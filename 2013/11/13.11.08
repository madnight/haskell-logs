00:03:42 <DarkFox> Anyone online mind checking my code for any suggestions? - http://ix.io/8WG/hs
00:05:54 <mornfall> 23 data Reply = ReplyX | ReplyY
00:06:33 <mornfall> DarkFox: that means you have a 2-element enumeration there, is that what you meant?
00:06:36 <DarkFox> mornfall: Oups
00:07:09 <mornfall> (incidentally, neither of those types have a self-named constructor, so it will probably compile :)
00:07:33 <DarkFox> mornfall: Wait.. It looks right..? Trying to get both ReplyX and Y to be of Reply type.
00:07:50 <arkeet> no, the way you wrote it, ReplyX and ReplyY are constructors (that take no arguments).
00:07:59 <DarkFox> Should I have data Reply = ReplyX ReplyX | ReplyY ReplyY ?
00:08:07 <arkeet> yes you could do that.
00:08:16 <DarkFox> :)
00:08:22 <mornfall> if you want a tagged union, yes, although I suspect it's not what you want :-)
00:08:42 <arkeet> heh
00:09:03 * DarkFox unsure if he is even going to use it yet .. But just trying to get a unified RFC for the protocol.
00:09:12 <DarkFox> unified as in client/server happy.
00:09:21 <DarkFox> Not just one :P
00:09:56 <mornfall> Well, from how those error codes work, I'd expect a product type, not a sum type.
00:10:11 <DarkFox> Hmm?
00:10:11 <mornfall> I.e. the (ReplyX, ReplyY, int) tuple you use.
00:10:39 <DarkFox> Oh
00:10:49 <DarkFox> What do you suggest in replace there?
00:10:52 <mornfall> DarkFox: Well, your sum type (the union) can contain *either* an X code or an Y code but not both.
00:11:03 <DarkFox> Oh
00:11:04 <DarkFox> Yes
00:11:54 <DarkFox> I guess Reply should be ... (Int, (ReplyX, ReplyY)) where Int is the original number.
00:11:59 <mornfall> You can either use the tuple you already do, or you could name it, data Reply = Reply ReplyX ReplyY Int
00:12:19 <DarkFox> Or just that
00:13:14 <mornfall> The latter is a little more type safe, as you can't confuse replies with other tuples of the same composition that aren't replies (that does seem unlikely though)...
00:13:28 <mornfall> But I'd consider naming your type to be a good practice regardless.
00:13:35 * DarkFox unsure still... (About that parser) Later on, for if it's just checking for success/failure which I already have with expectedResponses.
00:14:04 <DarkFox> ^ Kinda. I'm not checking which turple yet.
00:14:33 <mornfall> Also, you should prbably type-ify requests instead of using String.
00:16:55 <DarkFox> Yea - considered that but couldn't think for a name :P
00:17:38 <sopvop> does `!` has any meaning in newtype?, like newtype Foo a = Foo !a ?
00:17:58 <DarkFox> s/has/have/ sopvop
00:18:08 <sopvop> thanks
00:18:57 <DarkFox> 321 -- Just (Reply XPending YConnections 1)
00:18:59 <DarkFox> :-)
00:19:28 <DarkFox> mornfall: load in new tab for comparable update
00:19:35 <DarkFox> reload if you don't care for previous version
00:19:44 <zol> I love Haskell so much! It is so awesome, and Monads didn't feel strange at all!
00:19:52 <Feuerbach> sopvop: bangs are not allowed in newtypes
00:20:32 <DarkFox> zol: Haskell is XMonad, not AwesomeWM.
00:20:43 <DarkFox> But very much amazing :-)
00:21:00 <zol> DarkFox: Oh, right, thank you for the correction! (also, I love XMonad too, best WM ever!)
00:21:08 * zol grins.
00:21:08 <DarkFox> :-)
00:21:44 <edwardk> Feuerbach: if you wrote a module that exports a instance Foo Bar and instance Foo a;  then somewhere else you export instance Foo Baz, the compiler may or may not choose to let the Foo Baz instance fire.
00:21:51 <DarkFox> mornfall: No more suggestions for now?
00:22:34 <edwardk> Feuerbach: in general overlap only works correctly when all definitions involved are given in the same module
00:23:07 <sopvop> Feuerbach: Oh, I should have tested it first :) Thanks
00:23:10 <DarkFox> Oh if we have `map (\c -> ord c - ord '0')`, does this check what 0 is EVERY iteration? - I think yes.
00:23:25 <DarkFox> Unless optimizations clean that up?
00:24:08 <edwardk> DarkFox: the compiler could lift that out of the lambda, it probably won't
00:24:28 <DarkFox> So... parseReply = replyType . map (\c -> ord c - o0) where o0 = ord '0'
00:24:30 <DarkFox> it is
00:24:31 <DarkFox> :P
00:24:41 <edwardk> that will at least always work
00:24:53 <DarkFox> Yea
00:25:09 * DarkFox renames o0 to o
00:25:37 <DarkFox> Thanks edwardk & mornfall
00:25:47 <DarkFox> & arkeet
00:27:04 <DarkFox> zol: And to think that Haskell is as old as it is. Great high-level language.
00:27:55 <zol> DarkFox: I am so amazed by the things you can do in Haskell, and how concise it can be. Also, of course, some problems are better suited to other paradigms.
00:27:58 <Feuerbach> edwardk: interesting. is that documented anywhere?
00:29:49 <edwardk> https://groups.google.com/forum/#!topic/haskell-cafe/I38UV4B0QVw is a lament by SPJ about this sort of issue
00:29:51 * DarkFox likes how edwardk personified haskell's compiler. Chooses aye? More like, depending on a set of rules for how unexpected requiring some definition somewhere?
00:30:42 <DarkFox> Latter sentence heavily fragmented there...
00:34:23 * DarkFox goes back to SMTP RFC
00:35:56 * hackagebot instrument-chord 0.1.0.0 - Render Musical Chords on Instrument  http://hackage.haskell.org/package/instrument-chord-0.1.0.0 (AlanHawkins)
00:37:00 <vonDraco> How sexually mature do you have to be to learn about Monads?
00:37:16 <DarkFox> vonDraco: More than you to need to ask.
00:38:15 <vonDraco> Got it, thanks
00:39:27 <DarkFox> vonDraco: Damn Draco, your IP IS SO TINY
00:40:33 <vonDraco> Under the right conditions, it grows to succulent length.
00:40:56 * hackagebot instrument-chord 0.1.0.1 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.1 (AlanHawkins)
00:42:01 <DarkFox> Oh, curious for if there is any standard for writing RFC followed haskell libraries? I.e Naming convention exist? I've just got RFC5321.hs here.
00:42:19 * DarkFox expects to find an RFC on RFCs
00:42:49 <DarkFox> http://tools.ietf.org/html/rfc1111 :-)
00:44:00 <vonDraco> haha
00:50:58 * hackagebot concraft-pl 0.5.0 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.5.0 (JakubWaszczuk)
00:59:46 <Redz> if i have a polygon data structure who doesn't save a box (for collision detection), is it guaranteed, that this box will calculated only once, even if the build-a-box-function is called (with same parameters) multiple times?
01:00:20 <Ralith> certainly not in general
01:02:21 <zol> GHC seems to only have Graphics libs for Win32 included, can you use those on linux as well?
01:02:52 <DarkFox> zol: Are you refering to haskell-platform and not _GHC_
01:02:53 <DarkFox> ?
01:03:37 <DarkFox> Find the libraries included in haskell-platform, or simply install the whole haskell-platform.
01:03:42 * DarkFox rathers far more minimal :P
01:04:00 <zol> DarkFox: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/
01:04:25 <DarkFox> zol: Does that include the library you want?
01:04:33 <DarkFox> Oh.
01:04:41 <DarkFox> "Graphics.Win32"
01:04:51 <DarkFox> Heh. IDK dude :P
01:04:58 <zol> DarkFox: :D Thanks
01:05:40 <DarkFox> zol: If the library doesn't contain any Win32 requirements, it will compile on Linux. :-)
01:06:00 * hackagebot instrument-chord 0.1.0.2 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.2 (AlanHawkins)
01:06:05 <DarkFox> (Or if it contains but doesn't require because #if ... #else ... #endif etc.)
01:06:47 <DarkFox> xpika: Having fun there with Chords? Seen this thing pop up twice today. :-)
01:06:59 <DarkFox> Within the time for myself being online.
01:07:11 <DarkFox> 3 even
01:07:23 <xpika> DarkFox:  i did the silly thing of not testing it installed properly
01:07:31 <DarkFox> HA
01:07:32 <DarkFox> Nice
01:07:53 <pharaun> this may be dumb, but how do i do parameterized type function in which the function does not care what the type is?
01:08:51 <pharaun> oh nvm
01:12:43 <xpika> would be cool if lenses were included in the haskell platform
01:13:27 <johnw> not really
01:13:45 <johnw> the platform lacks a certain agility
01:13:55 <prophile> I'd also like to see zygohistomorphic prepromorphisms make their way in
01:15:49 <mm_freak> i'd like to see a few more algebraic structures and basic types make it into the base library
01:15:59 <mm_freak> Comonad, Stream, Semigroup, etc.
01:16:06 <prophile> free
01:16:10 <prophile> would be nice
01:16:33 <johnw> yeah, I agree with that
01:16:35 <mm_freak> perhaps, but i consider Free to be advanced enough to live in a separate library
01:16:40 <johnw> Semigroup is now my go-to algebraic structure
01:16:42 <Pholey> hello having some issues installing lambdabot... Im not entirely familiar with Haskell so the errors are a bit obscure to me: http://codepad.org/HnwEGswE
01:17:07 <mm_freak> 'streams' and 'comonad' are both very common dependencies for me…  i have almost no project without them
01:17:35 <hvr> johnw: ...woudl you make semigroup a superclass of monoid? :)
01:17:43 <johnw> you know I would
01:17:50 <hvr> hehe
01:18:03 <prophile> now that edwardk is the lord high librarian...
01:18:06 <prophile> who knows
01:18:16 <hvr> prophile: he'll bring us Lenskell
01:18:21 <mm_freak> the nice thing is, making Semigroup < Monoid is far less invasive than, say, Applicative < Monad
01:18:49 <supki> Pholey: that looks like you don't have enough ram or something
01:19:00 <supki> (judging from ExitFailure 9)
01:19:10 <mm_freak> class Semigroup a where (<>) :: a -> a -> a;  class (Semigroup a) => Monoid a where mempty :: a; mappend :: a -> a -> a; mappend = (<>)
01:19:44 <johnw> mm_freak: it's been debated quite a bit on libraries@, and was turned down ;(
01:19:57 <johnw> people think that including Semigroup would require bringing in a "universe" of Semi-specific functions
01:20:05 <hvr> mm_freak: nevertheless, there's still the issue that we need might want a "convenient" way to define a class + its superclass in one declaration
01:21:02 * hackagebot bert 1.2 - BERT implementation  http://hackage.haskell.org/package/bert-1.2 (RomanCheplyaka)
01:21:16 <mm_freak> johnw: the haskell community has proven to respond to these changes very quickly…  not sure why they're hesitating that much
01:21:42 <mm_freak> everybody wants more sensible abstractions, but nobody wants to make the change
01:21:43 <johnw> me either, but then, I haven't explored the ramifications either
01:22:01 <johnw> everybody wants to go to heaven, but nobody wants to make the trip
01:22:09 <mm_freak> the ramification is that lots and lots of libraries on hackage need to be adjusted
01:22:24 <mm_freak> hvr: i don't understand
01:22:33 <skaldarnar> :/quit
01:23:23 <hvr> mm_freak: it'd be nice to have a syntax-extension so that you could define 'class Monoid' and have it's super-class 'class Semigroup' be implicitly defined
01:23:44 <mm_freak> hvr: still not sure
01:24:00 <hvr> (by providing the superclass' 'mappend' method defined in the Monoid instance definition)
01:24:11 <mm_freak> ah
01:24:16 <hvr> it's been a point in the discussion, to easy the transition
01:24:20 <hvr> of adding superclasses
01:24:22 <mm_freak> you mean that every Monoid instance becomes a Semigroup instances as well
01:24:38 <prophile> that'd be interesting for Applicative => Monad
01:24:46 <hvr> yes, that is a 'instance Monoid' declaration would implicitly also define a 'instance Semigroup'
01:25:00 <mm_freak> but i'm not sure how that would work…  you would need to allow overlapping instances
01:25:11 <prophile> you could probably go the whole hog and Ord => Eq there too
01:26:13 <mm_freak> prophile: huh?
01:26:41 <hvr> mm_freak: it would be just syntax sugar for two instance definitions
01:26:43 <prophile> you could use such a mechanism to implicitly get an Eq instance from an Ord instance
01:27:49 <hvr> what prophile says is, that you could 'instance Ord Foo where { a (==) b = ..., compare a b = ... }'
01:28:10 <hvr> and have that implicitly define 'instance Eq Foo where { a (==) b = .. }
01:30:36 <mm_freak> i understand what prophile says…  i'm just not sure i agree about Eq/Ord =)
01:32:00 <hvr> mm_freak: what's the problem you see?
01:35:40 <mm_freak> hvr: nevermind =)
01:37:25 <hvr> btw, here's one of the proposals to that end: http://ghc.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances
01:37:47 <Pholey> Ok, im down to one error upon installing regex-tdfa-1.1.8.... http://codepad.org/QbJCBaqu
01:37:50 <Pholey> any ideas?
01:38:34 <hvr> Pholey: does that package use -Werror?
01:39:34 <Pholey> hvr: it is lambdabot i am trying to install, i am not familiar with haskell much.. i have been learning from "learn you a haskell"
01:39:45 <AshyIsMe> ooh twitter ipo was today
01:39:47 <Pholey> so to sum up the previous message, i have no idea
01:40:22 <Fuuzetsu> I'm investigating it. I _think_ it'd be solved be either using older array package or patching regex-tdfa to import the unsafe staff as per the message. I'm not sure why it just quits though, those are just warnings. Not sure what else to try.
01:41:05 <arkeet> ExitFailure 9
01:41:08 <hvr> in the long-term regex-tdfa needs to be fixed (if it isn't) as array-0.5.0.0 has the deprecated function removed
01:41:20 <arkeet> are you running out of memory?
01:42:07 <Fuuzetsu> hvr: It hasn't seen updates since 2011 it seems.
01:42:38 <Pholey> arkeet: would one gig be insufficient?
01:42:48 <arkeet> maybe!
01:42:55 <Pholey> i would think that troublesome if it was
01:43:03 <Fuuzetsu> Monitor your memory usage when compiling it, see what it's like.
01:43:16 <hvr> Fuuzetsu: and it got no constraint on array :-/
01:44:26 <Fuuzetsu> Damn it might actually be a memory problem
01:44:41 <Fuuzetsu> It's chewing through my RAM pretty badly. It's not quite in 1GB range though.
01:44:49 <Fuuzetsu> More like 400MB
01:44:50 <Pholey> fuuzetsu: it spiked up to 99 once, but it stayed around 50-80% of CPU for the most part
01:45:32 <Fuuzetsu> CPU doesn't really matter here. Maybe add some more swap?
01:45:43 <Fuuzetsu> Or give regex-tdfa some love ;)
01:46:42 <Fuuzetsu> Yeah, I can compile it fine on my netbook with more RAM available so it's almost certainly that.
01:46:54 <hvr> packages w/o open issue-trackers are .... :-/
01:47:32 <Fuuzetsu> I'm pretty sure it can be considered abandonware
01:47:40 <Fuuzetsu> hvr: Better yet, it's home page points to itself
01:47:42 <Fuuzetsu> its*
01:48:57 <hvr> regex-base is weird... it's hosted on sourceforge :-))
01:50:30 <arkeet> ExitFailure 9 usually means out of memory.
01:51:05 <Fuuzetsu> I wonder why it takes so much memory to compile it
01:52:22 <hvr> there's hope I guess, the author is on https://github.com/ChrisKuklewicz as well
01:52:24 <Pholey> ^
01:53:10 <Fuuzetsu> I'm not going to say anything because it's almost certainly going to meet with ‘we have a volunteer!’.
01:53:32 <Fuuzetsu> Also a commit 11 months ago is hardly being on the site.
01:53:42 <hvr> Fuuzetsu: it's not like volunteers are going be stoned =)
01:54:03 <Fuuzetsu> I have my own yaks to shave.
01:54:44 <hvr> ...is it already yak shaving day again?
01:55:30 <Fuuzetsu> Every day is the yak shaving day.
01:56:05 <Fuuzetsu> No brakes on the yak train.
01:59:02 <johnw> some days we're not programmers, we're yak farmers
01:59:51 <Rembane> Yaks are cute
02:00:51 * quchen should look up what this yak business is.
02:02:17 <Fuuzetsu> I wonder if there's an channel on some server dedicated to yaks and/or their farming, and I don't mean #haskell.
02:03:28 <mornfall> Fuuzetsu: #java?
02:04:22 <Fuuzetsu> I think they are still too busy piling on layers of farming-related tools on top of each other to do some actual farming
02:05:12 <quchen> Fuuzetsu: Here you go. http://www.reddit.com/subreddits/search?q=yak
02:05:32 <peddie> AbstractProxyFarmFactory
02:05:45 <hulahoop> Hello. I need to, but also want to, learn Haskell as my first language. I need to because it's the first language our professor teaches us, but I have trouble understanding it fast enough. For now I try my luck with Richard Bird's Introduction to Functional Programming using Haskell, but it doesn't really explain what Integers and Float is. I am that new to programming
02:06:18 <quchen> Integer = ℤ.
02:06:34 <quchen> Float = something we use in proramming that approximates reals.
02:06:59 * elliott suspects that answer to be not terribly useful to someone who doesn't know what "integer" is
02:07:11 <hulahoop> the whole numbers, okay
02:07:23 <Fuuzetsu> quchen: I don't go to ‘post the same yak over and over‘dit
02:08:33 <hulahoop> Sorry, try not to be a "help vampire" is there a starting point besides tryhaskell.org?
02:08:34 <quchen> hulahoop: You can think of floats as numbers in scientific notation, that's how they're stored internally.
02:08:57 <quchen> hulahoop: LYAH is a popular first book.
02:08:58 <quchen> @lyah
02:08:58 <lambdabot> Unknown command, try @list
02:08:59 <Fuuzetsu> hulahoop: learnyouahaskell.com is pretty good
02:09:01 <quchen> @where lyah
02:09:01 <lambdabot> http://www.learnyouahaskell.com/
02:09:06 <alexander__b> quchen: lyah assumes you know programming
02:09:16 <AshyIsMe> my hard copy arrived yesterday :)
02:09:20 <Fuuzetsu> alexander__b: Not a whole lot
02:09:24 <alexander__b> it's not going to be useful to someone who doesn't know what a function or an integer or a variable is.
02:09:33 <Fuuzetsu> AshyIsMe: IIRC the hard copy is missing the last few chapters
02:09:38 <Fuuzetsu> like the one on zippers or something
02:09:39 <quchen> I don't think LYAH assumes programming, despite it claiming so in the introduction.
02:10:05 <quchen> s//previous/
02:10:13 <AshyIsMe> hmm, it has up to chapter15 zippers
02:10:29 <alexander__b> I am rather convinced it's not a good starting point, when compared to things like learn python the hard way
02:10:38 <Fuuzetsu> AshyIsMe: Well, I'm pretty sure it's missing something compared to the online one, or it's re-arranged
02:10:41 <jalopezp1> the online version has up to chapter 14 zippers
02:10:53 <Fuuzetsu> my housemate has a hard copy around somewhere and it's different from the online
02:11:00 <alexander__b> Fuuzetsu: I think it's rearranged a bit, but it does have most of the things.
02:11:01 <Fuuzetsu> chapters moved around and merged or something
02:11:03 <AshyIsMe> ah yeap, no worries
02:11:04 <alexander__b> (if not all.)
02:11:12 <AshyIsMe> i have a bit of a fetish for hard copy books im starting to realise
02:11:30 <Fuuzetsu> hard copy is nice because you can stop staring at your monitor for a bit
02:11:31 <AshyIsMe> it's nice to hold a hefty book, and smell it
02:11:38 <AshyIsMe> smells like heavy knowledge haha
02:11:49 <hulahoop> thnak you very much.
02:11:59 <hulahoop> *thank
02:12:45 <quchen> hulahoop: I think as a beginner you can assume that when you need whole numbers Integer is the right choice, and for fractions and decimals etc. Float is alright.
02:12:56 <AshyIsMe> there's also Programming in Haskell which is supposed to be for people new to programming in general
02:12:57 <quchen> Double is alrighter, it's the same thing as Float, but with more precision.
02:12:59 <AshyIsMe> though i havent read it myself
02:14:05 <alexander__b> I'm in a c++ lecture. I miss haskell. a lot.
02:14:09 <AshyIsMe> oh according to amazon reviews it assumes a certain level of understanding
02:14:56 <alexander__b> I think it's more likely they'll find introductionary books for lisp than haskell.
02:15:34 <jorgno> Hello all. I'm having some problems creating a parser for a simulation program I have created in Haskell. The system reads JSON using aeson, but I need it to to be quite generic and I'm having some problems where GHC can't deduce that the type is correct, which I'm pretty sure it is. I have created a simple test program which has the same problem and is quite a lot smaller if anyone has the time to help me under stand why GHC can't deduce the types I thin
02:16:08 <Fuuzetsu> jorgno: Well, have you got a link to the paste?
02:16:20 <jorgno> http://lpaste.net/95389
02:16:48 <Rembane> jorgno: What error message do you get?
02:17:00 <jorgno> I know there is a problem in Main in that pase which is wrong, but I also get can't deduce "Signal s" in the parsing method
02:17:01 <Fuuzetsu> ambigous type
02:17:10 <Fuuzetsu> jorgno: Why not add type signatures?
02:17:43 <jorgno> Fuuzetsu: Are you refering to main?
02:18:05 <Fuuzetsu> jorgno: Sorry, ignore that.
02:19:03 <jorgno> Rembane: Here is the actual problem I get in my much larger program, but I think the paste above has the same problem: http://lpaste.net/95390
02:19:58 <jorgno> In my head the problem should be quite straight forward, but I think I'm using Haskell classes wrong or forcing it to behave a way it wasn't intended
02:20:00 <Rembane> jorgno: parseSimpleSignal returns Signal s
02:20:17 <Rembane> jorgno: It should return s
02:20:33 <jorgno> Rembane: But both SimpleSignal and OtherSignal are of type Signal(?)
02:20:41 <Rembane> jorgno: Check row 22
02:20:55 <Rembane> jorgno: Yes
02:20:55 <Fuuzetsu> jorgno: They aren't of type Signal. They are instances of the Signal class.
02:21:18 <Rembane> jorgno: But parseSignal returns s, not Signal s
02:24:51 <jorgno> I don't quite think I understand what you mean, doesn't the "(Signal s) =>" in the signature for parseSignal mean that s must be an instance of class Signal which both SimpleSignal and OtherSignal are?
02:24:53 <Rembane> jorgno: http://lpaste.net/95389 <- does this make sense? :)
02:26:26 <lpaste> pharaun pasted “Parameterized Types on Records?” at http://lpaste.net/95391
02:27:21 <pharaun> ^ I feel like i maybe missing something here? I'm getting data constructor not in scope so I wanted to check my understanding of parameterized types
02:27:30 <Fuuzetsu> jorgno: basically you're returning two different types from a function, they just happen to have the same instance
02:27:41 <jorgno> Rembane: No(?) =P Again I don't understand why it forces parseSignal to return SimpleSignal and not just any instance of Signal
02:28:18 <jorgno> Fuuzetsu: Can't I do that as long as I promise they can function as the instance I want to return?
02:28:41 <Fuuzetsu> probably with rank-whatever types but don't do that
02:30:07 <Rembane> jorgno: I'll hack something together, to clarify my thoughts. Hang on. :)
02:30:22 <jorgno> Fuuzetsu: Hm, ok, is there any place I could look for some inspiration for how to write my parser then, since I need it to be able to parse several different "Agents" which all should be interchangable in the rest of the simulator, at least they function that way currently
02:30:27 <pharaun> I feel like i'm missing something maybe with my records types
02:30:37 <jorgno> Rembane: Thanks =D
02:31:12 <Fuuzetsu> jorgno: Why not make Signal into a data type?
02:31:17 <Fuuzetsu> with OS and SS constructor
02:32:44 <jorgno> Fuuzetsu: Well in my other program I can't do that as my "Agent" must be extensible without extending a data type
02:32:50 <Fuuzetsu> disclaimer: I'm far past the point where I say legible things
02:33:05 <pharaun> oh never mind
02:33:11 <jorgno> Any help is much apreaciated as this is quite important to me =)
02:33:12 <pharaun> i finally got it to compile, so i think i got something that works :D
02:35:23 <Rembane> jorgno: http://lpaste.net/8639641253538955264
02:35:34 <Rembane> jorgno: There are some redundant $, but I really like dollars so...
02:36:32 <Fuuzetsu> re: rank types before, I actually meant existential quantification
02:36:37 * Fuuzetsu shuts up
02:36:44 <pharaun> yess
02:36:55 <mornfall> DarkFox: your isResponseExpected should work with Reply, not with numeric responses
02:37:06 <Rembane> jorgno: What about newtype?
02:37:44 <Redz> has someone read the haskell wikibook? i wonder how useful it might be for beginners.
02:38:16 <jorgno> Rembane: I'll check it out, that might work better
02:40:11 <jorgno> By the way here is the actual piece which complains, but it is not complete as it lacks all the other of my code, but it might help illustrate the problem http://lpaste.net/95392
02:40:36 <Rembane> jorgno: LYAH has some pretty good stuff about it.
02:41:36 <t4nk851> Hi I have a question, can someone possibly tell me how to import a module file that imports another module file.
02:41:45 <jorgno> Rembane: Thanks =)
02:41:54 <Rembane> jorgno: No worries. :) Good luck!
02:41:59 <johnw> t4kn851: you mean, in a cycle?
02:42:53 <t4nk851> yeah since when I try to import my file I get the error message "Could not find module 'Utilities', Use -v to see a list of the files searched for. Failed, module loaded: none"
02:43:10 <johnw> oh, that's a different problem
02:43:27 <johnw> i assume you're invoking ghc from the command-line?
02:43:40 <johnw> if so, you'll need a -i option to tell it which directory Utilities lives in
02:44:18 <t4nk851> oh ok so I'll need to write  -i after I've imported the .hs file
02:44:33 <johnw> that doesn't make sense
02:45:14 <t4nk851> Oh I'm sorry, pardon me, I mean after I've written the :l <destination> I'll add the -i at the end of the line?
02:45:33 <johnw> there is too much context missing for me to answer
02:46:13 <t4nk851> ah ok I'll try to explain in a better mannor if I can't figure it out. Thank you for your time johnw
02:47:48 <DarkFox> mornfall indeed, ill pach that up soon. offline for a bit
02:47:57 <DarkFox> thanks
02:50:07 <mornfall> np, bye
03:01:21 <DarkFox> Back mornfall
03:02:34 <DarkFox> mornfall: I'm not so sure for how to go about that acturally.
03:03:04 <DarkFox> I could compile all the numbers to their Reply's but that would be a bit counter productive.
03:05:26 <mornfall> DarkFox: where mk = map parseReply and sprinkle the list with mk's?
03:05:51 <mornfall> map (fromJust . parseReply) maybe
03:06:21 * hackagebot time-series 0.1.0.0 - Time series analysis.  http://hackage.haskell.org/package/time-series-0.1.0.0 (AtsuroHoshino)
03:06:49 <hpc> that doesn't type
03:06:57 <hpc> :t map ?f maybe
03:06:58 <lambdabot>     Couldn't match expected type `[a0]'
03:06:58 <lambdabot>                 with actual type `b1 -> (a1 -> b1) -> Maybe a1 -> b1'
03:06:58 <lambdabot>     In the second argument of `map', namely `maybe'
03:07:09 <mornfall> hpc: that was english maybe :-)
03:07:16 <hpc> oh
03:07:34 <merijn> mornfall: This is why I quote my inline haskell ;)
03:07:52 <mornfall> I actually lol'd when I read it back...
03:09:54 <donri> :t fmap ?f maybe
03:09:55 <lambdabot> (?f::((a -> b1) -> Maybe a -> b1) -> b) => b1 -> b
03:11:21 <hpc> i wonder, using only the base package
03:11:30 <hpc> what's the longest grammatical sentence you can write which typechecks?
03:12:10 <donri> > "something very long in deed"
03:12:12 <lambdabot>   "something very long in deed"
03:12:16 * donri ducks
03:12:31 <hpc> haha
03:14:53 <DarkFox> mornfall: parse just makes it work with strings
03:14:59 <DarkFox> The lists aren't strings :P
03:15:08 <DarkFox> So - replyType
03:15:19 <DarkFox> But doesn't compile
03:15:39 <DarkFox>     No instance for (Num [Int]) arising from the literal `321'
03:15:39 <DarkFox>     Possible fix: add an instance declaration for (Num [Int])
03:15:45 <DarkFox> Strange error...
03:16:14 <hpc> DarkFox: you're using a number as a list
03:16:30 <hpc> DarkFox: as it so happens, adding the instance it suggests makes lists into numbers
03:16:38 <hpc> but that's not actually the right solution, usually
03:16:54 <DarkFox> Yea :P
03:16:59 <DarkFox> I see
03:17:53 <DarkFox> Oh yea, mornfall I can't pass in the literal numbers because it's expecting [3,2,1] not 321
03:19:02 <DarkFox> I could stringify them / show but... Would that be ideal here? Not really, considering I deal with the literal numbers in the case.
03:19:43 <DarkFox> Only reason I still use strings where I do is because it will be pulled from the data stream as a String / ByteString when I get around to it.
03:24:09 <DarkFox> mod x 10 gets the 3rd number. :P
03:26:08 <DarkFox> oh just div lol
03:26:23 <DarkFox> for the first
03:27:15 <DarkFox> > [ [ a `div` 100, a `mod` 100 `div` 10, a `mod` 10 ] | a <- [321]  ]
03:27:16 <lambdabot>   [[3,2,1]]
03:27:20 <DarkFox> mornfall: ^ :P
03:28:20 <DarkFox> mornfall: I wouldn't call that efficient?
03:28:43 <epsilonhalbe> hey when looking at the data.list sources and find some strange notation/types (+#) and (I#) in the function `findIndices` can anybody tell me what this means - and can I use this with ghc?
03:30:02 <DarkFox> @hoogle Data.List
03:30:03 <lambdabot> Data.List module Data.List
03:30:03 <lambdabot> package List
03:30:03 <lambdabot> package ListLike
03:30:09 <DarkFox> @hackage Data.List
03:30:09 <lambdabot> http://hackage.haskell.org/package/Data.List
03:30:20 <DarkFox> lol
03:31:57 <DarkFox> epsilonhalbe: Strange indeed, I found the answer a while back - I'll try to dig it up again
03:32:24 <DarkFox> epsilonhalbe: http://www.haskell.org/haskellwiki/Keywords#.23
03:32:39 <DarkFox> Boxed-types
03:33:19 <epsilonhalbe> what exactly are boxed types - I've read the term a few times but this is the first time I ve stumbled upon them
03:33:33 <DarkFox> epsilonhalbe: Also - at the top of the source
03:33:34 <DarkFox> {-# LANGUAGE CPP, NoImplicitPrelude, MagicHash #-}
03:33:47 <DarkFox> http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html << Source that includes some socs
03:33:48 <epsilonhalbe> the magichash i've used
03:34:04 <DarkFox> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#magic-hash **
03:34:11 <DarkFox> Meant that one not the former
03:35:27 <malorie> is there a way to have parameterized modules?
03:35:46 <chrisdone> hpc: the closest thing i could get for a grammatical english sentence was: let in all reserved pathSeparators
03:35:56 <DarkFox> > let n = 321 in [div n 100, mod a 100 `div` 10, mod n 10]
03:35:57 <lambdabot>   [321 `div` 100,a `mod` 100 `div` 10,321 `mod` 10]
03:36:03 <DarkFox> Anyone here see any cleaner way to do that? ^
03:36:07 <DarkFox> Heh
03:36:12 <DarkFox> lambdabot: Why you no evaluate?
03:36:25 <chrisdone> it did
03:36:28 <DarkFox> "a" -> "n'
03:36:30 <DarkFox> I se
03:36:31 <chrisdone> > a
03:36:32 <lambdabot>   a
03:36:41 <DarkFox> > let n = 321 in [div n 100, mod n 100 `div` 10, mod n 10]
03:36:43 <lambdabot>   [3,2,1]
03:36:46 <DarkFox> There we go
03:37:04 <DarkFox> I typoed :P
03:37:36 * DarkFox can see that lambdabot as I, rathers the longer x `mod` n.
03:43:10 <malorie> or what should I do when all the functions in a module depend on a value, and I'd like to only provide that value once?
03:43:49 <DarkFox> malorie: Paramaterized modules?
03:43:58 <malorie> yeah, but how?
03:44:02 <DarkFox> Like import Module (XXX)
03:44:16 <DarkFox> You don't have functions in modules to run for exporting
03:44:25 <DarkFox> You import only what you need.
03:45:06 <DarkFox> import MyModule.SubModule (myFunc, MyType, MyConstructor(a,b,c))
03:45:18 <t7> > let f 0 = []; f n = f (n `div` 10) ++ show (n `mod` 10) in f 321
03:45:19 <bergmark> malorie: maybe the functions should run in a Reader
03:45:20 <lambdabot>   "321"
03:45:30 <t7> yey me
03:45:43 <DarkFox> t7: I have better... Never needs to be a string within the functions :-)
03:45:55 <DarkFox> Btw, I want split not.... show 321
03:46:00 <t7> yeah but i wrote show using show
03:46:07 <DarkFox> Indeed
03:46:16 <malorie> bergmark: can you be a bit more specific?
03:46:23 <t7> > let f 0 = []; f n = f (n `div` 10) : n `mod` 10 in f 321
03:46:25 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
03:46:26 <DarkFox> t7: Better idea, acturally write show
03:46:27 <bergmark> malorie: do you know Reader?
03:46:44 <t7> > let f 0 = []; f n = f (n `div` 10) ++ (n `mod` 10) in f 321
03:46:46 <lambdabot>   No instance for (GHC.Show.Show a0)
03:46:46 <lambdabot>    arising from a use of `M3076500191782...
03:46:50 <t7> stupid me
03:46:55 <malorie> afaik, it's a monad that allows its actions to read a certain value
03:47:15 <t7> > let f 0 = []; f n = f (n `div` 10) ++ [n `mod` 10] in f 321
03:47:17 <lambdabot>   [3,2,1]
03:47:38 <bergmark> right, so when using your module you would run the reader to set the value you want them all to have access to
03:47:45 <DarkFox> Okay..
03:47:50 <DarkFox> Well, how ? O_o
03:48:29 <malorie> makes sense. I'll see if I can come up with something :-)
03:48:40 <bergmark> malorie: see http://book.realworldhaskell.org/read/monad-transformers.html
03:49:59 <DarkFox> Ah
03:50:00 <DarkFox> I see
03:50:02 <DarkFox> t7: Nice
03:50:34 <Rulexec> @pl \f g a = f a (g a)
03:50:34 <lambdabot> (line 1, column 8):
03:50:34 <lambdabot> unexpected "="
03:50:34 <lambdabot> expecting pattern or "->"
03:51:05 <Rulexec> @pl \f g a -> f a (g a)
03:51:05 <lambdabot> ap
03:51:14 <t7> > let toBase b 0 = []; toBase b n = f (n `div` b) ++ [n `mod` b] in toBase 2 15
03:51:16 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr [a0])
03:51:16 <lambdabot>    arising from a ...
03:51:37 <DarkFox> t7: Get it any smaller? :D
03:52:53 <t7> > let toBase b 0 = []; toBase b n = toBase b (n `div` b) ++ [n `mod` b] in toBase 2 1337
03:52:55 <lambdabot>   [1,0,1,0,0,1,1,1,0,0,1]
03:53:13 <DarkFox> Sweet
03:53:16 <DarkFox> eh
03:53:34 <DarkFox> @hoogle toBase
03:53:35 <lambdabot> No results found
03:53:40 <DarkFox> @where toBase
03:53:40 <lambdabot> I know nothing about tobase.
03:53:48 <DarkFox> @which toBase
03:53:48 <lambdabot> Unknown command, try @list
03:53:51 <DarkFox> O_o
03:54:00 <DarkFox> Oh damn it. You defined it
03:54:01 * DarkFox should read more
03:54:10 <chrisdone> lol
03:54:16 <chrisdone> first word in the line says 'let'
03:54:16 * DarkFox facepaw
03:54:22 <DarkFox> chrisdone: XD
03:54:55 <Swenn> Yesod Question: http://lpaste.net/95395 How do I get the user Entity from the AuthId?
03:55:46 <DarkFox> Stupid hamlets
03:56:05 <t7> > let fromBase b [] = 0; fromBase b xs = last xs + (b * fromBase b (init xs)) in fromBase 2 [1,0,1,0,0,1,1,1,0,0,1]
03:56:07 <lambdabot>   1337
03:56:18 <DarkFox> Nice
03:56:37 <t7> redundant brackets ftw
03:56:39 <DarkFox> > let fromBase b [] = 0; fromBase b xs = last xs + (b * fromBase b (init xs)) in fromBase 2 [1,1,0,0,0,1,0,1,0,0,1,0,1]
03:56:40 <lambdabot>   6309
03:57:48 <Sagi> can I give lambdabot types and let it find out how to write a certain expression in point free style?
03:58:10 <Sagi> (the types corresponding to parts of the expression)
03:58:12 <dv-> @pl \a -> a
03:58:12 <lambdabot> id
03:58:24 <chrisdone> Swenn: use maybeAuth
03:58:37 <Swenn> chrisdone:
03:58:54 <Swenn> chrisdone: Lemme check that
03:59:04 <Sagi> @help pl
03:59:04 <lambdabot> pointless <expr>. Play with pointfree code.
03:59:07 <Swenn> chrisdone: Will it return a user?
03:59:44 <chrisdone> Swenn: yeah, e.g. maybeAuth :: Handler (Maybe (Entity User))
03:59:49 <DarkFox> Sagi: You can
04:00:01 <Swenn> chrisdone: Nice thanks!
04:00:07 <DarkFox> @pl MyRecord <$> a <*> b
04:00:07 <lambdabot> MyRecord <$> a <*> b
04:00:13 <DarkFox> :)
04:00:26 <chrisdone> Swenn: welcome. understandable you didn't find that. the type signature is hard to understand and the function isn't documented
04:00:30 <dv-> @pl \a b -> MyRecord <$> a <*> b
04:00:30 <lambdabot> ((MyRecord <$>) .) . (<*>)
04:00:40 <DarkFox> :P
04:00:50 <Swenn> chrisdone: True that
04:01:02 <Sagi> @pl verifyProperty c v n1 n2 = validateProperty v =<< computeProperty c n1 n2
04:01:02 <lambdabot> verifyProperty = flip ((.) . (.) . (=<<) . validateProperty) . computeProperty
04:01:08 <Swenn> chrisdone: Most of my time with Yesod has been figuring out types :P
04:01:24 <Sagi> ah, it's that mess again :o)
04:01:29 <DarkFox> Sagi: Half the time lambdabot doesn't know what it's doing, just understands enough function types and can figure out enough to clean it up :-)
04:01:36 <Sagi> thanks dv-, DarkFox :)
04:02:06 <DarkFox> If you give it valid code, it will either give you valid code or an error
04:02:14 <Sagi> :t (.) . (.)
04:02:15 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:02:24 <DarkFox> @pl \(a,b) -> [a,b]
04:02:24 <lambdabot> uncurry ((. return) . (:))
04:03:58 <Sagi> well, I gues that expression might get more clear from writing it point free. Or I have to resort to .: et al.
04:04:13 <Sagi> not*
04:05:58 <DarkFox> Remote vim / tmux switching </3
04:06:01 <DarkFox> Great normally
04:06:04 <DarkFox> But ping </3
04:06:36 <malorie> bergmark: the reader monad appears to be exactly what I was looking for. thanks, again :-)
04:08:44 <t7> anyone know of something like excel but strongly typed ?
04:09:53 <DarkFox> t7: Excel?
04:10:05 <bergmark> malorie: np!
04:10:30 <t7> i guess it wouldnt even be a speadsheet thing
04:12:11 <chrisdone> @tell dibblego fixed the raw link
04:12:11 <lambdabot> Consider it noted.
04:16:13 <prophile> in a sense excel is strongly typed
04:16:20 <prophile> due to having only one type
04:16:31 * hackagebot bert 1.2.1 - BERT implementation  http://hackage.haskell.org/package/bert-1.2.1 (RomanCheplyaka)
04:18:01 <donri> i guess "rich types" is a better term for some uses of "strong types"
04:18:47 <prophile> "rich" seems to be academic-speak for "verbose and poorly thought-out"
04:18:56 <donri> hah ok
04:18:59 <prophile> :)
04:19:16 <donri> "accurate types"? :P
04:19:21 <DarkFox> @pl  f [] = Nothing; f x = map parseReply x
04:19:21 <lambdabot> (line 1, column 7):
04:19:21 <lambdabot> unexpected " "
04:19:21 <lambdabot> expecting operator
04:19:26 <DarkFox> @pl let f [] = Nothing; f x = map parseReply x
04:19:26 <lambdabot> (line 1, column 7):
04:19:26 <lambdabot> unexpected "["
04:19:26 <lambdabot> expecting pattern or "="
04:19:39 <DarkFox> Oh yea lambdabot doesn't do that...
04:20:04 <prophile> DarkFox: that doesn't look well-typed anyway?
04:20:05 <DarkFox> Type is broken anyway
04:20:10 <DarkFox> prophile: Yea :P
04:20:12 <prophile> :)
04:20:53 * DarkFox can't get it typed even. lol
04:20:56 <prophile> :t mfilter (not . null)
04:20:57 <lambdabot> MonadPlus m => m [a] -> m [a]
04:20:58 <DarkFox> Too tired
04:21:15 <DarkFox> parseReply = Maybe Reply
04:21:19 <DarkFox> s/=/::/
04:21:29 <prophile> :t \x -> mfilter (not . null) (return $ map parseReply x)
04:21:30 <lambdabot> Not in scope: `parseReply'
04:21:31 * hackagebot ariadne 0.1.2.1 - Go-to-definition for Haskell  http://hackage.haskell.org/package/ariadne-0.1.2.1 (RomanCheplyaka)
04:21:37 <prophile> @pl \x -> mfilter (not . null) (return $ map parseReply x)
04:21:37 <lambdabot> mfilter (not . null) . return . map parseReply
04:21:46 <DarkFox> Well... parseReply :: Int -> Maybe Reply
04:21:53 <prophile> ah
04:22:04 <prophile> so you need sequence or something?
04:22:10 <prophile> :t sequence
04:22:11 <lambdabot> Monad m => [m a] -> m [a]
04:22:15 <DarkFox> Hope not lol
04:22:39 * DarkFox expected maybeSomething
04:23:10 <prophile> DarkFox: so what's the type of x?
04:23:20 <prophile> and what type do you expect f to return
04:24:14 <DarkFox> Not what I'm telling it to with maybe... lol
04:26:02 <DarkFox> Fixed
04:26:29 <DarkFox> f [] = []; f x = map parseReply x -- Modified parseReply so it's just .. parseReply :: Int -> Reply because impossible for Nothing :P
04:31:20 <hedb> Any function in GHC Haskell (with any extension) to "unsafely" force a term to have the user-provided type? Data.Data.cast is "safe" and requires instantiation of Data; I am looking for a function that can really fool the typechecker, e.g. (foolTC 'c') :: Int
04:31:34 * hackagebot language-pig 0.2.0.0 - Pig parser in haskell.  http://hackage.haskell.org/package/language-pig-0.2.0.0 (elisehuard)
04:31:38 <merijn> hedb: unsafeCoerce?
04:31:41 <merijn> :t unsafeCoerce
04:31:43 <lambdabot> Not in scope: `unsafeCoerce'
04:31:46 <merijn> eh
04:31:50 <merijn> @hoogle unsafeCoerce
04:31:50 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:31:59 <hedb> great!
04:32:04 <hedb> thanks
04:32:12 <merijn> hedb: Mind you, you better be damn sure the two are actually coercible
04:32:54 <merijn> hedb: Because if the memory layout of the two is not compatible, you *will* segfault
04:33:12 <DarkFox> *RFC5321> isResponseExpected "DATA" (parseReply 550)
04:33:12 <DarkFox> True
04:33:14 <DarkFox> Whoo
04:33:26 <DarkFox> mornfall: Done :-)
04:34:09 <DarkFox> mornfall: http://ix.io/8WN/hs
04:35:01 <donri> also, unsafeCoerce will pretty much always type check, so it's really easy to make silly mistakes
04:35:09 <DarkFox> Thanks prophile ^,^
04:35:16 <vijaykiran> from “filter doesn’t work on infinite lists” LYAH
04:35:28 <vijaykiran> but I just did filter odd [1,2..]
04:35:35 <vijaykiran> and it worked
04:35:38 <merijn> vijaykiran: heh, where does it say that in LYAH?
04:35:47 <merijn> vijaykiran: Because that's nonsense, filter works fine on infinite lists
04:35:48 <DarkFox> prophile: Didn't need the stupid sequence, map was what I needed
04:35:51 <DarkFox> :-)
04:35:57 <vijaykiran> "“We use takeWhile here instead of filter because filter doesn’t work on infinite lists.”
04:36:16 <merijn> vijaykiran: Can you give a link? I need context
04:36:20 <vijaykiran> possibly I misunderstood some contextual info
04:36:21 <vijaykiran> 1sec
04:36:35 * hackagebot burst-detection 1.0 - Burst detection algorithms  http://hackage.haskell.org/package/burst-detection-1.0 (AlexanderVershilov)
04:36:40 <merijn> vijaykiran: oh, actually
04:36:45 <merijn> vijaykiran: I can probably infer what he meant
04:36:58 <merijn> vijaykiran: Compare these two
04:37:02 <prinsen> Im writing a backend for OpenTables (YQL copy). These tables can contain a javascript portion that needs to be executed. Is there any work on translating javascript to haskell (quasiquoting)?
04:37:06 <vijaykiran> http://learnyouahaskell.com/higher-order-functions#function-application
04:37:09 <merijn> > takeWhile (<10) [1..]
04:37:10 <vijaykiran> just above the heading
04:37:10 <lambdabot>   [1,2,3,4,5,6,7,8,9]
04:37:11 <mornfall> DarkFox: map works on [] just fine
04:37:19 <merijn> > filter (<10) [1..]
04:37:26 <lambdabot>   mueval-core: Time limit exceeded
04:37:27 <DarkFox> Indeed it does
04:37:30 <mornfall> DarkFox: and the second equation can be eta-reduced
04:37:32 <merijn> vijaykiran: See the difference?
04:37:45 <vijaykiran> merijn: ah, it goes on forever
04:38:03 <donri> > take 20 $ filter (<10) [1..]
04:38:08 <vijaykiran> merijn: but it is the expected behaviour .. isn't it ?
04:38:10 <lambdabot>   mueval-core: Time limit exceeded
04:38:17 <merijn> vijaykiran: Basically, I'm guessing he was referring to the fact that "filter" can't ever stop (it has no logic to know that there can never be extra elements smaller than 10)
04:38:18 <DarkFox> mornfall: refering to duplicated processing of [250] ?
04:38:34 <vijaykiran> merijn: okay
04:38:37 <merijn> vijaykiran: Yes, and if you take only a finite set of a filter (as donri did) then it wroks fine
04:39:00 <donri> except it didn't, wtf? :P
04:39:18 <merijn> vijaykiran: But since haskell is lazy it can still make sense to filter infinite lists, as long as you don't think filter will make an infinite list finite
04:39:30 <donri> oh right
04:39:42 <merijn> vijaykiran: takeWhile will (sometimes, if the condition never stops takeWhile is infinite too)
04:39:52 <donri> you need take 9 there
04:39:52 <DarkFox> mornfall: ?
04:40:01 <donri> > take 9 $ filter (<10) [1..]
04:40:03 <lambdabot>   [1,2,3,4,5,6,7,8,9]
04:40:03 <merijn> donri: No, take 20 should work
04:40:12 <merijn> > take 10 [1,2,3,4,5]
04:40:13 <lambdabot>   [1,2,3,4,5]
04:40:15 <vijaykiran> merijn: agreed .. takeWhile (> 1) [2,3...]
04:40:28 <donri> merijn: yes but the 10th element is infinite recursion
04:40:38 <merijn> donri: oh, duh
04:40:38 <donri> [1,2,3,4,5,6,7,8,9^CInterrupted.
04:40:46 <merijn> donri: I'm silly :)
04:40:50 <donri> i was silly too
04:41:04 <DarkFox> mornfall: Reload
04:41:09 <merijn> vijaykiran: See donri's example for another place where filter fails :p
04:41:14 <merijn> Well
04:41:15 <DarkFox> mornfall: What do you think of that?
04:41:16 <merijn> "fails"
04:41:28 <merijn> It's to be expected when you think about it
04:41:30 <DarkFox> Doesn't even compile lol
04:41:33 <donri> so yeah, filter doesn't know when there are no more elements satisfying the predicate
04:41:50 <vijaykiran> I'm just above $ stuff :)
04:42:09 <vijaykiran> but, thanks guys, for the explanation.
04:42:27 <DarkFox> mornfall: Fixed
04:44:21 <DarkFox> mornfall: Oh eta-reduced... Where? O_o
04:44:30 <mornfall> DarkFox: f x = map parseReply x
04:44:37 <vijaykiran> BTW, when I ask emacs haskell-mode to generate the type for me it gives [Char] .. can I tell it to make it String  ?
04:45:40 <DarkFox> mornfall: I fixed that - reload :P
04:45:59 <DarkFox> mornfall: When you said second, I was looking higher as if second function defined.
04:46:08 <DarkFox> Noticed quickly after though
04:46:39 <DarkFox> mornfall: Was there any advantage for stdS or would that be compiler optimized eitherway?
04:47:27 <mornfall> DarkFox: don't think it's worth it as an optimisation
04:47:48 <DarkFox> Reverted
04:48:07 <mornfall> DarkFox: I'd also consider lifting 'f' out of the list into a map, not sure though :)
04:48:14 <mornfall> DarkFox: you could try and see what looks better to you
04:48:22 <DarkFox> Lifting it how?
04:48:34 <DarkFox> Oh
04:48:36 <DarkFox> I see
04:48:44 <mornfall> DarkFox: M.fromList $ map (\(x,(y,z)) -> (x, (f y, f z )))
04:48:47 <mornfall> ...
04:48:56 <mornfall> something like, anyway
04:49:22 <mornfall> bbiab, lunch
04:50:51 <DarkFox> mornfall: Was about to write that :)
04:51:04 <DarkFox> Well. Was typing when you said
04:51:37 * hackagebot language-pig 0.2.0.1 - Pig parser in haskell.  http://hackage.haskell.org/package/language-pig-0.2.0.1 (elisehuard)
04:52:35 <DarkFox> @pl Maybe x -> x -> x
04:52:35 <lambdabot> (line 1, column 11):
04:52:35 <lambdabot> unexpected '>'
04:52:35 <lambdabot> expecting operator
04:52:45 <DarkFox> @hoogle Maybe x -> x -> x
04:52:46 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
04:52:46 <lambdabot> Prelude asTypeOf :: a -> a -> a
04:52:46 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
04:53:11 <augur> DarkFox: Maybe x -> x -> x is a type
04:53:15 <augur> @pl works on terms
04:53:15 <lambdabot> works on terms
04:53:28 <augur> lol
04:53:39 <augur> @pl also repeats you
04:53:39 <lambdabot> also repeats you
04:55:14 <DarkFox> Hahaha
04:55:51 <DarkFox> augur: I meant hoogle not pl
04:56:03 <augur> well then :)
04:56:21 <DarkFox> @pl this is funny though $ :P
04:56:21 <lambdabot> (line 1, column 24):
04:56:21 <lambdabot> unexpected ":"
04:56:21 <lambdabot> expecting space or simple term
04:56:30 <augur> fromMaybe should be called default
04:57:21 <merijn_> maybe (that's a pun!) :p
04:57:57 <supki> default is a keyword
04:58:15 <merijn_> And the "def" is taken by Data.Default :p
04:58:57 <merijn_> Anyway I should probably get back to writing, rather than procrastinating on IRC
05:01:21 <DarkFox> Okay... expectedResponses :: M.Map Request ([Reply], [Reply]) -- How am I meant to filter this for if the response is expected for the Request given...
05:01:48 <DarkFox> isResponseExpected "DATA" $ parseReply "550"
05:01:56 <DarkFox> Which should be true
05:11:11 <Swenn> Yesod Question: How do you make forms with a many-to-many relation enitity?
05:20:52 <iLike> Swenn, many-to-many relations are modelled like: Entity1 --> EntityUser <-- User
05:21:53 <iLike> So there's a EntityUser table with 2 (or 3, for id) columns: EntityId and UserId, this couples many users to many entities.
05:22:26 <iLike> Now, if we want to add a new many to many relation into the database, all we need to do is add a row to the EntityUser table
05:23:03 <iLike> Swenn, do you understand that?
05:23:37 <Swenn> iLike: Yes! I got it! I've already figured it out but thanks anyway!
05:24:15 <iLike> Swenn, cool. You aren't making the assignment for the Function Programming course at the UU, aren't you? ;-)
05:24:46 <Swenn> iLike: UU? What's that?
05:25:05 <iLike> Swenn, never mind. I'm doing an assignment with Yesod which requires right that.
05:25:29 <Swenn> iLike: Ah alright :) Hehe, just kidding; Yeah me to :P
05:25:49 <iLike> Swenn, haha, how far along are you?
05:25:50 <Swenn> iLike: Horrible Assignment :P
05:25:51 <lpaste> alyx_ pasted “No title” at http://lpaste.net/95396
05:26:13 <Swenn> iLike: It's coming together now :) You're CS? Or AI?
05:26:15 <alyx_> any idea why that prints out nothing and just eats up memory?
05:26:45 <iLike> Swenn, yea, I agree. I'm CS. You
05:27:41 <Swenn> iLike: AI! The assignment only involves figuring out Yesod(Which I don't think is properly documented) and almost requires no programming logic... And this one's worth 40% ..
05:28:07 <iLike> Swenn, this assignment is WAY more difficult with MUCH less guidance than the previous ones, not really fair if you ask me
05:28:52 <iLike> Swenn, agreed on the not really documented part. There's so much functions in Yesod with little explanation, or none at all
05:29:08 <Swenn> iLike: True... I think a lot of people won't finish the course because of this. The assignment should have been to build a DSL
05:29:42 <iLike> Swenn, perhaps.. That would be hard as well though
05:30:03 <Swenn> iLike: It would be hard, but it would be educational
05:30:06 <iLike> anyway, we still have the onofficial deadline monday morning, ey?
05:30:29 <Swenn> Yep
05:30:45 <Swenn> Luckily Enough
05:30:57 <iLike> Swenn, good luck and have fun, I'm going to work on it once again
05:31:07 <Swenn> Same to you! Bye
05:31:50 <Philonous_> iLike, what's UU?
05:31:52 <supki> alyx_: you never write anything into Chan you are reading from
05:32:03 <iLike> Philonous_, university of utrecht
05:32:24 <Philonous_> iLike, And you have to write Yesod apps? Interesting.
05:32:37 <iLike> Philonous_, meh
05:33:08 <Philonous_> iLike, I mean, it's the first I've ever heard of a university buying into haskell that much.
05:33:23 <iLike> Like I said, the assignments went from: 'Look guys, this is a monad' to 'Hey write a Yesod app', without any explanation at all
05:34:08 <iLike> Philonous_, the course was pretty well taught though. Also, look at UHC, it's developed at the University of Utrecht
05:34:14 <bartavelle> as understanding monads is /obviously/ the hard thing about haskell, writing a simple web app should be nothing at all :p
05:34:47 <alyx_> supki: no, writing is happening. when I run it I get 100% CPU and the RAM usage of the process baloons, so there are obviously lots of "hello"s being written to the chan and stored in memory
05:34:52 <alyx_> the problem is that nothing gets printed
05:35:09 <supki> alyx_: yeah, you write to different chans
05:35:17 <iLike> bartavelle, well it's not that monads are the hardest thing about haskell, it's just that there was little help and explanation regarding monads and yesod
05:35:28 <supki> alyx_:  chan  creates a new Chan on each execution
05:35:48 <alyx_> ohhhhhh
05:36:10 <allsystemsarego> @src join
05:36:11 <lambdabot> join x =  x >>= id
05:37:56 <alyx_> so is there any way to keep the type of the function func1 the same, but having it use the same chan as the one in func2?
05:38:19 <alyx_> I don't want to have to pass round the chan as an argument everywhere
05:41:01 <donri> alyx_: there's the ugly way, or you could use e.g. Reader or reflection
05:42:08 <alyx_> donri: I'll look into those, thank you
05:45:29 <donri> alyx_: those do change the type though
05:46:12 <donri> alyx_: maybe look at https://hackage.haskell.org/package/safe-globals (i haven't used it myself though) which wraps up the "ugly way"
05:46:34 <donri> alyx_: but really, try Reader. :P
05:46:45 * hackagebot language-pig 0.2.0.2 - Pig parser in haskell.  http://hackage.haskell.org/package/language-pig-0.2.0.2 (elisehuard)
05:49:33 <alyx_> I'm curious, what would be the ugly way?
05:50:04 <donri> alyx_: the ugly way involves using unsafePerformIO and some tricks to make the compiler only run it once
05:50:46 <alyx_> eww
05:50:58 <donri> in deed
05:54:38 <donri> alyx_: however if you use Reader, you can use it to pass around anything you need, and abstract things to act in that environment. it all translates to functions, but you get a monadic vocabulary to work with
05:56:32 <donri> for example you could do, writeChan = flip Chan.writeChan =<< asks chan
05:56:45 <donri> and then you can do, func1 = forever $ writeChan "hello"
05:56:57 <donri> actually
05:57:17 <donri> writeChan = liftIO . flip Chan.writeChan =<< asks chan  -- or something like that
05:59:59 <prinsen> Anyone familiar with HXT parsing?
06:00:33 <prinsen> I have some troubles with missing attributes
06:01:56 <prinsen> noone?
06:02:52 <donri> prinsen: best just lpaste and state the problem
06:03:39 <prinsen> donri: ok!
06:05:16 <lpaste> Prinsen pasted “HXT Parsing” at http://lpaste.net/95399
06:06:07 <DarkFox> mornfall: http://ix.io/8WP/hs
06:06:19 <donri> prinsen: does this help? getMaybe a = (Just ^<< a) `orElse` constA Nothing
06:06:36 <yogsototh> Hi! Could someone be kind enough to explain me why foldr in GHC.Base is coded like this http://lpaste.net/95398   and what appear to me as a more common code style has been commented?
06:06:47 * hackagebot HsSyck 0.51 - Fast, lightweight YAML loader and dumper  http://hackage.haskell.org/package/HsSyck-0.51 (AudreyTang)
06:06:49 <donri> prinsen: make sure to use with an arrow that can in fact fail
06:07:20 <DarkFox> mornfall: http://ix.io/8WQ/hs *
06:07:21 <donri> yogsototh: inlining
06:08:09 <prinsen> donri: as the field id in the datastructure Im parsing isn't a maybe, I would like id not to be either
06:08:16 <exicer> I'm having some trouble understanding where the Either comes from in http://lpaste.net/95400
06:08:16 <donri> yogsototh: see second bullet point https://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#inline-noinline-pragma
06:08:20 <exicer> Could anyone help me out  ?
06:08:24 <yogsototh> donri: thanks!
06:09:06 <donri> exicer: in that case it's even easier: getAttrValue "id" `orElse` constA defaultValue, something like that
06:09:11 <donri> sorry, that was for prinsen
06:09:34 <exicer> donri: Fair enough!
06:09:37 <DarkFox> mornfall: http://ix.io/8WP/hs lol IX deciding to change it around a little.
06:09:46 <prinsen> donri: thank you
06:10:04 * DarkFox stops resending link...
06:11:03 <yogsototh> donri: thank you very much! It makes more sense now.
06:11:15 <donri> prinsen: oh you do want getAttrValue0 there
06:11:43 <donri> yogsototh: \o/
06:12:14 <donri> performance tuning, making your code ugly since ada lovelace
06:13:24 <chrisdone> DarkFox: black beauty, he's a dark horse
06:14:07 <donri> exicer: (now actually for you!) the Either comes from the Failure type class
06:14:16 <DarkFox> chrisdone: Indeed. Why you reference?
06:14:26 <chrisdone> DarkFox: it's a joke =p
06:14:33 <donri> exicer: https://hackage.haskell.org/package/failure-0.2.0.1/docs/Control-Failure.html
06:14:38 * DarkFox wonders the joke.
06:14:45 <donri> exicer: parseUrl :: Failure HttpException m => String -> m (Request m')
06:14:59 <chrisdone> DarkFox: http://www.merriam-webster.com/dictionary/dark%20horse
06:15:27 <DarkFox> So the underdog
06:15:42 <DarkFox> Of horses
06:15:47 <exicer> donri: Huh, I didn't know that. So I can choose what I want the failure instance to be with the type signature ?
06:15:51 <chrisdone> “a person who has interesting qualities or abilities that most people do not know about”
06:16:32 <DarkFox> chrisdone: I'm confused for the reference / joke still :P
06:16:33 <donri> exicer: with parseUrl from http-conduit yes. it's already specialized in your paste, though
06:16:36 <chrisdone> DarkFox: so one of your friends reveals after 5 years he can play the violin, you'd say "he's a dark horse, isn't he!"
06:16:52 <DarkFox> No, I wouldn't.
06:16:53 <DarkFox> :P
06:16:59 <exicer> donri: Oh, yeah I know - I have been trying to understand someone elses code :P
06:17:15 <chrisdone> DarkFox: you would if you were awesome
06:17:16 <donri> chrisdone: i can play the violin. i think we've known each other for about 5 years :p
06:17:57 <DarkFox> chrisdone: Nope. I'd probally go, sweet, wanna play something? :D
06:18:17 <chrisdone> donri: woah, you're a dark horse, aren't you? =p
06:18:38 <DarkFox> chrisdone: Your dictionary link contained a flash ad.
06:18:41 <donri> chrisdone: i was even quite good. haven't played in some 11 years though.
06:18:43 <chrisdone> what other secret talents does donri possess
06:18:47 <DarkFox> That flash ad took my cpu usage from 1% to 16%
06:18:52 <DarkFox> O_o
06:18:57 <chrisdone> DarkFox: this is my face caring: -_-
06:19:10 <DarkFox> No, that was mine
06:19:20 <DarkFox> Trying to steal my face aye!?
06:19:21 <chrisdone> LIKE MY JOKE
06:19:35 * chrisdone demands DarkFox likes his joke
06:19:36 <DarkFox> NO LIKE BUTTON
06:19:53 <DarkFox> NAhh, this is IRC.
06:19:57 * DarkFox +1 chrisdone 
06:20:08 * chrisdone beams
06:20:18 * DarkFox demands chrisdone writes the rest of this SMTP RFC.hs
06:21:31 <chrisdone> huh?
06:22:01 <chrisdone> sure you're thinking of the right chap?
06:22:33 <chrisdone> oh, you mean yours
06:22:35 <chrisdone> why are you doing that?
06:23:00 <DarkFox> chrisdone: Because I can. :P
06:24:16 <mornfall> DarkFox: you should shorten consistently
06:24:47 <DarkFox> chrisdone: And I want to have a set of RFCs for different protocols. Then to unify them into an event manager which could be used for a number of things. Packet filtering and logging, network bouncing, bridging protocols, detecting hilights on IRC and broadcast to clients listening for such event such as a phone app or XMonad module.
06:25:16 <chrisdone> with tcpdump?
06:25:22 <DarkFox> mornfall: ix.io - I delete the previous to re-post it. It doesn't always work, but generally I get the same ID back by doing that.
06:25:30 <mornfall> DarkFox: packet filtering is kinda unlikely, you need to make it stream-level
06:25:40 <DarkFox> chrisdone: No.
06:25:46 <mornfall> DarkFox: I mean resX vs Response
06:25:48 <chrisdone> DarkFox: Oh.
06:26:22 <chrisdone> donri: i've got sushi. what've you got?
06:26:30 <DarkFox> mornfall: resonse code X Y Z as denoted in the RFC for placeholders. :P
06:26:38 <donri> chrisdone: ulcerative colitis
06:26:43 <chrisdone> lol
06:26:56 <chrisdone> nearly spat my sushi
06:27:02 <donri> \o/
06:27:14 <DarkFox> mornfall: Maybe not "packet" but I meant moreso, data wise for what is traveling in the packets.
06:27:33 <mornfall> donri: ouch
06:28:22 <DarkFox> Protocol daemon that understands different protocols for administrative purposes. Also, for testing and relaying etc.
06:29:39 <DarkFox> Example. ZNC-like but silent, detect hilights and send an event off to clients listening for that event. So... IRC client connects to the daemon and speaks IRC. XMonad module connects the the daemon, speaks it's protocol and any hilights would be pushed as a notification. Thinking UDP for this protocol.
06:29:50 <DarkFox> UDP + SSL ... Might steal some work from mosh :P
06:30:46 <DarkFox> Mail RFC for now because thats one of the things I want to do from within IRC :P - BRIDGE
06:31:23 <DarkFox> mornfall: So... Any idea for this isResponseExpected function?
06:32:38 <mornfall> DarkFox: what's wrong with it?
06:32:53 <DarkFox> mornfall: It's commented bcause it's invalid :P
06:33:18 * DarkFox just switched gateways, hopefully won't have as many packet drops now.
06:33:28 <mornfall> DarkFox: doesn't seem to be very type correct
06:33:41 <DarkFox> mornfall: That's why it's commented :D
06:34:30 <DarkFox> Also, main reason I'm doing mail now is because IRC is way too damn long. :P
06:34:52 <mornfall> DarkFox: maybeToList gives you a list of lists in this context
06:35:07 <mornfall> DarkFox: so concat that?
06:35:09 <DarkFox> Indeed
06:35:47 <mornfall> (or join, if you like it that way :-)
06:36:24 <DarkFox> Ideally, I just want a single concat'd list with both success and failure. To check if it's in any. I can use resX => XPending to see if it's valid at all.
06:36:34 <DarkFox> Erm. Not valid, I meant successfull
06:37:31 <mornfall> ohwait :-)
06:37:36 <DarkFox> RAIN STOP KILLING MY UDP PACKETS D:
06:38:26 <mornfall> maybe False t $ M.lookup?
06:38:36 <DarkFox> O_o
06:38:44 <mornfall> t doesn't operate on lists
06:38:46 <DarkFox> .t ?
06:39:08 <mornfall> maybe False t is a function that gives False for Nothing and Just (t x) for Just x
06:39:28 <DarkFox> WOW
06:39:34 <DarkFox> Okay
06:39:52 <DarkFox> That's sweet :D
06:39:53 <DarkFox> Wait
06:40:06 <DarkFox> False for Nothing but Just for Just ? Did you mean True?
06:40:20 <mornfall> DarkFox: I mean t x for Just x sorry
06:40:28 <DarkFox> Yes, that makes sense
06:40:41 <mornfall> it's a fold over Maybe ;-)
06:41:11 <DarkFox> Yea
06:41:25 <DarkFox>    80 isResponseExpected s r = maybe False (==r) $ M.lookup s expectedResponses
06:41:54 <mornfall> DarkFox: you still need the t as you have it, I guess... unless you changed expectedResponses?
06:41:57 <DarkFox> Hmm
06:42:21 <DarkFox> Indeed
06:43:01 <DarkFox> Sweet
06:43:23 <DarkFox> Thanks
06:43:38 <DarkFox> Parsec time .... D:
06:43:40 <DarkFox> I think
06:44:04 <mornfall> DarkFox: check out attoparsec
06:44:07 <DarkFox> Parse and write...
06:44:18 <mornfall> also, walk time :) bbl
06:44:20 <DarkFox> mornfall: Was about to ask about if attroparsec would be better :P
06:44:25 <DarkFox> Aww
06:44:31 * DarkFox more like sleep time
06:44:32 <DarkFox> Sat Nov  9 01:33:23 EST 2013
06:44:33 <flo1> Hey, I made my first experience with mtl. I want to combine a Writer and a Error monad. So I built up this: http://lpaste.net/95401 — the problem is that the result of the writer monad is a tuple. I tried to apply the runErrorT only on the second value of the tuple using lenses. But this fails of course. I have no Idea how I can solve this
06:44:53 <mornfall> DarkFox: it's CET here ... 15:33
06:45:09 <DarkFox> Welcome to afterschool yesterday.
06:45:13 <DarkFox> -time
06:45:49 <DarkFox> Thanks again mornfall
06:46:25 * DarkFox will be off to bed - I'd stay but I'm on irssi and vim/tmux in the US while I live in the AUS with rain killing my packets :P
06:46:29 * DarkFox is off too
06:46:44 * DarkFox o/ mornfall Night man.
06:46:52 <mornfall> \o
06:46:55 <skypers_> hi
06:47:06 <skypers_> I’ve been wondering for a few days
06:47:16 <skypers_> is Network.Socket often used by anyone?
06:47:25 <DarkFox> skypers_: Yes, night.
06:47:39 <skypers_> I read the haddock page
06:47:52 <skypers_> the send and recv functions work with String, why?
06:48:06 <skypers_> what if I want to send or get a Float?
06:48:11 <skypers_> in C it’s possible
06:48:17 <skypers_> we can send the float
06:48:22 <skypers_> and read sizeof(float)
06:48:40 <skypers_> even if it’s not really advised :D
06:49:17 <skypers_> how does it work if you want to pass a serialized object through a socket in Haskell?
06:49:27 <skypers_> I actually expected ByteString
06:49:39 <skypers_> oh
06:49:48 <skypers_> Network.Socket.ByteString
06:49:55 <skypers_> that might be what I’m looking for
06:52:16 <supki> @ty runWriterT . runErrorT
06:52:18 <lambdabot> ErrorT e (WriterT w m) a -> m (Either e a, w)
06:52:25 <supki> flo1: ^ ?
06:52:37 <supki> @ty runErrorT . runWriterT
06:52:38 <lambdabot> WriterT w (ErrorT e m) a -> m (Either e (a, w))
06:53:04 <supki> flo1: look like you want the former composition of Writer and Error
06:56:19 <iLike> Is it possible to select on a non-monadic value in Persistent?
06:58:13 <flo1> supki: Thanks! Now I have: (Either BuildError (Mech,[String]))   — [String] should be warnings during the build — I combined runErrorT . runWriterT
06:58:37 <flo1> but is there a way to have: ([String], Either BuildError Mech) ?
06:58:48 <flo1> So I get the warnings in every case - even if it fails?
07:01:38 <flo1> supki: I updated the parse: http://lpaste.net/95401
07:02:41 <donri> flo1: invert the stack
07:03:59 <flo1> donri: you mean to have something like   — type MyMonadT e m = ErrorT e (WriterT [String] ) ?
07:04:31 <donri> yes
07:08:31 <yesthisisuser> Hi guys. I am trying to think of how to deal with state in a gtk2hs application...
07:09:27 <yesthisisuser> Let's say I have a button and want to interact with some state every time the button is pressed
07:10:02 <yesthisisuser> Is that even possible without using an MVar or IORef or similar
07:13:02 <yesthisisuser> I don't see how the State monad can be of any help in this case. Or can it?
07:13:34 <WraithM> I think it depends upon the context
07:13:41 <dv-> i thought IORef was standard
07:14:18 <quicksilver> you will need an IORef to pass information between the callback and the main program, yes
07:14:26 <quicksilver> (or between seaprate instances of the callback)
07:14:45 <quicksilver> you can still use a State Monad within the callback though
07:14:54 <quicksilver> (just wrap it in IORef read/writes)
07:15:03 <yesthisisuser> ok.. .hmm
07:15:22 <Brongue> can't you wrap the IO monad in StateT somehow?
07:15:37 <fronx> o/ hey. i am kind of a haskell noob and i'm trying to understand what exactly the cost/disadvantage of monads compared to functors is, given that functors compose generically and monads don't and require monad transformers.
07:17:28 <enthropy> fronx: functors have less operations possible
07:17:38 <fronx> so… i understand that that difference exists, and i have looked at Compose for functors. but i don't see how useful it really is to have a composition type. i can't come up with an example where you really need one.
07:18:28 <enthropy> right you can probably get by without Compose, since in your own code you can write (fmap . fmap) when you would need a single fmap if you used Compose
07:18:34 <fronx> enthropy: hey, thanks for responding. i also know that. but sometimes you kind of have a choice whether you want to use a monad or a functor, because you don't really depend on the monadness, but it might look more convenient or something.
07:18:40 <quicksilver> Brongue: you certainly can if you want but that still doesn't push it through the callback.
07:19:49 <fronx> enthropy: right. that's what's puzzling me. because if i don't really need it, then what's the big deal with the non-(generic-)composability of monads?
07:20:56 <mm_freak> fronx: since every monad is a functor, i don't even understand your question
07:21:34 <enthropy> probably it's not a big deal
07:22:45 <fronx> mm_freak: hehe… you know, it's hard to communicate something that may be based on a misunderstanding. :]
07:22:57 <mm_freak> fronx: that's possible =)
07:23:02 <mm_freak> fronx: (f ∘ g) a ≃ f (g a)
07:23:07 <enthropy> http://src.seereason.com/module-management/scripts/CLI/HaskelineTransAdapter.hs (together with stuff in Control.Monad.Trans.Control) is a pain to write just to be able to get two people's monad transformers to play together
07:23:08 <mm_freak> for all functors f and g
07:23:12 <fronx> mm_freak: yes…
07:23:26 <mm_freak> and this is expressed in the type:  newtype Compose f g a = Compose (f (g a))
07:23:34 <fronx> mm_freak: yup…
07:23:40 <mm_freak> as you see it's a /newtype/
07:23:47 <mm_freak> so the underlying representation is the same
07:24:13 <mm_freak> i.e. there is no immediate performance difference between Maybe [a] and Compose Maybe [] a
07:24:32 <mm_freak> a performance difference may come from RULEs firing for the direct composition but not for Compose
07:24:57 <quicksilver> except a programmer/text editor performance difference :)
07:25:10 <enthropy> you might spend more effort wrapping/unwrapping the newtype than you gain from writing less fmaps
07:25:52 <mm_freak> fronx: unless you are building an abstraction based on functor compositions it doesn't really pay off to use Compose
07:26:22 <fronx> mm_freak: okay. so far my understanding is consistent with what you said. i guess that's good. =]
07:26:59 <fronx> mm_freak: when people say, "if all you need is a functor, don't use a monad", isn't that kind of a moot point then?
07:27:16 <fronx> mm_freak: "because generic composability bla…"
07:28:27 <mm_freak> fronx: well, it's probably good to prefer fmap over liftM =)
07:28:53 <fronx> ( i don't know if it's useful to know that what motivated my questions was this talk: http://functionaltalks.org/2013/10/27/tony-morris-monad-transformers/ )
07:28:58 <enthropy> fronx: take a look at the code I linked. If features of InputT and CleanT could have been provided by Functor, it would have been nicer to have them as Functor
07:29:02 <mm_freak> but since through historical accident Functor is not a superclass of Monad sometimes it's just easier to use liftM
07:29:39 <fronx> enthropy: oh, didn't see your link earlier… looking now
07:29:51 <mm_freak> fronx: one elegant solution is to write representation-agnostic code
07:30:31 <mm_freak> instead of:  myComp :: WriterT [Log] (ReaderT Blah IO) Integer
07:30:57 <mm_freak> if you're only writing:  myComp :: (MonadWriter [Log] m) => m Integer
07:35:05 <fronx> mm_freak: (still thinking about your example…)
07:37:02 <fronx> mm_freak: is there a difference between representation-agnostic and generic?
07:39:04 <fronx> enthropy: so you're saying that even without the composition argument, a functor solution can lead to less clutter than one using monads?
07:39:34 <jrmithdobbs> so i'm working with this "rest"ful api written by perl devs that changes the type of search on an item based on transformation of the string of the key to be searched (ugh)
07:39:53 <enthropy> no that code is just an example of how you can have trouble composing monad transformers
07:40:13 <fronx> enthropy: okay
07:41:16 <jrmithdobbs> eg, /resource?key=val is a string compare, /resource?key:=val is a mapr . toLower $ myStr, /resource?*key~=val is a search on a special kind of param as a regex (the ~) ... anyways ...
07:42:01 <hamid> @src flip
07:42:01 <lambdabot> flip f x y = f y x
07:42:12 <hamid> @src flip (:)
07:42:12 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:42:14 <hamid> :P
07:42:41 <jrmithdobbs> so I have a recursive type i've created whose bases contain either a plain string or the *key special form and then has data constructors for regex/insensitive/not/gt/lt ... problem is not all those modifiers can actually be applied on all fields and i want the type system to check for me instead of waiting for a roundtrip from the (slow) service
07:44:03 <fronx> (thanks for the answers so far. maybe i just need to go back to constructing examples and see how the different abstractions compare.)
07:44:06 <jrmithdobbs> so using it works out like (OPnot (OPins (OPreg (OPstr "key")))) == key!:~
07:44:20 <jrmithdobbs> err "key!:~" and order of the postfix stuff doesn't matter
07:45:09 <jrmithdobbs> I've been trying to do it with GADTs but that causes some extra headaches in that the individual data constructors can no longer have the same records applied?! (I'm really confused by this, actually)
07:48:02 <mm_freak> fronx: "representation-agnostic" is a specific kind of "generic" =)
07:48:48 <fronx> mm_freak: so like… generic, but with type class constraints?
07:48:49 <jrmithdobbs> or in an easier way to say that, this: http://lpaste.net/95403
07:49:07 <edwardk> johnw: i'm not above making the change in the long term. i just think that this year we should focus rather heavily on non-breaking changes instead.
07:49:52 <mm_freak> fronx: i've really just invented a word
07:50:01 <fronx> mm_freak: lol =)
07:51:13 <shergill> edwardk: what change?
07:54:35 <edwardk> shergill: class Semigroup a => Monoid a
07:56:08 <shergill> ah yeah that would be nice
08:01:52 <jrmithdobbs> so i guess to better rephrase, I'm looking for a way to take this (and it's annotation) http://lpaste.net/95403 and move the functionality of condKeyToStr to take any of the other types and convert them down to a type witha  { plainKey :: String } record with all the transformations applied ... I guess I'm looking at a specialized constructor for a new member to the GADT and don't export that real constructor to users (but then it can't be patter
08:02:53 <jrmithdobbs> the end goal is this is a member of a specialized tuple type that's used to later generate a querystring
08:03:59 <jrmithdobbs> so you end up with effectively MyWrapper (CondKey String,String)
08:04:43 <jrmithdobbs> but i'm wanting that without having to write an individual extra pseudo "constructor" for each of OPreg,OPnot,...
08:04:46 <Rembane> jrmithdobbs: Implement the show-function yourself?
08:05:37 <jrmithdobbs> Rembane: but loses readibilty when debugging :(
08:05:46 <Rembane> jrmithdobbs: Oh.
08:05:47 <jrmithdobbs> Rembane: that was my first approach, actually, was a gad implementing show
08:05:53 <jrmithdobbs> s/gad/gadt/
08:06:14 <Rembane> jrmithdobbs: Haskell needs to get on the broadway and give more shows!
08:06:46 <jrmithdobbs> funny you say that as I'm using a URLShow later on ;p
08:06:51 <jrmithdobbs> to avoid using Show
08:07:20 <Rembane> jrmithdobbs: ^^
08:07:51 <Rembane> jrmithdobbs: I think one way to solve this is to build your own KeyShow-class which implements plainKey :: String
08:08:19 <jrmithdobbs> Rembane: ya but i really really want the transformed data inside the GADT definition itself :(
08:08:59 <jrmithdobbs> Rembane: because I need to implement some type restriction stuff in there too (not all those modifiers are applicable to all key types, eg, how do you >= a regex? heh)
08:09:18 <mm_freak> i've found the solution to all my problems!  ⊥!
08:09:21 <Rembane> jrmithdobbs: Well, there you lost me. :)
08:09:38 <jrmithdobbs> it's a bad api and i'm trying to work around it ;p
08:09:43 <jrmithdobbs> because i have to :(
08:09:58 <jrmithdobbs> (not the haskell gadts stuff, the reason for doing these stupid transforms in the first place)
08:10:05 <Rembane> jrmithdobbs: Can you make somekind of easier-to-chew data representation that is between what you have now and the string?
08:10:20 <jrmithdobbs> assholes should have just given me a param to post this data as json to insteado f mangling urlencoded lvals in query strings
08:10:23 <jrmithdobbs> </rage>
08:10:57 <Rembane> Sucky interfaces are great fun. :/
08:11:33 <jrmithdobbs> sadly, this is actually being easier solved in haskell than it was in ruby, you don't even want to see what builds that part of the query string in the ruby interface we wrote, lol
08:11:39 <Flonk> How do I go about defining a Monoid instance for the whole of Num? Neither (Num a => Monoid a) nor (Monoid (Num a)) seems to work.. (The former does with -XFlexibleInstances I think)
08:11:58 <vijaykiran> in this "on :: (b -> b -> c) -> (a -> b) -> a -> a -> c" a & b can be of the same types .. right?
08:12:07 <Rembane> vijaykiran: Yes
08:12:16 <Rembane> jrmithdobbs: :D
08:12:35 <donri> vijaykiran: c too
08:12:53 <vijaykiran> ah, so they don't mean that the a/b/c are distinct types
08:13:00 <vijaykiran> unless they are all 'a'
08:13:14 <jrmithdobbs> wait wait wait
08:13:52 <jrmithdobbs> can't I change that to take a (a -> b) func in the constructor, and always call it's stored func on itself to evaluate it's value?
08:14:00 <Rembane> vijaykiran: They can be three distinct types, but don't have to be.
08:14:20 <hvr> johnw: did you notice edwardk managed to make semigroups the package most downloaded ever? http://hackage.haskell.org/packages/top
08:14:45 <jrmithdobbs> or more specifically, can't I always take a (CondKey a -> String) function in the constructor
08:14:57 <Rembane> jrmithdobbs: Yes you can
08:15:01 <donri> vijaykiran: however the "on" function itself has to assume they're all different types, and in fact it can't assume anything at all about any of them really
08:15:10 <jrmithdobbs> let me play with that approach i think i can make that work
08:15:43 <vijaykiran> donri: hmm - I guess I sorta-kinda understand. Need to try out more on examples
08:18:03 <yesthisisuser> what exactly is a "functional dependency"?
08:18:46 <hvr> yesthisisuser: in the context of Haskell types: http://www.haskell.org/haskellwiki/Functional_dependencies
08:20:14 <donri> vijaykiran: for example `(\a b -> a) :: a -> b -> b` doesn't type check, but given `a -> b -> a` (which type checks) you can pass it two values of the same type just fine
08:21:18 <yesthisisuser> in this text is says "while pure functions can easily describe the transformation of one data structure into another, interactive and embedded applications have to
08:21:19 <yesthisisuser> deal with input and output living in a time domain"
08:21:37 <yesthisisuser> ... and describe temporal as well as functional dependencies
08:21:52 <remdezx> Hello! I want to use 0mq to send repa matrix from Haskell to C++ process. Protocol Buffers wants me to use a "Seq" data type, which has got method "fromList" - on the other hand repa uses unboxed vectors underhood. Is there a way to omit the conversion between them and send just unboxed vectors?
08:22:16 <int-e> @type interact
08:22:17 <lambdabot> (String -> String) -> IO ()
08:23:26 <donri> yesthisisuser: i don't think that's referring to FunctionalDependencies
08:23:36 <thirsteh> I thought I saw a script somewhere that looked at your cabal file and suggested new lower bounds for your packages. Was I hallucinating?
08:23:42 <donri> yesthisisuser: sounds more like they mean "behavior" or something
08:24:05 <donri> thirsteh: packdeps?
08:24:39 <yesthisisuser> donri: no.. it's a paper about FRP..
08:25:19 <thirsteh> hmm that might be what I was thinking of. The problem I have is I want to upgrade the dependencies I'm using to the latest versions without looking up each one's haddock and seeing which one is the latest / grepping in the ghc pkg metadata
08:25:37 <geekosaur> yesthisisuser, that would make it *more* likely they mean behavior
08:25:47 <int-e> interact (\xs -> "Please enter your name: " ++ let (name, xs') = span (/= '\n') xs in xs' `seq` "Hello, " ++ name ++ "!\n")
08:26:12 <thirsteh> (I understand that that is somewhat misguided, but my project isn't public and I just want to use the latest and greatest in my sandbox.)
08:26:17 <int-e> (the `seq` in there is annoying, but it is an interactive program specified by a pure function of type String -> String :-) )
08:26:40 <donri> thirsteh: there's some tool for diffing releases of cabal packages
08:26:53 <yesthisisuser> i don't understand the sentence.. what is depending on what.. hehehe?
08:27:08 * hackagebot unix 2.7.0.0 - POSIX functionality  http://hackage.haskell.org/package/unix-2.7.0.0 (HerbertValerioRiedel)
08:27:15 <byorgey> donri, thirsteh: http://hdiff.luite.com/ ?
08:27:16 <donri> thirsteh: diffcabal, precis
08:27:19 <ersran9_> In exercise for functors in typeclassopedia - Give an example of a type of kind * -> * which cannot be made an instance of Functor. I can't think of any examples. Any pointers?
08:27:36 <byorgey> oh, sorry
08:27:49 <donri> and hdiff sure
08:28:17 <yesthisisuser> geekosaur: yes i think they are referring to behavior.. i think it's just the terminology that is confusing me
08:28:25 <thirsteh> byorgey, donri: awesome, thanks
08:28:37 <byorgey> ersran9_: hint: it involves (->)
08:29:40 <Hermit> First of all, I don't mean to rant, at all. It's just that I've been asking myself a few things for a while now. Trying to figure out if haskell's approach is the best way to go. For example, effects separation. I know it's safer, but so far I also find it more rigid to program in. Not that I can't get the job done but it feels awkward, always trying to workarround the restrictions it imposes. For example,
08:29:42 <Hermit> not being able to define a global without doing IO had me refactor a whole lot of code into a Reader when I wanted to make it config file aware. Had to make an alterF, updateF, mapKeysM, and others when I needed to apply effectful updates (queries to filesystem) to a Map. I would have liked that these versions were part of the standard libs, but still, writing them would not be needed if there was no
08:29:44 <Hermit> sepparation of effects (but this compromises lazy eval). Sometimes in my ramblings I think inferred effects annotation instead of strict sepparation would be nicer in practice. Maybe I'm just missing a better way to work with all this?
08:32:56 <ersran9_> byorgey: but I was able to implement functor instance for ((->) a) , and I dont see any other possibility other than ((->) a) being of kind * -> * ... am I missing something really obvious here?
08:32:57 <mm_freak> Hermit: the problem is that you're reading "IO" as an annotation
08:33:00 <byorgey> Hermit: as you gain experience programming in Haskell you will find nicer ways to do these sorts of things, and nicer ways to organize your code so such things are not needed.
08:33:15 <byorgey> Hermit: but also, you're certainly right that there are other valid approaches than the one Haskell takes.
08:33:17 <mm_freak> Hermit: haskell gives you first class actions, which is a different way to program…  it needs tiem to get used to
08:33:23 <zol> What does the identify function?
08:33:26 <mm_freak> time
08:33:37 <mm_freak> zol: id x = x
08:33:37 <byorgey> zol: it returns its argument as output
08:33:54 <alexander__b> anyone have any idea on how to do a menu in gloss? I was thinking I could have two worlds (so the menu would be a gloss world), but IDK if it's plausible to trivially change between them.
08:34:11 <byorgey> ersran9_: yes, ((->) a) is a Functor
08:34:12 <zol> mm_freak: Hm.. Why do you want to use that? Why not just pass x instead?
08:34:20 <byorgey> ersran9_: there is one other possibility.
08:34:30 <byorgey> ersran9_: actually, more.
08:34:32 <alexander__b> the only solution I can think of right now is to have a Game that's a menu, and have that do if gameP then gameStep else menuStep, and the same for drawing and handling.
08:34:33 <mm_freak> zol: it's useful as an argument to some higher order functions
08:34:37 <ersran9_> oh
08:34:41 <Hermit> indeed, it's been months and I don't feel as productive as with a few lesser languages I used to use (which I mastered in far less time)
08:34:42 <byorgey> but you will need to use a type synonym or a newtype
08:34:44 <triliyn> alexander__b: maybe you could use as your world type Either Menu World
08:34:44 <zol> mm_freak: Aha, thanks
08:35:17 <triliyn> So that your evolution function can return Left menu or Right world depending on input
08:35:24 <mm_freak> alexander__b: using the simulation/game interface a menu shouldn't be much of a problem
08:35:49 <triliyn> hmmm, you'd need somewhere to keep track of the world though
08:35:51 <yesthisisuser> zol: You can find some examples here: http://stackoverflow.com/questions/3136338/uses-for-haskell-id-function
08:36:07 <Hermit> and I sometimes get scared when I check some code and it uses some strange typeclasses I have yet to learn. Endo, MonadPlus. Last time I grabbed some doc I was figuring out my way with Arrows
08:36:09 <mm_freak> alexander__b: except that gloss offers no widgets by itself, but having two interfaces to switch between should be easy enough
08:36:10 <alexander__b> triliyn: what about when the game has started? if I make the game with main = menu, where menu makes uses play -- how do you init the world?
08:36:15 <triliyn> Maybe (Menu,World) would be better and then there would just be a control that chooses between them
08:36:25 <alexander__b> mm_freak: if it's so easy, feel free to suggest how to do it
08:36:30 <Iceland_jack> zol: Another use is for stating laws: 'f ∘ g = id'
08:36:40 <mm_freak> alexander__b: are you using FRP?
08:36:41 <zol> yesthisisuser: thank you
08:36:49 <alexander__b> mm_freak: not ATM, no.
08:37:12 <mm_freak> alexander__b: then you need to encode the current state manually in the world state type, e.g. "game running, but currently in the menu"
08:37:17 <alexander__b> triliyn: I don't understand how this solves anything.
08:37:44 <alexander__b> mm_freak: well I do that. as I said, that's my current solution. and then do step = if gameP then gameStep else menuStep, etc
08:38:07 <triliyn> alexander__b: what I meant is basically what you're doing, so I guess I don't have any better ideas
08:38:27 <mm_freak> alexander__b: that's the traditional global-state way to do it…  if that's how you do it, i don't understand your question
08:38:54 <mm_freak> alexander__b: looking for an improvement?
08:39:00 <alexander__b> mm_freak: my question is if there's a better/easier way to do it with gloss. like having two worlds and being able to change between them,.
08:39:23 <mm_freak> alexander__b: gloss itself won't help you there
08:39:39 <alexander__b> mm_freak: that's the conclusion I'm beginning to come to terms with, yes.
08:39:55 <mm_freak> alexander__b: you should consider switching to FRP
08:40:00 <mm_freak> that gets rid of the global state approach
08:41:10 <alexander__b> mm_freak: I don't really know FRP. there's this guy who wants to contribute to the project who's "FRPising" the game at this time, so maybe he'll come up with something that can help us.
08:41:52 <mm_freak> alexander__b: well, gloss' sim/game APIs are almost directly compatible with AFRP
08:42:06 <mm_freak> so this might be the time to learn netwire or yampa =)
08:42:29 <triliyn> AFRP?
08:42:38 <alexander__b> mm_freak: he's using netwire. I thought I'd take his patches as an opportunity to dive head first into netwire and frp. I have read a lot on frp, including reactive-banana's great "what is frp" doc.
08:42:58 <mm_freak> triliyn: Arrowized FRP, a term i don't really like
08:43:08 <mm_freak> FRP = Functional Reactive Programming
08:43:19 <triliyn> hmm
08:43:23 <mm_freak> alexander__b: feel free to ask questions…  i'm the author of netwire =)
08:43:42 <alexander__b> mm_freak: do you have a link for complete newbies who are newbies to haskell as well? :-P
08:44:15 <triliyn> I've only seen one recent-ish FRP library that used arrows, and because of the way arrows worked it had to traverse the entire network-tree-thingy even if there was nothing to do
08:44:17 <mm_freak> alexander__b: try reading this:  http://hub.darcs.net/ertes/netwire
08:44:34 <mm_freak> alexander__b: as a haskell beginner you may hit a few bumps, in which case you may revisit LYAH/RWH/…
08:44:49 <triliyn> Because the compiler can't tell the difference between arr (\_ -> blah) and arr (\f -> blih f)
08:45:02 <mm_freak> triliyn: there are basically two approaches to FRP
08:45:33 <mm_freak> reactive-banana/sodium:  update/push-based for propagating information
08:45:49 <mm_freak> netwire/yampa:  real-time scene calculation for simulations and games
08:46:08 <mm_freak> one interesting thing to note is that you can actually combine sodium and netwire easily
08:46:16 <triliyn> o.o
08:46:20 <triliyn> hmm
08:46:40 <mm_freak> so you can use the advantages of both concepts
08:46:43 <yesthisisuser> my main question about FRP in Haskell right now is how well they work with the different UI toolkits
08:47:09 <triliyn> What is "arrowised"?
08:47:10 <mm_freak> yesthisisuser: reactive-banana and sodium are toolkit-agnostic
08:47:26 <mm_freak> triliyn: "uses arrows"
08:47:38 <triliyn> mm_freak: ah, that's what it sounded like
08:48:30 <yesthisisuser> I have played around with Elm.. and I really liked it.. It looks like there is slightly more "steep" learning curve for Haskell FRP libraries however
08:49:03 <thirsteh> Anyone have any tips on compiling something that depends on pcre, e.g. pcre-light on Windows (x64)? I've tried mingw/tdm-gcc, cygwin, and I can't for the life of me get cabal/ghc to actually detect that the bindings are there (even with the pcre headers installed and pointing to the custom include/lib dirs)
08:49:06 <mm_freak> the rule of thumb is:  if your toolkit uses an event loop and rebuilds the scene at every instant (games and simulations), you should use AFRP
08:49:45 <mm_freak> if your toolkit is based on callbacks or events only come in as the user does stuff, and each event only changes a small portion of the scene (widget GUIs), then use push-based FRP
08:51:28 <mm_freak> finally FRP is not only for UIs…  my first experiment with sodium was a small IRC bot
08:51:46 <mm_freak> and netwire was originally written for community/game servers
08:51:58 <mm_freak> (hence its name)
08:54:11 <ersran9_> type Foo a = Foo (a -> Int) <= is this the answer for type of kind * -> * that cannot be made into a functor?
08:55:02 <supki> s/functor/Functor/
08:55:05 <supki> but yes
08:55:12 <ersran9_> :D
08:55:16 <ersran9_> but why the capital?
08:55:38 <supki> because Functor is specifically for covariant functors
08:56:13 <mm_freak> Functor is specifically for covariant endofunctors on Hask =)
08:56:21 <ersran9_> .. :(
08:58:19 <mm_freak> ersran9_: ignore me, i'm just joking
08:58:29 <triliyn> ersran9_: a Functor is a haskell concept that basically means "something that can yield one or more results in some context"
08:58:49 <triliyn> Without the capital it is a more general mathematical concept
08:59:09 <ersran9_> oh, I see.
08:59:20 <triliyn> Which also includes contravariant functors (a subset of which are represented by the haskell typeclass Contravariant), which are just things that can consume results
08:59:44 <triliyn> fmap on a contravariant functor (which I think is called comap or something) has a type like this:
09:00:02 <triliyn> Contravariant f => (a -> b) -> f b -> f a
09:00:05 <danharaj> contramap
09:00:15 <danharaj> if you are using the contravariant library.
09:00:21 <triliyn> It takes a function from a to b and a contravariant that can eat things of type b
09:00:38 <triliyn> And returns a contravariant that can eat things of type a by first applying the function
09:11:37 <bz> @search monad.reader
09:11:37 <lambdabot> Unknown command, try @list
09:11:51 <bz> anyone know of an up-to-date archive of the monad reader?
09:12:58 <bz> nvm
09:13:46 <rasfar> since you sent me searching: http://themonadreader.wordpress.com/previous-issues/ :-p
09:14:54 <donri> mm_freak: so why isn't nw5 on hackage yet? :)
09:15:11 <edwardk> hvr: hah
09:15:27 <bz> rasfar: yeah, just finished scraping that one
09:16:27 <mm_freak> donri: because work is preventing me from running a few final tests =/
09:16:28 <hvr> edwardk: ...admit it, you've got a cronjob that 'curl's the semigroup tarball ;-)
09:16:35 <donri> mm_freak: okies
09:16:51 <mm_freak> donri: if you're waiting for it, i can do it later
09:16:57 <intrados> Is there a way to declare typeclass functions visible only to instance declarations? Something that would make this work? http://lpaste.net/95409
09:17:01 <edwardk> nah, I just strategically bump the version number at the right times and the crowd will do it for me. ;)
09:17:05 <donri> mm_freak: nah, no hurry
09:21:03 <sirspazzolot> LYAH: "That's why in an I/O do block, ifs have to have a form of [if confition then I/O action else I/O action]." why must both results be I/O actions?
09:21:37 <rasfar> intrados, I don't know, but I suppose if they're only to be visible to the typeclass, you could make them regular functions and not export them from the typeclass's module?
09:21:50 <triliyn> sirspazzolot: if...then...else... is an expression, and it has to have a single type
09:22:14 <sirspazzolot> triliyn: oh, okay. right.
09:22:15 <sirspazzolot> thank you
09:22:28 <zol> triliyn: Thanks, didn't know that! :)
09:22:39 <zol> Oh, wait, I did. Sorry.
09:22:54 <Flonk> In my three months of Haskell programming I never felt the need to do IO or any of that Monad jazz until now. Right now I'm resorting to `fix' and `(>>=)' and in general the IO part is a bit of a mess.. basically I want to read lines from stdin and do stuff with each line unless getLine returns "quit". How would I best go about that?
09:23:17 <zol> Flonk: Use Do notation
09:23:36 <zol> Flonk: http://en.wikibooks.org/wiki/Haskell/do_Notation
09:23:54 <Flonk> zol: The main problem is the recursion part.. Is there something like while-loops for monads?
09:24:02 <zol> Flonk: Yes
09:24:05 <zol> Flonk: Until
09:24:11 <Flonk> :t until
09:24:12 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
09:24:17 <identity> @hoogle untilM
09:24:17 <lambdabot> No results found
09:24:42 <simpson> Flonk: Instead of a while-loop, you can always just have a recursive loop that calls itself.
09:24:53 <donri> @src forever
09:24:53 <lambdabot> Source not found. That's something I cannot allow to happen.
09:25:09 <sirspazzolot> Flonk: there's more or less an example given in the I/O section of Learn You A Haskell
09:25:12 <donri> @src interact
09:25:12 <lambdabot> interact f = do s <- getContents; putStr (f s)
09:25:21 <Flonk> simpson: my main function is using fix and it feels pretty wrong
09:25:42 <Flonk> sirspazzolot: Yeah I guess I should read through that
09:25:55 <donri> there's mfix/fixIO, not that you need it
09:26:04 <simpson> fix seems like a weird way to do IO.
09:26:16 <sirspazzolot> Flonk: if only the I/O part. it's a nice description of how it's in a sense containing the 'impure' I/O operations. it's helping me, anyway
09:26:34 <sirspazzolot> http://learnyouahaskell.com/input-and-output#hello-world
09:26:41 <rasfar> Flonk, great timing, I'm trying to do the same thing... I've always done what simpson suggests in the past, but thought I'd try a more compact style this round.
09:27:40 <Flonk> :t fixIO
09:27:42 <lambdabot> Not in scope: `fixIO'
09:27:56 <Flonk> I feel like do-notation is being overused quite a bit
09:27:56 <donri> :t System.IO.fixIO
09:27:58 <lambdabot> (a -> IO a) -> IO a
09:28:29 <identity> Flonk: Something like forever do { line <- getLine; when (line == "quit") exitSuccess; doSomeStuff }
09:28:54 <enthropy> @type interact
09:28:55 <lambdabot> (String -> String) -> IO ()
09:29:03 <mm_freak> Flonk: main = do l <- getLine; if l == "quit" then XXX else stuff >> XXX
09:29:16 <enthropy> for whatever reason I thought it gave you lines
09:29:21 <mm_freak> oh, sorry…  i was way up in my scrollback =)
09:29:32 <mm_freak> i guess the question is already answered =)
09:29:36 <geekosaur> it's common to wrap lines and unlines...
09:29:44 <moops> how do i "show" Sublime Text/SublimeHaskell how to build my project (im using cabal)? all the tutorials seem like it happens automatically if you create a cabal file, but i already have one
09:29:46 <triliyn> enthropy: interact gives you one line at a time, I think
09:29:55 <donri> can't really do IO with interact though, so no exitSuccess
09:30:07 <identity> moops: Cabal takes care of building your project according to your .cabal file
09:30:22 <moops> i can build it from the command line
09:30:23 <Flonk> mm_freak: I'm happy about suggestions :P 2 minutes of #haskell and I have 100 new functions to check out
09:30:25 <dv-> :t Control.Monad.Loops.iterateUntil (== "quit") getLine
09:30:26 <lambdabot> IO [Char]
09:30:30 <mm_freak> 'interact' feeds in chunks of whatever is specified in the buffering mode
09:30:34 <donri> triliyn: interact gives you one character at a time, and how that's read depends on how stdin is buffered
09:30:40 <moops> but SublimeHaskell purportedly can do it automatically when you save
09:30:44 <moops> but i cant figure out how
09:30:44 <mm_freak> main = hSetBuffering stdin NoBuffering >> interact f
09:30:44 <enthropy> triliyn: it doesn't though... but you can easily   interact (f . lines)
09:31:06 <triliyn> hmmm, okay
09:31:35 <mm_freak> Flonk: i was about to provide a way to think of recursion i like to teach to beginners =)
09:31:48 <mm_freak> theProgram = do l <- getLine; …; XXX
09:31:53 <triliyn> So if you do something like interact (show . length), does that just print a 1 for every character in the input?
09:31:55 <mm_freak> at XXX you want to run the program over again
09:31:59 <triliyn> I should just test it myself
09:32:06 <mm_freak> so what's XXX?  it's theProgram =)
09:32:23 <kuznero> Hi All!
09:34:11 <Flonk> mm_freak: Yeah, thats a pretty cool way to do it. Completely forgot about (>>)
09:35:00 <Sculptor> yo
09:35:22 <mm_freak> Flonk: as your question was about while-loops, the answer is a lie:  "no, there are no while-loops"
09:35:43 <mm_freak> i mean:  the proper answer is to lie and say no =)
09:35:59 <triliyn> mm_freak: also, I've been looking at this netwire thing and it looks pleasant
09:36:02 <moops> nvm, this thing is useless
09:36:13 <moops> i get compiler errors where i dont on the command line
09:36:18 <moops> it cant find any definitions
09:37:08 <mm_freak> triliyn: i recommend netwire 5…  i'll upload it on hackage soon
09:37:37 <mm_freak> triliyn: http://hub.darcs.net/ertes/netwire
09:38:03 <Flonk> mm_freak: I vaguely remeber a function called forM or forM_ though, I thought maybe something like this is what I'd need
09:38:11 <rasfar> > reverse $ takeWhile (<=256*256) $ [2^i | i <- [0..]]
09:38:12 <lambdabot>   [65536,32768,16384,8192,4096,2048,1024,512,256,128,64,32,16,8,4,2,1]
09:38:15 <triliyn> Flonk: forM is just flip mapM
09:38:20 <rasfar> any slicker way to do that?
09:38:41 * rasfar is looking at for / forM in fact
09:38:53 <Flonk> triliyn: Well, I guess that makes sense
09:38:58 <mm_freak> Flonk: mapM_ and forM_ are pretty much "foreach"
09:39:01 <dv-> http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html
09:39:13 <triliyn> [2^i | i <- [256*256, 256*256-1, .. 0]] ?
09:39:18 <dv-> ^ has a whileM
09:39:24 <triliyn> > [2^i | i <- [256*256, 256*256-1, .. 0]]
09:39:25 <lambdabot>   <hint>:1:34: parse error on input `..'
09:39:32 <triliyn> > [2^i | i <- [256*256, 256*256-1 .. 0]]
09:39:32 <rasfar> not quite...
09:39:34 <lambdabot>   [20035299304068464649790723515602557504478254755697514192650169737108940595...
09:39:38 <rasfar> hahaha
09:39:39 <triliyn> ...hmmm, right
09:39:48 <rasfar> something using fix would be cool
09:39:54 <triliyn> Yeah, I see what I did wrong XD
09:39:56 <rasfar> thanks dv-
09:40:10 <triliyn> You could fix it with like log2 maybe?
09:40:25 <rasfar> hmm nice though tx
09:40:30 <rasfar> *thought
09:40:31 <triliyn> I don't know though... that doesn't seem like the right way to go
09:40:33 <mm_freak> Flonk: in haskell mapM_ is used for only a small subset of the things you would use "foreach" for in other languages
09:40:48 <mm_freak> for example to print list elements to the terminal for debugging =)
09:40:52 <rasfar> not in the longrun probably, but for the sake of trying new stuff
09:41:11 <mm_freak> and i strongly recommend ignoring the monad-loops package…  it will mislead you
09:41:17 <mm_freak> and IMO it shouldn't exist
09:41:26 <rasfar> oh? wow strong words
09:42:12 <mm_freak> with reason
09:42:51 <mm_freak> beginners don't benefit from it, because it will be a frustrating, misleading experience that leads away from idiomatic haskell into trying to write python in haskell
09:42:53 <rasfar> it does have the sound of package which would attract newcomers used to imperative idioms
09:43:12 <srhb> rasfar: Exactly right.
09:43:15 <mm_freak> and experienced programmers don't benefit from it, because they write idiomatic haskell
09:43:56 <dv-> experienced programmers make their own loops with callCC
09:44:27 <rasfar> @hoogle callCC
09:44:27 <lambdabot> Control.Monad.Trans.Cont callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
09:44:28 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
09:44:28 <lambdabot> Control.Monad.Cont callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
09:44:55 <Flonk> mm_freak: I don't use functions unless I know how they're implemented, and I don't even completely grok monads yet..
09:45:54 <rasfar> there's an example of a third-order function (somebody was wondering if they arise much in practise yesterday)
09:46:05 <simpson> Flonk: I found that the most useful approach for people like you is to take apart a couple simple types like Identity, Maybe, Either, or Reader, and see how they work and behave as monads.
09:46:06 <mm_freak> Flonk: apparently you're responding to something, but i'm not sure what =)
09:46:37 <mm_freak> rasfar: 'mask'
09:46:38 <triliyn> mm_freak: probably responding to something about monad-loops?
09:46:45 <rasfar> :r mask
09:46:55 <rasfar> :t mask --grrr
09:46:56 <lambdabot> ((forall a. IO a -> IO a) -> IO b) -> IO b
09:47:41 <mm_freak> order 3, rank 3 =)
09:47:50 <mm_freak> didn't even notice it's rank 3 before
09:48:08 <Flonk> mm_freak: I try not to use packages since I don't even know what the base library has to offer, that's what I wanted to say
09:48:23 <mm_freak> Flonk: ah, alright =)
09:51:11 <rasfar> if the result of an IO action is never demanded, is it still evaluated to WHNF?
09:51:23 <monochrom> usually no
09:51:37 <monochrom> but the action itself can do whatever it wants
09:52:12 <monochrom> if you do a getChar for example, then clearly, the Char is in WHNF whether you care or not
09:53:45 <rasfar> well, that's a boxed primitive type right? i mean, that it's HNF is sort of axiomatic, but for coinductively defined types...
09:53:52 <Flonk> simpson: I know how to use the monadic operations and all, but then I hear people say things like "the advantage of Applicative over Monad is that an Applicative can inspect its structure" and I have no idea what it means
09:54:59 <m1dnight> hey guys, me again :)
09:55:07 <monochrom> my honest answer is: depends on the action. my diplomatic answer is: if you just want to hear "you are right", I can do that.
09:55:30 <rasfar> heh, testing is the best way to go then
09:55:45 * monochrom does not understand why people does not grok "it depends"
09:56:49 <rasfar> (strange notion of diplomacy to put it inside out like that)
09:57:58 <edwardk> rasfar: each IO action can do whatever the heck it wants there
09:58:00 <rasfar> i think i've seen a recent example of what you mean, in Repa, because the action used computeP (a.k.a force) -- I never used the result (had CPP branches before that)
09:58:13 <rasfar> but it was still fully evaluated
09:58:38 <edwardk> return undefined isn't going to force undefined to WHNF and bottom out your program.
09:59:02 <edwardk> return $! undefined on the other hand will
09:59:10 <rasfar> good point; so there's an example of each
09:59:17 <edwardk> hence 'it depends'
09:59:22 <edwardk> =)
10:00:17 <m1dnight> allright, i give up
10:00:19 <m1dnight> i need ur help :p
10:00:37 <rasfar> midnight, what's the trouble?
10:00:37 <m1dnight> I want to implement a function that calculates the average of a given list of (in this case) integers
10:00:49 <m1dnight> so plain and simple:
10:00:55 <m1dnight> avg list = (sum list) / (length list)
10:01:06 <rasfar> you need fromIntegral
10:01:09 <m1dnight> first thing I find awkward is, this function does not work without a function type
10:01:21 <rasfar> or rather, Haskell needs to somehow ditch the need for it...
10:02:10 <monochrom> avg list = sum list / fromIntegral (length list)
10:02:19 <rasfar> > let xs = [1,2..5] in (sum xs) / (length xs)
10:02:23 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
10:02:25 <lambdabot>    arising from a use o...
10:02:32 <rasfar> > let xs = [1,2..5] in (sum xs) / fromIntegral (length xs)
10:02:33 <lambdabot>   3.0
10:02:35 <simpson> :t genericLength
10:02:36 <lambdabot> Num i => [b] -> i
10:02:39 <monochrom> well, unless list::[Integer] or the like, then fromIntegral (sum list) too
10:02:50 <m1dnight> so the issue is that (length xs) returns an Int?
10:02:57 <simpson> > let xs = [1..10] in (sum xs) / (genericLength xs)
10:02:59 <lambdabot>   5.5
10:03:02 <monochrom> that is the first issue
10:03:12 <nooodl> :t (/)
10:03:13 <lambdabot> Fractional a => a -> a -> a
10:03:31 <nooodl> and Int isn't a Fractional type
10:03:35 <m1dnight> ooooh, (/) can ONLY accept fractionals
10:03:50 <dv-> :t div
10:03:51 <m1dnight> that's what my teacher means with "the north korea of type systems"
10:03:51 <prooftechnique> I was really hoping liftM2 (/) sum length would just work :D
10:03:51 <lambdabot> Integral a => a -> a -> a
10:03:52 <m1dnight> now I get it
10:04:10 <m1dnight> so no division for Int -> Int -> Float or something
10:04:14 <nooodl> "liftM2 (/) sum genericLength" works i think!
10:04:38 <pmk> :t liftM2 (/) sum genericLength
10:04:39 <lambdabot> Fractional i => [i] -> i
10:04:44 <m1dnight> ah, now I see
10:04:45 <m1dnight> let me try
10:05:04 <m1dnight> > (sum [1..4] / 3)
10:05:06 <lambdabot>   3.3333333333333335
10:05:14 <monochrom> that is a great misunderstanding of north korea
10:05:15 <m1dnight> so, he "parses" 3 to a fractional then?
10:05:22 <nooodl> pretty much
10:05:28 <m1dnight> and then
10:05:31 <m1dnight> :t sum
10:05:33 <lambdabot> Num a => [a] -> a
10:05:36 <m1dnight> takes a num
10:05:38 <m1dnight> ooohhhhh
10:05:39 * rasfar still laughing
10:05:41 <m1dnight> now I get it :D
10:06:15 <prooftechnique> @let avg = liftM2 (/) sum genericLength
10:06:18 <lambdabot>  Defined.
10:06:25 <prooftechnique> > avg [1..4]
10:06:28 <NeonCore> Hi, I need some help, my problem is described in the paste. http://lpaste.net/5932159510125740032
10:06:29 <lambdabot>   2.5
10:06:46 <rasfar> > [1..4]
10:06:49 <lambdabot>   [1,2,3,4]
10:07:00 <rasfar> right.
10:07:00 <m1dnight> hey thanks a boat load guys :)
10:07:09 <nooodl> :t ((/) `on` fromIntegral)
10:07:11 <lambdabot> (Fractional c, Integral a) => a -> a -> c
10:07:38 <rasfar> > [1,1..4]
10:07:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:07:55 <m1dnight> that's weird
10:08:04 <m1dnight> thought it'd be 1, 1, 2, 3, 4
10:08:09 <rasfar> [1,1..0]
10:08:10 <prooftechnique> Why?
10:08:19 <triliyn> Is it possible to define a version of (/) that works on fractions or integers?
10:08:21 <rasfar> > [1,1..0]  -- last one
10:08:22 <lambdabot>   []
10:08:26 <geekosaur> try the extended version: enumFromThenTo
10:08:30 <prooftechnique> triliyn: div is integral division
10:08:58 <prooftechnique> I think (/) works on ratios from Data.Ratio
10:09:01 <geekosaur> (that is, that's what the [..] syntax expands to and is somewhat descriptive of the meaning)
10:09:15 <m1dnight> I think he means a function like div :: (Num a) => a -> a -> a
10:09:15 <triliyn> prooftechnique: right, but I mean, can you have a function that acts like either (/) or (/) `on` fromIntegral depending on the type of its arguments?
10:09:19 <nooodl> @src (/)
10:09:20 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:09:20 <rasfar> who actually does useful work with Ratio, calis
10:10:17 <monochrom> some reasonable Num instances cannot support division
10:10:50 <NeonCore> m1dnight: it's an infinite list because: you set the 'starting' value to 1, and you're always adding 0 to it, so you will never reach 4.
10:10:55 <triliyn> Yeah, I guess the problem is that there's no typeclass for FractionalOrIntegral or something
10:10:59 <pmk> hmm, ghci 7.4.2 dislikes liftM2 (/) sum genericLength
10:11:00 <rasfar> someone suggested x /$ y = realToFrac x / realToFrac y
10:11:02 <nooodl> :t (/) `on` realToFrac
10:11:03 <lambdabot> (Fractional c, Real a) => a -> a -> c
10:11:05 <rasfar> which i've used with mixed success
10:11:06 <nooodl> ah. yeah that
10:11:10 <triliyn> oh wait
10:11:16 <prooftechnique> pmk: Did you import Data.List?
10:11:20 <triliyn> Is Integral a subclass of Real?
10:11:20 <pmk> of course
10:11:25 <triliyn> That might work
10:11:26 <nooodl> i think it is
10:11:40 <prooftechnique> pmk: What's it choking on?
10:11:50 <m1dnight> maybe a silly question, but is there some diagram of the typeclases in haskell?
10:11:54 <nooodl> i always forget the Real, RealFrac, Fractional, ... hierarchy
10:11:56 <triliyn> > (/) `on` realToFrac 5 (5 :: Int)
10:11:57 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
10:11:57 <lambdabot>    arising from a use ...
10:12:00 <prooftechnique> @where typeclassopedia
10:12:01 <geekosaur> @where typeclassopedia
10:12:01 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:12:01 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:12:09 <pmk> "No instance for (Monad ((->) [r0])) arising from a use of `liftM2'
10:12:53 <nooodl> http://commons.wikimedia.org/wiki/File:Classes.svg ooh
10:13:08 <m1dnight> exactly what I needed :D
10:13:16 <m1dnight> found a similar one on google just now
10:13:19 <m1dnight> this one is better tho
10:13:21 <m1dnight> lets print this baby
10:13:22 <m1dnight> :p
10:13:27 <pmk> and ":t liftM2 (/) sum genericLength" is :: (Fractional r, Monad ((->) [r])) => [r] -> r
10:13:56 <rasfar> indeed just hours ago I had: 100.0 * (1.0 - (fromIntegral (vec VU.! (7::Int))))/(0.25 * (fromIntegral (size $ extent v) :: Int )) and about 10 other variants which won't pass muster with the type checker
10:14:08 <nooodl> are there Fractional types that aren't in RealFrac?
10:14:09 <prooftechnique> pmk: Weird.
10:14:48 <rasfar> so i broke it down into #*$@1..#*$@7 and did it incrementally with type sigs on every line and it finally worked. took about 40 minutes.
10:14:54 <mrwonko> Hi. I want to overload a custom operator/function with two arguments. For, say, Int and Int it always returns a String, while for Int and String it returns a Boolean. I've started reading about MultiParamTypeClasses, FunctionalDepenencies, FlexibleInstances and TypeFamilies and now I'm just utterly confused. Help.
10:15:07 <prooftechnique> nooodl: Not in base, no
10:15:57 <rasfar> (i see the error in the above now incidentally, but still)
10:16:09 <enthropy> mrwonko: FunctionalDepenencies and TypeFamilies do the same thing. You only need one of them to make your function usable
10:16:09 <prooftechnique> Wat
10:16:25 <rasfar> fromIntegral ((size $extent v) :: Int)
10:16:44 <rasfar> anyways.... back to work
10:16:47 <nooodl> mrwonko: i don't think you want to do that, generally!
10:17:01 <pmk> yeah, it's not just ghci 7.4.2, but also ghc.   mean = liftM2 (/) sum genericLength         fails.
10:17:27 <mrwonko> well, this isn't something I'd generally do, but I want to bend the ghci to my will by overloading +, * and other operators in crazy ways because I'm too lazy to write a parser for this quick test
10:17:32 <prooftechnique> Is there something special I have to do to make cabal repl work? It just says "Preprocessing library..." but then doesn't start a repl
10:17:37 <supki> pmk: IIRC you need to import Control.Monad.Instances explicitly on old ghcs
10:17:47 <pmk> oh right
10:17:47 <prooftechnique> I seem to remember having this issue once, but I can't for the life of me remember the solution
10:17:49 <pmk> never mind
10:17:53 <sclv_> mrwonko: class Foo a b c | a b -> c where op :: a -> b -> c
10:18:01 <dcoutts_> prooftechnique: what is it doing? have you run with -v ?
10:18:07 <dcoutts_> or v3
10:18:17 <sclv_> instance Foo Int Int String where op x y = show x
10:18:18 <sclv_> etc.
10:18:19 <pmk> yeah that fixes it.
10:18:22 <pmk> thank you
10:19:01 <monochrom> people who wish for implicit numeric promotion or a general divison :: (constraints here) => a -> a -> b haven't thought it through
10:19:23 <lpaste> prooftechnique pasted “cabal repl” at http://lpaste.net/95411
10:19:30 <prooftechnique> dcoutts_: ^
10:19:42 <pmk> monochrom, it's worked fine in Fortran for sixty years
10:19:54 <monochrom> first, the general division :: (constraints here) => a -> a -> b. do you understand that such generality means you will need more type annotations, not fewer?
10:20:15 <prooftechnique> dcoutts_: That's with -v3
10:21:09 <monochrom> with a->a->a, there is only one type variable, you need at most one annotation, sometimes zero if you're luck. with a->a->b, two type variables, now you need up to two annotations
10:21:11 <rasfar> i expect if i annotate the expression as a whole as :: Double, a lot of the rest could be inferred
10:22:00 <rasfar> and that if the result of that expression is used elsewhere in a Double context, even that annotation wouldn't be needed
10:22:00 <monochrom> your expectation is usually wrong
10:22:07 <rasfar> no really
10:22:16 <rasfar> oh i mean, in general...
10:22:39 <mrwonko> hmm okay that appears to work, but I have to write op (1 :: Int) (1 :: Int) because the type of 1 can't be deduced. I'd like it to work for all Integrals.
10:22:44 <Guest14640> hey guys, what do i do if i try to cabal install HDBC-mysql and i get an error message that says it cant find mysql_config
10:22:45 <dcoutts_> prooftechnique: hmm, odd
10:23:06 <Guest14640> on windows 7. same thing happens with hdbc-postgresql
10:23:08 <triliyn> monochrom: I think I'd rather use annotations than have to decide whether I need fromIntegral on both sides
10:23:19 <prooftechnique> Yeah. I think I had this issue once before and then fixed it somehow, but that was before 1.18 was even released
10:23:33 <triliyn> At least redundant annotations don't stop it from compiling
10:23:35 <dcoutts_> prooftechnique: does it terminate or hang?
10:23:42 <triliyn> But if you use fromIntegral and you don't need to, that's a type error
10:24:06 <prooftechnique> dcoutts_: Doesn't seem to. It seems like it's working correctly and then just doesn't load up ghci
10:24:20 <pmk> needing two annotations is not exactly a catastrophe on the order of being forced to rove a postapocalyptic landscape in a futile search for foodstuffs while being pursued relentlessly by ravenous former humans.
10:24:49 <dcoutts_> Guest14640: install the mysql devel stuff (C libs, headers etc, including mysql_config program on the $PATH)
10:24:51 <monochrom> next, implicit numeric promotion. you can point at all the existing languages, C, fortran, basic, javascript, whatever. so how does C do it? by baking the allowed numeric types into the language. if you know you only have 8 numeric types, you can explicitly say, in the language definition, how to implicitly promote. it's a closed world. do you really want a closed world? do you not want, like in Haskell, to define your own nu
10:24:51 <monochrom> meric types?
10:24:58 <rasfar> monochrom, don't be put off, i apologise if i'm being somewhat obtuse, but you should realise there's been hours of frustration over this
10:25:14 <Guest14640> dcoutts_: thanks i'll give it a shot
10:25:21 <dcoutts_> prooftechnique: well, if you could file a bug with an example that someone else could reproduce then that'd be very helpful.
10:25:35 <Guest14640>  install the mysql devel stuff (C libs, headers etc, including mysql_config program on the $PATH)
10:25:56 <prooftechnique> Sure, I'll see what I can do. Can hardly tell if it even is a bug. :D
10:26:14 <triliyn> monochrom: although, I think realToFrac solves the "redundant fromIntegral" issue
10:26:24 <triliyn> I should remember that function
10:26:51 <prooftechnique> I'm just gonna start the sandbox over and see if that helps
10:28:14 <prooftechnique> dcoutts: Is a Main.hs required to use the repl? It worked in another sandbox I have with a Main in it
10:28:19 <prooftechnique> Maybe that's all the issue is
10:34:09 <ericmoritz> I am a bit stumped by this.  I want to basically create a function that will fetch data from a HTML listing and auto unpaginate it into a into an long list.  So basically I have a [IO [Item]] That I want to lazily evaluate to an IO [Item].  Is that even possible? sequence evaluates all the actions; so that doesn't work
10:36:55 <jchee> ericmoritz: have you looked at unsafeInterleaveIO? http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO
10:37:04 <ericmoritz> nope
10:37:08 <quchen> sequence for IO is lazy enough for this I think
10:37:18 <quchen> :t map concat . sequence
10:37:19 <lambdabot> [[[a]]] -> [[a]]
10:37:28 <quchen> :t fmap concat . sequence
10:37:29 <lambdabot> (Monad f, Functor f) => [f [a]] -> f [a]
10:37:34 <geekosaur> I seem recall there's some subtlety in making sequence and unsafeInterleaveIO be more lazy than just sequence?
10:37:49 <Cale> quchen: not if his list is infinite or something
10:37:50 <chrisdone> quchen: sequence is lazy in what way?
10:37:58 <Cale> Sequence isn't very lazy
10:39:40 <Cale> ericmoritz: Probably what you want to do is write something similar to sequence, but which will run the actions until you get no results.
10:40:32 <prooftechnique> dcoutts: It was just that I forgot to add my modules to the cabal file -_-
10:40:48 <ericmoritz> Cale: cool
10:40:53 <epta> .цшт 6
10:41:18 <donri> :t mapM_ (>>= ?f)
10:41:19 <lambdabot> (Monad m, ?f::a -> m b) => [m a] -> m ()
10:42:11 <quchen> Cale: Depends on what kind of lazy you want.
10:42:14 <quchen> sequence (zipWith ($) (repeat print) [1..])
10:42:18 <quchen> ^ That prints all the numbers.
10:42:31 <Cale> well, yeah
10:42:38 <quchen> Sure, it never terminates, but if the side-effects are enough then you can work with that
10:42:39 <Cale> but you'll never get the list of () back
10:42:49 <Cale> He wants the results of his actions
10:43:09 <Cale> ericmoritz: You could write something like  sequenceUntil p [] = return []; sequenceUntil p (x:xs) = do v <- x; if p v then return [] else do vs <- sequenceUntil p xs; return (v:vs)
10:43:21 <Cale> and then use  sequenceUntil null
10:45:47 <ericmoritz> that sort of works but I want to be able to use (take 20) to get the first 20 items
10:47:30 <donri> you'll either need unsafeInterleaveIO to make it truly lazy, or you'll need invert it like sequence . take 20
10:47:42 <ericmoritz> ok
10:47:51 <dmj`> is there a better way to get the values out of a Map besides using Prelude.map Prelude.snd . M.toList ?
10:48:05 <quchen> dmj`: valuesList?
10:48:13 <donri> ericmoritz: might also consider using something like pipes here
10:48:30 <Cale> ericmoritz: Yeah, applying unsafeInterleaveIO to each of the actions before sequence is an option, but it will mean that the *evaluation* of the results will cause the IO to actually occur
10:48:34 <quchen> dmj`: Oh no it's called "elems"
10:48:45 <quchen> http://hackage.haskell.org/package/containers-0.5.3.1/docs/Data-Map-Lazy.html#v:elems
10:48:50 <dmj`> quchen: ah thank you
10:49:11 <Cale> ericmoritz: So it may result in the actions being delayed for arbitrary amounts of time, or occurring in a weird order.
10:49:30 <Cale> (because it'll depend on how the rest of the program uses the list of results)
10:52:05 <donri> ericmoritz: with pipes you could have something like, Producer Item IO (), which you can then compose with a pipe like take :: Monad m => Int -> Pipe a a m ()
10:52:30 <donri> ericmoritz: and it should only download as many pages as it needs to produce that many Items, without using unsafeInterleaveIO
11:02:32 * hackagebot cereal 0.4.0.1 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.4.0.1 (TrevorElliott)
11:17:05 <rasfar> > ( map (\x -> logBase (2::Int) $ fromIntegral x) ([1..5]::[Int]) ) :: [Double]
11:17:07 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
11:17:07 <lambdabot>              with actual ty...
11:17:39 <rasfar> since we're allowed to say fuck on #haskell, I am prepared to say it now
11:18:21 <rasfar> > map (\x -> logBase (2::Int) $ fromIntegral x) ([1..5]::[Int])
11:18:22 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
11:18:22 <lambdabot>    arising from a use of...
11:18:33 <rasfar> > map (\x -> logBase (2::Int) x) ([1..5]::[Int])
11:18:35 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
11:18:35 <lambdabot>    arising from a use of...
11:18:46 <monochrom> @type logBase
11:18:47 <lambdabot> Floating a => a -> a -> a
11:18:55 <monochrom> not going to be Int
11:19:13 <rasfar> > logBase 2 8
11:19:15 <lambdabot>   3.0
11:19:26 <rasfar> > logBase 2 8.0
11:19:27 <lambdabot>   3.0
11:19:28 <monochrom> replace "2::Int" by "2"
11:19:47 <monochrom> unless you say, in your real code, it's a variable not a literal
11:19:48 <rasfar> > map (logBase 2) ([1..5]::[Int])
11:19:50 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
11:19:50 <lambdabot>    arising from a use of...
11:20:04 <monochrom> @type map (logBase 2)
11:20:05 <lambdabot> Floating b => [b] -> [b]
11:20:10 <monochrom> not going to be [Int]
11:20:12 <rasfar> > map (logBase 2) (map fromIntegral ([1..5]::[Int]))
11:20:14 <lambdabot>   [0.0,1.0,1.5849625007211563,2.0,2.321928094887362]
11:20:30 <rasfar> okay
11:20:35 <monochrom> = map (logBase2 . fromIntegral)
11:20:53 <rasfar> (right)
11:23:26 <prooftechnique> If I want to build a correct XML parsing library, am I better off using Data.XML.Types, or Text.XML.Light.Types?
11:31:09 <simukis_> prooftechnique: you can always make your own types if neither pleases you.
11:31:39 <prooftechnique> I think I'll probably go with the former. It seems more comprehensive, if nothing else
11:32:58 <shergill> so i'm hopefully going to get some time to hack on my project this weekend. i want to implement an interpreter and compiler for a lisp like language, so what're the tools that i should be working with? i'd like something modular and extensible since the semantics of the language haven't been fixed and i'd like to be able to experiment with variants, so modularity and extensibility
11:33:41 <prooftechnique> @faq Interpreter and compiler for a lisp-like language
11:33:41 <lambdabot> The answer is: Yes! Haskell can do that.
11:34:02 <shergill> no way!
11:35:13 <shergill> ok more concrete, what should i use for parsing, capture avoiding substitution, writing optimization passes modifying the ast etc?
11:35:23 <shergill> edwardk: ↑
11:36:39 <rasfar> prooftechnique: does HXT not suit?
11:37:10 <prooftechnique> rasfar: I'm porting xml-conduit to pipes, so I think that'd be a bit much
11:37:20 <rasfar> ah!
11:37:27 <simukis_> I wonder wheter somebody put a safety switches into lambdabot so such logic loopholes don't occur
11:37:35 <simukis_> @faq What can't haskell do?
11:37:36 <lambdabot> The answer is: Yes! Haskell can do that.
11:38:08 <quchen> Lambdabot's axiom system is ∀ x. P(x)
11:39:04 <simukis_> hmm, makes (no) sense.
11:39:31 <simpson> Seems reasonable enough to me.
11:42:31 <quchen> When you design a logic system, you have to pick sides at some point. Lambdabot chose wisely and picked inconsistency over incompleteness.
11:43:08 <simpson> But it's okay, because she doesn't encapsulate any notion of truth outside of her system.
11:45:05 <shergill> actually i have another requirement which i suppose most people implementing dsl's wouldn't. i want to be able to share some of the 'optimizations'/transformations between the host and domain language
11:47:25 <shergill> i'm thinking of a probabilistic functional programming language. say, lisp with some extra stochastic primitives. the compiler of this dsl makes use of inference engines which i would want to be able to reuse on haskell programs as well. hmm i suppose i could trivially do that by writing the haskell program in the using the ast and defining the inference over the gadt
11:47:41 <shergill> /s/in the//
11:49:30 <AlbusGondola> hello?
11:49:36 <carter> shergill: huh
11:49:52 <carter> shergill: you should talk with rob zinkov
11:50:06 <AlbusGondola> Hm? Why?
11:50:10 <shergill> carter: where can i get a hold of him?
11:50:20 <carter> hrmm
11:50:20 <AlbusGondola> Ah.
11:50:37 <carter> http://zinkov.com/contact/ ?
11:51:03 <AlbusGondola> I hope I'm not interrupting anything? I have a simple question that might not have a simple answer.
11:51:23 <Rembane> AlbusGondola: Those are the best. Shoot!
11:52:30 <AlbusGondola> The fact that a list with a heterogeneous type is well established, but the fact that a list with heterogeneous levels is apparently not as much. I can think of about four reasons why this would be but without further clarifying I would simply ask why?
11:53:04 <carter> thats totally doable
11:53:14 <carter> but generally Hlists aren't what you actually want
11:53:25 <carter> at that point you want a tree :)
11:53:50 <AlbusGondola> Yes, I'd expected that there was a reason, heterogeneous lists of that type would be error prone.
11:54:12 <shergill> carter: thanks. why him, specifically?
11:54:40 <carter> he's actually leading a project in the probabilistic modelling language space that has oleg and ken chan on board
11:54:46 <carter> and darpa funding
11:55:14 <shergill> huh, interesting
11:55:19 <AlbusGondola> Do trees convert to lists on queries of a certain type? I haven't read that far in yet.
11:55:27 <carter> queries fo what
11:55:37 <carter> what do you mean by queries
11:56:59 <monochrom> you can convert trees to lists. after you have defined "convert" and proved that it is not a self-contradiction
11:57:36 <AlbusGondola> I'm still on Learn You a Haskell for Great Good. I was testing lists when I thought of what is apparently represented better as a tree and precludes an entire solution set that I had considered. I was wondering if a list and a tree are freely interchangeable for output.
11:57:43 <shergill> carter: by leading you mean one of the main people, not the pi right?
11:57:59 <carter> i don't care what it says on paper, its his baby
11:58:10 <monochrom> not freely interchangeable
11:58:20 <carter> shergill: so i consider him in charge
11:59:10 <AlbusGondola> Can, then, a tree have a list or a set of list clearly represent its output?
11:59:32 <mangaba_leitosa> Is there a module that would allow doing '[ x | x <- set ]' for Data.Set instead of List? A monadic interface to Data.Set maybe?
12:00:00 <monochrom> I don't understand the question
12:00:07 <AlbusGondola> Its an interesting idea.
12:00:51 <simukis_> http://hackage.haskell.org/package/ssh-0.2.12.1/docs/SSH.html hackage is broken?
12:00:51 <mangaba_leitosa> monochrom: e. g. in Scala, you can do 'for (i <- something) yield i' where something can be List, Vector, Set or other iterable collection
12:00:59 <monochrom> is it similar to: I have the number 10, can I output it in a form that looks neither like a number nor the idea of 10?
12:01:13 <carter> the issue is sets can only have a single elem
12:01:17 <mangaba_leitosa> monochrom: are you talking to me?
12:01:25 <carter> so the order of evlauation of the comprehension would change its meaning for a set
12:01:27 <monochrom> no, I am talking to the question
12:01:34 <mangaba_leitosa> monochrom: to my question?
12:01:51 <carter> if a comprehension for a list gives me the number 2, twice,
12:01:52 <monochrom> to the question of "can a tree have a list or a set of list clearly represent its output?"
12:01:54 <carter> i have two 2's in my list
12:02:06 <teneen> what does it mean to add {-# UNPACK #-} ! to a field which is a list of some elements?
12:02:07 <carter> with a set… not so much
12:02:13 <carter> teneen: nothing
12:02:15 <teneen> is this any useful for lists?
12:02:16 <carter> wont work there
12:02:16 <mangaba_leitosa> monochrom: oh, sorry, not about my question then
12:02:21 <carter> teneen: whats the goal
12:03:36 <teneen> carter: I just want to understand how things work. I actually want to add this pragma to a field which is one of the parameters of the datatype
12:03:53 <AlbusGondola> I am only curious, since mathematically a set can have an infinite number of subsets I attempted to see how haskell would handle more than one or two levels of lists and it rejected it.
12:03:55 <carter> teneen: it wont change the meaning of the program
12:04:18 <monochrom> mangaba_leitosa: it seems that you may like Data.Set's toList
12:04:25 <teneen> carter: in case the parameter is unboxable it will be useful,  and in case it is not it will not be harmful, is this correct?
12:04:26 <Rulexec> Why lambdabot for @pl \f g a -> f a (g a) returns ap?
12:04:33 <mangaba_leitosa> monochrom: sure, but this means working with lists, not sets
12:04:40 <carter> teneen: its very bad to have cargo cult optimization habbits
12:04:51 <fizruk> :t ap
12:04:52 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:05:08 <carter> teneen: bang the types with a !
12:05:11 <teneen> carter: I'm working on an application where I care about each and every bit
12:05:13 <mangaba_leitosa> monochrom: I like the Scala's idea of Sets, Lists, Vectors etc. being Monads, so all usable in for comprehhensions
12:05:13 <fizruk> :t ap (c -> a -> b) -> (c -> a) -> (c -> b)
12:05:14 <lambdabot> parse error on input `->'
12:05:16 <carter> teneen: whats the application
12:05:17 <fizruk> :t ap :: (c -> a -> b) -> (c -> a) -> (c -> b)
12:05:19 <lambdabot> (c -> a -> b) -> (c -> a) -> c -> b
12:05:27 <mangaba_leitosa> monochrom: such a think should be theoretically doable in Haskell as well
12:05:39 <teneen> carter: processing very huge amounts of data
12:05:44 <carter> doing what
12:05:45 <mangaba_leitosa> AlbusGondola: right, but lists can also be infinite :-)
12:05:50 <carter> thats really really vague :)
12:05:53 <carter> how much is huge?
12:06:03 <teneen> carter: terabytes
12:06:06 <carter> :)
12:06:08 <mangaba_leitosa> AlbusGondola: and Haskell does work with infinite lists
12:06:16 <carter> so bigger than 1 hard drive, but not the internet
12:06:17 <carter> streams?
12:06:20 <AlbusGondola> Well the way it was explained, as I understand it would be having a set of trees and a haskell forest that can do what I'm thinking of.
12:06:27 <teneen> carter: logs
12:06:30 <carter> what sort of workload
12:06:35 <carter> streaming through a log?
12:06:48 <carter> have you tried just using pipes or machines?
12:06:57 <fizruk> Rulexec, it uses ap for ((->) c) monad (aka Reader)
12:07:04 <teneen> carter: I don't need them
12:07:07 <carter> oh
12:07:09 <AlbusGondola> ??
12:07:11 <carter> why not?
12:07:19 <carter> if you're doing single pass over a log
12:07:23 <carter> that'd be helpful
12:07:38 <teneen> carter: What really matters to me is the data structure I use for doing the statistics over this data
12:07:43 <carter> ohh
12:07:43 <carter> ok
12:07:45 <carter> welll
12:07:45 <teneen> it gets very huge
12:07:56 <carter> you should look at multipass
12:07:58 <carter> and folds
12:08:00 <teneen> So I'm storing it as bits with some encoding
12:08:23 <carter> you can bound the space usage if you can do multiple passes
12:08:35 <AlbusGondola> I am confused. Have I gotten an answer and not noticed?
12:08:42 <fizruk> :t (<*>) :: (c -> a -> b) -> (c -> a) -> c -> b
12:08:44 <lambdabot> (c -> a -> b) -> (c -> a) -> c -> b
12:08:51 <teneen> so is this ok? data S a = S {-# UNPACK #-} !a
12:08:58 <fizruk> Rulexec, ap is <*> ^
12:09:13 <teneen> ofcourse this is not the datatype I'm using
12:09:19 <teneen> it has more fields
12:09:31 <Rulexec> fizruk: ok, works as expected.
12:09:54 <teneen> I just want to make sure that unpacking and strictifying a polymorphic parameter is fine
12:10:34 <carter> teneen: currently polymorphic types can't be unpcked, only strictified
12:10:50 <carter> you have to go monomorphic to get things strict AND unpacked
12:11:03 <carter> people recurrently want unboxed yet polymorphic
12:11:22 <carter> the current only route for that is some sort of associated data family / type thing + type classse
12:11:24 <carter> + specialize
12:12:25 <mangaba_leitosa> monochrom: ok, I found what I needed: http://hackage.haskell.org/package/set-monad
12:12:32 <monochrom> mangaba_leitosa: theoretically, there are issues, and scala blows it, not solves it. but first, in practice, lazy list is close enough to generator-yield, so toList is true to the spirit
12:12:38 <rasfar> AlbusGondola, maybe the package ListTree would be of interest? *shrug*
12:12:54 <mangaba_leitosa> monochrom: "The set-monad library is particularly useful for writing set-oriented code using the do and/or monad comprehension notations"
12:13:13 <rasfar> gotta run...
12:13:29 <monochrom> here is the theoretical issue: why should Set be a monad? what justifies it?
12:13:42 <AlbusGondola> Tis only for curiousity's sake but I will take your direction seriously.
12:13:54 <teneen> carter: will -funbox-strict-fields unpack polymorphic fields?
12:14:00 <mangaba_leitosa> monochrom: the notation of list comprehensions is very close to mathematical notation for defining sets
12:14:15 <mangaba_leitosa> monochrom: so, why shouldn't it be used for the same purpose in Haskell?
12:14:17 <monochrom> no, I don't mean "use convenience to justify it"
12:14:27 <tomejaguar> WHat's the difference between unboxed and unpacked?
12:14:50 <geekosaur> unpacked stores it in the parent constructor
12:15:06 <geekosaur> instead of the parent constructor having what amounts to a pointer to the datum
12:15:17 <monochrom> I have a type Mono. I am not going to tell you anything about that type. under what condition does "Set Mono" make sense?
12:15:22 <mangaba_leitosa> monochrom: well, I just needed to be able to use a mathematical notation for defining sets. The set-monad package seems to be created exactly for this purpose. Do you think it would be better if it did not exist? :-)
12:15:24 <Hari`> the "context" for the idea of a set is that there aren't duplicated elements.. is that enough?
12:15:27 <tomejaguar> geekosaur: and unboxed is "not a thunk"?
12:15:48 <shergill> carter: is your information about zinkov recent? i can't seem to find references to it on his website. he only ever mentions a sentiment analysis project
12:16:23 <mangaba_leitosa> monochrom: Set Mono probably makes sense when Eq Mono => Set Mono
12:16:28 <monochrom> in order for "Set Mono" to behave like a set, you need at least equality for Mono. but do you know that Mono has equality? recall that I am not telling you anything about Mono
12:16:44 <AlbusGondola> I think so, but the concept of the context is more in my interest, I think its likely just the old idea that I don't fully understand the problem as its expected to exist.
12:16:48 <mangaba_leitosa> monochrom: so, you won't be able to create a set from a list of functions
12:17:05 <geekosaur> I think unboxed conflates "no constructor tag" and "no pointer/thunk". but the thunk here is different; it's one level deeper than the unboxed field
12:17:35 <tomejaguar> geekosaur: sure i can see that.
12:17:38 <geekosaur> that is, normally parent holdes a pointer to a {tag, pointer to a value}
12:17:58 <geekosaur> unpack strict fields removes the first pointer; unbox, the second
12:18:07 <mangaba_leitosa> monochrom: so, what's your point?
12:18:20 <monochrom> but now, the requirements of monad, actually let's weaken it and just look at the requirements of functor, it wants "fmap :: (Int -> Mono) -> Set Int -> Set Mono". we agree that Set Int makes sense. but does Set Mono make sense?
12:18:36 <tomejaguar> Right.  So a strict functional language would be unboxed by default?
12:18:41 <monochrom> and like you said, if Mono happens to be a function type, does Set Mono still make sense?
12:18:48 <tomejaguar> But not unpacked?
12:18:52 <geekosaur> depends on implementation
12:19:02 <geekosaur> it might still want to use thunks for other reasons
12:19:20 <tomejaguar> So does ! in a datatype actually unbox?
12:19:36 <monochrom> now here is how scala blows it. scala says: every type supports equality, it's an axiom. Mono supports equality, even if "you know nothing about Mono". function types support equality. etc etc
12:19:36 <tomejaguar> or does it just insert code to evaluate the thunk strictly
12:20:01 <geekosaur> default is just to insert a seq call
12:20:22 <geekosaur> unpack strict fields both unpacks into the parent *and* unboxes, I think
12:20:30 <tomejaguar> Ah ok.  So you don't necessarily get any performance benefit over inserting the seq by hand?
12:20:52 <Taneb> ghc-mod isn't picking up installed modules... I've a feeling that it's to do with the fact I installed it from the package manager
12:21:37 <geekosaur> not just by using !
12:21:40 <monochrom> anyway, I should shut up, since no one agrees with me. everyone wants convenience for writers, no one cares reader's predictive power.
12:21:56 <mangaba_leitosa> monochrom: so, what's what's wrong with fmap for Set Mono, as long as Set Mono can be defined at all?
12:21:58 <jchee> monochrom: You've convinced that scala blows it, but not that sets shouldn't be considered monads
12:22:04 <geekosaur> it is possible that strictness analysis may recognize the ! more easily than the explicit seq and take advantage of it, though
12:22:40 <mangaba_leitosa> monochrom: Set Mono with Mono being a function type is not possible even with Set not being a Monad
12:22:44 <jchee> or even functors
12:23:02 <mangaba_leitosa> monochrom: so I cannot see how making Set a Monad instance will change things in this relation
12:23:53 <AlbusGondola> I still see the Haskell Forest being a decent idea, but I don't know what you guys are saying just yet.
12:25:04 <tomejaguar> I don't understand how you *can* make set a monad.
12:25:17 <AlbusGondola> Seconded.
12:25:18 <tomejaguar> What is >>= supposed to do?
12:26:14 <carter> shergill: he's not updated teh site in a while
12:26:39 <tomejaguar> It's not about Eq so much as about Ord
12:27:22 <monochrom> well, Ord was chosen for logarithmic speedup. if you don't mind quadratic time, Eq is the bare minimum
12:27:33 <tomejaguar> OK, fair enough.
12:27:35 <monochrom> likewise Hashable for HashSet
12:27:44 <AlbusGondola> SO I've also been wondering about something else. Don't functional languages simply implement imperative languages in a way that nicely states that they are an obsessed-over innovation while working with functions on top of imperative states? Wouldn't that mean that many of the things unique to Haskell are just epic bugfixes of imperative language implementation details?
12:28:27 <tomejaguar> AlbusGondola: You could say that.  You could also say that functional programming allows more design patterns to be library code, rather than just a concept.
12:28:50 <tharper> tomejaguar: isn't that more a feature of a type system than of just functional programming?
12:29:30 <AlbusGondola> The term Boilerplate comes to mind. Its new to me but I think its applicable.
12:29:35 <tharper> ?
12:29:37 <geekosaur> not really? the point is more what implementation (not just type) can be expressed in library-able form?
12:29:42 <tomejaguar> tharpher: Depends what you mean by type system.  If you consider Java and C++ to have a type system then no.  So many design patterns were invented to work around the insufficiencies of that language.
12:30:04 <geekosaur> a type system aids in this but a better type system can't make a non-functional language functional
12:30:17 <AlbusGondola> Ironic.
12:31:11 <monochrom> suppose you take Scheme and subtract its macro system. then you still have functional programming. but it does not allow more design patterns to be library code. you need macros for that.
12:31:11 <geekosaur> (that is open to multiple readings, isn't it :)
12:32:21 <tharper> Indeed
12:32:27 <monochrom> and Haskell, the non-strictness of Haskell is how you can omit macros and still restore 90% of the ability to turn design patterns into library code
12:32:45 <AlbusGondola> The question that follows is deduced from the last and the little I've seen of Core, which has modest imperative elements, I think. If there is this progression from raw code to imperative up to functional, would there be some other language that would be based around implementing functional language elements for another order of computation interface?
12:32:55 <tomejaguar> Hmm kind of.  Laziness is still just syntactic sugar really.
12:33:04 <monochrom> at the end, I wouldn't attribute that ability to functional programming. I attribute it to language semantics.
12:33:07 <mangaba_leitosa> monochrom: actually, I just read in the set-monad description that 'map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
12:33:08 <tharper> O.o?
12:33:14 <tharper> monochrom: I agree
12:33:17 <mangaba_leitosa> monochrom: prevents Set from being a functor
12:33:33 <mangaba_leitosa> monochrom: maybe this is what you were trying to tell me
12:33:40 <monochrom> yes, mangaba_leitosa
12:34:10 <tharper> because you can't implement forall a b. (a -> b) -> Set a -> Set b?
12:34:36 <monochrom> right. b can't be instantiated to Mono
12:34:53 <monochrom> (Mono is my secret type. I am telling you nothing about it.)
12:34:57 <tharper> ah
12:34:59 <edwardk> shergill: i parse with trifecta, deal with capture avoiding substution with bound, and do compiler passes with a combination of plated from lens and basic elbow grease
12:35:25 <edwardk> i'm still working on finding ways to better combine lens's plated support with bound
12:37:59 <shergill> edwardk: benefit (and drawback) of trifecta over parsec? is there a comparative link out there?
12:38:32 <edwardk> trifecta is parsec that supports clang-style error messages and never accidentally moves your error message to another location.
12:39:18 <edwardk> its designed for 'human scale' languages, generally things written and consumed by a person, not protocols, and so it takes advantage of some opportunities to let you backtrack and refine parses that you can't without holding the entire input
12:40:19 <shergill> ok so better error support, but not streaming
12:40:50 <edwardk> it also comes with the machinery you need to be able to extract the syntax highlights from your parser when you're done so you can generate a web page with the highlighted segments or hand it off to emacs to highlight the file (that latter mode isn't fully implemented, but people have done it)
12:41:04 <edwardk> its also engineered in such a way that you can plug in the whitespace parser more flexibly so you can extend the base parsers to support layout easily
12:41:22 <edwardk> and the whole thing works with monad transformer stacks
12:41:32 <edwardk> making it easier to work with other transformers on top of your parser locally
12:41:43 <edwardk> i also think i threw in a pony
12:41:58 <shergill> ok and ease of use? comparable to parsec?
12:42:35 <edwardk> its bascally the same API, a few rough edges bcause i shipped it early because we're using it all over in production these days
12:42:52 <monochrom> well, "language semantics" is broad. of course you can attribute or blame everything on the language's semantics, it's a tautology. :)  but, let's say, in this case, the focus is on what kinds of abstractions the language supports.
12:44:01 <shergill> i'm going to take a look at the fpcomplete entry for bound, but any extra perks you get if you're using trifecta? or works just as well with parsec?
12:44:25 <edwardk> bound is orthogonal to how you parse things
12:44:47 <monochrom> here is my view. more abstractions supported = more predictive power = less cavalier power. for the 2nd equation, see my http://lambda-the-ultimate.org/node/4816#comment-77080
12:44:52 <edwardk> heck you can use 'parsers' rather than choose parsec or trifecta and parse with either or both. ;)
12:44:54 <edwardk> i do that a lot
12:45:29 <shergill> yeah, just wanted to make sure i do the sanity checking before i dig into bound and its examples
12:47:16 <moops1> is it normal to attach source information (line, col, file) to AST nodes
12:48:30 <tomejaguar> Predictive vs cavalier is a nice way of expressing it.
12:48:42 <monochrom> yes, unless you no longer worry about producing error messages or reverting back to human text
12:49:34 <edwardk> moops1: i usually attach them when i'm likely to need it for error reporting later.
12:50:17 <edwardk> moops1: i've since switched to putting it in every node to making a separate constructor for "Loc" that puts an annotation in where i know it, it keeps my AST from getting cluttered
12:50:40 <edwardk> i used to annotate everything or even use a cofree comonad to bolt it on at every level
12:51:00 <moops1> littering every AST node with a Loc like object seems messy, yea
12:51:31 <moops1> i dont see how to both avoid it and keep a rigid structure
12:52:48 <edwardk> moops: consider http://ermine-language.github.io/ermine/Ermine-Syntax-Term.html#v:Loc
12:54:58 <carter> teneen: nothing unboxes polymorphic fields
12:55:03 <carter> unless you use data familes or the like
12:55:18 <carter> teneen: look at edwardk's structures lib for a way to do that that might be nice
12:56:00 <teneen> edwardk: is there any example on how to use Data.Bits.Coding?
12:56:46 <shergill> edwardk: so plated has the same interface as uniplate? any reason why you went with that instead of syb? i'm familiar with syb, but i hear uniplate is simpler? is that at the cost of expressivity?
12:56:48 <edwardk> teneen: not really =) aheller has some code, but i'm not sure if any of that found its way out into the public domain
12:56:55 <moops1> edwardk: so this allows you to optionally wrap a term in location info, iiuc?
12:57:22 <edwardk> shergill: 'uniplate' and 'plate' are valid traversals, which means they work with a few thousand other combinators in the lens library.
12:57:31 <edwardk> moops1: yeah
12:57:44 <moops1> cool
12:57:53 <edwardk> shergill: syb doesn't have a form that fits that use case
12:57:58 <tomejaguar> monochrom: the Data.Set.Monad type does genuinely seem to be a monad.  However it doesn't actually seem to be any more efficient than using the list monad.  It doesn't "collapse" intermediate values.
12:58:19 <edwardk> shergill: note: it uses Data.Data to go down and implement Data.Data.Lens.uniplate and biplate
12:58:30 <edwardk> it just provides a uniplate-like API
12:58:47 <djahandarie> It's Data all the way down
12:58:53 <cschneid> for matrix math, would I want repa or hmatrix?
12:58:56 <edwardk> and we stole the uniplate combinators so they can be used with any appropriate (even type changing) traversal in many cases.
12:59:19 <edwardk> cschneid: i tend to use linear personally, but your mileage may vary
12:59:30 <edwardk> cschneid: depends on how big your matrices are
12:59:45 <cschneid> not sure honestly - some coworkers are doing matrix math in ruby, and it's.... slow....
12:59:48 <edwardk> i use linear, introspect on it and generate gpu code that has the right shape
12:59:56 <tomejaguar> cschneid: I suspect carter can give you some interesting info about that.
13:00:01 <edwardk> if you're obsessed with low hanging fruit speed then go hmatrix
13:00:16 <cschneid> yeah, anything optimized at all will be better :)
13:00:20 <carter> repa doesn't have solvers
13:00:25 <carter> hmatrix is an ok stop gap
13:00:29 <edwardk> if you want sparse matrix stuff i have some code, if you want dense matrix stuff then carter has been building some numerics code
13:00:34 <carter> yeah
13:00:45 <carter> and soo i'll be borrowing edwardk's sparse code
13:00:48 <edwardk> hmatrix lands you in a local optimum that for me is too local
13:00:51 <teneen> edwardk: I just don't understand what do the arguments of runCoding represent
13:00:52 <carter> yeah
13:01:05 <carter> edwardk: the argument for hmatrix is its public right now :)_
13:01:13 <edwardk> teneen: runCoding is a CPSd state monad
13:01:15 <carter> cschneid: it has some basic solvers etc
13:01:26 <carter> yeah, at some point i want to make a SIMD / vectorization dsl using linear
13:01:34 <cschneid> yeah, I don't understand their problem super well. Basic machine learning stuff, but... not sure about specifics
13:01:43 <cschneid> just looking around as an excuse to get haskell into my environment :)
13:01:44 <edwardk> it'll tell you the 'leftovers' when its done and how many bits you have left unseralized
13:01:59 <carter> cschneid: well, why are they using ruby for it rather than the python tools....
13:02:05 <carter> the python tools are pretty good
13:02:09 <carter> room for more awesome
13:02:13 <cschneid> carter: yeah, we're a ruby shop nearly 100%
13:02:13 <carter> but they will be better than ruby
13:02:17 <carter> yeah
13:02:18 <teneen> edwardk: oh I see
13:02:30 <carter> probably better to sneak haskell in than confuse things with python
13:02:35 <edwardk> teneen: baically it packs up bytes at a time then sends them downstream
13:02:46 <teneen> edwardk: and that does the first argument (the function) to runCoding do?
13:02:48 <edwardk> when its done you have some leftovers
13:03:00 <edwardk> its CPSd for efficiency, just pass it (,,)
13:03:05 <carter> cschneid: i'm aiming to get my first layer of libs out before the Dr Who Xmas special airs
13:03:10 <carter> hows that for a hard deadline
13:03:10 <edwardk> and you'll get the function you'd expect
13:03:29 <edwardk> carter: but which year?
13:03:30 <edwardk> =)
13:03:31 <carter> this one
13:03:48 <carter> i'm futzing with how the indexing api works right now
13:04:40 <cschneid> carter: so we are wide open on choices. Might as well go for a language that represents math super well (haskell), over a language like python.
13:04:41 <Twey> edwardk: Why isn't the vector in linear a type family?
13:04:47 <cschneid> I do know python is plenty fast for mathy stuff
13:05:01 <carter> cschneid: indeed, its just not exctensible
13:05:08 <edwardk> because i use the fact that it can be an honest to goodness Functor everywhere.
13:05:09 <carter> but if you're just doing algs that folks ahve already written, its ok
13:05:38 <Twey> edwardk: Aha
13:05:51 <cschneid> plus: it's just a good way to sneak some haskell into the mix. So I can be sneaky
13:07:15 <edwardk> Twey: every vector space is classically a 'free' vector space, which means it is isomorphic to e -> r for some basis e and some field r. a (co)representable functor f is one that f r is isomorphic to e -> r for some 'representation e.
13:07:44 <edwardk> Twey: linear is based on these two results, it represents vector spaces by their 'polymorphic lenses'
13:08:36 <edwardk> rather than make up some basis type, the set of lenses that know how to get (forall r. Lens (f r) r)   out of f, are used as the representation 'e' for a functor 'f'
13:08:45 <edwardk> which is the basis of the vector space.
13:09:56 <edwardk> _e, _i :: Functor f => (a -> f a) -> Complex a -> f (Complex a)  -- are the lenses into complex numbers. and they together define that vector space
13:10:18 <edwardk> _e, _i :: Lens' (Complex a) a
13:11:12 <edwardk> this makes it very easy to write a ton of operations parametrically that work on all sorts of different vector spaces
13:11:28 <edwardk> and are independent of the element type
13:11:40 <edwardk> it also lets me use a 'vector of vectors' as the matrix representation for linear.
13:11:43 <tomejaguar> How do you represent the complex numbers then?  As the collection containing _e and _i?
13:11:48 <edwardk> it costs me the abilty to pack them
13:11:57 <carter> which is fine for n <=10  nxn matrices
13:11:59 <edwardk> tomejaguar: we use Data.Complex, we just define a couple extra instances for it
13:12:21 <edwardk> http://hackage.haskell.org/package/linear-1.3.1/docs/Linear-Quaternion.html#t:Complicated
13:12:45 <edwardk> instance Complicated Complex where  _e f (a :+ b) = (:+ b) <$> f a; _i f (a :+ b) = (a :+) <$> f b
13:13:32 <edwardk> now you use it as a monad, tensor vector spaces, etc.
13:18:05 <tomejaguar> That's a nice approach.  I didn't know Complex was a data constructor.  I guess the original intent was only to feed numeric types in, but it seems that the more general approach is actually more useful :)
13:19:11 <carter> huh
13:19:13 <carter> it is a constructor
13:19:21 <carter> theres some weird issues with the complex classes
13:19:28 <carter> but i'll save that rant for another time :)
13:20:29 <Twey> edwardk: That's pretty neat
13:21:42 <tomejaguar> Why isn't everything perfect?  It's frustrating.
13:22:14 <monochrom> heh
13:22:21 <carter> tomejaguar: i'm hoping to figure out a solution people would agree on by 7.12 or 7.4
13:22:24 <monochrom> I am a bit more modest.
13:22:30 <carter> so 2-3 years from  now
13:22:34 <carter> people might agreee on something
13:22:39 <monochrom> why isn't everyone perfect? it's frustrating. :)
13:22:42 <carter> and then another 1-2 years before it gets merged int
13:23:40 <moops1> edwardk: am i correct in assuming that the types are filled in in a separate pass?
13:27:57 <quchen> When I create a -hc heap profile, all the function calls are truncated in the generated data, which makes it pretty useless ("(833)makeTimestamp/startHa...	52" is an example line). Can I somehow influence this?
13:31:21 <mangaba_leitosa> is there a shorter equivalent for 'import qualified Data.List as Data.List' ?
13:31:43 <supki> import qualified Data.List
13:31:54 <mangaba_leitosa> supki: ah, thanks!
13:32:58 * hackagebot array 0.5.0.0 - Mutable and immutable arrays  http://hackage.haskell.org/package/array-0.5.0.0 (HerbertValerioRiedel)
13:36:46 <ffog> ah hmm
13:43:32 <edwardk> moops1: yeah its a type inference/checking engine.
13:46:09 <slack1256> How can I make ghc use sandbox libraries instead of user-wide ones?
13:46:31 <slack1256> this is yi look libraries installed at its sandbox
13:49:03 <Feuerbach> slack1256: ghc -no-user-package-db -package-db $sandbox/.cabal-sandbox/i386-linux-ghc-7.6.3-packages.conf.d
13:49:21 <Feuerbach> the last component may differ obviously
13:49:28 * slack1256 trying
13:51:49 <slack1256> it works!
13:51:57 <slack1256> Thanks Feuerbach
14:00:05 <quchen> … found it, there's a "-L<length>" parameter.
14:00:24 <quchen> ^ in case someone searches the logs and finds the question
14:21:19 <wuase> Hi
14:23:39 <johnw> hello
14:24:49 <kuznero> hi
14:45:39 <PHO_> Hmm...
14:45:53 <PHO_> I uploaded HsOpenSSL 0.10.3.5 three days ago
14:45:59 <PHO_> http://hackage.haskell.org/package/HsOpenSSL-0.10.3.5
14:46:18 <PHO_> but haddock isn't generated yet...
14:46:56 <PHO_> something's wrong in the package, hackage2, or both?
14:47:50 <hpc> ... did the build log get designed out of hackage?
14:48:43 <PHO_> hpc: sounds like it
14:49:57 <hpc> and i don't know the format of direct links to the build log either, if they happen to still exist on the backend :(
14:50:55 <robstewartuk> Bah humbug. Is there a way of getting the type level representation for an Int? I.e. the types from Data.TypeLevel, such that `f (0::Int)` evaluates to D0, `f (1::Int)` evaluates to D1
14:51:03 <robstewartuk> and so on
14:52:13 <geekosaur> types aren't values...
14:52:24 <geekosaur> you mnight be able to get a TypeRep but that won't help you much
14:52:36 <Kron> you can't quite 'evaluate' anything to a type
14:52:45 <Kron> evaluation is a value thing; it's in the name and everything
14:52:58 <Kron> without dependent types anyway? I think?
14:53:13 <PHO_> and I don't think reflection is what robstewartuk wants :) http://hackage.haskell.org/package/reflection
14:53:21 <robstewartuk> http://hackage.haskell.org/package/llvm-3.0.0.0/docs/LLVM-Core.html
14:53:43 <robstewartuk> I'm using this library, and depends heavily on type level representations of numbers.
14:54:28 <robstewartuk> e.g. http://hackage.haskell.org/package/llvm-3.0.0.0/docs/LLVM-Core.html#v:extractvalue
14:55:12 <robstewartuk> Where the GetValue class only accepts typelevel representations of indexes in to arrays.
14:55:50 <robstewartuk> Note that d0 :: D0 , d1 :: D1 ...
14:56:24 <robstewartuk> If only I could construct the `d0` expression from 0::Int :-/
14:57:53 <PHO_> case x of 0 -> d0; ...
14:58:43 <robstewartuk> a more scalable version? x may be very large.
15:00:36 <geekosaur> problem is, you could type that expression but I don't think you can make that type fit the constraints that the index stuff has in place there
15:10:03 <PHO_> I finally found a build log! http://hackage.haskell.org/package/HsOpenSSL-0.10.3.5/reports/1/log
15:10:20 <PHO_> Seems like OpenSSL has been removed from the buildbot box :(
15:11:37 <hpc> wow
15:13:44 <Clint> probably good for reasons of security
15:13:44 <xpika> I'm looking for an insertAt function Int -> a -> [a] -> [a]
15:17:39 <Ghoul_> > let insertAt n x xs = case splitAt n xs of { (a, b) -> a ++ [x] ++ b } in insertAt 3 100 [1..5]
15:17:40 <lambdabot>   [1,2,3,100,4,5]
15:18:12 <Ghoul_> :t \n x xs = case splitAt n xs of { (a, b) -> a ++ [x] ++ b }
15:18:13 <lambdabot> parse error on input `='
15:18:22 <darthdeus> hey guys, i'm confused ... i thought   do (x:xs) <- Just ""; return x   is equivalent to   Just "" >>= (\(x:xs) -> Just x)  ... but the former returns Nothing and the latter raises an error :\
15:18:25 <Ghoul_> :t (\n x xs -> case splitAt n xs of { (a, b) -> a ++ [x] ++ b })
15:18:26 <lambdabot> Int -> a -> [a] -> [a]
15:18:34 <darthdeus> i thought they should both return Nothing?
15:18:49 <S11001001> darthdeus: no, failed patterns in do syntax use `fail'
15:19:05 <darthdeus> S11001001: they don't do that using >>= ?
15:19:06 <S11001001> > fail "oops" :: Maybe Int
15:19:07 <lambdabot>   Nothing
15:19:28 <darthdeus> yeah I understand that part, what i dont understand is why >>= isn't using fail
15:19:34 <PHO_> >>= isn't a syntax sugar. It's a normal function
15:19:36 <khyperia> > fail "another oops" :: Either String Integer
15:19:37 <lambdabot>   *Exception: another oops
15:19:41 <darthdeus> i thought do is just a syntax sugar for chained >>=
15:19:43 <khyperia> Huh.
15:19:46 <S11001001> darthdeus: it's not
15:20:11 <quchen> Huh? It is. "do" notation is sugar for >>= and >>.
15:20:18 <PHO_> and fail.
15:20:24 <quchen> We don't talk about fail.
15:20:27 <S11001001> quchen: fail
15:20:45 <darthdeus> hmm, so what would be the equivalent including fail using >>= ?
15:20:47 <S11001001> darthdeus: the desugaring is Just "" >>= (\z -> case z of (x:xs) -> return x; _ -> fail "blah")
15:20:50 <xpika> Ghoul_: thanks, do you think it could be added to Data.List ?
15:20:58 <darthdeus> oh
15:21:06 <Ghoul_> it probably already exists, let me take a look
15:21:15 <simpson> khyperia: There's no way to specialize fail for Either String as opposed to Either a for any other a, so it ends up having to raise an exception.
15:21:26 <khyperia> yeah, I figured.
15:21:40 <darthdeus> S11001001: thanks, it makes sense now :)
15:23:44 <Ghoul_> xpika: you're right, it doesn't exist.
15:24:00 <frege> hey guys
15:24:11 <frege> what's the right way to do this?
15:24:12 <frege> filter (>5) map (*2) [1,2,3,4,5]
15:24:22 <frege> I want to filter the result of map
15:24:26 <Ghoul_> The review process for getting it added would be a pretty long (and possibly controversial) one, so you're probably better off just roling your own
15:24:36 <quchen> > filter (>5) $ map (*2) [1,2,3,4,5] -- frege
15:24:38 <lambdabot>   [6,8,10]
15:24:50 <Ghoul_> > filter (>5) . map (*2) $ [1..10]
15:24:51 <lambdabot>   [6,8,10,12,14,16,18,20]
15:25:24 <khyperia> and then you had me what-the-heck-ing since the output was different and I didn't see why, heh.
15:25:32 <frege> what does $ do?
15:25:37 <khyperia> f $ x = f x
15:25:48 <quchen> … but with very low precedence.
15:25:51 <Ghoul_> > [n | x <- [1..5], let n = x * 2, n > 5]
15:25:53 <lambdabot>   [6,8,10]
15:26:13 <quchen> frege: You can read "$" as an opening parenthesis reaching to the end of the line.
15:26:28 <PHO_> > filter (>5) (map (*2) [1,2,3,4,5])
15:26:29 <lambdabot>   [6,8,10]
15:26:38 <quchen> > filter (>5) (map (*2) [1,2,3,4,5]) -- You can also write it like this. "$" is mostly used to get rid of parentheses.
15:26:40 <lambdabot>   [6,8,10]
15:28:00 <khyperia> although you can get into some trouble with that, quchen
15:28:07 <frege> quchen: gotcha
15:28:13 <frege> makes total sense
15:28:25 <khyperia> someone recently was in here wondering why "2 + foo $ 3 * 3" didn't work (or some such question like that)
15:29:04 <khyperia> but it's a good start.
15:29:08 <quchen> khyperia: Well, it's also like a closing parenthesis for one that was opened at the beginning of the line.
15:29:16 <Ghoul_> > ($) (+) 2 $ 3
15:29:17 <khyperia> yep
15:29:17 <lambdabot>   5
15:29:29 <Ghoul_> > ($) (+) 2 3
15:29:30 <lambdabot>   5
15:29:47 <Ghoul_> yeah, I only realized how stupid the first one was after I sent it.
15:30:15 <japesinator> join #tmux
15:30:25 <PHO_> Khisanth: that's amusing but logical indeed :)
15:30:29 <japesinator> sorry, forgot a slash
15:30:42 <PHO_> i've never thought of such an expression
15:33:53 <xpika> Ghoul_: maybe I should create my own library on hackage for it?
15:34:15 <Ghoul_> it would be a pretty small library.
15:34:41 <xpika> Ghoul_:  add it to the Data.List hierarchy
15:35:34 <Ghoul_> maybe you could suggest it to be added. http://www.haskell.org/haskellwiki/Library_submissions#Guidance_for_proposers
15:36:48 <xpika> ok
15:38:16 * hackagebot language-c-quote 0.7.5 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.7.5 (GeoffreyMainland)
15:41:44 <frege> what does @ do in "let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)"
15:41:47 <frege> > let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)
15:41:48 <lambdabot>   ((10,20,30),10,20,30)
15:42:21 <PHO_> it binds abc to (a, b, c) itself
15:42:30 <frege> holy shit
15:42:43 <Heynoww> Hey haskell friends.  I'm the owner of Lemonparty.org (nsfw).  If anyone wants some good exposure / good promotion, I would be happy to promote any venture or URL or aff link you want on this site in exchange for BTC.  This site has been referenced in television shows and movies.  Website receives thousands of visitors daily.  I'm also selling @Lemonparty.org email for the first time ever-
15:42:44 <Heynoww> for 0.015 Bitcoin
15:42:50 <Heynoww> I will be happy to provide proof, to verify
15:43:10 <hpc> ill take seven!
15:43:10 <xpika> Ghoul_: a deleteAt function could also be added for completeness
15:43:15 <hpc> @ops
15:43:15 <lambdabot> Maybe you meant: pl oeis docs
15:43:20 <zomg> Heynoww: hot on the heels of goatse mail eh? :P
15:43:20 <hpc> @where ops
15:43:21 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
15:43:21 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
15:43:31 --- mode: ChanServ set +o Cale
15:43:43 --- mode: Cale set +b *!*@c-98-213-119-60.hsd1.il.comcast.net
15:43:43 --- kick: Heynoww was kicked by Cale (Heynoww)
15:46:12 <xpika> Ghoul_: and modiftyAt
15:46:31 <PHO_> happy to provide proof to verify? unusual words for spam...
15:48:01 <Ghoul_> lol
15:48:07 <Ghoul_> oddest spam I've seen in a while
15:48:34 <zomg> It seemed sort of legit tbh
15:48:39 <zomg> Weird, but legit :D
15:49:30 <xpika> pretty good deal if you ask me
15:50:11 <WraithM> What's 0.015 BTC in USD?
15:50:41 <rdevilla> WraithM: depends on the time of day
15:50:46 <WraithM> lol
15:51:16 <tromp_> Latest Exchange Rates: 1 Bitcoin = 306.7267 US Dollar
15:51:20 <zRecursive> time is essential :)
15:51:33 <tromp_> says http://btc.exchangerates24.com/usd/
15:51:54 <WraithM> > 306.7 * 0.015
15:51:56 <lambdabot>   4.600499999999999
15:52:31 <zRecursive> how to get bitcoin ?
15:52:56 <tromp_> mine on PCs that youpwned
15:53:00 <tromp_> mine on PCs that you pwned
15:53:34 <joeyh_> write haskell code (worked for me!)
15:54:44 <quchen> Chat in #haskell (worked for me!)
15:54:49 <joeyh_> (can work for you too: http://joeyh.name/blog/entry/please_build_a_haskell_to_perl_compiler/ still has an unclaimed 0.5 BTC bounty )
15:55:07 <quchen> Haskell to Perl!?
15:55:20 <Francisco> whyyy
15:55:21 <rdevilla> good god
15:55:35 <PHO_> why not haskell to /bin/sh :)
15:55:59 <WraithM> PHO_: Now you're talking
15:56:00 <Tene> http://search.cpan.org/~autrijus/Language-Haskell-0.01/lib/Language/Haskell.pm
15:56:05 <monochrom> haskell to xslt
15:56:15 <tromp_> Haskell to Perl is like going down a one way street the wrong way
15:56:31 <scriptor> would you prefer Perl to Haskell?
15:56:38 <tromp_> of course
15:56:48 <scriptor> you'd rather have a Perl to Haskell compiler
15:56:48 <joeyh_> then you'd have to write perl to use it
15:57:09 <hpc> everyone knows you should be writing python with quasi-quoted php
15:57:15 <tromp_> there's enough old perl lying around
15:57:52 <PHO_> lol
15:58:07 <quchen> Haskell to C++ templates
15:58:22 <quchen> Beat that. No, VB is not enough.
15:58:42 <PHO_> C++ templates have no IO monad
15:59:10 <quchen> ASM has no IO monad. You can still compile Haskell to it.
15:59:35 <chrisdone> your face has no IO monad!
15:59:46 <rdevilla> well no, it doesn't
15:59:55 * chrisdone beams with pride at being right
16:00:43 <hpc> chrisdone: my brother was killed by an IO monad
16:00:56 <quchen> "An"? There are multiple ones?
16:01:06 <Tene> I have <=0 faces with >0 IO monads.
16:01:23 <sipa> hpc: using a destructive update?
16:01:25 <hpc> quchen: of course; taco bell makes millions of monads every day
16:01:26 <rdevilla> so you have -10 faces with >0 IO monads?
16:01:30 <hpc> or is it burritos
16:01:38 <rdevilla> (possibly)
16:01:43 <chrisdone> hpc: :D
16:02:03 <sipa> hpc: i guess it started as an evaluation, but ended up as an execution...
16:02:15 <xpika> haskell to rule 110
16:02:19 <Tene> rdevilla: Could be; I haven't measured any more precisely.
16:02:28 <hpc> sipa: dammit that's too funny
16:02:33 <hpc> i can't come up with any response
16:02:39 <mischov> my face might have a burrito...
16:02:54 <chrisdone> sipa: that's beautiful
16:03:20 <sipa> :)
16:03:24 <chrisdone> @remember sipa <hpc> chrisdone: my brother was killed by an IO monad <sipa> hpc: i guess it started as an evaluation, but ended up as an execution...
16:03:24 <lambdabot> Good to know.
16:03:27 <rdevilla> the earth is round, or my face has an IO monad
16:03:31 <rdevilla> not sure which one yet
16:03:54 <AshyIsMe> haha
16:03:55 <quchen> rdevilla: Or it could be both
16:04:08 <khyperia> I'm always surprised LISP is still around. It predates C by 14 years!
16:04:22 <rdevilla> quchen: my god
16:04:35 <chrisdone> you can always tell a muggle by their capitalization of LISP
16:04:54 <quchen> If you write it "Lisp" that makes you a magician?
16:04:59 <chrisdone> if you were trying to infiltrate the Lisp community, that's when they'd slice your head off with a parenthesis
16:05:01 <khyperia> Or I just came from wikiped where it's capitalized like that
16:05:17 <chrisdone> quchen: i mean, an outsider :p
16:05:21 <quchen> chrisdone: This is offtopic though, this channel is about HASKELL
16:05:35 <chrisdone> i've seen that once. HASKELL
16:05:50 <chrisdone> abut what does it stand for?
16:05:51 <hpc> it's spelled HASCAL
16:05:55 <chrisdone> lol
16:06:00 <quchen> PASCAL you mean
16:07:23 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml
16:07:41 <Philonous> hpc, Wait, isn't that an icelandic delicacy? Cured and burried algol or somesuch?
16:07:53 <edwardk> ozataman: around?
16:08:11 <ozataman> hey edwardk, I'm here for another 15-20 mins
16:09:05 <WraithM> Philonous: Hakarl
16:09:38 <frege> where do you learn haskell from?
16:09:53 <hpc> frege: hang from the worldtree for ten days
16:10:20 <hpc> for mortals, there is also LYAH
16:10:23 <frege> hpc: can I die instead?
16:10:30 <monochrom> I learned haskell from the gentle introduction
16:10:30 <hpc> http://learnyouahaskell.com/
16:10:31 <Maxdamantus> C doesn't care about the substitutability principle.
16:10:47 <quchen> We're against dying on #haskell, because that would mean we have to stop using HASKELL.
16:11:26 <Tene> chrisdone: I was never able to persuade my previous manager to s/PERL/Perl/ on our job posting.
16:13:00 <chrisdone> Tene: hence, “previous”?
16:13:39 <Tene> chrisdone: Well, he wasn't involved in actual technical decisions any more by the time I left, so not so much.
16:14:40 <quchen> Yes, wrong capitalization is a good cause for leaving a job.
16:14:46 <frege> >doubleSmallNumber x = if x > 100 then x else 0
16:14:50 <chrisdone> quchen: it's one of the signs
16:15:00 <frege> >doubleSmallNumber 5
16:15:04 <frege> >doubleSmallNumber 105
16:15:13 <frege> > doubleSmallNumber x = if x > 100 then x else 0
16:15:14 <lambdabot>   <hint>:1:21: parse error on input `='
16:15:14 <quchen> You need a space after ">".
16:15:16 <chrisdone> quchen: “it's not written like that” “it is, i know better” “look, here's the home page, and wikipedia, and books” “no, i'm stubborn. this makes me a good manager”
16:15:35 <frege> why?
16:15:35 <frege> why does it beitch about = ?
16:15:47 <Philonous> frege, lambdabot only accepts expressions, not declarations
16:15:49 <hpc> it wants an expression, not a definition
16:15:52 <Tene> quchen: The actual Perl code he wrote is what you'd expect from someone who would make that mistake; he treated it as barely different from bash.
16:16:04 <quchen> Eww
16:16:06 <quchen> EJECT!!!
16:16:06 <hpc> frege: you can do "let <defns> in <expr>"
16:16:22 <frege> http://learnyouahaskell.com/starting-out
16:16:26 <frege> I'm copying from this
16:16:29 <Tene> And then there was the guy who "didn't trust lexical scope", so insisted on prefixing all variables with underscores based on how many scopes they were nested in.
16:16:36 <Tene> $____foo
16:16:40 <chrisdone> lol
16:16:44 <quchen> Haha.
16:16:56 <chrisdone> i like that guy alread
16:16:57 <frege> how do I do this
16:17:03 <PHO_> crazy
16:17:20 <chrisdone> frege: do what?
16:17:21 <quchen> That reminds me of the story of that guy who worked for some government agency, and all methods had standardized names a la "abc123", and they were tracked in a centralized documentation file
16:17:31 <frege> doubleSmallNumber x = if x > 100 then x else 0
16:17:35 <frege> chrisdone: ^
16:17:35 <quchen> So n335 would be the square root :-)
16:18:02 <chrisdone> frege: looks good to me. what do you want to do?
16:18:06 <koala_man> someone once complained that his shell script ran slowly, and asked me how to unroll the loop to make it faster
16:18:14 <frege> > doubleSmallNumber x = if x > 100 then x else 0
16:18:16 <lambdabot>   <hint>:1:21: parse error on input `='
16:18:17 <Philonous> > let doubleSmallNumber x = if x > 100 then x else 0 in doubleSmallNumber <$> [1,10,100,1000]
16:18:17 <frege> chrisdone: ^
16:18:18 <lambdabot>   [0,0,0,1000]
16:18:38 <chrisdone> frege: it's because what you showed me is a declaration, but lambdabot accepts expressions only
16:19:06 <frege> ahh so in the interactive mode I can't evaluate this
16:19:12 <frege> I see
16:19:23 <Philonous> frege, lambdabot is not ghci
16:19:23 <quchen> Technically you can use @let, but that isn't really recommended (because your test definitions are persistent and may confuse others)
16:19:28 <chrisdone> frege: in ghci you can, you just put a let in front of it
16:19:41 <chrisdone> λ> let x = 1
16:19:41 <chrisdone> λ> x
16:19:41 <chrisdone> 1
16:19:50 <evincar> Is there an existing thing to make the Alternative instance for lists have [] as a left zero instead of a left identity?
16:20:07 <quchen> Newtype?
16:20:14 <frege> gotcha
16:20:40 <evincar> quchen: Yeah, just asking if someone already made it.
16:21:22 <quchen> Hm, not that I know of
16:22:34 <frege> cycle is crazy
16:22:38 <frege> what's it doing?
16:22:57 <quchen> Repeats a list.
16:23:07 <quchen> > cycle "hello "
16:23:08 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
16:23:27 <evincar> frege: At a lower level, it's replacing the [] in the list with a pointer to itself.
16:23:28 <quchen> cycle xs = xs ++ cycle xs, basically.
16:23:48 <Maxdamantus> @let map f = reverse . fmap f
16:23:49 <lambdabot>  .L.hs:204:46:
16:23:49 <lambdabot>      Ambiguous occurrence `map'
16:23:49 <lambdabot>      It could refer to either ...
16:23:56 <Maxdamantus> Damn it.
16:24:00 <FreeFull> I think cycle uses let to be more efficient
16:24:08 <quchen> Yep.
16:24:56 <sclv> ryantrinkle: ping
16:25:05 <FreeFull> > let cycle' xs = let ys = xs ++ ys in ys in cycle' "123"
16:25:06 <lambdabot>   "12312312312312312312312312312312312312312312312312312312312312312312312312...
16:25:13 <ryantrinkle> sclv: yo
16:25:14 <FreeFull> Something like that
16:25:25 <quchen> > let cycle xs = fix (xs ++) in cycle "hello "
16:25:27 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
16:25:33 <frege> am I allowed to do it here for test?
16:25:38 <lkey> @src cycle
16:25:39 <lambdabot> cycle [] = undefined
16:25:39 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
16:26:20 <frege> > take 100 cycle [1..5]
16:26:21 <lambdabot>   Couldn't match expected type `[t1] -> t0' with actual type `[a0]'Couldn't m...
16:26:34 <frege> > take 100 (cycle [1..5])
16:26:36 <lambdabot>   [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,...
16:26:50 <frege> > take 3 (cycle [1..5])
16:26:52 <lambdabot>   [1,2,3]
16:27:06 <frege> > take 8 (cycle [1,2])
16:27:07 <lambdabot>   [1,2,1,2,1,2,1,2]
16:27:29 <triliyn> fix (concat . cycle)
16:27:37 <triliyn> > fix (concat . cycle)
16:27:38 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
16:27:39 <lambdabot>  Expected type:...
16:27:54 <lkey> frege: you can use lambdabot in channel to show something or ask questions, or you can pm her if you just want test something
16:28:54 <frege> tnx I have the shell open
16:29:09 <frege> I fucking love this syntax [x*2 | x <- [1..10]]
16:29:14 <frege> it's really sexy
16:30:29 <frege> holy shit this is math syntax
16:30:30 <frege> [x*2 | x <- [1..10], x*2 >= 12]
16:30:59 <frege> > [ x | x <- [50..100], x `mod` 7 == 3]
16:31:00 <lambdabot>   [52,59,66,73,80,87,94]
16:31:35 <frege> kuje [x for x in xrange(50,100) if x % 7 == 3]
16:31:43 <frege> -kuje
16:31:58 <hpc> [x for x not in x]
16:32:41 <quchen> > [ p | p <- [2..], all (\x -> p `mod` x /= 0) [2..p-1]]
16:32:42 <quchen> :-)
16:32:43 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:32:55 <frege> how do you use this one?
16:32:56 <frege> > let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
16:32:58 <lambdabot>   not an expression: `let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!...
16:33:14 <frege> [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
16:33:18 <frege> > [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
16:33:19 <lambdabot>   Not in scope: `xs'
16:33:19 <lambdabot>  Perhaps you meant one of these:
16:33:19 <lambdabot>    `x' (imported from D...
16:33:35 <quchen> > let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] in boomBangs [1..5]
16:33:37 <lambdabot>   ["BOOM!","BOOM!","BOOM!"]
16:33:56 <frege> > let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] in boomBangs [1..11]
16:33:57 <lambdabot>   ["BOOM!","BOOM!","BOOM!","BOOM!","BOOM!","BANG!"]
16:34:04 <evincar> hpc: I see you there, Russell.
16:35:54 <Philonous> frege, I think list comprehensions are Haskells tourist traps. Nice to impress the vacationing C-programmer, but you never go there again once you become a resident.
16:36:17 <frege> why can't you do this ? [ x*y | let x [2,5,10], let y [8,10,11]]
16:36:25 <frege> instead of [ x*y | x <- [2,5,10], y <- [8,10,11]]
16:36:59 <frege> oh nm that was dumb
16:37:29 <frege> Philonous: I'm a python programmer so I've already explored it but the syntax in haskell looks nicer!
16:38:59 <frege> src@map
16:39:08 <frege> how do I get the source of map function?
16:39:14 <Philonous> @src map
16:39:14 <lambdabot> map _ []     = []
16:39:14 <lambdabot> map f (x:xs) = f x : map f xs
16:39:24 <Maxdamantus> > [ (x, y, z) | z <- [1..2], let x = [2,5,10], let y = [8,10,11] ]
16:39:26 <lambdabot>   [([2,5,10],[8,10,11],1),([2,5,10],[8,10,11],2)]
16:39:42 <chrisdone> frege: lol, 9/10 for taking a risk and going for it =p
16:40:12 <frege> chrisdone: hah thanks
16:40:30 <frege> @src f
16:40:30 <lambdabot> Source not found. Just try something else.
16:40:39 <frege> of course
16:40:46 <frege> it's a variable
16:41:04 <frege> that's recursion right?
16:41:37 <frege> what does : mean in 'f x : map f xs'
16:41:42 <dor> it's an argument to map
16:41:52 <dor> : is list cons
16:42:03 <Nimatek> :t (:)
16:42:03 <Philonous> frege, : is a lists constructor
16:42:04 <dor> @src []
16:42:04 <lambdabot> data [] a = [] | a : [a]
16:42:06 <lambdabot> a -> [a] -> [a]
16:42:15 <Philonous> frege, it prepends an element to a list
16:42:18 <Maxdamantus> :t "foo" : ["bar", "baz"]
16:42:19 <lambdabot> [[Char]]
16:42:23 <Maxdamantus> > "foo" : ["bar", "baz"]
16:42:24 <lambdabot>   ["foo","bar","baz"]
16:42:29 <frx> > 1 : [2,3]
16:42:31 <lambdabot>   [1,2,3]
16:42:43 <frx> > 1:2:3:[]
16:42:44 <lambdabot>   [1,2,3]
16:42:46 <frege> gotcha
16:43:05 <Philonous> > let (x : xs) = [1,2,3] = x
16:43:07 <lambdabot>   <hint>:1:24: parse error on input `='
16:43:13 <Philonous> > let (x : xs) = [1,2,3] in x
16:43:14 <lambdabot>   1
16:43:23 <ksira> :t lift $ fmap
16:43:24 <lambdabot> (Functor f, MonadTrans t) => t ((->) (a -> b)) (f a -> f b)
16:43:49 <PHO_> why lambdabot can show the source for [a]? it's a compiler built-in
16:44:10 <dor> because @src is a hand-written database
16:44:21 <dor> not actually the source code
16:44:25 <hpc> also it's technically it's not built-in
16:44:37 <chrisdone> dor: what's with the new nick? you just wanna be like hpc, don't you?
16:44:40 <PHO_> i see
16:44:41 <hpc> the syntax for [stuff between brackets] is built-in, and [] is a special lexeme
16:44:58 <hpc> data [] a = [] | a : [a]
16:45:00 <frege> guys my goal is to do DSP with haskell
16:45:01 <dor> chrisdone: laptop in bed, don't have nickserv password ;)
16:45:20 <dor> chrisdone: dor being the rafsi
16:45:21 <frege> but I think I will need to communicate with modules in other languages as well
16:45:22 <hpc> (also ':' is the only upper-case symbol)
16:45:33 <hpc> chrisdone: i wasn't the first three-letter
16:45:36 <frege> do you think haskell is capable of doing that for soft real-time?
16:45:53 <chrisdone> hpc: don't be so modest
16:46:16 <chrisdone> dor: i was confused, as your nick is normally blue. now it's orange =)
16:46:44 <dor> chrisdone: but you still thought it was me? :P
16:47:18 <chrisdone> dor: yeah, somehow i could tell from a few sentences. that's true love
16:47:33 <hpc> what color am i?
16:47:40 <chrisdone> hpc: also blue
16:47:55 <dor> chrisdone: i was thinking style would be a give-away ;)
16:47:56 <chrisdone> i configured my nicks with the tomorrow theme… it's very limited
16:48:50 <dor> you're all blue here, because i'm trying a new client
16:49:30 <hpc> dor: so apparently you're an orange man in a blue world
16:49:47 <dor> orange you feeling blue
16:49:47 <hpc> (dabadedabadi)
16:50:09 <chrisdone> hpc: your color is this blue :) https://github.com/chriskempson/tomorrow-theme#tomorrow-night
16:50:10 <dor> actually i wish i was feeling blue. damn rubber dome keyboard :(
16:50:52 <frege> hpc: cyan for me
16:52:01 <chrisdone> oh yea
16:52:09 <chrisdone> i wanted to implement haddock browsing in emacs with w3m
17:06:00 <chrisirc> Hi. After not much ghc usage, my .cabal directory is 1GB.  Any way to trim that down?
17:06:43 <chrisirc> Aha, the majority is taken up by hoogle (its db).
17:09:18 <chrisirc> Actually not sure it's databases. .cabal/share/hoogle-4.2.15/databases$ rm -rf download/
17:09:21 <monochrom> I would expect .cabal directory size to be related to cabal-install usage, not ghc usage
17:10:42 <chrisirc> Yes. I was presuming that cabal is ghc only.
17:35:15 <rck> I understand the abstract idea of continuations, but can someone give me a few concrete examples of where they are practical?
17:36:47 <chrisdone> most practical applications are implemented as subsets of continuations
17:37:04 <chrisdone> state monad is a continuation
17:37:16 <chrisdone> most javascript code is in laborious continuation passing style
17:37:29 <chrisdone> returning to previous points in the program is nice
17:37:45 <monochrom> my http://www.vex.net/~trebla/haskell/cont-monad.xhtml is concrete, but I don't know what is "practical" to you
17:37:46 <chrisdone> parsers are continuations
17:38:03 <chrisdone> exceptions are implementable with continuations, though that's not really a practical example
17:38:07 <rck> chrisdone: parsers are the example that make the most sense in my mind right now
17:40:01 <intrados> I kind of feel like I'm keeping state with a foldr. Are there any guidelines for when to switch over to the state monad?
17:40:04 <chrisdone> rck: ajax('/get-stuff',function(result){ ajax('/more-stuff',function(etc){ … }); });
17:40:05 <chrisdone> rck: could be much easier implemented as:
17:40:05 <chrisdone> rck: do result <- ajax "/get-stuff"
17:40:05 <chrisdone> rck:    etc <- ajax "/more-stuff"
17:40:07 <chrisdone> rck: etc.
17:40:09 <rck> monochrom: reading, thanks.
17:42:01 <rck> chrisdone: would that be 'ajax "get/stuff" >>= ajax "/more-stuff"'?
17:42:30 <rck> letting callCC or ContT unwrap it?
17:44:10 <chrisdone> rck: proper example https://github.com/faylang/fay/blob/master/examples/Cont.hs
17:44:36 <rck> chrisdone: thanks
17:44:57 * chrisdone →  bed
17:47:22 <canalha> hey
17:48:04 <Tekmo> Hi!
17:58:28 <DarkFox> Morning world
17:58:34 <DarkFox> More like evening :P
18:02:00 <Tekmo> Morning!
18:03:24 <DarkFox> Hai Tekmo
18:03:28 <Tekmo> Hi! :)
18:03:38 <DarkFox> Hows the life.hs?
18:03:49 <Tekmo> Good.  It still type-checks
18:03:59 <DarkFox> Awesome
18:04:04 <Tekmo> How about you?
18:04:14 <DarkFox> Typechecks with warnings :3
18:04:17 <Tekmo> :)
18:05:05 <DarkFox> Tekmo: Warnings patched, typechecks valid.
18:05:19 <DarkFox> Tekmo: Happen to have access to World/libs?
18:05:41 <Tekmo> It's proprietary
18:05:50 <DarkFox> Damn
18:06:10 <DarkFox> Lets make open alternative?
18:06:14 * DarkFox wonders how to swap over..
18:06:37 <DarkFox> Current world has no migrate between worlds function...
18:06:54 <Tekmo> Alright, I'll throw up a github repo with a TODO: Solve world, and then just start handing out commit bits
18:07:25 <DarkFox> New world would fit in Github? :O
18:07:55 <Tekmo> Maybe I have to buy a premium account
18:08:08 <DarkFox> Well, for the core, I guess so. But definatly not ever soul.
18:10:34 <DarkFox> 12:57:00             --> tomboy65 has joined (~tomboy64@unaffiliated/tomboy64)
18:10:36 <DarkFox> 12:58:52             <-- tomboy64 has quit irc (Ping timeout: 272 seconds)
18:10:45 <DarkFox> Damn timeout instantly!?
18:11:15 <DarkFox> And pretty sure that is only 112 seconds...
18:11:29 <DarkFox> Oh differnet nmbers
18:11:31 <DarkFox> That's akwward
18:11:35 <Tekmo> Oops.  That's my fault.  There was a bug in my world implementation
18:11:36 <DarkFox> awkward *
18:11:58 <DarkFox> Tekmo: I think we should patch governments.hs first.
18:12:43 <DarkFox> I have a crypto anon goverment innovation idea. We could implement that.
18:12:46 <DarkFox> :-)
18:12:51 <Tekmo> What is it?
18:13:06 <DarkFox> Lets just say, the courts are on IRC :D
18:13:29 <zomg> The timeout was probably from the time he connected to the server
18:13:42 <zomg> As the server sends a ping request when you connect, and his client just lagged so badly :p
18:13:45 <DarkFox> zomg: Timeouts work from the last interaction from the user's client.
18:13:59 <DarkFox> zomg: The numbers were different.
18:14:02 <zomg> Yeah exactly so maybe the last interaction was when he connected =)
18:14:06 <DarkFox> zomg: Therefore, different connections.
18:14:20 <DarkFox> IT would take the join as the last success
18:14:27 <zomg> Though I'm not 100% sure if it actually counts it from that or from the PING request
18:14:48 <DarkFox> It will never PING if you don't shut up for long enough :P
18:15:01 <zomg> It actually does
18:15:03 <DarkFox> I had a bot that never pong'd but it would ping back XD
18:15:05 <zomg> Depends on the server I believe
18:15:08 <DarkFox> Indeed
18:15:38 <DarkFox> But in those bot logs, if I was talking to the bot causing it to reply. It wouldn't get any ping from the server.
18:16:10 <DarkFox> zomg: If the IRC servers checks for latency, and depends on it, then you must pong, otherwise, if you get a ping and you talk somewhere else, the pong was optional.
18:16:29 <DarkFox> This *might* be in the RFC or just a common side-affect.
18:16:44 <DarkFox> I'll be reading that RFC again somewhat soon too..
18:16:51 <zomg> well at least when I was fiddling with the irc protocol level things, not responding to a ping would always drop you out
18:16:58 <zomg> even if you were interacting with the server otherwise
18:17:21 <DarkFox> zomg: Are you refering to an initial ping on connect or ping throughout connection?
18:17:28 <zomg> both
18:17:38 <DarkFox> Which network? O_o
18:17:44 <DarkFox> Not freenode...?
18:17:51 <zomg> eh can't remember =)
18:18:10 <DarkFox> Freenode is from which the behavour I'm speaking from experience with.
18:18:27 <DarkFox> And another network, siverirc I think.
18:18:49 <DarkFox> zomg: Feel like writing a attroparsec parser for me? :D
18:19:05 <bz> sum $ zipWith (*) a b
18:19:12 <zomg> no, I feel like going to bed as it's pretty late here
18:19:13 <zomg> =)
18:19:21 <bz> is there a terser or faster way to arrive to a scalar product?
18:19:22 <DarkFox> Heh
18:19:28 <DarkFox> Night zomg
18:19:46 <DarkFox> zomg: Wait, you leaving now or soon? :P
18:19:59 * DarkFox was in here at 1 something last night.
18:20:06 <DarkFox> So less than 12 hrs ago.
18:20:17 <DarkFox> Then didn't want to get out of bed from when I woke up... Several hours ago.
18:35:42 <AshyIsMe> i should be working on my nodejs project (or rewriting it in haskell) but ive been playing dwarffortress all morning
18:37:03 <dbuckalew> AshyIsMe: you mean playing a game is more fun than programming? :)
18:38:01 <AshyIsMe> heh, sometimes i guess
18:38:23 <AshyIsMe> ive had niggling ideas of writing a dwarffortress clone in haskell
18:38:39 <AshyIsMe> ive only ever done one game before though
18:38:41 <dbuckalew> that sounds like fun
18:38:53 <AshyIsMe> super basic bubble cannon clone on android
18:39:04 <dbuckalew> i'm just getting in to haskell, so i'm nowhere near thinking of making something quite so grand yet
18:39:14 <AshyIsMe> yeah im new to it too
18:39:37 <AshyIsMe> gonna do some stockmarket stuff with it too
18:39:43 <AshyIsMe> er, first*
18:40:26 <dbuckalew> you have fun with that :)
19:04:13 <funfunctor> hi
19:05:20 <funfunctor> I am just writing some bits to convert between several base number systems.. Instead of writing all these functions is there a way I can just define say hex in a data type and derive a bunch of things I need?
19:05:43 <funfunctor> That way things stay well-typed
19:06:04 <edwardk> > base 16 # 123818
19:06:07 <lambdabot>   "1e3aa"
19:07:10 <spaceships>  /msg lambdabot @type base
19:07:24 <spaceships> excuse me
19:07:36 <edwardk> :t (base)
19:07:38 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
19:08:01 <funfunctor> Is that in the prelude, I didn't notice?
19:08:06 <edwardk> its in lens
19:08:10 <funfunctor> ahhh
19:08:22 <funfunctor> I didn't think about lens
19:08:47 <edwardk> > Numeric.showHex 123
19:08:49 <lambdabot>   <[Char] -> [Char]>
19:09:27 <edwardk> there is something like that in Numeric as well
19:09:29 <edwardk> but its harder to use
19:09:33 <haasn> > showIntAtBase 16 intToDigit 123
19:09:34 <lambdabot>   <[Char] -> [Char]>
19:09:38 <haasn> > showIntAtBase 16 intToDigit 123 ""
19:09:40 <lambdabot>   "7b"
19:09:58 <funfunctor> yea I already wrote a function to do it..
19:10:38 <haasn> > review hex
19:10:39 <funfunctor> What I want is it to be well-typed in a way that if I provide it with a base 10 and it gives me base 16 then the output will be of type Hex
19:10:39 <lambdabot>   No instance for (Control.Monad.Reader.Class.MonadReader b0 m0)
19:10:40 <lambdabot>    arising f...
19:11:01 <funfunctor> So I guess I would need to make a class
19:11:02 <edwardk> where Hex is a newtype or somesuch?
19:11:09 <funfunctor> yes
19:12:12 <edwardk> or just call Hex . showIntAtBase 16 intToDigit ;)
19:12:19 <edwardk> for a newtype constructor Hex ;)
19:13:49 <funfunctor> derr, yea that would be the smart thing to do ! Thanks !
19:16:30 <funfunctor> I tried newtype Hex = Hex . showIntAtBase 16 intToDigit am I missing something?
19:17:57 <funfunctor> ah these are from lens too
19:18:18 <edwardk> showIntAtBase is in Numeric, not lns
19:18:22 <edwardk> er not lens
19:18:26 <funfunctor> ok
19:18:28 <edwardk> :t Numeric.showIntAtBase
19:18:29 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
19:19:11 <funfunctor> so do I need a parameter or something in that newtype?
19:19:20 <frx> :t (#)
19:19:21 <lambdabot> parse error on input `)'
19:19:22 <edwardk> newtype Hex = Hex String
19:19:39 <edwardk> (#) is used to build up a structure with a prism
19:19:42 <edwardk> > _Left # 4
19:19:43 <lambdabot>   Left 4
19:19:51 <edwardk> a prism acts like a smart constructor you can pattern match on
19:19:57 <edwardk> > Left 4 ^? _Left
19:19:58 <lambdabot>   Overlapping instances for Data.Monoid.Monoid (Data.Monoid.First b0)
19:19:58 <lambdabot>    aris...
19:20:00 <edwardk> > Right 4 ^? _Left
19:20:02 <lambdabot>   Overlapping instances for Data.Monoid.Monoid (Data.Monoid.First b0)
19:20:02 <lambdabot>    aris...
19:20:11 <edwardk> wut
19:20:24 <edwardk> elliott: ^- ?
19:21:53 <funfunctor> but if I define the type, newtype Hex = Hex String, I can't check I don't have something like 4Z
19:22:01 <funfunctor> which is invaild ofcourse
19:24:04 <edwardk> i don't really see the point in a Hex newtype. just store a number and convert it to hex on demand
19:24:13 <funfunctor> I wrote a radix conversion function which is vaild for 0<=x<=20
19:24:18 <edwardk> rather than storing some string that happens to be in an encoding
19:24:51 <edwardk> you can hide the constructor from the user and only ever permit it to be constructed by means that preserve your invariants
19:24:54 <edwardk> but thats up to you
19:25:38 <elliott> edwardk: ask int-e :P
19:28:13 <edwardk> elliott?
19:28:16 <edwardk> what changed
19:28:27 <edwardk> he take over the bot?
19:28:37 <edwardk> int-e: ^- ? =)
19:28:50 <wolftune> hi, quick question: what resources would folks recommend to a beginning programmer who wants to start with Haskell? (most tutorials assume you know other things and then go through the hassle of explaining how you have to change your assumptions)
19:29:01 * edwardk begins to speak solely in pictographs
19:29:16 <funfunctor> I suspect the invariant constructor is the right thing to do.
19:29:38 <w3pm> wolftune: that is funny but true, never considered learning haskell from the perspective of someone completely new to programming ;)
19:30:10 <edwardk> wolftune: Real World Haskell is a good crash course for someone who already speaks systems programming, but not so good for starting from scratch. Learn You a Haskell doesn't assume you have bad habits to unlearn, but doesn't get far
19:30:27 <rck> if you're brand new maybe read How To Design Programs first, then transition to haskell
19:30:39 <funfunctor> there are these haskelllive videos poping up on youtube that look good to follow along.. I want to implement FASTA maybe this evening
19:30:43 <rck> http://www.ccs.neu.edu/home/matthias/HtDP2e/
19:30:44 <wolftune> edwardk: so Learn You A Haskell is the best bet that you know of?
19:30:51 <edwardk> so far
19:31:12 <edwardk> maybe andres loeh's book when it comes out will be a better intro
19:31:23 <edwardk> if not maybe i'll have to give in and write one ;)
19:31:58 <ReinH> edwardk: oh hai
19:32:10 <wolftune> everyone keeps saying that it could be easier than having to unlearn all these other things, but none of the resources are written with beginner as audience
19:32:10 <edwardk> hya ReinH
19:32:17 <ReinH> edwardk: please write one
19:32:18 <funfunctor> edwardk: want to make that a opensource book like the HoTT one ;) ? I already have chapter 1,2 done for you to explain x86 asm :)
19:32:21 <edwardk> wolftune: true
19:32:25 <ReinH> edwardk: tell you what, we can coauthor
19:32:36 <edwardk> funfunctor: thats actually the plan if i decide to proceed
19:32:42 <ReinH> seems good!
19:32:59 <ReinH> edwardk: I am in Miami drinking mojitos at a Ruby conference :D
19:33:08 <ReinH> and I don't even like Ruby...
19:33:09 <funfunctor> edwardk: done, I have a couple of chapters for you already and the LaTeX book framework done.
19:33:15 <w3pm> "The Haskell Road to Logic, Maths and Programming. Second Edition" is a great book, doesn't assume prior language knowledge at all
19:33:21 <edwardk> ReinH: i've been plannng on just settng up an outline and seeing if i can't interest a bunch of folks in collaborating
19:33:21 <w3pm> but im not sure its the best book for learning to program
19:33:29 <w3pm> mainly just an interesting math book with programming solutions
19:33:31 <ReinH> w3pm: It's quite nice for maths but doesn't teach much haskell
19:33:38 <w3pm> ReinH: yeah exactly
19:33:39 <ReinH> w3pm: it's a great introduction to formal proof systems though
19:33:46 <funfunctor> w3pm: yea I liked that book because it teaches programming from a mathematical prospective
19:33:50 <ReinH> which are a really nice mental framework for using haskell
19:34:02 <edwardk> ReinH: i don't have the bandwidth to write the whole thing, but i do have a pretty solid outline of what i've used to teach folks haskell for the last few years, and a firm grasp of what i want in a haskell text
19:34:13 <ReinH> edwardk: yeah that's why I suggested coauthoring :)
19:34:35 <edwardk> ReinH: let's talk when i'm back in the states
19:34:37 <wolftune> well, yeah that would be great
19:34:39 <w3pm> that book makes alot of very basic haskell concepts make alot of sense though
19:34:41 <ReinH> edwardk: I had a contract like that with Kent Beck back in the day to port Smalltalk Best Practice Patterns to Ruby
19:34:42 <w3pm> but doesnt go much beyond that
19:34:46 <ReinH> but it fell through because politics :(
19:35:15 <ReinH> specifically my managing editor was also my boss and I quit
19:35:21 <edwardk> fair
19:35:25 <wolftune> in my personal case, I got into making a website with someone else who knows and is building it with Yesod, and I need to (and want to) learn how to work on things in the coding side
19:36:06 <funfunctor> I have a good grasp of mathematics and LaTeX
19:36:22 <funfunctor> and more low level compiler backend stuff
19:36:57 <edwardk> ReinH: color me interested but momentarily overwhelmed by circumstance
19:37:01 <ReinH> wolftune: start with the code and use that as a forcing function to learn Haskell
19:37:07 <ReinH> edwardk: totes understood
19:37:16 <ReinH> edwardk: if you have an outline floating around I'd be interested to read it :)
19:37:25 <edwardk> its mosly in my head =)
19:37:34 <ReinH> edwardk: ok we'll talk later no worries
19:37:43 <ReinH> edwardk: we've spent literally decades not writing this book
19:37:44 <Platz> People keep saying without the baggage of experience haskell is easier.  I don't buy it.  There's something straightforward about seeing lines execute and modify state in a direct way.  When you have to worry about complexity then maybe jump over to pure FP
19:37:45 <ReinH> it can wait a bit
19:37:46 <ReinH> ;)
19:37:47 <wolftune> ReinH: that's what I've done up to now, and it's a good approach, but I would really like a general intro and reference appropriate for me if there was one
19:38:05 <ReinH> wolftune: LYAH and RWH are probably the best current resources
19:38:12 <w3pm> Platz: i agree that you cant truly appreciate haskell until seeing the grass on the other side, so to speak ;)
19:38:15 <ReinH> but I assume they've been mentioned and summarily dismissed ;)
19:38:26 <edwardk> Platz: depends on how you think i think.
19:38:33 <ReinH> w3pm: Haskell grass does not grow until it is observed.
19:38:46 <wolftune> ReinH: yeah, I'm aware of those and have planned to read them, I just wanted to drop in and see if anyone had other suggestions
19:38:51 <ReinH> wolftune: cool :)
19:39:05 <Platz> edwardk: true, not everyone thinks the same
19:39:08 <ReinH> wolftune: this channel is a good resource :)
19:39:15 <wolftune> if my question leads to writing something new, then certainly glad I brought it up ;)
19:39:29 <edwardk> How to Learn Haskell: Chapter 1: Ask Cale about Monads
19:40:16 <edwardk> Chapter 2: Ask Cale about Applicative Functors
19:40:21 <ReinH> hahahaha
19:40:26 <Cale> lol
19:40:35 <ReinH> edwardk: I've spent most of this Ruby conference trying to tell people about Haskell
19:40:35 --- mode: Cale set -o Cale
19:40:41 <ReinH> I explained catamorphisms earlier
19:40:43 <edwardk> Chapter 3: Complain to Cale that Functor is not a Functor
19:40:53 <ReinH> edwardk: that one has actually been bothering me?
19:40:56 <ReinH> what's the story there
19:40:57 <ReinH> heh
19:40:58 <simpson> Chapter 7: Cale explains parsers
19:40:59 <wolftune> ReinH: thanks, I'll try to get more involved, but I need to get to where I have enough sense of things to even know where to start asking good questions
19:41:00 <ReinH> Cale: please explain
19:41:14 <Cale> ReinH: Which one?
19:41:16 <ReinH> wolftune: even bad questions can be good questions
19:41:18 <simpson> Also Chapter 8: Cale and the Chamber of Lenses
19:41:28 <ReinH> Cale: Why is Functor called Functor? What's its relationship to functors?
19:41:43 <Cale> The Functor class is for type constructors which give an endofunctor on the category of Haskell types.
19:41:45 <ReinH> simpson: so good
19:42:07 <edwardk> (it really is a functor, btw) just restricted to endofunctors on Haskell types
19:42:13 <wolftune> ReinH: thanks for the encouragement, I think the first thing is for me to get a sense of what is Yesod-specific vs Haskell when I'm dealing with code issues
19:42:29 <Cale> If there's an instance of Functor f, then the functor involved acts on a type t to produce f t
19:42:46 <Cale> and it acts on functions a -> b to give functions f a -> f b, via fmap
19:42:47 <wolftune> otherwise, some point soon I need to start recruiting people to work on the open-source code so that they know what it is I'm even asking about…
19:42:51 <edwardk> wolftune: there you are already in a world of hurt. i usually encourage folks to spend 6 months learning haskell before they try to do something in one of the web frameworks
19:42:51 <ReinH> Cale: ok, but how is that different from data constructors in general?
19:42:59 <edwardk> that way you have a firm understanding of the different layers involved
19:43:05 <Cale> Type constructors and data constructors are two different things
19:43:17 <Cale> Type constructors live in the world of types, on the right hand side of the ::
19:43:29 <wolftune> edwardk: yeah, that makes sense, but I'm helping build a site that someone else is the main coder doing the Yesod stuff
19:43:29 <Cale> Data constructors are values and they live on the left hand side of the ::
19:43:44 <ReinH> Cale: I know that. I guess I misunderstood what you said.
19:43:47 <Cale> Not every type constructor gives a functor
19:44:05 <edwardk> wolftune: sure, just wanted to not that you're going to have a bit harder time of it as a result
19:44:05 <ReinH> Ok, functor acts on a type
19:44:14 <Cale> For example, try coming up with a suitable fmap for  data T a = T (a -> a)
19:44:55 <edwardk> the functor maps objects to objects and arrows to arrows, right? the objects here are types, it maps a    to f a , and it maps arrows from a -> b   to arrows btween f a -> f b preserving the connectedness of the category, and taking the identity arrow to the identity arrow
19:45:05 <Cale> ReinH: Oh, I suppose I might've checked that you're familiar with what functors are in category theory :)
19:45:09 <wolftune> edwardk: thanks for the warning, and that's why I am looking for general resources to work on before diving as much into the site stuff, but I already do a lot of the Hamlet and Cassius stuff in Yesod anyway
19:45:10 <edwardk> those are the two functor laws, fmap id = id and fmap f . fmap g = fmap (f . g)
19:45:16 <ReinH> edwardk: that's what I was missing
19:45:25 <ReinH> Cale: A functor is a category homomorphism :)
19:45:37 <ReinH> fmap maps the arrows
19:45:40 <Cale> right
19:45:40 <ReinH> That's what I was missing
19:45:44 <edwardk> exactly
19:45:45 <ReinH> Ok makes sense now
19:46:28 <Cale> If you read fmap's type as  Functor f => (a -> b) -> (f a -> f b)  (with the extra parens), it's a bit clearer that something functorial is going on
19:46:56 <ReinH> Cale: yep, I get it now :D
19:47:17 <edwardk> class (Category c, Category d) => Functor f c d | f -> c d where fmap :: c a b -> d (f a) (f b)
19:47:39 <funfunctor> edwardk: here is a LaTeX framework for a book should you wish to continue https://github.com/victoredwardocallaghan/haskell_book
19:48:11 <edwardk> funfunctor: filed away. i've got somethng similar from a previous project but more resources are always good
19:48:19 <edwardk> bbiab
19:48:46 <funfunctor> edwardk: its got bits from a more maths book I was writing.. so you may wish to disregard them
19:49:39 <funfunctor> edwardk: well not sure about the overall structure however I can commit the bits about x64 asm if you think that would be good to have?
19:50:34 <funfunctor> I also have some category theory notes in my github and other maths notes too if you look in openware
19:50:42 <ReinH> Cale: yep, I get it now :D
19:51:00 <Cale> okay okay :)
19:51:03 <Cale> hehe
19:53:42 <edwardk> funfunctor: well. any haskell book i'd be working on would really be focused around two halves, basically set up as a 2 semester course in how to program in haskell, pretty much to the exclusion of other concerns, with perhaps a few later chapters devoted to enough category theory to make some of the haskell stuff fit it exposes into the world of mathematics better, but rather non-systems oriented
19:53:58 <edwardk> basically i want the antithesis of real world haskell ;)
19:54:36 <edwardk> that way it could serve as a more principled replacement for LYAH in the RWH + LYAH recommendation we usually give folks
19:55:18 <ReinH> edwardk: btw why are Cofree Comonads called Cofree? Aren't they just free?
19:55:36 <edwardk> no, free is left adjoint to a forgetful functor
19:55:42 <edwardk> cofree is right adjoint to a forgetful functor
19:56:10 <ReinH> OH
19:56:11 <ReinH> ok then
19:56:22 <edwardk> so there is a deep abiding reason for the name =)
19:56:25 <ReinH> I need to remind myself what adjoint means
19:56:31 <ReinH> edwardk: I figured as much :p
19:56:43 <funfunctor> edwardk: yep makes sense I am just thinking of all the bits I already have written :)
19:57:08 <edwardk> F -| G, "F is left adjoint to G" when (F a -> b)    is isomorphic to (a -> G b)
19:57:14 <funfunctor> I have some lambda calc notes written too
19:57:39 <ReinH> edwardk: oh is that all
19:57:52 <ReinH> edwardk: and right adjoint is... the reverse?
19:58:11 <edwardk> (- , e) -| (e -> -)     because (a, e) -> b  is isomorphic to a -> e -> b
19:58:12 <funfunctor> be back later..
19:58:20 <ReinH> oh
19:58:21 <ReinH> huh
19:58:26 <ReinH> sure
19:58:32 <edwardk> F -| G has G is the right adjoint of F
19:58:40 <ReinH> edwardk: right so co
19:58:42 <ReinH> ok then
19:58:58 <oio_> can i do this type (a,b,c) = String, String ,Bool ?
19:59:19 <edwardk> now th arrows there don't have to be in Hask. they can be other categories
19:59:36 <ReinH> oio_: (String, String, Bool), sure
19:59:36 <edwardk> you can find that there is an adjunction through Hask^op for (- -> r) as well.
20:00:14 <oio_> ReinH: Cool
20:17:49 <Platz> is there any special history that explains why we say "a function is applied to a value" or "a function is mapped over a value", rather than the other way where we think of arguments being applied to functions?
20:18:18 <Platz> or is just a matter of grammatical preference
20:19:05 <Platz> or is it because in the lambda calculus the latter doesn't have meaning or something
20:19:40 <Iceland_jack> I've never heard ‘mapped over a value’ referring to function application
20:19:53 <Cale> Neither have I
20:20:28 <Cale> Platz: Well, the tendency is to think of functions as processes and values being things that those processes act upon.
20:21:01 <Cale> It's not really a math thing specifically, but an English thing. Processes are applied to the things they happen to.
20:21:24 <Tekmo> Well, here's a counterpoint
20:21:34 <Tekmo> We sometimes say that you "apply a given setting"
20:21:50 <Tekmo> If you think of a function's argument as a parameter/setting, then it makes sense to apply it
20:23:12 <Platz> Tekmo: except it's said 'apply the function to the value' not 'apply the setting to the function'
20:23:21 <Tekmo> True
20:23:52 <Luke> can anyone help with a type issue in snap + heist here? http://lpaste.net/2797752056075517952
20:23:59 <Luke> i noted where the compiler error is referencing
20:24:09 <Platz> I think Cale's on the right track there.
20:24:22 <Iceland_jack> The answer is basically what Cale said, functions are some process by which the output is computed so we apply that process to the input
20:24:25 <Cale> It's about how the transitive verb form of apply is used in English
20:25:08 <Tekmo> Luke: withTop is not an `IO` action
20:25:32 <Tekmo> Luke: Try removing the `lift` right before `withTop`
20:25:45 <Tekmo> Luke: In other words: race <- withTop ...
20:25:52 <Luke> Tekmo: thanks i'll try that
20:26:16 <Tekmo> Luke: Or maybe what you want is: race <- withTop db $ lift $ getRace rid
20:26:21 <Luke> how did you know this was going to lift to IO?
20:26:36 <Tekmo> Luke: The compiler error told me
20:26:42 <Tekmo> Luke: Also, your type signature is wrong
20:27:04 <Tekmo> Luke: Or your `lift` is wrong
20:27:09 <Luke> kind mismatch
20:27:11 <Tekmo> Luke: You may need to replace `lift` with `liftIO`
20:27:16 <Luke> tried that
20:27:24 <Tekmo> Luke: Try removing the type signature first and see what happens
20:27:28 <Luke> I'm not sure if I have an IO action when I don't or need one when I do
20:27:36 <Luke> if I remove the signature how will it know what monad i want?
20:27:49 <Tekmo> Luke: The compiler figures things out
20:28:00 <Tekmo> Luke: And then you can ask the compiler what type the function was
20:28:10 <Tekmo> Luke: That only works if it type-checks, though
20:28:25 <Tekmo> Luke: So it still helps to have a mental model of what is going on so that you can get to the point where it type-checks
20:28:28 <Luke> hmm same problems even with the type signature gone. removing "lift" causes kind errors
20:28:56 * hackagebot tdd-util 0.3.0.0 - Test framework wrapper  http://hackage.haskell.org/package/tdd-util-0.3.0.0 (ByronJohnson)
20:29:01 <Tekmo> Luke: Ok, so let's be methodical about this
20:29:11 <Tekmo> Luke: The first way you debug these things is to find out what the types mean
20:29:18 <Tekmo> Luke: We need to first lookup what `Splice` is
20:29:29 <Tekmo> Luke: Sometimes a thing like `Splice` is a type synonym that expands out to something larger
20:29:44 <Luke> yeah definitely
20:29:46 <Luke> i have all the docs open
20:30:11 <Tekmo> Luke: In this case it is: type Splice n = HeistT n IO (DList (Chunk n))
20:30:21 <Tekmo> That tells a lot once you know how to read these things
20:30:26 <Luke> http://snapframework.com/docs/tutorials/compiled-splices here's the guide. http://hackage.haskell.org/package/snap-0.13.0.4/docs/Snap-Snaplet-Heist-Compiled.html and http://hackage.haskell.org/package/heist-0.13.0.2/docs/Heist-Compiled.html
20:30:32 <Tekmo> Are you familiar with monad transformers?
20:30:35 <Luke> yes
20:30:39 <Tekmo> Ok
20:30:45 <Tekmo> So in this case your use of `lift` was correct
20:30:51 <Tekmo> As long as the argument of `lift` is an `IO` action
20:31:01 <Tekmo> We can think of it as having the following specialized type:
20:31:01 <Luke> it is
20:31:04 <Luke> access the db
20:31:09 <Tekmo> lift :: IO r -> HeistT n IO r
20:31:21 <Tekmo> So now let's look at the type of `withDB`
20:31:31 <Tekmo> Sorry, `withTop` is what I meant
20:33:10 <Tekmo> Ok, I found it here: http://hackage.haskell.org/package/snap-0.13.0.2/docs/Snap-Snaplet.html#v:withTop
20:33:38 <Tekmo> So it looks like it expects to only be run in the `Initializer b v` or `Handler b v` monads
20:34:11 <Tekmo> I don't see a `MonadSnaplet` instance for `HeistT`
20:34:19 <khyperia> Can anyone help me install Harpy on windows (or similar)? I tried llvm-general, and I just got overwhelmed by the sheer quantity and complexity of everything.
20:34:35 <Luke> ok I suspected as much. I was also trying with SnapletCSplice m
20:34:38 <Luke> instead of Splice m
20:35:00 <Tekmo> So it's important to also think about what the type error means
20:35:07 <Luke> in fact when I remove the type signature roughly the same error occurs but on the last line withSplices
20:35:27 <Tekmo> Is it sensible to run `withTop` within a `Splice`?
20:35:42 <Luke> no its not
20:35:47 <Luke> that's what I'm asking about =)
20:35:54 <Tekmo> Oh, ok :)
20:35:58 <Luke> i know the types don't make sense. I can't figure out how to put them together to make sense
20:36:12 <Tekmo> So let me look closer and see if there's another way to accomplish what you want
20:36:38 <Ghoul_> does ghc use m4
20:37:02 <Ghoul_> actually, nvm. it doesn't.
20:37:14 <Luke> Tekmo: thanks for helping btw. I think doug's given up on me
20:37:21 <Tekmo> Luke: Ha! :)
20:37:42 <Tekmo> Doug is actually a really nice guy, so don't think less of him for that
20:37:43 <flebron> Is there a more idiomatic way of writing fmap lines . hGetContents? Perhaps with Applicative?
20:38:31 <Tekmo> flebron: For point-free style I'd prefer what you just wrote
20:39:18 <haasn> fmap lines <$> hGetContents -- ? :)
20:40:26 <Tekmo> Luke: Ok, so I'm studying how the `Heist` monad interacts with the rest of the system right now
20:40:43 <Luke> basically through SnapletCSplice
20:40:55 <Luke> before that you're in heist and and after that you're in snap land
20:41:29 <Luke> Tekmo: or you mean just within the context of heist?
20:42:03 <Tekmo> The former, how it interacts with `snap`
20:46:29 <Tekmo> Ok, so looking at the definition of `Heist`, it looks like it is basically the same as `ReaderT Node (StateT (HeistState n) m) r`
20:46:40 <Tekmo> Which means that the only information it knows about is that `Node` and `HeistState`
20:46:55 <Tekmo> It does not know anything about the Snaplet state
20:47:08 <Luke> right
20:47:36 <Luke> reader = templates and heist state is the splices applied to templtes
20:48:39 <Tekmo> So when is the `HeistT`/`Splice` run in the course of the web server's lifetime?
20:48:44 <flebron> Why could it be that, given a file with several lines "foo.txt", main = withFile "foo.txt" ReadMode ((>>= putStrLn . concat . lines) . hGetContents) only outputs the first one, but if I replace concat with unlines, all lines are outputted? Is this a combination of withFile closing things too early, and some optimization pragma unlines.lines=id in GHC?
20:49:07 <Luke> Tekmo: in this case, compiled splices, at startup
20:49:47 <Luke> Tekmo: everything gets compiled down to byte strings and "holes" for data to go. the data needs to come form a monad (like the lens for the DB i'm trying to pass in)
20:49:48 <Tekmo> Luke: Oh, I see.  That's what you set up in your `addSplices` function
20:49:54 <Luke> yeah
20:49:56 <xpika> I'm looking for a template Haskell Code String to ExpQ where "1+1" == [| 1 + 1 |]
20:50:18 <Luke> Tekmo: addSplices happens at startup in the Initializer
20:50:36 <Tekmo> Yeah, I'm familiar with the `Initializer` part
20:50:41 <Luke> Tekmo: So I have splices which take RuntimeSplies (holes) and I'm trying to meet in the middle here
20:51:23 <xpika> all I found was a function to turn a string into a string literal Expression
20:51:37 <Tekmo> Luke: In this case it looks like you will have to pass that information in as a parameter to `compiledSplices`, which would in turn pass it to `raceSplice`
20:51:47 <Luke> Tekmo: doug told me earlier today that I should attempt to bind the RuntimeSplice with some monadically captured data in the Splice where the error is
20:51:47 <enthropy> flebron: maybe try changing how stdout is buffered?
20:52:04 <Luke> Tekmo: yeah thats the "db" lens
20:52:10 <Tekmo> Luke: In other words, you run your `withTop` command within your `addSplices` function and then pass the result of that to your splice
20:52:26 <Luke> I tried that earlier. Couldn't get it to work
20:52:31 <Tekmo> Luke: No, not the lens.  I mean, use the lens to retrieve the value within the `addSplices` function
20:52:38 <Luke> The trouble is how do I get a RuntimeSplice m Race
20:52:56 <flebron> enthropy: No change with hSetBuffering stdout NoBuffering .
20:53:28 <Luke> Tekmo: to that question, doug said that's what the "withSplices" is for
20:54:46 <Luke> Tekmo: I suspect the raceSplice type should actually be :: SnapletCSpilce to handle the snap + heist integraiton
20:54:51 <Tekmo> Wait
20:55:09 <Tekmo> So does this value need to be computed dynamically or can it be computed once at load time?
20:55:12 <[swift]> hmm.. how can i log stuff during an STM transaction?
20:55:16 <[swift]> Debug.Trace maybe?
20:55:43 <enthropy> flebron: I can't reproduce what you describe
20:55:48 <lpaste> flebron pasted “Reading only the first line.” at http://lpaste.net/95427
20:56:24 <Luke> Tekmo: dynamically and then put into the RuntimeSplice whole
20:56:26 <Luke> hole*
20:56:42 <enthropy> style-wise  ((>>= putStrLn . concat . lines) . hGetContents) looks much better as   (putStrLn . concat . lines <=< hGetContents)
20:56:48 <flebron> Sorry, seems to be the last line, not the first line.
20:57:04 <Luke> Tekmo: the splice just has to know how to fill the hole at start time, but actually fill it at run time
20:57:55 <Tekmo> So in other words, there is a component that fills some holes at load time, and then another component that fills them in on a per-request basis?
20:58:16 <Luke> right
20:58:21 <flebron> enthropy: Running that with the text file "1\n2\n3\n4\n" in foo.txt (\n being a newline), results in only "4" in stdout.
20:59:09 <enthropy> well with a file "a\nb\nc\nd\ne\nf\n" I get "abcdef" out main = withFile "foo.txt" ReadMode ((>>= putStrLn . concat . lines) . hGetContents)
20:59:12 <Luke> Tekmo: so at start time it tries to compile all the chunks it can into contiguous ByteStrings, leaving Chunks of RuntimeSplices to be run at run time dynamically. So basically the UserName ex could change
21:01:05 <flebron> enthropy: Hrm, it seems my file has bytes "31 0d 0a 32 0d 0a 33 0d 0a 34 0d 0a", so there's trailing noise after it.
21:01:30 <flebron> Oh, it's in DOS format. CRLF.
21:01:50 <flebron> For some reason that must be confusing either lines, unlines, concat, or all of them.
21:03:59 <Tekmo> Ok, so `SplicesM s` is basically a more efficient version of `Writer (Map Text s)`
21:04:21 <flebron> Yay, hSetNewlineMode worked. Thanks :)
21:04:49 <mm_freak> that reminds me
21:04:52 <DarkFox> mornfall: ping
21:05:00 <Luke> Tekmo: yeah. Splices is an alias for it
21:05:16 <mm_freak> Tekmo: the 'lines' combinator in pipes-bytestring would usually be more useful as a pipe:  Pipe ByteString ByteString m r
21:05:21 <Luke> Tekmo: he did that so he could control the overwriting semantics
21:05:23 <mm_freak> i keep reinventing it all the time
21:05:39 <Tekmo> mm_freak: It wouldn't flush the last line if there was no terminating newline
21:06:04 * DarkFox hands Tekmo world.asm - decompiled
21:06:32 <mm_freak> Tekmo: that's right, but the combinator variant is really difficult to deal with
21:06:37 <mm_freak> or perhaps i'm being stupid =)
21:07:12 <Tekmo> mm_freak: It's difficult because of the nature of the problem
21:07:32 <Tekmo> mm_freak: Consider the abstract case where we implemented something like `conduit` and we had a bona-fide `Pipe`
21:07:51 <Tekmo> mm_freak: ... assuming hypothetically that `pipes` had end-of-input detection
21:08:01 <Tekmo> mm_freak: What would you expect `lines >> lines` to do?
21:10:00 <mm_freak> Tekmo: i understand the problem, but i still wonder how to approach it
21:10:21 <Tekmo> mm_freak: The nature of the problem is that the concept of `lines` is `Producer`-centric
21:10:34 <mm_freak> Tekmo: here is a particular instance of the problem:  i have a Pipe ByteString Record m r
21:10:47 <mm_freak> it translates lines into records
21:11:02 <mm_freak> each bytestring is a line
21:11:17 <mm_freak> now i have a raw stream as produced by fromHandle
21:11:39 <mm_freak> how would i 'lines' it and then pass it to the parser pipe?
21:11:52 <mm_freak> let's call it parse :: (Monad m) => Pipe ByteString Record m r
21:11:58 <Tekmo> Oh I see
21:12:13 <Tekmo> You want to concatenate each line into a single `ByteString`
21:12:26 <mm_freak> when i use 'lines', i need to use State-based parsers within each delimited stream processor
21:12:42 <mm_freak> exactly
21:13:06 <Tekmo> So, I actually had a function for this in `pipes-parse` and then removed it at the last minute in the last patch
21:13:19 <Tekmo> Well, it was a generic folding funciton
21:13:46 <Tekmo> But basically if you gave it a fold for a `Producer`, it would turn a `FreeT` of `Producer`s into a `Producer` of each fold's result
21:14:13 <Tekmo> So what you would have done is folded the producer using a fold that concatenated all the `ByteString`s from that line, and it would create a `Producer` of  one-line-long `ByteString`s
21:14:16 <mm_freak> yeah, that would be extremely useful
21:14:20 <Tekmo> Yeah, I agree
21:14:29 <Tekmo> It's a high priority addition to the ecosystem, for two reasons:
21:14:31 <mm_freak> here is my workaround:  http://lpaste.net/95429
21:14:40 <mm_freak> it's unfortunate, because it requires the last line to be terminated
21:14:41 <Tekmo> Here, let me link you to the code for it
21:15:09 <mm_freak> no hurry…  i can wait for the next release =)
21:15:19 <mm_freak> i just wanted to note that something like that is really necessary
21:15:42 <flebron> Say I'm using hmatrix, is there a reasonable way to create an n x m matrix from an n' x m matrix, with a function f that works on n'-dimensional vectors, and returns n-dimensional vectors? i.e. apply a function to every row, though the input and output sizes differ.
21:15:50 <mm_freak> even better if it can deal with StateT for handling the EOS
21:16:16 <mm_freak> and even even better better if it does that transparently =)
21:16:20 <Tekmo> mm_freak: Here ou go: https://github.com/Gabriel439/Haskell-Pipes-Parse-Library/blob/ceeba5d4f9fbfb17404e0e916a267e8e21658234/src/Pipes/Parse.hs#L254
21:16:38 <Tekmo> mm_freak: But yeah, that function solves two common pain points with `pipes`
21:17:01 <Tekmo> mm_freak: The first pain point is that the folds in `Pipes.Prelude` drop the return value, which means that you can't use them to fold multiple layers of a `FreeT`
21:17:19 <Tekmo> mm_freak: The second pain point is that there isn't a function to convert from `FreeT ((,) a) m r` to `Producer a m r`
21:17:31 <Tekmo> mm_freak: That folder solves both of those problems simultaneously
21:18:02 <Luke> Tekmo: giving up on the heist problem?
21:18:09 <Tekmo> Luke: No, I'm still working on it! :)
21:18:16 <Luke> ha ok thanks
21:18:24 <mm_freak> thanks
21:18:41 <Tekmo> mm_freak: You're welcome
21:18:42 <mm_freak> i will ad-hoc-add those into my project for now =)
21:18:48 <Tekmo> mm_freak: Ok :)
21:18:57 <mm_freak> Tekmo: do you think that they'll be in the next release?
21:19:04 <mm_freak> (foldFree and foldMFree)
21:19:27 <Tekmo> mm_freak: Yeah
21:19:46 <Tekmo> mm_freak: The delay is that I would like to sort out a couple of things in `foldl` and have those take a `Fold` as an argument for reuse purposes
21:20:27 <mm_freak> Tekmo: that reminds me…  have you looked into sodium?
21:20:39 <Tekmo> mm_freak: Yes, a little bit.
21:21:02 <mm_freak> Tekmo: do you think there is a more categorical, pipy approach to the same abstraction?
21:21:09 <Tekmo> mm_freak: Yes
21:21:13 <Tekmo> mm_freak:  I already wrote it up
21:21:26 <Tekmo> One second ...
21:21:50 <Tekmo> The best place to begin is here: http://stackoverflow.com/questions/19201901/in-functional-reactive-programming-how-do-you-share-state-between-two-parts-of/19204253#19204253
21:22:29 <Tekmo> Then check out this for even more information: https://groups.google.com/forum/#!topic/haskell-pipes/7mDzAD9Al-8
21:22:39 <Tekmo> It's still experimental
21:22:48 <Tekmo> That's why I haven't blogged about it yet
21:23:35 <Tekmo> Luke: So the part I'm stuck on is understanding the `mapS (pureSplice . textSplice)`
21:23:50 <mm_freak> Tekmo: are you sure this solves the same problem as sodium?
21:24:24 <mm_freak> Tekmo: as a side note, it may be beneficial to flip the type arguments m and r =)
21:24:31 <mm_freak> Edge r m a b
21:24:44 <Tekmo> mm_freak: Any reason?
21:25:08 <Tekmo> mm_freak: Think of the solution as having two halves
21:25:11 <mm_freak> should someone write actual type classes for category-to-monad transformers, then the m belongs there
21:25:23 <Luke> Tekmo: https://github.com/snapframework/snap/blob/5ad1328c008e593c5f1fbcab33dd25ce3547d5d1/src/Snap/Snaplet/Auth/SpliceHelpers.hs#L99 example
21:25:41 <Tekmo> mm_freak: There is a pure arrow-based core that is the "model" and effectful inputs and outputs that are "views" and "controllers".  The views and controllers are closer to `sodium`
21:25:54 <mm_freak> and since that abstraction would be the second instance of this (along with Wire), the classes may be coming =)
21:26:29 <Tekmo> mm_freak: Oh, you are right.  I should follow the `netwire` order
21:28:11 <Tekmo> Luke: Thanks.  That makes a lot more sense
21:28:19 <Ghoul_> oh man Tekmo that MVC stuff has my juices flowing
21:28:24 <Tekmo> :)
21:28:55 <mm_freak> mine not yet, because i'm not sure how events fit into this
21:29:00 <Ghoul_> I was supposed to write about the concurrency stuff, but then my mingw blew up and it was too hard to fix so I reinstalled my entire operating system <_<
21:29:08 <Ghoul_> now I'm slowly reinstalling everything..
21:30:19 <Tekmo> mm_freak: You feed events into the system using `Input`s (i.e. controllers)
21:30:31 <Tekmo> It's best if you study the source code for `rcpl`
21:30:40 <Tekmo> A whole lot of things will make sense if you check it out
21:30:53 <Tekmo> https://github.com/Gabriel439/Haskell-RCPL-Library/blob/master/RCPL.hs
21:32:30 <Tekmo> mm_freak: The key funciton is the `rcpl` function which sets up all the events that are input to the system
21:32:42 <Tekmo> mm_freak: It then consolidates them into a single event stream, which it feeds into the pure `Arrow`-based core
21:34:02 <blaenk> is there a cabal channel? I'm wondering if I'm doing sandboxes wrong
21:34:13 <blaenk> I pulled the pandoc source, sandboxed it, installed dependencies, then built it --- all fine
21:34:46 <blaenk> then I sandboxed my own package that depends on pandoc, sandbox add-source'd the pandoc code I sandboxed, and install dependencies errors out on pandoc
21:34:57 <blaenk> setup: data/templates/default.html: does not exist
21:35:17 <Tekmo> Luke: Ok, I'm studying `withSplices` to try to better understand how it works
21:36:02 <Luke> k
21:36:35 <Tekmo> I will have to go in about 5 minutes, but I'll do my best until then
21:39:00 <mm_freak> Tekmo: ok, i'll check it out and do a few experiments
21:39:25 <Luke> Tekmo: no problem. thanks a lot
21:39:35 <Luke> i'll definitely be back later w/ the same question =D
21:39:35 <Tekmo> Luke: You're welcome!
21:39:51 <blaenk> nevermind, looks like I needed to init the git submodules :)
21:40:39 <Tekmo> Luke: So what it looks like to me is that you need to read the dynamic values within the `RunTimeSplice` monad and then pass them to `withSplices` as `Text` parameters within the `Splices` map
21:40:52 <Tekmo> Luke: The part that I can't figure out is how to do anything within the `RunTimeSplic` monad
21:41:58 <Luke> Tekmo: that's exactly where I got stuck
21:41:59 <Tekmo> Luke: It seems to require the `MonadState HeterogeneousEnvironment` instance
21:42:09 <Tekmo> Luke: That seems to be the useful part
21:42:19 <Luke> I'm not familiar with that
21:42:33 <Tekmo> It doesn't show up in the instance list for some weird reason
21:42:42 <Tekmo> But if you look at the source code for `RunTimeSplice` you will see it:
21:43:17 <hkarim> What does ':=" mean here: data Named a = Name := a | Do a
21:43:17 <Tekmo> Under the hood it is a `StateT HeterogeneousEnvironment m a`, and there is a `deriving (MonadState HeterogeneousEnvironment)` clause
21:43:25 <Tekmo> I think that is what you need to use, somehow
21:43:31 <Luke> hmm
21:43:39 <Tekmo> hkarim: It's an infix constructor
21:43:40 <Luke> seems like there would be docs on this key piece =)
21:43:49 <Tekmo> hkarim: Haskell lets you define infix constructors if they begin with a colon
21:44:04 <hkarim> Tekmo: Thanks
21:44:11 <Tekmo> Luke: Yeah, I'm surprised that it doesn't even show up in the instance list
21:44:14 <Tekmo> hkarim: You're welcome!
21:44:27 <Tekmo> Alright, I have to head out.  It was a pleasure talking with all of you
21:44:40 <Luke> well if you can help convince doug that there's something missing in terms of usability learning - that'd be nice
21:44:42 <Luke> thanks again!
21:44:46 <Tekmo> You're welcome!
21:44:46 <Luke> have a good night!
21:44:49 <Tekmo> You, too
21:44:53 <Luke> ty
21:50:46 <nisstyre> :t either
21:50:47 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
22:12:51 * hackagebot tdd-util 0.3.0.0 - Test framework wrapper  http://hackage.haskell.org/package/tdd-util-0.3.0.0 (ByronJohnson)
22:12:51 * hackagebot tdd-util 0.3.0.1 - Test framework wrapper  http://hackage.haskell.org/package/tdd-util-0.3.0.1 (ByronJohnson)
22:32:02 <joelteon> what's writing tests
22:32:15 <DarkFox> joelteon: What?
22:32:23 <joelteon> nothing
22:32:34 <DarkFox> ?
22:49:41 <abg> Hey, so I can't find an obvious way to go from Unix epoch to UTCTime. Am I missing something?
22:49:53 <Clint> yes?
22:50:39 <abg> What am I missing? I figured that would be a simple conversion.
22:51:28 <Clint> what do you have your epoch time in?
22:51:51 <abg> Seconds since Jan 1, 1970 UTC
22:52:19 <Clint> that's not a type
22:52:36 <abg> Oh, you meant type. Integer.
22:55:28 <Clint> abg: posixSecondsToUTCTime . fromIntegral
22:56:46 <abg> Clint: Oh, damn. I've been looking in the wrong section. Thanks a lot!
23:12:07 <TallerGhostWalt> 00:56 *** phienone JOIN
23:12:17 <TallerGhostWalt> sorry lost my prompt!
23:12:24 <Fuuzetsu> Damn, I'm actually very impressed with the OpenGL bindings.
23:13:00 <TallerGhostWalt> canLenses be built over Sum Types?  Is there a best practice for that?
23:13:29 <TallerGhostWalt> I am working on updating an xlsx xml parsing package and adding a lens interface to it
23:13:50 <TallerGhostWalt> But wasn't sure the best way to handle something like
23:13:59 <TallerGhostWalt> data CellValue = CellText {unCellText :: Text} | CellDouble Double | CellLocalTime LocalTime
23:13:59 <TallerGhostWalt>                deriving Show
23:15:36 <TallerGhostWalt> I think I will try pattern matching over the types
23:15:47 <carter> Fuuzetsu: oh?
23:17:00 <Fuuzetsu> carter: Well, I kind of expected it to be like a lot of bindings to stuff on Hackage: barely compiling, undocumented, grossly incomplete and with tons of exposed hacks
23:18:04 <carter> hehe, nope
23:18:11 <carter> people ahve been working on them for YEARS
23:18:26 <carter> including lispy and acowley
23:18:38 <carter> like
23:19:00 <Fuuzetsu> Well, I'm sure I'll be swearing heavily pretty soon and blaming them for my failures
23:19:25 <carter> nah
23:19:27 <carter> they're good engineers
23:19:31 <carter> it'll be your fault :)
23:19:33 <carter> :P
23:19:39 <carter> or file a bug report! :)
23:19:39 <Fuuzetsu> Oh, of course it will be.
23:19:46 <Fuuzetsu> I don't doubt that.
23:23:54 <lispy> I gave a good effort on the opengl bindings, but I think Sven deserves all the real praise.
23:24:35 <carter> i was noticing that when i read the commit logs just now
23:24:43 <lispy> Fuuzetsu: I like to make sure things build on osx, linux, and windows. Otherwise, what's the point?
23:24:44 <carter> is sven ever on irc?
23:24:51 <lispy> I don't think so
23:40:19 <manjunaths> Hello
23:42:17 <DarkFox> Hello manjunaths
23:48:51 <manjunaths> Why is the class keyword needed ?
23:49:33 <manjunaths> Can't the data keyword cover all the cases which class covers ?
23:49:47 <Iceland_jack> Type classes are not data types
