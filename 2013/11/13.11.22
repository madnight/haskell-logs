00:00:47 <lesur> Hey guys, I've got a beginner question. While I was going through the 99 haskell problems, I noticed that to check if there is only one element in a list, you would use [a], for example, func [a] = a. I'm slightly confused about this, is [a] not a list of a's, not a single a? Also why would I have to do (x:xs) and not [x:xs]?
00:01:16 <johnw> [a] is a list that has just one a in it
00:01:26 <johnw> [x:xs] is a list containing a list
00:01:39 <bergmark> lesur: [a] can be a type "list of a's", in func [a] it's a pattern match "a list containing one element"
00:01:40 <johnw> I'm not sure whether parens is necessary there or not, though
00:01:56 <lesur> So [x:xs] is the same as [[x]:[xs]]?
00:02:14 <johnw> no
00:02:24 <lesur> Would that be [[[]]]?
00:02:32 <johnw> you can't replicate [x:xs] using just [] chars
00:02:38 <scott_> [1,2,3] is the same as 1 : (2 : (3 : []))
00:02:41 <ReinH> that would be a type error :)
00:02:42 <johnw> it means "a list containing a list with at least one element"
00:02:51 <scott_> When you pattern match x:xs on [1,2,3], x = 1 and xs = [2,3]
00:03:16 <lesur> so x:xs is x concat tail of list?
00:03:21 <scott_> yes
00:03:23 <johnw> yep
00:03:29 <johnw> we pronounce it "cons"
00:03:34 <lesur> cons?
00:03:36 <lesur> Thanks.
00:03:40 <johnw> x:xs is x cons'd onto xs
00:03:58 <smith_> lesur: And it works in pattern matching because it's just another data constructor
00:04:00 <ReinH> lesur: http://en.wikipedia.org/wiki/Cons
00:04:58 <lesur> Oh, and why does a type signature look like func :: [a] -> a. Why is that a list of a and not a single a?
00:06:00 <ReinH> lesur: that type signature means that func takes a list containing values of type a and provides a value of type a
00:06:24 <lesur> So are type signature definitions different from arguments?
00:06:31 <scott_> [a] in a type is a bit of special syntax in Haskell. If you defined a List type yourself you would have List a -> a
00:06:33 <scott_> It's the same thing
00:06:52 <ReinH> :t ['a']
00:06:53 <lambdabot> [Char]
00:07:32 <lesur> I guess what is confusing me is that in func :: [a] -> a, [a] is a list of a's, while in func [a] = a, [a] is a single element.
00:07:37 <johnw> [a] in a type is a type constructor; there it *does* contain a single a: a single a *type*
00:07:42 <johnw> not to be confused with a single a *value*
00:07:56 <lesur> So types and values are different?
00:07:59 <johnw> yes, very
00:08:05 <johnw> Int is a type, 10 is a value
00:08:17 <johnw> "Int" is inhabited by many more values than just 10
00:08:33 <johnw> likewise, [Int] can contain many more elements than just one
00:08:39 <lesur> I see, thats why you had the List a example.
00:09:48 <lesur> So type signatures have types (I should have guessed that :)) while functions have values.
00:10:37 <johnw> I think I can say yes to that :)
00:11:05 <lesur> Well, thank you guys, you've just made Haskell infinitely easier for me. :)
00:11:47 <johnw> confusing types with values is pretty common, I still do it sometimes
00:12:46 <bergmark> especially when the same names are used, my colleague had a presentation to non-haskellers where he used `id :: a -> a; id a = a` and people were hopelessly confused :(
00:12:52 <johnw> but one thing to bear in mind is that in Haskell, types only exist at compile-time, and values mostly exist at runtime (constants is one exception)
00:13:35 * hackagebot posix-paths 0.2.0.1 - POSIX filepath/directory functionality  http://hackage.haskell.org/package/posix-paths-0.2.0.1 (JohnLato)
00:13:38 <lesur> Uh, I'm going to have to look some of that up I'm not quite at that stage yet. :)
00:14:09 <ReinH> johnw: confusing [a] with [a] is particularly common
00:14:21 <lesur> I can see why.
00:22:57 <Ralith> this is all so much simpler with dependent types
00:23:36 * hackagebot range-space 0.1.1.1 - A Range type with vector-space instances  http://hackage.haskell.org/package/range-space-0.1.1.1 (JohnLato)
00:28:36 * hackagebot fay 0.18.1.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.1.1 (AdamBergmark)
00:38:55 <quchen> Ralith: Because you're always confused anyway when using them? ;-)
00:39:22 <bartavelle> if anyone used something like pontarius-xmpp, is there some helper library that will five me helper functions for writing XHTML that will be compatible with xmp-types ?
00:39:37 <lesur> Whats the type of a list that can go to any depth? [] is [a], [[]] is [[a]], but what if I want a list with an undefined number of sublists?
00:39:37 <Ralith> quchen: sincerely, there only being one language (rather than a separate one for types) simplifies things beautifully
00:40:16 <scott_> lesur: You can construct a list like that in Haskell (it will complain about an infinite type)
00:40:19 <scott_> can't*
00:40:29 <quchen> scott_: Yes you can!
00:40:35 <lesur> ?
00:40:40 <scott_> Not with [] though
00:40:40 <quchen> It's some Free thing.
00:40:43 <scott_> Hmm?
00:40:54 <mr-> > let x = [x] in x
00:40:55 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
00:41:18 <quchen> scott_: Free is pretty much arbitrarily nesting a Functor
00:41:22 <Ralith> mr-: that's not an undefined number, that's an infinite number
00:41:34 <quchen> So "Free [] a" is something in the "arbitrarily nested list"
00:41:38 <quchen> … direction
00:42:19 <quchen> It essentially expands to `FreeList a = Pure a | Roll [FreeList a]`
00:42:21 <mr-> Ralith: "any" includes infinite
00:42:39 <Ralith> mr-: but infinite does not subsume "any"
00:43:04 <scott_> quchen: Which is basically a tree, right?
00:43:06 <mr-> Ralith: but showing it does not work for infinite, shows it does not work for any
00:43:25 <quchen> scott_: Right
00:43:28 <Ralith> mr-: it is fortunate, then, that that is not what he said regardless :P
00:43:29 <ReinH> also, Cofree [] a is (isomorphic to) a rose tree of a
00:44:38 <mr-> Anyway, the correct answer was quchen's Free [] a :-)
00:45:07 <lesur> Free [] a, thanks. I may have to do some reading to understand what that means though. :)
00:45:31 <quchen> lesur: You can actually ignore the "Free" part and write your specialized version yourself.
00:45:43 <lesur> As a data type you mean?
00:45:53 <quchen> data AbitraryList a = Value a | Nested [ArbitraryList a]
00:46:08 <quchen> That's the same as "Free [] a" but probably easier to read and understand.
00:46:22 <startling> then you can try and write Free yourself. :)
00:46:43 <horsepower123> hai.. so how do you make "research" within a programming language? How is my donated money being used?
00:46:47 <lesur> Hmm, interesting, I'll give that a go, thanks.
00:46:48 <quchen> startling: Well, Free is mostly about its Monad instance, which may be a little beyond scope here
00:47:09 <arkeet> "mostly"
00:47:15 <quchen> horsepower123: When you donate money to science you pay smart people to think about what they like to think about.
00:47:15 <lambdabot> That's Numberwang!
00:47:24 <startling> I think it's useful to see that you can write it yourself.
00:47:30 <oio_> any idead how to hide a .exe cmd on windows xp?
00:47:37 <quchen> Delete it.
00:47:52 <arkeet> oio_: did you see my answer to what I thought was your question earlier?
00:47:58 <arkeet> or are you asking something different?
00:47:59 <horsepower123> so.... "research".. what's actual research within programming?
00:48:23 <lesur> Theoretical computer science?
00:48:26 <quchen> horsepower123: You mean programming languages?
00:48:40 <lesur> http://www.cs.cmu.edu/~mleone/language-research.html
00:48:46 <horsepower123> I read a lot that "haskell is being researched"
00:48:52 <oio_> arkeet: worked but doing dome run command with mailsend
00:49:05 <quchen> horsepower123: So is every other evolving programming language
00:49:09 <arkeet> oio_: ok, what is your question?
00:49:21 <oio_> arkeet: hide mailsend.exe
00:49:42 <arkeet> is this related to haskell?
00:49:42 <oio_> arkeet: within haskell runcommand
00:50:07 <arkeet> what's runcommand?
00:50:55 <oio_> arkeet: like putting a command on shell bash
00:51:11 <mirpa> horsepower123: Search for Philip Wadler, Simon Peyton Jones in case of Haskell
00:51:15 <oio_> arkeet: runcommand "ls -a"
00:51:16 <arkeet> oio_: I'm not asking what it's like.
00:51:21 <arkeet> I'm asking what it is.
00:51:27 <arkeet> where is it from:?
00:51:56 <arkeet> hm, you mean runCommand from System.Process?
00:52:01 <oio_> arkeet: yeas
00:52:14 <arkeet> don't use that.
00:52:47 <arkeet> try runProcess or similar.
00:52:53 <arkeet> to avoid going through cmd.
00:54:08 <oio_> arkeet: mm
01:12:59 <danbst> [Q] how to intersperse effectively large ByteString with byte? I have ByteString bitmap data "rgbrgbrgbrgbrgbrgb" and want to do "rgbArgbArgbArgbArgbA"
01:14:19 <quchen> danbst: ByteString has intercalate/intersperse functions: http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#v:intersperse
01:14:56 <arkeet> presumably he wants to split things up too.
01:16:09 <danbst> quchen: intercalate would be great, but we have to split BS first
01:16:53 <arkeet> you could do that with repeated uses of splitAt.
01:18:45 <arkeet> I guess I would try not to worry about performance of that unless you find (e.g. by profiling) that it's a bottleneck.
01:19:01 <danbst> arkeet: intercalate uses another BS as argument, but I do need only a Word. Can we optimize that somewhat?
01:19:19 <danbst> arkeet: sure
01:19:19 <arkeet> make a bytestring from the word.
01:19:46 <danbst> isn't it an overhead?
01:20:00 <arkeet> nope.
01:20:12 <arkeet> actually there's a rewrite rule that makes intercalate (singleton c) more efficient.
01:20:40 <arkeet> well
01:20:59 <arkeet> yeah.
01:21:04 <arkeet> except you still want an A at the end.
01:21:55 <danbst> cool
01:22:44 <danbst> not that easy to think about your code in the presence of magic rewrite rules...
01:33:15 <chare_> question for you haskell experts: is making a chess endgame tablebase generator in haskell efficient possible?
01:34:24 <mirpa> chare_: what is chess endgame tablebase generator?
01:34:34 <chare_> omg you don't know what chess is...
01:35:00 <johnw> chare_: I don't see why it wouldn't be possible
01:35:09 <johnw> Haskell should make parallelizing such a computation pretty easy too
01:35:51 <chare_> johnw: but is it going to take a major hit in performance, these tablebase generators can take days to finish so any inefficiency magnifies the time to finish
01:36:09 <johnw> I don't see why the inefficiency would have anything to do with Haskell per se
01:36:11 <Hermit> chare_: worry about the algorithm then
01:36:51 <chare_> so you guys are saying haskell will compete with C on this hands down
01:37:03 <johnw> it's usually within 2-4x of C, but sometimes it's faster too
01:37:27 <chare_> But 2-4x means going from taking 1 day to potentially 2 or 4 days
01:37:28 <johnw> if the algorithm is amenable to parallelization, then probably the Haskell code will definitely win and be much easier to get correct
01:37:43 <startling> it will also be nicer to write. :)
01:37:44 <Hermit> chare_: it all boils down to how good your algorithm is and how well you've implemented it. You can also implement crap slow code in C for all I know
01:37:51 <chare_> johnw: mmm i'll think about that you probably right
01:39:50 <chare_> ok so I have no idea how to actually make a chess endgame tablebase generator
01:39:53 <chare_> you experts are going to help right?
01:40:11 <chare_> you guys going to help with project endgame tablebase in haskell?
01:40:42 <johnw> we can help with problems you face in learning Haskell to get job done
01:40:54 <johnw> why not just download pre-generated endgame tables?
01:40:55 <chare_> johnw why don't you want to help?
01:40:57 <johnw> there are many on the Net
01:41:05 <johnw> chare_: uh, because I have better things to do?
01:41:16 <Hermit> chare_: would you help me clean my fucking house?
01:41:18 <chare_> johnw you saying you hate chess?
01:41:27 <Hermit> johnw: this smells like a troll
01:41:29 <chare_> Hermit: you're suppose to get your gf to do that
01:41:41 <Hermit> chare_: yeah, but I'm a hermit
01:41:58 <startling> I hate chess.
01:42:07 <Hermit> I love StarCraft
01:42:22 <chare_> wtf you got the world championship between carlsen and anand going on right now
01:42:23 <chare_> and you hate chess?
01:42:24 <startling> chare_, kindy avoid spewing misogyny into this channel.
01:44:45 <chare_> so what project are we going to work on then
01:44:54 <augur_> what a weird bug
01:45:32 <augur_> i have a GADT that uses phantom types, and if i have both an Eq and Show deriving instance, i get a weird type mismatch in the Eq instance
01:45:48 <augur_> but if i just have the Eq, i get a comment about the lack of the Show
01:45:58 <augur_> maybe this is the instance checking pre-empting type checking?
01:47:22 <quicksilver> well the comment about lack of show might just be because you're trying to show it in an error message
01:47:30 <quicksilver> but without seeing the code or the error, we're only going to guess
01:51:47 <Rc43> How to install package of certain version viia cabal?
01:51:54 <Rc43> I try `cabal install hashable-1.1`.
01:52:11 <Fuuzetsu> That should work I think.
01:52:18 <Rc43> But it says that "Dependency tree exhaustively searched." and that's all.
01:52:27 <Fuuzetsu> Is there hashable-1.1?
01:52:45 <Rc43> There is 1.1.0.0.
01:52:54 <arkeet> @hackage hashable
01:52:54 <lambdabot> http://hackage.haskell.org/package/hashable
01:53:02 <Fuuzetsu> Then do cabal install hashable-1.1.0.0
01:53:14 <arkeet> yes, the .0 matters.
01:53:20 <Rc43> If I specify 1.1.0.0 it goes further but fails on dependencies for base
01:53:36 <arkeet> why do you need 1.1.0.0?
01:53:51 <Fuuzetsu> Rc43: Well, then your dependencies aren't in a state where you can install 1.1.0.0
01:53:54 <Rc43> UHC requires that =/
01:53:54 <arkeet> as opposed to, say, 1.1.2.5
01:53:58 <Fuuzetsu> I'm not sure what you expect
01:53:58 <arkeet> =/
01:54:21 <arkeet> 1.1.0.0 depends on ghc.
01:54:53 <Rc43> Maybe I will succeed with cabal-dev with local installation of necessary versions...
01:54:57 <arkeet> so I don't see how uhc can require it.
01:55:36 <arkeet> I suppose you mean you're trying to compile uhc.
01:56:42 <Rc43> arkeet, I tried to install UHC via system package manager, it tried to compile uhc (call to installation via cabal) and then it failed with message about hashable-1.1.
01:57:00 <mr-> Rc43: you can not reinstall base, I think
01:57:20 <mr-> Rc43: so using any sort of sandbox won't help
01:57:28 <arkeet> Rc43: you sure you can't use hashable-1.1.2.5?
01:57:37 <arkeet> (which is incidentally the version that comes with the platform)
01:59:00 <Rc43> arkeet, I will try, perhaps thats will really help
01:59:14 <Rc43> arkeet, didn't notice that there are two 1.1 versions
01:59:26 <arkeet> you should look on hackage to see what versions are there.
02:01:31 <arkeet> alternatively use constraints:
02:01:32 <arkeet> e.g.
02:01:34 <Rc43> arkeet, somehow 1.1.2.5 didn't help, but message clearly says "1.1.*" version
02:01:38 <arkeet> cabal install hashable --constraint "hashable == 1.1.*"
02:01:42 <arkeet> what message?
02:01:54 <Rc43> arkeet, message about failed compilation of UHC
02:01:59 <arkeet> yes, what message?
02:02:06 <arkeet> show the build log.
02:02:30 <Rc43> arkeet, I will make screenshot (cannot copy-paste)
02:04:21 * arkeet wonders why you can't copy-paste but oh well. also there are things like sprunge.us
02:07:05 <Rc43> arkeet, rghost.ru/50347333/image.png
02:07:06 <TheBrayn> anyone here using emacs for haskell? I would like to have a completion for standard and library functions which honors imports, how can I do that?
02:07:43 <arkeet> Rc43: oh, well, probably because it's not looking in your user package db
02:07:59 <Rc43> arkeet
02:08:03 <Rc43> arkeet, aahh
02:08:09 <Rc43> arkeet, seems that I understood why
02:08:10 <arkeet> can you install hashable through portage?
02:08:16 <arkeet> an appropriate version.
02:08:36 <Rc43> arkeet, I thought it should do it automatically (for other packages does)
02:08:44 <arkeet> it should.
02:08:45 <Rc43> arkeet, I will try to do it manually
02:22:38 <structuralist> is it possible to download a release candidate for Haskell Platform 2013.4.0.0?
02:26:09 <augur_> whats the haskell library for parenthesization magic?
02:26:43 <Fuuzetsu> @faq can Haskell make augur_'s question clearer?
02:26:43 <lambdabot> The answer is: Yes! Haskell can do that.
02:26:51 <augur_> Fuuzetsu: :P
02:27:11 <augur_> the library that lets you do proper parens insertion for Show
02:27:23 <Fuuzetsu> pretty?
02:27:37 <augur_> maybe thats it
02:28:16 <BoR0> why does haskell whine about this recursive definition \g -> (\x -> g (x x)) (\x -> g (x x)), but it doesn't whine about fix f Y-combinator recursion?
02:28:34 <augur_> BoR0: fix f Y-combinator recursion?
02:28:45 <augur_> BoR0: anyway, the reason is the type of x
02:28:45 <BoR0> I meant fix f = f (fix f)
02:28:52 <augur_> to apply x to itself, what's its type?
02:29:11 <augur_> well suppose x :: a -> a for some choice of a
02:29:29 <augur_> to apply x to something, the something has to have type a
02:29:33 <augur_> so to apply to x, x :: a
02:29:34 <startling> :t \g -> (\x -> g (x x)) (\x -> g (x x))
02:29:35 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
02:29:35 <lambdabot>     Expected type: t1 -> t0
02:29:35 <lambdabot>       Actual type: (t1 -> t0) -> t0
02:29:39 <augur_> but that means a == a -> a
02:30:04 <augur_> well technically x can be :: a -> b, i suppose
02:30:10 <startling> :t \x -> x x
02:30:11 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
02:30:11 <lambdabot>     In the first argument of `x', namely `x'
02:30:11 <lambdabot>     In the expression: x x
02:30:14 <augur_> so you need to solve a == a -> b
02:30:31 <Fuuzetsu> a :: undefined
02:31:03 <augur_> does that make sense, BoR0?
02:31:03 <BoR0> ok, but how does fix f = f (fix f) work?
02:31:06 <gniourf> Is there a function f :: Int -> [a] -> [a] that will take every n elements of a list? e.g., f 3 [1,2,3,4,5,6,7,8] = [1,4,7] ?
02:31:06 <lambdabot> That's Numberwang!
02:31:15 <augur_> BoR0: because the type isnt a problem!
02:31:16 <haasn> I... what
02:31:20 <augur_> BoR0: fix :: (a -> a) -> a
02:31:20 <Fuuzetsu> @src fix
02:31:20 <lambdabot> fix f = let x = f x in x
02:31:41 <startling> :t let f x = x x in f
02:31:42 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
02:31:42 <lambdabot>     In the first argument of `x', namely `x'
02:31:42 <lambdabot>     In the expression: x x
02:31:49 <augur_> BoR0: so for f :: a -> a, fix f :: a. so its ok to apply f to fix f
02:31:51 <startling> haasn, she's been doing it all day. I don't get it either.
02:32:17 <Fuuzetsu> apparently it reacts to numbers
02:32:30 <startling> BoR0, I think something is being inferred as more restrictive than it needs to be.
02:32:44 <BoR0> augur_, your explanation is clear. thank you! so, basically, using lambda calculus' recursion definition, it is only useful in the untyped world
02:32:49 <startling> :t const const
02:32:50 <lambdabot> b -> a -> b1 -> a
02:33:03 <haasn> “Numberwang” is a pop culture reference. I'm more confused over the fact that lambdabot started announcing it
02:33:12 <augur_> BoR0: right. for a typed LC you need something else
02:33:25 <haasn> I dearly hope it's based on http://hackage.haskell.org/package/acme-colosson-0.1/docs/Acme-Colosson.html though
02:33:36 <augur_> BoR0: the type-theoretic approach to this is usually to actually define primitive recursors for each relevant type
02:33:37 <BoR0> so that is where combinators come into play? augur_, I am spending some time on theory more
02:33:41 <kthl> augur_: like typed lambda calculus? or something else? (newby here)
02:33:45 <Fuuzetsu> is it just const True
02:33:46 <Rc43> There is package uhc-utilities on hackage. Have it UHC itself?
02:33:52 <augur_> kthl: right, like the (simply) typed LC
02:33:58 <haasn> Fuuzetsu: look at the source :)
02:33:59 <Fuuzetsu> >numberwang = unsafePerformIO colosson
02:34:00 <kthl> k thx
02:34:00 <Fuuzetsu> terrible
02:34:01 <augur_> BoR0: which combinators?
02:34:51 <BoR0> maybe I need to get my terms together and define them well. I was thinking about fixed point combinator (fix f = f (fix f)), or is it the same with the lambda calculus definition?
02:35:11 <startling> oh, I see. it's a rank-2 type
02:35:13 <startling> :t (\x -> x x) :: ((forall b. b -> a -> a) -> a -> a)
02:35:14 <lambdabot> (forall b. b -> a -> a) -> a -> a
02:35:21 <augur_> BoR0: well, at the level of the type theory, there's built-in recursion. haskell doesnt use fix to define its recursive functions.
02:35:30 <augur_> BoR0: fix is just yet another function you can define in haskell
02:35:37 <startling> it's being inferred as an infinite type.
02:35:39 <haasn> > [1..8]^..folded.indices (\i -> i `rem` 3 == 0) -- gniourf
02:35:41 <lambdabot>   Couldn't match expected type `(a0
02:35:41 <lambdabot>                                 -> Contro...
02:35:54 <haasn> works here :(
02:36:03 <haasn> :t indices
02:36:04 <lambdabot> Ix i => Array i e -> [i]
02:36:08 <startling> :t let fix f = f (fix f) in fix
02:36:10 <haasn> > [1..8]^..folded.Control.Lens.indices (\i -> i `rem` 3 == 0) -- gniourf
02:36:10 <lambdabot> (t -> t) -> t
02:36:11 <lambdabot>   Not in scope: `Control.Lens.indices'
02:36:12 <lambdabot>  Perhaps you meant one of these:
02:36:12 <lambdabot>    `C...
02:36:18 <BoR0> ok augur_ , I see. basically I want to understand how and why SKI theoretical programming language compare to lambda calculus
02:36:33 <augur_> BoR0: oh, thats a separate issue entirely
02:36:44 <haasn> > [1..8]^..folded.Control.Lens.Indexed.indices (\i -> i `rem` 3 == 0)
02:36:46 <lambdabot>   Not in scope: `Control.Lens.Indexed.indices'
02:36:49 <gniourf> haasn, thanks, I'm already using some home-cooked stuff, but was hoping an already existing function existed. :(
02:36:52 <BoR0> I was thinking they are differ in their recursion definitions
02:36:53 <haasn> > [1..8]^..folded.Lens.indices (\i -> i `rem` 3 == 0)
02:36:54 <augur_> BoR0: SKI and LC are usually looked at in untyped settings where recursion can be achieved with Y
02:36:54 <lambdabot>   Couldn't match type `Control.Lens.Internal.Indexed.Indexed
02:36:54 <lambdabot>                 ...
02:37:04 <startling> BoR0, it's purely a bad inference thing.
02:37:07 <augur_> BoR0: you'd have some version of Y but in SKI.
02:37:14 <BoR0> so Y in SKI and Y in LC is the same thing?
02:37:16 <Fuuzetsu> haasn: stop hating spaces around operators
02:37:19 <augur_> BoR0: not quite
02:37:45 <augur_> BoR0: SKI is a different thing, right, so they cant be _the same_, but there are conversions from SKI to LC and back, so
02:38:14 <Fuuzetsu> would you say they are ~~~isomorphic~~~?
02:38:29 <augur_> Fuuzetsu: i would say the term languages are isomorphic, sure
02:38:43 <augur_> or at least i think so
02:39:00 <haasn> oh! this definition of ‘folded’ is weirdly monomorphic
02:39:22 <haasn> > [1..8] ^.. indexing folded . Lens.indices (\i -> i `rem` 3 == 0)
02:39:24 <lambdabot>   [1,4,7]
02:39:33 <Fuuzetsu> :t (^..)
02:39:34 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
02:39:48 <BoR0> augur_, okay, but in terms of expressive power, are they equivalent?
02:40:04 <startling> the typed lambda calculus is less expressive than the untyped.
02:40:06 <augur_> BoR0: since there's a translation in both directions, yes, of course
02:40:13 <augur_> any program you write in one, you can translate into the other
02:40:20 <BoR0> ah, right. that's a natural consequence. ok great!
02:42:43 <gniourf> :)
02:43:05 <augur_> BoR0: how recursion is achieved in typed systems, and in practical languages, is an interesting question
02:43:24 <Tordek> what's the... "consensus", so to speak, on unsafePerformIO? I mean, for 'safe' stuff; clearly, running a program to format your HDD through upio'd be bad, but what if I want to use, say, grep (because reasons) and I define a "totallyIsntGrep :: String -> String -> String" function?
02:43:42 <augur_> but is distinct from the untyped systems
02:43:58 <augur_> i mean, you could do similar things in untyped systems
02:44:03 <augur_> theres sort of two dimensions at work
02:47:57 <BoR0> is there any practical usage of untyped systems?
02:48:17 <startling> BoR0, you might want to ask #python and ##ruby and ##javascript that.
02:48:20 <augur_> thats yet another question :)
02:48:39 <startling> Tordek, you should avoid it.
02:49:08 <augur_> BoR0: SPJ has a bunch of talks about the "point" of haskell, and this discussion of how there are two forces at work: the ability to write programs that you know work without any hassle, and the ability to say what your programs so
02:49:32 <augur_> BoR0: untyped systems have little hassle, at least as far as the compiler is concerned
02:49:49 <augur_> but they suck at knowing what they're supposed to do, so you have to make more complex programs to make sure you're making sense
02:50:01 <augur_> typed systems know more about what they do, but the compiler complains more often
02:51:28 * yogurt_truck doesn't get the "little hassle" argument
02:51:44 <BoR0> and I assume the check of correctness is also easier in the typed world
02:51:47 <augur_> yogurt_truck: well, no types means no type errors :)
02:51:52 <pharaun> ^
02:52:13 <augur_> BoR0: the fancier your types, the easier it is to express the notion of correctness in them
02:52:14 <pharaun> but i generally *prefer* type errors to... the other alternative
02:52:18 <yogurt_truck> augur_: no types errors != no runtime errors
02:52:30 <pharaun> different thing :)
02:52:33 <augur_> yogurt_truck: i never said it did, thats why i said you dont get hassle from the _compiler_
02:52:45 <pharaun> haskell can have runtime error (error/fail)
02:53:03 <yogurt_truck> it's "little hassle" maybe for bashing a keyboard with your hands and deploying it to production. like, literally the _physical_ process of _writing_
02:53:05 <mr-> Seperate compile-time and run-time. Only the former is of concern to a good programmer.
02:53:22 <mr-> Hence, no types means less hassle
02:53:25 <yogurt_truck> but I don't see how _that_ "lack of hassle" is valuable at all against correctness, etc.
02:53:39 <pharaun> yogurt_truck: fwiw i think its more painful to deploy most scripting/dynamic languages to prod
02:53:47 <augur_> yogurt_truck: well i dont either, of course
02:53:48 <pharaun> because the whole thing with deploying their libraries, and so on
02:53:48 * hackagebot conduit 1.0.9.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.9.2 (MichaelSnoyman)
02:54:11 <BoR0> mr-, but is it a short term less hassle? program may execute without errors but may crash later which then needs to be investigated
02:54:22 <augur_> yogurt_truck: tho SPJ makes a good point about how often times the types just get in your way because the type system is too restrictive, or too limited
02:54:32 * yogurt_truck got into typing way to late. afters years of his life wasted maintaining awful "dynamic" language projects
02:54:43 <bearclaw> yogurt_truck: little hassle means it's easier and faster to make a program that starts and somehow appear to work, and still a company is mostly not liable for bugs in its products...
02:54:49 <pharaun> yogurt_truck: i'm stuck with a 1.1mloc python app
02:54:49 <lambdabot> That's Numberwang!
02:54:59 <mr-> BoR0: Nothing of what I say should be taken seriously. Sorry, I should have mentioned that.
02:55:12 <alexander__b> yogurt_truck: 10K+ LOC files of "dynamically" assigning random crap to other crap are fun, aren't they. :-D
02:55:14 <yogurt_truck> pharaun: :(
02:55:28 <pharaun> yogurt_truck: i know :) at least i get to use haskell for hobby project and enjoy the bliss
02:55:56 <lasticot> Hi, does anyone have any tutorial I should look at to understand how to manage random on a project?
02:56:03 <alexander__b> pharaun: does yours on several occasions go above the 15th indentation level too? :-D
02:56:38 <pharaun> alexander__b: in the legacy part of the codebase oh yes, but at least the folks i work with *try* to keep it at a reasonable level and try to write good code
02:57:06 <alexander__b> pharaun: oh, I deal with "close enough" commits very often, in addition to a long legacy of "close enough" commits.
02:57:17 <pharaun> it just can be hard to be happy with the quality of the code because i feel like i can't write enough tests and lots of silly error slips through because of lack of compile time type checks
02:57:18 <alexander__b> pharaun: I don't have >1 million LOCs though, hurr.
02:57:20 <augur_> as it happens, i just wrote an untyped LC variant called DRS
02:57:38 <augur_> im probably _not_ going to write a type checker over it, tho i probably should >_>
02:57:39 <pharaun> alexander__b: indeed, those do happen, but i suspect it happens in nearly all languages :)
02:58:23 <alexander__b> pharaun: right. so best disallow as many things as possible. ;-)
02:58:29 <pharaun> at least the org has alright to decently strong testing culture but still
02:58:48 <pharaun> some time i feel like it would be *more* helpful to have something like haskell types ;p but i'm obiv biased
02:59:00 <pharaun> ok (almost always) but... :)
02:59:15 <alexander__b> pharaun: anything that's not a prototype/small program, I want strong static typing
02:59:29 <pharaun> the older i get and the longer i program, the more i agree
02:59:48 <alexander__b> I work a lot on games. the circleIntersection function doesn't need dynamic types. it takes two Circles and returns a Maybe CollisionNormal.
02:59:49 <pharaun> i want more linters, more strong types, so on...
03:00:04 <yogurt_truck> alexander__b: I used to be like that too. But now not even that. I prototype and refactor and radically change those prototypes much faster with types.
03:00:18 <pharaun> alexander__b: my personal bitter enemy is 1) id 2) datetime
03:00:33 <pharaun> def foo(self, id, timestamp): ...
03:00:38 <alexander__b> haha
03:00:57 <pharaun> ive ran into cases where i got feed 4 different id types, and 3 or 4 different types of timestamp/format
03:01:10 <alexander__b> yogurt_truck: oh yes I go nuts not using Haskell now, and I don't even know haskell yet!
03:01:22 <fizbin> I have a problem, and I know how I'd solve it in something that weren't haskell, but I don't know how to solve it in haskell.
03:01:27 <alexander__b> pharaun: what about (self, *args, *kwargs) :-P
03:01:33 <pharaun> well there's no better time than now to learn haskell alexander__b :D
03:01:39 <pharaun> alexander__b: far too many of that, far far
03:01:44 <BoR0> fizbin, that's a great start :)
03:02:06 <pharaun> fizbin: what's your problem?
03:03:01 <fizbin> I have a data structure in haskell that represents... let's say for now that it represents an intermediate language in a compiler. Something the back end reads that the front end produces.
03:03:16 <w0rm_x> is hat dead?
03:03:35 <tdammers> fizbin: something like an AST?
03:04:04 <augur_> blegh. natural language semantics is a pain in the ass :(
03:04:17 <fizbin> Now, I need to annotate this data structure (deeply) with information about where in the original user input it came from so that decent error messages can be produced.
03:04:19 <augur_> actually its the pragmatics thats the pain, really
03:04:35 <augur_> i think i'd be happier with dependent types
03:04:45 <startling> fizbin: what does your AST look like?
03:04:57 <jbracker> I am using cabal-dev with a test-suite and I am trying to run haskell programm coverage on it. I added the options: -fhpc -hpcdir dist/hpc/tix/myproject and the reports are created but they contain no actual information
03:05:06 <augur_> i should sleep. night BoR0
03:05:19 <BoR0> thanks for the help augur_! good night
03:05:33 <jbracker> I also tried calling the test executable manually but it always complains it cant find a module though I correctly specify the srcdir
03:05:34 <fizbin> In something like java I'd separate this from my nice intermediate language by having an IdentityHashMap that mapped objects in the representation to user input.
03:06:18 <startling> fizbin, a pretty typical way is to add a parameter to every constructor.
03:06:38 <startling> this can sometimes be done more nicely by doing recursion explicitly with something like Free.
03:06:48 <startling> fizbin, you could do it that way, too, though.
03:07:12 <fizbin> But in Haskell, it looks like I'm going to need to redo the whole set of intermediate language data structures, top to bottom, with an addition of information about where it came from.
03:07:37 <startling> fizbin, well, why do you think your hashmap idea doesn't work?
03:08:10 <startling> http://www.reddit.com/r/haskell/comments/1kzwlg/ideas_for_annotating_an_ast_with_custom_data/ <- a relevant thread from /r/haskell
03:08:19 <fizbin> Also, think less AST and closer to something like what the various gcc frontends spit out.
03:08:35 <startling> OK.
03:08:53 <fizbin> startling: I think it doesn't work because my data structure is full of lots of different types.
03:09:10 <startling> Hm?
03:09:22 <startling> Pasting code might help.
03:09:35 <fizbin> I suppose though I could simply add a "unique lookup key" int to each type, and then use that as a key in the companion map...
03:10:16 <startling> that's doable. you could even write a wrapper around State to automate this.
03:11:25 <startling> I'd be interesting in hearing what approach you decide on. It's a hard problem and not one I know the answer to.
03:11:36 <fizbin> startling: Hrm. A wrapper around State. That might work...
03:12:25 <startling> I mean newId :: MyThing Int Int or something.
03:18:09 <fizbin> Wow, that reddit thread is gold. Thanks.
03:19:06 <fizbin> It points at http://martijn.van.steenbergen.nl/journal/2010/06/24/generically-adding-position-information-to-a-datatype/ which solves something so close to exactly what I want it's scary.
03:20:57 <startling> :)
03:57:58 <marko2> Hey guys. I have a bytestring that is a mapped file (bytestring-mmap => unsafeMMapFIle), but I have space leaks. Does anyone know of a way of tricking GHC into garbage collecting something?
03:59:42 <marko2> This very short example leaks memory: http://lpaste.net/96006
04:01:02 <marko2> When I consume the bytestring in a streaming fashion, there is no leak. However, I need to have random access
04:06:29 <Philonous_> marko2, No, that's impossible. As long as you keep a reference to the entire bytestring the GC can't go ahead and pull chunks away under your feet.
04:08:16 <marko2> Philonous_: thanks, that is too bad. What is bytestring-mmap good for, then? The cool thing about mmap is that I can pretend that the file is in memory, and the OS takes care of loading the pages as I access them...
04:09:14 <marko2> Philonous_: Would you happen to know of another good way of efficiently getting out sub-bytestrings from a file?
04:09:27 <Philonous_> marko2, I don't know, I haven't written it. Seems to me the idea is to make sparse access more efficient.
04:09:49 <marko2> that might be true..
04:11:17 <marko2> Philonous_: is there some way of unsafely copying the bytestring in constant space such that GHC thinks it is another string, hence releasing it right away?
04:12:33 <Philonous_> marko2, What would happen if you access the "copy"?
04:13:13 <marko2> It would access the mmaped file, and when I am done with this portion, GHC would garbage collect the "copy" and I would be processing in constant space
04:13:40 <arkeet> marko2: bytestring has a copy function, is that what you're looking for?
04:14:01 <marko2> arkeet: I do not want an actual copy (which needs O(n) space and time)
04:14:04 <marko2> In the paste, like this: print $ F.foldl' (+) 0 $ map fromIntegral $ BS.unpack $ BS.take len $ BS.drop offset $ createFakeCopy s
04:14:12 <marko2> note the createFakeCopy at the end
04:15:40 <Philonous_> marko2, Sounds to me like you want weak refs
04:15:49 <marko2> If you know of other ways of achieving what I need (repeatedly getting bytestrings out of a file at random locations), I am all ears :)
04:15:56 <Philonous_> marko2, It would probably make a lot of sense of the mmap library was built on those
04:16:12 <Philonous_> So you can keep a handle on the entire file and chunks can still be GCed when you are done with them
04:16:25 <arkeet> marko2: are those lazy or strict bytestrings?
04:16:33 <Feuerbach> marko2: well, seek & read is one option
04:16:35 <marko2> strict
04:16:56 <Feuerbach> marko2: but I'm not sure the mmap approach is necessarily bad
04:17:10 <Feuerbach> although I don't immediately see the source of your problem
04:17:43 <marko2> Feuerbach: how can I seek and read in a file? bytestring provides readFile, which reads the whole file.
04:17:54 <Feuerbach> could you ask on stackoverflow? then either someone comes up with an answer, or I'll investigate myself when I have time (during the next few days, probably)
04:17:58 <hpc> marko2: you open the file and use Handle operations
04:18:03 <Feuerbach> I mean, ask about your mmap issue
04:18:42 <Feuerbach> marko2: Data.ByteString.hGet
04:18:44 <marko2> Feuerbach: the source seems to be that when I access a substring (BS.take .. BS.drop .. stream), the GC never collects it because I keep using `stream`, even though I am done with the substring
04:19:14 <Feuerbach> and System.IO.hSeek
04:19:45 <merijn> Philonous_, marko2: That is exactly what happens, but the OS swapping out pages of the file doesn't reduce your virtual memory consumption
04:20:14 <merijn> Philonous_, marko2: i.e. even if 90% of the file is swapped out, you'll still consume the file's total memory in virtual address space
04:20:14 <codh> I got a out of memory while doing a repa tutorial,
04:20:22 <codh> anybody knows something?
04:20:25 <marko2> merijn: I don't care about the virtual memory, just about actual memory used in the application. I keeps increasing and I run out (even though the virtual memory stays constant)
04:20:33 <codh> Loading package repa-3.2.2.201204.1 ... linking ... done. <interactive>: out of memory (requested 2097152 bytes)
04:20:33 <arkeet> codh: ask a more specific question, possibly with code
04:20:43 <arkeet> what are you doing exactly?
04:20:58 <merijn> marko2: hmm, sounds like the bytestaing-mmap library is a bit pointless, then?
04:21:23 <codh> http://lpaste.net/96008
04:21:39 <marko2> Feuerbach: I will try with this. One advantage of mmap is that that it nicely caches the pages that I access, so a second run is *much* faster. Not sure if this will be the case with the other approach
04:21:44 <merijn> marko2: You could use mmap directly like in C and access the bits you want using the FFI to do pointer operations
04:21:57 <arkeet> codh: well yes, you're asking it to make an infinite array.
04:22:02 <codh> after load the file in ghci, then just type x to show it, you'll get an out of memory
04:22:06 <arkeet> I think?
04:22:31 <codh> but the array is 3 by 3 from the type.
04:22:31 <lambdabot> That's Numberwang!
04:22:37 <arkeet> codh: yes, but it looks at the entire list.
04:22:42 <marko2> merjin: You mean using mmap without bytestring-mmap, i.e. a direct foreign call? Is this easy to do or do I need to write C-wrapper?
04:22:44 <merijn> marko2: If you're comfortable with mmap in C, the haskell FFI should pose little difficulty. Of course, you have to properly track when you free stuff, etc. like in C. But at least that way you know your library isn't breaking things
04:22:45 <mr-> codh: does it work if you replace  [1..] with  [1..100] ?
04:23:03 <codh> yes, you are right, I use [1..9] and it works. Thanks  !
04:23:05 <arkeet> it is an error to give it a list of a different length than it needs.
04:23:14 <arkeet> unfortunately... http://hackage.haskell.org/package/repa-3.2.3.3/docs/src/Data-Array-Repa-Eval-Target.html#fromList
04:23:22 <marko2> merijn: Is this easy to do or do I need to write C-wrapper?
04:23:24 <merijn> marko2: You can directly wrap and call C functions from haskell without C wrappers and there's a bunch of predefined functions for reading/writing to pointers (all IO, obviously)
04:23:28 <arkeet> it still needs to traverse the entire list before deciding it's too long.
04:23:33 <arkeet> (someone write a patch!)
04:23:39 <marko2> merijn: thanks! sounds good actually
04:23:45 <merijn> marko2: But even linking in C wrappers is fairly easy
04:24:14 <marko2> merijn: I also thought the point of bytestring-mmap was that I can use it like in C, but Philounous_ remarked that it helps with sparse access, so there is that
04:24:15 <merijn> marko2: As long as you don't use custom structs, the FFI is really simple
04:24:32 <mr-> arkeet: what could that patch be?
04:24:53 <arkeet> mr-: to change 'len /= size sh' to something more lazy.
04:24:59 <arkeet> where len = length xx
04:25:01 <bearclaw> the haskell way of binding C is pretty cool, compared to pythonlib or jni. You mostly don't need to write any line in the foreign language
04:25:03 <merijn> marko2: I have a fairly simple library with examples of FFI code: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L222-L257
04:25:14 <marko2> merijn: looking at the source of bytestring-mmap: it has custom .h and .c files for wrapping... Not sure why, I certainly want to avoid that
04:25:16 <mr-> arkeet: is size guaranteed to be finite/Ok?
04:25:18 <merijn> marko2: That imports/links some standard C functions and imports several CPP macros
04:25:21 <arkeet> no, and that's what was biting codh.
04:25:26 <arkeet> er
04:25:30 <arkeet> xx isn't guaranteed to be.
04:25:37 <mr-> arkeet: I was talking about size sh
04:25:42 <arkeet> well, that's an Int.
04:25:54 <Philonous_> marko2, maybe http://hackage.haskell.org/package/mmap-0.5.9 helps
04:25:54 <merijn> marko2: (eh, word of warning, the CPP macro imports may only work in GHC7.6 and newer)
04:25:56 <mr-> so is lenght xx ;-P
04:26:20 <arkeet> mr-: fine, but it may be bottom.
04:26:34 <marko2> Philonous_: I have seen this library, but I didn't try it, seeing that it basically does the same thing as bytestring-mmap..
04:26:53 <arkeet> I would actually just patch it to reject lists that are too short.
04:26:57 <arkeet> lists that are too long are fine.
04:27:06 <arkeet> :<
04:27:17 <mr-> agreed!
04:27:23 <int-e> Hmm. Are there too many Numberwang announcements? I can disable that plugin again :)
04:28:31 <Philonous_> marko2, It gives you access to mmap and munmap directly.
04:29:01 <Philonous_> marko2, You hands you the pointer and doesn't do any lazy IO magic.
04:29:05 <marko2> Philonous_: True. The only question now is whether I should go with mmap or with repeatedly opening/seeking in the file myself
04:29:15 <arkeet> go with pipes ;-)
04:29:28 <marko2> arkeet: I would, but I don't see how it helps me here
04:29:32 <merijn> marko2: Anyhoo, I'd recommend reading up on the FFI anyway (since it sounds like you're familiar with C). If you have any C experience it's incredibly simple and the libraries delightfully obvious :)
04:29:33 <arkeet> ;-)
04:30:14 <marko2> merjin: thanks a lot, also for the sample code. I will study it.
04:30:40 <merijn> marko2: The GHC manual chapter on the FFI is pretty good reading
04:34:41 <marko2> merijn, Philonous_: I tried using bytestring-mmap, but accessing the string by doing (BS.Internal.fromForeignPtr (BS.Internal.toForeignPtr stream)) first. Any idea why this didn't work?
04:35:02 <arkeet> that seems like a no-op.
04:35:26 <arkeet> or a type error.
04:36:12 <marko2> arkeet: fromForeignPtr fp s l = PS fp s l
04:36:20 <marko2> arkeet: so it does construct a new bytestring based on the ptr
04:36:55 <arkeet> yes, the same ForeignPtr
04:37:12 <arkeet> the ByteString data itself hardly takes up any memory.
04:37:14 <marko2> so can I copy a ForeignPtr or something like that?
04:37:56 <arkeet> you're looking for the copy function.
04:37:58 <marko2> resp. create a new one referencing the same data?
04:38:03 <arkeet> otherwise no.
04:40:30 <marko2> `newForeignPtr` in combination with `withForeignPtr` might work, brb ;)
04:42:28 <Philonous_> marko2, No, I'm afraid not.
04:42:49 <marko2> Philonous_: why not?
04:43:39 <Philonous_> marko2, I don't know the internals of bytestring
04:44:05 <Philonous_> At least not well enough to understand whatthe semantics of  fromForeignPtr . toForeignPtr
04:45:01 <frxx> <Kaidelong> qthaskell doesn't have a cabal package at all, gtk2hs' one is currently broken last I heard, and wxhaskell is just generally a pain to install
04:45:20 <frxx> is that true? about gtk2hs being broken
04:46:16 <tdammers> frxx: yes, somewhat
04:46:24 <frxx> in what way?
04:46:34 <tdammers> it can be worked around IIRC, but it won't install out-of-the-box on newer Cabals
05:05:02 <Dasuraga> is hugs not used at all anymore?
05:05:35 <donri> not really no
05:26:26 <Dasuraga> anyone know how to unbind all sockets on a certain port (I terminated the program before closing the socket in ghci)
05:26:58 <mm_freak> Dasuraga: wait for the kernel to deal with it
05:27:10 <Dasuraga> it's been a while and it hasn't dealt with it
05:27:28 <lasticot> Does someone have a code example that would give a good idea of how random should be handle in haskell
05:27:29 <mm_freak> Dasuraga: GHCi still running?
05:27:30 <Dasuraga> I could just close ghci and re-open it I suppose, but was trying to avoid that
05:27:32 <Dasuraga> yeah
05:27:36 <donri> you sure the process is killed?
05:27:48 <mm_freak> Dasuraga: restart GHCi
05:27:54 <mm_freak> Dasuraga: the socket is owned by GHCi
05:28:11 <donri> :t state random
05:28:12 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
05:28:21 <donri> lasticot: done, next question! :)
05:28:34 <mm_freak> Dasuraga: in the future use 'bracket' =)
05:28:45 <lasticot> donri: :p
05:28:46 <mm_freak> (from Control.Exception)
05:28:52 <lasticot> dinr:
05:30:45 <lasticot> donri: I understand if it's ok or not to thread the generator from the IO monad to where I need it? And I don't get how to use monads to avoid that?
05:30:55 <mm_freak> Dasuraga: normally GHCi would close the socket when garbage-collecting, but in your case there may be some reference to the socket…  it can be kept alive by many things, most notably lazy I/O
05:31:02 <lasticot> donri: don't*
05:31:30 <donri> lasticot: you just need to initialize a seed/generator in IO, which you can then pass to pure code and update/pass around. the state monad handles the latter for you
05:32:06 <lasticot> donri: ok I'm gonna give it a try
05:32:11 <lasticot> donri: thanks
05:33:06 <donri> > execState (do x <- state random; y <- state random; return (x,y)) (mkStdGen 123)
05:33:08 <lambdabot>   No instance for (System.Random.Random t1)
05:33:08 <lambdabot>    arising from a use of `System....
05:33:26 <mm_freak> lasticot: you need to pass the generator to the consumer regardless…  the consumer can deal with it transparently by using a state monad as in donri's example
05:33:51 <donri> > evalState (do x <- state random; y <- state random; return (x,y)) (mkStdGen 123)
05:33:52 <lambdabot>   (5912679320616661859,5085716927896574010)
05:33:59 <donri> i never remember which is which of exec/eval :p
05:34:11 <mm_freak> alternatively you can pass a stream of random numbers
05:34:25 <mm_freak> > randomRs (1,6) (mkStdGen 0)
05:34:26 <lambdabot>   [6,6,4,1,5,2,4,2,2,1,6,5,1,5,3,2,3,4,4,1,5,1,1,6,5,6,3,4,6,5,6,3,6,3,5,5,3,...
05:34:50 <lycantrophe> Hi; I'd like to traverse my tree (it's an AST for regular expressions) in order to print it with graphviz syntax to visualize what the internal structure looks like. The traversal itself is simple, as it can be no cycle; but graphviz requires node names to be unique. In C(++) I easily solved this by creating node names from pointer values; are there any simple ways of doing something similar in haskell?
05:35:07 <mm_freak> then you can write the usual lazy-stream-consumer type of design
05:35:39 <mr-> lycantrophe: can't you just dfs your tree, increasing a counter, for example?
05:35:47 <mm_freak> lycantrophe: no, because that would be impure; you need to actually generate the numbers
05:35:57 <lycantrophe> mr-: that's my backup plan :p
05:36:21 <mr-> lycantrophe: why is it not your true plan? You could do that while generating the graphviz output.
05:36:21 <mm_freak> lycantrophe: however, if your tree is Traversable, then this is a matter of using mapM
05:36:25 <Lethalman> lycantrophe, StateT with a map from pointer to name?
05:36:53 <lycantrophe> mm_freak: well, yes, but there is no unique identification on the specific node when I map over it, is it?
05:37:11 <lycantrophe> Lethalman: that can work when I have to deal with cycles, printing the state machine.
05:37:19 <mm_freak> lycantrophe: mapM (\x -> next >>= \i -> return (x, i)) myTree
05:37:36 <mm_freak> where the mapM is from Traversable and uses m = State Int or something
05:38:00 <lycantrophe> mr-: because the nodes itself could in practice carry enough value. now I have to juggle return values up the dfs to ensure uniqueness.
05:38:11 <mm_freak> lycantrophe: that operation his this type:  Tree a -> State Int (Tree (a, Int))
05:38:38 <lycantrophe> arright, I'll try that.
05:38:48 <mm_freak> and next = state (\i -> (i, succ i))
05:39:59 <mm_freak> lycantrophe: an alternative plan is to make your tree a zipping Applicative
05:40:20 <lasticot> donri: if I needed other random numbers later I would have to extract the values as well as the generator from the state monad and then thread to the next use of evalState?
05:40:30 <mm_freak> then you can generate a numbering template tree and combine them using liftA2 (,)
05:40:40 <mm_freak> but the State variant is simpler
05:41:06 <mr-> mm_freak: would that be using lens-wizardry?
05:41:11 <mm_freak> mr-: no
05:41:24 <lycantrophe> I suppose. Some traversability is fine too, though ,because I'll have to do that again to translate it into an NFA
05:41:27 <mm_freak> mr-: this is like ZipList
05:41:45 <johannesbodannes> I'm sort of torn between the choice of picking up snap, happstack or yesod for web development projects. It seems like yesod has much more aggressive type safety, which is very attractive, but then it uses a lot of GHC extensions, which I don't like as much, and tries very hard to be conventional (which I'm a little tired of, which is why I am poking my nose around here).
05:41:46 <mm_freak> mr-: where numbering looks like this:  liftA2 (,) xs (ZipList [1..])
05:42:04 <donri> lasticot: runState gets you the updated generator as well
05:42:06 <johannesbodannes> Happstack uses acid-state, which I really love the idea of
05:42:14 <donri> lasticot: if you can't stay inside State
05:42:33 <mm_freak> johannesbodannes: happstack is a good compromise
05:42:35 <donri> johannesbodannes: happstack is more type safe than yesod
05:42:38 <johannesbodannes> is it?
05:42:43 <donri> last i checked
05:42:45 <johannesbodannes> i should use happstack then...
05:42:51 <johannesbodannes> alright thanks
05:43:01 <mm_freak> donri: it's not (by itself)…  yesod has some additional safety features
05:43:16 <donri> happstack "by itself" isn't really much of anything
05:43:16 <mr-> mm_freak: Ok, but how would that work for a tree? Wouldn't you also need a tree of the same shape that already has the numbering?
05:43:19 <donri> i'm talking about ecosystem :)
05:43:46 <mm_freak> donri: even then you would have to use some packages from yesod's ecosystem to get the same level of automatic safety =)
05:44:07 <mm_freak> anyway, happstack is a good compromise and uses a categorical approach, so i prefer it
05:44:15 <johannesbodannes> excellent
05:44:17 <mm_freak> the coding style you use in happstack alone makes your programs safer
05:44:31 <dmj`> i use snap w/ acid-state and its good so far
05:44:35 <donri> mm_freak: what safety features are you thinking of?
05:45:08 <mm_freak> donri: for example templates with builtin consistency checks
05:45:17 <Eduard_Munteanu> Does the 'gstreamer' package work with gstreamer 1.x?
05:45:27 <Eduard_Munteanu> @hackage gstreamer
05:45:27 <lambdabot> http://hackage.haskell.org/package/gstreamer
05:45:36 <mm_freak> neither HSP nor blaze-html gives you that…  they only guarantee structural consistency
05:45:48 <donri> mm_freak: hm what sort of consistency?
05:45:59 <donri> HSP is quite unsafe though I agree
05:46:27 <arcke> can I force cabal to install man pages (to ~/.cabal/share/man") whenever they exist for a give package?
05:46:29 <mm_freak> donri: have you tried lucius? =)
05:46:42 <mm_freak> aka shakespeare-css
05:46:58 <donri> i would say blaze-html is a bit safer than hamlet because you get errors if you typo an element or attr
05:47:03 <dcoutts> arcke: cabal doesn't have direct support for man pages or other doc forms unfortunately
05:47:15 <dcoutts> arcke: it's clearly a nice feature to have though, patches accepted.
05:47:34 <mm_freak> donri: but not type errors
05:47:37 <mm_freak> you get not-in-scope errors
05:47:44 <donri> mm_freak: yeah i shouldn't call it "type safety"
05:47:49 <arcke> dcoutts: ok, ill see if I can do this
05:48:00 <mm_freak> anyway, i haven't used yesod for two years
05:54:06 <mangaba_leitosa> in a do sequencce for list, I have the final comprehension (working for about 30 seconds), I have the final expression 'if (Set.member (mass, l) set1 || Set.member (mass, l) set2) then [] else return (mass, l)'. I know that set1 only contains elements (mass, _) with mass /= constant and set2 only contains (mass, _) with mass == constant. However, if I optimize my expression as 'if Set.member (mass, l) (if mass /= constant then set1 else set2) t
05:54:38 <mangaba_leitosa> oops. I'll try again
05:55:27 <mangaba_leitosa> in a do sequencce for list, I have the final expression 'if (Set.member (mass, l) set1 || Set.member (mass, l) set2) then [] else return (mass, l)'. I know that set1 only contains elements (mass, _) with mass /= constant and set2 only contains (mass, _) with mass == constant
05:55:34 <mangaba_leitosa> However, if I optimize my expression as 'if Set.member (mass, l) (if mass /= constant then set1 else set2) then [] else return (mass, l)', my program works 5 seconds longer (35 seconds instead of 30). How can an additional check for (mass::Int =/ constant::Int) generate a 5 sec delay instead of optimizing things by avoiding lookup in 2 sets instead of one?
05:55:44 <donri> mm_freak: well as an example in shakespeare-js spicing in a value basically just concatenates it as a string
05:56:24 <donri> mm_freak: compare to jmacro which is preferred in happstack, where splices are actually macros on ASTs with hygiene
05:57:04 <donri> at least last i checked; haven't looked at julius in a long while
05:57:18 <mm_freak> donri: lucius
05:57:21 <mm_freak> not julius
05:57:33 <vijaykiran> Is Yesod the defacto web development framework or as a beginner (in Haskell) should I look at some other framework ?
05:57:33 <donri> mm_freak: yes, i was making a separate point :)
05:57:42 <donri> vijaykiran: depends what you're after
05:57:45 <donri> @where web
05:57:45 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
05:58:13 <vijaykiran> I'm looking for a ReST-SPA kind of webapp development
05:58:49 <donri> i don't know what that is
05:59:07 <dmj`> single page app
05:59:42 <donri> but i think yesod is designed for restful resource dispatch whereas in the others you'd need to code that up yourself, more or less
05:59:45 <vijaykiran> a single page app which calls the backend using REST/JSon stuff - compared to multiple page per screen
06:00:28 <vijaykiran> but from my understanding it uses Template Haskell - which is kind of "advanced" for a n00b like me .. right ?
06:00:38 <donri> aha, elm might be an idea for the frontend side of that
06:01:01 <donri> template haskell isn't that advanced as a "consumer"
06:01:17 <mangaba_leitosa> It seems that my question was too long. I'll rephrase: how can an expression 'Set.member (mass, l) (if mass /= constant then set1 else set2)' take longer to evaulate than 'Set.member (mass, l) set1 || Set.member (mass, l) set2' ?
06:01:21 <vijaykiran> donri: oh, okay - may be my fears are founded on "unknown"
06:01:55 <dmj`> vijaykiran: This might help, https://github.com/raimohanska/snap-mongo-rest.
06:01:57 <donri> i've mostly seen experienced haskellers complain about the TH in yesod... beginners are more scared by all the type classes
06:02:26 <Fuuzetsu> chrisdone: just saw ‘Hell’, you are the hero shells of 2013 need
06:02:32 <vijaykiran> dmj`: fantastic - thanks!
06:03:17 <vijaykiran> this was probably my next question - how to design DB access in a lazy language
06:04:28 <donri> vijaykiran: here's a purely-haskell way to do this rest-spa-style stuff http://happstack.com/page/view-page-slug/15/happstack-fay-acid-state-shared-datatypes-are-awesome
06:05:14 <vijaykiran> "type-checked AJAX interface between the browser and the server" wow :)
06:05:24 <donri> vijaykiran: the frontend is haskell compiled to js, and the database uses haskell data types that are shared with the frontend
06:06:36 <vijaykiran> donri: yup - pretty much what i was looking for - similar to Clojure/ClojureScript
06:06:42 <dmj`> donri: great link, happstack seems the best choice, although I'd like to see a good example of authentication w/ it
06:07:15 <donri> there's happstack-authenticate but it's a bit of a mess
06:08:41 <donri> mangaba_leitosa: what if you union the two sets up front?
06:09:15 <dmj`> donri: yes, I think yesod opts for openauth, so I had to go w/ snap since it had an auth backend
06:09:41 <mangaba_leitosa> donri: then lookup should take longer (at least in theory), but I'll try now
06:10:51 <donri> mangaba_leitosa: well set is optimized for member testing. i usually find when i try to outsmart either the compiler or optimized libraries, i'm fighting a losing battle :)
06:11:41 <mangaba_leitosa> donri: yes, but the sets contain > 10000 of elements each, so union must generate an overhead :-)
06:12:29 <donri> mangaba_leitosa: certainly, but you'd do that once up front right?
06:12:42 <mangaba_leitosa> donri: no, this function is called many times with different sets
06:12:49 <donri> hmm
06:13:26 <klugez> dmj`: "Yesod provides built-in support for a number of third-party authentication systems, such as OpenID, BrowserID and OAuth. These are systems where your application trusts some external system for validating a user's credentials. Additionally, there is support for more commonly used username/password and email/password systems."
06:13:32 <donri> i mean once in the function and not for each iteration of the list comprehension
06:13:46 <mangaba_leitosa> donri: I just cannot get it: how doing int1 == int2 makes the function to take longer?
06:13:55 <mangaba_leitosa> donri: yes, once in the function
06:14:04 <ocharles> Does the notion of a free indexed monad exist on hackage?
06:14:23 <donri> @hackage indexed-free
06:14:23 <lambdabot> http://hackage.haskell.org/package/indexed-free
06:14:26 <ocharles> awesome, thanks
06:14:36 <ocharles> I /think/ this is what I want
06:15:08 <mangaba_leitosa> donri: ok, I tried 'let sets = Set.union set1 set2' before the list comprehension and then doing if (Set.member (mass, l) sets)
06:15:31 <donri> mangaba_leitosa: where's that let?
06:15:49 <mangaba_leitosa> donri: before the list comprehension
06:15:52 <ocharles> I'm trying to write a little JSON test tool. I want to be able to say 'key "name" personName >>= expect . (==)' - that would encode a query into a JSON structure (x["name"]) and a function that can be applied to get an expected value
06:16:05 <mangaba_leitosa> donri: the function takes the same time to complete
06:16:11 <ocharles> The usage is then: runTest (key "name" personName >>= expect . (==)) (Person "Bob")
06:16:29 <mangaba_leitosa> donri: yet my idea is to avoid looking in two sets one looking in just one is enough
06:16:46 <mangaba_leitosa> donri: but it becomes slower :-O
06:17:39 <donri> mangaba_leitosa: it could be a strictness issue, that the if forces both sets to be evaluated but the || only the first. maybe. no clue. :D
06:19:02 <mangaba_leitosa> donri: 'if a then b else c' is lazy by its nature (does not evaluate c if a is True), eitherwise nothing would have worked :-O
06:19:07 <mangaba_leitosa> donri: thanks anyway :_)
06:19:39 <mangaba_leitosa> donri: haskell is so inpredictable :-)
06:21:52 <lasticot> I've just finished this 300 long piece of code which is working but is awfully coded, because, well, it's my first real program. I plan on cleaning it and making it beautiful  as and to better understand the Haskell way of coding. Do you have any advice on how to proceed? I was thinking of reading open source code and even contributing  in the long term, I came across a post mentioning ...
06:21:54 <lasticot> ...xmonad, do you have any other project I should check out?
06:23:08 <donri> mangaba_leitosa: and what if you move the Set.member in, if mass /= constant then Set.member (mass,l) set1 else Set.member (mass,l) set2  ?
06:23:25 <donri> i vaguely recall some laziness gotcha here, i could be confused
06:23:26 <bartavelle> lasticot, you might get some "tactical" insight just by running hlint
06:24:05 <mangaba_leitosa> donri: tried that, the time is the same
06:24:10 <mangaba_leitosa> donri: just out of curiousity, I have now added '(mass == mass') `seq` True &&' before (Set.member || Set.member) in my 'if'
06:24:22 <mangaba_leitosa> donri: this added 5 additional seconds again
06:24:50 <mangaba_leitosa> donri: do, it seems that it's not about sets, it's about (mass == mass') being slow (they are Int)
06:24:58 <lasticot> bartavelle: thanks
06:25:00 <vijaykiran> Any help with ExitFailure 1 from cabal - https://gist.github.com/vijaykiran/bf6dc3653842737edade  ?
06:25:01 <mangaba_leitosa> donri: I can't understand that :-)
06:25:16 <donri> yeah, you'd think Eq Int would be quite cheap
06:25:31 <dcoutts> vijaykiran: look at the message there
06:25:32 <dcoutts> setup: The program ghc version >=6.4 is required but the version of
06:25:32 <dcoutts> /usr/bin/ghc could not be determined.
06:25:50 <merijn> donri: Well, not if the Int's are unevaluated thunks, I guess?
06:26:11 <vijaykiran> dcoutts: yes, tried that - which ghc ; ghc --version => /usr/bin/ghc ; The Glorious Glasgow Haskell Compilation System, version 7.4.1
06:26:13 <donri> oh, true. maybe "constant" is an expensive thunk?
06:26:21 <donri> mass should already be forced by Set.member
06:26:43 <mangaba_leitosa> donri: 'constant' is the first argument of the function
06:27:14 <dcoutts> vijaykiran: ok, then the next step is to see if we can get more detail by running with -v3
06:27:19 <mangaba_leitosa> donri: and it's used in the function anyway :-)
06:27:36 <donri> mangaba_leitosa: you're sure it gets evaluated?
06:28:05 <dcoutts> vijaykiran: also, check what /usr/bin/ghc --numeric-version reports
06:28:13 <donri> i suppose you could time the fast version with a bang pattern on constant
06:28:31 <mangaba_leitosa> donri: it's used in the function like  'partition ((/= constant) . fst) $ do { my comprehension here }
06:29:09 <donri> mangaba_leitosa: well, list operations are lazy...
06:29:40 <mangaba_leitosa> donri: yes, this must be the likely reason then...
06:29:57 <vijaykiran> dcoutts: ran with v3 - and --numeric-version reports 7.4.1
06:29:57 <lambdabot> That's Numberwang!
06:30:06 <donri> i also recall some silliness about list comprehensions getting optimized better than do notation for lists
06:30:19 <vijaykiran> dcoutts: https://gist.github.com/vijaykiran/bf6dc3653842737edade < added a coment there with the results
06:31:30 <dcoutts> vijaykiran: and what exit code does it produce?
06:31:51 <mangaba_leitosa> donri: I used the do notation instead of [ | ] because I need either 'return something' or '[]' in the final statement
06:32:10 <vijaykiran> dcoutts: sorry . which one ? the /usr/bin/ghc --numeric-version ?
06:32:18 <donri> mangaba_leitosa: you can do that with list comprehensions too
06:32:22 <donri> bit silly/ugly though
06:32:22 <dcoutts> vijaykiran: yes.
06:32:40 <vijaykiran> dcoutts: 0
06:32:50 <donri> > [ y | x <- [1,2,3], y <- [] ]
06:32:51 <lambdabot>   []
06:32:59 <donri> > [ y | x <- [1,2,3], y <- [1] ]
06:33:00 <lambdabot>   [1,1,1]
06:33:04 <dcoutts> vijaykiran: as you can see, cabal thinks that /usr/bin/ghc --numeric-version is producing "" as output, ie nothing. However, that's almost certainly because the code pretends it produces "" when there is an IO exception or the program returns a non-0 exit code
06:33:40 <vijaykiran> here - > /usr/bin/ghc --numeric-version => 7.4.1 ; echo $? => 0
06:33:42 <mangaba_leitosa> donri: thanks, I will try that and see if there this is faster :-)
06:34:17 <dcoutts> vikraman: 0, hmm ok. more detailed test, use ghci -package Cabal; import Distribution.Simple.Utils; import Distribution.Version;
06:34:49 <dcoutts> vikraman: and run: rawSystemStdout verbose "/usr/bin/ghc" ["--numeric-version"]
06:36:06 <dcoutts> vikraman: oops, sorry, not Distribution.Version, Distribution.Verbosity
06:36:34 <vijaykiran> dcoutts: you meant vijaykiran :) not vikraman
06:36:41 <dcoutts> doh
06:36:47 <dcoutts> tab completion
06:37:06 <mangaba_leitosa> donri: I got interesting results
06:37:21 <vijaykiran> dcoutts: ok - Couldn't match expected type `Verbosity' with actual type `[Char]'
06:37:52 <dcoutts> vijaykiran: oh, older version perhaps doesn't have the verbosity param, leave it off
06:37:58 <vijaykiran> dcoutts: complete - https://gist.github.com/vijaykiran/a9f70beb663f502d0288
06:38:00 <mangaba_leitosa> donri: the 'do with (mass == mass') `seq` True' version converted to list comprehension became faster. the 'do without seq' became much slower :-)
06:38:49 <donri> mangaba_leitosa: excessive polymorphism perchance?
06:38:50 <mangaba_leitosa> donri: but at the same time 'do with (mass == mass') `seq` True' version converted to list comprehension takes about as much time as 'do without seq' (not converted to list comprehension)
06:39:10 <dcoutts> vijaykiran: oh, no you were missing the verbose arg, include it.
06:39:16 <mangaba_leitosa> donri: well, the function is not polymorphic :-)
06:39:24 <dcoutts> vijaykiran: all in one: Distribution.Simple.Utils.rawSystemStdout Distribution.Verbosity.verbose "/usr/bin/ghc" ["--numeric-version"]
06:39:25 <vijaykiran> dcoutts: crap - sorry
06:40:08 <donri> mangaba_leitosa: also you'll want to bind to a name anything you `seq`, or it might just make it evaluate it twice
06:40:46 <vijaykiran> dcoutts: I get - "7.4.1\n" gist here - https://gist.github.com/vijaykiran/a9f70beb663f502d0288
06:40:50 <donri> let cond = mass == mass' in cond `seq` True ... and use "cond" anywhere you have equality test
06:41:05 <mangaba_leitosa> donri: but I only use it once :-)
06:41:14 <vijaykiran> dcoutts: is it the \n ?
06:41:14 <donri> then why seq it
06:41:22 <dcoutts> vijaykiran: no, that's all as we expect so far
06:41:54 <mangaba_leitosa> donri: in this case, I don't use it at all, just try to detect how evaluating or not evaluating it affects the execution time
06:42:20 <mangaba_leitosa> donri: and in 'do' it slows things down, in list comprehension it makes things faster :-0
06:43:28 <donri> yeah there's all sorts of things like cache locality going on that i don't really understand completely myself
06:43:45 <dcoutts> vijaykiran: ok, next: Distribution.Simple.Utils.findProgramVersion "--numeric-version" id Distribution.Verbosity.verbose "/usr/bin/ghc"
06:43:51 <vijaykiran> dcoutts: is it possible that my cabal version is too low/old ?
06:44:08 <dcoutts> vijaykiran: no, I'm trying the same version as you
06:44:52 <vijaykiran> dcoutts: ok - this results in  = Just (Version {versionBranch = [7,4,1], versionTags = []})
06:45:13 <dcoutts> vijaykiran: ah, wait a sec, you're not using Cabal-1.14.0, you're building Cabal-1.18.1.2, which builds using itself...
06:45:27 <vijaykiran> dcoutts: fyi, cabal -version 0.14.0
06:45:55 <vijaykiran> dcoutts: sorry - yeah that's what I meant - may be the 0.14.0 isn't able to build 0.18 or whatever
06:45:56 <mangaba_leitosa> donri: previously, I only new that forcing complex structures such as lists can effect performance. Now I know that forcing an Int value passed as argument to your function affects it to :-O  An immense new spectrum of possible optimizations is opening up :-)
06:47:29 <dcoutts> vijaykiran: ok, lets cabal unpack Cabal-1.18.1.2; cd Cabal-1.18.1.2
06:48:10 <vijaykiran> dcoutts: done -- you want me to do usual ./configure make dance :) ?
06:48:17 <dcoutts> vijaykiran: no
06:48:19 <dcoutts> vijaykiran: then ghci Distribution/Simple/Utils.hs  and evaluate the same code as above, the findProgramVersion one
06:48:55 <vijaykiran> dcoutts: ah -  Warning: cannot determine version of /usr/bin/ghc : \n ""  \n Nothing
06:49:03 <dcoutts> !
06:49:07 * hackagebot filelock 0.1.0.0 - Portable interface to file locking (flock / LockFileEx)  http://hackage.haskell.org/package/filelock-0.1.0.0 (AkioTakano)
06:49:44 <jml> how do I pretty print data structures in the repl?
06:49:49 <dcoutts> vijaykiran: ok, eval the earlier one again, the rawSystemStdout
06:50:19 <vijaykiran> dcoutts: ghc died
06:50:27 <donri> @hackage groom perhaps, jml
06:50:27 <lambdabot> http://hackage.haskell.org/package/groom perhaps, jml
06:50:37 <dcoutts> vijaykiran: details?
06:50:44 <vijaykiran> dcoutts: segfaulted - /usr/bin/ghc: runInteractiveProcess: invalid argument (Bad file descriptor)
06:51:04 <dcoutts> vijaykiran: can I see the log?
06:51:05 <vijaykiran> dcoutts: complete log since unpack https://gist.github.com/vijaykiran/34fb167fbeff20c2b216
06:51:07 <dcoutts> ta
06:52:08 <dcoutts> vijaykiran: are you using ghc with clang on osx?
06:52:37 <vijaykiran> dcoutts: hmm -- could be - I'm on Mavericks
06:52:50 <dcoutts> vijaykiran: so at least we're closer to the problem runInteractiveProcess is failing, which smells like a much lower level bug, it's not cabal's fault probably.
06:52:54 <vijaykiran> dcoutts: so cc is clang
06:53:17 <dcoutts> vijaykiran: there are special things you have to do to get a working setup with ghc on osx after the switch to clang
06:53:37 <dcoutts> normally it just flat out doesn't work though
06:53:39 <vijaykiran> dcoutts: oh, so I miised some setup steps
06:53:46 <dcoutts> I've not seen reports on other random errors
06:53:50 <jml> donri: thanks, will try it.
06:54:07 <dcoutts> vijaykiran: but clearly here we have a problem that's making System.Process.runInteractiveProcess behave wrong
06:54:08 <jml> it's probably the most obvious thing I miss from ipython.
06:54:44 <vijaykiran> dcoutts: any pointers to where I should look/read to fix this myself ?
06:55:07 <dcoutts> vijaykiran: google for GHC OSX Mavericks clang
06:55:33 * vijaykiran feels stupid. googling now
06:55:40 <dcoutts> vijaykiran: if you think you've followed all the instructions, then file a ticket about the failing System.Process.runInteractiveProcess
06:56:28 <dcoutts> vijaykiran: oh, and it's not even 7.6 you're using
06:56:50 <vijaykiran> dcoutts: I used that Haskell platform package thingie for OS X
06:57:02 <vijaykiran> dcoutts: I'll wipe stuff off and start in a clean way
06:57:25 <dcoutts> vijaykiran: short story: XCode 5 introduced Clang and broke everything
06:57:44 <dcoutts> vijaykiran: is you can use an older XCode you're fine, if not you need to read the longer story.
06:57:48 <dcoutts> is/if
06:58:18 <vijaykiran> dcoutts: I need the latest XCode - for iOS dev - so I guess I need to put in the fix
06:58:42 * dcoutts presumes multiple versions of XCode cannot be installed side by side
06:58:55 <vijaykiran> they can be but it is a bit more PITA
06:59:51 <merijn> dcoutts: Naah, clang was already shipped for ages, XCode 5 *dropped* gcc, that's the problem
07:00:04 <geekosaur> ^
07:00:11 <Kaidelong> haskell can target iOS?
07:00:15 <Kaidelong> GHC anyway
07:00:24 <Kaidelong> I did not know that, also awesome
07:00:27 <dcoutts> merijn: yes, you're right of course
07:00:27 * geekosaur is still keeping xcode 4 on his desktop because he'd rather not fight with it right now
07:00:29 <merijn> Kaidelong: Work in progress
07:00:41 <merijn> Kaidelong: ARM support is starting to get there
07:00:46 <dcoutts> merijn: still, XCode 5 broke everything :-)
07:01:06 <vijaykiran> dcoutts: ah, http://www.haskell.org/platform/mac.html has a note for XCode 5/ Mavericks
07:01:20 <Kaidelong> merijn: shouldn't ARM support just be a matter of LLVM support?
07:01:44 <vijaykiran> dcoutts: I haven't looked at it - since I installed Haskell before Mavericks released. Sorry for the noise. I'll use the workaround
07:01:47 <dcoutts> vijaykiran: ah good
07:02:02 <dcoutts> vijaykiran: you can tell I'm not an OSX user :-)
07:02:26 <vijaykiran> dcoutts: :) I should have added my OS to my first question
07:02:48 <vijaykiran> being mostly JVM guy it usually isn't the first thing to remember :)
07:07:42 <Fuuzetsu> What are the project name restrictions for Cabal ‘name’ field? I tried making a project under a name ‘cwk2-cm20219-2013’ and it doesn't like it. Underscores don't do the job either.
07:08:12 <Fuuzetsu> Eduard_Munteanu: Damn you, I saw you in #gentoo and thought it was #haskell so I posted in the wrong channel…
07:08:21 <Eduard_Munteanu> :D
07:08:25 <dcoutts> Fuuzetsu: can't have '-' separated components that are all numeric, or it'd be ambiguous with a version number
07:08:42 <Fuuzetsu> But wouldn't underscores work?
07:08:44 <dcoutts> Fuuzetsu: so it's that -2013 bit that's a problem
07:09:24 <Fuuzetsu> Or rather, ‘shouldn't underscores work?’. Because they don't.
07:11:17 <bennofs>  /join #finance
07:11:18 <dcoutts> Fuuzetsu: _ isn't allowed at all
07:13:11 <Fuuzetsu> dcoutts: Alright, thanks. For future reference, what separator would you recommend?
07:13:20 <dcoutts> Fuuzetsu: -
07:13:26 <Fuuzetsu> th-thanks
07:15:19 <klrr_> chrisdone: cool shell you made! also really readable code :) ill try use it this evening, ive waited for this for a long time (tried some scheme shells before) since im really too lazy to learn all the unix tools (even though i got TUPE) this will hopefully make me more effecient in commandline
07:21:15 <Rc43> Somehow can't make uhc work without installation.
07:22:07 <Rc43> I downloaded it and use like `ehc --pkgsearch=<package-database-inside0uhc-distro> T.hs`, but it claims that cannot find Prelude.
07:22:11 <chrisdone> klrr_: for me too! i don't like bash. see also this i just added! https://github.com/chrisdone/hell#using-shell-libraries so you can use one of the shell libraries from hackage or put your own in
07:24:20 <klrr_> oh nice!
07:27:03 <quchen> chrisdone: How long did you develop that
07:27:15 <quchen> for/since, pick your choice. :-)
07:27:26 <klrr_> readme said it was written in a few hours
07:30:23 <kthl````> chrisdone: are you really living in Italy then (read about rive del garda on your blog just yesterday). Napoli, qui :)
07:32:57 <Fuuzetsu> …can you document data type constructors with Haddock comments? I feel like I shouldn't be the one asking this but I totally forgot and I don't recall there being documentation for this…
07:33:11 * Fuuzetsu makes a mental note to write documentation on what we can actually attach Haddock comments to.
07:33:39 <haasn> Fuuzetsu: I think you can
07:33:46 <haasn> but it gets formatted uglily or something
07:34:11 <Fuuzetsu> haasn: Well, I'm writing it on an executable module so it's never actually going to be rendered… Just a matter of principle.
07:34:28 <DanielDiaz> Fuuzetsu: sure you can: http://hackage.haskell.org/package/HaTeX-3.9.0.0/docs/Text-LaTeX-Packages-TikZ-Syntax.html#t:TPath
07:34:36 <Fuuzetsu> Also what do you mean gets formatted uglily? Is there a bug filed?
07:34:44 <Fuuzetsu> I didn't see a bug filled for this.
07:34:54 <Fuuzetsu> DanielDiaz: Thanks, thought so.
07:35:24 <Fuuzetsu> solirc: Around?
07:36:37 <BoR0> I am looking at memoized_fib :: Int -> Integer
07:36:39 <BoR0> from http://www.haskell.org/haskellwiki/Memoization
07:36:54 <BoR0> why is the code running too slow if I make "memoized_fib x = (map fib [0 ..] !!) x"
07:37:11 <solirc> Fuuzetsu: yes
07:39:05 <Kaidelong> oh dear, eta expansion is not supposed to be an important thing in haskell is it?
07:39:26 <Kaidelong> seems BoR0 found an example where eta expansion changes behavior
07:39:31 <AVariedDeveloper> Do you guys know if there's a tool right now to browse the installed modules on your own computer/search for functions in them?  Sort of like a local graphical hoogle?
07:39:47 <BoR0> thank god it's a haskell error! it completely blew my mind. I think I forgot everything I knew about haskell
07:40:00 <quicksilver> if you install haddock docs along with your modules you get a local haddock index page
07:40:00 <Kaidelong> I didn't say it was an error
07:40:08 <quicksilver> unfortunately that's not on by default
07:40:17 <BoR0> but how does eta expansion change a behaviour?
07:40:22 <merijn> AVariedDeveloper: There's a non graphical Hoogle for local
07:40:31 <merijn> @hackage hoogle
07:40:31 <lambdabot> http://hackage.haskell.org/package/hoogle
07:40:54 <AVariedDeveloper> merijn:  Nice!  Does that work against all intsalled packages?
07:40:55 <merijn> AVariedDeveloper: Also, as quicksilver points out you should set "Documentation: True" in your cabal config to get local documentation
07:41:18 <merijn> AVariedDeveloper: You can compile your own databases of packages (i.e. all local stuff, all of hackage, etc.)
07:41:32 <AVariedDeveloper> That's pretty cool.  Thank you everyone!
07:41:33 <Fuuzetsu> solirc: Did you manage to merge in more changes into upstream Haddock? I'm mainly interested in the stuff I wrote in ‘features’ branch.
07:42:30 <Fuuzetsu> I'd like to do some more hacking on Haddock (such as concentrating on non-parser issues) but I'd very much like to work on top of what I wrote over summer rather than on what current master is and then having to either rebase or make it somehow work when/if the changes make it.
07:42:39 <Kaidelong> https://groups.google.com/forum/#!topic/fa.haskell/LEFHMgwCO4g
07:44:17 <Kaidelong> BoR0: looks like the issue is a type inference related one
07:44:32 <Fuuzetsu> merijn: Unfortunately the hoogle files generated by Haddock from local documentation are quite broken. I don't know how Neil managed to get the Hoogle search engine to work, I imagine it involved a lot of dirty hacks on his end. There are multiple issues open on this.
07:44:49 <Kaidelong> for some reason if you don't provide the x it is bound to the type Integer and if you do provide it it becomes (Num a) => a and the memoization gets lost
07:44:50 <Fuuzetsu> So local hoogle won't be as nice as the online one.
07:45:10 <Kaidelong> that's something you should be able to test
07:46:08 <Kaidelong> @ty let fib 0 = 0 in (map fib [0..] !!)
07:46:09 <lambdabot> Num a => Int -> a
07:46:27 <levi> Doesn't the command-line hoogle download the database from online somewhere when you first run it?
07:46:30 <Kaidelong> well I dunno if lambdabot has monomorphism restriction
07:46:49 <klrr_> chrisdone: i got some standard commands like
07:46:56 <BoR0> Kaidelong, note that memoized_fib calls inner function fib
07:46:58 <Kaidelong> BoR0: see if it runs fast again if you give it an explicit type like Int -> Int that is not polymorphic
07:47:03 <klrr_> 'clear' that i wanna implement, are you looking for patches or should i make my own lib?
07:47:33 <Kaidelong> in production this is where you would use the SPECIALIZE pragma, I think
07:47:34 <BoR0> Kaidelong, it does, but produces wrong output
07:47:47 <Kaidelong> Int -> Integer?
07:47:58 <Kaidelong> might have overflowed Int
07:48:02 <BoR0> Int -> Integer is slow, Int -> Int is fast but wrong otput
07:48:34 <klrr_> chrisdone: nvm it's too simple to be in the prelude i guess :P
07:48:40 <Kaidelong> (Num a) => Int -> a is no slower than Int -> Integer?
07:48:41 <BoR0> I don't understand why this kind of reduction would change the overall behaviour of a function
07:49:28 <Kaidelong> the more you know about what types are involved the more you can assume about what data can be reused because you know that all things of type Integer are compatible with one another but not that all things with typeclass Num are
07:49:36 <klugez> levi: You have to run 'hoogle data' and it downloads a tarball.
07:49:37 <BoR0> it is slow Kaidelong
07:50:11 <quchen> BoR0: Haskell does not automatically memoize functions. For that reason, calling "f x = foobar" will do the whole calculation each time you provide an "x".
07:50:36 <quchen> If you want something memoized, you'll have to give it a simple identifier, and not a function definition.
07:51:21 <Kaidelong> quchen: so the eta expansion itself is the issue because there is a difference between a function and a value with a function type?
07:51:41 <quchen> Right.
07:51:51 <Kaidelong> that's surprising
07:52:00 <solirc> Fuuzetsu: Sorry for the delay on this.
07:52:27 <solirc> I did some more refactoring on top of your changes + fixed a couple of bugs.
07:52:42 <BoR0> quchen, so basically eta reduction can be used to play around with haskell's laziness?
07:52:50 <solirc> There are still some quirks in there..
07:52:50 <quchen> let fibo = 0 : 1 : zipWith (+) fibo (tail fibo); fib n = fibo !! n in fib 10 -- This will memoize 'fibo'.
07:53:20 <quchen> BoR0: Both ways are lazy, it's just that one has better sharing.
07:53:23 <solirc> But I just wrote a mail to Austin.  If he is ok, then let's push it.
07:53:42 <Fuuzetsu> solirc: Well, I understand that you're a busy person but I'm just worried about the 7.8 release. If you feel that there are things that I could fix (and not further break) then don't hesitate to send it my way!
07:53:47 <Fuuzetsu> Ah, great.
07:53:59 <BoR0> I see.
07:55:07 <BoR0> I don't like this behaviour at all, it is so implicite and non intuitive
07:56:03 <solirc> Fuuzetsu: If you can double check that everything builds (documentation for base, etc.) that would be great.
07:56:13 <solirc> But first let's wait for the ok from Austin.
07:56:26 <skypers> hello
07:57:16 <Peaker> > map fst $ iterate (\cur next -> (next, cur+next)) (0,1)
07:57:19 <lambdabot>   Couldn't match expected type `(b0, b1) -> ((b0, b1), (b0, b1))'
07:57:19 <lambdabot>            ...
07:57:32 <Peaker> > map fst $ iterate (\(cur, next) -> (next, cur+next)) (0,1)
07:57:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:58:21 <Fuuzetsu> solirc: Alright, I'll build HEAD later tonight (hopefully…) and build the whole thing + docs + base docs &c and see how it goes.
07:59:45 <Fuuzetsu> I asked around in #ghc again the other day, maybe I'll even be able to get an OK on GHC validation although I wouldn't hold my breath on that.
08:01:15 <solirc> Fuuzetsu: I usually first validate without my changes and then check that my changes don't introduce new issues ;)
08:02:01 <solirc> Fuuzetsu: Use this branch https://github.com/sol/haddock/tree/new-parser
08:02:07 <Fuuzetsu> Yes, that's more or less what I've been trying in the past but it's hard to judge sometimes, especially if some validate tests are intermittent &c
08:02:54 <solirc> also note that I removed some of your documentation
08:03:06 <solirc> we have the specs for that
08:04:07 <Fuuzetsu> solirc: That branch seems to have a lot of new stuff missing (in fact it seems to just have a parser that matches the features of the old one)?
08:06:40 <skypers> do you know a flip version of mapAccumL?
08:08:12 <Peaker> @type mapAccumL
08:08:13 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:08:57 <Peaker> mapAccumL ::~ (x -> State acc y) -> [x] -> State acc [y]
08:09:21 <Peaker> mapM :: (x -> m y) -> [x] -> State acc [y]
08:09:35 <Peaker> oops
08:09:42 <Peaker> mapM :: Monad m => (x -> m y) -> [x] -> m [y]
08:09:53 <Peaker> forM :: [x] -> (x -> m y) -> m [y]
08:10:02 <piezoid> hi
08:10:03 <Peaker> I dislike mapAccumL :) Just wrap with State... and then you have forM
08:10:07 <Peaker> skypers: ^^
08:10:08 <piezoid> is anyone using Kate for haskell coding ?
08:10:22 <piezoid> the default indentation script is a pain for me...
08:10:26 <skypers> Peaker: well
08:10:37 <solirc> Fuuzetsu: yes, it does not include your feature branch, we have to cherry-pick that separately
08:10:41 <skypers> for now I have forM and state, but it’s annoying to use
08:10:49 <Peaker> skypers: why?
08:10:51 <skypers> the state is already something
08:10:57 <skypers> I don’t want to make a tuple as a state
08:11:11 <Peaker> skypers: what do you mean? mapAccumL makes you use a tuple
08:11:22 <Peaker> skypers: you could use StateT on State
08:11:29 <Peaker> (currying at the transformer level)
08:11:29 <skypers> no it doesn’t
08:11:56 <Peaker> I meant that mapAccumL uses tuple return values. Then I realized what you meant about the tuples
08:12:10 <Fuuzetsu> solirc: So you want me to build everything the new-parser and we can start piling new stuff on later (assuming Austin gives OK)?
08:12:12 <skypers> yeah, well btw I think it won’t make it
08:12:18 <Fuuzetsu> everything with the*
08:13:11 <skypers> I have a list of things and a value. The value is the state of a StateT, and I want to run a forM that modifies the list in StateT, accumuling something from each element of the list in order to pass it to the next
08:13:28 <skypers> mapAccumL is not what I want
08:13:34 <skypers> because it’s not monadic…
08:13:57 <skypers> the function is (a -> b -> (a,c)), and I need (a -> b -> m (a,c))
08:14:46 <joelteon> you could write your own
08:14:46 <solirc> Fuuzetsu: I think once we have the new-parser on master, doing smaller changes should be fine, yes.
08:15:01 <joelteon> mapAccumLM
08:15:36 <solirc> We for sure want the bold.
08:15:57 <solirc> There was something with the headlines, I had some questions regarding how they get nested.
08:16:13 <solirc> Not sure what else was on the feature branch.
08:16:19 <solirc> Will have a look then ;)
08:20:11 <mangaba_leitosa> donri: I'm still on this unused "(mass /= mass') seq True" thing. I discovered that I don't have to force mass and "takeWhile (`seq` True) [mass']) `seq` True" takes the same time. However, if I try to replace "takeWhile (`seq` True) [mass']) `seq` True" with just "mass' seq True", the program takes 10 second longer to complete. Ideas? :-)
08:20:19 <skypers> is there a zipIndex function?
08:20:20 <skypers> like
08:20:26 <skypers> zip x [1..]
08:20:48 <mangaba_leitosa> donri: mass' is initialiazed from a generator in the list comprehension, BTW
08:23:29 <quchen> Every what order of magnitude in time does GHC typically run GC?
08:24:12 <donri> there's a +RTS flag to make it beep on GC which sounds like a machine gun
08:26:46 <quchen> Okay, that's sufficiently accurate.
08:31:24 <joelteon> that's awesome
08:35:05 <klrr_> hmm i get this error "cabal: can't find source for DotHellRC in ., dist/build/autogen" when i try build my project with cabal (paste here https://gist.github.com/klrr/7602561 ) anyone know what the problem might be?
08:36:37 <quchen> Peaker: I think I identified (part of) my leak. If you're interested: I have the usual infinite loop forking workers for every new incoming connection. After some handshaking, that connection is added to the "known neighbours" database. For safety, there is a watcher; should something fishy happen and a connection gets deleted from the DB, the corresponding thread is killed. The problem is that for technical reasons, the "worker fork" is fo
08:36:37 <quchen> rkIO, while the watcher is an async. In case of an exception, the async is terminated correctly, but the forkIO isn't; the entry stays in the databse, the watcher is oblivious and the worker runs indefinitely. Meanwhile, the enclosing system thinks the worker should have been terminated now, and launches a replacement. Bam, leak.
08:39:01 <Fuuzetsu> solirc: re: headlines: What's your question?
08:39:15 <Peaker> quchen: I don't understand:  the "watcher" watches the DB?
08:39:34 <Fuuzetsu> Shou: Please don't use unsafePerformIO ;_;
08:39:35 <Peaker> quchen: what was supposed to delete it from the DB?
08:39:48 <Sagi> What would be the best resource to start learning about writing tests for haskell code? Preferably something that compares the different frameworks, including examples etc.
08:40:23 <Shou> Fuuzetsu, ww
08:40:31 <quchen> Peaker: No, the watcher monitors a thread, and kills it should its entry be removed from the DB. Reasons for doing so is when no useful signal has come from the connection in some time, for example.
08:40:48 <quchen> The DB is basically the list of allowed connections.
08:40:50 <Shou> Fuuzetsu, I'm just getting a working prototype out then I was planning to refine it.
08:40:51 <Fuuzetsu> Sagi: There's http://book.realworldhaskell.org/read/testing-and-quality-assurance.html and you should probably also read about QuickCheck. Personally I use ‘hspec’ for spec testing (which can use QuickCheck)
08:41:20 <Fuuzetsu> Shou: Yeah but come on man, that unsafePerform was totally unnecessary not to mention it can (and does) change semantics
08:41:27 <Peaker> quchen: Thread leakage is so easy with forkIO.  I prefer "withForkedIO" that brackets the forkIO around some scope to kill it when leaving that scope
08:41:30 <Sagi> Fuuzetsu: ah, I remember now that I actually own that book :-D
08:41:32 <Sagi> thanks
08:41:57 <lpaste> mangaba_leitosa pasted “((takeWhile (`seq` True) [mass']) `seq` True) vs.  (mass' `seq` True)” at http://lpaste.net/96017
08:42:09 <quchen> Peaker: But when I want to fork something on each iteration of a loop I can't do that :-(
08:42:21 <merijn> @quote not.a.bug
08:42:22 <lambdabot> SPJ says: [This is] clearly not a bug in GHC; but it would be more felicitous if it gave you a warning...
08:42:24 * mangaba_leitosa feels like his haskell program is totally out of his control ^ in the lpaste above, a meaningless change to the code adds 10 seconds to execution time :-(
08:42:24 <Shou> Fuuzetsu, I know ;_;
08:42:25 <merijn> bah
08:42:30 <merijn> I hate it when I missguess quotes
08:42:43 <Shou> Fuuzetsu, I did it at like 3 AM or something so I was rushing >.>
08:42:52 <quchen> go = accept >>= \connection -> forkIO (...) >> go  -- Peaker I don't think I can write this with bracketing, can I?
08:42:55 <Fuuzetsu> Shou: Well, I usually wake up at 3am ;)
08:43:25 <merijn> @quote Lemmih not.a.bug
08:43:26 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
08:43:37 <Peaker> quchen: you can, use sequence with ContT
08:43:42 <Peaker> @type bracket
08:43:43 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:43:58 <quchen> UUuuuugh, ContT, my arch enemy!
08:44:20 <Fuuzetsu> I haven't used Cont yet!
08:44:24 <Fuuzetsu> I feel kind of good about that.
08:44:31 <Fuuzetsu> For no particular reason.
08:45:19 <quchen> And there's no way to poll a ThreadId?
08:45:24 <Peaker> if you wrap bracket with something like:  IO a -> (a -> IO b)  -> ContT c IO a    then you can use the wrapper to make a [ContT c IO a], then sequence on that, and runContT on that
08:46:16 <Peaker> @type \ini fini -> ContT . bracket ini fini
08:46:17 <lambdabot>     Couldn't match type `IO c0' with `(a0 -> m0 r0) -> m0 r0'
08:46:17 <lambdabot>     Expected type: (a0 -> IO c0) -> (a0 -> m0 r0) -> m0 r0
08:46:17 <lambdabot>       Actual type: (a0 -> IO c0) -> IO c0
08:46:18 <quchen> Sounds compelling. I'll need some (lots) of time to think about using ContT though.
08:47:16 <Peaker> @type \ini fini -> ContT $ bracket ini fini
08:47:17 <lambdabot> IO a -> (a -> IO b) -> ContT r IO a
08:47:34 <Peaker> @type ContT $ bracket ?ini ?fini
08:47:35 <lambdabot> (?ini::IO a, ?fini::a -> IO b) => ContT r IO a
08:48:56 <Peaker> quchen: I remember thinking about Python's "with" statement equivalence with "bracket", and how in Python you can use "nested" (I think it's got a built-in syntax support now) -- and thinking what the equivalent to "nested" is, and it's just "sequence"!
08:49:10 <Denommus> hi
08:49:25 <quchen> Peaker: I don't know Python that well, but I think I understand the Haskell version anyway.
08:49:30 <Denommus> if I want to make a game (even if it is very simple), which libraries does Haskell provide?
08:49:36 <Denommus> I need, at least, graphics, sound and input
08:50:15 <quchen> Peaker: I often don't realize I'm using continuations, actually. bracket, withAsync, …
08:50:31 <Peaker> yeah, once you wrap them in the newtype, all the nice combinators are there
08:50:35 <quchen> And I'm nesting them quite often as well. ContT seems to be really useful.
08:51:25 <Peaker> if you wrap your brackets in ContT, you can replace:   withA $ \a -> withB $ \b -> withC $ \c -> ...     with:   do { a <- withA ; b <- withB ; c <- withC ; ... }
08:52:20 <quchen> :-D
08:52:46 <quchen> I wonder why I haven't seen (or been told) this before
08:52:55 <quchen> Looks almost idiomatic
08:53:46 <Fuuzetsu> Would you say it's… Haskellic?
08:53:49 <Peaker> I think ContT code usually doesn't do anything after the continuation is called. bracket is a weird ContT in that regard
08:54:59 <quchen> "ContT doesn't really do anything after the continuation is called"?
08:55:38 <quchen> Oh, you mean because the finalizer is run when the whole ContT finishes
08:59:21 <solirc> Fuuzetsu: Ok, just looked at it again.  Question is whether we to have H1s in the documentation of types and functions (as we probably already have some h1 there), or whether it makes sense to only provide e.g. provide 3 levels of headlines and then start at e.g. H3
08:59:37 <haasn> Denommus: you can get far with SDL bindings
08:59:43 <haasn> there are also OpenGL bindings but I can't comment on their quality
09:00:04 <haasn> for very simple games you can user higher level libraries like gloss
09:00:22 <solirc> say effectively having H3..H6 with =, ==, ===,
09:00:24 <solirc> or something
09:03:19 <klrr_> chrisdone: when i try to start hell using custome library i get this error "hell: attempting to use module `main:DotHellRC' (./DotHellRC.hs) which is not loaded", my Main.hs is like this https://gist.github.com/klrr/7603087 . any idea what might be wrong or is it a bug perhaps?
09:06:17 <chrisdone> klrr_: i think the module probably has to be installed somewhere. i don't (yet) know directly how to load in a file with the api
09:06:35 <klrr_> i did install it with cabal as a library
09:06:44 <chrisdone> the DotHellRC module?
09:06:45 <klrr_> the DotHellRC module
09:06:47 <klrr_> yeah
09:06:49 <chrisdone> hmm
09:07:13 <chrisdone> ah wait
09:07:24 <chrisdone> maybe it's because the file is in the same directory, so  it's trying to load it
09:07:29 <chrisdone> try running hell in a different dir
09:08:37 <klrr_> chrisdone: thanks! :)
09:08:45 <chrisdone> welcome :)
09:12:26 <roconnor> Is the term "monad natural transformation" the right term for that idea?
09:12:31 <edwardk> monochrom: ping
09:12:43 <edwardk> roconnor?
09:12:47 <edwardk> monad homomorphism?
09:13:05 <roconnor> edwardk: monad homomorphism is the better way to phrase that?
09:13:28 <edwardk> roconnor:  missed the part where 'the idea' was described
09:13:35 <roconnor> edwardk: i.e. a natural transformation that preserves return and join.
09:13:44 <edwardk> that's a monad homomorphism
09:13:47 <roconnor> thanks
09:15:32 <mangaba_leitosa> I can do a strict field with data Foo = Foo !Int, how do I do the same for a named field such as 'data Foo = Foo {a:: Int}' ?
09:16:01 <mangaba_leitosa> ah, just Foo {a:: !Int}
09:16:20 <mangaba_leitosa> for some reason it did not work the first way :_)
09:16:24 <mangaba_leitosa> the first time
09:16:32 <roconnor> hmm, lhs2tex seems unhappy with my use of \_ -> expr
09:17:04 * roconnor adds a space
09:19:17 <ocharles> If I have an indexed monad action 'm i j a', is there a standard way of discarding my final state?
09:19:29 <ocharles> presumably 'm i j a -> m i Void a' or something
09:19:52 <ocharles> I have a few different actions that start in the same state but end in different states, and I want to sum them under IMonadPlus
09:20:57 <roconnor> ocharles: it seems that () would be more appropriate than Void
09:21:12 <ocharles> Hmm, yes, () would work
09:21:24 <roconnor> Void would be more suitable for discarding the initial state.
09:21:30 <ocharles> right
09:21:35 <roconnor> ... maybe
09:21:39 <ocharles> I'm working with a free indexed monad, and can't see a nice way to change the state like that, without introducing a new layer in my functor
09:22:35 <roconnor> ocharles: put () :: m i () ()
09:22:35 <mr-> Oh.. what is an indexed monad?
09:23:04 <roconnor> mr-: you know how many monads are parameterized, like the state monad, reader monad, etc?
09:23:11 <mr-> yes
09:23:24 <mr-> it just generalizes that?
09:23:26 <roconnor> mr-: parameterized monads let the bind function change the type of the parameter
09:23:29 <joelteon> indexed monads are parameterized by their "input" and "output" type
09:23:48 <joelteon> so you can enforce an order on sequenced actions
09:23:56 <ocharles> roconnor: as in: put :: a -> m a a () ?
09:24:16 <roconnor> mr-: Robert Atkey has some nice theoretical papers on the topic if you like category theory.
09:24:22 <simpson> So are things like Conduit and Pipe also indexed monads?
09:24:24 <roconnor> ocharles: put :: a -> m b a ()
09:24:25 <mr-> roconnor: I do, thanks
09:24:29 <ocharles> and McBride if you want more practical
09:24:30 <ocharles> roconnor: right
09:24:50 <Sagi> if I have a func :: (Monad m) => a -> m Maybe a and replace a call by guard by (return . guard), will the function still short-circuit?
09:25:10 <ocharles> Though I think that might invalidate some other properties of this, so I might just use a special "Stop" layer
09:25:16 <ocharles> roconnor: tah for helping rubber duck this
09:25:19 <ocharles> ta*
09:25:37 <Sagi> I need to wrap an existing function in a reader monad, because I need some information contained theirin, but now it seems I have to jump through all kinds of hoops :-\
09:26:14 <Fuuzetsu> solirc: Well, regarding header levels, it's up to the user whether they want it up to H6. I don't care, I picked 6 because that's what HTML allows for (our main output). It's an arbitrary choice. Header type takes an Int anyway so in theory you could have as many or as little as you want. Regarding headers in things like constructor docs, I haven't thought of that. Practically I can't see anyone actually using these but theoretically I
09:26:14 <Fuuzetsu> don't see a reason not to. I admit that I haven't checked how it would look.
09:28:07 <Fuuzetsu> In lens, is making instances of Field1, Field2, FieldN … for things that aren't tuples discouraged? I gave Vertex3 (from OpenGL bindings package) instances up to Field3. Is there a different, more idiomatic solution?
09:28:49 <Fuuzetsu> I mean, I was going to create some arbitrary HasX, HasY… classes anyway so I might as well leverage on lens which achieves this already.
09:29:20 * hackagebot git-repair 1.20131122 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20131122 (JoeyHess)
09:33:20 <schell> chrisdone: congrats on HN this morning!
09:33:28 <supki> Fuuzetsu: I don't think it's discouraged
09:33:36 <supki> Fuuzetsu: Vertex3 is still a product anyway
09:33:53 <supki> HEAD even has a Generic support for FieldX instances
09:39:31 <chrisdone> schell: huh?
09:39:46 <chrisdone> oh, neat
09:39:56 <schell> oh - your...you saw
09:39:58 <schell> :)
09:42:44 <chrisdone> the comments seem kind of silly
09:43:40 <schell> i don't think they get it - and HN readers are typically pretty competitive
09:43:58 <FireFly> "you `import Hell` and ..." hmm, seems like a dangerous project
09:44:01 <schell> "oh you think that's cool? check out the one *I* did"
09:44:06 <chrisdone> no big deal, HN isn't the target audience
09:44:08 <schell> haha
09:44:40 <schell> chrisdone: i just think it's rad - someone liked it enough to post it and now it's on the front page, that's cool
09:44:47 <triliyn> chrisdone: what is this thing?
09:44:50 <schell> win
09:46:13 <chrisdone> triliyn: a shell. instead of running bash, you run hell. instead of bash script, you write haskell
09:46:51 <chrisdone> i think the brevity gains of bash are superficial
09:46:57 <triliyn> chrisdone: oh, that's pretty cool, but I meant what is the HN thing (unless they're the same?)
09:47:05 <kthl````> sometimes they so silly and void-critic on HN they should IMO left reading news on telnet..
09:47:09 <chrisdone> as soon as you want to do something out of the ordinary, your options are awk, or just scripting a perl or haskell script
09:47:50 <chrisdone> triliyn: HN is hacker news https://news.ycombinator.com/item?id=6780050
09:47:54 <Fuuzetsu> schell: Anyone and their dog can post anything to HN/reddit/<any other regurgitation website>, it doesn't mean anything
09:49:03 <Fuuzetsu> …which is why I personally look down on such sites
09:49:04 <schell> Fuuzetsu: true, maybe i'm easily impressed
09:49:24 <schell> Fuuzetsu: but not everything posted makes to the front page is all
09:50:43 <Fuuzetsu> schell: I don't know how HN exactly works but do you really want to judge a project based on whether a few people thought ‘hehe, nice’ and bothered to click ‘upvote’ without a second thought?
09:51:13 <schell> Fuuzetsu: i'm not judging the project, i'm just giving chris some props
09:51:15 <Fuuzetsu> Sadly, you could probably get to the front page with a semi-funny picture or something.
09:51:19 <schell> high-five
09:51:36 <Fuuzetsu> schell: Don't get me wrong, I love what chrisdone is doing here, I expressed it few hours ago!
09:58:26 <yorick> how do I go from a StateT a b c to a State a c using a b c -> a function?
09:58:48 <mangaba_leitosa> wow that's cool. 'do file <- openFile "jaa" ReadMode; content <- hGetContents file; print content' works, 'do file <- openFile "jaa" ReadMode; content <- hGetContents file; hClose file; print content' always prints an empty line :-)))
09:59:47 * mangaba_leitosa had an impression that the monad helps in sequencing the order of operations, such as "hGetContents; hClose" :-)
10:02:35 <triliyn> :t (>=>)
10:02:36 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:06:56 <yorick> I have a StateT LispEnv ThrowsError String    and an extractValue :: ThrowsError x -> x , and I want to get to a StateT LispEnv String , that should be doable, right?
10:10:21 <klugez> mangaba_leitosa: It does, but unfortunately that is lazy IO, so hGetContents does not actually do the IO, it just creates an unsafe value. When you evaluate it, the IO is performed.
10:11:13 <klugez> mangaba_leitosa: That's one reason some people consider lazy IO a bad idea. You can use System.IO.Strict from strict package to get the expected result.
10:11:22 <klugez> Or conduit/pipes/io-streams.
10:12:13 <mangaba_leitosa> klugez: but why hGetContents returns "" instead of undefined value?
10:12:27 <Fuuzetsu> Fans of lazy IO would say that it was the expected result.
10:12:58 <mangaba_leitosa> klugez: I can understand that 'content' gets evaluated after the file was closed so read operation cannot be done. But why "" ?
10:13:16 <mangaba_leitosa> klugez: why not error?
10:13:26 <vpm> mangaba_leitosa : I guess that it's because of that: "Once a semi-closed handle becomes closed, the contents of the associated list becomes fixed. The contents of this final list is only partially specified: it will contain at least all the items of the stream that were evaluated prior to the handle becoming closed." http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#v:hGetContents
10:14:18 <mangaba_leitosa> vpm: haha. Thanks :-) So, it's oppurtunistic I/O. If it works, good, if not, no problem :-)
10:14:22 <FreeFull> Something like pipes is much more reasonable
10:15:28 <yorick> I tried doing liftM extractvalue, but that would transform a StateT LispEnv ThrowsError (ThrowsError r0) into a StateT LispEnv ThrowsError r0 , and that's not exactly what I want
10:16:05 <mangaba_leitosa> klugez: but what if I want to get the expected result, yet want to this code to work even if content does not fit to RAM. Will it work with System.IO.Strict?
10:17:09 <mangaba_leitosa> klugez: because with hGetContent being lazy, it does not try to read everything to memory at once...
10:17:36 <klugez> mangaba_leitosa: No, then you will need conduit/pipes/io-streams or do chunking the same way it would be done in other languages.
10:18:01 <klugez> mangaba_leitosa: That's true and that's why people occasionally put up with lazy IO despite the surprises. :)
10:18:42 <mangaba_leitosa> klugez: aha, so, System.IO.Strict is not such a great idea... BTW, I tried evaluating 'head content' before hClose, and then print content works even after hClose
10:19:41 <klugez> mangaba_leitosa: For a small enough file. For the one that doesn't fit in RAM, it wouldn't give the whole content. Just the part that it happened to read.
10:20:08 <mangaba_leitosa> klugez: I see, thanks
10:23:38 <yorick> there should be something willing to work on a StateT LispEnv ThrowsError x to turn it into a StateT LispEnv Identity x, right? my latest attempt is liftM (Identity . extractValue) , but that still expects a StateT LispEnv ThrowsError (ThrowsError x) which is really not what I want
10:27:28 <triliyn> yorick: you can't do it monadically, because the entire "StateT LispEnv ThrowsError" is the monad and monadic operations can't change the monad
10:27:42 <yorick> triliyn: hm, you're right
10:28:48 <yorick> triliyn: so how will I do it?
10:29:44 <mangaba_leitosa> vpm: I reread the description of hGetContents. It seems that even there is no issue with hClose (placed after print content), there can be an I/O error when reading the file and I won't have any idea about it?
10:29:45 <triliyn> yorick: the only thing I can think of right now is to manually use runLispEnv and extractValue and then wrap it in Identity and StateT
10:29:51 <triliyn> There might be a better way but I'm not sure
10:30:23 <yorick> triliyn: I've been trying extractStateValue (StateT s (Right val)) = StateT s (Identity val) but pattern matching StateT does not seem to work
10:30:33 <mangaba_leitosa> " I/O errors encountered while a handle is semi-closed are simply discarded"
10:31:26 <yorick> oh, right, StateT has this weird function thing
10:31:52 <triliyn> yorick: right, you need to pass it an initial state
10:32:04 <Rylee> Does the current lambdabot work with GHC 7.x?
10:32:57 <Fuuzetsu> Rylee: I compiled it on 7.6.3 not that long ago.
10:33:06 <Rarrikins> Rylee: The one here does.
10:33:10 <mangaba_leitosa> klugez: could you comment on this? Is it safe to use hGetContents at all? Is it true that it doesn't check for any I/O errors except for EOF?
10:33:21 <Rylee> kay
10:34:02 <geekosaur> it is true
10:34:20 <geekosaur> because your interface to it is a pure String, so there is no way to detect or catch exceptions
10:34:33 <kqr> is there a list of the most common language extensions somewhere together with their level of harmlessness?
10:34:34 <geekosaur> so all it can do on I/O error is act like it hit EOF
10:35:20 <kqr> i read all the time that "extension X is harmless so you should just enable it" but when I'm about to decide whether or not to enable an extension I can't remember the Xs I've read about
10:35:31 <supki> kqr: http://stackoverflow.com/a/10849782/972985
10:35:46 <kqr> supki, brilliant. bookmarked
10:36:01 <Fuuzetsu> supki: SQL comprehensions? What is this magic? I've never heard of this.
10:36:13 <mangaba_leitosa> geekosaur: but on EOF, an exception is thrown. What's the problem with doing the same for other errors?
10:36:16 <adnap> Does anyone know a good way to write games that run in a web browser with Haskell?
10:36:37 <geekosaur> no, EOF is not an exception
10:36:43 <Fuuzetsu> adnap: AFAIK you can compile to JavaScript. Somehow.
10:36:44 <geekosaur> this is not python
10:36:49 <yorick> triliyn: extractStateValue (StateT f) = StateT (Identity . extractValue . f) seems to work, thanks!
10:37:02 <Fuuzetsu> adnap: ping haasn, IIRC he's done something simple with this
10:37:24 <adnap> Fuuzetsu: Yes, I saw there are lots of Haskell to JavaScript compilers
10:37:28 <adnap> http://www.haskell.org/haskellwiki/The_JavaScript_Problem
10:37:42 <Fuuzetsu> Does such solution not satisfy you then?
10:37:43 <mangaba_leitosa> geekosaur: I tried this: "do file <- openFile "jaa" ReadMode; content <- hGetContents file; hGetContents file" and got "*** Exception: jaa: hGetContents: illegal operation (handle is closed)". This is kind of expected behaviour
10:38:07 <geekosaur> yes, but that is not EOF, that is after you do hGetContents on a handle it is marked as closed
10:38:11 <mangaba_leitosa> geekosaur: won't I get a similar behaviour when hGetContents file because of a broken HDD?
10:38:16 <geekosaur> so if you do hGetContents on it again you get an exception
10:38:16 <adnap> Fuuzetsu: I just don't know what is the best
10:38:20 <mangaba_leitosa> geekosaur: "when hGetContents fails"
10:38:27 <geekosaur> no
10:38:39 <geekosaur> because that handle is closed exception is thrown in IO
10:38:40 <Fuuzetsu> I don't think there's an unquestionably best way to do this.
10:38:42 <adnap> Fuuzetsu: And I would prefer a higher level drawing API
10:38:51 <geekosaur> but an I/O exception thrown while you're using content is in *pure code*
10:38:53 <geekosaur> not in IO
10:38:55 <kartoffelbrei> adnap: threepennygui?
10:39:05 <adnap> kartoffelbrei: Isn't that for UI stuff?
10:39:12 <adnap> I'm trying to write a game
10:39:22 <geekosaur> (you may be using it under IO, but there is no guarantee of it, and since it looks pure it must be treated as pure even if it's pure code being evaluated in an IO somewhere)
10:39:31 <mangaba_leitosa> geekosaur: sure... But when still within the IO 'do' sequence, how can I detect I/O errors?
10:39:40 <geekosaur> use a non-lazy interface
10:39:47 <geekosaur> the lazy one does not throw exceptions
10:40:02 <geekosaur> because the lazy one only gives you a pure-looking interface
10:40:14 <kartoffelbrei> adnap: http://www.haskell.org/haskellwiki/Threepenny-gui#Gallery some of the examples look pretty "game-y" to me
10:41:04 <Fuuzetsu> Spawn 3 buttons. Guess which one is the right one to press. We game now!
10:41:43 <mangaba_leitosa> geekosaur: but lazy is convenient (at least I thought it was up to this moment) for working with large files. It means that using this convenience encourages writing unsafe code that will be not aware of I/O errors? Then Lazy I/O must be considered harmful and advised against?
10:41:44 <adnap> kartoffelbrei: They look a bit static... I want to write something where things move around in real time
10:41:53 <adnap> kartoffelbrei: I'll keep reading and see if it will work
10:42:19 <geekosaur> mangaba_leitosa, yes it is convenient and unsafe and a number of us do recommend against using it for serious programs
10:42:30 <geekosaur> unfortunately all the alternatives are more painful :(
10:42:39 <mangaba_leitosa> geekosaur: that's truely sad :-(
10:42:54 <kartoffelbrei> adnap: yeah, it might not be what you want...
10:43:36 <mangaba_leitosa> geekosaur: shouldn't it be banned/depcecated entirely ?
10:44:00 <geekosaur> no
10:44:18 <mangaba_leitosa> geekosaur: but why? If any code using it is unsafe ? :-)
10:44:24 <geekosaur> this btw is an argument that has been hashed out in channel and on the haskell-cafe mailing list many times. I suggest you go read archives
10:44:44 <mangaba_leitosa> geekosaur: thanks
10:46:39 <mangaba_leitosa> So, doing I/O in Haskell is either unsafe or painful...
10:46:40 <geekosaur> also it's the main reason people are playing with conduit and pipes (intended to provide lazy I/O with exception safety)
10:47:17 <mangaba_leitosa> aha, then I must read about it
10:47:31 <geekosaur> but as they're both still fairly new they are both still somewhat painful to work with; I expect them (or whichever one "wins") to become easier to use as it settles down, but both of them are still changing their internals around with some regularity
10:49:24 <mangaba_leitosa> I admired learning Haskell up to this point. Now I'm learning that it's not ready for real life use :-(
10:50:01 <osa1_> can anyone point me some papers/articles/books about compiling pattern matching?
10:50:22 <thebnq> mangaba_leitosa: what, not ready for real life? how so?
10:50:37 <mangaba_leitosa> thebnq: geekosaur says that doing I/O is either unsafe or painful
10:50:37 <adnap> mangaba_leitosa: Doing IO in Haskell is not less safe than doing IO in an imperative language, and it is not more painful
10:50:53 <dwcook> If I could remember how to trigger that quote about how Haskell is "only used" in certain things, I would right now
10:50:58 <mangaba_leitosa> thebnq: at leat it's how I interpret these words
10:51:05 <geekosaur> thebnq, mangaba_leitosa just discovered that lazy I/O can't tell you about I/O exceptions
10:51:11 <quchen> I think geekosaur is exaggerating a bit. I wouldn't call pipes "painful", especially compared to lazy IO.
10:51:20 <tabemann> just remember doing IO in an imperative languages is *always* unsafe
10:51:25 <FireFly> @faq is haskell ready for real life use?
10:51:25 <lambdabot> The answer is: Yes! Haskell can do that.
10:51:25 <geekosaur> @quote academia
10:51:26 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
10:51:26 <lambdabot> s, phone apps, and web services.
10:51:26 <lasticot> Should I take a hint from the conflict between the State monad and the State defined in the parsing modules? Or is just an unfortunate naming conflict and is separating the two in different files the only way of resolving?
10:51:37 <dwcook> geekosaur, awesome, yes
10:51:49 <klugez> mangaba_leitosa: Note that you still have all the same tools like for example C has. Is C ready for real life use?
10:52:10 <klugez> mangaba_leitosa: Lazy IO is just a few functions in a library. (Albeit a standard one.)
10:52:18 <dwcook> Haskell is Turing complete, so close enough
10:52:43 <quchen> Turing completeness is overrated.
10:52:58 <mangaba_leitosa> tabemann, klugez: let's compare Haskell to ocaml, with which I have more real life experience. I/O errors in ocaml generate exception, and using I/O in ocaml is not paintful. Is it unsafe then?
10:53:18 <dwcook> Actually Haskell might be "more" Turing complete than C by way of not specifying machine-level things
10:53:19 <mangaba_leitosa> s/paintful/painful/
10:53:25 <dwcook> quchen, an Agda fan?
10:53:38 <tabemann> mangaba_leitosa: it is unsafe in that it isn't pure
10:54:04 <Javran> hi there, I'm just wondering that can I say Reader is a special case of State? because IMHO we can keep an env in state and do queries or modifications just like Reader.
10:54:39 <quchen> dwcook: Haven't used it, but I think it could be neat. Anyway, I think Mauke proved that C isn't turing-complete at some point. Which illustrates fairly well that it should be treated as a mathematical, not practical, concept.
10:54:41 <mangaba_leitosa> tabemann: but not noticing I/O errors in when doing pure I/O is much more unsafe, in my opinion. It's just a disaster
10:54:45 <klugez> mangaba_leitosa: http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html - If you look in here, there's a lot functions. Most of them will throw exceptions.
10:55:11 <tabemann> mangaba_leitosa: solution - don't use lazy IO
10:55:15 <dwcook> quchen, yeah, I was being facetious when I said that anyway. I thought the telltale sign of that was that the exact same argument would apply to Brainfuck. :)
10:55:18 <klugez> There's a few lazy IO things that won't and as geekosaur said they are targets of frequent arguments.
10:55:33 <quchen> dwcook: Nonononoonono. :-)
10:55:42 <FireFly> mangaba_leitosa: I guess it depends on how you define 'safety'
10:55:52 <quchen> I think the rationale behind it was something along the lines "C demands every memory block to be addressable, and pointers have to be of finite size. Therefore there are algorithms that need more memory than any specific implementation can provide.
10:55:57 <quchen> "
10:56:20 <FireFly> mangaba_leitosa: it's safer in the sense that you have to handle the error somehow, and it's not that painful once you're used to it (I think, anyway)
10:56:23 <mangaba_leitosa> klugez: So far, I was just using readFile and print in my programs, and that was enough. But I didn't know it was unsafe. If I switch to System.IO.Strict, will I be safe with readFile?
10:56:27 <dwcook> quchen, yeah, I was aware of that argument when I said "Actually Haskell might be 'more' Turing complete than C".
10:56:30 <geekosaur> mangaba_leitosa, another thing to consider is that I'm a sysadmin by trade; I tend to want reliability by default
10:56:47 <quchen> dwcook: Oh, I missed it when you said that
10:56:48 <geekosaur> haskell lazy I/O is no different from your typical C program that doesn't check the return value from printf()
10:57:15 <intrados> Is there a cleverer way to subtract a number from a list of numbers? http://lpaste.net/96021
10:57:17 <mangaba_leitosa> geekosaur: I would also hate the idea of writing unsafe code when there is an easy way to avoid that. That's why I prefer Haskell to C :-)
10:57:34 <dwcook> intrados, you want simpler, not cleverer
10:57:43 <cizra> intrados: map (-10) [1..]
10:57:45 <dwcook> > map (subtract 10) [1, 2, 3, 50]
10:57:46 <lambdabot>   [-9,-8,-7,40]
10:57:52 <quchen> > (subtract 3) [1..10] -- intrados
10:57:53 <lambdabot>   No instance for (GHC.Show.Show t0)
10:57:54 <lambdabot>    arising from a use of `M5795162600130...
10:57:55 <quchen> Woops.
10:57:56 <geekosaur> cizra, that won't work
10:57:58 <quchen> What dwcook said.
10:58:13 <geekosaur> because numeric literals "stole" that section
10:58:23 <cizra> geekosaur: Why not?
10:58:30 <klugez> I'm not sure. It will read all of the file at that point, but not sure about exceptions.
10:58:30 <cizra> > map (-10) [1..5]
10:58:31 <geekosaur> :t (-10)
10:58:31 <thebnq> you could map (+(-10)) if subutract is too long :)
10:58:32 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
10:58:32 <lambdabot>    arising f...
10:58:32 <lambdabot> Num a => a
10:58:40 <geekosaur> notice its type
10:58:47 <FireFly> cizra: (-10) == 0 - 10
10:58:51 <geekosaur> (-10) is not a section on (-), it is unary minus
10:58:52 <mangaba_leitosa> FireFly: right, but unlike C, for example, where an I/O error can get unnoticed, in ocaml, I will notice the error even if I don't handle them: the program will just abort on I/O exception
10:59:04 <quchen> cizra: https://github.com/quchen/articles/blob/master/fbut.md#--4-is-not-x---x---4
10:59:10 <cizra> Ah, hah, I understand now.
10:59:27 <cizra> > map (\x -> x - 10) [1..5]
10:59:27 <tromp__> intrados: shldnt it be otherwise = x : minus xs (c - x)  ?
10:59:28 <klugez> mangaba_leitosa: You can look at for example https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview to get both ability to read larger than RAM files safely.
10:59:29 <lambdabot>   [-9,-8,-7,-6,-5]
10:59:35 <mangaba_leitosa> FireFly: and I was naive enough to assume this was true for Haskell as well :_)
10:59:39 <geekosaur> which is why we have subtract
10:59:41 <simpson> @tell edwardk lens depends on mtl. It also depends on MonadCatchIO-transformers, which depends on monads-tf. Could we switch that to be a dependency on exceptions instead? I'll do the hacking if you're okay with it.
10:59:41 <lambdabot> Consider it noted.
10:59:42 <tromp__> oops, ignore that
10:59:54 <mangaba_leitosa> klugez: thanks!
11:00:13 <supki> simpson: HEAD switched to exceptions long ago
11:00:31 <simpson> supki: Oh. Well, 3.10 on Hackage is still not using exceptions. :c
11:00:35 <tromp__> i'd call it deplete rather than minus though...
11:00:45 <adnap> It seems like UHC is currently the best Haskell to Javascript compiler, but GHCJS is poised to be the standard as they are trying to integrate it into GHC
11:01:02 <mangaba_leitosa> klugez: and answering your question about C, no, C is not ready for real life use. Ocaml is :-)
11:01:12 <Javran> .could someone answer my question?
11:01:17 <mangaba_leitosa> klugez: C is much like assembly language :-0
11:01:31 <intrados> tromp__: Yeah. Deplete is probably a better term. So all the `map subtracts` aren't actually doing the same thing
11:01:46 <geekosaur> Javran, not quite
11:02:05 <tromp__> also, reverse argument order
11:02:06 <geekosaur> if you look at the interface for Reader, it just looks like a read only version of State
11:02:11 <geekosaur> but it's more than that in reality
11:02:19 <geekosaur> Reader is the monad over functions with a parameter
11:02:21 <tromp__> which makes deplete n a list transformer
11:03:16 <mangaba_leitosa> klugez: for example, mozilla/firefox, written in C/C++, only stopped aborting with coredump about 10 years after its first release :_)
11:03:33 <Javran> geekosaur: but isn't that a "local" that can change contents of Reader?
11:03:46 <intrados> tromp__: Is that generally the preferred parameter order for such things? `a -> b -> b`?
11:03:48 <geekosaur> it doesn't change the contents
11:03:52 <mangaba_leitosa> klugez: I notice that in the last 5 years, firefox doesn't crash every week anymore :-)
11:03:52 <lambdabot> That's Numberwang!
11:04:14 <geekosaur> it runs something inside a local modification. that modification goes away when the expression it runs does
11:04:21 <intrados> tromp__: But can you think of a way to avoid primitive recursion? (I know I can also do it with a fold but that doesn't seem any clearer)
11:04:23 <geekosaur> (it is not assignment)
11:04:31 <supki> simpson: yeah, 3.10 was a maintenance release
11:04:41 <geekosaur> local is the equivalent of let ... in
11:05:07 <geekosaur> the things in the ... are only "known" inside the expression following `in`
11:05:28 <geekosaur> likewise, `local` makes a change that is only visible in the single expression you run within it
11:05:36 <klugez> mangaba_leitosa: Well, the point was that the same kind of manual buffering as in C programs can be done with Haskell IO as well. It's just not convenient. I'm not familiar with how OCaml does things.
11:05:41 <adnap> > (+) <$> (+ 24) <*> (* 5) $ 3
11:05:42 <lambdabot>   42
11:05:57 <tromp__> avoiding recursion seems counterproductive here
11:06:15 <tromp__> reversing args makes partial applicatoin more sensible
11:06:26 <tromp__> regardless of type signature
11:06:39 <Javran> geekosaur: ok, so it works just like keeping `let x = ... in let x = ... in ...` where we use `x` inside as if it was changed?
11:06:40 <geekosaur> whereas `put` or `modify` changes the state
11:06:59 <geekosaur> for all following expressions
11:07:54 <Javran> geekosaur: I just managed to implement function memoization using State monad, and I thought maybe Reader can do the same thing..
11:09:35 <lasticot> Is there an other way to resolve the conflict between the declaration of State from the state monad and the from the parser module?
11:09:51 <lasticot> Than dealing with them in 2 different files?
11:09:51 <geekosaur> use them qualified?
11:10:06 <geekosaur> import qualified Control.Monad.State as S
11:10:18 <geekosaur> now State is the parser one and S.State is the monad
11:10:28 <Javran> geekosaur: fine, so now I know why Reader is named reader. thanks.
11:10:40 <lasticot> geekosaur: thank you that's exactly what i was looking for
11:11:13 <Rylee> What dark magic do I have to work to make @src work on a lambdabot instance?
11:14:38 <mangaba_leitosa> klugez: sure... I had to do manual buffering in ocaml as well... I just can't get one can gain from 'automatic' buffering done by lazy I/O if it's unsafe :-) But geekosaur already mentioned that I must study haskell cafe archives to get the answer :-)
11:14:58 <mangaba_leitosa> klugez: "I just can't get how one cain gain"
11:15:12 <mangaba_leitosa> oops, my typing is bad
11:15:32 <evancz> does anyone know how portable the sundown library is? (bindings to a C markdown parser)
11:16:24 <evancz> i am having trouble on OSX 10.9, which is not super surprising, but I'm curious about other platforms
11:17:23 <mangaba_leitosa> klugez: that is, my question is, knowing about unsafety of hGetContent, can I use this knowledge to somehow use it safely?
11:18:16 <klrr_> out of curiosity, may i ask if you are the author of elm evancz ?
11:20:59 <Dtgr> why does not postgresql-simple have documentation available on hackage? :o
11:21:06 <evancz> klrr_: I am :)
11:21:07 <Dtgr> http://hackage.haskell.org/package/postgresql-simple-0.3.9.1/docs/Database-PostgreSQL-Simple.html
11:21:52 <klugez> mangaba_leitosa: You can use (or opt to not use) it knowing its limitations. :)
11:23:33 <evancz> klrr_: the dependency on pandoc is pretty huge, so I am looking for ways to move to something smaller to keep install times down
11:25:10 <mangaba_leitosa> klugez: but when I'm still in the I/O monad, can I perform any additional checks to find out there were any I/O errors when hGetContent or any other I/O operation failed right before the program exits?
11:25:30 <klugez> evancz: Have you looked at this http://hackage.haskell.org/package/markdown?
11:25:38 <klugez> mangaba_leitosa: Not that I know of.
11:25:49 <mangaba_leitosa> klugez: I see
11:26:17 <mauke> quchen: but C provides the standard tmpfile() function, which creates unbounded self-resizing dynamic arrays
11:27:11 <quchen> mauke: Ah, so it's complete again?
11:27:30 <mauke> theoretically, in a hosted implementation
11:27:51 <mauke> but our universe has a finite size anyway
11:28:00 <quchen> Well, we're on the semantic level here anyway
11:28:09 <quchen> Implementations come later
11:28:10 <evancz> klugez: yeah, but it seems much less straight forward
11:28:25 <evancz> and has more dependencies
11:28:42 <evancz> if sundown is not portable, it is probably the best alternative though
11:30:06 <evancz> bah, just saw that sundown is going away
11:30:12 <evancz> https://github.com/vmg/sundown/blob/master/CONTRIBUTING.md
11:33:15 <klrr_> evancz: aa cool :) elm is a really cool project
11:33:45 <evancz> klrr_: thank you! :D
11:35:10 <mangaba_leitosa> evancz: what's the best introduction to FRP, besides just starting to learn Elm?
11:35:43 <adnap> mangaba_leitosa: I started with reactive-banana, and I just read through examples
11:36:15 <adnap> mangaba_leitosa: These: http://www.haskell.org/haskellwiki/Reactive-banana/Examples
11:36:19 <evancz> mangaba_leitosa: why is starting to learn Elm off the table?
11:36:40 <mangaba_leitosa> adnap: thanks
11:36:57 <evancz> one of the big goals of the project is to make learning really easy
11:37:07 <mangaba_leitosa> evancz: now, I want to understand the concepts first in order to learn Elm and other FRP-based GUIs easier :-)
11:37:57 <evancz> this paper gives an overview of the concepts if you prefer to start with thoery: http://www.testblogpleaseignore.com/wp-content/uploads/2012/04/thesis.pdf
11:38:11 <evancz> one goal of that was to summarize all of the previous work on FRP
11:38:14 <mangaba_leitosa> adnap: I also saw grapefruit and yampa and articles about it, so unsure of where to start ::-)
11:38:17 <Hodapp> omnomnom papers!
11:38:20 * Hodapp downloads ravenously
11:38:43 <evancz> I tend to be someone who learns from example, so I typically recommend http://elm-lang.org/Examples.elm
11:38:43 <adnap> mangaba_leitosa: The concepts are: the denotation of Behavior a is (t -> a) and the denotation of Event a is [(t, a)]
11:39:01 <evancz> Hodapp: there's this one too: http://people.seas.harvard.edu/~chong/abstracts/CzaplickiC13.html :)
11:39:11 <evancz> that one is the more academic version of the other paper
11:39:25 <evancz> so if you want less literature review and jokes, that's the way to go
11:39:28 <adnap> mangaba_leitosa: FRP gives you events and behaviors, where events are values at points in time, and behaviors are functions of time
11:39:29 * Hodapp . o O ( is evancz trying to kill me? )
11:39:41 <evancz> lol :)
11:39:50 <Hodapp> we seem to have plenty of FRP folks in here!
11:40:00 <evancz> adnap: certain formulations use events and behaviors
11:40:10 <evancz> Arrowized FRP does not, Elm does not
11:40:15 <adnap> evancz: The original by conal
11:40:50 <adnap> I think netwire, which is arrowized FRP, has events and behaviors
11:41:06 <evancz> that's true, but his coauthor Paul Hudak went on to work on formulations without
11:41:10 <mangaba_leitosa> evancz: aha, thanks :-) and if I want to learn about yampa and Elm, which order would you recommend? :-)
11:41:16 <jle`> in repa, does fusion end as soon as you go from delayed to non-delayed/unboxed/unboxed?
11:41:30 <jle`> or can it fuse operations that involve a transition between delayed/non-delayed
11:41:33 <jle`> and back again
11:41:37 <evancz> mangaba_leitosa: I think yampa is hard
11:41:39 <adnap> I prefer the original FRP because it is simpler
11:42:07 <evancz> Elm's FRP is very simple, and I think from there, you can pick up other libraries much more easily
11:42:22 <mangaba_leitosa> evancz: great :-)
11:42:39 <evancz> Elm's Automaton library (http://docs.elm-lang.org/library/Automaton.elm) is a simple version of Arrowized FRP
11:42:46 <evancz> which is the basis of netwire and yampa
11:43:00 <adnap> Can I use any package on Hackage with lambdabot?
11:43:13 <evancz> Automaton is not as expressive, but it is a good starting point for figuring what the hell is going on in other Arrowized FRP libs :)
11:43:20 <mangaba_leitosa> evancz: is it automaton as in 'finite-state automaton' or?...
11:43:48 <maurer> Is there a way to get something like an Enum instance that is valid for all of the nullary constructors?
11:43:48 <evancz> that's  the analogy I wanted :) It's fairly similar, but not necissarily finite
11:44:00 <maurer> I'm trying to update the 'elf' package to be able to render out to bytestrings as well
11:44:02 <adnap> I was able to understand http://hub.darcs.net/ertes/netwire after getting comfortable with reactive-banana, but the API seems more complicated and not finalized
11:44:14 <maurer> and don't want to manually write the inverse of all of his functions mapping from numbers to internal structures
11:44:15 <evancz> an Automaton takes in inputs and spits stuff out
11:44:20 <evancz> it may have some state inside though
11:44:31 <evancz> this is the key concept of all Arrowized FRP libraries
11:44:39 <evancz> netwire and yampa are this way
11:44:43 <evancz> with crazier types
11:44:55 <mangaba_leitosa> evancz: I also heard about the term 'reactive transducer' and wonder if it has to do with FRP, finite-state automata, both or none. Are you familiar with this term?
11:44:56 <evancz> sorry, more exciting types :P
11:45:11 <evancz> It rings a very vague bell
11:45:22 <evancz> I remember transducers from a natural language processing class
11:45:28 <evancz> but never with reactive in front of it
11:46:32 <mangaba_leitosa> evancz: right, I know about finite-state transducers, which are like finite-state automata generating output, but in the docs about a natural language processing library in ocaml, I also stumbled upon reactive transducers
11:46:38 <jle`> would my knowledge of transducers from my electrical engineering classes be helpful
11:47:04 <adnap> The example "sum (V2 1 2)" found http://hackage.haskell.org/package/linear-1.3.1/docs/Linear-V2.html does not work for me in GHCI
11:47:26 <evancz> mangaba_leitosa: that sounds suspiciously similar :)
11:47:42 <jle`> adnap: does it give the wrong answer?
11:47:56 <evancz> if you start chaining transducers, I can imagine you get something similar to AFRP
11:48:06 <enthropy> adnap: you might have to use Data.Foldable.sum instead of the Prelude.sum
11:48:07 <adnap> jle`: It doesn't typecheck and GHCI thinks I'm using (Num a) => [a] -> a
11:48:26 <evancz> mangaba_leitosa: We had a discussion recently about different goals of FRP (https://groups.google.com/forum/#!msg/elm-discuss/LI4673F3ZjI/P1wHIMCZM8EJ) so that might be helpful too
11:48:45 <evancz> it's written assuming more background though :)
11:48:45 <mangaba_leitosa> evancz: it's this library http://sanskrit.inria.fr/ZEN/. I'm still going to look at it in more detail.
11:48:49 <mangaba_leitosa> evancz: thanks! :-)
11:48:55 <adnap> evancz: Okay, that worked. I didn't know about Data.Foldable.sum
11:51:01 <evancz> adnap: was that a netwire example?
11:51:04 <chrisblake> chrisdone: hey, just in case you didn't know this, hell made front page HN: https://news.ycombinator.com/item?id=6780050 :)
11:51:08 <evancz> I am not a great expert on that library
11:51:17 <mangaba_leitosa> evancz: I encountered that 'reactive programming in scala' class on coursera and even learned scala to join the course, but then it turned out that it does not teach FRP :-O
11:51:43 <adnap> evancz: By "that", do you mean "sum (V2 1 2)"? If so, no, it's an example from the linear (algebra) package
11:51:45 <evancz> mangaba_leitosa, I don't think there are authoritative resources yet :)
11:52:09 <jle`> adnap: you are using Data.List.sum, which is imported from Prelude
11:52:21 <evancz> adnap: okay, I thought so. I was confused why you mentioned me about sum :)
11:52:21 <jle`> you have to either hide prelude or import linear into a namespace/as qualified
11:52:21 <mangaba_leitosa> evancz: so, I unenrolled and want an Elm class now :-)
11:52:23 <adnap> jle`: Yes, I already figured that out
11:52:35 <chrisblake> chrisdone: oh, you commented there already. nevermind!
11:52:37 <mangaba_leitosa> evancz: aren't you going to organize a MOOC? :-)
11:52:53 <danharaj> @pl (\f x y z -> f y z x)
11:52:53 <lambdabot> flip . (flip .)
11:52:54 <evancz> haha, I'd like to do one :)
11:53:13 <evancz> I think for now that's not top priority though
11:53:20 <evancz> biggest goals are making it easier to share libraries
11:53:22 <chrisblake> evancz: thank you for making elm. it's awesome :)
11:53:31 <mangaba_leitosa> I see :-)
11:53:31 <evancz> aww, thank you! :D
11:54:01 <chrisblake> markdown quasiquoter and friends were a fantastic idea (so was switching :: and : IMO)
11:54:18 <joelteon> I want a markdown quasiquoter
11:54:30 <joelteon> well no, I want to write one, I don't think I'd ever use it
11:54:45 <evancz> chrisblake: thanks :) I actually visited #haskell today to improve the markdown parser
11:54:51 <klrr_> evancz: are you aware of helm btw? it's elm in haskell :)
11:55:02 <mangaba_leitosa> evancz: you don't visit #elm, do you?
11:55:07 <adnap> Does elm use the canvas element?
11:55:08 <evancz> klrr_: yeah, I saw the announcement on reddit
11:55:24 <klrr_> but without the awesome record syntax :(
11:55:24 <evancz> adnap: for certain parts of the collage API
11:55:31 <adnap> And does it use some kind of Haskell to Javascript compiler?
11:55:58 <evancz> mangaba_leitosa: no, I try to keep off of IRC because I get stuck :)
11:56:07 <evancz> speaking of, I am flying home for thanksgiving today
11:56:07 <adnap> I was just asking about an hour ago what I should use to make an game that runs in the web browser in Haskell
11:56:09 <chrisblake> joelteon: super random, but why did you remove your blog code from github?
11:56:15 <evancz> so I need to get moving :)
11:56:20 <chrisblake> joelteon: I was hoping to learn from another yesod codebase.
11:56:32 <joelteon> well, i made it private because config/postgresql.yml was in there and all of a sudden i started needing it
11:56:37 <chrisblake> your "noLayout" function was really helpful to me, but I had to get it from the googe caches
11:56:43 <evancz> adnap: Elm is really nice for that :)
11:56:44 <chrisblake> well that makes sense
11:56:45 <joelteon> was supposed to be a temporary measure till i figured out what to do with the db config
11:56:46 <adnap> I thought I would use UHC, but maybe I can use Elm
11:56:58 <joelteon> I used to allow all local unix socket connections but
11:57:02 <evancz> Let me find a few articles on that really quick :)
11:57:03 <adnap> I first found this: http://jshaskell.blogspot.com/
11:57:11 <joelteon> anyway, I think I might just purge config/postgresql.yml and make it public again
11:57:14 <joelteon> sec
11:57:31 <evancz> adnap: https://github.com/Dobiasd/Breakout#breakout--play-it
11:57:40 <adnap> The person makes a game using UHC, writing javascript bindings to Haskell and using the canvas element
11:57:43 <evancz> See the "making of article"
11:58:03 <evancz> http://elm-lang.org/blog/games-in-elm/part-0/Making-Pong.html
11:58:19 <evancz> http://elm-lang.org/edit/examples/Intermediate/Mario.elm
11:58:20 <adnap> The person also uses netwire
11:58:31 <evancz> the mario one is my favorite :)
11:58:35 <klrr_> i hope they make a extension to support elm record syntax :)
11:58:55 <adnap> evancz: So, if I make a game with Elm, can I just embed a canvas element in a page and have everything work?
11:59:06 <evancz> adnap: yes!
11:59:06 <adnap> I mean, is it "standalone"?
11:59:09 <evancz> one second
11:59:24 <evancz> https://github.com/evancz/elm-html-and-js#htmljs-integration--live-demo
11:59:29 <adnap> Okay, it sounds perfect then
11:59:42 <evancz> that's an example of embedding the whole Elm program in an arbitrary HTML page
11:59:51 <adnap> evancz: What Haskell to Javascript compiler do you use?
11:59:56 <Hodapp> I played with Elm a little bit, but by 'a little bit', I probably mean 'less than 45 seconds'
12:00:01 <Hodapp> I need to read those papers
12:00:03 <evancz> adnap: I don't
12:00:14 <evancz> the Elm compiler goes from Elm source to JS
12:00:20 <adnap> Okay
12:00:30 <evancz> the compiler is in Haskell
12:00:36 <adnap> Is Elm a DSL in Haskell?
12:00:41 <joelteon> chrisblake: I'm cleaning the repo right now, should be up soon
12:00:46 <evancz> no, it's a separate language
12:00:49 <joelteon> sorry, I didn't think anyone was relying on it
12:00:50 <adnap> Can I use any other Haskell packages I want with Elm?
12:00:52 <adnap> Oh...
12:01:02 <adnap> I don't like that
12:01:17 <evancz> This means I can choose semantics that are best suited for graphics and FRP
12:01:23 <chrisblake> joelteon: awesome :D my main concern was trying to get a script to run at startup that would generate blog post metadata and then insert it into a db.
12:01:24 <evancz> this is why the records are nicer
12:01:32 <adnap> But then I can't use packages like linear to do linear algebra
12:01:45 <adnap> Or add anything onto Elm using Haskell
12:01:50 <chrisblake> I needed something like Handler Html -> IO (), but I couldn't find it. I had to end up putting the bootstrap code at a secret url, which sucks.
12:01:55 <klrr_> it's like a modern haskell with FRP "built-in"
12:02:05 <chrisblake> nested records are really really awesome
12:02:11 <evancz> http://www.testblogpleaseignore.com/2012/06/21/why-elm/
12:02:15 <thebnq> maybe we need to make a haskell to elm compiler then :}
12:02:42 <adnap> I doubt Elm is a better language than Haskell. It sounds like a restricted (on purpose) language
12:02:47 <joelteon> I'm going to need to do something else about deployment
12:02:58 <evancz> lol
12:03:01 <joelteon> this is definitely the worst bit about using compiled languages
12:03:03 <evancz> give it a try before deciding :)
12:03:19 <adnap> I will
12:03:22 <chrisblake> joelteon: why not just transfer over static/ and dist/ ?
12:03:30 <joelteon> well, dist is easy
12:03:33 <adnap> But I'm afraid I will run into something I can't do in Elm and be stuck because it's not extensible
12:03:36 <evancz> making different semantic choices is not the same as making restrictions
12:03:40 <joelteon> although the commit history for it makes it a pain in the ass to clone
12:03:42 <fizruk> is 'free' (in 'free monad/monoid') always read as 'freely/automatically generated'?
12:03:44 <mangaba_leitosa> evancz: and what's the recommended approach to writing complex web-applications? Writing everything in Elm or GUI part (client-side) in Elm and the backend in something like Haskell?
12:03:46 <joelteon> the problem is setting up the VM for building it
12:03:47 <joelteon> chrisblake: https://github.com/joelteon/joelt.io.hs
12:04:05 <evancz> mangaba_leitosa: Elm has no requirements about what you do on the server side
12:04:06 <chrisblake> joelteon: awesome, thanks :D
12:04:16 <structuralist> is it possible to have operators as value constructors in a GADT?
12:04:17 <joelteon> yep
12:04:20 <mangaba_leitosa> evancz: but what's the standard practice?
12:04:38 <evancz> I tend to write my entire front-end in Elm with Happstack servers
12:04:43 <joelteon> what I should do is have one repository with just the built products and one with the actual code
12:04:52 <structuralist> when I try to write "data Ctx u = T | (^) (Ctx u) u" using GADT syntax I get an error
12:04:52 <lpaste> jrm2k6 pasted “rearrange content” at http://lpaste.net/2800657902098972672
12:04:55 <evancz> this is how the website is done: https://github.com/evancz/elm-lang.org
12:05:06 <jrm2k6> hey evanz!
12:05:13 <evancz> hello!
12:05:16 <pseudolio> (^) is not a constructor name.
12:05:19 <jrm2k6> it is jeremy from prezi :D
12:05:27 <structuralist> pseudolio: it works though
12:05:31 <evancz> hi :)
12:05:49 <mangaba_leitosa> evancz: that is, you do backend on Haskell?
12:05:54 <evancz> unfortunately, I really need to get ready for this flight
12:05:54 <mangaba_leitosa> in Haskell even
12:05:59 <evancz> mangaba_leitosa: yeah
12:06:06 <evancz> I am thinking of trying some other things though
12:06:17 <mangaba_leitosa> evancz: have a good trip and thanks !
12:07:23 <chrisblake> joelteon: a submodule seems like a good idea
12:07:24 <evancz> okay, great talking with you :) And definitely come by the Elm mailing list if you have any FRP questions! Or want to discuss anything. We are really friendly and want to help more people learn FRP :)
12:07:25 <pseudolio> structuralist: No, it doesn't.
12:07:50 <klrr_> frp is truly awesome
12:08:15 <evancz> that makes me really happy :D
12:08:17 <structuralist> pseudolio: ok, it works at the type level
12:08:19 <structuralist> (&) :: Ctx * -> * -> Ctx *
12:08:22 <evancz> the internet is not always so nice :P
12:08:23 <mangaba_leitosa> evancz: good talking to you too, thanks :-)
12:08:28 <pseudolio> The type level is different.
12:08:59 <klrr_> evancz: although many of the examples doesnt utilize frp as much as it could do
12:09:13 <adnap> Can you create your own data types in Elm?
12:09:26 <evancz> klrr_: see this thread https://groups.google.com/d/msg/elm-discuss/LI4673F3ZjI/P1wHIMCZM8EJ
12:09:32 <evancz> adnap: yeah!
12:09:35 <evancz> of course :)
12:09:47 <adnap> Well, I just don't know how much I will be able to add if I find Elm lacking
12:10:00 <mkay_> something weird is going on...
12:10:14 <evancz> adnap: let me know if you have any issues at all and we'll figure it out
12:10:18 <mkay_> Data.Set doesn't have the findIndex/lookupIndex functions for me
12:10:23 <adnap> Is it strongly typed?
12:10:25 <mkay_> I'm on 7.6.3 though
12:10:26 <evancz> I don't think there are any major expressiveness limitations
12:10:28 <quchen> From what I've heard "Haskell without type classes and strict" is pretty much what Elm is.
12:10:29 <klrr_> evancz: gonna check
12:10:30 <evancz> adnap: yep
12:10:58 <evancz> quchen: that's reasonably accurate.
12:11:06 <evancz> signals take the place of IO monad
12:11:07 <adnap> So there's partial application, pattern matching, etc?
12:11:11 <evancz> records are nicer
12:11:13 <evancz> yep :)
12:11:19 <quchen> evancz: So you're the guy who Dobi always talks to when he's coding mazes eh? :-)
12:11:20 <evancz> it's in the "ML-family"
12:11:29 <evancz> haha, probably :)
12:11:34 <adnap> I don't get why it's not just a DSL in Haskell
12:11:50 <evancz> read this: http://www.testblogpleaseignore.com/2012/06/21/why-elm/
12:11:53 <adnap> I read it
12:12:10 <adnap> You said you would have trouble compiling Haskell to JS
12:12:16 <evancz> That was two years ago and Haskell to JS is still not a thing
12:12:29 <adnap> But it sounds like Elm has a lot of Haskell features
12:12:38 <adnap> So, I don't know what was so hard after all
12:12:40 * sm thinks it is a thing by now
12:12:42 <evancz> Haskell also has a lot of OCaml features
12:12:53 <adnap> Haskell to JS is a thing
12:12:54 <evancz> why is haskell not an OCaml DSL
12:13:24 <adnap> I just read http://jshaskell.blogspot.de/2012/09/breakout.html where the guy demonstrates using UHC to write a game in canvas with Haskell
12:13:39 <evancz> okay, I overstated
12:13:42 <evancz> sorry :)
12:13:43 <lpaste> lasticot pasted “Error Message” at http://lpaste.net/96027
12:13:46 <lpaste> lasticot pasted “main.hs” at http://lpaste.net/96028
12:13:47 <evancz> it is still tough though
12:13:53 <klrr_> i think a language instead of a DSL was good choice
12:14:01 <evancz> alright, I really do need to get going!
12:14:03 <klrr_> although it got some draw backs
12:14:05 <klrr_> cu
12:14:32 <evancz> http://cs.yale.edu/c2/images/uploads/dsl.pdf
12:14:33 <adnap> Well, Elm seems like it has a nice API already, so I'm going to try to implement a game in Elm first
12:14:34 * jchee calls for an Elm tsandard
12:14:42 <evancz> It's a tradeoff :)
12:14:50 <adnap> But I'm disappointed I can't use the linear package for linear algebra
12:14:55 <jchee> tsandard = standard
12:15:09 <evancz> adnap: awesome! Hopefully it serves you well :) And let us know if you have any issues!
12:15:09 <adnap> Or lenses, or other package
12:15:13 <adnap> *any other
12:15:23 <evancz> Okay, going for real! :)
12:15:31 <evancz> later folks :)
12:15:40 <adnap> Bye
12:15:44 <adnap> Thanks for answering questions
12:15:44 <klrr_> adnap: implement linear in elm as exercise :P
12:16:05 <fizruk> lasticot, perhaps you're using evalState instead of evalStateT somewhere
12:16:13 <adnap> klrr_: Agh, I don't want to reinvent Haskell in Elm
12:16:20 <adnap> It should be the other way around
12:16:23 <klrr_> it's a library not haskell per se
12:16:34 <klrr_> that's how it works across different language
12:17:01 <adnap> Well, the only reason Elm is not a DSL is because it was too hard
12:17:10 <adnap> So, I think it's still the ideal
12:17:15 <mkay_> huh
12:17:21 <lpaste> lasticot pasted “SnakeGame.hs” at http://lpaste.net/96029
12:17:33 <mkay_> anyone know why Set.lookupIndex got removed again?
12:17:41 <fizruk> lasticot, try adding type signature to the `loop`
12:18:09 <klrr_> adnap: well, there are already several FRP libraries/dsl's for haskell, reactive-banana, netwire, sodium, elerea etc.
12:18:16 <klrr_> i recommend reactive-banana
12:19:03 <klrr_> GHCJS might be something you are interested in then (not sure what initially got this discussion started)
12:19:26 <adnap> klrr_: GHCJS is not as developed as UHC yet
12:19:34 <fizruk> lasticot, exactly what I thought
12:19:41 <adnap> klrr_: But it said on github that they are trying to integrate it into GHC
12:19:49 <fizruk> lasticot, updateGameState has type SnakeInputs -> S.State SnakeGame ()
12:19:52 <klrr_> okey
12:20:05 <adnap> I have been using reactive-banana so I'm pretty familiar with it
12:20:14 <fizruk> lasticot, you should make it MonadState SnakeGame m => SnakeInputs -> m ()
12:20:34 <adnap> I don't understand why none of the Elm examples seem to have type signatures
12:20:45 <fizruk> lasticot, if you want it to work on an arbitrary monad stack (like StateT SnakeGame IO)
12:20:49 <klrr_> i think it's beacuse they were written before it was imeplement
12:20:51 <klrr_> implemented
12:20:55 <klrr_> i also got annoyed by that :P
12:21:20 <lasticot> fizruk: ok i ll try
12:22:14 <adnap> I can't believe how close Elm is to Haskell. It must have been hard to implement.
12:22:38 <adnap> It just makes it annoying that it's not Haskell!
12:23:19 <adnap> Well, I should get started
12:23:27 <lasticot> fizruk: it doesn't seem to be working/enough
12:23:28 <adnap> Making one thing in Elm couldn't hurt :P
12:23:40 <klrr_> well, it got different strings, different records, FRP built-in, it's strict etc.
12:24:10 <fizruk> lasticot, you're replaced type for updateGameState and nothing changed?
12:24:20 <fizruk> lasticot, s/'re/'ve/
12:24:21 <adnap> And once it spits out the JS, I don't have to worry if Elm dies or breaks compatibility
12:24:25 <lasticot> fizruk: actually it is asking me to add -XFlexibleContexts
12:24:36 <adnap> I'll have the finished game in JS
12:25:08 <lasticot> fizruk: I'm sorry I don't understand
12:25:22 <fizruk> lasticot, you can turn that on or use `StateT SnakeGame IO` instead of `State SnakeGame`
12:26:07 <jle`> this is hilarious http://elm-lang.org/edit/examples/Intermediate/Physics.elm
12:26:23 <fizruk> lasticot, FlexibleContexts is an extension that in this case allows you to use concrete type `SnakeGame` in the context `MonadState SnakeGame m`
12:27:12 <fizruk> lasticot, you can add this extension simply by adding {-# LANGUAGE FlexibleContexts #-} at the very top your SnakeGame.hs
12:27:42 <lasticot> fizruk: ok, I don't understand everything I'm doing ... do you have any link I could read to better understand
12:27:58 <quchen> jle`: The ball is following a sin curve! This is madness!
12:27:59 <adnap> jle`: It's like "learn you a haskell" humor
12:29:01 <jle`> not just that, but the earth/sun too
12:29:07 <adnap> jle`: The example seems a little laggy for me. Sometimes the Earth jitters slightly
12:29:16 <jle`> earth just follows an ellipse
12:29:32 <adnap> jle`: How is it for you?
12:29:41 <jle`> oh it's smooth for me
12:29:41 <fizruk> lasticot, perhaps here: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html#flexible-contexts
12:29:57 <lasticot> fizruk ok thanks!
12:30:15 <jle`> there are some aliasing/pixelzation issues with the text being centered on the ball of course
12:30:32 <fizruk> lasticot, and MonadState is from mtl package: http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-State-Class.html
12:31:05 <fizruk> lasticot, with MonadState one can abstract over actual transformer stacks
12:31:26 <lasticot> ok
12:31:54 <fizruk> lasticot, mtl has MonadReader, MonadError, MonadCont, etc. made with the same idea
12:32:00 <danharaj> edwardk: What makes Identity so special that callCC can be defined for Ran Identity Identity, but not for any other Codensity monad?
12:32:40 <lasticot> fizruk: ok I'll read the link you gave me I should better understand afterward
12:32:48 <lasticot> fizruk: thanks
12:33:01 <fizruk> lasticot, you're welcome!
12:35:15 <fizruk> danharaj, you can have callCC for Codensity (Const (m r)) which is pretty much ContT?
12:36:15 <danharaj> s/any/most
12:37:27 <bz> zathura lazy-
12:37:28 <bz> l
12:43:09 <ellipsis_> anyone know if you can use left-fuse with ResumableSource?
12:50:00 <fizruk> danharaj, I also suspect you can make instance MonadCont m => MonadCont (Codensity m)
12:50:39 <danharaj> That looks reasonable.
12:50:59 <danharaj> Finding a definite criteria for when callCC is definable is my interest.
12:57:16 <Eduard_Munteanu> Yay!
12:57:34 <Eduard_Munteanu> We have https!
12:58:10 <Eduard_Munteanu> Does cabal use it?
12:58:54 * Eduard_Munteanu ghcs Hackage 2
12:59:17 <Eduard_Munteanu> (hugs are too old)
13:04:35 <edwardk> danharaj: you mean (Const r) not Identity
13:05:13 <edwardk> @tell danharaj You mean Const r, not Identity. the thing you need is to know 'r' the thing we quantified over
13:05:13 <lambdabot> Consider it noted.
13:06:52 <fizruk> edwardk, still one can define instance MonadCont m => MonadCont (Codensity m)
13:07:24 <edwardk> fizruk: please do, and show me
13:07:29 <edwardk> oh
13:07:35 <fizruk> edwardk, so is it either "use internal callCC" or "know exactly what 'r' you're using"
13:07:39 <edwardk> MonadCont  => MonadCont (Codensity m)
13:08:21 <edwardk> send the instance for MonadCont (Codensity m) to me, not sure if we should adopt it as there is also MonadCont (Codensity (Const r)) which isn't MonadCont
13:08:39 <fizruk> edwardk, callCC f = join . lift $ callCC (\k -> return $ f (lift . k . return))
13:08:41 <edwardk> the lack of canonical choice is the kind of thing that drives one not to adopt either
13:08:53 <fizruk> edwardk, this is exactly what I used for FT
13:08:54 <jle`> is anyone here familiar with how fusian works in repa?
13:08:57 <edwardk> fizruk: can you create an issue on kan-extensions?
13:09:10 <fizruk> edwardk, I guess so :)
13:11:23 <fizruk> edwardk, you want an issue or a pull request with MonadCont m => MonadCont (Codensity m) ?
13:13:10 <`^_^v> what's a good idiomatic way to do this? i want to iterate over a list of integers, if the difference between an integer and the previous integer is more than 1, perform one monadic action, otherwise perform another monadic action
13:14:37 <jle`> `^_^v: is the monad action dependent on the integer or the difference itself, or only whether or not it is greater than or less than one
13:15:15 <arkeet> > (zipWith (-) <*> tail) [1,3,5,2,2,6]
13:15:16 <lambdabot>   [-2,-2,3,0,-4]
13:15:48 <joelteon> :t (-)
13:15:49 <lambdabot> Num a => a -> a -> a
13:16:00 <arkeet> that's subtraction.
13:16:12 <jle`> replace tail with drop 1 to be slightly less partial
13:16:23 <arkeet> jle`: actually this works fine.
13:16:27 <arkeet> but only by accident.
13:16:33 <fizruk> edwardk, also I believe MonadCont (Codensity (Const (m r))) is also legal
13:16:34 <arkeet> > (zipWith (-) <*> tail) []
13:16:35 <lambdabot>   []
13:16:41 <jle`> huh.
13:16:43 <arkeet> > zip [] undefined
13:16:44 <jle`> interesting
13:16:45 <lambdabot>   []
13:16:46 <fizruk> edwardk, since it's just a ContT
13:16:54 <jle`> did not consider that
13:16:56 <jle`> :)
13:17:00 <arkeet> :)
13:17:01 <edwardk> fizruk: sure. that will be the same as MonadCont (Codensity (Const r))
13:17:01 <joelteon> your mother is a ContT
13:17:07 <arkeet> =(
13:17:16 <`^_^v> that works,  i should have thought of that
13:17:23 <arkeet> nah
13:17:31 <arkeet> it's just one of those tricks.
13:17:40 <arkeet> @quote consecutive
13:17:41 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
13:17:44 <fizruk> edwardk, so which you want?
13:17:50 <jle`> `^_^v: don't worry, there is a question about list differencings every other day
13:18:18 <jle`> haha
13:18:45 <edwardk> fizruk: put the issue with the instances for Const r and MonadCont m   and we can let folks talk about if they want either instance or not, but i'll likely just keep the issue there to show that there is a tension about what the 'right' instance should be to support this functionality
13:18:56 <joeyh> I want to add getExecutablePath, which was added in ghc 7.4.2. What's the best way to get an #ifdef for that?
13:19:06 <fizruk> edwardk, ok
13:19:52 <arkeet> #if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ >= 704
13:19:56 <arkeet> will check for >= 7.4
13:20:01 <edwardk> __GLASGOW_HASKELL__ >= 704   -- doesn't give you enough resolution for that. since it'll hit 7.4.1 as well
13:20:03 <joeyh> thanks!
13:20:15 <joeyh> hmm
13:20:23 <dmwit> Shouldn't you use like #if MIN_base(whatever) instead?
13:20:31 <arkeet> probably.
13:20:32 <edwardk> ou can use MIN_VERSION_base(x,y,z)   (4,6,1)  -- or whatever the # is for 7.4.2
13:20:33 <joeyh> that's what I was wondering, base or that
13:20:45 <arkeet> if the thing is from base, check the base version, I suppose.
13:20:47 <edwardk> i don't know what base shipped with that compiler
13:21:07 <dmwit> Or just drop support for GHC <7.4.2 and put this in your .cabal file. ;-)
13:21:07 <lambdabot> That's Numberwang!
13:21:13 <dmwit> what
13:21:16 <dmwit> <7.4.2
13:21:21 <arkeet> haha
13:21:28 <arkeet> I don't see anything called getExecutablePath in base.
13:21:32 <arkeet> or in any standard library.
13:21:40 <joeyh> 7.4.1 is still in use by eg, Debian stable
13:21:43 <joeyh> sadly
13:21:49 <arkeet> well, that's debian stable.
13:21:55 <joeyh> System.Environment is where it lives
13:21:55 <arkeet> :P
13:22:06 <jrm2k6> I have this mapM (putStrLn . arrange) myList but I dont want to return [(), ()] from mapM, I just want to see the putStrLn
13:22:10 <jrm2k6> How can I do this?
13:22:14 <dmwit> arkeet: It's in there, according to haddock.
13:22:18 <dmwit> jrm2k6: mapM_
13:22:22 <arkeet> I only see that in base 4.6.0.0
13:22:29 <arkeet> not 4.5.1.0
13:22:30 <jrm2k6> thanks dmwit
13:22:37 <jrm2k6> :t mapM_
13:22:38 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
13:22:55 <dmwit> arkeet: Oh, I don't know what version it started in. You just said you didn't see it in base, not that you didn't see it in base-4.5.1.0!
13:23:01 <joeyh> looks like base 4.6.0.0 was the first
13:23:07 <arkeet> I was looking at the one corresponding to 7.4.2, I think
13:23:09 <arkeet> or 3
13:23:45 <Eduard_Munteanu> Does 'gstreamer' work with gstreamer 1.x?
13:23:56 <dmwit> Okay, let's see if I can get \bot to say NumberWang again. Think it's referentially transparent?
13:23:56 <Eduard_Munteanu> Oh, dmwit is around. :)
13:24:03 <dmwit> Or just drop support for GHC <7.4.2 and put this in your .cabal file. ;-)
13:24:06 <dmwit> nope
13:24:07 <dmwit> Eduard_Munteanu: hi
13:24:18 <dmwit> Eduard_Munteanu: I have no idea if gstreamer works with gstreamer 1.x.
13:24:21 <Eduard_Munteanu> Hey.
13:24:24 <dmwit> Is 1.x old or new? =P
13:24:47 <arkeet> did github just break?
13:25:00 <dmwit> no?
13:25:06 <arkeet> I get 403 Forbidden everywhere.
13:25:23 <Eduard_Munteanu> dmwit: it was released on 2012-09-24 it seems
13:25:53 <Eduard_Munteanu> Hm, so it seems not, latest upload on 'gstreamer' is Nov 11 2012
13:26:02 <jle`> arkeet: https://status.github.com/
13:26:26 <Eduard_Munteanu> Er, actually it is possible.
13:26:26 <arkeet> that doesn't change the fact that I get 403 everywhere.
13:26:36 <jle`> they did recently (as in the past half year or so) switched to distributed servers so you might be having problems with one of the nodes?
13:32:16 <ibotty> chrisdone: are you online and have a minute to chat?
13:34:01 <WraithM_> @src filter
13:34:01 <lambdabot> filter _ []     = []
13:34:01 <lambdabot> filter p (x:xs)
13:34:01 <lambdabot>     | p x       = x : filter p xs
13:34:01 <lambdabot>     | otherwise = filter p xs
13:34:23 <Philonous_> arkeet, Works for me™
13:34:47 <arkeet> yep, still no good here.
13:35:57 <arkeet> well it works sometimes randomly.
13:36:00 <arkeet> =(
13:38:00 <uvelichitel> arkeet: Can access my repos but 403 others
13:38:07 <monochrom> arkeet: there is System.Environment's getExecutablePath.
13:38:25 <arkeet> monochrom: yeah, but only since base 4.6
13:38:31 <monochrom> I see
13:39:24 <monoidal> pseudolio: replied to you on trac
13:39:43 <pseudolio> I saw.
13:39:54 <pseudolio> Your declaration is promotable.
13:40:05 <pseudolio> I still don't like it.
13:40:37 <pseudolio> This is not really an acceptable situation.
13:41:04 <pseudolio> We need consistent rules for the namespaces.
13:41:29 <pseudolio> Or to not auto-promote.
13:41:35 <pseudolio> Pick one. :)
13:42:05 <monoidal> I would prefer consistent rule (all type operators must start with :), but this seems to have little support (conal advocates this)
13:42:26 <monoidal> actually, no auto-promotion sounds also good
13:42:29 <fizruk> edwardk, created an issue... this instances do not conflict as far as I can see, do they?
13:42:58 <edwardk> Codensity m  overlaps Codensity (Const r)
13:43:11 <pseudolio> All type operators must start with : is actually not a consistent rule, either. :)
13:43:15 <edwardk> they unify
13:43:27 <monoidal> pseudolio: it's more consistent than having different rules for values and types
13:43:32 <pseudolio> Although it's restrictive enough to be okay.
13:43:34 <monoidal> pseudolio: I mean, the situation before the change
13:43:45 <fizruk> edwardk, so ghc wouldn't be able to figure out which one to use for (Const r) ?
13:43:48 <pseudolio> The situation before the change was to have different rules for values and types.
13:43:50 <monoidal> pseudolio: infix type constructors must start with :
13:43:50 <edwardk> honestly with the addition of type nats, having (+) (-) (*) at the type level is really important for code readability
13:43:58 <monoidal> pseudolio: what was different?
13:44:08 <edwardk> fizruk: corrct. you'd have to instantiate all the instances of MonadCont pointwise.
13:44:08 <Eduard_Munteanu> All type operators must start with a printable character, and have a positive integer as length. :P
13:44:39 <monoidal> hm, (+) (-) (*) seems to be a good argument.
13:44:41 <pseudolio> monoidal: You can write functions at the value level that don't begin with :, but not at the type level.
13:45:08 <monoidal> pseudolio: before the change you could write e.g. type a + b = (a,b)
13:45:14 <monoidal> umm sorry
13:45:16 <fizruk> edwardk, mkay... btw is there a reason you're not merging MonadCont instances for FreeT/IterT?
13:45:27 <monoidal> pseudolio: type F (+) = (+)
13:45:28 <pseudolio> Consistency would dictate that type and type family would not have to begin with :.
13:45:33 <Eduard_Munteanu> It's also annoying that you can't write kind synonyms. :(
13:45:38 <edwardk> been traveling, haven't had time to look
13:45:38 <monoidal> pseudolio: but yes, I see
13:45:58 <edwardk> monoidal: the problem with that was there was no syntax to put a fixity on those
13:46:06 <fizruk> edwardk, oh that's okay then :)
13:46:28 <edwardk> fizruk: going back out next week, so hopefully i'll get to it before thanksgiving otherwise you're in for a long wait ;)
13:46:48 <monoidal> pseudolio: I agree it is very confusing to have data A = (&) accepted, and have no (&) on the value level
13:46:49 <knadyy> damn this girl has a nice pussy http://instaflurt.com/yuribalbin/
13:47:01 <monoidal> pseudolio: maybe the fix would be: allow data A = (&) only if DataKinds is on?
13:47:03 <edwardk> speaking of travel: monoidal, i'll be in toronto next weekend on the 30th
13:47:04 <pseudolio> monoidal: Anyhow, the real problem is the value level. You can't just drop constructors. Yeah.
13:47:22 <monoidal> edwardk: I'm not from toronto; probably you meant monochrom
13:47:24 <pseudolio> If anything, the whole type shouldn't exist at the value level.
13:47:27 <edwardk> monoidal: that fix seems reasonable
13:47:28 <monochrom> no no no, you want monochrom to know this!
13:47:31 <edwardk> monoidal: woops
13:47:35 <monochrom> hehehe
13:47:37 <kthl`````> hi, can you suggest an algebra resource that covers the basics to start exploring Haskell's core and libraries? I'm starting from the level of college calculus. thx
13:47:41 <edwardk> one of you mono-types =)
13:47:49 <fizruk> edwardk, you ever visiting Moscow? :p
13:48:16 <dmwit> Why would an algebra resource cover Haskell?
13:48:19 <edwardk> fizruk: no plans currently, but figure out how to get someone to pay to fly me there and i'll happily give a talk
13:48:28 <monoidal> pseudolio: currently we don't support this, and there was a decision to not merge it to 7.8
13:48:58 <monochrom> edwardk: how much time will you have in Toronto? more specifically, for a Haskell meetup?
13:49:21 <kthl`````> fizruk: a resource that covers algebra, that seems to be required to understand lots of Haskell related principles, libraries and the likes - not that covers HAskell directly.
13:49:32 <monoidal> pseudolio: does that fix seem reasonable? or would you prefer to never accept data A = (&), even with DataKinds?
13:49:36 <edwardk> monochrom: anyways, i'll be there from late night on the 29th, all day on the 30th, and fly out stupid early on the 1st. if you wanted to do a Haskell meetup on the 30th i could make it work
13:49:36 <lambdabot> That's Numberwang!
13:49:38 <cornjuliox> i take it you're not able to give functions explicit type declarations in ghci? I'm trying to do it and i get 'not in scope' errors
13:50:07 <monoidal> cornjuliox: let f :: a -> a; f x = x works
13:50:11 <edwardk> i'm visiting with a friend while i'm in the area, but i'm renting a car so i can get around
13:50:23 <notthemessiah> kthl`````: like this? http://en.wikibooks.org/wiki/Haskell/Category_theory
13:50:44 <arkeet> note: you don't really need that to be productive in haskell
13:50:45 <arkeet> :p
13:51:03 <fizruk> kthl`````, "Types and Programming Languages"?
13:51:26 <monochrom> ok edwardk, I'm booking you for a haskell meetup on the 30th, 7:30pm-9:30pm; if you like to dine with some of us too, 6:30pm. or you suggest a time slot better for you.
13:51:34 <pseudolio> monoidal: I could live with data A = (&) being accepted for the type level if it didn't exist at all at the value level. I think it's wrong for A to exist with no constructors, though.
13:51:48 <kthl`````> notthemessiah: yes althought it seems too advanced for me - what to study before that?
13:51:52 <edwardk> that works. how many people do you expect?
13:52:10 <pseudolio> monoidal: I think the right solution is to figure out one set of naming rules that work for both levels, though. I don't know if that can ever happen, though.
13:52:11 <cornjuliox> monoidal, awesome that worked thanks
13:52:20 <kthl`````> fizruk: can it be understood without specific knowledge of logic/smenatics and the like?
13:52:50 <monoidal> pseudolio: I agree it's wrong, but as far as I know we won't have KindsWithoutData in 7.8
13:53:17 <pseudolio> What would that enable?
13:53:24 <fizruk> kthl`````, yes
13:53:27 <pseudolio> A separate declaration?
13:53:31 <Eduard_Munteanu> What's a good FFI bindings generator these days?
13:53:45 <johnw> Eduard_Munteanu: I use c2hsc
13:53:51 <monoidal> pseudolio: a situation where you have kind A but not type A. yes, a separate declaration data kind A = X, which creates kind A, type X, but not type A nor value X
13:54:16 <monoidal> pseudolio: so you could write data kind A = (&) but not data A = (&)
13:54:17 <Eduard_Munteanu> johnw: same thing as 'c2hs'?
13:54:17 <fizruk> kthl`````, iirc the book does not rely on any particular background knowledge
13:54:32 <johnw> Eduard_Munteanu: no, c2hsc turns C header files into .hsc files, for use with Bindings-DSL
13:54:44 <johnw> it's how I generate the bindings for hlibgit2
13:54:44 <arkeet> c2hs is not c2hsc
13:55:16 <monochrom> edwardk: with 99.99% probability, you and me; with 90% probability, you me and one more (likely chris olah, colah here); with 80% probably, you me and at least two more
13:55:37 <Eduard_Munteanu> Hmmm... what about that DSL?
13:56:09 <Eduard_Munteanu> Maybe I can approach it that way.
13:56:51 <monoidal> pseudolio: https://ghc.haskell.org/trac/ghc/wiki/GhcKinds/KindsWithoutData
13:56:55 <pseudolio> monoidal: I guess implementing a check that only generated the kind if there were invalid constructors would be a waste of effort then?
13:57:11 <notthemessiah> kthl`````: Category theory is somewhast related to Abstract Algebra, so perhaps as a point of reference you might want to try learning about Group theory and how a set&operation form a group, and relate that to how monads are formed.
13:57:12 <pseudolio> I guess you could just postpone the fix until KindsWithoutData, then.
13:57:21 <arkeet> notthemessiah: ??????
13:57:24 <edwardk>  monochrom: then i'll just plan on whiteboarding something =)
13:57:25 <monoidal> pseudolio: I don't understand your question "I guess..."
13:57:57 <kthl`````> fizruk: I see there are even lectures of Pierce's courses online
13:58:13 <edwardk> how about i just show up and talk about whatever you guys are interested in
13:58:14 <monoidal> pseudolio: what I propose is this: if there are invalid constructors *and* datakinds is off, reject the declaration
13:58:25 <pseudolio> monoidal: When KindsWithoutData goes in, will 'data Foo = (&)' be rejected because you can write 'data kind Foo = (&)' which will be accepted?
13:58:44 <monoidal> pseudolio: yes, that's what I expect.
13:58:55 <pseudolio> Okay. Then that's probably a good enough stopgap.
13:59:10 <notthemessiah> kthl`````: Pierce's book on Software Foundations is completely free, and provides a deep understanding of programming languages and type theory.
13:59:11 <pseudolio> Although you'll still have to explain why GADT syntax doesn't work in the meantime. :)
13:59:19 <monoidal> oh, right
13:59:25 <pseudolio> Or maybe it does on HEAD, I didn't check.
13:59:38 <kthl`````> notthemessiah: that is because monads come from monoids, which are structures with... I forgot, one operation maybe?
13:59:43 * hackagebot tempodb 0.1.1.0 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.1.1.0 (ParnellSpringmeyer)
13:59:48 <pseudolio> Nope.
14:00:31 <kthl`````> notthemessiah: yes I'm looking at it right now, seems quite a hard study but worth it for sure.
14:00:41 <silasm> kthl`````: one operation which is associative and has an identity.
14:01:14 <silasm> software foundations is fun.
14:01:22 <Eduard_Munteanu> Any thought on c2hs itself? I have it readily available here.
14:01:27 <notthemessiah> kthl`````: Software Foundations might be overkill, but helps you understand proofs-as-programs, Typeclassopedia is also a good resource: http://www.haskell.org/haskellwiki/Typeclassopedia
14:04:28 <kthl`````> silasm: oh ok - I wonder why monoids are usually not mentioned in math classes before college level. sometimes I remember they present you a bit of ringsand groups, maybe because they help explain simple concepts like the ones in geometry (simmetry, trnslation)? hope I'm not sayin silly things by tryin to remember...
14:05:55 <silasm> kthl`````: makes some sense, finishing up an Abstract Algebra class this semester, but it's the first I'd heard of algebraic structures outside of Haskell. If it's taught in high school in any way, I'm jealous.
14:05:56 <kthl`````> seems a good strategy will be reading about algebric structures first then checking Pierce eventually.
14:06:01 <chrisdone> ahoy hoy
14:06:22 <dmwit> mushi mushi
14:06:30 <johnw> silasm: I'd never heard of a single algebraic structure until just recently, via Haskell
14:07:06 <kthl`````> silasm: no no no need to be jealous, I only remember it was mentioned related to geometry concepts (plane geometry figures if I'm not mistaken)
14:07:30 <silasm> kthl`````: I'm using sf primarily to understand programming with dependent types and such. Unfortunately the documentation I've found on Idris has been less introductory.
14:07:32 <edwardk> kthl`````: many of the interesting results start up around group, so depending on how your abstract algebra course goes it either goes top down starting at the reals, ripping wings off the fly and seeing what still works, stopping somewhere around group, or it goes bottom up like mac lane and starts with group or so and goes up. if you do a graduate course that follows Lang, then it starts with monoids and goes up
14:07:43 <edwardk> but starting with group gives you more structure, more things you can prove
14:07:47 <edwardk> monoids are pretty weak
14:08:48 <silasm> edwardk: yeah my class just briefly mentioned monoids and skipped them altogether. We've been doing groups all semester, start rings and fields on Monday. Excited for that.
14:08:50 <kthl`````> edwardk: ah I see that makes sense
14:09:09 <ibotty> hi chrisdone
14:09:44 * hackagebot chatter 0.0.0.3 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.0.0.3 (RoganCreswick)
14:09:57 <edwardk> category theorists like monoids because a monoid is just a category with one object
14:10:04 <ibotty> many comments on hell :D. do you have any ideas on integrating posix into the shell. apart from the (not full-featured) `run`?
14:10:17 <silasm> kthl`````: If you want an abstract algebra book there's a Dover publications one for $14, by the way. I've enjoyed reading it.
14:12:14 <edwardk> i tend to like mac lane's algebra or lang's depending on how much math background the person has.
14:12:58 <tac> A category is just a monoidoid.
14:12:59 <kthl`````> silasm: Charles Pinter's one?
14:13:21 <silasm> kthl`````: yeah. Main thing is it's cheap, but it does a good job of giving motivations and such too, I like it.
14:13:36 <kthl`````> silasm: thx for the suggestion
14:13:50 <chrisdone> ibotty: 'integrating posix'?
14:13:58 <ibotty> integrating posix commands
14:14:25 <ibotty> for me a shell is all about leveraging the system
14:14:51 <kthl`````> edwardk: mac lane's is the heavier on prerequisites or the other way around?
14:15:09 <ibotty> and the system is the unix commands, and they communicate (in a shell context) via stdin and stderr
14:15:16 <edwardk> lang is rather ridiculously heavy prerequisite wise
14:15:29 <edwardk> everything he says is self-contained, but you need the background to unpack it
14:15:45 <ibotty> so i'd like an operator `|` that can do so for run commands, if you like
14:15:55 <edwardk> mac lane has a couple of abstract algebra books that are very accessible
14:16:11 <kthl`````> edwardk: tell me about the background for Lang, up to what is useful to have?
14:17:06 <ReinH> I'm enjoying Categories for the Working Mathematician
14:17:08 <edwardk> kthl`````: personally i used Lang as a way to sort of bridge category theory and abstract algebra. its a good way to pick up after you're done with CftWM by mac lane and start to mix more algebra into your  understanding of category theory
14:17:18 <edwardk> er bridge between
14:17:18 <ibotty> i'm thinking about a function r :: ProgramSpec -> StdIn -> (StdOut, StdErr), where ProgramSpec is how you call the external program
14:17:23 <silasm> ReinH: I was looking at that, how is it?
14:17:34 <ReinH> I'm working my way through Lang's Algebra right now too
14:17:54 <edwardk> CftWM changed the way i think fundamentally, but it took me dozens of tries to get all the way through "honestly"
14:18:21 <edwardk> and i had a strong math background to start with
14:18:22 <ReinH> Lang is like walking through a zoo full of algebraic structures
14:18:46 <ReinH> silasm: It's good. For someone with the requisite maths (which isn't very much) it's a brisk introduction
14:18:57 <silasm> my abstract algebra teacher said I should have a good understanding of abstract algebra and topology and such before attempting CT though, what are your opinions on that?
14:18:59 <ibotty> then you could have an operator, |, that composes them.
14:19:30 <ReinH> silasm: I'm just piecing stuff together as I go. I'm sure a more principled approach would yield better results but ain't no one got time for that.
14:19:44 <edwardk> Lang is great for the way I learn in that he just gives you the menagerie of different things and moves on. Very dense. you can unpack the significance later, but you need to be good at holding a lot of relatively unmotivated abstractions
14:19:45 * hackagebot laborantin-hs 0.1.2.0 - an experiment management framework  http://hackage.haskell.org/package/laborantin-hs-0.1.2.0 (LucasDiCioccio)
14:19:50 <ibotty> chrisdone: maybe you could open the wiki, so that can be discussed a little more substantial
14:19:53 <silasm> ReinH: heh sounds good to me, I'll probably buy it then.
14:19:57 <kthl`````> edwardk: well got no strong background here but I'm working on it right now. hopefully I'll start diggin deeper in structures soon.
14:19:57 <lpaste> jfeltz pasted “error| Expecting one more argument to `a' in type signature” at http://lpaste.net/96031
14:20:21 <jfeltz> I'm surprised that I haven't run into this error before, clue please :(
14:20:35 <edwardk> silasm: the nice thing about picking up some category theory is that a solid understanding of haskell can serve as a bit of a substitute for some of the usual 'mathematical maturity' needs.
14:20:38 <mauke> looks like Foldable takes * -> *
14:20:46 <edwardk> Hask makes a great category to work in, since it has so much structure
14:20:51 <mauke> :k Foldable
14:20:52 <lambdabot> (* -> *) -> Constraint
14:20:54 <mauke> yep
14:20:57 <jfeltz> gah
14:21:05 <silasm> edwardk: ooh, neat. Guess I hadn't thought about it that way.
14:21:30 <silasm> though I do feel my knowledge of haskell helped me in AA.
14:21:31 <edwardk> silasm: as you go you find things that 'should exist' and look around in haskell and recognize them
14:21:34 <kthl`````> edwardk: mmm sounds like Lang is more of a "mathematicians' book" so to speak, while Mac Lane is more open to anyone with the sufficient background then. will look into the latter first for sure then.
14:21:43 <edwardk> kthl`````: exactly
14:22:11 <ReinH> silasm: the most helpful thing for me was to try to use my newfound knowledge in Haskell
14:22:16 <Saizan> Mac Lane does have some obscure examples for me still, but i'm fine if i make my own
14:23:08 <edwardk> you get things like Void as the initial object, because absurd exists, () as the terminal object, because const () exists. etc
14:23:56 <ReinH> edwardk: bottom makes Hask a bit of a pain though, doesn't it?
14:23:59 <edwardk> () works as the unit for (,), Void as the unit for Either, you have products and coproducts, exponentials, Functor gives you endofunctors on Hask, all sorts of things just work
14:25:46 <edwardk> ReinH: there is a nice writeup out there talking about "which category is Hask?" that summarizes the different quotients we like to take over types when talking about Haskell. do we ignore seq, etc.
14:25:57 <silasm> is there a "Category Theory for the Haskeller" book? I'm honestly surprised I don't find things like this sometimes.
14:26:06 <edwardk> silasm: not really
14:26:33 <ReinH> edwardk: that's true, figuring out that Functor is an endofunctor on Hask was a big help for my intuition about the mapping from maths to Haskell
14:26:43 <ReinH> edwardk: it's a morphism morphism ;)
14:26:47 <edwardk> =)
14:26:53 <ReinH> silasm: seems good, edwardk should write it :D
14:26:57 <ReinH> in his copious freetime
14:27:25 <tac> I want copious freetime.
14:27:55 <jfeltz> silasm: http://en.wikibooks.org/wiki/Haskell/Category_theory
14:28:27 <tac> IMO, Haskell only obscures your understanding of category theory.
14:28:44 <tac> You end up trying to jam it into Haskell's limited type system, and things don't fit right :<
14:29:00 <edwardk> tac: it is a source of intuition, not rigor.
14:29:12 <edwardk> parametricity isn't quite naturality, etc.
14:29:21 <arkeet> Hask isn't a category.
14:29:23 <arkeet> :P
14:29:56 <kthl`````> btw I started working up on the algebra path after skimming http://jeremykun.com/primer - maybe too simple for the audience here but I thought of mention it because it's well written and accurate as far as I can check.
14:30:04 <tac> It's just broken overall. You'd be better off in a dependently-typed language, and having both.
14:30:21 <tac> (Or at least, much less broken stuff :X)
14:31:54 <silasm> tac: yeah I'd imagine Coq might fit the bill a bit better. It's weird though; I kind of hope to use it to learn the paradigm and move to Idris asap.
14:33:26 <mythmon> simon: but now I am.
14:33:31 <mythmon> er, simpson ^
14:33:32 <simpson> preflex: xseen mythmon
14:33:32 <preflex>  mythmon was last seen on freenode/#haskell 1 second ago, saying: er, simpson ^
14:33:33 <mythmon> sorry for the misping.
14:33:46 <simpson> mythmon: Ah.
14:34:02 <simpson> preflex: xseen edunham
14:34:02 <preflex>  edunham was last seen on freenode/#haskell 2 days, 2 hours, 47 minutes and 20 seconds ago, saying: it's how you background a process; means he's afk for a bit.
14:34:51 <gwern> who runs lambdabot these days? what's your excuse for that 'Numberwang' thing?
14:36:02 <scriptor> what 'Numberwang' thing?
14:36:25 <gwern> scriptor: in #lesswrong, when people write numbers, every 4 or 5 times, lambdabot will say 'That's Numberwang!'
14:36:48 <simpson> Fancy. Numberwang's a pretty tricky game, and I didn't realize that lambdabot could detect it.
14:36:55 <simpson> Hm. 42, 1, 2, 1, 1.
14:37:07 <simpson> 5, 8?
14:37:17 <simpson> Guess I'm pretty bad at Numberwang. :c
14:37:28 <kthl`````> anyone, thank you very much for the pointers and discussion.
14:37:48 <thebnq> maybe 1st 2nd triggers it
14:37:51 <thebnq> oh well :C
14:37:57 <silasm> kthl`````: enjoy :). Glad I could help someone out here, that's rare for me lol.
14:38:09 <simpson> thebnq: Well, it only would fire if you get Numberwang, which is non-trivial.
14:38:29 <thebnq> simpson: i don't know the rules at all :( just going off what i saw earlier
14:38:48 <jimmyray> haskell is a fookin shite
14:38:51 <jimmyray> mofos
14:38:54 <simpson> @where ops
14:38:54 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
14:38:54 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:38:55 <jimmyray> suck my fookin dick
14:38:59 --- mode: ChanServ set +o monochrom
14:39:00 <jimmyray> FUCK HASKELL
14:39:02 <jimmyray> niggers
14:39:04 --- mode: monochrom set +b *!*@2001:1af8:4020:a018:4::
14:39:04 --- kick: jimmyray was kicked by monochrom (jimmyray)
14:39:06 <peddie> 'numberwang' triggered in ##crypto when someone sent part of an ascii text banner; no numbers required?
14:39:11 --- mode: ChanServ set +o geekosaur
14:39:13 --- mode: ChanServ set +o edwardk
14:39:13 --- mode: geekosaur set +b jimmyray!*@*
14:39:24 --- mode: monochrom set -o monoidal
14:39:28 --- mode: monochrom set -o monochrom
14:39:40 --- mode: geekosaur set -o geekosaur
14:39:49 <kthl`````> was that Jon Harrop right?
14:40:01 <simpson> Same guy was in #python earlier. Guess he just needs something to do.
14:40:29 --- mode: ChanServ set +o mauke
14:40:29 --- mode: mauke set +b $a:jimmyray
14:40:47 --- mode: ChanServ set +o monochrom
14:40:52 <geekosaur> actually... oh, fixed already
14:40:56 --- mode: monochrom set -b *!*@2001:1af8:4020:a018:4::
14:41:00 --- mode: monochrom set -o monochrom
14:41:15 * geekosaur had missed that they were already kicked, client set stupidest possible ban :/
14:41:26 <monochrom> hehe
14:42:29 --- mode: mauke set -o mauke
14:44:05 <monoidal> is there a Typeable-like class but for Q Type, not TypeRep?
14:44:15 <monoidal> (plain curiosity.
14:52:05 <int-e> that plugin is a bit too chatty :)
14:52:19 <arkeet> yes
14:53:08 <edwardk> int-e: yeah. it was interesting the first dozen times
14:53:15 <edwardk> but lambdabot is too high traffic for it
14:54:17 <simpson> I don't see the problem. We don't really play Numberwang in here.
14:54:46 <rally> Hi #haskell, I have a question. I have a function (Code b) => a -> b, and another one (Code b) => b -> c, and I want to turn those into a function that does a -> c, but it's not letting me write (Code b) => a -> c.
14:55:16 <arkeet> rally: what are a and c?
14:55:21 <arkeet> are they just type variables?
14:55:24 <edwardk> simpson: [23:58] lensbot:	 succinct/master d52ab52 Edward Kmett: more restructuring    ==> [23:58] lambdabot:	 That's Numberwang!
14:55:31 <rally> I kind of get why it's not letting me do that (I need to specify which instance to use) but can't find a way to write it
14:55:36 <rally> arkeet: type variables, yeah.
14:55:41 <monoidal> rally: you can use a concrete value for b, otherwise it's ambiguous
14:55:51 <arkeet> rally: well, such a function doesn't exist!
14:55:55 <arkeet> (neither does Code b => b -> c)
14:55:57 <int-e> edwardk: I /guess/ that's two numbers for it. (52 and 52 again)
14:56:02 <geekosaur> rally: if you do not *provide* a b, you cannot control the instance
14:56:02 <monoidal> rally: e.g. give the first function type a -> Int, and the second Int -> b
14:56:04 <edwardk> simpson: lots of #'s flying around in other channels. =)
14:56:36 <int-e> anyway, it's gone now. I hope nobody was seriously upset by it :)
14:56:45 <monoidal> rally: the point is that the result of your composition might depend on b. for examle, consider (show . read)  "0.0" - if you read this is as a float, it is 0.0, but as an int, it's undefined
14:56:48 <edwardk> int-e: plus "[succinct] ekmett pushed 1 new commit to master: http://git.io/iGXCWQ" on the previous line
14:56:59 <edwardk> int-e: nah, slightly bemused =)
14:57:12 <rally> monoidal: Yeah, I think I get why it's not letting me do that - it doesn't know which instance to use, does it?
14:57:17 <monoidal> rally: Right.
14:57:19 <arkeet> unless, of course, there are also constraints on a and c.
14:57:34 <monochrom> rally: you likely want to write like "f x = btoc (atob x :: Int)" (this chooses b=Int)
14:57:35 <rally> Trouble is I can't find a way to specify which one I want.
14:57:45 <arkeet> rally: care to show some more complete code?
14:57:54 <monoidal> rally: use a typesig, like monochrom said
14:57:58 <Qfwfq> int-e: Thanks! <3
14:58:04 <gwern> int-e: thanks for removing it. we weren't playing numberwang whatever that is, but it wasn't shutting up
14:58:05 <arkeet> or at least the exact types of things
14:58:22 <intrados> Is there some generalized fold that takes multiple lists? Or is folding over a zipped list the best option?
14:58:33 <rally> arkeet: https://gist.github.com/ogham/1cfe120afc36c379e340
14:58:48 <rally> Not sure if lpaste is preferred, I put it on gist before seeing the topic
14:59:08 <rally> The 'problem functions' are the last two, tryParse and parse.
15:00:24 <simpson> edwardk: All I can say is that git clearly plays a mean game of Numberwang. :3
15:00:30 <rally> monochrom: I don't parse in an argument of type b, and the return type isn't of b either. But if that's the way I have to go then I could re-write it so I could specify something of type b
15:01:15 <monoidal> rally: you can write case decode s :: Result IPv4 of ... for example
15:01:50 <arkeet> ok, so they weren't type variables after all. :-)
15:01:59 <rally> Oh, they aren't?
15:02:06 <arkeet> String isn't a type variable.
15:02:21 <arkeet> it's a type.
15:02:22 <rally> Oh. But 'a' and 'c' are type variables, though?
15:02:26 <arkeet> yes
15:02:39 <arkeet> because you can substitute them for types.
15:02:44 <monoidal> you don't have 'c' anywhere, though
15:03:01 <arkeet> concrete types start with an uppercase letter.
15:03:20 <monoidal> rally: simply speaking, you've got two parsers, so you need to specify which one to use on a string.
15:03:42 <skypers> night every one
15:03:59 <monoidal> rally: you might create a different function that will parse both IPv4s and Sammichs, if that's intended
15:04:02 <rally> arkeet: I thought you were talking about 'a' and 'c' rather than the types they referenced. Perhaps. I see what you're getting out now.
15:04:26 <rally> monoidal: I was going for something that I could pass in a typeclass instance and have it do the parsing for that instance
15:04:36 <arkeet> yes, I was asking whether they were type variables in your code, or fixed types.
15:04:39 <arkeet> anyway.
15:04:44 <rally> monoidal: I know that just using 'tryParse s' won't work, but I got kind of stuck.
15:04:50 <rally> arkeet: oh! right.
15:05:28 <monoidal> rally: you can give a dummy variable Code b => b -> String -> Maybe [Code]
15:05:36 <arkeet> Code b => p b -> String -> Maybe [Code]
15:05:41 <monoidal> rally: the user will put there a value of type b, which will be ignored, but the type will indicate what parser to use
15:05:52 <rally> So pass in one that gets ignored, but still carries type info with it?
15:06:05 <monoidal> rally: an even better solution is arkeet's, where "p b" essentially forces the thing to be ignored due to polymorphism
15:06:22 <monoidal> rally: yes
15:06:54 <arkeet> you still need to use that type information somehow to fix the type of the intermediate value though.
15:06:58 <monoidal> rally: alternative: define data Proxy a = Proxy; then you can have type tryParse :: Code b => Proxy b -> String -> Maybe [Code], and use it like so: tryParse (Proxy :: Proxy IPv4)
15:07:00 <rally> OK, let me try this
15:07:09 <arkeet> monoidal: that's strictly worse than mine, I think.
15:07:21 <monoidal> arkeet: it's a matter of taste imo
15:07:36 <arkeet> in any case
15:07:43 <rally> Passing in a variable means I need to use the constructor instead of the type name for every parser I have in the list, which is a bit weird but I can live with it
15:07:52 <monoidal> arkeet: reinventing Proxy is bad, but if you use one commonly used, I think it expresses cleanly the intent
15:08:09 <arkeet> monoidal: I'm not reinventing anything.
15:08:20 <arkeet> p is polymorphic, so you can pass it a Proxy IPv4 if you like.
15:08:40 <monoidal> arkeet: by reinventing I meant defining "data Proxy  a = Proxy"
15:08:45 <arkeet> no need.
15:08:49 <monoidal> arkeet: instead of using some library.
15:08:54 <arkeet> Nothing :: Maybe IPv4 is just as good
15:09:08 <arkeet> (or undefined :: p IPv4)
15:09:22 <monoidal> arkeet: what I don't like about "p a" is that it's somewhat laxer on type safety, since you can pass e.g. Maybe IPv4
15:09:24 <arkeet> (although I guess that might run into ambiguous stuff.)
15:09:30 <arkeet> it is?
15:09:41 <monoidal> arkeet: I would prefer (forall p. p a) -> ...
15:09:45 <arkeet> it is forall
15:09:48 * hackagebot tempodb 0.1.1.1 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.1.1.1 (ParnellSpringmeyer)
15:09:53 <monoidal> arkeet: but not rank-2
15:09:58 <arkeet> oh
15:10:01 <arkeet> that is even worse!
15:10:07 <monoidal> arkeet: why?
15:10:20 <monoidal> it forces you to pass undefined
15:10:28 <arkeet> who cares what you pass it?
15:10:58 <arkeet> if you write p a -> ...
15:11:01 <monoidal> arkeet: if you forget about that "p", you can pass something and get the wrong instance. e.g. you meant Proxy [Int], but forgot the proxy and got Int
15:11:04 <arkeet> that already guarantees that the implementation can't use p.
15:11:08 <arkeet> er, the value.
15:11:29 <arkeet> ?
15:11:41 <arkeet> anyway whatever.
15:11:44 <monoidal> it gives more room for the user than neccessary. I prefer to have a single correct way to do it.
15:11:55 <arkeet> rally: sorry for sidetracking. :p
15:12:15 <monoidal> agreed. rally: please disregard above
15:12:36 <rally> haha it's ok
15:12:43 <benzrf> when would you *not* want to use try in parsec?
15:12:44 <rally> You people are interesting
15:12:45 <arkeet> this happens often.
15:12:53 <benzrf> it makes it so that failing parsers do not consume input, right?
15:13:22 <arkeet> benzrf: memory leaks, possibly.
15:13:27 <monoidal> good night
15:13:52 <rally> I'm re-writing it so it takes an argument that gets ignored, but right now it's failing with some other type error that I couldn't see because the other one was happening instead
15:16:58 <nelk> Ever since I've switched to cabal sandboxes, I can't get "yesod devel" to run - it says it can't find "libHSutf8-string-0.3.7.so". Does anybody know how to fix this?
15:19:37 <jle`> i feel bad asking this again but does anyone here have a working knowledge of how fusion works in Repa?  Does fusion end when you move from Delayed to Non-Delayed?  If I have code that dynamically switches between Delayed and Undelayed several times, is fusion carried trhough?
15:38:45 <chrisdone> 631 emacs buffers
15:39:04 <chrisdone> think maybe i'll just start a fresh session than garbage collecting =)
15:39:20 <monochrom> haha
15:39:51 <monochrom> your number of buffers is like how many US dollars can buy a bitcoin
15:40:01 <chrisdone> haha
15:40:16 <rally> midnight-mode
15:40:41 <rally> You aren't the only one!
15:44:12 <Peaker> chrisdone: I use ido in emacs, so I long-press C-k to kill my hundreds of buffers :)
15:44:23 <klrr_> chrisdone: as suggested in reddit, having names that are not in scope being evaluated to strings, do you think this is a viable idea or way too hard to implement as is?
15:45:06 <hpc> klrr_: names not in scope should crawl up the call stack until they find a scope with the name in it!
15:53:50 <ReinH> hpc: I guess no one wants to follow that up
15:54:02 <hpc> i wouldn't follow it up either
15:55:30 <chrisdone> i'm not yet convince that strings are as terrible as people make out
15:55:38 <chrisdone> i'm going to try it out
15:55:49 <hpc> i like strings, but not implicit strings from out-of-scope identifiers
15:55:51 <chrisdone> bash syntax is convenient but haskell is predictable
15:56:08 <ReinH> er, converting not-in-scope haskell identifiers to strings?
15:56:13 <ReinH> that sounds like a pretty terrible idea
15:56:35 <ReinH> maybe less so in a type inferred language, but o_O
15:56:40 <chrisdone> hpc: that's what i mean. i'm not that bothered by writing ls "ProTAB instead of ls ProTAB to write ls "Projects"
15:56:56 <chrisdone> yeah, it seems like it would lead to bugs to me
15:57:20 <hpc> bash isn't really a language
15:57:30 <hpc> i mean, it is, but it isn't
15:57:44 <chrisdone> strings also give a clear delimitation for completion of filesystem vs haskell commands
15:57:45 <hpc> it's below even scripting languages in terms of complexity that you use it for
15:58:00 <ReinH> I mean, if nothign else we're talking about a large number of "reserved" identifiers from Prelude and imported modules...
15:58:02 <donri> to hell with this, i want a lojban shell
15:58:57 <donri> ko jukpa lo nanba
15:58:58 <chrisdone> do dijca un zo'oi shell bau lo jbobau i'e zo'o
15:59:16 <ReinH> oh god no please stop
15:59:18 <chrisdone> hpc: yeah, i largely dislike bash
16:00:10 <hpc> i like bash, but only because i don't see it as a scripting language
16:00:16 <hpc> it's a "command language", if that's even a thing
16:00:19 <rally> I did a similar thing in ruby a couple of years ago. The only painful thing was cd
16:00:42 <chrisdone> rally: why was cd painful?
16:00:51 <rally> Because you had to put the quote in! Terrible, I know.
16:00:55 <chrisdone> lol
16:01:15 <rally> I have had to... not do that for so long that I just couldn't get my head around it.
16:01:53 <ReinH> hpc: Bash is a general purpose language!
16:02:03 <hpc> ReinH: don't make me slap you
16:02:05 <ReinH> I wrote a redis client in Bash, for instance.
16:02:06 <chrisdone> if i'm not piping two commands together bash is useless to me, personally
16:02:23 <ReinH> It was only 20 LoC :p
16:02:42 <ReinH> Fun story: bash 3 has a fake dev device called /dev/tcp
16:02:44 <chrisdone> i grep/find/sed and run things in sequence, anything else more complicated and it's godawful
16:02:50 <rally> When all you have is a shell, everything begins to look like a string.
16:02:53 <ReinH> I just said device device :/
16:03:00 <chrisdone> lol
16:03:04 <ReinH> rally: false, Bash has arrays :p
16:03:11 <rally> When'd they add that?
16:03:11 <chrisdone> ReinH: DJ Hitek has a PC computer
16:03:12 <FireFly> in rc everything is a list of strings instead
16:03:13 <hpc> rally: when all you have is a shell, hide inside it
16:03:18 <ReinH> chrisdone: hate you
16:03:39 <ReinH> when you don't have a shell, steal someone else's
16:03:41 <FireFly> (which is at least mildly saner in that e.g. PATH doesn't have to be a colon-separated string)
16:03:46 <rally> I tried using fish and that has $PATH as an array.
16:03:47 <ReinH> this is how a hermit crab do
16:04:11 <chrisdone> rally: zsh does too. i couldn't really figure out how to use it properly
16:04:24 <ReinH> colon-separated strings are a pretty reasonable way to encode arrays in a language that has arrays. Wait.
16:04:30 <chrisdone> ReinH: the hermit crabs are wise
16:04:45 <levi> Anyone ever play with Powershell?
16:04:48 <chrisdone> really PATH should be Set =)
16:04:51 <rally> ReinH: That's a terrible idea. Whe should make the delimiter inconsistent across platforms.
16:05:02 <rally> I use Powershell at work! It's Good Enough!
16:05:02 <chrisdone> perhaps an ordererd set
16:05:09 <chrisdone> order matters, but uniquness doesn't
16:05:09 <ReinH> rally: I am so sorry
16:05:25 <rally> With PowerShell and ConEmu, it's mildly bearable
16:05:51 <ReinH> I'm still waiting for someone to write skynet in sed
16:06:17 <rally> surely bc is the natural language for skynet
16:06:23 <ReinH> I posit that the text processing facilities will allow enough metaprogramming for sentience to emerge
16:06:34 <merijn> ReinH: Did I hear someone asking for inscrutable sed scripts? :>
16:06:35 <chrisdone> whenever i see someone try to solve a problem in the shell
16:06:43 <chrisdone> and the answer comes back: … awk …
16:06:44 <ReinH> merijn: I've seen the chess engine :p
16:06:51 <chrisdone> then you know it's reached the limit
16:06:54 <chrisdone> and should be haskell
16:07:02 <merijn> ReinH: Oh, I was gonna look up my own backup parsing script
16:07:10 <merijn> I don't even understand how it works anymore...
16:07:16 <ReinH> merijn: o_O
16:07:17 <levi> The ideas behind PowerShell seem interesting, but I have never had occasion to really figure out whether I'd like using it.
16:07:18 <rally> True story: today I had to work out how to do set operations in the shell. Like, find the set of lines that are in one file but not in another.
16:07:22 <rally> It took me five whole minutes to give up.
16:07:34 <ReinH> lol sort | diff
16:07:39 <ReinH> sort | uniq | diff
16:07:41 <merijn> rally: I would immediately start either python or ghci for that :p
16:07:50 <chrisdone> rally: yay hell is perfect for you
16:08:00 <rally> I tried that! But the columns weren't in order.
16:08:05 <rally> It was a setset.
16:08:17 <ReinH> you just said set of lines :p
16:08:23 <rally> Oh, so I did.
16:08:39 <ReinH> you can't give me new requirements after I provide the solution!
16:08:42 <ReinH> That's not how waterfall works!
16:08:53 <rally> Yes I can! Otherwise I'd be useless as a manager!
16:09:04 <rally> I have to be seen to be doing something. That inspires confidence.
16:09:06 <ReinH> This presumes that managers can enter some other state.
16:09:24 <merijn> ReinH: You wanna know what's funny? The original paper about waterfall mentioned it as an example of a development model that clearly *can't* work :)
16:09:25 <hpc> https://dl.dropboxusercontent.com/u/37707/cahfgcfi.bmp -- waterfall development
16:09:34 <ReinH> merijn: I know :)
16:09:45 <ReinH> someone didn't read the findings
16:09:46 <Maxdamantus> cat foo | while read x; do fgrep "$x" bar >/dev/null || echo "$x"; done
16:09:50 <rally> I remember when images used to load up.
16:09:58 <hpc> rally: good times
16:10:06 <Maxdamantus> maybe with grep rather than fgrep and some anchors to ensure a whole line is matched.
16:10:06 <ReinH> Maxdamantus: nope :p
16:10:20 <ReinH> Maxdamantus: if it were just comparing lines, sort | uniq | diff would do just fine
16:10:20 <geekosaur> also, without the cat
16:10:27 <merijn> hpc: Won't open here
16:10:28 <geekosaur> while read x; do fgrep "$x" bar >/dev/null || echo "$x"; done < foo
16:10:28 <ReinH> useless use of cat award winner
16:10:46 <rally> something | cat | something
16:10:46 * Maxdamantus usually prefers to use cat in those sorts of cases.
16:10:51 <FireFly> rally: I think you're supposed to use cmp for that
16:10:58 <rally> cmp?
16:11:14 <FireFly> Hm, no, wrong command
16:11:18 <ReinH> FireFly: cmp is byte comparison
16:11:27 <ReinH> line comparison is... diff ;)
16:11:31 <rally> I discovered cmp today.
16:11:34 <jmcarthur_mobile> I ported some Haskell code that heavily uses laziness directly to OCaml today. Was a great argument for why lazy by default with explicit strictness is superior to strict by default with explicit laziness.
16:11:56 <FireFly> but.. there's another hting that's a bit like diff but specifically for outputting commands only in left, only in right, only in both, etc
16:11:56 <geekosaur> ReinH, diff is structured line comparison. comm?
16:12:01 <FireFly> Ah, comm!
16:12:11 <ReinH> oh yeah
16:12:19 <ReinH> jmcarthur_mobile: and not an argument that moving between paradigms in either direction is expensive?
16:12:20 <Maxdamantus> Yeah, I guess diff would work.
16:12:24 <jmcarthur_mobile> Ugh and sorry, s/lazy/non-strict/g s/laziness/non-strictness/g
16:12:45 <jmcarthur_mobile> ReinH: There was no paradigm shift involved.
16:12:46 <Maxdamantus> diff <(sort foo) <(sort bar) | grep ^\<
16:12:59 <Maxdamantus> maybe with uniq on each
16:13:03 <FireFly> comm -23 <(sort foo) <(sort bar)
16:13:04 <ReinH> jmcarthur_mobile: ok, moving between these two things that are paradigms but you refuse to call them paradigms so pick another word? :p
16:13:17 <jmcarthur_mobile> What the crap is a paradigm?
16:13:23 <ReinH> oh yeah I remember comm now
16:13:28 <rally> I don't know, but it sounds cool!
16:13:31 <rally> We should buy some.
16:13:35 * Maxdamantus didn't know about comm.
16:13:50 <ReinH> jmcarthur_mobile: ok, moving between strict-by-default and non-strict-by-default
16:13:54 <jmcarthur_mobile> I was simply strict and non-strict in the same places, where it mattered. Same paradigm.
16:13:55 <geekosaur> (there is also sdiff, for side by side diffs and merging)
16:14:00 <FireFly> I also learned today that Posix defines a `join` command that performs relational-database join
16:14:07 <FireFly> for all your shell-querying needs
16:14:12 <ReinH> jmcarthur_mobile: this is a silly argument :) I'll stop using paradigm.
16:14:12 <geekosaur> yes. and it predates POSIX even
16:14:14 <rally> That thing with the diffs and sorts might have actually done the trick, after ordering the columns. You're good at this.
16:14:21 <jmcarthur_mobile> ReinH: and now we're back to my original claim again ;)
16:14:33 <ReinH> jmcarthur_mobile: and I'm still challenging it :)
16:14:41 <jmcarthur_mobile> On what grounds?
16:14:46 <ReinH> jmcarthur_mobile: are you sure it wouldn't be equally expensive to move in either direction?
16:14:52 <Maxdamantus> There's an option in diff to only do one-line blocks, but I can't remember what it is.
16:14:52 <ReinH> vs one option being strictly superior?
16:14:53 <jmcarthur_mobile> Yes
16:15:01 <ReinH> jmcarthur_mobile: ok, can you expand on that a bit?
16:15:09 <Maxdamantus> so I'd've just done the first thing with `cat`.
16:15:11 <ReinH> jmcarthur_mobile: I'm genuinely curious
16:15:35 <Maxdamantus> unless there were a significant number of lines.
16:15:38 <jmcarthur_mobile> Strictness annotations are less finicky in practice that explicit thinking and forcing, and lazy by default is composable by default
16:15:55 <jmcarthur_mobile> s/that/than/
16:16:42 <jmcarthur_mobile> s/thinking/thunking/
16:17:18 <ReinH> jmcarthur_mobile: thanks
16:17:51 <jmcarthur_mobile> Not sure if I could fit a more elaborate argument into IRC via phone...
16:18:08 <ReinH> jmcarthur_mobile: am aware of your constraints :) thanks for the answer
16:20:21 <jmcarthur_mobile> Consider it this way. Porting OCaml code to Haskell can be done straightforwardly, just by adding some annotations. Porting Haskell to OCaml might not be so straightforward and might require rewriting common functions and data structures to fit the lazy style or redesigning the whole thing to fit the strict style
16:21:26 <chrisdone> that's true
16:22:09 <ReinH> jmcarthur_mobile: makes sense.
16:22:37 <donri> ReinH: https://en.wikipedia.org/wiki/RAS_syndrome
16:23:02 <ReinH> donri: yep :)
16:23:14 <chrisdone> quiz: what happens if you pipe something to `ls'?
16:23:33 <donri> "This CD disc contains NT technology" actual wording on windows installation discs
16:23:47 <chrisdone> lol
16:23:54 <geekosaur> ls ignores it, if the output you're sending to it is too big that program will block, eventually ls exits without reading and the other program takes SIGPIPE
16:23:58 <ReinH> "This compact CD disc..."
16:24:00 <jmcarthur_mobile> chrisdone: I will guess... Nothing?
16:24:14 <donri> ReinH: ...contains the new NT technology!
16:24:17 <ReinH> ls is not intended for programmatic use :)
16:24:19 <chrisdone> correct, it does nothing
16:24:36 <geekosaur> (if the output of the first program fit into the pipe then the first program does not take SIGPIPE and just vanishes)
16:24:49 <jmcarthur_mobile> If you want stdin as arguments, try xargs
16:24:49 <chrisdone> geekosaur: D:
16:25:07 <chrisdone> i don't -- i'm exploring the limits of the piping paradigm
16:25:07 <ReinH> and beware of stdin that contains spaces
16:25:48 <chrisdone> i'm writing a wrapper to ls, and noting that there's no reason its type should contain an stdin parameter. i was debating having a arrow-like pipeline and looking at shelly
16:26:06 <jmcarthur_mobile> Maybe ls is not a good representative.
16:26:06 <chrisdone> but it doesn't seem like that important of a metaphor when you have a real language at your shell
16:26:16 <jmcarthur_mobile> Yeah
16:26:29 <ReinH> typed composition > piping :)
16:27:44 <geekosaur> piping was a irst cut at composing programs. but because there's only one data type (octet stream), they are interinsically untyped
16:28:08 <chrisdone> nod. and there's a contention with stdin vs arguments
16:28:55 <ReinH> geekosaur: nope, they are monotyped :p
16:29:00 <ReinH> 6 of one...
16:29:00 <geekosaur> and environment, which is sometimes (ab)used as additional arguments (and in fact is handled almost parallel to the way arguments work)
16:29:13 <chrisdone> true, environment too
16:29:33 <ReinH> because composition is worthless without effects...
16:30:06 <chrisdone> what also annoys me about bash is that the most convenient character to press is the one i least want
16:30:14 <chrisdone> i almost never want ; and i almost always want &&
16:30:36 <chrisdone> if a script randomly fails in the middle i rarely want it to just go ahead anyway
16:30:49 <geekosaur> what you really want is set -e
16:30:55 <geekosaur> which in fact I use in most scripts
16:31:30 <geekosaur> (unfortunately POSIX broke it to some extent and bash honors that brokenness. it doesn't abort loops, just the current iteration)
16:32:20 <chrisdone> i've used set -e
16:32:25 <Peaker> chrisdone: did some backlog reading... for a shell, where you type more literal strings than variables, it may make sense to require escaping to get variables rather than to get strings (i.e: bash's "$" rather than Haskell's " )
16:32:28 <chrisdone> but i do sometimes want to ignore some things
16:32:46 <geekosaur> || :
16:32:59 <Peaker> it might be nice to have a Haskell shell, with the string-variable distinction reversed
16:33:48 <geekosaur> (: being a legacy whose only remaining use is that construct)
16:34:50 <ReinH> would someone please just write a shell monad so we can write our own shell languages?
16:35:22 <Peaker> geekosaur: "set -e" is good to know!
16:35:35 <Peaker> thanks
16:36:04 <Peaker> I guess I can remove all the "|| exit 1"   from the end of all my bash script lines :)
16:36:19 <chrisdone> haha
16:36:40 * chrisdone should start a “Say NO to bash” campaign
16:36:59 <joelteon> i don't actually know of any situation in which i'd want a script to keep running after a command failed
16:37:30 <chrisdone> joelteon: a trivial one is: killall xmonad -w; xmonad
16:37:39 <chrisdone> joelteon: i.e. to restart xmonad. you don't care that killall fails
16:37:43 <geekosaur> there are reasons. removing files after (or before) processing that might not be there, various other cleanups that might not be needed
16:37:55 <joelteon> that's what rm -f is for
16:38:10 <joelteon> well
16:38:13 <joelteon> ok
16:38:24 <chrisdone> yeah, kinda. rm -r will remove things that rm by itself won't
16:38:41 <chrisdone> (er, -f, sorry)
16:38:45 <joelteon> yeah
16:38:55 <geekosaur> yes. -f is a Big Hammer, sometimes too big
16:39:15 <chrisdone> i'm starting to shy away from -f
16:39:18 <geekosaur> `rm foo || :` is a smaller hammer and might avoid breaking glass
16:39:33 <joelteon> what we really need is haskell shell scripts
16:40:20 <haasn> it seems odd that there's no flag for “ignore nonexistant files, but still prompt”
16:40:21 <Peaker> chrisdone: here's a Python shell alternative from a Pythoneer friend of mine: http://tomerfiliba.com/blog/Plumbum/
16:41:05 <Maxdamantus> What we need is an OS with a functional filesystem, so you can execute commands in duplicated namespaces and merge when they complete correctly.
16:41:19 <donri> i just alias rm to trash-put :)
16:42:15 <chrisdone> Peaker: fun
16:43:47 <Peaker> the guy is a Haskeller at heart :) He does these elegant DSLs in Python.  I tried getting him over to Haskell, but he immediately tries to implement these advanced DSLs before he knows how to use the type system, proclaims it too difficult and goes back to Python
16:44:22 <hpc> python is too difficult, im going back to java
16:44:49 <monochrom> haskell's type system is pretty easy to me. even after adding all sorts of extensions.
16:45:18 <monochrom> not just is. also was, when I was learning.
16:45:52 <Peaker> monochrom: well, he tried implementing pickler combinators as his first Haskell attempt.. In Python, he wrote a popular pickler combinator library. So he can do it. But in Haskell, it is more difficult, because you also have to get it all well-typed, and it isn't trivial (and IMO, worth it)
16:46:11 <chrisdone> i came from scheme to haskell and started to write code without learning the type system and entered the expected pain
16:46:29 <Peaker> Pickler combinators are one of the harder things to design and implement in Haskell, IMO
16:46:31 <chrisdone> but i often learn things the hard way
16:48:34 <Peaker> Doing nice pickler combinators where you control the wire format, and which can also create C code to [de-]serialize the same structures - sounds like a nice project to me. But not a first Haskell project (Even if you just want to [de-]serialize)
16:51:13 <Peaker> in Python, he could just throw dynamically typed lambdas into fields that look at the dictionary of previous [de-]serialized data to decide the length of the next field. In Haskell, if you want to do it without ugly dynamic typing, you can't do that kind of thing
16:52:27 <chrisdone> oh, nice, i just thunk of something
16:52:44 <chrisdone> suppose
16:52:44 <chrisdone> ls :: Text -> IO Text
16:52:46 <Maxdamantus> thank*
16:53:09 <chrisdone> Maxdamantus: past tense of to thunk? =)
16:53:23 <Maxdamantus> no, to think.
16:53:30 <ReinH> chrisdone: | is kleisli composition :)
16:53:45 <Maxdamantus> I think I thank I'd thunk of that before.
16:53:56 <chrisdone> ReinH: a little bit, yeah, apart from all the other stuff
16:54:07 <chrisdone> anyway
16:54:31 <donri> I thunk, therefore I may become.
16:54:34 <chrisdone> suppose ls :: Text -> IO Text  then if i write ls SPC then the shell could insert "" and put my cursor inside the speech marks
16:54:39 <ReinH> cat "foo" >=> wc Lines
16:54:53 <chrisdone> so you'd just *type* ls foo  to get ls "foo"
16:54:59 <ReinH> because we need more fish operators
16:55:00 <chrisdone> how's that for a slice of fried gold?
16:56:08 * Maxdamantus suspects it'd be neater to just create a new syntax.
16:56:15 <chrisdone> go ahead
16:56:25 <chrisdone> i'm not giving up on haskell so easily =)
16:57:35 <enthropy> Peaker: my guess is you could give types to that kind of thing (which would become about as long as the data)
16:57:54 <ReinH> I for one welcome my new pipes-shell overlords
16:58:02 <Peaker> enthropy: maybe HList style, and it would be very difficult
16:59:09 <enthropy> well I imagine getting the dynamically typed version right is also difficult
16:59:57 * hackagebot highlighting-kate 0.5.5.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.5.1 (JohnMacFarlane)
17:01:14 <Maxdamantus> You'd probably have special implementations of common things like `ls', which won't deal with octet streams.
17:01:49 <Peaker> enthropy: Not as hard as getting the types right. Of course, you get no guarantees in all user code. The difficulty is there because you're creating a proof about *all* uses of the library. It's constraining and it's hard, but it's worth it.
17:02:05 <geekosaur> powershell actually has the right idea here (although not perhaps implemented as well as one could wish)
17:02:14 * monochrom looks at syntax design information-wise. you need one token to say what command you want ("ls" so far), and one token to say you want a specific directory rather than the default, and that token must say it's a directory name rather than a configuration option name. no amount of syntax design can go more minimal than that.
17:02:43 <thebnq> chrisdone: what if you could somehow define files and folders as types in scope
17:02:47 <geekosaur> unfortunately it's very much OOP, not functiona
17:02:49 <geekosaur> l
17:03:52 <monochrom> note also that computer security people will point out the vulnerability in "names become string literals iff the name is not in scope".
17:04:27 <Peaker> monochrom: imagine that the default action of a directory is to list it.  You could just name the directory, then
17:04:52 <Peaker> you basically need to huffman code the UI for the things you actually do
17:07:11 <monochrom> that is object-oriented heresy :)
17:07:13 <chrisdone> thebnq: sounds like a research project
17:08:45 <geekosaur> huffman code the UI. are we reinventing perl6 here?
17:08:55 <monochrom> haha
17:09:35 <Maxdamantus> if it begins with a `/' or a `.', it's a file.
17:09:51 <Peaker> geekosaur: well, you don't need to huffman code the character-level, but huffman coding the AST-level is probably a good idea, and to an extent, done by all languages (at least those that try to avoid being morbidly verbose)
17:11:20 <mangaba_leitosa> chrisdone: what do you do instead of bash? A haskell shell?
17:12:17 <chrisdone> mangaba_leitosa: yes
17:12:53 <mangaba_leitosa> chrisdone: hsh?
17:13:56 <chrisdone> mangaba_leitosa: presently, https://github.com/chrisdone/hell
17:14:16 <mangaba_leitosa> chrisdone: 'hell'? Do you recommend it? :-)
17:14:24 <chrisdone> no
17:14:29 <chrisdone> not yet
17:14:29 <mangaba_leitosa> why? :-)
17:14:31 <mangaba_leitosa> ah :-)
17:15:18 * mangaba_leitosa tried the haskell window manager, but it seems that it's strictly for tile layouts, weird
17:15:38 <monochrom> when one day it is mature and is ported to windows and becomes a dynamic library, we can say: hell.dll :)
17:15:42 <hpc> xmonad is a tiling wm
17:16:00 <mangaba_leitosa> hpc: yes, I tried it and got confused :-)
17:16:09 <mangaba_leitosa> hpc: why prefer a unique window layout? :-)
17:16:18 <hpc> i am told you get used to it
17:16:32 <Maxdamantus> Though it's not strictly for tile layouts.
17:17:05 <mangaba_leitosa> Maxdamantus: I didn't found any easy way to make overlapping windows, but I didn't try too harrd
17:17:07 <Maxdamantus> There'll layouts in contrib that do fairly conventional windowed window management.
17:17:08 <monochrom> clearly, xmonad authors can inflict on you whatever ideology they please.
17:17:50 <monochrom> it's free software. if you want a different ideology, you can always fork.
17:18:11 <chrisdone> =)
17:18:13 <mangaba_leitosa> monochrom: sure. But any software I use is free :-)
17:18:20 <Maxdamantus> or just implement a new Layout.
17:18:43 * mangaba_leitosa uses blackbox
17:19:07 * Maxdamantus tries SimpleFloat.
17:19:43 <mangaba_leitosa> blackbox is good because it has no cool features :-) Just the minimal functionality :-)
17:19:49 <Peaker> mangaba_leitosa: I always thought it was really silly how windows are generally created in arbitrary overlapping positions to obstruct each other while so much space on the screen is free
17:19:59 <codygman> I'm trying to show the first "Person" from an IO (Maybe [Person]) and getting an error: http://lpaste.net/96036
17:20:26 <Peaker> so I like the premise of xmonad, but I dislike the implementation (No focus stealing prevention, bad config API, apparent ignoring of all window size hints)
17:20:35 <mangaba_leitosa> Peaker: sure, but for strict tile layout, you need a really big monitor to see something in those numerous small windows :-)
17:20:36 <Iceland_jack> codygman: fromMaybe takes something of type Maybe ...
17:20:45 <Iceland_jack> codygman: is `allThePeople' of type Maybe ...?
17:21:04 <monochrom> I don't have so much space. it's merely 19-inch 1280x1024 here. and it is not free, I had to pay money for it.
17:21:05 <Peaker> mangaba_leitosa: I just use full screen everything in any wm in smaller displays.. xmonad is kinda irrelevant in that kind of setup, though, indeed :)
17:21:12 <codygman> Iceland_jack: No, it's IO (Maybe [Person]) which is my problem... not sure how to fix it.
17:21:34 <triliyn> codygman: also, the first argument to fromMaybe is a default
17:21:45 <mangaba_leitosa> Peaker: I mostly use full screen too :-)
17:21:46 <Iceland_jack> codygman: You can look to Learn You a Haskell for how to use IO
17:21:53 <chrisdone> i don't know how i worked without a tiling layout earlier without going insane
17:22:12 <monochrom> well, perhaps I am insane :)
17:22:22 <codygman> Iceland_jack: Alright, I will go look at LYAH again. I don't recall encountering this specific problem though, maybe I'm just forgetful? :D
17:22:33 <chrisdone> whenever i end up on compiz or something manually moving things with the mouse makes me almost instantly angry
17:22:35 <Iceland_jack> but if you want you can use something like:
17:22:35 <Iceland_jack>     main = do
17:22:35 <Iceland_jack>       people <- allThePeople
17:22:35 <Iceland_jack>       head (fromJust people)
17:22:38 <Iceland_jack>  
17:22:53 <Iceland_jack> or just
17:22:53 <Iceland_jack>     main = fmap (head . fromJust) alllThePeople
17:22:58 <Peaker> mangaba_leitosa: I do occasionally want multiple windows on the same display, and then xmonad is nicer than manually resizing stuff
17:23:13 * Maxdamantus only started using a tiling WM after his graphics card partially died so he couldn't run Compiz.
17:23:13 <chrisdone> chris:~/$ cd "Downloads/"
17:23:13 <chrisdone> chris:~/Downloads$ ls "*.pdf"
17:23:14 <chrisdone> loginpagewithquoteFinal.pdf  OSS1997-02-34.pdf	syb-opt-2014-pepm-submission.pdf
17:23:14 <chrisdone> chris:~/Downloads$ pdfinfo "syb-opt-2014-pepm-submission.pdf" >>= return . pdfInfoTitle
17:23:18 <chrisdone> Just "Optimizing SYB Is Easy!"
17:23:21 <chrisdone> =)
17:23:27 <Peaker> especially as most WMs require you to drag these 2 pixels from the window edge that I never manage to actually hit, it takes me like 10 sec to actually hit the right pixel
17:23:37 <Peaker> Always yelling at things :)
17:23:46 <chrisdone> Peaker: exactly
17:24:08 <monochrom> wait, what is the type of pdfIntoTitle?
17:24:13 <k00mi> I normally have 1 to 4 windows per screen on 15", I'd go nuts if I had to arrange everything manually every time
17:24:17 <chrisdone> monochrom: Maybe String
17:24:18 <quchen> chrisdone: "\nHLint for your console™: use fmap!"
17:24:27 <mangaba_leitosa> Peaker: blackbox uses 5 pixels I guess :-)
17:24:49 <Peaker> mangaba_leitosa: still, dragging is so slow. some WMs at least let you alt-rightclick to resize quickly
17:25:14 <monochrom> you could pdfInfoTitle <$> pdfinfo "syb-opt-2014-pepm-submission.pdf", you know? :)
17:25:29 <chrisdone> of course
17:25:57 <chrisdone> i was giving it a "shelly" feel
17:26:16 <chrisdone> probably <&> would be better
17:26:52 <chrisdone> tho, as it's a shell, i can use one of the single-key operators
17:27:04 <Maxdamantus> You mean <|>?
17:27:11 <chrisdone> no?
17:27:15 <chrisdone> <|> is choice
17:27:27 <Maxdamantus> Thought you wanted something shelly.
17:27:59 <chrisdone> i'd prefer a single key. we're not subject to normal haskell namespacing issues in a shell thankfully
17:29:07 <Maxdamantus> Oh, <&> as in flip <$> (<$>) or whatever.
17:29:09 <chrisdone> i'm seeing that there are going to be two types of commands in this shell: those that just run commands (e.g. ls, man, shutdown) and those that have proper type-safe Haskell wrappers, like pdfinfo
17:29:13 <chrisdone> Maxdamantus: yeah
17:30:20 <Maxdamantus> er, the first <$> shouldn't've been there.
17:31:10 <chrisdone> maybe i should make a hell-contrib package that contains all these type-safe wrappers
17:38:03 <joeyh> well, if you consider ls -l to return [LongLsInfo], I might want to `sort mtime <$> ls Long`, as just one example
17:43:46 <chrisdone> joeyh: yeah, exactly. type-safe versions are way nicer than stringly typed ones. but at that point you wouldn't be calling ls, you'd be using System.Directory-based functions
17:45:13 <joeyh> well, in my example, I'd still like to see the ls output, just sorted
17:45:14 <chrisdone> (unless someone's made a nice type-safe wrapper to ls to take advantage of its speed)
17:45:25 <chrisdone> ah, then burn the witch, etc.
17:46:56 <joeyh> if LongLsInfo contains both the parsed data and the original line ls output, it could be done
17:47:33 <geekosaur> parsing ls output is a fool's errand
17:47:33 <monochrom> give LongLsInfo a show instance or two :)
17:47:43 <Maxdamantus> Why not just make the extra stat information part of how you display directory entries when they're returned to the shell?
17:47:44 <joeyh> geekosaur: sssh
17:50:11 <chrisdone> geekosaur: yeah. parsing pdfinfo is reliable, i have no confidence for tools like ls
17:52:34 <ReinH> your periodic reminder that ls is not for programmatic use
17:52:54 <hpc> ReinH: you have to pipe it through cat first ;)
17:53:05 * geekosaur *eyeroll*
17:53:30 <chrisdone> is it caturday? ^_^
17:55:44 <lpaste> jrmithdobbs pasted “No title” at http://lpaste.net/3330523473331093504
17:56:09 <jrmithdobbs> i can't decide which is scariest, that i wrote that, that it works as intended, or that I understand it.
17:58:00 <Peaker> jrmithdobbs: (return . f =<<)   is   fmap f
17:58:08 <chrisdone> yeah the operators use there is wack
17:58:21 <ReinH> needs more fmap . fmap
17:58:32 <Peaker> (fromGeoIPRecord <$>)   is   fmap fromGeoIPRecord
17:58:32 <ReinH> or fmap fmap fmap
17:58:34 <ReinH> or something
17:58:55 <Peaker> (fmap . fmap . fmap) fromGeoIPRecord geoLookupByString   :)
17:59:06 <chrisdone> fmap (fmap fromGeoIPRecord) . geoLookupByString
17:59:08 <chrisdone> ^ clearest to me
17:59:16 <ReinH> yeah so fmap (fmap fromGeoIPRecord) . geoLookupByString ?
17:59:18 <ReinH> seems good
17:59:18 <Peaker> yeah, use that
17:59:32 <Peaker> though I do like (fmap . fmap), less parens to add if you have the third fmap
17:59:48 <ReinH> (.: fromGeoIPRecord) . geoLookupByString
17:59:59 <Peaker> Is .: generalized to any Functor?
18:00:02 <chrisdone> ReinH: is that right?
18:00:04 <chrisdone> :t (.:)
18:00:06 <lambdabot>     Not in scope: `.:'
18:00:06 <lambdabot>     Perhaps you meant one of these:
18:00:06 <lambdabot>       `.' (imported from Data.Function),
18:00:08 <ReinH> it isn't a thing
18:00:13 <chrisdone> WHY does lambdabot never have that
18:00:14 <ReinH> but it's commonly defined as fmap fmap fmap
18:00:17 <jrmithdobbs> Peaker: i think my mind may have exploded a little from that realiation
18:00:21 <jrmithdobbs> realization
18:00:22 <chrisdone> ReinH: ah, ok
18:00:32 <ReinH> it's been @let here a few times
18:00:37 <ReinH> but lambdabot keeps forgetting :/
18:00:48 <Peaker> jrmithdobbs: that   (return . f =<<)  is   fmap f ?
18:01:33 <Peaker> jrmithdobbs: (>>=) is about combining effects of the two relevant actions.   If one of those actions is built with "return", which is about having no action at all, then (>>=) degenerates into fmap
18:01:35 <jrmithdobbs> Peaker: that I stared at that for 30 minutes and didn't realize i wrote fmap the long way
18:02:10 <ReinH> heh
18:02:15 <ReinH> I do things like that a lot
18:02:26 <chrisdone> “My name’s Terry Pratchett, and I have Alzheimer’s disease. At least, I think I do.”
18:02:31 <ReinH> for instance I wrote mapMaybes the long way and chrisdone just corrected it for me today
18:04:03 <monochrom> don't feel bad about not finding the shortest path on your own. Kolmogorov told you it's a really hard problem. :)
18:04:20 <ReinH> monochrom: :p
18:04:52 <ReinH> monochrom: I mean hell, he could have just read some Shannon and saved himself some time too.
18:05:51 <monochrom> the Cold War probably caused some obstacle for him
18:07:41 <ReinH> Oh indeed. There's a lot of really interesting history there :)
18:08:13 <ReinH> One wonders if we'd have arrived at the entropy - information - complexity correspondence as quickly without him working so independently
18:08:18 <ReinH> maybe not "one", but I do.
18:21:56 <xiamx>  Couldn't match type `[Char]' with `case-insensitive-1.0.0.1:Data.CaseInsensitive.CI ByteString' > what should I do ?
18:24:28 <lpaste> blueonyx pasted “Lens compile error” at http://lpaste.net/96039
18:25:24 <blueonyx> tried chrisdone's code frome https://gist.github.com/mkozakov/59af0fd5bddbed1a0399 but got this error ^^ how to fix?
18:28:12 <blueonyx> erm error line is actually 12
18:28:36 <lpaste> blueonyx revised “Lens compile error”: “No title” at http://lpaste.net/96039
18:37:28 <Peaker> blueonyx: the problem is that type inference infers a "Rank1 Type" by default, which means the lens is *either* a getter or a setter, but it can't be both.  You can:
18:38:32 <Peaker> oh whoops, the error seems more basic than that
18:39:01 <Peaker> blueonyx: enable -Wall and get rid of all the shadowing, it just confused me to hell :)
18:39:59 <joelteon> always use -Wall!
18:40:15 <Peaker> blueonyx: l = cloneLens ln    needs a type signature, or you need NoMonomorphismRestriction, or you need to duplicate it to both uses of l
18:40:32 <hpc> all in all you're just another brick in the -Wall
18:41:42 <Peaker> blueonyx: the problem is that "l" becomes a lens with its 'f' set to a particular thing (Mutator OR Accessor) and it cannot be polymorphic to both.  I think disabling the dreaded MR should make it polymorphic again, or if not, a type signature surely will
18:41:57 <blueonyx> Peaker: ah thanks
18:44:43 <ReinH>  /win 28
18:44:45 <ReinH> woops
18:45:23 <blueonyx> wow its even memory leaking what am i doing wrong chrisdone xD
18:45:35 <codygman> How would I turn my pizzaLovers and drinkers functions into "Maybe [Person] -> Maybe [Person]" so that I can compose them?
18:45:47 <codygman> http://lpaste.net/96041
18:47:17 <chrisdone> blueonyx: did you sacrifice any goats?
18:48:24 <scott_> codygman: pizzaLovers = fmap (filter likesPizza)
18:48:46 <ion> Never use fromJust
18:48:48 <scott_> This way it won't crash on Nothing, unlike fromJust
18:50:22 * chrisdone looks through his .bash_history to see what commands he needs to bind
18:50:56 <blueonyx> so thats how you get into lenses, kthx
18:51:27 <chrisdone> blueonyx: memory leaking?
18:53:11 <blueonyx> yea on some inputs
18:57:03 <chrisdone> blueonyx: what does that mean?
19:00:32 <blueonyx> chrisdone: i use this from QuickCheck to generate a bigger sample: xs <- (V.fromList . head) `fmap` sample' (map getNonNegative `fmap` (resize 10000 $ listOf $ resize 10 $ variant 3 arbitrary))
19:01:10 <blueonyx> chrisdone: and 2 out of maybe 20 tries i got an answer instead of a memory leak
19:02:12 <redscare> in languages like common lisp it is possible to write a macro that automatically converts a function, recursive or not, to a memoized version. is something like this possible in haskell?
19:06:21 <chrisdone> blueonyx: what's a memory leak here?
19:07:05 <blueonyx> chrisdone: it eats all memory until it gets killed
19:07:36 <blueonyx> like more than 2GB
19:08:35 <chrisdone> blueonyx: i expect there's an infinite loop being created
19:09:01 <alexander__b> https://secure.plaimi.net/~alexander/tmp/2013-11-23-035454_1920x1080_scrot.png -- is there a way to make ghc-mod/syntastic/vim actually *do* this instead of only suggesting it? great suggestions, but I have to do them manually? really?
19:09:06 <chrisdone> although excessive memory use isn't that surprising either
19:09:54 <chrisdone> alexander__b: i think learning some vimscript would be a valuable investment
19:10:21 <alexander__b> chrisdone: no, finding an addon by someone who knows more vimscript than me would. ;-) I'm too busy for that.
19:11:18 <chrisdone> alexander__b: something like that is a five minute job in emacs
19:11:56 <chrisdone> it's pretty sad not to be able to extend your environment to suite your needs
19:15:37 <xiamx> Couldn't match type `[Char]' with `case-insensitive-1.0.0.1:Data.CaseInsensitive.CI ByteString' > what should I do ?
19:18:17 <chrisdone> xiamx: use (mk (fromString "your [char] value"))
19:18:19 <chrisdone> xiamx: http://hackage.haskell.org/package/case-insensitive-1.1.0.1/docs/Data-CaseInsensitive.html
19:18:48 <chrisdone> xiamx: or vise-versa
19:36:29 <xiamx> chrisdone: thx
19:39:01 <Aetherspawn> :t Word
19:39:02 <lambdabot> Keyword
19:39:06 <Aetherspawn> :t Int
19:39:07 <lambdabot>     Not in scope: data constructor `Int'
19:39:07 <lambdabot>     Perhaps you meant one of these:
19:39:07 <lambdabot>       `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
19:39:23 <copumpkin> > Word
19:39:25 <lambdabot>   Word
19:39:29 <Aetherspawn> wtf is Word
19:39:31 <copumpkin> > Werd
19:39:32 <lambdabot>   Not in scope: data constructor `Werd'
19:39:32 <lambdabot>  Perhaps you meant `Word' (imported f...
19:39:36 <copumpkin> ugh
19:39:44 <copumpkin> not a very useful perhaps message, mr lambdabot
19:39:47 <copumpkin> mrs?
19:39:50 <copumpkin> who cares
19:53:28 <brandon`> is it possible that either readFile or appendFile leave the file opened?
19:54:49 <zomg> brandon`: don't think so but it's possible that due to laziness they don't run when you think they do
19:55:00 <zomg> which could cause issues which might look like the file was left open
19:55:14 <geekosaur> readFile is lazy, so it could in some circumstances leave the file open until the next major garbage collection
19:56:33 <athan> hello fellow haskellers
19:57:30 <athan> can someone help me with understanding strict declarations with a higher-order data type?
19:57:44 <athan> the code itself is very simple
19:58:29 <athan> http://lpaste.net/96043
19:58:33 <athan> my question is:
19:59:08 <athan> when using `bcVector` and `bcRest`, does the `res` parameter need to be evaluated immediately aswell?
20:00:15 <athan> er
20:01:09 <benzrf> hello!
20:01:10 <athan> if I call some Vector function that uses the result of bcVector, but doesn't necessarilly use it's contents, does the whole value need to be strictly evaluated (parameter as well)?
20:01:15 <athan> hi!
20:01:39 <benzrf> when is it appropriate to use multiple constructors and pattern matching, and when is it appropriate to use multiple types and typeclasses?
20:02:28 <enthropy> athan: depends how PieceMap works
20:02:30 <athan> - when you want functionality at run time vs. functionality (and organization) at compile time.
20:02:57 <enthropy> if you have field like   ![Int], that can be   1:undefined just fine
20:03:07 <enthropy> the ! is just a seq not a rwhnf
20:03:31 <athan> ahhh hm.
20:03:41 <athan> I need to look those up / read real world haskell
20:04:06 <athan> i just finished the haskell performance wiki series as an intro to the topic
20:04:09 <scott_> enthropy: What's the r in rwhnf?
20:04:21 <enthropy> what the function is called?
20:04:26 <enthropy> @type rnf
20:04:27 <lambdabot> Not in scope: `rnf'
20:04:28 <athan> _really_ weak..
20:04:29 <athan> lol
20:04:31 <enthropy> @type rwhnf
20:04:31 <lambdabot> Not in scope: `rwhnf'
20:04:58 <copumpkin> chrisdone: did you see http://www.staff.science.uu.nl/~swier004/Publications/PolymorphicDynamics.pdf ?
20:05:12 <benzrf> Really Weak Normal Head Form?
20:05:13 <enthropy> scott_: reduce I suppose
20:05:45 <copumpkin> chrisdone: granted, it's in Agda, but it's relevant to what you wanted :)
20:05:46 <copumpkin> might be interesting
20:09:48 <athan> Is there a way to force a _result_ from a function, and not just strictness parametrically?
20:10:02 <athan> is there a way to make a strict result?
20:10:23 <athan> or is it all by-need? Man this is confusing :S
20:11:08 <joelteon> deepseq?
20:12:55 <benzrf> athan: why do you need this
20:13:24 <benzrf> > atan 1
20:13:25 <lambdabot>   0.7853981633974483
20:13:56 <benzrf> whyd you pm me instead of just typing back
20:13:57 <benzrf> ?
20:14:13 <athan> wat
20:14:27 <athan> my bad haha i thought you just pm'd me
20:14:31 <athan> irc noob
20:14:36 <athan> my bad
20:16:54 <codygman> ion: You said never use fromJust? What am I supposed to use for maybe values instead? Say for turning them into lists... that is Maybe [a] -> [a]
20:17:15 <benzrf> codygman: catMaybes?
20:17:20 <benzrf> :t catMaybes
20:17:21 <lambdabot> [Maybe a] -> [a]
20:17:23 <nisstyre> codygman: don't use fromJust
20:17:24 <nisstyre> ever
20:17:35 <benzrf> nisstyre: why not
20:17:37 <copumpkin> if you like runtime exceptions and want one
20:17:41 <copumpkin> then perhaps use fromJust
20:17:41 <nisstyre> benzrf: partial function
20:17:49 <benzrf> hm?
20:17:49 <scott_> codygman: The point of Maybe is to deal with the possibility of missing values. If you use fromJust you ignore that case and just crash when you get Nothing... so why are you using Maybe anyways?
20:17:58 <nisstyre> benzrf: it's not defined for all possible inputs
20:18:04 <benzrf> ah
20:18:17 <nisstyre> benzrf: catMaybes or sequence are better
20:18:53 <ReinH> aaaaand I'm done editing the next episode of the haskell cast
20:18:56 <ReinH> chrisdone: ^
20:19:02 <nisstyre> depending on what you want done
20:19:50 <ReinH> codygman: in order to answer that question you need to decide what Nothing means and what you want to do with it.
20:19:52 <ion> codygman: Pattern matching. fmap :: (a -> b) -> Maybe a -> Maybe b. maybe/fromMaybe. etc.
20:20:08 <ReinH> fromJust says "I want my program to crash", which is probably not what you mean.
20:20:43 <benzrf> bye
20:22:25 <udevd> hi! i wanted to use haskell98 Random package, what should i do in order to do it? When i simply put :m + Random in GHCI, i get
20:22:33 <udevd> <no location info>: Could not find module `Random' It is a member of the hidden package `haskell98-2.0.0.1'.
20:22:50 <geekosaur> you should not be using the haskell98 package unless you are running in haskell98 mode
20:23:10 <geekosaur> because it requires the haskell98 Prelude which is incompatible with the regular Prelude (which is why the package is hidden)
20:23:16 <udevd> mhm
20:23:35 <Cale> udevd: If you're being practical about things, use System.Random
20:23:48 <udevd> so what should i use to generate random numbers? Monadic approach of Data.Random doesn't fit my use
20:23:50 <Cale> (Which is the newer version of the Haskell 98 Random module)
20:23:51 <udevd> okay, thanks
20:26:40 <codygman> scott_, ReinH: I was using maybe because it's what aeson gave me... so from my understanding I can use catMaybe or pattern matching to throw away the nothing values?
20:26:56 <ReinH> :t catMaybe
20:26:57 <lambdabot>     Not in scope: `catMaybe'
20:26:57 <lambdabot>     Perhaps you meant one of these:
20:26:57 <lambdabot>       `catMaybes' (imported from Data.Maybe),
20:27:01 <ReinH> :t catMaybes
20:27:02 <lambdabot> [Maybe a] -> [a]
20:27:06 <ReinH> yes
20:27:12 <ReinH> > catMaybes [Just 1, Nothing]
20:27:13 <lambdabot>   [1]
20:28:20 <ReinH> You can also use its functor or monad behavior
20:28:40 <ReinH> > fmap succ Nothing
20:28:42 <lambdabot>   Nothing
20:29:48 <Aetherspawn> maybe someone who does a lot of parsing can help me with this issue I've been facing for the last couple days: http://stackoverflow.com/questions/20139957/haskell-trifecta-parsing-completely-optional-semicolons-without-polluting-ast thanks in advance.
20:29:53 <ReinH> > lookup "foo" [] >>= flip lookup []
20:29:55 <lambdabot>   Nothing
20:30:15 <chrisdone> copumpkin: thanks!
20:30:31 <chrisdone> i just ordered a kobo hd. i'll be able to read papers with it \o/
20:31:56 <copumpkin> oh I've wanted something like that for a while
20:32:09 <ReinH> I use my iPad. Works pretty well
20:32:27 <copumpkin> oh I thought it was a full page reader
20:33:57 <chrisdone> yeah it fits half a page in at full zoom, but from the demos i saw it's very usable
20:34:31 <chrisdone> https://www.youtube.com/watch?v=pPFfw2sNQ_c&t=12m50s
20:39:39 <chrisdone> also has landscape view, for the kind of PDF you just linked me https://www.youtube.com/watch?v=KMKvDBE7e84
20:39:54 * chrisdone so excited
20:40:18 <scott_> chrisdone: Have you owned any e-readers before this?
20:41:27 <brandon`> sorry I was away
20:41:30 <chrisdone> scott_: i had two sony readers
20:41:31 <brandon`> <geekosaur> readFile is lazy, so it could in some circumstances leave the file open until the next major garbage collection
20:41:51 <brandon`> how do I handle this? I want the file to be read as soon as I assign the result to text
20:42:16 <geekosaur> you have to look at the entire content then
20:42:38 <geekosaur> e.g. force the length or something
20:42:46 <scott_> chrisdone: I have a kobo glo right now, and it's quite nice
20:43:00 <scott_> I haven't tried it with PDFs yet, though
20:43:19 <brandon`> do text = readFile path; return (length text) } <- like this?
20:43:32 <brandon`> do text = readFile path; return (length text) {-- more code --} }
20:45:06 <geekosaur> return doesn't force it
20:45:17 <ReinH> brandon`: this seems like a job for non-lazy IO?
20:45:28 <geekosaur> return $! length text -- might
20:45:32 <brandon`> ReinH yes. I
20:45:52 <brandon`> might? :-O
20:46:13 <chrisdone> scott_: i got one of the first readers to come out in 2006, for some 350gbp, which was beautifully made and usable. then i got the prs-600 last year which was the first touch screen version of the sony reader, a product which they kind of ruined by making the screen *far* too shiny, you spend most of your time trying to find an angle where you're not distracted by reflections. recent sony's fixed this, and the kindle paperwhite, and
20:46:14 <chrisdone> kobo glo, made it even better with the lighting. the kobo hd is like the paperwhite but seemingly far better PDF reading capabilities and much high resolution, higher dpi and larger screen. i'm looking forward to its arrival <3
20:46:20 * geekosaur has not worked the whole thing through and is about to fall on his nose; probably better to ask someone else
20:46:44 <ReinH> something something iteratee? I mean conduits? I mean pipes?
20:46:58 <geekosaur> isn't iteratee kinda dead now?
20:47:02 <ReinH> geekosaur: totes
20:47:16 <ReinH> geekosaur: yeah it's been replaced by pipes/conduits afaik
20:47:21 <codygman> I wasn't sure how to use pattern matching on my Maybe [a] values or fmap, but I did manage to make *something* work. Any other suggestions about my code would help too: http://lpaste.net/96047
20:47:27 <brandon`> which one do you recommend of the two?
20:47:32 <chrisdone> there's also io-streams
20:48:25 <chrisdone> brandon`: you just want to read a file in strictly?
20:48:47 <scott_> codygman: head . maybeToList is equivalent to (and just as bad as) fromJust
20:48:53 <brandon`> yes. it needs to happen as soon as I call read
20:48:55 <brandon`> readFile
20:49:00 <chrisdone> brandon`: Text or ByteString?
20:49:07 <brandon`> String
20:49:14 <chrisdone> mm. sucky
20:49:27 <chrisdone> use the strict package if you must use String
20:49:39 <brandon`> what if I used Text? out of curiosity
20:49:41 <chrisdone> http://hackage.haskell.org/package/strict-0.3.2/docs/System-IO-Strict.html#v:readFile
20:49:52 <chrisdone> then Text has strict IO out of the box
20:50:01 <chrisdone> Data.Text.IO.readFile
20:50:14 <brandon`> ok cool
20:50:56 <brandon`> is Text always recommended over String? I am parsing a small file
20:51:32 <codygman> scott_: I thought it was. What would you recommend in my code? I've been trying to come up with a different solution but can't seem to. Perhaps I need to read up on pattern matching? Are things grouped weird/wrong?
20:51:50 <chrisdone> it's a use your discretion thing, but you need some experience to use your discretion
20:52:05 <chrisdone> the text package has sensible, predictable IO and some helpful string manipulation functions
20:52:26 <chrisdone> and you'll find that more modern, stable packages will expect Text's rather than Strings
20:53:07 <chrisdone> you also know that when you have a Text, it's already been decoded properly
20:53:10 <Aetherspawn> isn't Text just like ByteString but wider?
20:53:13 <chrisdone> Strings can sometimes get mixed up
20:53:30 <Aetherspawn> so it shouldn't be a question of String/Text but really String/ByteString *and then* Text
20:53:36 <scott_> codygman: Try something like this: http://lpaste.net/96047
20:54:32 <chrisdone> Aetherspawn: it's more like Text or ByteString. String's general use is questionable
20:55:08 <chrisdone> Aetherspawn: text is for "text", ByteString is not really for strings as normally expected, it's better thought of as a byte array. for binary data
20:55:54 <chrisdone> you don't need to go through String to get to Text or ByteString, either. both packages have IO functions
20:56:11 <brandon`> does Text have only strict IO?
20:56:19 <chrisdone> no, it has lazy IO too
20:56:25 <brandon`> cool
20:56:33 <chrisdone> see the module hierarchy
20:56:48 <brandon`> I'll use String for now as that's what I'm comfortable will. I'll check out Text when I do some heavier parsing
20:57:22 <chrisdone> we should start updating haskell books to settle this matter once and for all…
20:58:06 <chrisdone> newbies keep coming in using Strings and lazy I/O and wondering why everything is such a PITA
21:00:53 <brandon`> is using lazy IO a good idea in some cases?
21:10:21 <chrisdone> brandon`: sometimes, when you're working with a stream and you don't want to/can't read it all in at once. it'll be read in as chunks as if you manually did a hGetBuf repeatedly in a loop
21:13:49 <brandon`> I notice that there is only readFile in the System.IO.Strict. I take it there are no similar issues with writing functions like writeFile and appendFile? it appears to work fine, but I am becoming paranoid now.
21:19:24 <frege> guys is there a map reduce framework in haskell?
21:21:50 <udevd> > replicate 10 'a'
21:21:51 <lambdabot>   "aaaaaaaaaa"
21:26:16 <chrisdone> brandon`: yeah writing is fine
21:28:00 <ReinH> frege: you mean something other than `foldr1 f . fmap g'? :p
21:32:21 <roconnor> brandon`: I find lazy IO acceptable when I either write main = interact foo or I plan on opening at most one file in my application ever.
21:53:50 <brandon`> I am still having two issues with laziness. why is the first lookup taking so long? is reading the file taking place after I type the first word, or just parsing? how do ensure both (reading and parsing) are done before readInput is called?
21:54:05 <brandon`> http://lpaste.net/96049
21:56:05 <brandon`> print (Map.size wordsMap) does it but I would rather not print anything unnecessary
21:57:20 <ReinH> brandon`: btw you don't want type Map = Map.Map. You want import Data.Map (Map)
21:57:51 <brandon`> thanks I wasn't too happy about that one
21:59:10 <Twey> brandon`: You don't have to print it.  There are other ways to force a value (like Control.Exception.evaluate, but make sure you evaluate something that will actually force it, like its length)
21:59:21 <Twey> (well, the spine, but that's probably enough)
21:59:40 <brandon`> was it just the parsing that was delayed, not the reading?
21:59:41 <Twey> brandon`: Lazy IO is recommended against for various reasons; a better way to do it would be using something like Pipes
21:59:49 <Twey> The reading is delayed with readFile
22:00:02 <brandon`> but I am using strict io..
22:00:13 <Twey> Oh, you're right, sorry
22:00:31 <brandon`> so was it just the parsing that was delayed then?
22:00:46 <Twey> Yes
22:01:37 <ReinH> well
22:01:50 <ReinH> It seems that readFile can be evaluated whenever GHC decides to evaluate it
22:02:00 <ReinH> It's the behavior of opening, reading and closing the file that is strict
22:02:24 <ReinH> brandon`: in other words, unless you force the evaluation of readFile earlier, it will be evaluated Just In Time
22:02:29 <brandon`> yeah i see
22:02:38 <ReinH> which means not necessarily before readInput
22:02:40 <Twey> There wouldn't be much point in reading everything, putting it somewhere, then storing an unevaluated thunk to it, would there?
22:03:04 <Twey> I assume System.IO.Strict does what it says on the tin
22:03:06 <ReinH> in fact, as far as GHC is concerned, it would be pessimal to read the file initially
22:03:16 <ReinH> given that you might never use the result
22:03:28 <ReinH> so it's still being lazy in that regard
22:03:40 <ReinH> the strictness comes into play after GHC "decides" to evaluate readFile
22:03:52 <Twey> Huh, really?
22:03:57 <udevd> is there a strict version of iterate? it can be defined easy, but i don't want to double it
22:03:58 <ReinH> Twey: why not?
22:04:03 <ReinH> Twey: how would it be otherwise?
22:04:24 <Twey> « Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is immediate closed. »
22:04:43 <ReinH> Twey: ok?
22:04:47 <Twey> ReinH: I'd say the file is opened, read into memory, and closed, before the next action
22:04:59 <ReinH> Twey: I'd say it is opened, read and closed upon evaluation
22:05:02 <ReinH> We can do a simple test
22:05:12 <ReinH> run readFile on a 1GB file and throw away the result
22:05:14 <Twey> ReinH: But the docs disagree with you: ‘immediately closed’
22:05:19 <ReinH> Twey: no, they don't
22:05:21 <Twey> Fair enough
22:05:28 <ReinH> that can be interpreted as "immediately upon being read"
22:06:13 <Twey> Mm, I don't think so
22:06:15 <udevd> @def  iterate' f x = x seq x : iterate' f (f x)
22:06:16 <lambdabot>  .L.hs:149:22:
22:06:17 <lambdabot>      Occurs check: cannot construct the infinite type:
22:06:17 <lambdabot>        ...
22:06:20 <udevd> mh
22:06:22 <Twey> « Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is immediate closed. »
22:06:27 <Twey> But I'll run it on a big file and see
22:06:32 <udevd> ah
22:06:32 * Twey installs
22:06:42 <udevd> >closed propasl (wontfix)
22:07:33 <Maxdamantus> Maybe the handle is closed so you can't read from it again.
22:07:38 <Twey> Unless ‘immediate closed’ is a technical term and not a grammatical error, I'd say that ‘immediately’ means ‘immediately’, not ‘immediately after reading’
22:07:56 <ReinH> Twey: it is ambiguous
22:08:03 <Twey> Maxdamantus: If the handle is closed then the reading is done; there's a special state for lazy-IO–bound handles
22:08:07 <Maxdamantus> it would be irrelevant whether the underlying, unreachable OS handle is closed.
22:08:08 <ReinH> Twey: consider...
22:08:16 <ReinH> Twey: it must mean immediately upon reading
22:08:24 <ReinH> since there is no possible earlier time for closing to occur
22:08:37 <ReinH> "immediately closed" does not imply anything about when that read happens
22:08:48 <Twey> ReinH: Well, yes, but the reading must occur immediately (i.e. before the next action) in order for it to be closed immediately
22:08:55 <ReinH> Not by my reading
22:09:00 <brandon`> it does appear that S.readFile forces reading. I can notice a slight delay compared to if I replace it with readFile
22:09:00 <ReinH> and not based on observable behavior :p
22:09:09 <ReinH> hmm
22:09:35 <Maxdamantus> you won't be able to hGetChar on the handle after doing hGetContents, because the handle is closed.
22:09:44 <ReinH> ah, hGetContents uses a seq on the length
22:09:50 <Maxdamantus> whether the file from disk is read lazily is another matter.
22:10:28 <Maxdamantus> I think there are strict and lazy versions of hGetContents though.
22:10:41 <ReinH> the underlying mechanism is: hGetContents h  = IO.hGetContents h >>= \s -> length s `seq` return s
22:11:00 <ReinH> so at what point is that evaluated?
22:11:04 <Maxdamantus> “In this state, hdl is effectively closed, but items are read from hdl on demand and accumulated in a special list returned by hGetContents hdl.”
22:11:23 <Maxdamantus> Oh, you're talking about the strict one.
22:11:27 <Maxdamantus> nvm me
22:11:28 <ReinH> Maxdamantus: yes
22:11:58 <Twey> *** Exception: <filename>: hGetContents: invalid argument (invalid byte sequence)
22:12:12 <Aetherspawn> brandon`: you can use BangPatterns there I believe
22:12:25 <Twey> From: foo <- S.readFile "<filename>"
22:12:34 <Twey> ReinH: I reckon that's strict
22:12:41 <ReinH> Twey: without forcing foo?
22:12:53 <ReinH> evidence > reasoning :)
22:12:57 <Twey> ReinH: Yes
22:13:12 <ReinH> alright then
22:13:31 * ReinH still thinks the docs are ambiguous...
22:13:36 <Twey> ReinH: They're not :þ
22:13:45 <ReinH> yay now we can argue about something again
22:13:50 <Twey> \o/
22:13:52 <ReinH> and this time it's subjective so we can argue forever
22:13:55 <ReinH> \o/
22:14:04 <udevd> do anyone know why isnt strict iterate in Data.List? strange for me
22:14:20 <brandon`> I have another weird issue with the same program, even weirder one :)
22:14:21 <ReinH> udevd: if it were strict, how would this work?
22:14:25 <Twey> I don't think it is.  There's no mention of closing *after reading* in the docs — in fact, there's no mention of reading at all.  It just says the file is immediately closed.
22:14:38 <ReinH> > take 10 $ iterate succ 1 -- udevd
22:14:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:14:49 <udevd> @def iterate' f x = x `seq` (x : iterate' f (f x))
22:14:51 <lambdabot>  Defined.
22:14:51 <Twey> The only useful interpretation (that returns a result :þ) is that it's immediately read and then closed
22:15:04 <udevd> > iterate (+1) 0 !! 1000000000
22:15:06 <Twey> I guess it *could* just return () and close the handle, but that would be a bit unhelpful.
22:15:09 <lambdabot>   mueval: ExitFailure 1
22:15:09 <lambdabot>  mueval: Prelude.undefined
22:15:12 <ReinH> > take 10 $ iterate' succ 1
22:15:13 <udevd> > iterate' (+1) 0 !! 1000000000
22:15:14 <lambdabot>   can't find file: L.hs
22:15:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:15:39 <ReinH> udevd: seq doesn't make it strict in the way you expect
22:15:40 <udevd> it may be too much for poor lambdabot, but difference can be seen for smaller numbers
22:15:44 <udevd> > iterate' (+1) 0 !! 100000000
22:15:46 <udevd> so how?
22:15:47 <lambdabot>   mueval-core: Time limit exceeded
22:15:55 <udevd> > iterate' (+1) 0 !! 10000000
22:15:59 <lambdabot>   mueval-core: Time limit exceeded
22:16:01 <udevd> pfft
22:16:03 <udevd> > iterate' (+1) 0 !! 1000000
22:16:06 <lambdabot>   1000000
22:16:10 <udevd> > iterate (+1) 0 !! 1000000
22:16:11 <lambdabot>   *Exception: stack overflow
22:16:14 <udevd> oh, you see
22:17:04 <udevd> ReinH: ↑
22:18:17 <ReinH> udevd: that's an argument for iterate', not for iterate being strict
22:19:25 <udevd> i don't want it to be strict, i'm just wondering why there is not present strict version is standard modules
22:20:00 <ReinH> udevd: good question
22:20:50 <ReinH> perhaps because the uses cases for a strict iterate are limited?
22:21:30 <ReinH> > [0..] !! 1000000
22:21:31 <lambdabot>   1000000
22:21:35 <brandon`> is x `seq` return () the same as evaluate x  (evaluate from Control.Exception)
22:21:52 <udevd> perhaps
22:21:55 <Twey> brandon`: I think so
22:22:13 <udevd> i actually found this solution for strict version of iterate on web, i don't know how seq is working ._.
22:22:47 <ReinH> evaluate forces to WHNF, seq forces to HNF
22:22:52 <ReinH> which are largely the same thing
22:23:01 <udevd> ... (W)HNF?
22:23:04 <ReinH> http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
22:23:08 <Twey> udevd: ‘seq x y’ means ‘when “seq x y” is evaluated, evaluate x to HNF, then return y’.
22:23:47 <udevd> uhm, i see
22:24:01 <ReinH> udevd: the SO question would be useful for you too :)
22:24:19 <udevd> and HNF means just simple value and not graph meant to be reduced?
22:24:29 <Twey> udevd: HNF is basically WHNF.
22:24:32 <ReinH> basically: seq does just enough work to ensure that the value is not undefined
22:24:37 <Twey> (i.e. a constructor containing thunks)
22:24:47 <udevd> and W stands for what?
22:24:51 <ReinH> udevd: http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
22:24:52 <Twey> ‘Weak’
22:24:55 <ReinH> "Weak"
22:24:58 <Twey> Yes, read the SO
22:24:59 <ReinH> Twey: you and your smart quotes
22:25:02 <udevd> mhm
22:25:11 <Twey> ReinH: I hate smart quotes
22:25:12 <udevd> i will :3
22:25:12 <ReinH> so fancy
22:25:21 <ReinH> Twey: but you just used them :p
22:25:21 <Twey> I just have quotes :þ
22:25:25 <Twey> I didn't!
22:25:44 <ReinH> Twey : ‘Weak’
22:25:49 <Twey> ‘Smart quotes’ is that stupid feature of Word that inserts Unicode quotes when you type apostrophes
22:26:03 <ReinH> oh so you did it all on your own :p
22:26:03 <Twey> I typed my quotes myself :þ
22:26:07 <ReinH> fair play
22:27:36 <brandon`> now about the second issue. I can resolve it myself by evaluating the Map but I am still curious why it happens. I replaced recursive readInput with forever and now there is a few seconds delay every single time I enter a new word and look it up in the Map. so forever seems to force the parsing or reading+parsing on every single lookup. why does this happen??
22:27:47 <brandon`> annotation at http://lpaste.net/96049
22:27:52 <udevd> as far as i can understand, seq evaluates first argument to have its head as simple value. what if i want to have first two elements of some list evaluated?
22:28:38 <Twey> brandon`: I'm guessing you arranged your code such that readInput gets called afresh every time
22:28:57 <brandon`> Twey I just changed recursive readInput with forever readInput
22:29:24 <Twey> brandon`: Values of the form ‘x’ will be stored in memory and re-used if the same variable is referred to again.  Values of the form ‘f x’ will not.
22:29:42 <brandon`> http://lpaste.net/diff/96049/96050  (I also changed foldr to foldl' but this does not make any difference)
22:29:49 <udevd> ah, i must to use multiple seqs
22:30:22 <brandon`> Twey I don't quite get that
22:30:46 <brandon`> (readInput wordsMap) is 'x' ?
22:31:13 <Twey> No, ‘readIpnut wordsMap’ is an expression of the form ‘f x’ (i.e. a function application).
22:31:37 <Twey> Try: let doInput = readInput wordsMap in forever doInput
22:31:43 <Twey> readInput**, sorry
22:32:32 <Twey> Oh, never mind, it's the parsing you're worried about
22:32:39 <brandon`> yeah, I am getting the same dela
22:32:42 <brandon`> delay
22:33:52 <brandon`> note that even though I have changed readFile to S.readFile and foldr to foldl', neither of those things make the difference. only forever + readInput vs recursive readInput
22:34:46 <Twey> That's odd
22:34:51 <brandon`> yeah
22:34:53 <Twey> I don't know, sorry
22:35:03 <brandon`> did you get the same thing? you tested it?
22:35:05 <Twey> You could try stepping through it with GHCi's debugging tools
22:35:10 <Twey> I don't have a map big enough
22:35:28 <ReinH> @src forever
22:35:28 <lambdabot> Source not found. My pet ferret can type better than you!
22:35:32 <ReinH> srsly
22:35:40 <Aetherspawn> how do I make this work
22:35:41 <Aetherspawn> > foldr (\x y -> if y >= 9 then x else x + y) 0 [2,3,4,undefined]
22:35:42 <lambdabot>   *Exception: Prelude.undefined
22:35:51 <Aetherspawn> I used to know how to short circuit a fold, but I forgot
22:35:51 <Twey> forever m = m >> forever m
22:36:10 <ReinH> Twey: actually, forever m = let m' = m >> m' in m'
22:36:14 <ReinH> Twey: not sure if that affects sharing
22:36:35 <Twey> I think not
22:36:37 <ReinH> but I assume there's *some* reason for not using your version
22:36:47 <ReinH> it doesn't affect sharing of m
22:37:01 <ReinH> but it might affect the evaluation stack?
22:37:08 <Twey> Hm, maybe
22:37:16 <ReinH> probably so the evaluation stack can be reused?
22:37:36 <ReinH> otherwise each forever is a new frame?
22:37:47 <ReinH> anyway not the problem
22:39:12 <ReinH> Twey: talking to SimonM is making me obsessive about the GHC runtime :p
22:39:19 <Twey> Aetherspawn: Um, that actually evaluates to undefined, so it's not going to work
22:39:33 <Twey> Aetherspawn: ‘if y >= 9 then x else x + y’ with y = 9, x = undefined
22:39:43 <Twey> Aetherspawn: Yields undefined
22:40:05 <Aetherspawn> > foldr (\x y -> if y >= 9 then y else x + y) 0 [2,3,4,undefined]
22:40:06 <lambdabot>   *Exception: Prelude.undefined
22:40:07 <Twey> You can yield something that doesn't depend on the next value (x) to ‘short-circuit’ it
22:40:24 * hackagebot labyrinth-server 0.1.4.1 - A complicated turn-based game - Web server  http://hackage.haskell.org/package/labyrinth-server-0.1.4.1 (AlexeyKotlyarov)
22:40:42 <Aetherspawn> I tried that originally, but it still fails above, any idea why?
22:41:18 <Twey> You add undefined onto the total, and then check whether it's >= 9
22:41:27 <frx> but isn't y the next value? second argument is the accumulator
22:42:08 <Twey> Aetherspawn: At one point y = 0 + 2 + 3 + 4 + undefined, and you check y >= 9
22:42:15 <Aetherspawn> I don't think I add undefined onto the total
22:42:18 <Aetherspawn> x + y is in the else branch
22:42:34 <joelteon> > (0 + 2 + 3 + 4 + undefined) >= 9
22:42:35 <lambdabot>   *Exception: Prelude.undefined
22:42:45 <Twey> You might be right; it appears to be my stupid time
22:42:55 <frx> > foldl (\y x -> if y >= 9 then y else x + y) 0 [2,3,4,undefined]
22:42:57 <lambdabot>   9
22:43:03 <Aetherspawn> ah, foldl
22:43:13 <Aetherspawn> cheers! :)
22:43:15 <frx> foldr starts from the right
22:43:26 <Aetherspawn> I thought I tried that but I must've still had x/y reversed
22:43:30 <ReinH> Aetherspawn: foldr parenthesizes to the right
22:43:42 <ReinH> frx: that's not exactly true...
22:43:44 <Twey> > foldr (\x y -> if y >= 9 then y else x + y) z [a, b, c, d] :: Expr
22:43:45 <lambdabot>   z
22:43:46 <Aetherspawn> hmm I misread it as fold moving right so I assumed I could short circuit it that way
22:44:02 <Twey> That's a surprising answer
22:44:08 <Twey> > foldr (\x y -> if y >= w then y else x + y) z [a, b, c, d] :: Expr
22:44:08 <frx> ReinH yeah I wasn't precise, it starts from the left as well
22:44:09 <lambdabot>   z
22:44:46 <ReinH> > take 10 $ foldr (:) [] [1..]
22:44:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:44:55 <ReinH> couldn't do that if foldr started from the right :)
22:45:24 <vikstrous> Hey guys, is there an easy/obvious way to simplify this?
22:45:24 <vikstrous> stage 4 $ stage 3 $ stage 2 $ stage 1 input
22:45:26 <ParahSailin> @src foldr
22:45:26 <lambdabot> foldr f z []     = z
22:45:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:45:42 <ReinH> process = stage 4 . stage 3 . stage 3 . stage 1
22:45:44 <brandon`> ReinH but with + it has to start from the right?
22:46:01 <brandon`> 2 + (3 + (4 + (undefined + 0))   can't do anything until undefined + 0 is calculated, i think
22:46:04 <ReinH> brandon`: how do you evaluate 1 + (2 + (3 + 0)) ?
22:46:06 <codygman> I'm having some problems using basic auth... I think it might be an encoding problem? I keep getting a 403 response... however when I test the same user and pass with curl it works: http://lpaste.net/96051
22:46:25 <vikstrous> ReinH What I was looking for is a way to say something like "run the stages up to 4" instead of chaining them explicitly
22:46:26 <brandon`> 3 + 0 first
22:46:35 <ReinH> brandon`: right
22:47:07 <brandon`> so it starts from the right?
22:47:14 <brandon`> but with : from left? o_O
22:47:27 <ReinH> > take 1 $ 1 : (2 : (3 : []))
22:47:28 <lambdabot>   [1]
22:47:31 <ReinH> same thing
22:47:43 <ReinH> you don't need to evaluate 2 : (3 : [])
22:48:07 <ReinH> the advantage of foldr is that it lets you be as non-strict *as possible*
22:48:31 <ReinH> > take 1 [1, undefined]
22:48:32 <lambdabot>   [1]
22:48:33 <ReinH> same idea
22:49:21 <ReinH> vikstrous: so you literally have something that takes an int?
22:50:10 <brandon`> so it starts from the left, but + isn't productive until we go through entire list
22:50:18 <vikstrous> ReinH I have a few stages that a slightly different and take Int and [[String]] and return [[String]]
22:50:40 <vikstrous> I just want to call them in order without writing out each step
22:50:40 <ReinH> right
22:51:28 <vikstrous> I think I can do something with zip and a range
22:51:47 <vikstrous> I'm not really sure how to approach it
22:52:44 <ReinH> something something foldl1 ($ input) . fmap stage [1..4]
22:53:37 <vikstrous> ah! fmap.. hmm
22:53:58 <ReinH> fmap stage [1..4] = [stage 1, stage 2, stage 3, stage 4]
22:54:36 <ReinH> @src foldl1
22:54:36 <lambdabot> foldl1 f (x:xs) = foldl f x xs
22:54:36 <lambdabot> foldl1 _ []     = undefined
22:55:07 <vikstrous> oh cool I'll try this
22:55:50 <ReinH> vikstrous: something vaguely like that should work
22:56:19 <ReinH> you want stage 4 (stage 3 (stage 2 (stage 1 input)))
22:57:29 <ReinH> oh
22:57:31 <ReinH> > foldl1 (.) [succ, succ, succ, succ] $ 1
22:57:32 <lambdabot>   5
22:58:00 <ReinH> > foldl1 (.) [f,g,h] 1 :: Expr
22:58:01 <lambdabot>   f (g (h 1))
22:58:11 <ReinH> seems good
22:58:20 <ReinH> I would also accept foldl1 fmap
22:58:30 <ReinH> which is probably the highest order fold I will use today
22:58:49 <ReinH> also SimpleReflect never ceases to amaze me
22:59:27 <Twey> That's my favourite fold
22:59:47 <ReinH> Twey: it's pretty great :)
22:59:51 <vikstrous> looking for examples of fmap brought me here... brb reading random cool stuff http://www.haskell.org/haskellwiki/Lifting
22:59:53 <Twey> It's very Haskell
23:00:19 <ReinH> > foldl 1 (.) id [f,g,h] :: Expr
23:00:20 <lambdabot>   Couldn't match type `(a0 -> b1) -> a0 -> c0'
23:00:20 <lambdabot>                with `Debug.Sim...
23:00:25 <Twey> Well, I guess foldr id [f, g, h] is actually my favourite fold
23:00:40 <ReinH> the function monoid strikes again :)
23:00:42 <Twey> Er, foldr (.) id [f, g, h]
23:00:44 <Twey> Heh
23:01:29 <ReinH> I was using the clearly inferior function semigroup ;)
23:01:39 <vikstrous> oh cool... so you're saying I can apply . to things as if . is a function D:
23:01:47 <ReinH> (.) IS a function :)
23:02:02 <ReinH> Twey: sorry, endofunction monoid
23:02:09 <vikstrous> haskell is so trippy... I like it :P
23:02:13 <Aetherspawn> @pl (\z -> fst . foldl (\(n, y) (x, r) -> if y < z then (x, y + r) else (n, y)) (undefined, 0) $ [("cow", 0.1 :: Double), ("pig", 0.1), ("horse", 0.25), ("deer", 0.1), ("duck", 0.1)])
23:02:13 <lambdabot> (line 1, column 101):
23:02:13 <lambdabot> unexpected ","
23:02:13 <lambdabot> expecting simple term
23:02:22 <ReinH> Twey: which reminds me that this is probably ala Endo foldMap
23:02:24 <ReinH> hmm
23:02:27 <brandon`> I need immutable Map-like structure. should I just use hashtables or IORef + Map?
23:02:35 <brandon`> err mutable not immutable
23:02:45 <ReinH> > ala Endo foldMap [succ, succ, succ] 1
23:02:46 <lambdabot>   4
23:02:49 <ReinH> omg it is
23:03:30 <ReinH> > let stage = (+) in ala Endo foldMap (fmap stage [1..4]) 1
23:03:31 <lambdabot>   11
23:03:37 <ReinH> holy shit I love algebra
23:03:59 <ReinH> > let stage = (+) in ala Endo foldMap (fmap stage [1..4]) x
23:04:02 <lambdabot>   1 + (2 + (3 + (4 + x)))
23:04:12 <ReinH> and SimpleReflect is still amazing
23:04:46 <ReinH> Twey: Endo is the endofunctor monoid yay!
23:04:53 <ReinH> endofunction*
23:05:35 <ReinH> Twey: monoid homomorphisms are probably my favorite thing ever
23:05:51 <vikstrous> One day I'll know what you're talking about...
23:06:44 <ReinH> vikstrous: look at these two things
23:06:49 <ReinH> > 1 : 2 : 3 : []
23:06:50 <lambdabot>   [1,2,3]
23:06:53 <ReinH> > 1 + 2 + 3 + 0
23:06:54 <lambdabot>   6
23:06:58 <ReinH> notice any similarity?
23:08:17 <vikstrous> I'm not sure what you mean...
23:08:46 <johnw> they fit a pattern of 1 ⊗ 2 ⊗ 3 ⊗ ε
23:09:01 <ReinH> johnw: you and your math symbols
23:09:06 <ReinH> how do you do that btw?
23:09:09 <johnw> agda-mode
23:09:14 <johnw> I type \ox and \Ge
23:09:17 <ReinH> oh you just copy it over
23:09:25 <johnw> no, my IRC buffer is in agda-mode :)
23:09:30 <ReinH> you irc in emacs?
23:09:38 <johnw> there are other IRC clients? ;)
23:09:40 <ReinH> do you play tetris too?
23:09:45 <ReinH> emacs is a pretty nice operating system
23:09:49 <ReinH> shame about its text editor...
23:09:51 <johnw> yeah
23:10:02 <Makoryu> I hear they have one of those now too
23:10:12 <Makoryu> Not a good one though
23:10:12 <ReinH> Makoryu: yeah but you need the foot pedals to get the full experience
23:10:15 <Makoryu> Rather the opposite
23:10:21 <vikstrous> I guess emacs is popular with haskell users?
23:10:28 <ReinH> vikstrous: it has nice tools for editing haskell
23:10:34 <ReinH> vim is pretty good too and a number of us use vim
23:10:57 <ReinH> vikstrous: so, can you see that those two things are basically the same structure?
23:11:02 <ReinH> We just swapped : for + and [] for 0?
23:11:26 <vikstrous> Oh, I haven't tried emacs yet. I'll done that one day..
23:11:32 <vikstrous> Yeah, I saw that
23:11:45 <ReinH> vikstrous: one is a list, the other is a sum
23:11:49 <vikstrous> s/done/do/
23:11:50 <ReinH> lists and sums are both monoids
23:12:08 <vikstrous> ah I see
23:12:24 <ReinH> swapping : for + and [] for 0 is a structure-preserving mapping between the list monoid and the sum monoid
23:12:36 <ReinH> that's what homomorphism means
23:12:50 <vikstrous> but the return types are very different
23:13:00 <ReinH> vikstrous: yes, but the structure is the same
23:13:13 <vikstrous> okay makes sense
23:13:14 <ReinH> both are of the form 1 ⊗ 2 ⊗ 3 ⊗ ε
23:13:27 <ReinH> we just change what ⊗ and ε mean
23:14:04 <ReinH> and `f . g . h . id' is of the same form too
23:14:04 <vikstrous> hmm so yeah, both can be evaluated with a fold?
23:14:08 <ReinH> yes
23:14:15 <ReinH> if you squint hard enough ;)
23:14:21 <vikstrous> haha cool
23:14:29 <johnw> monoid homomorphisms are a special case of catamorphisms, about which you can find a great deal of reading material relevant to Haskell
23:14:31 <ReinH> so monoids are sets with things you can combine together to get a new thing
23:14:43 <johnw> if you find this kind of thing cool :)
23:14:46 <ReinH> as long as combining them is associative
23:15:08 <ReinH> a fold basically takes a list and turns it into a different monoid
23:15:35 <ReinH> you turn 1 : 2 : 3 : [] into 1 + 2 + 3 + 0 via `foldr (+) 0'
23:15:51 <ReinH> notice that the arguments are exactly the things that change between the two?
23:15:59 <vikstrous> yeah
23:16:15 <ReinH> if you have an actual monoid, you can use the fact that those arguments are baked into the typeclass:
23:16:21 <ReinH> > fold ["foo", "bar"]
23:16:22 <lambdabot>   "foobar"
23:16:32 <ReinH> > fold [Sum 1, Sum 2, Sum 3]
23:16:34 <lambdabot>   Sum {getSum = 6}
23:16:50 <vikstrous> wait, is fold the same as foldl1 or something?
23:16:55 <ReinH> :t fold
23:16:56 <lambdabot> (Foldable t, Monoid m) => t m -> m
23:17:10 <ReinH> when you have a monoid, you know what the equivalents of (+) and 0 are for that monoid
23:17:15 <ReinH> for Sum they are, in fact, (+) and 0
23:17:21 <ReinH> so you don't need to pass them as arguments
23:17:25 <vikstrous> ohh I see
23:17:30 <vikstrous> woah
23:17:34 <ReinH> that is, when you have a Monoid
23:17:37 <ReinH> :info Monoid
23:17:45 <ReinH> @info Monoid
23:17:45 <lambdabot> Monoid
23:17:49 <ReinH> thanks lambdabot
23:18:00 <vikstrous> lol
23:18:20 <ReinH> fold is the same as mconcat but for any foldable, not just []
23:18:27 <ReinH> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html
23:19:01 <ReinH> johnw: I have a new talk I'm preparing where I teach math to rubyists
23:19:08 <vikstrous> oh wow monoids are cool
23:19:10 <ReinH> including monoid homomorphisms and catamorphisms :)
23:19:11 <ReinH> vikstrous: yep!
23:19:18 <ReinH> they're super useful
23:20:16 <ReinH> johnw: It's basically a Mathematician's Lament for computer science-y maths
23:20:54 <vikstrous> I'll go try to figure out the right way to solve my problem now... Haskell is like a puzzle :P
23:21:45 <Twey> :t ala
23:21:46 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
23:21:48 <ReinH> vikstrous: the nice thing about compositionality is that you can write fireZeMissiles = foldl (.) id (fmap stage [1..4]) once and forget it
23:22:20 <ReinH> Twey: it's sugar for wrapping and unwrapping a newtype
23:22:30 <johnw> ReinH: nice!
23:22:30 <ReinH> ala Sum foldMap = getSum . foldMap Sum
23:22:34 <johnw> ReinH: I'd love to see it
23:22:40 <ReinH> johnw: I'd love your input!
23:22:41 <Twey> Ah, I see
23:23:02 <ReinH> Twey: it came from the newtype package and was grafted onto lens
23:23:15 <Twey> I don't know everything in lens yet
23:23:19 <Twey> I suspect I never will :þ
23:23:24 <ReinH> Twey: hah I don't think edwardk does either at this point...
23:23:31 <Twey> Haha
23:24:00 <brandon`> is there already a function like this? maybeToStr x  = case x of Nothing -> ""; (Just x) -> show x
23:24:00 <ReinH> johnw: I want people to have principled ways to reason about some of the stuff they are doing in Ruby and math provides that in spades
23:24:23 <ReinH> johnw: so I can provide, e.g., a principled reason to prefer #reduce with a specified initial value to without
23:24:41 <ReinH> [1,2,3].reduce(:+) is like foldl1 (+) [1,2,3]
23:24:46 <ReinH> and has the same problem with empty lists
23:24:48 <johnw> right
23:24:56 <johnw> does Ruby have non-empty lists?
23:24:58 <ReinH> except in Ruby it returns nil, which is the magical bottom that is not bottom
23:25:01 <ReinH> yep
23:25:01 <ReinH> []
23:25:10 <brandon`> "magical bottom that is not bottom" <- LOL
23:25:13 <johnw> isn't that an empty list?
23:25:26 <ReinH> johnw: I can't read.
23:25:28 * hackagebot egison 3.0.12 - The world's first language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.0.12 (SatoshiEgi)
23:25:29 <ReinH> [1] is a non-empty list
23:25:30 <johnw> i mean, does Ruby have an equivalent to Data.List.NonEmpty
23:25:32 <ReinH> although it's a array
23:25:35 <ReinH> oh. no
23:25:43 <ReinH> I mean
23:25:45 <ReinH> I could write such a thing
23:25:52 <ReinH> but it's not a part of core or stdlib ruby afaik
23:26:16 <ReinH> I can pretty easily write a non-empty linked list implementation, but it will be about as slow as you expect
23:28:17 <ReinH> One of the frustrating things about Ruby is that if you want performant data structures you HAVE TO lean on the native ones
23:28:26 <ReinH> you can't just write your own out of whole cloth
23:28:53 <ReinH> which basically limits the problems you can solve to those that can be implemented using arrays and hash-maps
23:29:09 <johnw> "If it looks like a duck, and quacks like a duck, it will probably throw exceptions at runtime." -- somebody on twitter
23:29:17 <ReinH> johnw: brilliant.
23:29:27 <ReinH> any idea who?
23:29:34 <ReinH> before I appropriate it?
23:29:38 <johnw> i tried to find it, failed
23:29:41 <ReinH> :(
23:30:01 <ReinH> johnw: well that wasn't very hard https://twitter.com/slyphon/status/398937654605381632
23:30:04 <ReinH> google is magic
23:30:11 <johnw> and my twitter client is not, apparently
23:30:35 <Twey> I'm not sure what the point would be of having a non-empty list in Ruby
23:30:50 <Twey> There are no types, so you might as well just pass in a list :þ
23:30:55 <ReinH> Twey: it would let you use reduce without a starting value and not feel guilty?
23:31:09 <ReinH> Twey: yeah, that's why I said "bottom that is not really bottom"
23:31:12 <Twey> Ah, a false sense of security :þ
23:31:15 <ReinH> it's not bottom if oyu don't have a type to inhabit in the first place
23:31:28 <ReinH> it's just yet another value
23:31:33 <Twey> Well, it has the type of Ruby values
23:31:39 <ReinH> sure, but nil isn't privileged there
23:31:41 <ReinH> is my point
23:31:43 <Twey> Or expressions, rather
23:31:46 <Twey> Yeah
23:31:59 <ReinH> the only bottom might be actual runtime exceptions, but not really
23:32:04 * ReinH shrugs
23:32:09 <ReinH> it's pretty much a non sequitur
23:32:19 <Twey> You can have bottom in that you can exit the program &c.
23:32:22 <pharaun> for all of the talk of bottom there's no such thing as top?
23:32:29 <Twey> It's just uninteresting because it never appears anywhere useful, due to strictness
23:32:31 <ReinH> Twey: well, I guess non-termination is bottom
23:32:31 <pharaun> wouldn't that be the type/result itself?
23:32:37 <Twey> pharaun: There is such a thing as top
23:32:48 <ReinH> there is indeed
23:32:48 <johnw> one way to simulate bottom is to debate the merit of dynamic typing
23:32:54 <ReinH> johnw: lmao
23:33:28 <Twey> johnw: I stopped having those debates after I figured out that there's no such thing as dynamic typing :þ
23:34:10 <johnw> yeah, that killed my interest in such debates as well
23:34:14 <pharaun> Twey: i guess i'm just wondering where "bottom" came from
23:34:26 <Twey> pharaun: If bottom is the value contained by all types, top is the value contained by no types
23:35:07 <Twey> It's used in lattices and things sometimes as a supremum
23:35:12 <ReinH> pharaun: lattice theory, boolean algebra, and type theory
23:35:15 <johnw> pharaun: it comes up a lot in type theory books; and in Agda ⊤ and ⊥ are both used, although there ⊥ does not mean "the value contained by all types"
23:35:18 <ReinH> where it means equivalent things
23:35:32 <Twey> The TT use of top is weird to me
23:35:46 <ReinH> pharaun: http://en.wikipedia.org/wiki/Bottom
23:35:59 <Twey> It seems to mostly mean ‘true, but we've already got things called “true” and “false”’ :þ
23:36:13 <ReinH> It also refers to the posterior pelvic region of the anatomy
23:36:15 <ReinH> the more you know
23:36:24 <Twey> Ha
23:36:33 <johnw> ⊤ is like True at the type level, where true is true at the value level
23:36:37 <ion> (⊥)
23:36:39 <ion> / \
23:36:44 <Twey> johnw: Fair enough
23:36:46 <ReinH> yes that
23:37:06 <ReinH> johnw: that's a really good way of putting it actually
23:37:08 <ReinH> ty
23:38:02 <ReinH> It is also a term used by gay, BDSM, and some straight couples to refer to... you know what... never mind.
23:38:02 <vikstrous> ReinH this is what I ended up with. It seems like there are a few small things to improve here. Is there no way to fmap the other way? Is there a way to get rid of some of the brackets?
23:38:02 <vikstrous> (foldl (.) id (fmap stage [4,3..1])) input
23:38:05 <johnw> ion: lol, just got it :)
23:38:23 <ReinH> vikstrous: make this its own function f = foldl (.) id (fmap stage [4,3..1])
23:38:30 <ReinH> and give it a better name than f
23:38:35 <ReinH> and then betterNamedF input
23:38:38 <vikstrous> I apply it to input
23:38:51 <ReinH> but giving it a name will help you remember wtf it does :)
23:38:56 <ReinH> and make it prettier as a side bonus
23:39:00 <vikstrous> lol okay
23:39:00 <johnw> vikstrous: http://www.haskell.org/pipermail/haskell-cafe/2012-October/104141.html
23:39:05 <Twey> foldl (.) id $ stage <$> [4, 3 .. 1] -- look ma, no brackets
23:39:06 <johnw> a thread you might find relevant
23:39:31 <ReinH> johnw: yep, I noticed that it was Endo earlier!
23:39:34 <ReinH> I was very proud of myself!
23:39:34 <vikstrous> johnw thanks. That's exactly what I'm doing
23:39:41 <ReinH> ala Endo foldMap :D
23:40:08 <Twey> Heh
23:40:08 <johnw> yep, Endo is pretty cool, it makes difference lists trivial too
23:40:11 <ReinH> It's a monoid... what monoid? function? Close... endofunctions? Yep... oh wait isn't that a newtype?
23:40:36 <pharaun> ReinH: hah the "couples" thing is what i was also pondering bout >.> :p
23:40:43 <Twey> ‘I've been using foldr (.) id a lot lately; does it have a name?’ ‘Sure, you can call it ala Endo foldMap’
23:40:50 <pharaun> anyway yay thanks
23:40:54 <ReinH> Twey: haha
23:41:16 <ReinH> johnw: I actually derived foldr (.) id from first principles just now, having not seen it before.
23:41:26 <vikstrous> > Endo foldMap
23:41:27 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = t0 a0
23:41:27 <lambdabot>  Expected type...
23:41:37 <vikstrous> :/
23:41:37 <Twey> :t ala Endo foldMap
23:41:38 <lambdabot> Foldable t => t (a -> a) -> a -> a
23:41:53 <ReinH> :t foldMap
23:41:53 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
23:42:11 <Twey> vikstrous: f x y is (f x) y, not f (x y).  If you have f x y, (x y) may or may not type-check.
23:42:13 <ReinH> vikstrous: foldMap takes a way to turn a value into a monoidal value and a foldable thing "full of" values
23:42:26 <ReinH> vikstrous: without endo it's appEndo . foldMap Endo
23:42:27 <pharaun> ahh i now see why there's not much talk in here about top
23:42:33 <ReinH> ala just does the newtype wrapping and unwrapping for you
23:42:51 <ReinH> er without ala I mean
23:43:11 <Twey> pharaun: The top value is largely useless.  The top type is handy, but doesn't exist in Haskell.  ☺
23:43:16 <halalvava> a.
23:43:16 <ReinH> it depends on the fact that wrapping and unwrapping any newtype is an isomorphism
23:43:50 <halalvava> Is there a way to do last $ takeWhile f list, without doing it in that silly way?
23:43:52 <johnw> ReinH: for your next trick: foldr (<=<) return
23:43:59 <ReinH> johnw: I've done that too
23:44:06 <pharaun> Twey: yeah that's what i figured :) makes more sense now
23:44:07 <halalvava> A builtin function that returns the last element of a list where a function returns true
23:44:12 <vikstrous> I'll read more about types and stuff later.. It's getting really late over here
23:44:32 <ReinH> but that's just a fold of the monoid in the category of endofunctors :p
23:45:05 <ReinH> johnw: also understanding foldr (<=<) return is all you need to make that definition of monad make sense :D
23:45:14 <Twey> pharaun: In Agda you can use the top (unit) type to ‘hide’ proofs by having the type of an input evaluate to top if the other inputs are valid and otherwise bottom, but it's considered bad style
23:45:17 <ReinH> kleisli composition + return forms a monoid
23:45:23 <ReinH> what monoid does it form?
23:45:40 <augur_> anyone know how to deal with zippers into mutually recursive types?
23:45:42 <ReinH> there you go
23:46:07 <ReinH> johnw, Twey: btw I want to start using Agda
23:46:16 <ReinH> specifically to work on some proofs of properties of LVars
23:46:23 <ReinH> but it seems like modeling IORefs would be hard?
23:46:56 <Twey> ReinH: Mmm, not necessarily
23:47:04 <ReinH> seems good
23:47:04 <Twey> You can pass around a store
23:47:24 <ReinH> Twey: hmm, maybe if I can write LVar in terms of ST it might be easier?
23:47:36 <ReinH> I don't actually see yet why IORef is necessary vs STRef, but maybe it is
23:47:42 <Twey> Well, yes, I don't think you specifically need IORefs for LVars
23:47:58 <Twey> Only if you're planning to use them for threading
23:48:09 <ReinH> unsure if it's a principled or pragmatic choice
23:48:14 <ReinH> right
23:48:36 <Twey> It's nice to see LVars gaining steam
23:48:37 <ReinH> Twey: well once I learn basic Agda proofs I'll bother you some more :)
23:48:47 <ReinH> Twey: yeah I'm very interested, had a chance to talk to Lindsey at RiconWEST
23:48:52 <Twey> Sure; I'm not really an expert, just an enthusiastic amateur :þ
23:48:59 * Twey nods.
23:49:20 <ReinH> I asked it it was possible to provide a "peek" that didn't freeze the structure but provided non-deterministic results
23:49:35 <ReinH> as in you couldn't guarantee which "version" of the structure you would be peeking into
23:49:42 <Twey> Aye
23:49:50 <ReinH> which seems still useful enough
23:50:03 <ReinH> if you're using, e.g., a counter, you often want to know "some recent value"
23:50:05 <Twey> Depending on your ordering, I guess
23:50:09 <ReinH> and you don't want to have to freeze the counter to get it
23:50:25 <ReinH> I may not care if that value was the last value or the nth to last value
23:50:25 <Ralith> Twey: what do you mean, "the top type doesn't exist in Haskell"?
23:50:28 <ReinH> for some small n
23:50:51 <Ralith> Twey: is agda's top something more than a unit type?
23:50:57 <ReinH> Twey: so a non-deterministic result in practice might be sufficient
23:51:07 <Twey> Ralith: Haskell doesn't have a top type (a type that contains every possible value)
23:51:08 <ReinH> and is another way to trade off determinism for... usability?
23:51:24 <Twey> Ralith: Agda's isn't; I regretted mentioning them in close proximity shortly after I did :þ
23:51:26 <ReinH> I think the non-determinism is fine as long as it's bounded
23:51:32 <Ralith> :P
23:52:06 <Twey> ReinH: From what I understand of LVars, that's a major advantage of them
23:52:14 <scott_> brandon`: Late reply, but maybeToStr = maybe "" show
23:52:39 <Ralith> Twey: also, just because I'm feeling mean, consider Data.Dynamic
23:52:43 <Twey> Viz. that you can start working immediately with a value that's ‘good enough’ without necessarily waiting for a final result
23:52:59 <Twey> Ralith: Data.Dynamic doesn't contain non-dynamic types
23:53:28 <Twey> It's a top type for Data.Dynamic :þ
23:53:49 <Ralith> Twey: I'm not sure what meaning of 'contain' you're using there; you can certainly obtain values of static type from it, otherwise it wouldn't be useful.
23:53:51 <johnw> g'night all
23:54:28 <Twey> Ralith: But it doesn't immediately contain a value of type () (for example).  It contains a value that might contain a (), but that's a different value, as Just 3 is different from 3
23:54:31 <Twey> 'night, johnw!
23:54:41 <Aetherspawn> wow
23:54:50 <Aetherspawn> its really crazy fucking annoying that IORef doesn't have an Ord instance
23:55:00 <Twey> Aetherspawn: Uhh, what would that even *do*?
23:55:04 <Aetherspawn> like, it should just use the time on creation or something like that
23:55:10 <Aetherspawn> but its so annoying I can't even put them in a Map
23:55:12 <Twey> Hell no
23:55:31 <Ralith> Aetherspawn: newtype AetherIORef = AIR IORef TimeStamp
23:55:32 <Aetherspawn> after scouring hackage for like 10 minutes
23:55:33 <Ralith> er
23:55:34 <Ralith> data
23:55:35 <Twey> That's some crazy non-determinism.  If you want to add that sort of order go ahead, but leave everyone else out of it :þ
23:55:41 <Aetherspawn> the only damn thing I can put an IORef inside is a list
23:55:56 <Ralith> so wrap it
23:56:01 <Twey> Aetherspawn: You can just tag it with something
23:56:27 <ReinH> johnw: this is my favorite post in that thread http://www.haskell.org/pipermail/haskell-cafe/2012-October/104166.html
23:57:03 <ReinH> Aetherspawn: expecting to know anything useful about the time an IORef was created seems fraught with pain and fail
23:57:24 <Twey> newAIORef v = AetherIORef <$> newIORef v <*> getCurrentTimeStamp {- I don't remember how the time system works, so sue me -}
23:58:24 <ReinH> rephrase: expecting to derive any value from knowing the time an IORef was creating seems fraught with fail
23:58:30 <ReinH> *created
23:58:40 <Rc43> Anybody use UHC with java backend (jazy)?
23:58:50 <Rc43> How to import itc compiled classes?
23:59:31 <Rc43> I tried to decompile .class files with jad, but they are somehow executable (have main function).
23:59:40 <ReinH> Aetherspawn: expecting IORef creation to be meaningfully ordered seems pretty dubious in a lazy runtime
23:59:53 <Aetherspawn> it doesn't even need to be
