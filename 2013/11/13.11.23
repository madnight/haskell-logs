00:00:01 <Rc43> Or it is just RTS-initialization?
00:00:02 <Aetherspawn> it just needs to have a unique number so we can put them in containers
00:00:16 <ReinH> Aetherspawn: the Ord constraint isn't necessary. It's a performance optimizaiton.
00:00:17 <Aetherspawn> its so inconvenient not to be able to put it in a Set or Map...
00:00:39 <Aetherspawn> ReinH: so should I be defining my own?
00:00:45 <Twey> Well, it's necessary for the desired performance characteristics
00:00:55 <ReinH> Twey: isn't that what I said? :p
00:01:27 <Twey> Depends whether or not you consider data-structures to be defined by the performance of their operations :þ
00:01:42 <ReinH> Aetherspawn: are you using IORefs as keys?
00:01:57 <Aetherspawn> yes
00:02:01 <Twey> Oh, there's a level of pain I didn't consider
00:02:21 <Twey> Aetherspawn: Why?  :þ
00:02:36 <Aetherspawn> because they are tagged with a Int
00:02:39 <ReinH> o_O
00:02:45 * Ralith wonders whether Aetherspawn has read any of the solutions people have provided to him
00:02:48 <DarkFox> @pl f x = if p x then [x] else []
00:02:48 <lambdabot> f = flip (liftM2 if' p return) []
00:02:52 <DarkFox> if' ?
00:03:04 <ReinH> @src if'
00:03:04 <lambdabot> Source not found. Where did you learn to type?
00:03:06 <ReinH> :(
00:03:12 <Twey> DarkFox: if' p t f = if p then t else f
00:03:15 <Aetherspawn> Ralith: I really don't want to roll my own type like that
00:03:22 <Ralith> too bad
00:03:23 <Aetherspawn> there will be more of that roll-my-own-stuff than actual solution code
00:03:24 <ReinH> if' p a b = if p then a else b ... doh
00:03:32 <DarkFox> Heh
00:03:41 <Ralith> perhaps you should adopt a less trivial task, then :P
00:03:49 <Twey> bool (const mzero)
00:03:51 <Twey> Oops
00:03:51 <ReinH> Aetherspawn: rolling your own type is a sign that you are doing it right :p
00:04:18 <DarkFox> What would be the tinest way to do that if then else that I said above?
00:04:41 <ReinH> filter p [x] ?
00:04:50 <DarkFox> f x@(p->True)=[x];f _=[]
00:04:58 <Aetherspawn> instance Ord (IORef a) where
00:04:58 <Aetherspawn>     compare _ _ = EQ
00:05:01 <Aetherspawn> bleh
00:05:06 <Twey> Oh
00:05:08 <Ralith> ew
00:05:15 <Aetherspawn> now I can map them
00:05:26 <Twey> I was going to go with join $ bool (const mzero) pure . p
00:05:33 <Aetherspawn> whats even more annoying is that there is no version of Map that doesn't require Ord
00:05:34 <ReinH> Aetherspawn: sure, if you want your map performance to be worst case all the time, go right ahead :p
00:05:35 <Twey> But yes, filter is probably a better option :þ
00:05:37 <Aetherspawn> I searched it for ages.
00:05:43 <DarkFox> ReinH: Oh duh
00:05:44 <DarkFox> Lol
00:05:51 <DarkFox> Thanks
00:05:51 <Ralith> ReinH: I'm pretty sure it actually just won't work at all
00:05:55 <Aetherspawn> should be like a TagSet or something
00:05:56 <Ralith> I'm not sure he cares, though
00:06:06 <DarkFox> Friend likes if-then-else and I hate so I was trying to do that ... but filter, damn.
00:06:21 <Aetherspawn> ReinH: theres like, at most, 10 items in the map
00:06:28 <Twey> Aetherspawn: That will give you basically the same characteristics as a list :þ
00:06:30 <ReinH> Aetherspawn: then why do you even need a map?
00:06:33 <ReinH> just use an association list
00:06:38 <ReinH> it even provides the same basic interface
00:06:48 <Aetherspawn> ReinH: I'm very interested, where do I find this?
00:06:58 <Ralith> :t lookup
00:06:58 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
00:06:59 <ReinH> any list of type [(k,v)]
00:07:08 <ReinH> and lookup from the prelude
00:07:24 <ReinH> but ofc you need an Eq constraint
00:07:37 <Aetherspawn> oh, the utility was in insertWith
00:08:00 <ReinH> Ralith: it would totally work as long as they're ok with getting back an arbitrary value every time ;)
00:08:14 <ReinH> Aetherspawn: why don't we ask you what you're actually trying to do
00:08:21 <ReinH> not what you think you need to do to accomplish it
00:08:36 <ReinH> this seems like an XY problem
00:08:47 <Aetherspawn> building a mutable markov chain with arm specific chances using IORefs
00:09:30 <Ralith> ReinH: heh
00:10:03 <ReinH> you do need some basic facility for comparing keys
00:10:04 <Aetherspawn> although, I'm "done" now and I don't really want to touch it anymore
00:10:22 <Aetherspawn> uh, yeah, I do.
00:10:32 <Aetherspawn> although performance is not a concern
00:10:34 <Aetherspawn> its a toy project
00:11:32 <ReinH> alrighty then
00:11:48 <ReinH> I don't particularly want to touch it any more either, so we agree on this much at least ;)
00:11:53 <Aetherspawn> lol
00:13:09 * pharaun gets out the 10ft stick of poking
00:14:38 <ReinH> not enough
00:14:49 <ReinH> I need a +3 20ft stick of poking
00:14:53 <pharaun> haha :)
00:14:55 * Ralith gets out his 15 foot stick of poking, pokes pharaun smugly
00:14:56 <Aetherspawn> .. there is like a huge hole in containers almost
00:14:58 <ReinH> with extra chance to crit
00:15:07 <ReinH> Aetherspawn: uh, for using IORefs as keys? Not really.
00:15:11 <pharaun> ReinH: Vorpal?
00:15:18 <ReinH> pharaun: PLS
00:15:39 <ReinH> For using things that are Eq but not Ord? Maybe.
00:15:43 <Aetherspawn> ReinH: I think you're missing the point.
00:15:45 <Aetherspawn> oh there we go
00:16:21 <ReinH> (IORef is not an example of the latter)
00:16:48 <Aetherspawn> ... whats wrong with IORef
00:17:07 <Aetherspawn> I think you're just being a little bit wingy about it having IO in its name
00:17:38 <pharaun> TVar, MVar?
00:17:39 <klugez> Can you do any better with just Eq than association lists?
00:18:19 <Aetherspawn> yeah, it would be nice to have all the stuff in Data.Map like insertWith
00:20:02 <klugez> Possibly, yeah. But typically you would just use unordered-containers if you don't have Ord.
00:20:10 * hackagebot labyrinth-server 0.1.4.1 - A complicated turn-based game - Web server  http://hackage.haskell.org/package/labyrinth-server-0.1.4.1 (AlexeyKotlyarov)
00:20:10 * hackagebot egison 3.0.12 - The world's first language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.0.12 (SatoshiEgi)
00:20:30 <Aetherspawn> klugez: those use Hashable
00:21:56 <klugez> Aetherspawn: Yes, but that covers a lot. (I'm not sure what it doesn't cover.)
00:22:16 <ReinH> pretty easy to write insertWith for assoc lists
00:23:40 <ReinH> insertWith f k v = fmap ((k',v') -> if k == k' then f v v' else v')
00:24:37 <klugez> Missing \ before the tuple.
00:24:42 <ReinH> er make that a tuple
00:24:45 <ReinH> and fix my syntax
00:24:52 <ReinH> thank you sufficiently smart compilers
00:25:22 <ReinH> insertWith f k v = fmap (\(k',v') -> if k == k' then (k', f v v') else (k', v'))
00:25:37 <ReinH> or factor out the (,) k', whatever
00:25:45 <fizruk> > let insertWith f k v = fmap (\(k',v') -> (k', if k == k' then f k v' else v')) in insertWith (+) 2 3 [(1, 4), (2, 2)]
00:25:47 <lambdabot>   [(1,4),(2,4)]
00:26:24 <fizruk> > let insertWith f k v = fmap (\(k',v') -> (k', if k == k' then f k v' else v')) in insertWith (+) 2 3 [(1, 4)]
00:26:26 <lambdabot>   [(1,4)]
00:26:37 <fizruk> tada
00:26:49 <dementor> hi, i have a question: how can i reimplement 6-tuples equality operator, because on ghc is defined in GHC.Classes, and I would like to work on all ccomputers. My current implementation is instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => Eq (a, b, c, d, e, f) where   (a, b, c, d, e, f) == (g, h, i, j, k, l)     | a == g && b == h && c == i = True      | otherwise                  = False
00:26:52 <ReinH> wait, how does 2 + 3 = 4?
00:26:55 <klugez> Not f k v', f v v'
00:27:08 <ReinH> oh yeah I see
00:27:38 <fizruk> ReinH, the thing is it's not *insert*, it's *update* or something
00:27:49 <klugez> But can't do it with fmap, since you need to add if there's no key yet.
00:27:52 <ReinH> fizruk: true, so you can't use fmap
00:29:04 <ReinH> fst . foldr with (list, seen :: Bool) as the accumulator
00:29:08 <ReinH> would do it
00:29:20 <dementor> or is there a way to specify my own function when using (list \\ list)?
00:29:49 <ReinH> dementor: a 6-tuple is usually a good candidate for a data type
00:29:54 <ReinH> since then you can derive Eq ;)
00:30:09 <ReinH> and 6-tuples are hard to work with anyway
00:30:14 <Aetherspawn> I have a strong belief that it shouldn't be necessary to roll your own anything related to other peoples libraries
00:30:38 <ReinH> Aetherspawn: let me know how well that belief withstands its inevitable clash with reality ;)
00:30:43 <Aetherspawn> you'd think thats stupid, but this is the first time I've had that problem in months
00:30:52 <fizruk> dementor, you can always hide Prelude
00:30:53 <Aetherspawn> because generally its OK
00:31:07 <Aetherspawn> or you can compose smaller things together to make bigger things
00:31:14 <dementor> oh ok :) ill try that
00:31:18 <ReinH> Aetherspawn: *generally* one does not use IORefs as keys in maps :)
00:31:37 <fizruk> dementor, also you probably can do standalone deriving for 6-tuple if you don't have it
00:31:44 <ReinH> fizruk: good point
00:32:07 <Aetherspawn> ReinH: its nice to be overly critical of the solution, but using the IORefs as keys is most likely the most concise way of implementing what I need
00:32:41 <Twey> That doesn't mean you should do it :þ
00:33:10 <klugez> Aetherspawn: I don't understand how having IORefs as keys would make any sense, regardless of what you are doing. You can't compare them, only their contents.
00:33:18 <Aetherspawn> type NodeRef = IORef Node
00:33:19 <Aetherspawn> data Node = Node Word (Map NodeRef Frequency)
00:33:20 <Aetherspawn> data Chain = Chain (Map NodeRef Frequency)
00:33:34 <Aetherspawn> I assume you are familiar with a markov chain, otherwise, it looks like this:
00:33:48 <Aetherspawn> http://en.wikipedia.org/wiki/File:Finance_Markov_chain_example_state_space.svg
00:33:50 <simpson> Aetherspawn: What does it look like *without* the IORefs?
00:33:59 <Aetherspawn> simpson: its horrid and impossible
00:34:05 <Aetherspawn> tying the knot everywhere
00:34:09 <Twey> Why are there IORefs in a Markov chain…?
00:34:22 <simpson> Aetherspawn: Hm; I did it in Python with only primitives. I can't see how it would be harder in Haskell.
00:34:49 <Aetherspawn> I think you can do it with a zipper somehow while remaining pure, but it looked really really hard
00:35:18 <Aetherspawn> it all comes down to being able to insert more arms in a way that doesn't suck
00:35:20 <simpson> It's a mapping of the current state to the possible states... Something like: data Markov3 a = M.Map (a, a, a) (S.Set a)
00:35:24 <FreeFull> What about with ST? Or is that not enough?
00:35:32 <simpson> So what sucks about using Map and Set like normal?
00:35:55 <Aetherspawn> How does that map the graph?
00:36:13 <simpson> The graph is *emergent* from a traversal of the chains.
00:36:14 <Aetherspawn> Oh I see/
00:36:35 <simpson> And this lets you configure the entropy source used to randomize the paths.
00:36:59 <simpson> I dunno. I was a little, uh, parsimonious in my Python version, but I see no reason for it to be harder in Haskell.
00:37:26 <Aetherspawn> What happens here though, is that if you remove a node it's a hellish mess to clean up the map and set
00:37:52 <Twey> I think I'd use http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html or something similar
00:37:58 <simpson> A little bit of typing, but not too much.
00:38:05 <Aetherspawn> yeah its not too bad I guess.
00:38:24 <simpson> Anyway, only a couple dozen lines of Python: https://github.com/MostAwesomeDude/airbrush/blob/master/airbrush/tipsum.py
00:38:51 <Aetherspawn> simpson: you're MostAwesomeDude?
00:39:32 <ReinH> simpson: most awesome, dude!
00:39:42 <simpson> I try.
00:39:42 <Aetherspawn> heh, I started writing a minecraft server a while ago based off Baskerville
00:40:23 <ReinH> GHC has the best names: reallyUnsafePtrEquality#
00:40:50 <ReinH> seriouslyYouProbablyDon'tWantToPerformThisUnsafeIO#
00:41:04 <simpson> Baskerville's under active development. As usual, Minecraft gets in the way, but I'm trying to make something better than Bravo.
00:41:35 <Aetherspawn> so you're making a full server?
00:41:46 <simpson> Yeah.
00:41:50 <Aetherspawn> I tried but always ended up in cabal hell due to mine crafts weird encryption
00:42:03 <Aetherspawn> I did eventually get the encryption part working though
00:42:27 <simpson> Not doing the encryption. It got broken three times in three days; I'm boycotting it until they implement TLS instead.
00:42:37 <Aetherspawn> lol
00:42:42 <Aetherspawn> do you take pull requests?
00:42:46 <simpson> Of course!
00:42:52 <Aetherspawn> awesome ! :D
00:43:07 <codygman> I'm having a "not in scope: data constructor" error even though I'm importing it and it's constructor: http://lpaste.net/96052
00:44:24 <simpson> codygman: Don't pattern matches on the left like that have to be parenthesized? (Response ...)
00:45:00 <Aetherspawn> yes they do
00:47:54 <codygman> simpson: I fixed that, but I'm still getting the not in scope error :/
00:48:12 <scott_> I don't think that pattern match has to be parenthesized
00:48:36 <simpson> Hm. Well, I'm out of ideas, then.
00:49:16 <Twey> scott_: Response is a type; are you sure it has a constructor called Response?
00:49:38 <codygman> I looked and Network.HTTP.Conduit does expose Response
00:49:42 <scott_> Twey: s/scott_/codygman/
00:49:51 <Twey> Oh, sorry
00:50:31 <Twey> And no, that one doesn't have to be bracketed
00:50:31 <codygman> Twey: https://github.com/snoyberg/http-conduit/blob/master/Network/HTTP/Conduit.hs#L142
00:51:15 <scott_> codygman: It looks like they don't export the data constructors (no (..) after Response)
00:51:41 <Twey> codygman: That doesn't export the constructor, only the type
00:51:50 <Twey> The constructor would look like Response (Response)
00:52:06 <scott_> You'll want to do "resp <- http req manager" and then use the provided functions to get what you need from the Response
00:52:12 <Twey> Aye
00:52:46 <Twey> No Response constructors are exported from this module: it's opaque
00:53:21 <codygman> Twey: Oh, alright I see what you mean. scott_: Okay, I think I know what you mean.
01:20:17 <lpaste> lasticot pasted “Error Message” at http://lpaste.net/96054
01:20:21 <lpaste> lasticot pasted “main.hs” at http://lpaste.net/96055
01:20:24 <lpaste> lasticot pasted “SnakeGame.hs” at http://lpaste.net/96056
01:22:10 <lasticot> fizruk try to help me yesterday with this issue but I didn't quite understood the solution, can someone explain me what is the problem?
01:22:15 <lasticot> tried*
01:42:43 <lpaste> lasticot revised “Error Message”: “No title” at http://lpaste.net/96054
01:43:33 <lasticot> Can someone explain me what the problem is, I don't even understand the error message
01:44:26 <dv-> looks like you tried using liftIO in a State monad
01:45:16 <lasticot> these are the source code files: http://lpaste.net/96055 and  http://lpaste.net/96056
01:45:42 <lasticot> dv-: this part was not a problem in prevous version of the code
01:46:19 <lasticot> dv-:https://github.com/Daiwen/HaskellTraining/blob/master/other/snake/main.hs this version works fine
01:46:45 <lasticot> dv-: I changes the type of updateGameState since then though
01:46:48 <lasticot> changed*
01:48:03 <Taneb> Where does ghc-mod look for installed packages?
01:48:19 <dv-> to what did you change it?
01:49:34 <Taneb> Where does ghc-mod look for installed packages by default?
01:51:41 <lasticot> dv-: well As you may have seen in the new version I don't use modify anymore, and now the type is SnakeInputs -> S.State SnakeGame ()
01:52:47 <lasticot> dv-: my thoughts were to use the State monad to access the game state rather than thread it through the entire program
01:52:51 <dv-> lasticot: i don't think you can mix State and StateT like that. try changing it to SnakeInputs -> S.StateT SnakeGame IO ()
01:55:28 <lasticot> dv-: it's working thank you!
01:56:31 <lasticot> dv-: do you know if it's ok to have this IO in the type signature of the entire code because of the fact I'm using the a monad transformer
01:57:22 <fizruk> lasticot, you can use MonadState constraint instead
01:57:23 <lasticot> dv-: would it be nicer for me to use modify again and runState to use the state monad rather than the state transformer?
01:57:58 <lasticot> fizruk: ah! I'm sorry I have trouble understanding how it works
01:58:17 <lasticot> fizruk: can you re-explain me?
01:58:39 <dv-> if you need to do use IO functions in the state functions then this is the only way
01:59:19 <fizruk> lasticot, eventually you will use runStateT (mind T at the end) because in the end you will use StateT SnakeGame IO (that is IO in the lowest level)
02:01:14 <fizruk> lasticot, you have some functions that you want to work with SnakeGame state (updateSnake, updateFoodPosition, etc.)
02:01:42 <lasticot> fizruk:yep
02:02:19 <fizruk> lasticot, but actually don't care if the monad is `State SnakeGame` or `StateT SnakeGame IO` or even `RWST r w SnakeGame IO`
02:02:46 <lasticot> fizruk: yes I see it now
02:02:49 <fizruk> lasticot, all you care about is get/put functions that would work with SnakeGame state
02:03:12 <fizruk> lasticot, that is precisely what `MonadState GameState m` constraint gives you
02:03:23 <lasticot> fizruk: ok
02:04:26 <fizruk> lasticot, also there's a MonadIO class
02:05:39 <fizruk> lasticot, perhaps you could use that for initGameState and drawGameState
02:06:00 <lasticot> fizruk: the thing is when I change the type declaration of updateGameState from SnakeInputs -> S.State SnakeGame () to MonadState SnakeGame m => SnakeInputs -> m ()
02:06:30 <lpaste> lasticot revised “Error Message”: “No title” at http://lpaste.net/96054
02:06:36 <lasticot> fizruk: I reieve that:  http://lpaste.net/96054
02:07:09 <fizruk> lasticot, you should change types for all functions
02:07:30 <lasticot> fizruk: ok I will look into the MonadIO class
02:07:35 <fizruk> lasticot, in this case updatePlayer has an old, too concrete type
02:07:43 <lasticot> fizruk: ok
02:07:49 <fizruk> lasticot, so you can't use it in a more general one
02:11:13 <lasticot> fizruk: it is working now, and I feel I understood what I did
02:11:23 <lasticot> fizruk: thank you very much
02:11:48 <fizruk> lasticot, you're welcome :)
02:18:32 <codygman> Well this is quite a strange error... well at least one that looks strange to me: http://lpaste.net/96061
02:50:35 <Cale> codygman: What's the type of parseUrl?
02:52:44 <Cale> oh, I see
02:54:38 <Cale> codygman: The type of decode is FromJSON a => ByteString -> Maybe a
02:55:01 <Cale> codygman: and you've even given the last line of the do-block that type signature explicitly
02:55:32 <Cale> codygman: Therefore, the do-block as a whole must have type Maybe t for some t, and each of the actions being run in it must as well.
02:56:34 <Cale> But that doesn't work, since while the type of parseUrl is polymorphic enough to produce a Maybe result, withManager isn't.
02:57:45 <Cale> (Its type says it produces an action in any ResourceIO monad, which includes IO and various other monads built on top of that)
02:57:53 <Cale> (but not Maybe)
02:59:06 <Cale> codygman: So perhaps you meant to write something like   return . decode $ responseBody resp
02:59:38 <Cale> codygman: and then your problem will be that print getTimeSheets won't work, because getTimeSheets needs to be something like an IO action.
03:01:17 <lpaste> Cale annotated “No title” with “No title (annotation)” at http://lpaste.net/96061#a96062
03:01:36 <Cale> codygman: ^^ how to fix it
03:19:46 <ion> Title (no annotation)
03:33:43 <lpaste> nomeata pasted “Random Haskell” at http://lpaste.net/96063
03:34:11 <nomeata> I have some problem compiling the code at http://lpaste.net/96063, can anyone help me? :-)
03:38:28 <ion> The compiler would be the biggest help.
03:40:20 * hackagebot language-java 0.2.6 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.2.6 (VincentHanquez)
03:44:56 <skypers> hi
03:45:34 <nomeata> More random haskell. I need to increase the corpus of code to learn from. http://lpaste.net/96064
03:46:09 <skypers> quite compacte, nomeata :D
03:56:04 <chrisirc> I'm trying to use Data.Vector.Unboxed; it seems clear that I need to write an "instance Unbox Mytype where...",
03:56:24 <donri> nomeata: i don't follow, is there an inside joke i'm missing here? :p
03:56:25 <chrisirc> but can't figure out which methods it needs. I can't even find the code that defines class Unbox
03:57:13 <donri> chrisirc: looks like Unbox is just a collection of constraints
03:57:17 <chrisirc> http://hackage.haskell.org/package/vector-0.5/docs/Data-Vector-Unboxed.html  -> that links to sources having instance Unbox declarations without methods,
03:57:22 <chrisirc> and no class definition.
03:57:22 <nomeata> donri: I’m writing code that analyses existing Haskell code and then uses the probabilities in the syntax tree to generate similar code
03:57:42 <donri> chrisirc: you need to write instances for Vector and MVector and then just "instance Unbox Mytype"
03:57:55 <chrisirc> donri, well, I was expecting that it allows me to declare how to dissect Mytype into basic Int etc.
03:58:05 <donri> nomeata: ah :D
03:58:34 <donri> chrisirc: you do that in the Vector and MVector classes, i imagine
03:58:48 <chrisirc> I'll check.
03:58:51 <donri> chrisirc: did you see the code example at the top of the Unboxed module?
03:59:45 <chrisirc> donri, no, there's no example on http://hackage.haskell.org/package/vector-0.5/docs/Data-Vector-Unboxed.html
04:00:06 <donri> chrisirc: https://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Unboxed.html
04:00:13 <donri> 0.5 is old :)
04:01:53 <chrisirc> Aha. No idea how I landed on that version.
04:02:06 <donri> hackage is hostile to search engine indexing
04:02:16 <donri> i was hoping hackage2 would fix that, maybe not...
04:03:07 <chrisirc> Usually I'm using hoogle. But IIRC I also googled for some tutorial and perhaps that way I ended up there.
04:03:30 <donri> at least hackage2 has a search feature itself
04:03:37 <donri> https://hackage.haskell.org/packages/search?terms=vector
04:03:50 <chrisirc> Nice
04:04:00 <chrisirc> Another haskell search engine after Hoogle and Hayoo :)
04:04:10 * chrisirc adds bookmark
04:04:24 <donri> well this one searches packages, not apis
04:05:27 <chrisirc> Perhaps hackage could add a release date to the version number display.
04:05:41 <donri> it does on the package front page
04:05:45 <chrisirc> And, perhaps, a popup on the version number that shows all the other versions :)
04:06:04 <chrisirc> Or something. (Perhaps that would be too long.)
04:06:27 <donri> it's not a shit idea :) it's somewhat complicated by the fact that haddocks are generated by a separate tool
04:06:37 <chrisirc> Perhaps just a link to a page that has a list of all versions.
04:07:08 <donri> but the first step should be to ensure that search engines just index the latest version
04:07:31 <donri> with URLs that always point to the latest version
04:08:19 <donri> chrisirc: that link exists though, "Contents"
04:09:26 <chrisirc> Hm
04:11:13 <chrisirc> I guess the release date might have made me notice. Or a red marker that says "this is not the newest version".
04:11:58 <chrisirc> And yes, primarily using URLs that always show the latest version would surely be useful.
04:12:15 <lpaste> nomeata pasted “Random Haskell generated from GHC’s code” at http://lpaste.net/96065
04:12:17 <chrisirc> anyway, reading the example now.
04:14:30 <chrisirc> PS. here's how I got to version 0.5: http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
04:14:49 <chrisirc> I clicked on "Unboxed" under "2 Tutorial"
04:19:05 <chrisirc> I still don't get it. I surely have to tell the system how to pick out the numbers out of Mytype so that they can be stored unboxed in the vector?
04:20:06 <chrisirc> (I'm operating on a "try things until it somehow works" level here.)
04:20:08 <augur_> whats a good way to handle zippers that only really need to do an in-order traversal?
04:30:06 <chrisirc> Sigh, what's at the "..." anyway, in that example? That's exactly the list of methods that I was looking for.
04:31:57 <Aetherspawn> lasticot: State = StateT Identity
04:32:12 <Aetherspawn> You can infact use the Identity monad
04:32:57 <Aetherspawn> oh, bugger, the scroll buffer wasn't scrolling down. That must've been from hours ago. sorry ;_;
04:36:01 <Freundlich> Can I consider an FFI imported function to be pure when the C function always returns the same result given the same pointer argument (obviously, if the pointed to object has already been freed, the function will crash instead)?
04:50:32 <donri> Freundlich: if you use ForeignPtr and don't free it from C, that sounds pure
04:51:49 <Freundlich> donri: Yes, the pointer argument can only be freed when its ForeignPointer is freed.
04:59:10 <joastbg> Hi all, I'm planning a master thesis project for next spring, about STM and the different concurrency control schemes available, currently 3 as far as I know. Any ideas?
05:02:03 <gienah> joastbg: you could implement read-only MVCC concurrency control STM like clojure, and use the Haswell transactional memory instructions :]
05:03:48 <marko2> merijn: Hi! Just a quick update about the mmap-issue from yesteday. It seems there was no real memory leak after all, it was just that the display in top is a bit misleading..
05:05:47 <joastbg> gienah: nice idea, will look into it!
05:05:49 <marko2> merijn: resident and shared memory both went up, but under certain circumstances it did do so only up to a small constant limit. When it increased I thought it was a leak, but it seems it is simply the decision of the OS how many pages are loaded into memory, and they are freed on demand
05:06:09 <marko2> merijn: not 100% sure though
05:07:12 <arkeet> marko2: that's what I would have expected.
05:07:20 <arkeet> :-)
05:19:55 <haskellnoob> Given a string which represents a number, I want to get a list of all the digits in this number. So I wrote a function as follows:
05:20:11 <haskellnoob> -- Get the list of digits in a number
05:20:12 <haskellnoob> getDigits :: String -> [Int]
05:20:14 <haskellnoob> getDigits (digit : []) = (read [digit] : [])
05:20:15 <haskellnoob> getDigits (digit : digits) = (read [digit] : getDigits digits)
05:20:35 <haskellnoob> This works. But it looks to me like I am mapping something over the String here.
05:21:14 <haskellnoob> What exactly am I mapping here? In other words, how can I write getDigits in the form: getDigits = map someFunction ?
05:21:45 <haskellnoob> the function I want to map is a combination of "read" and "[]"
05:21:52 <chrisirc> someFunction = read
05:21:55 <haskellnoob> but how do I express this?
05:22:07 <chrisirc> ah wait
05:22:25 <bergmark> read . (:[])
05:22:42 <chrisirc> yep
05:22:44 <haskellnoob> chrisirc: yes, I tried that first but the compiler complained
05:22:51 <haskellnoob> bergmark: thank you, let me try that
05:23:07 <haskellnoob> and how exactly does one arrive at this answer?
05:23:23 <haskellnoob> what is the ":" doing in (:[])
05:23:37 <haasn> (:[]) = pure
05:23:39 <haasn> or return
05:23:52 <haskellnoob> haasn: but read. return doesn't wokr
05:23:54 <haskellnoob> *work
05:23:55 <haasn> haskellnoob: it's an operator section, \x -> x : []
05:24:02 <haasn> :t read . return
05:24:03 <lambdabot> Read c => Char -> c
05:24:29 <haasn> read accepts a list so return is already fixed to (:[])
05:24:32 <haasn> there's literally no difference
05:24:46 <haskellnoob> but map (read . return) "12345" gives me an error
05:24:58 <haasn> > map (read . return) "12345" :: [Int]
05:24:59 <lambdabot>   [1,2,3,4,5]
05:25:01 <scott_> Which error?
05:25:06 <haasn> > map (read . (:[])) "12345"
05:25:07 <lambdabot>   [*Exception: Prelude.read: no parse
05:25:21 <haskellnoob> scott_: the error was because read didn't know what kind of thing to read, i guess
05:25:32 <haskellnoob> Ambiguous type variable `b0' in the constraint:
05:25:33 <haskellnoob>       (Read b0) arising from a use of `read'
05:25:33 * hackagebot thorn 0.2 - Datatype Manipulation with Template Haskell  http://hackage.haskell.org/package/thorn-0.2 (Kinokkory)
05:25:39 <bergmark> > map (read . (:[])) "12345" :: [Int]
05:25:40 <lambdabot>   [1,2,3,4,5]
05:25:53 <haskellnoob> yes, that :: [Int] is required
05:26:00 <scott_> haskellnoob: Right, you need to specify that somewhere if it can't be inferred.
05:26:24 <scott_> haskellnoob: But inside your getDigits you won't need :: [Int] because Haskell already knows that from the type signature.
05:26:47 <haskellnoob> thank you all, that helped me
05:27:27 <klrr_> map (:[]) "12345"
05:27:30 <klrr_> > map (:[]) "12345"
05:27:31 <lambdabot>   ["1","2","3","4","5"]
05:29:43 <haskellnoob> klrr_: I want a list of Ints, so the read is required to be mapped as well
05:32:02 <mr-> > map digitToInt "12345"
05:32:03 <lambdabot>   [1,2,3,4,5]
05:33:05 <scott_> > map digitToInt "abcd"
05:33:06 <lambdabot>   [10,11,12,13]
05:33:23 <nooodl> @src digitToInt
05:33:23 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:34:13 <haasn> > map (review hex . return) "12345"
05:34:13 <mr-> it's in Data.Char, but not total
05:34:14 <lambdabot>   No instance for (GHC.Base.Monad m0)
05:34:14 <lambdabot>    arising from a use of `GHC.Base.retu...
05:34:24 <haasn> > map (preview hex . return) "12345"
05:34:26 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
05:34:42 <haasn> > mapM (preview hex . return) "12345"
05:34:43 <lambdabot>   Just [1,2,3,4,5]
05:34:58 <scott_> What are review/preview?
05:34:59 <klrr_> :t digitToInt
05:35:00 <lambdabot> Char -> Int
05:35:12 <klrr_> :t read '1'
05:35:13 <haasn> > "12345" ^.. folded.to pure.hex
05:35:13 <lambdabot>     Couldn't match type `Char' with `[Char]'
05:35:13 <lambdabot>     Expected type: String
05:35:13 <lambdabot>       Actual type: Char
05:35:14 <lambdabot>   [1,2,3,4,5]
05:35:20 <hpc> > digitToInt 'f'
05:35:20 <lambdabot>   15
05:35:32 <klrr_> :t read ['1']
05:35:32 <lambdabot> Read a => a
05:35:41 <klrr_> > read ['1']
05:35:42 <lambdabot>   *Exception: Prelude.read: no parse
05:35:52 <haasn> scott_: lens functions
05:36:03 <scott_> haasn: Ah, thanks
05:36:21 <mr-> :t readMaybe
05:36:22 <lambdabot> Not in scope: `readMaybe'
05:36:24 <mr-> aww
05:40:01 <donri> :t Text.Read.readMaybe
05:40:01 <lambdabot> Read a => String -> Maybe a
05:48:44 <fizruk> > let f (Left x) = Left x; f (Right y) = Right (tail <$> y) in f (Left 2)
05:48:45 <lambdabot>   No instance for (GHC.Show.Show (f0 [a0]))
05:48:45 <lambdabot>    arising from a use of `M547931...
05:49:20 <fizruk> > let f (Left x) = Left x; f (Right y) = Right (tail <$> y) in f (Left 2) ^? _Left
05:49:21 <lambdabot>   Could not deduce (GHC.Base.Functor f0) arising from a use of `f'
05:49:21 <lambdabot>  from the ...
05:57:21 <haasn> I'm trying to write a parser, that in addition to returning the AST, also gives me the original ByteString that resulted in each element
05:59:01 <haasn> for example “1*(2+3)” could return in Mult "1*(2+3)" (Lit "1" 1) (Add "2+3" (Lit "2" 2) (Lit "3" 3))
05:59:11 <haasn> the first parameter of each constructor is the original string that resulted in it
06:00:29 <marko2> arkeet: indeed.. it was just so confusing that sometimes, htop would shot a constant of 3% memory, and sometimes it would be continuously increasing
06:03:33 <klrr_> using this kind of FRP game loop https://gist.github.com/HeinrichApfelmus/3821030 , is it correctly intepreted that you render graphics inside the event network?
06:03:43 <klrr_> gameNetwork*
06:11:13 <merijn> marko2: That sounds like what I initially expected, yeah
06:11:40 <marko2> merijn: indeed.. it was just so confusing that sometimes, htop would shot a constant of 3% memory, and sometimes it would be continuously increasing
06:11:52 <marko2> show, not shot
06:12:52 <merijn> I don't rely on top for memory estimates anymore, I found it to unreliable. Especially when you're doing funky things (i.e. use a full 4GB of virtual memory on a box with only a few 100 MB RAM)
06:26:03 <mangaba_leitosa> I'm trying -XDisambiguateRecordFields as described on http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html, and the example is not working for me: despite of -XDisambiguateRecordFields, ghc still says "Ambiguous occurrence `x'". What's wrong?
06:29:07 <donri> mangaba_leitosa: are you using separate modules?
06:29:28 <donri> it only works for records defined in different modules
06:29:29 <mangaba_leitosa> donri: yes
06:30:04 <donri> mangaba_leitosa: are you trying this with record *updates*?
06:30:37 <donri> it only works for construction, as the constructor is what disambiguates it
06:32:10 <lpaste> mangaba_leitosa pasted “-XDisambiguateRecordFields not working” at http://lpaste.net/96066
06:32:15 <mangaba_leitosa> donri: I'm trying the exact example shown in the docs: ^ see lpaste
06:33:00 <mangaba_leitosa> donri: oh
06:33:03 <mangaba_leitosa> donri: I misread the doc
06:33:13 <mangaba_leitosa> donri: only the former two are correct
06:33:18 <donri> yes
06:33:26 <mangaba_leitosa> donri: thanks :_)
06:33:34 <donri> does it work if you remove bad1/2?
06:33:42 <mangaba_leitosa> checking
06:33:48 <donri> the error messages seem to be for ok1/2...
06:33:55 <donri> based on line numbers
06:33:57 <donri> no wait
06:33:59 <donri> nevermind
06:34:14 <donri> lpaste's line numbers /= module Main's line numbers
06:34:23 <corkexaminer> trying to find out why the haddocks aren't showing for pbkdf on hackage
06:34:28 <mangaba_leitosa> donri: yes, working now
06:34:39 <corkexaminer> anybody know where I can find the logs?
06:35:03 <Rylee> Hey, anyone know how to fix the "state not initialized" thing with lambdabot's src command by default?
06:35:40 * hackagebot neat-interpolation 0.2.0 - A quasiquoter for neat and simple multiline text interpolation  http://hackage.haskell.org/package/neat-interpolation-0.2.0 (NikitaVolkov)
06:36:31 <marko2> merjin: how do you measure memory then?
06:38:31 <donri> corkexaminer: https://github.com/haskell/hackage-server/issues/37
06:38:59 <donri> corkexaminer: https://hackage.haskell.org/package/pbkdf-1.1.1.0/reports/ not very helpful though :)
06:41:34 <corkexaminer> donri: but very helpful to know -- thanks!
06:44:19 <merijn> marko2: Depends on platform, DTrace, sysfs, etc.
06:44:38 <marko2> ok
06:44:41 <marko2> thanks
06:58:46 <Bubus> Hi guys!
06:59:48 <Bubus> I don't speck english very well...but I need to help in haskell
07:00:20 <hpc> what problem are you having?
07:02:46 <Bubus> I'm italian and  I need documentation haskell in Italian
07:04:20 <sm> haskell documentation translations are quite scarce
07:05:04 <hpc> yeah, i can't find translations of the report, lyah, or rwh
07:05:18 <hpc> google translate might be helpful
07:06:19 <Bubus> I know, but I dont' speck english and 4 me haskell is very difficult..
07:08:16 <Dodek> Bubus: it's probably best for you if you learn english
07:08:41 <hpc> Bubus: good luck learning both languages; it's definitely worth it
07:09:22 <Bubus> thank you boys... =(
07:13:56 <sm> Bubus: what is http://translate.google.com/translate?sl=en&tl=it&js=n&prev=_t&hl=en&ie=UTF-8&u=https%3A%2F%2Fwww.fpcomplete.com%2Fschool%2Fstarting-with-haskell%2Fintroduction-to-haskell%2F1-haskell-basics like ?
07:14:41 <sm> or http://translate.google.com/translate?sl=en&tl=it&js=n&prev=_t&hl=en&ie=UTF-8&u=https%3A%2F%2Fwww.fpcomplete.com%2Fschool%2Fstarting-with-haskell%2Fbasics-of-haskell
07:16:29 <Bubus> <sm> Thank you but the translation in very bad
07:18:50 <osfameron> Bubus: there is a #haskell-it channel isnt there?
07:19:24 <osfameron> they might have some pointers
07:19:57 * osfameron really wanted to go to their meeting in the 5 terre a couple of years back...
07:20:21 <Bubus> yes, there is...but there are only only 2
07:20:44 * hackagebot hTalos 0.2 - Parser, print and manipulate structures in PDB file format.  http://hackage.haskell.org/package/hTalos-0.2 (MichalGajda)
07:20:54 <osfameron> ah, used to be busier iirc
07:20:59 <sm> #haskell.it
07:22:30 <joneshf-laptop> if i've used the pragma DeriveFunctor to derive a functor on a data type, how can i see the instance it generated?
07:25:44 * hackagebot parsestar 1.4 - NMR-STAR file format parser.  http://hackage.haskell.org/package/parsestar-1.4 (MichalGajda)
07:26:09 <sm> Bubus: maybe promote #haskell.it on the haskell-cafe list
07:33:45 <joneshf-laptop> or maybe i'm asking the wrong question
07:34:07 <joneshf-laptop> is there a way to see the instance of a datatype outside of the source file?
07:34:10 <joneshf-laptop> like with ghci
07:34:35 <joneshf-laptop> i see info can tell you if it is an instance, but i want to see how it's defined
07:42:18 <kthl`> Bubus: I'm italian too, join #haskell.it one sec.
07:42:41 <zennist> some questions regarding 'instance'. How can I know whether a value actually implements a particular type class?
07:43:34 <Fuuzetsu> zennist: You can ask GHCi with ‘:i’ about a type and it will show you the instances that are in scope.
07:43:45 <jophish> Yo yo yo, motherfuckers
07:44:29 <jophish> Say I had a datatype for vectors, data Vec3 a = Vec3 a a
07:44:47 <jophish> What's the neatest way of enforcing that a be an instance of Num?
07:44:47 <zennist> so I have this value that might or might not implement a type class. I want my function to return Nothing if it doesn't implement the type class I'm looking for; and Just $ (some result) if it does implement the type class and I have some processing on it
07:45:40 <zennist> Fuuzetsu: I'm talking about deciding that within a script
07:48:28 <Fuuzetsu> zennist: Oh. You'll probably have to dig into GHC API for such thing. Depends on what your actual use case is.
07:48:56 <Peaker> zennist: what are you trying to do? That sounds like a very weird thing to do
07:49:23 <Fuuzetsu> jophish: You don't. You do ‘instance Num a => Vec3 a where …’ instead.
07:50:02 <Fuuzetsu> You can technically constrain it on the data type but it's discouraged
07:51:07 <jophish> Fuuzetsu: I don't quite understand the syntax there, what does the => mean in an instance declaration?
07:52:26 <Fuuzetsu> jophish: ‘Num a =>’ means that ‘a’ has to have an instance of Num. What we're saying is that ‘we're declaring an instance of Num for ‘Vec3 a’ as long as ‘a‘ already has a Num instance’.
07:52:38 <jophish> ah I see
07:53:02 <Fuuzetsu> So with that, ‘Vec3 Integer’ would have an instance of Num while ‘Vec3 String’ wouldn't.
07:53:07 <jophish> Fuuzetsu: what if I don't want Vec3 a to be an instance of Num
07:53:27 <Fuuzetsu> jophish: Then you don't give it an instance? I don't follow.
07:53:32 <jophish> I jus require that for any 'a' in 'Vec3 a', 'a' is a Num
07:53:43 <jophish> to prevent things like Vec3 String
07:53:56 <Fuuzetsu> Well, there are two ways
07:54:01 <Fuuzetsu> one sec going to try and pull up a link
07:54:13 <jophish> thanks
07:54:19 <evancz> Hi, I am trying to send a multipart/form-data POST request with a file. Are there any resources on doing this with the basic Network libraries?
07:54:32 <jophish> the word about the internet is that data type contexts aren't cool
07:54:50 <evancz> jophish: me?
07:55:01 <jophish> evancz: sorry, no
07:55:06 <evancz> np :)
07:56:02 <Fuuzetsu> jophish: http://www.haskell.org/haskellwiki/Data_declaration_with_constraint
07:57:29 <Fuuzetsu> Very lacking page… In any case, I believe nowadays GADTs is the right way to do it
07:57:45 <jophish> Fuuzetsu: awesome
07:57:49 <enthropy> no constraint may be the right way too
07:57:52 <jophish> they seem like a nice way of specifying things
07:59:04 <zennist> Peaker: I'm trying to implement a new layout for XMonad. In XMonad every layout is an instance of LayoutClass, but I try to make  my layout have more methods than those defined in LayoutClass by defining new type classes and conforming it to them so in my main I can query more information. The problem is that (obviously) other layouts won't implement these methods and I need a way in my main to know if it is
07:59:06 <zennist> the kind of customized layout I wrote or just normal ones written by other ones
07:59:06 <Fuuzetsu> Personally I'd just stick to not forcing ‘a’ to be Num…
08:00:43 <enthropy> zennist: what are the new methods? Why don't they fit inside whatever the provided ones are?
08:01:47 <zennist> enthropy: the basic ones provide utility for handling messages but not giving feedback. The only feedback I can get from each layout is 'description', or name of the layout. My new methods can return the structure of the windows being managed by that layout
08:02:37 <enthropy> what you can do for feedback is a message like   data AndThen = AndThen ( [Window] -> X () )
08:03:26 <zennist> entropy: looks interesting. can you elaborate a bit on that? I'm afraid I'm quite new to Haskell
08:04:01 <enthropy> your handleMessage will then get that information (lets say it's parameters for how the layout is running rather than a list of Window) and supply it to the function that's sent in the message
08:04:55 <zennist> enthropy: brilliant! I didn't think of that
08:05:30 <enthropy> an example (which probably doesn't help) is http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Layout-SubLayouts.html#t:GroupMsg
08:07:14 <zennist> enthropy: that definitely helps. thanks!
08:10:48 * hackagebot pbkdf 1.1.1.1 - Haskell implementation of the PBKDF functions from RFC-2898.  http://hackage.haskell.org/package/pbkdf-1.1.1.1 (ChrisDornan)
08:33:36 <bz> is ST the state transformer? i thought it was StateT
08:34:51 <bz> launchbury 1994 calls it the state transformer
08:34:51 <merijn> bz: ST is State Threads
08:34:54 <chrisdone> ST is for strict state threads
08:34:57 <hpc> ST is the "IO without IO" monad
08:35:18 <hpc> you have mutable arrays and references and such, but you can't perform any side effects and mutable vars can't escape the action
08:35:20 <bz> he function
08:35:20 <bz> takes an initial value, of type
08:35:20 <bz> , say, and delivers a state transformer of type
08:35:22 <bz> . When this is applied to a state,
08:35:24 <bz> oops
08:35:25 <chrisdone> 1994 it's probably just a naming convention difference
08:35:47 <bz> any idea what MutVar is?
08:36:04 <merijn> bz: Presumably a MUTable VARiable
08:36:49 <merijn> bz: I looked at the ST docs, transformer is being used in a different sense then monad transformer
08:36:58 <merijn> bz: i.e. ST is something that "transforms state"
08:37:08 <bz> "the type MutVar s a is the ttype fo referencesallocated from a store of type s, containing a value of type a."
08:37:12 <merijn> not a "monad transformer for the ST monad"
08:37:59 <bz> the etymology of the type name is obvious, but it's really unclear how it works, like what exactly a reference is
08:38:24 <chrisdone> that seems to be an STRef
08:38:28 <chrisdone> where are you reading this?
08:38:33 <bz> launchbury 1994
08:38:58 <bz> chrisdone: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.144.2237&rep=rep1&type=pdf
08:39:14 <Iceland_jack> bz: You can search for "ST haskell" and find other references
08:39:45 <chrisdone> yeah this is just old terminology for what is now the ST monad and ST refs
08:40:20 <hpc> bz: in all honesty, your best source for ST is the haddock
08:40:22 <bz> Iceland_jack: did that already, and not really, because my next question would be where the friendly ST guides are
08:40:29 <hpc> if you know IO, you already know ST
08:40:51 <countoren> hello
08:41:08 <Iceland_jack> hi
08:41:16 <countoren> im trying to install mongodb binding in haskell and im getting this error
08:41:22 <countoren> cabal: Error: some packages failed to install: binary-0.7.1.0 failed during the building phase
08:41:38 <b_jonas> merijn: yes, that's because you can't really have a monad transformer version of ST, just like you can't have one from IO either
08:41:41 <countoren> anybody have expreince with that?
08:41:46 <hpc> countoren: there will likely be a root error further up, if you can find that and paste it?
08:41:48 <Iceland_jack> bz: http://www.haskell.org/haskellwiki/Monad/ST is there anything here that's unclear?
08:41:49 <hpc> @hpaste
08:41:49 <lambdabot> Haskell pastebin: http://lpaste.net/
08:41:57 <b_jonas> ST has to go to the bottom (or possibly over IO)
08:42:10 <bz> "After reading this text, you will receive a "Master of Haskell I/O" degree that is equal to a Bachelor in Computer Science and Mathematics, simultaneously."
08:42:11 <Iceland_jack> It is the first hit I get when I search for ST and Haskell
08:42:49 <bz> Iceland_jack: the whole thing. significance of 'forall'?
08:43:06 <Iceland_jack> Don't worry about that now, just try out some simple examples
08:43:25 <bz> read that one last night, doesn't really elaborate on what the definition of STRef
08:43:26 <Iceland_jack> also, are you familiar with IO and the Monad type class?
08:43:30 <bz> maybe i'll read on IO first
08:43:32 <piezoid> chrisdone: I'm trying to use Parsec.Expr to implement extensible syntax in Hell
08:43:34 <Iceland_jack> maybe you should
08:43:43 <countoren_> hpc: sure let me check
08:43:55 <bz> Iceland_jack: not reall yon IO apart from print/read; of course on class Monad
08:44:23 <Iceland_jack> bz: You can ignore ST for now, you rarely need to us it
08:44:24 <Iceland_jack> *use
08:44:34 <countoren_> what is the the site for pasting?
08:44:34 <Iceland_jack> especially if you aren't familiar with IO already
08:44:38 <hpc> @hpaste
08:44:38 <lambdabot> Haskell pastebin: http://lpaste.net/
08:44:38 <Iceland_jack> countoren_: topic
08:44:52 <bz> Iceland_jack: i actually do need it, thanks.
08:45:11 <chrisdone> piezoid: go for it =)
08:45:42 <lpaste> countoren pasted “Error Cabal Install mongoDB” at http://lpaste.net/96068
08:45:49 <Iceland_jack> bz: Be that as it may, I recommend you wait with learning it since it's a more advanced feature than the IO monad
08:45:53 <bz> Iceland_jack: and i would have appreciated a "learn IO first" instead of "forget ST, it's too hard and you don't need it"
08:46:11 <piezoid> chrisdone: but I refactored using a GhcT (IOEnv HellState) stack, maybe you won't like it :/
08:46:12 <Iceland_jack> Well bz, learn IO first.
08:46:33 <hpc> countoren_: lol, your problem is actually kind of hilarious
08:46:33 <hpc>      error: invalid preprocessing directive
08:46:34 <hpc>      #-}
08:46:36 <Iceland_jack> Also I believe I said “ignore ST for now” bz
08:46:50 <hpc> it thinks the end of a {-# pragma #-} is CPP
08:47:02 <countoren_> which means
08:47:26 <piezoid> chrisdone: maybe I'll put InputT somewhere too
08:47:38 <hpc> there's enough other warnings in that log too that i would send the whole thing to the maintainer
08:47:59 <hpc> Author	Lennart Kolmodin <kolmodin@gmail.com>
08:47:59 <hpc> Maintainer	Lennart Kolmodin, Don Stewart <dons00@gmail.com>
08:48:05 <countoren_> so its not my fault? :)
08:48:09 <hpc> not your fault
08:48:12 <geekosaur> countoren_, see the end of the /topic
08:48:16 <hpc> not sure if you will be able to reach dons though
08:48:46 <hpc> geekosaur: is this an xcode issue?
08:49:10 <geekosaur> if you see -Winvalid-pp-token it is the xcode (really clang) issue
08:49:17 <hpc> oh, huh
08:50:05 <geekosaur> ...although I dread when that starts happening on other systems because someone has replaced gcc with clang for some reason
08:52:00 <countoren_> there is something i can do to fix it ?
08:52:16 <geekosaur> once again: see the end of the /topic
08:52:42 <hpc> countoren_: http://is.gd/H4sEub - "GHC 7, whether installed directly or via Haskell Platform, can be made to work with this wrapper script:"
08:52:53 <hpc> countoren_: "An alternate approach for users with Xcode 5 is to install a gcc and direct GHC at that"
08:52:58 <hpc> top of the page
08:53:05 <hpc> bottom of the top of the page
08:54:13 <countoren_> hpc: will be fixed in the next release?
08:54:29 <hpc> countoren_: no idea; i don't OSX
08:54:50 <countoren_> i mean in the haskell(cabal) side
08:55:07 <hpc> dunno
08:56:45 <geekosaur> supposedly ghc 7.8 has a fix for it
09:02:29 <geekosaur> also the haskell platform folks are still arguing over how to deal with it in the next h-p release since 7.8 wont be out in time, although theyr'e taking long enough that it might be moot >.>
09:03:46 <piezoid> is it frequent to have GHC built without mtl ? (mine is, on ArchLinux)
09:04:10 <bennofs> piezoid: yes. Just do cabal install mtl if you want to get mtl
09:04:48 <bennofs> piezoid: But I think mtl is in the haskell platform. GHC itself does only have libraries it depends on or that are heavily dependent on GHC internals
09:05:09 <piezoid> it's hard to deal with GHC.MonadUtils.MonadIO and Control.Monad.IO.Class.MonadIO differences
09:05:19 <countoren_> pieziod: should i try diong cabal install mtl first?
09:05:33 <piezoid> mtl is installed, no problem with that
09:06:19 <piezoid> but my ghc api use a custom MonadIO class because it is build without mtl
09:06:57 <enthropy> mtl should be re-exporting the MonadIO class from somewhere else (transformers?)
09:07:19 <piezoid> there is #if !HAVE_MTL class MonadIO m ... #endif in ghc's MonadUtils
09:10:20 <piezoid> enthropy: yes, but I have to deal with qualified imports and declare an instance of MonadIO using the instance of the other version, either way
09:10:30 <gelisam> hi! is there a tool to help choosing appropriate version ranges in cabal, perhaps by trying a bunch of combinations and reporting which ones fail?
09:11:02 <Tomsik> Hi, I want to get something equivalent to f (a : b : l) = (a, b) : f l; f _ = [], but without explicit recursion
09:11:16 <enthropy> cabal init fills in some version ranges, but it doesn't try much
09:11:29 <enthropy> or rather it doesn't try to build your code at all
09:11:37 <Tomsik> I had this problem a few times before and never though of anything satisfactory
09:12:20 <enthropy> > chunksOf 2 [1 .. 10]
09:12:21 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
09:12:34 <gelisam> thanks! I'll try to build my own, then.
09:12:47 <Tomsik> Where does it come from?
09:12:55 <enthropy> split
09:13:20 <enthropy> http://hackage.haskell.org/package/split-0.2.2
09:13:32 <Tomsik> Looks good, thanks
09:15:25 <gelisam> > map (head &&& head.tail) (chunksOf 2 [1 .. 10])
09:15:26 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
09:15:42 <gelisam> slight improvement :)
09:17:20 <Tomsik> Oh well, [1,2] is good enough when you pattern-match right away
09:17:46 <gelisam> I agree
09:17:51 <Iceland_jack> > map (\[x,y] -> (x, y)) (chunksOf 2 [1 .. 10])
09:17:52 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
09:18:15 <gelisam> even better!
09:18:19 <oio_> can someone give me an example of runProcces?
09:18:21 <kazu> aa
09:18:29 <oio_> with handles being use?
09:22:00 <Iceland_jack> oio_: runProcess "/usr/bin/tr" ["a-z", "A-Z"] Nothing Nothing (Just file) Nothing Nothing
09:22:13 <Iceland_jack> where: file <- openFile "/tmp/file" ReadMode
09:22:49 <Iceland_jack> ghci> readFile "/tmp/file"
09:22:49 <Iceland_jack> "testin\n"
09:22:49 <Iceland_jack> ghci> file <- openFile "/tmp/file" ReadMode
09:22:49 <Iceland_jack> ghci> runProcess "/usr/bin/tr" ["a-z", "A-Z"] Nothing Nothing (Just file) Nothing Nothing
09:22:52 <Iceland_jack> TESTIN
09:22:56 <Iceland_jack> Does that answer your question oio_?
09:23:21 <Iceland_jack> You have to import System.IO and System.Process
09:24:42 <Iceland_jack> You can then specify an optional handle for the standard output
09:25:02 <haasn> ‘drop’ on a ByteString just returns a new slice with the same pointer but a different length and offset, right?
09:25:45 <haasn> How does the GC handle this? Say I have xs <- take 10 $ readInSomeGiganticByteString -- will the GC eventually realize that I'm only ever using a small fragment of the gigantic bytestring and reallocate it?
09:25:48 <monochrom> I think yes
09:25:53 <Iceland_jack> so if you want to emulate:
09:25:53 <Iceland_jack>     $ <in tr a-z A-Z >out
09:25:53 <Iceland_jack> you'd do:
09:25:53 <Iceland_jack>     do in <- openFile "in" ReadMode; out <- openFile "out" WriteMode; runProcess "/usr/bin/tr" ["a-z", "A-Z"] Nothing Nothing (Just in) (Just out) Nothing
09:25:58 <copumpkin> I think no
09:26:23 <haasn> ah, this is explicitly mentioned in the haddock description of ‘copy’
09:28:13 <oio_> Iceland_jack: well, what i don't understand i how to use the handles to stdin stdout etc i need to use them all because i need to star the procces witouth a windows and to to this you need to use all the handles "From peeking at the ghc source code file runProcess.c, I found that the CREATE_NO_WINDOW flag is set when you supply redirects for all of STDIN, STOUT, and STDERR. So that's what you need to do, supply redirects for those."
09:29:49 <Iceland_jack> stdin, stdout and stderr are available through importing System.IO
09:30:19 <oio_> Iceland_jack: Yes but how do i use them?
09:30:27 <Iceland_jack> How do you want to use them?
09:30:38 <Iceland_jack> If you want to supply input from stdin, you use that handle
09:30:50 <khyperia> Anybody from FPComplete here? It says Data.Map.Strict isn't found, what do I need to get it imported?
09:31:44 <oio_> Iceland_jack: Example
09:32:00 <Iceland_jack> Exactly what I posted above only s/file/stdin/
09:32:06 <geekosaur> khyperia, what version of ghc and of the containers package do you have?
09:32:16 <khyperia> No idea, how do I check?
09:35:30 <oio_> Iceland_jack: lol didn't saw it thanks
09:38:04 <geekosaur> (I'm thinking Data.Map.Strict is relatively recent and and old enough containers won't have it)
09:38:34 <geekosaur> anyway: ghc --version; ghc-pkg list containers
09:38:48 <khyperia> I'm on fpcomplete, though, no idea how to do that with fpcomplete
09:38:53 <geekosaur> oh
09:39:04 <geekosaur> I ws wondering why you were asking abotu them
09:39:19 <geekosaur> I do not know what versions of stuff they have but it would be odd for them to have older containers
09:39:47 <chrisdone> piezoid: just fork it
09:41:11 <monochrom> perhaps don't use fpcomplete :)
09:41:34 <kazu> If I want to read a first column of of a data file which contain 4columns, how do I do?
09:41:39 <khyperia> Perhaps I want to use fpcomplete since it's very nice.
09:41:48 <redscare> is there a way, in haskell, to create a function memoize that takes a function in and memoizes?
09:42:16 <khyperia> If I dropped every product that had a single tiny glitch in it, I would have exactly zero products left.
09:42:26 <redscare> this is possible, in, for example lisp and python
09:42:32 <David> redscare: http://hackage.haskell.org/package/memoize-0.6/docs/Data-Function-Memoize.html
09:42:33 <kazu> What I am doing is something like map ((!!) (map read (words filehandle) :: [Double])) [0,4..]
09:43:15 <piezoid> chrisdone: I'm having hard time with duplication of MonadIO and MonadException classes...
09:43:52 <redscare> David: is there no elegant way to handle multiple arguments (the package you sent doesn't seem to)?
09:45:05 <chrisdone> piezoid: yeah it should really use monad-base and monad-control
09:48:06 <chrisdone> khyperia: ahoy, i work at fp complete
09:48:16 <khyperia> oh, awesome
09:48:28 <khyperia> did you hear my question?
09:48:46 <khyperia> basically Data.Map.Strict isn't found
09:49:27 <chrisdone> khyperia: right, let's check our containers version
09:50:11 <khyperia> and how would I do that?
09:50:26 <chrisdone> khyperia: go to the settings tab and you see an Environment section
09:50:46 <khyperia> yep
09:50:50 <chrisdone> khyperia: it'll say something like Stable 13.09 7.4.2. you can click it and view a package list
09:51:00 <chrisdone> probably you have this one: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/containers/index.html
09:51:10 <khyperia> aha, didn't see that was a link
09:51:31 <khyperia> yeah, containers-0.4.2.1
09:53:26 <khyperia> I don't think I will, but is it possible for me to override that by adding "containers-[version]" to the Extra Hackage packages section?
09:54:43 <chrisdone> khyperia: yeah, in the settings there's an experimental Extra packages section where you can specify e.g. Hackage: containers 0.5.0.0
09:54:57 <khyperia> awesome, thanks!
09:55:35 <chrisdone> khyperia: i'm not sure whether it will build okay. the point of stackage (what we use) is that all packages build together. introducing new stuff might lead to build errors
09:56:13 <chrisdone> khyperia: maybe just switch to the Unstable environment
09:56:33 <khyperia> Eh, it's not that important, I just wanted to learn what to do if it happens again.
09:56:47 <chrisdone> nod
10:08:08 <chrisdone> khyperia: so it looks like we're hoping for ghc 7.8 to be deployed in december which will have this new containers version
10:08:16 <khyperia> goodie!
10:11:08 <Heffalump> is there a GHC 7.8 RC yet?
10:12:58 <oio_> is there a way to create a dummy IO HANDLE?
10:14:01 <geekosaur> wut
10:18:13 <oio_> geekosaur: so no?
10:18:34 <geekosaur> nd am suspicious about what you're trying to do
10:18:40 <geekosaur> er
10:18:43 <chrisdone> what would a dummy Handle do?
10:18:50 <geekosaur> I do not know what you mean by that and am suspicious about what you're trying to do
10:19:19 <oleo> sterile handle, gives no mushy no dick!
10:19:22 <oleo> lol
10:19:31 <oio_> when you use runprocces on windows it spawns a CMD windows
10:20:07 <geekosaur> so you want a handle open on NUL: ?
10:20:07 <oio_> but when you use it with all handles stun st out err it will not show the window
10:21:14 <oio_> so i run a procces that doesn't need st in out err
10:21:37 <oio_> but shows a window when i use runprocces which i don't want
10:22:01 <geekosaur> also if it doesn't need any of those then what is the point of running it?
10:22:32 <oio_> geekosaur: it needs the arguments
10:23:12 <geekosaur> that tells me precisely nothing
10:23:20 <geekosaur> in any case
10:23:24 <geekosaur> [23 18:07] <geekosaur> so you want a handle open on NUL: ?
10:23:38 <oio_> geekosaur: all the handles
10:24:41 <oio_> geekosaur: is just a executable that does not prints nothing nor does have output
10:26:17 <oio_> but i don't want it to show the windows
10:26:20 <oio_> window
10:26:27 <geekosaur> so I just gave you the answer
10:27:09 <monochrom> make it 3 handles all open on NUL: :)
10:28:41 <geekosaur> well, if it were unix it'd be one handle dup()d, but this is windows...
10:28:43 <chrisdone> what's this “NUL:” notation?
10:28:59 <geekosaur> the colon is optional these days but windows has devices
10:29:05 <monochrom> DOS notation for /dev/null
10:29:17 <geekosaur> and the colon is still nice for making it clear that you mean a device and not a file
10:29:33 <chrisdone> gotcha
10:29:33 <monochrom> and CON: is /dev/tty, PRN: goes to the printer
10:29:57 <haasn> is that why you can't make a folder named ‘con’?
10:30:02 <geekosaur> yes
10:30:07 <monochrom> example: "real programmers use 'copy con: x.hs' for editor"
10:30:21 <haasn> (what about ‘prn’ or ‘nul’?)
10:30:37 * geekosaur still remembers AVAILDEV, sigh
10:30:48 <oio_> geekosaur: without dummy files ..
10:30:57 <geekosaur> oio_, this is nto a dummy file
10:31:01 * hackagebot yaml 0.8.5.2 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.5.2 (MichaelSnoyman)
10:31:02 <geekosaur> it is an operating system device node
10:31:16 <geekosaur> if you are going to program on Windows then you might want to learn a little bit about how Windows works
10:31:39 <chrisdone> ideally he shouldn't have to
10:31:56 <chrisdone> why just createProcess with CreatePipe in the stdouts and stderrs?
10:32:09 <geekosaur> and it exists for *precisely* this purpose
10:32:14 <oio_> chrisdone: thinking that
10:32:18 <chrisdone> the problem is that windows makes a terminal if there's no stdout and stderr pipe to write to?
10:32:39 <oio_> geekosaur: and how do you put that into runprocess
10:33:01 <geekosaur> the code in System.Process sets the don't-create-window flag if all of stdin, stdout, stderr are redirected
10:34:04 <chrisdone> donri: http://grooveshark.com/s/Arcade+Superhero/5b5t1D?src=5
10:34:43 <oio_> "From peeking at the ghc source code file runProcess.c, I found that the CREATE_NO_WINDOW flag is set when you supply redirects for all of STDIN, STOUT, and STDERR. So that's what you need to do, supply redirects for those. "
10:34:57 <geekosaur> myin <- openFile "NUL:" ReadMode; myout <- openFile "NUL:" ReadWriteMode; ph <- runProcess ... (Just myin) (Just myout) (Just myout)
10:35:19 <geekosaur> sorry that ReadWriteMode should be WriteMode
10:35:31 <oio_> geekosaur: neat thans
10:40:24 <khyperia> Oh, I just figured out why Haskell has Kinds. The entire system is a whole new lambda calculus, only it works on types, not values. You have lambdas (forall), applications (such as "[] Int"), and variables (such as Int)
10:40:56 <khyperia> that's *cool*.
10:42:01 <roconnor> khyperia: forall isn't really a lambda, but type synonyms are kinda like lambdas a little bit
10:42:07 * geekosaur waits until khyperia discovers the language Ωmega
10:43:17 <geekosaur> also note that ghc doesn't actually support type lambdas (the underlying type system does but they're blocked from user code because they complicate typing too much)
10:43:39 <Iceland_jack> Maybe in the future :)
10:43:50 <simpson> I can't wait until GHC supports multiple sorts. We'll have to figure out the name for the thing above sorts, though.
10:44:33 <khyperia> Just looked up Ωmega, no idea what it's doing, but it's probably really awesome (but I haven't discovered it's awesomeness yet, lol)
10:44:41 <khyperia> roconnor, how is a forall not a lambda?
10:44:46 <khyperia> It certainly looks like one
10:44:59 <geekosaur> it's just a free type variable
10:45:19 <triliyn> simpson: I think someone said that an upcoming version of GHC will have dependent kinds, collapsing all levels above kinds into one
10:45:22 <khyperia> "forall a. TypeConstructor a" -> "\a -> DataConstructor a"
10:45:33 <simpson> triliyn: Aw, no more BOX?
10:45:46 <simpson> @quote BOX
10:45:46 <lambdabot> ghc says: Illegal unboxed tuple type as function argument
10:45:53 <roconnor> kylcarte: forall is more like an -> than a lambda
10:46:03 <khyperia> and then I figured out the difference between type constructors and data constructors
10:46:07 <triliyn> simpson: that's what I would assume, but I haven't really read the full description of the proposed system
10:46:35 <geekosaur> khyperia, it's not a lambda, it's just a scope delimiter
10:46:36 <khyperia> a type synonym, to me, looks like a "let" binding
10:46:47 <triliyn> (Also, perhaps I should have said "collapsing all levels above types into one", since "above" doesn't really sound inclusive)
10:46:48 <Iceland_jack> khyperia: How would you apply a forall then?
10:47:01 <roconnor> let bindings are more like lambdas than foralls are ;)
10:47:08 <geekosaur> without the forall, the scope of a would be the outermost scope, instead of being limited to where the forall is
10:47:29 <geekosaur> (this scoping behavior is also why forall is used to introduce ScopedTypeVariables)
10:47:47 <khyperia> Iceland_jack, there is no syntax for it, but basically if you have... I get your point about type synonyms are the lambdas, but in my warped and twisted view they're not, lol.
10:47:48 <roconnor> (\x -> e) y  vs let x = y in e
10:48:07 <Iceland_jack> It wasn't my point! :)
10:48:34 <roconnor> but yes type synonyms are let bindings and not lambdas
10:48:42 <roconnor> we don't have type level lambda
10:48:49 <simpson> Ow. ArrowFix and ArrowLoop hurt.
10:48:56 <roconnor> there is no way to write flip on the type level
10:49:01 <monochrom> wait, there is ArrowFix?
10:49:15 <triliyn> roconnor: you can do it with type families I think
10:49:15 <khyperia> but essentially if you have "foo :: forall a. a -> a", and then "foo 2", the compiler automatically figures out to apply (forall a. a -> a) Int to create Int -> Int
10:49:32 <geekosaur> no
10:49:43 <geekosaur> `foo :: forall a. a -> a` is the same as `foo :: a -> a`
10:49:52 <Iceland_jack> what geekosaur said
10:49:57 <khyperia> yes, but there's an implicit forall on the right example
10:49:58 <geekosaur> `forall` only mattters for scoping
10:50:06 <roconnor> khyperia: it is probably best for you to read about the lambda cube
10:50:13 <fizruk_> foo : {a : Set} -> a -> a
10:50:13 <geekosaur> it does not otherwise change what `a` means
10:50:25 <geekosaur> it *only* limits the scope of `a`
10:50:25 <simpson> monochrom: It's mentioned briefly in the Paterson paper on the original arrow notation. He then explains ArrowLoop, which is not any easier for me to grok.
10:51:05 <khyperia> geekosaur... hmm. We seem to have two different viewpoints on foralls, both of which are valid.
10:51:07 <japaric> are we restricted to use a certain range of unicode characters in hs files? e.g. I can use 0x2191 but not 0xe0b0, see http://bpaste.net/show/152408 (using ghc 7.6.2, I'm a haskell newbie trying to configure xmonad/xmobar)
10:51:14 <geekosaur> I am not convinced yours is valid
10:51:18 <khyperia> roconnor, what is that?
10:51:23 <geekosaur> since you think it has behavior beyond scoping
10:51:34 <simpson> simple_loop :: ((b,d) -> (c,d)) -> b -> c; simple_loop f b = c where (c,d) = f (b,d)
10:52:11 <khyperia> geekosaur, alright, I think that there is an implicit forall for any unbound type variables in the type, while you don't.
10:52:17 <geekosaur> no
10:52:20 <simpson> The origin of that d is head-hurting. I know that it's just like fix, but still.
10:52:25 <geekosaur> you are deeply confused
10:52:36 <khyperia> if there *wasn't* a forall, the types would be unbound
10:52:38 <geekosaur> in fact I have no idea where you got that assertion
10:52:48 <khyperia> and unbound type variables don't exist in haskell
10:52:51 <khyperia> so it's implicit.
10:52:57 <geekosaur> yes, exactly
10:53:10 <roconnor> khyperia: http://dare.ubn.kun.nl/bitstream/2066/17240/1/13256.pdf
10:53:12 <geekosaur> whatever gave you the idea that I *don't* know that?
10:53:36 <roconnor> khyperia: let me know if that is over your head
10:53:39 <khyperia> So why do you say that foralls are *only* for scoping? It's incorrect.
10:53:47 <khyperia> roconnor, alright
10:53:48 <geekosaur> what?
10:53:49 <roconnor> khyperia: I think you are ready for it though.
10:53:57 <geekosaur> what you just said IS scoping?
10:54:02 <khyperia> geekosaur, foralls are for the introduction of type variables
10:54:07 <geekosaur> now I think youer notion of what scoping is is completely confused
10:54:08 <khyperia> not restricting scope
10:54:17 <geekosaur> ok, your definiton of scope is wrong
10:54:23 <khyperia> probably
10:54:31 <geekosaur> because, in reality, those are two ways of saying the same thing
10:54:49 <khyperia> alright, sure
10:55:06 <khyperia> so I was completely wrong, then, haha.
10:55:32 <geekosaur> (how do you introduce a new name? you create a new scope)
10:55:37 <khyperia> well, I wasn't *wrong*, I just said something was wrong that was right, because of my misdefinitions (which technically makes me wrong if you simplify it)
10:56:21 <Iceland_jack> O_o
10:59:53 <fizruk_> is there a shorter way to say `catMaybes . takeWhile isJust` ?
11:00:10 <geekosaur> uh, doesn't catMaybes already do the isJust?
11:00:18 <geekosaur> oh
11:00:24 <Iceland_jack> geekosaur: Yes but it's different if you have more after the first Nothing
11:00:26 <geekosaur> I see what you're getting at
11:00:41 <Iceland_jack> Looks good to me, wouldn't be surprised if there were a better way
11:00:44 <geekosaur> perhaps you want to use Maybe's MonadPlus instance
11:00:46 <Iceland_jack> (though)
11:01:04 <geekosaur> (the monoid instance drops Nothings, the MonadPlus instance stops at the first Nothing)
11:01:26 <fizruk_> geekosaur, oh should check that, thanks!
11:01:41 <Iceland_jack> > msum [Just 1, Just 2, Nothing, Just 3] -- ?
11:01:42 <lambdabot>   Just 1
11:01:50 <Iceland_jack> > (catMaybes . takeWhile isJust) [Just 1, Just 2, Nothing, Just 3] -- versus
11:01:51 <lambdabot>   [1,2]
11:01:58 <Iceland_jack> oops, monoid instance
11:02:09 <frx> one of the few instances where map fromJust would be appropriate
11:02:28 <geekosaur> no? you want it to stop, not throw an exception
11:02:32 <frx> > map fromJust $ takeWhile (/=Nothing) [Just 1, Just 2, Nothing]
11:02:33 <lambdabot>   [1,2]
11:02:45 <haasn> is there something like data (&&&) f g x = Pair (f x) (g x) -- ?
11:02:46 <geekosaur> oh. but that's no better than the origina;
11:03:03 <haasn> @hoogle (* -> *) -> (* -> *) -> * -> *
11:03:04 <lambdabot> Parse error:
11:03:04 <lambdabot>   (* -> *) -> (* -> *) -> * -> *
11:03:04 <lambdabot>      ^
11:03:11 <fizruk_> frx, i don't want Eq constraint
11:03:16 <Iceland_jack> fizruk_: (your version is fine)
11:03:35 <fizruk_> geekosaur, mplus and <|> select one value, I need all (till Nothing)
11:03:41 <fizruk_> Iceland_jack, ok :)
11:04:00 <monochrom> > mapM return [Just 1, Just 2, Nothing, Just 3]
11:04:02 <lambdabot>   No instance for (GHC.Show.Show (m0 [Data.Maybe.Maybe a0]))
11:04:02 <lambdabot>    arising from ...
11:04:08 <supki> > [Just 1, Just 2, Nothing, Just 3] ^.. takingWhile isJust folded . folded
11:04:09 <lambdabot>   [1,2]
11:04:18 <monochrom> > mapM Just [Just 1, Just 2, Nothing, Just 3]
11:04:19 <lambdabot>   Just [Just 1,Just 2,Nothing,Just 3]
11:04:35 <bz> :t (<-)
11:04:36 <monochrom> > mapM id [Just 1, Just 2, Nothing, Just 3]
11:04:36 <lambdabot> parse error on input `<-'
11:04:37 <lambdabot>   Nothing
11:04:43 <haasn> Ah, my (&&&) = Product from transformers
11:05:03 <supki> bz: <- is syntax
11:05:23 <bz> supki: yeah, couldn't resist double-checking
11:05:35 <bz> s/syntax/sugar/
11:05:53 <Iceland_jack> Sugar is not syntax?
11:06:03 <Iceland_jack> You can always PM lambdabot as well if you want to try things out :)
11:06:25 <fizruk_> Iceland_jack, syntactic sugar is syntax?
11:06:37 <Iceland_jack> Yes
11:06:59 <Iceland_jack> It's just redundant syntax
11:08:38 <fizruk_> i guess the same works for lists: map head . takeWhile (not . null)
11:10:57 <fizruk_> oh I think there is an Error monad which accumulates errors?
11:11:00 <fizruk_> is it These?
11:13:41 <benzrf> hi
11:13:50 <benzrf> i'm trying to implement a simple lisp
11:14:09 <benzrf> would it be better to define different data types as constructors of the same type, or as separate types?
11:14:25 <geekosaur> wee, expression problem :p
11:14:35 <benzrf> I need to be able to refer to them as a unit sometimes
11:14:40 <benzrf> i guess i could make a typeclass for that?
11:14:53 <Iceland_jack> benzrf: For a simple language I'd say go with the same type
11:14:58 <benzrf> hmm
11:15:01 <benzrf> i dunno
11:15:18 <Iceland_jack> You can look Data Types A La Carte
11:15:20 <benzrf> one type is 'function', and i'd prefer to store the arg list as symbols instead of haskell strings
11:15:28 <benzrf> but i can't single out symbols as is
11:15:36 <benzrf> since they are just a constructor
11:15:53 <Iceland_jack> benzrf: Unless you use some fancy stuff, that will complicate other parts of your code
11:16:00 <benzrf> How so?
11:16:19 <Iceland_jack> What about a function which should accept both functions and synbols?
11:16:22 <Iceland_jack> *symbols
11:16:36 <benzrf> no, i mean the arg names
11:16:43 <benzrf> *params i guess
11:16:53 <Iceland_jack> Yes but a symbol is a type, no?
11:16:54 <zomg> benzrf: different data types in a simple language could easily be represented by a single type, eg. data LispVal = LispFunction something | LispNumber something and so forth
11:17:01 <benzrf> zomg: that's what im doing atm
11:17:14 <Iceland_jack> Are you going through or have gone through http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours btw?
11:17:18 <benzrf> no
11:17:22 <Iceland_jack> You should check it out
11:17:22 <benzrf> i'm trying to do it my self
11:17:23 <benzrf> ;P
11:17:29 <Iceland_jack> good
11:17:30 <benzrf> it's more fun to do it myself though
11:17:35 <benzrf> maybe when i'm done i'll go through it
11:17:43 <Iceland_jack> That sounds like an excellent approach :)
11:18:06 <benzrf> as it is i have 'type Env     = Map.Map String LispVal'
11:18:14 <Iceland_jack> But yes, you can check out compdata which will allow you to specify which “subset” of your type a function accepts
11:18:17 <benzrf> which feels meh
11:18:19 <Iceland_jack> @hackage compdata
11:18:20 <lambdabot> http://hackage.haskell.org/package/compdata
11:18:23 <benzrf> lookin
11:18:34 <benzrf> you sure a typeclass isn't the right way here?
11:18:42 <Iceland_jack> You can do that, yes
11:18:54 <benzrf> hmm
11:19:04 <Iceland_jack> There are many approaches, many of them end up feeling very similar
11:19:21 <benzrf> well i'd really like to be able to refer to individual lisp types as different haskell types
11:19:27 <benzrf> so... i guess i'll do that
11:19:41 <haasn> what's the most canonical implementation of Fix f ~ f (Fix f) ?
11:19:43 <benzrf> Honestly i probably already decided that before i came here and was just looking for backup
11:19:46 <benzrf> ->-
11:20:09 <Iceland_jack> I'm not saying that's the right choice though benzrf, it may be overkill for a small project
11:20:09 <frege> hey guys
11:20:16 <Iceland_jack> hey frege
11:20:16 <Iceland_jack>  
11:20:18 <frege> is it easy to communicate with python from haskell?
11:20:52 <frege> or in another world make a network protocol with haskell?
11:23:05 <Iceland_jack> With compdata you can do something like:
11:23:05 <Iceland_jack>     desugar :: Term (Sugar :+: Operators :+: Values) -> Term Val
11:23:05 <simukis_> frege: easy is subjective. You can't really bind haskell with python as you'd bind C with python, but communicating between a haskell and python applications through some socket is as easy as between any other two languages.
11:23:06 <quchen> I've got a couple of Travis+Haskell issues. My .travis.yml is minimal (https://github.com/quchen/brainfuch/blob/master/.travis.yml), but Travis is still running 'cabal update' and other Cabal-related commands. Am I missing something? The Haskell-related guide doesn't mention this behaviour.
11:23:06 <frege> simukis_: how about using python modules from haskell?
11:23:08 <frege> simukis_: I know many useful libs in python particularly for machine learning that don't exist in haskell
11:23:09 <Iceland_jack> benzrf: Where values of type `Term (Sugar :+: Operators :+: Values)' include the values of your language (values, pairs, ...), operators (multiplication, fst, snd) and sugar is swap
11:23:31 <Iceland_jack> and ‘desugar’ transforms every
11:23:33 <benzrf> i uh
11:23:38 <triliyn> You can call python from C, can't you?
11:23:40 <benzrf> sort of follow that a little
11:23:44 <benzrf> triliyn: ish
11:23:47 <triliyn> Couldn't you in theory write a C library that wraps the python ones
11:23:52 <triliyn> and call those from haskell?
11:23:59 <benzrf> triliyn: there's hpype
11:24:05 <chrisdone> see also missingpy
11:24:08 <Iceland_jack> benzrf: In the sugared-language, you have swap and fst and snd
11:24:14 <benzrf> wait no
11:24:30 <benzrf> Iceland_jack: i think ill stick with vanilla haskell ftm
11:24:33 <Iceland_jack> but once you've desugared, every:
11:24:33 <Iceland_jack>     swap (a, b)
11:24:33 <Iceland_jack> turns into
11:24:33 <Iceland_jack>     (b, a)
11:24:34 <simukis_> triliyn: that doesn't really sound like easy.
11:24:36 <Iceland_jack> :) good
11:24:37 <frege> I want to use haskell as my main language
11:24:41 <benzrf> except for parsec for parsing
11:24:49 <frege> but I still need python to do some work
11:24:52 <triliyn> simukis_: yeah, it would probably be bad
11:25:25 <frege> I can communicate through socket which is fine but I prefer to do it through memory and wrapping func in haskell possibly
11:25:48 <simukis_> frege: well… shared memory between two processes then?
11:25:49 <frege> I don't know how the overhead of socket will do to a soft real-time app like mine
11:26:04 <frege> simukis_: yeah would it be possible to do that with haskell and python?
11:26:23 <frege> without using a third party module like redis or whatever
11:26:24 <frege> ?
11:27:30 <simukis_> frege: sure it would. Doesn't pass the easy constraint either, though.
11:27:49 <frege> simukis_: how would you do that?
11:28:08 <frege> simukis_: using C as the middle lang?
11:29:50 <haasn> does attoparsec have something like parsec's getPosition?
11:31:03 <supki> quchen: I think "language: haskell" implies "cabal update" on startup (yes, this is annoying)
11:31:14 <haasn> alternatively, does parsec have something like attoparsec's decimal?
11:31:24 <simukis_> frege: well… you can get shared memory by mmaping the same file in memory from both processes. Python has mmap module, haskell has mmap package too. That's one of the ways to do it.
11:31:35 <quchen> supki: But when I don't use Cabal? Argh. I wish they would just publish their default config.
11:31:47 <simukis_> frege: but again, that doesn't pass as easy.
11:32:01 <donri> quchen: yes, the haskell workers imply certain operations like cabal update
11:32:06 <geekosaur> at some point, "easy" becomes "pray for unicorns"
11:32:17 <simukis_> yes!
11:32:49 <geekosaur> (going between multiple languages will probably never be "easy" in the sense you seem to mean. deal.)(
11:32:57 <benzrf> B)
11:33:09 <codygman> Thanks Cale
11:33:11 <chrisdone> donri: did you try hell? =p
11:33:14 <quchen> donri: And that's independent of the .travis.yml?
11:33:18 <donri> chrisdone: not yet no
11:33:41 <donri> quchen: well it's dictated by the "language" line, but there's no way to override it while using a haskell worker no
11:33:42 <quchen> donri: Oh, when I spam "foo: true" in the .yml it disables it.
11:33:52 <donri> ?
11:34:01 <frege> what do ppl use for this kinda problem in the industry?
11:34:04 <quchen> before_install: true
11:34:06 <quchen> xyz: true
11:34:09 <quchen> That kind of spam.
11:34:16 <donri> wat
11:34:17 <quchen> It still needlessly runs "cabal update" though.
11:34:37 <donri> so what then does it "disable"?
11:34:53 <osa1> I want to make some transformation on a tree type and all I care is just one node type, what I want is to pattern-match on that node and traverse down other nodes .. I guess I need something like SYB but I couldn't find any related example, am I looking for wrong thing?
11:34:55 <donri> you can override the cabal install step, not cabal update
11:34:59 <quchen> The following cabal commands (cabal install complains about missing .cabal file for example)
11:35:01 <quchen> Right.
11:35:08 <benzrf> hmm
11:35:13 <donri> quchen: just drop the language line
11:35:16 <simukis_> frege: I've used zmq once to communicate between haskell, python and node.
11:35:33 <donri> or try drone.io
11:35:43 <simukis_> frege: very successfully.
11:35:44 <geekosaur> frege: whatever they can come up with. as I said, it will never be "easy"
11:35:46 <frege> simukis_: yeah zmq is interesting!
11:36:04 <haasn> ugh, has parsec always been this annoying to work with? Its primitives are disturbingly ungeneralized
11:36:05 <frege> geekosaur: yeah it's always patchy
11:36:06 <benzrf> hmm
11:36:08 <geekosaur> zmq and similar messaging systems are probably the closest we get to "easy" but you still have to do some work
11:36:21 <benzrf> is it possible to have a heterogeneous list where all of the values are the same typeclass?
11:36:26 <haasn> Do I really have to implement ‘satisfy’, ‘oneOf’ etc. myself?!
11:37:05 <osa1> haasn: use parsers library
11:37:20 <donri> haasn: those are in the Char module?
11:37:29 <haasn> donri: yeah. I'm not parsing chars though
11:37:34 <frege> is there a sample work on design and implementation of a streaming protocol using haskell
11:37:45 <Iceland_jack> benzrf: yes, it's an anti-pattern :)
11:37:48 <benzrf> Iceland_jack: ah
11:37:54 <benzrf> i guess i shouldnt go with the typeclass design then
11:37:55 <benzrf> >_>
11:37:57 <Iceland_jack> existential types
11:38:09 <benzrf> dag it
11:38:21 <benzrf> now how do i single out a particular lisp type
11:38:23 <benzrf> u_u
11:38:40 <Iceland_jack> benzrf: What's wrong with trying the straight-forward way first?
11:38:46 <Iceland_jack> then refining it
11:38:57 <benzrf> which way is the straight forward one
11:39:15 <Iceland_jack> Everything as a single type
11:39:35 <benzrf> ok, but then how can I have a heterogeneous lisp-list?
11:39:43 <benzrf> it's kind of necessary
11:39:51 <Iceland_jack> Yes and it's possible
11:40:00 <benzrf> i thought you said it was an antipattern?
11:40:00 <chrisdone> donri: i'm already starting to take advantage of the haskellyness
11:40:04 <geekosaur> if everything is one type then it is "heterogeneous" within your tyoe
11:40:06 <geekosaur> *type
11:40:08 <Iceland_jack> That's not what I said benzrf
11:40:12 <geekosaur> meanwhile welcome to the expression problem
11:40:20 <haasn> donri: I want satisfy :: Stream s m a => (a -> Bool) -> ParsecT s u m a
11:40:28 <haasn> Parsec only implements this with a ~ Char
11:40:29 <benzrf> Iceland_jack: wait, then what do you mean
11:40:32 <Iceland_jack> You were talking about having the same type class
11:40:41 <donri> haasn: agreed, i also find this weird
11:40:44 <benzrf> hmm?
11:40:50 <donri> chrisdone: example?
11:40:52 <chrisdone> donri: i just wrote for example: $ notifying $ do cabal "update"; sh "./dev-scripts/pull-build.sh" -- where notifying will do a notify-send on complete or on exception to let me know the job's done or failed
11:40:55 <Iceland_jack> It's perfectly easy to have a list with values of different types, they just ened to be tagged
11:40:59 <haasn> donri: the internal reasoning seems to be for pretty-printing purposes but it should be easy enough to add a Show a constraint
11:41:06 <benzrf> Iceland_jack: huh?
11:41:07 <Iceland_jack> > [Left True, Right "not a Bool"]
11:41:08 <lambdabot>   [Left True,Right "not a Bool"]
11:41:15 <benzrf> ahihi2:
11:41:16 <benzrf> *ah
11:41:25 <benzrf> by tagged you mean wrapped in an element type?
11:41:35 <chrisdone> donri: i don't know how i'd write that in bash (nor do i much care!)
11:42:00 <Iceland_jack> You just create your own tag:
11:42:00 <Iceland_jack>     data LispValue = LispNum Integer | LispBool Bool | LispString String ...
11:42:02 <benzrf> that's a bit awkward
11:42:03 <Iceland_jack> *type
11:42:09 <benzrf> no wait
11:42:16 <benzrf> that's what i was doing earlier
11:42:20 <Iceland_jack> Right
11:42:24 <benzrf> but then I can't single out lisp symbols
11:42:25 <benzrf> as a type
11:42:28 <Iceland_jack> That's right
11:42:35 <benzrf> so i have to, for example, have 'type Env     = Map.Map String LispVal'
11:42:46 <benzrf> instead of 'type Env     = Map.Map LispSym LispVal'
11:42:48 <benzrf> or something
11:42:49 <Iceland_jack> Yes
11:42:53 <benzrf> :[
11:42:57 <benzrf> how annoying
11:42:58 <Iceland_jack> Pros and cons man
11:43:06 <Iceland_jack> You can create a type just for a symbol
11:43:18 <benzrf> Nahra:
11:43:20 <benzrf> *nah
11:43:21 <Iceland_jack> and just incorporate it into your LispValue data type
11:43:23 <benzrf> too special-casey
11:43:36 <haasn> Ah, I'll use trifecta instead. It fits my use case perfectly :)
11:43:42 <haasn> Much better than Parsec or AttoParsec
11:44:04 <Iceland_jack> Like I said, try it using a single type for everything :) then you realize the painpoints and you can see where you need change
11:44:18 <fizruk_> i have f :: a -> Maybe b; xs :: [a]. I want to get first a such that f a = Nothing and all Justs that were generated before Nothing occurred
11:44:22 <simpson> haasn: If you use the `parsers` package to define your parsers, then you can trivially use any of Trifecta, Parsec, or AttoParsec, as you like.
11:44:56 <simpson> haasn: `parsers` defines a typeclass MonadParsing for Monads that can parse.
11:45:06 <simpson> Or is it MonadParser? It's been too long.
11:45:07 <benzrf> comonad is where =<< :: a -> (m a -> b) -> b
11:45:07 <benzrf> right?
11:45:16 <benzrf> or something along those lines
11:46:07 <Iceland_jack> fizruk_: head . filter (isJust . f)
11:46:19 <geekosaur> no, wrong kind of reversal :)
11:46:25 <benzrf> geekosaur: oh?
11:46:33 <geekosaur> (=<<) is just flip (>>=)
11:46:34 <haasn> simpson: okay, but I need functionality trifecta provides me with (ie. not in ‘parsers’)
11:46:43 <Iceland_jack> :t (=<<)
11:46:44 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:46:45 <Iceland_jack> Monad :)
11:46:46 <simpson> haasn: Oh, okay. I didn't realize.
11:46:52 <simpson> :t extract
11:46:52 <benzrf> ok so the wrong symbol
11:46:53 <lambdabot> Not in scope: `extract'
11:46:56 <benzrf> but the type is right, right?
11:46:57 <benzrf> ;p
11:47:07 <haasn> simpson: also, all of the useful functions are in a subclass CharParsing - again, I'm not parsing Chars
11:47:08 <haasn> so this is useless
11:47:10 <geekosaur> sort of
11:47:27 <Iceland_jack> benzrf: Well the co-monad one doesn't have a Monad constraint for one :)
11:47:29 <fizruk_> Iceland_jack, no, sorry, nevermind
11:47:45 <haasn> oh, wait. trifecta implements CharParsing? How does that work
11:48:09 <haasn> oh! UTF8
11:48:22 <benzrf> Iceland_jack: i chose m just cuz i was working off of >>= type
11:48:24 <haasn> What a weird thing to do implicitly
11:48:30 <benzrf> i did not mean to imply a monad constraint
11:48:31 <haasn> this is actually not good. I think.
11:48:31 <benzrf> o:
11:48:56 <simpson> benzrf: http://hackage.haskell.org/package/comonad-4.0/docs/Control-Comonad.html
11:49:47 <simpson> benzrf: The methods are extend, duplicate, and extract; since there isn't any do-syntax for Comonads, there aren't operators. I guess.
11:50:40 <Iceland_jack> There is almost a syntax for them! :)
11:50:49 <Iceland_jack> @hackage codo-notation
11:50:49 <lambdabot> http://hackage.haskell.org/package/codo-notation
11:52:22 <geekosaur> hm? operators are not dependent on syntax existing
11:52:34 <mr-> simpson: but there are operators!
11:52:44 <geekosaur> unless you are confusing <- (syntax) with an operator
11:53:06 <simpson> You're right; I misspoke.
11:53:07 <haasn> simpson: hmm. I'm still lost. Say I need to parse exactly 40 bytes of the source ByteString. How can I do this with trifecta/parsers?
11:53:21 <nisstyre> geekosaur: it would be interesting if you could compose <- syntax, i.e. a <- b <- c (take a monad out of a monad out of a monad)
11:53:33 <nisstyre> er value out of a monad
11:53:37 <simpson> haasn: Hm. What's in the ByteString?
11:53:51 <haasn> simpson: bytes.
11:54:25 <simpson> haasn: Sorry, I mean, what's the semantic meaning? What are you parsing?
11:54:38 <monochrom> it sounds like I would feed just those 40 bytes (take 40) to the parser, not the whole bytestring.
11:54:52 <haasn> unspecified; just that it's a string of bytes
11:55:26 <simpson> haasn: Well, I'm going to guess that you're parsing packed binary data, and recommend the *very* useful combinators and tools in the cereal package.
11:55:27 <fizruk_> ok, can this be simplified? http://lpaste.net/96074
11:55:51 <monochrom> I mean, I could "replicateM 40" inside the parser for sure, but that's inefficient and unnecessary.
11:56:09 <haasn> for example say I have a format that works like this: a string field is represented by a size field (encoded via ASCII) followed by a | character (byte 124), and then that many bytes of whatever encoding
11:56:34 <Iceland_jack> fizruk_: what's ‘first’?
11:56:35 <monochrom> ok, so it is not 40
11:56:36 <simpson> Sounds vaguely like netstrings...
11:56:40 <fizruk_> :t first
11:56:41 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
11:56:46 <fizruk_> Iceland_jack, mapFst
11:57:07 <fizruk_> > first (+5) (1, 3)
11:57:08 <lambdabot>   (6,3)
11:57:26 <haasn> simpson: oh! of course! cereal is much better
11:57:27 <simpson> haasn: Well, yes, monochrom nailed it; you could take any character 40 times. There's also (IIRC) a way to take any character x times in a more efficient manner.
11:57:31 <Iceland_jack> Yeah I assumed it was some other function not included
11:57:33 <chrisdone> > upon _1 (+5) (1,3)
11:57:34 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = s0 -> t0
11:57:34 <lambdabot>  Expected t...
11:57:36 <chrisdone> > over _1 (+5) (1,3)
11:57:37 <lambdabot>   (6,3)
11:57:42 <haasn> simpson: problem is trifecta doesn't seem to expose any sort of “any character” primitive
11:57:58 <haasn> well, it has an “any Char” primitive. That UTF8-decodes internally. Implicitly, apparently
11:58:03 <chrisdone> over _1 is nicer because it will work on many tuple sizes
11:58:04 <Iceland_jack> fizruk_: It looks okay but the function itself feels off
11:58:17 <haasn> :t _1 +~ 5
11:58:17 <fizruk_> Iceland_jack, off?
11:58:18 <lambdabot> (Num b, Field1 s t b b) => s -> t
11:58:21 <benzrf> yeah id really like to be able to use individual lisp types separately
11:58:26 <Iceland_jack> chrisdone: It's not nicer in cases where you only deal with tuples of size 2 :)
11:58:58 <benzrf> i.e. apply should :: LispVal v => LispFunc -> LispList -> v
11:59:05 <benzrf> not LispVal -> LispVal -> LispVal
11:59:21 <fizruk_> chrisdone, i rarely work with 3-or-more-tuples
11:59:36 <Iceland_jack> benzrf: You can if you want
11:59:41 <benzrf> :\
11:59:49 <benzrf> i guess ill just make lists use a wrapper type
11:59:54 <benzrf> sort of both at once
11:59:58 <benzrf> :|
11:59:59 <chrisdone> _1 is also nicer because it's both a setter and a getter
12:00:39 <chrisdone> first/fst, second/snd, [third/thd] … not so good
12:00:43 <Iceland_jack> If you need a setter and getter, sure
12:00:49 <fizruk_> Iceland_jack, i need to choose a value out of a list and for each fail remember why I failed to choose that one
12:00:55 <Buzzer_> Hi!
12:01:10 <geekosaur> it'd be trd anyway :p
12:01:18 <fizruk_> Iceland_jack, `f :: a -> Maybe b` returns `Just y` in case of failure
12:01:24 <Buzzer_> I'm trying to implement an algorithm that is based on the well-known floodfill algorithm
12:01:30 <Iceland_jack> fizruk_: Then where does the ‘b’ in the type signature come from?
12:01:40 <Iceland_jack> from f?
12:01:43 <Buzzer_> however, I'm stuck since I don't see how I could make four function calls one after the other
12:01:54 <fizruk_> Iceland_jack, yes, I should've made it explicit parameter
12:01:56 <Iceland_jack> ah right, you might have included it in the paste
12:02:00 <Buzzer_> Here is pseudocode from Wikipedia:
12:02:00 <Buzzer_> http://en.wikipedia.org/wiki/Flood_fill
12:02:07 <haasn> oh, binary; not cereal. but yeah. Cereal doesn't have bytesRead :: Get Int64 -- but binary does
12:02:11 <geekosaur> Buzzer_, sounds like you are thinking procedurally instead of functionally
12:02:27 <Buzzer_> geeoksaur, the pseudocode is functional
12:02:32 <benzrf> can i do a constraint on a parameter to a type constructor
12:02:41 <benzrf> i.e. data Foo a => Bar a
12:02:47 <benzrf> or somethin
12:02:50 <Buzzer_> the example on Rosettacode, frustratingly, uses imperative code in the Haskell example...
12:02:58 <fizruk_> Iceland_jack, I've revised paste: http://lpaste.net/96074
12:03:05 <Iceland_jack> benzrf: sure..
12:03:12 <benzrf> Iceland_jack: with that syntax?
12:03:25 <Iceland_jack> well sorry, not with a type constructor
12:03:26 <geekosaur> I do not see a functional one there, only proedural ones
12:03:37 <Iceland_jack> I misread, you need a type class
12:03:42 <benzrf> hmm Okasu
12:03:44 <benzrf> *ok
12:03:53 <benzrf> I have
12:03:54 <Iceland_jack> I'm not sure what semantics you'd expect from the other one
12:03:55 <benzrf> data LispFunc v = LispFunc [LispSymbol] v deriving Show
12:03:59 <Buzzer_> There is the "Stack-based recursive implementation (Four-way)"
12:04:03 <benzrf> and I want to make sure v is always a LispVal
12:04:17 <benzrf> *LispVal being a typeclass
12:04:26 <geekosaur> the one whose step 2 is the procedural "Set ..."
12:04:50 <geekosaur> anyway, if you want to be functional, you take a region and return a region and use composition (.) to combine them
12:04:58 <geekosaur> :t (.)
12:04:59 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:05:13 <Iceland_jack> benzrf: You may want to read this http://www.codepills.net//blog/2012/12/17/haskell-data-constraints
12:05:18 <benzrf> thanks
12:05:24 <monochrom> perhaps the specification is also procedural. "the array has to be modified such that..."
12:06:10 <Iceland_jack> Especially the:
12:06:10 <Iceland_jack>     > This is widely considered a misfeature, and is going to be removed from the language.
12:06:10 <Iceland_jack> :)
12:06:11 * hackagebot data-variant 0.25.2.0 - A variant data type, useful for modeling dynamically-typed programming languages  http://hackage.haskell.org/package/data-variant-0.25.2.0 (TobiasDammers)
12:06:18 <benzrf> Iceland_jack: does this require a ghc ext?
12:06:19 <benzrf> :P
12:06:35 <Buzzer_> in my code fragment (I'm trying to count elements of an area), I would like to simply collect coordinates in an accumulator...
12:06:35 <benzrf> I prefer to use vanilla when possible
12:06:42 <Iceland_jack> Good
12:07:33 <benzrf> w/e i'm not writing that many funcs
12:07:38 <benzrf> I'll just put a constraint into apply
12:08:18 <geekosaur> Buzzer_, an accumulator is also procedural think...
12:08:38 <benzrf> geekosaur: not in a fold!
12:08:40 <benzrf> :(
12:08:42 <benzrf> I mean :)
12:08:43 <geekosaur> unless you mean in the sense of a fold, where you ... yes
12:08:44 <haasn> simpson: oh, I forgot to mention. I'm parsing Bencode
12:08:49 <Buzzer_> geekosaur, I'm quite certain that an accumulator is not procedural; it's a typical pattern in recursive functions
12:09:03 <simpson> haasn: Ah. Yeah, cereal is the way to go.
12:09:19 <chrisdone> /bin/schell =p
12:09:21 <geekosaur> only if you mean in the fold sense, which is not really an accumulator in the procedural sense of a fixed location where you accumulate stuff
12:09:25 <haasn> simpson: binary, but yeah
12:09:34 <geekosaur> but a value you pass along the chain
12:09:46 <schell> chrisdone: hi :)
12:09:51 <benzrf> ugh this is bullshit
12:09:58 <haasn> which brings me to the next challenge. Now I have to implement my own decimal parser on top of binary that uses ASCII :P
12:10:21 <benzrf> Ok since im using a wrapping type to have heterogeneous lists anyway i might as well abandon my typeclass since i can use the wrapper type like a typeclass
12:10:22 <schell> hey do you guys know if data.typeable exports Typeable1 in base 4.7?
12:10:24 <benzrf> :-:
12:10:26 <geekosaur> benzrf: seriously, read up on the expression problem. you're deep in the middle of it
12:10:29 <benzrf> ah, ok
12:10:35 <simpson> haasn: monad-loops would let you cheat with whileM.
12:10:54 <haasn> simpson: yeah; hand-rolling one shouldn't be too difficult
12:10:57 <simpson> Or perhaps untilM. Read until the | character.
12:11:05 <haasn> especially since I can rely on terminators (‘e’ or ‘:’)
12:11:11 * hackagebot crf-chain2-tiers 0.2.1 - Second-order, tiered, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-tiers-0.2.1 (JakubWaszczuk)
12:11:13 * hackagebot concraft 0.9.0 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.9.0 (JakubWaszczuk)
12:11:15 * hackagebot concraft-pl 0.7.0 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.7.0 (JakubWaszczuk)
12:11:19 <haasn> I just need to read until the terminator then use ByteString.Char8/Read
12:12:12 <Bor0> is fold a monoid?
12:12:20 <monochrom> no
12:12:36 <Bor0> what are they trying to show with this formula: http://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science
12:12:43 <geekosaur> that question sounda  bit like: is moving a pineapple?
12:12:53 <Iceland_jack> geekosaur: Well obviously…
12:13:00 <simpson> Moving is the *best* of all pineapples.
12:13:03 <hpc> it sounds more like "is multiplication a number"
12:13:11 <benzrf> geekosaur: i'm not seeing how this is relevant to my issue
12:13:25 <monochrom> the formula shows how to do "fold" when you have a monoid.
12:13:26 <Iceland_jack> Bor0: They're saying that if you have a finite list of monoids, you can fold the list
12:13:40 <benzrf> Bor0: folding is something that you can do with monoid
12:13:43 <benzrf> s
12:13:48 <benzrf> Bor0: it's not a monoid
12:13:49 <Bor0> so, the * there is the actual monoid?
12:13:53 <benzrf> Bor0: no
12:13:54 <Iceland_jack> Bor0: No
12:14:00 <benzrf> the numbers are the monoids
12:14:12 <Bor0> but how? when it says that a monoid is a binary operation
12:14:13 <monochrom> there are to *'s, but neither is the monoid
12:14:20 <Iceland_jack> Bor0: A monoid has a binary operation
12:14:21 <benzrf> Bor0: well to be precise
12:14:24 <Iceland_jack> it isn't one
12:14:36 <Iceland_jack> Bor0: Read the first line in the Wikipedia article
12:14:37 <benzrf> a monoid is a binary operation + an identity value + a data type
12:14:40 <monochrom> where does it say "a monoid is a binary operation"?
12:14:42 <Iceland_jack> > n abstract algebra, a branch of mathematics, a monoid is an algebraic structure with a single associative binary operation and an identity element.
12:14:43 <lambdabot>   <hint>:1:19: parse error on input `,'
12:14:45 <benzrf> *associative binary operation
12:14:58 <Hafydd> The * in M* is the Kleine closure of M, if that's what you're asking.
12:15:05 <benzrf> Bor0: do you understand type classes?
12:15:06 <Iceland_jack> There are two *'s there
12:15:24 <Iceland_jack> The Kleene star and the monoid operation
12:15:45 <Hafydd> Or whatever it's called.
12:15:57 <Hafydd> The sequences of elements from M.
12:16:07 <Iceland_jack> free monoid/sequence
12:16:32 <Bor0> ok, so that formula basically states "given a monoid, we can define fold like this" ?
12:16:37 <Iceland_jack> Bor0: Yes
12:16:49 <benzrf> if my code contains this line:
12:16:49 <benzrf> data LispVal = WList LispList | WSymbol LispSymbol | WNumber LispNumber | WFunc LispFunc
12:16:54 <benzrf> i'm doing something wrong, right?
12:17:01 <Iceland_jack> An example of a monoid would be: <Int, (+), 0>
12:17:06 <monochrom> no, not wrong.
12:17:16 <geekosaur> doesn't look wrong to me
12:17:23 <benzrf> really ?
12:17:29 <benzrf> i feel like a typeclass is more correct here
12:17:33 <monochrom> at least until you state the complete problem specification.
12:17:36 <Bor0> Iceland_jack, so in that case (your monoid), the star (not kleene's star) in the formula would represent the +?
12:17:38 <benzrf> except I can't have a list of typeclass instancews
12:17:43 <Iceland_jack> Bor0: Yes
12:17:46 <monochrom> the complete formal problem specification
12:17:50 <Bor0> ok, thank you!
12:18:00 <Iceland_jack> So fold [1,2,3] would become 1+(2+(3+0))
12:18:11 <codygman> Two things. I'm unsure how to interpret mapMaybes type signature of (a -> Maybe b) -> [a] -> [b] and unsure how to use mapMaybe to get only the Just a of my list. I have been told not to use fromJust to do something similar, but I don't have a need for the Nothing values in this case as far as I can see. code: http://lpaste.net/revision/96077
12:18:15 <monochrom> a solution is right or wrong depending on the problem. http://www.vex.net/~trebla/humour/tautologies.html #5
12:18:17 <frx> benzrf you can work around that
12:18:22 <benzrf> frx: yeah?
12:18:24 <benzrf> in vanilla has?
12:18:26 <Bor0> Iceland_jack, and that monoid would be <[Int], (++), []> ?
12:18:26 <benzrf> kell
12:18:40 <Iceland_jack> Bor0: the monoid itself is not the list
12:18:46 <Iceland_jack> but lists are monoids
12:18:48 <hpc> Bor0: <Int, (+), 0>
12:18:53 <geekosaur> not vanilla haskell, you need an extension, and it will introduce other problems
12:19:02 <Iceland_jack> You could thus have fold lists of lists with <[a], (++), []>
12:19:05 <benzrf> yup
12:19:08 <hpc> Bor0: there's another Int monoid, guess what it is?
12:19:11 <geekosaur> which is why it's considered an antipattern
12:19:15 <Hafydd> > concatMap maybeToList [Just 1, Nothing, Just 2, Just 3]
12:19:16 <lambdabot>   [1,2,3]
12:19:17 <Bor0> <Int, *, 1>
12:19:20 <Iceland_jack> fold ["hello", " ", "world"] = "hello world"
12:19:41 <simpson> > catMaybes [Just 42, Nothing]
12:19:41 <monochrom> benzrf, are you an objective person? are you a subjective person?
12:19:42 <lambdabot>   [42]
12:19:48 <benzrf> monochrom: i like objectivity
12:19:52 <chrisdone> monochrom: i'm a surjective person!
12:20:01 <benzrf> it helps me deal with my pathological need to be right
12:20:02 <Hafydd> @hoogle catMaybes
12:20:03 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
12:20:10 <monochrom> ok, then "right" vs "wrong" is not decided by your feeling, but by demonstration.
12:20:40 <monochrom> you write code, it works, then it's "right". you write code, it doesn't work, it doesn't even type-check, then it's "wrong".
12:20:51 <frx> geekosaur there's no consensus on existential typeclass being an anti-pattern
12:20:57 <monochrom> not determined by "I feel typeclass is more right"
12:21:34 <benzrf> monochrom: oh you
12:21:42 <monochrom> if you now say, you change your mind, you want to be a subjective person, then you can use feeling, and ignore the computer.
12:21:52 <simpson> Something something Tarski's something.
12:22:25 <Iceland_jack> benzrf: Trying to make it perfect in the first try is a /bad/ quality: to it many times and each attempt will teach you something new
12:22:32 <codygman> Couldn't match expected type `[Maybe a1]' with actual type `Maybe [TimeSheet]'. So I have a list of Maybe lists... not values... right? That's why it's not working?
12:22:32 <Iceland_jack> *try it
12:22:34 <benzrf> bah
12:22:48 <monochrom> what Iceland_jack says too. why not do both approaches?
12:23:33 <Iceland_jack> Did you hear about that perfect program made by that person on their first attempt? :) me neither
12:23:50 <monochrom> you heard from me
12:23:52 <marx2> are there any free source gtk2hs programs that are more complex than usual toy examples?  I am starting to create a convulted, unmanagable mess and I wanted to see how others are doing it
12:23:53 <Iceland_jack> hah
12:24:14 <monochrom> to be fair, the problem it solved was easy :)
12:24:16 <benzrf> marx2: i think most of us do it by trying not to
12:24:21 <chrisdone> even if a programmer made a perfect program on their first attempt they'd accidentally delete it before committing it
12:24:35 <benzrf> chrisdone: let's call that chrisdone's law
12:25:49 <fizruk_> how do I check whether two Maps are equal on intersection?
12:26:12 * hackagebot hpaco-lib 0.25.2.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.25.2.0 (TobiasDammers)
12:26:15 * hackagebot hpaco 0.25.2.0 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.25.2.0 (TobiasDammers)
12:26:19 <monochrom> in fact, http://lpaste.net/41790/ were pretty much perfect at the first attempt.
12:26:47 <piezoid> chrisdone: have you seen the ghci magic happening here ? http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.6.3/src/TcRnDriver.html#tcUserStmt
12:26:57 <benzrf> is it just me or is haskell one of the most static, nonreflective langs ever?
12:27:14 <Hafydd> Is Haskell less reflective than C?
12:27:26 <benzrf> probably
12:27:33 <Hafydd> What about Typeable?
12:27:35 <zennist> I'm modifying someone else's code and his has a rank-2 type that bounds to a type signature l. I'd like to extend l so that l can become something like (Group l1 l2) where l1 and l2 are any types. How can I do that
12:27:36 <monochrom> agda is even more static. haskell is pretty nonreflective, yes.
12:27:53 <benzrf> haskell has no backdoors in the lang itself afaik
12:28:00 <benzrf> javas pretty static but it has casting and so on
12:28:03 <monochrom> reflective is the anti-thesis to a lot of functional values such as extensional equality
12:28:07 <simpson> Do "static" and "reflective" mean anything?
12:28:20 <monoidal> lack of reflectivity is a value in itself. it gives free theorems.
12:28:39 <hpc> static means "not at runtime", reflective means "knows source-level information at runtime"
12:28:41 <benzrf> monochrom: i didn't say it was a bad thing :)
12:28:53 <monochrom> yeah, reflective is a cavalier power, not a predictive power.
12:29:04 <hpc> reflection lets you do stuff like "v = getLine(); x.invoke(v);"
12:29:08 <simpson> Maybe it's god to have two languages: One that reflects, and one that does not.
12:29:13 <hpc> type in "fooBar" and it runs "x.fooBar()"
12:29:19 <simpson> *good even. Cannot type today.
12:29:25 <chrisdone> piezoid: why are you looking at that?
12:29:28 <mr-> fizruk_: intersectionWith?
12:30:26 <fizruk_> mr-, sure, but that's not good enough on it's own
12:30:45 <monochrom> read my http://article.gmane.org/gmane.comp.lang.haskell.cafe/108253/ for what is cavalier power
12:30:46 <piezoid> chrisdone: i'am trying to do something similar idea for hell
12:31:08 <piezoid> chrisdone: and it's what you did a the string level
12:31:22 <fizruk_> mr-, I think of: andOf each (intersectWith (\x y -> Just (x == y)) m1 m2)
12:31:42 <chrisdone> piezoid: gotcha
12:33:48 <mr-> >  F.all (== True) $ M.intersectionWith (==) (M.fromList [(1,2)]) (M.fromList [(1,2)]) -- fizruk_
12:33:49 <lambdabot>   True
12:33:51 <Bor0> Iceland_jack, so why do we have fold in the first place? fold ["hello", " ", "world" ] we could do like "hello" ++ " " ++ "world"
12:34:23 <monochrom> if you have a list of unknown length, fold is useful
12:34:27 <fizruk_> > F.and $ M.intersectionWith (==) (M.fromList [(1,2)]) (M.fromList [(1,2)])
12:34:28 <lambdabot>   True
12:34:32 <fizruk_> mr-, thanks!
12:34:34 <Iceland_jack> Bor0: If you always have a list of length 3, that's fine :)
12:34:44 <monoidal> Bor0: that's if you know the list statically. But it might be a result of parsing a file etc.
12:34:50 <Bor0> I see
12:35:01 <Bor0> so fold basically takes a monoid and applies its operation?
12:35:02 <Iceland_jack> Then you could use:
12:35:02 <Iceland_jack>     concat1 [a, b, c] = a <> b <> c
12:35:07 <monochrom> I don't want to write like x0 ++ ... ++ xmk. what the hell is the ... there?
12:35:09 <mr-> Right, "and" is in Foldable too.. I have never really liked that one ;-)
12:35:11 <monoidal> Bor0: same with essentially every opeator (e.g. why we need + when we can always write 5 instead of 2+3)
12:35:14 <mr-> fizruk_: sure!
12:35:38 <monochrom> and what is "basically", basically?
12:35:39 <Iceland_jack> @ty fold :: Monoid m => [m] -> m
12:35:40 <lambdabot> Monoid m => [m] -> m
12:35:43 <Iceland_jack> yes Bor0
12:35:56 <monoidal> in Haskell, "fold" is named "mconcat"
12:36:04 <Bor0> this makes more sense now, thank you
12:36:10 <Iceland_jack> > fold ["hello", " ", "world"]
12:36:11 <lambdabot>   "hello world"
12:36:46 <Iceland_jack> In Haskell fold is a generalized version of the fold presented on Wikipedia
12:37:01 <newsham> > tail $ concatMap (' ':) ["hello", "to", "you", "world"]
12:37:02 <lambdabot>   "hello to you world"
12:37:11 <mr-> > foldMap id ["hello", " ", "world"]
12:37:12 <lambdabot>   "hello world"
12:37:18 <zennist> I have a function where one of the arguments is a rank2type that bounds to a type signature l. Now I'd like to pattern match this l with another data type but I can't do that. Is there even a way around that?
12:37:52 <monoidal> zennist: can you paste (lpaste.org) the relevant code?
12:41:23 <NemesisD> god i would just love it if ghc didn't give me errors with type aliases expanded
12:41:38 <zennist> monoidal: http://pastebin.com/4zsdy3Xi
12:41:43 <mauke> The paste 4zsdy3Xi has been copied to http://lpaste.net/96078
12:41:55 <monoidal> NemesisD: in case you didn't know, you can use :kind! to expand manually a type synonym.
12:41:56 <monochrom> use no type aliases. then problem solved. :)
12:42:47 <jevankovich> Would anybody be willing to look over some of my code and give some suggestions?
12:42:48 <NemesisD> monochrom: i think i want the opposite. if type Simple = ComplicatedType, i want to see errors as Simple
12:42:55 <zennist> monoidal: the relevant code is in the second function
12:42:55 <NemesisD> erm monoidal *
12:43:28 <monoidal> zennist: which line in paste?
12:43:34 <lpaste> jevankovich pasted “Simple Physics” at http://lpaste.net/96079
12:43:48 <zennist> monoidal: from 30 onwards
12:44:04 <zennist> monoidal: but the type signature is declared at the beginning
12:45:11 <monoidal> zennist: OK. now, what are you trying to do?
12:45:41 <zennist> I'm working on a layout that essentially uses XMonad.Layout.Groups to have 3 nested levels of grouping
12:46:35 <zennist> I've succeeded in getting one such layout to work. But I'm currently unable to manipulate on each sub group of windows..So my function is trying to get that sub group out of the original layout
12:47:38 <zennist> Since the code at the beginning uses a rank2type that limits the scope for the type signature l, when I'm trying to match l to a Groups type I got the warning
12:48:19 <monoidal> zennist: but you don't use ModifySpec in moveSubGroupToGroupAt
12:48:41 <monoidal> zennist: what's the warning?
12:49:09 <zennist> yes. this compiles fine. But the real intention is to use the applySpec included in the code to apply the 'moveSubGroupToGroupAt i'
12:49:27 * Hodapp tries to wrap his head around existential types.
12:49:33 * Hodapp gives up and reaches for vodka instead.
12:49:49 <chrisdone> Hodapp: what vodka? all vodkas or a particular one? =p
12:49:57 <zennist> couldn't match type 'l' with G.Groups l10 l20
12:49:58 <Hodapp> chrisdone: I think this is Russian Standard
12:50:15 <Hodapp> chrisdone: if you make a typeclass joke about vodkas, I'ma thwap you in the head with the bottle!
12:50:23 <chrisdone> :(
12:50:27 <zennist> l is a rigid type bound by a type expected by the context:...
12:50:33 <Hodapp> okay, okay, fine, make your vodka joke.
12:50:41 <monoidal> zennist: what causes that error?
12:51:01 <heath> ideas on cleaning this? StringTree False (Map.insert c (makeDNATree (Map.findWithDefault empty c nodes) cs) nodes) :: from https://github.com/NashFP/rosalind/blob/master/mark_wutka%2Bhaskell/LCSM/lcsm.hs
12:51:11 <zennist> monoidal: applySpec (moveSubGroupToGroupAt 1)
12:51:30 <monoidal> zennist: ah I see. well, the error is correct, since moveSubGroupToGroupAt is not fully polymorphic in l.
12:51:33 <zennist> if I can't apply this thing then essentially it is useless...
12:51:55 <zennist> monoidal: yes you got it. how can I work around that
12:52:14 <monoidal> zennist: what if you defined type ModifySpec l =  WithID l Window -> ...?
12:52:45 <zennist> then in the 'applySpec' function it complains that there's no instance implementing 'f'
12:52:59 <marx2> is it possible to get the filename and line of a definition of a function within ghci?
12:53:05 <monoidal> zennist: instance of which class?
12:53:06 <Iceland_jack> :info
12:53:10 <Iceland_jack> marx2
12:53:18 <marx2> perfect, thanks!
12:53:19 <monoidal> zennist: the only class I see in your code is LayoutClass
12:54:33 <reactormonk> how does filterM work exactly?
12:54:42 <sipa> @src filterM
12:54:42 <lambdabot> Source not found. Abort, Retry, Panic?
12:54:52 <sipa> :t filterM
12:54:52 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
12:54:56 <monoidal> zennist: maybe you need a context for applySpec for the missing instances?
12:55:05 <monochrom> have you read the source code of filterM to find out?
12:55:20 <zennist> monoidal: if you'd kindly refer to the code you'll see that in the applySpec function there's an application of an arbitrary function f to a layout
12:55:33 <monochrom> or it is the other sense of "how does it work" i.e. "how to use it?"
12:57:29 <reactormonk> monochrom, I'm reading up on scalaz (yeah, impure), and they list filterM, and I can't figure out how it behaves exactly.
12:57:45 <monochrom> ok, I don't know scalaz
12:57:48 <benzrf>  month
12:57:57 <benzrf> oop
12:58:00 <benzrf> wrong window
12:58:11 <reactormonk> monochrom, should work the same as in haskell
12:58:29 <reactormonk> http://davesquared.net/2013/06/filterm.html seems interesting for starters
12:58:34 <monochrom> ok, then have you read the Haskell source code of filterM?
12:59:29 <reactormonk> no
12:59:40 <monochrom> then we are totally not on the same page.
13:00:01 <monochrom> and I have no interest in learning scalaz immediately, unless I'm paid.
13:00:38 <reactormonk> where can I find it?
13:01:10 <reactormonk> I don't think the people here would appreciate me cloning the full ghc repo
13:01:45 <sipa> i don't think anyone would care
13:01:50 <sipa> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#filterM
13:01:54 <ReinH> ] @hoogle filterM
13:01:56 <ReinH> er
13:01:59 <ReinH> @hoogle filterM
13:02:00 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
13:02:00 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
13:02:19 <ReinH> reactormonk: http://www.haskell.org/hoogle/?hoogle=filterM
13:02:35 <Iceland_jack> > filterM Just [True, False]
13:02:36 <lambdabot>   Just [True]
13:03:23 <Cale> > filterM (const [False, True]) [1..4]
13:03:23 <lambdabot>   [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,...
13:03:42 <Cale> How do you write a whole page on filterM and not show that example?
13:03:54 <NemesisD> reactormonk: is that a name from Ascension
13:04:15 <ReinH> Cale: oh god the list monad how in the...
13:05:11 <Cale> ReinH: for each element in the list, drop it, and keep it :)
13:05:24 <reactormonk> NemesisD, indeed
13:05:25 <Cale> (regardless of its value)
13:05:41 <NemesisD> reactormonk: cool. love that game
13:05:43 <mr-> Cale: nifty!
13:05:56 <Cale> > filterM (\x -> if even x then [True] else [False, True]) [1..4]
13:05:57 <lambdabot>   [[2,4],[2,3,4],[1,2,4],[1,2,3,4]]
13:06:16 <Cale> ^^ have to keep even elements, odd elements are optional
13:06:54 <ReinH> ohhhh
13:07:10 <mr-> I should pay more attention to the list monad ;-)
13:07:19 <ReinH> it's all ways of keeping or discarding odd elements
13:07:43 <ReinH> that's nice
13:08:25 <reactormonk> Cale, how is the order of the output defined?
13:09:16 <Iceland_jack> > filterM (\x -> if even x then [True] else [True, False]) [1..4] -- reactormonk: see if this helps
13:09:17 <lambdabot>   [[1,2,3,4],[1,2,4],[2,3,4],[2,4]]
13:10:14 <Cale> reactormonk: The choices are made in the order of the list. It's a depth-first search, essentially.
13:10:15 <benzrf> > let m1 = Data.Map.fromList [('a', 1), ('b', 2)]; m2 = Data.Map.fromList [('a', 3)] in Data.Map.union m1 m2
13:10:16 <lambdabot>   Not in scope: `Data.Map.fromList'Not in scope: `Data.Map.fromList'Not in sc...
13:10:19 <benzrf> D:
13:10:24 <monochrom> "flg <- p x" before "ys <- filterM p xs" determines the order. consider swapping them and performing experiments.
13:11:12 <benzrf> with Data.Map.union, do the pairs from the first map _always_ override the pairs from the second?
13:11:16 <benzrf> or is it undefined behavior?
13:11:26 <Cale> benzrf: It's left-biased
13:11:29 <benzrf> OK good
13:11:38 <monoidal> benzrf: O(n+m). The expression (union t1 t2) takes the left-biased union of t1 and t2. It prefers t1 when duplicate keys are encountered,
13:12:20 <Cale> (If you want right-biased, you can use unionWith (\x y -> y)
13:12:24 <Cale> )
13:12:29 <benzrf> thanks!
13:12:53 <monochrom> > M.union (M.fromList [('a', 1), ('b', 2)]) (M.fromList [('a', 3)])
13:12:54 <lambdabot>   fromList [('a',1),('b',2)]
13:13:13 <monochrom> it is called M. yes, lambdabot's naming scheme is unpredictable.
13:13:38 <monochrom> well, it's predictable after you memorize the complete roster
13:13:38 <monoidal> zennist: in your application, is "l" always "Groups l1 l2"?
13:13:44 <monoidal> zennist: or "l" can be something else?
13:13:47 <Iceland_jack> I use lambdabot's naming scheme as a source for randomness :)
13:13:53 <monoidal> zennist: possible idea:
13:13:54 <monochrom> haha
13:14:18 <monoidal> zennist: type ModifySpec = forall l. SomeClass l => WithID l Window -> Zipper (Group l Window) -> Zipper (Group l Window)
13:14:35 <monoidal> zennist: implement SomeClass (Group l1 l2) and SomeClass for other things you need to match on
13:15:26 <monoidal> zennist: sorry but it took me a while to digest the question, as I have no experience with xmonad-contrib
13:16:04 <monoidal> zennist: SomeClass will have moveSubGroupToGroupAt as a method.
13:16:29 <benzrf> why does map require Ord?
13:16:39 <monoidal> benzrf: it's a balanced search tree
13:16:44 <benzrf> :|
13:16:46 <Bor0> I'm trying to understand kleene's star a bit better, in case if we have M = [1, 2, 3, ...] this is [Int], will M* be defined as [[Int]] ?
13:16:59 <Iceland_jack> Bor0: The monoid is Int
13:17:05 <Iceland_jack> So M* would be [Int]
13:17:23 <monochrom> why do you have a problem with Ord?
13:17:29 <marx2> is there a way to make this shorter? I am doing it quite often.  (case maybeText of Nothing     -> "" (Just text) -> text)
13:17:40 <Iceland_jack> :t maybe -- marx2
13:17:41 <Bor0> but in the case of Monoid <[Int], ++, []>, M = [Int] and M* = [[Int]] ?
13:17:41 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:17:45 <monoidal> marx2: fromMaybe "" maybeText
13:17:48 <Iceland_jack> Bor0: Yes
13:17:55 <ReinH> Bor0: are you familiar with regexp?
13:18:09 <Hermit> marx2: maybe "" id text
13:18:25 <Bor0> ReinH, no, but I know what they are used for (regexes in general)
13:18:27 <Tekmo> fromMaybe "" text
13:18:42 <ReinH> Bor0: do you know what the regexp /./ means?
13:18:42 <Tekmo> fromMaybe x m = maybe x id m
13:18:48 <marx2> nice :)
13:18:50 <Bor0> nope :
13:18:54 <ReinH> Bor0: ok then :)
13:19:09 <Iceland_jack> Bor0: For any type M, M* is just a different notation for [M]
13:19:17 <Iceland_jack> not quite the same but close enough
13:19:26 <Iceland_jack> Don't let that confuse you
13:19:29 <Bor0> Iceland_jack, I got that but what confused me is wikipedia's definition about M* being "string concatenation"
13:19:48 <monoidal> there's a more general notation of Kleene star for sets of strings
13:19:58 <monoidal> if you are intested in monoids only, you can ignore that.
13:20:07 <mr-> Iceland_jack: in what sense is it not quite the same?
13:20:17 <Iceland_jack> Finiteness
13:20:19 <marx2> how about doing that to a function that returns IO (Maybe String)? can I just fmap it?
13:20:24 <Bor0> so "string concatenation" is not limited to strings only, but integers too?
13:20:26 <monoidal> the idea is that {a,bb,bc}* is a set that includes bbabcbb etc.
13:20:26 <Tekmo> marx2: Yes
13:20:35 <mr-> Iceland_jack: ah, of course
13:20:59 <monochrom> fmap (fromMaybe "") action
13:21:17 <monochrom> is that right?
13:21:21 <monochrom> @type fromMaybe
13:21:22 <lambdabot> a -> Maybe a -> a
13:21:29 <monoidal> Bor0: in formal language theory, lists are called "strings", but the alphabet is usually taken to be finite
13:21:35 <marx2> this is sweet, I condensed a 5 line do block with this: fmap (fromMaybe "") (comboBoxGetActiveText combo)
13:21:39 <monoidal> Bor0: (usually meaning almost always)
13:21:47 <Iceland_jack> Free monoids are always finite
13:21:54 <monoidal> Iceland_jack: ??
13:22:03 <marx2> to this*
13:22:13 <Iceland_jack> or rather, the sequences of them
13:22:21 <monoidal> Iceland_jack: did you mean, free monoids are always infinite?
13:22:23 <quchen> marx2: You can save the parentheses using (<$>) instead of fmap. Other than that it's probably as short as it gets. :-)
13:22:32 <monochrom> free monoids always give me free willies
13:22:36 <Iceland_jack> monoidal: No I mean the sequences they contain
13:22:41 <monoidal> ah, agreed on that
13:22:44 <udevd> > iterate (+1) 0
13:22:45 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:23:01 <Tekmo> [0..]
13:23:01 <Iceland_jack> But I don't think that distinction is going to help Bor0
13:23:05 <Tekmo> > [0..]
13:23:06 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:23:26 <Iceland_jack> Bor0: It's an interesting topic, I suggest familiarizing yourself with foldl and foldr a bit
13:23:45 <ReinH> Bor0: when you see "string concatenation", for Haskell think list concatenation
13:23:51 <Iceland_jack> if you're unfamiliar with some of the algebraic concepts
13:23:58 <Bor0> thanks Iceland_jack and monoidal. yes I will continue playing around with this, it's too fun to stop :) the "string concatenation" being list concatenation actually helped much
13:24:05 <Iceland_jack> Bor0: Good luck! :)
13:24:11 <Iceland_jack> And feel free to ask here as always
13:24:48 <Iceland_jack> foldl and foldr don't put the restriction on the value of the list being a monoid
13:24:48 <Iceland_jack> @ty foldl
13:24:49 <lambdabot> (a -> b -> a) -> a -> [b] -> a
13:24:50 <Iceland_jack> @ty foldr
13:24:50 <lambdabot> (a -> b -> b) -> b -> [a] -> b
13:25:12 <NemesisD> Tekmo: hey! i just got around to start implementing that skeleton you gave me for pipes and i had some questions http://lpaste.net/95802
13:25:16 <ReinH> Bor0: in Haskell terms, the free monoid for some list [a] is the list of all possible finite length lists of elements from a, or [[a]], with [] as unit and (++) as times
13:25:23 <Tekmo> NemesisD: Of course!  Ask away
13:25:42 <Bor0> ReinH, what do free monoid and kleene's star have in common?
13:25:43 <monoidal> I like to think of foldl as an automaton. you start with an initial stateab, given a list of items [b], the transition function is a -> b -> a and you get the final automaton state.
13:26:00 <Iceland_jack> monoidal: That's not a bad way of thinking about it :)
13:26:03 <ReinH> Bor0: the kleene star is the free functor from set to free monoid
13:26:10 <Tekmo> Bor0: A free monoid is analogous to a list, and so is a Kleene star
13:26:12 <Iceland_jack> I feel like it works even better thinking about something like foldp (from Elm) in those terms
13:26:15 <ReinH> S* is the free monoid for the set S
13:26:19 <NemesisD> Tekmo: so i found that Binary and Pipes.Binary does not fit my problem well, if the request/response are separate types, binary is not sensible because the request only needs an encoding function, response only needs a decode
13:26:19 <Tekmo> Bor0: a* is sort of like [a]
13:27:05 <NemesisD> Tekmo: i started trying to rework the code to fall back to just working with bytestrings, because at the code i essentially have a -> ByteString and ByteString -> Result a (via a parser)
13:27:05 <Iceland_jack> Not to put too fine a point on it but knowing this is not necessary to use Haskell
13:27:06 <Bor0> great!
13:27:17 <ReinH> but it sure is helpful :)
13:27:19 <Iceland_jack> It is interesting in its own right though
13:27:25 <ReinH> and you probably already have an intuition for it
13:27:28 <Bor0> Iceland_jack, yes I am aware. but abstract algebra is fun as well to me. I also learned lambda calculus along on the way
13:27:35 <Iceland_jack> Well… I'm not so sure about that
13:27:38 <mr-> ReinH: it is the free functor from set to monoid! ;-)
13:28:03 <ReinH> mr-: yes, and the monoid it creates is a free monoid ;) (because that's how free functors work)
13:28:26 <ReinH> mr-: I wanted to be specific, if redundant
13:28:36 <Iceland_jack> Bor0: Then learn away.
13:29:37 <lpaste> NemesisD pasted “socket request/response so far” at http://lpaste.net/96082
13:30:07 <mr-> ReinH: Yeah, I reacted on my first impulse.. What you said is true too. I was confused ;-)
13:30:41 <benzrf> hmm
13:30:51 <benzrf> how do you recommend dealing with errors in my lisp thingy?
13:30:53 <benzrf> Either?
13:30:59 <Iceland_jack> Either is good
13:31:07 <Iceland_jack> I believe it's what the Scheme tutorial uses
13:31:13 <klrr_> yes it is
13:31:14 <ReinH> Iceland_jack: which scheme tut?
13:31:15 <Iceland_jack> or if that used the Error monad transformer
13:31:16 <benzrf> do you think its ok to start with dynamic scoping
13:31:23 <benzrf> will it be really hard to change to lexical later?
13:31:30 <klrr_> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hourshttp://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:31:32 <Iceland_jack> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:31:35 <NemesisD> Tekmo: ^ i get a bit lost in the types where it was previously using StateT and on the part where it parses. the stateful code in Pipes.ByteString is way too lowlevel WRT the protocol, pulling specific lenght bytestrings off the stream. i need to do something more like feed a lazy (or not, really) full message bytestring of some arbitrary length to my parser
13:31:35 <klrr_> :D
13:31:39 <benzrf> wait
13:31:41 <hpc> benzrf: start with lexical
13:31:46 <benzrf> actually lexical would be easy yeah
13:31:48 <benzrf> ok nvm =]
13:31:57 <hpc> you'll be structuring your code better from the start and it makes other stuff easy
13:32:22 <benzrf> right
13:32:38 <benzrf> ugh these patterns are waaaay too deep
13:32:42 <eyebloom> If I'm creating a data structure in haskell, say a tree where each node has a list of children and also a links back to a parent node i.e. Data Tree = Tree [Tree] (Maybe Tree). How can I tell if two nodes in the tree have the same parent without attaching a unique label to each node.
13:32:43 <ReinH> Cale: Isn't there an easy way to use the list monad to generate the free monoid for some list? i.e. foo [1,2] = [[],[1],[2],[1,1],[1,2],...]
13:32:44 <Tekmo> NemesisD: So this is the reason I usually prefer `Binary` for something like this, which is that it provides an interface for incrementally feeding more data
13:32:45 <benzrf> stupid wrapper type
13:32:55 <Bor0> if I were to prove that <[Int], ++, []> is indeed a monoid, for closure and identity it is easy. but how can I prove associativity? it is intuitive but how is associativity proven in general?
13:33:00 <eyebloom> sorry lower case data.
13:33:00 <Tekmo> NemesisD: The function you gave of type `Binary -> a` cannot be (safely) incrementally fed data
13:33:03 <Tekmo> Oops
13:33:10 <Tekmo> NemesisD: I mean `ByteString -> Result a`
13:33:26 <Iceland_jack> Bor0: You need to know how (++) is defined
13:33:29 <NemesisD> Tekmo: yeah i could conceivably use it if there was a way to break the Binary typeclass into Get and Put
13:33:44 <benzrf> ok now on lexical afaik
13:34:13 <reactormonk> how does let 2 + 2 = 5
13:34:16 <reactormonk> work exactly?
13:34:23 <Tekmo> NemesisD: So how do you define your function right now?
13:34:31 <NemesisD> Tekmo: which function?
13:34:32 <Iceland_jack> let 2 + 2 = 5 in 2 + 2 -- reactormonk: like this?
13:34:33 <monoidal> reactormonk: the same way let 2 & 2 = 5 works. it defines a new operator.
13:34:35 <Iceland_jack> > let 2 + 2 = 5 in 2 + 2 -- reactormonk: like this?
13:34:36 <lambdabot>   5
13:34:42 <Bor0> @src ++
13:34:43 <lambdabot> []     ++ ys = ys
13:34:43 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:34:43 <lambdabot> -- OR
13:34:43 <lambdabot> xs ++ ys = foldr (:) ys xs
13:34:43 <Tekmo> NemesisD: The function of type `ByteString -> Result a`
13:34:43 <Iceland_jack> It just shadows the usual (+)
13:34:48 <monoidal> reactormonk: only in this case, the + is shadowed.
13:35:01 <countoren> hello guys i asked before about an error that i had building mongoDB with cabal, got seggeted to apply the clang patch
13:35:16 <reactormonk> monoidal, ok. And it matches only to 2 -> 2 ?
13:35:20 <benzrf> hmm
13:35:23 <Iceland_jack> reactormonk: Yes
13:35:31 <countoren> i did and get patched installed but there is a lot of things that still wont build
13:35:31 <Iceland_jack> > let 2 + 2 = 5 in 0 + 0 -- reactormonk
13:35:32 <benzrf> how can I define an ADT that contains a function as one of its fields?
13:35:32 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
13:35:40 <Tekmo> NemesisD: The reason I ask is that I can translate it to the equivalent `pipes-bytestring` operations
13:35:57 <monoidal> > let 2 + 2 = 5; x + y = x Prelude.+ y in (2 + 2, 2 + 3)
13:35:58 <lambdabot>   (5,5)
13:35:58 <NemesisD> Tekmo: class Deserializable a where parser :: Parser a, parseBS :: Deserializable a => ByteString -> Result a; parseBS = Text.Trifecta.Parsers.parseByteString parser mempty
13:36:04 <Iceland_jack> benzrf: LispFn ([LispVal] -> LispVal) would be the simple way
13:36:14 <Bor0> Iceland_jack, okay, what comes next when I know how (++) is defined?
13:36:17 <benzrf> Iceland_jack: right derp
13:36:23 <Tekmo> NemesisD: Oooooh
13:36:24 <Iceland_jack> Bor0: You use structral induction
13:36:40 <Iceland_jack> Prove it for all (both) cases of the input: [] and (:)
13:36:42 <reactormonk> > let x + y = x + y + 1
13:36:43 <lambdabot>   not an expression: `let x + y = x + y + 1'
13:36:46 <reactormonk> ehh.
13:36:52 <Tekmo> NemesisD: So if you are using `trifecta` then you tie your hands a lot because it doesn't permit streaming parsing without using lazy IO
13:36:53 <Iceland_jack> reactormonk: You need an ‘in’
13:36:56 <Tekmo> NemesisD: However, we can hack around it
13:36:57 <lpaste> countoren revised “Errors cabal install yesod-platform”: “No title” at http://lpaste.net/96083
13:37:11 <reactormonk> ah damn, infinite recursion.
13:37:14 <Tekmo> NemesisD: Does the Trifecta parser provide information on how many characters it will require for parsing?
13:37:23 <NemesisD> Tekmo: i could use attoparsec i guess but i'd have to do some rewriting
13:38:00 <NemesisD> Tekmo: btw it is totally okay for me to slurp the whole response stream and parse it
13:38:07 <Tekmo> NemesisD: Yes, that's totally okay
13:38:23 <NemesisD> Tekmo: and because of that i'm starting to wonder if using pipes is a good idea, maybe this problem is less streamy than i thought
13:38:33 <Cale> > do k <- [0..]; replicateM k [1,2]
13:38:34 <NemesisD> Tekmo: i don't think it does
13:38:34 <lambdabot>   [[],[1],[2],[1,1],[1,2],[2,1],[2,2],[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1]...
13:38:38 <Cale> ^^ ReinH
13:38:53 <Tekmo> NemesisD: You can use `toLazyM` from `pipes-bytestring` to slurp the whole string
13:39:06 <ReinH> Cale: I thought it was replicateM but I couldn't figure out how. ofc you just do it for all finite lengths!
13:39:16 <benzrf> ugh\
13:39:17 <ReinH> Cale: thanks
13:39:28 <benzrf> is there a way to derive Show for one constructor, but use a custom one for another??
13:39:49 <geekosaur> no
13:39:53 <benzrf> bluhhh
13:39:59 <NemesisD> Tekmo: docs warn that its not an idiomatic use of pipes, my fear that i'm treading down the wrong path increases ;)
13:40:12 <monoidal> reactormonk: you can write let x + y = x Prelude.+ y Prelude.+ 1 to specify the Prelude operator.
13:40:23 <eyebloom> In other words are items in a haskell data structure comparable by anything but their value?
13:40:25 <monoidal> > let x + y = x Prelude.+ y Prelude.+ 1 in 3 + 10 -- reactormonk
13:40:26 <lambdabot>   14
13:40:29 <reactormonk> How come :t 'f' is Char but :t 1 is Num a => a
13:40:38 <reactormonk> monoidal, sweet
13:40:45 <countoren> someone have a clew?
13:40:57 <geekosaur> because numeric literals are overloaded per the Haskell Report
13:40:59 <monoidal> reactormonk: what is 'f'?
13:41:07 <monoidal> ah, that 'f'
13:41:12 <Tekmo> NemesisD: Well, when you use Trifecta, you only have two choices: (A) Use lazy IO, or (B) slurp the whole contents
13:41:14 <mjboa> eyebloom: something like that is pretty difficult due to immutability in Haskell. consider what you really need it for, maybe you can implement what you need some other way
13:41:16 <reactormonk> > :t 'f'
13:41:17 <lambdabot>   <hint>:1:1: parse error on input `:'
13:41:35 <geekosaur> there is an extension to enable strings (but not Char-s!) to be overloaded to make working with Text and ByteString easier
13:41:41 <Cale> eyebloom: They're not. Cyclic structures are impossible to distinguish from infinite ones without doing some kind of low-level stuff in IO
13:41:50 <NemesisD> Tekmo: is attoparsec different? i honestly went to trifecta because of the nice debugging diagnostics
13:41:55 <monoidal> there will be also an extension for overloading list syntax [2,3]
13:41:59 <mjboa> eyebloom: they basically aren't. if you're willing to work in IO you can do it
13:42:10 <Tekmo> NemesisD: Maybe trifecta provides an incremental parsing interface.  Let me check
13:42:10 <monoidal> reactormonk: by default, only numeric literals are overloaded.
13:42:19 <Cale> eyebloom: Normally, if you need arbitrary graphs, the thing to do is to use something like Map Vertex (Set Vertex)
13:42:27 <Cale> or Map Vertex [Vertex] or something
13:42:34 <eyebloom> I definitely would not like to work in IO
13:43:02 <Tekmo> NemesisD: Good news!  Apparently it does
13:43:05 <reactormonk> monoidal, so an implementation detail?
13:43:07 <marx2> can I backtrace from error?
13:43:19 <monoidal> reactormonk: it's defined in the language, and it's rather important.
13:43:20 <eyebloom> So my understanding is in order to have a graph I have to set up a reference system of my own, say within a map.
13:43:44 <Cale> eyebloom: yeah
13:43:45 <eyebloom> Which means lookups for every dereference.
13:43:50 <monoidal> reactormonk: this fact allows you to use a number literal as an Int, Integer, Float etc.
13:43:53 <Cale> But lookup is fast
13:44:07 <monoidal> reactormonk: fractional literals such as 2.2 can denote rational numbers, Floats, Doubles etc.
13:44:13 <monoidal> :t 2.2
13:44:14 <lambdabot> Fractional a => a
13:44:16 <Tekmo> NemesisD: So before I continue, just let me warn you about one thing
13:44:16 <eyebloom> I'm just trying to think through this, thanks.
13:44:27 <geekosaur> marx2, not readily because evaluation doesn't work in Haskell like it does in other languages
13:44:27 <Tekmo> NemesisD: There will be an overhaul to the `pipes-parse` API that will simplify several things
13:44:37 <Tekmo> NemesisD: So what I'm about to show you will go obsolete in a month or two
13:44:40 <Cale> marx2: Depending on what you mean by that, you might want to build with profiling support turned on, and then run your program with +RTS -xc
13:44:42 <ReinH> Bor0: did you figure out your associativity proof?
13:44:49 <skypers> hi dudes
13:44:49 <Tekmo> NemesisD: But I will be happy to help you transition when the new API comes out (it won't be too hard)
13:44:53 <reactormonk> monoidal, so number literals can be treated more liberally in terms of type coercion?
13:44:55 <eyebloom> No real attachment to references, but they always seem to come up whenever things get more complicated than straight trees.
13:44:57 <skypers> I participated to a challenge tonight
13:45:00 <Cale> marx2: That'll give a trace of the cost-centres which were active at the point where an exception occurs
13:45:03 <skypers> there were a lot of languages
13:45:08 <skypers> http://www.codingame.com/cg/#!ranking:17
13:45:12 <marx2> that sounds like what I want
13:45:12 <skypers> Haskell was there
13:45:13 <merijn> reactormonk: There is no type coercion, numeric literals are polymorphic
13:45:14 <eyebloom> Or acyclic graphs
13:45:15 <Tekmo> NemesisD: I wish Trifecta didn't have so many throwaway type classes
13:45:16 <skypers> we were a few
13:45:25 <Bor0> ReinH, I am looking at structural induction on wikipedia, seems to have sufficient information :) still looking at it
13:45:27 <skypers> the second exercice was _really_ hard
13:45:35 <skypers> we have to write an OCR for that:
13:45:43 <monoidal> reactormonk: there's no coercion. a literal such as "2" is polymorphic, which means you can use it in different contexts, but it might be represented in a machine differently depending on the context.
13:45:43 <skypers> http://files.codingame.com/pub/dw/dw2-allimages_fr.html
13:45:50 <NemesisD> Tekmo: honestly i'm not married to it at all. i've got more experience with attoparsec
13:45:51 <skypers> do you think it’s trivial to do that in Haskell?
13:46:01 <skypers> I have an idea but I just failed to make it work
13:46:06 <monoidal> reactormonk: e.g. if you write sin 2, then "2" will denote a double
13:46:25 <monoidal> reactormonk: but if you write length "abc" > 2, then "2" denotes an int
13:46:36 <reactormonk> monoidal, nice idea.
13:46:42 <Tekmo> NemesisD: You can use `pipes-attoparsec`
13:47:18 <benzrf> is there something like lookup for maps where you provide a default and it gives you an Either?
13:47:36 <NemesisD> Tekmo: ok i'm going to need an hour to rework my parser :P
13:47:43 <Tekmo> NemesisD: Alright :)
13:47:44 <NemesisD> but that's fine with me. devil you know, etc
13:47:54 <benzrf> :t lookup
13:47:55 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
13:48:00 <benzrf> :t Data.Map.lookup
13:48:01 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
13:48:25 <Cale> :t Data.Map.findWithDefault
13:48:26 <lambdabot> Ord k => a -> k -> M.Map k a -> a
13:48:38 <monoidal> this does not give an Either, thouhg
13:48:41 <benzrf> right
13:48:47 <geekosaur> maybe (Left yourdefaulthere) Right . M.lookup key map -- ?
13:48:49 <benzrf> it's hardly better than just lookup with case
13:49:26 <benzrf> w/e i'll just do 'case lookup foo of Just bar -> Right bar;  Nothing -> Left "OH NO"'\
13:49:35 <mjboa> eyebloom: you might try looking at zippers. they let you "move up" your tree, among other things
13:49:50 <monoidal> benzrf: you can use maybe as geekosaur said.
13:50:21 * Cale secretly prefers the case expression
13:50:27 <eyebloom> mjboa: ok thanks
13:50:42 <Cale> Well, perhaps not in all cases
13:51:23 <zennist> monoial: sorry saw your message late. l can be Groups l1 l2 or something else
13:51:49 <eyebloom> Is there some situation where vertex's essentially compile out of haskell and become actual pointers in memory?
13:51:58 <eyebloom> vertices
13:52:33 <monoidal> zennist: in this case, I would try adding the class. but you'll have to deal with the case when you're given something else.
13:52:59 <Tekmo> eyebloom: You can simulate this using `IORef`s, which are mutable references
13:53:27 <zennist> monoial: yeah I see your point. thanks for your effort
13:53:31 <Tekmo> eyebloom: But most of the standard graph libraries I know of do it the functional way where they simulate references purely
13:54:06 <eyebloom> Tekmo: That's understood, it just feels very impure to me. Not really the direction I wanted to head.
13:54:36 <Tekmo> eyebloom: So, I find that when it comes to problems like these, it helps to consider a smaller but equally difficult problem
13:54:57 <monochrom> I don't think vertices are compiled to pointers.
13:55:05 <eyebloom> I think what I'm looking for is not really mutable references, but immutable references that don't require a lookup.
13:55:06 <Tekmo> eyebloom: Let's think about the simplest possible cycle, a cyclic list with one element that points back to itself
13:55:19 <Cale> eyebloom: You *can* use cyclic datastructures, it's just very fiddly to work with them
13:55:25 <tromp__> cyclic list, or cyclist for shirt
13:55:29 <tromp__> short
13:55:35 <Cale> eyebloom: and operations on them tend to be horribly inefficient
13:56:00 <Tekmo> eyebloom: It is possible to simulate efficient references without lookups
13:56:02 <countoren> hello can someone help ? i have tried to build yesod-platform (cabal install yesod-platform) this is after i followed http://www.haskell.org/platform/mac.html
13:56:05 <Tekmo> eyebloom: This is what zippers are all about
13:56:09 <Cale> eyebloom: For example, if you want to update an element of a cyclic list, you must update every other node in the cycle
13:56:12 <Tekmo> eyebloom: A zipper is basically the functional equivalent of a pointer
13:56:31 <countoren> those are the errors :
13:56:34 <Tekmo> eyebloom: It's an internal reference to the interior of a data structure that you can update or look up in O(1) time and do relative motions
13:56:39 <lpaste> countoren revised “Errors cabal install yesod-platform”: “Errors cabal install yesod-platform” at http://lpaste.net/96083
13:56:47 <Cale> (not to mention that it's hard to tell when to stop)
13:57:00 <Tekmo> eyebloom: And you can have multiple zippers going (i.e. multiple pointers at once)
13:57:19 <Tekmo> eyebloom: The `lens` library provides lots of tools for working with zippers very efficiently and easily
13:57:57 <eyebloom> Ok I'll read up on those. Thanks.
13:58:02 <Tekmo> eyebloom: It's not going to be as easy as in an imperative language, but it works
13:58:30 <ReinH> Bor0: given xs ++ "" = xs, can you prove that "" ++ (ys ++ zs) = ("" ++ ys) ++ zs?
13:58:46 <Bor0> would this be considered a valid proof? http://lpaste.net/96086
13:59:19 <geekosaur> countoren, that list of reinstalls is a very bad sign
13:59:39 <Tekmo> Bor0: The more rigorous way to do this would be to simply check the two cases for the list `xs`
13:59:41 <ReinH> Bor0: let me walk you through an inductive proof
13:59:49 <Cale> countoren: hmmm: cannot satisfy -package-id mtl-2.1.2-94c72af955e94b8d7b2f359dadd0cb62
13:59:50 <Bor0> sure
13:59:54 <countoren> geekosaur: and this is after i got the patched correctly installed
13:59:56 <ReinH> Bor0: given xs ++ "" = xs, can you prove that "" ++ (ys ++ zs) = ("" ++ ys) ++ zs?
13:59:58 <eyebloom> I'll see what I can learn from that.
14:00:00 <Cale> countoren: ghc-pkg check
14:00:01 <Tekmo> Bor0: In other words, first you test whether or not `xs` is [] or `x:xs`
14:00:04 <geekosaur> it appears this yesod-platform is for a newer platform than you have?
14:00:14 <Bor0> so it's proof by cases, and induction for second case?
14:00:24 <Tekmo> Bor0: Yes, basically
14:00:35 <Tekmo> Bor0: Keep in ind that you will also need to branch on the cases for `ys` and `zs`
14:00:46 <ReinH> Tekmo: not really :)
14:00:49 <Tekmo> Bor0: Testing `xs` alone won't be enough for the complete proof
14:01:08 <ReinH> Tekmo: really? Every proof I've seen only tests xs.
14:01:27 <Tekmo> ReinH: Maybe you're right
14:01:46 <ReinH> Let's walk through the proof. It's quite fast. Should we move to #haskell-blah?
14:01:57 <geekosaur> or possibly an older version, since I can't see some of the things it is trying to replace
14:01:58 <monochrom> perhaps you both agree with "casing on xs, plus induction"
14:02:16 <ReinH> monochrom: you need to prove for xs = [] and xs = z:zs
14:02:20 <ReinH> and then you have your induction
14:02:25 <monochrom> yeah
14:02:38 <lpaste> countoren pasted “ghc-pkg check” at http://lpaste.net/96087
14:02:46 <countoren> it doesnt look good either
14:02:50 <ReinH> Bor0: join me in #haskell-blah :)
14:02:51 <monochrom> our triumvariate now agree :)
14:02:57 <Iceland_jack> Or you can just do: quickCheck (\a b c -> (a ++ b) ++ c == a ++ (b + c)) an.. no wait ;)
14:03:00 <ReinH> monochrom: high five o/
14:03:02 <Tekmo> monochrom: :)
14:03:17 <ReinH> Iceland_jack: :p
14:03:20 <monochrom> Iceland_jack, you also have a typo there, + instead of ++ :)
14:03:35 <Iceland_jack> ah well, QuickCheck didn't help me catch that monochrom! :)
14:03:43 <benzrf> oh fuck
14:03:53 <monochrom> @check \x -> x == reverse x
14:03:53 <benzrf> i just realized i wrote myself into a corner requiring runtime type checking
14:03:54 <benzrf> ;_;
14:03:54 <lambdabot>   +++ OK, passed 100 tests.
14:03:55 <Iceland_jack> Ease it up on the swearing :)
14:04:07 <benzrf> ...i think
14:04:12 <benzrf> hmmmm
14:04:31 <Iceland_jack> Why is run-time type checking a problem benzrf?
14:04:36 <monochrom> benzrf: you can, of course, add Typeable to proceed with runtime type checking :)
14:04:36 <monoidal> the 'check' thing is somewhat interesting.
14:04:51 <benzrf> Iceland_jack: isn't it an antipattern or something
14:04:52 <scott_> monochrom: Does it default to [()] lists or something?
14:04:53 <monoidal> if we have Eq a => ... then you can substitute a = Int to get the same thing, but () is too weak.
14:05:01 <monochrom> yes, it defaults to [()]
14:05:03 <Iceland_jack> benzrf: Run-time type checking?
14:05:07 <benzrf> well
14:05:11 <monoidal> if we have Ord a => ... then a = Int might be not enough, instead a = Rationals.
14:05:17 <Iceland_jack> monochrom: Have you incidentally seen how Clean handles polymorphic dynamic types?
14:05:26 <monoidal> if no context, a = () is enough
14:05:32 <monochrom> no, I haven't. how does it do it?
14:05:36 <benzrf> i want to cause an error if you try to use lambda with something other than symbols in the param list
14:05:36 <Iceland_jack> You can do something like:
14:05:36 <Iceland_jack>     applyDyn (f :: a -> b) (x :: a) = dyn (f x)
14:05:52 <Cale> countoren: If I were you, I'd just blow away my ~/.ghc and start over.
14:05:54 <benzrf> oo
14:05:57 <Iceland_jack> You can also match on type classes
14:06:04 <benzrf> wait you can pattern match types??
14:06:07 <benzrf> NeatBasis:
14:06:10 <benzrf> *neat
14:06:12 <Iceland_jack> In Clean you can
14:06:15 <benzrf> oh
14:06:17 <benzrf> -.-
14:06:24 <benzrf> not vanilla hs ?
14:06:24 <Iceland_jack> Do you always press ^I instead of ^M?
14:06:25 <monoidal> you can match on types in type families
14:06:28 <benzrf> Iceland_jack: :p
14:06:30 <countoren> any idea anyone?
14:06:34 <benzrf> it's a habit from overuse of bash autocomplete
14:06:48 <monoidal> countoren: I would follow Cale's advice. delete ~/.ghc, ~/.cabal and start over.
14:06:49 <benzrf> i always press tab at the end of typing a command usually
14:06:52 <Iceland_jack> Do you mean completion?
14:06:55 <Iceland_jack> huh?
14:06:59 <benzrf> yeah
14:07:00 <Cale> :O  A Clean user! Get him!
14:07:01 <Iceland_jack> even after you've finished typing
14:07:04 <benzrf> erm
14:07:04 <countoren> o didnt see that
14:07:10 <Cale> hehe
14:07:11 <Iceland_jack> I didn't say I used it Cale!
14:07:19 <Iceland_jack> Pitchforks down everyone
14:07:37 <Iceland_jack> https://ghc.haskell.org/trac/ghc/wiki/PolymorphicDynamic for those interesting
14:07:57 <Iceland_jack> I don't expect it to land in ghc to be honest
14:08:11 <benzrf> wait is this an extension
14:08:13 <Iceland_jack> but it would make working with dynamic values very nice
14:08:14 <monoidal> Iceland_jack: do you know if this idea covers rank-n?
14:08:15 <benzrf> I KNEW IT
14:08:16 <Iceland_jack> benzrf: no
14:08:20 <benzrf> wait huh
14:08:21 <Iceland_jack> monoidal: I believe not
14:08:34 <Iceland_jack> Did you know it was an extension benzrf?
14:08:51 <benzrf> > case 3 of (i :: Int) -> i + 1; (s :: String) -> s
14:08:52 <lambdabot>   Couldn't match type `GHC.Types.Int' with `[GHC.Types.Char]'
14:08:52 <lambdabot>  Expected type:...
14:08:55 <benzrf> u lied
14:08:58 <Cale> "The difficulty lies with ad-hoc polymorphism" s/ad-hoc/type class/
14:09:00 <Iceland_jack> What do you mean?
14:09:05 <benzrf> it does not work
14:09:08 <monochrom> I know how to improve Cale's call.
14:09:18 <Iceland_jack> benzrf: What are you talking about, I neve said it did
14:09:25 <monochrom> :O a dynamic typing fan! get him!
14:09:32 <benzrf> -.-
14:09:35 <monochrom> :)
14:09:40 <benzrf> 16:53 < Iceland_jack>     applyDyn (f :: a -> b) (x :: a) = dyn (f x)
14:09:41 <Cale> haha
14:09:51 <Cale> countoren: You don't have to delete ~/.cabal
14:09:59 <Iceland_jack> benzrf: Yes, I pasted Clean code after having mentioned twice that it was for Clean
14:10:02 <Cale> (also monoidal)
14:10:06 <Iceland_jack> one of which was a response to you
14:10:11 <benzrf> ahihi2:
14:10:12 <benzrf> *ah
14:10:13 <Cale> ~/.cabal/config in particular might be important to you
14:10:33 <Iceland_jack> I don't know what more to say :)
14:10:34 <Cale> But you could clear out everything else from ~/.cabal if you want to save some space
14:10:37 <countoren> Cale: did it allready
14:10:43 <Cale> ah, okay
14:11:02 <monochrom> Iceland_jack: I don't understand "applyDyn (f :: a -> b) (x :: a) = dyn (f x)". what is its semantics?
14:11:06 <countoren> Cale: i guess next step will be brew uninstall haskell
14:11:24 <countoren> Cale: and reinstalling it
14:11:32 <Cale> It's not a huge deal, just you'll likely have to edit ~/.cabal/config to set documentation: True and library-profiling: True again
14:11:34 <Iceland_jack> monochrom: If the first argument to applyDyn is a function whose domain is the type of its second argument, then the pattern matches
14:11:43 <Iceland_jack> and the function is applied to the second argument
14:11:43 <Cale> (I have no idea why those default to False)
14:12:05 <monochrom> oh yikes, it is a pattern on the types, and it is not a linear pattern!
14:12:27 <Iceland_jack> :) that's right monochrom!
14:12:34 <monochrom> scary
14:12:49 * Iceland_jack feels like they're about to get burned on a stake!
14:13:22 <monochrom> I don't like non-linear patterns. (I'm fine with pattern on types.) perhaps I'm just a pedant.
14:13:38 <Tekmo> I still have my pitchfork
14:13:38 <Iceland_jack> No I lean towards the same disposition monochrom
14:13:43 <Iceland_jack> Tekmo: ;)
14:13:45 <Tekmo> :)
14:13:46 <monochrom> heh ok
14:13:56 <countoren> Cale: which is better homebrew or reinstall package from site?
14:14:10 <Iceland_jack> That should probably have been ‘same position’
14:14:11 <Cale> countoren: I would use cabal install to reinstall things after doing that
14:14:35 <Cale> Of course, if you deleted ~/.cabal/bin it's possible that you deleted your cabal binary.
14:14:41 <countoren> Cale: its ralted to cabal only?
14:14:56 <Cale> countoren: cabal-install installs ghc packages
14:15:13 <countoren> Cale: thanks , man ill try
14:16:22 <monochrom> well, I guess the justification for the way Clean does it is: at the term level, we are not doing prolog, therefore linear patterns. at the type level, we are totally doing more that prolog, it's full-blown unification, therefore nonlinear patterns.
14:17:03 <monoidal> monochrom: nonlinear patterns on types are coming to 7.8...
14:18:25 <monochrom> it is just a bit taxing on my brain to remember two sets of rules. but I acknowledge that they are consistent with the traditional term-level culture and the traditional type-level culture.
14:18:26 <monoidal> monochrom: (well, even now we can write 'instance C a a' so in some weak sense we've got nonlinear patterns.)
14:18:30 <Iceland_jack> Knuth's book on Visual Basic is actually pretty good
14:19:51 <monochrom> haha, on the bright side, more reason to promote my http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification
14:20:08 <monochrom> wait what? Knuth wrote a book on VB?!
14:20:12 <Iceland_jack> http://www.ibiblio.org/Dave/Dr-Fun/df200002/df20000210.jpg ;)
14:21:06 <Cale> haha, bonus free CD with thousands of truetype fonts
14:21:15 <monochrom> well I guess it is a reasonable trade for Bill Gates's appraisal of TAOCP :)
14:21:29 <Iceland_jack> that appraisal doesn't come free!
14:22:06 <int-e> monochrom: I should work on that resume ;-)
14:22:13 <monochrom> haha
14:24:58 <Aetherspawn> http://stackoverflow.com/questions/20139957/haskell-trifecta-parsing-completely-optional-semicolons-without-polluting-ast help is appreciated if anyone is particularly good at parsing, thanks.
14:25:33 <Bor0> @src map
14:25:33 <lambdabot> map _ []     = []
14:25:33 <lambdabot> map f (x:xs) = f x : map f xs
14:28:38 <monochrom> Aetherspawn: could you write down the complete grammar in EBNF? (you could say, I should read it off from your code. yes I can do that, but since you're precisely saying your code is wrong, I no longer know what is right.)
14:31:23 <kuznero> Hi All!
14:31:26 <Tekmo> Hi!
14:31:28 <benzrf> hello!
14:31:40 <benzrf> kuznero: are you going to ask about monads?
14:31:40 <benzrf> ;p
14:31:48 <kuznero> I have a question wrt haskellmode/haskellfold in vim :)
14:31:55 <ReinH> uh oh
14:31:55 <Aetherspawn> monochrom: I don't know EBNF
14:31:57 <kuznero> Monads are much better I feel :)
14:31:58 <Aetherspawn> but I'll try.
14:32:09 <ReinH> but hey, not monads
14:33:04 <kuznero> For some reason vim haskellFold does not work in vim after I installed it. Does anyone knows if it requires additional packages to be installed like ghc-mod, hdevtools, etc.?
14:34:59 <ReinH> kuznero: I haven't used it sorry
14:35:37 <kuznero> ReinH: no promplem
14:35:40 <Aetherspawn> monochrom: gotta pop down the road, but I'll put the EBNF in the question in about 2 hours and I'll tag you here if you want, thanks for your help :)
14:36:02 <monochrom> trifecta depends on a million packages
14:36:54 <countoren> Cale: cabal installed faild to install as well :/
14:37:00 <hpc> monochrom: they're almost all edwardk packages though, so you can take comfort in the fact that you were never going to understand them anyway
14:37:08 <monochrom> haha
14:37:17 <lpaste> countoren pasted “cabal install cabal-install” at http://lpaste.net/96090
14:38:12 <countoren> its becoming realy annoying
14:38:18 <countoren> :/
14:38:48 <Cale> countoren: hmm
14:39:04 <chrisdone> welcome to cabal hell. is it just a weekend pass or a lifetime membership?
14:39:04 <Cale> countoren: Remove ~/.ghc and see if ghc-pkg check reports any errors
14:39:23 <Cale> I wonder if somehow some things got messed up globally?
14:39:23 <countoren> ok give mme a sec
14:40:00 <chrisdone> evening, Peaker
14:40:07 <Peaker> evening chrisdone :)
14:40:15 <monoidal> countoren: it might be http://stackoverflow.com/questions/19652729/cabal-cabal-install-not-working-strange-error
14:40:37 <Cale> Oh~
14:40:38 <Cale> !
14:41:11 <countoren> no
14:41:14 <countoren> follow those
14:41:15 <Cale> I didn't realise that was a symptom of the new OSX issues
14:41:39 <osa1> pfffffff .. I'm getting an annoying type error while trying to use everywhere/mkT etc. from Data.Generics. "cannot deduce a0 ..." but a0 looks free in context (e.g. there's no use of a0 in error message or code)
14:41:54 <countoren> o
14:41:57 <countoren> wait
14:41:59 <countoren> myabe
14:42:08 <countoren> let me check
14:43:05 <marx2> is there a deepseq equivalent that does not require you to define NFData?
14:43:16 <monochrom> no
14:43:49 <Cale> marx2: The NFData instance explains how to traverse the structure and evaluate its parts, it's pretty hard to do without that.
14:43:53 <chrisdone> i think such a thing might be ambiguous, like how far does it force down?
14:44:00 <marx2> I see
14:44:56 <benzrf> is there maybe for Either?
14:45:09 <monochrom> yes, it's called "either"
14:45:11 <benzrf> derp
14:45:12 <benzrf> :t either
14:45:13 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
14:45:36 <benzrf> that doesn't look right...
14:45:38 <benzrf> :t maybe
14:45:39 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:45:58 <benzrf> oh oops
14:46:03 <benzrf> i guess i don't really want maybe for either
14:46:18 <benzrf> well, maybe?
14:46:54 <benzrf> oh derp i do
14:47:00 <benzrf> ok, thanks :)
14:47:21 <james-sh> I am trying to build a function which gets a list of functions and returns a function which is the composition of those in the list
14:47:25 <james-sh> I have this implementation
14:47:34 <james-sh> composeList [] = id
14:47:38 <james-sh> composeList (function:functions) = (.) function (composeList functions)
14:47:44 <james-sh> but it does not work
14:47:53 <chrisdone> nod
14:47:53 <arkeet> what doesn't work about it?
14:47:54 <james-sh> does any body know why? thanks
14:47:58 <monochrom> ah, to use "cabal repl", I have to write a *.cabal file
14:48:12 <james-sh> it gets compiled successfully.
14:48:13 <james-sh> but
14:48:16 <sipa> james-sh: the functions won't have the same type, while a list does require that
14:48:24 <sipa> eh
14:48:27 <sipa> nevermind
14:48:30 <monochrom> well then, "ghci -package-db xxx" is going to be simpler
14:48:40 <arkeet> james-sh: you won't be able to compose functions of different types.
14:48:41 <james-sh> yes, I make sure the functions that I put in the list are composable.
14:48:55 <sipa> they have to be of type a -> a
14:48:55 <arkeet> they will all have to be a -> a, for the same a
14:48:55 <monoidal> james-sh: you can't have a list of values with different types.
14:49:00 <arkeet> because ↑
14:49:01 <james-sh> yes
14:49:04 <arkeet> ok
14:49:10 <james-sh> so lets have three functions
14:49:16 <james-sh> f, g and H
14:49:18 <james-sh> f, g and h
14:49:23 <arkeet> well, could you show the exact code and error message?
14:49:23 <james-sh> f :: Integer -> Bool
14:49:26 <sipa> @let composeList (function:functions) = (.) function (composeList functions)
14:49:28 <lambdabot>  Defined.
14:49:28 <james-sh> g :: Bool -> Double
14:49:32 <sipa> :t composeList
14:49:33 <lambdabot> [b -> b] -> a -> b
14:49:33 <james-sh> h :: Double -> Double
14:49:36 <arkeet> james-sh: ok, you didn't understand what we just said.
14:49:42 <scott_> james-sh: You can't store those in a list, they have different types
14:49:49 <arkeet> :p
14:49:56 <james-sh> i see
14:50:04 <ReinH> sipa: foldl (.) id
14:50:14 <arkeet> ReinH: foldr, please.
14:50:15 <ReinH> @src foldl
14:50:15 <lambdabot> foldl f z []     = z
14:50:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:50:20 <sipa> ReinH: just copying james-sh' code :)
14:50:22 <ReinH> @src foldr
14:50:23 <lambdabot> foldr f z []     = z
14:50:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:50:23 <james-sh> scott, i got you now
14:50:27 <skypers> hey
14:50:30 <ReinH> arkeet: yep this one is foldr sry
14:50:37 <skypers> why isn’t chunksOf in Data.List?
14:50:40 <skypers> it’s a great function
14:50:47 <arkeet> fortunately it's in Data.List.Split
14:50:53 <skypers> yep
14:50:57 <skypers> but tonight
14:51:01 <ReinH> :t ala Endo foldMap
14:51:02 <lambdabot> Foldable t => t (a -> a) -> a -> a
14:51:03 <geekosaur> because nobody can agree on *the* right way to split a list
14:51:05 <ReinH> is my favorite version
14:51:07 <skypers> I just couldn’t use it
14:51:17 <geekosaur> so you get a bunch of them but they're off by themselves
14:51:18 <arkeet> :t splitAt
14:51:19 <lambdabot> Int -> [a] -> ([a], [a])
14:51:32 <Cale> map (take n) . takeWhile (not . null) . iterate (drop n)
14:51:33 <skypers> (because of the computer of the context, it didn’t have it)
14:51:38 <skypers> well
14:51:38 <arkeet> :t \n -> takeWhile (not . null) . unfoldr (Just . splitAt n)
14:51:38 <lambdabot> Int -> [a] -> [[a]]
14:51:42 <skypers> I write it that way:
14:51:56 <skypers> http://lpaste.net/96089
14:51:59 <arkeet> fortnuately, splitAt is in Data.List.
14:52:01 <arkeet> and in Prelude.
14:52:10 <udevd> http://pastebin.com/RyjhWkCJ on line 44 i got     Couldn't match expected type `Vector Double'
14:52:13 <mauke> The paste RyjhWkCJ has been copied to http://lpaste.net/96100
14:52:13 <udevd>                 with actual type `(Vector Double, b0)'
14:52:15 <skypers> (that program takes ASCII alphabet and pops text :D)
14:52:21 <Cale> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1..20]
14:52:22 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
14:52:23 <skypers> yeah yeah arkeet
14:52:26 <skypers> I know that
14:52:29 <udevd> i don't know really why, as I declared type for multiplyByRandom
14:52:40 <james-sh> Thanks.
14:52:41 <arkeet> Cale: using 3 twice =(
14:52:45 <skypers> my chunksOf version is not tail-recursive though
14:52:49 <Cale> arkeet: meh
14:53:01 <arkeet> skypers: why should it be tail-recursive?
14:53:05 <arkeet> it should be lazy instead.
14:53:12 <skypers> for performance
14:53:16 <skypers> well mine is lazy
14:53:16 <arkeet> no.
14:53:20 <Cale> arkeet: A lambda will fix that
14:53:20 <arkeet> you want lazy.
14:53:24 <skypers> (see the lpaste above)
14:53:27 <arkeet> Cale: using the argument twice
14:53:28 <arkeet> =(
14:53:31 <Cale> lol
14:53:42 <arkeet> skypers: yes, that one is fine!
14:53:43 <monoidal> udevd: giving a typesig for lastpointgauss might make the error more helpful
14:54:13 <skypers> btw, I won the Haskell context
14:54:18 <arkeet> @pl \n -> takeWhile (not . null) . unfoldr (Just . splitAt n)
14:54:19 <lambdabot> (takeWhile (not . null) .) . unfoldr . (Just .) . splitAt
14:54:21 <skypers> (and a rasberry π! :))
14:54:21 <ReinH> tail recursion in haskell doesn't work the way most people assume it does ;)
14:54:26 <marx2> I have trouble reading composeList (function:functions) = function . (composeList functions)
14:54:29 <marx2> how does that work?
14:54:43 <FireFly> ReinH: how so?
14:54:44 <udevd> monoidal: didn't changed enything
14:54:49 <udevd> anything*
14:54:53 <ReinH> FireFly: well, there's no call stack, so call stack elimination is not a thing
14:54:58 <arkeet> marx2: how about:   sum (x:xs) = x + sum xs
14:54:58 <Cale> ReinH: Tail call optimisation doesn't mean much when you don't have a call stack to optimise.
14:55:00 <arkeet> can you read that?
14:55:06 <FireFly> ReinH: oh
14:55:10 <ReinH> what matters is whether sharing happens in the evaluation stack
14:55:15 <marx2> arkeet yes
14:55:16 <monoidal> udevd: isn't your list of pairs, while you filter it with inside, which does not take a pair?
14:55:25 <arkeet> marx2: ok, well it's just replacing sum with composeList and + with .
14:55:27 <ReinH> Cale: I literally asked SimonM about this last weekend :D
14:55:32 <Cale> There's a stack which GHC uses to pattern match
14:55:37 <arkeet> (and changing the names of variables)
14:55:39 <marx2> it expands to (f1 . f2 . f3 . f4)
14:55:45 <ReinH> but the question didn't make it into the podcast
14:55:46 <marx2> ?
14:55:58 <udevd> hm i think it is what i omitted, i'll check
14:56:00 <arkeet> marx2: the base case isn't there, it shold also have composeList [] = id
14:56:06 <arkeet> marx2: so composeList [f,g,h] is f . g . h . id
14:56:12 <ReinH> marx2: it's a monoid homomorphism :D
14:56:18 <marx2> ah
14:56:19 <Cale> i.e. when you pattern match on something, essentially the case expression goes on a stack while the scrutinee is evaluated
14:56:32 <skypers> btw, I was suprised to see that haskellers failed at the context
14:56:37 <skypers> the winner is a PHP guy…
14:56:42 <ReinH> marx2: consider, for functions f,g,h, f : g : h : []
14:56:51 <ReinH> marx2: now replace (:) with (.) and [] with id
14:56:54 <ReinH> f . g . h . id
14:56:57 <arkeet> :-)
14:57:12 <marx2> very clear now
14:57:13 <arkeet> Cale: where are those pictures?
14:57:16 <arkeet> for foldr and friends
14:57:20 <skypers> http://www.codingame.com/cg/#!ranking:17 (a bit down for Haskell dudes, with me included)
14:57:24 <skypers> I don’t what to think
14:57:33 <Cale> http://cale.yi.org/share/Folds.png
14:57:34 <benzrf> i feel like i should read up on Either utility funcs
14:57:41 <skypers> is Haskell really better than other languages when we need to write fast?
14:57:58 <skypers> that contest just proves it isn’t
14:58:02 <benzrf> skypers: STONE THE HEATHEN
14:58:03 <ReinH> marx2: so it's a homomorphism from <(a->a),(:),[]> to <(a->a),(.),id> :)
14:58:03 <marx2> works too :).   compose = foldr (.) id
14:58:11 <skypers> or the other haskellers were just bad.
14:58:15 <skypers> benzrf: what? :D
14:58:31 <ReinH> marx2: a.k.a the Endo monoid
14:58:33 <monoidal> ReinH: from <[a->a],(:),[]> to <(a->a),(.),id>
14:58:44 <khyperia> Oh, wow, I actually didn't use <$> when writing an applicative thingy... "f <*> x <*> y" and not "f <$> x <*> y"... that almost never happens.
14:58:56 <ReinH> monoidal: ... I don't think so?
14:59:06 <udevd> monoidal: compiles, thanks :)
14:59:12 <yng> pwd
14:59:20 <monoidal> ReinH: in the first monoid, elements are [a -> a], in the second a -> a, no?
14:59:30 <monochrom> haskellers are too busy with real jobs to play coding games
14:59:39 <arkeet> L-)
14:59:40 <arkeet> :
14:59:50 <monochrom> also explains why you don't find medical doctors on IRC
14:59:56 <ReinH> monoidal: ok, yeah, but technically (a->a)* :p
15:00:24 <monoidal> then agreed,  <(a->a)*,(:),[]> to <(a->a),(.),id>
15:00:31 <ReinH> monoidal: o/
15:00:39 <marx2> why do both  compose = foldl (.) id  and  compose = foldr (.) id  work?  I expected opposite result for  compose [(subtract 10),(subtract 2)] 5
15:00:41 <ReinH> (high five)
15:00:52 <ReinH> marx2: because (.) is associative
15:00:53 <scott_> marx2: Because composition is associative
15:00:56 <ReinH> doh
15:00:59 <ReinH> scott_: :p
15:01:01 <monoidal> ReinH: though I would prefer to write <(a->a)*, (++), []>
15:01:04 <scott_> You beat me :P
15:01:11 <ReinH> monoidal: yeah that's more correct again :)
15:01:18 <ReinH> scott_: I saved some chars :)
15:01:24 <monochrom> foldl (.) will only have a problem with infinite lists
15:01:28 <marx2> ah right. it doesn't matter if we first subtract 2 or 5, or 5 and then 2
15:01:38 <arkeet> marx2: no that's not it.
15:01:46 <arkeet> both first subtract 2 then subtract 5.
15:01:51 <ReinH> marx2: no, it's because (f.g).h = f.(g.h)
15:01:56 <arkeet> ↑
15:01:58 <arkeet> in particular,
15:02:36 <monoidal> udevd: btw there are many small things you can fix in that code, ask me if you want tips
15:02:59 <arkeet> subtract 10 . (subtract 2 . id) = (id . subtract 10) . subtract 2
15:03:13 <ReinH> marx2: foldl parenthesizes from the left, foldr parenthesizes from the right, but parenthesis don't matter for associative operations
15:03:14 <arkeet> (the left one is what foldr gives, the right one is what foldl gives. sorry)
15:03:20 <ReinH> so (f.g).h = f.g.h = f.(g.h)
15:03:29 <nooodl> foldl (.) id [f,g] = foldl (.) (id.f) [g] = foldl (.) (id.f.g) [] = f.g
15:03:31 <arkeet> but for laziness, usually one wants the foldr version.
15:03:32 <nooodl> foldr (.) id [f,g] = f . foldr (.) id [g] = f.g . foldr (.) id [] = f.g
15:03:45 <marx2> I think I got it. nothing is subtracted until we fold the list of functions
15:03:49 * arkeet thinks it's instructive to leave in the id
15:03:53 <monoidal> marx2: also, it doesn't matter whether you first subtract 2 or 5, or 5 and then 2. but it *does* matter for other functions, for example sin . cos /= cos . sin.
15:03:54 <arkeet> (and parentheses)
15:04:06 <ReinH> arkeet: which brings us back to the fact that productive recursion is usually more important than tail recursion :)
15:04:11 <arkeet> :-)
15:04:56 <ReinH> marx2: iow it uses associativity, not commutativity
15:05:37 <zennist> how can I specify in my Haskell script that something is of the same type of another variable?
15:05:56 <monoidal> zennist: there's no "typeof" operator
15:06:01 <ReinH> zennist: a) you can't, b) you shouldn't need to.
15:06:04 <arkeet> yes you can
15:06:07 <arkeet> you can even write it
15:06:10 <ReinH> :/
15:06:16 <ReinH> a) you shouldn't need to
15:06:19 <arkeet> asTypeOf :: a -> a -> a; x `asTypeOf` y = x
15:06:25 <ReinH> arkeet: oh yeah, it's called const
15:06:26 <monoidal> zennist: maybe you need ScopedTypeVariables?
15:06:27 <ReinH> doh
15:06:32 <arkeet> ReinH: sometimes it's unavoidable without ScopedTypeVariables.
15:06:34 <zennist> I just monoidal:
15:06:50 <zennist> monoidal: scopedtypevariables won't work in my case
15:06:58 <zennist> I need to get the exact type of a thing
15:06:59 <ReinH> arkeet: or, rather, const with appropriately constrained types
15:07:04 <arkeet> yes.
15:07:11 <arkeet> lambdabot has it.
15:07:13 <geekosaur> what?
15:07:13 <ReinH> I've even used it
15:07:19 * ReinH is silly
15:07:20 <monoidal> zennist: maybe you want a constraint a ~ b => ...?
15:07:26 <arkeet> well
15:07:30 <arkeet> let's figure out what exactly zennist wants to do.
15:07:31 <ReinH> zennist: what are you actually trying to do?
15:07:37 <ReinH> this smells like an XY problem
15:07:50 <arkeet> "show your code"
15:08:05 <zennist> ReinH: I have a function that has to been attached a type signature (otherwise the compiler can't deduce the type)
15:08:28 <zennist> ReinH: and I have a variable in my script that tells me about the type that should be annotated
15:08:39 <zennist> but that type is very very complex so I don't want to do it manually
15:08:43 <arkeet> show your code?
15:08:43 <FireFly> monoidal: "it doesn't matter if you subtract 2 or 5 first" ← does that property (of binary operations) have a name?
15:09:20 <ReinH> FireFly: commutativity
15:09:28 <ReinH> ab = ba
15:09:34 <FireFly> Hm, but it isn't quite commutativity, since a - b != b - a
15:09:35 <monochrom> commutes. e.g., if f(g x) = g(f x), we say "f and g commute"
15:09:37 <chrisdone> a-b = b-a? ;)
15:09:38 <FireFly> (in general)
15:09:45 <frx> there's :cd in ghci, but I can't find :cwd. how to get current working directory?
15:09:46 <monoidal> FireFly: (-2) and (-5) commute though
15:09:50 <ReinH> FireFly: (-a)(-b) = (-b)(-a)
15:10:00 <arkeet> put a . in there.
15:10:01 <monoidal> here juxtaposition means composition
15:10:05 <arkeet> :p
15:10:06 <geekosaur> :!pwd (:!cd on windows)
15:10:12 <geekosaur> cd has to be built in
15:10:15 <FireFly> Oh
15:10:17 <geekosaur> at least on unix
15:10:18 <ReinH> arkeet: ok, but I just used ab for a.b :p
15:10:23 <arkeet> :P
15:10:24 <monochrom> clearly, "(subtract a) and (subtract b) commute" is not the same as "a - b = b - a"
15:10:26 <ReinH> I guess I should be consistent with Haskell notation
15:10:29 <ReinH> rather than math notation
15:10:37 <FireFly> eh, I prefer using ∘ anyway
15:10:50 <ReinH> FireFly: well I don't have all those symbols handy :/
15:10:50 * FireFly isn't used to juxtaposition-for-composition
15:10:54 <FireFly> ah
15:11:02 * arkeet is, but not in the context of haskell :)
15:11:06 <FireFly> Anyway, that works I guess
15:11:07 <ReinH> arkeet: indeed :)
15:11:10 <ReinH> I'll try to stick to .
15:11:15 <monoidal> once you say "add (-2)" and "add (-5)" instead of "subtact 2" and "subtract 5", it might become more obvious.
15:11:27 <arkeet> yep
15:11:32 <monoidal> it follows from commutativity of addition.
15:11:57 <chrisdone> nod
15:12:05 <chrisdone> subtract a . subtract b = subtract (a+b)
15:12:07 <FireFly> Yeah, that makes sense
15:12:07 <ReinH> chrisdone: hai
15:12:15 <chrisdone> hei rein
15:12:16 <zennist> arkeet: can you tell me a bit more about 'asTypeOf'?
15:12:17 <monochrom> it is why I work calculationally rather than think intuitively
15:12:24 <zennist> I couldn't find it online
15:12:25 <ReinH> :t const
15:12:25 <lambdabot> a -> b -> a
15:12:26 <ReinH> :t asTypeOf
15:12:27 <lambdabot> a -> a -> a
15:12:35 <ReinH> zennist: asTypeOf is a constrained const
15:12:43 <monoidal> I'm not sure asTypeOf works well with rank-2-types
15:12:47 <zennist> ReinH: any example usage?
15:12:50 <monoidal> which zennist probably uses.
15:12:50 <arkeet> zennist: I just defined it.
15:12:52 <chrisdone> it just forces the first arg's type to unify with the second
15:13:01 <ReinH> :t 1 `asTypeOf` (2::Int)
15:13:02 <lambdabot> Int
15:13:11 <ReinH> :t 1
15:13:11 <lambdabot> Num a => a
15:13:17 <chrisdone> > return 1 `asTypeOf` [2]
15:13:18 <lambdabot>   [1]
15:13:21 <zennist> Great! I hope this thing help with my use case
15:13:27 <ReinH> chrisdone: nice
15:13:31 <chrisdone> =)
15:13:36 <arkeet> I also like asProxyTypeOf :: a -> p a -> a
15:13:47 <zennist> monoidal: I was still at the same old problem and I'll try if asTypeOf will help me with that
15:13:55 <ReinH> zennist: btw this is generally used for messing with lambdabot, not for actual code
15:14:00 <ReinH> zennist: so I'm a bit dubious of your need for it
15:14:03 <arkeet> ReinH: not true!
15:14:04 <khyperia> Woohoo, added data constructors to my language, but I don't have case expressions, so once it's in there... it ain't comin' out!
15:14:07 <ReinH> arkeet: ok never mind :)
15:14:08 <arkeet> some code needs it, unless you use STV
15:14:09 <chrisdone> arkeet: yeah that's like a parametrizable x :: y
15:14:10 <ReinH> I've never seen it
15:14:29 <chrisdone> asTypeOf is mostly useful in generic programming
15:14:31 <ReinH> but I believe you
15:14:32 <chrisdone> Typeable, Data, etc
15:14:33 <monoidal> zennist: if it's still the original problem, I'm very doubtful it will help
15:15:03 <monoidal> zennist: asTypeOf can make a value with polymorphic type less polymorphic. it won't make it more polymorphic.
15:15:22 <arkeet> well, I don't think we ever heard what the original problem was.
15:15:49 <monochrom> monoidal did. so did I. but I decided not to play.
15:16:06 <chrisdone> ReinH: i just thought of a good example
15:16:32 <chrisdone> :t let result = undefined::Int {- result is the result of your generic function -} in asTypeOf minBound result
15:16:33 <lambdabot> Int
15:16:35 <monochrom> it was about 3 hours ago.
15:16:54 <zennist> arkeet: in short: I'm using someone's code that's using a rank2type, and I can't pattern match the variable of the rank2type constraint. I'm working around that
15:16:58 <enthropy> it reads better  x `asTypeOf` y
15:17:14 <marx2> I still don't get it. :/
15:17:19 <arkeet> get what
15:17:29 <zennist> arkeet: it's at lpaste.net/96078 if you care to take a look
15:17:33 <monochrom> in fact, consider http://lpaste.net/96078
15:18:06 <benzrf> foo :: (a -> Either l r) -> [a] -> Either l [r]
15:18:07 <benzrf> ??
15:18:09 <zennist> I've been stuck with this problem for the whole night..
15:18:14 <benzrf> @hoogle (a -> Either l r) -> [a] -> Either l [r]
15:18:15 <lambdabot> No results found
15:18:17 <monoidal> benzrf: mapM
15:18:18 <benzrf> lame
15:18:21 <benzrf> oh wait
15:18:22 <benzrf> derp
15:18:22 <arkeet> benzrf: traverse
15:18:22 <benzrf> -.-
15:18:28 <benzrf> :t traverse
15:18:29 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
15:18:42 <benzrf> huh
15:18:48 <arkeet> f = Either l, t = []
15:18:48 <monoidal> traverse is more general mapM.
15:18:54 <benzrf> :t mapM
15:18:54 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:19:15 <zennist> monoidal: I think you are right, it won't actually help me with that..
15:19:20 <Twey> khyperia: Eliminators are easier to add than pattern-matching
15:19:23 <benzrf> so if any of then eval to a  Left, the whole thing will return that Left?
15:19:29 <arkeet> yes
15:19:30 <khyperia> what are eliminators?
15:19:42 <benzrf> cool
15:19:43 <simpson> :t maybe -- kylcarte
15:19:43 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:19:45 <arkeet> > traverse id [Right 1, Right 2, Right 3]
15:19:46 <lambdabot>   Right [1,2,3]
15:19:46 <Twey> khyperia: An eliminator is a function that takes an argument for each constructor of your type
15:19:48 <monoidal> khyperia: functions such as maybe and either
15:19:51 <simpson> Er, khyperia ^^^
15:19:52 <arkeet> > traverse id [Right 1, Left 'a', Right 2, Left 'b', Right 3]
15:19:53 <lambdabot>   Left 'a'
15:19:54 <khyperia> ahh
15:19:57 <benzrf> ahihi2:
15:19:58 <benzrf> *ah
15:20:00 <arkeet> (btw, traverse id = sequenceA)
15:20:04 <benzrf> why use traverse over mapM though?
15:20:11 <arkeet> it's more general.
15:20:14 <benzrf> ok...
15:20:15 <Twey> khyperia: So e.g. the eliminator for Maybe is maybe : b → (a → b) → Maybe a → b
15:20:16 <marx2> '(cos . sin)' is not the same as '(sin . cos)', but 'foldl (.) id [cos, sin]' is the same as 'foldr (.) id [cos, sin]'
15:20:17 <arkeet> you can use mapM if you want.
15:20:17 <benzrf> will do then
15:20:25 <benzrf> well
15:20:33 <benzrf> i think id rather use a prelude func
15:20:35 <Twey> khyperia: It's a straightforward translation from a datatype to its eliminator; much easier than pattern-matching :þ
15:20:36 <benzrf> it's more recognizable
15:20:39 <arkeet> neither is in the prelude ;)
15:20:43 <benzrf> isn't mapM?
15:20:46 <arkeet> nope
15:20:47 <Twey> benzrf: Control.Monad
15:20:55 <arkeet> oh wait it is!
15:20:57 <benzrf> then why is it available when i ghci without any import
15:20:59 <monoidal> mapM is in Prelude
15:21:00 <Twey> Or Data.Traversable :þ
15:21:01 <Tekmo> mapM is in the Prelude
15:21:02 <Twey> Oh, it is?
15:21:03 <Cale> marx2: both foldl and foldr keep the order of the elements of the list the same
15:21:07 <monochrom> marx2, no one says foldl gives you (sin . cos) and foldr gives you (cos . sin)
15:21:17 <Cale> marx2: The difference is how they're associated
15:21:30 <khyperia> Only trouble is my language is strict, so things like "maybe (error blah) [...]" might not do so hot
15:21:30 <arkeet> foldr (.) id [f,g,h] = f . (g . (h . id))
15:21:37 <arkeet> foldl (.) id [f,g,h] = ((id . f) . g) . h
15:21:41 <Twey> I don't understand why bits and pieces of modules make it into the Prelude.  We should have whole modules or nothing at all.  -.-
15:21:50 <monochrom> yes, what arkeet says. study his example carefully.
15:22:14 <Twey> khyperia: Then you just need a unit parameter on empty constructors, like SML
15:22:21 <khyperia> ah
15:22:27 <marx2> > (cos . (sin . cos)) 20
15:22:28 <Twey> khyperia: maybe : (() → b) → (a → b) → Maybe a → b
15:22:29 <lambdabot>   0.9222832389987806
15:22:37 <khyperia> that's a silly solution but it works, haha.
15:22:47 <marx2> > ((cos . sin) . cos) 20
15:22:48 <lambdabot>   0.9222832389987806
15:23:08 <Twey> khyperia: That's only if you care about it being lazy, though.  You still have perfectly functional eliminators if you don't do that.
15:23:11 <marx2> thanks, now it makes sense
15:23:31 <khyperia> yeah
15:24:15 <arkeet> > ($) undefined `seq` ()
15:24:15 <Twey> khyperia: You can do if maybe false (λ_. true) nothing then … else error "Oh no!"
15:24:17 <Twey> Or whatever
15:24:18 <lambdabot>   can't find file: L.hs
15:24:20 <arkeet> > ($) undefined `seq` ()
15:24:24 <lambdabot>   ()
15:24:27 <arkeet> ~~
15:24:28 <monoidal> zennist: you want to compute applySpec (moveSubGroupToGroupAt 0). what is your plan, when l is not Groups l1 l2, so moveSubGroupToGroup does not fit?
15:24:28 <arkeet> !!
15:24:42 <arkeet> I've been lied to all this time. ($) is not id.
15:24:51 <monoidal> that's right.
15:25:13 <countoren> Cale: ok , follow and install all required http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9 . but still installing cabal is failling
15:25:17 <lpaste> countoren pasted “cabal install cabal-install after patching” at http://lpaste.net/96102
15:25:18 <monochrom> > id undefined `seq` ()
15:25:19 <lambdabot>   *Exception: Prelude.undefined
15:25:28 <Twey> Haskell magic
15:25:33 <monochrom> > (id :: Int -> Int) undefined `seq` ()
15:25:34 <lambdabot>   *Exception: Prelude.undefined
15:25:44 <monochrom> no no, not that
15:25:46 <enthropy> zennist: you could get rid of the Rank2Type there... it is only there to restict you and not to make things work it seems
15:25:49 <Twey> Hehe
15:25:56 <monochrom> > (id :: (Int -> Bool) -> (Int -> Bool)) undefined `seq` ()
15:25:56 <lambdabot>   *Exception: Prelude.undefined
15:25:59 <benzrf> hmm
15:26:03 <monochrom> ok, now I'm convinced.
15:26:05 <benzrf> why is there no instance for Eq for funcs?
15:26:06 <arkeet> :P
15:26:14 <arkeet> benzrf: how would you write it?
15:26:15 <benzrf> oh wait that would be useless
15:26:16 <Twey> benzrf: Because it might not terminate
15:26:27 <enthropy> > (\x y -> x y) undefined `seq` ()
15:26:28 <Twey> (probably wouldn't, for most non-trivial functions)
15:26:28 <lambdabot>   ()
15:26:35 <benzrf> i was thinking just compare if they're the same item, then i realized that that is:
15:26:38 <benzrf> - meaningless
15:26:39 <benzrf> - useless
15:26:43 <arkeet> > (\y -> undefined y) `seq` ()
15:26:44 <lambdabot>   ()
15:26:48 <Twey> - not referentially transparent
15:26:53 <zennist> monoidal: about that. In fact I don't care for it to work for general purpose now, I just need it to work for a particular type of (Groups l1 l2) which I've defined in my configuration. That means the Type can be static and can fit into the rank2type criteria
15:26:54 <benzrf> ohh, right
15:26:56 <monoidal> benzrf: however! http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
15:26:57 <Twey> - doesn't respect alpha-equality
15:26:58 <benzrf> hmmm
15:27:04 <Twey> s/equality/equivalence/
15:27:17 <benzrf> you could compare the source code respecting alpha equivalence
15:27:17 <benzrf> :B
15:27:25 <arkeet> however, if the domain is enumerable, then you can compare them!
15:27:30 <Twey> benzrf: What about beta-equivalence?  :þ
15:27:31 <arkeet> (and it'll terminate if the domain is finite.)
15:27:32 <Cale> countoren: It looks like you don't have the clang-xcode5-wrapper binary
15:27:32 <benzrf> [still useless i guess]
15:27:38 <monoidal> zennist: if you're OK with crashing, use unsafeCoerce
15:27:48 <Cale> countoren: i.e. you didn't follow step 1?
15:27:51 <marx2> ChanServ: .oO( ((+10) (sin (cos 20)) would have been a better example )
15:27:56 <countoren> i did
15:27:57 <marx2> s/ChanServ//
15:27:59 <countoren> its there
15:28:05 <countoren> 100% sure
15:28:14 <monochrom> yes marx2
15:28:16 <zennist> enthropy: it doesn't show the use of that on the code here, but in reality it's necessary because the functions that are going to use these functions are not gonna to provide any type signature for the layoutclass so haskell has no way to deduce it except giving it a forall constraint
15:28:18 <Cale> oh, it's "could not execute"
15:28:22 <Twey> benzrf: As arkeet says, you can just compare their values pointwise for finite domains, but that would be horribly slow.
15:28:24 <Cale> Is the file executable?
15:28:29 <chrisdone> ReinH: got one!
15:28:32 <countoren> :/
15:28:38 <countoren> chmod ....
15:28:39 <chrisdone> > let supportsNeg str = if minBound `asTypeOf` r < toEnum 0 then Just r else Nothing where r = read str in supportsNeg "-1" :: Maybe Int
15:28:39 <Cale> chmod +x /usr/local/bin/clang-xcode5-wrapper
15:28:40 <lambdabot>   Just (-1)
15:28:40 <countoren> ?
15:28:42 <chrisdone> > let supportsNeg str = if minBound `asTypeOf` r < toEnum 0 then Just r else Nothing where r = read str in supportsNeg "-1" :: Maybe Char
15:28:43 <lambdabot>   Nothing
15:28:44 <Cale> yeah
15:28:49 <countoren> ok
15:28:52 <Twey> chrisdone: Hell is pretty cool
15:28:52 <countoren> let me see
15:28:54 <chrisdone> ReinH: see ^ a use of asTypeOf that's useful
15:29:09 <chrisdone> Twey: :D
15:29:22 <monochrom> I would be appalled if it's just missing one executable bit
15:30:05 <monochrom> all these cabal hell symptoms and xcode 5 symptoms for just one executable bit :)
15:30:15 <benzrf> heeeyyy, this article's ghci has nifty ascii art, WHY DOESN'T MY GHCI HAVE NIFTY ASCII ART
15:30:27 <enthropy> zennist: why do you say that? When you use `group', there is a concrete type there
15:30:32 <chrisdone> i think ghci used to have nifty art and i forgot that they removed it
15:30:32 <Iceland_jack> The ASCII art makes it run slower
15:30:35 <monochrom> old ghci had nifty ascii art
15:30:47 <Cale> I wonder why it was removed :S
15:30:50 <benzrf> bah
15:30:53 <monoidal> chrisdone: there was a banner on startup (removed in 6.6 or 6.8 afair)
15:30:56 <monochrom> to restore nifty ascii art, try ghc 6.8
15:31:12 <enthropy> hugs has one
15:31:19 * chrisdone makes some “bring back nifty ascii art” t-shirts
15:31:24 <monochrom> ok that does it. try hugs. :)
15:31:32 * BMeph wonders if chrisdone tells anyone that "[he's] coming, and Hell's coming with [him"?
15:31:43 <monochrom> haha
15:31:57 <chrisdone> :D
15:31:58 <zennist> enthropy: yes but when I'm sending messages to the layout e.g. sendMessage $ G.Modify (some expression of type ModifySpec)
15:32:10 <monochrom> when chrisdone's shell is done, we will be saying this to our computers: "cabal install hell"
15:32:42 <chrisdone> ^_^
15:32:54 <monochrom> (yesterday, I already played the "hell.dll" card :) )
15:33:05 <quchen> It's "cabal install cabal-hell", just like it's cabal-install to install cabal. Ish.
15:33:17 <monochrom> that is good too :)
15:33:19 <zennist> in that case the modifySpec is going to reach back to the layout and get executed, and the type signature for that modifySpec is not really decidable
15:33:29 <countoren> Cale: did chmod +x still getting the same error in cabal
15:33:30 <benzrf> are patterns checked in the order given?
15:33:36 <monoidal> benzrf: yes
15:33:43 <benzrf> ok just double checking
15:33:45 <benzrf> :U
15:33:47 <enthropy> zennist: oh I see. You could 1. make that type variable Layout, or you could have a name for your particular group layout and use that to restrict the type of what's inside the G.Modify
15:33:56 <ezyang> Hmm, hackage uploaded packages are not supposed to contain a dist/ folder, are they?
15:33:59 <Cale> countoren: what happens when you try to run it by hand?
15:34:07 <Cale> (I can't try that myself, I'm not on OSX
15:34:09 <Cale> )
15:34:17 <Iceland_jack> benzrf: Try doing f _ = ...; f [] = ...
15:34:23 <Iceland_jack> and see the error messages :)
15:34:29 <chrisdone> i'm wondering if i'll need to upgrade to a curses library to be able to do as-you-type completions
15:34:30 <quchen> Warnings, you mean.
15:34:35 <Iceland_jack> yes
15:34:40 <arkeet> quchen: not with -Werror ;)
15:34:42 <monochrom> runtime error message :)
15:34:46 <countoren> well clang: error: no input files
15:34:48 <chrisdone> could one, e.g., have it so that if i hit " it auto-inserts another and puts me between them?
15:34:49 <zennist> enthropy: good idea. gonna try that in a minute
15:34:50 <countoren> this
15:34:54 <simpson> 1,926,991,919,684,067
15:34:57 <Cale> countoren: hmm, okay
15:35:13 <enthropy> the second one would be if you drop the type signature of applySpec
15:35:14 <chrisdone> haskeline seems not to be able to do it
15:35:17 <simpson> Derp.
15:35:29 <zennist> enthropy: can I easily define a new type for any expression? e.g. data MyLayout = Full ||| Tall
15:35:40 <iron_houzi> Hi. I'm completely new to Haskell and functional programming, but I really want to know if I can use it for my dream project. I want to take the Tibetan language and create google docs for Tibetan. From what I've read, Haskell is brilliant but there are also some limitations where using another language might be better. So I need to know: will Haskell be good for computing language? I'll probably be using
15:35:42 <iron_houzi> alot of tree data structures as well. Is Haskell used for language processing and is it very good for it?
15:35:47 <Cale> countoren: I don't understand why ghc wouldn't be able to execute it, if you can
15:36:16 <countoren> Cale: could be the version?
15:36:34 <enthropy> zennist: no but as seems to have been discussed above, you can have    x = Full || Tall;      (y `asTypeOf` x)  instead of  (y :: MyLayout)
15:36:49 <Cale> countoren: you're still getting the exact same message?
15:36:59 <countoren> Cale: when?
15:37:00 <Cale> countoren: ghc: could not execute: /usr/local/bin/clang-xcode5-wrapper ?
15:37:19 <zennist> enthropy: ok, will try that then
15:37:34 <Cale> btw, you shouldn't really have to cabal install cabal-install if you already have a cabal binary, but it's a reasonable way to test that things are working
15:38:14 <james-sh> I am reading the book "Haskell, the craft of ....  " and it has this question in its exercises. Can anyone help?  The question is : what is the type of function f if  " f $ id "  is properly typed?
15:38:16 <countoren> well it says its not insalled, if i understand correctly
15:38:48 <chrisdone> iron_houzi: i don't know whether it's good for natural language processing, i haven't done that. but it's certainly good at writing parsers, and working with trees
15:38:53 <Cale> cabal-install is installed (it's the program 'cabal' that you're running)
15:39:42 <iron_houzi> chrisdone: Good. Is it good for writing custom font rendering engines and custom typesetting? UTF8.. ?
15:39:42 <countoren> im confused
15:40:17 <countoren> Cabal-1.18.1.2 is ralted to?
15:40:28 <Cale> iron_houzi: Well, it's a general purpose programming language. It doesn't have any features specifically aimed at font rendering or typesetting for instance.
15:41:24 <Cale> iron_houzi: But the text I/O uses UTF-8 by default.
15:41:28 <chrisdone> haskell libraries tend to have no problem with utf8
15:41:45 <countoren> ooo
15:41:52 <countoren> i think i found the dif
15:41:59 <countoren> let me check
15:42:00 <iron_houzi> Cale: I see, but I'm generally asking about how well haskell and functional programming is suited for these specific tasks in general.. From what I understand pure functional programming isn't good for everything. Especially dealing with mutability..
15:42:11 <chrisdone> does anyone know whether Judah Jacobson chats on irc?
15:42:13 <arkeet> haskell is the best imperative programming language.
15:42:18 <iron_houzi> haha
15:42:54 <chrisdone> seriously. i wouldn't want to write imperative code in another language
15:43:08 <khyperia> Oh dear. Particularly nasty @pl, it seems like this should be able to be done with Control.Arrow.first, but I'm not sure how.
15:43:09 <khyperia> @pl (\((x:xs), a) -> (f x : xs, a))
15:43:09 <lambdabot> uncurry (ap (((,) .) . (:) . f . head) tail)
15:43:34 <Peaker> well, when writing imperative code I tend to care *how* it runs :)  Haskell isn't great at that (all GC'd languages aren't great, laziness is bad here too)
15:43:37 <chrisdone> > over _head (+1) [1,2,3] -- wonder whether this is defined
15:43:39 <lambdabot>   [2,2,3]
15:43:42 <chrisdone> it is =)
15:43:49 <Peaker> If I don't care how it runs, why would I use imperative style?
15:44:14 <chrisdone> > first (over _head (+1)) ([1,2,3],())
15:44:15 <lambdabot>   ([2,2,3],())
15:44:42 <chrisdone>  @pl has a limited set of functions that it knows about
15:44:52 <Peaker> I (reluctantly) use C when I care about how the program will run. Haskell when I don't.  Hoping Rust replaces C for me :)
15:44:54 <monoidal> khyperia: ^
15:45:05 <khyperia> right
15:45:08 <khyperia> thanks
15:45:13 <james-sh> I am reading the book "Haskell, the craft of ....  " and it has this question in its exercises. Can anyone help?  The question is : what is the type of function f if  " f $ id "  is properly typed?
15:45:28 <chrisdone> Peaker: i feel like i'd like ATS if the syntax wasn't so gruesome
15:45:29 <monoidal> khyperia: that's with lens; without lens you need to define over _head, probably the simplest way is manual pattern matching
15:45:44 <marx2> is it possible to write a default instance for a type class, that will be used for types that do not implement instances for it?
15:45:51 <monoidal> khyperia: ie first (\(x:xs) -> f x:xs)
15:46:05 <khyperia> yeah, I haven't learned lens yet, I just typed out (first (\(c : cs) -> f c : cs))
15:46:05 <quchen> > over (_1._head) (+1) ([1,2,3],()) -- chrisdone
15:46:07 <lambdabot>   ([2,2,3],())
15:46:10 <Peaker> chrisdone: Yeah. It makes me feel bad that I rule out ATS/Ocaml, but I can't get over it :(
15:46:13 <Cale> james-sh: Well, what's the type of ($)?
15:46:18 <Cale> :t ($)
15:46:18 <lambdabot> (a -> b) -> a -> b
15:46:21 <marx2> I am trying to write a deepseq equivalent that will just do  "x `seq` y" for types that don't implement NFData
15:46:28 <chrisdone> quchen: oh yeah, lenses compose :3
15:46:33 <Peaker> chrisdone: Rust isn't great either, syntactic-wise, but I can live with that badness, I think.
15:46:40 <monochrom> marx2: no, can't be done.
15:46:47 <Cale> james-sh: So, here, a must unify with the type of id which is t -> t
15:46:49 <marx2> x `seq` (), rather
15:47:01 <chrisdone> nod
15:47:08 <monoidal> marx2: I'm afraid the solution is to implement NFData for all types you use.
15:47:13 <chrisdone> Peaker: this http://this-plt-life.tumblr.com/post/41441254767/when-i-checked-out-rust
15:47:13 <Peaker> > _1._head +~ 1 $ ([1,2,3],()) -- quchen, chrisdone
15:47:15 <lambdabot>   ([2,2,3],())
15:47:17 <Cale> james-sh: So if f :: a -> b, and a = t -> t, then f :: (t -> t) -> b for some types t and b
15:47:22 <monoidal> marx2: there might be a way to automatically derive that.
15:47:42 <james-sh> Cale : let me think about what you just said.
15:47:48 <Peaker> chrisdone: :)
15:47:53 <chrisdone> Peaker: (i avoid lens's operators)
15:47:57 <Peaker> chrisdone: I love em :)
15:47:58 <monochrom> x `seq` () is also unlikely to be a right default, even if default is allowed
15:47:58 <enthropy> you can write an overlapping instance NFData a where rnf = a `seq` (), but that can be confusing
15:48:24 <monochrom> time to say: why do the programmers imagine a vain thing
15:48:26 <Peaker> chrisdone: Everyone knows +=, -=, *=, etc.  So they exist for State.   Replace = with ~ for pure functions
15:48:32 <quchen> Peaker: chrisdone got me to like parentheses a bit more. :-)
15:48:37 <marx2> what would be the right default?
15:48:51 <monochrom> I don't know. I guess there is no right default.
15:49:11 <Peaker> quchen: I find it hard to parse nested parenthesis in non-trivial expressions, especially if they span more than 1 line)
15:49:16 <marx2> if x isn't a container like a list or a Map then x `seq` () should work, no
15:49:31 <chrisdone> Peaker: i generally just dislike operators. but they're specializations, to boot. do another operation and your code has to change shape, so i have no love for them
15:49:31 <Twey> iron_houzi: I'm not sure what you're trying to do, but you can obviously do it in Haskell.  For the NLP parts, though, you might want to try something like GF, the Grammatical Framework, which is an NLP/G framework written in Haskell
15:49:40 <Twey> I imagine the interface should be pleasant
15:49:51 <Twey> (if you're doing heavy NLP)
15:50:06 <iron_houzi> Twey: Wow! That looks very interesting!
15:50:10 <Peaker> chrisdone: Well, I don't mind working harder when writing code, to reap a benefit when reading it, even a small benefit
15:50:12 <monochrom> what is "container"? I am serious. you're thinking sloppily, not rigorously, it's why you're likely wrong.
15:50:14 <iron_houzi> Twey: Thank you
15:50:23 <Twey> iron_houzi: No problem
15:50:40 <chrisdone> Peaker: nod, the benefit for me is little
15:50:41 <Twey> GF is cool.  I look forward to having a project where I can play with it.  ☺
15:50:50 <Peaker> chrisdone: I think they're a nice specialization.  The infix parse tree corresponds more closely to its physical layout than the prefix parse tree
15:51:01 <chrisdone> Peaker: i swim in a sea of parens and it warms me like rays of the sun
15:51:22 <marx2> jklfasdj
15:51:27 <edwardk> @remember chrisdone i swim in a sea of parens and it warms me like rays of the sun
15:51:27 <lambdabot> Okay.
15:51:29 <Peaker> chrisdone: Heh)))))))))))))))))))
15:51:34 <quchen> Haha.
15:51:34 <iron_houzi> Somebody on reddit wrote that you shouldn't follow the tutorials on haskell.org. Where does someone who knows a bit of CS along with Java/C/Asm go to find great learning material?
15:51:36 <chrisdone> :-)))
15:51:36 <Peaker> chrisdone: hope you don't get too warm there!
15:51:48 <james-sh> Cale Thanks
15:51:52 <james-sh> got it now
15:52:00 <monochrom> somebody on reddit should shut up
15:52:07 <chrisdone> monochrom: hahaha
15:52:09 * edwardk is going to (start) replying to chrisdone) with unbalanced parens and see how much it unbalances him.
15:52:12 <Twey> Parse trees are for losers.  Real programmers write in RPN.
15:52:24 <Twey> edwardk: This makes me sad.  =(
15:52:28 <quchen> edwardk: My eyes!
15:52:33 <chrisdone> edwardk: hahahaha. i actually read the first part several times before reading the rest. i lol'd
15:52:37 <Peaker> iron_houzi: Learn You a Haskell is considered good, though it might be a little too slow for someone who knows other languages well.  There's "Haskell fast and hard" which might be good for doing it fast and hard :)
15:52:46 <Twey> iron_houzi: The usual recommendation is the book ‘Learn You A Haskell’, or LYAH
15:52:54 <arkeet> chrisdone: haha
15:52:55 <Cale> iron_houzi: http://www.haskell.org/haskellwiki/Tutorials is a pretty reasonable list
15:52:56 <quchen> edwardk: In your devious ways you made too many closing parentheses so you can't fix it with another comment
15:52:58 <quchen> You're the devil
15:52:58 <geekosaur> rpn is just a funny shaped parse tree :p
15:53:00 <Twey> iron_houzi: There's ‘Real World Haskell’ as well.
15:53:07 <monochrom> of all tutorials mentioned on haskell.org, there is about just one that some people say "too hard". and even then I contest that.
15:53:21 <iron_houzi> THanks! Twey: Is real wrold haskell available for free?
15:53:22 <scott_> iron_houzi: I've been following this SO answer a bit: http://stackoverflow.com/a/1016986/1535283
15:53:28 <iron_houzi> Nice
15:53:28 <Twey> iron_houzi: Yes, at realworldhaskell.org/book
15:53:29 <zennist> enthropy: pastebin.com/6hRFhLTR
15:53:33 <zennist> :(
15:53:35 <Peaker> I learned with "Yet another Haskell tutorial" and "Gentle intro" also existed, and I remember disliking them both
15:53:39 <iron_houzi> Oh wow! I'm so excited
15:53:44 <chrisdone> Peaker: me too
15:53:49 <chrisdone> YAHT and Gentle
15:53:49 <Twey> Peaker: Me three
15:53:58 <zennist> coerced the types and all but it still gave me errors...
15:54:00 <Peaker> Friends who tried to learn with RWH said that chapter 7 or so was a bit too forward-referencing, hard to read as a non-Haskeller
15:54:01 <chrisdone> i liked the exercises in YAHT, though
15:54:03 <Twey> One of them had some really terrifying monad tutorials.  I don't remember which.
15:54:07 * geekosaur started from Gentle, it was fine
15:54:14 <chrisdone> Peaker: nod, i've heard that, too
15:54:14 <Twey> But it put me off Haskell for about a year :þ
15:54:21 <chrisdone> haha
15:54:28 <quchen> Twey: "All about Monads" is written to scare people of monads, did you mean that one?
15:54:31 <Cale> I started learning before YAHT existed, and things were even trickier then :)
15:54:35 <Twey> quchen: That might be the case
15:54:48 <chrisdone> actually i think, in my usual impatient bumbling way, i started with Write Yourself a Scheme in 48 Hours, and then only afterwards actually picked up one of the books
15:54:54 <Twey> Cale: You're a mathematician, though — you had an unfair advantage :þ
15:55:01 <Cale> (but Gentle existed)
15:55:05 <marx3> sorry I got disconnected. perhaps I am defining NFdata wrong?  for data Point = Point { x = Int, y = Int }  is p `seq` return () enough or should I do should I do (x p) `seq` (y p) `seq` ()
15:55:24 <Twey> I think I started learning just after YAHT came out — I remember some hype about it.
15:55:25 <edwardk> I know what you're thinking. You're thinking "did he fire six ('s or only five?" Now to tell you the truth I forgot myself in all this excitement. But being this is Haskell, the most powerful language in the world and it will blow you head clean off, you've gotta ask yourself a question: "Do I feel lucky?" Well, do ya?
15:55:27 <monochrom> yes, you should seq x and y too
15:55:36 <Peaker> marx3: foo (Point !x !y) = ... is enough, I think
15:55:37 <Iceland_jack> marx3: You need to seq both x and y
15:55:41 <Twey> edwardk: You missed a ‘punk’
15:55:49 <Cale> edwardk: hahaha
15:55:51 <edwardk> yeah i was dropping punks in there
15:55:55 <Iceland_jack> otherwise you just evaluate to the constructor Point
15:56:01 <Twey> Heheh
15:56:02 <Peaker> I hate "seq", we should encourage ($!) and (!) more and discourage seq
15:56:06 <zennist> monoidal: pastebin.com/6hRFhLTR
15:56:16 <monochrom> I feel lucky that I came across Haskell
15:56:22 <chrisdone> marx3: how about making Point strict, if you're not making use of laziness. then to force Point, you just force the constructor
15:56:23 <marx3> oddly only x `seq` () was enough in my cases (detecting parsing error right away instead of in the middle of the execution)
15:56:24 <zennist> monoidal: this is what I get after coercing types. Still no luck...
15:56:27 <quchen> Peaker: BangPatterns for Haskell 2014!
15:56:32 <Iceland_jack> Peaker: Hate feels like and overly strong emotion for such an innocuous thing :)
15:56:34 <Cale> Peaker: step 1, make ($) and ($!) both left-associative
15:56:35 <chrisdone> data Point = Point { x :: !Int, y :: !Int }
15:56:45 <quchen> Cale: Good luck with that
15:57:00 <marx3> chrisdone I have a list of points, so I think I can't get away without defining NFData
15:57:05 <Cale> (That would make $! actually usable)
15:57:05 <Twey> I kind of wish I'd got into graphics instead.  I feel like I'd have learnt more CS earlier if I'd started with graphics and algorithms instead of jumping head-first into Haskell and type theory.
15:57:11 <benzrf> hey
15:57:12 <Peaker> Iceland_jack: (x+1) `seq` ...    is easy nonsense to write, and    x `seq` foo x    is too frequent and unreadable compared to foo$!x
15:57:24 <Twey> OTOH both these things are fun, if often less immediately practical, so.
15:57:29 <chrisdone> marx3: yeah, but i mean this simplifies the implementation of NFData. you only have to evaluate the constructor
15:57:37 <marx3> ah got it
15:57:41 <benzrf> (Foo a1 b1 c1 d1) == (Foo a2 b2 c2 d2) = [compare each pair of fields]
15:57:47 <benzrf> what's the most idiomatic way to do that?
15:57:58 <Peaker> Cale: well, the problem with the rassoc is annoying parens. but you get annoying parens with `seq` too?
15:58:00 <Iceland_jack> benzrf: deriving Eq?
15:58:12 <benzrf> Iceland_jack: one of the other constructors doesn't allow that
15:58:12 <Twey> benzrf: Just derive Eq; that's the default implementation
15:58:19 <quchen> toTuple (Foo a1 b1 c1 d1) = (a1, b1, c1, d1); a == b = toTuple a == toTuple b
15:58:27 <Cale> Peaker: maybe?
15:58:29 <quchen> If you insist in not deriving.
15:58:34 <monochrom> where would I be, if I hadn't come across Haskell? I would be defending the likes of SML, as Robert Harper does, lunatically rationalizing the violation of the obviously natural Leibniz law.
15:58:48 <Peaker> Cale: I mean, even without ($!) being infixl, ($!) is still a huge improvement over `seq`
15:58:49 <Cale> Peaker: x `seq` f x y
15:58:59 <Iceland_jack> you can also do: and [a₁ == a₂, b₁ == b₂, …]
15:59:00 <benzrf> well one of the other constructors contains a function as a field
15:59:00 <Cale> vs. (f $! x) y
15:59:01 <chrisdone> you guys will notice something oddly missing from this module: https://github.com/chrisdone/hell/blob/master/src/Hell.hs
15:59:04 <benzrf> so i can't derive eq
15:59:06 <benzrf> :\
15:59:11 <monoidal> zennist: sorry I have to go now. I don't have any idea for now, except what I mentioned restricting the type synonym to some context
15:59:30 <quchen> chrisdone: Communist propaganda! Needs more $
15:59:34 <benzrf> g2g, but thanks
15:59:34 <chrisdone> quchen: =p
15:59:54 <Twey> chrisdone: Abstraction over the horrible GHC API?  :þ
15:59:58 <monochrom> chrisdone, does it miss a "main"?
16:00:05 <Peaker> Cale: Yeah, though I think typical examples are: (f $! x) $! y   -- I see your point though
16:00:19 <chrisdone> quchen guessed it. no $ =)
16:00:27 <monochrom> or is it a lack of "heaven" to balance things out?
16:00:31 <Peaker> (and typically "f" and "x" are longer names, making the `seq` further away from its use, obstructing the meaning)
16:00:32 <frxx> benzrf you can't derive it but you can impement it manually (sorry if I am stating the obvious)
16:00:46 <quchen> chrisdone: ($) = id anyway, so you can just leave it away.
16:00:46 <Iceland_jack> > all (uncurry (==)) [(a, a), (b, b), (c, c)] -- ... oh they left
16:00:47 <lambdabot>   True
16:00:49 <countoren> Cale: Man im so sorry :/, I installed clang-xcode into usr/bin instead of usr/local/bin
16:00:53 <Twey> chrisdone: I'm always surprised when you write foo >=> bar instead of ((>=>) foo bar) :þ
16:00:55 <chrisdone> Twey: in this module the ghc api doesn't seem too bad
16:01:00 <countoren> Cale: now its compling
16:01:04 <Cale> countoren: cool
16:01:05 <marx3> it would be nice if we could do data Point = Point Int Int derive NFdata
16:01:17 <countoren> Cale: but realy thanks for the help
16:01:19 <zennist> monoidal: no prob. Thanks so far
16:01:36 <quchen> Twey: (>=>) is more like (.) than like ($).
16:01:45 <quchen> (>>=) is ($).
16:01:47 <chrisdone> indeed
16:01:54 <Twey> marx3: http://hackage.haskell.org/package/deepseq-th-0.1.0.2/docs/Control-DeepSeq-TH.html
16:02:12 <quchen> Now count the ">>=" in chrisdone's code. Result: zero, apart from one instance inside a string.
16:02:23 <chrisdone> apart from apply tricks, $ is almost always "no noes avoid parentheses"
16:02:24 <Iceland_jack> quchen: Inside a string?
16:02:24 <Twey> marx3: data Point = Point Integer Integer; $(deriveNFData ''Point)
16:02:30 <Peaker> quchen: (=<<)
16:02:44 <quchen> Or that.
16:02:51 <marx3> Twey that is great. I have to read more about TH one day
16:02:59 <Twey> chrisdone: I do a refactoring step after I write code where I go through and remove as many brackets as possible.  :þ
16:02:59 <quchen> Iceland_jack: ">>=" is >>= inside  a string.
16:03:05 * monochrom is in cold Canada and needs to warm sea of parentheses too
16:03:11 <chrisdone> Twey: haha. i used to do that
16:03:13 <monochrom> s/ to / the /
16:03:20 <chrisdone> Twey: you do it for aesthetics?
16:03:21 <Iceland_jack> Yeah I get what you meant, it just feels like an odd thing to have in a library :)
16:03:26 <Peaker> chrisdone: do you prefer "do" specialization over (>>= \...) applications?
16:03:27 <Iceland_jack> or code
16:03:41 <chrisdone> Peaker: yeah. you?
16:04:03 <Twey> chrisdone: I guess so, yes
16:04:03 <Peaker> chrisdone: of course :) I'm trying to reverse engineer your preference function for which specializations you like and which you don't :)
16:04:06 <chrisdone> Peaker:  the x <- y syntax is a little annoying to work with
16:04:28 <quchen> <- is nice if you have Functor stuff on the RHS.
16:04:37 <quchen> Otherwise you would need to parenthesize more often.
16:04:43 <chrisdone> Peaker: generally i don't like infix because it creates an overhead for my reading and for editing. it's not really a developed theory, it's just what i find convenient
16:05:06 <lykos_> I'm learning multithreading, how can I block until a thread finishes?
16:05:20 <lykos_> like  t <- forkIO
16:05:38 <lykos_> somefunctionThatBlocksUntilThreadFinishes t
16:05:38 <quchen> To be fair single infix operators are nice (and I think would do Lisp well), but when you're mixing lots of different things and have to worry about fixities parentheses and good indentation are probably more readable.
16:05:42 <Peaker> chrisdone: in Lamdu you might disable the "infix" presentation mode of functions, I guess :P   (you can already choose, per-function, whether it is "infix", "verbose" or "OO" modes of displaying application/arguments)
16:05:46 <chrisdone> Peaker: do is prefix, it's just that x <- y syntax which is a little annoying
16:05:52 <Iceland_jack> lykos_: You take an MVar right after
16:05:55 <quchen> Applicative style sometimes works well with infix. Applicative+Monad mixed is awkward.
16:06:04 <monochrom> lykos_: somewhere on the doc page of forkIO, there is an example, scroll down to find it
16:06:10 <Iceland_jack> and write to it once the you need it
16:06:24 <chrisdone> quchen: yeah, exactly
16:06:35 <Rylee> Hey, anyone know how to fix the "state not initialized" thing with lambdabot's src command by default?
16:06:37 <chrisdone> whenever i have <$> <* and <|> together i start to get lost in precedence and end up inserting parens
16:06:41 <marx3> this is very weird. instance NFData Point where rnf x = ()  is enough to detect parsing errors right away, instead of in the middle of a runtime.
16:06:59 <Iceland_jack> lykos_: it seems like you're possibly looking for something like async or monad-par (or any of the parallelism stuff)
16:07:00 <chrisdone> then i wonder whether it's worth looking up the precedences, and the burden i would be putting on other people
16:07:03 <Iceland_jack> @hackage async
16:07:03 <lambdabot> http://hackage.haskell.org/package/async
16:07:04 <marx3> I am not using strict fields
16:07:05 <Iceland_jack> @hackage monad-par
16:07:05 <lambdabot> http://hackage.haskell.org/package/monad-par
16:07:16 <quchen> chrisdone: <$> *> <* <*> all have the same precedence.
16:07:21 <quchen> And infixl.
16:07:24 <quchen> I think.
16:07:28 <monochrom> lykos_: in fact, look for the exact string "wait for child threads to finish"
16:07:41 <chrisdone> quchen: and then you have to figure out how to lay operators out
16:07:46 <monochrom> or use the async lib, yeah
16:08:08 <quchen> chrisdone: I think that works out nicely here. In particular more readable than parenthesizing.
16:08:08 <chrisdone> Peaker: yeah, i probably would just use a prefix notation
16:08:37 <Twey> I like Lisp's insistence on prefix everywhere, but it just doesn't feel right in Haskell.
16:08:37 <Peaker> chrisdone: What I meant is that in lamdu it's not a matter of choosing different functions, but a manner of choosing a different presentation mode for them
16:08:40 <quchen> If you have sensible operators pointing "hey the data is this way *>" then it would be a shame not to use them! :-)
16:08:40 <chrisdone> quchen: yeah. it's interesting because there's a difference in lisp:
16:08:51 <Iceland_jack> Twey: It certainly simplifies a lot of things
16:08:55 <chrisdone> x*y*z*p in lisp is simply (* x y z p)
16:09:01 <chrisdone> which is /far/ more readable to me
16:09:06 <lykos_> monochrom: Okay, thanks, that works.
16:09:11 <Iceland_jack> fixity is a very annoying thing to have to keep in your mind
16:09:21 <quchen> chrisdone: product [x,y,z,p] is a little noisy too I guess.
16:09:25 <Iceland_jack> lykos_: Do check out async
16:09:29 <countoren> i cant believe it!!! still happens       :/ something is really bad .
16:09:33 <lpaste> countoren revised “cabal install cabal-install after patching”: “cabal install cabal-install after patching” at http://lpaste.net/96102
16:09:43 <chrisdone> Peaker: yeah, i know.  i would use the prefix notation/style/theme/format/layout/whatever/presentation you are calling it
16:09:46 <Peaker> chrisdone: I wonder how many operator-ish-named function applications have more than 2 parameters in Lisp programs
16:09:51 <Twey> I think it's because you *can't* have prefix everywhere in Haskell.  Lots of things (like definitions) are not prefixable.  So mixing the bracketed and unbracketed styles doesn't feel right, so I try to avoid brackets.
16:09:57 <quchen> chrisdone: But now nest expressions: (+ (* 3 2) (/ 4 2) 4 (- 5 3)) -- wat
16:10:08 <lykos_> Iceland_jack: I have, I've been using it in my GTK program, it's very useful
16:10:30 <Twey> Plus the syntactic overhead of the extra brackets in (($) bar baz)
16:10:32 <chrisdone> quchen: my eyes are trained to read parens, so it doesn't matter what you put in them
16:10:37 <Twey> quchen: That's fine for me
16:10:40 <lykos_> I was just curious if there was a specific function that takes a ThreadID and blocks until the thread is done
16:10:41 <Peaker> 3*2 + 4/2 + 4 + 5-3  is nicer, I agree
16:10:44 <Iceland_jack> OK, because the ‘get’ function seems like similar to what you want
16:10:44 <simpson> 2 3 * 4 2 / 4 5 3 - + + + \ What, you don't like Forth?
16:11:03 <chrisdone> quchen: probably arithmetic is the worst examples one can come up with, but for me it's not even that bad. and lispers would normally put those on separate lines in the editor
16:11:04 <Peaker> lykos_: you can spawn an Async instead of a thread, and then you can wait on the Async
16:11:10 <quchen> Peaker: Or a hybrid, (+ (3*2) (4/2) 4 (5-3))
16:11:12 <Twey> simpson: That's better :þ
16:11:20 * geekosaur hands simpson dc
16:11:27 <Twey> I like RPN-style code because I can just read it left-to-right
16:11:38 <chrisdone> quchen: someone proposed that: (+ {3*2} {4/2} 4 {5-3})
16:11:48 <chrisdone> (where { } introduces infix application)
16:11:48 <quchen> With curlies. Yea right.
16:11:49 <monochrom> quchen: "(+ (* 3 2) (/ 4 2) 4 (- 5 3))" doesn't stumb me yet. I admit that something bigger does, but by then I'll use multi-line layout to help me
16:11:52 <Iceland_jack> I think most agree that arithmetic expressions are not as nice to read in Lisp code but at least you never have to doubt your rote memorization of fixity
16:12:11 <chrisdone> Iceland_jack: indeed
16:12:37 <Twey> Iceland_jack: I prefer the Lisp.  There are spacing tricks you can do to indicate fixity in infix notation, like Peaker showed, but that's rather limited once you start mixing more fixities.
16:12:50 <Iceland_jack> Also I recall encountering some operators in strange Haskell libraries that had completely bonkers fixity
16:13:18 <Iceland_jack> sometimes in Haskell the types help you out, but often they don't
16:13:20 <marx3> Iceland_jack do you have an example?  I never think about fixity when defining new operators, but I probably should
16:13:30 <quchen> The *worst* part about fixities is that `infix` functions can have custom ones.  foo $ bar `using` strat -- error
16:13:32 <Twey> Iceland_jack: And when you have a string like 13 <& 94 / 533 /.* 615 +^ 3 it's just untenable
16:13:32 <quchen> ಠ_ಠ
16:13:34 <Iceland_jack> marx3: It was ages ago
16:13:37 <lykos_> Peaker: Okay, that looks good, thanks
16:14:31 <Iceland_jack> exactly, the learning curve of Haskell libraries are imho far higher than equivalent libraries of other languages and this is among the reasons why
16:14:33 <chrisdone> Peaker: i think it's even more relevant for haskell. in lisk (my lisp syntax for haskell), i had it so that (* x y z) would compile to x * y * z, and this is super nice for <*>, e.g. foo <*> bar <*> mu <*> zot becomes: (<*> foo bar mu zot)
16:14:39 <Twey> Aye
16:14:49 <Iceland_jack> ‘Far higher’ is maybe an exaggeration
16:14:53 <Twey> chrisdone: What happened to Lisk?
16:15:05 <quchen> It went to Hell
16:15:10 <Iceland_jack> Also: (< a b c d) == a < b && b < c && c < d
16:15:15 <Twey> quchen: *groan*
16:15:16 <chrisdone> Twey: i realised i'd never be able to use it so it got put to one side
16:15:40 <Twey> Iceland_jack: I don't think so — difficulty of learning a library is my usual explanation for the lack of popularity of Haskell
16:15:54 <Peaker> Iceland_jack: Python uses:  a < b < c < d
16:16:06 <Twey> Learning a library in Haskell is more effort than learning Imperative Algol-Like #332
16:16:17 <chrisdone> Twey: oh, there was a technical reason; ghc's -pgmf flag gives really crappy location information for errors, it supports no source mappings. that needs to be improved before it could be used
16:16:29 <Twey> chrisdone: Oh. =(
16:16:37 <Peaker> Learning a *typical* library in Haskell is actually much easier for me, because of all the types
16:16:40 <Iceland_jack> Yes, Python's solution is not as principled as Lisp's (I believe the operators are actually non-associative?) but it is very readable
16:16:50 <Peaker> Of course, learning "lens" or some other game changing libraries is not easy. But that's more like learning a new language
16:16:52 <Twey> Peaker: Sure, but most of the interesting libraries are not typical :þ
16:16:57 <chrisdone> you get messages like /tmp/ghcx87ys.hs:2432:2: unexpected blah …
16:17:07 <Peaker> Twey: Most libraries we want to learn and use are not "interesting" in that sense
16:17:08 <Twey> HXT, Lens, FRP, Yesod, Hakyll…
16:17:16 <enthropy> chrisdone: can you insert {-# LINE #-} into the output of your preprocessor?
16:17:25 <Twey> Happstack
16:17:43 <chrisdone> enthropy: i heard about that more recently, which i think is supposed to help with that part
16:17:53 <enthropy> that should work, considering that other preprocessors do that
16:17:53 <Peaker> Twey: FRP libs are easy from the types, IME.  I don't know HXT/Yesod/Hakyll/Happstack, I don't do webdev
16:18:01 <chrisdone> enthropy: haven't tried it, though
16:18:01 <Iceland_jack> Since I'm on a rant I feel I must mention people misusing type classes in libraries :)
16:18:14 <countoren> i have played with that all day , im starting to lose hope , cant get cabal install cabal-install ...  http://lpaste.net/96102
16:18:26 <countoren> any help?
16:18:38 <Iceland_jack> Simple things become something like:
16:18:38 <Iceland_jack>     instance Encryptable AES128
16:18:38 <Iceland_jack>     instance Encryptable AES...
16:18:38 <chrisdone> yesod's types are quite large and hard to understand, like lens's, and for the same reason
16:19:06 <Peaker> countoren: #haskell-overflow ?
16:19:22 <Twey> Peaker: It's just that each one requires you to learn not just an API but whole new concepts.  FRP is probably the easiest of them, but then Hakyll/HXT require arrows, Lens requires… everything :þ, Yesod has tonnes of TH everywhere and also uses typeclasses in some very interesting ways, …
16:19:23 <edwardk> well, yesod does a lot of ad hoc overloading for usability's sake, that makes inference suffer here and there, but yes, both have big scary types
16:19:24 <countoren> Peaker: what is that?
16:19:29 <Peaker> countoren: not sure debugging cabal/ghc-pkg errors is that interesting for #haskell :)  It's a different channel
16:19:40 <countoren> o
16:19:42 <countoren> sry
16:20:10 <quchen> Twey: I think Lens doesn't have arrows because of Schahaf's strong lobby. :-P
16:20:22 <Twey> It's one of the strengths of Haskell that it allows such powerful and distinct APIs for library designers, but it comes at the price of learning a new set of idioms every time you pick up a new library
16:20:24 <edwardk> we have one arrow combinator in there, maybe 2 now
16:20:29 <Peaker> Twey: I believe arrows (At least as in Control.Arrow) are just a mistake.. so I don't consider those.  Lens is a huge set of new concepts, and obfuscatingly-generalized types for everything
16:20:31 <Iceland_jack> Twey: Well put
16:20:48 <Twey> Whereas in e.g. Java or Python, you learn one set of idioms once and then you just have to remember the method names and relevant objects for the API
16:20:50 <chrisdone> true enough
16:20:53 <Iceland_jack> It feels similar to the alleged problem of Lispers “macros are too powerful and result in everyone creating their own language”
16:20:57 <chrisdone> everywhere you turn there's a new concept
16:21:00 <edwardk> i largely agree with peaker there
16:21:02 <Twey> Peaker: Yes, I agree
16:21:30 <Peaker> countoren: you can /join #haskell-overflow and I'll try to help with the package problems
16:21:31 <NemesisD> ugh, so annoying that ghcmod puts compile errors *below* hlint errors
16:21:37 <Iceland_jack> Not everything has to be an EDSL with fancy types but those are the interesting parts of Haskell :)
16:21:53 <Twey> Iceland_jack: And so they inevitably make their way into the useful parts of Haskell :þ
16:22:01 <chrisdone> although there *is* a difference
16:22:16 <chrisdone> in java when i spend hours wrapping my head around an API, and finally i get it. i don't feel good. i just feel annoyed
16:22:23 <countoren> Peaker: ok just type the command from here?
16:22:27 <quchen> Twey: I held it back a couple of days now, but I simply have to compliment you for the correctness of this smiley.
16:22:35 <chrisdone> when i do the same in haskell, i feel happy at the end, most of the time
16:23:03 <Twey> quchen: Haha, thank you.  :þ
16:23:25 <chrisdone> although i do get annoyed when a library has no examples. an example is usually the stepping stone from "what the hell is all this crap?" to "oh, the types make sense now"
16:23:28 <Twey> chrisdone: Yes, that's because you're actually learning a new way of looking at things rather than just memorizing the correct sequence in which to instantiate a bunch of classes
16:23:40 <Iceland_jack> chrisdone: I'm far more familiar with Haskell than e.g. Python but I can generally figure out how to use any given Python library without much mental lifting, I cannot say that I feel happier when learning how to use Haskell libraries
16:23:42 <edwardk> chrisdone: i've noticed that examples help. i'm trying harder to add them nowadays =)
16:23:45 <Twey> The former is a much more rewarding (and challenging) experience
16:23:57 <chrisdone> edwardk: =)
16:24:01 <Twey> Examples definitely help
16:24:18 <Twey> Interactive examples are the best
16:24:36 <Iceland_jack> Having the library author on IRC is even better :)
16:24:44 <Twey> Well, that never hurts :þ
16:24:58 <Saizan> just don't pretend examples are a good substitute for a spec
16:25:00 <Peaker> Iceland_jack: I am familiar with Python and Haskell, and for most libraries (the ones of the "boring" kind), I find Haskell is far nicer because of the type-documentation..
16:25:14 <Twey> Saizan: It's okay, we have types for that :þ
16:25:29 <chrisdone> case in point -- the ST monad
16:25:40 <quchen> I've worked with a couple of libraries without docs. Man was I happy for having types in Haskell.
16:26:08 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
16:26:22 <chrisdone> ^ this page doesn't really tell you how to use this module
16:26:26 <Iceland_jack> Peaker: Possibly, 90% of the time when you want a library you only need 10% of its functionality and I feel other languages do a better job of making that portion easier
16:26:30 <Twey> quchen: I've been coding C++ over the last couple of days and I've been repeatedly finding that just reading the source tends to be better documentation than trying to figure things out from the generated docs
16:26:44 <Peaker> Iceland_jack: I disagree. Types let me pinpoint on the part that I need, and see which parts I can safely ignore
16:26:48 <chrisdone> you need ST refs or arrays to actually make use of it, but it doesn't say that. doesn't even link to them
16:26:54 <Peaker> Iceland_jack: also see what kind of error handling I'm expected to do, etc, easily
16:27:11 <quchen> Twey: Not sure whether you meant that in favour of C++.
16:27:18 <Iceland_jack> Peaker: Sure, types are nifty but sometimes the types are needlessly complicated: especially for the “most important” usage
16:27:18 <Peaker> Iceland_jack: with Python, you have to do a lot of trial&error, or read free-form documentation, both are harder -- and at the end you might be left with ambiguities, not knowing whether something can fail or not, etc.
16:27:21 <quchen> I'm going to guess not.
16:27:57 <chrisdone> Iceland_jack: i guess hakyll is an API that i didn't feel happy about learning. especially the arrows version. it felt like i was learning jasper's novel experiment with arrows, rather than just trying to generate a blog, which is a trivial task
16:28:09 <Twey> quchen: More against C++ documentation
16:28:12 <Peaker> Iceland_jack: http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson.html#v:decode  <-- nicer than Python land IMO
16:28:26 <quchen> Twey: That's a problem with people, and not C++, though.
16:28:49 <prooftechnique> chrisdone: What do you use?
16:29:02 <quchen> Twey: A related problem are the "Haskell types are enough documentation" folks. And the "good code is self-documenting" people. Arrrgh.
16:29:03 <Twey> quchen: Modern (post-2011) C++ lets you put most interesting information in the types, but there's a lot of legacy C++ code around still.
16:29:23 <Iceland_jack> Peaker: Even with Strings/ByteStrings/Text?
16:29:28 <chrisdone> prooftechnique: regrettably, hakyll. at some point i might just cook up my own just for my blog
16:29:41 <Twey> Haskell types *can* be enough documentation… if you are very careful (Agda-style) about making your functions type-correct, and name your types appropriately
16:29:52 <Twey> (per-function documentation, that is)
16:29:57 <Peaker> Iceland_jack: of course, the types tell me everything, instead of reverse engineering a bunch of examples in the Python docs
16:29:59 <Jesin> What is the recommended method for converting between Char and Word8 ?
16:30:03 <quchen> Twey: forall vs. exists :-þ
16:30:03 <Peaker> Iceland_jack: and still not knowing what kind of errors are possible
16:30:08 <quchen> (Note my new autoreplacement smiley!)
16:30:13 <Twey> quchen: Aye, indeed
16:30:13 <ion> jesin: What encoding do you want?
16:30:20 <Peaker> Jesin: Char and Word8 have very different value ranges..
16:30:26 <scott_> Jesin: Haskell Chars can be larger than 8 bits
16:30:30 <Iceland_jack> Peaker: If you're not familiar with the library usage at all and not very good at Haskell, (.!=) ∷ Parser (Maybe a) → a → Parser a is going to scare you away
16:30:31 <Iceland_jack> promise
16:30:36 <Twey> quchen: You are the fourth person I've converted! (though I recommend against autoreplacement, which is hideous)
16:30:53 <chrisdone> ヽ (＾▽＾) ﾉ
16:30:58 <Jesin> hm, I dunno.  I suppose ASCII would probably be fine?
16:30:58 <quchen> ლ(ಠ益ಠლ)
16:31:06 <Twey> Jesin: ‘Don't do it’ :þ   A Haskell Char is actually a character, not a byte
16:31:12 <Twey> (well, a codepoint anyway)
16:31:21 <Jesin> yeah, ok.
16:31:35 <Twey> Jesin: If you want bytes you should encode your string into some encoding
16:31:37 <ion> jesin: Converting Char to ASCII would be lossy. You’ll probably want an encoding of Unicode, such as UTF-8.
16:31:55 <chrisdone> Jesin: is your Char known to be in the ascii range?
16:32:06 <quchen> Data.ByteString.Encoding provides a way of converting Char to (multiple) Word8.
16:32:31 <enthropy> > toEnum 500 :: Word8
16:32:32 <lambdabot>   *Exception: Enum.toEnum{Word8}: tag (500) is outside of bounds (0,255)
16:32:33 <Jesin> well
16:32:57 <quchen> > (250 :: Word8) + 250
16:32:58 <lambdabot>   244
16:32:59 <quchen> :-D
16:33:05 <quchen> There you go, 500.
16:33:18 <Peaker> Iceland_jack: It took me 20 sec to decipher that one, rather than the usual few seconds :)
16:33:26 <Peaker> Iceland_jack: because I didn't use the Parser type yet, so I had to go read what that was about
16:33:47 <Peaker> Iceland_jack: but the nice thing is I just looked at how the types fit the API parts together and realized what that does
16:34:04 <ion> λ> (Data.ByteString.unpack . Data.Text.Encoding.encodeUtf8 . Data.Text.pack) "ಠ"
16:34:06 <ion> [224,178,160]
16:34:23 <quchen> Oh, encoding is in Text, not ByteString? Pardon
16:34:35 <Iceland_jack> Peaker: I'm a huge fan of Haskell, types are fantastic for a lot of reasons: but there is much room for improvement for making more nonbasic things easier
16:34:58 <Twey> Iceland_jack: Like what?
16:35:53 <Iceland_jack> I'm not a fan of some of the practicies that permeate the Haskell culture
16:35:56 <quchen> Haskell has a barrier-to-entry problem I guess. When you're just starting off you don't want to see "map :: Functor f => (a -> b) -> f a -> f b", although when you're experienced that would be quite nice.
16:36:32 <quchen> Iceland_jack: Like what?
16:36:58 <Iceland_jack> but some of the changes are also technical, there are many new concepts and the good ones will slowly emerge
16:37:00 <Twey> quchen: IMO the biggest problem with that type is the name ‘functor’
16:37:08 <quchen> Twey: How so?
16:37:09 <scott_> Racket's idea of multiple versions of the language for teaching which are progressively more complicated is interesting
16:37:21 <chrisdone> functor's an overloaded term in the programming world
16:37:43 <quchen> Functor is like Matrix. Everything in science+math has it, and it means completely different things.
16:37:44 <chrisdone> in c++ it means bashing rocks together, in ocaml it means modules or something?
16:37:54 <Twey> quchen: The type is quite obvious… if you know what a functor does.  The difficulty is mainly in the confusion generated by the concept of functors, rather than the type itself.
16:38:08 <Iceland_jack> quchen: Operator names, needlessly using type-system features, valuing short code over legibility, ...
16:38:11 <Twey> quchen: What other meanings of ‘matrix’ are there?
16:38:17 <scott_> There could be a "LearningHaskell" language where map :: (a -> b) -> [a] -> [b], but in regular Haskell, map :: Functor f => (a -> b) -> f a -> f b
16:38:24 <Twey> (other than the linear algebra ones)
16:38:25 <Peaker> Iceland_jack: I agree with that, I just don't think that "boring" libraries are hard to learn in Haskell, and I like learning them more than I liked learning Python libs
16:38:40 <quchen> Twey: I read LYAH and from the first second on I imagined Functor as "something you can map over".
16:38:45 <Twey> scott_: There is already a ‘basic Prelude’.  I imagine (or hope) that's how the language will evolve.
16:38:47 <chrisdone> i've never agreed with the fmap-map "better for newbies" stuff
16:39:08 <Twey> quchen: From that point your map isn't very scary any more, surely :þ
16:39:15 <Jesin> WAIT
16:39:17 <Jesin> actually
16:39:21 <Jesin> http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.0.2/Data-ByteString.html
16:39:23 <Bor0> I prefer "map :: Functor f => (a -> b) -> f a -> f b". I don't/didn't know what Functor means/meant, but I always was interested to explore more
16:39:52 <Iceland_jack> Bor0: Have you used it with that type signature? :)
16:40:09 <Jesin> it looks like ^ that provides IO operations that return ByteStrings, together with unpack :: ByteString -> [Word8]
16:40:16 <Jesin> yay
16:40:18 <Bor0> not yet I think, but I am still a haskell newbie :)
16:40:20 <quchen> > fmap (++ "world!") (Just "Hello, ")
16:40:21 <lambdabot>   Just "Hello, world!"
16:40:33 <Iceland_jack> In what way do you prefer it then?
16:40:52 <Bor0> it makes me want to learn and explore more
16:41:02 <quchen> Jesin: ByteString is basically an efficient implementation of [Word8]
16:41:08 <merijn> Jesin: Relatedly, there's ByteString -> Text decoding functions
16:41:09 <Twey> Jesin: Yes, because a ByteString is ba… never mind :þ
16:41:14 <Bor0> "what on earth does that represent"
16:41:16 <Iceland_jack> Yes but the reason why map isn't fmap by default is not because the authors didn't want people to learn more
16:41:26 <merijn> Twey: What? ByteString bad? ByteString is great!
16:42:27 <chrisdone> Iceland_jack: map and fmap is like having return :: a -> IO a and mreturn to me
16:42:28 <Bor0> all I know that everything before => is a class constraint (this is from the LYAH book), now I need to go deeper with that
16:42:28 <merijn> Especially if Jesin was asking to convert Char to Word8, as that implies he wants to work with binary data, in which case ByteString is obviously the right choice
16:42:29 <Twey> Hehe
16:42:41 <Jesin> ... I was initially surprised ByteString wasn't a Functor, but I guess that's because Functor needs to be a container for arbitrary types
16:42:47 <Iceland_jack> chrisdone: I wasn't advocating either way
16:42:51 <chrisdone> Iceland_jack: by the same argument made for map/fmap, you can argue that IO is the most common monad and one that newbies encounter first
16:42:54 <Twey> merijn: I was halfway through typing almost the exact thing quchen sent.
16:42:57 <quchen> Jesin: Right. ByteString has its own "map" function.
16:43:10 <quchen> Twey: Tardis monad, ha!
16:43:11 <merijn> Jesin: Yeah, it's because ByteString has no type argument that can change
16:43:21 <enthropy> chrisdone: do you use classy-prelude or similar?
16:43:24 <merijn> Jesin: But there's maps and fold build in
16:43:33 <donri> Jesin: there's Each in lens though
16:43:34 <chrisdone> enthropy: not by choice
16:43:54 <enthropy> well type errors that would be simple are not as simple when you use such a thing
16:44:14 <Twey> Jesin: ByteString is a MonoFunctor: https://hackage.haskell.org/package/mono-traversable-0.1.0.0/docs/Data-MonoTraversable.htmlk
16:44:18 <Twey> Er
16:44:21 <Twey> Jesin: https://hackage.haskell.org/package/mono-traversable-0.1.0.0/docs/Data-MonoTraversable.html
16:44:34 <Iceland_jack> ah the famed htmlk :)
16:44:37 <quchen>  > mofu
16:44:39 <quchen> WHO DID THAT
16:45:12 <Iceland_jack> Are you an element of this type family mofu?
16:45:19 <enthropy> the snoyman
16:45:37 <quchen> That's almost as bad as calling your program Stalin or your Raspi distro Pidora
16:46:06 <udevd> how can i see where my program halts? does GHC support gnu debugger?
16:46:08 <Peaker> Iceland_jack: I think what can make Haskell easier for beginners is a good IDE that takes the abstract type system and makes it concrete, with immediate feedback, and smart guidance based on the types
16:46:13 <Jesin> hm, where would I find the Text type?
16:46:15 <quchen> Oh, there's also "mofo" in the lib. Haha
16:46:26 <Peaker> Jesin: in the Data.Text module, inside the "text" package
16:46:40 <merijn> Peaker: Why, it seems almost like you're selling an idea there ;)
16:46:45 <Iceland_jack> Peaker: Yes, mostly I think of Haskell as a melting pot of ideas most of whom are very exciting
16:47:12 <zomg> quchen: took me a moment to realize what you were talking about with mofu, because I just thought of the japanese onomatopoeia for "fluffy" :P
16:47:21 <Jesin> Iceland_jack: "whom", heh
16:47:26 <quchen> onomatoopa-what?
16:47:45 <Iceland_jack> Jesin: Most of which? Not a native speaker :)
16:47:46 <zomg> A word that phonetically imitates or suggests the source of the sound that it describes.
16:47:49 <zomg> - wikipedia
16:48:07 <quchen> And fluffiness has a sound in Japanese?
16:48:11 <zomg> Apparently
16:48:23 <Peaker> merijn:  :-)
16:49:15 <quchen> Peaker: Are you working for FPComplete as well?
16:49:44 <Peaker> quchen: nope
16:49:47 <quchen> Ah wait
16:49:49 <quchen> Lamdu
16:49:53 <Twey> quchen: Mofumofu… desu
16:50:08 <quchen> Getting a s t a b
16:50:17 <quchen> i m a s t a b u
16:50:35 <chrisdone> Setting u w o t
16:50:36 <monochrom> E IE IO
16:50:52 <Jesin> Iceland_jack: usually the word would be "which", though if you wouldn't mind conversing with ideas and treating them as people, you can use "whom"  ^_^
16:51:18 <Iceland_jack> Ideas are better people than people are
16:51:54 <quchen> This channel will not tolerate redundancy in this channel!
16:52:17 <enthropy> quchen: http://hackage.haskell.org/package/HList-0.3.0.1/docs/Data-HList-Labelable.html#t:Labelable
16:52:40 <monochrom> polymorphism has dinner with referential transparency
16:52:46 <quchen> enthropy: Oleg.
16:53:03 <quchen> I like the instances.
16:53:23 <monochrom> free theorems want to be free
16:53:35 <quchen> Does anyone recall the module that has 4 lines of type sigs?
16:53:37 <hpc> i fight for the theorems?
16:53:47 <quchen> It was about linear algebra I think, or arbitrary precision floats
16:54:10 <enthropy> oh documentation there is a bit out of date since there was an n in there at one point
16:54:29 <thoughtpolice> http://hackage.haskell.org/package/sessions-2008.7.18/docs/Control-Concurrent-Session.html is the best
16:54:41 <quchen> You win, sir
16:55:42 <quchen> I guess conclusively documenting that would make Hackage's harddrives overflow
16:55:54 <monochrom> haha
16:56:15 <chrisdone> i wonder whether Session would benefit from constraint kinds now
16:56:25 <enthropy> the core ideas tend to be simple... just the implementations never end up being
16:56:26 <chrisdone> a lot of those types could probably be abstracted with names
16:56:33 <quchen> Welcome to the popular Haskell game show "find the =>"
16:56:38 <codygman> thoughtpolice: That scares me
16:56:46 <quchen> It's like Where's Waldo, just harder
16:57:37 <codygman> LOL
16:58:17 <triliyn> I see so many people using functional dependency type classes and I always feel like type families would be nicer
16:58:31 <triliyn> Am I missing something or are functional dependencies so common just for historical reasons?
16:58:45 <chrisdone> they were just availlable before associated types were
16:58:58 <FireFly> thoughtpolice: whaaa.
16:58:59 <triliyn> Okay, I kind of expected that
16:59:47 <quchen> chrisdone: Associated types? Is that what type families are?
17:00:08 <triliyn> quchen: as I understand it, associated types, type functions, and type families are all the same thing
17:00:27 <FireFly> thoughtpolice: I wonder whether that would be easier or harder to read with single-letter variable names. probably harder
17:00:30 <jmcarthur> quchen: associated type families are type families that are associated with type classes
17:00:36 <triliyn> Or at least they are all enabled by the type families extension
17:01:03 <quchen> jmcarthur: Ah, but you can have type families outside of classes, and those are "unassociated" then?
17:01:26 <thoughtpolice> triliyn: internally, they all basically desugar to the same thing, but there are Real Differences too. there are cases where the amount of instances you may be forced to write due to mechanical translation from FDs -> TFs is pretty bad
17:02:08 <chrisdone> quchen: there seem to be many names people use… the literature calls them associated types, because that seems to be the key innovation, type families associate types with other types
17:02:11 <enthropy> triliyn: fundeps can be much shorter since in  `| a -> b c, b a -> c, ... ' each bit between commas would have to be a separate type family
17:02:48 <quchen> Bor0: succ is part of the Enum typeclass.
17:02:56 <enthropy> actually I think something like   `a -> b c' would translate to     type GetB a; type GetC a
17:03:12 <triliyn> enthropy: if you actually want a multi-paremeter typeclass, then maybe. But it seems like if you just want to define type-level boolean logic, type functions are much better than defining a Not typeclass
17:03:38 <enthropy> sure
17:03:41 <Jesin> hm
17:03:51 <Jesin> http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.0.2/src/Data-ByteString-Lazy.html#filter
17:04:00 <thoughtpolice> triliyn: sure, but it cuts both ways. for some things FDs are much more concise, where some things are also much better expressed with a type family
17:04:06 <thoughtpolice> (like naturals, or booleans or something)
17:04:14 <triliyn> Functional dependencies are great if you actually want a typeclass; type functions are nicer if you want to define functions at the type level
17:04:20 <Jesin> I'm curious why that's "filter p s = go s" instead of "filter p = go"
17:04:23 <triliyn> Which I suppose is as you'd expect
17:04:33 <thoughtpolice> in practice i find i only use type-families outside classes and FDs on classe.
17:04:47 <heatsink> Jesin, go calls itself with a different argument
17:04:47 * Jesin learning about GHC's inlining
17:04:51 <triliyn> Is it possible to use FDs outside of type classes?
17:04:55 <heatsink> so it's value is not always s
17:05:04 <khyperia> why is this so horrendous?
17:05:05 <khyperia> (\x y z -> x : y : z)
17:05:07 <khyperia> oops
17:05:08 <thoughtpolice> well, i just mean i don't really use type families as part of a class, i.e. i always use FDs
17:05:09 <khyperia> @pl (\x y z -> x : y : z)
17:05:09 <lambdabot> (. (:)) . (.) . (:)
17:05:11 <quchen> Jesin: Right, I think it's an inlining thing. Although for inlining I would expect it to be point-free. Hmm.
17:05:19 <Peaker> heatsink: it's just eta expanded
17:05:24 <chrisdone> quchen: http://www.cse.unsw.edu.au/~chak/papers/CKP05.html http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html
17:05:27 <Jesin> heatsink: yeah, but the value of "filter p" is always semantically equivalent to "\s -> go s"
17:05:44 <Bor0> what's go do?
17:05:44 <geekosaur> triliyn, no
17:05:48 <heatsink> Oh, you mean instead of writing filter p = go ?
17:05:54 <Jesin> heatsink: yep
17:06:06 <quchen> chrisdone: Thanks, I guess.
17:06:08 <chrisdone> quchen: the idea came after a paper was published comparing generic programming features across languages, and showed that haskell was lacking in this place that c++ was doing okay, and i think scala, too =)
17:06:26 <Jesin> replacing "filter p s = go s" with "filter p = go" would not alter the semantics of the program at all, just the inlining.
17:06:51 <triliyn> thoughtpolice: I guess what bothers me is just that I always see FDs used to implement type functions
17:07:08 <triliyn> I don't think I've ever noticed them being used for an actual typeclass with useful operations
17:07:10 <heatsink> Writing fully applied function calls is considered good programming style.
17:07:18 <chrisdone> quchen: i guess you already knew that =)
17:07:24 <triliyn> (Probably just because I haven't read enough libraries)
17:07:27 <quchen> chrisdone: No, I did not
17:07:38 <thoughtpolice> triliyn: you can find plenty in lens :P
17:07:44 <Jesin> oh, interesting @ chrisdone
17:08:01 <thoughtpolice> but yes, for a lot of actual cases of writing *operations* i find type families far more legible. they also got a lot better with 7.8 as well
17:08:20 <codygman> heatsink: are you saying that "filter p s = go s" is good and "filter p = go" is bad?
17:08:22 <Jesin> heatsink: ... There is a type signature right above the function, so I don't see how it could possibly be confusing.
17:08:29 <thoughtpolice> so we can actually finally implement type-level equality, etc.
17:08:29 <quchen> thoughtpolice: Speaking of 7.8, any estimates? :-)
17:08:39 <chrisdone> i think i actually have a link to that paper, too, somewhere
17:08:40 <thoughtpolice> quchen: i'm trying to do a branch this weekend and clean some stuff up.
17:08:51 <quchen> So this year is still in scope?
17:09:02 <thoughtpolice> yes
17:10:02 <Jesin> Actually
17:10:32 <Jesin> Same question for foldl: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/src/GHC-List.html#foldl
17:10:51 <chrisdone> hm, i don't have that paper. but there is a related one comparing c++ with haskell's type classes http://sms.cs.chalmers.se/publications/papers/2008-WGP.pdf
17:11:19 <Jesin> why "foldl f z0 xz0 = go z0 xs0", not "foldl f = go"?
17:11:30 <Jesin> derp I meant to write
17:11:33 <Jesin> why "foldl f z0 xs0 = go z0 xs0", not "foldl f = go"?
17:11:44 <quchen> Jesin: foldl doesn't fuse well anyway I think, so it doesn't really matter.
17:12:41 <Jesin> "-- We write foldl as a non-recursive thing, so that it can be inlined, and then (often) strictness-analysed, and hence the classic space leak on foldl (+) 0 xs"
17:12:53 <quchen> The end of that sentence is
17:13:07 <Jesin> I know, that's what the file says though.
17:14:17 <heatsink> codygman, Jesin, partial applications take more steps for people to think about and for the program to execute.
17:14:57 <heatsink> I think GHC would eta-expand cases like filter p s = go during optimization
17:15:20 <chrisdone> sure
17:17:45 <heatsink> To be pedantic, the body of let f x = 1 + x contains two function calls because (+) is curried.  But it's awkward to think about addition that way.
17:18:06 <heatsink> And I'm pretty sure people would mentally expand let f = (1 +) into let f x = 1 + x
17:18:08 <Peaker> heatsink: "function calls" are an operational term. Better to say "function applications"
17:18:19 <heatsink> okay
17:18:21 <Peaker> heatsink: there may be no function call at all eventually
17:18:37 <Jesin> <heatsink> I think GHC would eta-expand cases like filter p s = go during optimization
17:18:45 <Jesin> it'd be "filter p = go"  <_<
17:18:48 <Jesin> but yeah
17:20:04 <Jesin> as for "partial applications take more steps for people to think about", this is irrelevant in a file that uses worker functions and even UNBOXING in order to speed things up.
17:21:26 <Jesin> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/src/GHC-List.html#length <-- this uses unboxed Ints and appears in the same file as that foldl implementation.
17:25:41 <heatsink> Operationally, this indicates that 'filter' should begin executing after it receives all its arguments
17:25:52 <heatsink> That is, the pattern filter p s = ... indicates that
17:27:07 <heatsink> The pattern filter p = ... says that filter should begin executing after it receives one argument, and its result is given by "let ... in go".
17:29:20 <heatsink> So the execution of 'filter p = ...' is interleaved with the calling code, making it harder to reason about whether its implementation is fast.
17:33:00 <heatsink> It looks like function definitions aren't saturated consistently.  group and groupBy are partially applied.
17:42:56 <NemesisD> lol achievement unlocked. accidentally asked a question about Pipes in #linux, they answered assuming I was talking about shell, their answer worked in Pipes
17:43:08 <chrisdone> lol
17:43:09 <arkeet> haha
17:43:13 <heatsink> wow
17:43:15 <chrisdone> what was the question and answer?
17:43:20 <Iceland_jack> I'd like to know as well
17:43:59 <NemesisD> the question was if there was a way to get a pipe to print out the contents from upstream and continue forwarding it
17:44:05 <NemesisD> the answer was tee which is in Pipes.Prelude
17:44:09 <arkeet> :p
17:44:10 <Iceland_jack> haha
17:44:11 <Tekmo> I'm here again!
17:44:25 <Tekmo> Did you get the parsers changed to attoparsec?
17:44:34 <Iceland_jack> tee should absolutely get more attention
17:44:41 <NemesisD> Tekmo: we just empirically certified Pipes for compliance with the UNIX philosophy
17:44:42 <Iceland_jack> both in Pipes and shell
17:44:44 <Tekmo> Haha
17:44:51 <Tekmo> Yeah, tee is useful
17:45:05 <Tekmo> It is actually even better if you leave something as an `Effect` when possible
17:45:21 <Tekmo> Because then you can decide on the fly whether it should be a `Consumer` or `Pipe`
17:45:29 <Tekmo> `tee` is a rather blunt hammer
17:45:53 <NemesisD> Tekmo: yeah i got it actually compiling now. the tests for my parser work, but the parse is failing so i think it might be getting an empty string
17:46:08 <Tekmo> Paste the code and I will take a look at it
17:46:34 <NemesisD> sec i'm going to get it up on github
17:46:39 * hackagebot shelly 1.3.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.3.2 (GregWeber)
17:47:31 <chrisdone> Tekmo: would your shell be based on pipes? =)
17:47:40 <Tekmo> I'm still not sure
17:47:51 <Tekmo> So, let me clarify
17:47:58 <Tekmo> I recently discovered a way to fix conduit to make it a proper category
17:48:05 <arkeet> make a shell based on machines
17:48:10 <Tekmo> This basically involves adding the ability to propagate leftovers further back upstream
17:48:22 <Tekmo> The whole thing is correct-by-construction and pretty beautiful
17:48:41 <quchen> What do you mean with "conduit" here?
17:48:44 <Tekmo> You can find it here: http://lpaste.net/96042
17:48:51 <Tekmo> I mean the parsing part of conduit
17:48:55 <Tekmo> Not the finalization stuff yet
17:48:57 <NemesisD> i ought to look more into correct-by-construction WRT haskell
17:49:15 <Tekmo> It's basically a reimplementation of the parsing subset of conduit using `pipes` that gets all the category laws correct-by-construction
17:49:21 <Tekmo> I just got through proving them a couple of days ago
17:49:23 <hpc> NemesisD: you can't really go very far with it
17:49:55 <Tekmo> So anyway, back to chrisdone's question about the shell
17:49:57 <hpc> haskell is turing complete, which is programmer language for "inconsistent"
17:50:30 <Tekmo> If I were to implement a pipes-based shell, it's not clear to me whether I'd use the "conduit implemented using pipes" as the category or the simpler vanilla-pipes category
17:50:37 <NemesisD> Tekmo: here's the guts of it https://github.com/MichaelXavier/haproxy-haskell/blob/master/src/System/HAProxy/Commands.hs#L55
17:51:05 <NemesisD> ignore the commented type signatures, they are liars
17:51:29 <Tekmo> NemesisD: Okay, I can immediately see one potential problem, which is the `map decodeUtf8`
17:52:10 <Tekmo> That won't work if the bytestring chunk boundaries are in the middle of encoded characters
17:52:19 <NemesisD> Tekmo: yeah, so i am using the text variation of attoparsec's parser, but the socket api sends bytestrings
17:52:27 <Tekmo> Right
17:52:50 <NemesisD> whats the responsible way to do this
17:52:52 <Tekmo> So there is a `pipes-text` package on Github right now that has support for encoding from bytestrings to text, but it only works with newer version of text
17:53:14 <chrisdone> Tekmo: certainly when pondering it generally, a category with (.) composition would be nice, with the top-level run function executing the category
17:53:20 <Tekmo> NemesisD: https://github.com/michaelt/text-pipes/
17:53:42 <NemesisD> Tekmo: hmm, would pulling that in be absolutely necessary here? how far away is it from release
17:53:43 <Tekmo> chrisdone: So there are various advantages to the two categories (i.e. the vanilla pull-based pipes category and the conduit-like pipes category)
17:53:54 <Tekmo> chrisdone: The conduit-like one handles end of input and leftovers very nicely
17:53:54 <chrisdone> e.g.  grep "foo " . take 5  or so
17:54:13 <countoren> :165
17:54:15 <Tekmo> chrisdone: The pull category from pipes handles mixing of non-streaming components and streaming components well
17:54:15 <chrisdone> nicely in what ssense?
17:54:35 <chrisdone> what's the difference between streaming and non-streaming? example?
17:54:54 <Tekmo> Let me first answer Nemesis's questoin
17:55:38 <Tekmo> NemesisD: It's probably a month or two from release
17:55:38 <NemesisD> Tekmo: hehe that package defines a Pipe Text Bytestring m r that has the exact same definition as mine: P.map TE.encodeUtf8
17:56:01 <Tekmo> NemesisD: Yeah, but that is broken
17:56:08 <Tekmo> NemesisD: Chunk boundaries will mess it up badly
17:56:10 <NemesisD> oh wait thats encode, i want decode
17:56:23 <Tekmo> NemesisD: The issue is that `text` for a while never provided a good way to incremental decoding
17:56:35 <NemesisD> the decode is much more involved
17:56:38 <Tekmo> NemesisD: It only added it specifically at the request of Ben Gamari who was helping work on `pipes-text`
17:56:53 <Tekmo> NemesisD: Most other libraries just worked around it by using various hacks
17:57:07 <NemesisD> Tekmo: i'm generally not that concerned about needing to use a new version of text, nobody uses my libraries anyways
17:57:52 <Tekmo> NemesisD: But I'm still not sure if that's the source of your parsing problem anyway
17:58:04 <Tekmo> NemesisD: That would only cause problems after 4096 characters at worst
17:58:12 <NemesisD> Tekmo: i'm going to guess that while this is probably an issue that will bite me eventually, it is not the problem here.
17:58:29 <NemesisD> AH! im not sending a newline
17:58:39 <NemesisD> haproxy knows you're done talking when you send a newline
17:59:00 <Tekmo> chrisdone: Okay, so the first topic is "nicely done leftovers"
17:59:17 <Tekmo> chrisdone: One of the things I had to do to make conduit a proper category was to correctly handle leftover propagation
17:59:46 <Tekmo> chrisdone: Right now, if you compose two conduits like this: c1 =$= c2, any leftovers that `c2` generates do not get propagated through `c1`
17:59:47 <Jesin> I'm a little confused by http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.0.2/Data-ByteString-Lazy-Builder.html and http://www.haskell.org/ghc/docs/latest/html/libraries/binary-0.5.1.1/Data-Binary-Builder.html
18:00:04 <Jesin> They apparently define two separate datatypes named "Builder" that appear to fill the same purpose
18:00:13 <Tekmo> chrisdone: This manifests itself as an identity law violation because: idP =$= c1 /= c1
18:00:23 <Jesin> furthermore I don't think I see any functions for converting between them
18:00:29 <Tekmo> chrisdone: The left-hand side of the equation discards all leftovers that `c1` generates, where the right-hand side does not
18:00:46 <Tekmo> chrisdone: So part of the fix is that now conduits correctly transform leftovers
18:01:09 <NemesisD> BOOYAH! it works it works!
18:01:19 <Tekmo> chrisdone: So that means, for example, if you have a `ByteString` to `Text` decoder and you push leftovers back onto it then it will be clever and correctly propagate those leftovers even further back upstream as `ByteString`s
18:01:20 <chrisdone> Tekmo: hm, maybe we can come back to this once i've done some reading about conduit and pipes
18:01:23 <Tekmo> NemesisD: Awesome!
18:01:30 <Tekmo> chrisdone: Alright
18:01:36 <Tekmo> chrisdone: One thing
18:01:42 <Tekmo> chrisdone: Read the pipes tutorial, minimally
18:01:44 <NemesisD> although i'm probably going to have a bad time if the messages get too large on either side it sounds like
18:02:00 <Tekmo> chrisdone: The reason I recommend it is that one challenge of modeling shell programing in Haskell is that some things in shell programming are streaming and others are not
18:02:24 <Tekmo> chrisdone: The `pipes` tutorial introduces really clever tricks for mixing non-streaming and streaming things in a single framework
18:02:28 <Tekmo> chrisdone: You should read it for that alone
18:03:31 <NemesisD> chrisdone: for some reason i had it in my head that all fp complete employees are given mandatory conduit education
18:04:01 <Tekmo> I presume Chris works mostly on Fay and front-end stuff, so he probably wouldn't need to know
18:04:49 <Iceland_jack> <Tekmo> chrisdone: The reason I recommend it is that one challenge of modeling shell programing in Haskell is that some things in shell programming are streaming and others are not
18:04:56 <chrisdone> i work across the board, but i haven't needed to know conduit yet
18:04:58 <Iceland_jack> Which parts are nonstreaming?
18:05:25 <Tekmo> Give me a second, I need to pull up a list of Unix tools
18:05:39 <quchen> Can you recommend a simple asymmetric crypto lib for Haskell?
18:05:50 <chrisdone> sometimes i work on backend stuff with attoparsec and processes, sometimes in yesod, sometimes fay and html/css, sometimes emacs =)
18:06:30 <Iceland_jack> I would really enjoy a detailed comparison between Pipes and shells!
18:06:39 <NemesisD> chrisdone: one day i'd like to pick your brain about what its like to work at fpcomplete :)
18:06:57 <chrisdone> NemesisD: it's the best job i've had
18:07:17 <quchen> If only it wasn't remote :-(
18:07:45 <chrisdone> yeah, you have to like remote work. i do!
18:07:46 <NemesisD> it seems pretty awesome. not that many haskell shops are cool with remote. if it became a wise idea to leave my job I'd love for my next job to be in haskell
18:07:46 <Tekmo> Iceland_jack: Things like `chmod`, `true`, `at`, `rm`, `wait`.  Basically things which are not involved in text processing
18:07:57 <countoren> does anyone tried to install wai-extra-1.3.4.4 (yesod dep) there is parsing error building it.  (some non escaped  * in comments)
18:08:01 <Iceland_jack> Ah things like that
18:08:08 <lpaste> Jesin pasted “Confusing standard library conflict” at http://lpaste.net/96110
18:08:14 <zomg> Yeah I'm busy with some projects but would be p cool to work with Haskell
18:08:19 <zomg> And I refuse all jobs except ones that are remote
18:08:20 <zomg> :P
18:08:29 <NemesisD> i prefer in-office work but not more than i prefer working in haskell over ruby
18:08:34 <Tekmo> I'm the opposite.  I prefer non-remote jobs
18:08:44 <Tekmo> I work better around people in person
18:08:57 <zomg> But I'm only about average when it comes to the language so I dunno how easily some company that actually had remote stuff would hire me
18:09:11 <zomg> In my experience many of the ones that are more remote oriented tend to be the sort of ones who hire the really skilled guys
18:09:20 <Tekmo> The thing about Haskell is that once you start doing it full-time you learn it REALLY fast
18:09:35 * geekosaur would kinda like to try a job working in haskell but does not believe he's really good enough for it
18:09:47 <Tekmo> Oh, you're definitely good enough for it
18:09:53 <zomg> Yeah I'm kinda at that point that I'd probably learn it pretty quick if I had someone to answer my dumb questions =)
18:09:53 <geekosaur> mostly I get by with xmonad based on my x11 knowledge, not so much my haskell >.>
18:10:16 <iron_houzi> Is it possible to save modification's I've done to ghci to a conf file?
18:10:18 <Tekmo> A lot of people think being an expert at Haskell means that they need to be like Edward
18:10:33 <zomg> Well, I have a non-trivial haskell repo on github, at least that's something
18:10:34 <zomg> haha
18:10:50 <iron_houzi> OK .ghci file
18:11:18 <quchen> Tekmo: Problem is there are lots of smart people here so normal users constantly feel dumb.
18:11:28 <thebnq> i find that much of learning haskell has been actually just learning theory :)
18:11:29 <hpc> even the smart people here are dumb
18:11:34 <Iceland_jack> *especially*
18:11:37 <quchen> That's why I'm not sure how well I'd do in a Haskell job
18:11:58 <hpc> people who could lecture me for days on category theory can't understand why sqlite isn't safe for storing data
18:12:00 <geekosaur> perhaps more to the point, I still tend to reach for perl before haskell because I know it much better (25 years vs. 7 years)
18:12:08 <chrisdone> Tekmo: indeed -- i've been feeling my way around how i, personally, use the shell (which is why i encourage others to fork and feel their own way). it's not yet that clear to me that i even do non-trivial piping, it's always find, grep, tail, easy things. on the other hand, what i personally am interested in is type-safe wrappers to commands. for example, with my pdfinfo wrapper i can say pdfinfo "foo.hs" <&> pdfTitle to get the title
18:12:09 <chrisdone> (for example). not only is this better typed and easier to access, i can have the shell generate much richer --help equivalents and completions
18:12:13 <quchen> Look at chrisone. Chrisdone had some spare time so he started coding a shell.
18:12:18 <NemesisD> i'm mainly interested in working with people who are way better than me in haskell. that's how you learn fast. i consider my haskell education hindered by the fact that i do it mostly in isolation
18:12:24 <quchen> Meanwhile, quchen is still sitting on his stupid leak.
18:12:28 <Tekmo> chrisdone: Yeah, type safety is a huge win all by itself
18:12:29 <Aetherspawn> monochrom: updated with EBNF
18:12:36 <Aetherspawn> first time, sorry if it's wrong
18:12:41 <NemesisD> when i joined my current company i leveled up really fast by working with senior devs
18:12:48 <Aetherspawn> http://stackoverflow.com/questions/20139957/haskell-trifecta-parsing-completely-optional-semicolons-without-polluting-ast
18:12:57 <zomg> hpc: my client tells me weekly how I've saved his company. Then I goto haskell and I'm like "I have no idea what I'm doing lul"
18:13:06 <Tekmo> zomg: lol
18:13:11 <Jesin> hpc: "safe" in the security sense or the reliability sense?
18:13:18 <scivey> zomg: I like how you used non-trivial in a casual sentence like that.
18:13:23 <zomg> lol
18:13:36 <Tekmo> quchen: Space leak?
18:13:41 <geekosaur> (and the perl had relatively little ramp-up because I already knew all the languages it stole stuff from, whereas I spent 3 or 4 of that 7 years of haskell just getting to the point where I could do actual productive work)
18:13:42 <Tekmo> quchen: Or memory leak in another language
18:13:54 <quchen> Tekmo: Haskell. Socket leak, probably related to a thread leak.
18:14:00 <hpc> geekosaur: perl is my favorite functional language ;)
18:14:08 <Tekmo> quchen: What's a socket leak?
18:14:13 <Tekmo> quchen: Oh wait, never mind
18:14:16 <quchen> Opening sockets without closing them.
18:14:16 <Jesin> D: HPC what did you dooooo
18:14:18 <heatsink> Jesin, that happens when you have two instances of the same name in scope.  You can use a qualified name, or import one of the modules qualified.
18:14:18 <Aetherspawn> Tekmo: some people have said that pipes doesn't wrap up finite resources as efficiently as conduit
18:14:24 <Tekmo> Aetherspawn: It doesn't
18:14:28 <Tekmo> Aetherspawn: I agree with Michael on that
18:14:31 <hpc> Jesin: it's okay, haskell is my favorite imperative language
18:14:34 <Tekmo> Aetherspawn: I'm actively researching how to improve this
18:14:40 <Aetherspawn> does that make it *bad* for a server?
18:14:40 <Jesin> heatsink: yeah but those two datatypes have the same name and purpose, and yet seem to be written without knowledge that the other existed
18:14:42 <quchen> There's also a space leak, which is probably due to the same reasons, but it's not exceptionally bad so I focus on the rest first.
18:14:51 <edwardk> @remember zomg my client tells me weekly how I've saved his company. Then I goto haskell and I'm like "I have no idea what I'm doing lul"
18:14:51 <lambdabot> It is forever etched in my memory.
18:14:55 <quchen> I call it "a leak" because everything that can leak leaks.
18:14:59 <chrisdone> having people like edward around is very healthy for a community, i think. if you have no one to look up to you can fall into the trap of plateauing and never getting smarter
18:15:21 <heatsink> I think you have described the situation accurately, Jesin.  What is confusing about it?
18:15:28 <edwardk> @tell simpson we have already switched in HEAD
18:15:29 <lambdabot> Consider it noted.
18:15:32 <Tekmo> chrisdone: I agree
18:15:32 * Jesin places "{-# LANGUAGE Unsafe #-}" on hpc's head
18:15:53 <hpc> @hackage hpc -- Jesin: submit a patch!
18:15:53 <lambdabot> http://hackage.haskell.org/package/hpc -- Jesin: submit a patch!
18:16:05 <NemesisD> Tekmo: oh i wanted to run something by you with regards to this free monad pattern
18:16:10 <quchen> Probably closed source, hpc
18:16:17 <edwardk> please, inflate my ego more.
18:16:18 <zomg> It should be pointed out that Haskell is not involved in said saving of client's company
18:16:19 <Tekmo> NemesisD: Great!  I love free monads
18:16:21 <zomg> haha
18:16:24 <chrisdone> edwardk: =)
18:16:35 <Jesin> heatsink: they are both in the standard library, but there are no convenient functions for converting between them
18:16:40 <scivey> hpc: I don't use much perl on a daily basis these days, but Higher Order Perl is one of the best books on functional programming I've read.
18:16:41 * edwardk waits for the "I meant Edward Yang" rebuttal. ;)
18:16:41 <hpc> edwardk: you are less flaky than dons and you smell nice ;)
18:16:45 <chrisdone> hahaha
18:16:52 <Tekmo> Don fell off the face of the earth
18:17:12 <edwardk> He still tweets sunsets
18:17:36 <NemesisD> Tekmo: so haproxy works like this: you send a command and a newline, it writes a response back and closes the socket. currently i'm not exposing an API that tries to issue multipe commands in sequence but it does support pipelining
18:17:42 <hpc> edwardk: https://dl.dropboxusercontent.com/u/37707/dons.png
18:17:42 <edwardk> I think they are a steganographic code
18:17:51 <chrisdone> i haven't been able to guess whether dons just got such a massive workload he never comes on, whether he “got a life” and now does other things in his spare time, or no longer feels that haskell “needs help” to take off
18:18:02 <NemesisD> Tekmo: you issue commands with semicolons interspersed and it sends you back responses with newlines interspersed then closes the connection
18:18:04 <heatsink> If they're developed independently, Jesin, that explains why there are no functions for converting between them.
18:18:21 <Jesin> So does anyone know what's up with http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.10.0.2/Data-ByteString-Lazy-Builder.html and http://www.haskell.org/ghc/docs/latest/html/libraries/binary-0.5.1.1/Data-Binary-Builder.html ?
18:18:23 <edwardk> hpc: =)
18:18:28 <hpc> chrisdone: my theory is he's too busy making money
18:18:40 <NemesisD> Tekmo: eventually i'd like to figure a way where it could either pipeline for sequenced monadic actions and/or reacquire the socket when necessary
18:18:42 <edwardk> hpc: there are worse problems to have
18:18:58 <hpc> edwardk: certainly a problem i wouldn't mind having
18:19:11 <chrisdone> tho i liked his appearance on the haskellcast
18:19:24 <chrisdone> ReinH's on a roll with his guests
18:19:34 <hpc> in any event, dons' main contribution was making just an absolute crapload of "IO" stuff
18:19:46 <hpc> darcs, xmonad
18:19:52 <chrisdone> and books and reddit linking
18:19:53 <Jesin> heatsink: I'm not entirely familiar with the process for deciding which modules go in http://www.haskell.org/ghc/docs/latest/html/libraries/ , but I thought it'd usually involve doing something about this sort of thing?
18:19:55 <chrisdone> and blogging
18:19:56 <hpc> things that other people can do too
18:20:01 <Tekmo> and Stack Overflow answers
18:20:11 <chrisdone> relentless haskelling
18:20:12 <Tekmo> Jesus, how can a guy get so many 100+ answers on the haskell tag
18:20:14 <djahandarie> I don't think dons is particularly inactive. I'm just as inactive as he is. It's just that he used to be very active before.
18:20:24 <hpc> people, go make more haskell binaries!
18:20:38 <hpc> djahandarie: holy crap, you still exist!
18:20:41 <chrisdone> though it's true that irc sucks up your time
18:20:55 <simpson> edwardk: Rockin', thanks.
18:20:58 <Taneb> Yesterday I more or less from scratch made a markov-chain-y thing
18:21:14 <djahandarie> hpc, for some definition of exist.
18:21:29 <hpc> i am presently consumed by trying to write a game
18:21:47 <hpc> eventually that boulder will come back down the hill and i can move on to less sisyphean tasks
18:22:26 <Tekmo> NemesisD: Give me a second to reload some of this into my mind
18:22:30 <hpc> and maintaining my irc bot, but that's perl :(
18:22:37 <lpaste> gienah pasted “ghc 7.7 ‛Tagged’ is applied to too many type arguments” at http://lpaste.net/96111
18:23:06 <NemesisD> Tekmo: absolutely, i'm just shooting the breeze at this point, i've got a lot of api calls to implement before i need to worry about this, just curious if this pattern fits that well
18:23:08 <heatsink> I don't know how those packages are chosen.
18:23:11 <edwardk> djahandarie: The difference is some of us see you once a month at boston haskell, so we know you're alive, whereas Don has been reduced to a bot that takes a snapshot of the sunset and posts it to google+, and could have been murdered by Lennart at any point in the last 6 months and we would never know.
18:23:41 <simpson> To be fair, they're pretty nice sunsets.
18:23:44 <gienah> does anyone know about a change in ghc 7.7 that causes tagged to get the compiler error: ?Tagged? is applied to too many type arguments
18:23:46 <geekosaur> 2remember edwardk
18:23:47 <chrisdone> so that's why his twitter is donsbot
18:25:42 <edwardk> chrisdone: You've exposed the conspiracy. Don Stewart is Hari Seldon. He pre-recorded that Haskell Cast years ago, and Standard Chartered is actually the second foundation.
18:26:06 <Twey> Hehe
18:26:40 <Tekmo> NemesisD: So if I understand correctly, right now you have a free monad API to interacting with the socket and now you want to layer a text API that gets parsed and converted to the free monad?
18:26:56 * edwardk waits for those few who never read the foundation trilogy to get done googling.
18:27:19 <edwardk> er series i guess, there were a lot of books
18:27:38 <geekosaur> but nothing worth reading after _Second Foundation_
18:27:47 <hpc> edwardk: asimov was burdened with popularity from that series ;)
18:27:47 <NemesisD> Tekmo: well that part is working, although it sounds like i need to wait on pipes-text to do the bytestring conversion safely
18:28:11 <djahandarie> edwardk, LOL
18:28:17 <quchen> I just noticed a package defining Binary instances. However, it does not depend on Binary according to the Hackage page. How is this possible?
18:28:25 <NemesisD> Tekmo: i was more asking about how if this pattern could let me translate a sequence of actions in my Command monad into pipelined requests
18:28:32 <hpc> i really lost track with the "lol psychic powah" stuff
18:28:38 <NemesisD> i think the redis client for haskell does automatic pipelining, haven't looked at how they do it
18:28:41 <Tekmo> NemesisD: Ooooooh
18:28:49 <edwardk> hpc: fair
18:28:54 <NemesisD> Tekmo: but in the simplest case, sequences of actions if they aren't pipelined need to reopen the socket again
18:28:55 <Tekmo> NemesisD: Not if you use a free monad as the intermediate
18:29:02 <Tekmo> NemesisD: The free monad enforces sequencing
18:29:13 <countoren>  http://lpaste.net/96109 , one of the yesod dependancies failed to build with   Network/Wai/Middleware/RequestLogger.hs:166:1 parse error on input `*'
18:29:18 <hpc> edwardk: have you read http://qntm.org/ra?
18:29:20 <quchen> Oh, it seems to be a transitive dependency.
18:29:26 <edwardk> yeah
18:29:48 <meretrix> Is there any way to "fmap" a record syntax data constructor over Maybe values?
18:29:50 <Tekmo> NemesisD: To elaborate, the free monad cannot see what the next action should even be before it receives the result of the current action, because of the way we structured it
18:30:07 <edwardk> his "fine structure" series is pretty damn awesome as well
18:30:12 <hpc> meretrix: something like (map (\x -> x {foo = bar}) xs)?
18:30:25 <hpc> meretrix: except ofc with fmap
18:31:00 <NemesisD> Tekmo: ah ok, and actually the current design is a bit inside out for handling the reconnection
18:31:06 <hpc> edwardk: i love the format; it's kind of the "television of scifi novels"
18:31:52 <NemesisD> Tekmo: all the pipes stuff gets handed a connection thats already established, so i think the outermost function that gets the Command would need to break it into a sequence and connect for each
18:31:53 <meretrix> hpc: No, more like Data { x = Just 3, y = Nothing } :: Maybe Data
18:32:32 <meretrix> hpc: where data Data = Data { x :: Int, y :: Int }
18:32:53 <hpc> meretrix: it wouldn't be record syntax, but Data <$> Just 3 <*> Nothing
18:32:57 <hpc> :: Maybe Data
18:33:01 <scott_> meretrix: You can't put a Maybe Int in an Int field
18:33:12 <jrmithdobbs> so lets say i have a list of IO ByteString's, we'll say, but they're still thunks and have not actually been evaluated. This is one of those weird situations where the order of requesting them *does not matter* just order of use, however, I want to *start* the io operations on the whole list at once (slow api requests) while continuing other processing which will access said list in order (so it may block if a certain result isn't available yet)
18:33:24 <jrmithdobbs> i'm having trouble figuring out how to go about this exactly
18:33:32 <jrmithdobbs> I've got to be missing something obvious
18:33:33 <hpc> scott_: that was metasyntax
18:33:40 <Twey> jrmithdobbs: unsafeInterleaveIO
18:33:49 <Tekmo> No!
18:33:51 <meretrix> Ok thanks, that's what I figured.
18:33:51 <Twey> (if you're really sure)
18:34:03 <jrmithdobbs> i'm not so sure that I'm that sure
18:34:11 <scott_> hpc: I don't really get what it means then
18:34:12 <jrmithdobbs> what do I need to be sure about?
18:34:20 <Tekmo> So you can do this using `pipes-concurrency`
18:34:22 <Twey> jrmithdobbs: That the computations are pure, effectively
18:34:23 <hpc> meretrix: i am sure edwardk has a lens for it ;)
18:34:30 <scott_> hpc: Ah, I think I get it now, from your answers
18:35:03 <meretrix> hpc: Eh I've trying to avoid diving into lenses for now..
18:35:08 <hpc> meretrix: same ;)
18:35:19 <Tekmo> jrmithdobbs: The basic idea is that you `spawn` a mailbox, you fork one thread for each `IO ByteString` action, then each thread forward the result to the mailbox when they are done
18:35:21 <hpc> anyhoo, that's the best i can think of
18:35:29 <Tekmo> jrmithdobbs: Then you can read off the mailbox output using a `Producer`
18:35:43 <Tekmo> jrmithdobbs: I'll write up a quick skeleton for you
18:35:50 <Twey> Tekmo: Access order matters
18:36:39 <jrmithdobbs> Twey: access order by a concurrent consumer of the actions matters, i just want the rest of the list to be having seq applied to it while the former is running, basically
18:36:53 <jrmithdobbs> Twey: unsafeinterleaveIO is actually the opposite of what i want, in fact
18:37:25 <Tekmo> jrmithdobbs: Do you know in advance how many elements the list has?
18:37:49 <geekosaur> doesn't async have this?
18:37:52 <Twey> I don't know about pipes-concurrent, but I'd do something like mapM (\comp → newEmptyMVar >>= forkIO . runComp comp)
18:38:14 <jrmithdobbs> Tekmo: it's a function of [a] -> [a], I know the length of the param but not the result beforehand (so the list of IO actions I do know the length of at the time fetching would want to begin)
18:38:24 <Twey> Where runComp comp mvar = comp >>= writeMVar mvar
18:38:45 <Tekmo> jrmithdobbs: If your function has that type then you limit yourself to unsafe solutions
18:39:10 <Twey> Then you can go through the list reading the MVars (which blocks)
18:39:35 <jrmithdobbs> Tekmo: it doesn't have specifically that type, it's really [IO ByteString] -> [Aeson blah]
18:39:57 <jrmithdobbs> was simplifying because shouldn't really matter i wouldn't think?
18:40:50 * gienah finds that tagged builds with ghc 7.7.20131122 without {-# LANGUAGE PolyKinds #-} - not sure if that breaks anything else yet though
18:41:08 <Tekmo> Twey: Probably easier to use `async` like geekosaur suggested
18:41:19 <Guest97395> @pl \f xs -> fmap (zip xs) (mapM f xs)
18:41:19 <lambdabot> liftM2 fmap zip . mapM
18:42:21 <Sailorreality_> Haskell is the most autistic programming language
18:42:45 <Sailorreality_> everyone that knows haskell has aspergers
18:42:49 <Sailorreality_> no exceptions
18:43:01 <NemesisD> uh
18:43:08 <Iceland_jack> Nothing wrong with being autistic or having aspergers
18:43:20 <Tekmo> jrmithdobbs: Try this: http://lpaste.net/96112
18:43:24 --- mode: ChanServ set +o geekosaur
18:43:25 <Iceland_jack> Please refrain from such comments
18:43:27 <danharaj> @where ops
18:43:27 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
18:43:27 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
18:43:33 <shapr> wot?
18:43:35 --- mode: ChanServ set +o copumpkin
18:43:37 <danharaj> No time for ableism here.
18:43:40 <ion> iceland_jack: Feeding the trolls never helps.
18:43:44 --- mode: ChanServ set +o shapr
18:43:44 <Tekmo> jrmithdobbs: That uses `async` to fork off all the computations, then iterates through the results using a `Producer`
18:43:45 <ion> Best just to ignore them.
18:43:48 --- mode: copumpkin set +b *!~IceChat7@24.114.41.176
18:43:48 --- kick: Sailorreality_ was kicked by copumpkin (no thanks)
18:43:50 --- mode: copumpkin set -o copumpkin
18:43:51 <Iceland_jack> ion: It did at least once :)
18:43:55 --- mode: geekosaur set -o geekosaur
18:43:58 <shapr> copumpkin: thank you :-)
18:44:07 * geekosaur was waiting for them to repeat after the warning
18:44:14 <jrmithdobbs> Tekmo: it doesn't because i'm using http-conduit, but it does because i see what you're going for there and think i know how to make resourcet/conduit do it
18:44:21 <Tekmo> Yeah
18:44:23 <Tekmo> Just translate it
18:44:27 <jrmithdobbs> nifty
18:44:41 <copumpkin> geekosaur: join-then-immediately-say-something-inflammatory doesn't seem warning-worthy
18:44:50 * shapr agrees
18:44:53 <NemesisD> Tekmo: oh yeah, is there any way i could be sure that i have finished sending data to the stream before i try to read? every so often this function fails to return any data. seems like a race condition
18:44:58 <jrmithdobbs> want to see the equiv in ruby? requires ~10M of epoll/etc c wrappers on the backend to work too! ;p
18:45:13 --- mode: shapr set -o shapr
18:45:20 <Twey> Tekmo: What's an async?  :þ
18:45:29 <Tekmo> Twey: An awesome library!
18:45:32 <shapr> Twey: it's where you wash your ForkIOs
18:45:37 <shapr> in the async!
18:45:38 <Twey> Nice
18:45:51 <shapr> ahem, You wash your ForkIOs in async
18:45:54 <geekosaur> also my network is unstable tonight :/ cmon folks, it's not snowing *inside*, the signal shouldn't be this bad :/
18:45:56 <Twey> Oh, that is neat
18:45:58 * shapr gives up, goes back to homework
18:46:00 <Tekmo> Twey: It lets you fork off computations and wait on their results
18:46:16 <Twey> Futures, I guess
18:46:19 <geekosaur> @hoogle async
18:46:20 <lambdabot> package async
18:46:20 <lambdabot> Control.OldException asyncExceptions :: Exception -> Maybe AsyncException
18:46:20 <lambdabot> Control.OldException AsyncException :: AsyncException -> Exception
18:46:24 <Twey> Found it
18:46:44 * hackagebot bytestring-builder 0.10.4.0 - The new bytestring builder, packaged outside of GHC  http://hackage.haskell.org/package/bytestring-builder-0.10.4.0 (LeonSmith)
18:47:03 <Twey> But ‘wait’ is still in IO :þ
18:47:15 <Tekmo> NemesisD: I don't see any concurrency in your code.  Where can the race condition arise?
18:47:22 <Twey> Ah, because exceptions
18:47:58 <NemesisD> Tekmo: i probably misspoke, i need to enforce that the other side has gotten the entire message before i try to read
18:48:15 <Twey> NemesisD: Session types!
18:48:17 <NemesisD> and god forbid i may even need a threadDelay in there
18:48:25 <Tekmo> NemesisD: How would you detect that?
18:48:32 <geekosaur> how do you plan to do that? unless there is a synchronization protocol
18:49:01 <Twey> NemesisD: http://pubs.doc.ic.ac.uk/session-types-in-haskell/session-types-in-haskell.pdf‎
18:49:40 <NemesisD> Tekmo: not sure. i don't know if pipes can know when it has sent everything down the buffer
18:49:54 <geekosaur> it can know when the data kits the network stack
18:49:57 <Tekmo> NemesisD: The way you know is that the send action completes
18:49:58 <geekosaur> that's *all* it can know
18:50:09 <Tekmo> NemesisD: You can't tell if the data reached the other side, though
18:50:17 <Tekmo> NemesisD: That's up to the network
18:50:20 <NemesisD> Tekmo: yikes, thread delay time :(
18:50:47 <Tekmo> NemesisD: If you want to be sure you need to build in some sort of acknowledgement into the protocol
18:50:52 <geekosaur> it can't know when the data have left the machine, nor when the other m,achine receives it, nor when the remote application receives it, unless the remote application can send a "yes I got it" packet --- which must be defined by your protoocl
18:51:39 <NemesisD> Tekmo: unfortunately it isn't my protocol it is haproxy's. actually though instead couldn't i get pipes to just take data until the other side closes?
18:51:52 <Tekmo> NemesisD: Yes, of course
18:51:54 <Twey> Tekmo: Isn't TCP sufficient?
18:52:08 <Twey> Well, to get to the other machine, anyway.
18:52:13 <lpaste> jrmithdobbs annotated “Async list processing” with “Async list processing (annotation)” at http://lpaste.net/96112#a96117
18:52:22 <geekosaur> Twey: TCP cannot tell you when the other side has received something
18:52:37 <jrmithdobbs> Tekmo: had to stare at it a minute think that's right ... i like yours better ;p
18:52:38 <Twey> Oh no, never mind
18:52:49 <Tekmo> jrmithdobbs: :)
18:52:51 <Twey> Only when it hasn't
18:53:09 <jrmithdobbs> Tekmo: needs a EM.stop before that last end ;p
18:53:33 <vvein> how do I run (a,a)->b over [[(a,a)]], to get [[b]] ?
18:54:06 <Tekmo> jrmithdobbs: What language is that?
18:54:07 <Iceland_jack> :t map.map
18:54:07 <vvein> no idea how to get through 2 levels of nesting ;)
18:54:08 <lambdabot> (a -> b) -> [[a]] -> [[b]]
18:54:09 <Twey> :t (map . map) (undefined :: (a, a) -> b
18:54:09 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:54:11 <Twey> :t (map . map) (undefined :: (a, a) -> b)
18:54:11 <lambdabot> [[(a, a)]] -> [[b]]
18:54:13 <jrmithdobbs> Tekmo: ruby
18:54:28 <jrmithdobbs> Tekmo: ruby is underappreciated re: it's functional bits ;p
18:54:29 <danharaj> edwardk: Ah ok, so it is the fact that in a right Kan extension we cannot choose the result type while in Cont r we can.
18:54:32 <vvein> so obvious to you guys! :)
18:54:46 <edwardk> yep
18:54:48 <vvein> thank you Iceland_jack , Twey
18:55:01 <Twey> vvein: The long form is from map (map f) xss
18:55:15 <danharaj> edwardk: Now to understand this weird business with comonads and Rifts.
18:55:20 <Twey> Or map (\xs → map f xs) xss if you like
18:55:21 <nooodl_> i wouldn't call the map.map thing too obvious! it's commonly known though
18:55:25 <vvein> Twey: I was trying something w/ <$>
18:55:44 <Twey> vvein: map is a specialization of fmap/<$>
18:55:45 <vvein> Twey: I thought there is some sugar way, maybe with liftA or liftM
18:55:59 <Tekmo> jrmithdobbs: That reminds me.  Pipes `for` loops are basically a more powerful version of ruby iterators
18:56:01 <vvein> I'm just beggining to uncover what's around ;)
18:56:06 <hsiu> Could anyone assist me? I'm using the ImageMagick FFI library. I started with an example from the source: https://github.com/qnikst/imagemagick/blob/df94d7930872ccacbf829f03e0681a771d308cbb/examples/basic.hs
18:56:06 <hsiu> Could anyone assist me? I'm using the ImageMagick FFI library. I started with an example from the source: https://github.com/qnikst/imagemagick/blob/df94d7930872ccacbf829f03e0681a771d308cbb/examples/basic.hs
18:56:06 <hsiu> Could anyone assist me? I'm using the ImageMagick FFI library. I started with an example from the source: https://github.com/qnikst/imagemagick/blob/df94d7930872ccacbf829f03e0681a771d308cbb/examples/basic.hs
18:56:06 <hsiu> Could anyone assist me? I'm using the ImageMagick FFI library. I started with an example from the source: https://github.com/qnikst/imagemagick/blob/df94d7930872ccacbf829f03e0681a771d308cbb/examples/basic.hs
18:56:10 <hsiu> whoops
18:56:20 <Twey> vvein: (f <$>) <$> xss
18:56:26 <lightquake> has there been work done on encoding authorization in the type system?
18:56:27 <Twey> Is equivalent
18:56:28 <hsiu> sorry, anyways I've been playing around with that, trying different things. Right now I'm trying to get it to work on an image blob, rather than reading from file.
18:56:35 <vvein> Twey: thanks! :)
18:56:38 <Twey> Or ((<$>) . (<$>)) xss
18:56:40 <hsiu> That is, instead of readImage w $ decodeString img, I want to use readImageBlob. For simplicity right now, I'm testing this by just reading the image file into a ByteString and then doing readImageBlob on that. This is silly, of course, but in the end the image data will come from a non-file source.
18:56:40 <hsiu> That is, instead of readImage w $ decodeString img, I want to use readImageBlob. For simplicity right now, I'm testing this by just reading the image file into a ByteString and then doing readImageBlob on that. This is silly, of course, but in the end the image data will come from a non-file source.
18:56:44 <Twey> Er, f xss
18:56:50 <hsiu> So I've tried
18:56:50 <hsiu> imageBlob <- BS.readFile img
18:56:50 <hsiu> _ <- readImageBlob w imageBlob
18:56:51 <lightquake> i.e., proving at the type level that you need to be an 'administrator' in order to launchTheMissiles :: IO ()
18:56:59 <hsiu> This doesn't work though, of course, because BS.readFile is of type IO ByteString, and withMagickWandGenesis' do block is ResourceT IO. So, I understand why it's not working, but I don't know how to remedy the problem.
18:56:59 <jrmithdobbs> Tekmo: nah, Enum and Bounded  + Functor more closely resemble that i think
18:57:05 <Iceland_jack> Twey: Why would you ever use ((<$>) . (<$>)) :P
18:57:09 <Twey> Indeed
18:57:10 <jrmithdobbs> Tekmo: well Applicative
18:57:11 <hsiu> Here's the non working attempt:
18:57:11 <hsiu> http://lpaste.net/96113
18:57:20 <vvein> Twey: totally worked!!
18:57:38 <Iceland_jack> ((<$>) . (<$>)) looks like someone on acid incidentally
18:57:40 <Tekmo> jrmithdobbs: For example:
18:57:46 <vvein> haha
18:57:49 <jrmithdobbs> Tekmo: i can do almost everything i can with Enumerable with haskell2010 stuff afaict so far
18:58:08 <Twey> lightquake: It would look like: launchTheMissiles ∷ ProofOfAdministratorStatus → IO ()
18:58:39 <Twey> lightquake: Where maybe checkAdministratorPrivileges ∷ Maybe ProofOfAdministratorStatus
18:58:45 <TravisD> Hmm, shouldn't that be ProofOfWarlordStatus?
18:58:49 <Twey> Or IO (…)
18:59:08 <Twey> You could use a Reader(T) to make it nicer to read
18:59:15 <NemesisD> Tekmo: so looking at fromHandle for inspiration, seems like i just need to slap another pipe after fromSocket that when downstream asks for data, checks if the socket isConnected. is that about right?
18:59:34 <chrisdone> i just thought of a nice feature for structured-haskell-mode
18:59:42 <Twey> chrisdone: Oh?
19:00:15 <jrmithdobbs> Tekmo: tbqh, the way i've kind of been looking at it is that ruby's Proc is an weakly-typed functor and from there most stuff translates directly to applicative/etc ... after figuring out what all that stuff actually seems to mean anyways ;p
19:00:17 <edwardk> Iceland_jack: that is better than the fmap fmap fmap version of the same thing, that sounds worse ;)
19:00:28 <Tekmo> NemesisD: So what is the exact sequence of sockets opening and closing?
19:00:38 <Twey> I like ‘fmap fmap fmap’ :þ
19:00:42 <Iceland_jack> De gustibus I suppose
19:00:49 <Twey> No nasty infix symbols in the way!
19:01:09 <NemesisD> Tekmo: ah shoot, i have to head out for about half an hour right now, i'll hit you up if you're still in when i get back
19:01:14 <jrmithdobbs> Tekmo: tbqh, looking at wai vs rack pretty much shows what i'm talking about ;p
19:01:22 <danharaj> edwardk: What are some applications of CoT w? I like comonads but it takes me a while to find concrete justifications of the constructions associated with them.
19:01:40 <chrisdone> in paredit-mode, you have split-sexp and join-sexp to make e.g. "foobar" into "foo" "bar" and vise-versa. in haskell you often have e.g. "foo" <> show bar <> "zot" <> blah. there could be a key that you hit to run insert-operand that will take you from  foo <> |bar  to  foo <> | <> bar  and vise-versa, delete-operand, to take you from   foo <> |bar  to  foo
19:01:44 <lpsmith> In a .cabal file,  is there a way to express (foo >= 0.1 && < 0.2  && bar >= 0.1) || foo >= 0.2   ?
19:01:47 <roconnor> what is CoT?
19:01:47 <danharaj> (and honestly I still don't know what cobind does other than specify a coassociativity law for its coalgebras)
19:01:58 <danharaj> http://hackage.haskell.org/package/kan-extensions-3.7/docs/Control-Monad-Co.html#t:CoT
19:02:05 <danharaj> Making a monad transformer out of a Comonad
19:02:12 <roconnor> oh right.
19:02:13 <lpsmith> I'm having trouble finding the right syntax for that, if it is indeed possible.
19:02:29 <edwardk> i don't have any direct applications of CoT w. I use it more as a tool for reasoning. e.g. using comonads while working with monads in scala rather than working with monad transformers, since the former is inferable, and the latter in scala is hell.
19:02:35 <chrisdone> beccause manually typing out the operator or deleting it is kind of pointless when the editor could do it for you
19:03:00 <Tekmo> NemesisD: Alright
19:03:02 <danharaj> ah
19:03:11 * chrisdone tries it
19:03:21 <Twey> chrisdone: That would be nice
19:03:24 <Aetherspawn> Tekmo: did you see the pm
19:03:24 <danharaj> actually I was confused
19:03:31 <danharaj> I wanted to ask about *ContsT*
19:04:03 <Tekmo> Aetherspawn: Now I have! :)
19:04:11 <Aetherspawn> hehe
19:04:13 <lpsmith> i.e. I want a build-depends that declares a dependency on a package only if another package is in a specific version range?
19:04:48 <danharaj> edwardk: Also now I wonder how much of your productivity is caused be Scala-induced stress.
19:05:32 <chrisdone> Twey: once an hour i find some haskell operation and add a little bit more to shm, hehe. earlier i added support for C-j when in a guard. so
19:05:32 <chrisdone> foo | bob = blah|  -- C-j here gives you the following line
19:05:32 <chrisdone>     | |
19:05:32 <chrisdone> i have similar context-awareness for lists and tuples and constructors
19:05:43 <edwardk> danharaj: =)
19:06:00 <danharaj> Ah ok, so ContsT is just the unquantified version of CoT
19:06:21 <edwardk> danharaj: i'll say that writing scala definitely motivated me to improve the haskell ecosystem to remove any need for me to ever have to write scala again.
19:06:27 <danharaj> haha
19:07:35 <jrmithdobbs> Tekmo: btw, if you're interested and not familiar, em-synchrony is pretty cool, takes the same philosophy as the haskell runtime actually to some extent
19:07:58 <jrmithdobbs> Tekmo: lets you run inside eventmachine but write synchronous looking code
19:08:00 <Aetherspawn> library request: a proper association list library that doesn't require anything except Eq but with a Data.Map api
19:08:20 <Aetherspawn> sssh nobody call in ReinH
19:08:59 <danharaj> edwardk: I got into a bet with Ryan on whether I can find a slick efficient implementation of FRP via category theory so I'm sharpening my construction-fu. ;)
19:09:02 <chrisdone> Aetherspawn: you have a use-case for that?
19:09:08 <Tekmo> jrmithdobbs: Neat :)
19:09:09 <jrmithdobbs> Tekmo: but i was hitting major performance walls, hence I'm looking at how to do similar things in haskell, so much fun so far :)
19:09:11 <Aetherspawn> I have one yesterday but it was stupid
19:09:17 <chrisdone> Aetherspawn: i tend to use [(a,b)]] and Data.List.lookup
19:09:17 <Aetherspawn> I was using IORefs as keys to a map
19:10:01 <edwardk> danharaj: you didn't actually take the side that suggested you were going to get a usable form of FRP did you? that direction lies madness.
19:10:10 <Aetherspawn> Data.List is OK but the API isn't mappy
19:10:18 <jrmithdobbs> someone should really write a "yesod and/or WAI for people famialar with rails/sinatra and/or RACK"
19:10:20 <Aetherspawn> it feels almost like a huge hack
19:10:27 <Aetherspawn> (to use a list for a map, that is)
19:11:06 <danharaj> edwardk: FRP is the white whale of Haskell programming. Several people I know have tried— and failed— to get a usable formulation at least multiple times, myself included. :P
19:11:15 <danharaj> I find it amusing to try.
19:11:24 <jrmithdobbs> tutorial* ... comparing the two actually gives a pretty intutitive way of introducing monads in a modern environment without all the things everyone bitches about the Prelude for newcomers ...  without a bunch of weird analogies just by, you know, actually trying to get things done
19:12:45 <maxiepoo> jrmithdobbs: Isn't Yesod a bit heavy for total noobs though?
19:13:11 <Jesin> Gotta love this description http://hackage.haskell.org/package/split
19:13:13 <chrisdone> danharaj: call me ishmael
19:13:16 <jrmithdobbs> maxiepoo: i would say that for anyone who can understand all the method_missing magic of Active* and rails/rack, no
19:13:47 <maxiepoo> jrmithdobbs: I just mean the type errors you get are pretty intimidating
19:13:53 <lpsmith> ahh, apparently not :-(
19:14:03 <jrmithdobbs> maxiepoo: specifically because it's solving problems in the same domain with functionally similar mechanisms (if you squint)
19:14:03 <chrisdone> lpsmith: hey dude
19:14:05 <danharaj> djahandarie: jmcarthur mistook me for you at a haskell meetup in nyc the other day.
19:14:23 <lpsmith> chrisdone, hey
19:14:39 <Tril> edwardk: when you say usable FRP are you implying the Reactive and reactive-banana hackage packages should not be used for some reason?
19:14:46 <chrisdone> lpsmith: what are you up to these days?
19:15:03 <jrmithdobbs> maxiepoo: ya well, working through those is the only thing that's really helped me to be able to intuit what's actually going on
19:15:09 <lpsmith> other than writing software,  not much
19:15:18 <edwardk> Tril: i'm demonstrating a personal bias that may not be well grounded in fact where those particular packages are concerned. ;)
19:15:39 <jrmithdobbs> maxiepoo: splitting out portions of a yesod route handler to be usable by multiple handlers is sort of like figuring out how to read those types in a trial by fire
19:16:04 <Tril> edwardk: just wondering as I'm trying to learn them (and Haskell) at the same time..
19:16:17 <jrmithdobbs> maxiepoo: except with non-contrived high school algebra problems that bore everyone
19:16:27 <dmwit> The traditional stumbling block for FRP implementations is space leaks.
19:16:32 <danharaj> There is no FRP system implemented to date that can be used in an industrial scale project without severe difficulty.
19:16:38 <chrisdone> which elm claims to have solved
19:16:44 <dmwit> I haven't heard anybody saying they have an implementation that avoids them completely, so I assume reactive has them.
19:16:47 <maxiepoo> jrmithdobbs: hm, now I think I do want to see this tutorial
19:16:53 <dmwit> chrisdone: Oh, really?
19:17:01 <dmwit> I wonder what they claim the magic sauce is.
19:17:02 <chrisdone> dmwit: by being a strict language
19:17:09 <dmwit> mmm =)
19:17:20 <chrisdone> (it's described in the thesis)
19:17:28 <jrmithdobbs> maxiepoo: i think it would be interesting, they're similarly complex environments that solve several problems almost identically (semantics of each given language aside)
19:17:32 <dwcook> Doesn't that mean you could theoretically solve it in Haskell by just strategically making functions strict?
19:17:33 <dmwit> That seems like it would rule out an entire raft of other useful techniques -- including ones that mix well with FRP.
19:17:45 <dwcook> s/Doesn't/Wouldn't/
19:18:18 <chrisdone> dunno. FRP remains an unturned stone for me
19:18:28 <danharaj> edwardk: I am confused as to how `CoT w f` ~ `Rift w f` because the first is `forall r. w (a -> f r) -> f r` and the second is `forall r. w (a -> r) -> f r`
19:18:30 <dmwit> dwcook: Yes, I'm pretty sure you can solve space leaks in programs written with today's FRP frameworks with careful strictness annotations.
19:18:39 <dmwit> dwcook: The problem is there's nothing (sane) that the framework *itself* can do.
19:19:01 <lilred> hey guys, I know I'm on a bit of a wild goose chase, but can anyone refer me to resources about formalization of UI paradigms?
19:19:03 <edwardk> danharaj: its not the same
19:19:14 <danharaj> ur docs say they are
19:19:18 <khyperia> if I have a function "func x = expensiveComputation x", will "func = expensiveComputation" evaluate the expensive computation only once the entire program?
19:19:20 <edwardk> then i lied ;)
19:19:23 <danharaj> haha
19:19:24 <danharaj> nice.
19:19:27 <djahandarie> danharaj, haha, what? Our nicks might be similar, but I don't think we look similar in real life too, do we? :P
19:19:29 <edwardk> patch it =)
19:19:39 <danharaj> fine.
19:19:49 <chrisdone> djahandarie and danharaj. it seems that i thought you two were the same person. i'm sorry
19:20:03 <edwardk> danharandarie
19:20:13 <danharaj> djahandarie: I doubt it but we are mostly our IRC handles to most people aren't we? :P
19:20:14 <chrisdone> the mind is neither racist nor ordinalist
19:20:15 <dmwit> khyperia: Maybe. Check the core.
19:20:19 <Twey> khyperia: If ‘expensiveComputation’ is the thing that is expensive, and not ‘expensiveComputation x’, then yes
19:20:25 <djahandarie> danharaj, well, I've met jmcarthur before :P
19:20:33 <danharaj> at hacphi?
19:20:37 <djahandarie> Yeah
19:20:42 <danharaj> then apparently we look the same to him
19:20:51 <danharaj> oh wait no
19:20:52 <khyperia> No idea how to do that, dmwit, so I'll just go with Twey, heh.
19:21:11 <dmwit> khyperia: add -ddump-simpl to your GHC compilation line
19:21:15 <danharaj> Whatever it was.
19:21:18 <danharaj> He was sure he met me at hacphi.
19:21:24 <geekosaur> or install the ghc-core package
19:21:25 <danharaj> After I told him I was danharaj.
19:21:31 <djahandarie> Hahaha
19:21:33 * danharaj is now getting confused himself
19:21:36 <dmwit> khyperia: (And if you're using a different compiler than GHC, double-check with Twey that he still believes what he said. ;-)
19:21:45 <Twey> Hehe
19:21:46 <khyperia> specific use case is "expensiveComputation" is a runParser from Parsec on a constant string, returning a function
19:21:53 <Twey> I thought memoization on values was a usual optimization
19:22:16 <dmwit> Memoization is pretty unusual, but khyperia's question doesn't appear to be about memoization.
19:22:16 <Twey> Especially top-level, I'd be surprised if any non-experimental compiler didn't do it
19:22:57 <dmwit> It's also possible that I understand the term "memoization" incorrectly.
19:22:58 <khyperia> since theoretically eta reduction doesn't change anything, but performance isn't theoretical, lol.
19:23:10 <Twey> I'm confused.  Memoization, the process of sharing evaluated values rather than re-evaluating them?
19:23:42 <dmwit> I thought memoization was specifically about avoiding the recomputation of function applications.
19:24:38 <djahandarie> danharaj, this is how I looked at HacPhi: http://yorgeys.smugmug.com/Computers/Hac-Phi-2011/i-ncBNvDc/A
19:24:43 <djahandarie> Also more or less how I look now, anyways
19:25:01 <danharaj> ok so I guess to white people we probably look similar
19:25:05 <danharaj> :p
19:25:10 <Aetherspawn> there is a degree of memoization in ETA expansion afaik
19:25:11 <djahandarie> lol
19:25:47 <Twey> dmwit: Since Haskell computation consists of applying functions, I'm not sure how that differs
19:26:10 <dmwit> "expensiveComputation" is not clearly a function application.
19:26:18 <khyperia> Another question: If I have a big constant string in my program (specifically, my language's prelude), is it possible to embed that string in a file in the program, instead of littering it with a whole ton of "\ newline \"?
19:26:45 <Ralith> dmwit: what is an example of a computation that is not a function application?
19:26:49 <Tekmo> khyperia: I don't think there is a good way to do this
19:26:58 <Ralith> perhaps blocking on a lock or something
19:27:00 <Tekmo> khyperia: Let me see if I can pull up a relevant Stack Overflow question
19:27:03 <Aetherspawn> khyperia: using {-# LANGUAGE CPP #-} I think you can #include it
19:27:05 <Ralith> not really computation
19:27:05 <Twey> The only thing I can think of is let &c., like let x = x in x
19:27:06 <dmwit> Twey: ...that is to say, my understanding was that memoization involved the transformation of a function into one that stores known inputs in a cache; the transformation that lifts "expensiveComputation" is a very different one
19:27:22 <Jesin> Ralith: anything that performs IO, for one thing.
19:27:40 <Twey> dmwit: I guess it's the old ‘zero-argument function’ potato
19:27:56 <Ralith> Jesin: definitely not computation :P
19:28:05 <Twey> Ralith: let x = x in x
19:28:43 <Ralith> Twey: is that computation?
19:28:46 <khyperia> looks like http://hackage.haskell.org/package/file-embed is pretty nifty
19:28:59 <lingxiao> hey all, whats the terset way to express this computation:
19:29:00 <Twey> dmwit: But the wiki has http://www.haskell.org/haskellwiki/Memoization#Memoising_CAFS
19:29:09 <Tekmo> khyperia: Never mind.  I can't find it
19:29:17 <dmwit> Twey: Right. So I'm just flat wrong.
19:29:33 <lingxiao> parameter : [(1,""), (1, "b"), (2, "c")]. result [(1, ["","b"]), (2, "c")]
19:29:58 <Twey> dmwit: Perhaps, but I wouldn't have been surprised if you were right.  :þ
19:30:05 <lingxiao> so basically given a list of tuples mapping key to value, put all values mapping to same key into a list
19:30:15 <lingxiao> so [(a,b)] -> [(a,[b])
19:30:27 <Twey> I think memoizing a CAF is the same as memoizing a function, except that you only store one argument value
19:30:40 <Twey> Er, s/one argument value/the value at one argument/
19:30:42 <dmwit> lingxiao: Map.fromListWith (++) [(k, [v]) | (k, v) <- xs]
19:31:08 <dmwit> Data.Map.fromListWith, I mean
19:31:16 <lingxiao> dmwit: ok cool sweet
19:31:20 <Jesin> I'm looking for a function that will redirect the stdin, stdout, and stderr of a given IO operation to given file handles.
19:31:26 <Twey> lingxiao: That doesn't typecheck; did you mean [(1, ["", "b"]), (2, ["c"])]?
19:31:58 <lingxiao> Twey : yeah oops forgot the second set of brackets
19:32:00 <Jesin> It might have type (Handle -> Handle -> Handle -> IO a -> IO a)
19:32:08 <lingxiao> thanks
19:32:13 <Jesin> Does such a thing exist?
19:33:09 <Ralith> lingxiao: consider IntMap too
19:33:19 <dmwit> Jesin: http://hackage.haskell.org/package/unix-2.7.0.0/docs/System-Posix-IO.html#v:dupTo ?
19:33:51 <Twey> lingxiao: map (\((n, v) : xs) -> (n, v : map snd xs)) $ groupBy (on (==) fst) [(1, "a"), (1, "b"), (2, "c")]
19:34:13 <jmcarthur_mobile> danharaj, djahandarie: it was nick confusion, not face confusion
19:34:52 <Twey> I'm pretty sure I've written this function before and I came up with something nicer
19:35:02 <Twey> lingxiao: Oh, that also assumes your keys are in order.
19:35:03 <hsiu> Can anybody help me with a simple problem I'm not sure how to simply word? http://lpaste.net/96113
19:35:22 <lingxiao> Twey: ok I will digest that guy too, thanks !
19:35:37 <Twey> But yes, you might be using the wrong datatype
19:36:58 <ion> hsiu: runResourceT :: ResourceT IO a -> IO a
19:36:59 <danharaj> edwardk: Don't take this pull request to be an invitation to slap me with commit privileges because they won't be used ;)
19:37:43 <Aetherspawn> hsiu: I think you're looking for lift/liftIO
19:37:53 <Aetherspawn> <- lift $ BS.readFile ..
19:37:56 <hsiu> ion: but I want to go the other direction
19:38:03 <ion> hsiu: Oh, sorry, i read too hastily.
19:38:20 <Aetherspawn> http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-IO-Class.html
19:39:08 <Aetherspawn> when I first started haskell, lift was like the scariest damn thing in the whole language
19:39:18 <Twey> > Data.IntMap.toList . Data.IntMap.fromListWith (flip (++)) . Prelude.map (second return) $ [(1, "a"), (1, "b"), (2, "c")]
19:39:18 <lambdabot>   Not in scope: `Data.IntMap.toList'Not in scope: `Data.IntMap.fromListWith'
19:39:19 <Aetherspawn> 1) I was naive, edwardk's libraries are scarier
19:39:22 <Aetherspawn> and 2) you get used to it
19:39:23 <Twey> Aww.
19:39:36 <edwardk> hah
19:39:39 <danharaj> curse yooouuu`
19:39:40 <Twey> Heh
19:39:43 <hsiu> aether: well, to be honest I still don't entirely understand it, though I'm starting to get a sort of intuition for it - not exactly the same thing
19:39:55 <hsiu> aether: but i swear i tried that... trying again
19:40:04 <Aetherspawn> I don't understand its implementation, really, I just know that it moves you one thing right in the transformer stack
19:40:08 <Twey> Aetherspawn: It's the curse of being a developer: software only ever increases in complexity
19:40:40 <hsiu> i'm not sure how to annotate it, though
19:40:46 <dmwit> I think there's a quote around here somewhere about how edwardk used to think category-extras was a big package until he learned how to do "big" correctly.
19:40:58 <Aetherspawn> I also know that with certain transformers you can move more right than the last monad in the stack and get the most ^&*('d up errors in the universe
19:41:10 <edwardk> =)
19:41:12 <Twey> Aetherspawn: Its implementation is generally the simplest thing you can imagine
19:41:31 <danharaj> category-extras was great
19:41:39 <danharaj> there are still some things in it that haven't been moved out
19:41:43 <danharaj> (that I have used)
19:41:46 <lilred> Is there a good IRC channel for UI design?
19:41:48 <dmwit> Make a package!
19:41:54 <dmwit> I'll link to it from category-extras.
19:42:03 <benzrf> hello
19:42:04 <danharaj> I only listen to that suggestion when my boss says it ;)
19:42:12 <benzrf> i do not know anything about monad transformers but i hear they're cool
19:42:18 <benzrf> also i should probably learn about the state monad
19:42:41 <dmwit> You might like "All About Monads".
19:43:10 <dmwit> I think that was the one I learned transformers from, and I like to think I came out OK.
19:43:11 <relrod> benzrf: http://vimeo.com/73648150 is a good presentation about monad transformers, too.
19:43:22 <benzrf> what about the state monad, will i learn about that?
19:43:27 <dmwit> yes
19:43:39 <benzrf> cool
19:44:19 <benzrf> tbp i'm trying to implement a simple lisp/scheme [not from a tutorial], and i'm using Either for eval to account for possible errors, along w/ returning a pair of the var env & the result
19:44:36 <benzrf> and from what i've heard, statet onto either might be what I want to simplify it??
19:44:53 <chrisdone> benzrf: farlo, as they say in italian
19:45:04 <chrisdone> (or fallo, in Starsky & Hutch, =p)
19:45:05 <hsiu> ah... it was the type annotation.... i see - thank you æther, even though it's frustrating when something works that you sorta almost but not quite there tried
19:52:25 <benzrf> wait hmm
19:52:25 <TravisD> Does anyone know of diagnostic tools for learning? I was hoping to be able to sort of visualize the evaluation of expressions or something
19:52:34 <benzrf> so how does State really work as a moand?
19:52:35 <benzrf> *monad
19:52:37 <chrisdone> vacuum!
19:52:48 <chrisdone> http://thoughtpolice.github.io/vacuum/
19:52:55 <chrisdone> huh, no pictures anymore
19:53:00 <benzrf> it looks to me like:
19:53:07 <chrisdone> why don't a project about making pictures got no picture 'samples
19:53:08 <benzrf> - a is data
19:53:14 <benzrf> - m a is data + state
19:53:15 <chrisdone> https://raw.github.com/thoughtpolice/vacuum/master/gallery/list.png
19:53:25 <benzrf> therefore, (a -> m b) does not take state, but adds it
19:53:28 <benzrf> ??
19:53:56 <triliyn> m a is a function that takes a state and returns data + state
19:53:57 <TravisD> chrisdone: Looks like pretty much what I wanted :) I don't understand the notation in the example
19:54:04 <benzrf> triliyn: ohhh
19:54:07 <benzrf> hmm
19:54:45 <triliyn> (And the state type is part of the m)
19:54:47 <benzrf> ok so
19:54:48 <benzrf> hm
19:55:19 <benzrf> S s a == (s -> (s, a))
19:55:22 <benzrf> therefore
19:55:34 <Twey> benzrf: return x = \s → (s, x); f >>= g = \s → let (x', s') = f s in g x' s'
19:55:37 <benzrf> hold on
19:55:39 <Twey> Or something like that
19:55:41 <benzrf> let me work out the types
19:56:00 <TravisD> it would be really cool if someone made an interpreter that would show the vacuum graphs for the most recent expression or something
19:56:06 <benzrf> let m = (s -> (s, a) in m a -> (a -> m b) -> m b...
19:56:11 <benzrf> no wait
19:56:17 <benzrf> let m a = (s -> (s, a)) in m a -> (a -> m b) -> m b...
19:56:20 <benzrf> then...
19:56:22 <benzrf> we get
19:56:55 <benzrf> (s -> (s, a)) -> (a -> (s -> (s, b))) -> (s -> (s, b))
19:57:12 <benzrf> so... the functions being chained with >>= are themselves HOFs?
19:57:43 <Twey> benzrf: → associates to the right, so: (s → (s, a)) → (a → s → (s, b)) → s → (s, b)
19:58:08 <benzrf> ah
19:58:11 <benzrf> p:
19:58:15 * benzrf tries to parse the madness
19:58:22 <Twey> (though the last pair might be helpful)
19:58:54 <benzrf> hmm, let's use concrete types...
19:59:09 <benzrf> let's say the individual calc type is LispVal, and the State type is Env
19:59:10 <benzrf> ;p
19:59:15 <benzrf> so we get...
19:59:53 <Twey> That's going to give you a = b = LispVal, which may be appropriate in your case but might confuse you re. learning State
20:00:00 <benzrf> ah, true
20:00:05 <benzrf> then let's use
20:00:06 <benzrf> hmmm
20:00:15 <benzrf> a = LispList, b = LispFunc
20:00:18 <benzrf> let's say it's a lambda form
20:00:19 <benzrf> :u
20:00:19 <Twey> Pretend you distinguish LispInt and LispString?  Or you could just use Int and String ;)
20:01:01 <benzrf> (Env → (Env, LispList)) → (LispList → Env → (Env, LispFunc)) → Env → (Env, LispFunc)
20:01:05 <benzrf> ok let me try to parse this
20:01:06 <benzrf> @_@
20:01:28 <benzrf> uggggh 10:48 pm is way too late for highly abstract fp
20:01:29 <benzrf> D:<
20:01:40 <benzrf> i wanna write me some good old imperative code dammit
20:01:48 <joneshf-laptop> what's a haskell-esque way to represent a map/dictionary/hast table?
20:01:54 <benzrf> joneshf-laptop: use a Map?
20:01:59 <benzrf> or just an assoc list
20:02:03 <benzrf> :t lookup
20:02:03 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
20:02:06 <benzrf> :t Data.Map.lookup
20:02:07 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
20:02:14 * joneshf-laptop feels dumb
20:02:17 <joneshf-laptop> thanks
20:02:17 <benzrf> =]
20:02:26 <benzrf> ok again
20:02:27 <benzrf> 22:48 < benzrf> (Env → (Env, LispList)) → (LispList → Env → (Env, LispFunc)) → Env → (Env, LispFunc)
20:02:30 <benzrf> erm
20:02:54 <benzrf> uh
20:02:56 <benzrf> i got nothing
20:03:01 <benzrf> this seems oddly complex
20:03:32 <benzrf> ok
20:03:34 <benzrf> bind takes
20:03:59 <benzrf> - a stateful func, and a func taking a value and a stateful func, and makes a new stateful func ?
20:04:16 <benzrf> *and making a stateful func
20:04:46 <joneshf-laptop> no wonder i couldn't find that, map + haskell = 90% about the function
20:04:53 <benzrf> heh`
20:05:05 <benzrf> well, lookup on assoc lists is in the Prelude
20:05:05 <benzrf> :i
20:05:10 <benzrf> i mean :u
20:05:24 <benzrf> (Env → (Env, LispList)) → (LispList → (Env → (Env, LispFunc))) → (Env → (Env, LispFunc))
20:05:44 <benzrf> given a stateful func...
20:05:58 <benzrf> and a func that takes the result, and produces a new stateful func...
20:06:01 <benzrf> we get a new stateful func
20:06:22 <benzrf> THE FIRST ARG IS A REGULAR STATEFUL FUNC AND THE SECOND ARG IS THE HOF THAT COMPOSES THEM
20:06:25 <benzrf> OR
20:06:26 <benzrf> SOMETHING
20:06:27 <benzrf> I LOST IT
20:06:58 <benzrf> IT'S MULTI-ARG COMPOSITION USING AN INTERMEDIARY TO CREATE CLOSURES???
20:07:07 <ion> wat
20:07:14 <dwcook> benzrf, are you aware you're typing in caps?
20:07:22 <benzrf> sorry im kinda excited
20:07:24 <benzrf> <_>
20:07:26 <Kams_> I've been reading LYAH and  I thought I knew monads somewhat, but then when I watched http://www.youtube.com/watch?v=ZhuHCtR3xq8 I became more confused :(
20:07:38 <benzrf> Kams_: it's just the type
20:07:40 <benzrf> no more no less
20:08:04 <benzrf> :t (>>=)
20:08:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:08:10 <benzrf> that's it.
20:08:24 <benzrf> if you think of a functor as being a 'wrapped type'
20:08:27 <benzrf> or a 'type with context'
20:08:42 <benzrf> a monad is a method of chaining functions that generate context in addition to regular returns
20:08:48 <TravisD> benzrf: I guess in addition to the type there are the monad laws
20:08:52 <benzrf> i.e. funcs of type (a -> m b)
20:08:58 <benzrf> this includes:
20:09:11 <benzrf> - funcs that take a and produce b, plus logging [writer monad]
20:09:15 <Kams_> Right, so I got proper understanding from LYAH
20:09:22 <benzrf> - funcs that take a, and produce b + possibly failure [maybe]
20:09:31 <benzrf> - funcs that take a, and produce multiple b's
20:09:46 <benzrf> basically  if you understand functors, just imagine a method of chaining functions that return functors
20:10:10 <ion> You don’t “return functors” (at least in Haskell).
20:10:14 <benzrf> w/e
20:10:26 <Kams_> Beefed up applicative functors (right?)
20:10:28 <benzrf> one way to think about it is being like functors, but each function can modify the structure
20:10:51 <benzrf> in a regular functor, a function can be mapped such that it modifies the contents without touching the structure
20:10:58 <benzrf> in a monad, it does that plus it can add to the structure
20:11:41 <benzrf> so if Writer were a functor, it would map over the value and leave the 'log' alone
20:11:44 <benzrf> as a monad, you can add to the log
20:11:58 <benzrf> Maybe as a functor leaves the failure state alone and maps over the contents, in a sense
20:12:05 <benzrf> as a monad, it does that plus you can add failure
20:12:27 <Kams_> Makes sense
20:13:47 <benzrf> as a functor, IO lets you add a callback to pass the output through
20:13:56 <benzrf> as a monad, it lets you add more IO actions to this one as well
20:14:17 <benzrf> this is why monads can also be defined in terms of join instead of in terms of bind [>>=]
20:14:41 <benzrf> bind can be seen as applying the 'wrapped value', then joining the output with the current structure
20:16:47 <benzrf> if you think of a monadic value as being a tuple of (structure, data) [obviously not really always feasible, or even making sense], then you could say `(s, d) >>= f = (join s ns, nd) where (ns, nd) = f d'
20:17:14 <benzrf> clearly this doesn't really work with lists unless you really stretch it
20:17:22 <benzrf> but it's one way of looking at emaphis
20:17:23 <benzrf> *em
20:23:29 <chrisdone> ircbrowse now has a calendar view http://ircbrowse.net/calendar/haskell
20:23:46 <chrisdone> and a recent view, with messages in reverse order, for easy following/catching up http://ircbrowse.net/day/haskell/today?mode=recent
20:26:45 <emaphis> benzrf: wat?
20:27:38 <Aetherspawn> oh wow, my other nick I forgot the password to is in the nick cloud
20:27:46 <Aetherspawn> ;__; I talk too much.
20:29:44 <benzrf> emaphis: i mis typed
20:29:51 <benzrf> i tend to press tab a lot
20:29:54 <benzrf> like
20:29:57 <benzrf> too much
20:30:04 <benzrf> mostly at the end of typing stretches
20:30:05 <emaphis> :-)
20:30:07 <chrisdone> and return
20:30:10 <benzrf> yeah...
20:30:21 <benzrf> no, i got into the habit of pressing tab, then bksp
20:30:31 <Aetherspawn> chrisdone: what is most active nicks based on
20:30:32 <emaphis> emacs?
20:30:34 <benzrf> which is fine when youre editing text in notepad or something
20:30:35 <Aetherspawn> messages?
20:30:46 <chrisdone> yeah
20:30:50 <benzrf> emaphis: no i use vim
20:30:52 <chrisdone> "Lines"
20:31:05 <benzrf> although i am aware that someday i should switch to emacs + evil
20:31:08 <Aetherspawn> surprised to see some of the people there
20:31:14 <Aetherspawn> I never see them speak outside blah or #ghc
20:31:17 * chrisdone added an auto-refresh to the recent page
20:31:19 <benzrf> ...maybe
20:31:33 <chrisdone> Aetherspawn: where are you looking?
20:31:43 <Aetherspawn> its probably my timezone
20:32:20 <Aetherspawn> well, during the day for example, I don't usually see you speak
20:32:22 <danharaj> Scarily, Cale's activity is invariant of timezone.
20:32:30 <Aetherspawn> carter I never see outside #ghc
20:32:38 <carter> arkeet: what?
20:32:40 <chrisdone> Aetherspawn: yeah, it's 5am for me right now
20:32:41 <Aetherspawn> lol
20:32:48 <carter> Aetherspawn: what
20:33:00 <arkeet> carter: what?
20:33:03 <arkeet> oh
20:33:03 <Aetherspawn> what?!
20:33:10 <carter> arkeet: sorry, auto complete got me fooled
20:33:12 <emaphis> wat!!!!
20:33:17 <Aetherspawn> w4tttt
20:33:19 <carter> go on blah :p
20:33:21 <arkeet> I usually put in more than one letter before autocompleting. :p
20:34:40 <scottj> arkeet: in irssi you could prevent that by putting no letters in before autocompleting, that way it uses the author of the last msg
20:35:14 <scottj> or complete_lastspoke.pl, guess it's not standard
20:35:26 <carter> hehe
20:35:32 <carter> i use a gui'd tool
20:35:38 <chrisdone> the auto-refreshing is quite usable
20:35:39 <emaphis> not in erc/emacs That tries to autocomplete irc commands.
20:36:11 <chrisdone> sometimes it's nice to just look at the logs without having the ability to chat
20:36:27 <Platz> benzrf: i like you're way of describing monads - haven't it heard it said quite as nicely as that yet
20:36:32 <Platz> your
20:36:51 <benzrf> :D
20:36:57 <benzrf> feels good to hear that
20:37:04 <benzrf> im always afraid that i'm explaining things poorly
20:37:05 <benzrf> :|
20:37:34 <benzrf> also sorry, but.... i think you mean your
20:37:38 <benzrf> not you're
20:37:38 <benzrf> ;p
20:39:29 <chrisdone> monochrom: let's maybe put http://ircbrowse.net/day/haskell/today?mode=recent in the channel topic! =)
20:40:11 <Aetherspawn> I think people overcomplicate the explanations of monads..
20:40:34 <chrisdone> yup
20:41:10 <Aetherspawn> coming from C++ people came up in denial of all these crazy explanations for them
20:41:19 <Platz> But I think there are different ways to look at them - different people focus on different things
20:41:56 <Platz> douglas crockford just cares about chaining for example and ignores the laws
20:42:23 <benzrf> well arent the laws just to enforce chaining working properly
20:43:04 <Aetherspawn> I think the laws are a distraction
20:43:07 <Aetherspawn> and personally they are confusing
20:43:14 <emaphis> I focus on the monads a form of food metaphors.
20:43:18 <benzrf> emaphis: ha
20:43:23 <benzrf> Aetherspawn: i thought they were p. simple
20:43:30 <benzrf> @where monad lwas
20:43:30 <lambdabot> I know nothing about monad.
20:43:33 <benzrf> @where monadlaws
20:43:33 <lambdabot> http://www.haskell.org/haskellwiki/Monad_Laws
20:43:36 <Aetherspawn> if you just describe monads as different kinds of boxes they are easy to grog
20:43:50 --- mode: ChanServ set +o monochrom
20:44:00 <Platz> odersky talks about Try[T] in scala in a for comprehension, and it doesn't satisfy one of the laws, but still useful
20:44:00 <benzrf> >return a >>= f
20:44:00 <benzrf> ≡ 	
20:44:02 <Platz> http://stackoverflow.com/questions/20168677/violation-of-the-second-monad-law-for-futures-in-scala
20:44:03 <benzrf> oops
20:44:14 <benzrf> return a >>= f ≡ 	f a
20:44:15 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=everything | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub' by monochrom
20:44:25 <benzrf> seems simple to me
20:44:48 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub' by monochrom
20:44:55 --- mode: monochrom set -o monochrom
20:45:07 <benzrf> it just means that the rules you use to pull an arg out of the monad should be the same as how return puts one in
20:45:22 <benzrf> m >>= return ≡ 	m
20:45:24 <benzrf> similar
20:45:42 <benzrf> if you take a value out of m, then put it back into a new one, you should end up with the same thing
20:45:56 <benzrf> & associativity just makes sense to prevent confusion
20:47:23 <Platz> yes.  I'm just saying there are cases where that's ignored
20:47:37 <Platz> haven't seen it in haskell yet, but in other languages
20:48:31 <monochrom> the laws formalize the chaining idea
20:49:37 <monochrom> therefore, the laws are a distraction iff the chaining idea is a distraction
20:50:58 <monochrom> therefore, it is illogical to say: "the point of monad is ____, the laws are a distraction". iff you are right about ___ being the point, the laws formalize exactly that. there is no escape.
20:50:59 <chrisdone> monochrom: thanks =)
20:51:25 <monochrom> unless you say, logic is a distraction. at that point, I'll just swear at you and move on.
20:52:03 <benzrf> im watching a video and the dude is flopping between 'HASS-kull and hass-KELL'
20:52:07 <monochrom> see also: http://www.haskell.org/haskellwiki/Monad_laws
20:52:35 <Platz> https://dl.dropboxusercontent.com/u/9264537/week8-4.pdf
20:53:07 <Platz> Hence,
20:53:07 <Platz> Try
20:53:07 <Platz> trades one monad law for another law which is more useful in
20:53:07 <Platz> this context:
20:53:07 <Platz> An expression composed from ‘Try‘, ‘map‘, ‘flatMap‘ will never
20:53:14 <Platz> throw a non-fatal exception.
20:54:52 <Platz> That is from Martin Odersky's coursera class (creator of Scala).  I think he knows what he's doing
20:54:54 <ion> What’s that language?
20:55:00 <ion> ok
20:55:19 <Platz> but you're not wrong, it's just a different way of using some of the same ideas
20:55:25 <Platz> in my opinion
21:38:59 <joelteon> ok
21:39:44 <Hodapp> ok?
21:39:59 <joelteon> wrong channel!
21:46:00 <emaphis> ok!
21:48:34 <NemesisD> man i really love it when my program works without typ annotation yet when i put in the type annotation that ghc complains i am misisng it does not type check
21:51:20 <enthropy> then you're needing something like -XScopedTypeVariables
21:53:36 <NemesisD> hmm, still giving me some problems this thing is fairly difficult to paste
21:53:58 <NemesisD> keeps expanding type synonyms so i can't really follow the types anyways
21:54:21 <NemesisD> i wonder if type holes would help
21:55:33 <NemesisD> i have 2 mutually recursive functions (i think that term fits here) so i can't seem to coyly get ghc to tell me what the types are
21:55:38 <NemesisD> at the same time*
21:55:59 <NemesisD> i wonder if type holes would help
21:59:38 <NemesisD> it is starting to set in that this may have only compiled because i had a sum type with 1 constructor to start with and only now am adding more
22:05:53 <NemesisD> i guess one solution is to just throw it in a where so i don't have to annotate it :(
22:09:16 <TravisD> Someone was talking about structural editing for Haskell in emacs
22:09:41 <TravisD> can someone point me towards this emacs mode?
22:10:42 <NemesisD> enthropy: ok that made things a bit less confusing, but the where doesn't seem to be using scoped type variables:
22:12:20 <NemesisD> expected type Either HAError b0 -> Proxy x'0 x0 () ByteString (StateT (Producer Text m0 r0) m0) a0... actual Either HAError b0 -> Proxy x'0 x0 () ByteString (StateT (Producer Text m1 r1) m1) a0
22:12:38 <NemesisD> ugh, love that type alias expansion
22:15:02 <NemesisD> haskell's type inferencer needs to write my damn program for me and stop wasting my time
22:15:09 <sevak> testing
22:17:08 <sevak> hi people, I am trying to solve the following, and would like some feedback on my thought process, instead of an outright answer
22:18:31 <sevak> http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf I'm doing exercise 1 of the credit card question
22:19:22 <sevak> and my thinking is to convert the integer to a string using show
22:20:05 <sevak> then to use the read function to convert each character in the string to an int
22:21:01 <sevak> using gates to check for any int <= 0
22:21:26 <sevak> does that sound like a good strategy?
22:22:19 <sevak> I'm having issues with the read function when trying it this way
22:22:37 <sevak> any help is appreciated, thanks
22:22:59 <emaphis> sevak: holy smokes, pretty tough 1st assignment. :-)
22:23:42 <sevak> ya hehe, at least for me it is at this point
22:24:06 <scott_> That looks exactly like the assignment I had for Haskell last year I guess my prof didn't make them himself
22:24:54 <sevak> it says adapted from Uni of Utecht
22:25:04 <scott_> Or maybe I saw that somewhere else not sure now
22:26:52 <scott_> sevak: You can do show/read digits that way, or you could repeatedly div and mod by 10
22:26:57 <emaphis> sevak: Are you doing the class through FPComplete?
22:27:00 <lpaste> NemesisD pasted “Can't annotate with inferred type” at http://lpaste.net/96123
22:27:19 <NemesisD> could someone with better type fu than me please tell me what i'm doing wrong around line 46?
22:27:24 <scott_> sevak: If you want to read the individual digits in the string make sure you wrap them in strings first, you can read "1" but you can't read '1'
22:27:30 <NemesisD> this code compiles when i remove annotations
22:27:45 <mzero> sevak: I'd think show/read is somewhat of a cop-out - I don't think it is what the assignment is after
22:28:00 <scott_> sevak: Better yet, you can just use Data.Char.digitToInt
22:28:17 <scott_> :t digitToInt
22:28:18 <lambdabot> Char -> Int
22:28:18 <emaphis> NemesisD: what do you get when you :type the unannotated code?
22:29:29 <emaphis> NemesisD: if it's different. just use that annotation. :-)
22:29:59 <Aetherspawn> NemesisD: lmfao
22:30:02 <Aetherspawn> that error is ridiculous
22:30:10 <sevak> emaphis: no, what is fpcomplete?
22:30:20 <Aetherspawn> I would almost report an error that bad as a GHC glitch...
22:31:17 <mzero> sevak: converting the number to a string using show feels to me like saying "I don't know how to convert a number to a string of its base 10 digits.... so I'll use the oracle to do it - then fiddle the text back into numbers"
22:31:40 <sevak> thanks scott, emaphis, mzero
22:31:58 <sevak> ya, I agree mzero
22:32:00 <mzero> to point at scott_'s, direction: not only is there div and mod functions, there is the very lovely divMod function
22:32:02 <mzero> :t divMod
22:32:03 <lambdabot> Integral a => a -> a -> (a, a)
22:32:25 <NemesisD> i'm starting to think this code may need an additional type parameter to work
22:32:47 <emaphis> sevak: https://www.fpcomplete.com/, they use university of Pa's class material in an online class of theres.
22:33:00 <emaphis> theirs.
22:33:26 <sevak> Is it not as efficient though to make all those divisions?
22:34:01 <sevak> I was trying to do it through division on paper
22:34:32 <mzero> sevak: how do you think show does it? :-)
22:35:09 <mzero> besides, you are perhaps prematurely optomizing - the HW says nothing about efficiency!
22:35:27 <NemesisD> emaphis: :type says the same as the inferencer. i think it gets confused when recursing
22:35:28 <sevak> haha ya you got me there
22:35:48 <sevak> true as well
22:36:06 <sevak> so I should look into divMod then
22:36:28 <NemesisD> im really losing track of what this fremonad business buys me
22:36:28 <mzero> try some in ghci - or via lambdabot
22:38:04 <sevak> sorry how do I use lambdabot, I have ghci, but curious
22:38:25 <mzero> > 42 `divMod` 10
22:38:27 <lambdabot>   (4,2)
22:38:32 <mzero> like that!
22:38:34 <emaphis> @help
22:38:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:38:57 <emaphis> ,help
22:39:02 <mzero> (and yes, idiomatic use of divMod is to use it as an infix operator like that!)
22:39:02 <sevak> 45 `divMod` 5
22:39:08 <mzero> you need the >
22:39:14 <grogtree> I started The Haskell Road to Logic, Maths, and Programming
22:39:15 <mzero> > 145 `divMod` 10
22:39:15 <lambdabot>   (14,5)
22:39:16 <emaphis> > help
22:39:17 <lambdabot>   Not in scope: `help'
22:39:18 <sevak> >45 `divMod` 5
22:39:21 <sevak> > 45 `divMod` 5
22:39:23 <lambdabot>   (9,0)
22:39:25 <grogtree> "It is convenient to define LD (least divisor) in terms of a second function, LDF, for the least divisor starting from a given threshold, k, with k <= n. Thus, LDF(k)(n) is the least divisor of n that is >= k. Clearly LD(n) = LDF(2)(n)"
22:39:30 <grogtree> what does the last sentence mean?
22:39:34 <sevak> oh nice
22:39:58 <mzero> sevak - you can also private message lambdabot, and have it calculate your bidding, without spamming the channel if you need to explore more than one or two expressions
22:39:59 <emaphis> now you can unistall your compiler. :-)
22:40:19 <sevak> hehe
22:41:21 <mzero> Ew, exercise 2 in that problem set is uneccisarily tricky
22:41:25 <Aetherspawn> lets be honest, the only useful lambdabot thing that GHCI doesn't have is @pl
22:41:33 <joelteon> my ghci has pl
22:41:36 <scott_> My ghci has pl :P
22:41:39 * emaphis checks to see if haskell-mode can use lamdabor as REPL
22:41:47 <Aetherspawn> how do you install pl
22:41:52 <joelteon> you just define it
22:41:56 <scott_> cabal install pointfree
22:42:15 <pavonia> Is there a Parsec parser for escaped Haskell strings somewhere, basically like read?
22:42:21 <joelteon> :def pl (\x -> return (":!pointfree '" ++ x ++ "'"))
22:42:39 <Aetherspawn> do I need to put that in a config file
22:42:41 <Aetherspawn> or only run it once?
22:42:46 <scott_> In ~/.ghci
22:42:47 <joelteon> i'd put that in ~/.ghci
22:42:50 <joelteon> otherwise you'll have to run it every time
22:43:23 <Aetherspawn> cool, thanks
22:43:39 <sevak> hmm, I'll have a go at it soon
22:44:08 * emaphis is a noob, doesn't understand point free.
22:44:55 <Aetherspawn> > fst . snd $ (1,(2,3))
22:44:56 <lambdabot>   2
22:45:16 <scott_> emaphis: Basically the idea is that (\x -> f x) is the same as just f by itself; there's no need to mention x.
22:45:22 <scott_> @pl \x -> f x
22:45:22 <lambdabot> f
22:46:05 <scott_> And there's lots of other tricks you can use to avoid having named variables like that
22:46:08 <mzero> or for example       doubleThem xs = map (*2) xs      can just as well be written   doubleThem = map (*2)
22:46:11 <scott_> @pl \x y -> f y x
22:46:12 <lambdabot> flip f
22:46:30 <Aetherspawn> joelteon: can you give an example of ghci usage
22:46:36 <Aetherspawn> :t pl doesn't work
22:46:36 <lambdabot>     Not in scope: `pl'
22:46:36 <lambdabot>     Perhaps you meant one of these:
22:46:36 <lambdabot>       `pi' (imported from Prelude),
22:46:42 <scott_> Aetherspawn: :pl \x -> f x
22:46:45 <Aetherspawn> and pl "anything" gives an error
22:46:48 <Aetherspawn> oh :
22:47:11 <Aetherspawn> woah thats awesome
22:47:17 <scott_> :)
22:49:59 <joelteon> @let tup 0 = "()"; tup n = "(" ++ tup (n - 1) ++ "," ++ tup (n - 1) ++ ")"
22:50:00 <lambdabot>  Defined.
22:50:01 <joelteon> > tup 5
22:50:03 <lambdabot>   "((((((),()),((),())),(((),()),((),()))),((((),()),((),())),(((),()),((),()...
22:50:16 <joelteon> @undef
22:50:16 <lambdabot> Undefined.
22:50:47 <emaphis> heh, paredit on steroids.
22:52:08 <NemesisD> hmm, i find it strange that things will typecheck fine until i extract functions into the where block then all the sudden it fails to carry with it the context it had in the main function body
22:52:25 <NemesisD> is this something i have to solve by annotating the where clauses and use ScopedTypeVariables?
22:52:40 <joelteon> yeah you have to use scoped type variables
22:53:17 <NemesisD> but that's not enough, because i'm already doing that, so i do have to annotate as well?
22:54:21 <joelteon> I believe you have to explicitly use forall
22:55:10 <NemesisD> joelteon: in the outer function's type signature?
22:55:15 <enthropy> what is the actual change?
22:55:16 <joelteon> yeah
22:55:30 <NemesisD> i never know where to put the forall, before the typeclass?
22:55:45 <joelteon> depends on what you're using it for
22:55:50 <enthropy> some stuff like    f = (1,1) --  f2 = (x,x) where x= 1 -- f2 has a more restricted type
22:55:57 <joelteon> usually it's of the form foo :: forall a. Foo a => a -> ...
22:56:17 <joelteon> but sometimes you'll have some of the form (forall a. a -> a) -> b
22:56:21 <joelteon> and so on
22:56:31 <NemesisD> yikes
22:58:57 <pavonia> @pl \_ s _ -> s
22:58:57 <lambdabot> const const
23:01:26 <ion> The forall just limits the scope of the type variable.
23:03:41 <sevak> thank you guys, took note of your replies, I'm off to search the topics you mentioned and to try again
23:03:59 <ion> Well, actually… In (forall a. a -> a) -> b, it lets the receiver of the (forall a. a -> a) parameter pick the a.
23:04:19 <ion> Perhaps i shouldn’t try to explain anything when i’m this tired. :-P
23:07:07 <ion> “forall b. (forall a. a -> a) -> b” can be imagined like “{b} -> ({a} -> a -> a) -> b” where {x} is a concrete type for x.
23:27:07 * hackagebot lord 1.20131124 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-1.20131124 (rnons)
