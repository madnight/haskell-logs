00:00:03 <chrizz> hi all, the source code of Control.Exception.assert is surprisingly small (assert prop r = r)
00:00:16 <mm_freak> adas: deleting ~/.cabal/{bin,lib,share} is optional, btw…  i do it to get rid of outdated files in one sweep
00:00:16 <smith_> mm_freak: Ah, thank you. I don't see that in the haddock pages for lens anywhere; where does it come from?
00:00:21 <chrizz> how does this function work, then? is there special logic in GHC to look for a function called "assert" and treat is specially?
00:00:36 <mm_freak> smith_: start GHCi, :m +Control.Lens, :i Lens'
00:00:43 <mm_freak> that shows you where it's defined
00:01:08 <adas> cabal: unrecognized option `-j4'
00:01:11 <smith_> mm_freak: Oh, hey! Thank you. I never noticed that it showed the package name.
00:01:29 <mm_freak> adas: cabal --version
00:01:42 <adas> cabal-install version 0.14.0
00:01:42 <adas> using version 1.14.0 of the Cabal library
00:01:42 <mm_freak> smith_: the module name =)
00:01:55 <mm_freak> adas: that's a bit out of date
00:02:03 <mm_freak> did you install the haskell platform?
00:02:25 <smith_> mm_freak: Gah. Yes, that. And I know why I didn't see it in the docs now--I was looking way back at lens-1.2!
00:02:44 <mm_freak> smith_: that explains it =)
00:03:10 <mm_freak> smith_: you can enable 'documentation' in ~/.cabal/config
00:03:19 <adas> mm_freak: i did install the haskell-platform. i have ghc 7.4.1 in the platform
00:03:35 <mm_freak> smith_: then cabal-install installations will put the corresponding documentation into ~/.cabal/share/doc
00:03:43 <mm_freak> adas: that's an old platform then
00:03:51 <mm_freak> adas: the current haskell platform has GHC 7.6.3
00:03:52 <smith_> mm_freak: I do have that enabled, but I was searching the haddock documentation through Google, which took me to the outdated page.
00:04:07 <mm_freak> smith_: ah
00:04:27 <adas> ubuntu has only the oldest platform..hmm
00:04:39 <adas> so ill download it from the website directly
00:04:59 <mm_freak> adas: happy building =)
00:05:22 <adas> mm_freak: is there any other way?
00:05:46 <mm_freak> adas: not sure…  if you're lucky you can find binary releases compatible with ubuntu
00:06:01 <lpaste> paf31 pasted “Lens” at http://lpaste.net/95096
00:06:11 <mm_freak> i don't think it's helpful to say that development is a nightmare on ubuntu =)
00:06:24 <paf31> smith_, thiat seems to do the job, if you didnt find it already
00:06:57 <smith_> paf31: Figured it out, and that's pretty much what I got. Thanks!
00:07:03 <paf31> cool
00:07:20 <paf31> i was figuring it out too :)
00:07:26 <paf31> really must spend more time on Lens
00:07:54 <mm_freak> i'm still waiting for the killer use case for lenses =)
00:08:28 <paf31> id quite like to understand prisms
00:08:37 <paf31> they seem to correspond to some sort of first order pattern
00:08:47 <mm_freak> they correspond to virtual constructors
00:09:30 <mm_freak> consider Either (Maybe String) Integer
00:09:41 <mm_freak> there is a constructor Left and a constructor Just
00:09:50 <mm_freak> prisms allow you to compose them
00:09:55 <paf31> i see that you can compose two prisms to get a string
00:09:57 <paf31> or a maybe string
00:10:17 <paf31> im interested to see if you can compose prisms in more ways
00:10:20 <mm_freak> > Left (Just "abc") & _Left . _Just %~ map toUpper
00:10:25 <lambdabot>   Left (Just "ABC")
00:10:38 <paf31> e.g. say you have an AST : data Expr = Const Int | Bin Op Expr Expr
00:10:40 <paf31> or something
00:11:22 <mm_freak> how do you want to compose them?
00:11:24 <paf31> can you use prisms on Expr to pull out chains of terms in such a way that you respect the precedence rules for the various operators
00:11:34 <paf31> a la chainl, chainr from parsec
00:12:02 <mm_freak> that's not how they work
00:12:05 <paf31> my intuition is that prism ~ a -> Maybe b
00:12:22 <paf31> and you can compose those kleisli arrows in that way
00:12:32 <paf31> so i just wonder if Prisms could be used that way too
00:12:32 <mm_freak> there is an intermediate step between Bin and the subexpressions
00:12:57 <paf31> but for any op, there is a prism from Expr to (Expr, Expr)
00:12:59 <mm_freak> example: _Bin . leftArg . _Bin . rightArg . _Const
00:13:07 <paf31> then you can compose those with snd
00:13:09 <paf31> and recurse
00:13:34 <mm_freak> Bin { _op :: Op, _leftArg :: Expr, _rightArg :: Expr }
00:14:27 <mm_freak> prisms aren't really much more than lenses for fields that may not exist
00:15:39 <mm_freak> that's why they are the natural candidates for sum components, aka constructors
00:15:51 <mm_freak> in a very informal way lenses correspond to products, prisms correspond to sums
00:16:09 <mm_freak> or rather:  product components, sum components, resp.
00:18:49 <paf31> makes sense, thanks
00:18:58 <paf31> i think i get that much
00:19:20 <paf31> one thing that i find odd is that youd expect there to be some sort of duality here
00:19:27 <paf31> but it seems assymetric
00:19:48 <mm_freak> well, products and sums are mutually dual =)
00:19:52 <paf31> in that prisms look like lenses with possible failure
00:20:01 <paf31> but can you express lenses in terms of prisms?
00:20:57 <mm_freak> you can express both in terms of 'optics' as edwardk calls them
00:21:11 <mm_freak> they are both special cases of the same concept
00:21:11 <paf31> do you have a link?
00:21:26 <mm_freak> only a search term:  van laarhoven lenses
00:21:28 <paf31> that seems like it would be helpful
00:21:31 <paf31> ah right
00:21:45 <paf31> spj's talk gave me a pretty good intuition there
00:22:51 <dv-> why does Data.Foldable.mapM map over just the values instead of (key, value)s?
00:25:56 <mm_freak> dv-: Foldable has no notion of keys
00:26:29 <mm_freak> also mapM is Traversable
00:26:32 <mm_freak> Foldable only has mapM_
00:29:28 <augur> programmers who complain about having to write type annotations are are just making up problems
00:29:36 <augur> haskell should force you to annotate with types
00:29:51 <augur> and when people complain, we tell them "go write C without annotating with types and then come back to me."
00:30:16 <mm_freak> main = (print :: (Show a) => a -> IO ()) ((1 :: Integer) + (1 :: Integer) :: Integer)
00:30:19 <mm_freak> like that?
00:30:23 <augur> lol
00:30:27 <augur> no declarations
00:31:16 <mm_freak> haskell does it just fine…  it practically forces you to write type signatures for top-level definitions; everything else is optional
00:31:24 <mm_freak> (except when it isn't)
00:32:16 <augur> (print :: (Show (a :: *)) => (a :: *) -> ((IO :: * -> *) (() :: *))) ((1 :: (Integer :: *)) `((+) :: (Num (a :: *)) => (a :: *) -> (a :: *) -> (a :: *)))` (1 :: (Integer :: *)) :: (Integer :: *))
00:32:26 <augur> mm_freak: haskell does it just fine but i dont care
00:32:49 <augur> we dont need inference. its completely unnecessary and the big guns in programming abolished it a LONG time ago
00:32:56 <augur> are we competing with Python, or with C?
00:33:10 <augur> because if we're competing with C, we can tell the complainers to piss off back to python land
00:43:10 <mm_freak> augur: not having type inference forces you to fully define every lambda, which can get quite annoying…  the proper solution is to use safe abstractions, not to introduce arbitrary, unnecessary rules
00:43:32 <augur> like i said, top level defs
00:43:35 <augur> lambdas dont count
00:43:57 <mm_freak> you didn't say that =)
00:44:07 <augur> you said the silly thing
00:44:08 <augur> and i said
00:44:09 <augur> "no declarations"
00:44:32 <augur> whereby i meant, you have to give types to your declarations
00:44:43 <augur> actually yeah, not just top level, but where's too
00:44:53 <mm_freak> i see…  commas can change the meaning of a statement a lot ;)
00:45:19 <mm_freak> anyway, haskell practically forces you to write type signatures for top level definitions
00:45:35 <mm_freak> otherwise you will run into trouble sooner or later anyway
00:46:53 <augur> yeah but we still boast that you can leave types out, etc.
00:47:04 <augur> so i'd say just force types, and tell the complainers to piss off back to python
00:47:40 <mm_freak> that's marketing =)
00:47:56 <augur> well, its also a language change :P
00:55:11 <mm_freak> augur: what do you think about map vs. fmap?  what about list vs. monad comprehensions?  are you pissed off by the fact that Control.Category is expensive to import?
00:55:26 <augur> what?
00:55:45 <mm_freak> augur: i'm going to make a point, but i need your answer to make it ;)
00:56:10 <augur> i reject the idea that its expensive to import!
00:56:23 <mm_freak> import Control.Category; import Prelude hiding ((.), id)
00:56:37 <mm_freak> i call that expensive
00:56:42 <augur> good for you!
00:56:59 <augur> but no, im not pissed off my having to do that
00:57:49 <mm_freak> i see
00:58:23 <mm_freak> are you saying that because you like the current state or because you don't want to help my point? ;)
00:58:36 <mm_freak> IMO Category should be in the Prelude
00:58:37 <augur> tho i think some language IDE support could be added, maybe? i dont know, i dont have much of a problem with it
00:59:06 <augur> mm_freak: you asked a question, you got your answer! if your point dependent on the answer, maybe you shouldn't've made it a question! :P
00:59:12 <mm_freak> ok, i may make heavier use of Category…  i import it into almost every module i write
00:59:51 <mm_freak> reason:  (by historical accident) the types of (.) and id are arbitrarily restricted
01:00:00 <mm_freak> and arbitrary restrictions piss me off
01:01:13 <mm_freak> same thing about list comprehensions:  as far as i know we used to have monad comprehensions, then they got specialized to list comprehensions and now you need a language extension to access them
01:02:16 <augur> i think not having monad comprehensions is good. i mean, the syntax isnt that much heavier
01:02:38 <augur> [ m | x <- n ]   vs   do x <- n ; m
01:02:40 <mm_freak> i don't use either, so i don't care about those much
01:02:51 <mm_freak> the point is:  arbitrary restrictions will always affect some serious programmer
01:03:36 <augur> "affect" for some definition of affect that means basically "give them reason to complain about some triviality"
01:04:00 <mm_freak> that's not a triviality…  some people write the function before they write the type signature
01:04:08 <mm_freak> those people will now have to change their programming style
01:04:30 <mm_freak> because of an arbitrary restriction "to make python programmers go back to python" ;)
01:04:38 <augur> mm_freak: yes, they will. big deal?
01:04:45 <augur> those people probably write crappy code anyway! :P
01:05:30 <mm_freak> augur: that's nonsense…  you're just imposing your religion on them ;)
01:05:42 <augur> mm_freak: all programming languages are impositions of religion
01:07:01 <augur> also also
01:07:10 <augur> in the newest flavors of haskell we have all these nutty things like
01:07:23 <augur> data kinds, type family function things, etc etc
01:07:35 <mm_freak> haskell's religion is type-safe freedom…  it's an excellent language for EDSLs
01:07:37 <augur> what dependent stuff is no longer possible?
01:07:49 <mm_freak> unlike python haskell doesn't sell itself as a language that forces you to write in "clean style" =)
01:07:52 <augur> i mean, once you get these, it seems like you're into the domain of dependent types
01:08:08 <augur> mm_freak: oh nonsense. haskell promotes itself that way every day
01:08:15 <augur> well, clean meaning
01:08:23 <mm_freak> haskell does not have dependent types
01:08:24 <augur> maybe not clean style, thats emergent from the clean meaning
01:08:38 <augur> mm_freak: yes i know thats the claim, but im asking what aspects of dependent types we're not getting
01:09:08 <augur> its it the non-erasable data in the types?
01:09:27 <augur> i dont know if data kinds let you properly bind things
01:09:31 <augur> like, i know you can do Vecs
01:09:34 <augur> but can you do
01:09:55 <mm_freak> augur: you don't get /anything/ like dependent types…  you're just emulating them
01:10:15 <augur> well i cant think of an example actually
01:10:26 <augur> mm_freak: you're not really emulating them with data kinds
01:10:36 <mm_freak> yes, you are, because you still need lifting
01:10:45 <augur> yeah yeah yeah
01:10:45 <mm_freak> the levels are separate, there is no direct passing between them
01:11:02 <augur> right thats what i mean, you cant have these functions that necessarily cannot erase
01:11:10 <mm_freak> dependent records would be an example
01:11:18 <mm_freak> sigma types
01:11:30 <augur> sigmas yeah, ok, thats an idea
01:11:34 <augur> but like
01:11:39 <augur> so heres my problem then
01:11:41 <mm_freak> predicate types
01:11:51 <mm_freak> like agda's Pred
01:11:58 <mm_freak> which denotes a subset type
01:12:04 <Matthias|PC> Could someone help me come up with a couple ideas of how to implement this? (not asking for any code), but I can't even seem to figure out _how_ to do this.. It's stressing me out majorly. Basically I need to parse a mathematical function, as such:
01:12:04 <augur> no those arent strictly ruled out
01:12:06 <Matthias|PC> run parseExp "sin(5^3^2*5+1-3)+cos(3)+logtwo(cos(5+sin(3*x)))"
01:12:07 <Matthias|PC> Just (Add (Sin (Add (Mul (Pow (Lit 5.0) (Pow (Lit 3.0) (Lit 2.0))) (Lit 5.0)) (S
01:12:07 <Matthias|PC> ub (Lit 1.0) (Lit 3.0)))) (Add (Cos (Lit 3.0)) (LogTwo (Cos (Add (Lit 5.0) (Sin
01:12:07 <Matthias|PC> (Mul (Lit 3.0) (Var "x"))))))))
01:12:11 <Matthias|PC> ah crap, too long (sorry)
01:12:13 <augur> Pred A is just A -> *
01:12:20 <augur> which is obviously a datakind
01:12:22 <Matthias|PC> my first idea was to parse all "tokens" into a list
01:12:26 <augur> but you couldnt also use the A
01:12:40 <Matthias|PC> so ["sin", "(", "5", "^", "3"..
01:12:41 <augur> but mm_freak, simon says you need a PhD for this dependent types stuff
01:12:43 <Iceland_jack> Matthias|PC: You can take a look at something like Parsec
01:12:47 <Matthias|PC> what is that?
01:12:59 <mm_freak> Matthias|PC: parsec gives you that almost for free
01:13:08 <Iceland_jack> You should be able to find information about it online Matthias|PC :)
01:13:12 <mm_freak> augur: i don't have a PhD, and i understand it =)
01:13:14 <Matthias|PC> alright, will look, thank you guys :)
01:13:32 <augur> but at this point, the difference between dependent types and data kinds + gadts + type functions is so minimal that you either need a PhD to understand the difference between haskell and idris, or simon's wrong
01:13:33 <mm_freak> augur: anyway, the point is that haskell has infinitely many levels, while a dependently typed language has only two
01:13:36 <augur> and im pretty sure simon's wrong
01:13:46 <augur> er, maybe you mean that backwards :)
01:13:53 <mm_freak> no, i mean it like i said
01:14:01 <mm_freak> haskell:  values, types, kinds, sorts, …
01:14:08 <mm_freak> agda:  values, types
01:14:11 <augur> uh
01:14:14 <augur> no thats not true at all
01:14:18 <mm_freak> it is
01:14:23 <augur> haskell stops at types, at least for what you can refer to
01:14:31 <mm_freak> (A : Set) -> A -> A
01:14:39 <augur> yes
01:14:43 <augur> but that's not a Set
01:14:48 <augur> (A : Set) -> A -> A : Set1
01:14:51 <mm_freak> A is of type Set, the second argument is of type A, etc.
01:14:52 <augur> Set1 = Kind
01:14:59 <augur> Set1 : Set2
01:15:05 <augur> Set2 = Sort
01:15:10 <mm_freak> you're using the same ":" everywhere
01:15:13 <augur> yes i am
01:15:15 <mm_freak> in haskell you have multiple "::"
01:15:21 <augur> not in the syntax you dont!
01:15:22 <mm_freak> one for types, one for kinds, etc.
01:15:29 <mm_freak> and you can't mix them
01:15:29 <augur> maybe in the underlying type theory
01:15:35 <mm_freak> yes, exactly
01:15:38 <augur> but anyway my real point mm_freak
01:15:51 <mm_freak> that alone is a fundamental difference, which prevents you from implementing many things
01:16:06 <augur> is that the outward facing language is now basically indistinguishable from idris, say, except some finer points that are themselves actually MORE confusing than the full dependent type stuff
01:16:26 <mm_freak> it is
01:16:36 <augur> it is more confusing, you mean?
01:16:39 <mm_freak> (n : Nat) -> NonZero n -> …
01:16:46 <mm_freak> you pass the proof as an argument
01:17:12 <augur> yes, this is true
01:18:51 <mm_freak> what would be on different, separate levels in haskell i can mix freely in idris, agda and all other dependently typed languages
01:19:05 <augur> yes
01:19:13 <mm_freak> that's why we need singleton types in the first place in haskell, because the levels are separate
01:19:21 <augur> yes yes
01:20:14 <mm_freak> id :: forall (a :: *). a -> a
01:20:16 <mm_freak> two different "::"
01:20:26 <augur> how many times are you going to repeat yourself? :P
01:20:31 <mm_freak> id : (A : Set) -> A -> A
01:20:33 <mm_freak> the same ":"
01:21:04 <mm_freak> i'm stressing this as /the/ difference ;)
01:21:18 <augur> yes i said that a long time ago, mm_freak :P
01:21:24 <augur> before you did
01:22:30 <mm_freak> then i don't understand why you're disagreeing ;)
01:22:41 <augur> im not!
01:23:03 <mm_freak> <augur> no thats not true at all
01:23:10 <augur> mm_freak: yes, i misinterpreted what you meant
01:23:24 <mm_freak> alright =)
01:23:37 <augur> which was, i thought, clear way back when i said "but anyway my real point mm_freak"
01:23:53 <mm_freak> error: no parse
01:23:54 <mm_freak> =)
01:24:05 <mm_freak> if that's supposed to be a self-contained statement
01:24:14 <augur> no, its a continuation of the previous one
01:24:42 <augur> im sure some people will point out that this is an example of why i need to back off the return key. im trying. im addicted! :(
01:25:02 <mm_freak> just pretend you're on a laggy connection ;)
01:27:47 <augur> mm_freak: fwiw ive seen some people comment that data can be used on the right of the same : as always, it just literally is always empty
01:28:06 <augur> so that the phantom nats and the real nats just are the same thing
01:28:12 <augur> i dont know if anything goes wrong by saying that
01:28:29 <augur> i think thats merely a grammar thing
01:28:47 <augur> because in neither case do you have a type theory where M :: 1 is provable, for some M
01:28:50 <Matthias|PC> do x <- try(parseICon)<|>try(parseIVar)<|>parseAdd -> what is this <|> notation?
01:28:54 <augur> oh but i guess in haskell, undefined :: 1
01:28:58 <augur> so that wouldnt be desirable
01:29:15 <augur> Matthias|PC: its an applicative parser widget
01:29:32 <Matthias|PC> a what? o.o
01:29:47 <augur> Matthias|PC: learn more haskell then return to that :)
01:29:55 <Matthias|PC> ok :p
01:30:11 <Hafydd> Matthias|PC: it's from Alternative.
01:30:21 <Hafydd> :t <|>
01:30:22 <lambdabot> parse error on input `<|>'
01:30:26 <mm_freak> augur: a lot goes wrong by saying that, because Nat is only a kind
01:30:27 <Hafydd> :t (<|>)
01:30:28 <lambdabot> Alternative f => f a -> f a -> f a
01:30:33 <mm_freak> it has no type-level counterpart
01:30:37 <Matthias|PC> ah ok
01:30:42 <augur> Matthias|PC: hm?
01:30:54 <augur> oh yes, right, well. whatever.
01:30:56 <augur> anyway.
01:49:44 <AshyIsMe> hmm, cabal install lushtags fails for me on osx
02:03:05 <Chat2192> Hii
02:35:35 <kqr> Matthias|PC, <|> is a function that first "runs" its first argument, and if it succeeds it returns the result, otherwise it "runs" the second argument and returns the result of that. if both fail, it fails
02:35:45 <Matthias|PC> kqr: thank you!
02:36:07 <kqr> Matthias|PC, for very vague definitions of "run" and "result"
02:36:27 <Matthias|PC> it was something I found @ StackOverflow, was just wondering what it did :p
02:37:08 <mm_freak_> kqr: and "first" and "second" =)
02:37:13 <kqr> mm_freak_, that as well
02:38:09 <kqr> Matthias|PC, in this case, it is used to parse something when it is not sure what that something is yet. the sub-parsers are tried in order 'til one can make sense of whatever's being parsed
02:38:28 <kqr> Matthias|PC, parser combinators are very powerful in that you can combine them together like that with very little code
02:38:30 <Matthias|PC> ah great, that'll come in very handy :p
02:38:44 <Matthias|PC> kqr: thank you so much for your time :)
02:42:01 <jophish_> Yo yo yo
02:42:09 <Axman6> ho ho ho!
02:45:22 <augur> it seems like the need for roles is due entirely to the fact that haskell lacks proper type functions
02:45:36 <augur> and also because its type functions allow you to match on types
02:46:54 <augur> im not sure quite how these type functions are really supposed to be used, anyway, except for data kind stuff. i think they're also used in type classes?
02:57:09 <jophish_> :( No Haskell counterpart to clang-format
03:00:31 <seanparsons> Is anyone using syntastic in vim with cabal?
03:03:10 <augur> hmm
03:03:24 <augur> these type functions internal to type classes are just existential types it seems
03:03:54 <tavarish> hi, I'm trying to purge projects installed by cabal to start over
03:04:00 <tavarish> so I "rm -Rf .cabal"
03:04:01 <augur> theres a lotof repetition that doesnt seem necessary tho
03:04:08 <augur> but i guess its because they're type functions
03:04:18 <tavarish> but each time I try to install something with cabal, cabal complains about the already installed package
03:04:38 <tavarish> does someone know where are the others cabal stored files ?
03:06:12 <supki_> tavarish: ~/.ghc
03:06:20 <supki_> seanparsons: yes, via hdevtools
03:06:49 <tavarish> supki_, ho, i must purge GHC too
03:06:51 <tavarish> thank you
03:06:59 <seanparsons> supki_: Is there a good guide on how to get that all rigged up?
03:11:50 <supki_> seanparsons: well, there is a vim-hdevtools README: https://github.com/bitc/vim-hdevtools/blob/master/README.md
03:11:58 <seanparsons> Aha.
03:12:06 <supki_> seanparsons: if you want to work with cabal sandboxes you will need to do some work though
03:12:27 <supki_> seanparsons: i.e. you hdevtools_options will look like these: https://github.com/supki/liblastfm/blob/develop/.vim.custom
03:12:36 <supki_> s/you/your/
04:05:58 <jophish_> Is anyone here familiar with Language-Haskell-Exts-Pretty?
04:06:10 <jophish_> I'd like to make a couple of modifications
04:06:43 <jophish_> For example, do expressions are always placed on a new line, even if their width is short enough to be placed on the same line
04:08:03 <jophish_> multiline do expressions*
04:11:57 <jophish_> In fact, the same goes for case expressions
04:23:01 <jophish_> niklasb: about?
04:23:38 <lingxiao> hey all I have a super rudimentary question and it's really  irking me.. if i have this transformer stack:
04:23:40 <lingxiao> stack2 :: StateT String IO ()
04:23:40 <lingxiao> stack2 = lift . print $ "hello"
04:23:44 <lingxiao> how do I run it?
04:24:09 <lingxiao> oh wait nevermind
04:24:25 <tavarish> lingxiao, "runStateT stack2 undef"
04:24:31 <lingxiao> haha, forgot to type the T
04:24:40 <lingxiao> grrr... :\  but thanks
04:24:42 <lingxiao> !
04:25:00 <tavarish> s/undef/undefined/
04:46:20 <chrisdone> pharaun: yeah, adding it to the config file seems reasonable
04:48:59 <chrisdone> gmail seems to be showing code samples from haskell-cafe as syntax-highlighted haskell. how?
04:49:33 <chrisdone> does haskell-cafe's mailman have a syntax highlighting plugin?
04:51:36 <haasn> edwardk: I think there's been a grave misunderstanding
04:52:08 <haasn> I needed one or two Haskell stickers, not a roll of 1000!
04:54:21 <AshyIsMe> haha, what do the stickers look like?
04:55:34 <donri> chrisdone: it's up to the author to send html no?
04:56:02 <AshyIsMe> so im trying to install lushtags on osx with: cabal install lushtags
04:56:04 <donri> chrisdone: i use a plugin for rendering markdown, including highlighting
04:56:13 <AshyIsMe> but it fails because vector-0.9.1 has 6 errors
04:57:25 <donri> chrisdone: looks like nickolay kudasov is using the same plugin as me
04:58:12 <donri> chrisdone: https://github.com/adam-p/markdown-here
04:58:15 <chrisdone> donri: ah it's a plugin
04:58:27 <haasn> AshyIsMe: Haskell logos
04:59:28 <AshyIsMe> Data/Vector/Fusion/Stream/Monadic.hs:1310:4:
04:59:28 <AshyIsMe>      error: invalid preprocessing directive
04:59:28 <AshyIsMe>       #-}
04:59:29 <AshyIsMe>        ^
04:59:34 <AshyIsMe> 6 of those errors
05:02:26 <FreeFull> AshyIsMe: Maybe it requires a newer version of GHC?
05:03:11 <jophish_> AshyIsMe: osx 10.9?
05:03:28 <jophish_> This is an issue with using clang instead of gcc
05:03:37 <jophish_> a quick fix is to compile this module yourself
05:04:00 <jophish_> and anywhere you get this error put the line starting with #-} at the end of the preceding line
05:04:12 <AshyIsMe> ah ok
05:04:12 <jophish_> so that # isn't the first character on a line
05:04:15 <AshyIsMe> yeah latest osx
05:04:32 <AshyIsMe> ghc 7.6.3 btw
05:23:11 <AshyIsMe> wow this is tedious
05:23:24 <AshyIsMe> the errors just keep coming
05:24:35 <jophish_> AshyIsMe: tell me about it
05:24:45 <jophish_> ANother option would be to install gcc
05:25:23 <AshyIsMe> ah yeap, might try that
05:26:11 <AshyIsMe> any idea which version?
05:26:15 <AshyIsMe> brew suggests gcc47
05:28:51 * AshyIsMe sighs
05:28:59 <AshyIsMe> if only osx was built on linux instead of bsd aye
05:29:15 <AshyIsMe> it's almost as good a dev environment, almost
05:30:51 <donri> it's more their anti-gpl policy that cripples it methinks
05:32:02 <Hodapp> OS X generally works well for me, until it gets into one of its "What? No. Nothing is wrong." states and then the entire Apple community echoes it.
05:32:15 <d3lxa> how do you describe the strong type-system of haskell, where you don't have sub-typing? In scala for example type "union" always find something (Any) whereas Haskell won't, it's a safer/stronger type-safety (for me), is there a name for this?
05:34:48 <donri> Hodapp: trying to use gcc? you're holding it wrong!
05:35:59 <jophish_> AshyIsMe: I much prefer clang to gcc for everything but haskell preprocessing
05:36:36 <epta> What is the difference between `:: A x' and `A a => a x' ?
05:36:36 <Hodapp> I'd use Clang on my MSP430 if I could.
05:36:42 <jophish_> I had to get a new keyboard after haskell made me type so strongly.
05:37:17 <donri> epta: A is a type constructor or a constraint constructor, respectively
05:37:22 <d3lxa> jophish_: great =)
05:38:21 <donri> epta: for example if you say, Num a => a -> a -> a, this function works with any type that is an instance of Num, but each "a" must be the same
05:40:55 <donri> epta: if constraints didn't need to be named and haskell allowed us to write, Num -> Num -> Num, we can no longer express that each Num must be the same type, that's why we need the =>
05:42:45 <AshyIsMe> jophish_: haha
05:45:30 <donri> jophish_: all cherry mx super black right
05:47:12 <AshyIsMe> cherry browns are my favourite out of the brown and blues that i have
05:48:00 <donri> browns are for weak typing, only 45 cN. super black is 150 cN, stiffest of the lot!
05:48:34 <AshyIsMe> haha
05:49:06 <AshyIsMe> argh, my poor mba, compiling gcc is killing it
05:49:18 <AshyIsMe> lushtags can wait i guess
05:52:01 <Fuuzetsu> AshyIsMe: But Apple™ products don't have any issues. Especially not heating or anything.
05:52:07 <jophish_> donri: 1.5N wow
05:52:36 <donri> inorite
05:52:36 <jophish_> AshyIsMe: I wouldn't hold your breath waiting for gcc
05:52:48 <Hodapp> mleh, I just tried to build GCC on my desktop and it failed quickly about my C preprocessor not being sane
05:52:52 <Hodapp> oh well, I'll look at it later
06:02:02 * hackagebot BlogLiterately 0.7 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7 (BrentYorgey)
06:07:45 <AshyIsMe> i guess it's not gcc i care about really, if vector would build with clang that'd be great
06:08:14 <AshyIsMe> those lines that were failing had whitespace before the #-} but i guess it must have been getting stripped somewhere?
06:14:15 <moops> if i want to just play around with parser combinators is parsec gonna be too heavy?
06:14:25 <chrisdone> no parsec is good
06:14:57 <moops> cool
06:17:33 <donri> moops: but attoparsec is simpler, IME
06:29:30 <moops> ill keep that in mind if it gets too hairy
06:29:44 <moops> hard to imagine it being hairier than lex/yacc though :P
06:39:32 <hpc> moops: there's nothing hairier than yacc - http://www.rarebreeds.co.nz/yak.jpg
06:43:38 <moops> haha
07:06:47 <lpaste> ghorn pasted “GHC.Generics "Could not deduce (a ~ b)"” at http://lpaste.net/95098
07:07:32 <ghorn__> i've been stumped by this ^ for a while, it's a really simple generic deriving thing which I might not be allowed to do
07:07:32 <chrisdone> ghorn: ghoooooorn. now that's a nice, woody, word
07:07:59 <ghorn__> thank you
07:17:26 <ghorn__> hmm... my problem actually has nothing to do with generics
07:19:09 <lpaste> ghorn annotated “GHC.Generics "Could not deduce (a ~ b)"” with “Could not deduce (a ~ b) (annotation)” at http://lpaste.net/95098#a95099
07:19:41 <enthropy> ghorn__: you could add `a' to the class GFoo
07:20:00 <enthropy> instance Foo b => GFoo (K1 i b) b where
07:20:06 <chrisdone> z
07:20:08 <enthropy> oops it's called b there
07:20:32 <enthropy> or you can write a   type family GetBFromK1 a
07:21:13 <enthropy> pretty much just saying that   GFoo a b | a -> b
07:21:21 <HugoDaniel> hi
07:21:29 <enthropy> hi
07:22:25 <ghorn__> hello
07:23:24 <ghorn__> enthropy: :O
07:23:51 <enthropy> there are lots of ways to encode exactly the same thing
07:24:34 <enthropy> instance (Foo b, b ~ b') => GFoo (K1 i b) b' where -- the above fundep is practically just for this instance now
07:24:55 <ghorn__> i see how that typechecks into the program I want, but I still don't see why it is necessary
07:25:35 <enthropy> because when you write    gfoo :: f a -> Blah a
07:25:56 <enthropy> and don't have that `a' mentioned in the line above, it means that you aren't allowed to restrict that `a'
07:26:08 <enthropy> instances have to allow any `a'
07:26:29 <enthropy> but you're trying to constrain that `a' to have an instance `Foo a'
07:26:50 <enthropy> hmm, you could also do it with ConstraintKinds
07:32:32 <ghorn__> what do you mean that `a' isn't mentioned in the line above?
07:32:44 <ghorn__> you mean this line? "instance Foo a => GFoo (K1 a) where"
07:34:19 <moops> wow im in love with parsec
07:34:35 <enthropy> yes
07:35:04 <ghorn__> so you mean, it's not mentioned as a "top-level" type?
07:36:39 <enthropy> aye
07:37:03 <lpaste> enthropy annotated “GHC.Generics "Could not deduce (a ~ b)"” with “Could not deduce (a ~ b) (annotation) (annotation)” at http://lpaste.net/95098#a95100
07:37:14 <enthropy> there are three ways
07:37:49 <enthropy> I guess you could also have the constraint as a parameter to the class
07:38:17 <enthropy> class GFooCC2 f cxt where gfooCC2 :: cxt f a => f a -> Blah a
07:39:08 <ghorn__> thank you!
08:11:04 <frxx> @pl \x -> Just (2^x, x+1)
08:11:08 <lambdabot> Just . ap ((,) . (2 ^)) (+ 1)
08:11:08 <lambdabot> optimization suspended, use @pl-resume to continue.
08:15:01 <Philonous_> @type (^2) &&& (+1)
08:15:02 <lambdabot> Num a => a -> (a, a)
08:15:17 <Philonous_> frxx, see above
08:16:28 <frxx> nice
08:16:45 <Philonous_> @type Just . ((^2) &&& (+1))
08:16:46 <lambdabot> Num a => a -> Maybe (a, a)
08:17:57 <Philonous_> frxx, The pointful version is arguably clearer and certainly shorter, though
08:18:55 <frxx> agreed
08:26:23 <enthropy> are there pattern quasiquoters for Language.Haskell.TH.Syntax.Type?
08:27:26 <enthropy> it is pretty ugly to convert   '[ LVPair "x" t, LVPair "y" s ]  into a value with type [String]
08:37:30 <moops> is there a builtin map type that stores old values? kind of like a map of stacks?
08:37:50 <moops> basically looking for this sort of behavior "Hashtbl.add tbl x y adds a binding of x to y in table tbl.    Previous bindings for x are not removed, but simply    hidden. That is, after performing Hashtbl.remove tbl x,    the previous binding for x, if any, is restored.    (Same behavior as with association lists.)"
08:38:05 <moops> i dont know if it has a name
08:38:17 <enthropy> you can use something like   Map k (Map age v)
08:38:27 <elliott> Map k [a]
08:38:32 <enthropy> or that
08:38:43 <moops> i guess so
08:38:45 <moops> okay thanks
08:41:46 <donri> :t M.insertWith mappend
08:41:47 <lambdabot> (Ord k, Monoid a) => k -> a -> M.Map k a -> M.Map k a
08:42:01 <moops> was just trying to puzzle that out
08:42:03 <moops> thanks :)
08:42:07 <donri> \o/
08:52:20 * hackagebot parsers 0.10.1 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.10.1 (EdwardKmett)
08:59:27 <jmcarthur> moops: if you will always be removing bindings in exactly the reverse order that you inserted them, you can just use a stack of maps instead of a map of stacks. you can possibily even structure your code such that the stack is implicit, this way.
08:59:33 <jmcarthur> moops: i say this because this is a common case
09:00:06 <edwardk> oh neat, gereeter implemented my bit-hack for IntMap and it paid out performance wise =)
09:00:33 <jmcarthur> moops: e.g. if i want to add a binding to a map, do some stuff with it, then remove the binding, i could just call a function with the modified map and then "forget" that i ever modified it and just keep using the old one
09:01:40 <moops> oh stack of maps sounds simpler
09:01:52 <jmcarthur> edwardk: where does your parsers package fit into the spectrum of parsing libraries?
09:02:11 <edwardk> parsers is a common parsing combinator substrate you can use across them all
09:02:14 <moops> oh i just realized that the only reason ocamls needs to save old values is because its mutable
09:02:22 * hackagebot parsers 0.10.1.1 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.10.1.1 (EdwardKmett)
09:02:22 <jmcarthur> moops: yup
09:02:32 <moops> i see what you mean jmcarthur, thanks
09:02:33 <edwardk> trifecta uses it, it has instances for ReadP, parsec, you can write instances for attoparsec, uu-parsinglib, etc.
09:02:34 <jmcarthur> edwardk: ah, cool, okay
09:02:51 <edwardk> the benefit is they lift over monad transformers
09:03:13 <edwardk> which means that it silently upgrades everyone else's parsing combinator libraries with that functionality
09:03:30 <stbuehler> how can i debug stack space overflows?
09:03:34 <jmcarthur> edwardk: is CharParsing the meat of it? looks pretty simple
09:03:41 <companion_cube> moops: in ocaml you have persistent maps too
09:03:49 <edwardk> jmcarthur: CharParsing and TokenParsing
09:03:56 <jmcarthur> ah, thanks
09:04:15 <moops> yea, i just didnt use them when i was making an interpreter in ocaml because i was a noob :P
09:04:32 <jmcarthur> i like that ReadP is an instance
09:04:39 <jmcarthur> *has
09:05:50 <lpaste> enthropy pasted “oohaskell hiding self?” at http://lpaste.net/95101
09:06:14 <stbuehler> i defined a "newtype Matrix4x4 e = Matrix4x4 ((e,e,e,e),(e,..),...)", made a Num e => Num (Matrix4x4 e) instance; and no matter what i try m^(10^50000) doesn't want to fit in my 8MB stack
09:06:25 <stbuehler> (i used e = Int for testing)
09:07:50 <chrisdone> anyone got a lines :: Data.ByteString.ByteString -> [Data.ByteString.ByteString]?
09:08:06 <rasfar> stbueler, not sure but have you seen http://www.haskell.org/haskellwiki/Stack_overflow ?
09:08:14 <enthropy> there should be one in the .Char8 modules
09:08:28 <rasfar> *stbuehler, sorry
09:08:34 <enthropy> chrisdone
09:08:43 <Iceland_jack> @hoogle ByteString.lines
09:08:43 <lambdabot> Data.ByteString.Char8 lines :: ByteString -> [ByteString]
09:08:43 <lambdabot> Data.ByteString.Lazy.Char8 lines :: ByteString -> [ByteString]
09:08:43 <lambdabot> package hsparklines
09:09:41 <copumpkin> stbuehler: make it strict. Your 4-tuple of 4-tuples is going build up lots of thunks
09:09:45 <stbuehler> rasfar: that are some useful tips how to code, but nothing helps debugging
09:10:02 <chrisdone> enthropy: ah, coo'
09:10:14 <rasfar> ah, I see. / so increasing strictness puts more pressure on the heap and less on the stack?
09:11:38 <stbuehler> copumpkin: i'd like to have the constructor taking the "user-friendly" tuples; any way to tell ghc to unpack them / make them strict? (i'm using TH to generate the type)
09:12:59 <stbuehler> my .cabal file already has -funbox-strict-fields
09:15:30 <edwardk> jmcarthur: i wrote it mostly because i was sick of writing copies of parsec modulo the parser type itself ;)
09:16:14 <jmcarthur_mobile> Yeah. I, too, have wanted something like this, especially for ReadP. Glad you made it.
09:17:46 <rasfar> stbuehler: don't you just add bangs to the type?
09:17:56 <rasfar> newtype Matrix4x4 e = Matrix4x4 ((!e,!e,!e,!e),(!e,..),...)
09:18:09 <rasfar> Or is this enough? newtype Matrix4x4 e = Matrix4x4 (!(e,e,e,e),!(e,..),...)
09:18:31 <bgamari> rasfar, you can't make a type parameter strict
09:18:43 <bgamari> rasfar, you'll need to define a new type
09:18:46 <rasfar> oh, I see sorry
09:18:52 <osa1_> which xml parsing library should I use?
09:18:56 <bgamari> rasfar, no reason to be sorry!
09:19:22 <bgamari> rasfar, data Matrix4x4 e = Matrix4x4 !e !e !e !e !e !e ...
09:19:40 <rasfar> fair enough / yes, the latter is what I was thinking (started playing with Repa where it's recommended)
09:19:41 <bgamari> You might find it easier to build up the type from smaller types however
09:19:48 <bgamari> e.g.
09:19:57 <joelmo> how do i bind this variable 'res' to a number without using too many if then: https://gist.github.com/2aad02131dab7ec0f25c
09:20:06 <bgamari> data Vec4 e = Vec4 !e !e !e !e
09:20:15 <stbuehler> Vec4 (Vec4 e)
09:20:17 <bgamari> type Matrix4x4 e = Vec4 (Vec 4 e)
09:20:23 <stbuehler> or Vec4 !(Vec4 !e) ?
09:20:39 <stbuehler> hm k
09:20:43 <bgamari> Vec4's e fields are already strict
09:20:46 <stbuehler> yes
09:20:52 <chrisdone> joelmo: that's quite an array of misconceptions you have there
09:21:26 <stbuehler> i'll have to write a function to wrap the construction, as Matrix4x4 (Vec4 (Vec4 1 2 3 4)) (...)... is not nice to write :)
09:21:28 <chrisdone> joelmo: something like this will work: where res = case w of "nul" -> 0; "en" -> 1; [etc]
09:22:04 <bgamari> stbuehler, sure
09:22:06 <chrisdone> joelmo: (replace semi-colons with newlines)
09:22:44 <joelmo> chrisdone: i already tried this but i get a parse error:  (possibly incorrect indentation or mismatched brackets)
09:23:50 <geekosaur> indentation matters, yes
09:24:22 <joelmo> ah i got the indentation right
09:24:28 <joelmo> thank you chrisdone
09:30:15 <enthropy> is there a parsec/trifecta parser that can parse haskell?
09:31:21 <chrisdone> does Ertugrul Söylemez idle on freenode?
09:31:44 <ski> joelmo : you don't use `num' ?
09:32:21 <chrisdone> his fastirc package on hackage doesn't build
09:32:38 <joelmo> ski: i dont know about num, will look it up
09:33:04 <ski> joelmo : in the recursive case, you name the accumulator parameter `num', but you don't use it
09:33:17 <ski> you tail-call with `res' as the accumulator, instead
09:33:52 <joelmo> ski: alright, that way i dont need to define taelle' ?
09:34:05 <ski> i don't know
09:34:11 <ski> depends on what you're trying to do
09:34:13 <edwardk> enthropy: not currently
09:35:06 <joelmo> ski: i know surrounding with `` is infix, but is `' something else?
09:36:06 <ski> yes, it's how i usually embed snippets of formal language in english sentences
09:36:31 <djahandarie> chrisdone, Ertugrul = mm_freak_
09:45:29 <rasfar> chrisdone, I just tried to build but I get:
09:45:33 <rasfar> attoparsec-0.10.4.0 (reinstall) changes: containers-0.5.0.0 -> 0.5.3.1
09:46:15 <chrisdone> djahandarie: ah, ok, thanks
09:46:23 <djahandarie> np!
09:46:23 <rasfar> Is it something similar for you? Because I got this same error earlier today trying to install pakcs (Curry).
09:46:39 <chrisdone> rasfar: yeah, it doesn't actually build with attoparsec that it specifies, i patched it locally
09:46:49 <chrisdone> nah, mine was
09:46:55 <rasfar> What does it mean "changes containers version"? then it says if it reinstalls it will break this and that.
09:47:00 <chrisdone> Network/FastIRC/Messages.hs:31:43:
09:47:00 <chrisdone>     Module `Data.Attoparsec.Char8' does not export `many'
09:47:08 <rasfar> i thought both versions of contains would coexist and be used as needed?
09:47:21 <mzero> rasfar: heed that warning - NEVER force reinstall a package
09:47:23 <rasfar> oh you get compile errors.
09:47:43 <rasfar> i've done it a few times ... but only reinstalling everything down the chain of dependancies.
09:48:05 <rasfar> what can I do about the above? I thought you could have multiple versions installed.
09:48:16 <mzero> and if you, then other things you installed a long time ago and aren't currently involved may well break down the line for no reason!
09:48:44 <mzero> you can have multiple versions installed - but a given version of package A can only depend on a single version of package B
09:49:39 <rasfar> but taking the above case, it goes on to say "will likely break <amonhaskell-platform-2013.2.0.0"g other things>
09:49:57 <rasfar> shouldn't these continue to use the version they were compiled with?
09:50:12 <rasfar> (oops)
09:51:08 <rasfar> I'm just concerned as that's twice today I've seen the same message regarding containers...
09:51:32 <mzero> consider:    there are A.1 and A.2 in the world...    B.1 needs some A,  C.1 needs B.1 and some A    when you install C.1 you get B.1 and A.2  (where B.1 and C.1 are built against A.2).....
09:51:55 <rasfar> I have two versions of platform and 4 versions of GHC on this system though, and haven't reinstalled world for about two years. Might be time.
09:52:01 <mzero> now you install D.1 that needs B.1 and explicitly A.1 .....   the problem is that B.1 was compiled against A.2, and now brings that in and yo uhave a conflict
09:52:11 <mzero> if you force reinstall B.1 (to use A.1).... now C.1 will break
09:52:33 <rasfar> thanks mzero, let me read that a few times...
09:53:18 <rasfar> i see.
09:53:23 <mzero> rasfar - each version of GHC is it's own package universe, so the long history with no cleaning may not be an issue: Each new GHC effectively statrs with a clean slate
09:53:46 <mzero> the other stuff is just wasting disk space unless you actively use those old GHCs
09:53:57 <rasfar> I thought so, although I haven't noticed that partition in my ~/.cabal tree
09:54:16 <fread2282> @pl lookupMetaMaybe key = maybe "" metaValueToText . lookupMeta key . meta
09:54:19 <lambdabot> lookupMetaMaybe = (maybe [] metaValueToText .) . (. meta) . lookupMeta
09:54:19 <lambdabot> optimization suspended, use @pl-resume to continue.
09:54:29 <rasfar> i use them occasionally when I want to try out a package which is broken with newer GHCs
09:54:59 <mzero> rasfar, depending on the .cabal/conf settings, and your OS - the division takes place at different parts of the tree
09:55:00 <Iceland_jack> When you have 4+ (.) in a single line, you're going to have a bad time :)
09:55:08 <rasfar> but I'd trade all such packages for a working cabal install to be sure
09:55:19 <mzero> look into individual packages and you should see somewhere in there directories named for the versino fo GHC
09:56:09 <mzero> fread2282: can't imagine @pl is going to make that look any better!
09:56:42 <rasfar> yeah you're right, ls ~/.cabal/lib* shows subdirs by GHC version
09:56:51 <rasfar> lib/* that is
09:57:00 <mzero> :-)
09:57:23 <fread2282> mzero: I had to try
09:57:24 <mzero> but you don't need to wipe them away to fix the current debacle, they don't interact
09:57:50 <rasfar> right, great
09:59:35 <rasfar> is there an option to force cabal install to recompile what is needful to avoid this? so in your example, D.1 would recompile it's own B.3 using compiled against A.1?
10:00:00 <rasfar> and if that's not possible, then the problem is inconsistency in the deps of D.1?
10:00:30 <rasfar> (I guess we could call that B.2)
10:01:18 <rasfar> since cabal is so avid in compiling everything, and multiple versions, I don't yet see why this problem has to arise. I'll give it more thought...
10:01:22 <mzero> rasfar - in B.1, I meant that .1 was the version --- the problem is that the GHC package system can handle multiple versions of a given package (okay to have A.1 and A.2 installed), but only one varient of each version --- to fix this you need B.1 compiled against A.1 and B.1 compiled agasint A.2 (since D  & C need different versions of A)
10:02:03 <mzero> in this case, one could seek out and recompile C, since it only needed some version of A, but a) C could have had a conflicting requirement, and b) C might not be installed... just sitting on disk somewhere!
10:02:17 <rasfar> I see, only one variant of each version. Wow. Is this a huge problem, or does it only arise infrequently?
10:02:27 <mzero> the only real answer today is to use Cabal 18 and use sandboxing for all your projects - installing nothing locally
10:02:28 * hackagebot BlogLiterately-diagrams 0.1.2.4 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.2.4 (BrentYorgey)
10:02:50 <mzero> rasfar - it arises quite frequently -
10:02:58 <mzero> it has it's own name: "cabal hell"
10:03:28 <rasfar> heh. i did just upgrade my cabal-install. will look into sandboxing, about which i presently know not a thing.
10:05:36 <mzero> [Note: Many other langage systems have this exact same problem, too: But most tools never flag the issue, and just go ahead and build with inconsistent versions. They get away with this becase a) APIs tend to only add, not remove, b) many are dynamically linked at a high langauge level, c) they rely on various fuzzy "DWIM" language semantics to run over the problems......   Of course, this introduces heinous hard to find bugs!]
10:06:38 <mzero> rasfar - it is very very easy to do with new cabal: http://www.haskell.org/cabal/users-guide/installing-packages.html#developing-with-sandboxes
10:06:46 <mzero> once set up on a project - you just ignore it!
10:08:15 <giogadi> I'm profiling an algorithm that calls minimumBy on a large list of elements. The comparison function is pretty intensive. However, when I profile the algorithm, instead of the comparison function taking up most of the time, it's the minimumBy function itself
10:08:29 <giogadi> is this some weird issue with lazy evaluation?
10:09:09 <giogadi> to be more accurate, I've re-implemented minimumBy to do be stricter and use foldl' instead
10:09:14 <mzero> it probably isn't wierd --
10:09:35 <mzero> my guess is that your comparison function isn't strict - it is just returning a "thunk" for the top most operation
10:09:45 <rasfar> (thanks mzero, i have that page open now)
10:10:16 <mzero> it isn't until minimumBy really really needs to know the value (so it can apply >) that the bulk of the comparison operation gets computed
10:10:32 <giogadi> okay; I'll see if I can strict-ify the comparison
10:10:42 <mzero> this may or may not be an issue at all
10:10:58 <mzero> for example - can you see the computations called by the comparison in the profile?
10:11:12 <giogadi> yes, but much lower down than the minimumBy call
10:11:14 <mzero> or is the comparison all primitive operations
10:11:35 <mzero> @src minimumBy
10:11:35 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:11:45 <giogadi> also, I noticed that most of the items being profile have nearly zero allocation, but the minimumBy takes 98% alloc
10:11:55 <giogadi> *being profiled
10:12:07 <glguy> Is the right way to accept exactly one connection from a set of listening sockets to forkIO one thread for each socket, threadWaitRead on each, and have each thread compete to write the ready socket to an mvar and then kill all the remaining threads?
10:12:16 <glguy> Just feels like a lot of work to write a select call
10:12:29 * hackagebot active 0.1.0.9 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.9 (BrentYorgey)
10:12:34 <rasfar> giogadi: let me guess, a Boards fan but geogaddi was already taken?
10:12:48 <mzero> I'd think the bigger issue is that minimumBy is going to call your comparison function twice for each element
10:12:58 <giogadi> rasfar: yeah that's how the nick came about years ago, and I just stuck with it =)
10:13:15 <ski> @src minimum
10:13:16 <lambdabot> minimum [] = undefined
10:13:16 <lambdabot> minimum xs = foldl1 min xs
10:13:29 <giogadi> ok, let me give you the source to my custom minimumBy
10:13:58 <lpaste> giogadi pasted “strict minimumBy” at http://lpaste.net/95102
10:15:04 <mzero> ah - I misunderstood - your comparison function is expensive --- that will be once per element of the list save 1
10:15:05 <giogadi> basically foldl1 -> foldl1'
10:15:21 <mzero> I was thinking you were computing a numeric value for each element, then comparing those
10:15:32 <giogadi> right
10:15:40 <giogadi> I mean, that's what's happening under the hood
10:16:02 <giogadi> I'm not really sure how to make the comparison function strict though
10:16:15 <Matthias|PC> http://pastebin.com/63LuKTCr -> could someone help me with that please?
10:16:20 <giogadi> does that mean making the arguments to the comparison strict?
10:16:30 <mzero> none the less - okay - that case should force the thunk
10:16:33 <rasfar> deepseq?
10:16:35 <mauke> The paste 63LuKTCr has been copied to http://lpaste.net/95103
10:16:58 <mzero> @src foldl1'
10:16:58 <lambdabot> Source not found. My mind is going. I can feel it.
10:17:14 <mzero> no need for deepseq - the value is Ord -- there's nothing deep there!
10:17:19 <glguy> Matthias|PC: () around Just(x,y)
10:17:29 <briennetheblue> Matthias|PC: Change "Just (x, y)" to "(Just (x, y))" i think
10:17:34 <Matthias|PC> glguy: ah ok, thanks! :)
10:17:46 <Matthias|PC> yep, that works, ty!
10:18:00 <rasfar> haha okay
10:18:08 <giogadi> could it just be an issue of the comparison function being "deep"? As in, the comparison function I'm passing to minimumBy' has quite a few layers
10:18:27 <giogadi> rasfar: favorite BoC album?
10:18:34 <chrisdone> Geogaddi!
10:18:36 <rasfar> Campfire Headphase
10:18:40 <chrisdone> no, wait! Music has the Right to Children!
10:18:46 <giogadi> oh rasfar here I was thinking you were cool
10:18:49 <giogadi> ;-/
10:19:00 <giogadi> it's a tossup between Music and Geogaddi for me
10:19:04 <rasfar> i actually like the Few Old Tunes boots
10:19:10 <giogadi> oh maaaaan I love few old tunes
10:19:22 <chrisdone> Twoism!
10:19:26 <giogadi> 5-9-78 especially
10:20:00 <rasfar> i don't have any song titles -- to be honest, it was a huge (now deceased) MP3 collection, very ill-sorted...
10:20:03 <chrisdone> the latest album… very atmospheric and soundscapey, but a couple BoC specials on there
10:20:14 <rasfar> they have a new album??
10:20:25 <giogadi> yeah! biggest music news of the year for me
10:20:26 <chrisdone> yeah, well, as of like last year or so
10:20:44 <chrisdone> http://grooveshark.com/#!/album/Tomorrow+s+Harvest/8974325
10:20:50 <rasfar> what is wrong with Campfire? that has some of the sweetest outros of all time...
10:21:03 <Philonous_> Why is EitherT not in tranformers?
10:21:05 <giogadi> not gonna lie, I just didn't really like how they mixed the guitar
10:21:18 <giogadi> Bibio does folktronica in a way I prefer
10:21:25 <rasfar> and one last thing, I hope you've seen the fan video for ... what's it called, with "Balloon" in the title.
10:21:31 <giogadi> oh so good
10:21:31 * ski rechecks channel title
10:21:40 <giogadi> ugh ok
10:21:49 <rasfar> one of my favourite tracks of theirs and I can't even remember the name, that's pretty bad.
10:22:07 <rasfar> alright, done.
10:22:28 <chrisdone> back to dry code and answering questions
10:22:49 <Iceland_jack> chrisdone: Haskell code is never dry!
10:23:00 <chrisdone> but it can be DRY
10:23:09 <Iceland_jack> ;)
10:23:26 <chrisdone> giogadi: BoC at #5 on my top artists http://chrisdone.com/music (spoiler: the server is written in haskell)
10:23:26 * Iceland_jack should open a bar called Foo Bar that serves DRY Vodka
10:23:30 <giogadi> mzero: so the thunking is coming from the comparison function you think?
10:23:41 <Philonous> giogadi, rasfar there's always #haskell-blah if you want to continue your discussion.
10:23:52 <giogadi> thanks, phil!
10:24:11 <chrisdone> Philonous: haskell-blah is artificial
10:24:44 <rasfar> i've too many distractions to open another IRC channel, but i will try to stay on topic :)
10:24:57 <Philonous> chrisdone, How do you mean?
10:25:28 <ski> @wn artificial
10:25:29 <chrisdone> haha, i love the idea of going to a haskell conference and a conversation sparks up about music and some droppy eyed guy walks up and says “can you please move to the -blah room to discuss this non-haskell topic?” and everyone in the group lets out a sigh of killed mood
10:25:30 <lambdabot> *** "artificial" wn "WordNet (r) 3.0 (2006)"
10:25:30 <lambdabot> artificial
10:25:30 <lambdabot>     adj 1: contrived by art rather than nature; "artificial
10:25:30 <lambdabot>            flowers"; "artificial flavoring"; "an artificial
10:25:30 <lambdabot>            diamond"; "artificial fibers"; "artificial sweeteners"
10:25:31 <lambdabot> [8 @more lines]
10:25:55 <jophish__> Yo yo yo
10:26:14 <jophish__> I have a function which takes a Word, later on this function I want to get the value 2 ** myWord
10:26:26 <jophish__> what's the idiomatic way of casting here?
10:26:36 <rasfar> but -blah is great, i totally forgot about it
10:27:12 <rasfar> fromIntegral word ?
10:27:19 <Philonous> jophish__, fromintegral
10:27:24 <Philonous> fromIntegral even
10:27:28 <srhb> jophish__: If you're sure that you mean ** and not ^ :-)
10:27:43 <jophish__> ah, I'd like to raise 2 to the power of myWord
10:27:47 <ski> > 2 ^ 186 :: Double
10:27:48 <jophish__> a shift would suffice :)
10:27:49 <lambdabot>   9.807971461541689e55
10:27:51 <ski> > 2 ** 186 :: Double
10:27:53 <lambdabot>   9.807971461541689e55
10:28:04 <rasfar> i do detest fromIntegral / in that case jophish__ use ^ it's more efficient
10:28:13 <srhb> > (2 :: Word) ^ (2 :: Word)
10:28:15 <jophish__> what's the difference?
10:28:15 <lambdabot>   4
10:28:20 <Philonous> jophish__, Don't use shift if you don't mean it. Let the compiler figure out those kind of optimizations.
10:28:23 <ski> @type (^)
10:28:24 <srhb> :t (^)
10:28:24 <lambdabot> (Integral b, Num a) => a -> b -> a
10:28:25 <ski> @type (**)
10:28:25 <lambdabot> (Integral b, Num a) => a -> b -> a
10:28:26 <rasfar> cant use ^ on floating types
10:28:26 <lambdabot> Floating a => a -> a -> a
10:28:32 <ski> can too
10:28:39 <jophish__> Philonous: oh, of course :)
10:28:42 <ski> > (2 :: Double) ^ 186
10:28:44 <lambdabot>   9.807971461541689e55
10:29:01 <rasfar> oh, it's just the exponent type that's at stake
10:29:05 <srhb> Yeah.
10:29:30 <rasfar> they have the same type...
10:29:38 <rasfar> including constraints
10:30:20 <FireFly> no, but ski and srhb both asked about the type of (^)
10:30:28 <rasfar> Prelude> :t (^)
10:30:28 <rasfar> (^) :: (Integral b, Num a) => a -> b -> a
10:30:28 <rasfar> Prelude> :t (**)
10:30:28 <rasfar> (**) :: Floating a => a -> a -> a
10:30:34 <FireFly> the  Floating a => a -> a -> a  line is the type of (**)
10:30:46 <FireFly> lambdabot just got a bit too much work at once, is all
10:30:57 <ski> @ghc
10:30:57 <lambdabot> Use -fglasgow-exts to allow GADTs
10:31:14 * ski wonders how old that one is
10:31:18 <srhb> Old.
10:31:19 <rasfar> except -fglasgow-exts is deprecated
10:31:20 <srhb> :P
10:31:34 <rasfar> but GHC still depends on it to build :)
10:31:38 <hpc> it's renamed to -foleg-exts
10:32:10 <FireFly> How would one pronounce (<*>)?
10:32:12 <rasfar> i never had the pleasure of being here when oleg was around
10:32:25 <ski> FireFly : perhaps "idiomatically apply" ?
10:32:39 <FireFly> Hm
10:32:40 <rasfar> (presuming he ever came here at all)
10:32:49 <ski> i don't recall Oleg even being in here
10:32:56 <ski> s/even/ever/
10:33:07 <Philonous> FireFly, It'd call it "ap"
10:33:18 <ski> also a good choice
10:33:19 <srhb> FireFly: Control.Applicative calls it sequential application
10:33:23 <srhb> I must say I don't like that very much.
10:33:27 <rasfar> that explains how i missed him then (not that i'm here with any great regularity myself)
10:33:33 <hpc> ap is a good name for it
10:34:27 * ski still thinks infix `ap' looks nicer than `<*>'
10:35:04 <hpc> at least until banana brackets become a thing
10:35:22 <ski> is that idiom brackets ?
10:35:41 <rasfar> I used `ap` for the first time about a day ago, to make a liftM6
10:35:42 <srhb> Are they in the pipeline?
10:35:54 <hpc> unsure
10:36:14 <Iceland_jack> ski: Have you seen Elm's way of lifting? :)
10:36:26 <Iceland_jack> Elm uses (<~) and (~) for (<$>) and (<*>) respectively
10:37:09 <Iceland_jack> hpc: Idiom brackets are writing ⟦ a + b ⟧ for ((+) <$> a <*> b)
10:37:43 <aleksejs_> Could someone explain me one thing about haskell?
10:37:50 <haasn> it's cool
10:38:04 <srhb> aleksejs_: Ask.
10:38:07 <Iceland_jack> aleksejs_: One or two depending on the problem :)
10:38:22 <srhb> aleksejs_: Unless you just want us to pick a random trivia. :P
10:38:30 <ion> aleksejs: Anything we want?
10:38:38 <geekosaur> heh
10:39:08 <Iceland_jack> (#haskell is like a pack of wildebeasts attacking potential question askers) :)
10:39:18 <ski> Iceland_jack : ok, looks more reasonable, imo
10:39:48 <srhb> Iceland_jack: What symbols did you use in that line? My IRC client rendered them as boxes
10:40:04 <srhb> Iceland_jack: (I presume it's something like [| and |])
10:40:04 <FireFly> double-struck [ and ]
10:40:04 <ski> srhb : roughly `[|' and `|]'
10:40:09 <srhb>  Aha
10:40:14 <Iceland_jack> srhb: [| and |], sorry :)
10:40:32 <Iceland_jack> Can people see (—) btw?
10:40:33 <srhb> Thanks, I should fix my fonts I guess.
10:40:42 <srhb> Iceland_jack: shows as parens with a dash between
10:40:47 <Iceland_jack> ok good
10:40:47 <ski> Iceland_jack : looks like an m-dash or something
10:40:47 <Iceland_jack>  
10:40:47 <aleksejs_> If I type 2^4^4, it gives me result of 2^256, because clearly, 4^4 is evaluated first. If I Type 2^16^16, I get Out of memory, because of obvious reason. but if I type 2^0^16^16, it shows result 1 immediately. The question is: How does it work? Should it evaluate 16^16 first?
10:40:52 <Iceland_jack> ski: That's right!
10:41:02 * Iceland_jack is never sure whether to use --- or —
10:41:21 <Iceland_jack> or --… but that's a different discussion
10:41:21 <aleksejs_> Snouldn't*
10:41:28 <srhb> Iceland_jack: #unicodeproblems
10:41:31 <Iceland_jack> ;P
10:41:41 <monochrom> > 0 ^ undefined
10:41:42 <lambdabot>   *Exception: Prelude.undefined
10:41:51 <ski> @src (^)
10:41:52 <lambdabot> x ^ 0            =  1
10:41:52 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
10:41:52 <lambdabot>   where f _ 0 y = y
10:41:52 <lambdabot>         f x n y = g x n
10:41:52 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
10:41:54 <lambdabot>                       | otherwise = f x (n-1) (x*y)
10:41:56 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
10:42:03 <simukis_> Iceland_jack: - between numbers, — between words, – for hyphenated words.
10:42:07 <ski> > 0 ^ (16 ^ 16)
10:42:09 <lambdabot>   0
10:42:17 <ski> > 2 ^ 0
10:42:19 <lambdabot>   1
10:42:21 <Iceland_jack> simukis_: I know /when/ they're used
10:42:36 <simukis_> oh, use unicode ofc.
10:42:36 * Iceland_jack is never sure whether to use --- or — (*both* referring to em dashes)
10:42:37 <aleksejs_> ski, I know how much is 0^x
10:42:44 <ski> aleksejs_ : `2^0^16^16' parses as `2^(0^(16^16))'
10:43:05 <nooodl> ski: i think it's more of a "why doesn't it run out of memory calculating 16^16" qeustion
10:43:11 <nooodl> (in 0^16^16)
10:43:20 <ski> > 16 ^ 16
10:43:21 <lambdabot>   18446744073709551616
10:43:31 <ski> doesn't look that particularly large
10:43:45 <nooodl> hm. that *was* a lot larger in my brain.
10:43:48 <simukis_> > 0 ^ 2 ^ 16 ^ 16
10:43:56 <aleksejs_> never mind, i got an answer: 2^0^(2^16^16) still gives an exception
10:44:00 * ski grins at simukis_
10:44:20 <monochrom> oh! 2^0^16^16 = 2^1
10:44:35 <monochrom> err, 2^0^16^16 = 2^0
10:44:42 <ski> aleksejs_ : `0^16^16' will multiply `0' with itself many times. `0^(2^16^16)' will do it very many more times
10:44:52 <nooodl> maybe there should be a "0 ^ x = 0" clause in that definition...
10:45:07 <ski> > 0 ^
10:45:09 <lambdabot>   <hint>:1:4:
10:45:09 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
10:45:09 <ski> > 0 ^ 0
10:45:11 <lambdabot>   1
10:45:21 <nooodl> yeah, you'd want it on the second line
10:45:24 <dwcook> > 0 ^ 0
10:45:24 * ski nods
10:45:25 <lambdabot>   1
10:45:37 <dwcook> Oh, you just did that
10:46:26 <ski> nooodl : you might just as well also add `1 ^ n = 1', and `(-1) ^ n | even n = 1 | otherwise = -1' as well
10:47:02 <srhb> Presumably there's a good reason they're not there?
10:47:08 <srhb> I just can't figure one out. :P
10:48:15 <nooodl> ski: ooh i like that ((-1) ^) one
10:48:26 <Philonous> Is there a reason EitherT is not in transformers?
10:49:00 <ski> aleksejs_ : all cleared up ?
10:49:08 <aleksejs_> yes
10:49:14 <ski> great
10:52:43 <stbuehler> i now got these datatypes:
10:52:43 <stbuehler> data Vector4 e = Vector4 !e !e !e !e deriving (Eq, Typeable, Data)
10:52:44 <stbuehler> newtype Matrix4x4 e = Matrix4x4 (Vector4 (Vector4 e)) deriving (Eq, Typeable, Data)
10:53:02 <stbuehler> and i still get stack space overflows
10:54:10 <stbuehler> (context: having Num e => Num (Matrix4x4 e); m^(10^50000) on Matrix4x4 Int)
10:54:27 <stbuehler> so i'd really like to know how to *debug* stack space overflows
10:59:19 <Eduard_Munteanu> Is there some way to avoid writing RULES to get fusion for data structures I'm implementing? Some sort of fusion combinator library or generics?
11:01:25 <stbuehler> ok. (^) isn't strict. made my own version, no stack space problems anymore. still, it'd be nice to know how to debug it
11:06:01 <shock_one> Hi. I want to make async HTTP request. I'm trying to use mapConcurrently, but the problem is, I have millions of requests to make, and it says «socket: resource exhausted (Too many open files)». What is the right way to deal with that?
11:07:19 <donri> Eduard_Munteanu: there's the stream-fusion package, duno how generic
11:08:22 <Eduard_Munteanu> donri: I wondered that too... assuming that means I'd write my structures as traversable streams.
11:08:39 <donri> shock_one: chunking?
11:10:02 <shock_one> donri: but doesn't it mean that the previous chunk has to finish completely before the next one starts? What if one of the requests takes too much time? I want to do it as quickly as possible.
11:12:29 <srhb> shock_one: I don't think mapConcurrently is the right idiom here, because you emphatically _don't_ want to execute all those IO actions at the same time.
11:12:42 <donri> shock_one: i mean, spawn a fixed number of workers that individually run in sequence
11:13:29 <donri> shock_one: and use a communication primitive to supply jobs to workers
11:13:33 <srhb> shock_one: If you split the original list into smaller ones of, say, a few hundreds of actions, and then run those sequentially, you're good.
11:15:04 <shock_one> srhb: A great idea.
11:15:19 <osa1_> how can I print help msg in optparse-applicative when no args are passed to the program ?
11:15:48 <srhb> shock_one: donris is better though
11:16:12 <srhb> shock_one: There's no reason to wait for one chunk to complete before processing more urls.
11:16:20 <srhb> shock_one: But just outlining the idea. :-)
11:16:46 <shock_one> srhb: Yes, queue of jobs and pull of workers is the right way, but I'm pretty new to Haskell and I'm afraid I won't manage to implement that.
11:17:00 <srhb> shock_one: OK, try my version then. :)
11:17:19 <srhb> shock_one: You can revisit the right solution later. :)
11:19:39 <donri> shouldn't be hard with async and stm, say
11:19:41 <shock_one> It looks like this thing does what I want http://zguide.zeromq.org/hs:taskwork
11:27:30 <donri> shock_one: do reqs <- newTVarIO [a,b,c]; workers <- replicateM n (worker reqs); mapM_ wait workers ...
11:28:37 <shock_one> donri: Thank you, I'll try it later. Do you have any useful links?
11:29:33 <donri> worker reqs = forever $ do req <- atomically $ do r:_ <- readTVar reqs; return r ...
11:30:02 <donri> this isn't a complete solution, you probably want to quit workers when the reqs is empty etc
11:30:36 <donri> shock_one: http://chimera.labs.oreilly.com/books/1230000000929
11:31:24 <shock_one> It's a little bit too much, but thank you.
11:31:31 <donri> hehe
11:31:51 <donri> shock_one: http://hackage.haskell.org/package/stm-2.4.2/docs/Control-Concurrent-STM-TVar.html then :)
11:32:55 <donri> oh forgot to writeTVar there... do r:rs <- readTVar reqs; writeTVar reqs rs; return r
11:35:17 <srhb> If I want to run a "gtk application" (non-Haskell) inside my Haskell GUI application, do I need to fiddle with X primitives?
11:36:14 <Eduard_Munteanu> srhb: I think the GTK API lets you pass an window for another app to draw on, something called a Socket I think.
11:37:08 <srhb> Eduard_Munteanu: That sounds useful, but would require the "client" application (the one "inside" my GUI) to be modified, wouldn't it?
11:37:41 <srhb> Eduard_Munteanu: Ie. I can't just say "here's my window, now open Firefox in it"
11:38:24 <Eduard_Munteanu> srhb: might be an universal GTK option, not sure.
11:38:33 <Eduard_Munteanu> Cmdline option, I mean.
11:39:03 <srhb> Eduard_Munteanu: I'll start digging through the docs. Thank you. :)
11:39:12 <tomboy64> do you really want firefox? with all the plugin infrastructure etc.?
11:39:17 <Eduard_Munteanu> srhb: ah, I think they have to implement a Plug/Socket at least
11:39:30 <tomboy64> or wouldn't it be enough to create a gecko-window?
11:39:47 <tomboy64> (got nothing to do with the original question, sorry)
11:39:54 <srhb> tomboy64: It was just an example. I'm looking for a way to run _any_ gui application inside my window
11:40:23 <tomboy64> ah, ok
11:40:39 <srhb> I don't know if it's even possible.
11:41:13 <tomboy64> maybe looking at the xmonad infrastructure might help
11:41:23 <tomboy64> or asking in a gtk-related channel
11:41:27 <srhb> tomboy64: That might be an idea, too.
11:41:37 <tomboy64> it doesn't have much to do with haskell itself
11:42:28 <geekosaur> xmonad won't help here, I suspect, although reparenting is involved to some extent
11:42:52 <srhb> geekosaur: "Reparenting?"
11:42:54 <geekosaur> (problem is, xmonad is not a reparenting window manager :)
11:43:09 <geekosaur> srhb: changing a top level window into a subwindow of something else
11:43:35 <geekosaur> man XReparentWindow
11:44:09 <srhb> geekosaur: Oho, that sounds exactly like what I need. Thanks
11:45:31 <tomboy64> probably not. it most likely is an x11-function, not a gtk function
11:46:33 <srhb> tomboy64: But doesn't that just mean I'll have to move my application "up a level" to work on the X layer?
11:46:43 <geekosaur> right, but it might be useful in finding what gtk wraps it with
11:50:15 <Eduard_Munteanu> Is there a strictness monad? I'm thinking of something like "newtype Seq a b = Seq b; mkSeq a b = a `seq` Seq b; return a = a `seq` Seq a; (Seq a) >>= f = a `seq` f a"
11:51:09 <geekosaur> actually, not sure it matters. create a basic gtk window, then use XReparentWindow directly to make your embedded window a child of it
11:51:23 <geekosaur> GtkSocket requires the embedded window follow the XEmbed protocol
11:51:36 <geekosaur> ...which random standalones typically won't
11:52:15 <srhb> geekosaur: So I guess my problem has now become "how to write a window manager inside a window manager"
11:52:24 <Eduard_Munteanu> And you can have a  force :: a -> Seq a ()   force = a `seq` return ()
11:53:36 <geekosaur> sort of; at minimum you've taken on the role of window manager for the embedded window, which is why XEmbed exists
11:54:03 <srhb> geekosaur: OK. Thanks, I now have something to go on. :)
11:54:05 <geekosaur> http://standards.freedesktop.org/xembed-spec/xembed-spec-0.5.html is worth reading just to see what you need to deal with, especially when the target window isn't aware of being reparented
11:54:40 <geekosaur> (at minimum you need to deal with assigning focus to the embedded window)
11:55:15 <enthropy> Eduard_Munteanu: what does the `a' parameter buy you?
11:55:41 <augustss> Eduard_Munteanu: I don't think strictness obeys the monad laws.
11:56:19 <geekosaur> isn't there a somewhat infamous demonstration that IO violates the monad laws because of strictness issues?
11:56:33 <enthropy> return for IO doesn't force it's argument
11:56:47 <enthropy> eduard's return forces it
11:57:05 <hpc> or rather, his return = evaluate
11:57:32 <enthropy> so probably something like     x >>= \y -> return y -- won't be `x' if  x = Seq undefined
11:57:48 <Eduard_Munteanu> enthropy: not sure, it's not a fully baked idea, but I think I want an indexed monad to get some structure on that.
11:57:51 <enthropy> hmm, but it's a newtype
11:58:08 <enthropy> so (Seq undefined) is the same as undefined
11:58:35 <Eduard_Munteanu> enthropy: yes, that's the point though, you don't want Seq to lazify the argument
11:59:52 <Eduard_Munteanu> enthropy: that way you can write   a `seq` b  where  b :: Seq b' b
12:00:56 <f-a> http://lpaste.net/95105 <-- I wonder how lines 8 and 9 can typecheck.
12:00:57 <Eduard_Munteanu> augustss: you mean in the context of undefineds? I was sort of ignoring them.
12:01:11 <f-a> (traversals)
12:01:20 <Eduard_Munteanu> So I'm mostly concerned about forcing fully-defined things.
12:03:35 <f-a> (I mean, "extracting" something with ^. should lead to the dame datatype, right?
12:03:41 <supki_> > Just (Just "Foo") ^. _Just
12:03:43 <lambdabot>   Just "Foo"
12:04:13 <f-a> > Nothing ^. _Just
12:04:15 <lambdabot>   ()
12:04:34 <supki_> > Nothing ^. _Just :: Maybe String
12:04:36 <lambdabot>   Nothing
12:04:50 <supki_> @ty view _Just
12:04:51 <lambdabot> (Monoid b, MonadReader (Maybe b) m) => m b
12:05:22 <supki_> f-a: that's how ^. for traversals works: it combines all targets with mappend
12:06:06 <supki_> > ["foo", "bar"] ^. folded
12:06:08 <lambdabot>   "foobar"
12:06:48 <f-a> > Just "foo" ^. _Just
12:06:50 <lambdabot>   "foo"
12:07:56 <srhb> ghc-mod is supposed to be able to guess simple types in my file in Emacs, right? I have bar = "foo" and it says it cannot guess that one - am I missing some setting?
12:08:00 <supki_> > Nothing ^. _Just :: String
12:08:02 <lambdabot>   ""
12:08:32 <f-a> supki_: no ghci here, what's be the type of a (where a is Maybe x) ^. _Just ?
12:09:01 <hpc> :t Nothing ^. _Just
12:09:02 <lambdabot> Monoid b => b
12:09:22 <f-a> a monoid, eh?
12:09:34 <sipa> :t (^.)
12:09:35 <lambdabot> s -> Getting a s a -> a
12:09:58 <sipa> :t _Just
12:10:45 <sipa> cmon you lambdabot
12:11:07 <sipa> @botsnack
12:11:07 <supki_> f-a: traversal can have multiple targets (0 or more), but (^.) says it gets you the answer always, so it needs a way to combine these targets, so Monoid
12:11:08 <lambdabot> :)
12:11:19 <sipa> :t _Just
12:11:25 <supki_> :t (_Just)
12:11:26 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
12:11:29 <sipa> ah
12:11:45 <f-a> very good
12:12:48 <f-a> I maybe fail to see useful applications for ^. on traversals, but hey I guess I must just wait and get more experienced
12:13:35 <f-a> > Nothing ^. _Just :: Product
12:13:37 <lambdabot>   Expecting one more argument to `Data.Monoid.Product'
12:13:50 <f-a> > Nothing ^. _Just :: Product Int
12:13:51 <lambdabot>   Product {getProduct = 1}
12:13:56 <supki_> yeah, occasionally it's useful, but more often you want (^?) or (^..)
12:14:14 <supki_> ^? gets the first target (if any), ^.. gets them all in a list
12:14:48 <sipa> > Nothing ^. _Just :: [Int]
12:14:50 <lambdabot>   []
12:15:12 <sipa> so ^.. is the same as ^., but specialized to lists?
12:15:25 <copumpkin> :t (^..)
12:15:26 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
12:15:40 <copumpkin> :t (^.)
12:15:42 <lambdabot> s -> Getting a s a -> a
12:15:44 <f-a> supki_: call me naive, but why would I want them in a list? I mean, what's a simple use case scenario? Generally speaking, of course.
12:16:03 <copumpkin> sipa: seems to be an extra Endo in there
12:16:08 <osa1_> is there parser in optparse-applicative to parse optional arguments?
12:16:32 <copumpkin> although Endo [a] is just a DList
12:16:34 <copumpkin> so perhaps
12:16:51 <copumpkin> well, a common subset of Endo [a] is
12:19:27 <Eduard_Munteanu> @hoogle (b -> c) -> f a b -> f b c
12:19:27 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
12:19:27 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
12:19:27 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
12:19:40 <Eduard_Munteanu> Hrm.
12:20:04 <darthdeus> hey guys, i'm trying to solve this project thing, and i think i have the right solution, but it's ridiculously slow http://lpaste.net/95107 ... a similar approach in ruby is way faster, so i guess the chained intersect is not a good idea?
12:21:00 <roconnor_> sipa: ^.. is not a specialization of ^.
12:21:05 <roconnor_> > ["a","b","c"] ^. traverse
12:21:05 <Eduard_Munteanu> I think I want  seqMap :: (b -> c) -> Seq a b -> Seq b c  but I'm unsure what that is, CT-wise.
12:21:07 <lambdabot>   "abc"
12:21:11 <roconnor_> > ["a","b","c"] ^.. traverse
12:21:13 <lambdabot>   ["a","b","c"]
12:21:18 <enthropy> darthdeus: use an intersect from Data.Set
12:21:31 <Eduard_Munteanu> Oh, wait.
12:21:32 <copumpkin> Eduard_Munteanu: what's the Seq type?
12:22:00 <enthropy> or maybe write an intersect that assumes your lists are already sorted
12:22:10 <Eduard_Munteanu> copumpkin: newtype Seq a b = Seq b   with   mkSeq :: a -> b -> Seq a b   mkSeq a b = a `seq` (Seq b)
12:22:27 <roconnor_> sipa: (^.) is (^..) compsoed with mconcat
12:23:13 <darthdeus> enthropy: should i also use Data.Set.fromList on the generated list comprehension, or is there a better way to make it directly into a Set?
12:23:47 <Eduard_Munteanu> It can be a profunctor I think: promap :: (b -> a) -> (b' -> c) -> (Seq a b' -> Seq b c)  with b ~ b'
12:24:37 <darthdeus> enthropy: but you were right, Data.Set.intersection solves the same number almost instantly :)
12:26:16 <supki_> f-a: well, you can look at traversals (folds here, really) as a way to query data structure for something, and when you want all results of that query, you need to store them somewhere ;)
12:26:41 <f-a> I see, I see. Thanks for the explanation
12:40:14 <timthelion> So I
12:41:16 <timthelion> So I've run into a total blocker.  The "tar" packages "pack" function is lazy, and I need to pack some directories on a mounted disk, and then unmount it(but of course, I get mountpoint busy when I go to unmount)...
12:41:29 <timthelion> How can I tell the haskell GC that some lazilly read file needs to be closed?
12:41:44 <Eduard_Munteanu> Heh, turns out I just want a Category for newtype Seq a b = Seq (a -> b)
12:43:13 <Eduard_Munteanu> I was a bit confused because I kept thinking that   Seq a (Seq b c)  can be collapsed into a  Seq something c.
12:43:54 <Eduard_Munteanu> I can make a "SeqReader" monad though.
12:43:54 <Philonous> timthelion, You can't. You can only force evrything and hope that the GC will get around to closing the handles.
12:44:37 <rck> is there any way to restrict one (or more) of a record type's fields to a specific value? e.g. type = 0 instead of type :: Int and wrapping it in a function specifying 0 as type
12:45:08 <timthelion> Philonous: So would it be reasonable to rewrite the pack function in a strict manner?
12:45:10 <Eduard_Munteanu> rck: you can make a GADT
12:45:18 <timthelion> Philonous: it is an opensource library afterall.
12:45:34 <rck> Eduard_Munteanu: thanks, will research
12:45:40 <Eduard_Munteanu> rck: not sure what you mean '0', are you talking about singleton types?
12:45:41 <Cale> timthelion: Which pack function?
12:45:52 <Cale> oh
12:45:58 <Philonous> timthelion, If it is indeed lazy IO, then yes.
12:46:04 <Philonous> timthelion, Possibly using conduits/pipes
12:46:17 <timthelion> Cale: tar's pack function: http://hackage.haskell.org/package/tar-0.4.0.1/docs/Codec-Archive-Tar.html#g:7
12:46:18 <Cale> Or just using strict IO :P
12:46:30 <Cale> (yeah, I didn't see your first line at first)
12:47:26 <timthelion> OK, well, at least it's open source :/
12:48:26 <Cale> Well, one workaround is to make sure that the result is completely read
12:48:27 <Eduard_Munteanu> rck: mind record syntax works for GADTs too
12:48:40 <Cale> i.e. force the evaluation somehow
12:48:43 <rck> yeah, basically I have an enumeration of a specific value ("type": 0 .. 2) and I want "type" :: Int (I should have chosen a better field name for this example...) but when I construct it I want the "type" field to be the value zero for one of my type constructors
12:49:06 <timthelion> It's kind of sad, I'm only using it, to re-implement "tar --diff", but "tar --diff" escapes it's output in such a strange way, that I couldn't figure out how to unescape it(the source code uses many global variables to configure escaping...)  So all this effort, just to get around having to parse shell output...
12:49:11 <rck> and 1 for another, and 2 for the last
12:49:38 <Eduard_Munteanu> rck: I think you mean Nat, not Int, no?
12:49:46 <timthelion> Cale: so if I were to seq the entire data structure I would have a guarantee that the descriptors would be closed?
12:50:04 <Eduard_Munteanu> I don't think we have lifted Ints.
12:50:13 <Cale> But since it's the tar package which opens the file, it might be hard to hClose it (Applying hClose to a file handle that's had hGetContents applied to it is not particularly safe, as it'll result in an arbitrary truncation of the file being read, but if you can ensure that you have all the data you'll need already evaluated, then it's kinda okay.)
12:50:30 <Eduard_Munteanu> You can probably define them though.
12:50:51 <timthelion> Cale: in order to hClose it, I need to have a handle...
12:51:00 <Cale> yeah, which you might not have
12:51:15 <timthelion> I don't see how I can get it...
12:52:07 <Cale> Well, yeah, in this case, I think the API of this library is such that you're kind of out of luck
12:52:09 <rck> Eduard_Munteanu: I didn't know about Nat, thanks!
12:52:14 <Eduard_Munteanu> data IntK = ZeroPlus Nat | MinusOnePlus Nat
12:52:19 <Eduard_Munteanu> Should do.
12:52:33 <hpc> timthelion: do es <- pack "foo.tar" files; evaluate (length es); return es
12:52:35 <Eduard_Munteanu> rck: just to make sure, you're talking about DataKinds, right?
12:52:48 <hpc> try that
12:52:48 <rck> Eduard_Munteanu: probably
12:53:16 <rck> I have an idea and I'm trying to understand how to implement it correctly. I could be talking about god knows what tbh ha
12:53:27 <timthelion> hpc: OK, I can try :)
12:53:28 <Eduard_Munteanu> rck: I get a feeling I might be talking about way more advanced stuff than you need. What is the kind of your '0'?
12:54:11 <Eduard_Munteanu> rck: or in other words, what are you trying to accomplish?
12:54:36 <Cale> timthelion: You might also want to try sticking in a System.Mem.performGC and see if that helps
12:54:48 <Philonous> Is there a (working) tool that converts darcs repositories to git?
12:55:14 <rck> Eduard_Munteanu: GHC.TypeLits.Nat but I only know this because you suggested -XDataKinds which looks like what I want
12:55:29 <Cale> timthelion: If the whole result is forced, then a retry loop to unmount should work (eventually).
12:56:18 <Cale> timthelion: But yeah, generally that's one issue with lazy IO, that you give up responsibility for the file descriptors, and don't really have the right to close them yourself anymore.
12:56:19 <srhb> Philonous: darcs-to-git does not work?
12:56:31 <rck> I think I'm trying to define preset values for fields and I'm going about it the wrong way
12:56:45 <timthelion> Cale: it's the first real blocker I've run into with lazy IO
12:56:54 <khyperia> I decided to finally figure out "a monoid is a monad in endofunctors yadda yadda" phrase, but I'm a bit confused on something - where does Haskell's "a -> m b" in the >>= function come into play with the definition of "functor monoid"? It seems like a "functor monoid" is composition of functors, not a monad.
12:57:19 <khyperia> as in the composition seems like the (.) operator, not (>>=)
12:57:29 <Eduard_Munteanu> rck: oh, in that case, it's definitely wrong. Just make a "template" value, like   template :: MyRecord   template = { ... }   foo = template { <change stuff you need to change> }
12:57:53 <Philonous> srhb, ruby barfs when I try to run it.
12:58:24 <Eduard_Munteanu> Er, template = MyConstructor { ... }
12:58:51 <Cale> khyperia: You have it backward: a monad on C is a monoid object in the category of endofunctors on C
12:58:59 <timthelion> I'm going to re-write the function in a case specific form.  This is performance critical code and I want guaratees that it'll work, no GC hacks.  Thanks for your help guys.
12:59:11 <Mark____> hello
12:59:20 <Eduard_Munteanu> rck: or, in case you can't provide defaults for all fields, you should make a function that builds your record
12:59:20 <Cale> khyperia: Do you know what a monoidal category is?
12:59:30 <rck> Eduard_Munteanu: yep yep, that's where I started but was curious if I could enforce that at the type system level instead of the function level
12:59:50 <khyperia> Nope, Cale
12:59:56 <rck> ...which I'm not sure makes sense
13:00:08 <Cale> khyperia: The definition of a monoid object is a generalisation of the definition of a monoid in the category of sets (i.e. what we'd ordinarily call a monoid) to arbitrary monoidal categories.
13:00:39 <lpaste> Mark pasted “Conduits” at http://lpaste.net/95109
13:00:43 <khyperia> Ahh, so the elements in the sets are "objects of type (a -> m b)", to rephrase?
13:00:59 <khyperia> and then the monad binary operation is >>=?
13:01:00 <Cale> Well, no, the connection is quite abstract...
13:01:07 <Eduard_Munteanu> rck: you can, but I'm not sure you want that. You could parametrize your (GADT) record by singleton types.
13:01:13 <Cale> >>= isn't directly part of it too
13:01:15 * Iceland_jack knows what ‘conduits’ are but wonders that ‘nduits’ are :)
13:01:20 <khyperia> right.
13:01:43 <augustss> Ahoy!
13:01:52 <Mark____> anyone got experience with conduits ? http://lpaste.net/95109 IO is not allowed as base monad on the runResourceT stack?
13:01:56 <Cale> The analogy is between how the unit and multiplication of an ordinary monoid M can be looked at as functions eta: 1 -> M and mu: M x M -> M respectively
13:02:10 <Eduard_Munteanu> rck: I think a good compromise is to make a fully-defined template value, that is, don't let some fields remain undefined.
13:02:21 <Cale> Here, 1 is a one-element set, and x is the Cartesian product of sets
13:02:29 <Eduard_Munteanu> Because record syntax allows that, but it sort of sucks.
13:02:35 <rck> Eduard_Munteanu: I appreciate your time
13:02:35 <Cale> (these give the category of sets a monoidal category structure)
13:02:40 <Cale> and on the other hand...
13:03:33 <Cale> We have that a monad on some category C consists of an endofunctor M: C -> C, together with natural transformations eta: 1 -> M (which we call return in Haskell), and mu: M . M -> M (which we call join in Haskell)
13:03:51 <Cale> Here 1 is the identity functor, and . is composition of functors
13:03:53 <augustss> and on the gripping hand...
13:04:11 <Eduard_Munteanu> Gripe-ing hand? :)
13:04:16 <Cale> which give a monoidal category structure to the category of endofunctors on C
13:04:19 <augustss> :)
13:04:29 <khyperia> Ah. I haven't really looked at join all that much, isn't it "m (m a) -> m a"? I think?
13:04:33 <Cale> yes
13:04:45 <khyperia> Alright.
13:05:00 <augustss> And it looks like join will finally be a member of the Monad class.
13:05:42 <McManiaC> how do you disable Network.HTTP output in the console for simpleHTTP?
13:05:49 <Cale> Recall that if F, G: C -> D are functors, then a natural transformation eta: F -> G consists of, for each X in C, some arrow eta_X: FX -> GX in D.
13:06:57 <Cale> So, in Haskell, if we have endofunctors F and G, then in order to specify a natural transformation between them, we need a way to provide for each type X, some function F X -> G X
13:07:01 <McManiaC> o nvm
13:07:09 <Cale> which is exactly the sort of thing that polymorphic functions do
13:07:31 <Cale> i.e. we'd use a polymorphic function of type F a -> G a
13:07:51 <Iceland_jack> augustss: great!
13:08:03 <Cale> So, eta: 1 -> M becomes  return :: a -> M a
13:08:20 <Cale> and mu: M . M -> M becomes  join :: M (M a) -> M a
13:08:53 <khyperia> alright, thanks
13:09:31 <Cale> khyperia: It turns out that the unit and associativity laws for a monoid are abstractly exactly the same as the unit and associativity laws for a monad, when you blur your eyes in just the right way :)
13:09:55 <Cale> and that's what gives rise to the idea of a monoid object
13:10:02 <Cale> in an arbitrary monoidal category
13:11:18 <khyperia> throwing somethng random out there, does (x >>= f >>= g) == ((join (f . g)) x) == ((f * g) x) ? (third equasion * is the monoid binary opration)... I'm probably completely wrong, but I'm trying!
13:11:59 <khyperia> :t \x -> join (return.return)
13:12:01 <lambdabot> Monad m => t -> a -> m a
13:12:20 <khyperia> :t \x -> x >>= return >>= return
13:12:21 <lambdabot> Monad m => m b -> m b
13:12:46 <khyperia> hmmm....
13:13:38 <khyperia> ah, wait, the first one wasn't supposed to be in a lambda
13:14:01 <khyperia> but still, "a -> m a" /= "m a -> m a"
13:14:51 <khyperia> wait, no, I'm stupid
13:15:01 <khyperia> just don't try to help me for a while while I think, heh.
13:17:08 <Cale> khyperia: Well, if we start with three M's, i.e. from M (M (M a)), there are two things we can do to begin to join them together, we can join :: M (M (M a)) -> M (M a), or we can fmap join :: M (M (M a)) -> M (M a)
13:17:12 <fizruk> :t \x -> join (return . return $ x)
13:17:13 <lambdabot> Monad m => a -> m a
13:17:25 <rfw> @pl \x y -> foldr ($) x (replicate y succ)
13:17:28 <lambdabot> flip ((.) . foldr ($)) (flip replicate succ)
13:17:29 <lambdabot> optimization suspended, use @pl-resume to continue.
13:17:33 <Cale> khyperia: and then after that, in either case we can apply join :: M (M a) -> M a to get down to one M
13:18:09 <Cale> khyperia: The associativity law says that these two ways to build a natural transformation M^3 -> M are equal
13:18:13 <fizruk> :t \x y -> take y (iterate succ x)
13:18:14 <lambdabot> Enum a => a -> Int -> [a]
13:18:22 <Cale> i.e. that join . join = join . fmap join
13:18:42 <khyperia> one is joining the outermost, and one is the innermost, I think?
13:18:46 <Cale> yeah
13:19:14 <rfw> @pl \x y -> (foldr (.) id (replicate y succ)) x
13:19:18 <lambdabot> flip (foldr (.) id . flip replicate succ)
13:19:18 <lambdabot> optimization suspended, use @pl-resume to continue.
13:19:40 <fizruk> rfw, why not `take y (iterate succ x)` ?
13:20:03 <rfw> fizruk: ah, neat
13:20:08 <rfw> just messing around :)
13:20:29 <Cale> Similarly, with monoids, starting from M x M x M, we can first either multiply the first two components to get to M x M, or the last two components to get to M x M, and then multiply again to get to M
13:20:44 <Cale> and that's the associativity law
13:20:48 <fizruk> rfw, oh that's actually scanl, not foldr
13:21:06 <johnw> Cale: that explains why so many of the commutative diagrams I see talking about monoids always use MxMxM in upper-left of the diagram; it proves associativity
13:21:09 <Cale> (i.e. that  mu . (mu x M) = mu . (M x mu)
13:21:10 <Cale> )
13:21:37 <rfw> fizruk: er yeah, did you mean iterate succ x !! y
13:21:52 <fizruk> rfw, something like that :)
13:21:57 <Cale> johnw: Well, yeah, the associativity law starts with three elements, and deals with what happens when you combine them in two different ways
13:22:34 <rfw> @pl \x y -> iterate succ x !! y
13:22:34 <lambdabot> (!!) . iterate succ
13:22:42 <fizruk> =)
13:23:40 <fizruk> :t \x y -> replicateM y succ x
13:23:41 <lambdabot> Enum a => a -> Int -> [a]
13:24:00 <fizruk> > replicateM 10 succ 1
13:24:01 <Cale> The unit laws here are similar. Suppose we start with M a. There are two simple things we can do. We can apply return :: M a -> M (M a), and then join :: M (M a) -> M a, and we'd like that composite to be the identity on M a.
13:24:01 <lambdabot>   [2,2,2,2,2,2,2,2,2,2]
13:24:43 <Cale> or, we can apply fmap return :: M a -> M (M a) and then join :: M (M a) -> M a, and we'd like that composite to be the identity on M a as well
13:25:06 <jrmithdobbs> why is GADTs still an extension?
13:25:52 <Cale> jrmithdobbs: Because why not?
13:26:03 <Cale> jrmithdobbs: There's no reason for it to stop being an extension.
13:26:27 <donri> are you asking why it's not in any standard yet?
13:27:05 <jrmithdobbs> donri: i suppose so, ya
13:27:19 <Cale> Even once the standards committee gets around to describing GADTs precisely, they're still likely to remain an extension. Perhaps someday one which is by-default turned on.
13:27:27 <augustss> jrmithdobbs: It's quite a complicated extension to the type system.
13:27:40 <Cale> But yeah, GADTs are not trivial to implement.
13:27:53 <Cale> (relative to the type system described in Haskell 98)
13:27:55 <augustss> And semantically non-trivial.
13:28:56 <fizruk> > ala Endo foldMap (replicate 10 succ) 3
13:28:58 <lambdabot>   13
13:29:03 <augustss> Though I was arguing for GADTs in 1994. :)
13:29:05 <Cale> GIMME HIGHER INDUCTIVE TYPES NOW PLSTHX HOTT
13:29:36 <fizruk> Cale, what's higher inductive types?
13:29:36 <rck> augustss: can you elaborate on the early days of Haskell?
13:30:17 <fizruk> Cale, I guess I should read HoTT, but still?
13:30:38 <Cale> fizruk: Types where instead of just having data constructors, you can also stick in path constructors which create equations (or paths, thinking geometrically) between various values, and then paths between paths, and so on.
13:31:19 <Cale> fizruk: and then functions out of a higher inductive type have to say to which equations in the codomain the path constructors correspond to
13:31:42 <augustss> rck: I could, but I'm off to have dinner. :)
13:31:53 <Cale> So, it's a fancy sort of quotient types
13:32:05 <rck> augustss: another time maybe :)
13:32:23 <donri> @google being lazy with class
13:32:28 <khyperia> I just read a SO answer, and what I got out of it is this - functors already have fmap :: (a -> b) -> m a -> m b, which then when you set b to be a monad, fmapSomething :: (a -> m b) -> m a -> m (m b)... which then suspiciously looks like bind... so wait, does (>>=) == (\f join . fmap f)? (although I think order of arguments is different)
13:32:44 <lambdabot> Plugin `search' failed with: <<timeout>>
13:32:55 <Cale> fizruk: But you can do fun things like: data Circle where Base : Circle; Loop : Base = Base
13:33:26 <khyperia> forgot a -> in there, (\f -> join . fmap f)
13:33:40 <Cale> fizruk: This creates a space which has a specified point Base, and then a single nontrivial path from Base to itself, i.e. you should look at it as a circle :)
13:34:11 <Cale> fizruk: The type Base = Base of paths from Base to itself in this space is isomorphic in a nice way to the integers :)
13:34:59 <donri> khyperia: bind is join plus fmap, yes
13:35:01 <Cale> (paths which line up can be composed, every path has an inverse, and there's an identity path from any point to itself, making the paths in any type a groupoid)
13:35:18 <khyperia> Awesome, thanks, I never knew that!
13:35:20 <Cale> (that groupoid in this case, is the group of integers under addition :)
13:35:26 <donri> :t fmap join . liftM
13:35:27 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
13:35:45 <Cale> khyperia: yeah, x >>= f = join (fmap f x)
13:36:24 <khyperia> donri, you just confused me, heh.
13:36:35 <donri> haha sorry
13:37:23 <khyperia> mainly because I haven't figured out what (.) to functions that return functions does yet.
13:37:36 <khyperia> but wait, that's only single argument
13:38:05 <donri> it's using the Functor (r ->) instance
13:38:11 <donri> :t fmap join
13:38:13 <lambdabot> (Monad m, Functor f) => f (m (m a)) -> f (m a)
13:38:38 <khyperia> Ah. Right. Haven't exactly figured that out yet, haha.
13:38:43 <donri> incidentally fmap = (.) in that instance
13:38:54 <donri> :t (join .) . fmap
13:38:56 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
13:38:58 <donri> :t (join .) . liftM
13:38:59 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
13:39:54 <fizruk> Cale, oh I first misread Loop : Base = Base as something like function definition, and that confused me =P
13:41:42 <donri> khyperia: also note that bind for the list monad is concatMap, and similarly concatMap is \f -> concat . map f
13:42:01 <khyperia> yeah, I already knew that, I just didn't know the details of why.
13:42:07 <donri> and fmap = map; join = concat
13:42:22 <aleksejs_> why does ghci shows *** Exception: getCurrentDirectory: does not exist (No such file or directory) each time I type some expression?
13:42:42 <lispy> aleksejs_: do you have anything in your ~/.ghci file?
13:43:04 <lispy> aleksejs_: oh, I bet I know
13:43:15 <lispy> aleksejs_: did you start ghci in a directory that no longer exists?
13:43:22 <aleksejs_> I don't have that file
13:43:46 <khyperia> @pl (\a b -> fzoo a b) . (\a -> derp a)
13:43:47 <lambdabot> fzoo . derp
13:44:05 <khyperia> @pl (\a -> derp a) . (\a b -> fzoo a b)
13:44:05 <lambdabot> derp . fzoo
13:44:05 <aleksejs_> lispy, you're right :D can't imagine how did you figure that out
13:44:16 <khyperia> wait... what does (f .) . g do again?
13:44:28 <khyperia> @unpl (f .) . g
13:44:29 <lambdabot> (\ d i -> f (g d i))
13:44:37 <khyperia> oh, I'm stupid.
13:44:37 <fizruk> Cale, aha that sounds interesting! have to read on that stuff later :)
13:44:40 <Eduard_Munteanu> :t (.:)
13:44:41 <lambdabot>     Not in scope: `.:'
13:44:41 <lambdabot>     Perhaps you meant one of these:
13:44:41 <lambdabot>       `.' (imported from Data.Function),
13:44:52 <Eduard_Munteanu> It's not there anymore? :(
13:45:06 <donri> :t (\a b -> undefined) . (\a -> undefined)
13:45:07 <lambdabot> a -> t -> a1
13:45:40 <Eduard_Munteanu> Elliotskell is more fundamentalist, I suppose.
13:46:11 <khyperia> alright, so (\f x -> join (fmap f x)) == (join .) . fmap... starting to figure this out, donri
13:46:14 <lispy> aleksejs_: lucky guess, I suppose :)
13:46:38 <johnw> khyperia: maybe simpler: join . flip fmap
13:46:44 <donri> khyperia: \o/
13:46:59 <ion> khyperia: Btw, (\f x -> join (fmap f x)) is better.
13:47:05 <donri> :t join . flip fmap -- ??
13:47:06 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
13:47:43 <johnw> :t (join .) . fmap
13:47:44 * donri is probably about the only person who likes  fmap join . fmap  :P
13:47:45 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
13:47:49 <khyperia> ion, donri typed in "fmap join . liftM" and I'm trying to figure it out
13:48:11 <johnw> :t liftM join . liftM
13:48:13 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
13:48:32 <fizruk> donri, fmap join <$> fmap
13:48:47 <johnw> i think you mean join <$> fmap
13:49:10 <khyperia> :t join <$> fmap
13:49:11 <donri> :t join <$> fmap
13:49:12 <lambdabot>     Occurs check: cannot construct the infinite type: f0 = (->) (f0 a0)
13:49:12 <lambdabot>     Expected type: (a0 -> b0) -> f0 a0 -> f0 a0 -> b0
13:49:12 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
13:49:13 <lambdabot>     Occurs check: cannot construct the infinite type: f0 = (->) (f0 a0)
13:49:13 <lambdabot>     Expected type: (a0 -> b0) -> f0 a0 -> f0 a0 -> b0
13:49:14 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
13:49:14 <donri> :P
13:49:15 <fizruk> :t fmap join <$> fmap
13:49:16 <lambdabot> (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
13:49:32 <monochrom> fmap (fmap join) fmap? :)
13:49:33 <donri> :t (join <$>) <$> (<$>)
13:49:35 <lambdabot> (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
13:49:41 <fizruk> johnw, no
13:49:47 <johnw> ok
13:49:49 <fizruk> donri, aha :p
13:49:51 <khyperia> haha, donri
13:50:15 <khyperia> confuse newcomers saying that's "all what >>= is, it's really simple"
13:50:28 <donri> \o/
13:51:09 <donri> :t liftM join `liftM` liftM
13:51:10 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
13:51:19 <donri> ad nausium
13:51:36 <donri> nauseam?
13:52:07 <fizruk> :t (<$>) (>>= id) <$> (<$>)
13:52:08 <lambdabot> (Monad f, Functor f) => (a -> f b) -> f a -> f b
13:52:15 <donri> :t (>>= id)
13:52:17 <lambdabot> Monad m => m (m b) -> m b
13:52:25 <donri> :t (>>= id) `asTypeOf` join
13:52:26 <khyperia> @src join
13:52:26 <lambdabot> Monad m => m (m b) -> m b
13:52:26 <lambdabot> join x =  x >>= id
13:52:45 <khyperia> join is just (>>= id)
13:52:48 <donri> :t (>>= id) `asTypeOf` (liftM (liftM join) liftM)
13:52:49 <lambdabot>     Occurs check: cannot construct the infinite type: a10 = a10 -> a10
13:52:49 <lambdabot>     Expected type: (a10 -> a10 -> a10 -> a0) -> a10 -> a10 -> a10 -> a0
13:52:49 <lambdabot>       Actual type: (a10 -> a10 -> a10 -> a0)
13:53:25 <joelteon> :t liftM (liftM jin)
13:53:26 <lambdabot>     Not in scope: `jin'
13:53:27 <lambdabot>     Perhaps you meant one of these:
13:53:27 <lambdabot>       `sin' (imported from Prelude), `min' (imported from Data.Ord),
13:53:27 <joelteon> :t liftM (liftM join)
13:53:29 <lambdabot> (Monad m, Monad m1, Monad m2) => m (m1 (m2 (m2 a))) -> m (m1 (m2 a))
13:54:17 <khyperia> how wrong is it to think that fmap == liftM?
13:54:18 <donri> :t liftM (liftM (>>= id)) liftM
13:54:19 <lambdabot> Monad m => (a1 -> m b) -> m a1 -> m b
13:54:32 <donri> khyperia: not wrong at all
13:54:36 <khyperia> good
13:54:54 <donri> khyperia: in theory, you can always fmap whenever you can liftM
13:55:05 <donri> khyperia: however the inverse is not always true
13:55:23 <khyperia> just requires monad instead of functor, right? Also, why doesn't saying (Monad m) imply (Functor m)?
13:55:38 <donri> khyperia: it's gonna happen in ghc 7.10, rumor has it
13:55:45 <donri> class (Applicative m) => Monad m
13:56:19 <khyperia> and then doesn't (Functor m) => Applicative m? Or not?
13:56:26 <donri> that's already the case
13:56:28 <donri> @src Applicative
13:56:29 <lambdabot> class Functor f => Applicative f where
13:56:29 <lambdabot>     pure  :: a -> f a
13:56:29 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:57:11 <khyperia> and isn't Applicative => Monad already the case as well?
13:57:13 <Cale> khyperia: This is a historical thing which really doesn't make any sense. I think some of the people who were initially deciding on this stuff didn't understand the fact that you can still define the superclass instance in terms of the subclass operations, making it trivial to write.
13:57:23 <fizruk> @src Monad
13:57:23 <lambdabot> class  Monad m  where
13:57:23 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:57:23 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:57:23 <lambdabot>     return      :: a -> m a
13:57:23 <lambdabot>     fail        :: String -> m a
13:57:37 <khyperia> Oh.
13:58:01 <khyperia> Is there an (instance Monad m => Functor m where) then?
13:58:04 <Cale> (i.e. you can always define  fmap = liftM  and get a valid Functor instance from a Monad instance)
13:58:05 <khyperia> or something?
13:58:15 <Cale> no, you can't write that because it'd overlap with everything
13:58:18 <donri> khyperia: that doesn't do what you want
13:58:46 <khyperia> Or is there a general "if you make a monad, you *probably* should do functor as well" rule
13:59:08 <donri> http://stackoverflow.com/a/3216937/931420
13:59:09 <fizruk> khyperia, every monad is a functor
13:59:31 <Cale> Well, you can consider it a bug if some library fails to include a Functor instance for one of its Monad instances
13:59:36 <ParahSail1n> theres probably some wacky monad in ghc that is not a functor that is holding monad from being subclass of functor
13:59:49 <Cale> (the same basically applies for Applicative in place of Functor as well now)
14:00:05 <Cale> ParahSail1n: Well, that's a truly trivial thing to fix
14:00:21 <donri> khyperia: yes, ghc 7.8 will even spew warnings at you if a monad is not an applicative
14:00:31 <Cale> It's a one-line fix:  instance Functor MyMonad where fmap = liftM
14:00:52 <khyperia> ah, good, donri
14:01:22 <simpson> So do languages like Agda fix this in their standard typeclasses? What problems did they run int?
14:01:26 <simpson> *into, even?
14:01:34 <Cale> Agda doesn't have typeclasses
14:01:35 <donri> agda doesn't have type classes :)
14:01:48 <fizruk> idris has?
14:01:53 <Eduard_Munteanu> Agda has sort-of-typeclasses.
14:01:59 <WraithM_> Yes, idris does
14:02:15 <simpson> I thought that Agda had monad do-syntax. Maybe I misunderstood.
14:02:26 <Eduard_Munteanu> In fact they are typeclasses, except resolution isn't recursive.
14:03:04 <Eduard_Munteanu> simpson: it has a general 'syntax' construct you can use to define do-syntax, not builtin
14:03:06 <Cale> and the implementations of type classes in Coq, and iirc, Idris too (though it may have changed since I checked) are somewhat flaky, in that they do nothing to try to ensure that instances don't overlap, and when they do overlap, they just pick the first one or last one that matches
14:03:09 <glguy> and you get to control when they are exported or not
14:03:22 <donri> https://github.com/idris-lang/Idris-dev/blob/master/lib/Prelude/Monad.idr
14:03:40 <ParahSail1n> which is the obscure monad in ghc holding everything back?
14:03:57 <donri> ParahSail1n: there isn't one
14:04:02 <glguy> ParahSail1n: There's no monad that can't be a functor
14:04:16 <Cale> There's a great temptation to implement type class instance resolution in dependently typed languages using the same solver that's already used to handle implicit parameters, and I don't think that's usually the right thing to do.
14:04:19 <Eduard_Munteanu> Agda's classes are pretty much implicit parameters that are resolved if there's a single matching value of that type in scope, up to some implicit application.
14:04:54 <Eduard_Munteanu> Cale: we could give up decidable type-checking
14:05:14 <Eduard_Munteanu> Or perhaps require an external solver.
14:06:06 <simpson> I think it'll be cool when auto-derived Functor is less flaky and we can all just use that.
14:06:07 <Eduard_Munteanu> e.g. a tactic that does instance resolution
14:06:15 <Cale> Eduard_Munteanu: Really, I just want some sort of guarantee that modules defining new instances don't change the behaviour of existing programs.
14:06:53 <Cale> Or, present an error in the cases where more than one instance would apply.
14:06:55 <Eduard_Munteanu> Cale: they can't, because existing modules can't import future modules. :)
14:07:28 <Cale> I mean, if my program compiles, and one of the upstream dependencies *adds* an instance, either my program should stop compiling, or it should do the same thing.
14:07:36 <Eduard_Munteanu> Cale: that is reasonable yes.
14:07:36 <donri> i generally get the feeling that, ironically, dependently typed languages give you a lot of ways to shoot yourself in the foot
14:08:17 <donri> for example how case is unimportant so if something is a binding or a constructor in a pattern depends on type and scope, i guess
14:08:38 <ParahSail1n> ah, yeah its the hoopl monad
14:08:54 <donri> or agda's mixfix. as if haskell's fixity situation wasn't crazy enough :p
14:09:11 <Eduard_Munteanu> Cale: I think that sort of ambiguity isn't a problem currently. Agda merely lets you fill in certain implicits, and if you still have multiple choices, it bails out.
14:09:15 <Cale> ParahSail1n: Even if there's a monad instance in GHC which is missing its Functor instance, we can add one easily.
14:09:46 <ParahSail1n> yeah im sure theres no reason you couldnt trivially make it functor
14:09:52 <Eduard_Munteanu> Cale: you need implicits resolution because a lot of types have things like Set level arguments
14:09:53 <osa1_> do I need to add an extra parameter to cabal file to enable GHC optimizations or are they enabled by default?
14:10:22 <donri> osa1_: -O[1] is default
14:10:24 <Cale> Eduard_Munteanu: Yeah, I can't say for Agda. Last I checked, Coq and Idris had the opposite policy about overlapping instances, one of them always chose the first defined instance which satisfied the constraints, and one always chose the last.
14:10:40 <osa1_> donri: what is maximum possible value? 2?
14:10:45 <donri> yes
14:10:52 <Eduard_Munteanu> Cale: ah, yeah, that's not really reasonable for programming.
14:10:59 <ion> donri: You’re obviously not a Gentoo user.
14:11:04 <osa1_> okay thanks. I think I'll add a cmd flag to switch between -O0 and -O2
14:11:27 <donri> ion: -fexpose-all-unfoldings? ;)
14:11:41 <Earnestly> -funroll-loops -O11
14:11:53 <ion> I can totally tell -O11 made it a bit faster.
14:11:55 <osa1_> where should I add this parameters? to ghc-options field?
14:12:22 <donri> osa1_: why do you feel you need to add that to .cabal?
14:12:41 <Eduard_Munteanu> Cale: I wish this stuff was implemented in the language itself. That should be possible for Haskell as well, you can let some TH code iterate over top-level declarations and pick one.
14:12:41 * ski . o O ( `-funroll-loops -Ωω' )
14:12:44 <osa1_> donri: I think I just mentioned that above
14:12:57 <Eduard_Munteanu> Ow! :)
14:13:06 <Cale> I thought it was kind of funny back when GHC didn't do clamping on -O numbers so that when you did -O3 it just silently didn't turn on any optimisations.
14:13:08 <donri> osa1_: don't think you did...
14:13:16 <Eduard_Munteanu> Ωωλ? :)
14:13:20 <donri> Cale: haha
14:13:21 <ion> cale: hah
14:13:30 <WraithM> I'm trying to turn on profiling on a code where I've imported Data.Vector. I get this error:
14:13:34 <WraithM> Could not find module `Data.Vector' Perhaps you haven't installed the profiling libraries for package `vector-0.10.0.1'?
14:13:36 <donri> is this back in the day when type errors caused the source file to be deleted
14:13:37 <osa1_> donri: to ensure my program compiled with all optimization enabled and make compilation faster when I'm developing by adding -fdevel flag
14:13:50 <Cale> donri: I'm pretty sure it was well after that point
14:13:53 <WraithM> Has anybody experienced this problem?
14:14:01 <Cale> I think it was like 6.4 or something which fixed that.
14:14:19 <Heffalump> WraithM: it's quite commmon if you installed other packages without profiling
14:14:39 <Heffalump> or if vector came in a Linux distribution or similar then you may need to get the profiling package
14:14:54 <Heffalump> the simple thing is cabal install vector --reinstall --enable-library-profiling
14:14:55 <FireFly> donri: was that some evil scheme to discipline programmers into understanding types correctly?
14:15:02 <donri> osa1_: anyways yes ghc-options if you must. but you can also configure it for your system in ~/.cabal/config e.g. optimization: [N], and pass it to cabal invocations with -O[N]
14:15:11 <WraithM> Heffalump: Thank you!
14:15:11 <Heffalump> but you might have to manually follow a chain of dependencies from vector
14:15:18 <FireFly> s/into/so that they/
14:15:21 <fizruk> ParahSail1n, why can't one make fmap = liftM for hoopl monad?
14:15:34 <donri> FireFly: :) rumor has it it was a bug in ghc for a short while
14:16:16 <Eduard_Munteanu> And if you want decidable typechecking, you just need to ensure your TH splicing halts, e.g. perhaps embed a strongly-normalizing DSL to describe instance resolution.
14:16:20 <WraithM> Heffalump: Is there a way to have profiling added by default? I just got an error on a dependency which didn't have profiling on.
14:16:32 <WraithM> (on a dependency for vector)
14:17:03 <donri> WraithM: library-profiling: True
14:17:12 <donri> in ~/.cabal/config
14:17:21 <donri> you'll need to reinstall all the things :P
14:17:38 <Eduard_Munteanu> BTW, what do you call Either Nat ω? Cardinal?
14:17:40 <Cale> /r/haskellcirclejerk  DAE -fglasgow-exts???
14:18:14 <ski> Eduard_Munteanu : no
14:18:24 <WraithM> donri: Fair enough :D Is there a good way to reinstall all the things?
14:18:32 <Eduard_Munteanu> ski: any suggestions?
14:18:33 <WraithM> Or should I start from scratch?
14:18:49 <Eduard_Munteanu> ski: I want to define unified vecs / streams
14:19:03 <donri> WraithM: maybe you don't have to all the things if you do something like --reinstall --force-reinstalls to that particular cabal invocation
14:19:15 <Eduard_Munteanu> ski: Vec ω a is pretty much Stream a
14:19:36 <donri> WraithM: otherwise, something like rm ~/.ghc ~/.cabal/lib; cabal install world
14:20:21 <ski> Eduard_Munteanu : Charity apparently calls then conaturals
14:20:25 <ski> @where Charity
14:20:26 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
14:20:27 <WraithM> donri: Yeah, I think I'll just rebuild my package with --reinstall --force-reinstalls
14:20:32 <WraithM> donri: Thank you :)
14:20:47 <Eduard_Munteanu> ski: oh, right... Agda calls them CoN, too, I forgot.
14:20:49 <donri> good luck
14:20:50 <WraithM> And if it gets out of control, I'll just rm .ghc
14:20:56 <WraithM> I've been here before
14:21:02 <donri> :)
14:21:05 <ski> Eduard_Munteanu : it's common to see them notated as `ℕ ∪ {∞}'
14:21:13 <donri> the monthly cleansing
14:21:42 <WraithM> I'll have all of you guys know, I only cried six times when I tried to get xmonad working just the way I wanted.
14:22:31 <Eduard_Munteanu> ski: ah, that doesn't name them though. I still think it's awkward how easy it is to prove ℕ ~ CoFin ω, where CoFin is a Fin parametrized by Coℕ
14:22:47 <ski> Eduard_Munteanu : in the category of dynamical systems, they form the subobject classifier
14:23:10 <Philonous> Cale, what are those arcane incantations you are muttering?
14:23:22 <Eduard_Munteanu> ski: oh, as in Coℕ -> a  ~   Stream a   ?
14:23:49 <Eduard_Munteanu> Er, not that.
14:24:00 <Eduard_Munteanu> I think you are talking about values at infinity.
14:24:15 <ski> Eduard_Munteanu : no, `ℕ → a  ≅  Stream a'
14:24:25 <Cale> WraithM: That's high praise indeed, given the state of window managers these days
14:24:27 <Eduard_Munteanu> As in "final value theorem".
14:24:32 <Eduard_Munteanu> Yeah.
14:25:40 <ski> Eduard_Munteanu : anyway, `0' represents "(eternally) true", `∞' "(eternally) false", `1' "false right now but (eternally) true after one time step", `2' "false now and in the next time instant, but then true henceforth", &c.
14:25:53 <ski> Eduard_Munteanu : a dynamical system merely being a set with an endofunction on it
14:26:07 <Eduard_Munteanu> ski: initial state + step?
14:26:51 <ski> Eduard_Munteanu : if we have two dynamical systems with a mono from the first to the second, then if we take a point in the second which happens to lie in the first, then all "future values" will also lie inside the first -- so, "once true, eternally true"
14:26:52 <Eduard_Munteanu> Sounds like dynamic systems from control theory.
14:27:21 <ski> Eduard_Munteanu : but if we take a point outside the first, then we might or might not end up inside the first, after a finite number of steps
14:28:02 <ski> Eduard_Munteanu : if we don't, then the "truth-value" of whether we're in the subobject is `∞', otherwise it's the (finite) number describing how many steps we must wait before we get inside
14:28:13 <Eduard_Munteanu> Oh, hm.
14:28:33 <ski> and `not' maps `∞' to `0' and everything else to `∞'
14:29:38 <WraithM> donri: I gave up, and rm'd .ghc and .cabal/lib. cabal install world gave me a bunch of dependency errors :/
14:29:54 <ski> `∧' simply takes the maximum of the given truth-values (conaturals), while `∨' takes the minimum
14:32:11 <Eduard_Munteanu> ski: I wonder what 'CoN -> a' is... a continuous stream? One that doesn't necessarily produce a full value every step?
14:57:38 <khyperia> .@src liftM uses do-notation (liftM f m1 = do { x1 <- m1; return (f x1) }), just checking to make sure I know a bit of how do-notation works, this is the same as "liftM f x = x >>= return . f"?
15:00:54 <geekosaur> @undo do { x1 <- m1; return (f x1) }
15:00:54 <lambdabot> m1 >>= \ x1 -> return (f x1)
15:01:14 <khyperia> ... I was about to say "there should be an @undo command"
15:01:18 <khyperia> and then apparently...
15:01:27 <geekosaur> @. pl undo do { x1 <- m1; return (f x1) }
15:01:30 <lambdabot> m1 >>= return . f
15:01:30 <lambdabot> optimization suspended, use @pl-resume to continue.
15:01:42 <sipa> @pl-resume
15:01:48 <lambdabot> m1 >>= return . f
15:01:49 <lambdabot> optimization suspended, use @pl-resume to continue.
15:01:50 <khyperia> Oh, neat, didn't realize @. existed
15:03:00 * hackagebot tasty-hspec 0.1 - Hspec support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hspec-0.1 (mitchellwrosen)
15:05:35 <Athas> Any suggestions on GHC flags to reduce memory consumption for a module when it's loaded in GHCi?  I have a nasty issue where reloading a Happy-generated parser ends up consuming gigabytes upon gigabytes of memory until my computer runs out.
15:05:44 <Athas> Probably a GHCi bug, but for now, I'm looking for workarounds...
15:06:18 <mitchellsalad> hi, i just uploaded this to hackage http://hackage.haskell.org/package/tasty-hspec, but the docimentation isnt hyperlinked
15:06:22 <mitchellsalad> what did i do wrong?
15:06:50 <donri> mitchellsalad: it builds periodically not on upload
15:06:58 <mitchellsalad> oh
15:07:05 <mitchellsalad> okay, thanks
15:07:17 <donri> mitchellsalad: it's built now btw
15:07:25 <donri> maybe it is on upload in hackage2?
15:18:02 * hackagebot tasty 0.4 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.4 (RomanCheplyaka)
15:18:04 * hackagebot tasty-golden 2.2 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2 (RomanCheplyaka)
15:18:10 <pharaun> and its also delicious too ^
15:20:53 <jml> there's a more idiomatic way to do "case x of\n Left y -> Left y\nRight z -> Right (f z)"
15:21:22 <jml> I can't recall what it is
15:21:35 <roboguy_> fmap
15:21:40 <roboguy_> fmap f x, I think
15:21:45 <thoughtpolice> jml: either id f x
15:21:51 <thoughtpolice> :t either
15:21:52 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:22:06 <jml> thanks!
15:22:43 <thoughtpolice> oh, nvm, i misread your Q, sorry :( that won't give you back an either, and the result types of both functions must unify
15:22:47 <thoughtpolice> (but maybe that's OK in this case)
15:23:11 <thoughtpolice> fmap is actually the correct way as roboguy_ said
15:23:18 <Philonous> @type \f -> either Left (Right . f)
15:23:19 <lambdabot> (b -> b1) -> Either a b -> Either a b1
15:23:30 <jml> yeah, fmap is what I wanted
15:23:37 <Philonous> @type fmap :: (a -> b) -> Either l a -> Either l b
15:23:38 <lambdabot> (a -> b) -> Either l a -> Either l b
15:25:06 <srhb> I am confused. I'm trying to write a little terminal multiplexer and got stuck on step 1; System.Posix.Terminal.openPseudoTerminal seems to give back values of type Fd, but shouldn't I be getting handles for stdin, stdout and stderr? I'm probably confusing concepts here.
15:28:03 * hackagebot time-exts 1.0.0 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-1.0.0 (EnzoHaussecker)
15:29:31 <geekosaur> since it's in System.Posix you're getting Posix file descriptors back
15:29:41 <geekosaur> @hoogle fdToHandle
15:29:41 <lambdabot> GHC.IO.Handle.FD fdToHandle :: FD -> IO Handle
15:29:42 <lambdabot> System.Posix.IO.ByteString fdToHandle :: Fd -> IO Handle
15:29:42 <lambdabot> System.Posix.IO fdToHandle :: Fd -> IO Handle
15:30:02 <srhb> Ah, so I can just convert them. Hmm.
15:33:28 <donri> or use the Fd based APIs in that same package
15:34:05 <ownclo> Good day, gentlemen! I wonder is there a better way to deal with State function that looks like: get >>= \s -> guard (valid s) >> put (f s). That seems to be very common pattern...
15:35:07 <ski> Eduard_Munteanu : hmm .. naively, it would be a pair of an ordinary stream, and an extra element
15:35:20 <sie> Does monad typeclass only insure it's got the binding operators defined?
15:36:01 <Eduard_Munteanu> ski: data Conat = Finite Nat | Cosucc Conat   -- less naively
15:36:40 <ski> Eduard_Munteanu : `Coℕ → a  ≅  (ℕ + ⊤) → a  ≅  (ℕ → a) ⊗ (⊤ → a)  ≅  Stream a ⊗ a'
15:37:04 <roboguy_> sie: what do you mean?
15:37:12 <ski> Eduard_Munteanu : however, i'm not convinced `Coℕ  ≅  ℕ + ⊤' would be right, computationally
15:37:16 <Eduard_Munteanu> ski: er, that's not ok... data Conat = Finite Nat | Infinite | Cosucc Conat
15:37:53 <Eduard_Munteanu> I think you want CoN ~ N + CoN
15:38:18 <donri> ownclo: modify f where f s | valid s = .. | otherwise = s  maybe?
15:38:21 <ski> `codata CoNat where Pred :: CoNat -> Maybe CoNat'
15:38:29 <Eduard_Munteanu> ski: I have to go AFK a bit, I'll come back later
15:38:35 <ski> with `Pred infinity = infinity'
15:38:46 <ski> hm, no
15:38:53 <ski> `Pred infinity = Just infinity'
15:39:14 <ski> (would be defining `infinity :: CoNat'
15:39:15 <ski> )
15:39:34 <sie> roboguy_, I'm just wondering what's the purpose of the monad typeclass.
15:39:52 <ski> Eduard_Munteanu : i'm not sure where your `Finite Nat' vs. `Cosucc Conat' is coming from
15:40:02 <ski> (nor do i think `Infinity' should be a constructor)
15:40:35 <ski> (er, s/Infinity/Infinite/)
15:41:22 <Eduard_Munteanu> ski: for any n :: Nat, Cosucc n :: Conat. Also, for any n :: Conat, Cosucc n :: Conat as well, morally.
15:41:45 <roboguy_> sie: are you familiar with the purpose of the Functor typeclass?
15:42:00 <ski> ownclo : or just define `modifyWhen :: StateMonad s m => (s -> Bool) -> (s -> s) -> m ()' ?
15:42:15 <Eduard_Munteanu> ski: IOW, not only you have ω, you also have ω + 1, ω + 2 etc.
15:42:59 <ski> or perhaps s/modifyWhen/modifyAssert/ or something would be better, to emphasize that `mzero' is used in case the check fails
15:43:06 * Eduard_Munteanu goes afk
15:43:32 <ownclo> donri: 'otherwise' clause will leave the state untouched. I am probably asked the wrong question, since I fail to find what is a 'mzero' for State monad is. This guard is actually used within StateT ... Maybe ... monad, so 'mzero' will abort the computation
15:43:47 <ownclo> donri: 'otherwise' clause will leave the state untouched. I am probably asked the wrong question, since I fail to find what is a 'mzero' for State monad. This guard is actually used within StateT ... Maybe ... monad, so 'mzero' will abort the computation
15:44:21 <ski> Eduard_Munteanu : but that's not conaturals, at least not in the Charity sense, not in the `ℕ ∪ {∞}' (which i believe to be basically the same thing)
15:45:00 <ski> ownclo : yeah, i suspected that was important to you
15:45:26 <ski> ownclo : so define `modifyAssert' or `modifyGuard' or whatever you want to call it ?
15:45:56 <ski> an alternative would be `modifyGuard :: StateMonad s m => (s -> Maybe s) -> m ()'
15:46:14 <ownclo> donri: yeah, I'll try that, thank you. I just wondered whether a 'canonical' implementation exists
15:46:30 <ski> hm, well, we need `MonadZero m' (or in the lack of that, `MonadPlus m'), as well
15:46:52 <ski> ownclo : are you confusing me with donri ?
15:47:16 <ownclo> ski: omg, yes, that's true, I'm sorry
15:47:18 <sie> roboguy_, Not yet, I will look at ti.
15:47:21 <ski> ownclo : np
15:47:53 <roboguy_> sie: I think it's good to learn about Functor before Monad
15:48:15 <skypers> hi
15:48:18 <ski>   fixedPointIterate :: MonadZero m => (s -> m s) -> (s -> m s)  -- hm
15:48:21 <skypers> is the a way to discard warnings like
15:48:21 <skypers>     Defined but not used: `attach2DTexture'
15:48:25 <skypers> ?
15:48:37 <skypers> it’s seriously annoying when writing a lib…
15:48:45 <ski> sie : yes, first `map', then perhaps some `mapTree' and similar stuff, then `Functor' with `fmap', before attempting `Monad'
15:49:51 <ski> sie : still, you can learn how to do basic I/O (without understanding the details), before attempting `Monad'
15:50:51 <sie> I get on with I/O well now, but I care about how it all works now.
15:51:20 <ski> sie : anyway, "Does monad typeclass only insure it's got the binding operators defined?" -- if a type function (like `Maybe' or `IO' or `Either String' or `[]') is an "instance" of the type class `Monad', that means there's versions of the `return' and `(>>=)' ("bind") operations defined for that type
15:51:38 <ski> e.g., for `Either String', this means that there are implementations of
15:51:44 <ski>   return :: a -> Either String a
15:51:56 <ski>   (>>=) :: Either String a -> (a -> Either String b) -> Either String b
15:52:07 <ski> and they happen to look like
15:52:11 <ski> @src Either return
15:52:11 <lambdabot> return        = Right
15:52:14 <ski> @src Either (>>=)
15:52:14 <lambdabot> Left  l >>= _ = Left l
15:52:14 <lambdabot> Right r >>= k = k r
15:52:15 <skypers> ski: and optionnaly fail, yeas
15:52:17 <skypers> yeah*
15:52:27 <ski> yes (and also `(>>)')
15:52:36 <skypers> it’s optionnal, but yes.
15:53:32 <ski> sie : also, these two operations can't do anything at all (which is allowed by the types), but must satisfy a few "laws" -- similar to how you expect `a + b = b + a' for types in class `Num'
15:53:49 <ski> sie : have you seen `map' yet ?
15:53:51 <ski> @type map
15:53:52 <lambdabot> (a -> b) -> [a] -> [b]
15:53:59 <skypers> ahah ski
15:54:13 <skypers> if we actually hasn’t seen it
15:54:25 <skypers> talking about monads might be dark magic for him :––’)
15:54:52 * ski thinks sie has probably seen `map', but would like confirmation
15:55:06 <skypers> personnally
15:55:16 <Narvius2> I took me reimplementing State, Maybe and [] to grokk monads. _^_
15:55:19 <skypers> I think one cannot see Monad before Applicative
15:55:44 <skypers> the <*> introduces applicative style
15:55:47 <ski> skypers : .. i saw `Monad' before `Applicative' existed, am i a contradiction ?
15:55:54 <skypers> and >>= is quite in some way applicative as well
15:56:01 <skypers> ski: no
15:56:06 <skypers> but it’s simplier
15:56:12 <ski> possibly
15:56:44 <ski> skypers : which particular applicatives would you suggest starting to look at first ?
15:56:46 <skypers> (<*>) unwraps a function from an Applicative and wraps the result
15:57:09 <skypers> >>= does exactly the same thing, except that the function is now outside the “container”
15:57:10 <ski> skypers : `Maybe', `[]', `State s', parsers ?
15:57:16 <skypers> Maybe
15:57:19 <skypers> definitely.
15:57:22 <ski> and then ?
15:57:26 <skypers> then Writer
15:57:30 <skypers> State
15:57:36 <skypers> and Reader
15:57:43 <ski> > replicateM 3 "ab"
15:57:45 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
15:57:58 <Philonous> skypers, "unwraps" sounds like there's exactly one.
15:58:06 * hackagebot time-exts 1.0.1 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-1.0.1 (EnzoHaussecker)
15:58:08 <skypers> one what?
15:58:29 <Philonous> skypers, You said "unwraps a function". That implies that there is a function stored somewhere
15:58:40 <skypers> Philonous: well
15:58:45 <Philonous> skypers, Or at least it sounds like it.
15:58:52 <skypers> (+1) <$> Just 4 <*> …
15:58:59 <skypers> there’s a function here isn’t it?
15:59:20 <briennetheblue> but it could be the absence of a function too :P
15:59:31 <Philonous> (,) <*> readFile "hello.txt" <-- there's no function stored.
15:59:31 <skypers> for <*> ?
15:59:41 <skypers> (,) is a ctor
15:59:54 <Philonous> (,) <$> readFile "hello.txt"  I mean
16:00:00 <ski> hm, there should be a `replicateA :: Applicative i => Int -> i a -> i [a]', no ?
16:00:13 <skypers> :t (<*>)
16:00:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:00:23 <skypers> f (a -> b)
16:00:25 <srhb> Hm, I still don't understand how this works. Presumably I'm supposed to hook up a shell to these Fds returned by openPseudoTerminal, but none of the functions in System.Posix.Process take Fds
16:00:26 <skypers> here’s your function.
16:00:38 <Zekka> Sorry to bother folks, quick question. I've got a typeclass `ColorGenerator c o r`. I'd like to define a synonym OutputColor which would be represented along the lines of (pseudocode) OutputColor c o = ColorGenerator c o RGBAColor. Is this possible/advisable?
16:00:45 <Philonous> Nothing :: Maybe (a -> b) -- please give me my function
16:00:48 * ski would prefer "reflect" to "unwrap" -- but then one would have to explain what is meant
16:00:48 <briennetheblue> > Nothing <*> Just 1
16:00:49 <lambdabot>   Nothing
16:00:55 <ski> (which might be for the better, anyway)
16:00:58 <skypers> Philonous: oh sure
16:01:03 <briennetheblue> that's an absence of a function :p
16:01:09 <skypers> I was talking about the type system :)
16:01:19 <skypers> btw
16:01:21 <skypers> Nothing
16:01:26 <skypers> it can have a lot of types
16:01:45 <skypers> and Nothing :: Maybe (Int -> Bool) is perfectly ok
16:01:51 <Zekka> I know Haskell supports type synonyms but I'm not sure if it supports typeclass synonyms. I might go around and try to solve this problem a different way
16:01:55 <Philonous> skypers, I just don't like the word "unwrap" because it sounds like there's a function stored somewhere.
16:01:56 <ski> "reflect" being similar to "unwrapping" a set to "get at the elements". e.g. when we say "The kittens are sleeping.", we're talking about a reflected set, iow talking about each of the members individually
16:02:07 <donri> Zekka: ConstraintKinds!
16:02:21 <Zekka> donri - Is that an extension? One second, I'll look it up
16:02:23 <skypers> Philonous: well, it depends on the Applicative, yes
16:02:37 <skypers> it “might” be a function
16:02:41 <skypers> is that better? :)
16:02:51 <Philonous> briennetheblue, It might also be multiple functions (think [a -> b]) or IO actions returning functions etc.
16:02:56 <donri> Zekka: type PoorMan'sSerialize a = (Read a, Show a)
16:02:57 <briennetheblue> yup
16:03:15 <briennetheblue> i just meant that as one counter example
16:03:17 <ski> another way to think about "unwrap"/"reflect" is to think of it as "reasoning inside the `Maybe' (or whatever)"
16:03:26 <Zekka> That seems pretty close to what I'm trying to accomplish: thanks
16:03:42 <ski> sie : well, have you seen `map' yet ? ;)
16:03:53 <skypers> I think he should start with list mapping, yes
16:04:00 <skypers> then filtering lists out
16:04:04 <skypers> folding them down
16:04:08 <skypers> and then
16:04:17 <skypers> generalizing the concept of map to fmap
16:04:24 <ski> then continuations, mayhaps ?
16:04:33 <skypers> the first time I had to generalize map -> fmap
16:04:35 <skypers> it was hm
16:04:37 <Philonous> ski, Yes, please.
16:04:40 <skypers> hard for me to get it :D
16:04:54 <sie> ski, yup
16:05:04 <ski> skypers : had you seen `mapTree :: (a -> b) -> (Tree a -> Tree b)' at that time ?
16:05:11 <sie> But it has no monadaic shenanigans going on, does it?
16:05:16 <skypers> ski: well
16:05:16 <ski> sie : and `filter',`foldr', list comprehensions ?
16:05:30 <skypers> when you got what the class Functor is
16:05:36 <sie> those too.
16:05:38 <ski> skypers : no monads in `map' or `Functor', no
16:05:40 <skypers> mapTree is kinda trivial :)
16:05:42 <ski> er
16:05:44 <ski> sie ^
16:05:47 <sie> aha
16:05:53 <ski> sie : have you seen user-defined datatypes ?
16:05:59 <skypers> funny thing to do
16:06:02 <skypers> is comparing fmap
16:06:04 <ski> sie : binary trees (of various kinds) ? rose trees ?
16:06:05 <skypers> and liftM
16:06:15 <skypers> and after that
16:06:24 <skypers> you understand that fmapping things
16:06:28 <skypers> is a simple lifting operation
16:06:29 <skypers> :)
16:06:29 <sie> I think I have.
16:06:39 <ski> sie : have you seen `mapTree :: (a -> b) -> (Tree a -> Tree b)' ?
16:06:51 <skypers> but it’s for people who already have heard of functor mapping
16:07:00 <sie> Nope, that I haven't seen.
16:07:04 <skypers> :t mapTree
16:07:05 <lambdabot> Not in scope: `mapTree'
16:07:14 <skypers> I knew it! :D
16:07:24 <skypers> the one I like is maybeMap
16:07:27 <skypers> :t maybeMap
16:07:28 <lambdabot> Not in scope: `maybeMap'
16:07:30 <skypers> :o
16:07:35 <skypers> :t mapMaybe
16:07:36 <lambdabot> (a -> Maybe b) -> [a] -> [b]
16:07:39 <skypers> yeah that one.
16:07:45 <ski>   data Tree a = Leaf a
16:07:48 <ski>               | Branch (Tree a) (Tree a)
16:07:50 <ski>                 deriving (Eq,Show,Read)
16:08:05 <ski> sie : is a type of simple binary trees, with elements in the leaves
16:08:05 <skypers> it’s what, a map then a filter isJust ?
16:08:09 <skypers> @src mapMaybe
16:08:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:08:21 <nooodl> sounds like a map then a catMaybes
16:08:33 <skypers> yeah catMaybe
16:08:34 <ski> sie : you can easily write a `flatten :: Tree a -> [a]', that extracts the leaves
16:09:06 <ski> sie : you can also write an `unflatten :: [a] -> Tree a', that attempts to make a roughly balanced tree (well, assuming the input list isn't empty)
16:09:08 <Zekka> donri - Thanks, wrote code that looks about how I expected it to look and it compiles.
16:09:15 <donri> \o/
16:09:30 <skypers> @pl mapMaybe
16:09:30 <lambdabot> mapMaybe
16:09:32 <Zekka> whether it's necessarily correct or sane I'll see later
16:09:34 <skypers> hihi :D
16:10:12 <ski> sie : you can define other operations of interest as well, like `smashTree :: (a -> a -> a) -> (Tree a -> a)', that smashes all elements together, using an argument function to apply at each branch
16:10:24 <ski> sie : using that, you can easily write `sumTree :: Num a => Tree a -> a'
16:10:43 <skypers> anyway sie, you may want having fun with fmap, filter and fold before getting into Monads
16:10:53 <skypers> those are terriblly violent :)
16:10:58 <jrmithdobbs> does someone know of another (preferably complete/functional) example of interfacing with a json rest api than https://github.com/BJTerry/mailchimp ? that just seems like an awful lot of boilerplate and i'm looking for other examples (no offense if the author is around ;p)
16:11:10 <ski> sie : and you can write `mapTree :: (a -> b) -> (Tree a -> Tree b)' that transforms a function operating on elements to a function operating on trees
16:11:26 <ski> sie : iow, given a function and a tree, it yields a new tree with the function applied at every leaf
16:11:30 <skypers> does he event have a Tree data?
16:11:41 <FireFly> ski gave one a while ago
16:11:49 <ski> sie : with slightly different tree types you can have more fun
16:11:53 <BMeph> jrmithdobbs: Have you checked out aeson?
16:11:55 <FireFly> if you meant the definition of the Tree type
16:12:05 <skypers> he can start with mapMaybe :: (a -> b) -> Maybe a -> Maybe b
16:12:11 <skypers> the implementation is simple
16:12:20 <skypers> yeah well
16:12:22 <skypers> too simple.
16:12:41 <ski>   data NodeTree a = Tip
16:12:47 <ski>                   | Node a (NodeTree a) (NodeTree a)
16:12:50 <ski>                     deriving (Eq,Show,Read)
16:12:58 <skypers> hey ski
16:13:02 <skypers> interesting data
16:13:04 <skypers> why not
16:13:09 <ski> sie : this admits empty trees, and has elements inside nodes instead of at the leaves
16:13:31 <jrmithdobbs> BMeph: yes i'm getting more familiar with aeson but i'm looking for strategies for dealing with very-not-haskell-oriented data types, eg, this one inparticular kind of assumes you have something like ruby's mixins and similar to share an assload of attributes between different types (instead of say having a request/response type that contains members with the various differently typed results)
16:13:37 <ski> sie : you can write three useful, different, "flatten" functions for this kind of tree, care to figure them out ?
16:13:50 <Zekka> Next question: is it possible to make anything that implements an existing typeclass implement a second one as well? I've got two typeclasses that express related tasks: one is pure, one is impure, and instances of the typeclass containing the pure methods should automatically redirect the impure equivalent methods to the pure ones
16:14:05 <skypers> data NodeTree a = Node a (NodeTree a) (NodeTree a)
16:14:17 <Zekka> Ideally I'd just be providing default implementations in each case
16:14:24 <jrmithdobbs> BMeph: i have a basic framework for how to accomplish what I want but it involves writing a whole lot more tedious boilerplate cruft so I'm just looking for inspiration ;p
16:14:27 <skypers> data Node a = Maybe (NodeTree a)
16:14:28 <skypers> and so on
16:14:34 <skypers> I’ve heard of such a situation
16:14:38 <skypers> on the haskell wiki
16:14:45 <skypers> it’s advised not to use empty ctor
16:14:49 <ski> sie : also, you can write `subTrees :: NodeTree a -> NodeTree (NodeTree a)', that replaces every element at a node with the subtree starting at that node -- you can use this together with `mapNodeTree :: (a -> b) -> (NodeTree a -> NodeTree b)' to compute the sum of every subtree
16:14:50 <jrmithdobbs> BMeph: the project i linked already gave me a few ideas to simplify some of what I'm doing
16:14:51 <skypers> and prefer using Maybe
16:14:54 <Zekka> so, for instance, generate c o = return (role c o)
16:15:26 <jrmithdobbs> BMeph: right this moment i'm thinking of using gadts to sort of merge the types but i'm not sure i like the idea =/
16:15:32 <skypers> I still wonder why data NodeTree a = Empty | NodeTree a (NodeTree a) (NodeTree a) would be bad
16:15:57 <skypers> if you have the anwser… ;)
16:15:59 <skypers> let me know
16:16:01 <skypers> shower time
16:16:16 <ski>   data RoseTree a = Twig a [RoseTree a]
16:16:17 <ski>                     deriving (Eq,Show,Read)
16:16:32 <Zekka> I'm used to languages with more conventional OO-style type systems and this is the sort of thing that's trivially expressible with inheritance but which seems a little harder to express in Haskell's type system
16:16:51 <ski> sie : is yet another kind of tree. try defining interesting operations on it, including `mapRoseTree :: (a -> b) -> (RoseTree a -> RoseTree b)'
16:16:59 <jrmithdobbs> BMeph: i've actually already forced most of my types into forms that the template generators of aeson produce *almost* acceptable input for the service, I'm just delaying doing the boring parts, ha
16:17:45 <Zekka> I imagine it's probably possible in some way - Haskell seems to provide a couple of builtin typeclasses where membership in one should imply membership in another (if you're an Applicative, you're also a Functor) even if it's not codified by the language in some of those cases
16:17:46 <ski> Zekka : "is it possible to make anything that implements an existing typeclass implement a second one as well?" -- yes, but you don't often want this (in the strict sense)
16:18:00 <Zekka> ski - Can you go into a little detail why I probably don't want this?
16:18:26 <Zekka> I can use constraints instead but I feel like I'd be writing a bit of extra redundant code
16:18:27 <ski> Zekka : btw, every haskell operation is pure, no impure stuff in Haskell
16:18:36 <Zekka> ski - Yeah, I should have written 'monadic' or 'effectful'
16:18:49 <Zekka> it's not really impure but I'm sequencing with side effects
16:19:16 <ski> Zekka : because if you say `instance Class0 a => Class1 a where ...', then this applies to *every* `a', no exceptions !
16:19:38 <jrmithdobbs> does using gadts and an approach like this to solve this seem like overkill? http://www.haskell.org/pipermail/glasgow-haskell-users/2012-August/022711.html
16:19:42 <cfoch> hello... has somebody installed wxhaskell in Fedora?
16:19:57 <Zekka> I'm a little bit confused here because I'm not sure why an exception would make sense in this case
16:20:21 <ski> Zekka : the `Applicative' vs. `Functor' case is different : `Applicative' is *defined* to only be possible for types which are already in `Functor'
16:20:56 <Zekka> ski - Yes, I'm aware. Applicative (in a better world) would be constrained to accepting Functors
16:20:58 <pdxleif> Is there a way to list the total transitive dependency tree of a package?
16:21:08 <Zekka> while my situation is automatically deriving instances
16:21:19 <ski> Zekka : if you're not after exceptions, then it's not clear why you need the second class at all, as opposed to defining separate operations with constraints involving the first one
16:21:37 <ski> sie : anyway, if you feel like, you could try some of what i suggested above
16:22:02 <sie> I have put them on my mind queue, I will certainly check them out.
16:22:12 <Philonous> Zekka, http://lpaste.net/3795616827455832064
16:22:20 <Zekka> Philonous - Reading, one moment
16:22:49 <Zekka> Philonous - Thanks, I'll probably ask Ski a bit more though and evaluate my current code a bit
16:22:51 <ski> (Haskell has effects, but no *side*-effects. effects are explicitly declared in the interface (type signature) of operations, instead of silently happening on the side of computing the result value. strictly speaking, the effects are *part* of the result value)
16:23:28 <roboguy_> Zekka: attempting to express OO-type things with type classes is probably not a good idea
16:23:41 <FireFly> ski: thanks for the exercises re. trees
16:23:50 <ski> yw
16:23:51 <Philonous> Zekka, An empty instance will use the default implementations but you can override them
16:24:17 <roboguy_> it is unfortunate that type classes have a similar name to OO classes
16:24:25 <Philonous> Zekka, This doesn't suffer from the problem where you instance declaration will apply to all types
16:24:50 <ski> Philonous' example is similar to the `Functor' & `Applicative' case
16:24:59 <Zekka> Philonous - I saw: you explicitly declared that your Foo was a Bar but used the default implementation
16:25:29 <Zekka> I'll probably just use that, although I might try rewriting my code a bit to see if I can express the same thing that I'm trying to express without two separate typeclasses
16:25:54 * ski thinks that default implementations probably ought to be taken as class laws
16:26:06 <Zekka> because from early on I've been a little unsure about this design
16:26:33 <Zekka> If I kep it I'll probably use philonous' solution and just supply a default implementation with a constraint, it's a little bit safer even though it's more verbose.
16:27:34 <Philonous> Maybe you can get rid of type classes altogether?
16:28:13 <Zekka> I'm not sure but it's possible that's my OO background talking
16:28:58 <jml> is there a function already defined that does: f x = [x]
16:29:01 <roboguy_> Zekka: you shouldn't really think about type classes in the way you think about OO classes. they are pretty different concepts. sometimes they might seem similar, but looking at it in that way can cause issues
16:29:37 <lpaste> srhb pasted “Terminal emulator basics” at http://lpaste.net/95118
16:29:56 <Zekka> I'm aware they're different concepts: I'm not trying to define a literal class, but a common set of operations to convert between members of the class (which is more similar to an interface)
16:30:05 <ski> you should use type classes when : (a) you find you're writing essentially the same code, parameterized by any one of few (at least two) differing sets of "base operations"; and (b) each set of base operations is *determined* by the type(s) it operates on
16:30:08 <srhb> ^ I'm missing a crucial puzzle piece here. I simply have no idea how I launch a shell with this new pseudo terminal
16:30:15 <Zekka> as far as I'm aware this is pretty similar to what's usually accomplished with typeclasses
16:30:20 <roboguy_> Zekka: that's what I meant to say, thinking of them as OO interfaces
16:30:30 <roboguy_> (is often a bad idea)
16:30:31 <ski> (or at least, you shouldn't use type classes otherwise)
16:30:42 <ski> jml : `(: [])'
16:30:55 <jml> ski: thanks
16:31:01 <Zekka> Hold up, I'll describe my usecase a little bit, perhaps you'll have some thoughts
16:31:05 <jrmithdobbs> roboguy_: they're more analogous to the module/mixin relationship in ruby or java's interafecs than to objects directly (even though the former is used for objects)
16:31:07 <ski> > map (: []) "Help"
16:31:09 <lambdabot>   ["H","e","l","p"]
16:32:18 <roboguy_> jrmithdobbs: sort of, but I think the interface analogy can probably be taken too far pretty easily
16:32:50 <Zekka> I've got two kinds of Color: a Color defines a transformation into some other kind of Color given some context (whose type is parameterized), as well as a few other operations
16:32:58 <ski> srhb : i suspect using `dupTo :: Fd -> Fd -> IO Fd' with the gived fds and `stdin',`stdout'
16:33:10 <ski> (and presumably also `stderr')
16:33:14 <skypers> > take 15 $ map (<10) [1..]
16:33:15 <lambdabot>   [True,True,True,True,True,True,True,True,True,False,False,False,False,False...
16:33:21 <skypers> :–’)
16:34:08 <Zekka> One kind of color is transformed into another kind under a monad that keeps track of a random number generator in addition to its ordinary context information (the type of the context information is parameterized in the typeclass)
16:34:09 <skypers> 00:23 < ski> > map (: []) "Help"
16:34:11 <skypers> huh? :D
16:34:11 <jrmithdobbs> roboguy_: well ya, but it's just an analogy, they provide the same basic functionality with different semantics
16:34:15 <skypers> > map id "Help"
16:34:17 <lambdabot>   "Help"
16:34:25 <jrmithdobbs> roboguy_: as long as you remember that last part thinking of them as oo interfaces isn't the worst thing
16:34:37 <Zekka> The other kind is transformed into another kind via a non-effectful operation
16:34:41 <skypers> oh
16:34:46 <skypers> you meant
16:34:49 <ski> Zekka : the difference is that in Java-like OO, you can have a variable whose type is an interface. but you can't have a variable whose type is a type class
16:34:57 <skypers> > map (\a -> [a]) "Help"
16:34:59 <lambdabot>   ["H","e","l","p"]
16:35:03 <roboguy_> jrmithdobbs: yeah that's true
16:35:11 <skypers> (: []) is not really explicit imho
16:35:29 <skypers> @hoogle a -> [a]
16:35:29 <lambdabot> Prelude repeat :: a -> [a]
16:35:30 <lambdabot> Data.List repeat :: a -> [a]
16:35:30 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
16:35:34 <Zekka> (So, the signature of the first is (RandomGen g) => c -> o -> Rand g r, and the second is c -> o -> r, where c is the type of the Color, o is the type of the Context, Rand g is the type of the random number generator in a monad, and r is the type the Color is converted into)
16:35:38 <skypers> @hoogle [a] -> [[a]]
16:35:39 <lambdabot> Data.List inits :: [a] -> [[a]]
16:35:39 <lambdabot> Data.List permutations :: [a] -> [[a]]
16:35:39 <lambdabot> Data.List subsequences :: [a] -> [[a]]
16:35:43 <skypers> arf
16:35:53 <srhb> ski: But. Hm. I don't understand how to launch a shell such that it "knows" to use those Fds
16:35:56 <ski> Zekka : such an interface-typed variable would be essentially a record of private state, together with a record of methods which secretly will get the former record as argument, when the methods are invoked on the variable
16:35:57 <Iceland_jack> > map (take 1 . repeat) "hello"
16:35:58 <lambdabot>   ["h","e","l","l","o"]
16:35:58 <Iceland_jack> :)
16:36:00 <nooodl> i think (:[]) is used often enough to be kind of an "idiom"
16:36:06 <roboguy_> Zekka: So is the "kind" of a color just a sort of "tag"? Meaning that it tells the type system that it is of a certain type, but you don't actually use a value contained in the "kind" type? or am I confused?
16:36:06 <jrmithdobbs> roboguy_: i actually have gobs of ruby code, i've now found out, that if I could override \ as an operator to open a block and s/[.]/ . / it's pratically haskell code ... and it basically treats ruby's modules as haskell's typeclasses even though I didn't know they existed when i wrote it ;p
16:36:18 <Iceland_jack> nooodl: It's still say it's ugly
16:36:20 <ski> Zekka : however, you can't do this with type classes, there's no record of private state, and there's no implicit argument
16:36:22 <skypers> :t return 3 :: [Int]
16:36:23 <lambdabot> [Int]
16:36:34 <Iceland_jack> It's not like (\x -> [x]) is very verbose
16:36:36 <skypers> map return "Help" :: [String]
16:36:41 <roboguy_> jrmithdobbs: really? that's interesting
16:36:42 <jrmithdobbs> roboguy_: (it's also ugly and requires kind_of? calls everywhere since there's no type safety)
16:36:43 <Zekka> roboguy_ - It's not really like that, each color's 'kind' is the type implementing the typeclass
16:36:44 <skypers> > map return "Help" :: [String]
16:36:45 <lambdabot>   ["H","e","l","p"]
16:36:45 <ski> Zekka : it's slightly more like multi-methods, a la CLOS (though not exactl that either)
16:36:45 <Iceland_jack> (or ‘take 1 ∘ repeat) ;)
16:36:47 <skypers> :)
16:36:55 <skypers> might work with pure as well
16:37:02 <skypers> > map pure "Help" [String]
16:37:03 <lambdabot>   Not in scope: data constructor `String'
16:37:09 <roboguy_> Zekka: So what are the kinds that it can be again?
16:37:09 <skypers> > map pure "Help" :: [String]
16:37:10 <lambdabot>   ["H","e","l","p"]
16:37:12 <Zekka> Some colors might be implemented as a block of three fields representing components, others might be an enum
16:37:16 <nooodl> > [[c] | c <- "Help"]
16:37:18 <lambdabot>   ["H","e","l","p"]
16:37:20 <jrmithdobbs> roboguy_: ya i started looking at haskell because i was actually hitting hard interpretter bottlenecks for stuff i was working on ;p
16:37:26 <ski> srhb : iirc, `dupFd' overwrites the target with the source so that if someone then targets `stdout' (e.g.) they will send to the `fd' which was duped to it
16:37:35 <srhb> ski: Oh!
16:37:37 <Zekka> roboguy_ - Well, it depends on the code using the library
16:37:40 <jrmithdobbs> roboguy_: and got really annoyed when i saw how much effort i was wasting to implement it in ruby, lol
16:37:48 <roboguy_> jrmithdobbs: ruby tends a little towards functional anyway though, doesn't it?
16:37:57 <Zekka> Anything can implement a Color and have it be valid if it meets these requirements
16:38:03 <roboguy_> (I only have some familiarity with ruby)
16:38:06 <jrmithdobbs> roboguy_: when used well it does
16:38:10 <ski> srhb : at least, there should be such an operator. iirc, `dupFd' is that operation, but check docs
16:38:12 <skypers> :t foldl ((++) . return) [] "Help"
16:38:13 <lambdabot>     Couldn't match type `Char' with `[a0]'
16:38:14 <lambdabot>     Expected type: [[a0]]
16:38:14 <lambdabot>       Actual type: [Char]
16:38:18 <srhb> ski: Will do, thank you.
16:38:32 <skypers> :t foldl ((++) . return) [] "Help" :: [String]
16:38:33 <lambdabot>     Couldn't match type `[Char]' with `Char'
16:38:33 <lambdabot>     Expected type: [String] -> [String]
16:38:35 <lambdabot>       Actual type: [String] -> [[String]]
16:38:37 <jrmithdobbs> roboguy_: at least, most of my ruby code is pratically functional with objects for typing/organization
16:38:39 <Zekka> (with the not-expressed-in-code requirement that it can eventually be chain-converted into an RGBAColor by repeatedly performing the conversion operation)
16:38:47 <jrmithdobbs> roboguy_: I don't know if that's "Good" or "Bad" ;p
16:38:49 <roboguy_> Zekka: so all it needs to be a color is to have three components? is that the requirement?
16:39:04 <roboguy_> jrmithdobbs: sounds pretty good to me
16:39:14 <skypers> > foldr ((++) . return) [] "Help"
16:39:15 <lambdabot>   "Help"
16:39:19 <skypers> arf
16:39:30 <roboguy_> jrmithdobbs: that's what I wish I could easily do when I use C++, but C++'s functional support is still a little messy
16:39:33 <Iceland_jack> > foldl (\a b -> a ++ [[b]]) [] "Hello"
16:39:34 <lambdabot>   ["H","e","l","l","o"]
16:39:36 <Zekka> roboguy_ - No, it needs to be able to convert to an existing Color via one of the two operation types. There may be other requirements in the future but that's what's necessary at the moment
16:39:44 <roboguy_> hmm, I see
16:40:09 <Zekka> In practice most colors will probably be enumerations of some kind that take a palette as context and then convert to RGBAColor
16:40:09 <skypers> > foldr ((:) . return) [] "Help"
16:40:10 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Types.Char))
16:40:11 <lambdabot>    arising from a use o...
16:40:15 <skypers> > foldl ((:) . return) [] "Help"
16:40:16 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[b0]'
16:40:16 <lambdabot>  Expected type: [[b0]]
16:40:16 <lambdabot>    ...
16:40:21 <skypers> ok stop now :D
16:40:22 <Philonous> Zekka, Ah, so you plan on having instances for all sorts of pairs of colors?
16:40:24 <jrmithdobbs> roboguy_: if only i could find a way to break ~1200 connection/s/core with ruby on tcp protocols (even with evented stuff) i quite like the language. I can't wait until rubinius hits real 2.0 language compatibility as most of my issues with ruby are actually issues with the implementation of the interpretter not the language (I do miss strong typing though)
16:40:25 <Zekka> (which is what it sounds like)
16:40:26 <Iceland_jack> skypers: You can play around lambdabot in PM
16:40:31 <skypers> yeah I know
16:40:42 <skypers> but I’m just off actually
16:40:45 <skypers> night folks
16:40:46 <Zekka> Philonous - I'm expecting users of my system to define their own instances of it, yeah
16:40:51 <Iceland_jack> good night skypers
16:40:55 <Philonous> like instance ColorConvert Pantone RGB
16:41:41 <roboguy_> Zekka: so you are thinking of having a class with something like toColor :: c -> RGBAColor?
16:41:43 <Zekka> PEople will be defining their own color instances along the along the lines of ColorGenerator [type] SteppedPalette RGBAColor
16:42:20 <Zekka> roboguy_ - Close: at present the non-effectful operation is `c -> o -> r` with a special synonym defined where r is RGBAColor
16:42:33 <jrmithdobbs> roboguy_: but hey if my professional life revolves around lamenting over having to use ruby instead of haskell ... i'll consider myself lucky as c++ isn't even in the mix of things i'll admit to knowing enough about to write. ;p
16:42:45 <roboguy_> Zekka: why do you have effectful and noneffectful?
16:42:51 <Zekka> actually, the synonym is for the typeclass including the effectful operation, as (RandomGen g) => c -> o -> Rand g r
16:43:26 <Zekka> roboguy_ - I'm expecting clients to need to operate on their own Colors manually and oftentimes they'll already know that their color can be noneffectfully converted to another type that's simpler to operate on
16:43:44 <roboguy_> jrmithdobbs: haha, yeah. C++ has some interesting quirks. It was pretty much my first language and I've used it for a long time, so it'll always at least have nostalgic value for me
16:44:14 <Zekka> For that there's a standard noneffectful conversion operation defined, although the builtin glue code and other builtin operations that manipulate the colors or eventually generate output will probably prefer the effectful version.
16:44:16 <roboguy_> Zekka: and sometimes it would be effectful?
16:44:33 <Zekka> roboguy_ - Right, for some color kinds a noneffectful operation doesn't make sense
16:44:45 <loadedanvils> for import Network (withSocketsDo) what does the parentheses indicate?
16:44:46 <Philonous> Zekka, care to give an example?
16:45:05 <roboguy_> Zekka: what would be an example?
16:45:07 <Philonous> loadedanvils, it means that it will only import the functions withSocketsDo
16:45:08 <Zekka> suppose you had an enum where one option was BrownOrGrayOrGreen, and it chooses randomly: for that it uses a random number generator inside a monad
16:45:15 <loadedanvils> ok thanks
16:45:17 <loadedanvils> Philonous: thank you
16:45:21 <jrmithdobbs> roboguy_: no you misunderstand, i'm familiar with it (was one of the earlier ones i learned too) I've just somehow managed to never let an employer find out
16:45:26 <jrmithdobbs> roboguy_: harder than it sounds; p
16:45:38 <roboguy_> jrmithdobbs: ah. haha, I see
16:45:39 <Zekka> You can't noneffectfully convert that to an RGBAColor because it isn't known what the true color is until the random number generator arrives
16:46:06 <jrmithdobbs> roboguy_: recently i've found ruby c extensions are actually fairly pleasant to write even ;p
16:46:11 <ski> Zekka : and `CurrentBackground' ?
16:46:19 <jrmithdobbs> but no c++ please
16:46:32 <roboguy_> Zekka: those should be separate from each other though. the effectfulness should probably happen outside of the color conversion.
16:46:36 <Zekka> ski - Where did you get `CurrentBackground` from?
16:46:42 <ski> (perhaps s/Current/Specified/)
16:46:53 <ski> Zekka : i don't know. just wondering whether it would be possible
16:47:08 <Zekka> roboguy_ - One thing I considered was not providing a standard noneffectful conversion and just letting clients define their own
16:47:15 <cfoch> How can I install WXHASKELL?
16:47:16 <Zekka> Er, wait, I misunderstood your comment
16:47:34 <cfoch> or there is a WXHASKELL channel?
16:47:37 <Zekka> roboguy - How could I do that other than providing an effectful conversion operation seperate from the noneffectful one?
16:47:40 <roboguy_> Zekka: you could use a list to represent nondeterminism
16:47:58 <Zekka> That's not a bad thought, come to think of it
16:48:18 <ski> or maybe `[(Double,color)]' if you want weights
16:48:19 <roboguy_> Zekka: and you could have a color conversion give at least one color. so a NonEmpty (which is a non-empty list, as it's name implies) might be in order here
16:49:06 <Zekka> Isn't that basically equivalent to making all operations effectful but using a list and laziness instead of threading a random number gnerator? Which I wouldn't complain about, to be fair.
16:49:17 <jophish_> Is there a function: f :: Num a => [a] -> [a]. where f [1,2,3,5,55] = [1,1,2,10]
16:49:34 <Zekka> so, removing the noneffectful conversion operation entirely and making people perform operations under []
16:49:35 <jophish_> i.e. it takes the difference between successive members.
16:51:27 <roboguy_> Zekka: if that seems appropriate. you might be able to generalize if you want to though (maybe to any monad)
16:51:27 <Philonous> > let f xs -> zipWith (-) xs (tail xs) in f [1,2,3,5,55]
16:51:29 <lambdabot>   <hint>:1:10: parse error on input `->'
16:51:30 <Zekka> ski - I might as well just return a function that gives the true value rather than constraining it to some particular data type: especially given that it's no messier than sequencing it under list anyway
16:51:34 <Philonous> > let f xs = zipWith (-) xs (tail xs) in f [1,2,3,5,55]
16:51:36 <lambdabot>   [-1,-1,-2,-50]
16:51:58 <ownclo> Hello again. Does it exist a function to wrap (pure) function of type 's -> Maybe (a, s)' to 'StateT s Maybe a' computation?  I've just wrote it manually, but
16:52:25 <ownclo> * the code seems to be too boilerplate.
16:52:27 <Philonous> > let f xs = zipWith (-) (tail xs) xs in f [1,2,3,5,15]
16:52:28 <lambdabot>   [1,1,2,10]
16:52:40 <jophish_> Philonous: exactly what I just wrote :)
16:52:41 <jophish_> thanks
16:52:51 <Cale> :t StateT
16:52:52 <lambdabot> (s -> m (a, s)) -> StateT s m a
16:53:00 <Cale> ownclo: ^^
16:53:15 <Zekka> roboguy_ - I'm probably going to keep sequencing it under Rand for now, since it doesn't really seem to provide different results from sequencing under list if my understanding of types is strong enough
16:53:48 <ownclo> Cale: oh, StateT is exported... lol, thank you ;)
16:53:49 <ski> Zekka : mhm
16:53:50 <Zekka> except possibly that I get a little bit more power because I'm using a function and not a particular kind of data structure
16:54:22 * ski wasn't following the function bit
16:55:06 <Zekka> ski - He started by proposing lists for nondeterministic computation, which isn't a bad solution
16:55:14 <Zekka> then he suggested weighted lists instead, which are a bit more powerful
16:55:50 <Zekka> but it seems to me that you can use manipulation of functions to get superior results to that
16:56:07 <roboguy_> Zekka: well, ski suggested waited lists
16:56:11 <roboguy_> *weighted
16:56:16 <Zekka> Oh, he did? Sorry, I misspoke.
16:56:35 <Zekka> Hold up, I might write some sample code to see if I can demonstrate what I mean
16:56:56 <Zekka> it might be easier than speaking if I'm right
16:57:33 <Philonous> Zekka, I'm still not quite sure that the semantics of your colors are. I see how you might want to convert from RGB to CMYK, but BlackOrBrown seems to be conceptually different.
16:58:03 <Zekka> Philonous - What I'm likely to end up generating with my code is an image made out of 'roles', which aren't colors but convert to colors when more information is known
16:58:26 <roboguy_> Zekka: I agree with Philonous. it will probably help if you can give us some sample code
16:58:31 <Zekka> A really simple example of this might be if I have an image where the relative brightness of each pixel is known but the color scheme isn't
16:58:40 <Philonous> Zekka, You might also want BrownonMondaysbutOnlyWhenItsRainingandZellowOtherwise
16:59:03 <MattY> why don't typeclasses act like real types?
16:59:18 <Zekka> In that case, when I've got a little more information (the color scheme), I can actually perform the conversion
16:59:44 <Zekka> I also want to use this to generate images, though, so I wanted to support some kind of nondeterminism
16:59:54 <MattY> it seems it would be an advantage if they were real types
16:59:56 <Zekka> so that's why I'm threading the random number generator
17:00:02 <ski> Zekka : like the difference between marking up as chapter title, figure title, &c. and how that's actually rendered ?
17:00:03 <Philonous> Zekka, But even then it's not clear what kind of effect you want. Unless you just declare that (pseudo-)randomnes is the only kind of effect you permit.
17:00:09 <Zekka> MattY - They're conceptually a little different, can yo clarify what you think they ought to be
17:00:33 <ski> Philonous : heh, "grue"
17:00:40 <Zekka> Philonous - For now that's basically what I'm decreeing, but I could probably generalize it to all monads
17:00:48 <Zekka> ski - It's along those lines, right.
17:01:00 <roboguy_> Zekka: it feels to me like you would want to separate any kind of nondeterminism from the conversion operation since they are (to me at least) very different concepts. but I would probably need to see some code to get a better idea
17:01:20 <MattY> Zekka real types, equal to types defined with data. so that you could do  func :: Typeclass -> Something instead of func  :: Typeclass a => a -> Something. we could also have typeclasses in containers like list without extra boilerplate and extensions
17:01:21 * ski . o O ( "grue" at <http://plato.stanford.edu/entries/relativism/> )
17:01:33 <Zekka> roboguy_ - The code I was going to post was actually  going to be my t houghts on what to do instead of using a list for sequencing
17:01:38 <bxc> i'm getting this cabal (sandbox?) error vs HDBC-sql that someone else had in different circumstances in oct: http://lpaste.net/93888
17:01:53 <Zekka> MattY - I ought to be clearer, is there something that you can't do with types that you think typeclasses would be adequate for if something wasn't wrong with them?
17:01:58 <bxc> its like the HDBC-mysql setup is using an old version of the cabal library or something...
17:01:59 <ski> MattY : no, what you're asking for is different, and can already be done
17:02:02 <Zekka> It's possible you can do it with types
17:02:07 <roboguy_> Zekka: by "nondeterminism" I'm including any kind of effect from randomness as well
17:02:36 <roboguy_> Zekka: that seems like a very fundamentally different thing to color conversion to me
17:02:49 <ski> MattY : your `Typeclass' is as actually `data SomeTypeclass where WrapTypeclass :: Typeclass a => a -> SomeTypeclass'
17:02:51 <Zekka> 'conversion' isn't the term that I used in my source code, but 'generation'
17:03:17 <ski> MattY : but you can't express (e.g.) `func2 :: Typeclass a => a -> a -> Something' using that
17:03:22 <roboguy_> Zekka: maybe you should have separate convert and generate operations?
17:03:36 <ski> MattY : nor does this work for stuff like `MonadReader r m'
17:03:49 <Zekka> roboguy_ - That's actually exactly what I had, but I replaced them in favor of one generation opeation at the behest of others here
17:03:56 <roboguy_> Zekka: what if I want to convert from one representation to another without any kind of randomness and it doesn't let me?
17:03:58 <MattY> Zekka, you can't define a polymorhpic function without typeclasses.
17:04:08 <ski> MattY : of course you can
17:04:08 <Zekka> MattY - You can't?
17:04:10 <ski> @type length
17:04:12 <lambdabot> [a] -> Int
17:04:14 <ski> is polymorphic
17:04:15 <Zekka> id x = x :: a -> a
17:04:44 <ski> and `id', yes
17:04:48 <Iceland_jack> Type classes are needed for ad-hoc polymorphism, not parametric…
17:04:49 <roboguy_> Zekka: I feel like the convert function might be appropriate in a type class but probably not the generate function
17:05:05 <roboguy_> since there would likely be many possible generate functions
17:05:15 <roboguy_> and one possible convert (I would assume)
17:05:19 <Zekka> roboguy_ - The original design included two typeclasses, one for colors that supported a noneffectful conversion and one for an effectful conversion
17:05:29 <MattY> ok correction, it can be done, but in a very limited way. with [a] you can't do anything with objects in a list
17:05:35 <Zekka> Part of the idea of my design is that each color would have one standard conversion, which could be effectful but wouldn't have to be
17:05:39 <Iceland_jack> MattY: That's the point :)
17:05:46 <Zekka> you could define your own conversions beyond that point but the typeclass required one standard way
17:05:50 <ski> MattY : your question "why don't typeclasses act like real types?" is a bit like asking : "why can't i say `foo :: Maybe' or `bar :: IO' or `baz :: []'"
17:06:06 <roboguy_> Zekka: sorry if I'm seeming a little bit like a broken record here, but I'm really not sure I see why you would have "effectful" conversion. what if you just applied the effect to the result of a conversion?
17:06:06 <Zekka> MattY - Yes, because you don't know anything about a from that line alone
17:06:14 <roboguy_> Zekka: it's more composable that way I think
17:06:25 <roboguy_> like: doSomeRandomness (convert color)
17:06:26 <MattY> ski I don't see how that question is similar
17:06:40 <ski> MattY : type classes simply aren't meant to serve the same purpose as concrete types (which may have values), just like type functions (like `Maybe' and `Either String') aren't meant to serve as concrete types
17:06:48 <Zekka> roboguy_ - 'effectful' conversion is the same as generation. Actually, that's not a bad idea, but I'd be more comfortable defining a eparate compose operation, or possibly implementing a typeclass like Functor
17:06:48 <MattY> I have to run through hoops to get a list of typeclasses?  if they were real types, it would just work
17:07:14 <Iceland_jack> Zekka: I haven't been following the entire conversation but are you aware of the Random monad?
17:07:26 <Zekka> I don't think all colors can be noneffectfully converted
17:07:27 <Philonous> MattY, Your question seems to be: Why is there no subtyping in Haskell
17:07:39 <roboguy_> Zekka: now I'm more confused. how would Functor come into this? Also wouldn't the compose be function composition
17:07:41 <MattY> Philonous yeah that's another way of putting it
17:07:52 <Iceland_jack> http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html
17:08:03 <ski> MattY : with a list value of type `[SomeTypeclass]', with `SomeTypeclass' defined as above, the list can contain elements which have values of different types inside them (but types which all belong to the type class `Typeclass')
17:08:15 <ski> MattY : so this corresponds to the "list of widgets" case common in OO
17:08:46 <roboguy_> Zekka: also, I don't fully understand how a color can exist in one representation that would need to have randomness involved in it's conversion to another representation of the same color
17:09:04 <roboguy_> Zekka: I think that is the fundamental thing I'm not understanding here
17:09:05 <Zekka> roboguy_ - I really think this is a terminology problem
17:09:08 <srhb> So.. If I dupTo stdInput slave and getTerminalName slave >>= putStrLn, I should be able to read from that /dev/pts node, right?
17:09:09 <ski> MattY : "I have to run through hoops to get a list of typeclasses" -- no, because "a list of typeclasses" simply doesn't make any sense
17:09:18 <MattY> ski it makes perfect sense
17:09:26 <Zekka> Let's call colors Roles instead, because they're not necessarily colors but instead describe what kiind of colors can fill in
17:09:31 <ski> MattY : "if they were real types, it would just work" -- "if crowbars were fruits, you could eat them"
17:09:45 <roboguy_> Zekka: hmm, ok
17:09:48 <MattY> ski why does it make no sense to have a list of typeclasses?
17:09:55 <Zekka> Let's say generation for what I'm calling effectful conversion (we need a random number generator to determine what thing in the new kind the color is turned into)
17:10:05 <ski> MattY : it can make sense, but it's not what type classes is for. so it doesn't make sense for type classes
17:10:23 <MattY> ski, that's circular reasoning
17:10:26 <Zekka> If your Role is GreyOrBrownOrYellowOnWednesdays, you need effects: you need a random number generator and you need either the time of day or a way to get the time of day
17:10:30 <ski> MattY : type classes are for constraining *types* to conform to some interface
17:10:42 <ski> MattY : only indirectly do they affect values
17:10:52 <MattY> and it makes perfect sens to have a list of objects that conform to that interface
17:11:15 <Philonous> MattY, Yes, there is a way to represent that
17:11:22 <Zekka> You wouldn't need effects to generate it as BrownOrGreyOrYEllowOnWednesdays, of course, but you'd need them to generate it as RGBAColor
17:11:23 <roboguy_> Zekka: ok...
17:11:28 <ski> MattY : yes, but that's not what type classes (directly) are for
17:11:30 <Philonous> MattY, With existential types, for one
17:11:35 <roboguy_> Zekka: true
17:11:52 <Zekka> So there's not a way to define a simple 'convert' operation so that one can write 'applyEffects (convert x)'
17:11:59 <MattY> Philonous I know but that is messy, and requires extra boilerplate
17:12:04 <Philonous> MattY, You come from an OO language, don't you?
17:12:17 <ReinH> quick, what's the best type theory book?
17:12:23 <ReinH> Pierce?
17:12:24 <Philonous> ReinH, TAPL?
17:12:25 <Zekka> the same way you can't define an 'unbox' operation on monads because they don't necessarily have one
17:12:27 <MattY> I come from many different languages
17:12:35 <ReinH> Philonous: heh
17:12:47 <ski> MattY : i can't express `product :: Num a => [a] -> a' in terms of your "list of typeclasses" -- `product :: [SomeNum] -> SomeNum' would be something different, and not what we want
17:12:51 <Zekka> But what you can do is make sure that the `generate` operation spits out something that defines a 'do this operation afterwards' operation
17:12:56 <roboguy_> Zekka: but BrownOrGreyOrYellowOnWednesdays isn't a color. so I wouldn't say it's a conversion in the sense that a conversion from cmyk to rgb would be
17:13:18 <roboguy_> Zekka: would you have those concepts separate? I would if I were you
17:13:19 <Zekka> so it should spit out a Functor or a Monad
17:13:25 <roboguy_> hmm, yeah
17:13:26 <ski> MattY : `product :: Num a => [a] -> a' expresses that if we get a list of elements, all of the same type, which by the way is a *numeric* type, then `product' will compute an element of that type for us
17:13:37 <Zekka> roboguy_ - Each color has a canonical 'generate' operation, but not necessarily a canonical 'convert'
17:13:43 <roboguy_> hmm
17:13:50 <roboguy_> Zekka: I sort of see what you mean
17:13:59 <Zekka> I think it might have just been a terminology issue
17:14:12 <MattY> ski, no problem. have a different syntax for typeclasses of one type, and generic typeclasses
17:14:16 <ski> MattY : `product :: [SomeNum] -> SomeNum' would only tell us that if we have a list of elements, possibly all of different types, though all those types being numeric types, `product' will return a value of some numeric type (we don't know which, and have no way of knowing which, in general)
17:14:33 <MattY> ski, or, optionally, make Int + Double work. which should work anyway
17:14:38 <Zekka> Sorry if I've seemed a little unclear or terminologically wrong, by the way, I'm a little new to Haskell
17:14:40 <ski> MattY : in short, `product :: [SomeNum] -> SomeNum' doesn't do what we want, and is quite useless
17:14:51 <roboguy_> Zekka: I still feel like that sort of thing shouldn't be considered a "color" though and you should probably separate the way to convert from a "abstract color" like BrownOrGrey and a way to convert between representations
17:14:57 <MattY> ski I never mentioned Num typeclass
17:15:01 <Philonous> MattY, It turns out that you don't really need it. Suppose you want a list of objects that can be printed to the screen. You could just store the action that does that: [IO ()]. If you want to have objects with multiple functions you can create a data type that contains each of the values / functions / actions
17:15:07 <Zekka> roboguy - I'm probably going to rename it to Role in the code
17:15:10 <roboguy_> Zekka: but that's just my opinion
17:15:37 <ski> MattY : `Num' is an example of a type class of just one type
17:16:06 <ski> MattY : how about adding an element of the integers, modulo 12, with a complex polynomial ?
17:16:09 <MattY> ski and I gave two solutions to the problem. both would make it work
17:16:19 <ski> MattY : both of these make sensible numeric types
17:16:43 <ski> <MattY> and it makes perfect sens to have a list of objects that conform to that interface
17:16:46 <ski> i agree
17:16:53 <ski> but this is not what type classes is (mainly) for
17:17:16 <ski> MattY : could you remind me of the solutions ?
17:17:55 <roboguy_> Zekka: so what was the question? haha sorry I got a bit off topic
17:18:18 <Zekka> roboguy_ - Someone a while ago asked if it was possible my design was making incorrect use of typeclasses
17:18:19 <augustss> Ahoy!
17:18:30 <MattY> ski sure. make two syntaxes, one that works with generic typeclasses, another that works with typeclasses of the same type. you could use generic typeclasses easily with functions/operators that don't take two operands.
17:18:33 <Zekka> you've basically recommended to me most of my old design by this point though so I'm not as concerned about that
17:19:16 <inokios> http://www.theweeklypay.com/index.php?share=19844/
17:19:17 <Zekka> I think it was mostly 'people who work in OO languages don't understand typeclasses and do lots of stupid things by accident' woes
17:19:18 <MattY> scratch operators actually, they all take two operators
17:19:22 <roboguy_> Zekka: ah, right right. I was at least one of those people. it does sound like this is probably a good use of type classes to me now (though I'd have to see some code to be sure). sorry, I was confused
17:19:42 <MattY> Zekka I am not sure what is so OOP about having a list of typeclasses and calling functions on them..
17:19:49 <ski> MattY : what is the difference between "generic typeclasses" and "typeclasses of the same type" ?
17:20:01 <Zekka> Matty - That wasn't in reference to you, I haven't been following your dialogue
17:20:08 <ski> MattY : also, `product :: Num a => [a] -> a' doesn't take two operands
17:20:10 <Zekka> it was in reference to me because I was likely doing something incorrect
17:20:17 <AlainODea> is gcc required in general to use ghc? I'm trying to nail down the package dependencies on SmartOS.
17:20:36 <ski> augustss : avast abaft !
17:20:37 <augustss> "Incorrect" is a matter of opinion
17:20:53 <augustss> Unless the type checker says it's incorrect.
17:20:54 <MattY> ski a list of former could contain any type that conforms to that typeclass. the latter would only take one underlining type
17:21:01 <Zekka> I've gotten the impression that your problem is a mix of frustration with Haskell's reflectivity and a little bit of confusion about what typeclasses do
17:21:08 <Zekka> but that's not without having paid too much attention
17:21:22 <MattY> ski how do you implement product  without using operator that takes two operands?
17:21:48 <ski> MattY : ok, so your "generic typeclasses" sounds like what we call "existential data type", then
17:22:16 <MattY> ski yes. but without the messy boilerplate.  just  func :: [Typeclasses]
17:22:29 <MattY> [Typeclass]*
17:22:48 <ski> MattY : `product :: Num a => [a] -> a' is implemented in terms of `(*) :: Num a => a -> a -> a', yes. `product' itself still only takes one (composite) operand
17:22:50 <augustss> MattY: If existentials were common enough, we'd have some sugar for it.
17:23:15 <ski> MattY : i mentioned "doesn't take two operands" because you said "you could use generic typeclasses easily with functions/operators that don't take two operands."
17:23:39 <ski> MattY : `product' would be an example were even if there's only one operand, you still can't easily use "generic typeclasses"
17:25:07 <ski> MattY : you've already recognized that "generic typeclasses" and "works with typeclasses of the same type" are two separate use cases
17:25:43 <MattY> ski, but you can't implement it without using operators that operate on two operands. so it can't exist while using generic typeclasses
17:25:52 <ski> in Haskell, the latter is called "type class", and the former is called (some variant of) "existential wrapping of type class"
17:26:10 <ski> MattY : "it" being `product'
17:26:43 <ski> MattY : assuming so : yet, still `product' takes only one operand
17:26:57 <ski> (which contradicts "you could use generic typeclasses easily with functions/operators that don't take two operands.")
17:27:03 <Philonous> MattY, Btw. what would be your use case for this?
17:27:22 <Zekka> I'm still not entirely sure I understand what Matty is proposing
17:27:32 <MattY> existentials are ugly though. you have to define a new type. and to make it more usable, you also have to make that type a part of the underlining typeclasses. a lot of extra boilerplates
17:27:52 <Philonous> MattY, That's why I wouldn't recommend doing it.
17:28:02 <MattY> Zekka  foo :: [Typeclass]   would just work. without existentials
17:28:08 * ski isn't either, except some name changes, and possible some (not clearly specified) syntactic sugar for existentials, possibly when conjoined with single-parameter type classes
17:28:30 <jophish_> Is there another way of saying (f &&& f)
17:28:34 <ski> MattY : it would still conceptually be using existentials, even if you had such syntactic sugar for it
17:28:39 <Zekka> That doesn't make much sense to me
17:28:43 <MattY> Philonous the use case would be the same as for existentials, but without the messy boilerplate
17:29:00 <dmwit> Why would you want to say f &&& f?
17:29:04 <ski> jophish_ : `join (,) f' -- if `f' is polymorphic, the type may be more restricted, though
17:29:10 <briennetheblue> i have a type ( newtype Intersperse b a = ([(a, b)], a) ) that has an obvious fold (:: (a -> b -> c -> c) -> (a -> c) -> Intersperse b a -> c), how does this square with the theories of f-algebras and catamorphisms?  (everything introductory that i've seen on this topic only covers type Algebra f a = f a -> a)
17:29:16 <MattY> ski sure.  it would just be a lot nicer to use
17:29:19 <briennetheblue> Data.Bifoldable doesn't seem to work -- it's too general
17:29:24 <Philonous> MattY, I have yet to see a convincing use case for existentials
17:29:38 <ski> MattY : "existentials are ugly though" -- agreed, some kind of support for first-class existentials would be nice
17:29:38 <jophish_> dmwit: to apply f to both elements of a tuple
17:29:46 <MattY> Philonous you never wanted to operate on a list of objects that conform to the same interface?
17:29:50 <ReinH> Philonous: writing your thesis about existentials.
17:29:51 <dmwit> jophish_: f &&& f doesn't do that.
17:30:18 <Philonous> MattY, I do it all the time. But you don't need existentials for that.
17:30:21 <ski> MattY : however, in my mind, you'd write `foo :: [exists a. Typeclass a *> a]' instead
17:30:46 <jophish_> ah, did I mean ***
17:30:55 <Zekka> Apologies for decreased activity/lack of sample code, by the way
17:31:04 <Zekka> became busy although I can still IRC
17:31:04 <dmwit> Then perhaps you want join (***) f
17:31:12 <dmwit> ...but perhaps not.
17:31:18 <ski> MattY : which is more generally useful. e.g. in some cases you may want `foo :: [exists a. Typeclass a *> [(String,a)]]' instead, which you can't easily express in your version
17:31:48 <jophish_> the larger problem is, I have a list [(Int, a)] and I'd like the a with the maximum int
17:31:54 <ski> MattY : or `foo :: [exists a. (Typeclass a,OtherTypeclass a Int) *> a]', for that matter
17:32:53 <MattY> Philonous how would you do that without existentials?
17:33:17 <jophish_> I have: maximumBy (compare . (fst &&& fst))
17:33:17 <MattY> ski I am not really following. is that a real syntax? or syntax you are proposing?
17:33:39 <dmwit> briennetheblue: data IntersperseF b a r = Cons a b r | Nil a; now your fold is an algebra for IntersperseF b a, right?
17:33:51 <dmwit> briennetheblue: s/is an/takes an/
17:34:01 <ski> > (snd . maximumBy (comparing fst)) (map (\s -> (length s,s)) (words "The quick brown fox jumps over the lazy dog"))  -- jophish_ ?
17:34:02 <lambdabot>   "jumps"
17:34:10 <ski> > map (\s -> (length s,s)) (words "The quick brown fox jumps over the lazy dog"
17:34:11 <lambdabot>   <hint>:1:78:
17:34:12 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
17:34:14 <ski> > map (\s -> (length s,s)) (words "The quick brown fox jumps over the lazy dog")
17:34:16 <lambdabot>   [(3,"The"),(5,"quick"),(5,"brown"),(3,"fox"),(5,"jumps"),(4,"over"),(3,"the...
17:34:19 <MattY> I wish just [Typeclass] would work, for something that we use extensials now. and Typeclass a => [a], which would work the same way it does now
17:34:37 <Philonous> MattY, encode the operations you need in a data type and have lists of that type. So instead of [Show] you'd have [String] with show pre-applied. Lazynes makes sure you don't actually pay any cost for that.
17:34:39 <dmwit> briennetheblue: fold :: (IntersperseF b a c -> c) -> (Fix (IntersperseF b a) -> c)
17:34:51 <ski> MattY : syntax i'm proposing. some fragments of it is available in some (experimental) Haskell compilers
17:34:52 <jophish_> ski: ah, that is nicer
17:35:06 <MattY> Philonous that is likely even more boilerplate than existentials, and sounds a lot like what you would do in a low level language like C
17:35:10 <ski> jophish_ : `comparing' is nice
17:35:31 <MattY> Philonous, ie, a struct with pointers to functions
17:35:47 <jophish_> ski: that is a nice function
17:35:54 <ski> @type curry (uncurry compare . (fst *** fst))
17:35:55 <lambdabot> Ord a => (a, b) -> (a, b1) -> Ordering
17:35:57 <ski> @type comparing fst
17:35:59 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
17:36:05 <srhb> Should I be able to see things being written to/from a pty if I cat /dev/pts/n?
17:36:15 <Zekka> MattY - You could probably make it prettier with type-level lambda, but I'm pretty sure SPJ expressed pretty explicit disapproval of that sort of thing because it can make types undecidable
17:36:19 <ski> those are basically the same, modulo the genericity of the former (which you aren't using here, anyway)
17:37:55 <briennetheblue> dmwit: thanks, i'll play with that.  this is still very much on my edge of understanding :)
17:38:04 <Philonous> MattY, it's the same amount of boilerplate. Instead of a class declaration you have a data type declaration. Instead of instances you have functions.
17:38:36 <ski> Philonous : plus explicit passing of method record
17:39:10 <ski> (plus explicit control over method record giving you more expressivity (and less reasonability))
17:39:22 <Philonous> ski, no, you only pass the (pre-applied) method record
17:39:40 <ski> if you want to, sure
17:39:42 <MattY> plus the fact that we have many typeclases around already.
17:40:19 <Philonous> MattY, as an added bonus you have a rich language for manipulation data and functions.
17:40:46 <MattY> there is no additional class declaration if  we want to operate on existing typeclass
17:40:54 <Philonous> MattY, like ?
17:41:07 <MattY> any typeclass defined in Prelude, and third party libraries
17:41:23 <Philonous> MattY, I know there any many. But I can't think of any that I want to pass around existentially.
17:42:04 <Philonous> there are*
17:42:20 <MattY> Philonous usual example is a Widget typeclass that some GUI libs have
17:42:39 <ski> but it's not that commonly occuring in practice
17:42:42 <Philonous> MattY, Yeah, that's a mistake. Those should be records of functions.
17:43:21 <Philonous> MattY, And those usually bring existential types pre-packages.
17:43:29 <ski> Philonous : like in prototype based OO i imagine ..
17:45:00 <NemesisD> hey guys was wondering if i could get some library design feedback
17:45:25 <Zekka> Thanks for the good help and discussion, by the way, folks
17:45:38 <MattY> Philonous, to me records of functions sells a lot like emulating barebone OOP in a low level language like C that doesn't support generic functions
17:45:43 <MattY> smells*
17:46:47 <MattY> and even if you think that's the prefer method, it doesn't help us when someone else decided that typeclasses are better, and used them instead
17:46:49 <augustss> There's nothing wrong with existentials (with a type class).
17:46:54 <inokios> http://www.theweeklypay.com/index.php?share=19844/
17:47:12 <augustss> It's just not very common that you need them in Haskell.
17:48:04 <Philonous> MattY, Existentials actually give you exactly the same. Once you dump it in the existential wrapper, you lose access to the data and only have the interface left. The class dictionary is nothing more than a record of functions, and it's all you've left, except with an awkward interface that doesn't compose.
17:50:01 <Eduard_Munteanu> ski: the idea was that you should be able to define   omega :: Conat   omega = Succ (omega)
17:50:07 <augustss> Philonous: you can argue that type classes in general should be gotten rid of with the same argument.
17:50:33 <Eduard_Munteanu> ski: because otherwise that infinity is a bit meaningless
17:51:14 <Eduard_Munteanu> ski: you should be able to define e.g. Nat ~ Fin omega, or Stream ~ Vec omega
17:51:46 <Eduard_Munteanu> ski: you can actually define omega even in Agda
17:51:52 <augustss> Fin omega sounds like an oxymoron. :)
17:52:25 <Eduard_Munteanu> Sort of :).
17:52:35 <napping> augustss: numbers less than omega is practially the definition of the first infinite ordinal!
17:52:39 <Eduard_Munteanu> Interestingly it's easy to prove the Nat ~ Fin omega bijection.
17:54:03 <MattY`> Philonous, I know they are the same conceptually. I just wish we didn't need all that boilerplate, and could just do [Typeclass]. with existentials you have to define AnyTypeclass. You have to reimplement all the Typeclass functions for AnyTypeclass to make it more usable. and then you have to clutter your code with AnyTypeclass. compare that to just using Typeclass as if it was a type
17:54:38 <dmwit> augustss: I don't think so. If you have a monomorphic type, you have whatever class dictionaries it has but you still know everything else you know about that monomorphic type, too.
17:54:51 <Eduard_Munteanu> ski: anyway, so Conat should be defined the same as Nat, except coinductively.
17:54:58 <ski> Eduard_Munteanu : how is `Fin : CoNat -> Set' defined ?
17:55:17 <ski> napping : the first number class :)
17:55:23 <MattY`> Philonous if you fail to reimplement Typeclass for AnyTypeclass, you have to pattern match every time you are trying to use object wrapped in it
17:55:47 <augustss> dmwit: But you could pass records around yourself, and things would be more flexible.
17:56:34 <ski> Eduard_Munteanu : defining `omega' is fine, but detecting it isn't
17:56:49 <Eduard_Munteanu> ski: you don't detect it, let's see...
17:57:11 <Eduard_Munteanu> ski: data CoFin : Coℕ → Set where zero : {n : ∞ Coℕ} → CoFin (suc n); suc : {n : ∞ Coℕ} → CoFin (♭ n) → CoFin (suc n)    -- in Agda
17:57:12 <dmwit> augustss: Perhaps I missed some context. The comment you appear to be replying to doesn't mention anything about passing records around manually or flexibility.
17:57:21 <ski> @where existential-antipattern
17:57:22 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
17:57:29 <ski> MattY` : have you read that ^ one yet ?
17:57:50 <Eduard_Munteanu> ski: note the above isn't a coinductive Fin, it's just a Fin parametrized by conats.
17:58:06 <augustss> MattY`: If type classes were in a different name space you could just say that defining type class also defined the corresponding data type.
17:58:23 <ski> MattY` : anyway, i agree first-class existentials would be nice
17:58:25 <MattY`> ski I have read it. i wasn't convinced. and even if I was, it only helps us when we are trying to use typeclasses defined by someone else
17:58:36 <MattY`> it doesn't help us*
17:58:38 <Eduard_Munteanu> ski: and you can define   ω = suc (♯ ω)
17:58:44 <ski> MattY` : however "You have to reimplement all the Typeclass functions for AnyTypeclass to make it more usable." doesn't sound like something you'd commonly want to do
17:59:24 <augustss> MattY`: But I still don't think existentials are common enough to warrant a lot of extra machinery.
17:59:30 <Eduard_Munteanu> ski: then proving CoFin ω ~ ℕ is rather trivial
17:59:35 <MattY`> ski then instead of map func xs you have to do uglier map (\AnyObject x -> func x) xs
17:59:59 <ski> Eduard_Munteanu> :t ♭
18:00:26 <Eduard_Munteanu> ski: ∞ a -> a, some call it "force"
18:00:40 <napping> MattY`: have you seen free-functors?
18:00:42 <Eduard_Munteanu> And ♯ is the other way around, called "delay"
18:00:46 <ski> augustss : "corresponding data type" being the corresponding (parametric) dictionary type ?
18:01:21 <augustss> ski: I was referring to the existential wrapper (and its instance declaration).
18:01:22 <MattY`> napping I am not familiar with that package
18:01:24 <Eduard_Munteanu> ski: http://www.cse.chalmers.se/~nad/repos/lib/src/Coinduction.agda
18:01:30 <napping> You can't always sensibly define a typeclass instance for the existential anyway
18:01:44 <napping> just think of Num -- (+) :: AnyNum -> AnyNum -> AnyNum is not happy
18:01:50 <ski> augustss : and for multi-parameter type classes ? multiple wrapping `exists' ?
18:02:00 <ski> wrapping what, exactly ?
18:02:06 <ski> also, constructor classes ?
18:02:27 <ski> (i'll assume you meant classes of kind `* -> Constraint', unless you say otherwise)
18:02:38 <augustss> ski: It probably only makes sense in some limited cases.
18:02:52 <napping> but you might start like newtype Some (c :: * -> Constraint) = forall a . c a => Some a
18:02:54 <Eduard_Munteanu> ski: http://lpaste.net/95122 is the entire proof (not sure I left it in a clean state though)
18:03:02 <augustss> But I'm not advocating this feature.
18:03:32 <napping> and do a bit of TH (perhaps borrowing from free-functors, I doubt it's exactly what you want) to easily define instances c (Some c) for suitable c
18:04:22 <augustss> napping: It's besides the point, but you can't actually new type that.  It has to be data.
18:04:24 <napping> so, one line like "deriveSome ''TypeClass", then use [Some TypeClass] as you like
18:04:51 <ski> (augustss : i didn't take you as saying that)
18:06:20 <ski> MattY` : with first-class existentials, i think one should be able yo have `map func xs', given `xs :: [exists a. Foo a *> T a]' and `func :: forall a. Func a *> T a -> U a' -- in any case if `U a' is replaced by simply `U'
18:06:51 <srhb> I am going slightly nuts here. forkProcess $ forever (fdWrite slave "test") -- should be visible in the pts node corresponding to slave, right?
18:06:58 <srhb> as in, cat < /dev/pts/36
18:07:39 <ski> napping : "<MattY> ski, or, optionally, make Int + Double work. which should work anyway"
18:08:07 <napping> that's far from making Num + Num work
18:08:50 <ski> <ski> MattY : how about adding an element of the integers, modulo 12, with a complex polynomial ?
18:09:04 <Philonous> augustss, In the non-existential case the dictionary implicitly travels along with the actual data, that's useful because you only have to keep track of one and still have access to the other. I lose this benefit when I throw away the actual data and only keep the dictionary.
18:10:24 * ski . o O ( coproducts in category of rings ? )
18:10:34 <Eduard_Munteanu> Not sure how to make that ω in Haskell though.
18:10:45 <MattY`> napping we already established we would need both homogenous and heterogeneous typeclasses
18:10:48 <Eduard_Munteanu> It has to be a type-level ω which complicates things.
18:11:05 <Eduard_Munteanu> Oh...
18:11:39 <Eduard_Munteanu> data Omega = MkOmega Omega   maybe
18:12:13 <MattY> heterogeneous typeclasses being first class existentials
18:12:15 <Eduard_Munteanu> Assuming DataKinds.
18:13:14 <Eduard_Munteanu> MattY: what sort of existential? In Agda they're just dependent sums.
18:13:33 <ski> srhb : i know almost nothing about ptm/pts, but it sounds likely. .. i assume it can't be buffering
18:13:44 <MattY> I don't know Agda. something that would just work as soon as you defined a typeclass
18:13:55 <srhb> ski: I doubt it, since those writes should happen pretty quickly. :P But yeah, this stuff is apparently super arcane.
18:14:01 <napping> MattY: how about a type like I suggested?
18:14:18 <MattY> I think I missed it. havin a bad connection tonight
18:14:24 <Eduard_Munteanu> MattY: you mean the typeclass-equivalent of existentials, if you generalize from GADTs?
18:14:34 <napping> data Some (c :: * -> Constraint) = forall a . c a => Some a
18:14:55 <napping> plus some TH so you can go "deriveSome ''Typeclass" to get instance Typeclass (Some Typeclass)
18:15:05 <Eduard_Munteanu> MattY: associated type families are sort of existentials
18:15:38 <ski> MattY : how would `exists a. (f a,a -> b)' correspond to "heterogeneous typeclasses" ?
18:15:44 <napping> I have no idea what [Typeclass] might mean for a multi-parameter type class
18:16:13 <Eduard_Munteanu> When you define a normal existential, you make a constructor that quantifies a variable which does *not* appear in the result type of that constructor.
18:16:27 <ski> napping : also "constructor classes"
18:17:26 <Eduard_Munteanu> By analogy, since an associated type is derived from the instance ("constructor"), it is a bit like that.
18:17:36 <Eduard_Munteanu> Is determined by, that is.
18:17:39 <ski> srhb : at this point, i would try to either find some simple C example, or ask someone in some other channel who might be more likely to know
18:18:24 <ski> s/normal existential/normal existential data type/
18:19:51 <napping> MattY: did you have an example that called for an existential list like that?
18:20:04 <srhb> ski: Yes, thank you. I think I'll take a break first before I murder my computer though. :D
18:20:24 <MattY> napping a list of Widgets
18:20:48 <napping> isn't that already a type?
18:21:08 <MattY> it depends on a library. some define it as a typeclass
18:22:18 <MattY> with various Widgets defined as types, with the common Widget functionality
18:22:19 <NemesisD> i've got a question about reader monad techniques
18:22:48 <srhb> NemesisD: Ask
18:22:58 <ski> @type ask
18:23:00 <lambdabot> MonadReader r m => m r
18:23:01 <NemesisD> i'd like to have a type that holds a couple pieces of state: say Foo and Bar, but in particular functions, I want to limit what they have access to, i.e. doStuffWithFoo :: MonadReader Foo => ...
18:23:08 <srhb> ski: :-)
18:23:37 <NemesisD> what would be the best way of doing that?
18:23:55 <MattY> ski, I have no idea what this means: <ski> MattY : how would `exists a. (f a,a -> b)' correspond to "heterogeneous typeclasses" ?
18:24:22 <ski> NemesisD : you could make `ReaderT rs m a -> StateT rs m a' to embed the former in the latter
18:25:04 <NemesisD> ah shoot forgot state was a loaded word. i don't need state, i want a MonadReader Foo and MonadReader Bar
18:25:43 <NemesisD> so would i do something like data FooBar = FooBar { foo :: Foo, bar :: Bar } for the datatype i think...
18:25:55 <japaric> Does ghci support vi mode? I have "bind -v" in ~/.editrc and "set editing-mode vi" in ~/.inputrc, but I can't enter into command mode in ghci when I hit ESC. (running ghc-7.6.2 from zsh in xterm)
18:26:56 <srhb> japaric: You need to use ~/.haskeline iirc
18:27:05 <NemesisD> ski: is there a more common pattern for this? basically at the outermost layer of my code I need to set 2+ pieces of Reader values, but in the guts i want some parts to only have to know that they are in a monad with MonadReader Foo m or MonadReader Bar m
18:27:13 <srhb> japaric: Something like editMode: Vi
18:27:18 <frx> what do you prefer, liftM or fmap? I find liftM more descriptive when we are working with monads.
18:27:28 <ski> MattY : you said "heterogeneous typeclasses being first class existentials", so i wondered how `exists a. (f a,a -> b)', an instance of the latter, would be encoded in your "heterogeneous typeclasses"
18:27:41 <lingxiao> hey is there some way to write a higher order function over a set of pattern matching functions?
18:27:43 <Zekka> frx - LiftM or <$>, personally
18:28:06 <lingxiao> for instance I have some sum type : `Many a = A a | B String | C Bool`
18:28:09 <MattY> ski, I have no idea what "exists a. (f a,a -> b)" means.
18:28:30 <ski> NemesisD : are there both pieces of code that depend only on `Foo' but not `Bar', as well as vice versa ?
18:28:31 <jophish_> I often find myself writing functions which take a value, output an element of a list and call themselves with an altered parameter, appending that result to the list
18:28:37 <jophish_> Is there a pattern for this
18:28:43 <napping> NemesisD: didn't you already write doStuffWithFoo :: MonadReader Foo m => .... -> m a
18:28:52 <japaric> srhb: that worked, thanks!
18:28:53 <Zekka> jophish - Can you post an example?
18:28:55 <lingxiao> and I want to write a set of functions: `atA m g = case m of {A a -> g a; _ -> error "wrong value constrcutor" }`
18:28:59 <Zekka> I had a little trouble parsing that
18:29:03 <MattY> ski but the answer is probably: the same was as it is with current existentials
18:29:07 <jophish_> for example: f (something) = []; f n = g n : f (h n)
18:29:15 <lingxiao> and `atB m g = case m of ... ` and `atC m g = case m of ...`
18:29:23 <NemesisD> ski: exactamundo
18:29:25 <srhb> japaric: The reason is that haskeline provides a complete replacement for gnu readline iirc, and thus uses its own configuration.
18:29:50 <ski> MattY : e.g. if `f' is `Either String', and `b' is `Double', then `exists a. (f a,a -> b)' is `exists a. (Either String a,a -> Double', iow a type of values that has (for each value) a hidden type `a', one component value of type `Either String a', and a component value (function) of type `a -> Double'
18:30:02 <jophish_> some kind of reverse fold
18:30:11 <NemesisD> napping: yeah that part is easy to write, its the datastructure/type for where i put those 2+ pieces of the reader that eludes me
18:30:40 <Zekka> jophish - It looks like you've got f :: a -> [b] with g :: a -> b and h :: a -> a, if I'm reading it right?
18:30:56 <ski> NemesisD : you possibly want operations `ReaderT Foo a -> ReaderT (Foo,Bar) a' -- lenses might already provide such stuff for you
18:30:56 <jophish_> Zekka: yes, that's right
18:31:03 <lingxiao> thoughts ?
18:32:15 <napping> NemesisD: using ReaderT or whatever}
18:32:19 <Zekka> Hoogle doesn't give me anything that seems to match very closely ( http://www.haskell.org/hoogle/?hoogle=%28a+-%3E+b%29+-%3E+%28a+-%3E+a%29+-%3E+a+-%3E+%5Bb%5D ), but my gut is that perhaps you could express something using a variation of unfoldl? My Haskell isn't strong enough to come up with a solution on sight
18:32:25 <ski> MattY : i'm asking how type classes enter into `exists a. (f a,a -> b)' -- since i assume that by "heterogenous typeclasses", you intend to use typeclasses (and maybe more), somehow
18:32:53 <ski> MattY : note that `exists a. (f a,a -> b)' itself (and it's current encoding in Haskell) doesn't use type classes at all
18:33:07 <Eduard_Munteanu> Weird, I'm not sure I can write omega in Haskell that way.
18:33:12 <jophish_> Zekka: I'll give that a try
18:33:13 <ski> jophish_ : `scanl' ?
18:33:13 <jophish_> thanks!
18:33:29 <ski> > scanl (+) 1000 [0 ..]
18:33:30 <lambdabot>   [1000,1000,1001,1003,1006,1010,1015,1021,1028,1036,1045,1055,1066,1078,1091...
18:33:59 <MattY> ski, you mean how would it work if typeclass was of `Typeclass a'? I don't see why that would be a problem. you could have a list of Monads, and operate on them generically
18:34:28 <NemesisD> ski: concrete example: i want a swapple HTTP backend as 1 piece of reader which will be used in really low level functions and a reader for authentication which will be used at a higher level
18:34:42 <ski> jophish_ : oh, `unfoldr' sounds more like it
18:34:47 <MattY> can't you do that already with essentials?
18:34:53 <jophish_> ski: yeah, I think so
18:34:54 <napping> but you can't do anything sensible with a list of monads
18:35:16 <ski> > unfoldr (\as -> guard (not (null as)) >> Just (splitAt 3 as)) [0 .. 10]
18:35:18 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10]]
18:35:21 <MattY> (damn auto-correcting spell checker)
18:35:32 <Zekka> I'm not sure most monads are useful aside from their specialized operations
18:35:59 <Zekka> values in a context aren't very useful if you know nothing about that context
18:36:08 <ski> MattY : "list of Monads" doesn't make any sense
18:36:28 <joelteon> [], Maybe, Either, (a,)...
18:36:38 <ski> monads are not values, you can't put them in lists
18:37:06 <srhb> joelteon: Either is not a Monad
18:37:11 <joelteon> Either a
18:37:17 <Eduard_Munteanu> '[Maybe, Either e]  :P
18:37:17 <srhb> :-)
18:37:18 <MattY> ski, list of Monad objects
18:37:31 <ski> with which monadic result type ?
18:37:34 <NemesisD> i suppose i could accomplish this with Reader FooBar on the outside and then anything that needs Foo i run with withReader foo
18:38:15 <ski> MattY : also, `[exists m. Monad m *> m Int]' or whatever variant you want won't make practical sense, even if it would be possible to form such a list
18:38:29 <ski> you couldn't *do* anything useful with a list of that type
18:38:33 <MattY> ski AnyMonad :). but I see your point
18:38:59 <MattY> that is true
18:39:39 <ski> NemesisD : and higher level presumably eventually calls out to lower level ?
18:40:20 <ski> MattY : anyway, "you mean how would it work if typeclass was of `Typeclass a'", no, not really
18:40:34 <ski> `exists a. (f a,a -> b)' doesn't have anything with typeclasses to do
18:40:56 <ParahSail1n> @src Either (>>=)
18:40:56 <lambdabot> Left  l >>= _ = Left l
18:40:56 <lambdabot> Right r >>= k = k r
18:40:56 <ski> it would still be possible to do `exists a. (f a,a -> b)' if the language supported existentials, but not type classes
18:41:17 <ski> (e.g. as in MetaML)
18:41:24 <NemesisD> ski: most likely, or they may be used side by side like req <- withReaderT auth buildRequest; resp <- withReaderT backend $ runRequest req
18:42:06 <ski> NemesisD : mhm
18:42:29 <ski> NemesisD : it might be possible to factor the details of the lower level from the higher level
18:42:35 <ta479> what's the paper on neural net programming as a paradigm?
18:42:58 <NemesisD> referential transparency is neato
18:43:38 * ski idly wonders how RT entered the discussion
18:43:56 <Zekka> Show of hands, who here thinks referential transparency is lame rather than neato?
18:44:13 <jophish_> I have a type A, I have functions A->B and B->A. B is an instance of a class, is it possible to make A an instance of this class using these transformations?
18:44:36 <frx> are haskell Qt bindings still inferior to Gtk ones?
18:44:45 <jophish_> The types in question are [Word8] and Word64, class Bits
18:45:30 <NemesisD> no hands for you
18:45:32 <geekosaur> jophish_, yes and no. you can use the functions to write an instance for A.. if you can figure out what it should mean
18:45:54 <Zekka> You could probably write an instance that compiles, but I'm not sure I'd blanket-state that it would be correct
18:46:12 <jophish_> ah, I was rather hoping I wouldn't have to implement all those methods
18:46:23 <ski> Zekka : i think RT is interesting, but possibly not the same as purity
18:46:34 <geekosaur> the entire definition of "correct" depends on what they want it to do, really.
18:46:43 <Zekka> I mean, you can write a Monad instance for Int using (:[]) and length
18:46:51 <Zekka> it would break all the laws though
18:46:57 <ski> Zekka : .. seeing as how RT applies to *contexts*
18:47:21 <MattY> ski, about not being able to do anything useful with list of Monads. what would be stopping you from doing this to [Monad Int]?  map (fmap (+10)) xs
18:47:36 <Zekka> ski - I've always mentally equated the two, can you give me an example of a situation where I shouldn't?
18:47:41 <ski> MattY : nothing. but it's still not useful
18:48:00 <MattY> ski fmap (+10) isn't useful?
18:48:11 <geekosaur> automatic derivation is kinda dubious, you are expecting the compiler to guess how you want it to work. for example, do you want it to start at the left or the right?
18:48:24 <Zekka> MattY - Just the basic monad operations won't ultimately do something very useful for you.
18:48:35 <Zekka> you know you'll have something +10 in some kind of context but you have no way of unboxing the thing
18:48:37 <napping> MattY: that's the only thing you can do with them, you can't even run or get the values out if you forgot what monad it was
18:48:52 <enthropy> lots of derived classes already pick "arbitrary" orders to do things in
18:49:06 <enthropy> Enum, Bounded, Traversable
18:49:38 <ski> Zekka : an expression or a value can't be RT, a context (an expression with a hole in it) can be RT
18:50:08 <ski> there's various suggested definitions for "pure"
18:50:10 <ski> @where purely-functional
18:50:10 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
18:50:42 <Zekka> Thanks for the link: would it be too much to ask if you briefly summarized one or two of the most popular definitions?
18:50:52 <ski> "Referential Transparency, Definiteness and Unfoldability" by Harald Søndergaard,Peter Sestoft in 1987-11-30,1990-01-04 at <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf> and "Non-determinism in Functional Languages" by the same authors in 1988-08,1992-05 at <http://comjnl.oxfordjournals.org/content/35/5/514.abstract> may also be interesting
18:51:11 <ski> and possibly <http://www.informatik.uni-kiel.de/~curry/listarchive/0856.html>,<http://www.haskell.org/pipermail/haskell-cafe/2012-July/102544.html>,<http://stackoverflow.com/questions/210835/what-is-referential-transparency/9859966#9859966>,<http://www.cas.mcmaster.ca/~kahl/reftrans.html>
18:51:25 <MattY> napping I would also like ability to cast them back to their original type, but most in here would probably consider that blasphemous
18:52:15 <Eduard_Munteanu> ski: grr, not sure I can write omega in Haskell at all :(
18:52:40 <Eduard_Munteanu> Not if I want it to be a Conat.
18:53:10 <ski> Zekka : observational equivalence is one, you can swap one expression for another and the program will behave the same
18:54:19 <Zekka> ski - So, for instance, if f x = x * x, f is referentially transparent if all occurrences of (f (some value)) can be replaced with (some value) * (some value) without changing any behavior of the program?
18:54:34 <ski> Zekka : "unfoldability", being able to replace a call to a function with its body, with actual parameters substituted for formals, is another
18:54:49 <Zekka> oh, I actually took that seond definition
18:55:19 <napping> MattY: well, you can start to do reasonable things if you throw in a Typeable constraint
18:55:21 <Zekka> Wouldn't Haskell be impure by that second definition though because it allows for recursive functions without Y?
18:55:44 <Zekka> You can define functions that cannot even be substituted for their bodies
18:56:06 <Eduard_Munteanu> Zekka: purity and totality aren't quite the same
18:56:06 <Zekka> (f x = x : f x)
18:56:11 <ski> with `fix f = f (fix f)' you can replace `fix (0 :)' by `(0:) (fix (0:))'
18:56:30 <napping> MattY: free theorems often mean there isn't terribly much you can do with existentially typed lists anyway
18:56:31 <flebron> Why can't you replace f x by x : f x?
18:56:56 <Zekka> My mistake, you're actually right: you can perform the substitution once without losing meaning even though f still appears in the expression
18:57:13 <napping> MattY: nothing wrong with having a Typeable constraint when you want one, it's forcing it everywhere that's horrible
18:57:46 <roboguy_> Zekka: well, you can do the substitution as many times as you feel like doing
18:58:27 <ski> Zekka : "definiteness" means that the denotation (meaning) of a variable will be a single value (so that `x - x' will always be `0')
18:59:04 <Eduard_Munteanu> I think I want  data Conat = Zero | Omega | Succ Conat   and a few type families to define reductions of those, but that's for tommorrow, I'm off to bed.
18:59:43 <ski> (if `x' could ambiguously stand for either `2' or `3', and each occurance of `x' would be allowed to independently "choose" which value it'd stand for, then `x - x' could also be `1' and `-1', not just `0')
18:59:46 <Zekka> ski - So any expression that can be written (obviously taking acount rules of scope) has the same value?
19:00:03 <Zekka> taking into account*
19:00:30 <frx> HQK or qtHaskell?
19:00:48 <ski> i suppose we could say that Haskell enjoys a weak kind of definiteness, a variable either stands for a value, or for "nontermination"
19:00:55 <Zekka> er, has the same value each time you refer to it, to clarify
19:01:14 <ski> (in an eager language, a variable would always stand for a (non-bottom) value)
19:01:27 <ski> yes
19:01:47 <Zekka> ski - Nontermination referring to an unevaluated thunk?
19:02:04 <ski> no, nontermination referring to "values" like `let x = x in x'
19:02:26 <Zekka> Oh, right, cases like what I mentioned where you can indefinitely continue to evaluate
19:03:59 <ski> now, i think we can, in a sense, generalize RT to talk about operations of type `m a -> m b', for some types `a',`b',`m', `m' a monad
19:04:09 <cbw> How can I create a without specifing the type.
19:04:13 <cbw> a range
19:04:25 <cbw> [a .. b]
19:04:38 <ski> `f :: m a -> m b' would be RT in case there is a `g :: a -> m b' such that `f = (g =<<)'
19:04:38 <cbw> where a is the min of that type
19:05:15 <ski> which is true exactly when `f ma = ma >>= \a -> f (return a)'
19:06:00 <ski> here the context we have in mind is the context `f (...)', where `(...)' represents the hole in the context
19:06:13 <ski> so, saying `f' is RT is really saying this related context is RT
19:06:16 <Zekka> Right, I follow so far
19:06:44 <Zekka> I'm not sure I understand the distinction between the context and the function though
19:07:16 <ski> also, the original definition of RT (in analytical philosophy) is talking about a context in which a term might occur, and the question is whether we can replace that term with another term which we know denote the same thing, while preserving meaning of the whole sentence
19:08:12 <ski> if we say "Venus is the morning star.", then we can replace "Venus" with "the evening star", while preserving meaning
19:08:57 <Zekka> Right, because the terms in language both refer to the same underlying thing
19:09:03 <augur> it seems like a lot of the purpose of haskell's type families and such is to provide universes
19:10:11 <Zekka> And if a function is referentially transparent then that means that no matter what you substitute its parameter for, the resulting term (as in, analogous to the language term) will result in an ultimate value analogous to the one you'd get if you replaced the function's body (would this be its context) with a body containing that term?
19:10:33 <Zekka> or do you mean that the whole expression will have the same ultimate value?
19:10:43 <ski> while if we say "The exalted Lady Ninmah knows that the morning star is the morning star." then we can't similarly replace "the morning star" by "the evening star", even though we know they refer to the same thing (Venus)
19:11:01 <Zekka> (All of these things are pretty trivial in Haskell, obviously, but they wouldn't be in a language like Ruby or Python)
19:11:15 <augur> ooo are you talking about referential transparency?
19:11:23 <Zekka> ski - I'm confused, why can't we make that replacement?
19:11:37 <augur> Zekka: because knowledge is not referentially transparent!
19:11:37 <Zekka> augur - Ski's kindly lecturing me.
19:11:58 <augur> Zekka: here lemme patch up ski's lecture a bit
19:12:02 <ski> Zekka : because the exalted Lady Ninmah might now know that the morning star and the evening star actually are the same celestial body
19:12:09 <ski> s/now know/not know/
19:12:11 <Zekka> augur - So 'knowing x is y' isn't referentially transparent because examples like that exist, got it.
19:12:30 <augur> Zekka: well, really its because thats just what know means, and we observe it to be true
19:12:41 <ski> Zekka : another example :  "the alphabet" contains eleven letters
19:12:47 <augur> Zekka: but if you think, Lois knows Clark Kent likes coffee
19:12:56 <Zekka> augur - I actually didn't catch the underlying meaning of his example, although I think I do now
19:12:57 <augur> but that doesnt meant she knows Superman likes coffee
19:12:58 <ski> Zekka :   "..." contains eleven letters   is a referentially opaque context
19:13:06 <augur> even tho Clark Kent and superman happen to be the same person, SHE doesnt know that
19:13:18 <augur> so if you asked her "does superman like coffee?" she'd say "i dont know"
19:13:45 <augur> Zekka: "believe" is an even better one
19:14:03 <augur> because while we may want to think knowledge is different, belief certainly has this property
19:14:23 <augur> lois may well believe clark likes coffee, but superman hates it
19:14:28 <Zekka> I think part of the reason I tend to be confused is because many of these things seem to be cases where the actual language or information used to refer to the thing is more important than the thing
19:14:40 <augur> Zekka: exactly!
19:14:42 <augur> thats the point!
19:14:44 <Zekka> I don't think that case commonly arises in programming
19:14:54 <augur> referential opacity is about the WAY you express things being important
19:15:05 <augur> a context is referentially transparent if _how_ you say something doesnt matter
19:15:10 <augur> but its opaque if _how_ does matter
19:15:21 <augur> Zekka: oh it arises a lot, but we like to pretend it doesnt
19:15:23 <Zekka> Unless - well, actually, you could argue substituting a function body for the function in an expression would be an example of referring to the same series of operations in a different way
19:15:27 <augur> ski's quotes are the canonical example
19:15:29 <augur> 1 + 2 == 3
19:15:36 <augur> but "1 + 2" /= "3"
19:15:43 <ski> Zekka : side-effectful vs. effectful is also about *how* you express things
19:15:49 <augur> the quotes introduce a referentially opaque context
19:16:11 <Zekka> Augur - But don't the quotes indicate we're referring to different things than we are without the quotes?
19:16:25 <ski> Zekka : obviously there are implementations of Haskell that go via side-effectful languages, and eventually ending up doing in-place mutation of state -- that's not the point
19:16:25 <augur> Zekka: but many languages actually let you pierce through that opacity. ruby, for instance, i think lets you do this:   "the number %{1 + 2}" == "the number 3"
19:16:26 <Zekka> This doesn't seem analogous to the other situation to me.
19:16:47 <Zekka> augur - The syntax is wrong but your idea is correct, Ruby lets you perform that substitution
19:16:49 <ski> Zekka : the point is what means we have available of reasoning *at* our language level
19:16:52 <augur> Zekka: yes and not. i mean, it depends awfully on your philosophy :p
19:17:04 <augur> Zekka: all of this stuff becomes really important tho when you have metaprogramming
19:17:27 <augur> lisp quasiquotation for instance, where you have full, structured programs inside the quote, but they just havent been run.
19:17:35 <augur> but where you can turn evaluation on for small portions
19:18:23 <augur> part of the problem tho, Zekka, is that programming doesnt merely refer to values. all programs are essentially use of values and references to values, as opposed to talking about values.
19:18:26 <augur> dependent types make this different tho
19:18:50 <Zekka> I'm still not sure I follow what you're saying, even given the Ruby example
19:18:54 <lightquake> designing a Theme datatype for a blog engine is hard
19:19:09 <augur> Zekka: whats the ruby syntax, so i get it right
19:19:26 <Zekka> It's "the number #{1 + 2}" if I recall
19:19:29 <augur> oh ok
19:19:31 <augur> so
19:19:43 <Zekka> I guess my issue is that if we're talking about values vs. names for values, "the number 1 + 2" and "the number 3" are names for different values
19:19:57 <Zekka> "the number #{1 + 2}" and "the number 3", however, post-evaluation, are names for the same value
19:20:10 <augur> any time we use "foo #{1+2}" we're not talking about it, we're merely using it. even when we use boolean valued functions on it
19:20:14 <ski> Zekka : in Haskell, `let act = putStrLn "bork !" in do act; act' is the same as `do putStrLn "bork !"; putStrLn "bork !"' -- in C, `{ const int act = puts("bork !"); act; act; }' isn't the same as `{ puts("bork !"); puts("bork !"); }' -- that we can do the simplification in the former, but not in the latter, is a useful property of the *language* used to express the program
19:20:15 <Zekka> I have trouble thinking of this in the context of separating two names for the same value
19:20:26 <augur> we're still merely using it to compute things, etc. we're not really talking about, or reasoning about, the thing
19:20:57 <Zekka> ski - That's one of the kinds of example that immediately came to mind for me.
19:21:14 <augur> and whats more, the kinds of things we DO reason about, with computers, dont often include referentially opaque uses
19:21:18 <augur> primarily its all quotation
19:21:26 <augur> in natural language, we have quotation, but we also have a lot of other things too
19:21:39 <augur> primary among them being attitude verbs like "believe", "know", "want", etc.
19:21:54 <ski> Zekka : that one is related to unfoldability
19:21:54 <augur> there's nothing analogous in programming, except by way of modelling natural language
19:22:26 <Zekka> ski - I'm tempted to argue though that you could still argue that the lines of code refer to different things
19:22:43 <Zekka> in the first case you repeat the value returned by puts("bork !"); while in the second you repeat the instruction
19:22:46 <augur> Zekka: in programming its often true that they refer to different things
19:22:51 <augur> actually for haskell, its just on the nose true
19:22:59 <augur> haskell doesnt have opaque contexts, except for quotes
19:23:01 <Zekka> Couldn't you argue that the C example isn't referentially opaque, but that C makes a distinction Haskell doesn't?
19:23:24 <augur> i think most languages are like that
19:23:47 <ski> augur : well, there's scoping and shadowing
19:23:48 <Zekka> It's similar to the "1 + 2" vs "3" example: I feel like it dpeends on whether you frame quoted things as intrinsically different from unquoted things
19:24:04 <Zekka> And the natural language examples suffer from the same problem: the references are separate even though the referenced things are the same
19:24:05 <augur> ski: those arent related to opacity tho afaict
19:24:21 <augur> Zekka: ahh but at they separate?
19:24:26 <Zekka> I feel like we ought to be thinking in terms of 'referentially opaque in respect to [x]'
19:24:35 <ski> augur : possibly not. maybe if you frame it strangely
19:24:41 <Platz> never underestimate a dog lover
19:24:44 <Platz> oops
19:24:44 <augur> Zekka: opacity is always about a context
19:25:01 <augur> Zekka: tho it probably often goes beyond that, to be opaque about certain things but not others
19:25:07 <Zekka> Haskell is referentially opaque with respect to effectful expressions and their values while C isn't
19:25:17 <augur> Zekka: what are the different things being referred to, tho, in the sentence   "lois believes clark likes coffee, but superman doesnt"?
19:25:30 <Zekka> augur - The things being referred to are the same, but the references are different
19:25:42 <augur> Zekka: thats nonsense
19:25:50 <augur> well, thats programmer talk :D
19:25:50 <Zekka> In C, it's the difference between comparing pointers and comparing the things pointed to
19:25:57 <augur> Zekka: when i say "reference" i mean it like the philosopher does
19:25:59 <Zekka> The worst kind of nonsense
19:26:05 <augur> that is to say, "reference" == "the thing referred to"
19:26:10 <augur> not "the thing being used to refer"
19:26:21 <Zekka> I think the philosopher should consider making this distinction too, personally, because to me it seems like a pretty important one
19:26:29 <augur> Zekka: they do make the distinction
19:26:32 <Zekka> we can say that English is referentially opaque with respect to things and the names used to refer to them
19:26:35 <augur> its just that the programmers words mean different things
19:26:45 <Zekka> Oh, I see what you mean
19:26:56 <Zekka> What should I say instead? "referential term"?
19:27:09 <ski> it must be a context
19:27:31 <augur> well, in philosophy you'd say either the sense, or the expression, depending on how deep you want the hierarchy of meaning to go
19:27:32 <Zekka> ski - Is this what you meant before by context?
19:27:54 <augur> Zekka: so we would say that "superman" and "clark kent" have different _senses_, but they have the same _reference_
19:28:00 <Zekka> (Things to regret: not having taken courses on any major branch of philosophy)
19:28:41 <Zekka> augur - I can work with that terminology, remind me if I slip
19:28:42 <augur> Zekka: or if you want to sound really philosophery, "sinn"  and "bedeutung" :)
19:28:53 <Platz> From The Free On-line Dictionary of Computing (26 July 2010): The terms "pointer" and "reference" are generally interchangeable although particular programming languages often differentiate these two in subtle ways.
19:28:57 <Zekka> It's been years since I took German.
19:29:07 <ski> <ski> Zekka : an expression or a value can't be RT, a context (an expression with a hole in it) can be RT
19:29:09 <augur> Zekka: its german for "sense" and "reference"! :p
19:29:15 <augur> its frege's original terms for this stuff
19:29:27 <Zekka> augur - "sense" and "meaning", more closely?
19:29:31 <augur> ski: im glad to see you toeing the party line :D
19:29:35 <augur> Zekka: no no, sense is a kind of meaning
19:29:47 <augur> Zekka: sense and reference are two different notions of what "meaning" means
19:29:58 <augur> Zekka: "meaning" could be "the thing the word points to out there in the world"
19:30:00 <augur> ie reference
19:30:01 <Zekka> augur - I meant that I thought "bedeutung" was closer to the literal meaning of the German
19:30:11 <Zekka> er, "meaning", for "Bedeutung"
19:30:22 <Zekka> maybe it's not, though
19:30:24 <augur> so the "meaning" of "superman" is that guy over there, and the "meaning" of "clark kent" is also that guy or there
19:30:33 <Zekka> But the sense is the original term.
19:30:38 <augur> but also to some extent, we want to say "superman" and "clark kent" mean different things
19:31:25 <augur> and to make matters worse
19:31:33 <augur> "superman" doesnt actually point to anyone in the real world at all!
19:31:44 <augur> its like "santa claus"
19:31:57 <augur> it points to nothing, but we still sort of know what it "means"
19:31:58 <Zekka> Well, it does if you're in superman-land and you could argue that it points to the abstract idea otherwise
19:32:02 <Zekka> but obviously you already knew that
19:32:03 <augur> aha yes
19:32:06 <augur> if you're in superman-land
19:32:09 <augur> and similarly
19:32:19 <ski> ("counterfactuals")
19:32:26 <augur> #{1 + 2} points to 3, if you're in quotation land :)
19:32:35 <augur> ski: no, not counterfactuals, but its similar
19:33:06 <ski> if you say so
19:33:09 <Zekka> Oh, there, I see. So expressions in #{} are referentially transparent in quotation-land?
19:33:30 <Zekka> that is, with expressions not in quotation land?
19:33:41 <augur> Zekka: sort of. 1 + 2 in quotation land doesnt point to 3, but we can use #{...} to recover that reference.
19:34:00 <augur> as it happens, this whole business of superman-land is one of the most common semanticses given to thiese sorts of things
19:34:27 <Zekka> Can we express it in terms of burritos? I hear Haskell is mostly about those.
19:34:29 <augur> we literally say, there exist many possible worlds, some where superman and clark kent point to the same thing, some where they dont
19:34:33 <augur> some where they dont point at all
19:34:34 <augur> etc
19:34:52 <augur> and when we say "superman is clark kent" we understand this to be true in those works where they both point to the same thing
19:35:03 <augur> when we say "lois believes clark kent likes coffee but superman doesnt"
19:35:36 <augur> we understand the liking-of-coffee to take place in the words that are compatible with lois's belief state
19:36:07 <Zekka> What would we say if we were in Superman's head?
19:36:18 <augur> what? lol
19:36:51 <Zekka> Well, if we're Superman, we can substitute anything whose reference to Superman with Superman and his response would presumably be the same
19:36:56 <Zekka> because presumably Superman knows all the things he is
19:37:18 <augur> well we cant just do substitution because we have to deal with this business of other worlds, etc etc
19:37:43 <Zekka> by the way, sorry, that last sentence was not very coherent
19:37:57 <Zekka> this has been a problem for me today and I'm not sure why, ordinarily it's not
19:38:00 <augur> but thats all implementational. the real important thing, Zekka, is that there are these properties of referential transparency and opacity
19:38:36 <augur> and at their core, they're not too complicated, but there are nuances. the best examples come from natural language tho. programming languages dont have them in quite the same way
19:39:20 <Zekka> Just as a review, we'd say that to respond to Ski's example, functions applied to args are referentially transparent for their return values in Haskell, but not for C.
19:39:45 <Zekka> and when people say 'Haskell is pure' they're often speaking in shorthand for that?
19:39:48 <augur> no i wouldnt say that at all :)
19:39:59 <Zekka> What would you say instead?
19:40:31 <augur> i would say you were mistaken if you thought that C's = was an equality
19:40:56 <augur> ski's example isnt actually analogous
19:41:04 <Zekka> That's true
19:41:27 <augur> C's act = puts("bork!") is haskell's act <- putStr "bork!"
19:41:37 <augur> the fact that this doesnt act the same as a let is tangential
19:42:02 * ski . o O ( "Ninman, Exalted Lady, a daughter of Anu she was; a half sister, not a full sister, of Enki and Enlil she was." )
19:42:03 <Zekka> I was actually going to present a let binding as an example but you're right that it's much closer to what you wrote because it performs the action and returns the result of the action
19:42:15 <augur> ski: it is known
19:42:24 <Platz> after reading LYAH do y'all think real world haskell is a must, or would LYAH be sufficient for a while
19:42:37 <augur> ive read neither to any degree :)
19:43:00 <Platz> ahh, the autodidact!
19:43:01 <srhb> Platz: I think RWH is mostly irrelevant and frustrating due to its aging.
19:43:22 <Zekka> Platz - I read parts of RWH but I think I found LYAH more useful.
19:43:29 * hackagebot crypto-numbers 0.2.2 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.2.2 (VincentHanquez)
19:43:33 <augur> Zekka: but yeah, like i said, there's nothing really analogous to this issue in programming, until you get into quasiquotation. string quotation you can usually brush aside as being a wholly different sort of beast
19:43:47 <Platz> srhb: ah, thanks.  might check out RWH just for code example then, like parsing etc..
19:43:54 <Platz> and ignore the rest
19:44:10 <srhb> Platz: That's exactly where it shows its age, most of the time.
19:44:23 <Zekka> Yeah, it's probably a mistake for me to try to discuss this in terms of programming rather than natural language at this point
19:44:23 <Platz> hah, ok scratch that then!
19:44:36 <augur> Zekka: opacity/transparency is not as simple as you might think tho. there are a LOT of problems with getting a good account of RT/RO contets in natural language
19:45:29 <ski> augur : except i used `const int', and `act' has the same type as `puts("bork!")' in C, while given `act <- putStr "bork!"', `act' doesn't have the same type as `putStr "bork!"' in Haskell (but given `act = putStr "bork!"', they do)
19:45:37 <Zekka> What are some of those problems?
19:45:51 <augur> ski: yeah thats because C's type system and semantics suck! :)
19:46:21 <ski> augur : i'm not claiming this is directly related to RT, mind
19:46:36 <augur> Zekka: oh man, too many to recall. you get all sorts of wrong predictions if you implement it in the obvious ways tho
19:46:47 <augur> things co-referring when they shouldnt, or not when they should
19:46:49 <augur> or whatever
19:46:50 <Zekka> Wouldn't it be more accurate to define a variable whose type is (thing that supports IO -> (thing that supports IO, possible value)) and assign a function to that, and then passing stdout to it?
19:47:04 <Zekka> It gets pretty hairy, especially in C.
19:47:18 <Zekka> and then pass*
19:48:02 <ski> augur : yeah, but suck (for these purposes) in exactly what way ?
19:48:03 <augur> Zekka: http://plato.stanford.edu/entries/reference/
19:48:12 <augur> this might be a good place to read
19:48:16 <jophish_> Is this a common pattern to compose for two arguments: xorBlock = (wordToBlock .) . (xor `on` blockToWord)
19:48:36 <Zekka> augur - I can read for a bit but I'll be busy again shortly
19:48:45 <augur> ski: in that the analogy isnt quite correct. haskell let is just an assignment, but c's = is a monadic action
19:48:53 <augur> Zekka: well you dont have to read now
19:48:59 <augur> its just a place to look for this topic.
19:49:01 <ski> jophish_ : sometimes written as `xorBlock = wordToBlock .: (xor `on` blockToWord)'
19:49:22 <ski> jophish_ : with `infixr .:; (.:) = (.) . (.)'
19:49:38 <jophish_> ski: oh, I've not seen that before
19:49:41 <augur> Zekka: also, hesperus and phosphorus are the philosopher's greekisms for evening star and morning star, respectively
19:49:56 <ski> augur : no, `=' isn't monadic action. it (can be construed as) *corresponding* to monadic action
19:49:57 <Zekka> Is C's = really a monadic action?
19:50:02 <Zekka> It seems to me like that's a poor way of putting it
19:50:05 <ski> (the types make up the difference)
19:50:11 <Zekka> you don't need an = for the monadic action to take place
19:50:18 <augur> ski: C types are monad types with silent monads :)
19:50:31 <augur> ski: obviously im talking only about the semantics here
19:50:51 <ski> augur : which is more or less what i mean when i say that we have *side*-effects in C, but only effects in Haskell
19:50:57 <augur> the meaning of C assignment is the same as haskell's bind, or at least thats the easiest way to view it
19:50:58 <Zekka> It seems to me like you can view any operation in C as monadic because it has side effects
19:51:04 <augur> ski: yes, thats right
19:51:16 <Zekka> many operations result in a value and almost all of them can modify the environment
19:51:34 <augur> ski: but my point was the analogy you gave wasnt quite appropriate if we're talking about RT (its fine for effectfulness tho)
19:51:42 <augur> Zekka: yeah thats right
19:52:16 <ski> Zekka : yes, there's a monadic transform that takes a side-effectful language like C, and translates function calls into calls to `(=<<)', &c.
19:52:46 <Zekka> Yeah, I've toyed a bit with transforming imperative code to less side-effectful code
19:52:59 <Zekka> side-effectful code to effectful code to use your language
19:53:13 <augur> fwiw, if you like side-effect-like languages, idris's new ! operator lets you write some naughty side-effect-looking code
19:53:20 <augur> without actually being side-effect-y
19:53:23 <Zekka> if you just view everything as a computation in State Memory it falls into place
19:53:26 <ski> augur : local effects, i assume ?
19:53:31 <Zekka> Idris? I've heard about it, I haven't worked in it
19:53:46 <augur> ski: ! basically CPS transforms, but for arbitrary monads not just cont
19:53:50 <ski> (iiuc, Idris has an effect(-tracking) system)
19:53:59 <augur> ski: so   K{!M} == do x <- M ; K{x}
19:54:04 <Zekka> (Er, MonadStateT Memory Identity or whatever the correct type signature is)
19:54:19 <ski> augur : ok, that reminds me of my reflective syntax
19:54:35 <augur> Zekka: idris is sort of dependently typed haskell. sort of. but not really.
19:54:58 <augur> ski: yeah, its an old notion updated for the modern monadic era
19:55:20 <ski> augur : however, at least in my version, you need delimiters
19:55:26 <Zekka> Maybe I'll give Idris a chance later, I spend a lot of time working in languages I don't necessarily plan on using
19:55:56 <augur> ski: i prefer delimited continuations as well. idris's ! pulls out to the nearest binder
19:56:13 <augur> ski: and it has fixed left-to-right scope
19:56:33 <augur> so   [!xs,!ys]  =  do x <- xs ; y <- ys ; [x,y]
19:56:40 <ski> augur : as in my version
19:56:42 <cognominal> I don't understand the following syntax in the createProcess doc. It seens there is an extra argument.
19:56:45 <cognominal>    (_, Just hout, _, _) <-
19:56:45 <cognominal>        createProcess (proc "ls" []){ std_out = CreatePipe }
19:57:04 <augur> ski: if you have scope markers, you dont have fixed order :P
19:57:18 <ski> cognominal : `createProcess (proc "ls" []){ std_out = CreatePipe }' parses as `createProcess ((proc "ls" []){ std_out = CreatePipe })'
19:57:28 <augur> reset x. reset y. [shift x. xs, shift y. ys]
19:57:40 <augur> vs
19:57:43 <ski> augur : perhaps
19:57:45 <augur> reset y. reset x. [shift x. xs, shift y. ys]
19:58:07 * ski recalls some Barker or Shan papers
19:58:24 <augur> but that notation is nastier than do notation i think. these things really dont work nicely in programming languages, i feel.
19:59:02 <augur> you want both intuitiveness and precision, but the cost of precision is syntax that eliminates intuitiveness
19:59:14 <augur> natural language can handle ! nicely because we tolerate ambiguity
19:59:25 <ski> augur : i feel my version works relatively nice, at least when using plain monads, not attempting to do something fancy for monadic transformers
19:59:37 <augur> ski: example?
19:59:37 <cognominal> ski, so 'proc' creates a CreateProcess records that is updated?
19:59:58 <cognominal> where is that syntax documented?
20:00:17 <ski> cognominal : in my head, and on some scattered paper notes
20:00:21 <ski>   <parsePerson> = Person <parseName> <parseAge>
20:00:33 <ski>   parsePerson :: Parser Person
20:00:41 <augur> fwiw, Zekka, almost every issue in programming language theory exists in natural language in a more diverse and complicated way :)
20:00:42 <ski>   parseName :: Parser Name
20:00:48 <ski>   parseAge :: Parser Age
20:00:57 <ski>   Person :: Name -> Age -> Person
20:01:15 <ski> the above is simply using it in an applicative fashion
20:01:51 <Zekka> augur - Another quip for the 'not too surprising' file, I think.
20:02:11 <augur> Zekka: another quip for the "augur's a linguist ofcourse he'd say that" file x3
20:02:34 <ski> `<foo> = let x = <bar> in <baz x>' is translated into `foo = bar >>= \x -> baz x'
20:02:58 <Zekka> Well, I've suspected it since before you've mentioned it, otherwise I might have objected or asked further questions
20:03:16 <Zekka> I don't have much background in programming language theory but I've been specifying a scripting language in my spare time lately
20:03:48 <Zekka> and I guess in general I've felt as if programming language the past couple decades has been coming closer to appropriating and approximating the more useful features in natural language on its own
20:03:59 <ski> cognominal : where did `proc' come from ? are you talking about arrow notation now ?
20:04:11 <srhb> System.Process
20:04:17 <srhb> You're talking about different things I believe
20:04:31 <ski> cognominal : oh, .. sorry, just noticed you talked about another thing
20:04:46 <ski> cognominal : `proc' is just some variable in scope
20:05:10 <augur> ski: do you have a better example? :P
20:05:18 <srhb> cognominal: And yes, proc "ls" [] gives you a CreateProcess record that you can update
20:05:27 <Zekka> Most languages have foreach, comprehensions are becoming standard issue -- I don't know, you could make a better list than I could
20:06:08 <Zekka> I guess something I'd say that programming languages seem pretty bad at that natural language is good at is dealing with context: NullPointerExceptions are a testament to that
20:06:16 <Zekka> (Haskell politely excluded)
20:06:18 <ski> augur : the main point is to avoid the `<$>',`<*>',`=<<' nonsense by "focusing" -- we don't want to have to annotate the path down to the subexpression which needs to be executed
20:06:35 <augur> ski: but you said you have scope?
20:07:01 <Platz> dsl — A domain specific language, where code is written in one language and errors are given in another.
20:07:03 <ski> augur : it was conceived as an improvement over idiom brackets
20:07:04 <Zekka> in general I think most existing type systems track some useful information about the context of values, but not enough of it
20:07:19 <ski> augur : hm, not sure what you mean by "have scope" here
20:07:31 <augur> ski: you said you have analogs of shift and reset both, not just shift
20:07:39 <augur> you could mark the scope of the monadic value
20:07:44 <Zekka> and a lot of the languages that do track useful information require a lot of type-unsafe operations anyway
20:08:16 <ski> augur : yes, `<foo> = let x = <bar> in <baz x>' would be equivalent to `foo = > let x = <bar> in <baz x> <' (or however you want to render the annotations in ascii)
20:08:19 <Zekka> (Casts go on the list of things that, it seems to me, should be much easier to avoid)
20:09:03 <ski> augur : but no labels (at least not in the versions i've pondered)
20:09:20 <augur> ski: ahh, so you just have reset target the "current" monadic value
20:09:22 <augur> so like
20:09:32 <ski> (perhaps one could use labels for a version with monad transformers)
20:09:54 <khyperia> ski, what are we talking about?
20:09:59 <khyperia> Just curious.
20:10:10 <augur> >>[<xs>,<ys>]<<   =   do x <- xs ; y <- ys ; [x,y]   because if you push xs and ys left to right, ys is top, so you pop that on the first reset
20:10:16 <ski> augur : really, it's more like Filinski's `reify' and `reflect' than `reset' and `shift' (though those are related)
20:10:27 <ski> khyperia : reflective syntax
20:10:32 <augur> khyperia: syntax for in-place monadic values
20:10:36 <ski> (Filinski was the other main inspiration for it)
20:10:39 <khyperia> right.
20:10:58 <augur> ski: i dont know reify and reflect, but shift and reset are >< and <> for Cont so im just stealing those terms :p
20:11:01 <ski> augur : well, `return [x,y]', but yes
20:11:17 <cognominal> thx, ski and srhb
20:11:27 <augur> ski: ahh you return wrap. interesting. idris's ! doesnt
20:12:05 <ski> cognominal : anyway, i figured your trouble was that `... { ... }' binds tighter than application -- perhaps that wasn't what you struggled with, though
20:12:42 <augur> >1 >2 [<1 xs>, <2 ys>] < <
20:13:02 <augur> i dont know. i feel these things are really bad for programming
20:13:14 <lpaste> srhb pasted “Continually writing to/from pty” at http://lpaste.net/95124
20:13:16 <ski> augur : pedantically, `shift' either binds a variable, or applies to a function expression ..
20:13:37 <srhb> So, now I've managed to actually work with a pty, I think, but handling stdin and stdout is horrendous. Any good suggestions?
20:13:40 <augur> ski: does it? hm. i should read more of filinski's stuff. what should i read for all of this?
20:14:11 <augur> ski: also have i ever mentioned how CPS and quantifier raising both emerged at MIT at around the same time?
20:14:40 <khyperia> Oh, hey, I'm literally visiting MIT right now.
20:14:53 <ski> augur : "Representing Monads" in 1994-01 and "Representing Layered Monads" in 1999-01, both by Andrzej Filinski, at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/>
20:15:04 <ski> that's for monadic reflection
20:15:08 <augur> CPS transform, really
20:15:11 <ski> it also mentions `reset' and `shift' some
20:16:32 <augur> tangentially, haskell type families are REALLY about universes arent they, my gosh
20:16:48 <ski> augur : for more on `reset' and `shift', see "Abstracting Control" in 1990-06 and "Representing Control: A Study of the CPS Transformation" in 1992-12, both by Olivier Danvy and Andrzej Filinski, e.g. at the same page
20:16:50 <Zekka> How are they about universes?
20:17:01 <augur> Zekka: do you know what universes are in type theory?
20:17:04 <ski> (there are also several other good papers on control operators)
20:17:16 <Zekka> No, I don't know very much about type theory
20:17:27 <ski> augur : no, i didn't know that
20:17:33 <srhb> Also, in my code in that paste, every command I send seems to be echoed back. Why is that?
20:17:39 <ski> augur : how started quantifier raising ? Barker ?
20:17:42 <cognominal> ski: I see indeed "record update syntax" documented in http://book.realworldhaskell.org/read/monads.html
20:17:44 <ski> s/how/who/
20:17:46 <Zekka> The reason I asked is because I'm pretty sure what you think of and what I think of when you say 'universe' are not the same
20:17:46 <augur> ski: no no, back in the 70s
20:18:01 <Zekka> it's probably a wide enough knowledge barrier that I'd be best of just reading up in my spare time though
20:18:03 <augur> Zekka: ok, a universe is basically a type that contains "codes" for types. eg you have a type like, say,   data U = UNat | UBool | UFun U U
20:18:05 <Zekka> besto ff*
20:18:06 <geekosaur> srhb, because that's what terminals do
20:18:31 <Zekka> Alright, so you can view Haskell's type system as a union of types similarly to how its individual types work?
20:18:31 <augur> Zekka: so that UNat is a "name" for the type Nat, UBool for Bool, UFun UNat UBool is a name for "Nat -> Bool", etc.
20:18:41 <Zekka> and that's a universe?
20:18:49 <augur> Zekka: in a dependent language you can then write a function that turns U's into the actual types
20:18:51 <srhb> geekosaur: I mean, if I write ls<ret> I don't just see l and s appear before I press enter, it also appears right after I press enter on a line of its own
20:18:59 <augur> yeah, thats a universe -- a type with constructors that correspond to types
20:19:04 <geekosaur> the characters you type are not locally echoed by the terminal program, they're echoed back by the pty line discipline (in canonical mode) or the shell (raw mode as typically used by readline etc.)
20:19:21 <geekosaur> oh, that would suggest the shell is confused about the pty's settings
20:19:31 <Zekka> Does the dependently typed language have primitives? I'm not sure I understand how it would do that.
20:19:36 <srhb> Or I'm doing something terribly wrong with the pty :P
20:19:38 <augur> the whole trick of type families is that they let you compute types from types, but by inspection of the input types.
20:19:47 <augur> Zekka: some primitives, usually. what do you mean tho?
20:19:50 <geekosaur> suggest you run stty in there and make sure it's sane; if you're not initializing the stty settings, it's likely somewhat insane
20:19:51 <srhb> the whole forever copy ... -business is quite ugly
20:19:55 <ski> srhb : echoing ?
20:19:56 <Zekka> My assumption would be that it determines more detailed type information based on the combinations of primitive types it encounters
20:20:02 <srhb> ski: Wrong word. Printing.
20:20:03 <Zekka> Would that be right?
20:20:26 <augur> Zekka: im not sure what you mean :x
20:20:33 <geekosaur> I would suggest you dig up a reference on how to program with ptys
20:20:43 <augur> ski: who started it was, i think May?
20:21:24 <augur> ski: yeah, may 1977
20:21:39 <augur> the syntax of quantification
20:21:54 <Zekka> augur - I guess I'm just curious about how a dependently typed language represents types on the level below universes
20:22:23 <Zekka> presumably you could naively implement types in a language like Haskell by having a numeric field representing which type in an enumeration, which is probably how its actual constructors within types are implemented
20:22:35 <ski> augur : and quantifier raising refers to "lifting" `A' to `X / (A \ X)' or similar, yes ?
20:22:47 <ski> (or do i recall completely wrong ?)
20:22:51 <Zekka> But I was under the impression that dependently typed languages don't have such fine boundaries between types: they can depend on the properties of what's being interpreted into typed data
20:23:05 <augur> Zekka: oh thats an implementation question so we dont care about that :p
20:23:18 <Zekka> Yeah, sorry, it was unfitting
20:23:22 <augur> ski: no no, QR is just CPS in natural language. quite literally.
20:24:00 <augur> ski: "everyone saw some" ~> "everyone_x (someone_y (t_x saw t_y))"
20:24:06 <Zekka> Anyway, what were you saying before my rude interruption?
20:24:10 <augur> or ~> "someone_y (everyone_x (t_x saw t_y))"
20:24:18 <ski> augur : any link for "the syntax of quantification" ?
20:25:00 <augur> ski: no, its a dissertation, and therefore hard to fine. fwiw tho, the generative semanticists invented QL, which is the upside down version of QR, before may invented QR
20:25:27 <augur> ski: so they said you start with the quantifiers in their scope positions, and the process of "pretty printing", basically, involved lowering them to their scope positions
20:25:31 <augur> er, form their scope positions
20:25:46 <augur> Zekka: oh, i wasnt saying anything, just that one remark. :)
20:25:56 <Zekka> Thanks for that much explanation at least
20:26:05 <ski> Zekka : typically the type system is constructed to allow "type erasure", i.e. we can compute with the terms (in some representation) without needing to know the types
20:27:11 <Zekka> ski - Can you clarify? Do you mean that the types don't matter after an initial typechecking phase, or that we're concerned about something other than the types in determining whether an operation can occur, or what?D
20:27:34 <augur> Zekka: thats exactly right
20:27:39 <augur> erasure means you dont need it at run time
20:27:51 <Zekka> Those were two statements, you're confirming the first?
20:27:54 <Zekka> Because that's what I thought
20:28:00 <augur> if it can be erased, it has no effect on computation, just veriying things make sense
20:28:44 <Zekka> I don't know whether you can eliminate the tags differentiating type constructors because those do occur interchangeably, but not separate parts of the universe
20:28:57 <augur> no those have an effect on computation
20:28:58 <ski> augur : hm, "QR vs. QL" being like deriving a sentence from a nonterminal vs. reducing a sentence to a nonterminal ?
20:28:59 <Zekka> but separate types in the universe can't occur interchangeably*
20:29:10 * ski expects augur to deny that
20:29:10 <Zekka> You can probably only eliminate them in certain cases if at all
20:29:16 <augur> ski: no no, it goes back to the GS/IS split, see
20:29:25 <ski> (see !? :)
20:30:06 <augur> ski: back in the 60s, there were two major views on how syntax related to semantics. the original idea was what became known as Generative Semantics, namely that language is best modelled as a map f : SemExp -> SynExp
20:30:52 <augur> chomsky began reversing this view, giving rise to Interpretive Semantics, the till dominant view of semantics, which is that language is best modelled as f : SynExp -> SemExp
20:31:23 <ski> Zekka : in many GC schemes you do need type-infos (or some kind of standardized layout), but typically with boxed values, you don't need it for the actual computation
20:31:51 <Zekka> ski - Garbage collection?
20:31:55 <ski> yep
20:32:07 <augur> IS _became_ dominant because the GS people are kind of dicks, but IS is still dominant to this day in part because semantics has imported a lot of model theory, and tries to avoid intermediate levels of representation between syntax and denotation, so generating from semantics is hard
20:32:13 <augur> and by hard i mean impossible
20:33:14 <ski> augur : "till dominant" ?
20:33:32 <augur> ski: well, noone does GS anymore really
20:33:44 <augur> some people do something related to it, but they're a minority of linguists
20:33:54 <ski> @wn till
20:33:55 <lambdabot> *** "till" wn "WordNet (r) 3.0 (2006)"
20:33:55 <lambdabot> till
20:33:55 <lambdabot>     n 1: unstratified soil deposited by a glacier; consists of sand
20:33:55 <lambdabot>          and clay and gravel and boulders mixed together [syn:
20:33:56 <lambdabot>          {till}, {boulder clay}]
20:33:58 <lambdabot> [6 @more lines]
20:34:02 <ski> hm, not that one
20:34:19 <augur> ski: i said still, not till
20:34:19 <augur> :P
20:34:30 <ski> "the till dominant view of semantics"
20:34:33 <augur> oh you meant before
20:34:39 <augur> sorry, that shouldve been still
20:34:42 <ski> ok
20:36:45 <ski> Zekka : note that to implement closures, the usual way is to have a standardized layout (since you're effectively dealing with existentials)
20:37:17 <ski> an alternative would be to have a typeinfo which describes the layout, but then probably that has a standardized layout
20:37:32 <augur> ski: i wonder if the uniformity of dependent types is actually a problem for learners. haskell's type families stuff at least separates a bunch of semi-isolated conceptual domains
20:37:48 <augur> even tho we could implement them all as dependent stuff, i wonder if collapsing them is confusing or liberating
20:38:30 <ski> Zekka : it is possible to avoid boxed representation by passing typeinfos whenever a polymorphic operation is invoked -- the typeinfos describe size (as in `sizeof', say), and perhaps internal layout of the types the type variables get instantiated to
20:38:42 <Zekka> ski - I'm not sure I follow, can you clarify? (on closures being similar to dealing with existentials)
20:38:51 <ski> Zekka : Mercury passes typeinfos around (though not for unboxed representation, i think)
20:40:00 <Zekka> To clarify, a closure is a function with access to the scope of the function where it was defined?
20:41:16 <augur> Zekka: closures are easy if you have substitution, not so easy if you dont
20:41:32 <augur> Zekka: unfortunately, substitution is also inefficient
20:41:52 <Zekka> augur - Substitution referring to the definition we worked with (or maybe ski worked with) with purity?
20:42:16 <augur> sort of. the usual way you do the lambda calculus is like so:
20:42:27 <augur> (\x -> M) N   reduces to M[N/x]
20:42:34 <augur> where M[N/x] just means M, but with N in place of x
20:42:49 <augur> so for instance   (\x -> x) 5   ~>   x[5/x]   == 5
20:42:54 <ski> Zekka : consider the type `a -> b'. now consider the C function type `b_t (a_t)' -- in C, functions can only depend on local variables and "global" variables, in particular, you can't define a function inside another, and even if the syntax allowed you that, it couldn't access non-locals from the wrapping function
20:43:11 <Zekka> Oh, are we about to get to the case where we pass an expression containing the parameter of the lambda abstraction?
20:43:18 <augur> but consider   K = \x -> \y -> x.   K 0 ~> (\y -> x)[0/x] = \y -> 0
20:43:38 <Zekka> Right, the K combinator.
20:43:46 <augur> you've substituted under a \
20:43:52 <augur> so you've created a closure.
20:44:04 <augur> thats all a closure is
20:44:18 <Zekka> Right, \y -> x is a closure because it has access to the outer scope.
20:44:21 <augur> the x is outside the \y part, so it's an "outer" scope, but with substitution, thats sort of irrelevant
20:44:33 <augur> the "outer scope" isnt there any more, "x" is no longer there, it just IS \y -> 0
20:44:39 <Zekka> however, we don't have to think like that because we can just substitute x initially
20:44:42 <augur> its not \y -> x where x is now "bound to 0" or whatever
20:44:55 <Zekka> (which is an allowed thing if scopes aren't mutable, like in Haskell or the lambda calculus)
20:45:00 <augur> right
20:45:17 <augur> substitution is the usual explanation of how beta reduction works
20:45:38 <augur> the problem is substitution is a pain in the ass for efficiency because you have to traverse the whole tree every time
20:45:56 <augur> one solution to this is actually to do explicit substitutio
20:46:23 <augur> so instead of [M/x] you make a new kind of term <M/x> and these get moved around by more reduction rules
20:47:07 <Zekka> So we'd be keeping information that 'also, replace x with M' in the closed-over function?
20:47:18 <augur> well no its not a closed over function yet
20:47:23 <Zekka> which would be handled lazily? Or am I misunderstanding.
20:47:24 <Zekka> ?*
20:47:25 <augur> not quite
20:47:25 <lambdabot> Maybe you meant: v @ ? .
20:47:52 <Zekka> I thought I might have been misunderstanding, can you clarify?
20:47:55 <augur> but one approach is to put substitution in as an explicit term, which you then deal with as you need to
20:47:59 <augur> so yeah, its kind of lazily
20:48:10 <augur> a quick bit of foresight says you probably want <M/x, M'/x', ...> instead of just <M/x> -- ie you have multiple variables not just one
20:48:11 <Zekka> I'm not quite sure I understand what you mean by 'as an explicit term'
20:48:21 <augur> well explicit
20:48:27 <augur> as in, its part of the _program_
20:48:31 <Zekka> If it's like I described it's very similar to keeping a reference to the previous scope
20:48:31 <augur> not merely part of how you evaluate
20:48:41 <Zekka> Oh, I think I understand, although the difference isn't quite clear to me
20:48:41 <augur> the _program_ includes <M/x>
20:48:48 <augur> whereas [M/x] was just some meta-operation
20:49:08 <Zekka> that is, I'm not sure I see how it's different from performing it implicitly, given that I can't think of any  cases where it would occur outside of application, when the other operation would occur
20:49:19 <Zekka> and given that performing the <M/x> operation would require traversing the tree as well, no?
20:49:19 <augur> so one route to handling this is to make substitution a part of your program code, and you explicitly push around substitutions
20:49:29 <augur> Zekka: well its not entirely different
20:49:36 <ski> Zekka : anyway, `b_t (a_t)' corresponds less to the Haskell / traditional Logic `a → b' than to the "strict implication/conditional" `a ⥽ b' of Lewis, which can also be thought of as `◻ (a → b)' where `◻' denotes a kind of modal *necessity* (namely that the (non-local) values that can be accessed are *necessary*, not cotingent, iow exists throughout the lifetime of the whole process, not just for the duration of the execution of a single
20:49:59 <ski> (hm, possible cut off : ".., iow exists throughout the lifetime of the whole process, not just for the duration of the execution of a single function body)")
20:50:13 <Zekka> ski - Cut off beyond 'single', thank you
20:50:18 <augur> but who says you have to push <M/x> anywhere? you dont have to do it right away, you can wait. whereas with a meta-operation, its a bit harder to say what you mean by "you can wait" since the meta-language has its own notion of evaluation
20:50:31 <ski> Zekka : anyway, let's asciify `a ⥽ b' as `a #-> b', corresponding to "function pointers" in C
20:50:32 <augur> Zekka: in haskell it would wait, in idris it wouldnt.
20:50:37 <Zekka> augur - I think I understand, at least roughly
20:51:41 <augur> Zekka: but, another alternative is to instead carry around an explicit list of binders. kind of like fusing the substitution operation into the eval operation
20:52:02 <augur> Zekka: so instead of saying   eval ((\x -> M) N) = eval M[N/x]
20:52:20 <ski> Zekka : then we can think of `a -> b' as meaning `exists s. (# s , (# s , a #) #-> b #)', where there *exists* some hidden environment / state / static link type `s', such that we have an (unboxed) pair of an element of that type, together with a "function pointer" that yields a `b' when fed an (unboxed) pair of an environment and an `a'
20:52:29 <Zekka> augur - So you'd be passing around references to a list that says 'these are the substitutions you might make', so if anybody asks make the substitution?
20:52:30 <augur> you would instead say   eval env ((\x -> M) N) = eval (extent env x M) N
20:53:01 <augur> Zekka: more or less, yeah
20:53:13 <augur> or you pass the list. references are an implementation issue of the meta-language :)
20:53:20 <Zekka> ski - Thanks for asciifying, several characters you used did not render correctly on my client: proessing
20:53:37 <augur> Zekka: but what do you do when you eval a lambda?   eval env (\x -> M) = ???
20:54:13 <augur> you somehow need to make sure that when you later USE the lambda M still can see the environment. so usually you define a new lambda-like thing (call it proc)
20:54:15 <augur> like so:
20:54:24 <ski> Zekka : and this is the traditional simple implementation of closures, which is often simulated in C by `struct blah { void *env_data; b_t (*fun_ptr)(void *env_data, a_t an_a); }' or like `bleh_t frob(void *env_data, b_t (*fun_ptr)(void *env_data, a_t an_a), more stuff here) {...}'
20:54:27 <augur> eval env (\x -> M) = proc env x M
20:54:50 <Zekka> Just a moment, I have a bit of reading to do and then I'll have a couple of questions
20:54:51 <augur> so its just like a lambda but it knows its environment
20:55:01 <augur> Zekka: you should watch SICP btw
20:55:09 <Zekka> Watch? You don't mean read?
20:55:13 <augur> watch
20:55:19 <Zekka> (We are referring to Structure and Interpretation of Computer Programs, right?)
20:55:23 <augur> yes
20:55:28 <roboguy_> watching SICP is more fun than reading, I think
20:55:32 <augur> http://www.youtube.com/watch?v=2Op3QLzMgSY&list=PL8FE88AA54363BC46
20:55:41 <ski> Zekka : asciifying "traditional Logic `a → b' than to the \"strict implication/conditional\" `a ⥽ b'" yields roughly "traditional Logic `a -> b' than to the \"strict implication/conditional\" `a -} b'"
20:55:41 <augur> watching is WAY more fun
20:55:55 <augur> abelson and sussman are very fun lecturers
20:56:05 <roboguy_> yeah. it's a cool video series
20:56:13 <augur> ive watched SICP at least three or four times now just because its so fun
20:56:13 <ski> Zekka : and similarly for "which can also be thought of as `◻ (a → b)' where `◻' denotes" into "which can also be thought of as `[] (a → b)' where `[]' denotes"
20:56:23 <augur> in fact, SICP was my main route to functional programming
20:56:30 <roboguy_> actually, talking about it makes me want to watch it again. it's been a couple years
20:56:30 <Zekka> ski - So in other words, it's similar to an alternative form whee the stack exists as a hidden parameter?
20:56:46 <augur> in about 2006 i discovered functional JS, and was baffled by it all (i mean truly baffled, nothing made sense)
20:56:57 <augur> then i watched SICP and my mind was opened
20:57:10 <Zekka> I think I discovered FP in 2011 or 12, but dismissed it until early this year
20:57:10 <augur> but it wasnt until about 2011 that i properly understood fold, tbh
20:57:16 <ski> Zekka : `[]' meant to look like a square (traditional notation for "necessary" in modal logic), and `-}' really meant to have the middle part of `}' point to the left, rather than to the right ("fish tail" in unicode)
20:57:33 <Zekka> I understand fold but I don't have a strong intuition for it
20:57:42 <Zekka> same could be said for a lot of Haskell's higher order functions
20:58:01 <augur> fold is easy to understand with the right explanations, i think
20:58:05 <Zekka> If you've got any thoughts I'd appreciate them, I've considered just tersely reimplementing the stdlib
20:58:19 <ski> Zekka : "a closure is a function with access to the scope of the function where it was defined?" -- a closure is a common *implementation* of that
20:58:39 <Zekka> ski - Where alternate implementations are what?
20:59:10 <augur> Zekka: substitution is another implementation!
20:59:23 <augur> tho arguably substitution obviates the need for words like "scope"
20:59:37 <Zekka> augur - I was thinking in terms of substitution as an implementation of closures, seems my mental hierarchy is flawed
20:59:45 <augur> i feel like the notion of scope used here is crucially dependent on variable envs
21:00:32 <augur> Zekka: substitution and environments are both ways of implementing the abstract notion of binding of a variable by a value
21:01:09 <Zekka> Alright. So basically, if you assume a function is a (usually) tree-like collection of symbols, substitution is an eager translation of those symbols to values and environments are a lazy one?
21:01:17 <ski> Zekka : you can think of it like this : substitution yields a simple (but inefficient) implementation -- instead you *delay* (a bit like with laziness) substitutions, and instead collect them in an "environment" -- whenever you actually run into a free variable, you perform the delayed substitution for that variable ("look up the variable in the environment")
21:01:54 <augur> Zekka: more or less, yeah. substitution goes through, finds the vars, and replaces them with their values right away
21:02:08 <augur> environments wait until you need the variables' value
21:02:14 <Zekka> and closures for shared scopes can be implemented by either substituting over the whole tree or maintaining a reference to the environment, a list of bindigns, or additional terms (lazy)
21:02:29 <augur> i wonder if haskell's laziness makes environments redundant
21:02:30 <Zekka> depending on which strategy was used initially
21:02:33 <augur> probably not
21:03:00 <augur> Zekka: no no closures arent "implemented"
21:03:13 <augur> they're just the consequence of evaluating a lambda term
21:03:15 <Zekka> I have a feeling performing the substitution in 'eager' style would probably result in similar output to maintaining a stored environment
21:03:32 <augur> Zekka: yes, these are supposed to be equivalent
21:03:36 <Zekka> augur - Yes, but it's possible to describe rules for systems of either kind that don't have support for closures.
21:03:44 <augur> it shouldnt matter whether you use substitution or environments, except in terms of efficiency
21:04:00 <augur> Zekka: well yes, usually thats because those systems dont have lambda terms!
21:04:01 <ski> Zekka : however, when evaluating a lambda expression (a function abstraction), we don't evaluate its body; that happens later (possibly in another scope), when applying the function. to properly simulate the (delayed) substitution, we need to bundle the abstraction (the source of the lambda) together with the environment (delayed substitution) in force when the lambda was evaluated
21:04:08 <ski> Zekka : or at least, we need to bundle the part of the environment which is accessible by the body of the abstraction
21:04:09 <Zekka> Er, I didn't mean 'similar output' as in the results are equivalent but that the resulting code would be the same way
21:05:29 <Zekka> the implementation with substitution in a lazy language probably wouldn't work substantially differently or less efficiently than keeping an environment
21:06:02 <Zekka> reading ski's notes, one moment
21:07:08 <Zekka> Ski - Are you saying that we need to maintain an environment in that case?
21:07:21 <Zekka> Because I don't see why it matters when we evaluate a lambda expression
21:07:46 <Zekka> we should be able to evaluate as eagerly as we want to given that we don't have to deal with side effects, possibly excluding cases where this would lead to indefinite recursion
21:08:50 <enzo_> Hi all, I just uploaded my time library to Hackage: http://hackage.haskell.org/package/time-exts
21:09:19 <ski> Zekka : yeah, but it's more efficient to access an environment than to do substitution
21:09:23 <ski> (SICP talks about this)
21:09:34 <enzo_> I've modeled the library after several others, including Google's TrueTime, Simon Marlow's NewTime, Joda.org's Joda-Time, Bloomburg's date-time, Nathan Howell's time-cube, and Ashley Yakeley's time
21:09:47 <enzo_> Hope you guys like it!
21:09:58 <Zekka> Well, right, but it sounded like you were suggesting that both strategies weren't equally viable, not that one was better
21:10:17 <augur> Zekka: both work. one is drastically less efficient.
21:10:18 <ski> augur : there's still a choice of how to represent the actual closure
21:10:34 <augur> ski: yeah thats a boring issue :p
21:10:44 * ski grins
21:10:52 <augur> ski: Proc Env Var Exp
21:11:01 <Iceland_jack> enzo_: Looks neat!
21:11:26 * ski . o O ( "Pattern Calculus" )
21:11:43 <Zekka> Anyway, all that talk and I forgot to find the SICP video
21:11:44 <Zekka> one moment
21:11:53 <augur> ski: ive never understood the pattern calculus
21:11:58 <augur> Zekka: i linked you!
21:12:01 <ski> augur : me neither
21:12:01 <augur> http://www.youtube.com/watch?v=2Op3QLzMgSY&list=PL8FE88AA54363BC46
21:12:08 <Zekka> augur - Yes, I went back up through the log
21:12:14 <ski> i've started attempting to read his book twice now
21:12:38 <roconnor> enzo_: Gene Ray's time cube?
21:12:40 <augur> ski: i think if you cant explain the basics of it in a tutorial, you're obviously wrong
21:12:40 <augur> :p
21:12:40 <roconnor> :P
21:12:41 <ski> but istr ddarius would recommend it, so i continue to try
21:12:49 <ski> preflex: xseen ddarius
21:12:50 <preflex>  ddarius was last seen on freenode/#haskell 1 year, 62 days, 19 hours, 2 minutes and 26 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
21:12:55 <ski> :(
21:13:07 <Zekka> Is that how you people talk when people like me aren't around?
21:13:11 <augur> ddarius was smart, but a jerk.
21:13:15 <nstdloop> Related to an interesting Quora question: How would MVC look in Haskell?
21:13:29 <ski> Zekka : which ?
21:13:36 <nstdloop> Is it just fundamentally not a good idea? Can it work?
21:13:39 <Zekka> ddarius' comment
21:13:54 <ski> Zekka : that's just some or other lambdabot fodder
21:14:10 <enzo_> roconnor: github.com/alphaHeavy/time-cube
21:14:14 <ski> let's see what it does ?!
21:14:16 <ski> > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
21:14:18 <lambdabot>   "hell, wold"
21:14:36 <ski> enzo_ : `time-cube' !? :)
21:14:55 <Zekka> I never got around to reading timecube, was it any good?
21:15:16 <ski> depends on your definition of "good"
21:15:42 <ski> see for yourself : <http://www.timecube.com/>
21:16:00 <Zekka> That's about how I remembered it, it seems a little hard to follow
21:16:23 <enzo_> I think that's a different time cube
21:16:48 <ski> istr more "You are educated Evil"'s, though
21:17:06 <Zekka> I was quietly hoping that somebody had attempted to express Time Cube in Haskell the way someone might express parts of it in a theorem prover
21:17:11 <ski> enzo_ : there can be only one !
21:17:19 <simpson> He changes the page every so often, yes.
21:17:35 <augur> fun fact: one of queen's most popular albums was the highlander soundtrack album
21:17:43 <ski> augur : perhaps, but i'd still like to have him back here
21:17:54 <augur> ski: what happened to him anyway
21:18:09 <ski> work or something
21:18:11 <ski> not sure
21:18:18 <ski> edwardk(?) possibly knows
21:18:26 <jfeltz> given the type of the first argument to: withReader :: (r' -> r) -> Reader r a -> Reader r' a, isn't this counter-intuitive? How is the environment r supposed to be set in this case?
21:18:47 <nstdloop> Anyone: Related to an interesting Quora question: How would MVC look in Haskell?
21:19:02 <nstdloop> It seems to superficially be a perfect match
21:19:12 <ski> jfeltz : note that that amounts to `(r1 -> r0) -> (r0 -> a) -> (r1 -> a)'
21:19:13 <nstdloop> You have a model that takes a controller and returns a view
21:19:24 <nstdloop> and a model that takes a view-change and returns a new controller
21:19:26 <Zekka> I'd comment on the MVC problem except I've only written relatively small toy software in Haskell
21:19:28 <sclv> well you don't really want to return a new view typically
21:20:16 <nstdloop> sclv: Well that's just the mutability/immutability issue, right?
21:20:16 <sclv> you want to modify a view (i.e. be view -> view) and probably produce a "view-delta" that tells your display manager (gui binding, dom model, whatever) the elegant way to reflect that.
21:20:50 <nstdloop> that's your controller, isn't it
21:21:20 <sclv> the way i've done it is typically have lots of (model -> model) functions and the controller is (view, model) -> IO view, so to speak
21:21:43 <nstdloop> makes sense
21:21:44 <sclv> if that makes sense
21:22:25 <sclv> you also don't want to "take a view change"
21:22:40 <zero-one> can anyone suggest some reading to help me wrap my head around monads?
21:23:07 <Iceland_jack> zero-one: Not reading any monad tutorials :)
21:23:10 <sclv> or i don't at least. instead i just attach "model update functions" to the view. and it calls them, followed by "render model to view"
21:23:15 <Zekka> zero-one - I can't think of any great articles offhand but I can try to help you out
21:23:24 <Zekka> (I'm the beginner here so I'm practically obligated to try to explain monads to someone)
21:23:57 <Zekka> (that's basically what beginners do, isn't it?)
21:24:02 <Iceland_jack> Too often yes :)
21:24:19 <Zekka> zero-one - Do you know what a functor is?
21:24:39 <Iceland_jack> zero-one: Use and get a good feel for IO, [], Maybe, …; learn what functors and applicative functors are; then start worrying about monads
21:24:53 <Zekka> I didn't really figure out what monoids were until I had a pretty good intuition for how functors/applicatives worked
21:24:57 <Zekka> monads*
21:25:00 <Zekka> monoids are another matter
21:25:10 <Iceland_jack> That's my standard response every time and I believe it's ignored as often :)
21:25:12 <ski> Zekka,augur : anyway, given `let x = computeLargeThing in let y = compressIt x in \z -> ..y..z..', we'd like the closure to not carry around a reference to `x', so that `x' can be GCed
21:25:34 <Zekka> ski - Right, x is thing not needed in the innermost scope
21:25:44 <ski> that's one practical part of selecting a good representation of the environment of a closure
21:25:46 <zero-one> Iceland_jack: that's not a bad idea at all
21:25:57 <zero-one> Zekka: i did at one point, lol
21:26:09 <augur> ski: how does that show up in languages
21:26:42 <napping> augur: only quite subtly, I'd guess
21:26:54 <ski> Zekka(,augur) : btw, you might find "Abstract Models of Memory Management" by Grep Morrisett,Matthias Felleisen,Robert Harper in 1995 at <http://www.cs.cmu.edu/~rwh/papers/gc/fpca95.pdf> interesting
21:26:54 <yitz> zero-one: i agree with Iceland_jack. except i wouldn't worry about applicatives just yet. do keep the definition of the monad class in front of you as you go.
21:27:00 <Zekka> Ignoring anything to do with burritos, functor types are basically context for values
21:27:04 <Zekka> ski - Thanks, downloading
21:27:30 <napping> augur: like if you promise too much about objects having finalizers and when they run
21:27:36 <Zekka> The standard analogy is a box: Maybe is an example of a box
21:28:19 <Zekka> What you receive is either Just (some value) or Nothing. The context represented by Maybe is that sometimes a value isn't there
21:28:36 <napping> augur: hopefully a compiler can get away with representing closures how it likes otherwise
21:28:48 <Zekka> A functor defines its own way to apply an operation to the thing(s) inside the box
21:29:00 <Zekka> THere are two functions that do this, and they're aliases for each other: fmap, and (<$>)
21:29:23 <Zekka> fmap (+1) $ Just 2 is Just 3 -- fmap (+1) $ Nothing is Nothing
21:29:25 <ski> augur : that paper expresses GC as a reduction rule of language *expressions* (roughly) through a small-step operational semantics, by employing Felleisen contexts
21:29:38 <Zekka> that's because Maybe knows that you can apply an operation to a thing that's actually there, but not a thing that's not there
21:29:42 <Zekka> so it defines fmap with that in mind
21:29:45 <osa1> is there a way to treat record fields as some kind of first order object? what I want to do is this: I have 3 fields that share same type, and I want to apply same operation to these fields depending on some conditions and I don't want do duplicate code just to rename some fields
21:29:55 <Zekka> Lists are also a functor, whose context is that multiple values exist
21:30:22 <Zekka> fmap == map -- fmap (+1) [1, 2, 3] == [2, 3, 4]
21:30:37 <Zekka> No one has shouted at me yet so I assume my explanation up to that point was correct
21:30:41 <Zekka> zero-one - Does that help with functors?
21:30:45 <napping> osa1: you might pass functions (a -> a) -> (Record -> Record)
21:30:52 <yitz> osa1: they're not first class unfortunately. you may be in luck for what you want to do specifically though, if the types are the same. otherwise, use lenses.
21:31:23 <osa1> napping: how does that work for updating records?
21:31:51 <ski> Zekka : aside, out of style, i'd prefer not using `$' here
21:32:01 <osa1> let's say I have field field1 :: Int and field2 :: Int, I have a function Int -> Int, depending on some conditions, I want to apply this function for field1, field2 or both
21:32:12 <Zekka> ski - Do you think it would have been neater to parenthesize the Just?
21:32:20 <napping> if that works for the kind of update you want to do, instead of f r args = r {field = newVal args (field r)}, say f onfield r args = onfield (\x -> newVal args x) r
21:32:22 <Zekka> er, the Just 2
21:32:28 * ski believes newcomers are often a bit too happy to use `$'
21:32:42 <napping> and pass functions like onField1 f r = r {field1 = f (field1 r)}
21:33:03 * yitz is not a newcomer and would often be perfectly happy to use $ the way Zekka did in this case
21:33:03 <ski> @src Maybe fmap
21:33:04 <lambdabot> fmap _ Nothing       = Nothing
21:33:04 <lambdabot> fmap f (Just a)      = Just (f a)
21:33:21 <ski> @src [] fmap
21:33:21 <lambdabot> fmap = map
21:33:24 <ski> @src map
21:33:25 <lambdabot> map _ []     = []
21:33:25 <lambdabot> map f (x:xs) = f x : map f xs
21:33:41 <yitz> sometimes i would use <$> instead. almost never parens in this case.
21:34:09 <napping> that's kind of what lens libraries do anyway, except you'll have a type like Lens Record Record a a, and they handle lookups and updates too
21:34:11 <Zekka> I would have used <$> for a function that's usually applied in prefix
21:34:45 <ski> yitz : imo it's fine (well, more fine ;) to use it in actual code, than to use it when explaining what an application of `fmap' means/does
21:34:58 <yitz> i suppose
21:35:22 <Zekka> Anyway, the short of this is that fmap is the operator a functor defines to perform an operation in contex
21:35:24 <Zekka> context*
21:35:31 <Zekka> operation*
21:36:16 <ski> the reduction order is :   fmap (+ 1) $ Just 2  =  fmap (+ 1) (Just 2)  =  Just ((+ 1) 2)  =  Just (2 + 1)  =  Just 3
21:36:27 <ski> where the penultimate step is just resugaring
21:37:22 <zero-one> Zekka: i follow
21:37:24 <ski> zero-one : did we manage to utterly confuse you yet ?
21:37:28 <ski> ok
21:37:44 <Zekka> Alright then
21:37:48 <zero-one> ski: i'm slightly confuzzled, but nothing that some reading and tinkering won't fix
21:38:02 <napping> what do you need monads for?
21:38:02 <Zekka> Anything in particular that has you confused?
21:38:09 <Zekka> I can go into a little more detail or give more examples if you like
21:39:00 <ski> @quote paperwork
21:39:00 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
21:39:14 <zero-one> Zekka: nah, i think i'm good for now
21:39:36 <Zekka> Alright. Want me to go into Applicative? (the next rung up)
21:40:15 <zero-one> uh.... i should go do my homework
21:40:17 <zero-one> hahaha
21:40:24 <Zekka> Oh, OK.
21:40:33 <Iceland_jack> zero-one: Haskell is your homework now
21:40:57 * zero-one has been charged with a task
21:42:43 <osa1> napping: so does help simplifying this kind of functions http://lpaste.net/95125 especially the first two, they're almost the same (except for the field name)
21:42:54 * ski . o O ( Tasks <http://amigadev.elowar.com/read/ADCD_2.1/Libraries_Manual_guide/node0287.html> )
21:43:59 <ski> osa1 : lenses ?
21:44:36 <ski> preflex: xseen dons
21:44:36 <preflex>  dons was last seen on freenode/#haskell 175 days, 16 hours, 59 minutes and 25 seconds ago, saying: boing
21:45:13 <ski> augur : btw, did you check out "Fun With Linear Implicit Parameters" ?
21:45:26 <ski> (i think it was you i suggested it to, recently)
21:45:30 <napping> probably won't break even without some library that uses TH to define the lenses for you, but yeah
21:45:34 <osa1> ski: learning a new complex library is the last think I want to do right now
21:46:13 <ski> osa1 : you could define `modifyProgram :: (Program -> Program) -> (TC -> TC)' and such
21:46:33 <AshyIsMe> hmm
21:46:34 <napping> you could split that as normalizeProgramPath rootFolder tc = onProgram (fmap (rootFolder </>)) tc
21:46:36 <ski>   normalizeProgramPath rootFolder = modifyProgram (fmap (rootFolder </>))  -- then
21:46:42 <AshyIsMe> could not find module `Network.HTTP'
21:46:47 <napping> with onProgram f tc = tc { program = f (program tc) }
21:46:49 <AshyIsMe> any idea what's going on there?
21:46:56 <ski> yeah, `modifyProgram = onProgram'
21:47:19 <augur> ski: no
21:47:24 <augur> or maybe
21:47:51 <ski> augur : <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters>, uses `reset' and `shift' to implement Filinski's monadic reflection
21:48:16 <ski> e.g. `reify (reflect [0,2] + reflect [0,1]) :: [Int]' evaluates to `[0,1,2,3]'
21:49:30 * ski wonders what really happened to TheHunter
21:53:12 <napping> can you run a decl splice in ghci?
21:57:31 <geekosaur> I don't think you can do any TH in ghci?
21:57:40 <chrisdone> mm_freak_: poke
21:57:49 <enthropy> no you can splice Exp in ghci
21:58:04 <napping> osa1: with lens, you'd write makeFields ''TC at the top level
21:58:22 <enthropy> napping: maybe the best you can do is    $(letE (makeFields ''TC) [| something in here  |])
21:58:27 <napping> if the type is TC and you changed the definition to prefix the fields with underscores
21:58:30 <enthropy> which is pretty useless
21:58:51 <napping> then normalizeProgramPath rootFolder tc = over (program . traverse) (rootFolder </>)
21:59:07 <enthropy> there's probably no reason ghci couldn't run Q [Dec] splices
21:59:15 <napping> normalizeResultPath rootFolder tc = over (result . traverse) (rootFolder </>)
21:59:34 <napping> and normalizeDefinitionPath rootFolder tc = over definition (rootFolder </>)
22:10:19 <osa1> is there a way to get the current pwd in haskell program? (without callind `pwd`, of course)
22:10:56 <joelteon> :t getCurrentDirectry
22:10:57 <lambdabot> Not in scope: `getCurrentDirectry'
22:10:58 <joelteon> fuuug
22:11:04 <joelteon> it's getCurrentDirectory
22:11:19 <osa1> okay
22:12:18 <augur> is bidirectional type checking related to a split type theory with "has a verification" and "can be used" judgments?
22:13:26 <augur> hmm probably not
22:16:26 <AshyIsMe> hmm, seems heaps of my cabal packages are broken atm
22:16:45 <AshyIsMe> is there a way to uninstall and reinstall everything ive got locally?
22:27:19 <mm_freak_> chrisdone
22:30:55 <osa1> which thread pool library should I use?
22:33:32 <augur> ski: i think the >< <> notation is nice to some extent. it'd be nice to be able to tag them somehow maybe tho
22:35:17 <augur> and also to have a super >< that iterates >< as needed
22:35:31 <ski> iterates ?
22:36:06 <augur> say,   !>[<xs>,<ys>]< == >>[<xs>,<ys>]<<   !>[<xs>,<ys>,<zs>] == >>>[<xs>,<ys>,<zs>]   etc
22:36:28 <enthropy> needs more fish
22:36:33 <augur> :)
22:36:50 <augur> ski: a sort of >< that drops down all the monadic values at once
22:36:52 <ski> well, i had just `> Person <parseName> <parseAge> <'
22:37:04 <enthropy> > let x ><> y = "fish" in () ><> "oO"
22:37:05 <lambdabot>   "fish"
22:37:06 <augur> oh, and that drops them all? hmm.
22:37:46 <ski> compare with the lispy  `(person ,parse-name ,parse-age)
22:37:56 <augur> thats probably optimal for the purposes most people would use it for
22:38:11 <augur> idris could use spanish upside down ! for that :)
22:38:45 <ski> ¡
22:38:58 <augur> ¡[!xs,!ys]
22:39:13 <enthropy> @let (><>°) = (><>°)
22:39:13 <lambdabot>  Parse failed: Parse error: )
22:41:58 <osa1> can anyone help me? we have several different thread pool libraries and I'm not sure which one to use. what I want to do is to run some big amount of OS processes(I'll call some other program) in a pool.
22:42:18 <osa1> I want to have truly parallel processes, instead of lightweight Haskell threads or something similar
22:42:44 <napping> Haskell threads are truly parallel
22:43:18 <osa1> really? that's great.
22:43:22 <osa1> my question still valid though
22:45:23 <osa1> maybe this one http://hackage.haskell.org/package/parallel-io
22:46:25 <osa1> yeah, this one looks good
22:46:40 <napping> or maybe just a semaphore, if the heavy work is done outside in processes
22:47:05 <napping> well, I guess that's probably about what that library is doing
22:55:31 <hezhit> hi, all. I am writing a website using snap, is there any way to automatically recompile my source code, so that I can see the result in browser after saving the code?
22:56:03 <joelteon> yesod does that. :)
23:00:26 <hezhit> I don't like yesod's hamlet, and wanna give heist a try.
23:00:48 <joelteon> fair enough
23:03:09 <chrisdone> mm_freak_!
23:03:43 <chrisdone> mm_freak_: i ported my irc server to use fastirc =)
23:07:00 <hezhit> I think anybody with XML experience saw a "<title>#{title}" will try to fix the syntax err and append another "</title>".
23:07:29 <hezhit> but using template like jade will be ok.
23:07:31 <joelteon> well, it's a lot of noise i could do without
23:13:51 * hackagebot hulk 0.2.0 - IRC server written in Haskell.  http://hackage.haskell.org/package/hulk-0.2.0 (ChrisDone)
23:14:20 <Clint> o_O
23:15:18 <chrisdone> @_ @
23:15:18 <lambdabot> Maybe you meant: v @ ? .
23:16:14 <Clint> chrisdone: does it work with any services daemons?
23:17:49 <chrisdone> Clint: dunno
23:18:00 <chrisdone> never needed such things
23:19:26 <roboguy_> how did lambdabot get v from that?
23:21:52 <mm_freak_> chrisdone: unfortunately the current version of fastirc is very out of date
23:22:05 <mm_freak_> i'm surprised it still compiles
23:22:07 <chrisdone> mm_freak_: yeah, i had to patch it locally to get it running
23:22:28 <chrisdone> mm_freak_: but i only had to remove hiding (many) from an attoparsec impoort
23:22:33 <chrisdone> after that it works fine
23:23:36 <Clint> what's monadLib for?
23:25:54 <chrisdone> mm_freak_: if you fix it somewhen let me know, it will probably help my haddocks to build on hackage
23:26:05 <chrisdone> i'd send a patch but i don't know darcs
23:26:08 * chrisdone →  bed
23:45:12 <AshyIsMe> weird
23:45:43 <AshyIsMe> reinstalling haskell-platform with brew didnt fix the "could not find module Network.HTTP" issue im getting
23:47:26 <roboguy_> AshyIsMe: did you install the appropriate package with cabal?
23:52:01 <AshyIsMe> package http?
23:52:05 <AshyIsMe> it's installed already apparently
23:59:21 <roboguy_> AshyIsMe: did you install it? I don't think it comes with the haskell platform
