00:02:07 <lispy> AshyIsMe: Can you post your full error message to something like lpaste.net?
00:02:22 <lispy> AshyIsMe: there are lots of reasons why you might get that error
00:14:42 * hackagebot crypto-numbers 0.2.2 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.2.2 (VincentHanquez)
00:14:42 * hackagebot hulk 0.2.0 - IRC server written in Haskell.  http://hackage.haskell.org/package/hulk-0.2.0 (ChrisDone)
00:16:57 <Iceland_jack> /me wonders why Crypto.Number.Basic exports:
00:16:57 <Iceland_jack> areEven :: [Integer] -> Bool
00:16:57 <Iceland_jack> areEven = and . map even
00:17:05 <Iceland_jack> and why it's not even 'all even'
00:17:16 <Iceland_jack> @pl and . map even
00:17:16 <lambdabot> all even
00:17:47 <Iceland_jack> but mostly why it's a top-level definition that is exported
01:14:05 <AshyIsMe> lispy: https://gist.github.com/AshyIsMe/7287473
01:16:54 <AshyIsMe> ive run it with -v, how do i redirect stderr and stdout to a file with bash?
01:17:20 <AshyIsMe> oh, got it
01:18:36 <AshyIsMe> https://gist.github.com/AshyIsMe/7287473
01:18:45 <AshyIsMe> i commented with the full -v output from ghc
01:19:45 <AshyIsMe> looks like half my libraries are missing wtf
01:19:57 <AshyIsMe> this is after a fresh brew install haskell-platform
01:32:01 <AshyIsMe> hmm, is it possible that cabal is installing packages somewhere that ghc isnt looking for them?
01:32:46 <AshyIsMe> import System.Random  fails with unable to find the package
01:33:10 <AshyIsMe> but "cabal install random"  says that random-1.0.1.1 is already installed
01:34:18 <Cale> AshyIsMe: ghc-pkg list random and make sure there's a package listed
01:39:38 <AshyIsMe> Cale: ah cheers!
01:39:43 <AshyIsMe> needed a ghc-pkg recache
01:39:48 <AshyIsMe> all working now
01:39:52 <Cale> cool
01:50:50 <taejo> in the lens package, is there a function for creating a lens from a getter/setter pair? or do I have to jump through this `fmap setter (f current)` hoop?
01:51:58 <yitz> taejo: i'm not a lens user, but - how about just the constructor of Lens?
01:52:32 <taejo> yitz: Lens is a type synonym
01:52:39 <taejo> for forall f. Functor f => (c -> f d) -> a -> f b
01:53:53 <taejo> sometimes I look at these types and wonder what I've done wrong in life (in particular, whether choosing "lens" over some other lens library was something I've done wrong)
01:54:59 <yitz> taejo: oh. well, all the lens introductions start out with a Lens type that has two fields, a getter and a setter. i'm sure that type must reduce to that somehow...
01:56:00 <supki_> @ty (lens)
01:56:01 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
01:56:34 <taejo> ty, supki_
01:00:46 <FreeFull> :t lens id const
01:00:47 <lambdabot> Functor f => (t -> f b) -> t -> f t
01:01:01 <FreeFull> I don't think this is a valid lens
01:01:39 <FreeFull> :t lens fst (\(_,b) x -> (x,b))
01:01:40 <lambdabot> Functor f => (a -> f t) -> (a, t1) -> f (t, t1)
01:17:15 <linduxed> hey guys, i was wondering if there's an ncurses library you'd recommend?
01:17:44 <linduxed> so far i've found ncurses, hscurses, nanocurses and vty
01:17:55 <linduxed> i can't figure out which one to go with though
01:18:09 <linduxed> vty seems to have a sample application to test the thing with, so that's nice
01:18:42 <dv-> i recommend ncurses
01:25:11 <mm_freak> linduxed: i recommend vty
01:25:19 <taejo> FreeFull: I think the identity lens is `lens id (flip const)`
01:25:54 <mm_freak> linduxed: for UIs there is vty-ui, which is about as awkward to use as all other GUI toolkits, but it's quite powerful
01:26:25 <mm_freak> chrisdone: releasing a new fastirc is a lot more likely
01:26:34 <mm_freak> the new parsing code already exists
01:27:04 <linduxed> well i'm not sure what i'll need except that i want something ncurses-based
01:27:07 <mm_freak> chrisdone: https://github.com/ertes/fastirc/blob/master/Network/FastIRC/Raw.hs
01:27:58 <mm_freak> chrisdone: this is a temporary location…  when i continue my work on fastirc, the code will be found somewhere here:  http://hub.darcs.net/ertes/
01:28:22 <mm_freak> linduxed: vty is 100% haskell
01:28:30 <mm_freak> i.e. it's not ncurses =)
01:29:38 <mm_freak> linduxed: http://lpaste.net/95093
01:29:47 <linduxed> mm_freak: oh, but it will give me something like it i take it?
01:29:54 <mm_freak> if you ignore the FRP parts, that's pretty much what vty-ui code looks like
01:30:04 <mm_freak> linduxed: yeah
01:30:23 <mm_freak> linduxed: vty is a terminal "graphics" library…  it gives you a raw canvas
01:30:30 <mm_freak> vty-ui is a toolkit built on that canvas
01:31:03 <linduxed> oh ok
01:31:11 <linduxed> yeah the thing is
01:31:15 <dv-> i'd still go with ncurses if you just want to draw some stuff in a terminal :p
01:31:26 <mm_freak> dv-: why?
01:31:29 <linduxed> i got the idea of creating a command line github pull request interface
01:31:35 <linduxed> with comments and everything
01:31:42 * linduxed doesn't want to leave the terminal
01:31:53 <linduxed> so i thought that ncurses would do fine
01:32:01 <dv-> mm_freak: it's very simple
01:32:07 <mm_freak> linduxed: "command line"?  or terminal-UI?
01:32:10 <linduxed> i was imagining something like mutt
01:32:27 <mm_freak> dv-: however simple ncurses is, i guarantee that vty is even simpler
01:34:51 * hackagebot uu-parsinglib 2.8.1.1 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.8.1.1 (DoaitseSwierstra)
01:36:15 <dv-> mm_freak: i'll need to look at vty then
01:38:12 <dv-> linduxed: there's an outliner called riot that has an interface very similar to mutt. might be worth checking out
01:38:50 <linduxed> dv-: should i just google "riot haskell"?
01:39:16 <arkeet> it costs you little to do that, so why ask? ;)
01:39:51 <dv-> you might end up on a list for googling that
01:40:10 <identity> so guys, for your IO needs, pipes or conduit?
01:40:23 <arkeet> @hackage riot
01:40:23 <lambdabot> http://hackage.haskell.org/package/riot
01:41:27 <linduxed> arkeet: thx
01:42:03 <mm_freak> linduxed: let me duckduckgo that for you =)
01:42:07 <mm_freak> https://duckduckgo.com/?q=riot%20haskell
01:42:31 <johnw> identity: i'll be one to say conduit
01:42:32 <arkeet> ddg doesn't give the relevant result.
01:42:40 <arkeet> wait.
01:42:41 <arkeet> I'm blind.
01:42:46 <arkeet> ugh
01:42:59 <identity> johnw: That was the one I was looking at as well, thanks. I'll just go with conduit
01:43:19 <johnw> conduit has been in production use for years now; the dust on pipes is still settling
01:43:22 <linduxed> mm_freak: i tend to use ddg for its bang keywords
01:43:28 <ion> ditto
01:43:33 <johnw> my recommendation could change in the years to come, of course :)
01:43:34 <linduxed> mm_freak: !hayoo, !aur, !hackage
01:43:48 <mm_freak> arkeet: ddg usually gives the relevant results at the top…  it's great for searching for concrete names =)
01:44:02 <ion> I do a lot of my web searching using Google because of the superior search results, so i type “!g …” in the address bar. :-P
01:44:16 <arkeet> mm_freak: it put it in a small box which I instinctively ignored
01:44:19 <mm_freak> linduxed: ddg is my main search engine now, with occasional fallback to google =)
01:44:27 <arkeet> =(
01:44:32 * arkeet uses google for everything
01:44:35 <mm_freak> arkeet: because google has trained you to ignore them =)
01:44:36 <arkeet> everything!
01:44:40 <arkeet> haha
01:44:59 <arkeet> still, it could stand out more.
01:45:02 <arkeet> maybe if they didn't put it in a box.
01:45:13 <arkeet> a collapsible one, at that.
01:45:29 <arkeet> ok, enough offtopicness.
01:45:32 <arkeet> bye
01:46:08 <mm_freak> =)
01:49:01 <zol> What's the difference between Int and Integer?
01:49:10 <johnw> Int is bounded at 32 or 64 bits
01:50:21 <johnw> it's odd that I don't miss unsigned integers in Haskell
01:50:38 <sie> Where did you need them?
01:50:43 <johnw> i used to have to always think "Do I want this unsigned?" in C++, but now I never even think about it
01:50:56 <johnw> well, for counting anything that should never be negative
01:50:59 <zol> johnw: and Integer has no bounds..?
01:51:21 <johnw> zol: well, system memory
01:51:28 <zol> johnw: obviously. :)
01:51:43 <Cale> (fwiw, there is Data.Word for unsigned things)
01:51:46 <johnw> but yeah, count as high as you like
01:51:49 <johnw> Cale: true!
01:52:10 <johnw> they just aren't accepted everywhere that American Express is
01:52:27 <mm_freak> dv-: http://lpaste.net/95130
01:52:37 <mm_freak> that's what vty code looks like (without vty-ui)
01:53:41 <linduxed> mm_freak: that example you gave
01:53:52 <linduxed> mm_freak: it should have "values" instead of "value"
01:54:20 <mm_freak> linduxed: 'value'
01:54:28 <mm_freak> 'values' is deprecated
01:54:41 <mm_freak> i'm using sodium 0.9
01:54:42 <linduxed> well, value didn't work
01:54:44 <linduxed> ooooh
01:54:50 <linduxed> it installed 0.8.x for me
01:54:57 <mm_freak> =)
01:55:51 <linduxed> weird though
01:56:04 <linduxed> i did "cab install sodium", shouldn't that install the latest version?
01:56:14 <linduxed> or does it go for the latest stable or something like that
01:56:40 <johnw> did you cabal update?
01:56:45 <linduxed> nope
01:56:51 <linduxed> could be that
01:56:56 <linduxed> :-P
01:56:58 <johnw> then it will go for whatever version was up when you last did that :)
02:18:30 <zol> Any way I can improve this? http://hastebin.com/yeruvaqoxo.haskell
02:20:04 <mm_freak> zol: first you need to fix it =)
02:20:18 <mm_freak> you wrote:  data Date = Year Month Day
02:21:15 <zol> mm_freak: What's wrong with that?
02:21:24 <mm_freak> zol: the Year is the constructor name
02:21:44 <dv-> it should be data Date = Date Year Month Day
02:21:48 <zol> mm_freak: Oh, right! Thanks
02:22:22 <arkeet> better, Date = Date { year :: Int, month :: Int, day :: Int }
02:22:55 <arkeet> also
02:23:02 <arkeet> er never mind
02:23:29 <zol> I don't really use the Date type in this function, but do later on, so thanks for the feedback so far!
02:24:03 <absence> zol: you can use daysInMonths !! month instead of the last/take combo
02:24:51 <arkeet> daysPerMonth = [31, if isLeapYear then 29 else 28, 31, 30, ...]
02:24:54 <arkeet> ;)
02:25:45 <zol> arkeet: Ooh! Nice, is that considered good style?
02:25:48 <arkeet> I have no idea.
02:26:17 <raek> I'd say so
02:28:18 <absence> is there a more idiomatic way to write "func b (a1, a2, a3) = (a1 `f` False, a2 `f` True, a3 `f` b)" where b::Bool? for lists i'd use zipWith
02:29:11 <arkeet> I wish.
02:29:26 <absence> :'(
02:29:44 <arkeet> liftA2Of triple f (a1,a2,a3) (False,True,b) -- if only this existed.
02:30:26 <NickHu> Hi, how come I can't use the <- operator in a where clause of a guarded function?
02:30:39 <arkeet> because it's not an operator
02:30:43 <NickHu> Oh
02:30:45 <arkeet> it's part of the do syntax
02:30:54 <arkeet> or pattern guards
02:31:02 <NickHu> Ah, that makes much more sense
02:31:05 <absence> NickHu: maybe you're missing a "do"?
02:31:15 <NickHu> In that case, how can I do the same thing without <-?
02:31:41 <arkeet> what exactly are you trying to do?
02:32:35 <absence> arkeet: is it only a matter of implementing triple? it would probably be worth it for more readable code :)
02:32:51 <raek> zol: You could also write the function using 'where' instead of 'let'. They mean the same thing so this is just a matter of aesthetics and personal taste.
02:32:54 <arkeet> mostly the issue is liftA2Of.
02:33:07 <arkeet> I'm thinking of a lensy thing.
02:33:26 <absence> arkeet: yes i figured
02:33:34 <zol> raek: Yeah, I prefer having the functions above. :/
02:35:15 <absence> arkeet: hm, i don't suppose there are vectors with length encoded in the type in some lib? doesn't have to be a tuple since all elements are same type
02:35:36 <arkeet> I suspect there are.
02:35:41 <NickHu> arkeet: Essentially something like this: http://lpaste.net/95132
02:35:45 <adas> is there any way to install the latest version of the haskell platform on ubuntu?
02:36:02 <arkeet> adas: which ubuntu?
02:36:04 <arkeet> version
02:36:11 <adas> arkeet: 13.04
02:36:17 <arkeet> NickHu: oh... you're trying to do IO
02:36:21 <identity> adas: Yes, there is. Follow the instructions for manual installation
02:36:29 <arkeet> adas: http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04
02:36:29 <NickHu> arkeet: Mm
02:36:41 <identity> adas: Basically download ghc source and compile it, and them compile haskell-platform with ghc
02:36:43 <arkeet> NickHu: well, don't do that
02:36:44 <identity> it's pretty easy
02:37:39 <adas> Or I can install ubuntu saucy and simply apt get it
02:37:40 <adas> ?
02:38:04 <absence> NickHu: guardedFunc is pure so it can't do IO
02:38:10 <identity> adas: Reinstalling your operating system in order to avoid a couple of commands in the terminal seems pretty .. crazy
02:38:16 <identity> reinstalling/upgrading
02:38:29 <NickHu> absence: Oh, so what should I do?
02:38:59 <adas> identity: i wont be reinstalling. ill be running saucy in a VM
02:39:00 <absence> NickHu: depends on what you're going to use this for
02:39:28 <identity> adas: ah. well, I can guide you through installing the haskell platform if you want. it really is easy.
02:40:02 <adas> identity: i really woldn't mind the help seeing as i've been trying all sorts of things for the past 2 days
02:40:09 <identity> adas: oh, sure
02:40:13 <identity> adas: see pm
02:40:13 <arkeet> adas: well, start by reading the thing I linked
02:40:31 <adas> arkeet: i've already read that a couple of times by now
02:40:34 <arkeet> ok
02:40:39 <absence> NickHu: probably pass the string as parameter to guardedFunc instead
02:40:43 <raek> zol: you could also rewrite "a `mod`b == 0" into "a `divisibleBy` b" (and define divisibleBy locally in the function)
02:41:09 <arkeet> that's more typing =(
02:41:29 <raek> zol: one more comment: are you sure you want to represent the month of the year as a number in the range from 0 to 11? :-)
02:41:42 <absence> NickHu: then you can leave guardedFunc as pure (String -> Int) and perform the IO action outside guardedFunc
02:42:09 <arkeet> heh
02:42:11 <NickHu> absence: Ah, that was what I was doing before, I was just wondering if there was a neater way, thanks
02:42:14 <Cale> NickHu: guardedFunc :: IO Int; guardedFunc = do str <- testFunc; case () of _ | str == "Some string" -> 1 | otherwise -> 0 -- you could do this
02:42:14 <zol> raek: Oh, no! I think I want to make it an Enum. Thank you for the suggestions!
02:42:36 <Cale> Or:  guardedFunc = fmap (fromEnum . (== "Some string)) testFunc
02:42:42 <arkeet> data Month = January | February | ...
02:42:44 <arkeet> =(
02:42:54 <augur> ooo. and internship at galois. that'd be fun
02:43:11 <raek> zol: sorry, I see now that your original version works with month numbers 1 to 12!
02:43:13 <arkeet> (I wouldn't do that)
02:44:21 <raek> so the last/take combo could be replaced by "daysInMonths !! (month-1)" instead
02:49:45 <NickHu> Cale: I tried the first one and it gives me a parse error
02:49:58 <NickHu> What does case () of _ do?
02:50:56 <Cale> It matches the empty tuple against the pattern _ which matches anything without binding a variable
02:51:12 <Cale> It's a trick just to introduce guards
02:51:46 <Cale> > case () of _ | 25 == 5^2 -> "hello" | otherwise -> "wat"
02:51:47 <lambdabot>   "hello"
02:52:42 <augur> a hack for lispy cond!
02:52:50 <Cale> I'm not sure why you'd get a parse error
02:53:33 <Cale> NickHu: Also, it's probably a little inappropriate to call these things testFunc and guardedFunc, given that they're not functions in any way.
02:53:51 <NickHu> Cale: Yeah, the mistake I made was = instead of ->
02:54:10 <NickHu> But I get indentation errors if I try to split it across multiple lines like a normal guard
02:54:21 <augur> im tempted to apply for the galois internship but im sure im the least qualified of applicants :(
02:54:27 <augur> oh if only i had a CS background
02:56:14 <Cale> case () of
02:56:25 <Cale>   _ | cond1 -> expr1
02:56:30 <Cale>     | cond2 -> expr2
02:56:34 <Cale> etc.
02:56:38 <NickHu> Cale: Ah, thanks
03:01:28 <vervic> Hi! I'm looking for a function Integer -> [Integer]. f 3 = [0,0,0], f 4 = [0,0,0,0], f 5 = [....
03:01:43 <arkeet> f x = repeat x 0
03:01:44 <arkeet> er
03:01:45 <arkeet> replicate
03:01:46 <arkeet> not repeat.
03:02:09 * arkeet thought he'd never make that mistake after watching everyone else do it.
03:02:35 <arkeet> :t flip repeat 0
03:02:37 <lambdabot>     Couldn't match type `[a0]' with `b0 -> c0'
03:02:37 <lambdabot>     Expected type: a0 -> b0 -> c0
03:02:37 <lambdabot>       Actual type: a0 -> [a0]
03:02:39 <arkeet> ugh.
03:02:41 <arkeet> :t flip replicate 0
03:02:43 <lambdabot> Num b => Int -> [b]
03:02:53 <arkeet> :t flip replicate 0 . fromIntegral
03:02:54 <lambdabot> (Integral a, Num b) => a -> [b]
03:03:07 <vervic> ty
03:04:42 <donri> augur: i have a CS background. played a lot of CS back in the day. doesn't seem to help internship applications!
03:04:53 <augur> donri: :p
03:05:14 <augur> but it would probably put you above me in the consideration pile!
03:05:33 <donri> maybe if we're both applying to valve :p
03:05:42 <augur> man, valve
03:05:50 <AshyIsMe> haha
03:05:56 <augur> i would work for valve. like on some dialog systems or whatever
03:06:10 <Cale> Does that CS background include experience with Source?
03:06:13 <Cale> ;)
03:06:17 <donri> Cale: nope :(
03:06:37 <Cale> Oh, so really ivory tower
03:06:56 <augur> forget ivory tower, it's crystal spires here!
03:06:58 <donri> not sure i got that one
03:07:16 <augur> donri: ivory tower means abstract academic land
03:07:26 <donri> i know that
03:07:39 <augur> oh. which one then
03:07:44 <donri> oh so "so abstract there's not even any source code"?
03:07:49 <augur> oh
03:07:56 <augur> Source is Valve's game engine
03:08:02 <donri> that i know too ;)
03:08:11 <Earnestly> It still doesn't make any sense :p
03:08:12 <augur> then whats not to get!
03:08:15 <donri> i'm having trouble relating ivory tower to counter strike
03:08:39 <Cale> looks like castAR's kickstarter is going well :) http://www.kickstarter.com/projects/technicalillusions/castar-the-most-versatile-ar-and-vr-system
03:08:42 <augur> oh again. i think cale meant that if you're not working on Source, then you must be an ivory tower academic, at least from valve's perspective
03:08:59 <donri> :D
03:09:04 <Earnestly> I'm sure anyone would be impressed with your noscope dust2 B doors headshot
03:09:29 <Cale> (This is tangentially related, because Valve made the ridiculous decision to fire all the people working on it)
03:17:17 <FreeFull> Cale: Wait, Valve fired all the Source guys? What sense does that make?
03:17:43 <Cale> FreeFull: no, they fired the people working on castAR
03:18:01 <Cale> FreeFull: But they at least had the good sense to give them the rights to it
03:18:13 <Cale> (rather than just not doing anything with the technology)
03:19:17 <Cale> (i.e. Jeri Ellsworth and Rick Johnson)
03:23:21 <arkeet> looks neat
03:24:14 <GeoffSK> Can some show me an simple example of how to define an array, using IArray
03:24:55 <arkeet> :t array
03:24:56 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
03:25:26 <arkeet> use that.
03:25:42 <GeoffSK> newbie warning, ican't avoid type errors.
03:25:43 <arkeet> http://hackage.haskell.org/package/array-0.4.0.1/docs/Data-Array-IArray.html
03:26:05 <GeoffSK> array ((1,1),(2,2)) [((i,j),0) | i <- [1,2], j <- [1..2]]
03:26:41 <arkeet> sure
03:26:42 <FreeFull> > array (0, 25) (zip [0..25] ['a'..])
03:26:43 <lambdabot>   array (0,25) [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h...
03:27:31 <GeoffSK> that gives me errors
03:27:44 <FreeFull> What error do you get? No instance?
03:27:50 <GeoffSK> yep
03:27:56 <arkeet> ambiguous type?
03:28:02 <identity> okay, so I'm really liking conduits
03:28:21 <FreeFull> That's because you need to specify the type for Show to know how to display your array
03:28:22 <identity> last time i even tried one of these libraries, it was iteratees etc.. this is a gigantic stet up
03:28:24 <arkeet> if so, just add some type annotations.
03:28:25 <identity> step up
03:28:30 <GeoffSK> two possible fixed, ambiguous and  instance
03:29:03 <FreeFull> Try  array (0, 25) (zip [0..25] ['a'..]) :: Array Int Char
03:29:21 <GeoffSK> perfect. thanks.
03:29:34 <arkeet> or, for the thing GeoffSK originally wrote, say Array (Int,Int) Int
03:30:00 <GeoffSK> which (of course) now works.
03:30:14 <FreeFull> If you just use Data.Array instead of Data.Array.IArray, then you won't need to specify any types since it won't be using a class
03:30:26 <arkeet> if you see "ambiguous type", generally the fix is to add some type annotations.
03:30:35 <GeoffSK> docs says i should use IArray.
03:31:34 <FreeFull> It just says that IArray is more general
03:31:58 <FreeFull> If you don't need the generality, don't use it
03:32:21 <GeoffSK> good point.
03:33:51 <FreeFull> Try  array (0, 25) (zip [0..25] ['a'..]) :: UArray Int Char
03:33:54 <FreeFull> Wait
03:33:59 <FreeFull> I meant to give that to lambdabot
03:34:02 <FreeFull> > array (0, 25) (zip [0..25] ['a'..]) :: UArray Int Char
03:34:04 <lambdabot>   Not in scope: type constructor or class `UArray'
03:34:04 <lambdabot>  Perhaps you meant `Array'...
03:34:13 <FreeFull> Yeah, lambdabot just uses Data.Array
03:35:08 <arkeet> > array (0, 25) (zip [0..25] ['a'..]) :: Data.Array.Unboxed.UArray Int Char
03:35:10 <lambdabot>   Not in scope: type constructor or class `Data.Array.Unboxed.UArray'
03:36:01 <teneen> if I use Data.Text.Lazy to read a very large file (10's of GBs), and then traverse this file and do some processing. At the end will the whole file be in memory?
03:36:44 <srhb> teneen: Depends.
03:37:32 <teneen> srhb: could you elaborate please
03:38:14 <srhb> tnks: It's not sufficient to use Data.Text.Lazy, the way you process the data (and write it back again) will need to be nice about it as well
03:39:31 <srhb> teneen: If you mean to ask whether it's _possible_ to do almost space-constant processing of Data.Text.Lazy, then the answer is yes. :)
03:40:14 <teneen> srhb: I will use Data.Text.hGetContents
03:40:33 <identity> hmm. Using conduits, how would I go about sending something downstream before entering an infinite processing loop?
03:40:49 <identity> if I just use yield before the processing, it replaces the current stream, so to speak
03:42:53 <donri> identity: i don't follow
03:43:22 <identity> donri: imagine a scenario where I connect to a server, send some authentication, then enter an infinite processing loop
03:43:59 <identity> I'm doing something like: appSource $= lines $= sendAuth $= infiniteLoop $= appSink
03:44:29 <identity> if my sendAuth just does "yield authData" that replaces the source, so to speak
03:44:31 <donri> identity: don't you want vertical composition
03:44:39 <identity> donri: i'm not sure what I want, heh
03:44:51 <identity> I don't know enough about conduit to know what I want
03:45:14 <donri> to be quite honest i don't really know conduit either, i'm thinking in pipes terms
03:45:19 <donri> but i imagine it's similar
03:45:26 <identity> possibly
03:45:36 <donri> (appSource >> sendAuth) $= ... ?
03:46:49 <identity> hmm
03:47:27 <donri> ie. it's when you compose monadically that yields don't replace each other, but "stack up"
03:49:09 <teneen> srhb: is hGetContents a good way?
03:50:42 <donri> teneen: don't think that's enough, since it'll build up one Text that still needs to have everything before it
03:50:50 <donri> teneen: you probably want something like pipes for this
03:51:18 <srhb> teneen: It's possible to do it with Data.Text.Lazy and Data.Text.Lazy.IO. As long as the consumers are nice I imagine it's fine.
03:51:46 <teneen> donri, srhb: If I read and process it line by line will it work?
03:51:53 <teneen> in constant space
03:52:25 <donri> teneen: maybe. lazy IO is devious though
03:52:28 <srhb> teneen: Try.
04:17:15 <augur> is there a good tutorial for getting and using the current version of quickcheck?
04:18:30 <lpaste> srhb pasted “echoing master” at http://lpaste.net/95136
04:18:56 <srhb> So I'm still struggling with this problem. Whenever I enter a line, it is immediately echoed back before the result of the command
04:20:50 <AshyIsMe> is there a way to split a list into separate arguments for a function?
04:21:18 <AshyIsMe> eg :: a -> a -> b
04:21:22 <srhb> AshyIsMe: An arbitrary list?
04:21:35 <AshyIsMe> eg (splitme [42, 1234])
04:21:40 <AshyIsMe> something like that?
04:21:45 <srhb> AshyIsMe: No, nor would you want it
04:22:10 <srhb> AshyIsMe: But you can always do (\[a,b] -> f a b) [42,1234]
04:22:10 <AshyIsMe> hmm
04:22:27 <srhb> AshyIsMe: You should probably not be using lists that way, though.
04:22:36 <sie> fmap's type is: "fmap :: Functor f => (a -> b) -> f a -> f b" That menas that it will return "b"s, but the prefixed f implied the b must have f type class implemented, correct?
04:22:57 <srhb> sie: No.
04:23:12 <AshyIsMe> ok cheers srhb, i'll rethink
04:23:59 <srhb> sie: Consider fmap g [a] - the type of the a's are irrelevant (as long as g :: a -> b)
04:24:20 <srhb> is irrelevant**
04:24:30 <sie> Okay.
04:25:18 <srhb> sie: The thing that is the functor is exactly the 'f' in the type signature
04:26:13 <srhb> sie: For instance, here's a list-specialized version: fmap :: (a -> b) -> [] a -> [] b
04:26:54 <AshyIsMe> srhb: so i have 6 strings that i want to convert to Double and then pass through to a data constructor
04:28:41 <srhb> AshyIsMe: You will have to pattern match on them all. ie let [a,b,c,d,e,f] = map read str :: [Double] -- note that this is unsafe for several reasons
04:29:04 <srhb> Wow, what nonsense
04:29:15 <srhb> Split it in words first ^^
04:29:31 <srhb> Or wait, you had six strings
04:29:34 <ski> or perpaps use `reads' to split
04:29:46 <ski> s/paps/haps/
04:33:39 <ski> > runStateT (do [a,b,c,d,e,f] <- replicateM 6 (StateT (reads :: ReadS Double)); return ((,,,,,) a b c d e f)) "2 3 5 7 11 13"
04:33:41 <lambdabot>   [((2.0,3.0,5.0,7.0,11.0,13.0),"")]
04:33:53 <ski> replace `(,,,,,)' with whatever your data constructor is
04:33:57 <ski> AshyIsMe ^
04:34:34 <ski> that is, in case you really had one string containing the numerals, at the start, like above
04:34:46 <ski> > runStateT (do [a,b,c,d,e,f] <- replicateM 6 (StateT (reads :: ReadS Double)); return ((,,,,,) a b c d e f)) "2 3 5 7 11"
04:34:48 <lambdabot>   []
04:34:52 <ski> > runStateT (do [a,b,c,d,e,f] <- replicateM 6 (StateT (reads :: ReadS Double)); return ((,,,,,) a b c d e f)) "2 3 5 7 11 False"
04:34:54 <lambdabot>   []
04:35:11 <ski> is what happens when there's a parse error (missing or wrong data)
04:35:16 <pyr> hello haskellers
04:35:33 <pyr> I'm trying to find out if its possible to integrate ghc in automake
04:35:35 <AshyIsMe> ah sweet, cheers
04:35:42 <pyr> I would like for ghc to be able to produce .la files
04:36:04 <pyr> (I'm building a dynamic library for an existing project with ghc)
04:36:24 <ski> AshyIsMe : wrapping `ReadS' into `StateT String []' is a nice trick
04:36:26 <pyr> do you guys know of any existing projects doing the same ?
04:36:34 <AshyIsMe> ah actually i think srhb's first answer works well for what im doing
04:36:34 <ski> there's also `ReadP' or something like that in a lib
04:36:56 <ski> AshyIsMe : except that you can't then catch parse failure easily
04:37:05 <AshyIsMe> ah ok
04:37:14 <ski> @hoogle ReadP
04:37:15 <lambdabot> Prelude readParen :: Bool -> ReadS a -> ReadS a
04:37:15 <lambdabot> Text.Read readParen :: Bool -> ReadS a -> ReadS a
04:37:15 <lambdabot> Text.ParserCombinators.ReadP data ReadP a
04:41:41 <AshyIsMe> cheers ski, more reading for me :)
04:41:58 <ski> > mapM (\s -> case (reads :: ReadS Double) s of [(a,"")] -> Just a; _ -> Nothing) ["2","3","5","7","11","13"]
04:42:00 <lambdabot>   Just [2.0,3.0,5.0,7.0,11.0,13.0]
04:42:02 <ski> > mapM (\s -> case (reads :: ReadS Double) s of [(a,"")] -> Just a; _ -> Nothing) ["2","3","5  ","7","11","13"]
04:42:04 <lambdabot>   Nothing
04:42:05 <ski> > mapM (\s0 -> listToMaybe [a | (a,s1) <- (reads :: ReadS Double) s0 , ("","") <- lex s1]) ["2","3","5","7","11","13"]
04:42:07 <lambdabot>   Just [2.0,3.0,5.0,7.0,11.0,13.0]
04:42:08 <ski> > mapM (\s0 -> listToMaybe [a | (a,s1) <- (reads :: ReadS Double) s0 , ("","") <- lex s1]) ["2","3","5  ","7","11","13"]
04:42:10 <lambdabot>   Just [2.0,3.0,5.0,7.0,11.0,13.0]
04:42:13 <ski> AshyIsMe ^
04:42:52 <ski> AshyIsMe : the `mapM' here is just used to turn a `[Maybe Double]' into a `Maybe [Double]', aborting to `Nothing' if any element was `Nothing'
04:43:24 <ski> the former version can be used in case there's no extra spaces at the end of the string
04:43:41 <ski> if you want to parse successfully even in such case, you can use the latter
04:44:00 <AshyIsMe> thanks heaps
04:44:35 <Cale> pyr: um, maybe you could write a .la file yourself, it just seems like a text configuration file, but I'm not totally sure why you'd need one
04:44:36 <ski> and of course it would make sense to give a name to the lambda, here
04:45:47 <ski> AshyIsMe : anyway, `reads' (and `readsPrec') is the basic parsing primitive for the class `Read' -- it can be used to good effect, but may be somewhat involved to use directly
04:46:06 <ski> hence wrapping it behind a helper function may be useful
04:47:08 <DanielDiaz> how do I parallelize computations in the ST monad?
04:47:52 <donri> ("1","2","3") & each %~ read :: (Double,Double,Double)
04:47:58 <donri> > ("1","2","3") & each %~ read :: (Double,Double,Double)
04:48:00 <lambdabot>   (1.0,2.0,3.0)
04:48:32 <donri> DanielDiaz: as with any pure code
04:48:55 <donri> eg. use par or strategies
04:49:01 <pyr> Cale: you're right, could probably do that
04:49:19 <ski> DanielDiaz : do you mean paralellize, or just not execute in a fixed sequential order ?
04:49:51 <Cale> pyr: It doesn't seem like shared libraries appear to need .la files these days. Most of the libraries in my /usr/lib don't have them anymore.
04:50:07 <pyr> Cale: ok
04:50:24 <pyr> Cale: just need to figure out the automake magic to build with ghc then
04:50:44 <Cale> Yeah, I've never tried that :)
04:50:47 <mm_freak> Cale: .la is mostly a libtool artifact
04:51:05 <pyr> if anyone is familiar with automake building ghc stuff then i'm all ears
04:51:30 <DanielDiaz> donri: I mean two computations that can be performed in parallel. "beg >> comp1 >> comp2 >> end" where comp1 and comp2 are computations only depending on data from "beg"
04:51:31 <Eduard_Munteanu> Interesting... I think you can make an interesting (exo-)comonad this way: make State a category and define the Stream comonad on it, where 'data Stream a = Cons a (Stream a)'.
04:51:53 <DanielDiaz> donri: I didn't use correct notation, but you know what I mean.
04:52:10 <Eduard_Munteanu> You end up with   extract :: State (Stream a) a   which makes it some sort of supply.
04:52:27 <donri> DanielDiaz: i'm not sure that can be done safely
04:52:36 <mm_freak> DanielDiaz: ST doesn't support parallelism
04:52:38 <Eduard_Munteanu> Is this a known thing?
04:52:38 <Cale> DanielDiaz: You largely don't parallelise stuff in ST.
04:52:59 <Cale> If it's possible to use runST, then you could apply runST and use par
04:53:13 <Cale> (but that's not going to be possible in general)
04:53:43 <mm_freak> DanielDiaz: the other option is to use monad-par, possibly in combination with ST
04:54:16 <donri> DanielDiaz: ST pretty much relies on sequential execution enforced by the monad to be observably pure
04:54:21 <DanielDiaz> donri, mm_freak, Cale: OK, thank you. Maybe I can run two runST...
04:54:50 <donri> yes, but you can't share e.g. STRefs between them
04:54:50 <DanielDiaz> gotcha
04:55:26 <DanielDiaz> donri: yes, I know about that, thank you.
04:56:44 <donri> okies :)
04:57:25 <ski> DanielDiaz : i'm not sure there's any nice way to do it. perhaps you could use `unsafeSTToIO' and then spawn threads
04:59:04 <DanielDiaz> ski: but then I can't go back to the ST monad right? or unsafeIOToST is OK with spawning threads?
05:00:27 <Eduard_Munteanu> They should allow some notion of forkST, perhaps a STM for ST too.
05:00:33 <bz> import qualified Text.Parsec as P; let  t = P.Parsec String u => "Failed to load interface for `P'"
05:00:51 <bz> but parsec-3.1.3 shows up in "ghc-pkg list"
05:01:25 <Eduard_Munteanu> Since forking threads isn't really different from allocating memory or such things, purity-wise.
05:01:33 <ski> DanielDiaz : I think it's ok, as long as you make painstakingly sure that regardless of which concurrent interleaving or parallel execution of threads is performed, the end result will still be the same (and won't depend on or modify any other part of the I/O state, of course)
05:02:28 <ski> DanielDiaz : but, i think this has to be determined from case to case, hence there's no `forkST' (there might still be something like a `unsafeForkST', like there is an `unsafeInterleaveST', iow with proof obligations for the programmer)
05:03:00 <DanielDiaz> ski: OK, I'm looking into it.
05:03:03 <DanielDiaz> thank you
05:03:24 <ski> DanielDiaz : of course, to be useful, you will need to communicate information back from the forked thread, somehow
05:03:51 <ski> probably by using an `MVar', i'd say
05:04:05 <ski> (an `IVar' could perhaps be nicer)
05:04:27 <edwardk> Eduard_Munteanu: exocomonad?
05:04:39 <ski> @hackage data-ivar
05:04:40 <lambdabot> http://hackage.haskell.org/package/data-ivar
05:04:42 <DanielDiaz> ski: to thatp oint... is it a crazy idea to get rid of the ST monad and just use IO and unsafeperformIO?
05:04:43 <ski> @hackage ivar-simple
05:04:43 <lambdabot> http://hackage.haskell.org/package/ivar-simple
05:04:45 <Eduard_Munteanu> ski: the simplest implementation could sequence forked threads such that writes to common storage occur sequentially, I guess.
05:05:08 <Eduard_Munteanu> edwardk: just a comonad on some other category, I've seen "exofunctor" used in Haskell's context somewhere
05:05:14 <ski> DanielDiaz : using `ST' provides the reader with added clue that this only does internal computation, no interaction
05:05:19 <edwardk> a
05:05:45 <ski> "make State a category" -- the Kleisli category ?
05:05:57 <DanielDiaz> ski: ok.
05:06:05 <Eduard_Munteanu> ski: no, Category State
05:06:27 <ski> Eduard_Munteanu : which is ?
05:06:37 <lpaste> identity pasted “Conduit question” at http://lpaste.net/95137
05:06:39 <bz> ugh
05:06:40 <bz> nvm
05:06:46 <Eduard_Munteanu> id :: State s s; id = State $ \s -> (s, s)
05:06:49 <identity> I would be very grateful if someone could take a look at the code pasted above
05:09:08 <Eduard_Munteanu> (.) :: State b c -> State a b -> State a c; (State g) . (State f) = State $ \a -> let (b, _) = f a in g b
05:09:13 <ski>   State g . State f = State (\a0 -> let (b,a1) = f a0; (c,_) = g b in (c,a1))  -- ?
05:09:53 <Eduard_Munteanu> :t \(State g) (State f) = State $ \a -> let (b, _) = f a in g b
05:09:55 <lambdabot> parse error on input `='
05:10:01 <Eduard_Munteanu> :t \(State g) (State f) -> State $ \a -> let (b, _) = f a in g b
05:10:02 <lambdabot>     Not in scope: data constructor `State'
05:10:03 <lambdabot>     Perhaps you meant `StateT' (imported from Control.Monad.State)
05:10:03 <lambdabot>     Not in scope: data constructor `State'
05:10:08 <Eduard_Munteanu> Argh, StateT.
05:11:06 <Eduard_Munteanu> ski: yes, yours is correct I think
05:11:39 <ski> @type let MkState g . MkState f = MkState (\a0 -> let (a1,b) = f a0; (_,c) = g b in (a1,c)) in (.)
05:11:41 <lambdabot> L.State t1 a -> L.State t t1 -> L.State t a
05:11:42 <ski> @type let MkState g . MkState f = MkState (\a -> let (_,b) = f a in g b) in (.)
05:11:43 <lambdabot> L.State t a -> L.State t t -> L.State t a
05:12:07 <ski> the `_' looks strange
05:12:20 <Eduard_Munteanu> Yeah, that was wrong.
05:12:21 * ski recalls pondering this system some years ago
05:12:36 <ski> Eduard_Munteanu : well, both my and your version includes a `_' :)
05:12:45 <Eduard_Munteanu> I meant mine. :)
05:12:54 * ski meant both
05:15:14 * hackagebot helm 0.5.0 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.5.0 (ZackCorr)
05:15:52 <Eduard_Munteanu> ski: actually that's f >> g in some form, there's nothing to compose about the result type unless you also e.g. add a Reader to that.
05:16:56 <Eduard_Munteanu> Er, no, wait.
05:17:57 <chrisdone> now hulk's client handling code is all in a pure RWS monad, i can write unit tests and maybe even quickcheck properties for it =)
05:18:21 <Eduard_Munteanu> Oh... I see. You're feeding the output of the first as the state of the second, it's not at all like (>>).
05:21:27 <ski> Eduard_Munteanu : itym `f >>> g'
05:21:45 <ski> oh, *nod*
05:22:30 <Eduard_Munteanu> ski: anyway, if you have that, you can define  xmap :: State a b -> State (Stream a) (Stream b)  xmap (State f) = State (fmap (fst . f))
05:22:54 <Eduard_Munteanu> Making Stream a functor in State.
05:24:16 <Eduard_Munteanu> And then  extract :: State (Stream a) a   extract = State (head &&& tail)
05:27:18 <Eduard_Munteanu> duplicate :: State (Stream a) (Stream (Stream a)); duplicate = State (id &&& tails)
05:28:39 <Eduard_Munteanu> Er,  duplicate = State (tails &&& id)
05:29:42 <ski> and it satisfies the laws ?
05:30:19 <Eduard_Munteanu> I'm still thinking about that... but given it's a lot like the Stream comonad, it seems possible.
05:30:46 <Eduard_Munteanu> (that being   extract = head   duplicate = tails)
05:32:54 <ski> btw, `s -> (a,s)' is reminiscent of `s -> (a,a -> s)'
05:33:18 <lpaste> blueonyx annotated “Conduit question” with “Conduit question (annotation)” at http://lpaste.net/95137#a95139
05:33:29 <edwardk> Eduard_Munteanu: note duplicate = tails isn't quite right, notice tails changes 'shape' by adding one element
05:33:32 <Eduard_Munteanu> ski: hmmm, I was thinking of Store earlier, in that form it does look streamish
05:33:33 <edwardk> you need to drop the []
05:33:36 <edwardk> > tails [1,2,3]
05:33:38 <lambdabot>   [[1,2,3],[2,3],[3],[]]
05:33:42 <edwardk> > init $ tails [1,2,3]
05:33:44 <lambdabot>   [[1,2,3],[2,3],[3]]
05:33:50 <edwardk> that is duplicate
05:33:52 <ski> sounds likely
05:35:16 <Eduard_Munteanu> edwardk: er, but don't you want to get something like   zipWith (++) inits tails ~ id   from extract and duplicate?
05:35:38 <Eduard_Munteanu> edwardk: oh duh, you're right, extract gives you 1 element
05:36:31 <ski> > liftA2 (zipWith (++)) inits tails "abc"
05:36:32 <lambdabot>   ["abc","abc","abc","abc"]
05:36:33 <haasn> edwardk: Hey hey
05:38:18 <Eduard_Munteanu> edwardk: wait, it doesn't matter... Streams are infinite
05:38:35 <Eduard_Munteanu> So init . tails ~ tails
05:39:41 <ski> > (init . tails) [0 ..]
05:39:43 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
05:40:00 <ski> > (map (take 4) . init . tails) [0 ..]
05:40:01 <lambdabot>   [[0,1,2,3],[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8...
05:44:36 <seanparsons> Anyone using SublimeHaskell?
05:45:13 <seanparsons> Getting a terrifying linking error with a yesod project and I can't find out for the life of me what the plugin is executing.
05:50:29 <Eduard_Munteanu> extract . duplicate = extract . (State $ \s -> (tails s, id s)) = State $ \s -> (head (tails s), tail s) = State $ \s -> (s, tail s)
05:50:40 <Eduard_Munteanu> So my id was wrong.
05:52:08 <Eduard_Munteanu> Actually I'm not sure.
05:59:11 <pyr> alright, even without fitting stuff in automake, I'm still a bit stumped
05:59:19 <pyr> I can't seem to produce a valid .so file from ghc
06:00:19 <pyr> my technique is to build all objects (C an haskell) with: ghc -c -fPIC -O object
06:00:56 <pyr> then try to link everything together with: ghc -v -dynamic -shared c $OBJECTS -o $DYNLIB.so
06:02:10 <pyr> this fails, saying: /usr/bin/ld: collectd.o: relocation R_X86_64_PC32 against undefined symbol `ghczmprim_GHCziTypes_Dzh_con_info' can not be used when making a shared object; recompile with -fPIC
06:12:05 <yc4891> \q
06:12:16 <Eduard_Munteanu> "duplicate = State $ \s -> (tails s, Cons (head s) s" gives (extract . duplicate) = id
06:12:22 <Eduard_Munteanu> But it seems a bit dubious.
06:12:50 <Eduard_Munteanu> Oh!
06:14:17 <Eduard_Munteanu> We can think of "extract" and "duplicate" as being "read" and "pushback"
06:14:47 <Eduard_Munteanu> ski: does the above seem reasonable?
06:16:46 <Eduard_Munteanu> Hrm, though I'm merely pushing back the head, not a previous element.
06:17:00 <Eduard_Munteanu> (needs moar state?)
06:29:16 <haasn> > inits $ tails [1,2,3]
06:29:17 <lambdabot>   [[],[[1,2,3]],[[1,2,3],[2,3]],[[1,2,3],[2,3],[3]],[[1,2,3],[2,3],[3],[]]]
06:30:23 <ski> Eduard_Munteanu : not sure
06:30:58 <ski> "pushback", how ?
06:31:15 <Eduard_Munteanu> I see... I'm playing with (s -> (a, a -> s)) now.
06:31:24 <Eduard_Munteanu> ski: like C's getc() and ungetc()
06:32:40 <osa1> I want a `flip map` in prelude :S
06:33:05 <ski> @let pam = flip map
06:33:06 <lambdabot>  Defined.
06:33:13 <Eduard_Munteanu> osa1: you can use (<$>)
06:33:23 <osa1> um .. how ?
06:33:32 <ski> > [0,1,2,3] `pam` \x -> [0 .. x] `pam` \y -> (a,y)
06:33:36 <lambdabot>   [[(a,0)],[(a,0),(a,1)],[(a,0),(a,1),(a,2)],[(a,0),(a,1),(a,2),(a,3)]]
06:33:41 <ski> > [0,1,2,3] `pam` \x -> [0 .. x] `pam` \y -> (x,y)
06:33:46 <lambdabot>   [[(0,0)],[(1,0),(1,1)],[(2,0),(2,1),(2,2)],[(3,0),(3,1),(3,2),(3,3)]]
06:34:07 <osa1> yeah, this.
06:34:13 <osa1> Eduard_Munteanu: how can I use <$> for this?
06:34:19 <Eduard_Munteanu> osa1: er, I was thinking of something else.
06:34:23 <osa1> okay
06:34:49 <Eduard_Munteanu> osa1: you can say   (`map` xs) f  if you want something like   flip map xs f
06:35:18 <osa1> Eduard_Munteanu: chaining maps would still be a problem with this approach
06:35:26 <ski> > (`map` [0,1,2,3]) $ \x -> (`map` [0 .. x]) $ \y -> (x,y)
06:35:28 <lambdabot>   [[(0,0)],[(1,0),(1,1)],[(2,0),(2,1),(2,2)],[(3,0),(3,1),(3,2),(3,3)]]
06:36:01 <ski> osa1 : chaining ?
06:36:13 <osa1> collection argument should be in rightmost position
06:36:32 <ski> which collection ?
06:36:37 <osa1> list
06:36:38 <ski> `[0,1,2,3]' ?
06:37:28 <ski> > map (\x -> [0 .. x] `pam` \y -> (x,y)) [0,1,2,3]  -- like this ?
06:37:32 <lambdabot>   [[(0,0)],[(1,0),(1,1)],[(2,0),(2,1),(2,2)],[(3,0),(3,1),(3,2),(3,3)]]
06:37:48 * ski isn't quite sure what osa1 wanted
06:39:49 <Eduard_Munteanu> ski: what do you call (s -> (a, a -> s))?
06:40:32 <ski> Eduard_Munteanu : a lens ?
06:40:38 <ski> afternoon, esap
06:40:52 <esap> afternoon
06:41:00 <Eduard_Munteanu> Oh, hm.
06:41:28 <esap> I just computed sqrt(-1) using newton's method and got 1.5564342192667386 as result :-)
06:41:51 <vervic> Hi! Is there a fast way to "convert" a  Maybe Int  into  Int ??
06:42:04 <Eduard_Munteanu> :t fromMaybe   -- vervic
06:42:05 <lambdabot> a -> Maybe a -> a
06:43:01 <vervic> Eduard_Munteanu: ty
06:43:19 <Eduard_Munteanu> :t maybe  -- vervic, also this one
06:43:20 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:44:44 <ski> > 1.5564342192667386^2
06:44:45 <lambdabot>   2.422487478904462
06:45:21 <ski> vervic : in either case, you must decide what result to give in cases there's only `Nothing'
06:45:42 <esap> ski: I can get an infinite stream of rationals out of that computation. It starts with:  % 1,1 % 3,(-19) % 35,1711 % 4329,4938200971 % 4803879805,8958875352561055266375567908191 % 6618340806270136113731673615657 ...
06:46:00 <vervic> ski: i am aware of that issue. ty
06:46:16 <Eduard_Munteanu> esap: how does an infinite stream of rational approximate a complex number? :)
06:46:21 <ski> esap : does it appear to converge ?
06:47:25 <esap> ski: yes it looks like that but computation seems pretty slow after some time. I tried squaring it and didn't get convergence to -1 though.
06:48:00 <ski> > fromRational (8958875352561055266375567908191 % 6618340806270136113731673615657) :: Double
06:48:01 <lambdabot>   1.3536437023722812
06:52:06 <chrisdone> is there a code quality tool that scans your project and checks things like unused libraries, unused modules, uncommented definitions, non-strict records, unused exports, etc.?
06:52:14 <esap> basically I'm representing infinitesimals by the sequence s_n = 1/(2^n), then computing derivates with that.
06:54:13 <dmwit> chrisdone: hlint, catch, -Wall are the tools I know
06:54:26 <dmwit> chrisdone: -Wall will tell you about unused imports (is that what you meant by unused modules?)
06:54:42 <dmwit> chrisdone: And haddock will complain about exports with no documentation if you ask it to.
06:54:46 <chrisdone> no, i meant unused modules e.g. files in the project that are no longer imported
06:54:58 <dmwit> aha
06:55:36 <ski> esap : hm, "representing infinitesimals" ?
06:55:46 <ski> related to dual numbers or automatic differentiation ?
06:55:54 <esap> because the limit of that sequence would be an infinitesimal
06:56:13 <teneen> do the unused parts of a very large vector get garbage-collected similar to lists?
06:56:23 <ski> hm, or perhaps you just mean computing `(f (x + h) - f x) / h' for various `h', perhaps in that sequence
06:56:44 <esap> ski: yes
06:56:58 <chrisdone> dmwit: nod. it might be nice to have one command like 'check' that runs all these tools project-wide using their library APIs and spits out a summary and todo list of things that need fixing
06:57:19 <dmwit> chrisdone: right
06:58:04 <dmwit> teneen: I expect that if a large vector is reachable, all its elements are reachable, too.
06:58:11 <dmwit> (and reachable things don't get collected)
06:58:14 <chrisdone> i know that Cabal itself has some code to figure out the actual dependencies a project needs, excluding the redundant ones specified in the cabal file
06:58:43 <ski> esap : did you see "Functional Differentiation of Computer Programs" by Jerzy Karczmarczuk in 2001 at <https://karczmarczuk.users.greyc.fr/arpap/> ?
06:58:45 <teneen> dmwit: Is this the same for Texts and ByteStrings?
06:58:58 <dmwit> teneen: Texts, ByteStrings, lists, you name it.
06:59:06 <chrisdone> unused modules is a harder one. though perhaps it can be done by simply compiling the whole project and seeing which modules aren't compiled by ghc
06:59:25 <chrisdone> and unused exports seems hardest of all
06:59:30 <esap> ski: no I didn't see that. Thanks for the link.
06:59:55 <teneen> dmwit: The issue is in lists the initial parts can get collected while keeping the next parts perfectly accessible
07:00:09 <chrisdone> e.g. if i have module (Foo,bar) where … i want to be told “bar is not actually used in your project at all [and thus can probably be removed]”
07:00:12 <teneen> dmwit: But Texts, vectors etc. do not have this feature, do they?
07:00:21 <dmwit> I don't know.
07:00:25 <dmwit> I don't use them much.
07:00:33 <dmwit> But I would be surprised if they didn't have a deep copy available somewhere.
07:01:00 <dmwit> Deep copy the slice you want to retain, and you get essentially the same feature.
07:01:08 <chrisdone> bytesstring has a clone function
07:01:36 <teneen> "iterate (+1) n !! 10000000000" should work in constant space. But does "Vector.interateN 10000000000 (+1) n"?
07:02:02 <dmwit> I doubt very much that iterate (+1) n !! 100000000000 works in constant space.
07:02:19 <dmwit> Have you tested this hypothesis?
07:03:20 <chrisdone> hm… it *should* work in constant space
07:03:23 <FreeFull> I think it would build up a lot of applications of +1
07:03:31 <dmwit> chrisdone: Laziness! BOOM
07:03:39 <chrisdone> true, the +1 would not be
07:04:01 <FreeFull> > iterate (+1) 0 !! 100000000000
07:04:03 <Chousuke> it would not work at all, causing problems
07:04:09 <lambdabot>  Terminated
07:04:10 <chrisdone> but it's the +1 that's the problem, the list itself should be traversed in constant space, i think
07:04:11 <Chousuke> lazy thing :P
07:04:23 <FreeFull> Well, there is only one way to find out
07:04:35 <dmwit> Yes, the list is traversed in constant space, I agree.
07:04:57 <FreeFull> It's not constant space in ghci
07:05:09 <ski> esap : edwardk also have an Automatic Differentiation package
07:05:11 <dmwit> e.g. repeat 0 !! n should be constant space.
07:05:12 <ski> @hackage ad
07:05:12 <lambdabot> http://hackage.haskell.org/package/ad
07:05:28 <dmwit> But then it's not as clear what the Vector equivalent should be. =)
07:05:29 <FreeFull> iterate (+1) isn't in ghci
07:05:32 <teneen> I thought with optimizations enabled it will strictify the individual cells in the list
07:05:36 <Chousuke> it's kind of amusing how haskell semantics means the implementations often do a tremendous amount of work to avoid doing anything
07:05:44 <FreeFull> I'd think the Vector equivalent might be constant space though
07:06:24 <dmwit> teneen: Not here, at least.
07:06:40 <dmwit> teneen: With -O2 I get a stack overflow, which tells me it's building up a deep thunk.
07:07:00 <chrisdone> i think because the expression isn't actually strict in the number
07:07:17 <chrisdone> you might never evaluate the number, so making it strict would have premature forcing
07:07:34 <teneen> dmwit: Ok maybe this assumption was wrong. Let's say I meant "[0..100000000000] !! n" compared to "Vector.enumFromTo 0 100000000000000 ! n"
07:07:40 <dmwit> chrisdone: I put "main = print (f 100000)", so it should be pretty straightforward to notice strictness.
07:08:20 <dmwit> teneen: What I'm trying to say is: why not just test it?
07:08:29 <dmwit> Throw it at GHC and see!
07:09:10 <dmwit> teneen: (But the microbenchmarks you're suggesting don't seem related to the original question you asked, really.)
07:10:38 <teneen> The question was you can traverse and process a list in constant space while for vector the whole vector should be in memory. I'm trying it now.
07:11:12 <jmcarthur> teneen: with optimizations the vector version should be constant space too
07:11:22 <chrisdone> dmwit: i'm not sure it's straight-forward to recognise the strictness there
07:11:44 <dmwit> chrisdone: Okay, I believe you!
07:11:52 <dmwit> I don't have a very good feel for what is obviously strict and what isn't.
07:12:30 <dmwit> teneen: Okay, I reread your original question. Apparently my memory was playing tricks on me and remembering things that didn't happen.
07:12:54 <dmwit> So the answer is "sometimes". The vector guys worked pretty hard to get fusion-y things to happen when you build and then immediately consume vectors.
07:13:49 <dmwit> (But that's all done statically.)
07:14:04 <chrisdone> main = print (iterate' (+1) 0 !! 100000000000)
07:14:04 <chrisdone> iterate' :: (a -> a) -> a -> [a]
07:14:04 <chrisdone> iterate' f x =  x `seq` (x : iterate' f (f x))
07:14:07 <chrisdone> ^ this does run in constant space
07:14:14 <chrisdone> (predictably)
07:14:33 <dmwit> right
07:14:36 <Cale> You could also use  strictList = foldr (\x xs -> x `seq` (x:xs)) []  on the list produced by ordinary iterate
07:14:42 <Cale> (before applying !!)
07:14:48 <chrisdone> Cale: right
07:15:26 <teneen> dmwit: The vector version runs in constant space too.
07:16:08 <Cale> Though, maybe the more sensible version of that would be  strictList = foldr (\x xs -> x : (x `seq` xs)) []
07:16:10 <teneen> dmwit: I always think of vectors as arrays and that's why I though they should be always stored whole in memory
07:16:26 <chrisdone> Cale: does it make a difference?
07:16:34 <Cale> i.e. if you opt to look at the tail, you're forced at that point to evaluate the head
07:16:46 <chrisdone> yeah
07:16:52 <Cale> (It doesn't make a difference for this use-case though)
07:19:31 <teneen> What about Data.Text? If I'm traversing a very large text can parts of it be garbage collected?
07:19:54 <dmwit> I don't think as much work has been done for fusion in text. Though I'm not confident.
07:20:21 <dmwit> It's a lot less common to build Text's algorithmically.
07:20:21 <chrisdone> brian has put some work into fusion for text
07:21:45 <teneen> dmwit: It's just a very large file I'm reading. So I'm wondering if I can read the whole file lazily using getContents and process it somehow. Will the whole file be in memory
07:22:05 <teneen> Alternatively I think If I read line by line it should be fin.
07:22:12 <teneen> fine.
07:22:45 <chrisdone> text has a lazy and a strict version, so you can use the lazy version
07:23:22 <chrisdone> whether it garbage collects unused chunks, i'm not sure, would have to look at the code and test it
07:24:43 <teneen> I'll try it out
07:25:13 <dmwit> Probably, like in ByteString, a lazy Text is a list of strict Texts.
07:26:43 <dmwit> data Text = Empty | Chunk {-# UNPACK #-} !T.Text Text -- so, yup, isomorphic to a list of strict Texts
07:28:21 <chrisdone> but how big are the chunks?
07:29:13 <dmwit> Dunno. As you say, you'd have to look at the source, e.g. for readFile.
07:29:38 <chrisdone> seems to be  16384
07:29:45 <dmwit> Probably they are as big as a page on whatever machine the author used to optimize them. ;-)
07:29:57 <chrisdone> http://hackage.haskell.org/package/text-0.11.3.1/docs/src/Data-Text-Lazy-IO.html#hGetContents
07:30:07 <dmwit> I was going to guess in the 4K range, so yeah, 16K doesn't surprise me much. =)
07:30:17 <chrisdone> but you have to specifically set the block buffering
07:30:35 <chrisdone> (so remember to do that)
07:31:22 <teneen> that's nice
07:32:55 <dmwit> Are you sure?
07:33:06 <chrisdone> about which bit?
07:33:43 <dmwit> I see that it chooses a 16K buffer for block buffering when you don't ask for a size.
07:33:48 <dmwit> Are you sure the blocks it reads fill that buffer?
07:35:25 <dmwit> (modulo EOF, of course, not going to quibble there)
07:35:39 <chrisdone> you mean does it read the whole block buffer into a chunk?
07:35:42 <chrisdone> dunno
07:37:50 <dmwit> http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-IO-Handle-Internals.html =(
07:37:57 <dmwit> anyway
07:37:57 <chrisdone> yeah, i got there too
07:38:02 <chrisdone> seems implied
07:38:07 <dmwit> indeed
07:42:41 <osa1> my haskell program has libffi as dynamic dependency, is there a way to statically link libffi to the program?
07:43:21 <chrisdone> last time i tried static linking in ghc it linked everything but libc, iirc
07:43:43 <chrisdone> did you try -static?
07:43:58 <osa1> okay, let me try
07:45:02 <osa1> chrisdone: looks like -static didn't make any difference
07:45:10 <osa1> still same list of dynamic libraries listed by ldd
07:46:26 <osa1> "-static Use static Haskell libraries" what does that mean? (from man page)
07:46:53 <osa1> well my problem is not related with Haskell libraries, it's related with native libraries
07:47:41 <chrisdone> ah, my bad, it wasn't -static
07:47:48 <pyr> ok, so all my attempts at building dynamic libraries fail, saying I am lacking -fPIC
07:47:49 <osa1> this post looks related http://stackoverflow.com/questions/5953199/create-a-static-haskell-linux-executable
07:47:50 <chrisdone> -optl-static
07:48:30 <chrisdone> see http://stackoverflow.com/questions/14270177/ghc-statically-linking-linux-binaries-for-arm-mips-processors
07:48:57 <osa1> interesting, some of the parameters mentioned in my link are not documented in man page
07:50:16 <osa1> okay, apparently my executable is no longer dynamically linked. let me run it on remote machine
07:50:32 <osa1> \o/
07:50:43 <chrisdone> \o/
07:51:22 <osa1> it's size got ~5mb bigger
07:51:59 <chrisdone> sure =)
07:52:17 <chrisdone> though strip might shave off a few KB
07:52:27 <osa1> pyr: well, I think -fPIC is kind of standard when compiling against native libraries ..
07:52:45 <pyr> osa1: yup, i do provide fPIC
07:52:54 <osa1> pyr: I remember having to use that when linking a C library to my C++ library ..
07:53:12 <pyr> osa1: but the linking step still complains it cannot relocate symbols
07:53:21 <osa1> pyr: but then it works fine?
07:53:24 <pyr> nope
07:53:27 <osa1> ah
07:53:28 <pyr> it won't produce a .so
07:53:34 <pyr> my build steps are like so:
07:53:50 <pyr> ghc -c -O -fPIC module1.hs
07:53:58 <pyr> ghc -c -O -fPIC module2.hs (built from hsc2hs)
07:54:01 <osa1> whoa
07:54:07 <pyr> ghc -c -O -fPIC module3.c
07:54:18 <osa1> chrisdone: strip removed 6.1mb from executable, and it still works o_O
07:54:23 <chrisdone> osa1: =)
07:54:30 <osa1> ... how can this be ??
07:54:40 <geekosaur> you should see what strip does for c++ sometime :)
07:54:54 <osa1> seriously .. what kind of magic is this?
07:54:54 <pyr> and then ghc -v -no-hs-main -shared $(OBJECTS) -o mylib.so
07:55:02 <osa1> geekosaur: what does it do on c++ programs?
07:55:05 <geekosaur> strip just removes symbol tables and debugging information
07:55:34 <osa1> geekosaur: so GHC adds lots of symbols for debugging purposes by default?
07:55:39 <geekosaur> since modern C++ is template heavy, the type information in the debug information is often bigger than the object code
07:56:07 <chrisdone> osa1: ghc, but also libgmp, libc, libpthread, i think
07:56:23 <osa1> aha, that makes sense.
07:56:27 <geekosaur> not ghc /per se/, it's mostly added by the linker
07:57:08 <osa1> so does strip guarantee that resulting executable runs same?
07:57:15 <osa1> or can it break programs?
07:57:47 <geekosaur> it could possibly break programs that introspect themselves; this is unusual though (ghc doesn't do it, possibly some odd uses of hint/plugins might though)
07:58:22 <pyr> osa1: you can't have a useful gdb anymore
07:58:25 <geekosaur> alos, even then strip should not remove the dynamic symbol information
07:58:30 <pyr> osa1: that's your main drawback
07:58:35 <osa1> yeah
07:58:41 <geekosaur> ...gdb is not exactly useful on ghc generated executables anyway :)
07:58:44 <pyr> yup
07:58:51 <pyr> hence, strip should be safe
08:00:06 <geekosaur> there might be some link options (sadly, not portable) that ghc could use to not let useless symbol information get into the final executable
08:00:18 <geekosaur> the "not portable" part may be why ghc doesn't
08:00:42 <geekosaur> but -optL-s might be of interest
08:00:51 <geekosaur> (I think that's right, hold on)
08:01:20 <elliott> iirc strip has broken ghc executables in the past
08:01:57 --- mode: ChanServ set +o geekosaur
08:02:44 --- mode: geekosaur set +b mrsolo!mrsolo@c-50-148-169-160.hsd1.ca.comcast.net$##fix_your_connection
08:02:48 --- mode: geekosaur set -o geekosaur
08:03:02 <chrisdone> geekosaur: didn't work?
08:03:10 <geekosaur> sighm got it wrong it seems
08:03:20 <geekosaur> I always have to look it up and usually get it wrong anyway
08:03:24 --- mode: ChanServ set +o geekosaur
08:03:28 <osa1> is there a way to run parallel haskell program scaled through CPUs without manually passing +RTS -Nn -RTS ?
08:03:32 --- mode: geekosaur set -b mrsolo!mrsolo@c-50-148-169-160.hsd1.ca.comcast.net$##fix_your_connection
08:04:08 <dmwit> Yes, you can set the number of capabilities at runtime these days.
08:04:10 <triliyn> osa1: I think there's a way to set RTS flags from within a program
08:04:16 <chrisdone> osa1: http://hackage.haskell.org/package/base-4.5.1.0/docs/GHC-Conc.html#v:setNumCapabilities
08:04:20 <osa1> thanks
08:04:22 --- mode: geekosaur set +b mrsolo!*@*$##fix_your_connection
08:04:31 <dmwit> chrisdone++ for linking the actual function
08:04:38 <osa1> great, getNumProcessors >>= setNumCapabilities should work
08:04:52 --- mode: geekosaur set -o geekosaur
08:05:01 <triliyn> "GHC notes: in the current implementation, the value may only be increased, not decreased, by calling setNumCapabilities."
08:05:03 <triliyn> That is weird
08:05:04 <frxx> wasn't there a way to specify this during compilation?
08:05:11 * osa1 just realized his i7 processor has actually 2 cores
08:05:32 <geekosaur> -rtsopts -with-rtsopts=-N (maybe?)
08:05:41 <dmwit> triliyn: It's less weird the more you know about capabilities. =)
08:05:56 <triliyn> dmwit: yeah, probably
08:06:10 <triliyn> I know nothing about them, so it's weird to me
08:06:43 <dmwit> That restriction is lifted in the most recent GHCs, anyway.
08:07:11 <chrisdone> probably someone couldn't be bothered writing the case to bring threads back onto the remaining cores
08:11:35 <chrisdone> hehe
08:11:45 <chrisdone> hulk irc server. 29 files changed, 1177 insertions(+), 1154 deletions(-)
08:11:54 <chrisdone> still works fine
08:12:30 <chrisdone> @faq can haskell help my program continue working throughout drastic refactorings?
08:12:31 <lambdabot> The answer is: Yes! Haskell can do that.
08:13:16 * ski . o O ( can i pretty please get type error slicing in Haskell ? )
08:15:05 <chrisdone> ski: what's type error slicing?
08:23:42 <osa1> I would sacrifice everything to remove null values from all languages (or at least from Java because that's currently what I have to write :p)
08:25:02 <chrisdone> osa1: and bottom from haskell? ;)
08:25:47 <osa1> heh, good point. I didn't thing about that, which indicates it was not a problem for me :-)
08:25:55 <haasn> bottom isn't observable
08:26:06 <haasn> null is
08:26:08 <osa1> what does that mean?
08:26:12 <danharaj> some bottoms are observable in IO
08:26:16 <haasn> isBottom :: a -> Bool -- ?
08:26:24 <osa1> aha
08:26:35 <haasn> bool isNull (object x) { return x == null; } // works
08:26:42 <chrisdone> which makes it more perverse than null
08:26:57 <chrisdone> you don't even know when code is going to blow up in haskell =)
08:27:12 <osa1> chrisdone: which means you can't rely on some values being bottom or not
08:27:13 <haasn> shh agda fanboy :P
08:27:52 <chrisdone> well, in ml a value is a value
08:28:22 <chrisdone> functions can throw exceptions, but once you have a value you've got one. you never have that in haskell
08:28:49 <copumpkin> come to the dark side, chrisdone
08:28:53 <copumpkin> agda beckons
08:28:57 <chrisdone> lol
08:29:06 <copumpkin> also, I am your father
08:29:07 <copumpkin> I think
08:29:09 <copumpkin> perhaps
08:29:15 <haasn> what happens if I define x = x in ML?
08:29:20 <haasn> and then try evaluating ‘x’
08:29:24 <chrisdone> copumpkin: missed out on a "GOOOD, USE YOUR AGDA"
08:29:29 <ski> haasn : you can't
08:29:35 <copumpkin> haasn: don't get to refer to yourself unless you say you want to
08:29:39 <chrisdone> http://www.theforce.net/kids/coruscant/probe_droid/palpatine.jpg
08:29:46 <copumpkin> lol
08:29:50 <copumpkin> that clearly needs an agda caption
08:30:15 <ski> haasn : neither `val rec x = x' in SML, nor `let rec x = x' in OCaml, is allowed
08:30:16 <haasn> does ML distinguish between terminating recursion and non-termination recursion like Agda etc.?
08:30:23 <ski> nope
08:30:27 <Eduard_Munteanu> Does this definition of CCCs makes sense?  class (Category cat) => CCC cat where el :: a -> cat () a; unEl :: cat () a -> a
08:30:36 <copumpkin> haasn: Agda doesn't either :P
08:30:46 <copumpkin> it distinguishes between terminating recursion and possibly-not-terminating recursion ;)
08:30:57 <haasn> fair enough :)
08:31:18 <Eduard_Munteanu> It merely lifts arrows from the terminal object; since type constructors are injective, you get all the other limits I think.
08:31:34 <ski> Eduard_Munteanu : hm, i suspect it doesn't
08:32:31 <haasn> ski: can I define something like f 0 = f 1; f 1 = f 0 ?
08:32:58 <Eduard_Munteanu> ski: what in particular?
08:33:57 <chrisdone> haasn: i wasn't implying ML was aga-esque, just strict. if you use unboxed values in ghc's flavour of haskell, you can't define recursive values there either
08:34:16 <chrisdone> haasn: (e.g. let x = x in x if x is Int# will throw a compile error)
08:34:26 <haasn> ah, okay
08:34:48 * haasn .oO( isBottom :: a -> Bool; isBottom x = x `seq` False )
08:34:55 <Eduard_Munteanu> ski: in a few more words, you can lift () merely by virtue of id. Also, if you have an 'a', you have an '() -> a' and you can lift it to 'cat () a'.
08:35:10 <Eduard_Munteanu> ( I mean id :: cat () () )
08:35:19 <SwineFlu> I'm trying to pass a function in to a function but i can't work out the right type
08:35:26 <SwineFlu> Should it be (a -> b)
08:35:45 <triliyn> haasn: but that doesn't return true if x is bottom
08:35:46 <dmwit> That depends on the function you're passing and what you're doing with it.
08:35:47 <Eduard_Munteanu> SwineFlu: it should contain an arrow, but it's not 'a -> b' generally
08:35:48 <chrisdone> SwineFlu: what is the function type you want to pass in?
08:36:00 <ski> haasn : yes, or e.g. `fun f x = f x' (SML), `let rec f x = f x' (OCaml)
08:36:00 <geekosaur> :t map
08:36:02 <lambdabot> (a -> b) -> [a] -> [b]
08:36:17 <haasn> triliyn: isBottom !x = False; isBottom _ = True -- :) Just kidding
08:37:04 <SwineFlu> chrisdone: I want to write a function that returns (f 1) + (f 2) ... (f n)
08:37:17 <SwineFlu> so I can do i with fold I just cant get the type
08:37:27 <ski> Eduard_Munteanu : i suspect that morphisms from the terminal object needn't be in isomorphism with the underlying set of the other object
08:37:53 <SwineFlu> I think it should be (a -> b) -> Int -> Int
08:38:11 <chrisdone> SwineFlu: what i tend to do when i can't work out the type of something is do baby steps, e.g.
08:38:14 <haasn> SwineFlu: if you're being monomorphic, (Int -> Int) -> Int -> Int
08:38:28 <haasn> because otherwise, what if I pass you (Float -> Double) ?
08:38:40 <haasn> You can't simply pass an Int to that :)
08:38:53 <chrisdone> :t let f = foldr undefined undefined undefined in f
08:38:54 <lambdabot> b
08:38:55 <Eduard_Munteanu> ski: ah, they aren't really, I don't require (unEl . el) == id, but I need some way to get back to Hask, because you can only define subcategories of Hask. Like ordinary categories are always Set-enriched, I suppose.
08:38:56 <chrisdone> :t let f = foldr undefined (undefined::Int) undefined in f
08:38:57 <lambdabot> Int
08:39:07 <ski> Eduard_Munteanu : let's say `cat' is such that `cat (Maybe a) (Maybe b)' is iso with `a -> b', e.g.
08:39:09 <haasn> alternatively, (a -> b) -> a -> b -- or whatever, together with the appropriate constraints on a, b that allow you to enumFromTo, fromInteger and (+)
08:39:31 <dmwit> SwineFlu: In the future, it's polite for this kind of question to post a complete (but minimal) example of the code you're trying, along with the error you're getting or a pair of input/output that it gets wrong.
08:39:49 <ski> Eduard_Munteanu : and probably also : `cat x y' where either `x' isn't of the form `Maybe a' or `y' isn't of the form `Maybe b' would be iso to `Void'
08:39:59 <SwineFlu> dmwit: noted
08:40:13 <ski> Eduard_Munteanu : then `Maybe ()' is a terminal object, no ?
08:40:13 <dmwit> SwineFlu: (Though if this results in more than a few lines, you should paste it to lpaste.org or similar instead of putting it in-channel.)
08:40:39 <chrisdone> :t let f g = foldr g (undefined::Int) (undefined :: [Int]) in f
08:40:40 <lambdabot> (Int -> Int -> Int) -> Int
08:40:42 <SwineFlu> add f n = foldr f 1 [1..n] <-- thats all the code in the func
08:40:51 <chrisdone> right
08:41:12 <SwineFlu> And it works
08:41:22 <SwineFlu> but I can't write a typeclass for it
08:41:25 <Eduard_Munteanu> ski: not really... I had Kleisli categories in mind. In those cases '()' is terminal, and el/unEl are X/runX pairs of functions for those monads, I think.
08:41:33 <SwineFlu> I've been trying for ages looking at other type classes on higher order funcs
08:44:40 <SwineFlu> Worked out my type class
08:44:41 <SwineFlu> doh
08:44:52 <haasn> SwineFlu: that's not the function you described earlier
08:45:22 <haasn> that's f 1 (f 2 (f 3 ... f n 1))...)
08:45:33 <haasn> you wanted f 1 + f 2 + f 3 ...
08:45:40 <haasn> or sum $ map f [1..n]
08:46:00 <Eduard_Munteanu> ski: er, not quite the run functions... instead e.g.  el :: s -> Kleisli (State s) () s, el = Kleisli . return    unEl :: Kleisli (State s) () s -> s; unEl (Kleisli st) = fst (st ())
08:46:46 <SwineFlu> hmm
08:46:59 <ski> @type (`evalState` ())
08:47:00 <lambdabot> State () a -> a
08:47:50 <haasn> SwineFlu: (when you say ‘type class’ do you mean ‘type’?)
08:47:56 <Eduard_Munteanu> ski: maybe it's an XY problem but I wanted to have some notion of function application to work with in the foreign category.
08:47:57 <SwineFlu> yeah
08:49:48 <Eduard_Munteanu> Oops, I repeated 's' as a State parameter too.
08:49:56 <ski> Eduard_Munteanu : hm, so an internal language
08:50:26 <ski> @type Kleisli . return
08:50:28 <lambdabot> m b -> Kleisli m a b
08:51:46 <Eduard_Munteanu> Should have been  el :: a -> Kleisli (State s) () a
08:53:03 <Eduard_Munteanu> ski: does that make the induced functor pointed? The functor induced by taking a subcategory of Hask.
08:53:22 <Eduard_Munteanu> Not sure what the proper name for that is.
08:54:02 <ski> @type \a -> Kleisli (\() -> return a)
08:54:04 <lambdabot> Monad m => b -> Kleisli m () b
08:54:12 <Eduard_Munteanu> But I figure for any S a subcategory of C, there's a functor F : C -> C such that S = Im(F).
08:54:53 <ski> Eduard_Munteanu : which subcategory / induced functor ?
08:55:19 <ski> Eduard_Munteanu : hm, could be
08:55:20 <Eduard_Munteanu> ski: AFAICT, in Haskell you can only define subcategories of Hask.
08:55:46 <ski> you can talk about subcategories of `* -> *' and so on as well, no ?
08:56:18 <Eduard_Munteanu> Oh, right, I guess so. But any 'cat :: * -> * -> *' is a subcategory of * I think.
08:56:47 <ski> needs to have `id' and `(.)' satisfying the laws, defined
08:56:52 <Eduard_Munteanu> Unless you make Category kind-polymorphic
08:57:06 <ski> s/kind/type/
08:57:07 <Eduard_Munteanu> Yeah, I meant a Category.
08:57:29 * ski is annoyed by that misnomer
08:57:38 <Eduard_Munteanu> ski: mm, I meant kind polymorphic, as in   class Category (cat :: ob -> ob -> arr)
08:57:57 <ski> that's not kind polymorphism (regardless of what it might be called in GHC docs)
08:58:12 <Eduard_Munteanu> Oh, I think I see what you mean.
08:58:29 <ski> `length' is a polymorphic value, having universal type `forall a. [a] -> Int'
08:58:36 <ski> the type itself isn't polymorphic
08:58:48 <Eduard_Munteanu> Yeah.
08:58:54 <ski> a polymorphic type would be one with universal kind, which can be instantiated at different kinds
08:59:05 <ski> like the `Category' above
09:00:29 <Eduard_Munteanu> Actually hm, I forgot CCCs have exponentials. Therefore the corresponding functor is pretty much an Applicative.
09:01:44 <BassSultan> hi guys, i am having a problem.. i am writing a function, which gets a list of Int-lists [[1,2,3],[3,2,1],...] and it should split this input in two seperate lists and return them as a tuple ([[Int]],[[Int]]). how could i add one [Int] to one of the 2 lists in the tuple? im kinda stuck :)
09:02:14 <Eduard_Munteanu> Am I wrongly assuming that if S is a subcategory of C, S = Im(F : C -> C), where F is injective, that F is closed?
09:02:55 <Eduard_Munteanu> (preserves limits and exponentials and pretty much everything else)
09:04:11 <Eduard_Munteanu> BassSultan: you can pattern-match on the pair, or use combinators like (***).
09:04:38 <Eduard_Munteanu> :t (?a:) *** id
09:04:39 <lambdabot> (?a::a) => ([a], a1) -> ([a], a1)
09:04:59 <BassSultan> Eduard_Munteanu: what does *** do?
09:05:18 <ion> @type (***) `asAppliedTo` (undefined :: a -. b)
09:05:20 <lambdabot> Not in scope: type constructor or class `-.'
09:05:27 <ion> @type (***) `asAppliedTo` (undefined :: a -> b)
09:05:29 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
09:05:33 <Eduard_Munteanu> BassSultan: (f *** g) (a, b) = (f a, g b)
09:05:33 <ion> @@ @djinn @type (***) `asAppliedTo` (undefined :: a -> b)
09:05:35 <lambdabot>  f a b (c, d) = (a c, b d)
09:05:39 * hackagebot stomp-queue 0.0.8 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.0.8 (TobiasSchoofs)
09:05:58 <ion> @@ @djinn @type (&&&) `asAppliedTo` (undefined :: a -> b)
09:05:59 <lambdabot>  f a b c = (a c, b c)
09:06:23 <Eduard_Munteanu> :t uncurry zipWith
09:06:24 <lambdabot> (a -> b -> c, [a]) -> [b] -> [c]
09:06:29 <Eduard_Munteanu> Er.
09:06:39 <Eduard_Munteanu> :t uncurry (zipWith ?f)
09:06:40 <lambdabot> (?f::a -> b -> c) => ([a], [b]) -> [c]
09:06:56 <ski> Eduard_Munteanu : "closed" meaning what here ?
09:07:03 <BassSultan> Eduard_Munteanu: do i have to import something special for that?
09:07:06 <ion> :t uncurry ((zipWith . curry) ?f)
09:07:07 <lambdabot> (?f::(a, b) -> c) => ([a], [b]) -> [c]
09:07:19 <ion> @hoogle (***)
09:07:19 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:07:23 <ski> @type uncurry . zipWith . curry
09:07:24 <Eduard_Munteanu> ski: closed functor... I've heard people mentioning that Applicatives are closed functors.
09:07:24 <lambdabot> ((a, b) -> c) -> ([a], [b]) -> [c]
09:07:41 <Eduard_Munteanu> BassSultan: Control.Arrow
09:07:55 <ski> @type \f -> map f . uncurry zip
09:07:56 <lambdabot> ((a, b1) -> b) -> ([a], [b1]) -> [b]
09:08:07 <Eduard_Munteanu> ski: it means it preserves "all" structure: products, exponentials...
09:08:55 <Eduard_Munteanu> Though personally I'm unsure what is there to preserve aside from limits and exponentials.
09:09:04 <Eduard_Munteanu> At least for Applicative.
09:10:20 <Eduard_Munteanu> Actually I don't think all functors preserve exponentials, clearly not all of them are Applicatives.
09:12:42 <BassSultan> Eduard_Munteanu: i dont really get it :( guess im too much of a beginner for that. is there no other way, like for lists [1,3,2] ++ [1,2,3] would work?
09:13:43 <Eduard_Munteanu> BassSultan: let (xs, ys) = yourFunction in (xs ++ something, ys)
09:14:37 <ion> > first (++ [42]) ([0,1,2], [3,4,5])
09:14:39 <lambdabot>   ([0,1,2,42],[3,4,5])
09:16:18 <ion> > ([0,1,2], [3,4,5]) & _1 %~ (++ [42])
09:16:21 <lambdabot>   ([0,1,2,42],[3,4,5])
09:16:53 <ski> > fmap (++ [42]) ([0,1,2], [3,4,5])
09:16:55 <lambdabot>   ([0,1,2],[3,4,5,42])
09:17:44 <ski> BassSultan : do any of the suggestions above help ?
09:18:54 <BassSultan> ski: im going to try some of them out :) but its gonna take a while :P
09:19:01 <BassSultan> but thanks for all your help
09:20:49 <Eduard_Munteanu> ski: do you think I want a CCC? It seems too much of an Applicative: pure :: a -> cat () a  (<*>) :: cat () (a -> b) -> cat a b
09:21:40 <BassSultan> ion: where is first defined/what do i have to import for that?
09:21:44 <Eduard_Munteanu> pure is like el, but (<*>) seems too much, and it seems needed to make a CCC, namely preservation of exponentials.
09:22:18 <Eduard_Munteanu> :t (uncurry ($), fmap (uncurry ($)))
09:22:19 <lambdabot> Functor f => ((b -> c, b) -> c, f (b2 -> b1, b2) -> f b1)
09:22:21 <ersran9> Hi, I'm trying to convert a character representation of a digit to an Int, and I found digitToInt function in Data.Char. Problem is, it gives exception when given a non digit. Is there a safe variant?
09:22:47 <chrisdone> :t Data.Read.readMaybe
09:22:48 <lambdabot> Couldn't find qualified module.
09:23:09 <chrisdone> can't remember what module it's in
09:23:11 <chrisdone> anyway, readMaybe
09:23:19 <chrisdone> @hoogle readMaybe
09:23:19 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
09:23:19 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
09:23:29 <ion> @hoogle first
09:23:30 <lambdabot> Data.Monoid First :: Maybe a -> First a
09:23:30 <lambdabot> Data.Monoid newtype First a
09:23:30 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
09:23:35 <chrisdone> http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Read.html#v:readMaybe
09:23:39 <ion> bassultan: ↑ Control.Arrow
09:23:58 <chrisdone> ion: arrow, your first-stop-shop for tuple manipulation =)
09:25:04 <ersran9> chrisdone: Thank you!
09:25:11 <Eduard_Munteanu> I guess a "corollary" to this discussion is not all subcategories of Hask are CCCs.
09:30:27 <Eduard_Munteanu> Remind me... is there a null category? One with no objects or arrows.
09:30:41 <hpc> data VoidCat a b
09:30:54 <Eduard_Munteanu> Ok, but is it a category in CT sense?
09:31:13 <jmcarthur> just think about the rules
09:31:30 <Eduard_Munteanu> jmcarthur: AFAICT it is, yes
09:31:30 <jmcarthur> for every object there must be an identity. no objects, so none needed.
09:31:37 <Eduard_Munteanu> Yeah.
09:31:44 <jmcarthur> and composition must be associative. trivially true
09:31:58 <hpc> wait, isn't id an arrow in every category?
09:32:14 <jmcarthur> in haskell it's a trick
09:32:20 <jmcarthur> since our id is polymorphic
09:32:28 <hpc> in CT as well though
09:32:33 <Eduard_Munteanu> Ok, so this is an exception to my previous statement: even though VoidCat is a subcategory of Hask, there's no functor that gives me that category, so no preservation of limits etc.
09:32:43 <jmcarthur> it's not really, in CT
09:32:44 <ski> Eduard_Munteanu : i don't know what you're after
09:32:50 <jmcarthur> we might pretend it is as a shorthand
09:33:04 <ski> Eduard_Munteanu : yes, there is a category with zero objects (and therefore zero morphisms)
09:33:18 <jmcarthur> the id_A is a unique morphism from id_B
09:34:12 <ski> jmcarthur : you can still think of `id : forall A in Obj. A --> A' as "polymorphic"
09:34:13 <jmcarthur> in haskell, it would be tough to define the Category instance for VoidCat
09:34:20 <jmcarthur> ski: yes
09:34:22 <Eduard_Munteanu> ski: and is it a subcategory of Hask? Because if it is, it sort of breaks limit preservation :)
09:34:27 <ski> in this case, we get `id : forall A in {}. A --> A', which is fine
09:34:38 <jmcarthur> ski: in the same way you can think of dependently typed languages as having polymorphism even if they don't
09:36:12 <ski> Eduard_Munteanu : it can clearly be viewed as a subcategory of any given category, given that the (initial) functor from it is faithful
09:36:13 <Eduard_Munteanu> Oh, I see! The void category isn't a subcategory of anything except itself. Because it doesn't preserve identities.
09:36:28 <Eduard_Munteanu> Hm.
09:36:30 <ski> jmcarthur : *nod*
09:37:52 <Eduard_Munteanu> ski: what's the basic definition for subcategories, really? Just faithful functors from S to C make S a subcategory of C?
09:38:19 <ski> Eduard_Munteanu : that's the "categorized" definition
09:38:29 <jmcarthur> Eduard_Munteanu: not sure that makes much sense to me. there are no identities to preserve, so in fact one could argue that it does trivially preserve identities
09:39:05 <jmcarthur> by that functor definition, i'm not sure what to think, though
09:39:17 <Eduard_Munteanu> For some reason I kept thinking that if S ⊆ C, then there's a functor C -> C whose image is S. Is that false?
09:39:35 <ski> Eduard_Munteanu : for a more traditional "algebraic" definition : a subcollection of the collection of objects, and for each collection of morphisms between selected objects of the former, a subcollection  (such that identity and composition of the original category is closed under these restrictions)
09:39:58 <ski> Eduard_Munteanu : what does `⊆' mean there ?
09:40:02 <Eduard_Munteanu> Ah, yeah, I have no complaints about either, I think my assumption above was faulty.
09:40:14 <Eduard_Munteanu> ski: a (possibly bad) symbol for subcategory
09:40:16 <lpaste> thevaanda pasted “Is this a bug?” at http://lpaste.net/95146
09:40:33 <ski> if it means "subcategory", then i'm not sure "if S ⊆ C, then there's a functor C -> C whose image is S" is true
09:40:43 <thevaanda> is this a bug in ghci, i use version 7.6.2, http://lpaste.net/95146 ?
09:41:25 <ski> Eduard_Munteanu : not bad if you know what "subcategory" is -- but it seemed there maybe was dissenting opinion on the meaning of that term here, which is why i asked
09:42:39 <NemesisD> hey guys, i'm getting the error Could not deduce (err ~ TrackResponseError) from type signature xmlRequest :: (ToXML req, FromXML err resp) => HTTPBackend IO (Either err resp) -> req -> IO (Either err resp)
09:42:55 <NemesisD> is there some sort of quantifier i have to add?
09:43:18 <Eduard_Munteanu> ski: I was confused :)
09:43:20 <NemesisD> i'm using the function in 1 place where it decides err to be TrackResponseError but xmlRequest shouldn't care what type error is
09:43:23 <NemesisD> err*
09:43:59 <Eduard_Munteanu> So, back to Haskell, I suppose the right way to define subcategories that preserve limits is to talk about endofunctors on Hask instead.
09:46:06 <NemesisD> oh nm i see what's going on, i'm doing something in the function that isn't fully polymorphic on err
09:48:15 <Eduard_Munteanu> So instead of  el :: a -> cat () a   I should have a functor together with gmap :: (a -> b) -> cat (f a) (f b).
09:50:23 <Eduard_Munteanu> And 'f' would preserve limits, even though limits in 'cat' generally don't coincide with Hask's.
09:50:48 <Eduard_Munteanu> Still, it's a bit annoying you can't restrict 'cat'.
09:52:28 <Eduard_Munteanu> We can pretend we have a certain kind of objects with PolyKinds.
09:53:56 <Eduard_Munteanu> e.g.  class SubCCC (cat :: ob -> ob -> arr) (f :: * -> ob) (hom :: arr -> *)   which gets a bit nasty, last time I tried.
09:54:41 <nikola> Hello, I'm stuck and I would like some help. Code works fine in ghci but fails when compiled with ghc; http://pastie.org/8452636
09:55:53 <geekosaur> that shouldn't work in ghci either
09:56:02 <geekosaur> I think
09:56:04 <geekosaur> :t (^)
09:56:05 <lambdabot> (Integral b, Num a) => a -> b -> a
09:56:14 <geekosaur> oh, hm, right
09:56:20 <Eduard_Munteanu> (you need 'hom' so you can write the types as inhabited types, e.g.  id :: hom (cat (f a) (f a))  because otherwise you'd need arr = *)
09:57:22 * Eduard_Munteanu should try doing something productive once in a while, I have some actual work to do :)
09:58:15 <geekosaur> oh, right!
09:59:07 <geekosaur> :t ceiling
09:59:08 <lambdabot> (Integral b, RealFrac a) => a -> b
09:59:24 <monochrom> please don't use ghci as the standard
09:59:30 <geekosaur> ...so *that* code is fine, but you are using it somewhere as if it were a Float
09:59:47 <geekosaur> nikola: show your full code please
10:01:22 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
10:02:06 <nikola> geekosaur: http://pastie.org/8452651 , I assume it's line 11
10:02:10 <nikola> :t (/)
10:02:12 <lambdabot> Fractional a => a -> a -> a
10:02:33 <Futho> Hello.
10:03:04 <Eduard_Munteanu> Futho: hi
10:03:04 <monochrom> perhaps (upperBound - lowerBound) / fromIntegral bitsForRepr
10:04:24 <nikola> monochrom: nope; when I remove line 11 (and putStrLn for that line) I get same error
10:05:52 <geekosaur> I think that doesn't necessarily prove anything
10:06:39 <geekosaur> suggestion: while type inference can be nice, it also can lead to errors being reported not where they actually are. give each of your top level definitions a type signature saying what you think the type should e
10:06:40 <monochrom> perhaps it's just me, but "from the use of ^" is not "same" as "from the use of ceiling"
10:06:46 <geekosaur> *be
10:07:34 <monochrom> is there a reason accuracy :: Float?
10:08:00 <timthelion> anyone here use eclipseFP?
10:08:02 <nikola> accuracy :: Int fixed it
10:08:18 <monochrom> see? not same
10:08:28 <nikola> monochrom: no, I was desparate and testing everything
10:08:31 <nikola> thanks for help!
10:08:53 <int80_h> when I use the invokation +RTS -xt -hy, I find that the most expensive cost center is MUT_ARR_PTRS_FROZEN. Could someone help me suss out how to pinpoint the culprit(s)?
10:11:53 <int80_h> Is this a problem that would be specific to the code? Or is this something that comes up when certain mistakes are made?
10:12:39 <jophish_> Is there a monadic find, which evaluates a monad on elements of a list until one returns True
10:12:45 <jophish_> and returns that element of the list
10:12:57 <jophish_> I've come up with one, but not in an elegant way
10:13:13 <Eduard_Munteanu> @hoogle findM
10:13:13 <lambdabot> Data.IntMap.Strict findMax :: IntMap a -> (Key, a)
10:13:14 <lambdabot> Data.IntMap.Lazy findMax :: IntMap a -> (Key, a)
10:13:14 <lambdabot> Data.IntSet findMax :: IntSet -> Key
10:13:21 <Eduard_Munteanu> @hoogle+
10:13:21 <lambdabot> Data.Map.Lazy findMax :: Map k a -> (k, a)
10:13:21 <lambdabot> Data.Map.Strict findMax :: Map k a -> (k, a)
10:13:21 <lambdabot> Data.Set findMax :: Set a -> a
10:13:27 <jophish_> yeah, I got nothing
10:13:38 <Eduard_Munteanu> :t sequence . find ?p
10:13:39 <lambdabot>     Couldn't match type `Maybe a1' with `[m0 a0]'
10:13:39 <lambdabot>     Expected type: [a1] -> [m0 a0]
10:13:39 <lambdabot>       Actual type: [a1] -> Maybe a1
10:13:56 <jonkri> Often when I make recursive functions, I end up with needing to reverse the result. In general, is there something I can keep in mind to avoid this?
10:14:11 <Eduard_Munteanu> :t Data.Traversable.sequence . find ?p
10:14:12 <lambdabot> (Monad m, ?p::m a -> Bool) => [m a] -> m (Maybe a)
10:14:54 <dmwit> ?hackage monad-loops
10:14:55 <lambdabot> http://hackage.haskell.org/package/monad-loops
10:15:19 <jophish_> ah, firstM
10:15:33 <jophish_> that has the correct type
10:16:04 <jophish_> hah, it's implemented exactly how I did mine
10:16:29 <dmwit> It's hard to imagine how else you would do it, really.
10:18:55 <kqr> i'm using the PortNum constructor from Network.Socket to create a PortNumber. am i supposed to turn the number inte network byte order or will that be done for me when i turn it into a Word16?
10:19:18 <Eduard_Munteanu> kqr: use fromIntegral instead
10:19:44 <kqr> oh i didn't realise portnumber was a Num
10:19:45 <Eduard_Munteanu> kqr: that takes care of converting properly, IIRC
10:19:45 <kqr> i'll try!
10:20:00 <kqr> currently i was doing PortNum $ fromIntegral 5555
10:20:27 <Eduard_Munteanu> I think PortNum takes a big-endian integer.
10:20:43 <kqr> yeah i was puzzled by that
10:20:44 <Eduard_Munteanu> s/integer/Word16/
10:20:49 <kqr> but doing fromIntegral directly worked fine
10:20:51 <kqr> thanks :)
10:21:07 <dmwit> Hell, get rid of the fromIntegral, too.
10:21:19 <dmwit> Just write "5555".
10:21:21 <kqr> right, there's an implicit one of those :D
10:21:31 <Eduard_Munteanu> Ah, yeah, it shouldn't be ambiguous.
10:21:49 <kqr> for some reason ghc seems to think 5555 should be an int
10:22:13 <kqr> Couldn't match expected type `PortNumber' with actual type `Int' In the first argument of `SockAddrInet', namely `portno'
10:22:27 <dmwit> needs more code
10:22:46 <monochrom> I think you're mixing up several issues
10:22:53 <Eduard_Munteanu> fromIntegral, as well as the implicit from
10:23:02 <Eduard_Munteanu> ... fromIntegral, expect an Integer.
10:23:15 <Eduard_Munteanu> :t fromInteger  --   err
10:23:16 <lambdabot> Num a => Integer -> a
10:23:22 <kqr> oh, sorry
10:23:23 <Eduard_Munteanu> Right, fromInteger.
10:23:26 <kqr> that was me being stupid
10:23:35 <kqr> i had bound the port number to an Int variable
10:23:49 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4 :)
10:24:15 <monochrom> @quote twitter
10:24:16 <lambdabot> hpc says: your next challenge: write a definition of fix in java that fits in a twitter post
10:24:40 <monochrom> not that one. let me find it.
10:25:06 <monochrom> @quote dmwit tweet
10:25:06 <lambdabot> dmwit says: If it fits in a tweet, you haven't included enough information to debug it yet.
10:25:10 <monochrom> :)
10:25:36 <kqr> that's a good one
10:25:51 <Hafydd> The next Twitter Interview question.
10:30:53 <augur> can you have strict semantics with lazy evaluation?
10:31:31 <Eduard_Munteanu> augur: yes
10:31:42 <skypers> hi
10:31:49 <augur> whats required to make that so, Eduard_Munteanu?
10:31:55 <skypers> is there any issues with the new cabal install?
10:31:59 <augur> probably totality
10:32:05 <skypers> I mean the command
10:32:08 <Eduard_Munteanu> augur: that the programmer assume the code can be executed strictly.
10:32:15 <augur> Eduard_Munteanu: :P
10:32:16 <skypers> well not install actually
10:32:17 <skypers> init.
10:32:26 <sclv> look up eager haskell
10:32:28 <skypers> cabal init generates a wrong .cabal file
10:32:35 <skypers> I got error on the name field
10:32:37 <augur> yes but i mean, you dont want a semantics that is only in the imagined programmers head
10:32:38 <skypers> which is
10:32:40 <Eduard_Munteanu> augur: I mean no infinite lists and so on
10:32:42 <skypers> name:    foo
10:32:43 <sclv> its "nonstrict" evaluation not strict
10:32:45 <skypers> any idea?
10:32:49 <sclv> and you can get eager semantics with it
10:32:55 <sclv> which is i assume what you want
10:32:56 <augur> Eduard_Munteanu: yes, but how to ensure that
10:32:59 <sclv> in terms of operational reasoning
10:33:08 <skypers> or maybe it’s because I put an underscore in there?
10:33:31 <augur> sclv: i want the semantics of eager evaluation with the efficiency of lazy evaluation
10:33:51 <skypers> woah sounds it was that
10:34:02 <sclv> augur: look up eager haskell its what you are interested in
10:34:08 <Eduard_Munteanu> augur: totality sort of gives you equivalence of non-strict / strict semantics.
10:34:15 <dmwit> skypers: I would say if cabal init produces invalid .cabal files that's a bug in cabal-install.
10:34:16 <augur> i suspect also you need some kind of productivity check for coinductive types
10:34:18 <sclv> i think he means operational semantics?
10:34:33 <dmwit> skypers: And you should complain on the official bug tracker. =)
10:34:35 <augur> Eduard_Munteanu: well, but the operational component doesnt, right
10:34:47 <sclv> right look up eager haskell
10:34:51 <sclv> it does exactly this
10:35:00 <augur> your denotational semantics might be strict, but once you write your evaluator, you can still write your crazy nasty lazy programs
10:35:04 <Eduard_Munteanu> augur: yeah. For instance, I've seen some complain Agda isn't lazy enough.
10:35:05 <augur> like ones = 1:ones
10:35:06 <monochrom> clearly, "strict" is denotational, "lazy" is operational
10:35:48 <Eduard_Munteanu> augur: yeah, because that's not properly typed
10:35:54 <augur> Eduard_Munteanu: sure it is
10:36:52 <augur> the real problems come from things like dead = dead
10:36:52 <Eduard_Munteanu> augur: is the type itself coinductive? Otherwise it might miss musical notation.
10:37:03 <jrmithdobbs> so as a learning exercise i'm trying to implement something i have before in ruby in haskell, pretty simple concept, basically I want to take a list of functions (in ruby it's an enumerable container of lambda Procs), store them, pass them back to the caller who then does (in ruby) eventmachine trickery to start running them all from effectively a thread pool (actually a pool of Fibers, irrelevent) and waits for specific items in order while doin
10:37:07 <augur> Eduard_Munteanu: well in agda you need music, but i mean in haskell
10:37:37 <skypers> 19:26 < dmwit> skypers: And you should complain on the official bug tracker. =)
10:37:39 <skypers> sure I will
10:37:57 <Eduard_Munteanu> augur: ah... in that case, we're moving the termination issue from the POV of the entire program to termination of individual productive steps.
10:38:01 <dmwit> jrmithdobbs: You got cut off at "specific items in order while doin", but so far nothing you said sounds too hard in Haskell.
10:38:33 <dmwit> Except that you won't need any event machine trickery. You just run them all in parallel and get thread pooling for free. =)
10:38:39 <augur> speaking of semantics, what should i read for an introduction to operational semantics?
10:38:39 <jrmithdobbs> dmwit: g other processing using em-synchrony to create callbacks to the running functions so that the processing loop can continue until it hits a value that's not ready yet
10:38:40 <Eduard_Munteanu> augur: basically you need to guarantee pattern-matching on constructors always terminates.
10:39:09 <augur> Eduard_Munteanu: so reduction to weak head normal form
10:39:18 <augur> ie some kind of productivity if we're coinductive
10:39:18 <jrmithdobbs> dmwit: ya of what I've figured out so far this seems like basically a task haskell is uniquely suited for ;p
10:39:27 <Eduard_Munteanu> But considering you have absolutely no guarantees wrt termination in plain Haskell, even the lazy one, I'd say it's fine. :)
10:39:36 <Eduard_Munteanu> Yeah.
10:39:37 <jrmithdobbs> dmwit: why i thought it'd be a good learning exercise
10:40:39 <jrmithdobbs> dmwit: the part i'm confused on is how to get them all "spun up" at once, the real-world jobs being executed do a bunch of extremely slow network api calls, the order of completion of which is non-deterministic at the begining
10:40:58 <jrmithdobbs> dmwit: but then get them back in the original order of the list
10:40:58 <dmwit> :t mapM_ forkIO
10:40:59 <lambdabot> Not in scope: `forkIO'
10:41:04 <dmwit> ?hoogle forkIO
10:41:05 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
10:41:05 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
10:41:05 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
10:41:15 <dmwit> :t mapM_ Control.Concurrent.forkIO
10:41:16 <lambdabot> [IO ()] -> IO ()
10:41:28 <monochrom> a strict language that doesn't let you have bottom is a non-strict language by vacuity
10:42:17 <monochrom> but I guess like clopen sets, we can certainly have strict non-strict languages
10:42:18 <augur> monochrom: what?
10:42:33 <Eduard_Munteanu> There are different kinds of bottoms.
10:42:37 <dmwit> augur: "strict" means "a function that's handed bottom returns bottom"
10:42:51 <Eduard_Munteanu> ones = 1:ones  vs   error "onoes"
10:42:53 <augur> dmwit: oh ok.
10:43:26 <jrmithdobbs> dmwit: so what if I need to make sure that no more than X are running at the same time? setup a thread pool consuming a queue somewhere and have the lambdas pass their values and a return queue into the pool?
10:43:33 <jrmithdobbs> dmwit: or am I overthinking again?
10:43:36 <dmwit> The denotationalist's answer to Eduard_Munteanu's latest comment is to say "nuh-uh!" and stick his tongue out.
10:43:41 <augur> Eduard_Munteanu: yes, this is a point i've made numerous times -- partiality and non-termination are not necessarily the same thing, and we fuse them into one simply because having two bottoms is inconvenient
10:44:02 <augur> dmwit: no, the denotationalists answer to Eduard_Munteanu's latest comment is "two bottoms is too hard :("
10:44:22 <dmwit> jrmithdobbs: Why not have X threads that read out of a queue of jobs or some such thing?
10:44:39 <dmwit> jrmithdobbs: Yes, essentially what you said.
10:44:48 <dmwit> jrmithdobbs: But why do you need to make sure that no more than X are running?
10:44:49 <augur> partiality yields all sorts of nasty problems, so you want to wrap all your types up in Maybe -- ie you inject bottom
10:45:20 <johnw> what do you mean by "you inject bottom"?
10:45:34 <hpc> johnw: it's all the rage in hollywood
10:45:46 <jrmithdobbs> dmwit: backend service being hit fucking sucks and can be tipped over easily because in reality of request i'm making of it is essentially causing it to do full table scans on it's dbs and load the entire thing into ram because it's a piece of shit ;p
10:45:48 <dmwit> Maybe is different than bottom. You're allowed to pattern-match on Maybes...
10:45:53 <augur> but non-termination is also a nasty problem. indeed, far nastier, because while partial things have denotations -- partial functions -- what does a non-terminating thing have as its denotation? technically it can have any denotation, but you want to pick a special one so you add a new bottom
10:45:59 <jrmithdobbs> dmwit: and fixing said service is not an option atm
10:46:04 <triliyn> johnw: I think "whenever you'd otherwise have a bottom, you instead have Nothing; and whenever you'd have a non-bottom, you instead have Just something"
10:46:12 <dmwit> jrmithdobbs: bummer =)
10:46:27 <monochrom> I have seen two bottoms. well, one of them is still above the other. for example Wadler and Hughes "projections for strictness analysis"
10:46:32 <johnw> triliyn: well, that's removing the possibility of bottom and making the function total; I don't see how that "injects" bottom
10:46:35 <augur> dmwit: no no, im not saying maybe is the same as bottom, im saying that the semantics of A_\bot is the same as Maybe A (modulo the bottoms in A and Maybe A)
10:47:05 <timthelion> Is emacs+flymake usably fast?
10:47:07 <loadedanvils> how to make case statement execute IO and output false?
10:47:08 <dmwit> But my point is that they're not.
10:47:13 <johnw> timthelion: flycheck is much better
10:47:18 <augur> johnw: by inject bottom i mean you take A to A_\bot = A \union {\bot}
10:47:23 <dmwit> Because Nothing is not less than Just _ in Maybe A, but \bot is less than Just _ in A_\bot.
10:47:26 <johnw> timthelion: and with hdevtools, it's *blindingly* fast
10:47:26 <augur> dmwit: uh.. they are tho
10:47:33 <timthelion> johnw: does it do the same thing?
10:47:39 <geekosaur> loadedanvils, it must return IO False
10:47:39 <johnw> timthelion: it does more
10:47:44 <jrmithdobbs> dmwit: i'm going rogue you see, our ruby code that does all of this has major perf walls due to the interpretter, but the only reason we're forced into interfacing with it with ruby is that's the internal libs we have to do so ... replace libs, then the service, then dumb the vendor, <3 haskell ;p
10:47:50 <geekosaur> or rather, IO Bool, value `return False`
10:47:55 <johnw> timthelion: and is pretty easily extensible
10:47:59 <timthelion> johnw: I hope it doesn't automatically apply hlint sugestions ;)
10:48:01 <loadedanvils> geekosaur: the IO can't return false, I just want to output false
10:48:01 <monochrom> it seems to me, in order for "let x=1:x in x" be non-bottom, you need "(1 :)" to be non-strict.
10:48:03 <augur> dmwit: sure, in Maybe A, this is true, because we dont define an ordering for Maybe A normally
10:48:04 <jrmithdobbs> s/dumb/dump/
10:48:07 <Eduard_Munteanu> Also, not being able to prove something terminates is a different kind of bottom from "it spins forever" and again different from "it crashes".
10:48:07 <dmwit> jrmithdobbs: I wish you luck. =)
10:48:13 <augur> dmwit: but we can easily define an Ord instance
10:48:20 <geekosaur> loadedanvils, then you are doing it wrong. if you;re going to do IO, you must be *in* IO
10:48:27 <dmwit> augur: I'm talking semantic order, not Ord. Obviously.
10:48:33 <Eduard_Munteanu> Just like untypeable programs aren't all the same.
10:48:35 <triliyn> loadedanvils: return False is an IO action that does nothing and has false as its value
10:48:43 <ClaudiusMaximus> @hackage spawn -- jrmithdobbs
10:48:43 <lambdabot> http://hackage.haskell.org/package/spawn -- jrmithdobbs
10:48:43 <johnw> augur: I still don't get what you mean, are you equating Nothing with ⊥ in some context?
10:48:46 <triliyn> (If you give it the type IO Bool)
10:48:52 <augur> dmwit: yes i know but im obviously using haskell as convenience
10:48:55 <timthelion> johnw: does emacs have some kind of outline mode for haskell(where I can view a list of funciton names in the file and use that list for navigation?)
10:48:56 <loadedanvils> case x of {0 -> True; _ -> do {putStrLn "hee"; return False}}
10:49:00 <dmwit> augur: In the "for this function to be meaningful, it must take higher things in the semantic lattice to higher things in the semantic lattice" sense.
10:49:05 <loadedanvils> or something of that nature
10:49:07 <geekosaur> 0 -> return True
10:49:09 <johnw> timthelion: you can always type C-1 C-x $
10:49:15 <geekosaur> and again it must be in IO
10:49:17 <monochrom> well, you could say, the language is strict overall, but (1:) in "let x=1:x in x" is recognized and made non-strict in that context. it's what ocaml does afterall
10:49:23 <johnw> timthelion: and I think ghc-mod gives you M-x imenu
10:49:32 <geekosaur> you are not permitted to fudge this. if you use IO you must6 be in IO
10:49:34 * dmwit realizes that he doesn't really know what he's arguing against and decides to drop it
10:50:00 <Eduard_Munteanu> monochrom: there's also the case of opt-in non-strictness, I think. Can't give an example though.
10:50:00 <augur> johnw: yes. the standard semantics for A in the partiality monad is that A denotes some set [[A]] \union {\bot}
10:50:11 <augur> johnw: where [[A]] is the denotation of A in |Set
10:50:14 <timthelion> johnw: ok, I'll look at it... I've just been trying out eclipseFP(I'm normally using vim) and I like the features, but it's too slow for normal use.
10:50:28 <loadedanvils> geekosaur: I'm intending to use it to filter
10:50:34 <augur> dmwit: yes yes, just be flexible, wont you? gosh. :P
10:50:34 <johnw> timthelion: I rely on flycheck every day and am extremely happy with the result
10:50:38 <Eduard_Munteanu> E.g.  ones = 1 : lazy ones
10:50:40 <geekosaur> then you can't do I/O
10:50:44 <timthelion> johnw: I'm happy to hear that.
10:50:56 <augur> dmwit: i could try to use all the CT omega-cpo terminology but i'd get lost.
10:51:01 <geekosaur> or you can use filterM
10:51:30 <augur> dmwit: besides, we like to pretend like haskell lets us write math in code, so :P
10:51:47 <triliyn> loadedanvils: if the IO you want to use is for debug printing purposes, you can use Debug.Trace I think
10:52:26 <loadedanvils> triliyn: thanks, but filterM is fine. It's not for printing, I just used it because it was simple
10:52:37 <triliyn> ah, okay
10:54:12 <augur> dmwit: anyway, my point was that partiality and termination and technically orthogonal, but the most practical semantics of both are so similar that it's much more convenient to identify the denotations
10:54:27 <jrmithdobbs> Claudius1aximus: that looks quite helpful
10:54:45 <augur> dmwit: but often we also actually distinguish them operationally again for practical reasons
10:55:24 <augur> dmwit: you can tell that they're operationally distinguished by the fact that non-termination yields non-termination, but partiality yields a halting error-reporting program
10:55:43 <jrmithdobbs> Claudius1aximus: doesn't look like parMapIO preserves order of results though unless i'm reding wrong
10:56:17 <augur> i dont know if anyone has tried to give a proper error-monad semantics over a proper non-deterministic core
10:57:04 <Claudius1aximus> jrmithdobbs: it does preserve order, although it seems not documented explicitly (the source makes it plain - it forks everything then demands each result in turn)
10:57:09 <jrmithdobbs> oh wait yes it does i see in how it uses spawn in the call
10:57:26 <jrmithdobbs> Claudius1aximus: heh, looks like we looked at the same thing there :p
10:57:52 <jrmithdobbs> the non-determinism is referring to the normal concurrency warning stuff
10:57:58 <jrmithdobbs> bad phrasing ;p
10:58:11 <WraithM> Is there a good way to convert a Seq to a Vector?
10:58:56 <monochrom> you lump things together or distinguish things based on what you care
10:59:59 <donri> WraithM: Vector.fromListN (Seq.length xs) (Seq.toList xs)  perhaps?
11:00:25 <monochrom> Scott and Dijkstra probably just cared about program correctness. if the specification says "you must answer 5", but you don't answer 5, either because you answer 6 or you take forever or you die immediately, you are wrong. we just need to know whether you are right or you are wrong.
11:00:25 <donri> Foldable.toList, rather
11:01:32 <monochrom> a practical programmer, of course, may like to distinguish between you die immediate and you take forever. in fact, a practical programmer should lump taking forever and taking more than an hour together.
11:04:11 <Redz> is there some operator, who does: flip (:)
11:04:14 <tac> monochrom: It's those extrinsic factors that make theoretical computer science difficult to apply in real life
11:04:32 <hpc> Redz: do you really want flip (:), or perhaps some function of (++)?
11:04:33 <tac> as there are certainly many programs which necessarily take an hour to complete :)
11:04:58 <geekosaur> suspect they want something which appends a single item to a list, which is not flip (:)
11:05:17 <Redz> ++[x] seems a bit less readable. ^^
11:05:35 <Redz> oh
11:05:52 <Redz> flip (:) doesn't work, i see.
11:06:29 <geekosaur> linked lists. adding an item to the start is simple (indeed fundamental), adding one to the end is hard
11:07:08 <hpc> if you plan to be using lists as queues, try a dedicated Queue type
11:07:19 <hpc> alternatively, try Endo or double-reversing the list
11:07:26 <Redz> haskell is lazy enough to append it, when i need it. so i think, this isn't a performance issue.
11:07:46 <johnw> Redz: you could use Data.Sequence to accumulate the list, which has an O(1) snoc operation
11:08:08 <johnw> or the Endo trick
11:08:56 <monochrom> you may need not accumulate and append, in fact.
11:09:05 <edwardk> :t snoc
11:09:13 <edwardk> > [1,2,3] `snoc` 4
11:09:15 <lambdabot>   [1,2,3,4]
11:09:20 <edwardk> (using lens)
11:09:28 <edwardk> > [1,2,3] |> 4
11:09:29 <lambdabot>   [1,2,3,4]
11:09:36 <monochrom> many beginners think that "map" has to be implemented by an accumulator and keep appending. but no:
11:09:39 <monochrom> @src map
11:09:40 <lambdabot> map _ []     = []
11:09:40 <lambdabot> map f (x:xs) = f x : map f xs
11:10:17 <Redz> actually, i just look for a already existing operator for appending a single item on a list. i don't mess with optimization.
11:10:46 <jmcarthur> Redz: (++[x]) is *not* going to be as efficient as (x:)
11:12:06 <Futho> I'm trying to setup flymake-haskell-multi, but it fails to find a module for some reason. Module is located in same directory as file in current buffer... File in current buffer is a module A.B and flymake can't fine A.C.
11:12:23 <Futho> Why?
11:15:35 <wlhlm> Hi, is there someone using Haskell on Archlinux? I'm having trouble installing haskell-setenv.
11:16:08 <monochrom> Futho: I want to know the exact "ls -R" of your directory. I do not trust human narratives.
11:16:50 <Futho> monochrom: Directory of where current buffer's file resides?
11:17:36 <monochrom> no. a suitable ancestor directory.
11:19:07 <monochrom> perhaps I should just tell you some GHC requirement and maybe that solves the problem?
11:20:03 <monochrom> if you have modules A.B and A.C, then A.B should be xxx/A/B.hs, A.C should be xxx/A/C.hs, and GHC needs to be told "xxx". probably same for flymake
11:21:02 <monochrom> it is not enough to think "every file is in the same directory"
11:21:03 <Futho> monochrom: http://vpaste.net/Ft5Ld
11:21:40 <Futho> I've created minimal reproducible example.
11:21:59 <monochrom> ok, that's a right layout. so find some way to tell flymake about "monochrome-test-project" (not "monochrom-test-project/A")
11:23:24 <chrizz> hi, can someone help me restructure this code so that i don't get scoping errors http://lpaste.net/95147
11:23:38 <chrizz> and this is just a toy example of course so inlining "result" isnt an option
11:23:51 <Futho> monochrom: That seems to be tedious. I have to specify such top-level dir for every project...
11:25:07 <lpaste> monochrom annotated “No title” with “No title (annotation)” at http://lpaste.net/95147#a95148
11:25:17 <monochrom> chrizz: http://lpaste.net/95147#a95148
11:26:30 <monochrom> augur: a beginner lumps all compiler error messages into one single bottom :)
11:26:50 <chrizz> monochrom: how about this, then? http://lpaste.net/95147
11:26:51 <augur> monochrom: yes, but non-termination doesnt yield an error message :)
11:26:54 <augur> so there's nothing to lump!
11:27:18 <monochrom> yes, some even explicitly insist "I get the same error" for two distinct error messages
11:28:23 <lpaste> monochrom annotated “No title” with “No title (annotation)” at http://lpaste.net/95147#a95150
11:28:36 <monochrom> chrizz: http://lpaste.net/95147#a95150
11:28:45 <chrizz> thanks! looks funky but it works
11:28:57 <chrizz> wish I could use "where" since i prefer it to "let"
11:29:20 <monochrom> I understand. but "where" belongs to "foo arg =", not "do ..."
11:29:52 <chrizz> right
11:30:16 <chrizz> so my options are use let, or create a new function
11:31:04 <monochrom> augur: I think beginners just haven't seen how we can make GHC non-terminate :)
11:31:51 <monochrom> to a beginner, a compiler bloody terminates, the only way to get bottom is error messages
11:32:44 <monochrom> I am a friend of distinguishing error messages, but empirically beginners just look at the first 10 characters
11:34:06 <monochrom> also empirically, when I am using a C++ compiler, I too just look at the first 10 characters, or maybe the first 10 lines, or something
11:35:43 <monochrom> http://xkcd.com/303/
11:36:32 <hpc> monochrom: obvious sign of a lazy programmer
11:36:34 <khyperia> haha, it took me way too long to connect non-termination and that comic after you linked that
11:36:39 <hpc> monochrom: they should be slacking off due to unit testing instead
11:37:33 <khyperia> "Compilation time for this project is around ∞ minutes"
11:40:59 * hackagebot iff 0.0.4 - Constructing and dissecting IFF files  http://hackage.haskell.org/package/iff-0.0.4 (HenningThielemann)
11:41:01 <teneen> I wrote a haskell script which does processing on a very large file. It terminates with the message "out of memory"
11:41:08 <teneen> What's the solution to this?
11:41:15 <teneen> I tried increasing the stack size
11:41:27 <hpc> teneen: terminate it before it runs out of memory ;)
11:41:28 <teneen> and the heap size is unlmited by default
11:42:04 <johnw> teneen: the solution is to fix the memory exhaustion
11:42:18 <Futho> teneen: Try not to load very large file in not so large memory.
11:42:32 <teneen> I'm not loading it into memory
11:42:39 <teneen> I read it using lazy Data.Text
11:42:53 <teneen> and I form a very large HashMap from the values in the text
11:42:54 <Futho> teneen: Yeah, you are loading it.
11:43:11 <teneen> in the task manager I can see the process only reaches 2GB of RAM
11:43:18 <teneen> I still have plenty more free rAM
11:43:23 <teneen> why does it terminate?
11:44:16 <monochrom> teneen: show actual code. show actual file size.
11:45:51 <lpaste> teneen pasted “large file word frequency” at http://lpaste.net/95151
11:47:49 <teneen> file size is 6GB
11:48:38 <johnw> teneen: try using foldl'
11:48:57 <johnw> instead of accumulating a map, you're accumulating a bunch of insertions into the map
11:49:32 <johnw> which each one holds onto the original data from the file, so that you end up keeping all 6GB and then some in memory
11:51:00 * hackagebot iff 0.0.5 - Constructing and dissecting IFF files  http://hackage.haskell.org/package/iff-0.0.5 (HenningThielemann)
11:51:07 <teneen> I believe foldl' will have the same problem
11:51:20 <teneen> with foldl'  the list of Texts will never be garbage collected till the end
11:52:54 <johnw> how about trying it
11:56:20 <arkeet> your belief is probably wrong.
11:59:07 <arkeet> belief-driven development is usually not very good. =(
11:59:53 <Futho> I'm fleeing to common lisp.
12:00:12 <Eduard_Munteanu> What's a good name for a function 'Stream a -> Stream (a, a)'? I'm pondering 'dup'.
12:00:32 <Eduard_Munteanu> Or more generally   a -> (a, a)  .
12:00:34 <Futho> Eduard_Munteanu: double.
12:00:36 <arkeet> what does it do?
12:00:42 <arkeet> diag
12:00:44 <jmcarthur> dup sounds good for the latter
12:00:48 <arkeet> and fmap diag for the former
12:00:55 <arkeet> I dunno.
12:01:00 <Eduard_Munteanu> arkeet: no, just (id &&& id)
12:01:05 <arkeet> that's fine too.
12:01:23 <joelteon> join (,)
12:01:29 <arkeet> so is that
12:01:41 <Eduard_Munteanu> Hm, yeah.
12:01:42 <Futho> In haskell it's too time consuming doing thing you don't know much about. Each refactoring is really a pain
12:02:08 <johnw> Futho: but then you learn, and it gets easier
12:02:12 <johnw> that's pretty generally true in life
12:02:29 <johnw> "Doing something you don't know how to do is hard."
12:02:48 <hpc> much easier to do something you don't know that you don
12:02:53 <hpc> much easier to do something you don't know that you don't know how to do
12:03:07 <Eduard_Munteanu> Futho: yes, it's a bit of a pain if you don't design your code to be extensible. Which usually means making things very general / polymorphic etc., though it's not always easy.
12:04:22 <Futho> Yeah, making haskell code extensible is much harder, that positional pattern matching is awfully frustrating thing when you have to add something new to record.
12:04:29 <khyperia> Can someone explain (fmap fmap fmap) to me? I understand (fmap . fmap), but not the triple one.
12:04:56 <hpc> khyperia: (fmap fmap fmap) = (fmap `fmap` fmap)
12:05:13 <arkeet> the first fmap is (.)
12:05:13 <jrmithdobbs> haddock is so much nicer than rdoc/yard, I desere that maintainer like a case of beer
12:05:16 <hpc> khyperia: and then expand the inner fmap, which resolves to the one for (->)
12:05:16 <jrmithdobbs> s/deserve/owe/
12:05:22 <arkeet> (.) fmap fmap
12:05:22 <hpc> and then it becomes (fmap . fmap)
12:05:28 <jmcarthur> Futho: so don't use positional pattern matching on records then
12:05:36 <khyperia> oh, so it requires an instance declaration?
12:05:44 <Eduard_Munteanu> Hm, I have a 'spans :: (a -> Bool) -> Stream a -> Stream ([a], Stream a)'. I wonder if I should make a 'zpans :: ([a] -> Stream a -> b) -> Stream a -> Stream b' instead, the 'z' standing for zipper/zipWith.
12:05:44 <Futho> jmcarthur: Yep, lesson learned. :)
12:05:51 <jrmithdobbs> haddock actually takes real comments I would write, where I would actually write them, and just turns them into docs, awesome tool ;p
12:06:08 * rasfar (agrees with arkeet re. "diag")
12:07:12 <Eduard_Munteanu> I think I will, it seems like a nifty combinator.
12:07:19 <jophish_> Yo yo yo
12:07:38 <jophish_> I'm using createProcess to call another program
12:08:01 <jophish_> It's important that I wait for this process to terminate, and free the handle for stdout before returning from the monad
12:08:16 <Eduard_Munteanu> jophish_: waitForProcess?
12:08:33 <jophish_> Eduard_Munteanu: That doesn't seem to be working on its own
12:08:49 <Eduard_Munteanu> jophish_: well, are you doing lazy I/O ?
12:08:55 <jophish_> only by piping the string from stdout to stderr does it work
12:09:05 <jophish_> Eduard_Munteanu: I'd rather it wasn't lazy in this circumstance
12:09:10 <jrmithdobbs> so how do I make cabal always generate haddock?
12:09:13 <jrmithdobbs> on build/install
12:09:17 <Eduard_Munteanu> jophish_: of course, any command freezes if its stdout isn't consumed
12:09:18 <rasfar> stdout and stderr have different default buffering; maybe you need to set the buffering on stdout?
12:09:36 <arkeet> jrmithdobbs: documentation: True  in .cabal/config
12:09:37 <geekosaur> then you are doing something wrong somewhere. perhaps told it to capture stderr to a filehandle and ignored the handle, and the stderr output is larger than _PIPE_BUF?
12:09:38 <jmcarthur> jophish_: not if it only writes to stdout in a separate thread
12:09:41 <jrmithdobbs> ya stdout is line buffered by default, stderr is un
12:10:01 <geekosaur> this is not the same thing as telling it to not capture stderr
12:10:04 <jmcarthur> sorry jophish_, i meant Eduard_Munteanu
12:10:12 <jrmithdobbs> assuming haskell runtime follows the posix env it's running in anyways ;p
12:10:13 <teneen> johnw: I still get the out of memory error
12:10:24 <Eduard_Munteanu> jophish_: if you don't care about output, just tell createProcess not to make one
12:10:34 <jophish_> Eduard_Munteanu: I need to output from stdout
12:10:41 <arkeet> you're still making a pretty big HashMap
12:10:45 <jophish_> but I'm hitting an error where I can't spawn any more processes
12:10:46 <johnw> teneen: ok, that's a good data point
12:10:48 <jrmithdobbs> arkeet: thanks, is there a list of common cabal/haddock/HOW I MAKE A SANE PACKAGE faq i missed somewhere?
12:10:48 <geekosaur> but you said your problem was stderr
12:10:52 <teneen> Why can't a haskell process occupy more than 2GB RAM?
12:10:55 <jophish_> so I need to ensure that it terminates
12:11:01 <geekosaur> my guess is you told it to create a handle for stderr, then ignored it
12:11:04 <johnw> teneen: are you using a 32-bit binary?
12:11:09 <geekosaur> which very likely means it's deadlocking
12:11:09 <khyperia> hpc, arkeet: so (fmap fmap fmap) requires an instance declaration and isn't possible with just type fiddling? Or is it? I don't see how you can apply (fmap) to (fmap fmap :: f (a -> b) -> f (f1 a -> f1 b))
12:11:10 <teneen> yes
12:11:15 <johnw> well, that would be the problem
12:11:27 <arkeet> khyperia: nothing is applied to fmap fmap.
12:11:29 <Eduard_Munteanu> jophish_: if you putStr to your stdout / err / log, that gets completed before any further action is issued.
12:11:31 <arkeet> it's (fmap fmap) fmap
12:11:33 <teneen> johnw: can I cross-build to 64-bit from a 32-bit ghc?
12:11:42 <johnw> teneen: I'm pretty sure you can
12:11:44 <arkeet> khyperia: now, there's an instance Functor ((->) r) where fmap = (.)
12:11:52 <jophish_> Eduard_Munteanu: I'd rather not have to output to stderr just to flush the handle
12:12:14 <arkeet> khyperia: in order for (fmap fmap) to be applied to anything, it has to be a function.
12:12:17 <Eduard_Munteanu> jophish_: I don't get it, what are you doing with that process' stdout?
12:12:24 <arkeet> which means the first fmap is (.)
12:12:28 <arkeet> because of that instance
12:12:35 <geekosaur> jophish_, I think we need to see your code. and I also think you need to understand how this stuff works
12:12:38 <jophish_> Eduard_Munteanu: using it later in my program. It's being left unevaluated for too long
12:12:49 <jophish_> geekosaur: both good ideas
12:12:49 <geekosaur> this is not a haskell issue, it's a "don't understand the POSIX process model" problem
12:12:56 <teneen> anybody knows how to cross-build for 64-bit from a 32-bit ghc?
12:13:02 <arkeet> you don't.
12:13:06 <Eduard_Munteanu> jophish_: read it into a Text / String strictly
12:13:10 <arkeet> I think.
12:13:24 <khyperia> ... I *think* I get it, arkeet, thanks.
12:13:57 <khyperia> I haven't studied how ((->) a) or ((,) a) works yet, which would probably help me,
12:13:58 <Eduard_Munteanu> jophish_: assuming it's not very large
12:14:00 <jrmithdobbs> arkeet: you sure? adding documentation: True ; didn't run cabal haddock on cabal build
12:14:12 <arkeet> jrmithdobbs: it never does on build.
12:14:17 <arkeet> only install
12:14:22 <jrmithdobbs> ak
12:14:29 <Eduard_Munteanu> jophish_: you can't just close a handle and do lazy I/O from it, btw
12:14:43 <JesseH> Does GHC come with the haskell platform source?
12:14:43 <jrmithdobbs> arkeet: maybe a better question is, is there a way to keep cabal clean from removing dist/doc so that I can keep that in the repo?
12:14:48 <jophish_> Eduard_Munteanu: The way to do that would be something along the lines of: myStr <- id $! hGetContents hout
12:14:49 <Eduard_Munteanu> jophish_: if you do that, the output gets cut right at the moment you closed the Handle.
12:14:54 <jrmithdobbs> arkeet: (from a commit-hook, similar)
12:14:55 <jophish_> there must be a nicer way
12:15:09 <arkeet> jrmithdobbs: I don't think putting the doc in the repo is a good idea.
12:15:10 <Eduard_Munteanu> jophish_: that doesn't work, use a strict hGetContents
12:15:21 <jrmithdobbs> arkeet: i don't either but it's convention where i work ;p
12:15:29 <jrmithdobbs> arkeet: choose your battles and all that
12:15:33 <Eduard_Munteanu> Actually I forget how that's called.
12:15:35 <arkeet> bah
12:15:45 <jophish_> ah, system.IO.Strict
12:15:45 <geekosaur> JesseH: no
12:15:52 <JesseH> Okay was confused a bit
12:15:55 <jmcarthur> teneen: why are you using a 32 bit ghc on a 64 bit platform?
12:15:56 <arkeet> what I mean is that someone with a different version of haddock builds your docs and then they'll get a slightly different output and then try to commit and then oops.
12:16:10 <geekosaur> ghc itself doesn't even come with the platform. the platform binary download doesn't come with source, but there is a separate source download
12:16:24 <jmcarthur> by platform i meant machine+os
12:16:25 <teneen> jmcarthur: that's what comes with the Haskell platform on Windows :)
12:16:26 <Eduard_Munteanu> jophish_: http://hackage.haskell.org/package/text-0.11.2.0/docs/Data-Text-IO.html#g:3
12:16:40 <arkeet> jrmithdobbs: well, I would probably just copy the docs elsewhere. =(
12:16:43 <jrmithdobbs> arkeet: ya i understand, in practice doesn't matter with our workflow because only the buildbots/commit-hooks are actually running those on master/production type branches
12:16:52 <arkeet> jrmithdobbs: btw, 'cabal haddock' will build the docs.
12:16:59 <jrmithdobbs> ya
12:17:01 <arkeet> right.
12:17:11 <Eduard_Munteanu> jophish_: and should be enough on its own, no need for a ($!) etc.
12:17:20 <jophish_> Eduard_Munteanu: I'll give this a try
12:17:22 <jophish_> thanks for youe help
12:17:24 <jophish_> your*
12:17:26 <jmcarthur> ugh, the haskell platform
12:17:35 <jrmithdobbs> arkeet: well, i say "are" but tmk this will be the first haskell project thrown into the workflow, lol
12:18:00 <jophish_> hmm, cannot find System.IO.Strict
12:18:03 <jrmithdobbs> (hence the confusing questions that are antithetical to the "Right Way(tm)" the docs refer to ;p)
12:18:09 <jophish_> ancient university computers
12:18:37 <arkeet> jophish: cabal install strict?
12:18:41 <Eduard_Munteanu> jophish_: what compiler are you using?
12:18:48 <Eduard_Munteanu> I hope it's not Hugs. :)
12:19:05 <Eduard_Munteanu> Because if it is, you need a hug. :)
12:19:14 <arkeet> :)
12:19:14 <jophish_> ghc 7.0.4
12:19:18 <jrmithdobbs> speaking of different compilers, is there any eta/roadmap to getting ghc building directly with clang/llvm?
12:19:21 <Eduard_Munteanu> Hm, not bad.
12:19:26 <arkeet> not as bad as hugs :-)
12:19:28 <jrmithdobbs> doesn't there just need to be work to retrofit their cpp vs gcc's?
12:19:30 <jrmithdobbs> heh
12:20:09 <jrmithdobbs> or is the problem that llvm abstrats the cpp part of the processing in a way that doesn't work for ghc's assumptions?
12:20:37 <Eduard_Munteanu> Really, is CPP a problem? GHC merely understands a subset of that.
12:20:52 <arkeet> the cpp issue is that clang's cpp is too strict
12:20:53 <jrmithdobbs> Eduard_Munteanu: it's the problem i've heard quoted re: building with llvm
12:21:07 <jophish_> What could I use instead of IO.Strict>
12:21:08 <enthropy> ghc calls a cpp on your system
12:21:12 <gecco> hi all, i have a problem, where the compiler says: "Non-exhaustive patterns in function substitute", and i can't find where the pattern is missing. http://lpaste.net/95152
12:21:34 <arkeet> gecco: you mean substitute' ?
12:21:38 <Eduard_Munteanu> jophish_: Text for textual stuff, Bytestring for binary, both provide IO functions
12:21:43 <enthropy> gecco: the compiler should tell you what's missing
12:21:46 <jrmithdobbs> arkeet: do you know specifically which parts are too strict? Im familiar with some of the cpp differences but can't imagine what's being abused that would actually come out in this case =/
12:21:47 <geekosaur> Eduard_Munteanu, cpp is intended for C. clang's cpp understands and expects C, as required by the standard. gcc's cpp can be run in K&R mode which didn't understand C
12:21:53 <gecco> arkeet: yes sorry, its substitute'
12:21:58 <arkeet> gecco: what if the third argument is []?
12:22:06 <geekosaur> (apparently there is also a K&R mode in clang but it requires special invocaton)
12:22:16 <arkeet> (you can tell by reasoning about it that it won't be, but ghc isn't *that* smart!)
12:22:23 <Eduard_Munteanu> geekosaur: hm, I guess it gets stuck on tokenizing Haskell code properly?
12:22:30 <gecco> arkeet: ah ok, but isn't otherwise gonna catch that?
12:22:35 <arkeet> no
12:22:47 <jrmithdobbs> geekosaur: oh so the problem is ghc's use of cpp requires pre-ansi (non-standard) conventions to be followed?
12:22:57 <arkeet> guards only apply to one defining equation.
12:22:58 <geekosaur> Eduard_Munteanu, yes, it throws errors on various things that are valid Haskell but not valid C
12:23:03 <gecco> arkett: so im better up with different functions here, for patterns maybe
12:23:05 <jrmithdobbs> that actually explains it quite nicely and succintly
12:23:25 <Eduard_Munteanu> I suspect it barfs on things like  `foo`  and such.
12:23:44 <jrmithdobbs> so technically, ghc *will* build with llvm, so long as you have access to a gcc cpp binary and specify it?
12:23:52 <Eduard_Munteanu> Actually even f . g could be an issue.
12:23:58 <jophish_> Eduard_Munteanu: I don't seem to have Data.Text
12:23:58 <jrmithdobbs> does it need it post build/bootstrap to actually compile other haskell or just for building itself?
12:23:59 <geekosaur> it works with llvm-gcc, for example
12:24:32 <Eduard_Munteanu> jophish_: odd... that usually gets shipped with Haskell Platform. What OS is that?
12:24:41 <jophish_> Fedora, I thin
12:24:42 <jrmithdobbs> geekosaur: you're inspiring me to fix the homebrew recipe to not force usage of apple-gcc42
12:24:43 <jophish_> k
12:24:49 <jophish_> I'm not really surprised
12:24:54 <jrmithdobbs> or at least, try to
12:25:07 <geekosaur> jrmithdobbs, I am not sure if there is an additional issue with clang. at one point there was, I think
12:25:13 <geekosaur> or with llvm in general
12:25:21 <geekosaur> specifically with the ghc source itself
12:25:24 <Eduard_Munteanu> jophish_: hm, I see. Did you install GHC yourself? Whoever did should have installed a Haskell Platform package, these days many distros have it.
12:25:27 <jrmithdobbs> i can't imagine many post-building ghc itself
12:25:29 <jrmithdobbs> sans cpp
12:25:51 <geekosaur> you'd be surprised how much code uses {-# LANGUAGE CPP #-}
12:25:58 <jophish_> Eduard_Munteanu: It's been set up by some admin, I can try and install text locally
12:25:58 <jrmithdobbs> i'm not
12:26:09 <geekosaur> because it is in largew part the only way to do compatibility the face of changing Haskell library APIs
12:26:16 <jrmithdobbs> but LANGUAGE CPP can be worked around to use llvm-gcc for cpp
12:26:22 <jrmithdobbs> fairly trivially
12:26:25 <Eduard_Munteanu> It's like installing gcc instead of build-essentials on Debian and expecting to have all the tools. :)
12:26:34 <khyperia> I'm trying to make a type system for a language I just started, but I'm absolutely lost as to where to even begin.
12:27:00 <khyperia> Are there any "how to make a interpreter in Haskell" tutorials or something?
12:27:03 <jrmithdobbs> geekosaur: maybe some day we'll get first class macros and this conversation can be moot
12:27:08 <jrmithdobbs> geekosaur: </troll>
12:27:09 <jrmithdobbs> ;p
12:27:13 <Eduard_Munteanu> khyperia: start with a simply-typed lambda calculus
12:27:28 <arkeet> khyperia: I can think of http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
12:27:57 <Eduard_Munteanu> khyperia: conveniently, the STLC can be embedded rather nicely into Haskell with GADTs, you don't even need to write a typechecker really. :)
12:27:58 <jrmithdobbs> an interpretter is just a parser that creates functions really
12:28:25 <arkeet> Eduard_Munteanu: what if you want to do your typechecking when you *run* your compiler?
12:28:28 <arkeet> =(
12:28:45 <khyperia> I eventually want to switch from interpreter to compiled... should I even start with interpreting, or go straight to compiling?
12:28:49 <arkeet> as opposed to "embed my language in haskell"
12:28:54 <Eduard_Munteanu> arkeet: have a TH splice generate an AST and compile that :P
12:28:57 <arkeet> no!
12:30:13 * arkeet an interpreter is a trivial compiler together with a big runtime system
12:30:45 <gecco> arkeet: here it's again, now it works, any more suggestions? http://lpaste.net/95152
12:30:54 <arkeet> yes. what's cs?
12:31:20 <arkeet> more importantly, I suggest you rewrite the whole thing to be more like a right fold instead of a left one. appending repeatedly to the end of a list is really bad.
12:31:32 <gecco> arkeet: a typo, have it on two computers, its xs in the code
12:31:40 <arkeet> ok
12:32:05 <arkeet> you should check for more typos.
12:32:12 <arkeet> because I'm sure there is at least one.
12:32:22 <arkeet> maybe copy and paste the code.
12:33:50 <gecco> arkeet: now its copied from the editor... sorry for the trouble
12:35:19 <timthelion> johnw: flycheck which you recomended is part of scion? Or installed separately..
12:36:12 <arkeet> gecco: ok, here's an example of what I mean:
12:36:14 <johnw> separately
12:36:37 <timthelion> johnw: OK, scion looks like it's too old to be installable on debian stable :P
12:36:44 <johnw> i never got scion to work
12:38:37 * timthelion this world is filled with the stench of dead and rotting code :/
12:38:57 <arkeet> gecco: say you're implementing map.
12:38:57 <arkeet> :t map
12:38:59 <lambdabot> (a -> b) -> [a] -> [b]
12:39:11 <arkeet> well, let me just paste it.
12:39:21 <johnw> timthelion: it fertilizes future efforts :)
12:39:27 <lpaste> arkeet pasted “two ways to write map” at http://lpaste.net/95157
12:39:35 <arkeet> thanks hlint.
12:40:11 <arkeet> gecco: first of all, do these make sense? (feel free to ignore the foldl/foldr parts if those don't)
12:40:28 <JesseH> ghc is required to build ghc? O_o
12:40:37 <arkeet> yes. (ghc is written in haskell)
12:40:47 <timthelion> JesseH: Eat your own dog food.
12:41:08 <JesseH> I'm trying to get into haskell and its already proving rather interesting. :P
12:41:14 <arkeet> :)
12:41:45 <sbrother> have any of you guys worked with the Euterpea computer music library?
12:42:44 <arkeet> I have not, but have you heard of the Haskell School of Music?
12:42:55 <sbrother> absolutely, i'm working through it :)
12:43:00 <arkeet> figures. :)
12:43:05 <jophish_> Eduard_Munteanu: Using Data.Text.IO and calling waitForProcess after getcontents works great
12:43:08 <jophish_> Thanks
12:43:25 <Eduard_Munteanu> Nice.
12:43:25 <JesseH> Not sure what i'm going to do then, because SliTaz doesnt have GHC :P
12:43:29 <sbrother> just having some weird midi issues - not really appropriate for this channel but i figured if someone had already gone through them it would be nice
12:43:34 <arkeet> JesseH: go get a ghc binary.
12:43:45 <JesseH> Wait I can create tazpkg packages with rpms
12:45:28 <JesseH> or i could just get a binary like arkeet said
12:45:39 <arkeet> most people have no need to compile ghc.
12:45:43 <jrmithdobbs> what does this mean? http://lpaste.net/4401052958146428928
12:45:51 * JesseH wonders what its gonna be like when he actually starts on the book
12:47:00 <jrmithdobbs> was: import qualified Data.ByteString.Lazy as LB ; LB.putStrLn $ aLazyByteString
12:47:46 <jrmithdobbs> i'm not relying on ascii, that should be utf8 encoded the way it's getting passed to me ...
12:48:11 <arkeet> you are relying on ascii, for newline being [0x10] is ascii.
12:48:47 <jrmithdobbs> oic
12:50:28 <jrmithdobbs> so i really want (as an option) do LB.putStr t ; putCar '\n'
12:50:30 <jrmithdobbs> or similar
12:51:07 <justinleitgeb> I'm either encountering a weird bug with Data.Map.member, or am doing something stupid. Can anyone help? https://gist.github.com/jsl/7294493
12:51:09 <jrmithdobbs> or to properly have it endcoded in the original string before putStr
12:52:50 <briennetheblue> well i know why i was getting so confused over f-algebra now... i was muddling the functors List and (ListF a) :(
12:54:07 <arkeet> a common mixup.
12:57:06 <justinleitgeb> Ugh, I think serialization is doing something strange. https://gist.github.com/jsl/7294493
12:57:23 <srhb> I'm looking at the ioctl package and wondering how to use System.Posix.IOCtl.ioctl to actually send TIOCSCTTY. Any pointers?
12:57:38 <justinleitgeb> why would Data.Map.fromList $ Data.Map.toList "unbreak" a Map ?
12:59:57 <jrmithdobbs> haha, :edit --help giving back $VISUAL's help output was surprising
13:06:36 <rasfar> srhb: no idea, but have you checked out http://stackoverflow.com/questions/12806053/get-terminal-width-haskell or http://pastebin.com/bLH8wsiY ? might give some ideas...
13:06:51 <mauke> The paste bLH8wsiY has been copied to http://lpaste.net/95158
13:08:30 <srhb> rasfar: Hairy stuff! Thank you.
13:08:49 <ski> Eduard_Munteanu : heh, i wouldn't call Hugs a compiler :)
13:08:49 <rasfar> yeah, i didn't realise it would involve FFI necessarily
13:09:35 <srhb> rasfar: It must at some point since I guess it's a very specific system call, I'm just surprised it's missing from the unix package
13:09:44 <srhb> Since it appears to be absolutely vital to creating a terminal emulator.
13:10:14 <Eduard_Munteanu> Count Hugs "The Compiler"... a legend.
13:11:31 <geekosaur> I am not sure that ioctl package is the way to go though
13:11:55 <srhb> geekosaur: Oh?
13:12:19 <geekosaur> just the paucity of documentation makes me think it's not a very well thought out package
13:12:26 <ski> @where haskel
13:12:27 <lambdabot> <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif>
13:12:40 <srhb> geekosaur: Hm, yes..
13:12:49 <ski> srhb : how fares your quest ?
13:13:22 <srhb> ski: Poorly. But well, I've found some reference C code to guide me. Unfortunately some of the system calls I need are apparently not implemented in Haskell.
13:13:48 <geekosaur> actually TIOCSCTTY shouldn't be used by modern code anyway
13:14:05 <srhb> geekosaur: Oh?
13:14:36 <ski> JesseH : "SliTaz" ?
13:14:45 <geekosaur> setsid() clears the ctty, then the next tty open without O_NOCTTY will set the tty
13:15:02 <geekosaur> TIOCSCTTY is 4.2BSD era stuff
13:15:42 <srhb> geekosaur: But hang on, this is a pseudo terminal. Presumably I will need to TIOCSCTTY after getting the slave Fd in the child
13:15:49 <srhb> Or what?
13:16:08 <geekosaur> no, the child should be a separate session and should close any terminals it has open and call setsid()
13:16:28 <srhb> Oh God, so much terminology I don't understand. :-)
13:16:31 <geekosaur> then open the slave side of the pty, which will make the pty its ctty
13:16:42 <geekosaur> POSIX session management
13:16:42 <srhb> "close any terminal" - does this mean closing the slave fd?
13:16:57 <geekosaur> hm. slave fd should probably not be open at that point really
13:17:15 <srhb> geekosaur: But that's sort of what openPty does
13:18:02 <geekosaur> great so you are using something based on 4.2BSD era code that has a good chance of not working on a fully POSIX platform
13:18:24 <srhb> Well, if all I have to do is stop using openPseudoTerminal, my life surely becomes simpler. :P
13:18:35 <geekosaur> (although it might work on Linux if you're ucky, but that means digging out all the 4BSD compat stuff like TIOCSCTTY and hoping you don't manage to miss/break any POSIX session stuff in the meantime)
13:19:19 <geekosaur> oh, right, prpbably a wrapper for the 4BSD openpty() function
13:19:19 <srhb> geekosaur: Alright, your approach sounds a lot smarter. I was just under the impression that openPty _was_ the modern POSIX way
13:19:37 <geekosaur> I am under the impression it's the ancient BSD way
13:19:45 <srhb> geekosaur: According to the man page of openpty, you are right.
13:19:59 <geekosaur> openp[t / grantpt / unlockpt is the POSIX way
13:20:39 <geekosaur> and this among other things lets you do POSIX session setup properly in the slave so you don't have weird interactions between the processes on either end of the pty
13:21:18 <srhb> geekosaur: I see. So that is what System.Posix.Terminal.openPseudoTerminal is really doing.
13:22:00 <srhb> Or actually, no, that doesn't seem to be what it is doing. Freaky.
13:22:49 * geekosaur is digging
13:23:10 <geekosaur> nope, it's calling BSD openpty
13:23:16 <srhb> geekosaur: I may be wrong (I know nothing about FFI) but looking at the source makes me think it';s using openpty
13:23:19 <srhb> Yeah.
13:23:21 <geekosaur> which is wrong. but it's correctable
13:23:54 <srhb> geekosaur: Can I persuade you to give me some pointers on how to do that? And thank you very much for your time so far. :)
13:24:19 <geekosaur> call ttyname on the slave fd. close slave, pass result of ttyname to the child process. which should close any fds on the parent's controlling terminal and then setsid() and then open the ttyname\
13:24:57 <geekosaur> file bug against the unix package pointing them to the correct POSIX interface :p
13:25:26 <geekosaur> (I wonder of there's alredy a haskell binding for ttyname())
13:25:44 <srhb>   s <- throwErrnoIfNull "getTerminalName" (c_ttyname fd)
13:25:51 <srhb> In the unix package as well
13:25:57 <ski> geekosaur : to my ears it sounds a bit strange to have to go fd -> name -> fd
13:26:00 <geekosaur> yeh, just found that
13:26:05 <geekosaur> it is strange
13:27:07 <geekosaur> but since openpty() does not give you the slave device name, you have to do this or toss the openpty interface and write your own binding to the POSIX openpt stuff (and then you get compatibility issues, OS X calls it posi_openpt and has no openpt)
13:27:13 <geekosaur> er, posix_openpt
13:27:42 <srhb> :|
13:28:20 <ski> i thought part of the point of forking would be that you could keep references to fds around
13:28:25 <srhb> But hang on, while openpty does not give me the slave device name, I can extract it
13:28:29 <srhb> yeah
13:28:47 <briennetheblue> how do i make a Functor instance for ( type List a = Mu (ListF a) )?
13:29:00 <srhb> I have the slave Fd available in my child process.
13:29:05 <ski> briennetheblue : no
13:29:11 <ski> briennetheblue : you need to make it a `data' or `newtype'
13:29:30 <geekosaur> ski: potentially if you have a file descriptor open on your controlling tty, you can have problems disassociating from it so you can associate with a new controlling tty
13:29:47 <ski> briennetheblue : or use `type List = Comp Mu ListF', which amounts to the same thing, wrt `Comp'
13:29:50 <geekosaur> it's a corner case left deliberately open so that various commercial Unixes could claim POSIX compatibilityt
13:30:01 <srhb> How annoying.
13:30:04 <ski> (`Comp' being composition of type functions)
13:31:00 <geekosaur> so you need to close all references to your old controlling tty (likely this is only fds 0, 1, 2, which you want to close anyway!), setsid() to clear controlling tty and set up a new session, open() the pty slave (which makes it controlling tty) which should make it fd 0 and dup() onto fds 1 and 2
13:32:00 <srhb> geekosaur: I'll... try.. :D Thanks.
13:32:15 <ski> geekosaur : dup what onto `1' and `2' ? `0' ?
13:32:19 <geekosaur> yes
13:32:24 <srhb> :|
13:32:57 <briennetheblue> ski: ok thanks
13:33:27 <geekosaur> you also want to open 0 O_RDWR. (and in fact you will generally find that it *is* actually open O_RDWR, because this is how it's traditionally been done. moreover some programs depend on it!)
13:34:06 <geekosaur> traditionally pagers read commands from stdout or stderr so that you can use them on the end of a pipeline or redirection
13:34:47 <JesseH> ski, linux distro
13:34:56 <geekosaur> and yes, this is all not that well documented
13:35:16 <srhb> I've been able to find almost no documentation at all on how to do this.
13:35:28 <srhb> Basically relying on source code of various projects. Which doesn't help me all that much
13:35:40 <geekosaur> yes :(
13:36:23 <srhb> geekosaur: Would it be sufficient for me to, in the child process, get the nameof the terminal (ie. /dev/pts/nnn) then close and reopen the file descriptor for it?
13:36:30 <srhb> I guess the answer is "maybe" :P
13:37:21 <geekosaur> should be, yes
13:37:30 <ski> briennetheblue : the reason is that you can't make type synonyms instances of classes. even with `TypeSynonymInstances' you can't make a different instance for `String' than for `[Char]' (you need `FlexibleInstances' for that as well)
13:37:37 <ski> briennetheblue : and making an instance `Monad MyErrorMonad' where `type MyErrorMonad a = Either MyError a' doesn't work, you have to "eta-contract" it to `type MyErrorMonad = Either MyError' (which can't always be done, without introducing stuff like `Comp')
13:38:06 <hpc> ski: does that even work? separate instance for String and [Char]?
13:38:28 <ski> geekosaur : why would you depend on being able to write to `0' ?
13:38:37 <codygman> What is the haskell equivalent of this code: from random import choice; print choice(['movie 1', 'movie 2']). Use case is my friends and I not being able to select a movie ;)
13:38:44 <geekosaur> ski, I'm not sure anything depends on writing to 0
13:38:59 <geekosaur> but you get a writable 1 and 2 by dup() from 0
13:39:05 <geekosaur> not independent open()s
13:39:15 <ski> ok, reading from `1' or `2' then ?
13:39:15 <hpc> codygman: what are the movies?
13:39:24 <startling> codygman: fromList from MonadRandom's Control.Monad.Random does something like that.
13:39:27 <geekosaur> it is possible that something depends on those actually being the same kernel file reference (which is what dup() gets you)
13:39:32 <ski> i didn't understand
13:39:34 <ski> <geekosaur> traditionally pagers read commands from stdout or stderr so that you can use them on the end of a pipeline or redirection
13:40:08 <codygman> hpc: lol. Enders game, Bad Grandpa, Escape Plan, and Baggage Claim.
13:40:21 <codygman> startling: Thanks, I'll look at it.
13:40:34 <geekosaur> one difference between using dup() and using open() is that they have the same file offset information, although that is actually meaningless for ttys/ptys
13:40:45 <geekosaur> but we are at this point getting into kernel details
13:41:27 <startling> > fromList . map (flip (,) 1) $ ["Ender's Game", "Escape Plan"]
13:41:28 <lambdabot>   Not in scope: `fromList'
13:41:29 <lambdabot>  Perhaps you meant one of these:
13:41:29 <lambdabot>    `IM.fromList' ...
13:41:30 <geekosaur> what it comes down to is that some programs expect that file descriptors 0, 1, 2 refer to the exact same kernel file structure, so they need to be created using dup) or fcntl(fd, F_DUPFD, ...)
13:41:40 <geekosaur> so you need to do the initial open O_RDWR
13:42:23 * srhb is lost
13:42:25 <srhb> :-)
13:43:34 <geekosaur> close(0); close(1); close(2); open(ttydev, O_RDWR); dup(0); dup(0); # roughly
13:43:52 <codygman> I was actually trying to use Random Fu but I'm struggling to figure out how to work with RVars.
13:44:41 <codygman> thanks btw startling
13:45:05 <startling> codygman, I think random-fu is overpowered for your use-case.
13:46:16 <timthelion> weird bug ;) I wrote: let fileTree = mapM (\path->makeRelative root path) fileTree' with mapM rather than map.  Really took me a while to figure out what was going on...
13:46:20 <monochrom> random-fu should alias "split" to "karate_chop" :)
13:46:52 <startling> codygman, but, hmm, it looks like you could just runRVar $ randomElement myList
13:47:02 <timthelion> Initially, I thought that makeRelative would be in the IO monad, so I had written mapM...
13:47:29 <startling> timthelion, (->) r is a Monad, so sometimes you get seemingly-crazy errors from that.
13:47:43 <hpc> or seemingly-crazy actual workingness
13:47:55 <startling> rarely!
13:48:03 <timthelion> well it ran.  I ended up with a really weird looking file tree though
13:48:07 <startling> heh
13:50:27 <Luke> I'm having an issue with Heist. http://lpaste.net/95159 This looks like it should work to me, even "devel" shows up in the rendered template but the binds don't bind. anyone see what's wrong?
13:50:46 <srhb> Hm, progress at least. I can start sh, but can't really communicate with it. :-)
13:51:26 <srhb> Controlling terminal looks wrong though, /dev/tty?
13:56:13 * hackagebot purescript 0.1.3 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.3 (PhilFreeman)
14:02:16 <frxx> @src (->)
14:02:17 <lambdabot> Source not found. That's something I cannot allow to happen.
14:03:12 <Flonk> Is there a reason that there is no default Monoid instance for Int (or Num in general)?
14:03:30 <startling> Flonk: because there are two
14:03:32 <Flonk> I know that there is Sum and Product
14:03:33 <hpc> there are two, Sum and Product
14:03:35 <roboguy_> frxx: you can't have a function called -> can you?
14:03:37 <startling> Flonk: you can use Sum and Product, yeah.
14:03:46 <startling> @quote sadly
14:03:46 <hpc> neither is "better" or more authoratative than the other
14:03:47 <lambdabot> cjeris says: [on compiling ghc] there's a little italian man with a sausage grinder in there, grinding away.  but since the art of sausage making is dying out, he is sadly an old italian man, and
14:03:47 <lambdabot> has no son to turn the sausage grinder with him.  but it goes slowly.
14:04:02 <startling> @quote add edwardk (->) is syntax, sadly.
14:04:02 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
14:04:03 <Flonk> startling, hpc: right, but why not pick one?
14:04:10 <hpc> which one?
14:04:28 <Flonk> Personally I'd go for sum
14:04:30 <Iceland_jack> hpc: Addition, duh. :)
14:04:43 <startling> Flonk, because both will be nonobvious to half of the users of Haskell.
14:05:02 <startling> frxx, (->) is a special thing meaning "the function type"
14:05:56 <Flonk> startling: I don't know, going for no instance seems even less obvious though
14:05:59 <Flonk> But I get the idea
14:06:27 <startling> Flonk, yeah. I personally think it's kind of strange, too.
14:06:54 <startling> But I'm also the kind of person who thinks Num should be split into Ring and Field, so
14:07:56 <ski> startling : `@remember' ?
14:08:14 <startling> @remember edwardk (->) is syntax, sadly.
14:08:14 <lambdabot> I will never forget.
14:08:18 <startling> Aha.
14:09:27 <Luke> http://lpaste.net/95159 can anyone see why my heist bindings are failing here?
14:09:32 <ski> startling : `Num' already doesn't contain `(/)'
14:10:09 <ski> the strange members are `abs' and `signum', i suppose
14:10:23 <startling> fromInteger is kind of odd, too.
14:10:54 <ski> isn't it just the initial morphism from the initial ring ?
14:11:21 * ski ponders whether that's right
14:11:25 * startling too
14:11:34 <arkeet> sure it is
14:11:43 <startling> OK, well !
14:12:01 <startling> so all that's left is to rename it. :)
14:12:05 <arkeet> :(
14:12:15 <ski> to what ?
14:12:39 <arkeet> precisely.
14:12:47 <arkeet> precisely :: Num a => Integer -> a
14:13:48 <ski> hm, sounds a bit strange to me
14:14:04 <arkeet> =(
14:14:55 <startling> I mean Num to Ring
14:15:06 <ski> @type abs
14:15:08 <lambdabot> Num a => a -> a
14:15:12 <ski> @type magnitude
14:15:13 <lambdabot> RealFloat a => Complex a -> a
14:20:02 <codygman> I have a pure function, in order to use putStrLn in my main's do block below I have to lift it into the IO monad right?
14:20:36 <dwcook> codygman, not necessarily.
14:20:44 <codygman> dwcook, etc: http://lpaste.net/95162
14:20:58 <codygman> That was what I *thought* the problem was
14:21:14 <roconnor> codygman: add more parentheses
14:21:16 <dwcook> Your problem there is you're trying to apply print to too many things when you seem to want to apply it to just the *result* of liftM
14:21:23 <dwcook> Put parens around everything after print
14:21:31 <dwcook> Or put ($) right after print
14:21:37 <dwcook> Err, without parens
14:22:17 <ski> i think you need some way of exiting `Random' here
14:23:15 <ski>   print (liftM choice [1,2,3])  -- as others are suggesting, *might* work, but i suspect not
14:23:24 <dwcook> Well, it's a start
14:23:26 <ski> yes
14:23:27 <dwcook> It's not the only problem
14:23:43 <codygman> Still get an error: http://lpaste.net/95162
14:23:48 <ski> codygman : which package does `Control.Monad.Random' come from ?
14:23:54 <roconnor> print (choice [1,2,3]) might be better.
14:24:02 <startling> MonadRandom, probably
14:24:14 <codygman> ski: Yes it does come from MonadRandom.
14:24:18 <roconnor> man, we really need a type-directed editor for haskell.
14:24:26 <dwcook> When in doubt, look at the types
14:24:37 <ski> @hackage MonadRandom
14:24:38 <lambdabot> http://hackage.haskell.org/package/MonadRandom
14:24:46 <dwcook> codygman, what is the goal here?
14:24:46 <johnw> roconnor: if you have suggestions for how we could move the fpcomplete IDE more in that direction, we'd love to hear them
14:24:57 <codygman> dwcook: Just to print out a random choice from a list
14:25:03 <roconnor> johnw: have you ever used epigram?
14:25:12 <johnw> roconnor: no, just agda-mode and proofgeneral
14:25:16 <dwcook> codygman, where does the randomness come from?
14:25:27 <roconnor> is agda-mode like epigram?
14:25:34 <johnw> that's the answer I don't have...
14:25:50 <ski> codygman : do you want to use Rand' or `RandT' ?
14:25:54 <roconnor> it probably is
14:26:03 <roboguy_> codygman: I think you need evalRandIO or something like that
14:26:14 <codygman> dwcook: I can do it in ghic with my function of course, but having trouble printing it. Randomness comes from Control.Monad.Random and however it implements it.
14:26:26 <johnw> roconnor: I know that agda-mode writes a scary amount of code for me
14:26:33 <ski> roconnor : have you ever used Alfa ?
14:26:37 <codygman> roboguy_: alright looking that up
14:26:43 <roconnor> johnw: it is also possible that type-directed editors are more awesome in my head than in real life.
14:26:49 <ski> johnw : goes for you as well ..
14:26:51 <roconnor> johnw: but I don't think it is all fanatasy.
14:26:54 <startling> roboguy_, nah, IO is a MonadRandom
14:26:56 <codygman> ski: I'm not sure of the difference tbh, I'm just now exploring these things.
14:27:08 <johnw> no, never heard of alfa
14:27:15 <ski> codygman : in case you don't know, then you probably want `Rand' -- it is at least the simplest option
14:27:22 <ski> johnw : it's the IDE for Agda1
14:27:28 <roboguy_> startling: that's what they use in the example in the hackage page for MonadRandom...
14:27:29 <startling> codygman: where's your code?
14:27:37 <codygman> ski: Alright, good to know. posting code now
14:27:42 <codygman> http://lpaste.net/95162
14:27:44 <roconnor> johnw: I've never used the fpcomplete IDE; It it an open source project?
14:27:45 <codygman> thought I already had
14:27:50 <roboguy_> I guess you don't need it though
14:27:59 <johnw> roconnor: no
14:28:06 <startling> roboguy_: yeah, I think they're just illustrating how to do it purely
14:28:30 <roconnor> johnw: ah, I probably cannot contribute directly to it then.
14:28:40 <johnw> roconnor: only by ideas at the moment, sadly
14:28:42 <startling> codygman: oh, just get rid of the liftM.
14:28:50 <startling> codygman: look at the type of "choice"
14:29:16 <roconnor> johnw: have you read the december version of Mckinna and Mcbride's "View from the Left"?
14:29:19 <startling> codygman, choice :: MonadRandom m => [a] -> m a
14:29:29 <startling> codygman, :i MonadRandom tells you that IO is an instance of MonadRandom
14:29:39 <roboguy_> why doesn't "fmap print (choice [1,2,3])" work?
14:29:42 <startling> codygman, so, you can pretend choice :: [a] -> IO a
14:29:52 <johnw> roconnor: not yet, it's in my reading queue though
14:29:58 <startling> roboguy_: (mapM_?)
14:30:16 <ski> johnw,roconnor : here's a simple screenshot of Alfa <http://i.imgur.com/Fn6Gr.png>, using the "natural deduction" view of proofs, you can also view them like proof terms in Agda2
14:30:17 <startling> codygman, so, you want something like choice [...] >>= print
14:30:28 <johnw> oh, wow
14:30:32 <startling> codygman: or do { result <- choice [...]; print result; }
14:30:35 <roboguy_> startling: doesn't type check
14:30:43 <roconnor> http://strictlypositive.org/view-Dec6.ps.gz
14:30:48 <startling> roboguy_: which doesn't?
14:31:01 <roboguy_> startling: did you mean mapM_ print (choice [1,2,3])?
14:31:03 <roconnor> I think this is one of the most important papers I've read; though I've only acted on a small portion of it.
14:31:18 <startling> roboguy_: oh. No, I wasn't thinking that through.
14:31:20 <roconnor> ski: Cute.
14:31:23 <ski> johnw,roconnor : the window to the right shows the dynamically computed keyboard shortcuts to the operations which could possibly fit in the selected hole (given type-checking)
14:31:42 <roconnor> ski: though I don't think that form of presentation of natural deduction lasts much beyond toy problems.
14:31:44 <roboguy_> startling: using fmap compiles but gives no output. something to do with lazy IO?
14:31:59 <codygman> startling: Alright, thanks. That fills in some of my knowledge gaps.
14:32:00 <ski> johnw,roconnor : as soon as you e.g. fill in a hole with a vector of a certain size, then other holes which must be the size of this vector are automatically filled in
14:32:29 <ski> roconnor : as i said, this is the "wide natural deduction" view, there's also a "tall natural deduction" view, and also a plain proof term view
14:32:31 <startling> roboguy_, I don't know what mapping over choice's result would even do.
14:32:53 <ski> @where Alfa
14:32:54 <lambdabot> Proof editor, using Agda1 proof engine/checker, at <http://www.cse.chalmers.se/~hallgren/Alfa/>,(broken) <http://www.cs.chalmers.se/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested>
14:32:54 <lambdabot> ,<http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz>,<http://ogi.altocumulus.org/~hallgren/untested/Source_code/alfa-050126.src.tar.gz>. Also see `
14:32:54 <lambdabot> Agda',`Fudgets',`GF'
14:33:02 <ski> johnw,roconnor : ^
14:33:06 <roboguy_> startling: actually, good point
14:33:07 <startling> codygman: great! let me know if you're still having trouble. this channel is sort of noisy today.
14:33:54 <roconnor> johnw: anyhow, I recommend moving that paper up your queue. :D
14:33:59 <johnw> roconnor: ok!
14:34:16 <johnw> there are so many that i usually just pick one at random, but i'll pick that next
14:34:38 <startling> johnw: I can sympathize. :(
14:35:06 <roconnor> johnw: after you are done reading it, put it back in the queue to read again later.
14:35:28 * roconnor tries to read it, like, once a year. :)
14:35:31 <johnw> roconnor: yeah, I need to read pretty much all of these again at some point
14:36:12 <mocuser> hi
14:36:14 <startling> I wish people would write blog post "readers" of papers.
14:36:21 <mocuser> hi
14:36:29 <startling> Knowing what to read when is kind of difficult.
14:36:31 <startling> mocuser: hi.
14:36:32 <mocuser> beginner here
14:36:37 <mocuser> data Pitcher = Pitcher { contents:: Int
14:36:37 <mocuser>                        , capacity:: Int
14:36:37 <mocuser>                        } deriving (Show, Eq)
14:36:37 <mocuser> instance Ord Pitcher where
14:36:37 <mocuser>     compare (Pitcher x y1) (Pitcher x y2) = compare y1 y2
14:36:37 <mocuser>     compare (Pitcher x1 _) (Pitcher x2 _) = compare x1 x2
14:36:38 <mocuser>     
14:36:51 <srhb> mocuser: User lpaste.net
14:36:55 <mocuser> I defined a Pitcher, which has two field
14:37:04 <mocuser> How can I write a Ord instance for it?
14:37:15 <roconnor> johnw: also be sure to read the December version.  The published paper is less useful.
14:37:30 <roconnor> ... way to go peer review process. :/
14:37:56 <monochrom> mocuser: what do you want the Ord instance to do?
14:37:59 <geekosaur> mocuser, don't paste into the channel pplease. see /topic for pastebin. but you're making a common beginner error: those x-s are not related
14:38:20 <ski> johnw : btw, i hope you've seen "A Case for Dependent Families" by Conor McBride at <http://strictlypositive.org/a-case/>
14:38:42 <geekosaur> or if you actually intende to ignore those like the second definition, then you have an unstable Ord instance which will cause problems
14:38:50 <mocuser> if the contents are equal for two picthers, we return  the order of capacity
14:38:59 <mocuser> otherwise, we return the order of contents
14:39:02 <monochrom> it seems to me you just need "deriving (Show, Eq, Ord)"
14:39:16 <mocuser> why I cannot do pattern matching
14:39:24 <mocuser> I 'll try
14:39:31 <geekosaur> because the x-s there are not equal
14:39:37 <monochrom> you can do pattern matching. your code does not do pattern matching.
14:39:43 <ski>   compare (Pitcher x1 y1) (Pitcher x2 y2) | x1 == x2 = compare y1 y2
14:40:00 <mocuser> I see!
14:40:07 <geekosaur> compare (Pitcher x y1) (Pitcher x y2) --- the second x is not checked for equality; it *hides* the first x
14:40:22 <mocuser> ah. deriving (Show,Eq, Ord) works too
14:40:30 <mocuser> I tried (Show, Ord),
14:40:34 <mocuser> it told me I need Eq.
14:40:43 <mocuser> I thought Ord includes Eq
14:40:50 <geekosaur> not so much includes as requires
14:41:01 <ski>   compare (Pitcher x1 y1) (Pitcher x2 y2) = compare x1 x2 `mappend` compare y1 y2  -- another way
14:41:05 <geekosaur> you need to provide it an Eq, and it can then use that to define Ord
14:41:09 <skypers> night :)
14:41:34 <akapp> Anyone know if EclipseFP site is down?
14:41:36 <mocuser> we had a assignment to do the classical pitcher pour liquid .. using Scheme.
14:41:44 <mocuser> After finishing it. I wanna try Haskell
14:41:47 <akapp> I cannot seem to pull from that site
14:41:47 <mocuser> http://www.ccs.neu.edu/course/cs5010f13/problem-sets/ps07.html
14:42:07 <ski> mocuser : Scheme is nice :)
14:42:08 <mocuser> I found they are so similiar
14:42:14 <mocuser> Yes.
14:42:28 <ski> mocuser : have you found #scheme yet ?
14:42:33 <mocuser> most of the syntax has equivalent tranlation.
14:42:53 <mocuser> Oh, I finished the scheme homework.
14:42:55 <Tril> akapp: url?
14:43:03 <mocuser> I taught Haskell by myself.
14:43:05 <ski> mocuser : question still stands
14:43:50 <ski> mocuser : btw, have you seen any logic programming ? Prolog ? (or Mercury or Oz or ECLiPSe or Gödel or Escher or Curry ?)
14:44:35 <mocuser> ACL2?
14:44:55 <mocuser> ACL2 sedan is used for logic and computation class.
14:45:38 <mocuser> <ski>
14:45:44 <ski> afaiu, ACL2 isn't logic programming
14:46:03 <ski> (also, if you say "<ski> ...", it looks like you're quoting a message of mine)
14:46:05 <monochrom> you are looking at various ways of using the word "logic"
14:46:58 <mocuser> how do I talk to a specific person?
14:47:01 <mocuser> new to irc too..
14:47:12 <geekosaur> normally just start the line with their nick
14:47:25 <mocuser> ski nick
14:47:25 <geekosaur> most of us follow with : or ,
14:47:31 <mocuser> ski: hi
14:47:38 <mocuser> ski, hi
14:47:40 <mocuser> not working
14:47:49 <geekosaur> enh
14:48:01 <roboguy_> mocuser: yeah it is. there's nothing special that goes on, most irc clients just highlight stuff with our name in it
14:48:19 <mocuser> okay.
14:48:19 <geekosaur> (there are also private messages but you should generally not just pm someone without an invitation)
14:48:32 <mocuser> I have another question
14:48:48 <mocuser> What is a Set    data type?
14:49:03 <geekosaur> ski will have been nnotified, but may be busy at the moment. it happens. (I flip between some 20 channels, and sometimes have op duties in several of them)
14:49:04 <mocuser> say I have a function take a Set of Int, Return a Set of Int
14:49:10 <mocuser> How do I write the contract.
14:49:23 <geekosaur> @hoogle Set
14:49:23 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
14:49:23 <arkeet> Set Int -> Set Int ?
14:49:23 <lambdabot> Control.OldException setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
14:49:23 <lambdabot> Data.Set module Data.Set
14:49:32 <arkeet> Set is from Data.Set, say.
14:49:37 <mocuser> yes.
14:49:42 <mocuser> Set if From Data.Set
14:50:11 <monochrom> f :: Set Int -> Set Int
14:50:31 <ski> mocuser : what is not working ?
14:51:10 <mocuser> ah. Good.
14:51:33 <mocuser> So far so good.
14:51:36 <akapp> anyone got a recommendation for an editor for haskell? I cant seem to get the plugin for eclipse working at the moment
14:51:52 <srhb> akapp: Vim and Emacs seem to be the most prominent ones.
14:52:18 <monochrom> I use emacs, vim, vi, nano, pico, notepad++
14:52:34 <mocuser> I am using emacs too
14:52:42 <mocuser> it's has a haskell mode
14:53:03 <Iceland_jack> Emacs
14:53:06 * ski used CygnusEd a little bit as well
14:53:13 <akapp> would it be beneficial to switch to or use a vm of linux for haskell programming them?
14:53:14 <akapp> then*
14:53:26 <monochrom> next time, I should try "I use cat >"
14:53:28 <srhb> akapp: Those editors exist for many OS'es
14:53:37 <ski> monochrom : btdt
14:53:37 <srhb> akapp: Including Windows and OS X
14:54:04 <monochrom> notepad++ is windows
14:54:31 <ski> akapp : it would also be possible to SSH from one computer to another, if you like
14:55:14 <mocuser> I betrayed Vim after learned scheme and finally know how Emacs works
14:55:26 <monochrom> (next time, I should try "I use copy con:" :) )
14:56:08 <mocuser> Does anyone know of "worklist" algorithm?
14:56:10 <thebnq> does anyone actually use yi
14:56:21 <mocuser> usually a graph search algorithm in FP?
15:01:25 <ski> monochrom :)
15:01:44 <unbirthday> i love haskell and i cannot lie
15:04:30 <mm_freak> akapp: check if leksah runs under windows
15:04:49 <mm_freak> attempts to be an IDE from haskell programmers for haskell programmers
15:06:34 <roboguy_> mm_freak: I only tried leksah briefly but it didn't seem very mature especially compared to using haskell-mode for emacs
15:07:57 <unbirthday> vi/m fans converge, to destroy the evil emacs and its cohorts!
15:08:12 <mm_freak> haskell-mode probably beats most editing choices for haskell
15:09:04 <monochrom> use turbo pascal
15:09:21 <dolio> I don't think there's anything you can do for vi.
15:09:46 <mm_freak> don't feed the…  you know…
15:11:46 <lpaste> henk pasted “shorten calcDurations?” at http://lpaste.net/95165
15:13:16 <henk> hi everyone, I’d like to know if there is a shorter or simpler way for the calcDurations function in http://lpaste.net/95165. Any ideas or pointers?
15:15:48 <arkeet> henk: probably, but it's probably less clear too ;)
15:17:46 <arkeet> > (zipWith subtract <*> tail) . (a:) : [x,y,z]
15:17:47 <lambdabot>   Couldn't match expected type `[Debug.SimpleReflect.Expr.Expr]
15:17:48 <lambdabot>              ...
15:17:50 <henk> arkeet: ah, too bad. Maybe I should consider rethinking / restructuring my program idea ):
15:17:51 <arkeet> oh.
15:18:05 <arkeet> henk: you could shorten it by shortening your variable names D:
15:18:21 <arkeet> > (zipWith subtract <*> tail) . (a:) $ [x,y,z]
15:18:23 <lambdabot>   [x - a,y - x,z - y]
15:20:15 <darthdeus> is there a package for calculating prime factors?
15:21:36 <arkeet> darthdeus: have a look at the arithmoi package.
15:22:26 <darthdeus> thanks
15:22:54 <rtfeldman> Does anyone know if https://github.com/basvandijk/lifted-base/pull/20 breaks in 7.6.3 because of a planned syntax change in preprocessor directives, or just a 7.6.3 regression?
15:23:06 <arkeet> rtfeldman: it breaks because you're using clang's CPP
15:23:22 <ski> monochrom : hm, reminds me i should try to install RhIDE again
15:23:42 <geekosaur> rtfeldman, see the end of the /topic
15:23:46 <henk> arkeet: hm, any recommendation how to learn about <*>?
15:24:03 <arkeet> henk: it's from Control.Applicative. the Applicative instance for functions is just
15:24:08 <arkeet> (f <*> g) x = f x (g x)
15:24:29 <arkeet> well, half of it.
15:25:18 <startling> pure = const
15:25:48 * henk blinks
15:25:59 * ski unblinks
15:27:05 <sm> hi all.. any tips on keeping disqus javascript out of my posts at planet haskell ? See eg http://planet.haskell.org/ ?
15:28:34 <sm> keep it out of my feed I guess
15:29:01 <rtfeldman> thanks arkeet and geekosaur!
15:34:04 <monochrom> sm: strange, I don't get disqus garbage when I browse it. I have even turned off adblock-plus and turned on javascript. what I do get: in some posts, but not all, the displayed text "<script type="text/javascript"> var disqus_shortname ... </script>". perhaps I should make you a screenshot
15:36:20 <henk> arkeet: Where can I find the other half?
15:36:29 <arkeet> I mean half of Applicative is <*>, and the other half is pure.
15:36:38 <monochrom> sm: http://www.vex.net/~trebla/tmp/disqus.png
15:37:21 <arkeet> :t const <*> const
15:37:23 <lambdabot> a -> a
15:37:27 <monochrom> only a few posts have it. I am guessing that it is the doing of individual sources, not planet.haskell.org
15:37:31 <ski> monochrom : disqusting
15:38:03 <monochrom> well yeah I agree with you. I tell my adblock-plus to block it normally
15:38:21 <henk> arkeet: Thank you, but I’m lost. I’ll just keep it like it is, until I understand a bit more of haskell a bit better … I’m a little handicapped when it comes to programming I think …
15:38:24 <monochrom> well, I block it because it's too slow
15:38:41 <arkeet> henk: ok, well you can pretend that (f <*> g) x = f x (g x).
15:38:46 <arkeet> but really, (<*>) is a typeclass method.
15:38:48 <arkeet> for the Applicative class.
15:38:58 <arkeet> one of the instances for Applicative gives the above definition.
15:39:22 <arkeet> that's it :)
15:40:17 <ski> henk : and `pure = const' is the same as `pure c x = c'
15:41:02 <henk> No, my head, I need to go … thanks
15:41:30 <arkeet> you can think about it more when you're more comfortable with typeclasses. :)
15:41:54 <henk> will do
15:42:25 <mocuser> hi
15:42:46 <mocuser> if I have a list = [1,3,43,43]
15:43:09 <mocuser> I want map a predicate on it
15:43:20 <mocuser> map (== goal) lst
15:43:27 <mocuser> == is not working
15:43:32 <roboguy_> mocuser: you probably want filter not map
15:43:39 <ski> what do you want the answer to be ?
15:44:30 <mocuser> I just wanted to ask if map (\x x==goal) lst is  map(== goal) lst
15:44:33 <arkeet> * What do you get?
15:44:34 <mocuser> I want ormap
15:44:37 <arkeet> * What did you expect to see?
15:44:46 <mocuser> a list of boolean.
15:44:57 <arkeet> > map (== 5) [1,3,5,7]
15:44:58 <lambdabot>   [False,False,True,False]
15:45:29 <ski> mocuser : `\x -> x == ...' is `(== ...)', yes, assuming `...' doesn't mention `x'
15:45:40 <mocuser> cool!
15:45:53 <mocuser> == 5 5  doesn't work right
15:45:57 <ski> similarly, `(... ==)' is `\x -> ... == x'
15:46:00 <startling> > (==) 5 5
15:46:01 <lambdabot>   True
15:46:02 <mocuser> but when you do map  the == can be in the first?
15:46:03 <arkeet> the parentheses are not optional.
15:46:05 <startling> > (== 5) 5
15:46:06 <lambdabot>   True
15:46:11 <mocuser> nice.!
15:46:27 <ski> > filter (> 4) [2,3,5,7]
15:46:29 <lambdabot>   [5,7]
15:46:29 <Iceland_jack> > (5 ==) 5
15:46:30 <lambdabot>   True
15:46:31 <ski> > filter (4 >) [2,3,5,7]
15:46:32 <lambdabot>   [2,3]
15:46:52 <mocuser> actually, I just want to see "is there a element ==5 in the lst"?
15:46:57 <mocuser> return true or false
15:47:03 <Iceland_jack> @ty elem
15:47:04 <lambdabot> Eq a => a -> [a] -> Bool
15:47:06 <mocuser> I guess I can do a map (== )
15:47:12 <Iceland_jack> > 5 `elem` [1,2,3,4]
15:47:13 <lambdabot>   False
15:47:14 <Iceland_jack> > 5 `elem` [1,2,3,4,5]
15:47:14 <ski> mocuser : what Iceland_jack said
15:47:15 <lambdabot>   True
15:47:16 <mocuser> ..
15:47:17 <mocuser> yes.
15:47:21 <startling> > any (== 5) [1, 2, 3, 4]
15:47:22 <mocuser> elem!
15:47:22 <lambdabot>   False
15:47:30 <startling> > 5 `elem` [1, 2, 3, 4]
15:47:31 <lambdabot>   False
15:47:40 <ski> > any (> 5) [1,2,3,4]
15:47:41 <lambdabot>   False
15:47:43 <mocuser> oops.
15:47:46 <ski> > any (5 >) [1,2,3,4]
15:47:47 <lambdabot>   True
15:48:02 <mocuser> not ,    I want to ask Is there a emelent satisfy a predicate in the list?
15:48:14 <mocuser> but I see..
15:48:15 <Iceland_jack> mocuser: any
15:48:17 <Iceland_jack> @any
15:48:17 <lambdabot> Maybe you meant: wn ask arr
15:48:19 <mocuser> eleme will work.
15:48:21 <Iceland_jack> @ty any
15:48:22 <lambdabot> (a -> Bool) -> [a] -> Bool
15:48:37 <Iceland_jack> > any (== 'a') "any should work here"
15:48:39 <lambdabot>   True
15:48:40 <mocuser> good!
15:48:42 <ski> > any (> 2) [1,2,3,4]
15:48:43 <lambdabot>   True
15:48:44 <ski> > all (> 2) [1,2,3,4]
15:48:46 <lambdabot>   False
15:48:57 <Iceland_jack> mocuser: Does that answer your question?
15:49:04 <mocuser> Yes, thanks a lot!
15:49:48 <mocuser> so any in haskell is actually a ormap in Scheme
15:50:03 <Iceland_jack> @src any
15:50:03 <lambdabot> any p =  or . map p
15:50:05 <arkeet> any f = or . map f
15:50:06 <arkeet> yeah.
15:50:09 <Iceland_jack> ;)
15:51:35 <arkeet> :t auf (wrapping Any) foldMap
15:51:37 <lambdabot> Foldable t => (r -> Bool) -> t r -> Bool
15:52:01 <ski> @src all
15:52:02 <lambdabot> all p =  and . map p
15:52:29 <AfC> I have a package up on Hackage whose haddock is not rendering properly. There was a bit of a change from a previous version [it', but a) the
15:52:39 <AfC> [it's now two packages]
15:52:57 * ski . o O ( "Auf Wiedersehen Monty" )
15:52:58 <AfC> but a) the dependency renders its haddock fine, and b) both render fine locally.
15:53:19 <AfC> Can anyone suggest who I should talk to to try and diagnose this?
15:53:26 <AfC> I'm guessing a Hackage-2 issue, but who knows.
15:54:18 <sm> monochrom: thanks for the info. I figure it's getting included and escaped in my feed, so shows up as content at planet haskell and planet darcs
15:54:46 <sm> ski: got any better alternatives to disqus ?
15:55:31 <arkeet> AfC: which package?
15:55:42 <ski> sm : i'm not quite sure what disqus is meant to do
15:56:15 <AfC> arkeet: http://hackage.haskell.org/package/http-streams
15:56:24 <mocuser> My program is about to finished!
15:56:26 * hackagebot cookbook 1.5.0.0 - A delicious set of interdependant libraries.  http://hackage.haskell.org/package/cookbook-1.5.0.0 (NatePisarski)
15:56:29 <startling> ski: it's a third-party js commenting system
15:56:35 <mocuser> General recurision is coming.
15:56:40 <AfC> arkeet: http://hackage.haskell.org/package/http-streams-0.7.0.2/docs/Network-Http-Client.html doesn't, but http://research.operationaldynamics.com/projects/http-streams/doc/Network-Http-Client.html did
15:56:48 <sm> ski: it's eg a quick way to allow comments on a static hakyll site
15:57:08 <ski> startling,sm : mhm
15:57:23 <sm> who wants to write a self-hosted haskell version ?
15:57:48 * ski . o O ( "All hail General Recursion !" )
15:58:55 <arkeet> AfC: I dunno!
16:09:21 <aupiff> hi all, I have a aeson question
16:09:27 <aupiff> http://lpaste.net/95166
16:09:42 <aupiff> the code and a description of the problem is in that paste
16:10:23 <aupiff> essentially, I am able to access a list element of a JSON object, and it's of type [[String]], and I'm just trying to convert it to [[Double]]
16:10:48 <aupiff> the list looks like [["23.22", "12932.2231"], ....]
16:11:49 <aupiff> I can't just fmap (fmap read) the thing because of the weird aeson parser monad which I cleary don't understand
16:12:06 <aupiff> and (mapM . mapM) read isn't working for me either
16:12:11 <aupiff> and advice?
16:12:43 <triliyn> I think you want liftM, not mapM
16:12:55 <fylwind> heh, I was looking at this #python question and apparently this expression [f () | f <- [(\_ -> x) | x <- [1, 2, 3]]] (translated from Python) gives you the non-intuitive result [3, 3, 3] because the lambda captures "x" by reference rather than value
16:12:56 <triliyn> Or wait, maybe not
16:13:00 <AfC> arkeet: any suggestion who I should poke?
16:13:11 <arkeet> no idea =(
16:14:21 <Iceland_jack> > [f () | f <- [(\_ -> x) | x <- [1, 2, 3]]]
16:14:22 <lambdabot>   [1,2,3]
16:14:44 <aupiff> triliyn: yeah, liftM works for read a single value
16:14:45 <Iceland_jack> > [f undefined | f <- [ const x | x <- [1, 2, 3]]]
16:14:46 <lambdabot>   [1,2,3]
16:15:07 <aupiff> triliyn: this time I've got a nested list and for some reason I'm getting weird results
16:15:49 <Iceland_jack> > mapM const [1,2,3] undefined
16:15:50 <lambdabot>   [1,2,3]
16:20:22 <Ralith> aupiff: aeson is pretty classy, you may be able to just decode it as [[Number]] or similar directly
16:21:28 <aupiff> this is a full non-working version, but it's the way it logically makes sense to me: http://lpaste.net/95169
16:21:46 <aupiff> Ralith: ok, trying that now
16:23:10 <Ralith> aupiff: if [[Double]] is what you need at the end, try that too
16:23:35 <aupiff> Ralith: oh, yeah, I've tried that already (my first attempt), but that's not working
16:24:29 <Ralith> aupiff: oh, there's your problem
16:24:33 <Ralith> aupiff: delete 'read'
16:25:01 <Ralith> aupiff: in fact, you should be able to delete all cases of read/mapM/liftM in the FromJSON instance
16:25:26 <Ralith> aupiff: also, this looks financial--consider Data.Decimal instead of Double.
16:26:12 <Ralith> clean the 'liftM read's out of the FromJSON Ticker instance too
16:26:21 <aupiff> Ralith: when expecting a Integral, encountered String instead
16:26:31 <Ralith> ?
16:26:46 <aupiff> Ralith: that's the error I get when I do that, I don't think aeson does that conversion for you
16:26:52 <Ralith> it does
16:27:02 * Ralith pulls down the code so he can see the error in full detail
16:28:05 <Ralith> aupiff: the changes I instructed you to make cause the code you pasted to typecheck fine here.
16:28:45 <aupiff>     aeson-0.6.2.1
16:28:52 <aupiff> is the version I have
16:28:59 <Ralith> oh, it was a runtime error
16:29:31 <aupiff> Ralith: yep, a runtime error, that's right
16:29:41 <darthdeus> what does this mean?     Couldn't match expected type `Int -> Int -> Int'
16:29:41 <darthdeus>                 with actual type `Int'
16:29:41 <darthdeus>     The operator `div' takes two arguments,
16:29:41 <darthdeus>     but its type `Int' has none
16:30:08 <Ralith> aupiff: do you have a concise sample of a valid input?
16:30:11 <darthdeus> the documentation says it takes Integral a, which is an integer, right?
16:30:14 <darthdeus> i mean Int
16:31:19 <monochrom> it can take two Ints, yes
16:31:20 <geekosaur> darthdeus, my guess is you tried to assign a type to a parameter but did not use parentheses
16:31:32 <geekosaur> so it's actually saying that the operator (/) is *itself* an Int
16:31:32 <aupiff> Ralith: you can just make the api call, like ghc --make (the file) -o name, ./name
16:31:45 <aupiff> Ralith: I'll post an example call in a sec
16:31:55 <geekosaur> also, you can't use an Int with (/) even with a type annotation
16:32:06 <geekosaur> oh, div, not (/), sorry. same issue though
16:32:16 <funky_> .
16:32:21 <geekosaur> you managed to tell the compiler that div is an Int
16:32:31 <geekosaur> not that div is being *given* an Int, but that it *is* itself an Int
16:32:55 <Ralith> aupiff: yes, I saw the web service, its result is much larger than necessary for a test case.
16:34:06 <aupiff> Ralith: http://lpaste.net/95170 short and sweet
16:34:57 <Ralith> aupiff: oh, they're actually strings in the input, silly me
16:35:21 <Ralith> (all the more reason to use a suitable type other than Double :P)
16:35:25 <geekosaur> @lpaste your actual code, darthdeus
16:35:26 <lambdabot> Haskell pastebin: http://lpaste.net/
16:39:31 <aupiff> Ralith: my code with the "liftM read (v .: "key")" works just fine for this ticker call http://lpaste.net/95173
16:40:05 <Ralith> aupiff: http://sprunge.us/IaPR
16:40:22 <Ralith> aupiff: you got carried away with mapMs, that was all
16:40:32 <mocuser> My program is done.
16:40:35 <mocuser> https://github.com/Linzertorte/cs5010f13/blob/master/pitchers.hs
16:40:50 <mocuser> Thank you, guys.
16:41:04 <Ralith> aupiff: in fact, that outer mapM can be replaced with a map too
16:42:12 <Ralith> aupiff: http://sprunge.us/IUie
16:42:18 <Ralith> that should be clearer
16:43:30 <Ralith> aupiff: you start out with a 'm [[String]]' and you want a 'm [[Double]]'
16:43:39 <Ralith> :t liftM (map (map read))
16:43:41 <lambdabot> (Monad m, Read b) => m [[String]] -> m [[b]]
16:43:51 <Ralith> see how that works?
16:45:12 <aupiff> Ralith: yes! thanks a lot!
16:45:39 <aupiff> Ralith: I kind of stopped thinking after 1 hr of trying to grok aeson...which is why I came here!
16:46:43 <zugz> any basic hints on keeping ghc compilation fast? e.g. does explicitly declaring types speed things up?
16:47:24 <monochrom> no. turn down optimizations, that's about the only way.
16:47:38 <chrisdone> zugz: ime type checking is rarely the problem for compile speed
16:47:46 <chrisdone> zugz: if you *just* want to type check, use -fno-code
16:48:00 <monochrom> (I also want to say "write less code" but I guess that is not an option)
16:48:04 <chrisdone> that is an order of magnitude faster than with code generation enabled
16:48:22 <aupiff> Ralith: this is all it took... http://lpaste.net/95174
16:48:24 <chrisdone> but you lose some warnings like missing patterns (presently), so don't rely on it for anything other than type checking
16:48:40 <aupiff> Ralith: just liftM, and then treat it like a normal list... duh!
16:48:51 <RichyB> I thought I saw a slide somewhere where someone was claiming that code using type families compiled noticeably faster than code using fundeps and MPTC to encode the same invariants.
16:49:28 <zugz> there are no optimisations unless you give -O, right? if you just invoke ghc from the command line, I mean
16:49:38 <RichyB> Maybe that was only applicable to code pushing at the edge cases.
16:49:43 <geekosaur> correct
16:49:51 <chrisdone> zugz: it also depends how you're compiling, too. ghci by default does not load files quickly
16:49:56 <ski> aupiff : are you sure `read' will always work there ?
16:49:57 <zugz> yes, it's not too bad without -O
16:50:15 <zugz> thanks
16:50:19 <RichyB> Yes, quick code generation (-fasm, -O0) is the default.
16:50:53 <chrisdone> -fobject-code in ghc will be the only way you can realistically work with large projects in ghci
16:51:08 <aupiff> ski: it's working now, and I think it will always work, because it knows the values are supposed to be doubles and as long as the API is faithful I should always get a list of list of well-formed numerical strings
16:51:09 <chrisdone> although -fno-code is also an option too in ghci
16:51:11 <khyperia> Hmm... I need a function of type "(a -> m1 (m2 b)) -> m1 (m2 a) -> m1 (m2 b)"... so sort of like (fmap . fmap), only monad-like.
16:51:20 <Ralith> aupiff: yeah, aeson's pretty intimidating at first but it's very simple to use once you get a hang of the core API.
16:51:34 <Ralith> aupiff: now seriously switch to Data.Decimal instead of Double.
16:51:58 <aupiff> Ralith: oh, yeah? infinite precision type?
16:52:40 <Ralith> aupiff: infinite precision reals aren't very useful; Data.Decimal is fixed-point with well defined behavior and no overflows.
16:52:54 <khyperia> actually it could also be "(a -> m1 (m2 b)) -> m2 a -> m1 (m2 b)"
16:53:47 <aupiff> Ralith: ok, gotchya, I'll do that after reading the hackage docs on Data.Decimal, then.
16:55:20 <roboguy_> khyperia: it can't be restricted to only use one monad at a time?
16:55:31 <khyperia> I think I'm almost onto it...
16:55:33 <Ralith> :t (=<<)
16:55:35 <lambdabot> Monad m => (a -> m b) -> m a -> m b
16:55:36 <Ralith> khyperia: ^
16:56:02 <Ralith> oh, sorry
16:56:05 <Ralith> different ms
16:56:51 <roboguy_> khyperia: actually, couldn't you use (fmap . fmap) since all monads are (or should be) functors?
16:58:24 <khyperia> (fmap . fmap) :: (a -> b) -> m1 (m2 a) -> m1 (m2 b)
16:58:34 <khyperia> not (a -> m1 (m2 b)) -> m1 (m2 a) -> m1 (m2 b)
17:03:12 <ski> aupiff : fair enough
17:04:38 <khyperia> I figured out something that's - liftM concat (mapM f xs) :: (a -> m ([] b)) -> [] a -> m ([] b), which [] was what I was aiming for
17:09:51 <arkeet> :t liftM ?f . mapM ?g
17:09:52 <lambdabot> (Monad m, ?f::[b] -> r, ?g::a -> m b) => [a] -> m r
17:17:55 <roboguy_> khyperia: I feel like it would be easier if you could combine the monads with a transformer
17:18:00 <khyperia> possibly
17:18:37 <arkeet> :t mapM
17:18:38 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
17:19:04 <arkeet> :t (liftM concat .) . mapM
17:19:06 <lambdabot> Monad m => (a1 -> m [a]) -> [a1] -> m [a]
17:19:26 <arkeet> looks like (=<<) for a certain thing.
17:19:44 <arkeet> I wonder about laws.
17:20:34 <roboguy_> khyperia: this is sort of close but the return type of the function argument isn't quite general enough: liftM join (fmap (>>=f) xs)
17:20:52 <roboguy_> since join works with one monad
17:20:57 <roboguy_> at a time
17:21:24 <akurei> --help
17:22:42 <roboguy_> if at least one of them is a comonad that would probably help
17:26:05 <cfoch> hello. How can I install wxhaskell in Fedora?
17:32:03 <geekosaur> cfoch, you start by installing fedora's wxwindows packages, otherwise wxhaskell can't find the libraries and headers it needs
17:32:11 <geekosaur> make sure you include the devel packages
17:35:31 <cfoch> geekosaur: can you tell me what are these packages, please? I'm really new in Haskell and in wxHaskell. I've installed wxGTK, should I install other package ?
17:35:55 <geekosaur> I don't have Fedora here
17:36:48 <geekosaur> but if my SL6 installation is any indication you also need wxGTK-devel and possibly wxGTK-gl and wxGTK-media
17:37:52 <cfoch> http://fpaste.org/51366/38352858/
17:38:22 <cfoch> geekosaur: there is a wxGTK-gl and media but not a devel
17:38:38 <geekosaur> then I can't help you because I don't have Fedora here
17:38:57 <Zearen> If I remember, there was this module that defined something like a Cast a b class that you could use to write typesafe cast declarations.  Am I remembering ghosts or is there something like that ?
17:39:09 <Zearen> (It's not Typeable)
17:39:12 <geekosaur> and after several attempts at it, I want to banish gnome3 until they make it usable...
17:39:23 <cfoch> geekousaur: how do you install it? via cabal?
17:39:52 <geekosaur> ...
17:40:32 <cfoch> ?
17:40:55 <geekosaur> apparently when I said "then I can't help you" you understood it as "I am Fedora expert"??
17:43:36 <pharaun> cfoch: tl;dr here's 3 approaches. 1) find the wx*whatever* package and their -dev on fedora repo, 2) if does not exist, find srpm or build your own and install those, 3) finally there's always the ol make --prefix trick to install local libraries then point haskell toward this
17:43:50 <cfoch> geekosaur: No... I just know you (at least) could  installed wxHaskell...
17:43:56 <pharaun> i use #3 lots at work because i don't have root
17:44:11 <pharaun> cfoch: installing wxHaskell is done via cabal yes, but you still need the wx* library first
17:45:26 <geekosaur> interesting that you know I "could installed"
17:45:52 <pharaun> geekosaur: you're a world-class expert at installing :)
17:45:56 <geekosaur> my main environment is OS X and not even remotely applicable to Linux. my secondary is SL6 and I don't try to use WxHaskell there
17:46:58 <geekosaur> I'm reasonably familiar with the RHalike way of managing packages, but not the specifics of Fedora; and I wonder if you have something turned off, or did your search wrong, that you did not find a devel package
17:47:21 <geekosaur> because it would be highly unusual for Fedora to have not split it into runtime libs and devel libs+headers
17:47:28 <pharaun> ^
17:47:44 <pharaun> if there is runtime libs there *is* going to be a devel version somewhere
17:47:54 <cfoch> oh... wxGTK-devel is available
17:48:27 <mm_freak> how do i provide a hackage-compatible changelog?
17:49:01 <geekosaur> ok, you *will* need to install that for the Haskell binding to build at all
17:49:15 <mm_freak> to replace the "No changelog available"
17:49:25 <cfoch> geekosaur: only those packages? wxGTK-devel, wxGTK-gl and wxGTK-media?
17:49:31 <geekosaur> probably
17:49:47 <geekosaur> they should pull in any other dependencies you need
17:50:10 <cfoch> so...now...cabal install wxhaskell?
17:50:55 <kayloos> Inside a monadic computation, namely a writer monad, is it possible to read the contents of your writer type?
17:50:59 <cfoch> cabal install wx... i think
17:51:18 <pharaun> something like that ^ after you got the devel stuff installed in fedora, you should be able to go go
17:51:28 <geekosaur> cabal install wx, yes
17:51:32 <jmcarthur> kayloos: if you want to also read it you should use state instead of writer
17:52:19 <geekosaur> (that should build wxcore and some other stuff)
17:53:29 <cfoch> oh man... -> http://fpaste.org/51369/13835295/
17:53:40 <cfoch> It fails
17:54:15 <mm_freak> kyrre: you can listen on a subwriter, but there is no "contents written so far"
17:54:19 <jmcarthur> or i guess you could use the Knot monad (which i just now named):   newtype Knot s a = Knot (ReaderT s (Writer s a)); runKnot :: Knot s a -> a; runKnot (Knot k) = let (x, s) = runWriter (runReader k s) in x
17:54:20 <mm_freak> oops
17:54:26 <mm_freak> kayloos: that was for you
17:54:40 <jmcarthur> code not type checked
17:54:55 <pharaun> yer missing libraries cfoch
17:54:59 <jmcarthur> maybe want that to be an irrefutable pattern, too
17:55:18 <mm_freak> kayloos: no need to switch to State though…  you can spy by using 'listen'
17:55:36 <geekosaur> cfoch, possibly that means you don't have an appropriate version of wxwindows installed. but debugging this is a bit beyond what I can do
17:56:02 <kayloos> jmcarthur, mm_freak: I need to read something in order to write all the values inbetween. Let's say i'm writing a logger that logs numbers, but instead of logging just the numbers, I want to log all the numbers inbetween like so: `log 1 >> log 4' should result in [1,2,3,4]
17:56:27 <mm_freak> kayloos: mapM_ log [1..4]
17:56:39 <mm_freak> like that?
17:56:48 <jmcarthur> kayloos: you could just store the min and max and then produce the actually numbers in the run function
17:56:52 <jmcarthur> *actual
17:56:54 <mm_freak> but that's actually a type error
17:57:35 <mm_freak> kayloos: note that the log type itself is a monoid, so you can construct arbitrary combinations, as long as you follow the rules
17:58:00 <mm_freak> data Log a = Empty | Single a | Range a a | Both (Log a) (Log a)
17:58:02 <mm_freak> something like that
17:58:22 <kayloos> hmmmmm
17:59:07 <cfoch> geekosaur: how can I know what version do I need?
17:59:16 <jmcarthur> (Min a, Max a); log x = tell (Min x, Max x)
17:59:18 <geekosaur> it told you
17:59:40 <geekosaur> Warning: No config found to match: /usr/lib64/wx/config/gtk2-unicode-release-2.8 --version=2.9 --version-full
17:59:48 <ad-hominem> IM an oo thinker, any book that would suit me?
18:00:01 <ad-hominem> I'm also on windowze :3
18:00:06 <geekosaur> (also I hope you did not end up with the 32 bit version or something)
18:01:19 <chrisdone> ad-hominem: Learn You a Haskell
18:01:21 <mm_freak> kayloos: if the log should always be an interval, then jmcarthur's solution works even better
18:01:24 <kayloos> jmcarthur: that was also my first idea but it seemed more elegant to do monadically
18:01:36 <chrisdone> ad-hominem: just leave your OO shoes and coat at the door on your way in
18:02:03 <ad-hominem> ok
18:02:05 <cfoch> it needs 2.9?
18:03:14 <kayloos> mm_freak: yes i am prone to agree...
18:03:35 <geekosaur> 2.9 actually changed a lot of stuff, I believe
18:03:54 <kayloos> mm_freak, jmcarthur: I think I will just do the intervalling afterwards, despite my problem description (lol)
18:03:59 <mm_freak> kayloos: it's about as elegant as you can get…  it's a product monoid =)
18:04:00 <funky_> .
18:04:04 <kayloos> Thanks for the help though guys!
18:04:15 <mm_freak> kayloos: instance (Monoid a, Monoid b) => Monoid (a, b)
18:05:39 <cfoch> I have 2.8.12 and I was reading Fedora didn't want to update to 2.9.x
18:06:59 <mm_freak> ad-hominem: java-OO or smalltalk-OO?
18:07:14 <mm_freak> i.e. classes with inheritance or message passing?
18:07:35 <ad-hominem> jst C++
18:08:10 <geekosaur> ok, then you won't be able to build that version of wx. there's an older version for 2.8 I think, but you'd have to ask the wxhaskell folks
18:10:13 <mm_freak> ad-hominem: welcome to a new reality…  but you'll have to leave your OO at the portal…  you can pick it back up when you leave =)
18:11:23 <cfoch> I lost the connection
18:12:41 <cfoch> look -> http://sharkcz.livejournal.com/11207.html
18:12:56 <desheng> is the use of $ considered poor form?
18:13:10 <khyperia> I was just playing around in privmsg lambdabot, and...
18:13:11 <khyperia> :t (=<<) (=<<) (=<<)
18:13:12 <lambdabot> (b -> b -> b) -> b -> b
18:13:17 <mm_freak> desheng: that question could cause a flamewar =)
18:13:19 <khyperia> how the heck does that work and what does it do?
18:13:25 <desheng> ok, sorry
18:13:31 <startling> desheng: it depends.
18:13:47 <startling> khyperia, (->) r is a Monad.
18:13:53 <geekosaur> khyperia, my guess is it's using the function instance of Monad ((->) r)
18:14:04 <mm_freak> desheng: my personal opinion is that you should think twice before using it…  it's not universally wrong, but making code flat is not always the best idea
18:14:06 <startling> > (=<<) (=<<) (=<<) const 12
18:14:08 <lambdabot>   12
18:14:12 <desheng> it's useful to make functions "just work"
18:14:15 <startling> > (=<<) (=<<) (=<<) (+ 1) 2
18:14:17 <lambdabot>   Occurs check: cannot construct the infinite type: b0 = m0 b0
18:14:17 <lambdabot>  Expected type...
18:14:21 <startling> > (=<<) (=<<) (=<<) (+) 2
18:14:23 <lambdabot>   6
18:14:29 <startling> haha, neat
18:14:36 <startling> > (=<<) (=<<) (=<<) (*) 2
18:14:38 <lambdabot>   8
18:14:40 <mm_freak> desheng: you will appreciate parentheses when revisiting code you wrote six months ago
18:14:42 <desheng> yeah I gotcha. I end up feeling like there's a more elegant way to do the function
18:14:48 <startling> khyperia: nice discovery
18:15:01 <cfoch> We are using wxhaskell in our class
18:15:04 <startling> > (=<<) (=<<) (=<<) f x :: Expr
18:15:05 <lambdabot>   f (f x x) x
18:15:10 <startling> khyperia: ^
18:15:11 <khyperia> Heh, I discovered a thing!
18:15:21 <ad-hominem> > show "hello world"
18:15:22 <lambdabot>   "\"hello world\""
18:16:27 <khyperia> Also, thanks for showing that Expr thing
18:16:29 <khyperia> I didn't know that
18:16:32 <startling> it's handy.
18:16:34 <desheng> is there a GHCi addon that does the same thing that lambdabot's "@src" query does?
18:16:47 <ad-hominem> is haskell interpreted or compiled?
18:16:59 <startling> khyperia: you can get it from http://hackage.haskell.org/package/simple-reflect
18:16:59 <mm_freak> desheng: nope, but you can install lambdabot locally and invoke it as a command line program
18:17:10 <startling> ad-hominem: Haskell is neither. GHC can do both.
18:17:15 <khyperia> ad-hominem, depends on the implementation. GHC is compiled.
18:17:15 <mm_freak> the IRC functionality is really just a plugin
18:17:16 <desheng> oh cool! I'll check that out. thanks
18:17:27 <khyperia> Well, what startling said.
18:18:11 <ad-hominem> is lambdabot programmed with haskell?
18:18:33 <startling> ad-hominem: it's written in Haskell, yeah.
18:18:34 <cfoch> do you know if Ubuntu have problems with wxhaskell?
18:18:37 <khyperia> ad-hominem, https://github.com/mokus0/lambdabot
18:18:43 <cfoch> Ubuntu 13.10
18:18:48 <ad-hominem> k
18:19:12 <ad-hominem> lol haskell seems to have more build in functions than c++
18:19:12 <desheng> oh it's even in the ubuntu repos :D
18:19:43 <cfoch> desheng: wxhaskell?
18:20:10 <khyperia> ad-hominem, I think these are all the default functions. http://hackage.haskell.org/package/base
18:20:22 <khyperia> default, built-in, same thing. Base package.
18:21:11 <ad-hominem> ok
18:21:19 <khyperia> ad-hominem, the Prelude is probably the most interesting to you, since it's all the automatically imported things. http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html
18:21:41 <geekosaur> right now base is partially defined by what ghc needs to build itself. gradually things are being moved out of it though
18:21:46 <ad-hominem> ok
18:22:02 <geekosaur> Prelude is the standard functions. there's also the haskell platform which is a collection of many packages
18:22:36 <gienah> cfoch: dev-haskel/wxhaskell builds in the gentoo-haskell overlay. So the gentoo or sabayon linux distros would work. Or you could look at how we build it for patches and hints: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/wxc https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/wxcore https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/wxdirect https://github.com/gentoo-haskell/g
18:22:42 <mm_freak> ad-hominem: haskell has /less/ builtin functions than C++
18:22:57 <mm_freak> however, the base library is quite large
18:24:08 <geekosaur> also I should note that there is a difference between built-in and standard library. the actual built-in list is small
18:24:11 <roboguy__> C++ has a really big builtin library. the STL in addition to all the standard C libraries
18:24:26 <mm_freak> i wasn't even counting the STL
18:24:30 <geekosaur> most of the Prelude is haskell code
18:24:49 <khyperia> is there any *non*-haskell code in the Prelude?
18:24:55 <mm_freak> haskell in its core is a fancy language to define functions and apply them
18:25:22 <mm_freak> khyperia: C-preprocessor-code
18:25:24 <roboguy__> khyperia: well, stuff like IO actions and seq
18:25:33 <khyperia> ah
18:25:34 <roboguy__> unless that's not considered part of the Prelude
18:25:44 <geekosaur> khyperia, it re-exports various things which are implemented in terms of primitives, although I think not much in the way of actual primitives (unless you count, say, []/(:))
18:25:56 <mm_freak> some of the functions are opaque and are provided by the corresponding target's run-time system
18:26:03 <mm_freak> things like primitive IO actions
18:26:24 <roboguy__> I would imagine that the majority is in haskell though. probably by a big margin
18:27:19 <mm_freak> the majority is…  it's things like memory management, calling libc functions, concurrency, parallelism, etc. that are provided by the compiler/RTS
18:27:23 <geekosaur> it also does not export (say) the primitive implementation of Int#, although it surely uses the higher level wrapper Int
18:28:16 <pharaun> do we have a list of built in items in haskell, or if i dig into the source and see a PrimOp, i can assume that is a built-in ?
18:28:53 <geekosaur> in general if it ends with # it's a builtin / primop of some kind.
18:28:56 <mm_freak> i don't think there is a list, but if a name ends in "#", you can safely assume that it's builtin
18:29:31 <mm_freak> pharaun: for GHC the GHC.* tree of modules should give you most of what is available to user code
18:29:43 <mm_freak> however, not everything there is primitive
18:29:43 <pharaun> mm_freak: k sweet thanks
18:29:54 <pharaun> would be surprised if everything in there was :)
18:30:08 <mm_freak> also don't import those modules in production code unless you know what you're doing =)
18:30:23 <pharaun> haha i've done some ghc imports before (plugin code)
18:30:34 <pharaun> but yeah it was more of an demo project anyway so...
18:30:45 <mm_freak> even then it's probably better to use one of the plugin libraries
18:30:50 <pharaun> yeah
18:31:04 <pharaun> i was mainly trying to teach myself exactly how the library loading/building thing worked
18:31:35 <pharaun> so i could have it load in "plugins" but yeah using one of those library would be better
18:32:12 <pharaun> never did figure out if reloading/removing code was even possible
18:33:08 <startling> pharaun: I think it's coming out in 7.8
18:33:33 <pharaun> oh it is? sweet
18:33:50 <startling> yeah! SPJ did it.
18:33:52 <pharaun> in the end what i did was do a proxy daemon and had it switch to the new version when i restarted
18:33:55 <pharaun> anyway sweet!
18:34:06 <startling> iirc
18:34:06 <pharaun> looks like i'll need to dig..
18:34:48 <pharaun> probably more reliable to just spawn a new process and redirect the proxy :) but yeah it was kinda fun to dig into that, looks like i'm going to have to get 7.8, still on 7.6 i think
18:42:15 <Zearen> Is there an immutable hash table, or something amiable to building a lookup table that needs to be created exactly once ?
18:42:42 <geekosaur> Data.Map is the usual lookup table, but there are several other kinds available
18:43:42 <Zearen> Yeah, normally I'd use Data.Map, but I'm doing a bunch of lookups in a largish table.
18:44:23 <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/unordered-containers-0.2.3.0/doc/html/Data-HashMap-Lazy.html (also Strict variant) ?
18:44:42 <startling> I think mauke or mm_freak wrote a thing optimized for large immutable datasets
18:45:00 <startling> I forget who it was or what it was called.
18:45:09 <startling> It definitely exists, though. :)
18:45:42 * startling . o O ( A nonconstructive proof of existence? )
18:47:50 <Zearen> Hmm, I'll see if I have to find it.  HashMap just looks like Map for Hashable instead of Ord.  I'm after the O(1) lookups :)
18:49:36 <johnw> does any data structure have O(1) lookups besides arrays
18:50:22 <startling> johnw, uh, hash maps with perfect hashes?
18:50:28 <geekosaur> not even arrays if you're being pedantic
18:50:30 <johnw> fair enough!
18:50:59 <startling> geekosaur: oh?
18:51:02 <sleepynate> johnw: i think you mean O(n)
18:51:30 <geekosaur> we ignore the hardware level stuff for the most part
18:51:31 <johnw> i meant O(1), because that's what Zearen asked for
18:51:53 <path[l]> why do arrays not have O(1)? Do you mean because for a large enough array, eventually you'll come to the limits of memory on a single machine
18:52:04 <johnw> I guess he means they are O(~1)?
18:52:23 <johnw> (i.e., depending on the size of the array, accessing elements outside the cache boundary can be orders of magnitude slowers
18:52:24 <sleepynate> johnw: sorry i misread
18:52:28 <startling> Zearen, the thing I'm (mis)remembering was actually a big array with bisection sort, and it had shockingly better performance than Data.Map iirc.
18:53:34 <geekosaur> path[l], technically anything that we refer to as O(1) is actually O(log n) at the hardware level. but since everything has the same skew applied to it we can pretend it's O(1)
18:53:46 <startling> So, uh, take algorithmic complexity with a grain of salt.
18:54:12 <geekosaur> but only a small grain since this doesn't really matter that much unless you're actually working at the level of logic probes and such :)
18:54:34 <geekosaur> (or if you're being unbearably pedantic, as happens sometimes around here)
18:54:37 <startling> a benchmarking-sized grain of salt.
18:54:43 <path[l]> I dont get how memory access for an array is O(log n) at the hardware level
18:54:47 <path[l]> can you tell me more about that
18:54:50 <Zearen> That sound like what I want.  O(n) to build, then O(1) to look up, but immutable, or O(n) insertion.
18:54:53 <path[l]> I thought you calculate the offset
18:54:57 <path[l]> and then jump straight to it
18:55:42 <startling> Zearen: there's apparently http://hackage.haskell.org/package/PerfectHash
18:56:08 <startling> which is pretty limited, but you know.
18:57:14 <geekosaur> as I understand it, largely because we pretend things are parallel, but inside a memory chip it's typically serial. otherwise you'd need much larger and more complex (and slower, canceling out the advantage) addressing hardware
18:57:56 <geekosaur> really to understand it means going and taking some EE courses
18:58:07 <geekosaur> (I only supported EE types, not studied it...)
18:58:49 <geekosaur> there are a lot of tradeoffs that had to be made at the chip level, but above that level we handwave them away and pretend and mostly get away with it
18:59:04 <srhb> Eureka, I can write to my shell in a different pty now!
18:59:19 <Zearen> But that's not really O(log(n)) in terms of the data size, so it's effectively constant, right ?
18:59:23 <srhb> That only took a few days...
18:59:57 <geekosaur> Zearen, I don't recall exactly where the log factors come in
19:00:05 <chrisdone> Zearen: well, if it doesn't relate to the input size you're not talking about computational complexity
19:00:23 <geekosaur> someone around here periodically tries to explain it to us hoi polloi, and it usually just rolls off :)
19:01:59 <Zearen> chrisdone:  I think he's talking about the multiplexers, which would be unrelated to the data size.  So yeah, that's basically my point.
19:02:37 <Ralith> 18:47:20 < startling> Zearen, the thing I'm (mis)remembering was actually a big array with bisection sort, and it had shockingly better performance than Data.Map iirc.
19:02:41 <Ralith> aren't those asymptotically identical?
19:02:46 <Ralith> modulo locality
19:03:43 <startling> Ralith, yeah. Whoever wrote it attributed the performance gains to locality as I recall.
19:04:06 <Ralith> oh, I read 'better' as 'similar' for some reason
19:04:09 <Ralith> cool
19:04:42 <startling> Zearen: aha: http://hackage.haskell.org/package/quickset
19:05:52 <startling> it /was/ mm_freak
19:05:58 <Zearen> Woot.
19:06:23 <startling> Zearen: you probably want to benchmark anyway. :)
19:08:15 <Zearen> True.
19:09:13 <lpaste> srhb pasted “Possibly not horrible way to get a pty” at http://lpaste.net/95175
19:09:22 <srhb> ^-- how does child look now?
19:09:34 * srhb hopes she's somewhere in the ballpark of maybe sorta right
19:09:34 <Zearen> And write tests.  I used to never write tests, then I learned their beauty at a new job.  So I guess I'll have to find a good Haskell test framework now...
19:10:44 <srhb> Zearen: Just throw quickcheck at everything and pretend all's good. :-)
19:11:02 <srhb> Zearen: (Otherwise there's HUnit..)
19:12:13 <startling> Zariel: hspec is nice
19:12:32 <startling> (it lets you use both quickcheck and HUnit's things)
19:13:41 <mm_freak> Zearen: i use test-framework
19:15:37 <mm_freak> and yes, for a query-only data structure using a sorted Vector gave a huge performance boost
19:16:29 <Zearen> Hmmm.
19:16:51 <Zearen> Oh, so this is just binary search.
19:17:13 <mm_freak> yeah
19:18:43 <Ralith> even union is only O(n+m), isn't it?
19:19:15 <Ralith> not sure about intersect off the top of my head but I wouldn't be surprised if it was fastish
19:19:45 <startling> Ralith, how is union O(n + m)?
19:20:41 <Ralith> startling: it's a merge of two sorted arrays
19:21:16 <startling> Oh, I see how you do it. You keep an index to where you are in the other one.
19:21:16 <mm_freak> Ralith: correct, although the library is quite spare
19:21:52 <mm_freak> startling: or you takeWhile alternatingly
19:23:05 <startling> mm_freak: oh, that's a neat solution.
19:23:26 <startling> @src union
19:23:26 <lambdabot> union = unionBy (==)
19:23:30 <startling> :/
19:23:34 <startling> @src unionBy
19:23:35 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
19:24:03 <startling> :t deleteBy
19:24:05 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
19:24:20 <startling> :t filter . (==)
19:24:22 <lambdabot> Eq a => a -> [a] -> [a]
19:24:30 <startling> :t (filter .)
19:24:31 <lambdabot> (a -> a1 -> Bool) -> a -> [a1] -> [a1]
19:24:40 <startling> that's, uh, a strange function to exist.
19:24:58 <startling> @src deleteBy
19:24:58 <lambdabot> deleteBy eq x []        = []
19:24:59 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
19:25:03 <cfoch> pharaun: I installed wxGTK-2.9
19:25:05 <startling> heh.
19:26:07 <cfoch> from source.... and... http://fpaste.org/51378/13835350/
19:26:13 <cfoch> it fails
19:32:16 <roboguy__> does ghci not support ARM? I didn't see it when I installed haskell platform on a raspberry pi
19:32:42 <startling> roboguy__, yeah, neither ghci nor TH work on ARM.
19:32:49 <roboguy__> hmm
19:32:53 <startling> it's a (lack of?) linker problem
19:33:09 <roboguy__> startling: it can't use the llvm linker?
19:33:23 <startling> *dynamic linker
19:33:39 <startling> I don't know very much about it. Does llvm provide a dynamic linker?
19:33:43 <roboguy__> ah
19:33:48 <roboguy__> hmm. I'm not sure
19:33:56 <thoughtpolice> 7.8.1 should work fine on ARM
19:34:00 <hamster007> hey guys I have a question: can scala's type inferrence do what haskells can do   i.e. can it infer the types of function parameters from usage?
19:34:02 <startling> I don't know much about the problem; that's what other people have told me.
19:34:05 <thoughtpolice> the support was kind of buggy before unfortunately
19:34:06 <startling> thoughtpolice: oh, nice.
19:34:28 <roboguy__> thoughtpolice: what's the best way to go about upgrading to that if I already have the haskell platform installed?
19:34:31 <thoughtpolice> roboguy__: GHC has its own dynamic linker
19:34:42 <thoughtpolice> and until recently (and still in HEAD) the support is buggy
19:34:45 <thoughtpolice> roboguy__: 7.8.1 is not out yet
19:35:08 <thoughtpolice> i need to push a fix bgamari made to flush caches and properly implement some other stuff in GHCi, then it should be quite solid
19:35:35 <hamster007> I am a haskeller who is forced to use scala and I need to know if it can do this
19:35:45 <roboguy__> thoughtpolice: I thought it was available on github. or is that version just not quite here yet at all?
19:35:54 <hamster007> the scala room isn't answering
19:35:59 <thoughtpolice> roboguy__: it is not *officially* released, but you can download it
19:36:09 <thoughtpolice> the RC should happen soon
19:36:16 <thoughtpolice> i was going to do it friday, but i've been behind this week
19:36:26 <roboguy__> thoughtpolice: hmm, maybe I should wait then if it's going to be soon
19:36:32 <thoughtpolice> of course building GHC on a raspberry pi will probably take like
19:36:36 <moops1> no hamster007
19:36:37 <thoughtpolice> upwards of 12 hours i'd bet
19:36:39 <thoughtpolice> who knows
19:36:57 <hamster007> I hate it
19:37:04 <thoughtpolice> my ARM machine can do it in like 3, but it's a powerful quad core (1.6ghz or so) w/ 2gb of RAM. the rpi is a pipsqueak in comparison
19:37:08 <roboguy__> thoughtpolice: what if I built it in a VM then moved it over somehow?
19:37:14 <moops1> scala only has local type inference
19:37:28 <thoughtpolice> in practice i find emulators like qemu pretty slow
19:37:34 <thoughtpolice> but that would probably work
19:38:03 <thoughtpolice> you need to emulate the exact revision of the RPi hardware however, because it's a very peculiar CPU chipset
19:38:18 <thoughtpolice> (notably it's ARMv6 but has hard-float VFP3 support)
19:39:09 <thoughtpolice> i do plan on making ARMv7 binaries available for the 7.8.1 release
19:39:21 <thoughtpolice> at least. i could probably do an RPi build too but i'd need to dust it off
19:40:54 <thoughtpolice> (ideally, in the future you'll be able to just build a x86->ARM cross compiler and have it work.)
19:41:14 <johnw> thoughtpolice: how far are we from having that, thoughtpolice?
19:41:22 <thoughtpolice> well, stage1 works
19:41:32 <thoughtpolice> modulo some fiddling that could be fixed in the build system
19:41:46 <thoughtpolice> stage2 is a bit farther off, and a bit more complicated
19:41:50 <thoughtpolice> mostly because of template haskell
19:42:04 <thoughtpolice> well, GHCi in general, i guess
19:42:45 <thoughtpolice> there is a path forward to do this at least, but it has some complications that are maybe tricky to get around
19:47:16 <moops1> is it discouraged to name a data type the same thing as its (only) constructor? ie data Thing = Thing Int
19:48:10 <johnw> no, that's quite common
19:48:21 <moops1> ah okay good
19:48:31 <moops1> was driving myself a bit nuts trying to figure another name for it
19:51:25 <chare_> we should make a game in haskell
19:51:28 <Ralith> moops1: another common convention is to name it MkThing
19:51:40 <Ralith> makes pattern matching look a bit weird though
19:51:50 * hackagebot time-exts 1.0.2 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-1.0.2 (EnzoHaussecker)
19:54:33 <chare_> Ralith have you ever made a game in Haskell?
19:55:00 <Ralith> chare_: yes.
19:55:21 <chare_> ralith ok so lets make starcraft successor with haskell
19:55:22 <chare_> ok
19:55:48 <moops1> shoot youre too late chare_
19:55:54 <moops1> they already made starcraft 2 :(
19:56:08 <chare_> starcraft 2 sucks shit
19:56:11 <chare_> we need something better
19:59:43 <Ralith> I play planetary annihilation, myself
19:59:48 <Ralith> but this is off topic
20:01:44 <aupiff> chare_: a game in haskell sounds really fun. have you ever played with helm?
20:02:05 <chare_> ralith planetary annihilation sucks shit
20:02:09 <chare_> its a one off novelty
20:02:21 <Ralith> if you say so
20:02:27 <chare_> you build a bunch of tanks
20:02:29 <chare_> have a battle
20:02:36 <chare_> do that like 3 times and the game gets boring
20:02:49 <srhb> @faq Can Haskell make tanks funny?
20:02:49 <lambdabot> The answer is: Yes! Haskell can do that.
20:02:54 <srhb> Problem solved.
20:02:58 <startling> how is ghc.js for json stuff?
20:04:23 <chare_> so question how do you architect a game for a purely functional language like haskell
20:05:01 <srhb> chare_: Depends on the game I suppose.
20:05:45 <srhb> chare_: The most complicated game I've written in Haskell was snake. :-)
20:05:57 <aupiff> john carmack describes rewriting doom in haskell at a talk he gave at quakecon
20:05:58 <startling> chare_, "purely functional" doesn't mean you can't be stateful, it just means that you have to be explicitly stateful
20:06:35 * ski . o O ( "Stateless state" )
20:06:40 <srhb> aupiff: Wolfenstein, and "describe" is probably a big word :P
20:07:31 <chare_> so team haskell we are going to make a successor of starcraft in haskell
20:07:34 <chare_> we all on board?
20:07:48 <srhb> chare_: I'll be cheering on you from the side lines :P
20:08:02 * ski . o O ( <http://www.c64-wiki.de/index.php/Castle_Wolfenstein> )
20:08:14 <chare_> srhb why won't you help
20:08:34 <srhb> chare_: Well, for one you haven't really pitched an interesting idea yet.
20:08:53 <srhb> chare_: If you come up with a concept I'll be sure to consider it. :)
20:08:54 <ski> chare_ : i thought you were going to write it in Scheme ..
20:08:54 <chare_> how can you think starcraft is not interesting
20:09:05 <chare_> ski do i know you?
20:09:11 <ski> i don't think so
20:09:18 <chare_> so where did scheme come from
20:09:24 <ski> from #scheme
20:09:30 <chare_> how is that relevant?
20:10:03 <ski> it's another programming language
20:10:28 <ski> perhaps you want to write it in several languages, to compare
20:10:55 <srhb> I'd love to see a Starcraft implementation in either Scheme or Haskell. I think it's a slightly large project for a beginner, though.
20:11:24 <chare_> srhb so help the project
20:11:32 <chare_> no cheering
20:11:35 <chare_> from side line
20:11:37 <srhb> chare_: I too am a beginner, and I don't find it very interesting either.
20:11:58 <chare_> so you like shitty games like call of duty and battlefield
20:12:16 <startling> haha
20:12:19 <srhb> chare_: I meant the project, I have no opinion on the game.
20:13:25 <simpson> chare_: There are several techniques for writing games in Haskell. FRP is one way. Big StateT IO loops are another (and the lens library makes this quite tenable nowadays).
20:16:16 <chare_> simpson ok so you make first commit to the project?
20:17:04 <simpson> chare_: Sure!
20:17:12 <simpson> chare_: When did you want to start? I'm thinking sometime around 2017.
20:17:22 <simpson> I have another game to write in the meantime, and a full-time job...
20:17:29 <srhb> main = undefined -- beat ya to it!
20:17:33 <startling> chare_, github will make the first commit to projects for you nowadays
20:17:34 <chare_> why does everyone always get resistant about making the inital commit
20:17:43 <gipp> i thought this was tongue-in-cheek at first but now I'm not sure
20:17:58 <srhb> chare_: We're just trying to help you get your feet wet on your own. :-)
20:18:10 <srhb> gipp: Oh I doubt that. *grins*
20:18:22 <simpson> chare_: Okay, I'll play your game. I made the first commit to a library called "gemstone"; it is possibly useful to you.
20:18:28 <simpson> chare_: Your turn!
20:18:54 <chare_> simpson link to it
20:19:08 <chare_> WHY DOES EVERYONE HATE STARCARFT
20:19:11 <chare_> I DON'T UNDERSTAND IT
20:19:19 <arpunk_> shitty game, what can I say
20:19:34 <simpson> chare_: http://hackage.haskell.org/package/gemstone
20:20:13 <simpson> chare_: You're asking for a non-trivial time investment, and you're not really taking no for an answer.
20:20:47 <hamh> Hi
20:20:52 <srhb> hamh: Hi there. :)
20:20:52 <chare_> simpson you need to dump your girlfriend to create the time for the game
20:20:58 <simpson> chare_: So I'm calling your bluff. Go make 116 non-trivial commits, and then I'll take your demand for help seriously.
20:21:18 <gipp> oh, he _is_ faking
20:21:19 <simpson> chare_: Ha! Okay, yeah, have a good day.
20:21:21 <gipp> why is he so committed
20:21:28 <chare_> you're doing initial commits since I don't know how to do opengl stuff with Haskell
20:21:41 <simpson> Go *learn*.
20:21:48 <srhb> chare_: There's actually some nice, if slightly outdated, tutorials on the haskell wiki
20:21:59 <srhb> chare_: It's pretty simple getting some stuff up on the screen.
20:22:44 <chare_> I read the Learn you a Haskell book cover to cover
20:22:47 <chare_> what do I do next
20:22:54 <srhb> chare_: Code stuff. :-)
20:23:06 <chare_> need more guidance than vague
20:23:58 <startling> chare_, read an opengl book probably
20:24:09 <startling> the opengl bindings for haskell are pretty straightforward
20:24:45 <simpson> chare_: Go do what I did when I was 13: Commit to a project that is far too large for you to do, brashly claim that you'll be able to do it, then spend several late nights figuring out how to make a GL screen that has the screen painted red and blue.
20:25:04 <chare_> I can already use opengl on c++
20:25:09 <chare_> thats not the probelm
20:25:16 <hamh> I'm messing around with hmatrix a bit and wrote this: multiplyR (multiplyR (pinv (multiplyR (trans x) x)) (trans
20:25:19 <srhb> chare_: It's much the same in Haskell. The layer is very thin.
20:25:21 <hamh>     x)) y
20:25:45 <chare_> so I need to do pathfinding for starcraft clone in haskell
20:25:49 <chare_> how the hell do you do a graph in haskell
20:25:55 <hamh> ahh.. thanks tmux. bleh. Anyway I was wondering how to make that a bit more idiomatically haskell looking
20:26:03 <srhb> chare_: try googling graph and haskell
20:26:31 <davidfstr> Why is foldl1 called foldl1? What does the 1 stand for? (I already know what this function does.)
20:26:40 <srhb> chare_: There are even some very nice and polymorphic a* algorithms on Hackage ready for consumption.
20:26:44 <AshyIsMe> chare_: let me know when you have a playable version, starcraft is sweet
20:26:46 <srhb> davidfstr: "I promise there's at least one element"
20:26:56 <moops1> start with 1st element?
20:27:04 <hamh> The actual expression is: multiplyR (multiplyR (pinv (multiplyR (trans x) x)) (trans x)) y
20:27:15 <geekosaur> foldl a list with at least one element
20:27:52 <davidfstr> srhb, geekosaur: Makes sense. Thanks.
20:28:27 <chare_> srhb i'm calling your bluff link to a* algorithm in haskell thats not slow as shit
20:29:50 <lightquake> if i have let x = f a; y = f a in g x y
20:29:58 <lightquake> is ghc smart enough to optimize that to let x = f a in g x x?
20:30:19 <funky_> yes
20:31:29 <Kron> y'know I'm trying to work on a very basic proof of concept real time game thing too. It pays to start small and work your way up. D:
20:32:02 <moops1> do haskell games usually have to have strictness annotations everywhere?
20:32:10 <Kron> that's a good question
20:32:13 <Kron> I'm not sure
20:32:13 <startling> moops1, not necessarily.
20:32:22 <lightquake> ... hm, apparently it's not that smart
20:32:28 <startling> Sometimes strictness annotations help performance, sometimes they don't.
20:32:30 <Kron> I think the laziness could be really helpful at times actually?
20:32:34 <Kron> like
20:32:38 <srhb> Kron: Indeed, it can.
20:32:46 <startling> Strictness annotations don't preclude laziness.
20:32:46 <Kron> if you build it like an imperative game, then yes you have to make it strict
20:32:53 <startling> Kron: eh?
20:32:54 <Kron> but if you build it lazily, you can do crazy things
20:33:17 <Kron> like... uh... I think my girlfriend once defined a list of all future player actions
20:33:27 <Kron> an infinite list of all future input, so she can siphon data off it
20:33:29 <triliyn> lightquake: someone said earlier that the default optimization setting is -O0. Maybe it is smarter with higher settings?
20:33:33 <triliyn> I don't actually know though
20:33:33 <Kron> that's pretty crazy and is very lazy
20:33:43 <edwardk> preflex: xseen rickasaurus
20:33:44 <preflex>  rickasaurus was last seen on freenode/#haskell 24 days, 4 hours, 8 minutes and 7 seconds ago, saying: [False, True]
20:33:45 <lightquake> yeah, i tried with -O2
20:33:47 <startling> Kron: yeah, you can do something like that. That's independent of strictness annotations though.
20:33:56 <Ralith> Kron: that's how all IO used to be done in haskell; people decided it was a bad idea.
20:34:07 <Kron> I'm just coming up with examples that can't be strictified I guess
20:34:19 <Kron> not all laziness is inherently just delayed computation you could be doing Right Now to speed up the game
20:34:22 <startling> Part of the reason that's a bad idea is because of IO, though.
20:34:30 <chare_> Kron we are making starcarft clone
20:34:34 <chare_> you going to do the work
20:34:35 <chare_> ok
20:34:47 <Kron> wellllll, by "we" you mostly mean you, right?
20:34:53 <Kron> I'm quite happy to play PA when it comes out
20:34:57 <Kron> also i'm working on a very silly chess game
20:35:08 <chare_> WTF WHY DOES EVERYONE LIKE THAT SHITTY GAME PLANETARY ANNIHALTION
20:35:11 <chare_> AND COMMAND AND CONQUER
20:35:14 <Kron> which is more than a little real time because I'm not very smart
20:35:29 <Ralith> startling: yes, IO like user input :P
20:35:32 <Kron> well because there are more real time strategy games than ones that exist in your church I guess
20:35:47 <Kron> starcraft was really nice, but it was only one of many separate very interesting lineages of strategy games
20:36:02 <startling> Ralith, eh.
20:36:08 <Kron> and frankly it was a little bit of a fluke. Even the successor made by the same company isn't quite as good despite a host of ui improvements and a lot more money
20:36:31 <Kron> at least total annihilation had some really good successors
20:36:38 <Kron> and command and conquer 3 was pretty good too
20:37:00 <funky_> sc1 story is epic and the multiplayer balance and game dynamics are phenomenal
20:37:07 <funky_> sc2 left alot to be desired in those aspects
20:37:11 <srhb> I think we can safely move the Starcraft and general non-Haskelly talk to a different channel now. :-)
20:37:12 <johnw> cool, got to use mmorph in anger for the first time!  thanks Tekmo, wherever you are...
20:37:13 <Kron> I'm more on the Destiny side of things
20:37:25 <Kron> I think the huge difference was probably Battle.net 0.2
20:37:38 <srhb> johnw: mmorph?
20:37:40 <Kron> Battlenet 1 was just... far more conducive to a nice big community than the new one
20:37:48 <Clint> @hackage mmorph
20:37:48 <lambdabot> http://hackage.haskell.org/package/mmorph
20:38:07 <Kron> the game suffered when the barrier to entry became too high and the ladder anxiety became too annoying and the chat system was so bad that it felt like shouting into an empty room
20:38:13 <Kron> now it costs like...
20:38:17 <johnw> with mmorph, I can turn a function of type "t m a -> m a" into "t (NoLoggingT m) a -> NoLoggingT m a"
20:38:18 <Kron> 100 dollars? to get into starcraft 2?
20:38:23 <funky_> yeah screw that
20:38:25 <Kron> it's literally too costly for me to get friends into it anymore
20:38:26 <srhb> Ah. Funky.
20:38:32 <chare_> exactly why we need to make a starcraft successor since blizzard fucked up starcraft 2
20:38:41 <srhb> Kron, chare_: Different channel please. :)
20:38:50 <Kron> yeah I agree
20:38:54 <chare_> srhb wheres that a* link i asked for
20:38:57 <Kron> this is less about haskell and more about oldschool RTSs
20:39:05 <srhb> chare_: I'm not your personal Google or Hoogle. :)
20:39:08 <chare_> I TALK ABOUT WHAT I WANT
20:39:10 <funky_> you can talk about sc if you can incorporate haskell with it
20:39:13 <simpson> edwardk: You've revealed yourself to be nearby; could you help out here? ^^^
20:39:18 <Kron> hmmm
20:39:19 <johnw> chare_: in that case, the ops will kick who they want :)
20:39:23 <chare_> we are talking about starcarft in haskell
20:39:24 <edwardk> uhoh
20:39:26 --- mode: ChanServ set +o johnw
20:39:27 <chare_> thats relevant to haskell
20:39:28 <edwardk> whats going on?
20:39:30 --- mode: ChanServ set +q *!*@gateway/web/freenode/ip.50.47.95.15
20:39:33 <Kron> okay, here's a sort of interesting haskelly question
20:39:39 <funky_> go on
20:39:42 <Kron> it's something I've thought about before
20:39:46 <simpson> johnw: Thank you.
20:39:54 <Kron> so, in a way, the old Starcraft style games had a very 'imperative' UI
20:40:04 <Kron> you were always selecting a unit and you would give orders to those units
20:40:10 <edwardk> johnw++
20:40:11 * cfoch gives it up... can't install wxhaskell on Fedora
20:40:14 <johnw> it wasn't me, I was waiting a few more minutes
20:40:14 <Kron> all your actions in the game came down to manipulating order queues for particular units
20:40:20 <Kron> can you make a declarative strategy game?
20:40:21 <johnw> all I did was op myself in preparation
20:40:28 --- mode: johnw set -o johnw
20:40:34 <funky_> what would a 'functional' UI be like then
20:40:35 <Kron> like... a game where you sort of state "I want a base here" and it sort of solves the problem and sends builders there to build things
20:40:40 <Kron> i'm not entirely sure
20:40:44 <Ralith> so, civ?
20:40:44 <johnw> i wonder if someone used chanserv to do the mute...
20:40:46 <Kron> but more goal declaration I guess
20:40:49 <Kron> and less direct action-telling
20:41:06 <simpson> I feel like you'd just end up with a really good Civ AI.
20:41:08 <Kron> like Globulation 2
20:41:10 <Kron> maybe
20:41:29 <funky_> some dudes made a pretty good AI for sc1 with machine learning
20:41:29 <Clint> johnw: as opposed to chanserv gaining sentience?
20:41:32 <funky_> maybe try same with haskell
20:41:44 <Kron> I think the thing I came up with is more like a Prolog RTS than a haskell one
20:41:48 <johnw> well, you can ask chanserv to mute someone, and then it won't appear as though you did it
20:41:50 <Kron> I'm not sure how to make a truly haskelly game
20:41:54 <Kron> a game which teaches haskell concepts
20:41:59 <hamh> anyone know how I can form an identity matrix in hmatrix?
20:42:23 <srhb> Kron: I've had vague thoughts about the same with no conclusion at all.
20:42:32 <srhb> Kron: So there... :P
20:42:37 <Kron> hah XD
20:42:38 <Kron> ah well
20:42:42 <lightquake> i need a short example of a program that uses unsafePerformIO and behaves differently under -O0 and -O2
20:43:02 <Kron> anyway need to finish my assignment... in C. toodles ;_;
20:43:08 <srhb> Kron: o/
20:43:24 <funky_> i wish i had the patience to start learning C
20:43:32 <funky_> but every time i try i feel like i shouldve started 30 years ago
20:43:47 <srhb> funky_: I've been digging through so much C today to try and figure out how the hell terminal multiplexers work
20:43:52 <srhb> funky_: I still don't want to learn it. <_<
20:44:25 <davidfstr> I can use "type ThrowsError = Either LispError" to mean "type ThrowsError x = Either LispError x". Is there a way to write something that means "type UsuallyInteger x = Either x Integer"?
20:44:31 <funky_> you came up with anything then?
20:44:51 <srhb> funky_: Bits and pieces. It's horrendous and undocumented, mostly.
20:45:11 <funky_> why terminal muxes though
20:45:15 <funky_> do you need to make your own? :p
20:45:18 <srhb> davidfstr: Yes, that.
20:45:49 <srhb> funky_: Not reaaaally, but I had some bits and pieces that annoyed me with tmux and I thought it'd make a great learning project.
20:46:04 <srhb> So far it's been a frustrating (and short, in LOCs) journey.
20:46:08 <Clint> edwardk: if i want to group a list of elements according to an (a -> a -> Bool) predicate, is Store the right tool for that?
20:46:12 <funky_> srhb: hehe
20:46:29 <edwardk> i have no idea how one would use a store for that.
20:46:37 <Clint> fair enough
20:47:52 <funky_> srhb: but i guess you know at least some C
20:47:56 <funky_> srhb: orr
20:48:12 <davidfstr> srhb: I'm actually surprised that notation works since I just made it up. Oddly "type UsuallyInteger X = Either X Integer" (with a capital X) does not work. Makes me think that capitalization is significant - which hopefully isn't the case.
20:48:12 <srhb> funky_: I do, yes. Nothing fancy, though.
20:48:27 <srhb> davidfstr: It is indeed the case.
20:48:49 <davidfstr> So are capitalized things always types?
20:48:58 <srhb> davidfstr: the capital letters are either type or value constructors
20:49:02 <johnw> davidfstr: also modules and value constructors
20:49:31 <srhb> davidfstr: I don't know why you think it's hopefully not the case, it's quite nice to be able to distinguish. :-)
20:49:46 <triliyn> davidfstr: and lowercase things are either values or type variables
20:50:17 <triliyn> (The conflation of these things, and of type constructors with value constructors, can be kind of annoying. But yes, otherwise it's nice to be able to distinguish them)
20:50:44 <srhb> Well I suppose value constructors oughtn't be different from any other function, but yeah.
20:50:45 <triliyn> Sadly there are only two letter cases :(
20:51:01 <triliyn> Well, I can see the reasoning for having value constructors be different
20:51:23 <triliyn> All value constructors are functions, but constructors have some additional properties that distinguish them from non-constructor functions
20:51:56 * hackagebot Chart 1.1 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.1 (TimDocker)
20:51:58 * hackagebot Chart-cairo 1.1 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.1 (TimDocker)
20:52:00 * hackagebot Chart-diagrams 1.1 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.1 (TimDocker)
20:52:02 * hackagebot Chart-gtk 1.1 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.1 (TimDocker)
20:52:26 <davidfstr> srhb: I'm always a bit wary of imposing compiler-enforced structure based on capitalization. How would you then make a type using international characters (for example) where there was no capitalization definition?
20:52:27 <triliyn> I guess it makes more sense to have them indistinguishable from normal functions than indistinguishable from types though
20:52:42 <srhb> davidfstr: I.. wouldn't. :P
20:52:47 <srhb> davidfstr: But that's just me!
20:53:12 <srhb> triliyn: Right, the important case is the type constructors. Then again, you can't accidentally put those in the wrong place, so meh.
20:54:24 <triliyn> srhb: I think lowercasing value constructors would really help with readability in cases where the type and value constructors have the same name
20:54:44 <srhb> triliyn: We can basically do that with record syntax, no?
20:54:48 <srhb> Well, not quite
20:55:24 * srhb has never really thought of this as a problem
20:55:45 <srhb> I mean, how do you accidentally mix the value and type level?
20:55:53 <triliyn> It's not really a huge problem, but I sometimes have trouble with it and have to reread once or twice
20:56:25 <newsham> > isUpper ':'
20:56:27 <lambdabot>   False
20:57:10 <simpson> > isLower ':' -- don't let me down here, Haskell
20:57:11 <lambdabot>   False
20:57:34 <triliyn> > map isLower "Λλ"
20:57:34 <srhb> What nonsense. : is clearl an uppercase .
20:57:35 <lambdabot>   [False,True]
20:58:13 <newsham> > [isLower,isUpper] <*> "Test"
20:58:15 <lambdabot>   [False,True,True,True,True,False,False,False]
20:58:28 <funky_> sum $ union [3,5..999] [5,10..999]
20:58:34 <triliyn> :t undefined :: Λ
20:58:36 <lambdabot> lexical error at character '\155'
20:58:39 <triliyn> awww
20:58:47 <triliyn> I think that's a lambdabot thing though, not a ghc thing
20:58:49 <funky_>  > sum $ union [3,5..999] [5,10..999]
20:58:56 <srhb> triliyn: It is just lamdabot
21:00:32 <funky_>  > [1..5]
21:00:45 <srhb> funky_: Now look what you did. :<
21:00:58 <funky_> srhb: how does this work
21:01:33 <geekosaur> funky_ you're typing a space before the >
21:01:42 <funky_> > "okay then"
21:01:43 <lambdabot>   "okay then"
21:04:22 <srhb> So as I understand it, fdRead fd n will return either when there's a full line ready or if n bytes have been read from fd. How would I go about wrapping that read in a way that ensures I always get a full line?
21:05:35 <stolaruk> Are there are tutorials or instructions out there for using text-format package?
21:12:12 <srhb> stolaruk: I don't think so. Anything particular causing troubles?
21:12:42 <stolaruk> srhb: I have no idea where to start. Like what a format string should even look like.
21:13:36 <stolaruk> It doesn't seem like there is any documentation anywhere. Would I just have to dive into the library code to figure out how to use it?
21:14:04 <srhb> stolaruk: Well, the hackage docs help
21:14:30 <stolaruk> Ok, let me see
21:14:49 <srhb> stolaruk: Not that they're particularly brilliant
21:15:21 <joelteon> stolaruk: you have to use {} for format sites
21:15:27 <stolaruk> Oh yes, I was poking around on those pages
21:15:56 <joelteon> i'd recommend using th-printf instead
21:15:58 <joelteon> or mauke-printf
21:16:02 <joelteon> whatever it's called
21:16:14 <stolaruk> joelteon: That's about as much as I gathered, as there is a single example I found on the doc pages:
21:16:19 <stolaruk>  f :: Format
21:16:20 <stolaruk>  f = "hello {}"
21:16:21 <frx> joelteon why, what's the difference?
21:16:31 <joelteon> between th and mauke-printf?
21:16:42 <joelteon> mauke uses splices, th uses quasiquoters
21:16:43 <stolaruk> But I don't know what {} really means.
21:16:48 <frx> between printf and mauke-printf
21:16:57 <joelteon> mauke-printf is compile time safe, printf is not
21:17:38 <frx> it uses something other than string for formatting?
21:17:43 <joelteon> no
21:17:46 <joelteon> it uses template haskell
21:18:22 <frx> interesting, I'll check it out
21:18:53 <stolaruk> Should I put printf -type formatters in {}?
21:18:56 <srhb> stolaruk: "insert things here"
21:18:58 <stolaruk> %s and %d for example
21:19:09 <joelteon> no
21:19:11 <joelteon> just {}
21:19:14 <joelteon> {} is the only specifier
21:19:17 <stolaruk> oh!
21:19:24 <stolaruk> ok, cool
21:19:31 <srhb> stolaruk: ie. format "here's a number: {}. And here's more characters: {}" (2,"foo")
21:19:39 <joelteon> yeah, that's why text-format is useless
21:20:00 <johnw> i gave up on text-format too
21:20:06 <srhb> stolaruk: ie. format "here's a number: {}. And here's more characters: {}" (shortest 2,"foo")
21:20:08 <srhb> oops
21:21:59 * hackagebot dbus 0.10.5 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.5 (JohnMillikin)
21:22:11 <stolaruk> ah, searching hackage I see there are th-printf and printf-mauke
21:22:20 <joelteon> yeah
21:22:51 <stolaruk> joelteon: Do you recommend either of these over the other?
21:23:01 <joelteon> I like th-printf more, because I wrote it
21:23:08 <stolaruk> oh cool
21:23:23 <frx> could one write type safe printf in agda without metaprogramming?
21:23:28 <joelteon> also, it uses quasiquoters rather than splices
21:23:44 <joelteon> printf-mauke would have you do $(printf "%s %d") "foobar" 10
21:23:46 <joelteon> or something like that
21:23:54 <joelteon> which is some noise
21:24:01 <joelteon> th-printf would be [s|%s %d|] "foobar" 10
21:24:07 <stolaruk> That's a TH convention isn't it
21:24:11 <joelteon> sure
21:24:14 <joelteon> that's a splice
21:24:18 <joelteon> i like quasiquoters
21:24:18 <stolaruk> right, ok
21:24:33 <johnw> i'd just use shakespeare then: [st|#{"foobar"} #{10}|]
21:24:34 <ski> srhb : hm, so you're patching TMux ? or making some thing with some similarities ?
21:24:42 <ski> triliyn : the problem with same identifier class for (value) variables and data constructors is that it's then very easy to write catch-all cases by mistake (misspelling) -- this happens in SML
21:24:53 <joelteon> johnw: good luck using width or precision specifiers in shakespeare
21:25:00 <johnw> well, true enough
21:25:06 <srhb> ski: At the moment I'm barely opening a pty - but yeah, why not, I'm making a tmux replacement. :P
21:25:37 <ski> (unreachable code error helps some, though. somewhat related, exhaustiveness checking (by default) is very nice as well)
21:25:43 <ski> triliyn : i think a nice convention is to have `data Person = MkPerson Name Age', &c. in case one can't compe up with a better data constructor name
21:25:47 <ski> srhb : "How would I go about wrapping that read in a way that ensures I always get a full line?" -- i suppose repeating until you get the whole line ?
21:26:06 <triliyn> ski: hmmm, I guess that might be a good convention
21:26:09 <srhb> ski: Yeah, I was thinking it sounded vaguely pipe-y, but I haven't touched those.
21:26:24 <srhb> I also don't know what's a brilliant amount of bytes to request.
21:26:35 <ski> srhb : ooc, which bits and pieces annoyed you with TMux ?
21:26:52 <srhb> ski: The lack of configurability of mouse buttons in copy mode
21:27:09 <srhb> ski: Specifically why can't I bind copy pipe and such to mouse-release on copy mode
21:27:51 <ski> srhb : bearing in mind that i haven't used TMux, only GNU Screen, what does "copy pipe" do ?
21:28:11 <srhb> ski: Basically tells tmux to pipe the copied region to a command of my choice
21:28:23 <ski> ok
21:29:05 <ski> so it'd prompt for a command when you release the mouse ?
21:29:23 <srhb> ski: Right, or on a specific mouse button or whatnot - but it's hardcoded in tmux
21:30:06 <srhb> ski: I made a monkey patch on my local copy, but threw a hissy fit when all I got was rudeness from #tmux in my attempt to get help to clean it up for production. :P
21:30:18 <srhb> And here I am now
21:31:38 <ski> i suppose it will at least be useful as a learning exercise
21:32:05 <srhb> ski: Yes, exactly. :) I have no higher hopes for it than that, especially at my current rate.
21:32:08 * ski has pondered making patches to Screen, but hasn't attempted to do so yet
21:32:25 <ski> (have been browsing around a little in the source, though)
21:32:49 <srhb> To be honest it wasn't _horrible_ to work with the tmux source, and from what little I've seen it's easier to deal with than the screen code.
21:32:56 <srhb> (It's just still C...)
21:32:56 * ski also knows next to nothing about terminal programming
21:33:02 <srhb> Same.
21:33:38 * geekosaur remembers writing his own screen-alike for sco unix way back when (late 80s?)
21:33:45 <srhb> geekosaur: Wow :)
21:34:14 <ski> geekosaur : if i have any questions, i might take them to you
21:34:42 <AshyIsMe> i like tmux just for the default statusbar to be honest
21:34:50 <AshyIsMe> nice defaults are a good thing
21:35:01 <ski> heh, that would be a point against it, for me ;)
21:35:07 <srhb> AshyIsMe: I think I can easily whip that up with vty-ui
21:35:27 <srhb> Though I'm not yet completely sure that's the right choice or if I should be using the vty library directly
21:35:30 <srhb> package*
21:35:39 <ski> (at least assuming the statusbar eats up a line of the character matrix)
21:35:45 <srhb> ski: It does.
21:36:10 <srhb> ski: Doesn't screen have one as well by default?
21:36:19 <ski> nope
21:36:24 <ski> no decorations by default
21:36:35 <ski> ("byobu" might be different. i don't care much for it)
21:37:00 <srhb> ski: Hm, I remember it as having one. Either way I get lost without it.
21:37:01 * hackagebot th-printf 0.2.0.1 - Compile-time printf  http://hackage.haskell.org/package/th-printf-0.2.0.1 (JoelTaylor)
21:37:03 <ski> in case the terminal itself has a hardstatus line though, Screen will use that to display its hardstatus
21:37:15 <srhb> Ah, right.
21:37:33 <ski> (in XTerm, the title row of the window (given a WM which displays such), will function as hardstatus)
21:37:37 <srhb> joelteon: Scratching an itch? :-)
21:37:44 <srhb> ski: Aye.
21:38:18 <ski> if you want to, you can display a list of the nearest surrounding windows in hardstatus
21:38:25 * ski doesn't, though
21:39:05 <ski> (instead i display other users on the window, window flags, window number, window title, window hardstatus)
21:39:36 <ski> (and window hardstatus will include all of the above for a nested Screen session, so that i can easily see where i am in the nesting)
21:39:49 <srhb> Nesting sounds scary.
21:40:03 <joelteon> yeah, I forgot to add haddocks to it. :)
21:40:15 <ski> it's common to have a local Screen, with a window connected by SSH to a remote Screen
21:40:33 <ski> one can also use multiple sessions for grouping of different tasks/topics
21:48:55 <AshyIsMe> ski: how starved for character resolution are you though that one line matters?
21:49:23 <AshyIsMe> i spose im a little spoiled by my high res monitor
21:49:43 <ski> perhaps not *that* starved usually
21:50:05 <ski> but i find it a bit visually distracting, and not that useful to me
21:51:25 <ski> (i'm more annoyed that if i split the display in several regions, each of those eat up a line for a "caption", which i don't really have much use for, either)
21:51:46 * ski would like to patch an option to disable that
21:52:12 <stolaruk> joelteon: I'm trying th-printf. I had a problem with "s" being shadowed in places where I used "s" as a variable name. I tried doing a qualified import of th-printf, but then I couldn't get my code to compile. Do you have any good strategies for this situation?
21:52:29 <AshyIsMe> ah yeap, i don't really split tmux or screen much
21:52:36 <AshyIsMe> usually just vim within them
21:52:57 <ski> yea, not that often here either, but it happens that it's really useful
21:53:00 <joelteon> you can't use qualified names in quasiquoters, can you?
21:53:26 <johnw> joelteon: I know that changed in 7.6
21:53:31 <augur> should i write a monadic-io tutorial? :x
21:53:51 <johnw> write a how to write a monad tutorial tutorial
21:53:53 <ski> augur : including what ?
21:54:08 <srhb> johnw: It's been done.
21:54:13 <augur> ski: an implementation in a non-haskell language
21:54:18 * ski . o O ( "write a how to not write a monad tutorial tutorial" )
21:54:21 <augur> ski: and a pretty picture!
21:54:21 <joelteon> write a how to write a monad tutorial tutorial tutorial
21:54:29 <ski> (ambiguous parse intended)
21:55:09 <ski> augur : with or without side-effects ?
21:55:28 <augur> ski: with side effects in the implementation language, obviously
21:56:12 <stolaruk> joelteon: Yeah doesn't look like I can use qualified name in the qq
21:56:18 <ski> getting `Lwt.t' cleaned up so that it satisfies the monad laws would be nice
21:56:54 <ski> augur : for what purpose ?
21:57:20 <augur> ski: to give an intuition to imperativists that haskell IO isnt quite as magical as they tend to thing
21:57:59 <srhb> geekosaur: Should I disable echoing on the master side I wonder? Seems a bit confusing.
22:00:12 <Zearen> How evil is it to do:
22:00:12 <Zearen> constMap = Map.fromList [(A, 1), (B, 2), (C, error "C not allowed in this context)]
22:00:39 <srhb> Zearen: Well.. You already know it's evil :P
22:00:45 <srhb> Zearen: How evil depends on your use case I suppose
22:02:14 <Zearen> It's either throwing an error there, or throwing an error when I get Nothing back from Map.lookup
22:02:18 <roboguy__> Zearen: I feel like there's probably a better way to do that, but it depends on what exactly you're doing. possibly using Either or Maybe (or maybe even a general Monoid constraint)
22:03:12 <Zearen> It's actually an error state.  If C shows up here, it means there was a logic error or corrupt data somewhere.
22:03:36 <ski> augur : be sure to emphasize reification of effects over the implementation (which might be something like `() -> a', no ?)
22:03:52 <augur> ski: what do you mean reification of effects?
22:04:04 <Iceland_jack> Zearen: Use Either/Maybe to express that
22:04:21 <roboguy__> Zearen: there would be no conceivable way to recover from it, even at some point in the future of the development of the code?
22:04:32 <ski> augur : for emphasis, you could give an alternative implementation (or sketch of it), like the `data IO :: * -> * where GetChar :: IO Char; ...' one
22:04:43 <augur> ski: yes thats my intention
22:05:48 <ski> augur : reification : that `hGetLine' returns something that *represents* the action (recipe), and that we can pass such things around, and bundle them together with each other
22:05:59 <augur> ski: yes thats the intention
22:06:35 <ski> augur : and obviously also that we want to just have one "top-level" place in which we actually initiate the execution process (where evaluation starts execution)
22:06:37 <Zearen> You could catch it in IO if you really needed to.  I can't think of a reason you'd want to know in real code.
22:06:47 <ski> augur : sounds fine, then
22:08:32 <Zearen> I mean, it's either put it there, which is evil, but feels so good, or a case Map.lookup key constMap of {Just a -> foo a ; Nothing -> error "Data corrupt"} further down.
22:09:02 <Adeon> if C appearing would be a programming error then I think your first way is fine
22:09:05 <Adeon> kind of like an assert
22:09:43 <ski> augur : also you could emphasize separation of UI (I/O) from (internal) computation, and the boons this give for "reasonability"
22:10:34 <geekosaur> srhb, in C the call you want (this is the same thing I was telling you about the other day, about stty settings) is tcsetattr(); or you can run the stty command before your shell. whether you can use tcsetattr() on the master side is still system dependent, I think; normally you use it on the slave end
22:11:06 <geekosaur> and often you copy the settings from your original terminal (*before* any changes to go into raw mode, if applicable)
22:11:23 <srhb> geekosaur: Ah, I think I was unable to understand it at the time. Thank you.
22:12:03 <roboguy__> Zearen: <$> and <*> might make it look nicer if you want to give the Maybe route a shot
22:12:44 <geekosaur> a common trick for people who don't want to try to decipher tcsetattr (or in this case any haskell binding for it) is to capture the output of `stty -g` and then feed that output as a parameter to `stty` in the slave...
22:13:51 <srhb> geekosaur: Sounds simpler.
22:15:54 <geekosaur> (be warned if you want to use this with e.g. ssh, the output of stty -g is system dependent and will probably misbehave if handed to some other system's tty. but in that case you'd be changing the settings of ssh's own pty and not yours anyway :)
22:16:06 <geekosaur> er, some other system's stty
22:16:50 <srhb> geekosaur: Roger :)
22:20:14 <Zearen> roboguy__: It's not a question of "Should I raise the error ?", it's "Where do I raise the error ?"  Having C appear in this context means the data got malformed inside the program somewhere.
22:20:27 <Zearen> Thanks for the input though ^^
22:28:27 <pharaun> *sigh* analysis paralysis sucks :)
22:28:40 <pharaun> can't make up my mind over some data structure/types
22:30:48 <edwardk> pharaun: stay up way too late until you don't care any more, then pick one and implement it, if you don't like it implement the other. if you do like it implement the other anyways, then benchmark and compare ;)
22:31:19 <Kneiva_> also a coin toss might help
22:31:34 <pharaun> :)
22:34:49 <ski> Kneiva_ : only if one could either commit beforehand to abide by it, or to realize which alternative one prefers by attemting to commit
23:00:09 <Ghoul_> every time I try to install "foldl", cabal does soemthing with fixplate
23:06:08 <Ghoul_> ugh, cabal has gone retard
23:06:21 <Ghoul_> package index corrupt :/
23:08:41 <identity> does anyone here use vim2hs for vim?
