00:36:55 <jrmithdobbs> I'm so confused by this video. His monad explanation is pretty good. But then he goes off and tries to implement some convoluted mixture of Either + currying + applicative functors in JavaScript... Right after saying functional programming isn't practical...
00:37:03 <jrmithdobbs> http://youtu.be/b0EF0VTs9Dc
00:37:45 <jrmithdobbs> So let's do it in JavaScript instead!?
00:40:46 <carter> ooooo, thats the infamous crap gonads talk
00:49:30 <arkeet> jrmithdobbs: yeah, let's not watch that one. :p
00:50:04 * hackagebot yesod-dsl 0.1.1.7 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.7 (TeroLaitinen)
01:10:06 * hackagebot simplessh 0.2.0.0 - Simple wrapper around libssh2  http://hackage.haskell.org/package/simplessh-0.2.0.0 (thoferon)
01:12:16 <ique> hey everyone, I'm giving a brief talk on Haskell and i'm trying to summarize in a slide what problem the Pipes library solves. Anyone got any good tips for me? It's hard to come up with something general and that clicks with people so they go "oh yeah i've had that problem"
01:26:46 <haasn> ique: there are some points mentioned in http://hackage.haskell.org/package/pipes-4.0.0/docs/Pipes-Tutorial.html
01:27:57 <ique> haasn: yes i've read though that one several times now.. I think it's the best material out there actually but there's not really one clear statement of the original problem, I think probably because there doesn't exist _one_ problem that pipes solves, it's many problems
01:28:34 <ique> my best attempt so far is pretty much "Long-running or complex/streaming IO in Haskell can be hard."
01:45:08 * hackagebot labyrinth-server 0.1.4.0 - A complicated turn-based game - Web server  http://hackage.haskell.org/package/labyrinth-server-0.1.4.0 (AlexeyKotlyarov)
01:50:41 <vjit> Trying out my irc client
01:51:01 <vjit> also started learning haskell today
01:51:23 <vjit> How to set up haskell mode in emacs?
01:55:48 <lpaste> Hulahoop pasted “Hugs Problem” at http://lpaste.net/95932
01:57:01 <hulahoop> hello, anyone can explain to me why this puts out errors in hugs and ghci even though I followed the tutorial word for word? http://lpaste.net/95932 Thanks.
01:58:10 <supki> hulahoop: are you sure you don't have any tab symbols anywhere?
01:58:35 <supki> hulahoop: specifically on the 4th line
01:58:50 <hulahoop> are tabs bad?
01:59:08 <hulahoop> supki: I thought they're convenient
01:59:31 <supki> they lead to confusing errors like yours :)
01:59:34 <quicksilver> they're not particularly convenietn and if you use them you have to be very careful to understand how they convert to spaces
01:59:41 <quicksilver> most people find it more convenient not to use them
01:59:49 <hulahoop> ouuuch.....
01:59:57 <hulahoop> i see it now
02:00:16 <hulahoop> deleted the tabs and now line 109 screams errors at me
02:21:02 <hulahoop> Okay, i tried this, does hugs not accept the let keyword? http://lpaste.net/edit/95932
02:23:15 <bergmark> hulahoop: you're missing an `=` after the function arguments
02:26:09 <hulahoop> bergmark: where? in the second line?
02:26:34 <quicksilver> yes
02:26:37 <quicksilver> cylinder r h =
02:27:10 <hulahoop> quicksilver: thanks
02:32:25 <ibotty> hi
02:33:21 <ibotty> what's the recommended way to use an additional hackage repo (say, an internal one)
02:33:43 <ibotty> is there a direct way or should i use sandbox'es add-source
02:34:05 <bergmark> ibotty: you can add several remote-repo's to your cabal config
02:34:45 <ibotty> and they will amend the amend the global hackage?
02:35:04 <bergmark> it will merge them in some order
02:35:16 <ibotty> sounds like what i am after
02:36:09 <ibotty> thank you
02:38:20 <mangaba_1eitosa> is there a better vim syntax highlitghing for haskell than the default one? I would like function's type signatures be displayed in a different color than function definitions...
02:39:02 <donri> mangaba_1eitosa: my vim2hs and vim-haskell does that
02:39:59 <mangaba_1eitosa> donri: does it has an alternative syntax file or it just add rules in addition to the default haskell.vim?
02:40:02 <donri> mangaba_1eitosa: https://github.com/dag/vim2hs don't recomment vim-haskell quite yet
02:40:17 <donri> mangaba_1eitosa: it replaces haskell.vim completely
02:40:29 <mangaba_1eitosa> donri: understood, thanks!
02:40:52 <mangaba_1eitosa> trying now
02:42:10 <ibotty> donri: vim-haskell is the not yet released successor, right?
02:42:19 <ibotty> i mean dag's repo is empty
02:42:29 <ibotty> is there a copy where i can play with it?
02:42:49 <donri> ibotty: it's very early in development and incomplete but https://github.com/dag/vim-haskell
02:43:22 <ibotty> yes, it has some syntax :D
02:43:28 <ibotty> but nothing else...
02:43:32 <donri> in deed
02:43:40 <donri> although to some extent that's intentional
02:43:44 <donri> vim2hs does too much ;)
02:43:59 <ibotty> ehm. yes, but no :D
02:44:21 <ibotty> syntax only is a little less than i'd have wanted :)
02:44:29 <donri> yes, it's gonna do more stuff
02:45:09 <mangaba_1eitosa> donri: hmm, it seems to collapse 'do' sequences :-)
02:45:22 <donri> mangaba_1eitosa: ?
02:45:38 <mangaba_1eitosa> donri: or maybe all all lines :-)
02:46:09 <donri> mangaba_1eitosa: oh yeah, another vim2hs stupidity. it provides folding out of the box and vim's default settings means it closes all folds :/
02:46:16 <donri> mangaba_1eitosa: try :set foldlevelstart=99
02:46:35 <ibotty> now that's a hack :D
02:46:41 <donri> not really
02:46:41 <mangaba_1eitosa> donri: thanks :-)
02:48:07 <ibotty> well, you will never have any folds closed. if that's what you want, you figured that out before, right?
02:48:33 <mangaba_1eitosa> donri: thanks, looks better indeed :-)
02:48:40 <donri> it'll just start out with folds open, which is what most users expect
02:49:07 <ibotty> hmm. but if they expect that, wouldn't they have set that before?
02:49:15 <ibotty> i expect to have folds closed...
02:49:35 <donri> point is most filetypes don't set up folding by default :) so most users never get folding
02:49:46 <ibotty> well. that's a valid point
02:49:56 <mangaba_1eitosa> donri: is there an easy way to disable unicode functionality?
02:50:00 <donri> folding is usually opt-in. with vim2hs it's opt-out, which is wrong
02:50:15 <mangaba_1eitosa> donri: I can see plenty of errors on startup if the locale is not UTF-8
02:50:16 <ibotty> mangaba_1eitosa: https://github.com/dag/vim2hs
02:50:25 <mangaba_1eitosa> ibotty: thanks, already trying it :-)
02:50:37 <ibotty> from the readme: let g:haskell_conceal              = 0
02:50:41 <donri> yeah
02:50:58 <ibotty> that was meant to be a: look there :D
02:51:27 <mangaba_1eitosa> ibotty: ah, thanks! README says it's disabled by default, though :_)
02:51:43 <ibotty> nope. only _wide_ conceals are disabled by default
02:51:49 <donri> mangaba_1eitosa: sorry bad wording. it doesn't actually say that
02:52:42 <ibotty> but you might fix your locale instead to use utf8. (fix is a pretty strong word here, but i think it is right here)
02:53:26 <donri> vim2hs should probably include :scriptencoding lines for those files...
02:53:38 <ibotty> that's right
02:54:09 <mangaba_1eitosa> ibotty: I need a 8-bit locale
02:54:16 <ibotty> why?
02:54:30 <mangaba_1eitosa> ibotty: for working with my Cyrillic text files in KOI8-R
02:54:47 <ibotty> well fix them as well to use utf8 :D
02:54:58 <mangaba_1eitosa> ibotty: grep on UTF-8 files is about 100 times slower
02:55:07 <ibotty> i know
02:55:18 <mangaba_1eitosa> ibotty: I cannot easily fix grep, so...
02:55:26 <ibotty> of course you can
02:55:31 <mangaba_1eitosa> ibotty: how?
02:55:38 <ibotty> use a function, that sets LOCALE=C before
02:55:47 <ibotty> and unsets it afterwards
02:55:50 <donri> i agree unicode conceals should be opt-in though
02:55:59 <ibotty> i agree as well though
02:56:02 <mangaba_1eitosa> ibotty: then grep won't be able to use locale for searching through Cyrillic texts
02:56:03 <donri> and use scriptencoding. not sure it would help in your case but anyway
02:56:06 <ibotty> but that was not my point anyway :D
02:56:24 <donri> (can utf-8 be losslessly converted to koi8-r?)
02:56:45 <mangaba_1eitosa> donri: I added 'let g:haskell_conceal_wide=0' to my .vimrc, but it does not help
02:56:46 <ibotty> ah. i see. then set LOCALE=whatever before. but ok. i get your point.
02:57:01 <mangaba_1eitosa> idnar: I already set my locale to what I need
02:57:03 <donri> mangaba_1eitosa: yeah that's default. you want g:haskell_conceal
02:57:08 <mangaba_1eitosa> idnar: you propose to 'fix' it :-)
02:57:16 <ibotty> mangaba_1eitosa: let g:haskell_conceal = 0
02:57:20 <mangaba_1eitosa> s/idnar/idotty/
02:58:05 <ibotty> mangaba_1eitosa: the problem with specific encodings is that you can only work with a small part of the world
02:58:17 <donri> utf-8 is a specific encoding :)
02:58:19 <mangaba_1eitosa> ibotty, donri: with 'let g:haskell_conceal = 0', there are less unicode errors on startup, but still some
02:58:26 <ibotty> but universal
02:58:48 <donri> mangaba_1eitosa: ok yeah, some of the script files might still be read...
02:58:59 <mangaba_1eitosa> ibotty: that's great, but I need to manipulate text files fast. And most of my text files are in Russian
02:59:53 <ibotty> mangaba_1eitosa: if you really need speed, of course you will take any shortcut you can find and that's ok. but as general setting it is wrong so it is to be 'fixed' :D
02:59:56 <mangaba_1eitosa> donri: here are the errors I can see: http://lpaste.net/95934
03:00:15 * hackagebot ghc-syb-utils 0.2.1.2 - Scrap Your Boilerplate utilities for the GHC API.  http://hackage.haskell.org/package/ghc-syb-utils-0.2.1.2 (ThomasSchilling)
03:00:17 <mangaba_1eitosa> ibotty: I did not encounter any problems with my default locale so far :-)
03:00:24 <mangaba_1eitosa> ibotty: so I'd better fix vim2hs :-)
03:00:32 <ibotty> that's besides the point
03:00:40 <ibotty> (and you are of course right)
03:01:07 <ibotty> 楓
03:01:08 <ibotty> :D
03:01:35 <mangaba_1eitosa> ibotty: ok, seeing '\u6953' on IRC is another locale problem :-)
03:01:54 <mangaba_1eitosa> ibotty: but I am on a Russian IRC channel that uses 8-bit locale, too :-(
03:01:54 <ibotty> now you encountered a locale problem
03:02:15 <ibotty> shouldn't your irc client handle different encodings?
03:02:42 <ibotty> it has to filter anyway, calling to iconv for irc ought not to be expensive
03:02:45 <mangaba_1eitosa> ibotty: it does... It translates UTF-8 to my locale if there is an equivalent
03:02:50 <ibotty> ha
03:02:53 <quicksilver> well encodings aren't part of IRC really
03:02:56 <donri> mangaba_1eitosa: i pushed a commit for scriptencoding, try pulling that?
03:02:58 <mangaba_1eitosa> ibotty: it's irssi, btw
03:02:59 <donri> i don't know if it will help
03:03:03 <mangaba_1eitosa> donri: thanks, tryinng
03:03:04 <quicksilver> there is a defacto standard that modern IRC channels use utf8
03:03:22 <hulahoop> Okay, I hope someone can help me. I need to define a polynomial function . Never done it, I am not even that far  with my knowledge about Haskell. The only thing I know is, that I need to do this: number -> Polynomial function ->number.  This sounds simple, but I can't wrap my head around  the workings. What do I have to do? and most importantly, why do?
03:03:23 <quicksilver> but there are channels which don't and there isn't an easy way for a client to be clever about that
03:03:25 <mangaba_1eitosa> quicksilver: I'm on an ancient Russian channel created in 1993 or so
03:03:30 * quicksilver nods
03:05:07 <donri> i can configure encodings per network but not per channel
03:05:45 <ibotty> yeah, that's a problem
03:05:49 <mangaba_1eitosa> donri: I tried git pull, still having the same errors
03:06:15 <ibotty> but afair irssi can do that per channel
03:06:21 <mangaba_1eitosa> donri: maybe I need several *conceal* directives, not just one? E. g. haskell_conceal_enumerations?
03:07:06 <donri> mangaba_1eitosa: oh yeah, you need to let g:jmacro_conceal = 0, too
03:07:30 <mangaba_1eitosa> donri: working now, thanks a lot!
03:07:36 <donri> \o/
03:10:30 <mangaba_1eitosa> donri: are there any special settings for :set bg=dark?
03:10:55 <lasticot> How to have getChar read char by char on the standard input?
03:11:20 <mangaba_1eitosa> donri: comments seem to have a different color with default background (:set bg=light), but use the same color as function definitions with :set bg=dark
03:15:16 * hackagebot hsc3-server 0.7.0 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.7.0 (StefanKersten)
03:22:13 <jle`> hulahoop: what kind of arguments would your function take?
03:22:24 <jle`> hulahoop: and what would it return?
03:26:15 <donri> mangaba_1eitosa: block comments? are you using rainbow parenthesis?
03:26:43 <mangaba_1eitosa> donri: no, normal '--' comments
03:27:10 <donri> lasticot: getContents does that
03:27:22 <donri> lasticot: oh you're talking about buffering
03:27:25 <kqr> is there a function that takes a boolean value and returns one of two value depending on whether the bool value is true or false? (so basically an if-then-else but with less characters)
03:27:35 <lasticot> donri:yes
03:27:54 <mangaba_1eitosa> donri: try ':set bg=dark' and check if '-- comment' uses the same color as 'f x = x'
03:27:54 <donri> lasticot: hSetBuffering stdin NoBuffering
03:27:56 <sprinx> @hoogle if'
03:27:56 <lambdabot> No results found
03:28:10 <lasticot> donri: thank you !
03:28:38 <donri> mangaba_1eitosa: that shouldn't happen... screenshot?
03:29:12 <mangaba_1eitosa> donri: a sec
03:30:17 <donri> kqr: "bool" in several packages and in Data.Bool upcoming ghc
03:32:13 <kqr> donri, thanks
03:32:21 <sprinx> they named if bool?
03:32:46 <donri> kqr: one of https://hackage.haskell.org/packages/search?terms=bool
03:32:58 <donri> sprinx: symmetry with maybe, either
03:33:45 <kqr> donri, yeah, found it
03:34:06 <mangaba_1eitosa> donri: (1) screenshot with ':set bg=light', comments use a different color: http://jail.mp2.macomnet.net/vim.haskell.bg.light.png  (2) screenshot with ':set bg=dark', comment use the same color as function names in definitions: http://jail.mp2.macomnet.net/vim.haskell.bg.dark.png
03:35:00 <donri> mangaba_1eitosa: looks like terminal issue, too few colors to pick from? does this not happen for anything else?
03:35:59 <mangaba_1eitosa> donri: t_Co=256
03:36:22 <donri> mangaba_1eitosa: that alone doesn't really matter i don't think. also depends on terminal and color scheme
03:36:32 <donri> i don't use vim in terminal much though
03:36:46 <mangaba_1eitosa> donri: no, with default haskell.vim, comments are different color than function definitions, but that's because in default haskell.vm function definitions don't use any special highligting (use default color)
03:37:30 <donri> mangaba_1eitosa: have you tried a more complex file? it could be a pattern issue that swallows that particular comment
03:37:55 <mangaba_1eitosa> donri: no, the comment DOES get a special color
03:38:02 <mangaba_1eitosa> donri: if I remove '--', the color changes
03:38:05 <donri> mangaba_1eitosa: yes, but the wrong one
03:38:08 <mangaba_1eitosa> donri: right
03:38:13 <donri> it could be it's swallowed by some other pattern
03:38:22 <mangaba_1eitosa> donri: yes, I did try a more complex file, and it's the same
03:38:26 <donri> vim2hs has a lot of crazy cross-line patterns
03:38:39 <mangaba_1eitosa> donri: could you show me your sreenshot with :set bg=dark ?
03:38:46 <exicer> I'm a bit confused - can I have something with a type signature like Downloader :: Either (IO String) (IO Result) ? Or should it be IO (Either String Result) ?
03:38:50 <donri> not easily, i don't use vim2hs :)
03:38:55 <mangaba_1eitosa> donri: :-))
03:39:03 <Twey> exicer: You probably want the latter
03:39:04 <mangaba_1eitosa> donri: I suppose you would observe the same
03:39:11 <Twey> exicer: The former is valid, but means something quite different
03:39:17 <donri> mangaba_1eitosa: i've never had that issue and never heard anyone else have it
03:39:21 <exicer> Twey: Could you explain the difference ?
03:39:29 <mangaba_1eitosa> donri: maybe you never have used 'set bg=dark'?
03:39:46 <donri> mangaba_1eitosa: well see the readme, lots of dark screenshots :)
03:39:56 <donri> all gvim though
03:40:14 <mangaba_1eitosa> donri: dark background does not activate set bg=dark automatically
03:40:15 <Twey> exicer: The former says ‘a downloader is either an IO program to get a String, or an IO program to get a Result’.  The latter says ‘a downloader is an IO program that returns either a String or a Result.’
03:41:00 <mangaba_1eitosa> donri: you can see on my first screenshot, then with dark background but with default setting (set bg=light), the issue does not exist
03:41:26 <exicer> Twey: Ah, okay. That makes sense then!
03:42:30 <mangaba_1eitosa> donri: anyway, I think I need to just pick a new color that I like for function names and hardcode a different color...
03:42:56 <mangaba_1eitosa> donri: because the issue is not with the color of the comments, it's that the function names happen to use the same color as comments
03:43:27 <donri> mangaba_1eitosa: is this a different color from comments in other filetypes?
03:43:59 <mangaba_1eitosa> donri: yes, comments look exactly the same as in other filetypes. At the same time, in vim2hs function names also look like comments
03:44:09 <sprinx> why wasn't if defined as a function, by the way? one syntax less, and you could pass it to higher order functions
03:44:23 <donri> mangaba_1eitosa: aha, then nothing is wrong. problem is your colorscheme uses too few colors
03:44:52 <mangaba_1eitosa> donri: how could I change it in addition to set c_Co=256?
03:45:01 <donri> mangaba_1eitosa: try another :colorscheme
03:45:42 <mangaba_1eitosa> donri: actually, on the screenshot, you can see that the color are SOMEWHAT different
03:45:56 <mangaba_1eitosa> donri: function names look like bold
03:46:08 <mangaba_1eitosa> donri: but still the same color
03:46:14 <donri> mangaba_1eitosa: yeah, i think bg=dark just makes some things bold, which in terminals is a different color sometimes :p
03:47:15 <mangaba_1eitosa> donri: we need someone using vim2hs and 'set bg=dark' to detect if the issue is really with vim's default color scheme :-)
03:47:30 <donri> mangaba_1eitosa: anyway try a different colorscheme but it should also be possible to override what highlighting group vim2hs uses with :highlight link
03:48:22 <mangaba_1eitosa> donri: trying now
03:48:28 <donri> mangaba_1eitosa: try :help group-name, you'll see the standard group names and their color in your colorscheme
03:48:42 <donri> mangaba_1eitosa: if you see the same colors used a lot, well there's your problem :)
03:48:45 <Earnestly> Generally setting t_Co is not required and can be negative.  Most schemes on the terminal actually also depend on your current terminal colour scheme, see solarized.
03:49:34 <mangaba_1eitosa> donri: but it's a problem with my what? colorscheme (vim's default?) terminal (xterm)?
03:50:09 <donri> mangaba_1eitosa: not sure, i use neither
03:50:18 <Earnestly> mangaba_1eitosa: What is your current TERM?
03:50:20 <mangaba_1eitosa> donri: I can see in :help group-name that e. g. 'Statement/Conditional/Repeat/Label/Operator/Keyword/Exception' all use the same color
03:50:53 <donri> mangaba_1eitosa: and Comment vs Identifier or Function?
03:52:02 <mangaba_1eitosa> donri: they are the same as on my screenshot, same color, but differ in 'regular/bold'
03:52:11 <Earnestly> #vim
03:52:33 <mangaba_1eitosa> Earnestly: xterm-256color
03:53:04 <Earnestly> Yeah ask in #vim, this is going in circles.  You shouldn't have to set t_Co either.
03:53:22 <mangaba_1eitosa> Earnestly: this config works for more than 10 years for me
03:53:34 <donri> mangaba_1eitosa: yeah, so it's an issue of colorscheme and/or terminal
03:53:36 <Earnestly> So?
03:53:39 <mangaba_1eitosa> Earnestly: what exactly should I ask?
03:53:59 <mangaba_1eitosa> Earnestly: my only issue is with vim2hs
03:54:03 <donri> mangaba_1eitosa: anyway that's just the name of the function, not the whole function. is it a big issue?
03:54:40 <donri> i'm quite sure lots of filetypes use Identifier, surprised you haven't noticed it's the same color as comment before :)
03:55:50 <Earnestly> vim2hs doesn't set colours (color/)
03:56:30 <donri> yeah vim2hs just links to the standard groups, it's up to the colorscheme to assign colors to the groups and up to the terminal how to display the colors
03:59:26 <mangaba_1eitosa> donri: you are right, maybe it's not a big issue and I will adapt to it. I was just confused because in default haskell.vim function names used a different color (default)
03:59:43 <donri> mangaba_1eitosa: maybe you're used to languages that use keywords like "def" to define functions, and keywords usually get Keyword or Statement highlighting
03:59:50 <JimmyTheKlingon> So what is the reason that instances of typeclases aren't "inlined' at compile time?
03:59:58 <donri> mangaba_1eitosa: in haskell there is no keyword, vim2hs just highlights the function's name, which is an Identifier
04:00:15 <donri> mangaba_1eitosa: standard haskell.vim doesn't highlight these things at all
04:00:26 <mangaba_1eitosa> donri: right, e. g. in ocaml source files the comment and identifiers look the same, too, but 'let' keyword helps in distinguishing definitions from comments
04:00:33 <donri> yeah
04:00:44 <donri> haskell is notoriously hard to syntax highlight :p
04:04:31 <hpc> is haskell really that hard? the hardest part i can imagine is multi-line strings
04:04:42 <hulahoop> jle`: I see that I have still a lot to learn. Is this an argument for Polynom ? Polynom :: [(Int,Int)]
04:04:54 <donri> hpc: depends how good highlighting you want
04:05:12 <Earnestly> donri: emacs can highlight it pretty much perfectly because it doesn't use regex to highlight syntax ;p
04:05:20 * hackagebot snaplet-mysql-simple 0.1.0 - mysql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-mysql-simple-0.1.0 (ibotty)
04:05:23 <donri> yeah vim is stupid in so many ways
04:06:02 <Earnestly> I'm a little sad I found vim first sometimes, but both editors are wonderful
04:06:32 <hpc> i am glad i found vim first; emacs takes 3 seconds to start on my craptop
04:06:38 <zielwasserjunki> I do have following issue i have a function with the type: Record -> a -> Record which changes one field with type a of the record is there any way to reuse the argument record without constructing it again
04:06:40 <rhz> representable-functors-3.2.0.1 fails to install with cabal
04:06:45 <donri> i want to switch to emacs some day, but even with evil it's a big change to commit to
04:06:59 <ibotty> Earnestly: some like to use evil because emacs is nice... but it's still so different
04:07:08 <Earnestly> hpc: You're not really meant to close emacs.  It provides a consistent environment for everything you use and do
04:07:35 <Earnestly> ibotty: Yeah, I used evil for while but I want to try and learn it as it was.  Probably silly of me but there's no rush
04:07:44 <hulahoop> sorry, my internet connection went bad. May I ask if Polynom :: [(Int,Int)] a valid definition for this datatype?
04:07:54 <Guest65545> zielwasserjunki: You mean without matching all fields and repeating all but one in the new record?
04:08:00 <donri> without evil i can't do shit in emacs, with evil the emacs docs aren't very helpful at all ^_^
04:08:05 <ibotty> Earnestly: well i guess if you have not invested yet in vim, go evil!
04:08:11 <Earnestly> hpc: You can have about 300+ buffers open without any slow down if needed.  Then there's emacsclient which sets up a server <> client model
04:08:26 <hulahoop> donri: is emacs that unfriendly?
04:08:31 <zielwasserjunki> merijn,exactly
04:08:41 <ibotty> hulahoop: yes if you are used to modal editing
04:08:42 <Earnestly> donri: the emacs docs are really good :|
04:08:44 <donri> hulahoop: it's different
04:09:10 <merijn> zielwasserjunki: If you're using record syntax, there is record update that lets you do that (in reality the record of course has to be copied, since it's immutable, but at least you can avoid the typing)
04:09:12 <donri> Earnestly: they're really good for emacs. evil is a new thing :P
04:09:18 <hulahoop> ibotty: hmmm, I am not used to monad, at all. In fact I am a bloody beginner at that.
04:09:21 <Earnestly> Since you can query any function name, keysequence, variable, by name or fuzzy match and it pulls the documentation for it
04:09:37 <Earnestly> (Self-documenting :D)
04:09:37 <donri> i sort of feel that to use evil efficiently you need to know both vim and emacs well
04:09:39 <donri> duno
04:09:50 <Earnestly> Pretty much
04:09:57 <isomorphic> has somebody started some type of boot to emacs project?
04:09:57 <ibotty> hulahoop: i think modal editing is great, because you don't have to reach for these strange meta keys
04:10:00 <zielwasserjunki> merijn, thank you very much
04:10:01 <merijn> zielwasserjunki: "updateX myRecord newVal = myRecord { fieldA = newVal }" <- this will create a record that's a copy of myRecord, but with fieldA set to newVal
04:10:16 <ibotty> isomorphic: there used to be lisp machines, that was a thing!
04:10:32 <zielwasserjunki> merijn, do i need a compiler extension?
04:10:58 <merijn> zielwasserjunki: No, that's just standard haskell
04:11:08 <merijn> zielwasserjunki: You can update any subset of fields at once, this way
04:11:16 <Earnestly> donri: But the biggest benefit of emacs is really just that it provides a consistent environment for everything, mail, irc, etc.  Imagine being able to grep for something and then /edit the grep results inline/.  Same for dired, proced, rss feeds, etc.
04:11:29 <hulahoop> ibotty: My own problem is, that I am confronted with problems I am too dumb to understand, or have not the time to make it click in my head before I can use it freely.
04:11:46 <donri> i'm not too interested in the non-editor stuff in emacs
04:11:48 <ibotty> hulahoop: you know i am talking about editors, right?
04:12:00 <merijn> Might I suggest we take the editor talk to -blah?
04:12:07 <donri> i'm interested in emacs mainly as a better platform for a programmable editor
04:12:08 <hulahoop> ibotty: no
04:12:26 <ibotty> hulahoop: look for modal editing. (last word from me)
04:12:27 <hulahoop> ibotty: not at all, sorry. My bad.
04:12:31 <hulahoop> ok
04:12:45 <merijn> donri: vim sucks as a programmable editor, but emacs sucks at modal editing :(
04:12:49 <Earnestly> donri: That's fair but since most of my time is spent on the command line, I am getting a little tired of all these different programs with different standards, different keys, different mechanics, etc.  Anyway, I like both editors \o
04:12:56 <zielwasserjunki> merijn, i just tried it. Thank you very much!!!!!
04:13:10 <donri> merijn: thus evil ;) chrisdone's god-mode is interesting too
04:13:25 <merijn> donri: evil < vim
04:13:37 <donri> god-mode has the upside that you don't have to learn two editors, it's just emacs with modality
04:13:37 <Earnestly> donri: Even opening ghci in emacs and having all of the emacs' modes available such as paredit/rainbow parens, etc.
04:13:49 <merijn> I'm so tired of non-vim users suggesting evil, it's not even close to usable
04:14:36 <donri> merijn: oh?
04:15:35 <merijn> donri: It's like using linux after years of BSD: Sure, at first glance everything looks the same. But then you use it and everything is different/broken in subtly different ways leading to lots of frustration
04:16:21 <Earnestly> When last did you try evil out of interest?
04:16:34 <merijn> Last year or so?
04:16:52 <Earnestly> Yeah, then I can fully understand your point of view
04:17:46 <donri> i haven't tried it that heavily but they seem to have the normal mode down. the ex commands are rather limited though
04:17:47 <ibotty> merijn: i am a heavy vim user. as (i was) a very heavy bsd user. so i (might) know what i am talking about. if you start with linux, you will not run into that many idiosyncrasies of linux (or not question them). the same _might_ be possible with evil mode.
04:18:51 <merijn> ibotty: Sure, if you don't know better, that might work. But that means it's still out for me :p
04:19:18 <ibotty> merijn: but vim is broken in many ways as well. i won't compare vim with bsd
04:20:21 * hackagebot concraft-pl 0.6.0 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.6.0 (JakubWaszczuk)
04:20:49 <donri> vim is bloated, just use vi!
04:21:07 <ibotty> i assume you mean nvi?
04:21:19 <chrisdone> vi is bloated just use fopen()
04:21:27 <lpaste> Hulahoop pasted “No title” at http://lpaste.net/95937
04:21:35 <merijn> vi's undo sucks
04:21:54 <ibotty> c-x m-c m-butterfly
04:22:01 <merijn> ibotty: Sure, I was looking into hacking vim into being a bit more emacs like, took one look at the code and said "screw this"
04:22:15 <ibotty> merijn: vi's undo is great! it's great to have an undo tree
04:22:24 <merijn> ibotty: *vim* undo is great
04:22:25 <Earnestly> vi is `ex -v` and it certail does suck.  I cannot blame Bill Joy for wanting to use emacs instead at the time hah
04:22:31 <Earnestly> certainly/
04:22:33 <ibotty> merijn: oh.
04:22:35 <merijn> donri: Was saying "use vi", and vi's undo sucks
04:22:35 <ibotty> of course
04:22:37 <chrisdone> ibotty: you know to at least know some emacs to make shortcut jokes accurately
04:22:45 <donri> ibotty: vi doesn't even have *linear* undo
04:22:50 <merijn> undo twice /= undo my undo
04:23:05 <merijn> undo tree is indeed great, though
04:23:09 <Earnestly> vi just undoes the last undo.  Perfectly logical ;p
04:23:32 <Earnestly> http://web.cecs.pdx.edu/~kirkenda/joy84.html
04:24:35 <ibotty> chrisdone: i started using emacs on nextstep, but when i used freebsd later switched to nvi and then to vim. so yeah, a bit, but my memory is faulty :D
04:25:19 <donri> oldschool
04:26:17 * mangaba_1eitosa trying alternative color schemes
04:26:22 <mangaba_1eitosa> downloaded "codeschool"
04:29:12 <chrisdone> donri: let's make a haskell shell
04:29:23 <donri> chrisdone: let's call it fihs
04:29:27 <chrisdone> donri: we can call it hell. it can be an ironic name
04:29:30 <merijn> This is why I always snicker when I see linux/osx users start vim by typing "vi", it's a bad habit. One login to a BSD system/whatever else ships real vi and you'll be confused
04:29:38 <donri> chrisdone: or hell, ok
04:29:41 <merijn> chrisdone, donri: Oh, can I join? :)
04:29:42 <merijn> :p
04:29:59 <chrisdone> merijn can come too
04:30:25 <merijn> \o/
04:30:49 <merijn> I actually started designing one in the past, but first got stuck yak shaving and then working on MOP :p
04:31:12 <chrisdone> meta object protocol?
04:31:25 <merijn> Money Oriented Programming :p
04:31:35 <donri> meticulously organized program
04:31:45 <chrisdone> with some basic commands ghci would be usable http://lpaste.net/3159158122216423424
04:32:03 <chrisdone> we can make a wrapper to ghci that knows about completion and the current directory
04:32:05 <donri> import Shelly? :p
04:32:27 <Earnestly> There is 'hash' which is vaporware I think
04:32:43 <merijn> See, I actually want to get rid of this existing shell notion and just build windowing and modality into the shell
04:32:48 <ibotty> chrisdone: i never saw the point. unix is great and you lose so much when not having easy redirection (pipes, in-place files, etc), i would not want to use something like that to get work done... zsh can be pretty nice to work with.
04:33:11 <merijn> ibotty: Why would a haskell shell not support those?
04:33:27 <merijn> pipes and redirection are like the most trivial bit of a shell
04:33:54 <ibotty> but how should the syntax within a haskell shell be?
04:34:06 <chrisdone> yeah i thought a simple reader/state monad with a current Handle would do fine
04:34:06 <merijn> ibotty: You can just invent one?
04:34:13 <Earnestly> ibotty: Well, you don't have to use pipes
04:34:18 <ibotty> even file names without quotes is great
04:34:22 <Earnestly> PowerShell is quite interesting
04:34:26 <ibotty> Earnestly: whut?
04:34:36 <chrisdone> see, this is why you guys haven't made a shell yet
04:34:46 <chrisdone> you go all second system and try to re-invent what it means to be a shell
04:34:48 <merijn> I thought PowerShell sounded good on paper, in practice it's no good
04:34:55 <chrisdone> rather than just replacing bash with haskell
04:34:56 <ibotty> merijn: ack
04:34:58 <Earnestly> Each thing in PowerShell is an object, the text has string methods like .length, etc.
04:35:00 <isomorphic> So, I have a bunch of lists [1, 2, 3], [4,5,6], [7,8, 9],  and I want to create a new list of each possible combination of the lists when selecting one item from each list, eg: [[1,4,7],[1,4,8],[1,4,9]…] - I expect the resulting list will be very large so I'd like to consume it as I construct it.   What's a good way to construct the new list?
04:35:11 <zomg> merijn: microsofties seem to enjoy Powershell
04:35:13 <Earnestly> And you can use .NET libraries directly
04:35:17 <merijn> Earnestly: Yeah, that sounds good until you realise two things
04:35:20 <zomg> merijn: I also can't get used to it
04:35:41 <merijn> Earnestly: 1) most shell commands/scripts are 1shot/throwaway 2) you now need to implement all the boilerplate for all things
04:35:42 <ibotty> Earnestly: but look at real powershell scripts. ugh! compare that with posix shell.
04:35:51 <Earnestly> merijn: I just said it was an interesting approach, it's not like the Unix's innovate much in that regard
04:36:05 <ibotty> Earnestly: that's right
04:36:10 <donri> > sequence [[1,4,7],[1,4,8],[1,4,9]]
04:36:11 <merijn> chrisdone: See, I would just drop the notion of a scriptable shell completely and focus on human interaction
04:36:13 <lambdabot>   [[1,1,1],[1,1,4],[1,1,9],[1,4,1],[1,4,4],[1,4,9],[1,8,1],[1,8,4],[1,8,9],[4...
04:36:29 <Earnestly> ibotty: Because something is new and looks different and because you don't understand it, it's "ugh" compared to something you're familiar with?  Yea, I agree
04:36:43 <Earnestly> posix sh is disgusting btw
04:36:50 <ibotty> hey. that's unfair. there is much boilerplate. that was my point
04:36:55 <Earnestly> Arrays?  No one uses those things
04:37:00 <donri> isomorphic: like that?
04:37:01 <chrisdone> merijn: nod.  you're off the project, Merijn. hand in your badge and company manbag
04:37:20 <isomorphic> donri - I believe that's precisely the answer!
04:37:41 <ibotty> Earnestly: you are wrong
04:37:45 <merijn> chrisdone: We have 10 billion shells for running scripts, I want one that's actually usable at the command line :p
04:37:46 <isomorphic> I heart #haskell
04:38:02 <ibotty> if you think posix shell is disgusting, try csh for programming
04:38:18 <merijn> ibotty: I think all shells are terrible for programming
04:38:26 <chrisdone> merijn: that's my aim, too
04:38:38 <ibotty> but honestly: posix shell is great if you want to connect simple well-defined things. for "real" programs, it's something different
04:38:39 <isomorphic> > sequence [[1, 2, 3], [4,5,6], [7,8, 9]]
04:38:41 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
04:39:00 <chrisdone> merijn: hence starting from ghci and working from there. i don't care much about writing script files, i can do that in haskell well enough. i also wannt haskell at my command  line
04:39:02 <ibotty> Earnestly: shells are for connecting things
04:39:03 <Earnestly> ibotty: Yes, csh is even worse, I don't disagree
04:39:05 <donri> merijn: fish!
04:39:07 <isomorphic> donri:  What's the intuition behind sequence working like that?
04:39:43 <merijn> chrisdone: Exactly, but I'd like to have a terminal multiplexer so you can do things like have pipelines where you can peak at the data flowing through it in a separate window
04:39:55 <ibotty> chrisdone: so you are talking about interactive shell only?
04:40:08 <chrisdone> merijn: yeah, that's outside the scope of what i'm interested in, otherwise it'll never get done
04:40:14 <donri> isomorphic: do you understand the list monad?
04:40:14 <merijn> chrisdone: True
04:40:23 <merijn> chrisdone: That's why I never got anything done xD
04:40:23 * hackagebot yesod-dsl 0.1.1.8 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.8 (TeroLaitinen)
04:40:24 <chrisdone> ibotty: yeah
04:40:27 <chrisdone> merijn: =p
04:41:06 <isomorphic> donri:  I doubt it.  I looked at the nondeterminism/monad tutorial as a first start - is that the one you mean?
04:41:16 <adnap> chrisdone: Hey. I watched your video on "semantic editing" and it looked like a normal vim session, but with an unusual sidebar that showed your keystrokes. What was I supposed to notice?
04:41:17 <donri> isomorphic: yes
04:41:43 <johnw> one thing that would be kind of neat is if my terminal automatically showed transfer stats on all pipelines that took longer than .25 secs to run or something.  It would likely need integrating from bash to insert the interceptor between any two pipes segments, like how pv works
04:42:11 <johnw> but I often forget to insert pv just when I needed to
04:42:13 <isomorphic> donri:  Okay, so where I got on that one was something like (,) <$> [1,2,3] <*> [4,5,6]
04:42:38 <chrisdone> adnap: it was an emacs session
04:43:23 <donri> @src sequence
04:43:23 <lambdabot> sequence []     = return []
04:43:24 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:43:24 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
04:43:43 <donri> :t sequence
04:43:46 <lambdabot> Monad m => [m a] -> m [a]
04:44:03 <donri> isomorphic: note that sequence always takes a list and always produces a list, that part is independent of the list monad
04:44:29 <adnap> chrisdone: What was I supposed to notice?
04:44:50 <adnap> chrisdone: What is "semantic editing"?
04:45:04 <donri> isomorphic: if you sequence a list of IO actions, it runs them "in sequence" and returns the list of their results
04:45:23 * hackagebot yesod-dsl 0.1.1.9 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.9 (TeroLaitinen)
04:46:44 <donri> isomorphic: but in the list monad, when you "run" a list the result is each element of the list
04:47:18 <donri> > do x <- [1,2,3]; return (x * 10)
04:47:20 <lambdabot>   [10,20,30]
04:47:53 <isomorphic> donri:  Thanks.  That last one looks like the example I'm looking for :P
04:48:38 <adnap> > do x <- [1..3]; y <- [41..39]; return (x + y)
04:48:40 <lambdabot>   []
04:49:16 <adnap> > do x <- [1..3]; y <- [41,40,39]; return (x + y)
04:49:18 <lambdabot>   [42,41,40,43,42,41,44,43,42]
04:49:25 <akegalj_> when using data i can do something like: "data A = B | C ; data G = A" but i can also do "data A = B | C ; data G = G A". Which approach is better?
04:50:02 <donri> > do x <- [1,2,3]; y <- [4,5,6]; return (x,y)
04:50:03 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
04:50:04 <chrisdone> adnap: i dunno, what is "semantic editing"?
04:51:03 <shiona_> http://lpaste.net/95938 any help on this. If it looks strange I removed alot of code trying to find the root cause for the problem.
04:51:32 <donri> isomorphic: if we "run" two lists, the result is the product of every element in both lists. it's like a for loop: for x in [1,2,3] { for y in [4,5,6] { return (x,y) } }
04:52:56 <donri> isomorphic: so sequence simply does this for every list in the list of lists
04:53:05 <adnap> chrisdone: I misremembered the term you used, which was "structured editing"
04:54:28 <isomorphic> donri:  that's cool.  So, desugared, I get [1,2,3] >>= \x -> [4,5,6] >>= \y -> [(x,y)]
04:54:45 <shiona_> donri: any clue about http://lpaste.net/95938
04:55:00 <donri> @undo do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
04:55:00 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5, 6] >>= \ y -> return (x, y)
04:55:28 <donri> @src [] (>>=)
04:55:28 <lambdabot> xs >>= f     = concatMap f xs
04:55:35 <donri> @src concatMap
04:55:35 <lambdabot> concatMap f = foldr ((++) . f) []
04:56:53 <adnap> chrisdone: So, how does your video demonstrate "structured editing"?
04:57:25 <donri> shiona_: the "s" is different
04:57:33 <bearclaw> <beginnerquestion> is something wrong with  that :     "case someText of ; pack "foo" ->  1   ? I get  "Parse error in pattern: pack"
04:57:47 <shiona_> donri: oh
04:57:49 <donri> shiona_: you need ScopedTypeVariables to do that and forall s. on findMST
04:58:18 <shiona_> oh god. I'm not ready for all that
04:59:35 <donri> bearclaw: if you enable OverloadedStrings you can do "foo" -> 1
05:00:18 <donri> bearclaw: it desugars to, _x | _x == fromString "foo" -> 1
05:00:31 <donri> bearclaw: if you prefer you can write that manually too
05:01:21 <donri> shiona_: shouldn't be needed, let type inference do its job :)
05:01:22 <bearclaw> OverLoadedStrings is compiler magic to make "foo" like int constants,  ie StringType a => a ?
05:01:43 <donri> bearclaw: yes. not that magic though, just inserts fromString before any string literals
05:01:48 <donri> :t fromString
05:01:49 <bearclaw> still, I don't get what is wrong with my case, pattern can't be any expr?
05:01:51 <lambdabot>     Not in scope: `fromString'
05:01:51 <lambdabot>     Perhaps you meant one of these:
05:01:51 <lambdabot>       `BSLC.fromStrict' (imported from Data.ByteString.Lazy.Char8),
05:01:58 <donri> :t Data.String.fromString
05:01:59 <lambdabot> Data.String.IsString a => String -> a
05:02:18 <donri> bearclaw: you can't call functions in patterns no
05:02:23 <donri> except with more extensions ;)
05:02:31 <donri> (and different syntax)
05:03:56 <allsystemsarego> why does Google tell me to read about GADTs when I go to search for "Haskell type level pattern matching"?
05:06:00 <donri> allsystemsarego: probably because pattern matching causes type refinement with gadts
05:06:15 <isomorphic> donri:  Thanks for your help.   I'll need to look at that a fair bit more
05:06:21 <donri> allsystemsarego: but type familiers are probably closer to "type level pattern matching"
05:06:21 <allsystemsarego> donri, thanks
05:07:42 <bearclaw> OverLoadedStrings seems to work, but I can't figure out how to make a default case
05:07:59 <donri> bearclaw: _ ->
05:08:05 <bearclaw> it parses error
05:08:16 <donri> then maybe your indentation is wrong
05:08:20 <merijn> allsystemsarego: THe TypeFamilies paper (Fun With Type Functions) is pretty readable
05:08:20 <bearclaw> (or should it be "parse errors"? :)  )
05:09:28 <allsystemsarego> merijn, thanks
05:10:09 <mirpa> bearclaw: what about otherwise ->?
05:11:04 <quicksilver> no, mirpa
05:11:08 <quicksilver> otherwise is a boolean
05:11:34 <quicksilver> it won't match an overloaded string unless there is a instance (IsString Boolean)
05:11:37 <quicksilver> which would be pretty confusing.
05:13:24 <bearclaw> http://lpaste.net/95940 case on Text, parse error on the second ->
05:13:25 <donri> actually that'll work just as _ ->
05:13:47 <donri> but bind the thing you case matched on to "otherwise" (shadowing the prelude one)
05:14:04 <donri> bearclaw: you need to align _ with "
05:14:34 <donri> you have it aligned with f
05:15:21 <bearclaw> ah, right, it was just that, thanks
05:15:22 <mirpa> it has to be aligned with first char on previous line
05:18:19 <merijn> mirpa: That's wrong if your previous pattern had a multi-line expression
05:18:54 <donri> it has to be aligned with the start of the first pattern clause :)
05:19:45 <donri> which may not even be the first non-whitespace, because you can have case foo of X -> ... and then the next one has to line up with X
05:20:23 <bearclaw> I just stupidly aligned the _ with the content of the quoted string for weird esthetic reasons :)
05:23:00 <chrisdone> adnap: http://ircbrowse.net/browse/haskell?id=16844340&timestamp=1384547715#t1384547715
05:25:09 <bearclaw> why not using typeclasses for stuff like head, or split?
05:25:29 <bearclaw> having to qualify it kind of breaks the genericity of the code
05:25:59 <donri> use lens
05:27:59 <bearclaw> Does it involve understanding quantum-rocket-science level concepts just to get the first element of a list or a Text with the same code? :)
05:28:05 <chrisdone> adnap: the video demonstrates navigating/selecting/cutting/pasting/indenting tree nodes as nodes, if you can do all that in vim (which i don't think so), good for you
05:30:36 <edwardk> bearclaw: sure, but that doesn't stop us from using it =)
05:30:57 <edwardk> it just means that by accessing the nth element of the list i can now call myself a quantum-rocket-scientist
05:31:15 <edwardk> > "hello"^.ix 3
05:31:17 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
05:31:17 <lambdabot>    arising from a use o...
05:31:20 <edwardk> > "hello"^?ix 3
05:31:22 <lambdabot>   Just 'l'
05:31:26 <edwardk> > "hello"^?!ix 3
05:31:27 <lambdabot>   'l'
05:32:49 <chrisdone> :t (^?)
05:32:49 <lambdabot> s -> Getting (First a) s a -> Maybe a
05:32:52 <chrisdone> :t ix
05:32:53 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
05:33:11 <bearclaw> well, then maybe Prelude.head needs to be upgraded :)
05:34:18 <chrisdone> :t 3 :: Index m
05:34:19 <lambdabot>     No instance for (Num (Index m1)) arising from the literal `3'
05:34:19 <lambdabot>     Possible fix: add an instance declaration for (Num (Index m1))
05:34:19 <lambdabot>     In the expression: 3 :: Index m
05:34:56 <bearclaw> splitlines = map ((map TL.toStrict) . (TL.split (== ' ' ))) lines      <-- (TL is Text.Lazy)hoping I did not strict it too soon, and wondering how to convince my boss that it's not as hard as it looks
05:35:02 <chrisdone> :t Ixed f m => (3,undefined) :: (Index m,f)
05:35:04 <lambdabot> parse error on input `=>'
05:35:16 <chrisdone> :t (3,undefined) :: Ixed f m => (Index m,f)
05:35:16 <lambdabot>     Expecting one more argument to `f'
05:35:17 <lambdabot>     In an expression type signature: Ixed f m => (Index m, f)
05:35:17 <lambdabot>     In the expression: (3, undefined) :: Ixed f m => (Index m, f)
05:35:47 <chrisdone> :t (3,undefined) :: Ixed (f::*->*) m => (Index m,f)
05:35:49 <lambdabot> parse error on input `)'
05:36:01 * chrisdone gives up
05:37:02 <quicksilver> chrisdone: where is the video?
05:37:52 <chrisdone> quicksilver: http://chrisdone.com/shm-gtk.ogv
05:38:40 <quicksilver> chrisdone: thanks
05:41:59 <quicksilver> chrisdone: don't understand eerything you did, but the yanking at local indentation is very nice
05:42:22 <quicksilver> chrisdone: (also wow keyclick such noise)
05:42:34 <chrisdone> haha, it's a das keyboard. cherry mx blues =p
05:44:59 <quicksilver> chrisdone: presumably you are familiar with paredit?
05:45:09 <chrisdone> quicksilver: yeah, it's my inspiration for this mode
05:45:24 * quicksilver nods
05:45:32 <quicksilver> paredit is such fine it almost makes me want to program lisp :)
05:45:40 <quicksilver> fun
05:45:41 <chrisdone> yeah =p
05:46:14 <chrisdone> navigation and indentation work the same as paredit. so C-M-u or M-a to go up a node, close paren ) to go to the end of the node or continue to the parent, etc.
05:46:22 <chrisdone> and then C-j to newline indent
05:46:34 <chrisdone> which in this mode looks at the current type of node to determine how to do that
05:48:22 <lasticot> What does the runtime error:  No match in record selector means?
05:48:42 <Qfwfq> Are lambdabot's imports listed anywhere?
05:48:53 <donri> lasticot: probably you have a multi-constructor record with different fields
05:49:07 <chrisdone> because haskell doesn't have the parentheses to tell you what node you're at, i highlight the background color
05:49:08 <chrisdone> do case x of
05:49:08 <chrisdone>      Foo x -> do foo bar| ← if the point is at | here, then C-j could do a multitude of things
05:49:08 <chrisdone>    ^ ^           ^   ^    ← it could go to any of these places. by expanding the current node, you make it explicit where it'll go next. existing modes have to guess this
05:49:19 <lasticot> donri: ok
05:49:20 <edwardk> Qfwfq: sadly, no
05:52:09 <shiona_> what do I need to do to read Text?
05:52:23 <shiona_> it's quite hard to google the subject
05:52:36 <chrisdone> “read” text?
05:52:44 <chrisdone> explain
05:53:21 <shiona_> let a = pack "1.2"; read a :: Float
05:53:44 <donri> you'll have to unpack for that
05:53:46 <klugez> shiona_: read only works on Strings. So you have to show . unpack
05:53:49 <shiona_> ok
05:54:06 <donri> don't want show here
05:54:20 <klugez> Err, read . unpack
05:54:26 <chrisdone> use http://hackage.haskell.org/package/text-0.11.3.1/docs/Data-Text-Read.html
05:54:30 <chrisdone> don't use unpack
05:55:02 <shiona_> ok
06:00:22 * quicksilver is quite amused by "For 94.2% of numbers, this function and rational give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place"
06:01:22 <quicksilver> percentages aren't particularly meaningful for the countable set of text-representable numbers.
06:02:25 <t7> countably infinite
06:03:39 <klugez> There's a finite amount of Doubles?
06:04:05 <merijn> klugez: Sure
06:04:21 <Blkt> arithmetic in hardware is finite
06:04:25 <merijn> klugez: They have a fixed number of bits, which means a finite number of possible representations
06:04:41 <klugez> So I don't get why the percentages wouldn't be meaningful.
06:05:33 <merijn> klugez: text-representable is not restricted to Doubles...
06:05:44 <quicksilver> klugez: the functions being discussed are all those readable from text
06:05:49 <quicksilver> Text and Rational are not finite
06:05:58 <merijn> Technically Text is finite
06:06:03 <quicksilver> well on any fixed hardware combination they are
06:06:10 <quicksilver> but denotationally they're not
06:06:10 <merijn> I believe it uses Word64 for indexing
06:06:26 <merijn> Or Int64, anyhoo
06:06:26 <quicksilver> well, let's suppose we take the word64 interpretation
06:06:30 <jmcarthur_mobile> Well... You could make handwavy arguments about memory limitations of 64 bit architectures
06:06:35 <quicksilver> then the pecentages exist
06:06:38 <quicksilver> but they're utterly wrong
06:06:39 <klugez> quicksilver: But the doc string you quoted is from double :: Reader Double. It's fairly natural that it refers to numbers representable by Doubles.
06:06:40 <jmcarthur_mobile> Yeah
06:06:48 <quicksilver> they're certainly not 94.2% and 5.8%
06:07:31 <quicksilver> klugez: no, because it applies to the source not the destination
06:07:45 <quicksilver> it's talking about 94.2% of strings (and which double they convert to)
06:07:55 <quicksilver> not 94.2% of doubles...
06:08:03 <quicksilver> because then you'd not know which string you mean
06:08:19 <quicksilver> the rational reader will convert an infinite set (or a very large set) of strings to the same Double
06:10:02 <klugez> I guess you are right, though I think the information in those sentences is still useful.
06:10:36 <quicksilver> it's not to me
06:10:43 <quicksilver> the more I think about the more I'm not sure what it means
06:11:06 <quicksilver> beyond the basic content "in most cases you care about it will be the same but faster, in some cases it will difer in the 15th, 14th or 13th dp)
06:13:13 <quicksilver> I suspect it might be "for 94.2% of all numbers expressed in scientific notation with 16 significant digits"
06:13:29 <quicksilver> so then it's 94.2% of 10^16, more or less, a relatively small number.
06:14:07 <quicksilver> but I am left quite unsure how you might expect non canonical reps like "0.00001234560123456789" to convert.
06:14:38 <turduks> **Earn 0.25$ Per Lead **. For Details:http://www.StillRemember.Net/Affiliate.htm
06:14:46 --- mode: ChanServ set +o johnw
06:14:48 --- mode: ChanServ set +o johnw
06:15:07 --- mode: ChanServ set +o johnw
06:19:52 <circle> why hasn't a computer virus been written in haskell?
06:20:23 <Kaidelong> hasn't there? Seems like it'd be the sort of challenge people'd pick up
06:20:57 <merijn> @quote virus
06:20:57 <lambdabot> SourceLabs says: Wilson, I understand we're vulnerable to a virus.
06:20:57 <Kaidelong> but computer viruses generally work by doing exactly the kind of naughty things haskell has features to prevent
06:21:02 <merijn> hmm, wrong quote
06:21:11 <merijn> @quote ghc-as-a-virus
06:21:12 <lambdabot> Cale says: We have GHC-as-a-Library, why not GHC-as-a-Virus
06:21:12 <zomg> I would imagine it to be simpler for people who actually want to do that to use C or such :P
06:21:18 <tdammers> circle: how do you know?
06:21:30 <circle> tdammers: maybe one has, but google turned up nothing
06:21:33 <tdammers> well
06:21:41 <tdammers> malware has been written in all sorts of languages
06:21:51 <tdammers> but the usual choices are C and C++, for obvious reasons
06:21:56 <tdammers> direct access to the bare metal
06:21:57 <merijn> Kaidelong: Haskell has a C FFI, trust me. I can be exactly as naughty in haskell as in C
06:22:04 <Kaidelong> you can
06:22:07 <merijn> :t peek
06:22:10 <lambdabot> Not in scope: `peek'
06:22:12 <Kaidelong> but then why not just use C
06:22:27 <tdammers> the benefits of a high-level language like Haskell don't really buy you much when you make a virus or some such
06:22:29 <merijn> Kaidelong: Because haskell is more pleasant for the boilerplate
06:22:31 <circle> all you need for a virus is access to the win32 api
06:22:35 <Kaidelong> (unless you are writing software to generate ... yes)
06:22:37 <circle> which haskell has
06:22:47 <Kaidelong> that only works for windows viruses
06:22:57 <tdammers> for high-profile attacks, however, I can imagine a higher-level language *would* be beneficial
06:23:11 <bearclaw> tdammers: for the parts where you're exploiting other softwares maybe, but there are a lot of other components in a virus that would benefit from being written in haskel
06:23:11 <tdammers> but if you do it right, google will never know about it
06:23:23 <tdammers> anyway
06:23:27 <circle> you could make a more advanced virus in haskell, the problem is only really the file size, but various compression programs and optimizations can take that down very significantly
06:23:33 <tdammers> I've heard of Lua being used for malware
06:23:45 <tdammers> but anyway
06:24:13 <tdammers> compile-time correctness guarantees are not as useful for a virus as they are for, say, an avionics computer, a compiler, or medical equipment
06:24:13 <Kaidelong> merijn: actually haskell would be a good platform for writing something along the lines of metasploit
06:24:21 <Kaidelong> come to think of it
06:24:25 <tdammers> I guess it's mostly a cultural thing
06:24:35 <Kaidelong> which isn't a surprise because ML was designed to deal with transformations
06:24:48 <tdammers> C is a hacker's language, and writing malware and general hacking have sort of a similar appeal to them
06:25:02 * bearclaw sees a paper title popping in his head: "list monad for non-deterministic code generation and antivirus evasion"
06:28:36 <divyansr> Where can I watch Simon Peyton-Jones - A Taste of Haskell online, most of links are dead
06:32:49 <alexander__b> divyansr: I have been wondering the same. here's the PDFs at least: https://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/TasteOfHaskell.pdf
06:33:07 <alexander__b> s/PDFs/slides as a PDF
06:34:07 <divyansr> Yeah It is kind of sad. It is amazing watching SPJ.
06:35:58 <alexander__b> divyansr: maybe one of the mirrors in http://downeb.net/video-training/oscon-2007-a-taste-of-haskell.html work -- I will try them myself now.
06:42:05 <exicer> So I'm a bit confused about how I should be doing something. I want to download some webpages, and then parse them, potentially following some links. The download step can have exceptions / a bad url or whatever, and parsing could also fail. At the moment I have two types - one represents the result of downloading, and the other represents the result of parsing... which is leading me to have ridiculous case statements everywhere.
06:42:34 <exicer> So presumably I should change this to use a monad somehow, but I can't quite work out how..
06:46:31 <osa1> do we have any trifecta tutorials?
06:56:33 <ziman> @pl \x -> all (`elem` x)
06:56:34 <lambdabot> all . flip elem
07:01:19 <niez> is there a function for substitution on parameters in String? for example: applyParams "my name is %1, i'm from %2" ["john", "usa"] == "my name is john, i'm from usa"
07:01:52 <donri> :t printf
07:01:55 <lambdabot> PrintfType r => String -> r
07:02:16 <donri> there are safer options on hackage
07:02:16 <dv-> > printf "hello %s" "john" :: String
07:02:17 <lambdabot>   "hello john"
07:06:28 <oio_> forM_ [1 .. n] $ \i -> do printf "%d" i (xxxx)
07:06:58 <oio_> can someone explain what the \i -> Does?
07:07:02 <stepkut> does their exist a library with a template haskell (or other) function where I can supply a Name and I will fetch the transitive closure of that type and any types its constructors use ?
07:07:40 <dv-> oio_: it the argument of the anonymous function
07:08:49 <oio_> dv-: what it does it take? and what it does in pronto?
07:09:25 <dv-> > (\x -> x + 2) 1
07:09:26 <lambdabot>   3
07:12:30 <donri> stepkut: not sure what you're asking there but i think haskell-names lets you resolve scope
07:12:34 <oio_> dv-: what it does in printf?
07:15:27 <ill_logic> Hi, I just upgraded cabal, with cabal. I ran cabal --version and it's still 1.14.0 (haven't upgraded cabal-install yet, it's on a Raspberry Pi so time is precious)
07:15:37 <ill_logic> oh, it might be the latest version available for arm
07:15:48 <Qfwfq> @type import
07:15:49 <lambdabot> parse error on input `import'
07:15:51 <ill_logic> at any rate, I'm looking at .cabal/bin/ ... and it doesn't exist
07:15:52 <adzeitor> ill_logic: check ~/.cabal/bin/cabal --version
07:16:04 <ill_logic> adzeitor: no such directory
07:16:13 <ill_logic> that's the weird thing
07:16:14 <iLike> how exactly does Haskell allow for a variable amount of arguments?
07:16:31 <ill_logic> config  lib  logs  packages  share  world
07:16:34 <ill_logic> that's what's in .cabal.
07:16:53 <ill_logic> perhaps it never created the bin, since it never really upgraded cabal? let me check on arm versions...
07:18:27 <donri> iLike: PrintfType r => String -> r, and one instance of PrintfType is (PrintfArg a, PrintfType r) => PrintfType (a -> r)
07:18:50 <ill_logic> wait no, it definitely said it was installing 1.18
07:19:06 <iLike> donri, ahh that's really clever
07:19:42 <donri> iLike: quite. it's also problematic: it's only runtime-checked and makes for bad type inference
07:20:30 <iLike> donri, so it's kind of un-haskell-ish
07:22:52 <donri> iLike: it gets the job done and is simple and portable, but yeah
07:27:12 <ill_logic> oh, duh. there's no bin because I didn't build a binary, I built the cabal library. how do I make it use that library though? or does it need the binary for that for some reason?
07:27:57 <geekosaur> [20 15:00] <ill_logic> Hi, I just upgraded cabal, with cabal. I ran cabal --version and it's still 1.14.0 (haven't upgraded cabal-install yet, it's on a Raspberry Pi so time is precious)
07:28:05 <geekosaur> the cabal command is cabal-install
07:28:10 <ill_logic> right.
07:28:21 <ill_logic> yeah that just hit me as well
07:28:27 <geekosaur> and it is linked against a particular version of the Cabal library, installing a new one will not retoractively make cabal-install use it
07:28:33 <ill_logic> ah ok.
07:28:36 <geekosaur> *retroactively
07:28:39 <ill_logic> so I have to install cabal-install as well?
07:28:42 <geekosaur> yes
07:28:55 <ill_logic> of course (sorry, Python programmer, forgot about that whole "linking" thing :P)
07:29:03 <ill_logic> geekosaur: ok great thanks.
07:29:09 <geekosaur> and you may need to rebuild any other libraries against the newer Cabal (but beware, one of those will be `ghc` and you need to upgrade the compiler for that)
07:29:42 <geekosaur> thankfully transitive uses of the Cabal library are uncommon, so it's usually safe to upgrade
07:29:58 * dcoutts always has several Cabal lib versions installed
07:30:03 <ill_logic> so wait
07:30:05 <ill_logic> ghc
07:30:16 <ill_logic> You're saying that once I upgrade to the new cabal, I need a new GHC as well?
07:30:24 <dcoutts> no
07:31:01 <dcoutts> old ghc new Cabal works fine
07:31:34 <ill_logic> I guess I misunderstood geekosaur's point
07:31:40 <ill_logic> about `ghc`
07:32:16 <geekosaur> no, I was saying that if you look for stuff that depends on Cabal in order to rebuild it to use the new one, one of the packages you will find is the compiler itself
07:32:25 <geekosaur> (actually the compiler as a library)
07:32:36 <dcoutts> but there's no need to rebuild anything else against a new Cabal
07:32:58 <geekosaur> but in general it's safe to ignore that because not much actually uses Cabal directly
07:32:58 <dcoutts> it's only cabal-install that needs it
07:33:25 <dcoutts> geekosaur: and if there were, you'd be best advised to leave it as it
07:33:40 <geekosaur> and cabal is mostly upward compatible so there is rarely a pressing need to upgrade the things that *do* use it (except cabal-install, but even there it's usually for cabal-install features)
07:34:07 <geekosaur> yeh
07:34:54 <donri> next haskell platform will ship two Cabal versions, right? hm or is the ghc library not part of platform
07:36:02 <donri> either way that's gonna be a problem for linux packaging i think...
07:36:34 <donri> or is Cabal only needed for building ghc, but it doesn't link to it?
07:37:32 <dcoutts> donri: oh, I wasn't aware of plans to ship two
07:37:50 * geekosaur wasn't either
07:37:50 <dcoutts> donri: where did you see that?
07:38:25 <donri> dcoutts: well the plan is to ship 1.18 but ghc 7.6
07:39:04 <dcoutts> donri: seems like I should go find out
07:39:30 <piezoid> Is it possible to copy the infix properties (associativity, precedence) of an operator to a newly declared alias ?
07:39:45 <turduks> **Earn 0.25$ Per Lead **. For Details:http://www.StillRemember.Net/Affiliate.htm
07:39:49 <donri> piezoid: possibly with TH
07:40:24 <donri> dcoutts: https://www.haskell.org/pipermail/libraries/2013-November/021585.html
07:40:35 <dcoutts> ta
07:40:45 <adzeitor> @slap turduks
07:40:45 * lambdabot would never hurt turduks!
07:42:33 <donri> dcoutts: how far away are we anyway from making ghc not depend on cabal?
07:42:50 <dcoutts> donri: I don't know if anyone has been working on my suggestion
07:46:55 <ill_logic> geekosaur: donri: Thanks for the help! I gotta run now.
07:48:21 <whittle> Speaking of cabal, could someone point me in the right direction on https://github.com/haskell/cabal/issues/1585 ?
08:10:41 <oio_> > let (su,si) = head in su "kilo"
08:10:43 <lambdabot>   Couldn't match expected type `(t0, t1)'
08:10:43 <lambdabot>              with actual type `[a0]...
08:19:05 <exicer> On this webpage: http://chromaticleaves.com/posts/guard-io-with-errort.html , how come it isnt necessary to define instances for Functor etc  ?
08:28:25 <stepkut> donri: when creating a checkpoint file for acid-state, I want to also write out a schema file that contains all the types associated with it -- of course to actually read the checkpoint file we would need to recover the SafeCopy instances as well
08:29:38 <stepkut> donri: ultimately, it would be great if it spit out a file that had all the types, plus the safecopy instances, plus a little REPL that let you examine the checkpoint file
08:31:26 <dcoutts> stepkut: my plan is to use a new binary package with a better on disk format
08:31:48 <dcoutts> in particular, one with a low level representation that does not need a schema
08:31:55 <dcoutts> e.g. msgpack or one of the similar ones
08:32:03 <stepkut> dcoutts: what problems would that resolve?
08:32:16 <dcoutts> stepkut: recovery of data if you lose the schema
08:32:25 <dcoutts> so you'd at least be able to convert it into e.g. json
08:32:33 <dcoutts> and look at it
08:32:38 <stepkut> ooo
08:32:43 <dcoutts> it'd be json using all arrays and no field names
08:32:48 <dcoutts> but still a whole lot better
08:33:42 <stepkut> is that something you'd incorporate into acid-state ? or would it just be an orthagonal export feature?
08:33:52 <dcoutts> stepkut: it'd be a feature of the binary package
08:34:19 <dcoutts> stepkut: so then we'd have to have acid-state switch from cereal + safecopy to a new binary
08:34:31 <dcoutts> and I think it would be possible to do safecopy style backwards compat directly in this style
08:34:43 <dcoutts> this style of low level binary format I mean
08:34:45 <stepkut> nice
08:35:06 <dcoutts> though enforcing that everyone does may still need a safecopy-style extra layer
08:35:18 <stepkut> where would migration support live?
08:35:25 <stepkut> that is primarily what safecopy adds now
08:35:34 <stepkut> versioned data and migration
08:35:46 <quicksilver> dcoutts: I wonder if it wouldn't be better to use something with named tags
08:35:52 <quicksilver> named fields I mean.
08:35:56 <cdjk>  > Data.Binary.decode (Data.ByteString.Lazy.pack [1..8]) :: Double
08:36:01 <quicksilver> the asymtotic cost shouldn't be high
08:36:05 <cdjk> > Data.Binary.decode (Data.ByteString.Lazy.pack [1..8]) :: Double
08:36:07 <lambdabot>   Not in scope: `Data.Binary.decode'Not in scope: `Data.ByteString.Lazy.pack'
08:36:24 <cdjk> \query lambdabot
08:36:24 <quicksilver> the field names could be numeric in band and the dictionary of names a separate blob.
08:36:25 <dcoutts> quicksilver: not if you want it to be small, and to use an existing externally defined format
08:36:41 <quicksilver> dcoutts: I was theorising that formats like that with named fields might exist.
08:36:45 <quicksilver> dcoutts: I hadn't checked :)
08:37:00 <dcoutts> quicksilver: and, it wouldn't help you a lot because the fields would still have to be in order
08:37:22 <quicksilver> dcoutts: the names wouldn't be used in the normal case
08:37:30 <quicksilver> but they could help over version skew and for debugging
08:37:39 <dcoutts> quicksilver: no, the better approach for applications that want that is to use aeson + a binary instance for the aeson's Value type
08:37:47 <quicksilver> ok :)
08:38:01 <dcoutts> quicksilver: oh using field names is possible in these formats, it just doesn't help you a lot
08:38:08 <dcoutts> quicksilver: and there are better methods for versioning
08:38:26 <dcoutts> quicksilver: basically by using fresh constructor tag numbers
08:38:51 <dcoutts> quicksilver: ie each time you change a constructor, give it a new tag number
08:39:18 <dcoutts> quicksilver: and that could be managed more symbolically with a bit of TH
08:39:44 <cdjk> does anyone know why (Data.Binary.decode (Data.ByteString.Lazy.pack [1..8]) :: Double) returns *** Exception: Data.Binary.Get.runGet at position 2: demandInput: not enough bytes? I would think a Double is 64 bits, and each Word8 in a ByteString is 8 bits, so there should be enough input. Even stranger, changing theBbyteString to 128 Word8 still gives the same exception
08:40:16 <quicksilver> dcoutts: yes. I'm familiar with the approach.
08:41:09 <quicksilver> dcoutts: there are actually quite a lot of orthogonal applications of binary storage and I was wondering about the human readable/debugging advantages of the plist/xml approaches
08:41:23 <quicksilver> (which notably preserve field names even when binary)
08:41:37 <quicksilver> but obviously you have to decide which problems you're actually trying to solve
08:42:39 <dcoutts> quicksilver: right. The approach I'm looking at would be able to do field names by repeating them a lot (like json does), or do it efficiently. But it would not be able to do both, ie be compact + efficient and use field names.
08:43:48 <dcoutts> quicksilver: there are binary formats where the repeated strings can be shared, but the ones I'm looking at do not support that.
08:44:09 * quicksilver nod
08:44:28 <minguin> #octave
08:45:23 <quicksilver> dcoutts: http://www.leonerd.org.uk/code/tangence/tangence-spec.txt
08:45:33 <quicksilver> dcoutts: but that is, I think, not what you want.
08:45:48 <Clint> cdjk: why do you think Data.Binary serializes doubles that way?
08:46:05 <dcoutts> ah, Clint beat me to it! :-)
08:46:14 * dcoutts was going to say the same thing
08:46:22 <Clint> :-O
08:46:30 <cdjk> Clint: I know it uses the encode/decodeFloat from Prelude, I'm looking at Data.Binary.IEEE754 and I think thats what I need, right?
08:46:45 <cdjk> how does Data.Binary serialize doubles?
08:47:17 <dcoutts> cdjk: when we were implementing Data.Binary, we did not have a portable way to construct IEEE format, so we used a simple portable format.
08:47:30 <quchen> cdjk: It calls 'decodeFloat' on it and then encodes the tuple.
08:48:00 <quchen> cdjk: So you'll have to look at how (Integer, Int) is encoded. Which is more than what 'Double' needs because there's the tuple and the arbitrary size Integer in there.
08:48:06 <dcoutts> cdjk: we really wanted it to be portable across platforms, including ones that do not use IEEE float natively, and we didn't have the bit twiddling code to do the conversion
08:49:42 * dcoutts notes that data-binary-ieee754 package actually is not portable either
08:50:30 <dcoutts> cdjk: at least when we wrote binary, there were still ARM platforms that use soft float implementations that do not use IEEE format in memory.
08:50:36 <dcoutts> I don't know if that's still the case
08:51:04 <cdjk> dcoutts: I have a binary file that was output by an x86_64 C program, and I'm trying to decode it. Can I use data-binary-iee754?
08:51:30 <quicksilver> but generally the automatic instances (for, e.g., [] or Maybe or Double) were not designed for people who cared about the byte representation of the output
08:51:39 <quicksilver> they were just designed to be fast and compact and portable
08:51:40 <dcoutts> cdjk: yes, but do not use the Binary class, because it's not for decoding externally defined formats. Use the Get monad directly.
08:52:02 <quicksilver> if you care about the byte representation.... what dcoutts said.
08:52:07 <quchen>  > encode (0.1 :: Double)
08:52:09 <quchen>  >>> \SOH\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\a\154\153\153\153\153\153\EM\255\255\255\255\255\255\255\200
08:52:22 <quchen> Probably not what you want when interfacing non-Binary programs :-)
08:53:19 <dcoutts> the Binary class is only for serialising and deserialising Haskell values, if you care about the external binary format (other than it be fast, compact etc) then it shows your use case is not appropriate for the Binary class
08:53:49 <dcoutts> but you should instead use the Get/Put directly, as they provide support for external formats, but you have to do the work yourself
08:54:05 <cdjk> dcoutts: okay, I'll use the Get monad. I never need to re-serialize with Put anyways.
08:55:27 <dcoutts> quicksilver: thanks for the link. The great thing about these binary formats is there's so many to choose from! :-)
08:56:01 <dcoutts> quicksilver: I've been mainly looking at MsgPack and the new CBOR (RFC 7049)
08:56:26 <dcoutts> quicksilver: the latter in particular looks quite well suited to serialising Haskell values
08:56:36 <dcoutts> (thanks to nominolo for pointing it out to me)
08:57:29 <quicksilver> dcoutts: well leonerd's format is not adopted by anyone apart from him but he's a smart guy so it represents an interesting point in the design space. A rather OOP-dominated point.
08:57:37 <quicksilver> dcoutts: there is also protocol-buffers?
08:57:53 <dcoutts> quicksilver: protobufs are not so good for Haskell
08:57:57 * quicksilver nods
08:58:07 <dcoutts> doesn't work well for deeply nested structures
08:58:27 <fizbin> protobuffs are great though for cross-language support.
08:58:46 <dcoutts> fizbin: so are any of the language neutral formats, like MsgPack
08:58:46 <fizbin> But you don't need that, apparently.
08:59:36 <dcoutts> fizbin: the main thing to get from using an externally defined format is some reassurance that the spec is ok, some tools (e.g. in other languages) you can use if you loose your schema and need to inspect/recover data
08:59:42 <Freundlich> dcoutts: I tried to add -Wl,-rpath=... to ld-options but it seems that the ghc linking invocation doesn't get it (neither for shared nor for static).
09:00:10 <Freundlich> I also tried to add this to myproject.buildinfo, which also doesn't seem to work.
09:00:12 <dcoutts> fizbin: and yes, the option for another service in another language to try to decode it is a benefit. But direct interop is not the goal, the goal is serialising Haskell values
09:03:01 <dcoutts> Freundlich: from the code it certainly looks like it passes them to ghc via -optl. You can check, run with -v and see how ghc is being invoked
09:03:13 <dcoutts> look for the -optl flags
09:06:32 <Freundlich> dcoutts: There are no -optl flags in the -v output.
09:08:00 <Freundlich> If I have mylib.cabal and mylib.buildinfo where the latter contains ld-options: something, that should be passed during the linking phase, right?
09:08:04 <Freundlich> Or am I missing something?
09:08:27 <dcoutts> Freundlich: and you're using the build-type: Configure ?
09:08:53 <dcoutts> Freundlich: quick test here works, it passes the flag
09:09:01 <dcoutts> when given in the .cabal file
09:09:16 <dcoutts> and the same should work for the .buildinfo if you're using build-type: Configure
09:09:39 <Freundlich> Oh no, I didn't use build-type: Configure.
09:10:27 <dcoutts> Freundlich: the .buildinfo is there for ./configure scripts that need to communicate via text files.
09:11:22 <Freundlich> dcoutts: That's what I want to go for (let the user pass where the library is and also record its rpath).
09:12:25 <Freundlich> dcoutts: When I change to build-type: Configure, I get an infinite "Resolving dependencies... Configuring ..." loop. I have to try to figure that out first.
09:13:42 <Freundlich> This is my current cabal file: http://codepad.org/tjCi6sI8 - Anything suspicious?
09:14:05 <Freundlich> cabal configure goes into an infinite loop, it seems.
09:14:23 <dcoutts> Freundlich: and what does ./configure do?
09:14:41 <dcoutts> does it call cabal configure? :-)
09:14:54 <Freundlich> I don't have a configure script yet.
09:15:05 <dcoutts> oh, hmm, it should just fail then
09:15:19 <Freundlich> All I wanted to try is to pass ld-options (hardcoded at first, and later configurable).
09:15:35 <dcoutts> well you can certainly hard code it
09:16:29 <dcoutts> Freundlich: what does cabal --version say? for me, when there's no ./configure it does just fail, as expected
09:16:33 <dcoutts> cabal: configure script not found.
09:17:24 <Freundlich> I'm currently on cabal-1.18.0.2 if that matters.
09:18:01 <dcoutts> Freundlich: what does cabal --version say?
09:18:30 <Freundlich> cabal-install version 1.18.0.2
09:18:30 <Freundlich> using version 1.18.1.2 of the Cabal library
09:18:35 <dcoutts> ta
09:19:27 <Freundlich> So, with build-type: Simple I tried this: http://codepad.org/1A6QHvba - I don't see the ld-options anywhere when using cabal build -v.
09:22:10 <dcoutts> Freundlich: oh, you're building a library, not an exe
09:23:09 <it3ration> morning all
09:24:14 <Freundlich> dcoutts: Yes. Does ld-options work differently there?
09:25:38 <dcoutts> Freundlich: so it's not going to use them when creating the lib, it'll use the ld options when linking an exe that uses your lib
09:25:59 <niez> is it possible to share local definitions (where) between function definitions in instance declaration? or I need to declare a function in my module scope?
09:26:50 <dcoutts> Freundlich: you can see that this will (or should) work, buy looking at the library package registration once it's installed/registered
09:27:04 <dcoutts> ghc-pkg field hsge ld-options
09:27:28 <dcoutts> those ld options will be used when linking an exe using that package
09:27:43 <dcoutts> Freundlich: sorry, I should have spotted that earlier.
09:27:56 <dcoutts> when I said I saw the -optl, I was using an exe
09:28:17 <bennofs> niez: you need to declare the function at module scope, or make a member with a default definition (only if overriding makes sense and it mentions the class variables)
09:28:33 <bennofs> oh, you said instance declaration.
09:28:37 <niez> http://lpaste.net/95943
09:28:41 <niez> here is my code
09:29:14 <bennofs> niez: you could change the pattern matching to a case expression
09:29:30 <dcoutts> quicksilver: so it looks like a similar binary format to msgpack, but with the difference that it encodes ID numbers for the types
09:29:30 <bennofs> like toXmlNode node = case node of ... where render = ...
09:29:34 <Freundlich> dcoutts: Ok, I see. Is there any way to link a shared library with special ld-options then?
09:29:57 <dcoutts> Freundlich: yes but it's hacky and not necessary.
09:30:38 <Freundlich> The C library I'm linking to isn't installed in a standard path.
09:30:48 <niez> bennofs, so all definitions of my function toXmlNode, they have separate local scope and I can't have one 'where' for them all?
09:30:48 * hackagebot git-annex 5.20131120 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20131120 (JoeyHess)
09:30:49 <bennofs> niez: or make a function errorConditionName (bad name, just an example) at module scope and then use that in toXmlNode
09:30:58 <bennofs> niez: right
09:31:15 <dcoutts> Freundlich: right, but the mechanism you're using will work just fine
09:31:24 <exicer> Ok so I really can't work out what is the way to solve this problem: I want to download a webpage, parse it, and then repeat - for example navigating to a certain page. Basically just emulating some behaviour you might have in a browser. I can't see how to do this without a massive staircase of case statements, which seems wrong.
09:32:00 <dcoutts> Freundlich: any Haskell executable you link that uses your hsge package will get the -rpath flag, so will find the C lib
09:32:06 <exicer> Any ideas how I might go about doing this ?
09:32:33 <dcoutts> Freundlich: it's just that the Haskell HShsge.so lib itself will not have an rpath, but that's ok so long as the exe does.
09:32:36 <Freundlich> dcoutts: OK, but I can't use cabal install to install the lib. It complains about the C library missing.
09:32:51 <dcoutts> Freundlich: huh?
09:32:56 <dcoutts> you'll have to be more specific
09:33:24 <dcoutts> Freundlich: are you tell cabal where to find it? e.g. with extra-lib-dirs ?
09:33:27 <niez> bennofs, can I use 'let' here?
09:33:41 <niez> let render = ... in instance ...
09:33:46 <niez> ?
09:33:53 <dcoutts> Freundlich: you can either hard code that in the .cabal file, or pass it at install/configure time, with --extra-lib-dir
09:33:56 <Freundlich> dcoutts: Yes, the linking phase succeeds.
09:34:03 <klrr_> exicer: so you want to download web pages parse them (into what?) and then archive them for later use within the program, is that correct?
09:34:19 <Freundlich> dcoutts: I'm already using --extra-lib-dir which results in -L... -l at the command line, so linking itself is fine.
09:34:31 <Freundlich> dcoutts: But when I try to use cabal install, it says this: http://codepad.org/RE7vDG7E
09:35:02 <dcoutts> Freundlich: but that's not using --extra-lib-dir
09:35:06 <Freundlich> dcoutts: The next thing I wanted to do is to write a simple executable that uses the library. If I understand correctly, I have to use cabal install so that cabal can find the library.
09:35:20 <dcoutts> Freundlich: or do you mean it's using extra-lib-dir field in the .cabal file?
09:35:46 <Freundlich> dcoutts: I'm doing: cabal configure --extra-library-dir=... ; cabal build; cabal install
09:35:56 <Freundlich> It seems like cabal install wants to reconfigure...
09:36:11 <dcoutts> Freundlich: "cabal install" is an all in one, do everything command. It configures, builds, installs.
09:36:18 <oio_> can someone explain me this BS.foldl' checkSum (0, 0) . BSC.pack $ str
09:36:25 <oio_> checkSum ::  (Word16, Word16) -> Word8 -> (Word16, Word16)
09:36:37 <dcoutts> Freundlich: so you'd want to say: cabal install --extra-library-dir=
09:36:50 <dmwit> ?@ @hoogle @type let c f g x = do { y <- f x; z <- g y; return (y, z) } in c
09:36:51 <Freundlich> dcoutts: Oh, I see, sorry about that.
09:36:53 <dcoutts> Freundlich: or, cabal configure --blah; cabal build; cabal copy; cabal register.
09:36:53 <lambdabot>  No results found
09:37:07 <dmwit> Any suggestions for cute ways to write that? =)
09:37:11 <Freundlich> dcoutts: Thanks! I think I can continue from here.
09:37:21 <dmwit> (It's like a combinations of (>=>) and liftM2.)
09:37:45 <monochrom> Freundlich: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#install
09:38:05 <dcoutts> Freundlich: and as for an exe that uses your lib, you can use cabal for that but don't have to, ghc will use the ld-options that are saved for the lib
09:40:20 <Freundlich> Ok, thanks.
09:40:53 <dcoutts> quicksilver: the tricky thing about using IDs for all the types is assigning them IDs and keeping track on which ones were used so that one can spit out metadata into the file somewhere
09:41:19 <dmwit> Also, why am I having so much trouble proving that (f >=> g = f >=> h) iff (compAccum f g = compAccum f h)?
09:42:28 <Kaidelong> what's compAccum?
09:42:34 <dmwit> oops
09:42:40 <dmwit> c from above =)
09:42:51 <dmwit> compAccum f g x = do { y <- f x; z <- g y; return (y, z) }
09:43:33 <quicksilver> dcoutts: yes. And it's not composable.
09:44:02 <quicksilver> you might have to rewrite IDs when combining files
09:44:18 <dcoutts> quicksilver: one could write out Typeable checksums, but still have to spit out metadata
09:44:23 <monochrom> @type (>=>)
09:44:24 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:44:27 <dcoutts> and it adds yet more overhead
09:44:43 <quicksilver> yup
09:44:49 <dmwit> (>=>) f g x = do { y <- f x; z <- g y; return z } -- for comparison
09:44:55 <quicksilver> silver bullets, we find them not
09:44:57 <dcoutts> quicksilver: yes, interesting point about combining files
09:45:01 <dmwit> only difference is return z vs. return (y, z)
09:45:06 <exicer> klrr_: Its more of an exercise than anything of actual use. The idea is that I would emulate some browsing - so, visit (for instance) www.imdb.com, follow a link to current films or something, parse it to find the top film, then follow the link to that film's page, and return the summary.
09:45:55 <dcoutts> quicksilver: the nearest thing I think is the binary formats that include "atom pools", like the Erlang one(s) and some of the binary JSON proposals
09:45:55 <exicer> klrr_: The problem in my thinking is that both making the request and parsing can have errors.. and I would like to know at what point an error occurs, if it does.
09:46:15 <exicer> klrr_: So the only way I can think of doing it is with a load of case statements
09:46:18 <dcoutts> quicksilver: they don't attempt to do anything with unique IDs, just a trick to compress the repeated strings
09:46:26 <dcoutts> compress/share
09:49:58 <dmwit> fmap f (m >>= g) = m >>= fmap f . g -- is this a law? this seems like it should be a law
09:51:18 <dmwit> never mind, doesn't help anyway
09:54:22 * dmwit gasps
09:54:27 <dmwit> Maybe it's hard to prove because it's not true!
09:54:28 * shapr inhales
09:54:40 <shapr> rmunroe: oh hai! I like your comix!
09:54:50 <shapr> rmunroe: Will you do one about Haskell?
09:55:09 <monochrom> dmwit: fmap f (m >>= g) = m >>= (fmap f . g) is provable.
09:55:30 <monochrom> he did one for all functional languages. :)
09:55:32 <shapr> rmunroe: Got any questions about Haskell that I could help you with?
09:55:49 <dmwit> monochrom: I think the thing I want (f >=> g = f >=> h implies compAccum f g = compAccum f h) is false, though. I'm trying to construct a counterexample using the Set monad.
09:56:09 <rmunroe> shapr: nothing right now, but thank you :)
09:56:22 <shapr> rmunroe: Sure, feel free to ask any questions you have!
09:56:35 <dmwit> A+++ very polite rejection would act creepy again
09:56:43 <shapr> haha
09:56:49 <dmwit> ;-)
09:58:24 <Kaidelong> I don't see how that could be false, they require the same basic thing, that g and h are equivalent over the codomain of f
09:59:33 <dmwit> Kaidelong: Suppose f is const [True, False].
09:59:40 <dmwit> Kaidelong: Suppose g and h are not and id, respectively.
10:00:00 <Kaidelong> not?
10:00:06 <Kaidelong> what is not in this context?
10:00:14 <dmwit> Kaidelong: Suddenly, the output of (f >=> g) and (f >=> h) are both [True, False] in some order but (compAccum f g) and (compAccum f h) are very different.
10:00:16 <dmwit> ?src not
10:00:16 <lambdabot> not True   =  False
10:00:16 <lambdabot> not False  =  True
10:00:36 <dmwit> So I think that's my counterexample.
10:01:09 <dmwit> The trouble with compAccum is that it tells you something about how to associate the codomain of f with the codomain of g or h, which (>=>) doesn't do. =)
10:01:15 <Kaidelong> @ty ((undefined :: a -> [Bool]) >=>)
10:01:16 <lambdabot> (Bool -> [c]) -> a -> [c]
10:01:38 <Kaidelong> @ty not :: Bool -> [a]
10:01:39 <lambdabot>     Couldn't match type `Bool' with `[a]'
10:01:39 <lambdabot>     Expected type: Bool -> [a]
10:01:39 <lambdabot>       Actual type: Bool -> Bool
10:01:51 <dmwit> Kaidelong: Okay, return . not and return . id, respectively.
10:02:13 <Kaidelong> return . id is id for the relevant category
10:02:19 * dmwit nods agreeably
10:02:33 <Kaidelong> so you could just use id if you have the right library loaded, so fortunately I understood that one
10:02:43 <Kaidelong> mmm
10:06:15 <Kaidelong> dmwit: I see, the counterexample works when order is not preserved
10:06:24 <dmwit> yes
10:10:57 <dmwit> In particular, the curious thing about Set is that fmap doesn't preserve the "shape" of the container.
10:11:07 <dmwit> (It may collapse elements.)
10:12:16 <Kaidelong> I guess that's not an overly surprising result given that computational contexts are allowed to introduce special semantics
10:12:34 <Kaidelong> I'm still having some trouble really getting it though
10:13:00 <Kaidelong> well
10:13:11 <Kaidelong> wait, is that a counterexample?
10:13:30 <dmwit> Yes, I'm having a bit of trouble wrapping my head around it as well.
10:13:35 <dmwit> I'm pretty sure it's a counterexample.
10:13:37 <dmwit> What worries you?
10:13:44 <Kaidelong> ([True,False],[False,True]) is still the same as ([True,False],[True,False]) if you disregard order
10:14:09 <dmwit> [(True, True), (False, False)] is not the same as [(True, False), (False, True)] in any order.
10:14:24 <dmwit> So even though (f >=> g = f >=> h), we don't have (compAccum f g = compAccum f h).
10:14:27 <Kaidelong> oh I misread compAccum then
10:14:37 <levi> fmap isn't supposed to preserve the 'shape' of things generally, is it?
10:14:49 <dmwit> levi: Dunno what "supposed to" means. =)
10:14:52 <Kaidelong> @ty compAccum
10:14:53 <lambdabot> Not in scope: `compAccum'
10:14:59 <dmwit> But it happens to for almost every Haskell Functor.
10:15:01 <Kaidelong> @hoogle compAccum
10:15:02 <lambdabot> No results found
10:15:14 <dmwit> ?let compAccum f g x = do { y <- f x; z <- g y; return (y, z) }
10:15:17 <lambdabot>  Defined.
10:15:31 <dmwit> > compAccum (const [True, False]) (return . id) ()
10:15:34 <lambdabot>   [(True,True),(False,False)]
10:15:38 <dmwit> > compAccum (const [True, False]) (return . not) ()
10:15:39 <lambdabot>   [(True,False),(False,True)]
10:15:59 <Kaidelong> I actually just wanted to look at the type of compAccum quickly cause I thought that might clarify things
10:16:04 <Kaidelong> @ty compAccum
10:16:05 <lambdabot> Monad m => (t -> m t1) -> (t1 -> m t2) -> t -> m (t1, t2)
10:16:09 <dmwit> ew
10:16:31 <dmwit> ?let compAccum :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m (b, c))
10:16:33 <lambdabot>  Defined.
10:16:36 <dmwit> :t compAccum
10:16:37 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m (b, c)
10:16:57 <Kaidelong> I don't think this will work with anything less than a monad
10:17:12 <dmwit> indeed not
10:17:16 <Kaidelong> actually
10:17:18 <levi> Well, Sum and Product functors don't preserve 'shape', for example. Aren't the only ones that preserve 'shape' the 'free' functors?
10:17:43 <dmwit> levi: Sum and Product preserve shape if the functors they're applied to do.
10:17:47 <quchen> Is there a beautiful way to zip two lists together to one? "zip' = concat . zip (\x y -> [x,y])" does the trick, i.e. "zip' [a,b,c] [x,y,z] = [a,x,b,y,c,z]", but I feel like there should be a better way.
10:17:52 <dmwit> fmap (Left x) = Left (fmap f x) -- same shape
10:18:08 <dmwit> quchen: transpose [x, y]
10:18:10 <levi> Maybe I'm not understanding what you mean by 'shape'
10:18:26 <dmwit> > [[a,b,c], [x,y,z]] >>= transpose
10:18:29 <dmwit> oops
10:18:30 <lambdabot>   Couldn't match type `[a0]' with `Debug.SimpleReflect.Expr.Expr'
10:18:30 <lambdabot>  Expected t...
10:18:38 <dmwit> > concat $ transpose [[a, b, c], [x, y, z]]
10:18:40 <lambdabot>   [a,x,b,y,c,z]
10:19:00 <dmwit> levi: For Haskell, let's say the spine of the data structure.
10:19:44 <quchen> dmwit: That looks good. It's even keeping elements if the lists are of unequal length, which the zip version doesn't.
10:24:00 <FireFly> dmwit: "but it (fmap preserving 'shape') happens for almost every Haskell Functor" ← almost? AIUI this is what the  id = fmap id  law gurantees, which would make it every functor
10:24:15 <dmwit> id = fmap id does not guarantee that at all
10:24:24 <dmwit> It just guarantees that fmap id preserves the shape. =)
10:24:42 <FireFly> Hm
10:25:09 <dmwit> Well. Things are complicated a bit by the fact that Haskell doesn't really do subcategories very well.
10:25:16 <int-e> @free (a -> b) -> f a -> f b
10:25:16 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
10:25:22 <dmwit> It's possible that in fact every law-abiding Haskell Functor preserves shape.
10:25:23 <int-e> @free fmap :: (a -> b) -> f a -> f b
10:25:23 <lambdabot> Extra stuff at end of line
10:25:28 <int-e> :(
10:25:28 <dmwit> But I wasn't sure, so I didn't try to claim it.
10:25:37 <int-e> @free map
10:25:39 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:26:31 <FireFly> Hm, so I misread your line then, treating it as "there exists counterexamples" rather than "this is a weaker claim"
10:27:14 <Kaidelong> FireFly: note that monads also obey id = fmap id
10:27:56 <dmwit> Kaidelong: What's the implication of that?
10:28:30 <FireFly> Kaidelong: yes, and many monads do preserve their structure if you `fmap` them
10:28:44 <levi> dmwit: I was just confused in general, and don't have time to think through things at the moment. Thanks for humoring my questions, though.
10:30:23 <dmwit> someday, far in the future, perhaps we will get an instance Functor Set
10:30:55 <Kaidelong> FireFly, dmwit: I misunderstood something
10:31:01 <Kaidelong> disregard that
10:31:22 <Kaidelong> both what firefly was saying and something more fundamental
10:31:33 <dmwit> ok =)
10:31:42 <dmwit> Hope it's cleared up now, but if not say so.
10:31:54 <int-e> dmwit: so free theorem for fmap and fmap id = id together say that fmap f = $map id . fmap f = map id . $map f = $map f, i.e. fmap is $map, the functor's "natural" fmap.
10:32:29 <dmwit> int-e: I wonder; can we use free theorems to prove the theorem I want?
10:32:41 <dmwit> It seems plausible, if the claim is "free theorems rule out shape-changing functors".
10:32:44 <int-e> map id --> fmap id (miscopy from the @free output above)
10:33:12 <int-e> dmwit: fmap id = id  is what rules out the shape change.
10:33:31 <dmwit> fmap id = id is what rules out the shape change *in Haskell*.
10:33:37 <int-e> otherwise you could have "fmaps" like  fmap f xs = [].
10:33:40 <int-e> dmwit: right.
10:33:42 <dmwit> Because we have parametricity, and therefore free theorems.
10:34:04 <dmwit> I can show that the theorem I want does not hold if parametricity doesn't.
10:34:15 <dmwit> Hence my question: can I show it does hold if parametricity does?
10:34:30 <dmwit> I don't understand free theorems well enough to have an intuition about how to use them. =/
10:40:39 <dmwit> :t compAccum
10:40:40 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m (b, c)
10:40:46 <dmwit> ?free Monad m => (a -> m b) -> (b -> m c) -> a -> m (b, c)
10:40:46 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
10:43:33 <randomlogin> How can i transform to unicode such string "\1083\1086\1083"?
10:43:41 <dmwit> mu
10:43:46 <dmwit> The String is already Unicode.
10:44:07 <randomlogin> then how can i display it?
10:44:14 <tarruda> does haskell caches the result of pure functions ?
10:44:17 <dmwit> Perhaps you would like to know how to produce bytes that represent such a String in some encoding you have in mind?
10:44:24 <dmwit> tarruda: Not unless you explicitly ask for it.
10:44:34 <randomlogin> dmwit: yes
10:44:39 <dmwit> randomlogin: Which encoding?
10:44:45 <randomlogin> utf8
10:44:50 <tarruda> dmwit: where do I read more about that feature?
10:45:01 <dmwit> tarruda: well
10:45:10 <donri> randomlogin: use putStrLn instead of print
10:45:10 <dmwit> tarruda: The precise answer is, "not in GHC, unless you ask for it<
10:45:28 <dmwit> tarruda: And the feature is "let" and "where".
10:45:44 <dmwit> Things bound to names get shared.
10:45:53 <dmwit> randomlogin: There's several packages to choose from.
10:45:55 <int-e> dmwit: I think I have answered that question actually. Given fmap id = id and the free theorem (curtesy of paramtricity), we can prove that fmap is *the* functorial map, which preserves shape.
10:46:10 <dmwit> int-e: I don't see how to use that to prove the theorem I want.
10:46:47 <dmwit> ?hackage utf8-string
10:46:47 <lambdabot> http://hackage.haskell.org/package/utf8-string
10:46:49 <dmwit> ?hackage encoding
10:46:50 <lambdabot> http://hackage.haskell.org/package/encoding
10:46:59 <dmwit> There's also some stuff in base, in um...
10:47:03 <dmwit> System.Encoding, I think?
10:47:05 <dmwit> randomlogin: ^^
10:47:11 <int-e> dmwit: The trick (if any) is to set g = k = id and h = f in g . h = k . f => $map g . fmap h = fmap k . $map f. $map id = id is a property of functors, and fmap id = id is given.
10:47:46 <dmwit> int-e: My theorem is "if (f >=> g = f >=> h), then (compAccum f g = compAccum f h)".
10:48:28 <dmwit> How do I use an observation about fmap here?
10:49:22 <skypers> hi
10:49:27 <randomlogin> dmwit: thanks
10:49:29 <int-e> dmwit: I didn't see that. (more than an hour ago, I was doing something different then.)
10:49:57 <dmwit> int-e: I figured, after you gave me the same apparently unrelated answer the third time, which isn't very like you. =P
10:51:04 <dmwit> :t compAccum
10:51:06 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m (b, c)
10:56:27 <mr-> :t compAccum
10:56:28 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m (b, c)
10:56:50 <mr-> Oops.. pays to read some of the history..
10:57:06 <int-e> dmwit: anyway it will not come for free; you have to look inside compAccum. Consider  f _ = put 0; g _ = modify (\x -> x + 1); h _ = modify (\x -> 2*x + 1). Then f >=> g === f >=> h, but f >=> g >=> g =!= f >=> h >=> h
10:57:28 <dmwit> int-e: I'm happy to look inside compAccum.
10:57:44 <dmwit> I demand that compAccum f g x = do { y <- f x; z <- g y; return (y, z) }
10:58:07 <dmwit> I only showed the type of compAccum so you could guess this implementation yourself. =)
10:58:14 <int-e> dmwit: That's fine. I'm just refuting the free theorem idea as a possible venue for a proof.
10:58:17 <dmwit> I suspect, if anything, that the free theorem will still have to be the one about fmap.
10:58:20 <dmwit> I just don't see how to use it.
10:58:43 <dmwit> Because I observe that the only counterexample I can think of involves allowing fmap to change the shape of its second argument.
10:58:48 <int-e> (at least when applied to compAccum without looking inside)
11:00:25 <dmwit> Right. I was never proposing using compAccum's free theorem in the first plaec.
11:00:32 <dmwit> (Though I was sort of curious what it would look like. =)
11:00:55 <_justjust> map f . concat = concat . map (map f) which is more efficient and why?
11:01:18 <dmwit> measure it
11:01:44 <dmwit> Probably the answer will depend on the context, though.
11:02:10 <dmwit> e.g. maybe one or the other can do list fusion in some situation
11:02:14 <mr-> dmwit: your theorem is wrong when g is not monic
11:02:14 <_justjust> i'm reading about bird/meertens formalism and this a rule
11:02:31 <dmwit> mr-: Okay. Remind me what monic means?
11:02:41 <mr-> (I must be misunderstandin your theorem, I think)
11:03:00 <mr-> dmwit: injective
11:03:57 <mr-> Ah, swapped the arguments. I take everything back
11:04:56 <mr-> and claim the opposite ;-)
11:05:19 <dmwit> well, you're wrong =)
11:05:23 <dmwit> g being injective is not enough
11:05:54 <dmwit> work in the Set monad; take f = const {True, False}; g = return . id; h = return . not
11:06:07 <dmwit> both g and h are injective, and (f >=> g = f >=> h)
11:06:15 <dmwit> but compAccum f g /= compAccum f h
11:06:50 <mr-> I think I am confusing the order of composition
11:07:27 <dmwit> (>=>) and compAccum have the same composition order
11:07:37 <dmwit> the only difference is that compAccum returns both the final and intermediate result
11:07:47 <dmwit> whereas (>=>) only returns the final result
11:10:58 <dmwit> > let x ~> y = not x || y in [x ~> y | (x, y) <- U.universe]
11:11:00 <lambdabot>   Not in scope: `U.universe'
11:11:05 <dmwit> oh
11:11:06 <dmwit> too bad
11:11:33 <dmwit> > let x ~> y = not x || y; uni = [False, True] in [x ~> y | x <- uni, y <- uni]
11:11:34 <lambdabot>   [True,True,False,True]
11:11:57 <dmwit> > let x ~> y = not x || y; uni = [False, True] in [(x ~> y) || (y ~> x) | x <- uni, y <- uni]
11:11:58 <lambdabot>   [True,True,True,True]
11:12:58 <latro`a> that last one secretly implies the principle of explosion
11:12:59 <latro`a> :D
11:13:46 <Eduard_Munteanu> If I want to do SSL/TLS, what's a very common Haskell package that does that?
11:14:02 <Eduard_Munteanu> Perhaps something based on HTTP?
11:14:10 <klugez> http-conduit at least.
11:15:21 <Eduard_Munteanu> I was looking at 'tls' but being native implementation makes me uneasy.
11:15:51 <burp> if you want to serve http with tls, warp/warp-tls
11:15:58 <Eduard_Munteanu> klugez: hm, that seems nice... what do I use on the server side though?
11:16:16 <Eduard_Munteanu> Hm.
11:16:32 <burp> uses "tls", which is again "Native Haskell TLS and SSL protocol implementation for server and client."
11:16:55 <burp> other than that I think there are just some outdated openssl bindings
11:17:07 <klugez> Eduard_Munteanu: Ah, http-conduit seems to use tls under the hood, so that won't address that concern.
11:17:22 <Eduard_Munteanu> I just want to implement a SSL/TLS-protected protocol in Haskell, really, and I was hoping to do it with the mainline Gentoo ebuilds.
11:17:27 <burp> wait, HsOpenSSL doesn't seem to be outdated
11:18:00 <burp> yea, looks good if you want a non-native implementation
11:18:06 <Eduard_Munteanu> klugez: any idea if 'tls' is alright?
11:18:40 <burp> it's used by yesod, warp and http-conduit, shouldn't be total crap ;)
11:18:40 <Eduard_Munteanu> I think I could just use stunnel.
11:19:21 <Eduard_Munteanu> I was also wondering if there's a stunnel equivalent for DTLS.
11:19:26 <klugez> No competent idea, but can't be too obviously bad due to the reasons burp said.
11:21:56 <Sculptor> hello!
11:22:29 <Jeanne-Kamikaze> yo
11:22:51 <lpaste> “_justjust” pasted “ghci” at http://lpaste.net/95944
11:23:07 <_justjust> ghci consumes 3gb ram is this normal?
11:24:14 <simpson> _justjust: You asked for a pretty big value!
11:24:50 <_justjust> ok and x is not just a thunk there?
11:24:56 <_justjust> or y
11:25:21 <merijn> Is that virtual memory or real memory?
11:25:59 <_justjust> system was kinda unresponsive
11:27:08 <_justjust> ahhh
11:28:01 <skypers> today I got how to use contramap
11:28:10 <skypers> but it’s still some magics to me :)
11:28:20 <_justjust> it was length x and i guess ctrl-c does not stop it in the background just in ghci
11:28:21 <skypers> its type is _really_ weird
11:28:21 <edwardk> =)
11:28:44 <skypers> I experienced Contravariant with Predicate
11:28:53 <edwardk> data Predicate a = Predicate (a -> Bool) -- think of how you can map it backwards
11:29:14 <skypers> and think of contramap first parameter (the function) as a function mapped before testing the predicate
11:29:41 <skypers> edwardk: mapping backwards would mean – for me – “given a Bool, I get a”
11:29:48 <skypers> and it just collides in my mind :D
11:30:02 <_justjust> so is it normal that ghci does not free the memory of an interrupted computation?
11:30:05 <skypers> but hm
11:31:11 <skypers> > getPredicate ( contramap length (Predicate $ \x -> x `mod` 2 == 0) ) "hello"
11:31:12 <lambdabot>   Not in scope: `getPredicate'Not in scope: data constructor `Predicate'
11:31:17 <skypers> ok well, here
11:31:19 <simpson> _justjust: You bound the value to a name using `let`; ghci will thus hold the value for you.
11:32:08 <skypers> I just read the contramap length as « given a predicate Predicate b, we just wanna know whether its truthiness with length mapped before
11:32:10 <_justjust> ahh makes sense
11:32:15 <_justjust> thank you
11:32:19 <dmwit> edwardk: I have a proposal for monadic lens laws.
11:32:37 <dmwit> edwardk: do { r <- putr l; l' <- putl r; f r l' } = do { r <- putr l; f r l }
11:32:42 <dmwit> edwardk: Is this a known thing?
11:33:04 <edwardk> putr?
11:33:09 <dmwit> err
11:33:13 <skypers> putR?
11:33:19 <dmwit> I have a proposal for symmetric monadic lens laws. =P
11:33:26 <dmwit> But read get/put instead of putr/putl if you like.
11:33:49 <dmwit> data Lens m l r = Lens { putr :: l -> m r; putl :: r -> m l }
11:33:58 <edwardk> skypers: you can view it as (a -> Bool) -> (b -> a) -> b -> Bool   -- which is just (.)
11:34:33 <skypers> edwardk: so what does it _really_ mean?
11:34:36 <edwardk> dmwit: ok, so this is a form of monadic isomorphism?
11:34:46 <skypers> btw
11:34:51 <skypers> it’s -> (b -> Bool)
11:34:52 <dmwit> I think it's much weaker than isomorphism.
11:34:56 <skypers> not b -> Bool
11:35:04 <Kaidelong> honestly I find the new lens library much more amazing just using it and not worrying about how it works
11:35:06 <int-e> > let f _ = [0,1,2]; g n = replicate n (); h n = [()] in ((f >=> g) () == (f >=> h) (), compAccum f g () == compAccum f h ()) -- dmwit :) (am I too late again?)
11:35:09 <lambdabot>   (True,False)
11:35:12 <edwardk> Kaidelong: hah
11:35:14 <Kaidelong> if you do worry about how it works it seems like a bit of a hack
11:35:17 <edwardk> dmwit: it is
11:35:26 <edwardk> dmwit: especially the way you guys use them
11:35:27 <edwardk> =)
11:35:33 <dmwit> int-e: Cool, let me read it!
11:36:02 <dmwit> edwardk: right =)
11:36:15 <skypers> seriously, the contravariance is a concept I have issues with
11:36:33 <Kaidelong> there are some other haskell libraries where I ended up accepting I'd be more productive and understand it better if I were like "MAGIC!!!", hood was one of them
11:36:48 <Kaidelong> and accelerate
11:36:49 <dmwit> int-e: Yes, perfect.
11:37:58 <skypers> :t contramap
11:37:59 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
11:38:24 <skypers> if f b is a Predicate b, how is the logic, the idea, of contramap here?
11:38:41 <skypers> it map a function backward on a Predicate
11:38:48 <skypers> what does it just mean?
11:38:49 <skypers> maps*
11:38:55 <simpson> skypers: It turns a predicate on b to a predicate on a.
11:39:01 <skypers> simpson: …
11:39:02 <skypers> yeah
11:39:03 <skypers> I know that
11:39:07 <skypers> what does it mean?
11:39:25 <skypers> if b == String and a == Int
11:39:26 <Ankhers> rg
11:39:29 <skypers> what does it mean?
11:39:47 <dmwit> skypers: I'm not sure this particular thing has a "meaning" that's explicable other than "do the calculations".
11:39:56 <skypers> dmwit: hm
11:39:58 <dmwit> Which I'm afraid is what I was ranting against saying last night.
11:40:04 <skypers> I would have thought of hm
11:40:06 <simpson> skypers: It means that it would let you turn a predicate on Strings into a predicate on Ints.
11:40:10 <skypers> implying
11:40:11 <skypers> you know
11:40:25 <skypers> simpson: you don’t understand the question I asked
11:40:29 <skypers> I know the concept
11:40:35 <simpson> skypers: I guess not!
11:40:37 <skypers> how it flips around the morphism
11:40:47 <skypers> I just don’t understand the meaning in term of predicates
11:41:18 <simpson> You know what a predicate *is*, right?
11:41:19 <skypers> for instance
11:41:25 <skypers> Predicate a -> Predicate b
11:41:49 <edwardk> skypers: remove the newtype and consider the type of it as if it were (.) or flip (.)
11:41:50 <skypers> I would say here “if we know a predicate a it directly implies that… something… on b”
11:41:57 <dmwit> skypers: I've got a mapping from "a"s to "b"s, and a subset of the "b"s. What is the subset of the "a"s which map to my subset?
11:42:08 <dmwit> skypers: This is the question that contramap answers.
11:42:20 <skypers> dmwit: now it becomes magics again
11:42:26 <dmwit> why magic?
11:42:30 <skypers> because of that:
11:42:31 <simpson> skypers: Which part is magic?
11:42:40 <skypers> given Predicate (==0)
11:43:05 <skypers> going backward would result is “the subset is 0”
11:43:27 <skypers> if the predicate is True, then the subset is 0
11:43:29 <dmwit> well, "the subset is {0}", but otherwise, yes, I'm with you so far
11:43:35 <skypers> ok
11:43:43 <skypers> but this is not what contramap does
11:43:43 <dmwit> Wait, I'm not with you on "if the predicate is True then the subset is 0".
11:43:53 <dmwit> That claim doesn't seem to typecheck.
11:44:02 <dmwit> "True" is not a predicate, and "0" is not a subset.
11:44:08 <skypers> yeah yeah
11:44:17 <skypers> I’m just talking about contravariance
11:44:24 <skypers> I could reformulate
11:44:25 <skypers> wait
11:44:29 <dmwit> Yes, please reformulate.
11:44:44 <dmwit> Because if that is the step that's magic, then that's where the problem is.
11:44:55 <skypers> if we know a predicate on b, going backward would give us a hint on a predicate a
11:45:16 <dmwit> I don't like this "backward" stuff. I don't know what it means.
11:45:20 <simpson> skypers: Imagine, with your example, that we use `contramap length`. Then we'd get a Predicate on lists.
11:45:30 <dmwit> If we know a predicate on b and a function from a to b, then we have a hint on a predicate on a.
11:45:37 <skypers> simpson: so that means
11:45:38 <simpson> Which would be equivalent to `Predicate (\x -> length x == 0)`.
11:45:53 <skypers> yeah so it just maps *before*
11:45:55 <skypers> right?
11:46:39 <simpson> You could think of the mapping as happening on the *left* side instead of the right side of the function; this is the "contrary" nature of contramap.
11:46:53 <skypers> ok
11:46:54 <skypers> yeah
11:46:56 <skypers> so
11:46:57 <simpson> At least that's always how I remember the direction.
11:46:57 <skypers> now
11:47:01 <skypers> I totally got it
11:47:15 <skypers> the thing is, I was seriously misunderstanding the notion of contravariance
11:47:22 <skypers> I thought of reversed functions
11:47:27 <skypers> or application, or morphisms
11:47:41 <skypers> like hm
11:47:44 <skypers> bijectivity
11:47:51 <skypers> (is that even english? :D)
11:47:52 * simpson &
11:48:02 <skypers> &?
11:48:14 <edunham> it's how you background a process; means he's afk for a bit.
11:48:29 <skypers> now I understand the sig of contramap
11:48:34 <dmwit> \o/
11:48:42 <skypers> the (a -> b) function is just “premapped” on the f b
11:48:47 <skypers> and then we get a f a
11:48:53 <skypers> that’s great :)
11:49:50 <dmwit> ?unmtl StateT s []
11:49:50 <lambdabot> Plugin `unmtl' failed with: `StateT s []' is not applied to enough arguments, giving `/\A. s -> [] (A, s)'
11:49:54 <dmwit> ?unmtl StateT s [] a
11:49:54 <lambdabot> s -> [] (a, s)
11:50:16 <skypers> I thought that contravariant meant ”f(x) = x + 1, f is contravariant in x means that if have f(x), we can state that x = f(x)-1”
11:50:19 <skypers> or something like that
11:50:26 <dmwit> I wonder why it fails instead of just answering /\A. s -> [] (A, s)
11:50:46 <skypers> I wonder how it’s called such a concept
11:50:48 <dmwit> skypers: Ah, yeah, that *would* be magic. =)
11:50:56 <skypers> bijection, maybe
11:50:58 <dmwit> That's called an "inverse", and computing them is hard.
11:51:13 <skypers> dmwit: yeah well, fix is kinda of isn’t it?
11:51:28 <skypers> it gives you the first lower fix points of a function
11:51:33 <dmwit> fix is kind of what?
11:51:39 <skypers> a bijection
11:51:43 <dmwit> wut
11:52:09 <skypers> well nevermind, we don’t care about fix here
11:52:27 <skypers> I just need to fully understand the sentence “f is covariant in y and contravariant in x”
11:53:08 <schell> what's more common - to have less varying parameters at the beginning or at the end of a function?
11:53:24 <skypers> at the end schell
11:53:39 <schell> skypers: so they can be curried?
11:53:42 <skypers> think of reader functions
11:53:43 <skypers> yes
11:54:12 <skypers> I personnaly write functions with parameters sorted from the least shared to the most
11:54:35 <schell> doesn't currying happen from left to right though?
11:54:39 <dmwit> wait
11:54:45 <dmwit> less varying parameters should go first, not last
11:54:57 <skypers> schell: well hm I mean if you have two functions like
11:55:03 <skypers> foo :: a -> b -> c -> String
11:55:04 <skypers> and
11:55:09 <skypers> bar :: e -> f -> String
11:55:33 <skypers> it’s better to write them that way if String is shared between both and a b c e and f are just constants
11:55:50 <schell> ah - i see
11:55:56 <schell> you guys are agreeing
11:56:03 <dmwit> I don't see.
11:56:04 <skypers> if you write String first
11:56:06 <schell> but thinking about it differently
11:56:13 <dmwit> String is not an argument. It can't move.
11:56:15 <skypers> it would result in lambda
11:56:25 <skypers> dmwit: hm
11:56:26 <schell> a b c e and f are all constants
11:56:31 <schell> so they don't vary
11:56:40 <edwardk> monochrom: ping
11:56:51 <skypers> liftM2 (>>) (foo 2 8 6 3) (bar 3) "the String"
11:56:57 <skypers> instead of
11:57:10 <skypers> liftM2 (>>) (\s -> foo s 2 8 6 3) (\s -> bar s 3) "the String"
11:57:31 <edwardk> monochrom: it looks like i may wind up out in toronto on the 30th for a day as an extended layover, visiting with a friend.
11:57:50 <skypers> 20:40 < dmwit> less varying parameters should go first, not last
11:58:02 <skypers> it’s exacly what I think, yeah, we agree :)
11:58:05 <skypers> exactly*
11:58:14 <dmwit> Okay. It's not what you said, though.
11:58:21 <schell> skypers, dmwit: thanks, got it :)
11:58:47 <skypers> dmwit: I might not be really comprehensive tonight, sorry for the misunderstanding
11:58:59 <skypers> I typo every sentences I write, I’m so tired :D
11:59:44 <dmwit> schell: There's another reason than currying.
11:59:54 <mm_freak_> maybe x id -- hlint suggests to use 'fromMaybe', but i actually prefer 'maybe' there
11:59:59 <schell> skypers: that's my whole world, but i'm also typing on data hands
12:00:04 <dmwit> In GHC, you can write something like f x = let y = expensiveComputation x in \z -> ...
12:00:19 <dmwit> and expensiveComputation will be shared among many invocations of, say, (f 3).
12:00:28 <skypers> schell: yeah
12:00:35 <edwardk> i always remember variance from physics distinguishing between vectors (e -> r) and covectors (e -> r) -> r -- the basis e in a covector is covariant, the basis e in a (contra)vector is contravariant.
12:00:36 <dmwit> schell: So you want the less-varying parameters to go first to maximize the sharing.
12:00:45 <skypers> when I’m very tired I often make typo, it’s annoying
12:00:49 <schell> dmwit: i see - is that memorizing?
12:00:53 <edwardk> but that mnemonic may only work for me
12:00:54 <schell> memo-izing*
12:01:09 <dmwit> schell: It's related, though I don't think identical.
12:01:16 <skypers> edwardk: yeah, I didn’t study such a thing
12:01:29 <schell> cool
12:01:30 <edwardk> then you can view a dot product dot :: (e -> r) -> (e -> r) -> r   as taking a vector to a covector
12:01:42 <skypers> but it makes me thing of kernels of applications
12:01:44 <skypers> and images
12:02:17 <skypers> I forget the name of the reversed application that, given an image, outputs an element from the kernel of the application
12:03:07 <dmwit> (Okay, right: this is more general than memoizing because the work you do doesn't have to be "cache the output for all possible values of y". It can be less work than that -- or more.)
12:03:19 <skypers> oh yeah, it’s id
12:03:39 <skypers> id(e) with e in the kernel is e_i with e_i the neutral element of the image set
12:03:47 <skypers> reminds me good maths course!
12:04:27 <skypers> I just wonder why it’s called a “kernel”
12:06:11 <skypers> ok so hm
12:06:31 <skypers> contrmap a function on another function would result in mapping the function back?
12:06:41 <skypers> contramap f g = g . f
12:06:49 <skypers> @src (->) contramap
12:06:49 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:06:56 <skypers> what? :D
12:07:10 <HalfWayMan> LOL
12:08:06 <mm_freak_> lambdabot--
12:09:09 <skypers> oh, (->) is not an instance, why?
12:09:55 <geekosaur> that is not certain
12:10:01 <geekosaur> @src is a very limited database
12:10:02 <lambdabot> Source not found. Whoa.
12:10:11 <skypers>       add an instance declaration for (Contravariant ((->) a0))
12:10:42 <mm_freak_> @djinn (a -> b) -> (e -> b) -> e -> a
12:10:42 <lambdabot> -- f cannot be realized.
12:11:02 * hackagebot testing-feat 0.4.0.1 - Functional Enumeration of Algebraic Types  http://hackage.haskell.org/package/testing-feat-0.4.0.1 (JonasDuregard)
12:11:06 <ion> Chuck Norris wrote that instance once.
12:11:12 <skypers> :)
12:11:47 <mm_freak_> that was bruce schneier
12:12:31 <malorie> is the ordering of Chars fixed, or does it depend on the underlying character-set?
12:12:48 <ion> Char represents a Unicode codepoint.
12:13:10 <malorie> ah, ok
12:21:03 * hackagebot hopfield-networks 0.1.0.0 - Hopfield Networks for unsupervised learning in Haskell  http://hackage.haskell.org/package/hopfield-networks-0.1.0.0 (ajtulloch)
12:21:40 <skypers> yeah it’s not possible to write an instance of Contravariant for (->)
12:21:47 <skypers> let contracompose :: (a -> b) -> (r -> b) -> (r -> a); contracompose f g = \r -> g r
12:21:50 <skypers> and I’m stuck
12:22:37 <edwardk> skypers: newtype Op a b = Op (b -> a) you can write a contravariant instance for (Op a)
12:22:46 <skypers> ok ok
12:22:48 <skypers> don’t tell me
12:22:50 <edwardk> skypers: the issue is the argument you want to map over isn't the 'last one'
12:22:51 <skypers> gonna do that!
12:27:02 <skypers> edwardk: I think I got it
12:27:03 <skypers> Prelude Data.Functor.Contravariant> let contraop :: (a -> b) -> Op a b -> Op a a; contraop f o = Op (getOp o . f)
12:27:07 <skypers> is that right?
12:27:30 <edwardk> contraop :: (a -> b) -> Op x b -> Op x a
12:27:35 <edwardk> the a's don't have to mach
12:27:39 <edwardk> er match
12:27:49 <skypers> yeah sure
12:27:51 <edwardk> but yes
12:27:51 <skypers> ahah
12:27:59 <skypers> contramap is so powerful
12:28:06 <skypers> but, I just wonder when to use it :D
12:28:10 <edwardk> now you need to learn dimap =)
12:28:14 <edwardk> :t (dimap)
12:28:16 <skypers> profoncteurs
12:28:18 <skypers> -eu+o
12:28:18 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
12:28:19 <skypers> yeah
12:28:23 <skypers> it makes me SO sick :D
12:28:27 <skypers> contravariant in the first
12:28:32 <skypers> and covariant in the second
12:28:33 <skypers> right?
12:28:37 <edwardk> yep
12:28:40 <edwardk> consider p = (->)
12:28:44 <skypers> sounds so weird :D
12:28:57 <edwardk> @djinn (a -> b) -> (c -> d) -> (b -> c) -> a -> d
12:28:57 <lambdabot> f a b c d = b (c (a d))
12:29:01 <edwardk> thats all
12:29:07 <skypers> what is djinn btw?
12:29:17 <edwardk> @djinn-add data Op a b = Op (b -> a)
12:29:27 <edwardk> @djinn (a -> b) -> Op x b -> Op x a
12:29:27 <lambdabot> f a b =
12:29:27 <lambdabot>     case b of
12:29:27 <lambdabot>     Op c -> Op (\ d -> c (a d))
12:29:37 <edwardk> its a theorem prover that finds programs
12:29:47 <skypers> oh
12:29:48 <skypers> nice
12:30:10 <skypers> 21:14 < lambdabot> f a b c d = b (c (a d))
12:30:18 <skypers> still weird
12:30:44 <edwardk> @djinn-add data Foldr r a b = Foldr (r -> b) (a -> r -> r) r
12:30:45 <bennofs> you could eta-reduce it: dimap a b c = b . c . a
12:31:09 <bennofs> (for p = (->))
12:31:10 <edwardk> @djinn (a -> b) -> (c -> d) -> Foldr r b c -> Foldr r a d
12:31:10 <lambdabot> f a b c =
12:31:10 <lambdabot>     case c of
12:31:10 <lambdabot>     Foldr d e f -> Foldr (\ _ -> b (d f)) (\ g h -> e (a g) h) f
12:31:26 <edwardk> eh, not perfect
12:31:26 <skypers> :–’(
12:31:28 <skypers> I feel like
12:31:29 <skypers> shit.
12:31:32 <skypers> sorry.
12:31:33 <skypers> :D
12:31:41 <edwardk> @djinn-add data Foldr' r s a b = Foldr' (r -> b) (a -> r -> s) r
12:31:49 <edwardk> @djinn (a -> b) -> (c -> d) -> Foldr r s b c -> Foldr' r s a d
12:31:49 <lambdabot> Error: kind error: (KArrow (KVar 2) (KVar 9),KVar 8)
12:31:53 <edwardk> doh
12:31:57 <edwardk> @djinn (a -> b) -> (c -> d) -> Foldr' r s b c -> Foldr' r s a d
12:31:58 <lambdabot> f a b c =
12:31:58 <lambdabot>     case c of
12:31:58 <lambdabot>     Foldr' d e f -> Foldr' (\ _ -> b (d f)) (\ g h -> e (a g) h) f
12:32:05 <skypers> edwardk: appart lens, when do you use profonctors?
12:32:06 <edwardk> still borked
12:32:40 <edwardk> i use them in my folds package. i just added them to my succinct data structures package for building a generic notion of a "Builder" that can be used to build vectors, succinct data structures, lists, etc.
12:33:02 <edwardk> i use them all over now that i know to look for them
12:33:19 <skypers> :–’
12:33:20 <skypers> ok
12:33:25 <bennofs> edwardk: how does that Builder work?
12:33:33 <skypers> you just impress me with all your maths knowledge
12:33:39 <edwardk> bennofs: http://ekmett.github.io/succinct/Succinct-Dictionary-Builder.html
12:33:40 <c_wraith> Is there anything that's combined observable sharing with free monads such that you can write an interpreter that doesn't loop?
12:33:43 <edwardk> i just figured it out this morning
12:34:31 <edwardk> bennofs: data Building m a b where Building :: (x -> m b) -> (x -> a -> m x) -> m x -> Building m a b
12:34:32 <skypers> but hm, I feel stronger in maths now I have been talking with you for a few weeks
12:34:41 <edwardk> bennofs: that looks like the arguments to foldlM
12:34:51 <skypers> learning maths concepts through haskell and wikipedia / talks, it’s just amazing
12:35:02 <edwardk> then a "Builder" is newtype Builder a b = Builder (forall s. Building (ST s) a b)
12:35:06 <edwardk> which is a profunctor
12:35:33 <skypers> hihi
12:35:38 <skypers> if you say so
12:35:40 <skypers> :)
12:35:47 <edwardk> math is one of those things you get by constant repetition and iterative deepening. once you realize you don't need to be afraid of math it kind of pours in
12:35:55 <skypers> oh btw, I need to talk to the maintener of OpenGL.Raw
12:36:04 <skypers> do you know where I can contact him?
12:36:08 <edwardk> bennofs: the nice thing about (Building s)  and Builder is they form profunctors, applicative, etc.
12:36:14 <edwardk> skypers: is that still lispy ?
12:36:23 <skypers> I don’t know
12:36:33 <skypers> but I’m becoming really active in Haskell through OpenGL
12:36:36 <skypers> I’m a demomaker
12:36:39 <bennofs> edwardk: What can you do with the profunctor instance? Change from what a vector (example) is built?
12:36:43 <skypers> and plan to stay in Haskell now
12:36:49 <DaveH_prime> Hello.  I'm a puzzled Haskell newbie.  Is it okay if I just drop my question in?
12:36:54 <skypers> then highly contribute to the OpenGL.Raw package
12:36:55 <bennofs> DaveH_prime: yes
12:36:56 <ayegill> certainly
12:37:01 <edwardk> skypers: did you see my tweet the other day?
12:37:09 <c_wraith> DaveH_prime: it's expected.  Just be ready for 5 different people to answer you at once. :)
12:37:10 <skypers> about demoscene on twitter
12:37:11 <skypers> sure
12:37:24 <skypers> I was like “DUH? he makes demo too?!”
12:37:25 <skypers> :)
12:37:36 <edwardk> https://twitter.com/kmett/status/400980710187479040
12:37:40 <skypers> but hm, the link you post is old isn’t it
12:37:43 <edwardk> yeah it was
12:37:51 <skypers> yeah
12:38:00 <skypers> I have two intro for now
12:38:01 <skypers> 64k
12:38:06 <skypers> (actually 42k both)
12:38:07 <edwardk> but I ran into the guy who did that and others in budapest, so i figured i'd share
12:38:08 <skypers> written in C++
12:38:26 <skypers> I’ll be releasing a demo by the end of the year if all is okay with my Haskell engine
12:38:36 <skypers> yeah great edwardk :)
12:38:45 <edwardk> i used to pitch in algorithms for demos but that was mostly in the 90s, before i found out there was more money in working on game stuff instead =)
12:38:55 <skypers> ahah
12:38:57 <skypers> yeah well
12:39:06 <skypers> demoscene-ing is all but money
12:39:13 <skypers> we don’t give a damn at it
12:39:27 <skypers> it’s a hobby
12:39:38 <edwardk> yeah. i'm sort of adjoint to the demo scene in that respect ;)
12:39:40 <skypers> a lot of friends sceners are in 3D compagny
12:39:46 <skypers> :)
12:40:04 <edwardk> most of my scener friends went on to make games when they moved on
12:40:09 <skypers> I know a guy from a very famous demoscene band who actually works… at Ubisoft, in Montréal
12:40:14 <skypers> yeah
12:40:22 <skypers> I plan to join such a compagny
12:40:26 <skypers> or an animation one
12:40:27 <dmwit> What edwardk isn't telling you is he uses money as a proxy for having a good measurement of "actually useful to somebody", and likes being useful.
12:40:29 <edwardk> they all do either movie special effects or game dev now
12:40:30 <skypers> like Pixar or somewhat
12:40:34 <edwardk> dmwit: =)
12:40:37 <DaveH_prime> Thanks.  I'm puzzled by the behaviour of 'undefined' in an IArray.  I'm in GHCi 7.6.3.  Say I type the following (please read a newline where I type a semicolon): import Data.Array.IArray; let a = array (0,0) [(0,undefined)] :: Array Int Int; a; let a = a // [(0,undefined)] :: Array Int Int; a
12:40:45 <skypers> ahah :)
12:42:02 <c_wraith> DaveH_prime: didn't fit on one line of IRC.  could you put the code in a paste on lpaste.org and link it for us?
12:42:06 <skypers> also, I’m looking for contributors for my FModExRaw binding ;)
12:42:16 <dmwit> DaveH_prime: Whoa, that's a funny one!
12:42:21 <DaveH_prime> c_wraith: gladly (sorry :).
12:42:32 <skypers> edwardk: the contributor is SvenPanne (OpenGLRaw)
12:42:38 <geekosaur> are you confused by undefined, or by the fact that let is recursive and you are not reassigning to the original a?
12:42:39 <skypers> is him lispy?
12:42:44 <dmwit> DaveH_prime: Oh, I get it. =)
12:42:47 <skypers> is he*
12:42:51 <dmwit> DaveH_prime: In the last "let", both a's are the same.
12:42:54 <edwardk> i don't know sven, but i do know lispy does a lot of work on it or used to.
12:42:57 <dmwit> DaveH_prime: Neither a is the old one.
12:43:09 <dmwit> DaveH_prime: So you're writing "let foo = foo // {- whatever -}", an infinite loop.
12:43:12 <edwardk> lispy = jason dagit, the other guy in the copyright for opengl.raw
12:43:27 <skypers> ok, I’ll try to talk to them then
12:43:31 <dmwit> DaveH_prime: BUT the Show instance for arrays knows it starts out "array ", so it prints that before it even bothers looking inside the loop.
12:43:32 <edwardk> i wonder how many times i can say lispy and make his client beep before he notices
12:43:39 <dmwit> DaveH_prime: Does this explain the behavior you see?
12:43:58 <skypers> cooking time, talk to you later!
12:44:52 <DaveH_prime> dmwit: I get it.  I was thinking of 'let' as an imperative assignment. :)
12:45:00 <c_wraith> Hmm.  Is there any research into free applicatives?
12:46:50 <c_wraith> I really want the ability to put together actions that I can statically analyze, from a number of primitives.  Static analysis suggests I want Applicatives. Building from composing a number of primitives suggests I want a free structure.
12:48:11 <lpaste> Daneo pasted “Overriding the equals method” at http://lpaste.net/95948
12:49:02 <lpaste> Daneo revised “Overriding the equals method”: “No title” at http://lpaste.net/95948
12:49:29 <FreeFull> c_wraith: Free Applicatives then?
12:49:33 <lpaste> DaveH_prime pasted “Newbie confusion over recursive 'let' :)” at http://lpaste.net/95950
12:49:49 <DaveH_prime> (in case anyone is interested in the full text of the confusion which dmwit has since resolved for me!)
12:50:04 <daneo> Would anyone care taking a look ? I added the error message, but where-ever I try to add Eq, I keep getting errors about a not implementing Eq
12:50:05 <bennofs> wasn't there some sort of Free AnyConstraintHere construction?
12:51:04 <c_wraith> FreeFull: Do they exist?  Have they been studied?  Is there a library?
12:51:12 <c_wraith> ok, yes, I'm sure they exist.
12:51:50 <dmwit> daneo: WFM when I add the context exactly the way the error says.
12:52:04 <dmwit> same_elements :: Eq a => Tree a -> Tree a -> Bool
12:52:19 <c_wraith> DaveH_prime: ah, yep.  just as dmwit was saying - you end up in a recursive loop, as the a in the second let is defined in terms of itself
12:52:29 <bennofs> c_wraith: I found http://hackage.haskell.org/package/free-4.2/docs/Control-Applicative-Free.html#Free
12:53:41 <daneo> dmwit: I tried putting the Eq in the a in the current expression Tree (Eq a), sorry .
12:54:06 <c_wraith> bennofs: Huh.  I guess that looks exactly how I'd expect..  But I'm not quite sure how I'd do static analysis on it.  Hmm.
12:54:18 <daneo> dmwit: And I tried it with -> , not =>
12:54:50 <c_wraith> I bet I could figure it out with sufficient poking.
12:57:13 <merijn> daneo: The way typeclasses work you can read them a bit as a predicate "same_elements :: Eq a => Tree a -> Tree a -> Bool" can be read as "IF a is an instance of Eq, THEN same_elements has type "Tree a -> Tree a -> Bool"
12:58:42 <DaveH_prime> Thanks dmwit and c_wraith.  Out of pure curiosity: is there a simple explanation why ghci simply stops when I try to evaluate a recursively-defined object like that?  I'd have expected it to do what imperative languages do, and overflow its stack.
12:58:44 <daneo> merijn: Ok, so it's a prerequisite then when '=>' is used ?
12:58:59 <dmwit> DaveH_prime: Stack is very different in Haskell.
12:59:08 <DaveH_prime> What isn't? :-)
12:59:09 <merijn> daneo: Yes, you can read the => as a predicate/prerequisite for the rest of the type
12:59:14 <dmwit> DaveH_prime: Also, I suspect if you wait long enough, it actually will terminate. =)
13:00:02 <dmwit> DaveH_prime: If this surprises you, get ready for another surprise.
13:00:10 <dmwit> DaveH_prime: Kick off the computation, then check "top" or similar.
13:00:21 <dmwit> See if you can spot the ghci process spinning up at 100% CPU.
13:00:31 <DaveH_prime> That's exactly what I did, and that's when I got really puzzled. :)
13:00:36 <dmwit> hehehe
13:01:07 <dmwit> DaveH_prime: Okay, enough mystery. Let's talk stack and black holes.
13:01:18 <dmwit> DaveH_prime: In GHC, the stack is used when you have a deeply-nested thunk.
13:01:22 <DaveH_prime> Thunk?
13:01:32 <dmwit> A thunk is a lazy computation that you haven't done yet.
13:01:54 <dmwit> So, stack frames don't get pushed on function calls; they get pushed when you demand some lazy value.
13:01:59 <daneo> merijn: Alright, thank you for the additional info :-)
13:02:38 <Jeanne-Kamikaze> you can inspect thunks in ghci with :sprint
13:02:52 <dmwit> For example, consider foldl (+) 0 (replicate 1000 1).
13:03:01 <dmwit> > foldl (+) 0 (replicate 1000 1) :: Expr
13:03:02 <lambdabot>   0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +...
13:03:08 <dmwit> oh, no parens, bummer
13:03:29 <dmwit> Anyway, that looks like ((((...(0+1)+1)+1)...)
13:03:30 <DaveH_prime> So... uh, if I do something like    putStrLn (last $ words collected_works_of_shakespeare) ... okay, I like your example better.
13:03:41 <bennofs> > foldl f 0 (replicate 1000 1) :: Expr
13:03:42 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
13:03:58 <dmwit> Now, it comes time to evaluate that monstrosity.
13:04:19 <dmwit> We've got <thunk-1000>+1, so we push a stack frame and enter that thunk.
13:04:26 <tac> > foldl f 0 (replicate 3 1) :: Expr
13:04:28 <lambdabot>   f (f (f 0 1) 1) 1
13:04:28 <tac> > foldr f 0 (replicate 3 1) :: Expr
13:04:30 <lambdabot>   f 1 (f 1 (f 1 0))
13:04:35 <dmwit> Then we notice that <thunk-1000> = <thunk-999>+1.
13:04:38 <bennofs> c_wraith: Maybe http://hackage.haskell.org/package/free-operational-0.5.0.0/docs/Control-Applicative-Operational.html?
13:04:42 <dmwit> So we push a stack frame and enter <thunk-999>.
13:04:49 <dmwit> ...and so on, until we've pushed 1000 stack frames.
13:05:09 <dmwit> We finally get to 0+1, evaluate that to 1; pop a stack frame, evaluate to 2; pop a frame, evaluate to 3; ...
13:05:22 <dmwit> Good so far?
13:05:25 <c_wraith> bennofs: that actually looks like exactly what I was thinking of.  Thanks
13:07:31 <DaveH_prime> Huh.  And sure enough, if I    foldl (+) 0 (replicate 1000000000 1)     then it runs out of memory.
13:07:54 <c_wraith> that's due to insufficient strictness, though.  It's an entirely different bag of worms. :)
13:08:07 <c_wraith> bag?  since when do people put worms in bags?  *can* of worms.
13:08:48 <c_wraith> DaveH_prime: in particular, that calculation doesn't run out of stack space during the fold.  It runs out when it tries to print the result.
13:08:49 <identity> > foldl' f 0 (replicate 1000 1) :: Expr
13:08:50 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
13:09:00 <identity> okay, I guess
13:09:20 <Cale> foldl (+) 0 [1,1,1,1,...] -> foldl (+) (0 + 1) [1,1,1,...] -> foldl (+) ((0 + 1) + 1) [1,1,...] -> ...
13:09:21 <identity> > foldl' (+) o (replicate 10000000 1)
13:09:26 <lambdabot>   mueval: ExitFailure 1
13:09:27 <lambdabot>  mueval: Prelude.undefined
13:09:30 <identity> eh
13:09:31 <identity> oops.
13:09:38 <identity> > foldl' (+) 0 (replicate 10000000 1)
13:09:39 <lambdabot>   10000000
13:09:58 <radicality> Hi. I have a question regarding Maybe with the State monad, but I don't really like the one response that I got on SO: http://stackoverflow.com/questions/20086030/using-maybe-with-state-monad?noredirect=1#comment29926078_20086030 maybe someone here could help me?
13:10:08 <Cale> DaveH_prime: the expression which is building up in the accumulating parameter takes space
13:10:35 <Cale> (more space than the Integer value it'd evaluate to if it had a chance to be evaluated)
13:11:31 <c_wraith> radicality: you might want the MaybeT transformer..  I hesitated to throw that in on that question on SO because I wasn't sure you're ready for that complexity.
13:11:50 <merijn> radicality: popQueue returns a Maybe, but pushQueue doesn't accept a Maybe
13:11:57 <simpson> radicality: Is it essential that `popQueue >>= pushQueue` works?
13:12:01 <merijn> :t (>>=)
13:12:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:12:04 <DaveH_prime> This is too much for my small brain.  I'm going to go and figure it out in very small steps with a pencil and paper.
13:12:10 <mm_freak_> radicality: the reason you don't like the answer is because your code is ill-typed =)
13:12:15 <c_wraith> DaveH_prime: that's a very good idea. :)
13:12:16 <DaveH_prime> Thank you!
13:12:18 <dmwit> DaveH_prime: That's a great plan.
13:12:24 <radicality> simpson: Well, not neceserially, I just thought the whole point of >>= is to make it easier to have operations like that chainable
13:12:30 <dmwit> DaveH_prime: Let us know if some part of the paper confuses you.
13:12:45 <mm_freak_> radicality: you have two different monads there…  the (>>=) is for the state monad
13:12:50 <simpson> radicality: Well, the whole point of (>>=) is to be a part of the Monad primitives.
13:12:56 <radicality> mm_freak_: yeah, i'm looking for suggestions on how to achieve what I want and still use >>= to compose
13:13:01 <simpson> radicality: Do you know about do-syntax?
13:13:05 <tomejaguar> radicality: What do you want your program to do if the queue is popped when it is empty?
13:13:11 <mm_freak_> radicality: well, get rid of the partiality
13:13:19 <DaveH_prime> dmwit: thank you.  I'll try not to let that be the empty page. :)
13:13:32 <mm_freak_> radicality: i.e. first /think/:  what does it mean to pop-then-push from an empty stack?
13:13:41 <dmwit> ?unmtl StateT s Maybe a
13:13:41 <lambdabot> s -> Maybe (a, s)
13:13:44 <identity> radicality: In real simple terms, your popQueue returns a (Maybe a) and your pushQueue takes an 'a'
13:13:45 <simpson> do { pushQueue 2; mi <- popQueue; maybe (return ()) pushQueue mi }
13:14:14 <mm_freak_> i think radicality understands the technical problem, but not the philosophical problem =)
13:14:15 <dmwit> radicality: My personal opinion is that StateT s Maybe can be a fine monad for you if it's what you want.
13:14:22 <radicality> mm_freak_: are you suggesting i get rid of the Maybe altogether? Well, popping and then pushing the result should leave the queue unchanged.
13:14:30 <mm_freak_> also i don't recommend StateT over Maybe here!
13:14:31 <identity> so you cannot chain popQueue into a pushQueue unless you make your pushQueue take a Maybe
13:14:38 <simpson> radicality: Even if the queue was empty to begin with?
13:14:39 <dmwit> mm_freak_: Why not?
13:14:58 <mm_freak_> because the problem is: "this case doesn't work, because its partial"
13:15:01 * monochrom suggests a combination of state and exception for this
13:15:06 <mm_freak_> the solution shouldn't be:  "well, make everything partial then"
13:15:13 <dmwit> mm_freak_: Why not?
13:15:16 <mm_freak_> radicality: not at all
13:15:27 <tomejaguar> dmwit: Wouldn't MaybeT over State be the better option?
13:15:31 <mm_freak_> radicality: make a well-defined operation
13:15:36 <tomejaguar> dmwit: Otherwise a Nothing brings down the whole computation
13:15:38 <dmwit> ?unmtl MaybeT (State s) a
13:15:38 <lambdabot> (State s) (Maybe a)
13:15:50 <dmwit> tomejaguar: Depends on what radicality wants, to be sure.
13:15:51 <Taneb> unmtl is broken
13:15:59 <dmwit> unmtl is very broken
13:16:03 <mm_freak_> pop :: State (Queue a) (Maybe a)
13:16:09 <mm_freak_> that's a totally sensible type!
13:16:38 <mm_freak_> why complicate everything?  by turning this into StateT over Maybe, you make everything potentially partial, including push
13:16:40 <dmwit> mm_freak_: It really depends.
13:16:40 <radicality> dmwit: well, I want to learn the best possible way to do this, meaning chain operations like push and pop using the standard monad syntax.
13:16:46 <mm_freak_> no, it does not depend
13:16:49 <dmwit> mm_freak_: Maybe it doesn't make sense to keep the queue after an error occurs.
13:16:53 <mm_freak_> pushing is a well-defined total operation
13:16:58 <mm_freak_> why should it have a Maybe below it?!
13:17:16 <dmwit> Because if you already got into an error state, pushing and pretending nothing happened is broken. =)
13:17:24 <radicality> mm_freak_: pushing doens't have a Maybe, no ?
13:17:33 <mm_freak_> radicality: your solution is fine
13:17:41 <mm_freak_> some people are suggesting a non-fine solution =)
13:17:57 <dmwit> Some people are suggesting that there is a choice that should be made consciously.
13:18:01 <radicality> ah i see
13:18:23 <mm_freak_> dmwit: insert :: k -> a -> Map k a -> Maybe (Map k a)
13:18:24 <simpson> radicality: Consider: You say that pop and push should complement each other. Should pop-then-push be a no-op *even if the queue was already empty*?
13:18:29 <mm_freak_> dmwit: does that make sense to you?
13:18:40 <identity> mm_freak_: i don't think that's quite what he's suggesting.
13:18:47 <dmwit> Nope. What's your point?
13:18:57 <mm_freak_> identity: it's exactly what he's suggesting
13:19:04 <k0001> I feel dirty if I import Control.Lens unqualified. Is that an expected behaviour?
13:19:15 <identity> k0001: file a bug
13:19:18 <edwardk> hah
13:19:23 <mm_freak_> push :: a -> StateT (Queue a) Maybe ()
13:19:27 <mm_freak_> bad for the same reason!
13:19:48 <dmwit> So make it push :: MonadState s m => a -> m ()
13:19:50 <edwardk> Control.Lens is designed to be imported unqualified. if it conflicts with common things then i'm a bad person and should feel bad.
13:19:52 <mm_freak_> pushing is well-defined and total…  the Maybe forces you to deal with the Nothing even if it's impossible for it to occur
13:19:53 <identity> radicality: In reality, the semantics of your implementation are fine.
13:19:56 <dmwit> So make it push :: MonadState (Queue a) m => a -> m () -- I mean
13:20:24 <mm_freak_> dmwit: you'll want to use 'pop' from time to time in the same computation, which brings it back to StateT over Maybe
13:20:30 <dmwit> correct
13:20:33 <dmwit> So?
13:20:48 <k0001> edwardk: phew! What a relief! I feel better now, thanks.
13:20:48 <mm_freak_> i give up
13:20:53 <radicality> Oh yeah, that's another part I'm kind of confused about - MonadState. So (State a) is part of MonadState? Can I just make my queue be part of MonadState and "bypass" State? Or am I talking nonsense?
13:21:18 <mm_freak_> radicality: no, that's sensible
13:21:30 <bennofs> mm_freak_: what's bad about push :: MonadState (Queue a) m => ... ?
13:21:39 <mm_freak_> bennofs: that's fine
13:22:00 <bennofs> Or you could use mmorph :)
13:22:21 <mm_freak_> there is no monad morphism from StateT s Maybe to State s
13:22:52 <mm_freak_> what's not fine is this:  pop :: StateT (Queue a) Maybe a
13:23:09 <mm_freak_> because as soon as you use this 'pop', your whole monad gets Maybe-partiality
13:23:22 <dmwit> yes please
13:23:30 <dmwit> don't report a wrong stack to me if something goes wrong
13:23:31 <dmwit> just give up
13:23:33 <mm_freak_> so at the run* site you will have to deal with the potential Nothing, even if the computation is actually completely well-defined
13:23:38 <dmwit> or queue or whatever
13:23:50 <mm_freak_> because the type does not express the totality
13:24:37 <bennofs> mm_freak_: hoist (return . runIdentity) should be able to lift State s a to Monad m => StateT s m a, no?
13:24:52 <mm_freak_> bennofs: now reverse the direction =)
13:25:13 <dmwit> mm_freak_: My queue is big and I want it garbage-collected as soon as an error occurs, and not after pushing a million more parsed elements onto it. What now?
13:25:18 <dmwit> This is a choice that one must make.
13:25:33 <dmwit> I don't believe you that it is 100% cut-and-dried what the right choice is.
13:25:40 <mm_freak_> dmwit: that's not going to happen, because the Maybe will force you to deal with failure anyway
13:25:45 <tomejaguar> mm_freak_: I think dmwit is saying that you may want popping an empty stack to be an programming error which brings down the whole monad.  MaybeT over State give you more fine grained control.
13:25:50 <mm_freak_> be it as the base monad or simply as the result type
13:26:34 <mm_freak_> tomejaguar: and my point is that pushing, then popping is a well-defined operation…  and if that's all you do, then there should be no partiality left at the end
13:26:59 <mm_freak_> tomejaguar: both the MaybeT and the StateT over Maybe version require you to deal with partiality even if it's not there
13:27:01 <dmwit> Oh, so you want to not use transformers at all?
13:27:04 <mm_freak_> is this really so difficult to understand?!
13:27:20 <dmwit> Then there is a different tradeoff to make.
13:27:23 <bennofs> do you want to track if the queue is empty in the types? :O
13:27:27 <dmwit> No wonder you found my arguments unconvincing.
13:27:52 <dmwit> If the option is transformers vs. no, then the tradeoff to make is programmer convenience at the call site vs. type specificity at the run site.
13:27:54 <mm_freak_> bennofs: no, why?
13:28:10 <mm_freak_> if all your operations are well-defined, there is no reason for Maybe
13:28:11 <edwardk> k0001: in all seriousness though, if you're getting lots of conflicts, let us know.
13:28:14 <bennofs> if you use maybe as a return type, then you still get a Maybe Queue in the end if you push then pop
13:28:48 <mm_freak_> popping a stack is a well-defined operation with a Maybe result, and it can be combined with other operations to something that makes the Maybe disappear
13:28:59 <mm_freak_> with the StateT+Maybe variant this becomes impossible
13:29:04 <mm_freak_> so all programs are partial
13:29:07 <mm_freak_> even well-defined ones
13:29:08 <edwardk> k0001: when we picked the names for lens we designed the vast majority of them to 'fit in the cracks' of the naming conventions of other libraries. i even calculated a bunch of statistics over hackage to find out how many conflicts we were getting and where at first.
13:29:09 <bennofs> hmm, right
13:29:17 <dmwit> Yes, I agree.
13:29:28 <identity> edwardk: haha, holy shit. That's dedication
13:29:30 <dmwit> Nevertheless, I do not conclude from that that StateT is inherently a wrong choice.
13:29:39 <identity> dedication to non-conflicting notation
13:29:46 <dmwit> Once again there is a tradeoff to make.
13:29:47 <bennofs> mm_freak_: But MaybeT (State (Queue a)) a should work, no? After all, I can run the MaybeT whenever I want
13:30:05 <edwardk> identity: mind you it didn't stop people from complaining about names like _1 and _Left ;)
13:30:06 <dmwit> That tradeoff being: do I want to reimplement MaybeT's (>>=) every time I pop?
13:30:14 <mm_freak_> dmwit: don't enforce your tradeoff…  it's easy enough to lift a non-StateT pop
13:30:25 <edwardk> identity: but it worked out pretty well i think
13:30:25 <dmwit> yes
13:30:45 <dmwit> OR you can skip the lift every time =)
13:30:49 <mm_freak_> bennofs: that doesn't solve the problem
13:30:51 <dmwit> It's a choice, and it should be made consciously.
13:31:06 <mm_freak_> bennofs: it's just a different encoding for the same thing =)
13:31:15 <radicality> thanks for the responses btw, reading through them slowly since this is dense material still for me.
13:31:29 <bennofs> mm_freak_: ? MaybeT (State (Queue a)) a should be the same as State (Queue a) (Maybe a), shouldn't it?
13:31:39 <mm_freak_> dmwit: you can also define a lifted pop
13:31:53 <dmwit> for example, yes
13:31:54 <bennofs> mm_freak_: http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-Maybe.html#v:MaybeT
13:32:20 <mm_freak_> bennofs: it is, but it has no real advantage
13:32:34 <bennofs> mm_freak_: it has, you can use (>>=)
13:33:06 <mm_freak_> you can use (>>=) with a lifted pop, without requiring an additional non-Prelude monad =)
13:33:08 <bennofs> but you still get control if you want to do something different in the Nothing case
13:34:14 <bennofs> But wait, why is this thing in a State? Shouldn't it be a reader?
13:34:29 <mm_freak_> bennofs: how would 'push' work?
13:34:33 <bennofs> hmm, right
13:34:42 <dmwit> or pop =)
13:34:49 <mm_freak_> not a big fan of State myself =)
13:34:50 <bennofs> but pop not changing the state doesn't really match my intuition
13:35:04 <bennofs> I'd rather have pop return Bool for Success/Failure then :|
13:35:10 <mm_freak_> most stateful computations can be expressed as a combination of a reader and a writer
13:35:16 <mm_freak_> but not this one =)
13:35:38 <dmwit> [citation needed]
13:35:40 <mm_freak_> bennofs: what would its type look like then?
13:35:42 <bennofs> Hmm, right, pop changes the state. (facepalm)
13:36:09 * hackagebot blaze-builder 0.3.3.0 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.3.0 (SimonMeier)
13:36:11 * hackagebot laborantin-hs 0.1.1.3 - an experiment management framework  http://hackage.haskell.org/package/laborantin-hs-0.1.1.3 (LucasDiCioccio)
13:36:14 <mm_freak_> pop :: (MonadState (Queue a) m) => m (BoolWithValue a)
13:36:15 <mm_freak_> =)
13:36:20 <mm_freak_> aka Maybe =)
13:36:34 <bennofs> So popping and empty queue does leave the queue empty?
13:36:37 <bennofs> an*
13:37:26 <bennofs> mm_freak_: How do I lift State s (Maybe a) to StateT s Maybe a?
13:37:41 <mm_freak_> bennofs: 'pop' doesn't just delete the value, it also retrieves it
13:38:01 <tomejaguar> Anyway, FWIW I think the Maybe monad is massively over-engineered for this example.  State on the other hand seems somewhat useful.
13:38:20 <mm_freak_> bennofs: pop >>= lift
13:38:37 <mm_freak_> where pop :: (MonadState (Queue a) m) => m (Maybe a)
13:38:39 <bennofs> right. Now I agree that this is probably the best solution :P
13:38:47 <mm_freak_> thank you =)
13:39:08 <dmwit> I agree: MaybeT State/StateT Maybe would not be the first thing I reach for here.
13:39:17 <dmwit> But I don't agree that they are categorically out of the question. =)
13:39:35 <dmwit> "The answer depends on the question" and all that.
13:40:24 <bennofs> But mm_freak_'s type can easily be lifted into those two types :)
13:41:51 <Dasuraga> I'm looking at Purely Functional Data Structures... all the lazy evaluation stuff in the paper is automatically done with haskell's lazy evaluation right?
13:41:54 <tomejaguar> I think they are violently agreeing actually :)
13:42:25 <dmwit> Dasuraga: "all" is a dangerous word
13:42:50 <dmwit> Dasuraga: Unless somebody here has read the entire thing in the last month or so, I doubt you'll get somebody willing to claim that.
13:42:53 <dmwit> =)
13:43:27 <tomejaguar> Dasuraga: Haskell doesn't need the laziness additions that Okasaki uses, though it's possible that some things need to be forced strict.
13:44:00 <Dasuraga> ok , I'll try to look out for that then
13:44:44 <simpson> edwardk: You're around! I have a question.
13:44:46 <radicality> mm_freak_: could you maybe spell out in more detail how I can implement pop :: (MonadState (Queue a) m) => m (Maybe a) . I can't find good examples online with MonadState
13:45:27 <simpson> edwardk: I have a Map of Arrays and I want to remove an Array if an operation makes it all-zeroed. At the same time, I want to add an Array not in the Map to the Map, if an operation would make it non-zero.
13:45:32 <mm_freak_> radicality: just like you did =)
13:45:44 <mm_freak_> :t state
13:45:45 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
13:45:56 <mm_freak_> radicality: just change the type signature and you're done =)
13:46:03 <simpson> edwardk: I wish, for reasons of laziness, to do this with a lens. Is it possible to build a lens into the Array that will return Nothing or (Just myArray) as appropriate?
13:46:26 <edwardk> simpson: 'non'
13:46:30 <simpson> (And by "laziness" I mean that Maps already have `at` lenses and they would work really well with Maybe-wrapped values.)
13:47:31 <edwardk> at foo . non (somekindofemptyarray)
13:47:42 <edwardk> there is also anon
13:48:01 <edwardk> > M.fromList [(1,2)] & at 2.non 0 +~ 1
13:48:03 <lambdabot>   fromList [(1,2),(2,1)]
13:48:09 <edwardk> > M.fromList [(1,2)] & at 1.non 0 -~ 2
13:48:11 <lambdabot>   fromList []
13:48:48 <edwardk> > M.fromList [(1,M.fromList [(2,3))] & at 1.non M.empty.at 2.non 0 +~ 1
13:48:49 <lambdabot>   <hint>:1:33: parse error on input `)'
13:48:55 <edwardk> > M.fromList [(1,M.fromList [(2,3))] & at 1.non M.empty . at 2.non 0 +~ 1
13:48:56 <lambdabot>   <hint>:1:33: parse error on input `)'
13:49:04 <edwardk> > M.fromList [(1,M.fromList [(2,3)])] & at 1.non M.empty . at 2.non 0 +~ 1
13:49:05 <lambdabot>   fromList [(1,fromList [(2,4)])]
13:49:11 <edwardk> > M.fromList [(1,M.fromList [(2,3)])] & at 1.non M.empty . at 2.non 0 -~ 3
13:49:13 <lambdabot>   fromList []
13:49:33 <simpson> edwardk: !! Wow. This is awesome.
13:49:34 <edwardk> anon can be used to change out the notion of equality you're using to get what you want
13:49:39 <edwardk> :t (anon)
13:49:41 <lambdabot> (Functor f, Profunctor p) => a -> (a -> Bool) -> p a (f a) -> p (Maybe a) (f (Maybe a))
13:49:51 <edwardk> > M.fromList [(1,M.fromList [(2,3)])] & at 1.anon M.empty M.null . at 2.non 0 -~ 3
13:49:53 <lambdabot>   fromList []
13:50:06 <edwardk> that's cheaper because its using null not (==) on maps to check
13:50:19 <simpson> edwardk: Thanks! I had thought that `non` was just a pun on `anon` and not the other way around.
13:50:29 <edwardk> in your case you'd use anon (the empty array) (the check to see if the array is empty)
13:51:06 <edwardk> it was named so i could say 'non 0' or 'non empty'
13:51:11 <simpson> edwardk: BTW, what I am doing now: https://github.com/bravoserver/baskerville/blob/master/Baskerville/Beta/Session.hs#L163
13:51:18 <simpson> It's, uh, messy. Pardon my dust.
13:51:38 <supki> note that anon changed type in HEAD, it takes a Prism there
13:52:01 <simpson> But yeah, I wanted to do one single (.=) operation which would automatically prune or augment the inner Map.
13:52:11 <edwardk> supki: yeah though we're changing it back and renaming the new anon something else
13:52:18 <supki> oh
13:52:20 <edwardk> supki: that way we don't break everyone
13:52:52 <edwardk> simpson: what i just showed does that as you update each time
13:52:58 <simpson> edwardk: Yep, and I like it.
13:53:04 <bennofs> I thought HEAD may break everyone? (And does already)
13:53:16 <simpson> ...Clearly I need more combinators in my code; it's so messy and ad-hoc.
13:53:18 <edwardk> bennofs: depends on what subsets of it you use
13:53:28 <skypers> hi back
13:53:36 <edwardk> the core of lens is pretty stable
13:53:54 <edwardk> its mostly generalizations and revisiting various decisions around the fringe
13:54:02 <skypers> 22:35 < lambdabot> (Functor f, Profunctor p) => a -> (a -> Bool) -> p a (f a) -> p (Maybe a) (f (Maybe a))
13:54:05 <skypers> :   D
13:54:23 <simpson> And using _Just is still the right way to dig down in cases where I want to reach through a Maybe, right?
13:54:47 <skypers> @index anon
13:54:47 <lambdabot> bzzt
13:55:05 <skypers> huh, seriously lambdabot ?
13:55:18 <skypers> @hoogle anon
13:55:18 <lambdabot> Network.Socket addrCanonName :: AddrInfo -> Maybe String
13:55:19 <lambdabot> Network.Socket AI_CANONNAME :: AddrInfoFlag
13:55:19 <lambdabot> package canonical-filepath
13:55:24 <supki> :t _Just `asTypeOf` traverse
13:55:25 <lambdabot> Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
13:55:31 <edwardk> simpson: yeah. or 'traverse' if you don't need the full prism
13:55:54 <skypers> prism… I saw that before
13:55:56 <skypers> in hm
13:55:59 <skypers> Control.Lens.Prism
13:56:17 <simpson> edwardk: At some later point, I'll have to introduce combinators to actually prune the big Map of Chunks. I just figured that the rule for the Map of MicroChunks (all zeros? drop it!) would be easy to wrap up separately.
13:56:48 <edwardk> well, you can prune the outer map using anon M.empty null  no?
13:57:19 <edwardk> skypers: a prism is just a traversal you can use for construction as well.
13:57:22 <schell> is using takeMVar, putMVar etc. expensive?
13:57:26 <edwardk> > Left 4 ^? _Left
13:57:27 <lambdabot>   Just 4
13:57:29 <edwardk> > Right 4 ^? _Left
13:57:31 <lambdabot>   Nothing
13:57:35 <edwardk> > _Left # 4
13:57:37 <lambdabot>   Left 4
13:57:39 <simpson> Except that every time I modify the outer map, I need to double-check that I might have to evict the contents to disk, or load from disk, or write to networking clients.
13:57:52 <edwardk> oh then there you're out of scope =)
13:57:57 <simpson> Which could be a little tricky to wrap up in an otherwise-pure lens. :3
13:58:00 <edwardk> yeah
13:58:19 <skypers> :t (#)
13:58:20 <lambdabot> parse error on input `)'
13:59:27 <simpson> I'm so damn tempted to write this with one big single Server value, and just pass it in a TMVar to all interested threads, using lenses to dig whatever I need out of it.
13:59:37 <simpson> But I know that that's not going to be conducive to parallelism later on.
13:59:41 <edwardk> :t ( # )
13:59:43 <lambdabot> AReview s t a b -> b -> t
14:00:04 <schell> when do you know when to use TMVar vs MVar?
14:00:15 <simpson> schell: Are you working in STM?
14:00:21 <hpc> simpson: it could be if you manage your write right
14:00:27 <edwardk> # takes something like a prism and uses it to construct a whole sum type out of the descripton of one of the summands
14:00:44 <schell> simpson: no, i'm more debating whether to use MVar or IORef
14:00:58 <schell> MVar sounds better but I'm thinking it's more expensive
14:01:17 <simpson> It shouldn't be more expensive, but it does come with an effective lock.
14:01:18 <schell> but I just like knowing these things :)
14:01:30 <hpc> schell: MVar's performance dip is less than the dip from leaving in i7 in the sun vs the shade
14:01:47 <mm_freak_> simpson: could you summarize the application?
14:01:55 <schell> hpc: interesting
14:02:14 <simpson> hpc: Yeah, I guess that any one single acting thread could be massively parallel in its actions. I also guess that I could use Async to have a pattern of acquire-read-release-work-acquire-write-release.
14:02:28 <simpson> mm_freak_: Mine? Summary: Minecraft server.
14:02:51 <mm_freak_> simpson: sounds like a reactive application
14:03:00 <schell> simpson: sweet - you should join #haskell-game if you haven't already
14:03:02 <Munksgaard> I'm looking at the "perfect shuffle" code. What does the {} in the line "extract_tree 1 (Node 2 l@Leaf{} (Leaf r)) k = r:k l" do?
14:03:08 <Munksgaard> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
14:03:39 <dmwit> Munksgaard: It's record syntax.
14:03:40 <simpson> mm_freak_: It has a lot of async stuff that happens without any player interaction.
14:04:01 <dmwit> Munksgaard: So it matches a value whose constructor is Leaf, and doesn't bind any names to the fields of that value.
14:04:04 <mm_freak_> simpson: that's fine
14:04:22 <dmwit> Munksgaard: It's a fairly common trick for when you don't feel like writing the right number of _'s.
14:04:32 <mm_freak_> simpson: FRP consists of events and behaviors…  it doesn't break down when no events occur =)
14:04:55 <Munksgaard> dmwit: Ah, I see. Thanks :)
14:04:56 <simpson> mm_freak_: I think that we chatted about using things like netwire for this, right? My analysis was that there was still a lot of stuff that would have to happen outside of netwire.
14:05:50 <mm_freak_> simpson: i think you should just experiment with an actual FRP application =)
14:06:34 <simpson> mm_freak_: Yeah. I mean, this *is* an experiment, after all.
14:06:38 <jrmithdobbs> so, I think I'm starting to "actually" "get" monads, but i'm having issues tieing it all together so to speak ... right now i'm playing with yesod's Handler/HandlerT and on a route have a :: Handler TypedContent (no arguments), and I'm just confused on how to work with multilple levels of nesting i think
14:06:59 <mm_freak_> simpson: i mean something simpler
14:07:26 <mm_freak_> jrmithdobbs: yesod is known to have scary monads =)
14:07:52 <jrmithdobbs> eg, I have TypeCon { valCon = xs' } <- runInputGet $ <snip> ... ; let xs = something xs' ; something xs; ... I know there's an easy way to lift my valCon getter into the HandlerT but my brain is swirling a little
14:08:08 <jrmithdobbs> where that last something is really somethingelse
14:08:10 <jrmithdobbs> but ya
14:08:44 <jrmithdobbs> I know this should somehow be xs <- lift valCon <$> runInputGet $ .... but i'm missing something
14:09:12 <Cale> get rid of that 'lift'?
14:09:14 <jrmithdobbs> at least, it should be something *very close* to that
14:09:40 <lpaste> malorie pasted “rearranging tree-labels, such that the tree becomes in-order” at http://lpaste.net/3575535637987590144
14:10:27 <Cale> jrmithdobbs: Does  xs' <- fmap valCon . runInputGet $ ...   work?
14:11:02 <malorie> so I wrote this piece of code, but I'm not quite satisfied with its readability, which is mostly due to the somewhat tricky recursion. how could I make this better?
14:11:48 <jrmithdobbs> Cale: no because <$> is fmap, i know that much ;p
14:12:16 <Cale> jrmithdobbs: (I'm aware)
14:12:33 <jrmithdobbs> Cale: i know you are
14:12:39 <chrisdone> ahoy
14:12:41 <Cale> jrmithdobbs: i.e. I'm suggesting you just not use lift
14:12:59 <Cale> If the code that you wrote works, then fmap valCon should work
14:13:34 <jrmithdobbs> oh jesus
14:13:39 <jrmithdobbs> missing space next to a .
14:13:42 <jrmithdobbs> shoot me
14:14:08 <chrisdone> @choose cake death
14:14:08 <lambdabot> cake
14:14:16 <chrisdone> jrmithdobbs: today, you live
14:14:20 <chrisdone> enjoy the cake
14:14:29 <Iceland_jack> @choose cake death
14:14:29 <lambdabot> cake
14:14:32 <Iceland_jack> well that's nice
14:14:36 <chrisdone> hurrah!
14:14:55 <Iceland_jack> If I get a second cake this will be the best day
14:14:56 <Iceland_jack> @choose cake death
14:14:56 <lambdabot> cake
14:14:57 <jrmithdobbs> Cale: ya that was my whole problem, i did understand it and then started questioning my understanding because i didn't read a compiler error correctly, lol
14:14:59 <Iceland_jack> ‼
14:15:03 <chrisdone> cake for all!
14:15:04 <Cale> malorie: Looks like a job for the State monad
14:15:10 <jrmithdobbs> Cale: good times
14:15:26 <Cale> jrmithdobbs: cool
14:15:59 <malorie> Cale: hm. I've never used the state monad. what would be the overall approach there?
14:16:26 <Cale> I'll write it if you like. The idea is to have the state be the list of labels
14:16:43 <Cale> If you look at the type of your go inside normalform
14:16:56 <Cale> It's Tree b -> [b] -> (Tree b, [b])
14:17:04 <malorie> yes
14:17:05 <Cale> which is the same thing as  Tree b -> State [b] (Tree b)
14:17:24 <jrmithdobbs> Cale: so should fmap symbolOne (M a) === symbolOne <$> (M a)
14:17:24 <malorie> I see
14:17:31 <Cale> You can write:  label :: State [b] b
14:17:47 <Cale> label = do (m:ms) <- get; put ms; return m
14:17:53 <jrmithdobbs> Cale: i'm trying to figure out how fmap composes to <$> exactly
14:18:02 <jrmithdobbs> like, I get:
14:18:04 <jrmithdobbs> :t fmap
14:18:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:18:37 <Cale> jrmithdobbs: Well, there's literally a definition (<$>) = fmap
14:18:40 <piezoid> malorie: there is an example about tree labelling : http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-State-Lazy.html#g:8
14:19:15 <jrmithdobbs> Cale: but if i take that line I got working with val <- fmap (valCon) . runInputGet $ ... ; and change it to (valCon) <$> runInputGet $ ... ;; I'm missing something very obvious here i think
14:19:34 <joelteon> yeah
14:19:41 <joelteon> you'd need to do (<$> valCon) . runInputGet $ ...
14:19:49 <joelteon> (fmap valCon) and (<$> valCon) are the same thing
14:19:57 <joelteon> fmap f . g is not the same thing as f <$> g
14:20:12 <jrmithdobbs> oh, facepalm, i see what you're saying
14:20:13 <tomejaguar> joelteon: flip fmap valCon?
14:20:41 <joelteon> jrmithdobbs: my misatke, it would be (valCon <$>) . runInputGet
14:20:46 <joelteon> mistake* heh
14:20:50 <jrmithdobbs> joelteon: ya i got what you meant
14:21:09 <joelteon> but the order is important, (<$> f) and (f <$>) are entirely different
14:21:41 <jrmithdobbs> but <$> f == (<$>) f
14:21:46 <joelteon> right
14:21:57 <jrmithdobbs> err f <$> == (<$>) f i mean
14:22:01 <joelteon> yes
14:22:04 <malorie> Cale: does the state monad allow me to make the labeling-dependencies implicit?, or does it just make sense to use it, because of the type of go?
14:22:38 <lpaste> Cale annotated “rearranging tree-labels, such that the tree becomes in-order” with “rearranging tree-labels, such that the tree becomes in-order (annotation)” at http://lpaste.net/3575535637987590144#a95951
14:24:09 <Cale> btw, if you had a base case for Null in the go for normalform, even your go would be a good bit cleaner
14:24:25 <Cale> (unless you really want that to be a pattern match failure)
14:24:55 <Cale> I also took the liberty of making the inorder traversal more efficient
14:25:05 <Cale> (yours was O(n^2), this one is O(n))
14:25:56 <Cale> malorie: Does that all make sense?
14:26:51 <FreeFull> jrmithdobbs: (f <$>) is actually == \f g -> (<$>) f g    which does make a difference sometimes
14:26:58 <chrisdone> @numberwang 8
14:26:58 <lambdabot> Unknown command, try @list
14:27:07 <chrisdone> hey… lambdabot doesn't have numberwang =(
14:27:14 <quchen> numberwang?
14:27:16 <chrisdone> int-e: your lamdabot sucks!
14:27:22 <tarruda> Whats the simplest way to write the following program in haskell:
14:27:24 <quchen> That sounds *wrong*.
14:27:27 <Cale> 8 is numberwang
14:27:32 <tarruda> 1- Read a file from disk containing a dictionary
14:27:38 <tarruda> 2- Update many entries in the dicitionary
14:27:43 <tarruda> 3- Persist it back to tdisk
14:27:51 <tarruda> ?
14:27:54 <chrisdone> https://github.com/mokus0/lambdabot/blob/master/lambdabot-novelty-plugins/src/Lambdabot/Plugin/Novelty/Numberwang.hs
14:28:56 <quchen> That's like linking a blueprint to someone who wants to know what a car is.
14:29:01 <pdxleif> what is meant by "dictionary"? Some JSON?  A Map String String?
14:29:21 <tinl> hello; I've cabal running and it can install various packages normally. but I cannot import HUnit into my files
14:29:21 <Cale> tarruda: Use Data.Map somehow? Also, if you happen to be using lazy IO, be especially sure to handle the filesystem correctly (write to a new file, move it over the old one when done).
14:29:24 <tarruda> yes any kind of dictionary, lets say its a Map String String
14:29:40 <chrisdone> quchen: http://www.youtube.com/watch?v=qjOZtWZ56lc
14:29:48 <tinl> I've installed HUnit with #"cabal install -p HUnit"; it doest isntall
14:29:49 <jrmithdobbs> so i've reduced that to two lines in a do block: do val <- (valCon <$>) . runInputGet $ ... ; doSomething val ; ... how can I get rid of the do block completely? i change it to (doSomething . valCon <$>) . it no longer typechecks: "Couldn't match type `HandlerT App IO TypedContent' with `TypedContent'"
14:29:53 <tinl> but i downt load it lateron
14:29:56 <tarruda> Cale: Perhaps you could show a snippet?
14:30:14 <pdxleif> readFile "foo.txt" >>= processFile >>= writeFile "newFoo.txt" ?
14:31:01 <tarruda> pdxleif: could you show the implementation of the processFile function? thats the part im having trouble
14:31:05 <malorie> Cale: it looks like it makes sense, but I've no idea what's actually happening :-)
14:31:26 <quchen> chrisdone: I'm going to hold you accountable for the loss of smart because this vid.
14:31:31 <chrisdone> quchen: :D
14:31:39 <pdxleif> So you'll want to go String -> Map String String
14:31:45 <pdxleif> and then the reverse direction when done
14:31:51 <tarruda> Assume its a Map String Int, how could I for example, iterate through each entry and increment it by one
14:32:11 <tarruda> and serialize it back to write to "newFoo.txt"
14:32:16 <Cale> Map.map (+1) theMap
14:32:57 <Cale> Though I guess if you're just adding one to all the entries, constructing a Map is a waste
14:33:20 <pdxleif> A Map String Int is isomorphic to a list of tuples: [(String, Int)]
14:33:28 <Cale> pdxleif: kind of
14:33:29 <int-e> chrisdone: sorry, but is there any point in that plugin at all?
14:33:45 <tarruda> Cale: I guess my example was too simple, what I want to do is this: Mine is a Map String Int containing filenames and modification timestamps
14:33:45 <Cale> The list of tuples can have duplicate keys, and maintains the order of the pairs
14:35:31 <chrisdone> int-e: not with that attitude
14:35:59 <tarruda> I would like to walk through the modified files, do some action on them(assume a simple touch) and update the corresponding timestamp
14:36:13 <quchen> … like @protontorpedo and @pl aren't funny enough, chrisdone!
14:36:28 <malorie> Cale: so, normalform generates a sequence of calls to label that adheres to the structure of the tree, and label does the actual magic, right?
14:36:30 <pdxleif> Just have a list of filename, timestamp pairs, then?
14:36:33 <chrisdone> @choose quchen chrisdone
14:36:33 <lambdabot> chrisdone
14:36:38 <chrisdone> that's what i thought.
14:36:47 <tarruda> pdxleif: yes
14:37:20 <tarruda> After updating the timestamp on all files, write the map back to the disk
14:37:38 <Cale> malorie: Come to #haskell-overflow and I'll go over how the state monad works if you want
14:37:52 <int-e> chrisdone: fwiw I didn't disable it consciously. it's the last novelty plugin that's to blame for there being an explicit list of novelty plugins that are enabled on here anyway, and I guess the numberwang one is quite recent.
14:37:56 <pdxleif> So on each file in the list, you want to do some IO to read the last modified date from the filesystem?
14:38:07 <lpaste> jrmithdobbs pasted “fun” at http://lpaste.net/4944874454376251392
14:38:12 <tarruda> pdxleif: yes
14:38:21 <jrmithdobbs> how can I get rid of that do block there?
14:38:44 <tarruda> if the file was modified, do something(eg: touch) update the timestamp
14:38:46 <piezoid> jrmithdobbs: mVal = doSomething <=<  fmap valCon . runInputGet $ ... ?
14:38:48 <tarruda> then write the map back to disk
14:38:57 <shergill> numberwang??
14:39:03 <jrmithdobbs> :t (<=<)
14:39:04 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:39:10 <chrisdone> shergill: see youtube link for explanation
14:39:23 <quchen> "explanation"
14:39:40 <pdxleif> picturing something like mapM updateLastModified [("foo", 26), ("bar", 27), ...
14:39:49 <chrisdone> :p
14:39:49 <mm_freak_> does anyone actually use deferred type errors?
14:40:15 <chrisdone> nope
14:40:16 <tarruda> :t mapM
14:40:17 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:40:34 <mm_freak_> what are the use cases again?
14:40:36 <tarruda> interesting
14:40:43 <chrisdone> i'd be interested to see a poll. when it came out i thought i'd use it, but i've never felt like using it
14:40:44 <shergill> chrisdone: lol
14:40:50 <tarruda> seems like what I need, thanks pdxleif
14:40:52 <ion> mm_freak: I’d love to have them in ghci, but they only seem to work with compiled code.
14:41:19 <chrisdone> ion: what, really? i thought ghci *was* the use-case
14:41:21 <pdxleif> It's like map, but where each action can do IO.  Same as doing sequence (map updateLastModified [("foo", 26), ...])
14:41:22 <chrisdone> O _o
14:41:24 <mm_freak_> ion: do you ever actually carry on developing when you see a type error?
14:41:29 <mm_freak_> i don't
14:41:38 <mm_freak_> not even in GHCi
14:41:45 <ion> mm_freak: The use case is preventing holes from aborting compilation and testing of working code in the same file.
14:41:59 <mm_freak_> ion: oh, good point
14:42:04 <shergill> mm_freak_: i do. what ion said. i'd use it more in ghci
14:42:08 <mm_freak_> you mean the ImplicitParams-style holes?
14:42:24 <ion> Well, anything you’re using for pseudo-holes while we’re waiting for real holes.
14:42:33 <ion> Including “undefined”
14:42:45 <mm_freak_> well, undefined is seldomly a type error to begin with =)
14:42:52 <ion> Oh, right, undefined doesn’t really cause errors.
14:42:53 <chrisdone> indeed
14:42:55 <mm_freak_> but yeah, that makes sense…  thanks
14:43:29 <pdxleif> I guess instead of json, you could store that data on disk as some csv-like thing, where each line is "filename modificationInt", assuming no spaces in the filename
14:43:44 <pdxleif> then you could just use the "lines" and "words" functions to parse the structure.
14:43:59 <pdxleif> tarruda^
14:44:28 <tarruda> pdxleif: thanks
14:45:06 <jrmithdobbs> piezoid: hrm, why can't i compose that with >=> instead? (I know i can't i've shown this to myself ;p)
14:45:21 <jrmithdobbs> :t (>=>)
14:45:23 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:46:27 <piezoid> jrmithdobbs: <=< is more like (.) :: (b -> c) -> (a -> b) -> a -> c
14:46:55 <cschneid> :t >>=
14:46:55 <lambdabot> parse error on input `>>='
14:47:03 <cschneid> :t (>>=)
14:47:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:47:48 <jrmithdobbs> piezoid: ya but looking at the differences in the signatures I don't understand exactly why they aren't transposable
14:48:05 <jrmithdobbs> piezoid: intuitively speaking it seems like they should be
14:48:18 <piezoid> jrmithdobbs: you can do ((fmap valCon . runInputGet) >=> doSomething) $ ... but it's awkward
14:48:30 <jrmithdobbs> OH
14:48:38 <jrmithdobbs> thank you for saying that, I see my misconception now
14:48:39 <jrmithdobbs> haha
14:49:13 <jrmithdobbs> i was forgetting in this instance nothing on the left side there was monadic to begin with, ha
14:49:29 <jrmithdobbs> or however you phrase that
14:53:15 <piezoid> @pl '\a -> (fmap g  (f a)) >>= mh'
14:53:15 <lambdabot> (line 1, column 4):
14:53:15 <lambdabot> unexpected " "
14:53:15 <lambdabot> expecting expression
14:53:16 <skypers> night everyone
14:53:38 <piezoid> @pl "\a -> (fmap g  (f a)) >>= mh"
14:53:38 <lambdabot> "\a -> (fmap g  (f a)) >>= mh"
14:53:50 <piezoid> @pl \a -> (fmap g  (f a)) >>= mh
14:53:51 <lambdabot> (mh =<<) . fmap g . f
14:53:56 <piezoid> err...
14:56:16 * hackagebot mediawiki 0.2.6 - Interfacing with the MediaWiki API  http://hackage.haskell.org/package/mediawiki-0.2.6 (SigbjornFinne)
14:58:35 <benzrf> is there a built in flag or method of running a haskell function or program such that it is killed if it takes too long to run?
14:58:50 <quchen> benzrf: System.Timeout.timeout
14:59:18 <benzrf> how do i use it?
14:59:32 <quchen> Have you read the docs?
14:59:35 <benzrf> derp, ok
15:00:15 <chrisdone> lol
15:02:33 <cswords> is it possible to unparse something with Meta.Parse?
15:02:45 <cswords> I want something that will take Exp -> String
15:03:12 <lpaste> jrmithdobbs annotated “fun” with “fun (annotation)” at http://lpaste.net/4944874454376251392#a570351565051789312
15:03:22 <jrmithdobbs> that is fun
15:03:30 <benzrf> > 50_00
15:03:31 <lambdabot>   Not in scope: `_00'
15:03:33 <jrmithdobbs> starting to get this for real finally i think ;p
15:03:38 <benzrf> pfft
15:03:42 <benzrf> > 500 000
15:03:44 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
15:03:44 <lambdabot>    arising f...
15:03:47 <benzrf> poo
15:05:48 <acowley> Isn't there some nice new numeric reader in 7.8?
15:05:57 <acowley> I can't remember what format it was
15:07:08 <benzrf> hmmm
15:07:17 <benzrf> how would I use timeout with a pure functoin ?
15:07:18 <benzrf> *function
15:07:44 <benzrf> using return on the function call seems to cause eval before the thunk is passed to timeout
15:10:08 <acowley> ah, NumDecimals allowing 1.2e6 :: Integer
15:10:24 <acowley> benzrf: I'd use "evaluate"
15:11:08 <benzrf> acowley: where's it from?
15:11:13 <benzrf> @t evaluate
15:11:13 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
15:11:19 <benzrf> @type evaluate
15:11:20 <lambdabot> a -> IO a
15:11:24 <benzrf> o:
15:11:26 <benzrf> NeatBasis:
15:11:27 <benzrf> *neat
15:11:30 <benzrf> where do i import it?
15:12:07 <acowley> Control.Exception
15:12:09 <geekosaur> Control.Exception
15:12:10 <benzrf> thanks
15:13:00 <benzrf> crud
15:13:10 <benzrf> i think its still evalling it instead of just turning it into a thunk
15:13:18 <benzrf> @thx
15:13:19 <lambdabot> you are welcome
15:13:25 <dyreshark> that's an exceptional import you've got there
15:13:32 <benzrf> dyreshark: ba dum tsh
15:14:36 <acowley> benzrf: I don't know what "evalling it instead of just turning it into a thunk" means
15:14:41 <benzrf> hmm
15:14:58 <benzrf> well, i want to create an io action that causes my pure function to be evaluated when executed
15:15:23 <benzrf> but as it is, i think the pure function is being evaluted and then the result is being put into an io action
15:15:34 <benzrf> i want to move the pure call into the io action
15:15:36 <quchen> There's 'evaluate' in Control.Exception I think.
15:15:47 <quchen> It evaluates something to WHNF in IO.
15:15:55 <acowley> quchen: I don't think you even need to scroll back to see that suggestion :P
15:16:00 <quchen> Oh.
15:16:11 <benzrf> how does it differ from return?
15:16:14 <quchen> acowley: I neither scrolled nor back. Pardon
15:17:06 <acowley> benzrf: Did you look at the docs?
15:17:07 <quchen> evaluate differs from return in that it evaluates something while return doesn't.
15:17:11 <benzrf> quchen: uh
15:17:13 <geekosaur> return doesn't do anything. evaluate does :p
15:17:34 <benzrf> ?
15:17:39 <geekosaur> you were actually seeing the opposite of what you thought
15:17:50 <geekosaur> timeout evaluated a thunk, to no effect, and returned it to you
15:18:03 <geekosaur> if ou use evaluate then evaluation is forced
15:18:05 <benzrf> no, it hung
15:18:28 <benzrf> i wrote a simple lambda calculus evaluator and im trying to put in a bit to prevent infinite recursion via timeout
15:18:37 <geekosaur> right
15:18:37 <benzrf> i integrated it into an irc bot for fun, you see
15:18:52 <geekosaur> the problem is that the actual evlaluation of the thunk happens *agter timeout has returned*
15:18:59 <geekosaur> because all you did was `return` it
15:19:00 <benzrf> oh
15:19:02 <benzrf> ohhh, ok
15:21:49 <benzrf> oh huh
15:21:51 <benzrf> never mind, it works
15:21:54 <benzrf> i just miswrote it
15:21:55 <benzrf> =D
15:22:34 <Tordek> hi
15:22:34 <benzrf> oh wait, maybe not
15:22:37 <benzrf> hello Tordek
15:22:39 <benzrf> do you like d&d?
15:22:43 <Tordek> aye, lad
15:22:48 <benzrf> :)
15:23:08 <Tordek> is there a default collection of locales to use for TimeLocale, or do I have to define my own?
15:30:11 <quchen> chrisdone: I'm starting to like your Lisp-style code style.
15:30:27 <benzrf> quchen: hows it lisp like?
15:30:28 <quchen> It's awkward when you're conditioned towards hating parentheses at first though :-)
15:30:34 <benzrf> ew parens
15:30:36 <benzrf> $ ftw
15:30:43 <ion> Overuse of ($) for the lose.
15:30:57 <benzrf> pfft
15:31:03 <benzrf> you can  never have too many $s
15:31:07 <ion> Overusing it just obfuscates the structure you’d see otherwise when skimming.
15:31:11 <benzrf> money
15:31:23 <Peaker> ion: example of overusing it?
15:31:23 <quchen> Right, I'm using ($) only for certain super-top-level functions (atomically, liftIO, ...)
15:31:34 <quchen> … now
15:31:34 <benzrf> quchen: atomically?
15:31:46 <benzrf> i personally use $ almost anywhere i can instead of parens
15:31:46 <benzrf> :B
15:31:51 <benzrf> i guess im just a lazy typist
15:32:00 <Tordek> . > $
15:32:05 <quchen> ($) is really hard to track over long expressions.
15:32:17 <benzrf> notice that i also leave off apostrophes usually
15:32:22 <quchen> (also . this . is . nicer) (than . this $ form)
15:32:22 <benzrf> probably related
15:32:35 <benzrf> quchen: but then you have to parenthesize the dotted form
15:32:40 <quchen> Yup.
15:32:48 <benzrf> EVIL PARENS
15:32:53 <benzrf> PARENS MUST DIE
15:33:01 <FreeFull> > map ($ 3) [(+1),(*10)]
15:33:02 <lambdabot>   [4,30]
15:33:03 <Tordek> you're a parencide
15:33:03 <FreeFull> Do this with .
15:33:05 <benzrf> any time i see a paren, i make a new where clause
15:33:16 <quchen> FreeFull: Silly you! map = fmap = (.)!
15:33:31 <FreeFull> quchen: In default prelude . isn't fmap
15:33:37 <Iceland_jack> > mapM id [(+1),(*10)] 3 -- ;)
15:33:38 <lambdabot>   [4,30]
15:33:40 <quchen> It was a joke :-(
15:34:08 <FreeFull> Iceland_jack: doesn't have (.)
15:34:37 <FreeFull> Isn't mapM id the same as sequence
15:34:44 <FreeFull> :t mapM id
15:34:45 <lambdabot> Monad m => [m b] -> m [b]
15:34:45 <quchen> Yes.
15:34:47 <FreeFull> :t sequence
15:34:48 <lambdabot> Monad m => [m a] -> m [a]
15:34:56 <quchen> mapM f = sequence . map f
15:35:31 <benmachine> sequence = mapM id
15:35:46 <benmachine> oh
15:35:51 <benmachine> that is what we were talking about
15:35:54 * benmachine didn't read up far enough
15:36:28 <FreeFull> I do that too
15:38:31 <djahandarie> If mapM f = sequence . map f and sequence = mapM id, then mapM f = mapM id . map f, right?!
15:39:15 <FreeFull> sequence isn't defined as mapM id
15:39:47 <benzrf> FreeFull: but it could be
15:40:31 <FreeFull> It could be, if mapM wasn't defined in terms of it
15:41:26 <FreeFull> The implementation for sequence in GHC seems to be   sequence ms = foldr k (return []) ms where k m m' = do { x <- m; xs <- m'; return (x:xs) }
15:41:44 <chrisdone> does ghci use editline or readline?
15:42:12 <FreeFull> I think it uses haskeline
15:42:42 <chrisdone> oh, sweet. i'll use that
15:42:47 <frx> is there a haskell-mode or ghc-mode function that wraps a long single-line comment to a multi-lined comment with -- prepended before every new line?
15:43:11 <chrisdone> frx: M-q does that
15:43:35 <frx> so it does, thanks!
15:43:43 <chrisdone> welcome
15:50:59 <chrisdone> i love how americans say theatre
15:51:28 <turduks> **Earn 0.25$ Per Lead **. For Details:http://www.StillRemember.Net/Affiliate.htm
15:51:30 <jodaro> thee-dur
15:51:53 --- mode: ChanServ set +o monochrom
15:51:59 <chrisdone> the-ey-dur
15:52:03 <monochrom> oh heh, nevermind
15:52:06 --- mode: monochrom set -o monochrom
15:52:10 <Peaker> These K-lines are quick recently, aren't they
15:52:29 <monochrom> yeah
15:52:52 <chrisdone> nice
15:53:01 <benzrf> chrisdone: wow thats real SNOOTY of you isnt it
15:53:56 <chrisdone> benzrf: interior crocodile alligator, i drive a chevrolet movie the-a-tre
15:54:33 <chrisdone> benzrf: https://www.youtube.com/watch?v=q_qUiytLYRc
15:54:50 <Peaker> chrisdone: did you see our lamdu page at: http://peaker.github.io/lamdu/ ?
15:57:00 <chrisdone> Peaker: suave!
15:57:20 <Peaker> chrisdone: thanks! :)
15:57:37 <Peaker> finally we have some "published" screenshots, though a video is too early still
15:57:48 <benzrf> Peaker: pfft
15:57:57 <benzrf> that doesnt look NEARLY 1337 enough
15:58:16 <Peaker> benzrf: which part? :)
15:58:17 <benzrf> how can i make people think im a super genius if it's not even in a proper h4xx0r font??
15:58:37 <Peaker> Comic Sans?
15:58:45 <benzrf> i bet it doesnt even have ricing options
16:00:02 <chrisdone> Peaker: when the time comes for a release & marketing, i really like sublime text's animations: http://www.sublimetext.com/
16:00:17 <chrisdone> Peaker: can instantly see the power of the editor without having to play a video or wait for a gif
16:00:38 <chrisdone> (i tried it out locally with imagemagick to do the imports and it works well)
16:00:57 <Peaker> chrisdone: yeah, that's nice!
16:02:40 <zardoz`> is there a function similar to this one?  hasEqual :: (a -> b) -> (a -> a -> Bool)
16:02:57 <monochrom> no
16:02:58 <zardoz`> actually hasEqual :: Eq b => (a -> b) -> (a -> a -> Bool)
16:03:22 <monochrom> I see. probably not written yet, but you can write it easily
16:03:51 <zardoz`> I have already. was just curious if there is one, or if `on` could be used somehow
16:04:02 <merijn> :t (compare `on`)
16:04:03 <lambdabot> Ord b => (a -> b) -> a -> a -> Ordering
16:04:07 <zardoz`> hasEqual length "foo" "bar" => true
16:04:15 <monochrom> "on" can be used
16:04:17 <Peaker> @type ((==) `on`)
16:04:17 <monochrom> @type on
16:04:18 <lambdabot> Eq b => (a -> b) -> a -> a -> Bool
16:04:19 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:04:21 <merijn> :t ((==) `on`)
16:04:22 <lambdabot> Eq b => (a -> b) -> a -> a -> Bool
16:04:28 <monochrom> yeah, what Peaker says
16:05:03 <zardoz`> @src on
16:05:03 <lambdabot> (*) `on` f = \x y -> f x * f y
16:05:31 <zardoz`> what is (*)? infix function argument?
16:05:40 <monochrom> yes
16:05:56 <Peaker> There's the cute infixr 4 ~> combinator:  (pre ~> post) f = post . f . pre       \f -> (==) & f ~> f ~> id    (~> lets you "visually" apply functions on the signature)
16:06:18 <benzrf> Watcher7:
16:06:19 <benzrf> *wat
16:06:29 <Watcher7> What?
16:06:33 <Watcher7> Oh.
16:06:35 <merijn> zardoz`: Any operator can be turned into a prefix function using parens
16:06:35 <benzrf> mis-tab complete
16:06:57 <lpaste> “_justjust” pasted “netwire HasTime” at http://lpaste.net/9201033473861615616
16:06:58 <merijn> zardoz`: Likewise any function can be made infix using backticks
16:07:21 <Peaker> @let infixr 4 ~> ; (pre ~> post) f = post . f . pre
16:07:23 <lambdabot>  Defined.
16:07:26 <zardoz`> merijn i know, but I haven't seen infix function as a local argument until now
16:07:27 <_justjust> can someone help me with the error?
16:07:40 <Peaker> @type \f -> (==)  &  f ~> f ~> id
16:07:42 <lambdabot> Eq a => (a1 -> a) -> a1 -> a1 -> Bool
16:07:48 <merijn> :t map (+) [1..10]
16:07:49 <lambdabot> (Enum a, Num a) => [a -> a]
16:08:15 <merijn> > map ($1) (map (+) [1..10])
16:08:16 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:09:14 <Peaker> _justjust: I don't know netwire, but this kind of instance error is usually because of too-polymorphic types, in this case "s" seems unconstrainted, if you constrain it to a particular type it should find the instance
16:09:21 <Peaker> (just a guess)
16:11:51 <_justjust> Peaker: thank you seems like i don't understand HasTime
16:13:00 <Peaker> _justjust: http://hackage.haskell.org/package/netwire-5.0.0/docs/Control-Wire-Session.html#t:HasTime it seems to have just 1 instance for "Timed" as second param, not "Double"
16:13:08 <benzrf> ok wait
16:13:25 <benzrf> Peaker: is this lamdu thing
16:13:28 <benzrf> similar to what is in this video
16:13:30 <Peaker> or rather: HasTime t (Timed t s), and not   HasTime Double s
16:13:36 <benzrf> *"inventing on principle"
16:13:50 <Peaker> benzrf: yeah, a bit. but we're more ambitious on some fronts, less ambitious in others
16:13:51 <_justjust> Peaker: what does HasTime t s | s -> t mean there even? what is the | for?
16:13:57 <benzrf> because if it is, i love you
16:14:00 <Peaker> _justjust: it's a "functional dependency"
16:14:09 <_justjust> omg
16:14:37 <Peaker> _justjust: it means that once any instance exists with some "s" and "t", that all other instances with the same "s" must also have the same "t"
16:14:53 <_justjust> k i heard about it :)
16:14:55 <_justjust> thank you
16:15:42 <Peaker> _justjust: in this case, it would probably be nicer as a type family, because all it's trying to do is have access to the "t" in (Timed t s) (in the single instance that seems to exist)
16:16:24 <Peaker> _justjust: as a type family, it would be like:  class HasTime t where type Delta t ; dtime :: t -> Delta t
16:17:25 <Peaker> benzrf: Lamdu is a much nicer code editor than the JS editor he displayed in the demo.  But we don't plan on the "record" features to replay with modifications and some of the other cool stuff (it's not in our core focus)
16:17:51 <_justjust> Peaker: thanks! i'll have to refresh type families :)
16:18:02 <benzrf> im talking more about seeing live flow of data as you code
16:18:31 <Peaker> benzrf: yeah, we'll have an execute-as-you-edit, using purity to make it safe.. Bringing the best of spreadsheets to Haskell :)
16:18:35 <benzrf> i have always wanted this and never realized it
16:18:46 <benzrf> holy crap
16:19:09 <Peaker> benzrf: so you immediately see what your changes do, and we intend to have custom UI/visualizations for custom types, rather than just silly Show instances
16:19:14 <benzrf> <
16:19:15 <benzrf> 3
16:19:34 <Peaker> benzrf: read the project page -- much of that is described
16:19:36 <benzrf> now that i know this exists i will not be satisfied with silly debug prints anymore :(
16:19:44 <benzrf> bluh
16:20:07 <Peaker> hah, like we all can no longer be satisfied with Perl/Python/Ruby after Haskell :P
16:20:20 <Peaker> #haskell, ruining programmer lives since 1992
16:20:36 <benzrf> to be fair i still use python and am switching to ruby
16:20:43 <benzrf> im not nearly comfortable in haskell
16:20:49 <benzrf> but i do always feel that yearning for currying
16:21:26 <benzrf> evenst whilst writing the most functional of code, surrounded by blocks & map calls at every turn
16:21:29 <benzrf> :B
16:23:34 <chrisdone> quchen: http://chrisdone.com/shm-writing-quchen.ogv ^_^
16:23:46 <Peaker> I'm more comfortable in Haskell for most stuff. But for basic stuff in Python's REPL like: open("foo").read().index("bar")  Python is much nicer.  Haskell needs a better Prelude for such basic I/O. Even simple, strict IO
16:23:53 <chrisdone> Peaker: ^ recent shm is pretty workable
16:24:09 <Peaker> chrisdone: awesome :) I'm going back to Lamdu development soon, the way things are looking, so will use that!
16:25:16 <benzrf> when i was writing some gnarly ruby that manipulated 4x nested lists, i started fantasizing writing it in haskell, in an editor where i can hover over any expr and see its type
16:25:18 <quchen> That's neat.
16:25:23 <acowley> shm?
16:25:25 <chrisdone> Peaker: yay!
16:25:28 <benzrf> but barely did i dream of seeing live data examples
16:25:31 <quchen> Serious Hacker Mode I assume ;-)
16:25:33 <benzrf> 8D
16:25:33 <acowley> Not on hackage
16:25:39 <chrisdone> acowley: “structured haskell mode”
16:25:51 <Peaker> benzrf: in Lamdu you can already press F7 to see all subexpression types
16:25:52 * Ralith likes quchen's better
16:25:53 <acowley> oh, your new mode!
16:26:19 <chrisdone> think of it like this
16:26:22 <benzrf> Peaker: i am so going to download this
16:26:24 <benzrf> so very much
16:26:28 <chrisdone> “Use structured-haskell-mode to prepare you for lamdu!”
16:26:35 <Peaker> benzrf: note: it's a preliminary prototype/toy :)
16:26:41 <benzrf> i mean, once it's done
16:26:41 <benzrf> of course
16:26:57 <benzrf> i wonder if i can make something like the js demo he showed by hooking into pdb
16:26:59 <benzrf> *for python
16:27:04 <benzrf> christ that would be amazing
16:27:27 <acowley> I've always struggled a bit with structured editors, actually
16:27:35 <acowley> I'm sure it's just a matter of not giving it enough time
16:27:57 <acowley> but I always seem to find some corner where I have invalid syntax and just want to delete that one character *right there* and can't do it :(
16:28:26 <haasn> isn't the point of structured editors to make syntax errors impossible?
16:28:34 <acowley> Yes
16:28:41 <acowley> but they don't always work perfectly
16:28:48 <Peaker> acowley: I think the devil is in the details, and most attempts I've seen got the details wrong..  also, I think chrisdone's shm lets you revert to text mode too, though I don't see myself needing to
16:29:06 <Peaker> (well I better use it before I make that statement :) )
16:30:28 <acowley> It's also frustrating if moving up/down is slower than the old fashioned way combined with fast cursor movement in your editor
16:31:06 <Peaker> acowley: I think even older structural editors made navigation faster, usually?
16:31:08 <_justjust> Peaker: thx got it working
16:31:17 <acowley> here's an example
16:31:26 <acowley> say I have (foo x), and I want ((foo x) y)
16:31:50 <acowley> I typically find I can get that text entered faster using normal point movement than moving up nesting the expr, moving down, and moving over
16:31:54 <chrisdone> actually shm behaves like paredit mode. you can make syntax errors but you'll get a red background. structured operations will still work on the existing tree, but nothing new that you type until it's parseable
16:32:10 <acowley> but, as I said, I'm sure a lot is just my lack of experience / muscle memory with the structured editors
16:32:22 <acowley> is shm in melpa or marmalade?
16:32:58 <Peaker> acowley: Naively, it's just 3 keys: "parent", "apply", "y".   vs.:  Control-left, Shift-(, End, space, y, Shift-)
16:33:03 <chrisdone> acowley: not yet. i'll make a release soon. when i can get it past johnw's strict standards, it'll be release worthy
16:33:37 <acowley> Peaker: Yeah, you're right.
16:34:01 <acowley> I guess when my cursor is at the end of (foo x), I just want to hit " y" first
16:35:01 <Peaker> acowley: in this edit, are you thinking: "I want these characters to be on screen", or "I want to apply the result to y" ?
16:35:13 <Peaker> acowley: I think my mode of thought is the latter
16:35:16 <acowley> the latter is rather quickly followed by the former :)
16:35:24 <Peaker> acowley: well, save the step :)
16:35:33 <chrisdone> if it's (foo x)| then in shm it would be SPC y M-S-(
16:35:38 <acowley> ah!
16:35:42 <acowley> that's perfect
16:36:37 <acowley> It's curious that it's M-S-( rather than M-S-)
16:37:32 <chrisdone> it's because parens wrap around the current node rather than making a new one. not sure whether that's best but it's what i've been using
16:38:14 <acowley> Makes sense
16:38:17 <chrisdone> Peaker: i like the apply idea
16:39:12 <acowley> I suppose this gets at exactly where I break down, though, I don't think "parent" first
16:39:22 <acowley> I think apply "this"
16:39:37 <Peaker> chrisdone: when we take the structural idea further to "typed", then in almost all contexts, adding an application is invalid as it breaks the types. You could still do that, but then you get a type error so the UI for that is de-emphasized or slightly more keystrokes.  Instead, you'd usually change the called function first
16:40:30 <chrisdone> Peaker: that sounds pretty inconvenient?
16:40:32 <Peaker> we might re-emphasize it (and just show the type error) if we find that it is annoying.. since it's a toy, we can't test it yet :)
16:41:25 * hackagebot network-bitcoin 1.5.0 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.5.0 (ClarkGaebel)
16:41:28 <Peaker> chrisdone: it might be, we're not sure.  you could just add the parameter at the function side (and automatically get the extra application everywhere, too), and then worry about filling in the logic later
16:41:29 <chrisdone> i guess you're always trying to fine the sweet spot between writing a language and working with a tree
16:42:08 <chrisdone> hm, so what's the behaviour?
16:42:22 <chrisdone> f x = ()
16:42:22 <chrisdone> a = f 1
16:42:22 <chrisdone> b = f 2
16:42:25 <Peaker> chrisdone: for now adding an apply that doesn't type check is a bit of a pain but we might revisit that
16:42:29 <AfC> I have a tinyprogram that is outputting "progname: <<loop>>". Is that some sort of indication that there is an infinite loop that the runtime has detected?
16:42:39 <chrisdone> now i want to add an argument to f. do i start with the f definnition or can i start at a's?
16:42:51 <eazar001> yes
16:43:41 <eazar001> @afc most likely you are defining a function/variable recursively with no terminating case
16:43:41 <lambdabot> Maybe you meant: src rc ghc bf ask arr
16:43:58 <AfC> (it's in some crazy type family based code that I'm calling)
16:44:25 <Peaker> chrisdone: for now you press <return> on f, then <right> to "x", press <space> to add an argument, and <accept> the new type which (will, not yet) add arg to all callers
16:44:27 <AfC> I'll take it back to upstream, then. Thanks.
16:44:53 <chrisdone> acowley: alternatively you can write SPC y and then wait a split second (for it to select the `y' node) and then M-a M-S-(. M-a goes to the parent
16:44:55 <acowley> You know, this may sound weird, but I find that highlighting from flymake buys me some of a structured editors benefits. Namely the "always correct" syntax, but it feels very loose.
16:45:27 <chrisdone> Peaker: gotcha
16:45:30 <Peaker> acowley: your keyboard is being used to navigate the space of syntactically invalid programs, 99% of the input space is wasted.. you take many more key strokes to write the same programs
16:45:54 <acowley> That's where I'm not convinced!
16:45:58 <Peaker> chrisdone: you can change:  a = f 1    to:  a = (<error> (f 1)) <something>   or such, but this will not usefully guide you later in fixing 'f', so we don't want that :(
16:46:12 <acowley> I have a funny interplay with ghc-mod now, where I write a type, write some code, delete a type, have it autofilled
16:46:20 <chrisdone> Peaker: i can just imagine i'm at `a' and i realise i need to add an arg to f and i have the arg in my clipboard. the natural feeling is to just insert it. it would be sweet to say <i'mright> and it would update the definition of f and callsites
16:46:33 <acowley> so we go back-and-forth, with ghc-mod speaking to me in pink, blue, and blank
16:47:03 <eazar001> @AfC, have you isolated what code is responsible for your bottomless execution?
16:47:04 <lambdabot> Unknown command, try @list
16:47:04 <Peaker> acowley: when we compare some of the simple programs we can write with Lamdu to writing them in a text editor, it takes about 50%-75% of the key strokes, and that's with only the basic structural editing operations, and no refactoring features (besides rename) yet which will cut that down drastically
16:47:06 <chrisdone> acowley: what does ghc-mod autofill?
16:47:21 <acowley> chrisdone: type signatures
16:47:28 <chrisdone> ah, sure
16:47:44 <acowley> chrisdone: I often start by writing a type signature, then code some and look at errors as I'm typing
16:47:56 <chrisdone> i rarely write out my own types unless i'm doing some type hackery
16:47:59 <Peaker> chrisdone: I think maybe for that kind of thing I'd want to be able to "paste in the general vicinity", maybe into a structured comment or such (perhaps a rendering of "const <code> <commented out here>"
16:48:15 <Peaker> chrisdone: and later you figure out how to hook the pieces up at that position
16:48:16 <acowley> chrisdone: As I'm iterating the definition to what I want it's nice to get the type checker to fill some things in
16:48:27 <chrisdone> Peaker: right, a kind of margin of notes
16:48:41 <hpc> at this point i only write out type signatures when i don't know what to do at the value level yet
16:48:43 <AfC> eazar001: https://github.com/alphaHeavy/protobuf/issues/2
16:49:30 <AfC> I must be doing something wrong if they say it works fine for them.
16:49:34 <Peaker> acowley: think of what happens when you press any one of the ~60 relevant keys in your keyboard in your text editor. What happens then?
16:50:12 <Peaker> acowley: the answer, for vast majority of them -- is a syntax error, majority of those still -- not even a useful step towards a valid syntax
16:50:23 <eazar001> okay, i have it bookmarked, if see something i'll make sure to comment on github then
16:50:24 <acowley> That's not a useful point
16:50:28 <Peaker> acowley: if you then think about well typed programs, the range goes down even more
16:50:40 <acowley> Most of the keys I press are identifier names
16:51:11 <Peaker> acowley: well, typing identifier names is either naming them (one time) or using them (many times). For using them, if you have smart type-based completions, you should only type a very small fraction of them
16:52:04 <acowley> I fully accept that my editor could be more helpful
16:52:17 <chrisdone> Peaker: that's a point. i should note that down as a todo feature. we now have subexpression type info in the fpco ide, and autocompletion. linking those two up to filter the appropriate thing would be fun
16:52:19 <acowley> But I'm not swayed by arguments about all of the many keys on my keyboard that might be erroneous
16:52:22 <Peaker> acowley: so considering only the space of correct-syntax, well-typed programs, typing in a much smaller part of an identifier name is enough. It also comes with whatever structural wrappings necessary to make it type-check in that position by default -- which saves even more key strokes
16:52:29 <AfC> eazar001: never mind. I have it now. A previous error had told me I couldn't use the automatically derived Show. Now I can.
16:52:47 <merijn> @quote ascii.turd
16:52:47 <lambdabot> ConorMcBride says: "Sometimes it's easier to search for good programs in the space of well typed programs, rather than in the space of ascii turds."
16:52:51 <Peaker> chrisdone: how do you do subexpression type info for nested type expressions that depend on local bindings within "where", etc?
16:52:54 <AfC> eazar001: (last line of the source snippet in the issue)
16:53:14 <Peaker> merijn: Great one :)
16:53:15 <chrisdone> Peaker: nested type expressions? what's that?
16:53:38 <Peaker> chrisdone: arrg. just meant: subexpressions that depend on a variable from "let" or "where"
16:53:52 <eazar001> @AfC have you run any debug output on it?
16:53:52 <lambdabot>  Done.
16:53:55 <Iceland_jack> Peaker: I'm guessing ScopedTypeVariables?
16:53:56 <chrisdone> ah, sure, local things work fine
16:53:58 <Peaker> chrisdone: ghc-mod/etc used a naive ghci  ":t <subexpression here>"
16:54:03 <lispy> ?tell edwardk my client doesn't beep :)
16:54:03 <lambdabot> Consider it noted.
16:54:12 <Peaker> chrisdone: but this doesn't work when <subexpression here> contains variables from "where", "let", parameters, etc
16:54:15 <eazar001> oh i see your output right there
16:54:19 <lispy> ?tell edwardk although, sometimes I think to type /lastlog lispy
16:54:19 <lambdabot> Consider it noted.
16:54:24 <chrisdone> Peaker: hmm, i think ghc-mod uses a full type tree from the ghc api
16:54:31 <chrisdone> and hdevtools does too
16:54:36 <ion> “Done.” Done what? :-D
16:54:38 <chrisdone> when  was the last time you tried them?
16:54:45 <Peaker> chrisdone: Maybe 5 months ago?
16:54:48 <chrisdone> weird
16:54:59 <chrisdone> i've ripped code from ghc-mod that gets sub-expr type info
16:55:02 <chrisdone> sec
16:55:05 <Peaker> I remember setting things up to work at all was very difficult too :(
16:56:05 <chrisdone> https://gist.github.com/chrisdone/1ac360460f99442f9efe
16:56:22 <acowley> ghc-mod is quite good at types of sub-expressions
16:56:34 <chrisdone> ^ with this you can just put in a line-col and it gives you a list of types of the expr, its parent, that parent's parent, up to the top
16:56:38 <eazar001> @AfC okay i'll be afk for a while i get grab myself some bites then i'll try to execute the code
16:56:39 <lambdabot>  Done.
16:56:52 <eazar001> pm me if you have any updates/info
16:57:00 <chrisdone> i ripped that from ghc-mod. hdevtools has slightly better support, it's basically a copy of ghc-mod's module plus extras
16:57:31 <chrisdone> Peaker: anyway our ide is using the ghc api at the back so it looks at all the types in the tree. e.g. http://chrisdone.com/subexprinfo.png
16:57:53 <chrisdone> i'm selecting things and it's showing the type of that region
16:57:59 <AfC> eazar001: fixed/closed: https://github.com/alphaHeavy/protobuf/issues/2#issuecomment-28948111
16:58:12 <Peaker> chrisdone: cool! It might be nice to also have Lamdu-style view? :)  Let me get a screenshot
16:58:15 <chrisdone> Peaker: but yeah, i never got ghc-mod to work properly in the past
16:58:17 <AfC> eazar001: thanks for your interest
16:58:26 <eazar001> hahaha
16:58:36 <eazar001> well that was easy: the wait solution
16:58:49 <acowley> I don't understand unix or emacs and I've installed ghc-mod on half a dozen computers. Luck of the ignorant, ftw!
16:58:54 <eazar001> congratulations
16:59:10 <acowley> whoa, chrisdone that is very pretty
16:59:31 <chrisdone> acowley: =)
16:59:49 <zardoz`> what module naming convention is usually recommended?  Zardoz.Directory, or System.Directory.Zardoz ?
16:59:52 <Peaker> chrisdone: Lamdu's types' view: http://i.imgur.com/XGOqFS2.png
16:59:56 <chrisdone> acowley: you can mess around with it for free now https://www.fpcomplete.com/
17:00:10 <chrisdone> Peaker: that's like a toggleable thing righht?
17:00:13 <Peaker> yeah
17:00:15 <chrisdone> nice
17:00:28 <chrisdone> yeah we were saying that's a cool thing we could do
17:00:37 <Peaker> this is the normal view: http://i.imgur.com/4ByvAcdh.png
17:00:38 <chrisdone> hit a key and have the editor show me *EVERYTHING*
17:00:54 <Peaker> though we want to sugar:  \(x:{a:Int,b:Int} -> ...    into    \a b -> ...
17:01:03 <Peaker> (in the display)
17:01:30 <acowley> <Patrick Stewart> I've seen everything
17:01:33 <heatsink> zardoz`, better to put things under the top-level namespace.
17:01:41 <chrisdone> mgsloan had a similar type display thingie from a prototype a couple years back, he's also psyched to get such a display in the ide
17:01:57 <heatsink> zardoz`, and hopefully "Zardoz" is just a nonce word and not your actual module name
17:01:58 <chrisdone> Peaker: what's the cur/next stuff?
17:02:21 <Peaker> chrisdone: it's a "running" fibs, rather than the more mind bending "zipWith" recursive implementation
17:02:34 <Peaker> chrisdone: i.e: store 2 numbers that run along the sequence
17:03:07 <chrisdone> ahh i thought it was a built-in lamdu thing for resolving types
17:03:17 <chrisdone> my bad, didn't read it properly
17:03:19 <Peaker> chrisdone: oh, it's just a record of 2 ints named cur and next
17:03:52 <Peaker> btw, http://i.imgur.com/FnjrIEX.png demonstrates one of the coolest code completions in Lamdu, I think :)   note the green cursor has written nothing at all, note what the completion underneath it is
17:04:11 <zardoz`> heatsink by top-level namespace you mean System.Directory.*?  and no, Zardoz would be my module name :). just a bunch of utility functions for personal use.
17:04:26 <chrisdone> acowley: and then i ride away. on the grass!
17:04:35 <Peaker> it knows iterate's "step" parameter is {cur:Int,next:Int}->{cur:Int,next:Int}    so it offers:  "\(x:{cur:Int,next:Int}) -> {cur=?,next=?}
17:04:37 <acowley> chrisdone: :D
17:05:10 <heatsink> Yeah, like System.Directory.Foo
17:05:12 <Peaker> and it knows the type because it does the online type inference -- which is incidentally why we prefer the "initial" parameter to be first (more useful for completions/type info)
17:05:44 <chrisdone> Peaker: nice =)
17:06:09 <chrisdone> Peaker: so far this could be done with the ghc api right? with some gaps filled in with undefineds
17:06:26 <chrisdone> i really want some fill-in stuff like this
17:06:32 <Peaker> chrisdone: mostly, but you'd need the usual Haskell ceremony around record definitions :(
17:06:33 <zardoz`> heatsink what other module name would you recommend?  for directory related utility functions, similar to the ones in System.Directory
17:06:51 <Peaker> chrisdone: we want a structural type system, we dislike ADT's to rule them all - requiring data constructors around everything
17:07:11 <chrisdone> not row polymorphism?
17:07:30 <Peaker> row polymorphism is a nice feature in a structural type system. We don't have it yet but we want it :)
17:07:50 <Peaker> data FibPair = FibPair { cur :: Int, next :: Int }   needs to be defined first.. whereas in our code we just threw the record value there without defining it first
17:07:59 <chrisdone> Peaker: what i read in here is the extent of my readings on both subjects http://brianmckenna.org/blog/row_polymorphism_isnt_subtyping
17:08:35 <acowley> that's a great intro to the subject
17:08:47 <Peaker> chrisdone: we don't want subtyping (especially not of the kind that makes type inference hard)
17:08:57 <chrisdone> nod
17:09:10 <Peaker> chrisdone: we considered anonymous sums and subtyping them automatically but decided against it because it would make almost everything well-typed in a silly way
17:09:12 <acowley> I think I even fixed a bug in the code in that article when he published it
17:09:21 <Peaker> (I think Scala does this)
17:09:27 <chrisdone> acowley: nice =)
17:10:08 <Peaker> chrisdone: but I think structural typing is much nicer than What Haskell does.. but I understand why Haskell doesn't do it -- it makes higher-kinded types and classes difficult, at least from my cursory thinking about it :)
17:10:11 <acowley> I wonder why we don't have more support in vinyl for that sort of thing
17:10:20 <chrisdone> alright i better go to bed or i'll hate the world when i wake up tired in the morning
17:10:21 <acowley> It's no good for my usual use of serializing the record
17:10:33 <Peaker> chrisdone: good night!
17:10:35 <acowley> but it's still a nice thing elsewhere
17:10:40 <chrisdone> night chaps! nice talking
17:12:22 <zardoz`> what do you think about this?  type BaseName  = String; type Directory = String; type Extension = String
17:12:32 <zardoz`> expanding on FilePath idea
17:12:44 <yogurt_truck> Peaker: what are anonymous sums? are they unboxed untagged unions?
17:12:58 <Peaker> yogurt_truck: "Polymorphic variants" ala ocaml
17:13:26 <yogurt_truck> Scala does them, but not very well at all
17:13:29 <Peaker> yogurt_truck: basically you can have  "Nothing + Just Int"  as a type of some expression, without defining the "Maybe" type beforehand
17:14:11 <Peaker> yogurt_truck: we still want to have polymorphic/variants anonymous sums. But we want the "injection" into the sum to be an explicit operation, rather than automatic. Subtyping here is just automating this injection to a tiny benefit and great horror :)
17:14:29 <acowley> oh geese, I got the Nvidia OpenCL compiler into a tizzy and need to restart
17:15:05 <Peaker> So you could have:  "Just 5 :: Just Int"    "inject :: a -> a + b"     "inject (Just 5) :: Just Int + Nothing"
17:15:35 <Peaker> (the "inject" would take the sum to inject to explicitly, probably, and the UI would help with that, but we've not fully considered the implications yet)
17:16:44 <heatsink> What would inject :: a -> a + a do?
17:16:56 <yogurt_truck> i.e you can define a `f(x: Int|String|Whatever)` function. in order to have that kind of union without defining a subtype relationship, but it's awful and sloppy in Scala
17:17:18 <yogurt_truck> Peaker: ah. I see
17:17:26 <grok22> is there a version of map that also passes the element index into the function
17:17:35 <heatsink> Oh... is a + a = a ?
17:17:46 <Peaker> yogurt_truck: for me it's more about avoiding the ADT ceremony to have precise types than about subtyping
17:18:04 <Peaker> yogurt_truck: in Haskell, if intermediate sub-expressions need a slightly different type, you won't go and define a separate ADT just for them
17:18:11 <Peaker> yogurt_truck: you'll likely use a less precise type, or partiality
17:18:37 <Peaker> yogurt_truck: instead, anonymous sums/products everywhere let you have more precise typing, basically enhancing the value of type-checking
17:18:55 <cmears> Is there any library that does something like "when this IORef is written to, run these actions"?
17:19:16 <Peaker> the fact you can re-use the same product fields and sum constructors in different contexts and have: a -> a+b    and  a*b -> a    operations available is a bonus
17:19:34 <Peaker> cmears: it's quite simple to implement a type that does that (not IORef)
17:20:02 <cmears> Peaker, I have implemented something that does it, but wanted to see if there is already something else (:
17:20:09 <Peaker> cmears: ah, no idea :)
17:21:33 <yogurt_truck> Peaker: so what language does this properly atm, ocaml? right now I totally prefer that ADT ceremony because from what I've tried to do in scala, I decided that untagged unions are an awful thing (in scala, that is)
17:22:52 <Peaker> yogurt_truck: Scala only has tagged unions, doesn't it?
17:22:58 <zardoz`> how would you portably compare extensions? I am using equalFilePath, which seems... weird
17:23:07 <Peaker> yogurt_truck: "tagged" vs. "untagged" is like "sum type" vs. "C union"
17:23:09 <zardoz`> file extensions
17:24:03 <yogurt_truck> Peaker: you can make untagged and unboxed unions by using the currey-howard isomorphism to be able to express A|B in the following type: !(![A] with ![B])
17:24:21 <Peaker> yogurt_truck: I agree that Scala doing auto-injection into larger sum types for subtyping is a very bad behavior. It's not really about anonymous sum types, which Scala doesn't really have -- it's injection only climbs the inheritance hierarchy
17:24:24 <heatsink> zardoz`, takeExtension gets the file extension
17:24:50 <yogurt_truck> Peaker: I tried to base a crucial part of an API on it a few days ago and it was horrible so I rather do this https://github.com/lambdatoast/ironhtml/blob/master/src/main/scala/Union.scala
17:25:04 <zardoz`> heatsink yes. but how to compare one extension with another? comparison should take case into consideration on some OSes, but not on other
17:25:34 <yogurt_truck> Peaker: that lets me define foo(Foo|Bar|Baz) of any types. but of course I need to also make the types for 4, 5, etc
17:25:38 <Peaker> yogurt_truck: I don't understand how CHISO  gives "untagged unions"
17:25:40 <heatsink> oh, idk
17:26:08 <Peaker> yogurt_truck: why would you want untagged unions?
17:26:29 * hackagebot bittorrent 0.0.0.2 - Bittorrent protocol implementation.  http://hackage.haskell.org/package/bittorrent-0.0.0.2 (SamTruzjan)
17:28:27 <yogurt_truck> Peaker: am I using the term wrongly? I didn't mean anything complicated, just being able to express "x: A|B|C" where A B and C are not related to each other (i.e. not constructors of an ADT, which is scala are achieved through inheritance) in any sense
17:28:36 <zardoz`> is there already a function that reads directory tree before I start rolling my own?
17:29:09 <Iceland_jack> zardoz`: There is some stuff on Hackage
17:29:10 <heatsink> A function that walks a directory tree and reads all the filenames into a data structure?
17:29:25 <heatsink> There is a directory-tree package
17:29:26 <Peaker> yogurt_truck: that's not an "untagged union".  Do you know "union" in C?
17:29:38 <zardoz`> heatsink a one dimensional list of files will do
17:29:55 <Peaker> yogurt_truck: That's a polymorphic variant, or I call it "anonymous sum"
17:30:07 <yogurt_truck> Peaker: I assumed that since they're not tagged unions, and they're still an union, then they were untagged unions :D but I must be wrong
17:30:26 <zardoz`> Iceland_jack know any keywords I can google?
17:30:30 <yogurt_truck> Peaker: ah. that
17:30:30 <Peaker> yogurt_truck: the "tag" refers to distinguishing at runtime which of the cases (A or B or C) it is
17:30:34 <heatsink> To be an anonymous sum, doesn't it need a tag in {1,2,3} to say which case it is?
17:30:46 <Iceland_jack> zardoz`: You can check out <heatsink> There is a directory-tree package
17:30:53 <Iceland_jack> Other than that “directory tree hackage”
17:31:02 <zardoz`> ah missed it. thanks
17:31:11 <yogurt_truck> Peaker: well, that's what I was doing
17:31:18 <Peaker> yogurt_truck:    union { A a; B b; C c; } <-- untagged union.     enum tag { tagA, tagB, tagC }; struct { enum tag t; union { A a; B b; C c; }; };  <-- tagged union
17:32:00 <Peaker> yogurt_truck: data Maybe a = Nothing | Just a  <-- named sum-type.    x :: (Nothing | Just a)    x is a value of an anonymous sum type
17:32:05 <Peaker> (or a polymorphic variant)
17:32:24 <zardoz`> writeDirectory$ "/home" :/ Dir "Tux" [File "README" "Welcome!"]
17:32:26 <zardoz`> that is cool!
17:32:32 <heatsink> I thought you were asking for a reference to (A ∪ B ∪ C), which can be done in Java since each object is tagged with its type
17:32:44 <heatsink> so no extra tag is necessary
17:32:53 <yogurt_truck> Peaker: `union { A a; B b; C c; }` is what I was doing with scala
17:33:02 <Peaker> heatsink: then it is already intrinsically tagged
17:33:04 <yogurt_truck> Peaker: but it's awfully unsafe
17:33:24 <Peaker> yogurt_truck: could you reinterpret/read A as if it were a B?
17:34:08 <yogurt_truck> heatsink: can Java do that? `(A ∪ B ∪ C)` ? and check properly the body of the function at compile time?
17:35:16 <yogurt_truck> Peaker: yeah. in an unsafe reflection-y way
17:35:31 <heatsink> Java doesn't enforce that type precisely.  I just meant that Java lets you use the LUB of the types and downcast dynamically.
17:36:06 <Peaker> yogurt_truck: anyway, what we both hate about Scala is that it auto-casts up to the super-class, making stuff of silly types
17:36:30 <Peaker> yogurt_truck: I also hate that Scala only climbs up an arbitrary class hierarchy, and I want to "climb up" to whatever sum I need at that position
17:39:05 <zardoz`> @src filterM
17:39:05 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:41:45 <yogurt_truck> Peaker: it's a fairly fat type system.
17:41:49 <yogurt_truck> lots of stuff I like. lots of stuff I dislike. lots of stuff I misunderstand or haven't heard about.
17:45:23 <yogurt_truck> Peaker: at some point I had moments where trying to implement a foo(A|B|C) with a normal algebraic type would get me into some combinatorics-feeling situation, because (A|B|C) is not the same as (C|B|A), plus some values might be something like "A with C", etc.
17:45:31 <yogurt_truck> and so it was like I would have to implement a billion things to have it work
17:45:36 <yogurt_truck> but in the end implicit conversions saved the day :D
17:46:58 <neverwearcondoms> who is haskell?
17:47:26 <jle`> prof. curry?
17:47:46 <yogurt_truck> neverwearcondoms: a kickass mathematician
17:47:48 <RichyB> Haskell is a programming language that is named after a mathematician called "Haskell Curry". http://en.wikipedia.org/wiki/Haskell_Curry
17:48:52 <pavonia> @faq Can Haskell please tell neverwearcondoms who he is?
17:48:53 <lambdabot> The answer is: Yes! Haskell can do that.
17:49:15 <neverwearcondoms> so can we cook curry using haskell?
17:49:22 <frx> grok22 use zip then pass the resulting list to map
17:49:30 <frx> > zip [0..] "foobar"
17:49:32 <lambdabot>   [(0,'f'),(1,'o'),(2,'o'),(3,'b'),(4,'a'),(5,'r')]
17:50:52 <grok22> frx: thanks!
17:50:58 <frx> welcome
17:51:02 <neverwearcondoms> it's interesting... all the nerds i've seen marry such ugly girls
17:51:22 <neverwearcondoms> is that a popular trend in nerd-dom?
17:53:04 <zardoz`> it is annoying how I can't use fmap on Monad
17:56:09 <merijn> zardoz`: Fortunately, there is currently a proposal in progress to remedy this (i.e. make Functor a superclass of Monad)
17:56:35 <merijn> zardoz`: Although it'll be at least 1 or 2 GHC releases away
17:57:04 <zardoz`> merijn that is nice
17:57:09 <heatsink> How do they do that without breaking existing library code?
17:57:57 <Peaker> heatsink: they break it very very carefully
17:58:09 <merijn> heatsink: See details here: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
17:58:37 <zardoz`> as far as I can see it would only break Monad instances that also don't implement Functor. which is a good thing :)
17:58:56 <Peaker> augustuss already did this for Mu Haskell, and said the breakage was minor, and IIRC mostly around "join" becoming a method so in everybody's namespace
18:00:53 <heatsink> So nonconforming code will produce GHC warnings for a while
18:00:58 <heatsink> That's pretty nice
18:06:29 <zardoz`> wasn't there some library that implements a monadic version of all Data.List functions that are missing in Control.Monad.  for example I need partitionM
18:07:33 <Tordek> is there a default collection of locales to use for old-locale, or do I have to define my own?
18:07:35 <Peaker> partitionA, maybe? :P
18:07:46 <Peaker> (It doesn't require Monad, just Applicative)
18:08:03 <zardoz`> Peak I see! yes that work too
18:08:23 <Peaker> zardoz`: I don't think it exists, I just meant it's not monadic.. Most of Control.Monad is actually Applicative and not Monadic
18:08:31 <Peaker> (but implemented monadically for historical raisings)
18:08:56 <zardoz`> I understood. I didn't know it could be implemented as Applicative
18:11:33 * hackagebot word24 1.0.4 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.4 (JohnLato)
18:19:18 <frx> is there something like this? cons :: (a, b) -> [(a, b)] -> [(a, b)]
18:20:23 <scshunt> frx: :
18:20:32 <scshunt> :t (:)
18:20:34 <frx> sorry, I meant
18:20:34 <lambdabot> a -> [a] -> [a]
18:20:49 <frx> consPair :: (a, b) -> ([a], [b]) -> ([a], [b])
18:21:14 <joelteon> @pl \(x,y) (xs,ys) -> (x:xs, y:ys)
18:21:14 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (:)) . flip . (((.) . (,)) .) . (:))
18:21:27 <scshunt> there you go
18:21:32 <frx> lol thanks
18:21:50 <Peaker> :t (:) *** (:)
18:21:51 <lambdabot> (a, a1) -> ([a] -> [a], [a1] -> [a1])
18:45:17 <grok23> is "do { (a,b,c) <- foo; return a }" valid syntax for function foo that returns a 3-tuple
18:46:47 <ion> No, but it is if foo is a monadic action that results in a 3-tuple.
18:46:49 <zardoz`> it is valid if it returns 3-tuple in a monadic context.. like IO (a,b,c)
18:46:51 <simpson> grok23: If foo is in some Monad, then sure.
18:47:09 <ion> “let (a,b,c) = foo in a” if foo is just a 3-tuple and not an action.
18:48:27 <zardoz`> > let maybeTuple = Just (1,2,3) in do { (a,b,c) <- maybeTuple; return a }
18:48:29 <lambdabot>   Just 1
18:48:38 <zardoz`> let maybeTuple = Nothing in do { (a,b,c) <- maybeTuple; return a }
18:48:43 <zardoz`> > let maybeTuple = Nothing in do { (a,b,c) <- maybeTuple; return a }
18:48:44 <lambdabot>   Nothing
18:50:24 <grok23> ion, simpson, zardoz`: thanks :)
18:56:37 * hackagebot word24 1.0.5 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.5 (JohnLato)
19:15:37 <zardoz`> why is when in Control.monad `Bool -> m () -> m ()'   and not `Bool -> m a -> m a' ?
19:16:25 <amosr> zardoz`: what would it return on 'False' case?
19:16:47 <amosr> zardoz`: perhaps it should be "Bool -> m a -> m (Maybe a)"
19:17:09 <zardoz`> oh I misunderstood what it does. I actually was looking for ifM
19:18:09 <zardoz`> in other words:  ifM :: Monad m => Bool -> m a -> m a -> m a
19:18:30 <mm_freak> zardoz`: you have that one
19:18:31 <amosr> ah, that makes sense
19:18:39 <mm_freak> zardoz`: it's called 'if' =)
19:19:01 <mm_freak> :t if True then Just "blah" else Nothing
19:19:03 <lambdabot> Maybe [Char]
19:19:06 <zardoz`> ok let's try again :)
19:19:26 <zardoz`> I want:  ifM :: Monad m => m Bool -> m a -> m a -> m a
19:19:43 <zardoz`> so yeah.. totally not like when
19:20:10 <mm_freak> it's probably in some package somewhere, but it's easy enough to define for yourself
19:20:49 <mm_freak> :t \c x y -> do b <- c; if b then x else y
19:20:50 <lambdabot> Monad m => m Bool -> m b -> m b -> m b
19:21:17 <mm_freak> zardoz`: note that if your monad is an Alternative you get a better abstraction than ifM
19:21:27 <mm_freak> > Just 3 <|> Just 4
19:21:29 <lambdabot>   Just 3
19:21:32 <mm_freak> > Nothing <|> Just 4
19:21:33 <lambdabot>   Just 4
19:21:48 <zardoz`> nice
19:31:59 <mirpa> I have types A, B, C... and I want another type (X) which contains value of A or B or C or ... (something like union in C). Do I have to make A, B, C... data constructors of X? Like data X = A | B | C ... I am parsing file which contains different kinds of 'nodes' and I want a list of these nodes.
19:38:16 <pavonia> mirpa: You have to introduce new data constructors too, like data X = XA A | XB B | XC C | ...
19:39:16 <mirpa> pavonia: yes, but can I keep A, B, C... as separate types (not only type constructors)?
19:39:53 <monochrom> A, B, C are already separate types. what do you mean?
19:40:33 <mirpa> data X = XA A | XB B ... and then data A = A; data B = B ... is this valid?
19:40:55 <pavonia> sure
19:41:02 <mirpa> thx
19:41:12 <monochrom> it is valid but I doubt you want A to be as simplistic as "data A = A"
19:41:21 <zardoz`> how can I make this function lazy?  http://lpaste.net/95963
19:42:17 <mirpa> yes, I tried to be brief
19:42:57 <zardoz`> I have to delay execution of `mapM getAllFiles dirs' somehow. is that even possible?
19:44:19 <pavonia> unsafeInterleaveIO perhaps?
19:46:07 <zardoz`> nice
19:46:15 <zardoz`> am I abusing that function though?
19:46:29 <zardoz`> it seems like a good use of it, but unsafe prefix makes me think twice
19:47:42 <pavonia> not sure, never used it myself
19:48:20 <zardoz`> it seems to work fine
19:50:05 <johnw> zardoz`: yes, if you need that function to be lazy, that's exactly what unsafeInterleaveIO is for
19:50:22 <zardoz`> great :)
19:51:08 <johnw> mind you, conduits or pipes is a better choice
19:51:19 <johnw> in fact, filesystem-conduit will do just what that function does
19:51:43 <zardoz`> I got the feeling I was reinventing the wheel.. I will check it out
19:51:48 <zardoz`> thanks
19:52:36 <skirmish> @pl \xs -> zip xs (tail xs)
19:52:37 <lambdabot> ap zip tail
19:56:44 <oio> which libraries for sending emails would you recommend?
19:57:06 <johnw> i like mime-mail
19:58:42 <zardoz`> just wondering how would one handle something like this in haskell.. above function that fetches all the files in the directory tree may throw an exception if I try to read directory without permission to do so.. so where do I catch exception? if I do it in that function caller will not be aware that error took place. and if I do it outside of it then I can't continue traversing the directory
19:59:03 <zardoz`> something like restartable exceptions would be nice
19:59:57 <johnw> you could return [(FilePath, Either Error [FilePath])] for each directory in the traversal
20:00:58 <frx> or take handleError function that receieves thrown error
20:01:28 <oio> @johnw: will look
20:01:28 <lambdabot> Unknown command, try @list
20:01:40 --- mode: johnw set -o johnw
20:02:17 --- mode: ChanServ set +o johnw
20:02:25 <zardoz`> I got another either: returning [Either Error FilePath]
20:02:43 * shapr grins at johnw 
20:02:55 <johnw> didn't realize I'd been op'd since last night
20:03:04 <shapr> look, you have ops AGAIN!
20:03:11 --- mode: johnw set -o johnw
20:03:14 * shapr grins
20:05:27 <zardoz`> haskell supports continuations, right? just out of curisoity, could I emulatate restartable conditions from CL with them?
20:05:57 <johnw> that's how conduit works
20:06:10 <johnw> Haskell doesn't need any special language support for continuations, btw
20:06:16 <johnw> they are just functions
20:06:19 <c_wraith> well.  Haskell supports *delimited* continuations, which are really just functions.  It does not support undelimited continuations, like scheme does
20:06:24 <johnw> it's the laziness that makes them nice to use in Haskell
20:06:36 <johnw> yes, what c_wraith said, thanks for the clarification
20:07:01 <maxiepoo> yeah but undelimited continuations are pretty useless as any schemer would tell you
20:07:53 <c_wraith> zardoz`: and yes, you could emulate restartable conditions with them
20:07:58 <carter> well yeah, 'cause no one knows quite what undeliminated continuations mean!
20:08:12 <carter> like what does that mean when you use them in the repl?
20:08:32 <c_wraith> that sounds like something terrifying.  Don't do that. :)
20:11:15 <joelteon> does hackage allow me to change my password?
20:11:37 <mm_freak> zardoz`: you can implement even more advanced control concepts
20:11:41 <mm_freak> @hackage continue
20:11:41 <lambdabot> http://hackage.haskell.org/package/continue
20:14:48 <carter> joelteon: ask on #hackage
20:15:53 <zardoz`> mm_freak interesting!
20:16:19 <TallerGhostWalt> yeah that continue library is cool
20:17:11 <mm_freak> it's motivated by this code:  http://lpaste.net/79601
20:17:24 <mm_freak> see the main action and the example interaction at the bottom
20:18:13 <TallerGhostWalt> what about
20:18:25 <TallerGhostWalt> pulling bytes over a serial port
20:19:12 <TallerGhostWalt> I can pull 240 bytes at a time but have data that 1kb or 2kb right now I just run the handshaking manually and use the Data.Binary lib to make a parser on the bytestring
20:19:26 <TallerGhostWalt> But boy it would be neat to have something that could start and stop a parse
20:20:24 <mm_freak> TallerGhostWalt: attoparsec supports incremental parsers…  but of course it's not a serialization library
20:20:48 <TallerGhostWalt> mm_freak: Yeah I started there
20:21:05 <TallerGhostWalt> But found Data.Binary was easier?
20:21:18 <TallerGhostWalt> for the app I mean
20:21:18 <TallerGhostWalt> not in general
20:21:22 <TallerGhostWalt> But now I don't remember why!
20:21:24 <TallerGhostWalt> hehe
20:22:07 <derekv> () is called 'unit' because of something to do with lambda calculus I imagine?
20:22:40 <mm_freak> derekv: it's the type with one element
20:22:55 <carter> its like 1
20:22:57 <carter> Void is like 0
20:22:59 <mm_freak> derekv: algebraically the type is called 1
20:23:11 <carter> x times 0 = 0
20:23:18 <carter> x plus 0  = x
20:23:37 <carter> x times 1 = x
20:23:43 <carter> x + 1 = 1 + x
20:23:44 <carter> :)
20:23:49 <mm_freak> if you call Either "+", then:  1 + 1 = 2
20:23:53 <carter> yes
20:24:02 <derekv> ok, that was my next question
20:24:03 <carter> well
20:24:05 <mm_freak> because Either () () has exactly two (defined) elements
20:24:13 <carter> mm_freak: it has more!
20:24:18 <carter> the Bottoms haunt it
20:24:22 <carter> 'cause Either isn't strict :)
20:24:27 <mm_freak> carter: see the "(defined)"
20:24:30 <carter> oh
20:24:33 <carter> hehe
20:24:50 <derekv> what is 'times' in this type algebra then?
20:24:56 <mm_freak> derekv: (,)
20:25:29 <carter> (,) a b = (a,b)
20:25:42 <mm_freak> (1 + 1) * (1 + 1) ≃ (Either () (), Either () ())
20:28:37 <mm_freak> derekv: exercise:  what's the algebraic representation of 'Maybe Word8'?
20:29:34 <johnw> @pl mfilter (const x) y
20:29:34 <lambdabot> mfilter (const x) y
20:30:05 <johnw> @pl \x y -> mfilter (const x) y
20:30:05 <lambdabot> mfilter . const
20:30:39 <derekv> hmm, Nothing + Just Word8 ?
20:30:49 <derekv> not sure
20:30:56 <johnw> what is Nothing equivalent to?
20:31:30 <teneen> when should I use Control.Parallel.Strategies and when should I use monad-par?
20:31:32 <derekv> johnw: I was just thinking of it as a special symbol.
20:31:39 <mm_freak> derekv: if x = 5, then Maybe x = ?
20:31:57 <mm_freak> note:  Maybe is isomorphic to Either ()
20:32:02 <augur> hmm hmm
20:32:03 <johnw> derekv: it's a "single distinguished value", which has a mathematical name
20:33:06 <augur> class Conjoinable a where conjoin :: a -> a -> a    instance Conjoinable b => Conjoinable (a -> b) where conjoin f g x = conjoin (f x) (g x)
20:33:15 <mm_freak> derekv: how many elements does () have?
20:34:12 <derekv> mm_freak: 0
20:34:17 <mm_freak> derekv: wrong
20:34:18 <carter> 1
20:34:22 <carter> welll
20:34:23 <carter> 2
20:34:25 <carter> :)
20:34:25 <derekv> so I'm confused
20:34:25 <mm_freak> 1
20:34:32 <carter> () == UNIT
20:34:36 <mm_freak> derekv: the type () has one element:  ()
20:34:44 <derekv> Oh
20:34:53 <derekv> well damn
20:34:58 <mm_freak> derekv: how many elements does Maybe () have?
20:34:58 <derekv> I get it =]
20:35:02 <augur> () is the type of tuples with no elements!
20:35:14 <augur> (a) is the type of tuples with one element of type a!
20:35:15 <razieliyo> oh monads, I'm starting to get them
20:35:17 <augur> (a) aka a!
20:35:29 <carter> augur: i thought we had no (a)
20:35:30 <slack1256> in the old day we used to call that the empty set
20:35:31 <razieliyo> (>>=) :: IO a -> (a -> IO b) -> IO b  -----> it's clear now!
20:35:33 <carter> only (Only a)
20:35:38 <slack1256> but no you type theorist had to change the world
20:35:39 <johnw> razieliyo: haha
20:35:40 <carter> @hoogle Only
20:35:41 <lambdabot> package only
20:35:41 <lambdabot> package fast-tagsoup-utf8-only
20:35:41 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors FixedOnly :: ClampMode
20:35:46 <mm_freak> slack1256: but () is not empty
20:35:47 <johnw> razieliyo: I can't even tell if you're being facetious
20:35:48 <carter> @hackage only
20:35:48 <lambdabot> http://hackage.haskell.org/package/only
20:35:52 <augur> carter: (a) == a afaik
20:35:57 <slack1256> now everything I knew is false
20:36:06 <augur> mm_freak: definitionally, i mean. (a) is just useless parens around a
20:36:07 <razieliyo> so IO is a monad made for being able to make things like, what's yur name? peter, hello peter, like the haskellwiki says
20:36:08 <augur> i think..
20:36:16 <mm_freak> slack1256: we still have the empty set/type, but () is not it =)
20:36:25 <razieliyo> johnw: haha not being sarcasting
20:36:31 <derekv> mm_freak: so Maybe () has Nothing and it has Just ()
20:36:40 <sellout-> So, is the LANGUAGE pragma generally preferred over putting a list of extensions in your cabal file?
20:36:43 <td123> mm_freak: by elements, you mean data constructors?
20:36:45 <mm_freak> derekv: and that's a total of …?
20:36:50 <mm_freak> td123: no, possible values
20:36:53 <derekv> 2
20:36:59 <td123> mm_freak: oh
20:37:08 <derekv> there's only one "Just ()"
20:37:08 <razieliyo> johnw: well, I still don't get what a monad is, but the type of that operator explains too much about it
20:37:21 <carter> http://hackage.haskell.org/package/postgresql-simple-0.3.7.1/docs/Database-PostgreSQL-Simple.html#t:Only
20:37:22 <razieliyo> I'm just starting to get them haha
20:37:23 <mm_freak> derekv: 2 is correct
20:37:29 <razieliyo> I'm reading an IO tut on haskellwiki
20:37:31 <carter> newtype Only a= Only a
20:37:33 <slack1256> well if you start constructing number from sets
20:37:39 <mm_freak> derekv: so algebraically you can think of Maybe as:  Maybe x = x + 1
20:37:42 <slack1256> one can be written as {∅}
20:37:56 <razieliyo> when I fully get IO, I'll get into monads
20:37:56 <slack1256> which is awfully similar to ()
20:37:58 <td123> mm_freak: so a 1 tuple (a) would have n elements where n = the number of data constructors for the type a?
20:38:01 <mm_freak> derekv: now you can tell me how many elements Maybe Word8 has =)
20:38:12 <razieliyo> an btw, I think I found a case when I was coding that something like Maybe could serve to me
20:38:21 <mm_freak> derekv: Word8 is the type for integers between 0 and 255
20:38:33 <derekv> mm_freak: because it has  all the elements of x, and then one more...  so that'd be something like 2^8 +1
20:38:43 <mm_freak> derekv: exactly =)
20:38:43 <augur> razieliyo: you should read my IO tutorial. at least, if you understand some JS
20:38:54 <razieliyo> I still don't get Maybe at all, but I think Maybe is getting clearer to me
20:39:06 <augur> razieliyo: Maybe is easy!
20:39:18 <razieliyo> Maybe is.... well... Maybe!
20:39:26 <razieliyo> Maybe or Maynot
20:39:29 <razieliyo> or Nothing
20:39:36 <mm_freak> derekv: final and most difficult exercise:  how many elements does 3 -> 4 have?
20:39:43 <sellout-> razieliyo: Maybe is for those cases where you’d like to allow a null pointer (if that’s your background)
20:39:44 <razieliyo> augur: don't still get what it really means
20:39:49 <augur> Maybe a should be thought of as the "silent failure" widget
20:39:53 <razieliyo> sellout-: it is =D
20:40:04 <razieliyo> so, Nothing is a null pointer?
20:40:06 <johnw> mm_freak: there's a really great chapter in Lawvere's "Conceptual Mathematics" book about that
20:40:22 <augur> razieliyo: no, dont listen to sellout-, its not a pointer at all
20:40:25 <mm_freak> johnw: wasn't aware of that, thanks =)
20:40:26 <razieliyo> what's the thing between Maybe and Nothing
20:40:26 <carter> 3^4
20:40:33 <carter> sooo… 9^2
20:40:36 <carter> sooo… 81?
20:40:37 <sellout-> augur: I’m not saying it’s a pointer.
20:40:47 <augur> razieliyo: the closest analogy is in math sublibs, where you have NaN
20:40:49 <mm_freak> carter: wrong, and if you know it, allow derekv to solve it =)
20:40:55 <carter> ok
20:40:57 <carter> i'm tired
20:40:58 <carter> ignore me
20:41:17 <augur> razieliyo: NaN is a kind of "un-number" that you can apply math ops to, but which "leaks" up, turning everything into NaN
20:41:42 <augur> razieliyo: NaN is kind of like Nothing
20:41:42 <sellout-> razieliyo: In pointery languages, you can either have some object or not, and if you want to disallow the not, you have to check that the pointer isn’t null. Well, in Haskell, by default, the not isn’t there, so if you want it, you need a Maybe.
20:41:55 <derekv> mm_freak: a function which takes 3 and returns 4... there's only one way to do that, that isn't silly, but i'm not sure I'm reading that correctly
20:41:57 <razieliyo> okay, so let's see I have an app where I have a function that MAY not return anything, so I can return Maybe and then, treat Maybe case special
20:42:15 <augur> razieliyo: you mean the Just case
20:42:17 <mm_freak> derekv: let me ask differently:  how many values of type 3 -> 4 are there?
20:42:37 <razieliyo> augur: lots of meanings, this is like starting to read
20:42:38 <augur> razieliyo: but yes, Maybe a means "maybe it's an `a`, or maybe it's nothing at all"
20:42:49 <razieliyo> so, it's a higher order monad
20:42:52 <razieliyo> haha
20:42:55 <augur> razieliyo: ignore sellout-'s explanation, its not a good one
20:42:57 <mm_freak> derekv: if you still have trouble, ask yourself:  what are the values of type 3 -> 4?
20:42:58 <augur> no its not a higher order monad at all
20:43:02 <augur> forget the monad-ness of it
20:43:03 <sellout-> augur: :P
20:43:11 <razieliyo> well, yes, you're right, it doesn't convert a monad into nothing
20:43:20 <augur> razieliyo: consider writing a math library, ok. thats the best example
20:43:21 <derekv> mm_freak: i'm just imagining an infinate number of functions.
20:43:22 <razieliyo> aw, forget about my last sentence
20:43:26 <razieliyo> augur: yea
20:43:35 <mm_freak> derekv: the number of functions is not infinite =)
20:43:38 <augur> razieliyo: you can write add all nice, right. add :: Int -> Int -> Int
20:43:38 <frx> pointer analogy is not bad. a pointer can point to an object, or to NULL. Maybe Int can be (Just 10) or Nothing
20:43:57 <augur> razieliyo: fine thats easy, but what about division? blegh. div :: Int -> Int -> ???
20:43:59 <lispy> The way you compare functions matters, too right?
20:44:08 <mm_freak> derekv: feel free to think of functions as tables =)
20:44:13 <augur> razieliyo: what should it return when you divide by zero?
20:44:14 <razieliyo> Float? Double?
20:44:18 <razieliyo> haha
20:44:20 <razieliyo> Nothing
20:44:21 <sellout-> frx: Thank you. It’s a very good analogy for someone coming from that world.
20:44:21 <derekv> mm_freak: ok right, i was getting there
20:44:22 <lispy> intentional version extensional equality, for instance
20:44:23 <razieliyo> it should return Nothing
20:44:25 <razieliyo> omg
20:44:27 <razieliyo> OMG
20:44:30 <augur> razieliyo: right, so div :: Int -> Int -> Maybe Int
20:44:35 <razieliyo> THAT WAS THE CASE I THINK
20:44:46 <augur> razieliyo: lets look at lists
20:44:52 <razieliyo> I had to make log(0)
20:45:00 <razieliyo> for a case on my id3 algorithm
20:45:04 <augur> head :: [a] -> ???
20:45:09 <augur> head should return the first element of a list
20:45:09 <derekv> mm_freak: so there's only one function with as many implementations as you care to come up with
20:45:11 <augur> but what is head []?
20:45:25 <razieliyo> hmmm
20:45:33 <razieliyo> Maybe [a]?
20:45:40 <augur> razieliyo: we can pick that, indeed
20:45:47 <augur> well, Maybe a
20:45:48 <augur> head :: [a] -> Maybe a
20:45:51 <augur> head [] = Nothing
20:45:53 <mm_freak> derekv: no, there are multiple functions…  you're getting one of three elements as input and mapping each to one of four results
20:45:54 <augur> head (x:xs) = Just x
20:46:02 <mm_freak> derekv: now think of this as arrays
20:46:19 <mm_freak> one function maps A to 0, B to 0 and C to 0
20:46:20 <augur> razieliyo: similarly for tail, which returns the rest of the list
20:46:21 <mm_freak> one function maps A to 0, B to 0 and C to 1
20:46:24 <augur> razieliyo: does that make sense?
20:47:04 <razieliyo> wait
20:47:06 <razieliyo> I'm processing
20:47:16 <augur> tail :: [a] -> Maybe [a]
20:47:19 <augur> tail [] = Nothing
20:47:19 <mm_freak> derekv: in that sense you can think of each function as an array of three elements:  [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, 1, 0], …
20:47:23 <augur> tail (x:xs) = Just xs
20:47:26 <augur> razieliyo: just to be clear
20:47:29 <razieliyo> fine, I get the maybe
20:47:31 <razieliyo> and the nothing
20:47:36 <razieliyo> but I'm a bit hard with the Just
20:47:42 <augur> razieliyo: Maybe is the name of the type
20:47:45 <razieliyo> oh pokay
20:47:47 <augur> Nothing is one value in the type
20:47:51 <derekv> mm_freak: ok I think I was a bit confused by what you meant by 3 -> 4 ... you mean a type of size 3 to a type of size 4
20:47:52 <augur> Just is another value in the type
20:47:58 <razieliyo> so tail (x:xs) Just xs is that it acts justs when xs exists
20:48:00 <augur> razieliyo: or i should say, Just x is a value in the type
20:48:00 <razieliyo> isn't it?
20:48:02 <mm_freak> derekv: yeah
20:48:30 <augur> razieliyo: i feel like you might not understand ADTs properly
20:48:48 <frx> :t Just 10
20:48:50 <lambdabot> Num a => Maybe a
20:48:51 <derekv> mm_freak: 4^3
20:48:57 <mm_freak> derekv: correct =)
20:49:06 <derekv> mm_freak: \o/
20:49:09 <augur> razieliyo: have you read lyah at all?
20:49:12 <radish> map print [1..10] -- no idea how to implement this lol
20:49:24 <derekv> mm_freak: thats a cool tutorial
20:49:30 <radish> one of the hardest challenges to date lol
20:49:33 <frx> radish that works
20:49:38 <maxiepoo> >mapM print [1..10]
20:49:39 <frx> radish it gives you a list of IO actions
20:49:43 <radish> frx: it doesn't seem to work... :(
20:49:52 <maxiepoo> > mapM print [1..10]
20:49:53 <lambdabot>   <IO [()]>
20:49:55 <mm_freak> derekv: now you know exactly how many functions there are of type Maybe Bool -> Either Bool Bool =)
20:49:55 <frx> radish you can execute a list of actions with sequence
20:49:56 <radish> maxiepoo: what is mapM?
20:49:57 <razieliyo> augur: I'm on it, I've not finished it but I'm starting to use haskell to implement algorithms
20:50:02 <frx> @src mapM
20:50:02 <lambdabot> mapM f as = sequence (map f as)
20:50:13 <augur> razieliyo: ok, so them im not entirely sure what youre asking, but
20:50:27 <augur> razieliyo: lets be clear:   data Maybe a = Nothing | Just a
20:50:30 <frx> so  sequence (map print [1..10])   which is the same as  mapM print [1..10]
20:50:32 <mm_freak> Bool = 2, so Maybe Bool = 2 + 1 = 3 and Either Bool Bool = 2 + 2 = 4
20:50:54 <augur> razieliyo: this declares a new type operator Maybe, and two constructors for it, Nothing :: Maybe a, and Just :: a -> Maybe a
20:51:07 <razieliyo> augur: fine
20:51:17 <radish> @sequence
20:51:18 <lambdabot>  Sequence not found.
20:51:22 <frx> radish sequences executes every action in a list and combines them to one IO action
20:51:23 <augur> razieliyo: so the definition for head :: [a] -> Maybe a
20:51:29 <frx> @src sequence
20:51:29 <lambdabot> sequence []     = return []
20:51:29 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:51:29 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
20:51:45 <augur> razieliyo: just says, if the list is empty, i give back Nothing, but if the list isnt empty, and instead looks like (x:xs), i give back Just x
20:51:47 <razieliyo> augur: fine, I remember all the writing above
20:51:47 <frx> (if argument is IO that is)
20:51:57 <razieliyo> okay okay
20:52:03 <augur> razieliyo: similarly tail.
20:52:07 <razieliyo> so augur, is that just a kind of giving meaning to things?
20:52:13 <augur> razieliyo: what do you mean
20:52:14 <radish> frx: i'm not less confused but at least i can write code that works now lol
20:52:21 <razieliyo> I mean the use of maybe, nothing and just
20:52:34 <razieliyo> or the way to avoid exceptions haha
20:52:34 <augur> radish: whats to be confused about!
20:52:44 <radish> razieliyo: you either have something of a type, or nothing at all (which is different than say 0)
20:52:49 <augur> razieliyo: the meaning is in the type declaration
20:53:01 <radish> razieliyo: it's kind of like null
20:53:07 <augur> radish: no dont go there
20:53:19 <radish> augur: you're absolutely right i'm sorry
20:53:40 <razieliyo> okay, I get it
20:53:44 <radish> augur: it's often used to deal with the possibility of null when linking in c++ code though, right?
20:54:08 <radish> razieliyo: it's a structure which can contain two types, either something (Just) or Nothing.
20:54:19 <razieliyo> okay okay, I was overseeing the fact that Maybe is at type definition and Nothing & Just at the real definition of the function
20:54:29 <radish> razieliyo: if it contains something, you have to say what it contains
20:54:34 <augur> razieliyo: i dont know what that sentence means
20:54:48 <radish> razieliyo: you're getting it
20:55:29 <razieliyo> I was thinking of Maybe, Just and Nothing being all types or sth like that
20:55:30 <radish> Maybe type is either Just type or Nothing, so Maybe number could be say Just 1, or Just 0, or Nothing
20:55:38 <augur> razieliyo: oh, no.
20:55:46 <augur> Maybe a is a type (provided a is a type!)
20:55:48 <mm_freak> derekv: one final note:  i pretended that bottom does not exist
20:55:52 <zardoz`> `Maybe a' is a type, `Just x' and Nothing are the values of that type
20:55:53 <augur> Nothing and Just are the constructors for the type
20:55:55 <razieliyo> haha
20:55:57 <radish> razieliyo: sometimes i long for () to be Nothing...
20:56:05 <razieliyo> so, what makes Maybe be a monad?
20:56:06 <mm_freak> derekv: in haskell () actually has two elements, but we often pretend that it has only one
20:56:11 <augur> razieliyo: ok so thats a separate issue
20:56:14 <razieliyo> oh, wait
20:56:16 <razieliyo> yes
20:56:22 <augur> razieliyo: lets look at how we use Maybe
20:56:37 <razieliyo> augur: yes, I got it
20:56:38 <augur> razieliyo: ok, so lets say we're defining our little math library
20:56:52 <derekv> mm_freak: () and -()    :P
20:57:00 <mm_freak> derekv: () and ⊥ =)
20:57:03 <augur> razieliyo: (+) :: Int -> Int -> Int,   (-) :: Int -> Int -> Int,  (*) :: Int -> Int -> Int,   (/) :: Int -> Int -> Maybe Int
20:57:08 <augur> razieliyo: so (/) has a different type
20:57:24 <augur> razieliyo: ok, well, now lets write some math!
20:57:24 <mm_freak> :t (let w = w in w) :: ()
20:57:25 <lambdabot> ()
20:57:27 <razieliyo> divide :: (Num a) => a -> a -> Maybe a, divide x 0 = Nothing, divide x y = Just (x/y)
20:57:32 <augur> razieliyo: 1 + (2 * 3)  -- fine
20:57:35 <radish> augur: best example ever
20:57:36 <augur> razieliyo: hmm how about
20:57:42 <augur> razieliyo: 2 + (3 / 4)
20:57:44 <razieliyo> I'm reading
20:57:47 <augur> oh dear, type error!
20:57:55 <razieliyo> yeah, augur okay
20:58:03 <augur> 3 / 4 :: Maybe Int   but (+) needs an Int! :(
20:58:21 <razieliyo> yes... I got some type errors when coding something, I had to make my own casting functions
20:58:26 <augur> wouldn't it be nice if instead we had written (+) :: Maybe Int -> Maybe Int -> Maybe Int?
20:58:34 <razieliyo> haha
20:58:37 <augur> and made _everything_ like this?
20:58:39 <augur> yes, it would!
20:58:54 <radish> augur: that's dastardly sir
20:58:59 <augur> but its an awful headache to have to case on all of these maybes everywhere, horrible
20:59:04 <augur> Nothing + Nothing = Nothing
20:59:08 <augur> Nothing + Just y = Nothing
20:59:11 <augur> Just x + Nothing = Nothing
20:59:18 <razieliyo> so, augur, the power of Maybe is using it in your code, and I guess it's not been implemented at base for giving a plain language that you can model
20:59:20 <augur> Just x + Just y = Just (primitiveAdd x y)
20:59:25 <augur> gag
20:59:31 <mm_freak> to be fair:  Just x + Just y = Just (x + y);  _ + _ = Nothing
20:59:34 <razieliyo> reading
20:59:40 <augur> mm_freak: hush you
20:59:46 <mm_freak> sorry =)
20:59:51 <radish> augur: you're poisoning my feeble mind with ugly truths i can't read this anymore i'm gonna have an aneurysm...
20:59:54 <augur> stop ruining my point by making it less ugly
20:59:58 <derekv> :t (let w = 2 in w)
20:59:58 <mm_freak> it's still a pain =P
20:59:59 <lambdabot> Num a => a
21:00:05 <derekv> :t (let w = z in w)
21:00:06 <lambdabot> Expr
21:00:10 <razieliyo> augur: continue
21:00:23 <derekv> :t (let weird = weird in weird)
21:00:24 <lambdabot> t
21:00:49 <razieliyo> derekv: brainf*ck
21:00:53 <augur> razieliyo: so what we do is we abstract the pattern. liftMaybe :: (a -> b) -> Maybe a -> Maybe b
21:01:07 <derekv> :t (let wat = wat in wat)
21:01:07 <augur> razieliyo: liftMaybe f Nothing = Nothing ; liftMaybe f (Just x) = Just (f x)
21:01:07 <lambdabot> t
21:01:14 <razieliyo> augur: oh, that was a good one, wait, my CPU is taking its time
21:01:19 <augur> razieliyo: that will let us define negation, at least
21:01:32 <augur> razieliyo: and also:   liftMaybe2 :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
21:01:42 <mm_freak> augur: no
21:01:54 <augur> liftMaybe2 f (Just x) (Just y) = Just (f x y) ; liftMaybe2 f _ _ = Nothing
21:01:59 <augur> mm_freak: shhhhhhhhhhh
21:02:02 <razieliyo> augur: so, are lifts implemented on haskell standard library?
21:02:15 <augur> razieliyo: no im just making this up for the purpose of teaching you
21:02:18 <razieliyo> okay
21:02:20 <razieliyo> reading
21:03:13 <mm_freak> augur: don't worry, i won't disrupt your rhetoric =)
21:03:29 <augur> razieliyo: but we still need to handle (/), because that's    Int -> Int -> Maybe Int
21:03:40 <derekv> mm_freak: thanks again for the tutorial
21:03:48 <mm_freak> derekv: you're welcome
21:03:57 <augur> razieliyo: it already has a maybe. ok we need more lifting functions. how boring.
21:04:10 <augur> liftMaybe' :: (a -> Maybe b) -> Maybe a -> Maybe b
21:04:14 <razieliyo> augur: so, you make the case for Just x, Just y, and all the rest is Nothing
21:04:22 <augur> liftMaybe' f Nothing = Nothing   ;   lift f (Just x) = f x
21:04:43 <augur> liftMaybe2' f (Just x) (Just y) = f x y   ;   liftMaybe2' f _ _ = Nothing
21:04:50 <augur> gosh this is _better_, but not perfect
21:05:06 <augur> well it turns out we can make do with just liftMaybe'
21:05:34 <augur> like so:   liftMaybe f x = liftMaybe' (\x -> Just (f x)) x
21:06:21 <augur> liftMaybe2' f x y = liftMaybe' (\x' -> liftMaybe' (\y' -> f x' y') y) x
21:06:49 <augur> liftMaybe2 f x y = liftMaybe' (\x' -> liftMaybe (\y' -> Just (f x y)) y) x
21:07:06 <zardoz`> I think you lost him :)
21:07:12 <razieliyo> no, I'm here
21:07:18 <razieliyo> but my head is starting to burn
21:07:24 <augur> i think thats what he meant :p
21:07:32 <augur> razieliyo: you dont have to understand those definitions right now
21:07:35 <zardoz`> razieliyo the point is that liftMaybe will return Nothing if argument is Nothing, otherwise it will call a function you passed on the value wrapped inside and rewrap it again in Maybe
21:07:49 <razieliyo> augur: that's what I'm trying to do
21:07:57 <razieliyo> that's why I'm lagged
21:08:08 <razieliyo> zardoz`: okay, I got it
21:08:14 <augur> razieliyo: just that this abundance of different lifts, to fit the different types of arithmetic operations that MIGHT fail, can all be reduced to one lift: liftMaybe' :: (a -> Maybe b) -> Maybe a -> Maybe b
21:08:18 <razieliyo> augur: if that was what you wanted me to understand, continue
21:08:25 <razieliyo> yes, it's a hell
21:08:28 <razieliyo> it's hell
21:08:39 <razieliyo> I know it's hell, so what's the real solution?
21:08:55 <razieliyo> the liftMaybe' is?
21:09:05 <augur> razieliyo: liftMaybe' is normally actually written as (>>=) for Maybe
21:09:20 <augur> razieliyo: (>>=) for maybe is   (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
21:09:41 <augur> you can read x >>= f as
21:09:49 <augur> if x is Nothing, then just give back Nothing
21:09:53 <mm_freak> razieliyo: this is all about applying functions to values you can't access directly
21:09:58 <augur> otherwise if its Just of something, apply f to that something.
21:10:24 <razieliyo> I see
21:10:28 <augur> razieliyo: that lets us propagate NaN (in the form of   Nothing :: Maybe Int) around
21:10:28 <mm_freak> razieliyo: if you have a value x :: A and a function f :: A -> B, you can just apply f to x
21:10:59 <mm_freak> but here you have a F A (in this particular case with F = Maybe)
21:11:00 <augur> razieliyo: we let (>>=) handle all of the NaN propagation, and get on with out business of writing the math library
21:11:24 <augur> s/out/our
21:11:26 <razieliyo> okay
21:11:31 <razieliyo> so >>= is like a handler
21:11:36 <mm_freak> no
21:11:37 <razieliyo> for writing all those liftings
21:11:44 <mm_freak> it's the lifting itself
21:11:49 <razieliyo> okay, okay
21:11:52 <razieliyo> that's other way to see it
21:11:53 <razieliyo> haha
21:11:56 <mm_freak> Functor:  apply A -> B to T A to get T B
21:12:03 <mm_freak> Monad:  apply A -> T B to T A to get T B
21:12:10 <augur> mm_freak: thats not helping
21:12:22 <razieliyo> it's not
21:12:31 <razieliyo> but I'll take that into accout for later
21:12:35 <razieliyo> s/accout/account
21:13:00 <augur> razieliyo: we could write liftMaybe2 now as   liftMaybe2 f mx my = mx >>= (\x -> my >>= (\y -> f x y))
21:13:02 <razieliyo> augur: fine
21:13:42 <Mokosha> Hey guys, I have a small OpenGL program running, but after about a second or two of my main loop, it just pauses for a second, anyone know what could cause this (GC?)
21:13:48 <augur> razieliyo: sorry that should be liftMaybe2'
21:13:55 <augur> razieliyo: you can sort of see this as saying, push mx's value in as x (if there is such a value), and my's value in as y (if there is such a value) and return f x y
21:14:11 <augur> liftMaybe2 (not ') is the same, but with an extra return:
21:14:20 <augur> liftMaybe2 f mx my = mx >>= (\x -> my >>= (\y -> return (f x y)))
21:14:37 <augur> and similar for liftMaybe and liftMaybe'
21:14:47 <augur> oh but gosh thats so darned unreadable!
21:15:01 <mm_freak> ok, i'll shut up
21:15:05 <razieliyo> it is
21:15:07 <augur> ok fine, abbreviate   mx >>= (\x -> ...) as   do x <- mx ; ...
21:15:11 <augur> not repeating the do's
21:15:25 <augur> liftMaybe2 f mx my = do x <- mx ; y <- my ; return (f x y)
21:16:03 <augur> now it really makes sense:   take x out of mx (if you can), then take y out of my (if you can), apply f to them, and wrap them up to make a Maybe
21:16:26 <augur> so, how about the fancier (+)?
21:16:34 <razieliyo> so, liftMaybe2 f mx my = do x <- mx ; y <- my ; f x y
21:16:45 <augur> liftMaybe2'
21:16:48 <razieliyo> without return
21:16:49 <razieliyo> yes
21:16:49 * hackagebot word24 1.0.6 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.6 (JohnLato)
21:16:51 <augur> because f will wrap them up for us
21:16:53 <razieliyo> sorry, I forgot the '
21:17:00 <zardoz`> razieliyo almost, you forgot return
21:17:05 <augur> razieliyo: the ' versions assume the function wraps for us, so its fancier
21:17:08 <augur> zardoz`: no he didnt hush.
21:17:20 <mm_freak> zardoz`: no, the function names are just terribly confusing =)
21:17:33 <razieliyo> so the return is occuring always
21:17:38 <razieliyo> could that be or not
21:17:43 <augur> mm_freak: yes, well, 's are naughty
21:17:51 <razieliyo> but you Maybe can place it at the middle of a function?
21:18:04 <augur> razieliyo: it depends on what f is! sometimes our function always gives back an int, like primitive addition
21:18:09 <mm_freak> the whole naming you chose will be confusing later when reading actual library APIs
21:18:20 <augur> razieliyo: but sometimes it gives back a Maybe Int, like primitive division
21:18:27 <augur> mm_freak: maybe. oh well. he'll adapt. :P
21:19:15 <augur> razieliyo: so:   mx + my = do x <- mx; y <- my; return (primitiveAdd x y)
21:19:39 <augur> which we could just write as   mx + my = liftMaybe2 primitiveAdd mx my
21:19:48 <augur> but:   mx / my = do x <- mx; y <- my; primitiveDiv x y
21:19:59 <augur> or just   mx / my = liftMaybe2' primitiveDiv mx my
21:20:29 <augur> the lack of return in the / case is because primitiveDiv might fail (so it returns a Maybe Int), but primitive addition can never fail
21:21:15 <augur> razieliyo: make sense?
21:21:52 <frx> are mx and my Maybes?
21:22:08 <augur> yeah, i try to always write mx for monadic values
21:22:15 <augur> so i can do x <- mx
21:22:18 <razieliyo> augur: yes
21:22:20 <frx> if so, what will Nothing + (Just 10) do if not fail?
21:22:38 <augur> frx: (+) will fail, but (+) is not the imagined primitiveAdd function
21:22:43 <augur> its lifted
21:22:47 <frx> ah
21:23:03 <augur> razieliyo: so now we can define our fancy, NaN-y (+), (-), (*), and (/)
21:23:35 <augur> in terms of our true primitive operations that arent NaN-y, (except primitive division, which only ever returns a NaN-y thing)
21:23:41 <mm_freak> allow me to add that this is not a monad tutorial, but a Maybe tutorial
21:24:03 <augur> yes
21:24:07 <mm_freak> Maybe-with-monadic-interface
21:24:10 <Jesin> When calculating A / B, if you need to know N bits of the quotient with perfect accuracy, how many significant bits of A and B are needed as input?
21:24:44 <razieliyo> it's a good case to know when I try to get into monads again
21:25:04 <augur> razieliyo: so you can play this same game for all sorts of things. lists, for instance. you can think of list xs :: [a] as a non-deterministic value of type a
21:25:37 <mm_freak> Jesin: floating point?
21:25:57 <razieliyo> augur: alright
21:25:58 <Jesin> mm_freak: with selectable precision, yes.
21:26:29 <carter> Jesin: just use rationals and rounding :)
21:26:30 <mm_freak> Jesin: (x1 * 2^e1) / (x2 * 2^e2) = x1 / x2 * 2^(e1 - e2)
21:26:34 <mm_freak> Jesin: if that helps
21:26:34 <augur> razieliyo: but very similar lift patterns come up repeatedly
21:26:35 <carter> orrrrr
21:26:36 <oio> *** Exception: /usr/sbin/sendmail: createProcess: does not exist (No such file or directory) getting tis on windows any idea?
21:26:38 <carter> well
21:26:42 <mm_freak> Jesin: but yeah, what carter said
21:26:50 <augur> razieliyo: so the monadic interface is really useful
21:26:58 <zardoz`> razieliyo as a practical example, if you have a Maybe String and a function that takes a String and returns Maybe Int, you can use >>= to compose them together.
21:26:59 <carter> theres a BigFloat lib
21:27:11 <carter> that basically uses bounded precision rationals
21:27:14 <carter> to give you that
21:27:18 <carter> theres a few other libs too
21:27:21 <carter> but thats the easy one
21:27:54 <joelteon> @let instance (Applicative f, Num a) => Num (f a) where (+) = liftA2 (+); (*) = liftA2 (*); abs = liftA abs; signum = liftA signum; fromInteger = pure . fromInteger
21:27:54 <Jesin> I'm trying to understand and improve the CReal library  <_<
21:27:56 <lambdabot>  Defined.
21:28:04 <joelteon> > [10] + [11,12]
21:28:08 <mm_freak> razieliyo: monads are functors, and haskell functors are all about applying functions
21:28:08 <lambdabot>   [21
21:28:12 <joelteon> uh oh
21:28:18 <zardoz`> razieliyo, or in the case of IO, getLine returns IO String, putStrl takes a normal String.  we can use >>= to combine them: getLine >>= putStrLn
21:28:47 <mm_freak> razieliyo: here is one example you may already know:  getLine :: IO String;  putStrLn :: String -> IO ()
21:28:58 <mm_freak> razieliyo: you want to read a line, then print it back
21:29:03 <augur> razieliyo: a nice way to figure out how these things are used, i find, is to write an interpreter for the lambda calculus, with some extra functionality like, say, possible failure, non-deterministic, let expressions, stateful variables, etc etc
21:29:27 <mm_freak> razieliyo: in other words you want to apply a String -> IO () to an IO String
21:29:33 <Tekmo> I think a much easier way to learn this is to just use a parsing library
21:30:00 <mm_freak> monad:  mapIO :: (a -> b) -> IO a -> IO b
21:30:04 <mm_freak> uhm
21:30:10 <mm_freak> functor:  mapIO :: (a -> b) -> IO a -> IO b
21:30:22 <mm_freak> monad:  appIO :: (a -> IO b) -> IO a -> IO b
21:30:36 <mm_freak> applicative:  apIO :: IO (a -> b) -> IO a -> IO b
21:30:46 <mm_freak> the difference is really the form of the first argument
21:31:01 <mm_freak> btw, appIO = flip (>>=) =)
21:31:04 <razieliyo> yeah, it is
21:33:13 <razieliyo> Tekmo: do you say that because of the "void" case?
21:33:23 <razieliyo> of formal grammars
21:33:45 <augur> Tekmo: yes, a parsing library is nice too. especially for applicatives.
21:33:56 <mm_freak> because parser monads are less straightforward examples of monads =)
21:34:01 <augur> well no i guess you really do want monads, but
21:34:15 <Tekmo> razieliyo: Parsers are just a really easy way to get your feet wet with monads
21:35:09 <razieliyo> Tekmo: any concrete suggestion?
21:35:42 <Tekmo> razieliyo: Try the `parsec` library
21:35:42 <augur> i wrote a little parser the other day to demonstration applicative/monadic parsing
21:35:44 <augur> lemme find it
21:36:07 <Tekmo> razieliyo: Actually, let me find you a nice thing to read that helps motivate how to use parsers monadically
21:36:26 <mm_freak> the parsec tutorial is fine
21:36:29 <zardoz`> razieliyo maybeString >>= stringToMaybeInt  can you guess what would happen if maybeString was (Just "10"), if it was (Just "asdf"), and if it was Nothing?
21:36:50 <mm_freak> razieliyo: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
21:37:02 <Tekmo> razieliyo: Read this: http://www.cs.nott.ac.uk/~gmh/pearl.pdf
21:37:25 <razieliyo> isn't there any kind of repos which store haskell libraries? I still didn't use one
21:37:28 <razieliyo> mm_freak: downloading
21:37:39 <mm_freak> just import Text.Parsec instead of Parsec
21:37:45 <mm_freak> the tutorial is for an older version of parsec
21:38:45 <razieliyo> so, is parsec included with ghc?
21:38:57 <razieliyo> I see I can import it from Text.Parsec
21:39:07 <razieliyo> and get no error
21:39:35 <mm_freak> so yes =)
21:41:21 <mm_freak> razieliyo: see Tekmo's link as well…  it seems good
21:41:26 <augur> razieliyo: http://lpaste.net/95831
21:41:55 <augur> im sure the standard notation for all of this is different but thats a toy example that demonstrates the principle
21:41:58 <razieliyo> mm_freak: yes, I'm on it
21:42:19 <razieliyo> augur: I'll take that into account, thanks for the free class =)
21:42:35 <augur> razieliyo: you should read mine first, if only cause its 25 lines of library code :p
21:42:55 <augur> oh actually less since i didnt use empty, did it
21:44:40 <[swift]> so if you use bang patterns with let, you get the same strictness results as case, right?
21:44:57 <razieliyo> wow, now that I remember it, I have to make a parser for csv files, I was going to write a python script that parse the csv file and transform to a haskell file that contains the data structure I'm using on haskell
21:45:12 <razieliyo> it's a very simple case, but I think this may help
21:45:15 <mm_freak> augur: yours isn't actually a monadic parser
21:45:20 <razieliyo> it's just a bunch of strings separated by commas
21:45:47 <augur> mm_freak: well no, it probably doesnt use monadicity in any interesting way
21:45:54 <Tekmo> razieliyo: There is a CSV parsing library in Haskell
21:45:57 <[swift]> to my understanding, "let (!a, !b) = foo" evaluates exactly as much as "case (a,b) of (Bar _, Baz _)". is that correct?
21:45:59 <Tekmo> razieliyo: It's called `cassava`
21:46:01 <mm_freak> augur: it doesn't use "monadicity" in /any/ way
21:46:05 <augur> mm_freak: but its a soft intro to parsing with haskell
21:46:07 <mm_freak> augur: because it's not a monad ;)
21:46:08 <razieliyo> Tekmo: installed by default?
21:46:15 <Tekmo> razieliyo: No.  You must type `cabal install cassava`
21:46:16 <augur> mm_freak: sure it does, it uses the list monad :p
21:46:26 <razieliyo> Tekmo: thanks =)
21:46:58 <augur> Tekmo's link is probbaly good, being a pearl, but pearls are also usually dense
21:47:10 <Tekmo> razieliyo: You're welcome!
21:47:23 <razieliyo> Tekmo: import... what?
21:47:40 <Tekmo> razieliyo: Data.Csv
21:47:46 <razieliyo> Tekmo: thx again
21:47:55 <Tekmo> So any time you want to look up a library's documentation, just Google "hackage <library_name>"
21:48:36 <augur> you can @hackage too, right?
21:48:41 <augur> @hackage Data.Csv
21:48:41 <lambdabot> http://hackage.haskell.org/package/Data.Csv
21:48:53 <razieliyo> Tekmo: I was going to ask that right now, I was just trying to get info with cabal haha
21:49:03 <razieliyo> Page not found
21:49:04 <razieliyo> Sorry, it's just not here.
21:49:23 <razieliyo> http://hackage.haskell.org/package/MissingH-1.2.0.2/docs/Data-CSV.html
21:49:53 <Tekmo> razieliyo: Pretty much any time I want to look up anything I just google "hackage <thing I need>"
21:49:58 <mm_freak> @hackage cassava
21:49:58 <lambdabot> http://hackage.haskell.org/package/cassava
21:50:00 <Tekmo> Works 90% of the time
21:50:01 <mm_freak> not Data.Csv
21:50:08 <Tekmo> The remaining 10% of the time I use "haskell <thing I need>"
21:50:24 <razieliyo> god bless google
21:50:44 <mm_freak> Tekmo: as a side note, you don't have to tell google everything if you have firefox:  i just type "hpkg cassava" into the address bar =)
21:51:05 <mm_freak> Tekmo: just create a keyword bookmark
21:51:15 <Tekmo> mm_freak: It's too ingrained in my bones.  I can't change it any longer :)
21:51:27 <razieliyo> well, it's been a good time
21:51:39 <Tekmo> mm_freak: But I do use the address bar
21:51:48 <Tekmo> mm_freak: I never actually visit google.com
21:51:55 <razieliyo> but it's 6:36 A.M. here and I should go to bed haha
21:52:01 <razieliyo> thanks to all for the help
21:52:09 <Tekmo> razieliyo: Good luck!  Get some rest
21:52:11 <razieliyo> cya tomorrow
21:52:14 <mm_freak> Tekmo: then just create a keyword bookmark for "hackage", so you don't need to change your habit =)
21:52:15 <razieliyo> Tekmo: thanks =)
21:52:17 <razieliyo> bye!!
21:52:27 <mm_freak> razieliyo: same here…  good morning =)
21:53:54 <augur> anyone have a nice monadic parsing lib that can do bottom-up parsing, or that can handle left-recursive grammars?
21:55:04 <[swift]> sorry to ask again, just trying to make sure i understand this stuff. to my understanding, "let (!a, !b) = foo" evaluates exactly as much as "case (a,b) of (Bar _, Baz _)". is that correct?
21:55:09 <johnw> can you even encode bottom-up parsing with monads?  I thought they implied ordering
21:55:19 <Tekmo> I'm not familiar with the intricacies of parsing, but I can name all the parsing libraries I know and maybe one of them will help
21:55:30 <Tekmo> parsec/attoparsec/trifecta/uuparsinglib
21:55:35 <Tekmo> Try one of those
21:56:34 <Tekmo> [swift]: I generally don't use bang patterns, so I don't know
21:56:34 <johnw> happy can do bottom-up
21:56:53 <johnw> but I think monadic parsers are top-down by definition, as far as I understand
21:56:53 <Tekmo> [swift]: I prefer to use `seq`; it's easier to reason about
21:57:08 <augur> johnw: i dont know, thats why i ask :)
21:57:19 <[swift]> Tekmo: no worries. i just read the GHC user manual's section on performance today and was disturbed to find that my code is full of 'let'. trying to figure out if i really need to switch to case or if bang patterns are good enough
21:57:29 <augur> johnw: or at least parsing combinators
21:57:31 <johnw> i mean, maybe you could it with back-tracking, but I wonder if that's efficient enough
21:57:38 <Tekmo> [swift]: There's nothing wrong with `let`
21:57:41 <Tekmo> [swift]: I use let all the time
21:57:44 <[swift]> Tekmo: seq is noisier though =)
21:57:51 <Tekmo> [swift]: That's why `$!` is nice
21:58:01 <augur> johnw: im a chart lover myself
21:58:03 <Tekmo> [swift]: It's a nice infix way to `seq` something without duplicating the name
21:58:03 <johnw> now, I think applicative parsers could do bottom-up
21:58:43 <[swift]> Tekmo: well, i don't aim to remove it from every piece of code, but the laziness of let is something to keep in mind in the hot loops, i guess. i'm still learning how to reason about lazy evaluation and performance
21:58:58 <carter> applicative + alternative parsers could work
21:59:01 <johnw> hmm... http://pdos.csail.mit.edu/~baford/packrat/thesis/ looks interesting
21:59:06 <Tekmo> [swift]: There are pretty much only two places you should ever worry about strictness
21:59:11 <johnw> a back-tracking packrat parser for Haskell
21:59:22 <johnw> seems to handle left-recursive rules
21:59:25 <Tekmo> [swift]: 1) data type definitions (i.e. mark fields strict and UNPACK them
21:59:37 <Tekmo> [swift]: 2) Keeping the accumulator of a loop strict using `seq`
21:59:39 <Tekmo> That's pretty much it
21:59:51 <johnw> it's on Hackage as "pappy"
22:00:20 <johnw> augur: see also http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.124.1239&rep=rep1&type=pdf
22:00:40 <carter> johnw: pappy is fugly though
22:00:42 <carter> look
22:00:43 <augur> chart parsing is really nice in terms of implementation. its quite gorgeous, really.
22:00:46 <amosr> sometimes you just gotta -ddump-prep and keep adding bang patterns until it's right
22:00:58 <carter> augur: whats chart parsing?
22:01:20 <augur> carter: non-deterministic bottom-up parsing that finds all solutions in an elegant, efficient way
22:01:26 <carter> oh
22:01:30 <augur> actually im not sure how elegant or efficient it'd be in haskell, but
22:01:30 <[swift]> Tekmo: i might guess that (3) would be making sure work happens on the thread you expect it to
22:01:34 <carter> so its like a GLL parser?
22:01:39 <Tekmo> [swift]: Yeah, that, too
22:01:51 <augur> carter: dont know GLL parsers
22:02:13 <carter> GLL is kinda like GLR, but you could mebe make a parser combinator lib using the
22:02:15 <carter> m
22:02:27 <augur> carter: http://www.ling.helsinki.fi/kit/2008s/clt231/nltk-0.9.5/doc/images/chart_np2.png
22:03:01 <carter> neat
22:03:06 <augur> you add the arcs bottom up
22:03:15 <carter> yeah
22:03:42 <augur> a rule like VP -> V NP spans m..n if V spans m..i and NP spans i..n
22:03:46 <augur> etc
22:04:41 <augur> obviously you can reuse things, so the cost of non-determinism/parse-totality isn't too high
22:06:34 <augur> i think maybe in haskell you could get away with it by using the pointery aspect of things to cheat
22:06:36 <[swift]> Tekmo: do you get just as good performance from letting everything in the loop be lazy and forcing the accumulator, transitively evaluating all those thunks, as you do from keeping things strict in the intermediate calculations too?
22:07:11 <[swift]> Tekmo: i'd expect not unless ghc is very smart (which it probably often is =) but i don't have deep knowledge of this stuff
22:07:14 <Tekmo> [swift]: The former, I only explicitly force the accumulator
22:07:33 <augur> i should try to write this cute cheaty chart parser
22:07:41 <Tekmo> [swift]: Don't try to second-guess ghc's optimizer
22:07:53 <Tekmo> [swift]: I've had several examples where my code got faster when I made it more high-level
22:08:14 <Tekmo> [swift]: The less specific you are, the more room you give ghc to optimize your code
22:08:19 <carter> augur: i think edwardk wrote sparse as part of a plan to use the Chart parsing alg in the ICFP 2013 paper
22:08:26 <augur> shhhh
22:08:30 <augur> dont give me any clues
22:08:32 <Tekmo> [swift]: If you try inline or seq everything you are tying ghc's hands and not giving it opportunities to rearrange things for speed
22:08:45 <carter> augur: he's now board and doing other things
22:08:55 <carter> Tekmo: unless your'e competing with numerical fortran / asm
22:09:03 <augur> carter: board? well plank him, then!
22:09:04 <carter> but that aside, you're def right
22:09:06 <carter> bored
22:09:07 <carter> yeah
22:09:18 <Tekmo> carter: There's no way Haskell can compete with that without FFI bindings
22:09:24 <carter> Tekmo: i'm working on it
22:09:25 <[swift]> Tekmo: thanks, that's useful advice. i may be getting a bit too excited about newfound knowledge
22:09:33 <Tekmo> carter: Heck, forget numerical computations
22:09:38 <Tekmo> carter: Consider just the simple `wcwidth` function
22:09:43 <carter> wcwidth?
22:09:45 <carter> whats that?
22:09:46 <Tekmo> carter: I tried writing a Haskell equivalent that was as fast
22:09:55 <[swift]> Tekmo: (though presumably if you can actually see problems in the core, it's worth doing these things. i need to learn to understand core better...)
22:10:02 <Tekmo> carter: It's basically a small C utility for counting how many columns a character will take up
22:10:10 <Tekmo> carter: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
22:10:18 <carter> fixed width characters or?
22:10:25 <Tekmo> carter: Not necessarily
22:10:46 <Tekmo> [swift]: It's more important to benchmark
22:10:59 <Tekmo> [swift]: However, I actually prefer not to use criterion for benchmarking
22:11:00 <carter> Tekmo: did you do a haskell version of the lookup taper?
22:11:05 <carter> Tekmo: why no criteiron?
22:11:09 <carter> *lookup table
22:11:37 <Tekmo> carter: Criterion just seems too unreliable to me
22:11:42 <carter> how so?
22:11:48 <Tekmo> carter: There have been too many times where it has given provably bad results
22:11:59 <carter> what sort of examples?
22:12:12 <carter> Tekmo: you can disable or force GC between runs and stuff to fix that
22:12:17 <Tekmo> carter: Like, for example, I'm timing disk IO and it says it only takes 100 nanoseconds
22:12:24 <Tekmo> carter: I don't know
22:12:30 <carter> ohhh
22:12:37 <carter> sometimes buffered io is fast :)
22:12:41 <carter> because of the OS buffers
22:13:00 <carter> and just reads and writes to ram
22:13:06 <carter> though 100ns is kinda fast for even ram
22:13:12 <carter> that sounds like a bug...
22:13:15 <Tekmo> Well, that's not the only example
22:13:22 <carter> well
22:13:23 <Tekmo> Like, another one was a pipe that was looping 1000000 times
22:13:27 <Tekmo> It was an IO action
22:13:29 <carter> ok
22:13:37 <Tekmo> And I told it to just run 10^6 times
22:13:41 <carter> yeah
22:13:42 <carter> ok
22:13:43 <Tekmo> Again, it said < 100 ns
22:13:43 <carter> and?
22:13:48 <carter> huhhhhhh
22:13:49 <Tekmo> I knew that was impossible
22:13:58 <carter> do you have a code exmaple?
22:14:09 <Tekmo> This was back in the 3.* cycle
22:14:17 <Tekmo> I don't remember the exact example
22:14:22 <carter> soo not in the past year or so
22:14:31 <carter> i was doing perf benchmarking this spring with criterion and it worked really well
22:14:56 <Tekmo> I have another example where criterion was all over the place.  Let me pull up a Github issue thread with details
22:15:07 <Tekmo> Oh wait, no
22:15:12 <Tekmo> This one was GHC acting up, not criterion
22:15:14 <Tekmo> never mind
22:15:42 <carter> ah
22:15:43 <carter> k
22:15:45 <Mokosha> anyone know how to deal with "Most RTS options are disabled. Link with -rtsopts to enable them" via cabal-dev?
22:16:03 <carter> Mokosha: adjust your .cabal  file
22:16:14 <Mokosha> with what?
22:16:16 <carter> have a ghc-options: -rts-ops
22:16:20 <carter> line
22:16:26 <carter> in the the application stanza
22:16:30 <carter> or pass the flag to cabal !
22:16:32 <Tekmo> Mokosha: -rtsopts
22:16:40 <carter> Mokosha: also use cabal-install 1.18, not cabal dev!
22:16:44 <carter> why are you using cabal-dev?
22:16:52 <Tekmo> I use cabal dev
22:16:57 <Tekmo> I'm still on an old Haskell platform
22:16:58 <carter> why?
22:17:00 <carter> ahhh
22:17:05 <Mokosha> cabal-dev seems to be what people use for development work?
22:17:11 <Mokosha> is 1.18 better?
22:17:14 <carter> yesss
22:17:18 <carter> it has baked in sandbox support
22:17:39 <carter> so the sandboxing support / work flow is now baked into cabal-install
22:17:47 <carter> and thus supported by the cabal team
22:17:50 <carter> rather than being a util on top
22:18:00 <Tekmo> Yeah, there was a while where cabal-dev was a mess
22:18:26 <carter> Tekmo: do you have you wcwidth code anywhere?
22:18:28 <carter> i'm curious now
22:18:48 <Mokosha> ok I will install the newer version and poke around some more
22:19:07 <carter> Mokosha: enjoy! :)
22:19:10 <carter> cabal help
22:19:12 <carter> will give you some hints
22:19:22 <Tekmo> carter: Maybe, I will check
22:19:26 <carter> ok
22:19:28 <carter> i really should do work
22:19:30 <carter> buttttt
22:19:31 <carter> i'm distractable
22:19:34 <Tekmo> Haha
22:19:38 <Tekmo> Now you know why I'm rarely on IRC
22:20:19 <carter> Tekmo: irc is how i made sure everyone knew about the mac issues
22:21:24 <Tekmo> carter: Blog posts generally reach a wider audience, especially ify ou make them searchable
22:21:27 <adnap> Have you made best friends in an IRL Haskell group?
22:21:31 <carter> Tekmo: good point
22:21:44 <carter> Tekmo: i am resuming my blog soon
22:21:50 <chrisblake> guys, if I have a Foo.hs, and a Foo/Bar.hs file, if I want to require the former, it's "import Foo", and the latter is "import Foo.Bar", correct?
22:21:50 <carter> trying to figure out wordpress vs blogger
22:21:51 <carter> thoughts?
22:21:56 <Tekmo> carter: blogger
22:21:58 <Tekmo> No contest
22:22:05 <chrisblake> or do imports not work that way?
22:22:09 <carter> thats what i'm leaning towards
22:22:11 <carter> what's your take?
22:22:16 <Tekmo> carter: Seriously, it's the best thing ever
22:22:18 <carter> yeah
22:22:29 <carter> blog.cstheory.net will have new stuff soon
22:23:03 <Tekmo> chrisblake: Yes
22:23:10 <chrisblake> Tekmo: okay, sweet. thanks :)
22:23:22 <Tekmo> chrisblake: You're welcome!
22:23:39 <Tekmo> carter: Think of it this way
22:24:00 <carter> "kill php" ? :)
22:24:03 <carter> i do like blogger
22:24:03 <Tekmo> carter: Ha
22:24:18 <carter> Tekmo: my blog is using blogger currently
22:24:29 <carter> finally talked myself out of yak shaving a hakyll blog
22:24:51 <Tekmo> carter: Blogger's stats are gold
22:24:55 <carter> true
22:24:58 <carter> they're pretty handy tooling
22:25:17 <Tekmo> If it weren't for the stats there would have been no way that I would have kept up blogging
22:25:23 <carter> its like a less painful / easy to use version of google analytics
22:25:27 <carter> which is pretty inscrutable
22:26:29 <Tekmo> Blogging requires a bigger up-front investment, but it pays off in the long run in educating people
22:26:33 <carter> yeah
22:26:35 <carter> agree
22:26:40 <Tekmo> For example, writing up a post takes about 10 hours for me
22:26:47 <carter> i'm going to be starting to do that for my numerical hackery soon
22:26:51 <Tekmo> But it will then generate about 20 views a day forever after that
22:26:54 <frx> http://lpaste.net/95968 <- why am I getting this error if I try to run main function in ghci? if I compile and run the program it works
22:26:56 <jle`> writing a post seems to always pay off in the little bump i get on google analytics
22:27:12 <Tekmo> So after about one month, the post has paid itself off
22:27:25 <Tekmo> I've informed 600 people more than I would have helped on IRC
22:27:49 <jle`> Tekmo: care to provide a link i can add to my feedly?
22:27:50 <Tekmo> And that's not even counting the initial burst in traffic
22:27:55 <Tekmo> haskellforall.com
22:28:08 <jle`> Tekmo: thanks :)
22:28:13 <jle`> hm i think i already have this one
22:28:17 <Tekmo> :)
22:28:42 <jle`> is the name a pun on the for all language extension?
22:28:44 <Tekmo> Yes
22:28:45 <Tekmo> :)
22:29:15 <carter> Tekmo: i may need a wee  bit of cheer leading to take the jump
22:29:18 <carter> thanks for the first nudge
22:29:36 <carter> keep on wanting to yak shave a static blog
22:29:41 <carter> but too manyt hings on my plate
22:29:41 <Tekmo> :)
22:29:48 <Tekmo> Just trust blogger
22:29:50 <Tekmo> You won't regret it
22:29:57 <carter> yeah
22:30:07 <Tekmo> The easy way you know to pick blogger is that all the successful bloggers use it
22:30:10 <jle`> Tekmo: good to see more people involved in scientific computing in the haskell community
22:30:18 <Tekmo> All the people who have static blogs or wordpress blogs give it up after a while
22:30:25 <carter> jle`: i'm allegedly scientific computing oriented
22:30:28 <Tekmo> jle`: Thanks! :)
22:30:29 <carter> butttt we'll see
22:30:39 <jle`> i am proud of my summer project blog engine :'(
22:30:43 <carter> jle`: cool
22:30:50 <carter> Tekmo: i'm pretty excited
22:30:59 <carter> i'm right now hammering out the initial array shape dsl
22:31:17 <Tekmo> carter: Just think of it as a way to share really cool ideas
22:31:21 <carter> yeah
22:31:21 <carter> ok
22:31:24 <Tekmo> carter: Every time you have a neat thought or idea, just blog about it
22:31:30 <Tekmo> carter: There will always be somebody who will find it informative
22:31:31 <carter> fuckit, i will
22:31:37 <Tekmo> carter: Remember, it's not a paper
22:31:45 <Tekmo> carter: It's just a forum to start cool and fun discussions
22:31:47 <carter> yes
22:31:48 <carter> ok
22:31:49 <carter> fineeee
22:31:51 <Tekmo> :)
22:32:00 <jle`> also please just log some of your progress on your projects ^^
22:32:02 <carter> Tekmo: i'll blog that shape / layout stuff, and email you
22:32:03 <carter> :)
22:32:04 <carter> yeah
22:32:07 <carter>  I should
22:32:10 <carter> i've gone dark too long
22:32:13 <jle`> it's nice seeing the little problems being tackled in the real world
22:32:24 <Tekmo> jle`: I've been busy completing my thesis.  That's why I've been silent the last month or two
22:32:25 <jle`> and seeing inside the mind of programmers
22:32:40 <jle`> it's much more useful than those toy tutorials
22:32:45 <Tekmo> jle`: Yeah, I will be switching to full-time programming soon, so I will ahve much more tutorials
22:32:46 <jle`> Tekmo: what field are you in?
22:32:51 <carter> Tekmo: i hope i snipe you and izbicki to be ealier dabblers
22:32:57 <Tekmo> jle`: I was in structural bioinformatics
22:33:04 <Tekmo> jle`: After this I'm joining Twitter
22:33:04 <carter> Tekmo: i just pm'd you
22:33:07 <carter> ohhhh
22:33:08 <carter> shit congrats
22:33:12 <Tekmo> Thanks! :)
22:33:19 <jle`> what kind of path leads one to structural bioinformatics
22:33:21 <carter> do you know what you'lll be doing there?
22:33:28 <Tekmo> jle`: In my case, a very circuitous path
22:33:34 <Tekmo> carter: I'm working on their platform intelligence team
22:33:44 <carter> is that SF only?
22:33:50 <Tekmo> carter: Basically building tooling for querying large amounts of data
22:33:56 <Tekmo> carter: They have other offices, but SF is the main one
22:33:57 <carter> in scala? :)
22:33:59 <carter> yeah
22:34:00 <Tekmo> Yeah, Scala
22:34:03 <carter> they have nyc office too
22:34:29 <carter> Tekmo: i really want to figure out how to nerd snipe as many orgs as possible into adopting numerical haskell once its out :)
22:34:41 <Tekmo> carter: Trust me, I will be using it myself once you complete it
22:34:46 <carter> yay
22:34:53 <Tekmo> carter: In my free time I'm working on a long-term project for protein design tools
22:34:53 <shergill> ditto
22:34:59 * shergill goes back to lurking
22:35:00 <Tekmo> carter: I can really use high-performance matrix stuff
22:35:02 <carter> i look forward to your ideas to fix all my corner cases
22:35:07 <carter> Tekmo: it won't be high perf initially
22:35:16 <Tekmo> carter: As long as it is on par with hmatrix, I'm happy
22:35:21 <carter> though i'll have a blas / lapack binding hacked out shortly after the first release
22:35:45 <carter> should i sort out the blas / lapack bit to be int tandem
22:35:49 <carter> or allow that to be later
22:36:14 <carter> happily, theres an Hmatrix branch that bsd' his blas/lapack binding code
22:36:16 <carter> so i can borrow that
22:36:35 <Tekmo> carter: I trust your judgement
22:36:43 <carter> thankee
22:36:46 <Tekmo> carter: My advice is don't worry about getting it perfect the first time
22:36:51 <Tekmo> carter: Just keep iterating until you are happy with it
22:36:52 <carter> yeah
22:37:03 <carter> but get the first ok + someone else can use it version out
22:37:23 <carter> ok
22:37:25 <carter> i g2g
22:37:26 <carter> :)
22:37:28 <carter> night all
22:37:29 <Tekmo> Alright
22:37:30 <carter> shergill: thanks :)
22:37:32 <carter> and Tekmo  too
22:37:33 <Tekmo> Good night
22:37:38 <carter> i need the cheer leading  sometimes
22:37:56 <shergill> carter: i'll be thanking you ;)
22:38:26 <Tekmo> carter: This is why blogging is great
22:38:33 <Tekmo> carter: It greatly increases your enthusiasm for you work
22:41:54 <piezoid> hi !
22:41:59 <lpaste> piezoid pasted “Less parser (WIP)” at http://lpaste.net/95969
22:42:01 <piezoid> can I ask for quick code review ? :)
22:42:19 <Tekmo> I'll review it
22:42:30 <Tekmo> Just let me put my kids to sleep
22:42:31 <Tekmo> Hold on
22:45:03 <piezoid> Thanks
22:45:08 <piezoid> I am not satisfied with my expP, the way I recursively construct the parser is a little awkward...
22:48:03 <MedDev> is there a vim plugin to remotely query hoogle. i know there's one for a local hoogle instance, but that seems... excessive
22:49:54 <Tekmo> piezoid: You might be able to achieve something similar using `asum` from `Control.Applicative`
22:50:03 <Tekmo> Or `msum` from `Control.Monad`
22:51:08 <oio> does smtp-mail supports TLS?
22:51:14 <Lambdacolyte> edwardk, is trifecta worth using if performance is *kind of* a concern, but pretty messages are nice?
22:51:47 <piezoid> :t asum
22:51:48 <lambdabot>     Not in scope: `asum'
22:51:49 <lambdabot>     Perhaps you meant one of these:
22:51:49 <lambdabot>       `F.asum' (imported from Data.Foldable),
22:51:54 <edwardk> it works well enough for me, and performance is kind of a concern for me.
22:52:11 <Tekmo> :t msum
22:52:12 <Lambdacolyte> ok, as long as its not really really slow or something :)
22:52:12 <lambdabot> MonadPlus m => [m a] -> m a
22:52:14 <edwardk> if you want it to be faster i'm happy to take patches cleaning it up
22:52:57 <edwardk> haasn: i'd rather not write the evil overlapping instance
22:53:28 <piezoid> Tekmo: I borrowed the logic from attoparsec-expr, I'm not sure to understand everything
22:54:45 <piezoid> at each precedence level, the parser is a fold over expressions of greater precedence
23:17:47 <ManOfStll> Anyone play Black ops?
23:22:48 <johnw> this isn't the channel for that, ManOfStll
23:34:01 <Feuerbach> Has hackage stopped building the docs?
23:34:43 <johnw> i noticed that on a few projects too
23:34:50 <johnw> i'd ask in #hackage, or report the issue on github
23:35:15 <Feuerbach> Oh, I didn't know about #hackage
23:35:30 <johnw> we have all kinds of fun in there!
23:35:38 <johnw> well, mainly one kind of fun, but hey
23:36:16 * sopvop decided to check out how inference works in ermine: inferType (Term.Var _) = fail "unimplemented"
23:37:42 <zennist> what function applies a function to two arguments and return the results? i.e. f::(a->b)->a->a->b->b
23:37:59 <johnw> why would there be two results?
23:38:18 <zennist> because you give it two arguments
23:38:24 <johnw> the result would have to be the same
23:38:43 <johnw> i'd do this: f &&& f
23:38:58 <johnw> > ((+1) &&& (+1)) 2
23:38:59 <lambdabot>   (3,3)
23:39:11 <johnw> oh, I see
23:39:21 <johnw> :t (***)
23:39:22 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
23:39:34 <johnw> > ((+1) *** (+1)) (2, 2)
23:39:35 <lambdabot>   (3,3)
23:39:40 <johnw> > over both (+1) (2, 2)
23:39:42 <lambdabot>   (3,3)
23:39:47 <johnw> does that help?
23:40:25 <piezoid> > (($2) &&& ($3)) (+1)
23:40:27 <lambdabot>   (3,4)
23:40:39 <johnw> haha
23:40:53 <johnw> > curry (over both f) a b
23:40:55 <zennist> johnw: what does the over both mean?
23:40:55 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
23:40:55 <lambdabot>    arising from a us...
23:41:01 <johnw> > curry (over both (+1)) 2 3
23:41:03 <lambdabot>   (3,4)
23:41:08 <johnw> zennist: it's from Control.Lens
23:50:37 <augur_> hmm
23:51:18 <augur_> the problem with chart parsing in a combinator system is that you need the whole grammar available at every step
