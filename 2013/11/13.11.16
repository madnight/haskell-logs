00:00:00 <startling> btw, I just now noticed that hlint caught the zipWith thing. :)
00:00:05 <benzrf> heh
00:00:20 <startling> the "\y -> cell x y" thing, too
00:00:25 <benzrf> does it notice zip + uncurry or something
00:00:27 <benzrf> +_+
00:00:40 <benzrf> 1 sec apt-get
00:00:48 <startling> benzrf, I guess so.
00:02:07 <startling> I'm a little surprised it caught it, too.
00:02:12 <augur_> Bool -> a -> Maybe a   is a levitated general constructor for Maybe :D
00:02:26 <augur_> almost
00:02:32 <benzrf> levitated?
00:02:38 <augur_> with skyhooks
00:02:44 <benzrf> ok let me wa
00:02:52 <benzrf> skyhooks
00:02:58 <augur_> levitation is a technique for writing a self hosted type system
00:03:11 <lpaste> benzrf pasted “sokoban” at http://lpaste.net/95748
00:03:21 <benzrf> oh huh it does that
00:03:30 <benzrf> ah, only if youre in the channel?
00:03:45 <augur_> no, it does it if you tell it to in the paste
00:03:54 <augur_> by default it sends here
00:04:00 <benzrf> Ok
00:04:20 <benzrf> anyway that's the New and Improved version
00:05:02 <benzrf> hmm
00:05:15 <benzrf> i dont suppose theres any way to declare a general instance for instances of another class
00:05:39 <benzrf> i.e. instance Monoid Functor where mappend = fmap mappend
00:05:42 <benzrf> nah that would be idiotic
00:06:07 <startling> benzrf
00:06:15 <startling> Functor is the wrong thing. You want Applicative.
00:06:28 <startling> t liftA2 mappend
00:06:28 <startling> liftA2 mappend :: (Applicative f, Monoid c) => f c -> f c -> f c
00:06:50 <startling> Applicative is sort of "Zippable".
00:08:07 <startling> zip a b = (,) <$> a <*> b
00:08:47 <startling> (note that this isn't the ordinary zip for lists. :<)
00:09:05 <benzrf> ooh
00:09:11 <benzrf> Gneralized Zip
00:09:24 <benzrf> azip, even
00:10:04 <startling> yep. liftA2 is generalized zipWith
00:10:04 <benzrf> so i use bash in vi mode, so ^L doesnt work in insert
00:10:21 <benzrf> so i made the file ^L a symlink to clear
00:10:25 <benzrf> so I can press ^L<ret>
00:10:35 <benzrf> on the upside, that's vaguely convenient
00:10:46 <benzrf> on the downside, grep now thinks my history file is binary
00:11:15 <adnap> chrisdone: I can't figure out what is unusual about you video. It looks like a normal vim session.
00:11:21 <adnap> *your
00:11:56 <benzrf> startling: thanks for all the help
00:12:05 <benzrf> ill be back tomorrow with MANY MANY MORE BUGS
00:12:12 <benzrf> as i try to tackle code i dont actually understand
00:12:13 <benzrf> i.e. state monad
00:12:24 <benzrf> =]
00:12:38 <benzrf> anyway i should probably sleep now as its 2:56
00:12:40 <benzrf> huh what good timing
00:12:42 <startling> benzrf, heh. it might be productive to derive State yourself.
00:12:45 <startling> have a nice night !
00:12:49 <benzrf> you too
00:13:01 <benzrf> bye
00:13:17 <adnap> I re-read about Reader and Writer. I still wonder what I would use them for.
00:13:55 <Twey> adnap: Most commonly, Reader is used for passing some sort of static configuration around your program, while Writer is used for accumulating output as you go
00:13:56 <startling> adnap, Writer is pretty common, e.g. Put in `binary` is secretly just a Writer.
00:14:10 <startling> adnap, ReaderT and WriterT are vastly more useful though.
00:14:13 <adnap> A Writer is like a value and a monoid value that gets mappended as you bind
00:14:14 <Twey> (e.g. logs or errors)
00:14:45 <adnap> But it seems annoying to have all of your functions "tainted" with monoids
00:14:56 <adnap> Isn't there a way to separate the logging code?
00:15:20 <startling> adnap, you could write a different Writer where runWriter takes something to use other than mappend.
00:15:39 <startling> in practice it's not so bad, though.
00:15:43 <adnap> Like, you will write functions such as Integer -> (Integer, String) instead of Integer -> Integer
00:16:09 <startling> adnap, oh. that's what liftM is for.
00:16:15 <adnap> And if you decide you no longer need the log, you have to go and--
00:16:23 <Twey> :t liftM
00:16:29 <Twey> Aw, not again.
00:16:35 <adnap> I know it
00:16:42 <adnap> (a -> b) -> m a -> m b
00:16:53 <adnap> Monad m => of course
00:17:00 <Twey> Aye
00:17:36 <startling> adnap, it's common to write your Integer -> Integer as a top-level declaration and mix it in with monadic code, yeah.
00:18:08 <startling> you are right that having an Integer -> Writer String Integer that never writes anything is sort of bad.
00:18:53 --- mode: Cale set -o Cale
00:19:22 <Cale> startling: The sort of bad which is provided for in the definition of a monad ;)
00:19:59 <adnap> So... if f :: Integer -> Integer, liftM f might produce Writer String Integer -> Writer String Integer
00:20:21 <Cale> adnap: That's right
00:20:26 <adnap> Which just does nothing to the log I guess
00:20:33 <Cale> yeah
00:20:52 <Cale> Nothing more than the Writer action that you give it does.
00:20:54 <adnap> So you can avoid writing logging functions unless absolutely necessary; i.e. you want to log something
00:21:29 <adnap> But I have never wanted to log anything. Do people use it when they have a huge codebase and they want to debug the execution?
00:21:49 <startling> adnap, do you know Monad transformers?
00:21:56 <adnap> startling: Yeah
00:22:09 <startling> OK. yeah, it's common to use WriterT for that kind of thing.
00:22:13 <adnap> startling: I read the Wikibooks page on those, I understood everything, and I haven't used them since
00:22:13 <startling> it's more than logging though.
00:22:32 <adnap> I have used some IO ones though
00:22:37 <adnap> So I can do liftIO in a mond
00:22:40 <adnap> monad
00:23:11 <adnap> startling: What else would you mappend?
00:23:33 <Cale> :t liftIO
00:23:43 <adnap> Cale: Not working
00:23:59 <Cale> liftIO :: MonadIO m => IO a -> m a
00:24:03 <levi> Man, what kind of programs do you write that you've never wanted to log anything?
00:24:19 <adnap> Graphics programs that loop forever
00:24:30 <startling> adnap, you could use it for building a set.
00:24:40 <Cale> You can't use liftIO in any monad, only in ones which are in some way constructed in terms of IO so as to be able to support that operation.
00:24:48 <levi> What's looping forever got to do with logging?
00:24:57 <startling> adnap, Put is like a Writer ByteString for serializing data.
00:25:10 <adnap> Well, if I created a log while looping forever, it would be huge and hard to read through
00:26:14 <adnap> levi: What kind of programs have you written where you wanted to log something?
00:26:17 <Cale> adnap: Depends on how often you write messages to the log?
00:26:25 <levi> Most programs that generate logs do so while looping forever. It's just that they don't log *everything*.
00:26:43 <adnap> If I'm just debugging, I might use trace and just example the terminal output
00:26:48 <adnap> *examine
00:27:06 <adnap> I don't have to change any of the code
00:27:19 <Cale> adnap: Web servers tend to run forever, and have to log things. Many games produce logs of various sorts (e.g. chat logs or combat logs).
00:27:38 <adnap> Yeah. I've never finished anything
00:27:49 <adnap> I've never written something big in Haskell
00:27:49 <startling> adnap, there's a difference between debugging your code and debugging your input.
00:28:48 <levi> Well, I'm talking about programming in general, not Haskell specifically. But I don't think the fact that you are implementing a program in Haskell makes much difference to the value of logging.
00:28:57 <adnap> Rigt
00:29:16 <adnap> I can imagine uses for it in a big program
00:29:45 <startling> well, logging is trivial in impure languages.
00:29:46 <levi> I can imagine getting away without it in small programs. ;)
00:30:03 <adnap> It's also trivial in IO
00:30:09 <adnap> You can just putStrLn
00:30:22 <adnap> And trace in pure functions
00:30:24 <startling> adnap, well, sort of.
00:30:30 <adnap> It's not as good I know
00:30:41 <adnap> 'Cause you can't easily write the log to a file or something
00:30:44 <startling> adnap, what if your program should do different things depending on what's in the log?
00:30:47 <startling> yeah
00:31:00 <adnap> startling: I don't understand that
00:31:06 <adnap> startling: So, the program has persistence?
00:31:24 <levi> startling: That sounds a bit outside the scope of what one normally thinks of as 'logging'.
00:31:33 <startling> levi, that's fair.
00:31:53 <startling> I think it's kind of bad to focus on Writer-as-logging, though.
00:32:08 <adnap> I can imagine getting away with trace and putStrLn for debugging purposes for a long time before restorting to a less hackish log with Writer
00:32:16 <adnap> *resorting
00:32:49 <adnap> I think once my code got big enough and I had a lot of trace statements or something, I would switch to Writer
00:32:59 <startling> I think the easiest way to view Writer is as a restricted State.
00:33:12 <startling> it's State you can only add too, for a certain value of 'add'.
00:33:17 <adnap> I don't use state either :/
00:33:33 <adnap> Some people here had me implement it when I said that last time
00:33:34 <startling> if your addition function is lazy enough, you can get away with things you can't get away with in State.
00:33:52 <adnap> So, what kinds of things do you use State for?
00:33:59 <startling> adnap, yeah. It seems like you might benefit from writing something nontrivial in Haskell
00:34:13 <adnap> startling: I'm trying to. I think I'm just bad?
00:34:24 <levi> Look at Brent Yorgey's Functional Pearl on Monoids for ideas on interesting stuff you can do with them.
00:34:40 <adnap> levi: State or Writer?
00:35:00 <startling> adnap, what are you trying to write?
00:35:08 <startling> (do you have any code you can paste?)
00:35:20 <adnap> startling: >_<
00:35:33 <adnap> I don't want to talk about it
00:35:56 <startling> adnap, anyway, it doesn't seem like you're bad; it seems like you've understood the abstract but not the motivation.
00:36:17 <levi> Writer lets you carry along a monoid with your computation.
00:36:23 <adnap> I think I'm slow
00:36:35 <adnap> At figuring things out
00:36:47 <levi> So, ideas on how to use monoids would lead to ideas on how to use Writer.
00:36:58 <startling> adnap, you've always been pretty quick in my conversations with you.
00:37:18 <adnap> startling: Well, I'm slow at designing my programs
00:37:39 <startling> understood.
00:37:59 <adnap> I'm using FRP, so... maybe that's a hint about why I'm having a hard time?
00:38:23 <levi> There's nothing wrong with doing things without fancy Monad transformers and whatnot, but playing around with them and incorporating them into your programs can help you learn how to use them.
00:38:36 <adnap> I got really confused about dynamic event switching
00:38:50 <adnap> Not the concept, but how to use it in practice
00:39:08 <levi> I haven't delved into FRP, so I can't speak to that.
00:39:23 <adnap> levi: Yeah, I really want to just look at my program and see, "Oh! This Monad fits here and makes my code shorter!"
00:39:46 <adnap> At least if I keep the monads fresh in my mind, I'll be more likely to notice
00:39:57 <levi> I think that's just a matter of experience.
00:40:10 <adnap> Also, I re-read about Reader...
00:40:15 <adnap> Let's see if I remember...
00:40:32 <levi> And experience comes via experimentation; you have to write code that uses things, not just read about them.
00:40:46 <startling> the thing about Reader is that it lets you avoid passing parameters explicitly everywhere.
00:41:07 <startling> if you have a lot of Configuration -> x functions, it makes sense to have a Reader Configuration instead.
00:41:08 <adnap> I remember something about... taking the result of a function before you actually evaluate it
00:41:16 <adnap> Hm...
00:41:49 <adnap> startling: Is Configuration usually a data type with lots of records?
00:41:55 <levi> That sounds like non-strict evaluation in general.
00:42:00 <startling> adnap, it could be.
00:42:16 <adnap> Would it be silly to use Reader when the first argument is just a simple data type?
00:43:05 <startling> nah.
00:43:11 <levi> Not if you have a whole lot of things that all need that same first argument.
00:44:00 <adnap> Wait a minute...
00:44:20 <adnap> Can you just use function composition instead of bind/Reader?
00:44:26 <startling> not quite.
00:44:39 <adnap> h >>= f = \w -> f (h w) w
00:44:49 <levi> Monads are function composition *plus* extra stuff.
00:44:58 <Twey> adnap: Function composition gives you f (g x); Reader gives you f x (g x)
00:45:00 <startling> \w -> f (h w) w is not f . h
00:45:21 <kqr> (and the kliesli composition (>=>) is the equivalent of function composition but for monadic functions)
00:45:28 <Twey> But Reader is also a Monad, so the reason to use it is to get do-syntax and all the nice stuff that's defined generically on Monads
00:46:03 <adnap> Right, so... h :: r -> a, f :: a -> (r -> b), f (h w) :: (r -> b)
00:46:04 <adnap> I see
00:46:29 <adnap> I think I  actually see f x (g x) a lot in my code
00:46:45 <adnap> Maybe I should use Reader :P
00:47:18 <startling> a neat thing about Reader is that (->) r works the same way. :)
00:47:27 <adnap> Wait...
00:47:30 <levi> The nice thing about non-IO monads is you can use them for portions of your program and get things out of them afterwards.
00:47:33 <adnap> Yeah!
00:47:40 <adnap> You can use Reader without a data constructor
00:47:55 <adnap> So, why the hell not use it if you can avoid typing 'x' twice?
00:48:12 <Twey> Well, you have to write a ‘runReader’ instead
00:48:16 <startling> :t (,) <$> id <*> id
00:48:17 <startling> (,) <$> id <*> id :: a -> (a, a)
00:48:28 <adnap> Twey: Not if you just use functions, right?
00:48:38 <adnap> You can just use the Monad instance for functions
00:48:43 <startling> Reader /is/ kind of silly, yeah.
00:48:44 <Twey> Sure
00:48:56 <Twey> It's a popular point-free technique
00:49:01 <startling> ReaderT composes with other monads in a way (->) r doesn't.
00:49:18 <adnap> startling: Oh, that's a cool pattern!
00:49:33 <adnap> Take any functions a -> b, a -> c, a -> d, and make a -> (b, c, d)
00:50:02 <adnap> So, you don't have to write \x -> (f x, g x, h x)
00:50:10 <startling> adnap, right.
00:50:15 <adnap> Just (,,) <$> f <*> g -- yeah
00:50:30 <startling> it comes up not infrequently.
00:50:35 <adnap> Okay, I should have been using Reader
00:50:40 <adnap> "not infrequently
00:50:46 <adnap> frequently
00:50:53 <startling> not quite frequently. :)
00:51:01 <adnap> I see
00:51:05 * adnap laughs
00:51:36 <adnap> Fallacy of excluded middle
00:51:53 <startling> heh
00:52:48 <adnap> Hm...
00:52:54 <adnap> What do you use State for?
00:53:02 <adnap> What specific things?
00:55:59 <startling> um, it's hard to say.
00:56:27 <edwardk> c_wraith: yes, bounded CA also form a comonad. https://www.fpcomplete.com/user/edwardk/cellular-automata/part-3
00:56:50 <c_wraith> ah, thanks.
00:57:18 <startling> oh, neat. I've never seen a bounded one.
00:57:48 <levi> State is at the heart of monadic parsing
00:57:56 <c_wraith> Related question: I need something of the shape f (f a -> a) -> f a...  ok, that's loeb, isn't it.  Ok, I don't even need comonads
00:58:08 <startling> levi: oh, that's a good point
00:58:21 <adnap> Well, that makes sense
00:58:28 <adnap> You want to carry around what's unparsed
00:58:31 <startling> right.
00:58:33 <adnap> And keep what has been
00:58:52 <adnap> Hm...
00:58:56 <adnap> State is somehow like Writer
00:59:00 <adnap> Ot
00:59:13 <adnap> Writer is State where the state is a monoid?
00:59:25 <startling> Writer is State where all you can do is mappend to it.
00:59:40 <bitemyapp> adnap: specifically, you're foregoing things State can do that Writer cannot.
00:59:48 <startling> (and you can't 'get', either.)
00:59:58 <Twey> adnap: State is like a combination of Reader and Writer.  It passes in an argument like Reader, but like Writer, the argument that's passed in is not constant but based on the output of the previous action
01:00:32 <bitemyapp> Twey: Reverse State >:)
01:00:35 <adnap> But Writer's log changes too
01:00:49 <adnap> Er,
01:00:52 <adnap> Nevermind!
01:01:11 <startling> adnap, well, mappend is always associative, so you can group parts of the Writer action together whichever way is convenient.
01:01:17 <c_wraith> Huh.  I actually found a problem that made me derive a need for loeb.  Nevermind that it's the exact same problem chrisdone talked about solving with loeb. :)
01:01:18 <Twey> adnap: But Writer can't use previous results when deciding what to output
01:02:07 <levi> Writer doesn't necessarily 'log' either.  It could summarize.
01:02:10 <bitemyapp> c_wraith: I was looking at that problem, the column summing solution made the most sense to me.
01:02:30 <bitemyapp> levi: as long as it's an accumulated result, yes?
01:02:39 <levi> Yeah.
01:02:59 <Twey> bitemyapp: Any Monoid works.  That includes things like Last that forget some of the information that was mappend'ed to them.
01:03:00 <c_wraith> bitemyapp: I'm not actually structuring my solution the same way he did. But I'm using loeb with to tie the knots the same way.
01:03:18 <adnap> I'm going to read this automata page for no reason
01:03:35 <c_wraith> err.  -with
01:05:31 <adnap> edwardk: In Part I, I remember that you had to use memoizing on Store. Does the act of extendeding and then fmapping produce Stores with increasing numbers of composed functions in them?
01:06:02 <edwardk> well, look at any one element in the new store
01:06:20 <edwardk> its made up of calls to get the state from an ever growing window of previous stores as you go farther back in time
01:06:26 <edwardk> and those calls wouldn't be memoized
01:06:57 <edwardk> so n timesteps in, you're going to access a window 2n+1 wide in your nth ancestor generation
01:07:11 <edwardk> without memoization that takes you to quadratic time
01:07:33 <adnap> Okay, I need to re-read, because I don't remember anything about the window size changing
01:07:40 <edwardk> with memoization you're accessing one generation back, touching 3 things, linear time
01:07:42 <edwardk> it doesn't
01:08:15 <adnap> I thought the previous steps were just being repeated on the same window at each new step
01:08:17 <edwardk> but think of it this way, you access the 3 entries in the previous store, but THEY access 3 entries in their previous store.
01:08:35 <edwardk> but 2 of your ancestors are offset by 1
01:08:50 <edwardk> so across 2 generations you're touching 5 cells.
01:10:04 <kqr> if one has a type with a bunch of constructors, like so: data X a = A a | B a | C a | D a ... is there a quick way to get the `a' value given an `X a' value?
01:10:41 <edwardk> cell_3,3 accesses cell_2,2 cell_2,3 and cell 2_4  but cell_2,2 accesses cell_1,1 cell 1,2 cell 1,3   while cell 2,3 hits cell_1,2 1,3 1,4  and 2,4 hits 1,3, 1,4 and 1,5. so you hit 1,1..1,5 in generation 1 from generation 3.
01:10:48 <kqr> i guess pattern matching might be my only option. its okay though because i only have a few constructors
01:11:20 <Twey> kqr: No.  If you have duplication like that it might be a good idea to split it into two types.
01:11:46 <Twey> data X = A | B | C | D; data XWith a = XWith X a -- though that's just a pair
01:12:10 <kqr> ah
01:21:11 <augustss> Yo!
01:21:44 <dcoutts_> g'morning
01:34:14 <augur_> smart people are awake! smart people like edwardk! :o
01:34:21 <augur_> hello smart people!
01:34:53 <arkeet> edwardk is always awake.
01:34:59 <augur_> :x
01:35:07 <quchen> arkeet: Or at least his sentient IRC bot
01:35:19 <augur_> edwardk: do you happen to know if there are any methods for doing nested interactions?
01:35:53 <arkeet> I can't get by with a couple hours of sleep anymore like when I was younger. :(
01:36:44 <quchen> Anyway, I have a question about type theory. I always read the [Var] inference rule as an odd tautology, can someone explain to me how it works? For comparison, it's the first one here: http://stackoverflow.com/questions/12532552/what-part-of-milner-hindley-do-you-not-understand
01:37:20 <quchen> It looks like "if x has type sigma in Gamma, then Gamma contains x of type sigma" to me
01:37:32 <augur_> quchen: yes and no
01:37:37 <augur_> what you're doing is changing judgments
01:37:44 <augur_> |- is a typing judgment
01:37:49 <augur_> \in is a lookup judgment
01:38:16 <quchen> You're right, I don't really understand the difference between |- and "flip \in".
01:38:32 <augur_> quchen: it might help to see how this gets implemented in an actual system, so let me write up some code for you in agda
01:39:12 <quchen> augur_: For context, I've read the first couple of chapters of TAPL, but the question remains. Guess I missed a lot of the enlightenment ;-(
01:39:25 <augur_> youll understand soon enough :)
01:39:33 <quchen> Oh. Well that's encouraging :-)
01:48:48 <augur_> quchen: http://lpaste.net/95750
01:49:43 <quchen> Oh, that's a minimal implementation of dependent types in Agda?
01:49:50 <augur_> quchen: no dependent types
01:49:51 <quchen> Eh, types
01:49:53 <augur_> just simple types
01:49:53 <quchen> Right.
01:49:59 <quchen> Overshot a little there. :-)
01:50:13 <augur_> but you notice that what \ni is doing is indexing into contexts
01:50:38 <augur_> basically, its just nats, bounded by the size of the context to prevent out of bounds errors
01:50:47 <augur_> we bound it by indexing them by the contexts
01:50:58 <augur_> but also by the type, thereby enforcing type safety
01:51:27 <augur_> this is of course an intrinsic representation -- the proofs of the judgments are the terms
01:51:33 <quchen> This is going to take me some time to understand
01:51:45 <augur_> we could separate the terms from the proofs, but that would be pointless
01:51:58 <augur_> quchen: let me give you another related example
01:52:09 <quchen> So you have three primitive types, Void/Unit/Bool.
01:52:17 <augur_> yep
01:52:28 <quchen> Then there are two binary type constructors, × and ⇒
01:52:31 <augur_> thats inconsequential, really
01:52:57 <augur_> the Type type is whatever you want your core types to be
01:52:59 <quchen> Yeah but I'd like to understand the easy part of the code before I get to the one that answers my question :-)
01:53:15 <quchen> Ctx is what?
01:53:30 <quchen> Looks listy.
01:53:39 <augur_> ctx is just lists of Type
01:53:41 <augur_> snoc lists
01:53:52 <quchen> What does the name stand for?
01:53:57 <augur_> "context"
01:54:09 <quchen> Ah, so that models \Gamma.
01:54:11 <augur_> right
01:54:16 <augur_> hence the G's all over the place :)
01:54:29 <quchen> Aaah.
01:54:48 <augur_> consider:
01:54:52 <augur_> data Index {A : Set} : List A → Set where
01:54:52 <augur_>   top : ∀ {x xs} → Index (x ∷ xs)
01:54:52 <augur_>   pop : ∀ {x xs} → Index xs → Index (x ∷ xs)
01:55:46 <augur_> Index [0,1,2,3]   is a pointer to a position in this list. it can't point outside of the list because the type family is constrained appropriate by indexing by the list
01:56:00 <quchen> Is that a new example?
01:56:03 <augur_> yeah
01:56:12 <quchen> Slow slow slow (remember how I didn't answer when you asked for smart people?)
01:56:20 <augur_> :p
01:57:04 <augur_> thats the general way to define a bounded index into a list, so that you can never get out-of-bounds errors with your index-projecting functions
01:57:41 <augur_> so like instead of _!_ : forall {A} -> List A -> Nat -> A   which is unsafe, and instead of _!_ : forall {A} -> List A -> Nat -> Maybe A   which is nasty
01:57:44 <augur_> you do stuff like
01:57:44 <quchen> The ∀ part is what would be the implicit ∀ in Haskell?
01:57:48 <augur_> yes
01:58:00 <augur_> _!_ : forall {A} -> (xs : List A) -> Index xs -> A
01:58:23 <augur_> given a list, and then an index into _that list_, i can give you an A, guaranteed
01:58:34 <quchen> So top says "If you have x and xs, then there is an index for the elements in x :: xs"
01:58:37 <augur_> because i know the index you give me is in bounds
01:58:40 <quchen> In other words, it excludes the empty list
01:58:45 <augur_> nope!
01:58:55 <augur_> because its an index into x :: xs
01:58:57 <augur_> not into []
01:59:11 <augur_> notice that top and pop both return Index's into cons lists
01:59:21 <augur_> there is no way to make an index into the empty list
01:59:33 <quchen> Isn't that what I said?
01:59:42 <augur_> oh sorry, i misread that as includes :X
01:59:54 <augur_> yes, it excludes the empty list, right
02:00:18 <quchen> Alright, and pop is "head" but requires a proof that the list is non-empty (i.e. is indexed)
02:00:29 <quchen> ..?
02:00:37 <augur_> top you mean?
02:00:42 <quchen> Wait, it's not head
02:00:44 <quchen> No I mean pop
02:00:49 <quchen> What is pop doing
02:00:56 <Twey> top: the list (x , xs) includes x.  pop: the list (x , xs) includes y if xs includes y
02:00:57 <augur_> its not quite head. head is a function that gives you part of the list
02:01:03 <augur_> pop is saying
02:01:32 <augur_> quchen: if you have an index into a list xs, then i can give you an index into the list x :: xs
02:01:53 <augur_> quchen: its called pop because when you go to find the element it points to, you pop the top element of the list and keep going
02:03:09 <augur_> quchen:
02:03:12 <augur_> _!_ : ∀ {A} → (xs : List A) → Index xs → A
02:03:12 <augur_> [] ! ()
02:03:12 <augur_> (x ∷ xs) ! top = x
02:03:14 <augur_> (x ∷ xs) ! pop i = xs ! i
02:03:19 <quchen> I still don't see how this is an index. It looks like "Indexed" is just "NonEmpty".
02:03:50 <quchen> Ah
02:03:50 <augur_> does that clarify it a little bit?
02:04:07 <quchen> Maybe. Hold on a second.
02:04:22 <augur_> notice that when the list is empty, there are not indexes into it, so we get to say, "nonsense! i dont have to tell you what to do!" using ()
02:04:36 <augur_> and thereby avoid having to give a definition for that case
02:04:46 <augur_> because we know it can never arise in type-checking code
02:05:02 <augur_> the important part tho is the _::_ case
02:05:09 <augur_> if the list is a cons, we look at the index
02:05:17 <augur_> if it says we give back the top element, we give it back
02:05:38 <augur_> otherwise if it says we pop and continue with i, we throw away the top element and continue indexing
02:05:46 <kqr> is there a sort of "Num a" division, that does (/) on types where it is possible, and div on types where that is all you get?
02:06:07 <augur_> its just like normal _!_, except we get this enforced fact that the index is in range
02:06:31 <quchen> I think at least my stomach get it now.
02:06:35 <augur_> quchen: it might help to try to give a value of type Index [0,1,2]
02:07:22 <augur_> quchen: ok so if you get that, then _\ni_ is not too different
02:07:36 <augur_> it also indexes by a list, but the fixed list of types Ctx
02:07:50 <augur_> we couldve used List Type but we want snoc lists so
02:08:11 <quchen> Hold on a second.
02:08:19 <quchen> (x ∷ xs) ! top = x
02:08:22 <augur_> holding pattern engaged
02:08:23 <Twey> quchen: The thing I think you're confused by (in your original question) is that Γ ⊢ x : τ is a ternary relation _⊢_:_ between Γ, x, and τ, not a binary relation _⊢_ between Γ and x : τ.  The Var rule is necessary to give meaning to the context: it says that if the context Γ contains an entry of the form ‘x : τ’ (this *is* a binary relation), then you can make the judgement that Γ ⊢ x : τ
02:08:23 <quchen> Doesn't that always match?
02:08:44 <augur_> quchen: not if the list is empty or the index isn't top!
02:08:58 <quchen> Twey: Right, _⊢_:_ is more like a triple of type, name, context.
02:09:31 <quchen> augur_: Ah, the link between that "top" and the "x :: xs" part is created by the type signature?
02:09:40 <quchen> (They looked uncorrelated to me)
02:09:42 <Twey> quchen: Right.  So the ‘Var’ rule relates ‘what's in the context’ and ‘what judgements I can make as a result’.
02:09:52 <augur_> quchen: because we're in dependent type land, yes, sort of
02:10:08 <augur_> quchen: when we look at the list, we find out more about the type of the index
02:10:16 <augur_> if we know xs = [], then we know i : Index []
02:10:29 <augur_> and there are no indices of that type, so we get to say ()
02:10:44 <augur_> which is agdas way of saying "not gonna happen"
02:11:03 <augur_> if we know xs = x :: xs', then we know i : Index (x :: xs')
02:11:14 <augur_> now if we match on i, it can be either top or pop
02:11:39 <augur_> because the return type of those constructors is of the form Index (x :: xs')
02:12:28 <augur_> quchen: this is what the inference rules are doing too, but less explicitly so
02:13:28 <augur_> often you dont explicitly have rules for \ni, but this is basically what they are
02:13:31 <Twey> quchen: A little bit further on in TAPL Pierce goes into linear types, where the Var rule is less obvious (you can only give a type to a variable if the context is devoid of other linear types)
02:13:50 <quchen> Twey: I think lots of redundant parentheses would help me a lot in those formulas. So the Var rule is "(x : σ) ∈ Γ  ===>  Γ ⊢ x : σ"
02:13:57 <augur_> you can of course do something silly like just look up the pair (x,t) in the context, but
02:14:02 <Twey> quchen: Right
02:14:43 <augur_> quchen: the "naughty" way to do this is to just do type Ctx = [(Var,Type)]
02:15:07 <augur_> and then x : s \in G is just (x,s) `elem` g
02:15:20 <Twey> s/linear types/linearly-typed variables/
02:15:38 <augur_> but thats a silly way to understand whats going on, because its too implementation specific
02:16:03 <augur_> you want a nice explanation, because as Twey says, there are fancier schemes
02:16:09 <augur_> and those fancier schemes are just variations on
02:16:13 <augur_> on the scheme i described
02:16:17 <augur_> quite simple variations, actually
02:16:33 <quchen> With that in mind, let me revisit your first example.
02:16:41 <quchen> (that one: http://lpaste.net/95750)
02:16:46 <augur_> yeah
02:17:02 <quchen> ∋ is your way of writing ⊢ in the code there?
02:17:13 <quchen> Or is it flipped for other reasons
02:17:44 <augur_> its fliped just because its nicer than reversing the position of gamma
02:17:52 <augur_> \ni == flip \in   ofcourse
02:18:00 <augur_> but i'd rather keep the contexts on the left
02:18:11 <Twey> quchen: It's not related to ⊢ except by Var
02:18:20 <augur_> oh, i forgot, quchen
02:18:26 <augur_> in Term we need to add a rule
02:18:36 <augur_> var : forall {G T} -> G \ni T -> G !- T
02:18:55 <augur_> if you have an index into a context, you have a term in that context
02:19:46 <augur_> there, fixed
02:19:51 <quchen> !- is what?
02:19:55 <augur_> Term
02:20:11 <quchen> And in mathematical notation?
02:20:18 <augur_> the turnstile
02:20:22 <quchen> It looks like ⊢ but with an exclamation mark.
02:20:32 <augur_> ascii turnstile, yes
02:20:33 <quchen> Oh, that's because you can't use | in Agda for syntax reasons
02:20:43 <Twey> quchen: augur_ has embedded the type into the term
02:20:44 <augur_> i can use \vdash
02:20:45 <augur_> but
02:22:01 <Twey> quchen: Such that the Agda type of each term contains its own type instead of having a separate typing derivation outside
02:22:09 <augur_> right
02:22:22 <augur_> thats what i was saying before about intrinsic vs extrinsic stuff
02:22:23 <quchen> Simple simply typed lambda calculus.
02:23:24 <quchen> So <> says that in every context Γ, there is a term which is the unit type
02:23:47 <quchen> And the same for the booleans and tuples.
02:25:11 <augur_> quchen: ive modified the code
02:25:29 <augur_> ive done the cunning Conor thing of using comments to make the thing look more like natural deduction :)
02:25:45 <augur_> quchen: <> sort of _is_ the term
02:26:15 <augur_> its both the term and the type checking rule wrapped up in one
02:26:24 <augur_> why bother having a type for untyped terms
02:26:27 <quchen> I feel like I'm having more problems with understanding Agda than the actual problem here :-(
02:26:35 <augur_> and then a whole other type for proofs!
02:26:43 <augur_> quchen: yes, well, thats possible :)
02:26:50 <quchen> I miss my whiteboard
02:27:12 <augur_> quchen: anyway, the answer to your question ultimately is just that the Var rule shifts to a new kind of judgment -- the context membership judgments
02:27:30 <augur_> !- is for typing, \in or \ni is for context membership.
02:28:12 <augur_> context membership is sort of a particular flavor of typing, of course, which is why the Var rule exists -- to embed context membership into typing in general
02:29:26 <augur_> the standard type-theoretic way to explain context membership is like ive been doing -- as a separate judgment that looks at the structure of the variable and context
02:29:54 <augur_> another way, if you're using proper names instead of de bruijn indices, is to just look it up in the context
02:30:45 <augur_> in the TT, you'd do it similar to what i did, except you'd do something like use the implicit syntactic equality to do something like this:
02:30:55 <augur_> G, x : T \ni x : T
02:31:14 <augur_> G \ni x : T   ===>   G, y : S \ni x : T
02:31:30 <rerecord> how do i map read? like say map (read :: Int) ["1", "2"]
02:31:46 <rerecord> > map (read :: Int) ["1", "2"]
02:31:46 <augur_> which you'll notice is using implicit equality to effectively do the same work that elem does
02:32:00 <donri> > map read ["1","2"] :: [Int]
02:32:04 <augur_> rerecord: read is not an int tho is it
02:32:08 <augur_> :t read
02:32:23 <augur_> :|
02:32:27 <donri> > map (read :: String -> Int) ["1","2"]
02:32:37 <quchen> augur_: I think I understood enough now to make re-reading TAPL worhwhile. Thanks a lot for your time and explanations
02:32:41 <augur_> well there you go, donri, giving away all the answers!
02:32:52 <donri> \o/
02:33:12 <augur_> quchen: usually you can be loose with what \ni really means
02:33:31 <rerecord> I got it now..thanks..
02:34:03 <augur_> because that comes down to things like efficiency, etc. if you want to be really precise and make your type theory to a LOT of work, you dont leave context membership to change, you bake all the stuff in like i tried to show you
02:35:02 <augur_> quchen: fwiw, a lot of type theories dont have a separate \ni judgment
02:35:11 <augur_> quchen: they usually just do   G, x : T !- x : T
02:35:25 <augur_> with the implicit assumption that the order of contexts is irrelevant
02:35:39 <rerecord> handling IO is a little bit difficult for starters in haskell, compared to other languages.. im having a hard time..
02:36:15 <augur_> quchen: or you could say, G, x : T, G' !- x : T   if you want to treat order as relevant
02:36:22 <quchen> augur_: One last thing about the syntax in these formulas: Γ in the numerator (hnnng) is always the same as in the denominator, right? It's not that Γ simply refers to "the current context"
02:36:40 <augur_> quchen: right, except for lam!
02:36:56 <augur_> because thats binding a free var
02:37:58 <augur_> quchen: we could be very general with it all, too, and get rid of fst and second, instead using pair case:   pair-case : forall {G S T R} -> G !- S * T -> G , S , T !- R -> G !- R
02:38:40 <augur_> which in a more sane world is written like this:
02:39:22 <augur_> G !- P : S * T   G, x : X, y : Y !- M : R   ===>   pair-case P of { <x,y> -> M }
02:39:25 <augur_> or something like that
02:39:53 <augur_> er...   G !- pair-case P of { <x,y> -> M } : R
02:41:00 <quchen> That's way beyond me I'm afraid.
02:41:05 <augur_> quchen: :p
02:41:15 <augur_> quchen: dont worry. youll understand it eventually!
02:41:21 <quchen> In fact I don't even know whether it's way beyond me because I can't read that line.
02:41:27 <mangaba_leitosa> lol "Anyone trying to understand monads will inevitably run into Haskells IO monad, and the results are almost always the same: bewilderment, confusion, anger, and ultimately Perl"
02:41:54 <quchen> You know you're a beginner when "G !- P : S * T   G, x : X, y : Y !- M : R" makes sense in O(n!) different parenthesizations. And yes I just invented that word.
02:42:07 <mangaba_leitosa> http://www.codecommit.com/blog/ruby/monads-are-not-metaphors
02:42:09 <augur_> quchen: hahaha
02:42:21 <augur_> quchen: _!-_:_ always binds weakest
02:42:40 <augur_> then _:_ then _,_
02:42:43 <dv-> is that an agda joke
02:42:47 <augur_> dv-: no
02:42:51 <quchen> G !- P : S * T   G, x : X, y : Y !- M : R           ========         G !- P : (S * T   G, x : X, y : Y !- M : R)
02:42:53 <quchen> ?
02:43:05 <quchen> I hope I'm not being kicked for spamming Freenode with random characters.
02:43:12 <augur_> quchen: no no sorry
02:43:15 <augur_> lemme rephrase it
02:43:28 <augur_> wide spaces bind even weaker :P
02:43:42 <augur_> i use spaces to indicate separate premises
02:43:57 <quchen> augur_: You now get a new syntax rule. If you can add a parenthesis do it.
02:44:07 <augur_> lol
02:44:21 <quchen> And don't tell me the obvious that that rule is divergent :-P
02:45:31 <augur_> (G !- P : (S * T)) (((G , (x : S)) , (y : T)) !- M : R) ===> (G !- (pair-case P of { <x,y> -> M }) : R)
02:46:21 <quchen> augur_: Maybe we should move this to overflow anyway. There are people trying to learn Haskell here it seems.
02:46:30 <augur_> quchen: just read tapl XP
02:50:48 <kqr> is there a quick way to say "true if any of the two-tuple elements are equal to x" without lenses? currently i'm doing (\t -> fst t == a || snd t == a) which doesn't feel very elegant
02:51:21 <edwardk> > anyOf both (=='a') ('a','b')
02:51:35 <edwardk> kqr: sadly that uses lens =)
02:51:55 <edwardk> nothing pretty otherwise
02:52:11 <Cale> (\(x,y) -> any (== a) [x,y])
02:52:16 <kqr> yeah. i'm working on an assignment for school and it has to run only using the haskell platform. i've been facepalming several times now when i've realised how much neater it would be if only i had access to lens
02:52:29 <arkeet> :t anyOf both (== ?a)
02:52:39 <arkeet> helloooo
02:52:44 <kqr> no lambdabot for you
02:52:59 <arkeet> (also, lenses /= lens)
02:53:10 <arkeet> what happened to lambdabot =(
02:53:18 <arkeet> elliott isn't here either, I can't blame him.
02:53:25 <kqr> (yeah lens the package, lenses the concept, i guess)
02:54:05 <arkeet> I think we've settled on "optics" for the general term.
02:54:08 <kqr> Cale, maybe that's nicer. particularly if i wrap it in a function. i'll think about it
02:54:13 <mangaba_leitosa> edwardk: I wanted to try Data.Vector.Map for counting word frequencies, but was stopped by depedency requirements... Do you think it's worth trying? I tried solving "counting word frequencies" using Data.Map (slow), Data.TrieMap (slower than Data.Map), Data.HashMap (fastest among immutable structures) and Data.HashTable (fastest, but mutable). Any chance that Data.Vector.Map will be faster?
02:54:18 <Javafant> Hi, I'm new to haskell and I have some trouble understanding hxt: I managed to get all nodes who have a certain name but now I want to filter out all nodes who contain a children with a certain name. I tried to find some examples but I wasn't able to do so.
02:55:32 <edwardk> mangaba_leitosa: data.vector.map is still a work in progress. the dependencies are to make it easier for me to think while developing
02:55:42 <mangaba_leitosa> edwardk: yes, I understand
02:56:34 <edwardk> honestly in its current state i don't know how well it'd work for the counter-like usecase. there is a variant of the design that can accumulate a monoidal result for the values very easily and much more efficiently than the current approach
02:56:41 <edwardk> but i haven't bundled it yet
02:57:06 <augur_> edwardk!
02:57:07 <edwardk> basically right now you ave to read then write, but reading is slower than writing, so its better to just write in the monoidal value, and when they merge, merge them
02:57:28 <edwardk> ack! it's an augur. run!
02:57:31 <augur_> :x
02:57:40 <augur_> edwardk: how can i do nested interaction nicely?
02:57:55 <edwardk> in what sense?
02:58:05 <Javafant> Ah I think A just got it working
02:58:20 <mangaba_leitosa> edwardk: aha. ok, then looking forward for when it's better suited for counters :-)
02:58:24 <mangaba_leitosa> edwardk: thanks
02:58:29 <augur_> edwardk: like, interaction with a user where the user's input can always potentially trigger a sub-response from the UI
02:58:40 <edwardk> augur_: no idea. =)
02:58:54 <augur_> edwardk: eg, you issue a command and the UI says "do you mean ...?" in a sub-dialog, etc etc
02:58:59 <Cale> Javafant: Cool, I was going to have a look for you, but it's been a long time since I've touched HXT
02:59:08 <augur_> i feel like its vaguely continuation-y
02:59:20 <Javafant> Cale: do you use another xml lib or do you just not work with xml anymore?
02:59:30 <Cale> A bit of both
03:00:05 <Javafant> hxt seemed to be the most used to me, so I tried that one
03:00:41 * hackagebot shake 0.10.10 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.10 (NeilMitchell)
03:01:06 <marko2> Hi everyone. What is a good way of parsing a huge binary stream of this form: "[blob length][payload][blob length][payload]..."? I am using Attoparsec.ByteString.Lazy, but I cannot get rid of memory leaks
03:01:09 <Cale> If I were forced to parse/generate XML, I'd probably hope to go via hexpat-pickle or something like it, and make datatypes to reflect all the XML structure.
03:02:13 <Cale> HXT is okay, but it reflects all the complication of XML, which I suppose is sometimes appropriate, but often a bit too much.
03:02:25 <marko2> I want to skip over the payloads and build a list of blocks
03:02:34 <Javafant> Cale: k
03:02:40 <Cale> Also, the fact they decided to go with Arrow for some weird reason is strange, given that it's really secretly a monad.
03:04:49 <edwardk> i suppose it depends on how modal a user interface you want
03:06:57 <Cale> (and it's not a very good Arrow -- it doesn't satisfy the interchange law for *** and >>>)
03:08:30 <Cale> marko2: You're using take and it's consuming all the memory for the intermediate chunks?
03:09:36 <marko2> Cale: I tried different things: 1) AP.take but discarding the output 2) AP.scan. I am looking for a way to skip over N bytes without memory leaks
03:11:18 <Cale> Hmm, I wonder why just discarding the output of AP.take isn't working. I can't see a reason why it shouldn't work. In fact, looking at the code, it looks lazy enough to not even bother computing the result in that case.
03:11:29 <marko2> Cale: as a workaround I can imageine parsing only the blocklength, run the parser and manually drop the payload from the remaining bytestring, and repeating that. I don't think it is very elegant, though
03:12:29 <Cale> oh, ensure
03:12:35 <Cale> hmm
03:12:42 <marko2> ensure is not exposed
03:13:02 <marko2> Cale: I got the idea for the workaround from this post: http://stackoverflow.com/questions/4151265/attoparsec-allocates-a-ton-of-memory-on-large-take-call. Looks similar
03:13:30 <Cale> marko2: Yeah, but take uses it. I'm just trying to work out why you'd see lots of memory usage out of that
03:14:05 <marko2> Cale: yesterday someone said it is not attoparsec's fault but rather that I am using lazy bytestrings
03:14:21 <marko2> I don't know, it seems natural to use that
03:14:29 <Cale> Well, what does your program do?
03:14:40 <Cale> (can I see it?)
03:15:20 <Cale> Having looked at what ensure does, I'm pretty sure it ought not to leak as well, so I don't know
03:16:20 <marko2> If you wanted to parse 10gb of this simple format (4 bytes which encode the length of the following payload, then skip over the payload), how would you do it?
03:17:19 <Cale> Well, what you're doing sounds reasonable
03:17:41 <Cale> oh
03:19:58 <c_wraith> drat, edwardk started me reading a huge tree of articles, and has apparently gone to sleep before I found a bug in the root of that tree! (typo kind of bug, not reasoning error)
03:21:49 <Cale> marko2: Okay, I think I might understand what's going on.
03:22:18 <marko2> Cale: By the way, you can look at the relevant things here: http://lpaste.net/5545718105386254336
03:22:25 <Cale> AP.take is using B.unsafeDrop which, looking at ByteString, is something which operates on strict bytestrings, and just adjusts an integer representing the starting position in a chunk of memory internally, so whatever it results in is going to use the same amount of memory as before.
03:23:14 <Cale> I think perhaps the machinery attoparsec uses to support lazy bytestrings is just taking advantage of strict attoparsec parsers' ability to demand more input
03:24:02 <marko2> Cale: which sounds reasonable.. thanks for your help. What about scan?
03:24:20 <Cale> and the 'ensure' inside of AP.take is going to result in the strict bytestring chunk that the parser is really acting on is extended until it's as long as it needs to be
03:25:00 <Cale> (and that's where all your memory is going)
03:25:28 <marko2> So "ensure N" loads a strict bytestring of size N?
03:25:56 <Cale> Indirectly, but yeah.
03:26:08 <fxr> ~.
03:26:14 <fxr> ups
03:26:25 <Cale> If the (strict bytestring) input is long enough, then it succeeds with the entirety of the input as its result
03:26:50 <Cale> If not, then the parser's result is a Partial
03:27:19 <marko2> and Attoparsec.ByteString.Lazy.parse feeds the Partial result with the next chunk
03:27:26 <Cale> (i.e. a continuation is supplied for the caller to be able to resume the parser with more input)
03:27:26 <Cale> yeah
03:28:19 <marko2> Do you think there is a way to make it work without handrolling the loop? It would be really elegant if I could just feed a lazy bytestring to the parser and consume it from inside the parser
03:29:09 <Cale> Let's try Data.Binary.Get
03:29:28 <Cale> It's meant to operate on lazy bytestrings directly
03:29:56 <marko2> I thought about it, but then I would lose all the nice things that attoparsec provides. For example, parse an exact string
03:30:56 <marko2> As an aside: is there anything that makes it impossible for attoparsec to support "skip n" or is it just not implemented yet?
03:32:04 <Cale> Well, using AP.take and ignoring the result is the closest you can get with Attoparsec
03:32:13 <Cale> (so in a way it already does)
03:32:40 <Cale> But the way that it handles lazy bytestrings here isn't so great
03:32:50 <marko2> with proper support for lazy bytestring :)
03:35:39 <marko2> about Data.Binary.Get: I was hestitant about using it because it is harder for me to use. For example, if I issue a fail (fail "error message"), it works like expected, but this doesn't: many (parsesomething *> fail "error")
03:35:48 <Cale> I have a dumb idea which is crazy enough that it might work
03:35:56 <marko2> Cale: yes please? :)
03:36:40 <Cale> Use pipes-attoparsec along with pipes-bytestring (Pipes.ByteString.fromLazy)
03:37:19 <marko2> Cale: coincidentally this is what I just tried: let (a,b) = flip runState (PipesBS.fromLazy s) $ PA.parse parseBlocks
03:37:42 <marko2> but it produces the same behaviour, unless I am missing something / using it wrong
03:38:20 <Cale> ah, okay
03:38:27 <Cale> Well, it was worth a shot
03:38:37 <marko2> Yeah, thanks.
03:38:40 <Cale> hm
03:38:47 <Cale> Maybe using Parsec proper would do
03:39:01 <Cale> Parsec can operate directly on lazy bytestrings
03:39:12 <marko2> Even if I want max. performance?
03:39:57 <Cale> Well, if you're *just* parsing this language of chunks followed by anything of that length, then yeah, Parsec is overkill
03:40:04 <Cale> But it sounds like you're actually doing something more?
03:40:44 <marko2> The binary blobs can be parsed themselves, I have just not yet decided if I want to parse them from the start or defer that until the user needs it
03:40:52 <kqr> is there a neater way of doing `\(a,b) -> f a . f b'? pointfree didn't give me much
03:41:09 <donri> :t over both
03:41:19 <donri> no lambdabot :(
03:41:27 <marko2> Cale: so I am experimenting with parsing only the header with a reference to the blob to make it fast
03:41:28 <Cale> kqr: I think that's fine personally.
03:41:52 <kqr> right
03:42:03 <Cale> marko2: Yeah, probably the easiest way to get something done is just to parse the header, and take the remainder of the string and chop it yourself.
03:42:18 <Cale> It's a bit of a shame that Attoparsec seems to fall over in that case.
03:43:00 <donri> kqr: anyway lens gets you "over both f", bifunctors gets you "bimap f f", Control.Arrow gets you "f &&& f"
03:43:03 <Cale> (I haven't used it all that often myself, so I dunno, maybe someone else would know a better trick to coerce it into having good behaviour)
03:43:18 <benmachine> :t uncurry ((.) `on` f)
03:43:20 <donri> no wait it's ***
03:43:26 <donri> i always mix those two up
03:43:27 <benmachine> oh
03:43:36 <marko2> Cale: yeah, what I am after is fast performance + elegance, so I tried to avoid handrolling my own loop.
03:43:49 <benmachine> donri: no, that's \(a,b) -> (f a, f b)
03:43:52 <marko2> Cale: maybe I will give Binary another shot
03:44:03 <marko2> Cale: do you think I I should open a issue on github for this?
03:44:08 <donri> benmachine: doh, totally misread the question
03:44:29 <benmachine> kqr: try "uncurry ((.) `on` f)"
03:45:24 <Cale> marko2: Yeah maybe. It'd be a bit of a project to fix, if I understand the problem correctly, but it's something that's worth doing.
03:46:02 <Cale> marko2: Well, maybe not that hard of a project. Just duplicating the functionality for strict bytestrings, and using lazy ones instead should actually work better.
03:46:14 * benmachine notes uncurry (on (,)) as another way of spelling join (***)
03:46:31 <marko2> Cale: okay, thanks for everything. Much appreciated!
03:46:42 <Cale> (It looks like they're trying to avoid that, and it's biting you, because the parsers really only work on strict bytestrings at some level)
03:47:36 <kqr> benmachine, quite nice
03:47:48 <kqr> donri, thanks
03:48:00 <kqr> donri, i'm starting to feel like i need to look into Control.Arrow...
03:48:53 <Cale> This is incidentally one of the biggest cases for an ML-style module system for Haskell, imo. There are so many packages where the same code has to be written for strict and lazy ByteStrings, and nobody really wants that to be a class, but at the module level, you'd kind of like to be able to abstract over it.
03:49:43 <marko2> Cale: I see
03:50:42 <marko2> Cale: I am not 100% sure, but I think I had similar problems with Data.Binary.Get at some point
03:51:58 <marko2> anyway
03:58:46 <donri> Cale: or you know, just write everything strict and use pipes for chunking ;)
03:59:10 <Cale> donri: Well, we halfheartedly tried that
03:59:46 <donri> (didn't actually follow the conversation)
04:01:04 <Cale> donri: marko2 has an attoparsec parser which reads a 4 byte chunk length and then uses AP.take to skip over that many bytes
04:02:17 <Cale> donri: Because of the way that the 'ensure' inside of AP.take interacts with the machinery Attoparsec provides for parsing lazy ByteStrings, this results in (more than) the whole chunk being read into a strict ByteString
04:03:15 <Cale> donri: We tried using pipes-bytestring (fromLazy) and pipes-attoparsec, but that didn't appear to help
04:07:53 <marko2> donri: Doing that would be sidestepping the problem: the chunker would need to parse the header and prepare the chunks. I don't really want to do any external plumbing when I could have it all work inside one parser, which I think is much more elegant
04:08:03 <donri> hm i don't follow. take doesn't guarantee to take no more than N bytes?
04:08:42 <marko2> donri: I want to skip over the blob, which should be done in constant space.
04:09:51 <marko2> Data.Binary.Get.skip does work, by the way
04:10:08 <Cale> donri: AP.take is otherwise lazy enough to skip the bytes involved, but the fact that Attoparsec only operates on strict bytestrings means that more input has to be requested repeatedly until there's enough for the whole take to happen
04:10:19 <Cale> marko2: hmm
04:11:22 <Cale> marko2: try  replicateM_ n (take 1)
04:11:29 <donri> hm is the problem then that you can't set the chunk size in attoparsec?
04:11:48 <donri> or bytestring, perhaps?
04:13:45 <Cale> marko2: this should be about as slow as using skip to go through the input, but it also avoids applying ensure to a large value
04:14:19 <marko2> donri: my goal is to be able to build a parser like so: "do { blobLength <- parseBlobLength; skip blobLength; return blobLength; }", working on a lazy bytestring. I don't want to deal with chunk sizes and preprocessing.
04:14:19 <Cale> oh, skip already skips one byte
04:15:29 <jpcooper> hello
04:16:14 <marko2> well replicateM_ n (take 1) blows up too, just slower.
04:17:50 <donri> marko2: and you never want to consume more than you need? sounds like you want [Word8] or a pipe stream of Word8 ...
04:18:11 <donri> i'm quite possibly misunderstanding everything though :)
04:21:29 <marko2> donri: if you name the above parser I wrote "parseBlock", then I want "many parseBlock" as my result, i.e. a list of block sizes of all my blocks. As fast as possible (i.e. skipping over the blocks once I know their size)
04:21:40 <marko2> and in constant space
04:21:50 <marko2> (processing space, obviously not the output)
04:25:43 <absence> where is lambdabot?
04:26:13 <nomeata> someone applied full lazyness to IRC, so he lives now out of the #haskell scope
04:26:16 <FireFly> Apparently they're absent
04:26:20 * FireFly eyes absence
04:27:54 <absence> right right :)
04:31:38 <donri> lambdabot has already answered all the queries, we just haven't evaluated them yet?
04:33:13 <chrisdone> donri: like the ancient proverb, “If you know the candlelight is fire, the meal was cooked long ago.”
04:34:26 <donri> i didn't know you watched stargate :D
04:34:40 <chrisdone> donri: =p
04:41:54 <circle> is Learn You a Haskell the best haskell book?
04:42:01 <circle> how about programming in haskell, by graham hutton?
04:42:53 <merijn> circle: LYAH is good, I haven't read the Graham Hutton one
04:43:06 <kryft> circle: I vaguely remember hearing good things about Hutton's book, but I could be wrong
04:43:07 <merijn> circle: I believe LYAH is more popular because the web version is free
04:43:23 <circle> i know a bunch of otheer languages and i already half-know haskell, but I want to re-learn it properly
04:43:24 <merijn> Yeah, I've heard positive comments about Hutton, but ymmv
04:43:38 <circle> so the more complete the better I suppose
04:43:51 <kryft> circle: I don't think there's anything really 'complete'
04:44:31 <circle> well, I can't decide between hutton and learn you a haskell. I have the former book, the latter is free online
04:44:36 <circle> you guys need to deliberate for me :)
04:44:39 <merijn> LYAH is pretty comprehensive on the basics, but might be a bit slow for people halfway familiar
04:45:08 <merijn> There's also Real World Haskell, but that mostly covers libraries, it's coverage of the basics is far from complete
04:46:21 <circle> eh, I'll stick with programming in haskell since it has exercises
04:46:27 <merijn> circle: Simple solution, read both :p
04:47:42 <siriusbtx> I have a datatype like this: data Matrix = Matrix [[Double]]. Now if I create a Matrix how can I select elements from underlying list? Because the type isnt a list anymore its a Matrix now.
04:47:51 <siriusbtx> (I am a beginner in haskell :P)
04:48:37 <pharaun> man defining a grammar upfront is making it so much easier to build this parser
04:49:07 <Eduard_Munteanu> How do you go about handling inter-symbol transitions with attoparsec without a tokenizing pass? E.g. I want to parse "!foo" as "!" and "foo", but "foobar" shouldn't be accepted as "foo" and "bar".
04:49:39 <Eduard_Munteanu> Should I stick a StateT on the parser perhaps?
04:49:42 <Saizan> siriusbtx: if m :: Matrix you can e.g. "case m of Matrix xs -> xs !! i !! j"
04:49:44 <hpc> Eduard_Munteanu: "!foobar" would be ["!", "foobar"]?
04:49:59 <Eduard_Munteanu> hpc: yes
04:50:10 <siriusbtx> Saizan: thanks
04:50:56 * hackagebot http-monad 0.1.0.3 - Monad abstraction for HTTP allowing lazy transfer and non-I/O simulation  http://hackage.haskell.org/package/http-monad-0.1.0.3 (HenningThielemann)
04:51:02 <Saizan> iirc attoparsec has a fair <|> so it should be even simpler
04:51:30 <kryft> siriusbtx: Probably you'll want to write a function to index the matrix, something like "index row col (Matrix rows) = rows !! row !! col"
04:51:36 <absence> does something like replicateM with accumulation have a name? it's a bit silly to foldM over replicate n ()
04:51:42 <Saizan> (string "!" >> ...) <|> (many1 letter >> ...)
04:51:56 <Eduard_Munteanu> absence: iterateM ?
04:52:56 <FreeFull> char '!'
04:53:45 <absence> Eduard_Munteanu: oh right! doesn't seem to be defined anywhere, guess i'll make my own
04:54:04 <hpc> Eduard_Munteanu: anyhoo, as an applicative parser it'd be something like try (char '!' >> token) <|> token <|> what other parsing rules you have
04:54:11 <hpc> er, s/>>/*>
04:54:25 <Eduard_Munteanu> Saizan: not sure you understood my question, the problem isn't matching "!" and "foo" as separate tokens, rather that string "foo" >> string "bar" also accepts "foobar".
04:55:11 <FreeFull> Eduard_Munteanu: You could designate separators
04:55:33 <siriusbtx> Is it possible to overload !! for my own types?
04:56:02 <FreeFull> You could hide the Prelude !!
04:56:02 <Eduard_Munteanu> Yeah, but I don't have a separate tokenizer pass, so I can't really track transitions unless I write my own applicative.
04:56:05 <FreeFull> And define your own
04:56:26 <siriusbtx> FreeFull: i was looking for a less hacky way :p
04:56:50 <siriusbtx> like c++ that calls the correct function depending on the arguments
04:57:35 <Eduard_Munteanu> Maybe I should resurrect my 'Free Parser' idea and do that when unwinding the parser, though tokenizing first would be just as messy.
04:58:22 <Chousuke> :t (!!)
04:58:40 <Chousuke> hm, how did that work again?
04:59:14 <absence> like that, but lambdabot is gone for some reason
04:59:15 <Eduard_Munteanu> Chousuke: lambdabot isn't here
04:59:20 <siriusbtx> Chousuke: (!!) :: [a] -> Int -> a
04:59:34 <Chousuke> oh, right.
05:00:02 <Chousuke> siriusbtx: that type tells you that you can't overload it. no type classes involved.
05:00:07 <FreeFull> siriusbtx: That would be the correct way
05:00:20 <FreeFull> Hiding and defining your own I mean
05:00:24 <Eduard_Munteanu> I wonder if there's a nice way to describe these transitions without sticking code into the Applicative and Monad instances.
05:00:26 <siriusbtx> ok thanks
05:00:30 <FreeFull> Then you can make a typeclass that defines (!!)
05:01:02 <FreeFull> And have a case for lists that calls the Prelude.!!
05:01:11 <FreeFull> Well, instance I mean
05:01:24 <Chousuke> siriusbtx: an int is not a sufficient index for a matrix anyway, unless you want vectors out of it.
05:01:55 <Eduard_Munteanu> I think I should use a StateT to adjust depending on the last token type.
05:01:59 <FreeFull> Something like    class Indexable f where (!!) :: (f a) -> Int -> a
05:02:00 <siriusbtx> Chousuke: ye i know, but was just out of curiousity
05:02:18 <FreeFull> You can probably use the Ix class for the index
05:02:36 <Eduard_Munteanu> lens might have something for that
05:02:38 <Chousuke> siriusbtx: overloading things is a bit rarer in haskell. abstracting things isn't though :P
05:02:59 <siriusbtx> k
05:03:05 <Chousuke> siriusbtx: there probably is some operator that abstracts indexing over multiple different types of index and indexable things.
05:03:53 <Chousuke> I would suggest keeping it simple, though
05:06:32 <Javafant> I have [String] and a function which takes a string and returns IO String. if i use map i get [io string] but what I want is [srting
05:06:39 <Javafant> [string] or io [string]
05:07:00 <Eduard_Munteanu> Javafant: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
05:07:16 <Saizan> Eduard_Munteanu: oh, you can make a token parser which uses lookahead
05:08:09 <Saizan> usually you want it to consume trailing spaces too
05:08:15 <Saizan> but that depends on the language
05:08:17 <Chousuke> Javafant: mapM
05:08:39 <hpc> mapM f xs = sequence (map f xs)
05:08:45 <bennofs> @ty sequencec
05:08:47 <bennofs> @ty sequence
05:08:49 <Eduard_Munteanu> Saizan: it consumes leading spaces automatically as it is now, but I'm not sure what to look ahead for
05:09:15 <Eduard_Munteanu> Oh!
05:09:33 <Javafant> Chousuke & Eduard_Munteanu: thx
05:09:36 <Eduard_Munteanu> Look ahead for trailing stringy characters.
05:09:44 <Saizan> yeah
05:09:58 <Eduard_Munteanu> Saizan: cool, that should do rather easily, thanks
05:10:19 <Saizan> np
05:10:53 <Saizan> i guess the usual concept is that of a word boundary
05:11:32 <Saizan> so you might need to take in consideration both the last char of the current token and the trailing char
05:11:48 <Eduard_Munteanu> Yeah, I didn't realize that given keyword parsers "foo" and "bar", the fault isn't bar's, but foo accepting an incomplete word.
05:12:48 <Eduard_Munteanu> Saizan: I can use separate parsers for keywords (actual words) and operators / other literals, so that should do
05:15:47 <Saizan> yep
05:29:02 <Eduard_Munteanu> Hm, there should be a  guardA :: Alternative f => Bool -> f ()
05:36:37 <FreeFull> @src guard
05:36:57 <FreeFull> Bot is gone
05:37:21 <Eduard_Munteanu> guardA False = empty; guardA True = pure ()
05:38:06 <quchen> Hmm. Maybe the AMP will allow changing guard to using Alternative in general.
05:45:03 <c_wraith> I wish I was better at determining when a Functor instance is possible...
05:45:16 <chrisdone> oh?
05:45:46 <c_wraith> I have a data type that if it's a functor, it solves my problem.  But I have no idea if it is.
05:47:01 <bennofs> c_wraith: just try adding a 'deriving Functor' clause with -XDeriveFunctor?
05:47:05 <c_wraith> newtype N a = N (((B -> a) -> a) -> a)  is the shape
05:47:18 <c_wraith> bennofs: it told me it couldn't do it, but it was awfully vague about why
05:47:25 <chrisdone> c_wraith: ohh =)
05:48:07 <Saizan> pretty unlikely, you have one 'a' in negative position
05:48:17 <c_wraith> ah, ok
05:48:42 <Saizan> newtype N b a = N (((B -> a) -> b) -> a) is a profunctor though :)
05:49:58 <c_wraith> Is there a profunctor equivalent to loeb?
05:50:50 <chrisdone> as Profunctor f g where pmap :: (a -> b) -> f a -> g b?
05:51:23 <fizruk> :t dimap
05:51:27 <chrisdone> what's your haskell definition of profunctor?
05:51:33 <bennofs> @ty (dimap)
05:51:38 <fizruk> :(
05:51:39 <c_wraith> no bot
05:51:48 <Saizan> Profunctor p where dimap :: (a' -> a) -> (b -> b') -> p a b -> p a' b'
05:52:00 <chrisdone> ahh
05:52:12 <Saizan> basically a contravariant functor on the left and a covariant one on the right
05:52:14 <mm_freak> @djinn c -> (a -> b) -> (((c -> a) -> a) -> a) -> ((c -> b) -> b) -> b
05:52:31 <Saizan> c_wraith: what's the type for loeb?
05:52:33 <mm_freak> oh
05:52:54 <c_wraith> Saizan: Functor f => f (f a -> a) -> f a
05:52:55 <c_wraith> iirc
05:53:02 <chrisdone> yeah
05:53:11 <chrisdone> i tried a loeb version of Traversable
05:53:21 <chrisdone> but didn't get any interesting use out of it
05:53:38 <bennofs> loeb f = fmap ($ f) f ?
05:53:52 <bennofs> ah, won't typecheck
05:55:08 <johnminton> Hello everyone - I'm trying to do 'cabal install cabal-install' and it's failing because of network timeout. Can I find which URL it's trying so I can try it myself and diagnose the problem? There doesn't seem to be a verbose flag.
05:55:09 <bennofs> loeb f = let res = fmap ($ res) f in res ?
05:55:25 <chrisdone> bennofs: seems ok
05:55:55 <dcoutts_> johnminton: there is a verbose flag, and you can use higher levels, like -v3
05:56:04 <Eduard_Munteanu> johnminton: there is '-v', but the hackage repo should be in the cabal config
05:56:13 <monoidal> haskell.org is currently down
05:56:15 <Eduard_Munteanu> There aren't other mirrors.
05:56:22 <johnminton> Single point of failure - awesome
05:56:31 <benmachine> there used to be mirrors
05:56:32 <c_wraith> There are mirrors.  I just don't remember any of them
05:56:42 <chrisdone> bennofs: maybe what you wanted was: loeb f = fmap ($ loeb f) f
05:56:47 <Saizan> c_wraith: yeah, basically you have to separate the negative from the positive positions
05:56:48 <benmachine> there's github, if that counts :P
05:56:48 <Eduard_Munteanu> Shortest Path to Failure. :P
05:56:53 <monoidal> the channel topic contains a mirror
05:57:09 <moto9> hi all, is there a way to convince ghci to accept multiline input?
05:57:19 <Saizan> c_wraith: in f (f a -> a) -> f a the second occurrence of 'a' is negative, the other positive
05:57:19 <johnminton> How do I know I can trust this mirror though? There's no HTTPs, no keys, no signing
05:57:23 <quchen> moto9: :{
05:57:24 <monoidal> moto9: use :{ to start multiline input, :} to end
05:57:37 <chrisdone> quchen: don't be sad
05:57:37 <moto9> oh, ok
05:57:44 <benmachine> johnminton: but there aren't those things for hackage either >_>
05:57:52 <benmachine> well, there might be https
05:58:03 <moto9> those ); languages are sad too ;)
05:58:27 <benmachine> no, there isn't, cabal-install doesn't do https
05:58:31 <Eduard_Munteanu> Saizan: can you say something about not-strictly-positive occurences of 'a'?
05:58:38 <Eduard_Munteanu> wrt to functoriality.
05:59:03 <Eduard_Munteanu> As opposed to just negative.
05:59:16 <Saizan> Eduard_Munteanu: yeah, for example the first occurrence there is just positive, not strictly positive, but it's still fine
05:59:39 <benmachine> Cont r a has a in a non-strictly-positive position
05:59:51 <Saizan> yeah, was going to make that example
06:00:13 <Eduard_Munteanu> Saizan: is it something like positive -> covariant, negative -> contravariant, not-strictly-* -> maybe {co,contra}variant?
06:00:44 <benmachine> an occurrence that is positive but not strictly is still covariant I think
06:00:48 <Saizan> Eduard_Munteanu: strictly doesn't matter, any positive is going to be covariant
06:00:55 <Eduard_Munteanu> Hm.
06:01:06 <bennofs> Someone really should make a ghci plugin to add support for @ty in ghci! :P
06:01:25 <chrisdone> huh?
06:01:34 <bennofs> I always mistype :t as @ty
06:01:41 <Eduard_Munteanu> I wonder why Agda doesn't accept recursion in non-strictly-positive positions. Well, I know you can derive bot, but I don't know what it amounts to theoretically.
06:01:49 <benmachine> bennofs: well volunteered :P
06:01:56 <quchen> bennofs: Of you could start typing :t in IRC.
06:02:06 <bennofs> quchen: doesn't work in private though
06:02:21 <Eduard_Munteanu> bennofs: it's working... as of lately
06:02:23 <quchen> bennofs: Yes it does, since some weeks ago
06:02:32 <Saizan> Eduard_Munteanu: i think that restriction could be relaxed somewhat if you don't care about classical set theory models
06:02:43 <bennofs> ah, I didn't know that, that solves my problem :) thanks
06:02:49 <Saizan> (or even non-classical i guess..)
06:03:05 <benmachine> quchen: what do you mean by since some weeks ago?
06:03:12 <benmachine> ohh
06:03:13 <benmachine> with you
06:03:15 <benmachine> never mind
06:03:30 <benmachine> but it doesn't work anyway because lambdabot is not here
06:03:43 <Eduard_Munteanu> Saizan: interesting... so you get a paradox only if you want things like LEM or whatever Agda calls anti-classical (I forget the assumption)?
06:04:10 <Eduard_Munteanu> Probably the negation of LEM.
06:04:52 <Eduard_Munteanu> Or perhaps ZF-related? :/
06:05:12 <Eduard_Munteanu> I missed the "set theory" bit, I suppose.
06:06:09 <benmachine> the negation of LEM is no good
06:06:13 <benmachine> Agda believes ¬¬LEM
06:06:24 <Saizan> Eduard_Munteanu: i don't know the details
06:06:37 <skypers> hi
06:06:50 <Eduard_Munteanu> benmachine: well, you can prove ¬¬LEM, but that's just LEM -> LEM really.
06:07:09 <Saizan> benmachine: i'd be cautious with that
06:07:43 <Saizan> benmachine: Agda believes forall a, ¬¬ (a or ¬ a)
06:07:52 <benmachine> Eduard_Munteanu: not reeeeally. A -> A is always true, but ¬¬A isn't in general
06:07:54 <FreeFull> Double negation can't be necessarily proven to be no negation, depending on your axioms
06:08:00 <Eduard_Munteanu> Though ¬¬LEM is rather weak in itself, I think, it just says there are propositions for which LEM is not true.
06:08:00 <Saizan> benmachine: not ¬¬ forall a, (a or ¬ a)
06:08:04 <benmachine> Eduard_Munteanu: I mean, I see what you mean, but my statement is nontrivial
06:08:18 <benmachine> Saizan: ah, I see what you mean
06:08:19 <FreeFull> There are cases where you can't prove double negation is no negation, but can prove triple negation is single negation
06:08:22 <chrisdone> huh
06:08:26 <chrisdone> can you define loeb in terms of fix?
06:08:49 <benmachine> chrisdone: remind me of the definition without it
06:08:58 <FreeFull> You should be able to define any recursive function in terms of fix
06:09:08 <chrisdone> i meant can you personally do it =p
06:09:09 <bennofs> loeb f = fmap ($ loeb f) f
06:09:37 <Eduard_Munteanu> benmachine: I mean LEM -> P is the same as ¬¬P
06:09:38 <hpc> :t let loeb f = fmap ($ loeb f) f in loeb
06:09:59 <chrisdone> fix (\loeb f -> fmap ($ loeb f) f)
06:10:02 <chrisdone> but that's just cheating ^
06:10:16 <chrisdone> i mean something that doesn't use a name to refer to itself
06:10:20 <chrisdone> i'd be interested to see that
06:10:22 <benmachine> fix $ \rec -> fmap ($ rec) f
06:10:30 <quchen> Solved! benmachine wins.
06:10:49 <quchen> Or something. (Why is fix cheating?)
06:11:01 <bennofs> benmachine: where is your f coming from?
06:11:08 <benmachine> bennofs: \f -> beforehand
06:11:17 <benmachine> \f -> fix $ \rec -> fmap ($ rec) f :: Functor f => f (f b -> b) -> f b
06:11:36 <Eduard_Munteanu> I wonder if you can do anything with ¬LEM that you can't do in absence of LEM.
06:11:38 <chrisdone> yeah that's what i mean by not really being different to just using normal let
06:11:47 <jpcooper> hi all
06:11:54 <chrisdone> fix $ \rec -> …  is just like let rec = …  there's nothing cool about that =p
06:12:07 <quchen> Eduard_Munteanu: When ¬LEM, can't you prove A and not A at the same time?
06:12:17 <jpcooper> I've been both trying to update my cabal package list and install a package, and both are timing out. Is hackage meant to be down right now? I have to complete a task for a job application, so I'm getting rather worrie
06:12:25 <chrisdone> benmachine: i'd employ @djinn but it's gone D:
06:12:49 <bennofs> jpcooper: use the mirror from the channel topic
06:13:07 <Eduard_Munteanu> quchen: mm, I don't think so...
06:13:20 <bennofs> jpcooper: https://github.com/ekmett/lens/blob/master/travis/conf is an example cabal config, not sure what part of that is needed
06:13:22 <jpcooper> bennofs: how do I do that?
06:13:30 <jpcooper> oh I see
06:13:49 <Eduard_Munteanu> quchen: you can't really turn the negation of 'or' into an 'and' in absence of LEM
06:14:44 <Eduard_Munteanu> Only 3 out of 4 de Morgan laws hold, I forget which fails right now.
06:14:52 <Eduard_Munteanu> In the absence of LEM, that is.
06:15:21 <benmachine> chrisdone: the pointfree version is fix . flip (fmap . flip id), but that's really just the same thing
06:15:46 <Saizan> forall a, ¬ (a or ¬ a) would be pretty silly, because you can apply it to () and pass it (Left ()) and get a contradiction
06:15:49 <chrisdone> benmachine: i like that. but yeah, it's probably not more reducable
06:16:14 <Eduard_Munteanu> Saizan: sure, not that
06:16:44 <Eduard_Munteanu> Saizan: ¬LEM = ∃ P. ¬(P V ¬P)
06:16:48 <Eduard_Munteanu> AFAICT.
06:16:57 <benmachine> chrisdone: so, you mentioned how anything with let can be mechanically translated into fix and that's "cheating", but of course you can go the other way as well
06:16:57 <FreeFull> Wouldn't or be something like    Left a | Right b | Both a b
06:17:08 <Saizan> Eduard_Munteanu: with a classical existential, yeah
06:17:23 <Saizan> Eduard_Munteanu: i don't know if just that is any use
06:17:41 <benmachine> chrisdone: so any loeb-with-fix gives rise to a loeb-with-let so any "interesting" way of doing loeb with fix is pretty much only as interesting as doing it without it
06:18:02 <jpcooper> every time I do cabal update, it tells me that there is a new version of cabal install available, which is the same version as the one I've installed before. How can I fix this?
06:18:09 <Eduard_Munteanu> FreeFull: you don't need the Both branch, because a Left or Right is enough to prove a disjunction
06:18:19 <FreeFull> Eduard_Munteanu: True
06:18:28 <chrisdone> benmachine: yup. it's just sometimes fix solutions look nicer. e.g. fix (1:) is nicer than with let
06:18:36 <bennofs> jpcooper: does cabal --version also print that version?
06:18:43 <jpcooper> I just checked, and it's an old version
06:18:47 <quchen> chrisdone: fix error etc.
06:18:56 <bennofs> jpcooper: Then I guess you don't have ~/.cabal/bin in your path?
06:18:59 <jpcooper> but the newer install says that is has installed the executabls in the path
06:19:09 <jpcooper> aah, it's pointing to the wrong one
06:19:09 <chrisdone> quchen: which ironically does not fix the error ;_;
06:19:10 <benmachine> chrisdone: fair enough, so you're looking for aesthetics mainly?
06:19:19 <FreeFull> Does fix (1:) have the same space characteristics as cycle [1]?
06:19:34 * benmachine eyeballs his intermediate forms to see if any of them look nice
06:19:36 <chrisdone> benmachine: was, yeah
06:19:39 <hpc> FreeFull: it depends on which fix you use
06:19:49 <hpc> fix f = let x = f x in x -- constant space
06:19:55 <hpc> fix f = f (fix f) -- linear space
06:20:03 <benmachine> hpc: only insofar as it also depends what cycle you use :P
06:20:06 <hpc> the let-in there ties the knot and makes it circular
06:20:07 <quchen> chrisdone: Depends on your desired outcome. If the error is that your program terminates …
06:20:08 <Saizan> Eduard_Munteanu: mh, i'm more confident about "¬ forall a, (a or ¬ a)" actually
06:20:09 <benmachine> I believe GHC gets both "right"
06:20:18 <hpc> ghc definitely gets fix right
06:20:41 <chrisdone> what's the src of cycle
06:20:49 * chrisdone installs lambdabot on lpaste
06:20:57 <Eduard_Munteanu> Saizan: what's the difference... that you don't need to produce that 'a' as proof?
06:21:01 <quchen> cycle xs = let xs' = xs ++ xs' -- chrisdone
06:21:01 <benmachine> chrisdone: lambdabot doesn't know what src GHC really uses
06:21:03 <hpc> hoogle's down
06:21:12 <quchen> +in etc
06:21:16 <donri> hackage's down :p
06:21:29 <quchen> Haskell apocalypse
06:21:38 <chrisdone> benmachine: which is weird because that's gettable with haddock
06:21:41 <bennofs> woot, a day where hayoo isn't down but hoogle is :D
06:21:57 <Eduard_Munteanu> ¬ forall a, (a or ¬ a)  ~   LEM -> ⊥  ?
06:22:07 <Eduard_Munteanu> That seems even more useless :)
06:22:08 <chrisdone> quchen: haskopalypse
06:22:10 <benmachine> cycle xs                = xs' where xs' = xs ++ xs'
06:22:13 <Saizan> Eduard_Munteanu: if i try to desugar ∃ P. ¬(P V ¬P) to forall i get "¬ forall P, ¬¬(P V ¬P)" but that's confutable?
06:22:28 <benmachine> (pasted from GHC/List.lhs)
06:24:45 <ownclo> Good day, gentlemen! Can a notion of reversibility be expressed in haskell? Say, I've implemented a function a -> b (e.g. a parser String -> Log Int String) which is fully reversible. Can I get the reversed function by saying g = reverse f to get a function b -> a (Log Int String -> String)?
06:26:34 <skypers> hey, `maybe x f (lookup k m)` is the same as f (findWithDefault x k m)
06:26:35 <skypers> right?
06:26:43 <donri> ownclo: yes, lens used to do that
06:27:09 <skypers> I wonder why it’s not named lookupDefault
06:29:08 <ownclo> donri, the lens library? I thought it's about accessing nested values. Could you please give me some hint on the relation betwenn lenses and reversibility?
06:29:26 <donri> ownclo: they're called Iso in lens
06:29:40 <Eduard_Munteanu> Saizan: hm... how about the sumtype existential ∃ (¬LEM) ~ ∃ (\P -> ¬(P V ¬P)), which is a (P : Prop, ¬(P V ¬P)) ~ (P, P V ¬P -> ⊥) ~ (P, ¬P -> ⊥)? That seems rather harmless.
06:30:01 <mauke> ownclo: that doesn't look computable unless you brute force it
06:30:28 <jpcooper> bennofs: where else can I view hackage documentation?
06:30:39 <donri> well yeah lens doesn't derive the reversal for you, you supply it
06:31:20 <ownclo> donri, thank you! I'll try to look closer. Is it possible to reverse a computation in a state monad? I'm trying to redefine the bind operator for that, but I fail to do so
06:31:25 <mauke> :t upon
06:31:36 <FreeFull> The lens library contains a lot more than just lenses
06:31:39 <chrisdone> there is a state monad that goes backwards
06:31:48 <FreeFull> chrisdone: Yes
06:31:50 <chrisdone> but i'm not sure it's what you want
06:32:04 <quchen> chrisdone: No. That's not what anyone ever wants.
06:32:07 <FreeFull> Whoops, I read "there is" as "is there"
06:32:13 <quchen> chrisdone: Reverse state is weird even to Haskell standards :-P
06:32:14 <ownclo> chrisdone, backward state is not the solution
06:32:17 <chrisdone> quchen: hey, man, someone used it to solve the twitter problem =p
06:32:26 <quchen> Right :-P
06:32:30 <Saizan> Eduard_Munteanu: i guess, yeah
06:32:33 <chrisdone> it was dog slow, but it worked
06:32:41 <quchen> Tardis is the strange cousin of reverse state
06:32:52 <chrisdone> tardis is just reverse state + normal state
06:33:05 <quchen> Right.
06:33:33 <Sagi> is hackage / haskell.org unreachable for more people?
06:33:38 <bennofs> yes
06:33:40 <chrisdone> ownclo: there is some prior work on this… i'm trying to remember how it's named…
06:33:54 <ownclo> thank you, gentlemen! I am sure that lens lib (with reversal) is just the right tool.
06:34:30 <ownclo> chrisdone, I've found a reversible (esoteric) programming language, but I cannot restore the link
06:34:39 <donri> acme-realworld. just reverse the world.
06:34:51 <bennofs> maybe someone should change the channel topic while hackage is down
06:35:02 <Sagi> oh, it's actually in the topic
06:35:11 <benmachine> ownclo: maybe have a look at http://stackoverflow.com/questions/13404208/in-pure-functional-languages-is-there-an-algorithm-to-get-the-inverse-function
06:35:32 <Sagi> hmm, are there hoogle-mirrors as well?
06:35:38 <bennofs> hayoo
06:35:39 <benmachine> Sagi: no, that Hackage down? bit is always there :P
06:35:41 <benmachine> just in case
06:35:43 <bennofs> @where hayoo
06:35:55 <bennofs> but that cannot search for types very weel
06:35:57 <Sagi> benmachine: oh :)
06:35:59 <ownclo> benmachine, wow, I didn't find any links on stackovwflw, thank you
06:36:00 <chrisdone> ownclo: yeah there's a logic language that is reversible with similar appearance to haskell
06:36:00 <benmachine> http://old.hackage.haskell.org/packages/hackage.html
06:36:04 <bennofs> oh, lambdabot down :(
06:36:15 <chrisdone> what is the official lambdabot github repo?
06:36:50 <bennofs> Sagi: http://holumbus.fh-wedel.de/hayoo/hayoo.html might be an alternative to hoogle, depending on your needs
06:36:53 <Sagi> heh, all haskell infra is down? I hope for scheduled maintenance
06:36:57 <donri> chrisdone: i think https://github.com/mokus0/lambdabot
06:37:01 <Sagi> bennofs: thanks
06:37:27 <bennofs> someone just used the IO monad at haskell.org to launch missles! Maybe they should try acme-realworld ...
06:37:59 <mikeplus32> hm, hackage is down, so i add hdiff.luite.com to cabal, but i need to first run 'cabal update' to use it, which can't be done because hackage is down (it just times out and dies)
06:38:01 <Sagi> it's funny how interweaved hackage is in everything.
06:38:30 <chrisdone> mikeplus32: comment out the hackage one
06:38:38 <chrisdone> mikeplus32: then your cabal update will work fine
06:38:40 <skypers> :t insertWth
06:38:42 <skypers> :t insertWith
06:39:23 <mikeplus32> chrisdone: oh, right. i was silly and just did 'echo ... >> ~/.cabal/config' without thinking
06:39:39 <mikeplus32> thanks
06:39:45 <chrisdone> welcome
06:40:02 <Eduard_Munteanu> Saizan: actually I'm not so sure, isn't the ∀ -> ∃ transformation unprovable without LEM?
06:42:15 <Eduard_Munteanu> So you can't really go from ¬(∀ p. LEM p) to ∃ p. ¬(LEM p), if that's true, unless you give that exact 'p' as part of your postulate.
06:43:27 <benmachine> Eduard_Munteanu: part of the problem is what exactly you mean by forall and exists
06:44:04 <benmachine> Eduard_Munteanu: when I learnt classical logic, it was by definition the case that that translation held
06:44:15 <Saizan> Eduard_Munteanu: right, so it's debatable how much ∃ p. ¬(LEM p) is a negation of (∀ p. LEM p)
06:44:22 <benmachine> Eduard_Munteanu: but if you have Agda's ideas, maybe not even LEM will save you
06:44:30 <jpcooper> anyone know of a mirror for the hackage documentation?
06:44:34 <benmachine> no I suppose it will, never mind
06:44:36 <Eduard_Munteanu> benmachine: the intuitionistic ∀ and the sumtype ∑ A P for ∃ (a : A). P a, like in Agda.
06:44:38 <Saizan> Eduard_Munteanu: well, actually from ∃ p. ¬(LEM p) you can prove ¬(∀ p. LEM p)
06:44:53 <donri> jpcooper: you can use hdiff and cabal install --enable-documentation
06:45:01 <Eduard_Munteanu> Yeah, but not the other way around, so I guess this is too strong an assumption.
06:46:22 <jpcooper> thanks
06:48:03 <epsilonhalbe> hey does anybody know what is wrong with haskell.org - is it down or is it just me?
06:48:33 <chrisdone> it's down
06:48:50 <unK_> what's LEM?
06:49:05 <Eduard_Munteanu> unK_: law of excluded middle
06:49:13 <quchen> A ∨ ¬A
06:49:19 <unK_> ah. thanks
06:49:20 <epsilonhalbe> do you know until when it is down (regular maintenance) or is there a problem ?
06:50:06 <chrisdone> probably there is some trouble with the hetzner host
06:50:10 <chrisdone> again
06:50:17 <epsilonhalbe> :(
06:51:02 <skypers> https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Core/Material.hs#L106
06:51:04 <epsilonhalbe> is there another way to get an actual version of cabal-install somehow?
06:51:11 <skypers> any idea how to discard to double let statements?
06:51:45 <fizruk> epsilonhalbe, github?
06:51:49 <chrisdone> epsilonhalbe: add the mirror in the topic to your ~/.cabal/config, remove the haskell.org one, until it comes up again
06:52:01 <epsilonhalbe> merci
06:52:07 <epsilonhalbe> i will try
06:52:27 <merijn> Speaking of down, is github up? I was trying skypers link and I don't get anything...
06:52:42 <donri> WFM
06:53:00 <chrisdone> github working fine here
06:53:35 <chrisdone> perhaps their dns is down
06:53:56 <merijn> Getting ping timeout too
06:53:59 <merijn> bleh
06:54:41 <chrisdone> chris@retina:~$ curl -s 192.30.252.131 | head
06:54:41 <chrisdone> <!DOCTYPE html>
06:54:50 <chrisdone> what does that give you?
06:55:37 <merijn> oh, ping is up now
06:56:13 <fizruk> merijn, I've experienced the same, but everything is ok now
06:58:19 <fizruk> skypers, were you talking about registerMatProp? you could just move the first let declaration to the second?
06:59:47 <merijn> skypers: btw, why is MaterialProperties a typeclass?
07:00:17 <merijn> This looks kinda like the existential anti-pattern without the existential :p
07:00:40 <benzrf> hi!
07:01:00 <Wizek> Is it just me, or hackage.haskell.org is down?
07:01:19 <skypers> merijn: because I want the user to be able to write his own
07:01:20 <skypers> like
07:01:23 <danilo2> its down. Does somebody know when it will be up ?
07:01:29 <skypers> newtype ColorMat = (Float,Float,Float,Float)
07:01:30 <benzrf> what's a simple unit testing framework I can use to test a 1-file program?
07:01:36 <skypers> instance MaterialProperties ColorMat where…
07:01:39 <benzrf> not looking for anything with special testing dirs and tons of features
07:01:47 <benzrf> just basic assertion stuff
07:01:49 <merijn> skypers: That doesn't not necessarily mean you need a typeclass
07:01:49 <skypers> 15:41 < fizruk> skypers, were you talking about registerMatProp? you could just move the first let declaration to the second?
07:01:52 <skypers> how?
07:01:57 <skypers> merijn: I’m all ears
07:02:14 <supki> benzrf: hspec
07:02:26 <fizruk> skypers, raw <- ...; let newMatProp = ...; newMgr = ...; ...
07:02:33 <merijn> skypers: Read this: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:02:38 <chrisdone> skypers: is that from radiation?
07:02:56 <merijn> skypers: You're not using an existential, but the "typeclass as OO class" problem is the same in your code
07:03:00 <benzrf> supki: thanks
07:03:37 <Wizek> Anyone knows when/how I will be able to use cabal again? (server is down)
07:03:38 <skypers> 15:45 < chrisdone> skypers: is that from radiation?
07:03:40 <skypers> radiation?
07:03:42 <Sagi> does anyone know of a maximumBy variant (Data.List) which returns all maximum values? I just wrote my own, but somehow this seems like something which should be in some existing library.
07:03:57 <chrisdone> skypers: all your ears
07:03:59 <danilo2> We are for not very long time using Hackage2. Has it got a mirror somewhere?
07:04:08 <skypers> merijn: ok, so how should I solve that then?
07:04:18 <skypers> chrisdone: I don’t what radiation is
07:04:30 <merijn> skypers: The link I just pasted explains an alternative design using just datatypes
07:04:45 <merijn> skypers: He was making a joke
07:05:04 <skypers> merijn: yeah, donri already told me about existential
07:05:12 <skypers> but hm, I don’t know, it sounds like a trick
07:05:31 <bennofs> danilo2: not sure, does hdiff.luite.com mirror hackage2 already?
07:06:27 <merijn> skypers: i.e. instead of having a material properties typeclass, just have a "MaterialProperties" type that is a record which has all the functions that the typeclass has
07:06:54 <danilo2> bennofs: thats a good question
07:07:10 <bennofs> danilo2: It seems hdiff.luite.com mirrors hackage2 already, because http-monad was updated 2h ago
07:08:37 <danilo2> bennofs: oh great! thank you :)
07:09:18 <skypers> 15:49 < merijn> skypers: i.e. instead of having a material properties typeclass, just have a "MaterialProperties" type that is a record which has all the functions that the typeclass has
07:09:22 <skypers> ok so
07:09:28 <skypers> what the use of typeclass then?
07:10:32 <bennofs> a typeclass should have laws between the functions provided by the typeclass (example: Functor has the law fmap id = id (and fmap (f.g) = fmap f . fmap g, but that one is free))
07:11:08 <benzrf> bennofs: those laws arent defined anywhere in the lang though are the
07:11:09 <benzrf> y
07:11:49 <donri> benzrf: haskell often isn't strong enough to make it convenient to enforce laws like that
07:12:03 <merijn> skypers: I almost never write my own typeclasses
07:12:49 <merijn> skypers: The only time I do is when I do type level wizardry/hacks. For common code, there's almost never a real reason to use them, other than OOP reflexes of "oh god, I need polymorphism here"
07:13:09 <benzrf> donri: how so?
07:13:46 <merijn> skypers: The usual beginner curve is 1) "what are typeclasses?", 2) "everything gets its own typeclass!", 3) "only use existing typeclasses"
07:14:16 <merijn> skypers: Most places where beginners use typeclasses are more nicely/simpler solved using a record of functions/values
07:14:19 <benzrf> merijn: i dont see major utility in typeclasses myself
07:14:32 <benzrf> in fact i barely see how theyre useful except for super abstract things like monads
07:14:43 <merijn> benzrf: You are not wrong
07:14:48 <donri> benzrf: well it gets messy even with the convenience of dependent types, and that in turn comes at the price of type inference
07:14:55 <merijn> benzrf: They can be good for type level hackery, but oter than that
07:15:35 <merijn> benzrf: They're a good tool to have available, but that doesn't mean it gets used a lot :)
07:16:03 <benzrf> cf. metaclasses in python
07:16:13 <merijn> benzrf: Likewise, existential quantification has it's purpose and it works really well for that. But in practice I've only used it a handful of times
07:16:18 <benzrf> or macros in lisp
07:16:24 <benzrf> merijn: dont know what that is
07:16:24 <benzrf> >.>
07:16:39 <fizruk> merijn, they're used for things like MonadState when you want to get a lifted interface, I guess this is not abstraction or is it?
07:16:40 <worldsayshi> It seems to me that haskell.org/ and also hackage is down? Or is this just me?
07:16:56 <benzrf> worldsayshi: http://isup.me/haskell.org
07:17:13 <worldsayshi> ah, thanks
07:17:23 <bennofs> worldsayshi: yes, it's down. You can use the alternative mirror at hdiff.luite.com
07:18:10 <merijn> benzrf: It lets you forget properties of a type, you can have like "data ExistentialWrapper = forall a . MyClass a => Wrapper a" benzrf Which means "ExistentialWrapper contains a value you can use MyClass functions on, but you don't know anything else about it
07:18:32 <worldsayshi> bennofs: ah, great thanks
07:18:39 <merijn> benzrf: i.e. you could have a list of ExistentialWrapper values with different contents in the same list
07:18:49 <benzrf> ahihi:
07:18:51 <benzrf> *ah
07:18:58 <benzrf> so it lets you use a type var that doesn't get reused?
07:19:21 <benzrf> like making a function a -> Int?
07:19:29 <merijn> benzrf: It lets you forget everything about the type, except that it's a "MyClass" instance
07:19:41 <benzrf> ok
07:21:17 <merijn> benzrf: See for more info: https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
07:21:36 <merijn> benzrf: And on why most of the times people try to use them, they're wrong: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:21:58 <benzrf> thanks
07:23:19 <benzrf> ok, when should I make a function of type String -> Foo the read instance and when not?
07:23:49 <merijn> benzrf: Usually the idea is that Read/Show are complements
07:24:08 <benzrf> so it should only be for debug representations?
07:24:11 <merijn> i.e. "show . read" == "id"
07:24:21 <benzrf> ok
07:24:43 <merijn> There's no hard rule about that
07:24:44 <Feuerbach> > "show . read" == "id"
07:26:05 <skypers> merijn: at first, I see classes the only way to overload functions in Haskell :)
07:27:38 <Eduard_Munteanu> Saizan: after a bit more thought, since '∀ p. p -> ¬¬p', ¬LEM -> ¬¬¬LEM, which is ¬¬(¬ ∀p. p v ¬p) ~ ¬¬(∃ p. p x ¬p) ~ ¬¬⊥, but that contradiction is "inaccessible" from intuitionistic propositions.
07:27:53 <Eduard_Munteanu> Saizan: does that seem sound to you?
07:28:20 <skypers> ok I see the idea of the data type
07:28:25 <skypers> it’s nice to see that
07:28:28 <khyperia> lambdabot isn't here! Everybody panic!
07:28:41 <Eduard_Munteanu> (by inaccesible I mean you can't really provide a 'p' such that 'p -> ¬¬⊥')
07:28:58 <benmachine> merijn: show . read tends not to be id for various reasons
07:28:59 <gniourf> show ((read "02")::Int) /= "02"
07:29:11 <benmachine> merijn: read . show = id is a bit more likely
07:30:43 <Eduard_Munteanu> Saizan: which is sort of convenient for classical logic... "I'm not consistent, but I'm not going to tell you why" :)
07:31:37 <codh> hello , is haskell.org down ? and replacement?
07:31:47 <Eduard_Munteanu> codh: yes, see /topic
07:32:33 <codh> I don't know how to see /topic
07:32:43 <skypers> merijn: I think I need to forget about “polymorphism” and all that stuff
07:32:44 <bennofs> just type /topic?
07:32:45 <Eduard_Munteanu> codh: type /topic and press enter
07:32:52 <skypers> it parasites my Haskell way to think
07:33:05 <codh> It gives me : Insufficient arguments for command
07:33:30 <Eduard_Munteanu> codh: then your client probably shows the channel topic some other way, that's what I meant by /topic
07:33:46 <Eduard_Munteanu> "Hackage down? http://hdiff.luite.com"
07:33:57 <codh> oh, yes, thank you. Eduard
07:35:11 <codh> hoogle
07:35:54 <codh> How can I use hoogle here?
07:36:10 <Eduard_Munteanu> codh: normally with @hoogle but lambdabot is dead right now
07:36:23 <codh> oh thanks.
07:36:54 <codh> is there are built in swap function?  swap (x,y) = (y,x)
07:37:12 <bennofs> codh: yes, in Data.Tuple
07:37:23 <codh> tell bennofs thanks
07:38:21 <Eduard_Munteanu> codh: you should use tab-completion, e.g. Edua<tab> will autocomplete to Eduard_Munteanu in many clients.
07:38:40 <codh> Eduard_Munteanu: thanks!
07:39:18 <mauke> I see you're using Mozilla Apple Chrome Safari
07:39:48 <codh> yep, I'm using the web version. the tab works. webchart.freenode.net
07:42:46 <benzrf> is there a way to use cabal with the mirror
07:43:25 <bennofs> benzrf: replace the remote-repo line in your cabal.config with 'remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive'
07:43:35 <codh> what's the good way to give a list's unique elements and count? e.g  "aaabb" -> ("ab", [3,2])
07:43:45 <benzrf> tjanks
07:43:48 <benzrf> *thanks
07:43:58 <benzrf> :t zip
07:44:03 <benzrf> aw
07:44:05 <bennofs> :)
07:44:16 <mauke> zip :: [a] -> [b] -> [(a, b)]
07:44:17 <bennofs> zip :: [a] -> [b] -> [(a,b)]
07:44:24 <bennofs> aw, mauke beat me
07:44:28 <benzrf> is there an [(a,b)] -> ([a], [b])
07:44:31 * mauke beats bennofs 
07:44:35 <mauke> unzip
07:44:38 <benzrf> ah
07:44:46 <Eduard_Munteanu> codh: map (length &&& head) . group . sort
07:44:59 <codh> Eduard_Munteanu:  thanks.
07:45:38 <Eduard_Munteanu> codh: well, that gives you pairs (3, 'a') and (2, 'b')
07:45:43 <Eduard_Munteanu> (in a list)
07:46:25 <codh> Eduard_Munteanu:  that's fine, I can do an unzip
07:46:35 <donri> codh: or use a bag/multiset
07:47:13 <Eduard_Munteanu> You can make one from Map.
07:47:19 <codh> donri: thanks. my list is small, and haskell.org is down.
07:47:30 <mauke> fold/insertWith
07:49:09 <codh> how can I do import Data.Arrow (&&&)?
07:49:13 <The_Ice> hi, is http://haskell.org is down or this is just local issue to me?
07:49:34 <fizruk> codh, ((&&&))
07:49:59 <codh> fizruk: thanks!
07:50:03 <donri> and it's Control.Arrow
07:51:04 <bennofs> The_Ice: it's down
07:51:25 <The_Ice> :(
07:51:49 <worldsayshi> is there an alternative mirror that cabal-dev somehow can be pointed to while hackage is down?
07:51:58 <donri> worldsayshi: see topic
07:52:17 <chrisdone> someone make a bot to announce that hackage is down every 60 seconds
07:52:23 <worldsayshi> But can I use git repos with cabal-dev?
07:52:24 <skypers> merijn: https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Core/Material.hs#L106 I got that with data
07:52:32 <skypers> it seems nice now!
07:52:35 <skypers> thank you
07:52:36 <donri> chrisdone: right after i add a plugin to lambdabot to announce that lambdabot is down
07:52:52 <bennofs> worldsayshi: replace the remote-repo line in your cabal config with 'remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive'
07:53:03 <worldsayshi> aha. Thanks!
08:02:54 <worldsayshi> hackage outage workarounds (perhaps put in topic?): http://bob.ippoli.to/archives/2013/01/11/getting-started-with-haskell/#hackage-mirrors
08:05:46 <hpc> worldsayshi: i would prefer more effort go into making haskell.org not go down to begin with
08:06:13 <worldsayshi> hpc: for the time being I mean
08:06:37 <bennofs> I'd like if cabal could automatically choose the best mirror, so you only have to add hdiff.luite.com to the cabal/config one time
08:06:54 <frxx> @src (&&&)
08:07:04 <bennofs> frxx: lambdabot is down
08:07:13 <frxx> :/
08:07:15 <bennofs> but (&&&) is a member of the Arrow class
08:07:21 <Rylee> aji,
08:07:39 <bennofs> for the (->) instance, I guess it's defined as f &&& g = \x -> (f x, g x)
08:07:41 <aji> Rylee,
08:07:57 <frxx> thanks
08:08:47 <ennui`> Here's a trivial 6-line typeclass experiment I'm failing to compile: http://lpaste.net/95757. Can someone help out a newbie?
08:10:00 <Eduard_Munteanu> ennui`: yes, but 'g' and 'a' are unrelated according to your class declaration
08:10:15 <Eduard_Munteanu> ennui`: and 'a' ends up fully polymorphic
08:10:39 <ennui`> Eduard_Munteanu: Could you fix my code, DWIM style? I'll figure out the rest.
08:10:55 <Eduard_Munteanu> ennui`: you probably want   edges :: Eq a => g a -> [(a, a)]
08:11:21 <benmachine> it depends a bit on which instances you want apart from Graph
08:11:55 <Eduard_Munteanu> ennui`: or if 'g' should contain the 'a' itself, you can make   class DirectedGraph a g | g -> a where <use your old edges type>
08:11:59 <donri> ennui`: what do you want with that Eq constraint?
08:12:19 <donri> are you trying to say that the a's should be the same type? they already say that
08:12:35 <merijn> skypers: Yeah, that looks much simpler
08:12:55 <ennui`> donri: i'm using the 'Eq a' in a default implementation of edges
08:13:22 <ennui`> ...which implements on other functions of DirectedGraph that I've omitted.
08:13:43 <ennui`> (depends on)
08:16:24 <ennui`> Eduard_Munteanu, benmachine, thanks for your pointers!
08:16:50 * benmachine gives ennui` a null pointer
08:16:54 <benmachine> here, have that one too
08:17:52 <Eduard_Munteanu> (As a sidenote, in some cases it's nicer to use 's' and 't' instead of just 'a', even if they're the same, it affords you a bit more type safety and can make some types more readable.)
08:18:24 <FireFly> benmachine: that's not a very useful pointer to follow
08:19:05 * Eduard_Munteanu imagines benmachine mentioning "don't dereference me on that" :P
08:19:09 <peterwestn> Why is hackage down? It's been down for hours? What's wrong with you people
08:20:06 <peterwestn> Fucking incompetent
08:22:11 <merijn> peterwestn: Feel free to pony up the money for a better datacenter...
08:23:15 <peterwestn> can't msr contribute a couple of servers?
08:23:57 <donri> they don't do enough?
08:23:59 <dino-> Does anyone know, are there any mirrors of hackage.haskell.org?
08:24:04 <merijn> dino-: Yes
08:24:09 <merijn> @where hackage-mirror
08:24:10 <FireFly> Try the topic
08:24:15 <merijn> or is lambdabot down? :(
08:24:18 <FireFly> She is :p
08:24:19 <donri> @where lambdabot-mirror
08:24:22 <merijn> oh, topic has the mirror
08:24:27 <Saizan> peterwestn: let's keep it civil, also admins aren't going to be as responsive on weekends
08:24:46 <merijn> Saizan: The problem is that the admins don't have out-of-band access to the servers
08:25:14 <merijn> Saizan: rock is down which hosts 4 of the Haskell VMs and it's impossible to determine remotely wether the machine is hung (and reboot it) or a network issue at hetzner
08:25:52 <merijn> I think someone at Hetzner has to physically give the machines a kick if they're stuck and I wouldn't know who to contact there
08:25:59 <benzrf> hetzner?
08:26:10 <merijn> benzrf: The company hosting the boxes
08:26:15 <benzrf> ah
08:26:31 <dino-> Thank you
08:28:11 <chrisdone> i wonder what specifically is wrong with the hetzner setup
08:28:40 <chrisdone> i use hetzner for lpaste, tryhaskell, haskellnews, ircbrowse and it's never gone down in 8~ months
08:29:15 <ifesdjeen> does anyone know if there's any way, having a type defined in a following way:
08:29:23 <ifesdjeen> data LispExpression = LispSymbol String |  LispNumber Integer | LispString String
08:29:31 <ifesdjeen> to write a function that'd construct LispExpression from either String or Integer?..
08:29:36 <ifesdjeen> I can write that:
08:29:41 <ifesdjeen> mklSymbol :: String -> LispExpression
08:29:43 <ifesdjeen> mklSymbol n = LispSymbol n
08:29:47 <ifesdjeen> but I'd like to generalise and pattern-match based on type of left-hand expression
08:29:50 <ifesdjeen> i assume that could be done via typeclasses somehow?
08:29:51 <benzrf> ifesdjeen: you could use a typeclass
08:29:58 <benzrf> something like
08:30:18 <merijn> ifesdjeen: You probably want GADTs
08:30:32 <merijn> chrisdone: Hetzner has been *really* unstable for rock :\
08:30:36 <merijn> chrisdone: lun and lambda are up
08:30:41 <benzrf> class LispLiteral l where toSexp :: l -> LispExpression
08:30:43 <ifesdjeen> merijn: what're GADTs?..
08:30:54 <ifesdjeen> benzrf: thanks, great, will try that out
08:30:58 <merijn> ifesdjeen: https://en.wikibooks.org/wiki/Haskell/GADT
08:30:59 <benzrf> instance LispLiteral Int where toSexp = LispNumber
08:31:06 <chrisdone> merijn: i don't know the server names. there are three on hetzner?
08:31:24 <merijn> ifesdjeen: They're Generalized Algebraic DataTypes
08:31:45 <merijn> chrisdone: I thought 4, but ironically, I can't check because our documentation is hosted on one of the VMs >.>
08:31:48 <ifesdjeen> merijn: as far as I can see, i need to do exactly the opposite, am I wrong?..
08:32:08 <ifesdjeen> i mean - given a simple type, i have to construct GADT
08:32:41 <bennofs> merijn: what are lambda and lun doing? All .haskell.org domains seem to be down
08:32:44 <fizruk> wow, I didn't know I can do  type X = forall m. Monad m => MaybeT m
08:32:49 <merijn> ifesdjeen: Rather, I meant you might want to use a GADT instead of your current LispExpression datatype
08:32:56 <fizruk> how is the scope of forall determined?
08:33:00 <ifesdjeen> ah, ok thanks merijn
08:33:48 <merijn> ifesdjeen: The wikibook I linked has an example of using GADTs for ASTs, it's fairly easy to understand and the examples should be similar to what you're doing
08:34:32 <merijn> bennofs: I don't remember of the top of my head
08:35:18 <merijn> ifesdjeen: And even if you don't use, GADTs are cool to know :p
08:35:22 <Sagi> perhaps the haskell community should consider colocating one or more machines at universities, to spread out the risk, while keeping costs low.
08:35:57 <merijn> Sagi: If you're at a university willing to donate a machine, feel free to offer :)
08:36:08 <enthropy> it used to be that way I think
08:36:17 <enthropy> as in haskell.org was one machine at yale I think
08:36:25 <Sagi> well, I know one which might offer rackspace / bandwidth. Not sure about the actual machine.
08:36:52 <Sagi> which I guess is the costly part on the long term.
08:37:04 <chrisdone> hmm, but heztner are stable
08:37:06 <merijn> enthropy: Currently I believe Galois is hosting one machines that is being phased out, there's still a university machine (in Sweden I think? Probably Chalmers or something)
08:37:37 <chrisdone> i'd be interested to see what the software on the dedicated host is doing before blaming hetzner
08:38:24 <merijn> chrisdone: Sure, I wasn't blaming Hetzner. I was saying it's either the machine OR hetzner and without out-of-band access it's hard to determine
08:38:26 <Kinnison> ls
08:38:51 <chrisdone> merijn: sure, i was more referring to Sagi whose answer to the downtime is "get another server"
08:39:10 <merijn> chrisdone: Ideally we'd have something like integrated lights-out or whatever it's called for non-HP machines
08:39:25 <Sagi> chrisdone: that's not my answer.
08:40:16 <Sagi> it was tangential to the current outage.
08:40:44 <chrisdone> Sagi: sure, and if there'd been no outage, you wouldn't've have brought it up. because nobody needs to fix working servers
08:40:46 <Sagi> the mention of scores of haskell.org services running at one hosting provider just got me thinking.
08:41:10 <Sagi> the risk is the same, whether they work or not.
08:41:32 <Sagi> just trying to help, don't get me wrong. :(
08:41:55 <chrisdone> Sagi: sure
08:43:17 <merijn> Sagi: Agreed, but there's not enough manpower and money to have nice redundant setups of everything.
08:43:35 <Sagi> okay
08:44:02 <Sagi> is there some page somewhere documenting who the awesome people are currently supporting everything?
08:44:10 <chrisdone> merijn: the weird thing is why redundancy is so needed. what's going on with these machines that makes them go down so often?
08:44:31 <merijn> chrisdone: Well, in this case it's that one machine that's down is hosting multiple VMs
08:44:45 <Sagi> hey chrisdone, take note: I haven't mentioned redundancy a single time :)
08:44:53 <merijn> chrisdone: And it's unclear why they're so unstable.
08:45:11 <merijn> chrisdone: It's on the "to-do" list to figure out with Hetzner what's going on
08:45:19 <merijn> Sagi: I don't believe there is such a page atm
08:45:28 <chrisdone> merijn: nod, i heard the same some weeks ago last time it happened
08:46:00 <donri> hm i think there are pages for the haskell.org committee or whatever they're calling it
08:46:08 <donri> but it's probably down, too ;)
08:46:53 <Sagi> heh, I fondly remember the numerous times I forgot to move the 'how to restore' documentation off the service to restore :-P
08:47:07 <Sagi> makes one feel a tad stupid
08:47:37 <merijn> Well, #haskell-infrastructure has most community admins
08:48:09 <wojtekM_> Let me take the opportunity to improve my list processing skills.
08:48:14 <wojtekM_>  (\(a:'a':tl) -> a:'A':tl) "Hackage"
08:48:54 <allsystemsarego> hi all, I remember skimming through a fairly in-depth article on GHC extensions at School of Haskell a while ago, but I can't find it right now, does anyone know what happened to it?
08:49:15 <codh> F# has |> operator, what's haskell's responding one?
08:49:18 <chrisdone> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions
08:49:29 <donri> upon (!!1) %~ toUpper $ "Hackage"
08:49:31 <allsystemsarego> chrisdone, thanks
08:49:37 <frxx> codh what does it do?
08:49:49 <merijn> I believe it's flipped function application
08:49:56 <chrisdone> lol
08:50:05 <codh> It's just post application
08:50:06 <merijn> codh: "x |> f" == f x, right?
08:50:06 <donri> that's (&) in ghc 7.8
08:50:07 <chrisdone> &
08:50:12 <codh> yes..
08:50:18 <chrisdone> donri: & got into base?
08:50:22 <merijn> lens exports & for that
08:50:26 <donri> chrisdone: apparently so
08:50:28 <merijn> Not sure whether that's in base
08:50:30 <donri> in Data.Function
08:50:31 <chrisdone> donri: lol
08:50:41 <donri> not Prelude ;)
08:50:44 <chrisdone> i guess they wanted to put something else in Data.Function to fill it out
08:50:46 <codh> thanks everybody
08:50:49 <monoidal> not in my HEAD
08:51:38 <donri> not sure it's been added yet but the libs committee OKed it
08:51:42 <donri> edwardk says
08:53:55 <stelleg> haskell.org down for others?
08:53:58 <monoidal> yes
08:54:01 <corkexaminer> yup
08:54:10 <sclv> luite: you around?
08:54:11 <stelleg> k thanks
08:57:18 <Sagi> merijn: for one thing, there appear loops in my mtr to haskell.org in the hertzner network with core21.hertzner.de appearing at hops 9 and 17.
08:58:25 <Tekmo> @src lines
08:58:25 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:58:36 <bennofs> @botsnack
08:58:37 <lambdabot> :)
08:58:40 <Tekmo> No, I haven't, lambdabot
08:58:40 <donri> ohai lambdabot
08:58:41 <bennofs> lambdabot is back !
08:59:02 <sdrodge> Is there a simple built-in way to accumulate a Vector and simultaneously calculate the sum of the differences?
08:59:20 <Tekmo> What do you mean by accumulate?
08:59:36 <chrisdone> maybe like scanl
08:59:42 <int-e> lambdabot was running happily without any connection to the IRC server :/ (it had a ping timeout this morning)
08:59:52 <sdrodge> Tekmo: I'm currently calling Data.Vector.Unboxed.accumulate
09:00:05 <chrisdone> int-e: you're running lambdabot?
09:00:15 <donri> chrisdone: this week, yes
09:00:15 <int-e> chrisdone: yes
09:00:31 <Tekmo> sdrodge: So do you want two vectors, or a vector with two values at each position?
09:00:39 <chrisdone> int-e: poop it behind an irc bouncer
09:00:47 <chrisdone> er, pop
09:01:49 <chrisdone> int-e: the irc bouncer will manage reconnections and timeouts for you. as far as lambdabot is concerned, it will be connected indefinitely
09:02:09 <sdrodge> Tekmo: I want to generate a new vector using an accumulator function and another vector of (index, value) tuples. I also want to know the sum of the deltas.
09:02:13 <Sagi> unless it loses its connection to the bouncer :-)
09:02:21 <chrisdone> Sagi: how would that happen?
09:02:45 <Eduard_Munteanu> I have a weird bug on this cheapo keyboard as well... apparently I type faster than the keyboard debounces, so I get stuff like "fufnction", not "ffunction".
09:02:49 <Sagi> eh well, an irc bouncer is nothing more than a shim represeting a server to its client and a client to the real server?
09:02:53 <Sagi> or am I missing something?
09:03:02 <chrisdone> Sagi: you put the bouncer on your localhost
09:03:03 <sdrodge> Tekmo: This is what I'm currently doing: http://pastebin.com/mszXfiJN
09:03:04 <Eduard_Munteanu> Debounces wrongly that is.
09:03:07 <mauke> The paste mszXfiJN has been copied to http://lpaste.net/95759
09:03:23 <Sagi> chrisdone: oh, that'd work.
09:03:30 <chrisdone> this is how lpaste remains connected all the time, despite the fact i'm restarting the server once in a while
09:03:47 <intrados> Is there a general style rule regarding free variables in where declarations? (e.g. avoid them and pass in parameters)
09:03:50 <Sagi> that's an additional advantages, seemingly seamless upgrades
09:03:52 <Sagi> -
09:03:53 <Sagi> -s
09:04:00 <chrisdone> seeming seamless, i like it
09:04:13 <chrisdone> +ly
09:04:18 <Sagi> chrisdone: that's what it is, right :o)
09:04:31 <Eduard_Munteanu> intrados: I generally add parameters to preserve pointfree expressions.
09:04:50 <Eduard_Munteanu> Not to avoid free variables necessarily.
09:04:51 <alexander__b> uhm is hackage and haskell.org both down?
09:04:56 <bennofs> yes
09:05:02 <alexander__b> wtf
09:05:05 <alexander__b> what's up?
09:05:14 <Eduard_Munteanu> Nothing, they're all down. :P
09:05:26 <Sagi> Just outage
09:05:27 <Sagi> lol
09:05:28 <alexander__b> Eduard_Munteanu: badumtsch
09:05:32 <merijn> We just got some info from Hetzner the datacenter hosting them is being DOSed
09:05:42 <chrisdone> D:
09:05:59 <chrisdone> bob harper's gone too far this time
09:06:04 <alexander__b> merijn: aw that sucks. my vpn was ddosed these last couple of days so at first I thought my vpn was down again
09:06:10 <Iceland_jack> chrisdone: link?
09:06:15 <chrisdone> Iceland_jack: just joking
09:06:45 <Iceland_jack> I was expecting an exciting blog post :)
09:08:28 <merijn> Iceland_jack: Bob Harper used to be an ML fanatic (and nowadays an F# fanatic?) that's always complaining how ML/F# are better than Haskell and is really upset about haskell being the more popular language :p
09:08:39 <Sagi> merijn: ah, this one? http://www.hetzner-status.de/#2366
09:08:43 * donri browses some haddocks on file:// to calm his hackage withdrawal
09:08:56 <sdrodge> If I want to update a Vector of values using another Vector of (index, values), as well as update the stored sum of the Vector, is there a way to make sure that happens all in one loop?
09:09:19 <sdrodge> It's so trivial in imperative languages, but I honestly can't figure out how to do it in Haskell.
09:09:22 <Iceland_jack> merijn: I'm aware of Bob Harper, I assumed he'd written a blog post which goes over the top
09:09:43 <Eduard_Munteanu> sdrodge: make a wrapper around the vector and update both the sum and vector
09:09:45 <cue> does State monad only queue functions applied to the value, and then runs those functions when you request it? it does not actually mutate anything, right
09:10:07 <Eduard_Munteanu> cue: sort of, yeah
09:10:23 <Eduard_Munteanu> cue: only IO and ST actually do mutation.
09:10:24 <Iceland_jack> cue: It's just sugar over “s -> (s, a)”
09:10:28 <sdrodge> Eduard_Munteanu: I pasted the code that I currently have, which I think does what you describe, but it definitely doesn't execute in a single loop...
09:10:47 <chrisdone> merijn: he mad
09:10:53 <Tekmo> sdrodge: The trick to these sort of things is to have your function do it in two steps
09:10:58 <Eduard_Munteanu> sdrodge: pasted where?
09:11:06 <Tekmo> sdrodge: First you have a function that produces a vector that computes two values at each element, i.e.:
09:11:14 <Tekmo> myFunction :: Vector A -> Vector (B, C)
09:11:24 <Tekmo> That ensures that you compute everything in one pass over the vector
09:11:31 <Tekmo> The second step is to unzip the final vector
09:11:42 <Tekmo> unzip :: Vector (B, C) -> (Vector B, Vector C)
09:11:56 <Tekmo> Now you have your two separate vectors
09:12:00 <Eduard_Munteanu> sdrodge: also, how do you know, and what loop is that?
09:12:27 <sdrodge> Tekmo: How does this work if the update list is much shorter than the total length of the Vector?
09:12:43 <benzrf> how can I make an entire file accessible elsewhere?
09:12:50 <benzrf> I want to write unit tests
09:12:53 <Tekmo> sdrodge: Let me study your code more closely.  Hold on
09:13:04 <Clint> anyone know offhand when conduit got the Consumer type?
09:13:26 <donri> benzrf: no good answer. the common practice is to put it in an .Internal module and export that
09:13:38 <benzrf> explain?
09:13:50 <benzrf> this is why i like python's import scheme
09:13:57 <benzrf> its basically the best one ive seen
09:14:04 <donri> benzrf: or you can duplicate the build and point the unit tests at the same hs-source-dirs
09:14:05 <sdrodge> Eduard_Munteanu: I could be wrong, I haven't actually read the core, but my understanding is that Data.Vector.accumulate works in a single loop, with only one allocation.
09:14:21 <benzrf> ?
09:14:45 <sclv> here's the downtime announcement on reddit: http://www.reddit.com/r/haskell/comments/1qrldv/haskellorg_servers_down_at_the_moment/
09:14:47 <donri> benzrf: maybe i didn't understand the question. what do you want to do?
09:14:59 <sclv> if anyone has other mirrors or alternate resources they should feel free to add them there
09:15:07 <benzrf> ugh brb
09:15:11 <benzrf> my father is being a jerk
09:15:32 <Eduard_Munteanu> sdrodge: I wasn't suggesting that, rather making your own wrapper around Vector to update the elements and the sum, but you write that yourself.
09:16:16 <Tekmo> Ugh, I wish Hackage was up
09:16:24 <sdrodge> Eduard_Munteanu, won't I need to do that in the ST Monad in order to do only do one allocation?
09:16:29 <sdrodge> Tekmo: You and me both.
09:17:20 <Tekmo> sdrodge: So I think there is a function in `Data.Vector` that you can use to do multiple index lookups at a time
09:17:47 <benzrf> Tekmo: hackage mirror
09:17:53 <benzrf> donri: i want to write unit tests for a file
09:17:54 <Eduard_Munteanu> sdrodge: no, I mean you can write    data SumVec a = SumVec (Vector a) a    and when you update the vector, you update the 'a' by the difference too.
09:18:10 <sdrodge> Eduard_Munteanu: I'm already doing that...
09:18:12 <donri> benzrf: and what is the problem preventing you from doing that?
09:18:16 <Tekmo> sdrodge: However, even before doing that, I would suggest one thing, instead of doing `bData' ! i - bData ! i`, you should instead first compute `zipWith (-) bData bData'` and then index inot that
09:18:22 <sdrodge> Eduard_Munteanu: My question is about how to do it efficiently.
09:18:33 <Eduard_Munteanu> sdrodge: well, that is efficient, IMO
09:18:49 <Tekmo> sdrodge: In other words: `bDiff = U.zipWith (-) bData' (bData b)`
09:19:02 <benzrf> donri: how do i see the funcs from the other file?
09:19:04 <Tekmo> sdrodge: Then you can just do `bDiff ! i` any time you want to look up the difference
09:19:18 <sdrodge> Eduard_Munteanu: Your suggestion is grossly underspecified, the structure of the data does not tell me what implementation you have in mind.
09:19:22 <cue> > sequence ["h", "e3", "lL", "o0"]
09:19:24 <lambdabot>   ["helo","hel0","heLo","heL0","h3lo","h3l0","h3Lo","h3L0"]
09:19:30 <cue> how does that work?
09:19:32 <donri> benzrf: make sure it's a module, then you can import it
09:19:46 <Rylee> @src sequence
09:19:46 <lambdabot> sequence []     = return []
09:19:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:19:47 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
09:19:49 <benzrf> donri: how do i make it a module? i tried 'module Foo where', but it syntaxerrors
09:19:51 <Iceland_jack> cue: Because of how the list monad works
09:19:57 <sdrodge> Tekmo: Reading what you wrote. Trying to make sure I understand.
09:19:58 <benzrf> cue:  monads
09:20:05 <benzrf> cue:
09:20:07 <Tekmo> sdrodge: Let me make an lpaste
09:20:09 <benzrf> :t sequence
09:20:12 <lambdabot> Monad m => [m a] -> m [a]
09:20:16 <donri> benzrf: that shouldn't syntax error. are you sure it said syntax error?
09:20:24 <Iceland_jack> if you don't know about how the list monad works, learn that before attempting to understand why sequence does that
09:20:30 <benzrf> Soko.hs:7:1: parse error on input `module'
09:20:41 <benzrf>    7 module Soko where
09:20:52 <Iceland_jack> benzrf: What is above line 7?
09:21:01 <benzrf> blank line, then imports
09:21:07 <Iceland_jack> Next response, move imports below line 7
09:21:09 <monoidal> cue: it's equivalent to [[x,y,z,t], x <- "h", y <- "e3", z <- "lL", t <- "oO"]
09:21:11 <benzrf> ah
09:21:11 <cue> I understand that we can use sequence to execute [IO a], but i am having trouble wrapping my head around how this applies to list with above result
09:21:13 <int-e> hPutStr is not atomic, is it?
09:21:17 <bennofs> benzrf: move the imports after line 7
09:21:18 <Tekmo> Here you go:
09:21:19 <Tekmo> http://lpaste.net/95760
09:21:31 <benzrf> cue: you need to understand the behavior of lists as monads
09:21:31 <cue> monoidal i see
09:21:45 <monoidal> cue: or do x <- "h"; y <- "e3"; z <- "lL", t <- "oO"; return [x,y,z,t]
09:21:55 <cue> ah
09:21:55 <monoidal> cue: which is the same as the list comprehension, but using do-notation
09:21:59 <sdrodge> Tekmo: If I understand it correctly, you're suggesting that use zipWith on the entire Vectors, then use my Vector that holds the indices to extract the sum of the differences.
09:21:59 <WraithM> Is haskell.org down?
09:22:04 <monoidal> WraithM: yes
09:22:07 <benzrf> @src (>>=) :: [a] -> (a -> [b]) -> [b]
09:22:07 <lambdabot> Source not found. My brain just exploded
09:22:10 <WraithM> monoidal: Thanks
09:22:11 <benzrf> buh
09:22:31 <monoidal> cue: sequence [x1, x2,...,xn] = do y1 <- x1; y2 <- x2; ... yn <- xn; return [y1,y2,...,yn]
09:22:34 <quchen> @src [] (>>=)
09:22:35 <Eduard_Munteanu> sdrodge: modify i f (SumVec v s) = SumVec (modify i f v) (s + new - old) where old = v ! i; new = f old
09:22:35 <lambdabot> xs >>= f     = concatMap f xs
09:22:40 <WraithM> (oops, top thing on reddit...)
09:22:50 <Tekmo> sdrodge: Yes, so far
09:22:51 <cue> makes sense, thanks
09:23:13 <Tekmo> sdrodge: I'm still studying your code to see how else it can be simplified
09:23:18 <Eduard_Munteanu> sdrodge: I don't know the actual API now, but by the second modify I mean the one that updates the index 'i' by applying 'f' to the value there in 'v'.
09:23:21 <sdrodge> Tekmo: Thanks!
09:23:43 <Tekmo> No problem at all
09:24:05 <cue> I am still puzzled about the types though
09:24:07 <cue> :t sequence
09:24:09 <lambdabot> Monad m => [m a] -> m [a]
09:24:16 <benzrf> ok
09:24:17 <cue> how can [m a ] and m [a] be the same?
09:24:21 <cue> for list monad
09:24:21 <Tekmo> cue: m = []
09:24:27 <benzrf> they arent
09:24:29 <benzrf> that's the point
09:24:32 <Tekmo> cue: So it expands to: [[a]] -> [[a]]
09:24:33 <benzrf> it converts one to the other
09:24:43 <cue> benzrf but both input and output are [[a]]
09:24:46 <sdrodge> Eduard_Munteanu: That is exactly the solution I am looking for. Really wish hackage wasn't down.
09:24:49 <cue> or [String
09:24:51 <monoidal> remember [a] is syntax sugar for application of [] a
09:25:05 <Tekmo> sdrodge: I think I found the function
09:25:06 <benzrf> cue: the outer list is the monad being used in the first, & the inner in the second
09:25:10 <benzrf> cue: it might help to look at it as:
09:25:17 <Eduard_Munteanu> cue: sequence turns a list of actions into a big action returning a list of results.
09:25:18 <benzrf> [[] a] -> [] [a]
09:25:21 <Tekmo> sdrodge: I think `backpermute` is the one
09:25:22 <quchen> cue: Maybe this helps? https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
09:25:25 <benzrf> ok
09:25:26 <sdrodge> Tekmo: Check out Eduard_Munteanu's suggestion. Is that the solution?
09:25:27 <monoidal> cue: you can read [] as List. Then the type is Monad m => List (m a) -> m (List a), and put m = List
09:25:34 <benzrf> i've put 'module Soko where' at the beginning of Soko.hs
09:25:35 <intrados> Is there not a sort for standard vectors?
09:25:37 <benzrf> but I cannot 'import Soko'
09:25:38 <benzrf> ??
09:25:58 <sdrodge> Tekmo: `backpermute` sounds interesting!
09:26:07 <Sagi> :t local
09:26:09 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
09:26:31 <donri> benzrf: how are you compiling the code that imports soko?
09:26:35 <cue> ah, m is list, so it's [[a]] regardless if it's m [a] or [m a]
09:26:43 <benzrf> donri: i'm trying it from ghci first
09:26:44 <monoidal> cue: right
09:26:45 <benzrf> cue: yes
09:27:11 <cue> it is a lot clearer now, thanks!
09:27:15 <int-e> chrisdone: thanks for the suggestion btw, I'll look into that. but right now the problem is that lambdabot does nothing on being disconnected, and I'm not quite sure how an irc bouncer would help there (except perhaps by reducing the number of actual disconnects)
09:27:23 <Tekmo> sdrodge: So the type of `backpermute` is:
09:27:31 <Tekmo> backpermute :: Vector a -> Vector Int -> Vector a
09:27:32 <donri> :t T.sequence `asAppliedTo` []
09:27:33 <lambdabot> Monad m => [m a] -> m [a]
09:27:45 <Tekmo> sdrodge: The second argument is a vector of indices to lookup
09:27:53 <quchen> :t T.sequence `asAppliedTo` [[]]
09:27:54 <bennofs> :t T.sequence `asAppliedTo` [[]]
09:27:54 <benzrf> :t asAppliedTO
09:27:55 <lambdabot> [[a]] -> [[a]]
09:27:56 <lambdabot> [[a]] -> [[a]]
09:27:56 <lambdabot>     Not in scope: `asAppliedTO'
09:27:56 <lambdabot>     Perhaps you meant `asAppliedTo' (line 140)
09:27:56 <Tekmo> sdrodge: And the result is a vector containing all the results it looked up
09:27:59 <benzrf> :t asAppliedTo
09:28:00 <lambdabot> (a -> b) -> a -> a -> b
09:28:07 <Tekmo> sdrodge: So that means you can simplify your fold even further
09:28:10 <chrisdone> int-e: the idea is you have the bouncer and lambdabot on the same machine
09:28:18 <Tekmo> sdrodge: One second while I write it up
09:28:23 <quchen> benzrf: asAppliedTo = const :: (a -> b) -> a -> a -> b
09:28:38 <benzrf> o
09:28:38 <chrisdone> int-e: the bouncer and lambdabot will never be disconnected
09:28:42 <bennofs> I have the feeling the lambdabot is faster when restarted :O
09:28:49 <bennofs> Does it get slower over time?
09:29:07 <chrisdone> int-e: when the bouncer disconnects from freenode it will reconnect, but its connect to lambdabot will remain running
09:29:11 <donri> :t T.sequence :: (Traversable t) => t [a] -> [t a]
09:29:13 <lambdabot> Traversable t => t [a] -> [t a]
09:29:15 <benzrf> donri: why can i not import?
09:29:18 <benzrf> [ghci]
09:29:41 <int-e> chrisdone: do you have a recommendation for bouncer software?
09:29:47 <chrisdone> i use znc
09:29:54 <Tekmo> sdrodge: Check out the second version here: http://lpaste.net/95760
09:30:05 <aristid> int-e: use irssi or weechat.
09:30:28 <donri> benzrf: oh ok, for ghci you may need to :add the file before you can import it
09:30:40 <benzrf> hm
09:30:44 <benzrf> what doe sthat do?
09:30:59 <Wizek> hi
09:31:09 <kanishka> hey Capital IQ folks, i want to go back through about 3 textbooks and do random exercises, both for curiosity and sharpen me up for interviews
09:31:19 <kanishka> what are your picks?
09:31:30 <Wizek> Can I somehow ensure that my new data type has integers only within a certain range?
09:31:31 <sdrodge> Tekmo: Nifty. Gonna take it out for a spin.
09:31:35 <Tekmo> A really good source of coding exercises is HackerRank
09:31:53 <Tekmo> sdrodge: I still think it can be improved more
09:31:54 <chrisdone> Wizek: so-called “smart constructors”
09:32:05 <chrisdone> Wizek: makeThing :: Integer -> Maybe Thing
09:32:37 <benzrf> kanishka: Ive been writing a sokoban game
09:32:40 <benzrf> so far it's been fun
09:33:00 <donri> benzrf: basically tells ghci to interpret that file without actually loading it, i guess
09:33:01 <Wizek> chrisdone: Looking
09:33:22 <chrisdone> Wizek: you write your smart constructor so that it will reject bad values
09:33:24 <donri> benzrf: you should be using cabal to manage all this though :)
09:33:24 <kanishka> benzrf: ...i cn't get psyched about games for some reason... dry algorithm or graph theory usually my style
09:33:26 <benzrf> ok?
09:34:10 <sdrodge> Tekmo: Does laziness cause this version to not actually compute all the subtractions in bDiff?
09:34:34 <Tekmo> sdrodge: Not if it is Unboxed
09:34:38 <donri> kanishka: homotopy type theory? ;)
09:34:57 <Tekmo> sdrodge: You need boxed vectors if you want laziness
09:35:33 <benzrf> why can't every language handle imports like Python
09:35:34 <benzrf> ;_;
09:35:47 <kanishka> wow, that's is awesomely obscure, just make take you up on that
09:35:49 <Tekmo> sdrodge: So the last thing I'm trying to figure out is how to compute `bData'` and `bDiff` in a single pass over `bData b`
09:35:51 <sdrodge> Tekmo: It is Unboxed. New version runs about 50% slower (the entire program does, that is, which would imply than this new version is more than 100% slower)
09:36:11 <hpc> benzrf: because python imports are order-sensitive and verbose by default
09:36:22 <Tekmo> sdrodge: That's probably because it is unnecessarily computing differences
09:36:32 <sdrodge> Tekmo: Agreed.
09:36:32 <donri> Wizek: you can write a function Int -> Maybe Range, or Int -> Range with pure exceptions (don't), or go nuts with dependent types
09:37:03 <donri> Wizek: or you can truncate, also not recommended
09:37:37 <benzrf> hpc: explain?
09:37:40 <Tekmo> sdrodge: What is the relative size of the two vectors?
09:38:07 <benzrf> hpc: i just meant, you can import any file as a namespace containing all of the top-level definitions in the file
09:38:10 <Tekmo> sdrodge: The reason I'm asking is that the only benefit of doing it the zipWith way I proposed if is you want to memoize the diff results
09:38:13 <lpaste> fizruk pasted “Impredicative types (what's wrong?)” at http://lpaste.net/95762
09:38:28 <donri> kanishka: it's also a book btw http://homotopytypetheory.org/book/
09:38:28 <Tekmo> sdrodge: If you don't need to memoize the results then you should probably go back to what you originally had for that part
09:38:34 <benzrf> hpc: so i guess basically how haskell does it, but without explicit module defs & with qualified by default
09:38:44 <benzrf> but less verbose names
09:38:50 <Tekmo> sdrodge: Or use a boxed vector for `bDiff` and see if that improves things
09:39:08 <sdrodge> Tekmo: It depends. I can point you the whole code if you want, but in general the update vector is substantially less than half the total size of the vector
09:39:20 <hpc> qualified by default annoys me in languages that have it, including agda and python
09:39:43 <sdrodge> Tekmo: https://github.com/sjdrodge/neopets_shapeshifter/blob/master/ShapeShifter.hs
09:39:45 <Tekmo> sdrodge: So can you remind me what were the two parts that you wanted to do in a single pass?
09:40:27 <sdrodge> Tekmo: I want to update the vector and simultaneously update/obtain the sum of the deltas
09:40:59 <Wizek> I'm looking at this right now: http://webcache.googleusercontent.com/search?q=cache:gFc02u95PesJ:www.haskell.org/haskellwiki/Smart_constructors+&cd=1&hl=en&ct=clnk
09:41:11 <Wizek> I need to list all correct values?
09:41:17 <benzrf> hpc: well you can always from foo import *
09:41:33 <donri> Wizek: smart constructor just means function
09:41:35 <Tekmo> sdrodge: So I'm assuming the single pass solution you had in mind is that as you are updating `bData` to `bData'` that you are also checking to see if the current index matches one from your `d` vector, and if so then you update the sum?
09:41:42 <Eduard_Munteanu> fizruk: does it work without '$'?
09:42:21 <Tekmo> sdrodge: If you show me the equivalent imperative code it will be easier for me to figure out what your intended behavior is
09:43:01 <fizruk> Eduard_Munteanu, not actually...
09:43:23 <sdrodge> Tekmo: I'm actually trying to achieve code that is the same as a for loop over the update vector, which for each element updates the corresponding element in the data vector and then uses the "delta" to update another variable
09:43:51 <sdrodge> Tekmo: Let me write up a bit of imperative pseudo-code
09:44:52 <fizruk> Eduard_Munteanu, evalStateT good 20 works *if* type X a = forall m. Monad m => StateT Integer m a    (that is fully applied)
09:45:29 <Eduard_Munteanu> fizruk: I mean, have you tried writing it as  "evalStateT (runWriterT bad) 10" ? (without flip too)
09:46:07 <sdrodge> http://lpaste.net/95763
09:47:38 <fizruk> Eduard_Munteanu, that doesn't change anything
09:47:58 <Eduard_Munteanu> fizruk: hm, ok, so it's not just GHC's special rules for impredicative ($).
09:48:14 <Eduard_Munteanu> (assuming you actually tried that :D)
09:48:39 <Tekmo> sdrodge: Just one question: couldn't you get rid of the `temp` variable just by switching the order of assignments?
09:49:06 <sdrodge> Tekmo: Yeah. Of course.
09:49:12 * sdrodge feels a bit silly.
09:49:28 <earldouglas> Is hackage down?
09:49:30 <fizruk> Eduard_Munteanu, yes, I've tried
09:49:45 <earldouglas> Cabal keeps timing out on me.
09:49:47 <sclv> earldouglas: yes :-(
09:49:50 <fizruk> Eduard_Munteanu, also there's another interesting behavior on a smaller example
09:49:57 <sclv> see the mirror in the channel topic
09:50:07 <sdrodge> Tekmo: The difference in my actual example, though, is that there's a modulus.
09:50:08 <sclv> it has instructions for pulling from there instead
09:50:08 <earldouglas> sclv, thanks
09:50:22 <sdrodge> Tekmo: Not sure if that make the temp variable necessary or not...
09:50:34 <Tekmo> sdrodge: Well, to make things simple I'll just translate the imperative pseudocode
09:50:43 <Tekmo> sdrodge: I think it will still work even with the modulus
09:51:30 <sdrodge> Tekmo: before you do that, I should fix it.
09:51:41 <Tekmo> sdrodge: Ok
09:52:47 <sdrodge> Tekmo: http://lpaste.net/95763
09:53:01 <Eduard_Munteanu> fizruk: hm, aren't you missing a Monad constraint on 'm'?
09:53:24 <fizruk> Eduard_Munteanu, I am, but that's not the point :)
09:53:31 <lpaste> fizruk annotated “Impredicative types (what's wrong?)” with “Impredicative types (what's wrong?) (annotation)” at http://lpaste.net/95762#a95766
09:53:36 <Eduard_Munteanu> fizruk: you can't instantiate 'm' to a Monad IO if it's any functor 'm'.
09:53:58 <monoidal> fizruk: you can't use "forall" on non-* type
09:54:05 <monoidal> fizruk: GHC should detect that, but it doesn't
09:54:11 <Eduard_Munteanu> Um, why?
09:54:21 <fizruk> monoidal, are you sure?
09:54:28 <monoidal> yes
09:54:51 <monoidal> you can't even unify (forall a. Maybe) Int with Maybe Int in GHC
09:55:37 <fizruk> monoidal, is it just an unimplemented feature?
09:55:44 <Tekmo> sdrodge: Ok, so the first way to simplify this is to annotate each (i, x) with the value of temp.  You can do this with U.map and not worry that it will generate an extra pass over the vector
09:55:45 <Eduard_Munteanu> monoidal: shouldn't you be able to instantiate 'forall a. Maybe' to 'Maybe' then apply it?
09:55:54 <osa1> is hackage down?
09:55:56 <Tekmo> sdrodge: I will annotate the beginning of this.  One second
09:55:58 <monoidal> osa1: yes
09:56:01 <Eduard_Munteanu> osa1: yes, see /topic
09:56:03 <osa1> ...
09:56:38 <monoidal> Eduard_Munteanu, fizruk: whether this should be allowed, opinions might differ, but as it stands, GHC essentially does not support it.
09:56:54 <Eduard_Munteanu> Hm, weird.
09:57:09 <Tekmo> sdrodge: http://lpaste.net/95763
09:57:11 <monoidal> ghc bug #8388  if someone is interested
09:57:39 <fizruk> monoidal, thanks!
09:58:43 <Tekmo> sdrodge: Oops, I accidentally overwrote it, but here: http://lpaste.net/95767
09:58:51 <Tekmo> That shows the reduced imperative problem we now have to solve
09:58:57 <monoidal> if course ghc trac is down atm
09:59:11 <Eduard_Munteanu> monoidal: I'm getting to the Google cached page :)
09:59:42 <sdrodge> Tekmo: Thanks muchly for the help.
10:00:03 <sdrodge> Tekmo: I'll give this a shot in a few minutes.
10:00:07 <monoidal> I'm opposed to allowing "forall" in general - for example, kind Bool will not only have False and True as types, but also forall (a :: Bool). a and others
10:01:15 <monoidal> "in general" meaning for non-* kind
10:01:22 <Eduard_Munteanu> monoidal: hm... I guess the more general problem is 'forall' per se, instead of a proper pi type. Otherwise you wouldn't need to make those things equivalent.
10:01:32 <benzrf> where is the ghci histfile
10:01:34 <jmcarthur> something seems wrong with  (forall (a :: Bool). a) :: Bool
10:02:25 <donri> benzrf: .ghc/ghci_history
10:02:50 <jmcarthur> i'm not even sure i can wrap my head around  (forall (a :: *). a) :: *   now that i think about it
10:03:19 <benzrf> donri: THANKS
10:03:23 <benzrf> oops caps
10:03:27 <monoidal> jmcarthur: that's the type of undefined
10:03:40 <Eduard_Munteanu> jmcarthur: yeah, exactly... instead, it's fairly straightforward as an actual type function
10:04:19 <jmcarthur> monoidal: i realize that. i'm just remarking that i don't know how this type system works ;)
10:04:30 <jmcarthur> Eduard_Munteanu: right
10:04:53 <fizruk> Eduard_Munteanu, you mean one could right (\a -> a) :: * -> * ?
10:05:12 <jmcarthur> fizruk: in some type systems, forall is roughly a type level lambda
10:05:35 <scott_> What is the default Applicative instance in ghci? e.g. when I say 'pure 2' it shows the result as '2' but I don't know what instance it's using
10:05:41 <jmcarthur> fizruk: so yeah, it could look something like that in such a type system
10:05:53 <Eduard_Munteanu> fizruk: more like in dependent types... (a :: *) => a -> a, making '=>' an actual arrow.
10:06:08 <monoidal> scott_: IO
10:06:18 <scott_> monoidal: Thanks
10:06:29 <jmcarthur> fizruk: Eduard_Munteanu's reply is more correct than mine
10:06:59 <witt3rd> hi - I'm working through basic parser using Hutton's book and have a style question: http://lpaste.net/95769
10:07:24 <witt3rd> why the use of lambda and case .. of instead of just pattern matching?
10:07:37 <Tekmo> sdrodge: Ok, I narrowed it down further: http://lpaste.net/95763
10:07:38 <fizruk> Eduard_Munteanu, i don't understand "making => an actual arrow" :)
10:07:40 <monoidal> witt3rd: I think your version is more idiomatic. they're equivalent.
10:08:02 <witt3rd> cool!  thanks!
10:08:18 <quchen> witt3rd: The 'case' version is pretty weird to write as a human. The runtime behaviour should be the same though (as GHC rewrites pattern matching to case blocks).
10:08:30 <jmcarthur> in ghc there is a slight difference, but it doesn't affect semantics
10:08:35 <monoidal> witt3rd: umm you need = instead of -> in the second version
10:08:46 <witt3rd> oops, yes, thanks
10:08:47 <Eduard_Munteanu> fizruk: consider for example an Agda map function signature:   map : (A : Set) -> (A -> A) -> List A -> List A
10:09:06 <quchen> witt3rd: You would typically use an explicit 'case' when you have many parameters, but want to match only a subset of them, and share the others over the entire definition.
10:09:09 <Eduard_Munteanu> fizruk: where Set is much like *
10:09:25 <Eduard_Munteanu> fizruk: you can actually invoke 'map' with the type as an argument
10:09:41 <fizruk> Eduard_Munteanu, aha I get that
10:09:45 <benzrf> can i do multiline strings
10:10:01 <Eduard_Munteanu> fizruk: however you can also make it implicit, which is probably more like Haskell: map : {A : Set} -> ...
10:10:13 <quchen> > "Yes benzrf. Whitespace \       \between backslashes is ignored."
10:10:13 <monoidal> benzrf: yes, end each line with \ and begin with \
10:10:17 <lambdabot>   "Yes benzrf. Whitespace between backslashes is ignored."
10:10:23 <witt3rd> thanks, @quchen
10:10:25 <benzrf> ok
10:11:07 <fizruk> Eduard_Munteanu, i don't understand why (forall (a :: *). a) :: * is not  id :: Set -> Set
10:11:28 <fizruk> Eduard_Munteanu, that's what i meant by (\a -> a) :: * -> *
10:12:18 <fizruk> er.. (forall (a :: *). a) :: * should be just * -> *
10:12:24 <Eduard_Munteanu> fizruk: we're not really talking about an implementation of a type function, rather its type
10:12:34 <benzrf> wat if i want newlines in my str
10:12:52 <monoidal> benzrf: \n
10:12:52 <Tekmo> sdrodge: Ok, I think I got it: http://lpaste.net/95763
10:13:06 <benzrf> :|
10:13:34 <Eduard_Munteanu> fizruk: I guess you can call it a lambda as long as you don't expect it to work like an actual lambda. It's just a binder.
10:14:55 <Eduard_Munteanu> fizruk: because in Agda you get to say   f :: Set -> Set; f = λa -> a
10:15:03 <Tekmo> sdrodge: Simplified it further: http://lpaste.net/95763
10:15:59 <sdrodge> Tekmo: Thank you so much, very pretty, and I really learned a lot in the process.
10:16:14 <sdrodge> Tekmo: Are you by any chance an educator?
10:16:15 <Eduard_Munteanu> fizruk: however we were talking about naming such types in types of functions
10:16:16 <fizruk> Eduard_Munteanu, okay so returning to the initial problem, I have to use newtype X a = X (forall m. Monad m => StateT Integer m a) ?
10:16:20 <Tekmo> sdrodge: That should be a single-pass implementation
10:16:26 <Tekmo> sdrodge: No, I'm a graduate student :)
10:17:04 <Eduard_Munteanu> fizruk: I think so, monoidal probably knows more about that particular issue
10:17:15 <monoidal> fizruk: yes
10:17:24 <fizruk> monoidal, Eduard_Munteanu: thanks!
10:17:31 <Eduard_Munteanu> fizruk: it wouldn't have worked without the Monad constraint either, mind
10:17:50 <fizruk> Eduard_Munteanu, yeah, I just forgot it the first time
10:18:23 <monoidal> perhaps you can give a  MonadState constraint instead. don't know what's better.
10:18:50 <sdrodge> Tekmo: Well, I just learned a lot from you, and I appreciate it a lot. If you TA any classes, those students are lucky :).
10:19:05 <Tekmo> sdrodge: Thanks! :)
10:19:27 <chrisdone> Tekmo Assistant
10:19:32 <Tekmo> Haha
10:20:25 <fizruk> monoidal, oh and I can't derive Monad/MonadState for that newtype...
10:20:36 <fizruk> that's not good
10:20:42 * chrisdone puts on his ‘programmer’ t-shirt (literally). aw yeahh
10:20:56 <monochrom> what does it look like?
10:21:26 <fizruk> chrisdone, now everyone would think you're a programmer
10:21:32 <monochrom> does it have λ printed on it?
10:22:08 <Tekmo> sdrodge: Actually, I think there's a mistake in the definition of `dataVector2`.  I think I have it backwards
10:22:52 <chrisdone> http://i.imgur.com/wQ5aeZZ.jpg
10:23:26 <chrisdone> underneath it says "let's hack", but my ipod's camera is poor
10:23:40 <Eduard_Munteanu> In Agda, that 'bad' would have been more like  bad : WriterT String ({m : Set -> Set} -> {{ M : Monad m }} -> StateT Integer m) Integer, and the inner type has a proper type, namely Set_1.
10:24:14 <Eduard_Munteanu> In Haskell those are called impredicative because you have an * type defined in terms of * itself.
10:24:21 <monochrom> I don't identify with hacking. but ok. :)
10:25:05 <Tekmo> sdrodge: There, fixed it: http://lpaste.net/95763
10:25:17 <chrisdone> monochrom: hacking as a term for programming?
10:25:22 <monochrom> yes
10:25:36 <hiptobecubic> So it turns out that getting a job really gets in the way of idling time :(
10:25:36 <fizruk> Eduard_Munteanu, thanks, good to know :)
10:25:40 <chrisdone> fair do's
10:26:16 <monochrom> because while hacking (the benevolent sense) includes building and exploring, it also includes patching and patching until the system is so complicated it has no obvious errors.
10:27:10 <chrisdone> sounds like programming to me =p
10:27:45 <chrisdone> If debugging is the process of removing bugs, then programming must be the process of putting them in. — Edsger W. Dijkstra.
10:28:49 <chrisdone> there's an article about this you might like, lemmie see if i can find it
10:29:52 <monochrom> I am actually fine with hacking if the target is learning or making a toy demo.
10:31:09 <monochrom> I am also fine with programmers hacking if they are not so keen on being called engineers.
10:32:48 <chrisdone> monochrom: i think we're just using a different sense of 'hacking'. i (and friends) just use it to mean working on something, not any particular quality or approach
10:33:01 <sdrodge> Tekmo: Surprisingly, this version is actually about 5% slower than the original. Did I translate your idea incorrectly in some way? http://lpaste.net/95763
10:33:13 <chrisdone> monochrom: in the 'hackathon' sense
10:33:53 <fizruk> monoidal, why can't GHC derive Monad/MonadState instances for newtype X a = X (forall m. Monad m => StateT s m a) ?
10:34:17 <chrisdone> monochrom: ‘hackathon’ carries no connotations of bad practices
10:34:28 <chrisdone> hmm, i can't find the article i wanted
10:35:21 <fizruk> monoidal, the instances are straightforward, I can't see why GHC can't do that for me (if m were a parameter the instances would be the same except for the (Monad m) => part)
10:35:54 * donri puts on his hackathong
10:36:00 <donri> aw yeah
10:40:06 <absence> i recently read a comment on a haskell blog or reddit or somewhere that suggested most classical design patterns are unnecessary when you have closures, but i can't remember where i found it. anyone know anything about it?
10:40:34 <danilo2> Hello! Is there anywhere a mirror of www.haskell.org/ghc/‎? I want to download ghc for a specific platform and everything is down today :(
10:40:58 <quchen> Topic.
10:41:42 <geekosaur> not sure hdiff mirrors ghc, just hackage?
10:42:19 <monoidal> fizruk: I don't know. probably the deriving mechanism does not work with rank-n-types
10:42:48 <sdrodge> Tekmo: Is it possible that there is unwanted laziness in this version?
10:43:07 <fizruk> monoidal, okay, I guess i should not wait for this in next release
10:43:09 <sdrodge> or that it's not actually compiled down to a single loop?
10:43:31 <monoidal> fizruk: it doesn't work with HEAD. in fact, GND has now even more restrictive typecheck designed to close a loophole
10:43:47 <augur_> anyone know how to do nested interaction?
10:44:07 <monoidal> fizruk: but deriving + forall seems sensible, so I would try to make a small testcase and create a ticket.
10:44:23 <enthropy> augur_: like a repl with a sub-mode?
10:44:58 <augur_> enthropy: yeah. a REPL-like thing where you can push down into a sub-REPL, and a sub-sub-REPL
10:45:19 <enthropy> how are you doing the 1st layer right now?
10:45:25 <Eduard_Munteanu> fizruk: have you tried standalone deriving?
10:45:32 <augur_> enthropy: but crucially, where they're not separate, isolated little REPLS, but where the outter ones can use the inner ones to fix problems, etc etc.
10:45:39 <augur_> enthropy: im not, im looking for stuff to rea
10:45:40 <augur_> d
10:45:58 <monoidal> fizruk: even newtype X a = X (forall m. Monad m => m a) deriving Monad does not work.
10:46:00 <Eduard_Munteanu> fizruk: er, nevermind, I don't think you can specify the inner Monad context
10:46:04 <augur_> i think the scheme repls typically have what i want, for things like undefinedness, etc.
10:46:24 <enthropy> if you have   upper = do l <- getLine; case () of _ | m <- stripPrefix "cmd1" l -> do cmd1 m; upper m
10:46:42 <enthropy> instead of calling upper again, you can call another function
10:46:51 <enthropy> this is probably not a very nice way to do it
10:47:02 <fizruk> Eduard_Munteanu, there's no context at all (it is given within the forall)
10:47:12 <fizruk> Eduard_Munteanu, standalone deriving is not working wither
10:47:17 <fizruk> *either
10:47:35 <enthropy> augur_: I suggest using haskeline
10:47:38 <Tekmo> sdrodge: No, there shouldn't be unwanted laziness because it is all using unboxed vectors
10:47:50 <augur_> enthropy: i want to understand how to properly do all of this tho
10:47:52 <enthropy> which takes care of the getLine bit
10:47:53 <augur_> in an elegant way
10:48:07 <Tekmo> sdrodge: Did you use the fixed versoin using `U.update`?
10:48:17 <danilo2> geekosaur: only hackage as far as I know :(
10:48:42 <avenge> Anyone know what's happening with hackage currently?  Any mirrors out there?
10:48:45 <danilo2> By the way - is there any info what is happening? When everything will be up again ?
10:49:16 <codesoup> absence, that comes up a lot (usually in relation to Java). You're probably thinking about http://www.reddit.com/r/programming/comments/1qg5x8/whats_wrong_with_oop_and_fp/ or https://news.ycombinator.com/item?id=6716399 which both link to the same blog post.
10:49:24 <monoidal> danilo2: ddos attack, eta unknown
10:49:33 <avenge> mirrors?
10:49:41 <monoidal> avenge: see channel topic
10:49:42 <codesoup> i mean, the most recent instance of it coming up on
10:49:46 <joelteon> hackage is being ddosed?
10:49:56 <Eduard_Munteanu> fizruk: you could split that into   newtype Y m a = Y (m a) deriving ...   and   newtype X a = X (forall m. (Monad m) => Y m a)   and only write a map function for X (or try deriving Functor?), if that helps at all.
10:50:05 <danilo2> monoidal: ok, thank you
10:50:07 <monoidal> joelteon: no, the server is shared
10:50:21 <Eduard_Munteanu> Well, Y should contain whatever you actually want.
10:50:21 <enthropy> augur_: I kind of like the approach I did in module-management's scripts/CLI.hs
10:50:24 <sdrodge> Tekmo: Yes: http://lpaste.net/95763
10:50:29 <Tekmo> sdrodge: The latest version shouldn't be doing any unwanted subtractions this time, if that is what you are asking
10:50:48 <Tekmo> sdrodge: It's only doing one subtraction per element in `updateVector`, which I believe is what the algorithm requires
10:51:03 <fizruk> Eduard_Munteanu, you mean fromX :: Monad m => X a -> Y m a ?
10:51:27 <monoidal> newtype X a = X (forall m. (Functor m, Monad m) => m a) deriving Functor works
10:51:30 <enthropy> as in "I wish it could be easier to understand etc.", but I don't know how
10:51:43 <Eduard_Munteanu> fizruk: yeah, or mapY :: (Y m a -> Y m b) -> (X a -> X b)  depending on your usecase
10:51:55 <Tekmo> sdrodge: One thing to note is that the way that `Unboxed` vectors work is that when you model a vector of tuples, it really is modeled as separate vectors under the hood
10:52:12 <avenge> monoidal: thanks, seems to be working.
10:52:13 <enthropy> so basically you have a list of commands [([String], CmdM ())]
10:52:17 <Tekmo> sdrodge: In other words, `U.Vector (a, b)`, is really just `(U.Vector a, U.Vector b)` under the hood
10:52:28 <Sagi> can I compose a case statement in a pointfree expression?
10:52:31 <absence> codesoup: thanks, that's the one! is there a reference for more info about how lambdas/closures make those design patterns "obsolete"?
10:52:37 <Tekmo> sdrodge: So perhaps you should try switching to boxed vectors
10:52:47 <Sagi> I would've checked the types, but I have no idea how to so with sugar-coated constructs :)
10:52:49 <Eduard_Munteanu> Sagi: not really, but you can define it in a 'where' clause
10:52:50 <chrisdone> ‘classical’ design patterns gives design patterns more legitimacy than probably warranted :p
10:52:53 <Tekmo> sdrodge: Then it will be all local and truly be a single-pass over a linear  block of memory
10:53:10 <sdrodge> Tekmo: So the difference between this version of the code and my original attempt is that it allocates extra vectors?
10:53:12 <Sagi> Eduard_Munteanu: ah, yeah of course
10:53:15 <Tekmo> sdrodge: Right
10:53:22 <Tekmo> sdrodge: There should actually be three separate vectors it is running over
10:53:27 <Eduard_Munteanu> Sagi: foo x = case p x of ...    =>   foo = p where p Pattern = ...
10:53:36 <enthropy> augur_: instead of exceptions there, maye CmdM can have a Cont monad in there somehow
10:53:47 <sdrodge> Tekmo: Was my original attempt actually running in a single loop, despite my suspicion that it wasn't?
10:54:06 <Tekmo> sdrodge: I'm not sure
10:54:09 <enthropy> but I dunno if that can play nicely with the other monad transformers there
10:54:10 <fizruk> Eduard_Munteanu, I want user to write some code with X a (or StateT s X a or something), that is like forall m. Monad m => Y m a but without knowing there is an inner m
10:54:20 <Sagi> Eduard_Munteanu: yeah, or move the case to an expression in the where clause
10:54:36 <sdrodge> Tekmo: I think I might have to bit the bullet and read some Core.
10:54:37 <augur_> enthropy: hmm
10:54:41 <sdrodge> *bite
10:54:47 <Tekmo> sdrodge: Have you tried boxed vectors?
10:54:52 <enthropy> yes the executable is called hmm.exe
10:55:13 <Eduard_Munteanu> fizruk: you should really go with MonadState though, I think monoidal suggested that earlier
10:55:16 <Tekmo> sdrodge: There's another way to get the efficiency of boxed vectors but keeping everything in a single vector
10:55:26 <enthropy> it doesn't have sub-modes, but I think that might be a straightforward extension
10:55:36 <pmk> bottled vectors taste better than most boxed vectors
10:55:47 <Tekmo> sdrodge: Note that I might be wrong about unboxed vectors
10:55:55 <Tekmo> sdrodge: It's just that I can't read the documentaiton to confirm :)
10:56:04 <Tekmo> sdrodge: But I know for sure that Storable vectors solve this problem really well
10:56:06 <Eduard_Munteanu> fizruk: (MonadState s m) => m Integer   ...
10:56:12 <sdrodge> Tekmo: Testing boxed vectors right now; will report back with results.
10:56:45 <Eduard_Munteanu> fizruk: you can simplify to   type MyState m = (MonadState MyEnv m)   with constraint kinds.
10:56:48 <fizruk> Eduard_Munteanu, instead of X ?
10:56:49 <sdrodge> Tekmo: I thought that Unboxed didn't have any performance penalty compared to Storable?
10:56:56 <monoidal> or (MonadState Int m) => m a, rather
10:56:58 <Eduard_Munteanu> fizruk: instead of the entire type
10:57:05 <Tekmo> sdrodge: Actually, I was wrong.  `Storable` doesn't permit an unzip operation
10:57:20 <Tekmo> sdrodge: So yeah, it looks like your best bet is Boxed if you truly want a single-pass solution
10:58:03 <sdrodge> Tekmo: Boxed causes a greater than 2x slowdown.
10:58:14 <Sagi> Eduard_Munteanu: tnx :)
10:58:32 <fizruk> Eduard_Munteanu, I should think about this a bit
10:59:39 <Tekmo> sdrodge: Hmmm, then I'm not sure
10:59:57 <Tekmo> sdrodge: Actually, there is still one thing you can try
11:00:09 <pmk> in the declaration    class Functor' f a b where fmap' :: (a->b) -> f a -> f b     with the instance Functor' S.Set a b       how should I read "a" and "b" in the instance?  existentially qualified placeholders, maybe?
11:00:22 <Tekmo> sdrodge: Use `unsafeUpdate` instead of `update`
11:00:40 <monoidal> pmk: it means we've got an instance Functor' S.Set a b for any a,b
11:00:57 <pmk> that's what i though
11:00:59 <pmk> thought
11:01:01 <pmk> thanks
11:01:04 <Eduard_Munteanu> fizruk: if you need access to X at some point you can make a MonadX class for it, in case it's a transformer, or use MonadIO / MonadBase if it's IO-ish or only available as a base monad.
11:01:19 <Tekmo> sdrodge: I mean, go back to using unboxed vectors, but use `unsafeUpdate`
11:01:33 <Tekmo> sdrodge: If that doesn't work, there is one last thing I know to try
11:02:23 <Eduard_Munteanu> In fact you can use MonadX for base monads as well, as long as you don't require IO-like lifting, i.e. liftX :: X a -> m a
11:02:32 <fizruk> Eduard_Munteanu, it's more complicated: type X t a = forall m. Monad m => StateT s (t m) a  -- StateT s is just an example of some particular transformer
11:02:59 <sdrodge> Tekmo: isn't that... unsafe?
11:03:01 <Eduard_Munteanu> fizruk: no, not that way
11:03:41 <Eduard_Munteanu> fizruk: if you have a function that requires access to the state, you can just write it as   f :: (MonadState SomeState m) => m a  instead of referring to StateT and X.
11:03:54 <Tekmo> sdrodge: Basically `unsafe` means that instead of throwing an exception it will segfault
11:04:04 <Tekmo> sdrodge: It's safe if you can guarantee that it won't look outside the array bounds
11:04:13 <Tekmo> sdrodge: Basically it just removes bounds checking
11:05:23 <Tekmo> sdrodge: In this case it should be safe because you are never updating things outside of the bounds of `dataVector`
11:05:45 <fizruk> Eduard_Munteanu, let me reformulate: I want user to be able to insert transformers above and below mine (e.g. StateT s) *and* have an arbitrary monad on the lowest level
11:05:51 <sdrodge> Tekmo: unsafeUpdate is... slower?!
11:06:23 <Tekmo> sdrodge: Huh!
11:06:25 --- mode: ChanServ set +o mauke
11:06:25 --- topic: set to 'http://www.haskell.org/ is down | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub' by mauke
11:06:26 <Eduard_Munteanu> fizruk: yep, all the more reason to provide a MonadX class, that way the order of transformers doesn't really matter.
11:06:33 <Tekmo> sdrodge: That is very unexpected
11:06:38 <sdrodge> Tekmo: agreed.
11:06:53 <Tekmo> sdrodge: So there's one last thing I wanted to try.  Give me a second
11:07:16 <fizruk> Eduard_Munteanu, the order matters for me: if transformers are placed below - I can affect them
11:08:25 --- mode: mauke set -o mauke
11:09:04 <Tekmo> sdrodge: Ok, try this one, using both update_ and unsafeUpdate_: http://lpaste.net/95763
11:09:17 <Eduard_Munteanu> fizruk: sure, you can do something like   class (MonadState s m) => MonadX s m | m -> s where ...  if you want the user to be able to access the state as well.
11:09:29 <Tekmo> sdrodge: Oops, it should say unzip3
11:10:55 <fizruk> Eduard_Munteanu, looks like we have different pictures in minds :) it's not that easy to explain a problem I guess)
11:11:13 <fizruk> Eduard_Munteanu, let me type some code
11:11:29 <Eduard_Munteanu> Hm, yeah, probably best.
11:12:12 <fizruk> Eduard_Munteanu, are you familiar with free monad transformers?
11:12:25 <Tekmo> I'm familiar with them!
11:12:29 <Tekmo> I wrote the code for them!
11:12:39 <chrisdone> Tekmo: show off!
11:12:41 <Tekmo> :)
11:12:43 <chrisdone> :p
11:12:46 <merijn> Tekmo: That doesn't mean anything
11:12:46 <sdrodge> Tekmo: update_ is slower, unsafeUpdate_ is about the same as update
11:12:57 <Tekmo> merijn: :)
11:13:02 <Eduard_Munteanu> fizruk: the free monad yes, I guess the transformer variant adds the free monad of that functor to / on top of another monad?
11:13:24 <merijn> Tekmo: Last time someone asked about the mtl stuff for pipes I answered with "I think they exist, yeah" even though I'm the one that submitted the patch for them...
11:13:27 <Eduard_Munteanu> Say like   data FreeT f m a = ...
11:13:36 <merijn> So writing code and knowing it exists are orthogonal issues :p
11:13:38 <chrisdone> merijn: so modest
11:13:40 <Tekmo> sdrodge: Oh wait
11:13:42 <fizruk> Eduard_Munteanu, FreeT f m a is like you have m actions "delimited" by f's
11:13:52 <Tekmo> sdrodge: I was looking at your full code segment that you pasted
11:14:01 <merijn> chrisdone: I was seriously bewildered for a bit when I checked the code!
11:14:03 <Eduard_Munteanu> fizruk: mm, yeah
11:14:27 <Tekmo> sdrodge: You might want to try converting `U.unzip . U.map $ d` to `U.unzip (U.map f d)`
11:14:33 <chrisdone> merijn: ever read an old comment on a forum and laugh/nod at it and realise it's your own?
11:14:36 <Eduard_Munteanu> fizruk: and constructors  Pure (m a) | Wrap (f (FreeT f m a))  ?
11:14:44 <merijn> chrisdone: No, I avoided forums :p
11:14:50 <Tekmo> sdrodge: Writing in that style sometimes messes with vector stream fusion.
11:14:56 <merijn> chrisdone: Or rather, the ones I didn't avoid no longer exist
11:14:57 <chrisdone> merijn: i mean any form of online posting
11:15:04 <chrisdone> incl. reddit
11:15:20 <chrisdone> merijn: sign my guestbook
11:15:23 <merijn> chrisdone: Dude
11:15:33 <merijn> chrisdone: Like reddit existed back then!
11:15:37 <fizruk> Eduard_Munteanu, Eduard_Munteanu almost :) FreeT f m a = FreeT (m (Either a (FreeT f m a)))
11:15:41 <chrisdone> “but you're my friend. why do you want me to sign your guestbook?” “sign my guestbook!!”
11:15:46 <Tekmo> merijn: Haha
11:16:17 <monochrom> perhaps you should call it not "guestbook", but "friendbook"
11:16:18 <Eduard_Munteanu> fizruk: mm... what does 'f' do then?
11:16:34 <fizruk> Eduard_Munteanu, Either a (f (FreeT f m a))
11:16:36 <Tekmo> merijn: Yeah, just the other day, Shane submitted something to `mmorph` and I was like "This is brilliant" then he says "Well, it was your idea, remember?"
11:16:40 <Eduard_Munteanu> Oh.
11:16:44 <chrisdone> monochrom: true, adding someone as a friend is the modern version of signing someone's guestbook
11:16:47 <Tekmo> merijn: I'm too young to be going senile :(
11:17:19 <fizruk> Eduard_Munteanu, the type does not matter that much I believe
11:17:29 <monochrom> I would want to say "yearbook", but this is not a highschool graduation :)
11:17:51 <chrisdone> Tekmo: bergmark pointed out some code in the fay ffi that i have no recollection of writing. i was like "i didn't know fay did that!" … "you wrote this code" "oh. yay?"
11:17:52 <sdrodge> Tekmo: no difference.
11:17:53 <Tekmo> fizruk: What are you trying to do with free monad transformers?
11:17:55 <fizruk> Eduard_Munteanu, if I have `OuterT (FreeT f (InnerT m)) a` then (InnerT m) actions are delimited, but OuterT are not
11:17:58 <maikklein> did I make any rookie mistakes https://gist.github.com/MaikKlein/7503890 ?
11:18:02 <Tekmo> sdrodge: Then I'm all out of optimization juice :(
11:18:06 <pmk> fizruk, what does 'f' buy you there?  why not    FreeT m a = FreeT (m (Either a (FreeT m a)))  ?
11:18:36 <fizruk> pmk, i mistyped: FreeT f m a = FreeT (m (Either a (f (FreeT f m a))))
11:18:42 <fizruk> too many symbols
11:18:43 <pmk> oh
11:18:52 <pmk> well that does make more sense to me :-)
11:19:30 <chrisdone> maikklein: looks good. i probably wouldn't format it that way, but the tokens make a fine program
11:19:33 <Eduard_Munteanu> Yeah, it's basically Free f a as a transformer for m.
11:19:58 <Tekmo> Anybody who wants to understand what free monad transformers are for should read Mario Blazevic's coroutine article in issue 19 of The Monad Reader: https://themonadreader.wordpress.com/2011/10/26/issue-19/
11:20:08 <Tekmo> He calls it the `Coroutine` type, but it's the same thing
11:20:16 <monochrom> maikklein: I think it's good. I just haven't tested it.
11:20:24 <levi> Hey, that's me!  I'll take a look, thanks.
11:20:25 <fizruk> Tekmo, thanks! I didn't know about that!
11:20:35 <monoidal> suppose IO was implemented via a free monad. Would then IOT make sense?
11:20:36 <maikklein> chrisdone, thanks. I wasn't sure how I should format it though. Any recommendations?
11:20:38 <Eduard_Munteanu> fizruk: ok... I suspect FreeT is your X?
11:20:53 <Tekmo> monoidal: Yes
11:21:02 <Eduard_Munteanu> It should.
11:21:07 <monoidal> oh, that's nice
11:21:24 <fizruk> Eduard_Munteanu, almost: I have type X f t a = forall m. Monad m => FreeT f (t m) a
11:21:45 <joelteon> is anybody here good at optparse-applicative? It seems to be almost completely useless
11:21:49 <jmcarthur> monoidal: it would, but the interpreter would need to be able to do something sensible with it
11:21:50 <Tekmo> I am
11:21:55 <Eduard_Munteanu> monoidal: however it's not the same thing as a transformer variant of IO.
11:21:57 <Tekmo> joelteon: I have a Stack Overflow answer you can crib from
11:22:03 <monoidal> I see
11:22:05 <donri> isn't it possible to write IOT if you import the internals?
11:22:15 <Tekmo> joelteon: http://stackoverflow.com/questions/17395388/command-line-arguments-reading-monad-library/17407774#17407774
11:22:17 <lpaste> chrisdone pasted “maikklein” at http://lpaste.net/95780
11:22:26 <levi> Tekmo: I'm writing an IRC server based on pipes.  The core pipes stuff is very straightforward and easy to use, but it's taking a bit for me to grasp how the concurrency, parsing, etc. bits fit on and interact with the core.  But I'm gradually getting it.
11:22:43 <Tekmo> donri: It wouldn't work with the FFI
11:22:44 <jmcarthur> donri: you can express a lot of nonsensical things using ghc primitives. ;)
11:22:53 <chrisdone> maikklein: that's how i'd format it. but feel free to make your style choices
11:22:55 <Tekmo> levi: Ok, so I have a long spiel to say on this
11:22:55 <monochrom> maikklein: apart from one advanced point. in "\x (xs,ys)", use "\x ~(xs,ys)" for more laziness. it doesn't matter for finite lists. it is only important for infinite lists. if you don't have infinite lists now, you don't have to care.
11:22:59 <joelteon> Tekmo: I'm having trouble specifically with subcommands, I'll just pastebin it and then you all can have a crack at it
11:23:00 <donri> jmcarthur: acme-realworld!
11:23:04 <Eduard_Munteanu> donri: possibly but IOT Identity and IOT [] would behave rather differently
11:23:09 <Tekmo> levi: So you really need to study my `rcpl` library
11:23:13 <Tekmo> levi: One second
11:23:16 <levi> Tekmo: I have been. :)
11:23:17 <jmcarthur> donri: yes. in fact, in that reddit thread i suggested adding IOT to that package
11:23:31 <Tekmo> levi: Oh, ok :)
11:23:34 <chrisdone> jmcarthur: did you see my loeb waterflow solution? :D
11:23:39 <monoidal> jmcarthur: which thread?
11:23:46 <Tekmo> levi: So the basic idea is that you try to factor out as much concurrency as possible
11:23:53 <maikklein> chrisdone, thanks
11:24:00 <jmcarthur> chrisdone: i did. btw, you can make leob a lot more efficient by eta reducing the recursive part
11:24:02 <maikklein> monochrom, thanks didn't know that
11:24:03 <Tekmo> levi: Recently I've been simplifying things by using `ListT` instead of push-based pipes arrows
11:24:08 <Tekmo> levi: I made a ton of changes in the last few days
11:24:14 <fizruk> Eduard_Munteanu, so... the user has something of type `OuterT (X f InnerT) a` and I want him to use it like `Monad m => OuterT (InnerT m) a`
11:24:25 <Tekmo> levi: However, the basic idea is still the same
11:24:33 <levi> I had similar ideas before I ran across it, but seeing them right there and concrete in the form of rcpl was very helpful.  And I loved seeing the Edge thing go away.
11:24:39 <Tekmo> levi: You take concurrent code and you transform it into pure `ListT (State s)` code
11:24:49 <fizruk> Eduard_Munteanu, e.g. if InnerT is MonadState then the whole thing is MonadState, etc.
11:25:03 <Tekmo> levi: In fact, an IRC client was the first example I had in mind for `rcpl`
11:25:10 <chrisdone> jmcarthur: how?
11:25:22 <Tekmo> levi: Maybe I should expose `rcplCore` so that you can use it directly within your application
11:25:23 <levi> Well, IRC clients are a bit of a different interaction model than IRC servers.
11:25:35 <chrisdone> jmcarthur: i have criterion benchmarks setup, so i can test
11:25:42 <Tekmo> levi: Oops, I didn't see the server
11:25:47 <Tekmo> levi: So I have another paste for that
11:25:56 <Tekmo> levi: It's using the old 3.0 pipes, but it's pretty easy to transltae
11:26:03 <Eduard_Munteanu> fizruk: ok, that's reasonable, you can just write instances like   instance (MonadState s m) => MonadState s (FreeT f m)   or derive them standalone
11:26:18 <Tekmo> levi: See this: http://lpaste.net/84018
11:26:28 <Tekmo> levi: It's an example of simple server idioms using pipes + STM
11:26:39 <fizruk> Eduard_Munteanu, I have them already :)
11:26:57 <levi> Well, easy to translate when you know more than the surface pipes 4.0 API, maybe.  I mostly found pre-4.0 examples confusing when I was trying to get comfortable with the 4.0 API.
11:27:09 <jmcarthur> chrisdone: loeb x = xs where xs = fmap ($xs) x
11:27:17 <Tekmo> levi: Then let me translate it really quickly.  Hold on
11:27:18 <Eduard_Munteanu> fizruk: ok... so... you also want your FreeT to "surface" above both InnerT and OuterT?
11:27:21 <chrisdone> jmcarthur: http://chrisdone.com/posts/twitter-problem-loeb#update-on-loeb
11:27:26 <fizruk> Eduard_Munteanu, so the problem is that I want innermost monad to be *any* (forall'ed) in user code
11:27:31 <lpaste> joelteon pasted “optparse-applicative pls” at http://lpaste.net/95781
11:27:37 <joelteon> ^ that's the one
11:27:44 <quchen> What's with this loeb stuff? I haven't heard about it until a couple of days ago, and now everyone's talking about it
11:27:49 <chrisdone> jmcarthur: in benchmarking, i found it only marginally faster. but there was a little bit
11:27:52 <fizruk> Eduard_Munteanu, no FreeT does not know about OuterT (and should not)
11:28:06 <Eduard_Munteanu> Sure, I just meant making the methods accessible.
11:28:17 <jmcarthur> chrisdone: ah, okay
11:28:30 <jmcarthur> chrisdone: for some problems it should be very significant
11:28:37 <chrisdone> aye, makes sense
11:28:46 <help_ME> hello. Could somebody help me?
11:28:48 <Eduard_Munteanu> fizruk: forall semantically, as in the user should not be able to tell what the inner monad is? Or should it just work with any monad as long as e.g. it's MonadState?
11:29:06 <chrisdone> help_ME: go ahead and ask
11:29:11 <fizruk> Eduard_Munteanu, it's absolutely arbitrary monad
11:29:16 <donri> joelteon: i think you might be using the Read reader there, which means it'll need to look like a haskell string
11:29:26 <fizruk> Eduard_Munteanu, most frequently some IO wrapper
11:29:31 <Eduard_Munteanu> fizruk: ok, let me ask differently... does the user pick it or do you pick it?
11:29:37 <chrisdone> quchen: http://chrisdone.com/posts/twitter-problem-loeb i guess
11:29:43 <fizruk> Eduard_Munteanu, e.g. ReaderT e IO
11:29:50 <Eduard_Munteanu> Oh, ok.
11:29:51 <help_ME> How do I find nth element in a map?
11:29:58 <donri> joelteon: try strOption instead of option for master-file
11:30:06 <geekosaur> help_ME, the concept doesn't really exist
11:30:08 <chrisdone> help_ME: what kind of map? Data.Map?
11:30:26 <help_ME> myfind ["123","123","123"] 3 '1'   returns (2,0)
11:30:28 <joelteon> donri: aw man, I can't believe I didn't see that
11:30:29 <Eduard_Munteanu> fizruk: so the user picks it on his end, when he run*'s the transformer stack?
11:30:29 <joelteon> thanks a lot
11:30:34 <fizruk> Eduard_Munteanu, I had Identity in place of m for some time
11:30:36 <chrisdone> ah, a list?
11:30:39 <donri> np
11:30:55 <fizruk> Eduard_Munteanu, but then I realised that not any transformer is an MFunctor
11:31:13 <help_ME> myfind :: [[Char]]->Int->Char->(Int,Int)
11:31:44 <fizruk> Eduard_Munteanu, yeah, there are two "ends" one where user has interpreter-agnostic code and the other which involves interpreter
11:32:14 <chrisdone> help_ME: a trivial way is lookup with zip
11:32:28 <chrisdone> > lookup 3 . zip [1..] $ "hello"
11:32:30 <lambdabot>   Just 'l'
11:33:00 <fizruk> Eduard_Munteanu, the former does not know of inner m and how the code will be executed, the latter does not know OuterT
11:33:13 <Eduard_Munteanu> Oh, I see.
11:34:26 <help_ME> sorry, i did not mean to find the nth element, i mean if I want to find the nth '1' in ["123","123","123"]
11:34:34 <chrisdone> ohh
11:34:55 <chrisdone> what should it return, an index?
11:35:05 <help_ME> yes
11:35:18 <Tekmo> levi: Here you go: http://lpaste.net/95782 http://lpaste.net/95783
11:35:24 <help_ME> myfind ["123","123","123"] 3 '1'   returns (2,0)
11:35:36 <Eduard_Munteanu> fizruk: so far you can just not expose InnerT by not making instances accessible by OuterT-running code.
11:35:38 <help_ME> myfind :: [[Char]]->Int->Char->(Int,Int)
11:35:40 <chrisdone> > map fst . drop 1 . filter ((=='l').fst) . zip [1..] $ "hello"
11:35:41 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:35:41 <lambdabot>    arising from the literal `1...
11:35:48 <chrisdone> > map fst . drop 1 . filter ((=='l').snd) . zip [1..] $ "hello"
11:35:50 <lambdabot>   [4]
11:35:52 <Eduard_Munteanu> fizruk: which also means you don't make X a MonadTrans
11:36:26 <chrisdone> “Oh, I think I'll just take 5 minutes to mess with Agda.” http://i.imgur.com/xmFcZZi.gif
11:36:26 <Eduard_Munteanu> OuterT is already invisible to InnerT by the way they're stacked.
11:37:01 <FreeFull> chrisdone: Tried idris?
11:37:07 <Eduard_Munteanu> fizruk: makes sense so far?
11:37:17 <chrisdone> FreeFull: watched the talk
11:37:26 <Tekmo> levi: Alright, I have to head out right now, but if you have more questions, my gmail address is Gabriel439
11:37:27 <Eduard_Munteanu> I'm assuming X takes care of brokering things between the two.
11:37:37 <Eduard_Munteanu> I.e. only X itself can do that.
11:37:46 <Tekmo> levi: Or you can ask questions on the haskell-pipes mailing list: https://groups.google.com/forum/?fromgroups#!forum/haskell-pipes
11:37:47 <levi> Tekmo: Thanks!
11:37:47 <jmcarthur> @let loeb x = xs where xs = fmap ($xs) x
11:37:49 <lambdabot>  Defined.
11:37:51 <Tekmo> levi: You're welcome!
11:38:28 <jmcarthur> > leob [(!! 1), succ . (!!2), const 7]
11:38:29 <lambdabot>   Not in scope: `leob'
11:38:29 <lambdabot>  Perhaps you meant `loeb' (line 147)
11:38:34 <jmcarthur> > loeb [(!! 1), succ . (!!2), const 7]
11:38:41 <lambdabot>   mueval-core: Time limit exceeded
11:38:42 <chrisdone> @let toeb x = xs where xs = traverse ($ xs) x
11:38:48 <lambdabot>  Defined.
11:38:51 <jmcarthur> err
11:38:52 <fizruk> oh, Tekmo is Gabriel Gonzalez? good to know
11:39:07 <byorgey> fizruk: yep
11:39:24 <jmcarthur> > loeb [(!! 1), succ . (!!2), const 7]
11:39:32 <fizruk> Eduard_Munteanu, not sure
11:39:43 <jmcarthur> dangit lambdabot
11:39:57 <jmcarthur> -- [8,8,7]
11:40:01 <jmcarthur> quchen: ^^
11:40:01 <FreeFull> I think lambdabot has a problem with @let bindings
11:40:13 <quchen> jmcarthur: ?
11:40:20 <jmcarthur> quchen: demonstrating loeb
11:40:26 <chrisdone> > "test"
11:40:32 <FreeFull> > let loeb x = xs where xs = fmap ($xs) x in loeb [(!! 1), succ . (!!2), const 7]
11:40:32 <lambdabot>   "test"
11:40:33 <lambdabot>   [8,8,7]
11:40:36 <fizruk> Eduard_Munteanu, how "not to expose" InnerT?
11:40:39 <jmcarthur> :t toeb
11:40:40 <Eduard_Munteanu> fizruk: mind you can even mention the inner monad in X's type, unless you provide lift the outer code can't access it.
11:40:43 <lambdabot> (Applicative f, Traversable t) => t (f (t b) -> f b) -> f (t b)
11:40:46 <chrisdone> > loeb [const 0, (!!0)]
11:40:54 <lambdabot>   mueval-core: Time limit exceeded
11:41:02 <chrisdone> hmm, this is incorrect
11:41:12 <monochrom> I'm going to @undefined so you could try again
11:41:14 <monochrom> @undefine
11:41:15 <lambdabot> Undefined.
11:41:20 <FreeFull> :t traverse
11:41:22 <Eduard_Munteanu> fizruk: if you really want to hide it, you can make the inner monad existential, not rank-2.
11:41:22 <FreeFull> :t fmap
11:41:23 <quchen> I still have no idea what the function does. I'm reading chrisdone's article now though.
11:41:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:41:25 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:41:42 <Destinova> hello everyone
11:41:46 <monochrom> @let toeb x = xs where xs = traverse ($ xs) x
11:41:47 <chrisdone> quchen: better is the one i linked in the article by sigfpe: http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
11:41:48 <lambdabot>  Defined.
11:41:49 <Eduard_Munteanu> fizruk: because X can and should know it.
11:41:52 <chrisdone> > loeb [const 0, (!!0)]
11:41:54 <lambdabot>   Not in scope: `loeb'
11:41:55 <lambdabot>  Perhaps you meant `toeb' (line 143)
11:41:57 <monochrom> > loeb [const 0, (!!0)]
11:41:58 <chrisdone> D:
11:41:59 <lambdabot>   Not in scope: `loeb'
11:41:59 <lambdabot>  Perhaps you meant `toeb' (line 143)
11:42:07 <monochrom> > toeb [const 0, (!!0)]
11:42:09 <lambdabot>   No instance for (GHC.Show.Show b0)
11:42:09 <lambdabot>    arising from a use of `M6686107823412...
11:42:22 <monochrom> ok, at least it doesn't time-out now :)
11:42:32 <chrisdone> :t toeb
11:42:33 <lambdabot> (Applicative f, Traversable t) => t (f (t b) -> f b) -> f (t b)
11:42:37 <fizruk> Eduard_Munteanu, hm... that can make sense
11:43:34 <Destinova> I'd like to ask someone a few questions about learning Haskell. Can someone spare me a few minutes?
11:43:36 <chrisdone> @let loeb f = loeb (fmap ($ f)) f
11:43:37 <lambdabot>  .L.hs:143:10:
11:43:38 <lambdabot>      Occurs check: cannot construct the infinite type:
11:43:38 <lambdabot>        ...
11:43:38 <fizruk> Eduard_Munteanu, also OuterT running code knows and can use InnerT, just should not know about inner m (I'm not sure I was strict about that)
11:43:45 <chrisdone> woops
11:43:56 <mauke> Destinova: don't ask to ask
11:43:58 <jmcarthur> quchen: in (loeb [(!! 1), succ . (!!2), const 7]), the first element of the result is the same as the second element of the result, the second element of the result is the successor of the third element of the result, and the third element of the result is 7
11:44:05 <chrisdone> @let loeb f = fmap ($ loeb f) f
11:44:06 <lambdabot>  Defined.
11:44:17 <byorgey> Destinova: just ask your questions here, and people will answer as they can/want to
11:44:17 <Destinova> mauke: right, i will!
11:44:22 <chrisdone> > loeb [const 0,const 1,sum . take 2]
11:44:30 <lambdabot>   mueval-core: Time limit exceeded
11:44:33 <chrisdone> :/
11:44:39 <jmcarthur> quchen: it just allows you to define the elements of the resulting container in terms of the resulting container itself
11:44:50 <monochrom> ok this is too bad
11:44:54 <chrisdone> lambdabot: what's your deal, man?
11:44:58 <quchen> jmcarthur: Ah. I still don't know how it works, but at least I know what it does now.
11:44:58 <jmcarthur> quchen: by replacing the elements of the input
11:45:56 <asmyers> quchen: I find this version (slightly) more understandable :p
11:45:57 <asmyers> loeb x = xs where xs = fmap ($xs) x
11:45:57 <quchen> I think when I do understand it it's going to be really cool and I can show all my friends how awesome laziness is. :-D
11:46:05 <chrisdone> > let xs = [length] in fmap (\f -> f xs) xs
11:46:10 <lambdabot>   [1]
11:46:17 <chrisdone> quchen: ^ that's the essence of loeb
11:46:32 <Destinova> I'm thinking of learning Haskell. I've coded in the past almost entirely in C / C++ / Java, and I'd like to try a proper functional language. The challenge here is that I've no proper application for that middle management slob who wants to get back to coding and I'm thinking if Haskell is a suitable candidate.
11:46:33 <Eduard_Munteanu> fizruk: you said 'type X f t a = forall m. Monad m => FreeT f (t m) a'. You can make that instead 'data X f a = forall m. (Monad m) => X (FreeT f m a)' and add outer transformers to that.
11:46:56 <chrisdone> > let loeb xs = fmap (\f -> f (loeb xs)) xs in loeb [length]
11:46:57 <Eduard_Munteanu> e.g. foo :: OuterT (X f) a
11:46:58 <lambdabot>   [1]
11:46:59 <Destinova> Also, it helps to note that I haven't coded in over 5-6 years, so I intend to have a more or less learn-from-scratch experience.
11:47:08 <quchen> chrisdone: Oh, so it applies all the functions in the list to the list itself, and gathers the results in a list of the same length. Abstract list away, poof, loeb.
11:47:20 <chrisdone> > let loeb xs = fmap (\f -> f (loeb xs)) xs in loeb [length,(!!0),const 1,sum.take 3]
11:47:21 <lambdabot>   [4,4,1,9]
11:47:30 <chrisdone> quchen: yeah
11:47:52 <help_ME> chrisdone: myfind :: [[Char]]->Int->Char->(Int,Int) e.g. myfind ["123","ab1","1sd"] 3 '1'   returns (2,0)
11:48:00 <chrisdone> > let loeb xs = fmap (\f -> f (loeb xs)) xs in loeb (Just isJust)
11:48:01 <fizruk> Eduard_Munteanu, existentials might work, I should try it
11:48:02 <lambdabot>   Just True
11:48:08 <FreeFull> Non-strict semantics, making loeb possible
11:48:21 <fizruk> Eduard_Munteanu, thanks for the ideas! :)
11:48:28 <chrisdone> help_ME: i suggest thinking about your problem and making some english questions
11:48:38 <Destinova> So what I'm looking for is beauty, a challenging learning curve but enough to allow small successes now and then. Quite a few people (who I admire) are on about Haskell and Erlang - a comparison from my point-of-view would be rather helpful too.
11:48:39 <Destinova> Thanks!
11:48:58 <danharaj> edwardk: I haven't been able to find any papers on comonad fix, neither `orchard` style nor `menendez` style.
11:49:29 <chrisdone> Destinova: Learn You A Haskell is the goto book for newbies to grok the Haskell basic-to-intermediates
11:49:43 <byorgey> Destinova: sounds great!
11:49:52 <Eduard_Munteanu> fizruk: you can even leave 'm' exposed, as long as there's no 'lift :: Inner m a -> X f (Inner m) a' the user can't really do anything to it and might as well forall it in his type sigs.
11:49:53 <byorgey> Destinova: I am not sure what your actual question is, though.
11:50:07 <FreeFull> Destinova: I've heard people like to alternate between Learn You A Haskell and Real World Haskell
11:50:08 <stelleg> anyone know if there is a equivalent to posix wait(pid)?
11:50:14 <chrisdone> Destinova: the school of haskell has inline runnable examples: https://www.fpcomplete.com/school
11:50:32 <stelleg> theres a waitForProcess in System.Process, but it waits on a ProcessHandle, not a PID
11:50:51 <chrisdone> quchen: now i'm wondering whether i can do anything with toeb =p
11:50:54 <Destinova> I'll check that book out chrisdone. and the school of haskell too. thanks!
11:51:01 <quchen> chrisdone: What's that?
11:51:10 <quchen> chrisdone: The free Functoroid generated by loeb?
11:51:10 <chrisdone> the same function but i replaced fmap with traverse =p
11:51:20 <quchen> Or that.
11:51:33 <chrisdone> :t let toeb xs = traverse (\f -> f (toeb xs)) xs in toeb
11:51:37 <lambdabot> (Applicative f, Traversable t) => t (f (t b) -> f b) -> f (t b)
11:51:48 <Eduard_Munteanu> fizruk: btw, what I said about MonadX still applies, if you want to make it polymorphic in the X monad.
11:52:00 <Destinova> byorgey: Is Haskell one of those languages I can learn just for the purpose of learning? Given that I have no material or product-based end goal (except perhaps the pleasure of writing some half-decent code etc.)
11:52:09 <Destinova> that is what I am trying to figure out.
11:52:31 <quchen> :t let moeb f xs = f (\g -> g (moeb f xs)) xs in moeb -- chrisdone: Let's make it a little more general, shall we? inb4 edwardk popping up "that's in Lens"
11:52:32 <lambdabot> (((t2 -> t1) -> t1) -> t -> t2) -> t -> t2
11:52:53 <quchen> moeb = multi-loeb by the way. You heard it here first.
11:52:54 <chrisdone> quchen: hmm, but that doesn't do anything?
11:53:10 <quchen> Sure it does! moeb fmap = loeb
11:53:31 <Destinova> I'm basically working on narrowing down which language to learn given this. I've narrowed down to Haskell and Erlang for now. I've no interest in learning Python/Ruby, or the other 'hot' languages for instance.
11:53:38 <chrisdone> sure, so with moeb traverse i still need to figure out what it can do =p
11:54:33 <monochrom> yes, you can learn Haskell for learning
11:54:35 <Eduard_Munteanu> Destinova: FWIW, Haskell is considerably more different to normal languages than Erlang.
11:55:34 <Destinova> Eduard_Munteanu: Yes, I read as much and that's one of the things I would want too - something different enough from C/ Java etc. so it'll be half challenging as well.
11:55:38 <Eduard_Munteanu> Destinova: and pretty much as far as you can go without having major difficulties writing real applications, if you're going in the research-y direction.
11:56:25 <FreeFull> quchen: What would be other options, rather than just fmap?
11:56:33 <Eduard_Munteanu> However Haskell and Erlang have rather different philosophies wrt program correctness.
11:56:40 <quchen> FreeFull: traverse, as chrisdone mentioned
11:56:59 <fizruk> Eduard_Munteanu, no it has to be a particular monad (not even any MonadFree)
11:57:04 <quchen> :t let moeb f xs = f (\g -> g (moeb f xs)) xs in moeb T.traverse
11:57:05 <lambdabot> (Applicative f, Traversable t) => t (f (t b) -> f b) -> f (t b)
11:57:05 <FreeFull> I don't see the use with traverse
11:57:07 <Destinova> Yes, I did read that Erlang is a lot more fault tolerant than Haskell, though I don't know if that is what you're referring to when you say philosophy
11:57:25 <quchen> FreeFull: That's an open research subject.
11:57:26 <Eduard_Munteanu> fizruk: sure... it can be MonadX if you can reduce X to a few basic methods :)
11:57:31 <FreeFull> Destinova: Erlang isn't anywhere as strongly typed as Haskell
11:57:49 <FreeFull> :t let moeb f xs = f (\g -> g (moeb f xs)) xs in moeb id
11:57:51 <lambdabot> (t -> t) -> t
11:57:52 <Eduard_Munteanu> It is strongly-typed but the types are crappy. :)
11:58:03 <FreeFull> Ah, moeb id might be fix
11:58:05 <FreeFull> :t fix
11:58:06 <lambdabot> (a -> a) -> a
11:58:16 <FreeFull> > let moeb f xs = f (\g -> g (moeb f xs)) xs in moeb id (:1)
11:58:17 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
11:58:18 <lambdabot>  Expected type:...
11:58:21 <FreeFull> > let moeb f xs = f (\g -> g (moeb f xs)) xs in moeb id (1:)
11:58:23 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:58:30 <chrisdone> neat
11:59:23 <Eduard_Munteanu> Destinova: that's an understatement, Erlang is fault-embracing really :). Whereas Haskell tries to eliminate faults from the start.
11:59:34 <quchen> @let moeb f xs = f (\g -> g (moeb f xs)) xs
11:59:35 <lambdabot>  Defined.
11:59:42 <quchen> That should make things easier.
11:59:58 <quchen> :t moeb id
11:59:59 <lambdabot> (t2 -> t2) -> t2
12:00:10 <edwardk> danharaj: there are a few comments by tarmo uustalu and dave menendez that note that comonadfix can be defined once and forall
12:00:10 <FreeFull> @let moo = 3
12:00:11 <lambdabot>  Defined.
12:00:12 <FreeFull> > moo
12:00:20 <lambdabot>   mueval-core: Time limit exceeded
12:00:25 <FreeFull> quchen: That's a problem
12:00:37 <edwardk> @tell prooftechnique either keynote or powerpoint, typically
12:00:37 <lambdabot> Consider it noted.
12:00:43 <Eduard_Munteanu> Destinova: oh, no problem, you're not cluttering the channel at all.
12:00:43 <quchen> Hm. "2" as a thunk shouldn't take this long to be evaluated.
12:01:00 <FreeFull> > let moo = 3 in moo
12:01:03 <lambdabot>   3
12:01:03 <prooftechnique> edwardk: Oh, cool.
12:01:24 <FreeFull> Who is responsible for lambdabot in here?
12:01:24 <monochrom> @tell int-e when we try to use something defined by @let, lambdabot times out. could you investigate? thanks.
12:01:24 <lambdabot> Consider it noted.
12:01:32 <monochrom> that one :)
12:02:08 <FreeFull> I would have done @tell int-e earlier if I knew he was responsible
12:02:10 <monochrom> lambdabot is now like Japan. changing prime ministers twice every year :)
12:02:28 <jmcarthur> Eduard_Munteanu: i think that is misleading because there are two kinds of faults in play here. erlang's goal is fault tolerance. haskell's goal is bug freedom. these are not at odds, nor does it imply that erlang projects are supposed to be bug-embracing or that haskell projects are supposed to be fault-free.
12:02:52 <Eduard_Munteanu> jmcarthur: I didn't mean for that connotation
12:03:14 <jmcarthur> to the extent that bugs are "faults" your claim is true, but i still claim as worded it was misleading
12:03:15 <Destinova> thanks, Eduard_Munteanu. I wonder how much the fault-tolerant vs fault elimination approach willl have on my learning, at least until I get half-decent with the language. Still, its a future implication I need to keep in mind.
12:03:32 * monochrom considers all casual discussions to be misleading
12:03:37 <jmcarthur> but there are also faults which are not bugs
12:04:15 * chrisdone casually misleads all considerate discussions
12:04:37 <Destinova> I'd like an example please, if you don't mind, jmcarthur
12:04:42 <Destinova> sorry if that's a dumb question
12:04:44 <donri> i think the philosophy of erlang is guided by a need to deal with hardware faults outside the control of the software
12:04:57 <jmcarthur> Destinova: a machine losing power is a fault, but not a bug
12:05:14 <Destinova> Oh, that kind of fault - right.
12:05:20 <jmcarthur> Destinova: so are bugs that are out of scope of the system you are programming, like an OS bug
12:05:20 <Eduard_Munteanu> jmcarthur: though in many ways Erlang programmers avoid correctness by all means :). The "let it crash" mantra is only ok if you have taken the necessary precautions first, not just "let it crash and cross your fingers".
12:05:42 <Tril> haskell.org web down?
12:05:43 <chrisdone> although crash-only software is quite a nice concept
12:05:55 <heatsink> what
12:06:00 <chrisdone> don't have a start-up and shutdown procedure, only have a really good recovery procedure
12:06:03 <jmcarthur> Eduard_Munteanu: in distributed systems, let it crash is almost always the right failure response, and i think this is true even when written in haskell
12:06:04 <byorgey> Tril: yes
12:06:09 <byorgey> see /topic
12:06:24 <jmcarthur> and not just "let it crash" but "force it to crash"
12:06:56 <jmcarthur> well, when i say "failure" i do mean "unrecoverable failures" to be clear
12:06:59 <Eduard_Munteanu> jmcarthur: yes... assuming crash also means failover. I agree Haskell code could benefit from such strategies.
12:07:07 <jmcarthur> which is the only kind worth talking about in this context, i think
12:07:31 <Eduard_Munteanu> jmcarthur: unrecoverable locally but the distributed system fails over, it doesn't crash itself.
12:07:38 <chrisdone> :t moeb liftA
12:07:40 <lambdabot> Applicative f => f (f t1 -> t1) -> f t1
12:08:02 <jmcarthur> yeah, redundancy is the way to go (when the work is justified)
12:08:39 <donri> isn't that why cloud haskell is about actors
12:08:42 <Eduard_Munteanu> If I'm making a networked application, sure, I'm not going to write code to call the ISP company and file a complaint the link is down, I'm going to make it use a different link. :)
12:08:47 <FreeFull> :t moeb const
12:08:49 <lambdabot>     Occurs check: cannot construct the infinite type:
12:08:49 <lambdabot>       t20 = (t20 -> t10) -> t10
12:08:49 <lambdabot>     Expected type: ((t20 -> t10) -> t10) -> t0 -> t20
12:08:52 <benzrf> :t maybe
12:08:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:08:54 <jmcarthur> but i claim that even without redundancy, it's a mistake to try to recover from unusual, expected issues.
12:08:58 <FreeFull> :t moeb maybe
12:08:59 <lambdabot>     Occurs check: cannot construct the infinite type:
12:08:59 <lambdabot>       t20 = Maybe a0 -> (t20 -> t10) -> t10
12:08:59 <lambdabot>     Expected type: ((t20 -> t10) -> t10)
12:09:06 <chrisdone> :t moeb (const maybe)
12:09:07 <jmcarthur> *unexpected
12:09:07 <lambdabot> t -> (a -> t) -> Maybe a -> t
12:09:10 <chrisdone> =)
12:09:22 <benzrf> what is moeb?
12:09:26 <chrisdone> :t moeb
12:09:27 <lambdabot> (((t2 -> t1) -> t1) -> t -> t2) -> t -> t2
12:09:32 <benzrf> wat
12:09:33 <quchen> I HOPE THAT HELPS
12:09:35 <chrisdone> lol
12:09:36 <chrisdone> hahahaha
12:09:46 <chrisdone> i lol'd
12:09:46 <aristid> Eduard_Munteanu: OBLIGATORY xkcd http://xkcd.com/416/
12:09:47 <FreeFull> benzrf: moeb is like loeb but with one extra parameter
12:09:58 <danharaj> edwardk: are there any nice examples of its use?
12:09:59 <quchen> benzrf:  moeb f xs = f (\g -> g (moeb f xs)) xs
12:10:03 <quchen> moeb fmap = loeb
12:10:19 <quchen> Waitwaitwait, Unicode!
12:10:26 <ion> In Erlang, you use the “let it crash” thing isolate the area of code that really needs to be right. Not completely unlike how you isolate the area of code that requires IO effects in Haskell. You let the supervisor take care of restarting the other parts upon crashes, confident that they won’t affect the important processes, and figure out all the possible things that could go wrong with the small
12:10:28 <ion> piece of code that keeps your nuclear power plant from going to a meltdown.
12:10:34 <quchen> möb f xs = f (\g -> g (möb f xs)) xs
12:10:41 <aristid> quchen: +1 for good spelling
12:10:52 <jmcarthur> ion: right on
12:10:53 <FreeFull> Erlang is for making large systems
12:10:59 <Eduard_Munteanu> jmcarthur: yeah, I just meant it's a bit unfortunate Erlang isn't a more strict language, because coding errors are the kind of errors which tend to occur in clusters and repeat themselves, something you can't really deal with by restarting.
12:11:27 <Eduard_Munteanu> aristid: hehe
12:13:25 <augur_> hm
12:13:36 <augur_> i just realized the connection between the State monad at diff lists
12:14:03 <ion> Please elaborate.
12:14:34 <augur_> well, do you know what diff lists are in, say, prolog?
12:14:51 <ion> I know what they are in Haskell, but not in Prolog.
12:15:14 <augur_> i think they're the same thing but i can be sure
12:15:19 <chrisdone> > let moeb f xs = f (\g -> g (moeb f xs)) xs in flip evalState 0 $ sequence (moeb liftM [const (modify (+1) >> get >>= return),\xs -> head xs]) -- quchen
12:15:26 <lambdabot>   [1,2]
12:15:50 <augur_> in prolog they're predicates with two list args, one that represents the argument to work on, and one that represents the remainder that's left over
12:16:05 <augur_> ion: so something typical in a parsing library, for instance
12:16:21 <chrisdone> > let moeb f xs = f (\g -> g (moeb f xs)) xs in flip evalState 0 $ sequence (moeb liftM [const (modify (+1) >> get >>= return),head,head,const (modify (subtract 2) >> return 1),head])
12:16:23 <lambdabot>   [1,2,3,1,2]
12:16:28 <jmcarthur> i thought i knew what they are in prolog, but apparently not
12:16:34 <ion> augur: Ok, so not the same thing at all.
12:17:06 <chrisdone> augur_: does append count?
12:17:16 <heatsink> ...since the topic came up, can you recommend a prolog tutorial?
12:17:20 <augur_> chrisdone: how do you mean?
12:17:23 <chrisdone> append takes two lists and a third arg for the result
12:17:24 <Destinova> That's quite some interesting info. Thank you chrisdone, byorgey, Eduard_Munteanu, FreeFull and jmcarthur!
12:17:42 <augur_> chrisdone: diff list based prolog code uses predicates
12:17:45 <chrisdone> Destinova: welcome! hope to see you here again =)
12:17:47 <jmcarthur> > let moeb f xs = let ys = f (\g -> g ys) xs in ys in flip evalState 0 $ sequence (moeb liftM [const (modify (+1) >> get >>= return),head,head,const (modify (subtract 2) >> return 1),head])
12:17:48 <Destinova> I appreciate your taking the time to answer my questions - although i fear i may be back with more
12:17:49 <lambdabot>   [1,2,3,1,2]
12:17:55 <augur_> chrisdone: a haskell difflist function is just [a] -> [a]
12:18:07 <quchen> chrisdone: Why did you address that to me? To confuse me? :-s
12:18:11 <augur_> or maybe [a] -> [[a]] if you allow multiple solutions
12:18:21 <chrisdone> quchen: though you might find it interesting? =)
12:18:25 <ion> I guess i kind of see a connection, since you get a backtracking parser from StateT [token] [] a.
12:18:26 <bearclaw> ion: your anti-meltdown core code can fail even if perfect when fed with bad data
12:18:35 <quchen> chrisdone: Oh. Let me revisit it then.
12:18:36 <FireFly> chrisdone: what is this m{oe,ö}b?
12:18:43 <Eduard_Munteanu> Destinova: phew... we feared you wouldn't come back at all. :P
12:19:14 <chrisdone> > let moeb f xs = f (\g -> g (moeb f xs)) xs in flip evalState 0 $ sequence (moeb liftM [const (modify (+1) >> get >>= return),head,head,const (modify (subtract 3) >> return 1),head,(!!2),(!!3)])
12:19:16 <lambdabot>   [1,2,3,1,1,2,1]
12:19:28 <bearclaw> my point being that isolation is sometimes hard, and the "critical" part can be a huge chunk of the whole system
12:19:34 <chrisdone> it's like you can apply things in the past and also get their value
12:20:07 <augur_> chrisdone: a typical parsing thing in prolog looks like this:   add(Xs, Ys) :- expr(Xs,Zs), plusSymbol(Zs,Ws), expr(Ws,Ys).
12:20:14 <chrisdone> FireFly: dunno, quchen defined it based on loeb. we're wondering what the usefulness of it is, if any
12:20:25 <FireFly> ...what's loeb? :P
12:20:32 <quchen> chrisdone: Well the above example used loeb only though
12:20:35 <chrisdone> firefly: http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
12:20:36 <ion> @google haskell loeb
12:20:40 <FireFly> chrisdone: thanks
12:20:41 <monochrom> isolation is hard. this is why we pay money for people to do it. not why we go shopping.
12:20:51 <lambdabot> Plugin `search' failed with: <<timeout>>
12:20:54 <augur_> chrisdone: which is analogous to the usual applicative style of incremental parsing
12:20:55 <chrisdone> quchen: well it used liftM
12:21:04 <chrisdone> quchen: meaning i could use monadic stuff. in basic loeb you can't
12:21:28 <chrisdone> augur_: so far so good
12:21:39 <quchen> chrisdone: Oh, because history etc. Right.
12:22:01 <chrisdone> so it's like a spreadsheet with state :D
12:22:13 <augur_> chrisdone: obviously in haskell instead of add/2, expr/2, plusSymbol/2, you have add, expr, plusSymbol :: [Expr] -> [[Expr]]
12:22:14 <chrisdone> somehow…
12:22:16 <augur_> or something like that
12:22:18 <quchen> chrisdone: I don't understand the example though. I mean the list head is State, the tail isn't
12:22:25 <khyperia> *sigh*... I just hacked up pattern matching in C#, then I tried to show it off to the C# irc... they don't get it, saying how the heck is this useful... lol
12:22:27 <quchen> And the Functor is []
12:22:30 <quchen> I'm confused
12:22:39 <chrisdone> quchen: well the list is a list of State Int a's
12:22:53 <chrisdone> quchen: and you're returning a State Int a also
12:23:02 <chrisdone> quchen: so you can return something, but also modify the state while you're doing it
12:23:21 <kryft> Hmm, if I have "data Foo = Bar {num :: Int, str :: String} | Baz", how would I pattern match on a Bar value? "getStr Foo (Bar b) = str b" complains about the constructor Bar not getting enough arguments - I guess it wants to match on both fields separately?
12:23:29 <augur_> chrisdone: but now imagine that you're doing stuff like managing variables in a language with stateful scope. how do you do it? well, with diff lists! vars-in, vars-out
12:23:43 <chrisdone> :t let moeb f xs = f (\g -> g (moeb f xs)) xs in moeb liftM
12:23:47 <lambdabot> Monad m => m (m t -> t) -> m t
12:23:47 <kryft> I'm only interested in one field here though, and there are quite a few fields
12:24:01 <monochrom> khyperia: pattern matching is only useful for algebraic types. but c# people don't use algebraic types. that's the problem.
12:24:07 <benmachine> kryft: try Bar { num = b }
12:24:09 <augur_> makeNewVar/2 in prolog might be   makeNewVar(Xs,[X|Xs]).   because the output list has an extra element
12:24:27 <chrisdone> quchen: oh you're right, it's the return value of the list that makes the monadicness
12:24:40 <augur_> in haskell it'd be makeNewVar xs = x:xs   (for some x)
12:24:42 <quchen> chrisdone: How is "\xs -> head xs" a State?
12:24:47 <khyperia> monochrom, I personally use a lot of algebraic types in my C#, and it's a PITA to do.
12:25:04 <quchen> chrisdone: I'm confused why this even typechecks
12:25:20 <monochrom> P.S. have you seen my http://www.vex.net/~trebla/humour/Nightmare.java ?
12:25:23 <kryft> benmachine: Ah, right; thanks a lot
12:25:47 <kryft> benmachine: I'm sure I've read about that somewhere, but I couldn't find it
12:26:05 <chrisdone> quchen: here's how i got to it:
12:26:14 <benmachine> kryft: it's Haskell records, which aren't used that much because they aren't that good :P
12:26:16 <augur_> chrisdone: directional conjunction:   (&&) :: ([a] -> [[a]]) -> ([a] -> [[a]]) -> [a] -> [[a]]   ; p && q = \xs -> let ys = p xs, zs = q ys in zs
12:27:25 <chrisdone> :t let moeb f xs = f (\g -> g (moeb f xs)) xs in moeb liftM []
12:27:26 <lambdabot> [t]
12:27:29 <chrisdone> :t let moeb f xs = f (\g -> g (moeb f xs)) xs in flip runStateT 0 $ sequence $ moeb liftM []
12:27:30 <lambdabot> (Monad m, Num b) => m ([a], b)
12:27:43 <augur_> but all of this stuff needs to be embedded in a pair so that your return values arent just the lists but the lists to continue with, plus the current value
12:27:49 <chrisdone> :t let moeb f xs = f (\g -> g (moeb f xs)) xs in flip runStateT 0 $ sequence $ moeb liftM [const (return 1),head]
12:27:50 <augur_> so its all [a] -> (b,[a])
12:27:50 <lambdabot> (Monad m, Num b, Num a) => m ([a], b)
12:28:02 <chrisdone> > let moeb f xs = f (\g -> g (moeb f xs)) xs in flip runStateT 0 $ sequence $ moeb liftM [const (return 1),head]
12:28:06 <lambdabot>   No instance for (GHC.Show.Show (m0 ([a0], b0)))
12:28:06 <lambdabot>    arising from a use of `M...
12:28:09 <augur_> for parsing its [Token] -> (PartialParse, [Token])
12:28:20 <ReinH> oh hai
12:28:21 <augur_> at least for deterministic parsing algos
12:28:36 <ReinH> chrisdone: o_O
12:28:41 <augur_> chrisdone: so its a diff-list system in the background.
12:28:43 <chrisdone> > let moeb f xs = f (\g -> g (moeb f xs)) xs in flip evalState 0 $ sequence $ moeb liftM [const (return 1),head]
12:28:45 <lambdabot>   [1,1]
12:28:57 <quchen> chrisdone: But where's State in that?
12:28:59 <ReinH> I still don't understand loeb o_O
12:28:59 <augur_> diff lists are just state threading for list-y states that always decrease in size!
12:29:10 <quchen> I see evalState, but it's applied to something unstaty :-(
12:30:04 <wolftune> Hi! So a few days ago, I popped in asking about a tutorial for people starting with Haskell rather than coming from non-functional programming background…
12:30:05 <chrisdone> quchen: because it's a list of State's, then i'm sequencing it, and sequence changes [m a] to m [a]
12:30:21 <quchen> chrisdone: How is 'head' a State?
12:30:28 <wolftune> Well, I found one! Wikibooks Haskell is totally it! https://en.wikibooks.org/wiki/Haskell
12:30:43 <Eduard_Munteanu> quchen: like get
12:30:48 <augur_> wolftune: have you tried LYAH?
12:30:49 <augur_> @where LYAH
12:30:50 <lambdabot> http://www.learnyouahaskell.com/
12:30:51 <chrisdone> quchen: remember it's taking an argument. head takes the head of a  [State Int Int]
12:30:51 <wolftune> I read through YAHT first and looked at other things, but Wikibooks is the thing
12:31:01 <quchen> OOhhhh
12:31:06 <chrisdone> :D
12:31:18 <quchen> Wait no nevermind. Wat.
12:31:19 <wolftune> augur_: I have not yet looked at LYAH, but I will, AND I know it is written for those with other programming background
12:31:21 <chrisdone> ReinH: check this
12:31:21 <chrisdone> > let moeb f xs = f (\g -> g (moeb f xs)) xs in flip evalState 0 $ sequence (moeb liftM [const (modify (+1) >> get >>= return),head,head,const (modify (subtract 3) >> return 1),head,(!!2),(!!3)])
12:31:21 <quchen> What's the type of head there
12:31:23 <lambdabot>   [1,2,3,1,1,2,1]
12:31:26 <Eduard_Munteanu> wolftune: yeah, some of it is great as a formal reference
12:31:33 <chrisdone> quchen: type of head is: [State Int Int] -> State Int Int
12:31:36 <chrisdone> (i think)
12:31:37 <ScriptDevil> Is there a way to reset imported modules in ghci?
12:31:49 <quchen> chrisdone: But that makes the Functor List, doesn't it
12:32:09 <wolftune> Eduard_Munteanu: I don't know if you've followed changes over time, but judging by the talk pages, the Wikibooks *used* to be a bit dense but is now rewritten as a really clear tutorial
12:32:15 <chrisdone> quchen: yeah, as i said earlier i think this is basic loeb, indeed
12:32:22 <chrisdone> no wait
12:32:23 <chrisdone> it's not
12:32:29 <quchen> chrisdone: Aaaah, the State stuff has *nothing* to do with the loeb
12:32:30 * chrisdone checks
12:32:46 <chrisdone> yeah, it is. indeed
12:32:48 <quchen> chrisdone: You're just loeb-ing a list of State actions
12:33:02 <chrisdone> yeah. although i was aiming for making it part of it
12:33:06 <chrisdone> still, this is cool
12:33:14 <quchen> Not sure what you were checking there though. Why is "liftM = fmap" a question?
12:33:17 <wolftune> So, rather than anyone writing a new book, I'd encourage contributing to the wikibook
12:33:42 <chrisdone> quchen: let's see if we can make a use of moeb liftM that does something loeb can't
12:33:58 <chrisdone> or maybe liftA
12:34:11 <quchen> chrisdone: Back to your example, what this thing actually does is calculate the list [modify (+1) >> get >>= return, modify (+1) >> get >>= return]
12:34:14 <chrisdone> what weird stuff in lens is there that uses applicative =)
12:34:22 <quchen> chrisdone: And then it sequences that.
12:34:26 <chrisdone> quchen: yeah, it does
12:34:27 <quchen> In other words, the State stuff is just for display.
12:34:47 <quchen> Wonderful, confusion gone. I kept thinking moeb's Functor was State, but it was List.
12:34:58 <chrisdone> right
12:35:05 <quchen> (Don't read the previous sentence, I fear what you may make of it.)
12:35:15 <benzrf> ok
12:35:38 * chrisdone looks at instances of Applicative
12:35:45 <lpaste> benzrf pasted “sokoban” at http://lpaste.net/95786
12:35:52 <quchen> chrisdone: Make moeb liftM do something that loeb can't?
12:35:54 <benzrf> wait nvm
12:35:55 <quchen> How?
12:35:58 <benzrf> i shouldve linted it first
12:36:07 <quchen> I mean that should really not happen
12:36:14 <quchen> In other words, I don't understand the problem
12:37:03 <chrisdone> hmm, indeed. it's the same
12:37:30 <bennofs> @ty moeb traverse
12:37:31 <lambdabot> (Applicative f, Traversable t) => t (f (t b) -> f b) -> f (t b)
12:37:32 <ReinH> chrisdone: crazy.
12:37:34 <bennofs> oha
12:37:37 <quchen> chrisdone: Why is this surprising? Am I overlooking something?
12:38:14 <stephenmac7> Anyone know when http://www.haskell.org/ will be up?
12:38:23 <chrisdone> quchen: yeah, liftM/fmap/liftA are all the same in terms of what they'll enable with moeb. i want another function that enables something different, just to see if there is one
12:38:30 <kqr> i just read on reddit that hackage was down and what is the very next thing i do? try to look up documentation on hackage...
12:38:40 <bennofs> stephenmac7: I heard that they use the weekend to finally figure out what's going on
12:38:45 <quchen> chrisdone: Ah. And traverse is too enigmatic.
12:38:51 <quchen> chrisdone: And id is too easy.
12:38:55 <stephenmac7> bennofs: I see. Not having hoogle kills me
12:38:56 <bennofs> stephenmac7: so nobody really knows when it will be up again
12:38:59 <chrisdone> yeah, i can't make a version of traverse  that terminates
12:39:06 <bennofs> stephenmac7: you could try hayoo
12:39:08 <stephenmac7> Especially since I'm new to haskell
12:39:09 <kqr> stephenmac7, the latest on monday, but hopefully earlier, was what i read
12:39:11 <bennofs> @where hayoo
12:39:11 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
12:39:13 <chrisdone> apart from moeb traverse [pure 1]
12:39:21 <chrisdone> er,  const (pure 1), ja
12:39:24 <quchen> chrisdone: Probably because the traversal has to take the whole list into account which is only available when the traverse has been done.
12:39:31 <chrisdone> aye
12:39:38 <quchen> That's just a guess though. I have no idea what traverse does there. :-D
12:39:47 <quchen> :t moeb const
12:39:49 <lambdabot>     Occurs check: cannot construct the infinite type:
12:39:49 <lambdabot>       t20 = (t20 -> t10) -> t10
12:39:49 <lambdabot>     Expected type: ((t20 -> t10) -> t10) -> t0 -> t20
12:39:54 <stephenmac7> bennofs: That's better than nothing
12:39:58 <stephenmac7> But I still can't read the stuff
12:40:01 <chrisdone> i think it's because you have to actually "run" the computation that generates the list so that it can pass it to the functions
12:40:04 <chrisdone> or something
12:40:06 <stephenmac7> Google cache is only so good...
12:40:13 <stephenmac7> Thanks anyway
12:40:22 <lpaste> benzrf pasted “sokoban” at http://lpaste.net/95787
12:40:23 <bennofs> @ty moeb foldMap
12:40:24 <lambdabot> (Foldable t, Monoid t2) => t (t2 -> t2) -> t2
12:40:31 <chrisdone> oh, interesting
12:40:32 <quchen> bennofs: Oh that looks interesting.
12:40:51 <benzrf> ok
12:41:03 <benzrf> can anybody look over http://lpaste.net/95787 and give me tips or criticism?
12:41:28 <klugez> stephenmac7: https://www.fpcomplete.com/hoogle - You could use that.
12:41:56 <chrisdone> > let moeb f xs = f (\g -> g (moeb f xs)) xs in moeb foldMap [const [1],return.(!!0)] :: [Int]
12:41:58 <lambdabot>   [1,1]
12:42:08 <chrisdone> that's the basics…
12:42:15 <chrisdone> hmmm
12:42:16 <bennofs> that's just loeb for list
12:42:21 <bennofs> isn't it?
12:42:26 <stephenmac7> klugez: Why is it that the people who are in it for the money always provide the best services?
12:42:34 <chrisdone> yeah. just showing it as a starting point
12:42:38 <stephenmac7> Must mean capitalism works...
12:42:41 <stephenmac7> Anyways, thanks
12:43:03 <quchen> stephenmac7: Because the people who do it because they love it spend their time on IRC wondering what parameters moeb should take.
12:43:18 <augur_> chrisdone: what is this moeb thing
12:43:28 <augur_> it looks like some kind of continuized recursive function
12:43:31 <quchen> augur_: loeb on steroids
12:43:32 <bennofs> it's like a generalized fix
12:43:37 <augur_> quchen: whats loeb!
12:43:38 <fizruk> Eduard_Munteanu, on a second thought... apparently, existentials won't work: the value of type X is constructed *before* the interpretation is known. moreover there could be many interpretations
12:43:39 <bennofs> moeb id is fix
12:43:42 <chrisdone> :t moeb id
12:43:43 <lambdabot> (t2 -> t2) -> t2
12:43:44 <chrisdone> :t moeb
12:43:45 <lambdabot> (((t2 -> t1) -> t1) -> t -> t2) -> t -> t2
12:43:49 <quchen>  moeb f xs = f (\g -> g (moeb f xs)) xs
12:43:55 <stephenmac7> quchen: I'm pretty sure the people at fpcomplete love it too
12:43:55 <quchen> moeb fmap = loeb
12:43:56 <fizruk> Eduard_Munteanu, unless I misunderstood you :)
12:43:58 <chrisdone> augur_: http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
12:44:04 <stephenmac7> Not just for the money
12:44:10 <augur_> chrisdone: oh.
12:44:11 <stephenmac7> But mainly for it
12:44:22 * bennofs looks up Foldable instances
12:44:23 <stephenmac7> About that... I should pay for fpcomplete
12:44:25 <quchen> stephenmac7: I meant that a a bit (read: very much) tongue-in-cheek. :-)
12:44:28 <stephenmac7> My trial is up
12:44:36 <chrisdone> stephenmac7: i work at fp complete =)
12:44:42 <quchen> HAHA
12:44:42 <stephenmac7> chrisdone: You told me
12:44:45 <quchen> Right, bullseye
12:44:47 <stephenmac7> quchen: :D
12:45:03 <stephenmac7> chrisdone: Is FP Complete itself written in haskell
12:45:06 <bennofs> stephenmac7: as long as you don't need git/github integration and don't use it for commercial purposes the commmunity edition if free
12:45:16 <stephenmac7> Really?
12:45:18 <chrisdone> stephenmac7: of course!
12:45:19 * stephenmac7 takes a look
12:45:31 <stephenmac7> chrisdone: Your own concoction or a framework?
12:45:45 <chrisdone> stephenmac7: it's in yesod
12:45:49 <stephenmac7> Cool
12:45:55 <chrisdone> the IDE is written in fay
12:46:30 <Eduard_Munteanu> fizruk: the only thing you know about that 'm' is that it's a Monad. The only question is whether you need to build a monadic computation and then instantiate it at a particular monad, or if you need to abstract the monad. I sort of doubt the former case.
12:46:46 <stephenmac7> Very cool but...
12:46:57 <chrisdone> stephenmac7: but?
12:47:01 <stephenmac7> Why do the All/Tutorials/Projects tabs not work?
12:47:19 <chrisdone> how do you mean?
12:47:46 <stephenmac7> On the dashboard thing
12:47:51 <stephenmac7> There are tabs
12:47:58 <chrisdone> stephenmac7: there are indeed
12:48:01 <stephenmac7> I click one and it only changes the tab, but not the tabbed content
12:48:26 <quchen> chrisdone: Semi-related question: why is this a type error (without the type sig)? http://lpaste.net/95789
12:49:21 <kryft> benmachine: What should I use instead?
12:49:28 <Eduard_Munteanu> fizruk: think about it, if it really contains a 'forall m. Monad m => FreeT f m a', then you have to build a value polymorphic in 'm' to put it into the constructor.
12:49:34 <stephenmac7> chrisdone: Another minor issue
12:49:42 <mauke> quchen: dmr?
12:49:43 <fizruk> Eduard_Munteanu, given `forall m. FreeT f (InnerT m) a` I want to pick a particular m and interpret f's in terms of (InnerT m)'s
12:49:57 <stephenmac7> Your navbar's hover highlighting does not extend all the way to the bottom of the navbar
12:49:59 <fizruk> Eduard_Munteanu, I may do that multiple times with different m's
12:50:01 <chrisdone> quchen: it's just the monomorphism restriction?
12:50:02 <benmachine> kryft: oh, I'm not saying you shouldn't use them as such
12:50:14 <quchen> mauke, chrisdone: Oh, indeed.
12:50:16 <fizruk> Eduard_Munteanu, so I believe I want a polymorphic value
12:50:16 <Eduard_Munteanu> fizruk: hm, in that case you probably want the rank-2 variant, yeah
12:51:02 <chrisdone> stephenmac7: that's true. thanks
12:51:08 <Eduard_Munteanu> fizruk: still, you don't need an impredicative type, just  newtype X f a = X (forall m. FreeT f (InnerT m) a)
12:51:18 <stephenmac7> chrisdone: Which one? The first problem or the second?
12:51:33 <Eduard_Munteanu> fizruk: er, with Monad m too
12:51:43 <fizruk> Eduard_Munteanu, mm... that's not a MonadTrans I think
12:51:59 <chrisdone> stephenmac7: the tabs work fine for me. they don't necessarily change when you switch if the thing they're filtering is the same. but the nav highlight doesn't reach all the way to the bottom, indeed
12:52:07 <fizruk> Eduard_Munteanu, that's why I sticked to 'type synonyms'
12:52:09 <Eduard_Munteanu> fizruk: you don't *want* a MonadTrans, AFAICT :)
12:52:14 <stephenmac7> I see.
12:52:23 <stephenmac7> So, you have to have projects to see the tab changes
12:52:23 <chrisdone> stephenmac7: what's in the tabs that doesn't change?
12:52:27 <fizruk> Eduard_Munteanu, hm...
12:52:34 <stephenmac7> Welcome to FP Haskell Center(TM), now available in a free community edition.
12:52:35 <stephenmac7> This is your home page. It contains all your tutorials and projects.
12:52:52 <stephenmac7> Maybe drop the tabs if I have no content
12:53:05 <chrisdone> stephenmac7: mmk, maybe take this to #fpcomplete. users in #haskell probably aren't interested in the details
12:53:35 <quchen> moeb is one of the most confusing functions I've come across in a long time.
12:53:47 <quchen> (((a -> b) -> b) -> c -> a) -> c -> a
12:53:56 <quchen> How does that unify with "id" as the first parameter?
12:54:12 <quchen> I don't see an "a -> a" anywhere in the first parenthesis
12:54:33 <scott_> quchen: With c = a -> b and a = b
12:54:47 <Eduard_Munteanu> fizruk: if X is a MonadTrans with respect to InnerT m, then you can 'lift :: InnerT m a -> X f m a', and furthermore lift it all the way to OuterT.
12:55:08 <Eduard_Munteanu> :t lift
12:55:10 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
12:55:25 <quchen> scott_: Ooooh. Okay, now fmap! :-)
12:55:38 <Eduard_Munteanu> fizruk: because if OuterT is also a MonadTrans, any X computation can get lifted to OuterT.
12:56:04 <fizruk> Eduard_Munteanu, why is that not what I want? :)
12:56:47 <Eduard_Munteanu> fizruk: you said the user only sees either of OuterT X a, or InnerT m a
12:57:11 <scott_> quchen: Hmm
12:57:31 <fizruk> Eduard_Munteanu, oh I meant either m or OuterT, InnerT is seen from both "ends"
12:57:42 <fizruk> Eduard_Munteanu, I thought I made that clear, sorry
12:58:27 <int-e> Is there a documentation about how options for a cabal sandbox are combined from ~/.cabal/config, the local cabal.config file and the cabal.sandbox.config file? I'm particularly interested with the effect of user-install: False that I have in ~/.cabal/config
12:59:00 <quchen> scott_: a = (a -> b), c = f a, a = f b
12:59:03 <quchen> Looks right at least
12:59:07 <fizruk> Eduard_Munteanu, look at the stack: OuterT (FreeT f (InnerT m)) a
12:59:25 <Eduard_Munteanu> fizruk: ok...
12:59:34 <scott_> quchen: That's talking about two different 'a's?
12:59:43 <quchen> Yeah the notation is abysmal
12:59:49 <fizruk> Eduard_Munteanu, m is determined by particular interpreter and is seen solely for it
12:59:54 <quchen> I'm really just trying to make sense of what the first parameter of moeb is
13:00:10 <kryft> If I have Data.Map imported qualified as Map, what's the qualified name of (!)? Neither Map.(!) nor (Map.!) seems to work
13:00:14 <fizruk> Eduard_Munteanu, f is a predefined user-interpreter interface defined
13:00:17 <Eduard_Munteanu> fizruk: so you want to hide 'm' alone?
13:00:32 <quchen> kryft: I don't think Map has (!).
13:00:37 <fizruk> Eduard_Munteanu, OuterT is user-only portion of program
13:00:40 <quchen> kryft: (!) is Vector.
13:00:47 <quchen> kryft: Map has lookup, for example.
13:01:06 <quchen> kryft: Other than that, (Map.!) is the right syntax.
13:01:18 <quchen> :t (Prelude.!!)
13:01:20 <fizruk> Eduard_Munteanu, and InnerT is an "exposed" portion of user's code that interpreter may affect/use
13:01:20 <lambdabot> [a] -> Int -> a
13:01:37 <fizruk> Eduard_Munteanu, so yes, I want to hide 'm' alone
13:01:50 <benzrf> why arent there num instances for small tuples
13:01:51 <benzrf> D:
13:02:18 <kryft> quchen: Oh, Data.Map.Lazy did list it
13:02:22 <fizruk> Eduard_Munteanu, newtype thing seems to work except for the MonadTrans part (though I could supply liftX for that purpose), right?
13:02:30 <int-e> @let moo = "Moo!"
13:02:30 <lambdabot>  .L.hs:141:1:
13:02:31 <lambdabot>      Multiple declarations of `moo'
13:02:31 <lambdabot>      Declared at: .L.hs:140...
13:02:39 <int-e> @let mooo = "Moo!"
13:02:40 <lambdabot>  Defined.
13:02:41 <int-e> > mooo
13:02:47 <haasn> :t moo
13:02:49 <lambdabot>   mueval-core: Time limit exceeded
13:02:54 <lambdabot> Integer
13:03:05 <haasn> Oh
13:03:25 <Eduard_Munteanu> fizruk: ok... in that case you can restrict your run* function a-la runST: runX :: (forall m. FreeT f (InnerT m) a) -> a
13:03:43 <Eduard_Munteanu> forall m. Monad m rather
13:04:26 <Eduard_Munteanu> fizruk: or if you can't extract an 'a', you can pick a different m' and return m' a.
13:05:44 <fizruk> Eduard_Munteanu, I can do that. I was hoping to remove 'm' from user-code though
13:06:09 <kryft> quchen: Data.Map does actually have ! - anyway, thanks, (Map.!) seems to work now
13:06:24 <quchen> kryft: Oh, good to know
13:06:48 <Eduard_Munteanu> fizruk: remove it from runX's argument's perspective, or from its caller's perspective?
13:07:10 <int-e> monochrom: argh, it's timing out loading the millions of packages that L.hs imports.
13:07:22 <monochrom> hehe
13:07:36 <fizruk> Eduard_Munteanu, from runX's argument's and hence from OuterT user's perspective
13:08:39 <absence> does the hackage mirror have documentation online?
13:08:47 <miguelnegrao> Hi
13:09:24 <fizruk> Eduard_Munteanu, ehm... not sure 'hence' is appropriate. OuterT user's perspective should not know about 'm' ideally when building value of type ... X ...
13:09:39 <miguelnegrao> since I've updated to ubuntu 13.10 I can't compile my scripts done with shelly, I get " Couldn't match expected type `Data.Text.Internal.Text' with actual type `T.Text'"
13:09:47 <miguelnegrao> Any hints ?
13:09:58 <Eduard_Munteanu> fizruk: you could make that argument pretend that it has a '(MonadInner m, MonadFree f m) => m a' instead, and due to the polymorphism you only see one monad.
13:10:58 <Eduard_Munteanu> fizruk: if you want to abstract over MonadInner you have a few options...
13:11:33 <fizruk> Eduard_Munteanu, e.g. constraint kinds?
13:11:38 <Eduard_Munteanu> fizruk: 1) provide a 'liftInner :: Inner a -> m a' for that 'm'
13:11:44 <Eduard_Munteanu> fizruk: 2) constraint kinds :)
13:12:35 <supki> miguelnegrao: what's T?
13:13:17 <miguelnegrao> supki: import qualified Data.Text.Lazy as T
13:13:36 <miguelnegrao> supki: I'm using {-# LANGUAGE QuasiQuotes, OverloadedStrings #-}
13:13:48 <Dasuraga> So I was looking for a sort of monad to consume a list, I found the Consumer monad, but I'm having a hard time understanding how this works
13:13:54 <supki> miguelnegrao: apparently shelly wants strict Text instead
13:14:14 <supki> miguelnegrao: import qualified Data.Text as T
13:14:18 <Dasuraga> basically I was looking for a monad that would have as a state [a], with some action that would let me "pop" some elements
13:14:23 <sdrodge> Eduard_Munteanu: I want to try that solution you suggested earlier today that uses a wrapper for Vector, but I've realized I don't fully understand it. I assumed the purpose was to create a new instance of Vector and define modify, which would allow me to use all the normal Vector operations on the wrapper type. I can't seem to find a typeclass that works this way though...
13:14:27 <Eduard_Munteanu> fizruk: 3) (tentative) you might be able to make the inner monad a MonadBase, and in some other place a MonadTrans and have a way to convert InnerT Identity a  to  InnerT m a  for an arbitrary m
13:14:55 <kqr> could anyone enlighten me as to what parsec does here: http://lpaste.net/1752226771345866752 ? i would expect both to do the same thing but they don't. why is that?
13:15:13 <miguelnegrao> code here: https://gist.github.com/miguel-negrao/5895613
13:15:14 <nisstyre> is there a mirror for the documentation stuff on hackage? hdiff.luite.com doesn't seem to mirror that stuff
13:15:18 <fizruk> Eduard_Munteanu, InnerT might as well be ContT
13:15:33 <Eduard_Munteanu> sdrodge: ah, no, I thought you could restrict your operations in some way. If you can completely change the vector, you could just recompute the entire sum.
13:15:37 <miguelnegrao> supki: then I get Couldn't match expected type `T.Text' with actual type `Data.Text.Lazy.Internal.Text'
13:16:06 <supki> heh
13:16:07 <fizruk> Eduard_Munteanu, I think I see it like this: runX has the type similar to what you've written above
13:16:17 <monochrom> kqr: many (noneOf " ") already takes all of "test\n"
13:16:21 <ifesdjee_> hi, I'm sorry to bother here with such simplistic questions, but haskell.org is down today :(
13:16:45 <sdrodge> Eduard_Munteanu: I'm generally modifying between 1/8 and 1/2 of the entries in the Vector
13:16:48 <kqr> nisstyre, http://haddocks.fpcomplete.com/fp/7.4.2/20130922-179/
13:16:56 <kqr> monochrom, of course! thank you
13:17:00 <miguelnegrao> ifesdjee_: I noticed that too...
13:17:02 <monoidal> ifesdjee_: see http://www.reddit.com/r/haskell/comments/1qrldv/haskellorg_servers_down_at_the_moment/ and channel topic
13:17:05 <nisstyre> kqr: thank you
13:17:06 <ifesdjee_> I have a `data` definiton, as follows: data LispExpression = LispSymbol String | LispList [LispExpression] and a typeclass:
13:17:14 <Eduard_Munteanu> fizruk: hm, there's also 4) ask the user to make their InnerT applied to a polymorphic monad
13:17:15 <ifesdjee_> class LispLiteral l where toSexp :: l -> LispExpression
13:17:31 <supki> miguelnegrao: I guess you need to figure out which function uses which Text and to convert between them
13:17:39 <fizruk> Eduard_Munteanu, user code has type like (MonadX InnerT m) => OuterT m a
13:17:42 <kqr> monochrom, do you have a suggestion for how to best fix it?
13:17:46 <ifesdjee_> i'm trying to implement the LispLiteral's toSexp for LispList, but can't figure out syntax :/
13:17:56 <ifesdjee_> that one doesn't look correct: instance LispLiteral [a] where toSexp n = LispList $ map toSexp n
13:18:07 <fizruk> Eduard_Munteanu, the last one I'm trying to avoid :)
13:18:13 <ifesdjee_> monoidal: thanks!
13:18:16 <fizruk> Eduard_Munteanu, i mean 4)
13:18:18 <sdrodge> Eduard_Munteanu: I was looking for a way to touch only the entries I want to update, and keep the "sum" up to date at the same time.
13:18:43 <miguelnegrao> supki: the exact same code was working on ghc 7.6.2... I guess it's something related with the quasiquote strings...
13:18:52 <monoidal> ifesdjee_: you need instance LispLiteral a => LispLiteral [a] where ...
13:18:58 <monochrom> replace noneOf " " by something more specific
13:19:06 <fizruk> Eduard_Munteanu, and MonadX InnerT m is pretty much like MonadBase only for transformer over arbitrary monad...
13:19:38 <fizruk> Eduard_Munteanu, I should try that out! thanks again!
13:19:44 <Eduard_Munteanu> sdrodge: it would help to restrict the kind of operations you apply to it... if it's really affecting that little portion, then it's most likely not a scan or something like that
13:20:01 <Eduard_Munteanu> fizruk: hm, yeah
13:20:06 <ifesdjee_> monoidal: thanks! trying that out!
13:20:20 <sdrodge> Eduard_Munteanu: Don't know what you mean w.r.t restricting the kind of operations
13:20:29 <fizruk> Eduard_Munteanu, that would be 5) :)
13:20:34 <Eduard_Munteanu> Heh.
13:21:27 <miguelnegrao> supki: thanks, I'll keep investigating.
13:22:09 <Eduard_Munteanu> sdrodge: you just seem to want to update specific locations in the vector. If so, then write that, then the rest of the operations can go through a function :: (Vector a -> Vector b) -> VecSum a -> VecSum b  that recomputes the sum from scratch
13:30:25 <mkay_> question: does anybody have an idea how I could handle an error case inside a HashMap adjust function?
13:30:44 <mkay_> err, the insertWith function rather
13:31:28 <mkay_> as in, it's possible that the function manipulating the existing value to produce a new one encounters an error, and I'm not sure how I could communicate that to outside the call...
13:33:01 <gsnedders> If I have a function :: a -> a -> b is there some other function I can compose with it to get a function :: a -> b where the first argument is duplicated?
13:33:23 <FreeFull> gsnedders: join function
13:33:31 <FreeFull> > join (*) 3
13:33:32 <lambdabot>   9
13:33:43 <FreeFull> > join (,) 3
13:33:45 <lambdabot>   (3,3)
13:33:52 <Iceland_jack> gsnedders: Or (\x -> f x x) :)
13:34:14 <benmachine> mkay_: well, what do you want to happen?
13:34:59 <chrisdone> did anything awesome happen with moeb while i was away?
13:35:29 <benmachine> chrisdone: if you don't mind me asking, why are you suddenly so excited about these ös?
13:36:16 <gsnedders> FreeFull: join, defined where? Doesn't appear to be in the prelude with 7.6.3?
13:36:50 <chrisdone> benmachine: 'cause it's interesting?
13:37:09 <mkay_> benmachine: I'd like to know right after the insertWith call whether everything worked, without having to query the resulting value a second time
13:37:19 <chrisdone> benmachine: why are you so unexcited? =p
13:37:36 <benmachine> chrisdone: I'm just wondering if there's background I missed
13:37:47 <benmachine> chrisdone: it is kinda exciting, I like the spreadsheets thing
13:37:55 <benmachine> chrisdone: but the sigfpe blog post is from 2006 :P
13:38:04 <benmachine> chrisdone: why wasn't I /already/ excited :P
13:38:42 <gsnedders> FreeFull: Or why else wouldn't join be in scope in ghci?
13:38:54 <chrisdone> benmachine: yeah. i saw the post a few years ago and i was loving it, but it's only recently i found a use-case for it, so it re-kindled my excitement
13:39:03 <bennofs> @let data Iter a = Iter (a -> a) a Int
13:39:05 <lambdabot>  Defined.
13:39:06 <chrisdone> and i totally need to start reading sigfpe's blog
13:39:14 <bennofs> @let instance Foldable Iter where foldMap f (Iter i a i) = foldMap f $ take i $ iterate i a
13:39:14 <lambdabot>  .L.hs:146:25:
13:39:15 <lambdabot>      Conflicting definitions for `i'
13:39:15 <lambdabot>      Bound at: .L.hs:146:...
13:39:15 <chrisdone> all of it
13:39:24 <bennofs> @let instance Foldable Iter where foldMap f (Iter g a i) = foldMap f $ take i $ iterate g a
13:39:26 <lambdabot>  Defined.
13:39:40 <bennofs> > F.toList (Iter id 1 3)
13:39:47 <lambdabot>   mueval-core: Time limit exceeded
13:39:50 <bennofs> aw
13:39:59 <benmachine> chrisdone: I'd ask you what the recent use case is but I'm already reading your blog so I'll finish that first :P
13:40:11 <chrisdone> benmachine: yeah =p
13:40:59 <bennofs> let fm f (Iter g a i) = foldMap f $ take i $ iterate g a in moeb fm (Iter id (const [3]) 3)
13:41:01 <bennofs> > let fm f (Iter g a i) = foldMap f $ take i $ iterate g a in moeb fm (Iter id (const [3]) 3)
13:41:02 <lambdabot>   Not in scope: data constructor `Iter'Not in scope: `moeb'Not in scope: data...
13:41:38 <bennofs> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm (id, const [3], 3)
13:41:39 <lambdabot>   Not in scope: `moeb'
13:42:15 <bennofs> > let moeb f xs = f (\g -> g (moeb f xs) xs; fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm (id, const [3], 3)
13:42:17 <lambdabot>   <hint>:1:42: parse error on input `;'
13:42:26 <bennofs> > let moeb f xs = f (\g -> g (moeb f xs) xs in let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm (id, const [3], 3)
13:42:27 <lambdabot>   <hint>:1:43: parse error on input `in'
13:42:29 <bennofs> aw
13:42:35 * bennofs switches to private
13:42:36 <int-e> > moo
13:42:39 <lambdabot>   1
13:42:47 <t4nk223> hi, what's up with haskell.org?
13:42:53 <frx> dead
13:42:56 <maik_> :(
13:42:57 <bennofs> t4nk223: it's down :P
13:43:13 <int-e> sigh. ok, it has a fighting chance to manage the timeout now, but I still need to investigate further.
13:43:15 <bennofs> > let moeb f xs = f (\g -> g (moeb f xs)) xs in let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm (id, const [3], 3)
13:43:17 <lambdabot>   [3,3,3]
13:43:20 <bennofs> chrisdone: ^^
13:43:31 <int-e> @let moeb f xs = f (\g -> g (moeb f xs)) xs
13:43:32 <bennofs> chrisdone: That pair I used is Iter, and fm stands for foldMap
13:43:33 <geekosaur> hackage mirror in /topic
13:43:35 <lambdabot>  Defined.
13:43:46 <int-e> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm (id, const [3], 3)
13:43:48 <lambdabot>   [3,3,3]
13:44:19 <maik_> is anyone working on an incremental garbage collection?
13:44:31 <benmachine> chrisdone: ok done, I'm with you, that's cool
13:46:56 <bennofs> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm ((\x -> (4:) . x), const [3], 3)
13:46:57 <alnix> hello
13:47:01 <lambdabot>   [3,4,3,4,4,3]
13:47:02 <chrisdone> benmachine: woo!
13:47:06 <bennofs> ok, this is cool
13:47:13 <chrisdone> ohhhh
13:47:14 <bennofs> don't ask me how that works
13:47:34 <ReinH> chrisdone: now what does one use moeb for?
13:47:42 <bennofs> the number of 4's increases each time
13:47:52 <chrisdone> ReinH: corecursive data structures
13:47:53 <mauke> zygohistomorphic prepromorphisms
13:47:55 <bennofs> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm ((\x -> (4:) . x), const [3], 5)
13:47:59 <lambdabot>   [3,4,3,4,4,3,4,4,4,3,4,4,4,4,3]
13:48:00 <ReinH> chrisdone: well yes :p
13:48:08 <chrisdone> ReinH: did you see http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
13:48:18 <ReinH> chrisdone: I've seen some clever uses of loeb (like your recent post)
13:48:22 <ReinH> Are there clever uses of moeb?
13:48:25 <chrisdone> sweet
13:48:34 <chrisdone> i guess that's what we're trying to figure out
13:48:38 <ReinH> ah :)
13:48:50 <chrisdone> bennofs: what is this witchcraft?
13:48:51 <ReinH> it seems like moeb should be more powerful in some way I can't specify
13:49:17 <alnix> it is planned to make mirrors haskell.org?
13:49:21 <int-e> monochrom: in particular it was loading the ghc package, which takes ages ... I fixed that now, but it's still taking more time than I'd like.
13:49:26 <ReinH> chrisdone: presumably the (4:) is being built up by iterate
13:50:04 <chrisdone> hmm, yeah i get it. but what's the point in it, bennofs? =p
13:50:44 <chrisdone> let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm ((\x -> (4:) . x), return.length, 5)
13:50:45 <chrisdone> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm ((\x -> (4:) . x), return.length, 5)
13:50:48 <lambdabot>   [15,4,15,4,4,15,4,4,4,15,4,4,4,4,15]
13:50:57 <bennofs> Hmm, I don't know. It showed that there are uses of moeb foldMap that are different from moeb fmap :P
13:51:00 * chrisdone goes to eat pasta
13:51:06 <chrisdone> bennofs: true =)
13:51:42 <ReinH> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm ((\x -> (0:) . x), const [1], 5)
13:51:44 <lambdabot>   [1,0,1,0,0,1,0,0,0,1,0,0,0,0,1]
13:51:54 <ReinH> well, this generates an irrational number...
13:51:59 <monochrom> heh, yeah, the ghc api takes forever, it's like 60MB or something :)
13:52:34 <ReinH> surely 0.1010010001... is a defined sequence of some sort
13:52:38 <monochrom> pray for ghc 7.8! its *.so preference may help :)
13:53:15 <chrisdone> ReinH: L  O  S  T
13:53:27 <ReinH> chrisdone: http://en.wikipedia.org/wiki/Golomb_ruler
13:53:30 <int-e> monochrom: of course it was not actually used; lambdabot comes with a Lambdabot.Plugin.Haskell.Eval.Trusted module that Pristine.hs imports ... even though that module has light dependencies (oeis and quickcheck), since the package it is in requires the ghc api, that's getting loaded. so the fix was to move it to an extra package.
13:53:45 <bennofs> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm ((\x -> (0:) . x), return.length, 10) == sum [1..10]
13:53:47 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
13:53:47 <lambdabot>    arising from a use of `Dat...
13:54:10 <bennofs> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in head (moeb fm ((\x -> (0:) . x), return.length, 10)) == sum [1..10]
13:54:12 <lambdabot>   True
13:55:28 <ReinH> numbers are fun
14:00:22 <benmachine> chrisdone: p.s. be careful of using the word "corecursive" because corecursion is actually a thing :P
14:00:38 <benmachine> chrisdone: a thing you do with codata, related to coinduction
14:01:11 <chrisdone> benmachine: i know it's a thing that's why i used the word?
14:01:37 <benmachine> chrisdone: do you mean something other than "mutual recursion"?
14:02:23 <benmachine> chrisdone: I suppose there are two meanings, one from co- as a prefix meaning sort of together (e.g. co-operation) and one from co- meaning category-theoretic dual
14:03:26 <chrisdone> http://en.wikipedia.org/wiki/Corecursion
14:03:51 <benmachine> chrisdone: oh, right, in which case continue
14:03:57 <benmachine> sorry, I thought you were using the word in a different way
14:04:39 <benmachine> well, now I'm just not sure that moeb really is corecursive, but that's a different issue
14:04:48 <benmachine> that's probably my problem
14:04:55 <donri> corecursion: see recorsion
14:05:05 <bennofs> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm ((\x -> (0:) . x), (return . (!!3)),10)
14:05:06 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:05:07 <bennofs> > let fm f (g,a,i) = foldMap f $ take i $ iterate g a in moeb fm ((\x -> (0:) . x), (return . (!!5)),10)
14:05:15 <lambdabot>   mueval-core: Time limit exceeded
14:05:49 <bennofs> can anybody explain why this terminates for 3 but doesn't for 5? For all numbers under 10, the ones for which it doesn't terminate are [2,5,9]
14:06:20 <fizruk> what's moeb?
14:07:03 <bennofs> moeb f xs = f (\g -> g (moeb f xs)) xs
14:07:53 <oleo> ya but what does it mean ?
14:08:19 <bennofs> ah I got it. That's exactly the places where [x !! 5] will appear
14:08:20 <k0001> 12
14:08:28 <chrisdone> it's a generalization of loeb from http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
14:08:32 <bennofs> (in the resulting list)
14:09:47 <benmachine> :t moeb
14:09:52 <lambdabot> (((t2 -> t1) -> t1) -> t -> t2) -> t -> t2
14:10:09 <benmachine> seems legit
14:10:27 <c_wraith> bennofs: Huh.  This seems like it might be related to what I was working on last night.
14:10:56 <oleo> l o e b
14:11:14 <oleo> hmmmm
14:11:15 <fizruk> Eduard_Munteanu, oh... now I remember why I used 'type synonym': if I have newtype X f t a = { ... } I can't have e.g. MonadState instance :(
14:11:31 <oleo> lenght of endo what =
14:11:33 <oleo> ?
14:11:50 <kqr> how can i compose an `a -> a -> IO ()' with a couple of `IO a' neatly? (i'm looking for something like the applicative style i would do if the function wasn't already returning an IO value)
14:11:51 <chrisdone> oleo: read the link ^ it's löb
14:12:00 <Aetherspawn> oh, ahaha
14:12:10 <chrisdone> kqr: liftM2  or <$> and <*>?
14:12:11 <oleo> lol
14:12:26 <benmachine> kqr: use "join" on the standard applicative stuff
14:12:26 <Aetherspawn> I thought it was a problem with my mac or cabal or something, `cabal update` wasn't working. Turns out hackage is just down
14:12:28 <chrisdone> oh, not liftM
14:12:41 <fizruk> Eduard_Munteanu, unless it is possible to write instance (forall m. (Monad m, Monad (t m)) => MonadState t m) => MonadState (X f t) where ...
14:12:42 <geekosaur> Aetherspawn, mirror in the /topic
14:13:00 <Aetherspawn> i'll just wait for it to come back up soke.
14:13:02 <fizruk> Eduard_Munteanu, I suspect it's not though -_-
14:13:04 <bennofs> :t moeb liftA2
14:13:05 <lambdabot> Applicative f => f ((f b -> f c) -> b -> c) -> f b -> f c
14:13:12 <chrisdone> :t join (liftA2 (\x y -> return(x*y) (pure 1) (pure 2))
14:13:12 <benmachine> fizruk: that doesn't look syntax-sensible to me
14:13:13 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:13:19 <chrisdone> :t join (liftA2 (\x y -> return(x*y)) (pure 1) (pure 2))
14:13:21 <lambdabot> (Monad m, Num a, Applicative m) => m a
14:13:22 <monoidal> fizruk: indeed, that's not possible, => must be toplevel
14:13:37 <kqr> benmachine, yeah, that's what i wanted. thanks
14:14:01 <fizruk> monoidal, it could be (forall m. Monad m, Monad (t m), MonadState s (t m)) => MonadState (X f t)
14:14:13 <chrisdone> @let om f m = (m >>=) . flip f
14:14:15 <lambdabot>  Defined.
14:14:24 <chrisdone> :t om when
14:14:25 <lambdabot> Monad m => m Bool -> m () -> m ()
14:14:26 <fizruk> it's forall in the constraint that matters
14:14:49 <monoidal> fizruk: you can't have forall in constraints, either. (trivia: GHC had once a bug that allowed you to do it and it worked in some very special case, but that was a bug.)
14:15:00 <flippant> is haskell.org down for anyone else?
14:15:04 <bennofs> yes
14:15:06 <Aetherspawn> flippant: /topic
14:15:08 <bennofs> for everybody else
14:15:17 <fizruk> monoidal, yeah, I suspected that :(
14:15:24 <flippant> ah ty Aetherspawn
14:15:29 <monoidal> fizruk: also, it's more of "exists" rather than "forall"
14:15:45 <monoidal> fizruk: what you want is forall m. (Monad m, Monad (t m), ...) => MonadState (X f t)
14:15:56 <monoidal> fizruk: that's possible to express, but ambiguous in m
14:17:22 <fizruk> monoidal, hm... I think I needed forall, not exists?
14:17:24 <monoidal> fizruk: anyway the forall m. Monad m looks weird to me. Maybe you can replace that with the trivial monad and then cast?
14:17:44 <monoidal> fizruk: forall m. Monad m is unsatisfable. not every type is a monad.
14:18:10 <fizruk> monoidal, I could, but that would restrict the applicable area (e.g. I won't be able to use ContT)
14:18:28 <monoidal> fizruk: what about continuations then? (see "mother of all monads")
14:18:37 <milesph> exit
14:19:13 <fizruk> monoidal, what about them?
14:19:51 <monoidal> fizruk: continuations are a "universal" monad, in the sense you can cast any m a to a Cont (m a)
14:19:53 <fizruk> monoidal, i think I could perhaps use newtype M a = M (forall m. Monad m => m a) as an innermost monad in the stack...
14:20:18 <monoidal> fizruk: isn't forall m. Monad m => m a equivalent to just a?
14:20:33 <quchen> So after talking about loeb with chrisdone earlier, I decided to write down how I understand the function. Would be nice to hear some feedback! https://gist.github.com/quchen/d96aebe0c996ecc70341
14:20:43 <monoidal> fizruk: the only way you can construct such a value is by using return (and >>=, but that simplifies using monad laws)
14:20:55 <quchen> Short version: loeb is awesome and you should learn about it and I'm so excited :-D
14:21:44 <fizruk> monoidal, I think I'm getting confused x_x
14:22:06 <monoidal> fizruk: what I am saying is that newtype M a = M (forall m. Monad m => m a)  is equivalent to newtype M a = M a
14:22:28 <c_wraith> quchen: I think there's a better implementation of loeb..  one that ties the know better.
14:22:29 <fizruk> monoidal, I see what you're saying, I can't see why is that :)
14:22:48 <c_wraith> *ties the knot
14:22:50 <Eduard_Munteanu> Actually equivalent to M (Identity a) I guess.
14:23:23 <bennofs> c_wraith: you mean loeb x = let r = fmap ($ r) x ?
14:23:25 <quchen> c_wraith: Yes, I know
14:23:28 <bennofs> in r*
14:23:31 <Eduard_Munteanu> fizruk: you only have access to return and >>=
14:23:33 <quchen> c_wraith: But that one is even more obscure :-)
14:23:46 <chrisdone> c_wraith: you mean http://blog.sigfpe.com/2006/12/tying-knots-generically.html ?
14:23:48 <quchen> I should probably mention it anyway
14:23:52 <benmachine> monoidal: instantiate the m to Identity and see what it has inside it :)
14:23:56 <chrisdone> oh you jus tmean with better sharing
14:23:57 <chrisdone> sure
14:24:43 <Eduard_Munteanu> The question is whether you can rebase transformers onto arbitrary base monads.
14:24:55 <fizruk> monoidal, Eduard_Munteanu: ok I see that now, thanks!
14:25:25 <fizruk> Eduard_Munteanu, I can't rebase ContT Identity to ContT m
14:25:34 <c_wraith> quchen: it's only more obscure in the way fix f = let x = f x in x is more obscure than fix f = f (fix f) is.
14:25:44 <fizruk> Eduard_Munteanu, I hope by 'rebase' you mean 'hoist'
14:25:49 <quchen> c_wraith: Probably true. I changed the definition.
14:25:52 <c_wraith> ok, I'm not awake yet. too many typos.
14:25:56 <Eduard_Munteanu> Possibly.
14:26:10 <fizruk> :t Control.Monad.Morph.hoist
14:26:11 <lambdabot> (Monad m, Control.Monad.Morph.MFunctor t) => (forall a. m a -> n a) -> t m b -> t n b
14:27:17 <monoidal> fizruk: am I missing something? hoist (return . fromIdentity)
14:27:31 <fizruk> ContT is not an instance of MFunctor
14:28:02 <fizruk> monoidal, but yes, that does rebasing for MFunctors
14:28:03 <Eduard_Munteanu> fizruk: can you remind me why you want a polymorphic 'm'? I see you want MonadState for 'InnerT m'.
14:28:18 <edwardk> preflex: xseen jfischoff
14:28:18 <preflex>  jfischoff was last seen on freenode/#haskell 2 days, 22 hours, 53 minutes and 30 seconds ago, saying: Work the baby you know
14:28:28 <benzrf> preflex: version
14:28:29 <preflex>  7.134
14:28:39 <mauke> preflex: version
14:28:39 <preflex>  8.425
14:28:43 <benzrf> wot
14:28:47 <mauke> preflex: help version
14:28:48 <preflex>  version - print a random number
14:28:51 <benzrf> HA
14:29:00 <edwardk> @tell jfischoff you should read http://stat.columbia.edu/~jakulin/Int/jakulin05phd.pdf and we should talk. note the connection to maxent ;)
14:29:00 <lambdabot> Consider it noted.
14:29:07 <fizruk> Eduard_Munteanu, m is responsible for the interpretation, I may have different interpretations
14:29:21 <fizruk> Eduard_Munteanu, without InnerT i wouldn't need polymorphic m
14:29:35 <PTBD> Is it just me or ist haskell.org not reachable?
14:29:36 <monoidal> fizruk: what about using MonadCont?
14:29:45 <bennofs> it's not reachable
14:29:54 <PTBD> ok, thank you
14:29:54 <monoidal> PTBD: http://www.reddit.com/r/haskell/comments/1qrldv/haskellorg_servers_down_at_the_moment/
14:29:55 <bennofs> see also channel topic
14:29:56 <Eduard_Munteanu> fizruk: and you can't transform it the other way around, InnerT at the bottom?
14:31:00 <fizruk> Eduard_Munteanu, no, m is typically IO-related, InnerT is not
14:31:02 <Eduard_Munteanu> fizruk: because if you had OuterT over X over 'm' over Inner, you could incorporate 'm' into X or at least hide it.
14:31:06 <Eduard_Munteanu> Ah, ok.
14:31:58 <shiona_> is there any good intro to mutable arrays. I remember I solved some problem with them but now I can't even create one (STArray) since I can't get the types to match
14:32:38 <Eduard_Munteanu> fizruk: I suspect you want a MonadBase.
14:32:40 <hpc> shiona_: you need to learn the larger design of ST itself
14:32:50 <Eduard_Munteanu> @hoogle liftBase
14:32:50 <lambdabot> No results found
14:32:55 <shiona_> hpc: I guess that's true
14:33:01 <geekosaur> shiona_: at a guess, you are missing that it has to be created and used in the same block; you can't create it in ST and return it
14:33:08 <hpc> shiona_: ST is very roughly the "IO without IO" monad
14:33:16 <geekosaur> s/block/expression
14:33:33 <hpc> and it does some type-level magic (not actually magic) to keep you from moving mutable references out of ST
14:33:39 <Eduard_Munteanu> class (Applicative b, Applicative m, Monad b, Monad m) => MonadBase b m | m -> b where
14:33:47 <Eduard_Munteanu> liftBase :: b α -> m α
14:33:56 <fizruk> monoidal, i have OuterT (X f InnerT) a
14:34:05 <fizruk> monoidal, 1) OuterT and InnerT are user-supplied (so it's not conceptually ok to use MonadCont)
14:34:38 <fizruk> monoidal, 2) i want to hide innermost m, so I can't simply write (MonadCont (InnerT m)) => ...
14:34:49 <hpc> shiona_: the simple answer to your problem is, you can't runST on actions of type (ST s (STWhatever))
14:35:10 <hpc> or you can, but it'd be useless
14:35:24 <shiona_> hpc: ok, what is it I want to do?
14:35:37 <hpc> :t runST
14:35:38 <lambdabot> (forall s. ST s a) -> a
14:35:41 <hpc> oh good, that's in scope
14:36:32 <fizruk> Eduard_Munteanu, I guess I need MonadTrans and MonadState analogs for transformers to do what I want...
14:36:57 <Eduard_Munteanu> Hm, wait, MonadBase buys you nothing.
14:37:04 <hpc> > runST $ do {x <- newSTRef 5; modifySTRef x (+ 5); readSTRef x}
14:37:08 <lambdabot>   10
14:37:12 <hpc> shiona_: something like that
14:37:23 <hpc> :t runST $ do {x <- newSTRef 5; modifySTRef x (+ 5); readSTRef x}
14:37:24 <fizruk> e.g. class MonadStateT s t where get :: Monad m, Monad (t m) => t m s ...
14:37:25 <lambdabot> Num a => a
14:37:34 <Eduard_Munteanu> fizruk: if 'm' is a MonadState, you can easily lift that to the FreeT
14:37:45 <hpc> :t runST $ do {x <- newSTRef 5; modifySTRef x (+ 5); return x} -- the extra "s" in this type makes the returned STRef unusable
14:37:47 <lambdabot>     Couldn't match expected type `a' with actual type `STRef s Integer'
14:37:47 <lambdabot>       `a' is a rigid type variable bound by
14:37:47 <lambdabot>           the inferred type of it :: a at Top level
14:38:01 <Eduard_Munteanu> fizruk: however what is your state, is it polymorphic too?
14:38:03 <hpc> or makes it fail to typecheck
14:38:06 <hpc> so that's a thing
14:38:08 <fizruk> Eduard_Munteanu, yeah but the problem is that InnerT is the one that adds MonadState instance
14:38:20 <Eduard_Munteanu> Hm.
14:38:23 <FreeFull> Yay phantoms
14:38:35 <FreeFull> Type safety for free
14:38:42 <hpc> shiona_: anyhoo, hopefully that makes sense
14:38:52 <shiona_> hpc: maybe one day
14:39:01 <Eduard_Munteanu> fizruk: who picks that state, your X or the user?
14:39:18 <Eduard_Munteanu> fizruk: also do you actually use it or just pass it to OuterT?
14:40:12 <c_wraith> :r
14:40:17 <c_wraith> gah.  sorry folks.
14:40:18 <hpc> shiona_: just use it and get comfortable with what works and what doesn't
14:41:03 <fizruk> Eduard_Munteanu, OuterT and InnerT are supplied by user. Basically he uses them + free operations over (MonadFree f m)
14:42:04 <fizruk> Eduard_Munteanu, so it is the user who supplies the effects
14:42:22 <fizruk> Eduard_Munteanu, high-level effects
14:43:18 <Eduard_Munteanu> fizruk: in that case you could parametrize your X by the state type and derive the instances
14:43:48 <fizruk> Eduard_Munteanu, what if InnerT = ContT ?
14:44:30 <Eduard_Munteanu> fizruk: that doesn't normally provide a MonadState instance, but you could beat it into doing it :)
14:44:52 <Eduard_Munteanu> You said the user picked the state.
14:44:56 <fizruk> Eduard_Munteanu, :) I meant I (user) would need MonadCont for that
14:45:39 <Eduard_Munteanu> fizruk: you'd need MonadCont to track state? :/
14:45:48 <fizruk> Eduard_Munteanu, user supplies OuterT and InnerT and want to use them as if he had OuterT (InnerT Identity) a
14:46:03 <fizruk> Eduard_Munteanu, I guess I confused you
14:46:27 <fizruk> Eduard_Munteanu, I'll paste some code
14:47:05 <Eduard_Munteanu> fizruk: well, if there's an instance MonadState S (InnerT Identity), you can proxy that to OuterT, yes.
14:47:18 <Eduard_Munteanu> fizruk: also if there's an instance of MonadCont
14:47:34 <stephenmac7> Any way to download GHC now?
14:48:39 <Eduard_Munteanu> fizruk: and yes, it seems like your X would be parametrized by your InnerT
14:49:23 <Eduard_Munteanu> Since if InnerT -> s, you want X -> s, as functional dependencies wrt MonadState.
14:49:37 <Eduard_Munteanu> That should do for any Monad* class.
14:50:04 <Eduard_Munteanu> The user can do his own standalone deriving if you omit one such instance.
14:50:20 <Eduard_Munteanu> So you don't really need a type synonym.
14:51:45 <Eduard_Munteanu> Wrapping it up, it seems to look like   newtype X f t a = X (forall m. (Monad m) => FreeT f (t m) a), where t already contains the 's' or whatever other Monad* parameter.
14:56:56 <fizruk> Eduard_Munteanu, standalone deriving wouldn't work for that newtype, would it?
14:57:20 <fizruk> Eduard_Munteanu, I'm pasting the code shortly
14:58:36 <Eduard_Munteanu> fizruk: it might because 'm' isn't involved in the instances
14:59:12 <Eduard_Munteanu> It's 't' which provides them.
15:02:55 <fizruk> Eduard_Munteanu, deriving instance (MonadState s (t m)) => MonadState s (X f t)   does not compile
15:03:53 <Eduard_Munteanu> Hm.
15:05:05 <codh> how can I get a breadth first traversal of a tree, given a root : Int, and children : Int -> [Int]
15:05:37 <Eduard_Munteanu> codh: do you know how to make a depth-first traversal?
15:05:53 <codh> Eduard_Munteanu: not yet, let me think
15:06:09 <Eduard_Munteanu> codh: do that first, it's easier and should help you
15:06:38 <edwardk> codh: https://github.com/ekmett/succinct/blob/master/src/Succinct/Tree/LOUDS.hs#L42 you can adapt the code i use for louds there to produce breadth first traversals for you
15:06:55 <c_wraith> edwardk: you've got a small error error in part 3 of your CA article. The definition of rule with the signature (Enum m, Bounded m, Num n, Bits n) => Rule m n doesn't typecheck against that signature. It needs some Integral first argument, or something
15:07:06 <Tekmo> edwardk: I just wanted to tell you that I loved your succinct data structures talk
15:07:10 <Tekmo> edwardk: It totally blew my mind
15:07:13 <edwardk> Tekmo: thanks! =)
15:07:15 <ReinH> edwardk: oh hai
15:07:38 <edwardk> Tekmo: i gave a more advanced version of it the other day here in slovenia, but i wasn't about to record it =/
15:07:53 <edwardk> er able to
15:07:54 <Eduard_Munteanu> codh: if you write the DFS, getting a BFS is mostly a matter of changing the data structure from lists to queues
15:08:33 <codh> dfs :: [Int] -> (Int -> [Int]) -> [Int] dfs roots children = (dfs $ concatMap children roots) ++ roots
15:09:06 <deMac> would somebody please explain to me how the following code works
15:09:28 <deMac> encode cipher offset ch =   /  let    p=mod ((alphaPos ch) - offset)  26 /  in cipher!!p
15:09:47 <deMac> where cipher is a String
15:09:59 <Eduard_Munteanu> codh: you can use Seq from Data.Sequence as a queue... you cons to the front and remove from the back
15:10:08 <Tekmo> deMac: What is `alphaPos`?
15:10:14 <FireFly> gsnedders: (a bit late perhaps, but I happened to see your line while scrolling back a bit..) `join` is defined in Control.Monad; its use as  \f x -> f x x  comes from the instance of function as a Monad
15:10:23 <deMac> a function which returns alphabetical position as an int
15:10:32 <deMac> of a char
15:10:32 <codh> Eduard_Munteanu:  like the imperative code? ok, thanks.
15:11:02 <ReinH> deMac: use lpaste.net :)
15:11:06 <Eduard_Munteanu> codh: wait... do you understand how DFS uses a stack for traversal?
15:11:09 <edwardk> c_wraith: it should be rule :: (Enum m, Bounded m) => Word8 -> (m -> Bool) -> Bool
15:11:15 <deMac> okay
15:11:21 <edwardk> er
15:11:24 <edwardk> c_wraith: it should be rule :: (Enum m, Bounded m) => Word8 -> Rule m Bool
15:11:32 <Tekmo> deMac: Okay, so it's converting the character to a number and then subtracting an offset.  After that it takes the modulus 26 to make sure that the resulting number falls between 0 and 25
15:11:48 <codh> Eduard_Munteanu:  no, I'm using a recursive algorithm.
15:11:51 <c_wraith> edwardk: ok, so that's quite a bit off. :)
15:12:08 <deMac> http://lpaste.net/95793
15:12:20 <edwardk> the version of that that works with more general enumerable types isn't up yet =)
15:12:26 <Tekmo> deMac: Looking at the code, it seems like "cipher" is supposed to be an alphabet of characters since you index it into it using `p` and `p` can range from 0 to 25
15:12:28 <edwardk> but it was missing the first argument regardless
15:12:51 <c_wraith> edwardk: actually, I think you meant (Enum m, Bounded m, Num n, Bits n) => n -> Rule m Bool
15:12:58 <deMac> Tekmo: yes an alphabet sorry
15:13:00 <edwardk> aha
15:13:01 <edwardk> yes
15:13:14 <Tekmo> deMac: So yeah, that's what it does
15:13:16 <Eduard_Munteanu> codh: hm, you could make a special kind of lift: liftX :: (MonadTrans i, MonadTrans o) => (forall m. (Monad m) => o (i m) a) -> o (X f i) a
15:13:21 <Eduard_Munteanu> Er.
15:13:25 <Eduard_Munteanu> fi: hm, you could make a special kind of lift: liftX :: (MonadTrans i, MonadTrans o) => (forall m. (Monad m) => o (i m) a) -> o (X f i) a
15:13:28 <deMac> Tekmo: really don't understand how it works. say i've supplied the cipher as r1 which is say  "ESOVPZJAYQUIRHXLNFTGKDCMWB"
15:13:29 <Eduard_Munteanu> :(
15:13:32 <Eduard_Munteanu> fizruk: hm, you could make a special kind of lift: liftX :: (MonadTrans i, MonadTrans o) => (forall m. (Monad m) => o (i m) a) -> o (X f i) a
15:13:38 * Eduard_Munteanu is clumsy today
15:13:45 <deMac> and no offset and i wanted to encode 'B'
15:13:48 <edwardk> c_wraith: the next upgrade to that is to use somethng other than bits, so you can work through automata with more than 2 colors
15:13:51 <Tekmo> deMac: Let's consider the simple case where your cipher is the alphabet, i.e. `cipher = ['A'..'Z']
15:13:55 <edwardk> c_wraith++
15:13:59 <ReinH> deMac: do you understand how substitution ciphers work?
15:14:08 <deMac> ReinH: I do
15:14:19 <fizruk> Eduard_Munteanu, already tried that one :) the problem is with Monad* instances though
15:14:20 <Tekmo> deMac: So if your cipher is the alphabet, then your code basically just moves back and forth in the alphabet by the given offset
15:14:33 <deMac> Tekmo: yep
15:14:33 <int-e> gah, tab completion is evil. I should stop using it.
15:14:33 <Tekmo> i.e. if the offset was `1` then it would advance everything by one character
15:14:48 <int-e> @botsnack (sorry!)
15:14:53 <Tekmo> deMac: When you replace `cipher` with a different ordering of characters it adds another layer of obfuscation
15:14:54 <lambdabot> :)
15:15:02 <ReinH> deMac: cipher is the ciphertext alphabet
15:15:04 <Eduard_Munteanu> fizruk: hm, why? If you have a 'o (i m) a' that uses a MonadState, you can liftX that.
15:15:22 <Tekmo> deMac: Think of it as two separate encoding steps
15:15:28 <Tekmo> deMac: The first step rotates the letter in the alphabet
15:15:42 <benzrf> why cant i put ifs in the middle of do blocks
15:15:48 <Tekmo> deMac: The second step then uses the cipher text to do a substitution, where the substitution is based on the order of characters in `cipher`
15:15:55 <fizruk> Eduard_Munteanu, oh sorry, I totaly misread that
15:15:58 <nbl_> Hi everyone :)
15:15:59 <Tekmo> benzrf: You can, but the `then` and `else` have to be indented
15:16:03 <Tekmo> nbl_: Hi!
15:16:03 <benzrf> Tekmo: hmmm
15:16:04 <deMac> imagine I had the cipher "ESOVPZJAYQUIRHXLNFTGKDCMWB" and wanted to encode 'B', I'd expect it to return 'S' right if offset was 0. don't understand how the function does thtat though
15:16:10 <benzrf> Tekmo: this isn't parsing for some reason
15:16:11 <benzrf> some sec
15:16:34 <benzrf> http://bpaste.net/show/150336/
15:16:51 <absence> does the hackage mirror have documentation online?
15:16:52 <nbl_> (Sorry for my bad english) Could I ask a question about xmonad ?
15:16:56 <Tekmo> benzrf: What's the exact error?
15:16:57 <deMac> Tekmo: actually I follow now! was being stupid
15:17:04 <benzrf> Soko.hs:140:3: parse error on input `if'
15:17:05 <deMac> Tekmo: could you explain how the !! operator works here though?
15:17:09 <chrisdone> http://haddocks.fpcomplete.com/fp/7.4.2/20130922-179/
15:17:10 <benzrf> 140 is the first if
15:17:19 <Iceland_jack> deMac: It just indexes into a list
15:17:24 <Iceland_jack> > "hello" !! 3
15:17:33 <lambdabot>   'l'
15:17:38 <Tekmo> deMac: It's the "index" operator.  Given a list of elements and a number `n`, it gives you the `n`th element of the list (where we treat the first element as #0)
15:17:40 <deMac> ah got you
15:18:07 <Tekmo> benzrf: Which if is that?  The top or bottom one?
15:18:10 <benzrf> top one
15:18:12 <deMac> I understand now. thanks all for your help!
15:18:20 <Tekmo> deMac: Oh, I see the problem
15:18:25 <Tekmo> deMac: You forgot the `do`
15:18:30 <Tekmo> Oops
15:18:32 <Tekmo> I meant benzrf
15:18:34 <Eduard_Munteanu> fizruk: hm, wait, you can't really do that unless your user cooperates
15:18:35 <benzrf> thanks
15:18:42 <benzrf> ohhh
15:18:43 <benzrf> derp
15:18:44 <benzrf> -.-
15:18:44 <nbl_> how to set unfloat gimp 2.8 single window with xmonad sorry I'm a noob in Haskell :(
15:18:49 <benzrf> the if was originally the first thing
15:18:51 <benzrf> so i forgot to put the do bacj
15:18:52 <benzrf> *back
15:18:58 <Tekmo> benzrf: Yeah, it's an easy mistake
15:19:09 <chrisdone> nbl_: hold down your special xmonad key and then move it with your mouse
15:19:15 <fizruk> Eduard_Munteanu, unless what?
15:19:54 <Eduard_Munteanu> fizruk: you should really just parametrize X by 'm', because even if you hide it in X's type, you still can't abstract it because InnerT must transform something.
15:20:04 <geekosaur> chrisdone, I think they want to tile a floated window, not float a tiled window
15:20:05 <nbl_> chrisdone: I know I can do that manually with mod1mask + t but I would like that it automatically
15:20:06 <geekosaur> mod-t
15:20:09 <geekosaur> also there is #xmonad
15:20:22 <geekosaur> (and what you are probably looking for is a ManageHook)
15:20:23 <fizruk> Eduard_Munteanu, looks like that so far :)
15:20:43 <nbl_> geekosaur: I looked but I don't understand I'm a beginner
15:20:54 <fizruk> Eduard_Munteanu, perhaps I exposing m and having users to write extra `Monad m =>` is not that bad
15:21:02 <geekosaur> sadly I think the default manageHook still floats gimp because old versions needed it... not so much newer ones
15:21:30 <geekosaur> anyway if you join #xmonad there's plenty of people who can help you work out how to do this
15:21:47 <nbl_> geekosaur: ok thaks bro :)
15:21:49 <nbl_> ++
15:21:57 * chrisdone puts on another episode of mystery science theatre 3000
15:22:24 <c_wraith> edwardk: I'm struggling with something, a bit. I want a CA representation that works as an instance of Functor, but also restricts the rules so that they must work only locally. I'm at the point of understanding why my current representation can't be an instance of Functor, but I have no idea how to achieve both of those goals.
15:22:35 <Iceland_jack> chrisdone++
15:23:09 <edwardk> a Rule is an algebra not a functor
15:23:27 <edwardk> but its an algebra of a functor
15:24:43 <Eduard_Munteanu> fizruk: try a constraint synonym: type XStack o i f m x = (Monad m, MonadTrans o, MonadTrans i, x ~ o (X f i m)); userFunctionExample :: (XStack o i f m x) => a -> x a
15:24:55 <c_wraith> Well, I suspect a large part of the issue is my representation isn't the same as yours - and I'm starting to see why the difference is important.
15:25:40 <Tekmo> fizruk: What are you trying to do?
15:27:18 <Eduard_Munteanu> Well, o and i would be concrete in the example, really.
15:28:13 <fizruk> Tekmo, I'm trying to have a part of user computation based on a free monad to be used within an interpreter: Monad m => OuterT (FreeT f (InnerT m)) a
15:28:48 <fizruk> Tekmo, InnerT represents an exposed (to the interpreter) structure of the computation
15:29:16 <chrisdone> Iceland_jack: do you likSLEEEEEP
15:30:04 <fizruk> Tekmo, m should be polymorphic to enable arbitrary interpretations
15:31:00 <fizruk> Eduard_Munteanu, that looks nice :)
15:31:05 <Iceland_jack> I'm afraid I don't know that (presumably MST3K) reference chrisdone!
15:32:04 <chrisdone> Iceland_jack: ah =p it's from She Creature, the one with the hypnotist. every time the guy scope they'd interject now SLEEEEP hahaha
15:32:10 <Eduard_Munteanu> fizruk: it's probably best to do it on the user side, because they can fix 'i' and 'o' to the actual transformers.
15:32:23 <Tekmo> fizruk: What is the type of the computation after being interpreted?
15:32:29 * Iceland_jack has to watch more MST3K!
15:32:37 <zardoz``> are constructors functions?
15:32:47 <Eduard_Munteanu> zardoz``: data constructors yes
15:32:53 <fizruk> Tekmo, eventually: m a
15:32:56 <zardoz``> yes that is what I meant
15:33:02 <Iceland_jack> chrisdone: Have you looked at RiffTrax?
15:33:27 <zardoz``> is the only difference between constructors and functions the fact that you can pattern match on the former?
15:33:43 <fizruk> Tekmo, I'll paste some code shortly...
15:33:49 <Tekmo> fizruk: Ok
15:33:58 <Eduard_Munteanu> zardoz``: pretty much, and that they have some significance with respect to evaluation
15:34:19 <cable729> l
15:34:19 <Iceland_jack> zardoz``: Well you can create your own patterns with some proposed extensions but that's an OK way of thinking about it
15:34:22 <chrisdone> Iceland_jack: i saw a couple clips and giggled =p
15:34:28 <zardoz``> what significance with respect to evaluation?
15:34:32 <Tekmo> chrisdone: Today is a good example of why it's not good to consolidate so much functionality into haskell.org
15:34:33 <Eduard_Munteanu> zardoz``: namely that forcing a value with 'seq' forces it to the outermost constructor
15:34:37 <Iceland_jack> zardoz``: Look up weak-head normal form
15:34:40 <cable729> > :t (1,2,3,["",""],'')
15:34:48 <cable729> :t (1,2,3,["",""],'')
15:35:04 <cable729> @list
15:35:06 <lambdabot> What module?  Try @listmodules for some ideas.
15:35:11 <cable729> @help
15:35:15 <cable729> @:t 6
15:35:21 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
15:35:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:35:24 <Eduard_Munteanu> cable729: you can talk to lambdabot privately too
15:35:36 <Tekmo> (1,2,3,["",""],'') :: (Num a, Num b, Num c) => (a, b, c, [String],Char)
15:35:43 <cable729> Eduard: how? /w or something?
15:35:45 <Tekmo> Actually, I think it is an error
15:35:45 <bss03> Alternative URLs for haddock documentation?  I'm not sure of the syntax for documenting module exports.
15:35:56 <Tekmo> '' is invalid Haskell
15:36:08 <Eduard_Munteanu> cable729: /query lambdabot
15:36:21 <bss03> Alternative URL for Haskell 2010 report?  I'm using a syntax I think is correct but GHC complains about for module re-exports.
15:36:32 <FreeFull> @t id
15:36:44 <FreeFull> I think lambdabot doesn't do haskell right now
15:36:52 <cable729> huh
15:37:24 <Eduard_Munteanu> bss03: try getting it from Google's cache
15:37:34 <cable729> well in GHCI, the type of (1,2,3,["",""],'') is (Integer, Integer, [[Char]], Char). I need the Integers to be Ints though
15:37:57 <Tekmo> cable729: Give them a type annotation
15:37:57 <FreeFull> cable729: That's type defaulting, probably due to monomorphism restriction
15:38:08 <Tekmo> cable729: (1::Int,2::Int,3::Int,...
15:38:15 <Cale> cable729: numeric literals are actually polymorphic, but GHCi defaults things aggressively
15:38:17 <cable729> oh
15:38:32 <Tekmo> cable729: Usually Haskell will figure out what they should be when you actually try to use them
15:38:44 <cable729> can I cast the tuple afterwards?
15:38:44 <Cale> (because you usually want to be able to print the numbers, so picking a specific type is important)
15:38:51 <FreeFull> You could do :set -XNoMonomorphismRestriction  and make a new binding for the tuple
15:38:54 <chrisdone> bss03: https://www.fpcomplete.com/business/resources/documentation/
15:38:57 <Cale> cable729: You could give the tuple a type which is polymorphic, like:
15:39:09 <Cale> (Num a) => (a, a, a, [String], Char)
15:39:31 <Cale> and then use it at different types
15:40:05 <Cale> but note that any computation done to compute the tuple will be redone at each point that it's used if you give it that type (because it's secretly a function of the Num dictionary then)
15:40:22 <bss03> chrisdone: Hrm, I don't see either of the things I'm looking for at that site.
15:40:38 <bss03> shrisdone: Although, it's nice to know that site is there for package docs, when I need them.
15:41:29 <Tekmo> I have a question: Is there any way to access cabal file flags through CPP?
15:41:50 <bss03> Eduard: Haddock manual is not cached by google right now.  The "Cached" link is giving 404.
15:42:05 <donri> Tekmo: if flag()  cpp-options: -DFLAG
15:42:37 <benzrf> what libs do binaries from ghc require?
15:42:45 <Tekmo> donri: Thank you!
15:43:02 <Eduard_Munteanu> bss03: the Haskell2010 page is cached, for me.
15:43:52 <bss03> Eduard: Yeah, I see the ToC, but none of those links work. :(
15:43:59 <int-e> :t id
15:44:00 <lambdabot> a -> a
15:44:22 <Eduard_Munteanu> bss03: hm, they won't work... but maybe you can search for the link target and look that up in the cache
15:44:49 <bss03> yeah, inurl: google-fu helps here, too.
15:44:59 <bss03> inurl: haskellch5, e.g.
15:45:03 <benzrf> what do hi files do?
15:45:11 <Eduard_Munteanu> bss03: I googled for one of the links and it works
15:45:20 <lpaste> fizruk pasted “hacking FreeT” at http://lpaste.net/95796
15:45:31 <fizruk> Eduard_Munteanu, Tekmo: ^
15:46:22 <chrisdone> benzrf: they contain the interface that the module represents, its exports, their types, stuff like that
15:46:35 <benzrf> ok
15:46:42 <benzrf> also i cannot exec the output of my ghc
15:47:03 <chrisdone> i see
15:47:27 <benzrf> bash: ./Soko.o: cannot execute binary file
15:47:43 <Tekmo> fizruk: So what's the part you are trying to figure out?
15:48:08 <geekosaur> why are you running an object file?
15:48:28 <benzrf> geekosaur: ...it's what ghc made
15:48:29 <benzrf> >.>
15:48:30 <FireFly> benzrf: I think you're supposed to link object files first, or compile with some flag to get a nice ELF binary
15:48:34 <benzrf> I know nothing about compilation
15:48:35 <benzrf> :I
15:48:42 <benzrf> i almost always interpret my progs
15:49:11 <bss03> benzrf: You have main::IO () in module Main?
15:49:12 <Tekmo> benzrf: If you have a `main` function then `ghc` will produce an executable
15:49:28 <bss03> benzrf: ghc --make Main
15:49:30 <fizruk> Tekmo, I think I want to get rid of `m` in User part, because it will always be "forall m. Monad m =>"
15:49:30 <benzrf> bss03: well, i can runhaskell it
15:49:37 <benzrf> bss03: wait
15:49:45 <bss03> benzrf: Should generate a Main (or Main.exe) in the current directory.
15:49:49 <benzrf> should 'Main' be verbatim?
15:49:51 <Tekmo> You don't need --make
15:50:16 <benzrf> i'm trying just 'ghc <file>'
15:50:16 <geekosaur> yes
15:50:18 <geekosaur> otherwise you're making a library module, which is a  .o and .hi and not executable
15:50:20 <benzrf> it makes hi and o
15:50:24 <Tekmo> fizruk: One trick you can do is make it `Identity`
15:50:27 <benzrf> how do i make a binary?
15:50:35 <fizruk> Tekmo, yeah, I tried that
15:50:45 <benzrf> and does it require any special libs besides standard libc?
15:50:45 <geekosaur> module Main where ... main = ...
15:50:45 <Tekmo> fizruk: Then when you want to change it back later you can use `hoist` from the `mmorph` package to fix to be general again
15:50:52 <bss03> Tekmo: --make is default now?  Or at least, compiling imported modules as needed is default?
15:50:52 <geekosaur> ghc should handle library dependencies itself
15:50:58 <Tekmo> bss03: Yes
15:51:03 <benmachine> bss03: --make is default
15:51:10 <Tekmo> fizruk: First you define this function
15:51:12 <fizruk> Tekmo, that's pretty nice until inner monad becomes ContT or something that is not MFunctor
15:51:28 <Tekmo> fizruk: But in this case it's not
15:51:33 <lpaste> benzrf pasted “sokoban complete” at http://lpaste.net/95797
15:51:44 <Tekmo> fizruk: Your monad stack implements `MFunctor` all the way down
15:51:55 <bss03> benzrf: There's advanced falgs for having the entry point not be Main.main, but by default your program entry point does need to have that name.
15:51:58 <Eduard_Munteanu> I wonder if you can make a   data Shady a = Shady (forall m. (Monad m) => m a)
15:51:59 <benzrf> wtf?
15:52:01 <fizruk> Tekmo, it's an example: ReaderT and StateT are supplied by user and can be anything
15:52:09 <geekosaur> benzrf: as you asked and I confirmed but you perhaps dod not see, it *must* be module Main
15:52:11 <lpaste> benzrf pasted “sokoban complete” at http://lpaste.net/95798
15:52:14 <Tekmo> fizruk: Oh, you want them to have their own monad transformer stack
15:52:15 <geekosaur> you created a library module
15:52:17 <benzrf> ah
15:52:22 <Eduard_Munteanu> (can be a newtype)
15:52:24 <benzrf> geekosaur: oh
15:52:33 <benzrf> geekosaur: it will not compile properly otherwise?
15:52:46 <geekosaur> there is -main-is but you should not do that without very good reason
15:52:59 <bss03> ++geekosaur
15:53:10 <fizruk> Eduard_Munteanu, it has been previously mentioned and you said that's Identity ?
15:53:18 <Eduard_Munteanu> Do you increment people before evaluating them, bss03? :P
15:53:33 <geekosaur> it's lazy, how can you tell? :p
15:53:38 <Eduard_Munteanu> fizruk: er... I miswrote.
15:53:41 <bss03> Eduard: I don't want to allocate a tempory copy of them!
15:53:42 <edwardk> Tekmo: if you liked my wavelet tree talk, you may want to go through http://www.dcc.uchile.cl/~gnavarro/ps/cpm12.pdf and dig up the uses of wavelet trees for full text indexing. they can be useful for BLAS/alignment-like queries, which iirc are more up your alley than mine these days
15:53:53 <Eduard_Munteanu> fizruk: data Shady a = forall m. Shady (m a)
15:54:06 <Tekmo> edwardk: I work on structural data, which is more like a graph
15:54:11 <fizruk> Eduard_Munteanu, you mean existential?
15:54:27 <edwardk> Tekmo: fair nuff. then it won't do you much good. there are succinct encodings of planar graphs, but not general ones
15:55:10 <fizruk> Eduard_Munteanu, then again I won't have flexibility in interpreter'm `m`
15:55:15 <Tekmo> edwardk: However, I'm making a library for handling the text file formats for these things and it is perfect for that
15:55:35 <Eduard_Munteanu> fizruk: no, I was correct the first time... yes, it is Identity but not if transformed and later instantiated.
15:56:14 <fizruk> Eduard_Munteanu, so I was correct back then too? :p
15:56:40 <edwardk> Tekmo: there are a half-dozen other succinct encodings i have linked in https://github.com/analytics/analytics/blob/master/notes/papers.md  -- if you decide you want to spend some time implementing some, i'd be happy to take patches ;)
15:56:51 <Eduard_Munteanu> fizruk: I think so. I think monoidal said it was Identity because it was looking like you weren't doing anything else with it.
15:57:23 <edwardk> the new repository is in github.com/ekmett/succinct -- it'll let you play with succinct data structures in haskell right now
15:57:32 <Tekmo> edwardk: I'm also a big fan of space-filling curves and entropy
15:57:50 <fizruk> Eduard_Munteanu, so you say `ContT r Shady a` can be instantiated to `ContT r m a` for any `m`?
15:58:38 <fizruk> Eduard_Munteanu, how do I write "magic :: Monad m => t Shady a -> t m a" ?
15:58:41 <edwardk> Tekmo: i'm currently working with Aleks Jakulin on trying to figure out if we can build a nice kikuchi-bayes/maxent minimal assumption model fitter. currently, as in, he just went to sleep =P
15:58:51 <Tekmo> edwardk: Ha
15:59:31 <Tekmo> edwardk: I am a huge fan of maximum entropy methods
15:59:37 <Eduard_Munteanu> fizruk: lift (return . unShady)
15:59:46 <Tekmo> edwardk: Speaking of which, have you read Edwin T. Jaynes' papers on the subject?
15:59:46 <edwardk> mostly because i want to see if i can't replace a lot of my code for dealing with correlation with code for dealing with mutual information and k-interaction
16:00:07 <edwardk> i've gone through some of jaynes, but as aleks has been showing me, not enough. ;)
16:00:15 <Tekmo> He's a genius
16:00:15 <Eduard_Munteanu> :t lift (return . ?f)
16:00:19 <lambdabot> (Monad m, ?f::a -> b, MonadTrans t) => t ((->) a) (m b)
16:00:24 <Eduard_Munteanu> Gr.
16:00:49 <Tekmo> edwardk: He basically show how many deep results are a consequence of maximum entropy
16:01:01 <fizruk> :t Contro.Monad.Morph.hoist (return . ?f)
16:01:02 <edwardk> you may find http://stat.columbia.edu/~jakulin/Int/jakulin05phd.pdf interesting if you like jaynes and maximum entropy
16:01:03 <lambdabot> Couldn't find qualified module.
16:01:09 <fizruk> :t Control.Monad.Morph.hoist (return . ?f)
16:01:10 <lambdabot>     Could not deduce (?f::m a -> a)
16:01:11 <lambdabot>       arising from a use of implicit parameter `?f'
16:01:11 <lambdabot>     from the context (Monad m, Monad n, Control.Monad.Morph.MFunctor t)
16:01:26 <fizruk> :t Control.Monad.Morph.hoist (return . runIdentity)
16:01:27 <lambdabot> (Monad n, Control.Monad.Morph.MFunctor t) => t Identity b -> t n b
16:01:34 <c_wraith> @pl \x f y -> f x y
16:01:35 <lambdabot> flip id
16:01:38 <Eduard_Munteanu> Wait, let's backtrack a bit.
16:01:40 <Tekmo> edwardk: I've always wanted to know: what is the state of the art for actually computing maximum entropy?  I'm familiar with analytical approaches, but not efficient numerical ones
16:01:46 <c_wraith> flip id.  I like that.
16:02:10 <edwardk> that is kind of the problem with maxent, and why aleks' work switched to what he called 'kikuchi-bayes'
16:02:55 <edwardk> i was working with jfischoff on trying to do reasonably efficient maxent at one point, but we got stalled
16:03:31 <Eduard_Munteanu> fizruk: when you say instantiate 'm', what do you expect to be able to do once you pick say, IO?
16:03:39 <Tekmo> The other problem with maximum entropy is that it's not always easy to figure out what the observed states should be
16:04:00 <gsnedders> FireFly: (even later) yeah, I eventually found it once I found somewhere else to look with Hoogle being down :)
16:04:16 <edwardk> exactly. maxent assumes everything you've been told is ground truth
16:04:40 <Eduard_Munteanu> fizruk: it seems to me you can't really do anything more with InnerT IO than you could have done if you picked m as IO from the beginning.
16:04:59 <edwardk> its a good general purpose model builder though. you can use it as a building block in other pipelines
16:06:20 <Eduard_Munteanu> fizruk: mostly because monad transformers don't really do different things depending on the base monad
16:06:32 <fizruk> Eduard_Munteanu, if don't choose IO from the beginning I can use both IO and, say Reader [String]  (so env would be a list of supplies for Input)
16:07:07 <eacameron> any idea when haskell.org will be back in town?
16:08:27 <fizruk> Eduard_Munteanu, you might say that I could've used Inner monad instead of (InnerT m)
16:08:34 <Eduard_Munteanu> fizruk: but Reader isn't accessible to InnerT, so it only matters to X?
16:10:08 <fizruk> Eduard_Munteanu, take a look at hackLangF function: this is how interpreter uses free monad, InnerT and `m` at the same time
16:10:17 <int-e> ok, I'll move lambdabot to another host with more memory, the current situation is too bad :)
16:11:39 <codh> when you profiling a program, what's the MUT time means?
16:12:06 <int-e> "mutator" = actual program
16:12:18 <codh> int-e: thanks
16:12:30 <fizruk> Eduard_Munteanu, oth `user` function makes the use of OuterT, free monad and InnerT
16:12:44 <int-e> codh: (this is garbage collector's lingo; there's the mutator that modifies data, and the garbage collector that clean up after the mutator)
16:13:04 <Iceland_jack> int-e: Should be called ‘slob’ ;)
16:13:32 <Eduard_Munteanu> fizruk: ok, but there you pick IO and do IO-specific stuff.  You can't reinstantiate that to a different monad, and at the point you instantiated it, you pretty much had an Identity monad.
16:13:34 <fizruk> Eduard_Munteanu, note that free monad and InnerT are visible to both, but free monad interface is conceptually supplied by interpreter while InnerT is supplied by user (sort of)
16:14:34 <fizruk> Eduard_Munteanu, I may have multiple users and interpreters I want them to be compatible with each other based on f and InnerT only
16:17:13 <fizruk> Eduard_Munteanu, is it's either I'm particularly bad at explanations or the problem is not particularly obvious :)
16:17:58 <Eduard_Munteanu> fizruk: ah no, I just wonder if you can do something with 'm' in there you can't already do if you pretend to have m = Identity and then hoisting it.
16:19:12 <fizruk> Eduard_Munteanu, I can hoist over MFunctors only and that excludes ContT (or forces users to write MFunctor instances)
16:19:40 <fizruk> Eduard_Munteanu, actually I used MFunctors till I found that out :)
16:23:25 <Eduard_Munteanu> fizruk: when you instantiate 'm' to IO under ContT, you get a 'FreeT f (ContT r IO) a', but that's a trivial IO computation right after instantiation, right?
16:23:50 <Eduard_Munteanu> After all, it could have only come from 'return' and (>>=).
16:24:44 <fizruk> Eduard_Munteanu, right but after instantiation I can do interesting things
16:24:59 <fizruk> Eduard_Munteanu, such as `transform hackLangF`
16:25:10 <Eduard_Munteanu> fizruk: oh, ok.
16:26:14 <fizruk> Eduard_Munteanu, actually that `transform hack` is the greatest point. without that I'd had simply `OuterT (Free f) a` and no worries :)
16:27:07 <NemesisD> anyone familiar with pipes-network? i'm a bit confused if i need bidirectional pipes or not
16:27:08 <Eduard_Munteanu> fizruk: well in that case, you can just open Shady and work with it...
16:27:13 <Tekmo> I can help
16:27:25 <Tekmo> NemesisD: You probably don't need bidirectional pipes
16:27:45 <Tekmo> NemesisD: Renzo only included them if you wanted to request chunks of varying sizes
16:27:55 <Tekmo> NemesisD: The overwhelming use case is to request constant-sized chunks
16:28:00 <fizruk> Eduard_Munteanu, by "open" you mean write Monad m => OuterT (FreeT f (InnerT m)) a ?
16:28:09 <NemesisD> Tekmo: oh hey! yeah this is my first day with pipes. so i'm trying to communicated over a unix socket in request/response fashion. is this a different type of bidirection than it means?
16:29:00 <NemesisD> the pipe i'm communicating over is pretty much 1 and done. you send commands and a newline, it sends you a response which you want to read in entirety, then the other side closes its side of the unix socket
16:29:39 <Tekmo> NemesisD: Don't use bidirectional pipes for that
16:30:02 <Tekmo> NemesisD: For sockets and other things that permit concurrent reading and writing you want to fork one thread for reading and another for writing
16:30:08 <Tekmo> NemesisD: Then you use one pipeline per thread
16:30:21 <Tekmo> NemesisD: You can communicate between the two pipelines using STM or higher-level primitives from pipes-concurrency
16:30:49 <NemesisD> Tekmo: hmm, there's no real concurrency here. the communication seems sequential as i need to send my whole message then receive the whole respones after
16:31:00 <Tekmo> NemesisD: In that case you can model it using a Client or Server
16:31:38 <Tekmo> NemesisD: I usually try to not assume sequence for these things, but if you want to then the bidirectional model will work
16:32:01 <Tekmo> Let's assume that your request argument is of type `Req` and your response is of type `Resp`
16:32:08 <quchen> chrisdone: http://ideone.com/9oS71H
16:32:16 <NemesisD> Tekmo: ah ok. in the non-pipes sense (i don't know about pipes clients) it is a client. it makes requests only, the other side speaks when spoken to
16:32:24 <Eduard_Munteanu> fizruk: say you have a 't Shady a', lift :: Shady a -> t Shady a. So if you have an action 'shadyIO :: Shady a -> Shady (IO a)', shadyIO (Shady io) = return io, you get   lift shadyIO :: t (Shady (IO a))
16:32:38 <Tekmo> NemesisD: Yeah, so your program would be a pipes `Client` and the socket would be a `Server`
16:32:41 <quchen> chrisdone: Sorry in advance for the retarded highlighting :-s
16:33:09 <Tekmo> NemesisD: Let's assume that the `Client` initiates interactions with a value of type `Req`
16:33:19 <Tekmo> NemesisD: and that the `Server` responds with values of type `Resp`
16:33:51 <fizruk> Eduard_Munteanu, type MonadX f t m x = (Monad m, x ~ FreeT f (t m))  makes things look nicer :)
16:33:51 <Tekmo> NemesisD: Then the type of the `Client` would be: client :: () -> Client Req Resp m r
16:33:56 <Tekmo> NemesisD: The initial `()` is optional
16:34:12 <Tekmo> NemesisD: If you include it, then you use `>+>` to connect them
16:34:20 <Tekmo> NemesisD: If you omit it, then you use `+>>` to connect them
16:34:28 <Eduard_Munteanu> Wait, lemme rethink this.
16:34:44 <Tekmo> NemesisD: The type of the `Server` would be: server :: Req -> Server Req Resp m r
16:34:52 <Tekmo> NemesisD: The `Req` argument is mandatory
16:35:00 <Tekmo> NemesisD: The server is passive, so it cannot begin until it receives a `Req`
16:35:28 <fizruk> Eduard_Munteanu, I guess Shady *is* Identity, no matter how it is used
16:35:42 <Tekmo> NemesisD: So, now let's say that you have two `IO` actions, one of which processes the `Req` and the other which generates a `Resp`
16:35:56 <Tekmo> NemesisD: Or even simpler, I'll just assume it is a single action
16:36:06 <Tekmo> NemesisD: process :: Req -> IO Resp
16:36:23 <Tekmo> NemesisD: Then the verbose way to write the server would be:
16:36:47 <Tekmo> NemesisD: server req = lift (process req) >>= \resp -> respond req >>= server
16:37:17 <Tekmo> NemesisD: However, you can simplify that in two steps
16:37:24 <quchen> Is there a package with Vector's API that uses Ix for indexing? Array is awful to use, Vector is only 1D
16:37:45 <Tekmo> NemesisD: First, you can write it as: server = lift . process \>\ pull
16:38:18 <Tekmo> NemesisD: The reason that works is because `f \>\ g` replaces all requests in `g` with `f`
16:38:32 <Tekmo> NemesisD: And `pull` is just `request >=> respond >=> pull`
16:38:52 <Tekmo> NemesisD: So substitution gives: `lift . process >=> respond >=> lift . proces >=> ...`
16:38:54 <chrisdone> quchen: fun =)
16:38:54 <Eduard_Munteanu> fizruk: hm, MonadBase gives you liftBase :: Shady a -> FreeT f (InnerT Shady) a, but you can't just make any Shady, it has to be polymorphic.
16:39:02 <Tekmo> NemesisD: However, even that is not necessary
16:39:15 <quchen> chrisdone: Not as cool as I'd like, but better than nothing
16:39:18 <Tekmo> NemesisD: You can actually omit the server entirely and just directly substitute `lift . process` into the client
16:39:23 <Eduard_Munteanu> fizruk: right, I don't think this works.
16:39:28 <NemesisD> Tekmo: this sounds very familiar to a similar shortcut you discussed in the Pipes.Tutorial
16:39:31 <Tekmo> NemesisD: Yes
16:39:35 <Tekmo> NemesisD: It's the exact same concept
16:39:36 <chrisdone> quchen: in fact there's a "real" use of loeb somewhere… hold up
16:39:50 <Tekmo> NemesisD: So assuming that your client's type is :: () -> Client Req Resp IO ()
16:39:58 <chrisdone> https://github.com/wcauchois/headsheet/blob/master/Main.hs#L61
16:39:59 <quchen> Wait, you mean one for a problem that wasn't designed for using loeb?
16:40:08 <quchen> This function keeps surprising me.
16:40:11 <Tekmo> NemesisD: Then you can substitute all `request`s in the `Client` with `lift . process` by just writing: lift . process \>\ client
16:40:15 <Eduard_Munteanu> fizruk: the problem is 'm' is quantified in a too narrow scope, I think you *have* to thread it around, just like you can't really hide ST's 's' no matter how.
16:40:19 <Tekmo> NemesisD: That will have this type: () -> Effect IO ()
16:40:44 <chrisdone> quchen: well, a spreadsheet. but yeah, in a real program. mgsloan sent it me =)
16:40:55 <Tekmo> NemesisD: So in other words, you use `request to create a hole wherever you want to abstract away the behavior that may change
16:40:55 <fizruk> Eduard_Munteanu, yeah, I think now I should just export MonadX constraint
16:41:05 <Tekmo> NemesisD: Whenever you want to fill that hole, you just use `\>\`
16:41:19 <Tekmo> NemesisD: That code just says "replace all client `request`s with `lift . process`"
16:41:35 <Tekmo> NemesisD: So if your client wrote: "resp <- request req"
16:41:45 <Tekmo> NemesisD: It would now become: "resp <- (lift . process) req"
16:42:57 <NemesisD> Tekmo: hmm ok. i'll have to get a bit deeper into the code to see how this plays out, thanks
16:43:03 <Tekmo> NemesisD: You're welcome
16:44:14 <NemesisD> i'm trying to figure out how process :: Req -> IO Resp would behave, because really it will just be serializing the request into a bytestring and then throwing it down the pipe somehow (via request?) then reading off the pipe until the connection closes, parsing that into a Resp
16:44:53 <Tekmo> NemesisD: What I meant is that `process` might be talking directly with the socket
16:45:04 <Tekmo> NemesisD: Process is just one possible server that can satisfy your client
16:45:53 <Tekmo> NemesisD: If you want to serialiez the request and then deserialize the response, then you want a Proxy
16:46:16 <Tekmo> NemesisD: Actually, you can get away with something simpler than a `Proxy`
16:46:46 <Tekmo> So again, let's assume that you have a serialization function of type `Req -> ByteString`
16:46:46 <Tekmo> You also have a deserialization function of type `ByteString -> Resp`
16:47:02 <sshilovsky> hi guys. why is haskell.org down?
16:47:12 <sclv> we're working on it
16:47:17 <NemesisD> shanse: http://www.reddit.com/r/haskell/comments/1qrldv/haskellorg_servers_down_at_the_moment/
16:47:20 <sclv> we've had problems in the past where it hangs
16:47:21 <Tekmo> NemesisD: Let's call those `serialize` and `deserialize` respectively
16:47:24 <sshilovsky> how long is it down for?
16:47:28 <sclv> and in the past we just sent in a reboot request
16:47:38 <sclv> this time we decided to ask our host to investigate
16:47:43 <Tekmo> NemesisD: You can then convert your client into one that understands `ByteString` instead of `Req`s and `Resp`s like this:
16:47:48 <sclv> and see if there's something systemic to fix
16:47:58 <sclv> so it might be a while
16:48:03 <enthropy> sclv: why couldn't they have done both?
16:48:09 <sclv> because if we send the reboot request
16:48:14 <sshilovsky> thanks
16:48:19 <sclv> then we can't get the host techs to look at the machine
16:48:22 <sclv> and see what's wrong with it
16:48:31 <sshilovsky> is http://hdiff.luite.com/ more stable?
16:48:34 <Tekmo> NemesisD: (\req -> fmap deserialize $ request (serialize req)) \>\ client
16:48:34 <sclv> because there's nothing in the logs that shows what the problem was
16:48:42 <sclv> well hdiff is up and hackage isn't :-)
16:48:47 <sclv> so its the right thing for the time being
16:48:47 <Tekmo> NemesisD: That will now have type: () -> Client ByteString ByteString IO ()
16:48:54 <sclv> eventually hackage will come back and then you should use that again
16:49:12 <Tekmo> NemesisD: If you want to convert that serializer/deserializer into its own self-contained `Proxy`, you would write:
16:49:29 <Tekmo> NemesisD: (\req -> fmap deserialize $ request (serialize req)) \>\ pull
16:49:45 <Tekmo> NemesisD: That would have type: Proxy ByteString ByteString Req Resp m r
16:49:52 <Tekmo> Oops, there should be an extra argument
16:50:01 <Tekmo> NemesisD: Req -> Proxy ByteString ByteString Req Resp m r
16:50:14 <Tekmo> NemesisD: That's now basically a 'decoder/encoder' proxy
16:51:10 <Tekmo> So whether or not you use a stand-alone decoder/encoder or you modify the `Client` directly, you end up with: () -> Client ByteString ByteString IO ()
16:51:24 <NemesisD> Tekmo: cool! i like the modularity of the parsing proxy. it is likely that Resp is going to be parameterized by a type variable in a typeclass
16:51:26 <Tekmo> NemesisD: All that needs is a socket of type: ByteString -> Server ByteString ByteString IO ()
16:51:42 <Tekmo> NemesisD: Again, let's say that you have a function that talks to the socket of type:
16:51:51 <Tekmo> NemesisD: sendAndRecv :: ByteString -> IO ByteString
16:51:53 <NemesisD> Tekmo: i'm thinking my request command set is going to be a big sum type, and resp will be like Deserializable a => Resp a type thing
16:52:02 <Tekmo> In other words, it sends a `ByteString` and waits to receive a `ByteString`
16:52:10 <Tekmo> Then you can build a server from that like this:
16:52:29 <Tekmo> lift . sendAndRecv \>\ pull :: ByteString -> Server ByteString ByteString m r
16:52:38 <Tekmo> Of course, you could just apply it directly to your `Client`, too
16:53:03 <Tekmo> lift . sendAndRecv \>\ clientThatUnderstandByteStrings :: () -> Effect IO ()
16:53:22 <Eduard_Munteanu> fizruk: this might do: data C :: Constraint -> * where C :: forall c. c => C c; type family UseC c :: Constraint; type instance UseC (C c) = c; type MonadX' i o f x = C (forall m. (x ~ o (FreeT f (i m)) a)); type MonadX i o f x = (UseC (MonadX' i o f x))
16:53:51 <Eduard_Munteanu> Can't make promises, but that sort of stuff sometimes worked for me to hide variables.
16:53:59 <Tekmo> NemesisD: Oh, there's one other thing that you might be interested in
16:54:03 <Tekmo> NemesisD: One second
16:54:19 <Tekmo> NemesisD: https://github.com/Gabriel439/pipes-web
16:54:23 <fizruk> Eduard_Munteanu, need some time to figure out what's it :)
16:54:28 <Tekmo> NemesisD: This is something I came up with to install and deploy pipes over networks
16:54:40 <Tekmo> NemesisD: It's technically not using HTTP, so I should change the name to something else
16:55:00 <Tekmo> NemesisD: But you might find it useful for assembling pipelines over multiple hosts
16:55:14 <Eduard_Munteanu> fizruk: I wrap a forall + constraint in an impredicative type then unpack it, because you can't place foralls in constraints normally
16:55:31 <fizruk> Eduard_Munteanu, can you actually put a "forall m" there?
16:55:44 <Tekmo> NemesisD: It only works for unidirectional pipes right now, but I can easily generalize it to bidirectional ones
16:56:09 <Eduard_Munteanu> fizruk: not exactly sure if it's forbidden by GHC's mishandling of impredicative * -> *
16:56:24 <NemesisD> Tekmo: Tekmo i have a feeling like my case is really simple, i'm writing a library to communicate over haproxy's stats unix domain socket
16:56:31 <Eduard_Munteanu> fizruk: yeah, it should work for normal variables at least.
16:57:15 <Tekmo> NemesisD: Oh yeah, pipes-web is probably overkill for that :)
16:57:28 <NemesisD> Tekmo: it sounds like some of your suggestions at the core have me calling sendAll and such instead of letting network-pipes do that. am i misreading?
16:57:39 <fizruk> Eduard_Munteanu, ok, I'm gonna try that
16:57:54 <Eduard_Munteanu> fizruk: I should try it too, I haven't. :)
16:57:56 <Tekmo> NemesisD: What is the format of the messages?
16:58:29 <Eduard_Munteanu> Mostly because it needs a very long list of pragmas to get going. :)
16:58:42 <Tekmo> NemesisD: Do you have a binary parser for your message already?
16:59:25 <NemesisD> Tekmo: they are simple string commands that can be pipelined by interspersing semicolons. your message is done when you send a newline, response responds to each in order, separated with a blank line and closes the conn
16:59:29 <NemesisD> Tekmo: not quite yet
16:59:59 <NemesisD> i figured i'd probably not worry about pipelining to start
17:00:18 <Tekmo> NemesisD: What do you want to do with the messages when you receive them?
17:00:52 <deech> I have a C function that takes a null pointer and changes it to point to a function. On the Haskell side do I just pass a nullPtr and `peek' it?
17:01:27 <ion> That doesn’t sound right. I bet it takes a pointer *to* a value that may be null and replaces that value with a pointer.
17:01:27 <fizruk> Eduard_Munteanu, not is scope "Constraint" where do I get it from?
17:01:29 <NemesisD> Tekmo: so my req is a sum type like Req = Cmd1 Int | Cmd2 Double... , i figure i'll have functions like cmd1 :: Int -> IO Cmd1Response
17:01:36 <Eduard_Munteanu> fizruk: GHC.Prim IIRC
17:01:57 <NemesisD> Tekmo: obviously with a type that handles errors etc, but i'll be pairing each element in the request sum type with a parsed response type
17:02:13 <NemesisD> and that parsing will probably be done via typeclass
17:02:17 <ion> So allocate a function poitner sized value, pass that to the function and peek.
17:02:40 <Tekmo> NemesisD: Okay, let me set up a skeleton program for you.  I may need to ask a few more questions
17:03:18 <deech> ion: Great. Thanks!
17:03:31 <NemesisD> Tekmo: awesome! thank you! i've got quite a lot of learning to do about pipes but getting a good example of the structure would be really helpful
17:03:41 <Tekmo> NemesisD: No problem at all :)
17:03:56 <fizruk> Eduard_Munteanu, tons of errors :\ can you check that locally?
17:04:30 <Eduard_Munteanu> Yeah, I'm trying it myself now, just a min.
17:04:32 <Tekmo> NemesisD: What is your `cmd1` function doing?
17:05:23 <NemesisD> Tekmo: basically cmd1 n = sendDownThePipe (Cmd1 n), preferring eventually to make it point free ;)
17:05:48 <frx> why doesn't this fail?
17:05:53 <frx> > let xs = [1,2,undefined] in head $! xs
17:05:55 <lambdabot>   1
17:06:01 <Tekmo> NemesisD: You mean it would write the request ot the socket and then read the response?
17:06:56 <NemesisD> Tekmo: yeah. i haven't decided how the connection management will be like though
17:08:04 <NemesisD> the simplest thing right now would be to acquire the socket and close it on each function in the api. it may make sense later to create a monadic interface that can figure out how to pipeline sequential requests together and parse out their responses, but i'd prefer to get something simple working than reach for the moon
17:08:16 <fizruk> frx, $! evaluates argument to WHNF ?
17:08:18 <pavonia> frx: $! doesn't evaluate the full list but only to weak-head normal form, IIRC
17:08:32 <fizruk> frx, so you get only first constructor
17:08:48 <fizruk> :t deepseq
17:08:50 <lambdabot> Not in scope: `deepseq'
17:08:57 <Tekmo> NemesisD: Does the response type change with each different type of request?
17:09:00 <fizruk> @hoogle deepseq
17:09:02 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
17:09:02 <lambdabot> package deepseq
17:09:02 <lambdabot> package deepseq-generics
17:09:19 <fizruk> :t Control.DeepSeq.deepseq
17:09:20 <lambdabot> Control.DeepSeq.NFData a => a -> b -> b
17:09:30 <Eduard_Munteanu> fizruk: ok, it works as long as I don't need any constraints for my makeshift 'm'.
17:09:35 <frx> got it thanks.
17:09:44 <Eduard_Munteanu> fizruk: I should try your types
17:09:45 <frx> this did work: let xs = [[1],[1,2,undefined]] in deepseq xs (head xs)
17:09:47 <NemesisD> Tekmo: yeah, for the most part each element in the request sum type will have its own distinct response type
17:10:06 <fizruk> > let xs = [1, 2, undefined] in Control.DeepSeq.deepseq xs (head xs)
17:10:08 <lambdabot>   Not in scope: `Control.DeepSeq.deepseq'
17:10:15 <fizruk> oh you
17:10:19 <NemesisD> Tekmo: there may be a few that use generic types like Text or something but i'm going to do my best to parse the responses into more rich data types
17:10:34 <fizruk> Eduard_Munteanu, is it bad when you add Monad m => ?
17:10:51 <fizruk> Eduard_Munteanu, or rather (Monad m, ...)
17:10:51 <Tekmo> NemesisD: So my recommendation is that you don't use pipes
17:11:03 <Tekmo> NemesisD: The ideal interface for this sort of thing is a different type of free monad
17:11:07 <frx> I am curious how deepseq is implemented to work with any list, regardless of how deeply nested it is. but neither @src nor haskell.org work
17:11:09 <NemesisD> oh noes!
17:11:22 <FreeFull> How do you look at lambdabot's L.hs again?
17:11:28 <Tekmo> NemesisD: Have you read this before? http://topsy.com/www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
17:11:28 <benmachine> frx: type classes
17:11:40 <Tekmo> Oops, wrong link
17:11:57 <Tekmo> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
17:12:07 <frx> benmachine so there's a limit on how deeply nested the list can be?
17:12:14 <benmachine> frx: no
17:12:38 <NemesisD> Tekmo: i believe so. i've flamed out twice trying to solve problems with free monads. once with that tutorial and once with Andres (?) Loh's talk on free monads
17:12:38 <triliyn> instance Whatever a => Whatever [a]
17:12:51 <Tekmo> NemesisD: Let me give you a skeleton program to refer to
17:12:58 <Tekmo> NemesisD: Actually, before I do that
17:13:16 <benmachine> frx: instance DeepSeq a => DeepSeq [a] where deepSeq [] x = x; deepSeq (x:xs) y = x `deepSeq` xs `deepSeq` y
17:13:25 <Tekmo> NemesisD: Let me first ask what is the problem you have run up against so far when trying to implement this
17:13:55 <fizruk> Tekmo, btw nice posts you have over there! thank you for them :)
17:14:22 <Tekmo> fizruk: You're welcome! :)
17:14:28 <Tekmo> NemesisD: In other words, what was the reason you were even trying to use pipes in the first place?
17:14:30 <carter> Tekmo: thanks for the shout out btw :)
17:14:34 <NemesisD> Tekmo: it could be that the problem was out of grasp, both times i was trying to solve the problem of being able to intercept, record, and fake responses to HTTP requests for testing http clients
17:14:40 <Tekmo> carter: My pleasure! :)
17:14:51 <Tekmo> NemesisD: Okay, so you want to mock the server
17:14:52 <fizruk> Tekmo, it's not that simple to start with edward's posts on free monads :p
17:15:00 <Tekmo> NemesisD: Yeah, in this case you definitely want the free monad
17:15:01 <benmachine> frx: so the key is when deepSeq'ing a list [a] we use deepSeq for a, so if we have nested lists we recurse into the type
17:15:01 <frx> benmachine thanks
17:15:04 <Tekmo> NemesisD: Let me sketch it out for you
17:15:33 <frx> benmachine yeah I figured something like that was happening.. nice
17:15:40 <NemesisD> Tekmo: that's for a different issue, although it would probably be helpful here. i looked at pipes because i knew i had to send data in/out of the socket and do transforms on both sides and saw there was a network-pipes
17:16:02 <carter> @tell heatsink cool, look forward to hearing about it
17:16:02 <lambdabot> Consider it noted.
17:16:12 <carter> Tekmo: happily i'm actually making decent progress on the array api
17:16:21 <Tekmo> NemesisD: So where pipes will help is dealing with parsing data from the socket and dealing with leftovers as you parse different messages
17:16:26 <carter> though i'm making some simplifying tradeoffs for teh near term
17:16:40 <carter> instead of overoptimizing sans benchmarking data
17:17:15 <carter> huh
17:17:19 <carter> i just had a silly idea
17:17:20 <Tekmo> NemesisD: Let me sketch out the full solution, because it goes hand-in-hand with the free monad part, too
17:17:43 <NemesisD> Tekmo: yeah for pipelining its pretty nice: encode request types, intersperse ;s, on response: split lone newlines into messages and parse each
17:17:49 <NemesisD> Tekmo: ok. thanks!
17:18:15 <Tekmo> NemesisD: Basically my plan is to have your free monad compile to a pipes parser
17:18:18 <carter> Tekmo: crazy silly  idea for when people want perf and pipes turned to 11: a deep embedding variant that only allows static pipelines? could do some interesting scheduling with static pipelines
17:18:39 <Tekmo> carter: What do you mean by static pipelines?
17:18:42 <carter> ok
17:18:46 <carter> good question
17:18:54 <carter> well
17:19:17 <carter> pipes is in some sense a discrete event "frp-like"
17:19:33 <carter> if we're being handwavy
17:19:34 <Tekmo> Yes
17:19:34 <carter> right?
17:19:53 <zardoz``> does sequence run actions, or does it return an action that, when executed, will be ran?  which one is a more correct way of describing what it does?
17:20:06 <zardoz``> when executed, will run those actions*
17:20:07 <Tekmo> zardoz``: The latter is more correct
17:20:20 <Tekmo> zardoz``: In Haskell, the only thing that ever gets run is `main`
17:20:29 <carter> now, in FRP style libs, part of the power is you can have higher order switching on pipe segments and how they're composed / connected
17:20:37 <carter> rather than "static data flow graphs"
17:20:45 <benmachine> Tekmo: that's an odd way of putting it; main runs things
17:21:08 <carter> but this flexibility is also the source of how many perf problems can happen
17:21:19 <carter> because things that you can rewire are harder to reason about / optimize
17:21:26 <Tekmo> benmachine: I wouldn't say that it runs things
17:21:31 <Tekmo> benmachine: It gets run by the Haskell runtime
17:21:32 <carter> i'm just thinking silly thoughts out loud mind you
17:21:35 <Tekmo> benmachine: There's a distinction there
17:21:47 <benmachine> Tekmo: ok, so, running main causes other things to be run
17:21:51 <Tekmo> carter: So there is a way to do high-performance pipes
17:21:56 <carter> oh?
17:22:02 <Tekmo> carter: The trick is to only use `for`/`~>`
17:22:09 <carter> vs which?
17:22:16 <Tekmo> carter: versus `>->`
17:22:35 <carter> lemme reinstall pipes locally so i can read the hadddocks :)
17:23:00 <carter> thanks the luite for hdiff :)
17:23:20 <Tekmo> Luite is the man
17:23:31 <carter> he's cool
17:23:42 <carter> i had the pleasure of meeting him IRL at ICFP and when he was in NYC
17:26:26 <carter> hrmm
17:27:29 <Tekmo> Also, pipes has new rewrite rules that I just added that will automatically convert your code to hyper-efficient `for` and `(~>)` when possible
17:27:35 <carter> ok
17:27:35 <carter> neat
17:28:05 <Tekmo> Some of my benchmarks have now doubled in speed as a result of those rules
17:28:09 <carter> ok
17:28:17 <carter> well
17:28:24 <carter> i'm still a ways from using pipes in my own work
17:28:29 <carter> a lot of stuff to do first
17:28:37 <carter> i just like trying to understand stuff ahead of time
17:28:42 <zardoz``> how can we force evaluation of IO () when it is not part of NFData?
17:28:57 <hpc> zardoz``: evaluation or execution?
17:29:01 <carter> zardoz``:    for e:: IO a
17:29:02 <zardoz``> evaluation
17:29:04 <carter> we can force it
17:29:16 <carter> with do a<-e :)
17:29:21 <hpc> i think seq reduces an IO action to normal form
17:29:25 <carter> Tekmo:: >~
17:29:27 <carter> ?
17:29:30 <carter> is that ok  too?
17:31:13 <zardoz``> actually I stated my question wrong, I want to evaluate (not execute) a list of actions. basically I want to prove someone wrong who thought that the only reason [print x | x <- [1..10]] doesn't cause sideeffects because haskell is lazy, so he "used sequence to force evaluation"
17:31:23 <Tekmo> carter: Yes
17:31:26 <carter> ok
17:31:29 <Tekmo> carter: That also produces very efficient code
17:31:44 <carter> so its general compose that hoses things / allows the bad association order?
17:31:58 <chrisdone> Peaker: tried it yet? =p
17:32:04 <carter> is it left or right compose of (>->) thats the problem?
17:32:07 <zardoz``> deepseq actionsList (length actionsList) does not work.  `No instance for (NFData (IO ()))`
17:32:09 <carter> left or right associative
17:32:28 <carter> ?
17:33:01 <Tekmo> carter: Neither
17:33:04 <carter> huh
17:33:08 <Tekmo> carter: I mean
17:33:22 <Tekmo> carter: They are both equally slow compared to `(>~)`/`(~>)`
17:33:30 <carter> oh
17:33:33 <Tekmo> carter: One is slightly slower, but the rewrite rules already fix it to the faster associativity
17:33:38 <carter> ok
17:34:19 <Tekmo> NemesisD: Ok, almost got the skeleton ready
17:34:40 <chrisdone> halloween was so last month
17:34:54 <carter> chrisdone: hehe
17:40:45 <qz> is there any information on when haskell.org is gonna be back online?
17:40:48 <Tekmo> NemesisD: Here you go: http://lpaste.net/95799
17:41:23 <carter> qz: when the fix it right
17:41:37 <carter> qz: they've been nursing it for a while
17:41:41 <Peaker> chrisdone: I think I have about 2 weeks or so before I actually do any Haskelling...  So I don't do much Haskelling this week, but when I do, I do it with structured-haskell-mode
17:41:42 <carter> they want to fix it right™
17:41:50 <Peaker> chrisdone: or rather, will :)
17:41:54 <carter> Peaker: how so?
17:41:56 <chrisdone> Peaker: \o/
17:42:00 <carter> havnet  you bean haskelling for a while?
17:42:08 <Peaker> carter: I have a C project that's behind schedule
17:42:10 <Tekmo> Peaker doesn't always Haskell, but when he does, it's with structured-haskell-mode
17:42:13 <carter> urk
17:42:13 <carter> gl
17:42:17 <carter> whats that?
17:42:36 <Peaker> carter: bluetooth virtualization support in Android
17:42:56 <carter> do you wokr at google?
17:43:08 <Peaker> Nope, it's contract-work
17:43:11 <carter> ah
17:43:13 <Peaker> (and not for Google)
17:43:24 <carter> sounds like a potentially neat project
17:43:32 <chrisdone> everyone works for google whether they know it or not
17:43:35 <Tekmo> Haha
17:43:39 <carter> MOAR ADS
17:43:46 <carter> adtech has sooooo muchhhhh money
17:43:50 <NemesisD> Tekmo: thanks so much for this! I am actually being pulled away to go to dinner ATM. i'll review it when i get back!
17:43:57 <Tekmo> NemesisD: No problem.  Talk to you later
17:44:01 <carter> whats structured-haskell mode?
17:44:06 <Tekmo> I don't understand who buys things from ads
17:44:11 <carter> Tekmo: most people
17:44:23 <carter> the scary thing is how unsophisticated most ad tech companies are
17:44:25 <chrisdone> carter: an emacs library i'm working on for a paredit-like mode for emacs
17:44:30 <carter> ok
17:44:31 <carter> well
17:44:35 <frx> @src sum
17:44:35 <lambdabot> sum = foldl (+) 0
17:44:41 <Tekmo> @src lines
17:44:41 <frx> why isn't sum rewritten to use foldl' ?
17:44:41 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:44:42 <chrisdone> s/for emacs/for haskell
17:44:43 <carter> how do I learn vim / emacs and not go insane?
17:44:57 <chrisdone> carter: interesting paradox
17:45:01 <Tekmo> carter: You can't
17:45:02 <carter> either
17:45:03 <Peaker> carter: some of it is neat.. I wrote a C code generator in Haskell for the project in its beginning.. saved me a lot of legwork :)
17:45:09 <carter> cool
17:45:20 <avenge> The google results for structured-haskell-mode turn up broken links to github.
17:45:20 <Ralith> carter: shm has my enthusiastic endorsement
17:45:23 <Tekmo> carter: What do you currently use?
17:45:29 <carter> sublime text 3
17:45:47 <Tekmo> carter: How often do you take your hand off the keyboard when you type?
17:45:53 <carter> not much
17:45:53 <Tekmo> carter: i.e. for code navigation
17:46:08 <Tekmo> If so, then you probably don't need to switch
17:46:14 <chrisdone> Ralith: updated fixed the delimiters-inside-strings code, now (){}[] etc are literal. among other tweaks
17:46:22 <Tekmo> At least, not to vi
17:46:23 <Ralith> chrisdone: whee
17:46:30 <chrisdone> it's so easy to add indentation support
17:46:33 <Tekmo> The big appeal of vi is always keeping your hands on home row as much as possible
17:46:39 <chrisdone> here's what i just added for record updates
17:46:39 <carter> i should play with digging into emacs / vim again sometime
17:46:42 <chrisdone> ((string= "FieldUpdate" (shm-node-type-name parent))
17:46:42 <chrisdone>       (newline)
17:46:43 <chrisdone>       (indent-to (+ (shm-node-start-column parent)
17:46:43 <chrisdone>                     shm-node-indent-spaces)))
17:46:56 <chrisdone> done
17:47:10 <Tekmo> carter: I have another question: do you prefer to use defaults or to customize things?
17:47:19 <carter> both
17:47:20 <carter> :)
17:47:25 <Tekmo> carter: Tough choice, then :)
17:47:50 <chrisdone> Tekmo: is that home row thing true? last i tried out vim keybindings a lot of it was shift and number rows and other rows
17:48:01 <chrisdone> D and $ and stuff like that
17:48:03 <davorak_> If any one has any insight into threepenny-gui could you take a look at http://lpaste.net/95800 and let me know why I am not getting any of the getElement... functions to work.
17:48:14 <carter> at some point when i'm more stable income wise i'll play with editors more :)
17:48:24 <Tekmo> chrisdone: I find that the most often that I leave home row it's to type the `:` in `:w`
17:48:50 <cesarkawakami> chrisdone: but those are characters you can type without actually moving your arm to reach the arrow keys or the mouse
17:48:51 <chrisdone> Tekmo: does using shift count as sticking to the home row?
17:48:55 <hpc> Tekmo: you have w on home?
17:50:04 <Tekmo> I mean for navigation, mostly
17:50:07 <Tekmo> i.e. hjkl
17:50:21 <Tekmo> But :wq and Esc cause strain
17:50:32 <Tekmo> That's my biggest gripe for uncustomized vi
17:50:36 <carter> maybe i'll play with macvim
17:50:53 <chrisdone> i rebound Esc to Caps Lock :3
17:50:56 <carter> just to learn the modals of live
17:51:00 <carter> huh
17:51:18 <chrisdone> er, i mean, the Caps Lock key is now sending Esc
17:51:20 <Tekmo> For me, the biggest turn off for emacs was the excessive use of Ctrl
17:51:23 <Tekmo> Huge pinky strain
17:51:36 <carter> i have ctrl on capslock
17:51:38 <Twey> Tekmo: You should use the heel of your hand
17:51:51 <carter> Tekmo: or get a kineiss keyboard
17:51:52 <Tekmo> Twey: That's a nice idea.  I never thought of that
17:51:57 <carter> i've been meanign to get it myself
17:51:59 <Twey> Or swap ctrl/alt, or use Ergoemacs (which has most bindings on Meta)
17:52:07 <chrisdone> Tekmo: i have the same complaint, so i made god-mode which provides a toggle (Esc or in my case Caps) to make Ctrl implicit
17:52:08 <zardoz``> I recall seeing some store selling foot pedals for emacs, for pressing meta and control keys with your feet :D
17:52:24 <Tekmo> chrisdone: I like the idea of rebinding caps lock, too
17:52:24 <Ralith> okay, why the crap is emacs opening a help buffer whenever I hit 'tab' if I haven't enabled an indentation mode in haskell mode :|
17:52:43 <Twey> Ralith: Because you need to enable an indentation mode to auto-indent :þ
17:52:57 <chrisdone> Ralith: i added that so that people would not be confused about configuring their indentation mode =p
17:53:03 <chrisdone> now people are confused about why they're being helped
17:53:06 * chrisdone throws hands up in air
17:53:16 <Twey> Heheh
17:53:20 <chrisdone> =p
17:53:22 <Ralith> chrisdone: oh, shm doesn't subsume those yet?
17:53:35 <Twey> I think picking a default would be a better option
17:54:16 <benmachine> Tekmo: re: :w, at work I have a keybinding such that pressing return in normal mode saves the file
17:54:17 <int-e> > 1
17:54:22 <mauke> but pick an awful default so people will change it
17:54:25 <lambdabot>   Could not find module `Data.Default'
17:54:26 <chrisdone> Ralith: personally i use simple-indent.el. i rarely use the tab key, tho, you're right. perhaps shm could provide its own minimal tab key support
17:54:31 <lambdabot>  Use -v to see a list of the files sea...
17:54:34 <benmachine> when I first heard about it I thought it sounded mad but now I use it all the time :P
17:54:41 <Ralith> Tekmo: if you don't have ctrl on capslock you're doing things wrong
17:54:53 <Ralith> chrisdone: it seems like it's well positioned to do a much better job of it
17:54:54 <Tekmo> Ralith: I am :(
17:54:59 <Ralith> Tekmo: :(
17:55:06 <Ralith> chrisdone: I mean, given that it has a newline-and-indent...
17:55:08 <Tekmo> No, I still have vi uncustomized
17:55:14 <Tekmo> I'm really lazy about customizing things
17:55:22 <mauke> benmachine: I use enter to get help for the identifier under the cursor
17:55:29 <Tekmo> But either way I'm doing it wrong, probably
17:55:35 <zardoz``> benmachine how many times did you accidentally save the file?
17:55:46 <benmachine> zardoz``: does it really matter? :P
17:56:00 <benmachine> not like I can't just hg revert
17:56:06 <mauke> or press u
17:56:15 <benmachine> indeed
17:56:27 <Tekmo> benmachine: You mean that it saves and also inserts a newline?
17:56:36 <mauke> normal mode, not insert mode
17:56:39 <chrisdone> Ralith: nod. i'll have to try it. i'd rather discourage "tabbing", preferring people start from a node and navigate or C-j or M-^ or w/e, but the basic necesseties i can probably sort out
17:56:51 <Twey> Tekmo, Ralith: Ctrl on capslock doesn't really help much.  It still requires pinky use (and disallows using the heel of your hand)
17:57:03 <benmachine> Tekmo: no, because normal mode, not insert mode
17:57:23 <Tekmo> benmachine: Oh, ok
17:57:23 <hpc> Twey: i thought i was the only one who used the heel of my hand!
17:57:35 <Tekmo> But yeah, I'd like to minimize pinky use, like Twey said
17:57:36 <benmachine> Twey: I honestly can't work out how this heel-of-hand thing works, possibly my laptop keyboard is too small
17:57:37 <Twey> I saw someone suggest return for ctrl recently.  It was terrible.
17:57:42 <Tekmo> I find that my pink accumulates the most strain
17:57:42 <Twey> hpc: It's been a standard emacs hack since forever :þ
17:57:47 <chrisdone> Tekmo: with god-mode enabled, C-a C-k C-n C-p C-x z z   is now aknp..
17:57:57 <Ralith> chrisdone: having to use it constantly in lieu of shm has made it a muscle memory thing for me, even if it's no longer necessary
17:58:09 <hpc> benmachine: get one of those classic "back in my day" keyboards
17:58:16 <carter> Ralith: what are you talkinga bout?
17:58:17 <Ralith> Twey: I don't see why pinky use is a problem when it's in a neutral position
17:58:23 <Ralith> carter: tab
17:58:23 <chrisdone> Ralith: nod
17:58:24 <hpc> with tall keys and a full numpad and everything laid out exactly as it damn well should be ;)
17:58:29 <Twey> benmachine: If your laptop keyboard has Fn on the corner, you're screwed
17:58:34 <benmachine> Twey: I'm screwed
17:58:46 <Twey> benmachine: :þ
17:58:55 <Tekmo> I can't believe laptop makers still do that
17:59:02 <Tekmo> Fortunately mind lets me rebind it to control
17:59:03 <Tekmo> *mine
17:59:12 <Twey> You can usually switch Fn and Ctrl in the BIOS, but those keyboards are often built so that you don't want to do that (the Fn key is usually not well-placed to act as Ctrl)
17:59:16 <chrisdone> carter: the whole "tab cycle" thing in emacs modes. in my mode you're not supposed to do that, instead relying on the awareness of the type of the node you're at
17:59:26 <carter> tab cycle?
17:59:50 <Zearen> The obvious solution is to use vim :v
17:59:55 * Zearen ducks
18:00:06 <Twey> It tends to be shorter and closer to the middle of the keyboard, which leads to awkward hand-crunching when you try to press e.g. Ctrl-Z
18:00:27 <Twey> I'd recommend just switching Ctrl and Meta in that case
18:01:33 <chrisdone> carter: e.g. you might write:
18:01:34 <chrisdone> carter: foo = do bob bar|  ← here you press RET, and then the mode will decide on some heuristic place to go, either under bar, under bob, or under foo. then you will hit tab again in a cycle until it jumps to the place you want. in my mode, you do what you do in paredit (lisp) mode. you C-j to go under bar, hit ) C-j to go under bob, or ) ) C-j to go under foo. the ) key just jumps to the end of the parent node
18:02:23 <chrisdone> carter: the different, to me, is with a tab cycle (apart from all the unreliable guess work of the editor), you have to think visually and watch to make sure it goes to the right place. by just extending the "current" node you know exactly what's going to happen
18:03:09 <chrisdone> carter: a recent demo http://chrisdone.com/shm-gtk.ogv
18:04:00 <Twey> chrisdone: Can you see the result of ‘jump to the end of the parent node’?
18:05:26 <carter> watching vid now
18:05:47 <int-e> monochrom: ok, that should take care of the timeouts :-)
18:05:51 <jmcarthur> http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/18980   <-- it'
18:05:53 <jmcarthur> oops
18:06:09 <jmcarthur> http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/18980   <-- it's quite sad that the IO monad isn't just free in this benchmark
18:06:14 <chrisdone> Twey: yeah, check the video. there's always a "current" node (the darker background), which is like being at a parenthesis in lisp
18:06:30 <carter> looks neat
18:07:02 <Ralith> chrisdone: really, all I'd expect tab to do is validate/correct the indentation of the current node
18:07:26 <carter> first i'd need to learn emacs if i were to try that mode
18:08:53 <sdrodge> Tekmo: instead of :wq, try ZZ, and in place of :q!, try ZQ, saves a lot of strain.
18:09:07 <Twey> chrisdone: Nice
18:09:17 <Tekmo> sdrodge: I'll give it a try.  Thanks!
18:10:10 <sdrodge> Tekmo: No problem. Also, you can use <C-[> in place of <ESC>.
18:10:55 <Tekmo> sdrodge: ESC is still a bit more preferable because I can use my middle finger to reach it
18:11:51 <nijotz> Is it possible to specify a mirror to cabal, since haskell.org is down?
18:12:35 <chrisdone> Ralith: generally you should pretty rarely get wrong indentation of the current node. although i actually use C-<left/right> to move whole blocks, like in that video, how i'm not happy with the four-space indenation from monochrom's code, i bring it in by 2 spaces. i think that's a good backup
18:13:42 <Ralith> chrisdone: I'm likely to spend the majority of the time working on code that was originally written outside of SHM, so even if SHM has completely deterministic indentation it's still useful.
18:14:06 * Ralith grabs video
18:14:40 <chrisdone> Twey: i like that video because it demonstrates god-mode rather well. i only hit the ctrl key a few times in that (showing that i'm getting used to using it), and hit Esc only to insert the function names
18:14:51 <sdrodge> Tekmo: I opt for a more radical solution. I type on this: http://www.kinesis-ergo.com/images/kb_adv-blk720x471.jpg , and I then swap Escape and Delete (the latter of which is in the left thumb well).
18:15:50 <chrisdone> Ralith: yeah, check the supervisor function, i move that in a bit but C-<left>
18:18:04 <carter> sdrodge: i want to get one of those eventually
18:18:31 <Twey> Aw, dammit, Hackage is down too?
18:18:35 <chrisdone> yup
18:18:35 <sdrodge> carter: I highly recommend it if you're experiencing RSI symptoms.
18:18:42 <carter> im not
18:18:56 <sdrodge> carter: Then it's rather pricey...
18:19:04 <chrisdone> i *was*. but since god-mode my fingers don't get tired anymore =)
18:19:20 <sdrodge> chrisdone: god-mode?
18:19:23 <chrisdone> i can hack all day without feeling any fatigue or that burning feeling
18:19:37 <carter> Twey: i just want a comfortable keyboard
18:19:46 <carter> erp
18:19:47 <carter> wrong thing
18:19:48 <Eduard_Munteanu> fizruk: hm, nevermind, I can't really figure it out, GHC keeps complaining things aren't fully applied, so I guess it only works in rare cases. Besides, you probably need to thread 'm' around so it might not be enough.
18:19:53 <chrisdone> sdrodge: https://github.com/chrisdone/god-mode
18:20:02 <carter> Twey: report your cabal/config to hdiff :)
18:20:08 <carter> http://hdiff.luite.com
18:20:12 <chrisdone> carter: we are not things, we are human beings
18:20:15 <Eduard_Munteanu> fizruk: I've had it working in different situations, but it's brittle.
18:20:22 <carter> chrisdone: eh?
18:20:30 <chrisdone> carter: n/m joking =p
18:20:42 <carter> chrisdone: youre at fpcomplete too right?
18:20:45 <chrisdone> yup
18:20:51 <sdrodge> chrisdone: Very interesting!
18:21:43 <Tekmo> sdrodge: Oh wow, that's neat
18:22:14 <Twey> carter: I'm not really sure where my Cabal config is :-\  I'm installing stuff via Portage on Gentoo
18:22:20 <carter> Twey:
18:22:29 <carter> ~/.cabal/config
18:22:36 <Twey> Tekmo: I have one of those too.  Solves the ctrl problem nicely by putting it on a thumb.
18:22:56 <chrisdone> the truly ergo brings most modifier keys to the center too
18:22:57 <Twey> carter: root's, I guess?
18:22:59 <carter> --remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
18:22:59 <carter> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
18:23:02 <carter> Twey: nope
18:23:05 <carter> Twey: run cabal update
18:23:10 <carter> and itll complain
18:23:12 <carter> and set i tup
18:23:16 <Twey> carter: Portage runs as root
18:23:17 <chrisdone> https://www.trulyergonomic.com/store/image/data/Truly_Ergonomic_Mechanical_Keyboard-207.jpg
18:23:22 <carter> Twey: i don't care
18:23:22 <Twey> Er
18:23:26 <carter> i'm telling you how to do it
18:23:40 <carter> Twey: "cat ~/.cabal/config"
18:23:47 <carter> you'll have some file output
18:23:47 <Twey> carter: Is this a roundabout way of saying ‘don't use Portage’?  :þ
18:23:55 <carter> Twey: use cabal for managing haskell packages
18:24:10 <Tekmo> Carter's right
18:24:13 <Twey> Yes, I know how it usually works, but there's a dedicated gentoo-haskell repo that integrates Portage with Cabal
18:24:14 <osa1> er
18:24:18 <Tekmo> You should use cabal to manage Haskell packages
18:24:21 <carter> Twey: i don't care about your feelings
18:24:23 <carter> do it this way
18:24:25 <carter> or you'll be sad
18:24:27 <chrisdone> twey's point is ~/ is  /home/root/, or possibly some non-standard place
18:24:34 <Twey> So Portage calls Cabal.  But I don't know where *that* Cabal gets its config from.
18:24:35 <Tekmo> The only thing I trust my package manager with is the Haskell platform
18:24:47 <carter> Twey: its always ~/.cabal/config
18:25:07 <carter> for any unix like
18:25:16 <carter> $homedir
18:25:18 <Twey> As chrisdone said
18:25:24 <Twey> The question is, *whose* homedir ☺
18:25:34 <carter> Twey: your user homeir
18:25:39 <mauke> carter: definitely not
18:25:44 <carter> well
18:25:47 <carter> then i can't help
18:25:50 <Twey> Definitely not that, no
18:25:51 <carter> someone elses problem
18:25:52 <mauke> that was obvious
18:25:56 <carter> why
18:26:08 <mauke> because you ignored the portage bit
18:26:14 <carter> Twey: "cabal help"
18:26:24 <carter> last line should be the pasth
18:26:26 <carter> "You can edit the cabal configuration file to set defaults:
18:26:26 <carter>   /Users/carter/.cabal/config"
18:26:28 <mauke> and you're still doing it
18:26:32 <carter> is what i got
18:26:42 <Tekmo> I don't know how gentoo works, but on Debian even if you install ghc/cabal via the package manager it still gives each user a local package database and cabal config file
18:26:50 <carter> exactly
18:27:04 <Twey> That's… not really what's happening here
18:27:20 <carter> Twey: i"M telling you how cabal can find the packages sans hackage
18:27:21 <Eduard_Munteanu> Probably somewhere in /usr/lib/ I guess
18:27:23 <Twey> It's okay, I wasn't really asking for help, just commenting.  I can probably figure it out myself.  Thanks anyway.  ☺
18:27:53 <carter> Twey: grep for hackage.haskell.org:http://hackage.haskell.org/packages/archive on your computer and swap in hdiff.luite.com:http://hdiff.luite.com/packages/archive
18:28:05 <Twey> Eduard_Munteanu: I suspect it might be Portage's homedir, /var/tmp/portage
18:28:14 <mauke> Twey: you could use strace to confirm
18:28:23 <carter> type cabal help
18:28:24 <carter> and find out
18:28:29 <mauke> carter: just stop
18:28:33 <carter> why
18:28:39 <carter> explain what i'm not understanding
18:28:44 <mauke> carter: PORTAGE
18:28:57 <chrisdone> Twey: hmm, i think there's an environment variable, too -- i'm using hsenv and cabal ignores my ~/.cabal/config file and instead reads from .hsenv/cabal/  i wonder whether that dir is actually set anywhere. lemmie check what it is on mine
18:28:59 <carter> "RTFM" isn't a constructive statement
18:29:31 <carter> mauke: brew is another source based package tool, albeit hacky as hell
18:29:44 <carter> saying "source based package manager" doesn't communiciate the "why"
18:29:55 <mauke> carter: I never said "RTFM", "brew", or "source based package manager"
18:30:01 <carter> yes
18:30:04 <carter> i'm asking you to explain
18:30:06 <mauke> so I'm not sure what you're talking about
18:30:13 <carter> http://en.wikipedia.org/wiki/Portage_(software)
18:30:17 <carter> you're saying "portage"
18:30:29 <mauke> yes, which is the bit you seem to keep ignoring
18:30:38 <carter> educate me on what that means for haskell libs
18:30:44 <carter> i'm reading the wiki
18:30:46 <mauke> no
18:30:50 <carter> and its not helping me understand
18:31:49 <carter> is this because portage / gentoo doesn't have users?
18:31:56 <chrisdone> Twey: n/m, didn't find it
18:32:15 <Twey> chrisdone: That's weird
18:32:19 <Twey> I wonder how it does that
18:32:29 <chrisdone> yeah, i'm not sure how
18:32:31 <carter> whatever, i'm going to go back to movies and math coding. gnith all
18:32:39 * chrisdone looks at hsenv's source
18:32:45 <Twey> Oh, there's a --config-file option to cabal, apparently
18:32:48 <Eduard_Munteanu> Twey: it's probably set by /usr/portage/eclass/haskell-cabal.eclass but I don't know what flag tells cabal what homedir to use
18:33:20 <Twey> Eduard_Munteanu: I'm just going to ‘locate cabal’ (after this updatedb is done :þ).  I figure that should point somewhere useful.
18:33:35 <mauke> Twey: or you could still use strace
18:33:39 <Twey> I could still use strace
18:34:32 <Eduard_Munteanu> Twey: are you having trouble with your packages? There's haskell-updater to handle rebuilding on Gentoo.
18:34:53 <mauke> hard to do if hackage is down
18:35:03 <Eduard_Munteanu> mauke: it gets them from Gentoo repos
18:35:11 <Twey> It does?
18:35:26 <Eduard_Munteanu> It should, just like any other Gentoo package really, it should be mirrored.
18:35:44 <Twey> Eduard_Munteanu: I don't think the Gentoo repos have mirrors for overlays
18:35:55 <mauke> I've seen more than one ebuild that fetched files from wherever
18:36:09 <Eduard_Munteanu> Oh, overlays.
18:36:25 <Twey> Eduard_Munteanu: Yeah, I'm using the Haskell overlay, sorry
18:37:28 <Twey> I'm trying to track down what seems to be an issue around vinyl-gl (or possibly some other part of my OpenGL stack), so I submitted a bug report to vinyl-gl, but acowley only has an old version of GLFW, so I need to downgrade my glfw-b &c. to try his test code
18:37:49 <Eduard_Munteanu> mauke: Gentoo packages are always mirrored AFAIK, though it can fetch them from the very source if your mirror isn't uptodate.
18:38:02 <Eduard_Munteanu> Well, except fetch-restricted things and the likes.
18:39:09 <Eduard_Munteanu> Oh, and of course, packages that pull from the VCS directly, i.e. -9999 stuff
18:39:14 <Twey> The ones in the official Gentoo repos are, but anyone can create an overlay, and the Gentoo devs don't scour the Web for overlays to mirror
18:39:27 <Eduard_Munteanu> Yes, sure.
18:39:37 <Eduard_Munteanu> Just the mainline stuff.
18:39:52 <Twey> Aye, they're supposed to be mirrored
18:40:37 <orzo> i cant function without haskell.org
18:41:12 <Twey> Heh
18:45:24 <bss03> Is there an ETA for haskell.org coming back up?
18:46:14 <nisstyre> bss03: might have to switch to OCaml
18:46:19 <Twey> Eduard_Munteanu, mauke: Looks like it's /usr/lib64/ghc-7.6.3/gentoo/cabal-1.18.1.1.conf
18:46:22 <Twey> (for future reference)
18:46:31 <Eduard_Munteanu> Ah.
18:46:56 <Eduard_Munteanu> I sort of remember something like that from ghc-pkg.
18:47:15 <Twey> Oh wait, no, that's something quite different
18:47:22 <Twey> Hm
18:47:44 <bss03> nisstyre: There's an alternate source of package docs, and the reports are cached in Google.
18:48:02 <bss03> nisstyre: So, I can limp along; just wondering on the ETA
18:48:11 <Eduard_Munteanu> Twey: ghc-pkg list reports /usr/lib64/ghc-7.6.3/package.conf.d, I guess cabal should be around
18:48:13 <nisstyre> bss03: I was joking :P
18:49:05 <orzo> heh
18:49:13 <bss03> nisstyre: Ah, then you should propose something more outlandish.  Like, switching to Agda, Ermine, or Idris. :P
18:49:27 <orzo> i just pasted a bunch of code from google cache for docs/src links
18:49:32 <orzo> because i cannot install packages
18:49:45 <Zearen> Is there away to get cabal to create haddock for all installed packages ?
18:50:06 <pharaun> ive done ^ but i end up with each package in isolation
18:50:15 <pharaun> no cross-linking so i'm probably missing something
18:50:24 <nisstyre> also I imagine luite's server is getting hammered
18:50:52 <Eduard_Munteanu> We should make a "Haskeller's survival guide".
18:51:12 <Twey> Ah
18:51:26 <nisstyre> Eduard_Munteanu: does it include several bags of coffee beans?
18:51:54 <Eduard_Munteanu> Possibly, if we're good enough at converting them to code.
18:52:05 <Twey> Eduard_Munteanu: Apparently the Haskell overlay fetches the packages using the normal Portage mechanism; it sets up Hackage as a mirror in /var/lib/layman/haskell/profiles/thirdpartymirrors (and there's a HDiff mirror in there, too).
18:52:33 <Eduard_Munteanu> Hm
18:52:45 * Eduard_Munteanu has to go, though
18:52:54 <pharaun> hdiff is nice i just now ran over it
18:52:54 <Twey> \o
18:52:59 <Twey> Thanks for the help!
18:55:39 <carter> question:  I can'tuse inlineable for class instances?
18:56:21 <doubleloop> hi, what's going on with www.haskell.org ? can not load the page
18:56:49 <c_wraith> doubleloop: well.  what's going on is that it's down.  But I think you already knew that.
18:57:35 <carter> so i can't use INLINE / INLINEABLE on class instances?
18:57:40 <carter> only in the class definition?
18:58:01 <doubleloop> :P but anyone know when it will be back?
18:58:09 <carter> doubleloop: when they fix the problem
18:58:15 <carter> they've been putning ont doing it right for a month or so
18:58:28 <carter> "reboot it and ignore it"
18:58:31 <carter> isn't scalable
18:58:33 <carter> well
18:58:36 <carter> ermmm
18:58:59 <c_wraith> carter: You can use them on instances, but only if you've also used them on the definition
18:59:04 <carter> damnit
18:59:21 <carter> c_wraith: soooooo, foldable and applicative in 7.6 dont have INLINEABLE
18:59:29 <carter> fuckity fuck
18:59:35 <carter> oh well
18:59:55 <carter> and that means I can't use SPECIALIZE on them either
18:59:58 <carter> right?
19:00:31 <c_wraith> my conclusion was that if you can, it's really hard to get it right, when I tried to do so a while ago
19:00:43 <carter> yeah
19:01:11 <carter> welp
19:03:03 <carter> this means i'll have to do some custom stuff sooner than I'd have liked
19:12:43 <carter> leroux: hows thigns on your side?
19:13:10 <leroux> I've been reading math books and stuff. Not too much haskell.
19:13:40 <carter> balance is good
19:14:53 <hopf> no, you should read all of the math or all of the haskell
19:15:04 <carter> BOTH
19:32:48 <zRecursive> @ty (<*)
19:32:49 <lambdabot> Applicative f => f a -> f b -> f a
19:36:00 <gfredericks> are the immutable Data.Vectors generally efficient for most update operations?
19:36:14 <gfredericks> structure sharing & such?
19:37:01 <carter> gfredericks: ummm nope
19:37:09 <carter> you want diff arrays or something
19:37:13 <carter> or mutable arrays
19:37:22 <gfredericks> I definitely want something immutable
19:37:31 <carter> diff arrays
19:37:35 <carter> if you want fast updates
19:37:45 <carter> uness you're only doing "batch updates"
19:38:12 <gfredericks> I'm trying to find an analog to clojure's vectors
19:38:22 <gfredericks> starting to think there might not be one
19:39:08 * gfredericks using google caches to browse hackage
19:39:13 <carter> gfredericks: OOOO
19:39:18 <carter> you want unordered containers
19:39:24 <carter> or containers
19:39:28 <triliyn> gfredericks: how do clojure's vectors work?
19:39:28 <Tekmo> greymalkin: You can use the `update` operation to batch updates
19:39:43 <Tekmo> Oops
19:39:48 <Tekmo> I meant to address that to gfredericks
19:39:49 <gfredericks> triliyn: trees with a branching factor of 32
19:40:12 <carter> gfredericks: you want unordered-containers or containers
19:40:20 <gfredericks> carter: unordered containers? are they confusingly named?
19:40:23 <carter> nope
19:40:26 <copumpkin> bitmapped vector trie is what we want an implementation of
19:40:31 <gfredericks> clojure'v vectors are ordered
19:40:50 <gfredericks> yeah bitmapped vector trie is the term that usually gets thrown around
19:40:53 <carter> yes
19:40:59 <carter> those aren't ordreed in teh sense you think
19:41:09 <carter> they're indexed
19:41:10 <carter> :)
19:41:22 <carter> i think
19:41:23 <gfredericks> this is what I meant by "confusingly named"
19:41:39 <carter> its a key value data structure with functionalupdates
19:41:43 <carter> and good complexity
19:41:43 <copumpkin> it's a datastructure we don't have a common implementation of, as its own thing, in Haskell
19:41:47 <copumpkin> we probably should
19:41:57 <carter> copumpkin: i thought unoreered containers did it
19:42:00 <carter> huh
19:42:05 <carter> i am distractable right now
19:42:11 <gfredericks> the data structure I'm talking about has keys (0..(n-1))
19:42:23 <copumpkin> well, the HAMT in there is the closest thing to the structure, but it's not the same thing
19:42:31 <carter> ok
19:42:32 <carter> huh
19:42:35 <copumpkin> IntMap is also pretty close
19:42:38 <copumpkin> but still not it
19:42:45 <carter> ok
19:42:46 <carter> hrmm
19:42:50 <gfredericks> I wonder how hard this would be to write
19:43:06 <gfredericks> maybe basing it on small Data.Vectors
19:43:21 <carter> i'm reading the clojure source now
19:43:37 <gfredericks> PersistentVector.java is the relevant class I think
19:43:39 <carter> i think its winking at me
19:43:40 <copumpkin> there's a paper on them somewhere
19:43:47 <carter> https://github.com/clojure/core.rrb-vector ?
19:43:48 <carter> yeah
19:43:51 <carter> bagwe'lls papers
19:43:58 <gfredericks> rrb-vector is a bit more advanced
19:44:10 <gfredericks> maybe that'd be a more sensible target if I'm going to make something new anyhow
19:44:28 <gfredericks> I don't understand rrb-vector yet though, but I think I understand the classic vectors
19:44:29 <carter> gfredericks:  copumpkin …. you can use the map in unordred-containers with int keys
19:44:37 <copumpkin> it's not the same thing
19:44:37 <carter> classic vectors are just arrays
19:44:41 <carter> true
19:44:47 <copumpkin> I can remove an element from a Scala Vector
19:44:50 <gfredericks> carter: I mean classic clojure vectors
19:44:51 <copumpkin> and have all the ones after it "fall down"
19:45:04 <carter> ohhh
19:45:17 <copumpkin> well
19:45:21 <copumpkin> maybe I can't
19:45:24 <carter> scala "vector" ===  clojure " vector"
19:45:28 <gfredericks> copumpkin: I'm just writing an interpreter for a clojuresque lisp, so if I can wrap something with similar perf characteristics that might be a good enough try
19:45:34 <carter> "Ideal Hash Trees
19:45:34 <carter> Phil Bagwell"
19:45:42 <copumpkin> well, IntMap or HashMap is closest
19:46:01 <Tekmo> I vote IntMap
19:46:02 <gfredericks> I'll look at intmap, thanks
19:46:05 <copumpkin> this is why I wanted the unordered-containers hashmap to not actually be a hash*
19:46:10 <copumpkin> you can have the AMT without the H
19:46:14 <copumpkin> it'd be closer to ideal
19:46:14 <carter> oooo, tiark wrote a paper with  bagwell
19:46:21 <carter> copumpkin: i'll take a look
19:46:40 <carter> copumpkin: do you know tiark? he's a pretty cool dude
19:46:57 <copumpkin> I saw a talk of his at scala days
19:47:01 <copumpkin> haven't met him
19:47:02 <carter> nice guy too
19:47:06 <carter> chat with him some time
19:47:07 <copumpkin> awesome name
19:47:12 <carter> oh?
19:47:20 <copumpkin> he has an awesome name
19:48:05 <carter> oh
20:00:34 <carter> copumpkin: so you're suggesting a keyless array mapped trie?
20:01:05 <NemesisD> hey Tekmo you still around?
20:01:10 <copumpkin> yeah, the hash isn't integral
20:01:10 <Tekmo> Yeah!
20:01:19 <copumpkin> and it seems like most of the implementation could be shared, just throwing a hash on the front of it
20:01:22 <copumpkin> for the hash one
20:01:53 <JuanDaugherty> hackage is down?
20:02:34 <carter> JuanDaugherty: haskell infrastructure is down
20:02:40 <carter> and they're taking the weekeidn to seriously debug it
20:02:45 <carter> rather than cargo cult reboot it
20:03:07 <carter> copumpkin: yeah… you just need a whole lotta different code for with vs without keys
20:03:16 <carter> but thered be a lot of common structure i gues
20:03:18 <JuanDaugherty> ah, OK. Glad I'm not the only person who uses that expression in derision.
20:03:20 <copumpkin> really?
20:03:31 <copumpkin> if I had an IntMap, I could just slap a HashMap interface on top of it
20:03:33 <carter> JuanDaugherty: cargo culting is always in derishion
20:03:48 <copumpkin> given that hash gives me an Int that I can shove into the IntMAp
20:03:51 <NemesisD> Tekmo: actually maybe my question is invalid. i noticed that you have a pattern match for each cmd constructor, Cmd1, Cmd2, Cmd3. in my case the function body will always be the same: encode/decode
20:03:53 <carter> copumpkin: not with the semantics of "remove this one elements, and the indexes for the suffix slide down"
20:04:02 <copumpkin> oh, I didn't mean that
20:04:06 <carter> ohh
20:04:09 <c_wraith> sparse array, not dense!
20:04:13 <carter> copumpkin: yeah
20:04:14 <NemesisD> Tekmo: but because all commands can be part of the Binary typeclass, i could get away with 1 pattern match there and just be polymorphic
20:04:16 <carter> c_wraith:
20:04:17 <copumpkin> I meant that the unordered containers AMT could just look like an IntMap
20:04:18 <carter> copumpkin: oooo
20:04:24 <carter> gotcha
20:04:25 <carter> ok
20:04:25 <copumpkin> and have a hash thrown on top of it for uses that need it
20:04:26 <carter> yea
20:04:27 <carter> agreee
20:04:33 <SegFaultAX> Is hackage down again?
20:04:40 <carter> read teh topic :)
20:04:46 <c_wraith> SegFaultAX: only if it was when that was asked 30 seconds ago. :P
20:04:48 <Tekmo> NemesisD: So you can simplify it a little bit by making one polymorphic function and then reusing it three times
20:04:53 <stelleg> anyone know how to create a handle from a posix fd?
20:04:59 <SegFaultAX> Oh whoops, sorry.
20:05:10 <carter> copumpkin: alternatively we could help hack on structures… :)
20:05:12 <carter> but yeah
20:05:15 <carter> different data structures
20:05:17 <carter> i'll chew on this
20:05:30 <Tekmo> NemesisD: Another possibility is that you existentially quantify the `Cmd` constructor
20:05:37 <Tekmo> NemesisD: That might work
20:06:17 <JuanDaugherty> yeah but as "prayer" it's encouraged or whatever in the masses in advanced countries not held to derision anyway
20:06:20 <copumpkin> https://issues.scala-lang.org/browse/SI-3724
20:06:21 <NemesisD> Tekmo: what would that look like? i haven't really done much of htat yet
20:06:36 <Tekmo> NemesisD: Let me try to write it up
20:07:20 <stelleg> oh cool, fdToHandle
20:07:22 <Tekmo> NemesisD: Actually, it wouldn't work
20:07:34 <Tekmo> NemesisD: However, I could simplify it a little bit
20:07:37 <Tekmo> NemesisD: Give me a second
20:07:49 <carter> copumpkin: another wontfix so scala doesn't get nice thigns?
20:08:15 <JuanDaugherty> just going offline like that is whack; why couldn't they leave the old thing up for the public
20:08:17 <copumpkin> I think that implementation made it in, in the end
20:08:19 <carter> copumpkin: are you suggesting i port the spiewak code?
20:08:23 <copumpkin> that's rompf
20:08:39 <copumpkin> brb
20:08:46 <carter> "Reporter:	  Daniel Spiewak"
20:09:19 <JuanDaugherty> is there like magical thinking about domain names, some animus or what?
20:13:17 <Tekmo> NemesisD: This simplifies it a bit: http://lpaste.net/95802
20:16:47 <NemesisD> Tekmo: ah ok. yeah that's a bit cleaner. i will have to add a line per command but that's not too bad
20:16:52 <sclv> JuanDaugherty: what do you mean "leave the old thing up"?
20:17:13 <NemesisD> Tekmo: commands could be a sum type but that would make the types a bit less safe
20:17:20 <Tekmo> NemesisD: Right
20:17:39 <Tekmo> NemesisD: If you want type correctness, then at some point in your code you will need one line per command
20:17:59 <sclv> Nobody "took something down"
20:18:05 <NemesisD> but my poor fingers :P
20:18:06 <sclv> the server became unrecachable
20:18:07 <lambdaCalculator> Does anyone know what's going on with haskell.org?  It appears to be down at the moment
20:18:12 <Tekmo> NemesisD: :)
20:18:15 <Tekmo> NemesisD: Use `vi`!
20:18:15 <sclv> and we asked our hosts to investigate
20:18:20 <sclv> we can't reboot it
20:18:23 <Tekmo> NemesisD: It's great for automating this sort of thing
20:18:27 <sclv> without destroying the evidence we're asking them to investigate
20:18:30 <NemesisD> if it becomes an issue i will weigh the moral decision of weilding the TH hammer
20:18:32 <sclv> so we're on their timetable :-(
20:18:37 <lambdaCalculator> sclv: I'm going to guess that answers my question?
20:18:38 <Tekmo> NemesisD: Haha
20:18:42 <NemesisD> Tekmo: vim user for 5 years :)
20:18:46 <sclv> there's a thread on haskell.reddit.com
20:18:49 <Tekmo> NemesisD: :)
20:18:54 <sclv> with some details of how to make do in the meantime.
20:19:03 <sclv> lambdaCalculator: sadly, yeah
20:19:06 <sclv> we're working on various options
20:19:08 <sclv> its hard work
20:19:23 <Tekmo> NemesisD: I need to learn to filter things through `ghci` so I can use Haskell to process text in `vi`
20:19:26 <lambdaCalculator> I can imagine
20:19:31 <lambdaCalculator> Best of luck then
20:21:24 <NemesisD> Tekmo: i know there are currently 2 vim plugins for doing ghc stuff. i have one of them installed but i use it for linting and type checking
20:23:40 <JuanDaugherty> sclv, as I understood it old hackage and hackage2 were being kept in sync
20:26:02 <NemesisD> i wonder if at some point it would be wise to get hackage up on aws or something
20:26:28 <carter> NemesisD: static hosted on S3 would be better
20:26:36 <carter> than "aws" perse se
20:26:48 <NemesisD> oh if everything could be static then yeah
20:27:00 <carter> http://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html
20:27:12 <NemesisD> but i thought there was quite a lot of live code being executed on hackage
20:27:20 <carter> NemesisD: for updating the pages yes
20:27:24 <carter> hrmmm
20:27:32 <NemesisD> user accounts too
20:27:52 <NemesisD> but yeah you're right, docs, package indexes, etc could be static
20:27:56 <carter> yeah
20:28:04 <carter> we'd need to do some funky partially static routing
20:28:14 <carter> and it'd fly in the face of hackage2
20:28:38 <NemesisD> ehh, most http servers have a check-files type option
20:28:47 <NemesisD> if the path links to a file, serve it, if not, fall through to the backend
20:28:59 <carter> oh
20:29:02 <carter> cool
20:29:10 <carter> if you can do that with s3, then we'd be golden
20:29:11 <copumpkin> carter: http://infoscience.epfl.ch/record/169879/files/RMTrees.pdf?version=1 is the one I meant
20:29:32 <carter> yay! I had that one already
20:29:39 <copumpkin> let's get a haskell one
20:29:39 <carter> dled it a few months  / year or so ago?
20:29:42 <carter> ok
20:29:43 <copumpkin> :)
20:29:47 * copumpkin disappears again
20:29:52 <carter> copumpkin: ummm, before or after i get my arrays core out?
20:29:58 <copumpkin> hah, up to you :)
20:30:34 <carter> ummm
20:33:07 <carter> copumpkin: added it to my haskell ecosystem trello :0
20:33:36 <NemesisD> hmm, i've got 30+ commands here, this actually may be a job for qq or th
20:35:47 <Tekmo> I recommend qq
20:35:57 <Tekmo> Template Haskell is the gift that keeps on taking
20:36:32 <carter> taking your soulllll
20:36:35 <carter> qq?
20:36:43 <joelteon> is there an mconcat for <|>
20:36:44 <Tekmo> vi's record function is `q`
20:37:06 <Tekmo> You associate the recording with a character
20:37:13 <Tekmo> People are lazy and just associate it with `q`
20:37:16 <Tekmo> Thus, `qq`
20:37:51 <NemesisD> wait are we talking about quasi quotes or vi macros
20:37:58 <NemesisD> i was talking about quasi quotes
20:38:01 <Tekmo> I was talking about vi macros
20:38:02 <pharaun> both, why not?
20:38:05 <pharaun> hah
20:38:06 <carter> oh
20:38:10 <Tekmo> Ha :)
20:38:22 <carter> i thought qq== quasiquoter
20:38:34 <sclv> JuanDaugherty: that stopped ages ago
20:38:43 <Tekmo> I try to avoid Template Haskell because of the annoying load up time every time you compile or interpret it
20:38:46 <sclv> we could sync hackage2 from old hackage periodically
20:38:53 <sclv> while hackage2 was in beta
20:38:57 <sclv> but we could never go the other way
20:39:01 <sclv> so after the cutover, that was that
20:39:07 <carter> Tekmo: yeah… hence why i keep on trying to lure folks into hacking on ghci :)
20:39:10 <joelteon> hoogle is still down so I can't hoogle for it
20:39:21 <carter> i think if we made ghci a bit faster we'd get TH times down
20:39:42 <sclv> joelteon: tips including hoogle mirror here http://www.reddit.com/r/haskell/comments/1qrldv/haskellorg_servers_down_at_the_moment/
20:40:05 <sclv> fpcomplete hoogle mirror here: https://www.fpcomplete.com/hoogle
20:40:32 <Taslem> Can an infix operator be set with lower precedence than $?
20:40:34 <joelteon> oh wait, but there's no identity for (<|>)
20:40:37 <pharaun> how complete is fpcomplete's
20:40:44 <joelteon> no Taslem it's infixr 0
20:43:00 <mzero> isn't mzero identity for <|>?
20:43:28 <mzero> no - I mean empty
20:43:34 <mzero> empty is identy for <|>
20:43:56 <Tekmo> mzero: mzero is identity for `mplus`, technically
20:43:56 <Tekmo> mzero: But `mplus` is supposed to be synonymous with `(<|>)`
20:44:29 <mzero> yes - hence my confusion - I always forget which zero goes with with op in which typeclass
20:44:31 <mzero> there are so many!
20:44:43 <Tekmo> Yes
20:44:43 <Tekmo> empty <|> f = f
20:44:43 <Tekmo> f <|> empty = f
20:45:03 <mzero> so, joelteon - there's your zero
20:45:11 <joelteon> oh, empty
20:45:34 <Tekmo> Well, empty and mplus are basically supposed to be the same
20:46:14 <Tekmo> Oops
20:46:14 <Tekmo> I mean empty and mzero
20:46:14 <Tekmo> And mplus/(<|>) are also supposed to be the same
20:46:16 <Tekmo> Assuming both are defined
20:46:19 <alekar83> is haskell.org scheduled for downtime?
20:46:19 <mzero> In th eback of my brain I thought MonadPlus m => Alternative m ... but no, not so
20:46:33 <bss03> It depends on your Applicative / MonadPlus ... depending on if it has non-determinism semantics, search semantics, or error-recovery semantics.  Also, left-bias or right-bias.
20:46:42 <bss03> * Alternative
20:47:30 <mzero> alekar83: no, haskell.org is down and the infra. team is on it
20:47:39 <Tekmo> alekar83: The servers are down.  They're letting the datacenter investigate, but that means not rebooting it for a few days
20:49:32 <alekar83> mzero: ah, thanks. perhaps change topic to reflect that?
20:49:47 <mzero> possibly - I don't have privs.
20:50:17 <JuanDaugherty> ah, that sounds more reasonable
20:50:29 <JuanDaugherty> not much, but clutching at straws here
20:50:46 <jmcarthur> the topic already says it's down
20:51:26 <carter> jah
20:51:31 <JuanDaugherty> "ages" ago I take it means like earlier this year. I don't even remember seeing hackage2 until those notices went up
20:51:47 <NemesisD> can you use qq to define types or can it only be used for expressions?
20:53:01 <joelteon> has anyone defined a trifecta parser for hostnames?
20:53:40 <carter> probably not
20:54:00 * mzero wonders what trifecta parser means
20:54:20 <Ralith> @hoogle trifecta
20:54:20 <lambdabot> package trifecta
20:54:27 <Ralith> I always get that wrong
20:54:29 <Ralith> @hackage trifecta
20:54:29 <lambdabot> http://hackage.haskell.org/package/trifecta
20:55:27 <jmcarthur> mzero: fancy parsec
20:55:45 <carter> jah
20:56:03 <carter> i think edward's ermine language uses it to have nice error messsages in the parsing
20:56:18 <Ralith> idris uses it too
20:58:39 <joelteon> is trifecta able to specify the number of times a parser can succeed in a row
20:58:47 <joelteon> like `count' but as an upper/lower limit
20:58:47 <NemesisD> you don't realize how much content is on haskell.org until it is down
20:58:55 <NemesisD> google cache all the things
21:00:31 <carter> joelteon: look at the haddocks :)
21:00:37 <ellipsis_> seems like it's up again
21:00:54 <carter> noe
21:00:55 <carter> well
21:00:56 <carter> umm
21:00:58 <carter> idk
21:01:13 <ellipsis_> I can ping it, but the response time's like 30 seconds
21:01:34 <cap11235> Got me all excited for a minute there...
21:01:53 <ellipsis_> I was trying to learn Conduit today :/
21:02:05 <carter> ellipsis_: just use the mirror for hackage
21:02:13 <ellipsis_> carter: what mirror?
21:02:19 <carter> http://hdiff.luite.com/
21:02:22 <carter> read the topiccccc
21:02:28 <carter> i'm gone night all
21:03:05 <Tekmo> Good night
21:03:27 <ellipsis_> good night
21:04:23 <bss03> Is there a Monad instance for (Either String) where fail = Left on hackage?
21:05:10 <scshunt> bss03: there won't be because instances must be unique; it would have to be some other isomorphic type, possibly a newtype wrapper
21:09:53 <bss03> OverlappingInstances?
21:11:06 <arkeet> those never work out well
21:11:12 <arkeet> consider not using fail
21:12:25 <ellipsis_> anyone willing to code-review a project I finished today?
21:12:31 <ellipsis_> trying to get better with Conduit
21:13:09 <ellipsis_> http://github.com/atomiccheese/distpi
21:13:32 <arkeet> ah, haskell.org is down.
21:13:53 <ellipsis_> yeah
21:14:30 <Hodapp> booo, some example code is not working because I have no module "Time"
21:14:44 <mzero> love the name atomiccheese
21:15:05 <sclv> Hodapp i think that got moved to System.Time?
21:15:30 <ellipsis_> mzero: I tried to think of a backup username that would almost certainly be free everywhere
21:15:44 <mzero> first suggestion, ellipsis_ - don't use tabs - always spaces!!!
21:15:57 <Tekmo> Also, try to import operators unqualified.
21:15:58 <copumpkin> mzero: how about blast_hardcheese?
21:16:28 <Hodapp> sclv: success! thank you.
21:16:35 <mzero> copumpkin: doesn't really have the zing of atomiccheese
21:16:40 <Tekmo> ellipsis_: Another trick: Any time you have something like this: case m of Nothing -> return (); Just a -> ...
21:16:47 <ellipsis_> Tekmo: is there syntax to import some parts of a library unqualified but import the rest qualified?
21:16:51 <copumpkin> :)
21:16:55 <Tekmo> ellipsis_: Yes
21:16:59 <sclv> import Foo qualified as F
21:17:05 <sclv> import Foo(this,that,theother)
21:17:09 <Tekmo> ^
21:17:10 <sclv> this that theother are unqual
21:17:12 <sclv> and the whole thing is qual
21:17:16 <ellipsis_> Tekmo: awesome
21:17:25 <Tekmo> ellipsis_: The next thing is `Data.Foldable.forM_`
21:17:36 <Tekmo> ellipsis_: You can use it to iterate over `Maybe`s, only doing something if they are a `Just`
21:17:51 <Tekmo> So you can do something like: `forM_ someMaybe $ \a -> ...`
21:18:06 <Tekmo> This allows you to ignore the `Nothing` case and focus on the `Just` case
21:18:25 <Tekmo> For example:
21:18:36 <Tekmo> forM_ (Just 1) print == print 1
21:18:41 <Tekmo> forM_ Nothing print = return ()
21:19:21 <johnw> I find that use case of Foldable's forM_ to be extremely handy
21:19:40 <ellipsis_> what's Foldable?
21:19:54 <ellipsis_> is it kind of like Functor but for folds instead of maps?
21:20:08 <Tekmo> ellipsis_: It's basically a glorified type class for "toList"
21:20:17 <Tekmo> ellipsis_: Anything that implements `Foldable` can be converted to a list
21:20:26 <Tekmo> For example, a `Maybe` can be converted to a list with either 0 or 1 elements
21:20:35 <ellipsis_> not exactly the most intuitive name, but that's awesome
21:20:51 <Tekmo> It's really useful for your own custom data types
21:21:07 <Tekmo> If you have them implement `Foldable` then you can reuse a lot of functions
21:21:15 <afarmer> I'm sure I'm the 8000th person to ask, but what happened to haskell.org?
21:21:20 <Tekmo> afarmer: It's down
21:21:27 <afarmer> I noticed that much
21:21:55 <Tekmo> From what I understand, the data center that was hosting it was subject to a DOS attack
21:21:59 <afarmer> ah
21:21:59 <ellipsis_> afarmer: Based on the Reddit post, it's down and instead of rebooting it immediately, they're talking to the server host
21:22:11 <afarmer> ooh reddit, forgot to check there
21:22:14 <ellipsis_> wait, it got DOSed?
21:22:25 <Tekmo> They said they were going to delay rebooting it for a day or two to give the infrastructure people a chance to investigate what went wrong and how to prevent it in the future
21:22:54 <sclv> we don't know if the dos attack had anything to do with the downtime
21:22:58 <dmj`> who's the host?
21:23:00 <sclv> the box is just unreachable
21:23:00 <Tekmo> Oh
21:23:01 <sclv> hetzner
21:23:05 <Tekmo> Then maybe it wasn't the DOS
21:23:17 <sclv> but they announced a dos attack on that data center in proximity to our problems
21:23:22 <sclv> so maybe there's a correlation maybe not
21:23:42 <sclv> once we kick off a reboot we 'destroy the evidence' since the logs don't show any trace of why the thing tanks
21:23:50 <sclv> so we're trying to get their ppl to investigate physically
21:23:56 <ellipsis_> are they in tmpfs or something?
21:24:06 <dmj`> uh oh
21:24:07 <dmj`> http://www.hetzner-status.de/en.html
21:24:31 <frx> isn't Foldable just describing types with a folding function? toList is just one of countless things you can do with it
21:24:41 <sclv> dmj`: yeah, as they note, the dos is over
21:24:51 <johnw> hi dmj`!
21:25:00 <Tekmo> frx: toList is basically equivalent to the other functions
21:25:02 <sclv> but we're still unreachable, so that indicates its just a stupid coincidence
21:25:14 <dmj`> hey johnw!
21:25:31 <ellipsis_> Tekmo: what I don't get about that is that if Foldable means "can be converted to a list" then why does forM_ Nothing print == return ()?
21:25:57 <johnw> ellipsis_: because forM_ implies ... >> return ()
21:25:58 <Tekmo> ellipsis_: Think of it as calling the given action once per each elemtn of the list
21:26:08 <Tekmo> So if there is one element in the list it calls the action once
21:26:12 <johnw> and the Nothing means "do nothing"
21:26:18 <Tekmo> If there are no elements then it does nothing (i.e. `return ()`)
21:26:36 <ellipsis_> so forM_ is basically sequenceM_ after mapping over the implied lsit?
21:26:38 <ellipsis_> list*
21:26:42 <Tekmo> Right
21:26:45 <ellipsis_> neat
21:27:32 <frx> Tekmo I mean saying it can be used for toList is like saying it can be used for computing the sum of the elements.. it's just one example of what you can use it for
21:28:20 <Tekmo> frx: Saying it can be used for toList does not sacrifice any generality
21:28:39 <Tekmo> frx: I'm also copying Edward Kmett's own words
21:29:05 <Clint> infringement!
21:29:11 <Tekmo> :)
21:29:28 <Tekmo> Pardon me while I go download myself an Edward
21:29:53 <johnw> Tekmo: I don't yet have sufficient bandwidth
21:30:53 <ellipsis_> johnw: Needs more 7zip
21:30:57 <frx> Tekmo you're right, but saying that it's "glorified toList" kind of does.
21:31:05 <Tekmo> johnw: Haha
21:31:34 <Tekmo> frx: I feel that `toList` captures the spirit of the `Foldable` type class better than any other explanation
21:31:48 <Tekmo> frx: I personally never "got" the `Foldable` type class until Edward explained it to me that way
21:32:57 <frx> it's an odd explanation.  it's not a glorified toList any more than a glorified sum, product, toTree, or anything else you can reduce some set of values to
21:34:48 <Tekmo> frx: The difference is that `toList` preserves all the original informatoin
21:34:56 <Tekmo> frx: A sum or product does not
21:35:09 <Tekmo> frx: All you are doing is changing the encoding of the list
21:35:14 <Tekmo> frx: With a fold you are church encoding the list
21:35:23 <Tekmo> frx: With toList you are using the ordinary encoding
21:36:00 <zardoz``> will Monads require Applicatives in future versions of ghc? if so, will they start removing functions like liftM2, ChanServ
21:36:18 <zardoz``> << or <*, etc
21:36:18 <ion> …wat
21:36:53 <zardoz``> if implementing Monads requires implementing Applicatives we don't need both liftM2 and liftA2. or << and <*, etc
21:37:00 <ion> They probably won’t remove liftM2 or (>>) any time soon, but they might make them aliases to liftA2, (*>). ChanServ?
21:37:12 <zardoz``> tab fail
21:37:51 <enthropy> there isn't a <<
21:39:07 <dmj`> enthropy: yet...
21:39:16 <zardoz``> ok, so >> and *>
21:39:26 <ellipsis_> (<<) = flip (>>)
21:39:54 <dmj`> (<<) :: m b -> m a -> m b
21:40:29 <ellipsis_> can't think of where it'd be useful though
21:40:52 <triliyn> We can use it to define (>>)!
21:40:57 <Tekmo> I just used it three times today!
21:41:08 <NemesisD> when defining a parser for a quasi quoter, is there any reason to use parsec over trifecta or attoparsec?
21:41:13 <ellipsis_> you used <<?
21:41:20 <ion> ♪ THRICE
21:41:20 <Tekmo> Technically, (<*)
21:41:25 <ellipsis_> what's a quasi quoter?
21:41:40 <ellipsis_> goddamnit haskell.org
21:41:54 <ellipsis_> not being able to wiki something is really annoyin
21:41:56 <ellipsis_> g
21:42:20 <NemesisD> ellipsis_: ever use yesod? the default way you generates routes is via quasi quotes
21:42:33 <NemesisD> [parseRoutes| ... |]
21:42:40 <ellipsis_> never used it -
21:42:47 <ellipsis_> s/ - //g
21:45:26 <dmj`> ellipsis: http://www.edsko.net/2013/05/09/brief-intro-to-quasi-quotation/
21:46:14 <joelteon> I would use trifecta, NemesisD
21:46:21 <joelteon> you just can't beat those diagnostics
21:47:51 <NemesisD> i picked a really good day to do something that requires reading lots of haddocks and haskell wiki
21:48:18 <joelteon> that's every day for me
21:48:41 <dino-> NemesisD: You can change to the mirror in the topic, and make sure cabal install builds docs. Then they'll be local.
21:48:46 <Tekmo> I just think it was not a good idea to concentrate so many services on a single server
21:49:00 <dino-> I have to admit I got lazy with keeping locally-generated haddock for stuff I have installed.
21:49:16 <dino-> But it's really handy if you travel and write code on the plane, things like that.
21:49:34 <Tekmo> You can just make cabal generate it by default
21:49:36 <NemesisD> dino-: yeah been doing that. i should really figure out how to reasonably browse local haddocks. right now i root around my cabal sandbox for an index.html :/
21:50:01 <Tekmo> NemesisD: Well, you can always still browse github
21:50:03 <Javran> is haskell.org server down?
21:50:10 <Tekmo> NemesisD: The haddocks are still markdown, so you can sort of read it :\
21:52:11 <dino-> NemesisD: I get you. If you don't cabal-dev I think they build to /usr/local/share/doc/ by default
21:52:19 <dino-> s/build/install/
21:53:04 <dino-> I should seriously get back into that habit, of defaulting to locally built haddock. HD space is cheap, even with SSD
21:56:44 <dino-> I'
21:58:22 <zardoz``> "<ellipsis_> can't think of where it'd be useful though"   foo = act1 << act2, instead of foo = do x <- act1; act2; return x
21:59:45 <ellipsis_> zardoz``: Fair point
21:59:59 <Fuuzetsu> Tekmo: Well, they aren't Markdown.
22:00:05 <Fuuzetsu> They're just human-readable.
22:00:55 <Tekmo> Fuuzetsu: Yeah, my mistake
22:02:30 <Hodapp> for some inexplicable reason, even being new to Haskell, the type signature syntax makes more sense to me.
22:02:31 <NemesisD> jeeze. trifecta sure does have some spartan docs
22:03:09 <joelteon> NemesisD: most of the heavy lifting is in the parsers package
22:03:14 <joelteon> and the light lifting
22:03:53 <NemesisD> parsers package?
22:04:17 <NemesisD> oh literally the package called parsers
22:04:56 <NemesisD> i can't figure out the entry points of these damn libraries
22:07:35 <NemesisD> i'd really like to see docs start to take the form of 2 divergent paths: impementation details/advanced topics vs how-do-i-use-this-library?
22:07:56 <NemesisD> haddocks just kind of lays bare the entire structure of a project and you get to guess
22:08:40 <enthropy> by default it's the first
22:08:53 <Fuuzetsu> There's nothing stopping you from including the ‘how-do-i-use-this-library’. edwardk includes such introductions is his packages AFAIK
22:09:17 <NemesisD> i'm mainly looking for the introductory resources for trifecta. seems to be missing
22:09:39 <NemesisD> although what i should actually be doing so i can get something accomplished today is use attoparsec because i know how to use it
22:10:00 <enthropy> writing the parser is pretty much the same as parsec
22:10:22 <orzo> i have a big list of strings and i need to run a sed-style s/// command on them.  Is there no quick and dirty way to get that done?
22:10:37 <orzo> pipe it into an external process? heh
22:11:27 <zardoz``> that's possible, you can launch external process and write to it's stdin
22:12:32 <zardoz``> runInteractiveProcess
22:12:36 <orzo> it's kind of lame that i dont have a ready made haskell way to accomplish it
22:12:48 <ellipsis_> isn't there a function like that in Text.Regex?
22:12:50 <orzo> without forking a process
22:12:57 <ellipsis_> Text.Regex.Whatever
22:13:45 <enthropy> Text.Regex only gets you matches, not substitutions
22:13:47 <orzo> well i have regex-posix and regex-base installed.  Cabal doesn't work to get anything else right now, does it?
22:13:47 <zardoz``> not sure if one takes s// format, but perhaps there is
22:14:10 <ellipsis_> orzo: You can use hdiff.luite.com as a mirror
22:16:03 <orzo> can i get docs and such at that mirror too?
22:17:23 <dino-> orzo: No haddock docs, but you can build them with cabal install locally
22:17:27 <orzo> eh, cant figuore out how to use the mirror
22:17:44 <orzo> remote-repo config item looks odd, has two urls with a colon between
22:17:52 <dino-> orzo: It goes into your ~/.cabal/config
22:18:08 <dino-> orzo: Replacing the remote-repo: field
22:18:30 <orzo> that's what i guessed
22:18:54 <orzo> what i dont know is what to set remote-repo to?  the exact text "hdiff.luite.com" or something else with a colon and another url?
22:19:14 <orzo> i have remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
22:19:28 <orzo> do i replace both occurences of the haskell.org domain?
22:19:49 <orzo> or delete one of the urls
22:19:50 <dino-> orzo: I commented out my hackage one and set mine to exacly this: "remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive"
22:20:02 <dino-> Yes, it looks weird
22:20:38 <orzo> okay, well thats what i needed to know
22:27:26 <pavonia> Is there a way to browse the package documentation on hdiff.luite.com?
22:31:06 <dino-> pavonia: I don't think so. But you can build it with cabal-install with haddock docs generated locally
22:31:41 <pavonia> :(
22:36:19 <dino-> pavonia: It's actually nice to have local docs. If you travel, say, and have sketchy internet access.
22:36:58 <pavonia> Well yes, but I want to check the docs first to see if I even want to install a certain package
22:37:42 <pavonia> and my version of HTTP seems to be buggy
22:41:25 <dino-> pavonia: Let me try to install the package you need on my server with docs and expose those through my http server. What package is this?
22:42:16 <pavonia> dino-: Hold on a moment, I'm installing the newest version of HTTP to see if that one works
22:42:31 <Fuuzetsu> ah piss, Hackage is down
22:42:38 <Fuuzetsu> fingers crossed for local docs
22:43:19 <dino-> Fuuzetsu: mirror is in the topic
22:43:32 <dino-> Fuuzetsu: And yeah, build local docs
22:44:07 <Fuuzetsu> I should have mirrored Hackage when I was going to do it last time…
22:44:44 <dino-> Fuuzetsu: But you can just have local cabal build haddock for things you install, if that works
22:45:00 <dino-> I mean, if that's adequate for that you need
22:45:11 <Fuuzetsu> Yeah I know but I wanted a mirror anyway
22:45:37 <dino-> Understood, we do need maybe more than one of these out there
22:46:04 <pavonia> Gahh, why wouldn't "ghc-pkg list HTTP" list that package when it (apparently) had been successfully installed?
22:46:08 <dino-> pavonia: Let me know the package you're needing docs for. I'm poised to cabal install it right now
22:46:24 <dino-> hm, not sure
22:49:43 <numberten> .window 1
22:53:46 <pavonia> dino-: Thanks for your offer to help. Actually, I'm just looking for a very simple way to download a text file from the internets and store it in a folder.
22:54:29 <dino-> Maybe curl or wget?
22:54:53 <pavonia> Yeah, as HTTP isn't working I guess I will just use curl
22:55:11 <dino-> Hey, I absolutely love the big H but we do have a lot of UNIX tools for things.
22:55:36 <pavonia> Unfortunately not on Windows :D
22:56:07 <dino-> Maybe through cygwin? I don't consider a Windows system civilized without cygwin installed
22:57:48 <pavonia> the curl binary from the git system seems to work
22:58:28 <zardoz``> did you try http-conduit
23:00:22 <pavonia> zardoz``: I haven't
23:00:22 <NemesisD> what is the purpose of Text.Trifecta.Delta?
23:01:30 <pavonia> I guess I'll stick with curl for now and leave getting the download done in Haskell as a job for tomorrow :)
23:01:46 <pavonia> Thanks for the help and good night!
23:02:13 <dino-> pavonia: Sorry I didn't help more. I think we do need a better mirror of the haddock docs for sure
23:07:14 <levi> NemesisD: I think it's to keep track of positions and ranges in files.
23:07:17 <edwardk> NemesisD: Delta is used internally to track relative file position offsets. The main parser type carries a rope of all of the input, tracking a fingertree with a Delta-annotation on it. We use Delta as an offset because it contains the total # of bytes, the known offset in column # or line # or fixed file name from LINE directives in your grammar that you want to show the user
23:08:03 <levi> And there's a much more authoritative answer for you.
23:08:28 <levi> ghc has an internal Delta type, or something like it, doesn't it?
23:08:47 <levi> I recall something like that from fiddling with the ghc API a bit.
23:13:08 <NemesisD> edwardk: so should i just use mempty there?
23:13:14 <edwardk> yes
23:13:36 <edwardk> you can also pass an annotation to indicate the filenae
23:13:38 <edwardk> er file name
23:15:07 <NemesisD> edwardk: how would you apply a parser to each line? myParser `sepBy` newline only seems to parse the first line
23:16:08 <edwardk> iirc the stock whitespace parser will eat newlines
23:16:40 <edwardk> so if you are using any of the token parsers you'll have to be careful if you want significant carriage returns
23:16:53 <NemesisD> ahh yeah that must be it
23:16:58 <edwardk> bbiab
23:17:31 <edwardk> you can make a newtype wrapper around Parser, then define your own whitespace parser for it, using GND to get most of the instances copied
23:33:20 <dmj`> why don't we run hackage on amazon
23:35:46 <NemesisD> what do the th docs mean by "capture" when they differentiate mkName as capturable and newName as non-capturable
23:36:10 <edwardk> @google name capture
23:36:11 <lambdabot> http://www.smarty.net/docs/en/language.function.capture.tpl
23:36:11 <lambdabot> Title: {capture} | Smarty
23:36:15 <edwardk> bah
23:38:27 <edwardk> If i make a new "x", mkName is saying you want to just have "x", taking whatever one is in scope as needed, but newName s saying make up an "x1230918230" that will be unique and different from any surrounding "x"
23:38:41 <edwardk> @google capture avoiding substitution
23:38:42 <lambdabot> http://stackoverflow.com/questions/11239262/
23:38:42 <lambdabot> Title: programming languages - What is meant by "Capture-avoiding substitutions"? - ...
