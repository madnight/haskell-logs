00:01:01 <chrisw> @pl \xs n -> take n xs
00:01:02 <lambdabot> flip take
00:02:21 <chrisw> @pl \g -> concatMap ($ g) [id, reverse]
00:02:21 <lambdabot> ([id, reverse] >>=) . flip id
00:02:37 <chrisw> @pl \g -> concatMap ($ g) [id, reverse, transpose]
00:02:37 <lambdabot> ([id, reverse, transpose] >>=) . flip id
00:09:55 <jle`> what does flip id even do
00:10:43 <scott_> It's the same as flip ($)
00:11:08 <scott_> So it takes an argument, then a function, and applies the function to the argument
00:12:52 <c_wraith> :t id `asTypeOf` ($)
00:12:53 <lambdabot> (a -> b) -> a -> b
00:15:49 * hackagebot gitlib-test 2.2.0.0 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-2.2.0.0 (JohnWiegley)
00:15:49 * hackagebot stm-conduit 2.1.4 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.1.4 (ClarkGaebel)
00:49:35 <chrisw> @pl \a b = mod b a == 0
00:49:35 <lambdabot> (line 1, column 6):
00:49:35 <lambdabot> unexpected "="
00:49:35 <lambdabot> expecting pattern or "->"
00:49:47 <chrisw> @pl \a b -> mod b a == 0
00:49:47 <lambdabot> flip flip 0 . ((==) .) . flip mod
00:55:49 * hackagebot base32-bytestring 0.2.0.0 - Fast base32 and base32hex codec for ByteStrings  http://hackage.haskell.org/package/base32-bytestring-0.2.0.0 (SamTruzjan)
01:30:53 * hackagebot dlist 0.6 - Difference lists  http://hackage.haskell.org/package/dlist-0.6 (SeanLeather)
01:36:43 * hackagebot fizz-buzz 0.1.0.0 - Functional Fizz/Buzz  http://hackage.haskell.org/package/fizz-buzz-0.1.0.0 (AlanHawkins)
01:39:28 <shiona_> How does ghc handle memory in the theoretical situation 'print[1..]' ?
01:39:40 <tovarish> shiona_, nicely
01:40:31 <shiona_> tovarish: does it garbage collect the beginning of the list after printing it? Testing suggests it does but I'm not sure
01:40:42 <tovarish> it does
01:41:03 <tovarish> in fact ghci will do something equivalent to for i = 1 to inf do print i
01:41:18 <shiona_> ok
01:41:22 <tovarish> maybe it uses chunk to do that, but that's how it process the code
01:41:36 <tovarish> think imperative if you want to understand how ghc hangles your memory
01:41:42 <tovarish> s/hangles/handles.
01:41:43 <shiona_> :D
01:41:49 <niko> 2
01:42:10 <shiona_> so the only way to get that to run out of memory would be to get close enough to 'inf' to use all the memory
01:42:45 <quicksilver> I'm not really sure "think imperative if you want to understand how ghc handles your memory" is good advice.
01:42:56 <shiona_> where does ghc put that i in memory and does it limit the memory for that segment?
01:43:18 <quicksilver> I would say "learn how reachabililty and garbage collection work if you want to understand how GHC handles your memory"
01:43:41 <quicksilver> what do you mean by "segment", shiona?
01:43:51 <tovarish> quicksilver, it's a good advice, you have to see how the process will be executed
01:44:03 <shiona_> well, from imperative world I mean something like stack or heap or something
01:44:18 <tovarish> because it's in proces time that the lazys are consumed
01:44:34 <quicksilver> GHC has a heap, yes.
01:44:38 <shiona_> but what I want to know is that does ghc limit the memory used by i or is the hardware the only limit
01:44:44 <quicksilver> and that's where data lives in general.
01:44:54 <quicksilver> the memory used by the actual integer itself?
01:45:01 <shiona_> yes
01:45:05 <quicksilver> it's handled by GMP
01:45:17 <quicksilver> I'm not sure what limits GMP has in practice but they're certainly very large
01:45:54 * hackagebot fizz-buzz 0.1.0.1 - Functional Fizz/Buzz  http://hackage.haskell.org/package/fizz-buzz-0.1.0.1 (AlanHawkins)
01:45:57 <shiona_> I feel like I have seen some 8M memory limit for something in GHC
01:46:12 <quicksilver> I don't know what that would be.
01:47:14 <shiona_> quicksilver: default maximum stack size it seems
01:47:29 <shiona_> overridable with rtsopts
01:48:02 <shiona_> but if the integer is in heap then it's unlimited
01:48:36 <tovarish> it's limited by the size of your memory
01:48:44 <shiona_> yes
01:49:00 <shiona_> or even stricted my OS
01:49:03 <quicksilver> yes GHC doesn't use the stack in anything like the way a C compiler does
01:56:05 <lpaste> bartavelle pasted “why isn't this catching exceptions ?” at http://lpaste.net/96364
01:56:24 <bartavelle> So I'm getting "hGetContents: invalid argument (invalid byte sequence)" with this code
01:56:35 <bartavelle> where I expected it to be catched
01:57:38 <bartavelle> I believe my code sample should catch all exception, what is wrong here ?
01:58:11 <quicksilver> hGetContents is what is wrong here.
01:58:23 <quicksilver> don't use it. it's broken by design.
01:58:34 <bartavelle> because of lazy evaluation ?
01:58:41 <quicksilver> no
01:58:47 <quicksilver> because of *lazy IO*
01:58:54 <bartavelle> I get the exception once I'm out of the catch block ?
01:58:57 <quicksilver> which is quite different from lazy evaluation
01:59:03 <quicksilver> which is why I hate that it's called lazy IO.
01:59:07 <bartavelle> heh
01:59:15 <quicksilver> lazy evaluation is perfectly safe
01:59:25 <quicksilver> it doesn't matter when you evaluate expressions
01:59:29 <quicksilver> might as well leave it until you need it.
01:59:37 <quicksilver> lazy IO is quite unsafe - if you do the IO at a different time
01:59:40 <bartavelle> except for expressions like undefined
01:59:45 <quicksilver> it might cause an exception you can't catch.
01:59:49 <bartavelle> ok I'll fix that, thanks !
02:00:55 * hackagebot base32-bytestring 0.2.0.1 - Fast base32 and base32hex codec for ByteStrings  http://hackage.haskell.org/package/base32-bytestring-0.2.0.1 (SamTruzjan)
02:08:38 <bartavelle> isn't Data.Text.readFile suitable ? I am having the same problem with it
02:20:05 <bartavelle> nvm, it is suitable
02:23:09 <Shapeshifter> How can I see the functions defined by a class in ghci? e.g. how can I see what functions I would have to implement if I want to make an instance Ord
02:23:43 <supki_> :i Ord
02:23:46 <Shapeshifter> supki_: thanks
02:25:58 * hackagebot hlint 1.8.55 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.55 (NeilMitchell)
02:33:38 <Zaba_> Hi!
02:33:51 <Zaba_> I'm working on a couple of exercises and I'm a bit stuck
02:33:57 <jle`> Hi Zaba_
02:34:05 <Zaba_> here's one (i.e. my solution)
02:34:11 <Zaba_> http://lpaste.net/1202265941488959488
02:34:34 <Zaba_> the task was to write a function that repeats one operation until the test operation returns Bool
02:34:51 <jle`> mhm
02:34:51 <Zaba_> sorry, the test operation is True
02:35:07 <Zaba_> in that care, I'm supposed to return the unit value ()
02:35:18 <jle`> does it work now?
02:35:28 <Zaba_> I've now translated the text of the exercises into Haskell code; it does compile; but I have no idea how I would test it
02:35:56 <Zaba_> I have no idea whether it works since I don't know how to test it in ghci
02:36:02 <jle`> are you supposed to test first, or after?
02:36:05 <jle`> oh
02:36:11 <jle`> you would do :load (filename)
02:36:16 <jle`> that would import it all into the namespace
02:36:25 <Zaba_> you are supposed to run the operation until the test is True
02:36:37 <Zaba_> so I thought I'd use something like a generator for Booleans
02:36:50 <Zaba_> but then I get a type mismatch error since Gen Bool /= IO Bool
02:36:56 <Zaba_> note that I'm supposed to use that signature
02:37:20 <Zaba_> (all those are voluntary exercises given at Chalmers university, so I'm not asking for help with any graded homework)
02:37:42 <jle`> do you want to manually test things out?
02:37:46 <Zaba_> no, I know how to load the file, and how to call it in the ghci
02:37:48 <jle`> or write a quickcheck?
02:37:52 <Zaba_> yes, I want to test it manually
02:37:53 <jle`> you load the file in ghci
02:37:57 <jle`> with :load (filename)
02:38:05 <jle`> then you have access to the functions
02:38:05 <Zaba_> yes, I'm way past that :)
02:38:18 <jle`> oh :)
02:38:23 <jle`> define your test, your op
02:38:27 <jle`> then you can just call repeat' test op?
02:38:46 <jle`> are you looking for functions you can use as test and op?
02:38:55 <Zaba_> but HOW am I supposed to call this?
02:38:57 <Zaba_> I just tried "repeat True (putStrLn "aaa")"
02:39:09 <jle`> oh you can't use True
02:39:10 <jle`> that's a Bool
02:39:11 <Zaba_> ...and I get this back "Couldn't match expected type `IO () -> t0'                 with actual type `[Bool]'"
02:39:14 <jle`> you want an IO Bool
02:39:22 <jle`> do you know how to wrap an object in an IO?
02:39:36 <Zaba_> but this didn't work either: repeat (4 > 2) (putStrLn "aaa")
02:39:37 <jle`> you do it once in your code
02:39:48 <Zaba_> you mean like "do"
02:39:51 <jle`> er
02:39:51 <Zaba_> do ... return
02:39:53 <jle`> not quite
02:39:57 <jle`> so
02:39:59 <Zaba_> what do you mean, then?
02:40:00 <jle`> you have something of type Bool
02:40:11 <scott_> Zaba_: Are you sure you used your repeat' and not the builtin repeat
02:40:11 <jle`> and you want something of type IO Bool
02:40:12 <scott_> ?
02:40:30 <jle`> do you know any functions a -> IO a ?
02:40:48 <jle`> a function that turns your Bool into an IO Bool?
02:40:52 <Zaba_> scott, I made a mistake by calling the built-in repeat. Thanks for pointing this out. However, I still get an error when calling repeat': Couldn't match expected type `IO Bool' with actual type `Bool'
02:41:14 <scott_> Yep, now listen to what jle` is saying ^.^
02:41:25 <jle`> you actually use this function once in your code
02:41:38 <Zaba_> okay, I'm listening :) So, how do I turn Bool into IO Bool?
02:44:52 <jle`> you do it once already
02:44:52 <jle`> note that one of your branches
02:44:52 <jle`> results in a () being returned
02:44:52 <Zaba_> yes, "x <- test"
02:44:52 <jle`> but your function can't return a ()
02:44:52 <jle`> it has to return an IO ()
02:44:52 <jle`> so how do you make it return an IO ()
02:44:52 <jle`> instead of an ()?
02:44:52 <Shapeshifter> So, can I view the system f-ish code ghc creates when compiling to machine code? I.e. can I compile to the core language instead of compiling to machine code?
02:44:52 <jle`> by return, i mean, say i have a function f x = x * 2
02:44:53 <jle`> the result of the function is a number
02:44:53 <Zaba_> I don't know. please tell me
02:44:53 <jle`> in your function, one of the results is...you want the result to be (), but your function has to return an IO ()
02:44:53 <jle`> so how did you turn a () into an IO ()?
02:44:53 <jle`> hm
02:44:53 <jle`> maybe it is not apparent that `return` is a function, and not a language keyword
02:44:53 <scott_> :t return
02:44:53 <Zaba_> typing "IO ()" ??
02:44:53 <lambdabot> Monad m => a -> m a
02:45:00 <scott_> Specifically for the IO monad, return :: a -> IO a
02:45:10 <jle`> return just wraps a value in IO
02:45:10 <lifescks> haskell is nothing to me
02:45:34 <scott_> scks to be him, I guess
02:45:39 <jle`> heh
02:45:45 <jle`> indeed
02:45:54 <jle`> `return` is a function that takes any normal value, and then "wraps" it in IO
02:46:01 <Zaba_> ok
02:46:08 <jle`> so return 5 will take your 5 and wrap it in IO, turning an Int into an IO Int
02:46:23 <jle`> an IO Int being an IO object that contains an integer
02:46:35 <jle`> kind of like how [Int] is a list that contains integers
02:47:02 <jle`> or (Int,Int) is a tuple that contains two integers
02:47:04 <jle`> etc.
02:47:22 <Cale> "contains an integer" is the wrong way to think about it usually (though not an invalid one)
02:47:22 <jle`> so you have a Bool (True), and you want an IO Bool
02:47:40 <Cale> An IO Int is an IO action which produces an Int as its result
02:48:17 <Cale> It's a bit weird usually to think of that Int as somehow already existing within it.
02:48:19 <jle`> yeah i never found a way of satisfactory way of explaining it to someone new that
02:48:32 <jle`> doesn't add extra confusion
02:48:41 <Cale> An IO Int contains an Int in the same way that /bin/ls contains a list of files
02:49:06 <tovarish> that's wise :)
02:49:10 <Zaba_> I'm sorry, but I still can't figure out how I should change the return function
02:49:26 <jle`> in terms of 'contains', i think of something like an IO Int being a data structure that represents the idea of an Integer somehow.
02:49:37 <Zaba_> okay
02:49:39 <jle`> oh
02:49:41 <jle`> so
02:49:51 <jle`> you are using repeat' True (putStrLn "hey")
02:49:58 <jle`> your second value is a Bool
02:50:00 <Cale> A value of type IO t is a description of some stuff which can be done to produce a value of type t.
02:50:02 <jle`> you want it to be an IO Bool
02:50:11 <jle`> so you would do
02:50:18 <jle`> repeat' (return True) (putStrLn "hey")
02:50:48 <Zaba_> I figured it out literally a second before you typed it :)
02:50:54 <Zaba_> okay, now (return True) returns nothing
02:50:54 <jle`> congrats :)
02:51:01 <Cale> Zaba_: return takes a value and produces an IO action which does nothing except to produce that value as its result
02:51:08 <Zaba_> and (return False) sends the function into an infinite loop
02:51:18 <Cale> Right
02:51:19 <jle`> Zaba_: as you would expect it to.
02:51:37 <jle`> thanks Cale, that's a lot better than how i was saying it
02:51:48 <Zaba_> how would I change this so that the IO Bool value can actually switch from False to True at one point
02:51:58 <Zaba_> like repeating until
02:52:02 <jle`> well
02:52:09 <jle`> your IO Bool value is a computation that returns a Bool
02:52:15 <jle`> so you need to find a computation that returns true or false
02:52:49 <jle`> hm.
02:52:50 <Cale> do r <- newIORef 0; repeat (do n <- readIORef r; writeIORef r (n+1); return (n > 10)) (print "Hello!")
02:53:08 <jle`> how about
02:53:10 <Cale> oh, that should be repeat'
02:53:58 <jle`> (\x -> x == "stop") =<< getLine
02:54:20 <jle`> hm should be a return there somewhere
02:54:34 <jle`> getLine >>= (\x -> return (x == "stop"))
02:54:56 <jle`> basically this is a computation that gets a line from stdin, and returns whether or not the line is "stop"
02:55:21 <jle`> so you could do repeat' (getLine >>= (\x -> return (x == "stop"))) (putStrLn "Hello!")
02:55:22 <Cale> This repeat' isn't terribly useful, but would be okay with things that operate on IORefs
02:55:23 <dv-> redundant ()'s
02:55:32 <Zaba_> fabulous! Thanks a lot
02:55:46 <Zaba_> I know that it's probably not very useful
02:55:48 <jle`> dv-: redundant, but hopefully is more readable for someone with less monad experience
02:55:55 <jle`> or point-free
02:55:59 <jle`> or functional experience
02:56:01 * hackagebot connection 0.1.3.1 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.1.3.1 (VincentHanquez)
02:56:09 <Zaba_> it's based on an exercise in Thompson's Haskell book
02:56:20 <Cale> getLine >>= \x -> return (x == "stop")
02:56:25 <jle`> oh yeah
02:56:27 <jle`> thanks
02:56:36 <Cale> or:  fmap (== "stop") getLine
02:56:38 <jle`> idk i feel really cognitively weird about leaving off those parenteses
02:57:13 <jle`> yeah the fmap form is what i would do myself ( or (== "stop") <$> getLine ), but it might be one concept too far at this moment
02:57:32 <dv-> hlint beats me when I use too many brackets
03:00:10 <jle`> anyone have any use cases for that Reverse State monad
03:00:17 <jle`> it feels too cool to be useless
03:00:55 <Zaba_> okay, thanks for all your help.
03:01:41 <jle`> Zaba_: no problem
03:01:44 <jle`> some style tips
03:01:54 <jle`> people don't like using if/then/else statements in haskell
03:02:09 <jle`> but i guess if you don't know some of the higher order functions
03:02:12 <jle`> it's not too bad
03:02:29 <jle`> if you notice, the lpaste code suggests that you "use unless"
03:02:35 <jle`> :t unless
03:02:36 <lambdabot> Monad m => Bool -> m () -> m ()
03:03:05 <jle`> unless takes a bool and a monadic action, and executes it only if the bool is false
03:03:13 <jle`> so you would do
03:03:34 <jle`> unless x (op >> repeat' test op)
03:03:56 <jle`> which says "unless x is true, perform op and then repeat' again"
03:04:21 <jle`> you can also use do notation if you want, unless x $ do ... etc.
03:08:55 <Zaba_> okay, I'll keep it in mind! Right now I'm primarily concerned with getting the code to work, though.
03:09:33 <Zaba_> I've got something else: http://lpaste.net/4851892557061292032
03:09:45 <Zaba_> This is a definition of sequence which we did in the lecture
03:09:59 <Zaba_> it does not quite behave like the inbuilt sequence
03:10:27 <Zaba_> again, I'm wondering how I would use this function
03:10:54 <jle`> first, write the type signature
03:10:55 <Zaba_> what kind of arguments would you feed it?
03:10:59 <Zaba_> I know this all sounds quite stupid
03:11:12 <Zaba_> I had no problems with Haskell before we moved on to monads
03:11:44 <jle`> do you know what type of arguments you are looking for?
03:11:50 <Zaba_> you are supposed to give it a list of functions, I presume
03:11:57 <jle`> not quite
03:12:02 <Zaba_> something you can execute in isoltation
03:12:05 <Zaba_> no, why not?
03:12:14 <jle`> this is the same analysis you would do in a normal non-monadic context
03:12:19 <Zaba_> doesn't "a  <- i" mean execute i and put it into a
03:12:24 <jle`> hm
03:12:43 <jle`> i represents a description of a computation
03:12:48 <jle`> and a represents the results
03:12:51 <jle`> *result
03:12:56 <jle`> so what type is i?
03:13:22 <Zaba_> would it be "a"
03:13:23 <jle`> it's IO a
03:13:29 <Zaba_> since it could be many types
03:13:29 <jle`> it's a description of a computation
03:13:41 <jle`> i is IO a
03:13:46 <Zaba_> ok
03:13:47 <jle`> it is a computation or a description of a computation
03:14:04 <jle`> it is not a function...it's a 'constant'
03:14:04 <Zaba_> but I thought that the return statement turns a into IO a
03:14:20 <jle`> yes return basically generates a description of a computation
03:14:26 <jle`> an IO object
03:14:37 <jle`> the computation that it generates says "just spit out the value."
03:14:42 <jle`> so when i say return 5
03:14:47 <jle`> i greate a description of a computation
03:14:57 <jle`> a computation 'object'
03:15:05 <jle`> and the computation is "spit out 5"
03:15:32 <Zaba_> ok
03:15:36 <Aetherspawn> anyone know a *cool* way to implement dropUntil
03:15:45 <jle`> so remember, i is not a funconi
03:15:48 <jle`> it does not have type a -> b
03:15:52 <Zaba_> so the return type is [IO a]
03:15:54 <jle`> it is a noun
03:15:59 <Zaba_> and the input type IO [a] ?
03:16:01 <fizruk> Aetherspawn, dropWhile (not . f) ?
03:16:11 <Aetherspawn> sorry, there's more, but I'm still typing it
03:16:18 <jle`> hm you mixed it up
03:16:34 <jle`> you know the return type
03:16:41 <jle`> from line 1
03:16:41 <Zaba_> I meant the type signature: sequence :: IO [a] -> [IO a]
03:16:44 <Aetherspawn> dropUntil [1..100] [5,6,7] == [8..100]
03:16:50 <jle`> you have it backwards
03:17:07 <jle`> from line 1, you see that your function evaluates to "return []"
03:17:14 <jle`> [] is type [a]
03:17:18 <Zaba_> ok
03:17:26 <jle`> return is type b -> IO b
03:17:35 <Aetherspawn> I know it can be done for static length arrays by using dropWhile (\(5:6:7) -> True; \_ -> False) ..
03:17:43 <jle`> so in this case, return is type [a] -> IO [a]
03:17:57 <jle`> so "return []" is of type IO [a]
03:18:16 <Zaba_> okay, in the case of an empty list
03:18:31 <Zaba_> oh, I think I now see the confusion
03:18:45 <jle`> well, you know that the function's input is a list
03:18:46 <fizruk> :t prefixOf
03:18:47 <lambdabot>     Not in scope: `prefixOf'
03:18:47 <lambdabot>     Perhaps you meant `prefixed' (imported from Data.List.Lens)
03:18:51 <Zaba_> it's sequence'' :: [IO a] -> IO [a]
03:18:52 <jle`> because you take a list in line 1
03:18:55 <jle`> yea
03:19:00 <jle`> and you know that the list contains IO a
03:19:02 <jle`> becuase of line 2
03:19:05 <jle`> your list is i:is
03:19:07 <fizruk> :t isPrefixOf
03:19:08 <lambdabot> Eq a => [a] -> [a] -> Bool
03:19:16 <fizruk> :t tails
03:19:17 <lambdabot> [a] -> [[a]]
03:19:17 <jle`> so when your list is i:is, the type of the list is the type of the i
03:19:21 <aico4> Hello, how  "m == transpose (transpose m)" property of transpose is called?
03:19:31 <jle`> and you see in line 3
03:19:34 <jle`> the type of the i is IO a
03:19:38 <Aetherspawn> isPrefixOf sounds wonderful
03:19:40 <Feuerbach> aico4: involution
03:19:51 <fizruk> > dropWhile ([5..7] `isPrefixOf`) (tails [1..100])
03:19:52 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
03:20:08 <jle`> so you know (1) you take in a list, (2) it's a list of i's, and (3) i is type IO a
03:20:15 <jle`> so you take in a list of IO a's
03:20:18 <aico4> Feuerbach: Thanks.
03:20:27 <Zaba_> [IO a] ?
03:20:31 <jle`> yes
03:20:40 <Zaba_> and I return IO [a]
03:20:44 <jle`> yes
03:20:51 <Zaba_> okay
03:20:55 <jle`> you also can tell you return IO a from line 5
03:21:02 <jle`> becuase you return $ a:as
03:21:06 <Zaba_> because of return
03:21:08 <jle`> a:as is a list
03:21:16 <jle`> and a is of type a
03:21:26 <Zaba_> okay, I think I got that
03:21:27 <Zaba_> thanks again!
03:21:32 <jle`> no problem
03:21:32 <Zaba_> but now the code won't compile
03:21:38 <Zaba_> Couldn't match expected type `[a]' with actual type `IO a'
03:21:43 <Aetherspawn> > dropWhile (not . isPrefixOf [2,3,4]) (tails [1..10])
03:21:44 <lambdabot>   [[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[5,6,7,8,9,10],[6...
03:21:47 <fizruk> > (!! 1) . dropWhile ([5..7] `isPrefixOf`) $ tails [1..100]
03:21:48 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
03:21:57 <jle`> did it compile before?
03:21:59 <fizruk> > (!! 1) . dropWhile (not . isPrefixOf [5..7]) $ tails [1..100]
03:22:00 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,...
03:22:05 <Zaba_> yes, without a signature it does
03:22:05 <fizruk> oh
03:22:17 <fizruk> > (!! 3) . dropWhile (not . isPrefixOf [5..7]) $ tails [1..100]
03:22:18 <lambdabot>   [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,3...
03:22:25 <Zaba_> and it gives the following signature
03:22:26 <Zaba_> sequence'' :: [[a]] -> [[a]]
03:22:34 <Zaba_> so there must be some other mistake
03:22:50 <jle`> that's funny
03:23:09 <Aetherspawn> (\x y -> (!! (length x)) . dropWhile (not . isPrefixOf x) $ tails y) [5..10] [1..50]
03:23:17 <Aetherspawn> > (\x y -> (!! (length x)) . dropWhile (not . isPrefixOf x) $ tails y) [5..10] [1..50]
03:23:18 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35...
03:23:24 <Aetherspawn> yay
03:23:25 <jle`> let me test it out
03:23:40 <fizruk> Aetherspawn, I have a feeling that's not nice :)
03:23:54 <Aetherspawn> :/ why not
03:25:34 <fizruk> :t splitOn
03:25:35 <lambdabot> Eq a => [a] -> [a] -> [[a]]
03:26:11 <Aetherspawn> dropWhile (not . isPrefixOf pat) (tails rest) !! length x
03:26:14 <Aetherspawn> that's okay, isn't it?
03:26:30 <Aetherspawn> woops, I changed the names, imagine x is pat
03:26:39 <jle`> oh okay
03:26:42 <jle`> Zaba_:
03:26:45 <jle`> your error is on line 7
03:26:51 <jle`> as <- is
03:26:54 <fizruk> Aetherspawn, perhaps there's a nice way with Data.List.Split
03:27:04 <jle`> you are in an IO monad
03:27:14 <Zaba_> what's the error?
03:27:16 <jle`> so your right hand side has to be an IO (something)
03:27:22 <Zaba_> ok
03:27:27 <jle`> but is is not an IO (something)
03:27:30 <jle`> what is is?
03:27:41 <jle`> heh.
03:27:46 <jle`> unfortunate naming
03:27:54 <jle`> what is the type of is?
03:28:08 <Zaba_> {IO a]
03:28:09 <Zaba_> ?
03:28:12 <jle`> yes
03:28:13 <Zaba_> [IO a]
03:28:19 <Aetherspawn> well
03:28:24 <jle`> but [IO a] is not IO (something)
03:28:27 <Aetherspawn> whats the disadvantage of the current solution
03:28:27 <jle`> so it won't fit there
03:28:29 <Zaba_> aha
03:28:29 <Aetherspawn> it's not performant?
03:28:32 <Fuuzetsu> @hoogle [IO a] -> IO [a]
03:28:33 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:28:33 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
03:28:33 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
03:28:48 <jle`> you're giving it away Fuuzetsu :P
03:28:51 <jle`> he is implementing sequence
03:29:01 <jle`> anyways my punchline now spoiled
03:29:12 <jle`> you need a function that turns [IO a] into IO [a]
03:29:15 <jle`> what is it...?
03:29:16 <Fuuzetsu> Oh, I thought you reached the point where you were going to let the cat out of the bag
03:29:33 <jle`> admittedly i am slightly long winded
03:29:44 <Zaba_> well, obviously I can't use "sequence" in that definition...
03:29:52 * Fuuzetsu reads up
03:29:53 <jle`> but you *can* use........
03:30:14 <jle`> (this was probably the first thing you learned in your course)
03:30:40 <jle`> anyways the answer is sequence''
03:30:49 <Zaba_> oh
03:30:51 <fizruk> Aetherspawn, I think it's okay, I just don't like how it looks like
03:30:57 <Zaba_> I was wondering where the recursive call was
03:31:12 <Zaba_> I tought it would have to come in the return statement
03:31:25 <jle`> it's weird isn't it
03:31:29 <Zaba_> so it's return $ a: sequence '' as ??
03:31:35 <jle`> hm
03:31:38 <jle`> not quite
03:31:42 <jle`> so remember, your problem was in line 7
03:31:46 <jle`> you couldn't do xs <- is
03:31:55 <jle`> becuase is is [IO a] and not IO [a]
03:32:06 <jle`> so you should do xs <- ?????
03:32:24 <Zaba_> as <- sequence'' is
03:32:27 <jle`> yes
03:32:44 <Zaba_> the Socratic method seems to pay off well ;)
03:32:47 <Zaba_> Thanks again for your help!
03:32:48 <fizruk> > splitOn [5..7] [1..100] !! 1
03:32:49 <lambdabot>   [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,3...
03:33:05 <Zaba_> so my teacher just made a mistake
03:33:05 <jle`> yes i do need to work on framing my questions a bit better though
03:33:18 <Aetherspawn> :t span
03:33:19 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
03:33:19 <jle`> then reason why it was compiling and inferring the type as [[a]]
03:33:27 <jle`> is slightly complicated
03:33:40 <jle`> but it's because you can put any monad on the right hand side of <-
03:33:57 <jle`> when you put an IO a, then the whole monad is an IO monad
03:34:07 <jle`> when you put a [a], then the whole monad as a [] monad
03:34:15 <jle`> IO a, [] a, they are both monads
03:34:35 <jle`> so you gave it an [IO a], so it thoguth the wohle thing was a list monad
03:34:38 <Aetherspawn> > (\pat lst -> snd $ span (not .isPrefixOf pat) lst) "def" ['a'..'z']
03:34:39 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
03:34:39 <lambdabot>              with actual ty...
03:34:47 <jle`> not sure if that made sense and it might have made things worse
03:34:50 <jle`> heh.
03:34:51 <Aetherspawn> > (\pat lst -> snd $ span (not .isPrefixOf pat) lst) [5..7] [1..10]
03:34:52 <lambdabot>   No instance for (GHC.Show.Show a0)
03:34:52 <lambdabot>    arising from a use of `M9057615800708...
03:35:46 <jle`> Zaba_: anyways, you would test this by giving it any list of IO objects that all return something of the same type
03:36:01 <fizruk> Aetherspawn, you still need tails to use span
03:36:05 <jle`> for example, [print 1, print 2, print 3, print 4], which is [IO ()]
03:36:10 <jle`> this should give you a list [(),(),(),()]
03:36:29 <fizruk> Aetherspawn, splitOn seems nice, but I can't figure out how to make it stop after first match
03:36:45 <jle`> or you could do [return 1, return 2, return 3, return 4] (or `map return [1..4]`...this should give you a list [1,2,3,4]
03:37:00 <jle`> or you could even do [getLine,getLine,getLine,getLine], and it'll give you a list of four strings
03:37:02 <Zaba_> okay, works
03:37:31 <Aetherspawn> are you sure I need tails to use span?
03:37:32 <Aetherspawn> :t span
03:37:33 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
03:37:52 <Aetherspawn> > span (/= '\n') "herp\nderp"
03:37:53 <lambdabot>   ("herp","\nderp")
03:37:54 <fizruk> Aetherspawn, sure, your predicate works on [a]
03:37:59 <Aetherspawn> oh.
03:38:13 <jle`> Zaba_: if you are interested in what IO actually "is", i wrote an article on it a couple of weeks ago http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
03:38:38 <jle`> i do not mention monads at all
03:38:59 <jle`> so if monadic terms and contexts are confusing you, maybe it could help
03:39:43 <Zaba_> jle`: thanks, I'll check out this article!
03:39:55 <jle`> excuse my shameless self absorbance!
03:40:04 <jle`> :)
03:41:28 <fizruk> byorgey, ping
03:42:36 <henk> hey, I’m trying to convert a unix epoch timestamp to format YYYY-MM-DD-HHMM. I think "formatTime" from Data.Time.Format should be the way to do it, but I don’t quite understand how to use it. (Is there anything else I should look at and consider using?) What exactly am I supposed to give for 't' in "formatTime :: FormatTime t => TimeLocale -> String -> t -> String"?
03:42:45 <fizruk> Aetherspawn, I guess splitOn should have a brother-function which takes an extra argument to limit number of splits
03:43:11 <fizruk> Aetherspawn, so your problem would be solved by splitOn' 1 [5..7] [1..100]
03:43:52 <Aetherspawn> > break (/= "\n") "herp\nderp"
03:43:52 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
03:43:53 <lambdabot>  Expected type...
03:44:06 <Aetherspawn> > (\pat lst -> snd $ break (not .isPrefixOf pat) lst) [5..7] [1..10]
03:44:07 <lambdabot>   No instance for (GHC.Show.Show a0)
03:44:07 <lambdabot>    arising from a use of `M6142708298863...
03:44:15 <profmakx> und der apple faehrt sich runter?
03:44:17 <Aetherspawn> oh, Im an idiot.
03:44:19 <profmakx> mrmph
03:44:58 <jle`> henk: t should be any instance of FormatTime
03:45:05 <jle`> which should be listed under the class definition
03:45:16 <jle`> http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Format.html#t:FormatTime
03:46:04 <jle`> the docs are not very helpful in this, but FormatTime represents any Time that can be queried for a %x code and return a string
03:46:27 <henk> jle`: argh, it’s the time I want to be formatted, right?
03:46:30 <jle`> this includes Day, UTCTime, TimeZone, TimeOfDay, ZonedTime, and LocalTime
03:46:35 <jle`> henk: yeah it is
03:46:40 <Aetherspawn> is there a safe head?
03:46:48 <fizruk> :t listToMaybe
03:46:48 <Aetherspawn> like, head or an empty list
03:46:49 <lambdabot> [a] -> Maybe a
03:46:49 <tovarish> Aetherspawn, case of
03:47:13 <Aetherspawn> oh, case of.
03:47:25 <fizruk> Aetherspawn, head or an empty list? take 1
03:47:29 <fizruk> :t take 1
03:47:30 <lambdabot> [a] -> [a]
03:47:35 <fizruk> > take 1 []
03:47:36 <lambdabot>   []
03:47:41 <fizruk> > take 1 [1, 2, 3]
03:47:42 <lambdabot>   [1]
03:47:43 <henk> jle`: thank you (that was rather dumb of me, right?)
03:47:50 <jle`> not dumb
03:48:05 <jle`> you just kind of have to know what to look for
03:48:10 <jle`> i've been stuck on things like this all the time
03:48:27 <jle`> basically you just follow the Class trails
03:48:33 <henk> oh ok, good to hear (; btw: thanks for that link regarding IO above, will read that too
03:48:47 <Aetherspawn> take 1 is elegant
03:48:54 <henk> well, rather for writing the article behind the link
03:49:09 <jle`> haha no problem.  it's just a matter of getting used to navigating haddock
03:49:14 <jle`> haddoc?
03:49:21 <jle`> which is admittedly not very intuitive the first few times
03:49:37 <jle`> get used to this link clicking dance
03:49:47 <jle`> and akwardly named typeclasses
03:50:02 <jle`> and undocumented typeclasses >>
03:50:33 <jle`> but yeah just look at the list of instances.
03:50:41 <henk> hrhr will try to, thanks (;
03:51:09 <jle`> if you have the libraries loaded
03:51:13 <jle`> you can do :info FormatTime
03:51:15 <jle`> in ghci
03:51:39 <fizruk> :t stripPrefix
03:51:40 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
03:52:10 <jle`> Aetherspawn: take 1 is elegant but i feel like you are back to square 1 in the first place in most use cases of head
03:52:18 <henk> jle`: yes, I learned about that recently (: I love haskell for things like that!
03:52:51 <jle`> i mean...you usually use head to get the first element, but if you use take 1, you still need to head or pattern match out of it, or handle the empty list case
03:52:59 <fizruk> > mconcat $ stripPrefix [5..7] <$> tails [1..100] -- Aetherspawn
03:53:00 <lambdabot>   Just [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
03:53:38 <Aetherspawn> hey, that's cool
03:54:28 <fizruk> Aetherspawn, note that this version is both safe and efficient
03:54:38 <fizruk> and nice :)
03:55:47 <fizruk> > F.foldMap (stripPrefix [5..7]) . tails $ [1..100]
03:55:48 <lambdabot>   Just [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
04:06:06 * hackagebot grid 7.5 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.5 (AmyDeBuitleir)
04:07:21 <dv-> oo
04:13:33 <mlen> Is there an epub version of Monad.Reader issues?
04:56:21 <henk> hm, finding out how to properly and elegantly handle time information is a lot more difficult than it seems to be … Can anyone recommend a way to transform a String in the form "H:MM:SS" to a String of only seconds? i.e. 1:01:20 would become 3680
04:59:57 <quchen> henk: That's a two-part process. 1.: convert the first string into an internal data representation (i.e. parsing it).
05:00:05 <quchen> 2. Convert the data to seconds.
05:00:09 <quchen> Are you familiar with parsing?
05:03:28 <henk> quchen: I know what it means, but I’m not sure I know the best way to parse this or even what format to parse it to …
05:04:11 <quchen> henk: Alright, so let's work on the format. The answer is almost in your source string "H:MM:SS".
05:04:15 <quchen> It consists of ..?
05:04:58 <henk> integers seperated by colons?
05:05:27 <quchen> Right. What would be a datatype that stores that information? Remember that the colons aren't important for the data, they just prettify the input.
05:06:18 <quchen> By the way, how much do you know about Haskell? Did you read LYAH, for example? Started RWH?
05:06:32 <quchen> That makes it easier to estimate what kind of things I can tell you
05:08:50 <donri> henk: https://www.haskell.org/haskellwiki/Time
05:09:22 <henk> quchen: I started with both, but at least LYAH is too much theory. I need practice to actually learn and remember things. I get back to LYAH from time to time and reread things and go on a little further. I’m on "beginner level" in a few programming languages and learn programming for personal fun and profit, not to earn a living with. Really new to haskell, haven’t understood monads yet for example …
05:09:44 <henk> quchen: Not sure what datatype does, I’d be guessing … DiffTime maybe?
05:10:18 <quchen> henk: Well, you could just handroll your own type, like "data HMSTime = HMS Int Int Int", which stores Hours/Minutes/Seconds.
05:11:38 <donri> >>> utcTimeToPOSIXSeconds (readTime defaultTimeLocale "%T" "01:01:20")
05:11:38 <donri> 3680 s
05:11:54 <quchen> To understand monads use them. You can read about them a million times, but that won't replace writing your own test code with Maybe, State, Writer, IO. Basically this: https://github.com/quchen/articles/blob/master/fbut.md#i-dont-understand-monads
05:11:57 <henk> oh btw: I need this to convert my own task/time tracker format to a different format which my employer expects me to give to him. In my own tracker I have a function secondsToHMMSS, but I think reversing that process is not as easy as it sounds, I’ll pastebin my tracker fyi
05:12:41 <lpaste> henk pasted “diddohs” at http://lpaste.net/96371
05:13:23 <quchen> henk: As soon as you have your HMSTime, you can easily convert it to "data Seconds = Seconds Int" via "convert (HMSTime h m s) = Seconds (3600*h + 60*m + s)".
05:13:34 <quchen> The problem is really just going from String to HMSTime.
05:14:04 <henk> quchen: working on that, and I think I’m using them already … Many times in haskell I’m like "hu? WTF? I have absolutely no idea what’s going on there" only to notice a few days/weeks later "oh my god, how could you not get that before? It’s so easy and straightforward!"
05:14:28 <quchen> Better get used to that feeling :-þ
05:14:43 <henk> donri: Thank you, that looks sensible, I’ll try that out (:
05:15:17 <henk> quchen: my own types will probably be one of these cases, I feel I’m really close to understanding them, just a few bits still missing …
05:15:22 <quchen> henk: What you're doing in your code is basically using strings as your data.
05:15:39 <quchen> That's almost never a good idea. You always want to convert things into their own data representation.
05:16:10 <henk> quchen: oh, that convert line looks nice too …
05:17:11 <henk> quchen: Yeah, but I have not quite understood datatypes yet, or rather how to make my own … ATM I’m constantly tweaking my programs to become cleaner, easier to read, saner to work with, … Still learning something new every time I touch haskell code (;
05:17:55 <henk> I’ll certainly change that, but ATM I need to get that converter done in whatever way will do, as I need to report my worktime to my employer until sunday.
05:19:33 <henk> For now I’ll go with donris solution, but creating datatypes specific for how I use time in my tracker seems cleaner, so I’ll adjust that when I find time[tm]
05:20:37 <donri> or use the datatypes provided by the time package :)
05:21:37 <henk> donri: haddock confuses me there, my mind can’t keep up with all these different formats, functions, etc ):
05:21:47 <donri> yeah it's a bit complex
05:21:58 <donri> reflecting the complexity of accurate and precise time handling
05:24:17 <henk> Yeah, nice to have these possibilities, but confusing if you are only looking for one (in your eyes) simple solution …
05:24:19 <donri> >>> timeOfDayToTime (readTime defaultTimeLocale "%T" "01:01:20")
05:24:20 <donri> 3680 s
05:24:24 <donri> maybe more sensible ^
05:24:56 <henk> But it’s not timeOfDay, it’s just a "duration" (not sure that is the right word, though. It’s the time needed for one task.)
05:25:21 <quchen_> I think Data.Time might be a little too much if you're not yet through LYAH.
05:26:08 <donri> henk: yes, that's what timeOfDayToTime is for
05:26:14 <donri> henk: it converts it to DiffTime
05:27:43 <henk> donri: ah, hm, ok - my mind is starting to complain: too many possibilities using different ways … I hate choice (;
05:28:27 <henk> quchen_: I already use parts of it (see the pastebin) but definitely don’t understand every part of it …
05:31:53 <donri> henk: did you say you like choice? let me tell you about the alternative thyme package!
05:33:17 <henk> diddohs2ctt.hs: readsTime: bad input "383170:20:56"
05:33:34 <henk> donri: WAAAAH, I’m not listening, lalalala
05:34:43 <quchen_> donri: An alternative time package? Sounds good. Data.Time and me are a bit at war.
05:37:26 <donri> henk: ah eh, yeah, it only wants two digits
05:37:47 <donri> henk: it seems you're inventing your own time format, maybe you'll need to parse it yourself then :)
05:39:01 <henk> So I guess I need to do my own datatypes now anyway …
05:40:39 <lemao> could someone recommend a simple (the simplest) json lib for haskell? I have a json doc with at most 20 elements that I need to serialize/deserialize only once at the beginning. I am looking for minimal dependencies.
05:41:38 <fabjan> §¶½ allaandra tangenter skriver det jag tänker mig ÅÄÖ¡£$£¥$¥5€4$6¥
05:42:10 <donri> >>> let [h,m,s] = map read $ splitOn ":" "383170:20:56" in 3600*h + 60*m + s
05:42:10 <donri> 1379413256
05:42:24 <fabjan> whoops
05:42:59 <donri> henk: ^ using split package
05:43:38 <donri> it will crash in your face on bad input but hey
05:43:59 <donri> (actually so did the time version because we used readTime instead of parseTime ;))
05:44:20 <henk> donri: You are purposefully trying to confuse me, right?
05:44:37 <donri> henk: hah no, why?
05:45:45 <donri> >>> let [h,m,s] = map read $ splitOn ":" "01:01:20" in 3600*h + 60*m + s
05:45:46 <donri> 3680
05:45:47 <donri> etc
05:54:41 <henk> because I am confused (;
06:07:38 <donri> henk: well in this version we're just splitting the string on ":", parsing each string to some number type and then doing the time math directly
06:09:14 <henk> I probably need food and less headache to cope with it …
06:42:18 <halcyon10> Hi, anyone know if there's a release date for the 2013.4.0.0 Haskell Platform yet?
06:43:28 <Ick> Dear Jake: If you are out there and the names Aaron Austin and Dom mean anything to you, get in touch man, we miss ya. <3
06:54:51 <Gowilla> halcyon10: I doubt it, the contents are still being figured out
06:55:29 <halcyon10> Gowilla: i see
07:05:03 <henk> o_O is quchen still here? Tab completion does not find him, but I don’t see when he left …
07:06:23 <alexander__b> henk: he left.
07:06:31 <chrisdone> he's gone. they're all gone.
07:07:10 <henk> strange, I see no quit message for him o_O
07:07:38 <chrisdone> https://www.youtube.com/watch?v=yRujuE-GIY4&t=0m44s
07:12:22 <geekosaur> [29 14:04] * quchen_ has quit (Remote host closed the connection)
07:13:42 <henk> geekosaur: Interesting, I don’t see that here … Ah well, maybe some setting in my client.
07:13:46 <henk> geekosaur: thanks
07:18:14 <henk> He told me to use my own datatypes for time in HMS and Seconds format and use a function to convert from HMS to Seconds. These types use Ints, but I only have Strings and, maybe due to my lack of understanding or experience with creating my own datatypes, I’m not quite sure how to go about that. I’m not even quite sure how to phrase my question sensibly really … I have a String like "1:01:20" and want
07:18:17 <henk> "3680" as a result. My datatypes are "data HMSTime = HMS Int Int Int" and "data Seconds = Int", and the convert function is "convert (HMS h m s) = Seconds (3600*h + 60*m + s)". Would anyone please give me a hint how to work with these?
07:19:51 <nouitfvf> > :k Integer
07:19:52 <lambdabot>   <hint>:1:1: parse error on input `:'
07:20:07 <nouitfvf> :k Integer
07:20:08 <lambdabot> *
07:21:29 <nouitfvf> > tail . tail $ [1, 2, 3]
07:21:30 <lambdabot>   [3]
07:22:26 <nouitfvf> :t [3]
07:22:27 <lambdabot> Num t => [t]
07:23:07 <highPriestLOL> ola *
07:23:40 <highPriestLOL> would you point me to any good resources regarding GUI dev with Haskell
07:23:58 <highPriestLOL> That's what I would love to jump into in the leanring process
07:24:18 <nouitfvf> > tail <*> [1, 2, 3]
07:24:19 <lambdabot>   Couldn't match expected type `[a0 -> b0]'
07:24:19 <lambdabot>              with actual type `[a...
07:24:35 <nouitfvf> > tail <$> [1, 2, 3]
07:24:36 <lambdabot>   No instance for (GHC.Show.Show a0)
07:24:37 <lambdabot>    arising from a use of `M3374048212946...
07:32:03 <dcoutts> zenzike: ah I see why the HDBC-odbc docs are not building
07:32:21 <dcoutts> just wrong markup that's all
07:35:27 <donri> dcoutts: i guess it's known/planned that reports don't show up on the package information pages?
07:35:51 <dcoutts> donri: yes they don't show up yet, they need proper presentation
07:36:02 <dcoutts> currently just use Show :-)
07:36:28 <donri> dcoutts: yeah, but honestly i'd rather have it at least link that if there is any reports at all, than have it be silent on the matter :)
07:36:52 <donri> or at least say "build failed" so you know it at least tried
07:36:57 <dcoutts> I think if one is going to spend 30 min on it, might as well do it properly
07:37:37 <dcoutts> donri: yeah now that's an interesting problem, I'm not sure how to say "build failed" when we have half a dozen reports and some work and some don't
07:37:37 <donri> fair
07:37:52 <donri> ah i thought build succeeded = no reports
07:38:01 <dcoutts> no
07:38:07 <dcoutts> you get reports of successful builds too
07:39:02 <donri> does it not record the exit status of the build process?
07:40:01 <donri> installOutcome = InstallOk, docsOutcome = Ok -- guess you'd need to look at these?
07:40:32 <donri> oh but you're saying a single version can have multiple reports with different "outcomes"?
07:40:42 <dcoutts> donri: my point is, if we have 3 reports that say it worked and 3 that say it failed, what summary do we report?
07:40:55 <donri> i see :)
07:42:28 <dcoutts> donri: there are reasonable answers of course, but it's not trivial
07:42:38 <donri> yep
07:42:52 <dcoutts> and it'll get more fun when we have 1000 anonymous build reports
07:45:01 <danilo2> Hello :) When you are spawning some cmd command processes and you are reading their output, are you using System.Process for that, or is there any other library I should use?
07:45:35 <dcoutts> danilo2: System.Process is fine for that
07:45:41 <dcoutts> use readProcess probably
07:46:20 <donri> incidentally i think the stop words stuff in hackage-server is a bane more than an aid https://hackage.haskell.org/packages/search?terms=process
07:46:32 <Taneb> Text.Parsec.string isn't backtracking, is it?
07:46:45 <dcoutts> donri: no, that's not a stop word, I've fixed that, just need to get the new code running
07:46:52 <danilo2> dcoutts: Ok, thank you :)
07:46:59 <donri> aha
07:47:12 <dcoutts> donri: see http://beta.hackage.haskell.org/packages/search?terms=process
07:47:15 <Feuerbach> Taneb: what do you mean, exactly?
07:47:28 <donri> dcoutts: cool :)
07:47:45 <dcoutts> donri: in fact, see http://beta.hackage.haskell.org/packages/search?terms=process&explain
07:48:06 <Taneb> Feuerbach, like, can I say «choice [string "you", string "yes"]»
07:48:15 <Taneb> And it will match on you and match on yes
07:48:44 <Taneb> Because (I think) if it isn't backtracking it will consume the y and then fail if the text is yes
07:48:46 <Feuerbach> I think it won't. Use "try . string" for that
07:51:07 <Feuerbach> it's not because string isn't "backtracking". It's because string isn't "atomic"
07:51:26 <Feuerbach> it can consume some characters and then fail
07:51:59 <Taneb> Oh, okay
07:52:12 <Taneb> (that was what I meant, I just had the wrong word. I know now :) )
07:52:16 <Taneb> Feuerbach++
07:52:18 <Taneb> Thanks
07:52:39 <Feuerbach> yw
07:54:40 <ctrl_> If lazy IO is dangerous and somewhat buggy, why is it default?
07:55:16 <Taneb> ctrl_, because almost everything is either really complicated or dangerous and bugger
07:55:19 <FireFly> Is it dangerous and buggy?
07:55:20 <Taneb> *buggy
07:55:32 <fizruk> ctrl_, I guess there's no common substitution
07:55:37 <donri> ctrl_: i don't think it's buggy, just not always that predictable
07:56:10 <FireFly> Acme.Missiles, now that is a dangerous module
07:56:50 <Taneb> FireFly, I think it's bugged, I tried to use it to launch some missiles but it didn't
07:59:42 <fizruk> Taneb, how'd you check it didn't?
08:01:06 <Taneb> fizruk, I was next to the missile silo
08:02:23 <fizruk> you know there's more than one of those :p
08:11:27 * hackagebot creatur 4.1.4 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-4.1.4 (AmyDeBuitleir)
08:11:31 <Shapeshifter> So, who's actually developing Haskell? Is it still this "committee" that they made in 1990? I know SPJ works on it a lot, but other then that?
08:11:52 <Shapeshifter> I mean, who's behind haskell?
08:12:57 <Fuuzetsu> Shapeshifter: There's a committee which gets together every now and again and decides on the standard. The committee rotates every few years. Just recently a new committee was picked. SPJ works on GHC, the Haskell compiler, along with a lot of other great people (and you could join them!)
08:13:30 <Sonderblade> spj doesn't anymore
08:14:05 <fryguybob> Sonderblade: SPJ works on GHC, Simon Marlow now works at Facebook and works less on GHC.
08:15:37 <Shapeshifter> So, does the development mostly occur in individual people's homes or are there unis/companies that could be considered as being involved in haskell a fair bit? It's just that I was asked "who's behind haskell" and this is kinda easy to answer for many other languages, but not this one
08:15:54 <Shapeshifter> Isn't spj with microsoft actually...
08:16:08 <Fuuzetsu> Shapeshifter: MS funds him to work on GHC
08:16:19 <Fuuzetsu> MSR to be more precise
08:17:00 <Fuuzetsu> Shapeshifter: re: who's behind it: committee behind standard, GHC people behind, well, GHC, and everyone else behind all the libraries
08:17:14 <Fuuzetsu> there are a few Haskell companies, like FPComplete
08:17:56 <Shapeshifter> was Simon Marlow also funded by MS?
08:19:16 <danr> they were both working on MSR Cambridge
08:19:32 <danr> but Marlow left, but PJ (and Vytiniotis) are still there
08:19:47 <Shapeshifter> mhm
08:37:31 <Museifu> hi
08:59:39 <highPriestLOL> any useful links for GUI development?
09:06:19 <Fuuzetsu> Does anyone know how I could download everything from http://code.haskell.org/SLPJ-collaborative-papers/pj-lester-book/ ? I don't have code.haskell.org shell account where I could just scp -r that directory
09:07:27 <Fuuzetsu> nevermind, I'll just wget it all
09:08:44 <klrr_> Fuuzetsu: there is a firefox plugin for that
09:09:02 <Fuuzetsu> I think ‘wget -r -np URL’ was less effort
09:09:25 <klrr_> sure thing, i dont know wget(1)
09:17:43 <chrisdone> any renoise users?
09:38:16 <radish> what is non-exhaustive patterns in case x of?
09:39:12 <simpson> radish: You didn't match all possible patterns.
09:39:33 <radish> simpson: i though a -> matches everything
09:40:01 <Shapeshifter> Do language extensions (enabled using language pragmas) ever change the behavior of existing code, even if the code is not modified? I mean, could I tell from only looking at Haskell code wether or not a language pragma was used without looking at the top of the file?
09:40:07 <simpson> radish: Pastebin your code?
09:40:37 <simpson> radish: `case x of { True -> something }` would be non-exhaustive because `False` wasn't matched.
09:41:06 <radish> case x of True -> return () something'else -> return ()
09:41:25 <radish> shouldn't something else match everything else?
09:41:39 <radish> same as _ -> return ()
09:41:44 <radish> right?
09:41:46 <c_wraith> yes,
09:41:49 <geekosaur> Shapeshifter, sometimes they steal new keywords that something might be using as a variable, although most code tries to avoid that
09:41:57 <radish> c_wraith: yes to me?
09:41:59 <fizruk> radish, it should, paste actual code?
09:42:10 <c_wraith> radish: but that's because of the pattern not constraining the value, not the ->
09:42:39 <geekosaur> (I should say binding there)
09:42:48 <Shapeshifter> geekosaur: interesting
09:43:00 <radish> c_wraith: the weird thing is, all of the cases are there anyway
09:43:02 <geekosaur> so for example in haskell98 and haskell2010 without extensions, `forall` is a valid name you could use for a binding or function
09:43:43 <radish> should it match with a -> () with Maybe _?
09:43:45 <enthropy> > let x = 2 in succ $x
09:43:46 <lambdabot>   3
09:44:20 <c_wraith> radish: put the complete code you're having trouble with on lpaste. I think it's the only way we'll be able to help
09:44:50 <enthropy> that won't work if you have -XTemplateHaskell... there's a summary at the bottom of http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/syntax-extns.html
09:45:40 <radish> nah you guys take it easy i'm gonna try to poke at it and see what happens.
09:45:50 <radish> i always make these weird rookie mistakes lol
09:46:02 <radish> i'm sure it'll make itself obvious
09:46:17 <radish> but i'll hpaste if i get desperate and thank you
09:46:46 <fryguybob> radish: Nested case statements and mixing tabs an spaces?
09:47:26 <radish> fryguybob: very possible i accidentally tabbed at some point but i thought i had it set up to replace tabs with spaces lol
09:48:53 <radish> wow wtf i took out the case and i'm still getting the error
09:50:23 <radish> different source of non-exhaustive patterns - the case thing is causing pattern-overlap
09:50:28 <radish> whats that?
09:50:46 <c_wraith> you can also have non-exhaustive patterns in function definitions
09:50:52 <c_wraith> since those implicitly are case statements
09:51:08 <radish> c_wraith: okay thanks
09:53:43 <radish> god i have no idea lol, i need to refactor badly anyway.
09:54:50 <c_wraith> you might just accidentally fix it doing that. :)
09:56:53 <radish> kind of mysterious though lol i'm intrigued
09:57:11 <radish> it was working like 5 minutes ago but theres no way for me to figure out why it isnt now
10:01:04 <Javran> @hoogle [a -> m b] -> a -> m b
10:01:05 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:01:05 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:01:05 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:01:22 <radish> lol computer went crazy
10:01:37 <radish> because i changed a list from 4..1 to 1..4
10:01:42 <radish> had to crash it lol
10:01:55 <radish> it should /not/ be doing /that/
10:01:59 <radish> :D
10:02:06 <radish> and to think my code is so pure!
10:02:09 <radish> :'(
10:02:23 <Javran> @hoogle [a -> m a] -> a -> m a
10:02:24 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
10:02:24 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
10:02:24 <lambdabot> Control.Seq withStrategy :: Strategy a -> a -> a
10:03:41 <radish> i don't even
10:05:03 <chrisdone> radish: radish as in the vegetable or radish as in rad-ish?
10:05:22 <radish> chrisdone: both of course!
10:06:47 <radish> chrisdone: totally tanked my computer just now lol
10:07:32 <chrisdone> rad!
10:08:22 <chrisdone> donri: say västkustskt kvistfritt kvastskaft =p
10:08:46 <donri> typiskt västkustskt
10:09:44 * chrisdone needs to check his haskell guide to swedish
10:11:57 <chrisdone> tharper: try to say västkustskt kvistfritt kvastskaft
10:12:31 <donri> > swedish "västkustskt"
10:12:32 <lambdabot>   Not in scope: `swedish'
10:12:37 <tharper> heheh
10:12:46 <tharper> It means "west coastish"
10:12:53 <Rylee> > [4..1]
10:12:54 <lambdabot>   []
10:13:02 <tharper> the other two words are rather easy to say, heh
10:13:06 <donri> > [4,3..1]
10:13:07 <lambdabot>   [4,3,2,1]
10:13:19 <radish> well that explains some things
10:13:45 <radish> never assume you've ensured pattern match safety lol
10:13:49 <radish> lesson learned
10:14:28 <FreeFull> @let swedish = intersperse 'f'
10:14:30 <lambdabot>  Defined.
10:14:41 <chrisdone> > swedish "västkustskt"
10:14:43 <FreeFull> >  swedish "västkustskt"
10:14:44 <lambdabot>   "v
10:14:45 <lambdabot>   "vf\228fsftfkfufsftfsfkft"
10:15:01 <chrisdone> huh. lambdabot had a problem there
10:15:02 <FreeFull> > var $ swedish "västkustskt"
10:15:03 <lambdabot>   vfäfsftfkfufsftfsfkft
10:15:10 <chrisdone> seems legit
10:15:14 <FreeFull> lambdabot does sometimes cut off early
10:15:52 <_justjust> @t var
10:15:53 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:16:02 <chrisdone> @ty var
10:16:03 <lambdabot> String -> Expr
10:16:03 <_justjust> @type var
10:16:04 <lambdabot> String -> Expr
10:16:25 <chrisdone> @todo
10:16:25 <lambdabot> 0. SamB: A way to get multiple results from a google search
10:16:25 <lambdabot> 1. dons: improve formatting of @dict
10:16:25 <lambdabot> 2. dons: write Haskell Manifesto
10:16:25 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
10:16:26 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
10:16:27 <lambdabot> [37 @more lines]
10:16:28 <chrisdone> O_O
10:16:36 <chrisdone> i wonder how old those are
10:17:42 <geekosaur> #2 is ancient
10:18:01 <geekosaur> when's the last time dons was worried about such things >.>
10:18:01 <khyperia> ghc commandline question: if I want to do a --make on a root directory, pointing at src/Main.hs, lumping all temporary files (.hi and .o) into obj/[...], and final executable into bin/[...], what would that look like?
10:18:44 <chrisdone> there's a -tmpdir flag or something to that effect
10:18:45 <khyperia> I got to "ghc -odir obj -outputdir bin --make src\Main.hs" but the .hi files are alongside the stuff in src
10:18:51 <khyperia> oh, awesome
10:20:19 <khyperia> hmm... doing "ghc -tmpdir obj --make src\Main.hs" throws a file not found error.
10:20:34 <geekosaur> there's another option for that. but this is kinda not really the use case for ghc --make
10:21:31 <Rylee> @src intersperse
10:21:31 <lambdabot> intersperse _   []     = []
10:21:31 <lambdabot> intersperse _   [x]    = [x]
10:21:31 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
10:21:34 <geekosaur> -ohi dir
10:21:48 <geekosaur> see http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html
10:22:12 <geekosaur> also tmpdir is not what you want, it's for intermediate files that will be removed unless you specified keeping them
10:23:06 <geekosaur> maybe you wanted -outputdir ?
10:23:23 <khyperia> ah, yeah, -outputdir is what I want
10:25:03 <khyperia> final solution was "ghc -outputdir obj -o main --make src\Main.hs"
10:25:10 <khyperia> thanks!
10:32:20 <ocharles> argh, why does Data.Map.union have such a useless type
10:32:30 <scshunt> :t Data.Map.union
10:32:31 <lambdabot> Ord k => M.Map k a -> M.Map k a -> M.Map k a
10:32:35 <scshunt> why is that useless?
10:32:42 <ocharles> because I want to union with (,)
10:32:44 <geekosaur> what were you looking for / expecting?
10:32:51 <geekosaur> :t Data.Map.unionBy
10:32:52 <lambdabot>     Not in scope: `Data.Map.unionBy'
10:32:52 <lambdabot>     Perhaps you meant `Data.List.unionBy' (imported from Data.List)
10:32:56 <geekosaur> bah
10:33:01 <ocharles> I meant unionWith in my rant
10:33:05 <ocharles> :t Data.Map.unionWith
10:33:05 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
10:33:22 <ocharles> mergeWithKey looks more useful
10:33:40 <geekosaur> this does not sound like a union operation, yes
10:33:59 <ocharles> oh, I want intersectionWith I think
10:34:43 <chrisdone> what's an identifier that has a nice long haddock entry?
10:34:50 <chrisdone> in base or w/e
10:37:29 <chrisdone> i'll look in Control.Concurrent.*, there's bound to be long docs in there
10:37:48 <chrisdone> throwTo. now that's a long description
10:37:48 <geekosaur> quite.
10:42:09 <Fuuzetsu> chrisdone: lens has some long docs
10:42:37 <Fuuzetsu> Do you have a Haddock question? Maybe I could answer.
11:01:01 <chrisdone> Fuuzetsu: no, i'm making an emacs viewer for haddocks and i wanted some long ones to test
11:01:36 <Fuuzetsu> Oh, cool. Got a screenshot?
11:01:46 * hackagebot BlogLiterately-diagrams 0.1.3 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.3 (BrentYorgey)
11:05:42 <enthropy> chrisdone: http://hackage.haskell.org/package/sessions-2008.7.18/docs/Control-Concurrent-Session.html
11:06:49 <chrisdone> enthropy: i meant long haddock markup
11:15:21 <Fuuzetsu> chrisdone: you could open some Haddock test files
11:16:22 <Fuuzetsu> chrisdone: about half way down https://github.com/Fuuzetsu/haddock/blob/master/html-test/src/Test.hs is a pretty good example
11:18:35 <byorgey> fizruk: were you looking for me?
11:19:59 <Ick> Dear Jake: If you are out there and the names Aaron Austin and Dom mean anything to you, get in touch man, we miss ya. <3
11:20:47 <fizruk> byorgey, oh nothing serious. I just thought splitOn from split package might have a brother with an extra argument to specify maximum number of splits :)
11:26:53 * hackagebot chell 0.3.1 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.3.1 (JohnMillikin)
11:29:19 <radish> does return break a do block?
11:29:32 <ion> no
11:29:36 <radish> thanks
11:29:36 <Fuuzetsu> no, return doesn't do anything like that, it's just a regular function
11:30:02 <ion> do { a <- something; b <- return a; return b }
11:30:09 <ion> do { a <- something; return a }
11:30:14 <ion> do { something }
11:30:16 <ion> are all the same
11:30:19 <Fuuzetsu> 2 returns! Preposterous!
11:30:41 <geekosaur> well, that code was preposterous but not for that reason >.>
11:30:43 <ion> If you add something else in the end of all the blocks, it’s still exactly the same.
11:30:47 <chrisdone> Fuuzetsu: nothing special, just dumbing individual entries http://chrisdone.com/haddock.png
11:32:10 <radish> is there a standard function for something like if a then Just b else Nothing?
11:32:27 <mlen> chrisdone: what wm do you use?
11:33:02 <ion> radish: b <$ guard a
11:33:28 <radish> ion: how standard is that?
11:33:34 <Shapeshifter> Every single time I want to try out something through cabal, the build fails. Sometimes I doubt wether there are any buildable packages left up there
11:33:35 <chrisdone> mlen: xmonad
11:33:46 <Shapeshifter> src/Text/PrinterParser.hs:230:42: Not in scope: `catch' whohoo
11:33:54 <chrisdone> Fuuzetsu: the entry point is either from directly in code, or here: http://chrisdone.com/hoogle-searchy.png
11:33:56 <Shapeshifter> There's always something...
11:34:08 <ion> radish: Or “when a (Just b)”
11:34:10 <chrisdone> Fuuzetsu: i haven't (yet) made a complete module doc browser
11:34:16 <mlen> chrisdone: do you have configs somewhere online?
11:34:24 <ion> radish: Oh, sorry. The latter won’t work.
11:34:34 <radish> ion that returns () right?
11:34:40 <Fuuzetsu> chrisdone: How do you feel about all the new syntax and semantics that will hopefully soon go upstream?
11:34:42 <radish> ion: thats more like a break
11:36:18 <chrisdone> Fuuzetsu: i'm not aware of any new developments. i tend to write as little haddock as possible
11:36:22 <chrisdone> mlen: https://github.com/chrisdone/xmonad-chrisdone
11:37:32 <byorgey> fizruk: no, it doesn't.  But patches/feature requests are welcome!
11:37:38 <chrisdone> Fuuzetsu: although i am interested in making a texinfo generator for haddock
11:37:50 <Fuuzetsu> oh, I think I misinterpreted what you were doing. I thought you were doing some cool in-emacs Haddock rendering (although I admit I don't see much point in that seeing as it's human readable already)
11:38:52 <chrisdone> nope -- rather i take the plain-text version of haddock and do some minimal paragraph filling and syntax highlighting
11:39:02 <Fuuzetsu> chrisdone: I'd suggest that you give the LaTeX back-end some love instead and then use something like pandoc to get texinfo out of it.
11:41:30 <chrisdone> Fuuzetsu: possibly, but i'd rather it be part of haddock so that cabal installing a package can install texinfo data
11:41:52 <chrisdone> similar to the way it can generation haddock html docs and update the index
11:41:57 <chrisdone> and, sometimes, hoogle
11:43:12 <radish> ion: can you link me to more information on the $> operator?
11:43:25 <radish> ion: <$ *
11:43:36 <Fuuzetsu> Well, I just don't want yet another back-end that will get some attention to scratch an itch and then bitrot away… Currently Hoogle and LaTeX back-ends are in dire need of some love so ideally one would work on those rather than take even more back-ends. It's a large maintenance burden.
11:44:27 <ion> radish: guard False = Nothing, guard True = Just (). foo <$ Just bar = Just foo, foo <$ Nothing = Nothing
11:44:28 <Fuuzetsu> Although if you did write a texinfo back-end, we might be able to get rid of the LaTeX one although you'd have to discuss that with solirc and e-mail Simon Marlow as he's the one that put it in so he obviously ha[sd] some use for it.
11:44:49 <chrisdone> Fuuzetsu: if i could just take a haddock file with the API and get a haddock document that i could manipulate and generate whatever i wanted, like in pandoc, that would be better
11:45:07 <shapr> Man, I need to update my haskell-mode
11:45:12 <shapr> haven't done much of anything lately.
11:45:21 <chrisdone> last time i tried to use the haddock api i didn't have a good experience
11:45:28 <radish> ion: so hard to search for haskell operators on the web lol
11:45:46 <ion> @where hoogle
11:45:46 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:45:50 <ion> radish: ↑
11:45:50 <geekosaur> radish: hayoo, hoogle, symbolhound as last resort
11:46:30 <chrisdone> Fuuzetsu: it's more likely that i'd just keep a local patched copy for a while
11:46:39 <Fuuzetsu> chrisdone: There are Haddock interface files.
11:46:41 <radish> ion: thanks a million, ion
11:46:44 <chrisdone> rather than submitting anything upstream that people are going to moan about
11:47:09 <shapr> I did something with haddock interface files once, I remember it being no fun at all.
11:47:32 <shapr> I do wish the literate LaTeX .lhs and haddock had some meeting in the middle though.
11:48:10 <Fuuzetsu> protip: if you wish for features, it's usually useful to say so on the bug tracker!
11:48:21 <lispy> lambdabot: that todo is from antiquity!
11:48:54 <Fuuzetsu> So far, Haskell hasn't allowed me to read minds. Maybe edwardk will release a mind reading package soon though.
11:48:58 <chrisdone> lispy: and the message you're referring to is so, like, 5 minutes ago
11:49:17 <geekosaur> unsafeChangeMind seems almost more likely >.>
11:49:42 * shapr looks at Fuuzetsu's github repos
11:50:09 <shapr> Fuuzetsu: neat stuff!
11:50:26 <chrisdone> trac.haskell.org is where tickets go to die
11:50:41 <shapr> chrisdone: Where do things get fixed?
11:51:33 <chrisdone> shapr: github! which some projects have an aversion to
11:51:43 <chrisdone> speaking of which, i might do a bit of hackage hacking
11:53:24 <Fuuzetsu> shapr: it's all terrible
11:53:37 <shapr> Fuuzetsu: It gets better :-)
11:53:39 <Fuuzetsu> I should stop lazying around in #haskell and write some code
11:54:14 <shapr> Fuuzetsu: me too!
11:54:16 <KoRnshell> Are there any things that can go horribly wrong by just using x = unsafePerformIO random at the top level?
11:54:26 <KoRnshell> where random generates a random integer in the IO monad?
11:55:17 * chrisdone ♥'s the --dry-run flag of cabal
11:55:26 <fryguybob> KoRnshell: Yes you will have an x with random values.
11:55:28 <geekosaur> KoRnshell, it can get inlined at use sites, so each one gets its own random instead of the shared one you intended
11:55:29 <c_wraith> KoRnshell: you can end up with *different* values for x in different places it's used, if GHC decides to inline the definition at use sites
11:55:34 <Fuuzetsu> KoRnshell: Terrible things always happen.
11:55:45 <Fuuzetsu> unsafe* should be called reallyTerrible*
11:55:48 <chrisdone> KoRnshell: don't worry, go for it
11:55:57 <KoRnshell> Ah, a rebell, I like it
11:55:58 * chrisdone wanted to be the dissenter in the mob
11:56:03 <KoRnshell> I like it.
11:56:09 <fryguybob> chrisdone++
11:56:09 <KoRnshell> Diversity breeds strength
11:56:19 <chrisdone> \o/
11:56:21 <geekosaur> good way to learn what not to do, at least...
11:56:33 <Fuuzetsu> I don't like diverse results in my program.
11:56:36 <Fuuzetsu> programs*
11:56:49 <KoRnshell> But yeah, I didn't think about the inlining.
11:56:49 <c_wraith> honestly, if you add a NOINLINE pragma, it'll probably *work*.  The problem is whether it's what you *really* want it all.
11:57:01 <c_wraith> *at all
11:57:10 <KoRnshell> I just need a random value to remain consistent throughout the entire execution
11:57:24 <Fuuzetsu> KoRnshell: then you get the random value in main and pass it around
11:57:24 <KoRnshell> But I guess I'll bind it around then
11:57:27 <c_wraith> Why random?  Why not command-line arg?
11:57:47 <c_wraith> reproduceability is important!
11:57:52 <KoRnshell> command line arg is the other option
11:57:59 <c_wraith> What if you get a strange answer one run, and want to figure out why?
11:58:05 <KoRnshell> We're talking 'give me a random quote from a database if no number is given' program
11:58:27 <Fuuzetsu> c_wraith: ./my_haskell_program `echo getrandomnumber.sh`
11:58:46 <c_wraith> Fuuzetsu: at least that's no longer the fault of the haskell program! :P
11:58:49 <Fuuzetsu> u
11:59:40 <Fuuzetsu> chrisdone: by the way, what do you use for hoogle in emacs?
11:59:55 <Fuuzetsu> I really need to set up my Haskell environment properly, it's kind of meh at the moment
12:00:00 <KoRnshell> In what case is inlining this by the way more efficient than computing it once? Is there some memory that may get saved from inlining?
12:00:24 <Fuuzetsu> inlining is what all the cool kids do
12:00:44 <KoRnshell> Only the English stay in line.
12:00:53 <KoRnshell> In all other countries it's survival of the fittest when the bus comes.
12:01:06 <radish> KoRnshell: isn't "Strength through Diversity" from 1984?
12:01:28 <ReinH> Fuuzetsu: GHC has reallyUnsafePtrEquality :D
12:01:28 <radish> KoRnshell: oh wait, nope, that's UN motto. lol @ UN.
12:01:41 <KoRnshell> No, that'd be ignorance is strength
12:01:55 * hackagebot Dust-tools 1.1.1 - Network filtering exploration tools  http://hackage.haskell.org/package/Dust-tools-1.1.1 (BrandonWiley)
12:01:57 * hackagebot Dust-tools 1.2.1 - Network filtering exploration tools  http://hackage.haskell.org/package/Dust-tools-1.2.1 (BrandonWiley)
12:01:58 <KoRnshell> Strengfth through diversity is from Ghost in the Shell I believe 'Specialize, and you breed in weakness'
12:05:50 <tharper> chrisdone: my favourite Swedish phrase is: Far, får får får? Nej, får får lamm.
12:06:13 <radish> is (\a-> do{ io' a; return a}) valid?
12:07:00 <chrisdone> tharper: which translates to? Fmap . fmap fmap fmap? liftM fmap fmap loeb
12:07:20 <geekosaur> radish, looks valid but pointless to me?
12:07:35 <tharper> chrisdone: hehe, "Dad, do sheep have sheep? No, sheep have lambs"
12:07:56 <ion> radish: Sure. That’s incidentally the same as \a -> a <$ io' a
12:08:01 <KoRnshell> tharper, wasn't that posted on reddit today?
12:08:15 <KoRnshell> In that Finnish lesson topic
12:08:16 <tharper> KoRnshell: was it?
12:08:21 <radish> ion: you just max level confused me
12:08:29 <tharper> KoRnshell: it's a super common "tongue twister"
12:08:47 <KoRnshell> Ah, oh well, it was posted on reddit today, I would just go on #haskell and tell lies.
12:08:49 <ion> radish: Feel free to ignore my last message and use return.
12:09:02 <radish> geekosaur: why pointless?
12:09:22 <radish> ion: it's just that I was under the impression that <$ had to do with the Maybe Monad.
12:09:25 <chrisdone> tharper: ah, nice =)
12:09:36 <geekosaur> for the reason ion showed you
12:09:56 <fizruk> :t (<$)
12:09:57 <lambdabot> Functor f => a -> f b -> f a
12:10:01 <ion> radish: It works with any Functor.
12:10:29 <chrisdone> tharper: the only italian tongue twister i know is: trentatre trentini entrarono a trento tutti e trentatre trotterellando
12:10:30 <radish> ion: i thought functors are maps or folds upon various data structures?
12:11:36 <ion> radish: Or generators of data, such as Parser or IO.
12:12:02 <chrisdone> tharper: which is something like, thirty-three Trentini (from Trento, where i live!) enter Trento together and all thirty-three trotting. but it's all trills in italian =)
12:12:06 <radish> ion: how do you guys make this sound so straight forward?
12:14:11 <simpson> radish: Experience.
12:14:55 <ion> radish: ‘reverse <$> readFile "foo"’ is an IO action that upon execution reads the file, reverses the string and results in that value.
12:15:27 <monochrom> @type (<$)
12:15:27 <lambdabot> Functor f => a -> f b -> f a
12:15:33 <ion> radish: ‘(\_ -> 42) <$> readFile "foo"’ is an IO action that upon execution reads the file, ignores the contents and results in 42.
12:15:50 <ion> radish: ‘const 42 <$> readFile "foo"’ is the same. ‘42 <$ readFile "foo"’ is the same.
12:17:18 <khyperia> I was about to ask if $> existed, but then I realized it'd be useless, since the left side is pure and discarded.
12:18:22 <fizruk> khyperia, $> is just inversed <$
12:18:28 <fizruk> :t ($>)
12:18:29 <lambdabot>     Not in scope: `$>'
12:18:29 <lambdabot>     Perhaps you meant one of these:
12:18:29 <lambdabot>       `$' (imported from Data.Function),
12:18:46 <chrisdone> @tell quchen http://frontenddevreactions.tumblr.com/post/50427701984/when-i-look-at-code-i-wrote-years-ago
12:18:46 <lambdabot> Consider it noted.
12:19:01 <fizruk> :t (Control.Comonad.$>)
12:19:02 <lambdabot> Functor f => f a -> b -> f b
12:19:29 <fizruk> khyperia, ^
12:19:44 <edwardk> ($>) as written in Control.Comonad is rather useful with wfix
12:20:39 <khyperia> ah, cool
12:21:19 <tharper> chrisdone: That is like Sju sjösjuka sjömän sköttes av sju sköna sjuksköterska
12:21:38 <khyperia> I've never heard of wfix before, though
12:21:46 <khyperia> :t wfix
12:21:46 <lambdabot>     Not in scope: `wfix'
12:21:47 <lambdabot>     Perhaps you meant one of these:
12:21:47 <lambdabot>       `mfix' (imported from Control.Monad.Writer),
12:21:56 <lispy> :t mfix
12:21:57 <lambdabot> MonadFix m => (a -> m a) -> m a
12:22:08 <geekosaur> wfix sounds like the equivalent of mfix for comonads to me
12:22:09 <fizruk> :t Control.Comonad.wfix
12:22:10 <lambdabot> Control.Comonad.Comonad w => w (w a -> a) -> a
12:22:15 <khyperia> ah
12:22:15 <lispy> is wfix like MonadFix but for Comonads?
12:22:20 <edwardk> yep
12:22:29 <lispy> funny
12:22:34 <lispy> cofix
12:22:49 <edwardk> it has the benefit of being universally defineable unlike mfix
12:22:58 <lispy> The nice thing about categorical dual jokes is that they're always cofunny.
12:22:59 <chrisdone> tharper: hehe. any like this? i'm not the pheasant plucker, i'm the pheasant plucker's son, i'm only plucking feathers 'till the pheasant plucker comes
12:23:44 <Hodapp> I read that as 'pleasant phucker'.
12:23:46 <simpson> edwardk: Really? Is it something like extract (fmap extract) ?
12:24:20 <edwardk> wfix w = extract w (extend wfix w)
12:25:36 <simpson> Man, I need to do more comonads. I think I have a good intuition for that nifty comonad that applies convolutions to images, but they're hard to think about in general.
12:26:21 <edwardk> simpson: i
12:26:37 <edwardk> i've been spending a lot of time playing around with comonads for folding lately
12:27:38 <edwardk> data FoldMap a b = forall m. Monoid m => FoldMap (a -> m) (m -> b) -- is a very nice Comonad, Applicative, etc.
12:27:46 <edwardk> (even a profunctor)
12:28:49 <edwardk> the comonad lets me 'sneak in before it is done and resume'.
12:29:10 <simpson> Hm. fmap (FoldMap to from) f = FoldMap to (f . from) -- or so? Interesting.
12:29:31 <edwardk> you have your fmap args flpped, but yes
12:29:43 <erisco> I am experimenting with the layout rules in Haskell and I find this case strange. http://lpaste.net/96383 is a parse error on 'in' but this is fine http://lpaste.net/96382
12:29:48 <simpson> Oh, derp. Still turkey'd out, I guess.
12:29:56 <edwardk> working through the applicative of that s fun
12:30:08 <fizruk> edwardk, what does that structure represent?
12:30:28 <ion> @hackage reducers
12:30:29 <lambdabot> http://hackage.haskell.org/package/reducers
12:30:35 <edwardk> fizruk: it represents the argumnts to foldMap, plus something to do at the end.
12:30:57 <edwardk> https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2 talks about a foldl version of it
12:31:46 <edwardk> https://www.fpcomplete.com/user/edwardk/conquering-folds talks about a version of it for divide and conquer folding over trees
12:32:11 <fizruk> edwardk, thanks!
12:32:54 <edwardk> https://www.fpcomplete.com/user/edwardk/parallel-crc gave a version of the FoldMap i defined above as well
12:33:12 <edwardk> as does http://hackage.haskell.org/package/folds-0.3/docs/src/Data-Fold-M.html#M
12:33:51 <edwardk> both of the latter use an explicit monoid broken into its mappend and mempty parts though, not the dictionary
12:34:21 <ReinH> edwardk: Isn't that what you were calling Reducer?
12:34:34 <edwardk> i've called it lots of things =)
12:34:45 <ReinH> FoldMap makes sense :)
12:36:49 <ReinH> edwardk: now what does Traverse look like?
12:38:02 <edwardk> doesn't make as much sense
12:38:53 <ReinH> :(
12:38:53 <blackdog> hey all. am in berkeley for a few days - anything happening in the haskell world while i'm here?
12:39:15 <ReinH> edwardk: I look forward to your new school of haskell posts with interest
12:55:14 <chrisdone> http://www.well-typed.com/blog/84 TL;DR: GHC HEAD (but not GHC 7.8) will soon support OverloadedRecordFields, an extension to permit datatypes to reuse field labels and even turn them into lenses.
12:55:19 <chrisdone> omg woo
12:55:46 <hiptobecubic> snap
12:56:48 <chrisdone> hiptobecubic: http://media.tumblr.com/tumblr_m89lolzd9t1rqpqe0.gif
12:57:10 <blackdog> chrisdone: at last, i won't have to be embarrassed when explaining haskell's record system to friends :)
12:57:34 <hiptobecubic> chrisdone, precisely!
12:57:47 <Ralith> aw, not 7.8?
12:57:53 <edwardk> just when explaining the ensuing type signatures
12:58:28 <edwardk> it wasn't until the very end of summer that we finally nailed down the right spec for them
12:58:38 <mlen> any mac users here?
13:00:25 <mlen> i'd like to verify if the build from homebrew crashes on 100000^100000 % 100^100 (bus error)
13:01:55 <chrisdone> edwardk: i'm not clear on the update point. can i write g :: r { f :: Int } => r -> Int -> r; g r v = r { f = v }?
13:02:17 <chrisdone> edwardk: or does it have to be concrete?
13:02:47 <edwardk> that should work
13:03:45 <chrisdone> sweet!
13:04:01 <chrisdone> oh, sweeter. the Accessor class is win
13:04:47 <chrisdone> edwardk: will there be a combinator for lens?
13:05:11 <edwardk> basically you'll get a combinator to turn the Accessor back into a lens-style lens
13:05:19 <edwardk> the name is up in the air
13:05:24 <chrisdone> nod
13:05:41 <edwardk> it'll probably just be the field accessor for the contents of the newtype
13:05:58 <edwardk> i've done tests and had it all working on the prototype
13:06:31 <chrisdone> so performance-wise it should have no overhead?
13:07:14 <chrisdone> now that's what i call a successful GSoC
13:07:17 <edwardk> pretty much
13:07:55 <chrisdone> \o/
13:07:58 <frx> I wonder if overloaded record fields will have any affect on the lens library?
13:08:07 <edwardk> now, the types will likely be a bit terrifying, but i like the overall design. folks have been spitting out 'simple' designs for a long time.
13:09:36 <edwardk> frx: well, the main thing we'll add is a combinator for reifying them back out of the representation supplied for this extension. it'll make it so users don't _have_ to go use all the template haskell, but lens provides a lot of stuff that way they still won't get with just the baseline proposal
13:09:36 <edwardk> so i'd expect a lot of people will still use the TH
13:10:07 <Fristi> hello
13:10:13 <mreh> hullo
13:12:38 <Fristi> having a problem with a open http connections, i am using Network.HTTP and its function simpleHttp (url) >>= getResponseBody.. however when i list the connections via netstat -an | grep <ip> i see alot of CLOSE_AWAIT
13:12:48 <Fristi> is there anything i can do about that?
13:13:16 <Fristi> the host seems to forbid new connections at some point due the open connections
13:18:07 <radish> is there an alternative to this horrible syntax? Thing 1 2 (3 ::Type)
13:18:41 <monochrom> is it horrible? and how is Thing defined such that you need a type annotation for a field?
13:19:01 <radish> happens all the time
13:19:10 <radish> OpenGL is the example i have at the moment
13:19:11 <Iceland_jack> radish: Normally later uses of (3 ∶ Type) lets ghc infer the type
13:19:33 <radish> Color3 1 2 (3 ::GLint)
13:19:51 <Iceland_jack> For examples like Color3 you can make your own constructor if it's such a bother
13:19:55 <monochrom> I don't know OpenGL. so how is Thing defined such that you need a type annotation for a field?
13:20:07 <radish> Iceland_jack: totally going to do that, thank you.
13:20:31 <ReinH> monochrom: presumably with a Num a constraint?
13:20:35 <ReinH> or Integral or w/e
13:20:42 <radish> monochrom: you can do Color3 GLfloat GLfloat GLfloat or Color3 GLint GLint GLint etc
13:21:08 <Philonous> ReinH, No, it's just (,,)
13:21:22 <Philonous> ReinH, Constraints on data types are no no.
13:21:42 <monochrom> I guess my question is completely unclear and "how is ___ defined" is completely ambiguous.
13:22:01 <ReinH> Philonous: why?
13:22:49 <chrisdone> monochrom: The Thing… classic movie
13:23:22 <tapuu> I need to define a type level function with signature (* -> Constraint) -> (* -> Constraint) -> (* -> Constraint)
13:23:52 <Philonous> ReinH, Because it doesn't do what you would expect.
13:23:53 <tapuu> if a and b are the arguments it needs to return this: forall c. (a c, b c) =>
13:24:04 <ReinH> Philonous: you just need GADTs or MPTCs so... yeah no.
13:24:20 <Philonous> ReinH, You don't get the constraint "back" when you match on the constructors
13:24:27 <tapuu> how can I define this? Type synonyms complain about the number of arguments, it wont let me partially apply
13:24:42 <Philonous> ReinH, How would GADTs help?
13:24:48 <radish> monochrome: sorry i didn't answer your question satisfactorily - thats the best i can do in my rookie state
13:25:11 <radish> monochrom: some kind of larval zygote-pupa of a haskellite
13:26:06 <ReinH> Philonous: data Thing a where MkThing :: Constraint a => Thing a
13:26:59 <tapuu> What are you guys trying to do? I think I can help
13:28:58 <Philonous> ReinH, Interesting.
13:29:15 <doingwellondiet> New to Haskell package structure. Say I have a custom project with a directory structure like foo/bar, with files "foo/foo.hs" and "foo/bar/bar.hs". How could I import module foo from within module bar?
13:30:02 <ReinH> Philonous: not saying it's a good idea :)
13:30:17 <Fuuzetsu> doingwellondiet: import Foo
13:30:33 <Fuuzetsu> or rather, import Foo.Foo
13:30:39 <Fuuzetsu> your structure is a bit off
13:30:46 <Fuuzetsu> usually you'd have
13:30:47 <Fuuzetsu> src/Foo.hs
13:30:59 <Fuuzetsu> src/Foo/Bar.hs
13:31:07 <Philonous> ReinH, I was talking about constraints on the type variable, though. As in "data Num a => Foo a = Foo a"
13:31:40 <ReinH> o_O
13:31:49 <tapuu> Philonous: You can't do that
13:31:53 <Fuuzetsu> doingwellondiet: also make sure your modules have the right names. So src/Foo/Bar/Baz.hs would be ‘module Foo.Bar.Baz where …’
13:32:21 <Philonous> tapuu, You can, it's just a bad idea
13:32:30 <Philonous> tapuu, And deprecated
13:32:56 <tapuu> Hmm
13:33:08 <tapuu> Philonous: Does it actually do anything?
13:33:15 <doingwellondiet> Fuuzetsu: Right. I'll see if I can get it right.
13:33:37 <Philonous> tapuu, Yes, it restricts the types you can construct Foo at. But you can't use that constraint when pattern matching.
13:33:55 <tapuu> Philonous: That seems really pointless...
13:34:04 <Philonous> tapuu, So it's pretty useless. That's why it's deprecated
13:34:12 <Philonous> tapuu, That's what I was arguing.
13:34:27 <tapuu> Philonous: I missed half the argument
13:37:03 * hackagebot BlogLiterately-diagrams 0.1.3.1 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.3.1 (BrentYorgey)
13:38:49 <tapuu> Why isn't it possible to partially apply type synonyms?
13:39:23 <tapuu> Are there alternatives that achieve the same thing?
13:40:02 <Philonous> tapuu, No, Haskell doesn't have type lambdas
13:40:22 <Philonous> tapuu, you can use newtypes instead
13:41:32 <tapuu> Philonous: That won't help, I don't need a datatype
13:41:33 <haasn> well, you can partially apply type signatures
13:41:43 <haasn> eg. instance Monad (Either e)
13:41:52 <haasn> Is a partially applied form of Either e a
13:42:21 <tapuu> I need a function like this: (* -> Constraint) -> (* -> Constraint) -> (* -> Constraint)
13:42:44 <tapuu> I an define one with type synonyms and it works, except I cant partially apply it
13:42:51 <tapuu> which i need to be able to do
13:43:50 <tapuu> Actually, I think I can do it with a GADT
13:44:01 <doingwellondiet> Fuuzetsu: Okay, I guess my issue is more like I've got parallels paths foo/bar and foo/car. I want to import module foo/bar/b.hs inside foo/car/c.hs. I don't seem to be having a problem when I'm directly downstream of the module.
13:47:05 <Fuuzetsu> your b.hs should be module Foo.Bar.B
13:47:09 <Fuuzetsu> and your c.hs should be
13:47:16 <Fuuzetsu> Foo.Car.C
13:47:33 <Fuuzetsu> you should then be able to just ‘import Foo.bar.B’ in your c.hs
13:47:53 <Fuuzetsu> I actually recommend that you look at an existing project, it's probably the best way to figure it out
13:48:57 <monochrom> 1. is it important to have the directory names foo/bar and foo/car, as opposed to Foo/Bar and Foo/Car, or better yet, show your actual names not made-up names?
13:50:04 <radish> don't you have to name the files B.hs and C.hs not b.hs and c.hs?
13:50:10 <monochrom> 2. is it important to use hierarchical module names such as "module Foo.Bar.B where", as opposed to simply "module B where", and then just tell GHC you have multiple source directories?
13:50:36 <radish> Main won't work very well if you don't set it in the root and call it module Main where
13:50:59 <radish> I keep trying to put it inside folder and hope Folder.Main works but it doesn't. :)
13:51:13 <monochrom> no, there is, in fact, no need to say "module Main". and if you do say it, say "module Main(main)" instead. do you know why?
13:51:30 <radish> monochrom: why?
13:51:52 <Fristi> are there any good alternatives to Network.HTTP and Network.HTTP.Conduit?
13:52:06 <monochrom> because "module Main" is more unnecessary work for the compiler
13:52:25 <radish> monochrom: well, never doing that again, then.
13:52:47 <monochrom> if you put the file in a folder, use -i to tell GHC about that folder
13:53:45 <radish> monochrom: easier to simply not put it in a folder :)
13:54:30 <monochrom> well, my broad concern is that people do not know their options, therefore they think they only have one option and go XY problems
13:56:26 <dEPy> anyone here knows a bit of ruby?
13:58:21 <henk> dEPy: a tiny bit, yes
13:58:38 <dEPy> I'm not sure if I implemented  church numerals right. Seems to work fine but a second check would be nice... https://gist.github.com/depy/fa476d9be1eea6044b94
14:00:24 <fizruk> dEPy, toInt seems wrong
14:00:42 <dEPy> ok, what seems to be the problem?
14:00:57 <fizruk> oh wait
14:01:31 <tapuu> Has anyone ever seen a function that takes 2 constraints and intersects them?
14:01:55 <tapuu> Like, it takes a and b, and returns forall x. (a x, b x)
14:02:26 <fizruk> dEPy, everything's ok, except I'd expect toInt to covert church numeral to int
14:03:00 <dEPy> fizruk: yea maybe I gave i a stupid name
14:03:04 <dEPy> it*
14:03:14 <doingwellondiet> Fuuzetsu: Got the modules loaded. Amounted to some typo. I had done what you suggested (minus typo), so thanks for confirming I wasn't on the wrong path.
14:03:21 <fizruk> dEPy, toInt = ->(f) { f.call(->(x) {x + 1}).call(0) } or something
14:03:24 <scott_> dEPy: btw, you can abbreviate f.call(x) as f.(x)
14:03:38 <dEPy> scott_: oh, didn't know, that's awesome :)
14:03:44 <henk> Noob question: I’m trying to read a String like "1:01:20" into Ints to convert them to Seconds, but it seems I’m not using 'read' correctly. The paste shows my code and the error I get. Could anyone help me fix that please? General advice on my code or suggestions how else to convert these numbers are welcome. (It could also be 123456:20:40, which seems to be a problem for some methods of handling these
14:03:45 <henk> Strings.) http://lpaste.net/96385
14:04:01 <fizruk> scott_, can't one write f(x) ? I'm no expert
14:04:16 <dEPy> if it's lambda I think then not
14:04:30 <Fuuzetsu> doingwellondiet: no problem
14:04:31 <fizruk> dEPy, also, I'd implement zero and succ first
14:04:44 <fizruk> dEPy, and then one = succ.call(zero)
14:04:49 <dEPy> fizruk: ye im working on succ :)
14:04:50 <scott_> fizruk: Only if it was defined as a method, unfortunately
14:05:10 <fizruk> oh
14:05:11 <dEPy> just wanted to check if im on a right track :)
14:05:21 <monochrom> henk: read my http://www.vex.net/~trebla/haskell/reads.xhtml
14:06:07 <raphie> is it possible to pattern-match based on string appending?
14:06:36 <raphie> right now I have: foo ('A':'B':x:[]) = x
14:06:40 <zuserm> edwardk: I got you something for Thanksgiving.
14:06:53 <raphie> can I do something like: foo ("AB"++x:[]) = x ?
14:07:06 <fizruk> raphie, with ViewPatterns you can do something similar
14:07:29 <tomberek> can one use two same-named modules at the same time? Text.Regex lives in both regex-compat and regex-compat-tdfa
14:09:00 <henk> monochrom: Thanks
14:10:17 <pavonia> tomberek: There's an extension that allows you to specifiy the package the module comes from. I guess you can load them both qualified then
14:10:36 <tomberek> pavonia: that should work, thanks!
14:10:46 <benmachine> PackageImports
14:10:49 <fizruk> > let f (splitAt 2 -> ("AB", [x])) = x; f _ = 'Z' in f "ABC"
14:10:50 <lambdabot>   'C'
14:10:51 <benmachine> but it's mostly meant for internal use
14:11:00 <benmachine> import "network" Network.Socket I think
14:11:18 <benmachine> usually the better solution is to work out why you only need one of then :P
14:13:52 <film-4242> just a random question, sorry.. has anyone in here found web development pleasing in haskell?
14:13:55 <tomberek> benmachine: I want to be able to output the results of both regex's
14:16:08 <dEPy> in the case:  succ ≡ λn.λf.λx. f (n f x)
14:16:29 <dEPy> f (n f x)  is not  f ( n ( f ( x ) ) )  ?
14:16:57 <benmachine> dEPy: no, f ((n f) x)
14:17:08 <dEPy> oh
14:18:18 <dEPy> damn those parens :S
14:19:00 <haasn> film-4242: I'm sure at least one or two people have ;)  (web development is really popular in haskell. probably the most popular branch)
14:19:21 <haasn> film-4242: have a look at yesod, snap, happstack, warp, whatever
14:19:28 <haasn> (note: ‘whatever’ is not a web framework)
14:19:57 <dEPy> haasn: maybe not in haskell :) But i'm sure it's out there somewhere :D
14:20:22 <chrisdone> ReinH: haskellcast \o/
14:21:01 <Fuuzetsu> dEPy: can't find any
14:21:32 <dEPy> Fuuzetsu: me neither :/  I was so sure...
14:22:34 <Fuuzetsu> here's your chance
14:22:48 <dEPy> :D
14:22:52 <zuserm> hey chrisdone, did you get my e-mail?
14:23:34 <chrisdone> zuserm: what was the subject?
14:23:44 <zuserm> wfix
14:24:43 <film-4242> haasn: I've seen a list of those frameworks, just not sure how people enjoyed working with them. I come from a clojure background, so I'm wondering how effective things can become.
14:24:50 <w0rm_x> @src takeWhile
14:24:50 <lambdabot> takeWhile _ []                 =  []
14:24:50 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
14:24:50 <lambdabot>                    | otherwise =  []
14:24:53 <chrisdone> oh yeah, i didn't sit down to read the code yet
14:25:29 <chrisdone> but the speed up from never-completes to 1.7x slower than loeb is good
14:25:39 <zuserm> no worries
14:25:55 <haasn> film-4242: I haven't really been working with them but I know people love them and they're a major selling point. They also tend to be ridiculously performant, check http://aosabook.org/en/posa/warp.html
14:26:19 <haasn> easily outperforming nginx on 2+ cores
14:26:46 <haasn> film-4242: maybe you could look at some of the documentation and/or examples and judge for yourself
14:27:30 <tomberek> zuserm: you are using loeb?
14:28:35 <chrisdone> zuserm: you should blog about it and explain it =p i only just understood the original comonadic one because both comonad and pointedlist were new to me. this detailed one is over my head at present
14:28:57 <raphie> has anyone built a tool where I can give sample input and output to a function and have it find the function for me?
14:29:04 <zuserm> yeah, I really should start a blog
14:29:10 <chrisdone> =)
14:29:18 <haasn> raphie: the only thing that comes to mind is something like a neural network
14:29:19 <zuserm> any suggestions on what to use?
14:29:23 <chrisdone> i'll link to it if you do
14:30:12 <chrisdone> in the haskell community hakyll is popular. but it depends on your time/patience. wordpress/blogpost are easy to setup in a few minutes
14:30:22 <tomberek> zuserm: got any code on github?
14:30:24 <raphie> haasn: well it could be pretty easily accomplished by a) checking the type signature of the input and finding all functions that match and then b) running each of those functions on the given input and checking if the output matches
14:30:42 <zuserm> tomberek: chrisdone at a blog post about and we were talking about loeb vs. wfix on reddit
14:30:44 <chrisdone> that's true, github is another option these days
14:31:09 <chrisdone> http://chrisdone.com/posts/twitter-problem-loeb#update-with-comonads-pointed-lists
14:32:44 <monochrom> raphie: you can pay me money to guess the function for you
14:33:30 <raphie> monochrom: heh. just thinking it would be a fun "learn haskell" project
14:34:19 <zuserm> tomberek: https://github.com/bacchanalia/ I don't have that much code up, but if anyone has seen edwardk's Mozilla talk, I just put up a version of the code he's talking about in it that keeps the amortized bounds when used persistently
14:34:23 <haasn> raphie: you'd need a lot of time most likely
14:34:24 <triliyn> raphie: for many type signatures, there are infinitely many possible functions
14:34:27 <haasn> and I mean, a lot
14:34:49 <tomberek> raphie, ghc type inference for the values, then hoogle it, and run those functions
14:35:05 <raphie> well yeah tomberek, that's what I'd like to automate
14:35:25 <triliyn> ooh, that could be kind of interesting though
14:35:35 <raphie> does hoogle have an API?
14:36:12 <triliyn> I think it does
14:36:16 <triliyn> Lambdabot has it
14:36:20 <triliyn> @hoogle Int -> Char
14:36:20 <lambdabot> Data.Char chr :: Int -> Char
14:36:20 <lambdabot> Data.Char intToDigit :: Int -> Char
14:36:20 <lambdabot> Data.Text index :: Text -> Int -> Char
14:36:28 <raphie> is there a library for safe evaluation?
14:36:31 <donri> @djinn Int -> Char
14:36:31 <lambdabot> Error: Undefined type Int
14:36:33 <donri> :(
14:36:42 <donri> raphie: SafeHaskell, mu-eval
14:36:51 <raphie> neat, this might be a fun project!
14:37:08 <donri> mueval, rather
14:37:10 <raphie> is there a way I could just download hoogle's database and run it locally?
14:37:12 <triliyn> mu-eval is what lambdabot uses, I have learned from error messages
14:37:19 <triliyn> > let bottom = bottom in bottom
14:37:23 <lambdabot>   mueval-core: Time limit exceeded
14:37:54 <donri> vaguely related to your question, there's a library for finding quickcheck properties in existing code and there's things like @djinn and theorem provers
14:38:01 <triliyn> > fix id
14:38:04 <lambdabot>   mueval-core: Time limit exceeded
14:38:13 <raphie> haskell seems like an amazingly beautiful language so far, I'm just concerned about being able to write "real-world" programs with it. webservers and the like.
14:38:35 <chrisdone> don't worry about web servers, we've got that covered
14:38:36 <zomg> raphie: why?
14:38:41 <blackdog> raphie: it's a pretty good language for that too
14:38:44 <donri> raphie: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
14:38:46 <chrisdone> worry more about desktop UIs and things like that, that's a little spottier at present
14:39:11 <blackdog> raphie: one caveat - if you're used to something like Rails, we don't really have that golden-path experience
14:39:22 <merijn> raphie: In my opinion real world programs are easy in haskell, but for me there was quite a bit of ramp up before I knew enough of the normal library design to get that far
14:39:32 <raphie> what I'm thinking is using node for all the I/O, and then passing the stuff that needs actual computation into a work-queue for a haskell program
14:39:53 <merijn> raphie: Once you're comfortable in haskell, almost any type of program becomes fairly simple, but getting that comfortable can take a bit longer than in other languages
14:40:01 <zomg> you get a pretty decent productivity for web stuff with the big libraries though, but yeah definitely something like Rails would have a bazillion libraries for solving all the tasks you can think of =)
14:40:18 <merijn> raphie: I would argue that haskell is far, *far* better at handling the server IO than node
14:40:23 <blackdog> raphie: in general, haskell should do a better job than node at the IO.
14:40:28 <chrisdone> raphie: nahhh! the ghc io manager is very capable. node here won't be a benefit
14:40:33 <merijn> raphie: Especially since you can just use threaded code, so it'll be simpler too
14:40:51 <zomg> I'm currently paid to use node to do stuff
14:40:54 <blackdog> raphie: i had a bit of fun doing an optimisation challenge with rvagg a while back
14:40:56 <zomg> and I'd still think Haskell would be a better choice
14:40:56 <zomg> =)
14:41:08 <blackdog> https://gist.github.com/mwotton/6077238
14:41:26 <zomg> Not sure why people seem to think haskell is somehow not suitable for real world problems even though there's a whole load of libraries and stuff for doing exactly those tasks
14:41:27 <monochrom> theorem: the language you're paid to use, or you're forced to use for a course, sucks. :)
14:41:33 <blackdog> i think we topped out at about 112krps for ghc, and 44krps for node
14:41:37 <donri> raphie: node.js is insanely bad at scaling io
14:41:41 <donri> it's not even funny
14:41:43 <raphie> well yeah, but it seems like there are a lot of problems that are better modeled sequentially. for example, get a web request -> hit the database -> perform a third-party API query -> respond
14:41:46 <donri> ok it's actually hilarious
14:41:55 <blackdog> donri: i think it's because rails/django are even worse.
14:42:03 <monochrom> (it's a simple corolloary of: master theorem: work sucks. :) )
14:42:04 <chrisdone> monochrom: i'm paid to use haskell. it doesn't suck =p
14:42:05 <blackdog> raphie: actually, i think that's more a point for haskell than node
14:42:10 <chrisdone> monochrom: it's awesome =p
14:42:15 <zomg> raphie: I wouldn't say node is particularly sequential =)
14:42:23 <blackdog> you spin up a thread, get a web request, do an api call, return
14:42:29 <blackdog> not "set a callback for a callback for a callback"...
14:42:33 * monochrom hires an assassin to eliminate the counterexample that is chrisdone :)
14:42:35 <merijn> raphie: Yes, which is actually why haskell is good at that. Just have one thread sequentially handle all of those
14:42:37 <zomg> there's probably at least a dozen libraries for node to make async code look sequential in node :P
14:42:39 <raphie> I guess all that could be done in a "do" block?
14:42:47 <chrisdone> monochrom: i chat to johnw and he waxes poetic about how much he loves doing his job in haskell =p
14:42:51 <monochrom> the assassin says, "you know what, homicide sucks" :)
14:42:53 <raphie> can do's be run concurrently like goroutines?
14:43:03 <blackdog> raphie: yep, exactly. there's nothing wrong with IO, it's a real thing that has to be done
14:43:14 <donri> raphie: sure thang.
14:43:15 <merijn> raphie: Yes, using threads. Haskell's threads are lightweight, so you can easily have >10k
14:43:18 <blackdog> the trick in haskell is that you can separate the stuff that's not IO out.
14:43:27 <blackdog> ^ /me english good today
14:43:28 <zomg> raphie: I've written a bunch of small web apps in haskell and node, and they're both just fine for the task
14:43:31 <merijn> raphie: They're very similar to Go's goroutines or Erlang processes
14:43:44 <chrisdone> monochrom: yeah, we're an exception. tho in the interest of never being satisfied it's easy to whine about what could be better, of course
14:43:44 <monochrom> hmm poetic
14:43:58 <donri> raphie: IO is rewritten transparently to use non-blocking event loops, but you don't have to write your code with modern-day GOTOs for it
14:44:03 <blackdog> chrisdone: the list is getting shorter. records seem like they might not suck soon.
14:44:26 <blackdog> and cabal doesn't seem to hurt nearly as much as it used to.
14:44:32 <merijn> raphie: The runtime uses select/kqueue/epoll to multiplex the lightweight threads over multiple OS threads. So you just write sequential code with 1 thread per connection and the runtime will do all the scheduling/callback-like behavior. So you don't have to do that manually like in node
14:44:34 <chrisdone> blackdog: yeah =)
14:45:40 <donri> you know C was considered high-level once. dynamic-imperative is the new low-level. :P
14:47:33 <heatsink> Sometimes Haskell code is used the way a C++ programmer would use macros or templates
14:47:55 <heatsink> That is, you expect the compiler to evaluate the code statically and give you good performance
14:48:07 <monochrom> raphie: it is relieving to know that the programmer model (a lot of threads, each waiting for blocking I/O) can be the complete opposite of the execution model (one single event dispatch loop of non-blocking I/O)
14:48:21 <heatsink> papers like the "Haskell Beats C" paper take advantage of that
14:48:52 <monochrom> but perhaps, some people find that nerve-wrecking, not relieving.
14:49:24 <monochrom> some programmers are control freaks. they freak out when the programmer model is different from the execution model.
14:50:21 <heatsink> has anyone written about this practice of expecting macro-like performance from code?
14:50:31 <donri> haskell performance is fun: sometimes code runs insanely slow and adding a single character makes it beat C. sometimes it's slower than python and it turns out to be because the python version wasn't really correct. :P
14:50:51 <chrisdone> sometimes it's just actually slow
14:50:53 <chrisdone> and that's fine too
14:51:24 <blackdog> hrm. the sandbox stuff is still taking some getting used to. keep forgetting that if i'm in a sandbox, binaries will get installed there
14:51:44 <monochrom> you shall play with PATH!
14:51:46 <chrisdone> heatsink: i think people tend to be surprising at how much haskell code is inlined and reduced
14:51:49 <heatsink> When does adding a single character make it faster than C?
14:51:54 * chrisdone should bring his corebot in here
14:52:23 <heatsink> I think people also tend to be surprised at how reliable some optimizations are
14:52:37 <monochrom> it's actually part of why I just wrote a few simple shell functions and aliases for sandboxing, instead of using any of cabal-dev, hsenv, or cabal sandbox
14:52:45 <heatsink> In C/C++, your compiler might inline an indirect function call if you're lucky, but don't count on it
14:52:50 <blackdog> heatsink: foldl' ? :)
14:53:03 <monochrom> because I tell write the shell function to add things to PATH and be done
14:53:06 <donri> heatsink: when you add a single ! that actually makes the computation run parallel
14:53:14 <donri> true story
14:53:32 <donri> not that i compared to C, but the point is that you don't really get "free parallelism" with C
14:54:07 <heatsink> Hmm, "\'" and "!" both alter strictness
14:55:19 <int-e> heatsink: what do you mean by "\"\\\"\""?
14:55:19 <raphie> sorry, spotty connection. y'all have sold me. can you recommend a tutorial on building a simple REST API? just JSON responses, resourceful routing, etc
14:55:34 <quchen> donri: You get "free parallelism" with C in some sense??
14:55:41 <heatsink> int-e, blackdog mentioned "foldl'"
14:55:46 <quchen> donri: (Or how should I understand that "really")
14:55:47 <blackdog> raphie: hehe, thought we'd scared you off :)
14:55:50 <int-e> heatsink: ah thanks!
14:56:12 <raphie> naw blackdog, this is probably the most responsive and passionate IRC chan I've been in, I appreciate it!
14:57:08 <blackdog> raphie: on the api stuff - i quite like scotty for really small stuff. similar to where you'd use flask or sinatra
14:57:21 <blackdog> bigger stuff, maybe snap?
14:57:37 <chrisdone> raphie: i think there should be a collection of things related to that on the school of haskell
14:57:42 <blackdog> yesod is full-featured but occasionally kind of a bear <- entirely subjective opinion, don't hate me yesod peeps
14:58:03 <chrisdone> raphie: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json
14:58:03 <raphie> yeah I do most of my web work in Angular with an Express REST backend
14:58:04 <chrisdone> raphoe: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks
14:59:30 <raphie> chrisdone: checkin' it out!
14:59:36 <zomg> blackdog: the yesod bears have been dispatched to maul you
14:59:37 <zomg> ;)
14:59:48 <raphie> I might be in and out due to internet issues (currently tethering on a road trip), but I'll be back to consult
14:59:55 <blackdog> zomg: thankfully their feet are trapped in a cabal build error
15:00:00 <zomg> oh snap
15:00:01 <zomg> :D
15:03:46 <blackdog> hrm, dumb question: anyone know how to get ghc-mod working with cabal sandboxes?
15:03:46 <blackdog> i keep getting comments about not being able to satisfy a package
15:04:12 * monochrom sends sicp.xhtml to the yesod bears to help them
15:04:47 * monochrom sends sicp.xhtml to blackdog too
15:05:09 <monochrom> no, actually I don't know whether that's relevant
15:05:33 <monochrom> is ghc-mod on hackage?
15:05:46 <monochrom> no, you mean something else
15:06:04 <blackdog> monochrom: yes
15:06:31 <blackdog> emacs plugin - been using it happily for some time, but now it can't find my packages
15:06:52 <blackdog> i guess i could install all my stuff globally as well, but that's a bit of a hacky workaround
15:07:15 <monochrom> well, ghc-mod needs to be told: there is another package db due to the sandboxing...
15:07:47 <monochrom> and given that ghc-mod was invented before sandboxing, it probably doesn't even have a way to be told
15:08:08 <monochrom> well, maybe it honours the GHC_PACKAGE_PATH environment variable, which cabal hates.
15:08:50 <blackdog> i haven't set that
15:11:50 <donri> it's supposed to support sandboxes
15:12:19 <blackdog> donri: yeah, this is why i'm a bit confused.
15:12:38 <blackdog> i have 3.1.4 *shrug*
15:12:54 <jonkri> In Haskell, is "a . b c" parsed as "(.) (a) (b c)"? That is, is the `.' function "greedy" and takes everything to it's left and right, instead of just the argument it needs, such as the case with normal function application?
15:13:07 <jonkri> `.' being an infix function.
15:13:45 <Philonous> a . b c === a . (b c)
15:13:54 <Philonous> Prefix application precedes infix
15:13:55 <monochrom> yes
15:13:57 <Philonous> Always
15:14:16 <monochrom> actually, no to "greedy"
15:15:27 <monochrom> "a . b c" is not so different from "a + b c"
15:17:07 <jonkri> Ah, that's what I thought. Thanks.
15:19:10 <raphie> chrisdone: in the Aeson tutorial, one of the types in the data definition is !Text. how is !Text different from Text different from String?
15:20:03 <benmachine> raphie: !Text isn't a type, but it can appear in some of the places a type can
15:20:19 <raphie> what is it? I've never seen the ! syntax before
15:20:29 <benmachine> raphie: if you have data A = B !Text, it means the B constructor is strict
15:20:39 <donri> it means when you evaluate the constructor, the Text is evaluated first
15:20:43 <raphie> as in, not lazy?
15:20:45 <benmachine> yes
15:20:53 <raphie> ahh, so what are the ramifications?
15:21:26 <benmachine> well, on the one hand sometimes laziness is necessary or useful
15:21:43 <donri> > case Just undefined of Just _ -> "would be undefined if data Maybe a = Just !a ..."
15:21:44 <lambdabot>   "would be undefined if data Maybe a = Just !a ..."
15:21:45 <benmachine> on the other hand, it involves overhead, and having a strict field can avoid that, so can be more efficient
15:22:13 <dmj`> is 7.8 out?
15:22:17 <donri> nope
15:22:21 <Ick> Dear Jake: If you are out there and the names Aaron Austin and Dom mean anything to you, get in touch man, we miss ya. <3
15:26:07 <jmcarthur_mobile> benmachine: to be pedantic, it doesn't mean the field will be evaluated first, only that it will be evaluated "when" the constructor is evaluated
15:26:28 <benmachine> blame donri, I didn't say that :P
15:26:43 <jmcarthur_mobile> Woops, I misread
15:28:12 <donri> and i said "when you evaluate the constructor" :)
15:29:57 <benmachine> donri: sure, but I think the point is that when you evaluate x `seq` y, either could be evaluated first
15:30:08 <benmachine> this is why pseq was invented
15:33:11 <jmcarthur_mobile> donri: I was picking on the word "first"
15:40:04 <benzrf> has anybody here tried lamdu?
15:42:28 <augur> uh oh
15:42:35 <augur> GHC Head now has proper subtyping
15:42:47 <benzrf> subtyping??
15:42:52 <benzrf> is that a haskell' thing?
15:43:00 <augur> it is now
15:43:13 <benzrf> NeatBasis:
15:43:14 <benzrf> *neat
15:43:23 <augur> not neat :(
15:43:26 <zomg> augur: what does that do though?
15:43:35 <augur> i mean, its just record subtyping, but still
15:44:16 <haasn> augur: isn't it just class instances? or am I remembering something different
15:44:33 <augur> no is it?
15:45:25 <augur> ahh it seems to be indeed
15:45:30 <haasn> augur: oh, I'm thinking of https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
15:45:40 <haasn> + some syntax sugar on top
15:45:48 <augur> haasn: me too
15:45:54 <haasn> but looks like https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Plan is not quite the same thing
15:46:14 <haasn>  A record field constraint r { x :: t } is syntactic sugar for the pair of constraints (Has r "x", FldTy r "x" ~ t)
15:46:15 <haasn> aha!
15:46:24 <augur> http://www.well-typed.com/blog/84
15:47:51 <Rarrikins> Yay!
15:49:04 <benmachine> augur: https://twitter.com/pigworker/status/396035730629488640 :>
15:49:08 <haasn> “The OverloadedRecordFields extension does not attempt to generalise this syntax, so a record update expression will always refer to a single datatype, and if the field names do not determine the type uniquely, a type signature may be required.”
15:49:12 <Ick> Dear Jake: If you are out there and the names Aaron Austin and Dom mean anything to you, get in touch man, we miss ya. <3
15:49:16 <haasn> I guess it won't bite us much if we use top level signatures
15:49:23 <haasn> but any reduction of type inferencing is scary, scary stuff
15:49:43 <haasn> rank-2 has given me some headaches already
15:50:05 <augur> benmachine: indeed
15:50:23 <augur> benmachine: youll notice im part of that convo x3
15:50:42 <benmachine> augur: I don't know your real name :P
15:50:53 <augur> benmachine: im @psygnisfive
15:51:02 <benmachine> oh cool
15:52:50 <augur> i assigned some subtyping problems to my students for their final project :x
15:53:43 <augur> also ive been reading a bit lately about a grammatical theory called Radical Construction Grammar which is basically a maximally subtype-oriented theory
16:05:49 <mreh> botsnack
16:08:06 <mreh> hello
16:09:38 <raphie> hey, I can't find an explanation for the <$> operator, anyone know what it does?
16:09:49 <mreh> raphie: it's infix fmap
16:10:26 <Rarrikins> @src (<$>)
16:10:26 <lambdabot> f <$> a = fmap f a
16:10:49 <mreh> I think it's a bit more than that
16:10:58 <mreh> it has different associativity
16:11:57 <raphie> time to learn about Functors! (this is how I learn languages -- try doing cool stuff, then learn things I run into and don't understand)
16:12:30 <blackdog> raphie: Ignorance Driven Education. I like it. :)
16:12:44 <jle`> raphie: it's analogous to $, really
16:12:55 <jle`> but it's $ "in a functor"
16:13:19 <jle`> for example
16:13:25 <jle`> > (* 2) $ 7
16:13:26 <lambdabot>   14
16:13:33 <jle`> > (* 2) <$> (Just 7)
16:13:34 <lambdabot>   Just 14
16:13:44 <jle`> > (* 2) <$> [7,8,9]
16:13:45 <lambdabot>   [14,16,18]
16:13:59 <raphie> huh, that's so neat. I'll have to check that out
16:14:01 <mreh> > Just (* 2) <*> Just 5
16:14:02 <lambdabot>   Just 10
16:14:06 <mreh> that'll confuse you
16:14:08 <raphie> I'm still trying to understand typeclasses, hah
16:14:17 <jle`> mreh, you're evil :P
16:14:22 <mreh> :)
16:14:59 <jle`> raphie: have you ever done any OOP?  Java?  Typeclasses are just interfaces
16:15:07 <mreh> <$> has a specific usage, in something called applicative style
16:15:09 <raphie> ahh, that makes sense
16:15:19 <geekosaur> sort og
16:15:21 <jle`> you know, like, you could make an interface called Printable
16:15:21 <geekosaur> *of
16:15:30 <jle`> meaning you can trust that it has a print method
16:15:39 <mreh> (+) <$> Just 12 <*> Just 7
16:15:45 <jle`> well, haskell has Show, which means something you can trust to have a show method
16:15:46 <augur> jle`: they're a little more fancy than interfaces
16:15:51 <mreh> > (+) <$> Just 12 <*> Just 7
16:15:52 <lambdabot>   Just 19
16:15:54 <Rarrikins> > [(*), (+)] <*> [1..3] <*> [4..6]
16:15:55 <lambdabot>   [4,5,6,8,10,12,12,15,18,5,6,7,6,7,8,7,8,9]
16:16:08 <mreh> lol
16:16:11 <raphie> what is the convention for handling state? in my programming classes at school, we wrote a bunch of little games in Racket. there was a "world" and all the functions that modified state (key handlers, tick function, etc) would simply take the world and return a new, modified copy of it
16:16:26 <mreh> sounds like the IO monad
16:16:36 <augur> sounds like the state monad.
16:16:40 <mreh> IO Monad is analogous to State World
16:16:49 <augur> for some notion of World
16:16:55 <augur> i think raphie means "game world"
16:17:09 <jle`> hm
16:17:15 <raphie> well I mean not just games, just state in general
16:17:29 <mreh> the State monad is a good place to start
16:17:30 <jle`> thinking of the IO monad as a RealWorld State tends to lead to trouble
16:17:36 <cschneid> raphie: state monad does that kind of thing. or you can manually pass around the data structure representing state.
16:17:52 <raphie> huh, cool, I'll check that out
16:17:56 <jle`> raphie: we handle state the same way, only "monad" allows for nice abstractions to hide away much of the plumbing
16:18:03 <raphie> this language has so many layers, hah. it's fun to discover
16:18:04 <jle`> the hassle of including arguments etc.
16:18:06 <cschneid> state monad is just a way to automatically hand things around, it's not really doing anything beyond that.
16:18:25 <jle`> it's all the same as you ever did; monads are just a way to expressively do it
16:18:56 <dmj`> > flip evalState 5 $ do five <- get; return (five+1)
16:18:57 <lambdabot>   6
16:19:03 <mreh> We use a Monad called State, which wraps up a function (s -> a -> (b, s))
16:19:30 <raphie> what's b? I assume s is the new state after the function has run
16:19:33 <mreh> and when you combine them, the Monad type class does the plumbing for you
16:19:36 <cschneid> raphie: you're new - for now, go ahead and wire the state in yourself to make a working program. Then learn the state monad when you get to it, and redo your program. See that it works the same, but is much easier to deal with :)
16:19:38 <mreh> yes
16:19:53 <jle`> yeah my first few projects i wired around manual state
16:20:03 <jle`> don't worry about it
16:20:17 <augur> i sometimes wire state manually
16:20:23 <augur> or sometimes i reinvent the State monad
16:20:29 <raphie> ok cool. mainly I've just been playing around with currying and ADT's and laziness and pattern matching. so nice.
16:20:32 <augur> since i have no idea how to use the built-in State monad
16:20:37 <jle`> augur: that's nice :)
16:20:43 <jle`> er, raphie
16:20:43 <augur> this obsession with monad transformers irritates the hell out of me
16:20:54 <jle`> are you following any text?
16:21:03 <mreh> augur, why?
16:21:03 <jle`> augur: state monad doesn't have to do with monad transformers?
16:21:33 <augur> jle`: the state monad in prelud is based off StateT
16:21:42 <augur> a lot of the monads in prelude are
16:21:46 <augur> or maybe just in Control.Monad
16:21:48 <augur> i dont remember
16:21:51 <augur> its really annoying tho
16:21:53 <jle`> yes but using it requires no congition of monad transformers
16:21:56 <mreh> we have transformers built into Haskell now?
16:22:00 <mreh> I've been away a while
16:22:10 <augur> jle`: i do my best to avoid anything involving monad transformers
16:22:11 <dmj`> into the haskell platform
16:22:12 <augur> i dont trust them
16:22:18 <dmj`> augur why?
16:22:31 <jmcarthur> augur: there is no state monad in prelude
16:22:36 <augur> im sure they work, but i dont understand how, so i wont use them.
16:22:41 <jmcarthur> augur: nor in Control.Monad
16:22:50 <jmcarthur> augur: nor in base at all, for that matter
16:22:56 <mreh> what approach to transformers did they settle on?
16:23:17 <jle`> you use the state monad as if it was not a transformer, there is really no difference
16:23:21 <augur> ever since i got into functional programming, i've refused to use things i dont understand, because ive become accustomed to actually being able to understand things
16:23:26 <jle`> ah okay
16:23:45 <augur> unlike with other languages where so much is just necessarily black boxed out of sight and mind that its all faith based anyway
16:24:00 <augur> jmcarthur: so its just StateT then
16:24:11 <jmcarthur> no
16:24:18 <jmcarthur> augur: there are no monad transformers in base at all
16:25:28 <augur> jmcarthur: er..
16:25:50 <augur> jmcarthur: maybe thats true. i dont know how this stuff is organized.
16:26:11 <augur> Control.Monad.State.Lazy has StateT
16:28:08 <dmj`> mtl and transformers are two transformer pkg's that are included w/ the haskell platform
16:28:15 <dmj`> > flip evalStateT 4 $ do { x <- get; liftIO (print "hi"); return x }
16:28:16 <lambdabot>   No instance for (Control.Monad.IO.Class.MonadIO m0)
16:28:16 <lambdabot>    arising from a use o...
16:28:31 <mreh> dmj' transformers fd?
16:28:35 <mreh> ...
16:28:39 <dmj`> > flip evalState 4 $ do { x <- get; return $ x + 1}
16:28:40 <lambdabot>   5
16:29:39 <mreh> there too many ways of doing transformers IIRC
16:29:52 <dmj`> transformers-0.3.0.0 and mtl-2.1.2 in latest I see
16:30:08 <mreh> monads-tf is another
16:30:37 <mreh> and monads-fd
16:31:27 <tomberek> what module has the function that can return the version number of a package that is in use?
16:31:50 <tomberek> looking for something like  PackageName -> IO PackageVersion
16:34:54 <tippenein> http://lpaste.net/96392 How could I recompose this filter with composition? It seems a bit gross
16:35:22 <Iceland_jack> What do you mean ‘recompose’?
16:36:13 <tippenein> was thinking (elem . fst)
16:36:15 <mreh> as in "restate"
16:36:44 <tippenein> sure. "make-it-suck-less"
16:36:58 <Iceland_jack> tippenein: Like this?
16:36:58 <Iceland_jack> @pl \a -> elem (fst a) stateKeys
16:36:58 <lambdabot> flip elem stateKeys . fst
16:37:20 <mreh> (`elem` stateKeys) . fst
16:38:41 <mreh> same thing, a little more idiomatic maybe
16:39:13 <Iceland_jack> Something like (\(key, _) → key `elem` stateKeys) is fine too..
16:39:54 <tippenein> very nice. both those work
16:40:09 <tippenein> haven't used flip before this
16:40:20 <mreh> Iceland_jack: unicode, how is that working out for you?
16:40:32 <tomberek> dcoutts: any way to get package version info inside a running program? eg: PackageName -> IO PackageVersion  ref: http://www.jjeasy.com/how-to-programmatically-retrieve-ghc-package-information/)
16:40:49 <Iceland_jack> mreh: It has caused me to lose weight and become happier.
16:40:55 <Iceland_jack> ⊑_⊑
16:41:04 <mreh> :)
16:41:23 <mreh> Iceland_jack: does your editor do the replacements for you?
16:41:38 <Iceland_jack> No, I have a massive .XCompose file that I've gathered over the years
16:42:49 <dcoutts_> tomberek: sure, Cabal provides a module you can import that contains the version of your package, plus paths to data files etc
16:43:20 <tomberek> dcoutts: i've used that before. I want to know the version of a package of an imported module
16:43:44 <dcoutts_> tomberek: that's provided via a cpp macro
16:44:06 <dcoutts_> tomberek: well more precisely, the versions of all your package's deps
16:44:32 <dcoutts_> tomberek: so you need to know which module comes from which package
16:45:17 <tomberek> dcoutts: where is this cpp macro? that's exactly what I need: "version of all your package's deps"
16:45:39 <chrisdone> dcoutts_: what ghc version are you building hacker-server with?
16:45:51 <dcoutts_> tomberek: take a look at dist/build/autogen/cabal_macros.h
16:46:04 <dcoutts_> chrisdone: 7.6.3 I think
16:46:07 <dcoutts_> why?
16:47:43 <monochrom> I am so dumb! I print x/y as a percentage, but I forgot it was x/y*100. I was like "this should be about 50%, why does it say 1%?" for half an hour
16:48:04 <monochrom> (fortunately, most of that half-hour was dinner)
16:50:46 <jle`> should have made it a type
16:50:52 <jle`> so that the compiler could debug for you
16:50:56 <jle`> don't you know that we don't debug anymore
16:52:18 <tomberek> dcoutts_: how do I access the values/versions in cabal_macros ?
16:52:31 <chrisdone> dcoutts_: i had a compile error earlier with cabal install --dependencies-only, but i just tried it again and it succeeded, go figure
16:53:00 <dcoutts_> tomberek: ordinary cpp
16:53:43 <dcoutts_> tomberek: e.g. let baseVersionString = VERSION_base
16:54:04 <dcoutts_> of course need to use {-# LANGUAGE CPP #-}
16:54:24 <tomberek> dcoutts_: that will work as Haskell source? ahh, that's it,,, cool.. .thanks for spelling it out!
16:57:07 <chrisdone> cool, i have a local hackage-server running
16:57:11 <geekosaur> until you run into a cpp that only works right on C source code *glares at xcode 5*
17:01:52 <mreh> you could run it through a custom preprocessor
17:02:21 * hackagebot stripe 0.3.0.1 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.3.0.1 (MichaelSchade)
17:02:24 <mreh> not that I have tried
17:02:29 <mreh> oooh, nice
17:02:47 <mreh> stripe - death to paypal
17:03:50 <tippenein> Paypal's switch to nodejs - death to paypal
17:03:54 <tippenein> ;)
17:04:07 <chrisdone> how confidence inspiring
17:04:12 <mreh> they did what?
17:05:10 <tippenein> I'll try to find the article I read, sec
17:06:00 <tippenein> lol https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/
17:11:54 <dmj`> they acquired braintree tho
17:12:19 <haasn> tippenein: alternatively, they could have written both the front and back ends in Haskell ;)
17:12:33 <haasn> (but really. can't their full-stack engineers learn java *and* javascript or is that too much to ask of corporate programmers?)
17:13:05 <Clint> oh snap
17:14:09 <derekv> Trying to figure out
17:14:21 <derekv> Trying to figure out the type I should have here line 44 http://lpaste.net/3468369959069941760
17:14:23 <chrisdone> huh. does cpp-options implicitly enable -XCPP?
17:15:31 <_justjust> is there something newer than haskellmode-vim, it doesn't show types (e.g. type main not known)
17:15:31 <haasn> “import qualified Data.Text.Internal (Text)” <- this looks weird
17:15:37 <derekv> With the type I give, it has an error on "getBy" : Could not deduce (PersistEntityBackend v ~ Db.SqlBackend) from the context (PersistEntity v, MonadIO m) bound by the type signature for idempotentInsert :: (PersistEntity v, MonadIO m) => v -> Unique v -> m ()
17:16:55 <haasn> derekv: silly question but have you tried adding PersistEntityBackend v ~ Db.SqlBackend to the list of constraints?
17:18:20 <derekv> derp, had set /ignore * by accident, so i have no idea if anyone said anything
17:18:38 <geekosaur> [30 01:08] <haasn> derekv: silly question but have you tried adding PersistEntityBackend v ~ Db.SqlBackend to the list of constraints?
17:19:01 <haasn> or if all else fails, let GHC infer the type signature? (unless it's too ambiguous)
17:19:08 <haasn> or make it more monomorphic
17:19:08 <augur> hm. using prolog to satisfy multiple constraints simultaneously is interesting.
17:19:23 <augur> i mean, i guess thats sort of the point, but i'd never thought of it quite like that before
17:19:37 <augur> having multiple propositions as the top-level command
17:19:40 <geekosaur> I probably would have left off the type and then asked ghci what it inferred
17:19:46 <haasn> augur: using ASP to do it is interesting, too
17:19:53 <augur> haasn: ASP?
17:20:05 <haasn> augur: https://en.wikipedia.org/wiki/Answer_set_programming
17:20:25 <augur> haasn: ah, never really understood how that works
17:20:38 <haasn> me neither, though I've looked at it recently and it seems like magic to me (to be fair, so did Haskell at first)
17:20:59 <haasn> all of those NP-hard search problems like solving sudoku or euler paths or whatever? <10 SLOCs of ASP
17:21:00 <derekv> haasn: so my next question was going to be about the error, I don't know what it means "(PersistEntityBackend v ~ DbSqlBackend)" ... if I let the ghc infer the type signature, it looks really crazy to me
17:21:34 <derekv> I was messing with it to try to learn however. Trying to see if I could get rid of any lint warnings
17:21:36 <haasn> derekv: PersistEntityBackend is an associated type of the PersistEntity typeclass; ~ is the constraint for type equality
17:22:00 <augur> haasn: they're always easy to specify. its the efficiency thats the issue. sudoku is a trivial specification, but not so trivial a problem.
17:22:04 <haasn> derekv: basically it means, in english:  ‘v’ must be an instance of PersistEntity and furthermore, the PersistEntityBackend defined in that instance must be Db.SqlBackend
17:22:16 <augur> thats the difference between logic and programming
17:22:39 <haasn> augur: exactly; the magic part is that the programs it produces are so efficient
17:22:45 <augur> hmm
17:22:46 <derekv> haasn: oh... because I refrence sqlite in the definition
17:22:48 <haasn> there's so much research into it yet (I) haven't even heard of them
17:23:02 <haasn> augur: I'm not sure if I just saw cherry-picked examples
17:23:57 <haasn> like; if I give a trivial equivalent definition of a sudoku solver in Haskell I have to put in lots of work to make it terminate within any human timeframe
17:24:15 <haasn> that is, if I start with just a trivial “generate all the possible sudoku fields, filter to ones that are valid solutions”
17:25:03 <haasn> but an equivalent approach in ASP for this and a few other problems produces code as fast as the fastest haskell code I could have come up with myself
17:25:11 <augur> huh.
17:26:11 <derekv> Would it be possible to implement my function in a way that could take any PersistEntity?
17:26:15 <augur> what i was doing in prolog tho was silly things like
17:26:50 <augur> length(Xs,3), all(a,Xs)
17:26:55 <augur> to yield Xs = [a,a,a]
17:27:02 <haasn> augur: sudoku: http://bpaste.net/show/154193/
17:27:17 <augur> and other silly things that synthesize values based on constraints
17:27:57 <haasn> or for an example solution of https://xkcd.com/287/ see http://bpaste.net/show/154194/
17:28:20 <haasn> augur: http://hakank.org/asp/
17:28:34 <haasn> some more programs
17:28:50 <augur> haasn: ill read those once i understand how to implement it :)
17:28:53 <haasn> minesweeper http://hakank.org/asp/minesweeper.lp
17:29:02 <haasn> nqueens http://hakank.org/asp/nqueens.lp <- these are all below 10 lines..
17:30:56 <haasn> to be fair, efficiency *is* a concern (obviously); and sometimes you have to help it with performance by adding more restrictions that allows it to rule out false branches more readily
17:49:49 <raphie> I'm back! typeclasses make sense now!
17:50:02 <raphie> another question, anyone have a recommendation for an ORM?
17:51:08 <jle`> i use Persistent & Esqueleto
17:51:43 <jle`> pretty good on the type safety department
18:20:14 <phserr> is there a round function (or workaround) with type (Integral b, Num a) => a -> b instead of (Integral b, RealFrac a) => a -> b?
18:20:54 <Cale> phserr: Not possible
18:22:10 <mreh> Num wont tell you enough I suppose
18:22:28 <Cale> Consider e.g. complex numbers or polynomials.
18:23:06 <phserr> Guess I should read more on haskell numeric classes to understand more specifically what they're representing
18:23:15 <mreh> http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num
18:24:47 <phserr> Thank you.
18:27:17 <xcthulhu> Do the Gaussian integrals instance an integral class?
18:27:27 * hackagebot purescript 0.1.14 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.14 (PhilFreeman)
18:28:30 <xcthulhu> Gaussian integers*
18:28:37 <mreh> xcthulhu: if you can implement it, then yes
18:29:09 <mreh> from the documentation "Minimal complete definition: quotRem and toInteger"
18:30:17 <xcthulhu> I'm not sure how `quot` would work for the Gaussian integers...
18:30:23 <mreh> :)
18:30:47 <startling> Integral is not for integrals.
18:31:11 <startling> Maybe gaussian integrals are integral. I don't know.
18:31:29 <heatsink> Gaussian integers are complex integers I think
18:31:44 <xcthulhu> startling: I know.  Gauss integrals and Gaussian integers are two different things, named after the same guy.
18:31:55 <xcthulhu> *Gaussian integrals even
18:32:18 <mreh> no, they're too derivative
18:32:22 <mreh> badum tish
18:32:26 <mreh> I have to go
18:32:31 <xcthulhu> haha
18:32:40 <mreh> bye
18:32:50 <startling> xcthulhu, oh, I see.
18:33:17 <xcthulhu> Gaussian integers are the integer domain Z[i]
18:33:48 <xcthulhu> i.e., numbers of the form n + i m  where n and m are both integers
18:35:27 <startling> oh, I see.
18:35:28 <heatsink> Complex Integer is not a Num.
18:35:33 <heatsink> Seems like it should be
18:36:03 <xcthulhu> Nah that I look at it, I don't think they are Integrals, because `div` doesn't make a whole lot of sense for them
18:36:55 <xcthulhu> Okay, I am making too many typos so it's time to go.
18:38:22 <ReinH> chrisdone: \o/
18:39:31 <Taneb> Is there a more efficient way to do what I'm doing than starting with a big set and removing things?
18:40:32 <startling> Haskell's numeric tower is a little unfortunate.
18:41:24 <heatsink> what are you doing, Taneb
18:41:36 <benzrf> why is it called Prelude
18:41:54 <heatsink> it's first
18:42:01 <benzrf> hmm
18:42:07 <benzrf> so it's like a prelude to the rest of the libs ?
18:42:14 <heatsink> import Prelude
18:42:17 <heatsink> import Intermezzo
18:42:19 <heatsink> import Finale
18:42:19 <startling> benzrf, yep
18:42:24 <benzrf> k
18:42:44 <Taneb> heatsink, I'm making a Set of possible solutions, then removing some obvious non-solutions
18:42:45 <Iceland_jack> Obviously Prelude should be FirstStuff
18:42:57 <Iceland_jack> import FirstStuff hiding ((.))
18:43:01 <nooodl> i've always imagined it as a Prelude to the rest of your program actually
18:44:01 <heatsink> It depends how you remove solutions
18:44:06 <Taneb> S.delete
18:45:05 <heatsink> If, for some solutions, you can avoid creating the data structure and sorting it (sets are sorted), you can reduce time and space usage
18:45:13 <Taneb> Hmm, I think I can see a way to get it from O(n log n) to O(n)
18:46:49 <haasn> module Finale ( module Control.Lens ) where import Control.Lens
18:48:09 <nooodl> the final boss of haskell
18:52:29 * hackagebot serf 0.1.0.0 - Interact with Serf via Haskell.  http://hackage.haskell.org/package/serf-0.1.0.0 (IanDuncan)
19:06:29 <pavonia> When constructing a vector with Data.Vector.iterateN, are the intermediate results of the former fields used to calculate the latter?
19:09:35 <pavonia> Hhm, I guess that is true if I pass it a strict function
19:11:44 <cschneid> I have some (very heavily commented) code here: http://watchchrislearn.com/blog/2013/11/28/playing-with-the-either-monad/ -- My goal is to inline the dowork function into main now, and I can't figure out how to have an embedded either monad running in the outer iO scope (no transformer needed, the either doesn't do io)
19:12:11 <cschneid> I know it isn't perfect form to embed that, but I'm trying to figure out how monads of differnet kinds interact
19:13:59 <cschneid> https://gist.github.com/cschneid/7b9014b6f2da535769af
19:14:28 <pavonia> let res <- do { ... either stuff here ... }, you mean like that?
19:14:39 <cschneid> I get this error, so I'm thinking that inner `do` block is being typed as IO, not Either. Is what I'm doing possible like this? Or is this a use of eitherT
19:14:42 <pavonia> erm, = not <-
19:15:27 <cschneid> pavonia: yeah, that's the goal. Make use of either monad's nice cascading Left behavior, inside a larger function which is orchestrating other work
19:15:39 <pavonia> yeah, use a let then
19:17:09 <cschneid> ohh! I see! The indendtation rules were screwing me up!
19:17:44 <cschneid> `let result = do` then a newline then indented inside the let, but before the "result" part.
19:17:47 <cschneid> didn't parse right
19:18:02 <khyperia> Anyone in here vim wizards? I've got trouble with preprocessor directives. https://dl.dropboxusercontent.com/u/18830644/Screenshot%202013-11-29%2021.59.28.png
19:18:29 <Jookia> In ghci I'm breaking at a function but once I'm there, I'd like to see the args. I can do this with stepping a few times but is there a better way?
19:20:05 <cschneid> khyperia: that's the compiler showing that error, not vim itself.
19:20:17 <khyperia> It's I think the syntastic plugin
19:20:17 <cschneid> vim => syntastic => ghc_mod
19:20:24 <khyperia> Something like that.
19:20:30 <cschneid> syntastic is reporting the error that ghc_mod is showing you
19:20:40 <khyperia> Alright, sure
19:20:54 <cschneid> myt guess is that ghc_mod isn't getting called with a flag that tells it to do preprocess
19:20:57 <cschneid> (or can't? I have no idea)
19:23:20 <cschneid> khyperia: dive down to the console, play with ghc-mod manually to get it to work as expected. Then set flags in ghc-mod (see the syntastic/syntax_checkers/haskell/ghc-mod.vim for the flags it starts w/ and how to deal with it
19:23:38 <khyperia> alright, sure
19:27:37 * hackagebot hlibgit2 0.18.0.12 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.12 (JohnWiegley)
19:28:22 <Tinned_Tuna> <3 Control.Parallel
19:28:57 <khyperia> Hmm... got to "ghc-mod check -g -XCPP [file]", excluding the -g -XCPP causes it to give that old error, and with it says "phase `C pre-processor' failed (exitcode = 1)". No idea why.
19:30:55 <khyperia> not sure how to get it to print the output of the preprocessor
19:39:59 <ParahSailin> very difficult to build package "network" under windows
19:40:30 <chrisdone> is there anything easy to do on windows?
19:40:56 <chrisdone> probably the reboot feature
19:42:39 * monochrom makes a newbie error! the mistake is "\Ctor x y -> ...", it should be "\(Ctor x y) -> ..."
19:43:06 <chrisdone> eh, i do that all the time
19:43:08 <johnw> monochrom: i did that just the other day
19:44:48 <Jookia> Is there a ... looped index operator?
19:45:10 <johnw> what is that?
19:45:20 <johnw> you mean, it loops and counts while doing so?
19:45:27 <Jookia> [1..10] !! -1 == 10
19:45:47 <johnw> ahh
19:46:17 <johnw> i've been meaning to write a library that lets you use splices and indices exactly as Python allows
19:46:27 <Jookia> Ooh, that sounds fun.
19:46:43 <geekosaur> the problem with doing that with lists is they're linked lists
19:47:09 <johnw> it would just involve copying
19:47:12 <geekosaur> if you don't hold onto the head, you can't walk "backwards"
19:48:07 <johnw> it would be more fun as a lens
19:49:21 <johnw> something along the lines of [1,2,3,4] & range 1 2 .~ [5, 6] ==> [1,5,6,4]
19:52:39 * hackagebot lord 1.20131130 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-1.20131130 (rnons)
19:54:16 <Jookia> (!!!) list i = list !! (if i < 0 then length list - i else i)
19:54:31 <Jookia> oh woops, that should be
19:54:35 <Jookia> (!!!) list i = list !! (if i < 0 then length list + i else i)
19:55:00 <Jookia> [1..10] !!! (-1) == 10
20:08:48 <khyperia> couldn't you also do:
20:09:09 <khyperia> (!!!) list i = list !! (i `mod` length list)
20:10:02 <Ralith> you could
20:10:27 <nisstyre> there should be a way to do it without using length
20:10:47 <scott_> There's no way to do negative indexing without using length
20:11:10 <scott_> But cyclic indexing could be (!!!) list i = cycle list !! i
20:11:23 <Jookia> khyperia: I didn't know modulo worked with negatives
20:11:31 <Jookia> khyperia: I am not good at math :P
20:11:36 <nisstyre> it's defined over Z I suppose
20:11:50 <khyperia> modulus of a negative != remainder of a negative (mod /= rem)
20:11:54 <khyperia> keep that in mind
20:12:05 <scott_> > -2 `mod` 10
20:12:06 <lambdabot>   -2
20:12:11 <scott_> That won't help with indexing
20:12:17 <heatsink> Need parentheses
20:12:19 <nisstyre> > -3 `mod` 2
20:12:20 <lambdabot>   -1
20:12:24 <heatsink> > (-2) `mod` 10
20:12:25 <lambdabot>   8
20:12:30 <nisstyre> > (-3) `mod` 2
20:12:31 <lambdabot>   1
20:12:33 <scott_> heatsink: Ah, thanks
20:12:49 <nisstyre> it was -(3 `mod` 2)
20:12:53 <scott_> Right
20:13:32 <heatsink> Implementing mod in terms of div is annoying
20:13:40 <heatsink> rem I mean
20:14:08 <heatsink> which is what you have to do if you want `mod` in C code
20:18:27 <Ralith> 20:05:39 < scott_> There's no way to do negative indexing without using length
20:18:31 <Ralith> sure there is
20:18:46 <Jookia> Oh?
20:20:27 <nisstyre> Ralith: I'm thinking it would be quite easy with a zipper, but you could just save a pointer to the head of the list any other way
20:21:05 <nisstyre> and then if you have an index >0 after reaching the end you just start over...
20:21:20 <scott_> Ralith: How?
20:21:21 <nisstyre> er, wait
20:21:25 <Jookia> That still sounds like you have to traverse the list?
20:21:42 <nisstyre> an index less than zero I mean
20:22:07 <triliyn> Traversing the list is unavoidable
20:22:24 <Ralith> for index -n you'd just do two simultaneous traversals, starting the second one at the head when the first one reaches the nth element
20:22:40 <Ralith> then when the first one reaches [], the second one's current element is returned
20:22:46 <nisstyre> my solution makes no sense actually
20:23:05 <scott_> Ralith: Ah, clever
20:23:28 <triliyn> But yeah, you can do it in one traversal rather than two (which is what the naive "list !! (length list + i)" does)
20:23:45 <Ralith> well, it's still sort of two traversals this way
20:23:55 <triliyn> hmm, I guess
20:24:02 <Ralith> just parallel instead of serial
20:24:03 <nisstyre> Ralith: it wastes space not time though
20:24:22 <nisstyre> and not even that much space
20:24:24 <Ralith> nisstyre: insofar as that a factor of 2 can be called a waste
20:24:24 <triliyn> How does it waste space?
20:24:43 <Ralith> either you spend twice as much time traversing or you store twice as many cons cells
20:24:56 <Ralith> since you normally only store 1 cons cell, the space cost is probably preferable
20:25:27 <scott_> I'm not sure that method really gains you anything, or I'm having a hard time seeing how it does
20:25:41 <Jookia> It gains you geek cred
20:26:01 <nisstyre> scott_: it should work on infinite lists
20:26:07 <scott_> lol
20:26:22 <Jookia> scott_: Uhh
20:26:30 <Jookia> nisstyre: Uhh_*
20:26:45 <nisstyre> oh right nevermind
20:26:51 <nisstyre> it has to check for []
20:27:12 <Jookia> Looping an infinite list doesn't make much sense either.
20:27:39 <Jookia> Does it? :s
20:27:52 <nisstyre> Jookia: well, it's not useful
20:28:00 <triliyn> > foldr (||) (cycle [False,True])
20:28:01 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
20:28:01 <lambdabot>              with actual type...
20:28:09 <triliyn> > foldr (||) False (cycle [False,True])
20:28:10 <lambdabot>   True
20:28:36 <Jookia> nisstyre: How would that work, even if not useful?
20:28:48 <nisstyre> Jookia: I actually don't know
20:28:49 <triliyn> It is usually not useful, but sometimes it might be convenient to use infinite lists instead of like a while loop
20:29:10 <scott_> Jookia: What do you mean by looping an infinite list?
20:29:19 <triliyn> I'm not sure if doing this ever has an advantage over explicit recursion, but it can be done
20:29:34 <Jookia> scott_: "nisstyre: scott_: it should work on infinite lists" I assume they meant negative indexing infinite lists.
20:29:44 <nisstyre> yes I was thinking of negative indexing
20:29:52 <nisstyre> but that's only one part of it
20:29:58 <Jookia> Oh?
20:30:09 <triliyn> oh wait, "looping" as in "python-style indexes" doesn't work for infinite lists, yeah
20:30:18 <triliyn> Or well, negative indexes wouldn't
20:30:23 <nisstyre> we also want them to roll around or whatever
20:31:54 <Jookia> [1..] !!! -10 == ???
20:32:06 <nisstyre> yeah I know it doesn't make any sense
20:32:11 <Jookia> :P
20:32:24 <triliyn> [1..] !!! -10 = bottom, of course
20:32:26 <nisstyre> maybe in the context of set theory it does though
20:33:06 <Ralith> scott_: it would perform substantially better on extremely large lists
20:33:27 <dwcook> Negative indexing wouldn't work for a general infinite list, but you could define a list representation that makes explicit certain subsets of that (e.g., an infinite list with a finite list appended) where it could make sense.
20:33:31 <nisstyre> Jookia: but if you wanted that to be defined you could just return the infinite list itself, which makes sense, sort of
20:33:59 <scott_> Ralith: Why is that, if it has to do the same number of work (one part going through the whole list, the other going up to the nth cell)
20:34:02 <dwcook> Actually my example isn't quite kosher either, but I'm sure there are some subsets you could come up with.
20:34:04 <scott_> same amount*
20:34:20 <Ralith> dwcook: heh, that's a fun thought; a double-ended infinite list is not something I'd imagined before
20:34:27 <Ralith> scott_: locality
20:34:34 <nisstyre> dwcook: isn't just returning the same list a sensible definition of it for infinite lists?
20:35:02 <Ralith> nisstyre: but it's not necessarily the same list for non-uniform lists
20:35:07 <dwcook> nisstyre, definition of what?
20:35:15 <nisstyre> dwcook: negative indexing on infinite lists
20:35:18 <Jookia> My brain kind of has the logic that we know the start and end of a looped around infinite list, but we're indexing from the center
20:35:19 <scott_> Ralith: On really large lists, indexing near the end, wouldn't the second part be so far along and far from the first part that locailty would be worse?
20:35:27 <dwcook> nisstyre, negative indexing asks for an element, so returning the list wouldn't work at all.
20:35:32 <nisstyre> dwcook: say you want the list and all but the "last" 10 elements
20:35:35 <dwcook> nisstyre, I think I'm misunderstanding what you're saying.
20:35:45 <monochrom> at the end of an infinite list, you will find unicorns
20:35:50 <monochrom> @quote unicorn
20:35:50 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
20:35:57 <dwcook> nisstyre, asking for "all but the last 10" elements of an infinite list is the identity on that list
20:36:02 <nisstyre> dwcook: yes
20:36:03 <Ralith> scott_: no, the second and first traversals are positioned at a fixed number of cons cells apart (equal to the negation of the negative index)
20:36:07 <nisstyre> dwcook: that's what I'm saying
20:36:29 <scott_> Ralith: Oh, I had it backwards - really large negative indexes on large lists would have worse locality
20:36:39 <dwcook> nisstyre, sorry, I thought the discussion was about obtaining a specific element, n places from the end of the list.
20:36:55 <Jookia> Isn't it? :s
20:36:59 <nisstyre> dwcook: I was thinking of slicing
20:37:05 <simon> I wonder if you can derive a Dyad from a Monad.
20:37:20 <nisstyre> sorry I didn't make that clearer
20:37:21 <Ralith> scott_: yes, but never worse than using 'length'.
20:37:46 <nisstyre> the analogy to Python confused me I think
20:37:48 <monochrom> infinite lists do not have to be cyclic, even conceptually. the list [1, 2, 3, ...] is not cyclic. every item appears only once.
20:38:08 <dwcook> monochrom, such a list doesn't have a sensible "n from last" operation, I'd say.
20:38:21 <monochrom> that is exactly right.
20:38:41 <scott_> We could imagine a list like [1,2,3,...] ++ [...,3,2,1]
20:38:41 <monochrom> [1, 2, 3, ...] debunks "conceptually it is a ring"
20:38:53 <Jookia> scott_: That's how I'm imagining it
20:38:56 <scott_> Or something like that
20:39:12 <simon> I always thought there were rainbows at the end of [1..]
20:39:13 <scott_> But that's just like a pair of lists
20:39:33 <dwcook> However, if we had data MyList a = … | Cycle (FiniteList a) (where FiniteList is some magical type that I'm not sure can exist), then the Cycle case would have some sensible "n from last".
20:39:34 <newsham> > iterate (+3) 1
20:39:35 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
20:39:55 <Jookia> Surely if we have [1,2,3,...] ++ [...,3,2,1] we don't need to fully traverse the list, just go to the center. :P
20:40:00 <Jookia> Problem solved.
20:40:26 <dwcook> Jookia, that looks like a fun problem – what is head [...,3,2,1]?
20:40:38 <trolling> dwcook: data FiniteList a = Null | Cons a !(FiniteList a) maybe?
20:40:43 <monochrom> no, you should imagine a list like [1, 2, 3, ...] ++ [2, 4, 6, ...] ++ [3, 6, 9, ...] ++ ... ++ [2, 3, 5, 7, 11, ...]
20:40:56 <simon> I'm curious if there's an easy answer here: how does lambdabot know the exact level of laziness required to print that amount of the infinite list? I mean, it seems to depend on how much of it is being shown.
20:40:57 <Ralith> trolling: yeah, that was what I was going to say
20:41:09 <monochrom> you should imagine every infinite list that cannot possibly be periodic.
20:41:09 <dwcook> trolling, that looks reasonable.
20:41:29 <Jookia> dwcook: head [...,3,2,1] = last [1,2,3,...] obviously
20:41:51 <dwcook> Jookia, and then last [1,2,3,...] is what?
20:41:52 <newsham> > take 10 ([1,4,9]...)
20:41:53 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
20:42:11 <Rylee> @src iterate
20:42:11 <lambdabot> iterate f x =  x : iterate f (f x)
20:42:13 <Jookia> dwcook: The head of [..., 3,2,1] :P
20:42:19 <nisstyre> dwcook: undefined?
20:42:21 <triliyn> :t (...)
20:42:22 <lambdabot> Num b => [b] -> [b]
20:42:25 <dwcook> Jookia, well, it's bottom any way you look at it. :P
20:42:31 <scott_> @src (...)
20:42:31 <lambdabot> Source not found. Where did you learn to type?
20:42:35 <Rylee> take 30 $ iterate (+4) 4
20:42:40 <Rylee> > take 30 $ iterate (+4) 4
20:42:41 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
20:42:42 <newsham> scott_: http://codepad.org/WDXeV59b
20:42:58 <Jookia> dwcook: You only need to traverse to half of infinity.
20:43:00 <trolling> newsham: that's extremely cool
20:43:10 <simon> :t flip flip flip
20:43:10 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
20:43:17 <newsham> trolling: its a difference engine
20:43:21 <newsham> thank babbage
20:44:19 <newsham> http://www.thenewsh.com/~newsham/x/machine/diffEngine.hs
20:44:43 <Ick> Dear Jake: If you are out there and the names Aaron Austin and Dom mean anything to you, get in touch man, we miss ya. <3
20:45:06 <chrisdone> what's it called when you have an AST but the things in the AST that represent functions are actual functions?
20:45:17 <chrisdone> in DSLs
20:46:18 <monochrom> higher-order abstract syntax, HOAS
20:47:24 <chrisdone> that's the one, thanks
20:48:54 <tac> What does HOAS actually mean?
20:49:02 <tac> That's one of those terms I've never quite understood
20:49:24 <tac> Is that where you represent a function in the object language with a wrapped function in the subject language?
20:49:37 <joelteon> I didn't know there was a stream-fusion library, that's awesome
20:49:46 <heatsink> There are many stream-fusion libraries
20:50:09 <newsham> just dont cross the streams
20:50:17 <chrisdone> tac: yeah
20:50:21 <heatsink> HOAS represents variable binding in the object language by functions in the meta language
20:51:01 <heatsink> Instead of data Exp = Let Var Exp Exp, you have data Exp = Let Exp (Var -> Exp)
20:51:33 <heatsink> eh, I think that last Var should be Exp
20:52:40 <newsham> isnt that a much "bigger" data type?
20:54:23 <heatsink> Sure, the type admits some values that aren't meaningful for HOAS
21:00:40 <joelteon> why is there a MonadPlus *and* an Alternative
21:01:35 <monochrom> MonadPlus was conceived earlier
21:12:59 <xpika> can someone show me how to write a lens?
21:13:07 <xpika> without template haskell
21:19:20 <ion> xpika: Do you have an example of a specific data type you’d like to write a lens for?
21:20:30 <chrisdone> xpika: http://hackage.haskell.org/package/lens-3.10/docs/Control-Lens-Lens.html#v:lens
21:20:36 <xpika> ion: basic example
21:21:10 <ion> chrisdone: That doesn’t really *explain* it.
21:21:35 <chrisdone> ion: he asked "can someone show me how to write a lens"
21:21:38 <chrisdone> ion: i showed
21:22:02 <ion> xpika: Perhaps i misinterpreted “how to”. Did i?
21:23:03 <xpika> lens (\(x,y)->x) (\s (x,y) -> (s,y))
21:23:06 <xpika> > lens (\(x,y)->x) (\s (x,y) -> (s,y))
21:23:08 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 f0)
21:23:08 <lambdabot>    arising from a use...
21:24:02 <scott_> > lens (\(x,y)->x) (\(x,y) s -> (s,y))
21:24:03 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 f0)
21:24:04 <lambdabot>    arising from a use...
21:24:09 <scott_> :t lens (\(x,y)->x) (\(x,y) s -> (s,y))
21:24:10 <lambdabot> Functor f => (a -> f t) -> (a, t1) -> f (t, t1)
21:24:30 <chrisdone> xpika: you just got the args the wrong way round in the setter
21:24:56 <aji> :t (\x s z -> s (x s z)) (\s z -> s (s (s (z))))
21:24:56 <lambdabot> (t -> t) -> t -> t
21:25:16 <scott_> chrisdone: That didn't seem to be the cause of the error he got, though
21:26:20 <chrisdone> yes, the lambdabot error is nonsense, ignore that
21:26:44 <ion> Nonsense in, nonsense out. ;-)
21:27:30 <chrisdone> tautology, tautology
21:28:52 <scott_> > let fst = lens (\(x,y)->x) (\(x,y) s -> (s,y)) in set fst 'a' (2, 3)
21:28:54 <lambdabot>   ('a',3)
21:29:05 <scott_> > let fst = lens (\(x,y)->x) (\(x,y) s -> (s,y)) in view fst (2, 3)
21:29:07 <lambdabot>   2
21:31:46 <xpika> scott_: ta
21:47:07 <Jookia1> In GHCI, is there a way to change scope?
21:47:31 <scott_> In what way?
21:47:48 <Jookia1> Well, I'm breaking at a function and I want to use the functions and variables in it to toy around with. Is this possible?
21:48:06 <scott_> Hmm, I don't know
21:48:36 <Jookia1> It's something that I'd like to do for debugging. :\
21:48:50 <scott_> It does sound useful
21:49:24 <Jookia1> I can't find anything in the documentation/google about it, it seems the only way to get stuff in scope is to step through it which only gives me pieces at a time (and if I'm lucky, function args)
21:49:40 <scott_> Jookia1: http://www.haskell.org/haskellwiki/Debugging#Dynamic_breakpoints_in_GHCi
21:49:46 <scott_> Does that do what you want?
21:50:49 <Jookia1> I think this may be what I want: https://ghc.haskell.org/trac/ghc/ticket/3302
21:51:05 <Jookia1> hmm
21:51:21 <Jookia1> The problem is that I don't have access to function args
21:51:48 <scott_> Don't you? What I linked to seems to give you args and where bindings
21:52:06 <Jookia1> Hmm. Let me pull up some code + ghci's stuff
21:52:48 * hackagebot gtk2hs-buildtools 0.12.5.0 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.12.5.0 (HamishMackenzie)
21:52:51 <Jookia1> http://sprunge.us/cKCK I apologize for the messy code
21:53:29 <khyperia> does anyone know what -XCPP uses as the preprocessor?
21:54:00 <scott_> Jookia1: Hmm, it seems like it's only showing stuff referenced in the RHS expression
21:54:17 <xpika> what do you guys think of my middle lens?
21:54:22 <xpika> let middleLens = lens  (\xs -> xs !! (length xs `div` 2)) (\xs n -> (\(h,ts) -> (h++ [n] ++ tail ts  ) ) (splitAt (length xs `div` 2) xs)) in set middleLens 999 $ [1,2,3,4,5]
21:54:25 <xpika> > let middleLens = lens  (\xs -> xs !! (length xs `div` 2)) (\xs n -> (\(h,ts) -> (h++ [n] ++ tail ts  ) ) (splitAt (length xs `div` 2) xs)) in set middleLens 999 $ [1,2,3,4,5]
21:54:27 <lambdabot>   [1,2,999,4,5]
21:55:24 <Jookia1> scott_: To get 'group' I have to drop in to one of the subfunctions and lose my scope and stuff
21:56:07 <Jookia1> In the GHCI bug report this issue seems to happen but isn't noticed
22:02:49 * hackagebot glib 0.12.5.0 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.12.5.0 (HamishMackenzie)
22:07:14 <film-4242> I love clojure, but don't want to neglect other functional langs. Is there a good "from clojure to haskell guide" anyone can vouch for?
22:09:35 <Ralith> @where lyah
22:09:35 <lambdabot> http://www.learnyouahaskell.com/
22:09:59 <Ralith> film-4242: generally better to just go with a good haskell resources like the above
22:10:45 <Ralith> resource*
22:11:28 <ion> There’s a nice combinatorial problem with the concept of “from Clojure to Haskell guide”.
22:11:38 <udevd_> > [1..4]==[1..4]
22:11:39 <lambdabot>   True
22:11:47 <udevd_> > [1..4] == [1..]
22:11:48 <lambdabot>   False
22:12:03 <ion> > [1..4] `isInfixOf` [1..]
22:12:04 <lambdabot>   True
22:12:57 <udevd_> [1..4] `isInfixOf` [1,0..]
22:13:06 <udevd_> > [1..4] `isInfixOf` [1,0..]
22:13:09 <lambdabot>   mueval-core: Time limit exceeded
22:22:51 * hackagebot cairo 0.12.5.0 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.12.5.0 (HamishMackenzie)
22:22:53 * hackagebot pango 0.12.5.0 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.12.5.0 (HamishMackenzie)
22:22:55 * hackagebot gtk3 0.12.5.0 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.12.5.0 (HamishMackenzie)
22:22:57 * hackagebot gio 0.12.5.0 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.12.5.0 (HamishMackenzie)
22:23:46 <Ick> Dear Jake: If you are out there and the names Aaron Austin and Dom mean anything to you, get in touch man, we miss ya. <3
22:25:33 <khyperia> Does anybody here know how ghc-mod works?
22:26:04 <khyperia> Specifically, I'm having trouble with very vague error messages about the C preprocessor failing.
22:31:04 <benzrf> liftM is fmap
22:31:06 <benzrf> isn't it?
22:31:30 <lispy> :t liftM
22:31:31 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
22:31:32 <lispy> :t fmap
22:31:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:31:34 <canon-> yes, specialized for monads
22:31:36 <benzrf> NeatBasis:
22:31:39 <benzrf> *neat
22:31:42 <benzrf> well i finally get it
22:31:43 <benzrf> :D
22:31:46 <benzrf> thanks hlint!
22:32:01 <benzrf> well i suppose i sort of got it before
22:32:04 <benzrf> i just didnt make the connection
22:32:24 <benzrf> anyway thanks :)
22:38:46 <khyperia> is there any way to get ghc to spit out why "phase `C pre-processor' failed (exitcode = 1)"?
22:42:50 <Javran> @pl let f g x y = g $ (+) x y
22:42:50 <lambdabot> (line 1, column 26):
22:42:50 <lambdabot> unexpected end of input
22:42:50 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ";" or "in"
22:43:05 <Javran> @pl f g x y = g $ (+) x y
22:43:05 <lambdabot> f = (. (+)) . (.)
22:43:40 <Javran> I'd better not write in this way...
22:43:52 <ion> f g x y = g (x + y)
22:45:18 <Javran> @pl f g bin x y = g $ bin x y
22:45:18 <lambdabot> f = (.) . (.)
22:46:12 <scott_> Some people define (.:) = (.) . (.)
22:46:23 <scott_> Then (f .: g) x y = f (g x y)
22:48:06 <Javran> scott_: yeah, exactly what I need: to apply an unary after a binary
22:51:04 <ion> Only make it more pointless if that makes it easier to comprehend.
22:52:31 <Javran> ion: I think in this case point-free style loses some readability..
22:52:46 <ion> yes
22:58:06 <khyperia> Could someone help me with this? https://dl.dropboxusercontent.com/u/18830644/confusingError.txt
23:03:17 <khyperia> "ghc -E typecheck\TcErrors.lhs" is fine as well - seems like only ghc-mod is screwed up.
23:04:38 <startling> :t \_ g -> (g .) . (+)
23:04:39 <lambdabot> Num b => t -> (b -> c) -> b -> b -> c
23:04:50 <startling> :t \f g x y = g $ (+) x y
23:04:51 <lambdabot> parse error on input `='
23:04:57 <startling> :t \f g x y -> g $ (+) x y
23:04:58 <lambdabot> Num a => t -> (a -> t1) -> a -> a -> t1
23:05:35 <scott_> startling: f wasn't a parameter
23:05:44 <Iceland_jack> startling: You can use @let to define a value
23:05:52 <Iceland_jack> @et f g x y = g $ (+) x y
23:05:54 <lambdabot>  Defined.
23:06:01 <Iceland_jack> > f succ 5 3
23:06:02 <lambdabot>   Ambiguous occurrence `f'
23:06:02 <lambdabot>  It could refer to either `L.f', defined at L.hs:1...
23:06:07 <Iceland_jack> @et f' g x y = g $ (+) x y
23:06:07 <lambdabot>  Defined.
23:06:09 <Iceland_jack> > f' succ 5 3
23:06:10 <lambdabot>   Ambiguous occurrence f'
23:06:10 <lambdabot>  It could refer to either L.f', defined at L.hs:156...
23:06:13 <Iceland_jack> sigh
23:06:28 <scott_> lol :)
23:17:55 * hackagebot OpenAFP-Utils 1.4.1.2 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.4.1.2 (AudreyTang)
23:22:56 * hackagebot LambdaHack 0.2.10 - A roguelike game engine in early and active development  http://hackage.haskell.org/package/LambdaHack-0.2.10 (MikolajKonarski)
23:24:57 <solrize> there was a reddit or stackoverflow in the past day or so that was a newbie question about type classes.. the person wanted to abstract out a record selection from several different types.  i remember the example selectors were catBelly, dogBelly, etc.  anyone remember that post?  i can't seem to find it.
23:34:46 <jle`> anyone have suggestions on monads/other structures that are useful because of their Applicative Instance, and not becuase of their monadness?
23:34:51 <jle`> things like parser combinators
23:35:42 <jle`> which have useful monad instances but are very useful on their own with just their applicative instance
23:41:19 <solrize> typeclassopedia might have some
23:41:48 <jle`> solrize: thanks
23:52:59 <navilan> Hello all...
23:53:26 <startling> jle`, I'm not sure what you mean.
23:53:27 <navilan> lets say I have a function x :: a -> (b, Maybe c) and another y :: c -> d ...
23:53:53 <navilan> is there a way to comose x and y in a point-free style to get z :: a -> Maybe d ?
23:53:56 <Twey> jle`: Any monad has a useful Applicative instance
23:53:57 <navilan> compose*
23:54:02 <Twey> s/m/M/
23:54:21 <Twey> jle`: Are you looking for things that have useful Applicative instances, but no Monad instance?
23:54:54 <startling> jle`, there's the Applicative/CFG thing for parsing.
23:55:01 <jle`> Twey: More like things that have usefulness using only <$> and <*>, and have many use cases/examples of such
23:55:22 <jle`> in contrast to things that are useful with (>>=)
23:55:29 <startling> jle`, any Monad has useful (<*>).
23:55:46 <jle`> i mean...things that are more 'famous' for their applicative uses than their monad uses
23:55:50 <startling> jle`, OK. the liftM functions can be expressed with (<*>) instead (they're called liftA).
23:55:51 <scott_> navilan: fmap z . snd . x
23:55:53 <startling> same with mapM
23:56:02 <Twey> navilan: fmap y . snd . x
23:56:15 <scott_> Err, yeah, s/z/y/
23:56:28 <jle`> any structures that are "famous" for their <$> and <*> instances, where the (>>=) usage does not take up much of the splotlight
23:56:41 <startling> jle`, I don't think there are any, no.
23:56:45 <Twey> jle`: FRP uses Applicative nicely, I think
23:56:45 <jle`> most popular monads like Writer, Reader, State, etc. are known for their (>>=)
23:56:56 <jle`> startling: I feel like parser combinators are one
23:56:58 <jle`> example
23:57:14 <jle`> I don't have much FRP experience but i'm doing research now and i feel like that might make sense
23:57:20 <navilan> scott_, Twey : Thank you - trying that now.
23:57:26 <Twey> jle`: Phooey is a GUI library that has a nice Applicative model
23:57:47 <Twey> jle`: Vinyl uses its Applicative instance for validation
23:58:05 <startling> jle`, I think you're approaching this the wrong way.
23:58:17 <startling> jle`, (<*>) for parser-combinators does nothing (>>=) can't do.
23:58:22 <startling> that's sort of the point.
23:58:37 <Twey> s/for parser-combinators //
23:58:54 <Twey> If your Applicative instance does more than your Monad instance, something's horribly wrong in your API :þ
23:59:20 <Twey> jle`: ZipLists are cool, too
23:59:21 <jle`> yes (>>=) is more powerful than (<*>), and can do everything the latter can, but I just want to have a list showcasing how cool applicativeness is
23:59:28 <jle`> applicativeness in its own right
23:59:44 <jle`> maybe to kind of give them their chance to shine
23:59:49 <jle`> when monads get all the attention
