00:04:37 <mikeplus32> there's no way to 'see' the 'result' type of an expression, is there? as in, (fooThing (foo :: n {- determined by the outer 'n' -})) :: n
00:05:27 <jle`> holes
00:06:46 <ion> mikeplus32: 7.8 will have real holes (fooThing _ :: n), but you can abuse ImplicitParams for that for now: {-# LANGUAGE ImplicitParams #-}, fooThing ?foo :: n
00:09:11 <adnap> Is there a way to pattern match on the end of a string (list)?
00:09:34 <ion> You’re using the wrong data structure. See for example Data.Sequence.viewR
00:09:41 <adnap> ion: Me?
00:10:16 <ion> Or Data.Text.stripSuffix
00:10:19 <ion> adnap: yeah
00:10:26 <mikeplus32> ion: maybe i've phrased myself badly, how would that look if i have foo :: Proxy n -> Int -> n, but want to make foo :: Int -> n?
00:10:38 <mikeplus32> or is that impossible?
00:11:30 <ion> mikeplus32: Sorry, i still didn’t get what you mean.
00:11:53 <ion> adnap: The Data.Text.stripSuffix documentation has a nice example.
00:11:56 <adnap> ion: Is the answer to my question "no"?
00:13:17 <ion> adnap: You can use view patterns and a helper function, but it will be an O(stringlength) search with [] instead of O(suffixlength) for Data.Text.
00:15:01 <adnap> ion: Like... helper :: Int -> (String -> String) -> String?
00:15:20 <mikeplus32> ion: nevermind, i solved it, what i had was fromIndex :: Dim n => Proxy n -> Int -> n, and wanted to make toEnum, but that's only :: Int -> n, but it looks like "toEnum = fromIndex Proxy" works fine
00:15:29 <adnap> (where Int specifies how many last characters to get)
00:16:14 <ion> adnap: It will be exactly like Data.Text.stripSuffix (except not efficient).
00:18:02 <adnap> ion: stripSuffix :: Text -> Text -> Maybe Text has a Maybe result. That's annoying and not like what I was thinking
00:18:22 <ion> adnap: See the documentation, particularly the part about ViewPatterns.
00:18:46 * hackagebot tempodb 0.2.0.0 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.0.0 (ParnellSpringmeyer)
00:18:46 * hackagebot tempodb 0.2.0.1 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.0.1 (ParnellSpringmeyer)
00:19:05 <adnap> ion: Oh, I see
00:19:47 <ion> If you don’t care about the prefix, you can use a guard with Data.List.isSuffixOf, but again, it will be O(stringlength) because it’s the wrong data structure.
00:20:24 <adnap> ion: I'm using Elm
00:21:02 <ion> Does it have an interface to JavaScript strings? You probably should use that instead of [Char].
00:21:58 <adnap> It has toString : JSString -> String and fromString : String -> JSString
00:23:13 <adnap> I'm not sure how to manipulate JSStrings
00:24:24 <adnap> ion: I don't understand why you think I "should"
00:25:21 <augur> blegh. i feel very squeamish about writing an untyped embedded DSL :(
00:26:08 <FireFly> adnap: probably to avoid having to match the suffix in linear time
00:26:17 <ion> adnap: The JavaScript string, Data.Sequence.Seq and Data.Text.Text aren’t linked lists where you have to traverse the entire list from the beginning to look at the end (which is what you’re meaning to do).
00:26:49 <adnap> ion: I see.
00:48:43 * hackagebot type-natural 0.0.4.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.0.4.0 (HiromiIshii)
00:53:44 * hackagebot sized-vector 1.2.0.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-1.2.0.0 (HiromiIshii)
00:57:25 <Walther> Hmm. Any simple/lightweight rss parsers in Haskell / how difficult would it be to implement one?
00:58:02 <arkeet> @hackage feed
00:58:02 <lambdabot> http://hackage.haskell.org/package/feed
00:58:07 <Walther> I'm getting sick of all these rss services (feedly etc) that insist on read/unread states, I'd just like a simple chronological list of everything
00:58:18 <Walther> Oh, neat!
00:58:23 <Walther> Thanks, will look into this
01:12:08 <T_X> does anyone know an efficient way to xor two bytestreams? I've been trying this, but it's pretty slow: bxor = Data.ByteString.Lazy.zipWith (\a b -> a `Data.Bits.xor` b)
01:17:16 <mm_freak> T_X: that's because ByteString's zipWith is kinda retarded
01:17:26 <johnw> this might be crazy, you could use unsafePeekAsCStringLen to deal with it as a raw buffer, and then xor into a malloc'd block and then packCStringLen to get a ByteString back.  Then could xor as a series of Int64 values
01:18:47 <mm_freak> T_X: if johnw's solution is too unsafe for you, then an alternative is not to use ByteString here…  you can use an unboxed Vector Word8
01:19:55 <T_X> mm_freak: you mean a strict instead of a lazy one?
01:20:04 <mm_freak> also if your plaintext is actual text, this could be an advantage, because unboxed Vector Char is also possible
01:20:05 <T_X> have tried that already, too, not much gain
01:20:15 <mm_freak> T_X: yes, unboxed implies strict =)
01:20:32 <johnw> my approach would be strict too
01:21:00 <mm_freak> T_X: vectors are always size-strict…  there are no lazy vectors in the same sense there are lazy bytestrings
01:21:18 <mm_freak> for dealing with large volumes of data you should use a streaming abstraction anyway
01:21:28 <mm_freak> like pipes or conduit
01:21:59 <T_X> unfortunately the files are binary. but actually they aren't that large, a 512B keyfile and a 512KB encoded file
01:23:59 <mm_freak> T_X: well, to improve your current solution use scanl or mapAccumL instead of zipWith
01:24:19 <mm_freak> use an index into the key string as the accumulator
01:24:36 <mm_freak> oh, scanl won't work
01:24:56 <mm_freak> there is also unfoldrN
01:28:13 <T_X> mm_freak: thanks, will look at unfoldrN first
01:28:29 <T_X> johnw: and afterwards at the CString functions, thanks!
01:30:22 <mm_freak> T_X: and consider using pipes/conduit anyway
01:30:39 <mm_freak> they will improve your performance, because they can do fast constant memory stuff without using lazy strings
01:30:40 <johnw> yeah, if this is for a stream, I'd use conduit
01:30:54 <johnw> (says johnw, while writing some conduit code)
01:31:00 <mm_freak> and i'd use pipes =)
01:31:09 <mm_freak> (says mm_freak while writing some pipes code)
01:31:16 <johnw> haha
01:36:16 <augur> blegh. the more this zipper code needs to be refined, the bigger the navigation method gets. i should figure out how to genericize this
01:36:52 <augur> what are the options for more generic zipper tools? i know of the weaving-a-web approach, but is that the best approach?
01:53:01 <augur> i dont think the web approach is actually going to help me, because i only need one function -- in-order traversal, but
01:53:10 <danilo2> Hi! Could somebody tell me how can I implement zipper like data structure, but with O(1) element access? It is even possible in Haskell? I've asked a question on SO, but I'm writing here also, because I know here is a lot of people, who are native Haskell speakers :D
01:53:10 <danilo2> http://stackoverflow.com/questions/20184355/implementing-efficient-zipper-like-data-structure-in-haskell-with-o1-elements
01:53:26 <augur> hah. danilo2 :)
01:53:39 <augur> we're on related topics, it seems
01:53:52 <danilo2> hello augur! :)
01:55:40 <danilo2> augur: nice to hear that :) I was thinking about going this problem around by creating a map nodeByID :: ID -> Node and remember in AST only the id's, but 1) this is a little ugly, 2) it is nlogn
01:56:46 <augur> you're going to have trouble with building the initial table. i wonder if somehow you could write some smart constructors that automate this process a bit
01:57:34 <augur> i think any solution will have some overhead at the construction level
01:58:47 <danilo2> augur: the overhead at construction level is ok. But I would love to have linear time complexity when accessing nodes by id, not nlogn, so the map idea is not good enough :(
01:59:38 <augur> you can construct the AST and the map together
01:59:44 <augur> but making changes will be tricky
02:00:04 <augur> if all you care about is constant access, you can do it no problem. i dont know how you'd handle the mutation stuff at all
02:01:23 <danilo2> augur: Ok, so I'll explain a little
02:04:08 <danilo2> augur: Lets say we've got data structure like in my SO question. If I'll go with map, than each AST element would not consist of AST subelements (like: (A 0 (B 1) (B 2) (B 3))) but it would point to ids, like nodeByID = 0 -> (A 0 1 2 3), 1 -> (B 1), etc (sorry for the arrow notion, it is easier to see the map this way to me
02:05:05 <augur> well, you wouldnt need the internal ID's but yes. you can simulate pointers like that
02:05:33 <danilo2> augur: of course, but still this way we do not have constant access to elements
02:06:09 <augur> yes, if you use a boring old map this is true. there are more efficient structures available in haskell, tho. they typically require some fancier stuff tho.
02:06:35 <danilo2> augur: I didnt know about it, do you know any such structure>?
02:06:52 <augur> i believe there are O(1) arrays in haskell that you can use, maybe? but i dont know how their construction/scaling works
02:08:14 <danilo2> augur: hmm maybe it is a solution for this problem, but I still feel it is a little ugly and not "haskellish" :/
02:08:27 <augur> why isn't it haskellish?
02:09:16 <augur> you could also of course build your AST type to be mutable from the ground up, that would make certain things easier
02:09:26 <danilo2> augur: because I'm simulationg "pointers" with these IDs. Maybe its ok, but I feel it is not pretty
02:10:23 <augur> if you build ground-up mutable ASTs, you wouldnt even need a pointer map, but you'd have to use the points that the constructors give you, of course
02:10:52 <danilo2> augur: how can I build mutable AST? Maybe it is exactly what I'm looking for
02:11:04 <Aetherspawn> danilo2: its a bit far to scroll up to get full context
02:11:08 <augur> same way you build any mutable type!
02:11:23 <danilo2> Aetherspawn: http://stackoverflow.com/questions/20184355/implementing-efficient-zipper-like-data-structure-in-haskell-with-o1-elements
02:11:24 <Aetherspawn> but if you're modelling debrujin indices then you should look at edwardk's bound package
02:11:29 <augur> Aetherspawn: he wants mutable ASTs with constant subnode lookup via pointery things
02:11:30 <Aetherspawn> oh
02:11:52 <augur> which i think means he should use something ST-ish
02:12:00 <danilo2> augur: hmm, thats very interesting because I've never built any mutable data in Haskell
02:12:20 <augur> danilo2: well you do it all in monads that give you some access to pointers to memory
02:12:49 <Aetherspawn> sounds like a premature optimisation TBH
02:13:01 <augur> i agree
02:13:07 <Aetherspawn> the entire of GHC and DDC both use purely functional AST, and if I had to deal with transformations in IO Id just want to kill myself
02:13:12 <Aetherspawn> can you simply imagine writing passes in IO?!
02:14:16 <danilo2> Aetherspawn: you are right. This is not pure and maybe I'll stay with simple maps :: ID -> Node
02:14:37 <danilo2> augur: thank you, nice to know that. I'll have to read about it :)
02:16:05 <augur> danilo2: do you even need these lookups?
02:16:06 <danilo2> Aetherspawn: When you're talking about writing passes in IO you're not telling writing passes in "do notation" or real "IO Monad" is wrong, but it is wrong and error prone to use IO to access mutable AST? (asking just to get it right) :)
02:16:09 <augur> i mean, whats their purpose
02:16:43 <Aetherspawn> w.r.t first half: it's painful to write passes in IO
02:16:56 <Aetherspawn> pure passes are incredibly sleek and easy to understand. Once you introduce IO it looks gross
02:17:00 <danilo2> augur: I think I need it. The language has got a visual representaion (visual nodes connected by lines) - If you click such node and modify it - I want to know what is the AST subtree of it and modify it "in place"
02:17:13 <Aetherspawn> w.r.t the second half: you can do it, but you won't win any incredible performance from doing so
02:17:16 <augur> danilo2: whats what zippers are for tho
02:17:26 <Aetherspawn> the complexity of your passes (often On^2 or n^3) will far shadow the cost of purity
02:17:42 <bitemyapp> Aetherspawn: funny you mention that, the use of mutable state in the filesystem is one of the main sources of bugs, especially hard to reproduce ones, in Clojurescript's compiler
02:17:58 <bitemyapp> Aetherspawn: worse, it doesn't even *really* need to do that, it's a single pass compiler. It's an "optimization"
02:18:04 <danilo2> Aetherspawn: I'm writing passes in myc custom PassMonad m , which satisfies IOMonad m, because I want to log some actions inside
02:18:12 <bitemyapp> I've grumbled about it before, I still don't think it's a good idea.
02:18:19 <Aetherspawn> probably better off using a Writer @ danilo2
02:18:28 <Aetherspawn> in ddc we use tell to report optimisation events
02:18:32 <Aetherspawn> and then we pretty print them *after* the pass
02:18:51 * hackagebot egison-tutorial 3.0.3 - A Tutorial Program for The Programming Language Egison  http://hackage.haskell.org/package/egison-tutorial-3.0.3 (SatoshiEgi)
02:18:58 <danilo2> Aetherspawn: I'm using RWS :) But I think there is no difference between RWS and IO in this case
02:19:00 <bitemyapp> edwardk's github is the wal-mart of Haskell.
02:19:07 <Aetherspawn> ^
02:19:32 <bitemyapp> might as well check there first to make certain there isn't a nice package for your problem before going to unproductive effort.
02:19:33 <Aetherspawn> In was surprised, honestly. Some of his packages are just like "WTF, why would you  ever need that, and WHEN did he decide he had to write THAT.."
02:19:51 <bitemyapp> It's almost disappointing when I find he's written a library for something I needed. No opportunity to explore on my own :P
02:20:01 <bitemyapp> Aetherspawn: that's just blub mindset.
02:20:10 <danilo2> bitemyapp: Ok, thank you, I'll checkit it right now :)
02:20:11 <bitemyapp> Aetherspawn: Most programmers I know have the same reaction to monads, type systems, and lenses.
02:20:28 <bitemyapp> edwardk is just playing in a higher dimension than most of us are, for now.
02:20:34 <Aetherspawn> well, yes, and then one day you're like "oh, I need that"
02:20:43 * bitemyapp nods slowly
02:20:44 <Aetherspawn> "didn't edwardk make one of those ... yes.. oh my..."
02:26:28 <alexander__b> does anyone have a link for The Kleisli Approach to Data Transformation and Integration (2001)?
02:28:28 <bitemyapp> alexander__b: I successfully googled for the PDF, it was on the first page.
02:28:56 <alexander__b> bitemyapp: I don't use Google, but was the result on a page that actually lets you download it gratis?
02:29:17 <bitemyapp> alexander__b: yes, but why don't you google it yourself?
02:29:25 <bitemyapp> I downloaded it gratis, like you said.
02:30:07 <alexander__b> I do not use Google. however, if it is actually easy to find then I imagine I can find it using another search engine as well if I look a bit more closely.
02:30:34 <bitemyapp> alexander__b: you do use Google, you just have a higher cost/benefit threshold than people that don't have weird pretensions with regards to their search engine use.
02:30:54 <bitemyapp> alexander__b: I'm certainly not going to let your perverse moralism *outsource* the use of Google and the utility derived through the use of secondaries such as myself.
02:31:18 <bitemyapp> alexander__b: so you'd better re-evaluate your economic relationship or find a better alternative search engine. What are you using for search right now?
02:32:00 <alexander__b> bitemyapp: this got off-topic quickly, and you are obviously in an attacking stance. I have no desire nor time to justify my computing to people in a chat room.
02:32:25 <Aetherspawn> I find that a really interesting stand
02:32:26 <bitemyapp> I don't mind people that don't use Google, I mind hypocritical outsourcing :)
02:32:48 <Aetherspawn> I reason that I've probably only got 50-60 years left and no huge corporation can ruin my life enough for me to regret it in that time.
02:32:51 <bitemyapp> I'd be happy to assist you by a means such as exploring alternative search engines and comparing results.
02:33:02 <bitemyapp> I'm not going to enable hypocrisy though.
02:33:04 <Aetherspawn> \o/ but y'know, I'm a shameless gmail/facebook/G+ user
02:33:23 <bitemyapp> Aetherspawn: I limit my involvement in things like Facebook, but I use Twitter and Gmail happily.
02:33:35 <bitemyapp> the utility I derive from the services is greater than any risk/threat they could offer me.
02:38:52 * hackagebot Spock 0.1.1.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.1.1.0 (AlexanderThiemann)
02:54:34 <zol> I am looking for function that allows me to map a list over a list of tuples: [b] -> [(a,a,a)] -> [((b,a),(b,a),(b,a))], or a tuple over a list of tuples: (b) -> [(a,a,a)] -> [((b,a),(b,a),(b,a))]
03:04:03 <FireFly> What do you want this for?
03:04:44 <FireFly> (b) isn't a tuple btw, there is no 1-tuple. and tuples all have fixed size, so you'd need one function for "map over 3-tuples", one for "map over 4-tuples" etc, if you wanted taht
03:04:58 <FireFly> that*
03:05:21 <Blkt> sounds like zip
03:05:25 <Blkt> zip + map
03:05:36 <ion> @type zipWith (\a (b,c,d) -> ((a,b),(a,c),(a,d)))
03:05:37 <lambdabot> [t2] -> [(t, t1, t3)] -> [((t2, t), (t2, t1), (t2, t3))]
03:05:39 <ion> @type liftA2 (\a (b,c,d) -> ((a,b),(a,c),(a,d)))
03:05:40 <lambdabot> Applicative f => f t2 -> f (t, t1, t3) -> f ((t2, t), (t2, t1), (t2, t3))
03:24:02 <Aetherspawn> What could "Could not deduce (NFData n) arising from a use" possibly mean
03:27:21 <bitemyapp> Aetherspawn: post more code
03:27:59 <Aetherspawn> hmm, that's not going to work. It's large compiler code
03:28:03 <Aetherspawn> I'll just figure it out myself.
03:31:50 <donri> Aetherspawn: it means you have an "n" that needs to be an NFData but is missing this constraint
03:32:48 <donri> maybe you're trying to deepseq a polymorphic structure
03:33:00 <Aetherspawn> now I feel really stupid
03:33:07 <Aetherspawn> I had a function with those constraints I was calling
03:33:27 <Aetherspawn> and I was getting all tied up looking for an rnf or a deepseq, but they didn't actually need to be there for me to get the error
03:33:33 <Aetherspawn> im a nub ;_;
03:33:59 <donri> ah, heh
03:35:15 <donri> i wonder if a warning for "unused constraint" could be added to ghc, and how many false-positives it would give
03:36:07 <Aetherspawn> donri: would love a warning like that!
03:36:13 <Aetherspawn> I had a dangling restraint I didn't see
03:38:52 <Rc43> Is this good benchmark? http://mirror.seize.it/report.html There are only errors for JHC/UHC/LHC.
03:50:10 <donri> and rather old ghc
03:58:59 * hackagebot bert 1.2.1.2 - BERT implementation  http://hackage.haskell.org/package/bert-1.2.1.2 (RomanCheplyaka)
04:01:23 <lpaste> isomorphic pasted “List monad, sequence” at http://lpaste.net/9048726511841968128
04:02:23 <isomorphic> ^-- the code above is an attempt at making a version of sequence that excludes certain values as it creates a list
04:03:22 <isomorphic> can anybody suggest from the snippet I've posted what's wrong with my approach?
04:03:52 <isomorphic> I gather that vs is not - from a type point of view- the kind of thing that I can have in the monad.  But that leaves me at a bit of a loss to filter it
04:05:24 <donri> isomorphic: and x is an m Int not [Int]
04:05:47 <donri> @src sequence
04:05:47 <lambdabot> sequence []     = return []
04:05:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:05:47 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
04:06:52 <boothead> Can anyone think of a reason that cabal list --installed might not include an executable that I have installed (hsenv)? Is this by design?
04:07:04 <merijn> boothead: cabal doesn't track executables
04:07:44 <merijn> boothead: Actually, cabal doesn't track anything. Cabal just queries the libraries registered with the compiler, but since executables are not tracked by the compiler it doesn't know they exist
04:08:34 <boothead> merijn, ah... that's a shame. Any alternative command you can think of that I could run to say "have I cabal installed this?"
04:10:50 <merijn> boothead: ls on your cabal directory? :p
04:11:02 <merijn> It should have one folder per installed thing
04:11:13 <sopvop> Is there such a thing as "ordered" key->val container which can be traversed in order of insertions. like OrderedDict { keys :: HashMap k Int, vals :: IntMap Int a, next :: Int }?
04:11:48 <hpc> sopvop: [(k, v)]?
04:11:58 <sopvop> k,v are slow to query :)
04:15:07 <frx> isomorphic are you doing this? sequencePlus = liftM nub . sequence
04:15:09 <isomorphic> donri: Is there a way to type annotate x?  I tried  [Int] in the hope that might be a valid specialisation of m Int - when I tried (x::m Int), I see a message couldn't match type `m1' with `[]'
04:15:39 <merijn> sopvop: I would just keep a list together with a Map? :p
04:15:57 <merijn> sopvop: Slightly slower to remove items though (have to scan the list O(n)
04:16:15 <isomorphic> frx:  I have a really big list- so I tried using nub with sequence in the beginning, but it ended up filtering a lot of what I wanted
04:16:31 <donri> isomorphic: you'd need scoped type variables for that, but why the signature at all? shouldn't be needed?
04:16:42 <sopvop> merijn: Well, my proposed one is better then. Just throw some quickchecks on it :)
04:17:04 <isomorphic> donri:   I got an infinite type error previously, so the crazy type annotations are a way of debugging
04:17:43 <donri> isomorphic: you can also put a signature on the v at a use site
04:17:43 <merijn> isomorphic: I usually replace bits with undefined until it typechecks and then figure out why the bit I replaced had the wrong type
04:17:53 <donri> (v :: Int) : (vs :: [Int]), say
04:17:58 <isomorphic> The gist of the function I'm trying to build is that when it is given [4,5,6][4,7,8] it won't generate a list item [4,4]
04:18:21 <merijn> isomorphic: "let newExclusions =  (v::Int) : (exclusions::[Int])" <- this is wrong
04:18:27 <isomorphic> donri:  Ah, good point
04:18:32 <merijn> exclusions has type "m Int"
04:19:08 <merijn> I'm guessing the type of sequencePlus is wrong
04:19:23 <merijn> I think it should be "[m Int] -> [Int] -> m [Int]"
04:19:34 <identity> isomorphic: set difference?
04:19:48 <identity> > [4,5,6] // [4,7,8]
04:19:49 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i0 e0'
04:19:49 <lambdabot>              with actual...
04:19:53 <identity> huh
04:20:15 <identity> oh.
04:20:20 <identity> > [4,5,6] \\ [4,7,8]
04:20:22 <lambdabot>   [5,6]
04:20:30 <BoR0> @src (\\)
04:20:30 <lambdabot> (\\) = foldl (flip delete)
04:20:32 <identity> silly me
04:20:39 <isomorphic> identity:  Not quite.  So the idea is a bit like
04:20:49 <isomorphic> > sequence [[1,2,3],[4,5,6]]
04:20:51 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
04:21:04 <isomorphic> 	 > sequence [[1,2,4],[4,5,6]]
04:21:15 <isomorphic> > sequence [[1,2,4],[4,5,6]]
04:21:16 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[4,4],[4,5],[4,6]]
04:21:35 <isomorphic> identity:  So the output would look like that last line, but without the element 4,4
04:22:00 <identity> for an arbitrary number of lists, or just the cartesian product of two lists without [a, a]?
04:22:02 <isomorphic> … but rather than build and filter, I want to filter prior to building
04:22:14 <isomorphic> identity: arbitrary number of lists
04:22:17 <identity> hmm.
04:23:18 <isomorphic> I actually have, in this case, 15 lists I'll pass in.   Some of them are about 7 elements long, some only a few elements, but there are only 15 unique elements.  So, repeated result terms start to dominate the size of the result
04:24:01 * hackagebot cabal-install-bundle 0.16.0.2 - The (bundled) command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-bundle-0.16.0.2 (BartoszCwiklowski)
04:24:08 <isomorphic> merijn :    Okay, that makes sense.
04:28:35 <isomorphic> Should  vs <- xs be able to follow v <- x in the do block?   I see an error on the line with vs where Expected type: m (m Int) , but  Actual type: [m Int]  - they sort of seem equivalent since the monad here is the list monad
04:32:18 <Eduard_Munteanu> isomorphic: what are the types of 'x' and 'xs'? If 'x :: m Int' and 'xs :: [m Int]', that won't work.
04:32:50 <Eduard_Munteanu> (you can't combine different monads like that)
04:33:02 <merijn> Actually, maybe sequencePlus is typed entirely wrong
04:33:34 <merijn> I'm guessing what you want is list specific, so you can't really have the type "[m Int] -> [Int] -> m [Int]" either
04:33:37 <Eduard_Munteanu> Is there any special support for interfacing with Vala code?
04:33:48 <merijn> I think you just want "[[Int]] -> [Int] -> [[Int]]"?
04:34:04 <Eduard_Munteanu> Or should I FFI with the resulting C code?
04:35:08 <isomorphic> merijn:   That last thought is the way in which those [[Int]] types wound their way into the code ;)
04:35:23 <isomorphic> But I'm still quite new to writing this type of code
04:35:42 <isomorphic> … so I thought it best to check with #haskell ;)
04:36:10 <Eduard_Munteanu> @hoogle sequencePlus
04:36:10 <lambdabot> No results found
04:36:30 <isomorphic> Eduard_Munteanu:  I made the name up ;)
04:37:01 <Eduard_Munteanu> sequencePlus :: (Traversable t, MonadPlus m) => t (m a) -> m a  ?
04:37:56 <isomorphic> Eduard_Munteanu:  Oh, apologies if I've caused a name collection - code referred to is http://lpaste.net/9048726511841968128
04:38:05 <isomorphic> s/collection/collision
04:39:48 <Eduard_Munteanu> isomorphic: your 'x' is an 'm Int', not a [Int].
04:40:12 <Eduard_Munteanu> isomorphic: also that type is way too polymorphic, 'm' is not even a Monad.
04:40:43 <isomorphic> Eduard_Munteanu:  merijn suggests above that a more likely type for is "[[Int]] -> [Int] -> [[Int]]"
04:41:34 <Eduard_Munteanu> Possibly, it seems you assume a few things about 'm'.
04:42:17 <isomorphic> Eduard_Munteanu:  I was looking earlier for a type constraint that it was a list…
04:42:59 <Eduard_Munteanu> isomorphic: why not *make* it a list? Or do you mean just list-like?
04:43:28 <isomorphic> Eduard_Munteanu:  List-like.  I started with the source for sequence, and was trying to preserve its polymorphic-ness.
04:43:48 <isomorphic> I have another implemented of the same, using nub, which adds an Eq constraint only
04:44:00 <Eduard_Munteanu> isomorphic: you probably want Foldable or even Traversable.
04:44:17 <isomorphic> I thought it might be possible to do the same in monadic code without adding too much extra
04:44:48 <lpaste> isomorphic annotated “List monad, sequence” with “List monad, sequence (annotation)” at http://lpaste.net/9048726511841968128#a7876418598602801152
04:45:19 <isomorphic> ^-  that's the version specialised to just work with a list - which is my instant problem
04:46:45 <BoR0> can I do in haskell like I can do in C: #define test (repeat); test 5
04:47:24 <frx> test = repeat
04:47:43 <Eduard_Munteanu> isomorphic: (x:xs) :: [m Int] implies x :: m Int so those '<-' bindings can't really work with that type.
04:47:57 <BoR0> I gave an example, what I really need is something like: #define CHECK(X) if (x > 9 || x < 0) then error (show x ++ " is not a valid digit") else X
04:48:48 <frx> check x = if (x > 9 || x < 0) then error (show x ++ " is not a valid digit") else x
04:49:01 <Eduard_Munteanu> isomorphic: unless you do something like   v <- toList x    vs <- xs
04:49:11 <Eduard_Munteanu> Assuming (Foldable m).
04:49:37 <BoR0> note that x is different from X. namely in the preprocessor macro x is not defined, but X is
04:49:49 <isomorphic> Eduard_Munteanu:  That might be the answer.  I've specialised it to just a list of lists in the annotation below the code you're referring to
04:50:14 <Eduard_Munteanu> isomorphic: yeah, I think you want Foldable
04:50:41 <augur> BoR0: you want to capture x?
04:50:42 <frx> BoR0 what is x?  something (hopefully) defined in the scope?
04:50:46 <augur> thats horrible. dont do that ever.
04:50:48 <BoR0> frx, yes
04:50:54 <BoR0> augur, I am just experimenting
04:51:03 <augur> BoR0: with fire
04:51:09 <BoR0> I noticed that haskell has #ifdef but not #define
04:51:22 <augur> because macros are a pain in the ass
04:51:41 <BoR0> ok, so basically haskell has no support for C-style's #define?
04:51:44 <Eduard_Munteanu> BoR0: it's not Haskell, it's just ghc + -XCPP
04:52:00 <Eduard_Munteanu> BoR0: it should work if you enable that extension
04:52:04 <isomorphic> Eduard_Munteanu:  Cool, i'll experiment with that for a bit. Thanks!
04:52:06 <BoR0> I see
05:00:51 <isomorphic> Eduard_Munteanu:  Foldable doesn't seem to quite do it.  I see  Could not deduce (m ~ [])  from the context (Foldable m) … :/
05:01:01 <isomorphic> I'm guessing it must be specialised to lists…
05:02:01 <Eduard_Munteanu> isomorphic: sure, you can't pretend you have a list, use functions from Data.Foldable.
05:02:35 <Eduard_Munteanu> isomorphic: http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/Data-Foldable.html#g:6
05:02:51 <Eduard_Munteanu> isomorphic: e.g. elem
05:02:56 <Eduard_Munteanu> :t Data.Foldable.elem
05:02:57 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
05:05:23 <Eduard_Munteanu> isomorphic: btw, are you trying to implement a more efficient nub?
05:06:20 <Eduard_Munteanu> :t S.toList . S.fromList
05:06:21 <lambdabot> Ord a => [a] -> [a]
05:07:07 <donri> that's not order-preserving
05:07:20 <Eduard_Munteanu> Hm, yeah.
05:07:55 <quchen> Just take the 'nub' source and replace the memory list with a Set
05:08:09 <quchen> nub has this accumulator it puts things it already encountered in
05:08:09 <isomorphic> Eduard_Munteanu:  It's not far off.  I'm working on a combinatoric problem to practice my haskell.  I have a list of lists, say for example the list [[1,2,3],[1,4,5],[6,7,8]], and I want to generate all combinations - but with a small difference to sequence.  It turns out that I should not check combinations where a list element is repeated in a sublist - so, in the output of sequence, [1,1,6] would be invalid since 1 is repeated
05:08:10 <Eduard_Munteanu> :t map head . group . sort
05:08:11 <lambdabot> Ord b => [b] -> [b]
05:08:20 <Eduard_Munteanu> Er, that isn't either.
05:08:22 <donri> https://github.com/nh2/haskell-ordnub hmm
05:08:41 <isomorphic> but I never want to generate the whole list, since there are a lot of repeated elements
05:09:09 <isomorphic> eg, I get mostly entries like [1,1,6] if I use sequence, so i don't want to filter with nub afterward, but rather filter while generating
05:09:49 <Eduard_Munteanu> :t map snd . sortBy (comparing fst) . map head . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [1..]
05:09:50 <lambdabot> Ord a => [a] -> [a]
05:10:04 <donri> well there's fusion so it might compile down to one traversal
05:10:17 <donri> Data.List.nub is quadratic though
05:10:38 <marx2> I expected getLine to be called after threadDelay due to laziness, but it is called before. how come?  http://lpaste.net/96190
05:10:45 <BoR0> @src nub
05:10:45 <lambdabot> nub = nubBy (==)
05:11:42 <BoR0> @src groupBy
05:11:42 <lambdabot> groupBy _  []       =  []
05:11:42 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:11:42 <lambdabot>     where (ys,zs) = span (eq x) xs
05:11:43 <Eduard_Munteanu> marx2: getLine is strict
05:12:22 <donri> IO is strict in bind, getLine is strict in the value
05:12:51 <Eduard_Munteanu> I mean strict as opposed to lazy IO.
05:14:13 <donri> yep. lazy IO is the exception, though :)
05:14:35 <donri> but i wasn't addressing you :)
05:14:42 <Eduard_Munteanu> :P
05:16:10 <isomorphic> Eduard_Munteanu:  What is that long function you've defined above?
05:16:39 <isomorphic> it acts like nub
05:16:43 <Eduard_Munteanu> isomorphic: an order-preserving nub that is O(n log n)
05:17:06 <isomorphic> that's cool
05:18:40 <marx2> how am I suppose to tell if a function is strict or lazy? documentation says nothing about it. http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:getLine
05:18:54 <marx2> neither does documentation for hGetLine
05:19:20 <Eduard_Munteanu> marx2: IO actions are strict unless specified otherwise, e.g. look at hGetContents
05:21:21 <donri> Eduard_Munteanu: hm that's interesting, there was a cafe thread about adding ordNub that seems to be blocked by the need for Set to implement it. is your version comparable to one using Set.member?
05:22:15 <Eduard_Munteanu> donri: I suspect the constant factors are worse since I'm sorting twice. Might also fuse less nicely.
05:23:08 <marx2> Eduard non-IO things are lazy unless specified otherwise?
05:23:10 <Eduard_Munteanu> Hm, we could do something else...
05:24:23 <alpounet> marx2: i recommend reading http://alpmestan.com/2013/10/02/oh-my-laziness/ or any other article about lazy & strict evaluation
05:25:05 <Eduard_Munteanu> marx2: there are two notions of lazy here... Haskell has lazy values as in "it only computes things on demand". For IO, we say an IO function is lazy if the *action* is also executed on demand, when the result is evaluated.
05:26:15 <Eduard_Munteanu> Well, more commonly we talk about lazy String or lazy Bytestrings to refer to such entities that aren't read all at once in memory when opening a file, for example.
05:27:43 <isomorphic> Eduard_Munteanu:  Should I be looking to somehow use filterM in the example I gave previously?
05:27:46 <mornfall> Right, and lazy IO is evil!
05:28:11 <mornfall> (Because it produces values with side effects that pretend to be pure.)
05:28:31 <quchen> No, that's not lazy IO.
05:28:41 <quchen> If that was bad IO would in general be bad.
05:29:07 * hackagebot Spock 0.1.2.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.1.2.0 (AlexanderThiemann)
05:29:36 <quchen> Lazy IO means that that IO actions can happen at a later point in time, after the IO action has been executed.
05:29:39 <Eduard_Munteanu> :t map (flip (!!) . fst . head) . groupBy ((==) `on` fst) . sortBy (comparing snd) . zip [0..]
05:29:40 <lambdabot> Ord a => [a] -> [[c] -> c]
05:29:59 <quchen> It's basically a thunk that can do IO, and due to unspecified evaluation order that can bite you.
05:30:29 <donri> quchen: i think mornfall's point is that the value is a thunk that carries the side effects
05:30:45 <quchen> In that case "yes and ignore everything I said".
05:30:52 <donri> :)
05:31:00 <donri> ie. you mean the same thing
05:31:07 <Eduard_Munteanu> :t map (xs !!) (ix xs) where ix = map (fst . head) . groupBy ((==) `on` fst) . sortBy (comparing snd) . zip [0..]
05:31:08 <Fuuzetsu> @package fgl
05:31:08 <lambdabot> http://hackage.haskell.org/package/fgl
05:31:08 <lambdabot> parse error on input `where'
05:31:11 <Eduard_Munteanu> Gr.
05:32:05 <Eduard_Munteanu> > let nubOrd = map (xs !!) (ix xs); ix = map (fst . head) . groupBy ((==) `on` fst) . sortBy (comparing snd) . zip [0..] in nubOrd [3, 5, 6, 3, 2, 3]
05:32:06 <lambdabot>   Not in scope: `xs'
05:32:06 <lambdabot>  Perhaps you meant one of these:
05:32:06 <lambdabot>    `x' (imported from D...
05:32:15 <Eduard_Munteanu> > let nubOrd xs = map (xs !!) (ix xs); ix = map (fst . head) . groupBy ((==) `on` fst) . sortBy (comparing snd) . zip [0..] in nubOrd [3, 5, 6, 3, 2, 3]
05:32:16 <lambdabot>   [2,3,3,3,5,6]
05:32:21 <brill> Anyone knows how to do a split with regular expressions while keeping the delimiter?
05:32:34 <Eduard_Munteanu> Er.
05:33:06 <Fuuzetsu> @package scenegraph
05:33:06 <lambdabot> http://hackage.haskell.org/package/scenegraph
05:33:47 <Eduard_Munteanu> > let nubOrd xs = map (xs !!) (ix xs); ix = map (fst . head) . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] in nubOrd [3, 5, 6, 3, 2, 3]
05:33:48 <lambdabot>   [2,3,5,6]
05:33:53 <Fuuzetsu> I don't understand why a lot of libraries you need to render an image in OpenGL don't even compile with 7.6.3. I wouldn't have thought I'm the only person in the last 3 years trying to render an image using Haskell…
05:34:06 <Eduard_Munteanu> Now, if only (!!) was efficient.
05:34:51 <Eduard_Munteanu> It's not order-preserving though.
05:34:59 <jmcarthur_mobile> Fuuzetsu: what libraries?
05:35:28 <Fuuzetsu> fgl (had to add explicit -XBangPatterns), scenegraph (doesn't compile at all, modules missing)
05:35:44 <Fuuzetsu> is there a better way to load a TextureObject in? Couldn't find anything
05:40:22 <benzrf> hi, im trying to write a library for doing simple analytic geometry
05:40:59 <benzrf> i intend to write a series of predicates for determining whether, for example, a quad is a trapezoid, or a rectangle, or a square
05:41:28 <benzrf> once I have all of them, how can I sequentially check subsets of each shape to find the most specific type of shape for each?
05:41:30 <Fuuzetsu> Nope, this is just not going to work. I don't know how to load an image into TextureObject for use with OpenGL and only references on the net are to libraries from ~4 years ago which couldn't have possibly ever compiled
05:41:38 <benzrf> oh hi Fuuzetsu
05:41:45 <benzrf> i think i argued with you on /g/ once
05:41:57 <Hodapp> ROUND 2
05:41:57 <Fuuzetsu> Hello benzrf, do I know you?
05:41:59 <Hodapp> FIGHT
05:42:15 <donri> what is /g/
05:42:16 <ciaranm> they both have a z in their nicks
05:42:23 <benzrf> donri: a terrible place
05:42:24 <ciaranm> this should be awesome
05:42:24 <benzrf> don't go there
05:42:38 <Hodapp> *ahem* round 2? fight?
05:42:41 <benzrf> nah
05:42:47 <benzrf> i have better things to do with my time
05:42:53 <tavarish> donri, you don't want to know
05:42:58 <Hodapp> ohhhh that sounds like some shit-talking right there
05:43:10 <Fuuzetsu> benzrf: Ah, alright. Hello.
05:43:13 <benzrf> anyway, types of shapes form a hierarchy obv. i.e. quad -> trapezoid -> rect -> sq
05:43:15 <Hodapp> "you're not even worth the scrapes on my knuckles."
05:43:23 <benzrf> i want to find the most specific type of a given shape
05:43:28 <benzrf> would I use some kind of search tree?
05:44:08 <jmcarthur_mobile> Fuuzetsu: you can use any image loading library you want. It doesn't have to be specific to OpenGL
05:44:10 <Hodapp> that's one way
05:44:15 <identity> benzrf: I don't really know analytical geometyr, but it would seem to me that you should be able to use the fact that there is a hierarchy
05:44:18 <benzrf> Hodapp: what else do you recommend?
05:44:26 <benzrf> identity: this isn't an analytic geometry problem really
05:44:29 <Hodapp> benzrf: offhand, I'd just say start with a search tree
05:44:30 <benzrf> it's just what I just said
05:44:33 <benzrf> Hodapp: ok
05:44:44 <Eduard_Munteanu> benzrf: how do you construct shapes?
05:44:46 <Fuuzetsu> jmcarthur_mobile: You're right, it doesn't. I simply couldn't find anything that provides the right type. What's your library called?
05:44:47 <ciaranm> the trick with geometry... is to convert it to topology. and then convert that to algebra.
05:44:54 <identity> benzrf: Well, my point is that if you were to start out by determining "is it a quad?" if so, .. go deeper, and repeat
05:44:58 <benzrf> Eduard_Munteanu: i'm just writing some predicates to check each type
05:45:00 <benzrf> identity: yeah
05:45:05 <benzrf> i'm asking about the best way to structure that
05:45:05 <benzrf> :u
05:45:23 <benzrf> anyway I don't know a ton about algorithms... what should i read about? what stdlib functions do tree searches?
05:45:31 <Eduard_Munteanu> newsham: I'm asking because a rectangle can also be a square, even if defined as the former
05:45:42 <Eduard_Munteanu> Er.
05:45:44 <jmcarthur_mobile> Fuuzetsu: I don't have one of my own, but I would recommend juicypixels
05:45:44 <identity> I would probably start at the bottom.
05:45:45 <Eduard_Munteanu> benzrf: ^
05:46:15 <Hodapp> If you define it as a rectangle, I'd start from there in the tree. It may also end up being something more specific.
05:46:20 <Fuuzetsu> jmcarthur_mobile: Oops, misread that as ‘…my image library…’. I'll have a look at juicypixels, thanks.
05:46:45 <benzrf> Hodapp: i define it as any set of 4 points more or less
05:46:52 <benzrf> i expect a bit of input sanity >.>
05:47:14 <Hodapp> benzrf: I'm talking about a hypothetical shape here, in a hierarchy where you can define from any point depending on what you know.
05:47:17 <benzrf> don't worry this isn't going to be used by anybody other than me and maybe a classmate or two
05:47:18 <benzrf> ah
05:48:00 <jmcarthur_mobile> Fuuzetsu: it's native Haskell, reasonably polished, and the maintainer is very active
05:49:06 <jmcarthur_mobile> Fuuzetsu: I think there might even be a separate package for using juicy pixels to load images into OpenGL for you
05:50:26 <Fuuzetsu> jmcarthur_mobile: I'm frantically looking for such thing, if you could remember the name that'd be great.
05:50:52 <jmcarthur_mobile> Just search in page on Hackage listing for juicy pixels
05:50:56 <mirpa> Does it make sense to have something like f :: FilePath -> IO (Either String a) or should I rather strip Either and use IO's fail?
05:51:00 <jmcarthur_mobile> Should be in the name
05:51:11 <Fuuzetsu> alright
05:51:29 <benzrf> hmm
05:51:39 <Eduard_Munteanu> mirpa: the former is alright, especially since you can wrap it in EitherT / ErrorT.
05:51:40 <benzrf> what's the best way to represent a small tree? just a list of lists?
05:51:48 <Eduard_Munteanu> mirpa: you could use Maybe just as well though
05:51:55 <donri> mirpa: it sort of depends on how exceptional the Left case is
05:52:02 <jmcarthur_mobile> benzrf: define "small tree"
05:52:10 <benzrf> jmcarthur_mobile: like 12 total elements
05:52:20 <tavarish> benzrf, type Tree a = (a, [Tree a])
05:52:25 <benzrf> ok
05:52:27 <jmcarthur_mobile> What shape should it have?
05:52:44 <donri> mirpa: do you except to want to deal with it at each call site every time?
05:52:46 <mirpa> donri: Left is used for error of parsing binary file by Cereal
05:52:51 <benzrf> it's ok, ill just use tavarish's type
05:52:54 <jmcarthur_mobile> Elements in nodes? Leaves? Something else?
05:53:15 <tavarish> benzrf, I don't even know if it will compile
05:53:45 <jmcarthur_mobile> It won't
05:53:57 <mirpa> so question is if can recover from that...
05:54:03 <mirpa> i will think
05:54:04 <alpounet> Fuuzetsu: I have a library for displaying juicypixels images in gloss, and I know there's a juicypixels-repa library, but I'm not sure there is one for loading JP images for OpenGL display
05:54:20 <donri> mirpa: either version can easily be converted to the other at the call site, so it's merely an api design question
05:54:58 <Fuuzetsu> alpounet: I found this http://stackoverflow.com/questions/10468845/juicypixels-texture-loading-in-haskell-opengl which seems to imply that one has to do the conversion by hand
05:55:22 <donri> mirpa: exceptions are meant to allow for recovery, they're not supposed to be fatal
05:56:22 <alpounet> Fuuzetsu: fortunately it's a write once thing. It could reasonably be a small "add-on" packge to JP, and apparently juicypixels-repa kind of supports that, according to Thomas' comment
05:56:22 <mirpa> donri: ok, thanks
05:56:55 <tavarish> jmcarthur_mobile, indeed it doesn't compile. Is there a way to enable recursive types?
05:57:07 <donri> mirpa: you can use "try" to convert an exceptional IO action to an Either; you can use "either fail return" to do the inverse
05:57:19 <jmcarthur_mobile> tavarish: just use newtype or data
05:58:02 <mirpa> donri: aha, thats interesting
05:58:10 <tavarish> jmcarthur_mobile, that's new type that remove the constructor when compiled ?
06:00:01 <maikklein> is there an easy way to inspect the source code of a function?
06:00:14 <donri> maikklein: find the haddocks, click [Source] on the right
06:01:08 <maikklein> donri, is there a terminal version of this? maybe something in ghci or hoogle?
06:01:18 <benzrf> @src uncurry
06:01:18 <lambdabot> uncurry f p = f (fst p) (snd p)
06:01:32 <maikklein> @src break
06:01:32 <lambdabot> break p =  span (not . p)
06:01:36 <donri> maikklein: not to my knowledge. hoogle can give you a link to the online haddocks though
06:02:15 <benzrf> naming conventions lol
06:02:27 <maikklein> @src span
06:02:28 <lambdabot> span _ xs@[]                     =  (xs, xs)
06:02:28 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
06:02:28 <lambdabot>                   | otherwise    =  ([],xs)
06:02:30 <benzrf> is there any language that doesnt have a ridiculously consistent naming convention for libs
06:03:20 <donri> i have yet to find any language that does have any sort of consistency in libraries
06:03:35 <benzrf> python: using 'py' in it, usually at the beginning
06:03:38 <benzrf> ruby, r, haskell,h
06:03:43 <bartavelle> or hs
06:03:50 <benzrf> yeah
06:03:51 <benzrf> java has j
06:04:00 <benzrf> javascript has .js
06:04:01 <donri> C has "lib" ;)
06:04:16 <quicksilver> libiberty
06:04:23 <quchen> PHP has lol
06:04:29 <benzrf> kekimmo:
06:04:30 <benzrf> *kek
06:05:47 <benzrf> http://benzrf.com/misc/fp.pdf
06:05:56 <benzrf> via land of lispy
06:05:58 <benzrf> *lisp
06:13:05 <iron_houzi> I'm just starting out with Real World Haskell, beginning of chapter two. I've also looked at the 99 questions, so I had Q1 at the back of my mind while reading. I came up with: myLast xs = drop ((length xs)-1) xs  This seemed to do the trick, but the solution to Q1 was much more elaborate. What's wrong with my solution compared to the actual solution?
06:13:51 <benzrf> it might be an efficiency thing
06:14:03 <benzrf> iron_houzi: btw, you can write that in point-free form
06:14:17 <quchen> Nah, that would be bad in this case. xs appears twice.
06:14:27 <benzrf> oh derp
06:14:45 <quchen> iron_houzi: Your solution is correct, but there may be more efficient ones.
06:14:59 <brill> :quit
06:15:09 <quchen> iron_houzi: Are you familiar with pattern matching? Try using that to implement myLast.
06:15:45 <quchen> It basically boils down to three cases: What's the last element of the empty list, a list of one element, a list of many elements?
06:16:02 <ziman> also, your myLast returs a list; did the original assignment require a list or the last element itself?
06:16:18 <quchen> ziman: Woops, right, when I called the solution correct I was wrong.
06:18:03 <iron_houzi> Ahh. OK. Thanks for clearing up my confusion and understanding why my solution is incorrect. I'll read on and learn more.
06:19:20 * hackagebot HMap 0.901 - Fast heterogeneous maps.  http://hackage.haskell.org/package/HMap-0.901 (AtzeVanDerPloeg)
06:19:50 <merijn> iron_houzi: Also, have you taken a look at Learn You a Haskell, I tend to think it's better than RWH for total newcomers
06:20:06 <johnw> merijn++
06:20:34 <quchen> Oh look, it's John W. Nice interview :-)
06:20:59 <johnw> thanks, quchen!
06:21:41 <iron_houzi> merijn: Newcomers to the language or programming in general?
06:22:11 <haasn> I think drop ((length xs-1) xs -- will have horrible runtime when compiled with GHC
06:22:20 <haasn> s/((/(/
06:22:59 <sopvop> head . reverse ?
06:23:19 <iron_houzi> haasn: Are nested parenthesis a bad code smell when using Haskell?
06:23:25 <silver> last or something
06:23:26 <merijn> iron_houzi: Both!
06:23:27 <silver> @hoogle last
06:23:28 <lambdabot> Prelude last :: [a] -> a
06:23:28 <lambdabot> Data.List last :: [a] -> a
06:23:28 <lambdabot> Data.ByteString.Char8 last :: ByteString -> Char
06:23:37 <Eduard_Munteanu> iron_houzi: not really
06:23:38 <haasn> drop is strict in its first argument, so ‘length xs - 1’ will be computed first; which forces all of xs's spine into memory - it won't get garbage collected because ‘drop’ is still (potentially) strict in its spine. Or something along those lines, at any rate
06:23:38 <iron_houzi> merijn: OK. Thank you
06:23:45 <Eduard_Munteanu> iron_houzi: it just wasn't necessary there
06:23:46 <merijn> iron_houzi: Not necessarily that bad, although some haskellers are allergic to parenthesis :)
06:23:55 <iron_houzi> OK
06:24:12 <haasn> :t drop <*> subtract 1 . length -- no parens
06:24:12 <lambdabot>     Couldn't match type `[a0]' with `Int'
06:24:13 <lambdabot>     Expected type: Int -> [a0]
06:24:13 <lambdabot>       Actual type: [a1] -> Int
06:24:15 <haasn> Oh no :(
06:24:24 <BoR0> how would one convert this into a one-liner? last' [x] = x ; last' (x:xs) = last' xs (semicolon doesn't seem to do the trick)
06:24:26 <haasn> :t flip drop <*> subtract 1 . length
06:24:27 <lambdabot> [a] -> [a]
06:24:29 <haasn> Yay!
06:24:48 <merijn> iron_houzi: In case of function application they're usually avoided, since the simple rule is "function application always binds tighter than infix operators"
06:25:12 <haasn> > let last' [x] = x; last' (x:xs) = last' xs in last' [1..10] -- semicolon is correct, BoR0
06:25:14 <lambdabot>   10
06:25:32 <BoR0> oh, okay, my bad. thanks
06:26:15 <iron_houzi> Is there a holy list of Haskell operator precedence like there is in K&R ANSI C, p.53 ?
06:26:44 <Eduard_Munteanu> @where report
06:26:44 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
06:26:49 <merijn> iron_houzi: No, but you can query ghci
06:26:56 <iron_houzi> merijn: Indeed
06:26:58 <merijn> iron_houzi: ":i (*)" will print the fixity
06:27:16 <magicman> @hoogle Read a => Text -> a
06:27:17 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:27:17 <lambdabot> Prelude id :: a -> a
06:27:17 <lambdabot> Data.Function id :: a -> a
06:27:20 <merijn> iron_houzi: which is infixl <number> or infixr <number>
06:27:39 <merijn> iron_houzi: The default (which results in not printing a fixity with :i, it's a bit annoying) is infixl 9
06:28:17 <iron_houzi> That's good to know. Thanks
06:28:19 <merijn> iron_houzi: Function application has infixl 10 (which you can specify for operators), infixl obviously means left associative, infixr right associative and higher numbers bind tighter
06:28:24 <merijn> eh
06:28:31 <merijn> *can't* specify for operators
06:29:03 <merijn> ($) for example is "infixr 0", i.e. binds least tight, hence it can be used to eliminate parenthesis
06:32:22 <maikklein> does anyone know where usually the .ghci file is located?
06:32:24 <maikklein> on linux
06:32:25 <Eduard_Munteanu> dmwit_: hey... any idea if binding Vala could get us closer to gobject introspection? I'm writing a gstreamer app and most likely going through Vala now, but it seems easy to FFI to since it generates plain C functions.
06:32:48 <Eduard_Munteanu> maikklein: ~/.ghci
06:39:22 * hackagebot diagrams-core 1.0 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.0 (BrentYorgey)
06:39:24 * hackagebot diagrams-lib 1.0 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.0 (BrentYorgey)
06:39:26 * hackagebot diagrams-svg 1.0 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.0 (BrentYorgey)
06:39:28 * hackagebot diagrams-postscript 1.0 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0 (BrentYorgey)
06:39:30 * hackagebot diagrams-cairo 1.0 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.0 (BrentYorgey)
06:41:19 <maikklein> does anyone know how to fix this? lambdabot> @src break Plugin `sourcePlugin' failed with: state not initialized
06:44:32 * hackagebot diagrams-gtk 1.0 - Backend for rendering diagrams directly to GTK windows  http://hackage.haskell.org/package/diagrams-gtk-1.0 (BrentYorgey)
06:44:34 * hackagebot diagrams-contrib 1.0 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.0 (BrentYorgey)
06:44:36 * hackagebot diagrams 1.0 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-1.0 (BrentYorgey)
06:45:43 <klugez> Uuh, diagrams reached 1.0. I should learn to use it.
06:46:08 <ion> Ooh. I wonder what’s new? Hackage should require a changelog.
06:46:29 <ion> http://projects.haskell.org/diagrams/ News: Diagrams 0.7 released!
06:47:03 <byorgey> whoops, forgot to upload the new website
06:47:05 <donri> @where hdiff
06:47:06 <lambdabot> http://hdiff.luite.com/
06:47:08 <byorgey> just a minute
06:48:49 <donri> hm weird, why is diagrams-core saying no changelog available when it's right there
06:49:17 <donri> should match https://github.com/haskell/hackage-server/blob/master/Distribution/Server/Packages/ChangeLog.hs#L33
06:49:26 <donri> https://hackage.haskell.org/package/diagrams-core-1.0/src/CHANGES.markdown
06:49:34 <byorgey> donri: because Hackage is only looking for certain filename patters which does not include the one diagrams-core uses.
06:49:42 <byorgey> I submitted a patch to get it to recognize more.
06:49:47 <byorgey> I think it has not been deployed yet.
06:49:59 <donri> oh i was looking at undeployed code? gotcha
06:50:09 <ion> To elaborate, a changelog entry should be a highly recommended or required in .cabal files and Hackage should display its relevant entry for each version.
06:50:46 <donri> ion: dcoutts wants to add a changelog field with a defined markup format
06:50:58 <ion> dcoutts++
06:51:00 <byorgey> ion: I agree.  In any case, all the diagrams packages do have changelogs, and you can view them on Hackage (by clicking "browse") even if Hackage does not specifically highlight them.
06:51:15 <byorgey> the short version is: this release is filled with new features and awesome sauce
06:51:29 <byorgey> I will be talking about it at the NY Haskell Users' Group tonight
06:51:44 <ion> byorgey: Ah, thanks. Has the browse thing always been there? Either it’s new in Hackage 2 or i have been blind.
06:51:53 <byorgey> ion: no, it's new in Hackage 2
06:52:02 <ion> byorgey: Will the talk be recorded?
06:52:30 <byorgey> ion: yes
06:52:33 <ion> great
06:54:38 <byorgey> hmmm, is SSH down on community.haskell.org?
06:54:38 <socket> L1 = {<M,x> | M halts on x and has an even number of states } , L2 = {<M,x> | M halts on x and has an odd number of states } ; L1 , L2 are recursively enumerable. is the union of them is in R? i think not, but my book says otherwise... any idea?
06:54:50 <byorgey> the webserver is running, but I can't ssh to it or scp anything to it
06:55:01 <byorgey> this is making it difficult to upload the new diagrams website =(
06:55:44 <byorgey> oh, there, my scp just completed... looks like it is just SUPER slow rather than completely down.
06:55:55 <byorgey> (as in, scp'ing a 1K file took several minutes)
06:56:04 <ion> Hmm. I don’t remember the last time i have used scp.
06:56:16 <ion> It has been years.
06:57:59 <pavonia> socket: What is R?
06:58:32 <socket> pavonia: all decidable languages
07:09:17 <merijn> byorgey: The machine hosting community is up
07:09:43 <merijn> byorgey: oh, it already worked, nvm :p
07:11:56 <byorgey> merijn: I know it's up.  It's just extremely slow to respond to SSH connections.
07:12:33 <byorgey> merijn: and no, that was just me scp'ing my public key that finally worked.  I have no hope of being able to rsync the entire diagrams website.
07:18:51 <merijn> byorgey: What sort of ping/pack loss are you getting? It's pretty snappy here
07:20:26 <zennist> when I do a fmap of a function to a list, does the result get calculated right away or it depends on how the resultant list is used?
07:20:52 <byorgey> merijn: ping is snappy here too.  No packet loss.
07:21:04 <byorgey> merijn: that is only one potential source of problems connecting via SSH.
07:22:05 <silver> zennist, I think the latter
07:23:56 <geekosaur> it's lazy
07:23:57 <merijn> byorgey: I meant that SSH was snappy here too (I just uploaded 2MB in less than a second), so I'm trying to think what else could be wrong (beyond network issues on your route to it)
07:24:13 <pavonia> > take 3 $ fmap succ [1,2,3,undefined]  -- zennist
07:24:15 <lambdabot>   [2,3,4]
07:24:51 <byorgey> merijn: oh, I see
07:25:39 <byorgey> when I type 'ssh byorgey@community.haskell.org' it simply hangs
07:27:14 <danilo2> Hello! Where is implemented AST in GHC? I would love to see it and see how it is implemented - GHC Lib is huge and I could not find it.
07:33:40 <zebr> hi all. is there any research or documentation available on 'multi-hole zippers'? all i can find is http://okmij.org/ftp/Haskell/Zipper2.lhs - are there any actual implementations, say?
07:37:52 <merijn> byorgey: Does your IP have a valid reverse lookup? I remember my server used to hang new SSH connection from IPs without a valid lookup until the reverse lookup timed out
07:38:06 <byorgey> merijn: I don't know, how would I check?
07:40:30 <donri> based on your irc hostname, i'd say you do have a valid revdns
07:41:24 <byorgey> OK
07:41:44 <merijn> byorgey: Can you try to login again? Wanna see what sshd complains about, if anything
07:41:56 <lilred> hey guys, is there a good subreddit for academia in math and CS?
07:42:01 <byorgey> merijn: OK, trying now
07:42:34 <byorgey> merijn: I have to leave to catch a bus to NY in one minute
07:44:16 <merijn> byorgey: Weird, you're not producing any sshd output either, the last entry I see is you connecting succesfully for like 1 second 45 minutes ago
07:44:32 <donri> lilred: hmm http://www.reddit.com/r/compscipapers http://www.reddit.com/r/compsci
07:44:59 <lilred> donri: aww hell I meant irc channels
07:45:00 <merijn> byorgey: ok, when you have time can you try connecting via a different host? It seems you're never reaching the machine by SSH
07:45:10 <merijn> lilred: #haskell and #haskell-blah :)
07:45:19 <donri> lilred: ok uhm, ##categorytheory ##math ...
07:45:34 <merijn> byorgey: Can try to debug further once you're back
07:45:44 <donri> lilred: ... ##crypto
07:46:38 <donri> lilred: #algorithms ##statistics ##logic ##cs ...
07:47:17 <lilred> Thank you so much!
07:47:32 <donri> /LIST is a useful command ;)
07:48:24 <lilred> donri: I'd forgotten about this one! It's been close to a decade since I've used IRC before this year...
07:48:46 <lilred> I'm having a sort of crisis of faith, not sure if I should go into academia, not sure who to talk to about it either
07:49:10 <ciaranm> only go into academia if someone else is paying for it
07:49:18 <lilred> my professors don't seem to be very encouraging either, apparently the job market is ridiculously crowded
07:49:31 <ciaranm> and only if you're doing what you want to do with someone who isn't going to treat you as their bitch
07:50:22 <lilred> ciaranm: I feel like every research lab has their own extremely narrow field of research, might be hard to find something that caters point-by-point to my interests, no?
07:50:56 <ciaranm> lilred: depends upon your interests
07:51:00 <lilred> ciaranm: like, we have a type theory lab here at McGill, but it mostly concentrates on dependent types while I'm more interested in linear types
07:51:16 <lilred> (for example)
07:51:34 <ciaranm> lilred: eh, that's not so much of a problem, if you can find someone interested in supervising you who isn't just looking for a source of slave labour
07:51:45 <lilred> ciaranm: okay, thanks! :)
07:52:13 <lilred> ciaranm: are there actually research groups where you're not a graduate slave?
07:52:41 <ciaranm> lilred: yes, although they're a minority
07:52:54 <lilred> ciaranm: okay thank you!
07:53:40 <lilred> ciaranm: my current research group is wide open to me, and it looks seriously high grade (POPL papers, etc) but it looks like I'll have to pay some serious dues
07:53:54 <lilred> joining next semester as an undergrad researcher
07:55:17 <ciaranm> lilred: the trick is to establish that you're capable of doing research on your own. where "on your own" doesn't mean "without other people", so but more like "without heavy supervision"
07:55:36 <lilred> okay
07:55:54 <ciaranm> also funding... always funding...
07:56:07 <ciaranm> if your funding is paying for you to be a monkey, you'd better be spending most of your time being a monkey
07:56:11 <lilred> ciaranm: what about "yak shaving" sort of work, I feel like no one wants to do it so it doesn't get done and the whole team suffers
07:56:18 <lilred> hahahaha
07:56:53 <TheBrayn> I'm trying this: http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/ (Point 3. Mirror) and I'm getting this error message for the exact same code: http://codepad.org/hHVovSZ8
07:56:58 <TheBrayn> any idea why?
07:57:06 <ciaranm> if you're off doing proper research, you're less likely to be selected when the yak's anus needs dehairing
07:57:28 * Hodapp looks at ciaranm
07:58:04 <ij> Does the ($) function actually has some code in the runtime? Or is it reduced?
07:59:10 <kartoffelbrei> ij: it'll probably get inlined
07:59:44 <lilred> ciaranm: so I take it yak shaving is not rewarded properly? because I definitely don't mind doing it, but I don't want it to slow down my progress
07:59:54 <lilred> ciaranm: or to jeopardize research opportunities
08:00:16 <quicksilver> ij: the code exists but it's not likely to be used.
08:00:33 <quicksilver> ij: GHC inlines small functions very agressively, it's a key part of how its code generator works
08:00:41 <ciaranm> lilred: depends upon your department. there are certainly some places where bad students with external funding are kept around as long term yak shavers...
08:00:56 <lingxiao> hey does anwyone know how I can install Control.Monad.Trans.Either ?
08:01:08 <lingxiao> like fill in the blank: cabal install __
08:01:10 <ciaranm> lilred: having said that, it's usually self-inflicted...
08:01:25 <ion> @hoogle Control.Monad.Trans.Either
08:01:26 <lambdabot> package EitherT
08:01:26 <lambdabot> package either
08:01:26 <lambdabot> package either-unwrap
08:01:45 <lilred> ciaranm: sounds like musical chair.
08:01:55 <ij> quicksilver, Is there something I can read about this topic?
08:03:05 <donri> lingxiao: cabal install either
08:03:11 <quicksilver> ij: hmm I'm not sure
08:03:13 <lingxiao> ion thanks
08:03:15 <lingxiao> donri thanks
08:03:33 <quicksilver> ij: there is this old paper - http://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/
08:03:43 <quicksilver> I don't think I've read it, certainly I can't remember it :)
08:04:10 <quicksilver> some stuff and some further reading at https://ghc.haskell.org/trac/ghc/wiki/Inlining
08:07:44 <ij> Thanks!
08:16:36 <lesur> Hi, I was reading realworldhaskell just now, and I came across the data type:
08:16:56 <lesur> data BookInfo = Book Int String [String]
08:16:56 <lesur>                 deriving (Show)
08:17:47 <lesur> I was wondering why might one might have "Book" in the data BookInfo. Wouldn't you normally name it: data BookInfo = BookInfo...
08:18:30 <silver> it's no the sam thing, Book is a constructor, there might be several of them
08:18:50 <ion> Or just “data Book = Book …”. They probably did that to guard against a newbie being confused about the two being in different namespaces.
08:19:04 <Sagi> can someone help me with the intuition behind Reader Maybe Foo?
08:19:46 <Sagi> I'm kind of getting use to the convenient short-circuiting of the Maybe monad, but I don't know how to reason about that behaviour when there's another monad wrapped around.
08:19:55 <lesur> Oh, so its called "book" not for any syntactical or design reasons?
08:20:46 <silver> educational reasons probably
08:21:09 <lesur> Oh, okay, thanks guys.
08:21:41 <ion> Sometimes tutorials have something like newtype State … = S { … } to make it very clear that when you see “State” it’s a type constructor and when you see “S” it’s a data constructor. That can be helpful in an early stage of learning.
08:22:06 <Sagi> oh wait, I should probably say Reader [Foo] (Maybe Bar)
08:23:29 <ion> The important thing is that the former is in the namespace of types and the latter is in the namespace of values.
08:27:05 <lilred> anyone here into Per Martin Löf type theory?
08:27:44 <lilred> I found the concept of a hierarchy of namespaces absolutely fascinating
08:28:03 <lilred> and how we can't do type inference, but we certainly can do namespace inference
08:29:53 <Hodapp> lilred: his was a constructivist type theory?
08:30:12 <lilred> Hodapp: exactly, constructive dependent type theory
08:30:35 <Hodapp> I wasn't familiar with his work showing that we couldn't do type inference, but could do namespace inference
08:30:38 <lilred> Hodapp: I'm getting acquainted with it through the first chapter of Homotopy Type Theory, which is absolutely amazing
08:31:19 <tavarish> it's just a rewriting of mathematics, but a retarded one because it copy set instead of copying cat
08:31:43 <lilred> Hodapp: I don't know if he personally proved that, but in informal proofs the indices on universes are left out for inference by the reader, which (again, informally) means that a machine could also do that
08:32:00 <lilred> s/informal proofs/informal notation
08:32:40 <lilred> tavarish: mind elaborating?
08:33:05 <lilred> tavarish: I'm a total pleb when it comes to math, so I'd be curious to hear some insights
08:33:09 <bobcrash> Parsec looks super cool so far as parsing stuff.  Just curious, is there a similar library or even related functionality to go from a data structure to that serialized output which your parser will handle?
08:33:35 <lilred> bobcrash: not that I know of, I certainly wish there was one!
08:33:59 <lilred> bobcrash: maybe using Template Haskell someone could reflect on the parsec definitions and use it to work in reverse
08:34:13 <quicksilver> that's called reversible parsing
08:34:17 <tavarish> lilred, I was trolling, forget it
08:34:25 <quicksilver> there are some reversible parser on hackage
08:34:38 <Hodapp> lilred: neat, just saw that's a freely available book!
08:34:54 <quicksilver> sorry it's called *invertible* parsing
08:35:15 <lilred> tavarish: my prof Prakash Panangaden was saying that HoTT was interesting, but "dangerous" to a math noob
08:35:17 <quicksilver> http://hackage.haskell.org/package/invertible-syntax
08:35:22 <quicksilver> http://hackage.haskell.org/package/boomerang-1.3.2
08:35:28 <quicksilver> http://www.informatik.uni-marburg.de/~rendel/unparse/
08:35:32 <quicksilver> ^^ bobcrash
08:35:35 <silver> lilred, why?
08:35:55 <quicksilver> silver: if you drop it whilst reading it it can seriously damage your toe.
08:36:11 <ion> I’m not sure my Kindle can really damage my toe.
08:36:12 <silver> :)
08:36:24 <quicksilver> ion++ # made HoTT safe
08:36:35 <quicksilver> I would have said it was inaccessible rather than dangerous
08:36:45 <quicksilver> I think most type theory is pretty inaccessible to newbie
08:36:46 <lilred> silver: I'm not completely sure, but I think it's because if you don't have a proper understanding of either intuitionistic logic or topology and read a book about combining them, you could get some very wrong conclusions out of it
08:36:53 <tavarish> lilred, you have to knoz some things about homotopy to understand it
08:37:01 <quicksilver> btu I'm sure Panangaden had a point
08:37:37 <lilred> tavarish, quicksilver: I know jack shit about either type theory or homotopy and so far, so good. Crossing my fingers
08:38:05 <lilred> it's surprisingly accessible for an advanced math book.
08:38:06 <tavarish> jack shit? what does it mean?
08:38:13 <quicksilver> tavarish: "nothing"
08:38:17 <lilred> tavarish: nothing, sorry
08:38:19 <tavarish> ok
08:38:23 <bobcrash_> quicksilver:  Thanks!  I'll check that out
08:38:43 <lilred> I have to go, ttyl
08:50:48 <stelleg> hey, this might be better suited for #ghc, but does anyone know if it's possible to get GHC to pretty print the C-- IR?
08:51:40 <lpaste> danilo2 pasted “Question about zippers” at http://lpaste.net/96192
08:51:45 <danilo2> Hello! Could somebody tell me if is there any easy way to create a zipper for a complex data type structure, like this one? : http://lpaste.net/96192
08:56:47 <stelleg> if anyone cares its -ddump-cmm
08:57:10 <Hodapp> stelleg: oooh. I did care.
09:00:09 <tavarish> danilo2, I know there is a way to derive a type, which produce the corresponding zipper
09:00:18 <tavarish> but I failed to find useful linkl
09:00:37 <tavarish> but you can apply the derivative thm to find the corresponding zipper
09:07:50 <lilred> OverloadedStrings is genius
09:08:01 <lilred> I'm really enjoying Haskell's metaprogramming capabilities
09:08:47 <Hodapp> lilred: link!
09:09:08 <lilred> Hodapp: https://gist.github.com/sordina/5714390
09:09:50 <bergmark> it's really nice for testing
09:12:46 <lilred> bergmark: do you write your tests as string or what?
09:17:41 <it3ration> morning all
09:18:31 <tomejaguar> Is it possible to do something like 'class MyClass (f a) => MyOtherClass (f ())'?
09:22:10 <Feuerbach> tomejaguar: you may want to look at the constraints package
09:22:27 <Feuerbach> assuming you want to quantify over a universally
09:22:44 <tomejaguar> What I actually have is 'class Monoid (f a) => MyOtherClass f'.  I basically want to capture the notion that 'f a' is a monoid in a parametric way.
09:23:23 <Feuerbach> yup
09:23:41 <tomejaguar> Hmm what is this mysterious constrains package?
09:24:01 <Feuerbach> http://hackage.haskell.org/package/constraints-0.3.4.2/docs/Data-Constraint-Forall.html
09:24:56 <tomejaguar> It's been documented by edwardk, which means I can't work out how to use it.
09:25:27 <bergmark> lilred: no, but you can write isstring instances for some data types to make the tests a lot cleaner, like this: https://github.com/faylang/fay/blob/master/src/tests/Test/Compile.hs#L67
09:25:55 <Feuerbach> tomejaguar: here's an example: http://stackoverflow.com/a/12718620/110081
09:26:07 <danilo2> tavarish: thank you! do you know something more about suuch automatic type deriving and making zippers for complex datatypes?
09:29:52 <tomejaguar> Feuerbach:  Wow very interesting!  Thanks.  I think I will stick without this additional class constraint for now, because it seems to require more non-standard extensions and hackery.  But it's good to know for the future.
09:36:45 <fizruk_> danilo2, take a look at https://www.fpcomplete.com/user/davorak/code-snippets/zipper-tree-examples
09:37:14 <fizruk_> danilo2, not sure that'll help, never had to use zippers myself
09:40:13 <danilo2> fizruk_: Ok, thank you, I'll look into it right now :)
09:40:29 <fizruk_> danilo2, oh it seems `zipper expr` will create a zipper for you
09:41:26 <fizruk_> danilo2, all you'll need are lenses to make moves
09:41:45 <fizruk_> danilo2, and those can be obtained with makeLenses
09:44:24 <danilo2> fizruk_: Hmm this could be cool - btw could you recommend any way of learning lenses? I've tried a time ago but it was a very hard task to me. Maybe now it will be easier, but I prefer asking if thre rae any recommended tutorials etc?
09:44:32 <fizruk_> danilo2, oh you'll need prisms for your Expr type
09:46:46 <zedikj> test
09:46:48 <danilo2> fizruk_: prisms?
09:47:04 <fizruk_> danilo2, prisms are 0-or-1 traversals
09:48:07 <danilo2> fizruk_: Ok, hmm - I'll try to use it . I need to dig into the lenses. Thank you for your help. If I will have any questions I\'ll try to ask you tommorow if you dont mind me to :)
09:49:06 <edwardk> fizruk_ technically they are 0 or 1 traversals you can construct the whole from the part with
09:49:09 <edwardk> > _Left # 4
09:49:11 <lambdabot>   Left 4
09:49:16 <edwardk> ^- that requires more than just an affine traversal
09:49:43 <fizruk_> edwardk, oh right
09:50:04 <zedikj> Hi, Could anybody answer some very very basic questions?  In haskell tutorials is often used notion (x : xs) - it looks like a toople but not list. Why these brackets () are used instead [] ?
09:50:40 <jonplussed> zedikj: you're inclosing the "cons" operator
09:50:41 <edwardk> [ x, xs] would match a list with 2 elements, named x and xs.  [a,b] = a:b:[]
09:51:04 <zedikj> Why not [x : xs] ?
09:51:20 <edwardk> > ['h':"ello"]
09:51:21 <trillioneyes> That desugars to (x:xs):[]
09:51:21 <lambdabot>   ["hello"]
09:51:32 <joelteon> zedikj: that would be [x:xs]
09:51:40 <jonplussed> zedikj: because that's not valid syntax; it's mixing list sugaring and functions/operators
09:51:51 <edwardk> ^that is a list of lists where we've consed onto the list that is the first element of it
09:51:53 <joelteon> well, it could be, couldn't it
09:52:03 <fizruk_> danilo2, I can't actually recommend a particular tutorial on lens: check out something on FP Complete, read haddock documentation, play with functions
09:52:07 <joelteon> :t \[x:xs] -> x
09:52:08 <lambdabot> [[t]] -> t
09:52:12 <jonplussed> oh, wait, you're right
09:52:21 <jonplussed> haha, that is valid, it's just a list of lists, right
09:52:27 <trillioneyes> > case ["hello"] of | [x:xs] -> x
09:52:28 <lambdabot>   <hint>:1:19: parse error on input `|'
09:52:37 <trillioneyes> > case ["hello"] of [x:xs] -> x
09:52:38 <lambdabot>   'h'
09:52:52 <trillioneyes> case "hello" of [x:xs] -> x
09:53:00 <trillioneyes> > case "hello" of [x:xs] -> x
09:53:01 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:53:01 <lambdabot>              with actual type...
09:53:09 <trillioneyes> That took me way more tries than it should have >.>
09:53:11 <FireFly> Maybe you meant (x:xs)
09:53:36 <FireFly> Well, [x:xs] desugars to (x:xs):[] :p
09:53:44 <trillioneyes> Yeah, I was demonstrating that
09:53:47 <FireFly> Aha
09:53:52 <edwardk> danilo2: simon peyton jones does a short intro to lenses on skills matter that gets your head around their internals pretty well. http://www.youtube.com/watch?v=cefnmjtAolY is from my talk in new york on them. there is a short 'operational' tutorial on http://lens.github.io/tutorial.html and tekmo has a short intro here: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
09:53:58 <FireFly> Oh, look, you said exactly the same thing a while back
09:54:00 <FireFly> never mind me
09:54:17 <haasn> “edwardk │ ^that is a list of lists where we've consed onto the list that is the first element of it” <- only element, mind
09:54:28 <edwardk> haasn: fair
09:54:37 <zedikj> Thanks !
09:58:06 <zedikj> What is an effective way to calculate moving average of the lenght n ? If  we have a list [1,3,5,2,10] then should I create list of lists  [[1,3,5],[3,5,2],[5,2,10]] to calculate MA ? It looks very ineficciant from the point of view of memory usage
09:59:01 <tromp__> use scanl
09:59:40 * hackagebot conduit 1.0.9.3 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.9.3 (MichaelSnoyman)
09:59:45 <tromp__> :t scanl
09:59:45 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
10:00:01 <tromp__> scanl 0 [0..]
10:00:02 <fizruk_> :t zipWith3
10:00:03 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:00:11 <tromp__> > scanl 0 [0..]
10:00:12 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
10:00:12 <lambdabot>    arising from a use ...
10:00:20 <tromp__> > scanl (+) 0 [0..]
10:00:21 <lambdabot>   [0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,25...
10:00:46 <tromp__> > let s=scanl (+) 0 [0..] in zipWith (-) s (drop 5 s)
10:00:47 <lambdabot>   [-10,-15,-20,-25,-30,-35,-40,-45,-50,-55,-60,-65,-70,-75,-80,-85,-90,-95,-1...
10:00:57 <tromp__> > let s=scanl (+) 0 [0..] in zipWith (-) (drop 5 s) s
10:00:58 <lambdabot>   [10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,...
10:01:05 <tromp__> those are sums of 5
10:01:34 <tromp__> divide by 5 to get moving avg
10:08:37 <int-e> > zipWith take [1..] $ transpose $ iterate (scanl (+) 0) (repeat 1)
10:08:38 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
10:13:28 <maikklein> I have a type called "Vec2F" and I can use it like "Vec2F 0 0". But I want to make my own type like "type Dir = Vec2F" but now I can't do "Dir 0 0". How would I fix this?
10:14:03 <enthropy> you can make a function `dir = Vec2F'
10:14:21 <maikklein> ah ok
10:14:41 * hackagebot oauthenticated 0.0.4 - Simple OAuth client code built atop http-conduit  http://hackage.haskell.org/package/oauthenticated-0.0.4 (JosephAbrahamson)
10:20:06 <cariveri> Hi. "could not find module Text.Parsec.Indent". where is it?  (ubuntu).
10:21:06 <dv-> @hoogle Text.Parsec.Indent
10:21:06 <lambdabot> package IndentParser
10:21:06 <lambdabot> package indentparser
10:21:06 <lambdabot> package indents
10:23:30 <cariveri> dv-: thats what I thought. but it seems I need to find a ubuntu package holding it.
10:25:30 <geekosaur> glwt
10:25:51 <geekosaur> ubuntu doesn't even package the platform these days, never mind additional packages
10:26:37 <dv-> cariveri: you can install cabal-install and then use that to install packages
10:26:46 <activeaspect> quickcheck question - i have a data instance of Arbitrary and I'm not seeing how you can use Test.QuickCheck.sample to give you arbitrary values
10:27:15 <activeaspect> not so much a question as a shot in the dark. i think sample is the way to go
10:28:00 <cariveri> dv-: ok thanks. cabal install indents worked fine.
10:29:54 <enthropy> activeaspect: sample (arbitrary :: Gen Whatever)
10:30:39 <activeaspect> enthropy: nice, thanks
10:32:50 <NickHu> Hey guys, I'm trying to fix the haskell-void aur package, but it keeps giving me:
10:32:53 <NickHu> void-0.6.1: cannot find libHSvoid-0.6.1.a on library path (use --force to override)
10:34:19 <NickHu> Pkgbuild here: http://lpaste.net/96193
10:34:43 * hackagebot comonad-extras 4.0 - Exotic comonad transformers  http://hackage.haskell.org/package/comonad-extras-4.0 (EdwardKmett)
10:36:32 <lasticot> hi, rather than having a data type derive from Eq I would like to test if a variable has been constructed with "Quit"  as the first argument of when. Is there a clean way to do it?
10:37:21 <lasticot> ok the test is meant to the condition expected as the first argument of when
10:38:32 <enthropy> @undo [ () | Just {} <- x ]
10:38:32 <lambdabot> concatMap (\ a -> case a of { Just{} -> [()]; _ -> []}) x
10:39:01 <enthropy> you might take advantage of that kind of thing
10:39:16 <levi> You could even use lambdacase.
10:39:27 <enthropy> otherwise just writing out the case expression (or defining a function that does such) is better
10:39:43 * hackagebot syb-extras 0.3 - Higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.3 (EdwardKmett)
10:40:51 <lasticot> ok thank you
11:03:27 <maikklein> which linear algebra library would you recommend for games?
11:08:18 <skypers> do you know a function that repeats an argument?
11:08:48 <silver> @hoogle cycle
11:08:49 <lambdabot> Prelude cycle :: [a] -> [a]
11:08:49 <lambdabot> Data.List cycle :: [a] -> [a]
11:08:49 <lambdabot> Data.ByteString.Lazy cycle :: ByteString -> ByteString
11:08:56 <silver> > cycle 'a'
11:08:57 <lambdabot>   Couldn't match expected type `[a0]'
11:08:57 <lambdabot>              with actual type `GHC.Type...
11:09:05 <silver> > cycle "a"
11:09:06 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:10:15 <supki> > repeat 'a'
11:10:16 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:10:45 <NickHu> lambdabot just evaluates haskell one liners?
11:10:52 <supki> > a ^.. repeated
11:10:54 <lambdabot>   [a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,...
11:11:26 <ParahSai1in> and multiliners
11:11:53 <klugez> NickHu: Also some others commands, like @type, @kind, @hoogle...
11:13:02 <fikusz> > iterate id 'a'
11:13:03 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:15:40 <ClaudiusMaximus> maikklein: i've used Vec for game-like demos (unboxed 4x4 matrices), after previously handrolling my own, but other alternatives may exist
11:16:28 <NickHu> take 3 [x | x <- [1..3]]
11:16:39 <NickHu> Hmm
11:17:04 <scriptor> you need to prepend it with a >
11:17:12 <scriptor> > take 3 [x | x <- [1..3]]
11:17:13 <lambdabot>   [1,2,3]
11:17:25 <silver> >[1]
11:17:32 <silver> "> "
11:17:38 <silver> > [1]
11:17:39 <lambdabot>   [1]
11:17:43 <NickHu> Ah, I see
11:17:56 <NickHu> > print "Test"
11:17:57 <lambdabot>   <IO ()>
11:18:08 <silver> hehe
11:18:09 <NickHu> > "Test"
11:18:10 <lambdabot>   "Test"
11:28:36 <skypers> :t bimap
11:28:37 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
11:34:48 * hackagebot bert 1.2.2 - BERT implementation  http://hackage.haskell.org/package/bert-1.2.2 (RomanCheplyaka)
11:34:50 * hackagebot oauthenticated 0.0.5 - Simple OAuth client code built atop http-conduit  http://hackage.haskell.org/package/oauthenticated-0.0.5 (JosephAbrahamson)
11:38:32 <vividpaws> good day haskell friends
11:40:16 <joelteon> hi
11:40:35 <vividpaws> is your name joel? how clever
11:40:41 <joelteon> yes
11:48:07 <donri> oh hey new haskellcast
11:48:13 <frelux> maybe someone can help me figure out what I want to do here. I'm trying to see if haskell's limited dependent type support can let me do something like this: i have two Channels that take a Value type. I want to tag each Channel and Value with an ID type such that the channel will only accept Values with the same ID (e.g. imagine I a value out of the channel, do some operations on it, and put it back into the channel; I want to ensure 
11:48:14 <frelux> can only go back into the same channel it came out of)
11:48:45 <frelux> (*e.g. imagine I <take> a value out of the channel)
11:49:16 <donri> frelux: sounds doable
11:49:46 <donri> maybe possibly could do it with just rankntypes, ST-style, but might not allow for convenient interleaving of operations
11:50:05 <frelux> (but of course the catch being that I'd like to construct these channel/value pairs at runtime)
11:50:20 <frelux> aha, yes
11:50:54 <athan> Sorry to interject, but is there anyone out there willing to help me learn denotational semantics?
11:50:56 <donri> well it's gonna be hard to give them globally unique IDs at runtime without something like indexed monads
11:52:56 <donri> incidentally that's exactly what they do in the monadic regions paper
11:53:18 <donri> they tag file handles with type-level nats that are incremented in an indexed monad
11:53:25 <donri> http://okmij.org/ftp/Computation/resource-aware-prog/region-io.pdf
11:53:31 <frelux> donri: fantastic, thanks!!
11:54:05 <donri> np
11:54:28 <donri> sadly indexed monads are clunky in current haskell
11:54:32 <donri> at least if you want do notation
11:54:59 <frelux> bummer. I'll adjust my expectations accordingly : )
11:55:30 <enthropy> frelux: instead of passing around (Chan a, Chan b)  you can pass around an   f :: (a -> IO b) -> IO ()
11:57:10 <frelux> enthropy: definitely a good idea too, thanks! I'll have to think about whether my toy example above (which could certainly be modeled that way) is similar enough to what I'm actually trying to do : )
11:58:15 <enthropy> it's a bit odd that you mention putting the result back into the original chan
11:59:15 <frelux> haha yeah, definitely not what I'm actually trying to do, was just trying to condense the concept down to a few sentences : )
12:00:37 <Uwood> Hello, i'm kinda new to STM hoping to find help on topic here.
12:01:33 <Uwood> http://vpaste.net/hjhhh
12:02:08 <Uwood> Not sure what should i write in mapM_ lambda. return $ hPutStrLn h "test" doesn't even being evaluated.
12:04:04 <frelux> Uwood: you'd need a "sequence" for that I believe
12:05:15 <frelux> Uwood: you're returning a list of IO actions, and sequence takes a list of monadic actions and turns it into a single action
12:05:27 <Uwood> frelux: Ah, let me try it.
12:06:00 <frelux> so replace atomically with sequence =<< atomically (you'll probably have to move things around due to the $ precedence)
12:08:09 <viran> something that runs on input of size n , number of operations is n(n-1)(n-2)....(1) .. is this O(n^2)  or O(n!) ?
12:08:22 <arnsholt> n!
12:08:37 <frelux> Uwood: you could do (sequence <=< atomically) $ do ...
12:08:54 <arnsholt> n+(n-1)+(n-2)+...+1 is quadratic
12:10:35 <Uwood> frelux: Yep, thanks.
12:10:59 <Uwood> By the way, is it threadsafe to havve broadcast function like that?
12:12:12 <ReinH> chrisdone: woo
12:15:15 <Uwood> What if two threads will use broadcast at same time?
12:15:34 <viran> thanks arnsholt
12:15:34 <Uwood> readTVar will prevent bad things?
12:15:54 <geekosaur> that is the whole point of STM...
12:16:39 <Uwood> geekosaur: So readTVar will lock serverClients for the duration of whole `do' block?
12:16:58 <fryguybob> Uwood: What are the "things" that you are doing?  hPutStrLn is not part of the transaction.
12:18:29 <Uwood> fryguybob: Chat server.
12:18:47 <Uwood> So using hPutStrLn isn't safe in broadcast function, right?
12:19:01 <Uwood> How can i do it in safe way?
12:19:16 <simukis_> Uwood: you can't do IO inside STM.
12:19:38 <fryguybob> Uwood: I would need to know more about the whole structure of the program to know if the hPutStrLn is safe.
12:20:45 <fryguybob> Uwood: From your paste something that could happen is the following.  The transaction completes reading clients from `serverClients` and building IO actions to run.  Some other transaction completes removing every client from `serverClients`.  The IO actions built before are now run.  Is that safe?
12:21:15 <lpaste> Uwood pasted “Chat server” at http://lpaste.net/96197
12:22:28 <Uwood> fryguybob: Nope, also two threads can write to same handler simulatneusly.
12:22:29 <ReinH> Uwood: you might be interested in SimonM's book, which is free atm
12:22:40 <fryguybob> Uwood: You could avoid that problem by instead of building an IO action in the transaction, write to some output queue that another thread reads from and writes.  When something is removed from the `serverClients` it also manages closing that thread.
12:26:35 <Uwood> fryguybob: Sounds hard
12:27:27 <Uwood> Do i need some kind of TChan on each client and thread which will go through each client and deliver messages from chans?
12:27:28 <simukis_> Uwood: ok. How about having it rephrased it this way: make a thread which infinitely reads action from TChan and executes it. Now you can put actions into that TChan from everywhere else.
12:29:18 <silver> ReinH, which book?
12:29:33 <Uwood> silver:c
12:29:34 <Uwood> Parallel and Concurrent Programming in Haskell
12:30:07 <fryguybob> Uwood: It isn't partucularly hard.  The goal is to express the atomicity that your use case requires.  The easy option is a global lock that sequences everything.
12:30:08 <donri> http://chimera.labs.oreilly.com/books/1230000000929
12:30:26 <silver> http://community.haskell.org/~simonmar/pcph/
12:32:42 <Uwood> But having that kind of chan on each client implies that in broadcast function i have to writeTChan on each client and if client's chan is still full then it will block, right?
12:35:42 <intrados> GHCi should be available for GHC 7.6.3 on armhf, right?
12:36:40 <donri> no, but in 7.8
12:36:51 <fryguybob> Uwood: These are not bounded channels, there is no full.
12:38:09 <intrados> donri: Ah, thanks
12:38:24 <Uwood> fryguybob: Ah, so my thread for reading from these chans will read from it until it empty?
12:39:31 <ReinH> I mention the book specifically because it explores a few different ways of doing this
12:39:54 <donri> (and because he recently interviewed simon on the subject! ;))
12:40:04 <ReinH> donri: I haven't even plugged the podcast yet :p
12:40:17 <donri> :)
12:41:22 <ifesdjeen> hello everyone! do you know wether it's possible to create "IO Something" if I'm already in monadic context?.. I've tried what I could, but still getting Couldn't match expected type `Maybe Something'
12:41:47 <ifesdjeen> or maybe question is wether it's possible to get back to IO Something from IO IO Something
12:42:05 <ReinH> ifesdjeen: :t join
12:42:06 <fryguybob> Uwood: Right.  When the chan is empty it will block.  But you can block waiting for multiple things to change.  For insance you could have a TVar that indicates that a client has disconnected.  You can check if the client is disconnected `orElse` read from the channel.
12:42:09 <ReinH> :t join
12:42:10 <lambdabot> Monad m => m (m a) -> m a
12:43:03 <ifesdjeen> thank you ReinH
12:43:18 <TravisD> ReinH: I guess that assumes the monadic context he's already in is also IO
12:43:21 <ifesdjeen> genius, i knew it should be somehow possible, much appreciated
12:43:34 <TravisD> oh, I didn't read clearl
12:43:34 <TravisD> y
12:43:40 <ReinH> ifesdjeen: you can always create a value of IO Something... return Something :: IO Something, but if your function provides a Maybe Something you have to provide a Maybe Something for it to typecheck
12:43:44 <akaposi> Hi, does anyone know how to cabal install repa-devil on Windows 7? It complains about "Missing C library: IL" and specifying extra-include-dirs, extra-lib-dirs does not help
12:44:38 <ifesdjeen> ReinH: ok, I think I understand now
12:44:39 <Uwood> :src join :: IO
12:44:59 <ReinH> Uwood: heh good luck with that
12:45:37 <ReinH> can I constrain join to IO when I ask lambdabot for its type?
12:45:38 <fryguybob> Uwood: In IO join will run an action that produces a new action, then run that.
12:46:18 <silver> @src join
12:46:18 <lambdabot> join x =  x >>= id
12:46:21 <ReinH> fryguybob: not really?
12:46:33 <ReinH> fryguybob: it will provide a new IO action where the two prior actions are sequences
12:46:37 <ReinH> it won't necessarily run them
12:46:42 <fryguybob> ReinH: Right.
12:46:42 <ReinH> I can call join from anywhere, not just main
12:46:47 <intrados> donri: Is the ghc git HEAD the best/only way to get 7.8 at this point?
12:47:26 <fryguybob> ReinH: I was more describing what executing  join m  would do.
12:47:43 <ReinH> ok
12:49:44 <ReinH> fryguybob: I think it's important to not conflate the two in our explanations as that's a common source of confusion
12:51:51 <SLi> I wonder why http://hackage.haskell.org/package/ListLike doesn't show the api documentation (the package names are not links)?
12:52:03 <SLi> Or module names.
12:54:21 <tomejaguar> SLi: Maybe because it's only recently uploaded?  The following works: http://hackage.haskell.org/package/ListLike-4.0.0
12:54:37 <SLi> tomejaguar: hmm, thanks.
12:55:23 <zedik> Hi ! What is the meaning of ( x : xs ) ? : means add element to . ( ) - tuple . How then ( x : xs ) matches list ?
12:55:38 <tomejaguar> x:xs  means put x on the front of the list xs.
12:55:49 <tomejaguar> (Unless it's a pattern, in which case it means match as such)
12:56:08 <ReinH> zedik: 1:2:3:[]
12:56:19 <ReinH> > 1:2:3:[]
12:56:19 <lambdabot>   [1,2,3]
12:57:09 <zedik> tomejaguar: thanks
12:57:16 <ReinH> zedik: x:xs matches any non-empty list, with x = head and xs = tail
12:58:28 <zedik> tomejaguar: But why ( ) are used ?
12:59:05 <FreeFull> zedik: Because the constructor takes parameters
12:59:17 <Uwood> thanks for help guys
12:59:27 <Uwood> i'm feeling more confident about STM now
12:59:56 * hackagebot raven-haskell-scotty 0.1.0.3 - Sentry http interface for Scotty web server.  http://hackage.haskell.org/package/raven-haskell-scotty-0.1.0.3 (AlexanderBondarenko)
13:00:17 <zedik> Thanks
13:00:46 <fryguybob> Uwood: No problem.  More questions are always welcome :D
13:01:29 <khyperia> If I want to make a GUI application centered around text editing, what GUI library might I use?
13:01:37 <tomejaguar> zedik: Just for precedence I guess.  () doesn't always mean tuple!
13:02:03 <tomejaguar> (Well, literal '()' means unit, but stuff inside ( ... ) doesn't always mean tuple!)
13:02:35 <ReinH> FreeFull: er?
13:02:52 <zedik> tomejaguar: interesting ..
13:02:56 <ReinH> () is used for tuples and grouping
13:03:12 <ReinH> f x:xs = (f x):xs
13:03:18 <ReinH> vs f (x:xs)
13:03:38 <haasn> zedik: think in terms of 2*(2+3)
13:03:45 <haasn> f (x:xs)
13:04:11 <ReinH> khyperia: emacs
13:04:13 * ReinH ducks
13:04:15 <silasm> isn't it only a tuple if there's a comma involved? (also does unit count as a tuple?)
13:04:25 <khyperia> ... how? what?
13:04:38 <ReinH> khyperia: jokes
13:04:45 <zedik> haasn: got it !) tuples, grouping, priority ..
13:04:57 <ReinH> There are no 1-tuples, no
13:04:58 <FireFly> well the latter two is more-or-less the same thing
13:05:05 <ReinH> since a 1-tuple is trivially isomorphic with... a value
13:05:35 * FireFly likes viewing (x) as a circumfix identity operator
13:05:35 <silasm> ReinH: well wouldn't () be a zero-tuple anyways?
13:05:41 <ReinH> and haskell decided to use (expression) to group expression, not put it in a tuple
13:05:47 <ReinH> silasm: yes, it is
13:05:48 <tomejaguar> ReinH: Kind of.  Should a 1-tuple be boxed?
13:05:54 <tomejaguar> Some might say so.
13:06:00 <khyperia> well, I'll say the full story. I've tried a bunch of IDEs (leksah, eclipsefp, emacs, vim, etc) and none of them has what I need, so I figured I could spend a few weeks and make a basic editor with the stuff that I need.
13:06:03 <ReinH> tomejaguar: hmm
13:06:09 <FireFly> tomejaguar: in a mathematical sense a 1-tuple doesn't make sense, I think
13:06:29 <ReinH> khyperia: madness :)
13:06:41 <skypers> today, I read some cabal code on github
13:06:58 <skypers> and I found something that just impressed me
13:06:58 <FireFly> (though neither does a 0-tuple)
13:06:59 <FreeFull> ReinH: He was asking about pattern matching
13:07:01 <khyperia> anyway, I have no idea what GUI library to use. Can anyone throw advice at me?
13:07:04 <skypers> so simple but neat
13:07:04 <Uwood> fryguybob: Hm, got confused, if chans are not boudned then writeTChan just adds new thing in chan and not overwrites everything in that chan with new thing, right?
13:07:17 <silasm> khyperia: *obligatory mention of yi*
13:07:20 <tomejaguar> ky
13:07:29 <tomejaguar> khyperia: How about working on Yi?
13:07:30 <khyperia> I... don't think I've tried yi. What's it like?
13:07:33 <skypers> the fact to write a function, and use a first indentation of 4 spaces in order to scope the where in two
13:07:36 <skypers> #brillant
13:07:45 <skypers> I was always having issues with my 2 spaces indent
13:07:53 <skypers> now I’m gonna do the same, it’s so nice!
13:08:08 <skypers> is there a tool te re-indent a file that way?
13:08:24 <FreeFull> I guess the brackets aren't obligatory in a case expression
13:08:50 <dcoutts_> skypers: yes, I like that style
13:09:03 <fryguybob> Uwood: Right it is just a queue.
13:09:14 <tomejaguar> skypers: Can you point to an example of the style you're talking about?
13:09:25 <skypers> tomejaguar: sure, wait
13:09:57 * hackagebot tempodb 0.2.0.2 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.0.2 (ParnellSpringmeyer)
13:10:00 <skypers> tomejaguar: https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Init/Heuristics.hs#L262
13:10:06 <skypers> gitConfigQuery
13:10:12 <skypers> look at the first indent line
13:10:16 <skypers> and the where statement
13:10:18 <skypers> it’s just nice
13:10:26 <silasm> khyperia: can't really say as I haven't had a lot of opportunity to really look at the source. It's okay from a user standpoint, it's got a few quirks in vim-mode (using a somewhat old version though, they may have been fixed)
13:10:39 <skypers> also, I always put the first “whereified” thing on the same line of the where
13:10:40 <tomejaguar> skypers: Oh right.  I don't do that because I don't like it to use up the vertical space.
13:10:48 <skypers> that way of doing is even better
13:11:01 <tomejaguar> You can also put the where on the preceding line
13:11:03 <skypers> tomejaguar: yeah but it reduces horizontal one
13:11:06 <skypers> and it’s important
13:12:33 <Uwood> What atomically actually does? http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-Conc-Sync.html#v:atomically It says it runs series of actions atomically, but what does it means actually?
13:13:42 <Uwood> My understanding is that it's a transaction in which i can pass do block with series of STM actions which will be run in that one transaction.
13:13:45 <Uwood> Am i correct?
13:14:20 <ReinH> Uwood: you should read SimonM's book :)
13:14:22 <khyperia> silasm, problem: yi depends on the unix package, and I'm on windows
13:15:15 <Uwood> ReinH: Yeah, i'm really want to.
13:15:17 <dcoutts_> Uwood: yes, read a tutorial on STM
13:15:20 <ReinH> Uwood: it's free, so do it :)
13:15:21 <khyperia> oh, never mind, I didn't RTFM
13:15:35 <ReinH> dcoutts_: hi!
13:15:46 <dcoutts_> hello
13:17:19 <fryguybob> Uwood: You can reason about transactions as though they are run one at a time.  No part of the system sees the effects of a transaction halfway through.
13:17:56 <fryguybob> Uwood: The implementation is not, however, a single global lock that only lets one transaction run at a time.
13:18:58 <jle`> is ther ea way to point-free an && expression where the thing is used on both sides?
13:19:26 <Uwood> fryguybob: Got it, thanks.
13:19:27 <fryguybob> Uwood: Additionally Haskell's STM has retry for blocking.  When a transaction executes `retry` it starts over again from the beginning.  The implementation is smart and only restarts when something has changed.  Otherwise it would just run to the retry again.
13:20:22 <fryguybob> Uwood: There is also `orElse` which allows for choice.  It takes two transactions and tries the fist, if that results in executing `retry` (blocking) then it tries the second.
13:21:02 <Uwood> fryguybob: Wow, that's really interesting.'
13:22:16 <Uwood> ReinH: I will.
13:22:41 <fryguybob> Uwood: Together `retry` and `orElse` make for a very nice composable way to handle concurrency.
13:23:49 <Peaker> khyperia: what kind of features do you want to implement?
13:23:51 <Uwood> fryguybob: Yeah, and it seems very powerfull.
13:24:15 <Peaker> khyperia: I'm working on an IDE/editor for a Haskell dialect, and I use graphics-drawingcombinators to draw
13:25:17 <khyperia> Peaker, what I'd like in an IDE is the ability to open up a source file and have all the awesomeness of things like continuous build (or rather just running through the typechecker of ghc), hlint, etc., but no project file required - just that file (and maybe an external config that doesn't have to be right next to the file in question)
13:26:10 <khyperia> the reason I want that is because I think I'm going to (attempt to) get into ghc dev, and there's no way I'm going to use, say, eclipsefp on that.
13:26:27 <khyperia> and emacs/vim just didn't cut it for me (sorry)
13:26:38 <Peaker> khyperia: there's "flymake" for emacs
13:26:52 <acowley> How do emacs and vim not cut it for you?
13:26:57 <Peaker> khyperia: I think writing up something like eclipse/vim/emacs is a project for more than a few weeks :)
13:27:04 <ReinH> khyperia: I have that with vim
13:27:06 * ReinH shrugs
13:27:10 <acowley> I have that emacs
13:27:15 * acowley shrugs ReinH
13:27:20 <ReinH> seems good
13:27:31 <khyperia> I mean, obviously it would be cruddy and feature-lacking, but it might do for me.
13:27:43 <ReinH> I can search local haddock index for imports and add them incrementally
13:27:47 <ReinH> which is pretty cool
13:28:11 <acowley> ReinH: How does that work out with sandboxes?
13:28:15 <khyperia> also when I try to install yi, it just fails at "loading package cairo" and drops to "failed to install yi", no error message.
13:28:43 <ReinH> acowley: it searches the global haddock index
13:28:51 <silasm> acowley: yeah installing yi never worked for me until I was on arch, it tends to not support anything other than the latest version of GHC.
13:29:20 <silasm> khyperia: ^, sorry for wrong ping acowley
13:29:21 <acowley> ReinH: So you need to have packages you might use installed both globally and in the sandbox?
13:29:50 <silasm> also Yi probably isn't what you want yet anyways (though the goals are pretty far-reaching).
13:30:03 <ReinH> acowley: I guess.
13:30:08 <ReinH> acowley: it isn't perfect
13:30:18 <acowley> If I had a nickel for every time somebody misspelled "acowley" as "khyperia" ...
13:30:26 <ReinH> acowley: are haddocks for sandboxed packages installed locally?
13:30:31 <ReinH> I honestly don't use sandboxes that often
13:30:33 <acowley> ReinH: Yeah, there are still a bunch of loose ends with sandboxes
13:30:39 <ReinH> only as a get out of hell free card
13:30:40 <khyperia> well, that's why I asked "what's Yi like", silasm
13:30:49 <silasm> acowley: heh, read it as I was writing, register got overwritten
13:31:06 <acowley> ReinH: Well, normally I'd say that you should be using sandboxes because they're awesome, but in this case, not so much :P
13:31:08 <silasm> khyperia: I didn't really have anything to go off of. Personally I don't really like IDEs much.
13:31:19 <Uwood> http://chimera.labs.oreilly.com/books/1230000000929/ch12.html On ther bottomish part of page there is runClient defintion and handleMessage definition.
13:31:38 <Uwood> Why did he runs IO inside of atomically?
13:32:05 <Uwood> Well, i gues not "runs" but just builds.
13:33:05 <ReinH> acowley: :p
13:33:33 <ifesdjeen> is there any way to compose Maybe monads, in a way that "try next until meet Just, then return Just, if you keep meeting Nothing, continue" ?
13:33:35 <ReinH> Uwood: he uses STM as a mechanism for producing IO actions that represent the results of computation
13:33:45 <ReinH> those IO actions are then executed outside of STM
13:34:12 <ifesdjeen> or not compose, maybe better say chain
13:34:20 <ReinH> "The loop function itself is implemented as an STM transaction that returns an IO action, which is then performed. This is a common pattern in STM. Since we can’t invoke IO from inside STM, the transaction instead returns an IO action which is invoked by the caller of atomically."
13:34:37 <ReinH> "results of computation" is more accurately "computation to be performed"
13:34:40 <ifesdjeen> for example, try action 1, if it returns nothing, try action 2, and so on
13:34:50 <mangaba_leitosa> > Nothing `mplus` Nothing `mplus` Just 1 `mplus` Just 2
13:34:52 <lambdabot>   Just 1
13:34:55 <mangaba_leitosa> ifesdjeen: ^
13:35:08 <ifesdjeen> thanks mangaba_leitosa
13:35:18 <ReinH> ala First foldMap [Nothing, Nothing, Just 1, Just 2]
13:35:20 <ReinH> > ala First foldMap [Nothing, Nothing, Just 1, Just 2]
13:35:22 <lambdabot>   Just 1
13:35:26 <ReinH> plenty of ways to skin that cat
13:35:28 <ifesdjeen> oh
13:35:32 <ifesdjeen> perfect
13:35:40 <Uwood> ReinH: But where is he actually runs these computations?
13:35:46 <FireFly> Hm, isn't mplus == mappend?
13:36:29 <Peaker> FireFly: nope, it can have and does have different meanings than Monoid (e.g: in Maybe)
13:36:36 <fryguybob> Uwood: The one in runClient is using join to do that.
13:36:42 <ReinH> Uwood: in main
13:36:43 <FireFly> Huh, good to know
13:36:47 <Peaker> > mappend (Just [1,2,3]) (Just [4,5,6])
13:36:48 <lambdabot>   Just [1,2,3,4,5,6]
13:36:48 <ReinH> Uwood: IO actions are always run by main
13:36:57 <Peaker> > mplus (Just [1,2,3]) (Just [4,5,6])
13:36:58 <lambdabot>   Just [1,2,3]
13:37:04 <ReinH> FireFly: no
13:37:11 <ReinH> FireFly: the MonadPlus impl of Maybe is equivalednt to First
13:37:22 <FreeFull> Monadplus doesn't place any constraints on the result type of the monad
13:37:30 <ReinH> the Monoid impl has a Monoid m => Maybe m constraint
13:37:46 <FireFly> Ah
13:38:02 <Peaker> It is quite inelegant that we need both MonadPlus and Monoid, IMO
13:38:03 <funky_> How can I export pragmas/directives from a module? I want to know if it is possible to use TypeSynonymInstances from an imported module without copying the pragma to the new file as well
13:38:14 <ReinH> Peaker: it's a silly way to implement monoid imo
13:38:28 <mgsloan> Somewhat related: I've been using a pattern lately where a DB transaction return IO actions.  This allows transactions to be shorter, but failures from IO don't abort (which can be good, usecase dependent of course)
13:38:33 <ReinH> (the Maybe monoid, that is)
13:38:52 <Peaker> ReinH: I think it's about the laws (mzero >> x == mzero, that you don't get with Monoid)
13:39:14 <ReinH> Peaker: you still get mempty <> a = a
13:39:19 <mgsloan> The benefit of this pattern is that it allows more composability than having IO actions that call the DB
13:39:24 <ReinH> and you don't need >>
13:39:26 <ReinH> for monoid
13:39:38 <Peaker> ReinH: the idea is that you *want* laws relating <> and >>
13:39:47 <ReinH> Also it annoys me that it's called MonadPlus. It should be MonadTimes
13:39:53 <Peaker> ReinH: when you want "exception throwing/catching" semantics for mzero/mplus
13:39:55 <ReinH> :p
13:40:16 <ReinH> Peaker: if it was MonadTimes you could also have mzero such that mzero `mtimes` a = mzero
13:40:29 <ReinH> mzero is then your usual absorbtive zero
13:40:39 <FireFly> That's.. a good point
13:40:48 <Peaker> but that's not what you want, you want mzero to be the neutral element, and "mtimes" is simply >>
13:40:54 <Peaker> (neutral for the "mappend" like operation)
13:40:58 <bitemyapp> ReinH: Maybe Monoid? Sorry?
13:41:00 <ReinH> Peaker: mone is the identity
13:41:11 <Peaker> ReinH: but that's a different structure than the one you want
13:41:16 <ReinH> Peaker: but is it? :)
13:41:21 <Uwood> Found it, it's in runClient. `join' runs IO inside STM.
13:41:31 <Peaker> mzero/mplus/>> together form the desired structure
13:41:34 <ReinH> Peaker: you'd write different code with this structure. I'm not sure it's worse.
13:41:47 <Peaker> ah, you're talking about a deeper re-design :)
13:41:58 <fryguybob> Uwood: Not inside.  atomically results in an IO action.
13:42:06 <Peaker> perhaps one is due -- I'm thinking about how Haskell could encode the existing design elegantly
13:42:14 <ReinH> Peaker: right, {a,mzero,>>} form a left zero semigroup :)
13:42:22 <ReinH> such that mzero >> a = mzero
13:42:30 <ReinH> wait, a >> a' = a right?
13:42:32 <ReinH> er a'
13:42:34 <Peaker> "a"?
13:42:38 <ReinH> fuck I don't know anything
13:42:44 <Uwood> fryguybob: Ah, indeed.
13:42:45 <SLi> Is there some good library or trick for working with (read-only) streams with position info tracking? I tried to write a "data BytePositioned a" myself, but that devolved into lots of boilerplate writing and reimplementing all kinds of list functions...
13:42:48 <ReinH> one sec I need to look up MonadPlus again
13:42:51 <funky_> Is there a way to export pragmas from a module? Such as TypeSynonymInstances, OverlappingInstances et cetera.
13:43:05 <geekosaur> no
13:43:05 <Javran> is there someone familiar with GetOpt? I find OptArg and ReqArg in ArgDescr require a String in their constructor but I have no idea what I'm supposed to fill.
13:43:09 <fryguybob> Uwood: It might be clearer if you add an additional name.  Take the do block from server and name it serverT, then it has the type STM (IO ())
13:43:33 <fryguybob> atomically serverT :: IO (IO ())
13:43:36 <ReinH> right, >> is still >>, so a >> b = b
13:43:44 <ReinH> Peaker: wait, you said mzero >> b = mzero?
13:43:48 <fryguybob> join $ atomically serverT :: IO ()
13:44:01 <Peaker> ReinH: yeah, "mzero" is like throwing an exception
13:44:04 <ReinH> yep
13:44:13 <ReinH> so mzero and >> form a zero semigroup
13:44:18 <Peaker> ReinH: "a `mplus` b" is like combining the non-exceptional results of "a" and "b"
13:44:30 <ReinH> actually no
13:44:39 <ReinH> because zero semigroups have weird semantics, iirc a <> b = 0
13:44:44 <ReinH> forall a.b.
13:44:54 <ReinH> aanyway
13:45:00 <Peaker> Well, a >> mzero = mzero   is a fake law, since destructive monads cannot really support it (e.g: IO)
13:45:15 <ReinH> right
13:45:34 <ReinH> Peaker: I still think introducing an annihilative zero would have been a nice alternative
13:45:35 <geekosaur> Javran, it's just a string to display in a usage message
13:45:45 <Peaker> ReinH: one that IO can't support?
13:45:59 <ReinH> Peaker: sure
13:46:32 <ReinH> reallyZero <> a = reallyZero = a <> reallyZero for modelling failure
13:46:50 <ReinH> Peaker: you end up cheating with IO anyway
13:47:08 <SLi> It's possible I should be using parsec anyway... Basically what my program is currently doing with zipped (Int,String), (Int,[Word8]) and (Int,[Word16]) lists is recognizing positions that meet certain criteria in a binary file, but carrying around the byte position that way becomes cumbersome.
13:47:21 <geekosaur> Javran: so if you have (Option ['f'] ["--file"] (OptArg ... "FILE") "command file") then the synopsys will show "-f FILE" and "--file FILE" and the lonh description will be something like "-f, --file FILE       command file"
13:47:30 <geekosaur> similar to GNU getopt
13:47:55 <Uwood> fryguybob: Thank you. But how does he achives thread safety there? If another hypothetical thread will write to same handler as server from runClient writes currently then there will be a mess.
13:48:13 <Peaker> ReinH: cheating?
13:48:19 <Uwood> Absense of that hypothetical thread gurantees thread safety? :)
13:48:24 <Peaker> ReinH: without the right-zero law there's no problem with IO afaik
13:48:44 <Philonous> Peaker, I didn't follow the entire discussion, but isn't that exactly why there is no MonadPlus instance for IO?
13:48:51 <Javran> geekosaur: ok, I get it, just wondering if that is something like a description
13:49:37 <geekosaur> short description that goes with the option specifier to identify the parameter, as opposed to the longer description which is always there
13:49:37 <Peaker> Philonous: An instance exists in Control.Monad.Error or such
13:49:52 <Philonous> It does? *shudders*
13:50:00 <Peaker> Indeed one doe (from Control.Monad.Trans.Error)
13:50:12 <Peaker> the right-zero law is considered "weak" I think, and allowed to be broken
13:50:12 <geekosaur> (and is part of OptArg and ReqArg because for NoArg there is no argument to describe)
13:50:19 <intrados> Are there any flags for cabal-install on low memory systems?
13:50:50 <ReinH> thet right-zero law is weaksauce
13:50:56 <ReinH> it is a puny law
13:50:58 <Javran> another quick question: is getOpt capable of parsing something like: "foo -a bar -b bar1 [file1 file2 file3 ...]", i.e. some arguments without an option prefix
13:51:22 <monochrom> intrados: perhaps -j1 to ensure it does only one thread and one thing at a time
13:51:24 <ReinH> Javran: what happens when you try?
13:51:52 <monochrom> actually, s/thread/job/
13:52:22 <wojtekM_> oh, vim channel
13:52:44 <fryguybob> Uwood: Sorry, I'm going for a bit.
13:52:52 <intrados> monochrom: Thanks. I'll give it a try
13:53:05 <monochrom> cabal-install itself doesn't use all that much memory. but GHC does. perhaps tell cabal-install to tell GHC to use less memory. let me look up how.
13:53:33 <wojtekM_> I'm trying to cabal blas package. And I'm getting the following error:
13:53:41 <wojtekM_> [ 1 of 49] Compiling BLAS.Internal    ( lib/BLAS/Internal.hs, dist/build/BLAS/Internal.o )
13:53:41 <wojtekM_> lib/BLAS/Internal.hs:74:1:
13:53:41 <wojtekM_>     Unacceptable argument type in foreign declaration: CSize
13:53:41 <wojtekM_>     When checking declaration:
13:53:44 <wojtekM_>       foreign import ccall safe "static strings.h bzero" bzero_
13:53:45 <Uwood> fryguybob: No problem.
13:53:47 <wojtekM_>         :: Ptr () -> CSize -> IO ()
13:53:50 <wojtekM_>  
13:54:11 <Javran> ReinH: I don't know how to try actually, probably that it the second one from getOpt's return "([a], [String], [String])", but I have no idea what are non-options and what are error msgs
13:54:28 <wojtekM_> Any idea why CSize became so terribly inacceptable?
13:54:41 <wojtekM_> unacceptable
13:56:47 <Javran> ReinH: I think I can figure it out now...err msgs seems to be the error generated by getOpts by reading the source
13:57:00 <monochrom> intrados: to tell GHC to use less memory, perhaps (untested) --ghc-options="+RTS -M512M -RTS" (this caps the heap at 512MB)
13:58:58 <skypers> yeah, isn’t there a way to add to cabal ghci support for dist/package.inplace?
13:59:02 <skypers> like cabal ghci
13:59:15 <monochrom> is that called "cabal repl"?
13:59:26 <SLi> Hmm, PointedList might be what I need.
13:59:39 <skypers> monochrom: hm, repl is weird
13:59:48 <skypers> it breaks on a C-c
14:00:00 <SLi> Or Lenses?
14:11:35 <khyperia> aha, silasm, I just installed Syntastic for vim, it's exactly what I wanted.
14:12:33 <silasm> khyperia: whatever floats your boat. I found syntastic kind of annoying, but I'd probably like it if I took the time to configure it.
14:13:40 <silasm> won't deny it's nifty though.
14:13:49 <skypers> what is syntastic?
14:14:15 <khyperia> by my understanding, it runs hlint and something else when you save the file
14:14:16 <silasm> skypers: vim syntax-checker.
14:14:24 <khyperia> and it points out errors with nice squiggly red lines
14:14:43 <skypers> oh nice
14:14:48 <silasm> problem I had was the haskell version loves its style guidelines, and I didn't.
14:15:02 * hackagebot tempodb 0.2.1.0 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.1.0 (ParnellSpringmeyer)
14:15:03 <silasm> at least as far as defaults go. It'd probably be easy to change.
14:15:21 <silasm> I prefer to just jump in and out of ghci to check things though.
14:15:36 <skypers> yeah with :sh
14:15:46 <skypers> I have a noremap on C-d
14:15:49 <skypers> it’s just awesome
14:22:20 <donri> skypers: or you can just use the default C-z
14:22:54 <donri> and then fg to get back to vim
14:23:30 <FireFly> shell job control <3
14:23:49 <donri> :)
14:24:09 <skypers> donri: well, it’s not convenient
14:24:11 <FireFly> bg and jobs are also useful to know about
14:24:21 <skypers> with the C-d shortcut
14:24:28 <skypers> I just press C-d
14:24:32 <skypers> I’m in a shell
14:24:39 <skypers> I press C-d in the shell
14:24:44 <skypers> in vim back!
14:24:45 <jle`> how can i test out @pl on my own?
14:25:01 <FireFly> jle`: you can @pl in a query with lambdabot
14:25:14 <jle`> FireFly: thanks :)
14:25:34 <FireFly> ...or you could use the hackage package it's based on, but I've no clue how you'd do that
14:25:38 <FireFly> so I stick to querying lambdabot
14:25:42 <Clint> apt-get install lambdabot
14:26:22 <donri> skypers: sure but it'll be a new shell each time, which may or may not matter
14:27:26 <skypers> yeah I don’t actually care
14:27:31 <skypers> and hm
14:27:35 <skypers> it’s not really a new shell
14:27:41 <skypers> well yes it is
14:27:50 <skypers> but I still have history, and old printings
14:27:56 <skypers> it’s all I need
14:30:01 <donri> it matters for example if you :cd inside vim. :sh will launch a new shell in the CWD of the current vim window, and :suspend will go back to the shell that started vim
14:30:04 <donri> both are useful :)
14:30:10 <monochrom> haha http://spl.smugmug.com/Humor/Lambdacats/i-7QXhZMR/ "Cale cat"
14:31:03 <skypers> donri: oh I see
14:31:13 <skypers> I didn’t even know of :cd!
14:31:21 <donri> i thought uncidable instanzez was considered mostly harmless
14:31:35 <skypers> (it’s a WOAH !, not a regular ! vim symbol)
14:31:36 <donri> skypers: wait til you discover :lcd
14:32:03 <skypers> :o
14:32:07 <skypers> only for the current window
14:32:11 <skypers> that’s great
14:32:40 <monochrom> I agree they are harmless, but they are also XY solutions to many problems
14:33:11 <donri> yeah that's often the case with extenzonz
14:35:14 <monochrom> anyway, since it's a lambdacat post, we need not take it seriously :)
14:35:39 <donri> wat, lambdacat is super cereal!
14:40:52 <bearclaw> > let tuplemap2 f (x, y) = (f x, f y)   in  tuplemap2 reverse ([1, 2], ["foo", "bar"])
14:40:53 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
14:40:53 <lambdabot>    arising from the literal ...
14:42:02 <donri> bearclaw: https://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#impredicative-polymorphism ?
14:44:51 <donri> well probably not
14:44:57 <monochrom> no, just rank-n types instead, and n=2 suffices
14:45:17 <monochrom> but this means you have to hand-write a type sig
14:46:54 <monochrom> > let {tuplemap2 f (x, y) = (f x, f y); tuplemap2 :: (forall a. [a] -> [a]) -> ([t],[u]) -> ([t],[u])}   in  tuplemap2 reverse ([1, 2], ["foo", "bar"])
14:46:55 <lambdabot>   ([2,1],["bar","foo"])
14:47:08 <Peaker> tuplemap2 :: (forall a. a -> a) -> (b, c) -> (b, c)   <-- this won't work because "reverse" isn't that polymorphic.  If you use:  (forall a. [a] -> [a]) then your tuplemap2 is kinda lame/restricted
14:47:09 <FireFly> monochrom: those are great :D
14:47:24 <FireFly> http://spl.smugmug.com/Humor/Lambdacats/i-M22CXrF/A so apparently polymorphic cat uses Lens
14:48:27 <monochrom> heh
14:48:45 <quchen> "forall a. a -> a" makes it lame and unrestricted. Unrestricted to id. ;-)
14:49:13 <monochrom> that picture was before lens. the eye-glass there was just meant for high-class
14:49:37 <FireFly> monochrom: yeah, I realised
14:49:45 <FireFly> which makes it better yet
14:50:07 <monochrom> but who would have thought that "lens" would fit too!
14:50:13 <chrisdone> fun. i've got an fpco-mode.el. you (require 'fpco-mode) and then M-x fpco-mode and it enhances existing things. so e.g. auto-complete, flycheck, M-. (jumps to definition or says the lbirary module it was imported from), C-c C-t (now works on any region), and there's an additional hoogle command for which i haven't thought of a keybinding for yet
14:50:28 <Peaker> with Dependent Types, perhaps you can do something like:  tuplemap2 : {T : Bool -> *} -> ({P : Bool} -> T P -> T P) -> (T False, T True) -> (T False, T True)
14:55:06 * hackagebot MusicBrainz 0.2 - interface to MusicBrainz XML2 web service  http://hackage.haskell.org/package/MusicBrainz-0.2 (ClintAdams)
14:55:11 <FreeFull> :t let tupleMap2 f (x,y) = (f x, f y) in tupleMap2
14:55:11 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
14:55:26 <bearclaw> monochrom: interesting, so you can make it work by forcing a sig that is not the default
14:55:48 <donri> bearclaw: well it needs extensions, and will be limited to list operations
14:55:50 <bearclaw> but that sig is not realy more generic than the default one, it has a different constraint
14:56:07 <FreeFull> (forall a. a -> a) can only be satisfied by id and bottom
14:56:30 <bearclaw> ah yes, reverse would not fit in that...
14:58:00 <bearclaw> basically it means that you can't have a function that forwards a name without any more/less type constraints
14:58:25 <bearclaw> like how a set of overloads is not something that can be represented/manipulated in C++
15:00:05 <FreeFull> You could do   (a -> b -> (c,d)) -> (a,b) -> (c,d)
15:00:07 <volty> hi, anybody with qt? which package?
15:01:16 <simpson> :t uncurry
15:01:17 <lambdabot> (a -> b -> c) -> (a, b) -> c
15:06:34 <slack1256> As somebody without any prior experience studying data structures and wanting to know purely functional data structures
15:06:46 <slack1256> Should I read first a common book on data structures and the okasaki
15:06:56 <slack1256> or start with okasaki right away?
15:07:14 <chrisdone> oh, ja. this is awesome sauce. M-. even jumps to local definitions/bindings
15:07:40 <scriptor> slack1256: okasaki is probably too dense for someone with no data structures experience
15:08:29 <volty> just read slowly -- if too dense
15:09:27 <scriptor> ehhh
15:09:54 <slack1256> Mmm
15:10:41 <scriptor> slack1256: you can give okasaki a try now and see how far you get http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
15:11:12 <scriptor> if you find yourself confused and with a dozen wikipedia tabs open, I'd switch to a more intro textbook :)
15:11:32 <slack1256> I got okasaki's thesis. but probably will start with a intro textbook
15:11:44 <tomejaguar> Probably best to start with an intro textbook (which means non-functional, I think, unfortunately). Okasaki is really written for someone who already knows quite a lot about datastructures.
15:12:02 <bitemyapp> slack1256: Okasaki's work is a weird hybrid of strict and lazy semantics if I remember correctly...and the syntax is based on ML.
15:12:23 <sellout-> bitemyapp: But there are Haskell versions in an appendix.
15:12:38 <slack1256> bitemyapp: syntax isn't a problem :-)
15:12:49 <sellout-> slack1256: That too :)
15:15:47 <bitemyapp> sellout-: I didn't actually know that.
15:16:05 <bitemyapp> slack1256: I'm more concerned with the semantics, namely, non-strict/strict
15:16:51 <slack1256> yeah but okasaki argues that a language should support both with lazy/force keyword in order to get efficient performance
15:17:11 <slack1256> on inmutable data structures that is
15:17:27 <slack1256> funny how haskell fits better at that than modern ML
15:17:30 <silasm> bitemyapp: I found that refreshing (though I didn't get very far). I tend to get really used to the semantics of whatever language I'm using and never get a side-by-side compare and contrast of the two within the same framework.
15:17:43 <silasm> might distract from data structures a bit more than you want though.
15:19:21 <silasm> I think my problem was that I wanted to do the exercises in Idris and then I realized I can't write Idris and got distracted trying to learn Idris, and now I'm going through Software Foundations trying to understand tactics and such. I should probably go back to it.
15:19:42 <levi> Yak shaving, FP-style
15:19:48 <silasm> so I only got through ~4 chapters
15:20:14 <tomejaguar> slack1256: I basically came to the same conclusion as Okasaki: both laziness and strictness are very important and you need to support both well.  Personally I'd prefer a strict by default language with optional laziness but there's a *very big* caveat: to do laziness efficiently you need to put a *lot* of effort into your compiler.  Strict by default compilers have never done that.  Only GHC has done that, because they had to :)
15:20:20 <benmachine> lazy/force is all very well but if you have a "culturally" strict languge it doesn't really help
15:20:34 <silasm> it was neat when my professor had a lecture on amortized analysis and I was the only one who had any background on it, though.
15:20:53 <tomejaguar> benmachine: This is also true.  You need a nice way of making your programs polymorphic over strictness.
15:21:48 <Peaker> Use "Thunk" and "Identity" type constructors, and a Copointed class to "force" either
15:22:10 <tomejaguar> Peaker: Exactly :)
15:22:14 <benmachine> Peaker: sounds boilerplatey
15:22:25 <benmachine> I think there's a lot to be said for lazy-by-default
15:22:30 <tomejaguar> Peaker: Also 'data Delay x = Delay (() -> x)' would be nice.
15:22:33 <Peaker> benmachine: if so, sounds ilke an opportunity for language improvement :)
15:22:42 <Peaker> tomejaguar: that won't work in GHC Haskell :(
15:23:08 <Peaker> tomejaguar: http://stackoverflow.com/questions/6208006/any-way-to-create-the-unmemo-monad
15:23:38 <slack1256> thanks all, I will start reading an intro to algorithms/datastructures and the okasaki
15:23:39 <volty> setup: The program c2hs is required but it could not be found. // I just installed it with cabal, do I have to prepend ~/.cabal/bin in my PATH?
15:23:42 <slack1256> ciao
15:23:59 <monochrom> I think 'data Delay x = Delay (() -> x)' is meant for SML etc
15:24:15 <geekosaur> volty, yes
15:24:20 <volty> THX
15:24:33 <geekosaur> be warned that you can't safely use ~ there, use $HOME instead
15:24:45 <Peaker> right, my reaction made no sense :) Just knee-jerk reminded me of the issue I linked to :)
15:24:46 <geekosaur> (worse, it will work *for bash* but not for external programs)
15:25:07 <Peaker> monochrom: the ()->x in Haskell context was about preventing memoization -- and unfortunately does not work
15:25:37 <volty> geekosaur: i'll fix it in profile, later, thx
15:25:48 * monochrom has a cunning plan! make it Int->x then :)
15:26:05 <cizra> Hi fellow Haskellers. I'm trying to write a FFI wrapper to my C lib. Dealing with function bool foo(size_t len, char* raw_bytes). The Haskell types I'd use are CSize -> CString -> IO Bool. How do I pass arbitrary Haskell stuff in there? Work with Foreign.Ptr and Foreign.Storable?
15:26:17 * monochrom has an even more cunning plan! make it RealWorld#->x :)
15:26:37 <tomejaguar> Peaker: I'm talking about a hypothetical strict by default language.  But anyway, it is possible (at least in certain cases) if you turn off the full-laziness "optimization".  See the last post here: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/103616
15:26:53 <Peaker> tomejaguar: yeah, my answer made no sense there :)
15:29:15 <silasm> tomejaguar: isn't there a strict evaluation pragma in the making?
15:29:31 <monochrom> cizra: before answering your question, I am unconvinced that C bool maps to Haskell Bool. find out for real what C bool is.
15:29:34 <tomejaguar> silasm: Yeah but I don't believe in such things  :)  I believe in an explicit thunk type constructor.
15:30:05 <tomejaguar> Every type in Haskell is wrapped in an invisible thunk.
15:30:19 <tomejaguar> (That's all that laziness is, in fact, at least this implementation of it.)
15:30:28 <silasm> tomejaguar: hm, I can see it (no pun intended).
15:30:49 <Peaker> cizra: http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-StablePtr.html
15:31:11 <mkscrg> can anyone recommend a good trie implementation for Text or ByteString?
15:31:36 <cizra> monochrom: well, I lied. It's actually int, there's no bool in C.
15:31:57 <Peaker> cizra: if you want C to point at arbitrary Haskell values, the Haskell GC needs to know about it, so you need to newStablePtr, which you can then give to C as a (void *)
15:32:08 <Peaker> cizra: C99 has <stdbool.h> which defines the type "bool"
15:32:42 <Peaker> cizra: when you get the (void*) back from C as a StablePtr a, you can use derefStablePtr to get the "a", but you have to manually "freeStablePtr" to avoid a leak
15:33:23 <geekosaur> note however that in many (possibly all, if I recall C99 draft correctly) it's really an (int) and nothing actually checks that it's only true/false
15:33:36 <geekosaur> which is what monochrom was getting at
15:33:42 <geekosaur> (probably)
15:33:43 <Peaker> cizra: basically the API I linked to covers what you need to do to pass around Haskell objects to C and back, assuming the C side needs to persist them. If they only persist across a single C call, then I think it may be enough to do simpler things
15:33:58 <Peaker> geekosaur: it's not -- if you use: bool x = 5; x == 1
15:34:33 <tomejaguar> What does == return?
15:34:39 <cizra> Peaker: Uh, I need a char*, not a void*, because I'll be writing it into a file later on.
15:34:41 <Peaker> true
15:34:51 <tomejaguar> true?  Or 1?
15:34:56 <Peaker> bool x = 5; printf("%d", x);  -->  prints 1
15:35:04 <hpc> tomejaguar: yes
15:35:08 <tomejaguar> lol
15:35:16 <tomejaguar> But what's the type of the return of ==?
15:35:22 <Peaker> oh, I think it's int :)
15:35:31 <volty> there's no type
15:35:45 <geekosaur> consistency, C style
15:35:52 <monochrom> I am unconvinced that StablePtr is relevant. sure, "unaffected by GC" etc. but also *unusable on the C side*. I think clearly cizra wants to transfer data from Haskell to C and have it *usable* on the C side.
15:36:03 <volty> either 0 (false) or yes ( != 0)
15:36:04 <Peaker> sizeof (bool) == 1, sizeof (x==5) == 4
15:36:21 <tomejaguar> ??? f() { return true == false } # <-- what type do I have to replace ??? with to get this to compile?
15:36:31 * monochrom is always an unconvinced skeptic
15:36:44 <tomejaguar> A wise default position.
15:36:48 <Peaker> monochrom: perhaps, when I wanted something similar, it was for persisting the Haskell ptrs in the C side
15:36:50 <simpson> This is C? C99 has a bool type IIRC.
15:36:59 <cizra> Peaker: Reading the doc of StablePtr, it seems that it's completely unusable for my purposes.
15:37:13 <Peaker> cizra: does your C code persist ptrs to the Haskell side?
15:37:28 <Peaker> cizra: what kind of use does your C code make of the arbitrary Haskell objects?
15:37:49 <monochrom> God, what Haskell objects?
15:38:13 <Peaker> s/objects/parameters
15:38:22 <Peaker> Why are you bringing God into this? :)
15:38:34 <monochrom> the Haskell side have 5 bytes. they are 0x34, 0xfe, 0x88, 0x33, 0x77, in that order. give them to C side.
15:38:41 <merijn> simpson: It has a bool typedef, I don't think it's specified what it is
15:38:55 <Peaker> oh, I missed the comment about the char*
15:39:22 <Peaker> cizra: so you want to pass a ByteString to C?
15:40:51 <cizra> Peaker: My C code basically fwrites the stuff to disk, from Haskell side, then reads it up again.
15:41:05 <cizra> Peaker: I want to be able to cast an arbitrary Haskell object into a char*, store and reread.
15:41:20 <cizra> Peaker: The pointer needs not remain the same, though.
15:41:28 <cizra> Peaker: Sounds like I want a Storable.
15:41:38 <Peaker> cizra: Either Storable, or Data.Binary
15:41:56 <Peaker> cizra: why do you need the C side to write it to disk, btw, rather than Haskell?
15:43:28 <cizra> Peaker: I'd prefer to keep the code in C for reuse across other systems, it's a tad tricky.
15:44:07 <Peaker> cizra: sorry about the unrelated suggestions, I had incorrectly guessed you were trying to do something else and then missed your comment about the (char *)
15:47:52 <cizra> Peaker: No problemo, thanks for the suggestions.
15:55:03 <lpaste> monochrom pasted “send storable to C” at http://lpaste.net/96207
15:55:14 <monochrom> cizra: http://lpaste.net/96207
15:57:40 <Peaker> monochrom: Bool is a boxed type, isn't it?
15:58:08 <hpc> Peaker: Bool is pure haskell
15:58:29 <Peaker> yeah, so I am not sure it's safe to assume it is compatible with a C int
15:58:32 <seanparsons> Is there any sensible reason why "cabal repl" would just print "Preprocessing library X..." and then exit?
15:58:35 <hpc> data Bool = TRUE | FALSE | FILE_NOT_FOUND
15:59:22 <Peaker> In Python, I can do: s = socket() ; s.connect(("foo", "bar")) ; s.send("foo").    In Haskell, currently, I have to install network-simple if I want a connect to be as simple as that. I have to install network-bytestring if I want to have sensible bytestring senders rather than String :(
15:59:25 <hpc> i write all my haskell variables in all-caps because they are constants
16:00:07 <dcoutts_> seanparsons: someone else had that issue before, I'm trying to remember what the issue was
16:00:32 <seanparsons> If I use "-v" in there the last mesage is "Linking...".
16:01:14 <joelteon> In Haskell, I can use monads. In Python, I cant :(
16:01:42 <seanparsons> Peaker: There's a much smaller base library in Haskell, which means that more of those things are up to you.
16:02:01 <dcoutts_> seanparsons: paste the .cabal file somewhere, it might help my memory if I have a look
16:02:09 <Peaker> joelteon: of course, I prefer Haskell, I am just complaining that Python's prelude/libs makes some simple/repl-ish things much easier than Haskell's current ecosystem
16:02:37 <hpc> Peaker: what are foo, bar in your example?
16:02:54 <seanparsons> dcoutts_: https://gist.github.com/seanparsons/e33c8420c100d36aeed3
16:02:55 <Peaker> hpc: foo is an address, bar is a port number, I think "bar" should be an int
16:02:55 <hpc> ip/port?
16:03:06 <Peaker> (though a string as a service name probably works too)
16:03:35 <Peaker> but I see that "network" does have a ByteString API in a separate module. Better than installing a separate package, so maybe not as bad as I now thought
16:03:56 <Peaker> but still the overhead for the most basic connect-send thing is larger
16:04:00 <dcoutts_> seanparsons: and can I see the log with -v
16:04:14 <hpc> Peaker: http://hackage.haskell.org/package/network-2.4.2.0/docs/Network.html#v:connectTo
16:04:35 <hpc> s <- connectTo "foo" bar; hPutStr "foo"
16:04:38 <monochrom> Peaker: compiler is required to generate code to convert between Bool and int. boxing if necessary. forcing and unbox if necessary.
16:04:51 <seanparsons> dcoutts_: Gist updated.
16:04:58 <hpc> comes in vanilla, bytestring, and texty crunch!
16:05:00 <dcoutts_> ta
16:05:21 <Peaker> monochrom: ah, didn't think FFI declarations did that kind of thing
16:05:37 <hpc> er, hPutStr s "foo"
16:05:43 * hpc is sleepy
16:05:58 <monochrom> it is really not so much different from Double vs double.
16:08:05 <dcoutts_> seanparsons: ahh! yes, it's because you have no modules in your lib, so it just gets skipped
16:08:15 <dcoutts_> seanparsons: not that that's sensible, it ought to error out
16:10:37 <seanparsons> Yeah.
16:10:45 <seanparsons> Curses.
16:12:04 <seanparsons> dcoutts_: That's it, thanks for helping, I'd have likely been spinning my wheels on that for ages.
16:12:21 <dcoutts_> seanparsons: btw, what happens if you do build rather than repl when there are no modules?
16:12:32 <seanparsons> It was building it fine.
16:13:24 <dcoutts_> seanparsons: mm, what was it actually doing when it "built" given there were no modules?
16:13:32 <dcoutts_> seanparsons: just making a lib with no modules I guess?
16:14:07 <seanparsons> Although I _think_ that's why I found I needed hs-source-dirs in there.
16:14:07 <seanparsons> This all makes a lot more sense.
16:14:07 <jrmithdobbs> This is fun. I'm looking at reimplementing a ruby project in haskell as an exercise and I'm looking through it's unit tests .... 95% of which can be completely omitted thanks to the type system.
16:14:12 <hpc> jrmithdobbs: welcome to the best kept secret in programming
16:14:26 <jrmithdobbs> Things like 'it "does not change nil into a string" do'
16:14:28 <jle`> accidentally sanbox installed cabal-install heh.
16:14:33 <jle`> is there a way to cancel installations?
16:14:46 <hpc> jrmithdobbs: ctrl+c
16:14:51 <jle`> ctrl+c is safe?
16:14:57 <hpc> sandboxing cabal-install isn't too bad though
16:14:57 <jle`> i guess it's a sandbox
16:14:59 <hpc> it's a binary
16:15:19 <hpc> you can always copy it onto $PATH
16:15:22 <seanparsons> dcoutts_: Yeah, it was compiling it and that's it as far as I can tell, because I've got profiling on it didn't even bother doing that.
16:16:34 <tomejaguar> jrmithdobbs: You should write to FP Complete with that.  They're keen on presenting Haskell to Rubyists.
16:16:41 <jrmithdobbs> hpc: More fun? I can actually just use aeson for most of the types directly since it's just mangling json data!
16:18:03 <jrmithdobbs> tomejaguar: Really? Because I've seen very very little docs/posts from the perspective of someone familiar with ruby...
16:18:36 <jle`> jrmithdobbs: i also came from a ruby background and i have experienced the magic that you have.
16:18:39 <jle`> it is a wonderful feeling.
16:19:00 <jle`> i was making a web app once and changed a field on my database to be nullable
16:19:12 <jle`> immediately the compiler told me all of the places in my code where that would cause a problem
16:19:23 <jle`> whereas in ruby...i  might only find out in production
16:20:03 <jle`> or worse i'd have to change half of my unit tests
16:21:56 <tomejaguar> jrmithdobbs: Well there was this: http://www.reddit.com/r/haskell/comments/1pv6ua/fp_complete_is_hiring_a_ruby_expert_haskeller/
16:22:13 <jrmithdobbs> tomejaguar: Which I've found extremely odd seeing as if you use modules to extend functional functionality in ruby the languages use some very similar (in application if not exact theory) constructs ... Proc -> Applicative (and sometimes monad or only functor but e/e), enumerable -> enum, etc etc
16:22:38 <jrmithdobbs> w/e not e/e
16:24:01 <jrmithdobbs> I have some lots of lis processing ruby code that almost becomes valid idiomatic haskell just by s/[.]/ . / ... Ha
16:26:11 <jrmithdobbs> tomejaguar: Interesting post that
16:26:49 <jrmithdobbs> tomejaguar: At least I'm not the only person having these thoughts. Ha.
16:31:50 <jrmithdobbs> I don't see the mystery though. Present haskell to ruby users like this: you can only implement "object" "instance" methods inside type classes (aka modules). Ignore monads and show how proc ~= functor/applicative and use that + yesod to introduce monads
16:32:33 <bitemyapp> jrmithdobbs: do not use Yesod for pedagogy.
16:32:47 <bitemyapp> oh my god there is way too much magic in Yesod for anything to be understandable to a noobie.
16:33:01 <bitemyapp> Scotty would be much more appropriate, the router is even a nice introduction to a simple Monoid.
16:33:38 <jrmithdobbs> bitemyapp: I disagree. Anyone that actually understands rack and rails can understand yesod and the complexity is desirable.
16:34:06 <jrmithdobbs> If what your after is actual comprehension, anyways
16:34:19 <bitemyapp> "the complexity is desirable" that is perverse.
16:34:38 <bitemyapp> maybe Rubyists would be the type to enjoy an "opposites day" anyway.
16:35:21 <acowley> Using Yesod early on in Haskell education sounds pretty risky
16:35:26 <sipa> when trying to learn, the right degree of complexity is certainly desirable
16:35:33 <bitemyapp> acowley: incredibly.
16:35:43 <acowley> But Yesod is new, much of its complexity is accidental
16:35:46 <monochrom> I do not understand why explain how to do Ruby OOP in Haskell. if they want to do Ruby OOP, they should use Ruby.
16:35:49 <acowley> Half the point in learning Haskell is to avoid that
16:35:54 <acowley> monochrom++
16:35:59 <bitemyapp> sipa: you don't want it to be boring, but I have a hard time imagining a worse candidate for teaching Haskell than Yesod.
16:36:05 <bitemyapp> Yesod is Haskell like Jesuits are Catholic.
16:36:11 <stepkut> :)
16:36:18 <sipa> bitemyapp: ok, i don't know Yesod actually :)
16:36:21 <jrmithdobbs> acowley: New? It's 3 yearsish I thought
16:36:54 <monochrom> I also make a distinction between complexity and complication.
16:36:59 <bitemyapp> sipa: I came to Haskell initially seeking an alternative web stack language and I do a lot web stuff in Python, Haskell, Clojure, and Ruby. Yesod is a horror taken to its natural conclusion by people too-smart-by-half.
16:37:00 <acowley> So a 3 year old domain specific library is how to introduce a nearly 30 year old language?
16:37:10 <jrmithdobbs> monochrom: I'm not saying teach oop in haskell I'm saying use it as an analogy
16:37:22 <bitemyapp> "OOP in Haskell" is the other problem
16:37:29 <bitemyapp> they should learn better, more idiomatic ways of expressing themselves
16:37:36 <bitemyapp> not how to write Ruby in Haskell. or Fortran in Haskell.
16:37:37 <monochrom> my "complexity": you put together a few simple things or rules, you get very interesting results, perhaps emergent results.
16:38:08 <bitemyapp> complexity is braiding together of behavior.
16:38:11 <monochrom> my "complication": you keep patching and patching. you build a bureacracy.
16:38:21 <bitemyapp> that can lead to emergent results, or something that's just hard to change without rippling the change outward.
16:38:38 <bitemyapp> functions are simple. they take arguments, return results, end of story.
16:38:56 <bitemyapp> building things out of functions that adhere to this simplicity will themselves, generally, be simple too.
16:39:21 <bitemyapp> Mimicking the bad ideas of poorly thought-out (or not at all) languages in Haskell is a good way to lose the point of learning Haskell
16:40:56 <acowley> Of course, there is controversy in terms everywhere: https://twitter.com/awelonblue/status/405039423756058624
16:41:19 <jrmithdobbs> Yes well, continue being dogmatic vs pragmatic and talking down to your audience instead of understanding that a large majority of them actually already understand most of the concepts used widely in your language of choice ....
16:41:43 <jrmithdobbs> How's that been working for ~30 years btw? ;p
16:43:32 <jrmithdobbs> I think rails :: yesod is a fair comparison and anyone that can understand the inner workings of one can the other ... Neither are magic
16:43:41 <monochrom> I am unconvinced that Haskell people and tutorials have been dogmatic.
16:43:59 <bitemyapp> jrmithdobbs: writing in Ruby in Haskell is a good way to convince people Haskell is terrible.
16:44:20 <bitemyapp> jrmithdobbs: do you put ketchup in your spaghetti? Would you be surprised if somebody told you to stop telling people to try ketchup on their spaghetti?
16:44:21 <quchen> monochrom: Euphoric at times, maybe
16:44:38 <jmcarthur_mobile> A big reason people find that Haskell expands their minds more than other languages do is that attempts to just pretend it's all those languages you know already don't work out.
16:44:59 <bobcrash_> If I build a binary with "ghc -threaded", will the runtime allow one of my threads (forkIO) to call into one native library while a different thread is calling into a different native library?
16:45:03 <jrmithdobbs> bitemyapp: What are you talking about? Yesod isnt ruby in haskell
16:45:07 <monochrom> but to answer your question, Haskell pedagogy has been working great, it has successfully repelled ill designs of the dailywtf calibre.
16:45:13 <bitemyapp> jrmithdobbs: that's not what I said...
16:45:27 <quchen> bobcrash_: "native library"?
16:46:00 <bobcrash_> quchen: FFI to C.   Wrong terminology?
16:46:02 <jrmithdobbs> monochrom: I was referring to his attitude specifically not every haskell doc ever...
16:46:26 <quchen> bobcrash_: Ah, that. In that case I don't have answers, never used FFI+parallelism :-/
16:46:56 <bobcrash_> quchen.  Gotcha.  Basically I have a GTK app, with a separate thread reading USB data... but it seems to be locking up my UI in-between USB reads (while USB blocks?)
16:47:00 <acowley> bobcrash_: A "safe" FFI call might block all threads, I don't recall
16:48:04 <jrmithdobbs> bitemyapp: Then whats at issue? I said i was reimplementing a ruby codebase in haskell someone pointed out a reddit post about fpcimplete asking how to present haskell to ruby developers ... I gave some example analogies and two similarly targeted software stacks to compare ...
16:48:34 <quchen> bobcrash_: When you said "native library" I wasn't sure whether you were simply referring to a precompiled Haskell library and I would have told you how you can code in parallel even without threaded etc.
16:48:45 <monochrom> I would simply omit "to ruby developers". it doesn't really matter.
16:48:46 <quchen> FFI is the catchword here I guess.
16:48:56 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml
16:48:58 <Tekmo> monochrom: By ruby developers do you mean rails developers specifically?
16:49:00 <bobcrash_> quchen: Ah, I completely see how that was ambiguous.  Yeah, I meant FFI
16:49:08 <Tekmo> Oops
16:49:13 <acowley> bobcrash_: I'd read this http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ffi-ghc.html#ffi-threads
16:49:13 <Tekmo> That wasn't intended for monochrom
16:49:25 <monochrom> no. simplify "present Haskell to ___" to "present Haskell". period.
16:49:30 <bobcrash_> acowley: Thanks, will check it out
16:49:48 <monochrom> my http://www.vex.net/~trebla/haskell/prerequisite.xhtml is how I would begin.
16:49:53 <Tekmo> Well, you do have to change your presentation style if they have previous experience
16:50:01 <bobcrash_> I think the only way you can truly understand Haskell is to think of it as a simpler Visual Basic 6 (the language it was inspired from and derived most of its theory from).  Its basically VB6, except much simpler because it doesn't have a built in GUI making it less powerful
16:50:07 <Tekmo> For example, teaching to a previous Python programmer is different than teaching to a previous Java programmer
16:50:10 <quchen> Tekmo: By mentioning to forget everything in the introduction? :-s
16:50:34 <monochrom> style? or is it content?
16:50:43 <Tekmo> Content
16:51:00 <Tekmo> For example, Python programmers need much more time on types
16:51:14 <Tekmo> Java programmers need more time on type classes and category-theory design patterns (i.e. Functor/Monad)
16:51:34 <quchen> … compared to Python people?
16:52:02 <quchen> That sounds odd. Those concepts are alien to all other big languages after all.
16:52:07 <Tekmo> Yes, because they usually tend to open with "How do I architect my application?" which requires beginning with that
16:52:12 <jmcarthur_mobile> Ugh I have no idea if anything in saying is making it in
16:52:13 <jmcarthur_mobile> *I'm
16:52:24 <Peaker> Calling them CT design patterns might scare people away unnecessarily :)  Functor/Monad in Haskell are very restricted/narrow compared to the actual CT notions anyway
16:52:25 <jrmithdobbs> quchen: Ruby has functors/applicative
16:52:30 <Tekmo> I don't actually call them that
16:52:40 <jrmithdobbs> quchen: So no. They are not. Python has similar
16:52:50 <Tekmo> I just tell them it's "Haskell design patterns"
16:52:58 <monochrom> I agree about adjusting ratios according to the audience. I disagree about the dichotomy of the audience by "uses/not python", "uses/not java".
16:53:05 <Peaker> But since they're captured by libraries, they're no longer patterns, yay
16:53:08 <Tekmo> It was an extreme example
16:53:12 <Peaker> "Design patterns are bug reports against your language"
16:53:17 <Tekmo> I don't believe the dichotomy is that stark
16:53:57 <Tekmo> You just have to speak their language
16:54:05 <Tekmo> Contextualize it in terms of what they already know
16:54:19 <jrmithdobbs> Exactly
16:54:25 <monochrom> I speak their language. English, math, and logic.
16:54:26 <quchen> "Type classes are like interfaces" and die a little inside
16:54:49 <monochrom> change English to Chinese if necessary. I can do that too.
16:54:57 <jrmithdobbs> Why? It's true
16:55:17 <Tekmo> quchen: I just link them to this: http://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes
16:56:15 <mangaba_leitosa> monochrom: It's surprising how pythons is becoming "default". I'm taking two coursera courses now, automata by Ullman and bioinformatics. The first one has python OR java for programming assignments, the second one says "you can use any language of your choice, but we recommend python" :-)
16:56:23 <jmcarthur_mobile> I've tried to say this twice now. It's at the point that I'm no longer sure it's worth trying, but I will give one more shot. Teaching of the form "It's like X, except for A, B, C, D,..." tends to confuse in the long run as much as it may appear to help in the short run. One of is finally recognized as too misleading, the learner has to unwind his stack write far. "Like X" was the first thing learned, and it was wrong.
16:56:46 <jmcarthur_mobile> *once it is finally
16:57:03 <monochrom> "except for A, B, C, D, ..., W" characterizes PHP
16:57:08 <jmcarthur_mobile> *stack very far
16:57:09 <jrmithdobbs> quchen: They're more like ruby modules than java interfaces but they're all used to accomplish similar things. What's wrong with saying that?
16:58:33 <Tekmo> For me, I came to Haskell from a C/Java background, so the analogy to interfaces helped me immensely
16:58:50 <monochrom> I agree about speaking their language. their language is a natural language, plus simple math, logic, computer science. for example common data structures. for example knowing about mutable and immutable. the language is not python or java or pascal.
16:59:19 <Tekmo> Many people do not speak the language of math/logic/computer science
16:59:30 <Tekmo> I know I didn't when I first started
16:59:41 <monochrom> then I can teach them those first
16:59:51 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml for the 3rd time
17:00:09 <zomg> Yeah Haskell technobabble is an issue for those not coming from a math/cs background :P
17:00:13 <jmcarthur_mobile> I honestly found the dictionary implementation more helpful than anything.
17:00:32 <quchen> For me I came from a background and forgetting about that helped me immensely. I guess everyone has his own story there.
17:01:09 <Tekmo> The way I always learn things best is code examples.  You can talk about math until you are blue in the face, but if you show me a functional piece of code I get it immediately
17:01:31 <zomg> For example I'm sure someone explained homomorphism and who knows what fancy Haskell-words to me before on this channel
17:01:43 <zomg> But I still can't remember what those mean...
17:01:43 <zomg> :D
17:01:55 <quchen> Homomorphism isn't even a Haskell word.
17:01:59 <bitemyapp> monochrom: that's not quite enough.
17:01:59 <zomg> Probably not :D
17:02:07 <zomg> But I've only heard it used in context of Haskell
17:02:15 <bitemyapp> monochrom: a principled explanation of functors would help.
17:02:15 <acowley> Tekmo: I don't think that's in dispute here. The question is more of how you select those examples.
17:02:50 <monochrom> Tekmo, nothing says I will not be showing actual code early
17:03:02 <quchen> zomg: Probably in the context of looking at Haskell from a category theory angle. Which is pretty far from standard Haskell.
17:03:13 <zomg> I can pretty much understand anything in programming terms but not math-speak
17:03:25 <zomg> but I go to look at some Haskell stuff and am like "whooaaa nevermind..."
17:03:27 <zomg> =)
17:03:35 <scott_> Math is a powerful tool for looking at programming, though
17:03:37 <zomg> of course it's not always like that, but occasionally there's this technobabble-heavy thing
17:03:43 <acowley> A great thing about Haskell is that it turns that around, zomg
17:04:00 <bitemyapp> there should be a new library prefix called "wow-"
17:04:01 <Tekmo> scott_: I prefer it the other way around: programming is a powerful way to think about math (if it is in Haskell)
17:04:08 <bitemyapp> all libraries in the prefix are written with shibe-speak
17:04:09 <scott_> Tekmo: I agree
17:04:13 <Tekmo> scott_: :)
17:04:20 <zomg> bitemyapp: lol
17:04:20 <bitemyapp> "wow. so homomorphism. such category theory. wow. many type"
17:04:24 <Tekmo> lol
17:04:35 <jmcarthur_mobile> Ha
17:04:38 <monochrom> in fact, "f x = x+x" is actual code. "deduce f 5 = 5+5" is simultaneously actual execution and math.
17:05:07 <Tekmo> Yeah, I love how I can interpret things by simple substitution
17:05:11 <monochrom> so please don't treat me like my math is abstract nonsense.
17:05:17 <quchen> Problem is that for most people math is the 5+5 part.
17:05:45 <zomg> That's what I always was taught in school!
17:06:10 <monochrom> please, like read my http://www.vex.net/~trebla/haskell/prerequisite.xhtml for the 4th time
17:06:21 <quchen> In English class I learned English. In history I learned about history. In math I learned to calculate.
17:06:21 <Tekmo> monochrom: I read it already
17:06:23 <zomg> I think I might've learned derivation and integration... possibly the most advanced thing we touched
17:06:31 <zomg> and I can remember NOTHING about it
17:06:32 <zomg> :D
17:06:38 <monochrom> ok, then good. read it every day.
17:06:44 <Tekmo> monochrom: :)
17:06:57 <quchen> I don't think that article is very constructive to be honest.
17:07:01 <Tekmo> I understand the benefit of reasoning equationally in Haskell
17:07:06 <Tekmo> I do it all the time
17:07:12 <jmcarthur_mobile> zomg: those things are much more complicated than your typical applied category theory though
17:07:17 <quchen> Tekmo: proofs.md :-D
17:07:21 <Tekmo> quchen: :)
17:07:27 <Tekmo> I have more proofs incoming.  Be prepared!
17:07:31 <zomg> jmcarthur_mobile: you lost me at typical applied category theory
17:07:32 <zomg> =)
17:07:48 <quchen> Tekmo: Are the Agda plans I imagine you mentioning at some point realistic?
17:07:50 <chrisdone> monochrom: i read my SICP and my trebla prerequisites every night before bed
17:07:53 <jmcarthur_mobile> That's the attitude that builds walls ;)
17:07:58 <Tekmo> quchen: Paolo got the Agda stuff working for unidirectional pipes
17:08:01 <jrmithdobbs> monochrom: I think there is quite a bit more than that necessary to be able to do simple things and actually understand what is going on in haskell ... I'd say that's oversimplification and almost dishonest
17:08:01 <Tekmo> quchen: Let me paste it
17:08:16 <zomg> jmcarthur_mobile: no that's the attitude of not having any idea what people are speaking about... :D
17:08:31 <quchen> Tekmo: I can't read Agda anyway :-/
17:08:43 <jmcarthur_mobile> zomg: a positive reaction to words you don't know is to Google it!
17:08:57 <chrisdone> quchen: s'all greek to me
17:09:14 <jrmithdobbs> monochrom: Tell me how http-conduit works in terms of only whats on that page, eg
17:09:16 <quchen> Tekmo: I was just wondering whether that was just something you'd like to have or whether it was actually realistic
17:09:17 <jmcarthur_mobile> zomg: admittedly Google doesn't always help
17:09:23 <zomg> jmcarthur_mobile: I google category theory and I'm presented by math hieroglyphs
17:09:30 <jmcarthur_mobile> zomg: but that's what #haskell is for ;)
17:09:49 <quchen>  /topic hieroglyphs decoded here
17:09:54 <monochrom> jrmithdobbs: I agree to disagree
17:10:04 <monochrom> bitemyapp: I agree to disagree
17:10:06 <zomg> I think the big one that looks like E is sum
17:10:11 <bitemyapp> monochrom: what?
17:10:13 <zomg> That's how much I know about math hieroglyphs
17:10:13 <zomg> :D
17:10:23 <quchen> I think monochrom just pushed the eject button
17:10:28 <monochrom> I disagree that I have to add functors there.
17:10:28 <Tekmo> quchen: It's sort of a "nice to have" thing
17:10:50 <quchen> Tekmo: Out of curiosity, how did you create pipes.md?
17:10:52 <quchen> Pen and paper?
17:10:52 <monochrom> and I am too proud to explain why. so good night.
17:10:58 <quchen> Or was it automated
17:11:07 <Tekmo> quchen: You mean the laws?
17:11:10 <quchen> Yeah
17:11:13 <Tekmo> quchen: I did it by hand
17:11:13 <jrmithdobbs> monochrom: So you can tell me how http-conduit works using only concepts on that page? Because that functionality is one of the first things any new user is going to go looking for.
17:11:14 <quchen> I mean the file is pretty long
17:11:19 <quchen> Wow
17:11:54 <quchen> Maybe you'll get a bonus PhD in addition to your DNA sequencing thing.
17:11:58 <Tekmo> lol
17:12:01 <quchen> (What's the area of research for that anyway?)
17:12:05 <monochrom> no, I cannot, and this does not imply that I am wrong.
17:12:07 <quchen> Biophysics?
17:12:19 <Tekmo> My degree is in biophysics.  My area of research is technically structural bioinformatics
17:12:20 <chrisdone> monochrom: that's so monotarian
17:12:24 <Tekmo> Also, I just passed my defense today!
17:12:28 <quchen> New users look for http-conduit functionality? Don't be ridiculous.
17:12:35 <quchen> Tekmo: Wooo! (I hope)
17:12:39 <chrisdone> Tekmo: yay \o/
17:12:42 <Tekmo> Thanks! :)
17:13:05 <monochrom> using only concepts on that page, one can begin learning Haskell. after learning a good portion of Haskell, one is ready to tackle http-conduit.
17:13:43 <monochrom> my article is on prerequisites for beginning to learning haskell, not for beginning to learn http-conduit.
17:13:53 <Tekmo> Well, I think one shouldn't pretend Haskell is super easy to learn, just not more difficult than learning any other language from scratch
17:14:06 <bitemyapp> is http-conduit a benchmark for something that is hard to understand?
17:14:19 <Tekmo> I'd say lens is the benchmark for that
17:14:43 <Tekmo> Don't get me wrong.  I absolutely love lens so much
17:14:47 <Tekmo> Most brilliant library ever
17:16:25 <quchen> Meta-theorizing about languages is pretty boring. :-(
17:16:53 <monochrom> I have not learned http-conduit. perhaps it's supereasy. I don't know.
17:17:09 <merijn_> I thought http-conduit was fairly easy
17:17:22 <chrisdone> it's pretty straight-forward
17:17:22 <quchen> http-conduit is entirely besides the point here.
17:17:34 <monochrom> as it is, clearly I cannot explain http-conduit to you now, regardless of your background, because I lack the background
17:17:55 <monochrom> but I can explain fix to you now
17:18:10 <bitemyapp> Tekmo: is lens that hard to understand, or merely big?
17:18:12 <chrisdone> i'd've preferred to've had http-conduit than curl/HTTP when starting haskell
17:18:27 <acowley> bitemyapp: Have you tried looking at the code?
17:18:32 <jrmithdobbs> bitemyapp: No it's a benchmark for something fairly easy to understand.
17:18:38 <Tekmo> bitemyapp: So `lens-family` is really easy to understand
17:18:38 <monochrom> but I guess "new users" aren't as interested in fix as in http libs and xml libs
17:18:39 <bitemyapp> acowley: I'm looking at Control.Lens.Fold right now.
17:18:44 <Tekmo> bitemyapp: `lens` is not because it is more general
17:18:46 <chrisdone> the curl api just assumes you know curl, and HTTP is a toy
17:18:54 * mangaba_leitosa is still a beginner in haskell and is now using haskell for solving the programming assignments of coursera/bioinformatics, very hard tasks taking > 20 hours/week, and is finding that writing algorithms in haskell is easy, but optimizing them or trying to predict how an attempt of a certain optimization will affect performance is nearly impossible 
17:18:59 <bitemyapp> Tekmo: I'm looking at `lens`
17:19:03 <merijn_> bitemyapp: Lens is both big and insanely generic, the generic bit makes things tricky
17:19:16 <Tekmo> bitemyapp: For example, try to figure out how `zoom` works on the `StateT` mond
17:19:25 <bitemyapp> Tekmo: yay, assignment. Will do.
17:19:47 <chrisdone> it's hard to understand what lens functions do without the haddocks, that much is true
17:19:52 <chrisdone> :t _1
17:19:53 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
17:19:59 <Tekmo> I mean figuring out how the internal implementation works
17:20:21 <Tekmo> Yeah, and the types are really bad for inference, too
17:20:25 <jrmithdobbs> Tekmo: What is lens for?
17:20:31 <merijn_> edwardk: I guess the Wolfram bit is mathematica, where does the "Hart" language come from?
17:20:33 <chrisdone> the _1 lens is grokkable, but from just the type i wouldn't so easily figure it out
17:20:51 <Tekmo> jrmithdobbs: A lot of things, but the core functionality is making it easy to get/set nested fields of complex types
17:21:06 <bitemyapp> jrmithdobbs: you don't know what lens is for but you're telling other people how to learn Haskell?
17:21:58 <merijn_> bitemyapp: Lens is fairly new
17:22:12 <Tekmo> Does lambda bot have lens installed?
17:22:14 <chrisdone> Tekmo: nod. in the case that a lens becomes monodirectional, that's a pity. whole point of lenses is to be bidirectional, but the breadth of generality the library is trying to do seems to stretch the type system
17:22:14 <merijn_> bitemyapp: The actual lens library I think is less than a year old?
17:22:17 <Tekmo> > :t set
17:22:18 <lambdabot>   <hint>:1:1: parse error on input `:'
17:22:19 <Tekmo> :t set
17:22:20 <lambdabot> ASetter s t a b -> b -> s -> t
17:22:20 <monochrom> yes, lambdabot has lens
17:22:30 <Tekmo> Okay, so let's start simple
17:22:34 <merijn_> bitemyapp: It's not inconceivable for someone to be comfortable with haskell and not up to date with lens
17:22:36 <Tekmo> > set _1 'C' (1, 2)
17:22:38 <lambdabot>   ('C',2)
17:22:53 <Tekmo> > set (_1._1) 'C'  ((1, 2), 3)
17:22:54 <lambdabot>   (('C',2),3)
17:22:55 <acowley> merijn_: This came from an argument about using yesod to teach Haskell
17:23:00 <Tekmo> set both 'C' (1, 2)
17:23:03 <Tekmo> > set both 'C' (1, 2)
17:23:04 <lambdabot>   ('C','C')
17:23:16 <Tekmo> set (_1.both) 'C' ((1, 2), 3)
17:23:19 <Tekmo> > set (_1.both) 'C' ((1, 2), 3)
17:23:20 <lambdabot>   (('C','C'),3)
17:23:35 <Tekmo> sumOf traversed [1..3]
17:23:36 <Tekmo> > sumOf traversed [1..3]
17:23:38 <lambdabot>   6
17:23:41 <Tekmo> > sumOf both (1, 2)
17:23:42 <lambdabot>   3
17:23:59 <chrisdone> merijn_: unless you're following the community, you won't have heard of lens. i hadn't, i know haskeller friends who haven't. it was only when i 'came back' i was like 'huh? this is a thing now?'
17:24:00 <Tekmo> sumOf (traversed.traversed) [[1, 2], [3, 4]]
17:24:02 <Tekmo> > sumOf (traversed.traversed) [[1, 2], [3, 4]]
17:24:03 <lambdabot>   10
17:24:16 <jrmithdobbs> Tekmo: Nifty
17:24:21 <acowley> chrisdone: That must have been fun
17:24:47 <Tekmo> > set 'C' (traversed.traversed.taking 3) [[1, 2], [3, 4]]
17:24:48 <lambdabot>   Couldn't match type `GHC.Types.Char'
17:24:48 <lambdabot>                with `(a0
17:24:48 <lambdabot>              ...
17:24:52 <Tekmo> Oh yeah
17:24:56 <Tekmo> > set 1 (traversed.traversed.taking 3) [[1, 2], [3, 4]]
17:24:58 <lambdabot>   Could not deduce (Control.Lens.Internal.Indexed.Conjoined p0)
17:24:58 <lambdabot>    arising fr...
17:25:01 <Tekmo> See
17:25:03 <Tekmo> That's the problem
17:25:05 <quchen> chrisdone: All of a sudden: lenses, comonads, free monads - everywhere!
17:25:14 <Tekmo> Really inscrutable types/type errors/type inference
17:25:15 <merijn_> chrisdone: Exactly, I know the gist of lens, but I'm far from a lens acolyte :p
17:25:26 <spaceships> haskell: free as in monads
17:25:29 <bitemyapp> chrisdone: came back from what?
17:25:34 <Tekmo> > set 1 (traversed.taking 3) [[1, 2], [3, 4]]
17:25:35 <lambdabot>   Could not deduce (Control.Lens.Internal.Indexed.Conjoined p0)
17:25:35 <lambdabot>    arising fr...
17:26:01 <Tekmo> > toListOf (traversed.taking 3) [[1,2],[3,4]]
17:26:02 <lambdabot>   Couldn't match type `s0
17:26:02 <lambdabot>                       -> Control.Lens.Internal.Baza...
17:26:41 <Tekmo> So yeah, lens is awesome, even if the types are inscrutable
17:27:06 <chrisdone> acowley: i was pretty happy about it. i was psyched about lenses back with twanvl's “functional references” stuff 5 years ago: https://github.com/chrisdone/wordcloud/blob/master/Graphics/GenericFR.hs~ but with the exception of the fclabels guys, i didn't see that the community was really into it. now it's everywhere, i had to re-psyche myself about it =)
17:27:36 <monochrom> parametricity wants theorems to be free
17:27:45 <spaceships> > toListOf (taking 3 traverse) [[1,2],[3,4]]
17:27:46 <lambdabot>   [[1,2],[3,4]]
17:27:53 <bitemyapp> Tekmo: I can figure out what zoom is doing with StateT at a conceptual level and I could take a guess at what the right-hand side is doing but it's not clear just from diving into the middle of the code.
17:28:11 <chrisdone> bitemyapp: back from not really hanging out on irc or reading reddit much
17:28:16 <bitemyapp> Tekmo: anything of equal sophistication with the same lack of familiarity with the design would've elicited the same result.
17:28:20 <spaceships> > toListOf (taking 3 (traverse.traverse)) [[1,2],[3,4]]
17:28:22 <lambdabot>   [1,2,3]
17:28:24 <bitemyapp> chrisdone: glad you 're back then :)
17:28:30 <Tekmo> spaceships: Thanks!  That was it
17:28:30 <monochrom> where can I read about zoom?
17:28:43 <acowley> chrisdone: Even though I thought Twan's work was amazing, I didn't have the slightest clue lens would blossom like it has
17:28:52 <bitemyapp> monochrom: http://hackage.haskell.org/package/lens-3.10/docs/Control-Lens-Zoom.html
17:28:58 <Tekmo> > set 1 (taking 3 traverse) [[1, 2], [3, 4]]
17:28:59 <lambdabot>   Could not deduce (Data.Traversable.Traversable t0)
17:28:59 <lambdabot>    arising from the ambi...
17:28:59 <monochrom> thanks
17:29:13 <Tekmo> > set 1 (taking 3 (traverse.traverse)) [[1, 2], [3, 4]]
17:29:14 <lambdabot>   Could not deduce (Data.Traversable.Traversable t1)
17:29:14 <lambdabot>    arising from the ambi...
17:29:31 <jrmithdobbs> Tekmo: Is there a good lens intro/summary somewhere?
17:29:36 <merijn_> @where lens
17:29:37 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
17:29:38 <chrisdone> acowley: to be honest, my phobia of TH blocked me from using libraries like this for a while…
17:29:39 <Tekmo> I can shamelessly link you to my lens tutorial
17:29:50 <Tekmo> jrmithdobbs: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
17:29:59 <spaceships> Tekmo: you have set
17:30:00 <acowley> chrisdone: You are not the first person I would have guessed would have a TH phobia
17:30:01 <merijn_> jrmithdobbs: THe youtube link is a 2 hour lecture by edwardk about lens and there's plenty of tutorials
17:30:11 <spaceships> Tekmo: you have set's args backwards i think
17:30:26 <Tekmo> > set (taking 3 (traverse.traverse)) 1 [[1,2],[3,4]]
17:30:27 <lambdabot>   [[1,1],[1,4]]
17:30:31 <Tekmo> Eureka!
17:30:39 <acowley> chrisdone: I still have a TH phobia, but I'm willing to look away when using makeLenses :P
17:30:41 <chrisdone> acowley: i dunno, it seemed like a hack, i use to call it “cheating”
17:31:01 <Tekmo> I too have a TH phobia
17:31:16 <bitemyapp> acowley: I'm a lisp/Clojure user, it's hard for me to feign indignation at TH, but I do avoid it.
17:31:27 <acowley> Tekmo: That is a neat example, and you made it look so easy!
17:31:29 <Tekmo> I prefer to use free objects to embed syntax within the language and then use Haskell to manipulate things
17:31:29 <chrisdone> someone would show me a cool trick they did and if i saw it used TH, i decided it wasn't impressive because you can do anything with TH, it was much cooler to have a clever functional solution that used types
17:31:35 <Tekmo> acowley: lol
17:31:38 <scott_> Is there a lens function like 'set' that takes a function to modify the values?
17:31:51 <chrisdone> :t over
17:31:52 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
17:31:52 <Tekmo> Yes
17:32:03 <acowley> :t (%~)
17:32:03 <scott_> Thanks, chrisdone
17:32:04 <chrisdone> HOPE THAT HELPS
17:32:04 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
17:32:09 <Tekmo> > over (taking 3 (traversed.traverse)) (+1) [[1,2],[3,4]]
17:32:11 <lambdabot>   [[2,3],[4,4]]
17:32:13 <quchen> chrisdone: :-þ
17:32:15 <Tekmo> I wonder if this next one will work
17:32:27 <Tekmo> > over (taking 3 (traversed.both)) (+1) [(1,2),(3,4)]
17:32:28 <lambdabot>   [(2,3),(4,4)]
17:32:35 <Tekmo> Not bad
17:32:47 <scott_> That's almost exactly what I did in ghci :P
17:32:52 <Tekmo> :)
17:33:41 <chrisdone> huey! there's a great storm coming. i feel like i should have some chickens so i can hurriedly herd them into the barn and close my shutters
17:34:08 <bitemyapp> chrisdone: chickens don't live in barns, they live in coops. It's not a mere semantic difference either.
17:34:16 <jrmithdobbs> Tekmo: I jus came a little in my pants: http://hackage.haskell.org/package/aeson-lens
17:34:16 <bitemyapp> chrisdone: this is how I know you aren't from the country-side :P
17:34:19 <acowley> When a storm is coming: Step 1) buy some chickens ....
17:34:37 <chrisdone> bitemyapp: my parents keep chickens in a coop. but… shut up
17:34:42 <chrisdone> =p
17:34:48 * bitemyapp snorts
17:35:08 <Tekmo> jrmithdobbs: lol
17:35:09 <acowley> Maybe you could just put some chicken nuggets into a box and speak soothingly to them?
17:35:15 <chrisdone> haha
17:35:27 <monochrom> chrisdone: instead, hurriedly herd your emacs buffers :)
17:35:34 <chrisdone> hahaha
17:35:51 <Tekmo> "Don't yall worry none, hear!"
17:35:56 <chrisdone> F3 M-x bury-buffer F4 F4 F4 F4 F4 F4 F4 F4 F4 F4 F4 F4 F4 F4 F4
17:36:46 <jrmithdobbs> Tekmo: Great timing. I was about to write my own th for ripping a bunch of aeson objects apart!
17:37:28 <chrisdone> while the wicked witch of the vim flies past on her broomstick, she tries to cackle but forgets she's in normal mode and turns upside down and my house lands on her
17:37:39 <Tekmo> jrmithdobbs: You might also be interested in: https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms
17:37:42 <bitemyapp> chrisdone: hahahaha
17:37:59 <bitemyapp> Tekmo: man keep the awesome articles coming. Thank you!
17:38:07 <Tekmo> bitemyapp: You're welcome!
17:38:18 <joelteon> parallel building on cabal-install has to be the best feature of any tool ever written
17:38:18 <Tekmo> It's because I browse /r/haskell to a fault
17:38:21 <mm_freak> is there a haskell-centric introduction into free objects?
17:38:23 <bitemyapp> Tekmo: you're piling stuff onto my "when I get home" queue :)
17:38:43 <mm_freak> i have an ad hoc understanding of free monads and free comonads, but that's it
17:38:54 <mm_freak> (or rather cofree comonads)
17:38:55 <Tekmo> I can link my free monad tutorial
17:39:03 <Tekmo> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
17:39:19 <marx2> is this the lenses package people often talk about in the channel?  it doesn't seem that popular (only 51 downloads). http://hackage.haskell.org/package/lenses-0.1.2
17:39:24 <mm_freak> Tekmo: does it deal with this on a more general level?  because i do understand free monads
17:39:29 <Tekmo> mm_freak: No
17:39:33 <Tekmo> mm_freak: It's free-monad-specific
17:39:34 <chrisdone> @hackage lens
17:39:34 <lambdabot> http://hackage.haskell.org/package/lens
17:39:38 <mm_freak> i'll read it anyway =)
17:39:43 <Tekmo> mm_freak: Thanks! :)
17:39:50 <mm_freak> (if i haven't already)
17:39:52 <marx2> thanks
17:40:02 <Tekmo> mm_freak: Basically, I like to think of a free object as something that preserves all the original syntax
17:40:15 <Tekmo> mm_freak: That's not totally rigorous, but it's a Haskell-centric way to think about it
17:40:16 <mm_freak> Tekmo: "syntax" meaning …?
17:40:29 <Tekmo> mm_freak: "source code" for a very loose definition of source code
17:40:36 <mm_freak> hmm, ok
17:40:38 <Tekmo> mm_freak: For example, consider this:
17:40:38 <chrisdone> Tekmo: are you spanish/mexican and/or just incidentally with a spanish-sounding name?
17:40:47 <Tekmo> chrisdone: My dad is Mexican
17:40:51 <Tekmo> chrisdone: I'm born and raised in US
17:40:58 * chrisdone nods
17:41:02 <Tekmo> My mom is Italian
17:41:08 <chrisdone> no wai!
17:41:12 <Tekmo> So we have a very loose connection! :)
17:41:21 <marx2> is lens,to put it very simplistically, about generic getters and setters?
17:41:35 <Tekmo> marx2: Here's another article on lens which answers your quesiton: marx2
17:41:40 <Kams_> Hi, I'm having trouble getting Haskell-platform on Arch
17:41:46 <ellipsis_> I'm trying to learn Control.Arrow
17:41:51 <Tekmo> marx2: http://www.haskellforall.com/2012/01/haskell-for-mainstream-programmers_28.html
17:41:56 <mm_freak> Tekmo: that's a weird consideration =P
17:41:57 <Tekmo> marx2: That discusses the motivation behind them
17:41:59 * chrisdone . o O ( i guess a more native rendering would be ‘Gabriele’? )
17:42:01 <ellipsis_> the number of times I've typoed >>> and written >> by mistake is astounding
17:42:11 <monochrom> nice to meet you, senor Gabriello Gonzalez
17:42:12 <Tekmo> chrisdone: I'm not totally sure
17:42:13 <marx2> thanks
17:42:15 <Tekmo> monochrom: :)
17:42:21 <chrisdone> =)
17:42:22 <Tekmo> monochrom: Mucho gusto!
17:42:28 <Tekmo> I'm missing the upside-down exclamation mark
17:42:47 <Tekmo> mm_freak: Ok so back to the example
17:42:54 <Tekmo> example = 0 + 2 + 4 + 5
17:43:08 <Tekmo> Note that in Haskell you can't "reflect" on example to see what you added to make it
17:43:09 * chrisdone now imagines this when Tekmo learns of people reading his articles http://th00.deviantart.net/fs70/300W/f/2010/281/2/a/me_gusta_by_megustaplz-d30cns2.jpg
17:43:28 <Tekmo> chrisdone: lol
17:43:49 <Tekmo> mm_freak: So one way to preserve the original values you add them together is not to add them together, but to instead store them as a list of values waiting to be added
17:43:57 <Tekmo> mm_freak: example' = [0, 2, 4, 5]
17:44:05 <jrmithdobbs> Tekmo: You just saved me so much work!
17:44:05 <Tekmo> mm_freak: example = sum example'
17:44:09 <Tekmo> jrmithdobbs: lol
17:44:16 <Tekmo> jrmithdobbs: Welcome to Haskell!  It's awesome like that
17:44:22 <Kams_> Hi, I'm having trouble getting Haskell-platform on Arch, could anyone help me out or point me to somewhere that can?
17:44:29 <Tekmo> mm_freak: In this case we've basically used the free monoid
17:44:48 <Tekmo> mm_freak: The free monoid basically takes any monoid and preserves the original arguments before you mappend them together
17:44:49 <mm_freak> Kams_: on arch you typically don't install the haskell platform, but the basic tools you need…  then install the rest using cabal-install
17:45:00 <Tekmo> mm_freak: The free monad is basically the same thing for monads
17:45:00 <Kams_> Hm ok
17:45:05 <rohloh> hi guys, how can i pattern match while using take while. Something like: take while the sum of an element from a list and the next element is less than some number?
17:45:12 <Tekmo> mm_freak: Normally for a typical monad you can't reflect on it to tell what steps it was made from
17:45:18 <Tekmo> mm_freak: Hold on, I have to take a call
17:45:24 <mm_freak> Tekmo: ok
17:46:05 <Kams_> mm_freak: I have a few things via cabal, is there a list of the packages haskell-platform includes that I can use to install what I need?
17:46:56 <mm_freak> Kams_: http://www.haskell.org/platform/changelog.html
17:47:13 <mm_freak> Kams_: not sure, but arch may actually provide a haskell-platform package
17:47:32 <Kams_> They don't, not in the standard repos, they have cabal
17:47:59 <Kams_> I attempted to build from source but I got some cryptic errors in the make process
17:48:24 <mm_freak> as a user building it from source is often just a waste of time
17:48:32 <mm_freak> if all else fails, install the packages individually
17:48:57 <mm_freak> for example when i used arch i only installed GHC, cabal-install, happy, alex and c2hs
17:49:15 <Kams_> Yeah thought it would be simple enough to just build from source because they don't have it in the repos and the instuction list was pretty short
17:49:50 <marx2> I had no idea haskell had this syntax. is this an extension or standard haskell?  set42Radius c = c { radius = 42.0 }
17:49:59 <monochrom> standard
17:50:05 <acowley> Record update syntax
17:50:21 * hackagebot semigroups 0.12 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.12 (EdwardKmett)
17:50:42 <mm_freak> marx2: that's haskell's slightly awkward record syntax =)
17:50:53 <acowley> But don't fall in love with it too quickly, some nasty bits lurk within.
17:50:59 <rohloh> I'm trying to do it like this but it doesn't work: takeWhile (\(x:y:xs)-> x+y < 14) [1..100]
17:51:02 <marx2> that one would come in handy quite a few times. :)
17:51:06 <scott_> acowley: What kind of nasty bits?
17:51:09 <marx2> rohloh like?
17:51:22 <marx2> sorry, acowley like?
17:51:25 <acowley> scott_: nested record update is painful, and the selectors aren't first class
17:51:28 <monochrom> but they say, "if you love Haskell, you have to accept all its shortcomings" :)
17:51:55 <scott_> acowley: What do mean by the selectors aren't first class?
17:51:55 * Kams_ loves haskell up to this point, even as a language to do real tasks in
17:52:03 <marx2> you can't pass them around I guess
17:52:16 <acowley> scott_: Using that example, try passing the radius "setter" to a function
17:52:25 <acowley> marx2: right
17:52:48 <acowley> Lens lets you pass these things around and compose them like any other function
17:53:02 <mm_freak> rohloh: your function is partial
17:53:19 <mm_freak> rohloh: if any of the sublists is shorter than 2 items, it will fail
17:53:29 <acowley> and upcoming extensions will support record field name overloading
17:53:31 <Tekmo> mm_freak: Ok, back
17:53:37 <acowley> but I guess that won't be until 7.10
17:53:41 <scott_> acowley: Ah, you mean the { ... } piece yeah, I think I first really noticed that when I tried @pf on a record update
17:53:45 <mm_freak> > (\(x:y:xs) -> x + y < 14) []
17:53:46 <lambdabot>   *Exception: <interactive>:3:2-24: Non-exhaustive patterns in lambda
17:53:52 <mm_freak> @ rohloh
17:53:54 <Tekmo> mm_freak: So let's use `IO` as an example.  You can't reflect on an `IO` action and tell how many sub-actions it was built from
17:54:03 <Tekmo> mm_freak: But if you use a free monad as an intermediate, you can
17:54:11 <mm_freak> Tekmo: ah!
17:54:16 <acowley> scott_: Yeah. It's frustrating only when you start to push it beyond basic usage. At first blush, it seems to work quite well.
17:54:27 <mm_freak> that last sentence helped me understand your view =)
17:54:38 <scott_> It's irritating to need (\x -> x { foo = bar })
17:54:39 <rohloh> mm_freak: hmm i see how that would fail.
17:54:47 <Tekmo> mm_freak: Yeah, free objects are about preserving as much informatoin as possible
17:54:59 <Tekmo> mm_freak: That's why people always say that "free objects are adjoint to some forgetful functor"
17:55:09 <rohloh> mm_freak: how should i do it then?
17:55:17 <Tekmo> mm_freak: adjoint means (roughly) something that is "almost an inverse of"
17:55:17 <mm_freak> rohloh: try this:  let p (x:y:_) = x + y < 14; p _ = False in takeWhile p
17:55:18 <acowley> scott_: Which is why we adopt lens into our hearts and write foo .~ bar
17:55:27 <mm_freak> rohloh: you have to define what happens for shorter lists
17:55:40 <Tekmo> mm_freak: So a free object is "almost the inverse" of something that is forgetful, meaning that it tries to remember as much as possible
17:55:54 <mm_freak> rohloh: if you compile your code with the -W flag it will warn you about partial functions ("non-exhaustive pattern matches")
17:56:04 <rohloh> mm_freak: thanks!
17:56:25 <jchee> Tekmo: you keep saying "tries to remember" are there examples when it loses information?
17:56:30 <mm_freak> Tekmo: i see…  thanks
17:56:42 <mm_freak> jchee: it doesn't lose information
17:56:52 <mm_freak> jchee: but you can choose not to provide all information in the first place
17:57:22 <jchee> mm_freak: right
17:57:24 <Tekmo> jchee: A free object only tries to remember as much information as the corresponding forgetful functor forgets
17:57:41 <Tekmo> jchee: So I think it is a matter of choosing a suitable forgetful functor, but don't quote me on that
17:57:52 <Tekmo> jchee: But most things you'd want to remember are possible
17:58:08 <Tekmo> jchee: For example, Haskell has lots of free objects in the `free` package you can use
17:58:15 <Tekmo> jchee: Also free categories and free arrows
17:58:39 <Tekmo> Now, there are some things in Haskell you can't model as free objects
17:58:44 <Tekmo> Like type declarations
17:58:47 <Tekmo> Or type class stuff
17:58:52 <Tekmo> That stuff has to be done with TH
17:59:03 <Tekmo> However, many other things can be implemented within Haskell using free objects
17:59:11 <Tekmo> I like to think of free objects as the "lisp-ification" of Haskell
17:59:21 <Tekmo> ... except more powerful than lisp in some ways
17:59:28 <mm_freak> Tekmo: is there a free object for every forgetful functor?
17:59:30 <Tekmo> Lisp only gets the free monoid correct (i.e. lists)
17:59:53 <Tekmo> mm_freak: I'm not sure.  My intuition says no
18:00:40 <mm_freak> Tekmo: is there an interesting application of free objects that is neither free monoids nor free monads?
18:01:18 <monochrom> free groups. free CPOs.
18:01:19 <Tekmo> mm_freak: free aplicatives
18:01:24 <Tekmo> ^monochrom
18:01:34 <bobcrash_> Its so weird how all the haskell tutorials use pure functions, when in a real program every function returns an "IO" of something
18:01:39 <monochrom> in fact I say "yes" to "free object for every forgetful functor"
18:01:41 <mm_freak> "CPO"?
18:01:45 <Tekmo> mm_freak: See here for free applicatives specifically: http://paolocapriotti.com/blog/2013/04/03/free-applicative-functors/
18:02:09 <mm_freak> bobcrash_: the majority of a well written haskell program is actually pure
18:02:10 <rohloh> mm_freak: can you give a working example please? I'm having a hard time figuring this out -___-. I understand what needs to be done in theory but its the syntax that I'm having a hard time with i guess.
18:02:21 <frx> bobcrash_something is wrong with a program where every (or most) functions return IO
18:02:46 <Tekmo> bobcrash_: frx is right.  You shouldn't have `IO` everywhere
18:02:52 <Tekmo> bobcrash_: I can teach you tricks to remove IO from your core logic
18:02:59 <bobcrash_> Sorry guys I'm just trolling.  Too many beers
18:03:04 <Tekmo> bobcrash_: lol
18:03:26 <bobcrash_> I figured it was just believable enough...
18:03:34 <Tekmo> There's also a general purpose trick which is a blunt hammer
18:03:40 <bobcrash_> haha
18:03:46 <Tekmo> See: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
18:03:47 <bobcrash_> Take code, open on screen, hammer screen
18:04:09 <monochrom> that only remove IO from the screen
18:04:15 <monochrom> or, I/O
18:04:41 <mm_freak> bobcrash_: if the IO bothers you, just use unsafePerformIO everywhere
18:04:44 <Tekmo> lol
18:04:48 <bobcrash_> likely its a pure action, because "hammer screen" returns a consistent value of "broken" and the there are no reported side-effects as long as you shoot the owner
18:04:49 <monochrom> you need to hammer the hard disk that holds your code. if the code is on github, hammer github.
18:05:04 <bobcrash_> mm_freak: LOL
18:05:35 <monochrom> if the code is with Buddha, hammer Buddha
18:06:14 <bobcrash_> No side-effectss from hammering either.  it just returns a new Universe based upon the existing Universe with everything modified
18:08:17 <Tekmo> See also: http://hackage.haskell.org/package/acme-realworld-0.1.1/docs/Acme-RealWorld.html
18:09:09 <bobcrash_> p.s. Did you guys get Haskell dreams trying to resolve types when you started learning the language?  Do those eventually go away?
18:09:44 <Tekmo> No, I have never gotten Haskell dreams (that I remember)
18:09:47 <Hodapp> No.
18:09:49 <Hodapp> They never go away.
18:09:54 <mm_freak> they started as nightmares for me, but at some point the pieces fit together and it spontaneously turned into a dream
18:09:55 <monochrom> I didn't. or maybe I forgot.
18:10:20 <khyperia> to be honest, the past few days I've been having dreams about hindley-milner
18:10:26 <khyperia> nights*
18:10:37 <bobcrash_> khyperia:  I started reading the wikipedia page on that and decided I should wait a little while before I tried again
18:10:46 <mm_freak> haskell is amazing in that even a joke idea can turn into a serious abstraction
18:10:50 <khyperia> hah, yeah, the symbols are a bit... scary.
18:10:53 <mm_freak> http://hackage.haskell.org/package/acme-schoenfinkel
18:11:40 <Tekmo> Computer science has the worst notation for everything
18:12:08 <bobcrash_> heh
18:12:08 <monochrom> no, I think physics is worst
18:12:16 <mm_freak> yes, physics is way worse
18:12:26 <bobcrash_> I have to ask, is the Va => a notation on that page similar to existential types in any way?
18:12:43 <[swift]> Tekmo: has anyone written about the perf cost of free monads? i really like the idea but the places i need to use it in my app are exactly the places where performance is most critical =\
18:12:50 <mm_freak> bra-ket notation is so braindamaged
18:12:51 <monochrom> I'm probably ok with "the two are very close"
18:13:07 <mm_freak> why |x> and <x| if you can simply write x and x*?
18:13:21 <bobcrash_> UPGRADE
18:13:22 <monochrom> bobcrash_: which page?
18:13:25 <Tekmo> [swift]: They can be really performant
18:13:40 <bobcrash_> hindl
18:13:43 <bobcrash_> oops, one sec
18:13:55 <Tekmo> [swift]: Well, let me clarify that
18:14:04 <Tekmo> [swift]: They are about as performant as haskell linked lists
18:14:19 <Tekmo> [swift]: So all the caveats about linked lists apply
18:14:47 <bobcrash_> monochrom: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_inference -- the section under Polymorphic type order with "Va.a -> a" for some reason made me think of "for each a => (Blah a)"
18:14:50 <[swift]> Tekmo: hah, fair enough. i certainly haven't shied away from using those
18:15:00 <trolling> isn't there something about codensity with free monads
18:15:26 <Tekmo> There is
18:15:34 <Tekmo> However, that actually has worse constant factors
18:15:57 <Tekmo> It is asymptotically better if you do `replicateM`/`mapM`/`sequence`
18:16:03 <Tekmo> However, I consider those three functions broken
18:16:07 <monochrom> no, it's the usual polymorphic type, similar to Haskell's "forall a. a->a"
18:16:10 <Tekmo> They are a bad idea in all monads
18:16:23 <trolling> why?
18:16:24 <[swift]> =( i use mapM all the time
18:16:27 <[swift]> what is the alternative?
18:16:51 <Tekmo> trolling: You will probably be interested in this `pipes` issue thread: https://github.com/Gabriel439/Haskell-Pipes-Library/issues/100
18:16:55 <bobcrash_> monochrom:  polymorphic type is what I was thinking of because I had to use that somewhere.  Now I need to go read about existential types again haha
18:16:58 <khyperia> monochrom, isn't the V symbol (well, upside-down A) actually literally called "forall"?
18:17:07 <monochrom> yes
18:17:44 <Tekmo> [swift]: Use the `pipes` equivalent
18:17:54 <Tekmo> [swift]: It doesn't stack overflow on large lists
18:18:29 <bitemyapp> Followed by Galois on Twitter, today is a glorious day.
18:19:01 <Tekmo> [swift]: So the reason `mapM` is bad is because it tries to load the entire list into memory
18:19:12 <Tekmo> [swift]: The correct behavior is to lazily generate only as many elements as needed
18:19:13 <khyperia> Does *your* GHC have potatoes? https://dl.dropboxusercontent.com/u/18830644/ghc.png (in other news, I'm yelling "yaaay, it worked!" repeatedly)
18:20:07 <Tekmo> [swift]: For example, let's say that I want to read user input 1000000 times
18:20:17 <Tekmo> [swift]: The wrong way would be: `replicateM 1000000 getLine`
18:20:35 <Tekmo> [swift]: That will not only overflow, but it won't produce a single result until it finishes reading all 1000000 lines
18:21:13 <Tekmo> [swift]: The right way is to instead create a `Producer` of lins
18:21:36 <Tekmo> [swift]: Pipes.replicate 1000000 getLine :: Producer String IO ()
18:21:42 <trolling> could replicateM itself not do the codensity wrapping?
18:21:44 <Tekmo> *Pipes.Prelude.replicateM
18:21:51 <Tekmo> trolling: Still the same problem
18:21:57 <Tekmo> trolling: It still will overflow if the number is large enough
18:22:06 <Tekmo> trolling: It will also not return any results until it retrieves all of the
18:22:10 <[swift]> Tekmo: i see. presumably in simple cases you can also just manually create a tail-recursive function that gets and processes each line
18:22:11 <Tekmo> *all of them
18:22:12 <augur> hmm hmm. unificational bidirectional parsing/generation is interesting
18:22:14 <simpson> Tekmo: That seems to just be the equivalent of the classic problem of reading in all of the input before doing anything with it.
18:22:25 <Tekmo> simpson: Exactly
18:22:31 <Tekmo> [swift]: This is actually what a `Producer` is
18:22:49 <Tekmo> [swift]: A `Producer` is analogous to a function waiting for a continuation that decides what to do with the output
18:22:58 <monochrom> all your points except stack overflow are right
18:23:03 <simpson> Tekmo: So it doesn't seem to me that replicateM is a problem; the *combination* of replicateM and this particular Monad is the problem.
18:23:03 <Tekmo> [swift]: Basically every time you `yield` a value it creates a hole waiting to be filled
18:23:20 <Tekmo> [swift]: If you use `for` to loop over a `Producer`, literally all that it does is substitute `yield` with the `for` loop body
18:23:35 <Tekmo> simpson: It occurs with all monads
18:23:39 <Tekmo> simpson: Not just IO and free monads
18:23:51 <[swift]> Tekmo: interesting. sounds very clean; i need to try this out
18:24:15 <Tekmo> [swift]: Read the `pipes` tutorial, you won't regret it: http://hackage.haskell.org/package/pipes-4.0.1/docs/Pipes-Tutorial.html
18:24:37 <Tekmo> [swift]: Even if you never use `pipes` you will learn a lot from it
18:24:54 <[swift]> Tekmo: cool, i'll check it out!
18:25:10 <simpson> Tekmo: So what about things like parsing monads?
18:25:16 <monochrom> ok, all your points except stack overflow and all monads are right
18:25:21 <Tekmo> simpson: I know a really good introduction to parsers
18:25:24 * hackagebot chronograph 0.2.0.0 - measure timings of data evaluation  http://hackage.haskell.org/package/chronograph-0.2.0.0 (JohnLato)
18:25:26 <Tekmo> simpson: It's a paper, but it's a really good paper
18:25:41 <chrisdone> Tekmo: some of my favourite tutorials are actually papers!
18:26:20 <Tekmo> simpson: Read this: http://cs.nott.ac.uk/~gmh/pearl.pdf
18:26:21 <chrisdone> (e.g. the first monad papers, the first type-class paper, fun with type funs paper)
18:26:46 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/107006/
18:26:53 <acowley> chrisdone: You found the Moggi papers helpful?
18:27:32 <acowley> I tried them when I was a Haskell noob and didn't get anything at all :(
18:27:58 <Tekmo> My favorite introduction monads was Dan Piponi's post: You could have invented monads (http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html)
18:28:16 <Tekmo> That was the post that got me utterly hooked on Haskell
18:29:57 <Hodapp> My favorite monad analogy was midgets in a dildo factory.
18:30:15 <chrisdone> what i like about ‘The essence of functional programming’ and ‘How to make ad hoc overloading less ad hoc’ is that they're both written before a culture of understanding and therefore are written for an audience who has never encountered the concepts before
18:31:22 <timemage> i kind of liked codecommit's "monads are not metaphors"
18:31:29 <Tekmo> I think part of my reluctance to read papers back in the day was that it was before there was good browser integration with PDFs
18:31:32 <chrisdone> like Applicative Programming with Effects, it's written in a “hey look at this idea”, rather than “you've all heard about monads, and they're not this, they're not that, they're kinda like this,” etc which  is just bad writing
18:32:18 <Hodapp> what I learned back in the day: when you got PDFs, teachers didn't know that you got it off the Internet
18:32:48 <Hodapp> so when we had to have N sources for our Stupid Effing Project and only M < N could be
18:32:53 <chrisdone> Tekmo: i tend not to like reading papers unless it's printed out. but i don't have a printer. my kobo hd should arrive tomorrow, though =)
18:32:56 <Hodapp> ...Internet sources, I may have cheated a little.
18:34:16 <Tekmo> chrisdone: I prefer reading things on my computer
18:34:39 <chrisdone> Hodapp: i hear teachers now say “no using wikipedia for coursework/homework”. that's stupid. don't ask people factual questions and then prevent them from using the most efficient source. ask them better questions
18:35:21 <Hodapp> chrisdone: oh, this predated Wikipedia, and we got the scaremongering "ANYONE CAN PUT ANYTHING ON THE INTERNET" explanation
18:35:34 <monochrom> https://ghc.haskell.org/trac/ghc/ticket/8189#comment:2
18:36:09 <monochrom> (SPJ agrees: stack limit is too low)
18:36:17 <Hodapp> chrisdone: so I used our out-of-date encyclopedias that I now remember being, er, wrong on a lot of things.
18:36:36 <Tekmo> monochrom: Well, that just hands off the problem to the (larger) heap
18:36:49 <monochrom> not always
18:36:51 <Tekmo> monochrom: It will crash on sufficiently large list sizes
18:37:01 <Tekmo> monochrom: It also still suffers from the problem where it won't return any result until it computes them all
18:37:25 <monochrom> ok, there are several points
18:38:36 <monochrom> 1. either a problem is solvable by O(1) space, or no. if yes, any grow of stack or heap or whatever is plain wrong, I agree. but if no, "using stack is wrong, using heap is right" is plain wrong.
18:38:48 <Tekmo> Right, using heap isn't intrinsically wrong
18:38:55 <Tekmo> I agree that moving to the heap is an improvement
18:39:11 <monochrom> no, using stack instead of heap is just as right
18:39:39 <Tekmo> Oh, whoops, I misread what you wrote
18:39:55 <Tekmo> Either way, I agree that O(1) space is ideal when possible
18:40:40 <monochrom> 2. some problems really specify, "complete all the effects and store all the one million answers in memory before moving on". then storing them on stack is just as right.
18:41:00 <Tekmo> What problems are those?
18:41:16 <monochrom> I don't know. I just know it's conceivable.
18:41:35 <Tekmo> So, I use to think that vector computations were such problems
18:41:52 <monochrom> I just know God did not set in stone "those specifications don't exist"
18:41:56 <Tekmo> But then I studied the internal representatoin of vectors (i.e. monadic stream fusion) and then discovered it was (basically) a producer in disguise
18:42:49 <monochrom> 3. you really need to read my http://thread.gmane.org/gmane.comp.lang.haskell.libraries/20113/focus=107006
18:45:46 <Tekmo> Okay, I didn't know that
18:47:11 <Tekmo> However, I think fixing the monad is not practical for all monads
18:47:18 <Tekmo> Since there are certain monads we cannot make lazy like that
18:49:05 <monochrom> when you talk about vectors and producers, you are comparing "generate 3n bytes on stack, then transfer n of that to a vector on heap, the other 2n is overhead" vs "generate n bytes into the vector on heap". this only shows that indirect fat algorithms are wrong. this does not show that stack is wrong.
18:49:47 <monochrom> to see this, compare "generate 3n bytes on heap, then transfer n of that to a vector on stack, the other 2n is overhead" vs "generate n bytes into the vector on stack"
18:50:31 <monochrom> I did not say or imply "change the monad". I am refuting a universal statement.
18:51:07 <monochrom> you can, always, change your statement to "for all useful monads", to exploit the flexibility of "useful".
18:51:30 <Tekmo> monochrom: I mean that we shouldn't be generating `n` bytes on either stack or heap
18:51:48 <Tekmo> monochrom: The producer solution works out of the box on all monads and is O(1) heap and stack
18:52:56 <monochrom> for those problems that fit the producer solution
18:53:13 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
18:53:14 <Tekmo> monochrom: So the thing is that the producer solution is guaranteed to be more flexible than the `mapM` one
18:53:30 <Tekmo> monochrom: You can always reduce the producer back to the version that returns an ordinary list using `Pipes.Prelude.toListM`
18:53:59 <Tekmo> monochrom: The producer just preserves more information that `mapM` and friends discard
18:54:09 <Tekmo> monochrom: `toListM` just throws that information away again
18:54:15 <monochrom> then I accept that
18:54:40 <Tekmo> \o/
18:56:20 <diamium> What's the easiest way to play an mp3 from Haskell code?
18:56:55 <Tekmo> So I searched for "hackage mp3" and found this: http://hackage.haskell.org/package/hmp3
18:57:25 <monochrom> consider http://hackage.haskell.org/packages/search?terms=mp3
18:57:59 <marx2> what is the difference between data-lens and lens packages?
18:58:48 <Tekmo> marx2: lens is basically the new way of doing things
18:58:56 <Tekmo> `data-lens` is obsolete
19:00:04 <Tekmo> The reason why is that the new lenses make certain things possible that were previously not possible using `data-lens`, such as updating a field with a value of a new type or having lenses that may point to multiple values (or no values)
19:01:14 <marx2> ok lens it is then
19:02:22 <bobcrash_> Hey guys, after lots of research with the most advanced functional programming advanced technologies... the future, is today: http://imgur.com/FCLaSaL
19:04:53 <Tekmo> marx2: You can try `lens-family`.  It's basically `lens` with simpler types and preserves most of the core features.
19:05:01 <Tekmo> marx2: It may make it easier to learn
19:05:15 <Tekmo> bobcrash_: lol
19:05:55 <monochrom> what is that? green land, blue sea, and a little brown hair?
19:06:53 <monochrom> is that the future? it's peaceful but a bit boring
19:06:58 <bobcrash_> Come on, you can totally tell its beautiful green grass that unfortuantely ends to soon, an (overly) expansive blue sky on a clear day, and a small red helicopter that just doesn't have all its detail yet
19:07:27 <bobcrash_> ;)
19:07:36 <ReinH> Yay haskell cast is up
19:07:47 <ReinH> wWell, it has been for like 12 hours, but still. Yay.
19:07:54 <monochrom> ok, I agree that helicopter is the future
19:08:03 <bobcrash_> totally is
19:08:27 <ReinH> wait did you say red?
19:08:30 <ReinH> red is not the future
19:08:44 <monochrom> no one said red
19:09:14 <monochrom> oh wait, someone did. nevermind. but we were focusing on the helicopter, not red
19:09:16 <bobcrash_> As much as I want to disagree with ReinH I did say red unfortunately
19:10:29 <ReinH> he helicopter is red
19:10:31 <ReinH> *the
19:10:35 <ReinH> this is problematic
19:10:54 <monochrom> I am sure the next version will make that polymorphic
19:11:00 <bobcrash_> ROFL
19:11:53 <bobcrash_> someday it'll actually be a helicopter model (once I bother upgrading this thing to modern non-immediate-mode opengl) but for now I need to stop stalling
19:12:00 <bobcrash_> and get functionality working
19:13:33 <ReinH> something something DMR
19:15:15 <bobcrash_> Never heard that before but from wikipedia I assume developmetn milestone release?
19:17:06 <monochrom> dreaded monomorphism restriction
19:17:53 <monochrom> the "dreaded" part is plain english :)
19:19:24 <bobcrash_> That's kind of crazy
19:20:28 <dhaya> l
19:21:59 <bobcrash_> m
19:26:25 <marx2> what is forall used in the examples on the following link?  I can't find it on hackage https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
19:55:31 * hackagebot hslua 0.3.9 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.9 (OmerAgacan)
20:03:39 <marx2> what is the lens operator equivalent to set (foo . bar) value x
20:04:17 <Taneb> x & foo . bar .~ value
20:04:33 <Taneb> (.~) is the interesting bit
20:05:22 <marx2> thanks
20:07:05 <ion> .= would probably be named := if that was allowed, and the ~ versions are the non-State variants.
20:07:41 <ion> := being the symbol for “set” in a number of languages.
20:10:32 * hackagebot metrics 0.1.0.0 - High-performance application metric tracking  http://hackage.haskell.org/package/metrics-0.1.0.0 (IanDuncan)
20:16:48 <marx2> fmap (view (father . name)) (Just myFamily)  <- is there a nicer way of doing that? both with functions and operators
20:17:57 <marx2> actually I guess `view (father . name) <$> Just myFamily' is as short as it will get
20:18:22 <marx2> (operators excluded :) )
20:18:59 <fizruk> wouldn't `preview (_Just.father.name)` do that?
20:19:08 <lispy> father . name? I would expect name . father
20:19:40 <lispy> Just in terms of the data layout. I would expect a father to have a name, not for a name to have a father
20:19:44 <marx2> no father . name is correct. lenses compose ther other way around
20:19:50 <marx2> compared to functions
20:20:12 <fizruk> > view (_2._1) (1, (2, 3))
20:20:13 <lambdabot>   2
20:20:20 <marx2> preview (father . name) (Just myFamily)  didn't work
20:20:24 <enthropy>  myFamily^.father.name&Just
20:20:41 <fizruk> > preview (_Just._1) (Just (1, 2))
20:20:43 <lambdabot>   Just 1
20:20:46 <lispy> oh, i didn't realize lens composition was backwards
20:20:46 <enthropy> we're winning the war on whitespace
20:21:07 <jrmithdobbs> Tekmo: this implies everything awesome I think it does doesn't it
20:21:35 <jrmithdobbs> Tekmo: A Prism into Value on lazy ByteStrings. ...
20:21:41 <fizruk> > Just (1, (2, 3)) ^? _Just._2._1
20:21:42 <lambdabot>   Just 2
20:21:52 <fizruk> marx2, ^
20:22:27 <marx2> ^? is like ^. but for Maybe?
20:22:53 <fizruk> marx2, ^? is infix preview
20:23:33 <fizruk> I guess you can think of it that way
20:24:13 <arbn> I feel like there's always an infix operator I don't know.
20:24:20 <arbn> So many squigglies.
20:25:02 <fizruk> > Just (1, (2, 3)) ^.. _Just._2._1
20:25:03 <lambdabot>   [2]
20:26:57 <phserr> I'm trying to understand getopt, but what should the behaviour of ReqArg be when there is no argument?
20:27:55 <phserr> I get no error or parsing error message on the tuple returned
20:28:02 <bobcrash_> Any chance one of you guys is near RPI in NY?
20:28:10 <phserr> I'm problem missing something about it
20:28:30 <phserr> *probably
20:30:24 <marx2> wow this worked, I totally didn't expect it to.  set (father . name) "Foo" <$> maybeFamily
20:31:37 <marx2> I just started learning lenses 20 minutes ago and I have little idea what's going on, but I like the results. I think I"ll stick with named functions for now though
20:31:43 <jrmithdobbs> Really?
20:31:49 <fizruk> > _Just._1 .~ "Foo" $ Just (1, 2)
20:31:50 <lambdabot>   Just ("Foo",2)
20:32:44 <zomg> Lens is like for the people who think Haskell syntax doesn't have enough special characters as is
20:32:46 <zomg> :D
20:33:20 <dmwit> phserr: Show us your code, what you tried, what you expected, what happened instead, etc. The usual.
20:33:23 <dmwit> ?hpaste
20:33:24 <lambdabot> Haskell pastebin: http://lpaste.net/
20:34:12 <jrmithdobbs> > _Just._1 (+1)  $ Just (1,2)
20:34:13 <lambdabot>   No instance for (Control.Lens.Tuple.Field1
20:34:13 <lambdabot>                     (Data.Maybe....
20:34:33 <fizruk> > _Just._1 %~ (+1) $ Just (1, 2)
20:34:34 <lambdabot>   Just (2,2)
20:34:45 <marx2> zomg I dislike the overuse of operators too, and I don't plan to use them for now. but compared to digging out data from some nested structure, modifying it, and then building it back together, this is a huge win
20:34:58 <jrmithdobbs> ipad corrected out the operator ha
20:40:53 <ReinH> (&) is often used with setters:
20:40:56 <ReinH> > Just (1,2) & _Just._1 %~ (+1)
20:40:58 <lambdabot>   Just (2,2)
20:41:07 <dmwit> > text "dmwit"
20:41:08 <lambdabot>   dmwit
20:41:44 <clay> what do you think about this?  "Haskell is the most common modern example of a purported pure functional programming language however the mutable reference feature of its IO monad effectively renders it impure"
20:42:08 <dmwit> "meh"
20:42:23 <ReinH> clay: not really?
20:42:28 <dmwit> It's not really precise. But I'm pretty tired of long discussions about it.
20:43:02 <simpson> If only "pure" and "functional" meant things.
20:43:25 <dmwit> Do they not?
20:43:26 <ReinH> unsafePerformIO is the usual canard for haskell not being Really Pure For Realsies
20:43:28 <clay> I am wondering if they are wrong, and if so why? I am pretty new to haskell and that line makes sense. it is from http://en.wikipedia.org/wiki/Purely_functional btw
20:43:31 <simpson> Okay, "pure" means a thing. "functional" doesn't.
20:43:50 <dmwit> Yes it does. "functional" means "functions are first class"
20:44:01 <simpson> Oh. Like C?
20:44:03 <silasm> people can program in Binary Combinatory Logic if they really want to. They won't get much done.
20:44:13 <dmwit> Are functions first-class in C?
20:44:19 <dmwit> I don't think so. Function pointers are first-class.
20:44:32 <simpson> I don't grok the difference.
20:45:25 <dmwit> Okay. Can I construct a new function, never before seen, at runtime in C?
20:45:43 <silasm> dmwit: when I refer to a "functional language" I make sure to add some sort of recursion optimization, e.g. tail recursion. More and more languages are adding the ability to pass functions as data, etc.
20:45:46 <bobcrash_> it'll take a lot of boiler-plate to do currying in C, or anonymous functions (the boiler-plate being them not being all that anonymous)
20:45:50 <dmwit> For example, the user types in a number, and I want to construct the function that adds that number to its argument.
20:46:02 <simpson> dmwit: Yes. Can you do it portably? Good question! I don't know.
20:47:00 <dmwit> I am reading "not portably" as meaning "requires features which are not a part of the C standard". Is that accurate?
20:47:35 <clay> ReinH: why cant IO references be considered for haskell not being pure? it seems like a good argument against it being pure, and I dont have enough insight to respond to it
20:48:10 <ReinH> clay: Because no one says that "Haskell is a completely pure langauge"
20:48:11 <silasm> clay: the issue is without that impurity nothing happens.
20:48:35 <silasm> Haskell does a better job of segregating pure code from nonpure code in an organized way
20:48:36 <ReinH> if it were, it would also be useless
20:48:50 <clay> ReinH: isnt it if we ignore unsafePerformIO?
20:48:59 <ReinH> clay: no
20:49:41 <simpson> dmwit: Yeah. I'm thinking a little more about this.
20:49:48 <dmwit> clay: The usual argument involves differentiating between evaluation and execution.
20:50:15 <simpson> dmwit: So what about things like FORTH where there are not functions in the normal sense of the word?
20:50:26 <dmwit> clay: "readIORef foo" evaluates to the same thing every time. When the runtime system gets to that evaluated thing, it may execute something which reads a different value from that ref; but the instructions we give to the runtime system are always the same.
20:50:36 * hackagebot krpc 0.4.1.1 - KRPC remote procedure call protocol implementation.  http://hackage.haskell.org/package/krpc-0.4.1.1 (SamTruzjan)
20:50:53 <dmwit> simpson: My personal reaction would be that if there are no functions, the language is not functional.
20:51:13 <ReinH> dmwit: Or constructing some RealWorld state such that Haskell + this state provides pure IO
20:51:28 <ReinH> i.e. pretending that we know a priori what getChar will do
20:51:28 <clay> dmwit: so would you say that wikipedia line is incorrect? it is the opposite of what is claimed in the article about haskell
20:51:52 <dmwit> clay: I would say it, and I did say it.
20:53:12 <ReinH> If you want to pose hard problems for Haskell's purity, they look more like: what hapens with Int operations in overflow situations?
20:54:43 <scott_> ReinH: Overflow doesn't break referential transparency
20:54:46 <clay> ReinH: clay: Because no one says that "Haskell is a completely pure langauge" <-- actually many people say that, even wikipedia contradicts itself and calls haskell purely functional on other pages. seems like there is no consensus on this, even in this channel :)
20:55:44 <ReinH> clay: well they should stop p
20:55:45 <ReinH> :p
20:56:08 <ReinH> scott_: it means that the same program with the same inputs can yield different results (on different architectures)
20:56:10 <simpson> dmwit: Okay, so I think that ANS FORTH qualifies as functional. Words are functions, values, and new words can close over values passed in by old words.
20:57:04 <marx2> ReinH, is that true even if we ignore GHC extensions, like unsafePerformIO and friends?  ie just core haskell
20:57:07 <dmwit> simpson: cool!
20:57:08 <scott_> ReinH: I suppose Int is a different type under the same name when you switch architectures, so that's a bit evil
20:58:29 <ReinH> clay: When people say that IO is pure, what they usually mean is that IO actions themselves are pure. The ways you can manipulate IO actions are pure and referentially transparent. And so on. It is *executing* these actions that is impure.
20:58:34 <simpson> dmwit: I just get tired of people saying "X isn't functional," where "X" is usually Ruby or Python.
20:58:49 <dmwit> I would never say that about Ruby or Python.
20:59:03 <ReinH> simpson: Church-Turing correspondence means everything is functional. Can we go home now?
20:59:05 <simpson> You are a reasonable guy, though. :3
20:59:17 <dmwit> <3
21:00:16 <marx2> I am not familiar with ruby but python discourages functional programming to the point of Guido intentionally not implementing tail call optimization (because people would use it..) and threatening to remove map, filter, reduce every once in a while
21:01:51 <simpson> marx2: TCO isn't functional, apparently. (Additionally, Python's execution model makes it undecideable to do it at compile time.) Also one can build map, filter, and reduce if one wants, from *the builtin syntax*.
21:02:37 <ReinH> Any language with built-in list comprehensions is already giving a strong nod towards functional programming
21:03:06 <ReinH> even though Python manages to make them imperative-looking
21:04:53 <marx2> simpson, TCO isn't functional, what does that mean?  and sure you can rebuild those functions, but it goes to show what attitude designer of the language has toward the functional programming. I am not sure by what definition is python a functional programming language
21:05:18 <simpson> marx2: It has functions as first-class values and can build new functions at runtime, apparently.
21:06:08 <marx2> even though the language and it's creator discourage functional programming and encourage OOP and imperative programming filled with state?
21:06:16 <dmwit> Yes.
21:06:36 <marx2> then it's a pretty useless definition
21:06:47 <dmwit> What style is encouraged has no impact on what style is possible.
21:06:58 <simpson> marx2: Really? Scheme permits objects and imperative programming and mutability too.
21:07:16 <marx2> but it often has impact on what style is possible without bending backward
21:07:19 <simpson> (set!) is a thing, after all.
21:07:37 <marx2> simpson I am pretty sure I used the word "encourage" not "permit"
21:08:08 <simpson> marx2: IYSS.
21:09:32 <dmwit> TIL an even more infuriating response than "u mad bro"
21:09:49 <joelteon> wha is it
21:09:53 <dmwit> IYSS
21:10:05 <joelteon> why make it an acronym
21:10:11 <dmwit> RSI
21:10:19 <joelteon> oh
21:10:39 * dmwit tries to work in another TLA and doesn't quite succeed
21:10:46 <clay> I have read some more and the argument seems to be that effects dont execute until they reach main?  i dont really understand the difference
21:10:50 <simpson> It stands for "I disagre with you, but I cannot shake your opinion and won't belabor the point."
21:10:53 <joelteon> what about an xTLA
21:11:39 <clay> ..between haskell and C in this regard. effects in C dont execute until they reach main either
21:11:46 <harovali1> if it depended solely on Guido van Rossum's desire, lambda, reduce and such would be rapidly taken apart the subsequent python versions.
21:11:55 <dmwit> clay: The difference will become quite apparent the first time you try to write "foo = newIORef" and then use "foo" in several different places in your program as if it were a shared mutable reference. =)
21:12:16 <simpson> GvR also is wrong about networking. Oh well. He's not perfect. No language designer is perfect any more than any language is perfect.
21:12:25 <scott_> clay: The idea is putStrLn "foo" always evaluates to the same thing - an IO action that prints foo when executed. So putStrLn is referentially transparent
21:13:14 <scott_> clay: You can see that putStrLn "foo" doesn't just execute by itself, it just evaluates to an IO action let x = putStrLn "foo" in x >> x
21:13:27 <harovali1> what makes his networking thinking wrong ?
21:13:33 <dmwit> clay: Anyway, after all this time, we now came to the reason for the second half of the first sentence I replied to you when you asked. =)
21:13:46 <ion> clay: This may or may not be helpful: “What is inside Haskell IO?” https://gist.github.com/ion1/7154691
21:13:52 <dmwit> clay: namely, "but I'm tired of long debates about it" -- because in the end it's not what matters
21:14:09 <dmwit> The Haskell difference that matters is that IO is first-class.
21:14:34 <dmwit> You can pass IO actions around and choose when they get executed. That's a big deal, and exploited a lot.
21:15:26 <dmwit> In other languages, you have to manually thunk such things -- e.g. by passing callbacks instead.
21:15:48 <ReinH> dmwit: I'm going to let "choose when they get executed" go this time, but I am watching you. ;)
21:16:18 <clay> thanks I am still processing all that
21:16:26 <dmwit> ReinH: What would be more precise?
21:16:53 <ReinH> dmwit: "gently suggest to the GHC runtime when it might desire to execute them"? ;)
21:17:01 <dmwit> no
21:17:09 <dmwit> the runtime has no choice about execution order
21:17:12 <dmwit> only evaluation order
21:17:33 <ReinH> I didn't say order.
21:17:38 <ReinH> And neither did you. :p
21:18:12 <dmwit> I'm confused about what your objection is.
21:18:27 <ReinH> dmwit: it's a very pedantic one :)
21:18:39 <ReinH> and depends on the meaning of "when" and "execute"
21:20:19 * dmwit shrugs
21:20:20 <dmwit> IYSS
21:20:55 <ReinH> "when" in a temporal sense is still up to GHC, but you are right ofc that you have control over ordering.
21:21:22 <ReinH> dmwit: but I'm derailing so I'll stop
21:24:49 <clay> Is putStrLn like a template what should runtime? and it just returns template instead of printing?
21:25:17 <clay> of what should the runtime do*
21:25:25 <scott_> clay: Essentially, yes
21:26:36 <clay> when would that difference matter though, in practice?
21:27:05 <dmwit> clay: Just to be clear about what question you're asking: what is the different thing you're comparing it to?
21:28:03 <clay> dmwit: compared to other languages where putStrLn equivalent just prints
21:28:22 <dmwit> Okay, so you want putStrLn :: String -> ()?
21:28:59 <ion> clay: It lets us know that if the type doesn’t say “IO” it won’t have side effects. It lets us limit the volume of the code we need to be especially careful about.
21:29:23 <clay> dmwit I want to understand when (if anywhere) the differenxe between returning template va directly printing matter
21:30:20 <clay> ion yeah i get that. but I am talking about cases when we are already in IO
21:31:05 <dmwit> clay: Right, I get that. I just want to make sure we're setting up the rules carefully.
21:31:14 <dmwit> So that when I point out something unsettling, you don't say I cheated. =)
21:31:43 <dmwit> (If I can point out something unsettling, of course!)
21:32:45 <clay> let me rephrase. when we are already in IO why (and if it does, when?) would the difference between printing directly vs building up a template for runtime matter
21:32:46 <ion> Since IO actions are first-class objects we can also use the combinators we’re used to with other objects with similar shapes with them.
21:33:25 <dmwit> clay: This "when we are already in IO" question is what I'm getting at. If you are not returning a template, what *are* you returning?
21:33:36 <dmwit> "in IO" means "returning an IO template"
21:33:44 <dmwit> So your question is not self-consistent.
21:34:34 <dmwit> (And I think making it self-consistent may result in a lightbulb moment for you, which is why I'm insisting that you be careful here!)
21:34:49 <clay> I dont know what we would return.. I am trying to make sense of this
21:35:04 * dmwit nods appreciatively
21:35:15 <dmwit> So, I have a proposal for what it would return.
21:35:24 <dmwit> The same as ever, but with the "IO" stripped off.
21:35:34 <dmwit> e.g. getLine :: String, putStrLn :: String -> (); etc.
21:35:52 <dmwit> What do you think about that?
21:35:59 <clay> yeah I see your point
21:36:19 <dmwit> Right. So now I write foo = [getLine, getLine, getLine]
21:36:25 <dmwit> and then main = print (foo !! 2)
21:36:34 <dmwit> what happens? How many lines does it ask for before it prints?
21:36:47 <clay> one?
21:37:00 <dmwit> Really?
21:37:28 <dmwit> Okay, here's a trickier one, then.
21:37:38 <dmwit> Suppose I write main = print [foo !! 2, foo !! 1]
21:37:46 <dmwit> which order do the lines you type in print, and why?
21:38:03 <dmwit> print [foo !! 2, foo !! 2] -- how about now?
21:39:00 <dmwit> I dunno. Maybe you can cook up answers to these questions, and even come up with a rule for understanding them.
21:39:05 <dmwit> But it seems very strange to me.
21:39:13 <dmwit> It's on odd situation.
21:39:50 <dmwit> Namely, because *the way you use a value* affects what IO is done, and in what order.
21:40:11 <dmwit> When it comes time to say what happens when you have a where binding, I get even more confused. =)
21:40:55 <clay> are other getLines not done because of lazyness or?
21:41:14 <dmwit> Well, that's sort of the point.
21:41:27 <dmwit> You have to come up with an answer to that question, and any answer you pick is bound to be surprising.
21:41:44 <dmwit> Certainly you have to hope that laziness can prevent IO from happening.
21:42:07 <dmwit> Or else it means somehow at runtime you have to inspect values arbitrarily deeply to see if they do IO before deciding whether to evaluate them lazily or strictly.
21:42:11 <dmwit> And that reeks of halting problems.
21:42:49 <dmwit> But then you find that the fact that nobody is telling you what order to evaluate things in means you have no control over what order IO happens in.
21:44:39 <dmwit> So then somebody comes along and says, "wouldn't it be cool if we had a function (>>) which took two things and guaranteed that all the IO from the first thing happened before all the IO from the second thing?"
21:45:02 <dmwit> And it doesn't take many iterations after that to arrive at Haskell's current solution. =)
21:45:16 <clay> hmm
21:46:02 <dmwit> I suspect you find some part of this argument unconvincing. I'm happy to expand on any part of it, but you should say which part seems weakest to you. =)
21:46:17 <clay> was it the lazyness that caused some getlines to not evaluate?
21:46:23 <dmwit> yes
21:49:26 <clay> if Haskell wasnt lazy what would happen?
21:51:08 <clay> i am not sure what this proves except that haskell is lazy
21:53:26 <dmwit> You are absolutely right.
21:53:36 <dmwit> It is not necessary in strict languages, and for that reason usually not adopted.
21:54:17 <dmwit> (where here "it" is "a separate IO type constructor")
21:59:56 <dmwit> gotta run, g'luck
22:00:25 <clay> thanks for trying to explain
22:21:27 <enthropy> has somebody here used http://hackage.haskell.org/package/tables-0.3.1/docs/Data-Table.html ?
22:21:42 <enthropy> indirection with the data family in there is a bit hard to follow
22:22:19 <enthropy> as far as I can tell you can just store one key (but that's not what the documentation says is possible)
22:24:50 <codygman> How can I easily get the start of today with a UTCTime? (end also, but I figure it'll be the opposite)
22:26:10 <codygman> TOD
22:26:22 <ion> Try time{ utctDayTime = 0 }
22:26:28 <monochrom> UTCTime has two fields, utctDay and utctDayTime. perhaps set utctDayTime to 0. set utctDay to today
22:28:19 <ion> λ> (\time -> time{ utctDayTime = 0 }) <$> getCurrentTime
22:28:21 <ion> 2013-11-26 00:00:00 UTC
22:28:47 <codygman> ion, monochrom: Thanks!
22:30:48 <ion> Ooh, thyme comes with lenses. liyang++
22:37:19 <lpaste> mikeplus32 pasted “unrolling(ish?) a loop at runtime” at http://lpaste.net/96214
22:43:50 <lpaste> mikeplus32 annotated “unrolling(ish?) a loop at runtime” with “unrolling(ish?) a loop at runtime (annotation)” at http://lpaste.net/96214#a96215
22:45:10 <lpaste> mikeplus32 revised “unrolling(ish?) a loop at runtime (annotation)”: “+ output” at http://lpaste.net/96215
22:46:41 <mikeplus32> (see the bottom)
22:52:53 <jle`> > "You are not lonely and you do have friends."
22:52:54 <lambdabot>   "You are not lonely and you do have friends."
22:52:57 <jle`> aw thank you
22:53:58 <joelteon> > text "hello world!"
22:53:59 <lambdabot>   hello world!
22:55:46 * hackagebot fay 0.18.1.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.1.2 (AdamBergmark)
23:00:06 <DarkFox> Hello. Could someone explain to me how this is valid code? data A = B String | C B; let B "test" = C $ B "tester" -- and what that let is acturally doing because B "test" /= C $ B "tester"
23:00:28 <no-n> what's the haskell equivalent to python's "from foo import (a as x, b as y)"
23:01:02 <DarkFox> no-n: import qualified Data.List as L
23:01:12 <DarkFox> Or more commonly
23:01:21 <DarkFox> import qualified Data.ByteString as BS
23:02:01 <DarkFox> Then ... a = x; b = y :P
23:02:08 <DarkFox> You don't rename functions
23:02:19 <no-n> o
23:02:32 <DarkFox> If you want to rename them. You could import the library, do your renaming and then export them as a new module.
23:02:49 <no-n> ok
23:02:59 <no-n> you can't rename in the import line?
23:03:57 <scott_> DarkFox: data A = B String | C B is only valid if B is a type defined elsewhere
23:04:10 <scott_> no-n: You can't rename functions, no
23:05:12 <DarkFox> no-n: module Data.MyModule (a, b); a = x; b = y
23:05:17 <DarkFox> no-n: import Data.MyModule :P
23:05:26 <DarkFox> that module is missing a where
23:05:56 <DarkFox> scott_: I meant C A
23:07:31 <scott_> DarkFox: The let binding does nothing because it doesn't bind anything, try in ghci: let 2 = 3
23:07:46 <DarkFox> I see
23:08:09 <DarkFox> Still barely looks valid :P
23:09:02 <DarkFox> In practice, is there any time where you would acturally use a let like that with a Type / Constructor ?
23:09:07 <TravisD> scott_: Why isn't this an error? let 2 = 3 in 2 + 1
23:09:21 <scott_> DarkFox: Compare: let B a = C $ B "foo"
23:09:27 <scott_> DarkFox: Then evaluate a
23:09:45 <DarkFox> Only I see is "*** Exception: <interactive>:12:5-21: Irrefutable pattern failed for pattern :Interactive.B a
23:09:55 <DarkFox> Ignore text at the start
23:10:26 <scott_> TravisD: The let 2 = 3 binding doesn't bind anything, so it never needs to get evaluated
23:10:50 <TravisD> scott_: Ah, yeah, it seems like you shouldn't be able to bind a value to a value, or something
23:10:53 <DarkFox> scott_: That error?
23:11:17 <TravisD> scott_: I guess I'm surprised that it's allowed to type let 2 = 3 at all
23:11:32 <scott_> DarkFox: Yeah, it's saying pattern matching (B a) against (C (B "foo")) failed
23:11:32 <DarkFox> TravisD: +1
23:11:47 <scott_> TravisD: Yeah, it's fairly surprising
23:11:53 <DarkFox> It let it "let"
23:11:57 <DarkFox> O_O
23:12:13 <scott_> I don't think it ever makes sense to have no variables in the left hand side
23:12:42 <DarkFox> Unless IO?
23:12:43 <scott_> DarkFox: Nah, it didn't try to do the pattern match until you forced it by evaluating a in ghci
23:12:49 <DarkFox> I.e, give me random numbers
23:12:58 <DarkFox> Even then how many? :P
23:13:43 <scott_> The purpose of let is to introduce new bindings, so if you have no variables in the left hand side, you aren't doing anything
23:14:00 <TravisD> DarkFox: wouldn't you want to bind a name to the random numbers? You wouldn't bind some other non-random value or something
23:14:32 <DarkFox> I meant, not all functions take arguments
23:14:51 <ion> All functions take a parameter in Haskell. It’s not a function if it doesn’t. IO actions are not functions.
23:14:53 <cizra> Peaker: FREAKIN' AMAZING, it works!
23:15:19 <DarkFox> Noted
23:15:22 <cizra> ion: Zero-parameter functions and constants are rather the same thing in my head. Is what you're saying official Haskell canon?
23:15:24 * DarkFox o/ ion
23:16:04 <ion> cizra: http://conal.net/blog/posts/everything-is-a-function-in-haskell
23:17:00 <scott_> If you consider a -> b the type of functions, then constants aren't
23:17:01 <ion> cizra: A Haskell value is a function iff its type matches “a -> b” for some a and b (modulo constraints).
23:18:29 <cizra> Okay, thanks.
23:20:59 <TravisD> This really struck me from that post: "Or perhaps they’ve heard someone speak with confidence, and they confused confidence with understanding."
23:21:47 <scott_> Heh, that's a pretty good line to take to heart
23:22:52 <TravisD> Yeah, absolutely. Everyone always sounds like an expert
23:24:19 <codygman> How would I print an xhxm display from the number of seconds up to 23:59?
23:24:44 <codygman> couldn't I just conver it to a UTCTime and format the time?
23:25:07 <dmj`> Is there a paper that explains how to implement abstract algebra in Haskell, like semirings, semigroups, etc
23:25:13 <ion> > (5*60+59) `quotRem` 60
23:25:15 <lambdabot>   (5,59)
23:25:51 <ion> That doesn’t account for 23:60, though.
23:26:28 <ion> the 86401th second
23:26:34 <ion> st
23:30:09 <epta> dmj`: what is abstract algebra?
23:30:49 * hackagebot asn1-types 0.2.2 - ASN.1 types  http://hackage.haskell.org/package/asn1-types-0.2.2 (VincentHanquez)
23:31:51 <dmj`> epta: what do you mean
23:33:45 <dmj`> epta: the study of algebraic structures
23:38:32 <carter> most examples of how i'd use abstract algebra are kinda concrete: MATRICES :)
23:51:58 <Silverfalls> I have some code that's rather ugly, and I'm trying to make it cleaner using higher-order functions or something. I'm just looking for some advice on how to clean up/improve the code, the current algorithm works fine.
23:52:04 <Silverfalls> Here it is:
23:52:32 <lpaste> Silverfalls pasted “Code” at http://lpaste.net/96220
23:55:04 <identity> Silverfalls: sometimes, that isn't always trivial
23:55:06 <identity> unfortunately
23:56:28 <identity> the best thing one can do sometimes is really look at the logic of the code and think "what exactly is it doing, and how can I write this differently?" etc
23:58:49 <Silverfalls> identity: That's fine, I'm just looking for suggestions. Did you check out the code?
23:59:13 <identity> yes
23:59:29 <identity> It's hard to come up with suggestions without completely understanding the logic, etc
23:59:48 <jle`> is it idiomatic to say not.x, with no spaces
23:59:51 <jle`> i've been seeing it come up a lot
