00:02:12 * hackagebot zasni-gerna 0.0.2 - lojban parser (zasni gerna)  http://hackage.haskell.org/package/zasni-gerna-0.0.2 (YoshikuniJujo)
00:21:15 <haskell_noob> hey folks im trying to solve the first question here : http://www.haskell.org/haskellwiki/99_questions/1_to_10 and I came up with something like this : http://pastebin.com/90mH5pHp
00:21:18 <mauke> The paste 90mH5pHp has been copied to http://lpaste.net/95479
00:22:02 <Iceland_jack> haskell_noob: That's a nice solution, you might want to include an error case for the empty list
00:22:19 <Iceland_jack> @head
00:22:19 <lambdabot> Maybe you meant: keal help
00:22:22 <Iceland_jack> @src head
00:22:22 <lambdabot> head (x:_) = x
00:22:22 <lambdabot> head []    = undefined
00:23:18 <haskell_noob> thanks Iceland_jack ! also, the error i seem to be getting is something related to print : http://pastebin.com/nuQLvhDj
00:23:22 <mauke> The paste nuQLvhDj has been copied to http://lpaste.net/95480
00:23:41 <dmj`> print $ mylast l
00:23:46 <Iceland_jack> haskell_noob: That's just because of lack of grouping
00:23:53 <Iceland_jack> You should write: print (mylast l)
00:23:58 <dmj`> @typ print
00:23:58 <haskell_noob> ah i see
00:23:59 <lambdabot> Show a => a -> IO ()
00:24:00 <haskell_noob> makes sense
00:24:04 <Iceland_jack> otherwise Haskell will group that as: (print mylast) l
00:24:12 <haskell_noob> i see
00:24:48 <Iceland_jack> haskell_noob: 'a b c d' is grouped as '((a b) c) d'
00:25:31 <haskell_noob> Iceland_jack: i see, interesting
00:25:58 <Iceland_jack> @def plus3 a b c = a + b + c
00:26:00 <lambdabot>  Defined.
00:26:03 <Iceland_jack> > plus3 1 2 3
00:26:09 <lambdabot>   6
00:26:10 <Iceland_jack> > ((plus3 1) 2) 3
00:26:13 <lambdabot>   6
00:26:18 <dmj`> If I have a cabal file that produces 4 binaries, can I specifically build one of the binaries with a subset of the dependencies?
00:26:25 <Iceland_jack> @undef
00:26:25 <lambdabot> Undefined.
00:26:34 <dmj`> w/o having to reconfigure the whole project
00:27:31 <Iceland_jack> haskell_noob: Are you working on problem ⅱ now?
00:27:58 <haskell_noob> not yet Iceland_jack -- just messing around with solution one still
00:29:11 <Iceland_jack> OK, feel free to ask if you have problems
00:29:22 <haskell_noob> thanks a lot Iceland_jack ! :)
02:09:35 <satc> @pl \f n = n*(f (n-1))
02:09:35 <lambdabot> (line 1, column 6):
02:09:35 <lambdabot> unexpected "="
02:09:35 <lambdabot> expecting pattern or "->"
02:09:41 <satc> @pl \f n -> n*(f (n-1))
02:09:41 <lambdabot> ap (*) . (. subtract 1)
02:11:12 <satc> @hoogle ap
02:11:12 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
02:11:12 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
02:11:12 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
02:12:23 <Narvius> So yeah, is there a reason ap uses Monad instead of Applicative?
02:12:41 <Narvius> I mean, the former seems to be overkill in this case.
02:14:05 <nanothief> no, ap is just legacy, it should be the same as <*> for any monad instance
02:14:39 <satc> @pl \f n -> if n==0 then 1 else n*(f (n-1))
02:14:39 <lambdabot> ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)
02:14:45 <satc> what is if' here?
02:14:45 <Gorby__> father's mother is different from mother's father... but grandfather's father and father's grandfather is the same person... so this kind of relations can be modeled with some monoid I think... and then we can check if two description is the same thing reduces to the word problem on that monoid. however, the word problem is undecidable in general... hmm...
02:15:34 <Iceland_jack> satc: probably if' ∷ Bool → a → a → a
02:16:30 <nanothief> @type if'
02:16:31 <lambdabot>     Not in scope: if'
02:16:31 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
02:17:23 <Redz> are there some coding conventions for function parameter order?
02:18:44 <Iceland_jack> Redz: Consider which order suits partial application better
02:18:46 <dv-> well, you want the stuff that changes to be outside
02:18:49 <nanothief> It's defined in multiple packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:if' , with multiple different types unfortunately. I'm guessing its one of the first two though
02:19:25 <Iceland_jack> and consider how the arguments will be: big example of something which gets this wrong: runReader, runState, …
02:20:03 <Iceland_jack> sometimes it makes sense to give both definitions: (.) and (>>>), mapM_ and forM_
02:20:35 <nanothief> urg yes, my code is full of (`runStateT` someState) $ do
02:20:53 <nanothief> or flip runStateT someState $ do, depending on how I'm feeling...
02:20:57 <Iceland_jack> Yes.
02:21:10 <Iceland_jack> The reason for run* being wrong is that the state you're passing in is generally small while the monadic value is generally rather big
02:21:42 <Iceland_jack> which is the same reason why forM_ is useful: you're mapping a large monadic action over a small expression for a list
02:24:20 <Redz> its really difficult to decide. i have a function that gets a Line (vector/math) and a Double. while i write the code, i wish i had the line as last parameter, because i modify this line a lot. but than i think, that i will need to change the Double really often too.
02:25:11 <Iceland_jack> It's just a design decision, if both paramters satisfy either of the points I made earlier you may want to consider a separate flip'ped function
02:25:16 <nanothief> what does the function return?
02:26:03 <Redz> a value of type Vector.
02:26:04 <Redz> data Line = Line Vector Vector
02:27:31 <Redz> linPoint :: Line -> VecNum -> Vec
02:27:31 <Redz> type VecNum = Double
02:32:23 <Redz> uh. i think i got a plan. i put the Double at first place.
02:41:24 <pyr> good morning lambda folks
02:42:11 <pyr> I'm looking for examples of a somewhat open module/interface/protocol system in haskell
02:43:18 <pyr> My use case is loading a log implementation and having a function to log to it
02:43:28 <pyr> which doesn't know which impl it talks to
02:43:36 <pyr> it looks like typeclasses will help me there
02:43:57 <arkeet> you don't need a typeclass for that
02:44:15 <pyr> i'm just looking for a program doing that already do get a sense of how i should structure things
02:44:22 <arkeet> plain old values are good :-)
02:44:49 <pyr> arkeet: ah, you mean, a fn that takes a known data structure as input
02:44:58 <arkeet> maybe
02:45:14 <pyr> as in LogMessage -> IO ()
02:45:20 <arkeet> sure
02:45:31 <pyr> and then I just write as many functions adhering to that signature as necessary
02:45:52 <arkeet> something like pipes or machines might be of interest too
02:52:06 <pyr> machines seem to be really suited to what i'm trying to do
02:57:29 <pyr> conduit as well !
02:57:44 <pyr> arkeet: thanks for the pointers, not used to structuring haskell programs yet :)
04:26:02 <TovenaarKlus> Some advice for a novice haskell programmer? I want to make a loop, to accept input and output something in every iteration. How would I best accomplish this? With a recursive call?
04:27:38 <srhb> TovenaarKlus: Or check out Interact.
04:27:42 <srhb> interact*
04:29:27 <srhb> TovenaarKlus: But yes, having loop = do ...; loop -- is quite common
04:30:02 <TovenaarKlus> That interact looks useful.
04:30:07 <jophish> Yo yo yo
04:30:11 <srhb> TovenaarKlus: It is quite useful for simple things.
04:30:22 <TovenaarKlus> But are there any other ways to accomplish a loop? It would, for example, be handy if I could carry a state around.
04:30:46 <srhb> TovenaarKlus: Explicitly is one way: loop state = do ... loop newState
04:31:21 <TovenaarKlus> srhb, and the other way is..?
04:31:29 <volko> somehow all of these web frameworks hurt my head
04:31:41 <jophish> When compiling a language such as Haskell to a language without currying (such as LLVM IR or Assembly) What techniques are used? How would: foo x ys = map (\ a -> a + x) ys be implemented for example?
04:31:43 <srhb> TovenaarKlus: There are many. Another common one is something like StateT MyState IO
04:32:21 <jophish> As far as I can tell the most simple way is to replace every instance of currying with a function which returns a tuple of function pointer and arguments so far
04:33:56 <jophish> I can't really see what's happening in GHC, there is a lot of extra work being done which obfuscates what's happening (Garbage collection, lazy evaluation etc...)
04:35:36 <TovenaarKlus> srhb, Thanks. Do you know a good resource on this so that I could learn a bit about it?
04:36:01 <srhb> TovenaarKlus: What, exactly? State transformers? Or just carrying around state in general?
04:36:57 <Maxdamantus> jophish: you need to deal with basically the same thing with any language with variables that live longer than the function invocation they're created in.
04:37:21 <Maxdamantus> Well, it could be more complicated there.
04:37:27 <TovenaarKlus> srhb: State transformers and looping techniques.
04:37:32 <srhb> TovenaarKlus: let foo = liftIO readLn >>= modify . (+) >> get >>= \b -> unless (b>20) foo
04:37:33 <srhb> in runStateT foo 0 -- try that in your ghci (with import Control.Monad.State)
04:37:40 <jophish> Maxdamantus: of course, I'm wondering about nice ways to handle this
04:37:49 <srhb> TovenaarKlus: http://en.wikibooks.org/wiki/Haskell/Monad_transformers for instance
04:38:02 <Maxdamantus> GHC seems to actually create functions usable in C using the FFI.
04:38:37 <jophish> Maxdamantus: but they depend on the run time system running
04:38:43 <TovenaarKlus> srhb: Thanks!
04:39:21 <benneh> certain typeclasses have 'rules' associated to them, e.g. fmap f . fmap g = fmap (f . g) for Functor; does GHC know about these? e.g. can it use them to optimise your code?
04:39:29 <Maxdamantus> jophish: yeah, you can't create functions like that using actual C.
04:39:43 <Maxdamantus> which is why the way GHC interfaces with it is peculiar.
04:41:00 <srhb> benneh: Look up rewrite rules. :)
04:41:02 <Maxdamantus> if you do something like: foreign import ccall "foo" foo :: (CInt -> CInt) -> CInt -> CInt
04:41:45 * Maxdamantus doesn't know if that's allowed by the Haskell FFI or if it's just a GHC extension.
04:42:29 <Maxdamantus> (but in GHC, you just get an `int (*)(int)`, not something like `int (*)(void *, int)`
04:42:32 <Maxdamantus> )
04:42:50 <benneh> srhb: thanks :)
04:42:53 <donri> lol i made a function dependently typed before realizing i could just split it into two functions
04:43:46 <Narvius> AFAIK Haskell could be automatically parallelised; does GHC do anything in that direction?
04:44:47 <srhb> Narvius: http://stackoverflow.com/questions/4701207/current-status-of-automatic-parallelism-in-haskell -- I think the second answer is still accurate.
04:44:56 <Iceland_jack> Narvius: Short answer “not really”, you can find the long answer by seaching “Haskell automatic parallelization”
04:44:59 <srhb> (As is the first, I mean the summary of the second one is accurate :))
04:46:08 <Narvius> Heh. Thanks to you both. :)
04:46:15 <antique> I have some ascii commands I need to send to a server, what would be a good way to express the strings as types?
04:46:35 <Iceland_jack> What do you mean by ASCII commands?
04:46:46 <Iceland_jack> I assume you're not actually referring to the encoding
04:46:53 <identity> Narvius: Using monad-par, parallelization is so trivial it might as well be automatic ;)
04:47:10 <Iceland_jack> Narvius: Not so trivial to get speed-ups :)
04:47:11 <identity> there's also plain old parMap, which makes it very simple as well for simple cases
04:47:27 <Iceland_jack> I mean sure, if you don't care about speed-ups then parallelization is trivial!
04:47:32 <antique> the box actually talks in ascii only lol so I'm sending stuff like "his\r\n" to it and it performs the command
04:47:37 <identity> Iceland_jack: Hehe
04:47:47 <identity> Iceland_jack: well, the point still stands
04:47:51 <Iceland_jack> True
04:47:52 * hackagebot HPi 0.2.0 - GPIO and I2C functions for the Raspberry Pi.  http://hackage.haskell.org/package/HPi-0.2.0 (WJWH)
04:48:22 <identity> especially for problems that are Embarassingly Parallel(TM)
04:48:33 <Iceland_jack> If you have two, similarly expensive and pure computations f and g and you want to add their outcomes, parallelizing that in Haskell is easy
04:49:15 <Iceland_jack> + independent
04:49:26 <srhb> Speaking of monad-par, what does IVar actually stand for?
04:49:39 <Narvius> Oke.
04:49:49 <identity> srhb: hmm
04:49:50 <Iceland_jack> srhb: http://hackage.haskell.org/package/monad-par-0.3.4.5/docs/Control-Monad-Par.html Information flow variables
04:49:54 <identity> ah.
04:49:56 <srhb> Iceland_jack: Thank you :)
04:50:01 <Iceland_jack> Top of the documentation for next time ;)
04:50:55 * Iceland_jack . o O ⸨ hopes they don't come off as passive aggressive ⸩ :)
04:51:02 <srhb> Iceland_jack: It did, but nevermind :P
04:51:30 <srhb> Iceland_jack: I immediately clicked the communication: IVars on the right, and it wasn't described there (which is silly)
05:21:12 <pyr> when writing classes, how do you reference an instance of another class ?
05:21:33 <mauke> if you could reference an instance, what would you do with it?
05:21:58 <pyr> e.g: class IInput i { read :: i -> ISink s -> IO () }
05:22:19 <mauke> what
05:22:28 <tharper> you want s to be an instance of ISink?
05:22:32 <pyr> yes
05:22:40 <Iceland_jack> pyr: Make sure that you're not confusing OO classes and type classes?
05:22:47 <pyr> I probably am
05:22:47 <pyr> :)
05:22:55 <Iceland_jack> Well they're completely different
05:23:08 <mauke> the I prefix is a bad sign
05:23:13 <Iceland_jack> Indeed
05:23:16 <tharper> class IInput i where { read :: (ISink s) => i -> s -> IO() }
05:23:27 <tharper> but then again
05:23:32 <tharper> what is s? heh
05:23:39 <pyr> ok
05:23:58 <tharper> but that at least is the syntax
05:24:03 <pyr> (the I prefix comes from HDBC, i thought that would be idiomatic haskell)
05:24:45 <pyr> you guys would recommend against I prefixes then ?
05:24:54 <pyr> tharper: the "handle" for the sink
05:24:56 <srhb> pyr: I don't know what it means in this case.,
05:25:10 <tharper> pyr: I think it is entirely up to you
05:25:21 <tharper> pyr: I think it's hard to say without context
05:25:26 <tharper> as longas you don't mean "interface"
05:25:28 <srhb> And yes, if the 'I' makes sense (what does it stand for?) sure, keep it
05:26:08 <donri> suffixes seem more popular in haskell though
05:26:25 <pyr> https://gist.github.com/pyr/7398104
05:26:39 <pyr> that's my current type definition
05:26:54 <pyr> I kinda hate myself for forgetting about Sink s => a -> b -> c
05:26:59 <tharper> that doesn't seem crazy
05:27:00 <tharper> heheh
05:27:30 <srhb> Wouldn't it be better to have Sink be a superclass of Module then?
05:27:46 <tharper> ?
05:28:11 <tharper> a mod seems to take a sink and do something with it
05:28:25 <srhb> Ah hm, yes.
05:28:42 <pyr> I got all the little low levels bits correct for my current project, trying to make sure I glue things together correctly
05:29:09 <pyr> system programming in haskell has been plenty of fun
05:29:48 <Rembane> pyr: Are there any secret tricks? :)
05:30:00 <pyr> secret tricks for what ?
05:30:36 <Rembane> pyr: System programming in Haskell
05:31:00 <pyr> not really, the FFI interface lets you interact rather well with lower level interfaces
05:31:10 <pyr> and there's a surprising amount of modules already there
05:31:32 <pyr> e.g: i was surprised to find out there already was a System.INotify
05:32:51 <osa1> is there a way to generate C struct interface in a hsc file using hsc cosntructs?
05:33:22 <mauke> how do you mean?
05:33:34 <Rembane> pyr: Sweet.
05:33:55 <Rembane> pyr: That's really useful
05:34:10 <osa1> like generating functions with types Ptr CStruct -> FieldType and mutator for same thing
05:34:40 <mauke> osa1: sure, why not?
05:35:01 <osa1> mauke: how?
05:35:05 * iLike is confused with Yesod
05:35:30 <iLike> I want to add my own stylesheet to the scaffolding, but it seems it's not parsed.
05:35:36 <mauke> osa1: where exactly are you stuck?
05:36:00 <mauke> and why do you have to interact with pointers directly?
05:36:20 <osa1> mauke: I can use #peek struct_type, field for every field but I don't want to do this, I want to generate this automatically
05:36:28 <osa1> mauke: because I'm wiring a FFI binding?
05:36:36 <mauke> but those generally use Storable
05:36:43 <mauke> and not individual field accessors
05:36:46 <osa1> hm
05:36:50 <osa1> let me check what is storable
05:37:07 <mauke> i.e. you'd create a Haskell type that mirrors the C struct
05:37:24 <mauke> then you write serializers that convert from/to C
05:38:03 <osa1> okay, I'm confused because I can't see hsc preprocessed version of my hsc file
05:38:26 <mauke> but yeah, hsc means a bit of manual work
05:38:33 <mauke> I hear c2hs automates more
05:40:36 <osa1> so what does #def some_c_struct exactly generate in hsc2hs ?
05:41:37 <mauke> what you tell it to
05:41:45 <mauke> it inserts code verbatim
05:52:27 <osa1> I'm confused again . http://www.haskell.org/haskellwiki/FFI_cook_book#Working_with_structs this doesn't work
05:52:59 <osa1> after #include "mylib.h" and #def mystruct I'm getting "mystruct undeclared" errors
05:54:58 <skypers> how could I set debug build in order to understand what it’s going on in gdb?
05:55:44 <merijn> skypers: Not directly related, but ghci has a stepping debugger
05:56:25 <merijn> @quote cmccann stream.of.con
05:56:25 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
05:57:57 <srhb> In the same vein as: Lens is a library for increasing the difficulty level of type errors.
05:58:23 <edwardk> srhb: from a POSIWID perspective i agree. ;)
05:58:25 <skypers> 14:43 < lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
05:58:29 <skypers> :     D
05:58:33 <skypers> :t runWriterT
05:58:33 <lambdabot> WriterT w m a -> m (a, w)
05:58:49 <srhb> edwardk: Sorry. :P
05:58:58 <klugez> edwardk: POSIWID?
05:59:05 <edwardk> @google POSIWID
05:59:05 <lambdabot> http://en.wikipedia.org/wiki/The_purpose_of_a_system_is_what_it_does
05:59:05 <lambdabot> Title: The purpose of a system is what it does - Wikipedia, the free encyclopedia
05:59:22 <mauke> ahoy, lensmen
05:59:26 <klugez> Ah, okay.
05:59:46 <edwardk> basically don't listen to what people tell you something will do, look at what it does when used in practice. It gives a better basis for determining ground truth.
06:00:16 <srhb> (I didn't mean it seriously, by the way - lens is awesome)
06:00:35 <edwardk> srhb: hah, no worries. i confess the type errors make me somewhat sad, too.
06:00:45 <skypers> do you think using lift everywhere is sane?
06:00:57 <srhb> I'm sure if there was an easy way of making them more understandable, it would have been done already.
06:01:00 <skypers> I have a lot of stacked monad
06:01:14 <skypers> s
06:01:18 <skypers> and I often use lift
06:01:19 <mauke> lift a >> lift b = lift (a >> b)
06:01:22 <ikarus> I've got an interesting issue, I need to represent 0..infinity whole numbers only
06:01:28 <srhb> skypers: Not using mtl?
06:01:28 <skypers> I know mauke
06:01:29 <edwardk> skypers: i almost never wind up using lift, and I wind up with lots of deep transformer stacks
06:01:30 <osa1> #def in hsc2hs is definitely not copying definition to c file
06:01:34 <skypers> srhb: I do
06:01:42 <srhb> skypers: How come you're lifting a lot then?
06:01:48 <skypers> well
06:01:55 <mauke> do you even lift, bro
06:02:04 <srhb> mauke: :P
06:02:04 <ikarus> is there any practical easy way of doing it
06:02:08 <skypers> for instance, take WriterT w IO
06:02:11 <edwardk> skypers: the reasons folks wind up lifting is because they wnd up with multiple states, multiple environments, or multiple exception types. you can fix that
06:02:14 <skypers> you can call tell without lifting
06:02:22 <ikarus> other then say, representing infinity by -1
06:02:22 <skypers> put IO functions have to be lift up
06:02:29 <srhb> skypers: Sure, but there's liftIO for that
06:02:40 <edwardk> skypers: for IO actions i'll use liftIO, that lifts it all the way to the base
06:02:43 <skypers> edwardk: may I show you some code?
06:02:46 <edwardk> no chain of lifts.
06:02:48 <edwardk> sure
06:02:58 <srhb> skypers: All the other intermediate transformers should not need lifting if they're defined properly
06:03:38 <srhb> (Though I have seend a student try something a la StateT (StateT (StateT ... )
06:03:57 <skypers> https://github.com/skypers/skyoralis_samples/blob/master/src/Raytracing.hs#L48
06:04:02 <skypers> I have a lot of lift calls
06:04:43 <mauke> all those lifts can be merged
06:04:44 <edwardk> when i write code for transformers i almost always write it in the style of (MonadWriter w m, MonadIO m) => .... m a   to keep it general, promote mocking and testing, and avoid dependencies on the explicit order of transformers unless I really mean them.
06:05:23 <skypers> yeah, that sounds a great idea indeed
06:05:39 <mauke> uh
06:05:47 <mauke> is there anything unlifted in that function?
06:06:01 <edwardk> he calls lift at the end
06:06:05 <edwardk> er loop
06:06:11 <mauke> i.e. why isn't this plain IO?
06:06:19 <mauke> loop is all lifts too
06:06:22 <srhb> edwardk: In which everything is lifted
06:06:23 <srhb> Yeah
06:06:28 <edwardk> hah
06:06:33 <edwardk> true
06:06:57 <skypers> I’m quite experiencing transformers btw
06:07:37 <srhb> skypers: You can almost just remove them all and have run' = liftIO run
06:08:03 <zol> @src const
06:08:03 <lambdabot> const x _ = x
06:08:14 <skypers> I don’t really understand why srhb
06:08:16 <skypers> for instance
06:08:30 <zol> @src id
06:08:30 <lambdabot> id x = x
06:08:36 <skypers> runGL :: GL s a -> IO (Either e (a,s))
06:08:37 <srhb> skypers: Well, you're not even using ask, I think..
06:08:47 <skypers> srhb: not yet
06:09:27 <mauke> skypers: write your code without ReaderT
06:09:27 <skypers> I’m going to try avoiding so much lifts
06:09:28 <nanothief> wouldn't it be easier to just write run :: Word32 -> Word32 -> Bool -> IO ExitCode ?
06:09:45 <mauke> nanothief: or just run :: IO ExitCode
06:10:07 <skypers> mauke: I’m going to put some functions using those 3 three parameters a lot
06:10:19 <srhb> skypers: It seems you're doing this backwards, trying to force transformers on a problem where you don't need them
06:10:20 <mauke> skypers: that can be dealt with later
06:10:36 <skypers> I see
06:10:42 <mauke> there's no point in complicating things up front
06:11:01 <skypers> so you think I should start with a simple IO ExitCode
06:11:52 <mauke> yes
06:13:06 * hackagebot flexible-unlit 0.2013.314.0 - A configurable reimplementation of unlit  http://hackage.haskell.org/package/flexible-unlit-0.2013.314.0 (StijnVanDrongelen)
06:13:13 <skypers> I end up with that:
06:13:21 <skypers> https://github.com/skypers/skyoralis_samples/blob/master/src/Raytracing.hs#L48
06:13:30 <skypers> definitely clearer :D
06:13:57 <skypers> if I want ReaderT for sub-functions
06:14:13 <skypers> I’d make run :: Word32 -> Word32 -> Bool -> IO ExitCode
06:14:18 <skypers> and use runReaderT inside of it
06:14:43 <maikklein> in some languages you can write a float like this. 10.0f. Is it possible in haskell to write something like this 10ms?
06:14:54 <Iceland_jack> maikklein: no
06:15:00 <skypers> 10.0
06:15:05 <skypers> or
06:15:06 <mauke> ms 10
06:15:10 <skypers> (10 :: Float)
06:15:15 <mauke> skypers: or 10
06:15:19 <Sculptor> ok
06:15:25 <skypers> mauke: in ghci?
06:15:28 <mauke> yes
06:15:31 <skypers> huh?
06:15:45 <skypers> > show 10
06:15:46 <lambdabot>   "10"
06:15:50 <skypers> :t 10
06:15:51 <lambdabot> Num a => a
06:15:54 <skypers> not a Float
06:15:55 <frx> maikklein if you use 10.0 in a context where Float is expected it will be a float
06:15:59 <srhb> > 10 :: Float
06:16:00 <lambdabot>   10.0
06:16:00 <mauke> skypers: that defaults to int
06:16:10 <mauke> skypers: but 10.0 doesn't default to Float either
06:16:14 <mauke> so meh
06:16:15 <maikklein> ok so my best bet would be type Meters = Float , 10 :: Meters ?
06:16:17 <skypers> yeah, that’s why I said “or 10 :: Float”
06:16:22 <mauke> maikklein: no
06:16:23 <skypers> yeah
06:16:28 <skypers> it defaults to Fractional
06:16:30 <skypers> or Rational
06:16:31 <mauke> maikklein: also, ms is milliseconds, not meters
06:16:37 <mauke> skypers: no
06:16:42 <skypers> I never remember
06:16:45 <skypers> :t 10.0
06:16:45 <mauke> Fractional is not a type and nothing defaults to Rational
06:16:45 <lambdabot> Fractional a => a
06:16:54 <skypers> Fractional a
06:16:54 <skypers> yeah
06:16:55 <mauke> it defaults to Double
06:17:53 <mauke> @let a === b = cast a == Just b
06:17:54 <lambdabot>  Defined.
06:18:03 <mauke> > 10.0 === (10 :: Double)
06:18:06 <lambdabot>   True
06:18:09 <mauke> > 10.0 === (10 :: Float)
06:18:12 <lambdabot>   False
06:18:44 <Iceland_jack> mauke: Great, Haskell needed (===) :)
06:18:48 <mauke> inorite
06:18:55 <mauke> > 0 === (0 :: Integer)
06:18:58 <lambdabot>   True
06:19:10 <klugez> mauke: Where is `cast` from?
06:19:11 <Iceland_jack> why not go one step further! _ ==== _ = True!
06:19:16 <mauke> @hoogle cast
06:19:16 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
06:19:16 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
06:19:16 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
06:19:39 <ikarus> erm, is there any sensible way of handling integer infinity (like in Dijkstra's algorithm, etc) in Haskell, without assigning it some arbitrary value like -1
06:19:45 <mauke> Iceland_jack: a ==== b = read (show a) == b
06:19:50 * Iceland_jack shudder
06:20:16 <edwardk> ikarus: make up a numeric type extended with infinity
06:20:21 <skypers> yeah
06:20:39 <skypers> or using Maybe?
06:20:45 <ikarus> edwardk: was hoping someone else already did it and included it in the standard library
06:20:45 <Iceland_jack> @let a ==== b = read (show a) == b
06:20:46 <edwardk> data Inf a = Num a | Inf
06:20:46 <lambdabot>  Defined.
06:20:48 <Iceland_jack> > 5 ==== (5 :: Int)
06:20:51 <lambdabot>   True
06:21:04 <edwardk> ikarus: there are several such numeric types, but its not in the standard library
06:21:05 <Iceland_jack> maybe just `read a == b' would be better :)
06:21:10 <skypers> :t (====)
06:21:11 <lambdabot> (Eq a, Read a, Show a1) => a1 -> a -> Bool
06:21:29 <edwardk> skypers: the issue with Maybe is that Nothing compares as < Just a  so you'd expect it to be -Inf
06:21:35 <Iceland_jack> @let a ===== b = read a == b
06:21:36 <lambdabot>  Defined.
06:21:37 <Iceland_jack> > "646" ===== 646
06:21:40 <lambdabot>   True
06:21:47 <ikarus> skypers: mmmm, perhaps I guess, although infinity == Nothing is a tad odd
06:22:01 <Iceland_jack> @undef
06:22:01 <lambdabot> Undefined.
06:22:03 <skypers> sure it’s odd:D
06:22:03 <srhb> ikarus: It is. Don't do that.
06:22:07 <edwardk> > Just 12 < Nothng
06:22:08 <lambdabot>   Not in scope: data constructor `Nothng'
06:22:09 <lambdabot>  Perhaps you meant `Nothing' (impor...
06:22:12 <edwardk> > Just 12 < Nothing
06:22:14 <lambdabot>   False
06:22:21 <edwardk> ikarus: ^- it also compares wrong
06:22:22 <skypers> I think edwardk came with the best solution
06:22:27 <mauke> data X = InfNeg | Fin Integer | InfPos
06:22:35 <skypers> but hm
06:22:43 <skypers> 15:08 < edwardk> data Inf a = Num a | Inf
06:22:46 <skypers> is that even allowed?
06:22:48 <skypers> Num is a class
06:22:56 <mauke> it's a data constructor
06:23:02 <edwardk> skypers: Num there is a data constructor, its a term, not a type
06:23:08 <skypers> oh?
06:23:08 <klugez> The namespaces are different.
06:23:09 <edwardk> that pun works
06:23:32 <mauke> what's Inf - Inf?
06:23:33 <skypers> I always thought of Num as a class
06:23:34 <edwardk> data Foo a = Foo a  -- the first Foo there is at the type level, the second is a constructor at the term level
06:23:41 <mauke> skypers: I always thought of i as an integer
06:23:46 <skypers> I know that edwardk
06:23:47 <mauke> it's just an identifier
06:23:58 <skypers> mauke: well
06:24:00 <skypers> :i Num
06:24:06 <skypers> gives me a class definition
06:24:08 <mauke> skypers: that's a different Num
06:24:09 <maikklein> would it make sense to write this? newtype Seconds = Seconds Float ? This way the compiler could typecheck
06:24:09 <skypers> that’s why I said that
06:24:17 <skypers> :t Num
06:24:18 <lambdabot>     Not in scope: data constructor `Num'
06:24:18 <lambdabot>     Perhaps you meant `Sum' (imported from Data.Monoid)
06:24:22 <skypers> hm
06:24:30 <edwardk> sure, but thats because there isn't also a data constructor in scope with that name
06:24:36 <sipa> :k Num
06:24:37 <lambdabot> * -> Constraint
06:24:49 <geekosaur> yes, edwardk was proposing a definition which would *create* a data constructor Num. it's not built in
06:24:51 <edwardk> it seems like it would collide precisely because we often pun the type and the data con, is all
06:25:03 <skypers> seriously
06:25:07 <edwardk> that was what i was getting at with the Foo example
06:25:10 <geekosaur> (for very loose definitons of "built in" even)
06:25:14 <skypers> you all make me feel I suck at haskell :(
06:25:24 <edwardk> you'll get better. =)
06:25:38 <Iceland_jack> skypers: For how long have you studied it?
06:25:50 <merijn> skypers: That feeling never goes away :p
06:25:54 <edwardk> it took me a long time to get productive in haskell
06:25:54 <skypers> Iceland_jack: one year, but I ping-ponged between Haskell and C++
06:26:08 <skypers> now I have my 3D engine in Haskell
06:26:09 <skypers> but hm
06:26:11 <mauke> I succ at Haskelk
06:26:18 <Iceland_jack> *groan*
06:26:30 <sipa> > succ "haskell"
06:26:31 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
06:26:31 <lambdabot>    arising from a use of `...
06:26:31 <skypers> there’re a lot of concepts and things I still don’t know
06:26:54 <merijn> skypers: That's because we're inventing new concepts at a rate faster than the average learning speed ;)
06:27:02 <skypers> yeah
06:27:04 <skypers> please stop that.
06:27:05 <skypers> :)
06:27:16 <donri> > upon last %~ pred $ "Haskell"
06:27:17 <sipa> > succ ('h','a','s','k','e','l','l')
06:27:17 <lambdabot>   "Haskelk"
06:27:18 <lambdabot>   No instance for (GHC.Enum.Enum
06:27:18 <lambdabot>                     (GHC.Types.Char,
06:27:18 <lambdabot>        ...
06:27:32 <skypers> sometimes I read folks here writing things I just CAN’T read
06:27:37 <skypers> thank you for the show sipa
06:27:38 <skypers> :D
06:27:45 <skypers> :t upon
06:27:53 <Iceland_jack> That issue should still be true for other languages, imagine how disappointing/boring it would be if you learn something for a year and all of a sudden you're a world expert :)
06:27:55 <skypers> allo lambdabot?
06:28:06 <sipa> @botsnack
06:28:06 <lambdabot> :)
06:28:08 <skypers> agreed
06:28:14 <skypers> but hm
06:28:20 <skypers> Haskell is very frustrating for that
06:28:24 <skypers> it is HUGE
06:28:31 <Iceland_jack> s/frustrating/motivational/ :)
06:28:32 <skypers> and it makes you better for sure
06:28:40 <skypers> even in other languages
06:28:49 <donri> > upon last . partsOf each %~ succ $ ('h','a','s','k','e','l','l')
06:28:50 <lambdabot>   Couldn't match expected type `[t0]'
06:28:51 <lambdabot>              with actual type `(GHC.Typ...
06:28:55 <donri> :(
06:29:20 <donri> > partsOf each . upon last %~ succ $ ('h','a','s','k','e','l','l')
06:29:22 <lambdabot>   ('h','a','s','k','e','l','m')
06:29:33 <mauke> how do I do base conversion with lens
06:29:39 <donri> :t base
06:29:51 <mauke> I want to do a lifted succ on the base36 interpretation of a string
06:30:06 <merijn> skypers: To be fair, you can be quite productive in haskell without knowing all those bits, though :)
06:30:07 <skypers> :t (%~)
06:30:07 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
06:30:12 <skypers> Profunctor :(
06:30:16 <merijn> skypers: That's lens magic
06:30:18 <edwardk> > base 16 # 12341
06:30:19 <skypers> what’s the heck is that :D
06:30:20 <lambdabot>   "3035"
06:30:28 <edwardk> :t (dimap)
06:30:29 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
06:30:38 <edwardk> that is what defines a profunctor
06:30:45 <mzero> mauke: that doesn't sound like a job for lens at all
06:30:49 <edwardk> you can map forward the second argumnt and backwards on the first
06:30:55 <merijn> edwardk: So it's a bifunctor with the arrows reversed, right?
06:30:56 <epta> How to :m + some module in ghci hiding particular function?
06:31:02 <mauke> mzero: if not lens, then what?
06:31:15 <mzero> I'd just code it - it's like two lines
06:31:26 <Iceland_jack> epta: import Data.List hiding (nub)
06:31:27 <mauke> it's one line but it's too long
06:31:29 <edwardk> > "129380" & base 16 +~ 1
06:31:30 <lambdabot>   "129381"
06:31:33 <Iceland_jack> it works in ghci now
06:31:37 <maikklein> I am very new to haskell and I am a little bit overwhelmed by all those libraries. What do you think of lenses?
06:31:45 <mauke> > "haskelk" & base 36 +~ 1
06:31:46 <lambdabot>   "haskell"
06:31:46 <mzero> really, edwardk ?
06:31:56 <edwardk> mzero: yes
06:31:59 <merijn> maikklein: Lenses are cool, but "lens" might be...overwhelming for newcomers
06:32:13 <skypers> 15:19 < maikklein> I am very new to haskell and I am a little bit overwhelmed by all those libraries. What do you think of lenses?
06:32:14 <mzero> okay - that confirms it - there is waaaaaaaaay too much in lens!  :-)
06:32:20 <merijn> maikklein: data-lens is simple and easy to understand, but significantly less powerful (i.e. no polymorphic "assignment"
06:32:24 <edwardk> mzero: that one is hidden in Numeic.Lens
06:32:25 <skypers> everyone here seem to agree the “default library to use” is lens
06:32:32 <skypers> but I started with data-lenses
06:32:32 <epta> Iceland_jack: import and :m + are not the same
06:32:35 <skypers> it’s quite nice :)
06:32:48 <mzero> no - skypers, with due respect to the awesome edwardk, I don't agree
06:32:51 <edwardk> mzero: its not in the default export list. =) people golf around with base a lot here on channel
06:32:53 <donri> @faq should @faq be changed to say "Yes, lens can do that!"?
06:32:53 <lambdabot> The answer is: Yes! Haskell can do that.
06:33:02 <Iceland_jack> epta: You can't hide with “:m +”
06:33:21 <mauke> @where+ faq' The answer is: Yes! Lens can do that.
06:33:22 <lambdabot> Good to know.
06:33:24 <mauke> @where faq'
06:33:24 <lambdabot> The answer is: Yes! Lens can do that.
06:33:31 <edwardk> mauke++
06:33:50 <mauke> maybe I should've called it _lens
06:33:51 <donri> \o/
06:33:52 <mauke> er, _faq
06:33:58 <edwardk> mauke: heh
06:34:33 <merijn> maikklein: Although, tbh, there's a lot of stuff you can do just fine without lenses so I wouldn't worry too much about it
06:34:40 <skypers> I don’t understand dimap
06:34:48 <skypers> from b and c
06:34:58 <skypers> it returns something with a and d
06:35:03 <skypers> I understand for the d part
06:35:06 <skypers> but the a part?
06:35:07 <merijn> skypers: It's like a cofunctor
06:35:08 <edwardk> skypers: consider p = (->)
06:35:10 <skypers> how is it even possible?
06:35:16 <skypers> with only a -> b ?
06:35:21 <edwardk> then work through the example type there
06:35:29 <merijn> skypers: i.e. "(a -> b) -> f b -> f a"
06:35:33 <edwardk> :t (dimap)
06:35:34 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
06:35:45 <edwardk> @djinn (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
06:35:46 <lambdabot> f a b c d = b (c (a d))
06:35:46 <skypers> merijn: is this cofunctor?
06:35:47 <merijn> skypers: The most intuitive example I know for that is a "sink" i.e. something that consumes values
06:35:59 <skypers> oh
06:36:00 <Iceland_jack> :t dimap :: (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
06:36:01 <lambdabot> (a -> b) -> (c -> d) -> (b -> c) -> a -> d
06:36:03 <merijn> skypers: It should be, unless I misremember
06:36:26 <merijn> skypers: So if you have a sink for "b"s then a function "(a -> b)" lets you turn it into a sink for "a"s
06:36:28 <skypers> so a cofunctor “goes back”?
06:36:44 <skypers> like the reversed version of a functor?
06:36:45 <edwardk> there are many other profunctors though, not just (->). Kleisli m, Cokleisli w, any Arrow can be a Profunctor.
06:36:49 <merijn> skypers: Yeah
06:36:53 <skypers> oook
06:36:55 <skypers> I got it then :)
06:37:08 <edwardk> there are others you can't glue together like arrows though.   data Indexed i a b = Indexed (i -> a -> b)
06:37:28 <edwardk> newtype Tagged a b = Tagged { unTagged :: b }
06:37:34 <mauke> .oO( a coilfunctor just sort of loops around )
06:37:56 <merijn> skypers: A bifunctor is "(a -> b) -> (c -> d) -> p a c -> p b d" (should be obvious, just imagine Either "(a -> b) -> (c -> d) -> Either a c -> Either b d")
06:38:06 <edwardk> skypers, merijn: cofunctor is an abuse of terminology i'm still questing to stamp out. Its a contravariant functor. contra /= co ;)
06:38:25 <skypers> yeah
06:38:28 <skypers> and hm
06:38:33 <merijn> skypers: As far as I can tell profunctors are a sort of hybrid where the first bit of the bifunctor is contravariant
06:38:40 <donri> contravariant and ntravariant functors
06:38:41 <mauke> so you could have a ntrafunctor?
06:38:49 <donri> \o/
06:39:06 <skypers> “ntrafunctor”
06:39:07 <skypers> hihi
06:39:13 <skypers> are you HIGH?
06:39:14 <skypers> :)
06:39:21 <merijn> edwardk: I was guessing, I wasn't sure whether they wre cofunctors or whatever :p
06:39:24 <mauke> skypers: let me tell you about coconuts
06:39:28 <edwardk> merijn: thats exactly what they are. you have a funny notion of composition though. the notion f profunctor composition gves you somethng that works a bit like how a relation is related to a function. you can map a relation forward or backwards with a function.
06:39:35 <skypers> coconuts crabs?
06:39:40 <mauke> they're just nuts
06:40:00 <skypers> hm
06:40:02 <skypers> a type like
06:40:07 <skypers> (a -> b) -> f b -> f a
06:40:11 <skypers> sounds a bit magic to me
06:40:14 <edwardk> given two profunctors we define data Procompose p q a b = forall c. Procompose (p a c) (q c b)
06:40:27 <edwardk> skypers: try t with newtype Predicate a = Predicate (a -> Bool)
06:40:33 <mauke> skypers: let f = I_accept_values_of_type
06:40:47 <skypers> yeah I can imagine
06:40:48 <edwardk> @djinn (a -> b) -> (b -> Bool) -> a -> Bool
06:40:48 <lambdabot> f a b c = b (a c)
06:40:49 <skypers> it’s like
06:40:52 <skypers> going backward
06:41:11 <edwardk> working over the argument to a function flips your intuitions around
06:41:22 <edwardk> Cont is hard because you have to flip them twice!
06:41:34 <skypers> thank you for your hints :)
06:41:36 <skypers> I just wonder
06:41:49 <skypers> are Dual related to the topic here?
06:42:34 <mauke> .oO( does your coide support de mpletion )
06:42:55 <edwardk> we can take a profunctor and define its dual profunctor, but thats largely unrelated to the topic at hand
06:42:59 <zol> Is it possible to use a binding multiple times in a pattern match? Example: myFunc wc (wc:ps) = ... ? So that the first argument is the head of the list?
06:43:06 <mauke> zol: no
06:43:11 <jophish> foo :: Moand m => (a -> m b) -> (c, a) -> m (c, b). I can't seem to find anything which does this. liftM second doesn't seem to work
06:43:19 <zol> mauke: Ok, thank you!
06:43:23 <mauke> zol: you can use guards to add equality constraints afterwards
06:43:29 <mauke> myFunc x (y : z) | x == y
06:45:38 <maikklein> question about cabal. I cloned a cabal repo "helm" and I tried to install it with "cabal install" but it just tells me "could not resolve dependencies, trying helm 0.6.0". It's a very ... minimalistic error report. Any ideas what that means?
06:45:47 <mauke> > let x@y = "co" in x ++ y ++ "nut"
06:45:48 <lambdabot>   "coconut"
06:46:08 <moops> jophish: built in, or doing it at all?
06:46:15 <jophish> moops: built in
06:46:22 <jophish> It's not too hard with a lambda
06:46:27 <moops> seems pretty specific
06:46:34 <zol> mauke: Thanks!
06:46:46 <jophish> (\(x,y) -> (,) x <$> foo y)
06:46:54 <bergmark> maikklein: try --max-backjumps=-1
06:47:01 <jophish> moops: I was hoping something in Arrows could do this for me
06:47:39 <moops> above my pay grade :P
06:47:46 <maikklein> bergmark, same error message :/
06:48:29 <merijn> maikklein: Try running with "-v3"
06:49:15 <merijn> maikklein: But it sounds like there's an unsolveable dependency constraint
06:49:40 <merijn> maikklein: i.e. two packages requiring incompatible dependencies or dependencies that are newer then what is available on Hackage
06:50:24 <jophish> This would also do: (a, m b) -> m (a,b)
06:51:28 <mauke> :t fmap . (,)
06:51:29 <lambdabot> Functor f => a -> f a1 -> f (a, a1)
06:51:37 <mauke> :t uncurry (fmap . (,))
06:51:37 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
06:51:45 <maikklein> merijn, okay thanks. The problem is SDL2
06:51:59 <jophish> heh, I may as well stick with my lambda :)
06:53:50 <jophish> :t second readFile
06:53:51 <lambdabot> (d, FilePath) -> (d, IO String)
06:53:58 <bz> meh
06:54:17 <bz> State s a's implementation of return is just (,)
06:54:23 <jophish> :t uncurry (fmap . (,)) . second readFile
06:54:24 <lambdabot> (d, FilePath) -> IO (d, String)
06:54:51 <jophish> :t (\(x,y) -> (,) x <$> readFile y)
06:54:52 <lambdabot> (a, FilePath) -> IO (a, String)
06:55:44 <jophish>  
06:56:51 <dv-> :t _2 %~ readFile $ (?x, ?y)
06:56:52 <lambdabot> (?x::t, ?y::FilePath) => (t, IO String)
06:57:34 <tharper> what...does that syntax mean
06:57:49 <tharper> what new sorcery is this?
06:58:02 <mauke> ?x is a placeholder variable
06:58:02 <lambdabot> Maybe you meant: v @ ? .
06:58:06 <hpc> (%~) is a lens thing
06:58:09 <hpc> _2 is a lens thing
06:58:13 <tharper> ah
06:58:21 <hpc> and '?' is from ImplicitParams
06:58:23 <mauke> :t ?hello
06:58:23 <lambdabot> (?hello::t) => t
06:58:27 <tharper> ah
06:58:28 <tharper> thanks
06:58:28 <mauke> :t ?hello ++ "world"
06:58:29 <lambdabot> (?hello::[Char]) => [Char]
06:58:39 <hpc> :t f . ?g $ "string!"
06:58:40 <lambdabot> (Show b, ?g::[Char] -> b, FromExpr c) => c
06:58:47 <mauke> :t length ?hello
06:58:48 <lambdabot> (?hello::[a]) => Int
06:59:02 <hpc> it's mostly used for typechecking tricks
06:59:11 <hpc> it is ostensibly meant to be used for dynamic scoping crap
06:59:13 <tharper> aye
06:59:15 <hpc> but that's evil
06:59:54 <tharper> seems nice for playing around when you want to say "put a thing of the right type here"
07:00:32 <merijn> tharper: That's pretty much what it was designed for, yeah
07:00:53 <mauke> I don't think it is
07:01:29 <yitz> @pl \f (x,y) -> fmap ((,) x) $ f y -- jophish
07:01:29 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . fmap . (,))
07:02:07 <jophish> thanks lambdabot. I'll put that in my code to make things easier to read later
07:02:09 <jophish> :)
07:02:31 <jophish> yitz: that was the first thing I tried :)
07:02:35 <yitz> hehe
07:05:30 <jophish> So, I have some code which used to call error "some error". I'm moving all this into the error monad
07:06:14 <jophish> There's one function which was already in the Reader Monad. Am I right in thinking that this should now me made into a ReaderT monad?
07:06:26 <jophish> where the parameter to ReaderT is the Error monad I'm using?
07:06:36 <jophish> or should they be stacked the other way round
07:07:07 <tomberek> does anyone mind sharing their NixOS configuration? (i see tons of packages on Hackage with NixOS distributions)
07:08:22 <ozgura> @msg lambdabot
07:08:22 <lambdabot> Not enough privileges
07:09:44 <ikarus> nope, mauke, uh, what should I read on actually making my own integer infinite act sensible ?, or what lib should I look at
07:12:41 <HardRock> Hey there Haskellers! Is there anyone here who's familiar with the Haskell bindings to the Windows Registry functions? I want to import some data from a file into the Registry, but run into an issue with the regSetValueEx function.
07:13:31 <gilligan_> Hm.. $ cabal-dev ghci --> 'cabal-dev: user error (cabal: Can't parse --info output of GHC)  Does anyone have an idea what the problem might be here ?
07:13:57 <hpc> gilligan_: what's ghc --info?
07:13:59 <hpc> @where hpaste
07:13:59 <lambdabot> http://lpaste.net/new/haskell
07:14:40 <gilligan_> hpc, http://lpaste.net/95483
07:14:59 <hpc> hmmmmmmm
07:15:38 <hpc> i like how ghc needs to know where perl is
07:15:44 <gilligan_> hpc, i was looking for some project template or tooling for bootstrapping a new haskell project an came across github.com/freels/haskell-project
07:16:01 <gilligan_> hpc, so I tried this and got stuck with the pasted error
07:16:53 <hpc> not sure what's wrong
07:17:32 <hpc> fwiw, my cabal-dev ghci doesn't work either
07:17:35 <hpc> with a different error
07:18:04 <hpc> it might be a non-issue depending on how you work
07:18:26 <gilligan_> hpc, thing is what i am trying to figure out right now :)
07:19:14 <gilligan_> hpc, i wrote a crappy little interpreter for a fantasy cpu architecture in haskell.. It's a total (incomplete) mess in a single file. Now I wanted to gradually decrapify it and write proper modules and tests etc
07:19:46 <gilligan_> hpc, but i find it hard finding the right route/setup/tooling
07:20:07 <gilligan_> hpc, the only given constant seems to be cabal
07:22:12 <yitz> gilligan_: in a new directory do cabal-dev install cabal-install. then take that cabal executable and use it instead of your current one. use cabal's built-in sandboxing instead of cabal-dev.
07:22:59 <hpc> feature request: sandboxed compilation by default for binaries
07:24:16 <yitz> hpc: you get that after running cabal sandbox init
07:25:35 <gilligan_> yitz, hpc : guess I will take it from here http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
07:26:26 * geekosaur would be moderately annoyed if pandoc required being in a sandbox, and more so if xmonad did
07:26:47 <geekosaur> ...and (some of) the mac packagers are already having trouble working around cabal
07:27:19 <geekosaur> (speaking of, I should suck the macbook onto 10.9 so I can poke a bit)
07:27:39 <mzero> ? context? as the mac pacakger of HP - I'm not sure what you're talking about
07:29:09 <geekosaur> carter has a couple times iterated a request from the homebrew folks for help getting cabal stuff to work nicely with homebrew. (I can't help with details, I don't run homebrew)
07:29:35 <geekosaur> (also I'm not sure where there would be a probem, the macports folks just used the same kinds of things linux packagers do...)
07:31:15 <pyr> tharper: thanks a bunch, got to a very pleasant state with a class
07:32:42 <mzero> ah - okay - I have no clue about homebrew or macports - I package for plain mac
07:33:04 <tharper> pyr: brilliant :)
07:39:32 <moops> anyone know of a simple (pure functional) language that has operational semantics available?
07:39:40 <moops> the purer the better
07:39:59 <prophile> core?
07:40:08 <prophile> the lambda calculus? :)
07:40:12 <skypers> hey
07:40:31 <adimit> moops: there are several in Pierce's TAPL.
07:40:32 <skypers> I need to allocate a C string and pass its pointer to a function (so char const **)
07:40:51 <skypers> I use withCString "the string" $ \buf -> theCFunction (castPtr buf)
07:40:56 <skypers> does it look okay to you?
07:41:21 <malvarez> wasn't McCarthy's original lisp (as defined in Recursive Functions of Symbolic Expressions) pure?
07:42:02 <moops> adimit: perfect! thanks
07:44:24 <adimit> moops: to see some of the more interesting examples, go to the chapters on System F, and System F_<, System F_ω
07:46:04 <adimit> simple examlpes are early on already; there's λ-calculus, which is arguably the simplest one. First untyped, then typed, then typed with subtyping, and then he adds polymorphism, then subtyping and polymorphism (which leads to the various system Fs)
07:46:33 <adimit> There is also a second book on advanced TAPL. I haven't read it yet, but it's high on my to-read list.
07:46:47 <HardRock> Is there anyone here who's familiar with the Haskell bindings to the Windows Registry functions? I want to import some data from a file into the Registry, but run into an issue with the regSetValueEx function.
07:47:17 <merijn> malvarez: Naah, pretty sure McCarthy's already had car/cdr
07:47:24 <merijn> malvarez: And updating of those
07:48:38 <skypers> who could help me?
07:48:40 <skypers> withCString "the string" $ \buf -> theCFunction (castPtr buf)
07:48:55 <skypers> I want something like Ptr (Ptr CChar) passed to theCFunction
07:49:02 <skypers> I wonder whether my stuff is okay
07:50:51 <malvarez> merijn: Not in the original definition, I don't think so
07:51:07 <HardRock> skypers: I'm fairly new to Haskell, but I have been looking at the foreign functions in the last few days and for what it's worth your code looks okay to me.
07:52:12 <malvarez> merijn: can't find any impure constructs in here http://www.cs.nccu.edu.tw/~chenk/Courses/PL/Papers/Mccarthy-Lisp60.pdf
07:52:23 <malvarez> but I only skimmed through it
07:52:23 <geekosaur> no, castPtr is wrong
07:52:46 <geekosaur> it says "pretend your (char *) is a (char **)", not "take a pointer to your (char *)"
07:53:03 <skypers> geekosaur: so I need to alloca?
07:53:05 <skypers> well no
07:53:25 <skypers> withWHAT?
07:53:27 <skypers> :D
07:54:08 <skypers> withCString >=> with? $ \buf -> …
07:56:10 <mauke> alloca $ \pp -> withCString "bojangles" $ \p -> poke pp p >> theCFunction pp
07:56:50 * geekosaur hasn't done that much with the FFI :(
07:57:19 <mauke> hmm
07:58:08 <mauke> withCString "..." >>= \p -> with p $ \pp -> ... should work, yeah
08:00:16 <osa1> is there a standard function for this f  [1, 2] ["a", "b"] = [(1, "a"), (1, "b"), (2, "a"), (2, "b")]
08:00:51 <mauke> liftA2 (,)
08:01:30 <osa1> liftM2 should also work, right?
08:02:01 <prophile> osa1: yup
08:02:31 <Shapeshifter> If I would like to write a graphical applications (like a status bar), should I use Xlib or are there more abstract frameworks I could use instead?
08:03:08 <osa1> is there a special name given to that function? liftM2 (,) is not descriptive IMO
08:03:27 <osa1> becuase it's more general than I want
08:03:31 <dwcook> You could call it cartesianProduct if you want
08:03:57 <osa1> that sounds better
08:05:15 <geekosaur> Shapeshifter, wx or gtk2hs?
08:05:49 <geekosaur> xlib or xhb not really recommended for general gui programming
08:07:03 <HardRock> I actually have a similar problem to skypers', but with the "withTString" function. It's type is "String -> (LPTSTR -> IO a) -> IO a". I want to use it to import a number into the Windows Registry as a dword. The number is stored as a Haskell String.
08:07:13 <HardRock> This was my solution: "withTString numberInString $ \ptr -> regSetValueEx hKey nameOfValue rEG_DWORD ptr (sizeOf (undefined::DWORD))"
08:07:57 <HardRock> It doesn't seem to work correctly though. For example, 32 is imported as 0x0032.
08:08:06 <HardRock> What am I doing wrong?
08:08:20 --- mode: ChanServ set +o copumpkin
08:09:28 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub' by copumpkin
08:09:41 <HardRock> It should be 0x00000032
08:10:21 --- mode: copumpkin set -o copumpkin
08:14:24 <bz> is there an haskell equivalent to python's "from <module> import <symbol> as <new name for symbol>"?
08:14:42 <bz>          a*
08:15:09 <geekosaur> no
08:15:27 <mlen> import qualified is close enough IMO
08:15:36 <bz> not really
08:15:47 <dv-> well you can do import qualified module as string and then new string = string
08:15:57 <bz> dv-: thanks!
08:16:33 <dv-> er i mean new string = string.function. just redefinition
08:19:47 <prophile> 0/w 2
08:19:59 <prophile> bad at irssi :(
08:20:02 <donri> not always though, not everything is first-class
08:20:24 <bz> yeah, modules aren't first-class
08:20:31 <Shapeshifter> geekosaur: So I'm trying to install wx through cabal, but it fails at some point with "Warning: No config found to match: /usr/bin/wx-config --version=2.9 --version-full" in /usr/lib/wx/config. If I run wx-config --list I see "Default config is gtk2-unicode-release-2.8". I suppose there's a discrepancy?
08:20:45 <donri> you can't rename record fields or data constructors
08:21:08 <geekosaur> Shapeshifter, this sounds familiar. fedora?
08:21:12 <Shapeshifter> geekosaur: archlinux
08:21:17 <geekosaur> oh, hm.
08:21:19 <donri> there's also a staging issue with TH
08:21:29 <geekosaur> I would have expected them to take the new one.
08:22:00 <Shapeshifter> geekosaur: so can't I just tell cabal to install a version that works with wxgetk 2.8?
08:22:24 <geekosaur> if you can figure out what that is, sure. probably have to talk to the wxhaskell folks
08:23:03 <geekosaur> am not an expert on it, just recall wxwindows had a major breaking change and the wxhaskell folks went along with it because it made some things easier for them
08:23:31 <Shapeshifter> geekosaur: nevermind, arch actually offers both versions as separate packages...
08:23:40 <FreeFull> Shapeshifter:  wx-config --version=2.9 --version-full  does give me a matching config
08:23:56 <FreeFull> Ah, that would be it
08:27:11 <Shapeshifter> good grief, there's always something. Now it went to install some more things, but now it failed with this: http://pastie.org/pastes/8469945/text " no matching function for call to ‘wxGridCellEditor::PaintBackground(wxRect, wxGridCellAttr*)" ... ?
08:34:33 <pome> i've got the following lambda function: \(a,b) -> f (g a) (g b)
08:34:51 <pome> is there a nice function for working with tuples and applying the same function to both?
08:35:32 <pome> there is the concern of course that i'm not planning to zip the results of (g a) and (g b) back up
08:35:49 <dv-> > (1,4) & both %~ (+1)
08:35:50 <pome> but presumably it's a common enough pattern that there exists something basic, no?
08:35:51 <lambdabot>   (2,5)
08:35:54 <prophile> (&&&)
08:36:09 <pome> hm
08:36:13 <prophile> well
08:36:15 <prophile> (***)
08:36:26 <prophile> > ((+1) *** (+1)) (4, 6)
08:36:27 <lambdabot>   (5,7)
08:36:35 <Iceland_jack> Cartesian product of two functions, (***)
08:38:28 <dv-> > (1,4) & both +~ 1
08:38:29 <lambdabot>   (2,5)
08:38:38 <roconnor> @pl \(a,b) -> f (g a) (g b)
08:38:39 <lambdabot> uncurry ((. g) . f . g)
08:38:52 <roconnor> @pl \g (a,b) -> f (g a) (g b)
08:38:52 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . f) .))
08:39:01 <roconnor> gah
08:39:08 <pome> roconnor: the first one is pretty much identical to what i have currently
08:40:39 <skypers> :t with
08:40:40 <lambdabot> Not in scope: `with'
08:40:41 <donri> :t bimap `asAppliedTo` (1,1)
08:40:42 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `(t0, t1)'
08:40:42 <lambdabot>     In the second argument of `asAppliedTo', namely `(1, 1)'
08:40:42 <lambdabot>     In the expression: bimap `asAppliedTo` (1, 1)
08:41:06 <donri> :t bimap f g `asAppliedTo` (1,1)
08:41:07 <lambdabot> (Num a, Num c, Show a, Show c, FromExpr b, FromExpr d) => (a, c) -> (b, d)
08:42:32 <ion> @type \f g -> uncurry (on f g)
08:42:33 <lambdabot> (b1 -> b1 -> c) -> (b -> b1) -> (b, b) -> c
08:42:44 <ion> @@ @djinn @type \f g -> uncurry (on f g)
08:42:45 <lambdabot>  f a b (c, _) = a (b c) (b c)
08:42:49 <ion> uh
08:42:56 <ion> oh
08:43:58 <lky> > bimap (+1) (+2) `asAppliedTo` (1,1)
08:44:03 <lambdabot>   <(Integer,Integer) -> (Integer,Integer)>
08:45:09 <skypers>   withCString src $ \p -> with p $ \buf -> glShaderSource sid 1 buf nullPtr
08:45:15 <skypers> sorry
08:45:17 <skypers> @pl   withCString src $ \p -> with p $ \buf -> glShaderSource sid 1 buf nullPtr
08:45:17 <lambdabot> withCString src (($ flip (glShaderSource sid 1) nullPtr) . with)
08:45:30 <skypers> holy cr*p that’s ugly
08:45:54 <FireFly> for being @pl output it's not that's bad...
08:46:20 <skypers> creating Ptr (Ptr a) is not uncommon
08:46:27 <skypers> something might exist for that
08:46:39 <FireFly> @pl \f g x y -> g (f x) (f y)
08:46:39 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
08:46:45 <FireFly> Typical @pl output
08:46:50 <skypers> :D
08:46:58 <skypers> pretty.
08:46:59 <skypers> ;)
08:47:23 <donri> make Ptr a monad!
08:47:35 <chrisdone> lol
08:48:56 <prophile> I think ptr could be a monad couldn't it?
08:49:09 <donri> Ptr should be a monoid with mempty = nullPtr; mappend = plusPtr  ;)
08:49:11 <prophile> in that Ptr a is in some senses Const Address a
08:49:21 <donri> because pointer arithmetic is awsumsauce
08:50:10 <tharper> GTFO
08:50:48 <pome> there are few better feelings when a function returns the same sequence as OEIS says is correct
08:51:09 <pome> 'than when', even
08:51:22 <roconnor> prophile: Const Foo is never a monad.
08:52:41 <skypers> 17:36 < donri> Ptr should be a monoid with mempty = nullPtr; mappend = plusPtr  ;)
08:52:44 <skypers> :D
08:52:52 <donri> doesn't work out, plusPtr has the wrong type :(
08:53:02 <skypers> yes
08:53:03 <donri> let's just make it a Num
08:53:04 <skypers> Int?
08:53:05 <skypers> right?
08:53:11 <pyr> is having a loop in a forkIO waiting on an MVar bad form ?
08:53:44 <brandonw> does anyone use the shnippet group of YASnippet snippets in emacs haskell-mode?
08:53:54 <pyr> I'm using this design to implement write sinks but I don't always see my side-effects being caried out
08:54:11 <prophile> roconnor: yes, sorry
08:54:17 <prophile> roconnor: just checked for myself and found out
08:54:20 <donri> pyr: can't you just use takeMVar
08:54:25 <prophile> damn right-identity
08:54:30 <chrisdone> pointer division, now that's the life
08:54:34 <pyr> donri: yes, that is what I'm doing
08:55:23 <donri> pyr: maybe stm would be better though
08:55:31 <pyr> donri: sink_input where sink_input = input <- takeMVar writebox ; sideffects input ; sink_input
08:56:38 <pome> i've written something that's taking ages to compute, and i'm not sure which function is the one which has been written badly
08:57:31 <pome> the main function has pretty much been borrowed from bird's pearls, and is in O(n) - if i post what I think might be causing the problem, could someone have a look?
08:57:34 <donri> pyr: you know the semantics of takeMVar?
08:57:51 <prophile> roconnor: Const () is probably a monad
08:58:15 <donri> pyr: it will block until there's something in the mvar, and then clear it, so something else must be writing it here
08:59:31 <pyr> donri: so that's not exactly my pb, it's my side-effects that don't always end up being realized
08:59:39 <donri> pome: maybe profile it on smaller input?
08:59:47 <pyr> donri: if i just putStrLn the content of the mvar, I'm fine
09:00:25 <roconnor> prophile: huh, you are probably right about that.
09:00:25 <donri> pyr: laziness issue maybe?
09:00:27 <pyr> donri: in one of my modules i loop on the mvar do carry out a "runRedis" action, this is what i don't see carried out
09:00:33 <roconnor> I'll be damned.
09:00:33 <pyr> donri: so yes, i guess lazyness issue :/
09:00:38 <donri> putStrLn will force it
09:02:58 <donri> pyr: also it sounds like you maybe want Chan instead
09:03:16 <pyr> i will look into chan
09:03:16 <roconnor> prophile++
09:03:19 <newsham> http://hackage.haskell.org/package/deepseq-1.2.0.1/docs/Control-DeepSeq.html ?
09:03:27 <prophile> \o/
09:03:34 * prophile updates CV
09:03:39 <pyr> donri: also just found out about forever in Control.Monad which is nicer than my loop
09:03:46 <donri> yep
09:05:31 <donri> pyr: and look at stm. i don't know if you need it here, but my attitude is to default to stm if it's not clear :P
09:05:48 <donri> you can implement MVar with STM but not TVar with IO
09:06:08 <pyr> donri: ok, will look at it
09:06:35 <pyr> donri: thing is, it looks like my problem is n ot stm / mvar related, but what i do in the IO monad
09:06:35 <donri> pyr: e.g. https://hackage.haskell.org/package/stm-2.4.2/docs/Control-Concurrent-STM-TChan.html
09:06:48 <pyr> btw, is there an "empty" IO () action ?
09:07:00 <donri> return ()
09:07:08 <pyr> of course :/
09:07:10 <donri> :)
09:07:58 <donri> you can also turn IO a into IO () with void
09:07:59 <donri> :t void
09:08:00 <lambdabot> Functor f => f a -> f ()
09:08:39 <donri> it's not usually the same as return () though
09:09:14 <donri> but "void ma" is the same as "ma >> return ()"
09:09:25 <roconnor> "the same as"
09:09:27 <roconnor> :)
09:09:38 <pyr> return is what i was looking for
09:10:27 <donri> roconnor: other than constraints and optimization. it's required by the laws to be the same, no?
09:10:37 <roconnor> yes
09:11:11 <pyr> ah ok !
09:11:15 <donri> "denotationally" i guess? :p
09:11:16 <newsham> ?let nop = return ()
09:11:16 <roconnor> Sorry I shouldn't have said anything
09:11:17 <lambdabot>  .L.hs:139:7:
09:11:17 <lambdabot>      No instance for (Monad m0) arising from a use of `return'
09:11:17 <lambdabot> ...
09:11:22 <pyr> seems I have a silent exception somewhere
09:11:42 <roconnor> Sometimes I worry too much about differences between the same thing.
09:14:24 <donri> :)
09:14:41 <pyr> donri: btw tchan looks great indeed for my needs
09:15:02 <donri> cool
09:15:32 <donri> pyr: could also look at pipes-concurrency
09:16:47 <pyr> will switch to one of those as soon as I understand that crazy output pb
09:17:55 <pyr> i down to this if anyone cares to look: https://gist.github.com/pyr/d5ba5c25b926e4c00556
09:18:38 <pyr> using hedis, anything after the lpush isn't executed (for instance if i stick another putStrLn)
09:19:22 <donri> "Calls to runRedis may thus block while all connections from the pool are in use."
09:19:26 <Iceland_jack> pyr: You don't need the parentheses
09:19:41 <pyr> donri: there's no blocking here, plenty of connections available
09:20:01 <pyr> Iceland_jack: just return ?
09:20:13 <Iceland_jack> no around the show's
09:20:43 <Iceland_jack> the 'R.runRedis conn $ R.lpush chan payload; return ()' can be replaced with 'void $ R.runRedis conn $ R.lpush chan payload'
09:21:29 <pyr> ack
09:21:43 <Iceland_jack> depends on preference
09:21:46 <pyr> so funny thing, https://gist.github.com/pyr/8611fc2803a55b6e726f
09:21:56 <pyr> mod_write is the fn that puts a value in the MVar
09:22:10 <pyr> if i call it twice, both side effects are realized, once: no side effects
09:23:18 <Clint> mm_freak: netwire seems to build fine with bifunctors 4 and profunctors 4
09:24:20 <jrmithdobbs> jesus christ, is there any way to override http-conduit's tls options to tell not to use SNI? this stupid appliance i need to access the rest api of responds to sni but doesn't respond correctly and has no way of fixing it's SNI responses so connecting with http-conduit ends with fun exceptions like:
09:24:51 <jrmithdobbs> *** Exception: TlsException (HandshakeFailed (Error_Misc "user error (unexpected type received. expecting handshake and got: Alert [(AlertLevel_Warning,UnrecognizedName)])"))
09:25:19 <jrmithdobbs> I can reproduce the problem connecting to the same host using openssl s_client and giving it a -servername param so that it tries to initiate sni
09:25:51 <jrmithdobbs> (it is self-signed and other broken crap too, but i can force off those checks and tell it what certs to expect, that's "good enough" for those things for now)
09:27:07 <jrmithdobbs> i can catch that exception but there doesn't seem to be a way to do so such that http-conduit will resume it's operation instead of resuming where i handle it which does me no good because there's no retry i can do, that I can tell, that wont trigger the SNI negotiation and the warning message at the tls layer that's throwing that exception
09:27:12 <jrmithdobbs> my head hurts :(
09:28:55 <jrmithdobbs> anyone had to deal with similar using http-conduit before and maybe have some suggestions? at the moment the http-conduit part of the code is like 3 lines lifted almost verbatim out the examples in it's docs, i'm overriding and ignoring cert checking and http status checking, but can't ignore that tls exception :(
09:38:38 * hackagebot web-plugins 0.2.3 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.3 (JeremyShaw)
09:38:40 * hackagebot clckwrks 0.19.2 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.19.2 (JeremyShaw)
09:43:13 <pome> http://lpaste.net/95486
09:43:38 * hackagebot clckwrks-plugin-page 0.2.4 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.2.4 (JeremyShaw)
09:43:43 <pome> given this works as i would like it to, can anyone see any problems / possible improvements?
09:45:09 <Saizan> @check \ x -> div (x + 1) 2 == quot x 2
09:45:14 <lambdabot>   *** Failed! Falsifiable (after 2 tests):
09:45:14 <lambdabot>  1
09:45:50 <dwcook> pome, you would like it to have a syntax error? ;)
09:46:17 <pome> dwcook: seems i copied it incorrectly, haha - let me try to work out where i lost it
09:46:41 <dwcook> The rightmost ) is extra
09:48:31 <pome> finally: http://lpaste.net/95486
09:51:08 <monochrom> the type sig looks wrong. why isn't it s :: Integer -> [(Integer, Integer)] ?
09:51:37 <pome> monochrom: entirely should be: yet another typo
09:52:13 <pome> i've got tonnes of type decs around the place, i made a mistake when changing them all to ints
09:52:47 <pome> monochrom: should be fixed
09:53:01 <dwcook> This is how it occurred to me to write it, by the way: s n = map (id &&& (n -)) [1..n `div` 2]
09:53:11 <dwcook> Not sure if you find that clearer or not
09:53:41 <dwcook> I glanced at what you wrote, copied just the test cases, and then wrote that to satisfy them
09:54:00 <dwcook> s/copied/looked at/
09:54:59 <moops> do function arguments (in the definition) just desugar to lambdas?
09:55:07 <pome> :t (&&&)
09:55:10 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
09:55:32 <FireFly> :t (&&&) `asAppliedTo` (undefined :: b -> c)
09:55:33 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
09:56:42 <monochrom> moops: I don't know what compilers do, and it shouldn't matter, but I would desugar to lambdas in my mental model, which also shouldn't matter
09:56:48 <pome> dwcook: that's interesting - thank you
09:57:15 <moops> monochrom: kk, mainly trying to see if thats problematic, if theres something im missing
09:57:52 <pome> dwcook: actually, upon actually looking at it, there's an issue
09:57:56 * monochrom prefers "the computer behaves like it does X" to "the computer does X"
09:58:21 <pome> the version i gave doesn't split into (x,y) where x=y
09:58:26 <moops> abstract interpretation ftw
09:58:33 <jrmithdobbs> monochrom: someone's been bitten by the real vs assumed behavior of the c runtime before haven't they
09:58:36 <jrmithdobbs> ;p
09:58:44 <pome> i.e., s 6 = [..., (3,3)]
09:58:58 <pome> not that it's a difficult problem to fix, just noting
10:01:10 <gfredericks> to implement Eq I just need ==, and for Ord I just need <, correct? not the full set of functions?
10:01:50 <donri> gfredericks: compare or <=
10:02:12 <pome> dwcook: i suppose that was mostly my fault for only including test cases of odd input values
10:02:45 <gfredericks> donri: oh interesting
10:02:48 <glguy> gfredericks: That kind of thing should be documented http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#g:4
10:03:18 <zugz> is there a cunning shorter way, without involving fromJust, to do "flip (maybe $ return ()) mval $ \val -> do [blah]"? Using MaybeT seems to give something of roughly the same complexity, but maybe I'm missing a trick?
10:03:24 <gfredericks> excellent, thanks!
10:03:42 * hackagebot acid-state-tls 0.9.0 - Add TLS support for Data.Acid.Remote  http://hackage.haskell.org/package/acid-state-tls-0.9.0 (JeremyShaw)
10:03:53 <gfredericks> that definitely fixed it
10:04:19 <pome> zugz: maybe (return ()) (const (do x)) mval
10:04:23 <pome> ?
10:04:33 <glguy> zugz: traverse_
10:05:24 <pome> zugz: sorry, i didn't read correctly
10:05:47 <glguy> or just writing out what you wanted to do would be significantly better than trying to fit it into 'maybe'
10:05:53 <zugz> traverse!
10:05:55 <monochrom> jrmithdobbs: no. instead, I recommend John Reynolds's http://www.cs.cmu.edu/afs/cs/user/jcr/ftp/typesabpara.pdf . even just the fable at the beginning.
10:05:58 <glguy> for_ is the flipped version
10:06:05 <zugz> glguy: beautiful, thanks
10:06:06 <glguy> (you shouldn't be using a lot of flip)
10:06:10 <glguy> Data.Foldable
10:07:00 <piezoid> hi
10:07:28 <piezoid> is there a instance for type isomorphic to Maybe ?
10:08:02 <piezoid> Traversable is too much because they can have multiple values
10:08:45 <quchen> You're mixing up multiple concepts here.
10:08:51 <quchen> First, there is no "IsMaybe" class.
10:08:58 <quchen> Second, Maybe is an instance of Traversable.
10:09:57 <piezoid> yes, but trees are Traversable too
10:10:29 <monochrom> I don't understand the question
10:10:36 <dwcook> Why do you need a class for that? Why not just use (Maybe a)?
10:10:53 <dwcook> A type isomorphic to (Maybe a) is just as good as it
10:10:53 <piezoid> I need a kind of "sequence" where the monadic action is optionaly run once
10:11:42 <piezoid> it's for yeod's FormResult a = FormSuccess a | FormFailure e | FormMissing
10:12:33 <dwcook> You could write a function FormResult a -> Maybe (Either e a) perhaps
10:12:42 <osa1_> which library to run timed IO operations?
10:13:01 <donri> :t traverse `asAppliedTo` Nothing
10:13:01 <lambdabot>     Couldn't match expected type `a0 -> f0 b0'
10:13:02 <lambdabot>                 with actual type `Maybe a1'
10:13:02 <lambdabot>     In the second argument of `asAppliedTo', namely `Nothing'
10:13:10 <dwcook> Wait no, because the e doesn't appear in the type
10:13:29 <donri> :t for `asAppliedTo` Nothing
10:13:29 <monochrom> perhaps e does appear in the type
10:13:29 <lambdabot>     Not in scope: `for'
10:13:30 <lambdabot>     Perhaps you meant one of these:
10:13:30 <lambdabot>       `T.for' (imported from Data.Traversable),
10:13:42 <donri> :t T.for `asAppliedTo` Nothing
10:13:43 <lambdabot> Applicative f => Maybe a -> (a -> f b) -> f (Maybe b)
10:13:43 <donri> ...
10:15:57 <jrmithdobbs> is there a way to get ghci to load everything not in base so that I can :step through it? i'm trying to find where an exception is originating from in code i didn't write =/
10:16:27 <jrmithdobbs> the debugging info, i mean, it seems to not let me step into the function throwing the exception since it's in another module
10:17:09 <piezoid> ok thx, I'll stick with the specific type (FormResult), it's not a problem for my application
10:17:31 <chrisdone> donri: have you seen Space Mutiny?
10:18:00 <donri> jrmithdobbs: recompile everything with -prof -fprof-auto and run the program with +RTS -xc  :P
10:18:03 <donri> chrisdone: nope
10:18:26 <jrmithdobbs> donri: there an easy way to do that with cabal-sandbox? (not a joke ;p)
10:20:06 <osa1_> can anyone recommend me some library to run timed IO operations (I need to update some gui periodically)
10:20:17 <merijn> osa1_: async?
10:20:42 <donri> duno, maybe if you delete it and recreate it and install with --enable-library-profiling --ghc-option=-fprof-auto or something like that
10:20:56 <donri> osa1_: netwire? :)
10:20:58 <osa1_> merijn: "package not found"
10:21:00 <osa1_> donri: heh
10:21:17 <donri> async is on hackage and in the platform
10:21:55 <identity> There once was a girl from Dundee // Who never wrote programs in C // She felt that destruction // Lacked the seduction // Of referential transparency
10:21:58 <identity> anyone heard that one before?
10:22:13 <osa1_> okay found it
10:22:14 <osa1_> thasnk
10:22:16 <osa1_> thanks*
10:23:36 <mzero> +1 identity
10:23:43 <jrmithdobbs> donri: worth a shot!
10:23:53 <monochrom> never heard of dundee // I only know of cookie // and share it, maybe
10:24:57 <jrmithdobbs> donri: taking much longer to build so that may actually do the trick ;p
10:25:00 <identity> I stumbled upon that limerick whilst googling for haskell user groups in denmark
10:25:16 <identity> which seem to be sparse, in that I can find zero.
10:25:31 <monochrom> come to Toronto, Canada. we have one. :)
10:25:58 <chrisdone> get on a horse now, you'll be there by january
10:26:25 <glguy> osa1_: http://hackage.haskell.org/package/base-4.6.0.1/docs/System-Timeout.html#v:timeout
10:26:49 <identity> Haha..
10:27:28 <osa1_> glguy: this is not what I want
10:27:41 <osa1_> I don't want a timeout, I want a timed event
10:28:09 <osa1_> e.g. I'll update a gui every n seconds no matter what happened to my data structures
10:28:15 <identity> osa1_: forever $ do wait; executeGuiAction;
10:28:29 <identity> osa1_: using whatever system.timeout provides
10:28:32 <identity> + forkIO
10:29:20 <glguy> osa1_: Then you can forkIO a thread that loops the updated delaying with threadDelay
10:29:36 <osa1_> yeah that should work
10:29:43 <identity> osa1_: yeah, threadDelay was the one I was looking for
10:29:57 <osa1_> where is threadDelay?
10:30:02 <identity> @hoogle threadDelay
10:30:02 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
10:30:02 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
10:30:02 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
10:30:10 <identity> lambdabot: thank you kindly
10:30:11 <osa1_> okay
10:31:24 <donri> jrmithdobbs: you'll need to build the executable with --enable-executable-profiling --ghc-option=-rtsopts or something like that
10:35:46 <hpc> osa1_: it's also worth pointing out that threadDelay uses the most terrible unit of time ever conceived
10:36:07 <monochrom> hehehe
10:37:05 <identity> hpc: kardashians?
10:37:16 <quchen> hpc: The minimum-microsecond?
10:37:32 <osa1_> hpc: what's wrong with microsecond?
10:37:52 <hpc> osa1_: you don't get that precise in practice, and it's not double seconds
10:38:15 <osa1_> okay so the problem is it's deceiving?
10:38:16 <hpc> no other API does microseconds as an int
10:38:25 <hpc> that i know of
10:38:26 <osa1_> hm
10:41:43 <jmcarthur> would be nice if it just took a DiffTime, but then it would need the time package
10:42:11 <jmcarthur> and of course, time isn't *that* convenient, although at least it's not deceptive
10:42:34 <hpc> double seconds is much less deceptive, imo
10:42:49 <hpc> threadDelay is a delightfully direct way to sleep a program
10:43:01 <hpc> on the level of ease that scripting languages enjoy
10:43:05 <hpc> and they all use double seconds
10:43:26 <jmcarthur> DiffTime has a Fractional instance, so this could be pretty direct too
10:43:34 <hpc> that's true
10:44:16 <hpc> DiffTime is implemented as Pico
10:44:28 <jmcarthur> an implementation detail
10:44:41 <hpc> which is implemented as Integer, interestingly
10:44:46 <jmcarthur> yep
10:44:49 <hpc> so i can see it working out fine
10:44:55 <hpc> better, in fact
10:45:03 <hpc> because now you can delay a thread for more than two damn hours
10:45:07 <jmcarthur> exactly
10:45:13 <hpc> make it so
10:48:50 <donri> replicateM_ (hours `div` 2) (threadDelay maxBound)  \o/
10:50:34 <identity> what image library should I be using if I want to be drawing bitmaps directly to the screen, etc?
10:50:37 <identity> gloss?
10:50:43 <identity> I want to write a mandelbrot viewer
10:51:44 <identity> s/image/graphics
10:51:50 <Iceland_jack> donri: mapM_ (forkIO ∘ forever ∘ putChar) [minBound…maxBound]
10:52:30 <tharper> so much unicode
10:52:45 <tharper> much symbol
10:52:46 <tharper> wow
10:54:01 <chrisdone> main = putStrLn “Yay, unicode!”
10:54:41 <donri> mapₘ forkᵢₒ
10:54:51 <chrisdone> foldl’
10:55:15 <donri> @let ∞ = forever
10:55:15 <lambdabot>  Parse failed: Illegal character ''\136''
10:55:18 <donri> :(
10:55:56 <chrisdone> :t let (∞) = forever in (∞)
10:56:12 <chrisdone> lambdabot sure is fail these days
10:56:41 <mauke> @ty ()
10:56:42 <lambdabot> ()
10:56:44 <mauke> :t ()
10:56:45 <lambdabot> ()
10:56:52 <ion> @hype ()
10:56:53 <lambdabot> ()
10:58:30 <ParahSail1n> what's @hype
10:58:39 <chrisdone> an autocorrection probably
10:58:41 <FreeFull> lambdabot has typo correction
10:58:44 <geekosaur> edit correction on @type
10:59:06 <FreeFull> @snack foods
10:59:07 * lambdabot would never hurt foods!
10:59:15 <ion> Typo correction would be “did you mean @type?”
10:59:25 <mauke> I'm feeling ducky
10:59:31 <ion> Let’s make GHC arbitrarily pick substitutions for any typos.
10:59:46 <ion> ghc -ffeeling-lucky
11:02:04 <haasn> chrisdone: blame elliott
11:02:12 <identity> @snack myself
11:02:12 * lambdabot activates her slap-o-matic...
11:02:15 <identity> @snack myself
11:02:15 <lambdabot> I'd rather not; myself looks rather dangerous.
11:02:16 <monochrom> @slip monochrom
11:02:16 <lambdabot> Come on, let's all slap monochrom
11:02:21 <identity> @snack myself
11:02:21 <lambdabot> Come on, let's all slap myself
11:02:25 <identity> wut.
11:02:39 <monochrom> snack -> slap
11:02:52 <monochrom> @botslap
11:02:52 <lambdabot> Unknown command, try @list
11:02:57 <monochrom> oh well :)
11:03:01 <monochrom> @botsnack
11:03:01 <lambdabot> :)
11:03:13 <monochrom> @nap monochrom
11:03:13 <lambdabot> Maybe you meant: slap faq
11:03:16 <donri> @robotstack
11:03:17 <lambdabot> Unknown command, try @list
11:06:10 <joelteon> @. pl undo (\h -> do { str1 <- hGet h 36; str2 <- hGet h 36; return (str1, str2) })
11:06:10 <lambdabot> ap ((>>=) . flip hGet 36) (flip (fmap . (,)) . flip hGet 36)
11:06:15 <joelteon> aww :(
11:07:24 <FreeFull> What did you expect?
11:07:35 <joelteon> I thought there would be a clever combinator I was missing
11:08:10 <Iceland_jack> joelteon: Not too dissimilar to something you could use (>=>) for
11:08:17 <Iceland_jack> hm, no never mind!
11:08:20 <joelteon> m <- a; n <- a; return (m,n)
11:08:25 <mauke> liftM2 (,) (hGet h 36) (hGet h 36)
11:08:27 <Iceland_jack> you can use liftM2 (,) though
11:08:30 <FreeFull> That h in the middle screws things up
11:08:31 <monochrom> you can always define a new clever combinator
11:08:32 <joelteon> oh yeah
11:08:44 <mauke> join (liftM2 (,)) (hGet h 36)
11:08:47 <Iceland_jack> I suppose you could use join
11:08:48 <Iceland_jack> yeah :P
11:08:52 <Iceland_jack> but don't use join though
11:09:00 <joelteon> why not
11:09:21 <Iceland_jack> I find it needlessly golfy
11:13:11 <jmcarthur> (join.liftM2) (,) (hGet h 36)
11:13:34 <jmcarthur> ah that was already done
11:13:39 <mauke> liftM join liftM2 (,) (hGet h 36)
11:13:42 <mauke> come at me bro
11:13:45 <chrisdone> join  with applicative isn't that bad
11:13:50 <Iceland_jack> I've long since given up
11:15:21 <jmcarthur> i find that a lot of expressions that initially look golfy actually end up providing a deeper insight into the structure of the problem
11:15:32 <jmcarthur> so long as the golfiness is in terms of number of tokens rather than number of characters
11:15:48 <Iceland_jack> jmcarthur: Absolutely no disagreement there
11:16:05 <Iceland_jack> it's only a matter of degree
11:16:06 <mauke> I just try to cram as many monad functions as possible in there
11:16:54 <jmcarthur> i wrap everything with (return.join) just for good measure
11:16:58 <jmcarthur> err
11:17:01 <jmcarthur> other way
11:18:36 <mauke> missed opportunity
11:18:39 <mauke> liftM join return
11:19:31 <jmcarthur> nah, just redfine (.) = liftM
11:19:36 <jmcarthur> *redefine
11:19:48 <mauke> why stop there? go all the way and (.) = fmap
11:20:27 <jmcarthur> because monad
11:20:49 <mauke> fmap fix return
11:21:16 <FireFly> or (.) = Control.Category.(.) :o
11:21:17 <tford> Hi, newbie here, a little lost.  I want to create a type that is like a list except that it "wraps around".  As input the construction of the object should take the list to be wrapped around.  Is there a way to do this with a data constructor alone?  This doesn't compile, but for e.g. data WrappingList a = WrappingList (cycle [a])
11:21:20 <chrisdone> (.) = Control.Category.(.) =p
11:21:25 <mauke> syntax error
11:21:31 <mauke> it's (Control.Category..)
11:21:32 <chrisdone> FireFly: hey stop stealing my thoughts
11:21:41 <FireFly> Oh, right
11:21:45 <chrisdone> mauke: we knew that
11:21:48 <chrisdone> ok, i knew that
11:21:58 <FireFly> I half-knew that :p
11:22:25 <mauke> :t [id, ($), ask, asks]
11:22:26 <lambdabot> [(a -> b) -> a -> b]
11:23:25 <tford> i have a feeling I may be taking the C++ word "constructor" and applying it to Haskell incorrectly
11:23:36 <mauke> yes
11:23:46 <hpc> :t [(.), fmap, liftM, join]
11:23:47 <lambdabot>     Occurs check: cannot construct the infinite type:
11:23:47 <lambdabot>       a1 = a0 -> b0 -> a1
11:23:47 <lambdabot>     Expected type: (b0 -> b0 -> a1) -> (a0 -> b0) -> a0 -> b0 -> a1
11:23:52 <hpc> :( join doesn't work
11:24:02 <tford> would I simply create a function which created a "WrappingList" from a list by calling "cycle" ?
11:24:09 <hpc> :t [(.), fmap, liftM, liftM2]
11:24:10 <lambdabot>     Occurs check: cannot construct the infinite type: a20 = a20 -> a20
11:24:10 <lambdabot>     Expected type: (b0 -> a20 -> r0)
11:24:10 <lambdabot>                    -> ((a20 -> a20) -> b0) -> (a20 -> a20) -> a20 -> r0
11:24:12 <hpc> :(
11:24:16 <mauke> :t [(.), fmap, liftM, liftA, (<$>), (>>>)]
11:24:17 <lambdabot> [(c -> c) -> (c -> c) -> c -> c]
11:24:23 <mauke> :t [(.), fmap, liftM, liftA, (<$>), (<<<)]
11:24:24 <lambdabot> [(b -> c) -> (a -> b) -> a -> c]
11:25:18 <mauke> tford: do you need a separate type?
11:25:45 <mauke> tford: but yeah, that kind of thing is called a "smart constructor"
11:26:17 <mauke> because normal constructors are POD, more or less
11:26:59 <tford> mauke, basically I want to somehow force the value to be an infinite list instead of a non-infinite list
11:27:17 <tford> and not just any infinite list, a repeating version of a list
11:27:20 <mauke> that's what cycle does
11:27:21 <Hermit> tford: if your type is recursive, then just make it's last recursive element the whole collection
11:27:30 <mauke> why define a new type?
11:28:27 <mauke> (also, using cycle doesn't guarantee the result will actually loop around)
11:28:29 <tford> mauke, yes, but let's say I have a function that should take a "WrappingList".  If it takes objects of the type [a], then that doesn't assert that [a] is the result of having called cycle
11:28:34 <mauke> > cycle [0 ..]
11:28:36 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:28:42 <Hermit> > let whole = 1:2:3:whole in whole  -- tford
11:28:43 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
11:28:50 <mauke> Hermit: that's what cycle does
11:28:51 <Iceland_jack> mauke: It wraps around! Just wait
11:28:59 <tford> interesting, mauke
11:29:18 <Hermit> mauke: yes, but he wanted cycle for something that's not a list
11:29:20 <tford> Hermit, I'm going to have to take some time to process what you're saying :)  I'm just getting started
11:29:26 <mauke> Hermit: ?
11:29:36 <Iceland_jack> tford: In short, you probably don't really need a specific type for that
11:30:06 <mauke> no, but enforcing invariants through types is a legitimate thing
11:30:14 <Iceland_jack> Indeed
11:30:16 <mauke> so we're back at smart constructors
11:30:31 <Iceland_jack> but if you do you can use smart constructors:
11:30:31 <Iceland_jack>     wrap ∷ [a] → Maybe (WrappingList a)
11:30:31 <Iceland_jack>     wrap [] = Nothing
11:30:31 <Iceland_jack>     wrap xs = Just (cycle xs)
11:30:44 <mauke> tford: you can define your type in a separate module and don't export the constructors
11:31:01 <Iceland_jack> Sorry, missing the WrappingList value constructors
11:31:03 <Iceland_jack> -s
11:31:06 <pyr> donri: turns out, I do have a lazy problem it seems, switching to tchans doesn't seem to help in that regard (although the interface is nicer, thanks)
11:31:15 <tford> mauke, okay that's what I suspected!  The only way to construct the value would be to call the "smart constructor"
11:31:31 <mauke> right
11:31:39 <tford> great tha
11:31:40 <tford> nks
11:31:53 <mangaba_leitosa> anyone knows how to make vim match the opening paren using the '%' key when the opening paren is preceded by '\', such as in map (\(a, b) -> a + b) ?
11:32:43 <Iceland_jack> Write it as uncurry (+) inst… no never mind
11:32:52 <mangaba_leitosa> :-)
11:32:55 <geekosaur> write it as \ (a,b) -> ...
11:33:11 <mangaba_leitosa> geekosaur: yes, I have to do this, but the code looks ugly
11:33:23 <geekosaur> although it sounds like vim being too smart for its own good
11:33:33 <FireFly> There's an option for it, trying to find it..
11:33:37 <supki> mangaba_leitosa: according to my .vimrc it's  set cpoptions+=M
11:33:48 <FireFly> Ah, that's it :p
11:33:56 <mangaba_leitosa> supki: thanks, working now!!
11:59:18 <elliott> haasn: I am no longer to blame :)
12:01:07 <haasn> elliott: who am I supposed to flame now? :)
12:02:43 <Cale> haasn: I believe it's int-e now
12:03:01 <Cale> haasn: (assuming you're referring to lambdabot)
12:03:11 <haasn> int-e: fix lambdabot plz ktxhbai
12:05:46 <pyr> if anyone is still up for having a look a this: https://gist.github.com/pyr/47e4c217b01bcfa8fdfa
12:06:15 <pyr> in this short snippet using tchans, the side effects are not realized
12:08:20 <FreeFull> pyr: Let me guess, does the program simply exit before anything happens?
12:08:30 <pyr> FreeFull: not exactly
12:08:42 <pyr> FreeFull: I can either get the first message output to redis, or none
12:08:48 <FreeFull> But then it quits?
12:08:51 <pyr> yup
12:09:08 <FreeFull> That'd be because there is nothing to stop the main thread from terminating
12:09:12 <FreeFull> And once that terminates, everything does
12:10:21 <FreeFull> The simplest fix would be to put in a getLine at the end, so it doesn't terminate until you press enter
12:10:41 <FreeFull> At the end of main, I mean
12:10:52 <pyr> \o/
12:11:16 <FreeFull> A more proper fix would probably be to have a loop that checks for a termination condition
12:11:18 <pyr> FreeFull: you're right, I was sure it was related to lazy eval which would have sucked
12:11:35 <pyr> ok, yes, i'll do the mvar trick with forkFinally
12:12:17 <FreeFull> Since you are already using STM, you could use STM for that too
12:12:46 <pyr> just one thing, I get that this happens when I run my compiled program
12:12:57 <pyr> that's reasonnable, i should "join" threads before quitting
12:13:04 <pyr> but i get the same behavior in ghci
12:13:13 <pyr> (running from emacs)
12:13:35 <pyr> since the ghci process hasn't exited, it seems a bit surprising
12:13:45 <FreeFull> The program's main thread isn't ghci's main thread
12:14:09 <pyr> ack
12:14:15 <FreeFull> Or ghci itself would end up terminating in all sorts of circumstances, and you'd have other problems
12:14:43 <pyr> alright, on I go, thanks a lot
12:16:32 <gfredericks> I'm trying to chain two basic functions that return a Maybe
12:16:45 <gfredericks> I coulda sworn `f1 >>= f2` would do the job
12:17:07 <dwcook> @type (>>=) `asAppliedTo` Nothing
12:17:07 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
12:17:22 <dwcook> f1 is Maybe a, f2 is a -> Maybe b
12:17:25 <gfredericks> man this stuff is trippy
12:17:30 <FreeFull> gfredericks: >>= takes a value and a function
12:17:35 <FreeFull> Maybe you want >=>
12:17:39 <gfredericks> yeah I was slowly realizing that
12:17:43 <dwcook> There's also
12:17:47 <elliott> perhaps (f1 >=> f2)
12:17:50 <dwcook> @type (>>) `asAppliedTo` Nothing
12:17:51 <lambdabot> Maybe a -> Maybe b -> Maybe b
12:17:51 <gfredericks> I think >=> is it
12:18:26 <FreeFull> > (Just >=> Just) 3
12:18:28 <lambdabot>   Just 3
12:18:49 <gfredericks> eeerrrm
12:19:23 <gfredericks> oh no wait
12:19:35 <gfredericks> I have an (a -> Maybe b) and a (b -> c)
12:19:39 <gfredericks> and I want an (a -> Maybe c)
12:19:57 <FreeFull> Then you want fmap/liftA/liftM
12:20:07 <FreeFull> Actually
12:20:09 <FreeFull> Hmm
12:20:27 <gfredericks> I started with do and figured it'd be succincter with the appropriate combinator
12:20:35 <alexander__b> I see RWH calls value assignment "variables", and even goes to say that a *variable* may *never change* (lol). is this common? do people call things variables in haskell? I never imagined, and have said (on several occasions) said that haskell doesn't have variables.
12:20:35 <prophile> if they're f and g you want either fmap g . f
12:20:41 <dwcook> That looks like an fmap . fmap to me
12:20:44 <prophile> or f >=> (return . g)
12:21:07 <alexander__b> the way I see it, if you let foo = 2, then foo is 2. foo means 2. foo is not a variable that at the moment points to the number 2.
12:21:14 <gfredericks> the return trick worked
12:21:17 <gfredericks> I'll just stick with that
12:21:21 <gfredericks> thanks!
12:21:23 <alexander__b> i.e. it's more akin to constants than variables
12:21:29 <FreeFull> >  fmap (Just . show) (+3) 10
12:21:31 <lambdabot>   Just "13"
12:21:42 <zett_zelett> http://stackoverflow.com/questions/15936469/calling-gnuplot-from-within-ghci-corrupts-the-terminal-is-it-possible-to-rest I have the same problem as Mike, only I call gnuplot from funcPlot of Graphics.Gnuplot.Simple.
12:21:56 <zett_zelett> Does anyone know how to fix that?
12:26:23 <int-e> @bot
12:26:23 <lambdabot> :)
12:30:37 <gfredericks> how do I convert between Data.ByteString.ByteString and String?
12:31:21 <FreeFull> gfredericks: What encoding is the text in?
12:31:53 <gfredericks> I see.
12:32:07 <Taneb> gfredericks, perhaps use text?
12:32:08 * gfredericks knows heck if
12:32:23 <gfredericks> that does sound better
12:33:30 <gfredericks> that's the text package?
12:33:33 <nisstyre> gfredericks: use Text
12:33:37 <nisstyre> it's on hackage
12:33:51 <gfredericks> cool; thanks!
12:34:14 <nisstyre> gfredericks: Data.ByteString.Char8.unpack will convert a ByteString to String, but you probably shouldn't do that
12:34:18 <nisstyre> unless you have a good reason
12:36:32 <int-e> @type let (∞) = forever in (∞)
12:36:40 <lambdabot> lexical error at character '\136'
12:38:16 <elliott> > let (∞) = forever in (∞)
12:38:17 <int-e> > let (∞) = 1 in (∞) -- ...
12:38:22 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 m0)
12:38:28 <lambdabot>   1
12:38:30 <elliott> int-e: you should look at how lambdabot "does" Unicode.
12:38:30 <lambdabot>    arising from a use...
12:38:32 <int-e> so @type is different, sigh.
12:38:37 <elliott> int-e: basically it uses String to represent a byte string
12:38:43 <elliott> so commands get UTF-8 in String format
12:39:00 <elliott> with @run, it happens to get double-decoded at some point? like because it passes it on the command line
12:39:11 <elliott> but not with other things.
12:39:19 <elliott> I was going to make it properly decode stuff as Text as early as possible but, time.
12:40:38 <int-e> elliott: well, it's less wrong now (though I honestly don't know why it works better with en_US.UTF-8 than with C.UTF-8 locale)
12:41:06 <elliott> maybe you don't have C.UTF-8? :)
12:41:18 <int-e> haasn: next time please give me a hint what's actually wrong ... it's annoying to have to check several hours of history to find the context .
12:41:26 <int-e> elliott: apparently. :P
12:42:58 <haasn> :t asIndex
12:43:02 <haasn> :t (asIndex)
12:43:03 <lambdabot> (Functor f, Indexable i p, Contravariant f) => Overloading' p (Indexed i) f s i
12:43:06 <elliott> int-e: btw, bonus props if you figure out how on earth @pl got broken ;)
12:43:07 <haasn> int-e: why doesn't the former work? :P
12:43:20 * elliott runs away screaming
12:44:44 <int-e> @pl \x y -> y x y
12:44:44 <lambdabot> join . flip id
12:45:05 <int-e> haasn: oh that looks funny.
12:46:07 <FreeFull> :t flip id
12:46:08 <lambdabot> b -> (b -> c) -> c
12:46:18 <FreeFull> :t ($)
12:46:19 <lambdabot> (a -> b) -> a -> b
12:46:38 <int-e> @hoogle a -> [a]
12:46:39 <lambdabot> Prelude repeat :: a -> [a]
12:46:39 <lambdabot> Data.List repeat :: a -> [a]
12:46:39 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
12:47:00 <int-e> phew, at least there is something that works :)
12:47:39 <int-e> @pl (\x -> x x) (\x -> x x)
12:47:41 <lambdabot> Plugin `pl' failed with: stack overflow
12:50:07 <moops> haha
12:50:51 <int-e> :t id asIndex
12:50:52 <lambdabot> (Functor f, Indexable i p, Contravariant f) => Overloading' p (Indexed i) f s i
12:50:58 <int-e> :t asIndex undefined
12:50:59 <lambdabot> (Functor f, Indexable i p, Contravariant f) => Indexed i s (f s)
12:55:24 <identity> god I love monad-par
13:01:54 <bz> why would PSQueue keys be an instance of Ord?
13:04:24 <Cale> bz: lookup :: (Ord k, Ord p) => k -> PSQ k p -> Maybe p is O(log n) time
13:04:29 <geekosaur> presumably so they can be searched, and whatever implementation it uses requires Ord?
13:05:04 <bz> yeah nvm
13:05:14 <bz> i thought it was a simple binary heap, turn sout not
13:08:52 <monoidal> suppose data A a = A. How do I define TH's Lift for this type?
13:09:15 <monoidal> I wanted to say lift A = [| A |], but then $(lift (A :: A Int)) has type A a, while I wanted A Int
13:09:23 <mangaba_leitosa> there is Data.List.isInfixOf for checking whether [3,4,5] is found in [1,2,3,4,5,6,7,8]. What about the function for locating the index of the subsequence?
13:10:03 <Cale> monoidal: That can't be helped
13:10:31 <Cale> monoidal: because there's no way to infer from the syntax A which type you wanted.
13:11:08 <monoidal> Cale: something like instance Lift (A a) where lift A = [| A :: A a |], but this complains a is undefined, even with scoped typevars
13:11:38 <monoidal> is there a way to place local type variables in a TH splice?
13:11:43 <Cale> > findIndex (isPrefixOf [3,4,5]) (tails [1..8])
13:11:45 <lambdabot>   Just 2
13:12:46 <glguy> monoidal: forallT [PlainTV (mkName "x")] [] [t| $x -> $x |]
13:12:48 <glguy> something like that?
13:13:00 <glguy> where let x = varT (mkName "x")
13:13:17 <mangaba_leitosa> Cale: haha, thanks! Such an idea didn't cross my mind :-)
13:13:39 <monoidal> glguy: will check
13:13:57 <glguy> monoidal: after you fix any minor typos, what I wrote will work if it's the kind of thing you want
13:14:36 <Cale> glguy: I think he wants to capture the local value of the type variable a, and then use that to create syntax depending on which type it is
13:14:54 <Cale> monoidal: You could maybe define separate instances for various specific types
13:15:46 <glguy> oh, I see
13:16:01 <glguy> If you can do that I'd imagine you'd have to go through "reify"
13:16:22 <elliott> I think you can do what monoidal wants but I don't know how.
13:16:37 <elliott> monoidal: maybe if you use ''a in the lift body?
13:16:40 <elliott> with ScopedTypeVariables on
13:16:41 <int-e> :t asIndex
13:16:52 <lambdabot> (Functor f, Indexable i p, Contravariant f) => Overloading' p (Indexed i) f s i
13:17:41 <int-e> haasn: ^^
13:18:46 <monoidal> elliott: [| A :: A ''a |] is a syntax error
13:19:28 <int-e> (This wasn't so hard ... just text processing going wrong: The type signature is so long that ghci puts a line break after 'asIndex' and after a bit of aggressive filtering, lambdabot was staring at ":: <type>", and didn't find the " :: " substring that it was expecting.)
13:19:34 <elliott> monoidal: I mean outside of the [| ... |]
13:19:34 <scd250> yay, I made a haskell program that actually works AND foes what it's supposed to!
13:19:37 <scd250> *does
13:19:59 <scd250> I'm really excited, this is the first and only time I didn't need a million tries to get something I wrote to run properly in any language.
13:20:01 <monoidal> elliott: I don't understand the suggestion
13:20:36 <elliott> monoidal: well, me neither. just maybe you could reify ''a or something to get the type information for it and construct an AST or something.
13:20:38 <int-e> I don't think I can stomach the UTF-8 woes though, they have to wait.
13:23:15 <mzero> congrats scd250
13:23:17 <gfredericks> I do not understand error handling
13:23:27 <dv-> join the club
13:23:31 <scd250> yeah it felt pretty awesome and now I want to try a more complex project lol
13:23:34 <gfredericks> handle (putStrLn . show) (putStrLn $ show (3 / 0))
13:23:40 <scd250> all this one did was set up networking, meaning write to a bunch of config files
13:23:42 <gfredericks> ^ this gives a complaint about type ambiguity
13:23:57 <gfredericks> and I think I understand what the ambiguity is but don't know how to do what I'm trying to do
13:24:34 <gfredericks> (which is handle any exception)
13:24:36 <mauke> handle (\(SomeException e) -> print e) (print (3 / 0))
13:26:04 <gfredericks> what is "SomeException" doing there?
13:26:17 <gfredericks> (i.e., what role is it playing syntactically?)
13:26:23 <mauke> being a data constructor
13:26:27 <mauke> and part of a pattern
13:26:57 <geekosaur> the semantic part is more important, it gives the compiler a type to work with since all it has otherwise is a typeclass
13:35:27 <monoidal> hm. maybe there's a free theorem that forbids writing a nonconstant function A a -> Q Exp
13:42:22 <monochrom> that depends on what's "A", but hopefully yeah
13:42:30 <monoidal> data A a = A
13:43:15 <monochrom> oh heh, then it's almost () -> Q Exp and doesn't need a free theorem :)
13:43:27 <elliott> monoidal: well, you could use e.g. a type family on "a" in the instance or something.
13:51:03 <haasn> int-e: whoop whoop
13:51:10 <darthdeus> how can i write   f x && g x    in a better way?
13:51:11 <scd250> this is a really big chat channel.
13:51:13 <haasn> int-e: finally a maintainer of lambdabot that actually fixes things ;)
13:51:22 <Iceland_jack> darthdeus: You can use: liftM2 (&&)
13:51:24 <haasn> scd250: haskell is a really popular programming language, apparently ;)
13:51:25 <Iceland_jack> if you think it's nicer
13:51:29 <monochrom> I think f x && g x is just fine
13:51:43 <scd250> is anyone willing to look at my code I just got working and critique it since as I said earlier it's my first project?
13:51:46 <darthdeus> monochrom: but i have     foo x = f x && g x :\
13:51:47 <haasn> instance Boolean x => Boolean (r -> a) -- :(
13:51:53 <scd250> it works but I'm sure there's plenty with it I could do differently lol
13:51:57 <darthdeus> Iceland_jack: not sure how :o
13:51:57 <hpc> #haskell is like a monad; things that go into it never come out!
13:52:01 <monochrom> ok, if you want to use foo, then use foo.
13:52:15 <darthdeus> noo, i mean that the whole function is defined like that
13:52:16 <monoidal> if there was a way to convert TypeRep to Q Type, I might have Typeable a => A a -> Q Exp
13:52:27 <darthdeus> i thought there would be a way to make it into something like  foo = f `and` g
13:52:27 <monochrom> ok, that is a fine definition
13:52:28 <monoidal> but as far as I see, there is no such function
13:52:28 <Iceland_jack> :t liftM2 (&&)
13:52:29 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
13:52:32 <Iceland_jack> :t liftM2 (&&) ?g ?f
13:52:33 <lambdabot> (Monad m, ?g::m Bool, ?f::m Bool) => m Bool
13:52:46 <Iceland_jack> 'f x && g x' is just fine though
13:53:23 <monochrom> ok, define and f g x = f x && g x. now you can write foo = f `and` g. happy now?
13:53:24 <monoidal> scd250: paste your code and perhaps someone will look at it.
13:53:30 <scd250> https://github.com/sarah-dumas/easynet/tree/master/network
13:53:49 <scd250> FYI this is also my first time doing version control so my files aren't organized well
13:53:55 <scd250> some of the configuration files also aren't uploaded
13:53:56 <elliott> is there a convenient way to show a Rational as decimal in base?
13:53:59 <Iceland_jack> Or define ‘and’ as (f `and` g) x = …! :)
13:54:00 <elliott> I guess maybe printf can do it
13:54:12 <monochrom> you should be specific about "better" before you turn down my answers
13:54:15 * hackagebot purescript 0.1.8 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.8 (PhilFreeman)
13:54:23 <Taneb> [] : NonEmpty :: Seq : ???
13:54:29 <haasn> (&&) <$> f <*> g -- ugh
13:54:40 <elliott> oh, or fromRat + the showFloat family... but that is limited precision
13:54:41 <haasn> foo = liftA2 (&&) -- my favorite
13:54:57 <monochrom> for example if you say "more advanced" I know what to do. or "shorter" I know what to do. or "more like python" I know what to do. but none of them are my "better".
13:55:31 <monoidal> scd250: hlint (cabal install hlint) should give you some simple hints
13:55:51 <monochrom> perhaps next time I should begin by asking "what does 'better' mean?"
13:56:20 <monoidal> scd250: valid x = x `elem` ["passwd", "group", "shadow", "hosts"]
13:56:30 <ReinH> haasn: (((&&) <$>) .) . (<*>)
13:57:12 <monoidal> scd250: in general, you should name your files starting uppercase, and begin with "module ModuleName where..."
13:57:15 <ReinH> monoidal: this is true any time anyone ever says "better" without qualification ;)
13:57:37 <scd250> ahh. I've just been running them individually lol.
13:57:46 <ReinH> monoidal: if "it works" is the most ambiguous possible sentence in the english language, "it's better" is only slightly less so
13:57:46 <haasn> ReinH: fmap (&&) .: (<*>) -- ?
13:57:54 <ReinH> haasn: something something
13:57:58 <monoidal> ReinH: I think you were speaking to monochrom
13:58:00 <haasn> I think that needs to be flip (<*.)
13:58:02 <haasn> or whatever
13:58:04 <ReinH> monoidal: argh
13:58:06 <Iceland_jack> scd250: Also for:
13:58:06 <Iceland_jack>     isAddingLine line = valid . head . T.words $ line
13:58:06 <Iceland_jack> it could be
13:58:06 <Iceland_jack>     isAddingLine = valid . head . T.words
13:58:09 <scd250> also, does anyone know how to get the program to restart the VM and then start again
13:58:10 <Iceland_jack>  
13:58:23 <ReinH> monoidal: my brain only supports 4-deep tries
13:58:24 <Iceland_jack> with monoidal's definition of ‘valid’
13:58:24 <scd250> because right now I have it as a manual restart
13:58:31 <ReinH> monoidal: after that it just gives up
13:58:50 <scd250> *is writing these suggestions down*
13:59:03 <monochrom> well, I toss a coin. if it's head, I ask "what does 'better' mean?". if it's tail, I use my own judgement of "better" and stand by it.
13:59:33 <ReinH> monochrom: something something axiom of choice
13:59:44 <monochrom> and if it's null, I don't answer. :)
13:59:52 <Iceland_jack> scd250: I personally prefer 'filter predicate (T.lines usersconfig)' when there is only a single pair of parens instead of 'filter predicate $ T.lines usersconfig' but there is nothing wrong with either
14:00:22 <ReinH> monochrom: so your axiomatic system includes the axiom of choice then ;)
14:00:38 <Iceland_jack> It looks very good though overall scd250
14:01:03 <ReinH> Iceland_jack: I find that I tend to use parens when the thing inside parens is a useful concept of itself
14:01:09 <scd250> thanks :D
14:01:14 <monoidal> scd250: remember you don't need "do" for a single expression; you can just use restart = echo "..."
14:01:15 <monochrom> I accept excluded middle and choice, yes.
14:01:15 <scd250> this is the easiest language I've tried I think
14:01:20 <scd250> oh really?
14:01:21 <monoidal> scd250: (this should be caught by hlint)
14:01:30 <scd250> I need to go get hlint
14:01:50 <Iceland_jack> ReinH: I find $ too noisy personally but it's a preference thing like I said
14:01:50 <scd250> this is the first time though that the debugging process didn't have me ripping clumps of my hair out trying to figure out what was wrong and how to fix it
14:02:00 <scd250> it did take a bit but it wasn't super frustrating.
14:02:08 <ReinH> Iceland_jack: yep, just giving you a heuristic I seem to find useful
14:02:32 <scd250> going to install hlint though
14:02:36 <Iceland_jack> ReinH: Yeah, I might use it more if it had a neater operator to be honest :)
14:03:02 <ReinH> monoidal: well, you're choosing a random selection from an infinite collection of bins ;)
14:03:06 <ReinH> argh
14:03:09 <ReinH> monochrom: ^
14:03:09 <monochrom> haha
14:03:22 <scd250> what's amusing is the teacher this is being handed in to does not understand haskell and had actually never heard of it before
14:03:23 <monochrom> that's just dependent product :)
14:03:32 <scd250> he'd suggested we write it in shell script but we're allowed to use any language we want.
14:04:00 <ReinH> monochrom: I had a coworker who used to joke that he believed the axiom of choice on prime days of the week
14:04:11 <ReinH> monochrom: strangely enough, he was not a haskeller
14:05:07 <ReinH> monochrom: (the joke is that you don't need the axiom of choice if you have a way to choose)
14:05:11 <ReinH> math jokes.
14:08:12 * chrisdone stands in front of the tumbleweed to avoid ReinH being embarassed
14:08:39 <ReinH> *crickets*
14:08:47 <ReinH> chrisdone: it wasn't a funny joke when he said it either ;)
14:08:56 <ReinH> so I had extremely low expectations
14:10:30 <monochrom> I am not intuitionistic. but when I use intuitionistic logic, I like Kripke's semantics.
14:10:36 <monochrom> @quote monochrom Kripke
14:10:36 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
14:10:40 <chrisdone> ReinH: i've got double entendres here, shall i give you one?
14:10:50 <ReinH> chrisdone: go for it :p
14:10:57 <ReinH> monochrom: did you just quote yourself?
14:11:07 <monochrom> yes, I always quote myself
14:11:11 <ReinH> haha
14:11:13 <ReinH> fair play
14:11:27 <monochrom> in fact, I always talk to myself, it spices up my conversations
14:11:38 <ReinH> haha
14:12:09 <timbod> Any users of the new cabal sandbox functions about?
14:13:25 <timbod> I'm trying to work out why the build directory now has an extra layer: dist/dist-sandbox-HASHCODE/build
14:13:39 <timbod> Whats with the wierd hashcode?
14:14:52 <monochrom> I just tried it yesterday. I didn't get a hashcode. it's just dist/build. but I only have an executable.
14:18:16 <timbod> monochrom: This all arises from trying to use ghc-mod + emacs. It's all pretty simple, except teaching ghc-mod how to find all the necessary code. Looking at the source code for ghc-mod, it searches dist/build/autogen, but not dist/dist-sandbox-HASHCLODE/build/autogen
14:22:18 <monochrom> well, I have just tried library instead of executable. I still don't get a hashcode. it's still simply dist/build, and I do have dist/build/autogen
14:23:34 <timbod> monochrom: Thanks - I'll ask on the cabal-dev mailing list.
14:23:59 <monochrom> cabal-dev? I am not using cabal-dev. I'm using plain cabal "cabal sandbox init"
14:24:18 <timbod> etorreborre: Since when do you hang out on haskell mailing lists?
14:24:23 <monochrom> oh, nevermind, cabal-dev is the right mailing list for that
14:25:29 <etorreborre> timbod: I started a few days ago, mostly to get a feel for what's being discussed because I unfortunately still spend most of my time in Scala-land
14:25:44 <monochrom> it is just confusing that there is such a thing as http://hackage.haskell.org/package/cabal-dev
14:26:39 <timbod> monochrom: Indeed. I should have said "cabal-devel" mailing list. The names are too close.
14:26:54 <kuznero> Hi All!
14:27:07 <timbod> etorreborre: "unfortunately"?
14:27:42 <etorreborre> I just wished I spent more time with haskell, at least for one reason: a fast compiler :-)
14:28:12 <timbod> Wow - I think ghc is slow.
14:29:47 <monochrom> ghc takes time but because it does a lot
14:30:20 <chrisdone> the code generation is slow
14:30:29 <chrisdone> type checking is fast
14:31:01 <mzero> timbod - during development consider turning off optimization - or doing your testing in ghci!
14:31:05 <ion> @hoogle FilePath -> [ByteString] -> ByteString -> IO ByteString
14:31:06 <lambdabot> System.Posix.ByteString.FilePath throwErrnoPathIf :: (a -> Bool) -> String -> RawFilePath -> IO a -> IO a
14:31:06 <lambdabot> System.Posix.ByteString.FilePath throwErrnoPathIfRetry :: (a -> Bool) -> String -> RawFilePath -> IO a -> IO a
14:31:06 <lambdabot> System.Posix.ByteString.FilePath throwErrnoPathIfMinus1 :: (Eq a, Num a) => String -> RawFilePath -> IO a -> IO a
14:31:16 <monochrom> as opposed to what I heard recently about the common scala compiler "it is slow because it is unstructured and therefore you don't know how to improve it"
14:31:22 * ion is looking for a ByteString variant of readProcess
14:31:34 <chrisdone> ion: there's one in process-extras
14:31:39 <ion> chrisdone: Thanks!
14:31:51 <chrisdone> welcome
14:32:15 <hpc> ion: beware, there's a problem with it on windows, afaict
14:32:31 <ion> Thanks, not a problem for me.
14:32:40 <FreeFull> GHC does a lot of optimisation I think
14:32:52 <FreeFull> And it has many compilation stages
14:32:54 <timbod> The issue for ghc speed for me doesn't really apply to a single file - you get the type errors back pretty quickly. The problem is more that as the haskell universe gets bigger you spend more and more time compiling dependencies etc.  I know it does a lot.
14:32:56 <etorreborre> timbod: ok, try scalar then ...
14:32:56 <chrisdone> even with optimization turned off code gen is slow
14:33:03 <FreeFull> At least three intermediate languages
14:33:28 <chrisdone> timbod: that's probably the most annoying part
14:33:42 <chrisdone> C# .net compilation is pretty slow too, but at least you only compile your own app
14:33:47 <etorreborre> timbod: s/scalar/scalac/
14:34:13 <chrisdone> in haskell you're (re-)compiling everyone and their dog's libraries more often than is reasonable
14:34:22 <mzero> tombod - tell me about it - I'm building all of Haskell Platform - from scratch (hermetic build) for like the fourth time today!
14:34:49 <etorreborre> timbod: but it's interesting to hear that compilation times are also sometimes an issue with haskell
14:34:49 <chrisdone> and the arguments like 'get a faster machine' irritate me
14:35:11 <monochrom> no no, I don't use that argument
14:35:12 <mzero> 300k+ lines of source!
14:35:12 <lpaste> pharaun pasted “Rigid Type Variable with Existential Quantification?” at http://lpaste.net/95494
14:35:56 <FreeFull> Go get a machine from 2030
14:36:04 <chrisdone> i'd like it if one person just spent a summer making it really easy to avoid recompilation
14:36:17 <chrisdone> and making it faster
14:36:34 <chrisdone> with something like "development mode" vs "production mode"
14:36:55 <pharaun> my understanding of parameterized/rigid types are a bit wonky probably, so it would be great if someone double checked my work
14:37:04 <chrisdone> so just because i change something 10 libraries depend on, i don't have to recompile 10 libraries
14:37:04 <pharaun> i'm not sure i'm doing it right, the type sure thinks i'm not :)
14:39:15 <monochrom> pharaun: suppose I am a user of your function. that is, I provide a value of type Comic, and I get to choose what "a" is, right?
14:39:24 <pharaun> yup
14:39:32 <pharaun> the rest of the code should not care what A is
14:39:38 <monochrom> and since I provide a value of type Comic, I also get to choose what "t" is, right?
14:39:41 <pharaun> its just a "tag" for the comic parser to deal with
14:40:02 <monochrom> therefore, I have the freedom to choose t = Int, a = Bool, right? well that breaks "parse x"
14:40:33 <Ghoul_> its because haskell loves inlining
14:40:56 <pharaun> monochrom: oh... hm how would i fix that
14:41:09 <Ghoul_> and certain optimizations (cough SpecConstr) can't be understood without excessive inlining
14:41:16 <pharaun> basically i want to make it so that t is free to be defined by whoever provides the Comic
14:41:17 <monochrom> I don't know. it depends on the whole project.
14:41:31 <pharaun> which is why i did existential quantification
14:41:59 <monochrom> must it be an existential type? must t be hidden?
14:42:00 <pharaun> i want to make "t" a blackbox that only the parse can open up
14:42:11 <pharaun> because each comic is going to have a different type of t
14:42:21 <pharaun> and i tried a sum adt
14:42:38 <pharaun> that's not going to work because then i would have to extend it everytime, i'm intending this to be a library
14:43:09 <pharaun> in which you can provide a comic then provide a t (which is your state) and it will just carry t along till it arrives back in pageParse
14:43:13 <pharaun> then you can do whatever you want with t
14:43:23 <pharaun> the rest of the system need not to concern itself as of what t is
14:43:44 <monochrom> I mean data Comic a = Comic { comicName :: String, pageParse :: ReplyType a -> IO [FetchType a] }, and therefore indexedParser :: Comic a -> TBMChan (ReplyType a) -> TBMChan (FetchType a) -> IO Bool
14:44:13 <pharaun> then i would need to do one indexedParser call for each comic type right ?
14:44:29 <mzero> better HP stats: 58 packages, 220k+q lines of haskell in 1243 files (each compiled twice!), 288k+ lines of source total (including c & other)
14:44:37 <pharaun> i probably can live with that, i was just tyring to make it so i could give it a list of Comic and have it iterate through that list
14:44:41 <monochrom> I don't know. it depends on the whole project specification
14:45:08 <pharaun> alright i'll try that out monochrom and see if it would work
14:46:12 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
14:46:23 <pharaun> always :)
14:46:42 <pharaun> alright i may be able to live with one call to indexedParser for each Comic a type
14:46:48 <pharaun> i just think it would be nice to send it a list
14:46:56 <pharaun> anyway tweaking the types again let's see
14:47:13 <pharaun> and
14:47:18 <pharaun> monochrom: that typechecked
14:47:36 <pharaun> well alright i guess i'll stick with one call per comic type and call it a day for now, thanks :)
14:48:30 <pharaun> yep yep that works great
14:48:32 <pharaun> monochrom: <3
14:48:51 <pharaun> i guess i need to work some more on understanding existential quantification
14:53:32 <pyr> is there a syntax for a data to reference a class instance
14:53:52 <pyr> e.g for Eq saying something like: data Foo = Foo (Eq a)
14:54:03 <Iceland_jack> instance Eq Foo where … ?
14:54:05 <monochrom> no
14:54:15 <geekosaur> wanting to do that is a bit of a smell...
14:54:51 <monoidal> pyr: data Foo = Foo a, and put Eq constraints in methods which use Foo
14:55:14 <Iceland_jack> oh I understand, no you don't do that
14:55:28 <monoidal> data Foo a = Foo a
14:55:33 <pyr> ah ok
14:56:21 <bz> @pl f x == f y
14:56:21 <lambdabot> f x == f y
14:56:56 <piezoid> I'm trying to make g :: (Maybe a) -> m (Maybe b) from  f :: a -> m (Maybe b)
14:56:59 <geekosaur> you didn't tell it which points to remove
14:57:08 <piezoid> the best I can find is : fmap join . mapM f ...
14:57:15 <Narvius> bz: (==) `on` f
14:57:48 <bz> @hoogle on
14:57:48 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:57:48 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
14:57:48 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
14:58:15 <quchen> (f `on` g) a b = f (g a) (g b)
14:58:18 <bz> Narvius: thanks
14:58:18 <monoidal> piezoid: maybe (return Nothing) - though maybe there's something simpler
14:58:21 <monochrom> piezoid: I would first asking myself g Nothing = ?  g (Just x) = ?
14:58:56 <FreeFull> > (compare `on` fst) (3,4) (1,1)
14:58:58 <lambdabot>   GT
14:59:44 <Narvius> bz: No problem.
15:01:17 <piezoid> monochrom: I see, so I should use maybe (return Nothing) ?
15:01:36 <monochrom> I don't know. you haven't said what you want.
15:01:45 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
15:01:57 <monochrom> well, you said incompletely
15:02:06 <Narvius> g m = m >>= f
15:02:14 <monoidal> piezoid: you might be looking for MaybeT
15:02:14 <bz> :T GT
15:02:24 <Narvius> piezoid: g m = m >>= f
15:02:37 <Narvius> Oh, wait
15:02:38 <Narvius> No.
15:02:39 <Narvius> Hm.
15:03:05 <ReinH> Do we have any FPComplete folks in here?
15:05:04 <monoidal> ReinH: johnw, though I don't know if he's present now.
15:05:15 <ReinH> monoidal: ty
15:05:34 <quchen> ReinH: Scouting for the next interviewee? :-)
15:06:15 <ReinH> quchen: nope :)
15:06:21 <ReinH> quchen: we have the next scheduled
15:06:51 <ReinH> Trying to reach out to Aaron
15:13:13 <structuralist> what are your favorite monad tutorials?
15:13:29 <Iceland_jack> none
15:13:38 <ReinH> structuralist: they are all terrible, but "you would have invented monads" is probably the least terrible
15:14:04 <quchen> structuralist: This one: https://github.com/quchen/articles/blob/master/fbut.md#i-dont-understand-monads
15:14:17 <quchen> Bonus: it's short.
15:14:20 <moops> structuralist: i like tony morris's one in scala
15:14:23 <Iceland_jack> “I want to learn about monads” before learning some Haskell foundations is the wrong mindset
15:14:30 <moops> with banana and furry and unicorn
15:14:35 <moops> thats what made it finally click for me
15:14:41 <quchen> Scala has monads?
15:14:52 <moops> you can implement monads in scala
15:14:56 <FreeFull> Scalaz has something that looks like monads
15:14:58 <Hafydd> Monad is in the standard library. Is that not foundational enough?
15:15:05 <Cale> Iceland_jack: ...unless you're studying category theory :)
15:15:06 <quchen> I didn't know Scala had return type polymorphism
15:15:07 <Iceland_jack> Hafydd: That is not my point
15:15:12 <Hafydd> Also, you need to use Monad to write literally any useful program.
15:15:24 <Hafydd> Iceland_jack: what is your point?
15:15:25 <Cale> (But in any case, you'll need *some* foundations!)
15:15:26 <Iceland_jack> Using monads and “I want to learn monads” are completely separate things
15:15:29 <moops> you can do it with typeclasses
15:15:43 <Hafydd> I disagree. You can't use something properly without knowing what it is.
15:15:45 <Iceland_jack> I'm advocating learning to use IO, Maybe, [], …
15:15:51 <Iceland_jack> You absolutely can…
15:15:56 <monochrom> my favourite monad tutorial is Wadler's "monads for functional programming" http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf
15:15:59 <Hafydd> Not with any dignity.
15:16:00 <Iceland_jack> You can use numbers without knowing group theory
15:16:07 <Cale> You can use specific monads quite well without knowing what monads in general are about
15:16:18 <structuralist> (this is the liveliest discussion a question of mine has ever sparked)
15:16:25 <moops> haha
15:16:28 <Iceland_jack> structuralist: You mentioned the M-word.
15:16:29 <Hafydd> Fair enough. But you do need to know what the overloaded operators you'll be using are.
15:16:35 <quchen> Hafydd: You can't use a computer with dignity because of your lack of quantum field theory.
15:16:36 <Hafydd> >>= and return, at the very eleast.
15:16:44 <structuralist> suppose I want to understand what monads are about though
15:16:47 <Iceland_jack> Hafydd: I say, focus on concrete usages of monads first: then worry about the type class
15:16:56 <Iceland_jack> structuralist: You're doing it again!
15:17:01 <structuralist> like I want to understand the concept of a m****
15:17:03 <quchen> Haskell is not a monad tutorial.
15:17:12 <Hafydd> There aren't even non-overloaded versions of IO's >>= and return.
15:17:19 <ReinH> quchen: could make "Don't be one of those guys." not gender-specific?
15:17:30 <quchen> ReinH: ?
15:17:35 <ReinH> s/guys/people?
15:17:39 <quchen> Oh. No.
15:17:43 <ReinH> I would like to think that there are female beginner haskellers
15:17:48 <quchen> Don't care. Leave your politics out of my articles.
15:17:51 * ReinH sighs
15:17:52 <Iceland_jack> ReinH: Or “Don't be like that.”
15:17:53 <ReinH> it's not politics
15:17:55 <ReinH> it's being nice to people
15:18:12 <ReinH> it fucking has nothing to do with politics
15:18:48 <monochrom> I don't understand this conversation. the asker asks for monad tutorials. then he/she engages in much conversation that does not name one single monad tutorial. what is going on? what is the asker's real question?
15:18:59 <yesthisisuser> ok, this was an interesting error message for a change in GHC: "My brain just exploded I can't handle pattern bindings for existential or GADT data constructors. Instead, use a case-expression, ..."
15:19:31 * structuralist is the asker
15:19:33 <ReinH> quchen: don't call it politics. Call it what it is: you not giving a shit about women.
15:19:48 <quchen> ReinH: No, that's not it.
15:19:49 <ayako> plenty of women call each other 'guys' too
15:20:09 <ReinH> ayako: and plenty of black people call each other "nigga"
15:20:19 <ReinH> that's not relevant
15:20:22 <Iceland_jack> structuralist: Go through LYAH, it takes you through what I'd call good preliminary stuff first before even mentioning monads
15:20:27 <Iceland_jack> @where lyah
15:20:27 <lambdabot> http://www.learnyouahaskell.com/
15:20:39 <Iceland_jack> structuralist: Are you familiar with Maybe?
15:20:41 <arkeet> don't worry about monads.
15:20:42 * structuralist already understands monads more or less
15:20:49 * structuralist is interested for pedagogical reasons
15:20:51 <quchen> ReinH: It's that you're trying - scratch that, are - insulting me as not giving a crap about women, when that word "guys" clearly means "bunch of people". Your interpretation of the word and trying to shove that down my throat is what I call politics. This conversation is over.
15:21:04 <Iceland_jack> structuralist: Pedagogical reasons for what then? If you basically understand them
15:21:07 <ReinH> quchen: Well, I was *trying* to gently suggest that you use less exclusive language.
15:21:15 <ReinH> quchen: your response to that prompted my "insult"
15:21:23 <monochrom> I guess people just want to talk
15:21:28 <Iceland_jack> structuralist:
15:21:28 <Iceland_jack> @src Monad
15:21:29 <lambdabot> class  Monad m  where
15:21:29 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:21:29 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:21:29 <lambdabot>     return      :: a -> m a
15:21:31 <lambdabot>     fail        :: String -> m a
15:21:35 <Iceland_jack> That's all there is structuralist
15:21:51 <FireFly> Well there's the laws
15:21:52 <ReinH> the word "guys" does not clearly mean "bunch of people". A cursory glance at the issues of sexism and langauge would be enough to convince you of that.
15:21:55 <Iceland_jack> Yes, and laws :)
15:22:02 <structuralist> TBH the monoid object in the endofunctor category makes more sense to me
15:22:33 <arkeet> ReinH: I don't care what it is but I don't want to see it in this channel. :<
15:22:35 <Iceland_jack> I fail to see the problem
15:22:38 <ReinH> quchen: ok, just know that I do not tolerate your form of sexism
15:22:38 <yesthisisuser> i also thought "guys" was used to refer to both men and women.. i am not a native english speaker
15:22:49 <ReinH> arkeet: me neither, but if I get banned for asking people to not be sexist then so be it
15:22:53 <ReinH> ignoring the problem doesn't make it go away
15:23:06 <structuralist> reason for asking is that I'm starting to sort of get why monads and coalgebra and continuations are connected but not really yet
15:23:14 <arkeet> you can go to pm or -blah or something for that
15:23:27 <structuralist> it would be helpful if there was some self-contained expository piece that covered that
15:24:10 <structuralist> it occurred to be that free monads might be a good pedagogical starting point, a la http://r6.ca/blog/20110520T220201Z.html
15:24:23 <ReinH> arkeet: I'm going to let it go because it's just some person's personal work.
15:24:27 <ReinH> But I'm not at all happy about it.
15:24:56 <FreeFull> ReinH: Guys, gals and others?
15:25:08 <quchen> Next time I read an artcle where the reader is passively referred to as "she" I better send a letter to the head of state, that stuff is unacceptable.
15:25:09 <structuralist> human beans
15:25:20 <ReinH> "one of those people" conveys exactly the same thing without being sexist. But if you want to talk about it let's go to -blah.
15:25:34 <ReinH> quchen: oh fuck off with your passive aggressive dismissiveness
15:25:46 <ReinH> that's not the same thing and you shuold know better
15:25:47 <arkeet> oh come on
15:26:10 <Heffalump> quchen, ReinH: please cool it, I'm sure it's possible to have this debate without being insulting
15:26:15 <arkeet> this channel is getting too hot.
15:26:40 <flebron> Say I have a module, and I'm defining a type X which is just the type Y (type X = Y), is there a way to prevent users of my module from using my X as if it were a Y? (Because I may want to change this representation in the future.) I'd like to not have another constructor, like with newtypes.
15:26:45 * FreeFull opens the windows
15:26:50 <arkeet> flebron: no, they are the exact same type.
15:27:10 <FreeFull> flebron: Newtypes are free
15:27:18 <monochrom> newtype plus non-exporting is how you enforce abstraction
15:27:21 <flebron> FreeFull: Not for typing they aren't. I'm unpacking and packing over and over,.
15:27:22 <arkeet> use a newtype if you want that sort of encapsulation.
15:27:43 <FreeFull> The newtype constructor gets optimised away AFAIK
15:27:50 <arkeet> FreeFull: usually. ;)
15:27:51 <monochrom> then again, Liskov's CLU does exactly what you say
15:28:17 <structuralist> can't you just export the type without its constructors?
15:28:25 <flebron> Yes, it does, but I'm teaching a class using this type, and was trying to avoid as much complexity as I could. Unboxing and boxing over and over just pollutes the code.
15:28:37 <flebron> structuralist: It has no constructors. "type X = Y".
15:28:51 <geekosaur> `type` does not do what you want.
15:28:54 <structuralist> oh
15:29:10 <monochrom> you are asking for a language different from Haskell
15:29:27 <structuralist> I'm not sure what it would mean to not use X as Y then
15:29:43 <flebron> structuralist: Inside the module, I know X is Y. But a user of the module does not need to know this.
15:29:54 <ReinH> flebron: type X = y means that X IS Y, so it's impossible to expose X without exposing Y
15:30:16 <FreeFull> We'd have to see the code
15:30:20 <structuralist> I get that. But in order to use X at all your users would need to either use some functions you export, or pattern match, right?
15:30:27 <flebron> It's just type Polynomial = [Integer].
15:30:40 <flebron> structuralist: Yes, I'm fine with them using functions I export.
15:30:41 <structuralist> Pattern matching means "using it as Y"
15:30:45 <arkeet> flebron: you cannot do what you want with type synonyms.
15:30:50 <flebron> Alright. :)
15:30:51 <FreeFull> What exactly are you trying to prevent?
15:31:03 <structuralist> flebron: so what's the problem with newtype?
15:31:04 <arkeet> this is what newtypes are for.
15:31:34 <flebron> FreeFull: I'm trying to showcase the difference between an abstract datatype, which you handle using the modules' provided operations, and an algebraic one, where you have access to its constructors and can assume things about its representation.
15:31:37 <monochrom> flebron does not mean computational overhead. flebron means syntactic overhead
15:31:42 <flebron> structuralist: See above why I'd prefer not to use that.
15:32:17 <structuralist> your convenience functions can do the wrapping/unwrapping, can't they?
15:32:20 <ReinH> flebron: well given that `type` does not abstract anything...
15:32:23 <monochrom> you can also turn an algebraic type into an abstract type, again by non-exporting
15:32:43 <flebron> monochrom: Right, if it were a different type, as in the newtype case :p
15:32:49 <ReinH> (except in the sense that any label abstracts the thing being labeled)
15:32:55 <flebron> I guess I'll use newtype and live with the noise.
15:33:06 <arkeet> the noise can stay entirely within your own module.
15:33:16 <arkeet> that defines the operations you let people use on your type.
15:33:22 <structuralist> what arkeet said
15:33:43 <flebron> Yes, but students will eventually read the code I wrote to see what's being done, and it's suboptimal to have all that noise confusing them
15:33:47 <structuralist> ohh
15:33:55 <chrisblake> hi guys
15:33:55 <structuralist> how about type classes?
15:34:00 <arkeet> structuralist: no =(
15:34:06 <chrisblake> are refinement types and dependent types the same thing?
15:34:16 <arkeet> I don't know what refinement types are, but no.
15:34:19 <structuralist> dependent types are stronger
15:34:19 <monochrom> you have to make a decision. are you teaching Haskell? are you teaching ideas? they are different, they admit different solutions.
15:35:29 <monochrom> if you are teaching ideas with minimal syntax, then Haskell does not satisfy it. you should choose a language that fits.
15:35:56 <chrisblake> monochrom: I'm trying to be taught it :)
15:36:04 <monochrom> or you could join the Haskell committee and push through the necessary change, but that takes a year and won't help your class next week.
15:36:11 <chrisblake> but conceptually, are they the same?
15:36:21 <monochrom> I don't know
15:36:30 <arkeet> chrisblake: monochrom wasn't responding to you ;)
15:36:42 <chrisblake> arkeet, monochrom: oops, sorry >_>
15:37:48 <arkeet> refinement types don't get you dependent sums/products, for example.
15:37:55 <arkeet> maybe.
15:44:31 * hackagebot nanomsg-haskell 0.1.1 - Bindings to the nanomsg library  http://hackage.haskell.org/package/nanomsg-haskell-0.1.1 (IvarNymoen)
15:45:48 <timbod> etorreborre: Are you still actively working on specs? Just now I've converted a whole bunch of tests from haskell test-framework to hspec. It all seems alot cleaner.
15:46:30 <etorreborre> timbod: yes indeed but I haven't had a deep look at hspec yet
15:47:58 <etorreborre> hspec seems nicer indeed that a junit-like test framework
15:48:12 <timbod> Neither have I :-) it all looks pretty straightforward, and my new code is much easier to follow.
15:48:47 <timbod> I think it qualifies as "do syntax abuse". But I'll forgive that.
15:49:16 <enthropy> is it abuse?
15:49:29 <enthropy> do is for sequencing things... and you're specifying a sequence of tests to run
15:50:03 <hpc> enthropy: are you talking about sequencing as in (>>=), or like (>>)?
15:50:04 <timbod> enthropy: There's a sentiment that using do where every possible action is of type (Monad m) => m () is abuse.
15:50:14 <timbod> Not sure if I share it.
15:50:41 <hpc> blaze-html is certainly worth the abuse
15:50:53 <hpc> it's a nice syntax
15:51:01 <arkeet> to me, do syntax abuse is what happens when you make some illegal monad instance just for the purpose of using do syntax
15:51:14 <arkeet> :<
15:51:38 <arkeet> like blaze-html
15:51:48 <hpc> blaze-html has a legal instance
15:51:53 <hpc> name a law that's broken
15:52:02 <arkeet> ok, I dunno
15:52:12 <timbod> I don't have a strong opinion. But if all you have is a writer monad, without ever returning a value, you don't actually need a monad - a monoid will suffice.
15:52:36 <hpc> indeed
15:52:37 <timbod> So it's less about breaking laws, and more about having a type that is as specific as required.
15:52:47 <hpc> shame there isn't a monoid syntax that doesn't require balanced parens
15:52:49 <hpc> or braces
15:53:02 <arkeet> hpc: yeah it looks pretty illegal =(
15:53:13 <arkeet> name a law that *isn't* broken
15:53:19 <bz> wow scrollback got heated
15:53:34 <arkeet> (I'm looking at MarkupM)
15:53:36 <bz> never new gender issues were so central to haskell
15:54:13 <timbod> arkeet: Can you tell just by looking at the examples on the hspec page that monad laws are being broken?
15:54:18 <hpc> arkeet: okay, that's fairly impressive
15:54:27 <arkeet> timbod: I can tell by looking at the instance definition.
15:54:32 <timbod> Or do you have deeper knowledge of the hspec lib?
15:54:32 <arkeet> http://hackage.haskell.org/package/blaze-markup-0.5.1.5/docs/src/Text-Blaze-Internal.html#MarkupM
15:54:32 <enthropy> bz: haskell is a male name I think
15:54:36 <hpc> even (>>= return) is broken
15:54:42 <enthropy> so you have to keep things balanced
15:54:47 <timbod> arkeet: Are you talking about hspec also?
15:54:50 <arkeet> huh?
15:54:53 <arkeet> who mentioned hspec?
15:55:04 <enthropy> that's what started this topic
15:55:06 <timbod> That's where the question of monad abuse came up above.
15:55:10 <enthropy> (of do abuse)
15:55:13 <arkeet> well, someone mentioned blaze-html.
15:55:16 <arkeet> so I started talking about it.
15:55:45 <monochrom> that is what's wrong with you people. you must say something. that's what's wrong with you people.
15:56:20 <arkeet> SpecM is a fine monad, being a newtype of a well-known monad.
15:56:36 <hpc> monochrom: how dare we chat on internet relay chat
15:56:44 <hpc> especially using the internet as a relay
15:56:54 <hpc> ;)
15:59:45 <osa1_> I'm trying to open a paper with format .ps.Z -- any ideas how to read that?
16:00:32 <monochrom> the .Z part means use "uncompress" to decompress. the ".ps" part means use a postscript viewer. here are some: evince, ghostview
16:00:52 * arkeet hasn't seen a .Z file in a looooong time.
16:00:58 <monochrom> .Z is a pretty old compression format
16:01:00 <hpc> what is .Z?
16:01:11 <chrisdone> i love blaze-html!
16:01:14 <arkeet> http://en.wikipedia.org/wiki/compress
16:01:19 <arkeet> .Z ↑
16:01:38 <hpc> neat
16:01:52 <monochrom> perhaps gunzip understands .Z too
16:02:04 <ion> Files compressed by compress are typically given the extension ".Z" (modeled after the earlier pack program, that used the extension ".z").
16:02:15 <ion> Someone should continue the tradition of case-sensitive file name endings.
16:02:40 <chrisdone> case-sensitive files in general
16:02:43 <monochrom> maiN.lHs
16:02:44 <chrisdone> Makefile
16:02:46 <osa1_> monochrom: can I convert it to pdf or something more convenient to print?
16:02:47 <hpc> dibs on .CheesusHCrust
16:03:08 <monochrom> can be done but you need the right programs, and I forgot what they are
16:03:33 <chrisdone> ps2pdf or w/e
16:03:40 <monochrom> there is maybe a ps2pdf program. the result is usually ugly, but you will live.
16:03:46 <osa1_> evince is failed, btw
16:03:59 <chrisdone> failed by whom?
16:04:02 <osa1_> installing ghostview now
16:04:05 <osa1_> failed to run .Z file
16:04:07 <osa1_> s/run/open
16:04:29 <moops> uncompress it first
16:04:39 <monochrom> that is, in fact, strange, because it works for me, it decompresses without me asking
16:04:42 <jedai> ps2pdf result isn't ugly ! It's used by lot of people to support pstricks in pdf
16:05:17 <jedai> Though directly generated pdf is prettier :)
16:06:45 <monochrom> there is, of course, always a 0.1% chance that your file is corrupted in the first place
16:07:19 <jedai> osa1_: use ps2pdf on your ps if you want pdf, it should be pretty good (apart if you have a really unusual ps which... given the .Z isn't all that unlikely...
16:10:00 <osa1_> jedai: that worked nicely, thanks
16:11:04 --- mode: ChanServ set +o monochrom
16:11:14 --- mode: monochrom set -b *!*@ip57-165.cablenet.cz
16:11:20 --- mode: monochrom set -o monochrom
16:11:48 <Rand_McNally> Hi! :)
16:12:16 <pharaun> ?
16:12:50 <Rand_McNally> Not really a Haskell question, but... given a list, if its elements are non-repeating, it implies that they're all different, but that's not a sufficient condition, apparently...
16:13:43 <jedai> Rand_McNally: I don't think "non-repeating" is a completely standard term
16:13:58 <Rand_McNally> It isn't, probably.
16:14:25 <jedai> Rand_McNally: it could mean that terms never repeat (ie they're all differents) but it could also mean that two subsequent elements are differents
16:14:35 * hackagebot nanomsg-haskell 0.1.2 - Bindings to the nanomsg library  http://hackage.haskell.org/package/nanomsg-haskell-0.1.2 (IvarNymoen)
16:14:51 <jedai> which wouldn't preclude a term being repeated later
16:14:57 <Rand_McNally> Hmm...
16:15:18 <Rand_McNally> Well, if it helps, it's about making sure that an alternate nub function works.
16:15:36 <jedai> Oh, then it's the first definition
16:15:38 <Rand_McNally> Comparing its output to nub would be cheating, I guess, so...
16:15:51 <jedai> No, why would it be ?
16:16:02 <dibblego> what is a value for F in: "instance Monad F", where there is only one possible instance and it is most obviously so?
16:16:19 <Rand_McNally> Because it's for homework, and I'm tired of throwing everything I can think of at it.
16:16:29 <Rand_McNally> I strongly suspect that both conditions are one and the same.
16:16:43 <jedai> That's usually how you test a function, you write a model (usually dumb and slow) and then you try to improve it while checking you still have the same output
16:16:44 <Rand_McNally> But the exercise says otherwise.
16:17:15 <jedai> preferably with quickcheck (to avoid corner case blindness)
16:17:22 <Rand_McNally> My implementation is quite dumb, btw...
16:17:43 <Rand_McNally> nub' xs = [xs!!i|i<-[0..ls],j<-[i..ls], xs!!i /= xs!!j], where ls = length xs
16:17:48 <Rand_McNally> It's not idiomatic at all. :(
16:18:03 <jedai> Using nub in your homework would be cheating, checking your function against nub isn't
16:18:14 <Rand_McNally> It is, because it's already done.
16:18:30 <Rand_McNally> I'm supposed to define a new property using another custom function already provided.
16:18:31 <jedai> It's just good form (believe me, I'm a teacher)
16:18:37 <dibblego> so using something already done to check your answer is cheating?
16:18:41 <dibblego> (I too, am a teacher)
16:19:01 <Rand_McNally> Then again, I hate my Haskell homework.
16:19:14 <jedai> Rand_McNally: Then is this custom function equivalent to nub ?
16:19:25 <Rand_McNally> I'm always forced to perform dumb and non-idiomatic tricks in order to solve the problems...
16:19:40 <Rand_McNally> I think it isn't.
16:19:55 <jedai> Rand_McNally: Couldn't you give us the exact question/custom function ?
16:20:15 <Rand_McNally> Okay, but it's somewhat long and in Spanish.
16:20:30 <Rand_McNally> I'm sorry if I'm being bold at you, I'm just tired of this...
16:20:50 <jedai> Note that your nub' is seriously not nub at all
16:20:58 <Rand_McNally> I knew it, somehow.
16:21:30 <jedai> Rand_McNally: In fact under the right condition, the resulting list will be longer than the input list so...
16:22:52 <Rand_McNally> Using a custom function, allIn, defined ys `allIn` xs = all (`elem` xs) ys...
16:23:04 <jedai> > let nub' xs = [xs!!i|i<-[0..ls],j<-[i..ls], xs!!i /= xs!!j] where ls = length xs in nub' [1..4]
16:23:06 <lambdabot>   [1,1,1*Exception: Prelude.(!!): index too large
16:23:08 <Rand_McNally> I have to define a property checking nub' 's correctness.
16:23:20 <ziman> [0..length xs] is an off-by-one error
16:23:45 <arkeet> so is [i..ls]
16:23:55 <Rand_McNally> Yeah, it's wrong, I know.
16:24:02 <Rand_McNally> I defined ls as length - 1.
16:24:24 <Rand_McNally> Not that it actually makes nub' work, but...
16:24:31 <arkeet> well, you can define it recursively.
16:24:34 <arkeet> the property.
16:24:35 <jedai> > let nub' xs = [xs!!i|i<-[0..ls],j<-[i..ls], xs!!i /= xs!!j] where ls = length xs - 1 in nub' [1..4]
16:24:36 <lambdabot>   [1,1,1,2,2,3]
16:24:53 <arkeet> 1. does the property hold of the empty list?
16:25:02 <ziman> i'd start by asking what properties nub is expected to preserve
16:25:07 <arkeet> 2. for a nonempty list, you have a head and a tail.
16:25:14 <ziman> and whether there's something that could be expressed by allIn
16:25:17 <arkeet> and stuff.
16:25:36 <Rand_McNally> I think I'll just end up leaving that problem empty.
16:26:18 <Rand_McNally> unsolved*
16:26:38 <jedai> Rand_McNally: Your nub' isn't _that_ far off, you just need to refine the condition (and not output one element for each different following element)
16:27:06 <Rand_McNally> I don't care about nub' being wrong or not, I can work that out when I need it.
16:27:26 <Rand_McNally> But I'm waaay stuck on defining that property.
16:27:47 <Rand_McNally> Just comparing to "nub" would be the sensible thing to do, but I'm not allowed to, so...
16:28:42 <jedai> It's about the property ? Then arkeet gave you quite a hint, I'll add that you should probably write a AND between two properties :
16:29:11 <jedai> 1 that is as arkeet described and check the uniqueness of elements in the resulting list
16:29:26 <jedai> 2 that use this allIn
16:30:11 <Rand_McNally> I have an alternate property that checks if each element is different...
16:30:26 <Rand_McNally> But the problem explicitly states that it's not the same thing, albeit it's a necessary condition.
16:30:58 <jedai> Right, the key is in the property 2 (nub' shouldn't throw away more elements than nub)
16:31:25 <Rand_McNally> ...hmm...
16:31:41 <Rand_McNally> I'd need a counterexample.
16:32:02 <jedai> Rand_McNally: because if you just have property 1, "nub' = []" would be correct (all elements are differents)
16:32:25 <jedai> oops "nub' _ = []"
16:32:44 <Rand_McNally> I have defined a custom function, "distintos", that checks if each element is unique.
16:33:08 <Rand_McNally> It's awfully ugly, but seems to work.
16:33:22 <ion> dist into s?
16:33:26 <Rand_McNally> distintos xs = null [i|i<-[0..(lx-1)],elem (xs!!i) ((take i xs)++(drop (i+1) xs))]
16:33:30 <Rand_McNally> It's Spanish.
16:33:33 <Rand_McNally> "different"
16:33:51 <ion> Using a language other than English in code D-:
16:33:54 <arkeet> can I suggest my version?
16:34:00 <Rand_McNally> Not my choice.
16:34:07 <Rand_McNally> Of course, arkeet. :)
16:34:09 <arkeet> ok
16:34:18 <arkeet> distintos [] = True; distontos (x:xs) = all (x /=) xs && distintos xs
16:34:36 <arkeet> I can't type distintos, apparently.
16:34:54 <Rand_McNally> distontos means something like "dis-fools"
16:34:58 <arkeet> haha.
16:35:11 <Rand_McNally> ...beautiful, btw.
16:35:22 <jedai> Rand_McNally: because you don't need to check previous elements, if they were identical, you would already have caught it, arkeet solution take advantage of this
16:35:59 <Rand_McNally> Brb, implementing it.
16:36:08 <Rand_McNally> If this works, I'll owe you all a beer.
16:36:38 <arkeet> the other thing you'd want to check is that nub xs contains all the elements of xs.
16:36:40 <hpc> 1182 beers
16:37:01 <arkeet> all (`elem` xs) (nub xs) or something.
16:38:00 <Rand_McNally> I'm a Math undergrad, so I'm thinking about it in terms of sets and conditions.
16:38:43 <Rand_McNally> The problem states that nubbed sets /= sets satisfying "distintos"...
16:39:32 <Rand_McNally> So I've been trying to find a counterexample, but found none.
16:41:40 <trillioneyes> Rand_McNally: if the original set is [1,2,3,2,5], [2,4,5] satisfies distintos but is not the correct nub
16:42:21 <Rand_McNally> Still, nubbed [1,2,3,2,5] would satisfy distintos.
16:43:23 <Rand_McNally> I apologize for my cloudy English, it's not my native language and it's already 1:30am on here.
16:44:06 <jedai> arkeet: that's where the allIn enter the scene :)
16:44:22 <Rand_McNally> distintos . nub' should be always True.... except that it isn't, but I can't think of any particular example
16:44:38 <jedai> Rand_McNally: As I said, "nub' _ = []" satisfy distintos but isn't likely to be correct
16:45:01 <FreeFull> Quickcheck is useful
16:45:26 <jedai> Do you mean with your nub' ?
16:45:33 <jedai> > let nub' xs = [xs!!i|i<-[0..ls],j<-[i..ls], xs!!i /= xs!!j] where ls = length xs - 1 in nub' [1..4]
16:45:34 <lambdabot>   [1,1,1,2,2,3]
16:45:35 <Rand_McNally> Haskelito feliz> distintos [] -> True
16:45:38 <jedai> look ^
16:46:03 <Rand_McNally> Apparently.
16:46:04 <arkeet> yes, that looks pretty incorrect.
16:46:24 <Rand_McNally> That function is wrong, I know.
16:46:35 <mm_freak> Clint: thanks, i will adjust the dependencies
16:46:39 <Rand_McNally> I don't really care about my function.
16:46:41 <jedai> the problem is that one element will be repeated as many time as there are different elements after it...
16:46:46 <arkeet> ok :)
16:47:42 <Rand_McNally> Thank you all...
16:48:07 <jedai> Rand_McNally: If you're speaking in general, distintos . nub' xs should _always_ be true, but it isn't enough for nub' to be equivalent to nub, if it was, the function that constantly returns [] would be equivalent to nub... :)
16:48:30 <Rand_McNally> That's what I needed.
16:48:45 <Rand_McNally> ...thank you.
16:49:00 <Rand_McNally> Jedai, arkeet, I owe you both a drink.
16:49:26 <arkeet> as long as it's non-alcoholic. ;)
16:49:38 <Narvius> The cool thing about nerds is, you can introduce any definition in a conversation, and they'll run with it.
16:49:59 <mm_freak> Narvius: totally
16:50:03 <mm_freak> > let 2 + 2 = 5 in 2 + 2
16:50:04 <Narvius> Try doing something like "distintos" with non-technical people.
16:50:04 <lambdabot>   5
16:50:07 <mm_freak> lambdabot is a nerd =)
16:50:10 <Narvius> xDDD
16:50:12 <jedai> you're welcome :)
16:50:13 <Narvius> Nice.
16:50:30 <Rand_McNally> It wasn't my choice to use Spanish names for functions and the like.
16:50:41 <Narvius> I know, I followed it all from the start. :)
16:50:58 <mm_freak> what would a "distinto" be?
16:51:00 <Rand_McNally> I hate my whole university's CS department so much...
16:51:11 <Rand_McNally> Something "distinto" is something different, that's all.
16:51:17 <Rand_McNally> Also, "tinto" is a kind of wine.
16:51:29 <Narvius> But noone felt the need to rename it to something non-spanish, since it might as well be called distinto.
16:51:35 <mm_freak> ah, i've read it as "dist-into", which sounded weird =)
16:51:44 <Narvius> Un-Wine?
16:51:47 <jedai> in french you would say the elements are distincts
16:52:12 <Rand_McNally> "dees-teen-toh", probably.
16:52:12 <mm_freak> so "set"
16:52:27 <mm_freak> (as opposed to multisets)
16:53:04 <Rand_McNally> You know what?
16:53:15 <Rand_McNally> I wrote every single comment in my code in English.
16:53:44 <Narvius> Yeah, stick it to the man.
16:54:12 <Rand_McNally> Even if Haskell actually allows for Spanish names in functions and the like. :p
16:54:30 <arkeet> yes you can put unicode letters in names.
16:54:47 <Narvius> Iunno, though. Non-english code makes it harder to read for me. English isn't my primary language, rather my third, but I've always used english in programs. Always. For nine years.
16:55:07 <Narvius> It's a habit that probably won't die anymore.
16:55:13 <mm_freak> well, "distinto", read as "dist-into" and "into" taken as a synonym for "injection" could mean anything, including distilled alcohol
16:55:13 <Rand_McNally> It makes sense, after all.
16:55:19 <zrho> Does it use z encoding for all unicode characters?
16:55:30 <jedai> It's the "lingua franca" of computer science anyways ;-)
16:55:34 <Rand_McNally> Yep.
16:56:16 <Rand_McNally> But my classmates don't know anything about English, so the CS deparment chose to "translate" function names.
16:56:41 <mm_freak> i'm fine with english as the "de facto" standard language for programming, if you could just scratch "do", "make", "get" and "set" from the dictionary =)
16:57:16 <dwcook> > let arruínaloTodo = undefined in arruínaloTodo
16:57:17 <lambdabot>   *Exception: Prelude.undefined
16:57:23 <Rand_McNally> xD
16:57:52 <zrho> We have the same problem in Germany. It gets really weird when parsers become "Zerteiler".
16:58:02 <Narvius> wait
16:58:02 <Narvius> what
16:58:04 <Narvius> Zerteiler
16:58:06 <zrho> Yep.
16:58:06 <Narvius> Seriously.
16:58:19 <zrho> I needed like 20s to realize what he was talking about.
16:58:25 <Narvius> How does that even relate
16:58:28 <mm_freak> zrho: how about Leser?  you don't have to translate literally
16:58:40 <jedai> Doing computer science without any knowledge of english strike me as non-optimal... I hope they have language courses ?
16:58:41 <zrho> parser from pars, latin, the part.
16:59:01 <sipa> what does Zerteiler mean?
16:59:07 <jedai> teil is part too, isn't it ?
16:59:08 <Narvius> Well, fair enough. But I don't see how Parser is unsuitable, it sounds perfectly fine for german.
16:59:15 <Rand_McNally> These are just programming courses for mathematics undergrads, so...
16:59:16 <mm_freak> grammatik :: Leser Syntaxbaum
16:59:24 <Narvius> ;_;
16:59:24 <zrho> Pretty much.
16:59:31 <jedai> leser ?
16:59:33 <Narvius> Reader
16:59:42 <Narvius> Which might explain why it wasn't used
16:59:56 <Narvius> I still contend that Parser would be fine.
17:00:23 <mm_freak> if you were to insist on localized source code, i think Leser for Parser would be fine, and Umgebung for Reader
17:00:23 <Rand_McNally> .-.
17:00:40 <Narvius> According to the Duden, parsen is a perfectly valid verb
17:00:44 <jedai> Damn, I've forgotten all of my deutsch... I did almost 7 years of it...
17:00:47 <Narvius> Which means Parser is okay.
17:00:48 * Rand_McNally 's German knowledge increased half a point!
17:01:18 <mm_freak> Narvius: because "parsen" is an anglicism
17:01:19 <jedai> Rand_McNally: on what scale ?? ;)
17:01:42 <Rand_McNally> Millionths. ;_;
17:01:58 <mm_freak> it's like "kindergarten" is a perfectly valid english noun
17:02:00 <Narvius> So is Computer, and yet noone wants to replace every occurence of it with Rechner _^_
17:02:10 <flebron> If I have a file Foo.hs, which defines a module Foo, in the same directory I should be able to say "ghci", then "import Foo", and have Foo loaded, right?
17:02:14 <Rand_McNally> Also perfectly valid Spanish in South America.
17:02:20 <Narvius> xD
17:02:29 <Rand_McNally> Because of American influence.
17:02:41 <jedai> flebron: I think so ?
17:02:49 <mm_freak> Narvius: really?  i ususally say "rechner"
17:02:54 <mm_freak> when talking in german
17:03:17 <zrho> @flebron: I think you have to explicitly load the file.
17:03:17 <Rand_McNally> Spanish -> "ordenador", which came from French's "ordinateur".
17:03:18 <lambdabot> Unknown command, try @list
17:03:26 <Narvius> That was not a good example, true. :D
17:03:30 <mzero> flebron: no, :load Foo.hs
17:03:33 <Rand_McNally> At least we didn't adopt that stupid "octet" thing.
17:03:44 <flebron> Ah, OK. Thanks :)
17:04:57 <arkeet> you don't say "computadora"?
17:05:09 <mm_freak> in fact i prefer "rechner" over "computer"; mainly because "computer" is pronounced "com-puu-to" by most germans above a certain age, so it has a certain noob quality =)
17:05:12 <arkeet> I suppose it depends on what spanish-speaking place you're in.
17:05:26 <monochrom> (latin) octium, (french) octeur, (german) achtzeit :)
17:05:50 <zrho> Question about naming: Let's say I have a data structure DAG, a directed acyclic tree, and I have defined functor and comonad instances.
17:05:54 <Rand_McNally> Nope, that's in American Spanish.
17:05:59 <jedai> Rand_McNally: well bit/octet is actually much less confusing than bit/byte
17:06:12 <Rand_McNally> Although I use "computadora" too.
17:06:18 <edwardk_> zrho: so far so good
17:06:18 * flebron says computadora in Argentina.
17:06:57 <Narvius> Can someone explain the term "categorical dual" to me?
17:06:59 <Rand_McNally> It's not because of confusion, it's just that I haven't seen "bytes" as "octets" anywhere else.
17:07:04 <zrho>  With [] being used for adjacency lists, obviously this corresponds to a cofree over [], so cata is straightforward. What would you name a function (a -> [b] -> b) -> DAG a -> DAG b, which acts like extend, but uses the already changed values.
17:07:47 <Rand_McNally> "Computadora", "something that computes"; "Ordenador", "something that orders things".
17:08:00 <mzero> "octets" is the term used in all IETF work
17:08:02 <jedai> Rand_McNally: Right, it does cause some problems when computers start speaking about MB :)
17:08:22 <arkeet> my favourite one is where people use mb.
17:08:28 <jedai> mzero: Really ? Any reason why ?
17:08:29 <arkeet> I never figured out what a millibit is.
17:08:32 <Rand_McNally> xD
17:09:01 <monochrom> indeed, my first computer programming class was concerned greatly with ordering things (bubble sort)
17:09:04 <mm_freak> Narvius: take a categorical concept, flip all arrows, the result is dual to the original concept
17:09:08 <Narvius> Millibits are used to describe the amount of information a person using that unit could convey to you about information units.
17:09:11 <zrho> @Narvius: When you have a category, you can get its dual category by reversing all arrows. Many structures have dual notions, which just correspond to the same definition with all arrows reversed.
17:09:11 <lambdabot> Unknown command, try @list
17:09:25 <monochrom> please delete the "@" there
17:09:32 <Rand_McNally> @tomorrow.
17:09:33 <lambdabot> Unknown command, try @list
17:09:33 <mzero> because there was a time when "byte" refered to the unit of memory addressable by one unit of address --- and not all computers had 8-bits per such unit. Many earily computers had 7 or even 6
17:09:40 <Rand_McNally> Ish.
17:09:48 <jedai> arkeet: Then there's the MiB which as far as I understand is what we used to call MB for years before the disk industry pushed for its redefinition so that all capacity would look better
17:10:03 <mm_freak> Narvius: category vs. opposite category, monad vs. comonad, product vs. coproduct, etc.
17:10:10 <Narvius> That's... straightforward.
17:10:10 <Rand_McNally> I thought it was to harmonise it with standard prefixes.
17:10:28 <arkeet> some notions are self-dual, though, so you never hear of people talking about cofunctors.
17:10:30 <Rand_McNally> M = 10⁶, G = 10⁹...
17:10:33 <geekosaur> had nothing to do with disk industry, it was the SI folks being pissy someone used kilo for something other than their decreed 1000
17:10:35 <Narvius> I think about now is the time to get some introductory category theory reading material.
17:10:48 <arkeet> some people say "cofunctor" for contravariant functor. those people are weird.
17:10:52 <sipa> 100-megabit ethernet always meant 100 megabit
17:11:00 <Rand_McNally> Everyone in Mathematics recommends "Categories for the working mathematician" by MacLane.
17:11:13 <Rand_McNally> But I don't know of someone who actually read it, so...
17:11:20 <jedai> mzero: ok, thanks, never thought about it before !
17:11:21 <Rand_McNally> of anyone*
17:11:26 <zrho> I don't like MacLane that much
17:11:31 <Narvius> So what do you recommend?
17:11:46 <Rand_McNally> IANAM yet :(
17:11:50 <danharaj> Mac Lane is for mathematicians.
17:11:51 <mzero> Actually, historically M has always meant 10⁶, and it's use in computers was ambiguous for years
17:11:56 <zrho> I think steve awodey has a pretty decent introduction.
17:12:11 <general-general> Hello. I am looking for some pithy & informed comments on why one would choose Haskell over say Python, Perl or any other language...
17:12:13 <mzero> Mi, or Mebi- was added to make it clear in all contexts
17:12:35 <jedai> I stand by my description of history, even if I have absolutely no evidence for it :)
17:13:00 <zrho> If you want to mix it a bit with algebra, "algebra chapter 0" is quite nice, too. And for some interesting, but pretty advanced stuff "TheCatsters" on youtube.
17:13:05 <mm_freak> class Cofunctor f where comap :: (f a -> f b) -> a -> b
17:13:14 <jdhutah> i second Awodey
17:13:59 <mm_freak> there was a guy on youtube who had a pretty decent introduction to CT, but for some reasons his videos are no longer public
17:14:00 <Narvius> Pulled up his university page.
17:14:01 <jedai> Fact is both terminologies are currently present and so you get large discrepancies between programs/description/ ... (though if it's an ad, you can be sure they're using the new definition, they must really like the SI...)
17:14:36 <Narvius> Uhm.
17:14:47 <monochrom> you may want to read 2 books, not one. the 1st book is short, Benjamin Pierce's "category theory for computer scientists" or close. do whatever you like for the 2nd book, Awodey or MacLane
17:14:50 <Narvius> Can someone link me that Awodey introduction? _^_
17:15:01 <Narvius> Hm
17:15:06 <Narvius> CT for computer scientists?
17:15:07 <jedai> general-general: They're completely differents !
17:15:11 <Eduard_Munteanu> Is Alex still a reasonable option these days for parsing? I find (atto)parsec's non-layered approach a bit disturbing.
17:15:14 <Narvius> Sounds somewhat like what I want.
17:15:24 <monochrom> however, I prefer Fokkinga's "a gentle introduction to category theory"
17:15:25 <mzero> YOW - just built Haskell Platform for Mac - alpha of the next release -- it is 261MB!  (note, not MiB!)
17:15:27 <mm_freak> Eduard_Munteanu: happy is
17:15:33 <mm_freak> Eduard_Munteanu: you usually use alex together with happy
17:15:59 <jedai> general-general: the first and most obvious difference is that both python and perl are dynamic languages whereas Haskell has one of the more powerful static type system
17:15:59 <Eduard_Munteanu> mm_freak: any thoughts on alex+happy vs parsec, in your experience?
17:16:00 <monochrom> w00t mzero, which GHC does it endorse?
17:16:05 <mzero> Eduard_Munteanu: you can layer with Parsec!
17:16:32 <mzero> just write a lexer that produces a stream of tokens - then write a second parser over [Token] rather than String
17:16:47 <Eduard_Munteanu> mzero: well, I was admittedly going for attoparsec. But even Parsec seems to have that tokenizer generator as sort of a 2nd class citizen.
17:16:48 <mzero> The most recent release GHC: 7.6.3
17:17:00 <mm_freak> Eduard_Munteanu: you can have shorter grammar descriptions and encode some grammatical features more easily (like left-recursive grammars), but it's not a combinator approach, so you don't get first class parsers
17:17:10 <mzero> no no - I mean just write your own tokenizer - often easier!
17:17:12 <monochrom> I have an example of what you do with [Token]. http://www.vex.net/~trebla/haskell/parsec-generally.xhtml
17:17:14 <general-general> OK, jedai, I suppose I'm curious as to how this 'difference' is one that helps (or perhaps hinders, although I'm guessing no one will say it hinders) anyone who is programming stuff that is regex intensive.
17:17:35 <mm_freak> Eduard_Munteanu: and yes, what mzero said
17:17:43 <monochrom> I just don't have an example of how to produce that [Token]
17:17:47 <Eduard_Munteanu> Hm, so two passes with attoparsec would be fine.
17:17:52 <jdhutah> Narvius: I kinda like CT for Scientists also, by David Spivak (not the famous Spivak). http://ocw.mit.edu/courses/mathematics/18-s996-category-theory-for-scientists-spring-2013/textbook/
17:18:14 <mm_freak> Eduard_Munteanu: depending on the complexity of your grammar the first pass may not actually be an attoparsec pass
17:18:19 <general-general> &/or any other aspect of Haskell that makes regex using Haskell 'the thing to do' if you are willing to develop in Haskell.
17:18:19 <Narvius> Reading Fokkinga now. :S
17:18:21 <Rand_McNally> How would you define a function that gets the first common element of two ordered lists?
17:18:26 <Rand_McNally> My try at it was...
17:18:28 <jedai> general-general: if you're restricting yourself to regex, you probably don't want to use Haskell... Though you may gain much by using real parsers instead and Haskell is among the best to write those
17:18:31 <Eduard_Munteanu> mm_freak: yeah, it could just be 'words'
17:18:32 <Rand_McNally> Please don't laugh at me.
17:18:38 <mzero> well, two passes with attoparsec isn't really feasible - it is only over ByteString
17:18:55 <mzero> attoparsec is mostly good for parsing wire- and disk- formats
17:18:56 <Rand_McNally> firstCom xs ys =  head $ head $ filter (not.null)[[x|x<-xs, x<=y, elem x ys]|y<-ys]
17:19:02 <zrho> Hm CT for CS looks quite nice.
17:19:06 <general-general> Do you mean to write something like your own specialized regex program?
17:19:13 <Rand_McNally> It works, but it's horrifically inefficient.
17:19:21 <Eduard_Munteanu> I tried embedding the lexer as a transparent layer, basically making the 2nd stage operate on Text too.
17:19:26 <zrho> They even picked up that databases and schemas as categories concept.
17:19:28 <Eduard_Munteanu> But it's a bit awkward.
17:19:30 <hpc> Rand_McNally: firstCom = dropWhile (uncurry (==)) .: zip
17:19:36 <hpc> (.:) = fmap fmap fmap
17:19:37 <mm_freak> mzero: recent attoparsecs support Text
17:19:45 <mzero> 'k
17:19:50 <hpc> er, dropWhile (uncurry (/=))
17:19:51 <Rand_McNally> The lists may be potentially infinite.
17:19:54 <mzero> still not Token for some user type Token
17:20:03 <jedai> general-general: not that Haskell don't do regex, it's not bad with them really, though pretty disconcerting but regex becomes an unmaintainable mess very fast (note : Perl hacker speaking here, I've wrote my lot of regex)
17:20:07 <mzero> Rand_McNally: your problem seems under-specified
17:20:11 <mzero> what do you mean by common?
17:20:22 <jedai> general-general: what are you using regex for ?
17:20:29 <Rand_McNally> Element of both lists.
17:20:30 <Narvius> I'm pretty sure "firstCom [1,2,3,4] [5,7,1,3] == 1"
17:20:37 <Narvius> According to what I know.
17:20:37 <Rand_McNally> Yeah.
17:20:43 <mm_freak> mzero: [Token] is supported
17:20:46 <Narvius> Thus hpc's solution prolly won't work.
17:20:47 <Eduard_Munteanu> I can write my parser as an applicative wrapper over a tokenizer.
17:20:55 <mm_freak> mzero: Parser t a, where t has to be a Monoid
17:21:03 <mzero> in attoparsec?
17:21:07 <mm_freak> yes
17:21:11 <mzero> who knew?
17:21:15 <general-general> jedai, messaged.
17:21:16 <mzero> what separates it from parsec then?
17:21:20 <jedai> Rand_McNally: I would really just write the recursion by hand
17:21:34 <Eduard_Munteanu> mzero: it's not a transformer, for one thing
17:21:37 <Rand_McNally> I'm supposed to use it with infinite lists.
17:21:53 <mm_freak> mzero: it's still cheaper, because it doesn't have all the diagnostics features of parsec
17:22:23 <mm_freak> but the performance difference became much smaller
17:22:34 <mm_freak> attoparsec become slower while parsec became faster
17:22:42 <mm_freak> became
17:23:39 <jedai> Rand_McNally: That's really not a problem, (as long as there is a common element !)
17:23:45 <Eduard_Munteanu> mm_freak: do you have any preference for parsing Text into [Token] into your final datatype, vs. layering your own Applicative over a tokenizer?
17:24:06 <Eduard_Munteanu> In the latter case all stages work on Text, more or less.
17:24:14 <Rand_McNally> And then use that function like this.
17:24:19 <mm_freak> Eduard_Munteanu: no general preference, completely dependent on the situation
17:24:25 <Narvius> @hoogle (Applicative f) => f a -> a
17:24:25 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
17:24:25 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
17:24:25 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
17:24:38 <mm_freak> often i don't even use a parser library
17:24:43 <Rand_McNally> > thefunction (iterate (+n) n) (iterate (+m) m)
17:24:44 <lambdabot>   Not in scope: `thefunction'
17:24:47 <Narvius> Wait, no
17:24:52 <Rand_McNally> To find the least common multiple.
17:24:54 <Narvius> @hoogle (Monoid m) => m a -> a
17:24:54 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
17:24:54 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
17:24:54 <lambdabot> Data.Monoid getDual :: Dual a -> a
17:25:02 <Rand_McNally> My approach works but it's way too slow.
17:25:08 <mm_freak> splitThisWay >-> splitThatWay >-> splitSomeOtherWay >-> alrightNowDoStuff
17:25:35 <mm_freak> (with (>->) from pipes)
17:25:54 <Rand_McNally> I also included a "take m" and a "take n" to guarantee I'm not going to deal with infinite lists, but it's sooo slow...
17:26:13 <Narvius> :t foldr
17:26:14 <lambdabot> (a -> b -> b) -> b -> [a] -> b
17:26:20 <Narvius> :t fold mappend mempty
17:26:21 <lambdabot> (Foldable ((->) a), Monoid a) => a
17:26:30 <mm_freak> Rand_McNally: lcm?
17:26:31 <Narvius> what
17:26:34 <mm_freak> > lcm 12 15
17:26:36 <lambdabot>   60
17:26:48 <Rand_McNally> I have to redefine it, yep.
17:27:12 <mm_freak> > 12*15 `div` gcd 12 15
17:27:13 <lambdabot>   60
17:27:16 <Rand_McNally> Thing is, my custom function works, but it gets slow when dealing with large numbers... such as 30.
17:27:20 <mm_freak> redefined =)
17:27:25 <Rand_McNally> Also I have to use multiples.
17:27:26 <Rand_McNally> :)
17:27:39 <mzero> Ah - this is HW? so a hint then: Rather than try to do this as a list comprehension --- it is really probably easier as a simple two or three clause recursive function
17:27:57 <mm_freak> well, if you don't want to define LCM in terms of GCD, the only way i know is to use the prime factorization of the arguments
17:28:08 <Narvius> > fold mappend mempty $ Just 3
17:28:09 <lambdabot>   Could not deduce (Data.Monoid.Monoid t)
17:28:10 <lambdabot>    arising from the ambiguity check...
17:28:14 <mm_freak> but this seems like a weird way to define LCM
17:28:16 <Narvius> > foldr mappend mempty $ Just 3
17:28:17 <lambdabot>   Couldn't match expected type `[b0]'
17:28:17 <lambdabot>              with actual type `Data.May...
17:28:25 <Rand_McNally> Nope, I have to use the list of multiples of m and n.
17:28:34 <mm_freak> ah
17:28:39 <zrho> That makes sense^^
17:28:45 <Rand_McNally> Define a function to get the first common element of two lists.
17:28:54 <mzero> but wait
17:29:00 <mm_freak> Rand_McNally: well, the list of multiples is sorted, so perform the merge step of a merge sort
17:29:00 <Rand_McNally> And then define lcm using that function and the list of multiples.
17:29:05 <mzero> is it a given that the lists are in ascending order?
17:29:11 <Rand_McNally> ...merge sort.
17:29:13 <mzero> or that their elements are even Ord?
17:29:18 <Rand_McNally> Wow.
17:29:23 <Rand_McNally> Integer.
17:29:34 <Rand_McNally> Brb, implementing.
17:29:46 <mzero> Okay - but "first common element of two lists" - isn't by itself, well defined in my view
17:29:56 <alexander__b> what would you guys suggest as the simplest and lightest gui library?
17:30:03 <jedai> mzero: the list are ordered so it is
17:30:10 <mm_freak> alexander__b: vty-ui
17:30:16 <hpc> alexander__b: webserver and CGI ;)
17:30:24 <alexander__b> mm_freak: not vty/curses/etc
17:30:29 <Rand_McNally> GLUT and a lot of patience.
17:30:33 <hpc> maybe wxhaskell?
17:30:35 <mm_freak> alexander__b: then what hpc said
17:30:43 <mzero> jedai: right, btu the "defina  function...." doesn't say they are ordered
17:30:44 <alexander__b> I want to write a stopwatch, so I need up/down buttons for hours/minutes/seconds, and a start/pause reset button. that's it.
17:30:45 <Eduard_Munteanu> alexander__b: gtk2hs isn't very complex, though not light either I guess
17:30:47 <mm_freak> well, not quite
17:30:55 <mm_freak> alexander__b: my favorite GUI library is happstack =)
17:30:56 <hpc> it's a sad day when the lightest GUI library one can think of is gecko
17:31:02 <mzero> doesn't say "first common element of two monotonically increasing lists"
17:31:12 <alexander__b> I am going to do this project to learn how to do... more advanced stuff, for the record. this is just to get a feel for gui programming with haskell.
17:31:13 <Rand_McNally> It's implicit, since I'm using it to compute the lcm.
17:31:23 <alexander__b> I should also not that I'd love something that's declarative in the large not in the small
17:31:33 <jedai> mzero: but he said "define a function that gets the first common element of two ordered lists"
17:31:51 <alexander__b> I read a paper on FranTK and it seemed nice, but I can't find anything about it. other than that I see people mention wxhaskell and gtk2hs a lot.
17:32:08 <jedai> alexander__b: you have threepenny-gui
17:32:15 <alexander__b> Eduard_Munteanu: would you say gtk2hs would be "simple enough" a starting point for gui haskell programming? bearing in mind the simplicity of my project.
17:32:31 <alexander__b> my main worry about gtk2hs is that it won't be declarative, and a bunch of imperative haskell coding.
17:32:36 <jedai> alexander__b: though there are almost no widgets actually (it builds a gui in the browser)
17:32:39 <mm_freak> alexander__b: widget-based or scene-based?
17:32:49 <alexander__b> mm_freak: it's a stopwatch with a few buttons. does it really matter? heh
17:32:57 <mm_freak> yes, it does
17:32:58 <Eduard_Munteanu> alexander__b: yes, perhaps not as light as it could be, but it's rather straightforward to start with gtk2hs
17:33:01 <alexander__b> I haven't decided what to use for my big big project for my master thesis.
17:33:04 <alexander__b> mm_freak: then I'm not sure.
17:33:24 <mm_freak> for widget-based see reactive-banana or combine sodium with one of the GUI bindings
17:33:40 <Narvius> > foldr mappend mempty [Sum 3, Sum 2, Sum 1, Sum 0]
17:33:41 <lambdabot>   Sum {getSum = 6}
17:33:44 <Narvius> Heh.
17:33:44 <mm_freak> for scene-based see netwire and combine it with OpenGL
17:33:54 <Eduard_Munteanu> FRP GUI stuff isn't particularly easy to work with, though.
17:33:56 <alexander__b> mm_freak: opengl sounds heavy-handed
17:33:59 <Eduard_Munteanu> Aside from simple examples.
17:34:02 <alexander__b> I mean it's a stopwatch
17:34:07 <Narvius> "Binary operation with neutral element."
17:34:11 <mm_freak> Eduard_Munteanu: it is, you just need to understand it =)
17:34:14 <Narvius> Sorry, associative binary operation.
17:34:17 <alexander__b> i.e. I'll probably go  widget based
17:35:00 <mm_freak> alexander__b: then my personal preference is sodium, but look into reactive-banana, too
17:35:01 <jedai> alexander__b: threepenny-gui is based on the same idea than reactive-banana (it's the same guy apfelmus)
17:35:11 <alexander__b> right
17:35:56 <mm_freak> all three choices are FRP, so declarative (rather than based on event callbacks and other insanity)
17:36:00 <jedai> alexander__b: you would have to code some widgets but nothing too onerous (it's just html and css, you can get something on the net if you wish and adapt it to your needs)
17:36:10 <alexander__b> html and css ugh
17:36:28 <Eduard_Munteanu> Yeah, that's rather eww.
17:36:51 <alexander__b> if it weren't haskell I think I'd just use tk or something. it's just a stopwatch. "how hard can it be" etc.
17:37:10 <mm_freak> a stopwatch is far from trivial =)
17:37:17 <alexander__b> mm_freak: sodium and reactive-banana are apparently both "general purpose reactive programming systems"
17:37:30 <alexander__b> mm_freak: where does GUI come into the picture (hurr durr)?
17:37:41 <mm_freak> alexander__b: they claim to be, but they're not =)
17:37:47 <alexander__b> mm_freak: I have written one in Python in very few lines. that was quite trivial. IDR what GUI I used though.
17:37:51 <mm_freak> there is no "general purpose" FRP implementation
17:38:01 <Eduard_Munteanu> alexander__b: if you can call external commands to create the UI, e.g. like dialog stuff, I wouldn't exclude that either
17:38:18 <mm_freak> simply because different applications need entirely different approaches…  in fact you can combine the FRP frameworks
17:38:20 <jedai> alexander__b: threepenny-gui is really pretty nice (take a look at it)
17:38:27 <alexander__b> (pygtk apparently)
17:38:53 <alexander__b> jedai: I'm not interested in doing anything for a Web browser
17:39:18 <mm_freak> alexander__b: none of the choices require much more than a few lines of code…  it's just that there are lots and lots of choices =)
17:39:24 <alexander__b> mm_freak: OK, but my real question was where does GUI come into the picture? do they have GUI-library thingies, or did you mean to combine them with one?
17:39:39 <mm_freak> you can always just pick up the GTK+ bindings and do whatever you've done in python
17:39:45 <mm_freak> it's almost the same API
17:40:12 <alexander__b> I see. maybe I'll do gtk2hs to learn that. then later FRPise it to learn that. then do other stuff. then other stuff. because hacking. :-)
17:40:13 <mm_freak> in other words, you create widgets (or design UIs using glade), you assign event handlers, etc.
17:40:20 <jedai> alexander__b: reactive-banana used to have some links to wxhaskell, I don't know the current state of things though
17:40:56 <alexander__b> I have to do a real proper analysis of all these frameworks come master thesis time, I guess.
17:40:56 <himh> hi
17:41:18 <Eduard_Munteanu> himh: hi
17:41:22 <alexander__b> well, not guess, know. my master thesis is way too ambitious. :-)
17:41:23 <mm_freak> alexander__b: FRP and UIs are two completely separate concepts, but you can use FRP to express UIs
17:41:29 <waidmann> himh: hi
17:41:34 <mm_freak> alexander__b: so you can learn both separetely =)
17:41:46 <alexander__b> mm_freak: I know. which is why I think maybe I'll pick up gtk2hs and learn that first, and then frp-ise my code to learn the other. :-)
17:42:15 <alexander__b> jedai: found reactive-banana-wx, thanks
17:42:46 <mm_freak> for the classic native GUI reactive-banana-wx is probably the shortest path to success
17:43:00 <alexander__b> mm_freak: although tbf from my understandig of frp, frp-ising is not exactly straightforward, so I guess it'd be a complete rewrite, heh.
17:43:10 <alexander__b> mm_freak: OK thanks for the suggestion
17:43:18 <mm_freak> alexander__b: yes
17:44:02 <Eduard_Munteanu> mm_freak: btw, I was layering my parser when I noticed this might be related to the free monad: newtype Parser a = Pure a | Token (Lexer a), where Lexer is just a parsec parser. Then I made a straightforward Applicative such that (Token f) <*> (Token x) = Token (f <*> lex x), where 'lex' skips whitespace.
17:44:13 <Eduard_Munteanu> mm_freak: is this a known construction?
17:44:40 <jedai> alexander__b: Yes, going from classic gui gtk2hs to a reactive gui implementation isn't really something you can do step by step... :(
17:44:41 <Eduard_Munteanu> I mean it looks like I might generalize Parser to Free Lexer.
17:45:09 <Eduard_Munteanu> The idea was to insert whitespace skippers automatically.
17:45:10 <mm_freak> Eduard_Munteanu: that sounds similar to how pipes-parse works
17:45:36 <Eduard_Munteanu> Hm... I've been told that by somebody else, haven't taken a close look though.
17:45:37 <mm_freak> jedai: oh, you can do that
17:45:45 <mm_freak> jedai: see sodium
17:46:11 <alexander__b> I think maybe my master thesis program will have some sort of GIMP-ish layout, so with several toolboxes that work well for multi-monitor layouts. it's an "adventure game author" tool. it will have things like a "main scene window" where the user could put layers of images and designate "walkable area" of the image etc. but also completely different things like event trigger editing, NPC scripting, animation
17:46:13 <alexander__b> cycle editors, etc.
17:46:24 <jedai> mm_freak: really ? ok, i'll look at sodium but isn't there some clash between the two views ?
17:46:28 <alexander__b> or, and this is more likely, I will have a window that says "hello world" and has a few widgets. ;-)
17:46:45 <mm_freak> jedai: not necessarily
17:47:46 <mm_freak> alexander__b: i'd probably express the games themselves using FRP =)
17:48:02 <alexander__b> mm_freak: the goal is to design a high-level scripting language that might be FRP-ish
17:48:23 <mm_freak> "scripting" suggests an imperative language
17:48:28 <alexander__b> maaaaybe
17:48:35 <mm_freak> so no FRP =)
17:48:49 <alexander__b> the thesis is kind of maybe about what to do on the high-level game-designer-friendly front
17:49:14 <jedai> kind of maybe ?
17:49:44 <jedai> probably shall be ?
17:49:52 <alexander__b> undecided but need a "sort of kind of probably maybe I'll do this"
17:50:00 <alexander__b> ideas are welcome
17:50:14 <mm_freak> use haskell as the underlying "scripting" language
17:50:15 <alexander__b> I just had the idea to make this game authoring tool as a fun engineering project
17:50:24 <jedai> There's probably some good work to be done on the subject :)
17:50:28 <alexander__b> now I need to figure out how to get research out of it, heh
17:50:48 <alexander__b> so I was thinking about something like "how to frp/functional-ish high-level language for game designers"
17:51:23 <alexander__b> so the tool lets you make a scene with layered images, set up "walkable area", add actors, add behaviours and dialogue options, etc (think Monkey Island and classic SCUMM games). then the thesis is I guess on the language used for NPC scripting etc.
17:51:32 <himh> So just finishing the last chapters of LYAH and was wondering if ppl actually use monoids, create monoid instances, etc for their programs?
17:51:57 <Eduard_Munteanu> alexander__b: I think Blender's Game Engine is a bit FRP-y / circuit-y, and graphically
17:52:24 <mm_freak> Eduard_Munteanu: it's far from FRP
17:52:57 <Eduard_Munteanu> Yeah, I mean a bit more like Labview.
17:53:00 <alexander__b> I want the target audience to be 1. game design classes at bachelor level or similar -- but also 2. indie game devs. so it should be usable by professionals and newbies both. even children, preferably.
17:53:15 <mangaba_leitosa> what's the more efficient data structure to use for calculating word frequencies in the text? 'Data.Map.Lazy' seems to be slow on 'let update_freq map elem = Map.insertWith (+) elem 1 map in foldl update_freq Map.empty words'
17:53:27 <alexander__b> so the language needs to be dead simple. SCUMM had things like "actor walk-to place", which is of course extremely imperative.
17:53:34 <Eduard_Munteanu> mangaba_leitosa: IntMap
17:53:41 <mm_freak> FRP has two defining features:  reactive behaviors and declarative event handling…  the latter is a big deal, and something that uses event handlers is not and will never be FRP
17:53:52 <mangaba_leitosa> Eduard_Munteanu: but IntMap has Ints as keys, I need words as keys?
17:54:03 <Eduard_Munteanu> mangaba_leitosa: er, sorry, I mixed it up
17:54:08 <jedai> himh: definitely !
17:54:31 <Eduard_Munteanu> mangaba_leitosa: just make sure you're using Data.Map.Strict, not the ordinary one
17:54:32 <mm_freak> so please stop saying "FRP" just because you react automatically to value changes! ;)
17:54:34 <alexander__b> maybe the thesis can be on something like FRP for this high-level language. like how an actor's dialogue options may be expressed via frp, or whether it's walking around or just standing, etc.
17:54:36 <amalloy> himh: i'm still a beginner, but i've defined a few monoid instances. generally when i'm like "okay i want to add an X to this other X. i could define a custom function for this, but if i make it a monoid instead it'll be a little more flexible later on"
17:54:55 <Eduard_Munteanu> mangaba_leitosa: because ordinary numeric types are strict
17:54:56 <mangaba_leitosa> Eduard_Munteanu: I tried both Data.Map.Strict and Data.Map.Lazy, no difference
17:55:15 <conal> sadly "FRP" has come to be used for any vaguely "functional" approach to reactive programs.
17:55:46 <alexander__b> conal: the way I see FRP (being a newbie) is declarative event handling as opposed to "event listeners" and callback crap.
17:55:56 <alexander__b> + reacting of course
17:55:58 <jedai> himh: Monoid are neat, so often you come across a type in some library and you remark that two values may be combined... and you check and there's a Monoid instance for the type ! which mean you have access to all the good stuff on Monoid (+ some of the Foldable/Traversable/Lens stuff that use Monoid)
17:56:03 <pharaun> does the frp ones out there still have what its named - time leaks?
17:56:10 <alexander__b> space leaks?
17:56:19 <conal> alexander__b: have you read my two defining characteristics? (on a stack overflow answer)
17:56:21 <mm_freak> alexander__b: in FRP dialogue options are best expressed by switching
17:56:30 <Eduard_Munteanu> mangaba_leitosa: and how do you apply that function? Have you tried Map's foldl'?
17:56:30 <alexander__b> conal: 99.99% unlikely
17:56:58 <mangaba_leitosa> Eduard_Munteanu: 'let update_freq map elem = Map.insertWith (+) elem 1 map in foldl update_freq Map.empty words'
17:57:05 <alexander__b> mm_freak: I wonder if FRP can be used to make branching stories and dialogue more easy to reason about
17:57:27 <conal> http://stackoverflow.com/a/5878525/127335 and follow the links there
17:57:32 <mm_freak> alexander__b: probably
17:57:34 <Eduard_Munteanu> mangaba_leitosa: try foldl', make sure to enable optimizations, and I hope you're not using String for reading stuff
17:57:43 <alexander__b> mm_freak: OK that's my master thesis then. maybe. :-P
17:57:43 <himh> amalloy: How does it become more flexible later on? Asking, from a beginners perspective.
17:58:03 <mangaba_leitosa> Eduard_Munteanu: yes, I'm using String. shouldn't I? :-)
17:58:18 <mangaba_leitosa> Eduard_Munteanu: I mean, 'words' is [String]
17:58:40 <amalloy> himh: for the reason jedai just gave: i can pass it to some other library function that works with monoid
17:58:45 <Eduard_Munteanu> mangaba_leitosa: use Text. It gives you its own IO functions to read it and its own 'words'.
17:58:49 <mm_freak> alexander__b: you should give a formal definition of what constitutes a "correct game"
17:58:59 <conal> alexander__b: those posts describe the essential principles from which FRP came.
17:59:15 <alexander__b> conal: yes, I'm reading right now.
17:59:18 <amalloy> or use it in the Writer monad, for example
17:59:20 <alexander__b> mm_freak: why
17:59:20 <mangaba_leitosa> Eduard_Munteanu: how will that speed things up for my expression above?
17:59:22 <mm_freak> alexander__b: among the necessary properties should be a formal variant of "there is always a path to conclusion"
17:59:34 <mm_freak> alexander__b: then see if you can encode this in types and values
17:59:43 <Eduard_Munteanu> mangaba_leitosa: it can speed up IO considerably.
17:59:50 <alexander__b> mm_freak: oh, now I get what you mean by "correct game"
18:00:03 <mm_freak> alexander__b: a "reasonable" game =)
18:00:06 <mangaba_leitosa> Eduard_Munteanu: well, what's slow is the expression above for calculating frequencies, not I/O
18:00:17 <Eduard_Munteanu> mangaba_leitosa: how do you know?
18:00:40 <mangaba_leitosa> Eduard_Munteanu: benchmarking this expression :-)
18:00:48 <alexander__b> mm_freak: yes, I didn't consider the context of our conversation heh
18:01:15 <Eduard_Munteanu> mangaba_leitosa: with what sort of data? If your input was a String, then you might still be bottlenecked by that.
18:01:18 <Narvius> Hey, cool. Ordering has a monoid instance.
18:01:50 <hpc> (->) also has a Monoid instance sometimes
18:01:58 <mangaba_leitosa> Eduard_Munteanu: on String, yes. if I don't calculate frequencies, the program terminates immediately
18:01:59 <hpc> which has waaaaay cool interactions with Ordering and the Ord methods
18:02:32 <Eduard_Munteanu> mangaba_leitosa: if you don't calculate frequncies perhaps it doesn't even process the String at all.
18:02:49 <mangaba_leitosa> Eduard_Munteanu: no, I check this by printing the list of words
18:03:08 <hpc> > sortBy (comparing (!! 3) <> comparing (!! 1)) [[1, 1, 1], [2, 5, 0], [0, 2, 5]]
18:03:09 <lambdabot>   *Exception: Prelude.(!!): index too large
18:03:11 <mm_freak> :t \xs ys -> foldr (<>) EQ (zipWith compare xs ys)
18:03:12 <lambdabot> Ord b => [b] -> [b] -> Ordering
18:03:14 <mangaba_leitosa> Eduard_Munteanu: well, by doing 'length words', actually
18:03:19 <hpc> > sortBy (comparing (!! 2) <> comparing (!! 0)) [[1, 1, 1], [2, 5, 0], [0, 2, 5]]
18:03:20 <lambdabot>   [[2,5,0],[1,1,1],[0,2,5]]
18:03:44 <hpc> (<>) = mappend
18:03:59 <mangaba_leitosa> Eduard_Munteanu: so, I suspect that I just need a data structure other than Map, more suitable for constant updates
18:04:23 <mm_freak> conal: i'd be interested in your opinion about sodium
18:04:31 <mangaba_leitosa> Eduard_Munteanu: I looked at hashtables, but they all seem to work via the IO monad for some reason
18:04:33 <conal> mm_freak: url?
18:04:39 <alexander__b> conal: nice hat
18:04:44 <mm_freak> @hackage sodium
18:04:44 <lambdabot> http://hackage.haskell.org/package/sodium
18:04:59 <mangaba_leitosa> Eduard_Munteanu: maybe I need purely funtional hashtables
18:05:00 <Eduard_Munteanu> mangaba_leitosa: you could try this... see if it's any faster if you give it a list of numbers instead of words.
18:05:01 <mm_freak> conal: i'm surprised you haven't heard about it
18:05:04 <conal> alexander__b: thanks. i like it.
18:05:15 <conal> mm_freak: i have.
18:05:18 <Narvius> So basically...
18:05:23 <mm_freak> oh, ok
18:05:43 <mm_freak> it handles simultaneity very elegantly by having a transactional Reactive monad
18:05:50 <Narvius> hpc: So what does this sort by? :o
18:05:59 <Narvius> hpc: Wait, no, silly me.
18:05:59 <trillioneyes> mangaba_leitosa: hash tables derive their constant-time access from an array-like implementation, and arrays are a bit harder to do without mutation than trees are
18:06:07 <Narvius> hpc: I was looking at the arguments and not seeing any order _^_
18:06:08 <conal> mm_freak: anything specific you'd like my perspective on about sodium?
18:06:10 <alexander__b> conal: ohhhhh you wrote Push-pull functional reactive programming. I read that.
18:06:25 <trillioneyes> They're not impossible, but more thought and tradeoffs are required
18:06:29 <mangaba_leitosa> Eduard_Munteanu: here is what I have now: the 'words' list has 1108241 elements, and they contain 571913 unique words
18:06:43 <Eduard_Munteanu> mangaba_leitosa: besides, I still think String might cause issues, you can't really know. To use Text, just import Data.Text and Data.Text.IO qualified and use its 'words' and IO functions.
18:06:51 <mangaba_leitosa> Eduard_Munteanu: it's calculated in about 10 seconds, I need it immediately
18:07:01 <mm_freak> conal: just a general "rocks" vs. "sucks" with an optional one-sentence reason =)
18:07:14 <Eduard_Munteanu> mangaba_leitosa: hm...
18:07:45 <conal> mm_freak: i don't know what it is that sodium aims to implement. most so-called "frp" systems satisfy neither of the two fundamental properties i care about (denotative & continuous).
18:07:46 <Eduard_Munteanu> mangaba_leitosa: try increasing the min heap size, i.e. pass -H128m as an RTS option
18:07:59 <Eduard_Munteanu> mangaba_leitosa: the list itself might generate a bunch of garbage
18:08:06 <hpc> Narvius: it's sorting by the last element, then the first element
18:08:17 <Narvius> hpc: Yes, I already figured that out. xD
18:08:29 <mangaba_leitosa> trillioneyes: I see... So, no immutable hash tables?
18:08:31 <hpc> well i read slowly ;)
18:08:33 <conal> mm_freak: i think sodium is yet another such system. "changes" (http://hackage.haskell.org/package/sodium-0.9.0.0/docs/FRP-Sodium.html) is one red flag.
18:08:37 <mangaba_leitosa> Eduard_Munteanu: thanks, will try it now :-)
18:09:09 <Eduard_Munteanu> mangaba_leitosa: you should really profile it, and get the --stats output too.
18:09:36 <Eduard_Munteanu> Just mangling the code to disable it might not be predictable enough.
18:09:39 <alexander__b> conal: oh. I read Genuinely Functional User Interfaces too. it's always weird when I happen upon people I "know" on IRC.
18:09:45 <Narvius> Whoah, (<>) `on` comparing
18:09:47 <Narvius> Such power
18:09:48 <mangaba_leitosa> Eduard_Munteanu: my first thought is that Map's typical usage pattern is not like the one used for counting frequences
18:09:59 <conal> alexander__b: :)
18:10:13 <mangaba_leitosa> Eduard_Munteanu: so maybe there is another package for doing the same functionality more efficiently
18:10:14 <mm_freak> conal: well, it is written such that you can't even express continuous functions, so 'changes' does not necessarily violate the continuity property
18:10:23 <Eduard_Munteanu> mangaba_leitosa: log n lookup should be good enough for your dataset, really.
18:10:39 <conal> mm_freak: i bet changes means something operational, rather than denotational.
18:11:30 <conal> mm_freak: even without continuous time.
18:12:05 <Eduard_Munteanu> mangaba_leitosa: I'd also try rephrasing that as an M.fromListWith, instead of adding to a map, it might fuse away the list completely, especially with Data.Text.
18:12:16 <Narvius> So, turns out Ordering is the first Monoid instance I see a genuine practical application for.
18:12:22 <mm_freak> conal: associated with behaviors there is an "update" action, and 'changes' is the event that occurs when that update action is invoked
18:12:25 <Narvius> And once again, Haskell managed to blow my mind.
18:12:27 <Eduard_Munteanu> Lists as strings generate a lot of garbage, aside from being slow.
18:12:52 <Eduard_Munteanu> :t Data.Map.fromListWith
18:12:53 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
18:13:01 <conal> mm_freak: so what's the denotation of a "behavior" in sodium (if any)?
18:13:24 <mm_freak> conal: function of time
18:13:30 <Eduard_Munteanu> :t Data.Map.fromListWith (+) . flip zip (repeat 1)
18:13:31 <lambdabot> (Num a, Ord k) => [k] -> M.Map k a
18:13:37 <Eduard_Munteanu> Er.
18:13:43 <conal> mm_freak: great. now try to explain "changes".
18:13:50 <Eduard_Munteanu> Actually that's fine.
18:13:51 <trillioneyes> mangaba_leitosa: you can do some immutable approximation to hash tables, it just takes more work than immutable trees, which more or less work with the naive implementation
18:14:14 <mangaba_leitosa> Eduard_Munteanu: fromListWith needs a list of pairs, and the whole point of using Map here is to create such pairs :-)
18:14:15 <Eduard_Munteanu> > Data.Map.toList . Data.Map.fromListWith (+) . flip zip (repeat 1) $ ["foo", "bar", "foo"]
18:14:16 <lambdabot>   Not in scope: `Data.Map.toList'Not in scope: `Data.Map.fromListWith'
18:14:26 <Eduard_Munteanu> > Data.Map.toAscList . Data.Map.fromListWith (+) . flip zip (repeat 1) $ ["foo", "bar", "foo"]
18:14:27 <lambdabot>   Not in scope: `Data.Map.toAscList'Not in scope: `Data.Map.fromListWith'
18:14:29 <Eduard_Munteanu> Gr.
18:14:30 <mm_freak> conal: to be fair, i haven't seen a formal specification…  i'm drawing my conclusions from the API
18:15:08 <Eduard_Munteanu> mangaba_leitosa: you can give it ("word", 1) and use (+) to add the value up.
18:15:11 <mm_freak> conal: in sodium behaviors have to be staircase functions
18:15:16 <conal> mm_freak: that's fine. try to come up with a denotation for "changes" that's consistent with the model you suggested.
18:15:21 <mm_freak> conal: that allows a formal explanation of 'changes'
18:15:28 <Eduard_Munteanu> > M.toList . M.fromListWith (+) . flip zip (repeat 1) $ ["foo", "bar", "foo"]
18:15:29 <lambdabot>   [("bar",1),("foo",2)]
18:15:32 <conal> mm_freak: try it.
18:15:34 <Eduard_Munteanu> mangaba_leitosa: ^
18:15:53 <Eduard_Munteanu> mangaba_leitosa: but make sure to use Data.Map.Strict
18:16:19 <conal> mm_freak: if you try to work out the semantics, i think you'll discover the problem.
18:16:34 <mangaba_leitosa> Eduard_Munteanu: aha, so fromListWith can use the value already in the map... I missed that. thanks! :-)
18:16:43 <mm_freak> conal: ok, this is the type of staircase functions of time:  type Behavior a = Time -> (a, Time)
18:16:48 <mangaba_leitosa> Eduard_Munteanu: will try to see if it makes any change
18:17:04 <Eduard_Munteanu> mangaba_leitosa: also don't forget, use at least -O to compile your code.
18:17:19 <mm_freak> interpretation:  a value and the remaining positive duration for the given value
18:17:25 <mangaba_leitosa> Eduard_Munteanu: yes, I'm trying with -O2
18:17:26 <Eduard_Munteanu> Benchmarking without optimizations is rather useless.
18:17:29 <conal> mm_freak: why the (, Time)?
18:17:30 <Eduard_Munteanu> Oh, ok.
18:17:41 <mm_freak> conal: see above
18:18:55 <Eduard_Munteanu> mangaba_leitosa: it might help to use Int instead of Integer as well, btw.
18:19:40 <Eduard_Munteanu> Pattern-matching in Integers can get significant if you're adding 1 a bunch of ftimes.
18:19:48 <Eduard_Munteanu> @src Integer
18:19:48 <lambdabot> data Integer = S# Int#
18:19:48 <lambdabot>              | J# Int# ByteArray#
18:20:08 <mm_freak> then let type Event a = [(Time, a)]
18:20:08 <mm_freak> changes :: Behavior a -> Event a
18:20:10 <mangaba_leitosa> Eduard_Munteanu: the fromListWith approach did not make any difference...
18:20:14 <mangaba_leitosa> Eduard_Munteanu: now trying Int :-)
18:21:11 <mm_freak> changes = changes' 0  where changes' t f = let (x, dt) = f t in (t, x) : changes (t + dt) f
18:21:19 <Eduard_Munteanu> mangaba_leitosa: if you import Data.Text and Data.Text.IO qualified, you could just replace hGetContents and words directly.
18:21:39 <mangaba_leitosa> Eduard_Munteanu: thanks, will also try this...
18:22:23 <mm_freak> conal: minus the typo that should work, doesn't it?  it's a variant of FRP that strictly disallows continuous functions
18:22:38 <Eduard_Munteanu> I think the lists are generating a lot of garbage.
18:23:48 <Eduard_Munteanu> Not only because they're lists, but because Prelude stuff generally doesn't fuse away.
18:23:56 <mangaba_leitosa> Eduard_Munteanu: no luck with Int either :-) now will try Text :-)
18:24:20 <Eduard_Munteanu> It's good to know what does not help, too. :)
18:24:29 <mangaba_leitosa> Eduard_Munteanu: indeed :-)
18:25:28 <Eduard_Munteanu> I remember someone asking a very similar question a few days ago, I cooked up my own implementation, perhaps you could test it...
18:25:51 <Eduard_Munteanu> mangaba_leitosa: http://lpaste.net/95202
18:26:28 <Eduard_Munteanu> Just making sure there isn't other stuff like packing/unpacking Text in your code.
18:26:31 <mangaba_leitosa> Eduard_Munteanu: btw, maybe it matters... My words are not real words. They are all possible strings of length 10 encountered in the text file
18:28:05 <mangaba_leitosa> Eduard_Munteanu: I generate the words as follows: words l = [ tail  | tail <- (map (take k) . tails) l, length tail >= k ]
18:28:10 <mangaba_leitosa> Eduard_Munteanu: where l is String
18:28:53 <mangaba_leitosa> Eduard_Munteanu: but this function completes immediately, it's counting frequencies which is done further that is slow
18:28:58 <Eduard_Munteanu> mangaba_leitosa: why not  filter (\w -> length w == 10)  ?
18:29:38 <Eduard_Munteanu> Not sure what yours aims for though.
18:29:43 <mangaba_leitosa> Eduard_Munteanu: oops, no, really it's words k l = [ tail  | tail <- (map (take k) . tails) l, length tail >= k ]
18:30:09 <mangaba_leitosa> Eduard_Munteanu: yes, filter would be better :-)
18:30:31 <mangaba_leitosa> Eduard_Munteanu: but I'm optimizing another function anyway (counting frequencies, this one is fast)
18:31:10 <Eduard_Munteanu> mangaba_leitosa: are you trying to get at parts of words that have a length of 10?
18:31:11 <mangaba_leitosa> Eduard_Munteanu: I only mentioned the way the words are created because maybe it has some effects on the garbage collection
18:31:27 <Eduard_Munteanu> mangaba_leitosa: hm yeah, it might
18:32:26 <mangaba_leitosa> Eduard_Munteanu: no, I'm not interested in parts of those length 10 words, just the whole words  :-)
18:34:34 <Eduard_Munteanu> mangaba_leitosa: I remember benchmarking a while ago, even stuff like foldl' (+) 0 [1..1000000] can be slow with base / Prelude stuff.
18:34:40 <mangaba_leitosa> Eduard_Munteanu: I'm looking at your code http://lpaste.net/95202. I can see that you use Word32 instead of Int
18:35:00 <Eduard_Munteanu> Yeah, Word32 shouldn't make a difference though.
18:35:05 <mangaba_leitosa> Eduard_Munteanu: and what's the alternative stuff?
18:35:50 <Eduard_Munteanu> mangaba_leitosa: stream-fusion's lists fuse away... i.e. they compile to a loop.
18:35:58 <Eduard_Munteanu> For that scenario.
18:36:48 <mangaba_leitosa> Eduard_Munteanu: stream-fusion is an experimental feature, right?
18:36:56 <Eduard_Munteanu> mangaba_leitosa: http://hackage.haskell.org/package/stream-fusion-0.1.2.5/docs/Data-List-Stream.html
18:37:17 <Eduard_Munteanu> No, just a package with a few more combinators and a lot more RULES.
18:37:51 <mangaba_leitosa> Eduard_Munteanu: right, and marked as 'Stability: experimental'
18:37:56 <mangaba_leitosa> Eduard_Munteanu: will try now :-)
18:38:05 <mangaba_leitosa> Eduard_Munteanu: thanks for one more idea
18:38:12 <Eduard_Munteanu> That's API stability.
18:38:13 <hpc> mangaba_leitosa: RULES were made to be broken ;)
18:38:36 <Eduard_Munteanu> "experimental" as in "we might change the API"
18:38:46 <Eduard_Munteanu> Not as in "we don't know if it works". :)
18:38:49 <hpc> so why not say that?
18:38:56 <hpc> experimental means you are experimenting
18:39:20 <mangaba_leitosa> Eduard_Munteanu: ah, ok :-)
18:39:30 <hpc> nobody's going to ever say "we won't change the api"
18:39:34 <hpc> for obvious reasons
18:39:37 <Eduard_Munteanu> hpc: or you have been experimenting, but don't want to make promises :)
18:39:56 * hackagebot bifunctors 4.1.1 - Bifunctors  http://hackage.haskell.org/package/bifunctors-4.1.1 (EdwardKmett)
18:40:09 <mangaba_leitosa> Eduard_Munteanu: I can see that it has its own String functions as well
18:40:43 <mangaba_leitosa> Eduard_Munteanu: (not that it could help in my task, because I don't use 'words')
18:40:48 <Eduard_Munteanu> mangaba_leitosa: I'd still use Data.Text for string processing, not that. If you want to use stream-fusion, use its lists, not strings.
18:41:14 <Eduard_Munteanu> mangaba_leitosa: why not use 'words'?
18:41:33 <Eduard_Munteanu> T.words might help fuse away some listy stuff.
18:41:40 <mangaba_leitosa> Eduard_Munteanu: words don't give me all substrings of length 10 of the text file
18:42:02 <mangaba_leitosa> Eduard_Munteanu: actually, my text file is a list of chars with no whitespace
18:42:15 <Eduard_Munteanu> mangaba_leitosa: all substrings, or all substrings of all words?
18:42:37 <mangaba_leitosa> Eduard_Munteanu: all substrings of the entire text file
18:43:12 <mangaba_leitosa> Eduard_Munteanu: words k textfileAsString = [ tail  | tail <- (map (take k) . tails) textfileAsString, length tail >= k ]
18:43:12 <Eduard_Munteanu> Wow, that's a lot, depending on what your files are.
18:43:32 <Eduard_Munteanu> :t subsequences
18:43:32 <lambdabot> [a] -> [[a]]
18:43:47 <mangaba_leitosa> Eduard_Munteanu: but I need fixed length subsequences :-)
18:43:58 <Eduard_Munteanu> mangaba_leitosa: so filter them :)
18:44:19 <Eduard_Munteanu> > filter (\s -> length s == 4) . subsequences $ "this is my file"
18:44:20 <lambdabot>   ["this","thi ","ths ","tis ","his ","thii","thsi","tisi","hisi","th i","ti ...
18:44:54 <mangaba_leitosa> Eduard_Munteanu: but this generates words of length 4 not found in the original string
18:45:00 <Eduard_Munteanu> Library functions are more likely to fuse away.
18:45:09 <mangaba_leitosa> Eduard_Munteanu: there is no '"tisi" in the input
18:45:24 <mangaba_leitosa> Eduard_Munteanu: maybe I was not clear enough :-)
18:45:33 <mm_freak> filtering subsequences by length seems like a terrible idea =)
18:45:33 <Eduard_Munteanu> mangaba_leitosa: well, that is a substring like you asked for...
18:45:46 <mangaba_leitosa> Eduard_Munteanu: I only need subsequences that do exist in the string
18:45:48 <arkeet> Eduard_Munteanu: fusion isn't smart enough for that I'm pretty sure.
18:45:48 <Eduard_Munteanu> mangaba_leitosa: should it be a substring word-wise?
18:45:59 <arkeet> what exactly do we mean by substring?
18:46:15 <arkeet> usually, characters in a substring need not be contiguous.
18:46:24 <mangaba_leitosa> > words k textfileAsString = [ tail  | tail <- (map (take k) . tails) textfileAsString, length tail >= k ]
18:46:25 <lambdabot>   <hint>:1:26: parse error on input `='
18:46:29 <Eduard_Munteanu> > concatMap (filter (\s -> length s == 4) . subsequences) . words $ "this is my file"
18:46:29 <mangaba_leitosa> @let words k textfileAsString = [ tail  | tail <- (map (take k) . tails) textfileAsString, length tail >= k ]
18:46:30 <lambdabot>   ["this","file"]
18:46:31 <lambdabot>  Defined.
18:46:41 <mangaba_leitosa> > words 4 "this is my file"
18:46:42 <lambdabot>   Ambiguous occurrence `words'
18:46:42 <lambdabot>  It could refer to either `L.words', defined a...
18:46:50 <mangaba_leitosa> @let mywords k textfileAsString = [ tail  | tail <- (map (take k) . tails) textfileAsString, length tail >= k ]
18:46:51 <lambdabot>  Defined.
18:46:55 <mangaba_leitosa> > mywords 4 "this is my file"
18:47:02 <lambdabot>   mueval-core: Time limit exceeded
18:47:07 <mangaba_leitosa> oops
18:47:10 <arkeet> @undefine
18:47:10 <lambdabot> Undefined.
18:47:41 <mangaba_leitosa> ghci> mywords 4 "this is my file"
18:47:41 <mangaba_leitosa> ["this","his ","is i","s is"," is ","is m","s my"," my ","my f","y fi"," fil","file"]
18:47:53 <mangaba_leitosa> Eduard_Munteanu: here is what my function generates
18:48:07 <Eduard_Munteanu> arkeet: I was thinking of stream-fusion's implementation, that's a bit more likely to fuse
18:48:10 <mangaba_leitosa> Eduard_Munteanu: it's not what subsequences does, because subsequences are subsets, not substrings :-)
18:48:27 <arkeet> > transpose . take 4 . tails $ "this is my file"
18:48:29 <lambdabot>   ["this","his ","is i","s is"," is ","is m","s my"," my ","my f","y fi"," fi...
18:48:34 <arkeet> > transpose . take 4 . tails $ "abcdefg"
18:48:35 <lambdabot>   ["abcd","bcde","cdef","defg","efg","fg","g"]
18:48:36 <Eduard_Munteanu> Oh, right.
18:48:42 <arkeet> and then chop off the ones at the end.
18:48:47 <arkeet> @where sneaky
18:48:48 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
18:49:05 <mangaba_leitosa> arkeet: thanks, that looks way shorter :-)
18:49:15 <arkeet> or use a different transpose.
18:49:18 <arkeet> @src transpose
18:49:18 <lambdabot> transpose []             = []
18:49:18 <lambdabot> transpose ([]   : xss)   = transpose xss
18:49:18 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
18:49:42 <arkeet> hmm
18:49:44 <Eduard_Munteanu> :t Data.Text.transpose
18:49:45 <lambdabot> [Data.Text.Internal.Text] -> [Data.Text.Internal.Text]
18:49:54 <Eduard_Munteanu> Er.
18:50:01 <arkeet> > Data.Text.transpose (fromString ["abcd","ef"])
18:50:02 <lambdabot>   Not in scope: `Data.Text.transpose'
18:50:02 <lambdabot>  Perhaps you meant `Data.List.transpose...
18:50:04 <Eduard_Munteanu> Oh, it should.
18:50:11 <arkeet> > Text.transpose (fromString ["abcd","ef"])
18:50:12 <lambdabot>   Not in scope: `Text.transpose'
18:50:12 <lambdabot>  Perhaps you meant one of these:
18:50:12 <lambdabot>    `BSLC.tr...
18:50:14 <arkeet> blah
18:50:22 <Eduard_Munteanu> > T.transpose (fromString ["abcd","ef"])
18:50:23 <lambdabot>   Not in scope: `T.transpose'
18:50:23 <lambdabot>  Perhaps you meant one of these:
18:50:23 <lambdabot>    `BS.transpo...
18:50:27 <arkeet> =(
18:50:33 <Eduard_Munteanu> @index Data.Text
18:50:33 <lambdabot> bzzt
18:50:35 <arkeet> @let import qualified Data.Text
18:50:35 <lambdabot>  .L.hs:102:1:
18:50:36 <lambdabot>      Data.Text: Can't be safely imported!
18:50:36 <lambdabot>      The package (tex...
18:50:38 <arkeet> bah
18:50:49 <Eduard_Munteanu> > BS.transpose (fromString ["abcd","ef"])
18:50:50 <lambdabot>   Not in scope: `fromString'
18:50:50 <lambdabot>  Perhaps you meant one of these:
18:50:50 <lambdabot>    `BSLC.fromSt...
18:50:59 <arkeet> @let import Data.String
18:51:01 <lambdabot>  Defined.
18:51:02 <Eduard_Munteanu> > BS.transpose (BS.fromString ["abcd","ef"])
18:51:04 <lambdabot>   Not in scope: `BS.fromString'
18:51:04 <lambdabot>  Perhaps you meant `BSL.fromStrict' (imported...
18:51:08 <Eduard_Munteanu> Argh.
18:51:09 <mangaba_leitosa> arkeet: btw, why 'mywords' does not work with lambdabot?
18:51:24 <arkeet> mangaba_leitosa: lambdabot does weird things sometimes.
18:51:31 <arkeet> try it again.
18:51:38 <arkeet> assuming your code is correct.
18:51:46 <mangaba_leitosa> @let mywords k textfileAsString = [ tail  | tail <- (map (take k) . tails) textfileAsString, length tail >= k ]
18:51:47 <lambdabot>  Defined.
18:51:54 <mangaba_leitosa> > mywords 4 "this is my file"
18:51:58 <Eduard_Munteanu> > BS.transpose (map BS.pack ["abcd","ef"])
18:52:00 <lambdabot>   Couldn't match type `GHC.Types.Char' with `GHC.Word.Word8'
18:52:00 <lambdabot>  Expected type: ...
18:52:02 <lambdabot>   mueval-core: Time limit exceeded
18:52:08 <mangaba_leitosa> arkeet: works in ghci
18:52:11 <Eduard_Munteanu> > BSC.transpose (map BSC.pack ["abcd","ef"])
18:52:13 <lambdabot>   ["ae","bf","c","d"]
18:52:18 <arkeet> :t mywords
18:52:18 <Eduard_Munteanu> Finally.
18:52:21 <lambdabot> Int -> [a] -> [[a]]
18:52:31 <arkeet> > mywords 4 "this is my file"
18:52:36 <lambdabot>   ["this","his ","is i","s is"," is ","is m","s my"," my ","my f","y fi"," fi...
18:52:40 <mangaba_leitosa> Eduard_Munteanu: what are BS and BSC?
18:52:40 <arkeet> yep, lambdabot being weird.
18:52:53 <Eduard_Munteanu> mangaba_leitosa: Data.Bytestring.Char8
18:52:58 <mangaba_leitosa> > mywords 4 "this is my file"
18:53:00 <geekosaur> bytestring[lazy][char8]
18:53:03 <lambdabot>   ["this","his ","is i","s is"," is ","is m","s my"," my ","my f","y fi"," fi...
18:53:19 <structuralist> does GHC secretly treat IO a as something like World -> (a, World)?
18:53:37 <arkeet> structuralist: almost.
18:53:41 <geekosaur> depends on what you think World is
18:53:47 <tiffany> I asked mike to check it out and he's apparently going to come see
18:53:51 <tiffany> on twitter, that is
18:53:54 <structuralist> why doesn't it treat it as a free monad?
18:53:58 <tiffany> er, sorry, wrong channel
18:53:59 <mangaba_leitosa> Eduard_Munteanu: ah, will it be more efficient for 8-bit text?
18:54:02 <structuralist> with PutStrLn as a constructor for example
18:54:15 <arkeet> structuralist: that would be inextensible and also inefficient.
18:54:53 <Eduard_Munteanu> mangaba_leitosa: more efficient than String, perhaps
18:54:58 * hackagebot zasni-gerna 0.0.3 - lojban parser (zasni gerna)  http://hackage.haskell.org/package/zasni-gerna-0.0.3 (YoshikuniJujo)
18:55:26 <mangaba_leitosa> Eduard_Munteanu: maybe I just need to read a list of bytes instead of String or Text?
18:55:33 <Eduard_Munteanu> structuralist: GHC's RealWorld isn't really a state parameter, it's more like a phantom type
18:55:55 <augur_> geekosaur: what is #RealWorld in the internals of IO?
18:56:10 <augur_> Eduard_Munteanu: ^
18:56:20 <geekosaur> a baton. it doesn't even exist at runtime
18:56:28 <augur_> my hunch is that it's memory addresses for memory mapped IO junk
18:56:31 <geekosaur> it forces IO to be done in sequence
18:56:37 <augur_> geekosaur: a baton?
18:56:57 <Eduard_Munteanu> mangaba_leitosa: I'd try Text first, it should be reasonable
18:57:10 <geekosaur> when generating code, after the typechecker has used it to sequence I/O actions, ghc realizes nothing actually uses RealWorld#, and code doesn't get generated for it
18:57:28 <augur_> geekosaur: i dont follow
18:57:35 <structuralist> I guess in order to do anything with a free monad for IO it would have to transform it into World -> (a, World) anyway
18:57:45 <augur_> structuralist: no, you wouldnt
18:57:58 <structuralist> no?
18:58:00 <augur_> i wrote a tutorial on implementing haskell-style IO in JS. havent posted it anywhere but
18:58:02 <geekosaur> "something" injects a RealWorld# into main; I/O actions take it and return it. nothing ever looks at it or modifies it
18:58:30 <augur_> if you do it with the free-monad (or free-enough monad), it pretty straight forward
18:58:37 <geekosaur> (exception being unsafePerformIO, but that ends up being the same thing starting somewhere other than main --- nothing ever looks at it, just passes it around)
18:58:54 * structuralist blissfully ignore the existence of unsafePerformIO
18:58:59 <Eduard_Munteanu> augur_: IO calls to the RTS, but if RealWorld weren't there, the compiler would think it's fine to reorder things. It can't see the true data dependencies.
18:59:09 <augur_> geekosaur: but how does an actual IO action get implemented
18:59:15 <conal> mm_freak: continuing, what model (with typo fixed) for "Behavior"? and what meaning for "changes". as i said, if you spell it out, i think you'll find the problem.
18:59:18 <arkeet> suggested reading:
18:59:19 <arkeet> http://www.haskell.org/haskellwiki/IO_inside
18:59:21 <arkeet> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
18:59:21 <geekosaur> that passing around is enough that evaluation happens in the right order, but since nothing actually is done with it, after that ordeirng is established it goes away as dead unused code
18:59:59 <structuralist> will take a look, thanks
19:00:16 <geekosaur> yes, read that IO Inside page
19:00:17 <conal> mm_freak: oh. i found your explanation.
19:00:38 <conal> mm_freak: i doubt that's what the author had in mind for changes.
19:01:07 <geekosaur> ultimately actual IO things become FFI calls to OS services
19:01:11 <conal> mm_freak: i think he meant corresponding to events that trigger value changes to the behavior.
19:01:34 <geekosaur> (ghc does not try to actually make OS syscalls, it FFIs to libc stuff like read())
19:03:08 <Eduard_Munteanu> And the normal data dependencies aren't there because IO calls are opaque. GHC could sequence a chain of actions by their result, but IO actions have side-effects too, so putStrLn :: IO () would escape that analysis.
19:03:24 <augur_> geekosaur: rough expansion on that?
19:03:28 <Eduard_Munteanu> Er, putStrLn something.
19:03:31 <geekosaur> um?
19:03:40 <geekosaur> what kind of expansion? do you want to know how the FFI works now?
19:03:55 <augur_> geekosaur: i want to know how an IO action translates into an FFI call
19:04:14 <geekosaur> then at some point I have to point you to the GHC source
19:04:22 <augur_> rough.
19:04:24 <conal> mm_freak: ..., which is an abstraction leak.
19:04:41 <geekosaur> it's not a compiler builtin though, there is for example a library which handles matters of encoding, buffering, and such
19:04:53 <geekosaur> think of it as C's stdio but written in and for Haskell
19:05:19 <Eduard_Munteanu> I think GHC.Prim stuff and the likes get referred to by name, and the compiler translates them to calls.
19:06:20 <Eduard_Munteanu> (possibly the reason for the MagicHash?)
19:06:52 <geekosaur> (some of this can be quite simple, but generally the standard library provides a bunch of friendlier and relatively system independent wrappers for calls which may be quite different between (say) Windows and Linux)
19:07:55 <Eduard_Munteanu> In fact, I remember seeing them as    somePrimOp :: ...; somePrimOp = undefined
19:08:10 <geekosaur> yes, but I/O isn't done via primops
19:08:18 <Eduard_Munteanu> Ah.
19:08:57 <geekosaur> primops implement things like Word# and Int#, making them available to be wrapped into Haskell types
19:09:01 <geekosaur> @src Int
19:09:01 <lambdabot> data Int = I# Int#
19:09:21 <geekosaur> Int# there is implemented via primops
19:09:26 <Eduard_Munteanu> geekosaur: so it's just ordinary FFI calls for IO? Or do they use a different mechanism?
19:09:32 <geekosaur> ordinary FFI calls
19:09:53 <Eduard_Munteanu> Hm, cool.
19:10:03 <geekosaur> of course the FFI mechanism uses primops to the extent that the types expected by foreign functions are primitive types
19:11:29 <geekosaur> but, since the stuff in IO is about communicating with the system, ultimately it has to involve system calls --- and rather than try to keep track of how e.g. Linux changes kernel interfaces when glibc already does so, ghc just FFIs to the glibc functions
19:12:40 <geekosaur> if ghc were to try to make system calls directly, *that* would have to be a primop. but it'd also be nightmarish to maintain; linux kernel interfaces change all the time.
19:13:09 <geekosaur> (heck, even *how* you make syscalls has changed over time)
19:13:42 <geekosaur> int, lcall, sysenter, ...
19:13:50 <geekosaur> (CPU instructions on x86oids)
19:14:06 <Eduard_Munteanu> geekosaur: the syscalls are sort of stable, but glibc also tries to take advantage of the "good" ones too, AFAIK.
19:14:27 <Eduard_Munteanu> e.g. it can splice data instead of writing to a pipe.
19:14:27 <geekosaur> "sort of". I think stat() is still quite the mess...
19:15:17 <geekosaur> but in any case it's far better to defer all that stuff to glibc's stable interfaces and not worry about what goes on beyond that
19:16:00 <Eduard_Munteanu> geekosaur: yeah... though I suppose that's just for IO purposes, since stuff like memcpy() are best left to a compiler even in C.
19:16:10 <geekosaur> yes
19:16:33 <Eduard_Munteanu> Well, especially in C where you can't inline foreign functions. :)
19:17:00 <geekosaur> although even there it would be possible to push memcpy() to LLVM (I don't know if the LLVM backend takes advantage of this though)
19:18:15 <Eduard_Munteanu> IIRC gcc doesn't do it extensively by default either, unless -minline-all-stringops or whatsitsname.
19:18:57 <Eduard_Munteanu> (which is a bit weird considering it's rather short)
20:07:58 <countoren> hello, someone knows why the realworld haskell site is down?
20:09:50 <countoren> ?
20:10:02 <khyperia> Can someone explain math syntax to me? Trying to understand the wiki article on http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system so, does http://upload.wikimedia.org/math/5/b/5/5b53640a9a3539396d5b25da475a9e80.png mean "if x is alpha, then \y.x is forall beta. beta -> alpha"?
20:10:17 <khyperia> where "is" means "is of type"
20:10:18 <sclv> countoren: good question!
20:12:09 <sclv> none of the people who would be responsible for the website seem to be hanging out on irc
20:12:17 <countoren> got attacked? :)
20:12:26 <sclv> nah probably just fell down
20:12:40 <sclv> its run by the authors + maybe the publisher?
20:12:50 <sclv> not part of our common infrastructure
20:13:16 <sclv> of the three authors, jgoerzen is the least busy at the moment afaik and the most likely to respond if you email directly
20:13:30 <sclv> but you may want to send a polite note to any/all of them to let them know
20:13:49 <countoren> u have there email?
20:14:23 <sclv> actually forget it i'll tweet @ all 3 of them :-)
20:14:34 <countoren> cool
20:14:35 <sclv> but i wouldn't necessarily expect results anytime immediately
20:14:59 <countoren> well i guess i can wait
21:13:55 <Cirdec> How can I write the type of a function that requires an instance of a typeclass for all types that are instances of another typeclass. For example, I'd like to write something like: forall f a. (Functor f, (forall b. Eq b => Eq f b)) => (a -> a -> Bool) -> f a -> f a -> Bool
21:14:56 <Cirdec> But if I do that, the compile thinks it's a function with four arguments
21:16:11 <simpson> Cirdec: Hm. What are you building?
21:18:16 <Cirdec> I'm trying to rip the dictionary for Eq out of structures like [] to write equalBy. I can use reflection to construct a dictionary for Eq b that contains the function (a -> a -> Bool), but I can't get []'s Eq without exposing how the b's will be constructed.
21:23:20 <carter> Cirdec: couldn't you just do  byEq :: Eq a => proxy a -> (a-> a -> Bool)
21:23:23 <carter> or something
21:23:23 <carter> ?
21:23:49 <carter> ohhh
21:23:57 <carter> you want eq lifted to the functor
21:24:23 <carter> Cirdec: you could easily get it ot work if you require the Funtor is also foldable
21:25:17 <dmj`> > $([| \x -> 1 |]) 4
21:25:18 <lambdabot>   <hint>:1:1: parse error on input `$'
21:26:01 <carter> *functor
21:27:49 <dmj`> > runQ [| 1 + 1 |]
21:27:50 <lambdabot>   <hint>:1:7: parse error on input `|'
21:28:27 <Cirdec> I'd really rather not have the Functor either, but it's the smallest thing that can introduce the bs. It seems like type classes should have been built out of dictionaries and Rank2Types, with the type class added just to get type inference most of the time.
21:30:26 <Cirdec> So, the question could also probably be, what is the typeclass equivalent of Rank2Types/RankNTypes?
21:31:06 <edwardk> typeclasses are effectively already using rank-2
21:31:44 <edwardk> thats kind of how folks figured out rank-2 types were interesting in haskell, since they had to write something like them to desugar dictionaries anyways
21:35:32 <Cirdec> Ok, say we wrote something like 'newtype EqI a = a -> a -> Bool', and then defined 'list'Eq :: forall b. EqI b -> EqI [b]'
21:37:47 <carter> ok
21:38:31 <Cirdec> And then we realized we'd like to talk about things like this more generally, and wrote `type Eq1I f = forall b. -> EqI b -> EqI (f b)
21:39:22 <Cirdec> Now we can talk about they type of thing that we can make an instance for for any type, provided we have an instance for somethign of that type.
21:40:26 <Cirdec> Following the example so far, we could write that `list'Eq :: Eq1I []`
21:41:05 <lpaste> enthropy pasted “Cirdec” at http://lpaste.net/95496
21:41:14 <enthropy> I was going to suggest something like that
21:42:02 <enthropy> and the implicit param can be done with reflection instead I think
21:43:10 <carter> Cirdec: are there any examples where that f wont be a functor and foldable? :)
22:04:41 <bergmark> in general, how is something like `NewTypeConst `op` foo' reduced?
22:05:04 <dmwit> By substituting in the definition of op, I guess.
22:05:54 <bergmark> i'm trying to think of some contrived example for this :)
22:06:25 <bergmark> `NewTypeConst $ foo' just translates to `foo'
22:21:07 <dmj`> why is the max tuple size 62
22:21:34 <moops> you cant have a tuple of size 63
22:21:37 <moops> thatd be absurd
22:22:15 <dmj`> good point
22:29:05 <flebron> Great error message if I ask GHCi to show me (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1).
22:30:06 <moops> haha
22:30:19 <Kneiva> d_O
22:31:23 <joeyh_> makes me wonder what's the longest error message it's possible to get ghc to emit for say, 256 chars of code
22:35:06 <Kneiva> this is also interesting: show ((1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1) :: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, ...
22:35:12 <Kneiva> ... Int, Int))
22:36:44 <dmwit> joeyh_: Try let f = join (,) in tail . f . f . f $ 1. Add f a few times.
22:36:53 <dmwit> See if you can spot the pattern, then compute how big the error would be for 256 chars.
22:38:36 <pavonia> it's always the same error message for me
22:38:48 <dmwit> Well.
22:38:55 <dmwit> Import Control.Monad or whatever. =)
22:38:59 * joeyh_ is pretty sure the error message for 256 chars is "out of memory" :)
22:39:06 <dmwit> yeah =)
22:39:38 <pavonia> dmwit: no difference
22:39:44 <dmwit> pavonia: hm?
22:39:45 <joeyh_> clearly ghc needs lazy error message display
22:39:47 <dmwit> pavonia: What error do you get?
22:39:58 <dmwit> pavonia: When I try, I get wildly long messages after adding only a few 'f's.
22:40:08 <pavonia> "Occurs check: cannot construct the infinite type: a = (a, a)" + 4 extra lines
22:40:20 <enthropy> might be no Monad ((->) r) instance in scope
22:40:39 <dmwit> pavonia: It is important that you use let in exactly the way I said.
22:40:43 <pavonia> Ah, that's it :)
22:42:45 <dmwit> According to my calculations, you would get an error message length of around 10^35 if you filled your 256 characters with that nonsense. =)
22:49:06 <dmj`> show instances stop at tuple length 15
23:33:47 <seancpp> Hi there folks
23:34:31 <seancpp> I'm absolutely new to GNU/Linux, running Crunchbang...and i can't figure out for the life of me how to install the Haskell platform
23:34:38 <seancpp> was hoping to get some help! Haha
23:36:24 <mzero> uhm... that distro looks to be debian derived - so you should be able to use the packages for Ubuntu
23:36:49 <mzero> or at least those for Debian
23:36:54 <mzero> see http://www.haskell.org/platform/linux.html for locations
23:37:21 <mzero> but - that assumes you know how to install packages
23:37:34 <mzero> or that Crunchbang comes with some sort of nice UI package installer
23:39:23 <cbw> I wrote a function which given a list of numbers returns a number of that type but thats not in the list
23:39:49 <cbw> newState' :: (Ord q, Bounded q, Enum q) => [q] -> q
23:39:51 <cbw> newState' qs = head $ filter (\x -> notElem x qs) [minBound .. maxBound]
23:40:08 <cbw> newState' "ABC" -- works
23:40:19 <cbw> newState' [1,2,3] -- does not work
23:40:35 <cbw> Is there a better way to do what I am trying
23:43:37 <amalloy> cbw: you haven't told ghci what type of integer you're looking for. 1, 2, and 3 could be Int, Integer, or anything like that
23:43:39 <mr-> newState' [1,2,3 :: Int] -- works
23:43:48 <amalloy> newState' [1,2,3] :: Int is one example
23:44:59 <cbw> I did not know I could do that thanks
23:56:08 <cbw> forget what I just did. My new solution is better
23:56:11 <cbw> newState :: Enum q => Set q -> q
23:56:13 <cbw> newState qs = succ $ Set.findMax qs
23:57:52 <shiona_> http://lpaste.net/95497
23:59:05 <alexander__b> .
23:59:08 <alexander__b> ups
23:59:56 <external-reality> I'm stumped a Coursera problem
