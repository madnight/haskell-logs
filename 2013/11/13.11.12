00:22:11 <Taneb> How fast is (==) on Text?
00:23:10 <tdammers> Taneb: faster than (==) on String, I'd expect, but still O(n)
00:23:22 <BoR0> O(n) where n = min (length str1) (length str2) ?
00:23:53 <tdammers> yep
00:24:18 <Taneb> Actually, this probably isn't going to be an issue for me
00:24:46 <tdammers> and if the compiler transparently converts the linked-list String into an array behind the scenes, there might not be any difference at all
00:25:06 <tdammers> don't know if and when it does that though
00:27:50 <Feuerbach> tdammers: it doesn't
00:28:26 <tdammers> it could, sometimes, theoretically, and I have never checked, is all
00:29:32 <identity> when you guys are writing code, do you use cabal to build and run your stuff, or do you manually compile etc?
00:29:45 <identity> I'm thinking it might just be easier to create a few 'targets' and use cabal run to do it
00:29:48 <Taneb> cabal build generally
00:29:51 <identity> using manual compilation is annoying
00:30:00 <identity> i see
00:30:35 <Taneb> Or ghci
00:34:10 <earthy> I tend to start out with ghci
00:34:21 <earthy> and then add a cabal file once I outgrow a single file
00:34:24 <identity> yeah
00:34:30 <identity> I use ghci for the most part as well, of course
00:34:36 <identity> that's simply natural
00:34:41 <earthy> it's not as though cabal is extremely difficult ;)
00:35:27 <identity> but when I'm writing code that doesn't take a trivial amount of time to run, and I need to compile with optimiziations for example, manually specifying flags etc is annoying
00:36:05 <identity> guess it's time to get more familiar with cabal
00:38:22 <nicoo> identity: It is a great build system. However, cabal-install is an awful package manager.
00:38:27 <identity> yeah
00:38:39 <identity> I've been to cabal hell and back
00:41:15 <hamid> :t (<|>)
00:41:16 <lambdabot> Alternative f => f a -> f a -> f a
00:44:54 <identity> why is the cabal user's guide talking about a cabal run command that doesn't seem to exist?
00:45:40 <identity> oh, why the fuck do I have 1.16? duh
00:45:42 <identity> never mind me
00:48:22 <identity> dafuq
00:49:45 <jle`> don't really use cabal-install anymore, i always sandbox
00:49:52 <jle`> and specify versions explicitly in my cabal file
00:50:32 <identity> i was using /usr/local/bin/cabal for some bizarre reason
00:50:34 <identity> I have no idea why
00:51:02 <identity> and I don't quite get the whole sandbox deal
00:53:24 <jle`> don't get the motivation, or the procedure?
00:54:00 <identity> I understand the motivation is to avoid cabal hell, but don't quite get the procedure.
00:54:24 <identity> It sounded like a sandbox downloads, builds and installs packages in a sandbox local to each cabal package, so to speak, which seems strange to me
00:54:25 <jle`> i haven't touched the 1.18 sandboxing, but i have been doing fine with cabal-dev (and plus you get sandboxed ghci)
00:54:31 <identity> sounds like a lot of duplication etc
00:54:34 <identity> i see
00:55:05 <Taneb> When are derived functors a bad idea?
00:55:10 <jle`> basically, just cabal-dev install instead of cabal install
00:55:19 <jle`> and yeah, there is duplication
00:55:31 <jle`> but you aren't necessarily going to have the same versions of your packages for all your projects anyway
00:55:58 <jle`> space is cheap, and the time overhead is only one-time
00:56:27 <jle`> you get the luxury if basically a fresh cabal/package environment for every project, with none interfering with the other
00:57:11 <jle`> when you think about it actually there is little reason why you would constrain every package/project on your computer to the same set of dependencies
01:04:16 <identity> jle`: Yeah, I guess you're right wrt the last point
01:04:36 <identity> But are cabal developers going to allow multiple versions of the same package at some point?
01:11:03 <skypers_> hi
01:13:24 <skypers_> hey
01:13:34 <skypers_> Foldable is a generization of Traversable?
01:15:23 <jle`> hm. some data might hide constructors, so in that case, traversable would be the only way to maintain structure
01:16:17 <jle`> identity: i guess that's another way to answer that question :P
01:16:48 <jle`> i can see the desire but honesly i do not have any problem with just freshly installing the build dependencies every time i want to build something
01:29:28 <teneen> What's the difference between --enable-shared and --enable-executable-dynamic in cabal install?
01:41:07 <rootnode> yikes... this article is beyond stupid https://yinwang0.wordpress.com/2013/11/09/oop-fp/
01:58:12 <wirrbel> I am still struggling with Haskell types. I do understand the basic concept I think, data, instances, classes, but modelling something is still a challenge
01:58:15 <Cale> rootnode: lol
01:58:29 <Cale> wirrbel: Anything I can help with?
01:58:40 <wirrbel> lets say I am doing some geometry
01:58:45 <wirrbel> I do have classes for Points
01:58:55 <wirrbel> Pt2, Pt3 explicitly since I am cartesian
01:59:03 <Cale> data types, probably
01:59:07 <wirrbel> yes
01:59:08 <Cale> Maybe parametric ones
01:59:27 <Cale> (parameterised over the underlying numeric type)
01:59:28 <wirrbel> data Pt2 = Pt2 Double Double deriving (Eq, Show)
01:59:35 <wirrbel> numeric type can be fixed to double
01:59:35 <maicsmarties> http://www.LittleStacy.com?id=99194
01:59:38 <wirrbel> that is not the issue
01:59:41 <rootnode> Cale: I mean....I'm not the best with monads yet, but that article is just...
01:59:42 --- mode: ChanServ set +o Cale
01:59:46 <wirrbel> now I introduced two other types
01:59:51 --- mode: Cale set -o Cale
01:59:55 <wirrbel> Box2 and Box3
02:00:02 <wirrbel> data Box2 = Box2 Pt2 Pt2
02:00:04 <Cale> okay
02:00:23 <wirrbel> now intuitively I would assume that somehow I can write a Pt and a Box class
02:00:36 <pharaun> man its really hard to only select the first or the last item in an arrow stream :\
02:00:54 <wirrbel> and somehow abstract away the dimensionality of these objects
02:01:21 <wirrbel> something like calcBounds :: (Pt p, Box b) p -> b
02:01:31 <wirrbel> ah, => missing
02:01:44 <chrisdone> rootnode: http://this-plt-life.tumblr.com/post/36425247728/when-i-listen-to-someone-who-knows-less-about-pls-than
02:01:49 <Cale> Well, you might have a VectorSpace class
02:02:54 <Cale> class VectorSpace v where type Scalar v; (^+^) :: v -> v -> v; (*^) :: Scalar v -> v -> v; zeroV :: v; ... maybe some other things ...
02:03:46 <Cale> If you want to abstract over the various types of points, the question you have to answer is which operations are important and common to each of them.
02:04:13 <rootnode> haha, nice page
02:04:18 <rootnode> this made me really laugh http://this-plt-life.tumblr.com/post/44462204757/simon-peyton-jones-adding-the-io-monad-to-haskell
02:04:32 <Cale> For boxes, you might still only need 2 points to determine an axis-aligned cuboid
02:04:49 <Cale> So you could abstract that over the type of points just by making it a parametric type
02:06:12 <wirrbel> Cale, oh yea, you are right
02:07:07 <wirrbel> slightly embarassing ;) sometimes one should take a step back when thinking about a problem
02:07:13 <arkeet> or a vector of intervals ;)
02:12:04 <chrisdone> rootnode: yeah i love that one
02:12:14 <Cale> rootnode: Lisp-centric PLT folks sometimes have some really funny opinions. (I'm not really referring to that one specifically, but the sense that I get of this guy's take on things from the rest of the posts is a bit funny in places.)
02:14:31 <albertid> rootnode, haha :D
02:16:03 <chrisdone> Cale: the posts are submitted by different people, hence the contradictions across posts
02:16:49 <Cale> ah
02:17:07 <chrisdone> Cale: but yeah, it often seems like for lispers the peak of programming potential was hit in 1986 and everything after is just a macro
02:17:11 <Cale> That's why it seems a bit schizophrenic
02:17:15 <Cale> But yes
02:18:27 <mauke> > undefined :: Void
02:18:30 <lambdabot>   V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (V (...
02:19:05 <arkeet> newtype Void = V Void?
02:19:45 <wirrbel> chrisdone, after doing a some Scheme/Clojure for a while, it is really hard to get into other PLs again
02:19:57 <wirrbel> like haskell, it has syntax
02:20:28 <wirrbel> so cumbersome, so much to remember ;)
02:20:44 <nicoo> wirrbel: Scheme/Closure has optional syntax, called convention :þ
02:20:52 <quchen> arkeet: I think it's data Void = Voind !Void
02:21:11 <mauke> quchen: I think that would break the Show instance
02:21:13 <arkeet> quchen: then undefined :: Void wouldn't match that.
02:21:27 <quchen> Ah, it was change for GHC 7.0.
02:21:30 <arkeet> @newtype XX = XX XX
02:21:31 <lambdabot> Unknown command, try @list
02:21:33 <arkeet> @let newtype XX = XX XX
02:21:39 <lambdabot>  Defined.
02:21:39 <Cale> Scheme also has actual syntax
02:21:40 <arkeet> @let data YY = YY !YY
02:21:41 <lambdabot>  Defined.
02:21:41 <quchen> Now it's "newtype Void = Void Void" indeed.
02:21:43 <arkeet> oops.
02:21:49 <arkeet> @let newtype XXX = XXX XXX deriving Show
02:21:50 <lambdabot>  Defined.
02:21:50 <Cale> It's just that it all looks similar
02:21:54 <arkeet> @let data YYY = YYY YYY deriving Show
02:21:55 <lambdabot>  Defined.
02:21:57 <arkeet> > undefined :: XXX
02:22:04 <lambdabot>   mueval-core: Time limit exceeded
02:22:06 <mauke> @let data ZZZ = ZZZ !ZZZ deriving Show
02:22:08 <lambdabot>  Defined.
02:22:12 <mauke> > undefined :: XXX
02:22:14 <arkeet> oh I forgot the !
02:22:17 <lambdabot>   XXX (XXX (XXX (XXX (XXX (XXX (XXX (XXX (XXX (XXX (XXX (XXX (XXX (XXX (XXX (...
02:22:17 <arkeet> =(
02:22:17 <wirrbel> the truth: grumpy me is just annoyed that I have to think about indenting again ;)
02:22:20 <mauke> > undefined :: ZZZ
02:22:23 <lambdabot>   *Exception: Prelude.undefined
02:22:24 <arkeet> yes see.
02:22:30 <arkeet> newtype constructors always match.
02:22:46 <arkeet> > ZZZ undefined
02:22:49 <lambdabot>   *Exception: Prelude.undefined
02:22:50 <arkeet> > YYY undefined
02:22:52 <lambdabot>   YYY *Exception: Prelude.undefined
02:22:59 <tdammers> scheme has very little syntax, but this only means that you have to remember a lot of functions instead
02:23:03 <mauke> > undefined == V (V undefined)
02:23:10 <lambdabot>   mueval-core: Time limit exceeded
02:23:17 <Cale> tdammers: Well, it has *extensible* syntax, because that's what macros are
02:23:30 <chrisdone> Cale: the whole "X's pet feature is just a one liner macro" is revealing, it speaks (at least to me) volumes. the lisp attitude is a self-centered one. a macro extends the syntax of the language, but only for the user. people rarely agree on how a macro should work, or whether it's necessary, and hence lispers end up building motes around themselves of their own stuff. what good is extending your language if it only works for you? if
02:23:30 <chrisdone> you're self-centered, that's lots of good. if you care about sharing code, then you have exactly what the common lisp community has now, 30 years worth of history and not a sausage for libraries and no updates to the standard
02:23:34 <tdammers> right
02:23:52 <tdammers> although I suspect that what lisp people call "syntax" is actually a step up
02:24:03 <arkeet> @let instance Show VV where show _ = ""
02:24:03 <lambdabot>  .L.hs:156:15: Not in scope: type constructor or class `VV'
02:24:08 <arkeet> @let instance Show XX where show _ = ""
02:24:09 <lambdabot>  Defined.
02:24:17 <arkeet> > replicate 20 (undefined :: XX)
02:24:20 <lambdabot>   [,,,,,,,,,,,,,,,,,,,]
02:25:16 <chrisdone> Cale: whereas in a language like haskell without the free-form DIY, there has to be general concensus.  people have something to expect. everyone using haskell agrees, more or less,  that the features are okay for them to use. so in a sense, just like the type system, there is freedom in carefuly crrafted restrictions. that's the way i see it, anyway…
02:25:23 <wirrbel> chrisdone, there is some truth to what you say. However I would say that some of this can be attributed to the CL community that is centered around commercial lisp systems.
02:25:39 <spion> uhh, I disagree. the best way to improve code sharing is to make it easier to share code
02:25:42 <wirrbel> clojure for example has a great community spirit with libraries and code sharing
02:26:13 <spion> (e.g. make it possible for two libraries to use mutually incompatible versions of a third library)
02:26:25 <tdammers> static type checking is just as much restricting as it is liberating, IMO
02:26:57 <Cale> I think it's more liberating than restricting.
02:27:19 <tdammers> they are not just "carefully crafted restrictions", they also add information to your code that both the programmer and the compiler can actively use for better results
02:27:38 <chrisdone> tdammers: that's part of the point
02:27:50 <chrisdone> you have all that information because you have guarantees based on the idea of restricting
02:27:53 <tdammers> yes, but they are not primarily restrictions
02:28:22 <tdammers> you have a more expressive language, and the things you can express are enforced by the compiler
02:28:35 <Cale> Type classes make it hard to see types as simply being about restricting the behaviour of the program.
02:28:45 <Cale> Because they also determine the behaviour of the program
02:28:50 <tdammers> indeed
02:29:24 <tdammers> typeclass instances are much more about "given an X, here's how you do Y", rather than "given an X, you cannot do Y"
02:31:22 <chrisdone> i don't think i was saying anything to the contrary
02:31:52 <mauke> I get the impression some lispers see static types as walls that stand in their way to be walked around
02:32:18 <mauke> but experienced haskellers hang stuff on walls or even do wall jumps :-)
02:32:31 <tdammers> that's what static types feel like when you first battle them, yes
02:32:32 <chrisdone> (i was saying you get those nice things *because* you have guarantees (based on restricting what can be expressed), you can rely on the proofs that come from it)
02:32:57 <tdammers> but it's more than accepting restrictions so you can have nice things
02:33:04 <chrisdone> that's what i said.
02:33:41 <chrisdone> "part of the point" != "the whole point"
02:33:56 <tdammers> point taken
02:35:29 <pharaun> i like static types because it usually let me focus on the code in small segment, i know the type coming in, i know the types going out
02:35:44 <pharaun> instead of having to look at the code in *all* of its execution context
02:37:10 <wirrbel> what I do like about static typing/ Haskell is, that the function size is greatly reduced
02:37:39 <wirrbel> and from my experience, the shorter a function is, the more reliable the code is
02:38:49 <chrisdone> heh, i wonder if someone's made a rating function that takes in a haskell function, compiles it to core and calculates a complexity score based on how many cases and recursions happen =p
02:39:44 <Tinned_Tuna> chrisdone: complexity? as in cyclomatic complexity?
02:40:02 <chrisdone> Tinned_Tuna: right
02:40:20 <Tinned_Tuna> Hm, I'm not sure that CC is as applicable to functional programs as to imperative ones
02:40:29 <quchen> chrisdone: You mean a profiler?
02:40:31 <Tinned_Tuna> We tend to have no loops, just map, fold, etc.
02:40:38 <tdammers> the only meaningful measure for code complexity is wtf-per-minute
02:40:50 <chrisdone> Tinned_Tuna: sure, but we have recursion
02:41:10 <Tinned_Tuna> chrisdone: but it is often discouraged in favour of higher-order functions
02:41:15 <quchen> > let loop = 1 : loop in loop -- Loops!
02:41:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:41:23 <chrisdone> Tinned_Tuna: nod. which compile down to recursion in core
02:41:39 <tdammers> CC is about decision points IIRC
02:41:54 <tdammers> whether those are implemented as loops or recursion doesn't really change anything
02:41:55 <Chousuke> tdammers: another measure is how many hops from one function/file/module to another you need to do before you can finish a mental simulation of what's happening.
02:42:01 <chrisdone> tdammers: nod, hence 'cases and recurions'
02:42:16 <Tinned_Tuna> chrisdone: But the measure is primarily to find readability of the code
02:42:48 <Tinned_Tuna> why would it matter if, under the hood, it was converting it to 50,000 cases statements, and 100,000 potential entry points for other recursion?
02:42:50 <chrisdone> Tinned_Tuna: hm, that seems another measure
02:42:55 <Tinned_Tuna> that's not the bit of the code that you're reading :-)
02:42:57 <tdammers> Tinned_Tuna: not really. It's about maintainability, usually - higher CC means mental execution becomes more difficult, and as a result, it is more difficult to reason about the code
02:43:04 <chrisdone> if it's doing that much under the hood, it probably does a lot?/
02:43:30 <tdammers> I can easily write highly unreadable code with a very low CC
02:43:53 <Tinned_Tuna> tdammers: sorry, I was simplifying, since mental overhead, readability and reasoning about code are all often linked together
02:44:05 <chrisdone> Tinned_Tuna: but yeah, you could use HSE and make a similar readability score over the AST
02:44:52 <chrisdone> Tinned_Tuna: but somehow i think id f and foldr f are quite different in mental overhead to understand, that should be taken into account, which a purely syntactic analysis on the non-desugared AST would miss
02:45:55 <tdammers> worse yet, mental overhead depends on a lot of outside factors, too
02:46:27 <Tinned_Tuna> chrisdone: I think the conclusion you could be arriving at is that CC is not a great measure for Haskell, and that we may need a different way of looking at things ;-)
02:46:35 <chrisdone> Tinned_Tuna: maybe it could do both. look at the AST, but also take into account what each token compiles to
02:46:36 <tdammers> e.g., code that closely follows the real-world thing it models is easier to understand than code that doesn't, even if it has the same complexity by all measurable means
02:47:13 <Tinned_Tuna> Possibly: http://stackoverflow.com/questions/3431225/tools-for-generating-haskell-function-dependency-control-flow-graph ?
02:47:28 <tdammers> I suspect that this is one of the reasons why Haskell is great for writing parsers, but GUIs are somewhat challenging
02:47:33 <chrisdone> Tinned_Tuna: so then id f and foldr f are structurally similar, with foldr having more known complexity, but you could have some common vocabulary that makes using foldr not as bad as e.g. implementing the recursion manually
02:47:56 <chrisdone> tdammers: GUIs aren't challenging specifically in haskell. they're just challenging, imo
02:48:17 <mm_freak> they're less challenging in haskell
02:50:26 <identity> I'm using criterion for benchmarking using cabal -- how do I pass command-line options to my benchmarking executable via cabal?
02:56:42 <BoR0> is there any easy tutorial for implementing DSL? for instance, I saw that in happstack they have let x = <b><% str %></b> (note this is not a string). how do they do this?
02:56:50 <alexander__b> http://lpaste.net/4881388936456306688 I need a way to set the t (placeholder version on line 22) to getCurrentTime in buttonSwitch, or otherwise onClicked button1. ideas?
02:56:54 <BoR0> I'm interested in basic stuff at first
02:57:11 <wirrbel> with haskell typeclasses, I often read in the docs: "Minimal complete definition "
02:57:18 <alexander__b> so t = if [the user clicks start] then getCurrentTime else t
02:57:41 <alexander__b> then I need to use that t in hh/mm/ss.
02:57:50 <wirrbel> does this mean that other functions of the typeclass may not be available? Will calling those raise an error?
02:59:14 <tdammers> BoR0: that one is actually a bit of magic... it's not plain Haskell, but somewhat preprocessed
02:59:21 <tdammers> can't remember the details
02:59:43 <BoR0> aha, that makes sense. so Haskell has a macro preprocessing system like C does?
03:00:02 <tdammers> well, it can use actual CPP, but that's a bit of a hack
03:00:15 <tdammers> there's also quasi-quotes, which would look something like:
03:00:38 <tdammers> let template = [foobar|<div><p>{whatever}</p></div>|]
03:01:37 <klugez> wirrbel: There are default definitions, so when you define your own instance, you don't have to define all the functions. Minimal complete definition tells what you *have* to define in order to have all the functions.
03:02:04 <wirrbel> klugez, thanks
03:02:07 <mm_freak> BoR0: HSP/HSX actually have their own preprocessors and you need to feed your source code through it
03:02:10 <klugez> wirrbel: So if you are just using a ready instance, you don't have to care what they defined and what was provided by default. All are available.
03:02:18 <wirrbel> great
03:02:50 <mm_freak> BoR0: haskell itself provides quasiquotes for generating expressions from freeform strings
03:03:07 <mm_freak> tdammers's example is such a quasiquote
03:03:11 <mm_freak> yesod goes that route
03:03:19 <tdammers> HSX, the happstack thing, uses hsx2hs, a dedicated preprocessor that turns HSX templates into plain haskell
03:04:04 <BoR0> okay, so that's basically a templating library or something?
03:04:06 <mm_freak> BoR0: personally i like neither of the two approaches, so i use blaze-html with happstack (instead of HSP)
03:04:15 <mm_freak> no, it's a language extension
03:04:17 <BoR0> what is blaze-html?
03:04:26 <mm_freak> blaze-html is a HTML combinator library
03:04:42 <chrisdone> mm_freak: yay, blaze!
03:04:58 <mm_freak> myDoc = H.html (H.head (…) <> H.body (H.h1 "blah" <> …))
03:05:11 <mm_freak> myDoc = H.docType <> H.html (H.head (…) <> H.body (H.h1 "blah" <> …))
03:05:13 <mm_freak> of course =)
03:05:18 <BoR0> interesting, structure reminds of XML (without the closing tags) :)
03:05:27 <mm_freak> it's regular haskell =)
03:05:33 <tdammers> language extension? more like injecting a custom preprocessor into the source code
03:05:40 <tdammers> blaze is pure haskell though
03:05:43 <BoR0> mm_freak: but that approach doesn't use HSX I presume?
03:05:44 <mm_freak> tdammers: QQ is a language extension
03:05:48 <tdammers> QQ is, yes
03:05:50 <mm_freak> BoR0: nope
03:05:56 <BoR0> cool
03:06:04 <mm_freak> as said, it's regular plain haskell
03:06:09 <tdammers> I thought you were referring to what HSX does with its external preprocessor
03:06:11 <BoR0> I'm still new to haskell but I'd like to start playing with that stuff
03:06:24 <mm_freak> the "H." stuff is necessary, because you would normally import Text.Blaze.Html5 qualified
03:06:35 <chrisdone> mm_freak: http://hackage.haskell.org/package/blaze-0.0.1/docs/Blaze-Html5.html
03:06:45 <chrisdone> mm_freak: nahhh, i import it unqualified!
03:06:45 <mm_freak> otherwise you could even write:  docType <> html (head (…) <> body (h1 "blah" <> …))
03:06:54 <chrisdone> yeah, that's what i do
03:07:04 <chrisdone> although i don't use <>
03:07:14 <mm_freak> i prefer (<>) over (>>)
03:07:19 <chrisdone> BoR0: it can look much better than what mm_freak wrote:
03:07:30 <mm_freak> "much better" is subjective
03:07:45 <mm_freak> i don't consider the do-notation version "much better"
03:07:50 <mm_freak> in fact i consider it "much worse"
03:08:03 <chrisdone> do docType
03:08:03 <chrisdone>    html $ do
03:08:03 <chrisdone>      head $ do
03:08:03 <chrisdone>        title "hello"
03:08:06 <chrisdone>        script ! src "blah" $ mempty
03:08:09 <chrisdone>      body $ do
03:08:12 <chrisdone>        p "woot"
03:08:37 <BoR0> great. I like both approaches basically. at sometimes you need inline and sometimes you'd use multiline
03:08:43 <chrisdone> mm_freak: well yeah it's subject, what else would it be?
03:08:57 <chrisdone> BoR0: for inline you can also write: do foo; bar; mu
03:09:13 <BoR0> I see. so basically <> is a newline separator?
03:09:45 <BoR0> second approach is better imo because you don't get lost with parentheses
03:09:46 <chrisdone> nah, <> is a generic combining operator, in the case of the Html type it appends them
03:10:09 <chrisdone> :t (<>)
03:10:14 <lambdabot> Monoid m => m -> m -> m
03:11:52 <mm_freak> http://lpaste.net/95557
03:12:07 <mm_freak> that's about what templates look like in my code
03:12:54 <mm_freak> remember, this is haskell, not HTML…  no need to have 20-layer-deep nesting
03:13:21 <BoR0> I'll start playing with happstack and see how far I'll make it, thanks :)
03:13:39 <chrisdone> my template looks like this: https://github.com/chrisdone/ircbrowse/blob/master/src/Ircbrowse/View/Template.hs
03:14:28 <chrisdone> and some view code https://github.com/chrisdone/ircbrowse/blob/master/src/Ircbrowse/View/Profile.hs
03:14:57 <chrisdone> not as tidy as it would ideally be, but not too bad considering it was written in a rush
03:15:24 <chrisdone> for this page http://ircbrowse.net/nick/mm_freak
03:23:22 <chrisdone> mm_freak: show some real code! ;)
03:24:45 <mm_freak> chrisdone: of what?
03:24:53 <chrisdone> mm_freak: using blaze
03:25:18 <chrisdone> i haven't really seen a full module of blaze written by someone else other than me
03:32:12 <mm_freak> chrisdone: http://lpaste.net/95558
03:32:20 <mm_freak> had to remove/censor some parts
03:35:35 <davison> c
03:44:20 <chrisdone> mm_freak: hardly substantial example, but n/m if it's only proprietary code
03:45:52 <mm_freak> chrisdone: well, unfortunately i had to remove large parts of the code =)
03:46:27 <mm_freak> but it's enough to understand my blaze-html coding style
03:53:05 <popx_> let f a b c = a + b + c
03:53:16 <popx_> 1 `f 2` 1
03:53:28 <popx_> > let f a b c = a + b + c
03:53:29 <lambdabot>   not an expression: `let f a b c = a + b + c'
03:55:56 <byorgey> popx_: you can only have identifiers inside backticks, not expressions
03:56:07 <byorgey> @let f a b c = a + b + c
03:56:09 <lambdabot>  Defined.
03:56:13 <byorgey> > 1 `f 2` 1
03:56:14 <lambdabot>   <hint>:1:6: parse error on input `2'
03:57:04 <Ghoul_> > let n = f2 in 1 `n` 1
03:57:05 <lambdabot>   Not in scope: `f2'
03:57:05 <lambdabot>  Perhaps you meant one of these:
03:57:05 <lambdabot>    `f' (line 161), `f' ...
03:57:12 <Ghoul_> > let n = f 2 in 1 `n` 1
03:57:14 <lambdabot>   Ambiguous occurrence `f'
03:57:14 <lambdabot>  It could refer to either `L.f', defined at L.hs:1...
03:59:52 <popx_> byorgey: thanks
04:00:00 <popx_> is there a reason for this?
04:00:06 <chrisdone> anyone get optLevel to work with the ghc api? i've figured this out once before and forgot the arcane way to achieve it
04:02:37 <int-e> > 1 + 2
04:02:39 <lambdabot>   3
04:03:30 <int-e> hmm. seems fine now.
04:11:56 <byorgey> popx_: no particular reason, though it would make parsing more difficult.
04:18:54 <Kneiva> http://jobs.silk.co/page/Software%20Engineer%2C%20Haskell
04:25:19 <FireFly> ISve been wanting expressions inside backticks occasionally..
04:25:32 <FireFly> I've*
04:26:39 <srhb> FireFly: Yes, it's weird that it's not allowed.
04:28:07 <tdammers> I think backticks are handled at a fairly early stage of parsing... haven't read the parser code, but it would explain a thing or two
04:30:13 <Egbert9e9> I want to make a *complaint*.
04:30:16 <Egbert9e9> </cleese>
04:30:34 <srhb> Egbert9e9: You can have an argument.
04:30:35 <tdammers> about a "mattress"?
04:32:02 <Egbert9e9> there's an error on the wiki. I wonder if it's the haskell cabal members only or I could just register now and edit away
04:32:15 <Egbert9e9> oh, tried. i can't
04:32:49 <Egbert9e9> anyways, the error is in "test = V.foldl (\ a b -> a * sqrt (fromIntegral b)) 0" on http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
04:33:25 <Egbert9e9> either change it from * to + or 0 to 1
04:34:01 <Egbert9e9> thanks!
04:34:47 <srhb> Egbert9e9: But it's much more efficient like this!
04:37:11 <Egbert9e9> :D
04:45:54 <bz> is it possible to use Attoparsec.Char8.string without having to call ByteStringChar8.pack on all its arguments?
04:49:24 <sopvop> bz: {-# LANGUAGE OverloadedStrings #-}?
04:50:57 <bz> sopvop: cool, thanks
04:51:27 <mm_freak> bz: with that extension you can even write just "blah" instead of 'string "blah"'
04:53:50 <Narvius> Is there a downside to TupleSections?
04:53:58 <Narvius> Like, some edge-case ambiguity or something?
04:54:26 <danr> no...?
04:54:51 <bz> mm_freak: wow, cool
04:55:05 <Narvius> Okay, so basically it's just an extension because of an oversight.
04:55:35 <danr> maybe. or because of addiction to syntactic sugar
04:59:11 <mm_freak> Narvius: nobody understands why (,) is not a real operator
04:59:53 <mm_freak> having a right-associative regular operator (,) would be much more useful than what we have right now
04:59:54 <Ghoul_> couldn't you instantiate it and have them unpacked like in python?
05:00:06 <Ghoul_> ie
05:00:14 <Ghoul_> 1 , 2 , 3 , 4 -> (1, 2, 3, 4)
05:00:29 <Narvius> I'm pretty sure that's what mm_freak means, roughly.
05:00:45 <Ghoul_> that could be implemented using instances at a really high level. (Oh god, has anyone seen GHC.Tuple?!)
05:01:08 <mm_freak> x, y, z = x, (y, z) :: A, (B, C)
05:01:11 <Narvius> Looking it up, nao
05:01:15 <mm_freak> data a, b = a, b
05:01:22 <Narvius> ahahahahaha _^_
05:01:24 <mm_freak> infixr 1 ,
05:01:32 <Narvius> seriously
05:01:48 <mm_freak> in other words, every tuple is a 2-tuple
05:01:59 <Ghoul_> you could do better than that I think
05:02:08 <Ghoul_> you could make 2-tuples need to be explicit
05:02:08 <mm_freak> Ghoul_: "better"?
05:02:29 <Ghoul_> the same way people do varidic functions but I'd need a refresher there
05:02:32 <FireFly> The 0-tuple isn't :P
05:02:36 <chrisdone> mm_freak: like lisp!
05:02:36 <chrisdone> let car = fast; cdr = snd
05:02:38 <mm_freak> to improve something, it has to have a weakness
05:03:06 <mm_freak> chrisdone: i think so, yeah
05:03:15 <mm_freak> get rid of all this (,,,,,,,,,,,,,,,,,,) craziness
05:03:19 * Ghoul_ doesn't want to be writing the compiler when the AST for a large tuple needs to be debugged
05:03:22 <mm_freak> make (,) an operator!
05:03:38 <Narvius> So basically, convert tuples to a list that has it's length enforced by type.
05:03:39 <Narvius> Awesome.
05:03:49 <Narvius> its*
05:04:02 <mm_freak> no
05:04:07 <chrisdone> tuples specifically are well optimized by haskell compilers tho
05:04:45 <Ghoul_> thats a characteristic of them being data which is inherently "next to each other" rather than nested within itself
05:04:47 <Narvius> mm_freak: What you propose is essentially a linked list, with a pair as basic cell.
05:05:09 <mm_freak> Narvius: not quite
05:05:16 <mm_freak> A, B has no list representation
05:05:28 <Narvius> Yeah, and element-terminated instead of null-terminated
05:05:40 <Narvius> Still, it's essentially the same.
05:05:47 <chrisdone> due to this lisp has a delightful notion of "improper lists"
05:05:59 <mm_freak> GHC optimizes (A, B, C, D) as well as (A, (B, (C, D)))
05:06:07 <mm_freak> so optimization is not lost
05:06:19 <mm_freak> also please don't design a language for the optimizations you can perform
05:06:19 <Narvius> That's cool.
05:06:37 <mm_freak> by that standard haskell would be a terrible language!
05:06:39 <Narvius> Though what about type signatures?
05:06:40 <Ghoul_> class Tuple t where (,) :: a -> t
05:06:55 <Ghoul_> woops, :: a -> b -> t
05:07:03 <mm_freak> Narvius: not terminated!
05:07:04 <Ghoul_> then instantiate t as (a, b) (a, b, c) etc
05:07:06 <chrisdone> mm_freak: that's why agda's a great language!
05:07:12 <Ghoul_> like GHC.Tuple does at the moment
05:07:15 <Ghoul_> then you could just theoretically
05:07:19 <Ghoul_> (1,2) , 3 --> (1,2,3)
05:07:41 <mm_freak> Narvius: data a, b = a, b
05:07:43 <mm_freak> that's the whole type
05:07:53 <Narvius> OOooooh.
05:07:54 <Narvius> Neat.
05:08:07 <mm_freak> then make (,) right-associative and a regular operator
05:08:16 <Narvius> That's really goddamn sleek, actually.
05:08:54 <mm_freak> f :: A, B, C -> D, E
05:09:01 <mm_freak> = (A, (B, C)) -> (D, E)
05:09:11 <mm_freak> f (x, y, z) = (a, b)
05:09:18 <Narvius> Or (A, B, C) -> (D, E), for that matter
05:09:24 <mm_freak> = f (x, (y, z)) = a, b
05:09:28 <mm_freak> yeah
05:09:29 <Ghoul_> 1,2 .. 3, right, so a (..) b = (start, range) end
05:09:40 <Ghoul_> even list ranges can be high level functions! :D
05:09:47 <Narvius> Oh, but pattern matching still is shot, right.
05:09:57 <mm_freak> shot?
05:10:02 <FireFly> Couldn't (,) be a constructor?
05:10:02 <chrisdone> lists use (a:b:c) so why not (a,b,c)
05:10:08 <Narvius> Oh, right.
05:10:11 <mm_freak> FireFly: that's what i'm proposing
05:10:16 <Narvius> Right.
05:10:22 <danr> (,) is a constructor
05:10:23 <FireFly> mm_freak: yeah, was just clarifying that it wasn't a "regular" operator as in a function
05:10:34 <mm_freak> FireFly: but i want (,) to be a regular operator
05:10:43 <FireFly> but then you can't pattern-match on it, can you?
05:10:44 <mm_freak> and completely get rid of higher tuples
05:10:53 <chrisdone> FireFly: consider (:)
05:10:53 <Ghoul_> you
05:10:58 <FireFly> Yes, but it'd have to be a constructor (as opposed to not-a-constructor)
05:10:59 <mm_freak> FireFly: do you have trouble pattern-matching on (:)?
05:11:06 <FireFly> no, but that's a constructor!
05:11:09 <Ghoul_> have (honestly) really just turned tuples into explicit length lists
05:11:20 <mm_freak> FireFly: (,) is a constructor, too…  but it's not an operator!
05:11:22 <danr> > let ((,) x y) = (1,2) in x + y
05:11:24 <lambdabot>   3
05:11:37 <FireFly> Right, that was my point (that (,) is a constructor) :P
05:11:47 <FireFly> I'm not disagreeing!
05:12:06 <mm_freak> Ghoul_: no
05:12:19 <mm_freak> Ghoul_: represent (A, B) as a length-indexed list
05:12:43 <Narvius> So basically, the only thing preventing us from doing this is (,) not being a legal constructor in the sense of data a, b = a, b
05:13:01 <danr> let a , b = b , a
05:13:04 <chrisdone> mm_freak: [a,b] :: List 2 a
05:13:04 <mm_freak> the only thing preventing us from this is that (,) is syntactically special
05:13:14 <mm_freak> chrisdone: the type (A, B)
05:13:18 <mm_freak> not the value
05:13:32 <chrisdone> mm_freak: [a,b] :: List 2 (A :+: bB)
05:13:34 <Ghoul_> couldn't you do better with Seq magic
05:13:42 <chrisdone> mm_freak: think of HList
05:13:45 <Ghoul_> rather than using internal data stuff
05:13:52 <Ghoul_> since that'll inherently make it a linked list..
05:14:02 <mm_freak> chrisdone: i know, but that's not my point
05:14:06 <chrisdone> Seq magic?
05:14:25 <Ghoul_> (from what I remember, Seq are contiguous in memory..)
05:14:28 <mm_freak> there is really no reason to have infinitely many tuple types…  a single tuple type is sufficient and would simplify a lot of code
05:14:35 <Saizan> (nope)
05:15:13 <chrisdone> i suppose one difficulty with this is type instances
05:15:15 <Saizan> Seq are weirdly shaped trees for faster access to end-points and splitting, afaiu
05:15:15 <Ghoul_> there is reason though
05:15:23 <mm_freak> syntax is pretty much the only reason we don't do it that way
05:15:33 <mm_freak> and this gets really really annoying when working with arrows
05:16:10 <Ghoul_> I bet such an implementation would be slower and would require pulling out complex analysis to get it back the way it was
05:16:36 <Ghoul_> right now tuples are used everywhere to thread tokens through the core and if they were suddenly a type of constructor it would make everything so much more complex
05:16:57 <Narvius> GHC supposedly already optimizes (a,(b,(c,...))) as well as (a,b,c...)
05:17:01 <bz> @hoogle many
05:17:01 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
05:17:01 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
05:17:01 <lambdabot> Text.Parsec.Prim many :: ParsecT s u m a -> ParsecT s u m [a]
05:17:11 <mm_freak> Ghoul_: you would lose that bet
05:17:18 <Ghoul_> what he proposed isn't like that though
05:17:21 <bz> seems the 'many' combinator disappeared from Attoparsec.Combinators
05:17:27 <ski> `let a , b = b , a' is possible in OCaml ..
05:17:29 <Narvius> That's exactly it, Ghoul_.
05:17:36 <Narvius> That's exactly what he's proposing.
05:17:38 <Ghoul_> data a b = a , b or something like that, no?
05:17:47 <FireFly> whu
05:17:53 <Narvius> data a, b = a, b is the basic pair
05:17:53 <mm_freak> there is one important difference:  strictness
05:17:58 <Narvius> Make it right-associative
05:18:06 <mm_freak> (a, (b, c)) is not exactly isomorphic to (a, b, c)
05:18:07 <Narvius> And then you can go "a, b, c, d"
05:18:10 <chrisdone> bz: i don't think @hoogle knows about attoparsec
05:18:21 <ski> in OCaml, `a , b , c' is distinct from both `(a , b) , c' and `a , (b , c)'
05:18:28 <Ghoul_> so then you end up with
05:18:37 <Ghoul_> (,) ((,) 1 2) 3
05:18:45 <Ghoul_> for (1,2,3) which is a pointer that has to be optimized away
05:18:49 <Narvius> Right-associative
05:19:01 <Narvius> 1,(2,3)
05:19:03 <mm_freak> Ghoul_: you would still lose that bet
05:19:05 <Narvius> (1,(2,3))
05:19:06 <Ghoul_> oh, well, yeah shuffle it around. but same thing
05:19:43 <Ghoul_> look, it does a shit job of optimizing lists like that unless they are fused
05:19:51 <Ghoul_> it's going to be no different for tuples..
05:20:18 <danr> there are more bottoms in (a,(b,c)) than in (a,b,c)
05:20:20 <bz> chrisdone: http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/Data-Attoparsec-Combinator.html it's not here either
05:20:21 <chrisdone> ski: true, that has different meaning
05:20:29 <bz> i'll just use many1 in the meantime
05:20:42 <ski> i suppose one could imagine `a , b , c , d' being syntactic sugar for `(,) (# a , (# b , (# c , (# d , (# #) #) #) #) #)' or something like that
05:20:53 * hackagebot syntactic 1.8 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.8 (EmilAxelsson)
05:21:06 <chrisdone> bz: did it ever have "many"?
05:21:10 <Ghoul_> ski: except that unboxing will be really really hard to reason about
05:21:24 <Ghoul_> since then the compiler needs to specialize all the functions that take such a tuple over all the unboxed variants..
05:21:34 <ski> Ghoul_ : i thought we wanted unboxing, to get rid of intermediate indirections ?
05:21:37 <bz> chrisdone: yes: https://bitbucket.org/bos/attoparsec/src/tip/examples/RFC2616.hs#cl-57
05:21:51 <ski> "all the unboxed variants" ?
05:21:52 <Ghoul_> you absolutely would, but a very high level a , b wouldn't give it to you.
05:22:14 <bz> chrisdone: http://hackage.haskell.org/package/attoparsec-0.8.1.0/docs/Data-Attoparsec-Combinator.html#v:many
05:22:48 <chrisdone> bz: that example is using Control.Applicative, i think
05:22:54 <zol> Is it possible to have a where in a do statement?
05:23:04 <ski> zol : not directly
05:23:19 <ski> `let' is probably your nicest bet
05:23:20 <zol> ski: Can i use a let expression then?
05:23:33 <Ghoul_> bleh, whatever
05:23:34 <ski> sometimes you can factor out local bindings, and use a `where' anyway
05:23:41 <zol> ski: Ah, thanks!
05:23:55 <ski> (well, s/sometimes/always/ -- the question is whether it is nice enough or not)
05:23:59 <bz> chrisdone: see the 0.8.1.0 haddock
05:24:13 <ski> zol : let expression, or let command
05:24:35 <zol> ski: let command?
05:25:43 <chrisdone> bz: seems it was removed here: https://github.com/bos/attoparsec/commit/4e443c8f535c95caccdc20549d72e3311fa8bbdb#diff-f5a753ed9c56672085ddf28d5fc1337bL136
05:27:05 <chrisdone> bz: perhaps Control.Applicative inlines properly now with SPECIALIZE
05:27:36 <ski> zol : `do {x <- foo; let {y = ..f..x..; f z = ..f..x..y..z..}; ..f..x..y..}'
05:28:03 <chrisdone> bz: e.g. https://github.com/bos/attoparsec/commit/4e443c8f535c95caccdc20549d72e3311fa8bbdb#diff-19f60ca4c52af86b5f063634b784f8fcR199
05:28:05 <zol> ski: Ah, thanks!
05:28:18 <chrisdone> bz: happy? =)
05:28:35 <maikklein> I messed up cabal :(. Where does cabal save what libs are installed?
05:28:58 <bz> chrisdone: i should've looked at git. thanks!
05:29:07 <quchen> maikklein: ~/.ghc/i386-linux-7.6.3/package.conf.d for me
05:29:15 <chrisdone> maikklein: cabal saves package archives in your ~/.cabal and ghc installs them in .ghc
05:29:36 <chrisdone> bz: welcome!
05:30:08 <maikklein> thanks
05:30:30 * chrisdone laughs evily every time lpaste notifies him that a spams paste has been blocked
05:31:35 <quchen> chrisdone: What does LPaste do against spam now?
05:31:40 <ski> @quote bwahaha
05:31:40 <lambdabot> monochrom says: Power doesn't corrupt you. No no no. Power makes you INSANE! Absolute power makes you absolutely insane! BWAHAHAHAHAHA...
05:31:53 <chrisdone> quchen: it uses spamassassin
05:32:13 <chrisdone> quchen: if it detects something that seems spammy it informs the user "sorry, try to make your paste less spammy"
05:32:35 <chrisdone> https://github.com/chrisdone/lpaste/blob/master/src/Hpaste/Model/Spam.hs
05:32:41 <quchen> chrisdone: Like this? http://dilbert.com/dyn/str_strip/000000000/00000000/0000000/000000/00000/7000/200/7251/7251.strip.gif
05:34:24 <PudgePacket> @help
05:34:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:35:13 <chrisdone> quchen: hahaha
05:40:40 <Narvius> I see the contraction "CPS" crop up from time to time.
05:40:41 <Narvius> What is it?
05:40:55 <maikklein> hm I accidentally deleted the package.cache file :( is there a way to initialize it again? I tried "sudo ghc-pgk recache" but it doesn't do anything
05:40:56 <chrisdone> @google continuation-passing style
05:40:57 <lambdabot> http://en.wikipedia.org/wiki/Continuation-passing_style
05:40:57 <lambdabot> Title: Continuation-passing style - Wikipedia, the free encyclopedia
05:41:05 <Narvius> Thanks.
05:41:19 <chrisdone> maikklein: ghc-pkg init
05:43:57 <sherlock__> clear
05:45:49 <chrisdone> hmm, experimenting with a corebot
05:46:03 <chrisdone>  > let fib 0 = 0; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 25
05:46:07 <chrisdone> lvl = __integer 0;lvl1 = __integer 1;lvl2 = __integer 2;C.e_fib = \ds → case eqInteger ds lvl of{False → case eqInteger ds lvl1 of{False → plusInteger (e_fib (minusInteger ds lvl1)) (e_fib (minusInteger ds lvl2));True → lvl1};True → lvl};C.e1 = __integer 25;C.e = e_fib e1
05:46:11 <chrisdone> is that readable?
05:46:44 <chrisdone> it's meant to fit in a couple lines of irc
05:48:57 <skypers_> hi folks :)
05:48:58 <jmcarthur_mobile> I don't feel like core directly in IRC is likely to work out very well
05:49:04 <skypers_> I’m studying functions as monads
05:49:19 <skypers_> and I don’t get it when composing IO functions
05:49:31 <skypers_> I wrote a few to experience
05:49:34 <jmcarthur_mobile> I would feel better with the bot pasting to lpaste or something
05:49:55 <jmcarthur_mobile> What do you by functions as monads?
05:50:02 <jmcarthur_mobile> *mean by
05:50:16 <skypers_> @let hello = putStrLn . (++) "Hello, "
05:50:17 <lambdabot>  Defined.
05:50:33 <skypers_> @let foo = putStrLn . (++) ", foo!"
05:50:34 <lambdabot>  Defined.
05:50:37 <skypers_> ok now
05:50:40 <chrisdone> jmcarthur_mobile: your skepticism is noted
05:50:57 <jmcarthur_mobile> That's all I ask. :)
05:50:59 <chrisdone> > fromMaybe "hum" (maybe Nothing Just (return "Hello!"))
05:50:59 <chrisdone> e = unpackCString# "Hello!"
05:51:00 <lambdabot>   "Hello!"
05:51:01 <skypers_> :t do { a <- hello; b <- foo }
05:51:02 <lambdabot>     The last statement in a 'do' block must be an expression b <- foo
05:51:09 <skypers_> :t do { a <- hello; foo }
05:51:10 <lambdabot> [Char] -> IO ()
05:51:13 <skypers_> if I do
05:51:15 <chrisdone> see ^ the output can be quite nice
05:51:30 <skypers_> > (hello >> foo) "skypers"
05:51:38 <lambdabot>   mueval-core: Time limit exceeded
05:51:38 <skypers_> alo lambdabot ?
05:51:41 <skypers_> what?!
05:52:07 <chrisdone> someone give me some code to run against my corebot to see if it produces something massive
05:52:13 <skypers_> jmcarthur_mobile: I mean
05:52:15 <skypers_> function monad
05:52:25 <skypers_> ((->) r) a
05:52:26 <chrisdone> skypers_: please type on one line more often
05:52:34 <srhb> skypers_: We usually call it the Reader monad. :)
05:52:44 <jmcarthur_mobile> Got it
05:52:47 <skypers_> yeah, implicit Reader monad
05:52:48 <skypers_> the think is
05:53:01 <skypers_> (hello >> foo) "skypers" only takes foo in account
05:53:02 <skypers_> not hello
05:53:08 <skypers_> I’m trying to figure out
05:53:13 <srhb> dittos what chrisdone said
05:53:30 <skypers_> yeah sorry, wrong habits
05:53:35 <chrisdone> skypers_: is the comma key on your keyboard dusty? =p
05:53:56 <skypers_> chrisdone: I’m used not to using it because return key is more dynamic
05:54:05 <benj_> this is IRC, not AIM
05:54:06 <skypers_> but I won’t doing that, I promise
05:54:13 <skypers_> yeah yeah, got it
05:54:22 <jmcarthur_mobile> Since the only effect in the reader monad is reading, the left argument has no effect on the right, and since it ignores the result of the left argument, it is just totally ignored
05:54:42 <chrisdone> tibbe: i'm testing a "corebot" that takes in an expr and outputs core. gimmie an expr that's likely to output something horrendous! =p
05:55:01 <skypers_> jmcarthur_mobile: ok but :
05:55:19 <skypers_> > (a <- (*2); b <- (+1); return $ a + b) 4
05:55:22 <lambdabot>   <hint>:1:4: parse error on input `<-'
05:55:28 <skypers_> hm
05:56:02 <skypers_> well you know, that thing cleary uses both the expressions whereas the former doesn’t
05:56:06 <jmcarthur_mobile> Needs do
05:56:12 <jmcarthur_mobile> Right
05:56:13 <donri> chrisdone: lots of Text literals :p
05:56:17 <skypers_> > (do {a <- (*2); b <- (+1); return $ a + b}) 4
05:56:19 <lambdabot>   13
05:56:22 <jmcarthur_mobile> It's using the result of both
05:56:53 <jmcarthur_mobile> Because its using (>>=), not (>>)
05:56:56 <donri> chrisdone: uh actually they fixed that, nevermind =)
05:56:57 <skypers_> jmcarthur_mobile: ok so here my question: in do { a <- hello; b <- foo }, what is the type of a and b?
05:56:59 <skypers_> IO ()?
05:57:12 <jmcarthur_mobile> Yes
05:57:17 <skypers_> then how would I compose them?
05:57:31 <skypers_> > (a <- hello; b <- foo; a >> b) "skypers"
05:57:32 <lambdabot>   <hint>:1:4: parse error on input `<-'
05:57:35 <jmcarthur_mobile> return (a >> b)
05:57:41 <skypers_> > (do {a <- hello; b <- foo; a >> b}) "skypers"
05:57:42 <lambdabot>   Couldn't match type `(->) [GHC.Types.Char]' with `GHC.Types.IO'
05:57:42 <lambdabot>  Expected t...
05:57:58 <tdammers> :t a
05:58:01 <lambdabot> Expr
05:58:02 <skypers_> > (do {a <- hello; b <- foo; return $ a >> b}) "skypers"
05:58:09 <lambdabot>   mueval-core: Time limit exceeded
05:58:12 <jmcarthur_mobile> skypers_: I think you may be discovering the need for monad transformers
05:58:12 <skypers_> dammit!
05:58:23 <skypers_> jmcarthur_mobile: I’m already using them
05:58:25 <jmcarthur_mobile> skypers_: lambda bot won't do io
05:58:40 <skypers_> but it’s off topic here because I _want_ to understand function monads
05:58:54 <skypers_> I discovered a few weeks ago liftM2 (>>), and never understand it really
05:58:58 <skypers_> now I think I do :)
05:59:16 <tibbe> chrisdone: hah
05:59:18 <jmcarthur_mobile> Try not mixing io then. Mixing two monads makes it harder to learn one
05:59:25 <tibbe> chrisdone: I only write haskell that generates beautiful core;)
05:59:30 <chrisdone> tibbe: ;D
05:59:41 <skypers_> jmcarthur_mobile: but hm, here it’s powerful!
05:59:42 <Eduard_Munteanu> How do you do expression parsing with attoparsec? Is it enough to combine parses with (<|>) in decreasing order of precedence?
05:59:49 <skypers_> I can ommit the extra last parameter
06:00:18 <jmcarthur_mobile> You are using it like ReaderT
06:00:33 <khyperia> Eduard_Munteanu, http://hackage.haskell.org/package/attoparsec-expr-0.1/docs/Data-Attoparsec-Expr.html is one option, the other is to do it how that's implemented
06:00:44 <skypers_> yeah well, ReaderT would make me use lift
06:00:53 <Boreeas> How do I print a line for each element in a list? i.e. I got Show a => [a], and I want to print a line for each a in [a]
06:01:04 <jmcarthur_mobile> skypers_: and this is making you use return
06:01:04 <srhb> Boreeas: mapM_ putStrLn
06:01:05 <skypers_> Boreeas: traverse_ print
06:01:12 <Eduard_Munteanu> Hm, yeah...
06:01:15 <chrisdone> corebot> runReader (do i <- ask; return (i*2)) 55
06:01:15 <chrisdone> it = __integer 110
06:01:15 <srhb> Oh
06:01:19 <srhb> yeah, print
06:01:21 <srhb> not putStrLn
06:01:21 <chrisdone> donri: ^ =)
06:01:27 <Boreeas> Thanks!
06:02:07 <skypers_> jmcarthur_mobile: yeah, you’re right. At first I came with the need to compose MonadIO functions with &, like :
06:02:10 <khyperia> Eduard_Munteanu, this is how I used to do expressions before I learned of that function. http://www.seas.upenn.edu/~cit596/notes/dave/bnf4.html
06:02:21 <khyperia> it's the standard way of defining precedence in a top-down parser
06:02:21 <skypers_> something & action >> action1 >> action2
06:02:29 <skypers_> but it won’t work
06:02:35 <skypers_> oh!, ap right?
06:02:40 <jmcarthur_mobile> I don't even know what that means
06:02:58 <srhb> I think it's & as in flip ($)
06:02:59 <Eduard_Munteanu> khyperia: I guess that works if I don't care about associativity?
06:03:01 <skypers_> jmcarthur_mobile: it passes something to (action >> action1 >> action2)
06:03:06 <skypers_> yeah it is
06:03:21 <skypers_> it’s like “with something, do that”
06:03:24 <khyperia> Eduard_Munteanu, the Binary constructor takes an Associativity (or some class name like that)
06:03:31 <jmcarthur_mobile> Again, the first two actions will be ignored
06:03:40 <skypers_> yeah yeah
06:03:41 <Eduard_Munteanu> khyperia: I mean the BNF representation
06:03:44 <skypers_> I know it now
06:03:50 <jmcarthur_mobile> Because you aren't using their results, and they have no observable effects
06:03:54 <khyperia> Oh, yeah, it's hard to represent associativity in BNF
06:03:54 <skypers_> I wonder whether I can do it with ap
06:04:11 <jmcarthur_mobile> I don't know what you expect it to do
06:04:23 <skypers_> jmcarthur_mobile: something like sequence_
06:04:30 <khyperia> Eduard_Munteanu, it's possible, though - I usually just do it as a foldl or foldr in the construction step, and parse it as a list.
06:04:43 <jmcarthur_mobile> skypers_: in the reader monad?
06:04:48 <khyperia> Eduard_Munteanu, (note that I usually use parsec, no idea what attoparsec is)
06:05:02 <skypers_> jmcarthur_mobile: no, in the last line I pasted
06:05:14 <jmcarthur_mobile> skypers_: sequence_ in the reader monad does the same thing. It will just ignore everything but the last element
06:05:44 <skypers_> yeah I got it jmcarthur_mobile
06:05:52 <Eduard_Munteanu> khyperia: what I have now is a  data Expr = Eval Name | And Expr Expr ...  so I wondered whether making a parser from that structure would be enough.
06:05:54 <skypers_> I’m gonna experience it
06:05:57 <jmcarthur_mobile> The last line you pasted uses the reader monad
06:06:13 <skypers_> jmcarthur_mobile: that’s why I’m looking for a way not to use it :)
06:06:16 <skypers_> like :
06:06:24 <skypers_> something & sequence_ [actions]
06:06:28 <skypers_> I may need fmap here
06:06:36 <khyperia> Eduard_Munteanu, so you don't care about associativity? Question mark?
06:06:47 <Eduard_Munteanu> khyperia: e.g. exprP = (Eval <$> nameP) <|> (And <$> exprP <* "&&" <*> exprP) <|> ...
06:06:52 <jmcarthur_mobile> skypers_: mapM_?
06:06:57 <Eduard_Munteanu> khyperia: yeah, I'm not sure I care about it.
06:07:45 <khyperia> Ah, no idea how that would work... it *might*, although you need to fix the left-recursive issue, and not sure how multiple ops with same prec would work
06:07:51 <skypers_> yeah!
06:07:55 <Lambi> Hello guys. I'm just learning about making my own typeclasses. Having made one, how do I make a type an instance of that typeclass?
06:08:00 <skypers_> mapM_ ($ something) [actions]
06:08:03 <skypers_> that should work
06:08:03 <khyperia> seems like once you fixed the left-recursion it would turn into everything is the same prec with left association
06:08:11 <jophish> Yo yo yo
06:08:25 <jmcarthur_mobile> Yup
06:08:30 <Eduard_Munteanu> khyperia: hm, so it basically follows the associativity of (<*>)?
06:08:44 <Eduard_Munteanu> That'd make sense.
06:08:47 <khyperia> No, no...
06:09:03 <khyperia> do you understand what I mean by "the left-recursion issue"?
06:09:08 <Eduard_Munteanu> khyperia: not exactly
06:09:09 <jophish> Does ghc typecheck before or after desugaring? The checking would be easier after desugaring everything, but a pointer to the sugared code would have to be held onto to give proper error messages
06:10:05 <tdammers> Lambi: instance Foo Bar where ...
06:10:16 <khyperia> Eduard_Munteanu, essentially, in your parser example, "exprP = ... <|> (And <$> exprP <* ...) <|> ..." - say the Eval fails, so it goes and tries to parse an And, the first argument is exprP, and then it recurses forever.
06:10:16 <tdammers> @where lyah
06:10:17 <lambdabot> http://www.learnyouahaskell.com/
06:10:17 <Lambi> tdammers: where do I write this?
06:10:24 <tdammers> @where rwh
06:10:24 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:10:31 <Eduard_Munteanu> khyperia: mind attoparsec backtracks automatically, even in case of failure with partial input consumption
06:10:39 <tdammers> or whatever resource you're using to learn haskell
06:10:47 <Lambi> lyah atm
06:10:49 <tdammers> they should cover typeclasses and instances in depth
06:11:18 <khyperia> Eduard_Munteanu, if attoparsec fixes left recursion somehow, then awesome. I've never used it, though, only parsec.
06:11:23 <tdammers> it's really a fundamental thing in Haskell, so check out what lyah has to say about the matter
06:11:35 <tdammers> feel free to ask more specifically about things you don't understand
06:11:43 <Eduard_Munteanu> khyperia: oh, hm... I guess a proper fix is to make recursion explicit and make sure I consume at least one token each step
06:11:57 <skypers_> good afternoon :)
06:12:12 <jmcarthur_mobile> jophish: I think before desugaring, but I'm not 100%
06:12:24 <jophish> jmcarthur_mobile: yeah, that's the answer I got in #ghc
06:12:26 <jophish> thanks
06:12:44 <Lambi> tdammers: I'm just comfused about where to write my 'instance declaration'
06:12:51 <ski> left-recursion is a PITA
06:13:08 <Eduard_Munteanu> khyperia: it seems one way is to tokenize before parsing, not sure I want to do that though
06:13:09 <khyperia> Eduard_Munteanu, and generally your parser turns into <expr> := <primary> op <expr> | <primary>", where <primary> is "the next higher precedence"
06:13:16 <Eduard_Munteanu> Oh.
06:13:37 <FireFly> Lambi: anywhere, more or less. Like you would with a (top-level) function, or a type class
06:14:10 <khyperia> Eduard_Munteanu, and then the last link in the chain is your primary parser, aka identifiers, numbers, the like
06:14:33 <Eduard_Munteanu> I see, thanks.
06:15:11 <khyperia> Eduard_Munteanu, if you want multiple ops with same prec, you kludge them into the same <expr> in a big or statement. You can see how this is turning into a huge PITA, which is what that function I linked before does all for you.
06:15:46 <Eduard_Munteanu> Nah, each parse has a distinct precedence. (kconfig files)
06:15:53 <khyperia> Ah.
06:16:11 <tdammers> Lambi: oh, right - at the top level, pretty much anywhere that makes sense to you
06:16:43 <ski>   <expr> ::= <non-left-rec-0>
06:16:45 <Feuerbach> jophish: ghc typechecks before desugaring, afair
06:16:46 <Eduard_Munteanu> khyperia: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/kbuild/kconfig-language.txt#n160
06:16:51 <ski>            | <non-left-rec-1>
06:16:57 <ski>            | <expr> <expr-rest-0>
06:17:08 <ski>            | <expr> <expr-rest-1>
06:17:14 <Feuerbach> jophish: oh, I see it's been answered on #ghc :)
06:17:16 <ski> is translated into
06:17:29 <ski>   <expr> ::= <expr-base> <expr-cont>
06:17:37 <jophish> Feuerbach: yeah, thanks anyway :)
06:17:41 <ski>   <expr-base> ::= <non-left-rec-0>
06:17:47 <Eduard_Munteanu> Oh, hm.
06:17:54 <ski>                 | <non-left-rec-1>
06:18:07 <ski>   <expr-cont> ::= <epsilon>
06:18:29 <ski>                 | <expr-rest-0> <expr-cont>
06:18:31 <Lambi> tdammers: Do I need to write a module (in my typeclass file) and later import that whenever I want to make a type an instance of it? That to me feels inconvenient but my code compiles and runs just fine.
06:18:33 <ski>                 | <expr-rest-1> <expr-cont>
06:18:38 <ski> Eduard_Munteanu : that's the general idea
06:19:29 <ski> you need some extra plumbing to construct the parse tree (or whatever result you want) right
06:20:36 <Eduard_Munteanu> ski: is it something like   expr :: Parser Expr, exprBase :: Parser Expr, exprCont :: Expr -> Parser Expr   ?
06:20:47 <Eduard_Munteanu> epsilon is a Nothing ?
06:20:48 <ski> yes
06:20:57 <ski> `epsilon' is `pure'
06:21:03 <Eduard_Munteanu> Oh.
06:21:53 <Eduard_Munteanu> ski: hmm... I'm already writing my parsers as 'Free Parser a'.
06:22:22 <Eduard_Munteanu> I wonder if there's a nice way to fit your structure into that.
06:22:28 <ski> hmm
06:22:51 <ski> actually, `exprCont :: Parser (Expr -> Expr)' is perhaps nicer (if possible)
06:22:59 <ski> otherwise i think you'd have to go monadic
06:23:09 <ski> (which might or might not be a problem, mind)
06:23:36 <Eduard_Munteanu> Hm, that should be doable, the Expr -> Expr thing.
06:23:36 <ski> with the former, we get something like
06:23:46 <ski>   exprCont e0 = pure e0 <|> (exprCont =<< (And e0 <* ... <*> exprP))
06:23:55 <ski> with the latter, hm
06:24:36 <tdammers> Lambi: you can do it anywhere you like; if you put the instance declaration into a separate file, you need to import it, but otherwise it should just work
06:24:44 <ski> i think you can make it with `<**>' or something, but i can't immediately see the structure
06:24:55 <tdammers> the only thing that can get confused by ordering at the top level is template haskell related
06:25:20 <Lambi> tdammers: all right then. Seems to be working now. Thank you
06:25:21 <ski> (when writing the parser in monadic style, i usually rename `exprCont' to `return_' :)
06:25:30 <tdammers> np
06:26:02 * hackagebot murder 1.3.4 - MUtually Recursive Definitions Explicitly Represented  http://hackage.haskell.org/package/murder-1.3.4 (MarcosViera)
06:26:14 <bz> doesn't *> do the same as >>?
06:26:24 <ski> @type (*>)
06:26:25 <lambdabot> Applicative f => f a -> f b -> f b
06:26:25 <ski> @type (>>)
06:26:25 <bz> :t (>>)
06:26:26 <lambdabot> Monad m => m a -> m b -> m b
06:26:26 <lambdabot> Monad m => m a -> m b -> m b
06:26:36 <ski> basically the same, yes
06:26:36 <bz> in the scope of monads, that is
06:26:56 <bz> iirc monad hasn't yet C applicative
06:27:37 <quchen> Yes, *> = >> for sensible implementations of Applicative/Monad.
06:27:47 <quchen> Where sensible means "law-obedient".
06:28:05 <Eduard_Munteanu> ski: I'm using 'Free Attoparsec a' to define a 'Parser {Lexeme,Line} a' which operates on lexemes/lines . So I should be able to ask for a lexeme ("word") before recursing, perhaps?
06:28:34 <mangaba_leitosa> What's the approach to a problem with Haskell failing and reqesting to increase stack size? Make all functions tail recursive?
06:28:51 <mangaba_leitosa> (Instead of increasing stack size more and more as your data grow)
06:28:57 <Eduard_Munteanu> The lexeme parser operates on e.g. words, automatically skipping whitespace as needed.
06:29:17 <Eduard_Munteanu> mangaba_leitosa: sounds like a strictness issue
06:29:22 <quchen> mangaba_leitosa: Fix the space leak. This can be awkward to find though (looking for one myself right now) :-/
06:29:37 <Eduard_Munteanu> mangaba_leitosa: if it's for your word count, make sure you're using foldl', not plain foldl.
06:29:58 <mangaba_leitosa> Eduard_Munteanu: I do, and yet it wants more and more stack :-0
06:29:59 <Eduard_Munteanu> mangaba_leitosa: and make sure it's Data.Map.Strict
06:30:17 <mangaba_leitosa> Eduard_Munteanu: I think it is, but I'm going to double check
06:31:21 <Eduard_Munteanu> mangaba_leitosa: how do you increment the count / add to the map?
06:32:00 <ski> Eduard_Munteanu : `exprCont' should either return directly (`<epsilon>' case), or call something else which eventually eats some token before (perhaps) calling `exprP'
06:32:02 <mm_freak> cabal update says 403 forbidden
06:32:11 <mm_freak> any changes i've missed?
06:32:17 <dcoutts> mm_freak: your proxy?
06:32:22 <mangaba_leitosa> Eduard_Munteanu: I tried both my method 'times l = Map.toList (foldl' update_freq Map.empty l) where update_freq map elem = Map.insertWith (+) elem (1::Int) map' and the method you had proposed: times l = Map.toList . Map.fromListWith (+) . flip zip (repeat (1::Int)) $ l
06:32:56 <ski> and similarly fo~ `exprBase', except there's no `<epsilon>' case in the recipe above
06:33:13 <mm_freak> s/update/upload/
06:33:33 <Eduard_Munteanu> mangaba_leitosa: how do you use the result list? Try doing a "takeWhile (`seq` True)" on it before using it.
06:33:44 <ski> (it doesn't matter if `<non-left-rec-*>' or `<expr-rest-*>' calls `<expr>' after eating a token)
06:33:54 <donri> mm_freak: have you upgraded your account
06:34:02 <mm_freak> upgraded?
06:34:08 <donri> mm_freak: log in on the website
06:36:45 <mm_freak> donri: thanks
06:36:46 <mangaba_leitosa> Eduard_Munteanu: is it for forcing evaluation?
06:37:15 <mm_freak> netwire 5 is out =)
06:37:29 <Eduard_Munteanu> mangaba_leitosa: yeah
06:37:57 <mangaba_leitosa> Eduard_Munteanu: trying... :-)
06:38:05 <donri> mm_freak: hip hip horay!
06:38:18 <quchen> mangaba_leitosa: takeWhile (`seq` True) evaluates each list element to WHNF.
06:38:28 <ski> @yarr
06:38:28 <lambdabot> This is the END for you, you gutter-crawling cur!
06:41:05 * hackagebot netwire 5.0.0 - Functional reactive programming library  http://hackage.haskell.org/package/netwire-5.0.0 (ErtugrulSoeylemez)
06:43:47 <sopvop> oh god http://www.reddit.com/r/programming/comments/1qg5x8/whats_wrong_with_oop_and_fp/
06:43:50 <mangaba_leitosa> Eduard_Munteanu: what if I use foldr and there is no foldr' ?
06:43:52 <sopvop> oh sorry
06:43:55 <sopvop> wrong chan
06:44:08 <mangaba_leitosa> Eduard_Munteanu: should I replace it with reverse/foldl' instead?
06:44:10 <chrisdone> sopvop: get back to -blah!
06:44:20 <sopvop> I did
06:47:01 <Eduard_Munteanu> mangaba_leitosa: foldr isn't a good idea for (+)
06:47:42 <Eduard_Munteanu> @src foldr
06:47:42 <lambdabot> foldr f z []     = z
06:47:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:47:43 <mangaba_leitosa> Eduard_Munteanu: I now use (:) instead of (+)
06:48:00 <mangaba_leitosa> Eduard_Munteanu: because I need word positions, not just frequencies
06:48:07 <Eduard_Munteanu> mangaba_leitosa: oh, then yes, use foldr by all means :)
06:48:12 <mangaba_leitosa> Eduard_Munteanu: so, I add positions to the list
06:48:35 <mangaba_leitosa> Eduard_Munteanu: But there is no foldr' :-)
06:48:42 <Eduard_Munteanu> foldr is good for productive operations like building a list incrementally.
06:48:54 <Eduard_Munteanu> mangaba_leitosa: where are you using foldr?
06:49:05 <mangaba_leitosa> update_indices (index, elem) map = Map.insertWith (\[new] old -> new:old) elem [index] map
06:49:09 <mangaba_leitosa> kmersWithIndexGrouped k l = Map.toList . foldr update_indices Map.empty .  kmersWithIndex k $ l
06:49:34 <mangaba_leitosa> Eduard_Munteanu: kmers with Index returns a list of [(word, position)]
06:49:39 <Eduard_Munteanu> mangaba_leitosa: no, in that case you should use a lazy map and plain foldr
06:49:51 <mangaba_leitosa> Eduard_Munteanu: haha :-) ok, trying
06:50:38 <Eduard_Munteanu> mangaba_leitosa: if you want a count, the strict left fold is going to be... length :)
06:50:51 <Eduard_Munteanu> Well, length plus filter perhaps.
06:51:17 <Eduard_Munteanu> @src length
06:51:18 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:51:39 <Eduard_Munteanu> Should be foldl' (+ 1) 0 anyway
06:52:09 <enthropy> @src Map
06:52:09 <lambdabot> Source not found. Abort, Retry, Panic?
06:52:21 <Eduard_Munteanu> @src M.Map
06:52:21 <lambdabot> Source not found. Whoa.
06:52:23 <enthropy> it stores the size with itself
06:52:35 <Eduard_Munteanu> @src Data.Map.Map
06:52:35 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:52:35 <enthropy> no need to traverse, unless I'm misunderstanding something
06:52:51 <mangaba_leitosa> Eduard_Munteanu: where exactly am I supposed to do `seq True` in the kmersWithIndexGrouped functions above?
06:53:02 <Eduard_Munteanu> enthropy: he was previously doing a per-word count, not a total word count
06:53:19 <Eduard_Munteanu> mangaba_leitosa: you don't do that anymore
06:53:20 <mangaba_leitosa> Eduard_Munteanu: or before each function? :-)
06:53:40 <mangaba_leitosa> Eduard_Munteanu: OK, I changed the Map to Lazy
06:53:50 <Eduard_Munteanu> mangaba_leitosa: and foldr?
06:53:59 <mangaba_leitosa> Eduard_Munteanu: yes, foldr was already there. still getting stack overflow with default settings
06:54:31 <Eduard_Munteanu> mangaba_leitosa: do you have other strict / left folds in there?
06:56:07 <kqr> in the documentation for Text.Parsec.Combinator, in the example for `between', there's a reference to a "symbol" function which I can't seem to find. where's that located and what does it mean
06:56:57 <Eduard_Munteanu> kqr: probably Text.Parsec.Token
06:57:00 <ski> @hoogle symbol
06:57:01 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
06:57:01 <lambdabot> Text.ParserCombinators.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
06:57:01 <lambdabot> package symbol
06:57:12 <lpaste> mangaba_leitosa pasted “frequent_words2.hs” at http://lpaste.net/95560
06:57:15 <mangaba_leitosa> Eduard_Munteanu: no. Here is the minimal code sample for testing: ^
06:57:26 <khyperia> I think I just used seq for the first time as not an optimization edit.
06:57:27 <kqr> Eduard_Munteanu, ski: oh okay thanks
06:57:58 <infohigh> Why do || and && have right-associativity?
06:58:19 <mangaba_leitosa> Eduard_Munteanu: files on 'time (cat file.txt; echo 9) |./frequent_words2 kmersWithIndexGrouped' where file.txt contains a single line of 4,5M
06:58:21 <khyperia> I have a function that can throw an error, but I don't need the result of it - I just need to see if the error gets thrown or not. So, seq. Is that a proper use of seq?
06:58:28 <mangaba_leitosa> Eduard_Munteanu: "fails" even
06:58:30 <Eduard_Munteanu> infohigh: because you want shortcut evaluation for them
06:58:54 <mangaba_leitosa> Eduard_Munteanu: "file.txt contains a single line of 4,5MB"
06:58:55 <Eduard_Munteanu> infohigh: False && _ = False, True || _ = True
06:58:55 <tomejaguar> khyperia: Did you write the function?  If so, can't you use Either?
06:59:37 <Eduard_Munteanu> mangaba_leitosa: read (T.unpack b))::Int -- you should rethink this
06:59:41 <infohigh> Eduard_Munteanu: Am I confusing left- and right- associativity?  I see that going the opposite direction..
07:00:02 <mangaba_leitosa> Eduard_Munteanu: maybe, but that's now what's causing stack overflow :-0
07:00:12 <mangaba_leitosa> Eduard_Munteanu: "that's NOT what"
07:00:18 <infohigh> Eduard_Munteanu: but also does associativity even affect that?  I thought it was more for:  A && B && C  i.e. repeated side-by-side uses of the same operator.
07:00:20 <khyperia> Possibly. All the places I'd use it, I'd just have a case blah of Left -> error, so I think I'd rather jam that into the function itself.
07:00:43 <khyperia> I guess I can have two functions, one returning Either, one returning error on failure
07:01:25 <ski> @type either error id
07:01:26 <lambdabot> Either [Char] c -> c
07:02:14 <quicksilver> infohigh: it is. But by convention the short-circuit is on the left so you want the assoc to the right so the short circuit is useful.
07:02:19 <Eduard_Munteanu> infohigh: well, (&&) is associative in itself.
07:02:31 <Eduard_Munteanu> So arguably it doesn't matter mathematically.
07:02:41 <quicksilver> infohigh: if it was evaluated as (A && B) && C then you'd have to evaluate both A and B to get a short circuit.
07:02:53 <quicksilver> what I am saying is not true
07:02:54 <quicksilver> :)
07:02:58 <quicksilver> it really doesn't matter, in fact.
07:03:19 <ski> it's like `(a ++ b) ++ c'
07:03:27 <Eduard_Munteanu> I suspect you want liftM2 (&&) to work the same.
07:03:43 <ski> not for `liftM2'
07:03:51 <Philonous_> Are there interesting adjunctions in Haskell besides the ones given in Data.Functor.Adjunction ?
07:03:52 <Eduard_Munteanu> C-like semantics for shortcut.
07:03:59 <Narvius> Question: Why backquote content quote?
07:04:35 <mangaba_leitosa> Eduard_Munteanu: so, currently, this only works for a 3 MB file when I increase stack size to 64 MB :-(
07:04:37 <quicksilver> TeX habits, I imagine, that's how TeX does curly quotes.
07:04:50 <merijn> Narvius: LaTeX habit, likely :)
07:04:58 <merijn> Whoo! I guessed right!
07:05:13 <chrisdone> it's also how GHC quotes identifiers in its messages
07:05:18 <chrisdone> > foobar
07:05:19 <lambdabot>   Not in scope: `foobar'
07:05:27 <Eduard_Munteanu> mangaba_leitosa: try replacing the 'read (T.unpack b)' with an actual number. Also if it's a large number, you can't really use Int.
07:05:29 <merijn> chrisdone: I suspect GHC follows LaTeX too :p
07:05:34 <chrisdone> merijn: duh
07:05:43 <mangaba_leitosa> Eduard_Munteanu: no, the I use is '9'
07:05:46 <mangaba_leitosa> Eduard_Munteanu: no, the number I use is '9'
07:05:48 <chrisdone> but following *ghc* is probably nice to do in here
07:05:51 <infohigh> && being infixr implies to me that A && B && C will short-circuit on B first, which seems crazy.  I expect: A && (B && C) but then if the convention is to short-circuit the left side, B is checked first.
07:06:07 <mangaba_leitosa> Eduard_Munteanu: how could it help? :-)
07:06:10 <merijn> infohigh: no
07:06:21 <merijn> infohigh: Fixity only applies structure, not evaluation order
07:06:49 <merijn> infohigh: i.e. it specifies the grouping of arguments, not which argument the implementation of && looks at first, which is solely dependent on the implementation of &&
07:06:51 <quchen> > False && undefined && True -- infohigh
07:06:52 <lambdabot>   False
07:07:04 <Eduard_Munteanu> ski: why not liftM2?
07:07:10 <Eduard_Munteanu> :t liftM2 (&&)
07:07:11 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
07:07:22 <merijn> Eduard_Munteanu: Because that always executes side-effects
07:07:33 <Eduard_Munteanu> Oh, duh, I was just referring to the type.
07:07:36 <merijn> Eduard_Munteanu: It doesn't conditionally execute the second argument
07:07:46 <Eduard_Munteanu> Yeah, sure.
07:07:57 <mangaba_leitosa> Eduard_Munteanu: but anyway, I tried to replace 'read' with the number 9. Still getting stack overflow :-)
07:08:12 <tdammers> > False && undefined
07:08:13 <lambdabot>   False
07:08:18 <tdammers> > undefined && False
07:08:19 <lambdabot>   *Exception: Prelude.undefined
07:08:56 <merijn> infohigh: I think you're being confused by thinking that things within parens get evaluated first? Which isn't true, hence why "A && (B && C)" just evaluates A first, rather than B
07:09:22 <infohigh> Yep!  Thanks a bunch, that explains it.
07:09:52 <merijn> "A && (B && C)" -> inspect A, if true, then inspect "B && C", to inspect "B && C", inspect B, if true, inspect C
07:10:12 <infohigh> Perfect, that answers my next question.
07:10:21 <infohigh> Much appreciated, I get it now.
07:10:21 <dwcook> Is there or has there ever been a proposal for a way to explicitly pass typeclass constraints into a function instead of relying on such an instance that's in scope?
07:10:34 <Eduard_Munteanu> mangaba_leitosa: write type signatures for all those, might help
07:11:36 <mangaba_leitosa> Eduard_Munteanu: ok, trying
07:11:48 <dwcook> e.g., a way to effectively turn sort :: (Ord a) => [a] -> [a] into sort :: (a -> a -> Ordering) -> [a] -> [a]
07:11:57 <dwcook> Albeit automatically
07:12:22 <kqr> is it possible with parsec to state "i want three p1 separated by p2"? sepBy doesn't take a count, and "count" just repeats whatever it gets so i can't very well combine value + separator into a single parser, because it will expect a separator at the end as well
07:13:28 <merijn> kqr: I suspect it exists, but dunno what it's called. But even if it doesn't, it seems trivial to implement?
07:13:47 <kqr> yeah sure, i was just checking because i didn't find it with a quick search
07:13:47 <skypers_> hi
07:13:55 <skypers_> what is the use for Sequence?
07:14:06 <chrisdone> iirc sequence has super fast appending
07:14:06 <skypers_> I want to pass a queue of a to a function
07:14:27 <skypers_> I don’t know which is the best between Sequence and and DList
07:14:33 <skypers_> -and
07:14:46 <kqr> merijn, chain* looks like the ones i want
07:14:47 <skypers_> chrisdone: so does DList doesn’t it?
07:14:57 <chrisdone> dunno
07:15:01 <Eduard_Munteanu> kqr: you can use GADTs to define your own manual-resolution typeclasses, and wrap them into a proper typeclass, I think. Not sure what you want to automate though.
07:15:09 <kqr> or wait no, that doesn't take a count
07:15:20 <donri> skypers_: are we talking about Seq?
07:15:28 <Eduard_Munteanu> ski: Seq is fine for queues.
07:15:31 <skypers_> yes donri
07:15:35 <Eduard_Munteanu> Er.
07:15:42 <Eduard_Munteanu> skypers_: Seq is fine for queues.
07:15:43 <donri> skypers_: it has better complexity than lists for some operations
07:15:52 <donri> list is under appreciated though
07:15:54 <Eduard_Munteanu> It has efficient cons and snoc.
07:16:06 <donri> list has pretty much the best possible cons and uncons :)
07:16:07 <skypers_> donri: well I only need it as a function parameter
07:16:14 <skypers_> I’ll just deconstruct it
07:16:22 <donri> skypers_: sounds like list will be better then
07:16:31 <vijaykiran> why is Either a Functor ?
07:16:38 <Eduard_Munteanu> Er, another confusion...
07:16:42 <donri> vijaykiran: because it's a monad!
07:16:43 <skypers_> the user pass fromList [a,b,c,d], and I have to ensure each value will be taken as a, b, c, d and so on
07:16:45 <Eduard_Munteanu> dwcook: you can use GADTs to define your own manual-resolution typeclasses, and wrap them into a proper typeclass, I think. Not sure what you want to automate though.
07:16:49 <skypers_> hm
07:16:50 <skypers_> yeah
07:17:06 <chrisdone> would it hurt ghci to allow `where'?
07:17:12 <Taneb> For windowing and input stuff with OpenGL, what options do I have other than GLUT and GLFW?
07:17:18 <skypers_> SDL
07:17:19 <chrisdone> i.e. instead of assuming an expression, assume a RHS
07:17:27 <vijaykiran> donri: hmm okay - I haven't gotten that far. I'll wait until Monads appear and read
07:17:35 <ski> @type liftA2 either
07:17:36 <lambdabot> Applicative f => f (a -> c) -> f (b -> c) -> f (Either a b -> c)
07:17:37 <skypers_> Taneb: I use SDL in my Haskell 3D engine, it’s just nice
07:17:39 <ski> @type \iac ibc iab -> liftA2 either iac ibc <*> iab
07:17:40 <lambdabot> Applicative f => f (a -> b) -> f (b1 -> b) -> f (Either a b1) -> f b
07:17:44 <ski> @type \iac ibc iab -> either (\a -> liftM ($ a) iac) (\a -> liftM ($ a) ibc) =<< iab
07:17:45 <lambdabot> Monad m => m (a -> b) -> m (a1 -> b) -> m (Either a a1) -> m b
07:17:49 <Eduard_Munteanu> Taneb: also gtk2hs if you need a proper GUI
07:17:49 <merijn> vijaykiran: Well, why wouldn't Either be a Functor?
07:18:11 <skypers_> Eduard_Munteanu: is it convenient to use?
07:18:12 <ski> Eduard_Munteanu : there was some talk about `eitherA :: ApplicativeChoice i => i (a -> c) -> i (b -> c) -> i (Either a b) -> i c'
07:18:12 <merijn> vijaykiran: (To be pedantic "Either e" is a Functor, "Either" is not)
07:18:22 <skypers_> I may have the need for a “proper GUI”
07:18:33 <Eduard_Munteanu> ski: you mean someone else? :)
07:18:37 <lpaste> mangaba_leitosa revised “frequent_words2.hs”: “frequent_words2.hs” at http://lpaste.net/95560
07:18:47 <ski> Eduard_Munteanu : we want the behaviour of the `Monad' version above, without requiring the full power of `Monad'
07:18:51 <mangaba_leitosa> Eduard_Munteanu: I wrote type signatures. Still stack overflow (what I expected) :-)
07:18:52 <donri> vijaykiran: basically the Either functor lets you either modify the Right value, or keep the Left value. this is commonly used for error handling, as it's a bit like short-circuiting on Left
07:18:53 <Eduard_Munteanu> Well, arguably Either :: * -> (* -> *) should be a functor too, no? :)
07:19:01 <ski> <Eduard_Munteanu> ski: why not liftM2?
07:19:03 <dwcook> Eduard_Munteanu, the automatic part would be some way to supply "anonymous instances" in general, rather than manually writing conversions of functions from typeclassful to accepting functions in place of the methods.
07:19:05 <ski> <Eduard_Munteanu> :t liftM2 (&&)
07:19:08 <ski> <lambdabot> Monad m => m Bool -> m Bool -> m Bool
07:19:10 <Eduard_Munteanu> ski: oh, I see
07:19:11 <Taneb> Eduard_Munteanu: luckily for me I don't need a proper GUI (although I've used gtk2hs in the past and got on with it)
07:19:41 <vijaykiran> donri: thanks, that answers my question - what's the usage of Either being a Functor - but why "right" affinity ?
07:20:01 <vijaykiran> or .. why left is left alone and right is applied with the fmap's f
07:20:20 <donri> vijaykiran: is this a new question or are you clarifying your previous question? :)
07:20:38 <ski> @let class Applicative i => ApplicativeChoice i where eitherA :: i (a -> c) -> i (b -> c) -> i (Either a b) -> i c
07:20:40 <lambdabot>  Defined.
07:20:44 <chrisdone> hvr: huh, maybe we should make haskell-interactive-mode derive from haskell-mode so that we get syntax highlighting in the repl?
07:20:55 <chrisdone> hvr: and nice editing facilities =]
07:21:01 <donri> vijaykiran: also, this is, i think, the only possible (law-abiding) Functor instance for Either
07:21:22 <donri> (i read this is always the case with Functor, anyway)
07:21:22 <Eduard_Munteanu> dwcook: something like  class Instance (c :: Constraint) where { type GADT c :: *; getInstance :: GADT c }  might work
07:21:52 <quchen> vijaykiran: I think it's important to stress here that Either is no a Functor, but (Either a) is for all a. You can't use the "a" in the Functor instance for this reason, hence you can't modify Lefts.
07:22:01 <donri> yeah
07:22:05 <vijaykiran> donri: my "why is Either a is a Functor " is answered :) (error handling etc..)
07:22:06 <dwcook> Eduard_Munteanu, hmm, thanks, I'll play with that.
07:22:13 <donri> vijaykiran: cool
07:22:25 <merijn> vijaykiran: Because "fmap :: Functor f => (a -> b) -> f a -> f b", so we can make "Either e" a functor, (let's replace f with that) "fmap :: (a -> b) -> Either e a -> Either e b"
07:22:41 <quchen> The answer to "why doesn't fmap map over Left instead of Right" is because the type system won't allow that :-(
07:22:46 <merijn> vijaykiran: Functor doesn't have an interface for changing anything other than the "last" type mentioned in a parametric datatype
07:22:53 <ski> @type \iConj0 iConj1 -> eitherA (pure (const False)) (fmap const iConj1) (fmap (\b -> if b then Right () else Left ()) iConj0)
07:22:53 <lambdabot> ApplicativeChoice i => i Bool -> i Bool -> i Bool
07:22:58 <ski> Eduard_Munteanu : something like that
07:23:38 <enthropy> chrisdone: there's http://www.haskell.org/ghc/docs/7.6.3/html/libraries/ghc-7.6.3/Outputable.html#v:coloured which seems not to be used in ghci
07:24:06 <Eduard_Munteanu> dwcook: using it like  sort :: (Instance (Ord a)) => [a] -> [a]  sort = let (MkOrd cmp) = getInstance :: GADT (Ord a) in sortBy cmp
07:24:16 <donri> enthropy: wait, what is this? ghc can do color output? for what?
07:24:33 <ski> @instance ApplicativeChoice ((->) rho) where eitherA = liftA3 either
07:24:33 <lambdabot> Maybe you meant: instances instances-importing
07:24:33 <vijaykiran> merijn: the last type in the prev. example is a or b -- but not e.. right ?
07:24:37 <ski> @let instance ApplicativeChoice ((->) rho) where eitherA = liftA3 either
07:24:38 <lambdabot>  Defined.
07:24:43 <enthropy> don't know. There's something in the ghc-api about colours
07:24:52 <donri> heh
07:25:27 <merijn> vijaykiran: Correct, because Functor only deals with types that take one type argument (which includes partially applied types, like "Either e")
07:25:28 <ParahSail1n> @src Either ArrowChoice
07:25:29 <lambdabot> Source not found. :(
07:25:32 <Eduard_Munteanu> ski: basically a lattice for applicatives perhaps, more generally?
07:25:40 <donri> @src Either (|||)
07:25:40 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:25:42 <vijaykiran> merijn: thanks!
07:26:12 * vijaykiran feels vague sense of achievement of understanding something 
07:26:15 <merijn> vijaykiran: Incidentally, there is also the idea of a bifunctor (not in the standard libraries, but well known) which has "bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a c -> f b d"
07:26:24 <ski> @let instance ApplicativeChoice ((,) omega) where eitherA ~(o0,ac) ~(o1,bc) (o,ab) = either ((,) o0 . ac) ((,) o1 . bc) ab
07:26:25 <lambdabot>  .L.hs:168:10:
07:26:25 <lambdabot>      No instance for (Monoid omega)
07:26:25 <lambdabot>        arising from the su...
07:26:35 <ski> @let instance Monoid omega => ApplicativeChoice ((,) omega) where eitherA ~(o0,ac) ~(o1,bc) (o,ab) = either ((,) o0 . ac) ((,) o1 . bc) ab
07:26:36 <lambdabot>  Defined.
07:27:14 <ParahSail1n> @hoogle ApplicativeChoice
07:27:15 <lambdabot> No results found
07:27:30 <vijaykiran> merijn: noted. I'll keep that after I've understood a bit more of uno-functors
07:27:31 <merijn> vijaykiran: Which clearly would let you touch the left side too, it usually also has "lmap :: Bifunctor f => (a -> b) -> f a e -> f b e" and "rmap :: Bifunctor f => (a -> b) -> f e a -> f e b" (rmap being pretty much the same as fmap)
07:28:22 <khyperia> I saw someone use something called "Expr" before... I want to figure out what this reduces to, how do I do it? > let dot = (.).(.) in (f `dot` g) x y
07:28:51 <merijn> vijaykiran: As a (mildly confusing, but somewhat enlightening) exercise, try figuring out how functions (i.e. "(->) a" or (not valid syntax) "(a->)") is a Functor
07:28:52 <PudgePacket> Are there any Haskell lectures/talks that are renowned within the community as giving an insight into the language by professionals/haskell devs?
07:29:01 <merijn> vijaykiran: If you get stuck, try substituting/expanding types on paper
07:29:53 <quchen> PudgePacket: Sure, many of them. The most recent ones are the ones by SPJ on Lens and by Löh on free monads I think.
07:30:29 <vijaykiran> merijn: I still need go get used to the duality of thinking 1 (about logic of my program) + thinking 2 (about the types)
07:30:44 * vijaykiran only dabbled in Clojure a bit before starting on Haskell
07:30:48 <ski> @let maybeA :: ApplicativeChoice i => i r -> i (a -> r) -> i (Maybe a) -> i r; maybeA iNothing iJust iMaybe = eitherA (fmap (\r () -> r) iNothing) iJust (fmap (maybe (Left ()) Right) iMaybe)
07:30:49 <lambdabot>  Defined.
07:31:06 <ParahSail1n> where is ApplicativeChoice
07:31:28 <ParahSail1n> @src ApplicativeChoice
07:31:28 <lambdabot> Source not found. You speak an infinite deal of nothing.
07:31:34 <merijn> vijaykiran: I strongly recommend fully writing out types and manually substituting/inferring on paper until you get comfortable enough to do it in your head
07:31:51 <vijaykiran> merijn: sure, I'll do.
07:32:11 <merijn> vijaykiran: I also think it helps to specify programs by just writing down function names and types and composing these unimplemented functions to see if everything typechecks before starting to implement
07:32:36 <ski> @let andA2 :: ApplicativeChoice i => i Bool -> i Bool -> i Bool; andA2 iConj0 iConj1 = maybeA iConj1 (pure id) (fmap (\b -> if b then Nothing else Right b) iConj0)
07:32:37 <lambdabot>  .L.hs:178:44:
07:32:37 <lambdabot>      Couldn't match expected type `Maybe Bool'
07:32:37 <lambdabot>                ...
07:32:43 <merijn> vijaykiran: I'll usually start with datatypes and writing like 10 functions of "foo :: ...; foo = undefined" and only later bother to figure out how to implement them ;)
07:32:45 <vijaykiran> merijn: can I compile without writing the definitions of the functions?
07:32:52 <vijaykiran> merijn: :) ah, undefined
07:33:06 <ski> @let andA2 :: ApplicativeChoice i => i Bool -> i Bool -> i Bool; andA2 iConj0 iConj1 = maybeA iConj1 (pure id) (fmap (\b -> if b then Nothing else Just b) iConj0)
07:33:07 <lambdabot>  Defined.
07:33:09 <merijn> vijaykiran: It's your friend :)
07:33:22 <mr-> vijaykiran: The slogan is: If you don't know the type of your function, you don't know what you want to write anyway :-)
07:33:26 <mangaba_leitosa> Eduard_Munteanu: I wont it replacing my foldr with your Map.insertWith you had proposed before
07:33:33 <mangaba_leitosa> Eduard_Munteanu: "I won it" even
07:33:37 <mangaba_leitosa> Eduard_Munteanu: but why?...
07:33:49 <ski> @let orA2 :: ApplicativeChoice i => i Bool -> i Bool -> i Bool; orA2 iConj0 iConj1 = maybeA iConj1 (pure id) (fmap (\b -> if b then Just b else Nothing) iConj0)
07:33:51 <lambdabot>  Defined.
07:33:51 <mangaba_leitosa> Eduard_Munteanu: no stack overflow anymore
07:33:56 <vijaykiran> mr-: clearly, I didn't know what I was writing in Clojure/Lisp :P
07:34:03 <mr-> clearly :-)
07:34:10 <Eduard_Munteanu> mangaba_leitosa: hm... insertWith might be unnecessarily strict perhaps
07:34:17 <vijaykiran> merijn, mr-: thanks for the pointers - I'll keep reading!
07:34:46 <ski> @let andA :: ApplicativeChoice i => [i Bool] -> i Bool; andA = foldr andA2 (pure True)
07:34:47 <lambdabot>  Defined.
07:35:00 <ski> @let orA :: ApplicativeChoice i => [i Bool] -> i Bool; orA = foldr orA2 (pure False)
07:35:02 <lambdabot>  Defined.
07:35:02 <mangaba_leitosa> Eduard_Munteanu: so, I replaced this: kmersWithIndexGrouped k l = Map.toList . foldr update_indices Map.empty . takeWhile (`seq` True) . kmersWithIndex k $ l
07:35:11 <mangaba_leitosa> Eduard_Munteanu: with this: kmersWithIndexGrouped k l = Map.toList . Map.fromListWith ((++)) . map (\(a, b) -> (b, [a])). kmersWithIndex k $ l
07:36:18 <merijn> vijaykiran: Alternatively, if you worry about forgetting an undefined somewhere, you can use error + a string describing where it is
07:36:21 <merijn> :t error
07:36:22 <lambdabot> [Char] -> a
07:36:30 <merijn> > error "whoops!" + 1
07:36:32 <lambdabot>   *Exception: whoops!
07:38:06 <vijaykiran> that looks cleaner
07:38:41 <enthropy> > let undefined = 1 in undefined + undefined
07:38:42 <lambdabot>   2
07:39:08 <enthropy> thankfully nobody shadows undefined
07:39:19 <Eduard_Munteanu> dwcook: another option would be to wrap a Constraint in a GADT, that should do too
07:39:30 <tdammers> #define TRUE 0
07:39:42 <Eduard_Munteanu> enthropy: really?
07:39:45 <eikke> vijaykiran, merijn: there's also file-location: http://hackage.haskell.org/package/file-location-0.4.5.2/docs/FileLocation.html
07:40:02 <enthropy> well my sample isn't exhaustive
07:40:05 <Eduard_Munteanu> enthropy: I remember seeing undefined defined in BasicPrelude explicitly :/
07:40:33 <enthropy> sure, so they could add a warning to uses of it
07:40:40 <Eduard_Munteanu> Oh, heh.
07:40:51 <enthropy> but I don't think they change the meaning of it
07:40:51 <Eduard_Munteanu> enthropy: btw, did you have another nickname before this?
07:40:58 <enthropy> aavogt
07:41:05 <Eduard_Munteanu> Oh.
07:41:22 * Eduard_Munteanu merges identities
07:43:38 <chrisdone> hmmm
07:43:54 <vijaykiran> eikke: cool - thanks
07:52:31 <mm_freak> finally updated the netwire wiki page
07:52:39 <zgredzik> hello, I've just set up my own hackage server, can anyone tell me how can I remove an uploaded package?
07:53:12 <zgredzik> and if there is a possibility to log out of an account? :D (can't relog from admin to any other user to test their privileges)
08:06:47 <Boreeas> Is there a way to zip while including a default element if only list is empty? e.g. zipping [1, 2] and [1, 2, 3, 4] to [(1, 1), (2, 2), (0, 3), (0, 4)]
08:07:30 <haasn> Boreeas: zip [0..4
08:07:33 <haasn> err
08:07:33 <ski> if you know one list isn't longer than the other, then it's easy
08:07:43 <haasn> zip ([1,2] ++ repeat 0) [0..4]
08:07:53 <haasn> but also what ski said
08:08:28 <donri> @wiki Netwire
08:08:28 <lambdabot> http://www.haskell.org/haskellwiki/Netwire
08:08:34 <Boreeas> I need to know which list is longer for that though
08:11:51 <enthropy> @type \x y -> takeWhile (isJust . uncurry mplus) $ zip (x ++ repeat Nothing) (y ++ repeat Nothing)
08:11:52 <lambdabot> [Maybe a] -> [Maybe a] -> [(Maybe a, Maybe a)]
08:12:03 <enthropy> @type \x y -> takeWhile (isJust . uncurry mplus) $ zip (map Just x ++ repeat Nothing) (map Just y ++ repeat Nothing)
08:12:04 <lambdabot> [a] -> [a] -> [(Maybe a, Maybe a)]
08:12:49 <merijn> Boreeas: You could implement your own zip with this behaviour, but I don't believe it exists
08:12:55 <Boreeas> Yeah, I just did
08:13:00 <Boreeas> easier that way
08:13:04 <enthropy> hmm, that should be [a] -> [b] -> ..
08:13:14 <enthropy> @type mplus
08:13:15 <lambdabot> MonadPlus m => m a -> m a -> m a
08:14:32 <merijn> enthropy: Should be able to dedup that code with "on" :p
08:15:07 <merijn> :t zip `on` (++ repeat Nothing) . map Just
08:15:08 <lambdabot> [a] -> [a] -> [(Maybe a, Maybe a)]
08:15:19 <enthropy> and the type is again not general enough
08:15:25 <enthropy> as it could be
08:15:40 <merijn> ah, yeah
08:15:53 <enthropy> @type \x y -> takeWhile (\(a,b) -> isJust a || isJust b) $ zip (map Just x ++ repeat Nothing) (map Just y ++ repeat Nothing)
08:15:55 <lambdabot> [a] -> [a1] -> [(Maybe a, Maybe a1)]
08:25:42 <haasn> :t has (_Just `beside` _Just)
08:25:43 <lambdabot> (Maybe b, Maybe b) -> Bool
08:26:04 <haasn> :t is -- do we have this here?
08:26:05 <lambdabot>     Not in scope: `is'
08:26:05 <lambdabot>     Perhaps you meant one of these:
08:26:05 <lambdabot>       `id' (imported from Data.Function),
08:27:19 <lpaste> ibotty pasted “zipDefault” at http://lpaste.net/95562
08:27:21 <ibotty> now that you are talking about it for so long: is it worth it using the closed form though? i mean have a look at this paste (i don't know how multi-line expressions work in lambdabot):
08:27:29 <ibotty> ^
08:28:13 <ibotty> (of course lenses are always great)
08:28:14 <ski> > let sub a0 as bs = ((as ++) . map fromJust . dropWhile isNothing) (zipWith const (zipWith (\_ _ -> Nothing) as bs ++ repeat (Just a0)) bs); zipWithDefault a0 b0 f as bs = zipWith f (sub a0 as bs) (sub b0 bs as) in zipWithDefault '!' '?' (\x y -> [x,y]) "ab" "cdefgh"
08:28:15 <lambdabot>   ["ac","bd","!e","!f","!g","!h"]
08:28:18 <ski> > let sub a0 as bs = ((as ++) . map fromJust . dropWhile isNothing) (zipWith const (zipWith (\_ _ -> Nothing) as bs ++ repeat (Just a0)) bs); zipWithDefault a0 b0 f as bs = zipWith f (sub a0 as bs) (sub b0 bs as) in zipWithDefault '!' '?' (\x y -> [x,y]) "abcd" "efgh"
08:28:19 <lambdabot>   ["ae","bf","cg","dh"]
08:28:22 <ski> > let sub a0 as bs = ((as ++) . map fromJust . dropWhile isNothing) (zipWith const (zipWith (\_ _ -> Nothing) as bs ++ repeat (Just a0)) bs); zipWithDefault a0 b0 f as bs = zipWith f (sub a0 as bs) (sub b0 bs as) in zipWithDefault '!' '?' (\x y -> [x,y]) "abcd" "efgh"
08:28:23 <lambdabot>   ["ae","bf","cg","dh"]
08:28:26 <ski> > let sub a0 as bs = ((as ++) . map fromJust . dropWhile isNothing) (zipWith const (zipWith (\_ _ -> Nothing) as bs ++ repeat (Just a0)) bs); zipWithDefault a0 b0 f as bs = zipWith f (sub a0 as bs) (sub b0 bs as) in zipWithDefault '!' '?' (\x y -> [x,y]) "abcde" "fgh"
08:28:27 <lambdabot>   ["af","bg","ch","d?","e?"]
08:28:37 <ski> a bit ugly ..
08:30:41 <ski> @tell enthropy see <http://tunes.org/~nef/logs/haskell/13.11.12> for one variant
08:30:41 <lambdabot> Consider it noted.
08:30:47 <ski> Boreeas ^
08:31:06 <mangaba_leitosa> When I do :l "file.hs" in ghci, ghci's behaviour seems to differ depending on whether file.hs had been compiled with 'ghc' and file.hi & file.o exist. Specifically, ghci fails to see 'import' statements done in file.hs if file.hi and file.o exist. When I delete them, everything is back to normal. Why is that?
08:31:54 <zgredzik> does anyone know how to remove a package that I've uploaded to a hackage server I've set up on my local machine?
08:31:55 <ski> (probably a direct recursive solution is nicer, as Boreeas said they did)
08:32:02 <mangaba_leitosa> for example, in my file.hs, I have 'import qualified Data.Map.Strict as Map'. But ghci cannot do 'Map.fromList' after :l "file.hs" if file.hi and file.o exist
08:32:23 <geekosaur> mangaba_leitosa, for a compiled module only exported stuff is available
08:32:29 <Feuerbach> try :l *file.hs
08:32:36 <geekosaur> you can usually prepend a * to a module/file to force interpretation
08:32:41 <geekosaur> then everything should be available
08:33:18 <mangaba_leitosa> geekosaur, Feuerbach: thanks!! didn't know about '*'
08:50:17 <SwineFlu> I want to take a list [f0, f1, f2] and return something like (f0, (f1 (f2)))
08:50:22 <SwineFlu> would this be a fold?
08:50:31 <Eduard_Munteanu> SwineFlu: no
08:51:10 <bergmark> if you mean (f0 (f1 (f2 x))) then yes
08:51:11 <Eduard_Munteanu> SwineFlu: \[f0, f1, f2] -> (f0, (f1, f2))
08:51:23 <byorgey> SwineFlu: why do you want to do that? i.e. what is your higher-level goal?
08:51:24 * hackagebot progressive 0.1.0.0 - Multilabel classification model which learns sequentially (online).  http://hackage.haskell.org/package/progressive-0.1.0.0 (GrzegorzChrupala)
08:52:13 <SwineFlu> I'm going to do "or f0 (of (f1 f2)"
08:52:20 <SwineFlu> to get the disjuction for DNF
08:52:25 <Eduard_Munteanu> SwineFlu: parse error again :)
08:52:42 <SwineFlu> ) :p
08:53:19 <SwineFlu> I think I'll just use list recursion
08:53:25 <moops> how do i get cabal to delete a package? i think i have two conflicting bifunctors
08:53:36 <donri> moops: ghc-pkg unregister
08:53:37 <Eduard_Munteanu> SwineFlu: not sure what you mean
08:53:58 <Eduard_Munteanu> DNF yes, but I can't see how it fits into your thing.
08:56:02 <moops> weird. it had me run recache first, and then the compile error went away
08:56:15 <moops> wish i knew what happened
08:56:24 * hackagebot progressive 0.1.0.1 - Multilabel classification model which learns sequentially (online).  http://hackage.haskell.org/package/progressive-0.1.0.1 (GrzegorzChrupala)
08:56:52 <Sculptor> helllo
08:57:30 <shiona_> anyone know anything about this today: http://lpaste.net/95497?
08:57:36 <byorgey> SwineFlu: foldr or True ?
08:57:43 <shiona_> sorry about the extra question mark. http://lpaste.net/95497
08:58:40 <byorgey> shiona_: are you using some strange non-standard build/port of GHC?
08:58:54 <shiona_> debian testing ghc
08:59:02 <donri> shiona_: what arch?
08:59:12 <shiona_> I guess arm
08:59:17 <shiona_> rasp
08:59:17 <donri> TH doesn't work on ARM IIRC
08:59:44 <shiona_> ah, that explains it. I assume that means there is no way of handling this then
09:00:27 <donri> well maybe with something like zeroth, but it'll take some work
09:00:46 <shiona_> well, maybe I'll take a look if I happen to have time and get bored
09:00:49 <shiona_> thanks
09:01:00 <donri> i very vaguely feel i read ARM is properly supported in 7.8 though, but i'm really not sure
09:01:04 <ryantrinkle> does anyone have an intuition for what coexponentials mean?
09:03:03 <quicksilver> donri: "properly supported" but still not TH
09:03:05 <quicksilver> I think.
09:03:14 <quicksilver> TH requires the bytecode interpreter.
09:03:14 <donri> oh ok
09:03:17 <donri> yeah
09:03:23 <quicksilver> so presumably no ghci either
09:04:36 <Bet> I can't install any package with cabal. I reinstall haskell platform, but it did not help me
09:08:30 <robstewartuk> Itching to understand how to generate type level representation of a value level natural number with `dec2TypeLevel` http://hackage.haskell.org/package/type-level-0.2.4/docs/Data-TypeLevel-Num-Aliases-TH.html#v:dec2TypeLevel
09:08:43 * robstewartuk not familiar with TH splicing.. help?
09:10:09 <Eduard_Munteanu> robstewartuk: you should be able to write  type Three = $(dec2TypeLevel 3)
09:10:26 * robstewartuk tries
09:11:49 <Eduard_Munteanu> "However, type-splicing is not yet supported by template haskell." -- not sure what it means
09:12:01 <mm_freak> i've updated the FRP page in the haskellwiki:  http://www.haskell.org/haskellwiki/Functional_Reactive_Programming#Introduction
09:12:10 <mm_freak> now working on the 'events' section…  feedback welcome!
09:12:13 <glguy> type splicing is when you apply the $ operation to a TypeQ
09:12:13 <Eduard_Munteanu> robstewartuk: if that doesn't work try genAliases
09:12:32 <glguy> f :: $t -> Int
09:12:51 <identity> accelerate's documentation is fucking terrible
09:12:52 <identity> -_-
09:12:59 <Eduard_Munteanu> robstewartuk: genAliases' source documents those params
09:13:29 <robstewartuk> Your first suggestion results in "Cycle in type synonym declarations"
09:14:13 <byorgey> Bet: do you get an error message?
09:14:25 <robstewartuk> Eduard_Munteanu: ^^
09:17:56 <lpaste> Bet pasted “cabal install” at http://lpaste.net/95564
09:18:13 <Eduard_Munteanu> robstewartuk: try $(tySynD (mkName "Three") [] (dec2TypeLevel 3)) as a toplevel thing, on its own line
09:19:20 <Bet> byorgey: Haskell platform installs successfully. When I tried install cabal install or another package I get error
09:21:03 <robstewartuk> Eduard_Munteanu: yes, same error.
09:21:17 <robstewartuk> With ghc 7.6.3.
09:21:33 <Eduard_Munteanu> Weird... maybe it uses Three as a name?
09:21:42 <Eduard_Munteanu> robstewartuk: try Foo instead of Three
09:23:02 <robstewartuk> Cycle in type synonym declarations:
09:23:02 <robstewartuk>       Blah.hs:80:1-58: type Foo = $(tySynD (mkName "Three") [] (dec2TypeLevel 3))
09:23:58 <robstewartuk> Eduard_Munteanu: which ghc are you using? HEAD or ghc <= 7.6.3 ?
09:24:15 <Eduard_Munteanu> robstewartuk: I wasn't, lemme try it myself before further advice :D
09:24:27 <robstewartuk> Eduard_Munteanu: :-)
09:24:30 <test603> hi could anyone help me with this problem and put me on track i would be very thankfull :) http://pastebin.com/LDMewEaK
09:24:34 <mauke> The paste LDMewEaK has been copied to http://lpaste.net/95565
09:25:58 <Eduard_Munteanu> robstewartuk: hm, that's a 3rd party lib it seems, I don't have it installed.
09:26:27 <robstewartuk> It's type-level
09:26:32 <Eduard_Munteanu> robstewartuk: can you run GHC with -ddump-splices and pastebin the result?
09:26:40 <robstewartuk> Eduard_Munteanu: sure.
09:27:18 <Eduard_Munteanu> robstewartuk: why aren't you using the native type-level naturals, btw?
09:27:30 <Eduard_Munteanu> They're available in 7.6.3
09:27:35 <robstewartuk> Because I want a value beyond 5000
09:27:39 <robstewartuk> Oh..
09:27:48 <robstewartuk> Link?
09:28:04 <Eduard_Munteanu> robstewartuk: http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html
09:28:40 <Eduard_Munteanu> robstewartuk: https://ghc.haskell.org/trac/ghc/wiki/TypeNats/Basics
09:29:34 <Eduard_Munteanu> I initially thought that was some main TH function that generated new literals.
09:31:03 <Kinnison> win 26
09:33:23 <osa1_> hi all. I have some FFI bindings and some high-level mappings for that bindings. in that high-level interface, lots of Int -> CInt and similar conversations are happening, I was wondering whether these conversations cause performance problems of not. what's happening under the hood when enumFromTo is applied to that type? (e.g. Int -> CInt)
09:34:41 <Eduard_Munteanu> I suspect it's implemented as primops, basically C-ish type casts.
09:35:46 <Eduard_Munteanu> But if you have to pass in CInt, you should try working with them more directly.
09:35:49 <osa1_> but there should be at least some function calls, right?
09:36:03 <Eduard_Munteanu> Not quite.
09:36:07 <osa1_> Eduard_Munteanu: well, I have to pass CInt to FFI
09:36:30 <osa1_> Eduard_Munteanu: what's happening then? does GHC eliminate function calls under the hood?
09:37:17 <Eduard_Munteanu> It can inline for example, but I'm not saying that's what happens.
09:38:08 <test603> Hi, im learning Haskell and i can't solve this problem. Can anyone help with this give some exaples or something.Thank you. http://lpaste.net/95565
09:38:36 <osa1_> Eduard_Munteanu: does STG/Core outputs help to see what happens?
09:38:39 <osa1_> in that case
09:39:22 <Eduard_Munteanu> osa1_: yeah, try ghc-core
09:40:47 <Eduard_Munteanu> osa1_: looks like CInt is a newtype wrapper over Int8.
09:41:00 <osa1_> it should be Int32
09:41:05 <Eduard_Munteanu> Er.
09:41:11 <Eduard_Munteanu> I was looking at CChar, sorry.
09:41:56 <Eduard_Munteanu> osa1_: anyway, fromIntegral or other conversions would actually apply to Int32. And those can be implemented in terms of primops.
09:42:01 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
09:42:40 <Eduard_Munteanu> Those work on the actual unboxed integer types and some of them are straight casts.
09:43:56 <Eduard_Munteanu> GHC could generate code in-place for primops, many of those don't really make sense as regular functions.
09:46:32 * hackagebot highlight-versions 0.1.3.3 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.3.3 (BrentYorgey)
09:47:46 <osa1_> Eduard_Munteanu: interesting. I don't understand what's happening but I replaced 3 (toEnum . fromEnum) calls with fromIntegral and core output changed from {terms: 875, types: 849, coercions: 95} to {terms: 634, types: 648, coercions: 91} and diff file is very big
09:48:27 <Eduard_Munteanu> osa1_: oh, yeah, fromIntegral is what you want
09:48:50 <osa1_> I'll try to understand core output
09:49:02 <osa1_> (just realized some part of the diff file is actually stg output)
09:50:41 <osa1_> uh, there is also assembly
09:56:17 <zoggg> anyone want to buy a 4gb ram stick?
09:56:23 <zoggg> its brand new never been opened
09:56:25 <zoggg> i have no need for it
09:59:03 <osa1_> how to pass ghc optimization parameters to ghc-core?
10:00:51 <pavonia> Is there a very basic symbolic calaculation library for Haskell? I only need it to be able to simplify expression made of variables, +, -, *, /, and ^.
10:01:26 <lpaste> amf pasted “No title” at http://lpaste.net/89722901900558336
10:01:32 <khyperia> how do I Double -> Float?
10:02:35 <pavonia> :t realToFrac  -- khyperia
10:02:39 <lambdabot> (Fractional b, Real a) => a -> b
10:02:44 <khyperia> awesome
10:03:21 <khyperia> someone might want to update http://www.haskell.org/haskellwiki/Converting_numbers since it only includes GHC.Float as the only way to do that
10:03:30 <amf> in my paste above, what is the correct synta for writing a function that that takes a string, builds and returns a record
10:03:50 <pavonia> amf: You can't use let like this unless you are in a do-block. The expression syntax for let is "let<bindings> in <expression>"
10:04:27 <carado> hi everyone
10:04:34 <pavonia> amf: or you can use "where": buildRecord z = r where r = ...
10:04:36 <Eduard_Munteanu> carado: hi
10:04:51 <carado> http://paste.awesom.eu/fO9&ln could someone please explain to me why this doesn't work ?
10:05:20 <osa1_> so I don't understand core output but this page says in GHC http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html int is either 32bits or 64bits depending on architecture. I think CInt also same(32 bits on 32bit systems)
10:05:33 <osa1_> not sure if that means fromIntegral :: Int -> CInt is fast though
10:05:38 <Eduard_Munteanu> carado: f returns something that contains an 's'
10:06:08 <Eduard_Munteanu> carado: you can't pull those out of ST
10:06:13 <bz> > (1,2) < (3,4)
10:06:14 <lambdabot>   True
10:06:21 <bz> > (1,5) < (3,4)
10:06:23 <lambdabot>   True
10:06:45 <carado> > (1,undefined) < (2,undefined)
10:06:47 <lambdabot>   True
10:06:53 <khyperia> How difficult would it be to go from Double to one of http://bscarlet.github.io/llvm-general/3.3.8.2/doc/html/llvm-general-pure/LLVM-General-AST-Float.html (in particular, Half and Quadruple)
10:06:54 <bz> awesome
10:07:02 <Eduard_Munteanu> carado: also 'undefined' is irrelevant, Haskell only looks at the type and sees an 's' occuring in the result
10:07:24 <carado> I just used undefined as a dummy here
10:07:47 <carado> how can I have a my tree-reference-ish structure without returning anything of s ?
10:08:14 <Eduard_Munteanu> carado: in that case your entire tree lives in ST
10:08:57 <Eduard_Munteanu> carado: to be more precise, it's not f's fault... it's the caller running runST on a ST s (<something containing an s>)
10:09:49 <Eduard_Munteanu> For instance, you could convert that tree to a normal tree and get that one out with runST.
10:10:59 <carado> I see
10:11:02 <carado> thank you
10:12:02 <bennofs> Does 'data T f i v a = T ((i -> f v) -> f a)' have a monad instance in some package?
10:12:13 <bennofs> (for a Monad f)?
10:13:00 <Eduard_Munteanu> @src ContT
10:13:00 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
10:14:11 <bennofs> That's not the same. I'd like 'return = T . return . return' and 'T a >>= f = T $ \h -> a >=> ($ h) . unT . f'
10:14:51 <Eduard_Munteanu> I know, I was thinking maybe an indexed cont made sense.
10:15:24 <Eduard_Munteanu> http://hackage.haskell.org/package/indexed-extras-0.1.1/docs/Control-Monad-Indexed-Cont.html
10:15:39 <Eduard_Munteanu> bennofs: (a -> m o) -> m r
10:15:42 <Eduard_Munteanu> ^
10:16:35 <Eduard_Munteanu> Though the inputs and outputs are the wrong way around.
10:16:49 <Eduard_Munteanu> bennofs: what is it supposed to do, I'm curious?
10:17:17 <cschneid> Eduard_Munteanu: what's an indexed functor?
10:17:32 <Eduard_Munteanu> cschneid: a functor between indexed categories, AFAIK
10:17:55 <cschneid> indexed doesn't have much special meaning right? Just that it has "1", "2", "3" positions like a list or array may?
10:18:25 <Eduard_Munteanu> cschneid: and indexed categories are basically diagrams, i.e. functors I -> C for an index category I and base category C.
10:19:13 <cschneid> ok, I'm sure that means something :) I've gotta get a better grasp on some of these core words in haskell. "category" for instance is something I see, but don't really grok yet. Is there a good glossary somewhere with links to read up on words I run across
10:19:16 <Eduard_Munteanu> cschneid: it's not like that, it's index in the sense you don't care about the actual objects as long as the index category has a certain shape
10:20:07 <cschneid> ahh, ok.
10:20:11 <Eduard_Munteanu> cschneid: are you familiar with limits in CT?
10:20:16 <cschneid> nope.
10:20:25 <ocharles> Does anyone know if Roman Cheplyaka hangs out here?
10:21:38 * hackagebot vinyl 0.2 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.2 (JonSterling)
10:22:07 <Eduard_Munteanu> cschneid: the notion of indexed category is a bit like indexed sets, that is, functions from an index set I to an actual set A.
10:22:44 <bergmark> ocharles: sometimes
10:22:53 <cschneid> so it's vaguely similar to "foldable" where you say how to access the inner shape, without actually caring about what's there - except a different angle on the idea.
10:22:54 <bergmark> ocharles: Feuerbach
10:22:55 <cschneid> ?
10:23:46 <bennofs> preflex: xseen Feuerbach
10:23:46 <preflex>  Feuerbach was last seen on freenode/#haskell 1 hour, 51 minutes and 14 seconds ago, saying: try :l *file.hs
10:24:09 <Eduard_Munteanu> cschneid: for example Bool -> A can be thought of as partitioning the set A into A_false and A_true. We can call A an indexed set and refer to its parts by those names.
10:24:15 <ocharles> bergmark: ah awesome
10:24:19 <ocharles> I've tweeted him for now
10:24:44 <cschneid> Eduard_Munteanu: cool. I suppose thats enough for the moment - I'll stop asking questions and continue reading / learning more before looping back.
10:26:13 <zol> If I have
10:26:20 <Eduard_Munteanu> cschneid: mm, not quite like that, but indexed categories are related to universal objects in categories. You can formulate terminal objects in terms of those "diagrams".
10:26:26 <zol> whoops. How do I print a value from an IO Float?
10:26:45 <jrmithdobbs> yesod/warp is some impressive software ... never thought I'd be able to take boilerplate webapp code + a simple route and get 10k req/s on my laptop with almost no work ...
10:27:10 <cschneid> Eduard_Munteanu: learning haskell is tricky, so many new terms & concepts to hook into my brain, bootstrapping into it is tricky. (and that's as a 10+ year expereince programmer)
10:27:12 <Eduard_Munteanu> cschneid: btw, we also have ##categorytheory, if you're interested :)
10:27:40 <Eduard_Munteanu> Oh, I thought you had some idea of CT.
10:30:45 <cschneid> Eduard_Munteanu: I don't. I'm from an undergrad CS program, and long-time programmer. But no CT education beyond what I've picked up on my own
10:30:50 <jrmithdobbs> cschneid: ya my biggest problem with it is that it's confusing where the documentation for what is where (especially for anything using templatehaskell) and once you find it it assumes you have full context and have been in an environment speaking academic CS terms daily for the last decade ;p
10:31:17 <jrmithdobbs> cschneid: so far, it's worth wading through though
10:31:27 <cschneid> jrmithdobbs: right. Once I grok an idea, it's simple, but the terms are from the math side, rather than the programmer side. Even for the same ideas. Which obfuscates things for an experienced programmer.
10:31:47 <cschneid> no biggie, it's nice to have the rigor of haskell, it's why I'm learning it in the first place
10:31:54 <cschneid> just weird to take so much effort to learn a language.
10:31:55 <Eduard_Munteanu> cschneid: there are more down-to-earth examples... if you look at the indexed state monad, you'll find it rather alright.
10:32:31 <Eduard_Munteanu> cschneid: data State i o a = State (i -> (a, o))
10:32:55 <Eduard_Munteanu> cschneid: if you make an indexed monad out of that, you basically get a State-like monad that can change the state type as it goes.
10:33:32 <cschneid> huh, cool. change type meaning, Int turning into a Float or something?
10:33:41 <Eduard_Munteanu> cschneid: yes
10:34:09 <cschneid> cool... :)
10:34:21 <ReinH> Eduard_Munteanu: Hom(-,-), the sleepy owl hom-functor
10:34:45 <Eduard_Munteanu> cschneid: normal State doesn't let you change it, it's like IndexedState s s a.
10:35:06 <Eduard_Munteanu> (The input and output state are the same)
10:35:58 <Eduard_Munteanu> ReinH: you mean IxState is Hom(-,-)-like?
10:36:09 <ReinH> Eduard_Munteanu: no, I mean Hom(-,-) looks funny :)
10:36:14 <Eduard_Munteanu> Oh, heh.
10:36:16 <dwcook> Eduard_Munteanu, where does one learn about indexed monads?
10:37:31 <Eduard_Munteanu> dwcook: edwardk's blog on http://comonad.com/reader might have some, I'm not sure.
10:38:05 <Eduard_Munteanu> Also   http://blog.sigfpe.com/2009/02/beyond-monads.html
10:38:40 <lpaste> bennofs pasted “Uses of the T monad” at http://lpaste.net/95569
10:38:52 <bennofs> Eduard_Munteanu: I wrote some examples using that monad
10:39:07 <dwcook> Neat.
10:39:26 <ibotty> when i was looking into indexed monads i also found these two resources to be great. ekmetts page uses the "other" term though: http://comonad.com/reader/2007/parameterized-monads-in-haskell/
10:39:29 <Eduard_Munteanu> ReinH: I asked because IxState is actually trifunctorial, and in two of the three components it's just Hom(-, -) AFAICT
10:39:50 <bennofs> I think it's a nice pattern if you have some "holes" to fill in. It reminds me a bit of lenses
10:40:21 <ReinH> Eduard_Munteanu: right, makes sense
10:40:21 <ibotty> bennofs: lenses use indexed monads in some places afair
10:40:55 <bennofs> ibotty: yes, but is this really an indexed monad (what I pasted)?
10:41:07 <Eduard_Munteanu> The store comonad is like that in 'i' and 'a', and identity in 'o'. Haven't thought about State though.
10:41:16 <ibotty> oh. i did not look into it. sorry i misunderstood what you meant, bennofs. i'll have a look
10:42:46 <Eduard_Munteanu> bennofs: you don't seem to be using it as an indexed monad, since an indexed (>>=) itself is different
10:43:22 <Eduard_Munteanu> You want (>>=) :: m i j a -> (a -> m j k b) -> m i k a
10:43:48 <ibotty> bennofs: the point of indexed monads is that they have a more broad definition of bind. you do not use that
10:45:25 <flebron> Is there a cleaner way of writing do { x <- getRandom; y <- getRandom; return $ min x y}?
10:45:49 <alkabetz> min <$> getRandom <*> getRandom would work, I think
10:46:07 <ibotty> applicative style is great
10:46:27 <flebron> Ah, yeah, had forgotten about that :) Thanks!
10:46:42 <alkabetz> You’re welcome.
10:48:03 <ReinH> flebron: where does getRandom come from btw?
10:48:14 <flebron> Control.Monad.Random
10:48:19 <ReinH> oh ofc
10:48:23 <ReinH> hoogle didn't know
10:49:19 <zol> How do I get a value from an IO Float?
10:49:42 <Eduard_Munteanu> @where faq
10:49:42 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
10:49:50 <moops> do { myFloat <- ioFloat ; ...
10:49:52 <alkabetz> zol: How familiar are you with monads in Haskell?
10:50:12 <Eduard_Munteanu> zol: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
10:50:33 <ReinH> flebron: Or '(<$> getRandom) . min =<< getRandom`, which is totally worse than the applicative style ;)
10:50:40 <flebron> :)
10:51:07 <donri> ReinH: oh god WHY
10:51:31 <ReinH> donri: :D :D :D
10:52:02 <zol> alkabetz: Not very, I need them for my HW assignment however, but my lecturer have only briefed showed us how to read a random value and print it to the screen, not how to actually use the value.
10:52:13 <donri> exercise: now write it with fmap and join
10:52:31 <ReinH> donri: well <$> is fmap :p
10:52:39 <alkabetz> zol: If you have time, you should go read sections 1–5 of https://www.haskell.org/haskellwiki/Typeclassopedia
10:52:54 <Eduard_Munteanu> mapState :: ('i -> i) -> (o -> o') -> (a -> b) -> State i o a -> State i' o' b;  mapState fi fo fa (State s) = (fa *** fo) . s . fi
10:53:02 <Eduard_Munteanu> That's even more mundane. :(
10:53:05 <zol> alkabetz: I guess I won't need to retrieve it, but it is hard to test functions that use IO when you have to write them on one line in GHCi
10:53:32 <Eduard_Munteanu> Looks like Hom(-, I) x Id_o x Id_a.
10:53:33 <alkabetz> zol: Yeah, GHCi is a bit limited in that regard
10:53:41 <alkabetz> zol: You can use :{ and :}
10:53:57 <alkabetz> zol: Or you can just write your functions in a file and :load them into GHCi, which is what I usually end up doing
10:54:36 <ReinH> not at all
10:54:39 <zol> alkabetz: Thanks!
10:54:42 <ReinH> x <- getRandom :: IO Int works in ghci
10:54:59 <ReinH> ghci runs in an implicit `main' scope
10:55:22 <alkabetz> zol: You’re welcome.  Also, what ReinH said :)
10:55:42 <zol> ReinH: Oh, that was what I was missing! I thought I had to use do expressions and write everything on one line
10:55:47 <Eduard_Munteanu> Comparing to mapStore :: ('i -> i) -> (o -> o') -> (a -> b) -> Store i o a -> State i' o' b;  mapStore fi fo fa (Store s o) = Store (fa . s . fi) (fo o)
10:55:58 <Eduard_Munteanu> Er s/State/Store/
10:56:03 <alkabetz> GHCi is kind of magical
10:56:58 <Eduard_Munteanu> I guess State is more like Hom(-, - x -), though.
10:57:21 <james-ubc> hi, I just spent about 2 hours trying to figure out what's wrong with my code, there's some type error but I cant quite pin it down
10:57:26 <james-ubc> could someone take a look? http://lpaste.net/95570
10:57:40 <Eduard_Munteanu> And Store is like Hom(-, -) x -
10:58:10 <Eduard_Munteanu> Which gives you three distinct components.
10:58:24 <andromeduck> couldn't match int with actual type char -> char -> a0 -> int but it looks like im giving the right arguments
10:59:03 <ReinH> zol: in fact, ghci runs inside an implicit do inside an implicit main
10:59:11 <ReinH> that's why you need to use let x = 1 to declare bindings
11:00:29 <lpaste> chrisdone pasted “Twitter waterflow question with loeb” at http://lpaste.net/95571
11:00:49 <mm_freak_> conal: i've compared sodium to reactive-banana…  apparently your complaint applies to both
11:00:50 <chrisdone> jmcarthur: here was the first solution i thought of, “that's a spreadsheet!”
11:01:15 <conal> mm_freak: which complaint specifically?
11:01:18 <mm_freak_> conal: both provide 'changes', though reactive-banana specifically marks it as unsound in its documentation
11:01:54 <chrisdone> this is the first code i've used lens in =)
11:02:26 <conal> mm_freak_: ah. i hadn't spotted it in reactive-banana. heinrich at least tried to define and follow a denotation. so at least he's in the position of noticing unsoundness.
11:03:06 <mm_freak_> conal: indeed…  i will probably switch to reactive-banana for widget-based UI stuff then
11:04:32 <mm_freak_> in fact on a second look it seems hard to find an advantage of sodium over reactive-banana
11:05:01 <Eduard_Munteanu> Is there a 'length' for Text that takes standard tab-length into account?
11:05:56 <mm_freak_> Eduard_Munteanu: T.length . T.concatMap tabToSpaces
11:06:14 <FreeFull> I imagine the standard length for Text just reads a length field
11:06:25 <zard0z> hello, I am struggling to understand what is realy going on in here
11:06:38 <mm_freak_> FreeFull: no, it actually runs through the string
11:06:41 <mm_freak_> there is no length field
11:06:43 <Eduard_Munteanu> mm_freak_: and is there a tabToSpaces? I know I can add a case for tabs, but I wonder if there's a function that handles all unicode spaces.
11:06:44 <zard0z> if we have `xs = 0 : 1 : xs', it expands to `0 : 1 : thunk', with thunk being 0 : 1 : xs, correct?  if we take 4 elements, we get `0 : 1 : 0 : 1 : <thunk>'? what is thunk now?  previous value 0 : 1 : xs, or is it `0 : 1 : 0 : 1 : xs'?
11:07:04 <mm_freak_> Eduard_Munteanu: not really, and i'd suggest writing your own length function in terms of T.foldl'
11:07:34 <mm_freak_> T.foldl' (\n c -> n + charLen c) 0
11:07:36 <Eduard_Munteanu> mm_freak_: ah... I'll just use attoparsec's scan and match on '\t' and ' ', I only need the length.
11:07:38 <FreeFull> Eduard_Munteanu: You mean handles all unicode tabs?
11:07:49 <Eduard_Munteanu> FreeFull: all unicode horizontal spaces. :)
11:07:56 <Eduard_Munteanu> Are there more?
11:08:01 <mm_freak_> lots =)
11:08:13 <joelteon> zard0z: xs always expands to 0 : 1 : xs
11:08:14 <FreeFull> If you want actual length as if it was displayed in a monospaced font, then it won't be that easy
11:08:25 <Eduard_Munteanu> I guess you don't find unicode in Kconfig files too often :)
11:08:40 <FreeFull> > let xs = 0 : 1 : xs in xs ! 2001001
11:08:42 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i0 e0'
11:08:42 <lambdabot>              with actual...
11:08:45 <FreeFull> > let xs = 0 : 1 : xs in xs !! 2001001
11:08:47 <lambdabot>   1
11:08:50 <FreeFull> > let xs = 0 : 1 : xs in xs !! 20010012882
11:08:51 <zard0z> joelteon, how come it doesn't expand to the whatever the current value of xs is?
11:08:54 <Eduard_Munteanu> FreeFull: presumably Haskell does a similar thing for parsing
11:09:02 <mm_freak_> Eduard_Munteanu: turn the character into a vty Image, then ask for the dimensions of that image =)
11:09:04 <joelteon> zard0z: xs only has one value
11:09:06 <Eduard_Munteanu> Hehe.
11:09:11 <joelteon> namely, 0 : 1 : xs
11:09:17 <joelteon> it doesn't change
11:09:28 <zard0z> so unevaluated thunk is always 0 : 1 : xs?
11:09:28 <mm_freak_> Eduard_Munteanu: in fact that's pure, so vty probably has a way to tell the character width
11:09:31 <joelteon> right
11:09:39 <mm_freak_> Eduard_Munteanu: look into how vty determines it
11:09:45 <ReinH> zard0z: the current value of xs is always 0 : 1 : xs
11:09:51 <joelteon> 0 : 1 : xs -> 0 : 1 : 0 : 1 : xs -> 0 : 1 : 0 : 1 : 0 : 1 : xs -> ...
11:10:11 <ReinH> zard0z: when you say xs = 0 : 1 : xs, you are defining xs as 0 : 1 : xs
11:10:14 <Eduard_Munteanu> Nah, I'll just match on ' ' and '\t', too much of a headache.
11:10:16 <ReinH> its value doesn't change
11:10:25 <zard0z> ok makes sense
11:10:53 <jrmithdobbs> is there a good/simplified way of doing accept-encoding logic in yesod? eg, I want to use Accept headers to specify either application/json or text/plain and render differently depending (doing so with a PATH_INFO route like .json vs .txt is fine too) I'm just not seeing any examples of this anywhere
11:12:53 <jrmithdobbs> i mean i can manually define the routes and pass them through the same call stack that takes the encoding and result and presents but it just seems like something that would already be there
11:12:59 <klugez> jrmithdobbs: http://www.yesodweb.com/book/restful-content
11:13:28 <klugez> Under the header "Representations", I think.
11:13:28 <zard0z> I am really trying to grasp how `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)` works. I still can't quite figure it out
11:13:36 <Narvius> zard0z: It took me a while to understand how "fib = 0:1:zipWith (+) fib $ tail fib" can possibly work, but it's in the same vein.
11:13:45 <zard0z> heh :)
11:13:47 <jrmithdobbs> klugez: already had that open but I think I need to read more closely
11:13:50 <zol> If I have a structure like [(1, [2, 3, 4]), (5, [6,7])], how can I turn it into a result like [(1, 2), (1,3), (1,4), (5,6), (5,7)] ?
11:14:07 <Narvius> :t sum
11:14:08 <lambdabot> Num a => [a] -> a
11:14:16 <Narvius> zol: fmap (fmap sum)
11:14:19 <jrmithdobbs> oh, derr, i skipped past the relevent part looking for accept-encoding specifically, overagressive searching ;p
11:14:36 <Narvius> > fmap (fmap sum) [(1, [2, 3, 4]), (5, [6, 7])]
11:14:37 <lambdabot>   [(1,9),(5,13)]
11:14:41 <jrmithdobbs> klugez: thanks!
11:14:42 <Narvius> Oooh
11:14:43 <Narvius> no
11:14:43 <Narvius> wait
11:14:46 <Narvius> I'm silly, man.
11:15:04 <mm_freak_> :t concatMap (\(x, xs) -> map ((,) x) xs)
11:15:05 <lambdabot> [(a1, [a])] -> [(a1, a)]
11:15:12 <Eduard_Munteanu> > zip <$> repeat <*> id $ [(1, [2, 3, 4]), (5, [6, 7])]
11:15:14 <lambdabot>   [([(1,[2,3,4]),(5,[6,7])],(1,[2,3,4])),([(1,[2,3,4]),(5,[6,7])],(5,[6,7]))]
11:15:40 <Narvius> > concatMap (\(x, xs) -> map ((,) x) xs)  [(1, [2, 3, 4]), (5, [6, 7])]
11:15:41 <lambdabot>   [(1,2),(1,3),(1,4),(5,6),(5,7)]
11:15:47 <Eduard_Munteanu> Er.
11:15:55 <jrmithdobbs> oh, bah, i'm specifically re-implementing an api that allows both Accept and the .content methods of specifying resp format and yesod is opinionated about the latter this is going to be interesting
11:16:07 <mm_freak_> zol: see above
11:16:32 <mm_freak_> here is another way to write it:
11:16:39 <chrisdone> hmmm -- any comparisons out there between Data.Array and Data.Vector?
11:16:45 <Eduard_Munteanu> > map (uncurry $ zip <$> repeat <*> id) $ [(1, [2, 3, 4]), (5, [6, 7])]
11:16:47 <lambdabot>   Couldn't match type `[([b1], b1)]' with `[t0] -> b0'
11:16:47 <lambdabot>  Expected type: [b1] -...
11:16:55 <chrisdone> i tend to use Vector and forgot that Array exists
11:17:04 <Eduard_Munteanu> > map (uncurry . zip <$> repeat <*> id) $ [(1, [2, 3, 4]), (5, [6, 7])]
11:17:05 <mm_freak_> :t \xs -> [ (x, y) | (x, ys) <- xs, y <- ys ]
11:17:05 <lambdabot>   Couldn't match type `[(([b1], [t0]), b1)]' with `[t0] -> b0'
11:17:05 <lambdabot>  Expected type...
11:17:06 <lambdabot> [(t, [t1])] -> [(t, t1)]
11:17:16 <Eduard_Munteanu> Nevermind, I should be doing something else.
11:17:25 <mm_freak_> > (\xs -> [ (x, y) | (x, ys) <- xs, y <- ys ]) [(1, [2,3,4]), (5, [6,7])]
11:17:26 <lambdabot>   [(1,2),(1,3),(1,4),(5,6),(5,7)]
11:17:35 <zol> Narvius:  Thanks!
11:17:37 <Narvius> List comprehension is probably the clearest in this case.
11:17:40 <zol> mm_freak_: You too
11:17:43 <Eduard_Munteanu> Definitely.
11:17:47 <Narvius> zol: Why me, I didn't do anything right. _^_
11:17:49 <bennofs> Array can work with 2D indices, afaik, whereas vector can't (or you'll have to do the mapping manually)
11:18:07 <mm_freak_> zol: the comprehension is really just translated into the concatMap-based solution
11:18:18 <chrisdone> bennofs: nod
11:18:27 <chrisdone> bennofs: any speed comps?
11:19:04 <bennofs> I think vector does stream-fusion, which array doesn't do, but I don't have any benchmark data
11:19:19 * zol nods
11:20:47 <mm_freak_> bennofs: array operations with 0-based indices are slightly faster for Array, but the many optimizations of Vector make it outperform Array
11:21:30 <bennofs> mm_freak_: hmm, why is that? I thought they were basically the same, implementation-wise?
11:21:54 <mm_freak_> bennofs: i don't know, i'm just reflecting my benchmarks
11:21:57 <jrmithdobbs> klugez: oh wow was I doing this the hard way. so much simpler when you find the right part of the documentation. :)
11:22:03 <mm_freak_> in particular mutable vectors are generally slower than mutable arrays
11:22:24 <mm_freak_> this was a surprising result actually
11:22:35 <mm_freak_> also it was for an old version of vector…  may not apply anymore
11:27:11 <bennofs> Does anyone know a package where this monad is implemented? http://lpaste.net/95569
11:27:30 <bennofs> I asked that question earlier, but it seems it got lost in a discussion about indexed monads :)
11:29:00 <alkabetz> It’s got a very descriptive name. :)
11:29:09 <alkabetz> The type looks kind of like the type for the continuation monad.
11:29:27 <Eduard_Munteanu> Any thoughts on 'sepBy (takeTill isEndOfLine) endOfLine' in attoparsec? I'm not sure if it can be simplified.
11:30:05 <Eduard_Munteanu> 'sepBy takeText endOfLine' might be inefficient if it takes until EOF and backtracks, no?
11:30:40 <Eduard_Munteanu> alkabetz: yeah, I suggested the indexed ContT earlier but it's different.
11:36:32 <schell> what's up with the 'fake conferences' email that just came in to haskell-cafe?
11:37:45 <schell> is it itself a fake 'fake conferences' notice?
11:38:47 <Eduard_Munteanu> Dear Haskell Cafe, my late husband was a wealthy Nigerian fake conference organizer.
11:39:38 <eikke> s/wealthy Nigerian fake/fake wealthy Nigerian/
11:40:33 <FireFly> I prefer the original version
11:42:40 <notdan_>  /topic
11:42:44 <notdan_> sorry
11:46:31 <schell> i'm guessing that the email is fake, as the guy it talks about (Hamid Arabnia) seems to be real?
11:47:11 <chrisdone> Eduard_Munteanu: read the email with this music on http://grooveshark.com/s/Dance+Of+The+Dream+Man/rUidv?src=5
11:47:59 <zardoz``> a bit OT but I am curious about your opinion, can a dynamically typed language be considered type safe?
11:48:34 * schell loves twin peaks
11:48:42 * chrisdone high-fives schell 
11:48:46 <zardoz``> I have a hard time considering a language where misuse of types result in runtime error as type safe, but according to this they are: http://en.wikipedia.org/wiki/Type_safety#Common_Lisp
11:48:57 <schell> :)
11:49:33 <Eduard_Munteanu> zardoz``: yes, but you don't know if the program is type-safe until you get full testing coverage.
11:49:40 <roconnor> zardoz``: It depends on whether you are concerned about violation of data structure invariants or executing random data as code.
11:49:50 <triliyn> zardos``: most CL compilers can do static checks if you supply type declarations, but also they're probably comparing it to things like PHP where you DON'T get a runtime error if you misuse types
11:50:14 <chrisdone> zardoz``: i think type-safe is broadly meant to mean an error will happen, either at compile time, or runtime, rather than the program going about its merry way
11:50:19 <schell> chrisdone: my friends and i had a dress up twin peaks party a couple months ago
11:50:27 <zardoz``> but according to above, it is type safe as long as there are runtime checks, which seems like a useless definition.  "In general, Common Lisp is a type-safe language. A Common Lisp compiler is responsible for inserting dynamic checks for operations whose type safety cannot be proven statically. "
11:50:27 <Eduard_Munteanu> Well, assuming we are talking about a sound type system.
11:50:31 <chrisdone> schell: oh man that's awesome
11:50:32 <triliyn> "5" + 5 ---> "55"
11:50:35 * tomejaguar highfives chrisdone for making haskellnews.org
11:50:40 <chrisdone> schell: can i have your friends?
11:50:58 * chrisdone high-five tomejaguar
11:51:03 <triliyn> Or *(float*)intptr ---> garbage
11:51:25 <Eduard_Munteanu> zardoz``: there are ways to prove stuff about code that depend on coverage.
11:51:44 <zardoz``> trilyn what do you mean there are no runtime errors if you misuse types in PHP?
11:51:48 <Eduard_Munteanu> zardoz``: that is, you don't need to test all input combinations, you just have to run the code.
11:52:15 <donri> i think technically "type safe" just means no segfaults :p
11:52:20 <Eduard_Munteanu> zardoz``: an example is the Linux kernel deadlock prover.
11:52:27 <donri> not that it's used to mean that in haskell
11:52:28 <triliyn> zardoz``: well, there are some runtime errors, but there are also cases where there is not an error
11:52:31 <zardoz``> trilyn I missed your example. doesn't that mean (+) function takes strings?
11:52:36 <triliyn> Mostly implicit coercion
11:52:40 <chrisdone> zardoz``: well lisp generally compiles to assembly, it could just go about its merry way and let you write an int over a vector (and indeed you can allow that). but with safety on, it will do checks
11:52:43 <zardoz``> ie, not related to type safety
11:52:46 <Eduard_Munteanu> zardoz``: you just need to acquire the locks, you don't have to actually provoke a race condition
11:52:59 <triliyn> hmmm, right, php has a separate string concatenation
11:53:14 <triliyn> You could do "5".5 though, couldn't you?
11:53:32 <donri> that's called weak types
11:53:35 <chrisdone> doing type checks in your runtime is an overhead you don't necessarily want, so you might choose to sacrifice type safety
11:54:14 <triliyn> I probably shouldn't have used php as an example because I don't know it well
11:54:21 <triliyn> Anyway I need to go!
11:54:28 <chrisdone> nobody knows php well
11:54:34 <chrisdone> it's unknowable, like the abyass
11:54:39 <Eduard_Munteanu> zardoz``: which is definitely more than "I tested these locks and they seem fine", but less than "we have a static formal proof no deadlocks can occur"
11:54:44 <chrisdone> and unspellable, like the abyss
11:55:21 <donri> chrisdone: you're being funny but i think there's some formal truth to it, in that the parser doesn't have any formal grammar etc
11:55:44 <donri> or was that perl5, i don't remember
11:55:54 <chrisdone> probably both
11:56:15 <zardoz``> Eduard_Munteanu, but according to above wiki link, you don't need tests. you just need type errors to be checked (even if at runtime), for the language to be type safe. do you agree with that definition?
11:57:07 <chrisdone> zardoz``: i do, not that you're listening to me =)
11:57:14 <zardoz``> def size(string): return length(string)  size(10); <- not type safe in my book
11:57:19 <Eduard_Munteanu> zardoz``: I agree with the second part, that you only need types to be checked. But that doesn't mean "no tests".
11:57:28 <chrisdone> donri: beches don't know 'bout my loeb http://lpaste.net/95571
11:58:07 <Eduard_Munteanu> zardoz``: if types aren't constructed until runtime and coverage is required
11:58:28 <monochrom> "what does a PHP program do? we just don't know."
11:58:46 <Eduard_Munteanu> zardoz``: you still need to run the code and make sure all functions are executed at least once, for example.
11:58:54 <chrisdone> monochrom: https://www.youtube.com/watch?v=Kh0Y2hVe_bw
11:59:24 <monochrom> yeah, that one
11:59:31 <chrisdone> :D
11:59:38 <Eduard_Munteanu> zardoz``: e.g. Haskell code plus -fdefer-type-errors
12:01:11 <Eduard_Munteanu> You still need the type system to be able to prove something about the code, more than applying checks on particular inputs.
12:02:02 <Eduard_Munteanu> Sure if you *could* run a program for *all* inputs and check the results, then yeah, even PHP would be typesafe. But you can't. :)
12:02:09 <schell> chrisdone: it took me a sec but i found pics -> http://www.flickr.com/photos/d3greethree/sets/72157634544485368 (i'm James Hurley)
12:02:36 <monochrom> suppose you give me a Haskell function emit::a->[a]. just from that type, I still don't know what it does. but one more test will settle it.
12:03:04 <monochrom> if the test results in emit () = [(), (), ()], then I know emit x = [x, x, x}
12:03:10 <fizruk> SwineFlu, like (apply (car xs) (cdr xs)) ? what are the types?
12:03:25 <fizruk> oops
12:03:34 <SwineFlu> hi
12:03:44 <monochrom> parametricity says that types plus a few tests tell me almost the full specification
12:03:52 <Eduard_Munteanu> Erlang is a good example of a strongly-typed language with poor types and dynamic checking.
12:04:37 <Eduard_Munteanu> Although you can get some typechecking statically with success typing, but that's an afterthought.
12:05:25 <Eduard_Munteanu> And not even being strongly-typed isn't much of a deal, since you only have a handful of types.
12:06:21 <Eduard_Munteanu> So even if it was checked statically, it would let a lot of garbage pass as well-formed programs.
12:07:40 <FreeFull> monochrom: It's difficult to tell if a function produces a very large finite list or an infinite list
12:08:01 <scshunt> FreeFull: if by "difficult" you mean "impossible"
12:08:22 <Eduard_Munteanu> Well, yes, in that sense even Haskell has a poor type system.
12:08:40 <monochrom> you are right, that one I can't settle with a test
12:08:46 <Eduard_Munteanu> I mean the types are poor, as opposed to rich, e.g. dependent types.
12:09:56 <Eduard_Munteanu> If we could distinguish data and codata, then this could be settled just by looking at the type. :)
12:11:17 <FreeFull> Eduard_Munteanu: It's impossible to tell if a list is infinite or not for some cases
12:11:26 <chrisdone> scshunt: well, undecidable in the *general* case
12:11:39 <chrisdone> you can certainly decide plenty of things about programs in the specific case
12:11:57 * hackagebot flowdock-api 0.1.0.0 - API integration with Flowdock.  http://hackage.haskell.org/package/flowdock-api-0.1.0.0 (gabemc)
12:12:17 <FreeFull> You could make a list that is infinite only if the collatz conjecture is true
12:12:53 <jrmithdobbs> is there a way to tell cabal "always use --enable-tests" ?
12:13:23 <eikke> jrmithdobbs: check ~/.cabal/config
12:14:02 <scshunt> chrisdone: well of course
12:14:19 <jrmithdobbs> eikke: easy enough, thanks!
12:21:35 <jle`> i would like to thank the person here in #haskell who adamantly opposed the "IO is the state monad with RealWorld state" viewpoint for me when i was starting out Haskell.  I realize now how much it has shaped/opened the door for understnading since then.  you might know who you are or you might not.  that is all.  thank you.
12:23:08 <dcoutts> jle`: for fun, have a look at http://hackage.haskell.org/package/acme-realworld
12:23:30 <Nebasuke> quick question: I noticed Hackage has a new feature for changelogs, which apparently have to be placed in the root folder of the package. What is the naming policy for changelog files?
12:23:59 <dcoutts> Nebasuke: have to be called changelog or changes (any case) with extension of none, .txt. .md or .markdown
12:24:10 * Ringtail is new to this Haskell stuff!
12:24:26 <chrisdone> Ringtail: yay, newbies! \^_^/
12:24:36 <Nebasuke> cool :). Thank you very much
12:24:49 <donri> Nebasuke: https://github.com/haskell/hackage-server/blob/master/Distribution/Server/Packages/ChangeLog.hs :)
12:25:27 * donri wants a changelog field for .cabal though
12:25:35 <dcoutts> donri: me too
12:25:45 <donri> \o/
12:25:55 <dcoutts> donri: and allowing specifying it in the .cabal file, with checked syntax
12:26:02 <donri> in deed
12:26:21 <ibotty> speaking about checked syntax in cabal files. which tools can do that?
12:26:28 <donri> cabal check
12:26:30 <ibotty> oh
12:26:39 <donri> but not sure it checks the haddock markup in description though
12:26:41 <ibotty> that could have been expected.. :D
12:26:50 <chrisdone> yeah, CHANGELOG in the cabal file would feel very natural
12:26:55 * mm_freak_ abandons sodium again
12:27:27 <chrisdone> mm_freak_: back to chloride?
12:27:33 <mm_freak_> ;)
12:27:34 <donri> Nebasuke: btw you'll need extra-source-files: CHANGES or something like that, too
12:27:34 <bearclaw> are there tools to help/factor writing a Monad that is the combination of two others, say as a purely hypothetical example "IO Future"?
12:27:42 <monochrom> potassium is better
12:27:56 <mm_freak_> chrisdone: i was evaluating FRP frameworks for widget-based UIs
12:27:58 <bearclaw> so that I could write do x<-callThatReturnsIoFuture ; fooExpectsValue x
12:28:01 <bz> recommended examples/guides for using {M,ST,IO}Array?
12:28:13 <ibotty> donri: nice, with line numbers as well. let's see how i can integrate it in my vim setup
12:28:15 <Nebasuke> donri: you happen to have an example lying around?
12:28:23 <chrisdone> monochrom: i've heard good things about unobtanium, but i haven't been able to get hold of any
12:28:26 <donri> ibotty: line numbers? hmm is this new
12:28:34 <donri> i've looked at integrating cabal check into vim before
12:28:40 <mm_freak_> reactive-banana wins over sodium
12:28:41 <ibotty> i just deleted a , and it told me where
12:28:51 <ibotty> a ',' that is
12:29:00 <donri> oic
12:29:05 <monochrom> indeed chrisdone, I heard that Nobody is perfect, and I want to meet him/her :)
12:29:06 <donri> i could work with this
12:29:25 <donri> it's very lacking but better than nothing
12:29:35 <ibotty> best would be checking of dependencies though :D
12:30:07 <ibotty> someone will need to implement hcabaltools then
12:30:22 <popx_> question: I want a program that reads lines from stdin and occasionally does some test that may fail and then the program should exit otherwise continue executing. How would i model this?
12:30:47 <jrmithdobbs> Transaction rate:	    12600.87 trans/sec
12:30:51 <donri> ibotty: https://github.com/haskell/cabal/issues/1127
12:30:56 <ibotty> popx_:  use interact
12:31:22 <roconnor> @type interact
12:31:26 <lambdabot> (String -> String) -> IO ()
12:31:46 <ibotty> oh. well
12:31:56 <roconnor> ibotty: I think it is a reasonable suggestion
12:31:56 <donri> interact doesn't really let you do IO though
12:32:03 <donri> but you can use pure exceptions, although evil :p
12:32:05 <ibotty> donri: good bug report
12:32:09 <popx_> ibotty: how would i make it exit when some test failed?
12:32:55 <mm_freak_> FWIW here is my experiment:  http://lpaste.net/95576
12:33:00 <roconnor> popx_: if you just want to print failure or success messages to stdout you can use interact.
12:33:40 <popx_> i want the program to die when failing a test
12:33:53 <monochrom> popx_: perhaps my http://lpaste.net/52480 helps
12:34:18 <monochrom> "exit" = don't recurse. "don't exit" = recurse.
12:34:58 <roconnor> popx_: if you want to be more sophisticated, and apply the same test over and over again then : main = do {x <- getLine; if runTest x then main else (putStrLn "Test Failed" >> System.exit 1)}
12:35:16 <conal> popx_: here's an idea: newtype Aut = String -> Maybe (String, Aut) . then write a simple Aut -> IO () driver.
12:35:37 <chrisdone> monochrom: i can't get over it! that brick wall
12:35:42 <conal> popx_: or if you don't need any output, simplify to Aut = String -> Maybe Aut .
12:35:55 <monochrom> err, what brick wall?
12:36:28 <donri> mm_freak_: is netwire not good for this widget stuff either, or is it just a matter of lack of libraries?
12:36:35 <popx_> thanks all
12:36:47 <conal> popx_: btw, "Aut" for automaton.
12:36:51 <popx_> I'll see what i will do
12:37:04 <mm_freak_> donri: netwire is not good for widget-based GUI frameworks, because each event will cause a full network evaluation
12:37:46 <ibotty> donri: good you mentioned that bug report. now dcoutts answered :D. so many channels
12:37:50 <donri> hehe
12:37:54 <mm_freak_> for my current project i'll have both a real-time system, which i will write with netwire, and a widget-based system
12:38:07 <mm_freak_> so far i'm quite pleased with reactive-banana for the latter
12:38:28 <donri> mm_freak_: is reactive-banana conversely not great for netwire's use cases?
12:38:39 <mm_freak_> donri: yes
12:39:15 <mm_freak_> reactive-banana is great for the generalized-spreadsheet kind of application, for which netwire sucks
12:39:34 <mm_freak_> netwire is great for real-time hybrid systems (games, simulations, etc.), for which reactive-banana sucks
12:39:43 <donri> okies so you couldn't really have the best of both in one package without compromise or duplication eh
12:39:52 <mm_freak_> exactly
12:40:02 <mm_freak_> also they work quite well together
12:40:54 <ibotty> off-topic: i never visited the haskell platform starting page before. refreshingly pink
12:41:00 <ibotty> http://www.haskell.org/platform/
12:41:29 <monochrom> a mindset that thinks "what do I say to exit" has it all wrong information-wise. exiting contains little information, you should need to say very little, preferrably nothing. not exiting contains much more information: if you are not exiting, what do you want next? you've got to say that. not exiting is the one that needs saying a lot.
12:41:43 <ibotty> speaking about it, when is 2013.4.0.0 coming?
12:41:45 <chrisdone> ibotty: that's still the spring theme
12:41:47 <mm_freak_> perhaps conal can recommend more FRP libraries to look at…  until my experience was mostly limited to AFRP
12:41:54 <mm_freak_> *until now
12:42:57 <monochrom> therefore, people should be asking "what do I say to indicate that I want to continue at point X" rather than "what do I say to exit"
12:43:03 <donri> mm_freak_: my main interest is for an irc bot and dict server, so probably netwire then?
12:43:25 <monochrom> but Dijkstra may not like this
12:43:47 <chrisdone> list of things Dijkstra liked:
12:43:48 <chrisdone> 1) his wife
12:43:48 <chrisdone> 2) his beard
12:43:48 <chrisdone> 3) holland
12:44:15 <tac> chrisdone: 4) Proofs of correctness for his algorithms.
12:44:16 <chrisdone> this list is complete
12:44:39 <monochrom> um, Dijkstra would also want you to number them 0, 1, 2. :)
12:45:07 <mm_freak_> donri: it depends on the bot/server
12:45:16 <chrisdone> i always wondered what Dijkstra would think of haskell, but i suspect he'd dislike the unpredictable performance characteristics, while being positive about the functional and statically typed aspects
12:45:48 <Jeanne-Kamikaze> isn't that what everyone thinks ?
12:45:51 <hamid> how can I enable an extension in GHCi ?
12:45:59 <donri> hamid: :set -XName
12:46:08 <augur> “The purpose of this paper is not only self-citation (McBride, 2001; McBride & Paterson, 2006), but also to write a nice wee program.”
12:46:13 <ibotty> or {-# LANGUAGE Name #-}
12:46:24 <ibotty> (oh i missed the 'i')
12:46:25 <hamid> donri, thanks :)
12:46:26 <Jeanne-Kamikaze> :D
12:46:31 <chrisdone> augur: haha
12:46:38 <donri> ibotty: huh, that works in ghci?
12:46:46 <ibotty> no
12:46:47 <fizruk> augur, Why walk when you can take the tube?
12:46:51 <augur> chrisdone: :)
12:46:52 <augur> fizruk: yep
12:46:54 <mm_freak_> donri: if your bot has a lot of dynamic behavior, then netwire will work better…  if it's more like a chatter/talker bot that reflects some information, then reactive-banana will work better
12:46:59 <FreeFull> chrisdone: So he'd like Haskell if it was strict?
12:47:02 <mm_freak_> donri: ultimately for such an application it doesn't really matter
12:47:19 <augur> fizruk: im going to guess you're familiar with the paper?
12:47:22 <chrisdone> FreeFull: that's what i'd imagine
12:47:42 <ibotty> donri: seems it does
12:47:44 <augur> fizruk: alternatively, you know how conor-obsessed i am, you then looked at his twitter feed, saw he mentioned traversables, and figured i went off to read the canonical paper!
12:47:44 <ibotty> somehow
12:48:02 <hamid> i have no idea why this is okay to use in ghci :
12:48:11 <fizruk> augur, nope, just found it earlier today :p
12:48:14 <ibotty> at least typing {-# UNKNOWNPRAGMA foo #-} generates an error
12:48:17 <augur> fizruk: or that!
12:48:21 <donri> mm_freak_: i'm still not sure frp itself will make sense for my uses, but feel i should at least investigate it :)
12:48:24 <hamid> > (,) <$> [1] <*> [1..5]
12:48:26 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5)]
12:48:30 <ibotty> but {-# LANGUAGE foo #-} does not...
12:48:31 <hamid> but not this :
12:48:37 <augur> i still dont quite get traversables but
12:48:40 <hamid> > map (1,) [1..5]
12:48:42 <lambdabot>   Illegal tuple section: use -XTupleSections
12:48:47 * chrisdone goes to watch something about, you guessed it, zombies
12:48:48 <hamid> same here :P
12:48:57 <FreeFull> hamid: You can't partially apply the tuple constructor
12:49:03 <FreeFull> At least, not like that
12:49:11 <FreeFull> > map ((,) 1) [1..5]
12:49:13 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5)]
12:49:17 <int-e> hamid: hmm. I guess that's safe :)
12:49:31 <hamid> oh got it.
12:49:37 <augur> hamid: its just a parsing thing. lambdabot's message tells you how you make that possible
12:49:43 <donri> hamid: well, you need :set -XTupleSections for (1,) but not (,)
12:49:48 <augur> {-# LANGUAGE TupleSections #-}
12:49:55 <chrisdone> donri: ever seen Big Brother?
12:50:03 <hamid> yep tried it and it works perfect :)
12:50:05 <donri> chrisdone: the reality show?
12:50:08 <joelteon> why are TupleSections disabled by default?
12:50:09 <chrisdone> donri: yeah
12:50:11 <donri> chrisdone: no
12:50:12 <augur> chrisdone: the british one has a great theme song
12:50:26 <augur> AND was in the finale of S1 of doctor who
12:50:31 <chrisdone> augur: ever watched it and thought “where's a zombie outbreak when you need one"?
12:50:44 <augur> chrisdone: charlie brooker
12:50:48 <augur> well aware :)
12:50:49 <chrisdone> xD
12:50:58 <augur> i was about to mention it but then you said that!
12:51:01 <augur> Dead Set
12:51:02 <chrisdone> augur: i'm just about to watch the first episode. i loves me some zombies
12:51:04 <donri> joelteon: because it's non-standard
12:51:08 <mm_freak_> donri: i think i haven't written a single application that doesn't use FRP over the last two years =)
12:51:09 <joelteon> oh
12:51:11 <joelteon> makes sense
12:51:12 <augur> chrisdone: its great. also check out A Touch of Cloth
12:51:24 <donri> mm_freak_: but you're mm_freak
12:51:31 <mm_freak_> the scope of FRP is any stateful application
12:51:36 <donri> :)
12:51:54 <mm_freak_> donri: btw, you might find the new wiki-page on netwire interesting
12:52:00 <chrisdone> augur: thanks for the recom. ;) i've seen Dark Mirror. surprisingly, it's pretty dark
12:52:04 <jle`> netwire wiki page finally updated?
12:52:04 <augur> chrisdone: everything brooker does is amazing. ive watched all of his shows. screenwipe, news wipe, weekly wipe, but also black mirror
12:52:15 <schell> can anyone tell me where the code associated with the ghc api is located?
12:52:17 <mm_freak_> jle`: yeah, together with the release of netwire 5 today =)
12:52:19 <donri> mm_freak_: yep i read it :)
12:52:33 <mm_freak_> the first netwire version that conal might actually like =)
12:52:38 <int-e> > (,1) 2
12:52:49 <lambdabot>   (2,1)
12:52:52 * chrisdone bbl
12:52:53 <donri> int-e: yay!
12:53:06 <donri> int-e: (are you running lambdabot now?)
12:53:10 <FireFly> Ooh, tuple sectioning
12:53:14 <int-e> donri: yes
12:53:16 <augur> int-e's a hax0r
12:53:17 <hamid> :t evaluate
12:53:23 <lambdabot> a -> IO a
12:53:25 <hamid> :i evaluate
12:53:33 <monochrom> there is no :i
12:53:44 <hamid> :/ where is this function?
12:53:51 <FireFly> :t (&)
12:53:52 <monochrom> ghci has it
12:53:52 <int-e> Control.Exception?
12:53:54 <mm_freak_> hamid: ghci
12:53:55 <augur> :i before :e except after :c
12:53:57 <lambdabot> a -> (a -> b) -> b
12:54:03 <int-e> @hoogle evaluate
12:54:09 <monochrom> err, where is evaluate? then what int-e says
12:54:11 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
12:54:17 <lambdabot> Control.Exception evaluate :: a -> IO a
12:54:20 <monochrom> I meant ghci has :i
12:54:36 <Eduard_Munteanu> FreeFull: you can prove some finite lists are finite
12:54:49 <monochrom> pronouns must die die die
12:54:56 <donri> > [ "monad comprehensions? | _ <- Just Nothing ]
12:55:04 <lambdabot>   <hint>:1:47:
12:55:07 <donri> > [ "monad comprehensions?" | _ <- Just Nothing ]
12:55:08 <FreeFull> Eduard_Munteanu: Not all though
12:55:09 <lambdabot>      lexical error in string/character literal at end of input
12:55:15 <Eduard_Munteanu> monochrom: what do *you* have against *them*? :P
12:55:15 <lambdabot>   Couldn't match expected type `[t0]'
12:55:21 <lambdabot>              with actual type `Data.May...
12:55:37 <donri> :(
12:56:25 <augur> copumpkin: whats all this chatter about faking sums
12:56:27 <Eduard_Munteanu> FreeFull: actually it's all of them, except you're proving a certain way of constructing a list results in a finite list, and not all ways of constructing lists terminate.
12:56:33 <monochrom> students in calculus classes keep writing like "it is 0 therefore it is a critical point". their ciphertext means: "f'(5) is 0 therefore (5, f(5)) is a critical point". see what's wrong?
12:57:09 <Cale> monochrom: heh, and some of them write even less
12:57:11 <monochrom> pronouns must die die die. if they don't have pronouns, they will be forced to write clearly and think clearly
12:57:19 <augur> monochrom: thats not a problem with pronouns
12:57:24 <augur> thats a problem with their pragmatics
12:57:35 <monochrom> well, language shapes thoughts.
12:57:43 <augur> pronouns have well-defined meanings and use-cases, and they're violating them
12:58:09 <Eduard_Munteanu> Lists are countable up to the actual elements.
12:58:13 <augur> sometimes i think undergrads dont have a theory of other minds
12:58:56 <augur> Eduard_Munteanu: all types definable in type theory are countable in practice :)
12:59:11 <FreeFull> Eduard_Munteanu: Not all possible terminating lists can be constructed in that way
12:59:30 <augur> including function types like Nat -> Bool because you can only write down countable many inhabitants
12:59:34 <monochrom> ok, we're in a channel where people say we should design [programming] languages to forbid more bad uses, rather than allow bad uses and then just say "the program is some users, not the language"
12:59:47 <monochrom> s/the program is/the problem is/
13:00:10 <augur> monochrom: yes, well, we _do_ have a language that forbids bad uses
13:00:51 <augur> monochrom: its analogous to expecting people to write type checking code, and they just refuse to do so.
13:01:02 <schell> does anyone know where i can find docs for the ghc api for HEAD ghc?
13:01:04 <schell> similar to http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html
13:01:13 <schell> or how to generate them?
13:01:22 <monochrom> ok, we will eventually agree violently
13:01:22 <augur> the language can be strict, but if the programming just refuses to play by the rules, even when that renders the output bad, its not the language's fault
13:01:25 <Eduard_Munteanu> FreeFull: well, at least for the countable types.
13:01:33 <augur> and there's nothing you can do to fix that except smack the user upside the head
13:02:11 <augur> monochrom: also sometimes i think undergrads dont understand that their thoughts are confined to their own skulls
13:02:44 <Eduard_Munteanu> augur: higher-order types might not be countable though.
13:03:14 <augur> Eduard_Munteanu: no, they're not countable in the model, but the set of actual terms that can be written down is
13:03:19 <Eduard_Munteanu> I agree computable reals are countable, but what about e.g. functors?
13:03:31 <augur> Eduard_Munteanu: also countable
13:03:32 <Eduard_Munteanu> Hm.
13:03:34 <dmwit> "I can only write down countably many elements of this domain" is a stupid reason to believe "this domain is countable".
13:03:46 <augur> dmwit: i didnt say the domain is countable
13:03:59 <dmwit> Perhaps "domain" is a technical term.
13:04:07 <roconnor> mm_freak_: what FRP lib do you use?
13:04:15 <dmwit> I was using it as a stand-in for "set", but holding off on deciding whether we were using set theory or something else.
13:04:26 <augur> dmwit: i said in practice its countable because you can only get your hands on a countable subset
13:04:40 <dmwit> augur: and I said that's stupid
13:04:42 <augur> so the uncountable totality is computationally irrelevant
13:04:46 <Eduard_Munteanu> augur: so you're saying even functions extensionally equal to id are countable because the terms themselves are built inductively? That'd make sense.
13:05:25 <int-e> Cale: re: lambdabot being slow, if this happens regularly I'll have to ask the co-owners of the server about who's hogging so much memory (because I believe it's swapping occasionally, and it's not my doing; but I can't see who it is from my own VM)
13:05:59 <augur> Eduard_Munteanu: the term language is countable, so no type has uncountably many proof objects, even if the denotation has uncountably many elements
13:06:40 <roconnor> guys, the topology is far more important the the cardinality.
13:06:41 <augur> dmwit: why is it stupid
13:06:45 <augur> roconnor: :)
13:07:13 <dmwit> This last thing you said is much less stupid.
13:07:22 <dmwit> Was it intended to be the same thing, just said more carefully?
13:07:24 <augur> dmwit: but why is what i said before that stupid
13:07:46 <dmwit> Because "countable" isn't about what I can write down.
13:08:03 <augur> dmwit: ofcourse it is.
13:08:04 <dmwit> "computable" is about what I can write down, maybe.
13:08:15 <augur> countable ~ enumerable
13:08:23 <Eduard_Munteanu> augur: I should be able to build a [forall a. a -> a] then, no? If it can be built inductively, I guess there's also a notion of the smallest such term, no?
13:08:31 <monochrom> roconnor++
13:09:12 <Eduard_Munteanu> However I'm not sure how / if I can prove 'id a = a' is the smallest id.
13:09:53 <Eduard_Munteanu> e.g. vs id = \a -> a.
13:10:05 <Eduard_Munteanu> I guess that's because no ordering is defined, actually.
13:10:06 <augur> Eduard_Munteanu: you sure can build such a thing! and it will enumerate all of the proofs of that type. you can probably do some clever stuff (like enumerating only verifications) to eliminate beta redundancy
13:10:21 <mm_freak_> roconnor: mainly netwire
13:10:25 <dmwit> If you want to prove that the term "\a -> a" in language Y is the smallest term in language Y with a proof object in language X, you will have to model language Y in language X.
13:10:30 <augur> Eduard_Munteanu: i think if you do that you indeed get exactly one inhabitant: /\X.\x:X.x
13:11:02 <dmwit> Okay, I take that back.
13:11:07 <Vanadis> Hello
13:11:10 <dmwit> I don't know that's true, so I won't try to claim it.
13:11:59 <roconnor> The important bit about (Nat -> Bool) isn't that it is uncountable; the important bit is that it is compact.
13:12:00 <dmwit> Hiya, Vanadis.
13:12:17 <Vanadis> I'm starting to learn Haskell, I'm actually at page 5 of "Learn you a Haskell for great good", I guess I'll get to spend some time here ahah.
13:12:21 <augur> roconnor: depends on your purposes :)
13:12:31 <mm_freak_> Vanadis: welcome =)
13:12:42 <Vanadis> Thanks mm_freak_
13:13:13 <augur> roconnor: especially if you think that if a value lives in the denotation of X, then you can give a term that denotes that value. because that would be false
13:13:17 <dmwit> augur: What is this, some kind of monochromian "the answer depends on the question" nonsense? =)
13:13:20 <Vanadis> Well I better get back to it.
13:13:44 <augur> dmwit: lol
13:14:08 <augur> dmwit: surely the adjectival for of monochrome is monochromatic
13:14:12 <monochrom> hahaha, there is now an adjective based on me
13:14:46 <dmwit> "monochromium"?
13:14:54 <roconnor> augur: well, there is more to types than the set of values it contains.  Types also come with a topology.
13:15:20 <augur> roconnor: yes
13:15:41 <tomejaguar> roconnor: what's the topology on A -> B?
13:15:43 <dmwit> Despite the appeal of the puns, I still like "monochromian" best. =)
13:16:01 <Eduard_Munteanu> roconnor: do you mean uncountable stresses there's no injection from naturals, while compact that there's no injection to naturals?
13:16:08 <dmwit> ?whois monochrom
13:16:09 <lambdabot> Unknown command, try @list
13:16:13 <roconnor> tomejaguar: the topology of (Scott) continuous function from the space of A to the space of B.
13:16:17 <dmwit> Well, that's embarassing.
13:16:39 <augur> dmwit: monochromatic >|
13:16:43 <jrmithdobbs> why is building with cabal install --enable-split-objs; so so much slower? is it really that complex to split the objects out?
13:18:14 <monochrom> yes. more complex. or more disk operations. I don't know.
13:18:44 <Eduard_Munteanu> It's rather normal thing for C stuff.
13:18:58 <roconnor> Eduard_Munteanu: my thoughts are, though I'm a novice on the topic, that the debate between whether to consider only the computable inhabitants of (Nat -> Bool) or whether to consider "all" of the inhabitants is kinda irrelevent, because I think in the end the induced topological spaces are the same.  Very handwavy, very vague, don't ask too much of me here.
13:19:00 <Eduard_Munteanu> That's what distros generally do, I think. I'm doing it on Gentoo anyway.
13:19:37 <augur> roconnor: its not that irrelevant if you think that the denotations of types are all and only the denotations of its proofs
13:19:39 <monochrom> in C, if you write 10 functions, you get 10 objects. that's it.
13:19:50 <augur> andrej bauer talked about this a bit in a blog post
13:20:12 <monochrom> in Haskell, if you write 10 functions, GHC turns that into 100 C-level functions. now you have 100 objects.
13:20:17 <Eduard_Munteanu> monochrom: what debug symbols do Haskell object files have anyway?
13:20:27 <monochrom> I don't know
13:20:31 <jrmithdobbs> monochrom: ah, which is why it doesn't split them by default, makes sense
13:20:51 <roconnor> augur: Right; but if you are considering only the points of types as the entirety of the denotation of types, then you are missing the topology and missing out.
13:21:05 <monochrom> I only know that 10 Haskell functions become 100 C functions or machine functions. I have read the Cmm code and the assembly code.
13:21:06 <augur> maybe so :)
13:21:36 <monochrom> I don't know how many debug symbols, but let me just say as many debug symbols as 100 functions.
13:21:57 <derdon> hello. I am pretty sure with this assumption, but I just want to get sure: is there an empty Char value as there is an empty string? I guess it's not possible, but am not 100% sure
13:22:18 <dmwit> derdon: No, there is no empty Char value.
13:22:24 <Eduard_Munteanu> monochrom: why would that matter though? You only need to annotate entry points into a library and perhaps things that throw exceptions, as a rough approximation.
13:22:26 <derdon> k, thanks dmwit
13:22:35 <dmwit> You may use Maybe Char if you want something that can either be a Char or not.
13:22:52 <roconnor> For example; under suitable interpreation of equality, the types of all real numbers and the type of all real numbers that are either less than or equal to 0 or greater than or equal to 0 are the same, but the topology is different.
13:23:01 <monochrom> I don't know.
13:23:09 <roconnor> Granted I think this example needs to be refined a bit.
13:23:25 <roconnor> er I screwed up that statement
13:24:00 <roconnor> The *values* of the type all real numbers and the *values* of the type of all real numbers that are either less than or equal to 0 or greater than or equal to 0 are "the same", but the topology is different.
13:24:04 <derdon> dmwit: yeah, maybe that helps. actually, I planned something like ``a : "foo"`` where a is either a non-empty char or an empty char. but empty chars don't exist, so I have to think differently
13:24:18 <Eduard_Munteanu> Can't we have type theories with uncountable elements, btw?
13:24:33 <Eduard_Munteanu> Uncountable types, I mean.
13:25:01 <augur> blegh
13:25:03 <roconnor> Eduard_Munteanu: everyone agree that there are types which are not isomorphic to Nat nor any finite type.
13:25:10 <augur> i have to write something for my students for tomorrow. horrible :(
13:25:19 <augur> and im already committed to going to see Thor tonight!
13:25:21 <dmwit> derdon: You mean you want to prepend to a String? Or what?
13:25:21 <augur> woe is me
13:25:42 <roconnor> Eduard_Munteanu: the question is, how many values inhabit these uncountable types?
13:26:08 <roconnor> Eduard_Munteanu: and if there are only countable many values, do they deserve to be called uncountable types?
13:26:11 <dmwit> derdon: If so, you might like one of my favorite syntactic hacks: [x | condition] is either [] or [x] depending on condition. =)
13:26:22 <roconnor> Eduard_Munteanu: it is a bit of a silly debate. :)
13:26:28 <derdon> dmwit: yep, but using ``Maybe Char`` instead of Char as the return type of my function is what I do now. so no problem anymore now
13:26:33 <derdon> dmwit: uah, no :D
13:26:34 <roconnor> silly is the wrong word.
13:26:44 <Eduard_Munteanu> roconnor: this seems on your turf... how do you go about doing real analysis in a theorem prover? It seems to me things like Banach-Tarski would break if your reals had any semblance of a discrete structure.
13:26:57 <derdon> dmwit: my code will be reviewed at uni and should look as readable as possible
13:27:05 <roconnor> Eduard_Munteanu: my reals don't have any semblance of a discrete structure.
13:27:31 <dmwit> ah, dang
13:27:39 <dmwit> "cute" is my second-favorite goal after "readable" =)
13:27:41 <Eduard_Munteanu> roconnor: right, but as augur noted earlier, you can give them a discrete structure outside the language.
13:27:46 <roconnor> Eduard_Munteanu: even if the terms that inhabit my real numbers are discrete.
13:28:01 <augur> Eduard_Munteanu: what did i say
13:28:35 <Eduard_Munteanu> augur: you made the distinction between "it's countable in the language" vs "it's countable if we look at it from outside the language"
13:28:52 <augur> Eduard_Munteanu: yes,, sort of
13:29:24 <augur> its an interesting subtlely tho
13:29:44 <roconnor> Eduard_Munteanu: my functions which consume real numbers do not make any assumptions about said inputs being terms.
13:29:53 <augur> pi, for instance, is one of the enumerable reals if you let Nat -> Digit be your representation of reals
13:29:56 <monochrom> Eduard_Munteanu: but you're proving theorems just inside the language. the language doesn't notice anything odd, therefore the language can't help you prove anything odd.
13:30:42 <Eduard_Munteanu> monochrom: sure, I'm asking what you can conclude having proven a theorem in that language. Can you generalize?
13:30:55 <bearclaw> http://hackage.haskell.org/package/rmonad-0.8/docs/Control-RMonad.html <--is it still the 'recommended' way to achieve Monad implementations with constraints on type?
13:31:01 <monochrom> or you could say, you write down axioms that aren't strong enough to say "the reals are discrete at a meta-level".
13:31:27 <Eduard_Munteanu> Hm.
13:31:30 <roconnor> Eduard_Munteanu: I think it is very helpful to realize that Types are more than sets of values.  Because then you look at the real numbers and say: that topology has a countable basis, what's the problem?
13:31:44 <augur> also interesting, Eduard_Munteanu, is that you can often (always?) talk about the values that cant be given. in agda, for instance, you can prove theorems about all reals, even tho you cant give a proof term for most of them
13:32:17 <Eduard_Munteanu> Can I formulate it as: "the language has discreteness as an undecidable proposition, we choose it to be false and prove the result"?
13:32:56 <monochrom> don't choose it false. don't choose it true. just don't choose. leave it open. that's the most general.
13:33:27 <augur> also i think its impossible to prove in ITT that the denotation of Nat -> Bool is uncountable, because of the constructivity of ITT
13:33:30 <monochrom> and yes, this is a monochromian "don't answer to answer, just don't answer" :)
13:33:34 <Eduard_Munteanu> Hm. Perhaps I don't see how you can prove such a result without knowing they're discrete or not.
13:33:49 <bz> control.state.monad is making my head hurt
13:33:49 <augur> monochrom: nooooo
13:33:50 <monochrom> the result doesn't depend on knowing discreteness
13:33:52 <augur> monochromatic!
13:33:55 <Eduard_Munteanu> Or something along those lines.
13:34:28 <monochrom> if I want to prove "lim x->0 x = 0" I don't need to know, do I?
13:34:30 <Eduard_Munteanu> monochrom: well, what if I substitute rationals for your reals?
13:35:05 <augur> Eduard_Munteanu: curiously, the rationals arent the only enumerable reals
13:35:09 <Eduard_Munteanu> monochrom: you have to know they're complete I suspect.
13:35:12 <augur> depending on your choice of reals
13:35:23 <monochrom> you're confused. "it may be discrete" != "it may be rational"
13:35:42 <roconnor> http://muaddibspace.blogspot.ca/2009/10/cantors-diagonalization-proof-in-coq.html
13:35:52 <dmwit> bz: Pretty good, right?!
13:36:19 <roconnor> though augur said: "denotation of Nat -> Bool", and I'm not quite sure what he meant by that.
13:36:26 <Eduard_Munteanu> monochrom: yeah, but what sets reals apart from say, Nat -> Bool?
13:36:35 <augur> roconnor: what do you mean ?
13:36:35 <augur> :X
13:36:36 <monochrom> anyway, I still don't need to know, when I prove "exists x. x^2 = 2"
13:37:02 <augur> Eduard_Munteanu: reals are iso to nat->bool
13:37:03 <roconnor> augur: I believe it is easy to show in Coq that (Nat -> Bool) is not countable.
13:37:14 <monochrom> I don't know
13:37:24 <augur> roconnor: not constructively. that proof has two axioms which arent constructed witnesses
13:37:48 <augur> roconnor: you can prove it if you magic up some witnesses to nonconstructive things, of course, but you cant constructively prove those things actually exist
13:37:52 <monochrom> I know. "real" is an abstract type. it is not a type synonym of "nat -> bool". end of story.
13:38:09 <roconnor> augur: well it is a negative statement,  if you give me two functions that witness an isomorphism between (Nat -> Bool) and Nat, then I can derive an inhabitant of False.
13:38:10 <Eduard_Munteanu> augur: er, nevermind then... (but I still wonder if all the results you can prove about reals you can also prove about Nat -> Bool, if you don't have a model of reals in the first place)
13:38:28 <roconnor> augur: that it what it means for something to be not countable.
13:38:38 <augur> roconnor: ah yes thats true, you can do that.
13:38:45 <zq> dmwit: no. i dislike this feeling.
13:38:52 <roconnor> augur: I figured you meant something else, but I'm not sure.
13:38:56 <roconnor> not sure what.
13:38:58 <augur> youll never be able to prove the existential claim that there are reals that cant be constructed tho. thats all i meant.
13:39:10 <augur> just that if such a real COULD be constructed, it would be contradictory
13:39:33 <roconnor> ok
13:39:39 <Eduard_Munteanu> Also, I figure 2^N ~ R depends on a bit more context, no?
13:39:57 <monochrom> you can poke holes into my view by raising "but the language will let you prove 'real is uncountable', yet at the meta-level that 'real' is countable. what's going on?"  I forgot how to answer that, but it's an old question with an old answer.
13:40:10 <skypers> hey
13:40:15 <augur> roconnor: the existential proof in ITT requires you construct the witness, which is obviously the thing you're trying to prove cant be constructed
13:40:22 <roconnor> monochrom: It is the same answer to the existance of a countable model of ZFC.
13:40:31 <monochrom> yeah, it's all old news
13:40:41 <Eduard_Munteanu> monochrom: well, I was assuming you can't prove that :)
13:40:47 <monochrom> it's a dead horse, why are we beating it again today anyway?
13:41:00 <roconnor> monochrom: it is a kinda confusing horse.
13:41:09 <augur> roconnor: basically, exists x, x not in enum |R cant be proven, and you can prove this isnt so via the link you gave :)
13:41:34 <roconnor> what is enum |R?
13:41:39 <monochrom> I am, perhaps wrongly, presuming that anyone who bothers to discuss theorem proving already knows that dead horse.
13:41:44 <Eduard_Munteanu> augur: LEM lets you avoid constructing it trivially, not sure if you can avoid construction with a weaker axiom :/
13:41:50 <augur> roconnor: your choice of a way to enumerate the reals
13:41:57 <augur> Eduard_Munteanu: LEM isnt intuitionistically valid!
13:42:11 * hackagebot hsp 0.10.0 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.10.0 (JeremyShaw)
13:42:22 <Eduard_Munteanu> augur: mm, yes... but LEM + ITT is sound.
13:42:31 <augur> Eduard_Munteanu: yes, it's also not invalid :)
13:43:07 <augur> i wonder if there are different choices for representing the reals such that some reals are constructible in one but not the other, and vice versa
13:43:30 <roconnor> augur: I'm pretty sure that can be proven constructively.
13:43:30 <Eduard_Munteanu> augur: there's stuff that's really awkward in pure ITT, like surjections. How do you even talk about them without providing pseudoinverses?
13:43:31 <augur> probably -- Nat -> Bool vs Nat -> Digit will vary i think
13:43:56 <augur> Eduard_Munteanu: nothings really awkward in ITT without LEM, you just use the DN embedding!
13:44:14 <augur> or you abstract over LEM
13:44:27 <Eduard_Munteanu> augur: that's like proving LEM -> YourStatement, more or less :)
13:44:37 <augur> thats exactly proving LEM -> YourStatement
13:44:55 <monochrom> now I think about it, the language's 'uncountable' is not the meta's uncountable. that should do it.
13:44:57 <Eduard_Munteanu> It's just nicer because it's a monad too.
13:45:24 <augur> Eduard_Munteanu: the DN embedding is even nicer because you can build it into your types quite nicely, i think.
13:45:41 <dmwit> Huh. Why should Nat -> Bool and Nat -> Digit be so different?
13:46:12 <roconnor> augur: at least forall f : Nat -> (Nat -> Bool). exists g: (Nat -> Bool) . forall i. exists j. f(i)(j) /= g(j) ought to be easy to prove.
13:46:16 <augur> dmwit: well, it might not be, i dont know. it was a hunch
13:46:35 <Eduard_Munteanu> augur: so how about surjections? It's been bugging me ever since co-pumpkin (let's not highlight) mentioned it
13:46:57 <augur> Eduard_Munteanu: what about them?
13:47:11 * hackagebot reform-hsp 0.2.1 - Add support for using HSP with Reform  http://hackage.haskell.org/package/reform-hsp-0.2.1 (JeremyShaw)
13:47:13 * hackagebot robots-txt 0.4.0.0 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.4.0.0 (MarkWotton)
13:47:42 <Eduard_Munteanu> augur: you can't really talk about them without defining a pseudoinverse, which is much harder.
13:48:00 <roconnor> augur: \f -> {(\i -> negate f(i)(i)) & (\i -> {i & trivial})}
13:50:05 <flebron> Is there a common library for quadratic programming?
13:50:09 <Eduard_Munteanu> I honestly haven't run into much problems because of that, but it somehow seems too annoying for a simple thing.
13:51:23 <roconnor> augur: the case for real numbers ought to follow with the ususal manipulations.
13:52:12 * hackagebot happstack-hsp 7.2.3 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.2.3 (JeremyShaw)
13:58:04 <roconnor> augur: for the real numbers you should be able to construct a real number that is at least distance (1/3)^n away from the nth enumerated real number by adding up smaller and smaller pertibations.
13:58:46 <roconnor> augur: the infinite sum is computable because to get any finite approximation only requires adding up a finite partial sum.
13:59:11 <roconnor> augur: because the pertibations are made geometrically smaller and smaller in size.
13:59:32 <Eduard_Munteanu> roconnor: interesting... so if you built a colist of such approximations, you would actually get something a lot like the "real" reals
13:59:34 <augur> hm!
14:00:16 <roconnor> there is a whole bunch of trisection nonsense to work out, but I think it is all doable.
14:00:31 * Eduard_Munteanu has often wondered if codata was ever useful for proving stuff
14:01:24 <Eduard_Munteanu> Like the semantics of P vs ∞ P.
14:02:18 <Eduard_Munteanu> Things you can prove arbitrarily close to truth, just not exactly.
14:02:30 <ion> What’s cod̈ata again?
14:02:44 <roconnor> Eduard_Munteanu: I'm not quite sure I understood your statement, but it seems sensible since the set of "uncountably many values" of Nat -> Bool are all approximatable by a countable basis.
14:03:06 <roconnor> Again, the topology is what is important.
14:03:13 <Eduard_Munteanu> ion: possibly infinite, but productive terms
14:03:52 <Eduard_Munteanu> ion: what is that 'd̈' you just used? It's not really a 'd'.
14:04:03 <Eduard_Munteanu> It differs by about 2 pixels here :)
14:04:08 <ion> Like coöperation
14:04:16 <Eduard_Munteanu> Oh.
14:06:01 <stolaruk> Is it possible to put a "State WorldState Int" into "StateT WorldState IO Int"?
14:06:44 <Eduard_Munteanu> roconnor: basically I'm wondering if there are any interesting propositions which can be defined as coinductive types, and for which proofs are infinite.
14:07:06 <ion> @type state . runState
14:07:08 <roconnor> augur is probably thinking: But what if I plug in the enumeration of all provable repesentations of real numbers into that enumeration avoiding function that produces a provable representation of a real number?
14:07:08 <lambdabot> MonadState s m => State s a -> m a
14:07:14 * hackagebot hsx-jmacro 7.3.1 - hsp+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.3.1 (JeremyShaw)
14:07:22 <augur> roconnor: im not :p
14:07:33 <roconnor> okay, then only I am thinking that.
14:08:02 <quchen> stolaruk: Sounds like a job for 'hoist' in the general case.
14:08:16 <quchen> For special cases ion's suggestion will do as well.
14:08:19 <ion> @hoogle hoist
14:08:20 <lambdabot> No results found
14:08:28 <ion> @hackage hoist
14:08:29 <lambdabot> http://hackage.haskell.org/package/hoist
14:08:42 <quchen> @hackage this is just a text replacement
14:08:43 <lambdabot> http://hackage.haskell.org/package/this is just a text replacement
14:09:07 <fizruk> stolaruk, hoist generalize, see mmorph package
14:09:12 <stolaruk> ok
14:09:14 <Saizan> roconnor: do you know if the homotopy type of the topology you get from that interpretation of types correspond to the omega-groupoid you get from the HoTT interpretation?
14:09:16 <skypers> night folks
14:09:17 <Eduard_Munteanu> Did I tell you Fin ω ~ Nat is astonishingly easy to prove in Agda, for inductive Fins parametrized by Conats? I tend to tell that to everybody. :)
14:09:23 <roconnor> Eduard_Munteanu: there are interesting propositions that can be defined coinductively, but I'm not of aware of any that must be defined coinductively.  In my limited experience coinductive types can be replaced by function types.
14:09:28 <stolaruk> @ion thanks
14:09:28 <lambdabot> Maybe you meant: yow wn run nixon join id do
14:09:46 <Eduard_Munteanu> (where ω = succ ω)
14:10:23 <roconnor> Saizan: with our without HOTTer inductive types?
14:10:31 <roconnor> *or
14:10:34 <Eduard_Munteanu> Heh.
14:10:38 <augur> stolaruk: you address people like that, not like @stolaruk
14:10:47 <augur> or so the IRC gods command
14:10:57 <stolaruk> oh yes sorry about that
14:11:09 <Saizan> roconnor: Higher Inductive Types you mean? well, i'd be ok without but including codata :)
14:12:06 <roconnor> Saizan: I was about to say that without HOTTer types, all the homotopies of types are trivial. ... but I don't think that is true when you have polymorphic types.
14:12:11 <roconnor> Saizan: so I guess I don't know.
14:12:16 * hackagebot web-routes-hsp 0.24.2 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.24.2 (JeremyShaw)
14:12:18 * hackagebot happstack-foundation 0.5.2 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.5.2 (JeremyShaw)
14:12:46 <roconnor> Saizan: I've been thinking domain theory this whole time.
14:13:01 <roconnor> A topic of which I feel let down with regarding my CS degree. :/
14:13:18 <Saizan> roconnor: i kinda wonder the other way, what homotopy type do you get for the one-point compactification of naturals? the topology is not discrete but maybe you only have "reflexive" paths?
14:13:28 <roconnor> When I'm running the school of computer science, every undergrad will learn about domain theory.
14:13:39 <Saizan> hah
14:13:50 <Saizan> maybe i should wait to get a master then
14:14:10 <roconnor> also, Kleene Algebras.
14:14:58 <Eduard_Munteanu> That probably sounds a lot simpler than it actually is, no?:)
14:16:09 <roconnor> Saizan: I haven't grasped that inverse function for compactified natural numbers,  so my understanding of HOTT is curently in the "fucked" state.
14:16:52 <covi> How to write factorial using Y combinator?
14:17:15 <Saizan> roconnor: oh, which inverse function?
14:17:52 <Saizan> roconnor: i'm not talking about ||Nat||
14:17:52 <haasn> > fix (\f x -> case x of 0 -> 1; n -> n * f (n-1)) 5 -- covi
14:17:54 <lambdabot>   120
14:17:55 <Eduard_Munteanu> covi: do you want Y in particular, or fix?
14:17:59 <Saizan> roconnor: but about CoNat
14:18:00 <haasn> note: fix = Y
14:18:05 <roconnor> http://homotopytypetheory.org/2013/10/28/the-truncation-map-_-%E2%84%95-%E2%80%96%E2%84%95%E2%80%96-is-nearly-invertible/
14:18:07 <roconnor> oh
14:18:28 <roconnor> Saizan: indeed you are
14:18:34 <covi> Eduard_Munteanu: Y g = g (Y g), which should be the same as fix?
14:19:23 <jjauhien> Folks,  is there any standard function two map over 2D lists? Like map2D :: (a->b) -> [[a]] -> [[b]]. Or what is the prettiest way to write this?
14:19:29 <Eduard_Munteanu> covi: that is 'fix', but not Y. They coincide semantically, but Y as it is can't be typed properly.
14:19:41 <quchen> :t map . map -- jjauhien
14:19:42 <roconnor> Saizan: I'm not aware of any propery understanding of coinduction in the dependent setting.
14:19:42 <lambdabot> (a -> b) -> [[a]] -> [[b]]
14:19:45 <Saizan> roconnor: i guess reals are not topologically discrete either but they are still a hSet, so it shouldn't be suprising that CoNat is a hSet
14:19:51 <roconnor> *proper
14:20:01 <schell> when looking at a line like "#if __GLASGOW_HASKELL__ >= 707" does that mean "if glasgow haskell compiler 7.0.7 is being used..."?
14:20:09 <schell> or does it mean 7.7?
14:20:16 <jjauhien> quchen: hahaha, it was so easy. Thanks!
14:20:17 <roconnor> Saizan: do you mean the reals as a quotient type?
14:20:24 <quchen> 707 = 7.07, schell
14:20:31 <schell> quchen: thanks
14:20:37 <Eduard_Munteanu> covi: Y, Z, omega and that sort of stuff are usually defined in the context of *untyped* lambda calculus.
14:20:42 <Saizan> roconnor: i think so, yeah
14:20:55 <roconnor> right, they ought to be an hSet.
14:20:58 <quchen> schell: 7.7 is what will become 7.8 when it's officially released. Uneven numbers are development versions.
14:21:54 <schell> quchen: does that mean I can or cannot write something like #if __GLASGOW_HASKELL__ >= 770 ...?
14:22:03 <roconnor> Saizan: This is quite different from the homotopy real line which is the universal cover of the circle.
14:22:19 <quchen> schell: Sure you can write that, it's a standard CPP expression
14:22:34 <quchen> That line would not be very useful though, as I doubt GHC 7 will go up to .70 :-P
14:22:37 <Eduard_Munteanu> covi: https://en.wikipedia.org/wiki/Fixed-point_combinator#Existence_of_fixed-point_combinators  has more on this
14:23:19 <schell> well, i'm trying to check if it's 7.8, but i'd also like it to work for current HEAD, which is what i'm using for testing
14:23:28 <schell> which is 7.7
14:23:30 <covi> Eduard_Munteanu: thanks
14:23:40 <Saizan> roconnor: oh, really?
14:24:04 <schell> i'm guessing the ghc in the platform would be 763
14:24:10 <quchen> schell: If it works with HEAD, it'll work with 7.8 at this point.
14:24:20 <schell> right
14:24:40 <schell> i'm trying to write a patch for something that doesn't currently work in HEAD
14:24:43 <monoidal> schell: 707
14:24:47 <Eduard_Munteanu> covi: the short story is untyped has all those combinators and that you can't write them in STLC unless you explicitly allow recursion.
14:24:52 <monoidal> schell: 770 is for 7.70 I believe
14:25:08 <Eduard_Munteanu> covi: and even if you do, they're not the same combinators
14:25:47 <monoidal> oh I see quchen already said this.
14:25:54 <schell> monoidal: now i'm confused - is 763 equivalent to 7.6.3 and 770 equivalent to 7.7.x?
14:25:58 <Eduard_Munteanu> In Haskell you can write an Y-up-to-isomorphism.
14:26:15 <schell> monoidal: ah - you were answering my earlier question
14:26:16 <schell> :)
14:26:20 <monoidal> schell: 763 is a programming error
14:26:23 <quchen> schell: The naming scheme isn't terribly consistent. I haven't seen "763" yet though.
14:26:34 <monoidal> it should be 706, I don't think you can test for 7.6.3
14:26:42 <quchen> I think there were some exceptions around 7.2, but since then it was consistent I think.
14:27:01 <donri> yes it's 706 for 7.06 so to speak
14:27:15 <donri> 760 would be for 7.60
14:27:49 <roconnor> Saizan: well, the type for the universal cover of the circle has the property that by transitivity, all values are equal.
14:28:17 <roconnor> aka path connected.
14:29:35 <schell> is there any way i can check what the value of __GLASGOW_HASKELL__ is?
14:29:36 <Saizan> tbf if i think of the real line i think of something like that too
14:30:07 <donri> schell: whatIsIt = __GLASGOW_HASKELL__ ?
14:30:14 <donri> and :load in ghci or something
14:30:31 <donri> main = print __GLASGOW_HASKELL__
14:30:33 <Eduard_Munteanu> -XCPP perhaps?
14:31:23 <Eduard_Munteanu> I guess it has to be enabled even for simple substitution.
14:31:33 <donri> yes
14:32:19 * hackagebot CarneadesDSL 1.2 - An implementation and DSL for the Carneades argumentation model.  http://hackage.haskell.org/package/CarneadesDSL-1.2 (BasVanGijzel)
14:33:03 <lpaste> mangaba_leitosa pasted “comb for String and Text” at http://lpaste.net/95582
14:33:11 <schell> looks like in ghc HEAD it's still 707
14:33:16 <mangaba_leitosa> Eduard_Munteanu: how can I generate short Text values efficiently? I have two versions of the function 'comb n' for generating combinations of {A,T,C,G} of length n, for String and for Text. And for Text, the 'comb 9' is 2 times slower for String (see code in lpaste above)
14:33:51 <mangaba_leitosa> @let comb 0 = [[]]; comb n = [ i:tail | i <- ['A', 'T', 'C', 'G'], tail <- comb (n - 1) ]
14:33:53 <lambdabot>  Defined.
14:33:57 <evancz> It looks like Haskell Platform uses BSD license. Does that mean that all of the libraries it bundles are BSD? Or rather, does it mean that none of them are GPL?
14:33:58 <mangaba_leitosa> > comb 3
14:34:07 <lambdabot>   mueval-core: Time limit exceeded
14:34:22 <mangaba_leitosa> lambdabot can never run my code
14:34:29 <Clint> evancz: yes, none of them are copyleft
14:34:45 <evancz> I assume this is an official policy?
14:34:46 <Eduard_Munteanu> > T.subsequences "ATCG"
14:34:50 <lambdabot>   Not in scope: `T.subsequences'
14:34:50 <lambdabot>  Perhaps you meant one of these:
14:34:50 <lambdabot>    `T.seque...
14:35:19 <mangaba_leitosa> Eduard_Munteanu: here is what comb does: comb 3 == ["AAA","AAT","AAC","AAG","ATA","ATT","ATC","ATG","ACA","ACT","ACC","ACG","AGA","AGT","AGC","AGG","TAA","TAT","TAC","TAG","TTA","TTT","TTC","TTG","TCA","TCT","TCC","TCG","TGA","TGT","TGC","TGG","CAA","CAT","CAC","CAG","CTA","CTT","CTC","CTG","CCA","CCT","CCC","CCG","CGA","CGT","CGC","CGG","GAA","GAT","GAC","GAG","GTA","GTT","GTC","GTG","GCA","GCT","GCC","GCG","GGA","GGT","GGC","GGG"]
14:35:19 <evancz> Do you know if this causes issues for people?
14:35:23 <Clint> evancz: sadly yes
14:35:30 <tac> mangaba_leitosa: did you call?
14:35:32 <mangaba_leitosa> Eduard_Munteanu: not exactly like subsequences
14:35:56 <evancz> Clint: bah, I am not excited to be a part of this license stuff
14:36:10 <quchen> schell: Well that's because HEAD is 7.7
14:36:10 <mangaba_leitosa> tac: yes, I called '> comb 3' and multibot says time limit exceeded
14:36:25 <mangaba_leitosa> tac: multibot says this about all functions I define
14:36:27 <schell> quchen: i'm sorry i don't understand
14:36:30 <evancz> Clint: are there libraries that unfortunately do not make the platform because of this?
14:36:37 <evancz> like Pandoc?
14:37:03 <schell> HEAD is 7.7 but it defines __GLASGOW_HASKELL__ as 707?
14:37:03 <Clint> evancz: i suspect pandoc isn't in the platform for reasons other than licensing
14:37:13 <schell> wouldn't it be 770?
14:37:25 <quchen> 770 = 7.seventy
14:37:27 <baumax> would it be possible to write a printf version that uses {0} instead of C-style flags?  it would call show for every argument
14:37:28 <bz> n0m = n.m
14:37:30 <quchen> HEAD is 7.7
14:37:30 <evancz> Clint: maybe because of it being huge :)
14:37:41 <quchen> Or more precisely, HEAD = 7.7.date
14:37:57 <quchen> Or more precisely, HEAD is whatever is the end of the master branch of the GHC repo.
14:38:35 <schell> so we just lose that last digit of versioning
14:38:43 <quchen> Sort of, yes.
14:38:45 <schell> 7.6.x == 706
14:38:49 <mangaba_leitosa> Eduard_Munteanu: so, my 'comb 11' for String works 3 seconds, but 6 seconds for Text
14:38:52 <schell> 7.7.x == 707
14:38:52 <quchen> Yes.
14:38:55 <schell> etc
14:38:57 <schell> okay
14:38:58 <augur> > let l = "ATCG" in [ [x,y,z] | x <- l, y <- l, z <- l]
14:38:59 <lambdabot>   ["AAA","AAT","AAC","AAG","ATA","ATT","ATC","ATG","ACA","ACT","ACC","ACG","A...
14:39:25 <Cale> > replicateM 3 "ATCG"
14:39:26 <lambdabot>   ["AAA","AAT","AAC","AAG","ATA","ATT","ATC","ATG","ACA","ACT","ACC","ACG","A...
14:39:30 <quchen> The idea is that within one major release there aren't big changes that would justify having different "works with" versions I guess.
14:39:37 <augur> Cale: :)
14:39:47 <schell> quchen: thanks again
14:39:54 <Eduard_Munteanu> mangaba_leitosa: I'd use String for that and just pack the ones you need into Text.
14:39:58 <augur> @src replicateM
14:39:58 <lambdabot> replicateM n x = sequence (replicate n x)
14:40:51 <mangaba_leitosa> Cale: thanks :-) But I'm not asking how to define the function for String (I defined it here: http://lpaste.net/95582) but how to define such a function for Text as efficiently as for String
14:41:05 <chrisdone> augur: dead set is win, watching ep 2. brooker sure likes aphex twin, the whole soundtrack seems to be of his album tracks =)
14:41:11 <mangaba_leitosa> Eduard_Munteanu: I tried this and I got 6 seconds as well (3 seconds for generation + 3 seconds for 'map T.pack')
14:41:18 <augur> chrisdone: is it? hmm
14:41:25 <Cale> mangaba_leitosa: Oh, I missed your question. I just saw augur's list comprehension
14:41:35 <Eduard_Munteanu> mangaba_leitosa: what are you doing with them?
14:41:49 <donri> schell: consider the old 6.12 or the coming 7.10... i guess we could have 7100 but
14:42:05 <chrisdone> augur: maybe brian eno, too  "an ending"
14:42:17 <mangaba_leitosa> Eduard_Munteanu: comparing with words from my wordcount table, which I originally implemented for String, but then optimized by replacing String with Text :-)
14:42:19 <donri> (but then what do we do when ghc 71.0.0 is out!?)
14:42:39 <schell> haha
14:42:47 <Eduard_Munteanu> mangaba_leitosa: why not parse each word and see if it fits that pattern?
14:43:04 <mangaba_leitosa> Eduard_Munteanu: what do you mean by parse? :-)
14:43:04 <quchen> donri: This isn't Firefox we're talking about.
14:43:25 <chrisdone> augur: hm, waait, not brian eno. not global communication either. can't  put my finger on it. anyway, back  to the show =p
14:43:37 <augur> chrisdone: #haskell-blah :)
14:43:38 <mangaba_leitosa> Eduard_Munteanu: I need to compair all elements of (comb n) with all elements from the wordcount table
14:43:43 <mangaba_leitosa> compare
14:43:58 <Eduard_Munteanu> mangaba_leitosa: you could check each character is either A or T or C or G
14:44:16 <Eduard_Munteanu> mangaba_leitosa: and filter the ones with different length out
14:44:18 <mangaba_leitosa> Eduard_Munteanu: they are all of those characters only
14:44:48 <mangaba_leitosa> Eduard_Munteanu: :-)
14:44:55 <Eduard_Munteanu> mangaba_leitosa: doesn't 'comb n' generate all combinations of A/T/G/C of length n?
14:45:01 <mangaba_leitosa> Eduard_Munteanu: correct
14:45:18 <mangaba_leitosa> Eduard_Munteanu: and all my words in the wordcount table consist of A/T/G/C as well
14:45:32 <Eduard_Munteanu> mangaba_leitosa: how do they differ?
14:46:16 <Eduard_Munteanu> mangaba_leitosa: if they have a different length, then comparing length is going to be more economical
14:46:31 <mangaba_leitosa> Eduard_Munteanu: no, I only build the wordcount table for words of lentgh n :-)
14:46:48 <Eduard_Munteanu> mangaba_leitosa: so what are you using comb for?
14:46:49 <mangaba_leitosa> Eduard_Munteanu: so all my words are of length n an consisting of A/T/G/C chars only :-)
14:47:21 * hackagebot clckwrks 0.19.3 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.19.3 (JeremyShaw)
14:47:57 <pavonia> Is there a very basic symbolic calculation library for Haskell? I only need it to be able to simplify expression made of variables, +, -, *, /, and ^.
14:48:47 <mangaba_leitosa> Eduard_Munteanu: I calculate a metric for measuring the difference between pairs of words, and I need to find an element of comb which matches the maximum amount of words
14:48:52 <Ralith> pavonia: that doesn't sound very basic
14:49:09 <pavonia> Why not?
14:49:27 <Eduard_Munteanu> mangaba_leitosa: something like Hamming distance?
14:49:34 <Eduard_Munteanu> Or Levenshtein.
14:49:40 <mangaba_leitosa> Eduard_Munteanu: right
14:51:14 <mangaba_leitosa> Eduard_Munteanu: so, for example, if my list of words is [AACAA, ATAAA, AAACA, AAAGA], the pattern from (comb 5) that matches them best is "AAAAA"
14:52:18 <Eduard_Munteanu> mangaba_leitosa: you could count the frequency of each base in each position and use that to compute the best match, I think.
14:52:22 * hackagebot acid-state-tls 0.9.1 - Add TLS support for Data.Acid.Remote  http://hackage.haskell.org/package/acid-state-tls-0.9.1 (JeremyShaw)
14:52:23 <mangaba_leitosa> Eduard_Munteanu: but to detect this, I need to match AAAAA against all words to find out that the measure of difference is minimal (1) for this pattern
14:52:24 * hackagebot clckwrks-theme-bootstrap 0.2.13 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.2.13 (JeremyShaw)
14:52:26 * hackagebot clckwrks-theme-clckwrks 0.3.13 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-clckwrks-0.3.13 (JeremyShaw)
14:52:28 * hackagebot clckwrks-plugin-page 0.2.5 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.2.5 (JeremyShaw)
14:53:16 <mangaba_leitosa> Eduard_Munteanu: I'm going to consider better solution later, now I just want to perform a total match of all (comb n) with all the words of length n :-)
14:53:41 <mangaba_leitosa> Eduard_Munteanu: and here this Text efficiency issue arose
14:54:20 <Eduard_Munteanu> mangaba_leitosa: I think the issue here is the algorithm.
14:54:46 <mangaba_leitosa> Eduard_Munteanu: maybe :-)
14:55:17 <mangaba_leitosa> Eduard_Munteanu: but it would be useful for me to learn how to implement something like comb for Text efficiently anyway
14:55:47 <mangaba_leitosa> Eduard_Munteanu: because it turns out that Text makes some things faster (like my wordcount table), but some other things slower than String :-)
14:56:13 <mangaba_leitosa> Eduard_Munteanu: maybe I need to learn about another method of generating short Text values :-)
14:56:26 <Eduard_Munteanu> mangaba_leitosa: Text is an array of characters, it's going to be slower for very very small strings, because it copies the array to modify it.
14:57:03 <mangaba_leitosa> Eduard_Munteanu: ah, I see
14:57:22 * hackagebot clckwrks-plugin-media 0.6.1 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.1 (JeremyShaw)
14:57:24 * hackagebot clckwrks-plugin-ircbot 0.6.3 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.3 (JeremyShaw)
14:57:26 * hackagebot clckwrks-plugin-bugs 0.6.3 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.6.3 (JeremyShaw)
14:57:28 * hackagebot clckwrks-dot-com 0.3.3 - clckwrks.com  http://hackage.haskell.org/package/clckwrks-dot-com-0.3.3 (JeremyShaw)
14:57:49 <Eduard_Munteanu> mangaba_leitosa: this should be doable with a dynamic programming algorithm
14:58:13 <Eduard_Munteanu> Because you can define a notion of optimal substructure.
14:58:23 <mangaba_leitosa> Eduard_Munteanu: yes, Levenstein distance is usually calculated using dynamic programming...
14:58:47 <Eduard_Munteanu> No, I mean generating said element of 'comb'.
14:59:16 <mangaba_leitosa> Eduard_Munteanu: ah. For Text?
15:00:24 <Eduard_Munteanu> mangaba_leitosa: if it's Levenshtein distance, you can break up the problem into finding best fits for each base, since d(xab, yab) = d(x, y)
15:01:23 <Eduard_Munteanu> And since d(xy, ab) = d(x, a) + d(y, b) the changes simply sum up.
15:01:26 <covi> How does GHC implement closures? Putting all the frames on heap?
15:01:43 <Narvius> Is the hackagebot advertisement random, or when someone uploads something, or something else?
15:01:49 <Narvius> advertisements*
15:01:49 <hpc> covi: lambda lifting, i think
15:01:55 <Eduard_Munteanu> Narvius: on uploads
15:02:03 <Narvius> k, thanks.
15:02:11 <mangaba_leitosa> Eduard_Munteanu: I think that the probabilities of any char in every position are equal
15:02:19 <covi> hpc: what does that mean?
15:03:03 <Ghoul_> gimme some useless expensive pure code that doesn't generate much memory
15:03:16 <Eduard_Munteanu> mangaba_leitosa: yes, sure, that doesn't change things
15:03:37 <hpc> covi: it means stuff i am not very good at explaining ;)
15:03:38 <Ghoul_> I'm testing a theory that the order of strict let bindings can have a high impact on performance
15:03:44 <hpc> i think there's a haskellwiki page on it
15:03:48 <hpc> or a ghc trac page or something
15:03:55 <hpc> google certainly will find it
15:03:57 <bearclaw> will "do" automatically use bindM2 when possible?
15:04:13 <Ghoul_> bearclaw: no.
15:04:14 <hpc> bearclaw: "do" will use (>>=), (>>), and fail
15:04:22 <Ghoul_> but afaik bindM2 is probably just do.
15:04:32 <mangaba_leitosa> Eduard_Munteanu: are you talking about splitting the words to shorter fragments and calculating distances for those fragments, then summing them?
15:05:12 <Eduard_Munteanu> mangaba_leitosa: suppose you have ACG and CGT in your set. If you compute d(ACG, CGT), then for any 'xyz', d(xyz, CGT) = d(xyz, ACG) + d(ACG, CGT)
15:05:37 <mangaba_leitosa> Eduard_Munteanu: that's correct
15:05:46 <bearclaw> Is there a way to have "do  x <- return 1; y <- return 2; return x+y" perform the two first IOs in parallel? I was thinking wrapping IO into something
15:05:46 <jkarni> is there a way of having standalone GADT data constructors?
15:06:05 <hpc> bearclaw: async
15:06:05 <bearclaw> but it doesn't seem to be the case, >>= and >> don't get the proper arguments to have two IOs to perform
15:06:20 <jkarni> so that the constructor can be defined in someplace other than where the type is defined?
15:06:38 <Eduard_Munteanu> Er.
15:07:00 <Eduard_Munteanu> mangaba_leitosa: d(xyz, CGT) <= d(xyz, ACG) + d(ACG, CGT)
15:07:16 <mangaba_leitosa> Eduard_Munteanu: ah, right
15:07:58 <bearclaw> hpc: but the async has to be explicit
15:08:18 <hpc> bearclaw: of course
15:08:30 <hpc> automatic parellelization optimization is not a thing
15:08:34 <hpc> because it's really hard
15:09:09 <bearclaw> I believed that in the small do dsl it was possible in a restricted way
15:09:20 <bearclaw> ie two foo <-bar not depending on each other
15:11:29 <hpc> bearclaw: in your (x+y) example, are x and y going to be the result of effectful computation?
15:11:37 <bz> > sequence [Just 'a', Nothing, Just 'b']
15:11:37 <mangaba_leitosa> Eduard_Munteanu: but how can I use this fact to generate required patterns from comb?
15:11:38 <lambdabot>   Nothing
15:11:38 <hpc> ie, would you have parAdd :: IO Int -> IO Int -> IO Int
15:11:45 <hpc> or parAdd :: Int -> Int -> IO Int?
15:12:22 <bearclaw> hpc: yes, but I can live with having to force a wrapper type over the IO that tells "order is not important"
15:12:41 <mangaba_leitosa> Eduard_Munteanu: e. g. generate 'AAAAA' for ['AACAA, ATAAA, AAACA, AAAGA']
15:13:08 <bearclaw> I'm already in a very favorable position, my primitive operations return a "IO Future x"
15:13:22 <hpc> bearclaw: so with them being IO actions, you definitely want async
15:13:49 <hpc> parDo f a b = do x <- async a; y <- async b; return f a b
15:14:17 <hpc> parDo (+) (readFromFileX) (readFromFileY) = (return 700)
15:14:31 <donri> async gives you an Async, you need to "wait" on them
15:14:33 <ion> (parDo) (+) (readFromFileX) (readFromFileY) = (return) (700)
15:14:40 <bz> sequence [Just 'a', Nothing, Just 'b'] == Nothing because of haskell's laziness?
15:14:51 <ion> bz: no
15:14:56 <donri> or in this case, you could use "concurrently"
15:15:09 <Ghoul_> I want to give the garbage collector a really hard time by producing a lot of junk
15:15:13 <hpc> er yeah, i meant concDo
15:15:14 <ion> sequence [Just 'a', Nothing, Just 'b', error "bye"] == Nothing because of Haskell’s laziness
15:15:23 <hpc> bz: it's the semantics of (>>=)
15:15:29 <hpc> which sequence uses under the hood
15:15:46 <bz> Nothing >>= _ = Nothing
15:16:11 <bz> i don't get why it doesn't just return ['a']
15:16:21 <bz> s/return/evaluate to/
15:16:38 <hpc> > Just 1 >> Just 2
15:16:39 <lambdabot>   Just 2
15:16:48 <hpc> > Just 1 >>= \x -> Just (x + 1)
15:16:50 <lambdabot>   Just 2
15:16:57 <hpc> > Just 1 >>= \_ -> Just 2
15:16:59 <lambdabot>   Just 2
15:17:04 <hpc> > Just 1 >>= \_ -> Nothing
15:17:05 <lambdabot>   Nothing
15:17:15 <hpc> does that perhaps make it more clear why it can't just stop early?
15:17:17 <ion> > do { x0 <- Just 'a'; x1 <- Nothing; x2 <- Just 'b'; x3 <- error "bye"; return [x0, x1, x2, x3] }
15:17:19 <lambdabot>   Nothing
15:17:25 * hackagebot hsqml 0.2.0.1 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.2.0.1 (RobinKay)
15:17:40 <bz> ion: what would x1 be?
15:17:52 <FreeFull> sequence [a,b,c] is the same as a >> b >> c
15:17:54 <donri> > msum [Just 'a', Nothing, Just 'b']
15:17:55 <lambdabot>   Just 'a'
15:18:38 <ion> @undo do { x0 <- Just 'a'; x1 <- Nothing; x2 <- Just 'b'; x3 <- error "bye"; return [x0, x1, x2, x3] }
15:18:38 <lambdabot> Just 'a' >>= \ x0 -> Nothing >>= \ x1 -> Just 'b' >>= \ x2 -> error "bye" >>= \ x3 -> return [x0, x1, x2, x3]
15:18:57 <ion> bz: Nothing >>= \x1 -> …
15:19:21 <bz> ion:  = Nothing
15:19:27 <ion> freefull: sequence_ [a,b,c] would be
15:19:45 <ion> Well, actually a >> b >> c >> return ()
15:19:59 <ion> bz: indeed
15:20:14 <ion> bz: So x1 doesn’t end up being anything.
15:20:21 <mangaba_leitosa> Cale: btw why replicateM generates combinations? :-)
15:20:32 <donri> > sequence [Just 'a', Just 'b']
15:20:32 <bz> ion: :t x1 :: Maybe Char
15:20:33 <lambdabot>   Just "ab"
15:20:43 <mangaba_leitosa> Cale: I would expect it to ask just like Data.List.replicate for lists :-)
15:20:48 <mangaba_leitosa> Cale: to act
15:21:02 <FreeFull> Ah, I forgot
15:21:23 <ion> mangaba_leitosa: The semantics of (>>=) for [] aren’t like that.
15:21:52 <bz> > do { x0 <- Just 'a'; x1 <- Nothing; x2 <- Just 'b'; x3 <- error "bye"; return [x0, x1, x2, x3] }
15:21:53 <lambdabot>   Nothing
15:22:05 <bz> > do { x0 <- Just 'a'; x1 <- Nothing; x2 <- Just 'b'; return [x0, x1, x2] }
15:22:07 <lambdabot>   Nothing
15:22:18 <Cale> mangaba_leitosa: Well, sequence :: (Monad m) => [m a] -> m [a] produces an action which when run will run each of the actions in the given list in turn, producing a list of their results
15:22:33 <Cale> mangaba_leitosa: In the list monad, "running" a list means picking an element from it (in all possible ways)
15:22:39 <mangaba_leitosa> > sequence [[1,2,3], [1,2,3]]
15:22:41 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
15:22:54 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
15:22:54 <mangaba_leitosa> Cale: ah, OK :-) thanks
15:22:55 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
15:23:06 <ion> > do { a <- [1,2,3]; b <- [4,5]; c <- [6,7,8]; return [a,b,c] }
15:23:08 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
15:23:37 <ion> > [1,2,3] >>= \a -> [4,5] >>= \b -> [6,7,8] >>= \c -> return [a,b,c]
15:23:39 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
15:24:08 <bz> ion: it doesn't make sense why in one case the retval :: Maybe [a] and the other case the reval :: Maybe a
15:24:10 <mangaba_leitosa> ion: I'm not sure how replicateM and sequence generate the 'return [a,b,c]' part for you
15:24:20 <bz> oh nvm, Nothing :: Maybe [a] too
15:24:23 <ion> mangaba_leitosa: Look at their source.
15:24:27 <ion> @src sequence
15:24:27 <lambdabot> sequence []     = return []
15:24:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:24:28 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
15:24:51 <ion> bz: What do you mean?
15:24:57 <donri> > Nothing :: Maybe (Either (a -> b) ([(Int,String)]))
15:24:59 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
15:24:59 <lambdabot>    arising from a use ...
15:25:07 <donri> :(
15:25:33 <bz> ion: i associated the Nothing constructor with Maybe a and not Maybe [a]
15:25:52 <mangaba_leitosa> ion: aha, thanks
15:26:05 <ion> bz: Maybe a is Maybe [b] given a = [b]
15:26:31 <bz> yeah, i realized that right after i hit enter three messages ago
15:27:19 <no-n> is there all the punctuation chars in a string somewhere in the libs?
15:27:21 <mangaba_leitosa> > [1,2,3] >>= \v -> [[4,5,6]] >>= \vs -> v:vs
15:27:23 <lambdabot>   [1,4,5,6,2,4,5,6,3,4,5,6]
15:27:35 <mangaba_leitosa> > sequence [[1,2,3],[4,5,6]]
15:27:37 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
15:27:42 <mangaba_leitosa> hmm
15:27:54 <flebron> Is there a more idiomatic version of "filter id"?
15:27:55 <mangaba_leitosa> ah, I forgot return
15:28:14 <mangaba_leitosa> > [1,2,3] >>= \v -> [[4,5,6]] >>= \vs -> return (v:vs)
15:28:15 <lambdabot>   [[1,4,5,6],[2,4,5,6],[3,4,5,6]]
15:28:35 <hpc> flebron: unsafeCoerce . catMaybes . unsafeCoerce
15:28:36 <hpc> ;)
15:28:40 <mangaba_leitosa> still not there :-)
15:29:15 <flebron> hahaha
15:29:20 <schell> how does one import modules from ghc api  (like GHC, Desugar, PprTyThing, etc) into ghci?
15:29:45 <schell> i get an error like "Could not find module ‛GHC’ It is a member of the hidden package ‛ghc-7.7.20131106’."
15:31:07 <Eduard_Munteanu> mangaba_leitosa: if you count how many times each base appears in a given position, you can solve it for each base
15:31:16 <donri> schell: try ghci -package ghc
15:31:18 <donri> or something like that
15:31:24 <donri> may need full version
15:31:35 <Eduard_Munteanu> mangaba_leitosa: take an example...
15:31:41 <schell> donri: that worked!
15:31:43 <schell> thanks
15:32:20 <mm_freak_> chrisdone: any reason why threepenny-gui doesn't use reactive-banana?
15:33:26 <Eduard_Munteanu> mangaba_leitosa: for each position you write: n_a A + n_c C + n_g G + n_t T
15:34:21 <mangaba_leitosa> Eduard_Munteanu: and n_a an n_c are calculated for all words in my wordcount table?
15:34:54 <mangaba_leitosa> Eduard_Munteanu: what if they turn out to be all equal? :-)
15:34:59 <Eduard_Munteanu> mangaba_leitosa: now if you put A in the same position in your comb element: (n_a + 1) A + n_c C + n_g G + n_t T
15:36:34 <Eduard_Munteanu> mangaba_leitosa: er, you get a distance for the first element of: n_c + n_g + n_t
15:37:35 <Eduard_Munteanu> mangaba_leitosa: therefore, if you want to minimize the distance, you pick a base that minimizes the sums of count of the rest.
15:38:17 <Eduard_Munteanu> mangaba_leitosa: you can even try all four possibilities
15:39:07 <Eduard_Munteanu> mangaba_leitosa: then you move on to the next base in your string
15:39:14 <Eduard_Munteanu> mangaba_leitosa: makes sense?
15:39:21 * Eduard_Munteanu is a bit tired now
15:39:27 <mangaba_leitosa> Eduard_Munteanu: but n_a in the first position means that therare are n_a words in my table beginning with 'A'?
15:39:36 <bearclaw> hmf, without using async, even with my futures I can't get it to work, there is no way to express an ordering of startop1 ; startop2; waitop1; waitop2;
15:39:38 <Eduard_Munteanu> mangaba_leitosa: yes
15:40:17 <jjauhien> @pf and[e /= Nothing | r <- rs, e <-r]
15:40:18 <lambdabot> Maybe you meant: pl bf
15:40:26 <jjauhien> @pl and[e /= Nothing | r <- rs, e <-r]
15:40:26 <lambdabot> and [e /= Nothing | r <- rs, e <- r]
15:40:58 <mangaba_leitosa> Eduard_Munteanu: this should work if I need a common pattern for the entire table...
15:41:16 <jjauhien> @pl length rs == 9 && all isRowCorrect rs
15:41:16 <lambdabot> length rs == 9 && all isRowCorrect rs
15:41:17 <donri> bearclaw: no yeah you need concurrency for this
15:41:43 <jjauhien> @pl \rs -> length rs == 9 && all isRowCorrect rs
15:41:43 <lambdabot> ap ((&&) . (9 ==) . length) (all isRowCorrect)
15:41:52 <Eduard_Munteanu> mangaba_leitosa: yeah, the nice thing is Levenshtein distance is computed base-wise
15:41:56 <mangaba_leitosa> Eduard_Munteanu: but that's not what I need. there can be groups of words in the table each closely matching a different patern
15:42:19 <Eduard_Munteanu> mangaba_leitosa: ok, so?
15:43:01 <mangaba_leitosa> Eduard_Munteanu: so I'm still not sure how counting 'n_a A + n_c C + n_g G + n_t T' for each position of the entire table helps in constructing anything
15:43:20 <mangaba_leitosa> Eduard_Munteanu: maybe I first need to group words somehow?
15:44:26 <mangaba_leitosa> Eduard_Munteanu: but to group them, I need to match them against either each other or patterns from comb :-)
15:44:52 <Eduard_Munteanu> mangaba_leitosa: wait, I should have asked... how do you define "closest"?
15:45:13 <Eduard_Munteanu> mangaba_leitosa: minimum distance, maximum distance, sum of distances?
15:45:29 <Eduard_Munteanu> I was going for sum but I realize that's not what you want.
15:45:30 <mangaba_leitosa> minimum distance with some pattern
15:46:26 <Eduard_Munteanu> mangaba_leitosa: so given a pattern 'p', your metric is min(d(p, i))_i ?
15:47:49 <mangaba_leitosa> Eduard_Munteanu: yes, I guess so
15:48:04 <jjauhien> @pl \rs -> and[e /= Nothing | r <- rs, e <-r]
15:48:04 <lambdabot> and . (: [e <- r]) . (e /=) . ((Nothing | r) <-)
15:48:07 <Eduard_Munteanu> mangaba_leitosa: if so, then compute the count and min for each position, and pick a base corresponding to the minimal count.
15:49:16 <Eduard_Munteanu> mangaba_leitosa: e.g. if the distances are 3, 4, 1, 6, then min = (1, G), so you pick G for this position.
15:49:33 <Eduard_Munteanu> mangaba_leitosa: s/distances/counts/
15:49:45 <mangaba_leitosa> Eduard_Munteanu: thanks, will try. Before trying I'm still not sure about the case where all 'n_a + n_c + n_g + n_t' become equal for all positions for some rrason
15:49:48 <bearclaw> ah, it works actually (the async magic is supposed to be handled by future), I'm just bad at discriminating 500ms and 1s :)
15:49:59 <mangaba_leitosa> Eduard_Munteanu: I don't know if it can happen or not
15:50:04 <Eduard_Munteanu> mangaba_leitosa: it can
15:50:17 <Eduard_Munteanu> mangaba_leitosa: what do you want to generate then?
15:50:26 <Eduard_Munteanu> The first match? All of them?
15:50:35 <flebron> So I'm trying to use these.... let's call it "spartan" bindings for libSVM http://hackage.haskell.org/package/bindings-svm-0.2.1/docs/Bindings-SVM.html . svm_train takes a Ptr C'svm_problem. How do I get a Ptr C'svm_problem? The latter type is a type there, but I can construct C'svm_problems, not Ptrs to it.
15:52:49 <mangaba_leitosa> Eduard_Munteanu: if in such a situation all words in the table can be grouped according to their closest match to e. g. in two groups closest to two different patterns, then I need both patterns if the groups are equal in size and one pattern if one group is larger
15:57:24 <Eduard_Munteanu> mangaba_leitosa: hm, if n_a + k = n_c + k = n_g + k = n_t + k, you can remove the k and pick the smallest one...
15:57:59 <Eduard_Munteanu> mangaba_leitosa: use it, then remove it so you only remain with 3 counts. Pick the next smallest one and repeat
15:58:15 <mangaba_leitosa> Eduard_Munteanu: for example, if the table is [AACAA, ATAAA, AAACA, AAAGA, TTCTT, TATTT, TTTCT, TTTGT], then I need patterns AAAAA and TTTTT because they are both closest match to a maximum number of words
15:59:13 <mangaba_leitosa> Eduard_Munteanu: each pattern minimize the difference with 4 words of the table
15:59:59 <Eduard_Munteanu> mangaba_leitosa: I'm not sure what your metric is :/
16:00:51 <Eduard_Munteanu> mangaba_leitosa: perhaps you want to generate patterns as long as the metric or difference in metric is smaller than a number?
16:01:29 <Eduard_Munteanu> mangaba_leitosa: because arguably I could have picked AAACA and TTTCT too
16:01:48 <bz> oh wow
16:02:13 <Eduard_Munteanu> mangaba_leitosa: I think you want to pick all the solution with an equal minimum distance?
16:02:18 <bz> the list comprehension syntax really fits well with the definition of bind for lists
16:02:35 <bz> i wonder if it's coincidence
16:03:15 <mangaba_leitosa> Eduard_Munteanu:  d(AAAAAA, word_from_list) is minimal (==1) for the maximum number of words from the list (compared to other possibe patterns)
16:03:16 <Eduard_Munteanu> bz: it isn't...
16:03:42 <Eduard_Munteanu> bz: there are arbitrary monad comprehensions too
16:04:14 <mangaba_leitosa> Eduard_Munteanu: ah, I see what you mean
16:04:27 <mangaba_leitosa> Eduard_Munteanu: indeed AAACA is 0 for some words :-)
16:05:20 <int-e> and XXXXX has distance 5 to all of them.
16:05:26 <mangaba_leitosa> Eduard_Munteanu: I want to maximize the number of words  but minimize the distance :-)
16:06:20 <Eduard_Munteanu> mangaba_leitosa: you'll find it that two words are equivalent in a position if the counts of said bases are equal at that position.
16:06:53 <mangaba_leitosa> Eduard_Munteanu: for example, both AAAAA TTTTT match 4 words minimizing the distance. The pattern AAACA is a closer match to some words (actually, just one) but it matches less words
16:08:50 <Eduard_Munteanu> mangaba_leitosa: how do you define matching for words?
16:09:24 <Eduard_Munteanu> I can't tell unless you're proposing patterns like AAA-A
16:09:38 <mangaba_leitosa> Eduard_Munteanu: for words of varying length I'll need to use levenstein's distance. But for words of equal length, just the number of mismatching positions will work
16:10:48 <Eduard_Munteanu> mangaba_leitosa: um, that's the same as Levenshtein
16:10:55 <absence> is the errors package the best choice for handling errors?
16:11:14 <mangaba_leitosa> Eduard_Munteanu: right. just easier to calculate for equal length words
16:12:22 <Eduard_Munteanu> mangaba_leitosa: so what did you mean by AAACA having a smaller distance, but less matches?
16:13:06 <mangaba_leitosa> Eduard_Munteanu: I mean that the distance with the pattern AAACA can be 0, but only for a single word
16:13:23 <mangaba_leitosa> Eduard_Munteanu: whereas the distance with AAAAA is greater (1), but for 4 words :-)
16:13:36 <mangaba_leitosa> Eduard_Munteanu: so, maybe sum of distances indeed
16:13:50 <Eduard_Munteanu> mangaba_leitosa: where does 4 come from there?
16:14:30 <mangaba_leitosa> Eduard_Munteanu: the d(AAAAA, word) = 1 for the first 4 words of  [AACAA, ATAAA, AAACA, AAAGA, TTCTT, TATTT, TTTCT, TTTGT]
16:17:51 <mangaba_leitosa> Eduard_Munteanu: ah. no, not sum of distances. it's rather 'length . mimumumBy(distance "AAAA") . word_list'
16:17:51 <mangaba_leitosa> or even length . filter ((== mimumumBy(distance "AAAA") word_list) $ word_list :-)
16:20:33 <Eduard_Munteanu> mangaba_leitosa: I'm not sure I understand the metric you want.. you have two criteria, how do you combine them?
16:21:52 <Ghoul_> well, I was able to benchmark my hypothesis https://gist.github.com/kvanberendonck/7441084 but I dont think the generate b (\x -> x * 5 + 3) part is producing enough junk
16:22:00 <mangaba_leitosa> Eduard_Munteanu: maybe I need to try writing real code first before formulating it in words :-)
16:22:23 <mangaba_leitosa> Eduard_Munteanu: will now try with this slow "comb" function, it seems trivial
16:22:31 <mangaba_leitosa> Eduard_Munteanu: then forumulate it in words :-)
16:22:39 <Eduard_Munteanu> Yeah, that should do.
17:18:24 <schell> what is the advantage of using unsafeFreeze over freeze in Data.Array.MArray?
17:20:18 <dibblego> has the OverloadedLists extension been implemented?
17:21:49 <haasn> schell: performance, usually
17:22:16 <schell> haasn: that's what I guessed - tho it's not available any longer
17:22:36 <haasn> schell: freeze takes a complete copy, thus ensuring the resulting array is frozen. unsafeFreeze gives you a direct handle on the (previously) mutable array, so if you mutate it further you break the universe
17:22:38 <schell> i wonder if that means freeze is just as fast, or unsafeFreeze isn't worth the danger
17:22:48 <nkpart> dibblego: it's in https://ghc.haskell.org/trac/ghc/browser/ghc/docs/users_guide/7.8.1-notes.xml
17:23:03 <dibblego> nkpart: oh thanks
17:23:10 <schell> haasn: i don't want to break the universe
17:32:38 <alkabetz> schell: If you have to think about it this much, safe 'freeze' is probably the way to go :)
17:33:03 <schell> alkabetz: thanks - i'm making a patch for someone else's lib
17:33:08 <alkabetz> (Er, not specifically you.  One having to convince oneself that 'unsafeAnything' is okay is often a signal that it’s not okay.)
17:33:19 <schell> haha, right
17:33:56 <schell> i had a counselor tell me one time, "If you have to ask yourself if you're too drunk to drive, you are."
17:34:10 <hpc> schell: but then you shouldn't listen to yourself because you are drunk
17:34:15 <hpc> and therefore it is safe to drive
17:34:21 <schell> logic
17:34:26 <schell> it's dead right
17:35:45 <hpc> other good activities while drunk include making cruel bets with death row inmates and transporting a fox, rooster, and head of cabbage across a river in a boat
17:36:44 <schell> sounds interesting - flew right over my head though
17:36:55 <hpc> other logic puzzles
17:37:07 <hpc> well, logic puzzles not other
17:37:12 * hpc sleeps now
17:37:19 <schell> :)
18:03:13 <Bor0> hi. assume that I have "checkAuth username password" a function that connects to mysql and checks if user and password are existing in db. this function returns IO(), what is the best approach to make this function usable in main? I thought of checkAuth to return Bool and then do in main if checkAuth == True then "success" else "cant login", but is this the right way?
18:10:43 <alkabetz> Having it return an 'IO Bool' sounds reasonable to me.
18:16:45 <BigJ> What am I doing wrong here, I am just trying to add the elements of a list and append the result to the end of the original list.               sumListEnd (x:xs) = (x + sumListEnd xs) ++ [xs].
18:17:40 <prooftechnique> @let sumListEnd xs = xs ++ [sum xs]
18:17:42 <lambdabot>  Defined.
18:17:50 <prooftechnique> > sumListEnd [1..10]
18:17:59 <lambdabot>   mueval-core: Time limit exceeded
18:18:10 <prooftechnique> > sumListEnd [1..10]
18:18:17 <lambdabot>   mueval-core: Time limit exceeded
18:19:13 <ion> > iterate sumListEnd [1]
18:19:22 <lambdabot>   mueval-core: Time limit exceeded
18:19:48 <prooftechnique> BigJ: Anyway, switch the order of the append, don't wrap xs in [], and just use sum xs
18:21:20 <prooftechnique> > 2 + 2
18:21:23 <lambdabot>   4
18:21:28 <prooftechnique> > sumListEnd [1..10]
18:21:35 <lambdabot>   mueval-core: Time limit exceeded
18:21:39 <prooftechnique> Weird. I wonder why that times out
18:23:09 <fizruk> > [1..10] ++ [ sum [1..10 ]
18:23:11 <lambdabot>   <hint>:1:26:
18:23:11 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
18:23:16 <fizruk> > [1..10] ++ [ sum [1..10] ]
18:23:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,55]
18:23:20 <prooftechnique> @let sumListEnd xs = reverse . (sum xs :) $ reverse xs
18:23:25 <lambdabot>  .L.hs:212:1: Warning:
18:23:26 <lambdabot>      Pattern match(es) are overlapped
18:23:26 <lambdabot>      In an equat...
18:23:31 <prooftechnique> @undef
18:23:31 <lambdabot> Undefined.
18:23:36 <prooftechnique> @undef sumListEnd
18:23:36 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
18:23:42 <prooftechnique> @undefine
18:23:42 <lambdabot> Undefined.
18:23:45 <prooftechnique> @let sumListEnd xs = reverse . (sum xs :) $ reverse xs
18:23:47 <lambdabot>  Defined.
18:23:48 <fizruk> > let xs = [1..10] in xs ++ [ sum xs ]
18:23:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,55]
18:23:51 <prooftechnique> > sumListEnd [1..10]
18:23:58 <lambdabot>   mueval-core: Time limit exceeded
18:24:23 <prooftechnique> > [1..10]
18:24:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:24:44 <fizruk> > let sumListEnd xs = xs ++ [sum xs] in sumListEnd [1..10]
18:24:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,55]
18:25:55 <BigJ> prooftechnique, I am aware of the library function, I am writing this function in an attempt to understand both pattern matching and recursion
18:26:15 <alkabetz> prooftechnique: If 'xs' has 10 elements, how many elements does 'xs ++ [sum xs]' have?
18:27:11 <prooftechnique> 11?
18:27:21 <Bor0> alkabetz, how can I check an IO Bool afterwards? I say let x = checkUser... and then try if x == True then "success" else "cant login", but it says it can't match IO Bool to Bool
18:27:54 <alkabetz> prooftechnique: Okay.  So xs ++ [sum xs] has 11 elements.  Now, you’ve defined xs to be equal to xs ++ [sum xs].  Do you see the problem?
18:28:44 <alkabetz> Bor0: Have a look at https://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F.
18:28:52 <prooftechnique> When did I do that? ghci had no problem with either of the definitions I used
18:29:22 <alkabetz> prooftechnique: Ah, excuse me, I misread
18:29:37 <Bor0> I thought so, so I am doing something wrong. but how can I check the result of checkUser and do actions depending on it?
18:29:38 <prooftechnique> Haha, no worries. *That* would be a serious mistake :D
18:30:12 <alkabetz> > @undef
18:30:14 <lambdabot>   <hint>:1:1: parse error on input `@'
18:30:16 <prooftechnique> @undefine
18:30:17 <lambdabot> Undefined.
18:30:30 <alkabetz> @let sumListEnd xs = xs ++ [sum xs]
18:30:33 <lambdabot>  Defined.
18:30:39 <alkabetz> > sumListEnd [1 .. 10]
18:30:47 <lambdabot>   mueval-core: Time limit exceeded
18:30:49 <alkabetz> Okay, that’s really weird.
18:30:51 <prooftechnique> Weird, right?
18:30:56 <alkabetz> Because that totally works in GHCi.
18:31:10 <alkabetz> I wonder if you found a bug in lambdabot.
18:31:31 <prooftechnique> It looks like it's just taking too long to do something and mueval doesn't like it
18:31:36 <prooftechnique> Can't imagine what, though
18:31:38 <ion> > sumListEnd []
18:31:46 <lambdabot>   mueval-core: Time limit exceeded
18:31:47 <ion> > sumListEnd [] :: [Int]
18:31:54 <lambdabot>   mueval-core: Time limit exceeded
18:31:56 <alkabetz> >sum []
18:32:09 <alkabetz> > sum []
18:32:11 <lambdabot>   0
18:32:13 <fizruk>  > let sumListEnd xs = xs ++ [sum xs] in sumListEnd [1..10]
18:32:16 <fizruk> > let sumListEnd xs = xs ++ [sum xs] in sumListEnd [1..10]
18:32:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,55]
18:32:21 <prooftechnique> Anyway, BigJ, let's look at what you've got here: sumListEnd (x:xs) = (x + sumListEnd xs) ++ [xs]
18:32:25 <ion> @let f = const 42
18:32:27 * alkabetz scratches head
18:32:29 <lambdabot>  Defined.
18:32:30 <ion> > f 1
18:32:32 <lambdabot>   Ambiguous occurrence `f'
18:32:32 <lambdabot>  It could refer to either `L.f', defined at L.hs:1...
18:32:38 <ion> @let foo = const 42
18:32:39 <lambdabot>  Defined.
18:32:41 <ion> > foo 1
18:32:48 <lambdabot>   mueval-core: Time limit exceeded
18:32:51 <ion> ok
18:32:53 <ion> @undefine
18:32:54 <lambdabot> Undefined.
18:32:55 <alkabetz> @botsmack
18:32:55 <lambdabot> :)
18:32:57 <prooftechnique> BigJ: What is the type of sumListEnd?
18:33:31 <prooftechnique> Specifically, notice (x + sumListEnd xs)
18:34:14 <prooftechnique> sumListEnd is a function Num a => [a] -> [a], yes?
18:34:26 <BigJ> yes
18:34:40 <prooftechnique> Okay, so consider the type of (+)
18:34:44 <BigJ> list as the first argument and should return a list
18:34:45 <prooftechnique> :t (+)
18:34:50 <lambdabot> Num a => a -> a -> a
18:35:04 * hackagebot CarneadesIntoDung 0.9 - A translation from the Carneades argumentation model into Dung's AFs.  http://hackage.haskell.org/package/CarneadesIntoDung-0.9 (BasVanGijzel)
18:35:06 * hackagebot Win32-extras 0.2.0.0 - Provides missing Win32 API  http://hackage.haskell.org/package/Win32-extras-0.2.0.0 (KidoTakahiro)
18:35:11 <BigJ> ok so + expects a number
18:35:15 <BigJ> or Num
18:35:18 <prooftechnique> Right
18:35:22 <BigJ> and I am returning a list
18:35:25 <prooftechnique> Exactly
18:36:09 <prooftechnique> Now, you can implement your own sum to use within the function, using explicit recursion, a fold, whatever you like
18:37:04 <prooftechnique> Say sumListEnd xs = xs ++ [mySum xs] where mySum (x:xs) = x + mySum xs
18:37:11 <prooftechnique> @let sumListEnd xs = xs ++ [mySum xs] where mySum (x:xs) = x + mySum xs
18:37:12 <lambdabot>  Defined.
18:37:19 <prooftechnique> > sumListEnd [1..10]
18:37:27 <lambdabot>   mueval-core: Time limit exceeded
18:37:32 <prooftechnique> But of course that won't work here, for some reason :D
18:37:37 <BigJ> ok so I need some type of local definition as a helper
18:37:40 <ion> Use > let … in …
18:38:57 <prooftechnique> > let sumListEnd xs = xs ++ [mySum xs] where mySum (x:xs) = x + mySum xs in sumListEnd [1..10]
18:39:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,*Exception: <interactive>:3:44-70: Non-exhaustive pat...
18:39:32 <prooftechnique> > let sumListEnd xs = xs ++ [mySum xs] where {mySum (x:xs) = x + mySum xs; mySum [] = 0;} in sumListEnd [1..10]
18:39:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,55]
18:39:36 <prooftechnique> There
18:39:41 <BigJ> did u have the guard sumListEnd [] = []
18:40:30 <prooftechnique> I did not, but it's good that you noticed that
18:40:48 <prooftechnique> > let sumListEnd xs = xs ++ [mySum xs] where {mySum (x:xs) = x + mySum xs; mySum [] = 0;} in sumListEnd []
18:40:50 <lambdabot>   [0]
18:41:41 <prooftechnique> You can define that case explicitly if you want sumListEnd [] = [], but the function is total without it
18:43:54 <BigJ> ok thanks I will have to go sit down and go over this code for a bit
18:44:17 <prooftechnique> Let me make a readable paste of it so you can look at something nicer than IRC :D
18:44:29 <Hodapp> dang, is ghci unavailable on ARM or something?
18:45:12 <adnap> How do you generate tags for Haskell source?
18:46:01 <lpaste> prooftechnique pasted “sumListEnd” at http://lpaste.net/95583
18:46:13 <prooftechnique> BigJ: See link above
18:46:32 <prooftechnique> adnap: There are a couple of options. The last I used was
18:46:35 <prooftechnique> @hackage lushtags
18:46:35 <lambdabot> http://hackage.haskell.org/package/lushtags
18:46:54 <adnap> I'm using http://hackage.haskell.org/package/hothasktags
18:47:30 <adnap> I followed the instructions there. I was able to generate a tags file despite several parse errors, but I don't know how to use it with vim
18:48:35 <Bor0> can anyone help me with this piece of code? it fails at line 35 when trying to compare IO Bool to Bool. I don't know how to approach this. also please let me know if you have any general remarks regarding coding style etc. http://lpaste.net/95584
18:48:42 <BigJ> prooftechnique, thank you that is clearer
18:48:50 <prooftechnique> BigJ: No problem
18:49:17 <prooftechnique> adnap: :tag <tagname>
18:49:29 <prooftechnique> Also, Ctrl-] over a tag name
18:49:34 <prooftechnique> And look into tagbar
18:49:54 <adnap> prooftechnique: I tried that before. It doesn't seem to know about the tags in my tags file
18:50:37 <adnap> prooftechnique: Oh, I was wrong. I just have to type the full tag name
18:50:47 <prooftechnique> So it works?
18:50:51 <prooftechnique> Sweet :D
18:51:06 <Ralith> Bor0: that website has some style remarks for you already
18:51:24 <adnap> I should get tags and source for base...
18:51:49 <prooftechnique> Bor0: Add type signatures, also. It'll make things easier to follow
18:55:20 * hackagebot Win32-extras 0.2.0.1 - Provides missing Win32 API  http://hackage.haskell.org/package/Win32-extras-0.2.0.1 (KidoTakahiro)
18:55:45 <begriffs> Hey GHC can compile to LLVM, right? I wonder if Haskell could hook up with Google's new PNaCl to make web applets.
18:56:21 <Hodapp> bahhh! Just use emscripten.
18:58:04 <begriffs> Hodapp: oh cool I never saw that before. Have you tried it?
18:58:47 <Hodapp> nope, but I read their paper.
19:03:28 <prooftechnique> Hodapp: You know, I keep seeing emscripten, but I've never actually looked at it. Looks pretty neat
19:07:57 <alkabetz> Has anybody seen any performance benchmarks for emscripten?
19:14:12 <carter> begriffs: just use GHCJS :)
19:14:28 <carter> else you have to write a browser tuned gc
19:17:48 <Bor0> @src liftIO
19:17:48 <lambdabot> Source not found.
19:19:59 <alkabetz> Bor0: It's a type class method, so there's no associated source.
19:20:06 <alkabetz> > :t liftIO
19:20:08 <lambdabot>   <hint>:1:1: parse error on input `:'
19:20:14 <alkabetz> :t liftIO
19:20:16 <lambdabot> MonadIO m => IO a -> m a
19:20:34 <alkabetz> Bor0: What monad would you like to lift IO to?
19:20:57 <Bor0> I have no idea what I did, but the source I posted on lpaste suddenly started to work, after I used liftIO for checkUser'
19:22:03 <Bor0> http://lpaste.net/95584 could someone explain to me what line 42 does?
19:22:22 <alkabetz> Oh, this is using the CGI package?
19:22:45 <Bor0> yes, I was writing a simple auth web backend
19:23:11 <alkabetz> The CGI package uses its own special monad to keep track of state before it responds to a CGI request.
19:23:15 <Bor0> but most of the stuff you see there are result of trial and error for... 4 hours maybe now
19:23:16 <begriffs> carter: good idea. I'll probably wait for the GHC 7.8 release before messing with GHCJS though.
19:23:24 <carter> yeah
19:23:25 <carter> healhty that
19:23:29 <carter> :)
19:23:45 <alkabetz> Bor0: So cgiMain has type CGI (), but checkUser' has type IO Bool
19:23:46 <prooftechnique> Well, checkUser dips into IO, so it's type must be IO Bool. Then you wanted checkUser', whose type must also be IO Bool. Then you have lift it into the CGI monad to use it with cgiMain
19:23:59 <geekosaur> MonadIO is fairly simple. There is an instance for IO which just runs the action. There is an instance for other monad transformers, with a MonadIO context on the transformed monad, that amounts to: MonadIO m => MonadIO (SomeMonad ... m a) where liftIO a = lift $ liftIO a
19:24:18 <geekosaur> the effect is that an IO action is lifted as far as necessary until it reaches the actual IO
19:24:47 <Bor0> I see. so basically we kind of "call" the IO Bool() and get the Bool out of it as a call result?
19:24:55 <geekosaur> (lift is provided by Control.Monad.Trans and defines a monad transformer: it provides access to the transformed monad)
19:25:02 <geekosaur> not at all
19:25:22 <geekosaur> you can't do that
19:25:34 <geekosaur> but, you are executing in the context not of IO, but of CGIT IO
19:25:43 <geekosaur> liftIO lets you get at the IO part of CGIT IO
19:26:02 <geekosaur> and converts the IO whatever result into CGIT IO whatevere
19:26:05 <geekosaur> so you can use it
19:26:20 <Bor0> I see
19:26:43 <geekosaur> (actually I misspoke there slightly, liftIO a = return $ lift $ liftIO a -- so it gets wrapped in the outer monad
19:27:46 <Bor0> could I somehow worked this out without using liftIO? some of my tries were res <- checkUser' username password >>= (\x -> if x then authSuccess else inputForm)
19:28:18 <alkabetz> You must have run that in a do block associated with IO, not CGI.
19:28:31 <geekosaur> possibly just `lift` would have worked, if it's actually right on top of IO. liftIO is the correct way to do it, though
19:28:36 <Bor0> aha, so if I put that in main, it would've worked?
19:28:41 <geekosaur> so you don't need to care where the IO is, just that it's there
19:28:57 <alkabetz> Bor0: No, it still would have worked, because liftIO can lift from IO to IO :)
19:29:07 <alkabetz> It just would have been a no-op.
19:29:39 <Bor0> are you saying that my approach with >>= (\x ... would've worked, or something else?
19:29:43 <geekosaur> if your cgiMain were to return the user and password, you could have called it directly in main. as long as you're not then going to need the CGIT, that is
19:30:08 <Bor0> yes, I think I get that
19:30:10 <geekosaur> [13 03:14] <geekosaur> possibly just `lift` would have worked, if it's actually right on top of IO. liftIO is the correct way to do it, though
19:30:22 <alkabetz> Bor0: Yes, I don't think your approach with explicit bind should have worked in the context of the CGI monad.  I think you'd still need liftIO.
19:30:24 <geekosaur> you need *some* kind of lift to get at the IO; mere syntax will not help
19:31:07 <Bor0> ok. this is very useful information to me. thanks a lot! one more thing, where can I see what liftIO does in background? I understand that it can lift from IO to IO but how does it do this?
19:31:26 <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/transformers-0.3.0.0/doc/html/src/Control-Monad-IO-Class.html
19:31:49 <geekosaur> is the instance for IO itslef (it's a no-op)
19:32:04 <geekosaur> other monads provide their own definition, but it's pretty much the one I already gave you
19:32:40 <geekosaur> liftIO a = return $ lift $ liftIO a -- reinvoke liftIO in the next monad up, then wrap the result for the current monad
19:33:11 <geekosaur> if the next monad up is IO then the action is simply run. otherwise that monad just lifts it into the next monad... continuing until it reaches IO
19:34:21 <Bor0> thanks again :) for now I'll just save this log and re-read it again after I get some rest
19:35:36 <geekosaur> (you can't get into a situation where there is no IO; there is a MonadIO context on the lifted monad, which will only be satisfied if IO is the final monad)
20:00:28 <dmwit> surely there's no return
20:00:31 <dmwit> :t lift . liftIO
20:00:32 <lambdabot> (MonadIO m, MonadTrans t) => IO a -> t m a
20:00:45 <dmwit> :t return . lift . liftIO
20:00:46 <lambdabot> (Monad m, MonadIO m1, MonadTrans t) => IO a -> m (t m1 a)
20:10:41 <himh> Hey, anyone use syntastic? Is there a way that I can ignore certain types of warnings from hlint about redundant brackets?
20:11:33 <cbw> I use syntastic
20:11:37 <dmwit> Probably the best way is to tell hlint not to generate those warnings.
20:11:47 <cbw> need to install hlint
20:12:09 <cbw> not in my repro so I have been lazy
20:12:34 <dmwit> https://rawgithub.com/ndmitchell/hlint/master/hlint.htm#customization
20:13:17 <ndeine> in your vimrc, you can do:
20:13:45 <himh> dmwit: thanks!
20:13:46 <ndeine> let g:syntastic_haskell_checkers = ['hlint <options>']
20:15:03 <himh> Is there a way to simply dismiss one of the suggestions from the hlint location list? I don't necessarily want to suppress all warnings of this type but for a few they don't make sense
20:15:20 <dmwit> Did you read the documentation? =)
20:15:38 <dmwit> (The one I linked. ;-)
20:16:56 <himh> dmwit: I did, but it seems to suggest that it's all or nothing. Ignore or don't.
20:17:03 <prooftechnique> I think I ended up just shutting syntastic off for Haskell because it couldn't deal with sandboxes
20:17:15 <prooftechnique> ghc-mod does its own thing
20:17:15 <dmwit> That's not what it says to me...
20:17:18 <himh> Actually my question is more about syntastic
20:17:50 <dmwit> e.g. try {-# ANN myFunction "HLint: ignore Eta reduce" #-}
20:18:02 <dmwit> to ignore an eta reduction suggestion for function myFunction
20:18:16 <dmwit> or "HLint: ignore Redundant brackets" or whatever
20:18:41 <himh> I'll give it a go, thanks dmwit.
20:19:20 <jcarpenter2> Is there existing Haskell code anywhere that does what this does? http://lpaste.net/95586
20:19:42 <jcarpenter2> It tries to let you pass functors of types to functions as if the functors were the types they contain
20:21:32 <dmwit> jcarpenter2: Isn't this what monad transformers are all about?
20:21:43 <dmwit> Oh, no.
20:21:45 <dmwit> This is
20:21:47 <dmwit> :t traverse
20:21:48 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
20:22:39 <jcarpenter2> That's one instance, but this also applies t's that are not Traversable
20:23:11 <jcarpenter2> like Maybe
20:23:18 <dmwit> Maybe is Traversable...
20:23:22 <jcarpenter2> it is?
20:23:30 <dmwit> ?instances Traversable
20:23:30 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
20:23:35 <jcarpenter2> well it also applies to the applicative itself, if the applicative is a monad
20:23:37 <dmwit> ?instances-importing Data.Traversable Traversable
20:23:38 <lambdabot> Maybe, []
20:23:52 <jcarpenter2> That's not necessarily a traversable, right?
20:24:39 <jcarpenter2> IO definitely isn't at least
20:24:50 <dmwit> I'm not sure I understand what you're asking for yet.
20:25:10 <dmwit> Maybe you could tell us about the problem you're trying to solve.
20:26:14 <jcarpenter2> I'm trying to make it so you can seamlessly pass various types into your functions, without modifying your program
20:26:28 <jcarpenter2> The example that motivated this was asynchronous tasks.
20:26:48 <dmwit> Can you give a few more details about this motivating example?
20:26:52 <jcarpenter2> When you introduce one of those into your program, it seems to bubble down into the rest of your code.
20:27:00 <jcarpenter2> Maybe not in Haskell, I'm a Haskell noob.
20:27:34 <dmwit> ?hackage async
20:27:34 <lambdabot> http://hackage.haskell.org/package/async
20:27:35 <jcarpenter2> Normally you have to start signing up callbacks all over the place
20:28:00 <dmwit> Why use callbacks when IO is first-class?
20:28:20 <jcarpenter2> I'm not sure what you mean
20:28:45 <pharaun> callbacks--
20:28:48 <jcarpenter2> For example, in JavaScript you always do ajax requests with callbacks
20:29:10 <dmwit> That's nice. =)
20:29:11 <jcarpenter2> even with jQuery Deferreds or some such, you can't avoid manually writing a callback somewhere.
20:29:44 <dmwit> My recommendation is that you don't attempt to recreate Javascript in Haskell as a first step to writing your code. Instead, start writing your code.
20:29:55 <jcarpenter2> That's true
20:30:12 <himh> Javascript... ugh. *rant over
20:30:17 <jcarpenter2> It could be that Haskell just solves the problem I'm trying to solve in a totally different way
20:30:22 <pharaun> jcarpenter2: so far i've managed to avoid callbacks in haskell :p
20:31:08 <jcarpenter2> In Haskell, you could say I'm trying to automate calling the fmap function.
20:31:29 <dmwit> Why?
20:31:50 <pharaun> why
20:31:51 <jcarpenter2> so that you don't have to stripe it through your code when you decide that a String is now going to be a Maybe String
20:32:17 <dmwit> Do you have some example code where calling fmap is too onerous for us to look at?
20:32:24 <jcarpenter2> nope
20:32:35 <dmwit> Okay. So, there's no problem. So don't solve it yet!
20:32:56 <prooftechnique> Or just write code general enough that you need to fmap, anyway
20:33:24 <carter> jcarpenter2: stop worrying about javascript problems ;)
20:33:27 <carter> haskell does it nicer
20:33:32 <jcarpenter2> oh yeah
20:33:34 <dmwit> If you guess what problems you're going to have, a lot of the time, you'll guess wrong and waste time. Bad!
20:34:05 <dmwit> That's like, *the* motivational speech for lazy evaluation. ;-)
20:34:19 <jcarpenter2> dmwit: thanks.  I'll spend my time on whatever I deem fun though :)
20:34:24 <carter> true
20:34:27 * dmwit nods agreeably
20:35:09 <dmwit> Anyway, my answer to your question is basically, "I don't think there's anything quite like the code you wrote because I think the code you wrote is not very useful.".
20:35:14 <jcarpenter2> I've been learning Haskell in order to write the above
20:35:18 <dmwit> But I've been wrong before.
20:35:20 <prooftechnique> Oh, speaking of a problem I have, is there an obvious mapping from BNF to Parsec combinators? There's a parser I'm trying to write, but I think I'm just not sure which combinators to use
20:35:34 <jcarpenter2> and Haskell so far is easily the strongest language I've ever used
20:35:50 <jcarpenter2> I wouldn't be surprised if you guys are right, and the problem I'm solving just doesn't exist in haskell
20:37:02 <dmwit> prooftechnique: Well, the translation of  A ::= BC | DE is roughly a = (b >> c) <|> (d >> e)
20:37:24 <dmwit> prooftechnique: Recursive rules use chainl or chainr (or just directly use recursion).
20:38:00 <dmwit> prooftechnique: However, there's some gotchas having to do with common prefixes and fair alternation.
20:39:06 <prooftechnique> Hmm. I may just need to familiarize myself with the library more. I know what I *need* to do, I just have to figure out how to word it
20:39:21 <prooftechnique> In code, that is
20:40:33 <himh> Can anyone point me to some examples of haskell being used for numerical/scientific computing?
20:41:07 <prooftechnique> @hackage repa
20:41:07 <lambdabot> http://hackage.haskell.org/package/repa
20:41:23 <dmwit> prooftechnique: Have you seen the Parsec tutorial?
20:41:24 <nisstyre> himh: if you're not using a Fortran or C library for that you're doing it wrong. Bindings to said libs might exist though.
20:41:32 <dmwit> It's a bit outdated now, but the big ideas still shine through nicely.
20:41:46 <prooftechnique> dmwit: Which one? I've seen a few
20:42:10 <dmwit> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
20:42:28 <nisstyre> looks like repa doesn't support nested parallelism either which is the killer app of functional languages vs. Fortran/C
20:42:44 <prooftechnique> I've mostly just been trying to find nontrivial examples of going from a BNF grammar to a chain of Parsec parsers, but most examples are of the "instructive but not overly substantive" variety :D
20:42:58 <prooftechnique> I'll definitely give that a read, though
20:43:41 <dmwit> The section headed "Expressions" gives a translation from a BNF for a calculator language to Parsec.
20:43:56 <dmwit> i.e. the usual toy language with addition, multiplication, and parens
20:44:00 <prooftechnique> Yeah, I've seen a number of those.
20:44:04 <nisstyre> prooftechnique: are you used to writing recursive descent parsers?
20:44:13 <nisstyre> going from that to parsec is pretty easy ime
20:44:25 <prooftechnique> nisstyre: I'm not particularly used to writing parsers, at all, honestly
20:44:43 <nisstyre> prooftechnique: do you speak python? I have some good articles I can link
20:44:45 <prooftechnique> Though I wrote a bottom up CGF parser in Lisp this afternoon
20:44:50 <himh> nisstyre: well I've been playing with hmatrix which has said bindings, but when I try to scale some of my examples just a little bit it's still really slow
20:44:55 <prooftechnique> nisstyre: A little python, sure
20:45:20 <nisstyre> prooftechnique: http://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/
20:45:31 <nisstyre> prooftechnique: his blog has all kinds of interesting parser topics
20:45:33 <himh> nisstyre: maybe the problem is immutability + data munging are a bad combination
20:45:40 <nisstyre> I recommend the precedence climbing post
20:45:46 <prooftechnique> nisstyre: Cool stuff. Thanks for the link :)
20:45:54 <nisstyre> himh: Fortran compilers are REALLY good
20:46:24 <nisstyre> himh: but yeah there might be something weird going on with that
20:46:29 <nisstyre> I've never used hmatrix
20:47:49 <himh> nisstyre: I just think to myself... I dunno what ghc is doing with all this but if I'm updating a single row of a 4m row matrix and it's creating a new copy for each transformation that's gotta be a problem. But correct me if I'm wrong
20:48:08 <nisstyre> himh: I also have a RD parser I wrote that handles operator precedence and lets you add new operators via a table
20:48:12 <nisstyre> but it's in javascript :D
20:48:20 <nisstyre> er prooftechnique
20:48:26 <nisstyre> sorry
20:48:31 <prooftechnique> dmwit: To clarify my motivation, I'm actually writing an XML parser that I need for some other libraries :/
20:48:44 <nisstyre> himh: yes that is a bad idea if that's what it's doing
20:48:45 <dmwit> oh what
20:48:47 <dmwit> don't do that
20:48:53 <dmwit> Use an existing XML parser.
20:49:18 <nisstyre> dmwit: unless your name is Oleg ( http://okmij.org/ftp/Scheme/xml.html )
20:49:42 <dmwit> I mean, somebody has to write the first parser in each language.
20:49:47 <dmwit> But don't be the fool that writes the second one.
20:49:53 <prooftechnique> dmwit: Well, the idea is that I'm going to write one against xml-types, which I will then feed into pipes-attoparsec, which I will then use for pipes-xml, which I will then use for the project I actually want to do
20:50:19 <nisstyre> dmwit: yeah true enough
20:50:22 <prooftechnique> So I'm trying to fill out a little piece of ecosystem work without pulling in a bunch of dependencies
20:50:46 <nisstyre> prooftechnique: well, parsing all of XML is non-trivial
20:50:48 <prooftechnique> And it'll be a fun/awful learning experience
20:50:51 <dmwit> http://hackage.haskell.org/packages/search?terms=xml <- are you SURE nobody else has tried to fill that part of the ecosystem?
20:50:55 <nisstyre> you can parse a subset of xml easily
20:50:59 <prooftechnique> dmwit: Yes, sadly.
20:51:02 <nisstyre> but not all of it
20:51:31 <prooftechnique> xml-conduit is the closest, but for obvious reasons that's a bit at odds with my idea of pipes-xml
20:51:49 <intrados> Can type families replace fundeps of the form `c -> a b` ?
20:51:52 * dmwit shrugs
20:51:54 <dmwit> it's your sanity =)
20:51:59 <prooftechnique> I know, right?
20:52:08 <nisstyre> prooftechnique: you should read Oleg's parser then
20:52:11 <nisstyre> if you know Scheme that is
20:52:11 <dmwit> intrados: yes, type family A c; type family A b
20:52:14 <dmwit> err
20:52:17 <dmwit> intrados: yes, type family A c; type family B c
20:52:24 <prooftechnique> With luck, though, I'll get a couple of nice general libraries out of it that people can use elsewhere
20:52:37 <dibblego> is there some way to overload Show so that ghci users will observe it?
20:52:40 <nisstyre> may even be a way to transpile the Scheme code to Haskell
20:52:48 <prooftechnique> Having a usable XML parser that doesn't have a dozen dependencies would be pleasant
20:53:03 <dmwit> I will never, ever understand the "fewer dependencies is better" argument.
20:53:09 <dmwit> More dependencies is better!
20:53:10 <dibblego> me neither
20:53:19 <dibblego> a usable XML parser without bugs would be more pleasant
20:53:20 <dmwit> More dependencies is less code I have to write.
20:53:25 <prooftechnique> Less surface area to learn
20:53:30 <prooftechnique> dibblego: That's kind of the idea
20:53:53 <dmwit> prooftechnique: I doubt it. More like more surface area you have to invent because you didn't realize that doing a good job of your original goal had such a big surface. =)
20:54:05 <dibblego> I was a happy HXT user for years until I hit unsafePerformIO nonsense
20:54:07 <prooftechnique> Haha, well, that'll be all for the better, then
20:54:29 <nisstyre> prooftechnique: are you also going to implement a query language like xpath?
20:54:34 <prooftechnique> Hahahaha, no
20:54:46 <nisstyre> prooftechnique: I wouldn't use an xml library that doesn't have that tbh
20:54:57 <dibblego> I wouldn't use one that does
20:55:00 <prooftechnique> It's just a parser
20:55:04 <prooftechnique> Nothing fancy
20:55:11 <nisstyre> dibblego: it's a lot easier than manually traversing the AST
20:55:18 <dibblego> nisstyre: that is not the only alternative
20:55:24 <prooftechnique> I want it to do one thing well, and nothing else
20:55:29 <nisstyre> dibblego: well, I know there are other query languages
20:55:40 <nisstyre> and other ways to get at data
20:55:59 <dibblego> there are "query languages" that traverse properly using a zipper, composing along the way, recording history in structure, providing rollback
20:56:07 <dibblego> you know, doing it responsibly
20:56:12 <nisstyre> fair enough
20:56:24 <prooftechnique> I wouldn't be in this mess at all if the API I wanted to interact with had a JSON resource, but :shrug:
20:56:45 <dibblego> there has been talk of porting scala/argonaut to haskell for this reason
20:56:51 <dibblego> i.e. traversing properly
20:57:20 <dmwit> Is pipes really so much better than conduit that it's worth writing an XML parser from scratch?
20:57:39 <dibblego> use edwardk/parsers so as to stop caring
20:57:48 <prooftechnique> dmwit: I dunno. Still something to do, though :D
20:57:48 <pharaun> for me what i want is a better html parser
20:58:22 <pharaun> hxt works but i've managed to crash it, had to switch to tagsoup, but would be nice if i could get it going with text :)
20:58:50 <pharaun> dibblego: unsafe perform in hxt?
20:59:15 <dibblego> yes, I hit a bug and spent hours tracking it down, then I realised how awful HXT is and I cried for a bit
20:59:35 <dibblego> https://github.com/sol/doctest-haskell/issues/66
20:59:43 <pharaun> ive been peeking at tagsoup but it seems way too low level for me
20:59:52 <pharaun> but they seem to have a text version of tagsoup
21:00:29 <pharaun> oh man unsafe perform io :(
21:01:03 <nisstyre> port this to Haskell, http://planet.racket-lang.org/package-source/neil/html-parsing.plt/2/0/planet-docs/doc/index.html
21:01:06 <nisstyre> it's been quite good for me
21:01:13 <nisstyre> it's pretty permissive too
21:03:12 <pharaun> i had good experience with nokogiri and a few other parser for html stuff
21:03:14 <pharaun> but ah well
21:03:50 <prooftechnique> Well, if I get the damn thing working with my sanity intact, maybe it'll get some use :D
21:04:17 <jmcarthur> danharaj: i met you!
21:04:22 <nisstyre> prooftechnique: well if you've never written a RD parser before you will have a long time ahead of you
21:04:48 <prooftechnique> Eh, a little reading never hurt anybody
21:05:04 <nisstyre> prooftechnique: well, actually implementing them is really the only way you can get better
21:05:13 <prooftechnique> Even better
21:05:17 <jmcarthur> danharaj: i think i was confused because i always mix up your nick with djahandarie
21:05:30 <djahandarie> :(
21:05:37 <jmcarthur> i know
21:05:41 <djahandarie> And here I thought I was getting highlighted because someone actually needed me for something!
21:05:49 <jmcarthur> sorry! ^_^
21:06:12 <nisstyre> prooftechnique: trifecta looks cool btw, http://hackage.haskell.org/package/trifecta
21:06:17 <djahandarie> Like, "djahandarie, my Haskell application is crumbling and its used for launching nuclear missles, quick, I need your expert assistance!"
21:06:36 <prooftechnique> Figures it'd be ekmett :D
21:06:38 <jmcarthur> djahandarie: how did you know what i was about to say next?! you are truly amazing
21:07:21 <nisstyre> prooftechnique: might also look at http://tanakh.github.io/Peggy/
21:07:33 <prooftechnique> Yeah, I checked that out the other day, actually
21:07:33 <nisstyre> can't speak for how good it is, but PEGs are interesting
21:08:00 <djahandarie> unsafePerformDivination
21:08:05 <prooftechnique> I was also mulling over just breaking down and using Happy or something :D
21:08:21 <Hafydd> 0 `unsafePerformDivision` 0
21:08:29 <nisstyre> prooftechnique: well, you said you want to limit dependencies
21:08:34 <djahandarie> (Side effects may include the Gods striking down upon ye with great wrath.)
21:08:40 <nisstyre> so ideally that means a) writing the tokenizer by hand, no regular expressions
21:08:49 <nisstyre> and b) writing the parser by hand the old fashioned way
21:09:52 <prooftechnique> Haha, I'm okay with anything in the Platform along with xml-types and attoparsec
21:10:01 <danharaj> jmcarthur: aha
21:10:25 <nisstyre> prooftechnique: is the regex library in Haskell Platform?
21:10:43 <prooftechnique> I think so, yeah
21:10:53 <nisstyre> okay, well you can use that to tokenize
21:11:06 <nisstyre> (if you need to)
21:11:40 * pharaun tempted to troll and suggest the perl re example for html parsing :)
21:12:01 <pharaun> a madperson posted up an answer to one of those question with a nearly complete perl regex parser for html
21:12:04 <carter> the SO post on regexes and html
21:12:05 <prooftechnique> I don't strictly know that I need to. I think I can just read into a ByteString and chain parsers across that
21:12:10 <nisstyre> prooftechnique: check out this monstrosity, https://github.com/nisstyre56/JLambda/blob/master/tokenize.js
21:12:15 <prooftechnique> carter: Those are genius
21:12:19 <nisstyre> prooftechnique: use Text if you can
21:12:26 <carter> prooftechnique: i'm trying to dig up the link
21:12:34 <carter> yeah
21:12:41 <carter> byestring is only for binary data
21:12:44 <carter> do Text
21:13:00 <carter> http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags  FOUND IT
21:13:06 <prooftechnique> Yeah, now that I think of it, I think the code I've actually written uses Text
21:13:13 <prooftechnique> derp
21:13:34 <pharaun> speaking of the devil, regarding parsers, is there any good suggestion for html parsing? that uses text?
21:13:46 <pharaun> only one i found so far is fast-tagsoup but it seems rather low leveled
21:13:51 <dmwit> Doesn't XML have like PCDATA and friends?
21:13:55 <dmwit> Text seems like a dangerous choice.
21:14:15 <carter> thres some html parsing and XML parsing things
21:14:34 <prooftechnique> dmwit: I think that was the reason I was considering ByteString
21:14:44 <prooftechnique> dmwit: Also, http://www.w3.org/TR/REC-xml/
21:14:47 <prooftechnique> :D
21:14:49 <pharaun> carter: ya, most of the bytestring/text parser i've found seems to be "strictly" xml
21:14:59 <carter> theres a few other things
21:15:01 <pharaun> and i need to parse well... lets put it less than nice html
21:15:04 <carter> @hackage html
21:15:04 <lambdabot> http://hackage.haskell.org/package/html
21:15:07 <pharaun> managed to get hxt to crash
21:15:11 <carter> nvm
21:15:11 <dmwit> No thank you. I'm not interested in XML.
21:15:17 <nisstyre> pharaun: so you need a permissive html parser
21:15:20 <dmwit> It solves a problem nobody has, badly.
21:15:33 <prooftechnique> dmwit: My thoughts, exactly
21:15:40 <pharaun> nisstyre: ya, tagsoup + hxt *seems* to be able to handle the worst so far, but yeah
21:16:03 <prooftechnique> But there's a project I want to do a particular way for the experience, so here we are :D
21:16:13 <carter> http://hackage.haskell.org/package/HandsomeSoup?
21:16:31 <prooftechnique> I think HandsomeSoup is what I used for the scraper I wrote
21:16:34 <prooftechnique> It's pretty easy to use
21:16:37 <nisstyre> prooftechnique: well if you want to learn about parsing, xml is probably one of the worst ways
21:16:50 <pharaun> carter: that is on top of hxt which is "string" only
21:16:56 <carter> urk
21:16:57 <carter> welll
21:17:04 <carter> patch hxt or find something else :)
21:17:07 <prooftechnique> Geez, with this kind of attitude it's a wonder anything ever gets written :D
21:17:09 <pharaun> but ya i've been using hxt + occasional tagsoup, it seems to work....
21:17:32 <nisstyre> prooftechnique: I'm not against inventing wheels of your own
21:17:34 <pharaun> carter: i think if worst come to worst i can try my hand with hxt patching but yeah :)
21:17:37 * dmwit mumbles something about airplanes and weight
21:17:45 <carter> hhehe
21:17:48 <carter> dmwit: go on
21:17:54 <pharaun> heh
21:18:05 <carter> prooftechnique:pharaun: theres a lot of really neat libs that need textification love
21:18:10 <nisstyre> prooftechnique: I like choosing things of limited scope though, unless I have the experience to do something large
21:18:23 <dmwit> "Measuring software productivity by lines of code is like measuring progress on an airplane by how much it weighs."- Bill Gates
21:18:33 <carter> hehe
21:18:34 <prooftechnique> nisstyre: Well, I consider this my "experience to do something large" :D
21:18:37 <pharaun> carter: yup, at least tagsoup has textification, so i might be able to hopefully get hxt kickstarted :)
21:18:44 <pharaun> (re fast-tagsoup)
21:18:45 <nisstyre> prooftechnique: but you have no experience writing parsers
21:18:48 <carter> well, that  would be nice
21:18:59 <pharaun> agreed
21:19:01 <carter> http://hackage.haskell.org/package/tagsoup ?
21:19:10 <carter> i need to learn more web stuff
21:19:18 <carter> i just played with FeedWrangler recently
21:19:34 <carter> seems to be the only new feedreader service that keeps the full feed histories
21:19:44 <prooftechnique> nisstyre: And I need to write parsers to get that experience. So I'll write some parsers, write this parser, and then I'll be ready to write this parser. But then I won't need to, because I will have written it
21:20:41 <prooftechnique> dmwit: Who's that directed to?
21:20:43 <nisstyre> prooftechnique: okay then
21:21:00 <prooftechnique> nisstyre: Thanks for the advice and the links, though
21:21:21 <dmwit> It is directed at the aether.
21:21:39 <dmwit> However, it is a direct response to "with this kind of attitude it's a wonder anything ever gets written".
21:22:57 <carter> yeah,
21:23:02 <carter> contributing to existing tools that work well
21:23:08 <carter> is great for everyone
21:23:11 <carter> and saves everyone time
21:23:12 <pharaun> carter: yeah that's the one, there's a version called http://hackage.haskell.org/package/fast-tagsoup that implements bytestring parsing
21:23:22 <nisstyre> prooftechnique: at least you don't need to correctly do precedence parsing for xml or html (at least I don't think so)
21:23:53 <pharaun> seems like the guy got it up to 200mb/s which is quite nice
21:26:28 <carter> oooh
21:26:30 <carter> sweet i
21:26:33 <carter> its used in BQ
21:26:42 <pharaun> BQ ?
21:26:46 <carter> BazQux reader
21:26:53 <carter> written in a mix of haskell and Ur
21:27:00 <carter> kinda the nicest google reader clone
21:27:08 <pharaun> i dunno what to think about Ur
21:27:17 <pharaun> i looked at it a bit a long time ago seemed interesting
21:27:28 <carter> it doesn't matter for me
21:27:29 <prooftechnique> I've been on NewsBlur for a while, but I'm considering moving to BQ when my sub runs out
21:27:40 <pharaun> anyway tagsoup is used in it?
21:27:45 <carter> but apaprently he's using it it for his webapp quie happily
21:27:51 <carter> pharaun: thats what the hackage page says
21:27:57 <pharaun> neat
21:27:57 <carter> pharaun: i'm meh on newsblur
21:28:08 <pharaun> carter: that was prooftechnique not me :)
21:28:23 <carter> damn auto complete
21:31:17 <carter> pharaun: hrmmm
21:31:24 <carter> well
21:31:26 <carter> both of you
21:31:36 <carter> i'm kinda thinkingi'll use feedwrangler to keep a feedarchive
21:31:45 <carter> then have something else be the nice gui for recen things
21:42:14 <pharaun> heh :p
21:42:45 <pharaun> carter: but anyway i'll try playing with the fast tagsoup + whatever i can in hxt (assuming its not beyond me) and see if i can get it onto bytestring or something nicer :)
21:42:57 <carter> text
21:42:59 <carter> not bytestring
21:43:06 <carter> bytesting is for binary formats
21:43:23 <carter> that it works for other things is a happy accident called 8bit extended ascii
21:43:50 <pharaun> heh fast-tagsoup parses bytestring
21:43:52 <pharaun> >.>
21:43:58 <pharaun> but it emits tags as Text
21:44:20 <pharaun> might be something to do with the encoding/html thing, would have to look into that
21:50:28 <pharaun> hrm how evil is inlinePerformIO
21:51:46 <carter> you're not allowed to use it
21:52:05 <carter> it ws explained to me how to use it once
21:52:08 <carter> i don't remember
21:52:18 <carter> i remember how to do the other performIO ones safely
21:52:21 <carter> not that one
21:52:56 <carter> pharaun: http://hackage.haskell.org/package/text-0.11.3.1/docs/src/Data-Text-Unsafe-Base.html#inlinePerformIO
21:53:00 <pharaun> i'm seeing it in several spots in fast-tagsoup
21:53:06 <carter> huh....
21:53:13 <pharaun> http://hackage.haskell.org/package/fast-tagsoup-1.0.5/docs/src/Text-HTML-TagSoup-Fast.html
21:53:43 <pharaun> heh /Very unsafe/
21:53:49 <carter> yes
21:54:03 <carter> basically you're not allowed to do any memory allocation when you do that
21:54:06 <carter> i forget why
21:54:07 <prooftechnique> carter: I think it's pretty much only reading from an immutable memory buffer. Like, oh, god, do not even look at this unless the IO stuff is really, unbelievably pure
21:54:15 <carter> yes
21:54:17 <carter> exactly
21:54:18 <pharaun> carter: that seems really tricky to do
21:54:31 <carter> pharaun: its a way to make reading from IO things inline friendly
21:54:40 <carter> but they ahve to be really not changing
21:54:52 <prooftechnique> carter: Well, you're *allowed* to do memory allocation, just "oh, god, don't", according to the docs
21:55:06 <carter> yeah
21:55:20 <carter> prooftechnique: at that point you may as well use duppable perform io
21:55:23 <prooftechnique> There're some fun cafe mails about it
21:55:27 <rdesfo> I've installed Aeson with 'nix-env -i ...' , but ghc doesn't see the package.   Does any one know how to get ghc to see the install haskell package (ghc was also installed with nix and I've already reinstalled after removing .ghc and .cabal) ?
21:55:28 <carter> heh
21:55:53 <pharaun> carter: well i think i'm going to slowly put down this piece of code and back up and then run ;p
21:55:59 <carter> yeah
21:56:11 <pharaun> i'll try to implement some good stuff on top of this but this is probably frankly beyond my skill atm
21:56:13 <djahandarie> The reason you don't want to do memory allocation inside there is because if it gets inlined and simplified (which only happens sometimes!), the allocation can get floated out and things will end up sharing a single piece of memory.
21:56:25 <carter> woah huh
21:56:25 <carter> OH
21:56:26 <carter> shit
21:56:30 <prooftechnique> Yeah
21:56:45 <djahandarie> There are other things you can do aside from just reading from immutable buffers though.
21:56:47 <carter> 'cause ok to inliine implies ok to sahre
21:57:09 <carter> djahandarie: like?
21:57:27 <djahandarie> ByteString does some evil stuff with it that I'm not sure anyone but Ross Paterson understands.
21:57:37 <carter> FUSION :)
21:57:46 <pharaun> oh man
21:57:58 <pharaun> i love bytestring but
21:58:06 <pharaun> i shall never attempt to lift the hood for a long while
21:58:47 <djahandarie> (That was a little tongue in cheek anyways, I'm sure many other people understand some uses of it, just not me. :p)
21:59:10 <pharaun> :p
21:59:24 <carter> its basically a perf hack
21:59:28 <pharaun> djahandarie: all i know is at my current understanding level, if i see "unsafe*" i run
21:59:40 <carter> unsafePerformIO is pretty easy to use safely
22:00:01 <pharaun> i'll need to figure it out soon anyway
22:00:06 <pharaun> going to be playing with some FFI code soon
22:00:20 <djahandarie> I basically don't quite understand much of the inlinePerformIO usage in here: http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/src/Data-ByteString-Internal.html
22:00:51 <carter> {-# RULES
22:00:51 <carter> "ByteString packChars/packAddress" forall s .
22:00:51 <carter>    packChars (unpackCString# s) = inlinePerformIO (unsafePackAddress s)
22:00:51 <carter>  #-}
22:01:17 <carter> hrm
22:01:23 <pharaun> oh right you can give ghc rules for one of its stage in the complition pipeline
22:01:34 <carter> basically its to make the work on the bytestring buffers fusible
22:01:55 <djahandarie> I understand what it's doing. I don't understand why it's safe.
22:01:56 <carter> the only reason to do it is for fusion
22:02:20 <carter> because all the code that uses it is just doing array arith
22:02:23 <carter> to read from stuff
22:02:39 <carter> in a pretty structured way
22:02:50 <carter> because the reading from a pointer stuff in GHC is in IO by default
22:03:23 <carter> so reading from an immutable array of bytes using pointer arith
22:03:25 <carter> is kinda safe
22:03:26 <carter> ish
22:04:15 <carter> http://www.haskell.org/pipermail/haskell-cafe/2007-March/023592.html
22:04:33 <schell> you guys know of a situation in OpenGL where the compile status of a shader is False, but the shaderInfoLog is empty?
22:05:48 <carter> NOPE
22:05:51 <carter> you know more than i
22:05:57 <carter> schell: email the lists
22:06:08 <carter> schell: you're very very quickly starting to be an expert
22:07:05 <schell> ah, which list - is there one for the OpenGL bindings?
22:07:19 <carter> no clue
22:07:23 <carter> you can be the expert :)
22:07:43 <djahandarie> carter, I guess what I don't understand is why it's safe to do this when technically, if that's the last reference to the ForeignPtr, the finalizers will be run, which I'm not entirely convinced is fine to just get floated out.
22:07:59 <carter> djahandarie: for which?
22:08:02 <schell> :)
22:08:11 <djahandarie> For which?
22:09:35 <carter> djahandarie: the cafe email?
22:09:56 <djahandarie> The cafe email cites essentially the same code I linked to earlier.
22:10:05 <djahandarie> Which you attempted to explain the safeness of.
22:10:10 <carter> oh
22:10:19 <carter> that has a noinline
22:10:57 <carter> djahandarie: which other code is ismialr
22:11:26 <djahandarie> unpackAppendBytesStrict and unpackAppendCharsStrict in http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/src/Data-ByteString-Internal.html
22:11:49 <carter> those are different...
22:11:53 <carter> the cafe one WRITES stuff
22:12:35 <djahandarie> My concern is with the inlinePerformIOing of withForeignPtr.
22:12:40 <carter> the oh
22:12:47 <carter> foreign pointers dont always have finalizers
22:13:14 <carter> djahandarie: bytestrings use haskell byte arrays i think
22:13:43 <carter> errr
22:13:44 <djahandarie> Well, anyways, I'm sure I could spend some time diving into why this doesn't blow things up, but I find it hard to be able to claim the safety from just looking at the code snippet anyways.
22:13:44 <carter> idk
22:13:47 <carter> ok
22:13:53 <carter> i agree
22:44:47 <joelteon> cabal update is being killed
22:44:51 <joelteon> how do i figure out why
22:46:47 <carter> is hacckage down? :P
22:46:59 <carter> is your network configured well?
22:47:04 <carter> debugg the http over tcp?
22:47:11 <carter> dl the package locally and install thusly?
22:56:34 <joelteon> memory!
22:56:35 <joelteon> it was memory
22:58:12 <Cale> As in you had none free?
23:01:02 <NemesisD> hey guys, i had an idea and was looking for a bit of a direction
23:02:02 <NemesisD> i want a way for a given datatype to define ToJSON/FromJSON instances for it as well as a way to reflect on it to generate documentation for the json
23:07:12 <NemesisD> i haven't baked this idea all the way but it seems like you could build up a tree that represents the structure, i should be able to define something like parseJSON' :: JSONStructure a -> Value -> Parser a, toJSON' :: JSONStructure a -> a -> Value
23:11:17 * edwardk waves hello.
23:12:04 <NemesisD> hello
23:50:08 <structuralist> are there cofree monads?
23:54:51 <structuralist> is there a dual to do-notation?
23:56:29 <opqdonut> structuralist: there are cofree comonads IIRC
23:56:41 <structuralist> yep I know about cofree comonads
