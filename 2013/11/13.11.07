00:17:34 * hackagebot reified-records 0.1.0.0 - Reify records to Maps and back again  http://hackage.haskell.org/package/reified-records-0.1.0.0 (jozefg)
00:17:34 * hackagebot ed25519 0.0.2.0 - ed25519 cryptographic signatures  http://hackage.haskell.org/package/ed25519-0.0.2.0 (AustinSeipp)
00:43:53 <johnw> akegalj: I think he means something like {-# REWRITE inc1 . sub1 = id #-}
00:44:07 <johnw> not sure about the syntax
00:52:34 * hackagebot thyme 0.3.0.2 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.0.2 (LiyangHu)
01:10:12 <johnw> is there a way in an hspec test to know if --verbose was passed on the command-line?
01:19:28 <supki> johnw: does getArgs not work?
01:19:57 <johnw> that's a good point
01:32:54 <TallerGhostWalt> hmm, I am getting a weird permission denied error when I am trying to run a haskell binary on Windows
01:33:12 <TallerGhostWalt> what is weirdest, it is saying it can't create a file but I don't ask it to do that anywhere
01:33:23 <TallerGhostWalt> I mean, I obviously do! but not intentionally!
01:33:25 <fizruk> what are Strong and Choice for? http://hackage.haskell.org/package/profunctors-3.3.0.1/docs/Data-Profunctor.html#t:Strong
01:33:32 <arkeet> oh good, thyme handles leap seconds
01:37:08 <johnw> fizruk: they enrich what you can do with a given Profunctor
01:37:52 <fizruk> johnw, I can't see specifically what they allow me to do and in what what way they generalize UpStar/DownStar
01:41:07 <arkeet> fizruk: lens uses them :)
01:41:18 <fizruk> arkeet, I know that :P
01:41:30 <prophile> it's a typeclass with a name from category theory
01:41:35 <prophile> of course lens uses them :)
01:41:43 <fizruk> :)
01:42:20 <arkeet> Strong not as much
01:42:29 <fizruk> okay, I see that Prism is basically a (Choice p, Applicative f) => p a (f b) -> p s (f t)
01:42:37 <arkeet> but-yeah
01:43:05 <fizruk> how Choice is used here? (and why Applicative?)
01:43:29 <fizruk> okay, perhaps I should go to #haskell-lens then?
01:43:34 <arkeet> maybe
01:44:20 <arkeet> you could look at the implementations of prism
01:44:44 <exicer> Say I have a web application that scrapes info from another site. If that other site goes down, I don't want my application to crash, and I want to be notified - so should I use Either, or some kind of logging, or something else ?
01:45:01 <prophile> exicer: yes
01:45:12 <exicer> I guess I mean, what is the preferred method :p
01:45:42 <prophile> any combination, depending on the needs of the application
01:45:46 <prophile> hence the mathematician's answer :)
01:45:49 <arkeet> I might use exceptions
01:46:16 <exicer> prophile: Hehe, fair enough.
01:46:30 <exicer> arkeet: At what point would you handle then ?
01:46:41 <arkeet> at the point where you want to be notified.
01:47:48 <exicer> Hm, I guess I will experiment a bit then. Cheers!
01:47:58 <mr-> exicer: Either sounds good. Why not just scrape :: IO (Either Oops Yay) ;-)
01:48:25 <exicer> mr-: That is actually what I was doing already - in case the layout had changed etc.
01:48:29 <prophile> go for a nice ErrorT
01:48:38 <prophile> nothing like a good monad transformer
01:48:41 <exicer> mr-: I just hadn't thought about the site not being ther..
01:49:02 <exicer> prophile: I suppose it would be a good excuse to properly understand monad transformers :p
01:49:32 <mr-> exicer: then just add a "SiteNotThere" to your "LayoutChanged" error-type
01:50:14 <mr-> exicer: (note that ErrorT could just as well be called EitherT)
01:50:26 <prophile> mr-: technically no?
01:50:27 <exicer> mr-: Yeah, sounds like that would be the most simple way.
01:50:41 <mr-> prophile: pardon?
01:50:55 <prophile> you can't have mzero in general for Either e
01:51:02 <mr-> prophile: newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
01:51:28 <prophile> yes, but you'll note it's instance (Monad m, Error e) => Monad (ErrorT e m)
01:51:36 <prophile> rather than (Monad m) => Monad (ErrorT e m)
01:51:44 <mr-> Oh, I have not!
01:51:53 <mr-> Thanks
01:52:07 <prophile> mzero requires you to be able to conjure up an e out of nothing
01:52:12 <prophile> which isn't going to be generally possible :)
01:52:21 <prophile> and a similar story exists for fail
01:54:59 <mr-> Ok, and Error really is not much more than that
01:55:15 <prophile> Error gives you a way to construct an e from either nothing or a string
01:55:20 <prophile> basically for use in mzero and fail respectively
01:58:01 <mr-> Ok, but >>= and return are the same. It simply also implements fail
01:58:33 <johnw> supki: no, didn't work
01:58:57 <prophile> mr-: correct
01:59:06 <prophile> fail isn't important, it's the MonadPlus instance which is useful
02:00:58 <mr-> Somehow I have never considered "fail" as part of the data of a monad..
02:04:12 <quchen> Good.
02:04:50 <quchen> fail is the Monad's appendix. It's born with it, you try to ignore it, and when you're lucky it will only be useless throughout your life.
02:05:16 <prophile> I have a slight soft spot for fail
02:05:26 <quchen> I have a soft appendix.
02:05:41 <prophile> I haven't got one, so I use fail in its place
02:06:27 <mr-> You never use it, but if you did, you would throw a runtime exception?
02:06:37 <quchen> Most likely.
02:07:37 <quchen> There are monads for which fail doesn't crash. For most of them fail = const mzero. The exception is STM, for which fail = crash, for whatever reason.
02:08:29 <quchen> Well, it could retry forever in some scenarios if the pattern always fails I guess.
02:09:07 <johnw> yeah, I wonder why fail isn't retry then?
02:09:29 <quchen> johnw: I suppose infinite retries because a pattern doesn't match are hard to debug.
02:10:05 <sopvop> vinyl is like records in haskelldb on steroids?
02:10:15 <lpvb> what are some famous haskell quips
02:10:34 <prophile> a monad is just a monoid in the category of endofunctors, what's the problem?
02:10:38 <TallerGhostWalt> man this stupid permission denied thing is frustrating
02:10:54 <quchen> @quote coproblem
02:10:54 <lambdabot> ciaranm says: a comonad is just a comonoid in the category of endofunctors. what's the coproblem?
02:10:57 <TallerGhostWalt> anyone have trouble getting file permissions to work with windows
02:11:02 <TallerGhostWalt> for ghc?
02:13:06 <fizruk> is there a type alias for (forall a. f a -> g a) somewhere?
02:13:42 <prophile> fizruk: is that a natural transformation?
02:13:55 <fizruk> prophile, exactly
02:14:09 <prophile> there's got to be one in an edwardk library somewhere
02:14:52 <edwardk> i've got it in the unreleased version of 'indexed' and back n the old category extras, but i tend to write them out by hand
02:15:07 <edwardk> otherwise folks stop and wonder what (~>) means
02:15:25 <edwardk> and often my natural transformations are to compositions of functors and what not
02:15:38 <edwardk> and i don't want to force Compose into the mix
02:16:16 <fizruk> edwardk, I see, thanks!
02:20:43 <johnw> HPC is one of those things where by the time I need it, I've completely forgotten how to get it working again.  It's making a test.tix file, but "hpc report test" is just saying it "can't find Main", even though Main.mix is in my --hpcdir.  Anyone know what I'm doing wrong?
02:21:55 <johnw> ahh
02:22:03 <johnw> "hpc report test --hpcdir=dist/hpc Main.mix"
02:25:46 <dmj`> anyone ever done a migration with acid-state before?
02:30:54 <augur> anyone know of something i can read on complex intersection record types?
02:32:27 <augur> oh, tapl has a section on this, good
02:42:49 * hackagebot MFlow 0.3.2.0 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.3.2.0 (AlbertoCorona)
02:42:51 * hackagebot matrix 0.2.2 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.2.2 (DanielDiaz)
03:09:28 <remdezx> Hello! I'm building an application which has two parts: Qt Quick GUI and haskell backend. What is the best way to transfer images from Haskell to Qt gui? I'm processing images using the repa package
03:22:31 <shiona_> remdezx: have you looked at qtHaskell and/or HQK
03:24:49 <danilo2> shiona_: HSQML would be perfect, but it supports only qtquick up to 4.8 :( http://www.gekkou.co.uk/software/hsqml/
03:27:06 <supki> johnw: yeah,  hspec :: Spec -> IO ()  clears arguments with  withArgs [] $ ...  I guess you can work around that by using  hspecWith  or something
03:27:31 <hvr> anyone here w/ GHC-7.4.x on OSX?
03:27:38 <supki> dmj`: yes, that's possible, why?
03:27:42 <johnw> i figured out what to do: just call getArgs before hspec
03:27:46 <bergmark> hvr: yeah
03:27:55 * hackagebot spatial-math 0.2.0 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.2.0 (GregHorn)
03:28:14 <danilo2> shiona_ (we are working together with remdezx) - we are thinking about 0mq, nanomsgs (as someone recommended here a couple of days ago) and other methods, but we would love to ask you about it, because somebody could know the answerr "hat is the best method" in this situation.
03:28:55 <tdammers> zeromq is lovely, I can say this much
03:30:18 <danilo2> tdammers: ok, but would be as fast as for example shared memory or something like that? We want to interactively display images from our Haskell program, so we want to transfer them as fast as possible. We are testing 0mq right now though.
03:30:58 <ghorn> danilo2: I'm using zmq for exactly this
03:31:48 <ghorn> danilo2: i'm not sending raw images though
03:32:56 * hackagebot not-gloss 0.6.0.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.6.0.0 (GregHorn)
03:32:58 <danilo2> ghorn: could you tell a little more about it? what are you exactly sending?
03:35:12 <remdezx> how about nanomsg? I heard it is a bit faster than zeromq
03:36:54 <ghorn> danilo2: I'm using it for 2 projects: http://i.imgur.com/s72YnSP.png and http://www.youtube.com/watch?v=tmjIBpb43j0
03:37:57 * hackagebot not-gloss-examples 0.4.0 - examples for not-gloss  http://hackage.haskell.org/package/not-gloss-examples-0.4.0 (GregHorn)
03:38:22 <ghorn> danilo2: in the 2d graph case, i send a bunch of line plots to my graph program, in the second case I send [(Xyz Double, Quaterion Double)]
03:38:29 <ghorn> Quaternion*
03:39:01 <ghorn> zmq can handle quite a bit of data at 30fps, i've never measured how much but i haven't hit a bottleneck
03:39:15 <tdammers> zmq travels over sockets, so there is obviously some overhead
03:39:26 <tdammers> serialization, and most of the networking stack
03:39:42 <tdammers> but for what it does, it's pretty damn efficient
03:40:16 <ghorn> tdammers: what would be the next level in efficiency?
03:40:32 <tdammers> not sure... shared memory?
03:40:45 <bartavelle> zmq works with shared memory in a single process AFAIK
03:40:52 <bartavelle> but I'm no expert ...
03:40:57 <bartavelle> it's a socket abstraction
03:41:10 <merijn> tdammers, bartavelle: Yes, ZMQ uses shared memory and pipes when applicable
03:41:12 <bartavelle> you still have to pay for serialization though
03:42:07 <tdammers> but the serialization can be cheap
03:42:27 <tdammers> and the nice part is, you get networking for free
03:42:38 <tdammers> including transparent connects/disconnects and all that
03:43:11 <tdammers> I use it to drive a dzen2 in my xmonad setup
03:43:22 <tdammers> one end receives messages and pipes them into dzen2
03:43:37 <tdammers> the other end is started up as needed to flash messages
03:44:05 <tdammers> so I can send messages into the dzen2 toolbar from anywhere on my machine, even multiple concurrent processes
03:44:22 <tdammers> different scenario, obviously, but that's the kind of niceness you can easily get
03:46:09 <dmj`> supki: I need to learn migrations
03:46:54 <shiona_> oh, sorry. I just thought I'd pop some idea from google since nobody seemed to answer the question. I have totally no idea
03:46:56 <dmj`> supki: Data.SafeCopy docs seem to make sense, but I'm not sure how acid-state applies the migration instances
04:02:00 <Mimmo> ciao
04:02:05 <Mimmo> !list
04:02:05 <monochrom> Mimmo: http://lpaste.net
04:02:59 <chrisdone> ciao ragazzo
04:14:34 <danilo2> tdammers, ghorn: thank you! that is very interseting. I know zmq has some overhead because of the transfer and because of that we are looking for something better in this case. If we want to for exampel transfer full screen image at 30 fps we could have a problem
04:15:23 <danilo2> tdammers, merijn: If 0mq uses sghaared memory whee applicable its cool and that is exactly what we are looking for :)
04:15:49 <remdezx> Ok, so when zeromq is fine, what are you using for serialization?
04:16:39 <danilo2> tdammers, ghorn: Can we in this case somewhat ommit the serialization process?
04:18:56 <Feuerbach> When using conduits, how do I return a result not from the sink, but from the conduit in-between? E.g. source $= session $$ sink, I'm interested in the value produced by 'session'
04:49:18 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? bit.ly/1hcZveF is.gd/nFaH9z'
04:49:18 --- topic: set by monochrom!monokrom@216.138.220.146 on [Thu Oct 31 14:52:34 2013]
04:49:18 --- names: list (clog xl1 siriusbtx yorick ZioCrocifisso tranma t7 asmyers plhk asm89 Gorby__ bbee owst ehd nullcone tc [[zz]] Frugle Hexxeh2 emma go|dfish BigJ Kron Soft farn marcidy ion danvet macron otterdam xorox90 simpson sweeney ivasilov vivekrai Shaladdle albertid m1dnight Feuerbach opto ktosiek ft colluphid refold jamesjb predator117 nopcode Th0mas Athas eikke boffer joaopizani c_14 Raynes \u pcapriot` amathew1 uu1101_ kamatsu1 IceDanelol danr_ nulvinge_)
04:49:18 --- names: list (Slowpoke_Man hape01_ tamiko_ dropdriv1 otto_s_ kshannon_ WraithM_ jrw_ ent- Tinned_T1na Icewing_ anyfoo tessier_ ahihi2 companion_square geal_ Excedrin_ horlicks_ aegray JPohlman1 ahf ski_ cjay_ jzl_ MasseR_ cajla_ teneen etorreborre sepp2k_ jyyou_ theorbtwo Yawgmoth_ wagle_ Blkt q66 fijimunk1i razieliyo svecias30762 OlegYch7 stevely___ travisst1ton OscarZ JesuZ jobstijl0 nilsi_ simukis_ danharaj latermuse ulfdoz desc|zenbook shahn joneshf-laptop)
04:49:18 --- names: list (funfunctor asQuirreL Freundlich bio amritanshu_RnD qwandor ismlages kcj Palmik Rarrikins JobV segmondx myoriel boegel danilo2 Earnestly voxpopuli djanatyn Sorella_ juxovec Jabberish akegalj_ sbidin` mfzb mchqwerty zammy remdezx klaut_ arcke blebla ghorn lemao Guest7264 erkin og01 seschwar kludge` peterhil staafl Jonno_FTW ananthakumaran jalopezp1 ts33kr lpvb thunderrd SoupE brandonw Argue SirChurchill allsystemsarego quchen nominolo HalfWayMan)
04:49:19 --- names: list (sinclair|work general-general jungnam no7hing HugoDaniel augur edsko marr tesuji Itkovian etehtsea Machindo ersran9 rperry_ ByronJohnson TallerGhostWalt Tene uvelichitel mm_freak_ martinalex Okasu jonkri MercurialAlchemi mena Jesin-phone threesome pamojarpan caumeslasal raichoo halu hackagebot odi` ffog djcoin edon kushal evax Francisco tnks Kiryx sShintah alpounet Shin-LaC canta Jaxan ioanel phienone nick9573 codygman hvr akiress MrWoohoo ThomasLocke m6n_)
04:49:19 --- names: list (jefimenko RayNbow`TU lintguy RichyB latro`a_ sopvop kennyp satshabad rhodesd hashcat bscarlet sellout- mischov gienah dibblego adnap srcerer xxen preflex mauke Philonous xinming shanse td123 dmilith strobegen knigitz fylwind vendethiel apaku MooGoo hamishmack chrisdotcode Guest44172 jdegoes Mortomes_ kungp Ralith def-lkb arpunk_ tavelram__ ryantrinkle jonaias DT` schell Draconx|Laptop DrCode feyn jhormuz tomboy65 moto9 hajimeho_ gentleben saep dflemstr)
04:49:19 --- names: list (jcullen Nickeeh rarasd amosr tomaw mixi twilson liori profmakx apo Shapeshifter m0g katis castor2 c_wraith joogi Twey zacts joe9 nilg stianhj shutdown_-h_now perspectival dwcook Shieni udevd bgamari japesinator jrslepak strmpnk ofam Ptival coeus_ frase_ obcode Dorne_ mrd__ dabradley confound_ osfameron plcplc eL_Bart0- Liskni_s1 Thulsadu1 nik_89 necroyeti itamz bitemyapp capisce_ subfactorial certaint1 vili_ Bigcheese chrisdone jaimef puzza007 bobry kseo)
04:49:19 --- names: list (seanparsons jatwood stephe vervic purefn leifw mimico__ mp keelo idnar astronautaid Janiczek dr0nefs bgyss dziga qwerty| bentrevor DarkLinkXXXX ikke zero7 hungryblank Ghoul_ charlesofarrell_ gniourf IbnFirnas_ lopex nkpart dested shennyg upgrayeddd kfish strax aloiscochard Raynos akraut samrat_ Sieben ernst si14 sababa Xorlev tobyp jmct julmac tomh-_ ecube etrepum wilfredh chickenflu fser sclv_ Myk267 Excureo CindyLinz vmeson CaveJohnson andares_ pfoetchen)
04:49:19 --- names: list (Luke rndm exicer Khisanth Cerise_ phryk troydm pfeyz thetallguy1 dsfox exobit nabilhassein intrados loans shergill drbean byorgey copumpkin ccasin seynb Tarential FUZxxl vsayer ricky_clarkson cdidd ibotty _5kg Kabaka MoALTz fizruk malorie floatingman Morley93 adimit FireFly adinapoli guymann johnw Lethalman goldkatze averell yaxu Maxdamantus apples MitchW arkeet ixian Kneiva DarkFox wchun jle` tpsinnem isomorphic inarru aupiff mikecaruso joachifm mephx_)
04:49:19 --- names: list (wereHams1er dschoepe_ mikeplus32 k00mi ousado SwashBuckla mavam_ jrmithdobbs ibid fmapE fionnan_ carter dgvncsz0f cdk asjo mrshoe zorzar thetallguy jrib noddy2OOO mlen ashooby Pad^ folone _mkrull jack_rabbit doshitan lzm colah vikraman acharles ttm jorj [edwtjo] lpsmith robbert` sgs pharaun kakos_ IanKelling xnyhps Nimatek gseitz jcande_ ayako earthy Gothmog_ AtnNn hc honkfest1val aoh bentnib hsyl20_ xahry_ rasmusto_ KitB_ froztbyte sprang sajith_ sw1nn_)
04:49:19 --- names: list (geoffh_ Elision zomg M-ou-se yogurt_truck dreixel madariaga centrinia peterbb Gunni w3pm mendez Polarina kylcarte maoe Baughn helgikrs D9_ destiny lambdabot bytbox merijn nemesit|znc zol k4nar ocharles Iceland_jack AntiSpamMeta jlouis Spaceghost qz Saizan bind gds plucas_ Tesseraction bjorkintosh yastero ZsoL ryanRT smarter scottj fxr saml mikee hdevalence Paprikachu kmicu maksbotan_ gridaphobe ormaaj Bwild Hermit greymalkin joe1 xplat NickHu benj_)
04:49:19 --- names: list (Andrevan Neqoxec eevar zebr benmachine tibbe lkey Bram juhp chirpsalot Cale EarlGray1 fayden _d3f isenmann araujo djahandarie Eagle_Erwin ParahSail1n Lemmih copton lattenwald dolio srhb Mayzie eci McManiaC mandu tero- monochrom jackhill ant0wn dixie voyd Martingale @ChanServ pqmodn bezik banjiewen aristid sordina Deewiant lulf palmje aninhumer cynick Kinnison willb1 asante kryft d-snp isomorphismes FreakyPe1guin magicman bxc elliott tomejaguar myme)
04:49:19 --- names: list (jzelinskie sohum Reisen ortmage mokus yam marienz ejls nitin2 Hafydd Sunhay matthavener rfw bearclaw jb55 saurik betawaffle pdxleif paz_ so OrangeDuck tov solirc dilinger_ simon Cryovat cic thoughtpolice anhall Riussi mechairoi ido ReinH statusfailed nlogax Eridius Gracenotes nbouscal goodmanio deavidsedice kragniz Sornaensis pyykkis Walther Hardolaf zaphar_ps epsylon` adlan cross davorak_ tk_ Sagi munro joelteon mee xye- flazz_gone axiom geekosaur)
04:49:19 --- names: list (cschneid edk Amadiro pyrtsa jliikka kekimmo jcp jix heikkih Fuuzetsu mshroyer dyreshark rs0 saiam^ mrowe Clint luite Ke klugez Watcher7 angelicstrike peddie Belgarion0 michaelpj `bps_ mviljamaa smith_ supki Brando753 gereedy dsp_ pnielsen clemux lispy vhz boegel|work Tribal int-e radioxid ndngvr` aford gargawel wormwood Ornedan miasma zeroXten jamwt1 Dashkal drewr XMunkki mrmonday swistak35 Tehnix xiphias Ulrar mjo chipdude dogmaT_ bitraten mietek jang1)
04:49:19 --- names: list (kenkku opqdonut SaBer zoktar Plasmastar gemelen Kruppe wtw flux majackson andrewsw mero leroux mau_ Tril burp peder absence Edoxile solarus Entroacceptor igalic Svedrin scolobb raid anders^^ Rembane tomprince scshunt eagleflo stbuehler tippenein machisuji MetaCosm drdo h_chiro Vq milli peltchu _br_ bartavelle fall_ tpatja grazs rdevilla Squid_Tamer lahwran integral ivan\ ambul joneshf-work f8l lieven_ Enigmagic MasterTwit Pantoufle ve valdyn newsham)
04:49:19 --- names: list (RevJohnnyHealey PHO_ mangaba_leitosa Ycros kini tridactyla jmcarthur GaveUp Eliel ziman DonVitoC- relrod DustyDingo Derander AeroNotix ChongLi bergmark acfoltzer plains bbloom flori idoru mlinksva ValicekB melter jroesch tensorpudding Razz jrd0 twn mimi_vx_ Igloo alexsdut2on wto xaimus [swift] joeyh_ lpaste dqd sipa hpd Natch hongminhee sirspazzolot thorkilnaur ericmj fikusz stomp Nik05 Adios Martty zoli vobi ggreg hive-mind schoppenhauer lokydor _flow_)
04:49:19 --- names: list (Lindrian bben killy9999 mr- jonke xrq SHODAN ehamberg sunfun Vorpal marmaton jayne tych0 ashleywaffle SegFaultAX Phlogistique finnrobi sam_d pikhq quicksilver Boney spaceships mami Annamaria c_quark yeltzooo shelf liyang nanothief ssbr tristero Licenser theDon simonnn spion bz mantovan1 a11235_ joshsz cmsd2 felipe_ tahu Internet13 tromp_ shiona_ aforemny Sunhay__ mollerst1and zenzike_ rhelmer krakrjak Heffalump osnr kaol dpwright_ nwf b2coutts d3lxa tg)
04:49:19 --- names: list (yriw zw01 jssanders jonsterling mattp_ tsurutom inr bergey cods prophile bd_ Valodim petanqk alexsdutton Takumo computionist sa1 blakesmith cbw pjstadig heath Mowah jfhall tehroflmaoer n00dle EddSeabrook natte kbotnen noplamodo slobo dumbhat smlgs NNshag blast_hardcheese dmwit dawik neurocyte Jello_Raptor ibab petantik bogner lightquake dan64 rmunroe zerokarmaleft bstrie kxra Zariel ivan` sdrodge biscarch runde ciaranm kloeri zz_robj_ TheSpect1e blz37)
04:49:19 --- names: list (jlewis BrianHV Kurostrom Draggor numberten zugz qwxc rahul zeroskillor ninzine juuhaa Chousuke Dodek sfvisser DrSyzygy drmegahertz mxf _1126 dkua stvc wting luigy andihit brainproxy brisbin s2r2 Krakarn frihd_1 popx_ deggisv2 zeiris_ bens sm mgaare_ koala_man Laney AshyIsMe mononofu eyck_ suiside_ b_jonas fabjan_ mornfall gdsx_ MK_FG brixen b0c1 othiym23 linduxed KaneTW nklein ps-auxw mlh iulian paddymahoney shepheb arrdem CryptoCrack knyppeldynan dcoutts)
04:49:19 --- names: list (kloplop321 stelleg ryanakca nexion skypers Boreeas tinyghost vvv bcoppens aszlig s4msung noam doomlord_ ginmaniac raek yano kyrre gbarboza Counter-Strike `0660 jaspervdj gpampara nicoo AleXoundOS_ ozataman timemage fxrh solancile wollw jlamothe albel727 jnylen_ effy jbauman Spockz ParahSai1in dju jedai niko bholst apollolune manud kaw frontendloader ClaudiusMaximus kadoban BMeph_ neptunepink xymox meretrix Kuba hiredman arnsholt stiell alexander__b)
04:49:19 --- names: list (ninegrid alios_ n-dolio zarul CosmicRay mike2 funky_ ircbrowse agundry davean yac otulp stepcut Arnar barrucadu nikola ethercrow NeatBasis ikarus __main__ erikl_ fergusnoble haasn crs_ `^_^v stass epta notdan dv- _janne dougdougdoug pi8027 srh_ Ove_ TDJACR cpa clahey vvein jml pietore dlundy waterlaz hpc ljhms Zamarok Adeon pfurla tauntaun mirsal junsuijin etabot SLi squimmy tdammers Ezku mux Nahra fryguybob saiam maaku pierreghz Starfire demolithion Jaak)
04:49:19 --- names: list (Dtgr amontez kosmikus Hodapp mortberg yusukesuzuki julian____ nawulko dsantiago vnz kqr henk schlumpi Fubar^ seantallen cswords wunki)
04:49:26 <remdezx> tdammers: thanks :)
04:56:50 <pas43> why is it in ghci this creates a infinite loop: let list = 'a':list?
04:58:08 <cizra> Tried to compile LambdaHack, got this error message from "cabal install":
04:58:27 <lpaste> cizra pasted “lambdahack” at http://lpaste.net/95328
04:58:28 <tdammers> pas43: it's a recursive definition that doesn't terminate
04:58:49 <tdammers> 'let' is not a variable assignment, you know
04:59:03 <sbidin`> pas43: It creates an infinite list.
04:59:15 <sbidin`> > let as = 'a' : as in take 10 as
04:59:16 <lambdabot>   "aaaaaaaaaa"
04:59:42 <tdammers> the imperative equivalent would be something like function list() { return cons('a', list()); }
05:00:36 <pas43> okay thanks
05:01:59 <pas43> Is it esentially placing a a in the tail setion of the list instead of a null char?
05:02:29 <tdammers> not really, no
05:02:52 <tdammers> it defines 'list' to be a list where 'a' is the first element, and 'list' is the remainder
05:02:58 <quchen> list = 'a':list = 'a':'a':list = 'a':'a':'a':list = …
05:03:02 <tdammers> a list that is its own tail, if you will
05:03:14 <tdammers> such a list can only be an infinite list
05:06:01 <quchen> It's not really an infinite loop though, it's an infinite lazy list.
05:06:06 <quchen> You can still do useful things with it.
05:06:13 <pas43> tdammers: Ahh I see thanks!
05:06:14 <quchen> > let list = 'a':list in take 5 list
05:06:16 <lambdabot>   "aaaaa"
05:13:12 <allsystemsarego> > msum [Nothing, Just 1, Just 2, Nothing]
05:13:14 <lambdabot>   Just 1
05:29:00 <ocharles> http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html can anyone help me understand how sigfpe's Profunctor typeclass approximates the categorical definition above it?
05:29:39 <ocharles> I understand that D^op is the dual category of D, so can kind of see how that might be what (d' -> d) is
05:31:58 <supki> having  lmap  and  rmap  you can define  dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
05:32:23 <supki> and vice versa
05:32:39 <Saizan> ocharles: yeah, D^op corresponds that flip
05:33:44 <Saizan> he's basically taking D = Hask, C = Hask, and replacing Set with Hask too, since they share most of the important properties
05:34:36 <merijn> supki: Isn't that dimap just bimap?
05:34:39 <merijn> :t bimap
05:34:40 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
05:35:44 <supki> merijn: nope, p is contravariant in the first argument
05:35:55 <merijn> ah
05:36:07 <merijn> That's what I get for not paying attention :p
05:36:16 <ocharles> supki: and, would just dimap let you approximate that categorical definition?
05:36:50 <ocharles> i'm trying to figure out how sigfpe went from 'this is how it looks in maths' to 'this is how i can approximate it in haskell'
05:38:55 <supki> ocharles: do you understand how Functor is related to the categorical functor?
05:39:38 <ocharles> I think so. A functor in category theory takes objects to new objects (so that's what Functor itself does - taking a to f a), and morphisms between objects in the first category to objects in the new category - (a -> b) -> (f a -> f b)
05:39:47 <tdammers> well yeah, infinitely recursive definitions are not problematic per se
05:39:52 <tdammers> that's why Haskell allows them
05:40:00 <tdammers> you just can't evaluate them fully in finite time
05:40:55 <supki> ocharles: well, type constructor maps objects, and fmap maps morphisms -- yeah
05:41:05 <ocharles> right
05:42:07 <supki> ocharles: so, in Profunctor's case type constructor maps objects and dimap maps a pair of morphisms from Hask^op and Hask to a morphism on Hask
05:42:14 <individual> apart from using an IORef, is there any way to have dynamic auto-completion with haskeline (ie variables defined in a REPL can be completed)?
05:43:22 <ocharles> supki: so the two type parameters to 'h' in his Profunctor definition would be the two sides of the product - D^op and C?
05:43:42 <ocharles> and lmap and rmap can be used to define dimap
05:44:31 <Saizan> ocharles: yep
05:44:47 <ocharles> alright, that makes a lot more sense now!
05:45:10 <ocharles> I think the jump from dimap -> lmap/rmap is what lot me
05:45:40 <Saizan> you can prove that for a functor (A x B) -> C the action on morphisms can be splitted into two actions on each side, which are natural wrt each other
05:46:09 <Saizan> it's currying for categories :)
05:46:32 <exicer> Is hsenv widely used ?
05:46:35 <Saizan> A x B -> C ~ A -> C^B
05:46:53 <ocharles> actually one more q... what does the '-> Set' mean in the categorical definition? That a profunctor takes the product of D^op x C to the category of sets?
05:47:08 <Saizan> yeah
05:47:42 <ocharles> and is sigfpe using Hask as that?
05:47:50 <Saizan> yup
05:47:51 <ocharles> presumably that's what he means by endprodunctors
05:47:53 <ocharles> ok
05:48:14 <Saizan> Hask is handy as a constructive version of Set
06:03:16 * hackagebot persistent-redis 0.0.3 - Backend for Yesod persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.0.3 (PavelRyzhov)
06:11:30 <jonkri> Is there some performance difference between tail recursion and accumulative recursion in Haskell?
06:13:37 <Tinned_Tuna> jonkri: it depends, possibly; you're best bet for a given program is to benchmark. It should be the case that something which is tail-recursive in the formal sense (i.e. not building up a chain of thunks) should be optimised to something equivalent in time/space requirements as the equivalent accumulative/iterative.
06:14:42 <Tinned_Tuna> jonkri: but, you're best off trying it out for your specific case.
06:19:40 <jonkri> Tinned_Tuna: Could you give an example of an "informal" tail-recursion?
06:20:32 <jonkri> Tinned_Tuna: Should this optimization done by GHC, or is it part of the Haskell standard, or something else?
06:21:46 <Tinned_Tuna> I'm not familiar enough with the standard to say, I believe the optimisation is implemented by GHC though
06:22:04 <Tinned_Tuna> like I say, try it with a couple variations of the function definition
06:22:12 <Tinned_Tuna> montior time & memory usage
06:23:49 <cfoch> Hello. What's wrong here? There are conflicting definitions and I don't what happens ---> http://paste.ubuntu.com/6376542/
06:24:42 <Tinned_Tuna> cfoch: it will take the first pattern it finds, going from the top of the file
06:25:05 <Tinned_Tuna> clearly, the patterns on lines 3 & 4 are overlapping, but the pattern on line 3 will always be taken.
06:26:32 <Philonous> cfoch, using the same name twice in a pattern does not check for equality. So instead of f x x = ... you'll need f x y | x == y -> ...
06:26:59 <Tinned_Tuna> infact, all of the patterns are going to be short-circuited by the pattern on line 2.
06:27:12 <Tinned_Tuna> line 2 will always match, so that will always be taken.
06:28:18 <Philonous> cfoch, that "->" should have been an "=" though
06:31:46 <cfoch> Philonous: I will try it... thansk
06:32:43 <iLike> /j #reddit
06:32:48 <iLike> whoops
06:52:36 <cfoch> Philonous: I got it
06:53:33 <cfoch> why this code works ---> http://paste.ubuntu.com/6376648/  ? and...
06:53:36 <cfoch> this one doesn't work ---> http://paste.ubuntu.com/6376651/ ?
06:53:46 <cfoch> I think there's a problem with identation
06:53:57 <cfoch> but I'm not sure
06:54:26 <geekosaur> not indentation in this case. where *follows* guards
06:55:26 <geekosaur> (if you had a binding in the third expression then the where might have scoped to that, but that would cause other errors since it's needed in the other guards)
06:56:22 <allegy10> Hello everybody, was wondering if somebody knows about the dynamic linking situation on OS X with the HP. I thought with cabal 1.18 I could just make a new sandbox, do a 'cabal install --enable-shared --dependencies-only' and then build with '--enable-executable-dynamic' and it's done. But, it seems while the GHC core libraries have dynamic versions, the HP libraries like transformers-base are not distributed like that. I also can't 
06:57:07 <allegy10> ...new version in the sandbox. Anybody got this working?
06:57:44 <cfoch> geekosaur: could you correct this code please setting the condition with "where" in the middle?
06:58:20 <geekosaur> you have a line starting with "|" after the where clause. move it above the where clause
07:03:14 <Philonous> cfoch, btw. in your where clause you could just write "aux@(z', n') =  rutas s y rs" or even  "(z', n') =  rutas s y rs" since you don't seem to need the aux definition
07:03:44 <cfoch> geekosaur: where impacts on whole guards?
07:04:24 <geekosaur> where applies to a whole binding group
07:05:40 <geekosaur> the binding group starts with the binding (`rutas x y ...`) and ends with the last binding or guard. you have a guard after the where clause, so it no longer has a binding to attach to because the where ended the binding group
07:08:26 * hackagebot keter 1.0.1.2 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.0.1.2 (MichaelSnoyman)
07:08:53 <cfoch> thanks
07:09:49 <cfoch> btw... I've made some mini sample programs in wxhaskell... maybe the community of wxhaskell want them
07:10:00 <cfoch> how do I contact them?
07:12:54 <merijn> cfoch: The hackage listings for packages should specify a website/maintainer, that seems the right place to look
07:14:03 <iLike> I read so much about Lens, is it THAT useful?
07:14:23 <sopvop> @faq are Lens  THAT useful?
07:14:23 <lambdabot> The answer is: Yes! Haskell can do that.
07:14:52 <edwardk> iLike: i personally find it rather dramatically simplifies my code, but i'm a bit biased
07:15:38 <iLike> honestly I don't even know how to get started with them. Hell, I barely understand Applicatives & Monads :(
07:15:49 <sopvop> I find that I would like to use lens in a library, but don't want to force half of haskell platform on users...
07:16:23 <edwardk> iLike: don't feel the need to rush into lenses. pick up a little bit here and there as needed
07:17:10 <edwardk> sopvop: i figure between snap picking it up, diagrams, etc. its slowly becoming less of a burden to incur for a project. others have already paid the price
07:17:28 <merijn> iLike: Also, maybe play around with data-lens before moving on to full-blown "lens" lenses
07:18:02 <merijn> iLike: The drastically simpler type/small interface makes it easy to grok the basic notion before you move on to "actually lenses are generalised everything" ;)
07:18:22 <edwardk> the main issue with data-lens is that bcause you cn't do type changing assignments and because its such a limited interface it is very easy to 'fall outside of the useful range' of the API
07:18:28 <iLike> Here I am thinking monads were that..
07:18:34 <donri> i still want a lens-core just for *defining* lenses etc in libraries. it's not about ghc extensions, it's about weight and buy-in
07:18:50 <edwardk> donri: you can use lens-family for most of that
07:18:52 <merijn> edwardk: True, but for a beginner just having lenses into StateT records is already neat
07:18:58 <sopvop> edwardk: true, but snap and diagrams are huge. It's less of an issue for them. Also, more chance for cabal hell.
07:19:02 <edwardk> donri: if you want prisms and isos you can incur a dep on profunctors
07:19:08 <merijn> iLike: Everything is generalised everything in Haskell :)
07:19:24 <iLike> merijn, hah, yea that I noticed..
07:19:28 <merijn> Abstraction Oriented Programming ;)
07:19:34 <donri> edwardk: but i'd like a lens-core that exports the type synonyms, the iso/prism constructor functions etc
07:19:48 <Philonous> I'd pull in lens in a heart-beat in most of my projects if it was in the platform
07:19:50 <sopvop> maybe I should just copy get/set/modify into Internal.Util.hs :)
07:20:16 <merijn> iLike: Applicatives and monads are not actually that hard, especially if you first focus on just understanding types and typeclasses
07:20:21 <edwardk> the work to get lens into the platform would be somewhat daunting
07:20:23 <sopvop> It's like 30 lines of code
07:20:26 <merijn> iLike: Mostly people overthink applicative/monad :)
07:21:10 <merijn> iLike: Do you understand Functor?
07:21:31 <Philonous> edwardk, It would make using it a no-brainer though
07:21:46 * edwardk shrugs.
07:21:50 <edwardk> i try to build useful things, but focusing on minimalism is often at odds with that goal, as it means by construction that i'm providing fewer instances.
07:21:54 <iLike> merijn, I think so. That's the class which wants fmap implemented right?
07:22:06 <iLike> yea scrap that question, I understand them
07:22:07 <merijn> iLike: Yeah
07:22:09 <edwardk> i've since decided to just start going in the other direction because at least there are new thoughts to think out there.
07:22:18 <donri> edwardk: wouldn't it be nice if e.g. _Pure actually did have the nice type signature, not just "in disguise"
07:22:25 <edwardk> and that has more value to me
07:22:41 <merijn> iLike: So, "fmap (+)" would partially apply (+) to all the elements inside the functor, right?
07:22:51 <iLike> Don't fully understand the (->) Functor though.
07:22:58 <iLike> merijn, yea
07:23:00 <edwardk> donri: sure. i started using private unexported type synonyms in the profunctors package to facilitate that
07:23:08 <merijn> iLike: So "fmap (+)" takes you from "f a" to "f (a->a)"
07:23:20 <donri> edwardk: so move those to lens-core :p
07:23:23 <edwardk> donri: e.g. http://hackage.haskell.org/package/profunctors-4.0.1/docs/Data-Profunctor-Composition.html
07:23:32 <donri> or at least export them in profunctors
07:23:36 <iLike> merijn, makes sense, yea.
07:23:40 <merijn> iLike: Applicative is just "if I have a functor with functions inside, can I get that function out to use it again?"
07:24:25 <merijn> iLike: i.e. "(<*>) :: Applicative f => f (a -> b) -> f a -> f b" says "if I have a function inside an "f" and a value inside an "f", I can apply the function to the value and get a result in "f"
07:24:50 <edwardk> the question becomes what is enough for the core? do we include indexed lenses/traversals? actions? some of the methods? template-haskell? nobody can agree on what that dividing line should be
07:25:04 <iLike> merijn, that actually makes sense..
07:25:05 <edwardk> its really easy to argue for any one of those tings
07:25:11 <edwardk> and i get people asking me for each
07:25:17 <iLike> but why do we want <$> as an operator then?
07:25:19 <merijn> iLike: (Well, in reality Applicative also requires the existince of "pure :: Applicative f => a -> f a" which sense I can put anything inside the "functor")
07:25:20 <edwardk> but putting them all in gives you lens =P
07:25:38 <edwardk> and splitting into all of those packages is crippling for users
07:26:26 <merijn> iLike: <$> is identical to fmap so you can write either "fmap fun x <*> y" (here fun :: a -> b, x :: f a) or "fun <$> x <*> y"
07:26:43 <fizruk> donri, how do you use _Pure ? just out of interest
07:26:45 <merijn> iLike: So <$> really only exists because having an infix fmap looks nice sometimes
07:26:47 <donri> edwardk: it should just be type synonyms and the basic constructor functions. so you can make lens-based APIs without depending on lens or having scary type signatures or weird code
07:26:50 <edwardk> i'm not terribly against exporting useful aliases from profunctors
07:26:51 <donri> fizruk: duno
07:27:01 <iLike> merijn, ahhh, now that makes perfect sense
07:27:06 <edwardk> i also have very little bandwidth between now and the 20th
07:27:10 <fizruk> donri, :)
07:27:20 <edwardk> so more pressure now isn't likely to convert into a usful result ;)
07:27:22 <merijn> iLike: Because that makes it easy to "insert" pure functions into the functor
07:27:56 <donri> edwardk: i've considered rolling lens-core myself, but optimally i'd like lens to use the same synonyms for cross-linking documentation purposes etc
07:28:26 <merijn> iLike: The nice thing about Applicative is that if your function takes more than 2 (i.e. 3, 4, etc." arguments, you can just keep adding more <*> until it comes out right
07:28:32 <edwardk> we have a lens-core on the lens account that could be updated
07:28:35 <iLike> AForms in Yesod just got way more clear :P
07:28:43 <merijn> iLike: :)
07:28:49 <edwardk> the problem with your lens-core suggestion from a haddock perspective s the docs are in terms of functions you wouldn't have!
07:29:00 <edwardk> view/set/etc
07:29:00 <iLike> merijn, thanks a lot
07:29:02 <donri> good point
07:29:02 <merijn> iLike: The difference from Applicative to Monad isn't that big either
07:29:41 <merijn> iLike: Monad can do only two things that Applicative cannot 1) "join :: m (m a) -> m a" and 2) "(>>=) :: m a -> (a -> m b) -> m b"
07:29:45 <edwardk> the last time this came up that was the crack in the dam that made us worry we'd have to include some combinators, etc.
07:30:24 <edwardk> and the docs for the types without those methods are pretty much completely unmotivated and opaque
07:30:32 <merijn> iLike: The first one is "simple", you can essentially fuse nested copies of a Monad into a single one (for list this would be "concat :: [[a]] -> [a]", for example)
07:30:33 <donri> i wish haddock had better support for cross-linking, something more like what python's sphinx does...
07:30:37 <edwardk> anyways, talk to me on the 20th when i can stop and breathe =)
07:30:39 <iLike> merijn, is join a sort of lift?
07:30:48 <merijn> iLike: Or "Maybe (Maybe a) -> Maybe a"
07:30:59 <merijn> iLike: It's more like the reverse of a lift, it's compacting layers
07:31:02 <donri> edwardk: what happens on the 20th
07:31:07 <edwardk> otherwise this'll jus loom as another thing I can't do anything about
07:31:15 <edwardk> i get back from a long trip
07:31:21 <donri> aha
07:31:29 <iLike> merijn, makes sense
07:31:45 <edwardk> i fly out tomorrow to budapest, then i'm wandering around eastern europe doing talks for a couple weeks
07:31:54 <merijn> iLike: You can't have "Maybe a -> a" because it might be Nothing, but you *can* do "Maybe (Maybe a) -> a" because if the outer Maybe is "Nothing" you just return "Nothing", else you return the inner Maybe
07:32:16 <iLike> merijn, but what if we have like, "MyMonad (Maybe a)"? We MyMonad can't be joined in the Maybe monad right?
07:32:29 <merijn> iLike: No, all m's in the type are the same
07:33:07 <merijn> iLike: So "join :: m (m a) -> m a" would work on "MyMonad (MyMonad a)", but not on the MyMonad (Maybe a) one
07:33:10 <iLike> merijn, why isn't the 2nd example of type "Maybe (Maybe a) -> Maybe a"
07:33:34 <merijn> iLike: Because I can't type :D
07:33:36 <donri> or maybe if there was a way to have build-depends only on hackage or for building haddocks :P quite a hack but alas
07:33:53 <iLike> merijn, ahh cool, I thought I didn't understand it haha :P
07:34:21 <merijn> iLike: So why do we need the other difference (i.e. ">>=") if we already have <*>?
07:35:24 <iLike> merijn, so that we can 'inject' a pure value into a monad?
07:35:31 <iLike> no wait
07:35:43 <merijn> iLike: Applicative already has pure which is identical to return
07:35:56 <iLike> so that we can use an impure value into a 'pure' function
07:36:14 <merijn> iLike: No, let's take a look at IO now. "(<*>) :: IO (a -> b) -> IO a -> IO b"
07:37:16 <merijn> iLike: The side effects of "IO (a -> b)" and "IO a" are both "known" (i.e. they side effects of "IO a" don't depend on the result of the first one that produces the function)
07:37:59 <merijn> iLike: "(>>=) :: m a -> (a -> m b) -> m b", the second argument is "a -> m b" which means it's a normal haskell function that can do whatever it likes based on the result of "m a"
07:38:28 <merijn> iLike: I could have "readNumber >>= \num -> if odd num then actionA else actionB"
07:38:48 <merijn> iLike: In other words, with Monad the action that is being returned can depend on the result of the action before it!
07:39:14 <dv-> is there a unicode character for >>=? or ++?
07:39:17 <merijn> iLike: Applicative doesn't let you do that, which "side effects" happen cannot depend on the result of older action
07:39:31 <merijn> dv-: There is a common LaTeX way to typeset them, but no unicode, afaik
07:40:07 <iLike> merijn, alright, but why do we still have Applicatives then?
07:40:20 <merijn> iLike: In other words, Applicative always runs all side effects while Monad can conditionally run different side effects (or skip side effects by running "return ()")
07:40:29 <iLike> since monads are basically a superset of applicatives?
07:40:31 <merijn> iLike: Because not all Applicatives can be made Monads
07:40:38 <merijn> iLike: Same reason we have Functor
07:40:40 <iLike> o.O
07:40:41 <geekosaur> dv-, you can define your own. UnicodeSyntax only provides for stuff that can't be done any other way
07:40:55 <merijn> iLike: All monads are applicatives, but not all applicatives can be made monads
07:41:11 <merijn> iLike: So code that works on Applicative can potentially be used more often
07:41:29 <geekosaur> :: is baked in, so a replacement has to be baked in as well. (>>=) is an ordinary infix operator, you can pick a character and bind it to (>>=)
07:41:41 <iLike> merijn, I take it there are no simple examples of applicatives which cannot be made into monads?
07:41:43 <geekosaur> (well, it has to be Symbol syntax)
07:42:10 <dv-> geekosaur: UnicodeSyntax? I'm working with pretty-mode.el
07:42:32 <pqmodn> iLike another way to understand their relationship is (<*>) can be implemented using (>>=), but not the other way around. similarly, fmap can be implemented using (<*>) and pure or (>>=) and return so all Monads can be "made into" Functors
07:42:52 <geekosaur> ah. wouldn't know about that, aside from that there is some argument over what symbols various people like
07:42:52 <merijn> iLike: There is one, but it might look a little silly at first
07:43:10 <merijn> iLike: Because it seems rather useless, if you want a lecture on its usefulness, ask edwardk ;)
07:43:35 <merijn> iLike: Does this code make sense to you? "data Const a b = Const a"
07:43:56 <iLike> merijn, why add a b there
07:44:01 <Philonous> merijn, ZipLists are useful
07:44:02 <iLike> but otherwise, yea it looks fine
07:44:30 <dv-> geekosaur: I'm just looking for things I can replace to make the code look nicer. for example ⎨ for $
07:44:31 <merijn> iLike: That was the silliness I meant, it's used with great effect in lens, though!
07:45:12 <merijn> iLike: Right, we can make "Const a" a functor in the silly sense "fmap :: (a -> b) -> Const x a -> Const x b; fmap f (Const x) = Const x"
07:45:36 <iLike> yea
07:45:49 <iLike> Const (f x) btw?
07:46:06 <merijn> iLike: No, "x" has type "x", not type "a" :)
07:46:22 <merijn> iLike: There is no "a" inside it, so we can just return the same thing with a different type
07:46:54 <iLike> Oh never mind, I wasn't looking closely enough at the type
07:47:05 <merijn> iLike: Hmm, I just realised the applicative instance only works if "x" is a monoid, so that might be a bit tricky
07:47:25 <iLike> monoids have a mempty and a mappend, right?
07:48:03 <merijn> Yeah, you need it for "pure x = Const mempty"
07:48:20 <merijn> "pure :: Monoid x => a -> Const x a"
07:48:22 <iLike> Don't worry, I get what monoids are
07:48:31 * hackagebot purescript 0.1.5 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.5 (PhilFreeman)
07:48:40 <merijn> "(<*>) :: Monoid x => Const x (a -> b) -> Const x a -> Const x b"
07:49:09 <merijn> "Const x <*> Const y = Const (mappend x y)"
07:49:21 <merijn> Still make sense?
07:49:49 <iLike> sort of. How does haskell know how to change the a to b?
07:49:58 <merijn> iLike: Because the types tell it too
07:50:07 <iLike> Okay
07:50:38 <merijn> iLike: It's inferred, and because there's no value to change, we just update a fake (phantom! hence we call these things phantom types, types with no "body" on the value level)
07:50:46 <merijn> iLike: Now we get to the interesting bit
07:50:59 <merijn> iLike: If we try to make a Monad instance for "Const x", we're boned
07:51:09 <donri> you can only specialize the type of an existing value, but you're making a new Const here
07:51:36 <merijn> iLike: "(>>=) :: Monoid x => Const x a -> (a -> Const x b) -> Const x b"
07:52:03 <merijn> iLike: But the second argument (a -> Const x b) requires an actual 'a', and we can't give it one, because we've been faking the existence of 'a'!
07:52:25 <enthropy> iso-recursive types are another word for infinite types?
07:52:53 <iLike> merijn, that makes sense as well
07:52:57 <merijn> iLike: Hence making Const a datatype that can be Applicative, but not Monad
07:53:15 <merijn> iLike: There are some others, like ZipList, but I can't explain that one of the top of my head.
07:53:28 <iLike> but generally we want monads, since there exist Functor and Applicative instances for Monads, right?
07:53:28 <merijn> iLike: Other types exist, but tend to be in the more confusing/abstract types
07:53:49 <merijn> iLike: If something *can* be a monad, it's preferable yes
07:54:02 <iLike> yea that's what I meant indeed.
07:54:05 <merijn> iLike: But for generic code it's preferable to *use* Applicative, because then it'll work for more
07:54:24 <Saizan> enthropy: iso- is like in haskell, with an isomorphism, equi- is with equality, so infinite types come up in the latter
07:54:26 <iLike> cool cool
07:54:32 <merijn> iLike: (Although at the moment Applicative is not a superclass of Monad, that should be getting changed soon)
07:54:33 <Saizan> *are allowed
07:54:36 <donri> (so you couldn't say, instance Functor (Const a) where fmap f a = a, even though it looks like the same thing as, fmap f (Const a) = Const a)
07:55:06 <merijn> iLike: Also, after this you might wanna read up on this blogpost and then hopefully the confusion should be mostly gone :p
07:55:11 <Philonous> iLike, Lists form an applicative under zipWith ($) for <*> and repeat for pure (fmap is the usual list map)
07:55:15 <merijn> @google You Could Have Invented Monads
07:55:16 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
07:55:16 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
07:55:24 <donri> merijn: it's not always sensible to make an applicative a monad just because you can. sometimes that monad is silly
07:55:31 <donri> for example Wire
07:55:32 <merijn> donri: Oh, sure
07:55:57 <merijn> donri: But that seems awfully pedantic for the generic interpretation of that question :p
07:56:04 <Philonous> > (\(ZipList a) -> a) $ (*) <$> pure 11 <*> ZipList [2,3,5,7,11] -- iLike
07:56:06 <lambdabot>   [22,33,55,77,121]
07:56:13 <donri> probably, didn't follow the whole conversation
07:56:48 <Philonous> iLike, You need the extra constructor because lists themselves are Applicatives(and Monads) in a different way
07:57:34 <iLike> Philonous, you just broke my minde :-P
07:57:38 <iLike> mind*
07:58:56 <merijn> iLike: another good way to learn this is just try and implement Functor, Applicative and Monad for every datatype you write and see if you find ones where you can't (don't forget to check whether you obey the laws afterwards!)
07:59:14 <iLike> Philonous, translated to introduction level haskell that says: map (*11) [1,2,3,5,7,11] right?
07:59:39 <iLike> other than that the list isn't a ZipList..
07:59:47 <iLike> merijn, I've been doing just that :)
07:59:50 <merijn> iLike: Basically, he's saying there's two Applicatives, because you can implement "[a -> b] -> [a] -> [b]" two ways
07:59:53 <pqmodn> > getZipList $ (*) <$> ZipList [2,11] <*> ZipList [1,2,3,4,5]
07:59:55 <lambdabot>   [2,22]
08:00:02 <merijn> iLike: i.e. cartersian product and pairwise application
08:00:05 <pqmodn> > (*) <$> [2,11] <*> [1,2,3,4,5]
08:00:06 <lambdabot>   [2,4,6,8,10,11,22,33,44,55]
08:00:08 <fizruk> is there a function: until :: Monad m => (a -> Bool) -> m a -> m a   or an alternative in base?
08:00:23 <merijn> fizruk: Not a base, but take a look at monad-loops
08:00:25 <iLike> I wonder whether Quickcheck can be used to test monad properties though?
08:00:28 <merijn> @hackage mond-loops
08:00:28 <lambdabot> http://hackage.haskell.org/package/mond-loops
08:00:40 <merijn> @hackage monad-loops
08:00:40 <lambdabot> http://hackage.haskell.org/package/monad-loops
08:00:42 <merijn> whoops
08:01:22 <fizruk> merijn, thanks)
08:02:09 <Philonous> iLike, Yes. That's what it boils down to.
08:02:26 <fizruk> I thinks it's cheaper to prove laws by hand ?
08:03:04 <iLike> what Applicative does Haskell choose?
08:03:27 <iLike> or is that defined in whether it's in a Monadic function or an apllicative function
08:04:10 <Philonous> iLike, It maps  (*) over an infinite list of 11, so you get an infinite list of partially applied functions [11*, 11* ...] and then it applies each of those functions to the item in the list with the primes in a pair-wise fashion, that is the list indices match.
08:05:49 <Philonous> iLike, And the longer of the list is trimmed to size.
08:05:55 <merijn> iLike: The default is the cartesian product one, although there is a newtype (ZipList, hence the name) that does pairwise
08:06:17 <merijn> iLike: The main reason is to have the default applicative match the monad instance (which ZipList can't provide)
08:06:18 <fizruk> > zipWith (^) <*> tail $ [1..]
08:06:20 <lambdabot>   [1,8,81,1024,15625,279936,5764801,134217728,3486784401,100000000000,3138428...
08:06:31 <iLike> Philonous, and if we had omitted the "pure" in "pure 11", we'd get an error right?
08:06:38 <Philonous> iLike, Yes.
08:06:56 <Philonous> iLike, 11 is not a ZipList.
08:07:03 <iLike> exactly
08:07:03 <merijn> It could be!
08:07:19 <iLike> (goes off to writing ZipList instances)
08:07:46 <Philonous> merijn, That strikes me as postmodern.
08:07:58 <merijn> Philonous: Num instance for ZipList!
08:08:07 <merijn> Philonous: Strikes me more as worthy of acme-php :)
08:27:29 <moops> is there a balance somewhere between the expressiveness of parser combinators and the "strictness" of LALR parsers like yacc which disallow ambiguous grammars?
08:27:44 <danharaj> edwardk probably knows
08:27:48 <danharaj> parsing is his jam.
08:29:09 <moops> and maybe thats not inherent to parser combinators, ive just been playing with parsec the past couple of days
08:29:59 <moops> and i feel like what yacc would report as shift/reduce or whatever errors, have now become runtime parse errors
08:35:40 <iLike> merijn, Philonous_ thanks a bunch for your explanation guys!
08:38:49 <moops> easy fix would just be to statically determine if your grammar was ambiguous
08:38:53 <moops> someone should get on that
08:39:36 <geekosaur> someone probably has gotten on that. sounds like at least a couple of Ph.D.s to me :)
08:41:26 <moops> kidding, 90% sure its undecidable :P
08:43:34 <geekosaur> some parts of it are undecidable, sure, but if yacc can spot a reduce/reduce conflict than other tools can as well. what's not so clear is whether you can encode that in a type...
08:44:00 <geekosaur> *then other tools
08:44:10 <moops> if you restrict the grammar then yea
08:44:35 <moops> LALR is pretty restrictive and unnatural to encode imo
08:45:45 <heath> tips on converting for loops into recursive statements?
08:45:52 <heath> e.g. https://gist.github.com/heath/87379dc8757c15aa311a
08:53:55 <fizbin> heath: Both those examples seem to follow the pattern of "iterate over a structure, accumulating data about it into another thing". That pattern is usually best handled in Haskell by one of the fold* functions: foldr, foldl, foldl', foldM
08:58:03 <Cale> example1 looks a bit silly, if I'm understanding what it means correctly
08:58:29 <Cale> Why iterate over the key/value pairs in a map and then test whether the key matches the one you're looking for?
08:58:54 <Cale> Finite map structures are intended to make key lookups better than linear time :P
09:00:41 <Cale> Perhaps something like: Map.unionWith (+) states (Map.fromListWith (+) (zip (map location labs) (repeat 1)))
09:03:30 <Cale> example2, I don't understand what is being computed
09:04:10 <Cale> heath: still here?
09:04:15 <heath> i am
09:04:23 <heath> i'm refactoring
09:04:40 <heath> doing something like...
09:04:41 <heath> fold add_one, @scope.states[key], @scope.states
09:04:58 <heath> using http://preludels.com/#foldl
09:05:21 <heath> it doesn't have to be livescript, this just happens to be what i'm using
09:05:42 <heath> fizbin: that was a helpful response btw, Cale, i'm reading your responses now
09:05:52 <asuk> @pl (\k t -> chr $ a + flip mod 26 (ord k + ord t -2*a))
09:05:55 <lambdabot> (id chr .) . ((a +) .) . (flip mod 26 .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
09:05:55 <lambdabot> optimization suspended, use @pl-resume to continue.
09:06:26 <asuk> @Pl-resume
09:06:32 <lambdabot> (id chr .) . ((a +) .) . (flip mod 26 .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
09:06:32 <lambdabot> optimization suspended, use @pl-resume to continue.
09:07:07 <Cale> Well, to answer your original question, you can convert any imperative algorithm into a recursive functional one by replacing all mutable variables with function parameters, and replacing all statements (points in the control flow) with separate functions, and have each function apply the function for the next statement in the control flow to the updated values of the variables.
09:07:49 <Cale> This will typically result in a bit of a mess, but it'll almost always be a mess that you can immediately start to simplify.
09:09:00 <shiona_> is there a zip-like function for lists of lists?
09:10:23 <supki> shiona_: transpose?
09:10:43 <supki> > transpose [[1,2,3],[4,5,6],[7,8,9]]
09:10:47 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
09:10:54 <shiona_> supki: kinda, but that would take only as many elements that are in the smallest list
09:11:14 <supki> like zip? :)
09:11:18 <shiona_> of course I can later just use take, but I thought there might be one readily done
09:11:45 <supki> oh, I see
09:11:52 <shiona_> > zip [1,2,3] [4]
09:11:53 <lambdabot>   [(1,4)]
09:11:57 <quicksilver> > transpose [[1,2,3],[4],[5]]
09:11:59 <lambdabot>   [[1,4,5],[2],[3]]
09:12:08 <quicksilver> transpose works on ragged rectangles
09:12:15 <quicksilver> not sure what you want though
09:12:43 <quicksilver> > transpose [[1],[4,9,9],[5]]
09:12:44 <lambdabot>   [[1,4,5],[9],[9]]
09:13:14 <shiona_> > (\x -> take (minimum $ map length x) $ transpose x) [[1,2,3],[4,5],[6,7,8,9]]
09:13:15 <lambdabot>   [[1,4,6],[2,5,7]]
09:13:27 <apo> > transpose [[1,2,3],[4],[5,6,7]]
09:13:28 <lambdabot>   [[1,4,5],[2,6],[3,7]]
09:13:37 <apo> :)
09:14:27 <shiona_> what I wrote is what I want, is this the way to go or is there a neat mathematical term, class and a set of functions that implement this
09:15:55 <Kron> what would be the fastest way to take two functions, foo and bar, and make a new function (f x y = foo (bar x) (bar y))?
09:16:11 <Cale> :t on
09:16:12 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:16:15 <Kron> is there some elegant function composition approach for this?
09:16:26 <Kron> it's a pattern I see in my code a lot
09:16:28 <Cale> It's in Data.Function
09:16:30 <Cale> as on
09:16:56 <supki> > getZipList $ traverse ZipList [[1,2,3],[4,5],[6,7,8,9]]
09:16:57 <mr-> Kron: foo `on` bar
09:16:58 <lambdabot>   [[1,4,6],[2,5,7]]
09:17:03 <chrisdone> Function was already taken by auspicious dragons
09:17:13 <shiona_> supki: ok, thanks
09:17:39 <shiona_> I thought it might have something to do with traversible, but I haven't had time to look into that
09:17:46 <mr-> > ((==) `on` length) [1,2] [4,5,6] -- Kron
09:17:48 <lambdabot>   False
09:18:44 * hackagebot purescript 0.1.6 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.6 (PhilFreeman)
09:18:46 <heath> Cale: that's a really helpful response
09:19:14 <heath> i hadn't found a clear answer on converting an iterative function into a recursive one
09:19:17 <heath> ty
09:20:47 <geekosaur> heath: a list is a loop
09:20:50 <Cale> heath: It's a useful approach if you're really stuck, but usually you'll want to actually understand what's going on a little better first.
09:21:07 <geekosaur> this probably is not that clear to you as yet, but it's the key thing you need to learn
09:21:30 <Cale> and yeah, better to try to replace loops with lists :)
09:22:12 <Cale> Just as a loop either doesn't happen at all (because its precondition isn't met) or consists of a single iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
09:23:41 <Cale> We fill in the "loop body" by transforming lists using higher order functions. This sort of turns the code "inside out" from how you might expect to see it in an imperative language, but that's a good thing -- it turns out to be far more composable.
09:24:15 <mr-> When you say a list is a loop, do you mean that loops are foreach $element in @array, so it's just a fold over the array anyway?
09:24:28 <geekosaur> a fold or a map, or etc.
09:24:45 <geekosaur> rercursive operations on a list are the same as a for loop
09:24:49 <geekosaur> *foreach
09:25:03 <geekosaur> (a for loop in C style is just that applied to a list of numbers)
09:25:23 <chrisdone> the trivial case, at least
09:25:55 <geekosaur> true. C is actually a bit more interesting, but most people try to avoid the tings C *can* do there because it's less comprehensible
09:26:19 <geekosaur> otoh the IOCCC is a thing...
09:26:40 <rasfar> like conditionally modifying the index in the body of the loop...
09:26:54 <geekosaur> yep, that too
09:27:02 <SwashBuckla> SICP is full of examples of "turn this recursive function into an iterative one"
09:27:18 <SwashBuckla> that can help exercise that way of thinking
09:27:38 <SwashBuckla> heath: ^
09:28:39 * chrisdone prepares earl grey orange and cinnamon tea ^_^
09:29:26 <frx> is f = Just . head  not the same as  f xs = Just . head $ xs?  why am I gettin this error? http://lpaste.net/3893451088627499008
09:29:29 <Kron> did anyone see my last question? I lost my internet connection D:
09:30:45 <geekosaur> Kron, if that's the one about the f (g x) (g y), it's Data.Function.on
09:31:01 <geekosaur> Cale was answering you while you were still expanding on it :)
09:31:22 <geekosaur> :t Data.Function.on
09:31:23 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:31:24 <mr-> Kron: like (==) `on` length
09:33:01 <glguy> frx: You have to have the same number of arguments in each case of your function definition
09:33:02 <mr-> frx: that's not answering your question, but what you are implementing is called listToMaybe in Data.Maybe
09:33:30 <glguy> frx: and there's nothing wrong with Just (head xs). No bonus points for using all the operators :)
09:33:47 * hackagebot purescript 0.1.7 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.7 (PhilFreeman)
09:34:17 <frx> glguy :t Just . head is [a] -> Maybe a. why doesn't it work?
09:34:25 <glguy> frx: You have to have the same number of arguments in each case of your function definition
09:34:38 <geekosaur> I think there's some discussion on the haskellwiki as to why ghc doesn't let you mix foo x = ... and foo = ...
09:34:51 <geekosaur> it's complicated
09:35:10 <glguy> the number of explicit arguments in each case must be exactly the same
09:35:18 <glguy> if you pattern match in one case you have to name it in the other
09:35:37 <frx> really? first time I noticed this
09:35:49 <geekosaur> yes, really
09:36:44 <frx> pattern matching head looks nicer anyway. still, odd limitation.
09:36:51 <ghorn> is this the most up to date greencard documentation http://www.dcs.gla.ac.uk/fp/software/ghc/ghc-doc/green-card.html ?
09:37:08 <geekosaur> ...greencard is up to date?
09:37:54 <ghorn> some people are still using it
09:38:23 <ghorn> is hsc2hs better? i'm tired of writing bindings by hand....
09:50:28 <iLike> Does anyone here actually have a job where they use Haskell every day?
09:51:27 <chrisdone> iLike: a bunch of us =)
09:51:58 <iLike> chrisdone, do you?
09:53:03 <chrisdone> iLike: yup. i work at fp complete
09:53:36 <iLike> Ah, cool. I was about to ask, why did you choose Haskell as the language for that project, but that's kind of obvious now..
09:54:20 <bennofs> What are the advantages of using haskell-src-exts over the GHC API? It seems haskell-src-exts is simpler (is it also faster?), but the GHC API supports more GHC extensions of course (like ConstraintKinds or LambdaCase). Are there more differences between the two when you just want to parse haskell code (and have no problem depending on GHC of course)?
09:55:54 <chrisdone> bennofs: so i looked into this a wee bit the other week. GHC's parser is about twice as fast as HSE, but both parsing are so fast that you're talking the difference between 10ms and 20ms for a 400 line module
09:56:27 <chrisdone> bennofs: HSE parses into Strings, ghc into FastStrings. HSE's tree is definnitely simpler, with fewer overengineered ADTs that make you use accessor functions just to look inside
09:56:45 <Cale> bennofs: The GHC API is obviously not just a parser/prettyprinter
09:56:50 <alkabetz> Eww, FastStings :(
09:56:53 <chrisdone> bennofs: and GHC's tree actually contains bottom so you have to tread carefully around then, god forbid you do some generic operations
09:57:13 <Cale> But I think I would prefer haskell-src-exts from a user interface standpoint.
09:57:16 <alkabetz> *FastStrings
09:57:51 <alkabetz> The presence of FastStrings alone is enough to convince me that haskell-src-exts is probably what you want to use unless you really need to interface with GHC specifically
09:57:59 <chrisdone> bennofs: GHC is more likely to parse haskell correctly. i don't mean extensions, but generally, HSE has parsing bugs for haskell 98
09:58:08 <iLike_> Yay for crappy internet
09:58:13 <chrisdone> alkabetz: why's that?
09:58:40 <alkabetz> FastStrings make it very complicated to parallelize your code.  They’re the reason GHC still can’t build in parallel. :(
09:59:02 <bennofs> alkabetz: GHC 7.8 will be able to build in parallel AFAIK
09:59:07 <frx> when refering to a list of lists, do you prefer [] or [[]]?
09:59:10 <chrisdone> albel727: ah, sucky
09:59:14 <frx> :t [] :: [[a]]
09:59:15 <lambdabot> [[a]]
09:59:20 <frx> :t [[]]
09:59:21 <lambdabot> [[a]]
09:59:29 <chrisdone> the former because that's empty
09:59:30 <simpson> frx: Those are two different things.
09:59:35 <chrisdone> [[]] is not an empty list
09:59:40 <simpson> > []:[]
09:59:41 <Cale> iLike_: I've been working for skedge.me, the backend for skedge.me is written in Haskell using Snap. The old backend was in a horrible language called Groovy, and was ridiculously difficult to maintain.
09:59:41 <lambdabot>   [[]]
09:59:45 <alkabetz> bennofs: Yay! :)
09:59:56 <frx> ah right, my mistake
10:01:40 <chrisdone> iLike: crappy internet. in holland?
10:01:46 <chrisdone> iLike: get outta town!
10:02:09 <Cale> iLike: I actually didn't make the decision to use Haskell (but I agree with it!)
10:02:11 <iLike> chrisdone, well sometimes it randomly disconnects. Otherwise, I get about 60mbit/s down, which is pretty good
10:02:28 <iLike> (haha, "pretty good")
10:02:32 <bennofs> Well, missing ConstraintKinds support is a bit of an issue for me, as I use it in some projects. So I think I'll go with the GHC API.
10:02:34 <FreeFull> :t [] :: [] ([] a)
10:02:35 <lambdabot> [[a]]
10:02:52 <iLike> Cale, cool. Can you tell me anything about the things you work on on a daily basis?
10:03:01 <alkabetz> bennofs: Go for it.  Good luck!
10:03:24 <iLike> chrisdone, does FP complete hand out student licenses to students from the netherlands as well?
10:03:52 <frx> @src transpose
10:03:53 <lambdabot> transpose []             = []
10:03:53 <lambdabot> transpose ([]   : xss)   = transpose xss
10:03:53 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
10:05:36 <Cale> iLike: Well, it's mostly pretty boring code. One thing I've worked on a bunch is just a lot of the stuff dealing with backend handling of emails -- there are many different conditions on which our system needs to send out emails, and then the values of various splices need to be determined in order to fill out templates.
10:07:21 <Cale> and different customers have different requirements in that regard, so it's just a lot of working out ways to encode that business logic in some fashion that doesn't make us pull our hair out too much
10:07:55 <iLike> Cale, just a typical programmer's job then
10:08:23 <iLike> how is development speed compared against, say C# or Java?
10:08:44 <Cale> I haven't done much real world programming in either of those languages
10:08:50 <Cale> But I suspect it's comparable or better.
10:09:47 <simpson> iLike: I've done real-world Java. Haskell is so much more enjoyable, if for nothing else than not having to type as much.
10:09:58 <prooftechnique> > let filter' = filter . not in filter' even [1..10]
10:09:59 <lambdabot>   Couldn't match type `GHC.Types.Bool' with `a0 -> GHC.Types.Bool'
10:10:00 <lambdabot>  Expected ...
10:10:11 <prooftechnique> @let filter' = filter not
10:10:12 <Cale> (probably many times better in some places, but "business logic" is almost always a horrible mess, regardless of the language you choose to encode it in)
10:10:13 <lambdabot>  Defined.
10:10:23 <alkabetz> iLike: Yeah, don’t learn Haskell because you think it’ll be faster.  Learn it because you’ll think it’ll be more fun.
10:10:26 <prooftechnique> > filter' even [1..10]
10:10:27 <lambdabot>   Couldn't match expected type `[t1] -> t0'
10:10:28 <lambdabot>              with actual type `[G...
10:11:04 <pqmodn> @pl (\p xs -> filter (not.p) xs)
10:11:04 <lambdabot> filter . (not .)
10:11:21 <iLike> simpson, agreed on the not having to type as much, Java's a real pain when it comes to readability and expressiveness
10:11:24 <Cale> Before my current job, I was working for a startup on an action RPG in Haskell for phones and other mobile devices.
10:11:40 <bartavelle> Cale, I'd say that the ability to write arbitrary monads and thus create nice DSLs is awesome for business logic. Just the Maybe, List and Either monads are awesome.
10:11:55 <MattY> > let filter' p = filter (not . p) in filter' even [1..10]
10:11:56 <lambdabot>   [1,3,5,7,9]
10:12:02 <simpson> iLike: I did Forths at one point and now I make readability and simplicity into big priorities.
10:12:07 <bartavelle> but I only wrote a tiny bit of business logic, so I might be deluded
10:12:33 <iLike> alkabetz, I started learning haskell for a functional programming course, about 10 weeks ago, now I'm kind of hooked by the type system.
10:12:54 <iLike> Only thing is, I'm so much faster in C# than I am with Haskell
10:13:49 <Cale> and we built a pretty decent FRP system, and got the game up to the point where it had combat and AIs and a pretty large and detailed world, but it was still missing a lot of the stuff to make it into the RPG we wanted to make, and while it ran fine on a desktop, there was still a fair amount of performance tuning to get it running well on phones. It's on hiatus for now, but we'll probably come back to it at some point.
10:14:01 <haasn> C# is slowed down by having to type all of the unnecessary type signatures :)
10:14:36 <schell> Cale: what was the company you were writing games for?
10:14:41 <Cale> iPwn
10:14:51 <schell> haha - awesome name
10:14:57 <bartavelle> :)
10:14:59 <MattY> iLike for general programming tasks, or when building GUI programs?  for the latter, something like Gtk + Gtk Builder will speed up development considerably
10:15:18 <MattY> compared to creating the GUI programatically
10:15:38 <iLike> MattY, for general tasks as well as for GUIs
10:15:52 <schell> Cale: what were you using for graphics - OpenGL?
10:16:13 <MattY> I find developing in haskell much faster for general programming tasks
10:16:39 <iLike> it depends on what I'm trying to do
10:17:11 <iLike> but I'm just not as used to thinking functional as opposed to imperative
10:17:13 <Igloo> Cale: How's that pronounced?
10:17:39 <iLike> iPoon :-x
10:18:07 <Cale> Igloo: Despite the fact that we all know that pwn is pronounced "own", it's pronounced with the P just because non-gamers might be confused.
10:19:19 <Cale> schell: Yeah, we had an abstraction around OpenGL. We were originally planning to have a small part of the game written in C++ to avoid stutter when major GCs took place, which would basically just put animations and models and such on the screen as directed by the Haskell code, we ended up writing a lot of that code in Haskell as well, and the performance wasn't too bad from that side of things.
10:19:51 <Cale> It was unclear whether we'd have to stick with the C++ or not nearing the time when we stopped, because phones are getting more powerful
10:19:59 <frx> iLike you most likely know C# a lot better than haskell
10:20:28 <alkabetz> iLike: Yeah, speed comes with practice, in my experience.
10:20:29 <schell> Cale: were you also using ghc-ios for iPhone compilation?
10:20:37 <iLike> true that
10:21:12 <Cale> schell: Yeah, we were responsible for that, or rather the credit should all really go to Stephen Blackheath, who was one of us :)
10:21:38 <Cale> I think some others have gotten involved since
10:22:10 <schell> ah - cool - i follow the mailing list but haven't tried it yet
10:22:12 <carter> chrisdone: thats a good gif
10:22:23 <chrisdone> carter: huh?
10:22:24 <schell> i probably will after 7.8 is out
10:22:45 <carter> chrisdone: the giff about cool projects
10:22:56 <chrisdone> oh, hehe
10:23:11 <kuznero> Hi All!
10:23:52 <Cale> Which gif is that?
10:24:15 <Cale> Hello kuznero!
10:24:22 <moops> is there a name for this sort of thing? (a -> b -> c) -> (c -> d) -> (a -> b -> d)
10:24:49 <moops> almost composition but not quite
10:24:56 <prooftechnique> @hoogle  (a -> b -> c) -> (c -> d) -> (a -> b -> d)
10:24:57 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
10:24:57 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
10:24:57 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:25:04 <prooftechnique> That's on
10:25:11 <augur> its composition of a binary function
10:25:28 <simpson> @pl \f g a b -> g (f a b)
10:25:31 <lambdabot> flip ((.) . (.))
10:25:31 <lambdabot> optimization suspended, use @pl-resume to continue.
10:25:41 <pqmodn> it's often called .:
10:25:45 <prooftechnique> I love that one
10:25:57 <pqmodn> @type (.:)
10:25:58 <lambdabot>     Not in scope: `.:'
10:25:58 <lambdabot>     Perhaps you meant one of these:
10:25:58 <lambdabot>       `.' (imported from Data.Function),
10:26:13 <moops> i dont see how its on
10:26:16 <FireFly> @let (.:) = fmap fmap fmap
10:26:17 <lambdabot>  .L.hs:247:13:
10:26:17 <lambdabot>      No instance for (Functor f0) arising from a use of `fmap'...
10:26:19 <augur> its not on
10:26:22 <prooftechnique> Nevermind, I was wrong
10:26:22 <augur> its more general than on
10:26:24 <prooftechnique> Ignore that
10:26:27 <augur> but really, on should be generalized
10:26:33 <prooftechnique> @let (.:) = (.) . (.)
10:26:35 <lambdabot>  Defined.
10:26:39 <prooftechnique> :t (.:)
10:26:40 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:26:52 <moops> :D
10:26:53 <prooftechnique> :t flip (.:)
10:26:54 <lambdabot> (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
10:26:57 <moops> thanks all
10:27:34 <augur> (.:) is a nicer function that flip (.:)
10:27:44 <duairc> Does anybody know how to enable the expansion of CPP macros inside comments?
10:27:58 <prooftechnique> @let (:.) = flip (.:)
10:27:59 <lambdabot>  .L.hs:248:1:
10:27:59 <lambdabot>      Not in scope: data constructor `:.'
10:27:59 <lambdabot>      Perhaps you meant...
10:28:13 <augur> negate .: (+)   is better than   (+) :. negate
10:28:18 <augur> unless you're into ; for composition
10:28:26 <chrisdone> Cale: http://ircbrowse.net/browse/haskell?id=16789315&timestamp=1383809964#t1383809964
10:28:27 <pqmodn> prooftechnique, identifiers begining with : are reserved for data constructors
10:28:33 <prooftechnique> Oh, derp
10:29:00 <Clint> pqmodn: does anything use that?
10:29:08 <pqmodn> Clint: use what?
10:29:11 <moops> i actually wanted .: and not flip .:, for some reason i always search the arguments in reverse order :P
10:29:16 <Clint> pqmodn: :dataconstructors
10:29:27 <geekosaur> infix data constructors? sure
10:29:33 <pqmodn> sure, how about lists, non-empty lists, ...
10:29:45 <FireFly> The rather well-known (:) :p
10:29:48 <Clint> oh
10:30:09 <pqmodn> @hoogle (:+)
10:30:09 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
10:30:11 <haasn> :+ from Data.Com-- yeah
10:30:21 <haasn> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=%3A
10:30:56 <geekosaur> also :% from Data.Ratio although I think most people use % or / in practice
10:32:50 <arkeet> % does some normalization and stuff
10:33:31 <chrisdone> 2/4 -> 1/2 etc
10:33:37 <arkeet> not that Data.Ratio exports (:%)
10:33:40 <FreeFull> > 3 :% 6
10:33:41 <lambdabot>   Not in scope: data constructor `:%'
10:33:42 <lambdabot>  Perhaps you meant one of these:
10:33:42 <lambdabot>    `:+...
10:33:49 <FreeFull> > 3 % 6
10:33:50 <lambdabot>   1 % 2
10:33:58 <arkeet> 3 :% 6 will give you 3 % 6
10:34:04 <arkeet> @let import GHC.Real
10:34:06 <lambdabot>  Defined.
10:34:09 <arkeet> > 3 :% 6
10:34:10 <lambdabot>   3 % 6
10:34:27 <FreeFull> > 3 :% 6 + 1
10:34:29 <lambdabot>   3 % 2
10:34:38 <FreeFull> Seems any sort of operation will normalise though
10:34:48 <arkeet> > 3 :% 6 * 1
10:34:49 <lambdabot>   1 % 2
10:34:50 <arkeet> yeah
10:36:11 <prooftechnique> I wonder if that happens for a reason. Maybe there's a use case for unreduced fractions :D
10:36:38 <prooftechnique> Probably just doesn't do type level math
10:36:52 <joelteon> > 3 :% 6
10:36:54 <lambdabot>   3 % 6
10:36:54 <mike4> hi i typed for the first time ghci
10:37:00 <mike4> and Prelude> came
10:37:08 <lpaste> moops pasted “No title” at http://lpaste.net/95341
10:37:09 <mike4> how can I exit it?
10:37:10 <moops> can this .: function be generalized to some sort of fold? is that expressible in haskell?
10:37:14 <prooftechnique> mike4: :q
10:37:18 <mike4> ok
10:37:20 <prooftechnique> or :quit
10:37:37 <mike4> thx
10:37:50 <mike4> is prelude different from ghci?
10:37:57 <FreeFull> mike4: You can write :help to see the various built-in commands
10:38:01 <prooftechnique> Prelude is just the standard library
10:38:11 <geekosaur> the prompt shows the modules that ghci has loaded; by default that is Prelude
10:38:17 <geekosaur> you can use :m or import to load others
10:38:28 <mike4> ok
10:38:28 <geekosaur> or :l to load a program
10:39:46 <prooftechnique> :t foldr (.) (.)
10:39:47 <lambdabot> [((a -> b) -> a -> c) -> (a -> b) -> a -> c] -> (b -> c) -> (a -> b) -> a -> c
10:40:05 <prooftechnique> That looks complicated
10:40:54 <FreeFull> What would that be useful for?
10:41:03 <prooftechnique> I dunno yet
10:41:26 <prooftechnique> :t foldr (.) (.) [negate 4]
10:41:27 <lambdabot> Num (((a -> b) -> a -> c) -> (a -> b) -> a -> c) => (b -> c) -> (a -> b) -> a -> c
10:41:33 <FireFly> foldr (.) id  seems like it'd be more useful
10:41:50 <FreeFull> :t foldr (.) (.) [id,id,id]
10:41:51 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:42:05 <FreeFull> :t (.)
10:42:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:43:18 <glguy> :t ala Endo foldMap
10:43:20 <lambdabot> Foldable t => t (a -> a) -> a -> a
10:44:07 <glguy> > ala Endo foldMap    [(+2), (*3), subtract 4] 0
10:44:09 <lambdabot>   -10
10:47:52 <FireFly> :t ala
10:48:02 <glguy> :t (ala)
10:48:03 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
10:48:46 <glguy> :t ala Endo
10:48:47 <lambdabot> (((a -> a) -> Endo a) -> e -> Endo a) -> e -> a -> a
10:49:39 <prooftechnique> Well, I tried to unify that with something other than id, and it just didn't wanna. *shrug*
10:51:55 <nathanfh> @pl \a b c -> head . tail . sort $ [a,b,c]
10:51:58 <lambdabot> (((head . tail . sort $) .) .) . flip ((.) . (.) . (:)) (flip ((.) . (:)) (: []))
10:51:58 <lambdabot> optimization suspended, use @pl-resume to continue.
10:52:09 <nathanfh> @pl-resume
10:52:15 <lambdabot> (((head . tail . sort $) .) .) . flip ((.) . (.) . (:)) (flip ((.) . (:)) (: []))
10:52:15 <lambdabot> optimization suspended, use @pl-resume to continue.
10:53:18 <lpaste> henk pasted “diddohs” at http://lpaste.net/95342
10:54:05 <lpaste> henk annotated “diddohs” with “diddohs (annotation)” at http://lpaste.net/95342#a95343
10:55:47 <henk> hey guys, my brain is stuck regarding IO again /-: http://lpaste.net/95342 I need to get the timezone for a time, but getTimeZone returns an IO thing which I can’t use. And I still don’t quite understand how to work around that. Would anyone please give me a nudge in the right direction?
10:55:59 <geekosaur> >>=
10:56:16 <geekosaur> (IO thing) >>= \x -> (now x is your thing)
10:56:34 <geekosaur> BUT: you must put it back in IO afterward
10:56:48 <moops> and every function that uses that function will be tainted by IO as well
10:59:29 <schell> henk: you can also use '<-'
10:59:37 <quchen> What happens in IO, stays in IO.
10:59:42 <monochrom> haha edwardk: "You have to love it when unsafePerformIO is the safest option"
10:59:47 <edwardk> =)
11:00:26 <zomg> unsafePerformIO is like doing it without a condom
11:00:27 <edwardk> monochrom: i managed to get that stuff to work in structures BTW. its not yet a speed win or anything though
11:00:32 <zomg> Thank you, you've been a great audience!
11:00:34 <zomg> Good night!
11:01:04 <schell> zomg: you're saying it's the best?
11:01:08 <edwardk> i was mostly looking for deamortization without too much of a speed hit, but right now the hit is ~8x
11:01:12 <zomg> schell: lol :P
11:01:21 <edwardk> this is rapidly devolving into #haskell-blah material
11:01:38 <schell> lockdown
11:01:48 <arnsholt> henk: What you probably want to do is grab the timezone in your main, and then pass that as an argument to the functions that need it
11:03:19 <rasfar> \me pasted "Repa performance" http://lpaste.net/95344
11:03:57 <rasfar> anyone using or considering Repa? your comments on that paste are invited
11:10:07 <henk> Thanks for all the answers. I’m still stuck though. Is it normal that it takes a while for a programming noob to get the hang of monads/IO in haskell? I feel dumb.
11:10:21 <geekosaur> yes
11:10:23 <klugez> henk: Perfectly normal.
11:10:50 <tibbe_> Can we use the maybe monad if we have several IO (Either a b) actions in a row?
11:11:11 <Cale> tibbe_: You might be able to use EitherT
11:11:21 <henk> arnsholt: hm, are you sure that works? I’m mapping that function over a list of timestamps …
11:11:41 <tibbe_> Cale: Doesn't that require that IO is the inner monad?
11:12:01 <tibbe_> Cale: the use case is some library that has lots of functions in IO that return IO (Either a b)
11:12:30 <henk> ok, I’m a little relieved now, thanks (:
11:12:53 <Cale> newtype EitherT e m a = EitherT { runEitherT :: m (Either e a) }
11:13:00 <dv-> why does DisambiguateRecordFields only work for records defined in seperate modules?
11:13:08 <arnsholt> henk: Should work. "tz <- getTimeZone utctime" tz is then an instance of TimeZone. Add an argument of type TimeZone to epochToTime string and pass in tz
11:13:33 <arnsholt> Add the "tz <- ..." to your main, I mean
11:13:34 <Cale> So the EitherT constructor's type specialises to IO (Either a b) -> EitherT a IO b
11:13:51 <arnsholt> Above the let
11:14:51 <geekosaur> dv-: see http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
11:15:00 <geekosaur> the issue is that a field name is an ordinary function
11:15:31 <geekosaur> and you can't normaly have two functions with the same name in the same scope
11:17:37 <dv-> geekosaur: right. but with the extension you can
11:18:05 <geekosaur> "With -XDisambiguateRecordFields you can use unqualified field names even if the corresponding selector is only in scope qualified"
11:18:10 <geekosaur> it's a bit of a cheat
11:18:46 <geekosaur> there are ongoing discussions of how to do what you want. it's not easy and there are lots of cases that different people would like to see handled in different ways
11:20:26 <dv-> yeah
11:20:54 <Feuerbach> dv-: DisambiguateRecordFields is about /using/ record selectors. But your problem happens when you're (implicitly) /defining/ selector functions
11:22:06 <Feuerbach> if only you could suppress creation of those functions (and instead create only selectors which you use in the record syntax), it would've been fine
11:22:07 <henk> arnsholt: o_O wow, if that works, I’ll … uhm sit here with my mouth open for a minute or so …
11:22:49 <dv-> Feuerbach: why not let me define them and then use the same logic as if they came from different modules?
11:23:23 <DanielDiaz> is there anyway to make a "cabal install" fail if installing a dependency failed? I want cabal to stop trying to install other dependencies if one of them has failed.
11:23:25 <geekosaur> same name
11:23:41 <geekosaur> if they come from different modules, they can be disambiguated by the module name/prefix
11:23:48 <geekosaur> if they;re in the same module they are an error
11:24:10 <geekosaur> fixing this requires one of the poposals to make them typeclass instances or etc.
11:24:36 <dv-> but there's no module name here: ok1 (MkS { x = n }) = n+1   -- Unambiguous
11:24:47 <lpaste> henk pasted “diddohs” at http://lpaste.net/95345
11:25:04 <Feuerbach> dv-: "them" can mean two different things. There are selector functions (ordinary Haskell values) and fields used in the record syntax. There's no way to disambiguate the former, and neither there's a way to separate these two notions in the Haskell land. You have to understand that DisambiguateRecordFields only works with the record syntax
11:25:42 <henk> arnsholt: Is that kinda what you had in mind?
11:26:17 <moops> henk: yea thats what id do
11:26:20 <geekosaur> again: record fields act as *functions*. you can't have foo :: Int and foo :: String in the same program. you likewise cannot have record fields named foo of different types, *for exactly the same reason*. (you cannot prevent the record selector function from existing)
11:26:31 <geekosaur> sorry, in the same module
11:26:58 <geekosaur> your example was for pattern match, which has somewhat different constraints
11:28:22 <chrisdotcode> can you use a let in in a do block, or is it limited to let?
11:29:16 <Feuerbach> > do let a = Just 3 in a
11:29:16 <lambdacat>  Terminated
11:29:16 <geekosaur> hm? you can use an expression-let, or there's a special form available in do-blocks (without the "in")
11:29:46 <DanielDiaz> > do let x = 2 in return x
11:30:06 <DanielDiaz> that worked in GHCi
11:30:21 <chrisdotcode> geekosaur: yeah, I know that much; I was just curious if I could attach an "in" or "where" to a single "let" and not the entire thing.
11:30:24 <chrisdotcode> but I guess not
11:30:33 <alkabetz> Wait, who is lambdacat?
11:30:39 <Feuerbach> did I just kill a (lambda) cat?
11:31:42 <geekosaur> chrisdotcode, I'm not sure I understand the question. you can use let ... in just as well as you can elsewhere. where scopes to a binding group as usual, including one in a let
11:32:37 <geekosaur> (binding group = one or more bindings + guards with the same name, as: let b 5 = 6; b 7 = y + 2; b x = y + 1 where y = ...)
11:32:38 <chrisdotcode> geekosaur: like: do { let x = 5 in x + 4; m <- action; return (m + x); }
11:32:47 <chrisdotcode> is that vali?
11:32:50 <chrisdotcode> *valid haskell
11:33:12 <moops> is there a good intro to arrows somewhere? preferably with some exercises? i just know of them, nothing about them
11:33:14 <Feuerbach> no, x will be out of scope
11:33:28 <Feuerbach> you just terminated its scope with 'in'
11:33:49 <geekosaur> no, that's an ordinary let ... in, the scope of x ends with the end of the in expression (plus it's not in the monad plus you're ignoring the result(
11:33:58 <monochrom> what is x+4 doing there?
11:34:07 <Feuerbach> that's another question ;)
11:34:16 <geekosaur> that's what I meant by ignoring the result
11:34:44 <chrisdotcode> okay, cool. I get it now. thanks guys
11:34:50 <haasn> moops: mm_freak_ had a good one but his website has been down for some time
11:34:59 <henk> moops: It says "diddohs.hs:14:21: Not in scope: `utctime'" (Well, actually it does not run like it’s on the paste, but the fix to that is unrelated to the error.
11:35:42 <moops> what is the type of utctime and where are you expecting it to come from?
11:35:56 <moops> maybe you forgot to import it at the top?
11:36:07 <henk> moops: line 53
11:37:25 <moops> oh hmm
11:39:16 <schell> Cale: why did you stop working with iPwn?
11:39:54 <henk> I guess I’ll undo these changes and see if I can figure out how and where to use <- or >>= or (: or something (;
11:40:29 <Cale> schell: The company ran out of funds, so I ended up working for the same guy (Ryan Trinkle) at the other company he worked for :)
11:40:41 <moops> so you get the timezone in that function but you need to pass it a timezone? im confused
11:41:32 <henk> moops: Thanks, now I am too …
11:42:09 <schell> Cale: well that's a bummer they ran out of money before the game shipped
11:42:17 <henk> moops: Yeah, you are right, that code is probably bananas
11:42:20 <Hari`> hi
11:42:30 <mischov> Does anybody who uses Emacs have an up-to-date explanation of their setup re Haskell?
11:42:41 <moops> ah henk try putting this above
11:42:49 <moops> utctime <- getCurrentTime
11:43:02 <arnsholt> henk: Yeah, that's pretty much it, but TimeZone is a type, not a typeclass, so epochToTimeString :: Num t, => t -> TimeZone -> String
11:43:13 <moops> may have to import that functino from Data.Time.Clock
11:43:15 <Cale> schell: Well, yeah, it would have been nice to actually ship something. It was fun and I learned quite a bit about FRP though.
11:43:36 <schell> Cale: oh, what FRP lib did you end up using?
11:43:43 <henk> arnsholt: Yeah, but line 53 populates utctime and the complete undertaking is stupid, moops made me realise (;
11:43:49 <Cale> schell: Our own.
11:44:00 <Cale> (it's not released to the public)
11:44:11 <schell> yet? ;)
11:44:17 * schell crosses fingers
11:45:35 <henk> moops: No, that’s not what I need, AFAIU. I have lists of timestamps that I need this function to be mapped over. But it’s all wrong anyway. I’ll need to rework the logic. After dinner. Thank you and everyone else commenting very much. I’ll be back. (;
11:45:41 <Cale> We might come back to the project at some point, and figure out where to cut things to open source, and hopefully get things into working order to be able to sell something as well. :)
11:46:29 <Cale> schell: One of the really annoying things is that you can't have infix type variables any more, so there will be a few thousand lines which need to be reworked in that regard :P
11:46:42 <int-e> @bot
11:46:55 <lambdabot> :)
11:48:56 <joelteon> :t (^.)
11:49:03 <lambdabot> s -> Getting a s a -> a
11:50:21 <schell> Cale: infix type variables?
11:50:25 * schell is a noob
11:51:27 <Cale> schell: (Arrow (~>)) => ... a ~> b ...
11:52:34 <Cale> schell: GHC changed syntax since that code was written so that ~> would now be interepreted as a type constructor, so that won't work. There are various tricks which can be done to recover similar syntax though, it'd just be a lot of annoying editing
11:53:15 <schell> Cale: how long had you worked on that game?
11:54:44 <Cale> Good question, I'm not sure exactly. A couple years?
11:56:45 <oconnor0> is there a way to define a fully specialized type class? i'd like to define a "Show [Bool]"
11:59:43 <Cale> oconnor0: You would have to define showList for Bool differently, which is impossible since there's already an instance of Show for Bool.
12:00:15 <Cale> oconnor0: However, if what you mean is that you'd like a new typeclass with an instance specifically for [Bool], that is possible by turning on FlexibleInstances
12:01:10 <Cale> oconnor0: At the time the Prelude was written, FlexibleInstances didn't exist, and so a trick was used in order to allow showing lists in different ways at specific types
12:01:19 <Cale> (specifically String)
12:01:29 <Cale> and that's what showList is about
12:03:10 <int-e> A small public service announcement: please direct your complaints about lambdabot to me (not elliott) in the future :)
12:03:18 <Cale> int-e: okay
12:03:42 <Cale> int-e: I was confused about who was running it for a while there :)
12:03:50 <oconnor0> Cale: hm, when i enable FlexibleInstances and define an instance of Show [Bool], GHC complains about overlapping instances, is there a way to resolve that?
12:03:59 <Cale> oconnor0: Don't use Show
12:04:12 <Cale> oconnor0: There's already an instance of Show for [Bool], so you can't write another one.
12:04:49 <oconnor0> Cale: ah, ok, is there a way to hide that instance?
12:05:03 <danharaj> no
12:05:12 <oconnor0> k, thanks
12:05:22 <danharaj> You should think of instances as globally defined always.
12:05:36 <danharaj> If you want to hide an instance it usually means you are thinking about something incorrectly.
12:06:11 <Cale> You can of course just write your own function [Bool] -> String
12:06:12 <asmyers> Does anyone know the best way to use Persistent with an existing data structure?  I like the library but don't want it driving my type definitions and database schema
12:06:16 <Cale> and then use that
12:06:32 <asmyers> I would like to just map existing ADTs to a user defined schema
12:06:32 <oconnor0> right, thanks Cale & danharaj
12:08:28 <oconnor0> so what does FlexibleInstances allow for then?
12:09:50 <Cale> oconnor0: Haskell 98 had a restriction on instances which says that an instance head must consist of a type constructor applied to some distinct type variables
12:10:31 <Cale> oconnor0: FlexibleInstances relaxes that condition, so that you can apply type constructors to fixed types, or use type variables which aren't distinct
12:10:59 <Cale> e.g. in Haskell 98, having an instance for [a] was okay
12:11:10 <Cale> but not for [Bool], because Bool isn't a type variable
12:11:50 <Cale> As another example you could have an instance of something for Either a b, but not for Either a a, and not for Either String a
12:11:54 <quchen> Cale: Are there any pitfalls with that?
12:12:04 <quchen> I'm always wondering how safe using some extensions is
12:12:14 <Cale> quchen: It makes instance resolution slightly less trivial to implement
12:12:25 <Cale> But it's perfectly safe
12:12:44 <quchen> So I can put it on the list of things I can unconditionally enable?
12:12:47 <oconnor0> got it, so because Show has an instance for [a] (which covers [Bool]), that doesn't work, but if [a] wasn't defined adding FlexibleInstances would allow me to define a type class for [Bool], [Int], etc.?
12:12:47 <Cale> yeah
12:13:00 <quchen> Nice. Thanks
12:13:05 <Cale> In fact, FlexibleInstances for the longest time didn't even have a name
12:13:22 <Cale> GHC just implemented things that way and allowed the instances :P
12:13:40 <Cale> (until someone complained that it wasn't strictly allowed in Haskell 98)
12:13:57 <Cale> oconnor0: right
12:14:02 <quchen> So it was factored out?
12:14:06 <Cale> quchen: yeah
12:14:12 <quchen> Sneaky GHC devs.
12:14:12 <oconnor0> Cale: cool, thanks :)
12:14:48 <Philonous> That's a bit like complaining to a traffic cop that your fine isn't high enough.
12:15:35 <danharaj> not really
12:15:59 <danharaj> It's like telling your driver to obey *all* the traffic laws.
12:24:13 * hackagebot language-c-quote 0.7.4 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.7.4 (GeoffreyMainland)
12:24:15 * hackagebot labyrinth-server 0.1.1.0 - A complicated turn-based game - Web server  http://hackage.haskell.org/package/labyrinth-server-0.1.1.0 (AlexeyKotlyarov)
12:39:25 <diamium> Could anyone please help me get a callback working with GHCJS and jQuery-ui, starting with https://github.com/co-dan/ghcjs-jqueryui/blob/master/test/Test.hs, I've tried changing line 34 to "    _ <- change handler def sliderDiv"
12:47:33 <lpaste> fizruk pasted “Funny error message (GHC 7.6.3)” at http://lpaste.net/95348
12:49:56 <joelteon> fizruk: you have to runReader at some point
12:50:46 <fizruk> joelteon, I know, but the error message is funny to me :) "the function ... is applied to 1 argument but it's type ... has 1"
12:52:30 <AshyIsMe> yo
12:52:34 <AshyIsMe> oops, ww
13:02:08 <skypers> hey
13:02:17 <iLike> \o
13:02:29 <skypers> I tested to open a file
13:02:31 <skypers> 20 Mo
13:02:41 <skypers> with yi
13:02:51 <skypers> yi takes 7 Go of RAM
13:03:09 <skypers> and the document is still not open
13:03:49 <alkabetz> Yikes.
13:04:09 <alkabetz> Do you want to debug Yi? :)
13:04:19 * hackagebot reified-records 0.2.0.0 - Reify records to Maps and back again  http://hackage.haskell.org/package/reified-records-0.2.0.0 (jozefg)
13:05:33 <teneen> Any hints on how to binarize a structure using Data.Bits.Coding?
13:08:09 <skypers> 21:53 < alkabetz> Do you want to debug Yi? :)
13:08:10 <skypers> well
13:08:17 <skypers> not really for one logic reason
13:08:25 <skypers> what does yi offer over vim?
13:09:06 <fizruk> nice scripting language?
13:09:23 <skypers> fizruk: vim is quite nice as well I guess
13:11:12 <fizruk> skypers, I don't have to use vimscript, so I'm okay with it. yet I remember it being not very nice
13:12:00 <fizruk> perhaps it only concerns syntax highlighting/indenting
13:14:15 <FireFly> skypers: probably easier-to-read source code, at least :p
13:16:01 <skypers> sure FireFly :D
13:16:02 <skypers> well
13:16:19 <skypers> I’m looking for some tuto to get deeper into vim
13:16:31 <skypers> I’ve been using it for two or three months
13:16:37 <skypers> but I use the basic things of it
13:17:01 <skypers> x, dd, a, i, A, I, r, R, visual block edition
13:17:02 <skypers> netrw
13:17:08 <skypers> I need to get more into it
13:17:09 <skypers> using macro
13:17:11 <skypers> snippets
13:17:15 <skypers> refactoring
13:17:17 * FireFly learned vim by hanging out in #vim and reading/participating there, and via help pages
13:17:18 <skypers> and so on
13:17:22 <FireFly> the built-in help pages are wonderful
13:17:26 <skypers> yeah
13:17:31 <skypers> sure they are :)
13:17:56 <skypers> I use :sh sometimes
13:18:00 <skypers> it’s great :)
13:18:08 * FireFly usually ^Z's out or uses :! instead
13:18:42 <FireFly> anyway, I'm not sure if we should turn this into a second #vim
13:19:10 <Ghoul_> :q!
13:19:30 <fizruk> :P!
13:21:33 <skypers> yeah
13:21:45 <diamium> GHCJS: Please help: trying to get a callback working with jqueryui, tried modifying "https://github.com/co-dan/ghcjs-jqueryui/blob/master/test/Test.hs", line 34 to " _ <- click handler def sliderDiv" or " _ <- change handler def sliderDiv", compiles, but still does nothing when sliding.
13:22:12 <skypers> FireFly: :! is great, but do you know how to retrieve stdout from :! and paste it at the cursor?
13:24:40 <FireFly> skypers: :h :r!
13:25:19 <FireFly> skypers: also, :! with a range runs the range through the external command, so e.g. :%!sort sorts the entire buffer
13:25:58 <skypers> woah, it sounds so advanced for me :D
13:26:26 <FireFly> Hehe
13:26:31 <geekosaur> skypers, if you just want to capture output from a command, :r !whatever
13:26:49 <skypers> like :r a_file then
13:26:52 <skypers> great :)
13:33:24 <quchen> Is there a way of getting the size of a TBQueue?
13:33:32 <quchen> Current size, maximum size?
13:33:39 <carter> TBQueue in the STM package?
13:33:55 <quchen> Yes
13:34:07 <carter> quchen: does the data type let you? :)
13:34:21 <quchen> carter: That's the problem. Yes, but that part is not exported.
13:36:08 <quchen> I came across this when using Pipes.Concurrent, but that builds directly on the standard STM package.
13:36:21 <teneen> are there bit arrays in haskell?
13:36:37 <quchen> Knowing the current size of a queue could be useful to implement some form of load balancing for example.
13:36:46 <carter> nope
13:36:54 <carter> how would it be for load balance?
13:37:04 <carter> just have multiple consumers
13:38:25 <quchen> Suppose you want to keep a number of channels uniformly filled. Right now you can't do that, or at least I can't.
13:38:51 <benmachine> teneen: I'm pretty sure the answer is yes but I'm not sure I can remember where
13:38:55 <quchen> You can of course use a tuple of (TVar Int, TBQueue Foo) to keep track of everything manually.
13:39:08 <benmachine> teneen: possibly the unboxed vectors from the vector package
13:39:12 <carter> quchen: why are you organizing it that way?
13:39:30 <carter> why not have them pull from the same channel
13:39:39 <carter> or use a chase lev deque?
13:39:41 <skypers> is there a way to generate a vim tags file with a Haskell one?
13:40:03 <quchen> carter: It's just an idea right now that I think could be useful; I don't actually need it right now.
13:40:08 <carter> ok
13:40:10 <carter> well
13:40:11 <quchen> Or better, that I feel could be useful.
13:40:27 <carter> stm isn't want you want though for that
13:40:36 <quchen> And I don't see why it should not exist, as the channel size is readily available in the data type
13:40:45 <carter> quchen: http://hackage.haskell.org/package/chaselev-deque
13:40:46 <carter> is what you want
13:41:15 <carter> quchen: edwardk has a deque thats a bit cleaner in a branch of structures
13:41:36 <quchen> carter: Maybe I should start with how I came up with this whole thing. I basically ran into trouble with a queue filling up unnoticed, and then retrying indefinitely.
13:41:52 <carter> quchen: then just use q TBQueue
13:41:55 <quchen> This lead me to thinking "TBQueues are more opaque than they should be".
13:41:59 <carter> well
13:42:01 <edwardk> https://github.com/ekmett/structures/blob/deque/src/Control/Concurrent/Deque.hs
13:42:04 <quchen> It was a TBQueue, that's why it retried indefinitely :-P
13:42:07 <carter> why was it filling up unnoticed?
13:42:16 <carter> you werent consuming were you?
13:42:20 <quchen> Right.
13:42:35 <carter> bounded queues are safer than unbounded
13:42:43 <carter> why weren't you consuming it?
13:43:01 <carter> if you want something with nice properties thats not STM, that deque edward linked to is nice
13:43:12 <quchen> Forgot launching the thread. It's an awkward little thread that is always launched. Except when it's not.
13:43:36 <quchen> Anyway, if I had had access to current channel sizes, investigating the error would have been much easier.
13:43:51 <carter> quchen: you could also just wrap the STM actions with some logging
13:44:08 <edwardk> the deque above has the ability to query for conservative bounds on its size
13:44:25 <edwardk> https://github.com/ekmett/structures/blob/deque/src/Control/Concurrent/Deque.hs#L151
13:44:33 <edwardk> that gives a range into which the actual size must fall
13:44:50 <quchen> That log pumps out a lot of data in my case. I read that log for a week before finding out what caused the misbehaviour.
13:45:18 <quchen> There are workarounds for what I want, sure, but as part of the API it would be much easier to use.
13:45:18 <carter> to the log analysiss tools cave!
13:45:45 <carter> edwardk: how much work would it be to split that deque out?
13:45:55 <edwardk> but yeah, if you never dequeue then nothing will save you =)
13:46:01 <carter> yeah
13:46:05 <carter> you'll just run out of memory
13:46:06 <edwardk> carter: its just that module plus the Data.Vector.Array code in structures
13:46:22 <edwardk> i'm likely going to split D.V.A into a separate package once it stabilizes more
13:46:25 <quchen> carter: If you want specifics, I'm running a network that requires around 10 nodes to coexist before it works. The bug appeared during the bootstrapping of said network. Logging one client is not enough to see the bug; logging all of them is a mess, and logging some is an awkward mess.
13:46:29 <edwardk> but i'm not advocating doing it just yet
13:46:38 <carter> ok
13:46:40 <carter> makes sense
13:46:58 <carter> quchen: i was planning on writing a client for riemann.io
13:47:04 <carter> its kinda exactly what you want
13:47:21 <edwardk> i want to get a high performance variant of vector extended with an overmars/van leeuwen scheme so i can grow it with the right asymptotics. O(log n) cons, but still (mostly) contiguous reads.
13:47:33 <quchen> carter: I haven't heard of it
13:47:39 <carter> its nice
13:47:44 <edwardk> i need that for my vectors-of-sums trick
13:47:48 <carter> yeah
13:47:56 <edwardk> and i need it for all my wavelet tree work, etc.
13:47:58 <carter> quchen: you want a events messaging thing
13:47:59 <carter> yeah
13:48:03 <edwardk> so i've got a lot of incentive to get it right
13:48:06 <carter> jah
13:48:07 <carter> yay!
13:48:43 <nicoo> edwardk: What « vectors-of-sums trick
13:48:55 <quchen> carter: Right. Well what *I* want is writing this thing myself and researching the emergent structure of the network.
13:49:00 <edwardk> sadly my efforts at using Overmars and Van Leeuwen to optimize a Map have met with disappointing constant figures so far. its at ~3-5x slowdown right now
13:49:02 <nicoo> » and what are you doing with wevelet trees ? Sounds interesting
13:49:21 <edwardk> nicoo: are you familiar with the work on wavelet trees for string search?
13:49:22 <carter> edwardk: i'd just be happy with the autounboxing boring one :)
13:49:31 <nicoo> edwardk: Only in passing
13:49:37 <quchen> carter: And then bombarding it with nonsense and malicious data, and see how robust (or nasty) it can be.
13:49:45 <edwardk> nicoo: basically i just ned the underlying notion of a succinct indexed dictionary
13:49:49 <edwardk> @google succinct indexed dictionary
13:49:50 <lambdabot> http://en.wikipedia.org/wiki/Succinct_data_structure
13:49:51 <lambdabot> Title: Succinct data structure - Wikipedia, the free encyclopedia
13:49:55 <carter> well
13:49:57 <carter> look at riemann
13:49:59 <carter> may give you ideas
13:50:05 <quchen> Sure, I'm on it. Thanks
13:50:48 <edwardk> now, let's say you want to store a vector-like structure for a sum-type. W.LO.G. let's use Either a b for a and b that we know how to store already
13:51:12 <edwardk> we can use a bitvector for the decision, which we've extended with a rank structure in the succinct dictionary sense.
13:51:19 <nicoo> Yup
13:51:32 <quchen> carter: I imagine looking at how Bitcoin/Bittorrent are implemented might also help. At least network-wise.
13:51:34 <edwardk> that tells us which side of the either each element is on, and lets us ask how many Left's or how many Right's there are up to that position
13:51:56 <carter> umm, bounded queues are your friend
13:51:58 <edwardk> so we can use two vectors one vector of 'a's and one vector of 'b's such that thos two vectors have lengths that sum to the total length of our vector
13:52:11 <stelleg> @src tail
13:52:12 <lambdabot> tail (_:xs) = xs
13:52:12 <lambdabot> tail []     = undefined
13:52:18 <nicoo> edwardk: I see
13:52:46 <edwardk> and we can query it by asking the value of the bitvector at the position in question, to know if we want Left or Right, then take the rank and either use it directly to index into the Left array or subtract it from i to index into the Right array
13:53:15 <edwardk> scans/traversals are more efficient of course
13:53:33 <edwardk> now, we can build up this 'tree of vectors' rather than 'vector of trees' lazily.
13:53:56 <quchen> stelleg: If you're wondering why "tail [] /= []", it's because the tail of a list is literally "the part after the first (:)", and [] has no (:) in it.
13:53:57 <edwardk> and we can compress out portions of the tree that are represented homogeneously. if everything is a 'left' just store that fact.
13:54:25 <edwardk> its effectively a 'transpose' for the storage of standard boxed data types
13:54:46 <edwardk> now you can store vectors of maybes, vectors of lists of things, etc. and for the most part you get to use contiguous storag
13:55:30 <edwardk> we can enhance this for special cases where you know you're going to store things in lexicographically increasing order and lean on elias-fano encoding, etc.
13:55:34 <intrados> Is it possible to define a function in a class definition that's only available during instance declarations? Something like: http://lpaste.net/95353
13:55:37 <nicoo> ^^ (and you want continuous storage for cache-friendlyness, right ?)
13:55:39 <stelleg> quchen: yeah I know :). I was just checking what the source is exactly. I generally use (drop 1) almost everywhere instead.
13:55:41 <edwardk> yep
13:56:01 <edwardk> a lot of my recent work has been on improving cache locality in haskell, modeling cache oblivious data structures that are still pure
13:56:07 * stelleg is a big fan of total functions
13:56:20 <quchen> stelleg: Good boy! :-)
13:56:27 <nicoo> edwardk: Sounds fun
13:56:52 <edwardk> nicoo: https://www.fpcomplete.com/user/edwardk/oblivious/deamortized-st may interest you if you haven't seen it yet
13:56:56 <nicoo> My list of opened tabs grows startingly each time I talk to you, though
13:57:25 <edwardk> nothing that rebooting or accidentally shutting down your browser won't fix. ;)
13:57:36 <carter> a lot of my work has been in the same space, but less productively than edward's
13:57:39 <carter> :)
13:58:01 <geekosaur> what, exploding browsers? }:>
13:58:09 <nicoo> edwardk: Didn't read it yet, no :) (And my browser *has* persistent sessions)
13:58:55 <edwardk> nicoo: i'll be posting a follow up to it showing that you can adapt the overmars and van leeuwen dynamization technique to work in haskell via that deamortization trick
13:59:12 <nicoo> carter: edwardk is probably some kind of cyborg, with direct coffeine injection in the brain, tuned for coding performance ;)
13:59:20 <nicoo> edwardk: Looking forward to it :D
13:59:27 <edwardk> https://github.com/ekmett/structures/blob/master/src/Data/Vector/Set.hs shows it in action
13:59:40 <schell> are there other syntax checkers that work with vim besides ghc-mod and hlint?
13:59:44 <edwardk> its not yet fast but it does get the right asymptotics
14:01:58 <jrmithdobbs> is using Show for random string conversion "accepted" ? eg, not for producing re-interpolatable haskell-code strings but for eq, turning an enum of "operators" into their ascii representation, or should that be done with something like opToStr ?
14:02:08 <jrmithdobbs> (purely a style question, i know both ways "work")
14:02:28 <edwardk> jrmithdobbs: you'll find that as you get further along in your haskell programming you'll tend more and more to make that be a function like 'opToStr'
14:02:45 <jrmithdobbs> edwardk: that's kind of what I'm seeing and why I was asking
14:02:56 <jrmithdobbs> edwardk: I have this inclination to treat Show like #to_s in ruby ;p
14:03:07 <edwardk> jrmithdobbs: otherwise it makes it harder to debug data types that happen to contain such an op.
14:03:20 <jrmithdobbs> yes, that's exactly what I ran into that started me asking :)
14:03:38 <edwardk> yeah. think of it __repr__ not __str__ from the python world
14:03:47 <edwardk> er as
14:03:51 <lpaste> Kuznero annotated “getBrowserPath” with “getBrowserPath (annotation)” at http://lpaste.net/95354#a95356
14:04:01 <jrmithdobbs> #str vs #to_s is the ruby equiv iirc
14:04:10 <edwardk> yeah
14:04:20 <skypers> night :)
14:04:38 <carter> kuznero: so please explain what you're trying to do / understand
14:05:17 <kuznero> I'm trying to figure out what affects appearance of this problem called `permission denied` when calling openInBrowser
14:05:53 <kuznero> I thoughts that Win32 package with its regQueryValue, etc. is doing something wrong. But now it does not really look like that...
14:06:14 <carter> so you're trying to debug win32 on windows? what versoin of windows and ghc etc?
14:06:47 <kuznero> Yep, I have GHC 7.6.3, HP 2013.2.0.0, Windows 8.1 (but was also tested on XP)
14:07:25 <IceDanelol> using the list monad to do backtracking, how would I go about preventing duplicate results? E.g. [1,1,5] == [1,5,1]
14:08:06 <simpson> IceDanelol: IIUC you'll want to explicitly filter the list occasionally to remove duplicates, and you'll want to do it at times that you think are appropriate.
14:09:13 <identity> simpson: Hmm. I already thought about filtering the results myself, but I was hoping for some smarter solution
14:09:28 <identity> but I guess that may depend on the specific situation
14:09:45 <simpson> identity: So, the problem is that you need an Eq or Ord constraint in there to do it on every bind.
14:10:00 <simpson> Which would break Monad's method signatures.
14:10:15 <identity> ah.
14:12:05 <kuznero> And to sum up the problem is that no matter which line is commented out the value it returns is exactly the same. But result (side effect) is different - one with permission denied, another one doing everything ok.
14:13:12 <carter> so for those of us who don't know windows crazies
14:13:16 <carter> whats this supposed to do
14:13:18 <carter> vs what it does
14:14:02 <kuznero> it suppose to fetch the path to the default browser on windows from registry and create proces to open it with passed argument like "www.google.com" or something
14:14:15 <jrmithdobbs> ok, so having established that using Show for arbitrary string conversion is bad, is there a class somewhere in Data.Text or similar that might be better suited? (assuming I want to take encoding into account anyhow, which I do)
14:14:29 <kuznero> in *buntu systems it's much easier with sensible-browser...
14:14:34 <carter> ok
14:14:35 <carter> buttt?
14:14:48 <alkabetz> Ahem.  I think you mean “In Debian and its derivatives …” :)
14:15:02 <kuznero> alkabetz: true
14:15:44 <kuznero> carter: that's it... problem is that when string value is really fetched from registry it gives me permission denied when trying to System.Process.createProcess with its path
14:16:11 <kuznero> But if I fetch the value from registry but use a hardcode instead, createProcess works absolutely fine
14:16:12 <carter> is there a way to check for permissions?
14:16:40 <carter> so check that the strings are equal / print them
14:16:43 <carter> to see whats different
14:16:47 <kuznero> Yes, there is a way to get it running in elevated mode with all permissions necessary. That does not help. More than that it seems to be irrelevant in this case.
14:16:58 <carter> ok
14:16:58 <carter> well
14:17:00 <kuznero> Yes, checked. Strings are identical
14:17:06 <carter> are you sure
14:17:15 <carter> encoding wise and everything?
14:17:30 <carter> is this with the program compiled or run with ghci?
14:17:37 <kuznero> Hm! yes, I'd say. I checked value and type String/String
14:17:53 <carter> were you running this with ghci?
14:17:54 <kuznero> It's with compiled version `ghc --make`
14:18:01 <kuznero> yes, same problem
14:18:17 <carter> ok
14:18:24 <carter> huh
14:18:53 <carter> i can't help
14:18:57 <carter> but this sounds thorny
14:19:04 <carter> email cafe for help/ ideas?
14:19:15 <carter> and if that doesn't work, escalate to stack overflow and reddit?
14:19:16 <kuznero> good idea... will post it there
14:19:26 <kuznero> make sense, tnx
14:19:48 <carter> don't forget to explain so people don't need to ask to understand the problem
14:20:28 <kuznero> I'll try to sum it up with what I explained here.
14:30:29 <slack1256> On the yi editor page in hackage, I can't load the documentation
14:30:54 <slack1256> Will it generate them again soon? or should I contact somebody?
14:33:05 <kuznero> carter: Now, I'm going to hide in the basement... Problem was with extra quotes not being removed from the value fetched from the registry...
14:33:11 <kuznero> Sorry for terrorizing you all :)
14:33:23 <carter> you learned!
14:33:26 <carter> share your learning
14:33:26 <carter> :)
14:33:27 <intrados> Is there a way of scoping another type variable (not the b in class A b where) over the whole body of a class definition?
14:33:29 <kuznero> you bet :)
14:33:30 <carter> explain what you mean
14:33:45 <carter> showing a string adds a quotes
14:33:46 <carter> ?
14:34:08 <kuznero> When hardcoded value looked like this: C:\\Program Files (x86)\\Maxthon\\Bin\\Maxthon.exe
14:34:19 <kuznero> When fetched from registry it looked like this: "C:\\Program Files (x86)\\Maxthon\\Bin\\Maxthon.exe"
14:34:31 <kuznero> Thus, it was not in correct format :)
14:35:10 <kuznero> So, what I did is I just removed trailing quotes when fetched from registry if its at all present and it started working
14:35:19 <carter> huh
14:35:20 <carter> well
14:35:21 <kuznero> So, in the end nothing was wrong with System.Win32
14:35:24 <carter> now you know
14:35:24 <carter> well
14:35:28 <carter> thres othere things wrong
14:35:30 <carter> just not that :)
14:35:39 <kuznero> true, that's true
14:35:42 <briennetheblue> did there used to be a takeUntil in Prelude?
14:35:58 <kuznero> reverse $ dropWhile
14:36:22 <kuznero> double reverse
14:38:27 <Fuuzetsu> slack1256: It's the case with quite a few pages, asking around didn't help me either. I recommend you enable documentation in your cabal settings then cabal install yi and then just read the docs locally
14:38:51 <Fuuzetsu> ~/.cabal/share/doc/index.html is where you probably want to start IIRC
14:40:21 <supki> > break (> 5) [1..10]
14:40:22 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
14:40:24 <supki> briennetheblue: ^
14:41:13 <Fuuzetsu> :t takeWhile
14:41:14 <lambdabot> (a -> Bool) -> [a] -> [a]
14:41:42 <m1dnight> Can I ask a quick question? :)
14:41:52 <Fuuzetsu> Just ask.
14:41:54 <m1dnight> fact :: Integer -> Integer
14:41:54 <m1dnight> fact 0 = 1
14:41:55 <m1dnight> fact x = x * fact $ x - 1
14:42:10 <m1dnight> that doesn't work. It only works if I put parentheses around the X-1 and remove the $
14:42:25 <m1dnight> shouldn't the x -1 be evaluated, put into the fact, and then multiplied by X?
14:42:26 <kuznero> it should work with guards
14:42:30 <m1dnight> what am I missing here?
14:42:40 <geekosaur> m1dnight, you miss that $ is very low precedence
14:42:42 <joelteon> m1dnight: the last line is equivalent to fact x = (x * fact) (x - 1)
14:42:43 <triliyn> m1dnight: that's the same as (x * fact) $ (x - 1)
14:43:03 <joelteon> x * fact does not take any arguments
14:43:29 <monochrom> this is why $ is not "do what I mean". you must understand $, not cargo-cult it.
14:43:55 <fizbin> m1dnight: It's common to initially get used to $ meaning "put parentheses around everything to the right". That's not quite what it means.
14:44:07 <m1dnight> yeh, that's kinda what I used it for
14:44:09 <monochrom> or, you don't have to understand it, if you don't use it altogether
14:44:10 <m1dnight> to remove the parentheses
14:44:22 * Fuuzetsu just thinks of it as parenthesising everything from where $ starts to the end of the expression
14:44:33 <monochrom> you will never be able to remove all parentheses. accept this fate.
14:44:34 <m1dnight> exactly! :)
14:44:57 <fizbin> Fuuzetsu: That's the same mistake m1dnight made.
14:45:16 <Fuuzetsu> fizbin: no, in his case it'd be wrong anyway
14:45:17 <monochrom> $ is the root of all evil
14:45:29 <Fuuzetsu> it'd be x * fact (x - 1)
14:45:36 <Fuuzetsu> wait, actually this works because precedence
14:45:41 * Fuuzetsu shrugs
14:45:44 <m1dnight> yeah, Fuuzetsu that is the correct way
14:45:47 <fizbin> Yeah, that's what he wants.
14:45:49 <Fuuzetsu> I know how to us it so I don't worry ;P
14:46:13 <monochrom> yes, if you know what is $, you can use it.
14:46:18 <fizbin> monochrom: As with money, it's not $ that's the issue, it's excessive love of $.
14:46:27 <monochrom> but Dunning-Kruger kicks it. everyone thinks he/she knows it.
14:46:32 <intrados> How can I fix this class definition type variable problem? http://lpaste.net/95357
14:46:53 <monochrom> fizbin: actually, http://www.vex.net/~trebla/humour/tautologies.html #1
14:47:01 <glguy> monochrom (whatsA . littleOperator $ abuse betweenFriends)
14:50:01 <Fuuzetsu> intrados: I don't think you can go from ‘a’ to any ‘b’. How does it know what b is?
14:50:18 <fizbin> intrados: Do you actually mean the type you wrote for 'internal' there? It looks like you're saying that for something to be Sortable, it has to have a conversion to *anything* with an Ord instance.
14:51:07 <donri> monochrom: sure you can avoid parentheses. just throw lots of let bindings at everything!
14:51:32 <monochrom> yes, I will upload a program that does that to hackage, come April 1
14:51:40 <donri> nice!
14:52:11 <monochrom> we love to trash the contribution of fortran and go back to 1950, don't we?
14:52:13 <intrados> fizbin: Oh. It's universal rather than existential?
14:52:15 <glguy> intrados: Presumably you have a particular 'b' in mind for each 'a'. Either use functional dependencies: "class Sortable a b | a -> b" or an associated type family, or parameterize Sortable by a comparison function instead of a conversion function
14:52:32 <monochrom> intrados, it is always universal
14:52:42 <fizbin> intrados: yes.
14:52:59 <intrados> Yeah. It makes sense now that you've said it
14:53:12 <moops> Fuuzetsu just thinks of it as parenthesising everything from where $ starts to the end of the expression << if thats not what $ is then what is it? o_O
14:53:44 <Fuuzetsu> moops: it's that but with very weak precedence
14:53:53 <Fuuzetsu> so it doesn't work that well in presence of other operators
14:54:12 <moops> with the same fixity?
14:54:15 <jrmithdobbs> ya, surprisingly weak in some cases
14:54:30 <Fuuzetsu> because you'll apply those first and only then the parenthesising happens if you will, but at that point you probably already have a type error
14:54:30 <jrmithdobbs> s/surprisingly/counter-intuitively/
14:56:01 <monochrom> moops: the counter-example is "x * fact $ x - 1" = "(x * fact) (x - 1)"
14:56:28 <Fuuzetsu> I often consider defining $ but with a stronger fixity for use in things like parser combinators
14:56:36 <moops> x * fact $ x - 1 === x * fact (x - 1) though, right?
14:56:38 * monochrom is very happy if it means that your whole mental model collapses
14:56:47 <monochrom> N. O.
14:56:58 <Fuuzetsu> inability to do ‘foo <|> bar $ baz qux <|> quux’ annoys me
14:57:02 * monochrom is very happy if it means that your whole mental model collapses
14:57:07 <moops> haha
14:57:29 <monochrom> people live in such reality distortion fields
14:57:29 <moops> it may have
14:58:03 <Fuuzetsu> moops: no, the ‘*’ happens before ‘$’. So it's actually (x * fact) $ x - 1 ≡ (x * fact) (x - 1)
14:58:29 <khyperia> $ is a normal binary operator like any other operator
14:59:19 <moops> i just tried it
14:59:22 <moops> now i understand
14:59:24 <moops> thanks
14:59:35 * hackagebot BlogLiterately 0.7.0.1 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.0.1 (BrentYorgey)
14:59:46 <monochrom> $ has precedence level 0, * has 7, - has 6. why is it so hard to work out?
14:59:59 <Fuuzetsu> byorgey: Yet another blogging format?
15:00:00 <tromp_> > ($) 5
15:00:02 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
15:00:02 <lambdabot>    arising from a use ...
15:00:23 <byorgey> Fuuzetsu: It's not a format.
15:00:33 <tromp_> > let ($) = id in ($) 5
15:00:34 * Fuuzetsu clicks
15:00:35 <lambdabot>   5
15:00:51 <khyperia> Where's that one "instance Num ((->) a)" defined?
15:00:59 <halvrg> http://lpaste.net/95358 Does anyone understand this cabal install error?
15:01:01 <Fuuzetsu> Oh. Advantages over hakyll for blogging?
15:01:08 <tromp_> > let ($) = id in succ $ 5
15:01:10 <lambdabot>   6
15:01:23 <geekosaur> ancient program :/
15:01:37 <geekosaur> halvrg: you will probably have to do some porting
15:01:41 <halvrg> its an error in the library?
15:01:46 <khyperia> or, wait, is it "instance Num (a -> b)"
15:01:49 <Fuuzetsu> halvrg: yeah
15:01:50 <geekosaur> not an error, just out of date
15:01:53 <halvrg> bah, ok thanks
15:01:59 <Fuuzetsu> Yes. Contact maintainer.
15:02:02 <khyperia> whatever it is, it's awesome and highly pointless.
15:02:05 <halvrg> any good alternatives to load a png?
15:02:08 <geekosaur> it used to be popular to use both base and haskell98 at the same time. they are no longer compatible
15:02:11 <Fuuzetsu> You could probably get around by hiding the h98 package
15:02:16 <byorgey> Fuuzetsu: with hakyll you would have to construct your own blog from scratch, with all the pros and cons that brings (more flexibility, more effort)
15:02:42 <byorgey> Fuuzetsu: BlogLiterately gives you a reasonable way to write nicely typeset, featureful posts on standard blogging platforms
15:02:55 <geekosaur> because some basic things have different types now. but if you remove the haskell98 package from the cabal file, you'll probably have to follow up by chnaging some module imports
15:02:59 <Hari`> hi monochrom, i talked to you yesterday. thanks for that tip about using the evaluate function .. it considerably improved the situation
15:03:07 <Fuuzetsu> byorgey: Well, they give you the basic template. Where can I see some pages produced with your package?
15:03:17 <geekosaur> (like Char became Data.Char, and System was broken up into a bunch of modules)
15:03:37 <halvrg> yeah I understand thanks, I'll look for another library
15:04:53 <byorgey> Fuuzetsu: pretty much every post on http://mathlesstraveled.com/ or http://byorgey.wordpress.com/ from the last year or so was written using BlogLiterately
15:05:27 <byorgey> on the former I often use BlogLiterately-diagrams which is a plugin for incorporating diagrams into posts
15:05:46 <byorgey> I just write a single markdown file with embedded Haskell code describing the pictures and it does the rest.
15:09:59 <tromp_> does anyone have access to a machine with 32+GB of mem running Haskell?
15:11:07 <monochrom> I will have an old 486 with 16MB of mem :)
15:11:12 <carter> tromp_: whats the goal?
15:11:16 <carter> such people exist
15:11:20 <carter> but whats your goal
15:11:47 * monochrom guesses a goal: "test jhc with GC turned off" :)
15:11:49 <tromp_> goal is trying to solve bonus of Ponder This problem with this prog http://lpaste.net/95359
15:12:24 <tromp_> my laptop lands in swap hell looking for solution
15:12:35 <carter> tromp_: try a beter algorithm
15:12:39 <carter> or rent time on EC2
15:12:43 <monochrom> that may be an inefficient pascal triangle, i.e., takes too much memory because [] does
15:12:59 <tromp_> pascal is not the problem
15:13:10 <tromp_> the list of counts is
15:13:29 <monochrom> that is even more [] :)
15:14:06 <tromp_> anyway, the bonus may not have a solution at all
15:14:17 <monochrom> I wonder if it helps you know an observation by Oleg
15:14:55 <tromp_> what obs?
15:16:25 <Fuuzetsu> byorgey: Cool, I might consider it.
15:18:17 <monochrom> tromp_: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/103616/
15:18:56 <monochrom> sometimes you can try -fno-full-laziness to use less memory and more time
15:23:08 <tromp_> i thought the sort required to hold on to most of the counts list anyway
15:23:51 <tromp_> but i'll try make counts local to main when i get home
15:39:54 <frxx> from ML's wikipedia page: "Additionally, the use of this algorithm [Hindley Milner type inference algorithm] ensures type safety -- there is a formal proof that a well-typed ML program does not cause runtime type errors"
15:39:58 <frxx> does the same apply to haskell?
15:40:15 <monochrom> yes
15:42:16 <quchen> frxx: A diverging program is not an error though, so HM isn't a way around the Halting problem
15:42:50 <quchen> Also note that calling "error" is well-typed, but produces errors using black magic.
15:43:23 <quchen> Oh, I overlooked the "type" in "runtime type errors". Woops
15:43:31 <monochrom> it is conceptually clearer and more common to split Hindley-Milner into two parts: 1. type inference, which fills in omitted types; 2. typing rules, which assumes you have filled in all types, and checks that you have filled in right.
15:43:54 <monochrom> it is the typing rules that ensures no runtime type errors
15:44:46 <monochrom> and the type inference algorithm is written to fill in correct types
15:45:09 <frxx> why did they use "well-typed" adjective? if the program is not well-typed it won't compile, no?
15:45:31 <Hodapp> I'd read a handful of papers that took the view that unbounded recursion - or partial functions - should properly be considered side-effects.
15:45:58 <monochrom> because they are talking about types, not compiling
15:47:20 <moops> side effects?
15:47:22 <moops> or unsafe
15:47:44 <jrmithdobbs> can you pattern match using record syntax or are you relegated to stuff like myFunc x@MyType = accessFunc x ++ something ?
15:47:58 <moops> Hodapp: id love a link if you have one handy
15:48:00 <Hodapp> moops: I forget specifically the term they used. Perhaps it was just that they shouldn't properly be considered pure functions if they can halt your poor Turing machine.
15:48:01 <Tekmo> jrmithdobbs: I think so
15:48:13 <Hodapp> moops: I shall dig and see if I can find it.
15:48:20 <jrmithdobbs> Tekmo: to the latter or former? ;p
15:48:35 <monochrom> "compile" includes lexing and parsing and syntax checking and type inference and type checking and semantic analysis and optimization and memory layout design and register allocation and code generation... must you talk about all of them when you just need to talk about types?
15:48:36 <Tekmo> jrmithdobbs: I think you can pattern match using record syntax
15:48:44 <jrmithdobbs> Tekmo: if I know the order of the named records i know i Can still do (MyType x y z) but if order changes ...
15:48:53 <jrmithdobbs> Tekmo: how?
15:49:00 <Tekmo> jrmithdobbs: One second while I test this.  Hold on
15:49:11 <jrmithdobbs> ya i've played with a few things i thought might work
15:50:26 <Tekmo> jrmithdobbs: Yeah, this works.  Here's an example paste showing this in action: http://lpaste.net/95363
15:50:48 <jrmithdobbs> i was trying to be too tricky!
15:50:53 <Tekmo> :)
15:51:14 <Tekmo> It also works if you switch the order of the fields in the pattern match
15:51:21 <jrmithdobbs> I was looking at variations on MyFunc (MyType{x = accFunc1 id; y = accFunc2 id;}) ... ;p
15:51:32 <Tekmo> :)
15:51:37 <Tekmo> Yeah, you were too smart for your own good
15:51:38 <jrmithdobbs> but that didn't make sense, was hoping id would do some magic for me ;p
15:51:39 <jrmithdobbs> heh
15:51:39 <DanielDiaz> Tekmo: does it work if you miss record fields?
15:51:46 <Tekmo> DanielDiaz: Let me test
15:52:01 <Tekmo> Yes
15:52:17 <jrmithdobbs> that is handy.
15:52:21 <DanielDiaz> nice! that is an interesting use
15:52:31 <Tekmo> Yeah, I didn't even know that worked myself
15:52:57 <Tekmo> I usually pattern match without using record labels (i.e. test (MyType x y z) = ...)
15:53:15 <Tekmo> So I never knew that worked
15:53:19 <monochrom> in Test{first=x, second=y}, "Test" is not the type name, it is the data constructor name
15:53:36 <DanielDiaz> I usually write: foo x = foo1 x, foo2 x, etc
15:53:52 <DanielDiaz> I mean, I call the record functions without pattern matching
15:54:01 <monochrom> if you have instead "data X = Y{first::Int, second::String}", you will notice the difference
15:54:59 <DanielDiaz> the reason is because if I change something in the type, I don't need to change my code
15:55:09 <DanielDiaz> if I have added new fields, for example
15:55:14 <jrmithdobbs> DanielDiaz: same, but things like this with partials is useful: myFunc x@(MyType{impConst1 = y}) = delete x y
15:56:11 <DanielDiaz> jrmilthdobbs: I agree, of course.
15:58:41 <jrmithdobbs> Tekmo: when are those ()s necessary? or are they not
15:58:50 <Tekmo> jrmithdobbs: What do you mean?
15:58:58 <shiona_> can I use diagrams to render in some internal format that can be either shown in a window or sent over the net as a part of a website?
15:59:24 <jrmithdobbs> Tekmo: myFunc (MyDataCon{ .. }) = ... compiles the same as myFunc MyDataCon{ .. } = ..
15:59:37 <jrmithdobbs> i think the ()s are redundant there is what I was saying
15:59:48 <Tekmo> jrmithdobbs: You're right.  They are redundant
16:00:02 <jrmithdobbs> was wondering if there was a case where they aren't? multiple params maybe?
16:00:46 <monochrom> @let monof Just{} = 0; monof Nothing{} = 1
16:00:49 <lambdabot>  Defined.
16:00:56 <monochrom> > monof (Just 4)
16:01:00 <lambdabot>   0
16:01:16 <Tekmo> shiona_: I think the answer is yes.
16:01:56 <Tekmo> shiona_: I was browsing through the `diagrams-core` source code and it seems like you need to have whatever internal format implement the `Backend` type class, which you can find here: http://hackage.haskell.org/package/diagrams-core-0.7.0.1/docs/Diagrams-Core.html#t:Backend
16:02:14 <shiona_> I was just going through the backends
16:03:02 <Tekmo> Argh, `diagrams-core` is such a type-class mess
16:03:13 <shiona_> :D
16:04:13 <shiona_> renderSVG could be nice if I could just pull out the bytestring without the api forcing me to write it into a file
16:05:35 <shiona_> ah, there are diagrams-gtk and other libraries that do the lifting for actually drawing stuff
16:05:54 <hpc> Tekmo: it's the classiest
16:05:54 <haasn> shiona_: diagrams-svg renders to Text.Blaze.Svg11.Svg
16:06:00 <jrmithdobbs> Tekmo: contrived function but that syntax works out well for splitting across lines and staying readable even!:
16:06:03 <jrmithdobbs> Tekmo: http://lpaste.net/95363
16:06:03 <Tekmo> hpc: :)
16:06:08 <jrmithdobbs> i like that a lot
16:06:30 <Tekmo> jrmithdobbs: Yeah, I like that a lot, too!
16:06:37 <shiona_> haasn: thanks, might look into that
16:07:10 <jrmithdobbs> i never thought I'd say this, but the way the haskell spec/parser uses spaces/idention is like the opposite of python in every way
16:07:17 <haasn> shiona_: you can render it out to a ByteString or whatever with Text.Blaze.Renderer.Utf8
16:07:21 <jrmithdobbs> the most important way being that it usually makes me happy instead of making me want to break things ;p
16:07:30 <shiona_> I had an idea of drawing some random things, but also an idea about writing a web app. then I thought i might combine them
16:07:45 <hpc> jrmithdobbs: making people happy is a natural consequence of doing things the opposite of python ;)
16:07:46 <Tekmo> jrmithdobbs: Ha :)
16:07:47 <Peaker> jrmithdobbs: weird, I think Python's whitespace is simple&predictable, and Haskell's is complex and a bit weird :)
16:08:06 <rasfar> i like it too, but the asymmtery of the one missing comma (while nicely concealed) always bugs me
16:08:07 <jrmithdobbs> Peaker: then you've never used the worthless things they pretend are lambdas
16:08:11 <jrmithdobbs> Peaker: ;p
16:08:26 <Peaker> jrmithdobbs: well, Python having crippled lambdas isn't a hidden secret
16:08:35 <rasfar> aside from module exports, i don't know where else an extra comma is tolerated
16:08:35 <hpc> Peaker: just a frustrating one
16:09:03 <jrmithdobbs> Peaker: it's frustrating especially with the whitespace stuff tho because single line lambda + hard/ugly to define multiple of them in same place == ugly
16:09:03 <Peaker> Haskell's indent rules make every line indented some arbitrary amount, whereas in Python it's just some multiple of 4 (alignments aren't indents)
16:09:22 <hpc> haskell's indent rules make every line indented exactly as far as you intent it
16:09:28 <Peaker> jrmithdobbs: I don't like Python's crippled lambdas, you're supposed to use "def" everywhere (which sucks, but solves this issue)
16:09:29 <jrmithdobbs> ^
16:09:32 <hpc> *indent
16:09:47 <hpc> the problem isn't from increasing indentation anyway
16:09:51 <hpc> it's from decreasing it
16:09:59 <hpc> you're in the middle of some deep python code
16:10:06 <jrmithdobbs> Peaker: i like that it takes your indented spot and makes that the marker instead of an arbitrary modulo op on the number of spaces
16:10:07 <hpc> you're indented 16 spaces
16:10:08 <hpc> 4 deep
16:10:16 <jrmithdobbs> Peaker: it leads to pretty things like that annotation i had jsut pasted ;p
16:10:22 <shiona_> there seems to be at least 2 html5 backends
16:10:23 <hpc> one of those is the class, another is the function def, a loop and an if
16:10:24 <jrmithdobbs> Peaker: http://lpaste.net/95363
16:10:27 <hpc> now the indentation decreases
16:10:41 <hpc> and you have to eyeball how far it decreased without having } to help
16:11:04 <haasn> (or use an editor that displays a soft line after every 4th space)
16:11:09 <Peaker> jrmithdobbs: if you're willing to place the = on the same line as }, then Python works that way too (with tuple unpacking)
16:11:25 <jrmithdobbs> Peaker: i'm not because placing the = there makes it hard to add params later
16:11:31 <hpc> haskell does not generally decrease indentation except to decrease it entirely to zero
16:11:47 <jrmithdobbs> Peaker: you'll notice the rest is written in such a way that requires hitting 'o' and starting to type in vim anywhere there's a list like that too
16:11:50 <jrmithdobbs> and i *love* that
16:11:51 <Peaker> jrmithdobbs: actually Python requires () around the param list anyway, so you can indent any way you want in between
16:12:34 <hpc> lisp doesn't have that problem despite the stylistic choice to lump all the closing parens as ))))))))))))
16:12:47 <jrmithdobbs> hpc: until you articulated it exactly that way I hadn't realized it, but that is in fact *exactly* my problem with python's whitespacing rules, it's how it handles escaping out of the current "block"/indention level
16:12:50 <hpc> because it has an entire IDE made just for it, trying very hard to make ((()))()(()()))))) readable
16:13:07 <hpc> so basically what i am saying is, python needs a very poorly written IDE to make it better
16:13:07 <jrmithdobbs> hpc: haskell solution to this is (as I'm finding is oft the case) just ever so slightly more elegant
16:13:12 <hpc> like emacs or eclipse
16:13:14 * hpc ducks
16:13:33 <Tekmo> I really love Haskell's function application syntax
16:13:42 <Tekmo> I don't know why other people rag on it so much
16:13:51 <jrmithdobbs> meaning?
16:13:57 <hpc> Tekmo: BECAUSE HOW DO YOU PARSE IT?!?!
16:14:04 <jrmithdobbs> with a parser
16:14:27 <haasn> with a PDA
16:14:46 <jrmithdobbs> if i can parse URIs including uri and charset encoding using sh, you damned well can parse haskell with your compiler ;p
16:14:58 <hpc> jrmithdobbs: but can you parse sh?
16:15:03 <hpc> ;)
16:15:03 <joelteon> nobody can parse sh
16:15:10 <hpc> perl can parse sh
16:15:15 <jrmithdobbs> i can parse sh in sh
16:15:17 <hpc> and perl can parse perl
16:15:18 <jrmithdobbs> and have
16:15:26 <hpc> perl can parse all languages that can't parse themselves
16:15:26 <jrmithdobbs> ok wait, that's a lie
16:15:31 <jrmithdobbs> i can parse sh in BASH
16:15:32 <jrmithdobbs> :(
16:15:36 <haasn> but can you parse PCRE in PCRE?
16:15:49 <joelteon> yeah
16:15:56 <hpc> PCRE is an embarassment
16:16:00 <Peaker> jrmithdobbs: I like most things about Haskell, but I think Haskell code indentation tends to be an arbitrary mess, whereas Python indentation tends to be an orderly 4-space indent with very clear hierarchy of code
16:16:03 <hpc> it is neither perl-compatible nor regular
16:16:14 <Tekmo> I agree with Peaker
16:16:25 <jrmithdobbs> Peaker: it's funny you keep saying that 4 space thing, because you know that's not the rule right?
16:16:28 <Tekmo> I prefer regular 4-space indentation.  It's easier to read because it is more predictable
16:16:32 <Peaker> In my Haskell code, to avoid the mess, I throw a newline whenever I must to make sure things are indented rather than aligned
16:16:40 <jrmithdobbs> Peaker: I mention this because by python would DRIVE YOU CRAZY with it's ts=2
16:16:44 <jrmithdobbs> s/by/my/
16:16:44 <Peaker> jrmithdobbs: It's the official rule :) (PEP8)
16:16:57 <hpc> haha
16:17:44 <hpc> Peaker: i am not sure how you can claim it's easier, when it is very hard to read decreasing indentation
16:17:55 <Peaker> hpc: decreasing indentation exists in both Haskell and Python
16:18:08 <Peaker> so I'm not sure what you mean
16:18:09 <hpc> decreasing indentation in haskell is "decrease to zero"
16:18:20 <jrmithdobbs> i like the freeform of haskell's indention vs the hard and fast python method because while you should probably keep the code indented like python 99.99% of the time, that .001% where it makes you have a 500 bajillion spaces up front for some semantics reason it's nice to say "ya, the convention is stupid for this case"
16:18:25 <jrmithdobbs> and be done with it
16:18:41 <Peaker> hpc: no, nested do blocks have decreasing indentation.  Or you can just decrease indentation to align with a nested guard or what not
16:18:58 <Peaker> jrmithdobbs: I hate free form, I like orderly :)
16:19:03 <hpc> Peaker: "ugly code has decreasing indentation"
16:19:29 <jrmithdobbs> hpc: "python creates ugly code"
16:19:35 <jrmithdobbs> hpc: i accept your proof by induction.
16:19:35 <Tekmo> I wish Haskell had something like `gofmt`
16:19:40 <hpc> and if we are going to go that route, let's just do {;} and be done with it
16:19:51 <jrmithdobbs> ;p
16:19:53 <hpc> because that's damn ugly, but i have an easier time reading that than python
16:19:57 <Peaker> Tekmo: stylish-haskell?
16:20:08 <Tekmo> I never knew about stylish-haskell.  Let me check it out
16:20:17 <Peaker> hpc: you could say that ugly Python code has many levels of decreasing indentation, and usually you factor out so there are only 1-3 levels like nice Haskell code
16:20:25 <hpc> yes
16:20:26 <haasn> doesn't stylish-haskell just format imports and stuff? (I don't know what gofmt does)
16:20:28 <hpc> because that's the case
16:20:46 <hpc> my example of four indentation levels in python was 100% reasonable and common
16:20:54 <hpc> class > def > loop > if
16:21:04 <Tekmo> Argh, so that's what produces those ugly imports
16:21:15 <hpc> or you know what, since python has such an exception boner
16:21:20 <Tekmo> I wish there was a way to put the `qualified` after the module name
16:21:22 <hpc> class > def > try > loop > if
16:21:25 <fizbin> haasn: gofmt is a total formatter. If two go programs present the same AST to the compiler, the gofmt of them is identical.
16:21:32 <donri> hpc: don't forget "with"
16:21:45 <simpson> hpc: There's no loop-statement in Python.
16:21:59 <hpc> simpson: i refer to the larger concept of loops
16:22:04 <hpc> while, for, foreach
16:22:17 <simpson> hpc: There's no foreach in Python either; are you thinking of PHP? >:3
16:22:23 <hpc> shuddup
16:22:35 <haasn> Tekmo: yes! import Module.X qualified as Foo -- makes a lot of sense
16:22:41 <hpc> anyhoo, python is writing these long imperative C functiony things
16:22:48 <simpson> IYSS.
16:22:53 <hpc> because your lord and savior guido has said it must be so
16:23:07 <Peaker> hpc: Haskell could use more BDFL'ism :)
16:23:09 <hpc> haskell is writing 3-liner functions that are truly composable
16:23:11 <simpson> Actually, I'm part of the Twisted clan; GvR is not really a friend to us.
16:23:19 <jrmithdobbs> hpc: don't forget the convoluted voodoo to actually do any usefull SMP work
16:23:27 <jrmithdobbs> *cpu bound SMP work
16:23:34 <donri> guise there's "import safe" now too
16:23:48 <Tekmo> Reminds me of a quote I read on Haskell Weekly News, that went something like: "Idiomatic Haskell is 8 lines of language extensions, 20 lines of imports, and one line of Perl"
16:23:52 <simpson> donri: And that only imports Safe Haskell-okay stuff?
16:23:55 <donri> import      qualified Mod    as M
16:24:07 <Peaker> simpson: Twisted is overcomplicating everything crazily. Deferred is Cont-done-wrong. Protocols use inheritance rather than composition :(  Everything is done verbose-Java-style for no good reason
16:24:42 <simpson> Peaker: Which puts Python at a grand total of one semi-usable networking library, to Haskell's zero. >:3
16:24:44 <jrmithdobbs> Peaker: i've had some fun with eventmachine + goliath in ruby (it's twisted, without having to deal with python ;p)
16:24:45 <hpc> Peaker: as opposed to the rest which is done verbose-python-style for no good reason ;)
16:25:04 <simpson> Peaker: Anyway, I'm not really interested in a flamewar. We've been over this ground umpteen times.
16:25:06 <jrmithdobbs> Peaker: the performance wall on certain things is admittedly lower than twisted though
16:25:06 <Peaker> simpson: forkIO and ordinary network code is 100x more usable than Twisted :P
16:25:17 <Tekmo> Haskell networking is pretty easy
16:25:21 <hpc> ^
16:25:23 <simpson> Peaker: Yeah, we've been through this as well.
16:25:39 <hpc> an echo server in haskell is 2 lines
16:25:40 <Peaker> hpc: Python isn't very verbose.. I think it's on par with Haskell on most examples (much shorter according to the shootout, iirc)
16:25:51 <haasn> fizbin: do you know if something like that exists for Java? :)
16:25:57 <jrmithdobbs> simpson: i'm liking network-conduit but the docs on all the haskell network stuff is ... lacking to be nice
16:26:02 <Peaker> simpson: I think we've been through it once, and I don't remember what your argument was :)
16:26:08 <hpc> Peaker: haskell pays more lines on the shootout to compete with C speed
16:26:20 <Tekmo> jrmithdobbs: Hmmm, then maybe I should write a networking tutorial
16:26:37 <Peaker> hpc: It's not that much shorter than C, either, afair
16:26:39 <fizbin> haasn: Not to my knowledge. And even if it did, a big advantage of gofmt is that it ships with go, so every go programmer uses it and they
16:26:53 <hpc> once you account for that it's higher, because python is slower than ruby
16:26:57 <fizbin> ... and they're therefore all using the same format, period.
16:27:13 <simpson> Peaker: My argument was that Haskell requires a lot of typing to match the general power required to have interdependent client state interoperating with global server state, and that there is not really a single clear library yet that can handle all of the nitty-gritty.
16:27:17 <haasn> simpson: Haskell only has fully-usable networking libraries ;)
16:27:34 <simpson> haasn: Which library would you use to write an IRC server?
16:27:52 <haasn> (I was joking; but) pipes, most likely.
16:27:53 <jrmithdobbs> Tekmo: if you could write a tutorial showing how to setup something like a reactor execution environment hiding all the thread/etc details and presenting like a eventmachine/twisted type api I would love you forever
16:27:53 <hpc> simpson: that's because you list the features of two libraries
16:27:58 <simpson> Anyway, I talked a bunch with Bart, and he confirmed that the best way at the moment involves just hacking it out with STM on your own.
16:27:59 <Peaker> simpson: I think if you compare actual networking code between forkIO/direct-IO style (even without conduit/etc) with Twisted, you'll find the Haskell is shorter and simpler
16:28:18 <Tekmo> jrmithdobbs: What do you mean by reactor execution environment?
16:28:32 <simpson> Peaker: If we could agree on a set of specific benchmarks, then I'd be interested in this.
16:28:39 <jrmithdobbs> Tekmo: eventloop
16:28:40 <jrmithdobbs> Tekmo: http://en.wikipedia.org/wiki/Reactor_pattern
16:28:41 <Peaker> jrmithdobbs: GHC already has a reactor event loop behind the scenes
16:28:42 <fizbin> What the go folks did by shipping gofmt with go is to make swapping go code as close to not working in text but really swapping around ASTs as possible.
16:28:48 <jrmithdobbs> Peaker: deprecated.
16:29:01 <Peaker> jrmithdobbs: nope -- that's how the "blocking" calls are implemented
16:29:16 <elliott> jrmithdobbs: we prefer to have eventmachine/twisted type implementation and thread type api
16:29:18 <jrmithdobbs> Peaker: at least, the functions that hook into that layer have moved around and seem to be going away with .8
16:29:28 <elliott> jrmithdobbs: it is done automatically under the hood.
16:29:29 <fizbin> haasn: Doesn't ANTLR ship with an example java grammar? It seems that could be used to build something like that for java.
16:29:42 <haasn> fizbin: can I use it to parse go code others write into a format I like, too? :)
16:29:46 <elliott> if you use threads and blocking IO it uses non-blocking epoll-style IO under the hood.
16:29:47 <Peaker> jrmithdobbs: because it's automatic. When you do "blocking IO" it actually does async non-blocking in the implementation
16:29:54 <jrmithdobbs> elliott: well, I'm more familiar with the actual event loop metaphor so wrapping threads/etc on top of it confuses the fuck out of me, heh
16:29:56 <Peaker> jrmithdobbs: It's magic!
16:29:57 <haasn> fizbin: perhaps, I don't know what ANTLR is
16:30:08 <Tekmo> jrmithdobbs: The idiomatic Haskell way to do this is to fork one thread per request handler
16:30:08 <hpc> ?ddg antlr
16:30:09 <lambdabot> Maybe you meant: msg id do bug
16:30:17 <hpc> :( my bot's on another network
16:30:19 <alkabetz> haasn: Consider yourself lucky :)
16:30:33 <fizbin> haasn: No, which is part of the point. There is only one right format for go code.
16:30:35 <Tekmo> jrmithdobbs: Then you just have the listener dispatch events to each thread, typically using channels
16:30:37 <alkabetz> haasn: It’s a lexer/parser generator.
16:30:40 <simpson> Peaker: I want to consider three cases: A chat server that refuses to allow nickname clashes (one of Marlow's examples) and that also broadcasts the time of day to clients on every hour, and a TCP proxy that functions even when only one side of the proxy is receiving data.
16:31:03 <simpson> The third case, I suppose, is no longer necessary with conduits and pipes, so I guess only two.
16:31:19 <Peaker> jrmithdobbs: the user-level threads go something like:  read n = w <- waiter ; startNonBlockingRead (callback = wake w) ; yieldToOtherThreadUntil w
16:31:29 <haasn> fizbin: I could satisfy my use case by hacking together some sed scripts and astyle or something; I'm working in a language that isn't quite java but compiles down to it, and I need something to mangle all the ; and {} into a readable layout for my prof
16:31:38 <jrmithdobbs> Tekmo: a common thing I like to do with eventmachine in ruby is spawn off a bunch of stuff with EM.next_tick() (meaning: "run this sometime on the main eventloop sometime in the future") then move on with my work and then EM::Synchrony.sync() on the callback object to emulate locks/stm style synchronization
16:31:58 <Peaker> simpson: how does Marlow's example handle it?
16:32:00 <jrmithdobbs> when I actually need the data
16:32:24 <jrmithdobbs> I see how to do achieve the functionality in haskell using green threads, but it confuses me to write threaded code to interact with my eventloop ;p
16:32:27 <fizbin> haasn: There's also always loading it into eclipse or some other IDE that reformats code when you ask it, and tell it to reformat the whole thing.
16:32:47 <simpson> Peaker: Lots of STM to synchronize the internal server state. My additional challenge is for the server to have another process going on concurrently which operates on the server state and interacts with the clients.
16:33:13 <fizbin> haasn: Actually, you should check out http://blogs.operationaldynamics.com/andrew/software/java-gnome/eclipse-code-format-from-command-line\
16:33:14 <haasn> fizbin: aie, assuming I had eclipse installed anywhere - let alone on the headless development machine; this is getting quite off-topic though
16:33:28 <fizbin> (Minus the extra backslash)
16:33:36 <simpson> Peaker: My second case is based on a code example in an old conduits blog post: A TCP proxy that only works as long as both sides are sending data. It blocks if only one side is sending data and has no recourse for when that happens.
16:33:46 <Peaker> simpson: Do you have example Twisted code shorter/nicer than Simon Marlow's code?
16:34:06 <simpson> Peaker: Not at the moment; it never occurred to me that this might be of interest to anybody. :3
16:34:13 <Tekmo> simpson: The way you do that is easy
16:34:27 <Tekmo> simpson: Just fork two threads, one for each half of the communication
16:34:37 <Tekmo> simpson: Then the the two threads communicate using STM if necessary
16:34:56 <Tekmo> simpson: That prevents either half from getting blocked on the other
16:34:59 <simpson> Tekmo: Why would I need STM for a TCP proxy? What needs to be synchronized?
16:35:06 <Peaker> simpson: When I wanted to show that Python abstractions can be transliterated into Haskell relatively naturally, and then you get type safety and performance boost for the same amount of code (ended up ~10% larger in Haskell, eventually), which is really nice. I put up a blog post with the code
16:35:09 <Tekmo> simpson: That's only if you want the two halves to communicate
16:35:18 <Tekmo> simpson: If  it just a proxy, they don't need to, and you can ignore STM
16:35:26 <Tekmo> Here, I will go ahead and write up a proxy for you
16:35:37 <simpson> Tekmo: I think that you might have missed the part where this was in conduits. :3
16:35:48 <Tekmo> I'm writing it up using `pipes`
16:36:08 <simpson> Tekmo: Seriously, save your typing. It's okay.
16:36:22 <Tekmo> Alright :)
16:36:25 <Tekmo> It's not that hard
16:36:29 <Tekmo> It's just like 5 lines of code
16:39:10 <Enigmagic> simpson: something like this? https://gist.github.com/qnikst/2008113
16:40:45 <Tekmo> There, a really stupid and simple proxy: http://lpaste.net/95369
16:41:30 <simpson> Enigmagic: Possibly? I mean, the number of threads spawned looks sufficient.
16:42:35 <glguy> simpson: just on the topic of proxies, I put a socks5 proxy server on github the other day, probably not relevant to you just exploring things, but I haven't been following chat closely
16:43:16 <simpson> glguy: I'm just mentioning that making a correct TCP proxy is hard.
16:43:43 <Peaker> Tekmo: even with ordinary strict IO, forwarding two sides is trivial...
16:43:44 <simpson> Tekmo: So IIUC this is a unidirectional proxy, right? There's no data flowing back from the server to the client?
16:43:59 <Tekmo> Oops, forget the other direction.  Just a second ....
16:44:06 <Tekmo> Either way, Peaker is corret
16:44:11 <Tekmo> You don't even need a stremaing library to get this correct
16:44:17 <Tekmo> Just fork one thread per direction
16:44:31 <glguy> simpson: correct in that it needs to support one side closing without disrupting the other?
16:45:23 <simpson> glguy: Well, I'll settle for successfully continuing to forward data in one direction even when the other side doesn't send any data.
16:45:24 <Peaker> let side a b = forkIO . forever $ readChunk a >>= write b {- assuming readChunk throws an IO error upon EOF -} ; side x y >> side y x
16:45:47 <Peaker> s/side/forward probably
16:46:00 <glguy> simpson: and you don't want to use two threads?
16:46:14 <Tekmo> There: http://lpaste.net/95370
16:46:15 <simpson> glguy: Oh, no, the threads are fine. My main point was that this is a tricky problem.
16:46:23 <haasn> fizbin: thanks, I'm sure I'll be able to salvage some of it when I'm less tired :)
16:46:35 <haasn> seems like I need to ‘obtain’ some eclipse config file
16:46:46 <Peaker> simpson: the code I wrote is straight-forward as hell :)
16:46:50 <glguy> simpson: That's what I'm trying to get at. What had you identified asa the hard part?
16:46:58 <simpson> Also, again, I'm quite happy with Bart's solution of "Write lots of code, some of which uses STM to synchronize state."
16:47:03 <Tekmo> simpson: I think you should check out the `async` library
16:47:09 <Tekmo> simpson: It solves a lot of the problems you are describing
16:47:19 <fizbin> haasn: Only if you want to customize the formatting. If you don't much care and are happy with Eclipse default, then...
16:47:29 <simpson> glguy: The part where, having written a big pile of stuff to make your networking application work, you decide to turn around and contribute back some networking code that everybody can use. :3
16:47:34 <Peaker> simpson: Twisted is going to need more code than what I wrote for something that cannot parallelize nicely and is less composable
16:47:49 <ericmoritz> I'm trying to enable profiling with my project using cabal-dev.  I've tried "cabal-dev install --enable-library-profiling --enable-executable-profiling" but when I run "$EXEC +RTS -p" it just spits out the docs
16:47:59 <simpson> Tekmo: Yep, async is cool. It's unfortunately not terribly well-suited to streaming data or packet-based protocols.
16:48:00 <haasn> fizbin: the command line still complains if I don't specify a path to a configuration file
16:48:19 <Tekmo> simpson: Fortunately, `pipes` *IS* well-suited to streaming data and packet-based protocols
16:48:33 <fizbin> You can't use /dev/null ?
16:48:49 <simpson> Tekmo: Yes. My current solution to my problem involves a small amount of conduits, a small amount of cereal, and a small amount of STM.
16:49:45 <simpson> Tekmo: I think that you missed my general thrust: "...there is not really a single library yet that can handle all of the nitty-gritty [of building a networking application with complex inner state.]"
16:50:02 <Tekmo> simpson: So you mean that you want some higher-level framework for this sort of thing?
16:50:20 <sclv> hi all, is there anyone with talent doing audio around?
16:50:29 <sclv> We have the ghcjs talk at ny-haskell but the sound came through really poorly
16:50:35 <sclv> because we weren't using a good setup
16:50:36 <simpson> Tekmo: It'd be nice.
16:50:48 <sclv> Luite's talk is really interesting and I think it would be great to share it with the world
16:50:58 <sclv> but in this state the sound is just too hard to listen to
16:51:08 <Tekmo> simpson: Hmmm.  Is there a Python library that you think makes a good model for the Haskell one to aspire to?
16:51:31 <sclv> I think the main hum is ambient from it sounds like air conditioning or the like
16:51:41 <sclv> Its a hiss really
16:51:44 <simpson> Tekmo: As long as Haskell doesn't have select()-style primitives for events, then no, there's no real point.
16:51:58 <sclv> Anyone want to volunteer to help us scrub the sound, or know someone that I can ask?
16:51:59 <Tekmo> simpson: Why do you assume that select is the only way to solve the problem?
16:52:31 <simpson> Tekmo: Because porting any kind of high-performance I/O from Python to Haskell doesn't make sense otherwise?
16:52:39 <Tekmo> simpson: Haskell's IO manager is damn fast
16:52:54 <simpson> Tekmo: Chill; I'm not having that argument.
16:53:14 <Tekmo> Ok, I will chill :)
16:53:19 <simpson> Tekmo: Look. Say you're making a game. So you have some sound stuff, some input stuff, some GL stuff. Maybe you make a library that eases game development.
16:53:24 <Peaker> simpson: but GHC uses epoll already
16:53:57 <simpson> So now you're making a networking application. You have some concurrency stuff, some binary parsing stuff, some packet routing and protocol stuff. Why couldn't there be a networking library that helps manage all of that?
16:54:31 <Peaker> simpson: "... select()-style primitives for events ...." "Because porting any kind of high-performance I/O from Python to Haskell doesn't make sense otherwise" <-- sounds like you're unaware of the IO manager and its use of epoll?
16:55:06 <simpson> Peaker: Yeah, again, not having that specific argument. I was saying that directly porting any Python networking library doesn't make sense.
16:55:26 <Tekmo> simpson: Why do you want to port Python networking libraries?
16:55:29 <Peaker> simpson: sure, callback-style is unnecessary
16:55:38 <Peaker> simpson: which is nice
16:55:40 <simpson> And that's because anything in Python is going to fundamentally rely on receipt of events generated by a builtin primitive which notifies an event loop of data that is incoming or timers that have expired.
16:55:45 <simpson> Tekmo: I don't!
16:55:54 <Tekmo> simpson: Oh, I see
16:56:13 <Tekmo> simpson: You want to basically see how to take something that expects a `select`-like interface and get it to work within Haskell
16:56:21 <simpson> Whereas Haskell's fundamental primitives are so different that it's unreasonable to assume that the same models could work without contortions.
16:56:30 <simpson> Tekmo: Nope.
16:56:33 <Tekmo> Aw :(
16:56:42 <tanob> hey there, where can I find Cabal's documentation? Google is not helping me...
16:56:57 <simpson> Tekmo: I want to take this idea of "a library that, by simplifying and wrapping together concepts, eases the development of networking applications" and explore it.
16:57:13 <Peaker> simpson: basically, to make it work in Haskell you have to convert the "goto"-style callbacks/promise-chaining to structured programming
16:57:16 <monochrom> tanob: http://www.haskell.org/cabal/users-guide/
16:57:40 <simpson> Peaker: I'm not having that argument either. Consider the analogy that I already deployed, about how game libraries ease game development.
16:58:06 <tanob> monochrom: yep but I'm unable to find the description of fields like "build-depends" and "main-is", etc.
16:58:18 <Peaker> simpson: the stuff you mentioned in the game dev sentence seem very orthogonal to one another
16:58:36 <Tekmo> Woah, did the user guide change?
16:58:40 <Peaker> simpson: in the Haskell world we use a bunch of libraries and not a "game lib"
16:58:43 <simpson> Peaker: And yet there are many libraries on Hackage that aid in pulling those things together and making them all easier to manipulate.
16:59:15 <monochrom> http://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
16:59:22 <simpson> gloss, SDL, free-game, to name three off the top of my head.
16:59:33 * monochrom feels like being used
16:59:43 <Peaker> simpson: not afaik.. there's GLFW-b for drawing/window-input (both are in it because they aren't orthogonal, attached to same window).. sound is done differently, physics with a diff. lib, etc
16:59:51 <Tekmo> simpson: You should take your ideas and write them up into a blog post or a reddit post.  I think you could generate a lot of useful discussion
16:59:58 <Tekmo> Anyway, I have to head out now, but it was nice talking to you guys
17:00:04 <Peaker> simpson: SDL isn't a Haskell library, haven't heard of free-game
17:00:18 <simpson> Peaker: http://hackage.haskell.org/package/SDL
17:00:36 <Peaker> simpson: it's just bindings -- bindings reflect the C library's philosophy, not the Haskell philosophy
17:00:43 <tanob> monochrom: thanks! For some reason I thought that would go into "Cabal spec..."
17:00:48 <simpson> Peaker: And yet it's something that is available and useful and used.
17:00:57 <Peaker> simpson: what advantage is there to tying sound and graphics together in the same lib?
17:01:04 <simpson> Y'know what, I'm gonna go home. I really didn't want to argue and this isn't getting anywhere.
17:01:25 <Hari`> tanob, you might find this useful too, if you haven't seen it alrady: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
17:01:37 <Peaker> simpson: if you cut discussions short every time before they reach the basis of the disagreement, of course that'd be the result :)
17:01:47 <monochrom> instead of advocating for a lib, you should make that lib or pay someone to make it
17:02:05 <monochrom> and instead of advocating against a lib, you should pay someone to not make it
17:02:31 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #2
17:02:38 <Peaker> (exists someone. pay someone to make lib) is much easier than (forall someone. pay someone not to make lib)
17:03:00 <simpson> Peaker: Well, I'm pretty sure that our disagreement is fundamentally based around the fact that, by mentioning Python, I've convinced you that my position is untenable.
17:03:19 <simpson> And I'm frankly just not interested in having that discussion again.
17:03:35 <Peaker> simpson: not really, I used Python and Twisted a lot, and can relate.. but I do seem to recall the previous discussion was also cut short, so I guess it's unlikely to get anywhere
17:03:41 <tanob> Hari`: awesome, that gives me a good information on a typical Haskell project structure, thanks!
17:03:47 <monochrom> yes, that one is harder, and rightfully so
17:04:09 <tanob> I'm currently trying to understand if there's a way to avoid the dependencies duplication between your Executable and the Test-suite..
17:04:31 <tanob> I'd expect that the Executable deps to be transitive
17:06:37 <Hari`> tanob, what i do is let emacs tell me which imports are redundant, then i try to do "cabal build" and if something is missing from the dependencies list (build-depends) of the cabal file, i add it
17:06:44 <Peaker> simpson: I've changed my mind many times, and from various discussions on the internet.. so I don't agree with others about the uselessness of internet discussions/arguments
17:06:54 <Hari`> which libraries are redundant...
17:07:13 <Hari`> running "cabal build" tells you what's missing
17:07:54 <[swift]> anyone else encountered an issue where ghc-mod grumbles that it can't find modules which aren't exported?
17:08:05 <tanob> Hari`: yes, `cabal build` is quite smart and tells about it, the issue I
17:08:13 <[swift]> it seems like this should work.. not sure if i have something configured incorrectly
17:08:38 <Hari`> i've only written one program using haskell, though
17:08:40 <tanob> Hari`: yes, `cabal build` is quite smart and tells about it, the issue I'm facing is that the "build-deps" in my executable section also need to be in the "test-suite" "build-depends" section
17:09:03 <tanob> I think this SO thread is related: http://stackoverflow.com/questions/10163604/how-to-reduce-duplication-in-the-build-depends-fields-of-a-cabal-file
17:10:28 <Hari`> monochrom, thanks for that info you gave me yesterday -- the evaluate function helped
17:10:37 <monochrom> at the end, I think I prefer duplication
17:11:02 <Hodapp> moops: Still around?
17:11:07 <moops> Hodapp: i am
17:11:39 <Hodapp> moops: I am not certain of the exact paper where I first read this, but one of the more referred-to ones is just called "Total Functional Programming".
17:12:05 <Hodapp> moops: looking for the author now.
17:12:28 <moops> D.A.Turner ?
17:12:28 <Hari`> my main function has this: forkIO bankFeeds >>= evaluate, and bankFeeds is this: bankFeeds :: IO ()
17:12:29 <Hari`> bankFeeds = do
17:12:29 <Hari`>   toForce <- cachedWeeklyTransactions
17:12:29 <Hari`>   deepseq toForce (return ())
17:12:29 <Hari`>   threadDelay (3600000000 * 4) >> fmap force bankFeeds -- once every 4 hour
17:12:34 <Hodapp> moops: yes!
17:12:37 <tanob> monochrom: what do you mean? do you prefer it instead of the solution in the SO thread?
17:12:39 <moops> cool
17:12:42 <moops> thanks!
17:13:09 <monochrom> what is the solution in the thread? I haven't read, is it simply "create a library section"?
17:13:12 <Peaker> Hari`: what's the evaluate for?
17:13:21 <Hari`> and the interesting thing now is that instead of the cachedWeeklyTransactions running every four hours as I'd expect, it runs every 25 mintues
17:13:32 <monochrom> because I don't consider it a solution
17:14:30 <Hari`> one time it seeemed to run many many times a second -- the threadDelay wasn't effecting what I wanted it to
17:14:45 <Hari`> it seems sort of random to me, this behavior
17:15:29 <Hari`> Peaker, evaluate forces the normally lazy evaluation of something
17:15:42 <tanob> monochrom: yep, I agree, that's why I was trying to read the Cabal docs so I could better understand what they suggest or what's the reason it's like this
17:17:54 <Peaker> Hari`: that evaluate is forcing the ThreadId returned from forkIO, which is forced anyway
17:17:58 <Peaker> Hari`: IOW it does nothing
17:19:01 <Peaker> Hari`: maybe it was meant to be: forkIO (bankFeeds >>= evaluate)?  But bankFeeds does not return anyway. Which makes the "fmap force" on it also meaningless
17:20:49 <monochrom> it has the potential of spending memory, if that is a desired feature
17:22:22 <bz> someone gimme a lambda
17:22:35 <monochrom> λ
17:22:54 <bz> danke schon!
17:24:29 <Hari`> well, one way or another the execution of my function (which updates a cache) is being forced -- its' just that it's hapening more often (but regularly) than I'd like
17:24:56 <Hari`> let me try it without the evaluate..
17:26:19 <Adebar> Hi,
17:26:29 <Adebar> I'm struggling with IO
17:26:38 <Adebar> and I've been looking at a lot of tutorials already
17:26:43 <dibblego> @tell chrisdone when I click Raw on lpaste.net I get the initial revision, not the latest
17:26:44 <lambdabot> Consider it noted.
17:27:00 <Adebar> to put it quite simply: how do I return an Int like 1 as the type IO Int
17:27:11 <monochrom> "return 1"
17:27:46 <Adebar> No instance for (Num ()) arising from the literal `1'
17:27:49 <Adebar> tried that one already
17:28:02 <monochrom> it works for me. I can't reproduce your problem.
17:28:14 <ion> adebar: You should pastebin your code and the error message.
17:28:19 <rasfar> Adebar: do you have a type signature on your function ending IO () ?
17:28:26 <Peaker> Adebar: you seem to be using "return 1" in a context that expects the type "IO ()"
17:28:27 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
17:28:31 <rasfar> You'd need IO Int for it to work like you want
17:28:34 <darthdeus> is there a version of takeWhile which also returns the first element for which the condition fails?
17:28:40 <monochrom> @quote dmwit tweet
17:28:41 <lambdabot> No quotes match. Sorry.
17:29:11 <Adebar> Peaker: yes, the context expects type "IO ()"
17:29:14 <darthdeus> i guess i can do head $ dropWhile instead
17:29:37 <monochrom> change the context to expect "IO Int" then
17:29:48 <Peaker> > uncurry (++) . second (take 1) $ break (<5) [1..10]
17:29:51 <lambdabot>   [1]
17:29:51 <rasfar> (what i said...)
17:30:07 <Peaker> > uncurry (++) . second (take 1) $ span (<5) [1..10]
17:30:08 <lambdabot>   [1,2,3,4,5]
17:30:55 <Peaker> darthdeus: takeWhileAndNMore f n = uncurry (++) . second (take n) . span f
17:30:56 <monochrom> yes, what rasfar says and everyone says
17:31:09 <darthdeus> uhm
17:31:31 <Peaker> darthdeus: or by "also returns" you mean separately? or do you need "only returns" (suggested by your idea of using dropWhile too?)
17:31:47 <Peaker> > span (<5) [1..10]
17:31:48 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
17:32:10 <rasfar> monochrome: ?
17:32:12 <Adebar> OK, here is a pastebin with my problem: http://pastebin.com/VVAKhNkQ
17:32:12 <darthdeus> Peaker: oh that's smart
17:32:17 <darthdeus> yeah span is what i need
17:32:18 <Adebar> I just ripped out everything that is irrelevant
17:32:18 <mauke> The paste VVAKhNkQ has been copied to http://lpaste.net/95375
17:32:33 <monochrom> rasfar: I want to acknowledge that you said it first :)
17:32:48 <Adebar> and if I compile it, I get the following error message:     Couldn't match type `()' with `Int'     Expected type: IO Int       Actual type: IO ()
17:32:52 <rasfar> aw warm fuzzies ok (:
17:33:16 <rasfar> anyone keen on Repa?
17:33:26 <monochrom> putStrLn "bad input" is the one disobeying IO Int
17:33:38 <Adebar> do pastebins automatically get copied to lpaste.net?
17:34:12 <Fuuzetsu> Yes.
17:34:30 <monochrom> replace it by return 0
17:34:44 <Adebar> oh, okay!
17:34:46 <Adebar> Thanks a lot
17:34:55 <rasfar> or maybe better, did SPJ not just give a talk or something on Repa? I could swear I saw it lauded a few days ago, would like to check it out, but strangely can't seem to find it in the logs. anyone know what I'm talking about? (not too important)
17:34:55 <Adebar> but the problem is that I want to return an error message
17:35:03 <Adebar> so I can just use a regular "error. ..." construction?
17:35:25 <monochrom> you can, but that terminates the whole program
17:35:43 <Adebar> what's the standard way to do that?
17:35:49 <monochrom> it is also not the intended use of error
17:35:52 <Adebar> (I wanted to merely return a string to avoid exitign the program)
17:36:20 <rasfar> IO (Int,String) could maybe work?
17:36:26 <monochrom> then I'll add a paste there
17:37:39 <lpaste> monochrom annotated “pastebin.com/VVAKhNkQ” with “pastebin.com/VVAKhNkQ (annotation)” at http://lpaste.net/95375#a95376
17:37:44 <monochrom> that one
17:37:59 <monochrom> the dual of (Int,String) :)
17:38:29 <rasfar> lol
17:38:37 <monochrom> readX will not do the printing. (why should it?) the caller of readX will decide whether to print
17:38:56 <Adebar> Thanks, this has been really helpful?
17:38:57 <Adebar> !
17:43:06 <rasfar> i'll just put this out there once more in a quiet moment: not seeing good performance with Repa (relative to C), for an example taken from the haskellwiki Repa tutorial
17:43:15 <rasfar> details in http://lpaste.net/95344
17:44:01 <rasfar> 10 seconds to desaturate a 1024x600 image with Repa (on a netbook)
17:45:23 <rasfar> i thought the comparison was pretty fair, since the C code is compiled -O0 and is also non-parallel
17:45:28 <kayloos> Does anybody how to use Scotty (specifically the Warp server) for serving files, like .js and .png/.jpg?
17:46:08 <rasfar> (while the Repa code has lots of optimisation options, and is making good use of both cores)
17:50:06 <sirspazzolot> for future reference, if I complete a program in haskell could I post the source in here for a review of the places I'm philosophically off or is that annoying?
17:50:27 <rasfar> @lpaste
17:50:27 <lambdabot> Haskell pastebin: http://lpaste.net/
17:50:36 <srhb> sirspazzolot: You probably could (as long as you paste it on lpaste.net) - there's also the codereview stackexchange site
17:50:38 <kayloos> sirspazzolot: I think nobody would be annoyed if you posted a paste
17:50:58 <srhb> sirspazzolot: And reddit, but I personally think we're starting to get a bit much of that. Some people might think otherwise though
17:51:43 <srhb> kayloos: Do you want Warp to serve just that, or do you want to run the rest of your application as well?
17:52:36 <sirspazzolot> srhb: wasn't aware there was one of those. awesome!
17:52:38 <kayloos> srhb: To run the rest of the application as well. What I'm looking for is a simple way of making the server serve a directory of .js files, that I can use within my appliction.
17:52:45 <sirspazzolot> kayloos: good to know. thanks!
17:53:06 <kayloos> sirspazzolot: I've posted a few pasties here, and the response has always been great
17:53:08 <srhb> kayloos: I assume there's some sort of routing functionality.. There's a "file" function in Web.Scotty that serves a single file
17:54:09 <srhb> kayloos: Look at the second example in addRoute to see how to extract the filename from that particular route
17:54:28 <kayloos> srhb: Yeah, I noticed that. But I think it would be quite tedious having to specify every .js, .css and .png/.jpg file, and thought that there must be an easier way.
17:55:03 <srhb> kayloos: Look at the second example. :-)
17:55:48 <srhb> kayloos: addRoute GET "/myStaticStuff/:file" $ do f <- param "file"; ...
17:55:59 <srhb> kayloos: Now f is your filename.
17:56:12 <kayloos> srhb: Ahhh... thats genius.
17:56:39 <kayloos> srhb: Thanks man... but where did you see the example? On hackage?
17:56:57 <srhb> kayloos: Not a man, and you're welcome, and yes: http://hackage.haskell.org/package/scotty-0.5.0/docs/Web-Scotty.html
17:57:39 <Enigmagic> kayloos: also https://github.com/ku-fpg/scotty/blob/master/examples/basic.hs
17:57:42 <srhb> kayloos: I figured "let's see what the docs say" ;)
17:58:11 <srhb> scotty seems rather nice for a lightweight framework.
17:58:30 <kayloos> Enigmagic: Thats a good resource! Thanks (wo)/man
17:59:07 <kayloos> srhb: For some reason my brain could not make the connection to use "/:file" to load all the files... I had been reading through the docs for a good hour
17:59:28 <kayloos> thats probably an exaggeration, more like 10 minutes
18:00:06 <srhb> kayloos: Haha. I know the feeling though (even for hours).
18:06:52 <asmyers> Anyone here familiar with Groundhog?
18:17:25 <srhb> asmyers: LOOKS simple enough! Does that work? :D
18:17:48 <asmyers> srhb: Not sure what your referencing? :)
18:17:59 <asmyers> Groundhog looks simple?
18:18:17 <srhb> asmyers: Well, fsvo simple. I was mostly interested it what your question about it would be.
18:18:25 <asmyers> ah
18:18:50 <asmyers> I may have just found the answer, I'm getting  a (huge) strange error from the TH splice
18:18:53 <asmyers> mkPersisit
18:19:10 <asmyers>     Function binding for `Database.Groundhog.Core.entityFieldChain' has no equations
18:19:10 <asmyers>     When splicing a TH declaration:
18:19:29 <asmyers> I think it is because I have a type that is an enumeration
18:19:31 <asmyers> but not sure
18:19:50 <asmyers> I might have to hand roll the instance definition for it?  Not really sure yet
18:20:22 <srhb> asmyers: Where does mkPersist live?
18:20:58 <asmyers> groundhog-th package, module Database.Groundhog.TH
18:21:08 <asmyers> Docs are here
18:21:09 <asmyers> http://hackage.haskell.org/package/groundhog-th-0.4.0.2/docs/Database-Groundhog-TH.html
18:21:10 <srhb> Right.
18:21:56 <asmyers> Seems quite nice, the thing that always torpedoes using Persistent for me is that it really wants to drive your data and schema definition
18:22:11 <asmyers> I like the way this looks, but I'm hung up on this error right now
18:22:15 <srhb> asmyers: Yeah it's very all or nothing
18:22:24 <srhb> asmyers: I bet the error is more TH'y than Groundhog'y though
18:22:54 <asmyers> Yeah, it does seem that mkPersist doesn't like something that I'm giving it
18:23:05 <asmyers> As opposed to the actual database integration
18:23:22 <asmyers> Just have to figure out where i'm going wrong :p
18:23:35 <srhb> Maybe you could share what you're throwing at mkPersist
18:23:47 <asmyers> okay, let me put everything on hpaste
18:23:57 <srhb> asmyers: It's lpaste now :-)
18:24:08 <asmyers> ah I see, just got redirected
18:24:09 <asmyers> haha
18:27:00 <asmyers> okay, for me doing ghc --make on that gives me the same error I'm getting in my project
18:27:09 <asmyers> oh, didn't post here
18:27:09 <asmyers> http://lpaste.net/95377
18:28:35 <srhb> asmyers: Wait, does the splicing really work like that?
18:28:44 <asmyers> Work like what?
18:29:05 <asmyers> It's supposed to, according to the docs it's YAML
18:29:09 <asmyers> If that's what you're asking
18:29:23 <srhb> asmyers: I mean, does mkPersist in the top level really get spliced correctly?
18:29:28 <srhb> I may be confused on the TH specifics here.
18:29:32 <carter> quasquoters are neat
18:29:41 <carter> hrm
18:29:46 <carter> good question!
18:30:22 <srhb> I would expect $(mkPersist ...
18:30:34 <monochrom> quasiquoters are neat. but one has to write a parser...
18:30:34 <asmyers> The example here (expand the 2nd one down)  is like that
18:30:35 <asmyers> https://www.fpcomplete.com/user/lykahb/groundhog
18:30:36 <srhb> Since it's a declaration splice
18:30:42 <srhb> Guess not.
18:30:54 <asmyers> srhb: I don't know a whole lot about TH so I don't know
18:31:08 <asmyers> AFAICT the two are interchangable
18:31:24 <asmyers> $(mkPersist  vs top level mkPersist
18:31:32 <srhb> Really, huh.
18:31:50 <srhb> Clearly I need to read up on my TH agian
18:32:26 <monochrom> yeah, I don't like it, but at the toplevel you can just write "x y z" instead of "$(x y z)"
18:32:38 <srhb> monochrom: I never knew.
18:32:38 <monochrom> it is so write-only
18:33:04 <monochrom> programming is a dialectic class struggle between writer interests and reader interests
18:33:39 <asmyers> monochrom: Well, in this case it's a huge block of YAML so I don't think anyone's going to mistake it for anything else :p
18:33:55 <asmyers> but in general I agree, reader interests should be catered to
18:34:01 <asmyers> when writing
18:34:25 <srhb> asmyers: You can get a dump of the splice, right?
18:34:39 <asmyers> srhb: how do I do that?
18:34:50 <monochrom> -ddump-splices iirc
18:35:15 <srhb> Yes
18:35:56 <monochrom> it may be a huge output and takes some time to read :)
18:36:04 <asmyers> hmm, that doesn't show me much
18:36:27 <srhb> asmyers: I also wonder: is that empty entity allowed?
18:37:57 <srhb> asmyers: anyway I'm definitely back to "groundhog is doing something wrong" here. Ugh, TH.. :P
18:38:08 <asmyers> I added the splice here http://lpaste.net/95378
18:38:09 <asmyers> haha
18:38:19 <asmyers> The empty entity is in one of the examples
18:38:23 <asmyers> and I did try filling it out
18:39:11 <srhb> Those Lefts look worrysome.
18:39:58 <srhb> Hm, no, I don't know.
18:40:05 * hackagebot thyme 0.3.0.3 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.0.3 (LiyangHu)
18:40:34 <asmyers> srhb: Maybe I'll email the maintainer or ask on cafe
18:40:43 <asmyers> srhb: Thanks for looking at it
18:41:07 <srhb> asmyers: Sorry I was less than helpful
18:41:21 <slack1256> I got installed yi on a sandbox, but the configuration file is in ~/.config/yi/yi.hs which uses the .cabal libraries instead of the sandbox one.
18:41:30 <asmyers> srhb: haha no problem, TH is always hard :p
18:41:42 <slack1256> How can i do to make the recompilation use the sandboxed environment?
18:45:06 * hackagebot camh 0.0.2 - Image converter to 256-colored text.  http://hackage.haskell.org/package/camh-0.0.2 (HironaoKomatsu)
18:53:03 <moops> why does cabal keep going if it fails to install something
18:53:17 <moops> im very confused
18:56:38 <carter> parallel?
19:04:29 <srhb> asmyers: Figured it out. See the cutlery example
19:04:34 <srhb> Ah shoot, he left.
19:08:57 <prooftechnique> moops: glib depends on gettext, libffi, pkg-config, and xz. If only xz fails to build, should all the other dependencies just get wiped?
19:09:59 <moops> yes
19:11:00 <prooftechnique> Why?
19:11:35 <moops> if the library failed to install then theres a 50/50 chance i dont care and dont need those dependencies anymore
19:11:49 <srhb> moops: But if they get wiped you can't decide to keep them.
19:11:55 <srhb> moops: If they don't, you can delete them.
19:12:06 <moops> i dont know which ones it installed
19:12:09 <tabemann> random question - if I were going to make a module for genetically-programmed hunter-killer robots, where would be a good place to put it?
19:12:20 <srhb> moops: What? I'm pretty sure it says
19:12:32 <moops> in the 100s lines of scrollback?
19:12:35 <moops> im not reading that
19:13:36 <moops> why would i want dependencies for a library i cant use
19:13:44 <moops> anyway
19:14:00 <srhb> moops: You might want to fix the missing dependency and not have to recompile eeeeverything, say.
19:14:27 <moops> it would take less than 3 minutes for most things
19:14:46 <moops> at least among things i have tried in cabal
19:14:55 <srhb> Right. :P
19:15:05 <srhb> If only all my things where that light or my computer that fast
19:15:50 <moops> im perfectly used to compile times of > 5 hours that just die if theres an error
19:15:59 <prooftechnique> That sounds awful
19:16:15 <prooftechnique> Like, building Gentoo from a tarball awful
19:16:26 <moops> usually if they die its in an unrecoverable state anyway
19:16:30 <moops> or dependency hell
19:16:49 <prooftechnique> Well, cabal hell has become much less frequent, lately, at least for me
19:18:43 <prooftechnique> I sometimes install snap, Agda, lambdabot, and yesod at the same time just for giggles
19:20:58 <tabemann> random package suggestion time: I need a very basic drawing library (basically just lines, polygons, and text), one where I will [i]not[/i] have to deal with OpenGL, what would you suggest?
19:21:29 <prooftechnique> @hackage diagrams
19:21:30 <lambdabot> http://hackage.haskell.org/package/diagrams
19:21:43 <prooftechnique> Not basic, but great!
19:21:58 <khyperia> Gloss?
19:22:17 <khyperia> although I've never used gloss and have no idea how it looks like
19:23:52 <tabemann> prooftechnique: thanks
19:24:38 <prooftechnique> No problemo. I hope you like it!
19:29:22 <carter> diagrams is epcic
19:29:30 <carter> gloss is nice to
19:29:35 <carter> different use cases
19:29:36 <carter> both great
19:31:24 <AshyIsMe> one thing that i'm not a huge fan of with haskell yet is the amount of operators that people seem to define
19:31:47 <AshyIsMe> just looking at diagrams and the first tutorial of it shows 2 new operators almost immediately
19:32:00 <AshyIsMe> i spose you get used to it?
19:32:09 <moops> they are just functions
19:33:02 <prooftechnique> AshyIsMe: It gets easier with time. Eventually there will be things that just feel clunky without operators
19:33:30 <AshyIsMe> ah yeap
19:33:40 <glguy_> and then eventually you'll go back to using normal functions
19:33:43 <AshyIsMe> and to be fair, those 2 particular operators look pretty useful
19:33:44 <prooftechnique> Haha, yeah
19:34:35 <prooftechnique> I feel like there could be a better choice for reverse function application, but I dunno what :D
19:34:52 <glguy_> 'lens' uses (&)
19:35:09 <sirspazzolot> looking at examples in LYAH; why are you limited to one IO action in an else clause unless you wrap it in a do statement?
19:35:15 <prooftechnique> I think we should use £
19:35:28 <geekosaur> sirspazzolot, if is not a statement
19:35:29 <AshyIsMe> as an answer to $?
19:35:34 <prooftechnique> Yes
19:35:38 <geekosaur> it is an expression. if expr then expr else expr
19:35:59 <geekosaur> if you use "do" then it turns multiple fake-statements into a single expression as is expected
19:36:00 <prooftechnique> It's even pronounced the same way as # :
19:36:01 <prooftechnique> *:D
19:36:49 <frx> sirspazzolot do is one way of combining several IO actions into one. another is to use >> and >>= explicitly (which is what do desugars to)
19:37:27 <AshyIsMe> prooftechnique: i pronounce # as "hash"
19:37:58 <prooftechnique> Well, I pronounce # and £ as "octothorpe", so there
19:38:12 <carter> i pronounce # as pound
19:38:20 <carter> or hash
19:38:24 <carter> or cheese grater
19:38:26 <carter> depends on the day
19:38:30 <carter> *grater
19:40:13 * hackagebot pipes-rt 0.3.0 - A few pipes to control the timing of yields  http://hackage.haskell.org/package/pipes-rt-0.3.0 (imalsogreg)
19:41:00 <AshyIsMe> haha i even do it in my head surprisingly
19:41:11 <AshyIsMe> "carter> i pronounce hash as pound"
19:42:31 <khyperia> Is it weird to *not* pronounce symbols, and just think of the actual symbol when reading it?
19:44:58 <moops> nope
19:45:36 <moops> i dont know how one would pronounce -< anyway
19:47:48 <carter> half-cartwheel
19:47:54 <carter> or arrow tail
19:48:12 <moops> oh its a tail
19:48:20 <moops> looked like a jacked up arrow to me
19:48:24 <moops> like it was bent back on itself
19:49:17 <carter> naming things is a super power
19:49:35 <moops> id probably choose flying instead
19:49:39 <moops> but still pretty good
19:50:16 * hackagebot pipes-rt 0.4.0 - A few pipes to control the timing of yields  http://hackage.haskell.org/package/pipes-rt-0.4.0 (imalsogreg)
19:51:09 <AshyIsMe> it's an open alligator symbol
19:51:21 <AshyIsMe> -< open alligator   >- close alligator
19:51:44 <AshyIsMe> or crocodile rather, considering im an aussie
19:52:26 <tabemann> from looking at diagram, it doesn't seem like it exactly fits what I need, particularly in that its animation capabilities are based on active... which assumes simple functions of form Time -> a, rather than events that change state across individual frames which are not reversible
19:53:22 <carter> yeah
19:53:28 <carter> gloss may be what you want
19:53:31 <carter> or opengl propper
19:54:14 <moops> sdl can do polygons/lines
19:54:32 <apples> UG
19:54:36 <apples> oops, wrong channel, sorry
19:55:20 <carter> same idea
19:55:21 <carter> :)
19:55:59 <tabemann> I've played around with sdl before, but that was always with OpenGL 1.x, and OpenGL 3.x seems quite a bit overpowered for what I need it to do
19:56:01 <roconnor> Fucking Data.Binary!
19:56:31 <johnw> roconnor: that's... stong
19:56:34 <johnw> strong
19:56:46 <moops> you can draw with sdl without using opengl at all
19:56:59 <roconnor> This is how systems get rooted!
19:57:11 <johnw> by staying in one place too long?
19:58:42 <tabemann> moops: yeah, I know
19:59:02 <roconnor> God I hope cereal doesn't have the same problem.
20:02:28 <fl00r> i'm trying to learn how regional resource management works and i'm looking at oleg's SafeHandles, the regions package on Hackage, and pipes-safe and they all seem to use IORef as the mutable thingy...why IORef and not something like STM bounded queues and TVars?
20:03:00 <fl00r> i imagine it's because finalization is hard not being in IO...can this be overcome with some acrobatics and io-hooks?
20:03:02 <prooftechnique> roconnor: What's the problem?
20:03:11 <roconnor> http://justinleitgeb.com/haskell/mind-bending-behavior-for-deserialization-in-haskell/
20:03:19 <prooftechnique> Oh, THAT
20:03:49 <dolio> roconnor: It does.
20:05:24 <roconnor> fuck fuck fuck
20:06:58 <dolio> Good luck writing a library that fixes this.
20:07:05 <roconnor> what?
20:07:07 <dolio> And doesn't completely suck.
20:07:35 <roconnor> dolio: how hard is to check if a list is sorted?
20:08:40 <dolio> I guess it could just bomb after checking whether the map is valid.
20:09:04 <roconnor> dolio: or return Left in the case of cereal.
20:09:36 <tabemann> cool - gloss seems *perfect* for what I need
20:09:51 <dolio> We have a library at work that can write out a format description of what  you're serializing, I think.
20:09:54 <dolio> But it's pretty terrible to use.
20:10:11 <roconnor> fromAscList shoudln't even be in the Data.Map module.
20:10:30 <roconnor> It should be hidden away out of reach from people.
20:11:04 <roconnor> dolio: it doesn't have to write out the type of data being serialized.
20:11:19 <roconnor> All it needs to do is to *not* make invalid data structures.
20:11:24 <roconnor> ever
20:11:27 <roconnor> that's it
20:11:30 <dolio> No, it just needs to do something slower.
20:12:06 <roconnor> dolio: if someone wants to go faster they can deserialize their own AscList and introduce their own security holes.
20:12:18 <roconnor> let's not inflict it on everyone.
20:12:50 <elliott> dolio: it could just attach a TypeRep to every serialised thing and check it.
20:13:03 <carter> yeah, that post is like a funny version of   read . show
20:13:03 <roconnor> who is talking about TypeRep
20:13:08 <carter> he is :p
20:13:13 <roconnor> just dont' make corrupted Data.Maps
20:13:34 <srhb> Oh, there was a Reddit post about that recently, was there not?
20:13:38 <carter> today
20:14:01 <srhb> "recently" *hand-waves*
20:14:04 <srhb> <_<
20:25:58 <dolio> I guess you have to do the check anyway, because you can just spoof the type rep.
20:26:41 <dolio> But people will make mistakes.
20:28:42 <nstdloop> If I want to make a datatype Tree a, if I want it to be an instance of Show I should do: instance Show (Tree a) where?
20:28:54 <nstdloop> or instance Show Tree where?
20:29:00 <scshunt> the former
20:29:06 <nstdloop> ok
20:30:52 <nstdloop> If I already have a function, let's say strTree, that works on that tree and makes a nice string to print it
20:30:58 <nstdloop> how can I use that in the Show instance?
20:31:15 <nstdloop> I tried show = show strTree or show $ strTree or show . strTree
20:31:17 <nstdloop> and none of those works
20:31:33 <moops> show = strTree ?
20:32:07 <nstdloop> No instance for (Show a) arising from use of `strTree`
20:32:15 <moops> whats the type of strTree?
20:32:25 <geekosaur> you probably don't want to reinvoke show there unless you want that string to get quotes and escaping
20:32:26 <nstdloop> Show a => Tree a -> String
20:32:26 <moops> Tree a -> String ?
20:32:35 <moops> ah
20:32:41 <dolio> roconnor: You should go file an issue agains bytes, too. :)
20:32:46 <moops> you didnt specify in your instance that the a in your tree was showable
20:32:54 <dolio> Against, even.
20:32:57 <geekosaur> also that
20:33:01 <nstdloop> aaah
20:33:24 <nstdloop> so how do I fix that exactly?
20:33:27 <moops> Show a => Show (Tree a)
20:33:29 <moops> where
20:33:37 <roconnor> dolio: what is bytes?
20:33:45 <Clint> @hackage bytes
20:33:45 <lambdabot> http://hackage.haskell.org/package/bytes
20:33:46 <nstdloop> gotcha
20:33:51 <dolio> edwardk's wrapper for binary and cereal.
20:34:00 <dolio> Which also has its own implementation, which is wrong.
20:34:28 <nstdloop> moops: Awesome. That works.
20:35:08 <moops> :D
20:56:24 <cschneid> I have a tiny doc patch to the directory library - but I dont' seem to be able to create a ticket in trac. What do I need to do to submit this patch?
20:57:26 <carter> cschneid: is it on github now
20:57:27 <carter> ?
20:57:41 <cschneid> the patch is not, and the original lib is not hosted on github, or I'd just pull request it
20:58:04 <carter> cschneid: open a ticket on ghc trac if its managed by ghc hq
20:58:17 <carter> and or email the libraries list
20:58:26 <carter> asking where to file the ticket / patch
20:58:27 <cschneid> carter: the specific component doesn't let me it seems? new to trac
20:58:36 <carter> what what
20:58:37 <jrmithdobbs> that's annoying, hlint doesn't support record syntax in gadts :(
20:58:38 <carter> ghc trac
20:58:57 <carter> cschneid: just file a "bug report" if its a bug fix
20:59:13 <cschneid> ohh I see
20:59:18 <cschneid> it lets you in, but lower permissions until email verify
21:00:13 <cschneid> carter: thanks - I'm on it now
21:00:19 <carter> coool
21:00:31 <carter> share the ticket once your'e done writing it up
21:00:33 <carter> bug fix?
21:02:19 <cschneid> yeah, first one on trac. Not a real bug, just a doc tweak
21:02:25 <cschneid> two lines, just add a bit of markup
21:02:28 <cschneid> http://ghc.haskell.org/trac/ghc/ticket/8509#no1
21:02:34 <cschneid> but hey, something.
21:02:41 <cschneid> I'm helping! (also going to bed now.)
21:03:00 <carter> yay
21:03:01 <carter> thanks
21:03:52 <crocket> Is Osker useable?
21:04:22 <Cale> crocket: Is that the microkernel?
21:04:26 <crocket> yes
21:04:35 <crocket> no
21:04:43 <crocket> Osker is an OS written in Haskell.
21:04:47 <tnks> CD
21:05:26 * hackagebot music-diatonic 0.1.1 - Implementation of basic western musical theory objects.  http://hackage.haskell.org/package/music-diatonic-0.1.1 (AlanHawkins)
21:09:32 <carter> does it still type check? :)
21:12:10 <Cale> You might send an email to the authors of this paper and see what they can tell you about it http://web.cecs.pdx.edu/~rebekah/papers/icfp05_h.pdf
21:13:49 <crocket> Are reduce, map, and forEach part of FP?
21:14:11 <Cale> I guess
21:14:31 <Cale> map and reduce/fold are definitely functional programming idioms
21:14:52 <Cale> forEach can be seen as map combined with some kind of sequencing operation to glue the iterations of the loop together
21:16:09 <Cale> If you can't implement a polymorphic map function in your language, functional programmers are not going to be happy with it.
21:20:28 * hackagebot bytes 0.13 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.13 (EdwardKmett)
21:21:16 <Platz> trying to understand order of operations.  For a foldr we get (1+(2+(3+(4+(5+(6+(7+(8)))))))).  my intuition tells me 7+8 needs to happen first, but haskell does 1 + (thunk) first?
21:22:14 <Cale> Lazy evaluation is outermost first. The pattern match that (+) does on its right parameter will be put on the stack (at least in GHC), and (2 + ...) will be evaluated, and a similar thing will happen there.
21:23:22 <Cale> and 7 + 8 will be the first subexpression to actually finish evaluating, the stack will pop, the pattern match inside of (+) will succeed, and things will continue
21:23:42 <Platz> thanks, i hadn't seen the 'lazy means outermost first' rule in the stuff i've read so far.  that does make sense with everything so far
21:25:48 <Cale> Yeah, lazy evaluation implies two things: 1) evaluation is outermost first, and 2) variables which are bound in pattern matches (e.g. the parameters to functions) are evaluated at most once even if they occur in multiple places in their scope, and any work done evaluating them is shared between the occurrences
21:27:00 <dmj`> is pipes distro down? can't cabal install
21:27:32 <Platz> cool
21:28:21 <Cale> Haskell isn't actually specified to use lazy evaluation, but lazy evaluation is a reasonable approximation of the behaviour you'll see from most Haskell implementations.
21:28:46 <Cale> GHC includes a strictness analyser which will evaluate things sooner if it can prove that it will need to evaluate them
21:30:38 * carter and its possible to write really strict code when you want to too
21:30:39 <carter> and its possible to write really strict code when you want to too
21:32:46 <Platz> interesting.  yeah things like which way to construct data structures (like foldr for cons'ing lists) will take some getting used to
21:32:46 <jrmithdobbs> > let param2 = SearchCond (OPnot (OPins (OPreg (OPext "param")))) "^[^ ]*$"
21:32:48 <lambdabot>   not an expression: `let param2 = SearchCond (OPnot (OPins (OPreg (OPext "pa...
21:33:43 <jrmithdobbs> there's got to be a better way to write that second param (it really is a nested call like that though)
21:33:44 <Cale> Yeah, the thing to notice about foldr
21:33:47 <Cale> @src foldr
21:33:48 <lambdabot> foldr f z []     = z
21:33:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:34:00 <Cale> ...is that it passes control to f immediately
21:34:18 <Cale> and only if f looks at its second argument will the foldr continue
21:34:26 <Cale> @src foldl
21:34:26 <lambdabot> foldl f z []     = z
21:34:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:34:52 <Cale> foldl just greedily applies itself to new arguments, building up a large expression in its second parameter
21:35:04 <Cale> (until it reaches the end of the list)
21:35:14 <Cale> So foldr can work on infinite lists, while foldl can't.
21:36:00 <linz> why foldr can work on inifinite lists?
21:36:09 <Platz> thats clear.  seeing the source helps, will have to keep hackage handy
21:36:10 <linz> foldr will start from the end of the list?
21:36:20 <Cale> foldr starts from the beginning of the list
21:36:48 <Cale> foldr f z (x:xs) immediately produces f x (foldr f z xs)
21:37:02 <Cale> at this point, f gets control of things
21:37:28 <Cale> and foldr might be done, if f doesn't pattern match on its second parameter
21:37:32 <Cale> For example...
21:38:10 <DarkFox> Anyone here happen to know of an easy way to... convert "123" into [1,2,3] ?
21:38:21 <Cale> > foldr (\x y -> if x > 1000 then "done!" else y) "oh, nothing big" [1..]
21:38:22 <lambdabot>   "done!"
21:38:52 <DarkFox> > foldr (\x y -> if x > 1000 then "done!" else y) "oh, nothing big" [0..999]
21:38:54 <lambdabot>   "oh, nothing big"
21:39:50 <Cale> > map (\c -> ord c - ord '0') "123"
21:39:52 <lambdabot>   [1,2,3]
21:40:00 <DarkFox> Omg
21:40:05 <DarkFox> Thanks haha, so nice and simple.
21:41:00 <Cale> > foldr (\x xs -> 2*x : xs) [] [1..] -- we can implement map using foldr, and it'll work on infinite lists
21:41:02 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
21:41:18 <dmj`> let result = ("["++) . (++"]") . intersperse ',' $ "123" in read result :: [Int]
21:41:22 <dmj`>  > let result = ("["++) . (++"]") . intersperse ',' $ "123" in read result :: [Int]
21:41:36 <Cale> Can't be a space before >
21:41:40 <dmj`> > let result = ("["++) . (++"]") . intersperse ',' $ "123" in read result :: [Int]
21:41:42 <lambdabot>   [1,2,3]
21:41:45 <dmj`> ah thanks :)
21:42:17 <dmj`> Cale: I guess your way is simpler
21:43:38 <dmj`> Cale: In Haskell are {-# #-} used for pragmas only or can they be for comments as well
21:44:52 <Cale> {- -} is a comment
21:45:13 <Cale> I suppose all pragmas are technically comments too, but you should probably not use the #'s unless it's a pragma
21:45:14 <DarkFox> Anyone happen to know a way cleaner than s@([_,_,_]) to match a 3char string?
21:45:58 <Platz> map (\c -> read [c] :: Int) "123"
21:46:08 <johnw> DarkFox: (length s -> 3)
21:46:19 <johnw> but this may be much slower if s is really long
21:46:25 <Cale> It's interesting that you want to match a string of exactly three characters, but don't care what those are.
21:46:57 <DarkFox> johnw: Where to use that? O_o
21:47:03 <Cale> That's a view pattern
21:47:12 <Cale> You'd need to enable the view patterns extension
21:47:14 <DarkFox> Oh so ..
21:47:16 <DarkFox> Got it
21:47:26 <dmj`> Cale: When I attempt to install pipes I get "error: invalid preprocessing directive #-}"
21:47:48 <dmj`> Cale: from line 100 of Pipes/Internal.hs https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/src/Pipes/Internal.hs
21:48:10 <DarkFox> Problem though...
21:48:46 <Cale> dmj`: Are you on a mac?
21:48:58 <dmj`> DarkFox: s@(a:b:c:_)
21:49:00 <Cale> dmj`: It sounds like an error from CPP
21:49:02 <dmj`> Cale: yes
21:49:11 <geekosaur> that does sound like cpp is blowing up, yes. see the end of the /topic
21:49:33 <Cale> geekosaur: ah, convenient :)
21:50:39 <dmj`> geekosaur: thanks
21:50:54 <DarkFox> geekosaur: Suggestion with topic - add http:// :P
21:51:27 <geekosaur> yell at carter? I think he put it there. also it's approaching a length limit I think
21:51:33 <Cale> It might be missing that because channel topics have a limited length, yeah
21:51:41 <DarkFox> Oh
22:01:55 <dmj`> DarkFox: s@(a:b:c:[]), is what I meant
22:02:56 * [swift] just looked over his code, and is sad to see that 90% of it is in IO
22:04:10 <DarkFox> [swift]: Then, lift that IO out!
22:04:18 <[swift]> DarkFox: i wish i knew how!
22:04:30 <DarkFox> lpaste it?
22:05:43 <[swift]> it's kinda big for that unfortunately. most of the IO is due to things like database and filesystem access and STM
22:05:52 <[swift]> and network access
22:07:09 <[swift]> at its core its kinda a database server and a client program. it seems kinda tricky to separate the IO there since IO is all a lot of the code does
22:10:04 <hamster007_> hi I am a haskell programmer trapped in the body of a scala programmer
22:11:00 <hamster007_> rights   :: [Either a b] -> [b]
22:11:24 <hamster007_> rights x = [a | Right a <- x]
22:11:33 <hamster007_> I need that^^^
22:11:36 <hamster007_> in scala
22:13:32 <DarkFox> [swift]: Tar it and upload somehere?
22:14:03 <DarkFox> bsdtar cJf - . | ix
22:14:22 <[swift]> DarkFox: it's all online already =)
22:14:24 <DarkFox> where ix = "curl -n -F 'f:1=<-' http://ix.io"
22:14:30 <[swift]> DarkFox: here's a sample: https://github.com/sethfowler/pygmalion/blob/master/src/Pygmalion/Index/Manager.hs
22:14:31 <DarkFox> [swift]: Then link? :P
22:14:47 <[swift]> (apologies for terrible code; this is my first real haskell project)
22:15:17 <DarkFox> [swift]: Looks alright for a first.
22:15:41 <[swift]> DarkFox: hehe, thanks
22:15:42 <DarkFox> I'll be writing a database somewhat soon - except, it's more for passing events around between clients.
22:16:44 <[swift]> sounds like a cool project! i wouldn't say i've written a database here - i'm just using sqlite. this is an indexer for C++ code based on libclang
22:26:10 <DarkFox> [swift]: I see. Well, I shouldn't have said database myself - more just an event handler / multiprotocol multiplexer / cacher.
22:26:25 <DarkFox> So ... IRC bouncer, Mail bouncer, while logging both.
22:26:27 <DarkFox> For example
22:26:39 <DarkFox> Mail relay *
22:27:06 <DarkFox> In the case of IRC, would also keep the connection stable, reconnect etc etc.
22:27:19 <DarkFox> Thinking a lot like ZNC for that part.
22:28:23 <[swift]> sounds quite useful! i wouldn't mind something like ZNC that could notify me of highlights via some other medium like email or text message
22:28:26 <DarkFox> [swift]: Example usage for this idea - daemon on server, your IRC client connects to it for IRC. While your XMonad also connects through a different protocol just for hilights. Then, you ignore the title of any window and replace it with the hilighted message.
22:28:49 <DarkFox> ^ I'm thinking integration into XMonad :P
22:28:55 <[swift]> ahh, cool!
22:29:14 <DarkFox> ZNc can do TXT message iirc. If not, A module wouldn't be too hard to email an email2sms provider.
22:29:52 <DarkFox> gtmanfred iirc, gets SMSs for hilights when disconnected from the ZNC.
22:29:53 <[swift]> hmm, didn't know that. i set up my znc server so long ago i guess i've forgotten what it can do now. thanks for the tip
22:30:15 <DarkFox> [swift]: Maybe it can't directly, but it can detect hilights if you write a module to do so :P
22:30:50 <DarkFox> With my event manager, it would probally be monadic for modules. modA <> modB <> modC etcetc
22:30:51 <[swift]> DarkFox: yeah, true. was hoping you were saying there was a standard module tho =)
22:30:58 <DarkFox> monoid * ?
22:31:03 <DarkFox> One of those
22:31:20 * DarkFox has been off haskell for a while - just came back for this. :P
22:31:32 <DarkFox> [swift]: Not to mention the bill for email2sms :P
22:31:46 <DarkFox> Get a spam of hilights to find your phone bill +++++
22:31:48 <DarkFox> :P
22:31:58 <[swift]> heh, there'd need to be some rate limiting =)
22:32:07 <DarkFox> Ideally, or better, batching.
22:32:35 <DarkFox> batch and sync / cycle every X minutes of inactivity for example.
22:32:53 <DarkFox> where inactivity refering to of hilights
22:33:28 <[swift]> yup. for bonus points it'd be nice to get bidirectional communication =)
22:34:00 <[swift]> probably only for people with unlimited sms plans, heh
22:34:00 <DarkFox> [swift]: Also with the mail side, I might even create my own protocol for mail transfer between client-server. Create a mutt-like client too.
22:34:19 <DarkFox> [swift]: bidirectional ... full-durplex IRC via SMS.
22:34:20 <DarkFox> O_O
22:34:34 * DarkFox suggests that [swift] learns how to write an app for his mobile.
22:34:37 <DarkFox> Would be much nicer :D
22:34:51 <DarkFox> ^ An app listening for events - done.
22:35:20 <DarkFox> Notify on XMonad & Phone & Server logs. :P
22:35:38 <DarkFox> XMonad would time out or require a click - I'd prefer timeout though
22:36:15 <DarkFox> Or a keybinding to clear it. Also - going to do what I can to make EVERYTHING non IO blocking :P
22:36:38 <DarkFox> Speaking of which, XMonad-contrib's run would be a great benifit to be non-io blocking...
22:37:12 <DarkFox> So many things could be done
22:37:16 <[swift]> hehe, that's the way to go =)
22:37:29 * DarkFox goes back to SMTP/RFC5321.hs
22:38:01 <DarkFox> [swift]: Feel free to /msg me to avoid filling everyone's logs here ^
23:26:14 <lpaste> hamid pasted “why show instance for (Graph t) doesn't work?” at http://lpaste.net/95387
23:26:25 <hamid> hey :)
23:29:17 <arkeet> hamid: instance (Show t) => Show ([Graph t]) <-- this is an overlapping instance.
23:29:26 <arkeet> there already is a Show instance for lists.
23:30:08 <hamid> arkeet, for lists? can't I just overload on my prefered type? :/
23:30:32 <arkeet> there's stuff like OverlappingInstances and IncoherentInstances but you really shouldn't use them.
23:30:59 <arkeet> why not use something other than show for your [Graph t]?
23:31:00 <sopvop> OverlappingInstances are fine
23:31:04 <arkeet> right.
23:31:09 <arkeet> the other one isn't.
23:31:44 <arkeet> well, I don't like OverlappingInstances either.
23:32:04 <hamid> oh! so OverlappingInstances works :/ i wonder why :D
23:32:09 <arkeet> please don't.
23:32:23 <arkeet> why not write your own myShow :: Show t => [Graph t] -> String
23:32:32 <arkeet> instead of using the Show class for that bit
23:32:43 <arkeet> er, the Show instance for lists.
23:32:46 <arkeet> you can still use the one for Graph t.
23:34:02 <hamid> arkeet,  you know I'm trying learn how this works. i tried to use showList method in Show but that didn't work cause I had no idea what do with ShowS.
23:34:30 <arkeet> :t shows
23:34:31 <lambdabot> Show a => a -> ShowS
23:34:35 <arkeet> ShowS is just String -> String
23:34:59 <arkeet> shows/showsPrec use that as a difference list.
23:35:03 <sopvop> > shows 1 $ []
23:35:05 <lambdabot>   "1"
23:35:17 <arkeet> > show 1 ++ show 2
23:35:19 <lambdabot>   "12"
23:35:20 <xpika> whats the most concise way to update the first element of a list in haskell?
23:35:22 <arkeet> > shows 1 . shows 2 $ []
23:35:23 <lambdabot>   "12"
23:35:42 <arkeet> xpika: the obvious way.
23:35:43 <xpika> i'm looking for a hoogle "(a -> a) -> [a] -> [a]"
23:36:00 <arkeet> (i.e. pattern matching)
23:36:07 <arkeet> alternatively, you could use lens
23:36:10 <pqmodn> xpika: perhaps lens has a combinator, but let (a:b) = xs in (f a:b)
23:36:28 <arkeet> that wouldn't work for empty list =(
23:36:44 <pqmodn> d'oh
23:36:50 <arkeet> > over _head (+1) [1,2,3]
23:36:52 <lambdabot>   [2,2,3]
23:36:53 <arkeet> > over _head (+1) []
23:36:54 <lambdabot>   []
23:37:29 <xpika> arkeet:  thankyou
23:37:56 <supki> :t over _head
23:37:58 <lambdabot> Cons (->) Mutator t t a a => (a -> a) -> t -> t
23:39:35 <sopvop> hm, why Data.List.null has that funky (_:_) arse pattern intead of just _ for non empty case?
23:39:54 <arkeet> it is a mystery
23:39:59 <sopvop> first pattern will force constructor anyway
23:40:04 <arkeet> :t all (const False)
23:40:06 <lambdabot> [a] -> Bool
23:40:24 <pqmodn> @src null
23:40:24 <lambdabot> null []     = True
23:40:24 <lambdabot> null (_:_)  = False
23:40:42 <arkeet> > map (all (const False)) ["", "a"]
23:40:44 <lambdabot>   [True,False]
23:44:52 <hamid> honestly overlappinginstances is not good? cause i really like overloading in c++ :D it's like the only good thing about it!
23:45:18 <edwardk> its a terrible idea
23:45:29 <edwardk> in general it doesn't work the way you expect
23:46:20 <edwardk> overlapping instances only properly get dispatched if both are defined in the same module, later refinements in other modules are hit and miss.
23:47:03 <edwardk> you can work around this to a greater or lesser extent with default signatures to reduce the amount of work you need to do
23:47:43 <hamid> ok got it. thanks :)
23:56:05 <Feuerbach> edwardk: but that's not specific to OverlappingInstances; it's just the way instance "scoping" works, right? I guess your complaint is that you don't get any compiler error/warning about it?
