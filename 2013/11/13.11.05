00:00:15 <startling> well, it depends on what you're doing
00:00:48 <bitemyapp> supki_: that fixed it, thank you :)
00:01:16 <dmj`> dfs == pre-order traversal on a tree
00:16:09 * hackagebot texmath 0.6.5.1 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.5.1 (JohnMacFarlane)
00:16:09 * hackagebot imagemagick 0.0.3.1 - bindings to imagemagick library  http://hackage.haskell.org/package/imagemagick-0.0.3.1 (AlexanderVershilov)
00:26:05 * hackagebot csound-expression 3.0.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-3.0.1 (AntonKholomiov)
00:26:22 <Spaceghost> Clint: open your queries.
00:36:06 * hackagebot graceful 0.1.1.1 - Library to write graceful shutdown / upgrade service.  http://hackage.haskell.org/package/graceful-0.1.1.1 (NoriyukiOhkawa)
01:54:17 <Takumo> In GHCi I know when you have an `Either a b` you need to use `let Right x = function_which_returns_either_a_b` to make x be type b
01:54:24 <Takumo> How do i do the same thing for Maybe a ?
01:54:52 <chrisdone> let Just x = …
01:56:44 <Takumo> chrisdone: Gotcha
01:57:55 <ski> Takumo : an alternative is to use `either' / `maybe' or make a pattern-match with `case' or an auxilary function : that way you also specify what to do in the other case
01:59:19 <Cale> Takumo: Yeah, that way of matching is a little bit unsafe, because you'll get an error when you try to use x if the constructor was Left instead of Right. Using a case expression or the functions ski mentioned will let you handle each of the possibilities.
02:00:32 <lpsmith> Hmm, does anybody know of a parser on hackage for HTTP date headers?
02:01:28 <Takumo> Cale: I know that, but I'm in GHCi, so it’s only some testing
02:01:42 <Takumo> in real code I'd check the either / maybe state
02:02:07 --- mode: ChanServ set -q *!*@gateway/web/freenode/ip.50.47.95.15
02:06:02 <chrisdone> someone should make a corebot
02:06:10 <chrisdone> insert a single expression -> receive core
02:08:17 <johnw> haha
02:08:21 <johnw> I read that as co-robot
02:08:27 <johnw> was trying to figure out what was dual to a robot
02:10:15 <arkeet> well, I'm not sure what a rebot is, so I have no hope of figuring out what a corebot is.
02:11:19 <quicksilver> a rebot is a bot which checks regular expressions for you
02:11:32 <quicksilver> a corebot is a bot which generates a regular expression to check you
02:11:35 <quicksilver> soviet-style
02:12:03 <Lethalman> johnw, a human :P
02:38:26 * chrisdone boings
02:45:09 <lintguy> boing?
02:46:24 * hackagebot Graph500 0.4.0 - Graph500 benchmark-related definitions and data set generator.  http://hackage.haskell.org/package/Graph500-0.4.0 (AlexanderVershilov)
02:47:29 <chrisdone> lintguy: boing!
02:50:25 <tdammers> I thought a rebot was a mail auto-replier
02:50:51 <tdammers> so a corebot would be a program that, given an automatic mail reply, would generate the original message
02:56:26 * hackagebot parsec-parsers 0.1.1.1 - Parsing instances for Parsec  http://hackage.haskell.org/package/parsec-parsers-0.1.1.1 (DagOdenhall)
02:56:28 * hackagebot parsec-parsers 0.2 - Parsing instances for Parsec  http://hackage.haskell.org/package/parsec-parsers-0.2 (DagOdenhall)
03:04:15 <Lethalman_> I'm looking for an high performance web server in haskell for I/O file transfer
03:04:20 <Lethalman_> that is for implementing a very simple dav server
03:04:33 <Lethalman_> so I'm looking at scotty or warp
03:04:49 <Lethalman_> do you know any that is particularly efficient for this case?
03:05:06 <tdammers> scotty is built on top of Warp IIRC
03:05:32 <tdammers> so the question is really, does scotty fit your requirements
03:05:51 <Lethalman_> ah
03:05:56 <Ghoul_> this is ridiculous
03:06:00 <Lethalman_> ?
03:06:06 <Ghoul_> when I `cabal install` something, ghci can't pick up the module
03:06:22 <Ghoul_> and regular hs files wont compile with it either, but it's registered!
03:06:22 <Lethalman_> tdammers, once tried scotty but not for intensive file I/O, will try
03:06:27 * hackagebot GraphHammer 0.3 - GraphHammer Haskell graph analyses framework inspired by STINGER.  http://hackage.haskell.org/package/GraphHammer-0.3 (AlexanderVershilov)
03:06:29 * hackagebot parsec-parsers 0.1.1.2 - Parsing instances for Parsec  http://hackage.haskell.org/package/parsec-parsers-0.1.1.2 (DagOdenhall)
03:06:30 <Lethalman_> all the requests are independent of each other
03:06:43 <Lethalman_> need PUT, GET, DELETE, MKCOL, nothing more
03:07:16 <tdammers> I think the first thing to check is whether scotty's routing fits your needs
03:07:30 <tdammers> if it doesn't, you're probably better off coding against warp directly
03:07:36 <Lethalman_> I don't need any routing
03:07:42 <Lethalman_> the plain uri is fine to locate the file
03:09:55 <chrisdone> Ghoul_: did you restart your ghci?
03:11:28 * hackagebot GraphHammer-examples 0.3 - Test harness for TriangleCount analysis.  http://hackage.haskell.org/package/GraphHammer-examples-0.3 (AlexanderVershilov)
03:11:41 <tdammers> Lethalman_: well, routing... request dispatching, rather
03:11:47 <tdammers> you still need to dispatch on method
03:12:03 <tdammers> and I'm not sure whether scotty support all the verbs you need
03:13:54 <Lethalman__> tdammers, right, it doesn't, but I can avoid mkcol
03:14:35 <Lethalman__> tdammers, however, wouldn't using warp directly be the same?
03:14:35 <Lethalman__> dispatching on method should be something like if method request == "GET" ....
03:14:52 <tdammers> I think scotty does it differently
03:15:03 <tdammers> it has a simple eDSL for routing IIRC
03:15:14 <Lethalman__> I only need one handler
03:15:17 <Lethalman__> alright
03:15:23 <Lethalman__> I can probably start off with warp directly, thanks
03:16:37 <Lethalman__> let's try
03:20:12 <johnw> is there a module like Data.Functor.Compose, but for composing monad transformers?  I.e.: https://gist.github.com/7317482
03:20:33 <donri> johnw: mtl :p
03:20:40 <donri> monads don't compose generally
03:21:47 <johnw> well, I have a case here where my type is f (g m) a, but I need to pass it to a function whose type signature is expecting just "m a", which means I need ((f `o` g) m) a, in order to fit the pattern
03:22:03 <johnw> using my TCompose, it works
03:27:57 <ski> i don't see how  m a  would fit  ((f `o` g) m) a  any better than  f (g m) a
03:28:29 <johnw> hmm
03:36:12 <Ghoul_> chrisdone: yes, and my computer a few times
03:36:27 <Ghoul_> and I even nuked my entire cabal ecosystem once and deleted cabal/ and ghc/
03:42:15 <johnw> ski: i misphrased it
03:42:49 <johnw> the function I'm calling receives a monad type parameter t, and passes it on as (t IO), where as I have f (g IO)
03:43:03 <johnw> in order to get my f and g to fit into the "t", I need TCompose f g IO
03:43:08 <johnw> then t ~ TCompose f g
03:49:01 <ski> johnw : *nod*, i suspected something like that
03:58:17 <teneen> what's the difference between -O2 and -optlo-O2?
04:01:05 <johnw> isn't one for GHC and one for the system linker?
04:01:35 * hackagebot cci 0.3.1 - Bindings for the CCI networking library  http://hackage.haskell.org/package/cci-0.3.1 (FacundoDominguez)
04:31:46 <lpaste> f-a pasted “Dynamic woes” at http://lpaste.net/95220
04:32:24 <f-a> unsurprisingly enough, I don't know what to do with this error ^--
04:32:26 <taejo> f-a: nothing to do with Dynamic
04:32:49 <taejo> basically, 0 could be any Num type (Int, Float, etc.)
04:33:06 <taejo> and toDyn doesn't specify (you'd have the same problem with show)
04:33:15 <zebr> this is more of a lambda calculus question, but is there a name for a subrelation of beta-reduction where (\x.m)n -> m iff x not in FV(m)?
04:33:20 <taejo> just change it to (0 :: Int), (0 :: Float), etc.
04:34:15 <f-a> thanks
04:34:44 <ski> zebr : maybe "vacuous beta -conversion / -reduction"
04:34:59 <taejo> f-a: more accurately, 0 could be any type which is both Num and Dynamic, since toDyn requires its argument is Dynamic
04:36:07 <ski> > toDyn (0 :: Word8)
04:36:08 <lambdabot>   <<Word8>>
04:37:00 <general-general> 4h5t5 r9.0p]
04:39:10 <general-general> Daughter (3) just typed that.
04:46:02 <donri> already a perl programmer!
04:49:56 <zebr> lol
04:54:57 <mario27> Hi, I have 2 functions (String -> String -> String), func1 should call func2 n times with the first paramter beeing constant and the second paramter beeing the previous result. n is the length of the first parameter a. Something like: func1 a b = func2 a (func2 a (func 2 a b)) in case a has the length 3. Any suggestions how to do that?
04:56:02 <taejo> mario27: rather than thinking of calling func2 with one constant and one changing argument, think of it as calling (func2 a) with a changing argument
04:56:17 <taejo> > iterate f a
04:56:18 <lambdabot>   [a,f a,f (f a),f (f (f a)),f (f (f (f a))),f (f (f (f (f a)))),f (f (f (f (...
04:56:22 <taejo> and that ^
04:57:00 <oio_> when trying to update with cabal i get this?
04:57:12 <oio_> ghc: could not execute: /usr/local/bin/clang-xcode5-wrapper
04:57:18 <oio_> https://github.com/ghc-ios/ghc-ios-scripts/blob/master/clang-xcode5-wrapper.hs
04:58:00 <johnw> it fits the pattern of a right-fold: a `func2` a `func2` a `func2` b, or foldr func2 b [a,a,a], or foldr func2 b (replicate 3 a)
04:59:13 <taejo> johnw: that's true. I was thinking of func1 a = (!! 3) . iterate (func2 a)
05:00:19 <mario27> I'm slightly confused :D But thanks, I'll try that
05:00:52 <johnw> one difference between the two is if func2 is lazy in its second argument
05:01:15 <johnw> but maybe iterate is sufficiently lazy too...
05:01:28 <taejo> johnw: iterate is completely lazy
05:01:43 <johnw> ok, that works then
05:02:19 <taejo> mario27: iterate computes a list where the function is applied to its argument 0 times, then once, then twice, ...
05:03:02 <mr-> > iterate (+1) 0
05:03:03 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:46:01 <tomejaguar> Is there an easy way to compress the data produced by Data.Binary, using run length encoding or something+
05:47:04 <khyperia> is it possible to make lambdabot perform an IO action? Specifically, getStdRandom?
05:48:10 <khyperia> > getStdRandom random :: IO Float
05:48:12 <lambdabot>   <IO Float>
05:48:29 <quicksilver> no, khyperia
05:48:43 <khyperia> Aww.
05:50:10 <sbidin`> > head $ randoms $ mkStdGen 235534 :: Int
05:50:11 <lambdabot>   -1005382421
05:50:22 <sbidin`> But it's just not the same...
05:58:14 <bz> how to take the cartesian product of two tuples?
06:00:47 <triliyn> bz: you can't do it fully generally; each tuple size is its own type and there's not really  a way to work generically with them
06:01:53 * hackagebot parallel 3.2.0.4 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.2.0.4 (HerbertValerioRiedel)
06:12:27 <pamojarpan> I've made this in haskell: http://lpaste.net/95221, any comment to improve this code?
06:12:31 <vijaykiran> How do I see if 'a' has a type class "Blah" e.g., something Int => Integral
06:12:53 <Iceland_jack> vijaykiran: :info
06:13:17 <vijaykiran> Iceland_jack: fantastic, thanks!
06:17:50 <bartavelle> pamojarpan, at first sight I'd say the Show instances are not great, as (in my view, might be wrong) Show is about "human readable serialization". Also it is not great that you have to write a type synonym instance for showing a list
06:18:23 <bartavelle> as for parseTask, if you used "Text" and would be ok with a type "Text -> Maybe Task", you could have it like that :
06:19:31 <bartavelle> parseTask t = (NotDone <$> T.stripPrefix t "[ ]") <|> (Started <$> T.stripPrefix t "[-]") <|> (Done <$> T.stripPrefix t "[ ]")
06:19:45 <bartavelle> (and it could be nicer by factoring the (x <$> T.stripPrefix t y) )
06:20:13 <pamojarpan> bartavelle: thank you very much :)
06:21:44 <pamojarpan> about Show instances, the idea is to provide a human readable serialization for Tasks and TaskLists
06:22:19 <bartavelle> then it is nice, but I do not think this plays well with other types
06:22:41 <bartavelle> what if there are '\n' in the task name ?
06:23:36 <bartavelle> OTO this might be a perfectly legitimate policy, I am not sure about how Show instances are supposed to work, but I always think they should work with Read instances
06:23:37 <pamojarpan> about the type synomym instance, I felt weird doing that. In fact, I needed a language extension to allow it. Is TypeSynonymInstances not well considered? And language extensions? (I'm a noob in Haskell)
06:24:05 <bartavelle> well, what I meant is that you could have a "showTaskList" function, instead of a Show instance
06:24:18 <bartavelle> perhaps what's more appropriate would be a Pretty instance
06:24:26 <bartavelle> as Pretty is for human consumption only ...
06:24:36 <Iceland_jack> pamojarpan: You shouldn't derive Show instance for a type synomym
06:24:41 <Iceland_jack> You should use newtype
06:25:04 <Iceland_jack> Also Show is not intended for pretty printing
06:25:22 <Iceland_jack> but you can use it for pretty printing while you're starting out
06:26:16 <Iceland_jack> pamojarpan: If I want my own Show instance for Int's I would do:
06:26:16 <Iceland_jack>     newtype MyInt = MyInt Int
06:26:16 <Iceland_jack>     instance Show MyInt where show (MyInt n) = "This is my Int: " ++ show n
06:26:43 <Iceland_jack> You could just as well use ‘data’ instead of newtype but it would be more expensive.
06:27:26 <pamojarpan> Iceland_jack: what's the different between a typesynonym and a a newtype?
06:27:55 <pamojarpan> Iceland_jack: this may be a too newbie question, sorry for that
06:27:56 <Iceland_jack> pamojarpan: A type synomym is just that, a synomym
06:28:00 <bartavelle> a newtype can't be used in place of the original type
06:28:14 <pamojarpan> bartavelle: I see
06:28:23 <Iceland_jack> defining 'type MyInt = Int' would make MyInt exactly the same as Int
06:28:46 <Iceland_jack> just with a different name, that's why you shouldn't define instances on type synonyms since they'd clash with the original type
06:29:02 <Iceland_jack> newtype and data create *new* datatypes however
06:29:40 <mauke> @quote mauke newtype
06:30:27 <mauke> preflex: seen elliott
06:30:28 <preflex>  elliott was last seen on #haskell 16 hours, 17 minutes and 38 seconds ago, saying: acc is more what you call a parameter to go
06:30:41 <pamojarpan> bartavelle:  I'll look for the difference between "data" and "newtype"
06:30:48 <bartavelle> the difference between "data X = X Int" and "newtype X = X Int" is that the newtype is cheaper in term of execution speed (it *should* be the same as not using the newtype, except in some cases I did not understand)
06:31:00 <pamojarpan> bartavelle: is there a Pretty typeclass? Where is it defined?
06:31:24 <bartavelle> I use this one as it has colors : http://hackage.haskell.org/package/ansi-wl-pprint
06:31:40 <bartavelle> You'll want to use OverloadedStrings though
06:31:51 <khyperia> bartavelle, isn't newtype completely eliminated during compiletime and it behaves at runtime exactly like the underlying type, but with typechecking it's not compatible?
06:32:17 <khyperia> and data creates a structure surrounding the underlying type
06:32:33 <pamojarpan> khyperia, bartavelle: http://www.haskell.org/haskellwiki/Newtype
06:32:36 <Peaker> bartavelle, khyperia: newtypes still cost you when you have to use:  map SomeNewType  and at runtime that becomes   "map id"    and this cost is not eliminated (though 7.8 is supposed to help with that)
06:32:56 <bartavelle> Peaker, is that the only problem ?
06:32:59 <Iceland_jack> That's probably way too much detail for a new user
06:33:51 <Peaker> bartavelle: well, "map id" is an example, I guess where-ever you use a Newtype constructor/deconstructor as a function that degenerates to "id" at runtime, there may be overhead around it that's not eliminated
06:34:26 <bartavelle> I saw some long comment by ekmett explaining why he used unsafeCoerce, and that was the reason, can't find it though
06:35:02 <edwardk> Foo . f    becomes \x -> f x
06:35:07 <edwardk> not f
06:35:21 <bartavelle> ah :)
06:35:32 <edwardk> so it differs in its behavior when f is _|_ and could be forced, but also you get to accumulate those wrappers if you write something like
06:35:44 <pamojarpan> Iceland_jack: it is, but I like to read about this
06:35:48 <edwardk> map f (x:xs) = f x : map (\y -> f y) xs
06:36:08 <edwardk> that sounds silly, but thats precisely what the old code for DeriveFunctor did
06:40:07 <pamojarpan> to resume, newtype and data are almost the same but it can perform better due to the reduction of some operation to to "id". Am I right?
06:40:16 <iLike> Hm, how do I user the NOT IN operator (/<-.) from Database.Persist?
06:40:40 <Iceland_jack> pamojarpan: If you only need a single argument you can get away with using newtype
06:41:03 <Iceland_jack> but you're probably better off just searching for 'type newtype data' and you should find a bajillion discussions about exactly this :)
06:41:07 <Peaker> pamojarpan: it's not just about performance, a newtype is isomorphic/equivalent to the wrapped type.  a "data" wrapper adds an extra indirection around it which adds another "bottom" value that did not exist in the original type
06:41:41 <Peaker> so "data" is not equivalent to the original data in terms of possible values/states
06:42:13 <tomejaguar> In fact that the whole point for the existence of newtype.
06:42:40 <Peaker> tomejaguar: both performance and equivalence along with new instances attached are the point
06:44:02 <tomejaguar> Surely in a strict language newtype would not exist, since 'data A = A B' could have the constructor optimized away automatically.
06:44:50 <Iceland_jack> tomejaguar: They might exist to make it more explicit that you want the constructor optimized away but it would be a design choice
06:44:53 <haasn> newtypes have differing semantics
06:45:01 <haasn> > case undefined of Identity _ -> ()
06:45:02 <tomejaguar> Iceland_jack: arguably.
06:45:09 <haasn> > case undefined of Just _ -> ()
06:45:34 <haasn> lambdabot?
06:45:42 <haasn> Anyway, the first one is (), the second one is Exception: undefined
06:47:13 <bartavelle> pamojarpan, also you should store your tasklist in an IntMap or a Vector, so that you don't need the 'maskTask' function
06:49:45 <pamojarpan> haasn: understood, good example. Thanks!
06:50:00 <tomejaguar> Is there a Data.Binary instance for Data.Time.Calendar.Day?
06:51:23 <tomejaguar> bartavelle: One of the uses of unsafeCoerce is in Data.Profunctor
06:51:54 <haasn> pamojarpan: (the performance difference is only a side effect of this semantic change, since there's no difference between Identity ⊥ and ⊥, the compiler/runtime doesn't have to check for the presence of the constructor when pattern matching. Similarly, you don't have to store it in memory, since there's only one possibility)
06:52:50 <danr> jaspervdj: ping? I see that spawnPingThread was removed in websockets 0.8.0.0, do I need to build an own, or is it unnecessary?
06:54:23 <pamojarpan> bartavelle: I knew that, I have to change my code. :)
06:54:51 <bartavelle> ok !
06:57:00 <pamojarpan> haasn: a simplification could be like "newtype" vs "data" is like "primitive type" vs "object type" in Java?
06:57:07 <haasn> I have no idea.
06:57:25 <haasn> but ‘primitive type’ sounds more like ‘primitive type’ (in Haskell)
06:57:52 <haasn> I doubt newtypes have anything to do with it
06:59:38 <tomejaguar> I think if I was designing Haskell I wouldn't have added 'newtype'.  It seems that 'data A = A !Foo' does what is required and should be able to optimize in the same way.
07:02:31 <haasn> afaik newtype was introduced way before strict fields
07:02:48 <haasn> (are strict fields in Haskell 98?)
07:02:56 <frx> tomejaguar was ! a typo or does it have some specific meaning?
07:03:19 <haasn> tomejaguar: actually, that's not the same thing. See: my example above
07:03:42 <bartavelle> frx, with -XBangPatterns, it lets you declare some fields as strict
07:03:49 <Peaker> tomejaguar: http://www.haskell.org/haskellwiki/Newtype shows they behave differently.   And they have to, for the semantics of "!" in data to make sense, I think
07:03:56 <mauke> bartavelle: I don't think you need BangPatterns
07:04:16 <bartavelle> it would be by default for data constructors ?
07:04:22 <haasn> Also note that ‘Identity undefined’ is completely valid, with newtypes. Unlike ‘A undefined’
07:04:36 <bartavelle> mauke, yup, you don't need it
07:04:38 <dEPy> hi all
07:04:52 <tomejaguar> Actually I think that wiki page is misleading.  'data A = A !Foo' has exactly the same inhabitants as 'Foo'.  Syntactically they look somewhat different, but they're not.
07:05:23 <dEPy> I've installed haskell platform package on macos, now when trying 'cabal update' it says there's a newer version, if I do cabal install cabal-install all goes well but version of cabal doesn't change
07:05:31 <Peaker> tomejaguar: Note the actual code examples and differing output
07:05:51 <bartavelle> dEPy, check if ~/.cabal/bin/ is in your path
07:06:12 <Peaker> tomejaguar: pattern matching a newtype is a no-op. Pattern-matching a "data" is forcing the strict fields
07:06:15 <bartavelle> dEPy, you can start by typing "which cabal"
07:06:19 <tomejaguar> I agree that 'newtype A = A Foo' doesn't behave the same way as 'data A = A !Foo', but that's not what I am claiming.  I am claiming they are isomorphic.
07:06:59 <dEPy> it's using cabal in /usr/bin/caba
07:07:02 <dEPy> cabla*
07:07:06 <dEPy> cabal*
07:07:09 <dEPy> damn :)
07:07:12 <tomejaguar> Peaker: Right, for a newtype 'case A _ -> ...' is the same as 'case _ -> ...' for the strict data field.  But the 'A' was redundant anyway.
07:07:31 <dEPy> and there's no bin directory in ~/.cabal/
07:07:48 <tomejaguar> I'm saying that if 'newtype' didn't exist we could still simulate it with 'data' and '!'
07:07:51 <bartavelle> dEPy, then I do not know where it installs binaries ...
07:08:06 <tomejaguar> The syntax would be slightly different
07:09:23 <dEPy> The other question is, when adding proper path to my $PATH should/could I delete cabal in /usr/bin or will it use one from $PATH first?
07:09:54 <tomejaguar> frx: ! means that the constructor argument is evaluated strictly.
07:15:16 <owo> how can i know if overloadedstrngs is working
07:15:32 <pamojarpan> tomejaguar: and what about data A = A {-# UNPACK #-} !Int?
07:16:15 <scottj> For simple http/json requests to an api, what libraries should I be looking to use?
07:16:34 <tomejaguar> pamojarpan: That sounds like it would be even better :)
07:16:58 <tomejaguar> owo: What do you mean working?
07:17:02 <pamojarpan> scottj: https://github.com/xich/scotty?
07:17:22 <pamojarpan> scottj: I haven't made any haskell web app, but I'll do pretty soon. I'll may use scotty
07:17:28 <scottj> oh sorry, for making http requests, and parsing the json response
07:17:50 <pamojarpan> scottj: I missunderstood you
07:18:19 <scottj> pamojarpan: I'm glad to have the link anyway :)
07:19:31 <scottj> I've heard good things about aeson, should I use the built-in http package or is there something considered easier/simpler?
07:23:00 <tdammers> scottj: you could roll HTTP requests by hand, but there are a few things that you really want to have covered, so...
07:26:33 <bz> if i can iterate over a tuple, what should i do if i have a data type that is isomorphic to a fixed length list?
07:26:42 <Kron> I have a friend who is reasonably new to ML languages and wants a theorem prover for some bonus assignments in his university. Coq or Agda or Idris or others, he's not sure which is the best language for him
07:26:44 <Kron> he's using Ocaml
07:26:53 <Kron> I'm not sure what to recommend to him, I don't know any of these
07:27:13 <bz> type MyType a = [a] is too lax because there could be instances of MyType that aren't the correct length
07:27:41 <Kron> a newtype?
07:27:49 <Kron> you could use a newtype that would generate runtime errors if the length is wrong
07:28:14 <bz> yeah but then i wouldn't be able to iterate over the members of the newtype
07:28:16 <moops> bz: dependent types ;)
07:28:23 <miniBill> @list
07:28:31 <Xenasis> Which languages is the easiest proof assistant for a beginner? Coq, Agda, Idris, or something I've not heard of yet?
07:28:35 <Xenasis> -s
07:28:36 <miniBill> uh, is there lambdabot?
07:28:51 <Kron> you just create your own constructor that checks if the length is N and if not signal an error
07:28:57 <Kron> otherwise yeah, dependent types
07:30:15 <moops> agda is more like a regular FP language vs coq
07:30:21 <moops> based on my cursory understanding
07:30:35 <Kron> what do you mean by "FP"?
07:30:41 <Xenasis> Functional Programming I think
07:30:43 <Xenasis> I googled it :P
07:30:52 <moops> more like a regular programming language
07:31:01 <triliyn> bz: in haskell you can use type-level natural numbers
07:31:07 <Xenasis> Alright, so Agda would be easier to learn over Coq?
07:31:07 <moops> coq code looks indecipherable to me
07:31:13 <Xenasis> yeah
07:31:17 <Xenasis> you can say that again
07:31:40 <Kron> actually hold up can't you just use a large tuple?
07:31:43 <bz> triliyn: could you elaborate a bit?
07:31:48 <Kron> (a, a, a, a, a, a)
07:31:51 <Kron> that sorta thing
07:31:52 <Philonous> Xenasis, I found Coq fairly easy to learn, especially because of http://www.cis.upenn.edu/~bcpierce/sf/
07:31:52 <bz> Kron: can't iterate that
07:32:05 <Kron> you could make your own iterater I think...
07:32:26 <moops> coq might actually be the easiest due to its differentness
07:32:26 <bz> :(
07:32:34 <triliyn> bz: there are more in-depth explanations in various places, but basically, data Nat; data Succ a
07:32:41 <triliyn> er, I mean
07:32:46 <triliyn> data Zero; data Succ a
07:32:56 <Philonous> Xenasis, That's not only a coq tutorial (and a pretty good one at that) but an "interactive" book about languages and semantics
07:33:04 <Xenasis> Hmmm
07:33:07 <Xenasis> I see
07:33:07 <triliyn> I guess you also kind of need type families for this
07:33:29 <triliyn> And without datakinds your type-functions are unkinded
07:33:44 <Ankhers> Does anyone know where the new HP stands?
07:33:48 <triliyn> actually no, you don't really need type families for the basic stuff
07:34:01 <Xenasis> So the consensus so far is Coq because it has a better tutorial?
07:34:02 <bz> https://gist.github.com/bryant/7320695 <- this is what i'm trying to clean up
07:34:15 <Philonous> Xenasis, It's amazing that it's free.
07:34:27 <triliyn> fixedLengthCons :: a -> LengthList n a -> LengthList (Succ n) a
07:34:36 <triliyn> fixedLengthTail :: a -> LengthList (Succ n) a -> LengthList n a
07:34:51 <Xenasis> alright
07:34:56 <bz> god i should put a disclaimer on that code
07:35:08 <Xenasis> Are there any other proof assistants I should know about?
07:35:15 <Xenasis> I know it's a niche thing to say the least
07:35:20 <moops> epigram?
07:35:33 <Iceland_jack> Agda if it hasn't been mentioned before
07:35:39 <Kron> mate :: Genotype -> Genotype -> Poss
07:35:42 <Xenasis> It has
07:35:46 <Kron> now I'm curious o_o
07:35:47 <Xenasis> Epigram hasn't
07:35:51 <Philonous> Xenasis, Isabelle, but I only know it by name
07:35:51 <Kron> are you creating a mutant army?
07:36:03 <bz> simulating mendelian genetics, actually
07:36:17 <Kron> suuuure. Mendelian genetics.
07:36:19 * Kron winks
07:36:30 <Xenasis> I think I might give Coq a whirl later once I've wrote out this structural induction assignment
07:36:33 * Kron hums the 'we are the mutant race' from the mighty boosh
07:36:49 <bz> pretty simplifiable if data Poss = [Double] but then i couldn't get the type system to ensure that Poss is length 3
07:37:01 <Xenasis> Might pop back in later, though it'd be a relative waste staying - this is for OCaml, not Haskell, but you guys are friendlier and larger in number <3
07:37:12 <Xenasis> (I do not (yet) know Haskell)
07:37:15 <Kron> prudent :P
07:37:27 * Xenasis waves
07:37:39 <Philonous> Xenasis, btw. software foundations is really great, even if you don't want to stay with Coq
07:38:18 <Kron> I think he's gone
07:38:26 <Kron> though I do know him so I can always ferry him final remarks
07:38:44 <Lethalman> bz, you can use some hackage that has fixed length lists
07:38:54 <Lethalman> bz, like fixed-list or Vec
07:38:57 <Lethalman> never used them though
07:39:10 <bz> Lethalman: hackage.haskell.org/package/fixed-list‎
07:39:13 <bz>  this?
07:39:19 <bz> ah, o
07:39:31 <Lethalman> eh
07:40:52 <Lethalman> bz, yes, the length is encoded in the type, yet there are convenient functions to work with them like for lists
07:42:21 <Lethalman> bz, see them like something in the middle between tuples and lists
07:42:28 <Fuuzetsu> Why are so many recent Haddock docs missing on Hackage for recent package versions?
07:42:35 <Fuuzetsu> It's incredibly annoying.
07:42:39 <Lethalman> Fuuzetsu, yet to be built
07:43:35 <Fuuzetsu> Elaborate on this. Surely it's not waiting in automated queue for 2 weeks. Do you have some kind of blocking bug going on?
07:44:15 <Lethalman> Fuuzetsu, 2 weeks maybe there's something wrong with the package
07:45:25 <Fuuzetsu> Looking at GLFW-b at the moment but it's certainly not the first package I have recently encountered with missing docs.
07:46:07 <Fuuzetsu> And IIRC the build log links aren't provided to public.
07:51:46 <jophish_> Yo yo yo
07:53:28 <jophish_> http://lpaste.net/95223
07:53:39 <jophish_> I don't quite understand the type errors I'm getting here
07:53:46 <jophish_> Haskell seems to wants Int
07:53:47 <chrisdone> > unwords $ repeat "yo"
07:54:04 <jophish_> the type of pBits is [Word64]
07:54:09 <Fuuzetsu> jophish_: it helps if you post the error as well
07:54:15 <geekosaur> shiftL and shiftR it shift counts are Int not Word*
07:54:19 <jophish_> chrisdone: :)
07:54:21 <geekosaur> *bit shift counts
07:54:24 <chrisdone> Fuuzetsu: for some reason that made me giggle
07:54:25 <jophish_> geekosaur: ah, thanks
07:54:26 <geekosaur> :t shiftL
07:54:33 <jaspervdj> danr: You probably want to build your own
07:54:36 <geekosaur> beh, did the bot die?
07:54:57 <chrisdone> *** lambdabot (lambdabot@2a01:7e00::f03c:91ff:fedf:9fdd) has quit: Ping timeout: 246 seconds
07:55:07 <geekosaur> sigh
07:55:37 <dEPy> anyone can help me install yesod with cabal?  It's failing -> https://gist.github.com/depy/7321076
07:55:59 <geekosaur> dEPy, see the end of the /topic
07:56:23 <geekosaur> that's the xcode 5 cpp being all "hey this Haskell code doesn't look like ANSI C!"
07:56:37 <geekosaur> (alternately same issue on some other platform that has clang but not gcc)
07:56:40 <dEPy> ...
07:57:07 <dEPy> next time anyone says macs just work and are magical and all I'm gonna punch someone in the face
07:57:33 <geekosaur> often they are. but there's usually a pain point of some kind after a major upgrade (10.9 and xcode 5)
07:57:34 <chrisdone> dEPy: preferably a mac user
07:58:18 <geekosaur> considering how often I've had a linux installation "upgrade" turn out to be "shred itself"...
07:58:41 <dEPy> I mean, every stupid update on my mac breaks things
07:59:00 <dEPy> last big update had me reinstall postgresql and nearly half of my dev env :/
07:59:22 <Fuuzetsu> dEPy: b-but shiny!
07:59:24 <dEPy> I guess the safe thing will be to always stay on update number #N-1 :)
07:59:39 <danr> jaspervdj: thanks
07:59:57 <dEPy> Fuuzetsu: but ofcourse :)
07:59:59 <chrisdone> dEPy: speak to johnw, his os x setup is smooth
08:00:15 <Gothmog_> is there a functional data structure supporting : and !! in (amortized) constant time?
08:00:30 <danr> jaspervdj: I don't understand the documentation for `runServer': "... you should use a real server", however there is no other function to choose from that servers websockets. What do you mean here?
08:00:40 <dEPy> gonna try that stuff in topic first
08:01:38 <geekosaur> (also a lot of the pain in OS X is exactly in the installing third party stuff area; why would Apple give a shrill hoot about macports/fink/homebrew/mono/whatever? this is not fedora or debian where anything you might want probably has a *vendor*-supported package already)
08:04:38 <chrisdone> geekosaur: that's why i have two macs http://i.imgur.com/sl38WeG.jpg and put linux on both of them =p
08:06:03 <Ankhers> chrisdone: Are you installing linux as the base OS, or are you doing a bootcamp trick?
08:06:51 <chrisdone> Ankhers: base os. dualboot on the retina, solo on the older macbook
08:06:59 <Lethalman> where can I read how ghc copies values?
08:07:15 <Lethalman> is it copy on write or whatelse?
08:07:34 <Flonk> I'm newtyping [a], do I now have to redefine instances for Functor/Applicative/Monad for my datatype if I want to use them?
08:07:37 <Lethalman> does it create differences between objects like foo { bar = baz }
08:07:54 <Lethalman> Flonk, yes afaik
08:07:54 <chrisdone> why would it copy on write?
08:08:09 <Lethalman> chrisdone, let a = b, what's in a? a copy? the same object pointer or what
08:08:27 <chrisdone> i think that depends on what's being done
08:08:32 <Flonk> Lethalman: Okay, thanks..
08:08:34 <Lethalman> chrisdone, that's exactly what I'm asking
08:08:42 <Lethalman> where can I read about how ghc handles assignment/copies of values
08:08:52 <Lethalman> I've read stg but didn't say much about this argument
08:09:10 <chrisdone> sure, at stg it's still just a system fc with glitter on it
08:09:36 <owo_> can i cross compile to window?
08:09:39 <chrisdone> i think this is a runtime issue so you can check the docs on the runtime
08:09:48 <Kron> all I know is that there's this mysterious thing called 'sharing'
08:09:49 <Lethalman> chrisdone, yes, and I'm asking where can I read about that :P
08:09:53 <Kron> ghc rarely if ever actually copies anything
08:10:01 <Lethalman> if you have any pointers
08:10:01 <chrisdone> Flonk: you can just do deriving (X,Y,Z)
08:10:06 <Kron> it just links the new names to the old stuff behind the scenes
08:10:12 <chrisdone> Lethalman: oh. it's on the ghc wiki, hold up
08:10:17 <Kron> since you can't mutate anything, there's rarely a need to copy anything
08:10:25 <Flonk> chrisdone: deriving Monad is a thing?
08:10:31 <chrisdone> Lethalman: http://ghc.haskell.org/trac/ghc/wiki/Commentary
08:10:37 <Lethalman> yes, that's big
08:10:39 <Kron> so if you have a list that's like... x = [1,2,3] and you make a new list that's y = 0 : x
08:10:43 <chrisdone> Flonk: yes, if the type in the newtype is a monad
08:10:47 <Kron> then y will literally point to a 0 and then x in memory
08:10:51 <Lethalman> where... more precisely :P
08:10:53 <triliyn> chrisdone: don't you need an extension for that?
08:10:57 <chrisdone> Flonk: e.g. newtype Myidentity = MyIdentity Identity deriving Monad
08:11:06 <chrisdone> triliyn: yeah, GeneralizedNewtypeDeriving
08:11:15 <Flonk> chrisdone: That's great, exactly what I needed. Thanks!
08:11:28 <chrisdone> Lethalman: the runtime part?
08:11:37 <Lethalman> chrisdone, again, how ghc handles assignment/copying values
08:11:46 <owo_> can i cross compile to window from OS X?
08:12:09 <chrisdone> http://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
08:13:06 <geekosaur> owo_: cross compiling in general is still quite new and quite limited
08:13:36 <geekosaur> some people have played with x86->arm cross compile; anithing else is untested. all crosscompiles require both llvm and decent knowledge of llvm internals, as I understand it
08:13:43 <owo_> geeksaur: then i guess will need a VM
08:13:47 <geekosaur> so, "no"
08:13:59 <Lethalman> chrisdone, not what I've asked
08:14:07 <Lethalman> chrisdone, that's how objects are represented, not how and when they are copied
08:15:05 <jaspervdj> danr: You're supposed to run it using e.g. `websockets-snap` in production
08:15:24 <Lethalman> have to ask stackoverflow
08:15:39 <jaspervdj> danr: I want to write/update websockets-wai soon but I've been busy at work
08:16:51 <danr> jaspervdj: nice. thanks for the info, and thanks for developing and maintaining websockets. I really like the 0.8.0.0 release
08:17:02 <chrisdone> Lethalman: it might be helpful to see how they're presented, tho
08:17:09 <Lethalman> chrisdone, I've read that already
08:17:21 <Ankhers> Does anyone know where the new platform stands?
08:17:26 <Lethalman> chrisdone, since haskell is mostly about copying
08:17:39 <Lethalman> for example, adding a new tree to an existing tree
08:17:43 <Lethalman> will copy most of the existing tree
08:17:49 <Lethalman> and I'm interested on how ghc copes with that
08:17:56 <thirsteh_> Does anyone have a guide for compiling any of the PCRE libs on Windows (x64)?
08:18:01 <chrisdone> Lethalman: why will it copy most of the existing tree?
08:18:11 <geekosaur> Ankhers, it's still trying to figure out a way to deal with xcode 5 that doesn't involve either an unreleased/not fully tested ghc or weordshit that will have to be undone on the next HP release
08:18:16 <Lethalman> chrisdone, let a = addNewNode b
08:18:28 <Lethalman> a and b should be different no? that's a copy from a user perspective
08:18:40 <Lethalman> I don't know whether ghc really copies, or uses some kind of pointers, or whatelse
08:18:45 <Lethalman> and that's what I'm asking for
08:18:46 <jaspervdj> danr: thanks, glad you like it!
08:18:47 <Lethalman> for the nth time :)
08:19:07 <Kron> Lethalman: it uses pointers almost always
08:19:10 <chrisdone> Lethalman: sure, you're just assuming it copies anything despite the memory model clearly using pointers
08:19:10 <Kron> as far as I understand
08:19:24 <asmyers> Lethalman: That's up to the implementation of the data structure.  Most will do path copying.
08:19:24 <Lethalman> chrisdone, I assumed _nothing_, I'm looking for the implementation
08:19:26 <Kron> since everything is immutable there's a lot of memory sharing between things
08:19:30 <Lethalman> oh man
08:19:36 <Lethalman> _i'm looking for the implementation_
08:19:40 <Lethalman> where can I read about that
08:19:43 <Lethalman> except the code
08:19:58 <Lethalman> asmyers, yes, where's the implementation explained somewhere in the commentary?
08:20:11 <Lethalman> I can't explain myself probably
08:20:14 <Ankhers> geekosaur: Is there any sort of ETA? I would just really like for it to be out by this weekend.
08:20:15 <asmyers> Lethalman: The implementation of what?  That's going to depend on the data structure
08:20:37 <asmyers> Lethalman: For a tree you do path copying, for a list you don't have to copy anything for (:) but may to change the middle of the list
08:20:39 <Lethalman> asmyers, what ghc does if you do for example somestruct { field = newvalue }
08:20:41 <asmyers> Lethalman: etc.
08:20:50 <asmyers> Lethalman: Copies the spine of the struct
08:20:58 <asmyers> modulo the changed field
08:21:09 <Lethalman> asmyers, ok, where can I read about what it does exactly other than your chat :)
08:21:10 <geekosaur> I haven't seen an ETA for final release, no. would not bet on it being this weekend
08:21:20 <asmyers> Lethalman:  No idea :p
08:21:26 <Lethalman> asmyers, thanks, that was the answer
08:21:43 <cschneid> how stable is ghc 7.8 at this point?
08:22:05 <Ankhers> well damn.
08:22:08 <asmyers> Lethalman: np, A GHC dev may know the answer to your where question
08:22:18 <asmyers> Lethalman: Also, copying the spine is a bunch of pointer copies
08:22:42 <asmyers> Lethalman: well, I suppose unless things are {-# UNPACK #-}'ed
08:22:58 <chrisdone> there's the #ghc channel
08:23:15 <Lethalman> chrisdone, right will ask there
08:23:29 <Ankhers> I thought 7.8 had all the xcode5 issues resolved?
08:23:36 <satc> I have a class A x and class A x => B x, Now I want to define function which behaves differently depending on if it belongs to B or just A. So for example I have a class C x and instance A x => C x and instance B x => C x. Does overlapping instances help here?
08:30:09 <rasfar> When you're in a "do" block, what's the idiom for "if predicate then error" (with vacuous else clause)? I use putStr "" for the else in IO, but obviously that's silly.
08:30:51 <Lethalman> :t error
08:30:59 <jophish_> Which arrow operator will apply a function to both elements of a pair?
08:31:02 <rasfar> yes, but I still need an else clause!
08:31:08 <Lethalman> ah no lambdabot
08:31:27 <Mon_Ouie> rasfar: If you want to do nothing you can return ()
08:31:36 <rasfar> not ready to return yet!
08:31:51 <rasfar> (thanks for the suggestions though folks)
08:32:16 <Mon_Ouie> You do understand return is nothing like what it is in most imperative languages?
08:32:17 <rasfar> this is near the top of main, testing the config is consistent
08:32:47 <rasfar> so I can, inside the main do block, go "if predicate then error "blah" else return ()" ?
08:32:51 <geekosaur> rasfar, return isn't what you think it is
08:32:52 <rasfar> and still be in main
08:32:56 <geekosaur> yes.
08:33:15 <rasfar> but return brings me out of a monad, no? and I am still in it
08:33:20 <geekosaur> no
08:33:23 <rasfar> okay...
08:33:24 <geekosaur> return pulls a value into the monad
08:33:56 <geekosaur> since often the last thing you do in a modatic expression is pull a pure value into the monad, to that extent it resembles inmperative return
08:34:08 <rasfar> yeesh, i ought to know this. all i can say in my defense is, long hiatuses between use of Haskell...
08:34:11 <geekosaur> but return is not control flow in haskell, it only pulls a pure value into a monad
08:34:35 <rasfar> okay i'll test that instead of putStr ""
08:35:05 <blueonyx> @hoogle putStr
08:35:20 <geekosaur> bot's dead :(
08:35:21 <dEPy> ok loooks like now yesod installed but when I type yesod in cmd i tells e there's no such command O_o
08:35:22 <rasfar> well how about that
08:35:35 <dEPy> oh wait I need yesod-bin for that?
08:35:42 <geekosaur> dEPy, is ~/Library/Haskell/bin in $PATH?
08:36:41 <geekosaur> (you can't even blame OS X for this one, cabal always installs to a cabal-specific bin directory, ~/.cabal/bin on unix, ~/Library/Haskell/bin on most OS X, don't know offhand the right dir on windows)
08:38:25 <Lethalman> > "in the while"
08:38:31 <lambdaone>   "in the while"
08:38:38 <Lethalman> eeek a little heavy load
08:38:40 <Lethalman> :t error
08:38:40 <lambdaone> [Char] -> a
08:39:02 <Lethalman> hope it doesn't bother you guys, for one hour it can stay here :)
08:41:17 <dEPy> geekosaur: it is, but there's no yesod in there
08:42:11 <chrisdone> Lethalman: i think foo { bar = mu } is faithfully implemented by Foo x1 x2 mu where x1 and x2 are the fields of foo. given that most everything is thunks and thunks are pointers, this'll only make a new constructor. even Ints are boxed (indirected by a pointer)
08:42:42 <chrisdone> Lethalman: and given that core/STG don't have anything about record fields, i'd expect that that transofmration is accurate
08:43:25 <Lethalman_> chrisdone, makes sense, then what happens when strictness is required
08:43:35 <Lethalman_> > "still here"
08:43:41 <Lethalman_> sigh dc
08:45:49 <chrisdone> Lethalman: i think strict fields are more or less equiv to making the constructor force the fields, only. so data X = X !Int is equivalent to data X = X Int where X_ y = let !y' = y in X y
08:46:33 <Lethalman_> chrisdone, ok, you think, but I'd like some document to read :)
08:46:34 <chrisdone> Lethalman: the strict fields will still be boxed. that's why you explicitly need funbox-strict-fields. in that case, i'm not sure what would happen in the copying. presumably it would just copy the unboxed value, but i'd have to check the source
08:47:46 <dEPy> There's no  bin directory in my  ~/.cabal   how come ?
08:48:15 <chrisdone> dEPy: what is in there?
08:48:29 <dEPy> config and config.platform
08:48:32 <k12kl> Hi, i need some help to make a function which zips every first, second, third, ... etc member of a list of lists.
08:48:40 <geekosaur> dEPy because HP on OS X uses ~/Library/Haskell
08:48:41 <k12kl> can anyone give me some insight on how to do it?
08:48:51 <geekosaur> and you'll see the redirects for that in ~/.cabal/config
08:49:11 <dEPy> so yesod should be in ~/Library/Haskell ? cause it's not
08:49:16 <fizruk> k12kl, transpose?
08:49:22 <geekosaur> ~/Library/Haskell/bin as I said earlier
08:49:28 <dEPy> yes, it's not there
08:49:32 <fizruk> > transpose [[1, 2], [3, 4], [5, 6]]
08:49:32 <lambdatwo>   [[1,3,5],[2,4,6]]
08:49:41 <dEPy> and 'which yesod' doesn't find it
08:50:01 <Ankhers> DEPy: Did yesod actually build?
08:50:03 <geekosaur> (unless they moved the bin dir again, or cabal-install is still stmetimes doing the dumb thing and using a per-package bin dir without making a symlink into the main one for some reason)
08:50:04 <dEPy> ah wait..
08:50:21 <k12kl> yep that works
08:50:26 <dEPy> it installed it under:  ~/Library/Haskell/ghc-7.6.3/lib/yesod-1.2.2.1/lib
08:50:27 <jophish_> There must be an easier way of saying: zipWith (curry (uncurry xor *** uncurry xor))
08:50:31 <k12kl> thanks a lot i haven't fought of that
08:50:47 <dEPy> nvm, that's not binary
08:51:07 <fizruk> :t (***)
08:51:08 <lambdatwo> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:51:22 <geekosaur> look for a bin directory near there (possibly under yesod-bin-VERSION since that's the package)
08:51:23 <bz> :t transpose
08:51:23 <lambdatwo> [[a]] -> [[a]]
08:51:42 <dEPy> Yes it says: Installed yesod-1.2.2.1
08:51:44 <Kron> how would I use the Network interface found here: http://hackage.haskell.org/package/network-2.4.2.0/docs/Network.html
08:51:45 <lambdatwo> Title: Network, http://tinyurl.com/q6u36n6
08:51:53 <fizruk> :t xor
08:51:53 <lambdatwo> Bits a => a -> a -> a
08:51:54 <Kron> do I need to cabal install it?
08:52:23 <geekosaur> Kron: if you have cabal-install then Network should already be installed somewhere
08:52:32 <geekosaur> ghc-pkg list
08:53:13 <chrisdone> :t on (***) (uncurry xor)
08:53:14 <lambdatwo> (Arrow a, Bits (a b c)) => (a b c, a b c) -> (a b c, a b c) -> a (b, b) (c, c)
08:53:31 <chrisdone> :t map (on (***) (uncurry xor)) .: zip
08:53:32 <lambdatwo>     Not in scope: `.:'
08:53:32 <lambdatwo>     Perhaps you meant `.' (imported from Data.Function)
08:53:39 <chrisdone> damn. why's that never defined
08:53:51 <chrisdone> :t (map (on (***) (uncurry xor)) .) . zip
08:53:52 <lambdatwo> (Arrow a, Bits (a b c)) => [a b c] -> [a b c] -> [(a b c, a b c) -> a (b, b) (c, c)]
08:54:09 <chrisdone> D:
08:54:18 <geekosaur> keep in mind we're using a backup lambdabot, even if the main one has it the backup might not...
08:54:28 <Flonk> zipWith ( (,) `on` xor ) maybe?
08:54:44 <jophish_> :t zipWith ((,) `on` xor)
08:54:45 <lambdatwo> Bits b => [b] -> [b] -> [(b -> b, b -> b)]
08:55:06 <Flonk> err right.
08:55:50 <chrisdone> nah
08:55:51 <chrisdone> > on (***) (uncurry xor) ((1,2),(3,4)) ((5,6),(7,8))
08:55:51 <lambdatwo>   Could not deduce (Control.Arrow.Arrow (,))
08:55:51 <lambdatwo>    arising from a use of `Contro...
08:55:52 <thirsteh> Any way to just get any available port?
08:55:55 * chrisdone pokes lambdaone
08:55:58 <thirsteh> (to listen on)
08:55:59 <fizruk> jophish, why not map each and zip then?
08:57:19 <chrisdone> oh, duh
08:58:15 <fizruk> jophish, zip (f xs) (f ys) where f = map (uncurry xor) ?
08:58:32 <jophish_> fizruk: that makes a lot of sense
08:58:33 <jophish_> :)
08:58:57 <geekosaur> thirsteh, that's usually not what you want; it only makes sense if you have some other means to tell other programs about your service (ONC RPC, Rx, etc.)
08:59:08 <thirsteh> I do, and it's what I want
08:59:14 <geekosaur> and if you're doing that then you will need to use the lower level interface, as the haddock says
08:59:22 <thirsteh> a lot of other langs let you listen on port 0 and then just assign a random one
08:59:28 <jophish_> Thanks guys
08:59:36 <thirsteh> there is no way to listen on a random port with listeOn from the networking package as far as I can tell
09:00:08 <geekosaur> correct, as both I and its haddock says, you must use the lower level functions in Network.Socket
09:00:27 <geekosaur> (bind with aNY_PORT, then listen)
09:01:24 <Lethalman_> I would be interested on the L.hs of lambdabot in this channel
09:01:54 <thirsteh> geekosaur: ah, there it is. thanks
09:02:44 <thirsteh> geekosaur: although, I need to be able to tell what port it's then listening on
09:03:06 <chrisdone> > zipWith (on (,) (uncurry xor)) [(1,2),(4,5)] [(3,4),(6,7)] -- jophish_
09:03:06 <lambdatwo>   No instance for (Data.Bits.Bits b0)
09:03:07 <lambdatwo>    arising from a use of `e_112453467'
09:03:07 <lambdatwo> ...
09:03:19 <chrisdone> > zipWith (on (,) (uncurry xor)) [(1,2),(4,5)] [(3,4),(6,7::Int)]
09:03:20 <lambdatwo>   [(3,7),(1,1)]
09:03:40 <geekosaur> thirsteh, since I''m reading the docs for you apparently, Network.Socket.getSocketNamde
09:03:43 <geekosaur> thirsteh, since I''m reading the docs for you apparently, Network.Socket.getSocketName
09:03:49 <jophish_> chrisdone: nice :)
09:04:02 <chrisdone> \o/
09:04:17 <Kron> this Network library problem is making me feel very stupid :P
09:04:19 <thirsteh> geekosaur: thanks, I appreciate the help. No need to be an asshole
09:04:20 <Kron> I bet the solution is really easy
09:04:23 <geekosaur> also consider finding out how socket programming works, this stuff is pretty much just a thin Haskell layer over the standard socket functions
09:07:20 <Kron> hmm
09:08:25 <Kron> either I'm suffering from network issues or no-one has said anything in #haskell in the last 20 minutes o.o
09:08:47 <dv-> 4 minutes
09:09:49 <scriptor> Kron: ping
09:10:02 <Kron> my ping seems a bit better now
09:10:10 <Kron> thanks!
09:15:54 <rasfar> in case anyone has a moment: http://lpaste.net/95208
09:16:29 <rasfar> just wondering how one builds an example locally against a sandboxed package build (when the actual package is also installed)
09:16:54 <Fuuzetsu> rasfar: Does passing ‘-package hint’ not suit you?
09:16:57 <rasfar> tried a lot of -i -l and -L lines, but no joy, running out of ideas
09:17:17 <rasfar> oh: but i'm modifying hint as well
09:17:35 <Fuuzetsu> Sorry, haven't read your second message.
09:17:48 <rasfar> oh! np
09:19:13 <gdoteof> is there anything like socket.io in haskell?
09:19:44 <rasfar> gdoteof: i think the conduits package is recommended these days?
09:20:21 <thirsteh> geekosaur: FYI, there was a socketPort :: Socket -> IO PortNumber
09:20:27 <gdoteof> rasfar: thats about 2 levels of abstraction lower than i'm hoping for :-)
09:20:57 <rasfar> heh, ok
09:21:23 <ClaudiusMaximus> rasfar: maybe ghc-pkg list --verbose and hide one including the hash (but i never used cabal sandboxes yet)
09:22:09 <rasfar> thanks ClaudiusM. I'll try (perhaps in 15 minutes...)
09:22:13 <lpaste> yaxu pasted “Does this break monad laws?” at http://lpaste.net/95227
09:22:24 <ClaudiusMaximus> rasfar: alternatively, change the version number if you modified it
09:22:52 <yaxu> Hi all, wondering if the above paste is an example of a monadic law being broken or not?
09:23:13 <rasfar> that's a though as well, thanks. incidentally, the sandboxing is probably not essential, just something I tried (first time trying them) on other advice...
09:23:14 <mr-> yaxu: no, it is not. Consider IO, for example.
09:23:52 <yaxu> Ah, so it's ok for the 'structure' of the result to be different, based on the order of statements?
09:23:55 <mr-> yaxu: where vowel writes to a file that sound reads. (e.g.)
09:24:32 <ClaudiusMaximus> yaxu: yeah, i think that's the main difference between Applicative and Monad
09:25:41 <yaxu> in the first case the result is two sounds, with vowel applied to it. In the second it's one vowel, with the find sound applied to it
09:26:24 <yaxu> just feels wrong, but I guess that's just me thinking in terms of how imperative code usually works?
09:27:16 <mr-> yaxu: maybe it helps if you desugar do notation?
09:27:39 <yaxu> mr-: good thought, I'll give it a go ta
09:38:48 <Lethalman_> > "ping"
09:38:48 <lambdatwo>   "ping"
09:43:16 <fizruk> ClaudiusMaximus, I think the order of "statements" in Applicative also may vary the result
09:44:48 <fizbin> :t fmap (fmap join) (flip fmap)
09:44:48 <lambdatwo> (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
09:44:57 <fizbin> :t (>>=)
09:44:57 <lambdatwo> Monad m => m a -> (a -> m b) -> m b
09:46:28 <jophish_> How can I ignore some code if the ghc version is high enough?
09:46:34 <moops> @hoogle a -> b -> c -> d -> [(a, b, c)] -> [d]
09:46:34 <lambdatwo> No results found
09:47:07 <fizruk> :t uncurry3
09:47:08 <lambdatwo>     Not in scope: `uncurry3'
09:47:08 <lambdatwo>     Perhaps you meant `uncurry' (imported from Data.Tuple)
09:47:14 <fizruk> @hoogle uncurry3
09:47:15 <lambdatwo> No results found
09:47:20 <rasfar> (One more bit of info: I did not cabal install the modified hint package, only the official one. I only cabal built it (in sandbox). I could change the version and install it, but as this is only playing around I thought it would be more appropriate to not install.)
09:47:44 <moops> thanks fizruk :D
09:49:01 <fizbin> :t Data.Tuple.HT.uncurry3
09:49:12 <rasfar> jophish_: #if __GLASGOW_HASKELL__ < 704
09:49:23 <fizbin> :t Data.Tuple.HT.uncurry3
09:49:24 <jophish_> rasfar: and -cpp I guess
09:49:36 <moops> hmm "Could not find module `Data.Tuple.HT'"
09:49:44 <fizruk> fizbin, =)
09:49:44 <rasfar> yep! (i didn't know about -cpp, I use {-# LANGUAGE CPP #-})
09:49:55 <fizbin> It's in the package utility-ht, moops
09:50:41 <moops> is there a general way to tell what package a module on hackage is on?
09:51:03 <moops> i was on this page http://hackage.haskell.org/package/utility-ht-0.0.5.1/docs/Data-Tuple-HT.html
09:51:20 <moops> oh just delete the last two parts
09:51:22 <fizbin> I just use Google for the package name, then delete the package version number.
09:51:24 <geekosaur> it's there in the URL, or scroll up to the top of the page
09:51:25 <moops> nvm, thanks for the help
09:51:30 <fizruk> moops, "contents" in the top right?
09:51:46 <geekosaur> package name is on the top left in the page header
09:52:10 <geekosaur> "utility-ht-0.0.5.1: Various small helper functions for Lists, Maybes, Tuples, Functions"
09:52:23 <fizruk> anyway, I thought uncurry3 is in Prelude :)
09:53:53 <fizbin> Note that (map . uncurry3) doesn't quite have the type you asked for, moops, but has the type (a -> b -> c -> d) -> [(a,b,c)] -> [d]
09:54:03 <fizbin> Of course, that's probably what you meant.
09:54:16 <moops> yea, it is
09:55:27 <briennetheblue> ski: i think i found a nice example of before "f x `before` (guard . predicate) >>= ..."
09:55:34 <briennetheblue> i think it's useful, anyway :)
09:59:05 <Kron> can someone explain 'n + k' patterns to me? do they exist in haskell?
09:59:28 <geekosaur> they were removed from haskell2010
10:00:39 <kuznero> Hi All!
10:01:28 <rasfar> hi kuznero, what's up?
10:02:01 <kuznero> rasfar: trying to understand why createProcess from System.Process throws exception on Windows :(
10:02:40 <rasfar> i
10:02:53 <rasfar> oops will be of no use to you there
10:03:30 <kuznero> np, will post it on pastebin, let's see if someone could assist...
10:04:15 <haasn> Kron: http://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010
10:05:16 <kuznero> Gents, ladies, can anyone please help with this problem: http://lpaste.net/95228 ?
10:05:27 <lpaste> Kuznero pasted “createProcess on Windows” at http://lpaste.net/95228
10:07:28 <Kron> nevermind, gtg!
10:09:02 <lpaste> rasfar pasted “Wretched style, please help...” at http://lpaste.net/95229
10:09:22 <kuznero> But, to add to the sample I just posted... when creating process from GHCi it seems to be working fine...
10:12:21 <bz> :t reshape
10:13:11 <rasfar> reshape :: (Shape sh1, Shape sh2, Source r1 e) => sh2 -> Array r1 sh1 e -> Array D sh2 e
10:13:31 <rasfar> it's actually just a reindexing of the array
10:14:48 <rasfar> but the Repa stuff is the least of my problems in this instance...
10:15:04 <ClaudiusMaximus> rasfar: maybe you can creatively shadow:  something like   do{ v <- f v ; v <- g v ; ... }  and use return instead of let?
10:15:43 <rasfar> interesting, ok i'll look for opportunities to try that
10:16:41 <ClaudiusMaximus> rasfar: or maybe compose actions like  f >>= g >>= ...  so you don't even need names
10:16:42 <rasfar> cat you repeat names like that; I thought I tried that and it gave me some kind of trouble
10:17:49 <ClaudiusMaximus> @undo do{ v <- f v ; v <- g v ; h v }
10:18:05 <ClaudiusMaximus> oh bot :(
10:18:10 <rasfar> that sounds more "idiomatic" -- I shy away from unsugared monadic syntax, but maybe it's time to understand monads better. given my misunderstanding about "return" earlier
10:18:41 <rasfar> i'll try that locally, hang on
10:19:06 <rasfar> f v >>= \ v -> g v >>= \ v -> h v
10:19:15 <ClaudiusMaximus> yep
10:19:50 <ClaudiusMaximus> so each lambda introduces a new v into scope, shadowing the outer ones
10:19:53 <rasfar> gosh it's time to go through a Monad Tutorial again. (and apply what i learn)
10:20:07 <rasfar> oh, that i can understand easily! thanks
10:23:58 <moops> im writing an interpreter that returns an Integer, and that can throw a bunch different exceptions. An exception represents a bug in the interpreter. Is there some way i can turn my evalProgram :: AST -> Integer into AST -> Either String Integer ?
10:24:06 <moops> of*
10:24:30 <moops> for testing purposes
10:24:49 <Cale> Well, there's spoon
10:24:55 <joelteon> there's ErrorT
10:24:59 <Cale> any such thing is slightly evil
10:25:16 <Cale> http://hackage.haskell.org/package/spoon
10:25:26 <Cale> oh, right
10:25:31 <Cale> spoon only gives Maybe
10:26:23 <Cale> Someone should add, I dunno, knife :: (Exception e) => a -> Either e a  to that library
10:26:28 <moops> so its not possible without sacrificing safety then, i take it?
10:27:02 <joelteon> oh, you could write your own function for it
10:27:04 <Cale> Right, you can go the other way
10:27:32 <Cale> It's just that *catching* exceptions goes against purity.
10:28:25 <Cale> (you can break referential transparency with an unrestricted throw and catch)
10:29:27 <ReinH> Cale: clearly you are describing the spork combinator
10:30:31 <moops> maybe i dont need to change that function, ill see if i can catch it at a higher level thats already in IO
10:31:33 <ReinH> moops: seems like you should make the exceptions part of the interpreter definition rather than using Haskell's
10:32:01 <moops> it will for malformed programs
10:32:20 <moops> but it seems better to use haskells for things which represent bugs in the interpreter
10:32:28 <ReinH> Not to me
10:32:33 <moops> hmm
10:32:42 * hackagebot parseargs 0.1.5.2 - Command-line argument parsing library for Haskell programs  http://hackage.haskell.org/package/parseargs-0.1.5.2 (BartonMassey)
10:32:48 <ReinH> They are exceptions in the runtime you create and should be handled symetrically
10:32:59 <ReinH> i.e. as a part of the runtime
10:34:37 <moops> ill give it a try
10:35:38 <Cale> Actually, I think that makes sense. Bugs in the interpreter can be Haskell exceptions.
10:35:58 <jle`> is simon marlow ever in this channel?
10:35:59 <Cale> It's just, you probably shouldn't expect to catch exceptions thrown from pure code.
10:36:07 <jle`> just wanted to thank him for his book somehow
10:36:08 <Cale> jle`: Sometimes
10:36:18 <moops> may be more haskellish to still return an Either MyError Int
10:36:36 <jle`> Cale: what username does he tend to go under?
10:36:37 <Cale> jle`: I believe he goes by JaffaCake
10:36:39 <moops> where MyError is either a bug or bad program or the program did something bad like divide by zero
10:37:00 <jle`> Cale: ah, thanks
10:38:50 <moops> my interpreter is recursive decent, not sure how to make it die when an error is encountered
10:38:56 <moops> exceptions seem perfect for that :P
10:39:15 <alkabetz> moops: You could use the 'Maybe' monad
10:40:01 <ReinH> moops: you're using Haskell exceptions here as a poor man's monad, and you will always need to run your interpreter inside IO despite the fact that it is pure and deterministic.
10:40:30 <ReinH> (unless this is one of those newfangled nondeterministic recursive decent interpreters ;)
10:41:36 <moops> eval :: Environment -> Expr -> Integer  ----> eval :: Environment -> Either String Expr -> Either String Integer ?
10:42:03 <alkabetz> I’d go for eval :: Environment -> Expr -> Either String Integer
10:42:44 * hackagebot nlp-scores 0.5.4 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.5.4 (GrzegorzChrupala)
10:43:03 <ReinH> type RuntimeError = String
10:47:45 * hackagebot deepseq 1.3.0.2 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.3.0.2 (HerbertValerioRiedel)
10:49:05 <fizbin> moops: Note that if you have (eval :: Environment -> Expr -> Either String Integer) as alkabetz suggested, it's trivial to turn that into the type you suggested with (\env exprE -> do {expr <- exprE; eval env expr})
10:49:50 <fizbin> The other way around is pretty straight-forward too, I suppose.
10:50:56 <moops> looks like just having the either on the int is cleaner
10:54:09 <moops> hmm
10:59:45 <Zenol> Hi. Is there a way to create "parametrised types", in the sence that I would like to have one type for each Z/nZ ring? (So I would like something like data ZnZ Integer)
11:00:02 <moops> thats called a dependent type
11:00:11 <alkabetz> You can sort of do it with the DataKinds extension
11:00:23 <alkabetz> But I’d recommend learning a bit about dependent types first
11:02:05 <kuznero> I'm completely lost, has anyone have any idea about where should I look with this createProcess throwing permission denied exception on Windows?
11:02:22 <kmels> hi! i don't know whether this makes sense but, how can I know if a function `update :: StateT () IO` returns mzero or not?
11:03:03 <kmels> sorry, it is `update :: IM ()` where `type IM = StateT MyDataType IO`
11:03:28 <danr> well, it's probably going to return ()
11:04:10 <kmels> i do have a `when (statement) $ mzero` and it hangs in there, because i keep calling it. But i want to be able to stop it if it is mzero
11:04:16 <kmels> Sometimes it halts.
11:05:29 <Zenol> Hum, so DataKind alow using Types instead of kind, and type constructor instead of type. So I could make something like data ZnZ Integer = ZnZVal Integer, and ZnZVal 3 :: ZnZ 5 ?
11:05:47 <Zenol> (Hum, how can I tell the kind of a type variable? :s)
11:06:12 <Zenol> err, I mean data ZnZ a = ZnZVal Integer where a is Integer.
11:07:25 <alkabetz> Zenol: You can use :k in GHCi to check a kind.
11:08:09 <moops> i think i need to clean up my environment stuff first
11:09:19 <moops> data Environment = Environment { names :: SomeType, procedures :: SomeType, ... }
11:09:33 <moops> am i correct in assuming this is a good candidate for lenses? i dont know much about them
11:11:06 <lpaste> alkabetz pasted “𝐙/n𝐙 with DataKinds” at http://lpaste.net/95232
11:11:16 <alkabetz> Zenol: Have a look at that
11:11:39 <triliyn> moops: lenses would be useful if names and procedures have interesting parts inside them
11:11:59 <triliyn> (or any other field)
11:12:31 <moops> hmm
11:12:35 <moops> it will probably just be maps
11:12:38 <moops> lots of them
11:13:18 <Zenol> alkabetz: Thanks, that's exactly what I was looking for :)
11:14:59 <alkabetz> You’re welcome.  Good luck!
11:17:07 <Kron> hmmm. I bet this is a question that gets asked a lot but i'm gonna step on the landmine anyway: is there a neat way to implement natural numbers as a type?
11:17:25 <Kron> it's just getting a little bit annoying consantly wrapping functions with "if n is under 0, error"
11:17:39 <alkabetz> Kron: Define “neat”
11:17:41 <alkabetz> :)
11:17:46 <merijn> Kron: You can newtype and export a limited constructor
11:17:50 * hackagebot snap-core 0.9.5.0 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.5.0 (GregoryCollins)
11:17:55 <Kron> well, I guess reasonably efficient and useful
11:17:55 <Kron> yeah
11:18:02 <Kron> I guess that can work
11:18:07 <merijn> Kron: i.e. "newtype Natural = Nat Int", "makeNat :: Int -> Maybe Natural"
11:18:09 <Kron> okay thanks o.o
11:18:36 <alkabetz> Kron: Looks like http://hackage.haskell.org/package/naturals/docs/Data-Natural.html might be nice
11:19:00 <Kron> hmmm
11:19:13 <Kron> that indeterminate thing sounds dicey, I think just doing a newtype may be better
11:19:25 <Kron> like what if I try list !! indeterminate?
11:19:42 <alkabetz> You can’t do that with any natural from that package
11:19:46 <alkabetz> :t (!!)
11:19:51 <alkabetz> > :t (!!)
11:19:58 <merijn> @botsnack
11:20:02 <triliyn> The bot isn't here
11:20:03 <alkabetz> :(
11:20:04 <merijn> Looks like lambdabot is down
11:20:07 <Kron> :c
11:20:10 <Kron> poor lambdabot
11:20:12 <Kron> we knew her well
11:20:23 <Kron> okay I do basically want Nat to be a Num
11:20:27 <Kron> so I guess typeclass
11:20:29 <maik_> if you look at this "stepWire :: Time -> a -> m (Either e b, Wire e m a b)" What does it return? Is 'm' just a boxed value such as "IO a" or "Maybe a"?
11:20:31 <Kron> *newtype
11:20:42 <geekosaur> lambdabot hasn't been here all day. there was a backup but looks like that's gone too
11:20:52 <geekosaur> (or "two" since it was lambdatwo... :p )
11:21:04 <alkabetz> maik_: 'm' is some parametrized type; it could be 'IO' or 'Maybe' or a whole host of others
11:21:14 <alkabetz> maik_: It’s hard to say without seeing what type class constraints exist on 'm'
11:21:25 <Kron> maik_: it is indeed a 'box' of sorts, but the box depends on what the function does I guess
11:21:28 <lambdabot> :)
11:21:29 <lambdabot> [a] -> Int -> a
11:21:29 <lambdabot>   <hint>:1:1: parse error on input `:'
11:21:39 <Kron> :P
11:21:40 <alkabetz> yay!
11:21:42 <maik_> okay thanks
11:22:20 <merijn> maik_: Generally m will be a Monad in netwire
11:22:25 <moops> how would i modify one field of a record based on its old value? data Counter = Counter { _value :: Int } ; incr counter = counter { _value = _value + 1}
11:22:37 <kaction> Hello! Is is any way to write function a -> ?? a, which stack `return` as much, as necesery?
11:22:46 <merijn> moops: You can pattern match on record fields
11:22:55 <alkabetz> moops: Or just give up and use lens :)
11:22:58 <merijn> moops: I forget the exact syntax, consult the GHC manual for details
11:23:06 <merijn> kaction: Yes*
11:23:10 <sx> kaction: doesn't liftM do this?
11:23:11 <dv-> moops: incr counter = counter { _value = _value counter + 1 }
11:23:15 <merijn> kaction: * - with varying degrees of complexity/trickery
11:23:26 <merijn> sx: He want arbitrary numbers of lifts, not just a single one
11:23:57 <merijn> kaction: Anyway, you can do it, but I'm not sure I'd recommend it for beginners
11:24:12 <Peaker> moops: incr (Counter x) = Counter (x+1)
11:24:23 <Peaker> moops: but if Counter has many fields, "lens" is your friend
11:24:42 <moops> ah okay, ill just cave and use lenses then
11:24:44 <moops> thanks all
11:24:57 <kaction> Maybe you suggest reading for this problem?
11:24:57 <dv-> lens has its drawbacks
11:27:43 <moops> hmm, will i need a different lens for each field? doesnt seem like i gain anything in that case, unless my record is nested
11:27:48 <Peaker> dv-: mainly w.r.t learning it
11:28:11 <Peaker> moops: you can do:   data Counter = Counter { .... } ; makeLenses ''Counter
11:28:23 <Peaker> moops: then:  incr = value +~ 1
11:28:31 <Peaker> (so trivial that you probably wouldn't give it a name)
11:28:40 <dv-> Peaker: also noisy syntax, unreadable errors, and lots of dependencies
11:29:11 <alkabetz> Haha, yeah, the errors definitely take some getting used to
11:29:17 <glguy> moops: Your record becomes nested as soon as you put it in any other data structure
11:29:26 <glguy> like lists, maps, maybe, etc
11:30:09 <kaction> merijn: What should I read to understand, how do what I want? I know classes, instances and monad-transformers.
11:30:39 <Kron> hmmmm, what are all the things you need to define for a Num? +, -, *
11:30:45 <Kron> then... abs?
11:30:47 <alkabetz> :i Num
11:30:56 <alkabetz> Aww, does lambdabot not know :i? :(
11:30:59 <glguy> Kron: Check the documentation, it will tell you the minimum implementation
11:31:07 <Kron> ooh, sure
11:31:09 <Peaker> dv-: the syntax isn't noisy, it's much more concise (i.e: STN is higher)
11:31:10 <Kron> where would I check that?
11:31:11 <triliyn> lambdabot is wounded and seems to be responding irregularly
11:31:20 <Peaker> dv-: unreadable errors relate to "learning it" :)
11:31:24 <glguy> ?hackage base
11:31:28 <lambdabot> http://hackage.haskell.org/package/base
11:31:31 <Peaker> dv-: lots of dependencies is true
11:31:49 <Kron> http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-Num.html
11:31:52 <Kron> there's nothing here
11:32:00 <dEPy> any idea?      failed to install persistent-1.2.3.0/Users/matjaz/Library/Haskell/ghc-7.6.3/lib/resource-pool-0.2.1.1/lib/HSresource-pool-0.2.1.1.o: unknown symbol `_monadzmcontrolzm0zi3zi2zi2_ControlziMonadziTransziControl_zdp1MonadBaseControl_info'     ghc: unable to load package `resource-pool-0.2.1.1'
11:32:18 <glguy> Kron: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#g:7
11:32:22 <dEPy> trying to install yesod fails because persistent can't be installed
11:32:33 <dv-> Peaker: even after you get used to them, they're longer so they take longer to read and parse
11:32:34 <Kron> ooh thanks!
11:32:42 <glguy> Kron: click: Prelude > Number type classes
11:33:17 <Peaker> @quote line number
11:33:18 <lambdabot> No quotes for this person. Just try something else.
11:33:23 <dv-> Peaker: and it is noisy imo. normal record syntax is just [a-Z] (), {}, and lens has tons of symbols
11:33:33 <kaction> Can anyone, please, tell how write function, that stack returns as much, as necessery for context?
11:34:16 <Peaker> dv-: Lens reuses the ordinary symbols that known operators use, plus % for modification, and ~ or = suffixes for pure or state modification. Also @ for indexed, though these are more "advanced"
11:34:36 <glguy> kaction: You might have to step back a level and explain what you're trying to do. Your question doesn't make sense
11:34:41 <Peaker> dv-: so you just have to learn 3-4 rules about operating naming, and the dozens upon dozens of operators have compositional names
11:34:45 <monochrom> I cannot agree with "symbols = noise"
11:35:25 <elliott> dv-: incr = modify value (+1)
11:35:28 <elliott> lens
11:35:30 <glguy> dv-: The symbols are orthogonal to using lenses
11:35:40 <monochrom> my definition of noise is "noise = syntax serving no semantic purpose". clearly lens operators all serve semantic purposes.
11:35:42 <Peaker> dv-: There's also & and <&> instead of $ and <$>, which are nice as they are all infixl 1, which makes point-ful pipelines much nicer than before
11:36:14 <Peaker> foo & pureFunc <&> pureFuncOnRes >>= effectfulFunc & awesome
11:36:39 <Peaker> (>>= is also infixl 1)
11:37:12 <kaction> glguy: In fact, I want universal `lift`, which would automatically lift as much, as necessery, to eliminate zoo of `lift`, `lift . lift`, `lift . lift . lift ` and so on. For training I took on more simple problem --- with `return`, but I cant solve even it.
11:37:31 <Peaker> kaction: that's what the MTL does for the common case, though in general it might be ambiguous
11:37:43 <Peaker> @quote ndm number
11:37:44 <lambdabot> ndm says: As always, the most useful thing in the error message is the line number.
11:38:02 <Peaker> dv-: ^^ this is true about lens errors moreso than about other tools, but it's definitely worth it, IMO :)
11:38:08 <monochrom> example of noise: "multiply 4 by 5 and store it into y". it is 9 symbols for only 5 pieces of semantics: multiply, 4, 5, store, y. the rest is noise.
11:38:21 <monochrom> corollary: example of noise: english, cobol
11:38:22 <geekosaur> kaction, if you want to see how to do that kind of lift, you might take a look at MonadIO
11:38:23 <dv-> Peaker: well i converted a program that uses lots of records to lens and ended up not liking it so I reverted it. but maybe that's because i just rewrote normal record syntax with lenses or something
11:38:44 <Peaker> dv-: I changed my whole project to use lenses, and love it
11:38:58 <Peaker> dv-: also prisms, traversals, indexed lenses/traversals, the whole package
11:39:23 <dv-> and there are parts where I don't know how to use lens and have to use normal records
11:39:32 <dv-> like sortBy (comparing _record)
11:39:53 <glguy> dv-: lenses are much more than set way to do getters and setters on records, you're missing out if you just did a direct translation of your record accessors and record update syntax
11:40:09 <nbouscal> dv-: yeah you can use (view record) but _record is the same really
11:40:37 <nbouscal> i've been using lens on a project and i only lensify some of the record types. ones where you never use setters i don't seem to get value from lensifying them
11:40:42 <Peaker> dv-: comparing (^. foo) ?
11:41:18 <Peaker> I like the lens operators so I try to use them always, even as sections, rather than have aliases.. I dislike TIMTOOTDI
11:41:47 <nbouscal> hm. matter of preference. i rather like being able to use fmap sometimes and <$> other times. same thing for the lens operators
11:42:05 <Zenol> alkabetz: Are there a way to replace ZnZVal by a function so that I can constrol integer authorised (Something like constructor \v w -> (rem v w) :: ZnZ w ) ?
11:42:19 <Peaker> I think having many names for the same things is unnecessarily confusing
11:42:20 <Kron> how does one convert an Int into an Integer?
11:42:31 <Peaker> fromIntegral
11:42:54 * hackagebot deepseq-generics 0.1.1.1 - GHC.Generics-based Control.DeepSeq.rnf implementation  http://hackage.haskell.org/package/deepseq-generics-0.1.1.1 (HerbertValerioRiedel)
11:43:01 <Kron> ... hmmm
11:43:15 <Kron> are you sure? it seems to convert Integrals to Nums
11:43:21 <Kron> or... is that enough?
11:43:23 <mauke> Integer is a Num
11:43:23 <nbouscal> Peaker: It may not be necessary but I often find it nice. And if you don't like TMTOWTDI there are much lower hanging fruit (let v. where)
11:43:46 <maik_> any beginner FRP tutorial/book that you can recommend? I am playing around with netwire and helm, but it's not as easy as I thought it would be :(
11:44:15 <nbouscal> maik_: there is a coursera class in scala on FRP that is just starting, may or may not be useful for you
11:44:50 <Kron> fromIntegral isn't working, I'll see what I can do
11:45:03 <maik_> nbouscal, thanks, I'll have a look
11:45:05 <mauke> Kron: yes, it is
11:45:07 <monochrom> > fromIntegral (5 :: Int) :: Integer
11:45:19 <Kron> should I do that :: stuff?
11:45:23 <mauke> no
11:45:24 <Kron> fromIntegral x :: Integer?
11:45:26 <mauke> no
11:45:35 <monochrom> anyway, it works for me
11:45:36 <mauke> you should understand or at least explain your problem
11:45:47 <mauke> "isn't working" is not a problem description
11:45:52 <Kron> ah I see
11:46:02 <Kron> no I think I solved it
11:46:05 <Kron> thanks!
11:46:09 <monochrom> then good
11:47:22 <maik_> nbouscal, but it is just "reactive programming". Is the conecpt still similar?
11:47:29 <Peaker> nbouscal: I agree, I use "where" whereever I can and avoid let
11:47:44 <Peaker> nbouscal: I only use "let" inside "do" blocks where I need to scope over <- bindings, which "where" will not
11:47:49 <moops> maik_: its about functional reactive programming, they just didnt put functional in the course name for whatever reason
11:47:49 <Peaker> nbouscal: so it's one-way-to-do-it
11:47:53 <nbouscal> Peaker: and other people use let wherever they can and avoid where :)
11:48:07 <Peaker> nbouscal: I don't think so :) everyone hates the "let ... in ... " syntax
11:48:42 <maik_> moops, oh okay thanks :)
11:50:12 <chrisdone> Peaker: some people write let and then write the variables in reverse order, that weirds me out
11:50:23 <chrisdone> like
11:50:23 <chrisdone> let x = 2 * y
11:50:23 <chrisdone>     y = …
11:50:32 <chrisdone> it makes sense for where, but it seems the wrong order for a let
11:50:34 <Peaker> heh, that's top-down
11:50:47 <chrisdone> i always think of let as being bottom up
11:50:58 <chrisdone> probably because i only use it in do-blocks
11:51:00 <nbouscal> Peaker: I think there are a non-trivial number of people who default to let. Even if not, there are many many other places in the language where there's more than one way to do it
11:51:07 <nbouscal> do-notation itself is a good example
11:51:23 <Peaker> nbouscal: Yes, Haskell doesn't go for OOTDI, but I would love it to
11:51:27 <dv-> i always use let :|
11:51:34 <chrisdone> dv-: D:
11:51:48 <Peaker> dv-: with "in"?
11:51:50 <dv-> it indents more nicely
11:51:52 <dv-> yes
11:51:59 <Peaker> nbouscal: The IDE of the future ideally would use sugar for everything, so TIOOTDI
11:52:08 <Peaker> it indents horribly! :)
11:52:09 <nbouscal> Peaker: I dunno, I see the appeal, but I'm not partial to being dogmatic in either direction.
11:52:10 <chrisdone> dv-: ;_;
11:52:24 <nbouscal> i actually would prefer let but mostly use where because it indents better so now i am confused
11:52:37 <nooodl> i never know how to indent my "let"s in a way that looks nice
11:52:38 <nbouscal> i like that let is just expression reductions, whereas where is a syntactic construct
11:52:40 <nooodl> so i just give up and use "where"
11:53:04 <chrisdone> where is a natural way to do top-down coding
11:53:24 <chrisdone> main = foobar
11:53:24 <chrisdone> foobar = bob >> bill where
11:53:24 <chrisdone>   bob = lalal
11:53:24 <chrisdone>   bill = dfgdfg
11:53:46 <chrisdone> let reverses the order
11:55:08 <chrisdone> you should be able to read what the program is doing before you read how it's doing it
11:55:08 <chrisdone> because the latter is just noise without the former
11:55:19 * chrisdone is opinionated on this matter
11:56:53 <Peaker> chrisdone: when using C, I like bottom-up programming. In Haskell, I'm undecided, it depends on circumstance
11:57:01 <monochrom> I agree: if you top-down, use "where"; if you bottom-up, use "let"
11:57:20 <monochrom> but I think: most people have trouble making up their minds
11:58:53 <monochrom> C forces bottom-up. it is not like it gives you a choice.
11:59:05 <Peaker> monochrom: sure it does, you can use explicit function prototypes
11:59:12 <Peaker> and types' forward declarations
11:59:21 <monochrom> oops, yeah, I forgot that
11:59:55 <monochrom> well then, it still forces bottom-up in its type sublanguage
12:00:02 <bz> meh
12:00:09 <bz> how did i run out of ideas to write in hask
12:00:18 <bz> finished one of the rosalinds at the bottom, too
12:00:26 <Peaker> monochrom: for contains relationships
12:00:37 <Peaker> monochrom: btw, GHC forces bottom up too, between TH splices
12:00:57 <dv-> rosalind is ranked?
12:02:46 <monochrom> http://lpaste.net/83483 is truly top-down :)
12:03:58 <chrisdone> monochrom: nod, it seems to be the case that people can't make up their minds
12:05:29 <Hodapp> It seems like most languages that give you flexible constructs for composing things are those where bottom-up can work quite well.
12:06:16 <chrisdone> Peaker: yeah, c doesn't give you much of a choice in its sublanguage. you have to declare your variables and instantiate them all ahead of time. haskell's laziness really helps with declarative top-down style
12:06:23 <lpaste> moops pasted “lenses” at http://lpaste.net/95237
12:06:33 <moops> having trouble figuring out how to make this work
12:07:29 <chrisdone> moops:  i think your fields ought to be prefixed with underscores, right?
12:07:41 <moops> oh right
12:07:42 <moops> yea
12:07:44 * chrisdone doesn't know lens well, but pretty sure makeLenses mandates that
12:07:51 <alexander__b> what's an idiomatic way to map f and g on x?
12:07:54 <carlosgaldino> quick and noob question: >>= :: m a -> (a -> m b) -> m b. `m` must be of the same type, right? I can't have `m a` being an instance of Maybe and the function returning an IO Monad(the `m b`) in this case
12:07:57 * hackagebot cabal-debian 3.9 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.9 (DavidFox)
12:08:11 <bz> alexander__b: map (f . g)?
12:08:25 <alexander__b> bz: thats what I assumed, thanks
12:08:37 <alexander__b> bz: oh wait
12:08:40 <monochrom> carlosgaldino: correct
12:08:41 <nbouscal> moops: after the underscore fix, you're looking for something like map1 .~ i $ map1 .~ j $ maps, i think
12:08:57 <nbouscal> err, no, that's wrong
12:08:58 <alexander__b> bz: no, that's not what I meant. I meant if I e.g. have [text] and want to map length . lines and length . words on the same text
12:09:05 <carlosgaldino> monochrom: thanks
12:09:14 <alexander__b> bz: so not f (g x), but f x and g x and return both in a list.
12:10:13 <bz> alexander__b: h x = (length $ lines x, length $ words x)?
12:11:05 <chrisdone> bz: he said a list, not a tuple =p
12:11:26 <nbouscal> moops: map1 <>~ (singleton i j) $ maps
12:11:28 <nbouscal> might work
12:11:30 <joelteon> [f x, g x]
12:11:33 <cfoch> Hello. How can I divide "Int" / "Fractional" ?
12:11:44 <joelteon> fromIntegral cfoch
12:11:46 <joelteon> :t fromIntegral
12:11:52 <joelteon> oh
12:11:55 <bz> alexander__b: don't really get your description of the expected output
12:11:56 <chrisdone> alexander__b: are f and g the same type?
12:11:57 <nbouscal> moops: or better, map1 %~ (insert i j) $ maps
12:12:07 <joelteon> well it's (Integral a, Num b) => a -> b cfoch
12:12:14 <alexander__b> bz: if I have [txt], I want to return [length (lines txt), length [words txt)]
12:12:14 <triliyn> :t sequence [length . lines, length . words]
12:12:20 <joelteon> basically it converts an integer-ish number into any kind of number
12:12:23 <chrisdone> > map ($ 5) [(*2),(+3)]
12:12:33 <moops> nbouscal: it works! thanks :)
12:12:40 <alexander__b> bz: that is I want to map length (lines txt) and length (words txt) to the same [text] and return a list with both results
12:12:40 <chrisdone> got damn it lambdabot
12:12:46 <FireFly>   [10,8]
12:12:47 <joelteon> yeah
12:12:57 <nbouscal> moops: no problem, sorry it took a minute for my brain to wake back up :P
12:13:00 <chrisdone> thanks, FireFly
12:13:11 <cfoch> joelton: thanks, you're so cool :p
12:13:25 <chrisdone> alexander__b: map ($ txt) [length.lines,length.words]
12:13:25 <alexander__b> bz: foo txt = [map (length . lines) txt, map (length . words) txt] would probably work
12:13:38 <alexander__b> chrisdone: oh yes of course!
12:13:51 <alexander__b> chrisdone: I have done this exact same thing previously, and forgot all about it. thanks. :-)
12:13:59 <chrisdone> welcome =)
12:14:09 <FireFly> mmm, sectioning on ($)
12:14:17 <chrisdone> sexy right?
12:14:50 <FireFly> Very
12:17:06 <alexander__b> how did you typesig in ghci again?
12:17:14 <bz> :t
12:17:16 <alexander__b> nvm figured it out
12:17:29 <alexander__b> bz: I didn't mean typecheck but typesig your lets. but I figured it out.
12:17:59 * hackagebot free-functors 0.6.1 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6.1 (SjoerdVisscher)
12:18:52 <johnw> dEPy: hi
12:19:07 <Eduard_Munteanu> Is there a name for  f a b = (q, r) where q = floor (a / b); r = a - b * q   where a, b and r are reals, and q is an integer.
12:19:12 <Eduard_Munteanu> ?
12:19:43 <Eduard_Munteanu> A Haskell function would be nice too.
12:20:26 <triliyn> Isn't that either quotRem or divMod?
12:20:42 <dEPy> johnw: hi ? :)
12:20:46 <Eduard_Munteanu> :t quotRem
12:20:47 <monochrom> except a,b are reals
12:20:49 <nooodl> modf?
12:20:56 <geekosaur> Trilyn, but those are for Integral
12:20:56 <triliyn> oh
12:20:59 <johnw> dEPy: chrisdone was suggesting you get in contact with me
12:21:18 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Data-Fixed.html#v:divMod-39- ?
12:21:35 <Eduard_Munteanu> nooodl: for "mod float"?
12:21:47 <geekosaur> (why it's in Data.Fixed is a long story...)
12:21:51 <Eduard_Munteanu> Hmm.
12:22:03 <dEPy> johnw: If you're the guy that's going to help me with osx and cabal mumbo jumbo then yes plz :)
12:22:39 <Eduard_Munteanu> geekosaur: thanks, that seems to do
12:22:52 <johnw> dEPy: what's the problem you're having?
12:22:58 <monochrom> Eduard_Munteanu: you may like properFraction (a/b)
12:23:14 <nooodl> oh at first it reminded me of modf but that's something else. modf 3.14159 = (3, 0.14159)
12:23:44 <dEPy> johnw: I just reinstalled haskell platform so I'm at square one, but I'm having problems installing yesod (probably because of maverick update on osx?)
12:23:55 <geekosaur> some packages use the FFI to bind to C's fmod but that's only half of it
12:24:08 <johnw> dEPy: "problems"?
12:24:47 <monochrom> although, it is not floor, it is more like truncate
12:25:25 <Eduard_Munteanu> monochrom: hm, I need the quotient too though.
12:25:46 <Eduard_Munteanu> That seems to split a number into integral and fractional parts.
12:26:17 <dEPy> johnw: there's a lot of warnings when installing yesod and in the end it fails because it couldn't install conduit
12:26:41 <dEPy> johnw: conduit-1.0.8 failed during the building phase. The exception was:ExitFailure 1   <- when trying to install conduit by itself
12:26:52 <johnw> dEPy: https://gist.github.com/cartazio/7131371
12:27:05 <johnw> can you also show me a paste of the output?
12:28:00 * hackagebot free-functors 0.6.1.1 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6.1.1 (SjoerdVisscher)
12:31:25 <dEPy> johnw: I tried that first workaround but doing xcode-select install tells me it can't find the software and those brew commands say it's already tapped, and linked and so on
12:31:51 <dEPy> johnw: xcode-select says software is not currently available on update server or something
12:32:22 <johnw> i need to see your output
12:32:35 <geekosaur> dEPy, that means it's already installed. (horrible error message)
12:33:00 <dEPy> johnw: sure, sec
12:33:50 <Kron> hmmmm, GHC is saying "ignoring inconsistent module info:"
12:33:56 <dEPy> johnw: this is installing yesod https://gist.github.com/depy/7325599
12:33:56 <Kron> it seems to load just fine though
12:34:25 <Kron> module Naturals (Nat, toNat, fromNat) where
12:34:31 <Kron> is there a problem in my definition
12:34:51 <johnw> dEPy: yep, you need to follow that gist
12:34:53 <dEPy> johnw: and this is trying that patch thingy https://gist.github.com/depy/7325615
12:34:57 <johnw> you haven't done the critical step of modifying the settings file
12:35:38 <dEPy> johnw: that's right, I haven't done it yet on fresh install, let me try that
12:35:44 <moops> lens errors are ridiculous
12:37:22 <dEPy> johnw: how do I find path of newly installec apple gcc?
12:37:37 <johnw> it should be /usr/local/bin/gcc-4.2, if you followed his steps
12:37:43 <kqr> why is it not a good idea to override the default derived Show instance? i've heard the opinion some time ago that if you want pretty-printing, it's better to define your own methods for it. why is that?
12:38:09 <nbouscal> kqr: show is to some extent intended to be able to be read back in via a Read instance
12:38:31 <johnw> kqr: easier is to just use Text.Show.Pretty
12:38:37 <dEPy> johnw: so now it shuld work ?
12:38:49 <johnw> dEPy: after changing the settings file, you should see no more cpp warnings
12:39:10 <dEPy> johnw: seems like it's working
12:39:30 <dEPy> johnw: so, can you explain abit what the problem is?
12:39:52 <johnw> OS X 10.9's cpp isn't gcc anymore, it's clang
12:40:01 <lpaste> moops pasted “lenses again” at http://lpaste.net/95238
12:40:02 <moops> nbouscal: mind helping one more time?
12:40:28 <moops> err that should be "get" not "put" :F
12:40:33 <dEPy> johnw: so, just different standard?
12:40:44 <johnw> i'm not sure why it's being more strict
12:40:48 <johnw> carter would know
12:41:04 <nbouscal> moops: replace map1 with (view map1)
12:41:18 <nbouscal> err sorry, maps^.map`
12:41:23 <nbouscal> map1. cannot type
12:41:31 <geekosaur> because ANSI C requires it to be more strict. for gcc we used -traditional to override back to K&R behavior
12:41:41 <geekosaur> clang requires a different incantation
12:41:50 <nbouscal> moops: Map.lookup i (maps^.map1)
12:42:10 <dEPy> why did they switch it in osx maverick?
12:42:20 <geekosaur> apple decided to jettison gcc
12:42:32 <moops> nbouscal: works! thanks again
12:42:34 <geekosaur> probably because of gpl3, but you'd have to ask apple and I'm not sure they'd be forthcoming
12:42:48 <dEPy> :)
12:48:31 <dEPy> johnw: another thingy, when yesod is installed where are the binaries put?
12:50:54 <Ankhers> DEPy: ~/.cabal/bin if linux, I believe (~)/Library/Haskell/bin for OSX, no idea on windows.
12:52:01 <dEPy> yea, strange thing is ~/Library/Haskell/bin  only contains  yaml2json  O_o
12:52:19 <Ankhers> Did it say that yesod actually compiled and installed?
12:52:24 <Ankhers> Are you on Mavericks?
12:52:57 <dEPy> yes i'm on mavericks,  and seems like yesod installed:   Installed yesod-1.2.2.1
12:53:04 <jxv> What about `whereis yesod` ?
12:53:53 <dEPy> nothing, same for   locate yesod  or   which yesod
12:55:03 <jxv> Did you install yesod-bin with cabal?
12:55:44 <dEPy> no
12:56:33 <dEPy> but it says this: https://gist.github.com/depy/7325921
12:57:29 <Ankhers> Maybe try installing yesod-platform?
12:58:13 <dEPy> complains again, that some packages are likely broken
12:58:28 <dEPy> gut   ghc-pkg list  shows no 'red' packages
12:58:58 <dEPy> if that is even related
12:59:07 <jxv> dEPy, break it if you wish. The yesod-bin is the binary.
12:59:15 <jxv> All the other packages look current.
12:59:36 <dEPy> so I should just try to force it?
13:00:11 <dEPy> trying right now ... let's see
13:01:05 <johnw> force it, then reinstall whatever is broken as a result of that
13:03:56 <maik_> everyone is talking about how nice FRP is but I am interested in the cons. I know that there are potential time leaks with lazyness but there must be more.
13:04:34 <dEPy> I feel dirty doing this...
13:06:04 <tac> maik_: It's not clear, from a pragmatic standpoint, how to design UIs beyond a certain level of dynamicism to them.
13:06:18 <tac> maik_: Because all of your data dependencies must be given up front
13:18:28 <enthropy> cabal configure --enable-tests; cabal repl -- is this supposed to enable packages that the tests use?
13:18:34 <joelteon> yes
13:19:05 <enthropy> I mean in the ghci that gets loaded, it does not have the -package specified by a test
13:21:12 <tomejaguar> cabal repl exists?
13:21:49 <geekosaur> if you have the latest cabal-install, yes
13:22:59 <lilred> hey guys, can someone tell me what <$> is?
13:23:07 <johnw> it's another name for fmap
13:23:08 <Cale> lilred: It's a synonym for fmap
13:23:08 <joelteon> fmap
13:23:16 <johnw> f <$> x == f `fmap` x
13:23:22 <lilred> then what's <*> o.O
13:23:31 <joelteon> ap
13:23:35 <lilred> okay thanks!
13:23:35 <Cale> <*> is part of the definition of Applicative
13:23:48 <Cale> :t (<*>)
13:23:55 <johnw> it's not _really_ ap, anymore than <$> is liftM
13:23:57 <Cale> No lambdabot?
13:24:03 <lilred> I'm holding a programming paradigms workshop at school, it's pretty punk
13:24:07 <simpson> She's not in here, no.
13:24:12 <simpson> Somebody's kidnapped lambdabot! :c
13:24:18 <lilred> We're doing parser combinators in Haskell this week, wonder if someone can help me write the example code
13:24:28 <enthropy> joelteon: https://gist.github.com/aavogt/7326436  that one starts ghci without -package containers-x.y.z
13:24:52 <enthropy> so if you do what runtests.sh does, it fails
13:25:08 <Cale> elliott, mauke, someone: want to run lambdabot, or should I run the old one?
13:26:05 <elliott> Cale: sorry about that :)
13:26:15 <elliott> it seems to be crashing a lot today
13:26:36 <Cale> lilred: anyway, the type of <*> tells you a fair amount about what it means in general:  (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
13:26:46 <Cale> For example, let's consider f = Parser
13:27:03 <Cale> In that case, (<*>) :: Parser (a -> b) -> Parser a -> Parser b
13:27:05 <lilred> Cale: I'm pretty comfortable with the concept of fmap, thank you :)
13:27:08 <enthropy> alternatively, is there a flag that gets enabled when you --enable-tests?
13:27:20 <lilred> Cale: I'm struggling with syntax and idioms
13:27:41 <Cale> So it's taking a parser whose result is a function of type a -> b, and a parser whose result has type a, and doing *something* with them to produce a parser whose result has type b
13:28:02 <lilred> Cale: I KNOW FMAP :)
13:28:04 <Cale> and the obvious thing for it to be doing is probably the right one: run each of the parsers in turn, and apply the resulting function to the resulting value.
13:28:08 * hackagebot statestack 0.2 - Simple State-like monad transformer with saveable and restorable state  http://hackage.haskell.org/package/statestack-0.2 (BrentYorgey)
13:28:13 <Cale> This isn't something you can do with fmap! :)
13:28:19 <lilred> shit nvm
13:28:47 <lilred> I'm not sure how fmap and ap are different apart from the fact that one acts on a monad and the other works on an applicative
13:29:05 <lilred> nvm fmap works on functors
13:29:09 <fizbin> :t ap
13:29:17 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:29:27 <Cale> fmap works for arbitrary Functors. All Applicatives are Functors, and all Monads are Applicatives (but not the other way around, in each case)
13:29:30 <fizbin> :t fmap
13:29:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:29:51 <Cale> Note the extra m in the type of ap
13:29:55 <fizbin> But the types are very different, lilred.
13:29:58 <lilred> AH I get it
13:30:05 <fizbin> :t (<*>)
13:30:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:30:18 <lilred> fmap = some kind of "lift"
13:30:34 <fizbin> What you should ask is the difference between ap and (<*>)
13:31:18 <Cale> In the case of parsers as an example, (<*>) / ap will involve forming a parser which will run more than one parser (i.e. it will parse a concatenation of the languages parsed by each of its arguments)
13:31:28 <lilred> can someone explain to me how I could write a parser using parsec that, given, say, "195", produces the integer value of 195?
13:31:44 <fizbin> That difference (ap versus <*>) is just historical and would be fixed if the haskell universe were rewritten to have all Monads be Applicatives, as all sensible Monads are anyway.
13:32:26 <Cale> lilred: Well, that depends on how you want to go about it, and whether you want to take interpretation of base-10 into your own hands, or leave it to the existing read instance after matching a bunch of digits :)
13:32:31 <byorgey> fizbin: which it will be, in GHC 7.10
13:32:49 <lilred> Cale: I'd do what's most idiomatic, since this is example code for a workshop at school :)
13:32:52 <fizbin> And then will ap and (<*>) be synonyms?
13:32:53 <Cale> lilred: You could write  fmap read (many1 digit) :: Parser Integer
13:32:57 <lpaste> lelf pasted “why? (attoparsec)” at http://lpaste.net/95240
13:33:03 <FireFly> d'you think the type of ap will change after Monad will require Applicative?
13:33:05 <lilred> thank you cale!
13:33:09 * hackagebot hsnock 0.5.1 - Nock 5K interpreter.  http://hackage.haskell.org/package/hsnock-0.5.1 (mrdomino)
13:33:20 <byorgey> fizbin: off the top of my head, I am not sure.  Probably not at first.
13:33:34 <Cale> lilred: (note that this won't handle negative numbers as written)
13:33:42 <quchen> fizbin: I'm not sure about that, with a bias toward "no".
13:33:44 <lilred> Cale: that's perfectly fine :)
13:34:00 <fizbin> byorgey: So 'ap' will remain as a type-restricted version of (<*>), then?
13:34:05 <quchen> fizbin: The problem is that laws are encouraged, not enforced.
13:34:24 <quchen> fizbin: So "ap" and "<*>" may be different and still be legal Haskell.
13:34:52 <quchen> "ap" will probably be discouraged, as it introduces an unnecessary Monad constraint, much like (== []).
13:34:53 <carter> dEPy: johnw : darn it john, look at the topic for #haskell
13:34:57 <carter> johnw: i've told you this before :)
13:35:20 <briennetheblue> is there a really neat way to show that " flip ((. f) . g) " is " flip g . f "? i was wondering how much you can infer from just the types...
13:35:23 <byorgey> fizbin: I think so, and probably it will eventually be deprecated.  But don't take my word for it.
13:35:25 <johnw> carter: ack!
13:35:25 <carter> dEPy: johnw : basically clang CPP traditional mode doesn't fully replicate GCC's
13:35:27 <carter> and enver will
13:35:30 <fizbin> quchen: But aren't implementations free to write rewrite rules that depend on laws holding for validity?
13:35:39 <carter> johnw: ack ala tcp?
13:35:44 <carter> or "oh noes"
13:35:57 <quchen> fizbin: Current GHC does not use the Monad (or Functor or Applicative) laws. Probably for that reason.
13:36:17 <enthropy> probably another reason is maybe they don't help?
13:36:42 <byorgey> fizbin: the report is kind of ambiguous on that point.
13:36:44 <fizbin> quchen: So if you make "ap" and <*> different in the world where every Monad is an Applicative, aren't you taking a risk that your implementation will rewrite your code in surprising ways?
13:37:00 <carter> yes,
13:37:02 <byorgey> fizbin: in practice, the answer seems to be "no".
13:37:03 <carter> but thats you fault
13:37:11 <carter> but as byorgey says
13:37:17 <carter> ghc isn't that clever (yet)
13:37:18 <carter> :P
13:37:21 <quchen> fizbin: There are no rewrites. ap stays ap, <*> stays <*>.
13:37:53 <Eduard_Munteanu> Argh, no extension allows empty record updates. :(
13:37:54 <nomeata> Hi. Is there a verified compiler for Haskell, or a toy funcional programming language with lazy evaluation? If not, why not? Should there be one?
13:38:10 * hackagebot monadloc-pp 0.3 - A preprocessor for generating monadic call traces  http://hackage.haskell.org/package/monadloc-pp-0.3 (PepeIborra)
13:38:19 <quchen> fizbin: An example where Applicative is not a (valid) parent class of Monad is usually when the entire thing is contained in a module, and there is some interface that makes everything right. Similar to how ST is IO-like, but can be encapsulated to be pure again.
13:38:24 <Cale> fizbin: It will always be useful in defining an easy Applicative instance once you have a definition of Monad
13:38:25 <Eduard_Munteanu> nomeata: it's reasonably easy to implement an STLC in say Agda.
13:38:27 <quchen> Haxl does this for example.
13:38:46 <quchen> (Or at least it violates the Applicative laws, because ap /= <*>.
13:38:48 <quchen> )
13:39:34 <Cale> There seem to be a good number of cases where you want the Applicative instance to be incompatible with the one which is automatically available due to something being a Monad
13:39:35 <Eduard_Munteanu> Why isn't that a warning? It would confuse people, but it's definitely not breaking stuff. :/
13:39:38 <fizbin> Cale: In the world where Monad depends on Applicative, you never get to where you've got a definition of Monad and don't already have a definition of Applicative.
13:39:39 <byorgey> quchen: are they really unequal from a denotational semantics point of view?  Or are they just different operationally?
13:39:46 <Cale> fizbin: huh?
13:39:48 <Cale> fizbin: no
13:40:01 <Cale> fizbin: A superclass constraint doesn't say which order you have to write things in.
13:40:16 <Cale> fizbin: You can define the superclass methods using the methods of the subclass.
13:40:34 <humber> what it do
13:40:36 <Cale> It just says that the instances have to be there.
13:40:37 <humber> big l old school baby
13:40:42 <humber> school days and all that
13:40:43 <humber> 139 and lenox ave
13:40:44 <humber> word up
13:40:47 <nomeata> Eduard_Munteanu: with lazy evaluation? And compilation to some imperative, first-order target language? Or do you just mean an interpreter of STLC in Agda?
13:40:48 --- mode: ChanServ set +o Cale
13:40:57 <quchen> Cale: Oh right, and that.
13:41:32 --- mode: Cale set -o Cale
13:41:53 <fizbin> Cale: Really? Huh. I... yeah, okay, I guess I never tested that because flycheck would always start flagging my code when I'd forgotten a superclass declaration right away.
13:42:01 <Ankhers> Do I need to edit my environment in any way in order to use the binaries created in cabal's sandbox?
13:42:02 <Eduard_Munteanu> nomeata: I was thinking of an interpreter. BTW, are you aware of Compcert? Not lazy, but it's a lot of work.
13:42:19 <lilred> How do I express that a type parameter is generic? I have a parser that returns nothing, only consumes input, not sure what the type should be ("Parser _")
13:42:24 <quchen> byorgey: Morally, they should always be the same. However, "ap" will stay the monadic thing, and continue to unnecessarily use (>>=) when (<*>) would be enough.
13:42:33 <Cale> lilred: use ()
13:42:38 <Eduard_Munteanu> nomeata: you could compile STLC to SKI calculus or something like that.
13:42:44 <lilred> Cale: so Parser () or Parser unit?
13:42:49 <nomeata> Eduard_Munteanu: Yes, and there are a few works in that direction for eager, ML-style functional programs.
13:42:55 <Cale> yeah, () is the empty tuple type
13:43:07 <byorgey> quchen: I was asking about the specific case of Haxl
13:43:07 <Cale> It's useful when you have nothing meaningful to return from an action.
13:43:47 <Eduard_Munteanu> nomeata: I've also seen a verified bytecode verifier for Java, I think.
13:43:57 <absence> if i have a syntax tree, is a monad needed for an interpreter (in order to implement e.g. conditional branching), while an applicative is enough for a compiler (static transformation)?
13:44:00 <quchen> byorgey: Oh. Well in that case I'm not the right guy to ask. But looking at the data structure Monad/Applicative builds there, they look like they are identical when passed to some "eval" function.
13:44:10 <quchen> (Is that denotational semantics?)
13:44:31 <byorgey> ah, I see
13:44:39 <Eduard_Munteanu> absence: you don't really need a monad either way
13:44:45 <byorgey> no, that means they are even different denotationally
13:44:48 <donri> by this reasoning shouldn't things like (>>) and ($>) be "bad" too? the whole point of putting those in the classes is to allow for more efficient implementations that have the same uhm "result"?
13:44:56 <quchen> byorgey: Like "Next (Next (Done 1))" and "Next (Done 1)" are equvalent
13:45:03 <byorgey> but they are equivalent up to some sort of observational equivalence
13:45:11 <byorgey> right
13:45:22 <quchen> I think so.
13:45:51 <quchen> All I can really say is that I *know* Haxl violates the Applicative+Monad law, and I doubt Simon Marlow would do that without good reason and remedy.
13:45:54 <Eduard_Munteanu> absence: you could interpret the tree by compiling it to a bunch of continuations and running the results, for example.
13:45:58 <donri> so if you don't export the constructors and only correct interpreters there's no problem?
13:46:32 <donri> i don't think laws in haskell imply "correct by construction" :)
13:46:41 <byorgey> we need better tools for thinking and working with these sorts of situations, where something technically violates some laws up to equality, but satisfies them up to some more abstract notion of equivalence.
13:46:59 <Eduard_Munteanu> HoTT? :)
13:47:05 <byorgey> I was just going to say that.
13:47:13 <toors> is the choice between using (fmap / <*>), (pure / <*>), and (<$> / <*>) purely stylistic? do you guys find yourself using each based on context or do you pretty much stick to one?
13:47:14 <quchen> class Equivalence … :-)
13:47:18 <byorgey> I'm certainly hoping HoTT will be that in the long term.
13:47:31 <absence> Eduard_Munteanu: will that work for io actions though?
13:47:35 <johnw> toors: I use the one that suits the constraints I have; sometimes you have no choice
13:47:36 <Eduard_Munteanu> toors: in many cases yes
13:47:45 <fizbin> byorgey: Isn't what you want covered by a newtype wrapper and an Eq instance on that?
13:47:54 <triliyn> What is HoTT?
13:48:01 <Eduard_Munteanu> triliyn: homotopy type theory
13:48:39 <Eduard_Munteanu> absence: yes, you can build IO actions or representations of.
13:48:49 <byorgey> fizbin: no, because monad laws are not supposed to hold up to (==), they are supposed to hold up to = .  Having an Eq instance does not help because you can still write code which can tell the difference between two things which compare as (==).
13:48:54 <triliyn> Not something I'm familiar with, then (though I might look it up later because this discussion about various notions of equality is intriguing)
13:49:09 <lilred> how do I express that a function is generic?
13:49:22 <byorgey> triliyn: http://homotopytypetheory.org/
13:49:27 <lilred> I have a function that in ML syntax would be "'a -> Parser ('a list)'
13:49:30 <Eduard_Munteanu> triliyn: basically the idea that byorgey mentioned was that in HoTT you get isomorphism = equality.
13:49:36 <lilred> sorry "'a -> Parser ('a list)"
13:49:41 <byorgey> lilred: a -> Parser [a]
13:49:42 <lilred> what is that in Haskell
13:49:45 <lilred> okay thank you!
13:50:02 <quchen> The Monad laws are particularly unsuitable to be checked with (==) because many instances don't have Eq. (State, Reader, IO, STM, ST, probably parsers, ...)
13:50:48 <Eduard_Munteanu> quchen: well even checking  (->) r  satisfies laws is problematic if you just compare stuff :)
13:51:11 <Eduard_Munteanu> QuickCheck for monads ;P
13:51:13 <quchen> :-P
13:51:45 <quchen> One of Haskell's greatest features is that unit testing is only the second stage to testing your programs.
13:51:55 <johnw> quchen++
13:52:09 <quchen> (Compare that to other languages' second stage of testing: rolling it out in production)
13:52:12 <hpc> quchen: the first stage is production and the third stage is your coworker
13:52:31 <lelf> Can you somehow make this work in attoparsec: parseOnly (many anyChar >> char '.') "abc."
13:52:45 <hpc> :t parseOnly (many anyChar >> char '.')
13:52:46 <lambdabot> Not in scope: `parseOnly'
13:52:46 <lambdabot> Not in scope: `anyChar'
13:52:50 <hpc> :(
13:52:54 <Eduard_Munteanu> lelf: use manyTill
13:53:12 <Eduard_Munteanu> lelf: manyTill anyChar >> try (char '.')
13:53:20 <Eduard_Munteanu> Er.
13:53:22 <enthropy> is there a channel for cabal?
13:53:27 <Eduard_Munteanu> lelf: manyTill anyChar (try (char '.'))
13:53:33 <lilred> hey guys, I have a short script (30 lines) that I would like to share with class today as a Haskell example, could someone help me debug it and verify that it is idiomatic?
13:53:37 <lilred> here is the script: http://demo.firepad.io/#HImu2mKzsO
13:53:40 <quchen> byorgey: To come back to the Haxl case (which is really just a placeholder now for sane libraries that do something odd), I think this issue may have been what lead the Haskell designers no demand that laws hold.
13:54:03 <Eduard_Munteanu> lelf: the documentation for manyTill also gives a similar example
13:54:08 <quchen> byorgey: i.e. internal violations are OK. Maybe an "unsafeInstance" keyword would have been nice :-D
13:54:11 <brainacid> Hi channel
13:54:17 <lelf> Eduard_Munteanu: Obviously :) And without it? So it backtracks by char?
13:54:30 <Lethalman> lilred, that paste takes ages to load and it's not even highlighted :S (hint: use ideone)
13:54:45 <byorgey> quchen: yes, you're probably right
13:54:53 <Eduard_Munteanu> lelf: you could use  many noneOf '.' >> char '.'
13:55:22 <lilred> Lethalman: here it is http://ideone.com/htB06w
13:55:45 <tomejaguar> quchen: How does haxl violate the Applicative/Monad laws?  Just curious.
13:55:46 <Eduard_Munteanu> lelf: yeah, it backtracks.
13:55:59 <quchen> tomejaguar: ap /= <*>
13:56:20 <quchen> tomejaguar: The basic issue is that the Applicative instance is parallelizable, but the Monad one is not.
13:56:24 <triliyn> quchen: ap (/=) (<*>)
13:56:45 <Fuuzetsu> :t ap (/=) (<*>)
13:56:45 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
13:56:46 <lambdabot>     Expected type: (a0 -> a0 -> b0) -> a0 -> a0 -> b0
13:56:46 <lambdabot>       Actual type: (a0 -> a0 -> b0) -> (a0 -> a0) -> a0 -> b0
13:56:46 <quchen> triliyn: No, ap /= (<*>).
13:56:54 <quchen> Or (/=) ap (<*>).
13:57:03 <Eduard_Munteanu> quchen: not sure if Applicative and Monad's aps *must* coincide
13:57:11 <Lethalman> lilred, endOfList <|> entries directly instead of passing through result, might be a good use case to show how the monad works
13:57:13 <Fuuzetsu> I think Cale had something to say about that.
13:57:13 <lelf> Eduard_Munteanu: I know I can use "many (NOT E) >> E", I just want it to behave as, say, regexp /.*\./ (without writing /[^.]*\./)
13:57:20 <Kron> I've made the natural number type I wanted to! http://lpaste.net/4010253737854500864
13:57:22 <startling> Eduard_Munteanu: yeah, that's correct
13:57:24 <Kron> thanks for everyone's help ^_^
13:57:37 <lilred> Lethalman: good one!
13:57:45 <johnw> quchen: I made a dumbed down version of that too https://gist.github.com/jwiegley/6905323
13:57:46 <startling> classic example is downloading in parallel with (<*>), but you can't necessarily do it with ap
13:57:49 <quchen> Eduard_Munteanu: Control.Applicative names it as a law
13:57:52 <quchen> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative
13:57:52 <lilred> Lethalman: any idea why it won't compile?
13:58:03 <lilred> Lethalman: I'm not sure of the syntax for the type language
13:58:19 <Lethalman> lilred, you mean in ideone?
13:58:32 <lilred> well I'm running it on WinGHCi
13:58:51 <lilred> Lethalman: it doesn't typecheck
13:58:59 <quchen> johnw: Could you give me an abstract on that? Is that a small piece of code (for some definition of small) that has the same issues?
13:59:13 <johnw> quchen: It's an implementation of that aspect of Haxl as a monad transformer
13:59:26 <johnw> i.e., ConcurrentT m a make m parallel in <*> and sequential in ap
13:59:53 <Eduard_Munteanu> lelf: oh, in that case you can write something like  p stop = stop <* char '.' <|> p stop <* anyChar
13:59:58 <johnw> I wasn't aware it was law-violating, so this is good to know
14:00:07 <startling> I don't know if it violates the laws.
14:00:15 <quchen> Ah, I see.
14:00:31 <quchen> johnw: And then you provide an evaluation function that has identical results on equivalent data structures?
14:00:37 <lilred> Is there a way to throw away the result of a monad?
14:00:37 <startling> Yeah.
14:00:45 <quchen> startling: "If f is also a Monad, it should satisfy pure = return and (<*>) = ap (which implies that pure and <*> satisfy the applicative functor laws). "
14:00:46 <startling> lilred: how do you mean?
14:00:47 <Eduard_Munteanu> lelf: but the order of your <|>-combined parsers matters
14:00:48 <johnw> lilred: fmap (const ())?
14:01:04 <quchen> :t void
14:01:04 <lambdabot> Functor f => f a -> f ()
14:01:05 <lilred> startling: I have a Parsec parser and I'd like it to "eat" a character without returning it
14:01:09 <Lethalman> lilred, you can't use Parser a
14:01:12 <Lethalman> lilred, use Parser String
14:01:13 <johnw> quchen: oh, haha
14:01:22 <johnw> @src void
14:01:23 <lambdabot> Source not found. Abort, Retry, Panic?
14:01:31 <Lethalman> lilred, because, in your own code is not too generic to use "a", it only works for String
14:01:31 <lilred> Lethalman: I found the issue, "char" returns the character it's parsing
14:01:33 <johnw> I believe it's literally fmap (const ())
14:01:34 <Eduard_Munteanu> lelf: I mean something of that form. For your particular example, p = char '.' <|> (anyChar >> p)
14:01:43 <johnw> since it incurs a Functor constraint
14:01:45 <quchen> void = (() <$), literally
14:01:49 <johnw> ah
14:01:50 <lilred> Lethalman: I want it to "eat" the bracket and not return anything
14:01:51 <quchen> Or as of next release
14:01:56 <startling> quchen, is there a distinction between "should", "will", and "should satisfy the following laws: [...]"?
14:02:05 <startling> oh, no
14:02:06 <Lethalman> lilred, yes
14:02:11 * johnw hopes no one notices all the const () <$> in his code...
14:02:13 <startling> " include implementations of these functions satisfying the following laws [...]"
14:02:18 <Lethalman> lilred, also you are missing "value" after entries
14:02:19 <quchen> startling: All laws are only encouraged.
14:02:21 <startling> *must include
14:02:24 <startling> quchen, sure.
14:02:28 <Eduard_Munteanu> quchen: I mean CT-wise, I'm not sure they have to.
14:02:28 <quchen> startling: The Monad laws are stated the same way.
14:02:37 <startling> I mean, the other sense is that tey're semantically the same thing.
14:02:39 <quchen> Oh. CT-wise I have no idea what a lax monoidal functor even is.
14:02:57 <quchen> (Was that Applicatives Halloween name?)
14:03:04 <brainacid> Im considering becoming a developer. I only have high school education. I want to teach myself
14:03:10 <Eduard_Munteanu> quchen: I tend to oversimplify it to exponential-preserving functors.
14:03:26 <chrizz> hi, just started learning about GADTs from an interesting article in the latest MonadReader. I'm having trouble writing a convenience function that turns an Int into a NatSing (singleton version of peano number). Can someone please explain to me how to do this, if it's even possible? http://lpaste.net/95248
14:03:28 <brainacid> I wanted to get some feedback '
14:03:29 <quchen> That too tells me nothing. :-s
14:03:42 <Lethalman> lilred, another funny thing would be         (result:) <$> endOfList <|> entries value, but that might be too much :)
14:03:50 <Eduard_Munteanu> quchen: that is somewhat easier... it means it preserves function application, really.
14:04:00 <Eduard_Munteanu> :t fmap (uncurry ($))
14:04:01 <lambdabot> Functor f => f (b1 -> b, b1) -> f b
14:04:14 <johnw> quchen: actually, I just rely on FreeT to do the real work, so no evaluation function is really needed
14:04:32 <quchen> brainacid: I have zero formal training in programming.
14:04:34 <lilred> Lethalman: for now the more explicit the better :)
14:04:59 <quchen> johnw: Hmm. Well FreeT obeys the laws.
14:05:02 <Lethalman> lilred, well, that's another fmap example but using <$>, at least it's not an applicative :P
14:05:10 <quchen> johnw: I wonder where the violation comes in then.
14:05:12 <Lethalman> also an example of partial application :P
14:05:12 <Eduard_Munteanu> quchen: and at large, they're totally unrelated to monads.
14:05:18 <jophish__> Yo
14:05:23 <johnw> quchen: yeah, good question; maybe I'm good
14:05:23 <jophish__> I have a function which returns an integer
14:05:28 <Lethalman> however, gtg
14:05:37 <jophish__> a list of integers
14:05:45 <quchen> johnw: Maybe you're building your FreeT in different ways.
14:05:48 <jophish__> wait, I'll just say the type of what I want
14:06:10 <quchen> johnw: But you don't have a custom type that you declare monadic/applicative and then build a structure.
14:06:15 <quchen> (I'm just guessing here)
14:06:19 <jophish__> I have: f :: Int -> [a]. I'd like to get g :: [Int] -> [[a]]
14:06:29 <lilred> Lethalman: how would I make startOfList not return anything? I want it to throw away its output
14:06:38 <johnw> i wonder why there is no IdiomBrackets extension
14:06:41 <jophish__> this can be done neatly in the list monad I believe
14:06:47 <jophish__> but I can't quite remember how
14:06:58 <Lethalman> lilred, don't know Parser much, sorry
14:06:59 <quchen> jophish__: Looks like all you need is 'map'.
14:07:10 <lilred> Lethalman: that's fine, someone had actually replied above!
14:07:12 <quchen> johnw: What are idiom brackets?
14:07:15 <alexander__b> is there some doxygen-equivalent for haskell that's popular and/or good?
14:07:16 <clahey> jophish__: It can be done in the List Functor.
14:07:17 <lilred> (answer: fmap (const ())
14:07:20 <Lethalman> jophish, fmap ?
14:07:20 <Eduard_Munteanu> :t (uncurry (<*>), fmap (uncurry ($))
14:07:20 <quchen> I keep hearing about new brackets.
14:07:20 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:07:36 <Eduard_Munteanu> :t (uncurry (<*>), fmap (uncurry ($)))
14:07:37 <lambdabot> (Functor f1, Applicative f) => ((f (a -> b), f a) -> f b, f1 (b2 -> b1, b2) -> f1 b1)
14:07:38 <quchen> alexander__b: haddock is what is used to build all the fancy docs you see on Hackage.
14:07:43 <johnw> quchen: ($) <$> f <*> x would be [| f x |].  Idris has this
14:07:59 <jophish__> quchen: sorry, I guess the types aren't enough
14:08:04 <alexander__b> quchen: OK I'll look into it. thanks.
14:08:07 <Eduard_Munteanu> Applicative gives you a way to move between the two.
14:08:13 <jophish__> I'd like to get the list of all possible sequences of f
14:08:22 <jophish__> clahey: care to elaborate?
14:08:24 <quchen> alexander__b: http://www.haskell.org/haddock/doc/html/index.html
14:08:43 <quchen> johnw: Okay, that looks odd.
14:08:44 <brainacid> quchen, Ok nice. And you code as a career?
14:09:16 <quchen> brainacid: No. But I potentially will in the near future.
14:09:25 <jle`> is haskell ever going to get heredocs?
14:09:33 <donri> QQ?
14:10:01 <Eduard_Munteanu> jle`: you can define your own heredoc-like syntax with Template Haskell, like donri says
14:10:02 <geekosaur> not built in, probably, but there are several modules (most but not all using th/quasis) on hackage
14:10:05 <quchen> johnw: So idiom brackets basically lift everything as necessary?
14:10:28 <johnw> yes
14:10:29 <jle`> hesitant to resort to TH but i guess I can live
14:10:49 <Eduard_Munteanu> jle`: but if you want to paste data in your code, why not uuencode/base64 it first?
14:10:49 <johnw> quchen: they were presented in the original paper, and are pretty common in mathemetical treatments of the subject
14:10:59 <quchen> jle`: If you need multiline strings you can also escape whitespace.
14:11:02 <brainacid> quchen, What language did u begin with and what was your approach to proficiency.
14:11:03 <quchen> > "hello\    \ world!" -- jle`
14:11:04 <lambdabot>   "hello world!"
14:11:13 <johnw> stupid me, ($) <$> f <*> x == f <*> x
14:11:52 <donri> though i guess QQs lack the defining characteristic of heredocs
14:11:58 <Eduard_Munteanu> johnw: the former sort of makes the point of Applicative explicit, namely lifting ($).
14:12:06 <quchen> brainacid: I don't like to talk about my programming origins, I chose to learn the two most idiotic languages as my firsts ;-)
14:12:10 <skypers> hi
14:12:14 <jle`> quchen: did not know that you could escape whitespace, thanks for that
14:12:24 <brainacid> quchen, no prob.
14:12:25 <companion_cube> quchen: visual php.net?
14:12:33 <quchen> companion_cube: spot on
14:12:37 <quchen> VB and PHP.
14:12:53 <jophish__> oh ratbags, my function is in the IO monad already
14:13:42 <Eduard_Munteanu> jle`: https://en.wikipedia.org/wiki/Binary-to-text_encoding  might also help you, even if you have text
14:13:46 <brainacid> quchen, beginning with JS would be good ?
14:13:53 <quchen> brainacid: Programming is just something you learn over time. You do it and you get better when you challenge yourself on a regular basis.
14:14:06 <brainacid> quchen, gotcha
14:14:35 <johnw> quchen: now my Applicative is super clean: https://github.com/jwiegley/concurrent/blob/master/Concurrent.hs#L59
14:15:33 <quchen> johnw: Huh? Instead of "withAsync x wait", why don't you just use "x"?
14:16:09 <johnw> because f may be expensive to evaluate?
14:16:09 <Eduard_Munteanu> Weird how async gives you no way to get the Async handle into the child thread itself. :/
14:16:39 <quchen> Eduard_Munteanu: ?
14:16:41 <johnw> Eduard_Munteanu: interesting point
14:16:48 <johnw> you could marshal it over with an MVar
14:16:55 <jle`> i am having a brain lapse.  is there a standard library function for m >>= f >>= f >>= f >>= f ... n times ? or [m, m >>= f, m >>= f >>= f ... ]
14:16:55 <Eduard_Munteanu> johnw: yeah, I did that eventually :(
14:17:10 <quchen> jle`: foldr (>>=) return?
14:17:22 <quchen> And then replicate
14:17:25 <startling> foldr (>>=) m . replicate n
14:17:31 <Eduard_Munteanu> quchen: async gives the caller an Async, but not to the spawned thread.
14:17:56 <jle`> quchen, startling: ah that makes sense.
14:17:57 <quchen> Eduard_Munteanu: Oh, so if you want an async to cancel itself for example.
14:17:57 <Eduard_Munteanu> @hoogle iterateM
14:17:57 <lambdabot> No results found
14:18:07 <startling> i bet there's a thing in monad-loops
14:18:08 <johnw> quchen: even cleaner in this case is just "ap f . wait"
14:18:09 <jle`> does there happen to be anything cleaner in Control.Monad.Loops or something
14:18:19 <jle`> i guess i'll just dig around
14:18:22 <Eduard_Munteanu> quchen: yeah, or perhaps the child registers itself into a pool etc.
14:18:37 <jophish__> rephrasing things, I have the list ["cat", "dog", "xyz"] I'd like the list ["cdz", "cdy", "cdz", "cox", "coy"...
14:18:40 <chrisdone> Eduard_Munteanu: i hope there's a lifeguard present
14:18:41 <quchen> Eduard_Munteanu: Funny, I'm doing this exact thing right now. So yeah, that would be neat
14:18:41 <johnw> there's iterateM
14:18:44 <lilred> is there a "bottom" type in Haskell I can use for type parameters that don't matter?
14:18:47 <Eduard_Munteanu> Heh.
14:19:11 <lilred> also, "the child registers itself into a pool" sounds like a recipe for tragedy
14:19:11 <quchen> lilred: There is the empty type "Void". But if the parameter doesn't matter, you shouldn't use that.
14:19:44 <quchen> lilred: It may be beneficial to leave the type open for other functions to specialize.
14:19:47 <lilred> quchen: I have a "Parser ____" where the second part doesn't matter, and I want it to be pluggable, what can I put?
14:19:52 <Eduard_Munteanu> lilred: what do you mean "doesn't matter"? Perhaps you can use Proxy?
14:19:58 <quchen> :t forever -- Could use Void instead.
14:19:59 <jle`> johnw: hm i see iterateM_ ... but now do I "stop" it after n applications?
14:19:59 <lambdabot> Monad m => m a -> m b
14:20:12 <Eduard_Munteanu> jle`: (!!)
14:20:19 <quchen> But it's nice that the caller can specialize b to whatever himself.
14:20:29 <Eduard_Munteanu> :t (!!)
14:20:29 <lambdabot> [a] -> Int -> a
14:20:30 <johnw> jle`: yeah, your monadic function needs to know the stop condition
14:20:34 <startling> lilred, youcan just use a free type variable
14:20:41 <jle`> Eduard_Munteanu: iterateM_ does not return a list unfortunately
14:20:42 <lilred> Eduard_Munteanu: I mean that I have a parser that never returns anything, so the type that's in its type signature doesn't matter
14:20:44 <johnw> jle`: hmm
14:20:48 <Eduard_Munteanu> No? Hm.
14:20:52 <lilred> startling: that's exactly what I'm trying to do! How do I do that?
14:20:56 <quchen> lilred: For example a "skip whitespace" parser? That could have type "Parser r", where r is unused.
14:21:08 <lilred> quchen: by "unused" it shouldn't appear elsewhere?
14:21:09 <startling> lilred, pick a letter that hasn't been used yet in your type.
14:21:15 <johnw> jle`: I remember this coming up on cafe not too long ago
14:21:21 <quchen> lilred: Yeah. Like in the "forever" example.
14:21:23 <startling> lilred, all free variables are implicitly forall in Haskell
14:21:27 <jle`> i have done this multiple times in my life i am sure
14:21:35 <startling> lilred, "a -> a" is "forall a. a -> a"
14:21:56 <jle`> i guess i could encapsulate everything in a State and use replicateM
14:21:59 <quchen> johnw: Unless ap is not (<*>). :-)
14:22:05 <startling> :t [] :: [thisIsAFreeVariable]
14:22:05 <lambdabot> [thisIsAFreeVariable]
14:22:08 <johnw> quchen: oh, snap
14:22:13 <tac> @type id :: forall a. a -> a
14:22:14 <lambdabot> a -> a
14:22:15 <johnw> great poitn
14:23:13 <quchen> Also gotta be careful about circular definitions when replacing <*> with ap
14:23:14 <chrisdone> is ap ever not (<*>)?
14:23:18 <quchen> Haxl
14:23:24 <johnw> chrisdone: haha, welcome to the party!
14:23:26 <quchen> :-)
14:23:38 <johnw> the subject of our discussion: when ap is not <*>
14:23:52 <chrisdone> any examples?
14:23:55 <quchen> Haxl
14:24:01 <johnw> github.com/jwiegley/concurrent
14:24:03 <chrisdone> ah, that was directed at me
14:24:04 <quchen> Don't hurt me spamdetection ;-)
14:24:06 <johnw> aka, stripped down Haxl
14:24:13 <chrisdone> use more words next time please =p
14:24:19 <quchen> Hodor!
14:24:29 <Eduard_Munteanu> @fresh
14:24:29 <lambdabot> Halt
14:24:32 <Eduard_Munteanu> Wow.
14:24:46 <Eduard_Munteanu> If only I played the lottery.
14:24:55 <quchen> There are like 5 concurrent discussions here now
14:24:56 <quchen> I'm confused
14:24:56 <chrisdone> i've still got to watch that haxl talk
14:25:13 <chrisdone> quchen: now that's the #haskell i know and love!
14:25:31 <quchen> chrisdone: The original question was whether "ap" will be deprecated in the future, or defined in terms of "<*>".
14:25:36 <quchen> And then time happened.
14:25:53 <Eduard_Munteanu> Oh my god, I killed lambdabot. Me bastard.
14:25:58 <johnw> jle`: you know, your question is identical to a discussion we had last night, with the only exception that you're using a monadic function instead of a non-monadic one
14:26:14 <quchen> Short answer: ap will stay the same because it's not illegal to violate laws in Haskell. (What a beautiful language!)
14:27:14 <Kron> it should be. FREEDOM ISN'T FREE etc. o.o
14:27:23 <chrisdone> freedom is slavery
14:27:29 <quchen> Haskell is PHP
14:27:33 <Kron> war is peace
14:27:34 <chrisdone> war is php
14:27:37 <Kron> lol
14:27:48 <jle`> johnw: wouldn't a nonmonadic one just be iterate f x !! n?
14:27:50 <triliyn> I think what we're moving toward is "everything is php"
14:27:59 <johnw> jle`: that was exactly what we came up with
14:28:06 <quchen> triliyn: That would make PHP isomorphic to bottom. I'm on board
14:28:12 <johnw> http://tunes.org/~nef/logs/haskell/13.11.05, time 04:59:13
14:28:33 <Kron> XD
14:28:47 <Kron> poor PHP. No-one likes it.
14:29:15 <sm> triliyn: today's http://www.infoq.com/presentations/php-history agrees with you
14:29:43 <sm> (talk on php at facebook, good)
14:30:04 <chrisdone> johnw: reminds me i need to make a date view on ircbrowse
14:30:09 * chrisdone adds todo item
14:31:32 <quchen> chrisdone: It would be cool if you could make a timezone option, so all the dates get an offset
14:32:27 <lilred> :t (<*>)
14:32:58 <quchen> <*> :: Applicative f => f (a -> b) -> f a -> f b
14:32:59 <chrisdone> quchen: good point
14:33:02 * chrisdone adds to todos
14:33:41 <kuznero> System.Process.createProcess (proc path args) { std_out = CreatePipe, std_err = CreatePipe }
14:33:46 <kuznero> works in GHCi, but not when compiled :(
14:33:49 <kuznero> on Windows
14:33:57 <kuznero> Help....
14:35:39 <oRodrigo> hi
14:35:45 <jle`> hello
14:35:50 <briennetheblue> hey
14:36:11 <chrisdone> kuznero: paste codes
14:36:11 <chrisdone> @where lpaste
14:36:11 <chrisdone> ugh
14:36:11 <chrisdone> http://lpaste.net/new/haskell
14:36:17 <chrisdone> paste all the codes
14:36:21 <kuznero> hi
14:36:21 <quchen> Hello, sir!
14:36:23 <quchen> (Is Freenode DDoS'd right now? I'm having crazy lag)
14:36:33 <haasn> quchen: Doesn't seem like it
14:36:34 <kuznero> chrisdone: yeh, I know... just a bit desperate already... sorry
14:36:47 <haasn> quchen: have you tried switching servers?
14:37:00 <chrisdone> kuznero: don't be sorry, buddy. paste the code and we'll see if we can figure it out
14:37:18 <johnw> jle`: got it: iterate (>=> f) return !! 5
14:37:31 <quchen> haasn: How do I do that? Reconnect manually?
14:37:41 <haasn> quchen: I guess, or specify a different host manually
14:37:46 <quchen> BRB.
14:38:08 <lpaste> Kuznero pasted “createProcess on Windows #2” at http://lpaste.net/95250
14:38:14 <oRodrigo> Excuse me, I want to learn how to installar wxhaskell librery in leksah(windows), can someone help me?
14:38:30 <chrisdone> kuznero: that's not the whole code…
14:38:34 <kuznero> oRodrigo: I can help on this I guess
14:39:08 <oRodrigo> kuznero, I have already leksah in my pc
14:39:26 <oRodrigo> and I downloaded some packages
14:39:58 <kuznero> chrisdone: but that is the root problem...
14:39:58 <kuznero> oRodrigo: https://github.com/kuznero/Config/blob/master/haskell/install-wxHaskell-windows.txt
14:40:00 <oRodrigo> that I found on internet
14:41:30 <kuznero> oRodrigo: ok, what exactly do you mean by install wxHaskell in leksah? Do you want leksah to know signatures from wxHaskell?
14:41:45 <kuznero> oRodrigo: or do you just want to install wx package?
14:41:46 <oRodrigo> Im not sure
14:41:49 <oRodrigo> I just want
14:41:58 <oRodrigo> the wx and wxcore
14:42:09 <kuznero> I see, and you are on Windows, right?
14:42:11 <oRodrigo> it's for school
14:42:16 <oRodrigo> yes
14:42:56 <kuznero> Then just follow precisely what is stated in this link: https://github.com/kuznero/Config/blob/master/haskell/install-wxHaskell-windows.txt
14:42:56 <kuznero> I just went through this a few days ago
14:43:23 <kuznero> And, you can skip [ Notes ] section in the end. It should work without it anyway
14:45:00 <oRodrigo> will it work in leskah?
14:46:18 <briennetheblue> can parametricity help show that "flip ((. f) . g)" is "flip g . f"?  i've shown it through calculation (i think) i'm just wondering if there's a quicker way
14:46:20 <kuznero> chrisdone: I just posted full example http://lpaste.net/95250
14:46:21 <lpaste> Kuznero annotated “createProcess on Windows #2” with “createProcess on Windows #2 (annotation)” at http://lpaste.net/95250#a95251
14:46:28 <jle`> johnw: thanks, i'll give it a spin
14:47:14 <kuznero> oRodrigo: I'm not sure if Leksah will be able to understand it... I'm working primarily with Sublime Text 2 and SublimeHaskell plugin (based on ghc-mod, hdevtools', hoogle and hlint packages)
14:47:19 <quchen> So the guy in the PHP talk linked around half an hour ago just named concurrency and state as two of PHP's strengths.
14:47:31 <quchen> Meh, OT, I'll rant in #-blah.
14:48:05 <scriptor> damn, not a real channel
14:48:26 <quchen> scriptor: #haskell-blah.
14:48:47 <triliyn> join #haskell-blah
14:48:49 <triliyn> whoops
14:49:05 <kuznero> oRodrigo: As far as I know Leksah does not work pretty with latest released GHC (7.6.3 that is)
14:50:28 <oRodrigo> Ok, thanks anyway.
14:50:44 <kuznero> oRodrigo: np
14:55:29 <briennetheblue> i just feel like flip being the only function that's :: (a -> b -> c) -> b -> a -> c should help me prove that flip ((. f) . g) = flip g . f but guess i could be totally misled...
14:55:37 <skypers> why isn’t (<$>) in Prelude?
14:55:40 <skypers> fmap is
14:55:44 <joelteon> not sure
14:55:55 <skypers> it is
14:55:58 <skypers> I’m sure
14:56:13 <skypers> I often prefer using <$>
14:56:18 <skypers> but sometimes use fmap
14:56:36 <skypers> especially when I need to pass a function [a] -> [b]
14:56:46 <skypers> fmap f is prettier than (<$>) f
14:59:21 <WraithM_> skypers: Because (<$>) lives in Control.Applicative
14:59:25 <WraithM_> which is not Prelude
14:59:34 <WraithM_> idk
14:59:37 <WraithM_> That's a shitty answer
14:59:52 <merijn> skypers: Hysterical raisins
15:00:04 <WraithM_> I guess I associate <$> with applicative style
15:00:07 <WraithM_> not so much fmap
15:00:19 <WraithM_> despite it being fmap
15:01:27 <skypers> WraithM_: so you use fmap
15:01:30 <skypers> for instance
15:01:56 <skypers> let doubled = (2*) <$> [1..10]
15:02:00 <skypers> I prefer that than
15:02:10 <skypers> let doubled = fmap (2*) [1..10]
15:02:20 <WraithM_> I use fmap when I'm doing stuff with functors. I use <$> when I'm doing stuff with applicatives.
15:03:04 <skypers> that could be a great use indeed
15:03:10 <WraithM_> But that's not a hard and fast rule
15:06:53 <byorgey> is there anyone using haskell-yas with emacs haskell-mode, who can explain to me how to get it to work?
15:08:31 <hpc> i am having trouble googling for what haskell-yas is
15:09:08 <Fuuzetsu> hpc: https://github.com/haskell/haskell-mode/blob/master/haskell-yas.el
15:10:59 <hpc> more what YAS is at all
15:11:46 <loadedanvils> I'm getting parse error on input setCurrentDirectory in my code
15:11:52 <Fuuzetsu> hpc: https://github.com/capitaomorte/yasnippet
15:11:55 <loadedanvils> looks like this
15:12:20 <loadedanvils> how do I send code for display?
15:12:22 <Fuuzetsu> It's basically lets you expand terms with something like TAB and execute arbitrary Emacs Lisp while doing so.
15:12:39 <hpc> oh, i see
15:12:41 <Fuuzetsu> lpaste.net
15:12:47 <Fuuzetsu> loadedanvils: ^
15:12:49 <hpc> so haskell-yas-ghc-language-pragmas is
15:13:01 <hpc> when you type {-# LANGUAGE <tab>
15:13:11 <Fuuzetsu> hpc: sure, then you get a nice list
15:13:14 <hpc> it executes ghc --supported-extensions and then uses that to dictate your results
15:13:21 <Fuuzetsu> and you can do stuff with other extensions with it
15:13:25 <Fuuzetsu> like fuzzy matching and stuff
15:13:56 <Fuuzetsu> personally I trigger with LANG
15:14:01 <loadedanvils> http://lpaste.net/95253
15:14:14 <loadedanvils> giving me parse error on input setCurrentDirectory
15:15:03 <Fuuzetsu> There are quite a few things wrong with that function but first is that your expressions under ‘do’ don't align. Haskell uses alignment
15:15:38 <Fuuzetsu> So either move your ‘createDirectoryIfMissing True "hee"’ down a line, aligned with others or put more spaces in front of the two lines below so they align with it.
15:16:41 <chrisblake> this may be a silly question, but is IO a member of MonadIO?
15:16:45 <johnw> yes
15:16:46 <frx> jophish did you want this?
15:16:49 <frx> > sequence ["cat", "dog", "xyz"]
15:16:50 <lambdabot>   ["cdx","cdy","cdz","cox","coy","coz","cgx","cgy","cgz","adx","ady","adz","a...
15:16:50 <lpaste> Fuuzetsu annotated “test” with “test (annotation)” at http://lpaste.net/95253#a95255
15:16:54 <Fuuzetsu> Also note that you should be using spaces. I annotated your paste: http://lpaste.net/95253
15:16:59 <Fuuzetsu> Ah, there it went. Pretty slow.
15:17:01 <johnw> chrisblake: in ghci you can say ":i IO"
15:17:04 <merijn> chrisblake: FYI, you can use ":i" to check instances (assuming said instance is in scope)
15:17:08 <johnw> and you'll see its instances
15:17:12 <chrisblake> forgot all about that
15:17:14 <chrisblake> thanks, guys
15:17:24 <loadedanvils> Fuuzetsu: so tab doesn't cut it?
15:17:27 <johnw> #haskell: the alternative to :i
15:17:43 <chrisblake> :i IO
15:17:45 <cschneid> :i, but with lots of natural language processing.
15:17:59 <johnw> right, we answer the _real_ question, the one you didn't know to ask
15:18:00 <chrisblake> no lambdabot support for :i?
15:18:03 <geekosaur> nope
15:18:05 <Fuuzetsu> loadedanvils: You can technically use them (always interpreted as 8 spaces by the compiler) but it's very cumbersome. See http://urchin.earth.li/~ian/style/haskell.html for some pointers.
15:18:08 <chrisblake> shame...
15:18:08 <johnw> @info IO
15:18:09 <lambdabot> IO
15:18:10 <merijn> loadedanvils: I recommend reading https://en.wikibooks.org/wiki/Haskell/Indentation
15:18:31 <merijn> loadedanvils: That should dispel any and all confusion on haskell indentation
15:19:05 <loadedanvils> merijn: thank you, I'll give it a read
15:19:15 <Fuuzetsu> Remember to ignore the select few special snowflakes who will support tabs in Haskell as long as you can keep to a very rigorous discipline when editing and no one else will ever touch your code ;)
15:21:02 <kuznero> Is it appropriate to write to libraries@haskell.org with the question about `createProcess proc` that fails constantly on Windows?
15:21:23 <johnw> kuznero: I'd ask in #ghc first, personally
15:21:31 <kuznero> ok, thanks!
15:22:12 <briennetheblue> sorry to ask again -- but is there a more direct way than computation to show that flip ((. f) . g) = flip g . f?  parametricity maybe?
15:22:59 <startling> > flip ((. f) . g) a b
15:23:00 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr b0)
15:23:00 <lambdabot>    arising from a u...
15:23:05 <startling> > flip ((. f) . g) a b :: Expr
15:23:06 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
15:23:06 <lambdabot>    arising from a us...
15:23:12 <startling> ah well
15:24:32 <merijn> kuznero: libraries@ is mostly for feature suggestions/requests and discussion on (potential) bugs. If you're not sure whether it you or the library, maybe try the -cafe or -beginners lists first?
15:25:05 <briennetheblue> i have the computation here https://github.com/soapie/novelties/blob/master/novelties.lhs it's a bit messy though, i can't help but feel there's a better way...
15:25:44 <merijn> kuznero: Might also have a bigger chance of finding other windows users, as the ratio in the channel seems heavily skewed towards linux/osx, so the few windows users tend to miss windows problems/questions
15:26:30 <kuznero> merijn: seems that you're completely right...
15:26:54 <merijn> briennetheblue: with regards to sequenceUntil, have you looked at monad-loops?
15:26:58 <merijn> @hackage monad-loops
15:26:58 <lambdabot> http://hackage.haskell.org/package/monad-loops
15:27:20 <briennetheblue> merijn: i did, i don't think they have that sequenceUntil though
15:28:41 <johnw> monad-loops sounds like something Haskellers eat for breakfast
15:28:55 <merijn> briennetheblue: You could always email the maintainer and see if he/she is interested in including it
15:31:01 <briennetheblue> merijn: that's a good idea, seems like a good home for it
15:39:12 <moops> Either String a -> (a -> IO (Either String b)) -> IO (Either String b)
15:39:16 <moops> this is just >>= right?
15:39:44 <merijn> Not quite
15:39:50 <merijn> Without the IO it would be
15:40:05 <oRodrigo> someone knows what does "onPaint", data constructor "ViewArea" and datacontructor "GraphicBitmap?"
15:40:11 <moops> oh
15:40:53 <moops> is it possible?
15:40:57 <Fuuzetsu> Why do C++ Qt projects take so bloody long to compile? Even Haskell takes less time.
15:41:13 <geekosaur> very heavy use of templates
15:41:53 <moops> seems like it should be but i cant figure it out for the life of me
15:41:55 <Fuuzetsu> Great because I have to bisect 440 commits into the past in this one project
15:42:15 <Dodek> Fuuzetsu: c++ takes ridiculously long time to compile in general
15:43:50 <merijn> moops: Writing a function like that is possible yeah, you'll just have to explicitly pattern match the either
15:44:08 <joelteon> why does haskell take so long to compile?
15:44:18 <Peaker> joelteon: with or without TH?
15:44:21 <johnw> briennetheblue: I'd be happy to put sequenceUntil into monad-extras
15:44:27 <Peaker> joelteon: -O2 is slow, TH is *very* slow
15:44:30 <joelteon> oh
15:47:38 <bgamari> Is `utf8-string` not simply an obsolete `text`?
15:48:00 <geekosaur> utf8-string is not text, no
15:48:15 <geekosaur> in the old days, ghc didn't actualy support anything beyond iso8859-1
15:48:21 <geekosaur> even for String
15:48:30 <geekosaur> utf8-string added utf8 support for Strings
15:49:44 * Maxdamantus wonders how `show :: String -> String` manages to behave differently to the other `show`s.
15:49:59 <bgamari> Maxdamantus, see showPrec
15:50:07 <bgamari> geekosaur, Does it serve any purpose at this point beyond backwards compatibility?
15:50:08 <Maxdamantus> well, the other `show :: [a] -> String`s.
15:50:09 <geekosaur> nope. try showList for Char
15:50:32 <bgamari> oops showList
15:50:33 <geekosaur> bgamari, not really (except it is a little easier to use for utf8 encode/decode than the ghc internal ones are)
15:50:37 <Maxdamantus> Ah, I see.
15:50:37 <bgamari> beat me to it
15:50:52 <bgamari> I see
15:51:05 <bgamari> geekosaur, Are the strings unpacked?
15:52:18 <briennetheblue> johnw: cool!  monad-extras but it seems like a good place for it.  if you search google for sequenceUntil/sequenceWhile you'll find a lot of talk about it but the functions never seemed to find their home on hackage...
15:52:20 <geekosaur> it supports utf8 pack/unpack for both String and ByteString
15:52:29 <johnw> briennetheblue: ok, adding it now
15:52:51 <geekosaur> and System.IO replacements for String that do encode/decode (this is obsolete since ghc does it now)
15:53:23 <johnw> briennetheblue: http://github.com/jwiegley/monad-extras
15:53:45 <briennetheblue> johnw: :)
15:54:29 <johnw> uploaded as 0.5
15:57:52 <loadedanvils> getCurrentTime >>= utctDay
15:58:11 <alkabetz> > getCurrentTime >>= utctDay
15:58:12 <lambdabot>   Not in scope: `getCurrentTime'Not in scope: `utctDay'
15:58:12 <johnw> has anyone perused "Axiomatic Method and Category Theory" by Andrei Rodin?
15:58:18 <johnw> seems like it was published just one week ago
15:58:29 * hackagebot monad-extras 0.5.0 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.5.0 (JohnWiegley)
15:58:51 <loadedanvils> getCurrentTime >>= utctDay seems to not work (import Data.Time)
15:59:14 <xico> johnw: looks quite expensive for a philosophy book
16:00:11 <johnw> huh, the PDF is right here: http://arxiv.org/abs/1210.1478
16:02:04 <oRodrigo> Hello,  I want to learn to make some graphics in haskell, where can I found information about that?
16:02:22 <johnw> oRodrigo: #diagrams
16:02:35 <johnw> excellent library for creating graphics in Haskell
16:03:31 <oRodrigo> johnw
16:03:43 <oRodrigo> I am working in wxhaskell
16:03:53 <oRodrigo> it's for school
16:03:57 <johnw> i see
16:04:16 <oRodrigo> so I just want to know how to make some frames with their atributes
16:05:01 <oRodrigo> they ask me things like  solve the well-known "n queens problem" graphicaly
16:05:11 <johnw> yeah, teachers, they do that
16:05:38 <oRodrigo> yes but mine dint tell me where found the information =(
16:07:17 <johnw> i wonder how many times n queens has been solved throughout history
16:07:24 <johnw> seems like it just won't stay solved
16:07:34 <oRodrigo> LOL
16:07:47 <oRodrigo> I have to learn how to solve it graphicaly
16:07:59 <Fuuzetsu> Guess the new problem is how to get people to stop solving n-queens.
16:08:05 <moops> can you not call show on an exception? i think thats causing it to be thrown again
16:08:05 <oRodrigo> I already have the solution  without graphics
16:08:06 <johnw> right
16:08:13 <johnw> for any n-queens problem, solve (n+1)-queens
16:08:30 <Fuuzetsu> AND SO ON BY INDUCTION
16:08:37 <Fuuzetsu> ∎
16:08:40 <johnw> soon the youngsters will be solving ω-queens
16:09:11 <Fuuzetsu> I can only hope that's a real thing.
16:10:00 <oRodrigo> yes I already solve it without graphics, I'm interested about how should I put the pictures of the table
16:10:00 <oRodrigo> or the queens
16:10:10 <oRodrigo> and make a button to show
16:10:10 <oRodrigo> an asnwer
16:10:50 <oRodrigo> maybe an splitbutton(I guess it is its name) that indicate how many queen would be in the table
16:12:07 <bgamari> Anyone have an up-to-date email address for Don Stewart?
16:13:31 <hpc> bgamari: you might be able to get it out of his google+ account
16:14:50 <oRodrigo> johnw are you still there?
16:16:45 <briennetheblue> johnw: about your comment for the function "Draw monadic actions from a list until one of them yields a value failing the predicate, and then return all the passing values in a list within that monad." shouldn't it be satisfying rather than failing, and also all of the passing + the first failing is what's returned (just those passing being returned is what i would call 'sequenceWhile')
16:18:38 <Eduard_Munteanu> I wonder if there's a (<.>) :: Applicative f => f (b -> c) -> (a -> f b) -> a -> f c; (f <.> g) x = f <*> g x
16:20:43 <jdhutah> johnw, briennetheblue: i was just recently in need of a sequenceWhile function as well
16:20:55 <mm_freak_> Eduard_Munteanu: hint:  ((->) a) is also an Applicative
16:21:40 <briennetheblue> jdhutah: i suspect that it's a commonly required function, it just lacked a home :)
16:21:55 <Eduard_Munteanu> mm_freak_: yeah, I guess that works if you do  f . g . h <*> x
16:22:02 <Eduard_Munteanu> Er.
16:22:16 <jdhutah> briennetheblue: definitely. i came in halfway through your convo with johnw.  is this going into monad-extras?
16:22:18 <ebaldwin> @dcouttts please check your email
16:22:18 <lambdabot> Unknown command, try @list
16:22:29 <Eduard_Munteanu> :t ?f . ?g <*> ?x
16:22:30 <lambdabot> (?f::b1 -> a -> b, ?g::a1 -> b1, ?x::a1 -> a) => a1 -> b
16:22:36 <Eduard_Munteanu> :t ?f . ?g <$> ?x
16:22:37 <lambdabot> (Functor f, ?f::b1 -> b, ?g::a -> b1, ?x::f a) => f b
16:22:39 <Eduard_Munteanu> That.
16:22:45 <ebaldwin> dcoutts please check your email
16:23:05 <briennetheblue> jdhutah: it's in the latest monad-extras now, though i think the comment for it is a little misleading
16:23:17 <jdhutah> awesome
16:24:19 <roni> heh i just wrote sequnceWhile just to teach myself :-D
16:24:20 <alexappetiti> @oRodrigo I think looking at http://hackage.haskell.org/package/GeBoP-1.7.2/src/Reversi.hs might be useful, try going to the onpaint method a see how he draws the reversi board
16:24:20 <lambdabot> Unknown command, try @list
16:24:55 <alexappetiti> It's not quite chess, but still a grid of squares with various pieces
16:29:35 <dpwright_> I'm trying to create a type which defines a "context" for an operation... it's a bit like ReaderT combined with bracket from Control.Exception, so there's a class "Contextual" that defines init and finalise operations, and a function called "withContext" that takes one of these classes and a ContextT (/ReaderT), runs init, runs the contextual action with the return value from init, and then runs finalise at the end
16:29:44 <dpwright_> does such a thing already exist?
16:30:37 <dpwright_> I want to define at the type level that this thing must already have been initialised to do the next thing, basically.  And to have access to the initialised thing through something like the ReaderT monad
16:30:53 <oRodrigo> Someone who help me, I want to make some graphics with wxhaskell in leksah, please
16:36:11 <alexappetiti> @oRodrigo, did you take a look at the link I sent?
16:36:11 <lambdabot> Unknown command, try @list
16:36:49 <briennetheblue> @botsnack
16:36:49 <lambdabot> :)
16:37:56 <hamishmack> oRodrigo: Once you have installed wxhaskell, go to Package -> New in leksah.  Choose a directory to create the package in (name of the directory will be the name of the package).
16:38:29 <hamishmack> Then in the dependencies add the wxhaskell package
16:40:25 <OODavo> Is it possible to define a "matrix" data type in Haskell's type system, such that all valid matrices are members of the type and all invalid matrices are not? I've only seen matrices modeled as nested lists like [[Int]], which has the problem that it can't guarantee all rows have the same size.
16:42:12 <moops> thats called a "dependent type" because the type relies on a value, in this case the number of rows and columns
16:42:44 <moops> im not sure if you can do it properly in haskell, but you might be able to hack up that example
16:42:46 <OODavo> Well, I don't necessarily want the type itself to differ between differently-sized matrices (although that would make some sense).
16:42:59 <geekosaur> I think you would need the type to differ
16:43:31 <Heffalump> if you just define size-indexed vectors you can then make a list of those
16:43:50 <Heffalump> I don't think that's a dependent type per se - probably needs GADTs though
16:44:17 <chare> talk
16:44:23 <chare> can anyone hear me?
16:44:35 <moops> chare: nope
16:44:51 <OODavo> It might be simpler just to have nested lists, but use smart constructors to build the actual matrices.
16:45:04 <monoidal> OODavo: I think I saw somewhere (oleg?) a GADT encoding of square matrices of arbitrary size
16:45:06 <OODavo> Less statically-verifiable though.
16:45:07 <moops> do you want arbitrary sized matrices?
16:45:10 <moops> or just like, 4x4
16:45:36 <monoidal> OODavo: you can define a Vector n a type Nil :: Vector Zero a, Cons :: Vector n a -> Vector (Succ n a) and then use Vector n (Vector n a)
16:45:39 <OODavo> It's more hypothetical than actually something I need practically; arbitrarily-sized matrix support would be the ideal.
16:45:40 <pavonia> chare: we can read you, if that helps
16:46:05 <Heffalump> or Vector m (Vector n a) for rectangular matrices
16:46:15 <chare> so have you guys remember  the haskell starcraft project proposal
16:46:48 <monoidal> the probably-oleg thing was something more sophisticated, as far as I remember
16:46:54 <Hafydd> I do not. What is it, chare?
16:47:40 <monoidal> oh! It was Okasaki. OODavo: search for From fast exponentiation to square matrices: an adventure in types
16:54:45 <OODavo> monoidal: Aha. Looks like this is the kinda thing.
16:58:58 <chrisblake> does IO a satisfy IO ()?
16:59:03 <chrisblake> and if so, how?
17:00:04 <monoidal> you can instantiate a = () to get IO ()
17:00:15 <OODavo> You shouldn't really be able to *have* a value of type IO a, unless it's (return undefined).
17:00:24 <monoidal> or an infinite loop.
17:00:29 <hpc> OODavo: or anything (>> return undefined)
17:00:33 <monoidal> e.g. forever (print "a")
17:01:03 <OODavo> Oh, yeah, or those.
17:01:04 <chrisblake> because writFile has type IO a, doesn't it?
17:01:07 <chrisblake> yet I can use it in main
17:01:10 <monoidal> :t writeFile
17:01:11 <lambdabot> FilePath -> String -> IO ()
17:01:15 <chrisblake> oh...
17:01:17 <monoidal> as you see, no - it has IO ()
17:01:26 <chrisblake> well, also getDirectoryContents
17:01:30 <chrisblake> :t getDirectoryContents
17:01:31 <lambdabot> Not in scope: `getDirectoryContents'
17:01:37 <chrisblake> it's IO [FilePath]
17:01:46 <monoidal> chrisblake: "main" is bit weird: it can be IO x for any value of x
17:01:58 <OODavo> :t void
17:01:58 <lambdabot> Functor f => f a -> f ()
17:02:05 <chrisblake> monoidal: and x satisfies ()?
17:02:13 <monoidal> chrisblake: in other words, your main can have type IO Int, IO String, IO (), IO a etc., and it will always work (by discarding the result).
17:02:31 <chrisblake> oh and that's just how it is?
17:02:32 <OODavo> chrisblake: x is a type variable, so any type can go in it. () is one such type.
17:02:37 <chrisblake> oh, okay
17:02:41 <moops> am i wrong that this is join? Either a (Either a b) -> Either a b
17:02:48 <chrisblake> I think I got it. thanks, guys.
17:02:53 <monoidal> moops: it is join
17:02:57 <OODavo> moops: Looks like join, yep.
17:03:47 <moops> hmm
17:03:51 <moops> maybe i put it in the wrong place
17:04:57 <moops> oh its using the wrong 'join'
17:06:33 <chare> lets make starcraft clone in haskell
17:06:35 <chare> who is with me
17:06:43 <briennetheblue> sure
17:06:49 <chare> really?
17:06:51 <moops> nah i did that last year
17:06:56 <briennetheblue> you must beat me in 1v1 first though
17:07:25 <chare> ok lets play 1v1 starcraft brood war
17:07:48 <briennetheblue> sc2 only please :(
17:07:55 <chare> oh so you want the easy game
17:08:32 <briennetheblue> i only played custom games when it came to brood war :(
17:09:07 <Fuuzetsu> #haskell-mlg-noscope-400apm
17:09:30 <Fuuzetsu> no qt korean gf edition
17:09:36 <chare> briennetheblue the game we're making is a successor to brood war not sc2 so why would we play sc2
17:10:39 <Fuuzetsu> chare: You went from ‘clone’ to ‘successor’ pretty quickly.
17:10:58 <briennetheblue> chare: i'm interested in writing games in haskell but successor to SCBW is a bit of a tall order :)
17:11:03 <chare> they are the same thing fuuzetsu
17:11:25 <chare> briennetheblue why would that be any different from whatever you're thinking
17:13:13 <chare> fuuzetsu so you going to help?
17:13:22 <briennetheblue> chare: SCBW isn't just a game, it's an incredibly successful game, that's all i meant
17:13:42 <chare> briennetheblue: and you want to see sc2 replace scbw? THAT IS SCARY
17:14:13 <briennetheblue> chare: well, i like SC2, so i'll say no more... :)
17:14:39 <chare> briennetheblue wtf how can you like shitty SC2
17:17:34 <chare> briennetheblue its the fault of people like you that god damn sc2 is considered acceptable
17:18:31 <geekosaur> can we take the game wanking to #haskell-blah please?
17:18:34 <briennetheblue> chare: lmao.  i dont think this discussion is suitable for #haskell though
17:18:58 <chare> so then make scbw sucessor in haskell?
17:19:06 <moops> is there a way to use one monads >>= inside another
17:19:50 <OODavo> moops: What would that mean, exactly?
17:20:12 <tnks> this sounds like a question that leads to monad transformers.
17:20:24 <moops> inside do notation i have an IO a and an Either b c
17:20:27 <OODavo> Possibly a transformer situation, yeah.
17:20:30 <moops> i want to get the value out of both of them
17:20:35 <moops> and combine them
17:20:49 <moops> the result is Either b c
17:21:08 <OODavo> Well, you can't really get a result from an IO that isn't still some kind of IO.
17:21:16 <moops> err
17:21:20 <moops> the result is IO (Either b c), i mean
17:22:06 <moops> actually hmm they are different types
17:22:36 <monoidal> moops: perhaps you are searching for ErrorT b IO
17:22:59 <monoidal> moops: this is a monad that allows both IO and either-like errors.
17:23:17 <triliyn> ErrorT is Either String, not Either, isn't it?
17:23:30 <moops> sounds perfect, thanks
17:23:32 <monoidal> no, it takes a parameter
17:24:06 <alkabetz> The parameter has some string-related type class constraint on it, IIRC
17:24:10 <OODavo> moops: Sample usage here. http://evan-tech.livejournal.com/246130.html
17:26:07 <chare> so lets talk about haskell dominating, how can we get haskell to be used on android, ios, etc.., is that even possible to compile to android and ios?
17:27:35 <triliyn> http://www.reddit.com/r/haskell/comments/1lboh4/announcing_ghc_ios/
17:32:00 <chare> triliyn so how does the garbage collector work on ios?
17:32:30 <triliyn> chare: I don't know, I haven't actually used or researched it
17:32:57 <chare> how can you not know!!!!
17:47:30 <bgamari> Is there a way to get cabal to build just a single project in a sandbox?
17:47:38 <carter> in what sense?
17:48:50 <hpc> the newest cabal has sandboxing, and there's also always cabal-dev
17:48:55 <hpc> it depends on what you're doing
17:50:51 <briennetheblue> sorry, asking one last time since the channel is slow now -- is there any way in which parametricity helps prove "flip ((. f) . g)" = "flip g . g", or do you have to prove it though pure calculation?
17:51:14 <briennetheblue> "flip g . f" rather
17:52:05 <hpc> :t \f g -> flip ((. f) . g)
17:52:06 <lambdabot> (b -> b1) -> (a -> b1 -> c) -> b -> a -> c
17:53:05 <hpc> briennetheblue: just eyeballing the type i can say there's only one "defined" definition for that type
17:53:17 <hpc> i have no idea about the actual formal proof though
17:53:51 <briennetheblue> hpc: that's what i suspect, i just need an argument that makes it legit
17:54:13 <hpc> uh
17:54:27 <hpc> you can use djinn to enumerate the values of that type
17:54:46 <hpc> show there's only the one total definition
17:54:55 <hpc> then show that both expressions are the same type
17:54:55 <briennetheblue> hmm
17:55:08 <hpc> and they are both total, ergo they are the same
17:55:21 <hpc> djinn may or may not be cheating
17:55:41 <briennetheblue> i'm honestly not sure how to do that :(
17:55:48 <hpc> me either
17:56:05 <briennetheblue> haskell is too hard guys
17:56:17 <hpc> heh
17:56:48 <nisstyre> @djinn (b -> b1) -> (a -> b1 -> c) -> b -> a -> c
17:56:48 <lambdabot> f a b c d = b d (a c)
17:57:17 <briennetheblue> i just "feel" there's a better way where but i can't grasp it :/
17:57:27 <briennetheblue> *way here
17:59:41 <hpc> briennetheblue: perhaps you should start from "what is every way i can produce a value of type c"
18:00:22 <hpc> and work backwards from there to show the unique definition
18:00:23 <hpc> or something
18:00:31 * hpc shouldn't math when sleepy
18:00:56 <hpc> i leave you in the capable hands of lambdabot
18:01:05 <hpc> @faq can haskell help briennetheblue learn haskell?
18:01:05 <lambdabot> The answer is: Yes! Haskell can do that.
18:01:28 <briennetheblue> @faq is haskell impossible
18:01:28 <lambdabot> The answer is: Yes! Haskell can do that.
18:01:47 <moops> haha
18:01:48 <Fuuzetsu> @faq Can Haskell stop people using ‘@faq’?
18:01:49 <lambdabot> The answer is: Yes! Haskell can do that.
18:02:56 <briennetheblue> clearly there needs to be a @fqa too "No.  Haskell is a research language that has little to no relevance in the real world."
18:02:58 <briennetheblue> :P
18:03:36 <ion> Perhaps a command that says that about any given language.
18:06:11 <alkabetz> @fqa PHP
18:06:11 <lambdabot> The answer is: Yes! Haskell can do that.
18:06:17 <alkabetz> :(
18:06:26 <briennetheblue> hpc: i don't know, i can show it by computation: https://github.com/soapie/novelties/blob/master/novelties.lhs i'm just feeling that there's a better way
18:07:05 <briennetheblue> oh... there is a fqa... never mind then :P
18:08:20 <geekosaur> no, there isn't an fqa. the bot does edit correction if only one possible match within 3 errors (an error being an insertion, a deletion, or a different character)
18:08:30 <briennetheblue> ah ok
18:08:35 <geekosaur> @gaq foo
18:08:35 <lambdabot> The answer is: Yes! Haskell can do that.
18:09:00 <Fuuzetsu> briennetheblue: call it ‘@fuq’
18:09:10 <briennetheblue> :p
18:09:56 <Fuuzetsu> within 3 errors…
18:09:57 <Fuuzetsu> @q test
18:09:57 <lambdabot> Maybe you meant: queue-topic quit quote v @ ? .
18:10:04 <Fuuzetsu> isn't this 2 insertions?
18:10:10 <Fuuzetsu> @faqqq test
18:10:10 <lambdabot> The answer is: Yes! Haskell can do that.
18:10:34 <Fuuzetsu> @aaa test
18:10:34 <lambdabot> Maybe you meant: faq ask arr
18:10:42 <Fuuzetsu> @aa
18:10:42 <lambdabot> Maybe you meant: wn v rc pl id faq do bf ask arr @ ? .
18:10:47 <Fuuzetsu> *shrug*
18:11:30 <triliyn> Fuuzetsu: if there is more than one existing command within that delta distance, it won't autocorrect
18:12:10 <briennetheblue> @faq prove that flip ((. f) . g) = flip g . f
18:12:11 <lambdabot> The answer is: Yes! Haskell can do that.
18:12:37 <briennetheblue> lambdabot stop teasing me :(
18:13:27 <alkabetz> Hmm, I wonder if @hackage sbv can do that
18:13:34 <alkabetz> @hackage sbv
18:13:34 <lambdabot> http://hackage.haskell.org/package/sbv
18:14:01 <briennetheblue> ohh... i'll try that...
18:14:41 <briennetheblue> Z3 save me from proving stuff
18:14:47 <alkabetz> Hahaha
18:15:51 <ijp> what was the original technical reason for the monomorphism restriction?
18:17:10 <Fuuzetsu> Something or the other.
18:17:38 <jmcarthur> ijp: the idea was to prevent confusion. when a top level value is polymorphic then there might be more than one copy of it generated in memory (for different types), and the costs are not always obvious
18:17:51 <Fuuzetsu> ijp: http://www.haskell.org/onlinereport/decls.html#sect4.5.5
18:18:00 <geekosaur> not sure it was technical. the pracrical reason is that it can prevent sharing that you might otherwise expect from making a binding
18:18:33 <ijp> Fuuzetsu: ah, I didn't know it was in the report
18:19:25 <ijp> jmcarthur: I see, I think
18:22:03 <briennetheblue> i guess i'm actually going to have to read "theorems for free" and try to understand it
18:24:03 <briennetheblue> what kind of beastly language is this
18:24:15 <khyperia> Heh, I decided to read through some compiler class's powerpoint to help me learn compilers, one slide said "Using C code as output from your compiler is a growing trend (e.g. GHC)"
18:24:24 <jmcarthur> haha
18:24:42 <jmcarthur> ghc used to have a C backend. i think it's even still there?
18:24:47 <Fuuzetsu> It's still there.
18:24:51 <jmcarthur> but it's not the default, or even commonly used anymore
18:24:54 <Fuuzetsu> -C or something
18:24:59 <nisstyre> C-- ?
18:25:02 <jmcarthur> -fvia-c is what it used to be
18:25:07 <jmcarthur> C-- is different
18:25:12 <nisstyre> it (used to?) use gcc
18:25:12 <jmcarthur> it's not C
18:25:23 <jmcarthur> right, that was what -fvia-c did
18:25:23 <nisstyre> jmcarthur: I know
18:25:34 <nisstyre> I thought it used to have something like C-- too
18:25:40 <Fuuzetsu> it still uses C--
18:25:47 <jmcarthur> C-- is a normal part of the pipeline, but is not C
18:25:51 <nisstyre> ok
18:25:55 <jmcarthur> it's more assembly-like than C
18:25:57 <nisstyre> and LLVM too, right?
18:26:04 <jmcarthur> yeah, llvm is an alternative backend
18:26:24 <jmcarthur> the main two are the native code generator and the llvm backend. both take place *after* C--
18:27:24 <jmcarthur> haskell -> core -> stg -> c-- -> ncg/llvm/c
18:28:47 <jmcarthur> the c backend did crazy things like postprocess the assembly generated from gcc using a gigantic perl script called the Evil Mangler
18:29:08 <khyperia> wait, wait, that slide I read that on says "Fall 2013"... either they're just using a bad example for sake of simple example or somebody needs to update their knowledge.
18:29:54 <jmcarthur> khyperia: i once took a course in which the teacher claimed that haskell can only be interpreted, never compiled, so don't be too bitter about your class ;)
18:30:13 <khyperia> Heh.
18:30:37 <khyperia> (Although it's just some slides I'm reading through, I'm not actually in the class - in fact, I'm still in high school)
18:30:42 <jmcarthur> i see
18:30:54 <jmcarthur> man i wish i had looked at haskell in high school
18:30:55 <sipa> compiling to C a growing trend.... even C++ doesn't do that anymore...
18:31:17 <jmcarthur> yeah it's more of a dying thing, from what i've seen
18:31:31 <ijp> js is the new hot compilation target
18:31:44 <jmcarthur> ijp: well... that doesn't make me too happy
18:31:59 <ijp> me neither, but so little of computing does
18:32:38 <Kron> I'll be honest, I thought ALL interpreted languages could be compiled until like a month ago
18:32:48 <jmcarthur> i wish browsers would adopt some low level ish thing (and NaCl doesn't count, since it by design relies on what the end hardware actually is)
18:32:52 <Kron> now I hear stuff like python isn't compiled and it boggles my mind
18:32:57 <jmcarthur> Kron: it could be
18:33:03 <jmcarthur> there is nothing stopping it
18:33:10 <ijp> jmcarthur: asm.js might be that, but it's not really low enough
18:33:11 <Kron> yeah, it can be
18:33:14 <Kron> but people... don't
18:33:15 <jmcarthur> it might not generate a particularly efficient result, but still
18:33:22 <Kron> like the default is to run the code interpreted or something
18:33:25 <Kron> I used to compile all my lisp
18:33:37 <Kron> if I'm wrong I'd love to be told so
18:33:40 <jmcarthur> Kron: i think a large part of it is that it's hard to justify the work when the programming model would still require so much runtime support
18:33:43 <geekosaur> perl is effectively not compileable
18:33:57 <geekosaur> but perl is something of a special case
18:34:05 <Kron> hmmm. That's really interesting, I have trouble mentally modelling a system that's too difficult to compile or 'not worth it'
18:34:12 <jmcarthur> geekosaur: i beg to differ. the parsing issue is not damning... you just need a JIT ;)
18:34:14 <ijp> I think befunge is only compilable if you count letting it recompile itself at runtime
18:35:07 <jmcarthur> Kron: well, i was being overly dismissive. you could actually get real benefits from compiling python, really.
18:35:19 <jmcarthur> Kron: it's mainly just that nobody wants to bother, i guess
18:35:28 <jmcarthur> Kron: pypy does neat stuff, at least
18:36:06 <Kron> noted!
18:37:04 <jmcarthur> Kron: to over-simplify: it executes a function and traces its execution, then basically compiles the trace so that on later runs the function will be faster.
18:37:25 <jmcarthur> Kron: and a lot of things are specialized away since it's compiling the trace dynamically
18:37:54 <khyperia> Question from that same slide deck - "[blah blah] is O(n), while [blah blah] is NPC" - what is NPC? Google just says non-player character, heh.
18:38:21 <triliyn> NP-Complete I think
18:39:07 <nisstyre> geekosaur: the Perl grammar is Turing complete IIRC
18:39:31 <jmcarthur> nisstyre: wha-?
18:39:41 <Iceland_jack> What isn't Turing complete :)
18:39:46 <nisstyre> jmcarthur: http://www.perlmonks.org/?node_id=663393
18:39:53 <moops> C
18:39:56 <moops> isnt :P
18:40:04 <jmcarthur> nisstyre: it is common folklore (maybe even true) that perl is not parsable (requires runtime information to parse some bits correctly)
18:40:30 <jmcarthur> nisstyre: so i guess in that sense it is turing complete, but... it's kind of a sneaky way to make a grammar turing complete
18:40:38 <nisstyre> jmcarthur: the person who wrote that is using a very narrow definition of "parse" and "grammar"
18:40:48 <nisstyre> well, not very narrow
18:40:50 <nisstyre> but narrow
18:41:05 <jmcarthur> yeah this is the argument i expected to see
18:41:22 <jmcarthur> it's not really that perl's grammar is turing complete so much as it is dependent on runtime behavior
18:41:29 <nisstyre> yeah I guess
18:41:33 <jmcarthur> although the latter basically implies the former
18:42:22 <jmcarthur> it's really worse than that, since runtime behavior can be influenced by its environment
18:43:06 <jmcarthur> i also think the argument is kind of silly
18:43:22 <nisstyre> jmcarthur: it is silly, it's not meant to be serious
18:43:35 <nisstyre> although there's a nugget of truth in that perl is hard to reason about I guess
18:43:45 <Kron> does anyone have any experience with working with SDL on Windows?
18:43:50 <jmcarthur> it assumes a particular kind of AST representation. there are other representations to which you could target statically
18:43:50 <Kron> (through Haskell I mean)
18:44:57 <jmcarthur> i think there is no controversy over whether perl is complicated
18:45:03 <nisstyre> jmcarthur: it fits well with the design goals of perl though
18:45:08 <nisstyre> to be like natural language
18:45:22 * Kron slow claps
18:45:26 <jmcarthur> that's really a design goal of perl?
18:45:31 <nisstyre> yeah
18:45:40 <nisstyre> larry wall wanted it to be like natural languages
18:45:44 <jmcarthur> well, in a sense it has achieved that. natural languages are *full* of things that don't make any sense ;)
18:45:51 <Kron> quite right :P
18:46:09 <briennetheblue> how do i show that "flip ((. f) . g) = flip g . f" without pure computation, is that possible, does parametricity help?
18:46:14 <nisstyre> http://www.wall.org/~larry/natural.html
18:46:27 <jmcarthur> briennetheblue: what do you mean by "without pure computation"?
18:46:47 <Iceland_jack> briennetheblue: You can use the definitions of (.) and flip
18:46:48 <glguy> Kron: Trevor Elliott has been working on that recently https://github.com/elliottt/hsSDL2
18:46:52 <jmcarthur> briennetheblue: you could always just normalize both sides
18:46:56 <Kron> maybe if you sort of work your way through the (.) definition with a substitution model?
18:46:56 <glguy> Kron: If you don't work it out you might shoot him an email
18:47:51 <Kron> thanks!
18:48:16 <Kron> is it... done?
18:48:23 <briennetheblue> by computation, i mean a proof like this: https://github.com/soapie/novelties/blob/master/novelties.lhs i'd just like if it's possible purely through just looking at the types
18:49:18 <Kron> hmm, if SDL's bindings are still being worked on then maybe it's better if I use OpenGL or something
18:49:24 <briennetheblue> a little bird tells me, there's a better way.. is that bird lying to me? :(
18:49:33 <jmcarthur> briennetheblue: you would have to prove that for a type there is only one possible inhabitant. in haskell, at least, _|_ inhabits every type, so this would only be possible for types that are otherwise impossible to inhabit
18:50:17 <jmcarthur> briennetheblue: i think equational reasoning is generally your friend for proving two expressions equal
18:50:26 <Kron> yay math!
18:52:00 <jmcarthur> briennetheblue: so, for example, in haskell, if i have two functions having types  (a -> b)  then i know they must both just be _|_.
18:52:41 <jmcarthur> briennetheblue: it's more interesting if you assume haskell is total, i guess
18:53:03 <briennetheblue> jmcarthur: by similar reasoning, there's only one (flip :: (a -> b -> c) -> b -> a -> c) right?
18:53:41 <jmcarthur> briennetheblue: i think so, if you assume totality. if you are talking about *real* haskell, then there could be at least two  (in fact, even more than that if you accept seq)
18:53:55 <Iceland_jack> @djinn (a -> b -> c) -> b -> a -> c
18:53:55 <lambdabot> f a b c = a c b
18:53:59 <johnw> briennetheblue: "proof" in this context is exactly the process of finding an implementation that satisfies the types; the types alone are simply theorems
18:55:14 <briennetheblue> i'm just wondering that, assuming totality, there's a very short proof that "flip ((. f) . g) = flip g . f"
18:55:20 <sclv> jmcarthur: what if i have three functions having those types? what then, huh, huh? :-P
18:55:21 <johnw> parametricity gives you laws that any such implementation must provide
18:55:39 <johnw> briennetheblue: yes, and you've given that proof using equational reasoning
18:56:01 <briennetheblue> is there no shorter way, just from looking at the types?
18:56:09 <jmcarthur> sclv: "two functions" was from the context of determining whether they are the same
18:56:25 <sclv> sorry i'm just being silly
18:57:04 <briennetheblue> i mean, if you have two a -> a, b -> b, they're of course equal, right?
18:57:10 <johnw> briennetheblue: I'm not quite sure what you mean; the proof depends upon the meaning of flip, and flip's type allows for only one unique implementation (up to unique isomorphism)
18:57:10 <Iceland_jack> Silliness is off-topic on #haskell.
18:57:44 <briennetheblue> just wondered if similar reasoning could simplify my proofy
18:57:57 <johnw> I thought your proof was spot on
18:58:29 <jmcarthur> briennetheblue: my intuition says that there is a proof by parametricity that any total functions of type (a -> a) must be the same, but i don't have the right knowledge to construct it.
18:58:38 <briennetheblue> i just "feel" like there's a sorter one, of course, i could be totally wrong :)
18:59:42 <Kron> I'm trying to install gloss via cabal, but it tells me I'm missing a C library called GL
18:59:47 <Kron> how exactly would I fix this?
18:59:57 <joelteon> install it
18:59:58 <geekosaur> by installing that library. what platform?
18:59:58 <nisstyre> Kron: GL as in opengl?
19:00:05 <Kron> I assume so
19:00:07 <geekosaur> GL is the main opengl library
19:00:07 <nisstyre> what operating system?
19:00:07 <Kron> ubuntu 13.04
19:00:14 <Kron> is it a package?
19:00:14 <nisstyre> apt-get install opengl ?
19:00:28 <Kron> no such package...
19:00:30 <geekosaur> you'd also need the dev package
19:00:35 <nisstyre> it might be part of a larger package
19:00:38 <nisstyre> or called something else
19:00:39 <geekosaur> but I don't think it's called opengl, for historical reasons
19:01:44 <briennetheblue> jmcarthur: exactly, i think there's a direct proof, i just don't have the knowledge to make it...
19:01:55 <briennetheblue> oh well
19:02:30 <Kron> should i install freeglut? there's no opengl packages
19:02:34 <Kron> *I
19:02:54 <sclv> i'm pretty sure that's the canonical example given with logical relations and parametricity.
19:02:55 <triliyn> Freeglut won't give you the GL stuff
19:03:03 <sclv> but it doesn't say they're operationally the same
19:03:08 <sclv> just that they 'act' the same.
19:03:15 <triliyn> It's just a windowing utility library
19:03:20 <Kron> ok
19:03:24 <sclv> because obviously there's a sense in which id and id . id . id are "different"
19:03:24 <Kron> hmm :(
19:03:38 <startling> sclv: is there?
19:03:44 <Kron> no I think it fixed it
19:03:52 <Kron> installing freeglut seems to at least have opengl in its dependencies
19:04:03 <Kron> it installed a whole mesh of mesa libraries and I think one of them had opengl
19:04:04 <Kron> thanks!
19:04:06 <triliyn> oh, I suppose that is possible
19:04:08 <startling> sclv: if we could evaluate things to normal form in haskell, they wouldn't be
19:04:09 <sclv> well if you have a nonoptimizing compiler and count cycles they are
19:04:19 <briennetheblue> johnw: btw, did you see my commentary on 'sequenceUntill's comments?
19:04:22 <startling> we can't, because undefined
19:04:43 <jmcarthur> in ghc, there is a sense in which those are different, but in a language whose value forms are reduced under lambdas, there is not.
19:04:51 <briennetheblue> err, until rather
19:05:11 <geekosaur> libgl1-mesa-glx-dev is the package you want, apparently
19:05:17 <johnw> briennetheblue: not yet
19:05:23 <Kron> thanks geekosaur!
19:05:27 <jmcarthur> how many inhabitants does   newtype Foo = Foo (Foo -> Bool)  have?
19:05:59 <jmcarthur> i'm terrible at reasoning about recursive data structures in this way, and this is a pretty crazy one since it is not strictly positive
19:06:00 <geekosaur> actually just libgl1-mesa-dev
19:06:14 <geekosaur> odd they split up the runtime but not the dev package
19:06:27 <startling> jmcarthur: I think it's isomorphic to Nat
19:06:52 <jmcarthur> startling: so you could construct zero and succ values in terms of Foo?
19:06:54 <startling> well, Either Nat Nat
19:06:59 <briennetheblue> johnw:  i think the comment is misleading, it's until one of them yields a value satisfying the predicate rather than "until one of them yields a value failing the predicate", right?
19:07:08 <startling> hmmm, maybe not.
19:07:11 <jmcarthur> startling: i tried that approach and failed
19:07:12 <startling> [Bool]?
19:07:13 <johnw> i think you're right
19:07:15 <johnw> can you pull request me?
19:07:19 <startling> jmcarthur: I think it's [Bool]
19:07:24 <startling> well, nonempty lists of Bool
19:07:31 <startling> First there's const True and const False
19:07:52 <briennetheblue> johnw: ok, i'll make a pull request :)
19:07:59 <startling> hmm, maybe not.
19:08:00 <sclv> its an unfold on bool maybe.
19:08:01 <Kron> does anyone know what the LLVM is? It's telling me it has no idea what my LLVM version is and have I even installed it?
19:08:04 <startling> jmcarthur: this is a tricky one. :(
19:08:18 <startling> Kron: LLVM is a suite of compiler tools
19:08:20 <sclv> if I have a Foo, I can take it apart to run it. Now I can feed it to itself
19:08:24 <sclv> and I can either give back an answer
19:08:34 <sclv> or i can run it, and give an answer based on what I get from running it.
19:08:41 <Kron> so I just sudo apt-get install llvm?
19:08:45 <startling> Kron: maybe
19:08:46 <sclv> but hmm… the run is the run i already defined.
19:08:54 <startling> Kron: you might need llvm-dev or something
19:08:55 * hackagebot dual-tree 0.2 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.2 (BrentYorgey)
19:08:57 * hackagebot HList 0.3.0.1 - Heterogeneous lists  http://hackage.haskell.org/package/HList-0.3.0.1 (AdamVogt)
19:08:58 <startling> Kron: what are you doing?
19:08:58 <Kron> ok!
19:09:00 <sclv> what's a nontrivial inhabitant?
19:09:04 <jmcarthur> startling: denotationally it's equivalent to Fix Set, but i don't think that helps because while i can encode the natural numbers in terms of Fix Set, i don't think i can do the same for the original, or at least not in a computable way
19:09:09 <startling> sclv: not _|_, I think
19:09:36 <sclv> ok out of total inhabitants, besides the const case, what is there?
19:09:48 <Kron> startling: trying to get some basic haskell graphics working for some really simple game twiddling
19:09:59 <jmcarthur> all i know for sure is const True, const False, and _|_
19:10:11 <sclv> right i'm not seeing any others at the moment
19:10:40 <jmcarthur> and in haskell there's the two kinds of _|_, since it's a function and we have seq
19:10:48 <Kron> even after installing llvm-dev it still tells me it can't figure out my llvm-version... why does it even need llvm?
19:10:48 <briennetheblue> i wish github would show where the 80th character line was...
19:10:51 <sclv> the Foo in the contravariant position looks a bit voidish
19:11:02 <startling> how many functions S -> Bool are there, in terms of |S|?
19:11:09 <startling> |S|^2?
19:11:18 <jmcarthur> startling: if it's total, S^2
19:11:40 <startling> jmcarthur: yeah. so, if Foo has n inhabitants it has n^2 inhabitants
19:11:42 <sclv> so we have Foo = Foo^2 ?
19:11:52 <startling> so it's a big infinity
19:11:59 <jmcarthur> sclv: if the recursive definitions work that way, yes
19:12:07 <startling> is it countable? I don't think so.
19:12:19 <startling> obviously there's not only 1 inhabitant.
19:12:22 <startling> or 0.
19:12:24 <sclv> right.
19:12:35 <sclv> but name something more complicated than const!
19:12:43 <sclv> ignoring bottoms
19:12:44 <startling> const True, const False
19:12:49 <startling> at least two inhabitants
19:12:53 <sclv> yes
19:13:02 <Kron> gah and now cabal-install won't install llvm either...
19:13:11 <jmcarthur> the trouble is i have to be able to inspect the argument, and the only way to do that is to apply it something
19:13:17 <startling> there's also \f -> if f (const True) then const True else const False
19:13:38 <sclv> you mean then True else False
19:13:40 <jmcarthur> so a nontrivial value would have to contain something in its closure that can generate Foos
19:13:45 <startling> sclv: yeah, youre right
19:14:32 <johnw> briennetheblue: in Agda, your theorem following from the definition; maybe this is what you meant?  https://gist.github.com/7330231
19:15:19 <johnw> so, flip (∘ f) ∘ g) ≡ flip g ∘ f, is a free theorem given by the type of flip
19:15:22 <sclv> wait but there are two functions () -> Bool
19:15:41 <johnw> if you can implement flip, you've proven that theorem for free
19:15:43 <sclv> its 2^S!
19:15:45 <sclv> we're backwards
19:15:56 <jmcarthur> ah right, my bad
19:15:58 <jmcarthur> i should have caught that
19:16:12 <jmcarthur> 2^S ~ denotation for sets of S
19:16:23 <briennetheblue> johnw: hm, yes, i suspected that it would follow for free.  i'm not familiar with agda though
19:16:33 <sclv> and then we get foo = 2^foo, which is… more interesting
19:16:37 <jmcarthur> so Foo ~ Fix Set, although again, i don't think it helps
19:16:59 <johnw> briennetheblue: in this case, the fact that my proof is just "refl" means that the type of my theorem is proven by what's known about flip
19:17:04 <jmcarthur> Fix Set is easier to think about, but the inhabitants i can invent there are not computable if i try to port them directly to Foo
19:17:06 <Kron> is there any way to remove anything from cabal install?
19:17:13 <Kron> can I cabal uninstall anything?
19:17:37 <johnw> so the answer to your original question, "how do I prove..."; the answer is: you don't need to :)
19:17:52 <briennetheblue> johnw: i see.  in any case, it's a lot shorter than my current derivation :)
19:17:58 <briennetheblue> johnw: exactly!
19:18:00 <startling> Kron: you can ghc-pkg unregister but it sucks
19:18:06 <startling> Kron: you can use cabal sandboxes instead
19:18:09 <Kron> do I get any disk space back? :$
19:18:15 <geekosaur> Kron: no. you can ghc-pkg unregister a library and then remove the package's directory under ~/.cabal/lib (or platform equivalent)
19:18:16 <startling> nope
19:18:19 <Kron> I accidentally cabal installed a bunch of things
19:18:23 <Kron> to try and fix this problem
19:18:25 <Kron> I want to undo it :(
19:18:33 <Kron> what if I sudo apt-get remove cabal?
19:18:34 <startling> Kron: you can rm -rf ~/.ghc to delete everything
19:18:39 <Kron> okay
19:18:52 <Kron> is there a reason the system is implemented like that?
19:18:58 <startling> No.
19:19:01 <geekosaur> because cabal is not a package manager
19:19:08 <startling> geekosaur: that's not an answer.
19:19:12 <geekosaur> it's a wrapper for ghc-pkg
19:19:19 <startling> thr question is "why isn't cabal a package manager?"
19:19:22 <Kron> okay, can I uninstall with ghc-pkg?
19:19:32 <startling> Kron: nope! you can only unregister
19:19:33 <Kron> cabal's a library
19:19:33 <geekosaur> and ghc-pkg doesn't know anything about package management, and it's the only place caball-install can get package information from
19:19:53 <Kron> I understand that cabal-install is not cabal
19:19:59 <geekosaur> (this is also why installing executables is kinda stupid; ghc-pkg doesn't know about them, so cabal-install can't keep track of them)
19:20:23 <startling> So, your answer is: things were built in a kind of half-assed way at first and never fixed.
19:20:33 <Kron> :(
19:20:40 <startling> Sorry.
19:20:42 <Kron> I've yet to get a single thing properly cabal installed
19:20:50 <frx> @src Monad fmap
19:20:51 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:20:56 <startling> Kron: what are you trying to do?
19:20:57 <Kron> not a hash table, not the network libraries, not the opengl stuff
19:21:02 <startling> @src liftM -- frx
19:21:02 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:21:08 <Kron> i'm just trying to install gloss at this point
19:21:10 <startling> @src liftM
19:21:11 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:21:12 <geekosaur> I think there is a proposal to make cabal-install do its own package tracking, so it can handle stuff like this better
19:21:28 <Kron> it tells me this:
19:21:29 <geekosaur> also so it can properly deal with stuff like ghc-js
19:21:29 <Kron> <no location info>:
19:21:30 <Kron>     Warning: Couldn't figure out LLVM version!
19:21:30 <Kron>              Make sure you have installed LLVM
19:21:30 <Kron> ghc: could not execute: opt-3.0
19:21:50 <startling> Kron, sudo apt-get install llvm
19:21:55 <Kron> I've installed llvm on apt-get and I tried cabal-installing llvm
19:22:01 <Kron> but cabal-install can't install llvm either
19:22:07 <Kron> I installed llvm-dev too
19:22:09 <startling> cabal-installing llvm won't be the right thing
19:22:21 <startling> Kron, ugh, how did you install GHC?
19:22:33 <Kron> sudo apt-get install ghc
19:22:41 <startling> that's strange.
19:22:42 <Kron> there's no haskell platform on my repositories
19:22:51 <startling> try uninstalling ghc and reinstalling, with llvm installed
19:22:54 <geekosaur> nope, ubuntu stopped packaging it :(
19:23:05 <Kron> :(
19:23:15 <Kron> I just want to get anything at all to work, this last week has been somewhat demoralizing
19:24:40 <briennetheblue> johnw: sent you a pull request
19:25:11 <briennetheblue> johnw: i'm a little tipsy right now but i hope it's accurate :)
19:25:52 <Kron> There are problems in package QuickCheck-2.6:
19:25:53 <Kron>   dependency "random-1.0.1.1-048316c239de82db6e182c94b6cf4e19" doesn't exist
19:25:55 <sclv> jmcarthur: so what if we read our const functions back into "fix set"?
19:26:01 <Kron> ... I'm not sure I reinstalled GHC properly
19:26:05 <johnw> briennetheblue: thanks, will upload the change now
19:26:09 <sclv> is that saying the fixpoint of set is either all or none?
19:27:32 <copumpkin> Mu Set?
19:27:40 <johnw> sclv: saw your webcast today, nice job
19:27:47 <sclv> :-)
19:28:07 <ion> Webcast?
19:28:08 <jmcarthur> sclv: nope, i don't think so
19:28:25 <jmcarthur> sclv: i think the denotation angle is a dead end for discovering inhabitants
19:28:31 <Kron> ... now it won't even give me proper error messages
19:28:33 <Kron> it still fails
19:28:36 <sclv> right. i'm now saying assume we have the inhabitants
19:28:39 <sclv> all of them
19:28:46 <sclv> what does that say _about_ the denotation?
19:28:55 <sclv> or it just doesn't translate
19:28:58 * hackagebot monad-extras 0.5.1 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.5.1 (JohnWiegley)
19:28:59 <johnw> ion: http://rogueleaderr.com/post/66018558718/a-interview-4-gershom-bazerman-organizer-of#disqus_thread
19:29:04 <ion> thanks
19:29:25 <jmcarthur> something something computability something something?
19:29:37 <startling> jmcarthur: maybe there's only 4
19:29:47 <startling> no, I'm wrong.
19:29:48 <sclv> yeah constructiveness mumble mumble
19:29:58 <Kron> okay uninstalling and reinstalling cabal-install returned me back to the llvm error message which is better than no error message
19:30:11 <startling> jmcarthur: I think maybe it's a noncomputable number
19:30:21 <jmcarthur> the number of inhabitants?
19:30:26 <startling> yeah.
19:31:54 <Kron> okay, changing tacks: does anyone know how to install the Network library?
19:32:10 <startling> cabal install network or whatever
19:32:23 <startling> Kron, changing tacks won't work in this case, I think
19:32:24 <sclv> it comes with the platform
19:32:28 <Kron> okay, I'll try that
19:32:31 <Kron> oh?
19:32:48 <startling> I don't think Kron has the platform.
19:32:58 <Kron> I don't :$
19:33:04 <Kron> there is no platform in my repositories
19:33:08 <Kron> is there anywhere I can get it?
19:33:33 <Kron> ... I think cabal install network actually worked! o_o
19:33:38 <Kron> no error messages at the least
19:34:05 <Clint> you could have done apt-get install libghc-network-{dev,doc,prof}
19:34:18 <Kron> hmmm
19:34:24 <Kron> how do I use this in code? import Network?
19:35:19 <startling> Kron: great! yep.
19:35:32 <Kron> yeah that seems to have removed some of the error messages! :D
19:35:39 <Kron> so presumably something is happening now
19:35:45 <startling> Kron, there's a package called 'network'; it provides the modules 'Network', 'Network.BSD', etc
19:36:27 <Kron> i'm basically trying to get this to work: http://cogsandlevers.blogspot.ca/2013/05/a-tcp-server-haskell-example.html
19:36:32 <Kron> but it seems to involve a lot of libraries
19:36:41 <Kron> where does hSetBuffering come from?
19:36:56 <geekosaur> System.IO
19:37:08 <geekosaur> which is in base, which is part of ghc
19:37:09 <Kron> okay!
19:37:23 <Kron> forkIO? echoImpl?
19:37:30 <Kron> is there a way I can ask ghc this stuff?
19:37:45 <startling> ugh, I can't believe someone would write a blog post about code without showing what they imported.
19:38:03 <Iceland_jack> Kron: :i
19:38:04 <startling> Kron: forkIO is System.IO, I think. echoImpl is defined right there.
19:38:05 <geekosaur> hayoo never heard of echoImpl
19:38:10 <geekosaur> ah
19:38:21 <Iceland_jack> Prelude> :i forkIO
19:38:21 <Iceland_jack> forkIO :: IO () -> IO ThreadId  -- Defined in `GHC.Conc.Sync'
19:38:24 <Kron> it still says they're not in scope
19:38:38 <Kron> ghci> :t forkIO
19:38:39 <Kron> <interactive>:1:1: Not in scope: `forkIO'
19:38:41 <Kron> err
19:38:42 <Iceland_jack> Kron: forkIO is from Control.Concurrent
19:38:46 <geekosaur> correct place to import that from is Control.Concurrent
19:38:51 <Kron> ghci> :i forkIO
19:38:51 <Kron> Top level: Not in scope: `forkIO'
19:38:53 <Iceland_jack> echoImpl is not an actual thing
19:38:54 <Kron> hmmmm ok
19:38:59 * hackagebot monad-extras 0.5.2 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.5.2 (JohnWiegley)
19:39:01 <geekosaur> ad ghci can only tell you where it's from if it's imported
19:39:08 <geekosaur> @where hayoo
19:39:08 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
19:39:12 <Kron> okay! that took care of forkIO
19:39:14 <geekosaur> ^^ use this to find stuff
19:39:22 <Kron> now only one error message for echoImpl
19:39:23 <Iceland_jack> Yes, use Hoogle or Hayoo
19:39:29 <triliyn> echoImpl is from later on in the blog post
19:39:50 <Kron> I'll try
19:40:05 <Iceland_jack> Kron: Note what triliyn said
19:40:29 <Kron> ahhhh
19:40:29 <Kron> okay
19:40:30 <Kron> thanks
19:40:58 <Kron> thanks :D
19:41:18 <Iceland_jack> You're welcome
19:41:24 <Iceland_jack> now go forth and Haskell
19:41:48 <ion> Better yet: implement one in another
19:42:05 <Iceland_jack> hah
19:42:18 <Iceland_jack> I would not like to be the poor soul implementing Haskell in FORTH :)
19:42:27 <Iceland_jack> The other way around would be perfectly fine
19:43:07 <Kron> okay, this seems to actually work
19:43:09 <geekosaur> I think I'd rather do it in Forth than C
19:43:17 <ion> But i want to run Haskell on my Forth machine, and Forth on my Haskell machine.
19:43:20 <Kron> I'll have to build a test client and stuff later :)
19:44:20 <geekosaur> wouldn't be very fun either way, but I can think of ways to leverage Forth to make it easier (well, assuming I refreshed memories from bog knows how far back; last time I did any significant Forth was when I helped out a Conference Tree installation...)
19:45:50 <simpson> Forth is fun.
19:47:47 <khyperia> what's the difference between `liftA` and <$> ?
19:48:08 <geekosaur> :t (<$>)
19:48:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:48:12 <geekosaur> :t liftA
19:48:13 <lambdabot> Applicative f => (a -> b) -> f a -> f b
19:48:30 <geekosaur> so just the constraint
19:48:33 <geekosaur> :t liftM
19:48:33 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
19:48:41 <khyperia> But doesn't "class (Functor a) => Applicative a where ..."?
19:48:43 <geekosaur> again just the constraint
19:48:45 <Iceland_jack> khyperia: Yes
19:54:54 <Kron> I think I got gloss to install! I used llvm-3.0 instead of the latest llvm
19:55:47 <startling> khyperia, it's so you can write the Applicative instance and then write instance Functor Whatever where fmap = liftA
19:56:07 <khyperia> ah
19:56:50 <khyperia> Possibly also for a sort of "liftA1" part to all the liftA2, liftA3, etc. methods
19:57:51 <roconnor> @src liftA
19:57:51 <lambdabot> liftA f a = pure f <*> a
19:58:37 <roconnor> I suppose in some absurdly wrong code, f <$> a and pure f <*> a could be different.
19:59:15 <geekosaur> I think the idea is there could potentially be some optimization in the Applicative instance (but fiik what it might be given how close to Functor it is)
19:59:36 <roconnor> I suppose that is also true
20:01:38 <Kron> hmmmm, anyoen know how I can actually run any gloss-examples?
20:01:43 <Kron> *anyone
20:02:55 <Kron> anyone with any prior experience with gloss I mean. No-one should have to google stuff for me. D:
20:03:06 <edwardk> khyperia: liftA is a valid default definition for fmap in terms of pure and (<*>)
20:03:47 <edwardk> liftM defines it in terms of return and (>>=). liftW in terms of extract and extend from Comonad, etc.
20:07:32 <startling> Womonad?
20:08:06 <startling> Kron, ghc --make myexample.hs probably
20:08:35 <edwardk> startling: flip M over ;)
20:08:37 <Kron> I'm not sure where the examples ARE '^^
20:08:43 <startling> edwardk, heh
20:08:46 <Kron> I know they're probably compiled and neatly sitting... somewhere
20:08:48 <startling> Kron, oh, I see
20:09:07 <Kron> gloss-examples is a package with a bunch of examples in it
20:09:11 <Kron> and it seemed to cabal-install fine
20:14:33 <johnw> does anyone know about Data.Aeson hanging sometimes when encoding?
20:14:35 <Kron> http://hackage.haskell.org/package/gloss-examples-1.7.5.1 these
20:22:46 <startling> Kron: http://hackage.haskell.org/package/gloss-examples-1.8.0.2/gloss-examples.cabal
20:23:07 <startling> Kron, it installs executables gloss-bitmap, gloss-boids
20:23:28 <startling> etc
20:23:32 <startling> in ~/.cabal/bin
20:24:15 <enthropy> that's kind of unpleasant to have to repeat so many lines per example
20:24:45 <startling> cabal files are like that. :(
20:25:36 <enthropy> you can make one executable that includes all the different examples
20:25:39 <enthropy> probably
20:25:50 <enthropy> that would make it easier to have like demo slideshow
20:27:38 <startling> yeha.
20:27:51 <startling> or even gloss-example bitmap, gloss-exampe boids, etc
20:31:23 <tinyghost> is there a function somewhere like a fold but (a -> b -> Maybe a) and on Nothing it short-circuits on Nothing
20:32:28 <enthropy> @type \f z xs foldM f z xs :: Maybe a
20:32:29 <lambdabot> parse error on input `a'
20:32:34 <enthropy> @type \f z xs -> foldM f z xs :: Maybe a
20:32:35 <lambdabot>     Couldn't match expected type `t'
20:32:35 <lambdabot>                 with actual type `a1 -> b -> Maybe a1'
20:32:35 <lambdabot>       `t' is a rigid type variable bound by
20:33:01 <tinyghost> does foldM short circuit?
20:33:31 <Iceland_jack> @ty foldM ?f ?x ?y `asAppliedTo` Just undefined
20:33:31 <lambdabot> (?f::a -> b -> Maybe a1 -> a, ?x::a, ?y::[b]) => Maybe a1 -> a
20:33:43 <Iceland_jack> @src foldM -- you tell me :)
20:33:43 <lambdabot> Source not found. I am sorry.
20:33:47 <Iceland_jack> sigh
20:33:51 <tinyghost> lol
20:33:53 <enthropy> @type \f z xs -> foldM f z xs `asTypeOf` Nothing
20:33:53 <lambdabot> (a -> b -> Maybe a) -> a -> [b] -> Maybe a
20:34:02 <tinyghost> oh!
20:34:06 <tinyghost> that is very cool
20:34:12 <tinyghost> thank you enthropy and Iceland_jack :)
20:34:39 <Iceland_jack> Thanks? I couldn't even get the source right!
20:34:59 <enthropy> tinyghost: might not be the right kind of short-circuiting
20:46:03 <lpaste> cb pasted “refactoring bind” at http://lpaste.net/95262
20:46:06 <chrisblake> ^ can someone help me refactor a function?
20:54:22 <cschneid> chrisblake: so an empty text should be treated as Nothing, otherwise, Just text?
20:54:33 <fizruk> chrisblake, is it text :: Maybe; text = textToMaybe (name user) ?
20:54:53 <chrisblake> cschneid: yup. why, can that also be refactored?
20:55:07 <chrisblake> fizruk: and yes, sorry
20:55:14 <chrisblake> it text's return type is Maybe Text
20:55:19 <chrisblake> I'll fix that now...
20:55:21 <cschneid> chrisblake: I'm a noob, I don't have much to say, other than understanding :)
20:55:27 <cschneid> chrisblake: ahh, hah, that did confuse me a bit
20:55:33 <lpaste> cb revised “refactoring bind”: “No title” at http://lpaste.net/95262
20:56:12 <fizruk> chrisblake, user is not of type Maybe a, so you can't use >>= with it
20:56:39 <fizruk> chrisblake, it should be just: text = textToMaybe (name user)
20:56:40 <chrisblake> fizruk: sorry, another error... (I'm simplifying the actual code I'm using, so that's why the typos)
20:56:55 <lpaste> cb revised “refactoring bind”: “No title” at http://lpaste.net/95262
20:57:23 <chrisblake> it's nonsensical when written like that, but I'm trying to grok monads a bit more, and see if I can write that in a better/applicative way
20:57:33 <bens> chrisblake: text = textToMaybe (name user) ?
20:57:55 <fizruk> chrisblake, yes you can do fmap name (Just user)
20:58:10 <fizruk> chrisblake, or equivallently name <$> Just user
20:58:25 <chrizz> can someone help me out with Pipes.ByteString, I'm trying to append "foo" to each line of a file. http://lpaste.net/95265
20:58:30 <chrisblake> fizruk: and what about textToMaybe?
20:58:31 <fizruk> chrisblake, a more realistic example would be with IO: n <- read <$> getLine
20:58:40 <johnw> how about: Just (name user)
20:58:42 <chrizz> not quite sure what to do once I have a FreeT (Producer ByteString m) m r
20:58:47 <fizruk> chrisblake, you just don't need it)
20:59:13 <fizruk> chrisblake, oh sorry
20:59:17 <chrisblake> fizruk: but I wanna return a maybe text
20:59:22 <chrisblake> fizruk: no, my fault, I messed up a bit.
20:59:24 <bens> chrisblake: maybe making text have type (Maybe User -> Maybe Text) would be more interesting
20:59:29 <chrisblake> I had revised it.
20:59:40 <fizruk> chrisblake, it's too early for me, can't think straight :)
21:00:02 <chrisblake> fizruk: heh, well thanks anyway :)
21:00:14 <chrisblake> bens: unfortunately, I can't do that in the current code base....
21:01:01 <fizruk> chrisblake, perhaps you should provide a more realistic example then?
21:01:14 <fizruk> sorry, I gotta go
21:04:01 <lpaste> chrisblake revised “refactoring bind”: “more realistic example” at http://lpaste.net/95262
21:04:29 <lpaste> chrisblake revised “refactoring bind”: “typo” at http://lpaste.net/95262
21:04:47 <chrisblake> bens: would you be able to help me refactor that? this is essentially what I'm trying to do.
21:05:08 <johnw> MaybeText { text = Just (name user) }
21:05:16 <bens> for textToMaybe the guard function in Control.Monad is nice for filtering out values
21:06:03 <bens> johnw: user :: Maybe User now
21:06:10 <johnw> ah
21:06:16 <johnw> MaybeText { text = name <$> user }
21:07:15 <chrisblake> johnw: but I also want it to give a Nothing, if the given Text string is null
21:07:20 <chrisblake> hence the textToMaybe usage
21:07:25 <bens> chrisblake: what you've got is fine, though user >>= (textToMaybe . name) is the same as fmap name user >>= textToMaybe (which looks nicer to me)
21:07:40 <johnw> oh, I see what you mean
21:08:07 <chrisblake> bens: is there, (out of curiosity) a way to do it applicatively?
21:08:08 <bens> and which brings it closer to being point-free, if you like that
21:08:18 <chrisblake> (and I really do like points free)
21:08:22 <bens> no, you need >>=
21:08:31 <jle`> hm. is it possible to implement a prolog-like dsl by simply using the monad instance of list?
21:08:41 <prophile> yup
21:08:42 <johnw> chrisblake: MaybeText { text = mfilter (not . T.null) (name <$> user) }
21:08:48 <bens> textToMaybe has the a -> m b form that fits >>=
21:08:54 <jle`> why do we even need prolog then
21:09:05 <chrisblake> oh, okay. I was wondering if there was a way to do it without >>=
21:09:13 <chrisblake> :t mfilter
21:09:14 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
21:09:21 <prophile> jle`: the list monad I think is more general
21:09:24 <chrisblake> oh, that's cool
21:09:27 <johnw> > mfilter (==2) (Just 2)
21:09:28 <lambdabot>   Just 2
21:09:29 <johnw> > mfilter (==2) (Just 3)
21:09:29 <prophile> and is going to clunk along in exponential time
21:09:31 <lambdabot>   Nothing
21:09:38 <prophile> whereas prolog is all horn clauses
21:09:47 <prophile> which you can jumble up to a result in linear time
21:09:47 <bens> :t guard
21:09:48 <lambdabot> MonadPlus m => Bool -> m ()
21:09:57 <bens> is another way
21:10:01 <jle`> prophile: ah that makes sense
21:10:30 <prooftechnique> prophile: jle`: My understanding is that List is just Prolog without unification :/
21:10:30 <chrisblake> bens: how would using it with guard look?
21:10:33 <prooftechnique> So broken Prolog :
21:10:35 <prooftechnique> *:D
21:10:53 <bens> if you like point-free you can look up the (>=>) function
21:11:02 <jle`> prooftechnique: what is "unification"? is there something i can read about it
21:11:05 <jle`> is it like fusion
21:11:13 <bens> chrisblake: t <$ guard (not $ T.null t)
21:11:22 <prophile> I prefer real fusion to the haskelly stuff
21:11:33 <prooftechnique> jle`: http://en.wikipedia.org/wiki/Unification_(computer_science)
21:11:38 <prooftechnique> Wiki explains it better than I would
21:11:50 <jle`> thanks :)
21:11:55 <johnw> bens: that's the same as mfilter (not . T.null) t
21:12:00 <bens> yep
21:12:06 <chrisblake> okay, cool
21:12:12 <bens> mfilter probably fits better
21:13:14 <chrisblake> so I rewrote textToMaybe as mfilter (not . T.null) because I need it elsewhere
21:14:04 <chrisblake> but which form is "better": fmap name user >>= textToMaybe or user >>= (textToMaybe . name) ?
21:15:04 <johnw> chrisblake: i would go with the latter
21:15:13 <johnw> maybe even: textToMaybe . name =<< user
21:15:17 <prooftechnique> I would go with name <$> user >>= textToMaybe, but just because I think it looks more like a pipeline
21:15:28 <bens> it's down to taste, I like the former because you only have to read it in one direction
21:16:02 <chrisblake> I do like the latter form better, but bens right about one-way readability
21:16:12 <chrisblake> and what prooftechnique said is the same, too
21:16:13 <bens> you can write makeMaybeText as (MaybeText . (fmap name >=> textToMaybe)) if you want
21:16:39 <chrisblake> bens: oh, I didn't know you could compose constructors like that
21:16:48 <chrisblake> does that work because it only has one field?
21:17:02 <prooftechnique> :t MaybeText
21:17:03 <lambdabot> Not in scope: data constructor `MaybeText'
21:17:22 <chrisblake> prooftechnique: http://lpaste.net/95262
21:17:25 <bens> though that's not in one direction any more, and you get used to jumping between l to r and r to l
21:17:29 <prooftechnique> Ah, okay
21:18:33 <prooftechnique> bens: To answer your question, though, yes, I think so. If you :t MaybeText in GHCi, it should say Maybe Text -> MaybeText
21:18:52 <bens> chrisblake: a constructor applies just like any function
21:19:02 <edwardk> jmcarthur: i managed to get the overmars and van leeuwen scheme to work
21:19:12 <bens> yeah, as prooftechnique says, check their type signatures
21:19:13 <prooftechnique> Oh, bens, I meant to highlight chrisblake :
21:19:15 <prooftechnique> *:D
21:19:59 <chrisblake> alright, cool. thanks guys :)
21:20:06 <bens> no worries :)
21:20:55 <lpaste> edwardk pasted “Overmars and van Leeuwen” at http://lpaste.net/95268
21:21:22 <edwardk> that uses a placeholder version of Array, but the 'pacing' is right in that insert never triggers one of those errors.
21:21:58 <desheng> if "Just x" brings x into the Maybe monad, what function (is it built in?) brings x into the List monad, giving [x] ? (other than, let f x = [x])
21:22:15 <johnw> (:[])
21:22:17 <johnw> the monkey operator
21:22:20 <prooftechnique> :t (:[])
21:22:21 <lambdabot> a -> [a]
21:22:24 <prooftechnique> See? :D
21:23:06 <prooftechnique> Though that's equivalent to f x = [x], so...
21:23:19 <bens> return works too...
21:23:25 <prooftechnique> True
21:23:29 <johnw> and pure
21:23:29 <Iceland_jack> I think (\x -> [x]) looks clear enough :)
21:23:35 <Iceland_jack> but (:[]) is certainly cute
21:23:41 <johnw> there are packages that will name it cons for you
21:23:44 <johnw> like reducers
21:24:05 <desheng> thanks :)
21:24:24 <prooftechnique> Though I guess repeat works, too, it's just not the minimal example :D
21:24:55 <Iceland_jack> desheng: So you can use return (∷ a → [a]) as well
21:24:58 <jmcarthur> edwardk: nice!
21:25:01 <Iceland_jack> > return 5 ∷ [Int]
21:25:02 <lambdabot>   [5]
21:25:07 <Iceland_jack> > return 'a' ∷ [Int]
21:25:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:25:08 <lambdabot>              with actual type ...
21:25:13 <Iceland_jack> oops :P
21:25:14 <edwardk> jmcarthur: i was surprised at how clean the general pattern turned out in the end
21:25:15 <jmcarthur> edwardk: the million dollar question is, of course, how much slower is it now?
21:25:16 <Iceland_jack> > return 'a' ∷ String
21:25:17 <lambdabot>   "a"
21:25:24 <Iceland_jack> > return 'a' == (:[]) 'a'
21:25:25 <lambdabot>   True
21:25:27 <edwardk> jmcarthur: no idea. i haven't wired it up to an actual set/map
21:25:37 <edwardk> jmcarthur: just had an hour or so during a layover
21:25:43 <pavonia> > return 'a' == Just 'a'
21:25:44 <lambdabot>   True
21:26:00 <Iceland_jack> > return 'a' == Left 'a'
21:26:01 <lambdabot>   False
21:26:05 <Iceland_jack> :D
21:26:07 <Iceland_jack> > return 'a' == Right 'a'
21:26:08 <lambdabot>   True
21:26:21 <jmcarthur> oh i see
21:26:34 <carter> where could i find some good examples of code using data families?
21:26:53 <edwardk> jmcarthur: its currently using an 'array' that is just the number of elements in it
21:26:59 <carter> i'm hitting some weird confusing errors in my attemplt to use data families
21:27:03 <edwardk> but when wired up to the deamortized ST stuff it'll finish the job
21:27:13 <jmcarthur> yeah
21:27:20 <desheng> whoa, so when the compiler seens "return" it infers the correct monad to use basod on what it's being compared to on the other side?
21:27:45 <edwardk> once i finally figured out the right model for it was to group the new array with the previous generation rather than in the next one up it became easy
21:27:46 <Iceland_jack> desheng: Basically
21:28:09 <edwardk> actually worked flawlessly first try!
21:28:22 <edwardk> which is amusing given the sheer number of invariants
21:28:28 <Iceland_jack> If you do:
21:28:28 <Iceland_jack>     return 'a' == "hi"
21:28:28 <Iceland_jack> then ghc knows that ‘return 'a'’ has type [Char] so it must be in the list monad
21:28:31 <Iceland_jack> > return 'a' == "hi"
21:28:32 <lambdabot>   False
21:29:19 <carter> edwardk: ooo
21:29:24 <carter> is this code anywhere?
21:29:29 <carter> my scroll back for the afternoon is hosed
21:29:44 <edwardk> carter: http://lpaste.net/95268
21:29:45 <jmcarthur> carter: http://lpaste.net/95268
21:30:12 <edwardk> merge will be replaced with the code i already have in structures to do an actual array merge
21:30:34 <edwardk> and then it'll just be a slowdown thing
21:30:37 <jmcarthur> i like how Partial and steppable ST allow to decompose the algorithm a lot more than the manually interleaved original
21:30:45 <edwardk> yeah
21:30:45 <lpaste> carter pasted “associated data family confusion” at http://lpaste.net/95269
21:31:01 <carter> what am i doing wrong with data families…
21:31:06 <carter> well associated data famlilies
21:31:26 <carter> does datakinds not play nice with type classes sometimes..?
21:31:55 <edwardk> data (Shape n ):: *   --?
21:32:07 <edwardk> data Shape n
21:32:10 <carter> oh
21:32:12 <carter> that would jsut work?
21:32:16 <carter> huh
21:32:24 <enthropy> carter: aren't the second supposed to be: instance Shapable
21:32:34 <edwardk> that too
21:32:51 <carter> DERP
21:33:03 <johnw> herpa derp derp
21:33:09 <jmcarthur> carter: in your defense, that error message is awful for this mistake
21:33:12 <carter> ok
21:33:16 <carter> i'll file a GHC bug report
21:33:27 <enthropy> yeah, it should say something about "duplicate class"
21:33:30 <carter> yesh
21:33:34 <jmcarthur> it would make sense if there was no other definition
21:33:43 <carter> yesh
21:33:45 <carter> ok
21:33:45 <carter> well
21:33:58 <carter> at least my confusions are GHC bug report worthy
21:34:15 * hackagebot cuda 0.5.1.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.5.1.0 (TrevorMcDonell)
21:34:17 * hackagebot cblrepo 0.10 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.10 (MagnusTherning)
21:34:21 <jmcarthur> is late. bedtime
21:34:35 <edwardk> what really made me happy about the encoding was i didn't have to store the array sizes, they are all implicit
21:34:43 <edwardk> since this is zeroless and always doubles
21:34:49 <edwardk> and all levels are inhabited
21:35:01 <edwardk> thats a lot of register pressure off
21:35:37 <chrisblake> :i mfilter
21:35:38 <carter> edwardk: huh… sounds like i need to stare at this
21:35:43 <chrisblake> :t mfilter
21:35:44 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
21:35:47 <chrisblake> @info mfilter
21:35:47 <lambdabot> mfilter
21:35:57 <carter> edwardk: this is the new internals for structure using the free incremental st?
21:36:18 <edwardk> this is the sketch i did to prove to myself i had the recursion scheme for it right
21:36:31 <edwardk> it checked out, so the overall system should work once i slot it in
21:36:32 <carter> this looks insanely neat and succint
21:36:35 <edwardk> yep
21:37:17 <carter> would data.vector.array be a proxy for your automagic boxing?
21:37:27 <edwardk> yeah
21:37:35 <edwardk> Data.Vector.Array is what does it in structures
21:37:54 <carter> the abyss needs more name space!
21:38:28 <edwardk> i may move these to somewhere else eventually
21:38:33 <prooftechnique> Has anyone here ever worked on bindings to a web service's API? I'm trying to get an idea of the sorts of things I need to use to play around with the API for a game I play. I think it's gonna be mainly XML parsing and network stuff, I'd just like to see some prior art so I can get a feel for it
21:40:52 <carter> prooftechnique: use an XML parsing lib and stuff
21:41:03 <carter> theres probably a bunch on hackage if you just explore a bit
21:41:03 <prooftechnique> PS, edwardk, I'm hoping to use lens for this :D
21:41:28 <edwardk> prooftechnique: sounds viable. folks have had luck using lens with xml recently.
21:41:39 <prooftechnique> Neato
21:41:53 <prooftechnique> The library, or the markup in general?
21:53:46 <carter> jmcarthur: wooot
21:53:48 <carter> things work :)
21:54:28 <carter> jmcarthur: i'm actually making a kinda interesting choice in how i support doing calcs on address tuples
21:55:31 <carter> ReinH: whos going to be person #4?
21:59:57 <shelf> silly question: is there a function like zipWith, that simply merges the lists instead of forming tuples?
22:00:29 <carter> whcih merge strategy? :)
22:01:26 <shelf> x : y : merge xs ys
22:01:56 <shelf> s/zipWith/zip
22:03:03 <carter> shelf: sounds like you just define dit
22:03:08 <carter> or is there something like it in data.list/
22:03:09 <carter> ?
22:04:24 <shelf> yeah, i've just defined it quite a few times in the past, was wondering if i was missing something
22:05:35 <carter> look in Data.List mabye?
22:11:26 --- mode: ChanServ set +o mauke
22:11:26 --- mode: mauke set +q $a:chare
22:13:27 --- mode: mauke set -o mauke
22:18:31 <Kron> shelf: why not use zipWith?
22:18:40 <Kron> zipWith (\a b -> [a,b]) list1 list2
22:18:51 <carter> :t zipWith
22:18:52 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
22:19:14 <carter> Kron: so he'd do concat . zipWith ((\a b -> [a,b]))
22:19:15 <arkeet> that will lose elements if the lengths of the lists differ
22:19:16 <triliyn> I think the result of zipWith (\a b -> [a,b]) would have to be concatted
22:19:29 <Kron> ahhhh
22:19:29 <carter> that too
22:19:45 <Kron> intercalate?
22:19:50 <Kron> isn't this just... intercalate?
22:20:02 <triliyn> I don't think it is
22:20:08 <triliyn> Intercalate uses a constant interlist
22:20:13 <Kron> I vaguely remember there being a name for this
22:20:15 <Kron> intersperse?
22:20:19 <arkeet> :t align
22:20:19 <arkeet> :t (align)
22:20:19 <arkeet> it isn't.
22:20:20 <lambdabot> Not in scope: `align'
22:20:20 <lambdabot> Not in scope: `align'
22:20:23 <triliyn> :t intersperse
22:20:23 <lambdabot> a -> [a] -> [a]
22:20:25 <arkeet> nor that.
22:20:28 <arkeet> :t (Data.Align.align)
22:20:28 <Kron> damn
22:20:29 <lambdabot> Couldn't find qualified module.
22:21:03 <arkeet> @let import Data.Align
22:21:03 <lambdabot>  .L.hs:54:1:
22:21:03 <lambdabot>      Failed to load interface for `Data.Align'
22:21:03 <lambdabot>      Use -v to se...
22:21:05 <bens> concat . transpose ?
22:21:19 <triliyn> hmm
22:21:30 <triliyn> I think that also works o.o
22:21:45 <Kron> not quote
22:21:45 <triliyn> Indeed, transpose seems like it might be identical to zipWith (\a b -> [a,b])
22:21:50 <Kron> you'll first have to put them together into a list
22:21:54 <Kron> so
22:22:01 <triliyn> hmmm, I guess
22:22:07 <Kron> (\a b -> concat . transpose $ [a,b]) list1 list2
22:22:10 <Kron> something like that
22:22:14 <Kron> *quite
22:22:29 <bens> yep
22:22:34 <shelf> haha
22:23:10 <shelf> gets rather messy for such a simple little function :)
22:23:32 <Kron> well, it's relatively straightforward I think
22:23:41 <arkeet> align >>= biList
22:23:42 <Kron> interleave x y = concat . transpose $ [x,y]
22:23:49 <Kron> that's what the function definition will look like
22:23:51 <Kron> it'srather neat
22:23:54 <arkeet> er not quite.
22:23:55 <Kron> *rather
22:23:59 <arkeet> \xs ys -> align xs ys >>= biList
22:24:08 <arkeet> (after importing Data.Align and Data.Bifoldable)
22:24:26 <Kron> using transpose and concat just take Data.List
22:24:34 <Kron> hmmmmm
22:24:36 <Kron> actually hold up
22:24:43 <Kron> will transpose accept lists of different lengths?
22:24:46 <arkeet> transpose sounds like a reasonable thing to do though.
22:24:47 <arkeet> yes
22:24:56 <Kron> yeah okay awesome
22:25:00 <triliyn> I think it produces a list of the shortest length
22:25:00 <Kron> go with transpose, totally
22:25:20 <Kron> interleave :: [a] -> [a] -> [a]
22:25:23 <triliyn> I suppose it could also pad the shorter list with bottom, but that would be terrible
22:25:26 <Kron> interleave x y = concat . transpose $ [x,y]
22:25:31 <bens> triliyn: no, transpose will add on the rest of the longer list
22:25:39 <arkeet> align :: [a] -> [b] -> [These a b]
22:25:44 <arkeet> biList :: These a a -> [a]
22:25:44 <triliyn> bens: ah, hmm
22:25:52 <Kron> isn't that what we want?
22:25:58 <Kron> we want it to merge the rest of the longer list
22:26:07 <triliyn> > transpose ["hands", "feetses"]
22:26:08 <lambdabot>   ["hf","ae","ne","dt","ss","e","s"]
22:26:23 <triliyn> Yeah, I guess that's what we want
22:26:45 <Kron> > concat . transpose $ ["hands", "feetses"]
22:26:46 <lambdabot>   "hfaenedtsses"
22:27:02 <bens> carter's version is probably faster than transpose though
22:27:21 <triliyn> @src transpose
22:27:21 <lambdabot> transpose []             = []
22:27:21 <lambdabot> transpose ([]   : xss)   = transpose xss
22:27:21 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
22:27:36 <triliyn> hmmm, I'm too sleepy to analyze that
22:27:57 <Kron> yeah I think carter's may be the best
22:28:03 <Kron> but it is so ugly D:
22:28:03 <triliyn> In fact, I should probably go to bed
22:28:05 <arkeet> it collects all the heads from each list together until there are no heads left.
22:28:07 <Kron> lambas! hissss!
22:28:08 <carter> naming things gives them abstraction power
22:28:26 <carter> though it doesn't handle tail right
22:28:30 <Kron> also the problem with carter's solution
22:28:32 <Kron> you lose the longer list
22:28:34 <triliyn> (though, carter's DOES stop at the end of the shorter list, which I think is not correct for this purpose)
22:28:39 <Kron> ghci> zipWith (\a b -> [a,b]) [1,2,3] [1,2,3,4,5]
22:28:39 <Kron> [[1,1],[2,2],[3,3]]
22:28:39 <Kron> g
22:28:48 <bens> ah, fair point
22:28:50 <Kron> the transpose solution maintains the longer list
22:28:59 <Kron> so we're better off using transpose at the moment
22:29:06 <Kron> obviously the best solution is a proper recursive function
22:29:19 <Kron> and not smacking together list functions like flint and tinder and hoping things work out
22:29:22 <carter> merge [] [] = [] ; merge [] a = a  ;  merge a [] = a  ; merge (a:as) (b : bs) = a : b : merge as bs
22:29:43 <Kron> hold up I actually wrote a merge function like this before
22:29:51 <carter> yup
22:30:07 <Kron> merge :: Ord a => [a] -> [a] -> [a]
22:30:07 <Kron> merge [] ys   = ys
22:30:07 <Kron> merge xs []   = xs
22:30:07 <Kron> merge (x:xs) (y:ys)
22:30:07 <Kron>   | x < y     = x : merge xs (y:ys)
22:30:08 <Kron>   | y < x     = y : merge (x:xs) ys
22:30:12 <Kron>   | otherwise = x : y : merge xs ys
22:30:14 <Kron> sliiiiightly modified for a mergesort I guess
22:30:27 <Kron> scrap Ord, and all the guards and you're done
22:50:00 <Pleb> Is there an existing reliable package for capturing input from microphone/line in?
22:51:04 <carter> Pleb: on what OS?
22:51:14 <carter> thats an OS specific thing generally
22:53:30 <Pleb> carter: Well, the OS can be changed. Whichever is most pleasant, I guess.
22:53:42 <carter> Pleb: check out some of the game libs
22:53:56 <carter> many game libs have sound in out abstractions that are semi protable
22:54:01 <carter> and the haskell bindings mayb eowkr
23:11:17 <carter> yay, `f` is left associative by default!
23:11:27 <carter> this works out GREAT for me :)
23:11:31 <chare> guys lets do the starcraft successor project in haskell
23:11:36 <chare> who here is with me on the projecT?
23:12:04 <prooftechnique> Explain?
23:12:20 <carter> prooftechnique: me?
23:12:21 --- mode: ChanServ set +o elliott
23:12:27 --- mode: elliott set +b chare!*@*
23:12:30 <prooftechnique> No, chare
23:12:31 --- kick: chare was kicked by elliott (+q evasion)
23:12:33 <prooftechnique> Haha, sorry
23:12:35 --- mode: elliott set +b $a:chare
23:12:36 <carter> elliott: recurrent trolling
23:12:38 --- mode: elliott set -q $a:chare
23:12:39 --- mode: elliott set -o elliott
23:12:39 <carter> ?
23:12:48 <elliott> already +q'd under their nickserv account
23:12:53 <carter> q?
23:12:56 <carter> whats taht
23:12:58 <elliott> quieting
23:13:01 <carter> ok
23:13:03 <carter> whts that do?
23:13:37 <elliott> stops people sending messages
23:13:39 <elliott> (also not their first +q)
23:13:51 <glguy> Moderation chat in #haskell-ops if anyone has questions
23:14:04 <carter> ok
23:14:40 <carter> i should learn about how to op stuff at some point
23:14:44 <carter> anyways
23:14:50 <carter> very very happy that `f` is left associative
23:15:41 <Kneiva_> #haskell-`op`s
23:15:42 <sopvop> you can change fixity of `f` same way as any other operator
23:15:55 <carter> sopvop: yes, but the default is the right one for em :)
23:15:56 <carter> me
23:18:19 <sopvop> changing fixity of `f` is bad idea IMO, it's not documented by haddock and fixity errors are not obvious from error messages
23:18:51 <carter> yup
23:18:58 <carter> hence why i'm happy the default fixity is perfect for me
23:23:01 <dEPy> :t Maybe
23:23:01 <lambdabot> Not in scope: data constructor `Maybe'
23:23:25 <carter> :k Maybe
23:23:26 <lambdabot> * -> *
23:23:29 <carter> :t Just
23:23:30 <lambdabot> a -> Maybe a
23:23:32 <carter> :t Nothing
23:23:33 <lambdabot> Maybe a
23:23:34 <carter> dEPy: :)
23:23:57 <dEPy> tnx :)
23:24:03 <carter> soke
23:24:10 <carter> everyone has to learn :)
23:24:14 <dEPy> But I was just checking if I'm still connected to irc since my laptop was closed. :D
23:24:17 <carter> hehe
23:24:36 <dEPy> so what does  :k  do?
23:25:04 <prooftechnique> > foldl (const <$> (+1)) 0 "hello"
23:25:05 <lambdabot>   5
23:25:20 <prooftechnique> dEPy: :k is short for :kind
23:25:37 <prooftechnique> So it gives the kind of a type
23:25:41 <prooftechnique> :k Int
23:25:42 <lambdabot> *
23:26:53 <carter> :k (->)
23:26:54 <lambdabot> * -> * -> *
23:26:57 <carter> mwahahahahah
23:27:00 <carter> :)
23:27:12 <carter> yes, (->) is a type level infix thingy
23:27:13 <prooftechnique> Where, if I remember how to say it properly, kind * is a concrete type and arrowed kinds are parameterized types
23:27:18 <carter> yes
23:27:37 <carter> * is the things that are values
23:27:40 <carter> ish
23:27:43 <carter> theres some caveats to that
23:27:45 <carter> but roughly
23:31:37 <dEPy> ok, I kind(a) understand kind :)
23:32:18 <ersran9> hi, could someone take a look at this and critique it? https://gist.github.com/ersran9/7332232
23:32:29 <prooftechnique> It's probably easiest to consider Int, Maybe, and Either
23:32:31 <prooftechnique> :k Int
23:32:32 <lambdabot> *
23:32:34 <prooftechnique> :k Maybe
23:32:35 <lambdabot> * -> *
23:32:37 <prooftechnique> :k Either
23:32:38 <lambdabot> * -> * -> *
23:32:48 <prooftechnique> :k Maybe Int
23:32:49 <lambdabot> *
23:32:55 <prooftechnique> :k Either Int String
23:32:56 <lambdabot> *
23:33:00 <prooftechnique> :k Either Int
23:33:01 <lambdabot> * -> *
23:35:44 <arkeet> hm.
23:35:47 <arkeet> I'm looking at harpy now.
23:39:43 <teneen> looking at the source of the package binary, I feel like it treats bits as bytes. Isn't this inefficient?
23:40:16 <edwardk> teneen: in terms of space, yes, in terms of time? not always
23:41:08 <teneen> edwardk: is this the standard way to binarize data in general?
23:41:19 <teneen> not only in Haskell
23:41:33 <edwardk> teneen: its pretty common, the shifting is somewhat expensive
23:41:54 <edwardk> but then so is accessing more data than you need ;)
23:43:16 <teneen> I want to binarize very large amounts of data and I need the most compact representation
23:43:33 <teneen> I actually care about space complexity more than time :(
23:43:52 <edwardk> the bits package has a 'Coding' type that can be used for more dense packing
23:44:02 <edwardk> but not sure how much we have done with it yet
23:44:57 <carter> teneen: its also faster to read things in word sized chunks
23:44:58 <carter> :)
23:45:39 <teneen> but isn't it in theory 8x larger treating bytes as bits
23:48:01 <carter> teneen: well, why are you reading only bits ratther than whole words?
23:48:05 <carter> :)
23:48:17 <carter> cpus can't handl bits, only words
23:48:18 <carter> :)
23:49:04 <teneen> I want to read words but decompose them in terms of each bit not each byte
23:49:39 <edwardk> teneen: http://hackage.haskell.org/package/bits-0.3.3/docs/Data-Bits-Coding.html provides machinery for doing encoding/decoding of bitstreams
23:49:50 <carter> cool
23:50:03 <teneen> edwardk: I'll check that out, thanks
23:50:04 <carter> you'll still use a whole cpu register to handle each bit :)
23:50:13 <carter> but it can be done
23:51:19 <teneen> carter: yes, but the memory footprint will reduce significantly
23:51:27 <carter> for what?
23:51:33 <carter> storing what where?
23:51:39 <carter> storing != how you manipuate it
23:53:37 <teneen> carter: instead of storing 8 bytes I'll store one?
23:53:45 <carter> sure
23:53:49 <carter> i'm just saying
23:53:51 <carter> before you store
23:53:56 <carter> or after your read it in
23:53:59 <teneen> I know there'll be allignment issues and stuff but that's not significant
23:54:01 <carter> yeah
23:54:03 <carter> ok
23:54:04 <carter> ignore me
23:54:05 <carter> tired
23:54:06 <carter> long day
23:54:07 <carter> etc etc
23:55:06 <carter> nigth all
23:57:18 <arkeet> I'm not impressed with the win32 bindings =(
23:59:11 <carter> acfoltzer: make snese
23:59:14 <carter> *sense?
