00:21:27 <augur> ski: http://purelytheoretical.com/programming/ImplementingHaskellIOInJavascript.html
00:33:36 <structuralist> how do I use something of type "State s a" in "StateT s IO"?
00:35:36 <johnw> structuralist: since State s is really StateT s Identity, you can use "hoist" from the mmorph package to change Identity to IO
00:35:56 <johnw> basically "host liftIO foo", where foo is your State s a
00:36:14 <johnw> oh, wait, that is goes in the other directory
00:37:22 <johnw> you need: hoist (return . runIdentity) foo
00:38:00 <yac> is it possible to make ";" to mean a start of a one line comment?
00:44:15 <augur> Saizan: can i get some feedback on a tutorial i wrote?
00:44:26 <augur> Saizan: if yes: http://purelytheoretical.com/programming/ImplementingHaskellIOInJavascript.html
00:44:30 <augur> if no :(
00:58:29 <taejo> in lens, is there a name for (gets . view)? I.e., given a lens, get the value the lens points to in a state monad?
00:59:20 <taejo> ah, use
01:00:50 <taejo> @faq is Haskell the best language for imperative programming?
01:00:50 <lambdabot> The answer is: Yes! Haskell can do that.
01:01:02 <taejo> well, it's certainly an interesting one
01:04:09 <Saizan> ?hoogle hoist
01:04:09 <lambdabot> No results found
01:07:31 <fizruk> @hoogle hoist
01:07:32 <lambdabot> No results found
01:07:58 <funky_> how easy it is to do GUI programming in haskell?
01:08:17 <funky_> compared to mainstream OO-languages
01:10:37 <startling> funky_: it depends
01:10:50 <startling> library bindings are mostly just bindings, aiui
01:13:33 <kartoffelbrei> funky_: it's much more awkward because the bindings for gtk or wx are hard to install and even if you get it up running the API does feel very unhaskelly (imperative). Now if you just want to generate graphics or get a surface you can draw stuff on, there are other options (sdl, threepennygui, diagrams).
01:19:54 <maybefbi> djinn
01:20:01 <sie> I'm thinking about fmap — it's only needed to put some abstraction before passing the algebraic data type values to functions?
01:20:16 <sie> Have I gotten this right?
01:21:03 <Sonderblade> kartoffelbrei: surely there are haskellish gui libraries for haskell?
01:21:05 <maybefbi> @djinn (a, b) -> c -> (b, c) ==> f (_, a) b = (a, b)
01:21:06 <lambdabot> Cannot parse command
01:21:36 <maybefbi> @djinn ByteString -> [Word32]
01:21:37 <lambdabot> Error: Undefined type ByteString
01:22:02 <maybefbi> @djinn BS.ByteString -> [Word32]
01:22:03 <lambdabot> Error: Undefined type BS.ByteString
01:22:34 <funky_> Sonderblade: thats what id like to know as welll
01:23:13 <fizruk> sie, fmap is a useful abstraction that (like some other abstractions) let you be agnostic of what particular data structure you're using
01:23:26 <maybefbi> :t LBS.length
01:23:28 <lambdabot> Couldn't find qualified module.
01:23:51 <maybefbi> :t ByteString
01:23:52 <lambdabot> Not in scope: data constructor `ByteString'
01:25:09 <sie> fizruk, I see, thank you.
01:26:17 <maybefbi> @djinn Data.ByteString -> [Word32]
01:26:17 <lambdabot> Error: Undefined type Data.ByteString
01:27:20 <maybefbi> @djinn Data.ByteString.ByteString -> [Word32]
01:27:21 <lambdabot> Error: Undefined type Data.ByteString.ByteString
01:27:43 <maybefbi> @djinn Data.ByteString.Char8.ByteString -> [Word32]
01:27:43 <lambdabot> Error: Undefined type Data.ByteString.Char8.ByteString
01:35:58 <quchen> maybefbi: djinn is a theorem prover, not a lookup engine. For that use @hoogle or hoogle.haskell.org, preferrably in a private session.
01:37:26 <kartoffelbrei> Sonderblade: the closest i know of would be FRP libraries on top of wx or gtk like reactive-bannana-wx.
01:37:46 <fizruk> is there a name for liftIO . atomically ?
01:41:59 <quchen> fizruk: I wish, but haven't found one yet
01:42:45 <fizruk> quchen, okay :(
01:44:32 <quchen> fizruk: Would make too small of a package to upload I think
01:44:56 <quchen> I can't think of much more in STM that would need a lifted version
01:45:42 <fizruk> oh, I see, I thought stm depended on transformers
01:46:05 <fizruk> but it has no reason to depend on that :)
01:53:18 <quchen> STM is pretty independent
01:53:35 <quchen> Apart from the deep hardwiring in GHC :-P
01:53:58 <maybefbi> :t ByteString cons
01:53:59 <lambdabot> Not in scope: data constructor `ByteString'
01:54:16 <maybefbi> :t Data.ByteString.cons
01:54:17 <lambdabot> Word8 -> BSC.ByteString -> BSC.ByteString
01:54:19 <quchen>  /q lambdabot    <- maybefbi
01:55:19 <maybefbi> @djinn BSC.ByteString -> [Word32]
01:55:19 <lambdabot> Error: Undefined type BSC.ByteString
01:56:59 <startling> simpson: hey, did you ever do anything with a greenarray chip?
01:57:54 <maybefbi> @djinn [Word8] -> [Word32]
01:57:54 <lambdabot> Error: Undefined type []
01:58:16 <startling> maybefbi: maybe you want hoogle?
01:58:24 <maybefbi> ok
01:58:40 <startling> djinn isn't great for complicated things like that
01:58:50 <startling> @djinn (a, b) -> b
01:58:51 <lambdabot> f (_, a) = a
01:59:02 <quchen> Does Djinn even have recursive types?
01:59:13 <startling> No idea.
02:00:23 <maybefbi> its ok i will use binary Put
02:00:30 <maybefbi> to put 4 Word8
02:00:47 <maybefbi> after taking it from bytestring
02:01:33 <mr-> @djinn [a] -> Maybe a
02:01:33 <lambdabot> Error: Undefined type []
02:01:43 <startling> @djinn a -> Maybe a
02:01:43 <lambdabot> f = Just
02:01:54 <startling> @djinn a -> Maybe b
02:01:54 <lambdabot> f _ = Nothing
02:01:58 <startling> clever
02:02:01 <maybefbi> lol
02:02:16 <startling> @djinn Maybe Int
02:02:16 <lambdabot> Error: Undefined type Int
02:02:26 <quchen> startling: Djinn uses as many inputs as it can I think. Which is pretty useful in many cases.
02:02:42 <quchen> @djinn b -> (a -> b) -> Maybe a -> b
02:02:43 <lambdabot> f a b c =
02:02:43 <lambdabot>     case c of
02:02:43 <lambdabot>     Nothing -> a
02:02:43 <lambdabot>     Just d -> b d
02:03:15 <quchen> That's much better than "f x _ _ = x" :-)
02:03:42 <taejo> maybefbi: const []
02:03:44 <startling> quchen: neat!
02:03:47 <mr-> It would have been a simpler proof, though!
02:04:21 <quchen> mr-: Haskell is about writing complicated proofs for simple things.
02:04:27 <quchen> Mostly IO ()
02:04:36 <startling> heh
02:05:50 <maybefbi> :t const []
02:05:50 <quchen> mr-: But yes, from an implmenentation perspective I assume it's much harder to make Djinn be useful because you can't just use the usual algorithms
02:05:51 <lambdabot> b -> [a]
02:05:53 <mr-> It _is_ amazing how many different proofs for "IO ()" people have come up with
02:06:23 <quchen> mr-: Well I'm not sure what IO is yet so I can't judge that
02:06:49 <mr-> quchen: You are implying that they might all be equal?
02:07:09 <quchen> No, I'm implying that I'm not sure what IO is yet.
02:07:12 <startling> :)
02:07:21 <quchen> People used to tell me "It's like 'State RealWorld' but not really", now they tell me "It's like Free IOAction but not really"
02:07:47 <quchen> And then occasionally shachaf destroys the party saying "it's primitive and you're all wrong" :-P
02:07:57 <mr-> hehe
02:08:15 <mauke> it's wrong and you're all primitive
02:08:21 <quchen> :-C
02:08:28 <timthelion> :D
02:09:01 <startling> can I program FPGAs yet in Haskell?
02:09:18 <quchen> startling: Try using our @faq command!
02:09:40 <startling> :<
02:09:42 <timthelion> @faq can I program FPGAs yet in Haskell?
02:09:42 <lambdabot> The answer is: Yes! Haskell can do that.
02:10:05 <quchen> ;-)
02:10:11 <timthelion> @faq Is IO like a state monad but not really?
02:10:12 <lambdabot> The answer is: Yes! Haskell can do that.
02:10:16 <timthelion> :D
02:10:44 <quchen> IO = State RealWorld is sort of nice if you're a semi-beginner and can't make sense of it.
02:11:06 <startling> "but how does RealWorld represent all of the real world?"
02:11:13 <startling> "and what does 'put' do?"
02:11:25 <timthelion> quchen: well, there is no making sense of IO because it's not well formalized, it's simply imperative logic, no different from any other crappy imperative language
02:11:26 <Walther> "blue pill, or red pill"
02:12:20 <quchen> timthelion: But "IO = Free IOAction" is very sequential
02:13:03 * timthelion doesn't see Free in hayoo
02:13:04 <funky_> the point in haskell is that IO is well separated from the rest though, isnt it?
02:13:14 <timthelion> funky_: yes, that's the point
02:13:20 <quchen> As far as I know IO is simply a DSL to be interpreted by the runtime, in that sense it's similar to Free x
02:13:36 <quchen> timthelion: Free = Free Monad http://hackage.haskell.org/package/free
02:13:38 <timthelion> funky_: it's just two letters we put in front of a value to say that this value cannot be evaluated without doing IO.
02:13:49 <funky_> yep
02:14:51 <quchen> I am IO. Your purity and technological distinctiveness will be added to our own. Resistance is futile.
02:15:11 <quchen> s/our/my
02:19:50 <quchen> timthelion: There was a talk about free monads recently that demystifies them well, I think by Andreas Löh (or was it Alexander?)
02:20:18 <alexander__b> can I eta reduce "foo a = id 5 / id a" somehow?
02:20:47 <alexander__b> so "f x = f(something)/f(x)".
02:20:57 <quchen> Not without making it ugly
02:21:17 <quchen> f = (/) (g something)
02:21:27 <quchen> f = (g something /)
02:21:45 <quchen> f = (/) (g something) . h
02:21:47 <quchen> ^ Ugly.
02:21:55 <alexander__b> quchen: I see. thanks.
02:22:36 <quchen> Eta reduction rarely has runtime implications. It sometimes affects inlining, but I would treat it as a readability thing by default.
02:22:57 <startling> alexander__b, um, (5 /) ?
02:23:21 <quchen> startling: He meant complicated "id"s :-)
02:23:25 <startling> oh
02:23:29 <skypers_> hello
02:23:30 <alexander__b> startling: the id was illustrative, hence my f x followup generalisation.
02:23:35 <startling> that's a really strange name for a free variable
02:23:35 <skypers_>   src <- doesFileExist srcPath >>= \yes -> if yes then Just `liftM` readFile srcPath else Nothing
02:23:42 <alexander__b> quchen: yes, I always prefer readability
02:23:43 <skypers_> do you know a prettier way to do the same? :)
02:23:55 <startling> alexander__b, (/) `on` f
02:24:07 <quchen> My eyes! :-(
02:24:10 <startling> :t on (/)
02:24:11 <lambdabot> Fractional c => (a -> c) -> a -> a -> c
02:24:48 <skypers_> @hoogle Bool -> m a -> Maybe a
02:24:48 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
02:24:49 <lambdabot> Control.Exception assert :: Bool -> a -> a
02:24:49 <lambdabot> Control.OldException assert :: Bool -> a -> a
02:25:01 <skypers_> @hoogle a -> Bool -> Maybe a
02:25:02 <startling> skypers_, uh, how does that work?
02:25:02 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
02:25:02 <lambdabot> Control.Exception assert :: Bool -> a -> a
02:25:02 <lambdabot> Control.OldException assert :: Bool -> a -> a
02:25:13 <skypers_> startling: what do you mean?
02:25:18 <startling> skypers_: what's it do?
02:25:24 <quicksilver> doesFileExist is probably a bad idea anyway
02:25:34 <quicksilver> better to just read from the file and catch the exception.
02:25:37 <quchen> skypers_: if p then Just x else Nothing = x <$ guard p
02:25:50 <skypers_> it tests whether the file exist
02:25:50 <skypers_> if so
02:25:57 <startling> skypers_, that's a race condition
02:26:06 <skypers_> it reads the whole file, if no, returns Nothing
02:26:09 <startling> (if you plan on reading it if it exists)
02:26:12 <skypers_> :t (<$)
02:26:13 <lambdabot> Functor f => a -> f b -> f a
02:26:50 <skypers_> @src (<$)
02:26:51 <lambdabot> (<$) = (<$>) . const
02:26:55 <skypers_> oh
02:26:56 <quchen> x <$ f = fmap (const x) f
02:27:08 <skypers_> I see
02:27:26 <skypers_> [11:17] <quicksilver> better to just read from the file and catch the exception.
02:27:30 <skypers_> I really don’t like exceptions…
02:27:48 <quchen> skypers_: That's why you have to catch them.
02:27:52 <quicksilver> in general "check something will work and then do it" is a race condition
02:28:08 <quicksilver> it's a more robust habit to "just do it and handle if it failed"
02:28:09 <skypers_> but you might be right since file operations should be atomic
02:28:21 <skypers_> and doesFileExist >>= whatever is not
02:28:28 <tdammers> quicksilver: "EAFTP"?
02:28:29 <startling> exactly.
02:28:44 <quchen> I'm confused by what you call a race condition. I don't see a race between things here (like in the concurrent case where two things race for the first termination etc.)
02:29:24 <skypers_> I don’t actually know how to handle exceptions in Haskell
02:29:26 <mauke> quchen: your process isn't alone
02:29:31 <startling> quchen, maybe "race condition" isn't the word
02:29:40 <skypers_> I always try to stay out of their way :D
02:29:50 <quicksilver> quchen: the race is against something else deleting the file after you've checked for its existence
02:29:56 <skypers_> for instance, avoiding head without a test on null before
02:29:57 <startling> but yeah: another thread or process might move the file after you've checked that it exists but before you read it
02:30:10 <quicksilver> as far as I know "race condition" is the the correct term for this
02:30:12 <skypers_> yes, atomic.
02:30:17 <quchen> I would call that "potential leak/inconsistency" and not a "race".
02:30:18 <mauke> just because a file exists doesn't mean open will succeed anyway
02:30:40 <skypers_> that’s also a good point :D
02:30:41 <ibid> that's a classic race condition with security implications
02:30:51 <tdammers> it's a race alright, at least the "file deleted between checking if it exists and opening it"
02:30:54 <tdammers> cas
02:30:55 <skypers_> I might do that thing: try opening it
02:30:55 <tdammers> e
02:30:59 <skypers_> if I catch an exception
02:31:08 <mauke> :t try
02:31:09 <lambdabot> Exception e => IO a -> IO (Either e a)
02:31:11 <skypers_> I launch some functions to get why it failed
02:31:22 <mauke> the exception should tell you why
02:31:25 <startling> quchen: consider: your program might error depending on whether or not another thread or process wins a race with it.
02:31:25 <quchen> "A race condition or race hazard is the behavior of an electronic or software system where the output is dependent on the sequence or timing of other uncontrollable events." Since Wikipedia is always right I concur
02:31:33 <skypers_> through e, mauke ?
02:31:42 <mauke> skypers_: what e?
02:31:52 <skypers_> :t try
02:31:53 <lambdabot> Exception e => IO a -> IO (Either e a)
02:31:54 <skypers_> that one
02:32:19 <startling> :t fmap (preview _Right) . try . readFile
02:32:20 <lambdabot>     No instance for (Exception e0) arising from a use of `try'
02:32:20 <lambdabot>     The type variable `e0' is ambiguous
02:32:20 <lambdabot>     Possible fix: add a type signature that fixes these type variable(s)
02:32:41 <quchen> skypers_: readFile "/dev/noll" `catch` (\(SomeException e) -> print e)
02:32:44 <quchen> Something along those lines.
02:32:50 <skypers_> so try <=< readFile will not lead to non-atomic file operations?
02:32:52 <ibid> the security implication becomes a problem if the program has greater privileges than peope who have modification access to the directory containing the file
02:33:05 <startling> :t try <=< readFile
02:33:06 <lambdabot>     Couldn't match type `[Char]' with `IO a0'
02:33:06 <lambdabot>     Expected type: FilePath -> IO (IO a0)
02:33:06 <lambdabot>       Actual type: FilePath -> IO String
02:33:08 <ibid> *people
02:33:22 <quchen> skypers_: It will still be non-atomic if you handle exceptions, but when something fishy happens it won't crash your entire program.
02:33:27 <startling> ibid: I don't follow
02:33:49 <skypers_> yeah btw
02:33:51 <skypers_> it’s not <=<
02:33:52 <skypers_> but .
02:33:58 <skypers_> :t try . readFile
02:33:59 <lambdabot> Exception e => FilePath -> IO (Either e String)
02:34:38 <skypers_> so hm
02:34:49 <skypers_> I need some further details around Haskell exceptions
02:34:57 <skypers_> catch is a built-on GHC stuff?
02:34:59 <skypers_> so is try?
02:35:07 <startling> it's not GHC stuff iirc
02:35:10 <skypers_> when do you use exceptions?
02:35:16 <skypers_> startling: well
02:35:27 <ibid> startling: if the test is for the file's beningness, an adversary may have time to replace the file with a symlink to something they want to trash between the test and the actual open
02:35:28 <skypers_> there’re no hint in a sig a function can throw an exception
02:35:36 <startling> skypers_: correct.
02:35:50 <skypers_> and it’s perhaps a bad thing imho
02:35:51 <startling> skypers_, you should probably not throw exceptions yourself, but have no qualms about catching them
02:36:03 <skypers_> startling: I never throw exceptions
02:36:05 <skypers_> I hate them.
02:36:15 <startling> skypers_, Ok.
02:36:18 <skypers_> actually
02:36:23 <startling> skypers_: do you have a problem with catching them?
02:36:27 <skypers_> EitherT is kinda the monadic form of exceptions
02:36:36 <skypers_> startling: I don’t like the concept in pure language
02:36:48 <startling> skypers_, so you'll refuse to catch them in protest?
02:36:48 <skypers_> for instance, head should be head :: [a] -> Maybe a
02:36:52 <skypers_> no no
02:36:54 <skypers_> of course I will
02:37:06 <skypers_> but I won’t write code that intentionnaly throws exceptions
02:37:07 <startling> skypers_, yes, I understand why throwing exceptions is a bad idea.
02:37:16 <startling> I don't understand how it's relevant.
02:37:24 <skypers_> startling: that’s why I’ve asked:
02:37:33 <skypers_> [11:26] <skypers_> when do you use exceptions?
02:37:37 <skypers_> in other languages
02:37:40 <skypers_> imperative ones
02:37:53 <skypers_> people use exceptions for so much large errors situations
02:37:53 <startling> hence (04:27) < startling> skypers_, you should probably not throw exceptions [...]
02:38:00 <skypers_> yeah
02:38:13 <skypers_> so why are there exceptions at some point?
02:38:22 <skypers_> for IO operations only?
02:38:29 <skypers_> we saw it’s not
02:38:35 <skypers_> (i.e. head, tail and so on)
02:39:23 <skypers_> why the guys who’ve written head and tail chose to use error instead of Maybe a?
02:39:35 <skypers_> for comfort?
02:39:38 <startling> skypers_, because people are not always in agreement on this point, and because Haskell's field accessors generate exception-throwing code, and because backwards-compatibility is important.
02:39:41 <mauke> tradition
02:39:55 <skypers_> field accessors?
02:39:58 <skypers_> what do you mean?
02:40:13 <skypers_> for IO operations, I actually understand (concurrency and so on)
02:40:16 <skypers_> but for pure function
02:40:25 <skypers_> it makes me sad :)
02:40:35 <startling> skypers_, consider data List = Nil | Cons { head :: a, tail :: List a }
02:40:58 <mauke> skypers_: do you know record syntax?
02:41:02 <skypers_> yes
02:41:11 <skypers_> mauke: I’m not a rookie in Haskell anymore ;) ;)
02:41:23 <skypers_> (but I don’t like Arrows. :D)
02:41:27 <startling> skypers_, with that code, `head Nil` throws an exception.
02:41:36 <startling> skypers_, (no one likes arrows, don't worry)
02:41:45 <skypers_> startling: hm
02:41:48 <ibid> also because Maybe is an unnecessary complication if you know the Nothing case cannot occur
02:42:03 <skypers_> something I might not know about record syntax
02:42:12 <skypers_> I thought you cannot use it with multiple ctor
02:42:23 <startling> skypers_: you can! it's just bad practice
02:42:25 <ibid> of course you can
02:42:28 <skypers_> yeah, totally!
02:42:32 <ibid> startling: why?
02:42:44 <startling> ibid, partial functions
02:42:45 <skypers_> because of inconsistency?
02:42:46 <mauke> startling: multiple constructors doesn't neccessarily mean partial
02:42:52 <startling> that's true.
02:42:53 <ibid> startling: partial functions are not bad
02:42:57 <skypers_> [11:33] <startling> skypers_, with that code, `head Nil` throws an exception.
02:43:07 <mauke> data X = A{ foo :: Int } | B{ foo :: String }
02:43:23 <skypers_> woah, that’s odd
02:43:24 <startling> ibid, I think we'll have to disagree on this point.
02:43:30 <ibid> startling: yes :)
02:43:31 <mauke> I don't think that's legal
02:43:37 <tero-> what's wrong with arrows? (I haven't yet studied them)
02:43:39 <startling> mauke, it is.
02:43:44 <mauke> but I bet it is if both fields have the same type
02:43:49 <startling> oh
02:43:52 <ibid> startling: but yeah, if you think partial functions are bad, you're going to object to head and tail
02:43:53 * startling misread
02:43:58 <skypers_> tero-: the fact they’re abstract as fu*k
02:43:59 <ibid> startling: since i don't think so, i don't :)
02:44:04 <skypers_> :t (***)
02:44:05 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:44:09 <skypers_> have fun with that.
02:44:11 <skypers_> :)
02:44:11 <tero-> delicious
02:44:12 <startling> tero-, they're not a very useful abstraction.
02:44:18 <skypers_> :D
02:44:20 <startling> ime
02:44:49 <skypers_> is there anything else higher in term of abstraction that Arrow ?
02:44:49 <Cale> They're very close to being a very useful abstraction, but as they exist in the libraries, they're moderately self-defeating.
02:45:05 <Cale> (Arrows)
02:45:12 <startling> skypers_, it depends what you mean by "higher", I guess.
02:45:18 <skypers_> well
02:45:23 <sie> Are you talking about the argument delimiting arrows?
02:45:28 <skypers_> something that generalizes Arrows?
02:45:40 <Cale> skypers_: Category generalises Arrow
02:45:44 <skypers_> oh yes
02:45:46 <skypers_> :D
02:45:48 <skypers_> Category
02:46:08 <mm_freak_> skypers_: you can generalize in many directions
02:46:16 <Cale> Though Category is something weird. It only looks like the definition of a category if you don't look too closely
02:46:18 <mm_freak_> Category, Functor, …
02:46:25 <ClaudiusMaximus> tero-: http://www.cs.yale.edu/homes/hl293/download/jfpcca.pdf explains (at least in the abstract) some of the badness of Arrow as currently defined
02:46:25 <mm_freak_> Cale: why?
02:46:53 <Cale> mm_freak_: Because the parametric polymorphism in (.) restricts the sorts of things you can do
02:47:09 <tero-> ClaudiusMaximus: thanks
02:47:18 <skypers_> I’ve heard we can fmap a function f on a (a,a) with arrow
02:47:21 <mm_freak_> Cale: sure, you can only capture a certain class of categories
02:47:23 <skypers_> maybe the (***) operator
02:47:31 <startling> :t (&&&)
02:47:32 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
02:47:34 <Cale> Yeah, and it's hard to say exactly what that class is
02:47:36 <mm_freak_> Cale: but most type classes have that restriction
02:47:43 <skypers_> but I thing it’s not worth it to include it
02:47:45 <skypers_> oh yeah
02:47:45 <mm_freak_> including Functor, Monad, …
02:47:46 <skypers_> (&&&)
02:48:07 <startling> it's not quite "fmap a function f on a (a,a)"
02:48:10 <startling> :t (***)
02:48:12 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:48:15 <Cale> Well, that's true, Functor probably doesn't capture every endofunctor on Hask
02:48:36 <skypers_> startling: but (&&&) is, isn’t it?
02:48:54 <Cale> (though it comes a lot closer to capturing all the endofunctors on Hask than Category comes to capturing categories)
02:49:10 <startling> skypers_, no. it applies two different functions to an (a, b)
02:49:24 <startling> :t (&&&) `asAppliedTo` (+ 1)
02:49:26 <lambdabot> Num a => (a -> a) -> (a -> c') -> a -> (a, c')
02:49:29 <mm_freak_> Cale: Monad is worse than Category though
02:49:35 <skypers_> hihi
02:49:38 <skypers_> I trust you
02:49:39 <skypers_> :)
02:49:44 <Cale> mm_freak_: Well, Monad is for Monads on Hask only
02:50:00 <mm_freak_> Cale: and Category is for subcategories on Hask =)
02:50:01 <Saizan> (&&&) is the pointfree version of (,)
02:50:03 <mm_freak_> of
02:50:06 <skypers_> btw, is there a true functor class somewhere?
02:50:08 <Cale> But my point is, there's something relative to the category of Haskell types and functions which is going on with the Category class which we don't quite have words to express (I don't think?). Maybe it has something to do with internal categories.
02:50:18 <Cale> It's not subcategories!
02:50:23 <skypers_> tfmap :: (a -> b) -> f a -> g b
02:50:24 <skypers_> hm
02:50:28 <skypers_> it sounds unreal
02:50:36 <Cale> You're not always defining (.) as some restricted variant of function composition
02:50:57 <mm_freak_> Cale: indeed, but you'll still work with a subclass of the objects
02:51:07 <skypers_> @hoogle (a -> b) -> f a -> g b
02:51:07 <lambdabot> Data.IntMap.Strict map :: (a -> b) -> IntMap a -> IntMap b
02:51:07 <lambdabot> Data.IntMap.Lazy map :: (a -> b) -> IntMap a -> IntMap b
02:51:07 <lambdabot> Data.Set mapMonotonic :: (a -> b) -> Set a -> Set b
02:51:14 <skypers_> yeah, doesn’t exist
02:51:40 <mm_freak_> skypers_: you need a natural transformation from f to g
02:51:42 <skypers_> and it’s actually quite logical
02:52:05 <mm_freak_> forall a. F a -> G a
02:52:10 <mm_freak_> with the natural transformation laws
02:52:17 <skypers_> so
02:52:39 <Cale> Yeah, the objects of the category have to be Haskell types, but even more than that, the composition you define on the arrows has to be natural in a bunch of ways, because you can't define it piecemeal.
02:52:45 <skypers_> a natural transformation takes an object from a F and brings it in G unchanged?
02:52:48 <skypers_> in term of structure?
02:52:57 <darthdeus> anyone knows why in this code http://lpaste.net/95186 i'm getting  Couldn't match expected type `Int -> Int -> Int' with actual type `Int' ?
02:53:37 <skypers_> which line?
02:53:48 <Cale> skypers_: A natural transformation roughly corresponds to a polymorphic function of that type, but the actual definition is somewhat more permissive.
02:53:57 <skypers_> and yeah darthdeus
02:54:09 <skypers_> buu 600851475143 still lacks a parameter
02:54:15 <darthdeus> in this part    (buu $ number `div` div)
02:54:17 <skypers_> oh nvm.
02:54:18 <ClaudiusMaximus> darthdeus: turn on -Wall , you're shaddowing div
02:54:42 <startling> haha
02:54:44 <mm_freak_> skypers_: if F is a comonad and G is a monad, you get a natural transformation for free =)
02:54:45 <darthdeus> ClaudiusMaximus: oh wow :D
02:54:51 <mm_freak_> return . extract
02:54:58 <startling> darthdeus: it's funny how easy it is to accidentally do that
02:55:02 <skypers_> I don’t actually know what is a comonad
02:55:11 <skypers_> what a comonad is*
02:55:16 <mm_freak_> skypers_: nevermind
02:55:50 <ClaudiusMaximus> (oh, -Wall doesn't catch it - presumably that phase comes after type checking..)
02:55:50 <skypers_> when we say f a -> f b
02:55:59 <skypers_> what is f in math terms?
02:56:02 <skypers_> a category?
02:56:07 <skypers_> a “structure” ?
02:56:12 <skypers_> I always mistake that
02:56:16 <mm_freak_> skypers_: depends on context
02:56:25 <mm_freak_> but usually it's a functor
02:56:30 <skypers_> hm
02:56:32 <skypers_> in math
02:56:37 <mm_freak_> functor
02:56:56 <skypers_> a functor is a morphism between category
02:57:05 <skypers_> ok so f is a category.
02:57:09 <Cale> no
02:57:11 <mm_freak_> no, a functor
02:57:19 <skypers_> mm_freak_: it doesn’t make sense!
02:57:24 <mm_freak_> why?
02:57:31 <skypers_> because a functor is a morphism
02:57:35 <skypers_> and hm
02:57:37 <skypers_> Maybe
02:57:43 <skypers_> is not a morphism
02:57:48 <mm_freak_> a functor takes objects to objects and morphisms to morphisms, following a number of laws
02:57:48 <skypers_> is it?
02:58:06 <Cale> Maybe is a mapping which sends each type t in the category of Haskell types and functions to another type, Maybe t
02:58:19 <mm_freak_> Maybe is a morphism in a certain category (the category of categories)
02:58:28 <Cale> and the corresponding fmap sends each function X -> Y to a function Maybe X -> Maybe y
02:58:32 <mm_freak_> the morphisms of that category are called functors
02:58:35 <Cale> oops, Maybe Y of course :)
02:58:51 <skypers_> yeah
02:58:52 <skypers_> ok
02:58:58 <Cale> Let's not even look at the category of categories yet :)
02:59:12 <skypers_> so a functor is what?
02:59:19 <skypers_> if it’s not a morphism
02:59:20 <mm_freak_> yeah, i just wanted to explain why we sometimes call functors morhpisms =)
02:59:23 <skypers_> a generalization of morphism?
02:59:23 <Cale> Firstly, do you know what categories are?
02:59:47 <skypers_> not really, actually
02:59:55 <Cale> Okay, let's get that out of the way first
03:00:04 <skypers_> I actually know some categories
03:00:05 <mm_freak_> skypers_: wow, ok…  you have your first exercise then =)
03:00:13 <Cale> A category consists of a fairly large bunch of data:
03:00:14 <skypers_> but I don’t know how te define them generally
03:00:24 <funky_> how big of a help is it to be familiar with category theory if one aims to be good with haskell? I'm asking this as a layman
03:00:37 <funky_> I suck at math but I like haskell
03:00:45 <skypers_> funky_: so study with me. ;)
03:01:04 <chrisdone> funky_: you don't have to know any category theory. it's just more fun and enriching to do so
03:01:09 <funky_> skypers_: wikipedia is pretty unwelcoming with it's alien notation <.<
03:01:13 <funky_> its*
03:01:15 <skypers_> :D
03:01:15 <Cale> funky_: You might find that you're eventually interested in learning some, but if your goal is just to write programs and get things done, it's mostly going to waste your time.
03:01:27 <skypers_> ok so hm
03:01:30 <skypers_> for instance
03:01:33 <skypers_> vector space
03:01:35 <skypers_> is a category
03:01:36 <skypers_> right?
03:01:40 <skypers_> rings
03:01:42 <Cale> It's useful for understanding the big ideas behind some of the abstractions we throw around.
03:01:45 <skypers_> is another one
03:01:48 <funky_> Cale: I see
03:02:25 <skypers_> commutative group is another category
03:02:26 <Cale> skypers_: Yeah, for each field F, there is a category of vector spaces over F and linear transformations between them
03:02:43 <skypers_> and real with addition, 0 and -x is
03:02:44 <Cale> and all those are reasonable examples, but let's be clear about the definition
03:02:45 <skypers_> what?
03:02:55 <funky_> Cale: Are there any prerequisites to learning category theory? This is coming from a guy with a basic high school math background
03:03:06 <skypers_> funky_: I think so yes
03:03:08 <skypers_> like
03:03:11 <skypers_> morphisms
03:03:20 <skypers_> groups
03:03:28 <skypers_> and all that discrete math concepts
03:03:32 <Cale> funky_: Well, a lot of the trouble is that most texts are aimed at people who already have an undergrad degree
03:03:44 <funky_> oh snap :]
03:03:48 <quicksilver> There are very few actual prerequisites except being happy with abstraction
03:03:56 <skypers_> I think it’s quite important to know how such categories work
03:03:57 <quicksilver> however, it's very hard to get any *motivation* at all for category theory
03:04:00 <Cale> But fundamentally, there are very few real prerequisites
03:04:01 <skypers_> for instance, for Monoid
03:04:07 <quicksilver> without having at least some examples in mind
03:04:12 <skypers_> understand why we have mappend and mempty
03:04:15 <skypers_> :)
03:04:17 <quicksilver> and most of the examples of categories are undergraduate level
03:04:30 <funky_> Cale: so with some effort I should at least be able to get the basics?
03:04:30 <Cale> I would recommend Awodey's textbook as an example which tries about as hard as possible to avoid prerequisites
03:04:37 <skypers_> Cale: so talking about that, monoids are a category, right?
03:04:40 <skypers_> and hm
03:04:46 <chrisdone> Cale: spivak's book looks pretty good to me too
03:04:48 <tero-> I guess the best way to get motivation is to write enough simple repetetive code to start yearning for abstractions
03:04:53 <skypers_> (R,*,1) is what for monoids?
03:04:58 <skypers_> a structure?
03:05:12 <Cale> If you know basic things about sets, and you're okay with comprehending logical arguments (and are sufficiently stubborn), you can probably make it through Awodey's book.
03:05:17 <skypers_> 4 is an object
03:05:24 <skypers_> (R,*,1) is I don’t know what
03:05:32 <quicksilver> (R,*,1) is a monoid.
03:05:32 <skypers_> and the whole thing (monoid) is a category
03:05:34 <chrisdone> Category Theory for Scientists http://arxiv.org/abs/1302.6946
03:05:38 <Cale> But people should really let me write out the definition of a category already
03:05:40 <skypers_> ahah, sure
03:06:02 <quicksilver> every monoid is a category; also there is a category of all monoids
03:06:14 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf <-- this is what I'd recommend to most CS people
03:06:21 <skypers_> if we add to (R,*,1) the opposite (1/x), it becomes a group, and move into another category, right?
03:06:56 <Cale> Okay, so a category C consists of the following data:
03:07:09 <funky_> Cale: Thanks. I'll have to remember that if I get to study CS in uni
03:07:13 <danr> skypers_: a groupoid :)
03:07:21 <Cale> 1) An arbitrary collection Ob(C) of "objects" of C.
03:07:21 <skypers_> oh
03:07:33 <timthelion> Sometimes I wonder if edward kmett is actually one person...
03:07:33 <skypers_> it might be the english term for the french « groupe »
03:07:35 * hackagebot cndict 0.1.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.1.0 (DavidHimmelstrup)
03:07:52 <mm_freak_> funky_: some elementary category theory helps with communication
03:08:12 <Cale> 2) For each pair of objects X, Y in Ob(C), a collection C(X,Y) of "arrows". we write f: X -> Y to depict that f is in C(X,Y).
03:08:12 <quicksilver> skypers_: adding the inverse just makes it a group. groupoid is something else, possibly danr was making a joke.
03:08:22 <skypers_> ok
03:08:28 <skypers_> so I wasn’t mistaking
03:08:31 <quicksilver> skypers_: (but you do have to be careful with 0 if you want that to be a group)
03:08:34 <skypers_> DAMN YOU danr! :)
03:08:38 <Cale> 3) For each three objects, X, Y, Z, and arrows f: Y -> Z and g: X -> Y, a composite (f . g): X -> Z
03:08:42 <chrisdone> has anyone written a markdown to haddock converter?
03:08:44 <skypers_> quicksilver: if I don’t
03:08:46 <skypers_> it’s what?
03:08:50 <Cale> These are subject to the following conditions:
03:09:08 <skypers_> Cale: so a category defines composition?
03:09:15 <skypers_> well, has*
03:09:36 <Cale> For each four objects X, Y, Z, W and arrows: f: Z -> W, g: Y -> Z, h: X -> Y, we have (f . g) . h = f . (g . h) (composition is associative)
03:10:14 <skypers_> Cale: what are those objects?
03:10:21 <skypers_> for instance for the monoid category
03:10:28 <quicksilver> skypers_: I'm not aware of a special name for a group which fails at one point, although for all I know ther emight be one. it's most of the way to a field, of course
03:10:33 <skypers_> are they for instance 4, 54, -1?
03:10:35 <Cale> And for every object X, there is an arrow id_X: X -> X such that for any objects Y and Z and arrows f: X -> Y and g: Z -> X, we have f . id_X = f and id_X . g = g
03:11:17 <skypers_> Cale: hhhmm
03:11:28 <Cale> skypers_: The objects are whatever we like (the definition of a category only treats them as labels to specify when we can compose arrows), but for example,
03:11:32 <skypers_> isn’t that a generalized monoid?
03:11:35 <Cale> there is a category whose objects are sets
03:11:41 <Cale> and whose arrows are functions
03:11:56 <skypers_> Cale: hm
03:11:57 <skypers_> so
03:11:58 <Cale> i.e. f: X -> Y means that f is a function whose domain is X, and whose codomain is Y
03:12:00 <quicksilver> there is a sense in which a category is a generalisation of monoid, yes, skypers_.
03:12:04 <skypers_> R is a category?
03:12:08 <skypers_> I don’t think so :(
03:12:22 <skypers_> quicksilver: nice!
03:12:25 <skypers_> so hm
03:12:27 <quicksilver> (there are different senses in which it is a generalisation of lots of different things)
03:12:51 <skypers_> (R,*,1) is a monoid; do you treat it as an object, Cale ?
03:12:56 <quicksilver> a monoid is a category with only one object, so a category is, from one perspective a "multiple monoid".
03:13:07 <quicksilver> that's not normally the most useful way to think of them though.
03:13:14 <skypers_> one object?
03:13:16 <skypers_> why?
03:13:18 <Cale> If M is any monoid, then there is a category with a single object, call it *, and whose arrows * -> * are the elements of M, and where composition is defined according to the multiplication for M
03:13:34 <Cale> Similarly, any one-object category is a monoid in that respect.
03:13:48 <skypers_> I don’t understand why they’re only one object
03:13:58 <skypers_> I need some one to define “object” here
03:13:59 <Cale> Because we can multiply any two elements of M
03:14:09 <quicksilver> skypers_: there isn't a definition of object.
03:14:11 <Cale> Objects exist to express when we're allowed to compose arrows
03:14:12 <skypers_> yeah, so there’re plenty of objects!
03:14:30 <quicksilver> skypers_: objects are just a naming convention that we use to explain composition.
03:14:43 <quicksilver> it happens that you can express a monoid as a category on one object.
03:14:55 <quicksilver> that doesn't mean that "one object" is anything intrinsic or interesting to monoids
03:14:56 <skypers_> headache.
03:14:59 <quicksilver> it's just how the definitions work out.
03:15:15 <Cale> skypers_: More examples will help.
03:15:18 <quicksilver> I should probably let Cale do the explanation. Two overlapping agreeing explanations are not better than one.
03:15:27 <skypers_> sure they will :D
03:15:38 <skypers_> but first
03:15:51 <skypers_> do you agree that (R,*,1) is a monoid, and then a category?
03:15:57 <Cale> skypers_: But for now, do you see how, say, we could have a category with one object, and where there are a bunch of arrows from that object to itself corresponding to the integers, and where we define n . m to be n + m?
03:16:03 <skypers_> so in that monoid, there might be objects, right?
03:16:23 <Cale> So, e.g. 3: * -> * and 5: * -> *, and when we compose them, we get 8: * -> *
03:16:26 <skypers_> Cale: for the last part, yes
03:16:36 <skypers_> but I don’t understand the “one object”
03:16:54 <skypers_> 3: * -> *
03:16:54 <skypers_> ?
03:17:05 <Cale> yeah, * is the name I've given to the one object of my category
03:17:21 <Cale> (we could give it any name you like, it doesn't matter)
03:17:36 <skypers_> hm
03:17:42 <skypers_> so in your monoid
03:17:47 <skypers_> you have an object called *
03:17:47 <skypers_> ?
03:18:18 <skypers_> damn I gotta go
03:18:21 <Cale> and because the head of any arrow lines up with the tail of any other in a category with one object, we can compose any pair of arrows, just like how with a monoid, we're allowed to multiply any two elements of the monoid
03:18:25 <skypers_> I’ll be back by an hour
03:18:33 <Cale> In my *category* I have an object called *
03:18:42 <Cale> The monoid gives us all the arrows from * to itself.
03:18:52 <skypers_> oh
03:19:04 <skypers_> I think I’m starting understand
03:19:09 <skypers_> I really got to go Cale
03:19:14 <Cale> okay, see you soon :)
03:19:16 <skypers_> can we postpone?
03:19:17 <skypers_> :)
03:19:22 <Cale> Let me know when you'd like to continue
03:19:25 <skypers_> talk to you later
03:19:26 <skypers_> yeah sure
03:19:31 <skypers_> thank you
03:19:35 <Cale> no problem
03:28:13 <darthdeus> what's the idiomatic way of writing "short circuting for loop"? like the kind that's   for (...) { if (something) { return true; } } return false;
03:29:34 <mauke> :t any
03:29:35 <lambdabot> (a -> Bool) -> [a] -> Bool
03:29:45 <chrisdone> use the ContT monad
03:29:54 <mauke> haha
03:30:32 <mauke> if all you have is a nuclear powered swiss chainsaw, every problem looks like a thumb
03:31:00 <darthdeus> oh wow
03:31:49 <startling> it's hardly even a loop :)
03:32:45 <darthdeus> mauke: but any returns true/false, i need the actual element :\
03:33:02 <darthdeus> something like firstThatSatisfiesAPredicate :P
03:33:08 <dv-> dropWhile?
03:33:09 <startling> :t takeUntil
03:33:10 <lambdabot> Not in scope: `takeUntil'
03:33:16 <startling> :t dropWhile
03:33:17 <lambdabot> (a -> Bool) -> [a] -> [a]
03:33:22 <darthdeus> :t find
03:33:23 <lambdabot> (a -> Bool) -> [a] -> Maybe a
03:33:38 <darthdeus> i won :D
03:34:26 <dv-> :t Control.Monad.Loops.iterateUntil
03:34:27 <lambdabot> Monad m => (a -> Bool) -> m a -> m a
03:35:36 <Entroacceptor> :t takeWhile
03:35:38 <lambdabot> (a -> Bool) -> [a] -> [a]
03:35:41 <donri> :t fmap head . filter
03:35:42 <lambdabot> (a -> Bool) -> [a] -> a
03:35:43 <darthdeus> ahhh shit, i also need an index
03:35:49 <donri> :t findIndex
03:35:50 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
03:36:01 <darthdeus> donri: both index and the element :\
03:36:11 <darthdeus> oh never mind
03:36:15 <darthdeus> i can get the element by the index
03:36:25 <donri> that's wasteful
03:36:44 <dv-> :t find (\(i,e) -> e == ?p) (zip ?xs [0..])
03:36:46 <lambdabot> (Enum a, Eq a, Num a, ?p::a, ?xs::[t]) => Maybe (t, a)
03:36:55 <darthdeus> and stupidly enough, i don't need the index, because the original solution in C has the index equal to the value, but since i'm using [1..] the index and the value are the same :X
03:37:03 <darthdeus> dv-: wow that's smart
03:37:13 <donri> hehe
03:37:20 <darthdeus> but i'm not sure what the question marks mean there?
03:37:27 <darthdeus> wouldn't it work without htem?
03:37:35 <donri> those are just "placeholders" here
03:37:42 <donri> substitute them for your predicate/list
03:38:23 <dv-> flip the zip arguments too
03:41:32 <chrisdone> huh, cannot upload to hackage. 403 forbidden
03:42:09 <donri> chrisdone: have you upgraded your account? i think you have. do you own the package?
03:43:43 <augustss> How does one upgrade the account?
03:44:26 <donri> augustss: logging in on the website
04:13:09 <fizruk> is there a function of type (a -> c) -> (b -> d) -> Either a b -> Either c d ?
04:13:21 <aleksejs_> could someone explain me one thing?
04:13:21 <aleksejs_>  let x = 1 in [0..5] !! x" this works, but
04:13:22 <aleksejs_>  let x = 1
04:13:22 <aleksejs_>  [0..5] !! x
04:13:22 <aleksejs_> this doesnt
04:13:35 <t7> fizruk: either
04:13:42 <t7> :t either
04:13:43 <aleksejs_>  /ignore ", typo/
04:13:43 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
04:13:52 <Lethalman> aleksejs_, missing "in" ?
04:13:57 <fizruk> t7, not exactly
04:14:16 <t7> yeah my bad
04:14:27 <t7> that will work though if you use Left and Right
04:14:31 <aleksejs_> Lethalman, x is defined, it just has another type
04:14:44 <skypers_> back
04:14:55 <fizruk> t7, I guess I'll do that
04:14:57 <aleksejs_> it shows: Couldn't match expected type `Int' with actual type `Integer'
04:15:03 <skypers_> Cale: are you there? :)
04:15:07 <Lethalman> aleksejs_, I mean let x = 1\nin [0..5] !! x
04:15:15 <Cale> skypers_: hello!
04:15:21 <skypers_> hi!
04:15:32 <skypers_> I remembered
04:15:54 <skypers_> a friend (alp) sent me something about categories at some day
04:16:00 <skypers_> I should try to find it again
04:16:04 <t7> :t either (Left . (+ 1)) (Right . ('a':))
04:16:05 <lambdabot> Num b => Either b [Char] -> Either b [Char]
04:16:10 <aleksejs_> Lethalman, there's a "let" because i copied it form ghci
04:16:18 <skypers_> http://tlc.awesom.eu/articles/introduction-aux-categories/ here it is (french)
04:16:18 <aleksejs_> wait a sec
04:16:55 <Lethalman> aleksejs_, then [0..5] !! (fromIntegral x)
04:17:13 <Cale> skypers_: So, yeah, if we restrict the definition of a cateogry by insisting that there's only one object, what we end up with is effectively a monoid.
04:17:40 <fizruk> aleksejs_, or let x = 1 :: Int; [0..5] !! x
04:17:47 <fizruk> :t (!!)
04:17:48 <skypers_> Cale: hm
04:17:49 <lambdabot> [a] -> Int -> a
04:17:59 <skypers_> such a single object?
04:18:15 <quicksilver> s/effectively/precisely/
04:18:19 <darthdeus> how can i do [5..1] so that it generates [5,4,3,2,1] ?
04:18:27 <quicksilver> > [5,4..1]
04:18:28 <lambdabot>   [5,4,3,2,1]
04:18:37 <quicksilver> like that, darthdeus
04:18:57 <skypers_> how would you caracterize such an object?
04:19:16 <Cale> skypers_: The monoid consists of set of arrows from that one object to itself, and the multiplication of the monoid is the composition of the category.
04:19:27 <darthdeus> quicksilver: perfect, thanks
04:20:01 <skypers_> hhm
04:20:04 <skypers_> I see
04:20:08 <skypers_> oh
04:20:10 <skypers_> ok
04:20:13 <skypers_> now I got it
04:20:39 <aleksejs_> fizruk, Lethalman thanks
04:20:40 <skypers_> the set of arrows
04:20:44 <skypers_> morphisms
04:20:48 <skypers_> what are they?
04:20:50 <skypers_> for instance
04:21:01 <skypers_> (R,*,1)
04:21:06 <skypers_> but hm
04:21:07 <skypers_> is 4 a morphism in such a category?
04:21:10 <quicksilver> yes.
04:21:15 <Cale> If R is the set of real numbers, then yeah
04:21:18 <quicksilver> the morphisms are the elements of the monoid
04:21:25 <skypers_> hm
04:21:29 <quicksilver> the composition is the operation *
04:21:37 <quicksilver> and the identity element is the identity morphism
04:21:37 <Cale> (I'm going to continue using arrow instead of morphism, but that's just me)
04:22:04 <skypers_> aren’t the morphisms of a monoid binary?
04:22:13 <skypers_> how could 4 be a morphism then?
04:22:14 <quicksilver> this category is quite a good example of one reason people don't like the word morphism
04:22:26 <Cale> skypers_: I'm confused about what you just said :)
04:22:31 <quicksilver> 4 is a morphism of the category, skypers_
04:22:39 <quicksilver> not sure what "morphisms of a monoid" means.
04:22:39 <skypers_> Cale: well
04:22:40 <Cale> Let's not use the word morphism at all
04:22:40 <darthdeus> quicksilver: so if i want an arbitrary number, i would do [n, n-1..1], right?
04:22:45 <quicksilver> darthdeus: yes.
04:22:49 <skypers_> in (R,*,1)
04:22:52 <Cale> Unless we're talking about structure-preserving functions
04:22:56 <quicksilver> > let n = 10 in [n,n-1..1]
04:22:57 <skypers_> 4 is in such monoid
04:22:58 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
04:23:00 <Cale> of some type
04:23:06 <skypers_> and 5 is also in there
04:23:14 <skypers_> you can apply * on 4 and 5
04:23:15 <Cale> Like, there is a category whose objects are monoids, and whose arrows are monoid homomorphisms.
04:23:22 <skypers_> you’ll still being stuck in that monoid
04:23:23 <Cale> But arrows of a category need not be functions.
04:23:27 <skypers_> (20)
04:23:48 <skypers_> s/being/be
04:24:15 <quicksilver> skypers_: this is why not to use the word morphism. YOu're confusing two things.
04:24:28 <quicksilver> 4 is an arrow in the one-object category we have been describing.
04:24:32 <quicksilver> so is 5.
04:24:42 <skypers_> huh
04:24:53 <skypers_> 4, an arrow?
04:25:07 <Cale> skypers_: Let (M,*,1) be any monoid at all. In order to define a category, we need to specify 3 things: 1) What are its objects? 2) For any two objects, what are the arrows between them? 3) Given any two arrows which line up end to end, what is their composite?
04:25:08 <startling> 4 is sort of pointy, depending on your font
04:25:28 <Cale> skypers_: So, we define the objects of our category to just be a single object, say O
04:25:46 <Cale> and then we define the arrows of our category O -> O to be elements of M
04:25:54 <skypers_> yeah
04:26:08 <skypers_> O -> O is definitely an arrow for me too
04:26:11 <skypers_> but only 0 ?
04:26:11 <Cale> and then for any two arrows f, g: O -> O, we need to say how they compose
04:26:12 <skypers_> O*
04:26:24 <Cale> but f and g are elements of M here
04:26:29 <Cale> and we have the multiplication *
04:26:39 <Cale> So we can define f . g = f * g
04:26:54 <skypers_> so here, an object of a monoid is an arrow?
04:27:05 <Cale> objects are part of the definition of a category
04:27:07 <Cale> not of a monoid
04:27:18 <skypers_> yes
04:27:21 <Cale> The elements of M are the arrows of our category
04:27:27 <skypers_> so an arrow
04:27:30 <skypers_> of a monoid
04:27:39 <skypers_> is the object of the considered category?
04:27:40 <Cale> We're *building* this category, so we get to decide which objects and arrows and composition it has.
04:27:42 <quicksilver> no.
04:27:49 <Cale> So long as it follows the rules.
04:27:51 <skypers_> ok so
04:27:53 <skypers_> the object is O
04:27:53 <quicksilver> monoids do not have arrows, skypers_.
04:28:04 <quicksilver> "an arrow of a monoid" does not mean anything.
04:28:17 <quicksilver> categorys have arrows and objects; monoids have elements and an operation.
04:28:18 <hpc> skypers_: slow down and let Cale finish explaining ;)
04:28:21 <skypers_> the arrows are a set of thing that transport objects to objects
04:28:32 <skypers_> so here, f(O) = O
04:28:45 <skypers_> [13:20] <quicksilver> categorys have arrows and objects; monoids have elements and an operation.
04:28:46 <skypers_> yes
04:28:47 <skypers_> and here
04:28:56 <skypers_> I’m confusing elements and objects
04:29:32 <quicksilver> I think you are.
04:29:47 <skypers_> if I understand what Cale said
04:29:48 <Cale> A monoid consists of: An arbitrary set M together with a multiplication function *: M x M -> M, such that 1) multiplication is associative: for any elements a, b, c in M, we have a * (b * c) = (a * b) * c, and 2) there is some element 1 in M such that for any a in M, we have 1 * a = a, and a * 1 = a.
04:30:08 <skypers_> sure Cale
04:30:21 <skypers_> I know what a monoid is
04:30:28 <Cale> There are no objects or arrows in the basic definition of a monoid. However, once we get through this bit, we could also define a monoid to be a category with a single object (it's just a baroque way to do so0
04:30:29 <skypers_> but the way you define the category
04:30:31 <skypers_> I don’t get it
04:30:47 <darthdeus> is there something like foldUntil?
04:31:00 <skypers_> wait wait
04:31:07 <skypers_> you said
04:31:19 <skypers_> a category has objects, and arrows between objects
04:31:21 <fizruk> darthdeus, takeWhile with scanl?
04:31:24 <skypers_> some laws on the arrows
04:31:28 <skypers_> here
04:31:39 <skypers_> the composition is the inner law of the monoid (say *)
04:31:58 <Cale> Don't use the word 'law' where you mean multiplication :)
04:32:02 <skypers_> so composing monoids is simply applying the * operator
04:32:23 <skypers_> so now, what are objects?
04:32:30 <Cale> composing *arrows* is applying the multiplication of the monoid
04:32:36 <fizruk> > dropWhile (< 10) $ scanl (+) 0 [1..n]
04:32:38 <lambdabot>   *Exception: not a number
04:32:46 <Cale> Because we're taking the arrows of our category from the one object O to itself to be the elements of the monoid.
04:32:50 <fizruk> > dropWhile (< 10) $ scanl (+) 0 [1..]
04:32:52 <lambdabot>   [10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276,300,...
04:32:58 <skypers_> oh yes, it’s about arrows
04:33:25 <skypers_> so
04:33:30 <skypers_> f . g = f * g?
04:33:46 <Cale> skypers_: yes
04:33:51 <skypers_> and f and g are arrows, so the arrow of a monoid is a single element
04:34:00 <Cale> "arrow of a monoid"
04:34:04 <skypers_> well
04:34:05 <Cale> doesn't make sense
04:34:17 <skypers_> the arrows of the monoid category?
04:34:18 <Cale> The monoid (M,*,1) doesn't have any arrows
04:34:27 <Cale> yeah
04:34:37 <skypers_> well to make the monoid (R,*,1) we define arrows as elements of R
04:34:38 <skypers_> is that so?
04:34:41 <Cale> The arrows of the category corresponding to this monoid are the elements of the monoid.
04:34:44 <Cale> yeah
04:34:48 <skypers_> ahah
04:34:50 <skypers_> got it
04:35:00 <skypers_> I thought arrows were always functions
04:35:04 <skypers_> so here
04:35:14 <skypers_> I thought arrows were actually the * operation
04:35:23 <Cale> One point of this example is to break you of that notion :)
04:35:34 <skypers_> so why do we call them that way?
04:35:35 <Cale> The arrows are arbitrary things we get to decide on
04:35:37 <skypers_> why arrows?
04:36:07 <Cale> Well, because they relate pairs of objects somehow in a directed fashion :)
04:36:18 <skypers_> 4 relates pairs?
04:36:22 <Cale> and it's nice way to visualise the data we have
04:36:37 <skypers_> if we compose 4 and 6
04:36:38 <Cale> Well, in *this* case, we're trivialising the notion of a category in one way
04:36:51 <Cale> If we only have one object, then any pair of arrows will be composable
04:37:06 <Cale> and the whole reason for thinking of them as arrows is a little lost
04:37:14 <skypers_> hm
04:37:28 <Cale> But the definition still works, nonetheless.
04:37:33 <quicksilver> when I call them arrows I'm thinking of a picture
04:37:50 <quicksilver> where you draw a category on a piece of paper with dots (objects) and arrows (connecting objects)
04:37:52 <Cale> Let's look at another big class of examples, obtained by trivialising the definition of a category along another axis
04:38:04 <quicksilver> a one-object category only has a single dot and all the arrows are just looping back.
04:38:25 <skypers_> are functions a category then?
04:38:36 <Cale> Given a set S, a preorder on S is a binary relation <= satisfying the following properties:
04:38:39 <skypers_> we can compose them
04:38:47 <Cale> 1) For any a in S, we have a <= a (reflexivity)
04:39:05 <Cale> 2) For any a, b, c in S, if a <= b and b <= c, then a <= c (transitivity)
04:39:27 <Cale> Most of the notions of ordering that you can probably think of meet these conditions
04:39:34 <skypers_> yes
04:39:50 <quchen> It's a shame Cale explaind this to me in #haskell-blah, because that channel is unlogged.
04:40:04 <Cale> Okay, so given a set S with a preorder (<=), we can form a category whose objects are the elements of S
04:40:18 <Cale> and where there is exactly one arrow x -> y whenever x <= y
04:40:23 <Cale> and no others
04:40:35 <donri> chrisdone: you should log Cale on ircbrowse
04:41:04 <quchen> donri: He would also have to log his conversation partners, otherwise he would awkwardly talk to himself about abstract things.
04:41:28 <donri> that's part of the fun!
04:41:33 <quicksilver> awkwardly talking to oneself about abstract things is the fate of most category theorists in the end.
04:41:38 <skypers_> but hm
04:41:43 <bezirg> i have a question about STM: i want to embed an IO into an STM transaction and I wanted to be executed every time the transaction retries
04:41:44 <Cale> Then whenever f: y -> z and g: x -> y are arrows (so that y <= z and x <= y), we have that x <= z by transitivity, and so there's a unique arrow x -> z to serve as the composite
04:41:45 <quicksilver> c.f. garfield without garfield
04:42:01 <quchen> quicksilver: ?
04:42:14 <quchen> bezirg: You do not want to embed IO in STM.
04:42:17 <Cale> and for each object x, we know that x <= x by reflexivity, so there is a unique arrow x -> x to serve as the identity arrow
04:42:22 <Cale> id_x
04:42:26 <bezirg> quchen: but what if I want
04:42:38 <bezirg> quchen: I want to count how many times the transaction retries
04:42:40 <skypers_> that’s so weird
04:42:54 <skypers_> arrows are preorder laws here?
04:42:55 <Cale> So, the notion of composition becomes a little trivial in this construction, but we nonetheless obtain a category with at most one arrow between any pair of objects (in any given direction)
04:43:05 <skypers_> f : x -> y is an arrow and means that x <= y
04:43:12 <Cale> yeah
04:43:22 <skypers_> g : y -> z
04:43:29 <quchen> bezirg: Well if it's just for debugging, you can use some of the extremely unsafe functions here. Have a look at Debug.Trace.trace's source, you can easily modify that to add a counter.
04:43:36 <skypers_> so g . f means x <= z
04:43:54 <quchen> bezirg: But take a long shower after you've done that. And make sure none of it is left in the code when you're done.
04:43:55 <Cale> and of course, if we're given a category with a set of objects, and which has at most one arrow between any ordered pair of objects, then we get a preorder by saying that x <= y whenever there's an arrow x -> y
04:44:05 <Cale> So it goes both ways
04:44:21 <Cale> So categories can be looked at as simultaneously generalising monoids and preorders.
04:44:33 <skypers_> nice
04:44:39 <Cale> These are two different "axes" along which we're generalising
04:44:59 <bezirg> quchen: I do sth similar with Debug.Trace.trace
04:45:20 <bezirg> quchen: I put: unsafePerformIO (inc counter)
04:45:26 <Cale> Okay, so functors
04:45:38 <bezirg> quchen: but I think my counter just runs only once, and not on every retry, because of sharing maybe?
04:46:21 <skypers_> Cale: functors are arrows between category aren’t they?
04:46:32 <donri> bezirg: why not make the counter a TVar
04:46:34 <skypers_> categories*
04:46:37 <Cale> skypers_: yes, eventually
04:46:43 <quchen> donri: Because that's rolled back on retry.
04:46:46 <Cale> skypers_: But saying that doesn't tell us much on its own
04:46:59 <donri> quchen: d'oh
04:47:01 <quchen> :-)
04:47:24 <quchen> bezirg: I'm not sure. What you're doing there is way down the "unsafe" road, so you'll have to experiment. I think your problem could be with inlining.
04:47:24 <Cale> skypers_: It's nice to know that we'll eventually be able to form a category of (small) categories, but we still need a proper definition of how that all works :)
04:47:38 <skypers_> yeah
04:47:44 <bezirg> donri: it cannot be done with a TVar, bcs a TVar resets on a retry
04:47:51 <donri> bezirg: yeah ignore that :)
04:47:54 <quchen> bezirg: Note how 'trace' has a NOINLINE pragma.
04:48:00 <Cale> skypers_: So given a pair of categories C and D, a functor F: C -> D consists of the following:
04:48:08 <Cale> 1) A mapping on objects: For each object X in C, we have a choice of some object FX in D.
04:48:10 <quchen> Add that to your counter function. Or explicitly make it INLINE.
04:48:13 <donri> bezirg: did you read the notes for unsafePerformIO? http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO-Unsafe.html
04:48:15 <skypers_> a mapping on morphisms
04:48:34 <Cale> 2) A mapping on arrows: For each arrow a: X -> Y in C, we have a choice of some arrow Fa: FX -> FY in D.
04:48:46 <bezirg> quchen: maybe u r right about noinline pragma
04:48:51 <bezirg> donri: yes I have
04:49:00 <Cale> These are subject to the following conditions:
04:49:01 <bezirg> i will let you know
04:49:16 <Cale> 1) For each object X in C, we have F(id_X) = id_(FX)
04:50:01 <Cale> 2) For each three objects X, Y, Z in C, and arrows a: Y -> Z and b: X -> Y in C, we have that F(a . b) = (Fa) . (Fb)
04:50:28 <Cale> and that's all :)
04:50:59 <skypers_> yeah
04:51:02 <skypers_> I see
04:51:11 <Cale> So in Haskell, we tend to think about the category whose objects are ordinary Haskell types, and where the arrows between those are Haskell-definable functions between those types.
04:51:11 <skypers_> so if we have the category (R,1,*)
04:51:26 <skypers_> and another category C
04:51:40 <Cale> Well, sure, let's do that :)
04:51:57 <skypers_> if we take the arrow 3
04:52:07 <skypers_> there’s a another arrow in C
04:52:07 <Cale> First, let's start with two categories which are obtained from a monoid
04:52:10 <skypers_> one or several?
04:52:22 <Cale> In fact, I'll be very concrete
04:52:39 <danr> skypers_: one
04:53:17 <skypers_> ok danr, thank you
04:53:21 <Cale> Let's start with the category corresponding to the monoid of real numbers under addition, and the category corresponding to the monoid of positive real numbers under multiplication.
04:53:40 <skypers_> (R,+,0) and (N,*,1) then?
04:53:56 <merijn> ha
04:53:59 <merijn> hmmm
04:54:02 <Cale> no, (R,+,0) and (R+,*,1)
04:54:04 <merijn> That was the wrong channel >.<
04:54:13 <skypers_> oh positive real, yeah
04:54:24 <Cale> Our categories each have one object, so that part of the functor will be boring (we have no choice to send the single object of one to the single object of the second)
04:54:40 <skypers_> yeah, but several arrows
04:54:52 <Cale> Where "several" is "uncountably infinite" :)
04:55:16 <skypers_> sure :)
04:55:21 <quchen> several = aleph_0.5
04:55:25 <skypers_> but wait
04:55:32 <skypers_> the part of the functor on objects
04:55:51 <skypers_> is a morphism that transports a R into R+
04:55:52 <skypers_> right?
04:55:55 <Peaker> guess what's wrong with:  isEqual <- ((== content) <$> readFile filename) `catch` \SomeException{} -> return False ; unless isEqual $ writeFile filename content
04:55:59 <Cale> no
04:56:13 <Cale> Remember how we defined the category corresponding to a given monoid
04:56:23 <Cale> It has exactly one object
04:57:09 <quchen> Peaker: Missing "do"
04:57:12 <Cale> So, if we call that single object * in the case of (R,+,0) and, say, ! in the case of (R+,*,1)
04:57:20 <Cale> then we want to define F* = !
04:57:35 <Cale> Or I could use letters if the double use of * is confusing :P
04:57:36 <skypers_> oh
04:57:42 <skypers_> yeah
04:57:43 <skypers_> x and y
04:57:52 <skypers_> or r and rp
04:57:53 <Cale> So yeah, Fx = y
04:57:58 <Cale> or whatever
04:57:59 <skypers_> sure
04:58:09 <Peaker> quchen: nope
04:58:11 <Cale> It really doesn't matter what we call the one object, because it's unique
04:58:15 <Peaker> quchen: deeper than that
04:58:21 <quchen> Peaker: I know :-P
04:58:32 <Peaker> hint: it's the usual suspect
04:58:36 <Cale> So as long as we convey the idea that we're referring to an object, we're sure to refer to the right one :)
04:58:56 <quchen> Peaker: Is this an addition to the previous discussion about race conditions?
04:59:05 <Cale> Okay, so the mapping on arrows part is interesting though
04:59:08 <Peaker> quchen: nope, just an annoying bug I encountered now
04:59:18 <skypers_> Cale: hm
04:59:26 <Peaker> quchen: lazy I/O strikes me almost every time I try to use it
04:59:28 <quchen> Peaker: Wait, it's *always* wrong?
04:59:30 <quchen> Ah okay.
04:59:38 <Cale> We need F(a . b) = (Fa) . (Fb), where the . on the left of the equation is composition in our first category, i.e. it's addition
04:59:50 <Peaker> quchen: and so many people say "lazy I/O works almost all the time" or "if you don't care about resource leaks (trivial programs), lazy I/O is fine"
04:59:53 <Cale> and the . on the right of the equation is the composition in our second category, i.e. it's multiplication
05:00:06 <Cale> i.e. F(a + b) = (Fa) * (Fb)
05:00:11 <quchen> Peaker: Unless you write to the file while you read it. Circularity leak!
05:00:12 <Peaker> and IME, lazy I/O is an infinite source of bugs and frustration.. e.g: here, the readFile isn't fully forced by (==), so the file isn't closed, so the writeFile fails immediately after :(
05:00:21 <Cale> can you think of a function sending the real numbers to the positive real numbers which satisfies this? :)
05:00:42 <Peaker> despite the fact that a deterministic GC (if one existed) could finalize the file as soon as the comparison was done
05:00:44 <quchen> Peaker: Oh, I didn't see that one.
05:00:51 <skypers_> Cale: exp?
05:00:54 <Cale> yes!
05:00:58 <skypers_> :)
05:01:01 <Peaker> quchen: yeah, lazy I/O strikes in ways people who defend it almost never categorize
05:01:02 <quchen> Peaker: What if you add a manual "performGC"?
05:01:11 <Cale> And note that it also satisfies F(id) = id, because exp(0) = 1
05:01:12 <Peaker> quchen: Haven't tried it, it's too evil anyway
05:01:12 <quchen> (Not that that's a good solution)
05:01:22 <skypers_> so the morphism of arrows is exp?
05:01:33 <skypers_> woah
05:01:49 <quchen> Peaker: Actually, let me create a new file that I'll use to collect lazy IO pitfalls. So people can learn from them and not use lazy IO.
05:01:54 <Cale> So exp provides the arrow part of a functor between these two monoid categories
05:02:21 <Cale> skypers_: Of course, once we look at this in a little more generality, it'll be less surprising
05:02:32 <Peaker> quchen: another pitfall I encountered:  timeout (seconds 3) $ readFile "foo"    doesn't work
05:02:43 <quchen> ?
05:02:47 <skypers_> Cale: there’s just something I still hardly got
05:02:51 <quchen> Peaker: AAAAH
05:02:54 <quchen> Peaker: I see it.
05:03:00 <quchen> There should be a gameshow for this!
05:03:09 <mauke> I'd expect readFile to not block in normal cases
05:03:16 <skypers_> the part when you said that monoid as categories only have one object
05:03:22 <skypers_> you call it O
05:03:24 <Peaker> mauke: true, my real example was getContents from stdin
05:03:32 <Cale> skypers_: Yeah, we could still call it O if you like
05:03:38 <mauke> same :-)
05:03:50 <Peaker> mauke: stdin was interactive :)
05:03:58 <Cale> and then FO = O', where O' is the O for the second monoid category
05:04:04 <mauke> getContents does "nothing" in some sense
05:04:05 <Peaker> quchen: with all the fuss about "reasoning about programs", many don't seem to care that code involving lazy I/O has subtle behaviors/bugs that are very hard to reason about
05:04:11 <skypers_> Cale: yeah sure
05:04:19 <skypers_> but what is _really_ this O?
05:04:34 <skypers_> in term of monoid (R,*,1) for instance
05:05:01 <Cale> It's nothing in particular.
05:05:06 <Cale> We're not going to look inside it.
05:05:17 <Cale> It just has to formally be there to provide a place to put arrows.
05:05:27 <Cale> It's just a label
05:05:38 <skypers_> Cale: because arrows are between objects
05:05:40 <skypers_> so here
05:05:41 <Cale> yeah
05:05:43 <Peaker> another lazy I/O pitfall example:  withFile "foo" ReadMode $ \h -> ... hGetContents h ...
05:05:52 <Cale> So we need at least one object if we're going to have any arrows at all
05:05:54 <skypers_> all arrows
05:05:58 <skypers_> will take a O
05:06:02 <skypers_> and lead into a O
05:06:10 <skypers_> isn’t that stupid?
05:06:15 <mauke> Peaker: oh eah, that's a fun one
05:06:15 <Cale> If you like to think of them in a kind of function-y way
05:06:26 <mauke> y
05:06:31 <quicksilver> skypers_: "stupid"? it's just a simple case. A degenerate case if you like.
05:06:32 <Cale> But yeah, all the arrows will have both their head and tail at O
05:06:43 <quicksilver> although monoids are interesting so it's not that degenerate.
05:06:57 <Cale> It's exactly the kind of stupid that we need in order to represent a monoid.
05:07:08 <skypers_> Cale: I think that’s the most disturbing part is the fact arrows are elements
05:07:13 <skypers_> that*
05:07:47 * hackagebot cndict 0.1.1 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.1.1 (DavidHimmelstrup)
05:07:47 <Cale> We can also form a category whose objects are natural numbers, and where the arrows n -> m are n-by-m matrices of real numbers
05:07:56 <Cale> and we compose arrows by matrix multiplication
05:08:01 <bezirg> quchen: NOINLINE did not work, I did it with GHC.Conc.Sync.unsafeIOToSTM
05:08:09 <bezirg> quchen: ty anywayz!
05:08:36 <skypers_> Cale: do you know a category in which objects are more interesting?
05:08:37 <mr-> Cale: i.e. finite dim. vector spaces?
05:09:07 <Cale> mr-: More or less, except for the fact that the point I'm making is that what's inside the objects doesn't matter :)
05:09:29 <quchen> Peaker: I don't see what's wrong with this one.
05:09:30 <skypers_> hm
05:09:48 <skypers_> is it possible to represent all the monoids that have a (+,1) part as a category?
05:10:09 <skypers_> I mean, the monoids (a,+,1) where a is whatever
05:10:10 <Peaker> quchen: well, iff you force the result of hGetContents completely, that's fine
05:10:13 <Cale> skypers_: Well, the canonical example category is sets and functions. There's a category whose objects are all sets, and where the arrows X -> Y are functions from X to Y
05:10:32 <skypers_> so functions are category?
05:10:37 <skypers_> form*
05:10:44 <Peaker> quchen: if you return a reference to the contents out of the "withFile", the file is already closed, but the contents value is still expecting to lazily read the rest
05:10:46 <quchen> Peaker: Oh right. Otherwise the contents are lazy and the handle closes
05:10:48 <mauke> quchen: both withFile and hGetContents close the handle
05:10:51 <skypers_> hm
05:10:52 <Cale> i.e. triples (X,Y,G) where G is a set of pairs (x,y) with x in X and y in Y such that for each x in X, there is exactly one y in Y for which (x,y) is in G
05:11:03 <Cale> and we write f(x) = y when (x,y) is in G
05:11:10 <Peaker> quchen: so you'll be able to read until some arbitrary chunk boundary and then you'll get an asynchronous exception about the handle being closed later :(
05:11:34 <quchen> So there's two things crashing here really
05:11:40 <skypers_> let’s talk about binary functions. if they form a category, they’re two objects O and P, the arrows are functions, and the composition is the natural function composition
05:11:43 <skypers_> is that possible?
05:11:56 <Cale> sorry, what?
05:12:24 <skypers_> two objects because the functions are E -> D
05:12:25 <skypers_> so we need two objects, right?
05:12:31 <skypers_> or should I just shut up?
05:12:38 <Peaker> btw, someone suggested parameterizing handles like:  Handle ReadOnly, HandleReadWrite, etc. Maybe also:  Handle AutoClose  vs.  Handle ManualClose,  so hGetContents uses Handle ManualClose only, and withFile yieldling Handle AutoClose or such
05:12:39 <Cale> You want two objects O and P, so, you'll need to specify what the arrows O -> O, and O -> P, and P -> O, and P -> P are
05:12:40 <quchen> Peaker: 1. contents aren't forced. withFile closes handle, using contents afterwards fails.  2. hGetContents closes handle because it's forced, withFile tries to close a closed handle. (Does that throw?)
05:12:54 <Peaker> quchen: I think double-close won't raise an exception
05:12:59 <Cale> and then how they compose.
05:13:04 <skypers_> :D
05:13:05 <mauke> Peaker: I don't think you'll get an exception
05:13:07 <skypers_> Cale: well
05:13:10 <mauke> hGetContents will just return ""
05:13:18 <skypers_> if I have a function N -> R
05:13:23 <Peaker> mauke: I tested it with ByteString.Lazy where I get an exception.
05:13:23 <skypers_> what is the category then?
05:13:29 <mauke> oh, bytestrings
05:13:34 <Cale> I'm not sure what category to suggest
05:13:52 <mauke> ghc -e 'System.IO.withFile "/dev/urandom" System.IO.ReadMode System.IO.hGetContents'
05:13:54 <Cale> But that function is itself an arrow in the category of sets and functions
05:14:06 <Cale> (all functions are)
05:14:15 <kqr> is there an agreed way to say that two haskell functions are equivalent in the sense that they will produce the same results for the same arguments?
05:14:20 <Peaker> mauke: that crashes because it fails UTF8 decode on it
05:14:20 <skypers_> ok ok
05:14:29 <mauke> Peaker: ?
05:14:30 <skypers_> I think that’s quite enough for today
05:14:31 <Peaker> mauke: at least when I tried something equivalent
05:14:33 <Cale> kqr: Yes, we say that the functions are equal.
05:14:36 <mauke> Peaker: I get ""
05:14:48 <Cale> skypers_: All right :)
05:14:52 <mauke> because it can't actually read anything because withFile closes the file
05:14:52 <Peaker> mauke: Oh, you're not forcing anything in the withFile
05:14:53 <kqr> Cale, and = is a good character to use for that?
05:15:01 <Cale> skypers_: Did you grab that book I linked?
05:15:02 <Peaker> mauke: I tried forcing just 1 character inside the withFile
05:15:08 <Cale> kqr: sure
05:15:51 <Cale> kqr: You might in some contexts want to be careful to distinguish that = (semantic equality) with the = sign in Haskell definitions, but they're similar for a reason :)
05:15:54 <Peaker> so Prelude hGetContents truncates at chunk boundary upon closed file (which is horrible! You get "valid" seeming content which is wrong!).  And ByteString.hGetContents which raises an error (better, at least you know there's a bug)
05:16:06 <skypers__> damnit, network is unstable
05:16:19 <Peaker> so lazy I/O primitives are even inconsistent between Prelude/ByteString :(
05:16:19 <quchen> https://github.com/quchen/articles/blob/master/crazy_io.md  -- Peaker
05:16:27 <quchen> Hm I should add some credit to that
05:16:32 <skypers__> I’ll join back later, I’m at work, plus.
05:16:36 <Cale> skypers__: Did you get that book that I linked earlier?
05:16:38 <skypers__> thank you for your time Cale
05:16:43 <skypers__> yes
05:16:45 <skypers__> :)
05:16:51 <Cale> cool, it has all this stuff near the beginning
05:16:58 <Cale> In case you'd like to go over that
05:17:02 <skypers__> sure
05:17:03 <Peaker> quchen: s/partial/truncated
05:17:13 <kqr> Cale, okay. i've seen all kinds of variations with =, ==, === and ≡, likely for the reason you mention, so that's why i got curious
05:17:15 <quchen> True, that's better
05:17:18 <skypers__> I like math, and I’d love to understand all that weird things ;5
05:17:19 <skypers__> ;)*
05:17:39 <skypers__> gotta go, work is waiting for me ( :( )
05:17:41 <skypers__> bye!
05:17:42 <Peaker> quchen: Also add the Data.ByteString.Lazy one for the third, which raises an error instead (inconsistent with Prelude!)
05:17:43 <Cale> skypers__: Another really good resource is the YouTube channel called TheCatsters
05:17:48 * hackagebot texts 0.3.0 - User-facing operations for dealing with texts  http://hackage.haskell.org/package/texts-0.3.0 (ChrisDone)
05:17:50 <Cale> okay bye!
05:18:00 <skypers__> I’ll look forward to it then!
05:18:17 <quchen> Peaker: What's the exception?
05:19:36 <Peaker> *** Exception: /tmp/foo: hGetBufSome: illegal operation (handle is closed)
05:20:05 <quchen> Peaker: Can I write "partial" now? :-P
05:20:11 <Peaker> heh :)
05:20:30 <Peaker> though maybe ghc base deserves a bug report for that, as the bytestring version is more sensible and consistency here is important
05:20:34 <Peaker> (even if lazy I/O is used)
05:21:10 <quchen> Right, reading from a closed handle should be an exception and not something silent.
05:21:33 <Philonous> Peaker, Ah, the point is to demonstrate that lezy IO is evil. I was just about to say that you have to abandon all hope once you let lazy IO in your program anyway
05:21:52 <quchen> https://github.com/quchen/articles/blob/master/crazy_io.md
05:22:02 <quchen> I'm glad Git doesn't have a maximum on the --amend you can use.
05:22:29 <Peaker> Philonous: Lazy I/O has some defenders: http://www.reddit.com/r/haskell/comments/1o6iqs/why_i_dont_like_the_lens_library/ccpmvzh
05:22:29 <chrisdone> donri: http://ircbrowse.net/browse/haskell?q=Cale
05:23:04 <Cale> chrisdone: ?
05:24:25 <Peaker> Haskell is a lot about safety, and lazy I/O easily makes things subtly wrong. It's weird that lazy I/O has so much support
05:25:12 <quchen> I recently rewrote half my program because I had some bug with lazy IO.
05:25:20 <quchen> I still don't know what the bug was. But it's gone now.
05:25:29 <quchen> Or hidden better.
05:26:09 <Philonous> Peaker, I'm surprised, too. Once you enter the realm where strict IO gets you into trouble (RAM) you certainly want to have more control over how IO actions are performed, not less.
05:26:22 <quchen> Peaker: Lazy IO is a very compelling and beautiful idea if you ask me. It just doesn't work.
05:26:32 <mrsmarple> How difficult is it to master haskell?
05:26:35 <chrisdone> Cale: donri said “you should log cale on ircbrowse” — it already does =)
05:26:49 <chrisdone> mrsmarple: on a scale of one to potato?
05:26:50 <Cale> ah
05:26:58 <quchen> chrisdone++
05:27:20 <mrsmarple> chrisdone: on a scale of kitchen sink to hot spring
05:27:52 <kqr> mrsmarple, the experience is a transition from the kitchen sink to the hot spring
05:28:27 <Peaker> another problem (with lazy I/O?) is that whenever I'm tempted to use it, and get the inevitable subtle bugs, it makes me so angry that I go rant about it in #haskell instead of being productive! :)
05:28:28 <donri> chrisdone: no that's searching for cale in logged channels. log Cale!
05:28:50 <quchen> Peaker: Now that's what I call an unexpected side-effect
05:28:51 <mrsmarple> kqr: how would one describe the level of difficulty on this transitory quest?
05:29:01 <chrisdone> donri: you mean even his PMs? i'll have to talk to the US government for a feed
05:29:15 <donri> Cale the concept, Cale the ideal!
05:29:22 <kqr> mrsmarple, it starts bathroom tubby, turns kitchen sinky and then it's hot springs all the way
05:29:23 <Philonous> Peaker, So the problem isn't lazy IO but lazy programmers?
05:29:38 <chrisdone> they always said caleskell, but i always liked hascale
05:29:39 <Peaker> Philonous: :)
05:29:49 <mrsmarple> kqr: to put it less succinctly, what is the longest shortest time it would take to have a masterfully mastery of said language. Savvy?
05:31:06 <Philonous> mrsmarple, You question is fundamentally unanswerable. but I think the saying goes that you need at least ten thousand hours to master any art?
05:31:13 <kqr> mrsmarple, masterfully mastery – lots and lots of years (and possibly some mathematics thrown in); comfortable mastery – like any other language, maybe half a year?
05:31:29 <kqr> mrsmarple, do you know any other programming language?
05:31:55 <Philonous> kqr, Would that increase or decrease the amount of time needed to learn haskell? There are arguments for both.
05:32:15 <mrsmarple> kqr: php (sacrilege!), python, javascript, and a bit of C
05:32:16 * chrisdone is still a haskell newbie after 5 years
05:32:30 <quchen> I went from zero to Haskell-is-my-main-language in roughly six months of occasionally fiddling around with Haskell. In other words, it's like everything else.
05:32:38 <quchen> chrisdone: Stop being so humble you titan!
05:32:41 <quchen> :-P
05:32:50 * hackagebot formatting 3.0.1 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-3.0.1 (ChrisDone)
05:32:51 <Philonous> chrisdone, Now now, are we fishing for compliments?
05:32:59 <sie> ha
05:33:49 <kqr> mrsmarple, haskell will take no longer or shorter than any of those
05:34:12 <mauke> javascript and C may help with some aspects of haskell
05:34:25 <mauke> (C with static types, javascript with IO)
05:34:46 <quchen> Don't mix that up though or you'll enter a world of pain ^
05:35:49 <kqr> mrsmarple, haskell is different from all of them (thus giving it a steeper learning curve for you than, say, java) but no more difficult
05:38:03 <Lethalman> mrsmarple, it's surely funnier :)
05:39:24 <kqr> and once you get past the initial humps, much more forgiving. the compiler will in many cases tell you about errors you wouldn't even realise you were doing in other languages, until suddenly days later your program blows up
05:39:34 <mrsmarple> How can I get to the point (not necessarily in haskell but in all languages) where I can easily see how i would go about a problem? i.e. I can create innovative programs. At the moment, despite having relatively good grasps of the languages I do know (at least on the language level), I don't have that creative drive where I can start with an idea and almost straight away see a (admittedly general) approach to solving that issue
05:39:52 <kqr> mrsmarple, start small and go bigger little by little
05:40:01 <mauke> solve 10000 problems
05:40:17 <chrisdone> it's hard to speak from personal experience because the haskell ecosystem is always improving
05:40:45 <kqr> mrsmarple, also the general solution is often difficult to figure out at first. start specific and move to general as you realise you are doing the same thing in a bunch of places
05:40:54 <chrisdone> so while it may have took n months or a year for me to be able to do X, these days the same things might be laid out for you and ready to use off the shelf
05:41:12 <quchen> chrisdone: Speaking of which, what would you say is still missed? Lens and pipes/conduit solve two of the big problems of the language.
05:41:22 <quchen> A good debugger would be nice to have.
05:42:02 <donri> sensible stack traces :p
05:43:02 <mrsmarple> how long did it take you guys to get from where I am to over level 9000? (i.e. good understanding of language fundamentals, but not yet that creative)
05:43:23 <madariaga> Cale: I've been reading what you told skypers__, could you please link that book again? I think I wasn't here when you did
05:43:31 <kartoffelbrei> quchen: A way to abstract over patterns (as in pattern matching) in a sensible manner, but i don't mean view patterns.
05:43:58 <Cale> madariaga: see PM :)
05:44:14 <k00mi> kartoffelbrei: pattern synonyms
05:44:26 <k00mi> kartoffelbrei: http://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
05:44:32 <donri> chrisdone: format (prec 1) 123 => "1e2" is that right?
05:44:32 <quchen> mrsmarple: It took us precisely "pick up a book and see where it gets you" amount of time.
05:44:46 <kqr> mrsmarple, roughly six months from beginning to being comfortable with haskell
05:45:26 <mrsmarple> ok. i guess it'
05:45:38 <kqr> mrsmarple, but as you probably understand, it doesn't end there. i learn something big every month that completely changes the way i think about my code
05:46:28 <chrisdone> donri: i'm not sure. you specified only one digit of precision, which might confuse bos's Data.Text.Format.prec
05:46:32 <mrsmarple> I guess it's just a lot of work, like anything else
05:46:41 <Cale> mrsmarple: I think for me, it was perhaps 2 months to the point where I felt I was able to do something useful, and maybe about a year to really be comfortable. I've been programming in Haskell for about 12 years now.
05:46:41 <kqr> you got it!
05:47:03 <donri> chrisdone: :) i've been looking for a package that can do thousands grouping, can yours?
05:47:17 <Cale> (and there are still things to learn!)
05:47:27 <chrisdone> donri: perhaps it's misleading -- 5 digits means "123.00" is 5 digits
05:47:37 <kqr> mrsmarple, recall how it was learning programming when you first started out. it's like that with haskell as well
05:47:46 <kqr> mrsmarple, (even if you know python, because haskell is so different)
05:47:59 <Cale> Obviously not in the basic language definition, but there's a neverending stream of new libraries and concepts and every so often new language extensions.
05:48:12 <kartoffelbrei> k00mi: thanks. sadly this won't make it into 7.8.
05:48:22 <chrisdone> donri: no, but i wanted that the other day, i have a function for it somewhere. it's an appropriate function to add
05:49:01 <chrisdone> quchen: johnw, edward and snoyberg are working on a unified, final solution to error handling
05:49:05 <kqr> Cale, out of curiosity, what was the community like back when you started? the same but smaller?
05:49:20 <mrsmarple> yeah true. man there's so much I need to LEARN!!!!. well thanks for all the advice, I'm off to conquer haskell (or at least start to). Peace!
05:50:12 <Cale> kqr: A lot smaller
05:50:14 <quchen> chrisdone: Was that a joke?
05:50:17 <Cale> I think when I first came to #haskell, it had ~60 people in it?
05:50:23 <chrisdone> quchen: nope
05:50:32 <quchen> chrisdone: Oh. Well then that's very nice.
05:50:46 <quchen> chrisdone: By "error handling" you mean exceptions?
05:51:13 <chrisdone> quchen: both -- errors as in things that are expected errors (Either-ish) and exceptions -- things that rarely happen
05:51:26 <Cale> One thing which I'd say was better than now was our wiki community was stronger. Replacing moinmoin with mediawiki makes everyone implicitly treat the thing like Wikipedia.
05:51:34 <quchen> chrisdone: Those are unifiable? I wouldn't have expected that.
05:51:59 <Cale> There used to be lots of conversation there which I don't really see much of now.
05:52:04 <chrisdone> quchen: quchen: i missed their hangout meeting, but from what i heard it sounds positive. e.g. i'm particularly interesting in being able to specify "my function throws X exception" and have that be in the type
05:52:14 <alllex220> Cale: can u give me the link pls of the wiki?
05:52:20 <Cale> alllex220: haskell.org
05:52:29 <quchen> chrisdone: But it's undocumented/private right now?
05:52:47 <alllex220> :D ok yo umean this wiki
05:52:57 <chrisdone> quchen: i think so, still in design phase
05:53:18 <quchen> With edwardk schedule we can expect the first release by tomorrow afternoon then
05:53:31 <Cale> alllex220: Yeah, it used to have a better section for people to ask questions and get answers and stuff. Now it's kind of annoying to get an account to be able to edit.
05:53:40 <chrisdone> quchen: also the classic problem of exceptions between different layers of monads
05:53:45 <chrisdone> =)
05:53:46 <edwardk> quchen: not likely. i'm traveling until the 20th
05:54:07 <donri> chrisdone: will that type be purely documentation or checked?
05:54:08 <chrisdone> edwardk: is there a repo with experiments on what you guys were discussing?
05:54:12 <donri> if checked, isn't that just Either
05:54:23 <edwardk> chrisdone: we've mad some headway on it, but its mostly still in note form not code yet
05:54:34 <chrisdone> nod
05:54:36 <edwardk> i basically punted working on it until i get back at the end of the month
05:54:44 <edwardk> snoyman may make some headway in the meantime
05:54:53 <Cale> kqr: But one thing which has stayed is the helpfulness to beginners :)
05:54:53 <quchen> edwardk: Can you sum up the basic idea already?
05:55:04 <quchen> Or is it still very fuzzy
05:55:24 <kqr> Cale, yeah that's what i was thinking about particular. it's wonderful
05:55:29 <kqr> +in
05:55:30 <donri> or are those notes public somewhere?
05:56:04 <augur> edwardk: could i con you into reading something for me?
05:56:07 <alllex220> cale: how long do u programming in hskl?
05:56:09 <edwardk> split MonadThrow from MonadCatch, currently it has a type parameter for the top exception type, usually 'e'. a couple of combinators that can take a fold or an Exception to pick the target in the larger exception type for throw/catch to match C.E. and C.E.Lens, explicit onException so we can gracefully deal with side-exits in monads like EitherT
05:56:15 <Cale> alllex220: 12 years
05:56:34 <mauke> "hskl"
05:56:38 <edwardk> augur: i've got about 10 minutes left before my day goes chaotic, tops, so probably not the best time
05:56:41 <alllex220> cale: u prefer definetely hskl?
05:57:14 <Cale> alllex220: It's by a fairly large margin my preferred language for anything practical.
05:57:15 <mauke> I prefer hjkl
05:57:29 <tomejaguar> I prefer htns
05:57:31 <danr> htns
05:57:32 <danr> it is
05:57:33 <donri> hnei please
05:57:42 <augur> edwardk: doesnt have to be right away
05:57:45 <kqr> i prefer hnei though
05:57:59 <edwardk> Now I want to write a more terse language named hskl, which is just like haskell with all the keywords disemvoweled.
05:58:10 <donri> isn't that just lens
05:58:12 <mauke> mn = rtrn ()
05:58:13 <donri> lns
05:58:13 <danr> :p
05:58:15 <edwardk> donri: yes =)
05:58:53 <kqr> and every string is run through an implicit filter (not . vowel)
05:59:03 <donri> mn :: npttpt ()
05:59:15 <chrisdone> edwardk: should it be possible (plans for?) to have a lifted-base with something like: hGetChar :: (MonadIO m,Throws EOF m) => Handle -> m Char?
05:59:15 <tomejaguar> f vowels thn id ls ("un"++) $ "readable"
05:59:34 <alllex220> cale: ah k last year i started with haskell and i dont think im good in it
05:59:41 <Cale> alllex220: There are languages which have better type systems than Haskell does, but there's nothing which has quite as powerful a type system and which is as realistically usable for real programs.
06:00:00 <mauke> chrisdone: I hope hGetChar can throw more than EOF
06:00:36 <madariaga> Cale: what makes for a "better" type system?
06:00:36 <alllex220> cale: other languages are easier but haskell is very cool and elegant for many problems
06:00:40 <edwardk> chrisdone: basically what can happen is using classes like the AsArithException classes from C.E.Lens you could write that. note that hGetChar actually can throw a whole arsenal of exceptions though, not just that one. this is a fairly standard posix problem. almost any posix api can throw just about anything
06:00:41 <chrisdone> mauke: that's the only documented one
06:00:50 <donri> hGetChar :: Either (forall a. a) Handle -> Either (forall a. a) Char
06:01:03 <mauke> chrisdone: I didn't know it documented any
06:01:14 <chrisdone> mauke: http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#v:hGetChar
06:01:22 <Cale> madariaga: Well, I'm thinking specifically about languages like Coq and Agda and Idris with dependent types.
06:01:35 <mauke> that's dumb
06:01:43 <Taslem> Are there Haskell libraries for dealing nicely/efficiently with continuous probability distributions?
06:01:50 * madariaga googles
06:01:50 <donri> hGetChar :: Either (forall a. .) (Either (forall a. a) Handle -> Either (forall a. a) Char)
06:01:57 <donri> bottoms. bottoms everywhere
06:02:03 <mauke> it needs to at least handle EIO and EISDIR
06:02:08 <mauke> possibly EINVAL too
06:03:16 <chrisdone> sure, but i don't know the others off by heart
06:03:29 <Cale> madariaga: In Haskell, we have types which depend on other types, like Maybe. In these languages, you can have types which depend on values. The usual "Hello, World" kind of example of it is lists whose length is specified in their type.
06:04:04 <madariaga> Cale: I see
06:04:29 <Cale> (Of course, we're starting to be able to do this in GHC Haskell as well, but it's still pretty clunky here, whereas the dependently-typed languages I mentioned are designed around the ability to do that)
06:04:44 <merijn> madariaga: These languages allow you to specify types of functions like "non-empty input list"
06:05:35 <Cale> This ability makes the type system powerful enough to actually express a significant amount of mathematics. The whole idea that types are like propositions, and programs are like proofs becomes really important :)
06:05:45 <donri> > fst (1,(2,(3,4)))
06:05:46 <lambdabot>   1
06:05:50 <donri> > fst ()
06:05:51 <lambdabot>   Couldn't match expected type `(a0, b0)' with actual type `()'
06:05:55 <donri> ;)
06:06:21 <madariaga> the jump from programming language to proof assistant is quite beyond me
06:06:33 <chrisdone> edwardk: sure, but that's the case with all IO functions. out of memory, killthread from another thread, etc. at some point presumably you have to define some subset for this function. perhaps that subset is small, and if it's a dozen, could be in a constraint?
06:06:47 <edwardk> yes
06:07:17 <edwardk> hGetChar :: (AsFoo e, AsBar e, AsBaz e, MonadThrow e m) => m Char
06:07:29 <Cale> madariaga: It's less of a leap than you might think, once you have a pretty solid grasp on Haskell.
06:07:38 <chrisdone> edwardk: i like that AsFoo stuff =)
06:07:49 <Cale> madariaga: I only recently discovered that I basically already knew how to program in Coq :)
06:07:50 <Philonous> madariaga, If you're interested, I recommend http://www.cis.upenn.edu/~bcpierce/sf/
06:08:03 <edwardk> chrisdone: its how i solve the 'multple states in a transformer stack' problem as well.
06:08:12 <edwardk> (HasFoo s, HasBar s, MonadState s m) => ....
06:08:21 <chrisdone> edwardk: cool! hmmm =)
06:08:25 <madariaga> Philonous: let's see, thanks
06:08:28 <chrisdone> that problem always bugged me
06:08:35 <Cale> (well, at the same time, I don't really feel like I know what I'm doing, but I can mash my keyboard, and Coq will eventually accept my proofs! :)
06:08:44 <edwardk> i've been meaning to write a 'bro, do you even lift?' article about it
06:09:05 <merijn> Cale: I know Coq, you just type a problem and then alternate "auto" and random gibberish, right? :)
06:09:13 <Cale> haha
06:09:36 <madariaga> Cale: it's nice to know that, whatever it is that a program does, it's at least correct
06:09:52 <chrisdone> edwardk: i'd like to read that. i really like my functions being generic like that, only specifying what they use instead of a concrete type. but due to that very issue it always seemed impractical
06:10:28 <edwardk> i almost never pick a concrete monad transformer until the actual use site. makes it much easier to do mocking and testing of individual units of functionality
06:10:50 <merijn> madariaga: Do you understand the general notion of encoding properties ("proofs") in types of haskell programs? Like how you know for sure (ignoring undefined/bottom) that "id :: a -> a" can never do anything with the 'a'?
06:12:01 <madariaga> merijn: not really
06:12:07 <chrisdone> edwardk: yeah, especially if you have some IO in there, which you can abstract out and provide a StateT instance instead for doing testing
06:12:10 <merijn> madariaga: In haskell all your properties are restricted to being types (since types only contain types, "obviously"), in dependently typed languages type can also refer to values, which means your properties can suddenly include proofs about *values* too, making the type of property more expressive
06:12:39 <merijn> madariaga: Well, think about this, how many different (correctly typed) way are there to implement the type "(a -> b) -> [a] -> [b]"?
06:12:53 <madariaga> only one, map
06:12:58 <mauke> merijn: infinitely many
06:13:00 <merijn> (ignoring any undefined business)
06:13:15 <mauke> at least as many as there are integers
06:13:22 <merijn> mauke: Yeah, but fortunately only a few classes
06:13:24 <Philonous> madariaga, You can meddle with the list itself
06:13:36 <madariaga> right, I see
06:13:37 <merijn> madariaga: Unfortunately not, it could just always return empty list, for example
06:13:42 <merijn> madariaga: Or any random sublist
06:14:01 <merijn> madariaga: But even so, it rules out a lot of things it *can't* be
06:14:29 <merijn> madariaga: Dependent types would actually let you prove (in the type) that every element in the first list has a corresponding element in the result
06:14:59 <chrisdone> edwardk: my irc server now handles all client input in a pure RWS monad, with IO side-effects coming out as instructions from the writer. but it means some business logic is separated out into some interpreter which does the writer's instructions. it might be nice instead to allow the io inside the monad, but only for production, and testing i can run it as a pure monad that pretends to do IO with State. i'm not sure which i like better
06:15:00 <merijn> madariaga: In which case, there would really be only one possible implementation
06:15:31 <donri> chrisdone: needs moar free monads
06:15:34 <madariaga> merijn: it's a much narrow specification of the outcome
06:15:34 <merijn> madariaga: The downside is, dependent types make type inference (in general) impossible (you can still infer some specific subsets, but not the entire language)
06:15:37 <tiffany> even if you don't write a proof about it, having a and b be vects of length x would knock out many things it can't be
06:15:59 <merijn> madariaga: The other downside is, we haven't really figured out how to make specifying dependent types painfree
06:16:29 <merijn> madariaga: Lots of people are working on these thigns and lots of cool stuff is happening, but it's far from solved
06:16:52 <SaBer> talking about pain, do C++ templates qualify as dependent types?
06:16:58 <madariaga> merijn: it does seem interesting
06:17:12 <merijn> SaBer: In a limited form, yes
06:17:37 <bezirg> does anybody know if Control.Concurrent.forkOn :: Int -> IO () -> IO ThreadId  starts indexing the processor from 0 or 1? I guess by 0, right?
06:17:39 <merijn> SaBer: I don't think they're fully dependent, but you can have types depending on values in C++ templates making them at least partially dependent
06:18:01 <tiffany> I don't think you can implement dependant tuples in C++
06:18:09 <mauke> pfft, in C++ you can have syntax depending on values
06:18:18 <mauke> types are child's play
06:18:26 <chrisdone> donri: this is all pure https://github.com/chrisdone/hulk/blob/master/src/Hulk/Client.hs
06:19:14 <tiffany> being able to pass types as parameters to templates is to dependant typing as simple generics are to higher kinded polymorphism, I would imagine
06:19:20 <tiffany> er, values as parameters
06:19:36 <chrisdone> donri: monad is here https://github.com/chrisdone/hulk/blob/master/src/Hulk/Types.hs#L160
06:20:23 <donri> chrisdone: yeah but, free monads right? FREE MONADS!
06:20:32 <chrisdone> donri: what about them?
06:20:55 <donri> they're all the rage, don't you know
06:21:45 <chrisdone> free monads are so 2012
06:22:07 <quchen> chrisdone: 2012 is comonads.
06:22:25 <augustss> We want monads in chains!
06:22:26 <chrisdone> dude, 2011 was comonads
06:22:32 <chrisdone> at camhac everyone was going on about comonads
06:22:37 <quchen> So what was 2012 then
06:22:47 <Philonous> Free comonads
06:22:48 <edwardk> chrisdone: my victory is now complete ;)
06:22:57 <edwardk> Philonous: sadly they are only cofree
06:23:05 <ibid> TANSTAAFF
06:23:08 <chrisdone> edwardk: which victory? =p
06:23:08 <ibid> argh
06:23:09 <Philonous> Cofair enough
06:23:10 <ibid> TANSTAAFM
06:23:26 <chrisdone> 2013 is lens
06:23:31 <chrisdone> what's 2014 gonna be?
06:23:40 <MercurialAlchemi> free lenses
06:23:42 <lieven_> n-categories
06:23:43 <augustss> The year on the kmett.
06:23:48 <edwardk> chrisdone: my quest to get comonads instilled into the haskell community's collective subconscious as something useful and very distinct from monads
06:24:22 <edwardk> augustss: heh, well, at this rate i'll finally get a chance to stop traveling to give talks some time around 2014. i wish i wasn't serious.
06:24:24 <augustss> mmunity llective nscious
06:24:28 <donri> augustss: you mean co-mett
06:24:35 <chrisdone> augustss: hahaha
06:24:37 <Philonous> chrisdone, Anyway, RWS is ancient
06:24:46 <chrisdone> Philonous: huh?
06:25:02 <edwardk> but its all good. its forcing me to finish up slides for a bunch of different topics
06:25:55 <Philonous> chrisdone, Well, if free monads is last years flavor, what is RWS then?
06:26:13 <edwardk> automatic differentiation, wavelet trees, ermine, this procrustean mathematics / design by universal properties thing, deamortizing algorithms in ST and using Overmars and van Leeuwen's construction to help remove the asymptotic slowdown of switching to a functional algorithm for most cases, etc.
06:27:15 <chrisdone> Philonous: i wasn't espousing RWS as being anything new =p i was just showing how the command handling code in my IRC server is a pure function =)
06:27:19 <mauke> http://2.bp.blogspot.com/-JJ2_FaNL9AA/UeelzWC3w3I/AAAAAAAAB34/1CCDQK3rOF8/s1600/tumblr_mn3wynbnhn1rqg34ro1_500.gif
06:28:08 <augustss> edwardk: do you have a wavelet tree hack age package?
06:28:30 <edwardk> i am trying to finish up the code i have into a hackageable form soon
06:28:34 <chrisdone> mauke: and i say, ‘HEEEEYEEEYEEAAAHE!’ what's goin' on!
06:28:50 <edwardk> in particular 'm trying to switch from rank9 to poppy/cs-poppy for the baseline backend
06:29:17 <edwardk> and see if i can bring myself to support RM or RRR as alternate succinct indexed dictionaries to build it atop
06:29:54 <edwardk> augustss: gthub.com/analytics has a class for rank/select dictionaries that the wavelet tree code i have can fit into
06:30:05 <edwardk> er github.com/analytics
06:31:09 <simpson> @tell startling GreenArray chips? No, I never ordered one; I couldn't justify the expense when I was interested and I'm too busy these days. I still like the concept, but I'm not sure that I have the time to do anything cool with one.
06:31:09 <lambdabot> Consider it noted.
06:31:51 <bezirg> is there a Bag datastructure? Or should I emulate it with IntMap [a]
06:32:00 <edwardk> greenarray chips are ridiculous to program for
06:32:34 <danharaj> ridiculously difficult or ridiculously delightful?
06:32:58 * hackagebot texts 0.3.1 - User-facing operations for dealing with texts  http://hackage.haskell.org/package/texts-0.3.1 (ChrisDone)
06:33:31 <chrisdone> hey twey
06:38:13 <chrisdone> huh. there's no cycle function for Data.Text.Lazy
06:39:57 <Iceland_jack> Hm, there is one for Data.ByteString.Lazy
06:42:10 <lpaste> chrisdone pasted “commas (donri)” at http://lpaste.net/95194
06:42:20 <chrisdone> donri: found it!
06:48:01 * hackagebot formatting 3.0.2 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-3.0.2 (ChrisDone)
06:48:34 <chrisdone> donri: ^
06:48:34 <chrisdone> λ> format commas 125334234
06:48:34 <chrisdone> "125,334,234"
06:48:42 <donri> chrisdone: nice
06:50:02 <earthy> schweet.
06:50:28 <Nimatek> @pl f s = readFile s >>= \b -> return $ runGet g b
06:50:28 <lambdabot> f = (runGet g `fmap`) . readFile
06:50:35 <Nimatek> @pl f s = m s >>= \b -> return $ runGet g b
06:50:39 <lambdabot> f = ((return $) . runGet g =<<) . m
06:50:39 <lambdabot> optimization suspended, use @pl-resume to continue.
06:50:44 <Nimatek> Hmm.
06:50:54 <mauke> @pl-resume
06:51:01 <lambdabot> f = ((return $) . runGet g =<<) . m
06:51:01 <lambdabot> optimization suspended, use @pl-resume to continue.
06:51:01 <butterduckcake> !seen http://www.google.com
06:51:09 <butterduckcake> @seen duckie
06:51:10 <lambdabot> dUxxie
06:51:22 <Rylee> @pl-resume
06:51:34 <lambdabot> f = ((return $) . runGet g =<<) . m
06:51:34 <lambdabot> optimization suspended, use @pl-resume to continue.
06:51:54 <butterduckcake> lambdabot: teast
06:52:08 <butterduckcake> @help
06:52:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:52:15 <butterduckcake> @list
06:52:16 <lambdabot> What module?  Try @listmodules for some ideas.
06:52:20 <khyperia> > ((=<<) (=<<) (=<<)) (*) 2
06:52:21 <lambdabot>   8
06:52:24 <butterduckcake> @listmodules
06:52:25 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
06:52:25 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
06:52:46 <khyperia> butterduckcake, you might want to do this in /msg so you don't spam up the chatroom
06:53:01 * hackagebot intset 0.1.0.2 - Pure, mergeable, succinct Int sets.  http://hackage.haskell.org/package/intset-0.1.0.2 (SamTruzjan)
06:53:11 <skypers_> :t runEitherT
06:53:13 <lambdabot>     Not in scope: `runEitherT'
06:53:13 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
06:53:18 <skypers_> damn
06:53:26 <chrisdone> donri: in italian they use periods instead of commas and then a comma for the decimal place
06:53:49 <skypers_> hey, in order to lift readFile in EitherT
06:54:24 <skypers_> lift . try $ readFile "test.txt"
06:54:38 <skypers_> I think it’s correct
06:57:02 <donri> chrisdone: yeah i think printf() is locale-aware
06:58:02 * hackagebot intset 0.1.0.3 - Pure, mergeable, succinct Int sets.  http://hackage.haskell.org/package/intset-0.1.0.3 (SamTruzjan)
07:02:54 <skypers_> is there another way to make a EitherT from an Either without using EitherT?
07:03:06 <chrisdone> donri: yeah i'm tempted to move this to Texts.English
07:08:22 <chrisdone> donri: the i18n package on hackage seems a bit out of date
07:09:01 <chrisdone> s/a bit//
07:13:04 * hackagebot HList 0.3.0 - Heterogeneous lists  http://hackage.haskell.org/package/HList-0.3.0 (AdamVogt)
07:13:06 <chrisdone> donri: would be nice to bring it up to date and spruce up the docs a bit
07:13:13 * chrisdone adds to TODO.org
07:20:15 <bergmark> i hate the comma decimal thing :(
07:24:27 <chrisdone> bergmark: yeah? =)
07:25:46 <Kaidelong> does cabal have something equivalent to mingw32-make's SHELL parameter?
07:26:19 <mauke> does cabal use the shell?
07:27:19 <Matthias|PC> If I have "data blah = X Float | Y String", is it possible to pass the X/Y part to a function to do something with it?
07:27:19 <chrisdone> wouldn't've thought so
07:28:03 <Feuerbach> bergmark: I didn't know it's also used in Sweden. We suffer from it too.
07:28:30 <Feuerbach> It's a long list of countries, apparently: https://en.wikipedia.org/wiki/Decimal_mark#Countries_using_Arabic_numerals_with_decimal_comma
07:28:35 <mauke> Matthias|PC: yes
07:28:46 <Matthias|PC> mauke: could you tell me how please?
07:28:53 <mauke> Matthias|PC: f X
07:28:54 <Matthias|PC> I've tried googling but can't seem to find anything
07:28:59 <geekosaur> "yes" bit it may not do what you intend
07:29:08 <geekosaur> could you expand on what you are actually trying to do?
07:29:18 <cfoch> geekosaur: Finally I could install wxHaskell!
07:29:51 <geekosaur> (X and Y behave like functions, and as such can be passed around as functions. what you can't do is somehow "extract" the constructor from a value, except by pattern matching each one eplicitly --- unless you go the route of generics etc.)
07:29:58 <kartoffelbrei> Matthias|PC: I'm not sure i understand your question, but if you are asking if you can pass the constructor X to a function then yes. Constructors are like functions after all X :: Float -> Blah.
07:30:26 <Matthias|PC> hm yeah
07:30:28 <Matthias|PC> I'll play with it
07:30:29 <Matthias|PC> thanks guys :)
07:30:51 <chrisdone> Feuerbach: seems much worse than i feared
07:34:38 <Matthias|PC> kartoffelbrei: basically I need to construct an object of type "blah" inside a function (blah has constructors X String | Y Float or so)
07:34:43 <Matthias|PC> otherwise I'll have a lot of duplicate code
07:34:56 <Matthias|PC> I know the type of data constructor of blah is a -> blah
07:35:06 <Matthias|PC> but I'm not sure how to construct a new object from it
07:35:37 <mauke> X "hi"
07:35:45 <mauke> (\c -> c "hi") X
07:35:59 <kartoffelbrei> Matthias|PC: Just use the passed constructor like you'd use a passed function
07:36:12 <kartoffelbrei> just like mauke did right now
07:36:20 <mauke> hex, hex
07:37:41 <Matthias|PC> http://pastebin.com/505du4iA
07:37:43 <Matthias|PC> something like that?
07:37:48 <Matthias|PC> because that doesn't seem to work :p
07:37:50 <mauke> The paste 505du4iA has been copied to http://lpaste.net/95195
07:38:07 <Matthias|PC> "The function `constructor' is applied to two arguments, but its type `a -> Expression' has only one
07:38:10 <Matthias|PC> then I tried with ()
07:38:11 <chrisdone> mauke: oleg bless your bot
07:38:16 <Matthias|PC> but then I get the same error for e
07:38:45 <mauke> Matthias|PC: your type signature is wrong
07:38:57 <Matthias|PC> the (a -> Expression) part?
07:39:05 <mauke> yes
07:39:30 <Matthias|PC> I went off of "Lit :: Float -> Expression" being the type of Lit, but I'm not sure what else to put there then :p
07:40:23 <mauke> you're not replacing Lit by constructor
07:40:55 <Matthias|PC> wel no but
07:40:56 <Matthias|PC> hold on :p
07:41:23 <Matthias|PC> http://lpaste.net/8323522447848505344
07:41:42 <Matthias|PC> basically I need to be able to pass on Add/Sub/...
07:41:56 <Matthias|PC> the Lit thing is just a test for now
07:42:54 <mauke> you're replacing Pow
07:42:59 <mauke> Pow doesn't have the same type as Lit
07:43:06 <kartoffelbrei> if you want to replace Pow with an arbitary binary constructor like Add Mul etc. then the (a -> Expression) has to be a (Expression -> Expression -> Expression). your parameter constructor has to be of the latter type.
07:43:18 <Matthias|PC> ah I see
07:43:44 <Matthias|PC> kartoffelbrei: that works, thank you!
07:44:01 <Matthias|PC> and that's actually pretty logical haha :p
07:56:41 <brainsturgeon> what do you folks like to use for editing haskell? I've been using plain old vim, but I find myself missing some features.
07:56:49 <`^_^v> like what
07:56:57 <dv-> emacs with ghc-mod
07:57:09 <brainsturgeon> e.g. jump to def, syntax checking
07:57:18 <cschneid> brainsturgeon: vim + hdeftools + syntastic
07:57:26 <cschneid> hdevtools, sorry
07:57:42 <brainsturgeon> cschneid, first i've heard of syntastic. i'll check it out.
07:57:45 <cschneid> I imagine ctags would do jump to def? Haven't tried though
07:58:01 <cschneid> brainsturgeon: syntastic is a generic syntax checker for lots of languages. Wires into haskell as one of the supported languages
07:58:19 <cschneid> brainsturgeon: I did have to use ghc-mod for it for some reason I don't remember: let g:syntastic_haskell_checker='ghc-mod' in your vimrc to tell it that
08:00:19 <brainsturgeon> cschneid, thanks! I'll see if I can get that working.
08:00:38 <cschneid> brainsturgeon: I also say this for hdevtools: let g:hdevtools_options = '-g-isrc -g-Wall'
08:01:00 <chrisdone> who decided in haddock's syntax coloring that red would be an appropriate color for parentheses
08:01:03 <cschneid> brainsturgeon: in fact, here's the whole section of customizations: https://gist.github.com/cschneid/b36168c3b60c70cfb122
08:02:51 <brainsturgeon> thanks, that'll probably save me loads of time. what does hdevtoolsclear do?
08:04:04 <cschneid> brainsturgeon: ht is "haskell type" - which shows in the bottom status line. hc is clear that type - equivalent in thought to :nohl once you're done w/ highlighted search
08:04:12 <cfoch> Hello. How con I change the color of a button in wxHaskell (set it to Blue for example)? I've tried using bgcolor := blue but it won't work
08:07:04 <oio_> Whats the difference module Main (main) where ?
08:07:16 <geekosaur> not sure what you're asking
08:07:18 <srhb> oio_: Between that and...?
08:07:19 <geekosaur> difference from what?
08:07:23 <srhb> geekosaur: Do you never sleep?
08:07:25 <srhb> >_>
08:07:46 <oio_> module Main where
08:07:47 <geekosaur> I slept. not enough though; I was up last night rather later than intended
08:08:17 <cfoch> srhb: lol "geekosaur: Do you never sleep?" lol he's a bot maybe
08:08:22 <geekosaur> oio_: the former exports *only* the name "main" for other modules to see (that name *must* be exported; the "module" that needs to see it is the haskell runtime)
08:10:40 <srhb> geekosaur: Do you have any idea why I can't pass my master Fd to a function that is forkIO'd?
08:10:51 <brainsturgeon> cschneid, seems to work! i'll have to experiment a bit.
08:11:28 <cschneid> brainsturgeon: cool. I don't do enough larger projects to need stuff like jump-to-def features. But it'd be cool if you reported back w/ how that works... :) (maybe a comment on my gist?)
08:12:24 <brainsturgeon> cschneid: sure, i'll mark it to remind me
08:12:58 <k00mi> for jump-to-def I use hasktags, it works fine
08:16:52 <funky_> exit
08:20:07 <cschneid> k00mi: yeah, that and some other tag programs are listed on http://www.haskell.org/haskellwiki/Tags
08:23:33 <jalopezp1> Hi, I have a question about functors (I think): Imagine you have w=map Just (words "some list of maybe words"). How do I unwords this?
08:24:05 <jalopezp1> I have w::[Maybe String] and unwords::[String]->String. I need some way to get [Maybe String]->Maybe String. It seems like a functor, but it doesn't quite work out.
08:24:26 <Eduard_Munteanu> :t catMaybes -- jalopezp1
08:24:28 <lambdabot> [Maybe a] -> [a]
08:24:49 <Eduard_Munteanu> Or even...
08:24:54 <Eduard_Munteanu> :t sequence
08:24:56 <lambdabot> Monad m => [m a] -> m [a]
08:25:32 <Eduard_Munteanu> jalopezp1: depends on what you expect from that Maybe
08:26:51 <teneen> I'm trying to process a very large text file (6GB+). I want to count the frequency of each word. I use a strict HashMap ByteString to Word16. The application is taking too much time and memory.
08:27:35 <teneen> The file is not loaded into memory. Since I read it lazily
08:27:45 <teneen> however I assume the HashMap is very large.
08:28:02 <teneen> is there a better data structure I can use?
08:29:13 <Eduard_Munteanu> teneen: Text seems more appropriate. Also try a plain strict Map.
08:30:15 <teneen> Eduard_Munteanu: I believe it's mentioned on the unordered-containers page that HashMaps are more efficient than normal Maps
08:31:33 <Eduard_Munteanu> teneen: that probably depends on your keys...
08:32:06 <Eduard_Munteanu> teneen: I think a good structure for this would be a trie, I guess
08:32:27 <teneen> HashMaps are implemented using tries
08:32:55 <teneen> "The implementation is based on hash array mapped tries" from the package's page
08:33:32 <Takumo> Why is it after doing `cabal install cabal-install` , doing `cabal update` tells me to `cabal install cabal-install` ?
08:33:37 <Eduard_Munteanu> teneen: well, it sounds like prefixes are hashes, not your strings
08:33:40 <teneen> the file size is 6GB however the executable is occupying 20GB of RAM ::(
08:34:04 <Eduard_Munteanu> teneen: oh, hm... can you paste your code?
08:34:15 <Eduard_Munteanu> That's quite a bit.
08:34:46 <Eduard_Munteanu> teneen: what sort of words are there in your file?
08:34:48 <jalopezp1> Eduard_Munteanu: thanks! Sequence seems to do it, I hope I'm doing the right thing. What I actually have is a [Rand StdGen Int], was just using Just as an example.
08:34:50 <Entroacceptor> Takumo: cabal update fetches information about packages from hackage. If you did a cabal install with an old version of the package db you installed an old version of the program
08:34:54 <cfoch> Is it possible to set a different color in a button in wxHaskell?
08:35:12 <teneen> Eduard_Munteanu: unicode text
08:35:32 <Eduard_Munteanu> teneen: do words repeat themselves much?
08:35:45 <Takumo> Entroacceptor: So how do I fix this circular issue? why can't the old cabal fetch the updated package list so I can install a new cabal?
08:36:14 <teneen> Eduard_Munteanu: I don't think they are too many
08:36:18 <Entroacceptor> Takumo: oh, that is circular? cabal install cabal-install doesn't get the newest version?
08:36:31 <Entroacceptor> maybe you have them installed in different paths
08:36:43 <darthdeus> how many people are doing haskell for a living? :P
08:36:46 <srhb> It can and it does
08:36:52 <srhb> No circularity there.
08:36:55 <Eduard_Munteanu> teneen: ah, if there aren't many distinct words, sounds like the problem might be elsewhere than the data structure.
08:37:16 <Sculptor> yo
08:37:17 <srhb> darthdeus: Hard to say. Some hundreds maybe?
08:38:32 <darthdeus> srhb: interesting, i still haven't met a single haskell dev in my life
08:38:35 <teneen> Eduard_Munteanu: I'm sure I read the file lazily so it's not kept in memory
08:38:45 <darthdeus> it seems nobody over here knows it exists :\
08:38:53 <teneen> and I also tried reading it line by line and processing each one separately
08:38:55 <srhb> darthdeus: The world is a big place, and Haskell is rather niche.
08:39:18 <Eduard_Munteanu> teneen: I mean more like building huge thunks and not evaluating them
08:39:22 <Entroacceptor> Takumo: what does cabal --version say?
08:39:38 <lpaste> teneen pasted “word frequence for a huge file” at http://lpaste.net/95197
08:41:26 <bz> anyone know of any haskell shops on the east coast?
08:41:56 <bz> east coast :: TimeZone
08:42:55 <oio__> whats the current state of guy development of haskell
08:43:22 <`^_^v> pretty good, but girl development is catching up quick
08:43:32 <teneen> Eduard_Munteanu: do you see any problem in the code?
08:43:34 <oio__> gui
08:44:09 <donri> GIRL Graphical Interface Reactive Library
08:45:24 <Takumo> Entroacceptor: 1.16.0.2
08:45:27 <Eduard_Munteanu> teneen: why are you using both Bytestrings and Text?
08:45:41 <Takumo> intrestingly cabal install cabal-install installs version 1.18.0.2
08:46:13 <teneen> Eduard_Munteanu: because the text is in unicode. To do actual processing without messing up I need to use text.
08:46:45 <Eduard_Munteanu> Oh!
08:47:21 <teneen> I trying using Text alone and I face the same issue
08:47:26 <Eduard_Munteanu> teneen: I think hGetContents from Data.Text.Lazy.IO reads it just fine. I have a hunch you're opening normal Handles and getting a String from them... that's rather inefficient.
08:48:17 <teneen> I believe Handles can be used with all types of containers which support them
08:49:13 <Eduard_Munteanu> teneen: yes, but if you're getting a String from it, and it doesn't fuse away the list, which I don't think it does, it will be slower than using a Text/Bytestring-specific IO function.
08:49:37 <teneen> Eduard_Munteanu: where in the code might I be getting a String?
08:50:11 <Eduard_Munteanu> teneen: well, I think that's not the entire code
08:50:22 <Eduard_Munteanu> teneen: e.g. what's 'txt'?
08:50:56 <teneen> Ok this line wasn't copied :)
08:50:58 <teneen> txt <- B.hGetContents h
08:51:12 <teneen> B is Data.ByteString.Lazy
08:51:34 <Eduard_Munteanu> teneen: is B a lazy bytestring?
08:51:40 <Eduard_Munteanu> Ah.
08:52:27 <Takumo> Eduard_Munteanu: Found the issue, its Archlinux
08:52:33 <teneen> currently the process is occupying 30GB RAM and nothing is written as output yet
08:54:37 <lpaste> teneen pasted “word frequence for a huge file” at http://lpaste.net/95199
08:55:08 <Eduard_Munteanu> teneen: what's that 'pack . show' there doing? pack/unpack can cause issues
08:56:06 <teneen> I'm trying to convert the Word16 in the pair to a Text. I do so by converting it to a String and then to a Text.
08:56:12 <Eduard_Munteanu> teneen: also why convert to a bytestring just to put it in a HashMap? Can't you put Text in?
08:57:03 <teneen> Eduard_Munteanu: It was like this at the beginning and the same problem was there. So I thought maybe storing the values as bytes will be more efficient.
08:57:53 <Gothmog_> @pl f a $ g b c
08:57:53 <lambdabot> f a (g b c)
08:58:27 <Gothmog_> @pl \ a b c -> f a $ g b c
08:58:30 <lambdabot> (. g) . (.) . id . f
08:58:31 <lambdabot> optimization suspended, use @pl-resume to continue.
08:58:31 <Eduard_Munteanu> teneen: I'd also get rid of the foldl' + insert and simply use M.fromListWith
08:58:43 <Gothmog_> @pl-resume
08:58:47 <Eduard_Munteanu> Er, the HashMap one.
08:58:49 <lambdabot> (. g) . (.) . id . f
08:58:49 <lambdabot> optimization suspended, use @pl-resume to continue.
08:59:10 <Gothmog_> @pl \ a b -> f $ g a b
08:59:10 <lambdabot> (f .) . g
08:59:27 <Takumo> Eduard_Munteanu: So if you install Cabal using ArchLinux, you need to cabal install cabal-install && sudo pacman -Rcs cabal-install
08:59:52 <teneen> Eduard_Munteanu: that's a nice suggestion
09:00:10 <stelleg> Takumo: or you just have your cabal path before your /usr/bin path?
09:00:36 <stelleg> thats what I do
09:00:54 <augur> (((s f) . k) . g)
09:01:17 <augur> where s and k are the combinators
09:01:49 <Takumo> stelleg: Or that, but then my $PATH looks messy :P
09:02:04 <stelleg> fair enough
09:02:39 <teneen> Eduard_Munteanu: but I'm not sure if this will make a significant change
09:05:40 <Lindol> I don't really get fold, could someone explain it to me with perhaps an example?
09:05:41 <Eduard_Munteanu> teneen: it might fuse with toList better
09:06:10 <Eduard_Munteanu> Lindol: which fold? Left, right or both?
09:06:15 <teneen> Eduard_Munteanu: What do you think is taking too much memory?
09:06:23 <augur> Lindol: i'll happily explain fold! :D
09:06:26 <augur> Eduard_Munteanu: i got this :D
09:06:35 <FreeFull> @unpl (f .) . (. g)
09:06:36 <lambdabot> (\ e j -> f (e (g j)))
09:06:49 <FreeFull> @unpl (f . . )
09:06:50 <lambdabot> <unknown>.hs: 1: 6:Parse error: .
09:07:00 <Lindol> foldr will do
09:07:11 <bz> any ideas on how i could make this more concise/idiomatic? https://gist.github.com/bryant/7305681
09:07:17 <augur> Lindol: ill do you one better, ill teach you about all folds ever!
09:07:19 <Eduard_Munteanu> teneen: not sure, that pipeline is rather large and intricate though.
09:07:53 <Eduard_Munteanu> All your folds are belong to us. :P
09:08:08 <augur> Lindol: lets start with a nice simple case: pairs. pairs are simple, right? if you want to compute with pairs, any function you want to write on pairs can be defined like so:
09:08:33 <augur> Lindol: pair :: (a,b) -> (a -> b -> c) -> c
09:08:42 <augur> pair (x,y) f = f x y
09:09:13 <augur> Lindol: everythign you want to do with pairs can be done by way of that function. for instance, here's fst:
09:09:34 <augur> fst p = pair p (\x y -> x)
09:10:29 <augur> Lindol: this is kind of like a case analysis for pairs. pairs have one case, so all you need to do is provide some function that can turn the stuff that the (,) wraps up -- the x and y there -- into the result you want
09:10:33 <augur> Lindol: does that make sense?
09:11:00 <Eduard_Munteanu> teneen: it might be an issue with the HashMap though, namely if it holds all prefixes of a word, not only you need much more storage for one word, but it also defeats BS/Text's efficient packing.
09:11:25 <Lindol> augur: Yes, I got it I think
09:11:38 <augur> Lindol: ok, lets consider Either now.
09:11:41 <Eduard_Munteanu> teneen: try replacing that with a strict Map, it seems really easy.
09:12:09 <augur> Lindol: if you have d :: Either a b, and you want to case analyze it, you have to say what to do if it d == Left x, and what to do if its d == Right y
09:12:19 <teneen> Eduard_Munteanu: I'll try it out
09:12:25 <augur> Lindol: so you can define   either :: Either a b -> (a -> c) -> (b -> c) -> c
09:12:34 <augur> either (Left x) f g = f x
09:12:39 <augur> either (Right y) f g = g y
09:13:36 <augur> and again you can do any either-based computation like this. `either' is essentially the case analysis for the Either type, just like `pair' is the case analysis for the (,) type
09:13:41 <Shin-LaC> if I want to try several things in order, and get the first one that succeeds, is it reasonable to use head . mapMaybe?
09:13:51 <augur> Lindol: still making sense?
09:14:08 <glguy> bz: I added some ideas
09:14:12 <Eduard_Munteanu> teneen: I also get a feeling HashMap holds a hash of all prefixes, therefore not being able to share the 'as' in 'a:as'
09:14:13 <Lindol> augur: Yes
09:14:32 <augur> Lindol: ok, so lets try natural numbers. these are a tiny bit different. we'll still do case analysis tho
09:14:50 <augur> if you have n :: Nat, you need to say what to do when n == Zero, and what to do when n == Suc n'
09:15:03 <augur> so:   nat :: Nat -> a -> (Nat -> a) -> a
09:15:09 <augur> nat Zero z s = z
09:15:19 <augur> nat (Suc n') z s = s n'
09:15:26 <teneen> Eduard_Munteanu: This would be bad. I wonder if it's ever useful at all.
09:15:33 <augur> Lindol: make sense?
09:15:47 <bz> glguy: thanks. didn't knwo about unlines.
09:17:02 <Lindol> augur: Yes
09:17:08 <augur> Lindol: again this is just a case function for nats. we're not at folds yet.
09:17:20 <augur> Lindol: ok, lets play this game one last time but with lists
09:17:39 <augur> list :: [a] -> b -> (a -> [a] -> b) -> b
09:17:44 <augur> list [] n c = n
09:17:51 <augur> list (x:xs) n c = c x xs
09:17:59 <augur> still case analysis, but now for lists.
09:18:49 <Lindol> augur: Understand this one also
09:18:51 <augur> Lindol: in each of these functions, you see what we did was we had one input for the case to case on, and one input for each constructor, with an appropriate type signature so that it could use the sub-values
09:19:10 <augur> so for instance, (,) has the type (,) :: a -> b -> (a,b)
09:19:19 <augur> and we passed in a function p :: a -> b -> c
09:19:37 <augur> Left :: a -> Either a b, and Right :: b -> Either a b
09:19:44 <augur> so we pass in f :: a -> c, g :: b -> c
09:20:08 <augur> Zero :: Nat, Suc :: Nat -> Nat, so we pass in z :: a, and s :: Nat -> a
09:20:20 <augur> [] :: [a], (:) :: a -> [a] -> [a]
09:20:28 <Shin-LaC> augur: the order of arguments there is a little confusing since it differs from maybe's
09:20:33 <augur> so we pass in n :: b, and c :: a -> [a] -> b
09:20:38 <augur> Shin-LaC: shh its pedagogy
09:21:03 <Shin-LaC> oh, ok
09:21:05 <augur> Lindol: so you notice that the functions we pass in have the same types as the constructors, but the return types are different.
09:21:30 <augur> Lindol: yeah?
09:21:49 <Lindol> augur: Yeah
09:22:05 <bz> glguy: is splitAt more efficient than take/drop?
09:22:26 <augur> ok. so what if we want to do recursion over a structure? well for pairs and Either, there's no recursive structure inside them, so pair and Either recursion is the same as pair and Either case
09:22:39 <augur> but what abot nat, Lindol?
09:22:53 <augur> well, what we need to do is, instead of passing in s :: Nat -> a
09:22:57 <augur> we pass in s :: a -> a
09:23:14 <augur> instead of feeding s the predecessor of the number, we feed s the recursively computed result
09:23:22 <augur> natrec :: Nat -> a -> (a -> a) -> a
09:23:27 <augur> natrec Zero z s = z
09:23:31 * hackagebot ZipperAG 0.2 - An implementationg of Attribute Grammars using Functional Zippers  http://hackage.haskell.org/package/ZipperAG-0.2 (prmartins)
09:23:41 <augur> natrec (Suc n) z s = s (natrec n z s)
09:23:47 <augur> -- thanks hackagebot
09:24:00 <ryantrinkle> hey, has anyone tried installing bits-extras on Mavericks?
09:24:11 <Lindol> augur: And the base case for lists is [] then right
09:24:27 <augur> Lindol: right, so now if we do this same trick with lists, we get foldr
09:25:32 <augur> Lindol: fold's in general are the structural recursion principles for a data type. you inspect the value, and decide, for each case, what to do. but instead of simply sending off some return value, you recursively compute a result, and use that.
09:25:55 <augur> Lindol: so let's consider how we would define (+) for nats normally:
09:26:03 <augur> Zero + n = n
09:26:11 <augur> Suc m + n = Suc (m + n)
09:26:26 <skypers> hi
09:27:10 <augur> notice what this does: (+) looks at its first argument. if its Zero, it returns a n, but if it's Suc m, it recursively computes (+) on m and n, and applies Suc to it
09:27:20 <augur> Lindol: that makes sense as a definition of (+) right?
09:27:51 <Lindol> augur: Yeah it does
09:27:54 <augur> Lindol: but we know how to turn this into a natrec, because thats what natrec is for!
09:29:07 <augur> m + n = natrec m n (\r -> Suc r)
09:29:33 <ReinH> oh hai
09:29:42 <augustss> skypers: hi
09:29:45 <augur> when m is zero, we return n, and otherwise we recursively compute, and then suc up the recursive result r
09:30:27 <augur> Lindol: does it make sense how this relates to the pattern matched definition?
09:30:31 <ReinH> johnw: ping
09:31:00 <augur> we couldve alternatively written   m + n = case m of { Zero -> n ; Suc m' -> Suc (m' + n) }
09:31:11 <augur> and from there i think the relationship to the natrec version is clearer
09:31:32 <Lindol> augur: Yeah that case version is easier to understand
09:32:05 <chrisdone> ReinH: he's sleeping, probably be waking up soon  tho
09:32:11 <augur> Lindol: at its core, that is what all folds are about. letting you write structurally recursive pattern-matching functions
09:32:25 <augur> Lindol: consider list in the same fashion. first with real pattern matching:
09:32:28 <ReinH> chrisdone: ty
09:32:37 <augur> map f [] = []  ;  map f (x:xs) = f x : map f xs
09:32:59 <augur> and now with case:   map f xs = case xs of { [] -> [] ; (x:xs') -> f x ; map f xs' }
09:33:42 <augur> whoops, that should be : not ; after f x
09:33:46 <augur> and now with listrec:   map f xs = listrec xs [] (\x r -> f x : r)
09:33:46 <Lindol> augur: Yeah makes sense, ; has to be : or am I wrong?
09:33:54 <Lindol> augur: Ah u already said it
09:34:21 <augur> the listrec version is just the obvious translation of this function, through from pattern matching to case to listrec
09:34:24 <chrisdone> ReinH: http://ircbrowse.net/nick/johnw?recent=false =p
09:34:31 <`^_^v> has anyone used any of these llvm bindings? http://hackage.haskell.org/packages/#cat:Code%20Generation haven't looked through them all but would welcome opinions
09:34:33 <augur> now, what is foldr? well, foldr is just listrec with its list argument last!
09:35:05 <augur> and in general, all folds are this same sort of thing -- a way of representing structurally recursive computations
09:35:20 <augur> Lindol: the "structurally recursive" part of what i said is important btw.
09:35:55 <augur> by structurally recursive, what i mean is something like this: a function f is structurally recursive if, whenever it is called recursively, it is called only on the immediate sub-parts of its input.
09:36:06 <augur> and its called on all of them.
09:36:22 <Takumo> Total noob here, is there some reason why you get an error doing "x <- foo bar" along the lines of     Couldn't match expected type `IO t0'
09:36:25 <Takumo>                 with actual type `Either String [Row BS.ByteString]'
09:36:29 <Takumo> (in GHCi)
09:36:49 <Lindol> augur: I see
09:36:56 <triliyn> Takumo: it should be "let x = foo bar"
09:37:07 <triliyn> <- is a different thing
09:37:19 <triliyn> And "x = foo bar" is allowed at toplevel in files but not in ghci
09:37:44 <ReinH> chrisdone: http://ircbrowse.net/nick/reinh :(
09:37:49 <Takumo> triliyn: But then the type of x weill be `Either String [Row BS.ByteString]`, when on a success it should be [Row BS.ByteString]
09:37:55 <augur> Lindol: a good picture for what this does is like this: since each constructor gets matched to an input (eg Zero ~ z, Suc ~ s, etc.) take the value you're folding over, and replace each constructor with its associated function
09:38:03 <augur> Lindol: replace Zero with z, and Suc with s
09:38:10 <Takumo> which means I can't use all the list processing functions like `take` `head` `tail` etc
09:38:12 <augur> or replace [] with n, and (::) with c
09:38:18 <chrisdone> ReinH: http://ircbrowse.net/nick/ReinH
09:38:27 <augur> do that everywhere, and thats your structurally recursive computation -- the result of a fold
09:39:10 <ReinH> chrisdone: I thought I tried that. Thanks.
09:39:25 <triliyn> Takumo: if you know it succeeded, you can pattern match: let Right x = foo bar
09:39:38 <triliyn> (This should generally be avoided in real code though)
09:40:01 <Takumo> triliyn: ok, so in ghci I'd need to explicitly construct x with Right or Left?
09:40:11 <triliyn> If you don't know it succeeded, you can use >>= to use normal functions within the Either, or you can use the either function to do case analysis
09:40:18 <triliyn> :t either
09:40:19 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
09:41:01 <triliyn> Takumo: the first method isn't constructing, it's pattern matching
09:41:45 <triliyn> Anyway, this either function takes one function to handle the Left case and one function to handle the Right case
09:41:51 <triliyn> They have to have the same return types
09:42:27 <triliyn> If you just want to have it default to some value if there's nothing inside, you can use either (const something) id
09:42:38 <Eduard_Munteanu> teneen: btw, you did enable at least -O, right?
09:42:39 <triliyn> :t either (const ()) id
09:42:41 <lambdabot> Either a () -> ()
09:43:01 <teneen> Eduard_Munteanu: I always use -O2
09:43:58 <teneen> Eduard_Munteanu: I'm trying Data.Map.Strict now. It seems better, the memory consumption increase rate seems slower. However, it reached 10GB :(
09:44:26 <ReinH> triliyn: >>= isn't for "normal" functions, unless you consider a -> m b to be a normal function
09:44:39 <triliyn> ReinH: oh right, fmap, not >>=
09:44:42 <ReinH> right
09:44:46 <triliyn> I make that mistake frequently :(
09:45:03 <ReinH> <$> is useful
09:45:17 <triliyn> (or liftM or <$>, all of which are the same thing)
09:46:07 <Lindol> augur: foldr (/) 2 [8,12,24,4] so if we have this for instance we do 12/((24/(4/2)) etc
09:46:53 <augur> Lindol: well, with the extra 8 in there :)
09:46:56 <augur> but yeah
09:47:00 <lispy> > foldr (/) z [a,b,c,d] :: Expr
09:47:02 <lambdabot>   a / (b / (c / (d / z)))
09:47:12 <lispy> magic!
09:47:29 <augur> [8,12,24,4] == (::) 8 ((::) 12 ((::) 24 ((::) 4 [])))
09:47:33 <Lindol> lispy: Cool :P
09:47:39 <augur> replace (::) with (/), and replace [] with 2
09:47:52 <augustss> (::) ?
09:47:56 <augur> derp :D
09:47:58 <augur> too much agda
09:48:02 <augustss> I wish it were (::)
09:48:07 <augur> also i guess i couldve used infix since both are infix
09:48:13 <augur> 8:12:24:4:[]
09:48:26 <augur> ~ 8/12/24/4/2
09:48:35 * hackagebot Rlang-QQ 0.1.0.0 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.1.0.0 (AdamVogt)
09:48:40 <augur> provided / is right associative, which it probably isnt
09:48:55 <augustss> It isn't.
09:49:23 <augustss> Only the exponentiation operators are right associative (of the arithmetic ones).
09:49:39 <Lindol> augur: I think I get it now, thanks :)
09:50:19 <augur> Lindol: you should try writing some folds for a variety of different types
09:50:43 <ReinH> chrisdone: so I explained how a monad is a monoid in the category of endofunctors at least 3 times last week while I was at a conference.
09:50:48 <augustss> Start with some non-recursive types.
09:50:59 <serpico> !commandos
09:51:03 <ReinH> chrisdone: to non-haskellers
09:51:08 <augur> Lindol: eg write fold for   data Tree a = Leaf a | Branch a (Tree a) (Tree a)
09:51:15 <ReinH> chrisdone: it involved a fair amound of hand waving but I think it was a modest success
09:51:40 <augustss> ReinH: did you have to explain "monoid" and "endofunctor" as well?
09:51:45 <ReinH> augustss: yes
09:51:57 <ReinH> and functor
09:52:10 <ReinH> functor is where some hand waving occurred
09:52:17 <Lindol> foldr :: (a->b-> b) -> b -> [a] -> b if we look at the type signature, [a] is the list we fold over, the first b is our starting value, second b is the result and (a->b->b) is the function we apply?
09:52:28 <augustss> ReinH: you could just have made up some total nonsense instead. :)
09:52:31 <augur> Lindol: also, write a nice little expression evaluator for this math type:   data Expr = Val Int | Add Expr Expr | Sub Expr Expr | ... (add more constructors!)
09:52:36 <augur> write eval :: Expr -> Int
09:52:46 <augustss> Lindol: yes
09:52:47 <augur> and then, using the fold for Expr, re-define eval
09:52:55 <lintguy> Hello. I've read some articles about haskell and are curious, can it be used as a web-language? Replacement to ruby on rails, PHP etc.. ?
09:52:55 <skypers> :t runRWST
09:52:56 <lambdabot> RWST r w s m a -> r -> s -> m (a, s, w)
09:52:57 <augur> Lindol: exactly yes.
09:53:11 <tommd> @seen knsd
09:53:12 <lambdabot> kN$d
09:53:15 <tommd> ?seen knsd
09:53:16 <lambdabot> KNsD
09:53:16 <FreeFull> Reader Writer State Transformer?
09:53:20 <augur> Lindol: and importantly, the types for each of the non-list arguments is directly related to the types of the constructors for list
09:53:21 <tommd> lambdabot!
09:53:24 <seanparsons> lintguy: I'd recommend looking at Yesod if you're interested.
09:53:28 <ReinH> lintguy: yes, take a look at Yesod or Snap
09:53:35 <augur> Lindol: ill also find you some good papers to read, gimme a sec
09:53:36 * hackagebot Rlang-QQ 0.1.0.1 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.1.0.1 (AdamVogt)
09:53:53 <skypers> huh, when we run a state, we get the final state as well?
09:53:55 <skypers> :t runState
09:53:56 <lambdabot> State s a -> s -> (a, s)
09:53:57 * FireFly resists the urge to @faq the web-language question
09:53:58 <ReinH> augustss: well, it was nonsense... of a rather abstract variety...
09:53:59 <skypers> oh
09:54:01 <augur> @where calcfp
09:54:02 <lambdabot> http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/acmmpc-calcfp.pdf
09:54:04 <skypers> that’s weird
09:54:11 <lintguy> Thanks for that! Would you recommend it for this area, or does other languages perform better / Have better tools?
09:54:49 <augustss> lintguy: In this group we recommend Haskell for everything!
09:54:49 <ReinH> lintguy: few languages perform better than Haskell. Why don't you take a look at the tools and see if they meet your definition of "better"?
09:55:54 <Lindol> augur: Thanks!
09:56:08 <lintguy> I know about the performance and syntax, it's just that for example PHP have many IDE´s libraries and frameworks, from what i can see on haskell there is not that much?
09:56:09 <iLike> Hey there, can one make use of monads in  'pure' functions? For example, I have a function with type signature f :: Int -> Text, and I want to get a record out of a DB/TextFile on line Int. How would I go about this?
09:56:15 <augustss> skypers: It's not weird, it is the most general result.
09:56:21 <ReinH> augustss: endofunctors are the easy bit since monads are endofunctors a forteriori (they being the only kind of functor that allows composition)
09:56:50 <skypers> augustss: yeah
09:56:50 <Eduard_Munteanu> iLike: you can pass in a list of records instead of doing IO from that function
09:57:09 <augustss> skypers: there's evalState and execState
09:57:14 <FireFly> lintguy: there are lots of libraries and stuff on hackage. as for editor support I think most people prefer to use old-but-tried text editors (emacs and vim) although there are some Haskell-specialised IDEs as well
09:57:38 <skypers> augustss: yeah sure, but I’m working with RWST here
09:57:45 <augur> Lindol: maybe try also   A Tutorial on (Co)Algebras and (Co)Induction - Jacobs and Rutten
09:57:45 <skypers> but my code is now fixed :)
09:57:51 <iLike> Eduard_Munteanu, wouldn't that be inefficient? It seems to me that it will first read in the whole file/DB in memory and then 'query' it
09:58:00 <augur> Lindol: that also talks about things like unfold
09:58:13 <ReinH> augustss: so it basically involves explaining that monads are composable functors, which really isn't so bad
09:58:20 <lintguy> FireFly: So haskell files are like any source files, just text/code that you compile?
09:58:26 <augustss> skypers: Personally I never understood the charm of RWST.  I just use the state monad for that.
09:58:29 <FireFly> lintguy: yup
09:58:47 <Lindol> augur: Okay, saved that one too
09:58:48 <lintguy> Ok, great
09:58:50 <Eduard_Munteanu> iLike: depends on the usecase, but laziness would allow you to pretend you have it even if it's not in memory
09:59:00 <augur> Lindol: were you able to find it? if not, i can upload it for you
09:59:07 <skypers> augustss: well
09:59:13 <ReinH> augustss: my current challenge is seeing if I can explain comonads to a lay audience
09:59:16 <skypers> I use both the state and writer
09:59:16 <lintguy> FireFly: snap and yesod is not 1.0 yet, are they even mature enough for production use?
09:59:17 <augur> Lindol: but i really recommend trying to implement an evaluator for that little math language i described
09:59:24 <skypers> so I use RWST () w s m a
09:59:28 <iLike> Eduard_Munteanu, with Persist (DB library) for example, it will get the whole table afaik
09:59:35 <Eduard_Munteanu> iLike: another approach would be making general functions that don't need to look stuff up, then you can place a small core in IO
09:59:41 <augur> Lindol: using both basic haskell functions, and also using an expr fold that you define yourself
09:59:43 <Lindol> augur: http://www.cs.ru.nl/~bart/PAPERS/JR.pdf is this it?
10:00:01 <augur> Lindol: yep, thats it
10:00:02 <ReinH> lintguy: well, they are used in production.
10:00:11 <Lindol> augur: Then I found it
10:00:18 <FireFly> lintguy: I don't know much about either to be honest, but people use version numbers in completely different ways. I wouldn't put too much trust into 1.0 meaning "production ready"
10:00:25 <mightybyte> lintguy: Yes.  We've been using Snap to serve a million hits / day for over a year.
10:00:50 <lintguy> mightybyte: that is a mighty impressive number
10:00:54 <iLike> Eduard_Munteanu, the use case here is that I have a DB with Receipt, ReceiptUser and User tables, with a many-to-many relation. I need to know how many users there are on a Receipt
10:01:01 <lintguy> mightybyte: what kind of app do you serve?
10:01:11 <ReinH> mightybyte: fibonacci numbers? ;)
10:01:15 <mightybyte> lol
10:01:17 <lintguy> lol
10:01:31 <ReinH> gotta keep crushing nodejs
10:01:34 <mightybyte> It's an analytics app.
10:01:49 <iLike> It's also in Yesod, so runDB $ count [*filter*] returns a Handler Int. No way to get this to a normal Int I think?
10:01:58 <augur> Lindol: its also good practice in general to try to find some functions you're familiar with and re-implement them using just folds
10:02:25 <Lindol> augur: Yeah I think I will do that
10:02:32 <mightybyte> lintguy: http://snapframework.com/faq#is-anyone-using-snap-in-production
10:02:36 <augustss> iLike: Any access to an external access will be wrapped in some monad.
10:02:40 <Eduard_Munteanu> iLike: you should still keep queries separate from data. You execute a "count" query to get an Int, and it's that Int which your functions need, no?
10:02:43 <augur> Lindol: e.g. factorial, fibonacci, list length, list filter, int tree sum, etc.
10:02:45 <lintguy> mightybyte: do you have experience with creating and consuming web services? Because that's what i wanted build.
10:03:05 <lintguy> mightybyte: i currently use PHP but the performance is _TERRIBLE_ even after a year of optimization
10:03:12 <mightybyte> lintguy: Every time someone visits ladygaga.com a snap server gets hit.
10:03:31 <lintguy> Oh my
10:03:37 * hackagebot Rlang-QQ 0.1.0.2 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.1.0.2 (AdamVogt)
10:03:41 <iLike> so a function usersOnReceipt :: Receipt -> Int would be impossible, unless it's used from a handler function..?
10:03:41 <mightybyte> lintguy: What do you mean by "web services"?
10:03:47 <ReinH> mightybyte: you might as well tell us which analytics service it is
10:03:52 <ReinH> mightybyte: :p
10:03:57 <ryantrinkle> mightybyte: lol, why isn't there a picture of lady gaga on that page?
10:04:02 <lintguy> mightybyte: REST, WSDL, XML etc..
10:04:02 <mightybyte> ReinH: It's not a public one.
10:04:11 <ReinH> mightybyte: ah
10:04:25 <mightybyte> The ladygaga.com reference is Janrain.
10:04:30 <augustss> iLike: that kind of function is impossible, unless Rceipt contains the database.
10:04:31 <Shin-LaC> if I want to try several different things, and return Just the first that succeeds or Nothing if none do, is there a better way than foldr1 orElse?
10:04:46 <cschneid> Shin-LaC: look at the First type.
10:04:48 <Shin-LaC> it seems strange that I have to import Data.Generic.Aliases for something that seems so basic
10:04:55 <iLike> augustss, Eduard_Munteanu, gotcha. Thanks, I'll try to find a workaround
10:05:01 <mightybyte> ryantrinkle: I guess I'm just bad at promoting. :P
10:05:12 <cschneid> > getFirst $ mconcat $ map First [Nothing, Just 1, Just 2, Nothing]
10:05:14 <lambdabot>   Just 1
10:05:36 <augustss> iLike: Any access to the world is in a monad, so your functions has to be as well.
10:06:05 <lintguy> mightybyte: for example, php has great clients and libraries for consuming all of these.
10:06:11 <Shin-LaC> cschneid: that looks more convoluted than it needs to be :/
10:06:13 <ReinH> > ala First foldMap [Just 1, Nothing] -- cschneid
10:06:15 <lambdabot>   Just 1
10:06:18 <Shin-LaC> but thanks
10:06:26 <iLike> augustss, yea, I figured as much. It's a shame though, makes working with Yesod harder (at least to me)
10:06:26 <mightybyte> lintguy: Sure, it's quite straightforward to write web services like that.
10:06:31 <cschneid> ReinH: ahh, that's right, I forget ala exists.
10:06:35 <cschneid> I think I've seen it only once.
10:06:39 <ReinH> cschneid: could just be
10:06:50 <ReinH> getFirst . foldMap First
10:07:03 <lintguy> mightybyte: Ok, so it's not quickly turning into spaghetticode like in PHP where many use CURL when there is no proper client available?
10:07:04 <cschneid> @src ala
10:07:05 <lambdabot> Source not found. stty: unknown mode: doofus
10:07:16 <mightybyte> lintguy: No
10:07:16 <augustss> iLike: It's usually not that hard to work around.
10:07:16 <ReinH> cschneid: it's in lens and makes use of the newtype isomorphism
10:07:25 <cschneid> ah, cool.
10:07:28 <Shin-LaC> I think I'll just define my own orElse
10:07:39 <Shin-LaC> it's ridiculous to need so many dependencies for something so basic
10:07:42 <lintguy> mightybyte: Ok, i'll set it up and try some examples. Thanks for the answers!
10:07:53 <iLike> augustss, It does make my Handler functions seem rather bloated :(
10:08:14 <mightybyte> lintguy: I got into Haskell web development 5 years ago because I was tearing my hair out trying to build a web app in PHP.
10:09:17 <enthropy> should I spam R people with http://hackage.haskell.org/package/Rlang-QQ, or would the only users be people who already use haskell?
10:09:42 <sclv_> > msum [Nothing, Just 1, Just 2, Nothing]
10:09:43 <lambdabot>   Just 1
10:09:47 <sclv_> Shin-LaC: ^^
10:09:52 <schell> any news on the next release of the platform?
10:10:01 <sclv_> monadplus for just acts as the First monoid
10:10:04 <sclv_> and its in base!
10:10:19 <sclv_> for maybe rather, but you know what i mean
10:10:26 <Shin-LaC> yes
10:10:27 <Shin-LaC> thanks
10:10:34 <ReinH> Shin-LaC: "so many dependencies"? You just need Data.Monoid
10:11:05 <sclv_> (personally i think the Monoid instance for Maybe should also be First by default, since its the common case)
10:11:14 <ReinH> sclv_: oh msum, awesome
10:11:17 <Shin-LaC> ReinH: I mean conceptual dependencies, too
10:11:18 <sclv_> (and the weird monoid from a semigroup one we have should go away)
10:11:29 <ReinH> Shin-LaC: Monoid is a pretty foundational "conceptual dependency"
10:11:40 <sclv_> (and also we should eliminate last and just have the Reverse wrapper around the default instance to give it)
10:11:43 <enthropy> sclv_: why would you want one implementation when we currently have two?
10:11:44 <ReinH> sclv_: Option?
10:12:04 <ReinH> sclv_: it's only an artifact of the historical error of Semigroup not being a superclass of Monoid :p
10:12:08 <sclv_> 99% of the time the monoid people want on Just is maybe.
10:12:10 <Shin-LaC> well, I don't know monoids
10:12:19 <Shin-LaC> I haven't needed them until now
10:12:21 <enthropy> > mconcat [ Just "abc", Nothing, Just "def" ]
10:12:23 <lambdabot>   Just "abcdef"
10:12:25 <sclv_> everyone knows monoids
10:12:32 <lintguy> mightybyte: That is exactly what i have been doing as well.
10:12:33 <sclv_> they're just an associative operation and a zero
10:12:34 <tac> Shin-LaC: Monoids are the easiest of all the algebraic structures.
10:12:40 <ReinH> sclv_: a one :p
10:12:44 <Shin-LaC> well, I know monoids in algebra
10:12:45 <ReinH> let's call it unit and not fight
10:12:49 <Shin-LaC> I have no idea what they mean in haskell
10:12:51 <ReinH> Shin-LaC: they are the same
10:12:54 <tac> Any time you've added two numbers together or concatenated two lists, you've just monoided.
10:13:12 <mightybyte> lintguy: I finally got to the point where PHP made me unable to motivate myself to keep working on my app.
10:13:12 * Iceland_jack has never heard “monoid” as a verb
10:13:15 <lintguy> mightybyte: Luckily, during the latest years PHP has become better and frameworks matured - but at a huge cost of performance :-(
10:13:22 <mightybyte> Haskell made web development interesting again.
10:13:27 <Shin-LaC> ok
10:13:38 * hackagebot lifted-base 0.2.1.1 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.1.1 (BasVanDijk)
10:13:43 <ReinH> sclv_: we need zero to describe annihilation (zero * a = zero)
10:14:00 <ReinH> or absorbtion
10:14:00 <lintguy> mightybyte: So for web server snap or yesod is well and all, but what about databases?
10:14:06 <ReinH> or whatever the kids are calling it these days
10:14:10 <mightybyte> lintguy: postgres
10:14:26 <Shin-LaC> still, I got three different answers on how to combine Maybes in what seems to be the most natural way to use Maybes
10:14:43 <cschneid> Shin-LaC: ya, although several of them are doing the same thing in different ways
10:14:53 <Shin-LaC> I would say that it is surprisingly non-obvious
10:15:01 <Shin-LaC> but I don't mean to complain, I've learned something
10:15:03 <cschneid> the  ala First foldMap [Just, Nothing...] is identical to what I said. Except uses the `ala` commend to be a bit shorter
10:15:05 <simpson> Shin-LaC: Wait, what's the operation that you want to do? What's its type?
10:15:23 <cschneid> simpson: he wants the first `Just` out of a list. Or Nothing if no Just
10:15:37 <ReinH> Shin-LaC: well, the most common way is probably the monoid behavior: Nothing <> _ = Nothing
10:15:38 <Shin-LaC> simpson: its type is Maybe a -> Maybe a -> Maybe a, and I've already tried hoogling that and I get forty results, most of them irrelevant
10:15:52 <ReinH> Shin-LaC: if you want a different behavior, it's quite common to use a newtype wrapper
10:16:03 <simpson> Shin-LaC: I can think of only two total functions with that type. No, wait, three.
10:16:05 <Shin-LaC> ReinH: I'm happy with the monoid
10:16:14 <Shin-LaC> simpson: maybe my hoogle is broken
10:16:37 <mightybyte> lintguy: There are several good Haskell libraries for postgres.  I use postgresql-simple and groundhog.
10:16:54 <ReinH> Shin-LaC: my point is that if you want the monoid behavior to be Just a <> Nothing = Just a rather than _ <> Nothing = Nothing then you need a newtype, i.e. First
10:17:18 <simpson> Shin-LaC: Okay, so there's a bunch of different things that can be done here. None of them are really obvious and none of them are *the* operation. The simplest function that satisfies that type is something like: f _ _ = Nothing
10:17:35 <Shin-LaC> ReinH: I see, so I need to turn the Maybe x into a First x
10:17:56 <ReinH> Shin-LaC: well, First (Maybe x), if you want to use the First monoid
10:18:11 <ReinH> Shin-LaC: it's quite common to wrap and unwrap a newtype to use its properties:
10:18:31 <Shin-LaC> I agree with sclv_ that First should be the default for Maybe
10:18:55 <ReinH> Shin-LaC: i.e. this sort of combinator:
10:18:58 <ReinH> > let go f = getFirst . foldMap (First . f) in go id [Just 1, Nothing]
10:18:59 <lambdabot>   Just 1
10:19:08 <cschneid> > mconcat [Just "a", Just "b", Nothing]
10:19:10 <lambdabot>   Just "ab"
10:19:20 <Shin-LaC> yeah, I'll use msum
10:19:25 <simpson> Shin-LaC: Note that you could non-Monoid this as well if it's just for lists: f [] = Nothing; f (Nothing:xs) = f xs; f ((Just x):_) = Just x
10:19:28 <cschneid> > msum [Just "a", Just "b", Nothing]
10:19:29 <lambdabot>   Just "a"
10:19:47 <Iceland_jack> > msum [Just "a", Nothing, Just "c", Nothing, Just "e"]
10:19:48 <lambdabot>   Just "a"
10:19:49 <augur> Lindol: lemme know if you have any further questions, ey?
10:19:49 <ReinH> > let go f = getFirst . foldMap (First . fmap f) in go succ [Just 1, Nothing]
10:19:51 <lambdabot>   Just 2
10:19:52 <Iceland_jack> > sequence [Just "a", Nothing, Just "c", Nothing, Just "e"]
10:19:54 <lambdabot>   Nothing
10:19:58 <ReinH> Shin-LaC: you wind up doing this sort of thing a lot
10:20:12 <augur> Lindol: im usually always on, usually responsive about half of that time, so long as im not asleep or teeching
10:20:16 <augur> teaching D:
10:20:25 <lintguy> mightybyte: Ok, thanks! Are there nosql databases too?
10:20:25 <Iceland_jack> > (concat . catMaybes) [Just "a", Nothing, Just "c", Nothing, Just "e"]
10:20:26 <lambdabot>   "ace"
10:20:43 <Lindol> augur: Sure, will do!
10:20:53 <ReinH> Shin-LaC: alternatively, you have to know that the default MonadPlus instance for Maybe uses First semantics
10:21:02 <augur> speaking of
10:21:04 <sclv_> ?hoogle [Maybe a] -> Maybe a
10:21:05 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
10:21:05 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
10:21:05 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
10:21:06 <mightybyte> lintguy: Sure.  There are libraries for a number of DBs.  mongo, cassandra, redis, etc.
10:21:10 <sclv_> hoogle is actually quite helpful here tho
10:21:16 <cschneid> ReinH: that incongruity of mconcat vs. msum is surprising.
10:21:16 <ReinH> Shin-LaC: which arguably requires more cognative overhead than remembering a simple mechanism for wrapping and unwrapping newtypes
10:21:27 <ReinH> cschneid: exactly
10:21:38 <sclv_> the monoid instance of Maybe is six ways stupid
10:21:40 <augur> anyone who's comfortable with monads at a sort of professional or theoretical level, could you review this for me: http://purelytheoretical.com/programming/ImplementingHaskellIOInJavascript.html
10:21:42 <mightybyte> lintguy: Just look through the package list at http://hackage.haskell.org/package/
10:21:49 <ReinH> I would say that knowing that mconcat and msum for Maybe do different things requires more cognative overhead than knowing how to wrap and unwrap newtype instances
10:21:52 <Shin-LaC> sclv_ I'm using hoogle locally in ghci, and it gives me a bunch of stuff from Data.Foldable and Graphics.Rendering.OpenGL
10:22:00 <ReinH> one is a specific solution to a specific problem, the other is extremely general
10:22:01 <cschneid> sclv_: and I imagine that its engrained enough it should stay the same? and/or is a big deal to standardize
10:22:16 <sclv_> nah we just should lobby the libraries committee to fix it
10:22:23 <sclv_> i can't imagine many people use the current instance
10:22:28 <sclv_> even though yeah it is ingrained
10:22:38 <cschneid> sclv_: you think the mconcat default is silly, where it concats the inner values?
10:22:52 <ReinH> Shin-LaC: For instance, if I want to fold a bunch of values using some monoidal behavior, the very first thing I would look for was a newtype that provided the behavior that I could use with foldMap
10:22:54 <enthropy> sclv_: I use it for sure
10:23:02 <ReinH> it's a very general pattern for solving such problems
10:23:19 <ReinH> and if one doesn't exist, it's quite possible that by creating one you could provide a generally useful newtype
10:23:35 <Shin-LaC> ReinH: I see your point
10:23:55 <sclv_> yeah. it gives you a monoid over a semigroup, not a monoid over a monoid.
10:23:57 <ReinH> in this case, all you have to remember is that newtypes can provide new behaviors for existing types, and that foldMap exists :)
10:24:11 <sclv_> and it only works for some inner 'a' while the First version works for all a
10:24:29 <srhb> in forkProcess :: IO () -> IO ProcessID -- am I understanding it correctly that the IO action is not executed in the parent process?
10:24:32 <cschneid> ReinH: I'm bad at remembering that second part. :)  Time to go read up on foldMap
10:24:51 <ReinH> cschneid: not much to read. It maps something onto a monoid and then folds ala mconcat
10:24:56 <ReinH> well, ala fold
10:25:13 <ReinH> same difference
10:25:42 <sclv_> you can also always get the current behavior by doing mconcat . catMaybes
10:26:03 <sclv_> which actually happens to express what it actually does!
10:26:13 <cschneid> sclv_: I'm with ya :)
10:26:16 <sclv_> so its also unambiguous
10:26:19 <ReinH> sclv_: so does ala First foldMap!
10:26:27 <ReinH> or getFirst . foldMap First
10:26:35 <ReinH> if you aren't into the whole lens thing
10:26:59 <sclv_> my argument that the First instance is the most sensical and general one for Maybe that has 'least surprise'
10:26:59 <fizruk_> sclv_, what do you suggest to be the default Monoid definition for Maybe?
10:27:49 <ReinH> sclv_: the issue though is that this would make the monoid behavior different from the monad behavior, right?
10:27:54 <lintguy> mightybyte: Ah, so there where a package list! I had trouble finding it
10:27:58 <sclv_> wait what
10:28:01 <ReinH> you still want "short circuiting of errors" behavior for the Maybe monoid
10:28:13 <sclv_> it makes the monoid behavior consistent with the monadplus behavior!
10:28:22 <sclv_> at the moment the instance is different for the two
10:28:37 <ReinH> `possibleFailure >>= possiblyFailingAction' should return Nothing if either produce a failure, right?
10:28:45 <ReinH> not the first success?
10:28:52 <sclv_> because that breaks the laws
10:28:57 <sclv_> and makes no sense
10:29:01 <ReinH> ?
10:29:13 <sclv_> possibleFailure and possiblyFailingAction have different types
10:29:29 <ReinH> sclv_: assign them the types that make sense in context
10:29:32 <ReinH> :t (>>=)
10:29:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:29:37 <ReinH> possibleFailure is a Maybe a
10:29:43 <ReinH> possiblyFailingAction is an a -> Maybe b
10:29:49 <sclv_> but you still have an 'a' and a 'b'
10:29:52 <fizruk_> sclv_, m >> n or f >=> g
10:30:01 <ReinH> sclv_: which could just as well be a -> Maybe a
10:30:10 <sclv_> its just totally different
10:30:13 <sclv_> this is silly
10:30:36 <sclv_> and furthermore that doesn't coincide with the current instance for Maybe anyway!
10:30:49 <sclv_> (current monoid instance i mean)
10:30:54 <ReinH> sclv_: wouldn't you expect sequence and mconcat to behave similarly?
10:31:05 <sclv_> but they don't at the moment
10:31:32 <sclv_> and they can't
10:31:34 <sclv_> ?ty sequence
10:31:35 <lambdabot> Monad m => [m a] -> m [a]
10:31:38 <sclv_> ?ty mconcat
10:31:39 <lambdabot> Monoid a => [a] -> a
10:31:52 <ReinH> sclv_: oh right, the monoid constraint
10:31:55 <ReinH> sigh
10:31:56 <sclv_> mconcat doesn't have an 'm on the outside'
10:32:02 <sclv_> forgetting the constraints even
10:32:34 <smith_> What's the best way to split a String on a Char--or any [a] on an `a` to get [[a]]?
10:32:47 <ReinH> smith_: loot at Data.List.Split
10:32:49 <ReinH> look
10:32:50 <sclv_> smith_: you want the split package from hackage
10:33:09 <sclv_> there are so many knobs to twiddle with how exactly you may want to split
10:33:29 <sclv_> that someone wrote a package for it instead of sticking just one function, that probably isn't exactly right for any given case, into base
10:33:55 <cschneid> +1 on the split package. Solved every splitting problem I've run into so far
10:34:03 <smith_> Okay. Thanks!
10:34:42 <fizruk_> what's an example of a monad that can't have an appropriate transformer?
10:35:28 <lintguy> mightybyte: This is going to sound odd, do i need to learn haskell before i learn yesod?
10:35:39 <mightybyte> lol
10:36:05 <simpson> fizruk_: ListT is an example.
10:36:06 <mightybyte> Kind of
10:36:11 <srhb> lintguy: Yesod will be a very, very black box until you know quite a lot of Haskell. :)
10:36:18 <mightybyte> I learned Haskell while building a web app.
10:36:42 <lintguy> I learn best by example, so i thought i'd give a shot at http://shop.oreilly.com/product/0636920023142.do
10:36:44 <schell> mightybyte, lintguy: i'm still learning haskell while building a web app
10:36:49 <fizruk_> simpson, oh and any backtracking thing? are there more examples?
10:37:40 <simpson> fizruk_: IIUC it's more because ListT [] has trouble obeying the laws.
10:37:47 <lintguy> still i understand that learning haskell is important and i plan to, but it's hard to know where to start so i thought i'd start at what motivates me to learn haskell.
10:38:07 <simpson> fizruk_: http://www.haskell.org/haskellwiki/ListT_done_right
10:38:08 <arpunk> lintguy: what about snap instead of yesod?
10:38:36 <lintguy> arpunk: Well.. does snap have http://www.yesodweb.com/book/web-application-interface ?
10:38:36 <mightybyte> lintguy: I'd just pick a web framework and get started.  But you'll find that you will need to refer to things like LYAH and RWH quite a bit.
10:38:38 <arpunk> lintguy: yesod can be daunting because of the heavy use of template haskell
10:39:01 <augur> anyone know roughly how GHC implements IO?
10:39:02 <mightybyte> lintguy: Yes.  It's called snap-core.
10:39:17 <lintguy> arpunk: template haskell?
10:39:40 <lintguy> Hm, seems like i need to read up on both and compare.
10:40:00 <enthropy> @src IO
10:40:01 <lambdabot> Source not found. My brain just exploded
10:40:35 <lintguy> Whoa… template haskell doesn't have closed tags
10:40:43 <lintguy> how the… what?
10:40:43 <arpunk> lintguy: you might want to start here: http://www.yesodweb.com/book/introduction
10:40:47 <lintguy> never seen that before
10:41:04 <enthropy> augur: you can look for a  newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)) GHC.Types
10:41:10 <fizruk_> simpson, do you know of another examples?
10:41:17 <enthropy> but maybe you need to look deeper
10:41:28 <simpson> fizruk_: No, but I don't transformers much. edwardk probably does.
10:41:41 <lintguy> this really is a world of it's own
10:41:47 <augur> enthropy: im not sure how that works tho
10:41:52 <fizruk_> simpson, ok, thanks!
10:41:54 <srhb> lintguy: Yup :-)
10:41:58 <enthropy> it's a definition in that module
10:42:07 <schell> lintguy: i chose Yesod first, then moved to Happstack after I had trouble updating from one version of Yesod to another, then moved to Snap. Snap has been my favorite so far and migration has been easy each time. Yay haskell
10:42:10 <lintguy> i'm afraid learning this will take too long
10:42:27 <augur> enthropy: ??
10:42:32 <Luke> snap's my favorte as well
10:42:38 <Luke> best mix of features and simplicity
10:42:42 <srhb> I lean towards Happstack. Feels more like Haskell
10:42:47 <lintguy> schell: thanks for that input, reliable upgrades are important
10:42:52 <arpunk> lintguy: yes, but it is worth it
10:43:07 <lintguy> arpunk: i'm believing that more and more.
10:43:08 <Luke> lots of yesod based stuff seems to have version/deps problems for me
10:43:11 <Luke> its a huge pain
10:43:18 <iLike> lintguy, I followed a functional programming (in haskell) course the last 10 or so  weeks, and I'm struggling with understanding Yesod. I would _HIGHLY_ recommend getting a strong grasp on haskell first
10:43:41 <srhb> Or just not use Yesod. It is by far the most complicated of the three to dive in.
10:43:44 <srhb> into*
10:43:54 <lintguy> iLike: Thanks on that input too, so maybe snap would be a better choice for a beginner?
10:43:54 <Luke> yeah yesod has a lot of stuff going on
10:44:01 <iLike> I can't speak of other frameworks, yesod is hard imo
10:44:03 <Luke> kinda complicated
10:44:08 <Luke> i would say snap is the best for beginners and experts =)
10:44:14 <Luke> its scaling really well for me
10:44:18 <lintguy> Great then, snap it is!
10:44:18 <Luke> and was easy to get started w/
10:44:27 <Luke> snap has great support too
10:44:30 <srhb> lintguy: Have a look at Happstack too. Great crash course. :)
10:44:35 <lintguy> (but i will read up first anyhow)
10:44:42 <lintguy> Thanks.
10:44:53 <enthropy> augur: that's how ghc stops various optimizations from making bad side effects follow the rules
10:44:54 <lintguy> To you all, this seems like a really nice community!
10:45:08 <srhb> That it is. I've gotten so much help in here. You should stick around. :)
10:45:11 <lintguy> Asking this in PHP and i would get bitchslapped and dragged after a car
10:45:16 <srhb> Haha
10:45:17 <iLike> lintguy, it is! It has proven extremely helpful
10:45:20 <mightybyte> lintguy: Here are some resources comparing the different frameworks.
10:45:24 <mightybyte> http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks/5650715#5650715
10:45:32 <Luke> mightybyte: i was just looking for that =)
10:45:35 <arpunk> lintguy: yesod is great, it just it uses a few language extensions that require a solid basic understanding of haskell
10:45:39 <Eduard_Munteanu> teneen: can you try this one? http://lpaste.net/95202
10:45:42 <mightybyte> http://softwaresimply.blogspot.com/2012/12/haskell-web-framework-matrix_20.html
10:46:01 <mightybyte> http://softwaresimply.blogspot.com/2012/04/hopefully-fair-and-useful-comparison-of.html
10:46:09 <enthropy> augur: so I guess your problem is now "how does ghc evaluate pure code" for which you can look at SPJ's book on STG or something like that
10:46:16 <lintguy> this is really amazing, you are too kind!
10:46:22 <mightybyte> Those are things I've written.
10:46:34 <lintguy> I was uncertain but it seems haskell will give the best of all worlds the more i read about it.
10:46:57 <augur> enthropy: no, thats not where im headed at all :P
10:47:58 <mightybyte> lintguy: Haskell will absolutely be the best of all worlds. :)
10:48:01 <lintguy> Typesafe is important for web services i think.
10:48:07 <iLike> lintguy, facebook uses haskell for their high-load chat service (in combination with Erlang though)
10:48:15 <enthropy> ok well I dunno what kind of answer you're looking for then
10:48:15 <iLike> Link for the interested: http://cufp.galois.com/2009/slides/PiroLetuchy.pdf
10:48:20 <lintguy> So if snap is not typesafe, maybe yesod or happstack is a better choise
10:48:48 <mightybyte> lintguy: Snap can be just as type safe as the others.
10:48:58 <arpunk_> lintguy: no no, is not that snap is not typesafe, it means that yesod kind of automates that process for you in many steps
10:49:00 <lintguy> mightybyte: good to know
10:49:11 <Eduard_Munteanu> lintguy: yesod just has more type trickery for stuff like type-safe *urls*
10:49:18 <lintguy> arpunk: Ah, ok
10:49:26 <mightybyte> lintguy: Snap argues that some things should not be type safe.
10:49:31 <mightybyte> ...like HTML
10:49:39 <lintguy> I can agree with that though
10:49:42 <Ove_> Supz
10:49:43 <Ove_> It'
10:49:45 <Ove_> s
10:49:45 <Ove_> me
10:49:54 <Eduard_Munteanu> Why shouldn't HTML be typesafe?
10:49:54 <Ove_> How are you guyz doing?
10:49:56 <srhb> Ove_: I think you'll find you've remapped your return key to your space key.
10:50:17 <Ove_> srhb: ' is next to return key.
10:50:19 <mightybyte> Eduard_Munteanu: Because I don't want to have to recompile my whole app to make a change to my markup.
10:50:25 <Ove_> And I really don't like this keyboard.
10:50:31 <chrisdone> mightybyte: long time no see =)
10:50:35 <Ove_> I miss my old keytronic. :(
10:50:39 <mightybyte> chrisdone: :)
10:50:40 <lintguy> Eduard_Munteanu: Because not all html are correct if imported
10:50:46 <Eduard_Munteanu> mightybyte: that alone shouldn't be an issue if we had incremental recompiling
10:51:01 <mightybyte> Eduard_Munteanu: But we don't
10:51:11 <mightybyte> And yes, it still would be.
10:51:15 <lintguy> hm, that sounds like a timesaver
10:51:29 <Eduard_Munteanu> lintguy: you still want to write valid HTML even if most HTML sucks
10:51:32 <mightybyte> ...because the whole model of Haskell is to put as much as possible into the compiler.
10:51:51 <mightybyte> Eduard_Munteanu: That doesn't mean that it has to be type safe.
10:51:53 <Eduard_Munteanu> mightybyte: yeah, I'm nitpicking on "shouldn't" vs "it's inconvenient because something else sucks" :)
10:52:04 <srhb> lintguy: No offense intended, but I think it will be hard to make informed choices about those details in the the frameworks without being a bit informed on Haskell first. :)
10:52:12 <mightybyte> Heist gives parse errors if your markup is wrong.
10:52:48 <lintguy> srhb: Yeah, it is probably best to learn haskell properly from the ground up.
10:52:53 <augur> enthropy: the question really becomes what is RealWorld in practice
10:52:59 <srhb> lintguy: Besides, you can mix and match a lot of the stuff from the frameworks as you see fit
10:53:04 <chrisdone> wrong html is the last of your worries in web dev
10:53:10 <srhb> lintguy: And you might as well give them all a spin once you've gotten the basics down :)
10:53:10 <lintguy> I'll just have to move work out of the way, save money, and read.
10:53:18 <iLike> It makes sense to have to recompile everytime you change your markup, because the markup (in yesod, at least) is essentially a DSL
10:53:19 <ReinH> arpunk_: god forbit haskell programmers be expected to have a solid basic understanding of haskell ;)
10:53:32 <srhb> ReinH: I thought that was the compiler's job. :)
10:53:42 <lintguy> srhb: i agree, else i will just think that the grass is greener on the other side of the framework.
10:53:44 * hackagebot cqrs-example 0.9.1 - Example for cqrs package  http://hackage.haskell.org/package/cqrs-example-0.9.1 (BardurArantsson)
10:53:50 <srhb> lintguy: Yup!
10:53:50 <ReinH> srhb: I'm still waiting for the compiler that writes my code for me
10:53:57 <chrisdone> users don't care as long as the page works. making it work is top priority =)
10:54:09 <srhb> ReinH: {-# LANGUAGE LANGUAGE #-}
10:54:16 <ReinH> chrisdone: it's almost impossible to not have "wrong html" fsvo wrong
10:54:43 <mightybyte> iLike: And that slows down development significantly.
10:55:06 <iLike> mightybyte, it does, it also cuts down on debug time significantly
10:55:14 <mightybyte> Not in my experience.
10:55:45 <ReinH> {-# LANGUAGE DoWhatIMean #-}
10:55:46 <iLike> Care to elaborate? Everything I made (which compiled) more or less did what I intended it to do
10:55:55 <srhb> ReinH: Oh how I've wished for that.
10:56:51 <mightybyte> iLike: The big draw of type safe routes is essentially to make your links DRY...i.e. you only specify actual URLs in one place.  That way if you change them, you won't forget to update something and have a broken link.
10:57:20 <mightybyte> iLike: But you can get DRY URLs without going all type safe on everything.
10:57:41 <Eduard_Munteanu> Say I have a set A, a function f : A -> ℝ and T ∈ ℝ. I want to find k_i, n ∈ ℕ_+ such that |∑ k_i f(a_i) - n T| <= ε. And I want to pick ks fairly: max k_i - min k_i <= 1 (e.g. roundrobin)
10:57:48 <Eduard_Munteanu> Any idea what such a problem is called?
10:58:16 <schell> mightybyte: couldn't it be as easy as making a function for each url?
10:58:17 <Eduard_Munteanu> Some sort of knapsack problem where you just have to fill them as close as possible to full.
10:58:30 <schell> well - i guess then you'd have the choice NOT to use your functions
10:58:34 <mightybyte> schell: Roughly, yes.
10:58:38 <ReinH> mightybyte: compile time verification of generated URLs is pretty damn nice :)
10:58:45 * hackagebot HaTeX 3.9.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.9.0.0 (DanielDiaz)
10:58:50 <srhb> schell: It's all a question of how badly you want your compiler to stop you from doing something bad.
10:58:51 <mightybyte> ReinH: Sure, but it has a cost.
10:58:57 <schell> so you make a datatype that contains a url and you make your routes use that
10:59:03 <ReinH> mightybyte: yes, but as long as that cost is paid at compile time... ;)
10:59:04 <chrisdone> schell: if the functions return a type that your redirect and anchor functions only accept, then it's easy to make sure you use them
10:59:06 <schell> srhb: right
10:59:20 <mightybyte> ReinH: ...it will slow your development down.
10:59:31 <ReinH> mightybyte: I haven't seen that but I don't have as much experience
10:59:31 <schell> chrisdone: exactly
10:59:39 <chrisdone> ReinH: how much verification?
10:59:54 <ReinH> chrisdone: well, wellformedness is about all you can get
11:00:01 <ReinH> you can't ensure that, e.g., ids exist
11:00:26 <ReinH> but wellformedness is still quite useful
11:00:36 <mightybyte> ReinH: The cost I'm referring to *is* the compile time.
11:00:55 <apo> I just got 7 bonus points on an exercise that gave 16 points. I guess I'm pretty decent at haskell, at least compared to the expectations :P
11:01:20 <chrisdone> there's more than that, you can relate the current handler with the URL it was accessed by, and the context in which the url is generated, e.g. a user cannot visit a page if she isn't logged in
11:01:43 <mightybyte> ReinH: I have seen it.  Snap even has dynamic code recompiling with Hint.  But it becomes unusable once your app gets big enough.
11:01:45 <Eduard_Munteanu> apo: I guess expecting the worst of somebody should be a flattering thing :P
11:02:04 <Flonk> If the fixity of something is not defined it defaults to 7 right?
11:02:07 <srhb> mightybyte: Wouldn't plugins be better in that regard?
11:02:10 <ReinH> mightybyte: what sort of size is "big enough"?
11:02:19 <apo> Eduard_Munteanu: Not of somebody, just of a group ;)
11:02:23 <chrisdone> mightybyte: but the answer isn't necessarily "use template files", ofc
11:02:51 <mightybyte> ReinH: 33k lines of code.
11:03:01 <ReinH> mightybyte: that's... hmmm...
11:03:09 <ReinH> not that big
11:03:18 <mightybyte> And it probably happened when the app was smaller than that.
11:03:20 <ReinH> mightybyte: what sort of unusable?
11:03:25 <mightybyte> Unusable
11:03:28 <mightybyte> Wouldn't work
11:03:31 <ReinH> got that part
11:03:31 <chrisdone> 30 is your average serious web app
11:03:46 * hackagebot haskintex 0.3.0.0 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.3.0.0 (DanielDiaz)
11:03:53 <ReinH> mightybyte: what kind of wouldn't work? Wouldn't compile?
11:04:15 <mightybyte> Required too much memory or something.  I don't remember.
11:04:32 <ReinH> mightybyte: o_O
11:04:35 <ReinH> mightybyte: good times
11:04:47 <ReinH> mightybyte: so what is the alternative? Sorry if I missed that part.
11:05:15 <chrisdone> i have a 30k line web app here that uses blaze-html
11:05:20 <chrisdone> rebuilding and linking takes a couple seconds
11:05:24 <mightybyte> srhb: We did an examination of Haskell's dynamic code loading awhile back and in the end had to conclude that it's simply not good enough for mission-critical use right now.
11:05:32 <chrisdone> (hurrah, conditional compilation)
11:05:40 <srhb> mightybyte: *nods*
11:05:58 <ReinH> mightybyte: hasn't SM done some new stuff with that at Facebook?
11:06:05 <mightybyte> ReinH: The alternative is to not make your markup not be run through GHC.
11:06:09 <chrisdone> (admittedly only 3k lines of that exists in the View/ directory. but yeah)
11:06:11 <ReinH> I guess I'll have to ask him when we get him on the podcast
11:06:23 <lintguy> Hm, a user on another irc channel gave a good reason not to choose haskell - it will be hard to find developers and those available charge a lot per hour… while choosing nodejs it's easy as giving out candy on the streets, people will come running.
11:06:29 * ReinH adds to his topic list
11:06:39 <srhb> lintguy: Is that a good reason?
11:06:51 <mightybyte> lintguy: But the developers you can get will be WAY more talented on average.
11:06:55 <ReinH> lintguy: so your argument in favor of node is essentially that it's really easy to find a lot of bad programmers?
11:07:03 <lintguy> srhb: Well, from experience, labour is more expensive than adding machines.
11:07:06 <fl00r> and you don't have to read nodejs
11:07:09 <srhb> ReinH: The foundations on which NodeJS is built.
11:07:10 <scriptor> you can find PHP programmers pretty easily, too
11:07:11 <chrisdone> we're using yesod at fp complete and reloading a template takes a few seconds
11:07:14 <ReinH> srhb: and PHP
11:07:18 <srhb> ReinH: :-)
11:07:21 <ReinH> and anything with a sufficiently low barrier to entry
11:07:27 <Luke> lintguy: http://www.paulgraham.com/pypar.html
11:07:27 <mightybyte> ReinH: We did that examination probably 4-6 months ago, so I don't know the current state of affairs.
11:07:42 <Luke> python paradox explains why using a less popular language isn't bad if the people around the language are smart
11:07:47 <ReinH> mightybyte: I'll make sure we ask SM
11:07:51 <ReinH> I'm interested too
11:08:01 <mightybyte> Yeah, I'd love better dynamic loading support.
11:08:03 <chrisdone> (though we use a custom yesod-devel)
11:08:03 <FreeFull> Python did end up becoming more popular over time
11:08:13 <simpson> Luke: The funny thing is that the Python community's gotten consistently worse as it's become more popular.
11:08:14 <srhb> lintguy: If your argument for using Haskell is "I want my webapp to be really, really fast" you're missing out on most of the really great reasons to use it.
11:08:16 <lintguy> Luke: Exactly, like any language, there are good developers too.
11:08:29 <ReinH> simpson: this follows directly from Sturgeon's Law
11:08:33 <Luke> simpson: true but the point was made about python when it was unpopular
11:08:35 <simpson> ReinH: Quite.
11:08:37 <Luke> or unmainstream
11:08:42 <lintguy> srhb: the arguments would be many more than that, but in the end, it's also about labour and costs.
11:08:43 <simpson> Luke: Sure.
11:08:46 <ReinH> if 90% of everything is shit then the actual amount of shit is directly proportional to the actual amount of everything
11:08:55 <srhb> lintguy: So... You're hiring?
11:08:55 <Luke> totally
11:09:17 <lintguy> srhb: No use in hiring if i don't understand half of it myself.
11:09:20 <ReinH> lintguy: keep in mind that as humans we tend to vastly underestimate long term costs
11:09:23 <ReinH> our cost models are terrible
11:09:24 <Luke> ReinH: I wouldn't say it scales linearly though. I think less than 90% of haskell is shit
11:09:32 <Luke> but as more people pile on, it tends to get shittier
11:09:33 <ReinH> Luke: that would violate Sturgeon's Law
11:09:36 <ReinH> :p
11:09:44 <lintguy> ReinH: I'm very aware of that unfortunately the hard way.
11:09:46 <chrisdone> mightybyte: yesod-devel uses hint, but we ended up implementing a dual-ghci system which would have one active ghci and one passive. whenever you rebuild it kills the active one and runs :reload and :main in the inactive one and launches another. the newly launched one will load up all packages so that next time you reload you don't have to wait for that. it's now a second or two to update a hamlet file and restart the server =)
11:09:53 <ReinH> Luke: as a counter point, how many packages on Hackage do you use?
11:09:55 <simpson> Luke: You might not see it, but there are a *lot* of iffy packages on Hackage.
11:09:57 <Hodapp> Isn't Sturgeon's Law recursive? If 90% of everything is shit, then why is the remaining 10% exempt?
11:10:00 <ReinH> simpson: heh
11:10:08 <ReinH> Hodapp: that is the Susser corrolary
11:10:10 <simpson> ReinH: Hackagemind.
11:10:18 <Luke> simpson: there's a lot less good libraries in other more popular langauges
11:10:21 <geekosaur> it's not. but barely less than crap is still barely less than crap :p
11:10:26 <Hodapp> ReinH: But if the Susser corollary is 90% shit, how can I believe it?
11:10:32 <Luke> I program in C++ and Java at work so I'm in a good position to compare =)
11:10:37 <geekosaur> (well, I suppose you can think of that as recursive)
11:10:38 <ReinH> Hodapp: Sturgeon's Law is also 90% shit
11:10:38 <lintguy> Still, even if developers get expensive - having in-company-learning towards haskell will make everyone happier, both at coding and not having to mess with bugs.
11:10:43 <ReinH> unless it isn't, in which case it is
11:10:44 <simpson> Luke: The Law only says that 90% minimum is bad; it passes no judgment on the other 10%.
11:11:03 <ReinH> TLDR Sturgeon's Law is a Godel statement.
11:11:04 <chrisdone> ReinH: lpaste itself can run inside ghci happily. the restart cycle on that is fast
11:11:05 <FreeFull> Not everybody enjoys Haskell
11:11:06 <mightybyte> chrisdone: Nice.
11:11:10 <chrisdone> FreeFull: LIES
11:11:13 <FreeFull> It has it's own challenges
11:11:24 <lintguy> FreeFull: So far i need to find someone who doesn't actually like haskell.
11:11:26 <Hodapp> simpson: But if that minimum bound itself is a 90% shitty estimate, then the actual percentage of shit could be vastly different.
11:11:27 <Luke> Sturgeon's Law is an adage - not necessarily true guys
11:11:30 <srhb> lintguy: Either way, it's a fun and giving language. You'd benefit from learning it even if you're not building a company on top of it.
11:11:36 <mightybyte> I still prefer to have my markup loaded at runtime.
11:11:45 <Luke> mightybyte: same here
11:11:47 <ReinH> Luke: yes but it's more fun to pretend that it's true
11:12:21 <Luke> ReinH: empirical evidence tells me otherwise. (anecdotal evidence)
11:12:38 <aupiff> just checking, is everyone using cabal sandboxes instead of cabal-dev now?
11:12:41 <lintguy> Hm, markdown…. so much markdown!
11:12:42 <ReinH> Luke: I realize that it's not actually true
11:12:47 <FreeFull> aupiff: Seems so
11:12:51 <chrisdone> FreeFull: even john harrop and tom harper like haskell, they're just bitter about it
11:12:54 <ReinH> Luke: For instance, I'm sure that it's sometimes 89% or 91%
11:12:57 * ReinH trollolol
11:13:06 <lintguy> I like that there is so much markdown in the haskell packages :)
11:13:10 <chrisdone> er, rob harper
11:13:27 <Luke> ReinH: you're not even sure that it's not 50% ;) again I don't think it's linear
11:14:20 <chrisdone> mightybyte: one thing i'd like to try is making blaze-html BE the template "file"
11:14:40 <mightybyte> chrisdone: Runtime or compile time?
11:15:03 <lintguy> Hm, is hackage the only package manager for haskell?
11:15:11 <srhb> lintguy: It's not a package manager.
11:15:22 <srhb> lintguy: As far as I know, there's no package manager for Haskell.
11:15:23 <lintguy> sorry, code repository manager thingy
11:15:28 <Eduard_Munteanu> It's not even what others wrongly claim to be a package manager. :P
11:15:59 <chrisdone> mightybyte: both! runtime for dev, compile time for prod. i.e. i request template "showUser" and that is a function defined in a View.User module like showUser :: User -> Html. and then in dev-mode, i can cleverly runhaskell that module every page load. but in production i just compile the project as-is
11:16:00 <lintguy> the url said package and packages… so i assumed :P
11:16:03 <srhb> lintguy: It is probably the only very centralized source of Haskell packages outside of github.
11:16:09 <Hodapp> has anyone tried to make a package manager called "ups" or "fedex" or "dhl" or anything yet?
11:16:13 <Eduard_Munteanu> lintguy: Hackage is a server that hosts packages for cabal-install
11:16:20 <ReinH> is FPGuy from reddit in #haskell?
11:16:21 <chrisdone> mightybyte: not sure whether it would work, but it's something i'd like.  i *really* like blaze =)
11:16:25 <skypers> is there a way to do return () in RWST?
11:16:33 <lintguy> Eduard_Munteanu: Ok
11:16:33 <mightybyte> chrisdone: I've thought about doing something similar with heist...i.e. make a preprocessor or template haskell generator to process them at compile time.
11:16:43 <lintguy> what is cabal? someone said it was dependency hell
11:16:50 <srhb> skypers: Yes, like so?
11:16:53 <ReinH> lintguy: it's a package manager. It's about as good as most package managers.
11:16:54 <Eduard_Munteanu> skypers: sure, return (). What do you mean?
11:17:01 <skypers> a simpler way
11:17:08 <lintguy> ReinH: So it breaks now and then?
11:17:15 <Luke> mightybyte: what would that buy you?
11:17:17 <chrisdone> mightybyte: nod. that's the opposite side of the same coin. personally i tried to avoid TH… it really slows down compile times for me and breaks incremental compilation =(
11:17:19 <mightybyte> chrisdone: Frankly, I prefer to stick with HTML.  Designers are already quite savvy with it.
11:17:20 <srhb> lintguy: Constantly if you're not using sandboxes.
11:17:20 <Eduard_Munteanu> skypers: simpler than "return ()"?
11:17:25 <Luke> mightybyte: it kidna already exists except it runs at startup time
11:17:30 <skypers> Eduard_Munteanu: I actually use it in maybe
11:17:33 <lintguy> srhb: Sandboxes?
11:17:37 <skypers> maybe (return ()) (const $ modifier)
11:17:44 <Eduard_Munteanu> Oh.
11:17:45 <merijn> ReinH: Cabal is *not* a package manager
11:17:48 <lintguy> srhb: sounds complicated :-/
11:17:49 <srhb> lintguy: Right, you can have cabal sandboxes where the dependencies of your project do not infest the entire system
11:17:51 <mightybyte> Luke: Right, but it might allow people to get more type safety.
11:17:52 <merijn> ReinH: It's a dependency solver
11:17:52 <skypers> I’d like something like when
11:17:56 <ReinH> lintguy: it has the problems you get when you try to enforce version constraints in a deterministic way
11:17:56 <srhb> lintguy: It's finally not. :-)
11:18:00 <ReinH> merijn: :p
11:18:01 <merijn> ReinH: Package managers let you uninstall, cabal does not
11:18:02 <skypers> but with Maybe
11:18:06 <Eduard_Munteanu> skypers: use forM_ on that Maybe
11:18:09 <ReinH> merijn: touche
11:18:11 <Luke> mightybyte: splitting it out? Like compiling HTML templates to Blaze or something?
11:18:19 <Eduard_Munteanu> :t Data.Traversable.forM_
11:18:21 <lambdabot> Not in scope: `Data.Traversable.forM_'
11:18:21 <skypers> oh
11:18:22 <chrisdone> mightybyte: yeah, designers are why we can't have nice things
11:18:23 <skypers> fmap
11:18:25 <lintguy> Uh… no uninstalling?
11:18:27 <Eduard_Munteanu> :t Data.Foldable.forM_
11:18:28 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
11:18:36 <Eduard_Munteanu> skypers: you need this one ^
11:18:38 <srhb> lintguy: There's no package manager for Haskell, as stated. :)
11:18:50 <ReinH> lintguy: for instance, package a depends on package c between 1.0 and 2.0; package b depends on package c between 2.1 and 3.0.
11:18:54 <lintguy> srh_: Hm, ok
11:18:59 <ReinH> lintguy: there's literally nothing a dependency resolution mechanism can do about this
11:19:01 <skypers> not the one from Control.Monad?
11:19:01 <chrisdone> mightybyte: which is ironic, because designers have to learn how to use the little scripting language of the templates and "helpers", at least ime with designers and rails
11:19:02 <srhb> lintguy: There is however automatic installation of your project's dependencies in sandboxes, or without (but do use sandboxes)
11:19:05 <mightybyte> chrisdone: Well, I don't know about that.  The people who created awful things like Javascript that became standardized are significantly to blame. :)
11:19:13 <merijn> lintguy: cabal is a program that figures out which libraries you need to compile, fetches them and compiles them. It doesn't know what you do with binaries afterwards and if/when you want to uninstall stuff
11:19:15 <Eduard_Munteanu> skypers: fmap won't let you perform an action
11:19:16 <Luke> srhb: wikipedia would call cabal + hackage a package manager: http://en.wikipedia.org/wiki/Package_management_system
11:19:20 <lintguy> ReinH: ah, so it's like apt-get hold just more flexible
11:19:22 <ReinH> lintguy: unless the underlying langauge allows mutually incompatible codebases to be loaded simultaneously in an encapsulated way
11:19:25 <skypers> yeah
11:19:27 <srhb> Luke: Weird of Wikipedia.
11:19:33 <skypers> I’m used to using foldlM_
11:19:36 <skypers> -l
11:19:46 <lintguy> merijn: Ok, thanks
11:19:49 <skypers> and forM_ for list of monadic objects
11:19:51 <ReinH> lintguy: people who speak of cabal hell seem to not realize that this is just dependency resolution hell and happens everywhere ;)
11:20:03 <mightybyte> Luke: Compiling templates to some kind of types.
11:20:08 <Luke> srhb: "package manager, is a collection of software tools to automate the process of installing, upgrading, configuring, and removing software packages for a computer's operating system in a consistent manner."
11:20:17 <srhb> Luke: "removing"
11:20:18 <`^_^v> is there a generic way of doing this? data Foo = A | B | C, split [Foo] => [[instances of A], [instances of B], [instances of C]]
11:20:20 <srhb> Luke: :(
11:20:24 <lintguy> So it's like a jailed app more or less
11:20:34 <ReinH> lintguy: also let's say that package a depends on rng library c while package b depends on rng library c', which is api compatible with c
11:20:41 <Luke> mightybyte: gotcha - that would be kinda cool. Though I feel like I have more problems in the SQL area there more than the HTML area
11:20:50 <ReinH> lintguy: you'd like to be able to depend on an abstraction (the rng API) and not on a concretion (the actual libraries)
11:20:50 <mightybyte> Yeah, same here.
11:20:54 <lintguy> ReinH: You're making my head hurt :-(
11:20:58 <Luke> srhb: you can remove packages if you know what you're doing. I'd consider it a bug not by design
11:21:07 <Eduard_Munteanu> `^_^v: what do you mean "instances"?
11:21:15 <ReinH> lintguy: basically yes, cabal hell is a real place that you might spend some time in
11:21:20 <mightybyte> lintguy: That's quite common when talking to Haskell people. :)
11:21:21 <`^_^v> i just mean Foos constructed with A, B, etc
11:21:23 <srhb> Luke: Fair enough. I think if you sell cabal-install as a package manager they'll be sorely disappointed.
11:21:24 <Luke> mightybyte: weirdly I've never had what I considered a type error in Heist + HTML. It's always in the SQL side
11:21:25 <ReinH> lintguy: but it's not qualitatively worse than most other dependency management systems
11:21:29 <chrisdone> mightybyte: i mean, i watched designers use rails and the process seems to be (1) write html, (2) write helpers. the template can't be processed or edited by some ide, and the templating language is always insufficient, hence the helpers. so you (or i) end up just wishing for a real language. i made this case to a designer who agreed. but who wants to learn new things when you're a fancy pants designer?
11:21:31 <srhb> srh_: Or even cabal-install + Hackage
11:21:49 <Luke> technically it is though. just sucks at it
11:21:52 <lintguy> ReinH: No, i know, it's the common practice.
11:22:03 <ReinH> lintguy: we actually talk to Simon Peyton Jones (Haskell designer, GHC implementer) about cabal hell in our latest haskell podcast
11:22:09 <mightybyte> chrisdone: Heist goes a LONG way to making the templating language sufficient.
11:22:14 <ReinH> and about a capabilities model that might improve things in future cabal
11:22:17 <Luke> ReinH: what's your podcast?
11:22:32 <ReinH> haskellcast.com
11:22:37 <Luke> oh i didn' tknow you worked on that
11:22:40 <lintguy> *bookmarked*
11:22:46 <ReinH> Luke: yeah, with Chris Forno (jekor on the youtubes)
11:23:24 <Luke> ncie
11:23:37 <Luke> chrisdone: have you tried heist?
11:23:46 <Luke> chrisdone: i hated HTML templating until I started using it
11:23:51 * hackagebot DirectSound 0.0.0 - Partial binding to the Microsoft DirectSound API.  http://hackage.haskell.org/package/DirectSound-0.0.0 (BalazsKomuves)
11:23:53 <chrisdone> i think i saw it a while back and thought just another templating language
11:24:11 <Luke> its my favorite part of snap
11:24:19 <chrisdone> i'm sure it's very good but i've no personal interest in templating languages
11:24:32 <Luke> I only tried using blaze for a short period but I'd say it was hell compared to heist for larger more involved templates
11:24:40 <lintguy> Ok, thanks all for the conversations, it's been more giving hanging here than googling
11:24:46 <mightybyte> Neither did I until Haskell-generated markup became miserable for me.
11:24:46 <lintguy> need to sleep now
11:24:48 <skypers> I’ll have to get into Foldable and Traversable
11:24:53 <skypers> sounds great
11:25:04 <skypers> flip forM_ is just nice
11:25:04 <Luke> afk
11:25:12 <johnw> skypers: flip forM_ == mapM_
11:25:23 <skypers> hhmmm
11:25:27 <skypers> oh yeah
11:25:32 <skypers> you’re right :D
11:25:41 <skypers> so my fmap sooner was wrong
11:25:47 <skypers> but not totally wrong :)
11:25:57 <skypers> I was looking for the right function
11:26:08 <johnw> also, mapM_ == traverse_, if you prefer that name
11:26:23 <chrisdone> mightybyte: generated markup is problematic?
11:26:42 <skypers> johnw: hm
11:26:44 <skypers> no
11:26:56 <skypers> it doesn’t make so much sense for me for Maybe
11:27:03 <koellekarl> e3 = y[y:=e3][x:=e2[y:=e3]] how can this be? isn't y[y:=zx][x=yz[y:=zx]] = zzxz a counter example? (x[x:=y] being substitution in the untyped lamda calculus)
11:27:05 <skypers> “traversing” Maybe sounds great
11:27:09 <skypers> but hm
11:27:13 <skypers> odd too
11:27:48 <johnw> the language of traversals helps with grokking large parts of lens too
11:27:50 <mightybyte> chrisdone: Yeah.  Luke seems to have had a similar experience.
11:28:57 <sx> hi, does anyone know under which cicumstances i can get 'Multiple declarations of `...'' ? because i have the same number of arguments and every possible case used in the equations
11:29:35 <johnw> Luke: is there a good tutorial on how to use heist?  the snap website just directs me to the Haddocks, which seem to have no examples
11:30:03 <pqmodn> sx: i think a declaration means a type declaration, not a function definition. you probably have "foo :: ..." twice
11:30:25 <chrisdone> mightybyte: problematic how?
11:31:01 <ReinH> johnw: oh hi
11:31:05 <chrisdone> oh hai johnw
11:31:10 <johnw> hey there!
11:31:13 <ReinH> johnw: I was told I should talk to you about learning Agda
11:31:21 <johnw> ReinH: sure thing, wanna talk in #agda?
11:31:25 <ReinH> johnw: sure!
11:31:35 <pqmodn> are the "warning: missing terminating ' character" messages i'm now getting in the latest Mac OS X version due to changes in the C preprocessor?
11:31:46 <jjauhien> Dear all, how could I build full list of the following data type:
11:31:46 <jjauhien>     data Rank = Numeric Integer | Jack | Queen | King | Ace
11:31:46 <jjauhien> here Numeric Integer could be from Numeric 2 to Numeric 10.
11:31:58 <sx> pqmodn: sadly it isn't the case, also it references the function *definitions" with the exact line numbers (i have exactly one declaration)
11:32:21 <chrisdone> jjauhien: use an Enum instance
11:32:25 <pqmodn> sx: hmm, try uploading your code to lpaste so someone can take a look
11:32:27 <chrisdone> :t enumFrom minBound
11:32:28 <lambdabot> (Bounded a, Enum a) => [a]
11:32:39 <chrisdone> > enumFrom minBound :: [Int]
11:32:41 <lambdabot>   [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-2...
11:32:45 <chrisdone> aka [minBound..]
11:32:53 <chrisdone> > enumFrom minBound :: [Char]
11:32:55 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
11:33:42 <skypers> is there a way to export a module hiding some symbols?
11:33:44 <skypers> like
11:33:56 <skypers> module Foo ( module X hiding (Prelude.mapM_)
11:33:56 <skypers> ?
11:33:57 <chrisdone> jjauhien: oh, for the Numeric you probably need to write a custom instance of Enum
11:33:58 <skypers> + )
11:34:07 <joelteon> skypers: you just import X hiding Prelude.mapM_
11:34:12 <joelteon> and export X
11:34:27 <skypers> huh
11:34:31 <skypers> in which module?
11:34:34 <skypers> in Foo?
11:34:39 <joelteon> yes
11:34:41 <joelteon> i think.
11:34:41 <skypers> ok
11:34:42 <jjauhien> chrisdone: thanks
11:34:44 <skypers> nice
11:35:03 <skypers> nope
11:35:08 <skypers> it doesn’t work
11:35:18 <skypers> hides seem not to be exported
11:35:27 <skypers> they seem to be local
11:35:27 <joelteon> yeah, I don't think you can do it then
11:35:31 <jjauhien> chrisdone: but could you give some hint on custom istantiation?
11:35:38 <geekosaur> could also make a wrapper module which imports the target module and exports only selected names
11:35:48 <sx> pqmodn: the code is quite big and entangled, and i also used it for my final work in my bachelors degree, so i'm a bit scared to upload it
11:35:53 <skypers> .
11:35:55 <skypers> sure I can
11:36:01 <skypers> I can simply export mapM_
11:36:06 <skypers> from Foldable
11:36:10 <skypers> and not the Prelude one
11:36:47 <chrisdone> jjauhien: instance Enum Rank where succ Jack = Queen; succ Queen = King; succ (Numeric i) | i == 10 = Jack | otherwise = Numeric (succ i)
11:36:52 <chrisdone> jjauhien: something like that
11:37:10 <jjauhien> chrisdone: thanks a lot
11:37:55 <chrisdone> jjauhien: the class is well-documented, should tell you all you need to implement an instance: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Enum
11:38:37 <lpaste> srhb pasted “Commented line sould only close slave in parent process?” at http://lpaste.net/95203
11:38:42 <aupiff> I'm having issues upgrading cabal to 1.18
11:38:48 <chrisdone> jjauhien: but feel free to paste your code and ask if you get stuck
11:38:54 <srhb> ^-- can anyone figure out why closing the slave Fd in the parent process causes my program to fail?
11:39:20 <aupiff> I do cabal install cabal-install, it says it installed 1.18, but I still get 1.16 whenever I invoke cabal
11:39:38 <srhb> aupiff: Is your local cabal bin dir before the global one in your PATH?
11:40:20 <jjauhien> chrisdone: I will, I will ;) I just want to try first myself
11:40:45 <chrisdone> jjauhien: that's the spirit!
11:40:56 <jjauhien> :)
11:40:56 <Luke> johnw: there's some other stuff like here: https://www.fpcomplete.com/user/danidiaz/compiled-heist-insight-with-no-snap-in-sight
11:41:06 <Luke> johnw: but the snap website is a really good place to start
11:41:16 <aupiff> srhb: wow, I'm silly, of course that was it
11:41:20 <srhb> aupiff: :)
11:41:26 <aupiff> srhb: too used to blaming cabal for everything
11:41:41 <srhb> Harsh!
11:43:35 <Kaidelong> one thing that is starting to concern me is if dependencies on mingw is going to interfere with deploying my program as a binary
11:44:04 <Kaidelong> because these wx samples only run when ran via the msys command line
11:44:35 <Kaidelong> but it seems like you can't install like a third of existing packages without something like cygwin
11:45:54 <srhb> Kaidelong: Isn't that just a question of statically linking?
11:46:00 <Kaidelong> I'd hope so
11:46:05 <srhb> Kaidelong: Try?
11:46:18 <Kaidelong> I am still struggling with basic deployment stuff
11:46:31 <Kaidelong> getting cabal to build wx
11:46:40 <Liodan> Could someone give me an example why Haskell has the property referential transparency?
11:46:43 <Kaidelong> err not for my application
11:46:50 <koellekarl> anyone knows a chennel i can ask about lambda calculus?
11:46:53 <dgpratt> I recently repaved this machine and one item still to be installed is the Haskell Platform
11:47:03 <koellekarl> *channel, where
11:47:18 <srhb> Liodan: Because you can substitute in the definition of a value wherever it appears
11:47:29 <dgpratt> now I see that 2013.4 is due today -- what are the chances it will be made available this week?
11:47:41 <Luke> ReinH: this podcast is great
11:48:21 <Liodan> srhb: Hmm, could you give an example?
11:48:27 <Kaidelong> Liodan: it essentially means that you can't, within the confines of the haskell programming language, distinguish reference types from value types
11:48:44 <Kaidelong> at least at the level of declarative semantics
11:48:51 <chrisdone> Luke: yay haskell podcast <3
11:48:53 <srhb> Liodan: http://www.haskell.org/haskellwiki/Referential_transparency
11:49:24 <ReinH> Luke: <3
11:49:27 <Liodan> srhb: Thanks! I will read that
11:49:39 <chrisdone> srhb: http://stackoverflow.com/a/9859966/89574
11:49:44 <Kaidelong> you can notice a distinction in the operation of the program, which is why referential transparency is useful for automatic optimization
11:50:31 <ReinH> Liodan: in practice, it means that if you can show that x = y then you can substitute x whenever you see y. This seems trivial, but it becomes less so as y becomes more complex.
11:51:17 <Kaidelong> in theory a clever compiler could choose when to do passing by reference and passing by value based on what would work best, I don't know how much of this GHC actually does, I think it mostly just defaults to passing stuff by reference
11:51:27 <ReinH> This property is used to great effect in the equational reasoning style used by, e.g., Richard Bird's _Pearls of Functional Algorithm Design_
11:51:40 <ReinH> which is an awesome book
11:52:06 <ReinH> Liodan: you can find a nice example here as well http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
11:52:25 <Luke> chrisdone: I've been sitting on schnippet (my haskell emacs snippets) and they're extremely stable and no outstanding requests. Where do you prefer I stash those in haskell-mode and how do we tie them in?
11:52:44 <Liodan> ReinH: Aha nice, thanks
11:53:21 <ReinH> What's the term for the isomorphism `f . f = id' ? (transpose being an example)
11:53:32 <Dodek> involution
11:53:35 <ocharles> ReinH: involution
11:53:36 <ocharles> doh
11:53:37 <ReinH> thanks
11:54:38 <cpa> hi there
11:54:47 <ReinH> Liodan: the sudoku solution makes use of a number of such involutions
11:56:20 <ReinH> for instance it uses the property boxes . boxes = id to provide what is basically boxwise f = boxes . f . boxes, which lets you traverse the boxes of a sudoku
11:56:56 <ReinH> you can only do this if you can actually know that boxes . boxes = id in all cases, which requires referential transparency
12:07:07 <jjauhien> chrisdone: Enum requires definitions of fromEnum and toEnum. The following works fine:
12:07:07 <jjauhien> instance Enum Rank where
12:07:07 <jjauhien>     fromEnum (Numeric i) = fromIntegral i
12:07:07 <jjauhien>     fromEnum Jack        = 11
12:07:07 <jjauhien>     fromEnum Queen       = 12
12:07:08 <jjauhien>     fromEnum King        = 13
12:07:10 <jjauhien>     fromEnum Ace         = 14
12:07:12 <jjauhien>     toEnum 14 = Ace
12:07:14 <jjauhien>     toEnum 13 = King
12:07:16 <jjauhien>     toEnum 12 = Queen
12:07:20 <jjauhien>     toEnum 11 = Jack
12:07:22 <jjauhien>     toEnum i | 1 < i && i < 11
12:07:24 <jjauhien>               = Numeric (fromIntegral i)
12:07:26 <jjauhien> Any possible improvements?
12:07:30 <Luke> http://lpaste.net please
12:07:33 <mauke> yeah, don't paste into irc
12:07:44 <jjauhien> sorry, newbie :)
12:07:56 <tac> Suggested improvement: Aces low.
12:08:23 <tac> If it works, it looks right to me.
12:08:35 <jjauhien> tac: sorry, what is that?
12:09:15 <geekosaur> depends on the game, actually
12:09:28 <tac> I think that the specification actually says Enum should enumerate items starting from 0
12:09:41 <tac> But there have been worse crimes against the specification than that.
12:10:02 <geekosaur> ...some of them *in* the spec :)
12:10:42 <chrisdone> jjauhien: looks like a good start
12:11:20 <jjauhien> well, Okay, not a problem to fix from 0. As for Aces position, it's about BlackJack but particular order is not important for me right now
12:12:43 <chrisdone> jjauhien: so now [toEnum 1..] (or 0 after fixing that) should give you 14 items
12:13:12 <jjauhien> chrisdone: well, I prefer [Numeric 2..]
12:13:12 <chrisdone> and if you implement Bounded you can use minBound and maxBound
12:13:38 <cschneid> Luke: where are your snippets at? Github somehwere?
12:13:49 <chrisdone> where they be at?
12:13:59 <chrisdone> jjauhien: as you prefer =)
12:14:04 <jjauhien> :)
12:14:34 <johnw> Luke: cool, thanks
12:14:57 <chrisdone> when i first started with haskell this was the only results i got for docs search: http://zvon.org/other/haskell/Outputprelude/Enum_c.html
12:15:04 <chrisdone> but *who8 are these zvon peopple?
12:19:37 <ReinH> jjauhien: in any game where Ace is counted as high and low, the ranks do not form a well behaved Enum
12:20:53 <jjauhien> ReinH: agree, but I am more concerned on list comprehensions, etc. - so I need at least some order and it does not really matter for me which particular order
12:21:01 <bz> given a function that was imported from among a long long list of imports, how do i identify the module that exported it?
12:21:14 <ReinH> jjauhien: just be careful that having an Enum doesn't lead you to assume that enum properties hold
12:21:18 <ReinH> for instance straight detection
12:21:34 <jjauhien> noted
12:22:26 <ReinH> Oh I just realized something about straight detection
12:22:39 <Cale> bz: You could load the module in ghci and use :info theFunction
12:22:45 <ReinH> you should be able to include ALow and AHigh in your enum and then map a hand onto the card choices for each card
12:23:04 <ReinH> so all cards other than ace are just the singleton list and ace is [ALow, AHigh]
12:23:15 <ReinH> then do a cartesian product and see if any of those lists are in series
12:23:25 <fizruk_> is it okay for a function to accept (t Identity) instead of m to be able to hoist that Identity with another monad later?
12:23:31 <ReinH> I was struggling with representing this earlier and didn't have a good solution
12:23:37 <ReinH> also something something semilattice probably
12:23:53 <bz> Cale: any other options?
12:24:04 <rasfar> bz: try hoogle <fname>
12:24:20 <bz> rasfar: the module might not be in hoogle
12:24:35 <rasfar> we can try... how do you use hoogle here again?
12:24:37 <Cale> bz: rgrep maybe?
12:24:58 <bz> in python, for instance, it'd be easy to see because non-qualified imports are of the form "from <module name> import <function>"
12:25:18 <fizruk_> bz: import Module (func)
12:25:22 <Cale> bz: You can explicitly name what's being imported if you want to, but if you don't, everything is imported.
12:25:31 <bz> Cale: yes, i knwo that
12:25:44 <rasfar> yeah, in my own code I try to be explicit about my imports -- this might not be bz's code...
12:25:56 <Cale> (which is usually convenient, because it's usually obvious which module has what stuff in it)
12:25:57 <bz> the default "import Module", which is rather common, is equivalent to python's star improts
12:26:03 <rasfar> i sometimes resort to searching the haddock index page
12:26:08 <bz> rasfar: it's not my code that i'm reading, sadly
12:26:17 <rasfar> let's try hoogle
12:26:19 <Cale> Why doesn't ghci work?
12:26:21 <rasfar> @hoogle mapM
12:26:22 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
12:26:22 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
12:26:22 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:27:33 <bz> Cale: it might, but i was asking if there was any haskell equivalent to "from...import" tha twould let me get straight to the point
12:27:58 <Cale> bz: Oh, well, yeah
12:28:17 <Cale> bz: import ModuleName (identifier1, identifier2, ...)
12:28:19 <bz> i'm actually looking at https://github.com/glguy/s5s/blob/master/Main.hs and wondering where withSocksDo comes from
12:28:38 <bz> more precisely what its definition is
12:28:54 <Cale> http://hackage.haskell.org/package/network-2.4.2.0/docs/Network.html#v:withSocketsDo
12:29:37 <Cale> It initialises networking on Windows and is equivalent to the identity function on other platforms.
12:29:52 <bz> what procedure did you use to find it?
12:29:58 <Cale> Already knowing about it
12:30:05 <bz> meh
12:30:17 <bz> this isn't helpful at all
12:30:26 <Cale> Well, to be specific, I went and searched on Hackage for the network package
12:30:55 <bz> so hoogle isn't linked up to search through hackage?
12:31:02 <bz> because it doesn't show up on hoogle
12:31:04 <Cale> googling "site:hackage.haskell.org withSocketsDo" works
12:31:41 <Cale> @hoogle withSocketsDo
12:31:42 <lambdabot> Network.Socket.Internal withSocketsDo :: IO a -> IO a
12:31:42 <lambdabot> Network.Socket withSocketsDo :: IO a -> IO a
12:31:42 <lambdabot> Network withSocketsDo :: IO a -> IO a
12:31:58 <Cale> ^^ yes it does
12:32:23 <Cale> http://www.haskell.org/hoogle/?hoogle=withSocketsDo -- also shows up here
12:32:44 <bz> http://www.haskell.org/hoogle/?hoogle=withsocksdo
12:32:49 <geekosaur> @where hayoo
12:32:49 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
12:32:50 <bz> don't tell me it's case sensitive
12:32:53 <bz> christ
12:32:56 <Cale> Sockets, not socks
12:33:20 <Cale> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:withSocketsDo -- :)
12:33:23 <johnw> withSocksDo putOnShoes
12:33:34 <iLike> Hayoo indexes more of Hackage, iirc
12:33:42 <bz> ugh
12:33:43 <johnw> fpcomplete.com/hoogle indexes all of Stackage
12:33:52 <geekosaur> hoogle also indexes hackage but you need to specify the package I think
12:34:01 <Clint> which is annoying
12:34:03 <bz> sorry to rant, but it really really irks me when i see unqualified import-alls
12:34:05 <ion> Yes. Runtime support for foot clothing is implicit, you only need with…Do for sockets.
12:34:05 <geekosaur> which makes it kinda useless when the package is what you don't know...
12:34:15 <johnw> i built a local hoogle which indexed all of Hackage, and it wasn't as useful as you might think
12:34:21 <johnw> too many useless results
12:34:43 <FireFly> Now I kinda want to play around with that..
12:34:50 <Cale> bz: Personally, I really dislike explicit module qualification showing up everywhere, because it makes the code much harder to read in a lot of cases.
12:34:56 <iLike> johnw, still have the source around..?
12:35:07 <johnw> iLike: source around for what?
12:35:07 <FireFly> johnw: I wonder what the longest operator identifier you could find there is
12:35:24 <ion> One would think the RTS could just call the magic thing to initialize sockets support on Windows™ always.
12:35:30 <bz> Cale: how? it doesn't get any harder than not knowing where withSocketsDo comes from unless you've got a working internet connection
12:35:38 <iLike> The local hoogle which indexed all of Hackage?
12:35:49 <johnw> iLike: you can build it yourself: hoogle data -r -l all
12:36:04 <bz> qualified imports by default
12:36:09 <iLike> Now I feel stupid.
12:36:12 <iLike> Thanks :P
12:36:23 <Cale> bz: If you have "documentation: True" in your cabal config, then you also have a global index of all the package documentation installed on your machine
12:36:25 <bz> or just do it the way python does
12:36:42 <Cale> for example, I can go to file:///home/cale/.cabal/share/doc/doc-index-W.html
12:36:46 <bz> Cale: you're asssuming that i have every prereq installed
12:36:47 <Cale> and find withSocketsDo there
12:36:56 <Cale> Well, why wouldn't you?
12:37:08 <bz> because i'm just reading the code?
12:37:14 <Cale> I guess
12:38:02 <Cale> But you'll almost certainly have the network package installed, so that doesn't work in this case ;)
12:38:30 <bz> $ ghc-pkg list | grep -i network -> nada
12:39:53 <geekosaur> what, are you using a bare ghc install? that's kinda useless
12:40:27 <Cale> Yeah, I was going to ask if it's a fresh install of GHC. cabal-install needs network to build, so it's pretty unlikely that you wouldn't have it
12:43:30 <bz> no
12:44:02 <timthelion> Cale: well if you install through debian, does cabal-install actually have to be built?
12:44:35 <bz> cabal'ss a separate component
12:45:39 <moops1> can i ask lambdabot if it knows of a function with a certain type
12:45:53 <chrisdone> sure, use @hoogle
12:46:00 <rasfar> :)
12:46:57 <moops1> that works, thanks
12:47:16 <Clint> timthelion: in debian can you just install the -doc packages
12:54:08 <rasfar> i'm trying to modify a source package installed via cabal
12:54:30 <rasfar> aside from using ghc -i to specify the local build dir, how do I hide the actual installed package?
12:55:02 <rasfar> (i'm just testing the example in the hint package, and trying to add some tracing)
12:56:02 <rasfar> sorry never mind; must have mistyped "hide" when I was searching the ghc man page
12:56:16 <rck> rasfar: maybe cabal sandboxes will help too?
12:56:41 <rck> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
12:57:20 <rasfar> rck, yeah I was just reading about those on advice from mzero a couple days ago. Thank you.
12:58:15 <rasfar> rck, is it your blog? because my hostname is kadath, a bit of a coincidence!
12:58:38 <rck> rasfar: nope
12:58:44 <rasfar> we also just got seriously dumped on with snow here last night ... but this isn't -blah, I'll desist
12:59:53 <shapr> Whoa, that's a lot of people.
12:59:54 <rasfar> thanks for the link in any case, i was only referring the GHC Users Guide
13:00:18 <rasfar> the urge to say hi shapr is irresistable -- hi!
13:00:23 <rck> anytime. sandboxes help keep my sanity.
13:00:29 <shapr> howdy rasfar! long time no see!
13:00:39 <shapr> How's code treating you?
13:01:22 <bz> http://hackage.haskell.org/package/network-2.4.2.0/docs/Network-Socket.html#v:aNY_PORT <- did the author forget to turn off his caps locks?
13:01:30 <rasfar> what can i say, it's the same old thing: the sublime beauty of Haskell attracts me, then I run into performance hitches, but it's definitely worth the stuggle. And you, are you still a registered student?
13:01:45 <alkabetz> bz: No, it’s designed to mimic a C API that uses all caps for enums
13:02:04 <alkabetz> But 'aNY_PORT' is not a type, so it can’t be 'ANY_PORT'
13:03:21 <startling> simpson: dang. I was starting to write a Haskell toolchain and maybe a small lc compiler for the f18a.
13:03:36 * rasfar goes back to work for a spell
13:03:41 <shapr> rasfar: if all goes well, I graduate this term!
13:03:55 <simpson> startling: Hm. I don't know how I'd feel about that. The chipset is so inherently parallel.
13:04:22 <startling> simpson: sure. LC is inherently parallel too. :)
13:04:23 <shapr> also, I think my divorce papers will be final this week, so I dunno what I'll do after graduation... get a job writing Haskell maybe?
13:04:41 <startling> (I mean a toolchain /in/ Haskell, not one for Haskell)
13:04:56 <merijn> shapr: Move to Europe and make the EU haskell community livelier! :p
13:05:13 <timthelion> merijn: is it suffering?
13:05:26 <merijn> I hear Amsterdam has really cool people ;)
13:05:52 <merijn> timthelion: Define sufferig, it's not as cool as NY/sillicon valley, unless people are conspiring to keep me out :p
13:06:03 <rasfar> ah i see ... so the worst of that is over, didn't know, congrats on coming through. i always think of you as residing in Scandinavia but then I remember it's, er, Central USA someplace.
13:06:06 <timthelion> merijn: I think the main problem, is that Americans are just way more social than Europeans.  They spend all their time at meetups, but when I look at hackage, I'm shocked at how many Czechs have contributed code...
13:06:11 <bz> alkabetz: because the spec mandates lowercae first letters for non ADTs?
13:06:15 <bz> god
13:06:28 <bz> for such a beautiful language, i don't see how things like this has fallen through the cracks
13:07:01 <merijn> bz: What do you mean by that? It's a brilliant decision
13:07:01 <rasfar> bz, i do agree that sometimes leads to ugly identifiers
13:07:07 <rasfar> ohoh...
13:07:35 <rasfar> i'd sooner see fromIntegral dealt with though!
13:07:36 <merijn> bz: Consider the alternative of never knowing whether something was a function or a data constructor
13:07:49 <bz> merijn: check its definition then
13:07:53 <merijn> bz: "just 3" is this a function? A value? Who knows
13:08:08 <merijn> bz: The fact that I don't *have* to check the definition saves me hours
13:08:19 <bz> true
13:08:29 <aupiff> anyone here use yi? working with the latest build from git and running into a few problems.
13:08:33 <timthelion> merijn: but you can always do "let just = Just in just 3" then you Still don't know :P
13:08:57 <timthelion> aupiff: I've worked from git and run into more than a few problems, but never used it...
13:09:04 <bz> not like you could be checking the definition easily with 13 unqualified imports
13:09:31 <timthelion> bz: I use PackageImports and always list which functions I'm importing...
13:09:31 <rasfar> anyhow, shapr in case you missed my response it's a page or so up, I forgot to put your nick in. good luck with your final term (like you need luck!)
13:10:07 <bz> timthelion: that's great, but irrelevant to the fact that the default is unqualified
13:10:27 <timthelion> bz: in Elm you have to type open, otherwise it's fully qualified.
13:10:48 <timthelion> bz: import open Window... import Window would mean you have to type Window.height...
13:11:20 <bz> timthelion: hah, i smell that you're trying to sell me  :p
13:12:08 <timthelion> bz: I'm not selling anything.  For one thing, Elm is free.  For another thing, I hate Elm. For a third thing, I'm presenting at an Elm conf in Budapešť on Saturday :D
13:12:35 <srhb> timthelion: Well... That's gonna be a blast :P
13:12:38 <rck> bz: try ghc-mod if you use vim or emacs. combined with something like YouCompleteMe or Neocomplete you can easily look that stuff up, and see completions as you type.
13:12:44 <bz> timthelion: best of luck
13:13:12 <bz> so this kind of thing is hardcoded itno the spec; would it be too radical to modify the spec, then?
13:13:26 <bz> in python we have pep
13:13:30 <bz> does haskel have hep
13:13:43 <timthelion> Yeah, I wrote a visual programming language that compiles to Elm, in Elm.  And it's slow as %#@$.  So have to present it so I can say it's presented and I can stop worrying about the dead code.
13:19:07 * hackagebot nsis 0.2.3 - DSL for producing Windows Installer using NSIS.  http://hackage.haskell.org/package/nsis-0.2.3 (NeilMitchell)
13:21:26 <rasfar> i'm still having trouble hacking the local hint source. did the --hide-package hint, which worked, but what path do I give to -i? or should I use -l? (I've got -i -l and -L happening)
13:22:06 <rasfar> trying to build in ~/.cabal/packages/hackage.haskell.org/hint/0.3.3.7/hint-0.3.3.7
13:22:32 <rasfar> cabal build is fine, everything is in the above slash dist
13:22:57 <rasfar> but it tells me Could not find module `Language.Haskell.Interpreter'
13:23:12 <chrisdotcode> is there something like "drop :: (MonadIO m) => m a -> IO a", like the opposite of lift?
13:23:29 <rasfar> (which is part of the hidden package hint)
13:23:44 <simpson> chrisdotcode: Does your transformer have a run function or unwrapper of some sort?
13:23:52 <simpson> It wouldn't be part of MonadIO, no.
13:23:53 <rasfar> dist/build/Language is there
13:24:37 <rasfar> alright sandbox then...
13:24:45 <chrisdotcode> simpson: I'm working with yesod, trying to turn a Handler Html type into an IO type. the guys on #yesod are helpful, but never there, so I thought there might be a more general solution
13:27:03 <rck> liftIO doesn't do what you want?
13:29:36 <simpson> I think that chrisdotcode wants to somehow execute actions in Handler in IO instead. I don't know what the goal is, though.
13:30:18 <chrisdotcode> simpson: yeah, that's it. Im' trying to run a startup script which compiles my blogposts to html, and then inserts metadata into the database
13:31:02 <Luke> chrisdone: around?
13:31:24 <srhb> Ouch.
13:31:57 <chrisblake> chrisdone: (sorry about that)
13:32:44 <rasfar> my cabal actually has no sandbox command, despite being up-to-date -- must I actually install from git for that?
13:34:10 <sm> rasfar: cabal --version should say 1.18
13:34:33 <rck> cabal update && cabal install cabal-install
13:34:59 <rasfar> 1.16 here -- wonder why
13:35:11 <rasfar> just did
13:35:33 <alkabetz> Is ~/.cabal/bin in your PATH?
13:36:01 <rasfar> this is haskell-platform-2013.2.0.0
13:36:36 <rasfar> ah: I have the platform installed in /usr/local/bin and it seems to come before ~/.cabal/bin in my path; thanks for the tip!
13:36:43 <alkabetz> You’re welcome!
13:36:46 <timthelion> rasfar: did you cabal update before installing again?
13:36:56 <timthelion> oh
13:36:58 <timthelion> I see
13:37:18 <rasfar> well, I cabal updated yesterday. it seems to take a long time, and I'm on a cafe connection, so I don't do it all the time.
13:37:32 <rasfar> thanks timthelion and alkabetz
13:37:48 <identity> Does anyone recognize a vim plugin that does the whole interrupt and "press enter key to continue" when cursor is over a module that isn't in use?
13:38:15 <identity> because whatever plugin that is, it's only acting up in one of my files and it is immensely annoying
13:38:33 <Shammah> Hey, I've been trying to learn Haskell, which is all going fine so far, but I cannot find a good list of exercises. Would anybody know a good list of exercises apart from re-implementing some functions and Project Euler?
13:39:08 <schell> what about the 99 problems?
13:39:21 <schell> they're all pure problems
13:39:35 <Shammah> Do they cover pretty much 'everything'?
13:39:35 <johnw> Shammah: find a problem you want solved personally, and try to solve it
13:39:39 <moto9> what do you guys think about splitting imports into two groups: the qualified imports and the un-qualified imports?
13:39:42 <rck> identity: maybe try :autocmd CursorMoved and see what it shows
13:40:01 <Shammah> johnw, I have no personal problems, and when I do it's often solvable in a few list transformations
13:40:04 <Shammah> Too trivial :(
13:40:16 <alkabetz> Write a Serpent implementation!
13:40:18 <identity> rck: hmm, thanks. let me take a look
13:40:24 <aupiff> I'm working with the latest yi build in a sandbox, and I building my yi.hs config breaks (can't find yi modules) because I think it's using my user cabal instead of the sandboxed cabal packages
13:40:25 <rck> Shammah: try to implement something real. just take an idea you have and try to make it happen.
13:40:34 <alkabetz> Shammah: We’ve got AES and Twofish on Cabal, but not Serpent :)
13:40:35 <schell> Shammah: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
13:40:37 * elliott suggests finding life goals before programming languages
13:40:40 <moops1> Shammah: might want to take a look at https://github.com/NICTA/course ?
13:40:46 <merijn> @where exercises
13:40:46 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
13:40:49 <schell> i think some of those are previously unsolved?
13:41:08 <identity> two different files show same autocmd definitions, but only one of them is being really weird.
13:41:22 <ownclo> Good day! I'm diving into the source code of Pandoc, and I see the 'Pandoc' type is used everywhere, but I cannot find the definition of that type (neither manually with hasktags nor with 'cabal haddock'). Do you now how to find such 'global' types?
13:41:25 <merijn> schell: heh, H99 are all trivial beginner examples on lists and the like, based on a lisp book
13:41:50 <merijn> ownclo: That's usually the time I resort to grep :)
13:41:58 <zerowaitstate> we've got 99 problems, and a glitch ain't one
13:42:00 <alkabetz> ownclo: Hayoo
13:42:00 <timthelion> Shammah: try implementing a .docx editor :D
13:42:08 <merijn> ownclo: Although in this case I believe the pandoc metadata types including pandoc are in an external library
13:42:17 <iLike> ownclo, I don't know whether it'll work but :i in GHCI gives info like that
13:42:23 <merijn> ownclo: http://hackage.haskell.org/package/pandoc-types
13:42:26 <schell> merijn: oh, ha, i guess i'm thinking of something else, or an old version
13:42:26 <timthelion> Shammah: with GTK or one of those newfangled web interfaces
13:42:45 <schell> has anyone successfully built the newest ghc HEAD on os x lately?
13:42:46 <Shammah> That's kind of the problems with all these suggestions, it's either very trivial or basic, or that advanced I have no idea where to start
13:42:51 <Shammah> It's like I'm stuck in the middle :/
13:42:54 <merijn> ownclo: And yes, as iLike points out, ":i" usually reports where a type/value comes from in ghci
13:43:14 <merijn> schell: Yes (well, not me specifically), I assume you have xcode5 if you're running into issues?
13:43:39 <bz> alkabetz: why serpent? didn't it lose to rijndael in aes?
13:43:54 <alkabetz> bz: Yes, but it’s still an excellent cipher
13:43:56 <ownclo> merijn: iLike: thank you a lot! I didn't now about :i, that's sooo useful
13:43:57 <schell> merijn: yes
13:44:17 <alkabetz> bz: The primary reason it lost, AIUI, is because it wasn’t fast enough
13:44:17 <schell> merijn: this was my last attempt -> http://lpaste.net/95206
13:44:39 <merijn> schell: As of xcode5 Apple no longer ships GCC, breaking GHC build. It's a known issue, people are working on a fix, in the meantime there is a workaround
13:44:49 <merijn> schell: Lemme see if I can locate it
13:45:17 <merijn> schell: See https://gist.github.com/mzero/7245290
13:45:31 <merijn> schell: Oh, you already commented on it :)
13:45:36 <schell> yeah - i think that's ... haha
13:45:43 <merijn> schell: In that case, try #ghc for better expertise :)
13:46:28 <schell> merijn: thanks
13:46:37 <timthelion> Shammah: well, you'd be surprised how simple a simple .docx editor can be to write.  You need a state variable which holds an abstract document tree, a cursorView variable which holds information about where in the document the user is.  Then you need a function that takes the state and the cursor view variable and draws it to the screen.  Then all new commands will either modify the state or the cursor view, and then redraw.  You can do it f
13:46:45 <schell> seems mzero's script doesn't want to work when building ghc
13:46:51 <schell> but in other cases it works
13:47:07 <schell> just not the one i need (installing GLFW-b)
13:47:20 <merijn> schell: I'm not sure about all the details, but #ghc is *much* lower traffic, so smaller chance knowledgeable people won't see it through the noise
13:47:34 <schell> though apparently ghc HEAD will build GLFW-b, but i can't build ghc HEAD...
13:47:35 * Shammah shrugs
13:48:08 <timthelion> Shammah: if .docx sounds scary, try markdown...
13:48:40 <rasfar> i was able to build hint in a sandbox, excellent! however i still have the same problem -- how to then build the example using the sandboxed modules/libraries
13:49:01 <Shammah> I'll have a look
13:49:03 <Shammah> thanks
13:51:44 <rasfar> -L~/.cabal/packages/hackage.haskell.org/hint/0.3.3.7/hint-0.3.3.7/.cabal-sandbox/lib/i386-linux-ghc-7.6.3 ??
13:53:00 <rasfar> it is correct the --hide-package hint in this case, right?
13:53:30 <rasfar> any hints? ;)
13:54:39 <identity> http://www.imgur.com/1meGVke <- does anyone recognize this vim plugin? because it's some nasty asshole that's interfering with my work
13:55:00 <identity> for only a single file, all other files are processed properly
13:55:25 <hpc> identity: that's from :! ghc % -- i take it?
13:55:31 <hpc> (or something similar)
13:56:23 <identity> hpc: that could be, I don't really know. It *just* started appearing(i have syntastic + ghcmod to do type check and hlint on bufenter), and I have no idea what's doing it
13:56:26 <identity> or why all of a sudden
13:56:46 <hpc> oh, eek
13:57:44 <hpc> identity: see if there's a vim command to list active plugins
13:57:49 <hpc> and try systematically disabling them
13:58:03 <hpc> also try restarting vim, in case some mysterious key combo is what turned it on
13:59:29 <identity> hpc: duh -- that does indeed seem to have been the case
13:59:31 <identity> thanks
13:59:34 <identity> @ mystery key combo
13:59:39 <identity> restarted it and it went away
14:02:06 <rasfar> http://lpaste.net/95208 as it's hard to describe the situation concisely
14:02:16 <skypers> seriously
14:02:36 <skypers> monad transformers are the best thing programming languages could ever have <3
14:03:03 <skypers> it helps me to make things SO clear and elegant
14:04:22 <rasfar> skypers: paste an example?
14:05:09 <skypers> rasfar: I can’t, it’s a big WIP
14:05:10 <skypers> but hm
14:05:49 <skypers> I use some monads of my own creation to automatically push and pop stacks
14:05:56 <skypers> it’s so fucking gorgeous :)
14:06:10 <skypers> I also loooove RWST
14:06:16 <skypers> being able to write
14:06:27 <rasfar> :) your enthusiasm is contagious; now watch your language...
14:06:38 <skypers> either (tell . mkLog "hihi") return e
14:06:41 <skypers> just, woah.
14:07:02 <ion> rasfar: Is that an official channel rule?
14:07:05 <skypers> ahah rasfar, yeah, sorry for that
14:07:12 <bz> @src loop
14:07:13 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
14:07:26 <elliott> you're allowed to say fuck in #haskell
14:07:27 <rasfar> oh i don't know! isn't it?
14:07:39 <elliott> cursing *at* people is quite another thing
14:07:41 <rasfar> okay, good to know
14:07:45 <scshunt> elliott: fuck that
14:08:04 <skypers> actually
14:08:14 <skypers> there’s a huge problem with Haskell’s ideas
14:08:24 <rasfar> lol
14:08:26 <skypers> when you come back to work on OOP like C++ or C#
14:08:30 <ion> You’re not allowed to say php, though.
14:08:31 <skypers> you feel just
14:08:32 <skypers> sad.
14:08:32 <bz> @hoogle loop
14:08:33 <lambdabot> System.Event loop :: EventManager -> IO ()
14:08:33 <lambdabot> Control.Arrow loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
14:08:33 <lambdabot> package loop-while
14:08:42 <identity> fuck profanity tbh
14:08:58 <WraithM_> ion: lol
14:09:02 <skypers> ion: fuck php
14:09:14 * hackagebot tuple-hlist 0.1.0.7 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.1.0.7 (NicolasDudebout)
14:09:30 <bz> what the fucking hell: http://hackage.haskell.org/package/base-4.6.0.1/docs/System-Event.html -> 404
14:09:33 <aupiff> more people should hang out in #yi! it's a haskell text editor, you guys, isn't that exciting?
14:09:39 <skypers> so yeah, when I hear people saying “OMG, we have template variadic in C++”
14:09:43 <skypers> now
14:09:48 <skypers> it makes me laugh :D
14:09:51 <identity> aupiff: haskell editor? you mean vim?
14:09:58 <skypers> aupiff: yeah
14:10:03 <skypers> I downloaded it
14:10:04 <skypers> yesterday
14:10:12 <skypers> I tried :set nu, and it fails
14:10:22 <alkabetz> aupiff: Whoa, is Yi development actually happening?
14:10:24 <bz> anyone knwo the definition of 'loop'? hoogle gives a 404
14:10:24 <skypers> is there a way to make numbers appear like in vim?
14:10:32 <bz> first result on hoogle is 404*, that is
14:10:37 <rasfar> yeah, yi goes back 10 years
14:10:44 <WraithM_> :set number
14:10:47 <aupiff> alkabetz: I'd like to help build out basic vim functionality, it's lacking...
14:10:52 <skypers> bz, yes, you just asked for it
14:10:55 <skypers> 22:59 < lambdabot> System.Event loop :: EventManager -> IO ()
14:10:56 <quchen> bz: "loop" is generally just a name for something that loops. Like "loop = print x >> loop"
14:11:14 <quchen> Other names are "go" or "acc" or whatever people like.
14:11:29 <aupiff> alkabetz: and yeah, there seems to be some action on the git repo
14:11:33 <skypers> acc?
14:11:34 <bz> nvm, it's defined later on in the file
14:11:38 <skypers> why acc?
14:11:39 <bz> christ it's late
14:11:41 <skypers> accumulate?
14:12:07 * rasfar gives up on hacking hint for the time being
14:12:21 <elliott> acc is more what you call a parameter to go
14:12:43 <skypers> I personnally use loop, yeah
14:12:51 <skypers> or loopback
14:12:55 <skypers> for fuzzy names
14:13:10 <identity> foo, bar and baz ftw
14:13:14 <identity> not in real code though
14:13:26 <skypers> yeah you wouln’t dare :D
14:13:36 <skypers> you just forgot zoo
14:14:22 <identity> My programming teacher makes use of THGTG(The hitchiker's guide..) themed names
14:14:37 <fl00r> i'm working on code at work right now that someone else wrote that uses temp1, temp2, and temp3
14:14:45 <identity> phartiphukborlz, slartibartfast
14:14:56 <triliyn> I like "hands", "feet", and "noses"
14:15:21 <skypers> 23:06 < fl00r> i'm working on code at work right now that someone else wrote that uses temp1, temp2, and temp3
14:15:25 <skypers> throw it away!
14:16:01 <skypers> with some french friends we had fun to release a school project with jokes around the C mem alloc function (malloc)
14:16:01 <fl00r> haha...i usually "refactor" these with better names when i come across them
14:16:05 <skypers> something like
14:16:22 <skypers> int *g = malloc(u);
14:16:35 <skypers> such an interesting words joke… :D
14:17:30 <identity> i don't get it
14:17:56 <skypers> identity: g, in french is « j’ai »
14:18:24 <skypers> the first part of malloc, mal, would make it as « j’ai mal » (== I feel bad about…)
14:18:45 <skypers> the last part of malloc(u) is oc(u) = « au cul » (my ass)
14:18:55 <identity> i see.
14:19:03 <skypers> you end up with something like « my ass hurts »
14:19:09 <skypers> ahah
14:19:12 <skypers> so clever
14:19:19 <identity> I guess you shouldn't pursue a career as standup comedians
14:19:23 <identity> ;)
14:19:29 <skypers> oh
14:19:30 <skypers> so mean
14:19:31 <jle`> i wish i programmed in french
14:19:51 <startling> :t (ala)
14:19:52 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
14:19:54 <jle`> *france
14:20:15 <skypers> jle`: the best part of programming with frenchies is when team mates try to pronounce english words
14:20:18 <skypers> like unbounded
14:20:48 <startling> haha
14:21:20 <skypers> or integer
14:21:29 <startling> in-te-szhe
14:21:33 <skypers> « and T jet »
14:21:35 <skypers> horrible.
14:21:53 <skypers> (not a t but a r, but with the same e as in jet)
14:22:30 <identity> I have a german calculus professor who is incredibly fond of using 3 as a constant everywhere in his examples, who is incredibly nervous during lectures, and cannot for the life of him pronounce 3 correctly in english
14:22:36 <identity> FFHRREE
14:22:39 <skypers> I know some folks whe pronounce the i of engine like in sky
14:22:49 <skypers> it make my hear bleed
14:23:23 <skypers> ahah
14:23:31 <skypers> identity: don’t mock him too much
14:23:32 <vervic> Hi! What is a good way to remove *only* the n-th element from a list
14:23:45 <skypers> three is actually the hardest number to pronounce
14:24:04 <identity> skypers: I don't mock him, not to his face anyway
14:24:10 <identity> well, generally don't mock him as such
14:24:12 <startling> vervic, take n . drop 1
14:24:16 <startling> er
14:24:19 <startling> drop 1 . take n
14:24:23 <skypers> identity: the terrible “with” some retards pronounce “wizz”
14:24:28 <startling> oh, wait
14:25:04 <identity> but he's terrible at his job
14:25:11 <Flonk> > let del n = ((++).take n)`ap`drop (succ n) in del 4 [1..10]
14:25:12 <lambdabot>   [1,2,3,4,6,7,8,9,10]
14:25:26 <startling> Flonk: haha oh god
14:26:11 <nicoo> Flonk: Wuuuuut o_O
14:26:16 <skypers> I can’t read that
14:26:20 <startling> I feel like it's in Data.List but I can't find it
14:26:33 <monochrom> I guess you could use splitAt plus some manipulation too
14:26:37 <nicoo> @pf \n -> ((++).take n)`ap`drop (succ n)
14:26:37 <lambdabot> Maybe you meant: pl bf
14:26:43 <nicoo> @pl \n -> ((++).take n)`ap`drop (succ n)
14:26:43 <lambdabot> ap (ap . ((++) .) . take) (drop . succ)
14:26:47 <vervic> startling: nope
14:26:53 <startling> :t let del n = (++) . take n <*> drop (n + 1)
14:26:55 <lambdabot> <no location info>:
14:26:55 <lambdabot>     not an expression: `let del n = (++) . take n <*> drop (n + 1)'
14:26:56 <alkabetz> /me’s brain explodes
14:27:00 <startling> :t let del n = (++) . take n <*> drop (n + 1) in del
14:27:01 <lambdabot> Int -> [a] -> [a]
14:27:05 <startling> that's not so bad.
14:27:08 <monochrom> it is not in Data.List because it is not a good use of list
14:27:22 <startling> monochrom, neither is nub, yet
14:27:26 <Flonk> I've become pretty fond of using ap. ap f g x = f x (g x), which is so incredibly useful
14:27:32 <identity> "pl bf"
14:27:42 <identity> pointless boyfriend?
14:27:47 <identity> my mind read it like that.
14:27:50 <skypers> Flonk: I never use ap
14:28:00 <vervic> why this shit does not compile: (take (n-1) sss) ++ (take (n-1) (reverse sss))
14:28:10 <skypers> I just know it’s useful to chain applicative
14:28:12 <startling> ap is so nice once you grok reader
14:28:15 <simpson> :t ap . ap
14:28:16 <lambdabot> (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
14:28:31 <monochrom> @type \sss -> (take (n-1) sss) ++ (take (n-1) (reverse sss))
14:28:32 <lambdabot>     Couldn't match expected type `Int' with actual type `Expr'
14:28:32 <lambdabot>     In the first argument of `(-)', namely `n'
14:28:32 <lambdabot>     In the first argument of `take', namely `(n - 1)'
14:28:38 <monochrom> oops
14:28:42 <monochrom> @type \n sss -> (take (n-1) sss) ++ (take (n-1) (reverse sss))
14:28:44 <lambdabot> Int -> [a] -> [a]
14:28:51 <monochrom> it seems to be just fine
14:29:01 <WraithM_> Perhaps he'
14:29:08 <identity> why ap instead of <*>? most cases would be fine, no?
14:29:09 <WraithM_> s not using Int for n-1
14:29:11 <WraithM_> idk
14:29:13 <startling> skypers: anyhow, I'd appreciate it if you didn't use words like "retard" in this channel
14:29:17 <vervic> i typed it into ghci
14:29:28 <startling> identity, it's the same thing, but ap only has a Monad constraint
14:29:37 <skypers> startling: huh?
14:29:38 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
14:29:40 <identity> startling: yeah
14:29:41 <identity> i saw that
14:29:42 <skypers> is this an insult?
14:30:12 <Flonk> identity: Most of the time it's just that I don't want to import Control.Applicative when I don't need to
14:30:13 <monochrom> I saw no insult
14:30:36 <startling> skypers, it's pretty manifestly unfriendly to a certain set of people.
14:31:22 <skypers> startling: hm, sorry then I guess
14:31:46 <startling> skypers: thanks! I appreciate it.
14:31:47 <ReinH> startling: +1 let's please not use ableist terms
14:32:24 <ReinH> i.e. words that hurt people with mental or physical disabilities
14:32:50 <skypers> ReinH: I always thougth that word was a sarcasm
14:32:53 <skypers> not a true insult
14:33:24 <ReinH> skypers: it equates having a mental disability with all the bad connotations you intended when you used the word
14:33:57 <vervic> i solved it: (could be better) dropNthElement :: Int -> [Int] -> [Int]
14:33:58 <vervic> (take (n) sss) ++ (reverse (take (n-1) (reverse sss)))
14:34:18 * hackagebot tuple-hlist 0.1.0.8 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.1.0.8 (NicolasDudebout)
14:34:25 <chrisdone> vervic: huh
14:34:26 <ReinH> skypers: anyway, thanks for thinking about it
14:34:42 <Flonk> vervic: use drop instead of your double reverse there
14:35:02 <Laidon> What is the definition of (++) again?
14:35:16 <monochrom> something like this:
14:35:17 <ion> @src (++)
14:35:17 <lambdabot> []     ++ ys = ys
14:35:17 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:35:17 <lambdabot> -- OR
14:35:17 <lambdabot> xs ++ ys = foldr (:) ys xs
14:35:25 <monochrom> good timing :)
14:35:34 <chrisdone> > let dropNthElement n xs = take n xs ++ drop (n+1) xs in dropNthElement 3 [1..5]
14:35:35 <lambdabot>   [1,2,3,5]
14:35:48 <Laidon> ion: Thanks, forgot the case for the list
14:36:42 <ion> > (second (drop 1) . splitAt 3) [1..5]
14:36:43 <lambdabot>   ([1,2,3],[5])
14:36:49 <vervic> Flonk: ty
14:36:53 <ion> > (uncurry (++) . second (drop 1) . splitAt 3) [1..5]
14:36:55 <lambdabot>   [1,2,3,5]
14:37:03 <ReinH> or the ever so readable applicative version:
14:37:06 <ReinH> > (\n -> (++) . take n <*> drop (n+1)) 5 [1,2,3,4,5,6,7]
14:37:08 <lambdabot>   [1,2,3,4,5,7]
14:37:20 <simpson> Doesn't Data.Split have something for this?
14:37:56 <chrisdone> > let dropNthElement n xs = catMaybes (zipWith (\i x -> do guard (i/=n); return x) [1..] xs) in dropNthElement 3 [1..5]
14:37:57 <lambdabot>   [1,2,4,5]
14:38:22 <bz> hask is becoming more and more of a guilty pleasure when i should be prepping for c++ interviews
14:39:13 <ReinH> bz: disregard C++ jobs acquire Haskell jobs
14:39:52 <bz> ReinH: acquire [] = []
14:39:59 <bz> :(
14:40:11 <chrisdone> inexhaustive pattern match
14:40:15 <chrisdone> that's why you can't get a haskell job
14:40:20 <startling> :<
14:40:24 <chrisdone> =p
14:40:27 <bz> pft
14:40:41 <bz> acquire = maximum
14:40:54 <quchen> dropNth n = map snd . filter (\x -> fst x /= n) . zip [0..]
14:40:54 <chrisdone> > let acquire = maximum in []
14:40:56 <lambdabot>   []
14:41:08 <ReinH> disregard :: [a] -> [a]; disregard _ = []
14:41:09 <bz> @src maximum
14:41:09 <lambdabot> maximum [] = undefined
14:41:10 <lambdabot> maximum xs = foldl1 max xs
14:41:29 <monochrom> one day, when you are preparing for haskell interviews, you will have guilty pleasure with c++
14:41:31 <chrisdone> quchen: nice
14:41:32 <ReinH> or disregard = const
14:41:40 <identity> monochrom: pleasure?
14:41:42 <identity> monochrom: really?
14:41:48 <quchen> chrisdone: I think that should even fuse
14:41:52 <bz> monochrom: green grass is green
14:42:02 <chrisdone> quchen: presumably the splitAt is the most performant, tho
14:42:11 <quchen> Yeah, filter is inefficient there
14:42:14 <ReinH> quchen: use the Schwartz
14:42:23 <quchen> Schwartz?
14:42:29 <ReinH> schwartzian transform
14:42:41 <quchen> I don't know what that is
14:42:42 <ReinH> or a relative thereof
14:42:44 <chrisdone> i'll be back :: ContT a
14:43:29 <ReinH> quchen: it's usually used in sorting where you want to order by a property of the object so you do a map to compute the property and then sort based on that
14:44:02 <quchen> ReinH: Oh, it's the name for what I used
14:44:09 <ReinH> quchen: oh heh yes
14:44:16 <quchen> I thought you meant some other technique
14:44:46 <ReinH> quchen: so generally: schwartzian p =  map snd . sortBy (comparing fst) . map (p &&& id)
14:44:54 <bz> :t (->)
14:44:55 <lambdabot> parse error on input `->'
14:44:57 <ReinH> you just used it for something other than sorting
14:45:14 <quchen> ReinH: I used that many times, it never occurred to me it might have a name
14:45:20 <ReinH> quchen: well it does :D
14:45:25 <ReinH> it comes from Perl of all places
14:45:27 <quchen> "I could have invented Schwatz transformations" :-D
14:45:28 <ReinH> (the name)
14:45:31 <ReinH> quchen: confirm
14:45:59 <ReinH> quchen: one of the things I love about Haskell is how easy it is to find that solution and how easy it is to express
14:46:03 <monochrom> now it's the generalized quchen-schwartz-cauchy-unyakovsky transform :)
14:46:04 <ReinH> even if you've never heard of the term of art
14:46:11 <ReinH> it just sort of naturally falls out
14:46:30 <startling> what's this Schwatz thing?
14:46:42 <startling> oh, sort by a thing
14:46:45 <identity> yeah
14:46:47 <quchen> startling: It's a misattributed transformation, properly called the quchen transform
14:46:49 <ReinH> "well I want to compare by a derived property, so I can probably (&&&) or zip" etc
14:46:55 <ReinH> quchen: haha
14:47:08 <quchen> Stigler's law etc
14:47:09 <quchen> https://en.wikipedia.org/wiki/Stigler%27s_law_of_eponymy
14:47:36 <quchen> Also note the list of examples :-)
14:47:38 <chrisdone> hm, was just thinking about the ‘if it compiles it works’ phrase often said about haskell programs
14:47:58 <quchen> Sure it does. There's just no guarantees it works in the way you want it to.
14:48:15 <chrisdone> if you were constructing a robot with haskell, what this rule means in practical terms is that you'll make a robot that can walk around without setting itself on fire or getting stuck
14:48:26 <identity> ReinH: why not just schwartzian p = sortBy (comparing p) ?
14:48:30 <ReinH> quchen: if you use a monad comprehension you could express it with a ZipList? [ x | x <- xs, y <- [0..], y /= n] ?
14:48:45 <ReinH> identity: that applies p more times
14:48:52 <quchen> ReinH: That will still walk through the entire list
14:48:55 <ReinH> since you have to compare more than n pairs
14:49:05 <chrisdone> it may kill your pets and tear up the rug, stuff you didn't intend, but it won't actually break
14:49:05 <quchen> What you want is "split" so it stops looking when you reach "n"
14:49:38 <ReinH> identity: the goal is to apply p the minimum possible number of times, which is n
14:49:51 <identity> ReinH: I see
14:50:24 <ReinH> versus sorting generally which would apply it n log n times
14:50:51 <ReinH> (average case for most commonly used algos, that is)
14:51:11 <quchen> Sleepsort for O(n) sorting!
14:51:15 <ReinH> quchen: :p
14:52:06 <carter> ReinH: i watched a haskell cast with spj
14:52:08 <carter> good job
14:52:17 <ReinH> carter: high five!
14:52:19 <quchen> Well not interrupted :-)
14:52:33 <quchen> Shame there was no vid though
14:52:41 <ReinH> quchen: I know :( Simon's cam wasn't working
14:52:46 <quchen> Yeah you mentioned it
14:52:59 <ReinH> Also we tried Skype which sucked and then we had to go back to Google Hangouts mid-cast
14:53:20 <quchen> Was that the source of the odd audio?
14:53:20 <ReinH> Hard to believe there isn't a high quality VoIP service that isn't exhorbitantly expensive
14:53:24 <ReinH> quchen: yeah
14:53:32 <ReinH> (that does conferencing, that is)
14:53:37 <ReinH> but then we'd miss out on video too
14:53:54 <ReinH> google hangout has some artifacting but generally better than Skype based on our experience
14:54:12 <chrisdone> ime mumble is best for quality
14:54:23 <quchen> Video?
14:54:30 <quchen> Mumble has video?
14:54:35 <ReinH> quchen: we usually try to video conference and record video to youtube
14:54:36 <chrisdone> it lets you fine tune everything based on your own personal setup, connection, etc
14:54:39 <ReinH> quchen: we usually use google hangout
14:54:51 <chrisdone> quchen: nah, i'm just referring to the voip part
14:54:55 <quchen> Ah okay.
14:55:02 <ReinH> chrisdone: the problem is also that we want to use a tool that's as easy for our guests to get running as possible
14:55:02 <quchen> Well thumbs up for mumble.
14:55:13 <chrisdone> ReinH: nod. hangouts seems the best candidate for that
14:55:16 <ReinH> and so far google hangout has be satisficetory
14:55:19 <ReinH> been
14:55:26 <chrisdone> we use hangouts for all out meetings at fp complete =)
14:55:27 <ReinH> which is totally now a word btw
14:55:37 <ReinH> chrisdone: yeah we use it a lot for work too
14:55:49 <ReinH> AT&T has its own enterprisey conferencing solution
14:55:54 <ReinH> but out team pretty much just uses hangouts
14:55:59 <ReinH> *our
14:56:08 <chrisdone> we both made the same our typo =p
14:56:08 <quchen> AT&T has solutions? Man times change
14:56:15 <ReinH> quchen: hahaha, well it buys them
14:56:17 <chrisdone> quchen: OHHHHHH
14:56:21 * chrisdone slaps thigh
14:56:35 * ReinH shrugs
14:56:47 <ReinH> I'm a contractor so I'm totally not offended :p
14:56:57 <quchen> I have no idea what's going on
14:56:58 <chrisdone> AT&T seem to be the american version of BT
14:57:21 <ReinH> Welcome to #haskell, where we haven't talked about Haskell in at least 5 minutes!
14:57:25 <ReinH> :D
14:57:28 <quchen> I left the country partially because AT&T. That and my Visa expired. :-P
14:57:35 <quchen> +of
14:58:13 <monochrom> AT&T had solutions. here is one: https://www.youtube.com/watch?v=tc4ROCJYbm0
14:58:45 <ReinH> heh
14:59:06 <quchen> Sounds like a Linux ripoff!
14:59:07 <hpc> ReinH: we talk about haskell roughly 5% of the time; the internet talks about haskell hardly at all; by bayesian inference, we are a dedicated haskell channel
14:59:23 <ReinH> hpc: touche
14:59:38 <ReinH> hpc: to be fair, almost all internet traffic is porn anyway
14:59:53 <quchen> Not Torrents?
14:59:58 <quchen> Probably porn torrents.
15:00:01 <ReinH> torrents of porn
15:00:27 <simpson> Did somebody say "porn" and "torrents?"
15:00:47 <quchen> No, that must have been some other channel. This is about Haskell, the programming language.
15:00:52 <identity> torrents of porn torrents
15:02:35 <Fuuzetsu> I bet I could find one.
15:03:05 <chrisdone> http://www.reddit.com/r/programming/comments/1piqsj/in_praise_of_haskell_my_guest_editorial_for_dr/
15:03:26 <Fuuzetsu> Wow, apparently this ISP is a flaming *** and blocks a lot of torrent sites.
15:04:07 <chrisdone> that the same old discussions occur over and over is vaguely encouraging. it means new people are discovering haskell
15:04:17 <Ove_> Fuuzetsu: Are they blocked for real?
15:04:24 <Ove_> Or just dns mumbo jumbo?
15:04:34 <Heffalump> chrisdone: or that Haskell rots the brain and damages long-term recall
15:05:02 <bz> iss it possible to eliminate the gc?
15:05:16 <alkabetz> bz: In the GHC runtime?
15:05:20 <bz> would be so nice to use haskell for realtime
15:05:27 <bz> alkabetz: or eliminate the runtime, even
15:05:39 <alkabetz> I think HalVM is about as close as we are to that right now
15:05:54 <Cale> Atom
15:06:00 <Cale> http://hackage.haskell.org/package/atom
15:06:02 <Fuuzetsu> Ove_: Haven't tried a separate DNS yet. I wonder if I could ask to have the block removed.
15:06:09 <Heffalump> jhc compiles straight to C, not sure if it has a runtime of significance. I think it uses the Boehm collector, which you could probably turn off.
15:06:21 <alkabetz> Cale: Ooh, that’s cool!
15:06:22 <Heffalump> (at the cost of an indefinite memory leak, of course)
15:06:24 <Ove_> Fuuzetsu: Try googles dns servers.
15:06:32 <Cale> Mostly if you want to use Haskell for hard realtime, you'll be using it as a kind of metalanguage
15:06:33 <Ove_> 8.8.8.8 and 8.8.4.4
15:06:46 <WraithM_> Do people know of something like a Circular Buffer for Data.Vector?
15:07:13 <ReinH> Cale: I saw some interesting research into hard realtime compatible GC methods recently
15:07:26 <chrisdone> yeah, in some cases jhc compiles to almost plain c
15:07:32 <alkabetz> bz, Cale: Have you seen Ivory and Tower?  (Disclaimer: I know the developers)
15:07:53 <Cale> I haven't
15:08:02 <alkabetz> http://smaccmpilot.org/
15:08:19 <alkabetz> It’s basically a C code generator
15:08:21 <bz> saw that on reddit
15:09:28 <bz> bwah
15:09:33 <ReinH> Cale: haven't seen any research or haven't seen any research you think is interesting?
15:09:43 <bz> this guy took the idea i had for 5 years and made it into a lib
15:09:54 <Cale> ReinH: ?
15:10:06 <ReinH> Cale: oh you weren't answering me sorry
15:10:15 <Cale> oh, I hadn't seen Ivory or Tower before
15:10:17 <Cale> yeah
15:10:42 <ReinH> async systems are the worst thing ever
15:10:56 <WraithM_> Oh! I found exactly what I wanted from StackOverflow:
15:11:04 <WraithM_> http://hackage.haskell.org/package/vector-buffer-0.4/docs/Data-Vector-Buffer.html
15:11:17 <ReinH> I bet you $10 that it was a dons answer
15:11:19 <Fuuzetsu> Ove_: Oh yeah, I forgot that you can't change DNS in Firefox and the ‘Home hub’ the ISP gives you doesn't allow you to change nearly anything. I'll have to get a better router when I get some cash in. Well, in any case I can resolve to it but they ship me different content (their ‘error’ message)
15:12:09 <ReinH> Fuuzetsu: set up an ssh -D HTTP proxy?
15:14:24 <Fuuzetsu> ReinH: I have in the past and I will if I need access to the sites. Don't really need it at the moment but it's very disappointing. Just found a 67 page PDF where the blocking might be outlined though.
15:19:19 <skypers> night folks
15:20:36 <rck> is there a type that corresponds to a reverse Maybe? where you want to return something as part of failure? I guess like Either but throwing away the Right wrapped value?
15:20:54 <skypers> rck: what do you mean?
15:21:06 <rck> normal Maybe is Just x success, Nothing fail
15:21:08 <simpson> rck: What would the type look like?
15:21:18 <simpson> rck: data Maybe a = Just a | Nothing
15:21:25 <skypers> rck: you can see it that way, indeed
15:21:26 <skypers> then?
15:21:48 <rck> well yeah but it seems the idiom with maybe is that Nothing represents failure
15:22:04 <skypers> you’re not stuck to that
15:22:11 <simpson> rck: The Functor and Monad instances of Maybe are largely a result of the laws for those typeclasses rather than some attitude towards the meaning of Maybe.
15:22:16 <rck> and if I were to use it where Nothing represents success it would type check but probably would trip others (and myself later) on review
15:22:30 <skypers> you can use Maybe String and says that you return a string description of an error if occured
15:22:35 <merijn> simpson: Well, it's both
15:22:57 <rck> my question is more of about idiom than correctness
15:22:57 <skypers> rck: then write a wrapper?
15:22:59 <triliyn> rck: Either a () would be comparable and possibly less confusing
15:23:04 <triliyn> If you're worried
15:23:09 <simpson> merijn: If you changed the names of the constructors, it'd still have the same typeclass instances, wouldn't it?
15:23:19 <simpson> data Retval a = Success | Error a
15:23:45 <simpson> Would still have: fmap f Success = Success; fmap f (Retval a) = Retval (f a)
15:23:46 <skypers> I’d use Maybe a for that
15:23:57 <merijn> simpson: Yes, but it's disingenous to say that that behaviour is just incidental to the type
15:24:27 <merijn> simpson: The notion of Maybe/Option for failure predates the invention of typeclasses and the application of stuff like Functor/Monad in FP
15:24:35 <simpson> merijn: Why? In literature, I usually don't see Maybe called Maybe, but called something that reflects that it adds one additional value to the type that it is wrapping.
15:24:40 <skypers> you can simply write, rck:
15:24:48 <skypers> type RetVal a = Maybe a
15:25:09 <skypers> and wrap Just and Nothing in your own functions wrappers
15:25:25 <skypers> but I still thing returning a Maybe a with a little comment is quite enough
15:25:31 <skypers> think*
15:25:57 <jle`> simpson: i do think you'd have to define them yourselves
15:26:19 <Maxdamantus> type RetVal = Maybe
15:26:32 <simpson> jle`: My point was that there's only one possible Functor instance for this type, and IIRC only one working Monad as well.
15:27:15 <hamh> Hi
15:27:30 <Maxdamantus> couldn't you have a Functor instance where fmap = const id?
15:27:47 <Maxdamantus> wait, no, nvm.
15:28:16 <skypers> night
15:28:22 <simpson> Maxdamantus: And you can't do `fmap _ _ = Nothing` either, because of the Functor law.
15:28:41 <Maxdamantus> Yeah, I suspected that.
15:30:30 <ReinH> simpson: fmap id = id is such a boring law
15:31:03 <simpson> ReinH: Some cool dude proved that it forces all types in Hask to have exactly zero or one valid Functor instance, which is pretty cool.
15:31:21 <ReinH> simpson: obligatory "cool story bro"
15:31:40 <simpson> I think that it was Wadler, but I'm not sure.
15:31:55 <ReinH> simpson: surely that's true up to isomorphism or something right?
15:32:07 <simpson> Probably.
15:32:12 <ReinH> a 2-tuple functor that mapped over the first value is just as valid as one that maps over the second value, right?
15:32:46 <simpson> Anyway, it's not that different from the laws for Applicative and Monad, which have similar implications. ISTR that the Monad laws plus the version of fmap for Monad combine to give back the Functor law.
15:33:06 <ReinH> simpson: well, you can derive fmap from liftM, yes
15:33:13 <ReinH> er, from bind and return
15:33:18 <ReinH> which is liftM, which is fmap
15:33:26 <simpson> Right.
15:34:30 <bz> i feel like making a better ghci
15:34:50 <rck> is the eventual plan to do away with 'map', or define it as 'fmap' when Functors become superclasses of Monads? (same with liftM I suppose)
15:35:01 <augustss> simpson: who was the cool dude?
15:35:26 <ReinH> rck: well, there's a plan for "fixing" the class hierarchy such that functor is a proper superclass of applicative is a proper superclass of monad
15:35:34 <ReinH> in fact there are multiple such plans
15:35:35 <simpson> augustss: I suspect Wadler, but I'm not sure and didn't want to sound definitive.
15:35:47 <ReinH> it's almost always Wadler ;)
15:35:49 <simpson> rck: The problem is that there's a *lot* of code out there.
15:35:56 <augustss> yeah, it could be Phil
15:36:23 <thebnq> they'll probably leave in something like map = fmap
15:36:31 <ReinH> Some people also want to split Applicative and Monad up further by extracting Apply and Bind, respectively
15:36:32 <rck> ReinH: thanks, yeah that's what I meant.
15:36:48 <ReinH> since iirc Map is an Apply but not an Applicative
15:37:10 <ReinH> redefining map as fmap is pretty trivial
15:37:32 <augustss> fmap was supposed to be called map, but then people chickened out.
15:37:50 <ReinH> better than fap
15:38:09 <ReinH> which is ofc what the Apply function should be called
15:38:32 <augustss> mappend was supposed to be called concat
15:38:54 <ReinH> I'm a fan of <>
15:38:56 <FreeFull> mconcat as concat would make more sense
15:39:00 <FreeFull> <> is nice to hae
15:39:03 <FreeFull> have*
15:39:11 <augustss> Sorry, mconcat was supposed to be called concat
15:39:18 <augustss> mapped is ++, of course
15:39:19 <ReinH> it's often represented by a square in the literature
15:39:36 <ReinH> and <> is just a square turned a bit
15:39:40 <ReinH> if you squint
15:40:01 <structur_> who on earth decided that mappend was a good name for a monoid operation?
15:40:10 <augustss> A lot of things were nicer around Haskell 1.3
15:40:10 <hpc> ReinH: b-b-b-but <> is for reading from standard input!
15:40:18 <FreeFull> The arguments against this are using a typeclass gives worse errors, and old code that used to work might now need type annotations
15:40:18 <ReinH> structur_: the same people that decided fmap was a good name for a functor operation?
15:40:25 <hpc> http://hackage.haskell.org/package/acme-php-0.0.3/docs/Prelude-PHP.html
15:40:50 <structur_> fmap seems more reasonable to me
15:40:55 <augustss> FreeFull: That was indeed the argument.
15:41:08 <ReinH> I also want to fix Semigroup as a proper superclass of Monoid so we can relax the Maybe monoid restriction once and for all
15:41:46 <augustss> If the Haskell prelude was designed today it would undoubtedly look different.
15:41:52 <ReinH> augustss: confirm
15:41:56 <FreeFull> Right now there is an instance  (Monoid a) => Monoid (Maybe a)
15:42:05 <augustss> But it's not clear exactly how.
15:42:06 <FreeFull> That'd make more sense with a Semigroup constraint
15:42:09 <ReinH> FreeFull: right, compare to Option fmor Semigroup
15:42:13 <ReinH> which is exactly that
15:42:19 <ReinH> as you don't need a unit there
15:42:36 <ReinH> although making the monoid instance of Maybe act like First might also make more sense
15:43:07 <ReinH> it would unify the behavior with the MonadPlus instance
15:43:47 <FreeFull> That's what Alternative is for
15:43:53 <ReinH> which should really be what you get for free from its Monoid + Monad parent classes right?
15:44:17 <rck> augustss: by the almost universal esteem around Haskell I'd say you guys did a fine job at the time
15:44:29 <FreeFull> instance (Semigroup a) => Monoid (Maybe a)   would be very nice to hae
15:44:30 <FreeFull> have*
15:44:35 <ReinH> FreeFull: right, so then the MonadPlus instance should behave like the Monoid instance?
15:44:47 <ReinH> FreeFull: right you just add the identity, which should be called unit right?
15:44:49 <augustss> rck: I take none of the glory for the Prelude.  That was mostly Joe Fasel.
15:44:50 <ReinH> why can't we call it unit?
15:44:56 <FreeFull> ReinH: MonadPlus and Monoid don't take the same kind
15:45:01 <ReinH> FreeFull: oh right
15:45:05 <ReinH> disregard
15:45:18 <ReinH> FreeFull: maybe I mean from a monad of monoids?
15:45:28 <ReinH> Monad m, Monoid a => m a ?
15:45:30 <augustss> But I think the Prelude has withstood the test of time fairly well.
15:45:36 <ReinH> augustss: it certainly has
15:46:25 <FreeFull> AMP will be big
15:46:28 <ReinH> augustss: I hope no one is suggesting that the prelude is *bad*, because it clearly isn't
15:46:32 <rck> would all this map to fmap talk get implemented as a ghc extension, if it were to happen? that's how most of the language development is going right?
15:46:33 <ReinH> FreeFull: AMP?
15:46:50 <ReinH> rck: no, there's no need for an extension, you would just change the impl in the prelude
15:46:54 <augustss> ReinH: It just could be better. :)
15:47:01 <ReinH> augustss: exactly
15:47:20 <rck> ReinH: what about the "lots of old code" argument?
15:47:22 <FreeFull> Functor-Applicative-Monad
15:47:34 <ReinH> rck: Haskell's response to that has historically been to "avoid success at all costs"
15:47:41 <rck> hahaha fair enough
15:47:52 <FreeFull> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
15:48:10 <augustss> Code can be changed, it's not a disaster to make incompatible changes as long as they cause type errors.
15:48:14 <ReinH> which in part means being willing to make changes for the good of the langauge even if they cause some inconvenience
15:48:20 <FreeFull> ReinH: Two ways to interpret that. "Avoid (success at all costs)" or "(Avoid success) at all costs"
15:48:23 <ReinH> we actually talk to SPJ about that on the podcast
15:48:24 <ReinH> FreeFull: indeed :)
15:48:39 <ReinH> FreeFull: it's becoming more of the former as Haskell become more mature, I guess
15:48:43 <augustss> We made Applicative a superclass of Monad in our implementation, and that only cause minor problems.
15:48:44 <ReinH> although it's really a continuum :)
15:48:46 <rck> ReinH: have a link? I'd like to listen
15:48:51 <ReinH> rck: haskellcast.com
15:48:54 <rck> thanks
15:48:57 <ReinH> np
15:49:17 <ReinH> I think we talked to Don Stewart about it as well
15:49:27 <augustss> Indeed
15:49:28 <FreeFull> Success at all costs isn't worth it
15:49:31 <Peaker> augustss: how much of the ecosystem could you import into yours?
15:49:39 <ReinH> And probably edwardk since he's chairing the libraries committee now
15:49:40 <quchen> Did someone say AMP? :-D
15:49:43 <ReinH> so basically all the guests
15:49:45 <Peaker> augustss: (assuming Applicative problems involve mostly the ecosystem)
15:49:47 <FreeFull> You just end up with another bad language that can't be changed anymore
15:49:53 <FreeFull> quchen: I did
15:50:21 <ReinH> FreeFull: one of the things we talked to SPJ about is how Haskell has always been willing to do the hard think when they think it's the right thing
15:50:29 <ReinH> why, for isntance, it took so long to get a complete IO solution
15:50:34 <augustss> Peaker: what really caused us problems was making join a method in Monad.  Lots and lots of name clashes with our Relation.join.
15:50:39 <ReinH> rather than a quickly implemented but unprincipled one
15:50:57 <ReinH> s/think/thing
15:51:00 <ReinH> although both work actually
15:51:01 <quchen> I'm curious about whether join will make it into Monad.
15:51:04 <hamh> Are nested where's generally considered bad form in haskell?
15:51:05 <Peaker> augustss: ooh, haven't considered that aspect. Though it seems like it's orthogonal to the Applicative=>Monad relationship?
15:51:09 <FreeFull> Semi-lazy IO did end up being a problem
15:51:15 <ReinH> hamh: they can be good form!
15:51:24 <augustss> Peaker: it is orthogonal, but part of the same proposal.
15:51:27 <ReinH> hamh: if nested wheres help you share bindings in a useful way, for instance
15:51:37 <ReinH> hamh: but they can also be a smell that your function could be better factored
15:51:45 <ReinH> nested wheres often just mean "this should be at top level"
15:51:49 <quchen> Peaker: It's not entirely orthogonal. "join" doesn't make much sense unless you also have fmap.
15:52:04 <Peaker> quchen: well, it could be deferred to another time
15:52:09 <ReinH> hamh: which is ofc in tension with how useful that function is outside its current context
15:52:11 <hamh> ReinH: I think it's the latter, tbh. I've got this monstrously ugly one line function and I can't decide how to split it up
15:52:18 <quchen> Peaker: Oh, change-wise, sure
15:52:19 <Peaker> quchen: so that Applicative=>Monad breakage is minimized and focused
15:52:35 <ReinH> hamh: start by splitting it up into wheres and then extracting the ones that seem generally useful :)
15:52:52 <quchen> Peaker: I think the MonadPlus and join parts of the AMP were because "we won't change those things for a long time after this" so we put them in
15:52:54 <Peaker> maybe the breakage from Applicative=>Monad is worth it, but the breakage from making "join" a method not worth it?
15:52:55 <ReinH> hamh: if you avoid nesting them, though, you'll often find them easier to extract
15:53:03 <FreeFull> Will join become a part of the Monad typeclass?
15:53:11 <FreeFull> Ah, no
15:53:13 <FreeFull> Damn
15:53:14 <hamh> ReinH: thanks :)
15:53:17 <quchen> FreeFull: That's the plan. Current status: hopefully.
15:53:31 <ReinH> hamh: as you force yourself to use combinators rather than bindings available in the where scope
15:53:34 <FreeFull> How much breakage will there be?
15:53:42 <quchen> FreeFull: 7.8 warnings include one for "join".
15:54:02 <ReinH> hamh: (combinator here meaning "a function with no free variables")
15:54:04 <quchen> FreeFull: Haven't tried. GHC itself had 150+ instances that needed to be fixed/added.
15:54:15 <quchen> It was the dullest thing I've ever done in Haskell :>
15:54:28 <ReinH> hamh: on the other hand, though, some things are just more elegant with nested where clauses :)
15:54:29 <quchen> But not dull enough so you can automate it ;-(
15:54:29 * hackagebot purescript 0.1.4 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.4 (PhilFreeman)
15:54:31 <FreeFull> Some Monads are easier to define in terms of fmap and join
15:54:42 <ReinH> hamh: it's almost like you have to think about it and make a decision for each case :)
15:54:45 <FreeFull> So it'd be nice to have join in (and Functor as superclass)
15:55:04 <ReinH> FreeFull: I think monads are easier to explain in terms of fmap and join
15:55:07 <quchen> FreeFull: Have a look at the AMP wiki article
15:55:16 <ReinH> FreeFull: since join captures the monoidness and "sequencing"
15:55:29 <quchen> FreeFull: If something's unclear please complain.
15:55:36 <FreeFull> Reader monad, join f x = f x x; fmap = (.)
15:55:40 <hamh> ReinH: Indeed, so
15:55:48 <quchen> Hmm, I think >>= is much more sequency than join.
15:56:32 <quchen> FreeFull: Reader is easy to define with join, but I don't understand the instance that way.
15:57:02 <quchen> I'd say List makes a nicer example for something you can join :-)
15:57:04 <augustss> Putting join in the Monad class is the right thing, so I really hope that will happen.
15:57:20 <FreeFull> join = concat; fmap = map
15:57:26 <ReinH> quchen: once I figured out that Reader was just the function monad it made more sense :)
15:57:50 <quchen> ReinH: Hm. I looked at it many times and couldn't come up with something understandable.
15:58:04 <quchen> "\r -> f (m r) r" I could explain after a while.
16:01:12 <aupiff> sorry to interrupt the AMP talk, I have a question about cabal sanboxes. as indicated here: https://github.com/haskell/cabal/wiki/Sandboxed-Builds-and-Isolated-Environments#miscellaneous I think testing yi builds in a sandbox is a little tricky because ghc doesn't have access to sandboxed packages when compiling yi.hs config files... is there a way around this?
16:01:57 <ReinH> aupiff: oh noes you have discovered the cabal sandbox cryptonite!
16:02:10 <aupiff> in virtualenv, for example, every python invocation after activating a virtualenv is that virtualenv's sanboxed python, but there's nothing like that for cabal, huh?
16:02:20 <ReinH> (ghc self-reflection)
16:02:45 <aupiff> ReinH: yes! what should I do? should I just try to develop it with plain 'ol cabal?
16:03:07 <sm> aupiff: hsenv is like that
16:03:19 <sm> http://hackage.haskell.org/package/hsenv
16:03:42 <phserr> a bit of coding convention question - should I use Integral even when I know that the values will never be that large?
16:03:57 <phserr> or should i stick to ints?
16:04:08 <phserr> (by integral, i mean (integral a) => ...
16:04:10 <phserr> )
16:04:11 <aupiff> sm: interesting, I'll check it out. do you use it in combination with cabal sandboxes?
16:04:58 <sm> no, I used it before cabal sandboxes came along
16:05:05 <sm> works great
16:05:49 <Fuuzetsu> boo, lpaste just disregarded my paste as spam
16:06:22 <Fuuzetsu> It'd be nice if it prompted with captcha or something if it thinks the paste is spam instead of throwing it away…
16:07:08 <ReinH> Fuuzetsu: :( was your paste about a fortune locked in a Kenyan bank perchance?
16:07:11 <hkarim> Any recommendation for a good reference on how to implement pattern matching for ADTs in general not just Haskell?
16:07:28 <Fuuzetsu> ReinH: Nope, it contained a few links to issue trackers.
16:07:31 <Fuuzetsu> That's just as bad I guess.
16:07:34 <Dorne> why does cabal install usually fail?
16:07:47 <Dorne> for e.g. pandoc or hakyll
16:07:48 <Fuuzetsu> Dorne: Outdated dependencies.
16:08:18 <augustss> hkarim: SPJ's book on implementing functional languages is good.
16:08:44 <startling> Fuuzetsu, we wouldn't want anyone drawing attention to the issue trackers
16:08:49 <WraithM> augustss: Yes it is.
16:09:04 <Fuuzetsu> startling: No issues exist in the Haskell world.
16:09:25 <WraithM> Does anybody know of a good way to convert Data.Sequence.Seq to Data.Vector?
16:09:27 <Fuuzetsu> Even the non-Haskell-related issues.
16:09:31 <hkarim> augustss: thanks
16:09:32 * hackagebot hatex-guide 1.3.0.0 - HaTeX User's Guide.  http://hackage.haskell.org/package/hatex-guide-1.3.0.0 (DanielDiaz)
16:09:34 * hackagebot pipes-parse 2.0.2 - Parsing infrastructure for the pipes ecosystem  http://hackage.haskell.org/package/pipes-parse-2.0.2 (GabrielGonzalez)
16:09:47 <bz> hatex
16:11:59 <aupiff> sm: hsenv is amazing. why would anyone use sandboxing? it's so clearly inferior!
16:15:50 <sm> aupiff: well, it's nice to have something that works out of the box, and across platforms (windows)
16:16:08 <donri> tools that rely on setting envvars are messy
16:16:21 <sm> and cabal sandboxes can be a little smarter in certain ways. But yes, that deep environmental kind of sandbox can be useful too
16:17:24 <aupiff> all good points, I'm just glad haskell dev is getting easier
16:17:34 <sm> +1
16:17:47 <bz> now if only cabal learned uninstall
16:18:02 <aupiff> what do you think of the cabal-uninstall package?
16:18:54 <Fuuzetsu> Is it just an alias to ghc-pkg unregister?
16:19:02 <sm> I assumed it's much like .. yeah that
16:19:19 <aupiff> Fuuzetsu: that and automaticaly removes the package files, too
16:19:21 <Fuuzetsu> Oh, it is.
16:19:21 <donri> luite: why is it showing everything as changed? http://hdiff.luite.com/cgit/pipes-parse/commit?id=2.0.2
16:19:25 <sm> ah
16:19:39 <aupiff> Fuuzetsu: basically saves you the trouble of writing your own bash script
16:19:55 <sm> sounds good. Dunno why it shouldn't be offered by cabal
16:20:14 <Fuuzetsu> because ‘Cabal is not a package manager’®
16:20:21 <aupiff> says who?
16:20:31 <ReinH> aupiff: cabal, apparently
16:20:32 <aupiff> I haven't heard that.
16:20:32 <bz> neither is pip, but it knows how to uninstall
16:20:33 <sm> oh yes silly me (slaps forehead)
16:20:40 <aupiff> really? why? what is it?
16:20:46 <Fuuzetsu> http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
16:21:07 <dcoutts_> Fuuzetsu: I don't agree with ivan incidentally
16:21:13 <dcoutts_> it's just not implemented yet
16:21:22 <dcoutts_> we're getting closer to uninstall
16:21:22 <sm> https://www.fpcomplete.com/user/simonmichael/how-to-cabal-install is another, less technical intro
16:21:29 <bz> knowing to uninstall doesn't necessitate being a package manager
16:21:34 <dcoutts_> we worked on it at the recent ZuriHac
16:21:36 <bz> case in point, pip
16:21:57 <Fuuzetsu> dcoutts_: Not there yet though
16:22:22 <sm> (dcoutts and cabal/hackge team)++
16:22:34 <dcoutts_> Fuuzetsu: no, indeed not yet
16:23:08 <sm> oh nice, I see hackage has deployed new code
16:23:13 <dcoutts_> Fuuzetsu: but it's not that we don't aspire to cover that functionality
16:23:18 <dcoutts_> sm: yep, this morning
16:23:22 <sm> \o/
16:23:59 <sm> no more paging through 10 search results at a time
16:25:29 <donri> oh cool default limit bumped to 100 eh
16:25:40 <sm> funny, now I find 100 annoying :)
16:25:51 <donri> :P
16:26:14 <Fuuzetsu> Could it not be customisable?
16:26:23 <sm> I think it's really good for hackage to deploy new code regularly
16:26:30 <Fuuzetsu> Using the new ‘cookies’ technology.
16:29:34 * hackagebot scientific 0.1.0.0 - Arbitrary-precision floating-point numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.1.0.0 (BasVanDijk)
16:29:58 <bz> :t <$>
16:29:59 <lambdabot> parse error on input `<$>'
16:30:22 <prooftechnique> :t (<$>)
16:30:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:30:27 <bz> whoops
16:30:35 <bz> hey isn't that fmap?
16:30:39 <prooftechnique> It is!
16:30:57 <bz> why the redundancy?
16:31:18 <prooftechnique> Infix notation, mainly
16:31:40 <bz> `fmap` not good enough?
16:32:06 <prooftechnique> > (+1) <$> [1..10]
16:32:08 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:32:09 <[swift]> given how often that function gets used, halving the number of characters is a good thing
16:32:32 <bz> not if you count the extra shift key abuse
16:32:55 <prooftechnique> It's mainly used in applicative style code, I think
16:34:09 <prooftechnique> > (++) <$> Just [1..5] <*> Just [6..10]
16:34:11 <lambdabot>   Just [1,2,3,4,5,6,7,8,9,10]
16:34:19 <prooftechnique> bz: Consider that ^
16:38:22 <hamh> If i have a list of doubles and a list of list of doubles, how could I go about subtracting each value in the list of doubles from the corresponding value in list of list of doubles?
16:39:32 <sm> hackage's new changelog support is nice: http://hackage.haskell.org/package/intset-0.1.0.3
16:39:54 <sm> now hackage-server needs one
16:44:08 <Cale> hamh: Well, what do you mean by "subtracting" when you have a Double and a [Double]?
16:44:51 <bz> think he means [[a]] -> [a] -> [[a]]
16:44:53 <Cale> :t zipWith (\x xs -> map (subtract x) xs)
16:44:54 <lambdabot> Num b => [b] -> [[b]] -> [[b]]
16:50:49 <prooftechnique> > zipWith (map . subtract) [1.0..5.0] [[2.0..6.0],[3.0,7.0]]
16:50:51 <lambdabot>   [[1.0,2.0,3.0,4.0,5.0],[1.0,5.0]]
16:51:17 <prooftechnique> > zipWith (map . subtract) [1.0..5.0] [[2.0..6.0],[3.0..7.0]]
16:51:19 <lambdabot>   [[1.0,2.0,3.0,4.0,5.0],[1.0,2.0,3.0,4.0,5.0]]
16:52:11 <hamh> Cale: I'm trying to center the columns of a matrix, if that helps.
16:53:07 <bz> he means subtracting rotated 90 degrees
16:53:35 <hamh> prooftechnique: That's cool, thanks. I didn't to use composition like that
16:53:48 <hamh> *think
16:54:01 <prooftechnique> Cale did all the work :D
16:54:35 <prooftechnique> That behavior with ranges is pretty funky, though
16:56:17 <hamh> prooftechnique: your'e right. Thanks Cale
17:04:08 <hamh> Man, that's elegant. I'm still using list comprehensions to make it feel more imperative
17:05:15 <hamh> Anyway thanks for the help
17:05:17 <prooftechnique> Higher order functions are pretty great :D
17:05:45 <prooftechnique> You'll start seeing folds everywhere, eventually
17:07:15 <startling> is it possible to write traverse for lists in terms of foldr?
17:07:55 <startling> I guess so.
17:08:19 <startling> So yeah, every possible operation on a list is a foldr. :)
17:08:39 <heath> how could you clean line 39 up? https://github.com/NashFP/rosalind/blob/master/mark_wutka%2Bhaskell/LCSM/lcsm.hs#L39
17:08:44 <general-general> I am unsure if saying hello, everyone is a good idea. However, I will 'chance my arm'.
17:08:58 <startling> hi general-general
17:09:00 <sm> hello general-general !
17:09:02 <Fuuzetsu> Greetings considered imperative.
17:09:32 <startling> Fuuzetsu considered harmful
17:09:44 <Fuuzetsu> startling DEPRECATED
17:09:50 <heath> StringTree True $ Map.insert c . overlayString . Map.findWithDefault empty c nodes cs nodes -- for fun time
17:09:55 <startling> :O
17:10:30 <prooftechnique> startling: Fuuzetsu: shots fired
17:11:06 <Fuuzetsu> unsafeFireShots
17:11:26 <prooftechnique> heath: Huh?
17:11:51 <prooftechnique> Fuuzetsu: thaw iceBurn
17:14:32 <heath> prooftechnique: it's random, not sure really how to clean his code up
17:14:45 <prooftechnique> @where lpaste
17:14:46 <lambdabot> http://lpaste.net/new/haskell
17:14:46 <Kron> Kron: references Kron
17:15:08 <prooftechnique> heath: Post the code there. I'm sure you'll get some input
17:15:39 <heath> prooftechnique: i don't think he's sure how to clean it up either from a conversation with him
17:16:45 <prooftechnique> Is there some code we can look at?
17:16:52 <prooftechnique> Fresh eyes and whatnot
17:23:09 <cswords> Quick question: is it possible to export an entire submodule? If I have Foo and Foo.Defs, but using Foo requires all of Foo.Defs be in scope, is it possible to (easily) ensure that 'import Foo' also imports Foo.Defs?
17:23:14 <chrisblake> is there a function that's "zipWith (++)"?
17:23:19 <startling> cswords: yep
17:23:35 <startling> cswords: just put "module Foo.Defs" in the "module Foo ( ... ) where"
17:23:43 <chrisblake> oh, it's just zip.
17:23:50 <chrisblake> @src zip
17:23:50 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
17:23:50 <lambdabot> zip _      _      = []
17:23:54 <Cale> chrisblake: zip is zipWith (,)
17:24:06 <startling> chrisblake, zipWith (++) is it
17:24:44 <chrisblake> > zipWith (++) ["1", "2"], ["3", "4"]
17:24:46 <lambdabot>   <hint>:1:24: parse error on input `,'
17:24:46 <cswords> startling: you mean, the entire module's definitions?
17:24:51 <chrisblake> > zipWith (++) ["1", "2"] ["3", "4"]
17:24:52 <lambdabot>   ["13","24"]
17:25:06 <chrisblake> > zip ["1", "2"] ["3", "4"]
17:25:08 <lambdabot>   [("1","3"),("2","4")]
17:25:16 <chrisblake> oh, okay; they're different. thanks guys
17:25:41 <Kron> what happens if you give lambdabot an infinite list to show?
17:25:48 <Kron> does he destroy IRC forever?
17:25:51 <Kron> (she? it?)
17:25:52 <copumpkin> no
17:25:55 <copumpkin> > repeat 1
17:25:57 <triliyn> It uses ...
17:25:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:26:00 <Kron> ahhh
17:26:12 <Kron> hmmmm
17:26:15 <triliyn> > fix show
17:26:17 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:26:17 <sm> look closely at the dots, it's all in there
17:26:17 <Kron> does lambdabot have memory?
17:26:20 <startling> Kron: (she)
17:26:28 <Kron> gotcha
17:26:33 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
17:26:34 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:26:35 <startling> Kron: lambdabot remembers some stuff
17:26:38 <Kron> what is up with advanced functional programmers and female bots
17:26:43 <prooftechnique> Last I knew, lambdabot was a girl
17:26:46 <Kron> it's a pattern
17:26:49 <startling> e.g. with @let or with @remember for quotes
17:27:01 <prooftechnique> Kron: Have you ever seen 2001?
17:27:05 <Kron> no!
17:27:07 <Kron> read the book though
17:27:09 <prooftechnique> That's why you don't have male bots
17:27:17 <startling> prooftechnique, I was 8
17:27:26 <Kron> ah
17:27:26 <cswords> I still don't understand how to do this :[
17:27:30 <Kron> poor HAL ;_;
17:27:36 <startling> cswords: lemme find an example for you
17:28:08 <startling> cswords: https://github.com/startling/coatl/blob/master/Language/Coatl/Abstract.hs#L34
17:28:08 <sm> prooftechnique: because... a female AI could never act irrationally ?
17:28:30 <startling> that's kind of a bad example, since it lists itself
17:28:40 <prooftechnique> The robot apocalypse needs a woman's touch, that's all~
17:28:42 <Kron> are you insinuating that a female could ever act irrationaly?
17:28:44 <Kron> sexist D:
17:28:57 * Kron flames sm on tumblr
17:29:24 <Kron> I've read research that female voices are easier to listen to and comprehend in stressful situations
17:29:33 <Kron> which is why computer voices are female a lot
17:30:49 <Kron> though I don't remember where I read this research so it's practically anecdotal I guess
17:30:49 <hpc> Kron: because they are commonly used with stressful voice recognition ;)
17:30:49 <cswords> startling: hahaha, that did what I needed.
17:30:49 <bz> what happens if i want to curry something other than the first argument of a function?
17:30:49 <cswords> Well, sort of.
17:30:49 <bz> eg say take a section with only the 3rd argument applied?
17:30:49 <Kron> you'll have to use stuff like flip
17:30:49 <bz> (deliberately avoiding currying 1st or 2nd since flip exists)
17:30:53 <Kron> which basically manipulate functions to shift arguments around
17:31:04 <bz> Kron: yeah but how would you even use flip with arguments 3, 4, ..?
17:31:20 <Kron> I'm not exactly sure
17:31:21 <Kron> I mean
17:31:34 <Kron> trivially you could do this: (\x -> foo x 2 3)
17:31:39 <Kron> and bam you have a curried function to use
17:31:48 <Kron> but I dont' know of any faster syntactically neater way
17:31:49 <bz> yeah but i want to take a section
17:31:52 <triliyn> bz: I don't think you can do it with sections
17:31:56 <novochar> What are the @ and # symbols in http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Char.html#chr
17:32:11 <bz> triliyn: fair enough, but i just want to sure
17:32:27 <cswords> startling: thank you!
17:32:28 <startling> cswords: do you see how the syntax works?
17:32:34 <prooftechnique> bz: Can you give an example?
17:32:35 <startling> cswords: you're welcome!
17:33:12 <sm> novochar: NAME@PATTERN lets you refer to the overall matched thing by NAME. THING# is some kind of GHC primitive value reference
17:34:08 <novochar> thank you sm
17:34:37 <bz> prooftechnique: eg let f a b c = a*b - c in :t (f 1 2)
17:34:46 <prooftechnique> as-patterns are awesome. I keep waiting for Idris to have a nice way to use them
17:34:49 <sm> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/primitives.html
17:35:05 <bz> prooftechnique: it's easy to curry the first n arguments, but is it possible to take a section kinda like (f a b 3) ?
17:35:06 <novochar> I was reading http://www.haskell.org/onlinereport/exps.html#sect3.17.1
17:35:18 <hpc> novochar: a quick note on "#", it is actually a part of the name of the thing, and doesn't take special meaning
17:35:31 <hpc> it's like the convention of using a single quote ' for strict variants of functions
17:36:06 <hpc> it requires an extension only to change parsing such that "#" is treated as a letter instead of a symbol
17:37:08 <bz> eg in python, functools.partial can kinda skip ahead on the filled in arguments with kwargs
17:37:15 <bz> meh i'm talking out of my ass here
17:38:08 <novochar> thank you hpc
17:38:29 <prooftechnique> bz: pl says your example comes out to flip flip 3 . ((-) .) . (*), if I read you correctly
17:38:51 <prooftechnique> @pl let f a b c = a * b - c in (\a b -> f a b 3)
17:38:54 <lambdabot> flip (flip . fix (const (((-) .) . (*)))) 3
17:38:55 <lambdabot> optimization suspended, use @pl-resume to continue.
17:39:02 <prooftechnique> @pl-resume
17:39:09 <lambdabot> flip (flip . fix (const (((-) .) . (*)))) 3
17:39:09 <lambdabot> optimization suspended, use @pl-resume to continue.
17:39:13 <novochar> prooftechnique: What is pl?
17:39:15 <bz> yeah let's not break lambdabot
17:39:23 <startling> the @pl-resume thing is a bug
17:39:27 <startling> it won't do anything more
17:39:30 <prooftechnique> novochar: Pointfree, or pointless
17:39:52 <prooftechnique> Yeah, that's why I used it on my machine :D
17:40:12 <prooftechnique> > flip flip 3 . ((-) .) . (*) $ 2 4
17:40:14 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> c))
17:40:14 <lambdabot>    arising f...
17:41:41 <prooftechnique> > (flip flip 3 . ((-) .) . (*)) 2 4
17:41:43 <lambdabot>   5
17:41:47 <prooftechnique> There we go
17:42:15 <prooftechnique> That is a hilarious way to write that
17:42:26 <bwe> Hi, conduit-1.0.8 failed during the building phase on my Mac OS X.
17:42:48 <bz> god my head hurts just reading it
17:42:59 <srhb> bxc: Don't :P
17:43:20 <hpc> prooftechnique: you might try submitting patches to acme-php sometime ;)
17:44:15 <srhb> hpc: I always laugh when I read the description on Hackage.
17:44:33 <hpc> srhb: i personally like acme-microwave better
17:44:51 <hpc> any excuse to use the word "vexacious"
17:44:51 <bwe> A "rm -r ~/.cabal ~/.ghc" did not help. Log: http://lpaste.net/3203560713893183488
17:45:02 <prooftechnique> @hackage acme-colosson
17:45:02 <lambdabot> http://hackage.haskell.org/package/acme-colosson
17:45:08 <prooftechnique> acme-colosson is clearly the best
17:45:37 <geekosaur> bwe: see the end of the /topic
17:45:41 <prooftechnique> I like acme-realworld, too, but I'm worried about feature creep
17:45:43 <srhb> hpc: I found 200 :: Microwave to be better than that description. :P
17:45:45 <prooftechnique> Also, overpopulation
17:46:31 <hpc> prooftechnique: sorry, but hasslich = unschoen is just the funniest damn thing on hackage
17:46:34 <hpc> it's funnier than my stuff
17:46:59 <prooftechnique> I was gonna mention that :D
17:47:39 <moops> are HFT and test-framework different things?
17:48:08 <bwe> geekosaur: merci.
17:48:59 <nstdloop> why is this throwing me a warning?
17:49:10 <nstdloop> https://gist.github.com/reem/643ba2c92224f6979e99
17:49:29 <srhb> nstdloop: What's the warning?
17:49:43 <enthropy> defaulting
17:49:51 <nstdloop> yes
17:50:00 <nstdloop> defaulting the following constraints to Integer... etc.
17:50:06 <nstdloop> Says it has to do with the Enum
17:50:08 <nstdloop> [1..]
17:50:13 <enthropy> nstdloop: the reason for it is because earlier versions of haskell defaulted to Int not Integer or something like that
17:50:32 <enthropy> and some programs behave differently...
17:50:38 <nstdloop> enthropy: how do I fix it?
17:50:46 <enthropy> you can write    [ 1 :: Int .. ]
17:50:55 <enthropy> you can write    [ 1 :: Integer .. ] -- another choice
17:51:00 <nstdloop> ah
17:51:00 <nstdloop> ok
17:51:04 <srhb> or [1..] :: [Integer]
17:51:27 <srhb> Which is slightly less ugly. :P
17:51:28 <enthropy> or  [ 11 ^ (x :: Integer) |  ... ]
17:51:34 <Cale> Uh, I would just ignore that warning
17:51:39 <enthropy> me too
17:51:40 <srhb> Same.
17:51:40 <Cale> It's safe to let it default to Integer
17:51:48 <nstdloop> I thought so
17:51:51 <nstdloop> but I use vim with ghc-mod
17:52:01 <nstdloop> so it's kind of annoying to have it throwing the warning every time I :W
17:52:03 <nstdloop> :w*
17:52:17 <enthropy> {-# OPTIONS_GHC -w #-}
17:52:19 <srhb> Presumably you can tell it to ignore that specific warning? (Just guessing)
17:52:50 <nstdloop> I just added the signature
17:52:58 <nstdloop> Less effort
17:53:14 <nstdloop> On that subject, does anyone have any input on whether I should use ghc-mod, hdevtools, or hlint?
17:53:28 <nstdloop> I kind of just used ghc-mod because it is the default, but if there is a better option...
17:53:47 <enthropy> they don't do exactly the same thing I think
17:53:55 <enthropy> dunno about hdevtools
17:54:12 <johnw> hdevtools and hlint complement each other
17:54:14 <srhb> Maybe you can tell it to disable -fwarn-type-defaults
17:54:21 <johnw> ghc-mod does a bit more than hdevtools, but is much slower
17:54:45 <enthropy> srhb: -fno-warn-type-defaults I would thing
17:54:47 <enthropy> k
17:55:01 <srhb> enthropy: Yeah, but I don't know how to pass it to ghc-mod
17:55:16 <enthropy> probably it will read the OPTIONS_GHC pragma
17:55:18 <johnw> ghc-mod -x -fno-warn-type-defaults check ...
17:55:25 <srhb> Well, that was simple :P
17:55:26 <johnw> oh, -g, not -x, I think
17:56:03 <nstdloop> I use it in vim, not from the CL
17:56:36 <nstdloop> it's fine, I was just wondering if there was a specific program that is better. I like that ghc-mod doesn't shut up because it makes me learn these things.
17:59:49 <prooftechnique> nstdloop: My understanding is that hdevtools is significantly faster, so for things like a BufWrite autocmd, hdevtools is nicer for larger modules. ghc-mod does some heavier lifting, so it's slower but I think it can do more
18:00:15 <nstdloop> Most of my work is in fairly short files
18:00:23 <nstdloop> so
18:01:06 <prooftechnique> You probably won't notice any huge differences, but they can definitely complement each other. Also, IIRC, hdevtools uses the quickfix window in Vim, but I think ghc-mod does it's own thing
18:01:15 <prooftechnique> *its
18:05:55 <cfoch> hello. How should I ident this code?
18:05:57 <cfoch> http://fpaste.org/51652/38361645/
18:06:07 <cfoch> line 8
18:08:15 <enthropy> cfoch: I think it can work if you have:       let dogs = do [
18:08:38 <enthropy> thanks to the wonders of -XNondecreasingIndentation
18:09:20 <enthropy> normal people will suggest to put at least one space on lines 9-12
18:09:48 * hackagebot rewrite 0.8 - open file and rewrite it with new contents  http://hackage.haskell.org/package/rewrite-0.8 (OmariNorman)
18:10:10 <cfoch> enthropy: no... the problem is with the idendation of the list of tuples. If I type it in an only one line, it works...
18:10:28 <enthropy> did you try my suggestion?
18:10:48 <cfoch> enthropy: yes: dogChoice.hs:9:9: parse error (possibly incorrect indentation)
18:11:18 <srhb> I see nothing wrong with the indentation in said paste.
18:11:31 <carter> leroux: you were saying
18:11:45 <leroux> https://gist.github.com/leroux/7293870 <-- what would you call these if not metamorphisms?
18:11:58 <leroux> I don't know much category theory so I don't know.
18:12:29 <srhb> cfoch: Are you sure you've pasted the actual code, with the actual whitespace characters?
18:12:35 <novochar> How would you open a file and explore its contents from within ghci?
18:12:43 <startling> readFile?
18:12:47 <startling> :e ?
18:12:51 <startling> :! vim ?
18:13:05 <startling> open another terminal
18:13:07 <cfoch> srhb: yes... it's the real code I've test
18:13:15 <lpaste> enthropy pasted “indentation” at http://lpaste.net/95211
18:13:32 <enthropy> that's what I tried to say by adding a space
18:13:35 <novochar> thanks startling
18:13:36 <srhb> cfoch: Ah yes, I see it now
18:13:50 <carter> leroux:  why are you backing * and + into the same type?
18:13:56 <carter> Either and Pair
18:14:00 <srhb> cfoch: The let opens a block so everything indented to the same level as d is understood as subsequent let bindings
18:15:01 <carter> *baking
18:15:03 <cfoch> srhb: Oh... I had to ident twice... and... it worked
18:15:06 <novochar> let a = readFile "foo.txt"
18:15:08 <novochar> :t a
18:15:08 <cfoch> twice!
18:15:09 <lambdabot> Expr
18:15:25 <leroux> carter: Because I was trying to use a type definition instead of another data.
18:15:40 <leroux> Defining the type in terms of other ADTs.
18:15:44 <srhb> cfoch: As long as the items are indented further than the 'd' in 'dogs' all is fine
18:16:01 <carter> leroux: you mean https://gist.github.com/leroux/7293870#file-noob-hs-L35?
18:16:08 <carter> you didn't link to the lines you were asking about
18:16:19 <leroux> Yep.
18:16:31 <carter> leroux: OOOO, you're talking abut BIJECTIONS
18:16:34 <carter> as in
18:16:41 <leroux> Is that what they're called..?
18:16:48 <carter> well
18:16:57 <carter> an isomorphism
18:17:00 <carter> is a bijection
18:17:14 <carter> you're kinda rediscovering Data.Generic
18:17:15 <carter> :)
18:17:39 <cfoch> thanks everybody
18:17:45 <carter> leroux: http://hackage.haskell.org/package/syb-0.1.0.2/docs/Data-Generics.html
18:17:50 <novochar> a is of type IO String. Can IO String be converted to String?
18:18:03 <pqmodn> novochar: no
18:18:28 <pqmodn> novochar: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
18:18:28 <novochar> This looks useful: http://stackoverflow.com/questions/1675366/a-haskell-function-of-type-io-string-string
18:18:48 <carter> leroux: am i making sense?
18:18:59 <leroux> Yeah. I'm looking at the lib.
18:19:15 <carter> leroux: theres A LOT of generic libs
18:19:21 <carter> SYB is just one
18:19:29 <carter> theres also the generics that GHC comes wiht
18:19:31 <enthropy> there is a rather good review article
18:19:32 <carter> i forget where those are
18:19:40 <enthropy> GHC.Generics?
18:19:55 <structur_> enthropy: review article?
18:20:07 <leroux> carter: What would you call an ADT defined in terms of an Algebra?
18:20:13 <carter> an ADT
18:20:23 <leroux> Anything more specific?
18:20:31 <enthropy> structur_: a paper that compares 5 or so different approaches
18:20:42 <structur_> I'm interested
18:20:48 <structur_> do you have the title?
18:20:59 <enthropy> the second one here http://www.haskell.org/haskellwiki/Research_papers/Generics
18:21:06 <enthropy> "Comparing Libraries for Generic Programming in Haskell"
18:21:09 <structur_> thanks :)
18:21:21 <moops> do any testing frameworks let you have lists of tests?
18:21:28 <moops> hspec and HTF dont seem to
18:21:31 <leroux> enthropy: Thanks
18:21:49 <prooftechnique> moops: I think you can use QuickCheck that way
18:22:03 <startling> moops, sure. the test thingies are usually Monad, so you can mapM_ over a list of tests
18:22:13 <prooftechnique> And realistically you can probably use some sort of mapM_ over them
18:22:23 <prooftechnique> Or what startling said :D
18:22:33 <moops> HTF uses specially named functions, not monads :\
18:23:02 <moops> ill try that
18:23:42 <enthropy> is there an approach for open recursion/OOP which doesn't use IO for updates to the original object?
18:24:07 <carter> leroux: ask folks on channel
18:24:09 <carter> i'm the wrong person :)
18:24:17 <carter> or #haskell-lens maybe has folks
18:24:50 * hackagebot rewrite 0.10 - open file and rewrite it with new contents  http://hackage.haskell.org/package/rewrite-0.10 (OmariNorman)
18:24:56 <leroux> carter: Brb. Food.
18:25:01 <leroux> Will do when I get back.
18:25:35 <enthropy> Oleg/Hinze's OOHaskell seems to settle on using IO
18:26:21 <enthropy>  openMethod :: self -> Int -> String -> IO () -- OOHaskell approach
18:27:08 <enthropy>  openMethod :: self -> Int -> String -> self -- what I'm looking for
18:27:58 <enthropy> but actually I guess I need  openMethod :: self -> closedSelf -> Int -> String -> closedSelf
18:30:15 <mm_freak_> enthropy: what are you trying to do?
18:30:59 <enthropy> express http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html#t:LayoutClass in a different way
18:32:03 <lpaste> enthropy pasted “layout prototype” at http://lpaste.net/95213
18:32:46 <enthropy> so things are kind of working, but I think the problem is that there is no constraint on the `a' type (of the closed record)
18:36:59 <mm_freak_> enthropy: what's wrong with LayoutClass?
18:37:24 <mm_freak_> i mean what problem are you trying to solve?
18:40:22 <enthropy> well for syntax trees it is supposedly interesting to have stuff like     data OpenExp e = Apply e e
18:41:06 <enthropy> then (Mu OpenExp) is a tree that's not useful
18:41:19 <mm_freak_> data Expr p a = Apply (Expr p a) (Expr p a) | Prim p | …
18:41:26 <enthropy> but you can make variations on OpenExp, and close it later on
18:41:27 <enthropy> yes
18:41:42 <enthropy> you're doing the recursion already
18:42:01 <mm_freak_> data Expr p a = Apply a a | Prim p | …
18:42:16 <enthropy> putting the recursion off means you can provide a "prototype" which gets extended with more stuff later on
18:42:35 <mm_freak_> you can extend using the 'p'
18:42:41 <enthropy> yes
18:43:55 <mm_freak_> enthropy: and that's the approach i prefer, because it is really neat with type classes
18:44:35 <mm_freak_> myExpr :: (Feature1 p, Feature2 p) => Expr p a
18:44:48 <mm_freak_> myExpr = App (feature1 …) (feature2 …)
18:59:30 <Shin-LaC> why do so many datatypes have incompatible versions of length? why isn't there a LengthHaving type class so I can have both lists and texts in my program and use "length" without a prefix?
19:02:52 <mm_freak_> Shin-LaC: because they are difficult to combine
19:03:33 <Shin-LaC> how so?
19:04:01 <Fuuzetsu> Shin-LaC: Make one for your program and give them all an instance if you really want a unified length-like
19:04:20 <structuralist> is there a special name for arguments passed the the constructor of a type? components?
19:04:27 <structuralist> to the*
19:04:37 <Fuuzetsu> ``types''
19:04:42 <structuralist> er sorry
19:04:45 <structuralist> value constructor
19:04:53 <structuralist> constructor of a value
19:05:03 <prooftechnique> Parameters?
19:05:03 <enthropy> there is a classy prelude or some such
19:05:18 <prooftechnique> Yeah, I think classy-prelude does something like that
19:05:30 <drlemon> hi
19:05:38 <prooftechnique> Shin-LaC: Have you seen the underlying structure of a Text value?
19:05:43 <drlemon> this is a very big channel
19:05:54 <structuralist> something that distinguishes them from things bound by ordinary functions
19:06:06 <Shin-LaC> prooftechnique: no, but I don't see why that should matter
19:06:17 <Shin-LaC> obviously each instance would have its own implementation
19:09:09 <dmwit> Shin-LaC: I think the real answer to your question is because it's not clear exactly what the right abstraction is.
19:09:10 <prooftechnique> It seems like a major effort to save a couple of characters, is all
19:09:16 <dmwit> There's been lots of attempts at classes for container-like things.
19:09:40 <dmwit> But they end up being unwieldy and ad-hoc; none has ever really caught on in a meaningful way.
19:10:12 <dmwit> Not that this has ever stopped anyone from throwing another hat in the ring. =3
19:10:57 <Fuuzetsu> Not sure if a joke on ‘ring’
19:11:14 <dmwit> err, not intentionally
19:11:29 <dmwit> But I'll happily take credit for it if it seems funny, hehe.
19:11:50 <prooftechnique> Shin-LaC: I guess you could look at MonoFoldable
19:11:55 <prooftechnique> @hackage mono-foldable
19:11:55 <lambdabot> http://hackage.haskell.org/package/mono-foldable
19:12:04 <dmwit> There's also edison and half a dozen others.
19:12:08 <Shin-LaC> http://ghc.haskell.org/trac/ghc/wiki/Status/Oct13 <- this mentions "Overloaded record fields - Adam Gundry implemented the overloaded records field proposal as part of the Haskell.org 2013 GSoC. This work will make it possible to not only have overloaded record field names, but also enable a wealth of other nice features, like polymorphic update/lookup, and automatically turning record fields into lens."
19:12:21 <Shin-LaC> lookup is in a similar situation to length
19:13:36 <prooftechnique> MFoldable will at least get you length for anything you can make a sensible foldr for
19:13:42 <enthropy> @type lookup
19:13:43 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
19:13:47 <enthropy> @type Data.Map.lookup
19:13:48 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
19:14:37 <enthropy> I don't think that records proposal stuff is going to give you a lookup that can take either of those types
19:15:03 <enthropy> M.Map could very well be a record with a field that does the lookup
19:15:34 <enthropy> but it seems unlikely you could add a field to lists
19:15:55 <Shin-LaC> yeah, I'm not sure exactly what they have in mind
19:16:27 <Shin-LaC> but at least making these basic functions polymorphic seems to be on the map somehow
19:17:44 <mm_freak> structuralist: fields, arguments, components, …
19:17:48 <mm_freak> "field" is most common
19:18:04 <structuralist> ah thanks
19:18:34 <mm_freak> you could call them factor values/elements
19:22:13 <thirsteh> any tips on compiling something that needs perl on x64 Windows (msys or cygwin--tried either)? Can't for the life of me get it to work
19:22:32 <thirsteh> ghc/cabal keeps complaining the sos aren't there
19:23:22 <structuralist> mm_freak: yeah I was considering "factors of summands" but that seemed verbose :P
19:36:20 <mizu_no_oto> Can you start up ghci with language extensions like OverloadedStrings?
19:36:39 <johnw> mizu_no_too: just type:set -XOverloadedStrings
19:36:46 <johnw> ":set -XOverloadedStrings"
19:36:48 <johnw> or put that in ~/.ghci
19:36:49 <mizu_no_oto> Also, has anyone used Shelly before?
19:36:52 <mizu_no_oto> Thanks
19:36:58 <johnw> yes, I use Shelly quite a lot
19:37:11 <mizu_no_oto> How does running things using sudo work?
19:37:14 <structuralist> mizu_no_oto: -XOverloadedStrings is also a commandline argument
19:37:27 <johnw> run_ "sudo" ["/bin/ls"]
19:37:42 <mizu_no_oto> Can you supply a username and password to that?
19:37:46 <johnw> no
19:38:01 <mizu_no_oto> The user just needs to already have done that?
19:38:05 <johnw> yes
19:38:18 <johnw> or have a special exemption in /etc/sudoers for a specific command+arguments from a specific user
19:38:49 <mizu_no_oto> Is it generally impossible to provide additional input to commands using Shelly?
19:39:07 <enthropy> @type readProcess
19:39:08 <lambdabot> Not in scope: `readProcess'
19:39:13 <enthropy> @hoogle readProcess
19:39:13 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
19:39:14 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
19:40:36 <johnw> mizu_no_too: how do you mean?  you can pass whatever arguments or stdin that you like
19:40:51 <johnw> i'm not sure about its support for reading passwords from stdin though
19:42:42 <prooftechnique> Does it not farm authorization out to the system?
19:44:22 <geekosaur> um? shell commands don't work that way
19:44:35 <geekosaur> but shell commands also typically open /dev/tty directly to read passwords
19:44:38 <mizu_no_oto> So you can generally provide input (like 'y' or whatever to apt-get) but you can't easily provide usernames and passwords (say, to hg or whatever)
19:47:25 <geekosaur> so to intercept that you're talking about running it in its own session under a pty, and then using it in a pipeline is more complex (especially corner cases like signal handling since it won't see ^C unless the parent pushes it through the pty or forwards it "manually")
20:42:32 <jle`> i'm writing an article about haskell's idea of purity, and that main is really a function that returns an io object that can be compiled to machine code or whatever.  how do i properly illustrate how it's "different" from a compiled language like C, which arguably can be thought about as also, after being run through a compiler, an "IO object"/machine code of sorts?
20:43:07 <jle`> i mean ... it's obviously different, but I don't know how most effectively counter "Your program isn't a list of instructions, but returns a list of instructions?  isn't that what C and its compiler does?"
20:43:54 <jle`> i can probably explain it in a paragraph or two but i wanted some kind of elegant, hits-home-right-away phrase that can nail it elegantly
20:44:39 <Iceland_jack> jle`: Haskell makes a distinction between evaluation and execution, other languages don't
20:45:38 <carter> haskell still generates assembly as the end though
20:46:33 <jle`> maybe it's just the idea that the compiler enforces where "execution"/side effects can occur, whereas other languages it is arbitrary. but then it just sounds like a static checking tool rather than a fundamental shift in thought
20:47:40 <Iceland_jack> Your reference to an ‘IO object’ sounds a bit confused
20:48:46 <Iceland_jack> You can read this first: http://www.haskell.org/haskellwiki/Introduction_to_IO
20:48:48 <jle`> as i understand it, in haskell, `main` returns a data structure that represents computation
20:49:18 <jle`> *a computation
20:49:23 <Iceland_jack> The minutia of what gcc, clang, ghc, … eventually do with your pure code afterwards is not the point but rather the compile-time separation of the pure and effectful worlds
20:49:54 <jle`> yeah, once i get that data structure that represents a computation, i can turn that data structure into machine code, or javascript code, or a screenplay, or w/e i want
20:50:13 <jle`> but the creation of that data structure is a pure function/pure process
20:50:23 <edwardk> aavogt, b2coutts, scshunt: i was talking to someone up at waterloo about heading up that way to give a talk, but I've managed to lose track of who it was! was it any of you?
20:51:38 <jle`> "that's the case in Haskell.  in C, however,  _______"
20:51:40 <enthropy> edwardk: I am aavogt, but I don't organize anything at uwaterloo
20:51:57 <jle`> i guess i am trying to find an effective parallel in words that highlights the key differences
20:52:04 <jle`> with direct analgies
20:52:17 <edwardk> enthropy: ok, just skimming folks whose names i could think of with a waterloo address =)
20:52:36 <jle`> to me they are so different they aren't even comparable ... but i'm trying to find some way to directly compare.
20:53:54 <edwardk> i talked to whomever it was by /msg and usually have that logged, but after a machine upgrade that flag somehow wound up shut off for a couple of months which i didn't notice until grep didn't work =)
20:54:03 <enthropy> if something does get organized I'd be interested
20:54:36 <enthropy> as I'm in Guelph now, which is pretty close by
20:54:49 <edwardk> iirc the original goal was to do something in december, but in the meantime my schedule has filled up, so it'd probably have to wind up being something like march.
20:55:10 * hackagebot wai-extra 1.3.4.6 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.4.6 (MichaelSnoyman)
20:55:46 <Iceland_jack> Sure, but that doesn't matter
20:56:16 <Makoryu> Did GHC 7.8 ever come out
20:56:24 <Makoryu> It just occurred to me that I hadn't heard anything
20:56:39 <enthropy> edwardk: probably good to ask in #csc
20:56:45 <enthropy> if you didn't already
20:58:04 <Iceland_jack> jle`: What is this article for?
20:59:09 <jle`> Iceland_jack: oh just my own personal blog
20:59:31 <jle`> i wanted to kind of illuminate the compromise-less reconciliation of i/o and purity
20:59:43 <jle`> to my ocaml friends who maintain that i/o necessarily breaks purity
20:59:47 <Iceland_jack> Well you don't seem completely certain about it yourself
21:00:13 <Iceland_jack> There are plenty of resources for that around, entries at the HaskellWiki for instance
21:00:39 <jle`> just wanted to contribute something myself :)
21:00:45 <jle`> hopefully i don't convolute things too much
21:01:08 <jle`> is there a flaw in my interpreation of io in haskell?
21:01:33 <Iceland_jack> You should ignore all the compiler details
21:02:24 <jle`> hm i guess if i do stop before the compiler, i avoid the problems in distinction at the lower levels
21:03:12 <Iceland_jack> http://www.haskell.org/haskellwiki/Introduction_to_IO and http://www.haskell.org/haskellwiki/IO_inside are OK introductions: searching for “why is Haskell pure” gives a ton of stuff as well
21:03:18 <jle`> i do try to emphasize that compiler stuff/machine code is detached from the language, in the same way that human thought is detached from vocalizations that convey them
21:04:06 <jle`> thank you for the references
21:05:10 <Iceland_jack> http://www.reddit.com/r/haskell/comments/1874at/io_is_pure/ this may prove helpful as well
21:05:42 <Iceland_jack> you can point your OCaml friend to any of these or just direct them to #haskell if they have questions
21:06:24 <Iceland_jack> A common analogue is shell scripts:
21:06:25 <Iceland_jack>     "ls ; ls"
21:06:25 <Iceland_jack> is a ‘pure’ shell script since it's just a string
21:06:57 <Iceland_jack> so you can evaluate something like:
21:06:57 <Iceland_jack>     "ls" ++ ";" ++ "ls"
21:06:57 <Iceland_jack> and it's a pure action
21:07:26 <Iceland_jack> in the same way if you have ‘ls ∷ IO ()’ you can do:
21:07:26 <Iceland_jack>     ls >> ls
21:08:17 <Iceland_jack> Here's a quote by Tekmo from the Reddit thread:
21:08:17 <Iceland_jack>     The distinction between Haskell and other languages is that IO action order is independent of evaluation order. If you understand this, you basically understand Haskell IO.
21:09:01 <Iceland_jack> In fact in the Reddit thread you can see an argument about the very thing you just asked about :) arguments are often useful to learning
21:09:27 <enthropy> evaluation order is a fuzzy thing
21:10:22 <jle`> Iceland_jack: thanks :)  the reddit article is very close to my interests
21:10:53 <Iceland_jack> In Python if you do:
21:10:53 <Iceland_jack>     ⅰ  a = raw_input()
21:10:53 <Iceland_jack>     ⅱ  print a, a
21:10:53 <Iceland_jack> you run 'raw_input()' on line ⅰ and print the same output twice on line ⅱ
21:12:25 <Iceland_jack> jle`: You're welcome
21:16:37 <mm_freak> when trying to decompress a .gz file using pipes-zlib i get a ZlibException (-3)
21:16:42 <mm_freak> am i missing something?
21:17:13 <mm_freak> Pb.fromHandle h >-> decompress defaultWindowBits >-> Pb.stdout
21:17:28 <mm_freak> and: import qualified Pipes.ByteString as Pb
21:17:34 <Iceland_jack> -- * #define Z_DATA_ERROR   (-3)
21:18:08 <Iceland_jack> so you have a data error :) that's all the help I am
21:18:28 <mm_freak> why is that?  is it that zlib can't actually decompress full gzip files, but only their payload?
21:18:48 <Iceland_jack> did you open in as a binary file?
21:18:53 <mm_freak> (gunzip decompresses it just fine)
21:19:02 <Iceland_jack> *open it
21:19:20 <joelteon> You know what I hate is when people use CPP defines and then never test the code.
21:19:44 <Iceland_jack> Hate is a strong word :)
21:20:26 <joelteon> I don't like it very much.
21:20:31 <Iceland_jack> lol
21:20:36 <startling> Iceland_jack, what we need here is a /really/ strong one
21:20:56 <Iceland_jack> Detest!
21:21:06 <Iceland_jack> mm_freak: I'm just writing things that I find as a result of searching online, “Z_DATA_ERROR if the deflate data is invalid or incomplete”
21:21:59 <Iceland_jack> ‘Am very much not partial to!’
21:21:59 <mm_freak> Iceland_jack: it's withBinaryFile-opened and i created it a few hours ago using gzip
21:22:02 <mm_freak> weird =/
21:22:05 <Iceland_jack> weird…
21:22:12 <dmwit> pipes-zlib depends on zlib.
21:22:20 <dmwit> Do you get the same error if you use straight zlib?
21:22:23 <Iceland_jack> mm_freak: Maybe you could try using ‘zlib’ and not ‘pipes-…’
21:22:24 <Iceland_jack> yeah
21:22:29 <dmwit> i.e. with a more traditional, non-pipes approach
21:23:46 <Iceland_jack> if that fails you can try a different language that has bindings to zlib, if decompressing works with gunzip to me that indicates there is some problem with how you initialized something or how you opened some files
21:24:51 <mm_freak> dmwit: same thing, except that i get a more useful error message
21:24:56 <mm_freak> "*** Exception: Codec.Compression.Zlib: incorrect header check
21:25:15 <mm_freak> i wonder if "zlib" and "gzip" are actually the same thing, or if zlib is really just a component of gzip
21:26:17 <mm_freak> compression and decompression work fine…  it only fails when trying to decompress a .gz file created by gzip
21:26:18 <dmwit> What does file say about your file
21:26:19 <Iceland_jack> mm_freak: How about compressing and then decompressing with zlib?
21:26:19 <dmwit> ?
21:26:28 <mm_freak> Iceland_jack: that could work
21:27:12 <mm_freak> dmwit: blah.txt.gz: gzip compressed data, was "blah.txt", from Unix, last modified: Tue Oct 15 19:58:33 2013
21:27:33 <dmwit> "The gzip header is larger than the zlib header, as it stores a file name and other file system information."
21:27:40 <dmwit> from https://en.wikipedia.org/wiki/Zlib
21:28:25 <Iceland_jack> but 'zlib' supposedly works with gzip
21:28:44 <Iceland_jack> not sure about pipes-zlib
21:28:59 <mm_freak> d'oh
21:29:05 <dmwit> Well, there's C.C.GZip and C.C.Zlib
21:29:08 <dmwit> presumably they're different
21:29:15 <mm_freak> dmwit: yeah, just found it =)
21:29:19 <Iceland_jack> lol
21:29:30 <Iceland_jack> mm_freak: Try it with GZip and tell us how it works!
21:29:49 <mm_freak> i'll have to write a pipes wrapper first…
21:29:58 <dmwit> Whereas pipes-zlib doesn't seem to offer gzip support.
21:30:02 <Iceland_jack> Really?
21:30:04 <Iceland_jack> That's odd
21:30:14 <mm_freak> it's not that odd really
21:33:29 <dmwit> To be honest, I don't really understand how the pipes-zlib package can usefully depend on zlib. There's essentially only a function ByteString -> ByteString.
21:33:39 <dmwit> Hard to imagine that being enough of an API to make a useful pipe out of.
21:33:50 <dmwit> (Or else what's the point of pipes? =)
21:35:16 * hackagebot texmath 0.6.5.1 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.5.1 (JohnMacFarlane)
21:37:02 <dmwit> Oh, I guess it doesn't use the zlib API at all, just some of its data types.
21:37:09 <dmwit> makes more sense now
21:39:16 <mm_freak> dmwit: i guess that's why pipes-zlib supports zlib, but not gzip
21:39:25 <mm_freak> zlib can be performed chunk by chunk
21:39:39 <mm_freak> that's probably also why the window bits parameter is mandatory
21:39:47 <mm_freak> but yeah, it's odd
21:40:09 <mm_freak> i guess i'll just pipe the data through gunzip before feeding it into my program, but that sucks =/
21:41:35 <mm_freak> seems like i could have used xz right away…  i didn't because i wanted to be compatible with pipes-zlib
21:41:37 <ozataman> Has anyone had any problems with the zlib package? We've had pointer leak-like gradual memory bloat problems in production that went away after simply disabling zlib compression.
21:43:39 <carter> ozataman: howre you using zlib?
21:44:31 <ozataman> we make a Prism' that combines Serialize and zlib, then review/preview during adding/popping from redis queues
21:44:52 <carter> ozataman: have you tried snappy or lz4?
21:45:12 <carter> lz4 should be fine
21:45:19 <ozataman> Not yet - didn't want the snappy c++ dep and haven't looked into lz4
21:45:19 <carter> if you just want to compress for bandwidth
21:45:24 <carter> lz4 has no bugs
21:45:30 <carter> i fixed the biggy
21:45:31 <nstdloop> So I was trying out some of the ghc flags and I tried to use -C, but it's throwing Compiler not unregisterised, so ignoring -C
21:45:39 <ozataman> ok, good to know - we'll give it a shot
21:45:51 <carter> ozataman: i just darcs cloned zlib
21:45:53 <carter> ill take a look
21:46:02 <carter> lz4 has a really gnarly bug
21:46:12 <carter> the fix was just 1 character :)
21:46:20 <mm_freak> carter: just looked into lz4
21:46:25 <carter> mm_freak: oh?
21:46:28 <mm_freak> it too doesn't have an incremental interface
21:46:42 <carter> incremental in which sense?
21:46:52 <carter> lz4 is meant for chunks anyways
21:46:53 <ozataman> carter: haha, nice
21:47:00 <mm_freak> feed it strict bytestrings piece by piece
21:47:44 <pharaun> what was the gnarly bug?
21:47:47 <carter> https://github.com/mwotton/lz4hs/pull/6/files
21:48:03 <nstdloop> anyone on the -C issue?
21:48:28 <carter> nstdloop: whats -C do?
21:48:32 <carter> have you read the manual?
21:49:01 <carter> pharaun: mm_freak  basically for decompression, we already knew what the result size would be
21:49:09 <nstdloop> according to ghc --help, ghc -C compiles the module into C as a .hc file
21:49:09 <carter> but the code made a booboo
21:49:18 <carter> nstdloop: try -fvia-c
21:49:19 <carter> with -C
21:49:34 <pharaun> ah
21:49:35 <carter> nstdloop: WHY are youdoing this?
21:49:44 <nstdloop> carter: just playing around, really
21:49:58 <nstdloop> I'm trying out this hard project euler problem
21:49:58 <carter> nstdloop: remebmer: the c that that -fvia-c generates wont be human intelligible
21:50:08 <carter> nstdloop: just dump the CMM instead
21:50:11 <carter> much higher level
21:50:12 <nstdloop> trying to decide whether to write the solution in C or haskell
21:50:29 <carter> nstdloop: that has nothing to do with the previous sentence :)
21:50:52 <dmwit> mm_freak: I mean, I'm sure it wouldn't be much harder to write pipes-gzip than it was to write pipes-zlib.
21:51:02 <dmwit> No idea how hard that is, though. =P
21:51:05 <mm_freak> dmwit: probably, yeah
21:51:19 <nstdloop> If I can't actually read the C that -C outputs then I have no reason to use it
21:51:28 <mm_freak> i guess it's just a hack that takes a lazy ByteString indirection
21:51:58 <carter> nstdloop: good
21:52:05 <maybefbi> how to [Word8] -> [Word32] ? Should I engage Data.Bits.shiftL ?
21:52:30 <dmwit> mm_freak: I don't think so...
21:52:36 <mauke> map fromIntegral
21:52:47 <mm_freak> dmwit: or it splits the stream into fixed-size chunks
21:52:57 <nstdloop> is it possible to do memoization in haskell?
21:52:58 <dmwit> mm_freak: I think it actually binds to the zlib C libraries in a new way compared to the zlib package itself.
21:52:59 <carter> ozataman: in my naivete i just tried to look at the zlib fsource
21:53:01 <carter> nstdloop: sure
21:53:10 <carter> nstdloop: many ways to
21:53:26 <carter> http://hackage.haskell.org/packages/search?terms=memo
21:53:31 <maybefbi> mauke: but won't that convert each Word8 -> Word32 ? I want 4 Word8 s to align as Word32
21:53:39 <mauke> maybefbi: in what order?
21:53:40 <mm_freak> dmwit: you're right, it depends on zlib-bindings
21:53:45 <mm_freak> didn't notice
21:54:09 <maybefbi> mauke: little endian
21:54:14 <mm_freak> for now i'll dispense with zlib completely and just feed the input through gunzip
21:54:48 <maybefbi> guess I will shiftL then
21:54:53 <dmwit> maybefbi: Do you know how to [Word8]
21:54:58 <dmwit> maybefbi: Do you know how to [Word8] -> Word32?
21:55:08 <dmwit> Under the assumption that the input has four or fewer Word8's.
21:55:34 <dmwit> Yes, shiftL and friends are the way to go.
21:55:37 <maybefbi> dmwit: ok. i need to fold shiftL i think
21:55:58 <dmwit> Once you have [Word8] -> Word32, you can use map and chunk.
21:56:00 <dmwit> :t chunk
21:56:01 <lambdabot> Int -> [e] -> [[e]]
21:56:16 <dmwit> :t map undefined . chunk 4
21:56:17 <lambdabot> [e] -> [b]
21:56:33 <mauke> @hoogle chunk
21:56:33 <lambdabot> Data.ByteString.Builder.Extra Chunk :: ByteString -> BufferWriter -> Next
21:56:34 <lambdabot> Data.Text.Lazy.Internal chunk :: Text -> Text -> Text
21:56:34 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
21:56:47 <dmwit> :t map (undefined :: [Word8] -> Word32) . chunk 4
21:56:48 <lambdabot> [Word8] -> [Word32]
21:56:55 <mauke> :t chunksOf
21:56:56 <lambdabot> Int -> [e] -> [[e]]
21:56:57 <dmwit> mauke: Data.List.Split.chunk
21:57:07 <dmwit> yes, same as chunksOf
21:57:16 <dmwit> and one or two other names, I think?
21:57:41 <mauke> ah, chunk is undocumented and deprecated
21:57:47 <mauke> gj recommending it
21:57:53 <dmwit> bah
21:58:12 <dmwit> I disagreed with the people who suggested that it's a bad name when they suggested it, and I disagree now.
21:58:56 <maybefbi> thanks
21:59:20 <carter> what is it now?
21:59:41 <frxx> is there a way to make SimpleReflect display a chain of function calls in here, instead of just resulting list?
21:59:43 <frxx> > foldl (flip (:)) [] [a,b,c]
21:59:44 <lambdabot>   [c,b,a]
21:59:45 <dmwit> I think chunksOf is the official Name Of Choice.
21:59:55 <ozataman> carter: I'm guessing it's not the most straightforward piece of code :)
22:00:06 <carter> yes
22:00:07 <dmwit> > foldl f [] [a, b, c]
22:00:08 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr [a0])
22:00:08 <lambdabot>    arising from a ...
22:00:12 <carter> lz4hs is a bit simpler
22:00:15 <carter> like one module
22:00:16 <carter> ish
22:00:20 <dmwit> > foldl f (text "nil") [a, b, c]
22:00:21 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr
22:00:21 <lambdabot>                     Text...
22:00:28 <dmwit> I failed.
22:00:33 <dmwit> > foldl f (var "nil") [a, b, c]
22:00:34 <lambdabot>   f (f (f nil a) b) c
22:00:48 <dmwit> > foldl (flip f) (var "nil") [a, b, c]
22:00:49 <lambdabot>   f c (f b (f a nil))
22:00:53 <frxx> nice thanks
22:30:24 * hackagebot imagemagick 0.0.3.1 - bindings to imagemagick library  http://hackage.haskell.org/package/imagemagick-0.0.3.1 (AlexanderVershilov)
22:35:37 <joelteon> lol, that fixes the thing I was bitching about 30 minutes ago
22:35:39 <joelteon> neat
23:17:00 <lpaste> bitemyapp pasted “Can't build Pronk, get "error: invalid preprocessing directive" for LiftedBase” at http://lpaste.net/95215
23:18:15 <adelbert_> having issues installing the threads library v0.5.0.2 on ghc 7.6.3 and cabal 1.18.0 (while trying to install elm-server) - http://pastie.org/private/uywfeea8rzzd52pj6gpa any ideas?
23:19:33 <pharaun> that was one odd bug :)
23:20:05 <pharaun> somehow i accidentally wrote a list dedup >_<
23:22:46 <sopvop> adelbert_: looks like your C preprocessor does something funny with input
23:23:14 <adelbertc> sopvop - hm. any way to fix that?
23:23:14 <dmj`> noob question: what's the best way to format doubles in Haskell? Let's say I only want 2 decimal places
23:23:16 <adelbertc> what makes you say that
23:23:26 <sopvop> are you using xcode 5?
23:23:30 <dmj`> 34.245 to 34.24
23:23:46 <enthropy> > printf "%.2f" 34.245
23:23:48 <lambdabot>   Could not deduce (Text.Printf.PrintfType t)
23:23:48 <lambdabot>    arising from the ambiguity c...
23:23:56 <adelbertc> sopvop - if thats the latest xcode version, yes
23:23:56 <enthropy> > printf "%.2f" 34.245 :: String
23:23:58 <lambdabot>   "34.24"
23:24:18 <sopvop> adelbertc: http://www.reddit.com/r/haskell/comments/1pn6bk/wrapper_script_for_xcode_5_os_x_109/
23:24:18 <dmj`> enthropy, I need it in double form, you think I should just call read on that?
23:24:42 <dmj`> enthropy: ^
23:25:07 <enthropy> oh then maybe it's easier to go through Integer
23:26:00 <dmj`> enthropy: I would lose data if I converted it to an integer
23:26:07 <enthropy> > let f n = (*10 ^^ (-n)) . fromInteger . round . (* 10^^n) in f 2 34.245
23:26:09 <lambdabot>   34.24
23:26:12 <enthropy> isn't that the point?
23:26:44 <dmj`> enthropy: yes, but I thought by integer you meant whole number
23:26:58 <adelbertc> sopvop - hm, is that necessary if GHC does work for me? it seems its to fix issues in GHC with mavericks, though i seem to be able to use a REPL and compile haskell source fine
23:27:57 <dmj`> enthropy: wow, that is tricky
23:30:27 <sopvop> adelbertc: I'm not expert on macos or xcode, never used it. I guess the problem is with system C preprocessor which GHC uses
23:31:56 <dmj`> enthropy: did you just do that on the fly?
23:32:40 <enthropy> I've done that "algorithm" before
23:33:06 <enthropy> probably not implemented exactly the same
23:34:56 <dmj`> I see what you're doing, turning the first 2 digits and 2 decimals place into a 4 digit whole number by multiplying then rounding, then converting back to a double by raising to a negative exponenet, but getting all the types right was impressive
23:36:19 <arkeet> Data.Fixed might be useful.
23:36:56 <arkeet> hm, does lambdabot have it?
23:37:27 <arkeet> it does.
23:37:38 <arkeet> > fromRational 23.45678 :: Fixed E2
23:37:40 <lambdabot>   Ambiguous occurrence `Fixed'
23:37:40 <lambdabot>  It could refer to either `Data.Fixed.Fixed',
23:37:40 <lambdabot> ...
23:37:43 <arkeet> > fromRational 23.45678 :: Data.Fixed.Fixed E2
23:37:45 <lambdabot>   23.45
23:37:56 <arkeet> hmm.
23:38:04 <arkeet> no control over rounding.
23:38:33 <arkeet> no idea why I wrote fromRational.
23:39:32 <dmj`> arkeet: Thanks! I don't need rounding for what I'm doing anyway
23:39:48 <arkeet> realToFrac is what you'd use to convert, anyway.
23:40:31 <arkeet> but Data.Fixed is about actually representing numbers as fixed point decimal, less so about formatting.
23:40:37 <arkeet> so it may or may not be appropriate for you
23:41:30 <adelbertc> sopvop - googling some more points to what you said, xcode 5 problems. think ill wait for ghc 7.8 to land in a few weeks, cheers
23:42:43 <hamid> guys this is my type :
23:42:44 <hamid> data Graph t = Node { node :: t, leafs :: [Graph t] } deriving (Show)
23:43:18 <hamid> i want to get an stream of ts . but i'm noob in this fashion. would someone please help me?
23:44:05 <dmj`> hamid: You mean, you want to flatten your graph?
23:44:34 <hamid> dmj`, yes and get a [t] the end
23:44:36 <bitemyapp> I'm getting Failed to install lifted-base-0.2.1.0 - preprocessor error, anybody else encounter this?
23:45:13 <arkeet> bitemyapp: xcode 5? see topic
23:45:25 <dmj`> hamid: What have you tried, and have you looked at Data.Graph?
23:45:42 <bitemyapp> arkeet: thank you.
23:46:39 <arkeet> dmj`: Data.Graph isn't really relevant.
23:47:27 <hamid> dmj`, didn't look at Data.Graph. this is me learning how to write this on my own. but when i wrote my own function at the end it was something like this : n: [n :[n:[...]]]
23:47:47 <prophile> hamid: nodes x = (node x) : ((leafs x) >>= nodes) should do the trick no?
23:47:52 <hamid> dmj`, so i tried to concat those but that didn't feel right :|
23:48:32 <bitemyapp> arkeet: well the build hasn't finished yet so I don't know if it works for sure, but it's making a lot more progress than last time, thanks!
23:48:43 <arkeet> :)
23:49:34 <hamid> prophile, yes! it does :)
23:51:06 <hamid> prophile, thanks :)
23:51:24 <prophile> np
23:51:59 <bitemyapp> hrm, new problem :(
23:52:06 <arkeet> hamid: now you should figure out why it works.
23:52:27 <lpaste> bitemyapp pasted “Compilation error (couldn't match kind * against * -> *, trying to build pronk” at http://lpaste.net/95217
23:52:34 <hamid> arkeet, +1 :))
23:53:01 <dmj`> prophile: How do we know that Graph is a monad
23:53:35 <arkeet> dmj`: the monad being used isn't Graph
23:53:56 <dmj`> oh
23:55:35 <bitemyapp> ahhhhh nuts. https://github.com/bos/pronk/issues/20
23:55:46 <dmj`> arkeet: Isn't that a rose tree?
23:55:46 <bitemyapp> if I'm a Haskell noob, how likely is I can dig this problem up and fix it myself?
23:55:55 <arkeet> dmj`: it is.
23:57:21 <supki_> bitemyapp: https://github.com/bos/pronk/pull/23 ?
23:57:44 <bitemyapp> oh.
23:58:08 <bitemyapp> supki_: thanks!
23:58:13 <bitemyapp> I guess I should've checked :(
23:58:30 <dmj`> arkeet: are rose trees commonly used to represent graphs?
23:58:41 <arkeet> are they?
23:58:50 <startling> they can't, in general
23:58:51 <dmj`> I don't know
23:58:54 <startling> only trees
23:58:54 <prophile> presumably only when the graph is a tree
23:58:59 <prophile> and a nonempty one at that
23:59:12 <prophile> (is an empty tree a tree?)
23:59:23 <prophile> (and if it fell in the forest would it make a sound?)
23:59:26 <startling> prophile, only if you hear the last one fall
23:59:34 <startling> >.>
23:59:37 <dmj`> a tree is a graph, but a graph is not a tree
23:59:40 <Sculptor> that's a philosophical question
23:59:53 <startling> It's probably a bad idea to use a rose tree for a graph, unless you label each node
23:59:58 <startling> and even then
