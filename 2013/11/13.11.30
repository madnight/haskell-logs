00:00:38 <jle`> maybe even to find examples with strong applicative uses but that cannot be monads
00:00:47 <startling> jle`, OK. If a parser-combinator is expressed in an Applicative way, it can be evaluated in a context-free way.
00:01:11 <jle`> startling: yeah, parser combinators are my only real example i have right now ><
00:01:34 <startling> jle`, if your structure lets you download things, an Applicative-only version can download them in parallel
00:01:54 <navilan> scott_, Twey - very nice - thank you. I was trying y <$> (snd . x) etc ... this is great.
00:02:14 <Twey> navilan: Almost there — (y <$>) . snd . x
00:02:17 <Twey> (is equivalent)
00:02:28 <johnw> i was mentioning to someone about writing code to do Pythonesque splices with lenses; is that person still here?
00:02:55 <johnw> the product of my hacking is https://gist.github.com/7716493
00:02:57 <startling> jle`: you can write Applicative Reader, Writer, and State that tell you how many times the encapsulated value is read, written to, or modified.
00:03:24 <startling> (without evaluating the action).
00:03:51 <startling> there's a well-known web forms library that does neat things with applicatives. I can't remember the name.
00:04:20 <Twey> formlets
00:04:42 <startling> ^
00:05:46 <jle`> thank you for these examples, it's more than i expected :)
00:05:47 <Twey> johnw: The person was Jookia, but they're gone
00:05:53 <startling> http://hackage.haskell.org/package/digestive-functors , too
00:07:03 <startling> jle`, basically, for structures that are evaluated, Applicative lets you know more about values before you evaluate them.
00:07:04 <Twey> navilan: In fact, since (<$>) = (.) for functions, ‘fmap y <$> (snd . x)’ is also correct
00:07:06 <navilan> Twey - yeah, the fmap version is cleaner, I think - also helped me think about / understand it better.
00:07:29 <johnw> well, now I can do stuff like: [1,2,3,4,5] & irange  (-2) 4 .~ [3,4]   ==>   [1,2,3,3,4,5]
00:07:42 <startling> jle`, whereas Monad may use the result of one action to decide which action to perform next, so there's more run-time-determined behavior.
00:08:00 <Twey> johnw: Does that obey the laws?
00:08:04 <navilan> Twey: ah nice. playing with it some more now.
00:08:16 <johnw> Twey: you mean, the get/set laws?
00:08:49 <Twey> I think so.  I don't really know lens well, but I remember something about changing the structure being a violation of the laws.
00:09:01 <johnw> ah, I see what you mean
00:10:00 <johnw> this is a list onto a subset of a list
00:10:05 <johnw> so my action above is replacing that subset
00:10:10 <johnw> s/a list/a lens
00:10:18 <johnw> dunno if that's law-abiding or not
00:11:42 <johnw> no, it seems not to be; it fails the set-set-law
00:11:52 <Twey> Aha
00:11:59 <johnw> set (irange (-2) 4) [3,4] (set (irange (-2) 4) [5,6] [1,2,3,4,5])
00:12:11 <johnw> thanks for pointing that out
00:12:17 <Twey> No problem
00:12:45 <Twey> I think it's fine if you remove the end-of-range constraint
00:13:02 <Twey> (i.e. only lens over suffixes of the list)
00:13:38 <johnw> yeah, but the end-of-range is exactly what makes the Python splicing so handy
00:13:50 <johnw> being able to say "replace from x to y with this list"
00:13:52 <Twey> Mm
00:14:07 <Twey> Arguably that's an abuse of lists, anyway
00:14:15 <Twey> On the order of (!)
00:14:20 <johnw> i mean, I could always do this with getSplice and setSplice functions, which do not have to obey the lens law
00:14:23 <Twey> Er, (!!)
00:14:33 <johnw> I just thought lens would be a nice framework to do it in
00:14:35 <Twey> Aye
00:15:02 <johnw> i guess they can only be traversals at best?
00:16:01 <Twey> I guess so
00:16:12 <Twey> Oh
00:16:19 <Twey> No, not even that
00:16:34 <Twey> « One consequence of this requirement is that a traversal needs to leave the same number of elements as a candidate for subsequent traversal as it started with. »
00:16:46 <johnw> ok, then ;)
00:17:02 <johnw> "Learn Lens by Doing it Wrong, by John Wiegley"
00:17:04 <Twey> Hehe
00:17:31 <johnw> i've been beating my head against a wall trying to make a generalized version of a "pairing" lens
00:17:43 <johnw> like, (1,2,3,4) ^. pairing _2 _4
00:18:05 * hackagebot Allure 0.4.10 - Near-future roguelike game in very early and active development  http://hackage.haskell.org/package/Allure-0.4.10 (MikolajKonarski)
00:18:07 <Twey> Yielding (2, 4)?
00:18:13 <johnw> yeah
00:18:23 <johnw> but accepting just Getters as well as lens
00:18:25 <Ralith> startling: what ever happened to your roguelike?
00:18:40 <Twey> Again, I don't think that's a lens
00:18:47 <johnw> it can be, says edwardk
00:18:51 <Twey> Oh, really?
00:18:58 <johnw> the type is along the lines of pairing :: Functor f => LensLike' (PretextT' (->) f a) s a -> LensLike' (PretextT' (->) f a') s a'-> LensLike' f s (a, a')
00:19:14 <johnw> so, it gracefully degrades
00:19:20 <johnw> give it lenses, it's a lens
00:19:22 <Twey> Aha
00:19:26 <johnw> give it getters/traversals/folds, it degrades to that
00:19:32 <Twey> That's neat
00:19:47 <johnw> yeah, but I've spent hours trying to implement that function so far :)
00:19:54 <johnw> it's easy for the "only lenses" case
00:23:46 <bennofs> johnw: You cannot implement a law-abiding pairing lens for all pairs of lenses iirc
00:24:14 <bennofs> johnw: it only works when the fields viewed by both lenses are disjoint
00:24:30 <johnw> ahh
00:24:36 <johnw> good point
00:24:51 <johnw> i think this would be one of those "we won't watch you" types of lenses
00:25:02 <johnw> I know there are already a few such "caveat" lenses around
00:26:29 <navilan> Twey: http://lpaste.net/96396
00:27:42 <Twey> navilan: No, your understanding is broken :þ
00:28:25 <Twey> navilan: The fully specialized version with no typeclasses is: maybeMap y . snd . x
00:28:45 <Twey> navilan: Where maybeMap f (Just x) = f x; maybeMap _ Nothing = Nothing
00:29:05 <Twey> maybeMap ∷ (a → b) → Maybe a → Maybe b
00:29:08 <scott_> maybeMap f (Just x) = Just (f x)
00:29:12 <Twey> Er, yes, sorry
00:30:06 <Twey> navilan: maybeMap is the fmap for Maybe, and (.) is the fmap for functions, so if you apply fmap (or <$>, which is the same thing) to a Maybe you'll get maybeMap, and if you apply it to a function you'll get (.)
00:31:11 <Twey> navilan: So you can always replace an instance of maybeMap with fmap, and you can always replace an instance of (.) with fmap… but you can't replace any arbitrary instance of fmap with (.) because the thing you're applying it to might not be a function
00:31:51 <Twey> navilan: In this case, the thing that fmap gets applied to is the Maybe, not the function, so replacing that fmap with (.) results in a type error
00:34:19 <Twey> navilan: A ‘Functor’ is a *type* that has a fmap.  So the type (r →) is a Functor (with fmap (.)), and the type Maybe a is a Functor (with fmap maybeMap)
00:34:35 <navilan> Twey, scott_: wow - cool. very nice :)
00:34:48 <Twey> navilan: Which fmap you get depends on which *type* you apply it to.
00:35:06 <Twey> And the fmap for one type may not type-check if applied to another type.
00:37:38 <navilan> Twey: thank you. clear now.
00:38:39 <Twey> navilan: Cool.  Glad I could help ☺
00:44:52 <navilan> Twey: :) - I am really glad I asked too.  Trying to force myself to use point-free as it helps uncover holes in my understanding.
01:01:52 <xuusheng> how to map a number to a list of functions?
01:02:21 <xuusheng> for example, map 5 to [(\x->x^2), (\x->x+2)]?
01:02:26 <scott_> > map ($ 3) [(*2),(+2)]
01:02:27 <lambdabot>   [6,5]
01:02:55 <jle`> [f, g] <*> pure 5
01:03:29 <jle`> i like scott_'s way better
01:03:48 <xuusheng> thank you very much!
01:06:33 <raphie> is this the right place to ask about cabal? I'm a total newbie and utterly perplexed
01:07:49 <fizruk> raphie, go ahead
01:08:14 * hackagebot OpenAFP-Utils 1.4.1.3 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.4.1.3 (AudreyTang)
01:08:27 <raphie> well fizruk, I'd like to write a webserver with scotty
01:08:38 <raphie> so I ran "cabal install scotty"
01:09:13 <raphie> it prints out this
01:09:16 <raphie> https://gist.github.com/RaphiePS/e03d25b317ec6711df2c
01:10:28 <raphie> however, when I run my test file (https://gist.github.com/RaphiePS/76d3c1e95cf1c03f2740) it says "Could not find module `Web.Scotty'"
01:10:37 <startling> raphie, you can --force-reinstalls but it might break regex-posix-0.95.1.
01:11:00 <startling> I guess haskell-platform is something you installed with your distribution's installer?
01:11:14 <raphie> naw, from the download a while back. how should I update it?
01:11:30 <startling> install the newest haskell platform, I guess.
01:11:49 <startling> current release is 2013.2.0.0
01:12:40 <startling> or you could just make sure not to use sudo, cabal install scotty --force-reinstalls, and worry about it later
01:12:59 <raphie> ahh, so once I have the new version, startling, the cabal will place that module in my current directory?
01:13:13 <raphie> Web.Scotty, I mean
01:13:16 <startling> no.
01:13:28 <startling> it'll be in ~/.ghc somewhere and GHC will figure it out for you.
01:13:31 <raphie> oh, how does it work then?
01:13:39 <fizruk> ~/.cabal i think
01:13:45 <startling> fizruk, nope.
01:14:37 <startling> raphie, GHC will see that your file says "import Web.Scotty" and will figure out that that's from the package 'scotty'.
01:14:51 <startling> And find the (possibly precompiled, I think?) files necessary.
01:16:11 <fizruk> startling, i have .hi files in ~/.cabal/lib/<libname>-<version>/ghc-<version>/
01:16:37 <startling> raphie: what cabal is whining about is "this other package requires an older version of a package we want to install, and because of silly historical reasons we can only use one version of a package at a time"
01:17:13 <raphie> ahh, ok. I'm downloading the new haskell-platform now
01:17:14 <startling> fizruk, huh, me too.
01:17:29 <startling> fizruk: oh, I see.
01:17:38 <startling> ~/.ghc has a database pointing to all the appropriate files
01:17:45 <fizruk> startling, and in ~/.ghc i have some a single .conf for each installed package (essentially with package description from libname.cabal)
01:18:03 <startling> fizruk: yeah, I was wrong.
01:46:24 <zenzike> dcoutts: So what's the issue with the HDBC-odbc docs?
01:48:36 <AshyIsMe> on a slightly offtopic note: i just had a 2 week holiday in vietnam that was heaps of fun
02:01:09 <mart1n> I was addicted to watching pornography for 10 years.
02:01:11 <mart1n> If you want to know how i won the fight simply write me a short line now
02:14:25 <haasn> am I the only one who thought that was merijn for a second and got really weirded out?
02:14:29 <haasn> @where ops
02:14:30 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:15:03 --- mode: ChanServ set +o edwardk
02:15:12 --- mode: edwardk set +b *!~martin@85-127-100-72.dynamic.xdsl-line.inode.at
02:15:14 --- kick: mart1n was kicked by edwardk (Your behavior is not conducive to the desired environment.)
02:17:39 <Ralith> haasn: hahaha
02:19:01 <startling> AshyIsMe, like that Dead Kennedys song?
02:19:23 <startling> oh, that wasn't Vietnam.
02:40:49 <jle`> welcome back AshyIsMe
02:42:18 <ReinH> hai
02:49:45 <timblechmann> hi, (newbie question): i'm trying to write a shell stript using shelly, but i'm having some troubles with the Text type: i've got a list of `Text', but shelly seems to expect a list of `Data.Text.Internal.Text'. any pointers?
02:50:29 <Taneb> timblechmann, have you import Data.Text or Data.Text.Lazy?
02:51:13 <timblechmann> Taneb: Data.Text.Lazy (it seems to be suggested by the shelly docs, and i'm using splitOn from this package)
02:51:30 <timblechmann> Taneb: Data.Text.Lazy (it seems to be suggested by the shelly docs, and i'm using splitOn from this package)
02:52:43 <timblechmann> http://lpaste.net/8884405439668682752
02:54:32 <Taneb> timblechmann, if it wants Data.Text.Internal.Text you should probably using Data.Text
02:55:55 <timblechmann> Taneb: i see (though i don't totally understand)
02:56:30 <timblechmann> iac, it works! thanks a lot Taneb!
02:56:51 <Taneb> :)
03:04:12 <mirpa> What is ()? It can be used both as value and data type.
03:04:23 <mirpa> Why is that?
03:04:51 <mirpa> Is it data () = ()?
03:04:57 <Taneb> mirpa, roughly, yes
03:05:08 <mirpa> cool
03:05:59 <Iceland_jack> mirpa: () has type ()
03:06:03 <Iceland_jack> @ty ()
03:06:04 <lambdabot> ()
03:06:19 <Iceland_jack> () :: ()
03:06:37 <Iceland_jack> @ty ((), ())
03:06:38 <lambdabot> ((), ())
03:06:42 <Iceland_jack> @ty ((), (), ())
03:06:42 <lambdabot> ((), (), ())
03:06:57 <mirpa> Iceland_jack: so it is recursively infinite?
03:07:06 <Iceland_jack> mirpa: What is?
03:07:14 <Iceland_jack> (a, b) is a tuple, unrelated to ()
03:07:25 <mirpa> Iceland_jack: () :: ()
03:07:28 <Iceland_jack> no
03:08:15 <Iceland_jack> The value ()_value has type ()_type, and the type (called kind in Haskell) of ()_type is *
03:08:18 <Iceland_jack> @kind ()
03:08:18 <lambdabot> *
03:08:46 <mirpa> ...othervise it would be * -> *?
03:08:53 <Iceland_jack> no
03:09:14 <Iceland_jack> It's just: () :: () :: *
03:09:17 <Iceland_jack> and it ends there
03:09:26 <dv-> :k Maybe
03:09:27 <lambdabot> * -> *
03:09:38 <socket> hey, this ia a bit off topic but maybe someone here knows. I need a CFL that describes the syntax of the Java or C++ , any idea where can I find something like that?
03:09:45 <timblechmann> one more q: what is the easiest way to read all command line arguments as a list of strings?
03:09:50 <jle`> mirpa: yeah, there is a difference between the data constructor and the type constructor
03:09:57 <Iceland_jack> timblechmann: getArgs
03:09:59 <Iceland_jack> @ty getArgs
03:10:00 <lambdabot> Not in scope: `getArgs'
03:10:03 <jle`> mirpa: this is analogous to saying data MyData a = MyData a
03:10:07 <Iceland_jack> in System.Environment
03:10:14 <dv-> timblechmann: lines `fmap` getArgs
03:10:25 <jle`> the data constructor and the type constructor are the same, but they aren't necessarily so
03:10:25 <dv-> er, words `fmap` getArgs
03:10:27 <jle`> it is a happy accident
03:10:31 <Iceland_jack> dv-: why lines?
03:10:50 <Iceland_jack> dv-: that doesn't type check
03:11:04 <timblechmann> Iceland_jack: thanks a lot, that seems to be what i'm looking for!
03:11:18 <Iceland_jack> getArgs already returns a list of strings
03:11:20 <Iceland_jack> @hoogle getArgs
03:11:21 <lambdabot> System.Environment getArgs :: IO [String]
03:11:21 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
03:11:21 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
03:11:47 <dv-> oh it's already a list of strings. my mistake :(
03:13:17 <Iceland_jack> dv-: Otherwise it would be tricky to represent foo 'a b' c 'e f'
03:14:37 <dv-> yeah i think i confused it with getLine
03:15:14 <Iceland_jack> You could do: unwords `fmap` getArgs :)
03:26:22 <haasn> :t words . unwords <$> getArgs
03:26:23 <lambdabot> Not in scope: `getArgs'
03:26:32 <haasn> or concatMap words :)
03:27:40 <haasn> (oh, no relation to the above. I just remembered it. It transforms foo 'a b' c 'e f' into ["a","b","c","e","f"] instead of ["a b","c","e f"])
03:29:45 <donri> :t fmap unwords (return [])
03:29:46 <lambdabot> (Monad f, Functor f) => f String
03:30:08 <donri> :t fmap unwords (return [""])
03:30:08 <lambdabot> (Monad f, Functor f) => f String
03:30:26 <donri> oh doh i expected type error but that's with "words"
03:43:28 * hackagebot gtksourceview3 0.12.5.0 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview3-0.12.5.0 (HamishMackenzie)
03:43:30 * hackagebot webkitgtk3 0.12.5 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.12.5 (HamishMackenzie)
03:58:11 <donri> chrisdone: oh yeah i discovered vim does have "insert type signature"
03:58:29 * hackagebot webkitgtk3-javascriptcore 0.12.5.0 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.12.5.0 (HamishMackenzie)
03:58:37 <donri> in haskellmode.vim which i haven't used and ghcmod-vim where it seems new and undocumented
03:58:56 <quchen> The -j flag is not in 7.6, is it?
03:59:04 <donri> quchen: nope
03:59:51 <donri> there's ghc-parmake but it doesn't really gain you anything because it has to re-read the interfaces or something
04:02:23 <quchen> donri: It's not that pressing, I just felt like the flag was there before.
04:02:47 <donri> quchen: it's in cabal-install but only for building packages in parallel
04:03:14 <quchen> But 7.8 will have it in GHC as well on a per-module basis then?
04:03:34 <donri> that's my understanding yes
04:04:09 <donri> https://ghc.haskell.org/trac/ghc/wiki/Status/Oct13
04:07:57 <functor> Hi everyone, I'm new here. I have a question: has anyone recently succeeded in installing haxml via cabal? I keep getting a couple of errors 'can't match expected type [Char] with b0-c0' (ghc 7.6.3, OS X 10.9)
04:16:05 <quchen> donri: Oh, I remember that page again now. Should've found that myself.
04:26:28 <mrmonday> is there something like intersperse that works with tuples?
04:26:59 <fizruk> mrmonday, suggest a type
04:28:00 <fizruk> mrmonday, a -> (b, c) -> (b, a, c) ?
04:41:17 <sdx23> hi. Is there something as a vim plugin which can insert the type of a function?
04:53:55 <mrmonday> fizruk: I was thinking more a -> ([a], [a], [a]) -> [a]
04:54:42 <fizruk> mrmonday, why can't you make tuple just a list of 3 sublists?
04:55:00 <fizruk> :t intersperse
04:55:00 <lambdabot> a -> [a] -> [a]
04:55:07 <fizruk> :t intercalate
04:55:07 <lambdabot> [a] -> [[a]] -> [a]
04:55:25 <fizruk> mrmonday, perhaps you were looking for intercalate instead? ^
04:56:24 <donri> :t zip3
04:56:24 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
04:56:49 <fizruk> :t unzip3
04:56:50 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
04:57:28 <donri> mrmonday: do you have a concrete example of what you want?
05:04:58 <mrmonday> donri: need to think about it some more, I'll ask again later. Thanks though
05:06:21 <xenon-> what was that function called, ensureDirectoryTreeExists or something like that?
05:07:02 <donri> :t createDirectoryIfMissing
05:07:02 <lambdabot> Not in scope: `createDirectoryIfMissing'
05:07:06 <donri> @hoogle createDirectoryIfMissing
05:07:07 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
05:07:12 <xenon-> thanks!
05:07:37 <xenon-> (by the way is there an equivalent for a filename?)
05:07:38 <augur> is there a name for a pair of functions f :: a -> b, g :: b -> a, such that f.g = id, but g.f is an inclusion?
05:07:40 <donri> True for recursive
05:08:10 <augur> because thats what the zip-unzip pairs are
05:08:29 <donri> xenon-: don't think there's a standard one for files, no
05:09:22 <donri> wouldn't be hard to roll with createDirectoryIfMissing + takeDirectory though
05:09:24 <donri> @hoogle takeDirectory
05:09:24 <lambdabot> System.FilePath.Windows takeDirectory :: FilePath -> FilePath
05:09:24 <lambdabot> System.FilePath.Posix takeDirectory :: FilePath -> FilePath
05:09:54 <augur> taking zip :: ([a],[b]) -> [(a,b)] and unzip :: [(a,b)] -> ([a],[b]), it's obvious that zip.unzip = id, but unzip.zip = \(xs,ys) -> let l = max (length xs) (length ys) in (take l xs, take l ys)
05:10:40 <augur> well its not quite an inclusion, per se, but its related to some kind of ordering-related thing on ([a],[b])
05:11:04 <donri> prism?
05:11:20 <donri> i guess not quite
05:11:23 <augur> donri: is that to me?
05:11:32 <donri> yes but ignore me
05:11:35 <augur> :p
05:12:29 <xenon-> is it safe to use takeDirectory with filenames?  all of the examples have a directory at the end.
05:12:33 <augur> well, we could define a relation <= on ([a],[b]) like so:   (xs,ys) <= (xs',ys') = prefix xs xs' && prefix ys ys'
05:13:28 <augur> and then certainly the poset category for ([a],[b]) will include an arrow that corresponds to each use of unzip.zip
05:13:59 <augur> we could probably define some kind of metric in this space, and unzip.zip will be minimal non-zero arrows or something like that
05:15:45 <donri> xenon-: it doesn't care or even know if the last part is a filename or directory name
05:16:04 <donri> xenon-: filenames don't have to have an extension you know :)
05:16:14 <xenon-> that is true
05:19:23 <xenon-> what about creating a file? Just open it for writing?
05:19:29 <xenon-> and close it immediately
05:21:23 <frx> > :t appendFile "path" ""
05:21:24 <lambdabot>   <hint>:1:1: parse error on input `:'
05:21:28 <frx> :t appendFile "path" ""
05:21:29 <lambdabot> IO ()
05:21:44 <frx> :t withFile path WriteMode (const (return ()))
05:21:45 <lambdabot>     Not in scope: `withFile'
05:21:45 <lambdabot>     Perhaps you meant one of these:
05:21:45 <lambdabot>       `writeFile' (imported from Prelude),
05:22:27 <donri> @hoogle touchFile
05:22:27 <lambdabot> System.Posix.Files touchFile :: FilePath -> IO ()
05:22:27 <lambdabot> System.Posix.Files.ByteString touchFile :: RawFilePath -> IO ()
05:22:42 <donri> guess that's posix-only, though there's unix-compat
05:28:38 * hackagebot stateWriter 0.2.0 - A faster variant of the RWS monad transformers.  http://hackage.haskell.org/package/stateWriter-0.2.0 (SimonMarechal)
05:43:16 <xpika> spj said in his latest talk on lenses you could make non uniform traversal lenses
05:43:26 <xpika> such as every alternate element in a list
05:43:31 <xpika> how do you do that
05:44:37 <edwardk> > [1,2,3,4,5] & traversed.indices even .~ 100
05:44:38 <lambdabot>   Ambiguous occurrence `indices'
05:44:38 <lambdabot>  It could refer to either `Control.Lens.Inde...
05:44:43 <edwardk> > [1,2,3,4,5] & traversed. Lens.indices even .~ 100
05:44:44 <lambdabot>   [100,2,100,4,100]
05:45:09 <xpika> edwardk: thanks
05:45:21 <donri> :t Lens.indecent exposure
05:45:22 <lambdabot> Couldn't find qualified module.
06:07:07 <bennofs> Is there a function to kill a process from haskell, when it doesn't respond to terminateProcess?
06:08:57 <Iceland_jack> bennofs: terminateProcess sends SIGTERM, you basically want to send another signal?
06:09:32 <bennofs> yes, I'd like to send SIGKILL, but this will only work on unix/linux. Is there something that works for windows too?
06:09:48 <Iceland_jack> Have you seen the warning for terminateProcess and are you really sure you need to do this?
06:10:26 <bennofs> I'm writing a library to test command line applications. If the command hangs up, I'd still like to kill it.
06:11:11 <Iceland_jack> Have you used it and run into a case where SIGTERM was insufficient?
06:11:41 <bennofs> No, but I have written programs were SIGTERM was insufficient because of a bug
06:13:03 <donri> bennofs: https://hackage.haskell.org/package/unix-2.7.0.0/docs/System-Posix-Signals.html
06:13:04 <donri> duno about windows
06:17:11 <bennofs> It seems that TerminateProcess (which is what terminateProcess uses) is already the most ultimate way to kill a process on windows
06:19:16 <pavonia> Given a vector v, I want to build a new vector w by w(0) = c, w(i) = f(v(i), w(i-1)), where f also uses another, state-like value which is updated depending on v(i). Which of the functions from Data.Vector should I use here to build w?
06:24:41 <fizruk> pavonia, fromList + unfold/iterate ?
06:24:57 <fizruk> that's only a guess
06:25:27 <pavonia> Well, I don't have lists here
06:26:19 <pavonia> There's iterateN, but that doesn't allow me passing some extra information
06:28:31 <pavonia> Hhm, it could be one of the various scan functions
06:28:43 * hackagebot dimensional 0.12.2 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.12.2 (BjornBuckwalter)
06:28:45 <heatsink> zip, then scanl
06:30:46 <Hodapp> ooh, dimensions!
06:31:09 <Hodapp> I have poked around with things like MATLAB and just annotated in code the dimensions but that's never satisfactory
06:31:13 <pavonia> heatsink: The zip doesn't even seem to be necessary, from the example I guess I want prescanl
06:31:45 <heatsink> ok
06:31:47 <exicer> So I'm trying to learn about functors. When I try to compile http://lpaste.net/96405 it fails on the stuff in main. When I use the same functions in ghci it is fine - what gives?
06:32:36 <benmachine> exicer: what's your error?
06:32:43 <Saizan> exicer: you need parens around *2
06:32:43 <heatsink> That shouldn't work in ghci
06:32:47 <benmachine> oh
06:32:50 <benmachine> yeah, that
06:33:44 * hackagebot dimensional-tf 0.2.1 - Statically checked physical dimensions, implemented  using type families.  http://hackage.haskell.org/package/dimensional-tf-0.2.1 (BjornBuckwalter)
06:33:47 <exicer> http://lpaste.net/96406
06:34:05 <exicer> ...doh
06:34:14 <exicer> Yeah, missing brackets
06:34:15 <exicer> Thanks :p
06:34:19 <dmj`> do we have an ETA on 7.8?
06:34:39 <fizruk> :t V.fromList
06:34:40 <lambdabot> Couldn't find qualified module.
06:34:42 <pavonia> lol, beginner-friendly error messages
06:34:57 <benmachine> the errors are unusually unhelpful in this case
06:35:16 <benmachine> the trouble is that it's possible to write code such that the example compiles
06:35:21 <benmachine> it's a terrible idea, but GHC doesn't know that
06:36:04 <benmachine> (by "write code" I mean type class instances)
06:36:44 <xenon-> is there a portable way of getting the name of the user who ran my program?
06:37:10 <dmj`> xenon: yes
06:37:17 <xenon-> there is userName  but it is posix
06:37:20 <dmj`> xenon: check the unix-compat package
06:37:30 <dmj`> System.PosixCompat.User.getLoginName
06:37:42 <xenon-> thanks
06:38:01 <dmj`> > System.PosixCompat.User.getLoginName
06:38:03 <lambdabot>   Not in scope: `System.PosixCompat.User.getLoginName'
06:38:09 <dmj`> worth a try
06:38:21 <donri> benmachine: could maybe be special-cased though and given a human-written hint in the type error message
06:38:23 <dmj`> > print "test"
06:38:24 <lambdabot>   <IO ()>
06:38:41 <donri> benmachine: ghc already does some things like that e.g. with function arities
06:39:00 <benmachine> donri: yes, certainly, but it's not completely straightforward to work out when that's necessary/useful
06:39:08 <benmachine> donri: I'm sure patches would be welcome :P
06:39:17 <donri> in deed :) just sayin'
06:39:30 <xenon-> getLoginName works on OS X, but unfortunately not on windows.   *** Exception: System.PosixCompat.User.getLoginName: not supported: illegal operation
06:39:31 <donri> Num is sort of well known to be a confusion here
06:39:35 <benmachine> yeah
06:39:59 <benmachine> it's a problem that should be fixed, but there are good reasons why it hasn't been
06:40:21 <dmj`> xenon: hmmmm
06:40:30 <donri> quite :)
06:41:49 <dmj`> xenon-: Are you using cygwin
06:41:56 <xenon-> dmj` no
06:43:45 * hackagebot haskell-src-meta 0.6.0.5 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.5 (BenMillwood)
06:48:45 * hackagebot tidal 0.2.9 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.9 (AlexMcLean)
07:20:20 <Dasuraga> is there a reason not to use the stream fusion library?
07:20:27 <Dasuraga> if we're working with lists a lot
07:20:48 <donri> Data.List uses a different kind of fusion already
07:24:14 <lingxiao> hey all, what's `signum` for Int?
07:24:28 <lingxiao> kind of an inane question I'm afraid..
07:24:59 <exicer> Is there a way I can hide the functor instance of [] ?
07:25:09 <chrisdone> lingxiao: http://en.wikipedia.org/wiki/Signum_function
07:25:21 <geekosaur> the only way to hide an instance is to wrap a newtype around it and not derive it through
07:25:36 <lingxiao> ahh that makes so much sense
07:25:40 <lingxiao> thanks chrisdone
07:25:54 <exicer> geekosaur: Could you show me what that would mean for a list ?
07:27:38 <ion> @check \a -> a == signum a * abs (a :: Integer)
07:27:41 <lambdabot>   +++ OK, passed 100 tests.
07:27:49 <geekosaur> newtype MyList a = MyList [a] -- then you have to implement your own wrapper for (:) and possibly [], and if you want instances you'll have to write them yourself (or derive them but since many of them want Functor...)
07:28:18 <geekosaur> it would help if I knew what you were trying to accomplish
07:28:23 <exicer> geekosaur: Ah, okay
07:28:47 <exicer> geekosaur: I'm trying to work through the typeclassopedia, so it would be nice if I could implementeg the evil functor instance
07:29:01 <exicer> eg one that doesn't meet the laws
07:29:22 <geekosaur> ah. it might work better to write your own List then
07:29:42 <exicer> geekosaur: Ah, okay then
07:30:54 <geekosaur> data MyList a = Nil | a ::: MyList a -- or something, then write your instances
07:31:21 <geekosaur> sadky you can't replicate the [a,b,c...] syntactic sugar
07:31:40 <geekosaur> (unless you want to use a preprocessor of some kind, or SugarHaskell)
07:32:17 <fizruk> geekosaur, don't we have OverloadedLists?
07:32:32 <geekosaur> I thought that was 7.8
07:32:58 <geekosaur> (so yes, ghc HEAD might also work)
07:33:44 <fizruk> no OverloadedLists in 7.6 :(
07:33:57 <exicer> geekosaur: What does the ::: mean ?
07:34:04 <exicer> Oh, it is just cons
07:34:07 <geekosaur> it's just an infix constructor
07:34:11 <geekosaur> and yes, cons
07:34:25 <geekosaur> you can't repurpose : and :: is taken
07:34:27 <exicer> Huh, didn't know you could define infix things like that :P
07:34:39 <exicer> I guess there isn't really any other way to define them
07:34:43 <fizruk> exicer, infix constructors should start with :
07:35:26 <exicer> fizruk: Is it something that is commonly defined ?
07:35:41 <geekosaur> other examples are Data.Complex using :+ and Data.Ratio using :% (although I think the latter may not be exported any more)
07:36:10 <geekosaur> it's not really common but it is certainly there
07:36:25 <exicer> geekosaur, fizruk: Okay, good to know :)
07:36:35 <lemao> Holla! I am having troubles trying to get a callback to work in a specific scenario involving shared libs (C calling Hs shared lib)
07:38:33 <lemao> I have a cabal package A that provides a simple 'init' FFI export. I then have another (lib) cabal package B that imports package A. When C exe calls the 'init' function I need to have it call the package B. How to do that?
07:42:12 <frx> is there an alloca equivalent that initializes the object pointed to by Ptr?
07:42:38 <dcoutts_> with :: Storable a => a -> (Ptr a -> IO b) -> IO b
07:42:49 <frx> that's it, thanks
07:43:19 <geekosaur> lemao: I think you need to either explain more clearly or show an example of what you want
07:43:38 * dcoutts_ was also going to say that lemao's Q isn't very clear
07:44:34 <arianvp> SUp guys
07:44:50 <arianvp> I'm stuck with a set theoretic question
07:45:24 <arianvp> is the following true?  A dense in B <=> A×A dense in B×B
07:46:49 <lemao> geekosaur: consider an EXE that is ready to dynamically load (and uload) a shared library (.so) when started. The goal is to create this shared library with Haskell and also allow anyone to create them without having to know the specific FFI interfaces etc.
07:47:56 <lemao> geekosaur: so the obvious approach is to create a base cabal package that implement the ffi interface and provide some machinery to allow anyone to implement that in haskell (e.g. a type class with a well defined init/exit methods)
07:48:31 <lemao> geekosaur: anyone could create package B, import package A, implement this type class and build the .so
07:48:50 <lemao> geekosaur: I will work with the EXE, guaranteed
07:50:07 <geekosaur> generally we do init/exit type stuff with a bracketing mechanism (see for example Control.Exception.bracket, or ResourceT for a monadic mechanism) rather than trying to hide it. since global state is not a thing in Haskell, you can't hide it in shared obkect init/deinit functions
07:50:31 <khyperia> How portable is ncurses (specifically windows)? I'm installing it now on windows, but I have 15 billion MinGW packages/etc, and I'm wondering if it requires MinGW (since I'm thinking about making a package that I release)
07:51:00 <khyperia> ah, never mind, it failed to install
07:51:05 <geekosaur> ncurses is rather painful and unreliable on windows
07:51:14 <khyperia> Any alternatives?
07:52:01 <geekosaur> (ncurses is a reimplementation of a model that assumes that terminals use escape sequences, since that's how things worked in the 1980s with physical terminals; windows uses out of band calls instead)
07:52:22 <khyperia> looks like http://hackage.haskell.org/package/ansi-terminal is an option
07:52:45 <lemao> geekosaur, dcoutts_: the EXE will call hs_init, init, exit, hs_exit. Is there a std mechanism for a singleton in haskell? I don't even need a dynamic callback mechanism since the assumption is that thereis only one impl.
07:53:04 <geekosaur> there are a couple alternatives to ncurses for haskell (vty/vty-ui seems most popular?) but I know very little about if or how they work on Windows
07:53:06 <lemao> geekosaur, dcoutts_: I just want to make sure no one needs to know the specifics of the EXE vs .SO protocol
07:53:46 <hashcat> khyperia: how about vty
07:54:06 <lemao> geekosaur, dcoutts_: i.e. abstract that out in a package A and have package B import A and provide just the impl type checked by haskell
07:54:14 <khyperia> windows support for vty? The package description doesn't mention windows and keeps on saying "terminal" so I have doubts.
07:54:42 <geekosaur> hence "if or how"
07:54:47 <khyperia> "dependencies: unix" nope.
07:55:30 <geekosaur> sadly, in general the haskell world is not so much familiar with windows and a lot of stuff is not available. and, well, a character based UI is kinda foreign to windows anyway
07:56:26 <geekosaur> mostly what's there in windows is to aid porting of DOS programs
07:56:54 <khyperia> Well, I'd like to make a basic text editor (because reasons, don't ask), and it seems like console would be the easiest to do so (unless there's something else I don't know of)
07:57:05 <dcoutts_> lemao: I'd suggest that your package A provide a registration interface so that B can register a callback.
07:57:17 <geekosaur> it'd be easier on unix but I think windows apis work against you
07:57:33 <khyperia> ansi-terminal looks pretty nice
07:57:48 <geekosaur> that's only half of it though
07:57:54 <lemao> dcoutts_: the thing I am not sure about since this is a shared librrary: how to make sure that the registration happens before the init
07:57:59 <solirc> chrisdone: I'm with Fuuzetsu here regarding more backends.  And I'm with you that a text-based intermediate format would be cool.
07:58:04 <geekosaur> it relies on the ansi support in CMD.EXE windows, which is somewhat limited
07:58:11 <lemao> dcoutts_: i.e. hs_init, register, init, exit, unregister, hs_exit
07:58:13 <geekosaur> (because, again, only there for DOS compatibility)
07:58:56 <dcoutts_> lemao: mm, good point
07:59:13 <khyperia> well, the description of the package is basically shouting "with Windows compatibility", so I'd be pretty disappointed if it didn't have such.
07:59:27 <hashcat> khyperia: GUI is generally easier for porting
07:59:35 <dcoutts_> lemao: then perhaps it's better for B to provide init, using helper functions from A to do it
07:59:48 <lemao> dcoutts_: that is the nut of the question.
08:00:45 <lemao> dcoutts_: yes, and that is what I will do. However, it is not ideal since I don't have Haskell enforcing the API that is frozen
08:01:44 <hashcat> khyperia: wxHaskell or web-based Happstack may be better. I think windows seldom works without GUI. =P
08:01:47 <khyperia> geekosaur, looks like ansi-windows actually has a #if defined(WINDOWS) that redirects everything to windows.h calls, otherwise it goes to normal ansi-stuff
08:01:48 <lemao> dcoutts_: even though is not complicated (copy and paste the intended ffi function and how to implement it with helper functions), we shouldnt need to
08:02:44 <dcoutts_> lemao: if you know what Haskell function from B you want to call, then you can do it from C with a little wrapper
08:03:06 <dcoutts_> lemao: but otherwise this is just a problem of contexts, it'd be the same in C
08:03:23 <hashcat> khyperia: maybe that's why you can't find one
08:03:41 <khyperia> why what?
08:03:54 <geekosaur> I have no idea what the context of that was
08:04:48 <hashcat> khyperia: wxHaskell or web-based Happstack may be better. I think windows seldom works without GUI. I guess that's why you can't find one with Windows compatibility.
08:05:07 <khyperia> Well, ansi-terminal looks like it works, so.
08:05:26 <quchen> Can I somehow download and build a package from Hackage, but not install it, using cabal?
08:05:55 <dcoutts_> quchen: cabal unpack blah; cd blah-x.y; cabal configure; cabal build
08:05:58 <donri> quchen: cabal get pkg; cd pkg-ver; cabal install --only-dependencies; cabal build
08:06:15 <quchen> Hmm well that would be pretty much the manual way
08:06:30 <quchen> It'll have to do then.
08:06:42 <lemao> dcoutts_: that could be a solution. However, if I want to have Haskell help other people creating these impls I would have to use something like a type class to enforce the api.
08:07:14 <hashcat> quchen : "cabal --help" would tell you every thing.
08:07:28 <geekosaur> fsvo
08:07:45 <geekosaur> you can tell someone a lot and still miss how to actually put it all together...
08:08:08 <lemao> dcoutts_: I am wondering if the contexts issue could be solved by having hooks equivalent to hs_init/hs_exit and are triggered by the haskell rts when hs_init is called
08:08:27 <lemao> dcoutts_: an hs_init equivalent, but in haskell
08:08:50 * geekosaur still thinks this sounds like global state wearing a shared object-shaped mask
08:08:51 <lemao> dcoutts_: like main, but for libs
08:09:03 <dcoutts_> lemao: sure, you can call another Haskell function after hs_init
08:09:03 <fizruk> I'm trying to install yesod, doing cabal install yesod-platform; cabal install yesod-bin (as to http://www.yesodweb.com/page/quickstart)
08:09:23 <fizruk> but I get this dependency error: http://lpaste.net/96408
08:09:50 <fizruk> can I resolve this without wiping out all installed packages?
08:09:52 <geekosaur> rejecting: shakespeare-1.2.0.1/installed-94d... (package is broken)
08:09:55 <dcoutts_> lemao: or you can provide a C function that does both, but you cannot write that C function without knowing which Haskell thing it's going to call.
08:10:00 <quchen> hashcat: No, for example it would not tell me what arguments you can provide to the listed options.
08:10:11 <lemao> dcoutts_: true. That is simple enough and I should just avoid this typeclass idea.
08:10:25 <quchen> hashcat: In particular, it doesn't say "hey there's 'cabal install --no-install'" or something.
08:10:26 <geekosaur> which sounds like you need to find out why the package is broken, and possibly you do need to drop everything and start over
08:10:38 <geekosaur> fizruk ^^
08:10:52 <dcoutts_> lemao: for example, ghc's -main-is works by generating a C main function that calls the given Haskell function as the haskell main
08:10:58 <geekosaur> `ghc-pkg check` might be a good idea
08:11:10 <lemao> dcoutts_: yes. If this lib init/exit is a standard for all libs in haskell then it is as good as it gets (same as in main :: IO ())
08:11:15 <dcoutts_> fizbin: it may just work if you use --max-backjumps=-1
08:11:24 <augur> so parsec choke on left-recursive languages, or is it only grammars specified in a left-recursive fashion?
08:11:37 <lemao> dcoutts_: since I learn this once in haskell and can use it for all libs in haskell.
08:12:05 <lemao> dcoutts_: I see.
08:12:52 <lemao> dcoutts_: great. Let me go through with this. BTW, would this be something that could be standardized in haskell? It seems just such a general concept
08:13:11 <fizruk> dcoutts_, geekosaur: thanks! it seems like I've installed some packages with lots of conflicting deps (snap and yesod ?), I'm going to drop everything and start over...
08:13:15 <lemao> dcoutts_: by 'this' I mean: init :: IO () and exit :: IO  ()
08:13:31 <lemao> dcoutts_: or something like that?
08:13:50 <dcoutts_> lemao: you mean if they exist they're automatically called by hs_init ?
08:13:51 <fizruk> dcoutts_, also fizbin is a different person :p
08:13:53 <geekosaur> fizruk, I suggest cabal sandboxes (or cabal-dev if you haven't updated), separate one for each
08:14:03 <lemao> dcoutts_: yes.
08:14:08 <lemao> dcoutts_: like main
08:14:17 <dcoutts_> fizruk: did --max-backjumps=-1 help?
08:14:30 <lemao> dcoutts_: just curious. I will see how far I get with this.
08:14:34 <lemao> dcoutts_: thanks.
08:14:52 <dcoutts_> fizruk, fizbin: oops, sorry, tab completion
08:15:07 <fizruk> dcoutts_, it told me lots of packages would be broken (including just installed yesod-platform)
08:15:20 <fizruk> anyway, I think it's time for cleanup
08:15:21 <dcoutts_> fizruk: ah so it did work, ok
08:15:28 <augur> it seems like parsec's alternation rule would be ordered, making the whole thing a (locally?) ordered grammar, which avoids worries with left-recursion
08:15:59 <lemao> dcoutts_: btw, exercise made me want https://github.com/haskell/cabal/issues/593 :-)
08:16:35 <dcoutts_> fizruk: if you want both yesod-bin and yesod-platofrm, then ask for both at the same time with cabal install --dry-run --max-backjumps=-1
08:16:43 <khyperia> is there any way to get ghc to spit out the warnings/errors of the C preprocessor?
08:17:02 <geekosaur> erm? it does so
08:17:06 <dcoutts_> khyperia: I'm not sure there's any way to get it not to
08:17:18 <geekosaur> as anyone who's run into the xcode 5 cpp issue knows very well >.>
08:17:24 <khyperia> Well, must be a problem with ghc-mod, then.
08:17:30 * khyperia really hates ghc-mod right now
08:17:59 <dcoutts_> lemao: --enable-executable-dynamic
08:19:14 <fizruk> so in order to wipe out all the packages, I have to do rm -rf ~/.ghc ~/.cabal ?
08:19:31 <H1FuelCell> I'm finding it difficult to differentiate between when paranthese indicate a tuple, vs just a separation of logic
08:19:38 <H1FuelCell> any tips for that?
08:19:52 <lemao> dcoutts_: not sure how that would help here
08:20:26 <dcoutts_> lemao: I thought you wanted to make a dynamically linked exe
08:20:37 <lemao> dcoutts_: the EXE is not in haskell, but C/C++
08:21:13 <dcoutts_> lemao: so, nothing to do with Cabal you mean?
08:21:16 * dcoutts_ is confused
08:21:44 <lemao> dcoutts_: I am trying to create a simple framework for creating dynamic plugins for this existing C/C++ exe
08:21:54 <lemao> dcoutts_: dynamic plugins in haskell
08:23:13 <lemao> dcoutts_: so I am trying to structure/simplify the haskell plugins (.so) so that anyone that want to create a plugin doesnt need to know the internal details about how the EXE and the .so communicate
08:23:21 <heatsink> H1FuelCell, if there are commas inside, it's a tuple
08:24:29 <fizruk> except when it is a tuple section
08:24:47 <H1FuelCell> heatsink: in this example from learn you, I'm a little confused http://lpaste.net/96409
08:25:03 <H1FuelCell> because the author refers to it as "pattern matching within a binding"
08:25:19 <geekosaur> wonky indentation
08:25:23 <H1FuelCell> so I am unable to connect the concept of pattern matching with the way it is used here
08:25:48 <heatsink> Have you seen pattern matching like
08:25:51 <heatsink> f (Just x) = x
08:25:58 <heatsink> ?
08:26:18 <dcoutts_> lemao: right and then I thought you were saying there's some missing cabal feature that'd help, but now I can't see what that might be
08:27:53 <heatsink> The "binding" refers to the fact that it's defining variables skinny, normal, and fat
08:28:58 <heatsink> and there is pattern matching involved because the equation is deconstructing a tuple to get the values that go into the three variables
08:29:03 <lemao> dcoutts_: sorry, that is a related and additional point. There is only the notion of an exe or a library (to be linked to an exe) in cabal. What is missing is the notion of a shared lib that is a final binary that is not an exe
08:29:07 <klrr_> anyone know how to draw a cube in SDL without its renderering being "stuck" on the screen, i want the cube to move not draw like a pen over the screen?
08:29:19 <FireFly> iter2 f x y = x : iter2 f y (x `f` y)  -- does `iter2` have another name?
08:29:49 <dcoutts_> lemao: yes, I was going to say that technically cabal does not support constructing system shared libs
08:30:10 <lemao> dcoutts_: yes, that is the ticket I linked above that I found looking for it
08:30:14 <FireFly> I guess I should've gone with `iterate2` instead..
08:30:40 <dcoutts_> lemao: ah ok, that ticket is about something else, just being able to make dynamically linked exes
08:30:54 <lemao> dcoutts_: oh crap... my bad.
08:31:07 <lemao> dcoutts_: linked to the wrong one then...  I got around by adding this: ghc-options:   -o dist/build/test.so -no-hs-main -optl -bundle -fPIC
08:32:19 <fizruk> FireFly, i don't think so, otherwise we'd have a supershort fibb = iter2 (+) 0 1
08:32:30 <FireFly> Yeah :D
08:33:28 <FireFly> A functional dialect of APL has an operator with `iterate` as its monadic (meaning unary in this context) case, and `iter2` as its dyadic case
08:33:48 * riskinho hi people,do you wanna earn some money?this is the best way www.libertagia.com/riskinho,create your Network and get some money folks!
08:33:50 <FireFly> It seems like a useful generalisation of `iterate`, at any rate
08:33:59 * hackagebot wai-websockets 1.3.2.1 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.3.2.1 (MichaelSnoyman)
08:34:01 * hackagebot warp-tls 1.4.2 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.4.2 (MichaelSnoyman)
08:34:03 <lemao> dcoutts_: let me see how best I can structure this. I will circle back re: these points we discussed
08:34:37 <H1FuelCell> okay, that makes sense heatsink
08:34:43 <H1FuelCell> thanks
08:34:59 <aristid> Control.Applicative can be worth it for the <$> alone. *shudder* `fmap`
08:35:52 <frx> was old-locale replaced by some newer package?
08:36:25 <aristid> frx: not for the purposes of time formatting, if that's what you want to do
08:38:53 <moto9> hi all, probably many stumbled over this: how to make Doubles show non-scientifically but more readable
08:39:08 <moto9> is there an easy solution?
08:40:09 <geekosaur> don't use Show. and this is currently being discussed, there is some hope of a more sensible Show instance appearing at some point (but at this point probably no sooner than ghc 7.10)
08:40:24 <pavonia> moto9: Text.Printf.printf
08:41:39 <moto9> pavonia, i'm showing lists of tuples containing doubles, it feels a waste of time to type the printfs
08:42:34 <moto9> oh, i could newtype my Doubles and make a Show instance
08:43:54 <moto9> but then i can't calculate with them anymore, could i?
08:44:26 <pavonia> if you'd write a Num instance you could
08:44:29 <khyperia> I'm getting a parse error on "someprimop#", where it treats the "someprimop" and "#" differently and I'm very confused as to why.
08:44:45 <c_wraith> khyperia: -XMagicHash
08:44:57 <khyperia> alright, thanks, figured it was something like that
08:45:20 <c_wraith> Without that extension, # is a symbol character, and treated as an infix operator
09:00:00 <khyperia> Could anyone help me with ghc-mod?
09:04:12 <KoRnshell> Hmm, GHC allows you to use say Data.List.partition without importing Data.List but Hugs doesn't, is this part of the standard or not?
09:04:28 <Heffalump> KoRnshell: do you mean ghci or ghc compiling source files?
09:04:49 <KoRnshell> Hmm, I only tested it in ghci thus far
09:04:59 <KoRnshell> I discovered it on accident, no one told me
09:05:22 <Heffalump> I don't think interactive environments are covered by the standard at all
09:05:34 <KoRnshell> So the standard is to not allow it?
09:05:51 <Heffalump> in a source file, the standard is not to allow it
09:06:13 <Heffalump> as the standard doesn't cover what happens at a ghci/hugs prompt, there's no answer either way for that situation
09:06:17 <KoRnshell> I should note that I loaded a file into ghci in which the source file I forgot to import a module
09:06:24 <Heffalump> oh, right
09:06:48 <monochrom> it is in the GHC user's guide
09:06:57 <KoRnshell> Also, on that note, is it considered more proper to simply write 'partition' if you imported Data.List or write the fully qualified name each time?
09:08:05 <heatsink> use the unqualified name if you imported it that way
09:08:44 <jmcarthur> KoRnshell: you can import a module qualified if you want to enforce the qualified style. it's a matter of personal preference and judgement
09:09:05 <KoRnshell> jmcarthur, what is 'importing qualified'?
09:09:26 <KoRnshell> What I mean is, I have 'import Data.List;' at the top, should I use 'Data.List.genericLength' or just 'genericLength'?
09:09:40 <geekosaur> import qualified Module [as Alias]
09:09:45 <Heffalump> I would advise using genericLength
09:10:25 <monochrom> how about this. you should, under the constraint of unambiguity, minimize length.
09:10:46 <geekosaur> if you don't say `qualified` there then names are brought into the current namespace and you should generally use them as such (e.g. `genericLength`); with `qualified` they are brought in with the module name as a qualifier (e.g. Data.List.partition)
09:10:48 <jmcarthur> KoRnshell: a fuller import syntax might be:   import [qualified] <Your.Module> [as <Name>]
09:11:11 <jmcarthur> KoRnshell: if you use the qualified keyword then in order to use things imported from the module you have to specify them fully qualified
09:11:14 <geekosaur> with `as` you can pick a different qualifier (e.g. `import qualified Data.List as L; ... L.genericLength`)
09:11:24 <jmcarthur> KoRnshell: or qualified with the shorter name you chose, if you chose any
09:11:30 <KoRnshell> jmcarthur, ah, I did not know that keyword existed.
09:12:55 <KoRnshell> So to get it absolutely sure, if you compile with GHC and you do not explicitly import it'll fail if you use Data.List.genericLength without explicitly importing it?
09:13:14 <geekosaur> yes
09:13:31 <KoRnshell> Okidokido, thanks.
09:13:36 <geekosaur> ghci and runghc/runhaskell will do an implicit import but ghc will not
09:33:07 <PaulVisschers> I´m looking for a nice library to load (and possibly save) image files for use as opengl textures, does anyone know of a good one? (I´ve looked around on hackage but couldn´t find anything)
09:34:06 * hackagebot diagrams-postscript 1.0.0.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.0.1 (BrentYorgey)
09:34:36 <enthropy> PaulVisschers: graphicsmagic or maybe one of the opencv bindings?
09:35:35 <enthropy> they should have ways to convert images to whatever uncompressed format opengl will be happy with
09:37:02 <PaulVisschers> enthropy: Do you mean http://hackage.haskell.org/package/magic?
09:37:26 <hpc> this reminds me of a story i found on bash.org
09:37:43 <hpc> guy is in a bar, sees a table of ladies speaking in an odd accent
09:37:50 <hpc> "excuse me, are you ladies from ireland?"
09:37:54 <hpc> "it's wales, you idiot"
09:38:00 <hpc> "my mistake, are you whales from ireland?"
09:38:36 <enthropy> PaulVisschers: http://hackage.haskell.org/package/hsmagick or http://hackage.haskell.org/package/imagemagick
09:38:54 <PaulVisschers> enthropy: ah thanks
09:39:29 <PaulVisschers> enthropy: I´ll check those and the opencv packages out and see which one to use
09:40:48 <hpc> doh, wrong channel
09:42:07 <Iordanis> hi bros
09:44:20 <geekosaur> "bros" :(
09:46:04 <daneo> This code : http://lpaste.net/96413 is giving me the following error(s) : http://lpaste.net/96412
09:47:14 <daneo> Obviously I'm doing something wrong, but I can't figure out what. I'd be happy if anyone'd be willing to assist me, practicing Haskell.
09:48:20 <exicer> In the typeclassopedia (http://www.haskell.org/haskellwiki/Typeclassopedia#Monad), I'm trying to work out what the functor instance for Free f is. I can't work out what it should be for Node x - any help?
09:48:36 <exicer> I can think of a few things I could do, but don't know which to choose or why!
09:50:07 <enthropy> daneo: it might help you to narrow down where your assumptions about what's a [a] [[a]] and so on if you write type signatures for the definitions in the where block
09:50:32 <enthropy> you will need to enable -XScopedTypeVariables, and have   oorsprong :: forall a. Ord a => [[a]] -> [[a]]
09:50:51 <daneo> (How do i do that, enable that flag ? )
09:51:28 <enthropy> {-# LANGUAGE ScopedTypeVariables #-} -- at the top of your file
09:53:18 <daneo> enthropy: Ok, thanks. And then in the where e.g. : heads :: [a]
09:53:25 <daneo> heads = ..
09:53:33 <enthropy> yep
09:55:03 <enthropy> daneo: if you read through the type error, it says that (mini :: a) which won't work as a first argument to (:)
09:57:13 <daneo> enthropy: Oh, I see, or I think I do.
09:57:37 <daneo> mini is basically of type a now ?
09:58:00 <enthropy> yes, so you might want to    map (mini:) (oorsprong filteredlist)
09:58:13 <enthropy> or maybe   [mini] : 12:50:28      enthropy | yes, so you might want to    map (mini:)
09:58:25 <enthropy> or maybe   [mini] : (oorsprong filteredlist)
10:00:23 <daneo> Wonderful, that got me rid of the first type error I have.
10:00:37 <daneo> Now it's giving the same on 'calculatedMaxPos = map (getMaximumIndices l) heads'
10:00:52 <daneo> Am I not using getMaximumIndices as a partially applied function here ?
10:01:17 <krzysz00> How would I rewrite a Parser parser that looks like 'do { blah; a <- thing; b <- thing; return $ f a b }' in a more applicative style?
10:01:57 <supki> krzysz00: blah *> liftA2 f thing thing
10:01:58 <enthropy> blah *> f <$> thing <*> thing
10:02:30 <krzysz00> Neat.
10:02:40 <enthropy> do notation isn't all that bad though
10:02:45 <augur> i think that just obfuscates the intention tho, honestly
10:02:50 <daneo> enthropy: Trying not to bug, but I reuploaded it : http://lpaste.net/96414 , error : http://lpaste.net/96415 .
10:05:50 <enthropy> you're supplying an  [[a]] as the first argument to getMaximumIndices
10:06:24 <enthropy> so that means you replace [b] with [[a]] in   getMaximumIndices :: Ord b => [b] -> b -> (b,Integer)
10:06:51 <enthropy> which gives you    getMaximumIndices l :: Ord b => [a] -> ([a],Integer)
10:06:56 <enthropy> which gives you    getMaximumIndices l :: Ord a => [a] -> ([a],Integer)
10:07:15 <enthropy> but you're saying it's a (a, Integer)
10:08:21 <bennofs> Is there a way to get the path of the source directory with cabal test?
10:08:52 <dcoutts_> bennofs: the current dir is always set to the package root dir
10:09:37 <dcoutts_> bennofs: beyond that, it's not a well defined question since there are many places where source files are found
10:09:48 <bennofs> dcoutts_: Hmm, but is there a way to get it during compile time? This would be useful, so that I can also run the tests from another working directory
10:09:57 <bennofs> dcoutts_: I want to access some files for the tests
10:10:11 <bennofs> those are located in project-root/tests/some-dir
10:10:16 <dcoutts_> bennofs: you want to access the files during compile, like from TH code?
10:10:33 <bennofs> no, but I'd like to bake in the paths during compile time
10:10:57 <dcoutts_> oh I see, you want to move the test program
10:10:59 <daneo> enthropy: Processing that ..
10:11:05 <bennofs> so that I can do (example): cabal configure --enable-tests && cabal build && cd dist/build/tests && ./tests
10:11:32 <dcoutts_> bennofs: it'd be better to just run ./dist/build/tests/tests of course
10:11:41 <bennofs> Hmm, I could just reference the files relative to the test executable
10:11:59 <enthropy> daneo: in this case if you leave out the signature on calculatedMaxPos, things might work
10:12:01 <dcoutts_> bennofs: that's what I meant, the current dir is the package dir
10:12:20 <enthropy> because you're only using the map snd of it
10:12:46 <dcoutts_> bennofs: so if you're running the test from the build tree it's fine. I thought you were talking about moving the test somewhere else entirely and wanting the current dir to be elsewhere too
10:16:46 <bennofs> dcoutts_: But that only works if I run the tests with cabal, right? If I just run the tests from the command line (and don't change into the project root first), this won't work
10:17:43 <dcoutts_> bennofs: I guess so, but I thought it was pretty standard to be in the project root dir, afterall that's the only place where you can run cabal configure; cabal build etc
10:18:55 <bennofs> Hmm, maybe. Btw, couldn't cabal have per-target data files? So different executables/test-suites could have different data files
10:19:20 <daneo> enthropy: Well, it doesn't, but I understand the point u made about [[a]] being passed in.
10:19:34 <dcoutts_> bennofs: to answer your original Q, no there's no mechanism provided by Cabal to supply the project dir at compile time to the components being built
10:20:10 <bennofs> yeah, so I'll just assume the tests are run from the project root
10:20:19 <dcoutts_> bennofs: yes that's something we've considered, at the moment data files are shared by all components and there's only a single Paths_pkgname.hs module for all components
10:26:18 <chrisdone> dcoutts_: how are you starting/restarting hackage server in development?
10:27:00 <dcoutts_> chrisdone: just invoking it normally from the command line & ^C
10:27:36 <dcoutts_> chrisdone: I tell it to use the local data files
10:27:46 <dcoutts_> static files I mean
10:28:05 <dcoutts_> chrisdone: did you have something more specific in mind?
10:30:35 <chrisdone> dcoutts_: just wondering whether you had some script to auto-restart after compiling
10:30:51 <chrisdone> no biggie, i'll make wee script for myself with angel & emacs
10:31:22 <dcoutts_> chrisdone: you hacking on a new feature for us? :-)
10:31:57 <chrisdone> hopefully many, i'm looking at some easy tickets
10:32:03 <dcoutts_> super
10:34:07 <chrisdone> dcoutts_: have you been able to load the codebase into ghci?
10:34:18 <dcoutts_> chrisdone: I've not tried actually
10:34:37 <dcoutts_> chrisdone: actually, no that's not true, I have been using cabal repl, but I've not run it from within ghci
10:34:46 <klrr_> Lemmih: how is the SDL2 bindings coming along?
10:34:46 <dcoutts_> just using it for quick compiling
10:34:54 <chrisdone> dcoutts_: right -- i just want to load it in for type checking and type info
10:35:02 <dcoutts_> yep, that works fine
10:35:04 <chrisdone> dcoutts_: i'll try out cabal repl
10:35:07 <chrisdone> cool
10:36:46 <joelteon> :t \f -> map (\xs@((x,_):_) -> (x, mconcat $ map f xs))
10:36:47 <lambdabot> Monoid t2 => ((t1, t) -> t2) -> [[(t1, t)]] -> [(t1, t2)]
10:36:55 <joelteon> is there a better way to do this :U
10:36:56 <chrisdone> dcoutts_: wunderbar! cabal repl works
10:37:08 <joelteon> @djinn [(a,b)] -> (a,[b])
10:37:08 <lambdabot> Error: Undefined type []
10:37:25 <dcoutts_> chrisdone: :-)
10:37:32 <dcoutts_> yes it's useful
10:38:02 <dcoutts_> chrisdone: first time you've used it? :-)
10:38:18 * dcoutts_ was pleased to finally get that integrated
10:38:42 <chrisdone> dcoutts_: yep! works fine from inside emacs too =)
10:41:15 <monochrom> is that in the sense of "instead of calling up ghci, call up cabal repl"?
10:42:48 <chrisdone> monochrom: yeah
10:43:18 <chrisdone> (someone else added that support to haskell-mode, so i hadn't tried it)
10:43:23 <quchen> "cabal repl" loads the module's main in GHCi?
10:43:37 <chrisdone> i'm curious about that, too. it seems to load the target
10:43:47 <dcoutts_> it loads all the modules in the given component
10:43:48 <chrisdone> dcoutts_: what's the reason behind that behaviour?
10:43:55 <dcoutts_> or the first component if none is given
10:44:05 <dcoutts_> chrisdone: as opposed to what?
10:44:11 <donri> dcoutts_: i think it defaults to loading the library actually
10:44:19 <donri> which is contrary to the docs though
10:44:23 <chrisdone> normal ghci doesn't load anything when you open it apart from its own stuff
10:44:24 <dcoutts_> donri: you remember better than me, yes.
10:45:08 <dcoutts_> chrisdone: it's more analogous to cabal build
10:45:35 <dcoutts_> (indeed it shares the same code paths)
10:46:03 <daneo> enthropy: Thanks for the assistance. Now I only have an exception when I use `heads = map head l` when it reaches the point that there is an empty list.
10:46:36 <dcoutts_> chrisdone: I can't claim that the UI has been considered extremely carefully
10:46:57 <dcoutts_> chrisdone: e.g. there's no support yet for loading a ghci session outside of a package
10:47:40 <dcoutts_> chrisdone: one issue we had to face though is that there has to be a component selected, it cannot be agnostic
10:48:01 <dcoutts_> because the build env is (or at least can be) different for different components
10:48:20 <chrisdone> sure
10:49:11 <chrisdone> hm, at least with -fobject-code it doesn't take ages to restart, so that's ok
10:49:49 <krzysz00> How would I tell parsec to skip comments (anything between, say '|' and '|')
10:49:56 <krzysz00> *?
10:51:19 <jack2091> ciao
10:51:26 <jack2091> !list
10:51:26 <monochrom> jack2091: http://okmij.org/ftp
10:51:56 <donri> ;)
10:51:56 <Feuerbach> krzysz00: you probably want to use a separate lexer for that (possibly parsec's own Text.Parsec.Token)
10:52:04 <geekosaur> :p
10:53:35 <Zoltrov> Hmm, it says that genericLength is less efficient than length, is there a reason it cannot statically choose between the instances and replace them?
10:54:29 <Zoltrov> Surely if I use randomFunctionConsumingInt $ genericLength list it can just overload this?
10:56:19 <dcoutts_> Zoltrov: if it can specialise it, yes
10:56:27 <dcoutts_> that's not always practical
10:56:46 <geekosaur> Zoltrov, someone could write that, probably, but the usual use case for genericLength is not one where that specialization is useful
10:57:27 <geekosaur> if you want fromIntegral . length, write that
10:58:36 <jmcarthur> meh, i'm with Zoltrov. why not just add a rewrite rule?
10:59:15 <jmcarthur> or maybe it can manage to specialize on its own, of course
10:59:30 <jmcarthur> don't know if length is written with specialization for Int in mind already or if it's essentially the same thing
11:00:17 <geekosaur> I thought the point of genericLength was Nat
11:02:43 <dcoutts_> jmcarthur:
11:02:45 <dcoutts_> {-# RULES
11:02:45 <dcoutts_>   "genericLengthInt"     genericLength = (strictGenericLength :: [a] -> Int);
11:02:45 <dcoutts_>   "genericLengthInteger" genericLength = (strictGenericLength :: [a] -> Integer);
11:02:45 <dcoutts_>  #-}
11:02:54 <dcoutts_> it's already there
11:04:00 <dcoutts_> Zoltrov: so a reason it can be less efficient is that it's a foldr not a foldl'
11:04:14 <dcoutts_> though as you can see, it is specialised for Int and Integer
11:10:06 <Shapeshifter> Does someone know a prominent data type which is not an instance of Eq?
11:11:32 <joelteon> IO a
11:11:53 <Taneb> (a -> b)
11:12:05 <Shapeshifter> thanks
11:14:21 <roconnor> Float :P
11:14:46 <monochrom> "whatever floats your boat" :)
11:15:26 <FireFly> { x | Floats(x, yourBoat) }
11:31:19 <donri> Shapeshifter: [a]
11:33:27 <kakos> Which base64 library is the most common/recommended to use?
11:37:08 <Zoltrov> dcoutts_, hmm
11:37:22 <Zoltrov> I sued to be under the impression that typeclasses were a compile time convenience and dd not exist any more at runtime
11:37:34 <Zoltrov> Like overloading in say Java
11:38:45 <tiffany> I can't say for haskell, but it is possible to implement typeclasses in that manner if static dispatch is used
11:39:15 <Zoltrov> One assumes, so why isn't it? One assumes there is some kind of behaviour that cannot be caught by it?
11:39:26 <tiffany> dynamic dispatch is the one which incurs runtime overhead, a vtable dereference
11:39:46 <Zoltrov> I just assumed that if you used say sort (>) or something like that it would generate a different versoin of sort for all types where it is used in a call site
11:39:56 <tiffany> that would be static dispatch
11:40:01 <Zoltrov> I know
11:40:13 <Zoltrov> so basically it sacrifices cycles for less static memory allocated?
11:40:25 <tiffany> there's a tradeoff of code size and performance, so it's not entirely unreasonable to want dynamic dispatch
11:40:50 <tiffany> C++ tend to have rather huge binaries because of template expansion
11:41:12 <Zoltrov> Hmm, so it is possible to conform to the standard using static dispatch?
11:42:55 <geekosaur> it's easier with whole program compilation; cross-module stuff is already painful enough implementation-wise in ghc
11:43:02 <jmcarthur> Zoltrov: ghc does not monomorphize polymorphic functions, but it does inline them pretty aggressively, where they may be subjected to local specializations
11:43:20 <jmcarthur> Zoltrov: type class dictionaries are almost always inlined
11:44:02 <posco> Why is Data.List.Stream not the default for prelude?
11:44:21 <jmcarthur> C++ has huge binaries because of template expansion. ghc has huge binaries because of aggressive inlining.
11:44:38 <Zoltrov> Hmm
11:44:41 <jmcarthur> well, at the runtime, when we're talking about constant factors on the binary size
11:44:44 <Zoltrov> I take it a language pragma exists to override this though?
11:44:44 <Taneb> I though GHC has huge binaries because of poor linking
11:44:45 <jmcarthur> *and the runtime
11:44:47 <donri> posco: it already does build fusion
11:45:10 <jmcarthur> Taneb: perhaps that also contributes. does 7.8 make that better, since it now uses the system linker?
11:45:41 <posco> donri: so is the no win to using Data.List.Stream?
11:45:56 <donri> there are different tradeoffs to each
11:46:08 <donri> i hear.
11:46:25 <dcoutts_> posco: because we had not solved the concatMap problem
11:46:37 <geekosaur> um, ghc already uses the system linker. it's ghci / TH that doesn't
11:46:47 <jmcarthur> Zoltrov: you can use the SPECIALIZE pragma to "monomorphize" a type class for specific instances, which automatically generates rewrite rules to use the specialized version when possible
11:46:53 <jmcarthur> geekosaur: ah, i see
11:46:56 <geekosaur> which is why current ghc doesn't support those on ARM
11:46:59 <posco> dcoutts_: but it is solved now?
11:47:10 <dcoutts_> posco, donri: though we do now have a solution, though it's not trivial, nor integrated yet. It's a proof of concept using HERMIT.
11:47:43 <donri> dcoutts_: is there a good read on build vs stream fusion?
11:47:44 <Zoltrov> So how does this work, doesn't ths require type information to exist at runtime as some kind of tag like in dynamic languages?
11:47:44 <jmcarthur> Zoltrov: inlining tends to trump specializing, most of the time, though
11:47:53 <Shapeshifter> In ghci, how can I see which type classes a type belongs to? e.g. how can I see which typclasses Char belongs to?
11:47:56 <dcoutts_> donri: well, I can suggest my PhD thesis :-)
11:47:57 <Zoltrov> I can recall testing the lower and upper bounds of Int and they conformed to a 64 bit integer
11:48:08 <donri> dcoutts_: ah, i thought that was only stream fusion
11:48:17 <bearclaw> Shapeshifter: :info I think
11:48:19 <jmcarthur> Zoltrov: type classes are implemented in ghc as dictionaries that are passed around as separate arguments (but again, they are typically inlined, so they don't necessarily appear at runtime)
11:48:32 <dcoutts_> donri: it's the main thing I compare against
11:48:34 <Shapeshifter> bearclaw: that gives me the Types which implement a given typeclass, I would like the opposite
11:48:53 <dcoutts_> donri: http://code.haskell.org/~duncan/thesis.pdf
11:48:55 <donri> dcoutts_: ok, i'll have to read the paper, thanks :)
11:49:01 <jmcarthur> Zoltrov: yes, in ghc, Int is natively sized
11:49:30 <donri> dcoutts_: aha, not "From Lists to Streams to Nothing at All"?
11:49:30 <Zoltrov> jmcarthur, as so when using x < y where x and y are  :: Foo it actually passes 'Foo' as an argument to < in this case because < is overloaded?
11:49:37 <dcoutts_> donri: the intro explains both systems, then there's more comparison at the end
11:49:38 <bearclaw> Shapeshifter: :info sometype lists the type classes
11:49:39 <jmcarthur> Zoltrov: not Foo, Ord Foo
11:49:52 <Shapeshifter> bearclaw: oh of course, sorry.
11:49:53 <Shapeshifter> thanks
11:49:56 <jmcarthur> Zoltrov: it still doesn't know that it's a Foo, just that it has some operations available in the Ord Foo dictionary
11:50:04 <dcoutts_> donri: that paper doesn't talk all that much about build/fold, though it does benchmark against it.
11:50:16 <Zoltrov> jmcarthur, and this dict is a hash table?
11:50:44 <jmcarthur> Zoltrov: roughly, you can think of    blah :: Ord Foo => Foo -> Foo -> Ordering   as   blah :: OrdDict Foo -> Foo -> Foo -> Ordering
11:50:48 <jmcarthur> Zoltrov: no, it's just a record
11:51:08 <jmcarthur> Zoltrov: more like a C struct with function pointers, i guess... assuming it doesn't get optimized away
11:51:35 <Zoltrov> Ah yeah, figures when the size is fixed.
11:51:43 <Zoltrov> So it's basically an array?
11:51:52 <jmcarthur> i wouldn't say that
11:51:57 <jmcarthur> the elements aren't all the same type
11:52:05 <Zoltrov> Well, I mean in terms of access.
11:52:11 <jmcarthur> constant time access, sure
11:52:18 <dcoutts_> donri: at the end there's a discussion of the concatMap problem, and it turns out that the solution suggested there is more or less right, though there turns out to be more details (unsurprisingly). There's an upcoming paper on that topic.
11:52:47 <Zoltrov> The labels of a C struct only exist at compile time as far as I know and are rewritten at runtime to what is basically identical to array accessing. At lest, I believe they exist in constant memory.
11:53:00 <jmcarthur> Zoltrov: that is... roughly correct, although fuzzy
11:53:35 <jmcarthur> i would not consider structs a special case of arrays, myself
11:53:48 <Zoltrov> Well, nonetheless this is kind of not wat I expected about typeclasses
11:54:05 <Zoltrov> Well, I would more consider both of them special cases that automate pointer arithmatic I guess
11:54:19 <dcoutts_> Zoltrov: you could resolve most typeclasses at compile time, however you'd get C++ template-like code bloat
11:54:30 <jmcarthur> i really want to emphasize that this is not what you normally end up with in practice, so it is not very useful as a cost model
11:54:39 <jmcarthur> because ghc will optimize it away most of the time
11:54:49 <dcoutts_> Zoltrov: so ghc does quite a lot of compile-time specialisation, but it has heuristics so that it does not bloat too much
11:54:51 <Zoltrov> As in x->name can basically come down to *(x+10) or something depending on where the compiler throws it into the struct
11:54:54 <Zoltrov> Ah yes, I see.
11:55:04 <Zoltrov> So it decides if cycles or code bloat are more important?
11:56:44 <dcoutts_> Zoltrov: but don't confuse type class dictionary passing and record field lookup, that does indeed just use pointer arithmetic
11:56:58 <haasn> Zoltrov: to address your original question; regardless of the implementation strategy used it's possible via an existential type to capture ‘some’ dictionary, without the compiler necessarily being able to statically predict which dictionary it will be
11:58:54 <Zoltrov> haasn, example?
11:59:28 <augur> parsec can do non-CF grammars cant it?
11:59:32 <augur> Zoltrov: !
11:59:46 <jmcarthur_mobile> augur: yes, via monad
11:59:52 <augur> Zoltrov: what are you doing in #haskell!
11:59:56 <dcoutts_> haasn, Zoltrov: and indeed with polymorphic recursion it can be necessary to construct type class dictionaries at runtime
11:59:57 <augur> jmcarthur_mobile: i was just thinking without monads even
12:00:15 <haasn> dcoutts_: reflection called ;)
12:00:15 <augur> jmcarthur_mobile: just with parser parameters
12:00:20 <Zoltrov> augur, asking about ypeclasses, you?
12:00:27 <augur> Zoltrov: being a haskell hacker :P
12:00:51 <Zoltrov> Haskell can only be hacked via something starting with unsafe*, damned shame
12:01:01 <haasn> Zoltrov: an example of an existential:  data Foo = forall a. Class a => Foo a -- Foo :: Class a => a -> Foo
12:01:20 <geekosaur> Zoltrov, an existential erases static type information. once you've wrapped a value in an existential, the only "handle" you have on it is whatever dictionary is packaged with it (if any)
12:01:41 <haasn> a value of type ‘Foo’ is essentially some ‘a’ together with a ‘Class a’ dictionary
12:02:27 <haasn> (When using some value of type Foo, it is not necessarily possible to know at compile time what the type of ‘a’ will be; so the dictionary needs to get passed along in a generic way)
12:02:37 <Zoltrov> geekosaur, I don't get the '--' in your syntax
12:02:41 <Zoltrov> Isn't that a comment?
12:02:42 <haasn> geekosaur: -- is a comment
12:02:48 <haasn> err, Zoltrov
12:02:51 <Zoltrov> Yeah, I know
12:02:56 <geekosaur> that was haasn, not me
12:03:01 <haasn> I'm just adding the information that Foo :: Class a => a -> Foo
12:03:04 <Zoltrov> O yeah, I see
12:03:04 <haasn> That's not part of the definition :)
12:03:35 <augur> jmcarthur_mobile: i was thinking like..   ntimes c 0 = empty ; ntimes c n = char c >> ntimes c (n - 1)
12:04:02 <augur> and then you do   noncf n = ntimes 'a' n >> ntimes 'b' n >> ntimes 'c' n
12:04:24 <Zoltrov> haasn, hmm, so the 'Foo' data constructor requires that its argument is in class Class basically
12:04:32 <Zoltrov> And that cannot be completely statically realied
12:04:46 <augur> jmcarthur_mobile: and then you wrap that up so that it tries   noncf 0 <|> noncf 1 <|> noncf 2 <|> ...
12:06:37 <haasn> Zoltrov: consider let foo | someReallyHardProblem = Foo x | otherwise = Foo y
12:06:45 <haasn> where x and y have different types (thus, different Class instances)
12:07:22 <haasn> deconstructing ‘foo’ will give you some parameter that is either ‘x’ or ‘y’, but at compile time it is not readily possible to know which without solving someReallyHardProblem
12:08:32 <haasn> but say Class has classMethod :: Class a => a -> String; instance Class X where classMethod _ = "x"; instance Class Y where classMethod _ = "y";  main = putStrLn $ let Foo x = foo in classMethod x -- does this code output ‘x’ or ‘y’? The compiler sure doesn't know
12:08:50 <Zoltrov> haasn, ah yeah, I see
12:09:12 <Zoltrov> That comes pretty close to a type hierarchy actually
12:09:26 <monochrom> https://github.com/treblacy/random-read
12:09:43 <augur> jmcarthur_mobile: ahh but that plan doesnt guarantee termination. interesting.
12:09:55 <augur> at least not for a^n b^n c^n
12:10:16 <haasn> Zoltrov: existential types can be seen as a kind of type hierarchy, yeah; also note that existential types are way less useful than you might think
12:10:51 <augur> im sure some other way to make it work is possible tho, like returning tags or something, in a kind of Attribute Grammar simulation
12:10:56 <haasn> in this case it'd be way easier to just define let foo | someReallyHardProblem = "x" | otherwise = "y" -- instead of going through a type class
12:11:13 <Zoltrov> haasn, well the reason I did't know this is because the only ting I ever used them for was super theoretical stuff
12:11:37 <augur> Zoltrov: what was your type class question? i didnt se eit
12:11:55 <Zoltrov> I once used that together with GADTs to make it possible for a list to contain [a->b,b->c,c->d,d->e] etc to fold a list
12:12:16 <Zoltrov> augur if it was possible to conform to the standard with a pure static resolution of typeclasses
12:12:28 <augur> what? o_O
12:14:16 <heatsink> No, type classes have to be dynamic
12:15:10 <heatsink> See http://stackoverflow.com/a/10535629/507803 for an example where type classes can't be resolved statically
12:16:03 <haasn> Zoltrov: a very interesting use case for existentials (in my opinion) is data Dict where Dict :: c => Dict c
12:16:27 <haasn> as seen in http://hackage.haskell.org/package/constraints-0.3.3/docs/Data-Constraint.html
12:16:31 <Zoltrov> heatsink, that one is quite interesting
12:17:16 <Zoltrov> (and something I would probably disallow if I mde t all)
12:22:14 <augur> heatsink: resolution is static, passing/construction is dynamic
12:23:25 <heatsink> Resolution means inserting the code that computes evidence of class membership?
12:24:01 <augur> surely resolution is solving class constraints
12:24:43 <augur> using enforcing the constraints, and putting in whatever magic generators are necessary
12:25:27 <augur> actually im not sure how the instance-with-constraints things are handled, because thats where all the power of type classes really is
12:25:48 <augur> the magic of type classes is the infinity, not the ad hoc polymorphism
12:26:02 <heatsink> You mean how constraints on an instance declaration are handled?
12:26:10 <augur> yeah
12:26:18 * heatsink implemented a type class system a while ago
12:26:18 <augur> and how they get used
12:26:34 <augur> i mean, being able to do   instance Foo a => Foo (f a) where ...
12:26:35 <augur> for some f
12:26:39 <augur> is really useful, right
12:26:42 <augur> thats the magic
12:26:43 <fabydonciao> ciao a tutti
12:26:48 <fabydonciao> !list
12:26:48 <monochrom> fabydonciao: http://lpaste.net
12:26:59 <augur> thats really it. thats where typeclasses get their power
12:27:17 <heatsink> The instance declaration becomes a function that generates a class dictionary.  It takes the constraints as parameters.
12:27:19 <augur> thats why agda, for instance, doesnt pass with implicits -- it has no generative capacity there
12:27:31 <augur> heatsink: sure, i figured as much, but how does that get used?
12:28:01 <heatsink> When solving a class constraint, the constraints become added to the current constraint set and must also be solved.  Their solutions produce the function parameters.
12:28:08 <heatsink> How does what get used?
12:28:34 <heatsink> I mean, when an instance is used to solve a class constraint, its premises are added to the current constraint set.
12:29:04 <augur> is that how you did it?
12:29:21 <augur> SPJ always describes it as being handled all at compile time
12:29:48 * geekosaur wonders how long before freenode starts watching for privmsg responses to !list and /kill-s both
12:29:49 <augur> but i guess thats really just the threading of instance records
12:30:02 <augur> geekosaur: ?
12:30:27 <heatsink> Compile time solving ensures that all class membership constraints hold.  In polymorphic code, it doesn't find the actual solution to the constraints.
12:30:45 <heatsink> Code to compute evidence of the actual solution is generated b the solving process
12:30:53 <heatsink> That evidence is class dictionaries.
12:31:00 <augur> are you sure?
12:31:20 <augur> i mean, for non-generative instances, you can do it all statically
12:31:40 <augur> i think. maybe.
12:31:44 <heatsink> I don't know what 'generative' means.  Is that outside Haskell 98?
12:32:06 <augur> im just using generative to mean the things that look like   instance Foo a => Foo (f a) where ...
12:32:30 <heatsink> Yes, that's solvable statically
12:32:32 <augur> the instance declaration generates this infinite collection of Foo instances from some base instances
12:33:15 <augur> but im confident that you can get the non-generative instances at compile time, since the ultimate usage sites -- via main -- fix the types, and thus the instances, no?
12:33:28 <augur> maybe not
12:33:47 <heatsink> Solving is more of a proof search process.  You don't generate all the solutions and then search for the right one
12:33:55 <augur> no i know that
12:34:03 <augur> but doesnt that search happen in type checking
12:34:06 <augur> not in execution?
12:34:49 <heatsink> Yes, the search process happens during type checking
12:35:05 <augur> so then i dont see what you have to construct at runtime
12:35:32 <heatsink> At runtime, it's not enough to know that Eq (T a b) holds
12:35:45 <heatsink> You have to have the actual value of (==) and (/=) for T a b
12:35:59 <augur> well yes, but that's given to you
12:36:00 <heatsink> Proof search only verifies that Eq (T a b) holds
12:36:11 <augur> i mean, the standard way of handlign constraints is that
12:36:13 <augur> Foo a => ...
12:36:31 <augur> is turned into a record type argument   Foo a -> ...
12:36:50 <augur> f :: Foo a -> b ; f = some_b
12:36:51 <augur> becomes
12:37:00 <augur> f :: Foo a -> b ; f foo_a = some_b
12:37:12 <heatsink> yea
12:37:15 <augur> the instances are just already there
12:37:24 <augur> you dont have to search for it
12:37:25 <augur> its given to you
12:38:39 <heatsink> The search is partly in type-checking f and partly type-checking callers of f.  Similarly, part of the evidence is computed in each place
12:39:11 <augur> in what sense
12:39:32 <heatsink> Suppose I have a function f x = g [x, x]
12:39:39 <heatsink> and g has an Eq constraint on the type of x
12:39:59 <heatsink> Then, in f, it needs to create the Eq dictionary for list-of-x and pass it to g
12:40:02 <augur> ok so   g :: Eq a => [a] -> b
12:40:17 <augur> and f :: Eq a => a -> b
12:40:32 <heatsink> g :: Eq a => a -> Bool; f :: Eq b => b -> Bool
12:40:49 <augur> er..
12:40:55 <heatsink> and, in the body of f, b = [a]
12:40:57 <augur> not with the definition you gave of f :P
12:41:01 <heatsink> I mean, a = [b]
12:41:15 <augur> that cant be right either!
12:41:35 <augur> oh wait yes it can
12:42:04 <augur> can you write that?   g :: Eq [b] => [b] -> Bool
12:42:11 <augur> i suppose you can
12:42:14 <heatsink> Yes, if you turn on extensions
12:42:40 <augur> and you're explicitly typing these things
12:42:47 <augur> f :: Eq a => a -> Bool
12:42:53 <augur> f x = g [x,x]
12:43:00 <augur> g :: Eq [a] -> [a] -> Bool
12:43:04 <augur> g = ...
12:43:05 <heatsink> I just tried it in GHCi.  It can infer the right types.
12:43:25 <heatsink> g :: Eq a => a -> Bool
12:43:38 <heatsink> > let g x = x == x
12:43:39 <augur> ah ok
12:43:40 <lambdabot>   not an expression: `let g x = x == x'
12:44:00 <heatsink> > let g x = x == x in let f x = g [x, x] in (f 1, f "1")
12:44:01 <lambdabot>   (True,True)
12:44:56 <augur> let's say g :: Eq b => b -> Bool then, yes
12:45:05 <augur> so in f, then, we solve b == [a]
12:45:13 <augur> we need to provide g with Eq [a]
12:45:17 <heatsink> right
12:45:18 <augur> f provides us with Eq a
12:45:41 <heatsink> So that's an example where proof search ensures class membership statically, but doesn't build the dictionaries statically
12:45:41 <augur> in type checking/compiling, won't this desugar tho to something like
12:46:01 <augur> f eq_a x = g (eq_a_lista eq_a) [x,x]
12:46:37 <heatsink> yes
12:46:45 <augur> no run-time search for the instance
12:46:59 <augur> runtime construction, to be sure
12:47:08 <augur> but i wouldnt want to call that resolution
12:48:14 <heatsink> ok, then I won't call it resolution
12:50:23 <augur> i feel like resolution is the type checking component, since those witness-construction functions + args are really just ugly names for the instance witnesses anyway
12:53:01 <heatsink> Is there a difference between witnesses, evidence, and proofs?
12:59:23 <augur> heatsink: well, here there might be, i dont know
13:00:08 <augur> i want to say no, tho.
13:00:27 <heatsink> alright
13:00:36 <augur> i hope that haskell's type checker + witness constructor lets that identity hold
13:00:45 <heatsink> I see what you mean about the witness-computing functions being witnesses themselves
13:01:02 <augur> well, if f :: a -> b, and x :: a
13:01:12 <augur> then f x :: b just is a witness to b
13:01:37 <augur> but its not normalized, you know, so you might want to say it's not "really" a witness it just computes one, but as far as the typing is concerned it is
13:02:38 <augur> so to say that youre dynamically finding the witness is a bit of a lie. you have the witness. you just dynamically compute it down to a usable form
13:02:44 <augur> but then, thats just computation in general
13:02:54 <sdx23> hlint does not suggest "drop 1 = tail" - should it?
13:03:20 <geekosaur> no
13:03:33 <geekosaur> > drop 1 []
13:03:34 <lambdabot>   []
13:03:39 <geekosaur> > tail []
13:03:40 <lambdabot>   *Exception: Prelude.tail: empty list
13:03:55 <geekosaur> if anything, drop 1 is the preferred of the two
13:04:11 <sdx23> geekosaur: ah, i.c. thanks
13:06:43 <martsbradley> jkkjk:w
13:06:51 <martsbradley> sorry
13:07:18 <heatsink> Either you're just kidding, or using vi
13:07:21 <HectorAE> :]
13:07:45 <martsbradley> vi
13:07:45 * geekosaur points to :script in nvi, and probably vim has something similar...
13:07:57 <geekosaur> or, of course, there's the ever popular "wrong window"
13:08:38 <martsbradley> I'm getting used to xmonads also so did not know where the cursor was.
13:09:04 <FireFly> geekosaur: what is :script ?
13:09:19 <chrisdone> it runs the given file as if you'd typed each line into ghci
13:09:41 <geekosaur> in nvi, it gives you a buffer that is interacting with a shell
13:10:04 <FireFly> not possible in vim afaik
13:10:31 <geekosaur> but you still have insert vs. command mode
13:24:37 * hackagebot git-annex 5.20131130 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20131130 (JoeyHess)
13:25:05 <_d3f> /j #turpial
13:25:16 <_d3f> sry misstyped
13:26:13 <HectorAE> Lots of mistakes being made in this channel lately.
13:27:05 <henk> Where/how would I find haskell applications providing a GUI? And which toolkits (or other ways of writing a haskell programm with a GUI) are recommendable, in widespread use, stable, etc?
13:33:32 <HectorAE> henk, xmonad.
13:34:36 <henk> HectorAE: oh, right, thank you.
13:35:46 <tespa> hi
13:35:56 <tespa> I get errors when I try to compile with haskel
13:36:02 <tespa> a program that is expected to compile
13:36:14 <Fuuzetsu> Well, what are you compiling and what are the errors?
13:36:15 <augur> tespa: paste the code and the errors you get
13:36:23 <Fuuzetsu> @where lpaste
13:36:23 <lambdabot> http://lpaste.net/new/haskell
13:36:23 <augur> lpaste.net
13:36:27 <augur> one paste each
13:38:58 <tespa> http://pastebin.com/RHmSasEA
13:38:59 <mauke> The paste RHmSasEA has been copied to http://lpaste.net/96417
13:39:00 <tespa> augur
13:39:03 <tespa> here u go
13:39:47 <Fuuzetsu> tespa: You're compiling pretty old code. Paste the code in for us as well (but I can tell you ahead of time to remove ‘import List’
13:39:58 <Fuuzetsu> You might want ‘import Data.List’
13:40:19 <tespa> would it work if I would get an older version of Haskell?
13:40:20 <augur> mauke is manually copying all pastebin stuff :x
13:40:31 <geekosaur> a very old version, yes
13:40:48 <Fuuzetsu> tespa: It'll be much easier to fix up the code.
13:40:56 <tespa> http://cs.fit.edu/~ryan/cse4250/quad.html
13:40:59 <tespa> I am doing this assignment
13:41:13 <tespa> my partner sent me the code
13:41:21 <geekosaur> 6.4.1, sigh
13:41:21 <tespa> and I have to fix it but I can't get it to compile
13:41:41 <HectorAE> So... Fix it.
13:41:42 <geekosaur> you might also try -XHaskell98
13:41:52 <tespa> it should compile at first HectorAE
13:42:14 <HectorAE> Well if it doesn't it's obviously broken
13:42:21 <geekosaur> hm, except that page also shows import of System.IO
13:42:27 <Fuuzetsu> You need to tell your partner to stop living in the past. tespa, it won't compile without either a) fixing the code up to work with a semi-modern GHC or b) using an old compiler and libraries
13:42:29 <geekosaur> so yes, you get to fix it.
13:42:30 <HectorAE> How do you fix something that already works
13:42:41 <geekosaur> Fuuzetsu, the web page is telling them to use 6.4.1
13:42:52 <tespa> THis is the version of compiler I have
13:42:53 <tespa> The Glorious Glasgow Haskell Compilation System, version 7.6.3
13:43:04 <geekosaur> see under "Turning it in"
13:43:05 <tespa> I am not going to dispute if the code compiles or not with u, I verified with my partner it does
13:43:13 <tespa> I know
13:43:21 <Fuuzetsu> geekosaur: It also says  - Course: CSE 4250, Fall 2010
13:43:23 <tespa> but how do I get that version of Haskell?
13:43:32 <constantius> ?src error
13:43:33 <lambdabot> error s = throw (ErrorCall s)
13:43:39 <Fuuzetsu> tespa: With great difficulty. AFAIK you can get the binaries from the GHC website
13:44:13 <geekosaur> but I'm not sure you can build 6.4.1 with 7.4 or 7.6?
13:44:15 <henk> augur: align on the left?
13:44:28 <augur> henk: ?
13:44:30 <tespa> any workarounds?
13:44:31 <Fuuzetsu> http://www.haskell.org/ghc/download_ghc_641
13:44:54 <tespa> thx Fuuzetsu I will try it and let u know
13:45:12 <Fuuzetsu> tespa: E-mailing the course tutor would probably be the best idea.
13:45:14 <tespa> u think it will work on windows 7?
13:45:21 <henk> augur: oh, you did reference a movie there, did you not?
13:45:22 <HectorAE> Your professor must be some kind of sadist.
13:45:26 <dcoutts_> geekosaur: no, can only build with older versions not newer
13:45:29 <augur> henk: uh.. what
13:45:33 <tespa> HectorAE He is!
13:45:34 <tespa> lol
13:45:58 <heatsink> -XHaskell98 works for me on 7.4.1
13:46:09 <henk> augur: oh, sorry, never mind, thought "one paste each" was supposed to be a movie reference (;
13:46:17 <augur> no
13:46:31 <Fuuzetsu> heatsink: …sure, you can turn it on, but do you have tespa's code to try it on?
13:46:56 <heatsink> No.  I just tested whether "import List" worked, since that's the error message tespa had
13:47:16 <tespa> but would it be safe for me to use that version?
13:47:30 <dcoutts_> tespa: best bet is just to download the old ghc version, it should work on new windows 7 ok
13:47:46 <Fuuzetsu> Yes, the safest is to use the version they want you to.
13:47:48 <tespa> ok I will try
13:48:30 <Fuuzetsu> At least it's not someone seeing Hugs help.
13:48:48 <constantius> hello. I'm a newbie and I can't figure out whether calling "error" on child thread is ok? (I'm not seeing the message on console)
13:49:24 <constantius> when I did it on main thread it worked OK. can somebody help me out?
13:50:00 <Fuuzetsu> You shouldn't really be using error…
13:50:44 <tespa> now the command line says ghc not recognized
13:50:56 <tespa> I unistalled my previous version of ghc first and installed the .msi
13:51:08 <tespa> the Windows (x86) (standalone)
13:51:14 <dcoutts_> constantius: are you sure it does not print any message, it should do (and it does for me)
13:51:15 <heatsink> If you're not familiar with how lazy evaluation works, and you want to throw an exception, you should throw the exception in IO code
13:51:22 <Fuuzetsu> make sure it's in your PATH properly
13:51:26 <constantius> Fuuzetsu: I'm just trying to learn threads
13:51:47 <tespa> Fuuzetsu how to do that?
13:51:56 <dcoutts_> constantius: by default, any exception that propagates to the top level of a forkIO'd thread just gets printed to stderr
13:52:11 <Fuuzetsu> Not sure, I don't use Windows but I know there are tons of guides online.
13:52:15 <constantius> dcoutts_: I do see the message when I do that on main thread
13:52:26 <constantius> dcoutts: but not on child one
13:52:54 <dcoutts_> constantius: are you sure your program is waiting for the children threads to run?
13:53:10 <dcoutts_> e.g. if you just forkIO and then the main thread exits then the program terminates
13:53:52 <Iceland_jack> constantius: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent.html#g:13
13:53:58 <constantius> dcoutts_: yep I'm using forkFinally with MVar for tracking child thread exit as described there
13:54:28 <constantius> Iceland_jack: thx, I'm doing exactly this
13:55:14 <dcoutts_> constantius: ok, and what are you doing with the exception?
13:55:29 <dcoutts_> constantius: I'm guessing you're not printing it or throwing it
13:55:36 <dcoutts_> which is why you don't see it
13:55:57 <heatsink> Are you sure the result of the error expression is being used?
13:56:06 <heatsink> If you make an error value and don't use it, you won't see the exception
13:56:09 <dcoutts_> constantius: it's only the top level handler for the main thread or forkIO'd threads that end up printing unhandled exceptions
13:56:12 <heatsink> due to lazy evaluation
13:56:23 <constantius> hmm
13:56:26 <dcoutts_> but if you're using forkFinally then it's not unhandled, because you're handling it manually
13:56:36 <dcoutts_> constantius: it might help if you showed us the code
13:57:12 <constantius> I nearly got it, then how should I handle the exception to make it visible?
13:57:53 <dcoutts_> if what you really want to do is print it, then you can do that
13:57:56 <dcoutts_> using print
13:59:37 <heatsink> dcoutts_, do you know if anyone's gotten concatMap fusion to optimize reliably?
14:00:06 <constantius> okay I poked around and it seems that the problem is not with error in child thread
14:00:26 <constantius> I'm actually trying to use vty-ui and I want to run it in separate thread
14:00:42 <dcoutts_> heatsink: yes, the answer is yes
14:01:37 <constantius> this is the code https://gist.github.com/constantius9/7725038
14:01:40 <heatsink> I'm interested in how that works.  Do you have a reference, or some code I could look at?
14:02:09 <dcoutts_> heatsink: no reference yet, it's not published yet unfortunately (not my work).
14:02:27 <dcoutts_> heatsink: send me an email and I can put you in touch with the authors
14:03:11 <heatsink> I found your well-typed e-mail.  Shall send you a note.
14:03:26 <constantius> ?src Graphics.Vty.Widgets.All.runUi
14:03:26 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
14:03:40 <dcoutts_> heatsink: the basic idea is described in my thesis, but the details are more complicated
14:04:15 <dcoutts_> heatsink: so if you want the basic idea, http://code.haskell.org/~duncan/thesis.pdf section 4.8.3 (page 244)
14:05:30 <heatsink> got it
14:06:35 <heatsink> thanks
14:07:14 <dcoutts_> np
14:18:12 <Tehnix> anyone know of an estimated release date on ghc 7.8? :x
14:18:28 <ion> The wiki has IIRC.
14:18:30 <Fuuzetsu> Tehnix: Soon™
14:18:32 <ion> has one
14:18:41 <chrisdone> a few months baack it was predicted december
14:18:48 <chrisdone> a release candidate, anyway
14:20:57 <Tehnix> it was said to be ~25th of november, was just wondering if I might have missed any announcements or anything ^_^
14:22:36 <Fuuzetsu> Well, I'm pretty sure it's been pushed back since like the end of October or something
14:26:43 <cschneid> The stream fusion post today on Reddit / Hacker News raises a question about "is there any downside to using stream-fusion"?  Is there? A quick glance at the stream-fusion package on hackage doesn't say anything
14:29:50 <josaliba> Hey guys, I'm still trying to learn haskell, and I'm trying to return some JSON from my handler in yesod. I was looking at examples online and testing them. I found this, but when I run it, it tells me that '..' is Illegal there
14:29:56 <josaliba> http://lpaste.net/6655192515395715072
14:30:24 <constantius> for whatever silly reason it works as expected now
14:30:36 <josaliba> Not sure what I should be putting there to fix it. Any help would be really appreciated
14:30:57 <heatsink> I think it's an extension
14:31:31 <constantius> I just moved the inline lambda to separate function and it became OK...
14:31:43 <josaliba> (oops, it's this that I'm testing: http://lpaste.net/4013295803060715520 )
14:32:07 <constantius> dcoutts_: thank you for helping out
14:32:12 <heatsink> josaliba: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
14:32:46 <heatsink> To use it, you need to turn on the RecordWildCards extension
14:34:08 <josaliba> heatsink, hmm, how would I do that in yesod? is there a config file for it? (I'm testing with `yesod devel`)
14:34:58 <heatsink> You can put {-# LANGUAGE RecordWildCards #-} before the beginning of the module
14:37:05 <josaliba> heatsink, :D thank you!
14:57:50 <josaliba> If I have this data type http://lpaste.net/9054876548527554560 , what's the best way to encode it into json correctly?
15:00:21 <cschneid> if I have a function like: `pairMaybe a b = (,) <$> a <*> b`, can I write it in a way that's infix? so the code presents the look of it's return value: (a,b).
15:00:38 <cschneid> as opposed to having the (,) function as the prefix of the line there
15:00:39 <troydm> josaliba: are you looking for haskell json library?
15:01:05 <Iceland_jack> cschneid: You can always write it (and define it) as:
15:01:05 <Iceland_jack>     Nothing `pairMaybe` Just 10
15:01:27 <Iceland_jack> then you just wrap it in parentheses and it's not that dissimilar
15:01:47 <troydm> josaliba: http://hackage.haskell.org/package/json
15:01:51 <cschneid> Iceland_jack: more of an applicative syntax question than anything with Maybe. The general style is `f <$> a <*> .... <*> z`
15:02:06 <cschneid> Iceland_jack: is `f` "stuck" in that position, when it might make sense as an infix?
15:02:14 <josaliba> troydm, well I was already doing something like this http://lpaste.net/6442323499435425792 and it was working
15:02:27 <Iceland_jack> You can use: liftA2
15:02:27 <Iceland_jack> @ty liftA2
15:02:27 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:02:33 <Iceland_jack> but other than that.. not really
15:02:35 <josaliba> troydm, not sure how to use a similar syntax for my other data type
15:04:13 <cschneid> Iceland_jack: what I'm thinking is something like this: y a b = a `liftA2 (,)` b -- but one that actually works. :)
15:04:35 <Iceland_jack> You can use an expression within `...`
15:04:39 <Iceland_jack> *cannot
15:04:45 <cschneid> Iceland_jack: right.
15:04:55 <Iceland_jack> I'm not sure what exactly you're asking
15:05:25 <cschneid> just rearranging the function def to reflect a non-applicative style `(a,b)`.  Just playing with syntax & options atm
15:06:00 <Iceland_jack> @let { (++++) :: Applicative f => f a -> f b -> f (a, b) ; (++++) = liftA2 (,)  }
15:06:01 <lambdabot>  Defined.
15:06:06 <Iceland_jack> > Just 10 ++++ Just 5353
15:06:07 <lambdabot>   Just (10,5353)
15:07:21 <cschneid> Iceland_jack: cool - I figured I could do a new function, but beyond that it seems that applicative style starts w/ the fmapping of the function and chains on the args.
15:07:31 <cschneid> Iceland_jack: thanks for letting me be confused & talk through it :)
15:08:50 <Iceland_jack> @undef
15:08:50 <lambdabot> Undefined.
15:08:50 <Iceland_jack> I'm not sure how much I helped since I don't fully understand the problem, but explaining (formalizing) something you're confused about is a good exercise :)
15:09:03 <Iceland_jack> so carry on!
15:14:14 <henk> Is leksah in widespread use? What do you use for writing haskell code? If it’s vim: any plugin/addon recommendations which make writing haskell more comfortable?
15:14:46 <FreeFull> I usually just use plain vim
15:14:57 <FreeFull> It'd be nice to have something that could tell me the contents of modules and the definitions of stuff though
15:15:17 <cschneid> henk: inside vim, I use syntastic + ghc-mod to check my code on save.  And I use hdevtools to get types on demand of various expressions.
15:15:45 <cschneid> henk: haven't worked with large enough projects that tags would be useful, but vim's support of tags is really good, see tagbar and similar.
15:16:13 <cschneid> otherwise, Ack plugin and Ctrl-p to do file search & navigation. Those are generic tools, not haskell specific
15:16:28 <xvilka> FreeFull: there is a nice thing - hdevtools
15:16:34 <xvilka> FreeFull: works awesome with vim
15:17:39 <xvilka> FreeFull: https://github.com/bitc/vim-hdevtools
15:17:46 <FreeFull> Does hdevtools actually do either of those things?
15:19:15 <henk> cschneid, FreeFull: thanks (:
15:19:42 <cschneid> FreeFull: hdevtools gives you type information in your code, I have it mapped, and each time I hit it, it expands the scope of the type info a step, which is super handy for me. But yeah, it's not a "what module" kind of thing
15:20:13 <FreeFull> cschneid: I've used it before, so I know it does that
15:20:20 <xvilka> FreeFull: try vim-hdevtools
15:20:23 <cschneid> all it does though. afaik
15:21:26 <cschneid> FreeFull: a good hoogle interface would be awesome. and/or auto-complete using similar.
15:21:51 <cschneid> I bet it'd be straightforward with the Unite plugin. free user interface to a haskelly backend basically
15:22:01 <FreeFull> Autocomplete would be nice. Vim's default autocomplete only looks at stuff in the current file
15:22:34 <FreeFull> I think what I basically would want would be ghci inside the editor
15:23:35 <benzrf> @pl \a -> f a a
15:23:35 <lambdabot> join f
15:23:39 <benzrf> ?
15:23:41 <cschneid> FreeFull: check out `:help cpt` - might make autocomplete a bit better.
15:23:42 <benzrf> :t join
15:23:43 <lambdabot> Monad m => m (m a) -> m a
15:24:01 <Iceland_jack> @ty join :: (r -> r -> a) -> (r -> a)
15:24:01 <Iceland_jack> benzrf: ↑
15:24:01 <lambdabot> (r -> r -> a) -> r -> a
15:24:25 <benzrf> o:
15:24:25 <cschneid> FreeFull: and yeah, I have tmux split pane with ghci side by side w/ vim. Seems to work, although not perfect. One of the slime plugins would probably be slick.
15:24:44 <Iceland_jack> @ty join replicate 10
15:24:44 <lambdabot> [Int]
15:24:47 <Iceland_jack> > join replicate 10
15:24:48 <lambdabot>   [10,10,10,10,10,10,10,10,10,10]
15:24:49 <FreeFull> cschneid: I'd want the completion to consider what's in scope in that file
15:24:50 <Iceland_jack> > join replicate 15
15:24:51 <lambdabot>   [15,15,15,15,15,15,15,15,15,15,15,15,15,15,15]
15:25:05 <FreeFull> Which vim definitely cannot do on its own
15:25:08 <xvilka> cschneid: FreeFull: ++, using tmux splitting too (or awesome splitting for gvim case)
15:25:20 <cschneid> FreeFull: ahh, yeah, that's getting fancier :) Would certainly be cool to figure out. Agreed it has to shell out to .. something... to figure out all the names in scope
15:25:40 <xvilka> cschneid: there was slimv plugin for vim. Can be adapted for haskell, i think
15:26:20 <FreeFull> Right now I tend to mess around with code in ghci and then put it down into the file once I've got what I wanted figured out
15:26:54 <_justjust> i made cabal sandbox init and then install netwire inside the sandbox, now GHC says: Could not find module `FRP.Netwire' but Control.Wire seems to be ok, any ideas?
15:26:57 <cschneid> FreeFull: xvilka: check out tslime.vim (https://github.com/kikijump/tslime.vim/blob/master/tslime.vim), might make a tmux workflow smoother. Would require custom mappings to what you actually want.
15:27:17 <cschneid> I'll have to come up w/ a proper feature set desired for a haskell plugin like that, and see if I can't write it.
15:28:11 <FreeFull> cschneid: Encase URLs in <>, it's an RFC standard and the > won't be parsed as part of the URL
15:28:45 <cschneid> FreeFull: ok. :) did it confuse your client's parser?
15:29:18 <FreeFull> I think ) is valid in URLs, my terminal certainly thought it was part of the URL
15:30:19 <tespa> main.hs:69:10:
15:30:19 <tespa>     Couldn't match `[t]' against `(a, b)'
15:30:19 <tespa>       Expected type: [t]
15:30:19 <tespa>       Inferred type: (a, b)
15:30:19 <tespa>     When checking the pattern: (_, _)
15:30:20 <tespa>     In the definition of `reArrange': reArrange (_, _) = error "Error"
15:30:23 <cschneid> FreeFull: yeah, didn't even think about it. I know I've run into similar annoyances.
15:30:28 <tespa> whats that all about
15:30:56 <FreeFull> tespa: What's the type of reArrange?
15:31:11 <tespa> reArrange :: [t] -> [t]
15:31:11 <tespa> reArrange (a:b:c:d:[]) = a:c:b:d:[]
15:31:11 <tespa> reArrange ([]) = error "Error"
15:31:11 <tespa> reArrange (_) = error "Error"
15:31:11 <tespa> reArrange (_,_) = error "Error"
15:31:12 <tespa> reArrange (_,_,_) = error "Error"
15:31:15 <tespa> reArrange (_,_,_,_) = error "Error"
15:31:18 <geekosaur> please don't paste into channel
15:31:23 <geekosaur> @where lpaste
15:31:23 <lambdabot> http://lpaste.net/new/haskell
15:31:25 <tespa> ok bro
15:31:33 <fizruk> tespa, (_, _) is syntax for tuples, not lists
15:31:34 <cschneid> tespa: 1) please use a pastebin, 2) commas define a tuple, but you're working with lists.
15:31:46 <cschneid> tespa: you probably mean (_:_) instead
15:31:48 <FreeFull> tespa: Lists use : and not ,
15:31:50 <cschneid> with the list cons operator.
15:31:52 <tespa> what to do to fix it
15:31:54 <FreeFull> If it's , then it's a tuple
15:32:04 <fizruk> tespa, reArrange _ = error "Error"
15:32:05 <geekosaur> "bro" lose that too, not everyone intelligent here is male
15:32:12 <FreeFull> Also, for all the error cases you can use what fizruk said
15:32:15 <Hafydd> What do you hope the function will actually do?
15:32:22 <chrisdone> button up your shirt, too! and polish those boots!
15:32:37 <FreeFull> Hafydd: Swap the second and third element of the list, it seems
15:32:44 <Hafydd> I was not asking you.
15:32:48 <tespa> ok mate
15:33:13 <FreeFull> tespa: Do you want your function to work on lists that are longer than 4?
15:33:20 <tespa> Not sure
15:33:24 <chrisdone> Hafydd: lol. ask a question without any nick ref and then say you weren't asking the first person who answers
15:33:25 <tespa> FreeFull
15:33:28 <bennofs> Is there a way to get the path to the built executable from a test suite in Cabal ?
15:42:27 <Hafydd> What a productive conversation.
15:43:52 <chrisdone> Hafydd: does somebody need a scooby snack?
15:43:58 <volty> fortune-tellers (want more params? want less params? )
15:44:22 <benmachine> bennofs: do you know about the Paths_ modules?
15:44:54 <bennofs> yeah, is there documentation about what the Paths_ module actually contains anywhere?
15:45:43 <chrisdone> http://neilmitchell.blogspot.it/2008/02/adding-data-files-using-cabal.html
15:47:17 <benmachine> bennofs: http://lpaste.net/96421
15:47:28 <benmachine> bennofs: there may be documentation as well
15:47:33 <bennofs> Btw, does anyone know how to fix this:
15:47:35 <bennofs> Warning: Could not list sources of the add-source dependency 'hcltest'.
15:47:38 <bennofs> Skipping the timestamp check.
15:47:51 <skypers> > foldr const 0 [1..10]
15:47:52 <lambdabot>   1
15:48:14 <skypers> > foldl const 0 [1..10]
15:48:15 <lambdabot>   0
15:49:41 <skypers> > foldl1 (flip const) [1..10]
15:49:42 <lambdabot>   10
15:50:11 <Tordek> skypers: perhaps you meant ghci instead of irc-client?
15:50:26 <valid_nickname> let fib = 1 : 1 : zipWith (+) fib (tail fib) in take 10 fib
15:52:52 <valid_nickname> >let fib = 1 : 1 : zipWith (+) fib (tail fib) in take 10 fib
15:53:04 <Iceland_jack> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in take 10 fib
15:53:05 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
15:59:56 * hackagebot attoparsec-parsec 0.1.2 - An Attoparsec compatibility layer for Parsec  http://hackage.haskell.org/package/attoparsec-parsec-0.1.2 (SimonHengel)
16:00:38 <bennofs> is Cabal a dependency of GHC?
16:01:02 <bennofs> (i.e. is installed with GHC?)
16:02:32 <Cale> bennofs: The Cabal library is installed with GHC, I believe.
16:03:10 <josaliba> how is it possible to encode a data like this http://lpaste.net/1664820583394705408 to JSON
16:06:04 <Hafydd> Joseph Saliba?!
16:06:43 <josaliba> yes
16:07:12 <Hafydd> Interesting to see you here. I once worked on a second year final project with you; but nevermind.
16:08:10 <enthropy> you should decide what the json is supposed to look like
16:08:25 <ReinH> josaliba: sure, if you define some JSON schema for it.
16:08:38 <ReinH> JSON per se isn't sufficient
16:08:56 <josaliba> ReinH is it possible to give me an example? I've been struggling
16:09:01 <josaliba> Hafydd, whats your name?
16:09:44 <ReinH> Could be as simple as { type: "circle", values: [1,1,1] }
16:10:11 <Hafydd> Or ["circle", float, float, float] or ["rectangle", float, float, float, float]; or {"type":"circle", x:float, y:float, r:float} or {"type":"rectangle", l:float, t:float, r:float, b:float} might also do.
16:10:13 <ReinH> the point is that you'll have to define the semantics for encoding/decoding yourself
16:10:58 <josaliba> {"type":"circle", x:float, y:float, r:float} seems good. but how can i set x, y and z
16:11:18 <ReinH> josaliba: that's a question for your JSON library, isn't it? :)
16:11:50 <enthropy> maybe it's enough to define a  f :: Shape -> String
16:11:52 <tespa> anyone can solve this? http://www.karrels.org/Ed/ACM/98/prob_g.html
16:11:55 <ReinH> If you're doing it from scratch you could implement ToJson and FromJson typeclasses
16:12:06 <josaliba> I was proceeding this way (for another data) http://lpaste.net/869966310367297536
16:13:01 <ReinH> josaliba: have a look at http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson-Encode.html
16:13:21 <Hafydd> It should be similar, then. object ["type" .= "circle", "x" .= x, ...].
16:13:27 <ReinH> encode :: ToJSON a => a -> ByteString, so just implement your ToJSON instance
16:14:06 <bennofs> You could also use TemplateHaskell to generate all this automatically though
16:14:11 <josaliba> Hafydd, but x isn't defined in my Circle data
16:14:15 <josaliba> data type*
16:14:39 <josaliba> i mean all i have is Circle Float Float Float  (Floats !)
16:14:47 <Hafydd> josaliba: in that case, I wrongly assume what your three Floats meant.
16:14:57 <ReinH> josaliba: well, you can pattern match and give them whatever names are appropriate
16:14:58 <josaliba> how can i access the 1st, 2nd or 3d float
16:15:00 <ReinH> or switch to a record
16:15:16 <Hafydd> Yes. Pattern match on (Circle x y r)
16:15:25 <Hafydd> If that's their meaning.
16:15:42 <ReinH> or data Circle = Circle { _x, _y, _r :: Float }
16:16:55 <josaliba> ok, thanks a lot guys. i will try that
16:30:46 <radish> ugh haskell is giving me unwarrented type concerns
16:30:52 <radish> painful
16:31:57 <Iceland_jack> radish: Can you give an example?
16:31:59 <radish> I defined a function as type (Int,Int,Int)->IO() and yes, somewhere far down the road I convert the ints to floats, but its saying that it cant decide if fn (1,1,1) should be floats, doubles, or something else.
16:32:30 <Iceland_jack> if the function has type: (Int, Int, Int) → IO () then it should have no trouble
16:32:32 <radish> I finally had to say ((1,1,1) ::(Int,Int,Int)) for basically no reason.
16:32:59 <radish> i'm curious if something else is the matter somewhere else
16:33:07 <Iceland_jack> @ty let {fn :: (Int, Int, Int) -> IO (); fn = undefined } in fn (1, 1, 1)
16:33:08 <lambdabot> IO ()
16:33:08 <radish> because that right there makes zero sense
16:33:11 <benmachine> radish: maybe you ought to put some code on lpaste.net and we can see if we can help
16:33:16 <Iceland_jack> radish: See?
16:33:48 <radish> Iceland_jack: whats with "undefined"
16:33:54 <radish> Iceland_jack: this is new to me
16:34:06 <Iceland_jack> It's just something you can use as a place-holder
16:34:11 <Iceland_jack> it fits with ever type
16:34:26 <Iceland_jack> @ty undefined == True
16:34:27 <lambdabot> Bool
16:34:29 <Iceland_jack> @ty undefined == 5
16:34:30 <lambdabot> Bool
16:35:24 <Iceland_jack> When you start coding you can begin by creating the desired functions with the desired types and leaving the body as ‘undefined’:
16:35:24 <Iceland_jack>     parseProcStat ∷ String → ProcStat
16:35:24 <Iceland_jack>     parseProcStat = undefined
16:35:35 <Iceland_jack> and it will type check
16:35:42 <radish> Iceland_jack: maybe that will help? I mean, I gave it the types it needed. it calls a function using the 1s and that function takes ints as well. i just dont get why its having trouble, but i dont think i want to bother you guys with it anymore. i was mainly just double checking that i was right in that it should have no problem
16:36:08 <radish> benmachine: thank you i might take you up on that but mainly i was just making sure i wasnt crazy to think that ought to work
16:36:12 <Iceland_jack> You're not bothering, you should put your current code up on lpaste.net
16:36:18 <radish> its kind of wild
16:36:43 <radish> i'm gonna hack at it some more and if i cant get something satisfactory i will pester y'all
16:36:43 <Iceland_jack> that way it will be easier to see what the problem is: like my above example showed what you described should work
16:36:50 <Iceland_jack> Okay :)
16:36:58 <radish> let me try one more time to get it right and then i'll send it over
16:37:24 <Iceland_jack> Also play around with bits and pieces in GHCi and get them to work there first
16:38:08 <radish> omg now the ::(int,int,int) thing isn't working XD
16:38:22 <radish> type declarations abound
16:38:27 <radish> thanks guys
16:38:36 <Iceland_jack> Glad to see it working radish :)
16:38:46 <Iceland_jack> What are you modeling with (Int, Int, Int)?
16:38:55 <radish> no it isnt working still
16:39:01 <volty> i'm installing hoogle with cabal // 1 . it take so much time, normal?  2.  Is it possble to setup a local web server with it (like http: ... haskell/hoogle ) ?
16:39:03 <radish> what do you mean?
16:39:16 <levi> Playing with things in ghci can often lead to type errors that don't show up in normal programs, though, since there's less code to use to infer the types and numeric literals are type-ambiguous.
16:39:27 <Iceland_jack> What is the value that (Int, Int, Int) is supposed to represent, coordinates?
16:39:36 <Iceland_jack> Or something else
16:39:37 <radish> iceland_jack: colors
16:39:45 <Iceland_jack> I see, you might want to create a data type for that
16:39:56 <Iceland_jack>     data Colour = MkColor Int Int Int
16:40:15 <Iceland_jack> (mixing American and British..)
16:40:20 <Iceland_jack> or even better:
16:40:20 <Iceland_jack>     data Colour a = MkColour a a a
16:40:36 <Iceland_jack> That way you can be polymorphic in the type of the colour
16:40:39 <radish> iceland_jack: whoa never seen that before
16:40:47 <heatsink> data Colour a = MkColour {r, g, b :: a}
16:40:54 <radish> iceland_jack it definately needs to be ints
16:40:55 <Iceland_jack> yeah, or what heatsink just posted
16:41:13 <radish> its actually red, blue, white ;)
16:41:19 <Iceland_jack> radish: Okay, you can go with:
16:41:20 <Iceland_jack>     data Colour = MkColour { red, blue, white ∷ Int }
16:41:47 <radish> iceland_jack: you are busting out all these weird syntaxes i've never seen lol
16:42:12 <Iceland_jack> radish: Maybe you should ignore the curly-braces syntax (record syntax)
16:42:15 <levi> Probably you'll want to add: deriving (Show, Read, Eq) and perhaps others.
16:42:27 <Iceland_jack> Do you want to see how it would be used radish?
16:42:39 <radish> iceland_jack so is that the same thing as MkColour Int Int Int?
16:42:40 <Iceland_jack> @let data Colour = MkColour Int Int Int deriving (Show, Eq)
16:42:40 <lambdabot>  Defined.
16:42:48 <Iceland_jack> > MkColour 5 26 255
16:42:50 <lambdabot>   MkColour 5 26 255
16:42:55 <Iceland_jack> @ty MkColour
16:42:56 <lambdabot> Int -> Int -> Int -> Colour
16:42:59 <radish> yes I know that bit
16:43:06 <Iceland_jack> That's a better representation than a 3-tuple of Int's
16:44:01 <afraca> Hey guys, another Haskell learning student here... how original ...
16:44:13 <radish> who me?
16:44:14 <benmachine> it's more self-documenting and it ensures you don't get colour triples mixed up with other things-that-are-basically-three-ints
16:44:15 <Iceland_jack> radish:
16:44:15 <Iceland_jack>     data Colour = MkColour Int Int Int
16:44:15 <Iceland_jack> is the same as
16:44:15 <Iceland_jack>     data Colour = MkColour { red ∷ Int, blue ∷ Int, white ∷ Int }
16:44:18 <levi> Everyone's gotta learn sometime.
16:44:18 <Iceland_jack> but it gives you accessor functions
16:44:28 <volty> nice, done, thanks
16:44:34 <radish> benmachine: yeah, i used to go way too type crazy though
16:44:39 <benmachine> Iceland_jack: it also gives you different pattern matching syntax and update syntax
16:44:53 <Iceland_jack> That's right
16:44:56 <radish> benmachine: data NumberForASinglePurpose = Int lol
16:44:58 <binq> you mean red, blue, green?
16:45:00 * hackagebot heist 0.13.0.3 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.0.3 (DougBeardsley)
16:45:01 <benmachine> radish: :)
16:45:02 * hackagebot snap 0.13.1.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.1.1 (DougBeardsley)
16:45:04 <Iceland_jack> binq: No
16:45:17 <radish> binq: nope
16:45:35 <Iceland_jack> radish: If you're not familiar with the record syntax, you can use the regular syntax instead
16:45:55 <radish> binq: its more about how the eye works and its only converted into RGB mode
16:46:12 <binq> ok
16:46:17 <radish> see i think the problem is to render it i have to convert to floats
16:46:32 <afraca> For some assignment on parsers I want to represent a digit with :  data Digit = Zero | One | Two | Three | Four | Five | Six | Seven | Eight | Nine  . But when I wanna define some types for Year and Month like  Year = Digit Digit Digit Digit  I get  hs:16:15:`Digit' is applied to too many type arguments
16:46:49 <Iceland_jack> > let x = 5 :: Int in fromIntegral x :: Float -- radish
16:46:50 <lambdabot>   5.0
16:47:01 <afraca> Sorry, that should be  type Year = Digit Digit Digit Digit
16:47:04 <radish> iceland_jack: yes, you would think
16:47:05 <levi> radish: Sometimes making a new type that's just a wrapper around a basic type is a fine thing to do. Sometimes it's even necessary. There are some more advanced Haskell bits (including some non-standard extensions) that make wrapper types easier to deal with.
16:47:16 <Mortomes> afraca: .nl.... Utrecht?
16:47:19 <afraca> haha
16:47:22 <afraca> perhaps
16:47:26 <Iceland_jack> afraca: Yes, the left hand side needs to be a type
16:47:32 <Iceland_jack> Digit Digit Digit Digit is not a valid type
16:47:43 <radish> need Constructor first yes?
16:47:44 <Iceland_jack> You would need:
16:47:44 <Iceland_jack>     type Year ≔ (Digit, Digit, Digit, Digit)
16:47:57 <radish> Year = Year Digit Digit Digit Digit?
16:48:01 <radish> would that work?
16:48:04 <Iceland_jack> radish: If you use data, yes
16:48:10 <afraca> Hmmm, I keep messing up when to use constructors...
16:48:17 <Iceland_jack>     data Year ≔ Year Digit Digit Digit Digit
16:48:17 <radish> still cant discern the difference
16:48:35 <Iceland_jack> radish: One is ‘type’ which doesn't create a new type, just makes a synnonym
16:48:42 <afraca> Yeah, i had data first, but type looks cleaner to me
16:48:44 <Iceland_jack> the other is ‘data’ which does create a new type
16:48:56 <levi> 'data' tells Haskell you're creating a new type. 'type' tells Haskell you'd like to refer to an existing type with a new name.
16:48:57 <Iceland_jack> afraca: type is less type safe
16:49:00 <radish> Iceland_jack: the naming convention seems kind of backwards lol
16:49:08 <Mortomes> type is just a type synonym
16:49:20 <Iceland_jack> radish: data makes a data type, type makes a type synnonym? what's backwards
16:49:28 <afraca> Thanks. I think I understand that. It just seems to me data is a lot of redundancy in this case
16:49:40 <volty> 'arithmetic type' --- not exchangeable, right ?
16:49:41 <Iceland_jack> afraca: How is that redundant?
16:49:52 <radish> iceland_jack: should be newtype to create new data type and synonym to create type synonym
16:49:55 <levi> There's also 'newtype' that is somewhere between 'data' and 'type'.
16:50:15 <radish> which would then need yet another new name lol
16:50:18 <Iceland_jack> radish: newtype already does something different
16:50:24 <radish> i know
16:50:26 <afraca> Yeah, but then you cant really have the same signatures for different newtypes. Like Day and Hour can both be  DIgit Digit
16:50:27 <Iceland_jack> in any case, this is how things are
16:50:37 <afraca> So data it is.
16:50:38 <Iceland_jack> afraca: That's bad
16:50:58 <radish> afraca yes, use data
16:50:59 <Iceland_jack> If you do:
16:51:00 <Iceland_jack>     type Day  = (Digit, Digit)
16:51:00 <Iceland_jack>     type Hour = (Digit, Digit)
16:51:00 <Iceland_jack> then Day = Hour
16:51:07 <ReinH> Yes, let's have 5 different people explain type vs data vs newtype concurrently, I'm sure that will go well
16:51:08 <radish> Year = Year Digit...
16:51:26 <Rarrikins> ReinH: Welcome to #haskell ;)
16:51:29 <ReinH> Rarrikins: :)
16:51:36 <Iceland_jack> ReinH: And let's have one person point out what a bad approach that is!
16:51:38 <ReinH> someone needs to acquire a lock
16:51:38 <afraca> Hehe. Ok, data makes it a bit more explicit and safe
16:51:38 <volty> ReinH's right
16:51:42 <Mortomes> redwire: type vs data vs newtype is like a burrito...
16:51:48 <Mortomes> err
16:51:51 <ReinH> Iceland_jack: A service I am happy to provide
16:51:54 <Iceland_jack> hah
16:51:55 <ReinH> Mortomes: please, space burrito
16:51:59 <Mortomes> ReinH, not redwire
16:52:07 <radish> if two people aren't pointing out the same maybe problem then we need more people
16:52:15 <Iceland_jack> I'm more interested in what *isn't* a burrito in the Haskell language at this point :)
16:52:16 <levi> A spacesuit for a taco.
16:52:16 <bennofs> lambdabot should implement mutexes :P
16:52:24 <radish> even if that problem is that too many people are pointing things out ;)
16:52:48 <ReinH> Iceland_jack: Comonads are probably not burritos.
16:52:49 <radish> iceland_jack: lol
16:53:08 <ReinH> Profunctors are of dubious burritosity.
16:53:11 <levi> A comonad is an eater-of-burritos.
16:53:24 <Mortomes> Iceland_jack: Monads, obviously
16:53:25 <radish> iceland_jack: god wrought the universe out of a burrito sir
16:53:37 <ReinH> And he saw the burrito, and he saw that this was good.
16:53:53 <radish> ReinH: better than good - delicious
16:54:00 <ReinH> And then, verily did he say, "I'm sure glad I figured out that IO monad so I could create the universe"
16:54:02 <int-e> ReinH: a comonad is a ntainer?
16:54:10 <ReinH> int-e: :p
16:54:24 <bennofs> God din't use the IO monad. He used unsafePerformIO everywhere
16:54:32 <Iceland_jack> “burritosity” is such a useful word
16:54:32 <Iceland_jack>  
16:54:34 <ReinH> reallyUnsafePrtEquality#
16:54:42 <volty> God was imperative !!!
16:54:43 <radish> ReinH: its because of single threadedness that there seems to be a limited amount of intelligence on earth
16:54:43 <ReinH> Iceland_jack: It needs a unit though
16:55:08 <bennofs> http://xkcd.com/224/
16:55:36 <volty> radish: not true, the women are multi-threaded and multi-tasked :)
16:55:37 <ReinH> Iceland_jack: I nominate the Marlow, as in: This Monad has a burritosity of 3.5 centimarlows.
16:55:43 <radish> Mortomes: http://chrisdone.com/posts/monads-are-burritos
16:56:02 <Mortomes> bennofs: I knew it would be that one.
16:56:04 <radish> volty: leading to a large set of double-standards
16:56:28 <Mortomes> Quadruple standards, even
16:56:28 <Iceland_jack> ReinH: Reminds me of a milli-Helen
16:56:35 <ReinH> Let's please not have a poorly informed dudebro conversation about biological determinism please
16:56:36 <Iceland_jack> A face that can launch a single ship
16:56:42 <radish> bennofs: thats exactly what came to my mind lol
16:56:43 <volty> do one thing -- with full intelligence power // or do many of them assigning a piece of intellect to each one
16:57:01 <radish> ReinH: us? we're just goofing
16:57:30 <radish> volty: i'm working on a project about that right now
16:57:41 <radish> volty: lots of simple things that communicate solving problems
16:57:41 <ReinH> radish: Ok, but it's a bit offputting and I'm not even a female
16:58:01 <radish> ReinH: eh, i meant nothing rude by it
16:58:12 <ReinH> radish: ofc, and this meant very gently :)
16:58:14 <radish> ReinH: i make dudes are stupid jokes just as frequently
16:58:26 <radish> ReinH: almost as much as i make fun of myself
16:58:32 <radish> ReinH: but not quite
16:58:53 <radish> anyway we should take this haskell-blah if were going to screw around lol
16:58:53 <Mortomes> radish: Lies, all lies.
16:59:06 <radish> Mortomes: the burritos or the sexism?
16:59:15 <ReinH> Heh, yes.
16:59:19 <radish> jees, you don't get to say that often
16:59:24 <Mortomes> radish: Burritos
16:59:35 <jle`> alternative doesn't have to do with monoids in general right?  it is just one way to turn any applicative into a monoid?
16:59:36 <Mortomes> radish: Cherish the moment
16:59:46 <ReinH> radish: heh :)
16:59:51 <jle`> it's not like the alternative intance of list/whatever has anything to do with the monoid instance
17:00:29 <bennofs> Alternative mostly exists as a way to say forall a. Monoid (f a)
17:00:52 <bennofs> and for some laws that instances should abide in conjunction with the applicative operators
17:01:46 <jle`> bennofs: sorry, have no experience with forall and stuff
17:01:49 <jle`> :|
17:02:07 <chrisdone> ReinH: Rein in pein https://www.youtube.com/watch?v=slGq_21AOQQ
17:02:37 <bennofs> jle`: It means that f must be a "monoid" for all a. So for example "f String" must be a monoid, but so must "f Int", etc
17:03:15 <jle`> also i'm not totally sure why there needs to be an alternative at all; is it just a dual constraint?  like instead of (Monoid a, Applicative a), we can just write (Alternative a) ?
17:03:29 <bennofs> jle`: compare the kinds
17:03:41 <bennofs> Monoid a -- here a must be of kind *
17:03:45 <ReinH> chrisdone: I hate you ;)
17:03:55 <bennofs> Alternative f -- here f must be of kind * -> *
17:04:04 <chrisdone> ReinH: ;)
17:05:05 <bennofs> jle`: and as I said, it's also because Alternative should satisfy a bit more laws than just plain Monoid
17:13:20 <khyperia> chrisdone, boop, any updates on this? http://www.reddit.com/r/haskell/comments/1mcj19/fp_complete_to_release_a_personal_edition_of/cc83l3n
17:13:32 <Cale> jle`: It's similar to the situation with MonadPlus, if you have MonadPlus m, it means that (m a) is a monoid for every type a, and there probably ought to be further laws connecting the behaviour of mplus and mzero with return and (>>=), but there are at least two sets of laws which might be obeyed (so if we wanted to do it right, we'd really need another class)
17:13:37 <chrisdone> khyperia: planned for december
17:13:43 <khyperia> awesome!
17:13:55 <chrisdone> khyperia: mid-december, or so
17:15:10 <Cale> Why a subscription-based IDE?
17:15:56 <khyperia> Cale, it's a really good IDE. I like it. Not that much money, I say its worth it (but other people probably have vastly different opinions)
17:16:03 <ReinH> chrisdone: looking forward to trying it. I tried the web-baseed IDE for a little toy project and it was enjoyable.
17:16:22 <chrisdone> ReinH: cool =)
17:16:28 <khyperia> Only trouble is that I picked up hacking on ghc, which is impossible to work in their online IDE.
17:16:32 <ReinH> Although the subscription model is a bit awkward for personal software
17:16:37 <khyperia> so I'm really excited for the local bit
17:16:48 <ReinH> But maybe I'm misunderstanding
17:17:14 <chrisdone> ReinH: you mean paying a subscription to work on personal stuff?
17:17:34 <chrisdone> Cale: you mean why pay x per month vs paying once? or why have a service?
17:17:48 <Cale> The first
17:17:55 <Cale> (is it a service?)
17:18:42 <chrisdone> yeah, it's a platform, i suppose. it's stackage, plus a build/type/refactoring system, plus a web interface, plus amazon deployment
17:19:02 <chrisdone> you can do all that locally, but maybe as a business you'd just prefer to have someone maintain it for you
17:21:09 <chrisdone> i just finished on emacs bindings to it. sort of a like a drop-in replacement for ghc-mod/hdevtools
17:23:03 <afraca> Thanks for the help guys, Iḿ off.  This might not be my last visit...
17:23:14 <ReinH> chrisdone: So there's going to be a local version of the IDE?
17:23:18 <ReinH> chrisdone: What is its pricing model?
17:23:24 <Iceland_jack> afraca: Hope to see you again :)
17:24:47 <chrisdone> ReinH: i haven't been briefed on that yet. i've been too busy working on it =)
17:24:52 <ReinH> chrisdone: hah ok :)
17:25:00 <mgsloan> khyperia: One thing that might be interesting to you is that we do hope to have both clientside / serverside extensibility, though this isn't guaranteed to happen.  I'm not sure if you'd be able to talk directly with GHC, but we'll see!
17:26:10 <ReinH> Ok, how many FPComplete folks do we have in here now? Are you taking over? ;)
17:26:26 <ReinH> Is #haskell becoming some sort of Borg collective?
17:26:31 <mgsloan> There is already some form of clientside extensibility: the configuration file for the client is written in Haskell (fay)
17:26:48 <chrisdone> ReinH: i think there're three of us in here =)
17:27:09 <Nafai> chrisdone: You, johnw, and who else?
17:27:11 <chrisdone> ReinH: get snoyman on haskellcast and grill him on it =p
17:27:16 <chrisdone> Nafai: mgsloan ^
17:27:19 <ReinH> chrisdone: haha :)
17:27:32 <Nafai> chrisdone: duh, should have paid closer attention :)
17:29:10 <josaliba> guys i've been struggling for hours to serialize a data type to json. I can't do it.
17:29:21 <Cale> josaliba: What's the data type?
17:29:22 <josaliba> can someone help and guide me please
17:29:23 <josaliba> http://lpaste.net/6900146191187574784
17:29:35 <Cale> okay
17:29:48 <Cale> What JSON library are you using?
17:30:45 <josaliba> i was proceeding like that
17:30:46 <josaliba> http://lpaste.net/2512538263089053696
17:30:51 <josaliba> i dont know which library is that
17:31:18 <Cale> looks like perhaps aeson?
17:31:22 <c_wraith> if you don't know what library it is, how can you look up its documentation?
17:31:59 <Cale> hmm, is that missing parens?
17:32:11 <Cale> I think you want toJSON (Character {..}) = object ...
17:32:20 <Cale> also, there are tabs in this
17:32:32 <josaliba> for Character it's working
17:32:32 <Cale> Make sure to tell your text editor to convert tabs to spaces
17:32:50 <josaliba> the problem is with serializing this http://lpaste.net/6900146191187574784
17:33:12 <Cale> josaliba: So, it would be similar, just with different cases for each of the constructors.
17:33:44 <Cale> toJSON (Paragraph t) = ...; toJSON (Image t b) = ...; ...
17:34:02 <josaliba> like that?
17:34:03 <josaliba> http://lpaste.net/7372604215929077760
17:34:30 <Cale> Yeah, perhaps, though you might want to somehow encode the fact that it's a Paragraph in the JSON itself
17:34:43 <Cale> (if you have any control over how things are formatted on the JSON side of things)
17:35:04 * hackagebot system-random-effect 0.1.1.0 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.1.1.0 (ClarkGaebel)
17:35:26 <Cale> Also, the instance is for ContentElement, not Paragraph
17:35:44 <Cale> ContentElement is the type, Paragraph is just one of its data constructors.
17:37:53 <josaliba> but when i do that, i get this error on compilation http://imgur.com/H397iKh
17:38:49 <Cale> josaliba: Yeah, that's what I'm talking about
17:39:07 <Cale> It needs to be instance ToJSON ContentElement where ...
17:39:13 <Cale> Paragraph isn't a type
17:39:42 <josaliba> ahh !!!!
17:39:47 <josaliba> it works now !!
17:40:47 <Cale> cool :)
17:43:36 <josaliba> another thing
17:43:40 <josaliba> why i can't do that
17:43:40 <josaliba> http://lpaste.net/1970929229067452416
17:43:51 <josaliba> passing the "type"
17:56:14 <piezoid> is there a partial function to assume a typeclass constraint ? something like Show b => a -> Maybe b
17:57:44 <piezoid> i'm debugging polymorphic function with Debug.Trace, so this can be useful to print arguments
17:58:54 <bennofs> piezoid: you want a function that returns Nothing if a has no show instance?
18:00:02 <piezoid> yes, or throw an exception, it's just for testing purpose
18:00:03 <josaliba> why i can't set the type like i've done here
18:00:04 <josaliba> http://lpaste.net/1970929229067452416
18:05:18 <geekosaur> are there other constructors for ContentElement?
18:07:09 <josaliba> yes
18:07:51 <geekosaur> then you need to provide implementations for those as well, even if you're not using thme
18:07:52 <josaliba> i get a compilation error whenever i write "type" .= "paragraph"
18:08:08 <geekosaur> oh. you should include error messages
18:08:22 <josaliba> ok one second
18:09:12 <josaliba> http://tinypic.com/view.php?pic=348lrlz&s=5#.UpqYjGRDv7Y
18:11:08 <josaliba> geekosaur, http://tinypic.com/view.php?pic=348lrlz&s=5#.UpqYjGRDv7Y
18:11:23 <geekosaur> oh, I see what's wring, just don't know what the right fix is. (unless ContentElement is a GADT, you cannot tell it that the parameter to Paragraph has a ToJSON constraint)
18:11:50 <Cale> er
18:12:13 <Cale> josaliba: Are you using OverloadedStrings?
18:12:18 <Cale> Right, yes, you are
18:12:25 <geekosaur> well, you might be able to, but I have insufficient information and I'm a little weak in this stuff. but that is the information that is missing here
18:12:29 <Cale> It might help just to specify which string type you want
18:12:38 <geekosaur> yes
18:12:43 <josaliba> yes
18:12:44 <josaliba> {-# LANGUAGE OverloadedStrings #-}
18:12:45 <volty> i've installed hoogle, generated content with '....data all' etc etc // then started hoogle server , but the links (e.g. of foldl) point to http://haskell.org ... // how can I make it point to local content? Is it possible? Do I have to generate local html content ?  How?
18:12:50 <Cale> i.e.  "type" .= ("paragraph" :: Text)
18:13:36 <Cale> I think the problem is that it doesn't know which type "paragraph" is supposed to be, so it can't decide how that ought to be rendered as JSON.
18:13:51 <geekosaur> wouldn't that just make it complain it can't tell whether a0 is the same type?
18:13:51 <josaliba> i see
18:14:21 <Cale> geekosaur: No, it would let the compiler know that a0 = Text
18:14:46 <Cale> geekosaur: and then it would be able to determine the instance of IsString and ToJSON to use.
18:15:17 <geekosaur> maybe. I am thinking the confusion is it can't be certain that the parameter to Paragraph has that type, since ContentEntity isn't parameterized and it can't otherwise determine the type
18:15:28 <geekosaur> (as demonstrated by the messages)
18:15:37 <Cale> No, it's in the expression "type" .= "paragraph"
18:15:51 <Cale> Has nothing to do with the parameters to the actual Paragraph constructor.
18:52:17 <joelteon> I don't really understand how to use showsPrec
18:53:01 <khyperia> mgsloan, dunno if you're still around, I was afk. What do you mean by clientside / serverside extensibility?
19:21:46 <chrisdone> @vixen is it peanut butter jelly time?
19:21:46 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
19:22:34 <chrisdone> i like how @vixen is always offensive, despite being repeatedly replaced with new databases in the interest of being unoffensive
19:22:50 <hpc> i thought that was nixon
19:22:53 <chrisdone> it's almost like lambdabot is sentient and this is the whole way to get it out
19:22:58 <Saizan> it's just auto-corrected to @nixon now
19:23:25 <enthropy> @yow
19:23:25 <lambdabot> Where's th' DAFFY DUCK EXHIBIT??
19:23:58 <chrisdone> @what joke
19:23:59 <lambdabot> We regret to inform you a joke has been told in your vicinity. Our sincere apologies for any cognitive dissonance this may have caused.
19:25:41 <tespa> wtf is this fucking nonsense haskell language
19:26:00 <tespa> it makes no freaking sense
19:26:03 <chrisdone> tespa: you need some help?
19:26:11 <w0rm_x> tespa, what does not make sense?
19:26:18 <tespa> yeah, is there a way to convert code from c++ to Haskell
19:26:22 <tespa> anything
19:26:25 <brandonw> jmcarthur: thanks for the tip on using asyncs. it really was quite easy :) i now have reconnection capability on my play haskell project of an irc bot :D
19:26:30 <tespa> lol
19:26:39 <chrisdone> via a foreign function interface?
19:27:26 <tespa> haskell functions is the most bizare thing I have ever seen
19:27:33 <tespa> anyone bother to comment on that?
19:27:43 <chrisdone> that's cool
19:27:48 <chrisdone> it means you're learning something actually interesting
19:28:02 <hpc> tespa: embrace the weirdness
19:28:42 <chrisdone> hpc: http://img685.imageshack.us/img685/614/tumblrlmeew50het1qbgxlv.jpg “my brain is ready for you, Haskell”
19:29:13 <hpc> chrisdone: i tried to imagine a bowtie below that face and almost had an aneurism
19:29:29 <chrisdone> :D
19:29:47 <tespa> from what I understand haskell is an interpreted language and has no main method right?
19:29:53 <chrisdone> “Draw me like one of your list comprehensions.”
19:29:55 <geekosaur> ???
19:30:17 <hpc> tespa: it has a main function, and can be interpreted or compiled
19:30:19 <eyebloom> Does anyone know if Max Bolingbroke is continuing work on his supercompiler?
19:30:30 <geekosaur> ghci is interpreted. haskell programs may be interpreted but are typically compiled; in both cases the entry point is CAF main in module Main
19:30:38 <hpc> tespa: and in the case of ghc, you have the interactive interpreter
19:30:39 <tespa> hpc, is it safe to make the comparison between haskell and php
19:30:43 <tespa> because thats what it looks like
19:30:51 <triliyn> What is a supercompiler?
19:30:58 <geekosaur> o.O
19:31:14 <eyebloom> It's a compiler that does partial evaluation of programs.
19:31:35 <chrisdone> http://stackoverflow.com/questions/9067545/what-is-supercompilation
19:31:46 <triliyn> hmmm, thanks
19:32:05 <hpc> tespa: the two languages are not even remotely alike
19:32:18 <chrisdone> neil mitchell's Supero project is a supercompiler
19:32:25 <tespa> hpc what language would u say haskell looks like?
19:32:27 <chrisdone> http://community.haskell.org/~ndm/supero/
19:32:27 <tespa> python?
19:32:33 <hpc> it looks like haskell
19:32:37 <chrisdone> aka, -O11 =p
19:32:39 <tespa> nice
19:32:46 <hpc> (or if you really need a different language, it looks like ML)
19:32:52 <tespa> is it still used for actual purposes?
19:32:58 <scott_> It looks like Miranda
19:33:07 * chrisdone finds references to spinal tap funnier than actual spinal tap
19:33:14 <hpc> it's used in banking and trading stuffs
19:33:18 <khyperia> chrisdone, wait, I thought -O wasn't "optimization level" and rather "optimization type"? (O1 being size, O2 being speed)
19:33:19 <mangaba_leitosa> tespa: Curry, Clean or Elm all look like Haskell
19:33:36 <hpc> and websites and program verification and much research
19:33:59 <hpc> and games!
19:34:02 <mangaba_leitosa> (ML doesn't) :-)
19:34:20 <hpc> (just a few toy examples so far, but you can ask john carmack about that)
19:34:42 <chrisdone> khyperia: it is optimization level. the numbers make compilation take longer, but introduce more optimizations and danger
19:34:50 <khyperia> Ah.
19:35:03 <chrisdone> khyperia: https://www.haskell.org/ghc/docs/7.6.2/html/users_guide/options-optimise.html#optimise-pkgs
19:35:32 <heath> haskell looks like idris
19:35:40 <chrisdone> khyperia: but 11 is just a spinal tap joke, about "amp volume normally goes to 10, but this one goes up to 11 so it's even louder"
19:35:44 <heath> don't dispute this hpc ;)
19:35:45 <hpc> tespa: in any event, the best way to understand is by actual understanding; i recommend you go through a tutorial and form your own impressions
19:35:52 <mgsloan> but not /that/ much danger.  One nice thing is that GHC maintains types all the way down to core, and most of the fancy optimizations happen before core.  So at least type safety is probably preserved
19:36:13 <khyperia> heh, yeah
19:36:27 <hpc> if you haven't picked one out yet, LYAH is a good place to start
19:37:40 <heath> and if you've forgotten most of lyah by now and you need a review: https://gist.github.com/heath/6097570
19:39:16 <mangaba_leitosa> heath: and that's this? Learn you a Haskell if you forgot one? :-)
19:39:23 <mangaba_leitosa> heath: and what's this even
19:39:37 <heath> qlyah (quickly learn you a haskell)
19:39:53 <geekosaur> forgot you a haskell?
19:40:04 <mangaba_leitosa> :-)
19:40:13 <heath> i can rename it, if the community wants this ;)
19:40:46 <heath> maybe the agda or idris tutorials should be named "forget you a haskell for great good"
19:48:34 <julz> I am exploring acid-state library and I find it very interesting. I have one concern though. as a simple example, let's say that I am storing a Person { name :: String, gender :: String } but later I want to change representation of gender from String to Gender data. how would I update an already existing acid-state database?
19:50:32 <tespa> wtf is this
19:50:33 <tespa> square :: Int -> Int
19:50:40 <tespa> what is it supposed to mean or define?
19:51:09 <Clint> julz: http://acid-state.seize.it/safecopy
19:51:26 <Hafydd> It means that square is a function taking a value of type Int to a value of type Int.
19:54:30 <julz> Clint thanks, reading
19:56:39 <Clint> julz: if you're using deriveSafeCopy you'll want to do it differently
19:57:10 <julz> I am using deriveSafeCopy
19:57:32 <Clint> you'll want to not follow those examples then
19:58:10 <julz> is using deriveSafeCopy recommended?
19:58:21 <Clint> i would think so, yes
20:00:41 <julz> do you have any migrations examples handy when using deriveSafeCopy?
20:01:14 <Clint> pretty sure this has some, but it seems broken: http://www.happstack.com/docs/crashcourse/AcidState.html
20:02:03 <julz> http://web.archive.org/web/20120322195339/http://www.happstack.com/docs/crashcourse/AcidState.html
20:02:09 <julz> is that it?
20:02:27 <julz> it uses deriveSafeCopy
20:02:58 <julz> I don't see any migration code though, unfortunately
20:03:03 <Clint> then i misremembered
20:03:37 <julz> ok I'll figure it out when/if I need it
20:20:44 <flebron> What's the idiomatic way of saying "Is there a non-Nothing in this [Maybe a]"? Clearly not . null . catMaybes works, is there already a built-in way?
20:22:26 <flebron> Ah, msum :)
20:26:48 <mzero> always bothered that MonadPlus got mzero and mplus, whereas Monoid got mempty and mappend --- always wished it were reversed!
20:38:58 <alpounet> mzero: I thought the same when I first found out too, but well it's way too late to do anything about it now heh
20:39:09 <mzero> indeed
20:39:24 <mzero> and as you can see from my handle - I've made my peace with it
20:39:51 <alpounet> hah
20:40:20 <alpounet> mzero: how's the platform release prep going?
20:41:03 <mzero> fine - the list is still coming to grips with what to do about aeson - but looks like all the discussion is going to boil down to skip it this round -
20:41:16 <mzero> and then it is just a long night of running scripts for me
20:41:20 <mzero> I expect wtihin a week
20:41:42 * mzero should be working on it now - but is instead working on a blog post about merges, folds, and Monoids
20:41:46 <alpounet> ok
20:41:51 <alpounet> yeah I have followed the aeson discussion(s)
20:42:46 <alpounet> i thought an agreement was never going to be reached
20:44:57 <dwcook> I don't know if anyone has mentioned this already, but the haskell-platform package has returned in the latest Mint and therefore probably the latest Ubuntu.
20:45:17 <mzero> this is "community process" - a bit protracted - but it works!
20:45:21 <mzero> no - nice to hear
20:45:26 <mzero> about Mint
21:19:24 <pavonia> Huh, what was that? O.o
21:20:21 <mangaba_leitosa> looks like a bot attack
21:21:41 <Hafydd> That's the first flood I've seen with IPv6 addresses.
21:28:41 <geekosaur> not a very smart bot attack since it killed itself...
21:30:46 <dwcook> It doesn't seem obvious that it killed itself so much as it was killed
21:31:01 <dwcook> probably automatically though, yeah
21:35:01 <kujablak> Hi, I'm trying to insert a new element of a type in a list of elements of the same type, but for some reason I get a "pattern match failure"
21:35:18 <kujablak> here is the paste : http://lpaste.net/5219906151214219264
21:35:20 <dwcook> kujablak, show what you're trying.
21:36:05 <kujablak> basically it's adding a Recipe element to a [Recipe]
21:36:09 <dwcook> kujablak, [listeRecipes] means "a list of one element, which will be bound to the identifier listeRecipes"
21:36:32 <Cale> Yes, that'll be it
21:36:44 <dwcook> You probably don't want to include the [ and ] at all
21:36:53 <Cale> Also, configure your text editor to convert tabs to spaces
21:37:11 <dwcook> Though you should also note that appending is slow, O(n), whereas prepending is O(1)
21:37:21 <kujablak> all right, so the declaration part doesn't cause the function to recognise what types its arguments are ?
21:37:31 <geekosaur> it recognizes the type fine
21:37:43 <kujablak> okay, so I didn't understand then
21:37:44 <Cale> kujablak: [x] always means a list of one element, no matter what x is
21:37:52 <geekosaur> but you then provided an implementation that works for only lists of length 1
21:37:53 <kujablak> oh
21:37:58 <Cale> When you use it as a value or pattern
21:38:09 <kujablak> all right so [x:xs]
21:38:15 <geekosaur> no
21:38:19 <Luke> do I have to get permission or something to upload packages to hackage?
21:38:26 <kujablak> sorry (x:xs) ?
21:38:31 <dwcook> [x:xs] is a list of one element, and that element is a non-empty list
21:38:31 <geekosaur> x:xs is a list. [x:xs] is a list containing a single list
21:38:32 <Cale> no, that's a list with just one element whose element is itself a list with at least one element
21:38:42 <geekosaur> and yes, (x:xs) --- but in this case you don't want that at all
21:38:48 <geekosaur> you just want the list, not its components
21:39:01 <dwcook> You just want a bare identifier
21:39:02 <dwcook> like xs
21:39:04 <geekosaur> just drop the braces from listeRecipes
21:39:17 <geekosaur> er, brackets
21:39:28 <Cale> (on both sides of the equation)
21:39:43 <kujablak> done, and working
21:41:14 <kujablak> oh right, I got it with Cale's explanation,I got confused about how to represent a list
21:41:19 <kujablak> thanks everyone !
21:41:37 <dwcook> You don't need to indicate it's a list at all, just use list operations on it and that'll be implied
21:41:48 <dwcook> (Though of course writing your own type signature can't hurt)
21:45:25 <khyperia> I'm having -fllvm issues, I have installed llvm but -fllvm doesn't work. http://lpaste.net/96425
21:47:23 <Cale> Try -pgmlo opt -pgmlc llc -fllvm
21:47:52 <nso95_> the beauty of CLI
21:47:53 <Luke> how do I make sure docs get generated for my uploaded packages?
21:47:54 <khyperia> That worked. Huh. I wonder why that's not set as default...
21:47:58 <Luke> does that happen automatically on hackage?
21:48:06 <Cale> https://ghc.haskell.org/trac/ghc/ticket/7143
21:48:17 <Cale> Luke: yes, it happens automatically
21:48:27 <Luke> thanks
21:49:23 <Luke> http://hackage.haskell.org/package/snaplet-stripe-0.1.0 first package on hack age!
21:49:41 <Cale> nice!
21:50:29 * hackagebot snaplet-stripe 0.1.0 - Stripe snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-stripe-0.1.0 (LukeHoersten)
21:54:11 <khyperia> Kind of extending off that question... I'm starting to get into ghc hacking, and, well, how useful do you think this would be to the community: Make it possible to go from Haskell -> LLVM -> NVIDIA PTX. Both steps are already in place, there just has to be some wiring hooked up.
21:54:42 <Cale> Sounds cool
21:55:19 <Ralith> khyperia: don't forget R600
21:55:30 * hackagebot snaplet-postmark 0.1.0 - Postmark snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postmark-0.1.0 (LukeHoersten)
21:55:50 <Ralith> and note that there's still potential complexities, even if the IR translates nicely
21:55:56 <khyperia> I think there's also an AMD GPU backend to LLVM, not sure.
21:56:10 <khyperia> yeah, "some wiring hooked up" actually means "a huge amount of work"
21:56:43 <Ralith> R600 is the AMD GPU backend, yes
21:56:48 <simpson> khyperia: Go look at Mesa's guts.
21:56:52 <radish> who's idea was it to do the Color a b c thing?
21:56:58 <Ralith> (for the so named chipset)
21:56:59 <Cale> radish: ?
21:56:59 * khyperia doesn't even know what Mesa is
21:57:08 <radish> Cale: someone hooked me up hard earlier
21:57:11 <Ralith> Mesa is linux's GL stack; it uses LLVM
21:57:17 <khyperia> ah
21:57:24 <radish> Cale: but i forgot their name :(
21:57:32 <Ralith> well, the top part of the stack anyway
21:57:32 <radish> anyway whoever helped me with that THANK YOU.
21:57:45 <radish> Iceland_jack: it was you wasn't it, jack?
21:57:49 <simpson> Gallium's in there too. Just clone the repos and read some source.
21:58:11 <khyperia> Well, you people obviously know a ton more than me, so me being the one to try to implement that might not end too well.
21:58:14 <radish> i swear i have the memory of a goldfish
21:58:31 <radish> shout out to how awesome LLVM is
21:58:37 <radish> best idea since sliced bread
21:58:42 <radish> actually, f sliced bread
21:58:50 <geekosaur> it was Iceland_Jack fwiw
21:58:57 <radish> fwiw?
21:59:11 <radish> it was a few other people, too
21:59:13 <radish> :(
22:00:03 <geekosaur> "for what it's worth"
22:00:27 <geekosaur> several others helped you with it but IJ pointed you to it initially
22:00:49 * geekosaur still has conversation in scrollback...
22:02:29 <simpson> khyperia: FWIW I attempted this a while back and came to the conclusion that LLVM is ill-suited to GPUs.
22:02:46 <khyperia> Ah, alright.
22:03:18 <radish> what??
22:03:22 <radish> that's terrible!
22:03:55 <radish> well we need something modular like LLVM  but specifically suited for GPUs then
22:06:37 <simpson> We do?
22:06:44 <simpson> I think that we need to stop building compilers out of C++.
22:07:05 <radish> simpson: haha
22:07:15 <simpson> Compilers aren't hard. C++ is hard.
22:07:20 <radish> simpson: we need to stop doing anything out of C++ lol
22:07:38 <radish> simpson: i don't care what anyone says, it's a /bad language/
22:08:17 <khyperia> Anyway, looks like Haskell->GPU is going to be impossible for the beginner that is me, but I'm not sure what else I could contribute to the community. Oh well.
22:09:19 <radish> Khyperia: build a haskell IDE lol
22:09:21 <bd_> radish: note that each GPU has its own proprietary machine code, and so each GPU driver has a compiler from various languages (CUDA, GLSL, HLSL, etc) to its proprietary machine code
22:09:36 <Ralith> khyperia: the limiting factor on things getting written is more often free time than capability
22:09:38 <bd_> radish: so if you want to build a compiler from a new language you'll need to target one of those intermediate languages
22:10:00 <bd_> I suppose you could build a library to make it easy to programatically generate CUDA or GLSL or something
22:10:04 <radish> bd_: that's why I like LLVM's concept, you compile to intermediary language
22:10:12 <simpson> bd_: Disregard proprietary languages, use Mesa/Gallium's builtin shader IL.
22:10:12 <bd_> radish: well, thing is, you already have that :)
22:10:19 <radish> bd_: then you optimize and check for bugs and then you compile to a target
22:10:48 <radish> simpson: wait what is this thing you speak of? a decent shading language?
22:10:55 <khyperia> I'm considering that, radioxid
22:10:58 <khyperia> radish*
22:11:19 <radish> Khyperia: do genetic algorithms lol
22:11:22 <simpson> radish: Not particularly. Just an open one that can handle all the different cards.
22:11:26 <radish> Khyperia: that's what I do :D
22:11:34 <radish> simpson: better than GLSL?
22:11:40 <bd_> simpson: Hm, I thought GLSL was non-proprietary, being part of OpenGL?
22:11:52 <khyperia> I'm not really that into AI, heh, sorry.
22:12:06 <bd_> well, in any case, point is a big part of LLVM is its optimization and machine code generation core, but you already have that with graphics drivers
22:12:08 <radish> Khyperia: it ain't AI it's ALife, AI is a target
22:12:24 <bd_> so the need for a full compiler toolkit stack is lessened
22:12:52 <simpson> bd_: GLSL isn't really optimizeable.
22:12:55 <radish> Khyperia: one guy used GA to optimize a wind turbine under a given ruleset
22:13:02 <khyperia> Neat.
22:13:06 <radish> Khyperia: his ruleset sucked though, so it was optimal.
22:13:14 <simpson> bd_: Mesa's got a stack to turn GLSL into TSGI, which Gallium has a bunch of optimizers for.
22:13:21 <khyperia> but radish, were you being serious when you said "build a haskell IDE"?
22:13:31 <radish> Khyperia: had a notable jellyfish shape
22:13:31 <simpson> And then each driver turns TGSI into the proper GPU machine code.
22:13:39 <radish> Khyperia: kind of?
22:13:53 <bd_> simpson: interesting
22:14:05 <bd_> sounds like LLVM for graphics cards has already been built then :)
22:14:12 <radish> simpson: less buggy?
22:14:21 <radish> simpson: bug-prone*
22:14:58 <khyperia> since I've been considering it for the past few days. None of the IDEs available really fit all of my needs
22:15:04 <khyperia> but some of them get 99% of the way there
22:15:17 <khyperia> and I feel like whatever I hack up won't be as good... but whatever.
22:15:19 <radish> Khyperia: i've resorted to text editor
22:15:24 <Ralith> simpson, bd_: mesa is actually moving to LLVM because its optimizations perform much better than those for the existing TGSI pipeline
22:15:26 <simpson> radish: I'm not sure what you mean. It's a simple intermediate representation designed to abstract common GPU features while still being very low-level.
22:15:31 * hackagebot base32-bytestring 0.2.1.0 - Fast base32 and base32hex codec for ByteStrings  http://hackage.haskell.org/package/base32-bytestring-0.2.1.0 (SamTruzjan)
22:15:50 <radish> Khyperia: isn't that the worst? like a beautiful gal with a big ol' nose wart.
22:16:03 <simpson> Ralith: Yeah, although I don't feel that that means that LLVM is good... :c
22:16:15 <Ralith> simpson: ?
22:16:17 <radish> simpson: i just want something more modern i guess
22:16:20 <simpson> TGSI worked very well for the chipsets it was designed for! But those drivers were never public.
22:16:47 <radish> simpson: everything i hear about LLVM i like
22:16:50 <Ralith> http://www.phoronix.com/scan.php?page=news_item&px=MTQxMDM
22:16:59 <Ralith> dramatic framerate increases
22:17:15 <khyperia> Anyway, I think my plan of action will be to continue teeny little things on GHC, since compilers are sort of my primary passion, but... it's GHC, it's big and complicated and hard to learn :P
22:17:54 <simpson> Ralith: Anyway, I don't want to have a fight or anything. I think that we all want to see better drivers. I just got really tired of writing C.
22:17:55 <radish> Khyperia: you should write your own programming language
22:18:05 <radish> Khyperia: that's what I would do if I didn't suck at programming
22:18:10 <khyperia> Already made 12 or 13 little compilers, heh.
22:18:21 <radish> Khyperia: anything good
22:18:23 <radish> Khyperia: anything good?
22:18:30 <Ralith> simpson: I haven't disagreed with anything you've said; the data I linked showed that a custom chipset-specific optimizer was best of all, actually.
22:18:48 <simpson> Ralith: Yeah. I bet that that'll be the way it is, forever.
22:19:00 <khyperia> Not really. My latest is a silly thing that can compile things like https://github.com/khyperia/Khic/blob/master/testProgram.kc (although that compiler is more of a "hey I want to learn the llvm-general api, what can I do?")
22:19:17 <Ralith> simpson: well, one might hope that the chipset-specific optimizers would be written as LLVM modules instead of complete self-contained pipelines; LLVM is designed to make this easy.
22:19:37 <radish> Khyperia: i want to write a strong typed, pure functional, tuple-free, semi-strict language with regional memory and i want to use LLVM to make it swim.
22:19:53 <khyperia> heh, nice
22:20:10 <radish> Khyperia: regional memory and functional would be a dream
22:20:21 <radish> Khyperia: speed, no bugs, portable...
22:20:22 <khyperia> I've never heard of regional memory
22:20:34 <radish> Khyperia: i came up with the idea only to find out it's a thing
22:20:39 <Ralith> radish: "tuple-free"?
22:21:02 <radish> Ralith: when you call a function you do it like this: fn a b c
22:21:23 <Ralith> radish: what's the syntax got to do with anything?
22:21:28 <radish> Ralith: and when you get multiple data back you get a tuple
22:21:59 <radish> Ralith: and while I looove currying because it allows for partial application, i don't really like location-based mapping - i find it obtrusive
22:22:16 <Ralith> so it's not tuple-free, then
22:22:30 <radish> Ralith: no that's haskell i'm talking about
22:22:53 <radish> Ralith: i'd prefer to be able to call functions in a similar way as records
22:23:03 <radish> Ralith: and return records
22:23:07 <Ralith> it does not mean anything to 'call records'
22:23:20 <khyperia> do you mean calling with named parameters?
22:23:25 <radish> Ralith: as records are constructed*
22:23:31 <radish> Khyperia: yes, and named returns
22:23:32 <khyperia> like "foo arg1=val1 arg2=val2"?
22:23:38 <khyperia> right
22:23:44 <radish> Khyperia: yes, but with partial application
22:23:51 <khyperia> Ahhh. Neato.
22:24:07 <radish> Khyperia: you'd standardize a set of names for most things and then you could just chain everything together
22:25:29 <radish> so you would do maybe something like  (n=3 by=2) -> quotRem -> rem
22:25:40 <radish> n being the standard, or int, whatever
22:25:54 <radish> also operator overloading yes please :) can you do that in haskell?
22:26:15 <radish> oh yeah and then rem -> n
22:26:22 <radish> for reuse
22:26:36 <radish> i know it seems silly but i think it could really make code clear
22:26:42 <radish> or maybe not, but I'd like to try it lol
22:26:57 <radish> quotrem 3 2 doesn't mean very much to me, you know?
22:27:13 <jle`> is there any @src for gci?
22:27:15 <jle`> ghci
22:27:25 <jle`> i understand it might not even make sense for compiled modules
22:27:32 <jle`> and :i tells you where it's defined
22:27:35 <scott_> jle`: I made it, using the database from lambdabot
22:28:04 <jle`> scott_: you made it for ghci? how do i call it?
22:28:35 <scott_> jle`: I mean, you'll need my .ghci stuff (including an external script), but once you do, :src foo
22:28:50 <jle`> ah ok
22:28:53 <radish> hey do you guys suggest i utilize data D = D Bool Bool or data D = { a ::Bool, b ::Bool }?
22:28:57 <scott_> It only works for stuff in lambdabot's source database, at the time I ripped it out
22:29:06 <jle`> is there an api on the lambdabot source database?
22:29:15 <scott_> No
22:29:16 <jle`> or is it available for download somewhere?
22:29:31 <scott_> I just took it out of the repo and made a script for querying it
22:30:01 <jle`> huh. is it on github?
22:30:27 <scott_> lambdabot, or my stuff?
22:30:36 <scott_> https://github.com/mokus0/lambdabot, my stuff is not
22:31:07 <jle`> lambdabot
22:31:09 <jle`> thanks
22:31:15 <scott_> I don't know if that's the official lambdabot repo, but it has the source stuff
22:31:47 <scott_> https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
22:31:55 <scott_> That's the important bit
22:32:57 <syrioforel>  
22:33:17 <zomg> Hmm I wonder how badly my ghc / haskell-platform is going to break if I install GHC 7.6.3 from a PPA on Ubuntu Precise... :p
22:33:32 <scott_> jle`: This is what I use for querying it, you'll want to change the path on line 22: http://lpaste.net/96427
22:33:56 <scott_> After that you just need a ghci command that runs the script
22:34:19 <jle`> scott_, thanks :)
22:35:28 <scott_> Does anyone know what package provides do/undo for lambdabot?
22:35:38 <scott_> I'd like to steal that for ghci as well...
22:36:58 <jle`> undo is pretty neat
22:38:55 <zomg> Oagh, why does it look like GHC 7.6 is somehow b0rked on Ubuntu 13.04... >_>
22:38:57 <jle`> @undo do { x <- readLn; if even x then putStrLn "even" else putStrLn "odd" }
22:38:57 <lambdabot> readLn >>= \ x -> if even x then putStrLn "even" else putStrLn "odd"
22:38:58 <zomg> so much for installing it the easy way
22:39:13 <jle`> i don't know why i was expectin anything interesting
22:39:18 <Iceland_jack> radish: It was me but others suggested it as well
22:39:24 <scott_> @pl readLn >>= \ x -> if even x then putStrLn "even" else putStrLn "odd"
22:39:25 <lambdabot> flip (flip if' (putStrLn "even") . even) (putStrLn "odd") =<< readLn
22:39:49 <jle`> :t if'
22:39:49 <lambdabot>     Not in scope: if'
22:39:50 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
22:39:58 <scott_> if' x y z = if x then y else z
22:40:07 <jle`> how did i never know about this
22:40:14 <scott_> It's just defined for @pl
22:40:17 <jle`> ah
22:40:43 <mzero> actually, the one I want is:     bool f t b = if b then t else f
22:40:51 <mzero> analogous to    maybe
22:40:53 <scott_> That is a nice one
22:41:13 <mzero> though frankly, most people would probably expect    bool t f b = if b then t else f
22:42:01 <jle`> zomg: are you installing from source?
22:42:04 <mzero> I also wish for       list e f l = case l of [] -> e; (a:as) -> f a as
22:42:32 <zomg> jle`: considering I saw a warning it's going to take several hours I'm trying to find another way for now :D
22:42:34 <scott_> Is there a name for these kinds of functions?
22:42:46 <zomg> jle`: and I'm sure this several hours was spent on a beefier machine than my VPS is...
22:42:53 <mzero> jle`: perhaps     readLn >>= putStrLn . (\x -> if even x then "even" else "odd")
22:42:56 <jle`> zomg: several hours to buld from source?
22:43:00 <zomg> Ya
22:43:11 <mzero> then you can move that nice pure function elsewhere
22:43:11 <jle`> what are you building it on?
22:43:45 <zomg> I just saw someone post on SO that it had taken them several hours to compile it, not deets on what he did it on though. I have a VPS with 1 GB RAM on Linode, so I kinda get the feeling it'll probably take at least that on it..
22:43:46 <jle`> a ti089?
22:43:50 <jle`> ti-89
22:44:11 <jle`> i don't remember ghc taking too long to build from source for me
22:44:28 <zomg> Dunno, spose I could try it on a vagrant box locally on my Core i7 first and see how long that takes :P
22:45:33 <jle`> zomg: https://bitbucket.org/puffnfresh/vagrant-haskell-heroku
22:45:56 <jle`> change the Vagrantfile to the versions of ghc/haskell platform you want
22:46:22 <zomg> cheers
22:46:25 <jle`> mzero: how does that associate?
22:47:00 <mzero> readLn >>= (  putStrLn . (\x -> if even x then "even" else "odd"   )
22:47:14 <jle`> oh
22:47:25 <jle`> the too-strict-if thing
22:47:29 <mzero> dot binds very tight
22:47:35 <jle`> that hlint is always warning me about
22:47:59 <mzero> ?
22:48:19 <jle`> if you ever do something like if b then f x else f y
22:48:23 <jle`> it'll warn you to pull the f out
22:48:29 <jle`> to f (if b then x else y)
22:49:11 <mzero> ah
22:49:26 <mzero> I just D.R.Y. every chance I get
22:49:46 <mzero> also - I like to isolate pure code - so I can pull it out
22:49:54 <jle`> good principles
22:50:01 <jle`> for some reason though i always make my ifs way too strict
22:50:15 <jle`> maybe it comes from deeply ingrained imperative habits
22:50:32 <jle`> also when i first heard that error i had no idea what it meant, and i looked everywhere to try to figure it out but without getting many good answers
22:50:36 <jle`> i tried adding strictness annotations
22:50:39 <jle`> heh
22:50:53 <jle`> or maybe my conditions were too strict
22:50:55 <mzero> a good habit to get into is using guards and case over if
22:50:59 <jle`> (as in narrow)
22:51:32 <jle`> i do not use ifs often. i don't use guards enough i feel, but all of my if cases boil down to when and unless for me, normally
22:52:10 <jle`> maybe because i stil don't understnad use cases for guard
22:53:19 <jle`> how would you use them in that situation?
22:53:24 <jle`> er, how would you avoid if's
22:53:33 <jle`> i always feel awkward case'ing over booleans
22:56:57 <mzero> I'd have         readLn >>= putStrLn . classifyNum
22:57:18 <mzero> then      classifyNum x | odd x = "odd"      | otherwise = "even"
22:57:31 <jle`> oh you meant guards
22:57:35 <jle`> not the guard function
22:57:37 <mzero> on the presumption that classifyNum was going to get alot harder
22:57:49 <mzero> mind you,  if this really was just only ever going to be odd/even
22:57:53 <jle`> that makes sense
22:58:02 <mzero> I'd      classifyNum x = if odd x then "odd" else "even"
22:58:07 <mzero> and not worry about the if
22:59:24 <Spaceghost__> Clint: hey, open your queries to the catholics.
23:01:27 <zomg> jle`: btw that vagrantfile doesn't seem to work :\
23:01:57 <zomg> jle`: broke with some error about chef-solo not being able to convert a nil into a String
23:04:53 <jle`> zomg: huh how weird. it worked fine on my system multiple times
23:05:01 <jle`> ubuntu
23:05:28 <zomg> jle`: probably a different version of vagrant, says something about the vagrantfile being for an older version
23:05:35 <jle`> that might be it.
23:05:36 <zomg> runs fine until the chef-solo part though
23:06:21 <jle`> hm
23:06:42 <jle`> if you have an i7 you probably won't take too long to build ghc and the haskell platform though.
23:10:15 <zomg> jle`: yeah :)
23:10:37 * hackagebot gtk 0.12.5.0 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.5.0 (HamishMackenzie)
23:11:23 <jle`> if the ubuntu package manager versions are too out of date i usually just build...i don't see too much of an advantage of using ppa's
23:11:30 <jle`> remember to use checkinstall or something
23:11:36 <jle`> so you have an easy way to uninstall
23:22:58 <zomg> jle`: I think the issue is the cookbooks linked are broken for some reason.. I cloned pbrisbin/vagrant-haskell off github and that seems to work so far
23:23:24 <zomg> which in turn seems to be based on what you linked but has the cookbooks embedded into it instead of some url
23:24:49 <jle`> interesting
23:30:38 * hackagebot commodities 0.0.1 - Library for working with commoditized amounts and price histories  http://hackage.haskell.org/package/commodities-0.0.1 (JohnWiegley)
