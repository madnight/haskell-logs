00:03:44 <radish> how do i use ghci to import a library again?
00:04:08 <scott_> radish: import Foo.Bar
00:04:30 <radish> scott_: oh i just drop that right into the command prompt?
00:04:33 <scott_> Yeah
00:04:47 <scott_> In new versions, at least. Old way is :m + Foo.Bar
00:06:11 <radish> thanks
00:10:18 <jle`> j/b 10
00:19:45 <jle`> sorry
00:43:50 <joehillen> anyone have a type on how I can avoid: do {temp <- fun stuff; case temp of ...
00:43:54 <joehillen> *tip
00:44:24 <joehillen> the temp variable is pointless
00:44:38 <k00mi> there is the LambdaCase extension
00:45:17 <k00mi> so you could do "fun stuff >>= \case ..."
00:46:34 <joehillen> k00mi: that's perfect, thanks
00:52:55 <sssilver> Hello everyone
00:53:05 <sssilver> I wanna learn Haskell, but I'm afraid.
00:53:15 <jle`> hello sssilver
00:53:20 <jle`> there is notihing to fear :)
00:53:38 <sssilver> I keep reading interviews of people I worship who say Haskell is freaking hard
00:54:00 <JuanDaugherty> be afraid, be very afraid
00:54:03 <sssilver> and most programmers won't be able to properly perceive it, let alone learn it
00:54:33 <sssilver> gah, nevermind
00:54:47 <alpounet> sssilver: just start with Learn You A Haskell
00:54:52 <sssilver> I just wanted to join an IRC channel with predominantly smart people
00:55:03 <jle`> i don't know anyone who has found Learn You A Haskell inaccessible
00:55:14 <sssilver> yup, that's what I'm going by
00:55:19 <JuanDaugherty> depends on what you mean by "most programmers". There's a typical 10 year or less attrition rate for a
00:55:34 <JuanDaugherty> job title with millions of claimants at any one time
00:56:00 <jle`> sssilver: are you having trouble with LYAH?
00:56:06 <JuanDaugherty> 10s of millions more like
00:56:35 <sssilver> jle`, I'm having a trouble with the inconvenience of not having a state :)
00:56:40 <JuanDaugherty> LYAH is about as accessible as it gets
00:56:54 <JuanDaugherty> it's baby talking for chrissakes
00:57:00 <jle`> Haskell is hard in that it is different.  Anecdotal evidence suggest that those who have no experience programming, like children, who carry in no baggage, find functional programming much more intuitive than imperative programming
00:57:01 <companion_cube> sssilver: it's not necessarily an inconvenience
00:57:15 <jle`> sssilver: so not hard to understand; hard to do things in?
00:57:31 <sssilver> sort of, like if you're working on a game, having no state is quite difficult
00:57:39 <sssilver> you end up passing in zillions of arguments into every function
00:57:45 <jle`> hm
00:57:48 <jle`> that's not actually how it works
00:57:53 <jle`> in haskell
00:57:55 * hackagebot SimpleH 1.2 - A light, clean and powerful Haskell utility library  http://hackage.haskell.org/package/SimpleH-1.2 (MarcCoiffier)
00:57:55 * hackagebot alex 3.1.3 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.1.3 (SimonMarlow)
00:57:56 <JuanDaugherty> prolly shouldn't mess with haskell unless you take mathematics and CS seriously
00:58:00 <jle`> you *can* do it that way
00:58:08 <jle`> but...that's a really annoying way of doing it
00:58:12 <tac> sssilver: Haskell has state. You just have to be specific how you want to manage state.
00:58:14 <sssilver> yeah it's quite annoying jle`
00:58:18 <JuanDaugherty> and in that case you shouldn't be afraid
00:58:34 <sssilver> JuanDaugherty, that might be right
00:58:36 <jle`> but you can deal with state without passing zillions of arguments.
00:58:55 <jle`> in fact i will argue!!!
00:58:57 <jle`> !!!!
00:59:05 <jle`> that Haskell handles state in a more intuitive and safe and meaningful and powerful way
00:59:07 <JuanDaugherty> sssilver, and the number that do that prolly conforms to the fraction ur seein
00:59:07 <jle`> than imperative languages do
00:59:13 <jle`> and without any loss of convenience
00:59:39 <sssilver> jle`, do you mean the monads thing?
00:59:46 <sssilver> I haven't gotten there yet :)
00:59:51 <tac> Haskell's straightjacket is snug-fitting and comfortable once you get used to it.
00:59:57 <tac> Plus, it keeps you from hurting yourself.
01:00:01 <sssilver> JuanDaugherty, yeah, but that pretty much means that I'll have to give up on Haskell, and I do not wish to do that :)
01:00:03 <jle`> haskell allows you to understand what state really is
01:00:05 <JuanDaugherty> jle' yeah if your def of intuitive is what a grad student in math finds so
01:00:06 <tac> (The padded walls are nice too)
01:00:47 <jle`> JuanDaugherty: i don't really feel that there is any more reliance on math/cs in haskell than in a normal mainstream language
01:01:06 <JuanDaugherty> then you have a distorted perspective
01:01:12 <jle`> the difference is that math/cs will be more directly useful in haskell than in other languages
01:01:38 <jle`> but it's more like there is less of a diminishing return effect in learning math/cs in haskell than there is in other languages
01:02:11 <JuanDaugherty> wow you really twisted things there
01:02:14 <simpson> JuanDaugherty: I would say that if you are not willing to do some maths and some CS, then you should *not* be a programmer. Period. Choice of language is secondary.
01:02:17 <jle`> working day to day in haskell i have never felt more mathey than working in ruby, java
01:02:24 <JuanDaugherty> who said anything about learning math in haskell?
01:02:57 <JuanDaugherty> yes that was my point, the vast majority of people don't take it that way
01:03:07 <jle`> in other languages, being serious in maths/higher cs stuff can only get you *so far*.  in Haskell, you can go so far...and further.
01:03:17 <jle`> but you don't really ever need it to do useful things.
01:03:31 <JuanDaugherty> as a matter of fact in this time a lot of people are creating computer systems who can't even program
01:03:37 <JuanDaugherty> from "designs"
01:03:41 <simpson> JuanDaugherty: That's not a good thing.
01:03:59 <tdammers> it's kind of a vicious circle
01:04:11 <tdammers> the need for programmers is larger than the available talent pool
01:04:13 <JuanDaugherty> that's my impression of it at first take, that it's a kind of fraud, but maybe not
01:04:24 <tdammers> so a lot of programming is done by people who aren't good at it
01:04:49 <tdammers> idk, in it for the money, or unaware of their lack of talent, or just don't know what else to do with their lives
01:04:57 <tdammers> doesn't really matter
01:05:05 <tdammers> they do the job, but they're not good at it
01:05:09 <JuanDaugherty> in any case there are in fact right now world wide several tens of millions of people functioning as such
01:05:18 <tdammers> so we end up with a massive body of unmaintainable, suboptimal software
01:05:32 <JuanDaugherty> and the vast majority have barely heard of or maybe haven't even heard of haskell
01:05:47 <jle`> anyways, my point to sssilver, i have had much success in haskell without ever feeling more committed to cs or mathematics than in any other language.
01:05:52 <tdammers> and just keeping that software from falling down takes a huge pool of programmers
01:06:01 <tdammers> so the demand increases ever more
01:06:12 <tac> Haskell is where programmers go when they want to pretend to be mathematicians.
01:06:30 <jle`> ^^
01:06:32 <sssilver> lol tac
01:06:36 <tac> (You can tell it's a lie, though, because real mathematicians don't use category theory)
01:06:40 <tdammers> Haskell is where I go when I'm fed up with the limitations other languages subject me to
01:06:45 <syrioforel> tac: :C
01:06:51 <sssilver> jle`, yeah, in fact, it's not math I guess I'm struggling with, but with the down-to-earth stuff
01:06:57 <sssilver> like, in abstraction, everything seems cool
01:07:08 <tdammers> it's the only language I've ever used that never made me say "oh crap, I wish I could make this abstraction here, but I can't"
01:07:13 <sssilver> but when you have to do some IO, render some triangles, etc, then it becomes a pain
01:07:38 <joehillen> sssilver: it really doesn't
01:07:43 <JuanDaugherty> there are alternatives to haskell, CL maybe the main one
01:08:01 <JuanDaugherty> (the main general purpose one)
01:08:13 <tdammers> CL is fundamentally different in almost all practical regards though :x
01:08:13 <jle`> sssilver: it actually is less of a pain than you would imagine
01:08:13 <JuanDaugherty> or lisp generally
01:08:23 <arnsholt> tdammers: Only almost? =)
01:08:42 <jle`> sssilver: your prediction of the pain it is comes from your imperative baggage
01:08:44 <Twey> sssilver: I think the idea that Haskell is about eliminating state is a bit misguided.  Haskell is about eliminating *implicit* state.  We have lots of abstractions for making (explicit) state-passing nicer, like Reader/Writer/State, or ST.
01:08:47 <JuanDaugherty> a lot of people with prefer lisp as less culty
01:08:48 <tdammers> arnsholt: it's not PHP
01:09:01 <Twey> JuanDaugherty: *Less* culty?
01:09:01 <JuanDaugherty> *will prefer
01:09:07 <Twey> o.@
01:09:14 <JuanDaugherty> meant to say "slightly less culty"
01:09:20 <arnsholt> tdammers: Excellent point. Conceded. =D
01:09:31 <JuanDaugherty> meant to say "slightly less culty but a bit snottier"
01:09:37 <JuanDaugherty> cause they can be
01:10:02 <Twey> IME Haskell programmers usually know enough of what else is or could be out there to not boast about Haskell too much
01:10:03 <joehillen> you'll also find that 'state' is usually just a crutch in imperative languages and you really don't need to use it as often as you think you do
01:10:08 <Walther> Haskell is the best language in terms of readability and writability that I've faced, personally. I do hope I'd have more uses for it though.
01:10:11 <Twey> Maybe it's a mystery cult
01:10:32 <JuanDaugherty> gotta rope em into ur cult before you turn snotty which is why haskellers aren't as attitudinal
01:10:41 <jle`> sssilver: basically, try to suppress that nagging feeling in your head of "wait, but how will i be able to do [this thing i always would have done in an imperative language]?" and forget you ever knew anything
01:11:13 <joehillen> yes, forget everything you know about imperative programming, it will be much easier that way
01:11:26 <sssilver> that should be easy
01:11:28 <sssilver> eh
01:11:34 * Twey wonders if that advice ever actually worked for anyone
01:11:45 <jle`> your anxiety comes from these perceived problems that don't really exist :)
01:11:56 <joehillen> it worked for me
01:12:18 <jle`> Twey: idk, i've found that most of my own anxiety was worrying about 'how will i do this thing i used to do?'
01:12:24 <Twey> joehillen: Someone said ‘forget the stuff you've been cramming into your head for the last ten years and start afresh’ and you actually managed it?  :þ
01:12:31 <sssilver> jle`, I empathize with that
01:12:35 <JuanDaugherty> helps if you've worked with other non algol-likes such as lisp, prolog, etc.
01:12:59 <sssilver> I've only really worked with lots of C++ and lots of Python
01:13:16 <Twey> jle`: It would definitely be useful to do, but most people don't really have much experience of unlearning things
01:13:21 <joehillen> Twey: I did. I kept getting stuck and when I stopped trying to apply my existing knowledge things started falling into place
01:13:21 <JuanDaugherty> most people never work with anything that isn't essentially a dialect of C
01:13:23 <jle`> Twey: ah i see
01:13:24 <arnsholt> IME, the "problem" with Haskell (to someone used to almost anything else), is that you can't litter side effects willy-nilly all over your code
01:13:40 <begriffs> tac: wow, well said about pretend math.
01:13:45 <Twey> joehillen: That's a bit different :þ
01:13:58 <jle`> begriffs: was actually about to refer to your article about it, as a matter of fact
01:14:06 <arnsholt> This means that debugging as most of us do it (print ALL the things) is kinda tricky. The useful upshot is that once you get used to the way of thinking, debugging is a lot nicer
01:14:15 <mkscrg> is there a common Arbitrary Text instance somewhere?
01:14:17 * Twey goes to Agda when he wants to pretend to be a mathematician.
01:14:18 <mkscrg> or does everybody use the obvious fmap T.pack implementation?
01:14:46 <joehillen> I think it would be easier to teach my wife (who has no programming experience) haskell than my co-workers (who only have imperative programming experience)
01:14:54 <sssilver> that's my other worry -- debugging recursions is notoriously difficult. And Haskell implies lots of recursions.
01:15:16 <nooodl> Debug.Trace works well enough on the odd time i've needed it, but: often haskell forces me to split my code up into bits i can easily debug in ghci
01:15:30 <jle`> luckily in haskell you never debug anything. the compiler debugs for you :)
01:15:33 <jle`> :)
01:15:44 <bitemyapp> Upgrading cabal on fresh server: cabal-install-1.18.0.2 depends on Cabal-1.18.1.2 which failed to install.
01:15:47 <bitemyapp> whut.
01:15:48 <nooodl> i've never found haskell to imply lots of recursions. higher level functions take care of most situations i could imagine needing 'em
01:16:06 <jle`> honestly the idea that functional programming means recursion is kind of a flawed one
01:16:09 <bitemyapp> nooodl: it's the same in Clojure, you shouldn't be using loop/recur that often.
01:16:11 <arnsholt> nooodl: That's the thing. The strictures of the language mean that more debuggable code is natural
01:16:12 <jle`> i have talked about this before
01:16:13 <JuanDaugherty> the attrition rate is most evident it the age profile of the typical programming staff compared to other professional staffing
01:16:27 <JuanDaugherty> *in the age profile
01:16:27 <arnsholt> That's how it seems to me as mostly a Haskell novice, anyways
01:17:07 <jle`> actually i am torubled that most functional programming lessions teach recursion first
01:17:25 <jle`> i think it comes from the thinking "hey, no more loops...so how do you loop?  recursion!"
01:17:35 <jle`> but you should be thikning "hey, no more loops...why do you even need loops?"
01:17:44 <bitemyapp> jle`: I teach people in terms of folds instead.
01:17:46 <Twey> sssilver: Debugging recursion isn't strictly difficult.  It's just that the imperative modes of debugging (run through the loop a few times and see what you've got) isn't as useful.  Once you learn to think about invariants in arguments to function calls instead of state during loop executions, it becomes (IMO) much easier to debug in your head.
01:18:01 <jle`> bitemyapp: yes i feel like map and fold should be the real 'primitives'.
01:18:07 <bitemyapp> even map is just a fold.
01:18:15 <bitemyapp> but it's still a useful common-case thing to emphasize.
01:18:15 <jle`> yes but there is value in learning about map
01:18:18 <bitemyapp> yeah
01:18:22 <Urchin[emacs]> recursion is at least familiar from C even
01:18:23 <jle`> it's like...
01:18:23 <tdammers> yeah... instead of step debugging, I prefer running my functions through the paces in a repl these days
01:18:36 <jle`> when you learn C, you learn while and for loops
01:18:37 <lpaste> bitemyapp pasted “No title” at http://lpaste.net/96323
01:18:38 <tdammers> enforcing constraints and validating them
01:18:40 <jle`> you do'nt learn GOTO's.
01:18:41 <tdammers> that kind of thing
01:18:44 <bitemyapp> no but seriously guys, wtf ^^
01:18:55 <bitemyapp> cabal complains about a different version of cabal when I try to install on a fresh machine.
01:19:13 <Fuuzetsu> cabal install cabal?
01:19:13 <jle`> do you have any custom configuration bitemyapp ?
01:19:39 <joehillen> bitemyapp: oh right, I had this happen to me too, I forgot how I fixed it. Google?
01:19:41 <sssilver> Twey, http://dpaste.com/1485894/ is a recursion in Python that I'm working on right now at workplace. Very difficult to debug.
01:19:42 <bitemyapp> jle`: not as far as I'm aware.
01:19:46 <bitemyapp> cabal install cabal-install
01:19:53 <bitemyapp> joehillen: trust me, I am googling my ass off.
01:19:58 <bitemyapp> I'm finding abandoned lpaste's with no answer.
01:20:08 <sssilver> I wish it was an iteration, but you can't properly traverse a tree without recursion
01:20:16 <sssilver> *iteration -> loop
01:20:18 <Twey> sssilver: I think your issue is more that that function is huge.  :þ
01:20:20 <joehillen> bitemyapp: did you try 'cabal install cabal'?
01:20:50 <syrioforel> I second Twey's comment
01:20:57 <bitemyapp> joehillen: I'll try it now, but that is strange.
01:21:12 <nooodl> also "filter" is a very confusing name for it!
01:21:19 <sssilver> Twey, it's not easily split into smaller functions.
01:21:28 <sssilver> nooodl, it filters a tree, leaving only matching nodes
01:21:30 <tac> sssilver: I've written scripts like that in Python before. It helps to take the time to refactor it once you get something basic working.
01:21:32 <bitemyapp> sssilver: psssst, use lpaste.net :)
01:21:35 <joehillen> sssilver: it would be in Haskell
01:21:40 <tac> (Otherwise you forget how the darn thing works)
01:21:49 <bitemyapp> wait, you're asking a Python question
01:21:54 <sssilver> I'm not asking a question
01:22:03 <sssilver> I'm just saying that recursions can be very difficult to debug
01:22:04 <bitemyapp> sssilver: you can split that function into components, don't kid yourself.
01:22:45 <bitemyapp> joehillen: cabal install cabal seems to be working, thank you
01:22:52 <bitemyapp> Fuuzetsu: thanks to you too
01:22:53 * hackagebot happy 1.19.2 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.19.2 (SimonMarlow)
01:22:58 <bitemyapp> I didn't realize you were making a suggestion.
01:23:14 <Fuuzetsu> np
01:23:34 <jle`> sssilver: due to a lot of language features in haskell, working with recursion in haskell, when you need it, feels a lot less stressful than in other languages
01:23:48 <joehillen> bitemyapp: np
01:23:49 <bitemyapp> abal-1.18.1.2 failed during the building phase. The exception was:
01:23:50 <jle`> and i might venture to say easier to debug
01:23:56 <bitemyapp> ExitFailure 9
01:23:59 <bitemyapp> joehillen: nope, failed.
01:24:09 <bitemyapp> it failed for the same reason as the last build, just without the indirection.
01:24:22 <Twey> bitemyapp: Isn't that the out-of-memory error?
01:24:25 <lpaste> bitemyapp pasted “No title” at http://lpaste.net/96324
01:24:39 <jle`> i wish there was some index of all those cabal errors
01:24:54 <bitemyapp> Twey: so it is!
01:25:00 <bitemyapp> okay I'd better transpile this :)
01:25:03 <Twey> jle`: Better error messages would also be nice :þ
01:25:29 <bitemyapp> nuts.
01:25:32 <joehillen> 'ExitFailure 9' isn't good enough for you?
01:25:42 <bitemyapp> cross-compilation is apparently more of a 7.8.1 rather than 7.6.3 thing.
01:25:45 <sssilver> hey but I'm quite happy #haskell on Freenode has such a pleasant community
01:25:52 <Twey> bitemyapp: Apparently switching to gold reduces your memory usage quite significantly
01:25:56 <sssilver> that's a big part of the language :)
01:26:00 <bitemyapp> Twey: I beg your pardon? gold?
01:26:02 <sssilver> those who write on it
01:26:08 <Twey> bitemyapp: It's an alternative linker
01:26:15 <bitemyapp> okay, let me see how to flip over.
01:26:36 <Twey> It's a bit of a pain.  I ended up just making a chroot elsewhere that looked like my server, and compiling there :þ
01:27:18 <jle`> sssilver: :) not just on freenode too, haskell is a nice community overall, i've found
01:27:35 <bitemyapp> Twey: re-attempting with gold, thank you.
01:27:37 <joehillen> jle`: it's only because it's so small
01:27:44 <bitemyapp> joehillen: no, it's more than that.
01:27:47 <Twey> bitemyapp: No problem; let me know if it works.  ☺
01:27:48 <joehillen> just wait until the proles show up
01:28:02 <bitemyapp> joehillen: Haskell community isn't that small, I think it's because the difficulty of learning the language prevents a "pop culture" arising ala Rails/Ruby.
01:28:11 <bitemyapp> so if Haskell gets overtaken, move to Agda :P
01:28:19 <joehillen> ^ truth
01:28:20 <Twey> Already halfway there
01:29:21 <Lethalman> bitemyapp, or the paradigm
01:29:38 <bitemyapp> there's a cultural inclination to thoughtfulness too.
01:29:56 <bitemyapp> as opposed to self-aggrandizing puffery in some other communities.
01:29:59 <Twey> High level of academic involvement, I think
01:30:10 <bitemyapp> Twey: gold didn't work.
01:30:11 <Lethalman> I don't think it's the difficulty of the language per-se, rather the functional paradigm
01:30:14 <Twey> bitemyapp: Aw.
01:30:22 <bitemyapp> doesn't recognize hash-size argument, I'd have to hack up the packages.
01:30:26 * Twey nods.
01:30:44 <Twey> I do wonder why this happens instead of swapping
01:30:44 <bitemyapp> I don't really want to muck around in .m4
01:31:04 <Twey> Oh, people just don't use swap any more.  Okay.
01:31:19 <Twey> If you're lacking swap, adding it might do the trick (eventually)
01:31:21 <bitemyapp> Twey: I'm making one manually.
01:31:22 <bitemyapp> yes.
01:32:05 <bitemyapp> Twey: it might not be that painful, the instance has an SSD.
01:32:17 <bitemyapp> so swapping may be less of a big deal. We'll see.
01:32:26 <Twey> So long as it's not *your* SSD you're doing all those writes to ;)
01:32:33 <joehillen> you can make a temporary swap file, fyi
01:32:44 <bitemyapp> joehillen: that's what I just did.
01:32:51 <bitemyapp> Twey: $5/mo server.
01:33:00 <Twey> DigitalOcean?
01:33:03 <JuanDaugherty> how can an "instance" have an SSD?
01:33:31 <bitemyapp> JuanDaugherty: it's shared
01:33:35 <bitemyapp> Twey: yeppers.
01:33:37 <Twey> JuanDaugherty: They generally try to allocate a contiguous chunk of HD space rather than sending blocks over the network all the time :þ
01:33:43 <bitemyapp> I'm trying to compile gitit on the server.
01:34:30 <Twey> JuanDaugherty: And DO guarantees that space will be on an SSD.
01:34:49 <JuanDaugherty> I paid $50 for my 1st SSD, a mistake because it only lasted about 60 days
01:35:10 <bitemyapp> JuanDaugherty: SSDs have higher variance in quality, you have to do buy a quality brand-name one with good reviews.
01:35:17 <bitemyapp> JuanDaugherty: also, SLCs last longer than MLCs.
01:35:28 <bitemyapp> you have to do research* and buy
01:35:40 <bitemyapp> SSDs are wonderful, couldn't live without 'em.
01:35:53 <JuanDaugherty> right, I knew what I was getting but was still a little surprised at the 60 day deal
01:36:06 <bitemyapp> that was a manufacturer fault unless you were churning the data.
01:36:11 <adnap> I can't seem to write fmap f = id for instnace Functor (Const v)
01:36:11 <JuanDaugherty> OCZ FWIW
01:36:15 <bitemyapp> JuanDaugherty: were you using all the drive's space?
01:36:21 <JuanDaugherty> yes
01:36:27 <JuanDaugherty> well per spec
01:36:27 <bitemyapp> JuanDaugherty: yeah, don't wanna do that.
01:36:32 <ion> adnap: Yeah, because id doesn’t change the type.
01:36:44 <JuanDaugherty> it was only like 30G
01:36:47 <ion> fmap :: (a -> b) -> Const v a -> Const v b
01:36:48 <ion> id :: a -> a
01:36:49 <bitemyapp> oh that's fine then.
01:36:53 <adnap> Can you guys take it to #haskell-blah?
01:37:09 <bitemyapp> adnap: sorry
01:37:25 <bitemyapp> Twey: the ad-hoc swapfile trick worked, lol.
01:37:31 <bitemyapp> it wasn't even that slow.
01:37:44 <Twey> \o/
01:37:52 <ion> adnap: unsafeCoerce ought to work. ;-)
01:38:40 <Twey> adnap: Const v is a monofunctor, no?
01:38:43 <JuanDaugherty> adnap: wouldn't have been more on topic there, pm would have been a more proper snipe
01:39:03 <adnap> Also, I can't write view :: Lens' s a -> (s -> a) as view l s = getConst . l Const. I have to write view l s = getConst (l Const s)
01:40:02 <Twey> adnap, Fuuzetsu (re. the other day): http://hackage.haskell.org/package/mono-traversable-0.1.0.0/docs/Data-MonoTraversable.html#t:MonoFunctor
01:40:34 <ion> twey: Sure, but it’s also a Functor.
01:40:56 <adnap> Twey: I don't know what you're talking about
01:41:20 <Fuuzetsu> mofumofu
01:41:34 <Fuuzetsu> http://myanimelist.net/anime/5241/Mofu☆Mofu
01:42:22 <bitemyapp> Fuuzetsu: ༼ つ ◕_◕ ༽つ
01:42:31 <adnap> Twey: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Const
01:42:37 <Twey> Oh, I see
01:42:38 <alpounet> adnap: in your first def, the 's' shouldn't be there, should it?
01:43:05 <adnap> alpounet: No!
01:43:10 <adnap> alpounet: Thanks
01:44:09 <Fuuzetsu> alpounet: re yesterday: the ‘:kinds!’ doesn't cut it because I don't want to know that String is actually [Char], I want to know that [Char] is aliased to String.
01:44:48 <bitemyapp> Fuuzetsu: whoa that's an interesting problem.
01:45:40 <Fuuzetsu> Probably not worth the effort of implementing, especially considering that you can have multiple aliases &c.
01:45:42 <ion> fuuzetsu: That would be very nice with Lens types, too.
01:45:43 <Fuuzetsu> It'd be nice though.
01:46:28 <Fuuzetsu> Maybe we could ask GHC(i) what in scope aliases something as a new option…
01:46:42 <alpounet> Fuuzetsu: and say you have 'type Foo = String', what would you like that magic command you want to output when asked what 'Foo' is?
01:46:54 <alpounet> String or [Char]?
01:47:15 <Twey> Fuuzetsu: This is undecidable in the presence of fundeps/type families, mind
01:47:42 <sssilver> must..... not...... remember........ the `return` keyword............ must... forget......... arghhh!!!!
01:47:44 <jle`> hi all.  what is so Applicative about applicative parsers?  can someone give an example of working with something like parsec that highlights its useful properties as an applicative and *not* its useful properties as a functor, and its useful properties as a monad?
01:47:49 <Fuuzetsu> alpounet: Foo. I'd like this command to produce ‘Foo’ when given ‘String’ and not go the other way.
01:47:54 <alpounet> in ghci, :kind! would answer [Char]
01:47:57 <alpounet> alright
01:48:11 <alpounet> some kind of "go to definition" ?
01:48:29 <alpounet> maybe ":info" then ?
01:48:33 <Fuuzetsu> Twey: I'm looking for a simple solution, maybe look for ‘type …’ in the source file or something. I don't know.
01:48:51 <alpounet> :info String returns "type String = [Char]"
01:48:57 <ion> jle: name :: Parser String; name = (:) <$> alpha <*> alphaNum
01:49:17 <alpounet> and if i define "type Foo = String", ":info Foo" gives me back "type Foo = String"
01:49:30 <jle`> ion: ah that makes sense
01:49:31 <alpounet> and it says where it was defined
01:49:36 <ion> jle: int :: Parser Integer; int = negation <*> nat; nat :: Parser Integer; nat = read <$> many1 digit; negation :: Num a => Parser (a -> a); negation = negate <$ char '-' <|> pure id
01:49:40 <Fuuzetsu> alpounet: No no no. Again, you're going Foo -> String, not String -> Foo
01:49:50 <alpounet> ooooh, sorry
01:50:07 <ion> jle: Whoops, i meant “many alphaNum” earlier.
01:50:14 <alpounet> what would you like this for?
01:50:48 <jle`> :t negate
01:50:49 <lambdabot> Num a => a -> a
01:51:00 <jle`> that's just the (-) right?
01:51:09 <ion> That’s like (0-)
01:51:10 <jle`> er, the unary negative sign
01:51:14 <jle`> @src negate
01:51:15 <lambdabot> negate x = 0 - x
01:51:29 <jle`> didn't realize there was a function for it
01:51:36 <ion> @src (-)
01:51:36 <lambdabot> x - y = x + negate y
01:52:29 <k00mi> both are part of Num, right?
01:52:41 <k00mi> negate and (-), that is
01:52:49 <jle`> well there is a Num constraint, like lambdabot said
01:52:53 <Twey> k00mi: Yes
01:52:55 * hackagebot haskell-names 0.3.2.1 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.2.1 (RomanCheplyaka)
01:53:04 <Twey> jle`: More than that, they're part of the typeclass
01:53:04 <jle`> :t (-)
01:53:05 <lambdabot> Num a => a -> a -> a
01:53:09 <jle`> oh
01:53:31 <jle`> negate must be, but (-) must be a derived function?
01:53:33 <Twey> You need at least one of them for a complete instance of Num
01:53:39 <jle`> oh okay
01:53:44 <jle`> it picks one or the other?
01:53:50 <Twey> No, (-) is part of the typeclass too, to allow for optimizations
01:53:53 <Fuuzetsu> alpounet: to turn things like ‘[ ("I", ["x"], EVar "x") ] :: [([Char], [[Char]], Expr a)]’ into ‘ :: Program a’, or whatever I happen to be aliasing.
01:54:02 <Twey> (but has a default definition in terms of negate, which you just saw)
01:54:06 <jle`> @src (<$)
01:54:06 <lambdabot> (<$) = (<$>) . const
01:54:24 <jle`> Twey: ah yeah i guess I forgot that those are just default implementations
01:54:37 <jle`> you just need to override one of them to break the loop
01:54:41 <Twey> Mutually-recursive default implementations are a long-standing tradition :þ
01:54:48 <jle`> that's clever
01:54:49 <Twey> @src (==)
01:54:49 <lambdabot> x == y = not (x /= y)
01:54:51 <Twey> @src (/=)
01:54:51 <lambdabot> x /= y = not (x == y)
01:54:57 <Twey> These are both in Eq
01:54:59 <jle`> haha
01:55:01 <alpounet> ok I see, i'm clueless then, I'm not aware of anything solving this problem
01:55:15 <jle`> :t (<$)
01:55:16 <lambdabot> Functor f => a -> f b -> f a
01:55:50 <jle`> type analysis has failed me
01:56:11 <ion> Take a “f b”, throw away the “b” and replace it with the “a” you provided.
01:56:42 <jle`> is it just like a swap?
01:56:57 <Twey> jle`: No, it's like a const
01:57:00 <jle`> > 5 <$ Maybe 'f'
01:57:01 <ion> > "hello" <$ [0..5]
01:57:01 <lambdabot>   Not in scope: data constructor `Maybe'
01:57:02 <lambdabot>   ["hello","hello","hello","hello","hello","hello"]
01:57:06 <jle`> oops.
01:57:08 <Twey> But with a functor
01:57:12 <jle`> > 5 <$ Just 'f'
01:57:12 <lambdabot>   Just 5
01:57:17 <ion> > const "hello" <$> [0..5]
01:57:18 <lambdabot>   ["hello","hello","hello","hello","hello","hello"]
01:57:18 <jle`> it ignores the second argument
01:57:22 <jle`> and just returns the first?
01:57:32 <Twey> It ignores the ‘value inside’ the second argument
01:57:32 <jle`> but in the functor of the second argument?
01:57:33 <ion> > do { x <- [0..5]; return "hello" }
01:57:34 <lambdabot>   ["hello","hello","hello","hello","hello","hello"]
01:57:36 <Twey> It keeps the ‘context’
01:57:43 <Twey> > 5 <$ Nothing
01:57:44 <lambdabot>   Nothing
01:58:21 <Twey> If you like, it combines the value of the first argument with the context of the second
01:58:43 <jle`> you know this whole time i thought i was programming "applicatively" by turning do {x <- something; return $ f x} into f <$> something
01:58:48 <jle`> but that's just programming "functorly" isn't it
01:59:01 <Twey> Well, it's an application.  ☺
01:59:18 <ion> Turning do { x <- foo; y <- bar; return (something x y) } into the equivalent Applicative notation would be programming applicatively.
01:59:27 <mm_freak_> jle`: x <$ c = fmap (const x) c
01:59:33 <jle`> but it has nothing to do with the applicative properties of the functor
01:59:35 <mm_freak_> jle`: x <$ c = const x <$> c
01:59:43 <Twey> (<*>) is the real Applicative method.
02:00:19 <mm_freak_> jle`: using fmap is also applicative style, but only a trivial special case of it
02:00:26 <jle`> doing something likke f <$> something does not involve the applicativeness of the data type at all
02:00:35 <Twey> Aye
02:00:39 <mm_freak_> jle`: applicative style = liftA, liftA2, liftA3, liftA4, …
02:00:44 <ion> Which is arbitrary, the real Applicative method could also be e.g. liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c or foo :: Applicative f => (f a, f b) -> f (a, b)
02:00:53 <arkeet> :t liftA2 (,)
02:00:54 <lambdabot> Applicative f => f a -> f b -> f (a, b)
02:00:57 <Twey> Aye
02:01:00 <arkeet> :t uncurry (liftA2 (,))
02:01:01 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
02:01:06 <arkeet> :t both
02:01:07 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
02:01:12 <arkeet> right.
02:01:13 <arkeet> :t both id
02:01:14 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
02:01:51 <Twey> arkeet: Not quite the same because the type got fixed.
02:02:01 <jle`> liftA is fmap?
02:02:06 <jle`> er..."amap"?
02:02:11 <mm_freak_> jle`: fmap
02:02:29 <mm_freak_> fmap = liftA = liftM
02:02:32 <ion> jle: liftA and liftM are like fmap but implemented using Applicative/Monad primitives.
02:02:39 <mm_freak_> = liftW
02:02:41 <jle`> it lifts the function it is given into the applicative
02:02:45 <jle`> and applies it
02:02:48 <jle`> ?
02:02:58 <nouitfvf> > import
02:02:59 <lambdabot>   <hint>:1:1: parse error on input `import'
02:03:03 <ion> If you have an instance of Applicative and/or Monad for something, you can implement Functor as fmap = liftA or fmap = liftM
02:03:07 <nouitfvf> > import Data.Logic.Propositional
02:03:08 <lambdabot>   <hint>:1:1: parse error on input `import'
02:03:14 <jle`> so liftA (*2) (Just 5) is the same as
02:03:16 <nouitfvf> oh sorry
02:03:22 <jle`> (Just (*2)) <*> (Just 5) ?
02:03:29 <jle`> that's what the "lift" means?
02:03:39 <jle`> > (Just (*2)) <*> (Just 5)
02:03:40 <lambdabot>   Just 10
02:03:44 <ion> yeah
02:03:51 <Twey> jle`: ‘Lift’ refers to the partial application
02:03:52 <ion> liftA f x = pure f <*> x
02:03:53 <Twey> :t (* 2)
02:03:54 <lambdabot> Num a => a -> a
02:03:57 <Twey> :t fmap (* 2)
02:03:58 <lambdabot> (Functor f, Num b) => f b -> f b
02:04:13 <mm_freak_> jle`: conversely you can think of liftA2 and liftM2 as "fmap2"
02:04:13 <ion> liftM f x = x >>= return . f
02:04:22 <Twey> It ‘lifts’ the function into the functor
02:04:27 <Twey> (or monad, or comonad, or whatever)
02:04:37 <mm_freak_> fmap2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
02:04:45 <jle`> okay so the difference between fmap, liftA, and liftM are that they are implemented using the primitives of their respective typeclass
02:04:53 <jle`> even though they "do" the same thing
02:05:04 <ion> One should always use fmap unless there’s a specific reason to do otherwise.
02:05:09 <Twey> Hey, will they all collapse when we get a proper superclass hierarchy?
02:05:26 <mm_freak_> that there is any difference at all between liftM and fmap is a historical accident
02:05:35 <ion> The specific reason can be “implementing Functor in terms of Applicative/Monad” or “there would be an annoying additional type constraint”. The latter will be fixed somewhere around GHC 7.8 or 7.10
02:05:36 <jle`> mm_freak_: do you mean to include liftA there as well?
02:05:53 <mm_freak_> jle`: no, liftA and fmap are exactly the same thing
02:06:06 <mm_freak_> some people call this lifting, others call this functor-mapping
02:06:29 <jle`> i feel like, conceptually, they are two different paths to get to the same location
02:06:36 <jle`> so it might be useful to preserve the distinction
02:06:38 <jle`> somehow.
02:06:59 <mm_freak_> well, there are two different paths:  from top to bottom and from bottom to top
02:07:09 <mm_freak_> you can understand Applicative in terms of Functor and vice versa
02:07:26 <jle`> i mean, between fmap, liftA, and liftM, they might have the same total effect, but conceptually they are different things, right?
02:07:36 <jle`> or is their difference really meaningless
02:07:46 <mm_freak_> no, their difference is a historical accident
02:07:55 <mm_freak_> they should be exactly the same
02:08:03 <jle`> hm
02:08:14 <fizruk> i think you can look at the type as (a -> b) -> f a  -> f b or (a -> b) -> (f a -> f b)
02:08:22 <jle`> okay i think i see what you are saying
02:08:33 <jle`> but really though, liftA and liftM don't even have to exist at all
02:08:38 <mm_freak_> jle`: categorically they are indistinguishable
02:08:53 <jle`> because liftM and liftA aren't really..."important" applicative and monad methods
02:08:53 <FireFly> Hm
02:09:05 <FireFly> Why does liftA exist anyway?
02:09:16 <jle`> they distract from the applicativeness or monadness of the instance
02:09:16 <mm_freak_> jle`: in haskell however the Functor class is younger than the Monad class, so it never become a superclass of Monad (which was a terrible mistake!)
02:10:05 <jle`> liftA and liftM do nothing regarding the applicativeness and monadness of their instance, right?
02:10:25 <jle`> they aren't really 'primitive' actions
02:10:33 <jle`> whereas fmap is a primitive property of Functor
02:10:42 <mm_freak_> jle`: well, fmapping is an integral part of applicative/monadic style, so that may be misleading
02:11:28 <mm_freak_> jle`: you can define a monad either in terms of 'return' and (>>=) or in terms of 'fmap', 'return' and 'join'
02:11:56 <mm_freak_> in the former case you can define fmap as:  fmap f c = c >>= return . f
02:12:29 <jle`> yeah; you use fmapping in applicative and monatic style...but fmapping is not the defining characteristic of a monad or an applicative
02:12:37 <jle`> it's just a convenient helper function
02:12:38 <mm_freak_> it is
02:12:48 <fizruk> jle`, i think if you look at it as (a -> b) -> (f a -> f b) you may call it lift, because it looks like lifting a function from (a -> b) to (f a -> f b), but that is irrelevant of Functor-Applicative-Monad problems
02:12:49 <mm_freak_> every monad is a functor
02:13:15 <mm_freak_> monads are actually defined in terms of functors, similarly to how groups are defined in terms of monoids
02:13:18 <fizruk> hence different names for the same thing
02:13:45 <jle`> defining is probably not the right word; how about...'feature that distinguishes it from other things'?
02:14:07 <mm_freak_> jle`: but it is a defining feature
02:14:16 <jle`> like yeah, addition is a defining feature of Num
02:14:22 <jle`> but what sets Num apart is division
02:14:37 <mm_freak_> jle`: it's just that the new operations introduced by Monad make the fmap redundant, so technically it's not /necessary/ to have Functor be a superclass of Monad
02:14:44 <jle`> er i think i mixed up my hierarchy there
02:15:04 <jle`> mm_freak_: well.  you say that you can define Monadness in terms of fmap and join
02:15:12 <FireFly> and return
02:15:14 <ion> OTOH fmap can be easier to optimize than x >>= return .f
02:15:18 <Destinova> Has anyone attempted to use Haskell in conjunction with Oracle products?
02:15:20 <jle`> so in some sense fmap can be considered a primitive of monad
02:15:47 <FireFly> jle`: in my mind "can be derived" and "primitive" are a bit like antonyms..
02:15:47 <mm_freak_> jle`: it is a primitive
02:15:58 <Destinova> like Primavera/WebLogic etc.
02:16:05 <ion> destinova: We’re afraid the Oracleness could leak and infect the whole Haskell ecosystem.
02:16:10 <jle`> FireFly: yes I do not disagree
02:16:29 <jle`> in one way of defining monad, you have fmap and join as primitives
02:16:30 <Destinova> ion: LOL
02:16:42 <mm_freak_> and return
02:16:54 <jle`> and return, sorry
02:17:00 <jle`> and the other way, your primitives are...
02:17:03 <jle`> (>>=)?
02:17:06 <Destinova> you'd rather be infected by Oracleness than by SAPness or MSFTness :) But seriously, has anyone tried?
02:17:08 <mm_freak_> and return
02:17:12 <jle`> and return
02:17:23 <jle`> but they are both equivalent structures
02:17:26 <mm_freak_> a monad is a functor with return and join
02:17:26 <jle`> mathematically
02:17:40 <mm_freak_> just like a group is a monoid with an total inverse function
02:17:44 <ion> In my preferred way of defining Monad, you get fmap from the Functor superclass, pure from the Applicative superclass and can choose to implement one or both of (>>=) and join.
02:18:11 <jle`> i never realized that there is no pure/return from Functor
02:18:50 <shiona_> Would it be possible to create one operator that would make python like multicomparisons possible? (http://www.java2s.com/Tutorial/Python/0080__Operator/multiplecomparisonscanbemadeonthesamelineevaluatedinlefttorightorder.htm)
02:19:00 <FireFly> ion: that'd be neat
02:19:11 <ion> firefly: AMP should finally get us there.
02:19:16 <mm_freak_> class (Applicative f) => Monad f where join :: f (f a) -> f a; (>>=) :: f a -> (a -> f b) -> f b
02:19:31 <mm_freak_> i think the worst historical accident is to name the type variables 'm' =)
02:19:57 <jle`> ion: i think i'm going to grab that definition then.  it's a nice one
02:20:00 <FireFly> ion: you still can't define Monad by providing an instance for join, though, no?
02:20:06 <FireFly> since it isn't part of the type class
02:20:06 <shiona_> For now my two best tries have been (1 <& 2) (<) 3   and   1 <& 2 <&& (pure 3)
02:20:50 <mm_freak_> FireFly: you can…  given join you have: c >>= f = join (fmap f c)
02:21:02 <FireFly> mm_freak_: yes, yes, I mean with Haskell's current definition of Monad
02:21:03 <mm_freak_> so you can define myJoin and then (>>=) in terms of myJoin
02:21:08 <jle`> i think he means that the compiler will complain?
02:21:21 <mm_freak_> i defined monads that way in the past
02:21:26 <FireFly> by which I mean Control.Moad
02:21:28 <FireFly> Monad*
02:21:50 <mm_freak_> but yeah, you can't define it /solely/ in terms of join
02:21:56 <jle`> hm. monads also have <*> then don't they.
02:21:58 <ion> firefly: IIRC the AMP will bring join into the class.
02:22:01 <mm_freak_> (assuming fmap and pure are already there)
02:22:02 <jle`> is <*> meaningful in monadic style?
02:22:08 <ion> @src ap
02:22:08 <lambdabot> ap = liftM2 id
02:22:10 <FireFly> ion: oh, nice
02:22:19 <ion> @type (ap, (<*>))
02:22:20 <lambdabot> (Monad m, Applicative f) => (m (a -> b) -> m a -> m b, f (a1 -> b1) -> f a1 -> f b1)
02:22:20 <jle`> just like how fmap is meaningful in applicative/monadic style
02:22:21 <Twey> shiona_: You can do something like printf does (except safer :þ).
02:22:32 <jle`> does monad gain anything from having <*>?
02:22:37 <mm_freak_> jle`: yes
02:22:44 <mm_freak_> it gains applicative style
02:23:03 <shiona_> Twey: any pointers on what it is you mean?
02:23:10 <mm_freak_> liftM2 f x y = return f `ap` x `ap` y
02:23:18 <jle`> how does <*> fit into monadic style?
02:23:21 <roboguy_> jle`: I guess it depends on what you mean by "gain". ap = (<*>)
02:23:22 <mm_freak_> liftA2 f x y = return f <*> x <*> y
02:23:25 <jle`> er, or `ap`, becuase it's apparently the same
02:23:27 <mm_freak_> uh
02:23:28 <mm_freak_> liftA2 f x y = pure f <*> x <*> y
02:23:51 <mm_freak_> ap : (<*>) = fmap : liftM
02:23:59 <mm_freak_> = pure : return
02:24:19 <jle`> i mean, does monadic style involve `ap`
02:24:20 <ion> ap : (<*>) = liftM : fmap
02:24:28 <jle`> like how applicative style/monadic style involve fmap
02:24:39 <roboguy_> jle`: ap only works on Monad instances, so yeah
02:24:54 <mm_freak_> jle`: each time you write this:  do x1 <- c1; x2 <- c2; x3 <- c3; return (f x1 x2 x3)
02:25:00 <mm_freak_> that's applicative
02:25:16 <mm_freak_> and you can write liftM3 f c1 c2 c3 instead
02:25:27 <yitz> @type \f x y -> f <$> x <*> y
02:25:27 <jle`> heh. i meant, "the ability to apply a contex'd function to a contex'd value, in that context"
02:25:27 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
02:25:52 <yitz> @type \f x y -> pure f <*> x <*> y
02:25:53 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
02:25:56 <jle`> mm_freak_: ah okay
02:26:09 <jle`> so you would do f <$> x1 <*> x2 <*> x3
02:26:10 <jle`> ?
02:26:24 <mm_freak_> f <$> c1 <*> c2 <*> c3
02:26:32 <jle`> oh yes.
02:26:37 <jle`> but in monadic 'style', you do'nt do that?
02:26:38 <mm_freak_> (\x1 x2 x3 -> f x1 x2 x3) <$> c1 <*> c2 <*> c3
02:26:52 <jle`> you would do the separate binds
02:26:58 <mm_freak_> in monadic /style/ you don't…  you'd write the do-notation above
02:26:59 <jle`> and then a final return
02:27:17 <mm_freak_> the point is:  you don't need the Applicative instance to use applicative style =)
02:27:23 <jle`> hm yes i feel like i am starting to make less sense
02:27:27 <mm_freak_> the liftM* functions are applicative style
02:27:37 <yitz> and `ap`
02:27:50 <jle`> i am starting to lose sight of what i was originally trying to find out.
02:28:10 <jle`> but this has been enlightening.
02:28:12 <mm_freak_> jle`: you're exploring a giant new realm, so it's easy to get lost =)
02:28:25 <jle`> i guess it's that i never really gave applicatives any love
02:28:47 <jle`> i want to start seeing them as useful in their own right
02:29:06 <jle`> especially after reading a claim that those cool parser combinator stuff that was championed as the poster child of monadic style
02:29:12 <jle`> actually only needs to be applicative
02:29:21 <ion> “Transforming mostly-monadic code to mostly-applicative code” https://gist.github.com/ion1/7016798
02:29:26 <jle`> and that its monadicness is completely unecessary to its usefulness
02:29:39 <mm_freak_> they are very useful, not only because they make your code easier to read, but also because you get some unique guarantees by ignoring the monadness of a functor =)
02:30:04 <ion> Applicative code can also be easier to optimize because more can be known about its control flow statically.
02:30:08 <mm_freak_> the guarantees are established by the applicative laws
02:30:28 <yitz> mm_freak_: the main advantage in practice is that often makes your code easier read.
02:30:37 <jle`> what even are the applicative laws i do not even know. time to google.
02:30:53 <ion> or hoogle
02:30:57 <mm_freak_> jle`: just read the haddock documentation of Control.Applicative
02:31:20 <mm_freak_> jle`: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html
02:31:34 <mm_freak_> (you should have a local copy of that)
02:31:40 <jle`> mm_freak_: yeah that was open :)
02:31:44 <jle`> hm where is my local copy?
02:31:51 <jle`> i have always wanted to be able to access one
02:32:31 <ion> jle: In the gist, the do block in example 0 doesn’t require Monad at all and the do block in example 1 requires exactly one “join” apart from Functor/Applicative.
02:33:03 <ion> jle: ~/.cabal/share/doc/index.html on my system
02:33:14 <mm_freak_> jle`: the easiest way is set "documentation: True" in your ~/.cabal/config, then install a package
02:33:34 <mm_freak_> that installs the documentation of every installed package into ~/.cabal/share/doc
02:33:37 <jle`> mm_freak_: i set that to true when i started this most recent clean slate
02:33:38 <jle`> but
02:33:40 <jle`> i can't find base
02:33:49 <mm_freak_> and there will be a nice module index at the location pointed out by ion
02:34:12 <mm_freak_> jle`: the base modules are linked from that index
02:34:33 <mm_freak_> you recognize them by the "base" at the right hand side
02:34:35 <jle`> oh there you are
02:35:36 <jle`> thanks
02:35:56 <jle`> hm.
02:36:24 <mm_freak_> jle`: my personal way of looking at all this is:  the abstractions are mostly fancy function application operators
02:36:37 <mm_freak_> functor:  (a -> b) -> (f a -> f b)
02:36:46 <mm_freak_> applicative:  f (a -> b) -> (f a -> f b)
02:36:50 <mm_freak_> monad:  (a -> f b) -> (f a -> f b)
02:36:54 <mm_freak_> comonad:  (f a -> b) -> (f a -> f b)
02:36:58 <mm_freak_> etc.
02:37:31 <jle`> interesting
02:38:13 <jle`> more is starting to make sense.
02:40:10 <jle`> i guess i have a better answer to my original question...i heard "context-free parser combinators don't really ever need monads" and i thought no way, there has to be something.  because i only knew about their Functor properties, but not their applicative ones, and I knew there were things that you needed to do that Functor couldn't do.  (:) <$> alpha <*> (many alphaNum) would be one good example
02:40:31 <jle`> i just couldn't think off-hand of that 'in-between'
02:40:32 <yitz> mm_freak_: can you expand "etc."?
02:40:38 <jle`> something that is too much for a Functor
02:40:45 <jle`> but something that does not require Monad
02:40:49 <mm_freak_> yitz: not really…  i think the list ends there
02:40:59 <yitz> heh. ok.
02:41:28 <jle`> say. when do you ever even need monads
02:41:30 <jle`> and bind
02:41:32 <jle`> for parser combinators anyway
02:42:11 <mm_freak_> jle`: here is a way to parse CSV files with a header field:  first you parse the header and derive a list of parsers for the fields from the header
02:42:23 <mm_freak_> header :: Parser [Parser Field]
02:42:30 <jle`> oh
02:42:43 <jle`> you can't applicativize that?
02:42:50 <jle`> i guess you could say...monads provide control flow/branching?
02:42:57 <mm_freak_> then the CSV parser is:  header >>= many . sequence
02:42:58 <jle`> and that's really all they offer?
02:43:11 <mm_freak_> that's impossible in applicative style
02:43:47 <mm_freak_> monads allow the future computation to depend on an outcome
02:43:56 <jle`> hm.
02:44:02 <jle`> i guess that's kinda powerful
02:44:04 <jle`> and useful
02:44:06 <jle`> i guess.
02:44:06 <mm_freak_> c >>= f, note that f is a regular function
02:44:41 <enthropy> csv may be a bad example since you could parse rows as something like [Either String Double]
02:44:43 <mm_freak_> it could return anything from 'return ()' to launching the missiles based on the outcome of c
02:44:57 <enthropy> then disambiguate/error out on bad fields after the fact
02:44:59 <jle`> arbitrary branching
02:45:07 <jle`> ?
02:45:18 <jle`> you can't do that with applicative?
02:45:21 <jle`> let me sit down for a sec and try.
02:45:28 <enthropy> hmm, I guess you need Alternative
02:45:40 <mm_freak_> enthropy: you can't, because you need the header information to tell whether the field is correct
02:46:06 <mm_freak_> choosing between 'pure x' and 'empty' based on an earlier outcome is also monadic =)
02:46:09 <jle`> how about a parser that, if the string begins with "0x", parse the rest as a hexadecimal, and if it does not, parse the rest as a decimal
02:46:10 <mm_freak_> i.e. non-applicative
02:46:13 <haasn> jle`: consider the applicative instance for IO vs the monad instance for it
02:46:20 <haasn> jle`: the applicative instance can *only* combine results
02:46:24 <haasn> but the effects are always executed
02:46:37 <haasn> the monad instance can choose which effects to compute next, based on the outcome of the previous
02:46:39 <jle`> i never even thought about IO as an applicative.
02:46:52 <jle`> like i said earlier my mind only had Functor and Monad
02:46:55 <haasn> join :: IO (IO a) -> IO a
02:47:00 <jle`> the inbetween didn't exist for me until now.
02:47:02 <haasn> liftA2 (,) :: IO a -> IO b -> IO (a,b)
02:47:17 <mm_freak_> jle`: here is an non-applicative IO action:  getLine >>= putStrLn
02:47:30 <mm_freak_> putStrLn :: String -> IO ()
02:47:41 <mm_freak_> it's a family of IO actions indexed by String
02:47:54 <mm_freak_> which action you execute you select by passing it a String
02:47:59 * hackagebot hlint 1.8.54 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.54 (NeilMitchell)
02:48:06 <yitz> enthropy: yes Alternative is somewhere between Applicative and Monad.
02:48:27 <mm_freak_> Alternative branches in a different direction
02:48:34 <jle`> hm
02:49:02 <mm_freak_> Functor → Applicative → Monad;  Applicative ↓ Alternative
02:49:04 <haasn> Where does Arrow fit into the hierarchy? I have it in my head that it's equivalent to applicative but I also know that something like getLine >>> putLine can make sense in an arrow context
02:49:06 <enthropy> deciding how many columns to expect is the Monad thing but you can make do with Alternative
02:49:09 <haasn> without requiring monadicity
02:49:25 <jle`> so any time one of your things is a function that generates an instance, instead of just an instance itself, you need Monad
02:49:25 <mm_freak_> haasn: Arrow sits between Applicative and Monad
02:49:41 <mm_freak_> Arrow is almost equivalent to Category+Applicative
02:50:00 <mm_freak_> (completely equivalent if you disregard the laws)
02:50:07 <yitz> enthropy: you could do what you want if the number of header fields is fixed: write 2^n different cases and combine them with <|>.
02:50:33 <jle`> can i do something like parse either "0x123" or "123" with only applicative?
02:50:41 <mm_freak_> jle`: yes
02:51:19 <mm_freak_> jle`: you can have as many (<|>) trials as you want, even infinitely many
02:51:31 <jle`> hm so that wouldn't be a good example.
02:51:36 <enthropy> yitz: seems like that would be slower than a Monad parser... but maybe there are more chances to optimize the version you describe
02:51:45 <mm_freak_> so you can parse context-sensitive grammars using an applicative parser
02:51:53 <jle`> how about "b: 254", where b is the base
02:52:06 <jle`> which can be any positive integer
02:52:07 <mm_freak_> jle`: even that you can parse
02:52:18 <jle`> oh you make a lazy list and try all possible b's
02:52:32 <mm_freak_> we say "applicative parser", but we should really say "applicative+alternative parser" =)
02:52:56 <mm_freak_> the Alternative makes it vastly more powerful
02:53:00 * hackagebot idris 0.9.10 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.10 (EdwinBrady)
02:53:06 <jle`> alternative is just an applicative monoid?
02:53:47 <mm_freak_> yeah, in a sense
02:53:52 <jle`> hm.
02:53:59 <jle`> if you can just try out an infinite list of possibilities
02:54:03 <jle`> given a way to generate this list
02:54:09 <jle`> then can't you do your CSV header thing that way too?
02:54:14 <mm_freak_> no
02:54:18 <jle`> enumerate all possible header combinations
02:54:30 <jle`> with the appropriate parser from each one following it
02:54:33 <jle`> and then try all of them
02:54:44 <mm_freak_> well, actually yes
02:54:47 <mm_freak_> you could
02:55:00 <yitz> enthropy: another thing you could do would be to parse the header, parse the lines as Either String Double, and then fmap a function that checks that the types match up and returns a Maybe
02:55:46 <yitz> enthropy: all of those things are in reality just partially re-implementing the monad aspect
02:56:09 <jle`> oh i just said what yitz said six minutes ago
02:56:14 <jle`> i wasn't even reading what you wrote, my apologies.
02:56:20 <yitz> jle`: np :)
02:56:24 <jle`> maybe i would have avoided repeating the exact same thing
02:56:30 <jle`> but to my credit, my case was more general
02:56:37 <jle`> to arbitrary header lengths :)
02:56:42 <jle`> i will take a cookie now.
02:57:06 <yitz> @jle`snack
02:57:06 <lambdabot> Unknown command, try @list
02:57:09 <jle`> *unknown header lengths
02:57:14 <jle`> s/arbitrary/unknown
02:57:22 <jle`> okay so
02:57:25 <jle`> is there anything then
02:57:28 <jle`> that Applicative can't do?
02:57:32 <jle`> parser wise
02:59:20 <jle`> and what is fundamentally different about parsers and IO that we can't do the same <|> trick
02:59:42 <jle`> is IO not an alternative
03:00:02 <jle`> did i just destroy monads.
03:00:06 <yitz> jle`: IO is not an alternative
03:00:33 <yitz> jle`: you can't backtrack, erase the fact that you did IO, and try it a different way.
03:01:12 <jle`> that might be implementation-specific.
03:01:54 <yitz> launchMissiles <|> negotiateTreaty
03:02:54 <jle`> hm okay.
03:03:05 <jle`> so is there anything we can do with a monad that we can't do with an Alternative?
03:04:32 <Cale> jle`: join
03:05:09 <Cale> (or of course (>>=), but that's less obvious)
03:05:12 <Cale> :t join
03:05:13 <lambdabot> Monad m => m (m a) -> m a
03:05:21 <Cale> ^^ join reduces the number of m's involved
03:05:27 <Cale> :t (<*>)
03:05:27 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:05:31 <Cale> :t (<|>)
03:05:32 <lambdabot> Alternative f => f a -> f a -> f a
03:05:35 <Cale> :t pure
03:05:36 <lambdabot> Applicative f => a -> f a
03:05:54 <Cale> These all increase the number of occurrences of the functor, or leave it the same.
03:06:22 <jle`> but when is this necessary in the context of, say, a parser?
03:06:39 <jle`> useful yes
03:06:52 <jle`> necessary?
03:07:28 <Cale> Well, it lets you do some parsing in order to determine which parser to apply to the remainder of the input.
03:07:59 <jle`> Cale: we talked about this earlier, but you can just enumerate all possible branches of parse determinations
03:08:04 <jle`> and then <|> them all
03:08:31 <Cale> Can you? What if there are infinitely many?
03:08:57 <jle`> you can enumerate infinitely
03:09:19 <jle`> we have lazy lists :)
03:09:49 <jle`> if you cannot generate an enumeration to cover the entire space of possible parse branches then this won't work
03:09:56 <jle`> but i can't imagine a case where you would not be able to
03:10:29 <jle`> this is isomorphic to the set of rationals being countable i feel
03:10:40 <Cale> You're certainly going to incur an exponentially larger cost to parse in that way though.
03:11:05 <jle`> because your parse branch determinations all branch finitely
03:11:06 <Cale> Consider the case where you parse an integer, and then that many lines of the input.
03:11:54 <Cale> Though, I suppose you might be able to be a bit more clever about how you combined the sub-parsers with <|>
03:12:10 <jle`> (is this what category theory is, guys)
03:12:14 <Cale> no
03:12:15 <jle`> (am i a mathemtician yet)
03:12:15 <syrioforel> *no it isn't*
03:12:17 <jle`> darn
03:12:34 <syrioforel> haskell uses barely any category theory
03:12:36 <syrioforel> to be honest
03:12:39 <ion> jle: I only skimmed over the discussion, but here’s another simple example of where you *need* Monad for parsing: a format with a number that specifies how many characters long the following field is. field :: Parser String; field = do { n <- number; replicateM n char }. The important part is that a monadic action (other than return) is doing something with the result of an earlier monadic action.
03:13:00 <jle`> ion: i think this is similar to Cale's example
03:13:11 <donri> hmm http://www.tom-ridge.com/2011-12-01_verified_parsing.html ?
03:13:23 <Cale> ion: The idea is that you take a disjunction of many parsers which parse one specific integer followed by a field of that length.
03:13:30 <jle`> i feel like the space of all branches is enumerable though.
03:13:45 <syrioforel> the space of all programs is enumerable
03:14:01 <ion> Ah, i only now reached that far in the discussion. Indeed. :-)
03:15:19 <jle`> you have (<:> (char '1') <*> (count 1 p)) <|> (<:> char '2' <*> (count 2 p)) <|> ...
03:16:41 <Cale> Not quite sure how to parse that expression, but you'll also want to parse a delimiter of some kind after the number
03:16:57 <jle`> which is foldl (<|>) (map (\n -> (<:> char (head $ show n) <*> (count n p))) [1..])
03:17:04 <Cale> what is <:>?
03:17:08 <jle`> er, sorry
03:17:10 <jle`> it's (:)
03:17:18 <Cale> errr
03:17:24 <jle`> did i mess up my applicativeness
03:17:33 <jle`> (:) <$> char '1' <*> (count 1 p)
03:18:14 <syrioforel> that's certainly very inefficient though, yeah?
03:18:17 <Cale> I don't think that works as it is
03:18:23 <Cale> and yeah, it's inefficient like that
03:18:38 <Cale> But you can do it for each digit, and then branch out into a new disjunction
03:18:49 <Cale> and accumulate a number that way
03:20:02 <syrioforel> you could enumerate over all possible inputs though
03:20:20 <syrioforel> kind of trivial that that's *possible*
03:20:21 <jle`> i would not know how to enuerate something where, if it's a number, parse the next n "blocks", where a block is defined as either a normal line or a number followed by that many blocks
03:21:07 <jle`> like 3 a 2 3 c c c b a a
03:21:13 <jle`> where the letter is the depth of the block
03:21:46 <syrioforel> could enumerate all possible block sequences
03:21:48 <jle`> i don't think you can enumerate something like that with infinite depth
03:21:53 <jle`> because blocks can be infinitely deep
03:22:00 <syrioforel> they can be arbitrarily deep
03:22:01 <jle`> *nest infinitely deep
03:22:02 <syrioforel> but not infinitely
03:22:04 <syrioforel> yes?
03:22:11 <syrioforel> infinite input is probably something you don't want to handle
03:22:16 <jle`> oh yeah.
03:22:24 <syrioforel> and if you are only handling finite input
03:22:30 <syrioforel> then the input space is countable
03:22:37 <haasn> monochrom: oh, right; Arrow can be sequenced due to Category, which Applicative can't
03:22:44 <jle`> so you would do something breadth first-ish
03:22:49 <syrioforel> yeah
03:23:05 <syrioforel> or however you like (though breadth first is the usual way you'd prove that that's a countable set)
03:23:19 <jle`> okay
03:23:22 <syrioforel> that's some severe cheating though ;D
03:23:39 <syrioforel> like writing a program by just going "here are all possible inputs and outputs"
03:23:40 <jle`> anyways i guess my point was that it's definitely inconvenient, but...it still has the same 'power' as a monad does
03:23:44 <jle`> oh haha
03:23:45 <syrioforel> not very inspiring
03:23:53 <jle`> syrioforel: i see that analogy
03:24:22 <jle`> i guess it kind of defeats the purpose of programming in the first place.
03:24:25 <jle`> maybe.
03:24:27 <jle`> ?
03:24:29 <syrioforel> in a sense
03:24:35 <syrioforel> monads are useful though
03:25:14 <jle`> useful yes
03:25:29 <jle`> i am still waiting to be convinced that they are more powerful
03:25:37 <jle`> but it is late.
03:25:39 <syrioforel> you need a good definition of powerful
03:25:41 <syrioforel> i mean
03:25:42 <syrioforel> they just bury
03:25:46 <syrioforel> plumbing work
03:25:49 <syrioforel> for the most part
03:26:00 <syrioforel> you could write out all the steps explicitly and do everything just fine
03:26:08 <jle`> i mean that the set of things computable by monads is greater than the things computable by alternative
03:26:16 <jle`> like...
03:26:21 <jle`> afaik, monads ar emore powerful than functors
03:26:27 <jle`> you can only get so far with fmap
03:26:30 <syrioforel> well monads are functors
03:26:39 <syrioforel> but yeah
03:26:44 <jle`> you need more than just fmap for lots of things
03:26:53 <jle`> applicative is more powerful than functor
03:26:54 <syrioforel> certainly
03:26:56 <jle`> i guess i mean 'just functor'
03:27:14 <jle`> alternative more powerful than applicative, it seems
03:27:16 <jle`> but monad?
03:27:16 <syrioforel> functors are largely useless without natural maps anyway so that's to be expected to an extent
03:27:25 <jle`> does monad expand the set of computable things at all?
03:27:48 <jle`> on top of alternative
03:27:48 <syrioforel> depends how much you're restricting yourself right
03:27:50 <syrioforel> since you can just
03:27:55 <syrioforel> choose not to use any of it at all
03:28:15 <jle`> er
03:28:19 <jle`> not sure what you mean
03:28:26 <syrioforel> I mean, say, for parser
03:28:32 <syrioforel> you can just unpack every function that parser has
03:28:40 <syrioforel> and write all your functions with tuples and annoying argument passing
03:28:59 <syrioforel> so in what way are you restricting the operations you can do with applicative/monad/functor/etc. such that this is not possible
03:29:59 <jle`> well a rephrasing would be how does adding bind or join change what you can parse
03:30:10 <jle`> does it open doors to new things you can parse that you couldn't before?
03:30:33 <syrioforel> it makes it easier to parse certain things at the very least, right
03:30:36 <jle`> assuming you are working with an applicative-style parser using combinators
03:30:38 <jle`> yeah it's easier
03:31:05 <jle`> but again easier/more efficient is not what i am concerned aobout
03:31:19 <jle`> or well..what i am curious about.
03:31:30 <syrioforel> then the question you have is probably more mathematical
03:31:46 <syrioforel> in which case if it's a well-defined question has some category-theoretic statemetn
03:32:05 <syrioforel> statement* but that's hard to see
03:32:08 <ziman> jle`, yes, it does. With applicative/alternative, you cannot branch on the result of parsing in the sense of "parseInt >>= \n -> if n > 100 then parseA else parseB".
03:32:16 <ReinH> jle`: monad : context-sensitive :: applicative : context-free
03:32:34 <jle`> ziman: not sure if you have been following this, but the solution was to enumerate all possible branches
03:32:41 <jle`> and <|> all of them
03:33:19 <ziman> hmm, then this is not a good example
03:33:19 <jle`> in your example there is only one binary branch
03:33:29 <jle`> yeah i have been strugging to find a 'good' example myself.
03:33:33 <syrioforel> ziman: problem is you can do this *no matter what*
03:33:44 <ReinH> jle`:  so yes, you can parse things with a monad that you can't parse with an applicative: context-sensitive things.
03:33:53 <jle`> ReinH: for example?
03:34:04 <syrioforel> if you're allowing this enumeration thing
03:34:13 <jle`> (and i'm talking about Alternatives, not Applicatives, strictly)
03:34:25 <syrioforel> you can just enumerate all possible inputs programmatically, build a parser that only recognizes that one input, then <|> everything
03:34:34 <syrioforel> super cheating mode
03:34:43 <ziman> what about "parseInt >>= \n -> replicateM n parseItem"?
03:34:57 <ziman> n being an Integer
03:35:10 <ReinH> jle`: monads let you change future computations based on the results of previous computations
03:35:37 <ReinH> jle`: for reference, http://research.microsoft.com/en-us/um/people/daan/download/papers/parsec-paper.pdf
03:35:56 <jle`> ziman: i am pretty sure that is enumerable
03:36:01 <syrioforel> ziman: I think this got mentioned earlier with the mighty copout of <|>-ing together all parse 1 >> parseItem <|> (parse 2 >> parseItem >> parseItem) <|> ...
03:36:03 <jle`> with some map over [1..]
03:36:09 <syrioforel> forgive my rampant abuse of probably bad notation
03:36:34 <syrioforel> jle`: yeah thing is still that the set of all finite strings is countable :\
03:36:41 * ziman should probably read the backlog
03:36:54 <jle`> backlog is kind of longwinded so you probably would not benefit much
03:37:32 <ReinH> jle`: for instance, I can write a monadic parser that parses something (like a BNF grammar) and, based on that result,  decides how to parse something else
03:38:19 <ReinH> on the other hand, it's impossible to perform compile-time optimizations on a parser that doesn't exist at compile time
03:38:33 <ReinH> so applicative parsers sometimes have advantages for the languages they can parse
03:39:03 <jle`> ReinH: is the set of a BNF grammar expression enumerable?
03:39:16 <jle`> if so then you can just enumerate over all of them, with the appropriate decision for the post-parser
03:39:19 <jle`> and <|> them all
03:39:49 <jle`> haskell has no problem folding <|> over infinite lists
03:39:59 <syrioforel> jle`: though there's a snag there, you'd need code to produce the results of those parsers!
03:40:04 <syrioforel> that's effectively writing the parser
03:40:30 <jle`> well
03:40:36 <ReinH> jle`: how would you know the enumeration at compile-time?
03:40:43 <ziman> jle`, i like your idea!
03:40:45 <ReinH> for a BNF grammar you don't know at compile-time?
03:40:50 <ReinH> hint: you can't
03:40:54 <jle`> oh
03:40:56 <ziman> ReinH, you can enumerate all bnf grammars
03:40:58 <jle`> you mean parse the grammar sepcification
03:41:03 <ReinH> ziman: can you?
03:41:09 <ReinH> jle`: yes
03:41:15 <ziman> of course you can
03:41:18 <jle`> description
03:41:28 <syrioforel> you can enumerate... basically everything you can feed as input to a program
03:41:39 <ziman> basically everything in computer science is enumerable
03:41:53 <ReinH> uh.
03:41:56 <jle`> i mean if anything you can enumerate the ASCII codes that the grammar is written in
03:43:02 <ReinH> You're talking about recursively enumerable langauges, i.e. langauges for which a Turing machine can enumerate all valid strings of the language
03:43:07 <jle`> enumerate all bnf grammars specifiable in 50 bytes, 51 bytes, etc. etc.
03:43:23 <syrioforel> ReinH: beyond that, the set of finite strings is countable
03:43:35 <ReinH> syrioforel: yes, I am aware
03:43:51 <trolling> there are 44 of them
03:44:51 <syrioforel> you could enumerate all inputs and <|> together your custom-rolled parser for each, but I'd maintain that being able to do so requires actually writing the parser another way
03:45:05 <ReinH> But if you can decide whether a given string is a member of the langauge, you can solve the halting problem
03:45:15 <jle`> i feel like syrioforel's observation that any 'decision making' that monads allow can be enumerable by the very nature that their representations are enumerable at any arbitrary low enough level
03:45:16 <ReinH> So being able to enumerate all strings is not the whole answer
03:46:09 <ReinH> There's also the small practical problem of requiring infinite time and space to enumerate an infinite set
03:46:10 <jle`> but you can verify that a string is parsable as a bnf grammar
03:46:18 <jle`> well your input program is finite
03:46:27 <jle`> your input grammar
03:46:37 <jle`> the string representing it
03:48:06 <lpaste> Twey pasted “shiona_” at http://lpaste.net/96327
03:48:15 <syrioforel> jle`: this is still at the end of the day you need to compute the results that the parsers should produce
03:48:22 <ReinH> Ok, enumerate /.*/ for me.
03:48:23 <jle`> if your input strings are infinite
03:48:24 <syrioforel> since your program is finite, it has to compute those dynamically
03:48:26 <syrioforel> how does it do that
03:48:55 <Twey> shiona_: You should be able to generalize this to arbitrary state (Bool) and input (Integer) types, but it's early and my brain doesn't feel like FlexibleContext type errors right now :þ
03:49:35 <jle`> ReinH: enumerate a parser matching /.*/ ?
03:49:37 <merijn> shiona_: For what it's worth, might also want to include any errors in pastes
03:49:44 <jle`> first, all single character matches
03:49:48 <jle`> then all two character matches
03:49:56 <jle`> then all three
03:49:58 <jle`> etc.
03:50:13 <Twey> merijn: I pasted that for shiona_
03:50:16 <ReinH> jle`: That's not enumerating it.
03:50:17 <jle`> concat . map (something) [1..]
03:50:32 <merijn> Twey: ah, I haven't had enough coffee to read back enough :p
03:50:38 <shiona_> Twey: hmm, seems reasonable, but not quite as clean as I hoped
03:50:46 <Twey> It was quite a while back :þ  I went to get breakfast
03:50:50 <ReinH> [replicateM n chars | n <- [1..]]
03:50:56 <syrioforel> ReinH: is there a difference between countable and enumerable that i'm unaware of?
03:51:13 <ReinH> syrioforel: no
03:51:20 <Twey> shiona_: You could obviously make app an actual operator
03:51:40 <Twey> And even write a Num instance for Running, if that's what you're into
03:51:50 <Twey> Then it would look just like the Python
03:51:54 <jle`> well.  infinitely long bnf grammar description strings are not really of interest anyways because if you had one, Monad wouldn't help you either
03:52:02 <shiona_> hmm
03:52:05 <ziman> well, there are only countably many terminating λ-terms but there's no computable enumeration
03:52:18 <ziman> I wonder whether this could be exploited to counter jle`s idea
03:52:34 <syrioforel> a-ha
03:52:39 <syrioforel> ziman: this is a nice statement
03:53:12 <shiona_> Twey: that's actually quite neat. Just to make sure: I'm probably not going to use this, I just got curious if the type system could allow this kind of trickery
03:54:28 <jle`> syrioforel: i was thinking about what you said earlier about extracting out the result of the parse
03:54:33 <Twey> shiona_: Yeah, especially the Num instance is a terrible idea that you should never use in actual code :þ
03:54:33 <jle`> and i think you're right
03:54:40 <shiona_> :D
03:54:55 <Twey> Other than that this is pretty safe, though
03:55:00 <jle`> Twey: hey, don't Accelerate do that? :P
03:55:04 <jle`> doesn't
03:55:14 <ReinH> ziman: source?
03:55:22 <Twey> printf introduces runtime errors because it relies on a formatting string, but I think this is typesafe
03:55:27 <Twey> jle`: Do what?
03:55:31 <ziman> ReinH, what do you mean?
03:55:35 <jle`> abuse Num instances
03:55:40 <Twey> Oh, possibly
03:55:46 <Twey> λb does
03:55:52 <donri> not anymore
03:56:07 <ReinH> ziman: what's your source for "there are only countably many terminating λ-terms but there's no computable enumeration"?
03:56:08 <Twey> No?  ☹
03:56:11 <Twey> > (sin * sin) 5 + (cos * cos) 5
03:56:12 <lambdabot>   No instance for (GHC.Show.Show a0)
03:56:12 <lambdabot>    arising from a use of `M4803561543382...
03:56:14 <ziman> hmm
03:56:21 <Twey> > (sin * sin) 5 + (cos * cos) 5 :: Float
03:56:22 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Float -> GHC.Types.Float))
03:56:22 <lambdabot>    arisi...
03:56:32 <Twey> donri: How sad
03:57:13 <Twey> donri: Did you just wake up?  Can you generalize that code for me?  :þ  It's bugging me
03:57:23 <donri> what code?
03:57:34 <Twey> http://lpaste.net/96327
03:57:44 <ReinH> ziman: afaik there should be an enumeration?
03:57:52 <merijn> shiona_: This is the kinda stuff that's fine and neat if you wanna play and see how far you can push the type system, but probably is a terrible idea to do in production code :)
03:58:05 <shiona_> merijn: exactly my thoughts
03:58:10 <ziman> ReinH, the former is clear, but the latter I'm unsure about now
03:58:14 <merijn> Although weird Num instances are hilarious play tools :)
03:58:28 <merijn> shiona_: See for example the Num instance for String in acme-php :p
03:58:42 <Twey> donri: I feel like it should be possible to abstract out both the Bool and the Integer, but my head feels all morning.  :þ
03:58:51 <shiona_> :D
03:58:53 <ReinH> ziman: they are order-isomorphic to the rationals, for which there is an enuemeration
03:59:04 <merijn> shiona_: The source of this is hilarious: http://hackage.haskell.org/package/acme-php
03:59:23 <ziman> ReinH, true! now I remember
03:59:36 <shiona_> oh god
04:00:10 <ReinH> ziman: it should also be possible to enumerate them via turing-church correspondence
04:00:15 <Twey> Hahahah
04:00:16 <ziman> you actually enumerate pairs (i,n) such that the term i terminates in n steps
04:00:25 <Twey> merijn: I was just about to post exactly that
04:00:43 <merijn> Actually, everything on hackage with acme in it is hilarious :)
04:00:49 <ziman> ReinH, thanks for correcting me!
04:00:54 <ReinH> ziman: :)
04:01:58 <jle`> well i'm up muchlater than i had hope to be.
04:02:00 <jle`> thank you for entertaining my ramblings
04:02:14 <donri> Twey: i'm amazed you don't use the unicode-symbols packages ;)
04:02:25 <jle`> syrioforel left before i could thank him
04:02:26 <donri> @hackage base-unicode-symbols
04:02:26 <lambdabot> http://hackage.haskell.org/package/base-unicode-symbols
04:03:22 <ReinH> ziman: my red flag was that computable numbers are countably infinite, which means there is a bijection from them to N, which is definitely enumerable.
04:05:08 <ReinH> (There are \aleph_0 many Turing programs ;)
04:05:22 <Twey> donri: Too much user overhead
04:05:28 <donri> :)
04:05:49 <donri> Twey: anyway i'm feeling all morning too but i can't think of any way to extract the Integer that type checks...
04:05:49 <Twey> (I consider it every now and then :þ)
04:05:57 <Twey> Aw.
04:07:53 <ziman> ReinH, yes but the correspondence needn't always be computable (or is it always?)
04:10:29 <donri> Twey: base-unicode-symbols doesn't really work well with haskell's bad namespacing though... it uses EMPTY SET for both monoid mempty and alternative empty (oddly no support for monadplus?)
04:10:53 <donri> Twey: i sort of feel qualifying unicode operators defeat the purpose... :P
04:11:14 <ReinH> ziman: iinm any countable set is enumerable.
04:12:02 <Muhammad_> Imagine we have a function named Sum n = n + n
04:12:28 <Muhammad_> The lexical analyzer, specify s.t. to each of n
04:12:36 <Muhammad_> as an example n = id1
04:12:43 <Muhammad_> What about Sum
04:13:00 <Muhammad_> How GHC accomplish this task?
04:13:06 <arkeet> I didn't understand any of that.
04:13:31 <Muhammad_> We wanna compile this
04:13:37 <Muhammad_> SUM n = n + n
04:13:38 <Twey> donri: I don't think so
04:14:00 <Twey> Muhammad_: Tough, it's not syntactically valid code
04:14:24 <arkeet> please note: case is important
04:14:50 <Muhammad_> I ran it on GHCI
04:14:58 <Muhammad_> doubleMe  x = x + x
04:15:10 <donri> > case () of important -> True | otherwise -> False
04:15:11 <lambdabot>   <hint>:1:30: parse error on input `|'
04:15:22 <donri> > case () of important -> True; otherwise -> False
04:15:23 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
04:15:26 <donri> :(
04:15:32 <ion> donri: wat
04:15:36 <arkeet> > case () of important -> True
04:15:37 <lambdabot>   True
04:15:39 <Twey> wat, indeed
04:15:47 <donri> > case () of important -> True; otherwise -> False
04:15:48 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
04:15:53 <donri> > case () of { important -> True; otherwise -> False}
04:15:54 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
04:16:01 <donri> wat
04:16:01 <arkeet> overlapped pattern match error.
04:16:06 <arkeet> or warning.
04:16:11 <arkeet> oh yeah.
04:16:12 <donri> but error?
04:16:15 <arkeet> lambdabot hates it when it gives a warning.
04:16:23 <donri> the "mistake" was intentional, i thought ghc would accept it
04:16:30 <donri> okay
04:16:32 <arkeet> yes, but it spits out a warning.
04:16:38 <arkeet> and lambdabot doesn't know what to do with it.
04:16:47 <frase> hi all; any good URI/URL libraries for doing path manipulation? Network.URI doesn't offer much...
04:17:14 <ReinH> ziman: I suppose we should decide which version of "enumerable" we are using. Recursively enumerable?
04:17:16 <donri> frase: what sort of manipulation?
04:17:17 <tibell> refold, do we need any more releases from the 1.18 branch?
04:17:35 <donri> tibbe is no more? :o
04:17:42 <Twey> frase: It offers parsing of URIs; if you need to do anything with the path component you can use the usual path libraries
04:18:05 <refold> tibell: yes, cabal-install 1.18.0.3
04:18:25 <frase> donri: mainly path fragment appends, pops, substitution and normalization
04:18:28 <frase> Twey: thanks
04:19:04 <donri> mhm, fragment, that's the #part?
04:19:16 <refold> tibell: see https://github.com/haskell/cabal/issues/1582 et al
04:19:30 <frase> oh, I just meant sections of the path between the '/'s, not the #fragment ^_^
04:19:32 <donri> network gives you uriFragment :: String for that
04:19:36 <donri> oh
04:20:04 <donri> frase: well again, what sort of manipulation... you can use System.FilePath.Posix for some things, but if it's meant for web stuff there are routing libraries that may be better suited.
04:20:58 <frase> donri: thanks for pointers; routing lib would definitely be overkill so I'll just hand roll the bits I need on top of Network.URI.  cheers
04:21:27 <donri> frase: or use filepath package...
04:22:06 <lpaste> piezoid pasted “nondeterministic parser from scratch” at http://lpaste.net/96331
04:22:07 <piezoid> hi
04:22:08 <refold> tibell: I don't think we need a new Cabal release, though. the only code change since the last release was https://github.com/haskell/cabal/commit/cb0ad7a77457ef77c34ab4b6d54e2bdc5a972fa1 and I can apply it manually for the Windows HP installer.
04:22:12 <piezoid> I learned a lot about continuations doing this, but I still have some issues...
04:23:04 <piezoid> i don't know where to insert my inner monad inside the ParserT result
04:23:12 <adnap> Are there infix names for "view", "set", and "over"?
04:25:07 <ReinH> adnap: ^., .~ and %~
04:25:47 <ReinH> > (1,2) ^. _1
04:25:49 <lambdabot>   1
04:25:49 <adnap> ReinH: Thanks
04:25:56 <mreh> the price of bitcoin must be linked to the room count in here
04:26:01 <mreh> it goes up every time I come back here
04:26:07 <ReinH> > (1,2) & _1 .~ 2
04:26:08 <lambdabot>   (2,2)
04:26:22 <ziman> ReinH, yes.
04:26:46 <adnap> So many people lurk in here.
04:27:19 <mreh> I was here when barely broke 400 on a good day
04:28:05 <mreh> anyway, I wanted to revisit acid-state and happstack
04:28:31 <zomg> mreh: you oughta buy some and then just keep cycling the channel!
04:30:07 <mreh> was thinking of building a service with it, and I'm wondering what kind of limits I could get to the amount of data stored in virtual memory
04:30:26 <mreh> sort of use the OS as my caching mechanisim
04:30:39 <mreh> obviously not really a haskell question...
04:31:40 <donri> from what i understand, it doesn't really work out well to rely on virtual memory with ghc
04:32:00 <mreh> okay
04:32:01 <donri> uh wrong term
04:32:10 <ReinH> ziman: all recursively enumerable sets have cardinality of at most |N|, so all r.e. sets are countable. Not all countably infinite sets are r.e.
04:32:33 <donri> well paging is implemented using virtual memory, but yeah...
04:33:11 <ReinH> ziman: a fun property of r.e. sets is that there are infinite sets which are r.e. but which have subsets which are not r.e.
04:33:26 <mreh> donri: right
04:33:36 <tibell> refold, ok
04:33:53 <mreh> I was hoping haskell could give me a scalable RAM DB for free
04:33:57 <ReinH> In fact, almost every subset of an infinite r.e. set  will not be r.e.
04:33:58 <donri> mreh: acid-state is great for small-enough stuff, there's nothing wrong in using it together with something else for larger datasets
04:34:29 <tibell> refold, I will try to make a cabal-install release tonight then
04:34:59 <mreh> donri: what would you suggest? most of the computation I could do on a single machine, so I would just need the storage system to be scalable
04:35:38 <donri> mreh: really depends on what you're doing
04:35:53 <refold> tibell: ok. I think you can just use the current state of the 1.18 branch.
04:36:18 <donri> mreh: https://news.ycombinator.com/item?id=6796666
04:36:56 <tibell> refold, yeah
04:37:13 <tibell> refold, then I'd like to not make any more 1.18 releases (and not commit patches to the branch), if possible
04:38:11 <refold> tibell: yes, should be possible.
04:39:14 <ziman> ReinH, could you give an example? :)
04:39:20 <donri> mreh: basically i think if you don't know if your data will fit in RAM, it probably will
04:39:33 * earthy nods
04:40:01 <earthy> I *know* my data will at one point no longer fit in RAM. I'm still designing as though it will, as I'll rarely be looking at all the data in one go
04:40:03 <mreh> how much ram can you attach to a machine theses days?
04:40:10 <earthy> 128G is not that much
04:40:13 <earthy> (RAM)
04:41:09 <mreh> earthy: so you can transparently have some of the data sitting on disk?
04:41:31 <earthy> mreh: well, I'm simply delaying the problem
04:41:32 <donri> mreh: btw acid-state doesn't have sharding yet, but you can deploy separate states on multiple machines, you just don't get atomic transactions across states
04:42:10 <earthy> if I *do* get those amounts of data, I'm in a better position than I am now, and have the budget to deal with it ;)
04:42:32 <donri> earthy: well we're discussing acid-state here, where usually you do have all data in memory at once. at least for each "state"
04:42:40 <donri> yeah
04:42:45 <earthy> donri: yeah, I know. :)
04:42:58 <donri> quote from that hackernews link above: "Because RAM tends to get bigger exponentially, while how many customers you have will probably grow linearly or maybe fuster, but not much. So your data could fit into memory, now, or in future."
04:42:58 <mreh> sharding would be ideal
04:43:11 <earthy> donri: exactly.
04:43:12 <mreh> I see your point
04:43:20 <earthy> I've projected up for data though
04:43:31 <earthy> max total dataset is on the order of some 40TiB
04:43:48 <earthy> (that's when I get *all* potential customers to be actual customers)
04:43:51 <mreh> earthy: what OS are you using?
04:43:56 <earthy> currently, windows
04:44:05 <mreh> 64 bit?
04:44:09 * earthy nods
04:44:21 <earthy> however, currently I'm looking at datasets for a single customer
04:44:47 <earthy> those will fit witnin a few G for the next 4 to 5 years.
04:45:14 <mreh> earthy: physical hardware?
04:45:16 <earthy> and I'll rarely look at data for more than one customer at once.
04:45:23 <earthy> mreh: depends on the customer. :)
04:45:46 <mreh> cloud is too expensive for RAM I suspect
04:45:53 <frx> > (1,2) & both +~ 10
04:45:54 <lambdabot>   (11,12)
04:46:13 <earthy> oh, and I simply serialize the in-mem structures for persistence.
04:46:20 <earthy> and reload
04:47:02 <tdammers> I don't think exponential or linear growth accurately model how a company acquires customers
04:47:36 <donri> tdammers: true. simplification :)
04:48:30 <tdammers> I'd expect something like linear in the very early stages, then approximately exponential for a while, until the market is saturated, at which point it'll shallow off until it becomes constant
04:48:49 <tdammers> the interesting part that may throw the calculation off is the 'hot' phase in which it is exponential
04:49:52 <tdammers> and of course, rapid linear growth can be faster than exponential for a while, until you hit break-even
04:54:03 <earthy> tdammers: all true
04:54:41 <mreh> I can still serialise haskell data structures with safecopy and use some other shardable DMS though
04:55:03 <mreh> DBMS
04:55:22 <mreh> at least I hope
05:00:01 <vektor> got a weird dependency I need to resolve. so a set of functions operating mainly on one data structure (Statistics) sometimes need to call a function not known at the time of writing Statistics. So I decide to inject it into statistics as a data field - Statistics now has one additional data field called myFunc. All I know about myFunc is it's type signature. Now, I realized myFunc might...
05:00:03 <vektor> ...have some kind of semi-persistent state involved. So I want to store that as well in Statistics. But I can't because I have at the time of writing this not the slightest clue how State might look like.
05:01:32 <vektor> so my myFunc has a type Signature of Input -> State -> (Output, State) . But I need to store State in my Statistics without knowing a thing about what it is.
05:01:39 <ReinH> ziman: |P(N)| = |R|, so there are uncountably many subsets of |N|. There are only countably many r.e. subsets of |N|
05:01:42 <vektor> how would I do that?
05:03:16 * hackagebot unix-time 0.2.2 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.2.2 (KazuYamamoto)
05:08:14 <ziman> ReinH, I was rather asking about non-c.e. subsets of c.e. supersets (or I did not get the gist of your answer)
05:08:58 <ziman> oh, I did not even get the original statement; now I understand
05:10:16 <ziman> ReinH, I thought you said that there is a c.e. U and non-c.e. V, such that V ⊆ U
05:14:03 <ReinH> ziman: yes, I did
05:15:16 <ReinH> for all countably infinite c.e., almost every subset will not be c.e.
05:16:39 <ReinH> there are uncountably many subsets of U and only countably many are c.e.
05:17:09 <Bor0> how would one solve a problem like conway's game of life, which requires a matrix in haskell? a list of lists?
05:17:10 <ReinH> it's one of those weird counter-intuitive results for infinite sets
05:17:22 <ReinH> Bor0: sure
05:17:26 <ReinH> or an array
05:17:53 <Bor0> so list of lists is not a bad practice, it is common, right?
05:18:16 <ziman> ReinH, so that wasn't meant as an example, I see.
05:18:49 <k00mi> Bor0: list of lists, especially for something like game of life, is horrible performance-wise
05:19:10 <ReinH> Bor0: lists are a commonly used data structure, but not very performant
05:19:17 <Bor0> what data structure should I use? I've solved this problem in C/Python long time ago, but in Haskell it's totally different
05:19:36 <ReinH> Bor0: for performance? A quadtree.
05:20:09 <k00mi> a set of pairs is a nice simple solution
05:20:25 <ReinH> for something reasonably performant but simple? Data.Vector or Data.Array.
05:20:51 <ReinH> or Data.Map
05:20:53 <Bor0> ok, great. I'll play around with this, thanks guys
05:21:47 <ReinH> Anything that behaves like Int -> Int -> Bool will do
05:23:11 <ReinH> ziman: I'm not even sure what we're talking about any more :p
05:23:16 <vektor> any ideas anyone?
05:27:33 <yitz> vektor: can't you just make that a type parameter?
05:27:49 <jmcarthur> vektor: either make it a type parameter or make it an existential type
05:28:22 <ziman> ReinH, tl;dr not important, points taken, thanks! (I thought you were describing a specific example (U,V), while you just gave an U and an argument that almost every V is non-c.e.)
05:29:00 <jmcarthur> vektor: types of the form   data Foo input output = forall state. Foo state (input -> state -> (output, state))   show up a lot
05:29:00 <yitz> vektor: not sure about the details of your use case. if you can't make the type polymorphic somehow, then perhaps the vault package is what you are looking for.
05:29:15 <jmcarthur> vektor: there is also another way to go, which is to hide the state in some closure:
05:29:37 <jmcarthur> vektor:    newtype Foo input output = Foo (input -> (output, Foo))
05:31:16 <vektor> hmmm.
05:31:23 <vektor> sounds like I have research work to do...
05:33:23 * hackagebot stm-conduit 2.1.3 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.1.3 (ClarkGaebel)
05:33:24 <vektor> ex. types seem to be way over my head...
05:34:02 <vektor> type parameter seems doable, but I think then I could just as well outsource myFunc to be a type param... not sure though
05:34:53 <vektor> jmcarthur: how is that newtype thingy supposed to work? I don't seem to get that one.
05:35:57 <jmcarthur> vektor: let's say you want to make a Foo that takes a String and returns the same string with a counter attached to it, where the counter is a state
05:36:29 <jmcarthur> err, let's actually serialize the counter and append it to the string so the type doesn't look like the state monad...
05:36:38 <jmcarthur> so the type would be   Foo String String
05:36:56 <jmcarthur> i will present to you the existentially quantified version and the closure version
05:37:08 <jmcarthur> i'll put them in an lpaste in a couple minutes...
05:39:36 <lpaste> jmcarthur pasted “existential quantification” at http://lpaste.net/96335
05:39:47 <jmcarthur> vektor: ^^ there's the first version
05:39:58 <vektor> what kind of sorcery is that?
05:40:15 <jmcarthur> i think it's exactly what you asked for
05:40:31 <jmcarthur> vektor: there's a state in Foo whose type you don't know except in the Foo itself
05:41:19 <vektor> http://stackoverflow.com/a/5520212
05:41:28 <vektor> kinda like the first example
05:41:43 <vektor> where forall kinda even represents the upside down A.
05:42:02 <jmcarthur> that would be a universal type
05:42:52 <jmcarthur> the forall in the syntax i used is universal quantification in a weird position. the end result is existential quantification. i wouldn't really worry about the math right now, if i were you
05:43:52 <vektor> so Foo is a type
05:44:03 <vektor> or rather, foo input output is a type
05:44:09 <jmcarthur> right
05:44:37 <vektor> and my myFunc would then be addCounter?
05:44:49 <jmcarthur> no, it would be the function in the Foo
05:45:00 <jmcarthur> i mean... this is *literally* what you asked for, without any trickery
05:45:20 <jmcarthur> the function in Foo is your myFunc. the state type variable is the type of your state, and note that it has a field in Foo
05:45:42 <jmcarthur> maybe i should make this use record syntax to make it clear
05:46:43 <danil> data Foo input output = forall state. MkFoo { getState :: state, getFunc :: input -> state -> (state, output) }
05:46:46 <lpaste> jmcarthur annotated “existential quantification” with “existential quantification (record syntax)” at http://lpaste.net/96335#a96336
05:47:36 <ij> I read about functor and it has this 'should' law that says 'fmap id = id' Is that in any way verified upon making an instance of functor? Or one should check that himself upon creating one?
05:47:40 <lpaste> jmcarthur annotated “existential quantification” with “existential quantification (closure)” at http://lpaste.net/96335#a96337
05:47:59 <jmcarthur> vektor: and there's the closure version
05:48:15 <vektor> alright
05:48:23 <ReinH> ij: you need to verify it yourself
05:49:19 <ReinH> ij: but you only need to verify the id law. Any functor satisfying the id law automatically satisfies the composition law.
05:49:23 <jmcarthur> vektor: so the idea with the closure version is that instead of just returning a new state, myFunc just returns a whole new Foo
05:49:37 <jmcarthur> vektor: including, possibly, a new myFunc
05:49:42 <vektor> so I don't need the Foo type ctor for anything else, and if I know input and output ahead of time, I can fill them in right away, huh?
05:49:55 <ReinH> (if we ignore bottom)
05:50:00 <jmcarthur> i don't understand the question
05:50:18 <vektor> let's assume I know input is of type [String]
05:50:37 <vektor> I could replace every "input" with "[String]"
05:51:08 <jmcarthur> well... you could, but i don't see why you're going down this train of thought. it's not related to the problem, afaik
05:51:23 <jmcarthur> and you can do the same with the other version too
05:51:25 <vektor> just to figure out what your code does
05:51:27 <klrr_> could anyone explain how to use this? http://beta.hackage.haskell.org/api#documentation-core should i use some program like curl(1) or such? (im not familiar with how to use the hackage server api)
05:51:44 <klrr_> i need to upload some docs to a package but i dont know how
05:51:51 <jmcarthur> vektor: when you use myFunc you provide it an input, and you get the output and the *next* myFunc to use
05:52:12 <vektor> alright. That sounds like a plan.
05:52:15 <jmcarthur> vektor: and in my first version you feed myFunc an input and a state, and it will give you the output and the next state to use
05:52:30 <jmcarthur> vektor: these are equivalent in power
05:53:06 <jmcarthur> vektor: (actually, with data instead of newtype you can have other fields, so the closure version also allows you to modify the other fields of the record, but maybe i'm giving too much information)
05:53:15 <vektor> jmcarthur: the first one needs a dummy value to get started. A default state. I guess I do that by creating Foo{...} explicitly with default state?
05:53:29 <jmcarthur> vektor: both need an initial state
05:53:40 <jmcarthur> vektor: notice how in the closure version i supply it with 0 to start with
05:53:50 <ReinH> jmcarthur: something something monoid
05:53:57 <jmcarthur> vektor: also, i already supplied the state in addCount
05:53:58 <ReinH> almost as if someone had thought of this before...
05:54:01 <jmcarthur> ReinH: no
05:54:14 <jmcarthur> the state is supplied already
05:54:28 <jmcarthur> vektor: you can't supply the state from the outside anyway. you don't even know its type
05:54:29 <danil> ReinH: no, something something typed closure conversion uses existential types, though
05:54:39 <vektor> jmcarthur: I think I'm gonna go for the record stuff. Sounds good to me.
05:55:46 <jmcarthur> yeah closures and existential types have a lot in common
05:57:36 <vektor> so that data Foo record now keeps a state for me in memory, and if I want to call the function, I can grab it from Foo, and it will take care of all the state handling for me?
05:58:29 <vektor> so myFunc someFoo would hand me a function of type input -> output (or [String] -> [String] in my case)
05:59:23 <chrisdone> donri: Children of Monad - Every Time I Typecheck
05:59:41 <donri> chrisdone: i'd buy the album
05:59:49 <ReinH> heh
06:01:05 <tdammers> they'll start recording it the moment you order the album
06:02:07 <vektor> tdammers: I don't get all the monad jokes yet, but I got that one :D
06:02:31 <jmcarthur> it's a laziness joke, not a monad joke
06:03:18 <jmcarthur> vektor: it doesn't really keep track of the state for you. you still have to create the new Foo record from the resulting new state and remember to use it instead of the old one
06:03:20 <vektor> which is why I got it :D
06:03:43 <Qfwfq> I'll get it when I need it.
06:03:46 <vektor> well, ok. so it still hides the state from me. Good enough for me.
06:04:01 <vektor> Qfwfq: now laugh!
06:04:42 <jmcarthur> vektor: the closure version actually constructs the new Foo for you
06:04:53 <jmcarthur> vektor: but you still have to remember to use the new one instead of the old one
06:04:56 <klrr_> someone on a gamedev forum said FRP actually exist already in industry and is called MVVM, is that true or just a generalizide statment?
06:05:27 <vektor> good enough for me. I at least have the feeling I understand my own code if I use records :D
06:06:29 <vektor> ghci won't eat my forall without complaining. Can I annotate in the source file that I use ex. quantif.?
06:09:36 <jmcarthur> vektor: the extension is ExistentialQuantification
06:11:26 <vektor> can I put that into a .hs file? or need I use cmake or command line params or something to get ghc(i) to run that for me?
06:12:29 <danil> vektor: you put a LANGUAGE pragma at the start of your .hs file: {-# LANGUAGE ExistentialQuantification #-}
06:12:30 <vektor> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/pragmas.html maybe?
06:12:38 <danil> exatcly
06:12:47 <vektor> alright
06:13:31 <vektor> does that work with ghci?
06:14:26 <alpounet> vektor: just fire up ghci and do ":load yourfile.hs"
06:14:32 <vektor> yeah, works
06:14:38 <alpounet> or even run "ghci yourfile.hs"
06:15:09 <vektor> just failed at parsing that chars around the pragma, so mistyped
06:15:10 <danil> if you load the file into ghci it does, but if you're just typing things at the prompt you have to ":set -X[extension name here]" instead of the pragma
06:24:13 <vektor> thanks, guys. Seems to be working.
06:34:07 <skypers_> hi
06:34:18 <skypers_> why aren’t GADTs in GHC’s core?
06:35:20 <chrisdone> why should they be?
06:36:38 <piezoid> they may help to type the DSLs ?
06:37:07 <skypers_> they help us make more souple types ctor
06:40:13 <alpounet> skypers: I think it's mostly historical. And GADTs with generalized newtype deriving have a few issues. aside from that, I don't see any reason
06:41:06 <mostlyfledby> http://hastebin.com/tisucewini.hs is this the proper way to implement a doubly-linnked list? the recursive let in the last pattern seems kind of weird to me
06:41:10 <skypers_> I see alpounet
06:41:38 <skypers_> btw alpounet, delroth has been annoying me since yesterday about logging feature
06:41:47 <skypers_> have you read the talk yet?
06:42:11 <alpounet> okay, let's continue in private
06:43:07 <jmcarthur> mostlyfledby: purely functional doubly linked lists come with a lot of tradeoffs
06:43:21 <jmcarthur> mostlyfledby: for one, imagine updating an element in one
06:44:01 <mostlyfledby> I imagine.
06:44:10 <mostlyfledby> But ehh, that last step seems particularly convoluted, is there a briefer way?
06:44:42 <mostlyfledby> y = let x = ... in x; always struck me as odd.
06:44:49 <jfeltz> HLogger is deprecated in favor of hlogger, which is deprecated, wait a second :P
06:47:52 <danil> mostlyfledby: you can use y = fix (\x -> ...) instead, but it's not much briefer
06:48:34 <mostlyfledby> danil, well, it's more the general algorithm, I was thinking i might be doing something wrongly?
06:48:48 <mostlyfledby> It seems kind of awkward
06:51:01 <yogurt_truck> klrr_: whoever said that is absolutely clueless
06:52:08 <vernon> Hello. I am learning monads, so I wrote my own simple IO-like monad. In a do block the "binding to a name" thing doesn't work well. Could you help please? http://pastebin.com/qLJsZB0R
06:52:10 <mauke> The paste qLJsZB0R has been copied to http://lpaste.net/96338
06:53:34 <yogurt_truck> (you'd have to stretch a lot of terms way beyond absurdity to claim FRP is "just MVVM with another name")
06:54:49 <danil> vernon: your definition of >>= doesn't do what you want it to
06:56:12 <klrr_> yogurt_truck: okey
06:57:37 <vernon> danil: i suspected something was iffy with that.. I'm not sure how it should be corrected tough.
07:05:34 <derekv> emacs users, how do you have emacs configured? flymake? flycheck?
07:05:42 <derekv> ghc_mod?
07:08:04 * benj_ uses flycheck
07:08:57 <derekv> benj_: I'm looking at flycheck, trying to figure out how to get it to see the cabal sandbox packages
07:09:17 <benj_> derekv, I couldn't figure that out either
07:10:04 <derekv> benj_: I might submit a patch... I found some pull request the author rejected because he didn't like the approach
07:10:10 <Fuuzetsu> flycheck is not very mallable for projects that aren't non-straightforward
07:10:51 <Fuuzetsu> derekv: do you mean https://github.com/flycheck/flycheck/pull/205 caused by https://github.com/flycheck/flycheck/issues/182 (which I filed)
07:11:53 <derekv> Fuuzetsu: yes
07:16:36 <xenon-> any HXT users? how would I fetch all the images in the first div tag?  images <- atTag "div" >>> ???
07:18:53 <danil> vernon: you want `x >>= f` to run x with the current state to get a new state, then run f on its result with the new state.  Right now you're always running x on the empty state ("", "") and throwing away the state it returns (by pattern matching with _)
07:19:28 <ion> xenon: I’d try Text.HandsomeSoup.css
07:20:16 <xenon-> I am already too deep into using HXT for this project. I'll consider it for the next one though
07:21:28 <xenon-> I know how to fetch first img in the div tag, but I am not sure how to fetch the next one, or ideally all of them
07:22:02 <quicksilver> HXT is a great library for that kind of thing
07:22:03 <hpc> xenon-: atTag "div" fetches the first div, i assume?
07:22:16 <quicksilver> unfortunately I always have to remember how to use it each time
07:22:26 <ion> @hackage HandsomeSoup -- xenon: You… might want to check it out.
07:22:26 <lambdabot> http://hackage.haskell.org/package/HandsomeSoup -- xenon: You… might want to check it out.
07:24:17 <xenon-> hpc yes. and atTag "div" >>> atTag "img" >>> getAttrValue "src" would get the first link
07:24:59 <vernon> danil: thanks, I think I get it now.
07:26:55 <piezoid> why does people declare the function bind at toplevel to get inlined >>= ?
07:28:16 <hpc> piezoid: where is this?
07:28:35 <piezoid> https://github.com/bos/attoparsec/blob/master/Data/Attoparsec/Internal/Types.hs#L128
07:29:26 <hpc> piezoid: it's an optimization
07:30:04 <hpc> when it gets inlined, GHC's optimizer goes from seeing "bindP blahblahblah" to Parser $ \i0 a0 m0 kf ks -> runParser m i0 a0 m0 kf $ ...
07:30:05 <piezoid> yes but why not {-# INLINE (>>=) #-}
07:30:20 <danil> piezoid: which instance's >>= would that be talking about?
07:30:50 <hpc> (>>=) = bindP -- is theoretically already subject to automatic optimization, because it is such a basic definition
07:30:59 <skypers_> do you know a way to unwarning unused fields in a record?
07:31:25 <piezoid> danil:  a parser, that's why i am referring to attoparsec
07:31:32 <hpc> skypers_: one of these: -fno-warn-unused-binds    -fno-warn-unused-do-bind  -fno-warn-unused-imports  -fno-warn-unused-matches
07:31:41 <hpc> likely either matches or binds
07:31:47 <skypers_> hpc: yeah but it would apply to all of them
07:31:53 <skypers_> I’d like something specific
07:31:58 <hpc> hmm
07:32:02 <danil> piezoid: right, but writing {-# INLINE (>>=) #-} doesn't tell ghc which instance's >>= you want to inline is my point
07:32:03 <skypers_> like {-# NOWARN #-}
07:32:05 <skypers_> oh what
07:32:13 <skypers_> or whatever*
07:32:28 <hpc> piezoid: what generally happens is that specific uses of (>>=) will be obviously specializable
07:32:41 <hpc> piezoid: it will replace (>>=) with the appropriate RHS, which in this case is bindP
07:32:51 <hpc> then it sees it can be inlined and replaces bindP with the RHS
07:32:59 <piezoid> danil: oh, ok so INLINE doesn't bind to a specific instance, but to the class ?
07:33:10 <jmcarthur> you can put INLINE in type class instances
07:33:11 <hpc> then it has access to much information that can be used for optimization
07:33:41 <jmcarthur> you don't need the extra indirection
07:34:14 <piezoid> I'am amazed how attoparsec is very good at inlining, even if it's continuation based
07:34:47 <hpc> piezoid: someone just did the {-# hard work #-} to make it inlineable
07:36:29 <piezoid> i'm guessing that inlining should be done before strictness optimizations ?
07:38:24 <DanielDiaz> my travis builds are failing with "cabal: command not found". they have always worked... has something changed recently?
07:38:44 <hpc> DanielDiaz: somehow cabal is off your path
07:39:01 <hpc> make sure your travis still has that configured correctly?
07:39:16 <hpc> (most likely)
07:39:19 <DanielDiaz> hpc: I didn't change it at all... they just suddenly started throwing this error.
07:39:30 <hpc> DanielDiaz: can you run cabal manually?
07:39:33 <DanielDiaz> (the automatic builds)
07:40:05 <DanielDiaz> hpc: I'm not sure. It is something the travis server does for me each time a commit is pushed to the repo.
07:40:18 <DanielDiaz> hpc: in one of their machines
07:40:29 <hpc> when you do "which cabal", does it show up as something in ~ or /usr/bin or /bin?
07:40:50 <hpc> (on the travis box)
07:41:54 <DanielDiaz> let me find out that box...
07:41:55 <danil> Does anyone know where the (#.) and (.#) operators used in lens come from?
07:42:03 <edwardk> Data.Profunctor.Unsafe
07:44:16 <DanielDiaz> hpc: it is actually throwing the error /before/ my build script... it runs "cabal update" before my build script, and then it stops for being unable to find cabal.
07:44:54 <DanielDiaz> hpc: like this: https://travis-ci.org/Daniel-Diaz/HaTeX/builds/14661707
07:46:03 <hpc> DanielDiaz: can you get into the box and run "which cabal"?
07:46:18 <DanielDiaz> hpc: I don't know how to do that yet
07:46:38 <hpc> hmm
07:47:12 <simukis_> Why is Text recommended so far and wide if it can't handle *all* of unicode?
07:47:35 <DanielDiaz> hpc: reading the docs to figure it out..
07:47:38 <hpc> weird; it clearly happened yesterday
07:47:45 <hpc> er, not yesterdya
07:47:52 <hpc> this month
07:52:28 <DanielDiaz> hpc: it seems that specifying "language: haskell" in my yml file should make the script run in a VM with Haskell Platform.
07:52:39 <hpc> yay
07:52:40 <DanielDiaz> and I do have the line "language: haskell" in my file
07:52:55 <hpc> hmm
07:54:18 <hpc> apparently there's a #travis here you can ask
07:54:30 <hpc> so sayeth the "help" drop-down menu
07:58:54 <Kron> is haskell pattern matching script?
07:59:00 <Kron> *matching strict?
07:59:34 <hpc> Kron: better question: "does haskell pattern matching force evaluation" -- yes
07:59:58 <Kron> hmmm, is there a way to make lazily evaluated pattern matching, and is it worth it?
08:00:27 <hpc> if you match (using <thunk> notation) <1:2:3:4:5:[]> against (x:y:zs), you get <1>:<2>:<3:4:5:[]>
08:00:40 <hpc> irrefutable patterns are done with "~"
08:00:59 <hpc> > let f [] = "yep"; f _ = "nope" in f []
08:01:00 <lambdabot>   "yep"
08:01:04 <Kron> ooh, what exactly is an irrefutable pattern, and where can I learn more about thunk notation?
08:01:06 <hpc> > let f [] = "yep"; f _ = "nope" in f "nope"
08:01:07 <lambdabot>   "nope"
08:01:14 <hpc> > let f ~[] = "yep"; f _ = "nope" in f []
08:01:15 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
08:01:23 <hpc> > let f ~([]) = "yep"; f _ = "nope" in f []
08:01:24 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
08:01:31 <hpc> blargh
08:01:43 <hpc> Kron: i just made up thunk notation on the spot ;)
08:01:48 <Kron> ah
08:02:03 <Fuuzetsu> hpc: You better have formal semantics ready!
08:02:28 <hpc> Kron: http://www.haskell.org/tutorial/patterns.html
08:02:50 <xenon-> I figured it out..  imgs <- listA (atTag "img" >>> getAttrValue "src")   -< div
08:03:13 <hpc> Kron: anyhoo, one of the risks of irrefutable patterns is they can't be refuted
08:03:19 <hpc> (as in, they always successfully match)
08:03:29 <Fuuzetsu> I wish HXT didn't look as horrible. Also that it was usable for files bigger than few tens of MB
08:03:30 <hpc> > let (x:xs) = [] in "this works"
08:03:31 <lambdabot>   "this works"
08:03:42 <hpc> > let (x:xs) = [] in (x, "this doesn't")
08:03:43 <lambdabot>   (*Exception: <interactive>:3:5-15: Irrefutable pattern failed for pattern (...
08:04:04 <hpc> that kind of let-in matching does irrefutable matching, if you have ever done that before
08:04:44 <hpc> Fuuzetsu: don't tempt me to come up with a semantics
08:04:51 <hpc> hmm
08:04:58 <hpc> f undefined => undefined
08:06:20 <hpc> match(<f x y ...>) = f <x> <y> ...
08:06:36 <hpc> and i think that's it
08:07:00 <Fuuzetsu> now to blow it up to 8 pages and publish
08:07:07 <hpc> lol
08:07:46 <hpc> such a notation for thunks could actually be useful, now that i think about it
08:07:57 <hpc> <x> = "thunk that evaluates to x"
08:07:59 <Fuuzetsu> I want co-author on the paper.
08:08:02 <AVariedDeveloper> Happy Thanksgiving haskellers!
08:08:34 <hpc> it'd make how evaluation rules work a lot more "visible"
08:09:03 <hpc> Fuuzetsu: make it happen and co-author me!
08:09:11 <Fuuzetsu> pfft
08:10:17 <AVariedDeveloper> Just wondering... what is there a strict version of modifyTVar but not of writeTVar?
08:10:52 <quicksilver> because it's easy just to use $! with writeTVar ?
08:11:10 <AVariedDeveloper> That's fair enough :)
08:11:10 <quicksilver> whereas with modifyTVar you need to put the strict next to the function application so just using $! doesn't cut it?
08:11:17 <yitz> hpc: [a0,a1,a2..] = a0:<a1:<a2:..>>
08:11:22 <AVariedDeveloper> perfect, thanks
08:12:06 <ion> <a0:…>
08:12:06 <hpc> yitz: technically, <<a0>:<<a1>:<<a2>:<..>>>>
08:12:20 <yitz> hpc: you've just invented disciple
08:12:23 <ion> <<(:)> …>
08:12:47 <hpc> yitz: which is awful and should be flattened to <a0:a1:a2:..> with the understanding that the one thunk returns further thunks
08:13:02 <hpc> it's a teaching tool, not a formal analysis tool
08:13:16 <hpc> yitz: orly?
08:15:59 <Tinned_Tuna> monochrom: In the end, I gave up trying to get more specific heap profiling, used +RTS -K100M -RTS and forced a couple of my datastructures at key points. I also switched from using using Data.Text to Data.ByteString and using copy (Data.Text.copy wasn't available in my version of Data.Text) so that the large files could be GC'd -- although I still have to essentially keep the files around (in my data structure), so I don't know if 
08:16:29 <hpc> Tinned_Tuna: "so i don't know if..."
08:17:31 <Tinned_Tuna> hpc: ?
08:17:38 <hpc> your paste got cut off
08:17:46 <Tinned_Tuna> oh sorry, it wasn't a paste :-p
08:17:53 <hpc> your ramble got cut off ;)
08:17:58 <Tinned_Tuna> monochrom: hpc: ... so I don't know if I actually helped or hindered with that.
08:18:24 <Tinned_Tuna> hpc: yes, I don't know if you were about, but I was up late last night making war on the heap. The heap was winning
08:18:34 <Fuuzetsu> The heap always wins.
08:18:51 <yitz> Tinned_Tuna: sounds like you're in a heap of trouble
08:18:52 <Tinned_Tuna> Fuuzetsu: it's a painful truth
08:19:07 <Tinned_Tuna> yitz: whey! *dum-tish*
08:21:43 <yitz> Tinned_Tuna: we had that problem with one processing customer's data using one of our products. quickest fix: gave it 12 GB heap and 1 GB stack. we'll work on all the analysis later...
08:21:51 <hpc> when you are unwrapping your heap of presents under the christmas tree, remember
08:22:02 <hpc> if you take from the top of the heap it takes longer
08:22:22 <Fuuzetsu> heap jokes need to be banned
08:22:53 <Fuuzetsu> (will the burrito split open if your heap gets too large?)
08:24:55 <yitz> hpc: we could easily continue that metaphor with generational garbage collection, but i think we should take Fuuzetsu's advice.
08:26:51 <Fuuzetsu> It's not advice, it's a threat.
08:35:34 <tdammers> away zzzzz
08:41:20 <bek> hello , i'm newbe on haskell and i wonder if it is ok to use it with "gtk+" (licenced under LGPL), cause i heard that the compiler ghc make some changes (does include some part of "gtk+" when linking dynamicly) and that make ("gtk+" viral an then i must licence my code under the same licence), thanks ps (i aim to use "Gtk2Hs" as a front end).
08:42:11 <dcoutts> bek: you have to comply with the LGPL, but that's not all that hard
08:42:57 <dcoutts> in particular, it does not affect how you license your own code
08:43:00 <bek> can you explain more please
08:43:04 <dcoutts> as long as you do comply with the LGPL
08:43:50 <bek> what i want is to make my code propriatary
08:43:56 <dcoutts> that's fine
08:44:11 <dcoutts> you can do that while complying with the LGPL
08:44:25 <dcoutts> for gtk2hs Haskell lib and gtk+ C libs
08:44:29 <HectorAE> bek, it's not a big deal, you should really just read the license.
08:44:47 <HectorAE> It was designed to allow this sort of thing.
08:45:44 <dominik_info2> take 5 [1..] ==> [1,2,3,4,5]
08:46:03 <dominik_info2> > take 5 [1..] ==> [1,2,3,4,5]
08:46:04 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
08:46:04 <lambdabot>              with actual type...
08:46:35 <bek> <HectorAE> i know that LGPL allow this when linking dynamicly but my question is does ghc dynamic linking comply with the LGPL
08:46:47 <dominik_info2> @pl f4  f g x = f (g x)
08:46:48 <lambdabot> f4 = (.)
08:46:51 <robert__> in parsec what is the opposite of noneOf "\n\t" ?
08:47:01 <ParahSailin> anyOf
08:47:06 <dominik_info2> f7  f g h x = g ( h ( f x ))
08:47:09 <robert__> thanks
08:47:12 <dominik_info2> @pl f7  f g h x = g ( h ( f x ))
08:47:12 <lambdabot> f7 = flip ((.) . (.)) . flip (.)
08:47:31 <ParahSailin> attoparsec has better inClass and notInClass combinators
08:47:32 <bek> cause i learned on the net that it does not
08:47:48 <HectorAE> Well if you learned it on the net then why are you asking me?
08:48:01 <ParahSailin> i believe those actually evaluate to bit arrays
08:48:26 <robert__> is there already a white space function in parsec? anyOf " \t\n" etc
08:48:39 * hackagebot diagrams-lib 1.0.0.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.0.0.1 (BrentYorgey)
08:48:41 * hackagebot diagrams-contrib 1.0.0.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.0.0.1 (BrentYorgey)
08:48:48 <ParahSailin> isSpace might be a Char -> Bool
08:48:54 <ParahSailin> that might only be in attoparsec
08:48:56 <Clint> bek: you can email licensing@fsf.org or help@softwarefreedom.org
08:49:39 <edwardk> :t Data.Char.isSpace
08:49:40 <lambdabot> Char -> Bool
08:49:41 <robert__> there is no anyOf in parsec
08:49:54 <ParahSailin> its called inClass in parsec
08:50:07 <ParahSailin> er, scratch that
08:50:24 <bek> i'm asking you because it coud be that i didn't undersund "the post on the forum" the why it choud be , because i don't know how ghc work
08:50:43 <ParahSailin> http://hackage.haskell.org/package/parsec-3.1.0/docs/Text-ParserCombinators-Parsec-Char.html has "space" and "oneOf"
08:50:56 <ParahSailin> yeah forget anyOf, its called oneOf
08:50:56 <xenon-> hanks
08:51:01 <edwardk> http://hackage.haskell.org/package/charset includes the various unicode blocks and classes if you are just looking to categorize them for a parser
08:51:03 <xenon-> thanks*
08:51:39 <ParahSailin> edwardk, nice work
08:52:06 <HectorAE> bek, show me the URL of the forum post you read.
08:52:48 <edwardk> there is also http://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Char.html#v:space which gives you a single char that satisfies isSpace
08:52:58 <edwardk> and whiteSpace in the Token parser framework
08:53:07 <ParahSailin> yeah, just linked that
08:53:09 <edwardk> IIRC, at least, i switched to parsers a year or two ago
08:53:31 <bek> ok will be back in 5 minutes
08:53:44 <HectorAE> :|
08:54:31 <robert__> how about making white space optional?  many (oneOf " \t\n")
08:54:51 <robert__> this will require it
08:55:10 <quicksilver> many allows 0
08:55:14 <quicksilver> so that doesn't require it
08:55:15 <edwardk> robert__: i'd learn how the token parsers are used in practice. then just stick to appropriate calls to lexeme
08:55:45 <edwardk> 'many space' is 0 or more. 'some space' is 1 or more
08:56:05 <robert__> ah
08:56:16 <quicksilver> wasn't many1 the parsec name for some?
08:56:18 <ParahSailin> edwardk, what does parsers do best?
08:56:21 <quicksilver> or does parsec have a some now
08:56:26 <robert__> thanks
08:56:39 <dominik_info2> \quit
08:56:56 <edwardk> ParahSailin: supports monad transformers over your parser combinator stack, makes it easier to plug in things like layout parsing and what not
08:57:24 <ParahSailin> edwardk, so a more modern parsec?
08:57:54 <edwardk> well, its a bunch of combinators without an actual parser underneath, for that you use parsec, readp, trifecta, etc.
08:58:08 <ParahSailin> oh, i see
08:58:38 <ParahSailin> yeah i was looking for the "parse" function
08:58:40 <edwardk> but those combinators work on transformer stacks on top of the other parser types folks know how to use
08:59:04 <klrr_> im trying to upload docs to a package on hackage but it complains about the format, i tried to change the format to ustar but i cant for some reason
08:59:04 <AVariedDeveloper> Is there a way to use bang patterns inside record syntax?  can't figure it out
08:59:33 <klrr_> when i do "tar cvf --format=ustar doc.tar doc" it thinks "--format=ustar" is the name of the tarball i wanna create
08:59:49 <klrr_> how do i pass the option to tar without making it think its the tarball name?
08:59:50 <apo> klrr_: well yeah
08:59:59 <apo> klrr_: don't put --format=ustar after f?
09:00:09 <quicksilver> tar --format=ustar cvf doc.tar doc
09:00:16 <edwardk> foo Bar{ baz = !quux } = doesn't work for you?
09:00:19 <quicksilver> althoguh maybe your version of tar doesn't take that option
09:00:21 <apo> klrr_: f = "Here comes the filename!"
09:00:28 <klrr_> aa okey :P thanks!
09:01:43 <klrr_> crap, now it says hackage server says it's empty even if it's not -.-
09:02:48 <AVariedDeveloper> edwardk:  My b, had the wrong idea
09:03:50 <AVariedDeveloper> Do I need to import something?  I just get "not in scope !"  I have BangPatterns at the top of the file
09:06:18 <edwardk> :set -XBangPatterns \n  data Foo = Foo {quux :: Int} \n let test Foo { quux = !x } = x  >>> test (Foo 12)     ==> 12
09:06:53 <edwardk> "works for me"
09:07:08 <edwardk> show me the line if you can
09:10:42 <bek> hello , there is one http://comments.gmane.org/gmane.comp.lang.haskell.gtk2hs/465
09:11:47 <dcoutts> bek: Wolfgang is wrong about that
09:13:16 <dcoutts> bek: at most, if you're using static linking then you can provide your app in relinkable form as a big .o file, that can be relinked with the gtk haskell package to produce the final exe
09:13:37 <dcoutts> we did that for a proprietary app
09:13:41 * hackagebot TCache 0.11.0.0 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.11.0.0 (AlbertoCorona)
09:15:02 <bek> Ok <dcoutts> tanks
09:15:04 <dcoutts> bek: the lgpl says you're not allowed to prevent users from relinking against a modified version of the lib. It does not require that actually doing so be a practical proposition given the language + compiler being used.
09:15:48 <dcoutts> the FSF have an opinion somewhere saying that
09:18:10 <bek> so i dont need to dynamicly link as far as i'm making a big .o file and staticly link it with gtk
09:18:12 <bek> !!
09:21:25 <bek> <dcoutts> can you please explean more the point " practical proposition given the language + compiler being used."
09:21:55 <dcoutts> bek: actually changing the code and relinking may be tricky because ghc does not have a clear story on ABIs
09:22:35 <dcoutts> bek: e.g. you sell me your app, I decide to exercise my LGPL rights to relink your app with a version of the gtk Haskell package that I've modified
09:22:55 <dcoutts> bek: I may well have difficulty getting my modified package to match the required ABI
09:23:17 <dcoutts> where as in C it would be clearer about what changes would be ABI changes
09:23:37 <dcoutts> but the FSF say that's not really relevant for the LGPL interpretation,
09:24:03 <dcoutts> you as the distributor just can't prevent me from trying, it doesn't say that the tools have to make it easy
09:24:44 <dcoutts> bek: e.g. a way to prevent users from trying would be to checksum the thing and fail if it didn't match.
09:24:51 <dcoutts> that's not allowed
09:25:40 <dcoutts> in practice of course, nobody cares. The main thing is that you provide the source to the LGPL bits, or a promise to provide them (as explained in the LGPL text)
09:27:50 <bek> ok <dcoutts> thank you again for the clarifications.
09:30:06 * hackagebot hamlet 1.1.7.4 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.7.4 (MichaelSnoyman)
09:30:06 * hackagebot shakespeare 1.2.0.2 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.2.0.2 (MichaelSnoyman)
09:30:06 * hackagebot shakespeare-text 1.0.0.9 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.0.9 (MichaelSnoyman)
10:00:12 * chrisdone fidgets
10:00:54 <eyebloom> Is there a purely haskell alternative to the IGraph library?
10:02:21 <lemao> how should I free the memory allocated by mkCString considering that it is returned to a C/C++ exe (Haskell is called from C and receive a string back)?
10:02:52 <lemao> ... "receive a string back" = return a string to the caller
10:04:31 <jmcarthur> lemao: what is mkCString?
10:04:35 <chrisdone> lemao: what module is that defined in?
10:05:58 <derekv>  what do I set for -i and -package for ghc to work in cabal-sandbox
10:06:05 <skypers> @index mkCString
10:06:05 <lambdabot> bzzt
10:09:14 <derekv> nvm
10:10:01 <derekv> last week i had a project working with flymake and virthualenv and everything was fantastic and eutopian
10:10:34 <derekv> then I load it up and nothing works, so i learn all those things are out of date
10:10:38 <chrisdone> tharper: i always read your nickname like a northerner saying “the harper”
10:10:44 <tharper> LOL
10:10:57 <tharper> that is more accurate than reading th as a diagrpah
10:11:33 <derekv> so i get everything up to date and there is no way to get flycheck or flymake to work with cabal sandbox?
10:13:03 <derekv> wt?
10:13:18 <derekv> suddently it works lol.  complaining FTW
10:17:18 <geekosaur> rubber duck debugging wins again?
10:17:54 <NemesisD> have any of you haskellers played with dart or typescript?
10:18:07 <bergmark> typescript a bit
10:18:37 <NemesisD> bergmark: have you compared it with dart at all before you chose it?
10:19:16 <NemesisD> haskell is the first strongly typed language i've gotten deep into and i'm curious what is best by comparison to haskell if you have to work in js
10:19:48 <robert__> i am succesfully parsing Foo: bar  in parsec. now is there a way to get all those matches within a string that is filled with (more or less) random garbage?
10:20:54 <scott_> NemesisD: Are you familiar with Elm, Roy, or Fay?
10:20:56 <khyperia> robert__, possibly: many (Just <$> someParser <|> const Nothing <$> anyChar)
10:21:27 <khyperia> err, wait, then you have to do a filtering to go from [Maybe a] to [a]
10:22:14 <NemesisD> scott_: familiar with fay in what it does, but my toruble is that i'm looking to introduce something more maintainable than javascript at work which is not friendly to haskell (we are a ruby shop)
10:22:22 <robert__> I am not quite sure how to do that. just startes using parsec an hour ago
10:22:31 * robert__ started
10:22:38 <khyperia> catMaybes $ many (Just <$> someParser <|> const Nothing <$> anyChar)
10:22:45 <khyperia> from Data.Maybe
10:23:18 <robert__> to make it simpler, how about matching one such sequence surrounded by garbage?
10:23:31 <robert__> (I will try that)
10:23:51 <wereHamster> does aeson not define an ToJSON instance for Data.Map ?
10:24:05 <khyperia> how about: head $ catMaybes $ many (Just <$> someParser <|> const Nothing <$> anyChar)
10:24:26 <khyperia> not sure how you say "get the first match"
10:25:02 <NemesisD> listToMaybe?
10:25:20 <NemesisD> wait don't mind me
10:25:21 <khyperia> robert__, possibly: let parser = someParser <|> (anyChar *> parser) in [...]
10:25:34 <derekv> oh heck yea, cookn now
10:25:55 <jmcarthur> made a short blog post today demonstrating a naive final encoding for glob patterns. http://creativelad.wordpress.com/2013/11/28/final-encodings-part-1-a-quick-demonstration/
10:25:56 <derekv> problem is that it'll stop working later and I won't know what I did
10:28:58 <iron_houzi> To the Vim users here: ghcmod or hdevtools ?
10:29:22 <scott_> iron_houzi: I've never used ghcmod, but I'm pretty happy with hdevtools.
10:30:07 <iron_houzi> scott_: Did you install from cabal or via pathogen/vundle and github?
10:30:19 <scott_> The latter
10:30:35 <scott_> Well, I think you need to isntall hdevtools from cabal and the vim plugin from github
10:30:53 <iron_houzi> OK
10:31:14 <iron_houzi> What features do you make use of?
10:31:42 <lemao> chrisdone, jmcarthur: sorry, it is newCString from Foreign.C...
10:32:20 <jmcarthur> lemao: i think you should be able to just use free
10:32:25 <scott_> iron_houzi: Re: ghcmod vs. hdevtools, hdevtools is like a small piece of what ghcmod does (type information, general info) leaving plugins like syntastic to give errors and lints
10:33:09 <iron_houzi> OK. The common stuff, no autocompletion or anything fancy..
10:33:15 <scott_> Yeah
10:34:10 <scott_> iron_houzi: I just have these three keybindings: https://github.com/tsion/dotvim/blob/master/vimrc#L168-L170
10:34:37 <tarruda> can ghcmod be used to list exported definitions of a haskell file?
10:35:15 <tarruda> I use ghc-mod browse -d [MODULE] to see the definitions of an installed module, is there an equivalent for uncompiled files?
10:36:12 <lemao> jmcarthur: is the memory allocation the same? I am calling haskell from chrome.
10:37:42 <aranea> Hi. I've never written a program with a GUI before (because I much prefer the flexibility and usage efficiency of CLIs), but now I've got to write one (just for visualization however, no input capabilities needed). I'd prefer not to use a binding to something like GTK or wxWidgets, but a more functional approach. Does anyone have recommendations?
10:40:25 <ParahSailin> aranea, is HTML an option?
10:40:34 <jmcarthur> lemao: it is unless chrome replaces free with its own implementation or something
10:40:46 <robert__> khyperia: I could not get it working. I will paste example
10:40:54 <haasn> aranea: if you just need to visualize a function or whatever there's some stuff named uh... tv
10:40:58 <haasn> gtktv or whatever
10:41:00 <haasn> but it's in bit rot
10:41:24 <jmcarthur> lemao: if you are unsure you could always use another haskell binding to free it instead
10:42:20 <aranea> haasn: I'd prefer something which is still developed.
10:42:38 <Shapeshifter> So, I wrote an exercise for a bunch of Java students, involving interfaces and abstract classes, and now here I'm sitting, imagning how I would implement this task in Haskell, i.e. how I would have to translate the oo-design into a functional program... And I'm really having a hard time. So for example, there are different animals in a nursery. so I have a data Animal = Dog | Cat | whatever, and a data Nursery. Animals have some ...
10:42:45 <Shapeshifter> ... basic properties like how much they eat. *some* animals can be trained. In Java they implement a Trainable interface. In Haskell, I suppose I could have a class Trainable and make a instance Trainable Animal where train (Dog _ _) ... = and so on, but here there paradigms already disagree, because I would really have to implement instance Trainable Animal for *all* animals. But only some animals can be trained. How can I ...
10:42:50 <Shapeshifter> ... abstract this in Haskell?
10:43:37 <Shapeshifter> would I simply have a function train, where I pattern match for the Animals which can be trained, and return Nothing in a wildcard pattern?
10:43:43 <aranea> ParahSailin, haasn: I need to output a video (visualization of particle movement)
10:43:53 <aranea> I guess that rules out HTML
10:43:54 <haasn> aranea: gloss?
10:45:17 <aranea> haasn: sound interesting, I'll have a look. Thanks
10:45:32 <jrmithdobbs> Shapeshifter: Put that function in the class with proper constraints and trying to call train on an untrainable anjmal wont typecheck.
10:46:02 <jrmithdobbs> Shapeshifter: Why would every animal need to be in the class?
10:46:15 <jmcarthur> Shapeshifter: class Animal a where howMuchIEat :: a -> Int;  class Animal a => Trainable a where train :: a -> a; data Dog; data Cat; data Worm; instance Animal Dog where ...; instance Animal Cat where ...; instance Animal Worm where ...; instance Trainable Dog where ...; instance Trainable Cat where ...
10:48:16 <Shapeshifter> I see!
10:48:57 <jmcarthur> jrmithdobbs: i think Shapeshifter's problem was the Animal ADT
10:50:19 <robert__> can someone help me with this parsec question? to sum it up, how can I, given a simple parser that parses "option = value" text, parse that when it is surrounded by garbage text? more details and code is in here: http://lpaste.net/96351
10:52:36 <jrmithdobbs> jmcarthur: totally missed that part. But there's and extension for that too, ha., typeconstraintkinds or w/e
10:53:08 <khyperia> reading it, robert__
10:53:19 <jmcarthur> jrmithdobbs: i don't understand. you mean DataKinds? you would still have to make that a type parameter to some other type (probably a gadt) if you want usable values with those type tags though
10:53:35 <robert__> thanks
10:54:39 <khyperia> robert__, did the source I said in here not work? If not, why not?
10:55:46 <robert__> I was getting long, confusing errors. moment
10:59:21 <jrmithdobbs> jmcarthur: was thinking KindSignatures ... couldnt you use that without adding that much complexity?
10:59:35 <jmcarthur> jrmithdobbs: how would KindSignatures help?
11:02:05 <robert__> here is one of your suggestions:
11:02:12 <robert__> parse (many (Just <$> option <|> const Nothing <$> anyChar)) "" "garbage foo = 1,2,3 garbage"
11:02:32 <robert__> Left (line 1, column 9): unexpected "f" expecting space or "="
11:02:50 <khyperia> slap a "try" in front of "option", I think
11:03:17 <robert__> ah it worked
11:03:26 <robert__> great :)
11:03:49 <robert__> got a bunch of Nothing, and one match
11:03:49 <khyperia> would you like me to explain that code?
11:03:56 <robert__> sure
11:04:41 <khyperia> alright, so first off the "many" does the argument a lot, obviously. the "Just <$> try option" tries option, and if it succeeds, wraps it in a Just.
11:05:32 <khyperia> the <|> means "if the left side fails, do the right side". "const Nothing" means basically "return nothing, regardless of argument to the function", and the anyChar advances the parser by one character
11:05:56 <khyperia> and you should do catMaybes $ many ([...]) to get rid of all the Nothing s
11:06:27 <khyperia> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#v:catMaybes
11:06:39 <robert__> so Nothing is for each character it tried and failed to parse as option
11:06:45 <khyperia> yep
11:07:09 <khyperia> do you know applicative notation? Probably should have asked this first.
11:07:19 <robert__> nice, exactly what I wanted
11:07:30 <robert__> not quite
11:08:07 <robert__> actually you mean <$> ?
11:08:14 <robert__> I know it is fmap
11:08:18 <khyperia> yep
11:08:26 <lemao> jmcarthur: ok, free() seems to have worked ok. thanks.
11:08:33 <khyperia> so it runs the result of the right side through the left side function
11:08:34 <jmcarthur> yay!
11:09:31 <khyperia> and I'm not using it, but <*> means take the result of the right side through the left side function that happens to also be in the applicative
11:09:31 <robert__> What does try option do by itself?
11:09:42 <khyperia> the try option lets you backtrack
11:09:51 <khyperia> lemme pull up parsec's documentation on <|>
11:10:32 <khyperia> http://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Prim.html#v:-60--124--62- "If p fails *without consuming any input*, parser q is tried"
11:10:46 <khyperia> basically, "try" means "if the parser fails, un-consume the input"
11:11:22 <robert__> yeah, useful
11:11:41 <chrisdone> also wasteful
11:11:54 <chrisdone> try not to use it if possible
11:13:55 <robert__> I am amazed how clean and elegant parsec is compared to parsers in other languages I used, including high level languages
11:14:34 <khyperia> I'm using Syntastic for vim, I get no source errors - because "Error: ghc-mod: phase `C pre-processor' failed (exitcode = 1)". I'm guessing this is because of a #include that references something in the directory above it. Is there any way I can fix this?
11:15:26 <khyperia> (but when it actually builds, there's probably a -I in the script)
11:18:38 <Shapeshifter> So, someone on stackoverflow had a similar question, and here's an answer I don't understand. http://stackoverflow.com/questions/4260507/avoiding-namespace-pollution-in-haskell/4260957#4260957 It basically says that if there are multiple data record types which share a field name, you could instead say class getFoo a where foo :: a -> Int or something like that. But isn't this very different? I mean, I can 'update' a record type. ...
11:18:44 <Shapeshifter> ... But how can I use this class getFoo a so that different a's have different values?
11:19:51 <xenon-> are there any potential issues in using Show/Read to serialize haskell data? In my case Map String Ad  (Ad being data containing basic haskell types,
11:24:15 <Shapeshifter> nevermind, I think I got it
11:27:26 <solrize> do the haskellcast guys ever come here?
11:28:45 <solrize> or anyone know how else to contact them?  they have no contact info on their site other than twitter handles
11:28:53 <tswett> Ahoy. I'm wondering if there are any tools letting you construct Haskell functions using tactics, the way you'd prove a theorem in Coq.
11:29:59 <HectorAE> ++ if your GHCi prompt is "λλ="
11:30:35 <solrize> tswett i don't think haskell types are specific enough for tactics to mean much... there are some programs that will take a type signature and look for a function with that signature
11:31:47 <supki> solrize: yes, ReinH is often here
11:31:53 <supki> dunno about the other guy
11:32:08 <solrize> supki, thanks
11:32:11 <solrize> tswett, http://okmij.org/ftp/Haskell/types.html#de-typechecker
11:32:41 <fizruk> tswett, take a look at djinn
11:32:47 <chrizz_> @unmtl MaybeT (State s) a
11:32:48 <lambdabot> (State s) (Maybe a)
11:32:50 <fizruk> @hackage djinn
11:32:50 <lambdabot> http://hackage.haskell.org/package/djinn
11:33:01 <tswett> solrize: well, in a Coq proof session, you have a bunch of variables and a goal. By typing in commands, you can add variables, delete variables, manipulate the goal, and so on.
11:33:03 <solrize> yeah, djinn was the other one i was thinking of.  couldn't remember the name
11:33:14 <chrizz_> @unmtl StateT s Maybe a
11:33:15 <lambdabot> s -> Maybe (a, s)
11:33:21 <tswett> And at the end of it all, it gives you the function that you just defined.
11:34:37 <chrizz_> colloquially, which monad in a stack is furthest "down" and which is furthest "up"?
11:34:49 <tswett> So if I wanted to define the function "\x y -> map y x", I might type in a sequence of commands like "denote first argument by x; denote second argument by y; bring map into scope; apply map to y giving m'; apply m' to x giving m''; return m''".
11:35:02 <chrizz_> is the base monad the furthest down?
11:35:17 <fizruk> chrizz_, try StateT s IO a
11:35:18 <solrize> tswett, yeah, i've never used coq, it's high on my wanna list.  but, with coq as i understand it, the goals you can write down are complicated enough that it can take a lot of steps to prove them.  with haskell the expressible goals are simpler
11:35:31 <solrize> oops i was typing at the same time as you, just a sec
11:35:38 <fizruk> chrizz_, which you think is furthest down State or IO?
11:35:44 <chrizz_> IO
11:36:13 <chrizz_> but that's why I'm asking, it's just a colloquialism haha
11:36:16 <chrizz_> am I right?
11:36:42 * fizruk going to use a translator...
11:36:42 <solrize> tswett i guess i don't understand that example: you can certainly do something similar in haskell
11:36:56 <chrisdone> haha since implementing M-r in emacs i'm using it in haskell all the time
11:37:05 <solrize> > let m' = map y; let m'' = m' x
11:37:06 <lambdabot>   <hint>:1:31:
11:37:06 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
11:37:09 <tswett> I mean, what I'm looking for is a tool to help me write Haskell code.
11:37:28 <solrize> oh hmm, i guess there's leksah
11:37:36 <tswett> I'd like to write a complicated function, and it's complicated enough that I don't know how to write the entire expression in one shot.
11:37:37 <monochrom> chrizz_: up and down depend on perspective, and there are two valid perspectives.
11:37:53 <tswett> But if I had some tool to show me the types of little pieces of the function as I'm writing them, that would be really useful.
11:38:06 <chrizz_> monochrom: from typeclassopedia:  Intuitively, the monads become "more fundamental" the further down in the stack you get, and the effects of a given monad "have precedence" over the effects of monads further up the stack.
11:38:08 <monochrom> in fact there are 4, because you could also say inside and outside
11:38:09 <solrize> tswett there's something from fp complete that i haven't tried?
11:38:26 <solrize> i've seen emacs agda mode and it's pretty cool... maybe you mean something like that for haskell
11:38:43 <monochrom> well, see, the problem is with "intuitively". there are 4 valid intuitions.
11:38:48 <haasn> Iceland_jack: so are there any haskell jobs in iceland?
11:38:54 <solrize> tswett, https://www.fpcomplete.com/
11:40:15 <chrizz_> monochrom: okay, but what is the author's intended meaning? which monad is more fundamental and has precedence over the others?
11:40:30 <monochrom> and you have just silently switched from the public "colloquially" to the private "intuitively"
11:40:44 <monochrom> I don't know the author's intent. I haven't read it.
11:40:56 <byorgey> oops, that's sloppy writing on my part.
11:40:59 <chrizz_> monochrom: can you not tell by the context?
11:41:21 <chrizz_> monochrom: in StateT s IO a would you say IO has precedence over State, or the other way around?
11:41:23 <byorgey> what I meant is that the monds become more fundamental the further *inside* the stack you get.
11:41:48 <chrizz_> byorgey: ok! thanks :)
11:41:50 <byorgey> monochrom is right that up/down is ambiguous.  inside/outside is not.
11:42:17 <monochrom> I would say, in one perspective, yes
11:42:33 <monochrom> no no, inside-outside is the same story all over again.
11:42:53 <chrizz_> "inside" meaning "rightmost" ?
11:43:10 <monochrom> "MaybeT IO a": IO looks like inside. "IO (Maybe a)": IO looks like outside.
11:43:25 <monochrom> guess what? MaybeT IO a = IO (Maybe a). inside = outside?
11:43:42 <chrizz_> IO (Maybe a), IO looks like the only monad here to me
11:43:46 <chrizz_> no transformer
11:44:10 <solrize> @tell reinh hi reinh i wish there were video downloads for the haskellcasts.  right now the downloads are audio-only and video is flash-only, bleh
11:44:10 <lambdabot> Consider it noted.
11:45:11 <chrisdone> solrize: include some praise in your message so it doesn't sound like whining
11:46:03 <chrisdone> solrize: FYI you can use youtube-dl (get it off apt-get) to download a youtube video in mp4 format
11:46:21 <solrize> chrisdone good point, is there a way to edit one of those tells?
11:46:43 <solrize> the haskellcast videos aren't on youtube
11:46:54 <solrize> iirc
11:47:06 <chrisdone> http://www.haskellcast.com/episode/004-simon-marlow-on-parallelism-and-concurrency/
11:47:12 <chrisdone> → http://www.youtube.com/watch?v=73B1uc3xkvo
11:47:45 <solrize> oh i didn't see that.  i see a missing plugin thingie saying something about soundclud
11:47:47 <solrize> soundcloud
11:47:52 <solrize> thanks
11:48:18 <chrisdone> welcome =)
11:50:31 <ReinH> solrize: thanks :)
11:50:33 <dmilith> checking for GNU non-executable stack support... yes
11:50:34 <dmilith> Unknown vendor portbld
11:50:51 <dmilith> on configuring from source (base ghc from ports)
11:51:40 <solrize> reinh sorry about whining ;).  it looks like i don't see the youtube embed because i have adblock filtering it, but for some reason it doesn't show up on the list of blocked items
11:51:43 <chrisdone> ReinH: was listening to the haskellcast while shopping today. very interesting!
11:51:54 <ReinH> solrize: youtube also also has an HTML5 mode
11:52:10 <ReinH> the main advantages of youtube and soundcloud are that we don't have to pay for data hosting
11:52:28 <solrize> reinh archive.org would be a good place for these types of uploads and it's free too
11:52:41 <ReinH> solrize: good point
11:52:45 <ReinH> chrisdone: thanks :)
11:53:30 <solrize> i see this video works in html5 so i can watch it, which is cool... some other ones on youtube are flash-only and i have the impression they convert to flash-only once there are a certain number of views
11:53:37 <solrize> so they can put in unskippable adverts
11:54:11 * monochrom is fine with ads, but they have to be good ads, not dumb ads.
11:54:30 <ReinH> monochrom: they are almost never good
11:54:37 <solrize> i don't mind looking at ads, i just don't want the ads looking at me ;)
11:55:28 <solrize> the ads themselves aren't the bothersome issue with youtube flash.  it's the necessity of installing the darkware plugin, and the obstruction to downloading the video for later offline viewing
11:55:59 <Rembane> solrize: What about clive?
11:56:04 <solrize> what's clive?
11:56:32 <Clint> one of the many non-flash flash-video downloaders
11:57:02 <solrize> oh hmm, so i can point it at a youtube flash and it will download and convert it to a non-flash format?
11:57:03 <Rembane> And a rather nice command line tool
11:57:12 <Rembane> solrize: Just give it a URL
11:57:36 <solrize> http://www.youtube.com/watch?v=hpvlTVgeivU    was done by an acquaintance of mine some years back... it was html5 til a few months ago, then youtube converted it to flash-only.  i used to watch it all the time
11:58:00 <zomg> solrize: interesting, never thought about why they'd use flash for the videos
11:58:00 <solrize> i'd like to download it
11:58:08 <zomg> I always thought they did the opposite, converting the popular ones to html5
11:58:19 <zomg> but it actually makes sense for them to force flash on the popular ones for the ads :P
11:58:22 <solrize> zomg it seems to be the other way
11:58:33 <zomg> I think it might also depend on the type of ads you choose
11:58:45 <zomg> maybe if you don't put the one that blocks viewing it for a few seconds it won't do that
11:59:57 <yesthisisuser> i only accept Haskell-related ads
11:59:58 <solrize> the guy who uploaded that video didn't have anything to do with choosing the ads or ad type.  i asked him what had happened because i hoped he was at least getting some of the ad revenue, but he had nothing to do with it and didn't know about it
12:00:15 <solrize> it's possible that lucasfilm or queen inc. did it
12:00:24 <solirc> Anybody else got travis build errors due to missing cabal?
12:01:26 <solrize> but they never notified him or anything like that
12:02:05 <fizruk> solirc, can you point to the log?
12:02:15 <zomg> solrize: if you upload copyrighted material then the copyright holder gets to choose what happens to it
12:02:25 <solirc> fizruk: https://travis-ci.org/sol/attoparsec-parsec/builds/14672640
12:02:26 <zomg> if the material is your own, then you get to choose if you want to show ads or not
12:02:32 <zomg> and also what kind of ads
12:02:46 <solrize> zomg that song is a parody of bohemian rhapsody, done by the uploader
12:03:06 <zomg> could be it got flagged if the melody was detected by their algorithm
12:03:34 <zomg> none of my videos have any ads on them unless I choose so, or unless it gets flagged for copyright
12:04:01 * hackagebot attoparsec-parsec 0.1.1 - An Attoparsec compatibility layer for Parsec  http://hackage.haskell.org/package/attoparsec-parsec-0.1.1 (SimonHengel)
12:04:13 <solrize> i guess it's possible some algorithm flagged it, though it was up for years and had 500k+ views before it switched
12:04:39 <fizruk> solirc, hm... let me check with one of my repos
12:07:10 <fizruk> solirc, seem to be ok: https://travis-ci.org/fizruk/free-agent/builds/14672874
12:08:25 <fizruk> solirc, did you try rebuild?
12:08:44 <solirc> fizruk: yes, did not help
12:09:10 <solirc> fizruk: but @josh-k over in #travis is looking into it..
12:09:30 <fizruk> solirc, oh okay then :)
12:09:33 <nadirs> hi to all! about ads I find stackoverflow has some interesting ones
12:10:15 <nadirs> e.g. about dev tools and such
12:13:31 <solirc> fizruk: your tests are lacking :D
12:13:54 <fizruk> solirc, yeah, I now... :p
12:14:15 <fizruk> solirc, they're just not written yet
12:16:24 <solrize> reinh this interview (with simon m) is good, thanks for doing it
12:16:58 <codygman> Is there an easy way to join a tuple of strings like this: [("1","h"),("0","m"),("32","s")] -> "1h0m32s"?
12:17:40 <yitz> > concatMap (uncurry (++))  [("1","h"),("0","m"),("32","s")]
12:17:41 <lambdabot>   "1h0m32s"
12:17:48 <zomg> ^ ninja'd
12:18:15 <codygman> yitz: Whoa... awesome I'm going to have to look at that for a second.
12:18:21 <fizruk> > [("1","h"),("0","m"),("32","s")] ^.. traverse.both.traverse
12:18:22 <lambdabot>   "1h0m32s"
12:18:33 <bennofs> > view (each.each) $ [("1","h"),("0","m"),("32","s")
12:18:34 <lambdabot>   <hint>:1:51:
12:18:35 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
12:18:36 <bennofs> > view (each.each) $ [("1","h"),("0","m"),("32","s")]
12:18:37 <lambdabot>   "1h0m32s"
12:18:42 <yitz> ^ ninjalens'd
12:18:59 <solrize> wow
12:19:03 * hackagebot reactive-banana-sdl 0.1.2 - Reactive Banana bindings for SDL  http://hackage.haskell.org/package/reactive-banana-sdl-0.1.2 (JeanPhilippeMoresmau)
12:19:04 <fizruk> > [("1","h"),("0","m"),("32","s")] ^. each.each
12:19:05 * hackagebot TypeClass 0.2.0 - Typing speed game  http://hackage.haskell.org/package/TypeClass-0.2.0 (JeanPhilippeMoresmau)
12:19:06 <lambdabot>   "1h0m32s"
12:19:35 <solrize> > view each $ [("1","h"),("0","m"),("32","s")]
12:19:36 <lambdabot>   ("1032","hms")
12:20:36 <zomg> Lens: http://i.imgur.com/PkJ9UGS.jpg
12:20:36 <zomg> =)
12:21:28 <yitz> zomg: that actually kinda looks like edwardk
12:21:37 <zomg> haha =)
12:21:52 <skypers> zomg: sometimes
12:22:00 <skypers> it’s rather “Lens: I don’t wanna know.”
12:22:14 <fizruk> > [("1","h"),("0","m"),("32","s")] ^. folded.each
12:22:15 <lambdabot>   "1h0m32s"
12:22:32 <fizruk> > [("1","h"),("0","m"),("32","s")] ^. folded.both
12:22:33 <lambdabot>   "1h0m32s"
12:23:02 <fizruk> > [("1","h"),("0","m"),("32","s")] ^. traverse.both
12:23:05 <lambdabot>   "1h0m32s"
12:23:07 <ReinH> Every I see a function of the form `(f .) . g` I get all stabby
12:23:12 <haasn> > [(1,"h"),(0,"m"),(32,"s")] ^. folded.beside (to show) id
12:23:13 <lambdabot>   "1h0m32s"
12:23:16 <yitz> lens is starting to sound a little like perl. there are many, many ways to do it.
12:23:25 <haasn> ReinH: f .: g !
12:23:34 <ReinH> It's such a classic example of just running your code through `pointfree` and not thinking about whether that was a good idea
12:23:37 <ReinH> haasn: exactly
12:24:03 <ReinH> haasn: see my comment here http://stackoverflow.com/questions/20246506/in-haskell-how-can-you-multiply-a-string
12:24:04 * bennofs writes fmap f . g, without @pl
12:25:03 <ReinH> bennofs: somehow that one doesn't bother me as much
12:25:33 <yitz> ReinH: pointfree is just a game. combinator style is good; it just happens to look pointfree sometimes. (f .) . g is pointfree, not combinator style.
12:25:55 <ReinH> yitz: I think I agree with you fsvo combinator
12:27:09 <HectorAE> Recursive list comprehensions ftw
12:28:52 <haasn> ReinH: to be honest the main reason I get stabby is because of the ( )
12:29:23 <snizzo> Hello, I'm pretty new to haskell. Can I ask you what is the role of happy for haskell? I mean I used happy to compile a grammar file with happy which gave me an haskell file. What can I do with that haskell source file?
12:29:47 <ReinH> haasn: almost every time I see it it's not a conscious decision, it's copy-paste from `pointfree`
12:29:50 <ReinH> that's what bothers me
12:30:38 <ReinH> HectorAE: cartesian product is a good one :)
12:31:46 <skypers> hey
12:31:52 <yitz> snizzo: happy for Haskell is like yacc or bison for C. most of the time we use parser combinator libraries instead, like parsec or attoparsec.
12:31:53 <skypers> I need some help about program designing
12:32:07 <skypers> I few weeks ago, I came with an issue about typeclass constraint
12:32:17 <HectorAE> I'm trying to build a list of prime numbers as a list comprehension lol
12:32:35 <haasn> list comprehensions are just syntax sugar
12:32:41 <skypers> I think it was donri that stated out I don’t actually need typeclass, since then I’ve been using plain and good data
12:32:45 <yitz> snizzo: ghc uses happy mostly for historical reasons. also because it needs to parse a huge amount of text very quickly; but i'm still not sure if we would use happy now if we were to start over.
12:32:47 <HectorAE> Yes yes but it's fun
12:32:51 <haasn> they can be completely and equivalently expressed as function calls
12:32:52 <haasn> fair enough
12:33:08 <skypers> for instance I have a data called Renderable that has some functions like render
12:33:30 <skypers> I read an article on Widget in Haskell, with some functions to pass from a “specialized” version to the extended type
12:33:48 <skypers> like here I’d write a function like superObject -> Renderable
12:34:21 <skypers> I just wonder whether that way to do can limit oneself
12:35:40 <ReinH> HectorAE: you can replace `minus' in the seive of erasthenes with a `rem' check in a list comprehension but it is super inefficient
12:37:00 <HectorAE> I guess basically what I'm doing is that, yeah
12:37:46 <ReinH> > let primes = sieve [2..] where sieve (p:xs) = p : sieve [x | x <- xs, rem x p /= 0] in take 10 primes
12:37:51 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
12:37:58 <ReinH> sieve of erasthenes*
12:38:02 <ReinH> that word is silly
12:38:31 <nooodl> eratosthenes* too!
12:38:41 <nooodl> (that name is silly too)
12:38:42 <HectorAE> Hm
12:38:42 <ReinH> nooodl: I give up on spelling for today
12:39:06 <ReinH> HectorAE: can you write me a cartesian product with a list comprehension? Where cp xs = sequence xs
12:39:24 <yitz> list comprehensions are just alternative syntax for do notation. not much more concise, either. they just seem more natural in the context of containers, due to the common mathematical notation for sets.
12:39:31 <HectorAE> Whoa whoa let me take it one step at a time, ReinH.
12:40:00 <HectorAE> I'm still trying to figure out why 'sieve' is undefined
12:40:07 <skypers> yitz: it’s a bit more concise because you don’t have to right return nor guard
12:40:11 <ReinH> yitz: yep, although they'll become more like a cross between set builder notationn and LINQ if group and order are added
12:40:16 <skypers> write*
12:40:18 <skypers> gosh :D
12:40:34 <yitz> skypers: :)
12:41:21 <skypers> I discovered a nice use of applicative combinators with ctor a few days ago
12:41:24 <skypers> it’s so great!
12:41:33 <skypers> especially with IO :)
12:41:44 <yitz> ReinH: having, limit, left join, ...
12:42:22 <skypers> like data Foo = Foo String String Int… ; Foo <$> getLine <*> getLine <*> (readLn :: Int)
12:42:47 <ReinH> yitz: I am referring to http://research.microsoft.com/en-us/um/people/simonpj/papers/list-comp/ ofc
12:43:02 <HectorAE> Yep missing the package
12:43:28 <yitz> ReinH: yeah i know. i'm just being sarcastic because this direction doesn't excite me too much. maybe i'll eventually become convinced.
12:43:31 <ReinH> skypers: applicatives are quite nice for that
12:43:44 <ReinH> yitz: gotcha, yeah I'm pretty happy with the way they are now
12:44:57 <skypers> ReinH: yeah!
12:46:21 <ReinH> There's a really nice CSV package that uses that style: parseRecord r = Person <$> r !! 0 <$> r !! 1 <$> r !! 2, or for named csv: parseNamedRecord r = Person <$> r .: "first name" <*> r .: "last name" <$> r .: "age" -- where (.:) is a lookup
12:46:31 <lpaste> Magnap pasted “Spam, spam, spam, beans and spam” at http://lpaste.net/96355
12:46:39 <ReinH> er put <*> where appropriate in the first one
12:46:45 <ReinH> and the second one
12:46:50 <ReinH> I should stop writing haskell today o_O
12:47:11 <magnap> Hello, everyone. I am getting error "File or directory does not exist" when trying to run this compiled, but when doing it by hand in ghci, it works.
12:47:25 <skypers> :t (.:)
12:47:26 <lambdabot>     Not in scope: `.:'
12:47:26 <lambdabot>     Perhaps you meant one of these:
12:47:26 <lambdabot>       `.' (imported from Data.Function),
12:48:04 <ReinH> skypers: They define (.:) to lookup a value from a named column
12:48:14 <ReinH> skypers: it's more commonly defined as (.).(.) or fmap fmap fmap
12:48:24 <yesthisisuser> (.:) is defined in Data.Function.Pointless
12:48:28 <ReinH> for composing methods of 2 arguments
12:48:37 <magnap> :t fmap fmap fmap
12:48:38 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:48:53 <ReinH> > let (.:) = fmap fmap fmap in (concat .: replicate) 3 "
12:48:54 <lambdabot>   <hint>:1:55:
12:48:54 <lambdabot>      lexical error in string/character literal at end of input
12:48:56 <ReinH> er
12:49:10 <ReinH> > let (.:) = fmap fmap fmap in (concat .: replicate) 3 "Hello World! "
12:49:11 <lambdabot>   "Hello World! Hello World! Hello World! "
12:49:26 <Qfwfq> :t fmap fmap fmap
12:49:27 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:49:42 <ReinH> compare with:
12:49:43 <HectorAE> > let isDiv n l = 0 `elem` map (mod n) l
12:49:44 <lambdabot>   not an expression: `let isDiv n l = 0 `elem` map (mod n) l'
12:49:45 <ReinH> :t (.).(.)
12:49:46 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:50:14 <HectorAE> I see how it is
12:50:15 <ReinH> HectorAE: why not rem n l == 0
12:50:24 <HectorAE> :|
12:50:24 <skypers> hm
12:50:29 <ReinH> HectorAE: oh it's a list
12:50:36 <skypers> @let (.:) = fmap fmap fmap
12:50:36 <HectorAE> Read more carefully
12:50:37 <lambdabot>  .L.hs:146:13:
12:50:37 <lambdabot>      No instance for (Functor f0) arising from a use of `fmap'...
12:50:44 <ReinH> HectorAE: use better variable names
12:51:08 <skypers> @let (.:) :: (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b); (.:) = fmap fmap fmap
12:51:09 <lambdabot>  Defined.
12:51:13 <HectorAE> Sorry about that
12:51:21 <HectorAE> Oh I can use @let?
12:51:21 <Fuuzetsu> 2generic4me
12:51:24 <skypers> > (*2) .: [[1..10]]
12:51:26 <lambdabot>   [[2,4,6,8,10,12,14,16,18,20]]
12:51:31 <skypers> I see
12:52:17 <HectorAE> @let isDiv int list = 0 `elem` map (mod int) list
12:52:17 <lambdabot>  Defined.
12:52:35 <Fuuzetsu> Will .: ever make its way into the prelude?
12:52:39 <ReinH> fmap is a morphism morphism so (.:) is a morphism morphism morphism morphism morphism morphism... or something
12:52:43 <skypers> actually
12:52:51 <skypers> now I understand why .:
12:52:55 <skypers> it’s . . . !
12:53:02 <skypers> with the two last ones vertical
12:53:03 <ReinH> :)
12:53:06 <magnap> Can anyone diagnose my mysterious file-related IO problem in http://lpaste.net/96355 ? It excepts "openFile: file or directory does not exist" when run compiled, but works if done by hand in ghci.
12:53:19 <skypers> I’d make a unicode alias for that
12:53:21 <Fuuzetsu> …yes, IIRC the original author called it .: simply because it had 3 dots
12:53:23 <ReinH> skypers: what does the AST for (.).(.) look like? :)
12:53:41 <skypers> well, a Tree?
12:53:54 <skypers> a binary tree
12:53:56 <ReinH> turn .: around a bit and squint
12:54:03 <skypers> yeah
12:54:05 <skypers> a binary tree
12:54:25 <fizruk> Fuuzetsu, f .: g combines f :: c -> d with g :: a -> b -> c
12:54:42 <fizruk> Fuuzetsu, 1 argument, 1 dot, 2 arguments, 2 dots
12:54:51 <ReinH> fizruk: or that
12:54:51 <HectorAE> > let primes = [ p | p < [2..], not (isDiv p primes) ] in take 5 primes
12:54:52 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
12:54:52 <lambdabot>              w...
12:55:00 <HectorAE> wtf
12:55:24 <ReinH> HectorAE: p < [2..]
12:55:30 <ReinH> is probably not what you mean
12:55:42 <HectorAE> Um... Is there a difference?
12:55:44 <magnap> > let primes = [ p | p <- [2..], not (isDiv p primes) ] in take 5 primes
12:55:46 <Fuuzetsu> I can't be bothered to look even try to look through my IRC log to find the first .: occurrence
12:55:47 <lambdabot>   mueval-core: Time limit exceeded
12:55:49 <ReinH> ehamberg: between < and <-? Yes.
12:55:59 <ReinH> er HectorAE ^
12:56:05 <Fuuzetsu> I don't think I even have logs that old
12:56:14 <HectorAE> You made a typo!
12:56:17 <ReinH> Fuuzetsu: chrisdone to the rescue?
12:56:20 <ReinH> HectorAE: no, you did.
12:56:29 <HectorAE> Well then you made a typo correcting
12:56:38 <ReinH> HectorAE: ?
12:56:46 <HectorAE> Anyway, I don't think it works.
12:57:05 <magnap> No, he copied your bit char for char. You mean "p <- [2..]" but wrote "p < [2..]"
12:57:28 <Fuuzetsu> ReinH: maybe if ircbrowse.net didn't have such a crap search
12:57:33 <magnap> As you can see above, it works, but lambdabot doesn't have the computational power to compute it.
12:57:38 <ReinH> HectorAE: helping you isn't very fun if you're going to be so aggressive
12:57:44 <HectorAE> Sorry.
12:57:56 <magnap> Look here:
12:57:58 <magnap> > let primes = [ p | p <- [2..], not (isDiv p primes) ] in take 5 primes
12:58:01 <lambdabot>   mueval-core: Time limit exceeded
12:58:18 <Fuuzetsu> oh, ircbrowse is chrisdone's. chrisdone: the ircbrowse search is absolutely terrible
12:58:50 <HectorAE> It doesn't work because the first evaluation of isDiv keeps going and checking if for example isDiv 2 40,000,000
12:59:08 <HectorAE> Pretty sure.
13:00:14 <ReinH> HectorAE: idDiv is not a productive recursion: you have to consume the entire list before you can provide any values
13:00:19 <magnap> I don't think list comprehensions keep a running total.
13:00:25 <ReinH> HectorAE: how do you consume the entire list of primes?
13:00:29 <ReinH> *isDiv
13:00:30 <HectorAE> Right.
13:00:56 <magnap> You can't, it's infinite (as you defined it).
13:01:03 <HectorAE> I think I'll have to add a base case where it just returns False when an element is greater than n
13:01:18 * HectorAE stares into the infinite void
13:01:22 <Shapeshifter> Uhm, so this is the best I was able to do http://codepad.org/MRplFGPa but I find it really odd that I have to use different field names for each data type (dogBelly, catBelly etc). Is there a nicer way of writing this code?
13:01:26 <magnap> You could also take some number of elements.
13:01:27 <ReinH> HectorAE: what's the issue with the list comp using rem?
13:02:30 <HectorAE> Nothing
13:02:53 <ReinH> HectorAE: if you want to use your version, you can take primes while it is less than p^2
13:03:14 <magnap> Shapeshifter: You don't need the @-patters, since you aren't using the whole object at any time in the Feedable instances.
13:03:41 <Shapeshifter> magnap: Ah yes.
13:04:07 <Javran> just realized that all functions of type a -> a, with (.), forms a monoid, which is exactly Data.Monoid.Endo, correct?
13:04:12 <Shapeshifter> magnap: I need it on line 23
13:04:25 <HectorAE> Hm how do I add a condition into a map like that though
13:04:28 <magnap> Shapeshifter: Yes.
13:04:37 <ReinH> > let primes = 2 : [i | i <- [3,5..], and [rem i p > 0 | p <- takeWhile ((<=i).(^2)) primes]] in take 10 primes
13:04:38 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
13:05:08 <Shapeshifter> magnap: what I'm wondering is if there isn't a nicer abstraction for saying "every Dog, Cat and Parrot all have a belly which has a certain capacity"
13:05:15 <ReinH> HectorAE: btw this method uses trial division http://en.wikipedia.org/wiki/Trial_division
13:05:23 <Shapeshifter> magnap: instead of using record syntax with a different field name each time.
13:05:25 <magnap> Shapeshifter: with regards to the fieldnames, there really is nothing you can do.
13:05:32 <Fuuzetsu> Shapeshifter: Perhaps less separate data types and more type classes? Is there really need for data Dog, data Cat, data Parrot?
13:05:55 <ReinH> which is an effective but rather brute method ;)
13:05:58 <Fuuzetsu> What's wrong with data Dog Belly Float Float | Cat Belly | Parrot Belly?
13:05:59 <Shapeshifter> Fuuzetsu: I was hoping not, but then how can I express for example that only Dog and Parrot are Communicators?
13:06:01 <ReinH> *brute force
13:06:14 <triliyn> Shapeshifter: there's a thing called Vinyl that gives a different kind of record that I think could help here
13:06:16 <Fuuzetsu> hm
13:06:30 <Shapeshifter> Fuuzetsu: in that case, how could I update dog on line 23? with non-record types like that?
13:07:06 <ReinH> Shapeshifter: what does communicate mean?
13:07:13 <ReinH> in terms of types?
13:07:16 <Fuuzetsu> … (Dog x y z) = Dog x (y + z) z
13:07:39 <Shapeshifter> ReinH: that you can call communicate :: <Dog or Parrot> -> String -> String
13:07:59 <Shapeshifter> Fuuzetsu: well that gets tiresome when Dog gets more fields
13:08:21 <Fuuzetsu> Shapeshifter: You could use lens.
13:08:39 <ReinH> type Communicate = Animal -> String -> Maybe String; data Animal = Dog Belly Float Float Communicate | Cat Belly Communicate | ...
13:08:40 <nooodl> Javran: yup
13:08:53 <Shapeshifter> I'm thinking that maybe I'm getting something wrong about modeling "real world" scenarios in haskell in general
13:09:11 <Shapeshifter> ReinH: but not every Animal should be able to communicate, only some types
13:09:11 <magnap> BTW, can anyone diagnose my mysterious file-related IO problem in http://lpaste.net/96355 ? It excepts "openFile: file or directory does not exist" when run compiled, but works if done by hand in ghci. It's driving me crazy!
13:09:29 <Fuuzetsu> Shapeshifter: you're too hung up on ‘model real world with objects!’
13:09:30 <ReinH> or type communicate = Animal -> String -> String; data Animal = Dog Belly Float Foat (Maybe Communicate) | ...
13:09:36 <ReinH> *type Communicate
13:09:43 <Shapeshifter> ReinH: and I would like a compile time error instead of a wild card pattern or Nothing or something when calling communicate with an incomaptible type
13:10:16 <ReinH> Shapeshifter: but it isn't an incompatible type.
13:11:06 <Shapeshifter> ReinH: well right now it's not implemented. like here: http://codepad.org/MRplFGPa And that's the way I would like it to be. So now if I were to call communicate (Cat (Belly 1)) ghc complains with  No instance for (Communicator Cat) which is nice.
13:12:18 <Fuuzetsu> Shapeshifter: Out of interest, what are you going to do when you want a function that takes any animal?
13:12:26 <ReinH> Shapeshifter: right now you have 3 different types
13:12:37 <ReinH> Shapeshifter: also be sure to read http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
13:12:40 <Fuuzetsu> are you just going to model a behaviour of every function on each of the animals through typeclasses?
13:13:01 <HectorAE> @let truncateList x l = [ n | n <- l, n < x]
13:13:01 <lambdabot>  Defined.
13:13:30 <ReinH> HectorAE: that's just filter (<x)
13:13:39 <ReinH> and doesn't do what you want
13:13:43 <HectorAE> Argh
13:13:50 <ReinH> @unlet
13:13:50 <lambdabot>  Define what?
13:13:55 <ReinH> @unlet truncateList
13:13:55 <lambdabot>  Parse failed: TemplateHaskell is not enabled
13:13:58 <ReinH> ok fine
13:14:00 <dcoutts> zenzike: http://hackage.haskell.org/package/HDBC-odbc-2.3.1.1/reports/2/log, not sure why it fails when building docs but works when building normally
13:14:19 <ReinH> HectorAE: as I showed earlier, you want takeWhile
13:14:24 <HectorAE> Okay...
13:16:43 <ReinH> HectorAE: you can also just use a let binding locally
13:17:01 <ReinH> > let f = join (+) in f 2
13:17:02 <lambdabot>   4
13:17:28 <Shapeshifter> Fuuzetsu: I mean, this is just an exercise I posed for myself. Something non-algorithmic. So I assume I have an imaginary world with 3 kinds of animals. All animals eat something, but cats only eat half as much as other animals. dogs and parrots can communicate (communicating with cats shouldn't compile). dogs can be trained (training once increases their intelligence by 1). I mean, this isn't such an out-of-the-world scenario. You ...
13:17:34 <Shapeshifter> ... could also have student records or something.
13:17:47 <HectorAE> > let primes = [ p | p <- [2,3..], not (isDiv p (takeWhile (< p) primes)) ] in take 2 primes
13:17:50 <lambdabot>   mueval-core: Time limit exceeded
13:18:00 <ReinH> HectorAE: again, isDiv is not productive
13:18:13 <ReinH> hmm
13:18:22 <HectorAE> Shouldn't it be productive if I make it a finite list?
13:20:00 <ReinH> HectorAE: no elements of primes are produced
13:20:01 <Fuuzetsu> Shapeshifter: Sure but for some reason you seem to be hung up on using type classes as interfaces in other languages. What's wrong with communicate :: Animal -> Maybe String? It's not like Haskell doesn't provide tools to compose such functions elegantly. Did you read the anti-pattern blog post linked few lines up?
13:20:15 <HectorAE> Oh right
13:20:36 <ReinH> HectorAE: look at what this does:
13:20:39 <ReinH> > let primes = 2 : [i | i <- [3..], and [rem i p > 0 | p <- takeWhile ((<=i).(^2)) primes]] in take 10 primes
13:20:39 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
13:20:59 <HectorAE> > isDiv 2 []
13:21:01 <lambdabot>   False
13:21:15 <HectorAE> Why doesn't it work for that first one?...
13:21:18 <Fuuzetsu> Shapeshifter: if you want a warning from the compiler when you're missing something, just turn on -Wall and have it warn you about missing patterns on your Animal -> a functions rather than piling on type classes on top of each other
13:21:26 <ReinH> HectorAE: why doesn't what work for what?
13:21:29 <eyebloom> What is the most recent active supercompiler project for GHC?
13:21:37 <Shapeshifter> Fuuzetsu: mh, yeah that makes sense
13:22:10 <FireFly> I've heard the '<-' in list-builder notation is meant to look like ∈ (to mimic set-builder notation), but what about <- in do-notation? is that meant as a left-arrow, or also used for its similarity to ∈?
13:22:23 <Fuuzetsu> because in the end you'll end up with functions like ‘ClassA a, ClassB a, ClassC a => OneOf a Cat Dog’…
13:22:34 <ReinH> for instance, a non-communicative animal can define communicate as const Nothing
13:22:44 <ReinH> for type Communicate :: Animal -> String -> Maybe String
13:23:05 <Fuuzetsu> FireFly: I never heard that before but in do it's just an arrow.
13:23:11 <ReinH> Maybe is a totally reasonable way to model an animal's possible failure to communicate
13:23:14 <FireFly> Fuuzetsu: oh, okay
13:23:40 <HectorAE> ReinH, should I define an initial list to expand it off of perhaps?
13:24:26 <HectorAE> Sorry that I'm giving you such a hard time.
13:24:32 <ReinH> HectorAE: your version won't ever produce any primes
13:24:56 <ReinH> so takeWhile will never terminate
13:25:16 <ReinH> because in order to produce the first prime, it would have to evaluate the isDiv, which is not productive
13:25:18 <HectorAE> Oh I see, it's lacking a base case
13:25:21 <ReinH> no
13:25:32 <ReinH> you need productive recursion
13:25:34 <ReinH> isDiv is not productive
13:26:11 <HectorAE> What is productive recursion?
13:26:42 <Javran> nooodl: thanks, I think I'm on the right track of understanding monad now. Just tried to prove that monad is monoid, and now I see how the properties of `return` are used!
13:28:55 <nooodl> Javran: are you trying to understand monads as monoids in the category of endofunctors!
13:28:58 <ReinH> HectorAE: a type of corecursion that recurses on data constructors, basically. http://bentnib.org/productive.pdf
13:29:09 * hackagebot runmemo 1.0.0.1 - A simple memoization helper library  http://hackage.haskell.org/package/runmemo-1.0.0.1 (DanBurton)
13:29:19 <ReinH> HectorAE: intuitively, it means a recursion that is able to produce a single value without having to produce all values
13:29:24 <ReinH> foldr (:) is a good example
13:29:46 <HectorAE> Oh, I understand now.
13:30:34 <nooodl> (because if so i hear that's a bad idea.)
13:30:36 <HectorAE> I don't really understand how your example works though
13:30:47 <ReinH> HectorAE: the best example is probably fmap: fmap f (x:xs) = f x : fmap f xs
13:31:12 <ReinH> HectorAE: note that an f x is produced immediately and the recursion is "guarded" by a data constructor
13:31:24 <ReinH> This is why you can do
13:31:34 <ReinH> > take 10 (fmap (+1) [1..])
13:31:35 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:32:09 <Javran> nooodl: yes, exactly. So I begin with understanding Endo, despite that I think Endo and endofunctors are not the same thing. I get the idea of how to prove that something is a monoid.
13:32:29 <HectorAE> So maybe I can replace the map in isDiv with fmap to make it productive?
13:32:38 <snizzo> I've defined a BST data type here http://lpaste.net/96359 How can I put a BST type on console with ghci for testing?
13:32:49 <HectorAE> Nope, just checked, actually.
13:32:50 <ReinH> HectorAE: no, map and fmap are the same
13:32:55 <ReinH> (for lists)
13:33:01 <HectorAE> Oh okay
13:33:07 <ReinH> HectorAE: in my example, what happens when p takes on the first value?
13:33:11 <ReinH> What is primes then?
13:33:18 <ReinH> Walk through the evaluation
13:33:23 <ReinH> Then do that with yours
13:33:26 <HectorAE> 2.
13:33:26 <ReinH> I have to run
13:33:32 <ReinH> [2], actually
13:33:46 <HectorAE> Oh, yes. You then cons on the rest of the primes
13:33:48 <ReinH> You should see why mine is able to produce values while yours is not
13:33:54 <HectorAE> I get it. My first value is never defined
13:34:07 <HectorAE> Thanks, ReinH. See you around.
13:34:21 <ReinH> HectorAE: look specifically at the predicate used by takeWhile and answer the question: will there ever be a p such that the predicate is false for all primes?
13:34:38 <ReinH> because if that were so, the takeWhile would not be able to produce any values either
13:35:06 <Javran> nooodl: btw, is that endofunctor is something like applying a -> a on an [a] so that you get a result of [a] in return?
13:35:31 <HectorAE> I don't really get the predicate
13:35:48 <ReinH> Javran: that's endo*function*, a.k.a. Endo
13:35:56 <HectorAE> Dot notation hurts my brain
13:36:00 <ReinH> > ala Endo foldMap [succ, succ, succ] 1
13:36:02 <lambdabot>   4
13:36:10 <ReinH> :t [succ, succ, succ]
13:36:11 <lambdabot> Enum a => [a -> a]
13:36:31 <nooodl> http://stackoverflow.com/a/3870310/257418 explains the "monoid in the category of endofunctors" thing better than i ever could
13:36:44 <ReinH> :t (>=>)
13:36:45 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:36:49 <Javran> just got confused about Endo vs. endofunctor
13:36:49 <ReinH> :t fmap
13:36:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:36:51 <nooodl> but afaik it has not much to do with Endo at all!
13:36:52 <nooodl> yeah
13:36:58 <ReinH> Javran: compare (>=>) and fmap
13:37:21 <ReinH> and remember that these are *endo*functors and *endo*functions
13:37:36 <ReinH> so (a -> m a) -> (a -> m a) -> a -> m a
13:37:51 <ReinH> and (a -> a) -> f a -> f a
13:38:25 <Javran> so an endofunctor f should be (a -> a) -> f a -> f a?
13:38:31 <ReinH> (>=> is Kliesli composition)
13:38:55 <ReinH> nd fmap for functions is function composition
13:39:28 <ReinH> and the endofunction monoid is <(a->a)*, (.), id>
13:39:33 <ReinH> What is the endofunction monoid?
13:39:38 <ReinH> er what is the endofunctor monoid?
13:40:01 <ReinH> er, <(a->a), , id>  not (a->a)*
13:40:16 <ReinH> aaand I missed a (.), sorry I'm rushing, must run
13:42:12 <ReinH> :t (>=>)
13:42:13 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:42:15 <ReinH> :t return
13:42:15 <lambdabot> Monad m => a -> m a
13:42:25 <Javran> so i guess an endofunctor monoid is <a -> m a, (>=>), return> ?
13:42:36 <ReinH> Javran: bingo
13:42:56 <ReinH> now: Why? And what does that mean? :)
13:43:24 <Javran> and (g >=> f) x = (f x) >>= g
13:43:38 <snizzo> I've defined a BST data type here http://lpaste.net/96359 How can I put a BST type on console with ghci for testing? How can I put on console a recursive type? I'm confused :/
13:44:45 <Javran> ReinH, I guess if you are given a set of a -> m a, we can come up with some way of composing them together?
13:45:11 <ReinH> Javran: now compare this understanding to the SE answer
13:45:24 <ReinH> and ask yourself if they are the same
13:45:41 <Javran> ReinH:  SE answer?
13:45:56 <HectorAE> I love type inference
13:46:23 <ReinH> er the stackoverflow answer
13:46:27 <ReinH> so SO not SE
13:46:32 <Javran> ok
13:46:55 <ReinH> Javran: and, it means that if we are given two a -> ma we can compose them together
13:47:47 <ReinH> and if we are given a *list* [a -> m a], which is a free monoid of monads (heh) we can use foldr (>=>) return, a.k.a. mconcat
13:47:55 <ReinH> (sets are unordered)
13:48:30 <ReinH> so you'll actually see foldr (>=>) used for things like ad hoc IO pipelining
13:49:40 <Javran> ReinH: since monad is a monoid, so that's also possible to "Dual" it and get everything applied in a reversed order :)
13:50:31 <HectorAE> ReinH, so do you still want me to write the cartesian product list comprehension from earlier?
13:51:27 <ReinH> HectorAE: sure!
13:51:32 <Javran> but one last thing: (>=>) should be (a -> m a) -> (a -> m a) -> (a -> m a) isn't it?
13:52:18 <HectorAE> > [ [x*y] | x <- [2,4], y <- [3,5] ]
13:52:19 <lambdabot>   [[6],[10],[12],[20]]
13:52:26 <HectorAE> Oops nope
13:55:56 <ReinH> HectorAE: it needs to behave like sequence:
13:55:59 <Javran> is that a long story before we can get to the point where (>=>) :: (b -> m c) -> (a -> m b) -> (a -> m c) ?
13:56:06 <ReinH> > sequence [[1,2],[3,4],[5,6]]
13:56:07 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
13:56:29 <ReinH> :t (.) -- Javran
13:56:30 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:56:48 <hpc> Javran: to get a bit metaphorical, return is "monadic id"
13:56:49 <hpc> :t id
13:56:49 <lambdabot> a -> a
13:56:51 <hpc> :t return
13:56:51 <lambdabot> Monad m => a -> m a
13:56:53 <HectorAE> > [ [x*y
13:56:54 <lambdabot>   <hint>:1:7:
13:56:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
13:57:00 <HectorAE> Stupid enter key
13:57:06 <ReinH> HectorAE: there's no (*)
13:57:07 <hpc> Javran: (=<<) is "monadic ($)"
13:57:10 <hpc> :t ($)
13:57:11 <lambdabot> (a -> b) -> a -> b
13:57:13 <hpc> :t (=<<)
13:57:14 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:57:45 <lucidpaw> hello haskell friends
13:57:45 <HectorAE> Oh wait
13:57:46 <hpc> Javran: and, like ReinH says, (<=<) is the analogue of function composition
13:58:11 <HectorAE> I was going about it all wrong I thought I was actually multiplying things
13:58:33 <ReinH> :t join -- Javran
13:58:33 <lambdabot> Monad m => m (m a) -> m a
13:58:42 <Javran> hpc: can I think that they are "equivalent" in terms of monoid?
13:58:51 <ReinH> Javran: the things that you're actually combining monadically are the m's
13:58:52 <hpc> Javran: for a somewhat more "do it yourself" answer, take the definition of (<=<) and infer the type yourself
13:59:07 <ReinH> *monoidally, rather
14:00:07 <HectorAE> [ [x,y] | x <- [1,2], y <- [3,4]]
14:00:14 <HectorAE> > [ [x,y] | x <- [1,2], y <- [3,4]]
14:00:15 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
14:00:21 <HectorAE> Yes?
14:00:49 <HectorAE> That's correct, isn't it ReinH?
14:12:10 <Javran> hpc: still don't get it, if I want to infer from`g (<=<) f`, isn't that f has to be f :: a -> m a?
14:13:16 <yitz> > (,) <$> [1,2] <*> [3,4]
14:13:17 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
14:16:43 <FireFly> is >-, -<, >>- and -<< used as syntax for anything in Haskell?  I'm wondering since GHC's docs for -XUnicodeSyntax mentions Unicode alternatives for those sequences
14:17:13 <FireFly> and the other ones mentioned are all built-in syntax (::, =>, -> etc)
14:17:19 <fizruk> FireFly, Apply class?
14:17:25 <fizruk> FireFly, oh, Bind
14:17:49 * FireFly hoogles
14:18:03 <roboguy_> FireFly: doesn't Arrow use some of those?
14:18:22 <FireFly> Hm, I've only seen >>^ and stuff in Arrow, I think
14:18:40 <fizruk> http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Bind.html
14:18:59 <FireFly> Oh, hm
14:19:15 <roboguy_> FireFly: I think there's an extension to Haskell syntax for arrows that uses -<
14:19:19 <fizruk> FireFly, >>- is basically >>= there
14:19:48 <FireFly> I found it weird that they were mentioned in http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html, anyway
14:20:05 <HectorAE> What about λλ=?
14:20:06 <fizruk> roboguy_, http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
14:20:16 <fizruk> FireFly, ^
14:20:22 <roboguy_> fizruk: yeah, that's it
14:20:29 <FireFly> Oh, so that's where it's from
14:21:47 <HectorAE> Don't you just love λ?
14:21:47 <roboguy_> I've never used it but I've seen it before. actually, I'm not sure I've seen a good practical example of a non-trivial arrow
14:22:25 <FireFly> HectorAE: mm, unicode
14:24:05 <fizruk> some unicode replacements in my vim, looks like: λf g -> f ∘ g
14:24:18 <fizruk> s/^/I have /
14:24:51 <HectorAE> I wonder if you can customize Emacs haskell-mode to show lambda instead of backslash
14:27:14 * FireFly also does some unicode hackery with vim
14:27:56 <fizruk> HectorAE, http://www.haskell.org/haskellwiki/Emacs/Unicode_symbols
14:27:57 <fizruk> HectorAE, not sure that'll help though :p
14:30:34 <chrisdone> oh my emacs mode for hoogling is saucy
14:30:52 <alpounet> HectorAE: I used to have what fizruk just linked to enabled, but I don't feel I miss it at all
14:31:11 <alpounet> once you're in a big project, with tons of code all around, I'm not sure you care that much about that kind of details
14:31:31 <HectorAE> I guess.
14:31:37 <alpounet> it did however feel nice to see the code differently when I was looking at some small code samples
14:31:46 <chrisdone> you can customize emacs to show a lambda, yes
14:32:05 <chrisdone> http://www.haskell.org/haskellwiki/Emacs/Unicode_symbols
14:33:01 <chrisdone> i have it in my javascript mode, too, because reading 'function' over and over again spoils my day
14:33:12 <Javran> so let me go back a little, does endofunctor monoid = monad ?
14:33:35 <HectorAE> My haskell-mode is all messed up, it shows the help for haskell-mode-hook whenever I use M-;
14:33:38 <HectorAE> Argh
14:35:35 <Javran> or should I say that an endofunctor monoid is <a -> m b, (>=>), return> ?
14:37:18 <chrisdone> HectorAE: do you have an indentation mode configured?
14:37:33 <chrisdone> Javran: can you derive join from >=>?
14:38:48 <HectorAE> "haskell-mode-hook is a variable defined in 'haskell-mode.el'.\nIts value is (turn-on-haskell-indentation)"
14:39:34 <chrisdone> HectorAE: does the same thing happen when you hit tab?
14:40:19 <HectorAE> Yes.
14:40:27 <HectorAE> I don't know what the deal is.
14:41:13 <chrisdone> what's the deal, maaan?
14:41:21 <chrisdone> did you run
14:41:25 <chrisdone> M-x turn-on-haskell-indentation?
14:41:50 * chrisdone noms delicious sushi
14:41:58 <HectorAE> No, it appears there is no such function.
14:42:12 <chrisdone> interesting
14:42:13 * HectorAE noms delicious latkas
14:42:13 <fizruk> :t (>=> return)
14:42:14 <lambdabot> Monad m => (a -> m c) -> a -> m c
14:42:19 <fizruk> :t (>>=)
14:42:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:42:22 * mgsloan awaits delicious turkey
14:42:28 <quchen> fizruk: (>=> return) == return
14:42:30 <HectorAE> At this point I blame my distro packagers.
14:42:34 <chrisdone> HectorAE: is there any haskell-indent-*? try with C-h f to describe function
14:42:36 <Javran> chrisdone: (>=>) can be defined in terms of `join` and `fmap`, but I don't know how to do it in reverse
14:42:45 <fizruk> :t (>=> rid)
14:42:46 <lambdabot>     Not in scope: `rid'
14:42:46 <lambdabot>     Perhaps you meant one of these:
14:42:46 <lambdabot>       `id' (imported from Data.Function),
14:42:47 <fizruk> :t (>=> id)
14:42:48 <lambdabot> Monad m => (a -> m (m c)) -> a -> m c
14:42:53 <chrisdone> mgsloan: thanks giving turkey?
14:43:01 <mgsloan> chrisdone: Ayup!
14:43:06 <HectorAE> Nope, chrisdone.
14:43:30 <chrisdone> HectorAE: hm, i see. how are you loading haskell-mode in your emacs config? (require 'something)?
14:43:37 <fizruk> :t (>=> rid) . id
14:43:38 <lambdabot>     Not in scope: `rid'
14:43:38 <lambdabot>     Perhaps you meant one of these:
14:43:38 <lambdabot>       `id' (imported from Data.Function),
14:43:43 <chrisdone> mgsloan: \o/
14:43:57 <mgsloan> chrisdone: In about half an hour.  Can't wait!  In line with american tradition, I didn't eat much yet today
14:44:06 <fizruk> :t (>=> id) id
14:44:07 <lambdabot> Monad m => m (m c) -> m c
14:44:08 <mgsloan> chrisdone: Thanksgiving is somewhat of a competitive sport
14:44:10 <chrisdone> mgsloan: aha, fasting
14:44:47 <fizruk> chrisdone, Javran: join = (>=> id) id
14:45:21 <Javran> :t id >=> id
14:45:22 <lambdabot> Monad m => m (m c) -> m c
14:45:38 * fizruk goes to sleep...
14:45:46 <Javran> fine, I need some time to understand it..
14:46:20 <fizruk> Javran, f >=> g = \x -> f x >>= g
14:46:40 <fizruk> Javran, join m = m >>= id
14:46:49 <HectorAE> Yes, it appears that my distro package was at fault.
14:47:10 <chrisdone> HectorAE: the github version is best. it's got all the latest funk
14:47:10 <HectorAE> I uninstalled that and installed it locally, now it works fine
14:47:19 <fizruk> Javran, id >=> id = \m -> id m >>= id = join
14:47:22 <HectorAE> Yeah, it was an old version, buggy
14:48:12 <Javran> :t (>=>)
14:48:13 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:49:04 <HectorAE> Can't really whine about it to the packagers since they had the last _snapshot_ version
14:49:12 <HectorAE> Oh well.
14:49:27 <Javran> :t (>=>) id
14:49:28 <lambdabot> Monad m => (b -> m c) -> m b -> m c
14:50:35 <Javran> :t (>>=)
14:50:36 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:50:51 <Javran> :t flip (>>=)
14:50:52 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:51:37 <HectorAE> Yes, I got the unicode working with it as well!
14:51:58 <HectorAE> GitHub is da bomb
14:54:28 <Javran> chrisdone: sorry but I can't see how these two questions are related?
14:54:42 <chrisdone> Javran: i was just curious
15:28:27 <HectorAE> Can someone explain just what takeWhile((<=p).(^2)) means?
15:28:43 <scott_> @unpl (<=p).(^2)
15:28:43 <lambdabot> (\ e -> (e ^ 2) <= p)
15:29:27 <monochrom> does that help?
15:29:36 <HectorAE> What does @unpl mean
15:29:47 <HectorAE> Yes, it sort of helps.
15:29:50 <monochrom> it means expand to a lambda
15:30:00 <apo> unpointless
15:31:32 <HectorAE> Ah, I see. Points kind of confuse me...
15:31:33 <monochrom> takeWhile (\e -> e^2 <= 11) [2, 3, 4, 1, 1] = [2, 3]  because 4 is the first item that fails 4^2<=11. the answer keeps those before 4.
15:31:34 <HectorAE> Thanks.
15:35:42 <Javran> ReinH: ok, I finally figure out that should be "monad = endofunctor monoid = <a -> m b, (<=<), return>", instead of "a -> m b", is that true?
15:36:00 <pavonia> HectorAE: Note that the result of @unpl is the pointed version
15:36:30 <HectorAE> What? I thought that was its input
15:37:11 <pavonia> Nope, a point here isn't the (.) but the x in \x -> ...
15:37:12 <scott_> HectorAE: The terminology is a bit unobvious - "point" doesn't refer to the dot.
15:38:33 <HectorAE> Oh...
15:38:45 <HectorAE> The point is basically the function argument?
15:39:03 <scott_> Yeah, an explicitly named function argument
15:39:13 <scott_> point-less code has no explicitly named arguments
15:39:49 <HectorAE> Interesting. In that case, pointlessness confuses me.
15:39:52 <Javran> scott_: I think that's called "point-free"
15:39:59 <scott_> Javran: Same thing
15:40:21 <scott_> The @pl command is short of pointless, but it uses a package called pointfree to do its work
15:40:25 <scott_> short for*
15:40:48 <Javran> scott_: but point-free style does have points, which's a little confusing lol
15:40:52 <joelteon> does text-format have any format options? as far as I can tell it just has {}
15:40:53 <HectorAE> @pl (\ x -> 2*x == 6)
15:40:53 <lambdabot> (6 ==) . (2 *)
15:40:59 <HectorAE> Hm
15:41:15 <Javran> http://www.haskell.org/haskellwiki/Pointfree this one
15:41:25 <joelteon> or is there a library for text formatting that's somewhat more useful
15:41:26 <haasn> I think it's from λx.x <- that .
15:41:36 <scott_> Javran: Pointfree style doesn't have points ("point" doesn't refer to the (.) operator, as we said above)
15:42:09 <haasn> oh, no. the article explains it
15:44:31 <HectorAE> > let primes = 2 : [ p | p <- [3..], and [ p `rem` x > 0 | x <- takeWhile(\ x -> (x ^ 2) <= p) primes ] ] in take 15 primes
15:44:32 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
15:44:51 <HectorAE> Much faster sieve implementation than my old Scheme experiment
15:44:56 <HectorAE> And a one-liner too!
15:49:48 <xenon-> is there an elegant way of doing this without converting the list to Map and back?
15:49:51 <xenon-> > M.toList . M.fromListWith (++) . reverse $ [("one", "foo"), ("one", "bar"), ("two", "baz")]
15:49:53 <lambdabot>   [("one","foobar"),("two","baz")]
15:51:05 <alpounet> are the "one" entries supposed to be consecutive?
15:51:06 <monochrom> I would choose between these two answers. answer #1: no. answer #2: yes, stick to Map throughout.
15:51:36 <chrisdone> hoogle buffer! http://chrisdone.com/hoogle-buffer.ogv
15:51:39 <xenon-> alpounet yes
15:51:57 <scott_> chrisdone: emacs?
15:52:09 <chrisdone> scott_: emacs!
15:52:12 <scott_> :P
15:52:35 <epta> chrisdone: nice keyboard sound, what is that?
15:52:57 <chrisdone> das keyboard, cherry mx blue key switches
15:54:35 <yitz> hmm HectorAE has left. did anyone point out o'neil's paper to HectorAE?
15:54:53 <jmcarthur> <3 cherry mx blue
15:55:12 <monochrom> "das keyboard. das keyboard uber alle keyboards"
15:55:13 <donri> it's the primary reason chrisdone records screencasts
15:55:28 <monochrom> haha
15:55:32 <chrisdone> haha, yes, to exhibit the clickery =p
15:58:28 <donri> it would be killer to have a hoogle for your cabal build-depends
15:59:31 <yitz> > let combine pairs = (fst . head pairs, concatMap snd pairs) in map combine . groupBy ((==)`on`fst) . sortBy (comparing fst) $ [("one", "foo"), ("one", "bar"), ("two", "baz")]
15:59:32 <lambdabot>   Couldn't match type `a0 -> (c0, b0)' with `(a1, [b1])'
15:59:33 <lambdabot>  Expected type: [(a1...
16:00:15 <yitz> > let combine pairs = (fst $ head pairs, concatMap snd pairs) in map combine . groupBy ((==)`on`fst) . sortBy (comparing fst) $ [("one", "foo"), ("one", "bar"), ("two", "baz")]
16:00:16 <lambdabot>   [("one","foobar"),("two","baz")]
16:01:08 <yitz> xenon-: and now the lens fans will go to town writing many short and incomprehensibles version of that
16:01:19 <kvda> chrisdone: is the source for http://chrisdone.com/music available anywhere?
16:02:10 <kvda> also what OS/WM are you on in that screencast? pretty nifty
16:03:18 <xenon-> yitz :)
16:03:25 <chrisdone> kvda: it's ubuntu with xmonad and a custom panel at the top. it's not easy to setup, but it looks pretty
16:03:49 <chrisdone> kvda: the source, if you can grace it with such description, is here https://github.com/chrisdone/listens
16:04:49 <arkeet> maybe I should give xmonad another try at some point.
16:04:51 <chrisdone> i couldn't even be bothered coming up with a name for it, that's how quickly i whipped that up
16:05:20 <yitz> > let combine pairs = fst . head &&& concatMap snd in map combine . groupBy ((==)`on`fst) . sortBy (comparing fst) $ [("one", "foo"), ("one", "bar"), ("two", "baz")]
16:05:21 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
16:05:21 <lambdabot>    arising from a use ...
16:05:25 <kvda> Awesome, thanks :) I was looking at Scotty earlier but couldn't find any working sites/examples, this'll be great to learn from.
16:05:36 <yitz> > let combine = fst . head &&& concatMap snd in map combine . groupBy ((==)`on`fst) . sortBy (comparing fst) $ [("one", "foo"), ("one", "bar"), ("two", "baz")]
16:05:37 <chrisdone> kvda: cool =)
16:05:37 <kvda> chrisdone: ^
16:05:37 <lambdabot>   [("one","foobar"),("two","baz")]
16:05:47 <chrisdone> kvda: my xmonad panel also uses scotty =p
16:05:49 <xenon-> nice one
16:06:07 <kvda> chrisdone, eh?
16:06:15 <kvda> how/why? :)
16:06:16 <chrisdone> it's a webkit window that my xmonad launches, that makes requests to the scotty running in my xmonad
16:06:46 <chrisdone> and scotty uses i3status to get the stats, and font awesome for the icons
16:07:00 <chrisdone> i'm stubborn about getting exactly what i want on my desktop =p
16:07:24 <kvda> are you trying to compete with windows 8? i like your approach better for what it's worth :p
16:07:27 <arkeet> webkit for the panel, haha
16:07:28 <arkeet> :)
16:07:52 <chrisdone> kvda: hehe
16:08:39 <yitz> ssh chrisdone sh -c 'DISPLAY=:1 xmessage "SPLAT! bwahaha"'
16:09:20 <chrisdone> @quote xeyes
16:09:20 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
16:09:41 <arkeet> > let combine = fst . head &&& concatMap snd in map combine . groupBy ((==)`on`fst) . sortBy (comparing fst) $ [("one", "foo"), ("two", "baz"), ("one", "bar")]
16:09:42 <lambdabot>   [("one","foobar"),("two","baz")]
16:09:48 <arkeet> oh, you sort.
16:10:20 <arkeet> hmm
16:12:12 <arkeet> > M.toList . foldl' (M.unionWith mappend) M.empty . map (uncurry M.singleton) $ [("one", "foo"), ("two", "baz"), ("one", "bar")]
16:12:13 <lambdabot>   [("one","foobar"),("two","baz")]
16:12:18 <arkeet> :-)
16:13:29 <kvda> chrisdone, so you killed your last.fm completely?
16:13:31 <yitz> arkeet: why not just unionsWith to avoid the manual fold?
16:13:41 <arkeet> because I forgot about that. :-)
16:14:31 <chrisdone> kvda: yup. my grooveshark now submits to my own server
16:14:40 <chrisdone> http://chrisdone.com/posts/goodbye-lastfm
16:14:58 <arkeet> lambdabot needs these.
16:15:09 <arkeet> I mean the 'these' package.
16:18:19 <yitz> arkeet: fortunately, there is no package named 'it'. otherwise, we would be able to tell people to "install it" anymore.
16:18:29 <arkeet> let's fix that!
16:19:02 <donri> arkeet: the "that" package?
16:19:07 <donri> what's wrong with it
16:19:14 <donri> i mean the "that" package, not the "it" package
16:19:15 <arkeet> :-(
16:19:34 <donri> or what did you mean by it
16:19:36 <donri> i mean by "it"
16:19:51 <arkeet> I never said "it".
16:20:08 <donri> you said it!
16:21:37 <lightquake> I want to learn about free monads but I can't really think of a neat project to build with them. any ideas?
16:22:11 <chrisdone> did you read you could have invented free monads?
16:22:51 <lightquake> chrisdone: no, I don't think so
16:23:04 <lightquake> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html oh wait, yes I have
16:23:23 <alpounet> chrisdone: would you mind sharing the greasemonkey script? I might be inspired to adapt it for my own needs
16:23:34 <chrisdone> alpounet: sure, moment
16:23:38 <donri> and the followup http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
16:23:55 <donri> also good http://apfelmus.nfshost.com/articles/operational-monad.html
16:24:04 <alpounet> the cooperative threads one is good too
16:24:15 <donri> but you weren't asking for the how but the what
16:24:30 <chrisdone> https://gist.github.com/chrisdone/ced717cb886a58e0a3a9/raw/0baeeb00ac9b3e9f090799b6fe5a57acd03abc95/gistfile1.txt
16:24:50 <donri> but anyway every monad can be encoded as a free monad, except for a loss of laziness
16:25:13 <joelteon> @pl \x y -> (x `div` y, x `mod` y)
16:25:13 <lambdabot> ap (ap . ((,) .) . div) mod
16:26:12 <yitz> joelteon: and no, that's not how divMod is implemented in the Prelude.
16:26:51 <joelteon> probably for the best
16:30:38 <alpounet> chrisdone: thanks! that will save me some time
16:33:54 <yitz> lightquake: here's a nice exercise: use a free monad to implement a type that is like a list, except allows arbitrary combinations of nesting to various levels, like the list type in a typical dynamically typed language.
16:34:34 <lightquake> yitz: hmm. well, that structure reminds me of a tree
16:36:25 <yitz> lightquake: yes i guess that's just a Forest of a rose tree. well, anyway, it's an interesting recursive type, so you can do it with a free monad instead.
16:37:13 <lightquake> right. so, a NestedTree a is a list of things that are either a's or NestedTree a's
16:37:18 <lightquake> *NestedList
16:40:11 <lightquake> so... data T a = Terminal | Recursive [a], type NestedTree a = Free T a?
16:40:45 <arkeet> why Terminal?
16:40:59 <arkeet> hmm.
16:41:06 <lightquake> terminal as in there's no more recursion?
16:41:25 <arkeet> I'm not clear on the specification.
16:41:30 <arkeet> but Free already has a case for that.
16:41:56 <arkeet> for "no more recursion", I mean.
16:42:31 <lightquake> oh, Pure
16:43:41 <lightquake> so, type Nested a = Free [] a?
16:45:13 <lightquake> and you would encode, for example, [2, 3, [4]] as Free [Pure 2, Pure 3, Free [Pure 4]]
16:46:06 <arkeet> sure
16:52:11 <lightquake> I don't really understand the Monad instance that results, though
16:53:21 <derdon> is it good or bad style to declare the type of main although it should be already clear what type it is?
16:53:49 <arkeet> I always do.
16:53:51 <lightquake> derdon: i think most people declare it just because you should declare all top-level declarations
16:53:52 <geekosaur> still a good idea since all you really know about it is IO a
16:54:19 <geekosaur> you might want to decide what it should be (which, ideally, should be IO ()) so the typechecker can catch you leaking a useless value or whatever
16:55:12 <derdon> ok, thanks. I'll declare it then to make my code more clear and avoid possible mistakes
16:57:46 <yitz> for the record - i always (ok, almost always) write a type signature for top level functions, except for main.
16:59:14 <derdon> I even write type signatures for values because I fear my tutor might give us less points for not declaring things
16:59:41 <derdon> (if they're defined at top-level)
17:01:38 <tom39291_> Do hackage projects tend to follow http://semver.org/ or something similar, or is just a free-for-all, and I must keep strict constraints on dependencies?
17:02:27 <donri> @where pvp
17:02:27 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
17:03:57 <tom39291_> donri: Thanks.
17:06:35 <astropirate> moo
17:06:45 <chrisdone> astropirate: stop that!
17:07:34 <chrisdone> <yitz> for the record - i always (ok, almost always) write a type signature for top level functions, except for main.
17:07:42 <chrisdone> yitz: why bother? ghci can do that =)
17:08:23 <yitz> chrisdone: put type signatures into my haskell source files?
17:08:29 <derdon> is the command runhaskell part of ghc? Can I assume that people who have ghc installed on their computer also have the runhaskell command?
17:08:42 <chrisdone> yitz: yup
17:08:48 * arkeet tends to write the type signature before the implementation
17:08:50 <chrisdone> yitz: you're not a vim user, are you?
17:09:04 <yitz> chrisdone: heaven forbid
17:09:08 <derdon> arkeet: and if that fails, let ghci do the work for you :)
17:09:32 <arkeet> if only ghci could write the implementation for me.
17:09:36 <arkeet> fortunately, there's djinn.
17:09:37 <derdon> uncomment the signature line, open up ghci, use the :t command, get angry / frustrated about yourself
17:09:39 <derdon> rinse, repeat
17:09:42 <chrisdone> the writing down the type signature thing i did as a newbie, but i only do that now when it's something i can't figure out how to write
17:11:28 <yitz> chrisdone: there's an emacs function that inserts the type signature?
17:11:54 <chrisdone> yeah?
17:12:03 <yitz> chrisdone: and how do you convince it to write meaningful haddock comments for the function arguments?
17:12:42 <chrisdone> yitz: cabal install ghci-ai
17:14:10 <yitz> chrisdone: that works, but it always seems to inser the comment "-- ^ chrisdone told me to put this here"
17:14:56 <chrisdone> maybe your machine is too slow to run the AI
17:15:04 <yitz> that must be it
17:16:25 <chrisdone> donri: vim surely has a command to insert type sigs right?
17:16:38 <chrisdone> what kind of caveman world do you people live in?
17:17:02 <donri> chrisdone: nope. you can inspect type of ident/expr but it doesn't insert it
17:17:07 * chrisdone covers mouth with hand in shock
17:17:13 <donri> in deed
17:17:16 <Fuuzetsu> yitz: https://gist.github.com/Fuuzetsu/7700214
17:17:30 <Fuuzetsu> just make sure you load the file with C-c C-l first
17:17:50 <derdon> chrisdone: I read that as "chrisdone covers mouth with hand in sock" and was confused
17:18:15 <chrisdone> donri: http://4.bp.blogspot.com/-FHFaUhuOKHg/UKqyNGW4pZI/AAAAAAAABL8/g3vQqJh0MlQ/s1600/dsl.gif
17:18:37 <chrisdone> derdon: lol
17:18:49 <arkeet> someone should submit a patch to syntastic for that.
17:18:56 * astropirate smacks chrisdone 
17:19:06 <arkeet> or I guess maybe it could be its own thing.
17:19:11 <yitz> Fuuzetsu: nice!
17:19:14 <donri> doesn't really make sense in syntastic
17:19:19 <arkeet> right.
17:19:21 <donri> ghcmod-vim, though...
17:19:31 <donri> (or vim-hdevtools)
17:19:38 <chrisdone> yeah, that's a point -- this sounds like a job for ghc-mod/hdevtools
17:19:40 <donri> one is fast, one is maintained. \o/
17:19:41 <arkeet> yeah.
17:19:41 <chrisdone> they already have the information
17:19:45 <arkeet> :<
17:22:27 <stolaruk> Is there a better/idiomatic way to write "liftM (map f) xs" ?
17:23:21 <chrisdone> looks fine to me
17:23:21 <donri> map f <$> xs, according to some
17:23:26 <Cale> stolaruk: well, there are some alternatives, such as using fmap or <$>
17:23:42 <stolaruk> Ah interesting
17:23:51 <arkeet> usually one should use fmap instead of liftM.
17:24:09 <chrisdone> i pretty much never use liftM
17:25:05 <yitz> liftM used to be important when there were a lot of monads around that didn't have Functor instances. that's fixed now.
17:25:27 <Cale> liftM is still good for writing Functor instances in the first place sometimes.
17:25:45 <arkeet> I do that when I'm lazy.
17:26:11 <stolaruk> I'm going with "map f <$> xs", thanks! Very cool.
17:26:18 <stolaruk> It works. ;)
17:26:26 <arkeet> (fmap . map) f xs
17:26:42 <quchen> (fmap . fmap)!
17:26:48 <stolaruk> arkeet: Isn't that the same thing?
17:27:02 <arkeet> of course.
17:27:09 <arkeet> but it's the way it's written. :P
17:27:12 <quchen> It illustrates nicer how to compose maps to go one level deeper in the structure though.
17:27:23 <stolaruk> Funny I was JUST reading about that in RWH today.
17:27:43 <stolaruk> That is, unsing fmap twice to go 2 levels deep
17:27:55 <arkeet> that observation puts you well on the way to understanding lens. :p
17:28:02 <donri> :t fmap fmap fmap
17:28:03 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:28:21 <stolaruk> arkeet: Yeah I'm already using lens a lot ;)
17:28:22 <chrisdone> @let badger = fmap
17:28:23 <lambdabot>  .L.hs:149:10:
17:28:23 <lambdabot>      No instance for (Functor f0) arising from a use of `fmap'...
17:28:44 <chrisdone> @let badger = fmap :: Functor f => (badger -> mushroom) -> f badger -> f mushroom
17:28:45 <lambdabot>  .L.hs:150:5:
17:28:46 <lambdabot>      No instance for (Functor f0)
17:28:46 <lambdabot>        arising from an expres...
17:28:51 <donri> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap chrisdone chrisdone
17:28:52 <lambdabot> Not in scope: `chrisdone'
17:28:52 <lambdabot> Not in scope: `chrisdone'
17:28:53 <chrisdone> @slap lambdabot
17:28:53 * lambdabot activates her slap-o-matic...
17:29:18 <Rylee> @slap lambdabot
17:29:19 * lambdabot beats up lambdabot
17:29:22 <Rylee> haha
17:29:33 <Rylee> chrisdone, I can't seem to remember, are you a lambdabot dev?
17:29:33 <yitz> donri:  fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap ==  fmap fmap fmap fmap fmap fmap
17:30:09 <arkeet> yitz: yet fmap fmap fmap fmap fmap fmap fmap fmap fmap doesn't even unify with fmap fmap fmap fmap fmap
17:30:12 <arkeet> the types, I mean.
17:30:15 <stolaruk> I'm a relative newcomer to Haskell, read LYAH and now working thru RWH, and I'm developing an app in which I am using lens. Lens hasn't been too hard for me to wrap my head around. Of course there's probably a lot I could do with it that I'm not
17:30:16 <chrisdone> Rylee: no. i was gonna, but fortunately int-e rescued me. there's no telling how many hours i'd waste adding features to lambdabot if i ran it
17:30:26 <Rylee> haha
17:30:43 <chrisdone> stolaruk: so far so good
17:30:47 <yitz> arkeet: correct. one through nine are all distinct.
17:30:47 * arkeet nominates chrisdone for lambdabot dev
17:30:49 <donri> yitz: http://weebls-stuff.com/songs/badgers/
17:30:50 <Rylee> rargh, still passively trying to figure out how to make the `src` command work
17:31:01 <stolaruk> chrisdone: Yeah I'm kicking butt and taking names
17:31:07 <arkeet> yitz: yet you can apply them both to fmap and you get the same thing.
17:31:26 <yitz> donri: that goes out of sync after about 10 minutes, so it's not an appropriate metaphor
17:31:27 <stolaruk> chrisdone: I learn new tricks and then refactor my code. It's been thru many refactoring cycles but I'm learning a lot this way
17:31:36 <donri> :(
17:32:01 <joelteon> :t iterate fmap
17:32:02 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = f0 a0
17:32:02 <lambdabot>     Expected type: (a0 -> b0) -> a0 -> b0
17:32:02 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
17:32:12 <stolaruk> chrisdone: Recently I was able to refactor a ton of my "do" blocks into chained binds which was very cool and felt good
17:32:36 <quchen> stolaruk: Flip the arrows? :-þ
17:32:45 <chrisdone> stolaruk: \o/
17:32:50 <stolaruk> Huh?
17:32:53 <Rylee> :t flip
17:32:53 <lambdabot> (a -> b -> c) -> b -> a -> c
17:32:55 <Rylee> @src flip
17:32:55 <lambdabot> flip f x y = f y x
17:32:56 <donri> recently i was able to derive a difference path on the free category from hask, that felt good
17:33:15 <arkeet> @@ @djinn @type flip
17:33:15 <lambdabot>  f a b c = a c b
17:33:25 <chrisdone> yitz: funny, i was just thinking how it used to go out of synch much more reliably on slower machines back in the day. it's almost a required feature of flash videos from the 2000's, that they go out of synch. it adds to the charm
17:33:47 <stolaruk> I'm still a neophyte Haskell wizard
17:33:50 <quchen> chrisdone: Does that not happen anymore?
17:34:25 <yitz> chrisdone: the early version of flashplayer linux were even more charming. they went out of sync right from the get go.
17:34:26 <chrisdone> actually it's started going out of synch by a second now after a few minutes
17:34:30 <quchen> My VLC is always 300 ms off. I thought I had a broken installation, but after reinstalling (everything) it was still there.
17:34:33 <donri> mine's already out of sync
17:34:54 <quchen> But hey, when something sucks over a long period of time you just incorporate it into your culture.
17:35:02 <quchen> I'm 300ms-quchen. :-D
17:35:37 <chrisdone> quchen: can't you adjust the sync? in mplayer you can set the audio delay + or -
17:35:44 <donri> /bed
17:36:29 <ij> Was I supposed to understand what categories are after reading this http://www.haskellforall.com/2012/08/the-category-design-pattern.html ?
17:36:30 <quchen> chrisdone: Sure. Using VLC looks like this: 1. Quchen starts VLC. 2. Quchen hits h six times.
17:36:59 <yitz> ij: it depends what you mean by "understand".
17:37:24 <yitz> ij: personally, i like the brief introduction in the haskell wikibook.
17:37:33 <quchen> Learning about category theory is about getting improved gut feelings about them each time you read something new about them for me.
17:39:02 <ij> Monads make me want to cry.
17:39:15 <ij> All this "m" prefix gibberish.
17:39:24 <ij> yitz, Okay, I'll read that then.
17:39:33 <yitz> ij: too much hot sauce on your buurritto
17:39:34 <quchen> ij: You absolutely do not have to read about category theory in order to understand Monad in Haskell.
17:40:30 <stolaruk> ij: You are probably making it too hard for yourself
17:41:18 <arkeet> Monad is just a type class.
17:41:23 <arkeet> many things are instances of the class.
17:42:44 <arkeet> I think a good way of getting an intuition for monads in haskell is just to look at examples of such things.
17:43:13 <arkeet> but don't expect to understand it immediately, I guess.
17:43:51 <Guest42302> hey
17:44:00 <Guest42302> any haskell fans out here
17:44:09 <lucidpaw> woop woop pull over that haskell too fat
17:44:43 <Guest42302> i have a tinfoil hat
17:44:50 <solrize> ij, look at the wikibook about categories
17:45:08 <solrize> http://en.wikibooks.org/wiki/Haskell/Category_theory
17:45:24 <solrize> i found that it helped me understand monads
17:45:29 <lucidpaw> i recently acquired a tinfoil hat
17:45:32 <lucidpaw> will it help me soon? im in lyah
17:45:46 <Guest42302> very nice
17:46:33 <stolaruk> lucidpaw: LYAH will help you get thru RWH ;)
17:46:58 <lucidpaw> how much haskell will I be able to haskell after RWH?
17:47:11 * Fuuzetsu hasn't read RWH past first few chapters
17:47:18 <solrize> there's an rwh 2.0 in the works supposedly
17:47:25 <quchen> Beginner level: LYAH, Hutton. After that: LYAH again, and RWH.
17:47:33 <Guest42302> HASKELL NIGGERS
17:47:40 <Guest42302> FUCK HASKELL BITCH FAGGOTS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~
17:47:43 <chrisdone> @ops
17:47:43 <lambdabot> Maybe you meant: pl oeis docs
17:47:43 <Fuuzetsu> fingers crossed that 2.0 is less all over the place
17:47:47 <Guest42302> ~~~~~~~~~~#FUCK U#~~~~~~~~~~~~
17:47:49 --- mode: ChanServ set +o Saizan
17:47:50 <Guest42302> ~~~~~~~~~~#FUCK U#~~~~~~~~~~~~
17:47:53 <Guest42302> ~~~~~~~~~~#FUCK U#~~~~~~~~~~~~
17:47:53 --- mode: Saizan set +b *!*jimmyray@unaffiliated/stafford
17:47:53 --- kick: Guest42302 was kicked by Saizan (Guest42302)
17:48:01 <solrize> thanks saizan
17:48:02 <Fuuzetsu> must have missed #python
17:48:08 --- mode: Saizan set -o Saizan
17:48:09 <Saizan> np
17:48:09 <chrisdone> Saizan++
17:48:16 <geekosaur> nice, has a mask too. good way to lose it
17:48:19 <lucidpaw> does "LYAH again" mean skimming for highlighted functions
17:48:46 <stolaruk> lucidpaw: I'm about 1/2 way thru RWH, it's helping me a lot but writing my own code is REALLY moving along my understanding and skills
17:48:48 <quchen> lucidpaw: No, but for example reading the part about kinds again and now being completely clueless what that is good for :-þ
17:49:02 * geekosaur noticed just in time for Saizan to do the honors
17:49:33 <solrize> i think at a certain point you have to start reading actual papers, plus the haskell blogs
17:49:39 <stolaruk> quchen: For me understanding kinds has been very helpful
17:49:44 <solrize> planet.haskell.org aggregates most of the blogs
17:49:53 <solrize> idiomatic haskell has changed a lot in the past few years
17:49:57 <quchen> I didn't have to read any papers to learn Haskell.
17:50:08 <quchen> (I still did read some, but that was more out of academic interest.)
17:50:19 <chrisdone> me neither, tho some of them are better than books for specific topics
17:50:33 <chrisdone> see also http://ircbrowse.net/pdfs/haskell/unique
17:50:34 <solrize> parsec's documentation is mostly in a paper, for example
17:50:47 <quchen> Most work after you're done with RWH is really just finding your way around Hackage.
17:51:03 <stolaruk> lucidpaw: I think if you get all the way thru LYAH you will be ready to start writing some serious code.
17:51:22 <chrisdone> about 3k pdfs that haskellers find interesting enough to link in #haskell on that page
17:51:45 <solrize> yaht  that's a good paper
17:51:58 <lucidpaw> where do I find things to write "serious code" for. I'm pretty new to this whole programming deal
17:51:58 <quchen> It's also a 404 link
17:52:00 <solrize> okasaki's book is worth reading too
17:52:20 <solrize> there's some good stuff in here
17:52:45 <lucidpaw> hwo do i direct reply, do i just type <name>: '
17:52:47 <ReinHMobile> Oh hai
17:52:49 <quchen> lucidpaw: Well, ideas are something a language can't give you.
17:52:54 <chrisdone> lucidpaw: depends what you want to do
17:53:02 * monochrom doesn't understand. "I'm new" and "serious code" are antitheses to each other
17:53:11 <stolaruk> Is the Hutton bk worth reading after LYAH and RWH?
17:53:34 <quchen> stolaruk: I'd say read it alongside LYAH maybe.
17:53:47 <monochrom> "I am new to French. I want to write a serious movie review in French for a serious movie in French tomorrow."  not going to work.
17:54:04 <quchen> monochrom: Well you can chase an idea and grow on it.
17:54:10 <quchen> And refactor.
17:54:13 <quchen> And laugh at your old code.
17:54:24 * quchen loves his old code.
17:54:37 <monochrom> no, quchen, I would instead refer to despair.com
17:54:41 <stolaruk> Depends on what is meant by "serious code" I guess.
17:54:42 <chrisdone> i hate my old code
17:54:50 <lucidpaw> I was told I could start trying to walk on my own after getting through LYAH stop hurting my feelings monochrom ;~;
17:54:57 <haasn> I hate my pre-lens code
17:55:09 <solrize> lucidpaw, you can code interesting stuff after just part of lyah
17:55:23 <chrisdone> my old code is either useless, and therefore deleted, or useful, and therefore being used, and therefore very annoying because it sucks
17:55:28 <solrize> euler problems are a traditional first thing to try
17:55:34 <chrisdone> the code for tryhaskell is awful
17:55:45 <chrisdone> it's a wonder it actually works
17:55:46 <quchen> chrisdone: My old code is amusing. I should print TShirts with it.
17:55:54 <haasn> lucidpaw: you could try going through H99
17:56:02 <haasn> http://www.haskell.org/haskellwiki/99_questions
17:56:18 <haasn> Hmm
17:56:20 <haasn> @where 99
17:56:20 <lambdabot> I know nothing about 99.
17:56:24 <haasn> @where+ 99 http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
17:56:24 <lambdabot> Done.
17:56:31 <lucidpaw> hassn: did you do these?
17:56:35 <monochrom> http://www.despair.com/shoot-for-the-moon.html for everyone who aspires to a great project!
17:56:38 <Fuuzetsu> chrisdone: Last time I checked it only sometimes worked, often providing wrong results &c.
17:57:01 <quchen> monochrom: I'm not so sure about the lungs exploding though.
17:57:02 <stolaruk> lucidpaw: I did about half of the 99
17:57:48 <stolaruk> lucidpaw: Don't be discouraged, after LYAH you'll be able to do cool things like write code in a monad transformer stack and use the lens package and so on. It'll be fun.
17:58:01 <quchen> But who am I trying to motivate to write interesting programs, after all I just reinstalled my OS to procrastinate from searching the leak in my pet project.
17:58:01 <chrisdone> Fuuzetsu: 'often' is inaccurate
17:58:10 <monochrom> and http://www.despair.com/adventure.html
17:58:51 <chrisdone> Fuuzetsu: if it was often then i'd rewrite it. rare is acceptable
17:59:33 <chrisdone> monochrom: i  like the moon one =D
18:00:11 <chrisdone> quchen: did you try looking where you last had it?
18:00:24 <stolaruk> solrize: What is the title of the Okasaki bk
18:00:37 <solrize> stolaruk, purely functional data structures
18:00:37 <yitz> oh no, haasn. surely you meant to map 99 to http://99-bottles-of-beer.net/
18:00:40 <quchen> chrisdone: I looked everywhere. My code is about 1200 sloc. The changes I have made since discovering the leak are about 1400 sloc.
18:00:49 <stolaruk> solrize: Thanks, I'll check it out
18:00:52 <haasn> @where H99
18:00:52 <lambdabot> I know nothing about h99.
18:01:00 <haasn> yitz: feel free to fix it
18:01:20 <chrisdone> quchen: what's the leak like?
18:01:21 <haasn> but link to the haskell entry ;)
18:01:43 * chrisdone . o O ( http://www.leekspin.com/ )
18:01:48 <ReinHMobile> Also check out Bird's Pearls of Functional Algorithm Design
18:02:25 <haasn> stolaruk: oh, LYAH totally needs a chapter on lens
18:02:27 <ReinHMobile> Which has the minor advantage of actually being in Haskell
18:02:32 <quchen> chrisdone: Thread and socket and memory. That's what it's like.
18:02:42 <ReinHMobile> haasn: please to be writing
18:02:46 <chrisdone> quchen: big memory leak?
18:02:57 <stolaruk> haasn: Lens wasn't around when LYAH was written, no?
18:03:00 <quchen> You would think that something like that waves a red flag saying "I'M HEEEERE" but no, that sucker just shows up at runtime.
18:03:04 <quchen> chrisdone: No, small memory leak.
18:03:05 <solrize> lens came later than lyah, or at any rate it wasn't cool til then
18:03:06 <haasn> stolaruk: correct, lens is fairly recent
18:03:10 <solrize> same for pipes/conduits/enumeratee
18:03:19 <solrize> and data.text
18:03:27 <yitz> quchen: just throw more hardware at it. it's cheap nowadays.
18:03:27 <haasn> LYAH needs an update :(
18:03:28 <solrize> and attoparsec
18:03:32 <chrisdone> quchen: how did you detect it?
18:03:38 <ReinHMobile> quchen: correction: memory is not being leaked. It is being stored up to last through the winter.
18:03:46 <stolaruk> haasn: What I think we need is a new bk that covers lens and all the other good stuff & advanced topics
18:03:52 <quchen> chrisdone: By the OS telling me "too many connections, you don't get to open a new socket"
18:04:01 <solrize> stolaruk, yep, thus rwh v2 :)
18:04:07 <chrisdone> quchen: hmm, interesting
18:04:24 <quchen> yitz: Problem is that you can only have a limited amounts of sockets. I need more hardware and a better OS.
18:04:27 <haasn> stolaruk: I think what would be interesting is a “roadmap of interesting libraries” that links to the appropriate documentations
18:04:32 <haasn> just to give newcomers some idea of what's useful to learn
18:04:36 <chrisdone> quchen: how many connections do you have open?
18:04:42 <haasn> as well as what they can be used for
18:04:53 <ReinHMobile> Just bump up your ulimit.
18:04:56 <solrize> haasn the situation seems to be that there's important stuff that's really not accessible to newbies
18:05:01 <ReinHMobile> Mine goes to infinity.
18:05:07 <quchen> chrisdone: Around 200 sockets would be the desired behaviour.
18:05:09 <stolaruk> haasn: We also could use a Effective Haskell in the same vein as Effective Java
18:05:16 <yitz> quchen: do you think your code is actually trying to release the sockets and that isn't working? or that you are actually hoarding them?
18:05:44 <chrisdone> quchen: hmm. pre-ghc 7.something the io manager could only do a limited number of fds around 1024. but post the io manager update i happily tested my irc server with 10k connections
18:05:45 <quchen> yitz: My server forks off workers, and somehow these don't clean up enough after themselves when they're ThreadKilled.
18:05:54 <yitz> ah
18:05:59 <haasn> also, by linking to actual documentation instead of writing our own; we wouldn't need to update it as the libraries grow ;)
18:06:09 <haasn> a problem RWH suffers from, example rot
18:06:12 <quchen> yitz: Problem is killing workers is part of the server's design.
18:06:18 <chrisdone> quchen: ah, so the Socket isn't being killed properly?
18:06:28 <stolaruk> I'm hoping Gabriel Gonzalez writes a bk as he has said he will
18:06:36 <solrize> wow that would be awesome
18:06:37 <chrisdone> s/killed/closed
18:06:38 <quchen> chrisdone: Looks like it.
18:06:43 <ReinHMobile> So finally doesn't do it?
18:06:47 <yitz> quchen: you send them a polite request to close, or you shoot them with a rifle?
18:06:59 <chrisdone> quchen: and you presumably have a bracket/finally call to sClose it?
18:07:06 <quchen> chrisdone: I have everything in bracket, I'm using pipes and catch stuff, and still.
18:07:17 <chrisdone> oh. pipes
18:07:24 <chrisdone> good luck with that
18:07:29 <yitz> quchen: did you try resourceT?
18:07:30 <quchen> Well, pipes are probably just a detail here.
18:07:30 <monochrom> haha yikes
18:07:37 <ReinHMobile> Iirc SimonM's old concurrent http server just used a `finally`
18:08:03 <ReinHMobile> Oh pipes lol
18:08:19 <monochrom> if mapM is a monadic version of map, is SimonM a monadic version of Simon? :)
18:08:21 * ReinHMobile backs away nervously
18:08:27 <ReinHMobile> Yes.
18:08:41 <ReinHMobile> Effectful.
18:08:47 <quchen> simonM f = sequence . simon f
18:08:57 <monochrom> hehe
18:09:04 <chrisdone> monochrom: and as i joked the other day: simonM_ while at facebook =p
18:09:21 <chrisdone> (which isn't entirely true, but it's a joke =p)
18:09:23 <ReinHMobile> Jokes!
18:09:23 * geekosaur *eyeroll*
18:09:24 <yitz> monochrom: forkSimon :: SimonM Facebook
18:09:30 <quchen> chrisdone: What's probably worst about this leak is that every time I explain it it sounds like I'm missing something obvious and people suggest catching exceptions ;-)
18:09:32 <ReinHMobile> He output a podcast :p
18:09:57 * monochrom has a cunning plan!
18:09:58 <quchen> yitz: But a fork would mean he would still work on GHC full time (with half of his brain) :-(
18:10:06 <chrisdone> quchen: i presume you already put some logs in there to show that connection handles were actually closed?
18:10:20 <quidnunc> If I have a package "foo" that exists in hackage, download the source, modify it, cabal build && cabal install, will other packages that I install that depend on "foo" use my modified version?
18:10:22 * monochrom suggests quchen to *not* handle exceptions. then the program quits, and all sockets are closed.
18:10:47 <chrisdone> like, closeClient s = sClose s >> $(logDebug) ("Connection " <> pack (show s) <> " closed.")
18:10:53 <quchen> monochrom: Replacing "./a.out" with "true" would do as well, but consume less memory
18:10:55 <ReinHMobile> I don't think that is what is meant by "let it fail"
18:11:10 <haasn> ReinHMobile: hahaha
18:11:15 <quchen> chrisdone: Yes and no. The problem is the leak only shows up when I have a larger network running, and that makes the logs very uhmm concurrent.
18:11:24 <yitz> monochrom: he can disconnect the computer from its power source. that's more reliable.
18:11:41 <chrisdone> quchen: use monad-logger! it handles concurrency fine
18:11:41 <ReinHMobile> yitz: program a robot.
18:11:46 <monochrom> my cunning plans are not cunning enough
18:12:03 <quchen> chrisdone: That won't help. The logs aren't interleaved or anything, it's just that 10 people are talking at the same time in them.
18:12:09 <ReinHMobile> But who robots the robot.
18:12:14 <quchen> But yeah, I'm heavily printf-debugging at times.
18:12:46 <yitz> quchen: what os?
18:12:48 <chrisdone> quchen: sure. but e.g. you can see (1) fd 123 opened. (2) client killed (3) fd 123 closed
18:12:59 <quchen> yitz: It's not the OS. Anyway, it was Linux on x86.
18:13:39 <yitz> quchen: the problem only occuring in the presence of a larger volume of traffic on the ethernet sounds very suspicious
18:13:53 <lucidpaw> where do I put print statements in haskell for debugging?
18:13:58 <chrisdone> yitz: it sounds like sockets not being closed =)
18:14:08 <chrisdone> the more traffic, the more they would mount up
18:14:22 <yitz> lucidpaw: wherever you want, using Debug.Trace
18:14:23 <monochrom> for debugging, use stuff from Debug.Trace, you can put them almost anywhere
18:14:33 <haasn> lucidpaw: if you want to trace evaluation of a (pure) program you can use Debug.Trace; but beware of things not being in the order you expect them to be in
18:14:43 <haasn> Also, please don't deliver production code that uses trace ;)
18:15:00 <chrisdone> quchen: is your source online?
18:15:04 <lucidpaw> woo thanks
18:15:10 <quchen> yitz: It's not about traffic. What I have is a number of nodes, participating in a network. There is a special server that has its own little herd of nodes it uses to inject messages into the network. These nodes are periodically restarted to guarantee the server is interconnected with the network, and doesn't cluster its own nodes.
18:15:25 <solrize> quchen, wireshark ?
18:15:50 <yitz> ah i see. a larger network participating in use of your app.
18:16:20 <quchen> chrisdone: https://github.com/quchen/amoeba
18:16:27 <quchen> I think I merged everything into master.
18:16:51 <quchen> So that should be a somewhat current version. Ignore the commit message with "socket leak fixed", that one was premature :-(
18:17:04 <ReinHMobile> what is your file descriptor ulimit?
18:17:18 <chrisdone> lol
18:17:23 <ReinHMobile> Set it to 4096 or more? 200 sockets isn't very much.
18:17:24 <yitz> quchen: what is a typical rate of socket creation/killing?
18:17:53 <ReinHMobile> Your program might just lag in closing sockets, not leak
18:17:54 <chrisdone> ReinHMobile: he said he only expects 200 sockets. lifting the fd limit would just mask the problem that sockets aren't being freed
18:17:55 <quchen> yitz: Around every ten seconds when running normally. For testing faster, say 1-2 seconds.
18:18:12 <ReinHMobile> I'm not convinced they are leaking.
18:18:29 <quchen> Every spawn+kill cycle kills about 22 sockets (and reopens them).
18:18:42 <chrisdone> ReinHMobile: if he's compiling with ghc 7 then the limit is not going to be anywhere near as low as 4k
18:18:59 <ReinHMobile> Kernel ulimit.
18:19:18 <chrisdone> applied by who?
18:19:27 <ReinHMobile> The default
18:19:39 <chrisdone> @ _@
18:19:44 <ReinHMobile> Is 256 on OS X for instance iirc
18:19:50 <ReinHMobile> Or something stupid
18:19:57 <chrisdone> on ubuntu i went up to 10k freely
18:20:02 <ReinHMobile> Or used to be
18:20:10 <quchen> ReinHMobile: I investigated this thing for a long time now, I'm pretty convinced the error is on my side. In particular there are some other phenomena that would go well with me not cleaning up properly.
18:20:11 <chrisdone> quchen's on linux, presumably ubuntu
18:20:23 <ReinHMobile> Why would 200 sockets exceed any limit?
18:20:44 <ReinHMobile> I'm just baffled by this
18:20:47 <chrisdone> because it's not just 200 sockets. it's 200 at any one time, with new ones being created, and, it's suspected, others not being closed
18:20:52 <quchen> 200 doesn't exceed, but the program opens up to 1024 (which is a factor 5 over what it should do).
18:21:06 <quchen> I was on Ubuntu 11.04 until a couple of days ago, now I'm on 13.10.
18:21:11 <quchen> 64bit this time.
18:21:14 <ReinHMobile> Uh.
18:21:26 <quchen> At 1024 the OS tells me it's enough.
18:21:50 <ReinHMobile> Bump your ulimit and see if it still happens.
18:22:03 <ReinHMobile> I suspect they are being closed but not in time
18:22:10 <yitz> quchen: could it be because of the sockets going into TCPWAIT for 30 sec. when you kill its thread? that's the default on linux.
18:22:21 <ReinHMobile> If it's truly leaking any ulimit should be exceeded over time.
18:22:28 <quchen> yitz: TCPWAIT?
18:22:32 <ReinHMobile> I suspect it's just lag
18:22:36 <quchen> 30 seconds?
18:22:39 <quchen> Wow.
18:23:00 <ReinHMobile> That would probably do it
18:23:05 <yitz> quchen: yes. try cutting that down using proc, see if it helps.
18:23:33 <monochrom> "netstat -t -n" may help
18:23:41 <ReinHMobile> You might want to tune your tcp settings. They are typically tuned for 1970s usage patterns o_O
18:24:19 <ReinHMobile> Things like tcpwait, recv window size, it's rather ridiculous.
18:25:10 <yitz> quchen: look on the bright side. on windows the default is a minute.
18:25:17 <quchen> Might be worth a try at least.
18:25:18 <monochrom> haha
18:26:54 <quchen> yitz: Hans went to war. Hans was shot in the leg and it had to be amputated. Hans was happy about this, as he still had the other one.
18:27:14 <yitz> something like that.
18:30:35 <ij> solrize, Hopefully; currently looking at it.
18:31:20 <solrize> quchen, SO_REUSEADDR ?
18:31:38 <quchen> I'm terribly unfamiliar with networking, solrize
18:31:57 <quchen> So far I just assumed the OS knows best and I can just use networking libraries.
18:32:26 <solrize> quchen i missed part of this, but are you saying you're using pipes and your app is leaking sockets?
18:33:26 <chrisdone> the time wait stuff is to avoid the same ip:port combo being re-used on your server before the other side of that socket has finished sending stuff
18:33:46 <chrisdone> re-use addr would ignore that cautious behaviour
18:34:17 <solrize> chrisdone yeah, SO_REUSEADDR gets rid of the wait before reusing the port, but something else seems to be happening here.... quchen it might help if you use wireshark to get used to what tcp traffic actually looks like
18:34:36 * hackagebot hlibgit2 0.18.0.11 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.11 (JohnWiegley)
18:34:37 <solrize> then you should be able to see FIN_CLOSE when the program is suppposed to be finished with a socket
18:34:41 * geekosaur also recommends _TCP/IP Ilustrated_
18:34:51 <geekosaur> *Illustrated
18:35:21 * chrisdone → bed
18:35:37 <quchen> Yeah same here I think. I'll dream of tweaking TCP now
18:36:12 <quchen> Thanks again for the pointers. I'll probably ask again about these networking things once I'm not terribly tired :-)
18:43:05 <solrize> http://motherfuckingwebsite.com/  wow
18:43:27 <monochrom> um...
18:43:43 <solrize> i never saw that before
18:43:58 <solrize> something else i was reading linked it.  sorry, off-topic.
18:45:51 <yitz> solrize: bos wrote a post like that on his blog about big data. caused my isp to flag it and i couldn't access his blog anymore for a while.
18:46:01 <solrize> hehe
18:46:03 <monochrom> haha
18:46:28 <solrize> http://www.serpentine.com/blog/2013/04/30/big-fucking-deal/  ?
18:46:42 <yitz> right that one
18:58:12 <stolaruk> I'm refactoring my code and I found I can do this, but I'm wondering what popular opinion would be as to how ugly or unreadable this is: liftA (map fst . sortBy nameThenSing) $ zip3 is <$> getNames is <*> getSings is
18:58:33 <stolaruk> On a single line:
18:58:34 <stolaruk> liftA (map fst . sortBy nameThenSing) $ zip3 is <$> getNames is <*> getSings is
18:58:58 <ion> yitz: What made your ISP “flag” it?
18:59:28 <yitz> ion: the profanity. not sure how they noticed it though. maybe someone complained.
18:59:42 <ion> Your country does that? ಠ_ಠ
19:00:01 <yitz> ion: just guessing, anyway. all i know is that i mysteriously couldn't access the site after that blog post.
19:00:13 <yitz> ion: it was in the usa
19:00:29 <ion> all of my wat
19:01:19 <yitz> ion: bryan and i verified that the site was up and accessible to a lot of people, but for me it was as if the site was down.
19:05:04 <derdon> my haskell code starts to look like lisp :O
19:05:12 <derdon> I may be doing something wrong
19:05:57 <derdon> (size (delete key (insert (key, value) map)))
19:06:26 <yitz> @type liftA
19:06:27 <lambdabot> Applicative f => (a -> b) -> f a -> f b
19:06:31 <yitz> @type fmap
19:06:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:06:38 <quidnunc> Why can't I "cabal install network"? ---> "pwd: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory"
19:06:43 <yitz> stolaruk: other than that, looks fine to me.
19:07:17 <stolaruk> yitz: Do you mean it would make more sense to use fmap here instead of liftA ?
19:07:32 <yitz> quidnunc: why are you trying to install network? use the one that comes with ghc.
19:07:51 <stolaruk> derdon: Do you know about ($) and .  ?
19:07:58 <derdon> stolaruk: I do
19:08:02 <quidnunc> yitz: I'm trying to "cabal install cabal". network is a dependency
19:08:10 <geekosaur> quidnunc, that sounds like you removed the directory you are supposedly in
19:08:13 <derdon> stolaruk: I'm not always sure if it improved the readability
19:08:17 <quidnunc> geekosaur: nope
19:08:23 <yitz> stolaruk: i think it's more clear. you're mixing the two in the same expression, but really they're the same.
19:08:43 <quidnunc> geekosaur: You docker?
19:08:53 <geekosaur> ??
19:08:57 <quidnunc> do you do docker?
19:08:59 <stolaruk> derdon: You can do "size . delete key . insert (key, value) $ map"
19:09:16 <yitz> quidnunc: but if you have ghc, you already have network. is it a very old ghc perhaps?
19:09:16 <geekosaur> no
19:09:16 <stolaruk> yitz: Ok, cool. Appreicate it
19:09:34 <stolaruk> derdon: That would be more readable to me
19:09:38 <derdon> stolaruk: this surely looks more like Haskell. But is it also more readable?
19:09:38 <quidnunc> yitz: 2012/04
19:09:44 <quidnunc> yitz: ubuntu precise
19:09:51 <quidnunc> 7.4.1
19:09:58 <derdon> stolaruk: perhaps it just depends on how used to it you are to $ and .
19:10:00 <stolaruk> derdon: I think Haskellers are accustomed to reading that style with all the dots
19:10:08 <derdon> I see
19:10:12 <yitz> quidnunc: i do cabal install cabal-install with that all the time. in a sandbox though.
19:10:17 <derdon> I'm not a Haskeller (yet)
19:10:26 <quidnunc> yitz: with precise or with docker?
19:10:57 <quidnunc> http://dpaste.com/1486752/
19:11:01 <quidnunc> ^ This is not working
19:11:06 <ion> derdon: You might be able to eta-reduce the “$ map” away.
19:11:20 <stolaruk> ion: point free style?
19:11:49 <yitz> quidnunc: if you don't already have a recent cabal with built in sanbox support: re-install HP, cabal update, cabal install cabal-dev, in a new folder cabal-dev install cabal-install.
19:12:22 <yitz> quidnunc: from then on use the new cabal you just compiled. (precise. what's docker?)
19:12:56 <derdon> ion: stolaruk: the function that calls it is an HUnit test function
19:13:10 <derdon> so I'm not sure if eta-reducing there is a good idea
19:13:21 <derdon> it definitely wouldn't make the intention clear
19:13:26 <quidnunc> yitz: It's like a nice automatic chroot. It's all the rage.
19:14:17 <quidnunc> yitz: I can't cabal install cabal-dev because network won't install
19:14:34 <stolaruk> derdon: You can leave the
19:14:45 <stolaruk> derdon: You can leave the "$ map" if you think it makes it clearer
19:14:52 <brainsturgeon> Is there an easy way to modify "deriving Read" so that I can parse a string which doesn't include the type constructor?
19:14:55 <monochrom> chroot jail eh? that is like saying "I'm writing haskell code in my dream"
19:15:18 <derdon> stolaruk: ok
19:15:31 <yitz> quidnunc: oh i didn't try using apt-get to install cabal-install. joachim has been doing a great job with haskell apt packages, but you might end up with old stuff on precise that way.
19:15:51 <quidnunc> yitz: Right. The idea was to bootstrap from the old stuff
19:16:03 <brainsturgeon> e.g. data ListItem = ListItem String String;
19:16:06 <quidnunc> which is supplied by precise
19:16:24 <brainsturgeon> read "abc def" :: ListItem ---> ListItem "abc" "def"
19:16:31 <quidnunc> yitz: You're downloading source?
19:16:55 <stolaruk> derdon: If the function is "testMap map = size . delete key . insert (key, value) $ map" then you can actually write "testMap = size . delete key . insert (key, value)"
19:17:11 <monochrom> brainsturgeon, I'm afraid you will have to write your own Read instance code
19:17:17 <yitz> quidnunc: i install the ghc binary tar ball. it comes with network. use the version that will be needed by HP. then i install HP from source. you'll need zlib-dev, some OpenGL stuff, a few others.
19:17:28 <derdon> stolaruk: ... which is called eta-reduction
19:17:38 <quidnunc> yitz: :(
19:17:48 <yitz> quidnunc: doesn't take long. i do it all the time.
19:18:11 <quidnunc> yitz: High cognitive overhead
19:18:15 <stolaruk> derdon: Yes, I think the linter would suggest that you "eta-reduce"; that style is actually called "point free style" tho
19:18:18 <Javran1> inspired by the idea that monad is a monoid, I constrain every function to be a -> m a and make it an instance of Monoid. https://gist.github.com/Javran/7701008 don't know if my understanding is correct, so can you give me some comments?
19:18:41 <yitz> quidnunc: i actually have a few different versions of HP. i use GNU stow to manage them. the new cabal works fine with all of them.
19:19:04 <derdon> stolaruk: I plan to call hlint on my *.hs files before submitting them anyway
19:19:16 <quidnunc> yitz: I just want a fast easy way to get a recent haskell+cabal environment on precise
19:19:17 <yitz> quidnunc: nah it's trivial. ./configure, make, sudo make install.
19:19:39 <quidnunc> yitz: I need to install build-depends first
19:20:07 <yitz> quidnunc: precise is our workhorse platform at work - we have a ton of precise vms. installed various versions of ghc like that on all of them. very easy.
19:20:47 <brainsturgeon> monochrom: I was afraid of that. I've been struggling with parsers for a while.
19:20:51 <quidnunc> yitz: So what are the steps again? Install ghc from source, then haskell-platform?
19:21:00 <yitz> quidnunc: yeah the main problem is that you need a bunch of OpenGL-related debs, which then pulls in a lot of the X library. really a shame for a headless server.
19:21:22 <quidnunc> yitz: Yeah that's not going to work for me.
19:21:48 <quidnunc> It needs to be fairly lightweight
19:21:51 <yitz> quidnunc: why? configure tells you what you need.
19:21:57 <stolaruk> derdon: the linter is good ;)
19:22:10 <derdon> stolaruk: I know! it's very clever!
19:22:22 <derdon> I was positively surprised by its cleverness
19:22:53 <quidnunc> yitz: Because the image shouldn't install a thousand libraries
19:23:00 <quidnunc> (the image I am building)
19:23:06 <quidnunc> just to compile
19:23:15 <yitz> stolaruk: not really. you don't eta-reduce as far as possible as in point-free. just enough to make your code more clear.
19:23:43 <quidnunc> Can I bootstrap from cabal-install?
19:24:44 <yitz> quidnunc: yeah. if that's an issue, then don't install HP. just install the specific library versions that are in HP (from the list on their site), skipping the ones having to do with OpenGL and glut.
19:25:05 <quidnunc> yitz: :(
19:25:17 <yitz> you'll definitely need zlib-dev and gmp no matter what.
19:25:24 <yitz> but those are lightweight.
19:25:37 <derdon> yitz: eta-reduce is simply converting "f x n = g (foo x) n" to "f x = g (foo x)" whereas making a function point-free removes all explicit arguments from f
19:25:41 <derdon> yitz: right?
19:26:25 <quidnunc> If I download source for a package, modify it, cabal build && cabal install, will other packages that have said package as a dependency use my modified version?
19:26:37 <yitz> derdon: right, you keep going until there are no explicit arguments left at all.
19:27:48 <yitz> quidnunc: you should give your modified version a version number that makes sense. then you can use a local cabal.config to specify the constraint to use specifically your version.
19:28:44 <yitz> quidnunc: and cabal sandbox add-source to add your modified source code to the available dependencies.
19:31:02 <quidnunc> yitz: Thanks, I'll read up on it
19:37:53 <Ick> LF: Nethius, Jake
19:45:39 <brainsturgeon> The hackage page for Text.Read claims that GHC has an "extended and much improved 'read' class" which makes it easier to write parsers. Are there any good resources for creating parsers with this tool?
19:48:16 <brainsturgeon> monochrom, maybe you have some suggestions here?
19:48:32 <Clint> what do you want to parse?
19:48:37 <kvda> is there a ghc temp var of last computed output?
19:48:42 <kvda> *ghci
19:48:49 <geekosaur> `it`
19:49:20 <kvda> awesome, thanks geekosaur
19:49:44 <brainsturgeon> I'm making a task organizer as a sort of toy project to learn the ins and outs of the language.
19:50:54 <geekosaur> I am not sure when it's bound, so the usual warnings about recursive bindings may apply
19:51:07 <brainsturgeon> Clint, I'm parsing a task belonging to a datatype with "Maybe" fields
19:52:06 <brainsturgeon> and I'd like to make the "Maybe" arguments optional. context would be from the number of elements.
19:52:41 <enthropy> @hoogle readP_to_S
19:52:42 <lambdabot> Text.ParserCombinators.ReadP readP_to_S :: ReadP a -> ReadS a
19:52:43 <Clint> i really think you don't want to use Read for this
19:53:09 <enthropy> those combinators are in base I think and have conversions both ways
19:54:57 <brainsturgeon> okay, I'm not fixed on read. I thought since the derived behaviour was close it could save me some work.
19:55:34 <brainsturgeon> enthropy: thanks, I'll read those ref pages.
19:57:10 <enthropy> ReadP isn't that great, and readS_to_P has some big warnings that it might be slow/inefficient
19:57:40 <brainsturgeon> so what would you suggest? parsec?
19:57:52 <enthropy> but if you can figure out ReadP, it's the same idea as any other monadic parsers
19:58:18 <enthropy> parsec doens't have an equivalent of readS_to_P (as far as I know)
19:59:06 <enthropy> you could still write one but maybe they did that on purpose
19:59:29 <brainsturgeon> it's not critical that I recover "read" functionality. I was kind of hoping to avoid writing a parser, but I'll probably have to learn Happy or something.
19:59:52 <geekosaur> you'd still be writing a parser, just with lamer combinators
20:00:16 <geekosaur> ReadS will quickly leave you wishing you'd used Parsec
20:01:09 <enthropy> brainsturgeon: I think happy is underappreciated
20:02:18 <brainsturgeon> enthropy: you think it might be preferable to writing a monadic parser from scratch?
20:02:36 <brainsturgeon> I thought maybe it would be overkill for a simple case.
20:04:44 * hackagebot gitlib 2.2.0.0 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-2.2.0.0 (JohnWiegley)
20:04:46 * hackagebot gitlib-cmdline 2.2.0.0 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-2.2.0.0 (JohnWiegley)
20:04:48 * hackagebot gitlib-cross 2.2.0.0 - Run tests between repositories  http://hackage.haskell.org/package/gitlib-cross-2.2.0.0 (JohnWiegley)
20:04:50 * hackagebot gitlib-libgit2 2.2.0.0 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-2.2.0.0 (JohnWiegley)
20:04:52 * hackagebot gitlib-s3 2.2.0.0 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-2.2.0.0 (JohnWiegley)
20:08:27 <enthropy> happy is heavier in that you need a separate file/module for it
20:09:32 <enthropy> probably it's about the same amount of text for both options
20:09:54 * hackagebot gitlib-sample 2.2.0.0 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-2.2.0.0 (JohnWiegley)
20:09:56 * hackagebot gitlib-test 2.2.0.0 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-2.2.0.0 (JohnWiegley)
20:10:26 <brainsturgeon> okay. i'll give it a shot, it's probably worthwhile to learn anyway.
20:10:48 <Ick> Jake nethius if you are out there and remember austin aaron and dom, we miss you :c get in touch <3
20:19:45 * hackagebot stm-conduit 2.1.4 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.1.4 (ClarkGaebel)
21:03:13 <raphie> is it possible to easily parallelize maps?
21:05:04 <c_wraith> sort of
21:05:46 <c_wraith> You have to understand what a list is in haskell to understand what parallelizing map implies
21:07:03 <c_wraith> it's easy to replace a call to map with a call to parMap
21:07:18 <c_wraith> It's a lot harder to understand why it didn't speed anything up in many use cases
21:08:52 <raphie> c_wraith: lists are just singly-linked lists, yes? a value and a reference
21:09:15 <raphie> oh, so that'd make it hard to assign work at arbitrary points, cuz you'd have to traverse just to start working, yes?
21:09:20 <c_wraith> they are singly linked lists.  But they are lazy, in both value and in the tail
21:09:39 <Platz> so there must be some kind of vector type then
21:09:47 <Platz> which works better
21:10:24 <c_wraith> And that laziness often implies there is a calculation that must be performed to get the value *and* to get the tail.
21:10:40 <c_wraith> And in many cases, that calculation is more expensive than the function being applied with parMap
21:12:00 <c_wraith> now, parMap can work really well, in the case where you actually have a list that you know is fully evaluated, and will be fully consumed, and the operation you are mapping over the list is very expensive
21:12:20 <c_wraith> But when you don't have all of those things, it often isn't a good fit.
21:12:31 <raphie> when you say fully evaluated, what do you mean?
21:12:45 <raphie> (I'm new to Haskell)
21:13:32 <c_wraith> > let x = map (*3) [1..100] in take 5 x
21:13:32 <lambdabot>   [3,6,9,12,15]
21:13:42 <lightquake> oh huh, Free f Void = Fix f. that's neat.
21:13:47 <c_wraith> x is not fully evaluated in the computation there
21:14:43 <c_wraith> Only the first 5 (:) constructors of x and the numbers stored with those constructors are evaluated
21:15:16 <c_wraith> The remainder of the list exists only as a computation that got thrown out when take completed
21:16:19 <c_wraith> This laziness is fundamental for understanding how parallel computation works (and fails to work) in haskell.
21:17:49 <lightquake> why is there now (Show a) => Show (Identity a)?
21:17:55 <lightquake> *is there no
21:18:58 <raphie> > let foo n = "ab" ++ n in take 5 $ foo ""
21:18:59 <lambdabot>   "ab"
21:19:14 <raphie> er
21:19:23 <raphie> > let foo n = foo $ "ab" ++ n in take 5 $ foo ""
21:19:28 <lambdabot>   mueval: ExitFailure 1
21:19:28 <lambdabot>  mueval: Prelude.undefined
21:19:57 <c_wraith> that error message is confusing.
21:20:03 <raphie> took too long?
21:20:19 <c_wraith> well, yes, it would.  It's not productive
21:20:26 <c_wraith> But I have no clue why it hit an undefined
21:20:40 <khyperia> wait, what does "ap" do? Is it the same as (<*>) but for monads?
21:20:48 <c_wraith> khyperia: exactly
21:20:51 <khyperia> ah
21:21:14 <c_wraith> remember, the Monad abstraction is older than the Applicative abstraction.  That's why there's duplication
21:21:24 <khyperia> Right.
21:21:46 <raphie> c_wraith: why doesn't that work though? shouldn't it be lazily evaluated?
21:22:35 <lightquake> raphie: the problem is that foo never produces any values
21:22:39 <lightquake> so to speak
21:22:51 <lightquake> > let f n = "ab" ++ f n in take 5 $ f ""
21:22:52 <lambdabot>   "ababa"
21:23:16 <raphie> ooooh that makes sense, lightquake
21:23:32 <raphie> how does take know when to stop asking for values?
21:23:46 <raphie> is that something that's fundamental in the language, or implemented specifically in take?
21:23:54 <c_wraith> sort of both.
21:24:18 <c_wraith> I mean, take is the thing that grabs the number of values you ask for
21:24:20 <raphie> sorry if these are really basic questions, just curious about what's happening "under the hood"
21:24:28 <lightquake> @src take
21:24:28 <lambdabot> take n _      | n <= 0 =  []
21:24:28 <lambdabot> take _ []              =  []
21:24:28 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
21:24:46 <c_wraith> But the fact that take works at all on infinite lists is an artifact of how laziness works
21:25:30 <raphie> ooh, I haven't seen the | n <= 0 syntax before. what's that called?
21:25:35 <c_wraith> it's a guard
21:26:04 <c_wraith> It's a boolean expression that must be true for that equation to be chosen
21:26:05 <raphie> ahhhhhh I've seen those, just not on the same line :)
21:26:51 <raphie> yeah I've seen them in the context of replacing a conditional, just not in pattern-matching
21:27:08 <c_wraith> Well, the really important bit is the case when n > 0.  When that happens, take pattern-matches on the list constructor.
21:27:08 <ReinHMobile> Hai
21:27:40 <Ick> Jake nethius if you are out there and remember austin aaron and dom, we miss you :c get in touch <3
21:27:45 <lightquake> actually, here's something. you can easily define a type that only has infinite lists as inhabitants by doing something like data IList a = Cons a (IList a)
21:28:08 <lightquake> can you make a type that only has finite lists as inhabitants without using strictness?
21:28:42 <c_wraith> lightquake: absolutely - length-index the list, in the type.
21:29:13 <lightquake> can you do that in ghc 7.8's type system?
21:29:33 <c_wraith> yep.  you can do it in any version with GADTs
21:29:40 <c_wraith> it's way cleaner in 7.8, though
21:30:09 <raphie> has anyone done extensive web-dev with Haskell?
21:30:19 <c_wraith> raphie: pattern-matching is what drives evaluation in haskell.  Under the hood, the list constructor (conceptually, if not exactly) has three possibilities: [], (:), and "haven't figured it out yet"
21:30:32 <raphie> I'm looking for something less like rails (I've checked out Yesod and Snap) and more like Sinatra/Express
21:30:40 <c_wraith> try scotty
21:31:00 <lightquake> i've been meaning to look at scotty
21:31:13 <ion> c_wraith: and “crash and burn” or “let me get back to you on that after the heat death of the universe” ;-)
21:31:34 <c_wraith> raphie: when you pattern match on a value, it does exactly as much work as is necessary to figure out what the constructor actually is, and then the pattern-match proceeds
21:31:50 <raphie> huh, cool
21:32:10 <lightquake> oh right, data FiniteList n a where Nil :: FiniteList n a; Cons :: a -> FiniteList n a -> FiniteList (S n) a
21:32:26 <c_wraith> Nil :: FiniteList Z a
21:32:29 <c_wraith> but yeah
21:32:31 <lightquake> er, right
21:32:41 <ReinHMobile> c_wraith: ignoring the latter, [] and (x:xs) are your base and inductive cases.
21:33:36 <c_wraith> raphie: so when I said that your example function wasn't productive, I meant "it has to do an infinite amount of work before it figures out if the first constructor is (:) or []"
21:33:56 <raphie> that actually makes sense!
21:34:01 <ReinHMobile> iow it is not guarded
21:34:34 <c_wraith> raphie: whereas lightquake's modification produces a couple of (:) constructors before the recursive call, so it is productive
21:34:55 <ReinHMobile> raphie: compare foldl and foldr
21:36:03 <ReinHMobile> raphie: Why can I do take 5 . foldr (:) [] but not w/ foldl?
21:36:52 <raphie> ReinHMobile: foldl has to traverse the entire list before it begins computation, yes?
21:38:33 <raphie> ooooh, this seems like a good place to ask, is there a way to curry an argument other than the first?
21:38:33 <ReinHMobile> @src foldl
21:38:33 <lambdabot> foldl f z []     = z
21:38:33 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:38:49 <simpson> raphie: flip first.
21:38:49 <ReinHMobile> :t flip
21:38:50 <lambdabot> (a -> b -> c) -> b -> a -> c
21:39:31 <raphie> but that only works on a function with an arity of 2, yes?
21:39:49 <ion> c can be a function.
21:40:15 <raphie> oooh didn't consider that, nice!
21:43:04 <Platz> where does lambdabot get it's source from?  I thought foldl was defined non-recursively?
21:43:35 <c_wraith> its sources come from a hand-populated database.  they're not canonical
21:43:43 <ion> http://hackage.haskell.org/package/lambdabot-4.3.0.1/src/State/source
21:43:44 <c_wraith> But regardless of that, foldl has to be recursive
21:43:50 <simpson> @src concatMap
21:43:50 <lambdabot> concatMap f = foldr ((++) . f) []
21:44:16 <ReinHMobile> List homomorphisms ftw
21:44:56 <Platz> ahh, i was looking at http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#foldl , it is recursive but only in a helper function
21:45:23 <c_wraith> well, fine.  it's worker-wrapper transformed by hand.  But it's still recursive!
21:46:26 <c_wraith> and yeah, that's just a worker-wrapper transform to close over the value f, since it doesn't change during the recursion - it's just overhead to pass it every time.
21:47:42 <Platz> interesting, yeah I still have a lot to learn ;)
21:49:24 <c_wraith> what's interesting to me is that it's done by hand.  GHC can often do that transformation itself at compile-time.
22:10:42 <ReinH> c_wraith: oh and of course Hutton wrote the book on worker-wrapper transforms. Well, wrote the paper.
22:12:12 <ReinH> I also love the way he says Hsakell
22:37:13 <smith_> If I have one list xs and another list ys that is a subset of xs, is there a quick function to remove all xs from ys?
22:37:31 <smith_> Or, well, return a list that is xs without any elements that are also in ys.
22:38:09 <smith_> "remove all ys from xs", I mean.;
22:38:33 <Kams_> Removing all instances of a list from a list of lists?
22:38:38 <startling> it's probably in Data.List
22:38:53 <Kams_> You could individually filter every element you want to get rid of
22:39:06 <startling> it's (//)
22:39:11 <startling> from Data.List
22:39:17 <startling> :t Data.List.//
22:39:17 <lambdabot> parse error on input `Data.List.//'
22:39:24 <mgsloan> > [1,2,3] \\ [1,2]
22:39:25 <lambdabot>   [3]
22:39:30 <startling> oh
22:39:37 <smith_> startling: Ah! I looked at delete, union, intersect, but not (//). Thanks!
22:39:38 * startling 's brain flipped them.
22:39:50 <startling> smith_: it's (\\)
22:40:00 <smith_> Gah. Thanks.
22:40:15 <pavonia> > [1,2,3,1,2,3] \\ [1,2]
22:40:15 <lambdabot>   [3,1,2,3]
22:40:17 <Kams_> >[1,2,3,4,4,4,5] \\ [1,2,3,4]
22:40:33 <startling> yeah, it doesn't handle duplicates
22:40:50 <mgsloan> One hacky way to handle duplicates would be
22:40:53 <smith_> > (nub [1,2,2,3,3]) \\ [2]
22:40:54 <lambdabot>   [1,3]
22:40:56 <startling> smith_: for future reference: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#g:20
22:40:59 <mgsloan> > [1,2,3,1,2,3] \\ cycle [1,2]
22:41:03 <lambdabot>   mueval-core: Time limit exceeded
22:41:06 <mgsloan> Or not
22:41:15 <mgsloan> Of course not what am I thinking
22:41:19 <startling> haha
22:41:21 <smith_> startling: Thanks, I actually have that page open right now, heh. I guess I skipped over (\\) without seeing it.
22:42:37 <Twey> [] // _ = []; (x : xs) // ys | elem x ys = xs | otherwise = xs // ys
22:42:46 <Twey> But if you need this you might want to be using Set or Map
22:43:30 <Twey> (Map if you want to preserve duplicate elements)
22:44:15 <Twey> Even if you want to preserve duplicate elements and order, you can speed up the algorithm by making the second argument a set
22:44:29 <jle`> smith_: i assume you are avoiding just filtering on `elem`
22:44:54 <Twey> Yeah, that's just filter . flip elem of course :þ
22:45:46 <smith_> jle`: Yep, I try to use a higher-order function if one is available.
22:46:25 <Twey> smith_: filter is a higher-order function :þ
22:47:05 <Twey> > (filter . flip elem) [1, 2] [1, 2, 3, 4, 2, 4]
22:47:06 <lambdabot>   [1,2,2]
22:47:14 <startling> :t foldl (flip delete)
22:47:15 <lambdabot> Eq b => [b] -> [b] -> [b]
22:47:16 <Twey> > (filter . flip notElem) [1, 2] [1, 2, 3, 4, 2, 4]
22:47:17 <lambdabot>   [3,4,4]
22:47:37 <startling> I guess it depends on which is usually longer.
22:47:46 <Twey> Aye
22:48:00 <Twey> A Set is probably better anyway
22:48:05 <ReinH> aaand you still probably want a Set
22:48:10 <jle`> i think you mean pre-written, not higher order?
22:48:37 <startling> Maybe. It's silly to optimize this early, and using the listy things might be more clear.
22:48:39 <smith_> Set doesn't really work here, as I'm taking Data.Maybe.Lazy.keys on a Map and then removing keys that are in a certain list.
22:48:48 <Twey> > (filter . flip Data.Set.notMember) (Data.Set.fromList [1, 2]) [1, 2, 3, 4, 2, 4]
22:48:49 <lambdabot>   Not in scope: `Data.Set.notMember'Not in scope: `Data.Set.fromList'
22:48:54 <ReinH> startling: it's not (just) about optimizing, it's about using a data structure with the right semantics
22:48:55 <smith_> Going to Sets would mean having a bulky conversion in the middle.
22:49:00 <ReinH> Smalltalkers learned this long ago
22:49:04 <Twey> > (filter . flip S.notMember) (S.fromList [1, 2]) [1, 2, 3, 4, 2, 4]
22:49:05 <lambdabot>   [3,4,4]
22:49:16 <smith_> jle`: yes, that
22:49:20 <startling> ReinH, lists have fine semantics for this kind of operation.
22:49:44 <ReinH> Maybe, but sets probably have better semantics
22:50:04 <smith_> Oh, hey, there's a Data.Map.Lazy.keysSet. Hm.
22:50:25 <Twey> startling: Duplicates and ordering are irrelevant to one argument, so that should definitely be a Set
22:50:39 <Twey> What the other argument should be depends on smith_'s intended semantics
22:50:58 <startling> Twey, nah. [1, 1] is "remove two instances of 1"
22:51:28 <Twey> startling: That brings you up to a multiset (if that's what smith_ actually wants)
22:51:28 <smith_> Now that I know keysSet exists... I'll probably switch the other argument over to a Set, as that also shouldn't have any duplicates. Thanks!
22:51:43 <startling> smith_: heh.
22:51:52 <Twey> Heh
22:52:22 <smith_> Twey: I think something like :  Map.keySet table `difference` blacklist  : will do the job, where blacklist is a set.
22:52:47 <Twey> smith_: So you're preserving duplicates but not order?
22:53:14 <Twey> (table is a Map ElementType Integer, right?)
22:54:03 <smith_> Twey: No duplicates, order doesn't matter ; table is Map String String
22:54:29 <smith_> Since (unless I've got this wrong) Sets shouldn't have duplicate elements.
22:54:40 <Twey> Oh, that's a bit different to what you originally had
22:55:05 <Twey> No, it's fine if you're using a Map.  I just didn't know you wanted values associated with the elements in your container.
22:55:41 <smith_> Twey: Well, originally I was planning on something like this: Map.keys table \\ blacklist <- where table :: Map String String and blacklist :: [String]
22:55:59 <Twey> Aha
22:56:06 <Twey> Yep, keysSet seems like the thing to use, then
22:56:37 <smith_> Yep! And switching `blacklist` over to :: Set String also makes things more explicit in other places, as it shouldn't have any duplicates.
22:56:43 * Twey nods.
23:20:11 <Yep> hi, so in wai "data Application = Request -> ResourceT IO Response" and "type Middleware = Application -> Application". I'm wanting to create a Middleware that might fail.
23:20:17 <Yep> Would I be right in defining the following types? Or is there a better convention?
23:20:24 <Yep> "type MaybeApplication = Request -> Maybe (ResourceT IO Response)" and "type MaybeMiddleware = Application -> MaybeApplication"
23:20:55 <Javran1> @hoogle (Monad m) => (a -> b) -> a -> m b
23:20:56 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
23:20:57 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
23:20:57 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
23:23:08 <scott_> Javran1: That's just \f -> return . f
23:23:13 <scott_> :t \f -> return . f
23:23:14 <lambdabot> Monad m => (a -> b) -> a -> m b
23:24:01 <phi2_> Hi. I'm struggling with finding the right way to do something that's (hopefully) straightforward: I have a type class C c with some instances. I also have a data type B b, but b should be constrained to instances of A. I know how to do this with GADTs, but it seems like a common enough case to not need a language extension...
23:24:23 <Javran1> scott_: I want a (flip liftM)
23:24:48 <phi2_> Gah, *instances of C
23:24:57 <scott_> :t flip liftM
23:24:58 <lambdabot> Monad m => m a1 -> (a1 -> r) -> m r
23:25:07 <scott_> That's not what you were hoogling
23:25:07 <Javran1> scott_: hlint keep warning me to convert something like  xxxx >>= return . foo . bar >>=  yyyy to use liftM
23:26:41 <Javran1> ops.. you are right
23:27:04 <scott_> Looks like flip liftM isn't very popular, but I found at least one place where someone made an operator of it: http://hackage.haskell.org/package/genericserialize-0.1/docs/src/Data-Generics-Serialization-Standard.html
23:27:10 <scott_> They called it >>$
23:27:12 <Javran1> @fp \f -> return . f
23:27:12 <lambdabot> Maybe you meant: wn v rc pl id faq do bf @ ? .
23:27:25 <Javran1> @pf \f -> return . f
23:27:25 <lambdabot> Maybe you meant: pl bf
23:27:44 <Javran1> @pl \f -> return . f
23:27:45 <lambdabot> (return .)
23:28:20 <pavonia> Yep: If your middleware is doing IO this probably won't work. I guess you want something like "type MaybeApplication = Request -> MaybeT (ResourceT IO) Response"
23:30:23 <Twey> scott_: Isn't there an operator for flip fmap?
23:30:33 <Twey> Surely in lens at least :þ
23:31:22 <smith_> :q
23:31:22 <scott_> Twey: Yeah, I think people call it <&> (since fmap is <$> and & is a common opposite of $)
23:31:23 <Yep> pavonia: Thanks!
23:31:33 <smith_> (sorry, wrong window!)
23:31:54 <scott_> Twey: Like you said... both (&) and (<&>) are in lens :P
23:32:00 <udevd> :P
23:32:01 <Twey> scott_: Thought so.  That'd do it, then?
23:32:07 <Twey> phi2_: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
23:32:50 <scott_> Twey: Yeah (but you also need to add a Functor constraint because it isn't a superclass of Monad yet)
23:33:30 <Twey> phi2_: You can write data B b = ∀ b. A b ⇒ B b, but you shouldn't; see link
23:33:37 <Twey> Er
23:34:23 <Twey> Actually, not sure that's what you mean
23:36:06 <Twey> phi2_: I think GADTs are the way forward for this.  It's one of the dozen language extensions I enable by default these days :þ
23:36:14 <Twey> Sorry for confusion.
23:36:59 <phi2_> Twey: thanks for the info. I'm very new to this, so I wasn't sure about enabling GADTs
23:37:00 <Twey> phi2_: The ‘traditional’ way to do it is to put the constraints on the functions where you use the type
23:37:37 <Twey> Including, perhaps, a ‘constructor’ (and not exporting the real constructor)
23:37:53 <Twey> GADTs give you a nicer way to do that
23:38:22 <phi2_> Twey: that's what I've been reading. it's annoying since in my code, it really doesn't make sense to pass anything to B that isnt a C
23:38:58 <phi2_> i'll go with GADTs, thanks again
23:43:46 <Javran1> scott_: maybe I can use arrow, like Kleisli xxx >>> arr bar >>> arr foo >>> Kleisli yyy ?
23:45:45 <scott_> Javran1: I suppose, but that seems overcomplicated
23:46:38 <Javran1> scott_: yes, just wondering about that
