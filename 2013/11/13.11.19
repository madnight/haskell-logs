00:02:48 <s2r2> > pl (\f -> length . filter f)
00:02:49 <lambdabot>   Not in scope: `pl'
00:02:49 <lambdabot>  Perhaps you meant one of these:
00:02:49 <lambdabot>    `pi' (imported from ...
00:04:12 <s2r2> @pl (\f -> length. filter f)
00:04:13 <lambdabot> (length .) . filter
00:04:41 <s2r2> hm… but is it more readable?
00:21:36 <Twey> s2r2: Opinions differ.  The preferred way tends to be to define an operator (.:) = (.) . (.) and use that (length .: filter).
00:22:14 <s2r2> Twey: oh.  that looks good. thanks for the insight
00:23:02 * hackagebot http-encodings 0.9.1 - A library for encoding and decoding bodies of HTTP messages  http://hackage.haskell.org/package/http-encodings-0.9.1 (AndreyChudnov)
00:23:02 * hackagebot jespresso 0.9 - Extract all JavaScript from an HTML page and consolidate it in one script.  http://hackage.haskell.org/package/jespresso-0.9 (AndreyChudnov)
00:42:08 <augur_> no quchen :(
00:54:17 <TheBrayn> http://lpaste.net/95894 any idea why I'm getting this error message?
00:55:43 <TheBrayn> and how should I break the long line?
00:55:55 <Fuuzetsu> sure, because you don't have a list somewhere where you should have on
00:55:56 <Fuuzetsu> one*
00:56:11 <TheBrayn> but where?
00:56:38 <Fuuzetsu> >    In the expression: n
00:56:40 <lambdabot>   Not in scope: `the'Not in scope: `expression'
00:56:40 <mauke> vice versa
00:56:49 <mauke> Fuuzetsu: that's not the first error
00:57:01 <Fuuzetsu> oh so it isn't
00:57:04 <mauke> sum ([...] : ...)
00:57:09 <mauke> what is wrong with this picture?
00:57:40 * Fuuzetsu is very tired and hungry and was dealing with >>>mutable state<<< all night
00:57:41 <TheBrayn> oh I see
00:59:12 <TheBrayn> it has to be ++ instead of : of course
01:01:16 <haskellite> hey, can anyone tell me why [((-1) ^ (n - 1) * n ^ 2 / 10^n) | n <- [1..5]] makes the type system angry?
01:01:47 <ion> The compiler probably could.
01:02:26 <mauke> > [((-1) ^ (n - 1) * n ^ 2 / 10^n) | n <- [1..5]]
01:02:28 <lambdabot>   No instance for (GHC.Show.Show b0)
01:02:28 <lambdabot>    arising from a use of `M2537556930459...
01:02:44 <mauke> :t (^)
01:02:45 <lambdabot> (Integral b, Num a) => a -> b -> a
01:02:47 <mauke> :t (/)
01:02:47 <lambdabot> Fractional a => a -> a -> a
01:03:01 * hackagebot zasni-gerna 0.0.5 - lojban parser (zasni gerna)  http://hackage.haskell.org/package/zasni-gerna-0.0.5 (YoshikuniJujo)
01:03:04 <mauke> because you're using n with both / and ^, so it has to be both Integral and Fractional
01:03:07 <mauke> and there is no such type
01:03:17 <haskellite> oh
01:03:52 <TheBrayn> what's the fractional equivalent of ^?
01:03:57 <mauke> **
01:04:04 <haskellite> hm
01:04:41 <ion> > [((-1) ^ (n - 1) * n ^ 2) % (10^n) | n <- [1..5]]
01:04:43 <lambdabot>   [1 % 10,(-1) % 25,9 % 1000,(-1) % 625,1 % 4000]
01:04:57 <haskellite> no is it
01:05:03 <haskellite> is it **?
01:06:36 <ion> > [fromInteger ((-1) ^ (n - 1) * n ^ 2) / fromInteger (10^n) | n <- [1..5]]
01:06:37 <lambdabot>   [0.1,-4.0e-2,9.0e-3,-1.6e-3,2.5e-4]
01:06:39 <haskellite> thanks
01:06:40 <haskellite> that worked
01:06:44 <haskellite> the ** operator
01:07:15 <haskellite> lol i'm using it to calculate sums of series for math hw...
01:07:19 <tero-> is there a Haskell library to modify .cabal files?
01:07:53 <mauke> @index removeFile
01:07:53 <lambdabot> System.Directory, Distribution.Compat.Directory
01:07:58 <dcoutts_> tero-: the Cabal lib has a parser + pretty printer. But there's no help for preserving layout, comments etc.
01:08:38 <tero-> dcoutts_: I'd just want to modify the list of exposed-modules
01:08:51 <mauke> sed
01:09:10 <dcoutts_> tero-: in what context?
01:09:52 <tero-> dcoutts_: a code generator that outputs a Yesod subsite to work with an RDBMS
01:10:19 <tero-> it outputs a bunch of modules, partly because of TH and GHC stage restriction and partly because ghc just blows up if everything is in the same module
01:10:28 <dcoutts_> tero-: ok, so you're generating the whole .cabal file?
01:10:50 <tero-> dcoutts_: at the moment no, I don't want it to be that intrusive
01:11:33 <dcoutts_> tero-: if you don't need to preserve layout & comments, then using the Cabal parser+pretty printer should be fine
01:11:43 <dcoutts_> and it's not a lot of code
01:12:00 <tero-> dcoutts_: okay. thanks for the tip. I'll use it
01:12:20 <tero-> dcoutts_++
01:12:21 <drbean> I'm running 'cabal-dev install' to build this app in a sandbox, but it is saying it's probably going to break regex-compat and haskell-platform.
01:12:55 <drbean> That'd be OK, if it weren't the same message I got building it without cabal-dev.
01:13:37 <drbean> Is cabal-dev going to break haskell-platform in the sandbox, or globally?
01:19:53 <tdammers> sandbox
01:19:58 <tdammers> that's what cabal-dev is for
01:20:13 <tdammers> although with recent cabal versions, cabal sandbox may be a better choice
01:23:36 <drbean> Apparently cabal-dev uses system ghc, so I'm afraid it's going to break haskell-platform.
01:25:13 <drbean> http://lpaste.net/95895
01:27:36 <supki> cabal-dev uses system ghc and globally installed packages
01:27:47 <supki> but everything it installs is only visible inside its sandbox
01:28:04 <supki> so it only can break globally installed packages inside its sandbox
01:29:58 <tdammers> yeah
01:30:09 <tdammers> basically, system packages are read-only to cabal-dev
01:33:04 * hackagebot cuda 0.5.1.1 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.5.1.1 (TrevorMcDonell)
01:35:02 <chrisdotcode_> is there a convention for a value, when you know it's going to be discarded?
01:35:17 <chrisdotcode_> for example, I have a tuple, (_, y), where _ could be anything. what value should I make it?
01:36:07 <tarmil> () probably
01:37:31 <chrisdotcode_> tarmil: oh, that's excellent! thanks (I was using id)
01:38:03 <tarmil> yeah () was pretty much created for cases like yours
01:38:04 * hackagebot accelerate 0.14.0.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.14.0.0 (TrevorMcDonell)
01:43:05 * hackagebot accelerate-cuda 0.14.0.0 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.14.0.0 (TrevorMcDonell)
01:43:07 * hackagebot accelerate-io 0.14.0.0 - Read and write Accelerate arrays in various formats  http://hackage.haskell.org/package/accelerate-io-0.14.0.0 (TrevorMcDonell)
01:48:05 * hackagebot pipes-shell 0.1.0 - Create proper Pipes from System.Process  http://hackage.haskell.org/package/pipes-shell-0.1.0 (kbrei)
01:52:41 <circle> are n+1 patterns deprecated
01:52:56 <simpson> circle: To say the least, yes.
01:53:03 <circle> simpson: why to say the least?
01:53:05 * hackagebot compdata 0.7.0.1 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.7.0.1 (PatrickBahr)
01:53:07 * hackagebot accelerate-fft 0.14.0.0 - FFT using the Accelerate library  http://hackage.haskell.org/package/accelerate-fft-0.14.0.0 (TrevorMcDonell)
01:53:30 <mauke> they're gone, man
01:53:34 <simpson> circle: n+k patterns aren't in Haskell 2010, and they've been recommended against for as long as I can remember.
01:53:37 <mauke> game over
01:53:49 <ion> dude
01:54:11 <circle> simpson: what's so bad about them?
01:54:45 <simpson> circle: They're a special case of pattern matching that forces the compiler to do a lot of extra work, IIRC.
01:55:26 <circle> simpson: ah, k.
01:55:37 <mauke> it's not that it's a lot of work, it's that it's very ad-hoc and irregular
01:55:49 <mauke> nothing else works like it
01:56:06 <taejo> they also don't really match up with signed numbers, which most Haskell numeric types are
01:58:37 <Twey> circle: They pretend that numbers are something they're not, and they have surprising behaviour as a result
01:59:34 <chrisirc> Hm. What would you use first to try to track down the reason for an out of memory condition?
02:00:16 <taejo> chrisirc: I'm no expert, but I'd try heap profiling
02:00:29 <taejo> that should at least show you which datatype is using up memory
02:00:43 <chrisirc> Yeah, that's one of those things that turns up in google, but, seems complicated to set up.
02:00:49 <taejo> not really
02:01:02 <chrisirc> Does it work in ghci?
02:01:11 <taejo> I don't think so
02:01:18 <johnw> is there a way to create an Attoparsec parser which simply always fails without consuming input?
02:01:23 <johnw> oh, I guess it's mzero
02:02:27 <chrisirc> In other language environments I would just look at the stack trace. And considering that ghc can show that, too, how would I simply enable showing it when an allocation fails?
02:03:06 * hackagebot gloss-accelerate 1.8.0.0 - Extras to interface Gloss and Accelerate  http://hackage.haskell.org/package/gloss-accelerate-1.8.0.0 (TrevorMcDonell)
02:03:08 * hackagebot gloss-raster-accelerate 1.8.0.0 - Parallel rendering of raster images using Accelerate  http://hackage.haskell.org/package/gloss-raster-accelerate-1.8.0.0 (TrevorMcDonell)
02:03:10 * hackagebot accelerate-examples 0.14.0.0 - Examples using the Accelerate library  http://hackage.haskell.org/package/accelerate-examples-0.14.0.0 (TrevorMcDonell)
02:03:18 <chrisirc> (What I mean is, if ghc can show a stack trace in the debugger on break points, then it should also be able to do it on errors, shouldn't it?)
02:04:08 <supki> @where stacktrace
02:04:08 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
02:05:03 <taejo> chrisirc: you can try -fbreak-on-exception
02:05:24 <taejo> I don't know if this applies to allocation errors
02:06:01 <taejo> but in general, ghc has the cooler tools than ghci
02:06:14 <taejo> you shouldn't be so afraid to compile your code :)
02:06:53 <chrisirc> not afraid, just slower turnaround. Difference between C-c C-l in emacs and having to go to the terminal..
02:07:26 <chrisirc> And, first problem I'm running into is that Prelude is not compiled with profiling, so my first reaction is this sounds like pain.
02:07:47 <chrisirc> I start to feel like to write any haskell program at *all*, you should install ghc from source.
02:08:17 <chrisirc> That's after already having run in tons of mess with cabal and the Debian ghc here.
02:08:36 <chrisirc> I hate compilation for this reason, basically.
02:08:51 <supki> you can use binary distribution instead
02:09:00 <supki> (that's what I use on Debian)
02:09:17 <chrisirc> supki, binary distribution of what?
02:10:01 <supki> chrisirc: ghc binary packages, http://www.haskell.org/ghc/download_ghc_7_6_3#x86_64linux for example
02:10:08 <chrisirc> Aha.
02:11:23 <supki> you only _need_ to build GHC from source if you want HEAD's features
02:11:35 <chrisirc> (Installing binaries from websites kinda feels like Windows.)
02:11:41 <mangaba_leitosa> "the probability that Pattern = 01 appears in a random binary string of length 4 is 11/16, while the probability that Pattern = 11 appears in a random binary string of length 4 is 8/16. This phenomenon is called the overlapping words paradox"
02:11:48 * mangaba_leitosa is shocked :-)
02:13:08 <simpson> chrisirc: If you installed the haskell-platform package, Debian also ships a haskell-platform-prof package with all the profiling libraries.
02:13:45 <chrisirc> simpson, ah, thanks!
02:13:54 <simpson> chrisirc: Sure.
02:30:00 <isomorphic> I'm messing around with some Data.Vector and I'd like to use few operators - euclidean distance for example.   Are these implemented somewhere already, or is the idea to just use mapping operations?
02:33:44 <rurufufuss> quick question: when I do map(\x -> x + 1) [1..5], how come I get a list of doubles/floating points as opposed to list of integers?
02:34:15 <ion> Because that was inferred from the surrounding context.
02:34:24 <ion> The expression itself doesn’t dictate the specific type.
02:34:26 <rurufufuss> never mind, the / division that I didn't mention was the cause
02:34:45 <ion> @type map (+1) [1..5]
02:34:47 <rurufufuss> `div` fixed it
02:34:48 <lambdabot> (Enum b, Num b) => [b]
02:35:11 <rurufufuss> oh that's a fancy bot
02:35:19 <rurufufuss> @eval map (\ x -> x + 1) [1..5]
02:35:24 <mauke> @help eval
02:35:24 <lambdabot> eval. Do nothing (perversely)
02:35:28 <ion> > map (+1) [1..5]
02:35:31 <lambdabot>   [2,3,4,5,6]
02:35:37 <rurufufuss> aha, cool, thanks
02:35:41 <mauke> > [2..6]  -- optimized
02:35:42 <lambdabot>   [2,3,4,5,6]
02:35:54 <ion> > [2,3,4,5,6] -- inlined enumFromTo
02:35:55 <lambdabot>   [2,3,4,5,6]
02:36:03 <mauke> but that's more typing
02:36:19 <mauke> > 2:3:4:5:6:[]  -- desugared list
02:36:21 <lambdabot>   [2,3,4,5,6]
02:36:22 <ion> Yes, but it makes the compiler’s job easier.
02:36:33 <ion> Won’t anyone please think of the compiler?
02:36:52 <rurufufuss> I do my best to help them by putting all my source code in ramdisk
02:37:03 <Twey> isomorphic: It's not that kind of a vector
02:37:07 <Hodapp> ramdisk? what is this, DOS?
02:37:29 <rurufufuss> ram mounted as HDD mate, it works great
02:37:29 <ion> My /tmp is a ram disk.
02:37:41 <mauke> my /swap is a ram disk
02:37:52 <maximveksler> My mind is a ram disk.
02:37:52 <isomorphic> Twey:  Understood.  Context is I was just about to start implementing a mathy typeclass, and then thought I'd ask the question to see if it had been done before
02:37:52 <rurufufuss> not that I have experience compiling lots of haskell code that makes it matter too much
02:38:05 <rurufufuss> technically, everybody's mind is a ram disk
02:38:09 <rurufufuss> since if they die the memory goes away
02:38:23 <Twey> isomorphic: It's a vector as in the C++ data structure, i.e. a resizable structure supporting constant-time lookup.  If you want actual vectors, consider using a linear algebra package like edwardk's linear
02:38:27 <mangaba_leitosa> maximveksler: so, is you mind made blank each type you are reset?
02:38:34 <mangaba_leitosa> maximveksler: each time
02:38:44 <Hodapp> rurufufuss: I highly doubt that you're better than the OS's disk caching when it comes to allocating a set amount of RAM to backing certain things that'd ordinarily go on a slower disk.
02:38:47 <isomorphic> Twey:  Perfect, thanks :)
02:38:48 <Twey> isomorphic: Or Vec also has vectors
02:38:49 <maximveksler> mangaba_leitosa: Yeah, but I reset upon death.
02:38:55 <mangaba_leitosa> :-)
02:39:04 <rurufufuss> Hodapp: well, I tested it.. so much speedup
02:39:12 <ion> My mind doesn’t support random access. I wouldn’t mind (no pun intended) if it did.
02:39:46 <Hodapp> rurufufuss: what did you test?
02:40:03 <rurufufuss> Hodapp: 300k sloc c++ code base
02:40:19 <rurufufuss> not related to #haskell probably though, but it did help
02:40:42 <Twey> ion: My mind supports *only* random access…
02:40:58 <Hodapp> rurufufuss: what were the time differences of cold caches vs. hot caches vs. RAM disk?
02:41:02 <haasn> My mind only supports sequential access
02:41:22 <Twey> haasn: Any time you want to remember something, you have to start back in the womb?
02:41:29 <rurufufuss> Hodapp: I only tested two things, compiling from the directory that was located in the HDD, and compiling from the directory that was mounted on RAM
02:41:30 <haasn> Twey: it's a big continuous cycle
02:41:39 <Twey> Touché
02:41:41 <rurufufuss> speedup is by a factor of two, or three?
02:42:03 <Hodapp> rurufufuss: You copied everything into RAM, and you didn't bother to test on a hot cache?
02:42:23 <rurufufuss> Hodapp: no idea what a hot cache is, enlighten me?
02:43:02 <Twey> Heh, the Vec docs are disturbing.  ‘Sometimes you will get an error about a lack of instances.  This is just how GHC reports type errors.  Check you're not doing something stupid, then add a type annotation.’
02:43:55 <rurufufuss> wait, if you mean that hot cache is when after you repeatedly access the source code over and over, then that's been done as well
02:44:09 <rurufufuss> assuming linux does that automatically
02:45:34 <mrmonday> I'm using Text.printf - is it possible to use positional args eg %3$s?
02:46:12 <mrmonday> (I wanted to use Text.Format so I didn't have to use that horrible syntax, unfortunately I can't use libraries which aren't in the base lib for what I'm working on)
02:49:09 <mauke> mrmonday: I doubt it
02:57:08 <isomorphic> Twey:  Not ideal, but it is refreshing to at least have an indication of where the dragons might be
03:04:10 <merijn> The main problem is: non-trivial type errors are hard
03:04:32 <merijn> IFL had three talks on improving error messages, even those had a lot of weakspots and required serious engineering work
03:07:39 <chrisirc> I'm using ghc -prof and +RTS -hc  but the resulting memory profile does not reflect my rising memory use.
03:08:20 <chrisirc> Either it shows allocations/second and not amount of live memory, or it does it different for some options, or something's broken.
03:10:32 <chrisirc> Sigh, I still have *no* solution to help me track down my out of memory situation.
03:20:43 <merijn> chrisirc: I'm not too familiar with either, but did you check the profiling chapter in Real World Haskell? I believe that walks through tracking down a memory issue
03:25:36 <jtcwang> I'm trying to setup haskellmode-vim with vim, but i'm running into errors when i open a *.hs file up. Can anyone help me?
03:30:43 <ehamberg> jtcwang: check :messages in vim and see what the errors are.
03:31:11 <ehamberg> (that will list the error messages that appeared when you started vim.)
03:32:05 <jtcwang> it says that it cannot find haddoc html location. but i think i just saw something on it so i'll try it now
03:37:55 <jtcwang> ok looks like error is gone for now, I'll just write w/e I want to do :make to run it correct?
03:41:45 <circle> if i have a line like so:  mult = \x -> (\y -> (\z = x * y * z))
03:41:50 <circle> why does it give a parse error in input '
03:41:55 <circle> "="
03:44:11 <supki> you have two "=" in that line
03:44:22 <supki> the second one is illegal syntax
03:44:23 <johnw> second = should be ->
03:48:39 <chrisirc> merijn, I haven't read that one, will make mind mark to do that next time. I've now tracked the issue down somewhat, with the help of ghci's debugger.
03:49:15 <chrisirc> (employing some strategic thinking about where to set breakpoints, then using :trace)
03:49:37 <chrisirc> (not exactly what I call debugging friendly, but at least.)
03:54:26 <circle> oh ri9ght
04:22:12 <mfzb> @tobib: kurze js-frage?
04:22:12 <lambdabot> Unknown command, try @list
04:22:28 <tdammers> mfzb: wrong channel?
04:24:02 <mfzb> yes.
04:24:04 <mfzb> sorry.  :/
04:35:59 <Javafant> Hi, I'd like some input on the first haskell program I've written. It does what I want but I feel like I'm using the io monad incorrectly. I somehow “get stuck” in it. here's the code http://lpaste.net/95900 (if this is not the right place to ask such questions I would appreciate if someone could point me to the right place)
04:38:45 <donri> Javafant: fetching a http resource is gonna require IO, yes. any processing of it could probably be purified, though
04:39:29 <Javafant> Ok, so I'll try to separate this as much as possible.
04:39:36 <donri> HXT wants IO though to do things like follow DTDs and xml includes and other such things you probably don't care for
04:39:49 <donri> there's probably some way to run a pure xml arrow
04:39:50 <int-e> Javafant: well, nothing wrong with that, since most of the things you are actually doing require IO. (The extra processing is small, so perhaps not worth factoring out.)
04:40:15 <donri> but yes it's perfectly fine as it is, for something this small and simple
04:40:44 <jophish__> Can lambdabot show its working for @pl?
04:41:05 <Javafant> ok, is there a way to get rid of the if else and use pattern matching instead? I tried to remove it but I wasn't able to do so.
04:42:02 <donri> > T.fold (take 1 ["foo","bar"])
04:42:04 <lambdabot>   Not in scope: `T.fold'
04:42:04 <lambdabot>  Perhaps you meant one of these:
04:42:04 <lambdabot>    `F.fold' (import...
04:42:13 <donri> > F.fold (take 1 ["foo","bar"])
04:42:14 <lambdabot>   "foo"
04:42:19 <donri> > F.fold (take 1 [])
04:42:20 <lambdabot>   ()
04:42:24 <donri> > F.fold (take 1 []) :: String
04:42:25 <lambdabot>   ""
04:43:04 <mr-> donri: would you really write it like that in your code?
04:43:29 <donri> quite possibly
04:43:33 <donri> or the lens version of the same thing
04:44:46 <mr-> somehow I find the "if then else" much easier to understand on first glance. ;-)
04:44:51 <donri> > [] ^. _head :: String
04:44:52 <lambdabot>   ""
04:44:58 <donri> > ["foo","bar"] ^. _head :: String
04:44:59 <lambdabot>   "foo"
04:45:14 <donri> duno, guess i'm used to thinking in terms of monoids and foldable etc
04:46:29 <donri> admittedly "take 1" is a bit of a hack, i'd rather use "head" and have that return a Maybe. ie, listToMaybe but not with a crappy name
04:46:41 <donri> > F.fold (listToMaybe ["foo","bar"])
04:46:42 <lambdabot>   "foo"
04:46:46 <benj_> I'd probably make it fetchComitLink :: String -> IO (Maybe String)
04:47:09 <donri> and yeah i'd probably make it a different type too :)
04:47:24 <piezo_> @hoogle f a -> f b -> f a
04:47:25 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
04:47:25 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
04:47:25 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
04:47:45 <piezo_> @pl \f g -> (const <$> f) <*> g
04:47:45 <lambdabot> (<*>) . (const <$>)
04:47:48 <mr-> and have a mapMaybesConcurrently? :-)
04:48:50 <donri> well you can fold a maybe back to a list
04:58:56 <drbean> How do I find in what version of a module a function appeared?
05:12:00 <quchen> drbean: Trial and error :-\
05:12:35 <quchen> But you can do binary trial and error so you'll find what you're looking for in O(log(n)).
05:13:08 <bergmark> drbean: http://hdiff.luite.com/
05:13:59 <bergmark> you still need to binary search though ;o
05:18:18 <donri> does hayoo index only the latest version?
05:19:31 <bergmark> someone should set up a what's-changed using hs-gen-iface
05:20:11 <mkay_> hi
05:20:30 <mkay_> so, I've got (pure) code that uses a HashMap
05:20:49 <mkay_> and I've rewritten it to use a HashTable (which is presumably faster)
05:20:58 <mkay_> the problem is, now I'm stuck in the IO monad
05:21:29 <mkay_> of course I can escape that monad using unsafePerformIO
05:21:48 <mkay_> which, in my understanding, isn't that unsafe in this case, since the only side effects I'm causing are within that hash table
05:21:54 <mkay_> thoughts?
05:25:09 <donri> mkay_: use the ST interfaces, they're do this for you safely
05:26:17 <donri> i don't know if unsafePerformIO is unsafe for this in the sense of segfaults and such, but it's unlikely to behave predictably
05:26:59 <mkay_> donri: I can't, the platform I'm writing this for doesn't have the hashtable package...
05:27:36 <bergmark> won't unsafePerformIO break persistence?
05:28:15 <mkay_> bergmark: what do you mean?
05:28:16 <supki> mkay_: what hashtable implementation are you using then?
05:28:23 <mkay_> supki: Data.HashTable...
05:28:42 <supki> mkay_: I doubt it's faster than HashMap
05:28:42 <mkay_> which I know has issues, but I'd still wager it's faster than HashMap ^^
05:28:49 <supki> mkay_: did you measure it?
05:29:21 <mkay_> supki: I don't have the data this will get measured with, it's a coding challenge of sorts...
05:29:53 <donri> what package is that from?
05:29:57 <supki> base
05:30:20 <bergmark> f hashtable = (unsafePeformIO (someUpdate hashtable), hashtable), now fst and snd should be distinct
05:30:22 <donri> oh, never looked at that :D
05:30:38 <bergmark> donri: it was deprecated in 7.6
05:30:42 <donri> yeah
05:31:02 <mkay_> supki: but since I've got a pretty good idea of what the maximum element count in the table/map is going to be, I figured creating a big enough HashTable would pretty much be guaranteed to get the best performance
05:31:23 <mkay_> since I don't run into rehashing, and inserts/lookups should be O(1) instead of O(log n)
05:31:30 <mkay_> bergmark: yep, most likely
05:31:44 <mkay_> bergmark: I'm not using that hash table outside of the IO actions though
05:31:54 <donri> what sort of platform doesn't allow you to install packages?
05:32:02 <mkay_> donri: a coding challenge platform ^^
05:32:06 <Hodapp> the Republican platform?
05:32:09 <mkay_> heh
05:32:19 <Hodapp> who's gonna pay for the packages anyway?
05:32:33 <Hodapp> it's always "install this, install that" and no one ever answers who's going to pay for it
05:32:41 <mkay_> import System.Unsafe.Obamacare
05:32:41 <Hodapp> why? because it's always hard-working fellows like myself who pay for it
05:32:52 <donri> mkay_: are you sure you need a hash table though? have you considered vector or array?
05:33:46 <mkay_> donri: no, I didn't really consider them, as the challenge is to deal with huge amounts of data (requiring inserts/lookups) as fast as possible
05:34:03 <donri> mkay_: yes, that's what vector is good at
05:34:23 <mkay_> donri: ah, really? let me check that out
05:35:43 <mkay_> donri: it only works on indices though, as far as I can see
05:36:03 <mkay_> I need lookups for a more complex type
05:37:09 <donri> mkay_: so hash your keys yourself ;)
05:38:57 <mkay_> donri: and traverse the vector every time, looking for that hash?
05:39:05 <mkay_> I doubt that could be very performant
05:39:13 <mangaba_leitosa> > let l = "abcdefghijkl" in reverse . fst $ until (null . snd) (\(acc, list) -> let (hd, tl) = splitAt 3 list in (hd:acc, tl)) ([], l)
05:39:15 <lambdabot>   ["abc","def","ghi","jkl"]
05:39:17 <donri> you hash to an int, the int is the index?
05:39:28 <mangaba_leitosa> is there a shorter way to split the list into groups of 3 elements?
05:40:30 <TheBrayn> I'd say recursion and pattern matching
05:40:36 <mkay_> donri: you can't specify an index when inserting an element
05:40:55 <mkay_> donri: so I'd have to have 2^32 elements to cover all hashes...
05:41:05 <donri> true
05:41:42 <mkay_> supki: why do you think HashMap is as fast as HashTable?
05:42:07 <mangaba_leitosa> TheBrayn: pattern matching on 'a:b:c:tl' ?
05:42:14 <TheBrayn> yes
05:42:18 <mangaba_leitosa> TheBrayn: ok, what's about n elements, not 3?
05:42:45 <lpaste> lasticot pasted “Pattern Matching” at http://lpaste.net/95902
05:42:49 <TheBrayn> meh :P
05:42:54 <mm_freak_> HashMap is /not/ as fast as a hash table
05:43:08 <mm_freak_> it's sometimes faster, but often slower, because it is still a tree structure
05:43:19 <mangaba_leitosa> TheBrayn: thanks :-)
05:43:25 <mkay_> mm_freak_: that's my understanding also
05:43:36 <mangaba_leitosa> TheBrayn: I was thinking about a smart way of using standard library functions, though
05:43:51 <lasticot> In this example http://lpaste.net/95902, would the variable i be overridden in the guard?
05:44:03 <Cale> lasticot: That won't work -- case binds variables which occur in the patterns. The i which the case binds will shadow the i which is bound as the parameter to foo
05:44:15 <mm_freak_> if you want a real (fast) hash table, you'll have to write imperative code, because it critically relies on destructive update
05:44:29 <Cale> also, the otherwise will shadow the Prelude definition of otherwise
05:44:30 <mangaba_leitosa> lasticot: yes, looks like you need to do 'len | l == i -> '
05:44:45 <Cale> (but that branch will never be reached, because the pattern i will match anything)
05:44:55 <Cale> > otherwise
05:44:56 <lambdabot>   True
05:44:59 <mangaba_leitosa> in Scala, you can use `i` -> in such cases (backquotes)
05:45:03 <mkay_> mm_freak_: imperative as in monadic?
05:45:11 <Cale> ^^ otherwise is meant to be used in guards as a synonym for True
05:45:11 <mangaba_leitosa> is there something similar for Haskell?
05:45:14 <mm_freak_> mkay_: likely IO/ST-monadic
05:45:23 <mkay_> mm_freak_: yeah, that's what I have
05:45:28 <Cale> mangaba_leitosa: just the guard
05:45:38 <mkay_> mm_freak_: now I'm stuck in the IO monad... even though the function is, in itself, pure
05:45:39 <mangaba_leitosa> Cale: I see. Too long :-(
05:46:00 <mm_freak_> mkay_: is there a reason why you use a hash table instead of a Map/HashMap?
05:46:04 <mkay_> as in, I'm creating a hash table, operating on it, and get a result from it
05:46:08 <mkay_> mm_freak_: speed
05:46:10 <lasticot> Cale, mangaba_leitosa: thank you
05:46:14 <mm_freak_> mkay_: did you benchmark?
05:46:41 <mkay_> mm_freak_: no, I don't know which kind of data this will be run with... it's a sort of coding challenge
05:46:48 <donri> > [ a | (a,b) <- map (take 3) (tails [1..10]) `zip` [1..], b `mod` 3 == 1 ]
05:46:49 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
05:47:20 <Cale> mkay_: Insert/lookup being O(1) for hashtables is a myth, btw.
05:47:21 <mm_freak_> mkay_: in general you should just use Map…  it's a very fast data structure suitable for pure functional code
05:47:21 <mkay_> so I just assume the worst, and use the structure that deals well with a lot of elements
05:47:24 <mangaba_leitosa> donri: thanks, this one is shorter :-)
05:47:49 <Cale> You can't write a function whose range has n distinct elements which is any faster than O(log n) time.
05:47:52 <mm_freak_> mkay_: hash tables don't deal well with a lot of elements, unless you query only
05:48:36 <mkay_> mm_freak_: even if I specify a big enough size beforehand?
05:48:36 <mm_freak_> in fact Map may outperform a hash table there
05:48:39 <Cale> Because you need at least O(log n) bits of input to merely distinguish between n distinct cases
05:49:05 <mm_freak_> mkay_: "big enough"?  you said you don't know how much data will be there
05:49:21 <mkay_> mm_freak_: I know a upper limit at the time my function is run
05:49:48 <mkay_> which I'd shamelessly use when creating the hashtable
05:50:04 <mm_freak_> mkay_: well, the only way to tell is to benchmark
05:50:19 <mm_freak_> don't be surprised if Map/HashMap perform better than a hash table
05:50:35 <donri> mkay_: anyway this is exactly what ST is for: local and isolated pure mutation
05:50:53 <donri> mkay_: that's why packages for mutable data structures almost invariably provide ST interfaces
05:50:55 <mkay_> donri: I'd have loved to use the new hash tables :/
05:51:30 <donri> mkay_: well your original question was if there was a way to avoid IO with a hash table. the answer is yes, but not with Data.HashTable ;)
05:51:56 <khyperia> I'm reading through the wikipedia on Hindley-Milner, is the reasons lambdas can't be polymorphic in their parameter because that would create a type with quantifiers inside the type? (aka forall a. a -> (forall b . b -> b) -> a)
05:51:57 <mm_freak_> mkay_: furthermore Map/HashMap allow data parallelism…  making use of multiple CPUs/cores will be pretty much adding a word to your source code
05:51:58 <mkay_> but, taking a step back, is it correct that I'm 'stuck' in IO if my function does anything IOish, even if all the actions are contained within it?
05:52:10 <Cale> khyperia: Well, that's what that means
05:52:14 <mm_freak_> mkay_: in this case yes
05:52:41 <mkay_> mm_freak_: okay, good, I was fearing I was just doing something wrong :P
05:52:45 <Cale> khyperia: So yeah, kinda.
05:52:47 <mm_freak_> mkay_: hash tables are inherently destructive, so every operation has to be an IO/ST action
05:52:49 <khyperia> Right.
05:53:00 <mangaba_leitosa> > [ a | (a,b) <- map (take 3) (tails [1..9]) `zip` [1..], b `mod` 3 == 1 ]
05:53:01 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[]]
05:53:03 <donri> mkay_: there are safe and correct uses of unsafePerformIO, but there are lots of gotchas to look out for and consider, easy to get wrong
05:53:10 <mm_freak_> mkay_: for the calculations inbetween these operations you can still write regular pure functions
05:53:19 <mangaba_leitosa> donri: I inserted 'init' to get rid of [] in the end :-)
05:53:31 <donri> mangaba_leitosa: that won't work in the general case though
05:53:47 <mangaba_leitosa> donri: 'general case'?
05:54:06 <mm_freak_> mkay_: again, don't just blindly assume that the hash table is the fastest data structure…  benchmark!
05:54:07 <mangaba_leitosa> donri: ah, in case of an even number I think :-)
05:54:13 <donri> mangaba_leitosa: what if the input is already divisible by N?
05:54:20 <mangaba_leitosa> donri: right
05:54:29 <mm_freak_> mkay_: Map sometimes outperformed both HashMap and hash tables for me, simply because the hashing is not there
05:54:34 <donri> > [ a | (a,b) <- map (take 3) (tails [1..10]) `zip` [1..], b `mod` 3 == 1, length (take 3) a == 3 ]
05:54:35 <lambdabot>   Couldn't match expected type `[a0] -> a2'
05:54:35 <lambdabot>              with actual type `GH...
05:54:39 <mkay_> mm_freak_: I will have the benchmark... after the challenge is over :D
05:54:42 <donri> > [ a | (a,b) <- map (take 3) (tails [1..10]) `zip` [1..], b `mod` 3 == 1, length (take 3 a) == 3 ]
05:54:43 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
05:55:15 <Cale> mm_freak_: I hate how everyone always seems to assume that hashing is free or constant time.
05:55:26 <mm_freak_> Cale: indeed
05:55:45 <mangaba_leitosa> donri: thanks :-)
05:56:16 <donri> hashing also gets you all kinds of new problems like collisions and hash dos...
05:56:27 <mkay_> Cale: well, I only assumed it would be faster to hash a (string, string)-tuple instead of using it as a key directly...
05:57:01 <mm_freak_> mkay_: literally (String, String)?
05:57:06 <mkay_> mm_freak_: yes
05:57:16 <Cale> mkay_: In order to hash the tuple, you have to process it in some way. Probably you'd consume the entire pair of strings.
05:57:19 <mm_freak_> i thought this is about performance
05:57:34 <FireFly> To hash it you'd need to traverse the entire string. to put it in a balanced tree you don't necessarily need to do that, do you?
05:57:59 <mkay_> yeah, that's what struck me just now as well :P
05:58:03 <Cale> mkay_: In order to use it as a key in a Map, you'd have to compare it with O(log n) other pairs of Strings -- this may or may not involve looking at the entire first string even.
05:58:05 <mm_freak_> mkay_: but i'll let you lose the challenge, because sometimes it takes people to learn the hard way =)
05:58:24 <mkay_> mm_freak_: ah come on
05:58:53 <Cale> Hashtables *do* have some advantages sometimes
05:58:57 <Cale> But you pay for them
05:59:23 <mm_freak_> hash tables provide O(1) query under the assumption that hash is O(1), which is wrong in your case
05:59:25 <Cale> I'd always write something using Data.Map first, and only worry about other options if that turned out to be too slow.
05:59:29 <mm_freak_> for you hashing is O(n)!
05:59:37 <mm_freak_> not even O(log n), but O(n)
05:59:41 <Cale> er
05:59:43 <Cale> depends on the n
05:59:48 <mm_freak_> string length
05:59:56 <mkay_> mm_freak_: my strings aren't particularly long
06:00:03 <Cale> So, a different n :P
06:00:06 <mm_freak_> mkay_: your strings themselves are the next bottleneck
06:00:27 <mm_freak_> mkay_: see Data.Text and Data.ByteString
06:01:44 <mkay_> mm_freak_: good point...
06:02:06 <mkay_> ah shit, I didn't actually want to come here to get "unfair" advice :D
06:02:34 <bennofs> > undefined :: (forall a. m a -> x) -> t m a) id id
06:02:35 <lambdabot>   <hint>:1:43: parse error on input `)'
06:02:41 <bennofs> > (undefined :: (forall a. m a -> x) -> t m a) id id
06:02:42 <mm_freak_> mkay_: compare HashMap to Map
06:02:43 <lambdabot>   mueval-core: GhcException "panic! (the 'impossible' happened)\n  (GHC versi...
06:02:51 <bennofs> Is this a known bug?
06:02:51 <tarruda> I've written a binding to a simple C function that calls printf and returns a string. The string is returned successfully but it seems the printf calls only happen when I exit ghci. Why is that and how I can debug C code with printf?
06:03:08 <donri> bennofs: i think so
06:03:08 <mm_freak_> mkay_: if HashMap is slower than Map, then a hash table will be slower as well, because your hashing is too expensive
06:03:24 <mm_freak_> mkay_: for short Text (not String) strings this may well be the case
06:04:06 <mm_freak_> mkay_: if HashMap is only marginally faster, don't bother trying a hash table…  only if HashMap is really a lot faster than Map, it may pay off to go the ugly imperative hash table route
06:04:29 <mm_freak_> mkay_: finally i repeat that HashMap and Map support data parallelism, which a hash table doesn't support as easily
06:04:51 <mkay_> mm_freak_: yep, also a very good point
06:05:07 <merijn> Also, if you can hash to Int, IntMap will outperform Map on almost any key set
06:05:17 <FireFly> Wait, what is the difference between HashMap and "hash table" here?
06:05:29 <mm_freak_> FireFly: HashMap is basically Map on hashes
06:05:32 <bennofs> > (undefined :: (forall a. m a) -> t m a) id id
06:05:33 <lambdabot>   Couldn't match kind `* -> *' with `*'
06:05:33 <lambdabot>  Expected type: (a0 -> a0) -> a0
06:05:33 <lambdabot>    A...
06:05:34 <donri> mutability and persistence
06:05:40 <danbst> > let f xs = let (x, y) = splitAt 3 xs in if null y then [x] else [x] ++ f y in f [1..10]
06:05:41 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
06:06:01 <FireFly> mm_freak_: oh, so HashMap is also backed by a tree?
06:06:07 <mm_freak_> yeah
06:06:14 <FireFly> All right, got it
06:06:25 <tarruda> nevermind, I forgot stdout is line-buffered
06:06:38 <donri> danbst: much better
06:06:41 <mm_freak_> FireFly: sometimes (often for dynamic-size keys) comparing hashes is still faster than comparing values directly
06:06:49 <mm_freak_> FireFly: so you get the best of both
06:08:08 <mm_freak_> also HashMap has some balancing advantages…  depending on your keys, it may be expensive to balance Map, but it doesn't make a difference for HashMap
06:09:27 <bennofs> Does anyone have GHC HEAD and could test if :t (undefined :: (forall a. m a) -> t m) id id still panics on head?
06:12:18 <Janni> Hi.
06:15:07 <Janni> There's a package on Hackage that does not seem to be maintained anymore. It has a bug which breaks compilation. I sent a patch (very simple one) to the maintainer, but he doesn't react. Since a project of mine depends on it I'd like to have a working version on Hackage. Anyone has a suggestion? Is there a way to seize the package or should I simply create a new one?
06:16:11 <tdammers> fork it, rename it, upload to hackage
06:16:14 <merijn> Janni: It depends on the package, some are community maintained, other could be forked (depending on license)
06:16:24 <merijn> Janni: Additionally, have you tried contacting the maintainer?
06:16:37 <merijn> I tend to give a maintainer 2-3 weeks to respond before considering it abandonware
06:17:09 <Janni> merijn: Yes, as I said, he didn't react. A couple of tries over the last 8 months or so.
06:18:01 <merijn> ah
06:18:12 <merijn> Yeah, then I would just fork it
06:18:24 <Janni> OK. License is PublicDomain, so that should be possible.
06:19:36 <Janni> Is there maybe a naming scheme for such cases?
06:20:08 <Janni> To indicate that package A ist just a variant of B with a different maintainer?
06:20:29 <Fuuzetsu> You're free to just upload a new version
06:20:56 <Janni> Oh, am I?
06:21:02 * Janni is surprised
06:21:08 <Fuuzetsu> Yes, anyone with a Hackage account can upload things
06:21:26 <fryguybob> Fuuzetsu: I don't think that is the case with Hackage 2 now.
06:21:30 <Fuuzetsu> It's… a questionable practice but I don't think the maintainer system went into play
06:21:38 <Fuuzetsu> Oh, is that remedied now?
06:21:41 <merijn> Fuuzetsu: No he's not, that's always been considered wrong, and Hackage 2 shouldn't allow it
06:22:05 <merijn> hijacking a package like that should only been done after thorough discussion on libraries@ if everyone agrees
06:22:53 <Fuuzetsu> merijn: Well, he said that the maintainer didn't reply for 8 months but yes, asking in libraries@ with a week or two or discussion is advised, I didn't think of it
06:23:37 <Janni> OK. I'll do that then.
06:23:45 <Janni> Thanks for your thoughts.
06:24:21 <Fuuzetsu> Oh, it does seem like the maintainers thing is now in place, cool.
06:25:51 <Javafant> What is the easiest way to get the filename from a url like "http://example.com/long/path/filename"? uriPath returns everything after the first slash.
06:26:26 <donri> you could abuse System.FilePath.Posix
06:26:40 <k_89> in some other lang, i'd have done url.split('/').slice(-1)[0]
06:27:12 <Javafant> k_89: me aswell, but this I want to do it in haskell :)
06:27:37 <k_89> if i were you, i'd look for docs for the same thing
06:28:08 <mr-> Javafant: there's this, for example: http://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html
06:28:48 <Javafant> mr-: ah thx that seems to be easier than abusing filepath.posix as donri suggested
06:28:57 <mm_freak> that's not an abuse
06:29:02 <merijn> There is a URL parsing library, I forgot which, though
06:29:10 <mm_freak> since usually they do actually refer to POSIX paths
06:29:32 <mm_freak> but you may want to use Network.URI or Network.URL to extract the path first
06:29:40 <Javafant> hm
06:29:51 <mm_freak> the you can use a 'basename'-like function
06:29:54 <donri> not sure split will be easier, with filepath it's just "basename" or something like that
06:30:29 <Javafant> it's certainly more readable if I use the filepath function
06:30:32 <mm_freak> if you're looking for an example of an abuse, here is one:  <k_89> in some other lang, i'd have done url.split('/').slice(-1)[0]
06:30:40 <Javafant> :)
06:30:43 <k_89> haha
06:38:43 <sopvop> trying to use bound package, could not figure out how to get all the free variables from scope, suddenly realized that `foldMap (:[]) scope` should just work
06:47:35 <donri> :t F.toList
06:47:35 <lambdabot> Foldable t => t a -> [a]
06:51:39 <sopvop> oh
06:51:41 <sopvop> thanks
06:54:35 <emaphis> yay. I got ghc-mod working in emacs.
07:01:09 <piezoid> dumb question: why "parse (many anyChar)" always return Partial _ ?
07:01:29 <piezoid> parse (manyTill anyChar endOfInput) don't work neither
07:01:31 <Track_> hi, i am new at haskell and i need some help with recursion/index. pls query me
07:01:38 <Rembane> Track_: No. Ask here.
07:03:52 <Track_> i got this: tourLaenge (x:xs) = [dist!(a,b) | a <- x , b <- head [xs]!! 0] : tourLaenge (drop 1 xs)
07:04:41 <Track_> and i get the error:  Prelude.!!: index too large
07:04:42 <mauke> head [xs]  ಠ_ಠ
07:04:56 <chrisdone> lol
07:06:02 <Rembane> Track_: It's because you try to get an element from an empty list.
07:07:11 <Track_> oh oky
07:07:11 <piezoid> many anyChar may not be the best minimal example, but my parser work for one element, but not for many
07:07:43 <donri> piezoid: you sure you don't want parseOnly?
07:07:52 <piezoid> all the examples I found on internet use "many elemParser" without problems...
07:08:14 <piezoid> donri: oh.. yes, thank yout !
07:08:36 <Rembane> Track_: What do you want your code to do?
07:10:12 <Track_> it shall get the sum of distances between a permuttion of cities
07:10:19 <donri> piezoid: (or one of the .Lazy apis)
07:11:36 <donri> piezoid: when you "parse" a strict string type, attoparsec leaves it up to you to decide when you're "Done", and parseOnly is for when you're only parsing a single chunk
07:12:14 <Track_> dist!(a,b) gets a distance, but i am just so far that i get the sum of distances from A-B,A-C,A-D... nd not A-b,B-C,C-D
07:12:32 <Rembane> Track_: Ah. Cool.
07:12:51 <piezoid> I use the Text API, but maybe the Text.Lazy API is better for what I am doing (reading a list of nested {} blocks from a file) ?
07:13:18 <Rembane> Track_: What about [(x,y) | x <- cities, y <- cities], does it do what you want?
07:14:12 <donri> piezoid: if the file is large enough that you don't want to bring it all into memory, then you either want Lazy or manually feeding the incremental strict parser (or have something like pipes-attoparsec do that for you)
07:15:26 <piezoid> i see...
07:15:30 <Track_> do i get all distances without recursion?
07:16:12 <Rembane> Track_: Yes.
07:16:29 <alexander__b> if I have x and y, and I want to use them as as in f a b c, how do I do this? i.e. what's the shortest way to express (x', y') = (f x b c, f y b c)
07:16:47 <alexander__b> uhm *as 'a's
07:16:58 <Rembane> > [(x,y) | x <- [1,2,3,4,5], y <- [1,2,3,4,5]]
07:17:00 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
07:17:31 <tomejaguar> alexander__b: How about (x', y') = let g z = f z b c in (g x, g y)
07:18:32 <alexander__b> your suggestions are worse than just typing it out. in terms of readibility. maybe I'll just have that little duplication.
07:22:00 <tarruda> dcoutts: Can you take a look at a ffi binding I'm trying to write?
07:22:34 <dcoutts> tarruda: post it somewhere, someone might have a moment
07:22:37 * dcoutts is a bit busy
07:22:59 <dcoutts> and say what kind of feedback you're after
07:23:22 <tarruda> https://groups.google.com/forum/#!topic/haskell-cafe/TMgW_6LGXIE
07:23:50 <tarruda> Its a simple hello world binding to the v8 javascript engine
07:23:58 <tarruda> I would like to make it work :)
07:24:11 <haasn> alexander__b: let [x,y] = map (f ?? b c) [x,y]
07:24:13 <haasn> er
07:24:16 <haasn> let [x',y'] = ...
07:24:28 <haasn> only works for monomorphic types though
07:29:13 <leimy> Does anyone have a link to the paper where Haskell I/O gets close to linear scaling on 48 cores in a webserver?
07:30:24 <quchen> leimy: http://aosabook.org/en/posa/warp.html
07:31:17 <quchen> haasn: That shouldn't work for functions with 3 args though
07:31:27 <quchen> Wasn't there something with ?? just being useful for 2-argument ones?
07:32:09 <leimy> Ah the MIO paper is what I wanted
07:32:37 <leimy> http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
07:35:43 <haasn> quchen: oops
07:35:50 <haasn> quchen: f ?? b ?? c
07:35:56 <haasn> I think? don't quote me on this
07:36:09 <haasn> :t ?f ?? ?b ?? ?c -- heh
07:36:10 <lambdabot> (Functor f, ?f::f (a1 -> a -> b), ?b::a1, ?c::a) => f b
07:36:16 <haasn> :t \x -> f x b c
07:36:16 <lambdabot> FromExpr (t1 -> Expr -> Expr -> t) => t1 -> t
07:36:22 <haasn> :t \f b c x -> f x b c
07:36:23 <lambdabot> (t1 -> t2 -> t3 -> t) -> t2 -> t3 -> t1 -> t
07:36:49 <haasn> yeah seems right
07:37:26 <quchen> Any open questions?????????????
07:41:37 <dpld> @djinn (r a -> r b) -> r (a -> b)
07:41:37 <lambdabot> -- f cannot be realized.
07:44:25 <danr> @djinn r a -> r a
07:44:25 <lambdabot> f a = a
07:46:11 <dmj`> in ghci, can you run a program with sudo? like *Main> :sudo main -p 80
07:47:10 <danr> :!
07:47:52 <supki> dmj`: you can run external command with sudo like :!sudo ...
07:48:59 <Hafydd> :!sudo ghci
07:58:59 <FireFly> :t (??)
07:58:59 <lambdabot> Functor f => f (a -> b) -> a -> f b
07:59:14 <FireFly> Oh, right, that one
07:59:22 <Rembane> :t (???)
07:59:23 <lambdabot>     Not in scope: `???'
07:59:24 <lambdabot>     Perhaps you meant `??' (imported from Control.Lens)
07:59:25 <haasn> Doesn't ‘comonad’ have a dual for Applicative?
07:59:26 <Rembane> :(
07:59:53 <haasn> oh, ComonadApply
08:00:02 <haasn> :t (<@>)
08:00:03 <lambdabot>     Not in scope: `<@>'
08:00:03 <lambdabot>     Perhaps you meant one of these:
08:00:03 <lambdabot>       `<>' (imported from Data.Monoid),
08:00:06 <haasn> :t (Control.Comonad.<@>)
08:00:07 <lambdabot> Control.Comonad.ComonadApply w => w (a -> b) -> w a -> w b
08:00:17 <haasn> Shame dpld is already gone ;;
08:00:25 <haasn> Oh, that's not the same thing
08:05:01 <haasn> Something tells me that isn't possible either way
08:06:52 <haasn> of course, (,) Void is a legal Comonad and that would imply f (id :: (Void,a) -> (Void,a)) :: (Void, a -> a)
08:08:37 * hackagebot flowsim 0.3.5 - Simulate 454 pyrosequencing  http://hackage.haskell.org/package/flowsim-0.3.5 (KetilMalde)
08:13:27 <d3lxa> are there anyone who knows how we can nest applicatives as this there: http://stackoverflow.com/questions/19755192/complex-record-form-in-yesod ? simplest as possible?
08:16:07 <tomejaguar> What would you call the encoding that takes '(a,b) -> c' to '(z -> a) -> (z -> b) -> (z -> c)' ?
08:17:30 <oleo> partial back-map ?
08:18:05 <tomejaguar> Why partial back-map?
08:31:56 <tomejaguar> It's sort of currying and lifting into the '(->) z' applicative
08:32:11 <tomejaguar> or just Functor I guess.
08:40:21 <haasn> :t liftA2 . uncurry -- not sure what your question is
08:40:25 <lambdabot> Applicative f => (a -> b1 -> b -> c) -> f (a, b1) -> f b -> f c
08:40:27 <haasn> :t liftA2 . curry
08:40:28 <lambdabot> Applicative f => ((a, b) -> c) -> f a -> f b -> f c
08:40:38 <Javafant> I'm looking for a simple library to get the dimensions of a png image. pngload seems to do that but it seems to be unmaintained and doesn't built withouth changes so I'd like to avoid using it.
08:42:57 <haasn> Javafant: if you don't mind loading the image you could use devil or juicypixels
08:44:04 <Javafant> haasn: ok thx
08:53:40 * hackagebot hsc3-process 0.10.0 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.10.0 (StefanKersten)
09:04:41 <Track_> i got  new problem; Syntax error in expression ( unexpected ' ; ', possibly due to bad layout) i tried  guard but i get every time this error message. examples from websites do not work as well. any ides what i am doing wrong?
09:04:56 <geekosaur> @lpaste
09:04:57 <lambdabot> Haskell pastebin: http://lpaste.net/
09:05:10 <geekosaur> otherwise, the idea I have of what your'e doing wrong is what the error message says :)
09:06:54 <Track_> it should be uploaded
09:07:35 <tomejaguar> Track_: send us a link?
09:07:50 <Track_> http://lpaste.net/95906
09:09:08 <supki> Track_: don't use tabs
09:10:16 <tomejaguar> Track_: Looks fine for me.
09:11:53 <Track_> removed the tbs and still same error message :/
09:12:16 <tomejaguar> Track_: Are you sure it's those lines that are the problem?
09:12:28 <tomejaguar> Do you have a missing closing something above?
09:12:48 <tomejaguar> If you paste the whole file it will be easier for us, or a minimum complete example that still has the error.
09:13:03 <Track_> it says line 14 and that is line 14
09:14:51 <quicksilver> I bet you still have some tabs.
09:15:00 <quicksilver> paste again exactly as it is now.
09:17:20 <Track_> http://lpaste.net/95908
09:19:03 <quicksilver> Track_: you need to line it up, just not with tabs.
09:19:12 <quicksilver> each | needs to line up with the first |
09:19:28 <quicksilver> so, 7 spaces before each | if I counted correctly
09:19:48 <quicksilver> > length "test x "
09:19:50 <lambdabot>   7
09:20:21 <quicksilver> (incidentally, using == and | is the wrong way to write that function but I expect you want to understand the syntax error anyway)
09:21:26 * mangaba_leitosa would write 'test Aachen = Koeln' and so on
09:22:20 <Track_> but /= with | would be correct?
09:23:28 <mangaba_leitosa> both == and /= are corret with |, they are just not needed for your function :-)
09:23:35 <mangaba_leitosa> "correct"
09:25:27 <tomejaguar> Track_: It depends what you're trying to do, but typically you should prefer pattern matching if you can.
09:25:56 <quicksilver> yes, it's just simpler
09:26:16 <quicksilver> it doesn't matter in this context (as much as we can guess) but it's arguably easier to read
09:26:28 <quicksilver> in same cases pattern matching is more applicable as it doesnt' require an Eq instance
09:32:19 <Track_> thx for help, it works now
09:33:24 <mangaba_leitosa> Track_: I would rewrite it like this: http://lpaste.net/95909
09:34:56 <tomejaguar> mangaba_leitosa++
09:37:54 <danbst> Track_: OMG, do you have `type Berlin = String` in your code?
09:38:09 <Track_> no those re dt types
09:38:27 <Track_> *sry my a key is not working correctly -.-
09:38:54 <danbst> got it. But how does `test` typecheck? It must return String
09:39:10 <Track_> no
09:39:20 <Track_> it returns the data city
09:39:40 <danbst> I'm talking about `otherwise = "Keine gültige Eingabe"`
09:39:58 <Track_> oh yeah you are right, deleted it^
09:42:34 <danbst> you can encode incorrect input with Maybe or Either. So you'll have test :: City -> Either String City
09:43:26 <intrados> I'm using `simpleHttp` from `Network.HTTP.Conduit` and getting an `Error_EOF` exception. I think it's coming from `tls`. Is there another simple network library I can use to test if the error is in `tls`?
09:52:43 <kayloos> How can I check what version of a package i am using with GHCI?
09:54:21 <Javafant> Hi, I'm trying to do something like this http://lpaste.net/95910 basicly I just want to get the height of width no matter of the format. However this gives typematch errors, so I'm looking for another way to solve this.
09:55:42 <chrisdone> kayloos: emm :show packages?
09:55:54 <chrisdone> ah, not that
09:56:17 <chrisdone> kayloos: last resort: ghci -v
09:56:30 <chrisdone> should print out a lot of stuff but included in there will be package versions
09:56:44 <intrados> Javafant: Are imageWidth and imageHeight functions in an image typeclass?
09:57:18 <jml> am feeling a bit blind: is there a way to get the month out of a UTCTime?
09:57:27 <Javafant> intrados: yes they're from juicypixels http://hackage.haskell.org/package/JuicyPixels-3.1.1.1/docs/Codec-Picture.html#t:Image
09:58:02 <Javafant> However they don't work on the dynamic image which I have before, so I need to do some deconstructing
09:58:14 <lingxiao> hey all, I'm having trouble implementing `Alternative` instance for my little toy parser and I'm wondering if someone could help
09:58:26 <kayloos> chrisdone: looks like the verbose option are only giving me the package names, not the versions
09:59:04 <kayloos> chrisdone: I am trying to run my code with a locally modified cabal package, without having to uninstall the official version
09:59:34 <intrados> Javafant: And what's the actual error?
10:00:06 <Javafant> intrados: http://sprunge.us/SZhT?hs
10:00:40 <Javafant> If i uncomment all but the first line it compiles but I get a runtime error because the pattern match does not always work.
10:01:44 <Javafant> actually it doesn't only work with the first line. I just need to uncomment all but one.
10:03:20 <chrisdone> kayloos: ghc-pkg list packagename?
10:04:50 <kayloos> chrisdone: That shows me the package versions i have installed, same as `cabal info packagename'. I am looking for a way to set one of the installed versions as active
10:05:16 <intrados> Javafant: You see how the type of `Image a` has the type variable `a`? When your code runs, that `Image a` has to take on a concrete type like `Image Pixel8`. So it's `imgWidth :: Image Pixel8 -> Int`. Of course, that only works for the first image. When it gets to the next one, it tries to match `imgWidth :: Image Pixel8 -> Int` against `Image PixelYA8` and fails.
10:06:01 <Javafant> intrados: I think I understand the error but I don't know how to work around it.
10:09:11 <chrisdone> kayloos: i think that's hide vs err no-thide
10:09:26 <FreeFull> Bleh, sometimes it's hard to avoid code duplication in imperative software
10:09:28 <chrisdone> ghc-pkg info hide will make something hidden
10:09:34 <chrisdone> there's the opposite command to expose it
10:09:46 <chrisdone> yeah, ghc-pkg expose
10:09:56 <kayloos> Ok, thanks
10:09:58 <chrisdone> ohhh
10:10:00 <chrisdone> you mean just for ghci?
10:10:04 <chrisdone> ghc -package foo-123
10:10:05 <intrados> Javafant: A simple, boilerplaty way would be to make a typeclass with an imgWidth' function
10:10:09 <chrisdone> ghci -package foo-123
10:10:55 <intrados> Javafant: But I also have the sense that there ought to be a way to do it with a GHC extension allowing higher rank polymorphism. But I'm not totally certain how that would go
10:11:18 <chrisdone> kayloos: try -package!
10:11:23 <chrisdone> kayloos: and there's -hide-package too
10:11:24 <danbst> intrados, Javafant: is it possible to make Functor instance for DynamicImage?
10:12:19 <danbst> ah, it will not help...
10:12:28 <Javafant> intrados: thx
10:12:45 <Javafant> danbst: I have to admit that I'm quite a newbie so it's not possible for me
10:12:51 <Javafant> I think I found a way, let me check
10:14:07 <Javafant> yep, I just need to get the dimensions directly in each case
10:14:20 <Javafant> looks a bit ugly but it works fine
10:14:21 <kayloos> chrisdone: -package was exactly what i wanted. Thanks again
10:16:58 <chrisdone> welcome!
10:17:08 <tomejaguar> jml: For example use utctDay to get the Day and then use toGregorian to get Y/M/D
10:18:28 <mangaba_leitosa> is there a typeclass/module/interface for writing polymorphic functions working on String, ByteString and Text?
10:18:53 <mangaba_leitosa> ByteString.Char8 even
10:22:08 <emaphis`> mangaba_leitosa: don't know. :-)
10:23:08 <mangaba_leitosa> emaphis: :-)
10:24:09 <emaphis> mangaba_leitosa: I wonder if there's a way to phrase that question to hoogle?
10:25:04 <mangaba_leitosa> emaphis: I only know the most simple 'string' query so far :-)
10:25:53 <mangaba_leitosa> emaphis: so for example I don't know how to find the '.:' operator using hoogle (it's from Data.Composition)
10:26:10 <joelteon> that's because hoogle only indexes about 15 packages
10:26:30 <mangaba_leitosa> joelteon: 15? Why not 1.5?
10:26:30 <emaphis> I have know idea, but maybe pass a typeclass signature? (if there is such a thing)
10:26:32 <hulahoop> Hi, can someone explain me why I can't code this command? http://lpaste.net/95911
10:26:42 <joelteon> mangaba_leitosa: ask the hoogle maintainer
10:27:42 <mangaba_leitosa> I tried hayoo and it does find '.:'
10:27:44 <triliyn> hulahoop: I think you mean third (_, _, c) = c
10:28:11 <joelteon> hayoo is both more useful than hoogle and completely useless because you can't make it into an Alfred custom searcher
10:28:29 <hulahoop> triliyn: now that you point it out, this seems most likely. Thanks triliyn
10:35:04 <lingxiao> could someone implement the `monadPlus` instance for this parser: `newtype ParserT a m b = Pt { runP :: [a] -> m (b, [a]) }`
10:35:32 <lingxiao> such that `mplus m1 m2` would run the first parser, and *only* if it fails, runs the second?
10:36:10 <maurer> mplus = (<|>)
10:36:23 <lingxiao> so how would you impelment (<|>) ?
10:36:33 <maurer> lingxiao: <|> is in the standard parsec lib
10:36:35 <lingxiao> `p1 <|> p2 = Pt $ \as -> runP p1 as `mplus` runP p2 as`
10:37:03 <maurer> http://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Prim.html#v:-60--124--62-
10:37:11 <lingxiao> yeah I have that open
10:37:35 <lingxiao> but the implementation of Parsec's parser is sufficeintly different from mine that I can't make head or tails of it
10:37:43 <lingxiao> parserPlus :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
10:37:44 <lingxiao> {-# INLINE parserPlus #-}
10:37:44 <lingxiao> parserPlus m n
10:37:45 <lingxiao>     = ParsecT $ \s cok cerr eok eerr ->
10:37:47 <lingxiao>       let
10:37:49 <lingxiao>           meerr err =
10:37:51 <lingxiao>               let
10:37:53 <lingxiao>                   neok y s' err' = eok y s' (mergeError err err')
10:37:55 <lingxiao>                   neerr err' = eerr $ mergeError err err'
10:37:57 <lingxiao>               in unParser n s cok cerr neok neerr
10:37:59 <lingxiao>       in unParser m s cok cerr eok meerr
10:38:01 <lingxiao> oops. sorry for the code dump. But that is (<|>) in parsec
10:38:06 <geekosaur> don't paste in channel please
10:38:21 <lingxiao> sorry about that, it was an accident
10:38:28 <maurer> lingxiao: Is your monad an instance of applicative?
10:38:31 <maurer> If not why not?
10:38:36 <lingxiao> it is
10:38:40 <maurer> Then you're done
10:38:51 <maurer> <|> is also in applicative
10:38:54 <dwcook> You'd need Alternative
10:38:56 <maurer> well, alternative
10:39:01 <maurer> which can be gotten from applicative
10:39:07 <dwcook> Alternative and MonadPlus basically serve the same purpose
10:39:11 <lingxiao> not automatically derived right?
10:39:28 <lingxiao> i still need to impleemnt either (<|>) or mplus
10:39:49 <mangaba_leitosa> In my program, I have a global variable table = Map.fromList [...], and I would prefer to store the table in a text file (e. g. CSV) rather than hardcoded in .hs, yet use the contents of this table like a global variable as before. Am I right at thinking that it's impossible unless I wrap all my functions using this var in an IO monad?
10:40:15 <dwcook> lingxiao, I think your parser type would need a way to signal failure. How does it do so?
10:40:34 <lingxiao> right now it would just be some `mzero` value
10:40:41 <maurer> mangaba_leitosa: You either need to initialize the table variable with unsafePerformIO to read it, or use the Reader monad
10:40:44 <dwcook> Right, but what is that value?
10:41:08 <lingxiao> oh it's not explicity expressed, im guessing I should express it?
10:41:13 <dwcook> How do I look at a value :: m (b, [a]) and know that it failed?
10:41:25 <lingxiao> you're right, i'm pig headed
10:41:42 <mangaba_leitosa> maurer: thanks, so it's possible :-) I'm going to check out these alternatives
10:41:45 <lingxiao> but something like `Result a b = Fail | (b,[a])` ould make sense
10:41:59 <dwcook> Yes, that could work. Though you left out the m
10:42:04 <maurer> mangaba_leitosa: As a note, the "correct" way to do it would be the Reader monad
10:42:11 <lingxiao> correct?
10:42:30 <lingxiao> or better yet `Fail String`
10:42:38 <mangaba_leitosa> maurer: OK, I'm going to learn how to use it then :-)
10:56:47 <ReinH_> chrisdone: can loeb be derived as a free theorem?
10:57:41 <ReinH_> mangaba_leitosa: how did you pass the "global variable" around?
10:57:49 * variable is global?
10:58:01 <ReinH> variable: you are everywhere
10:58:32 <ReinH> variable: enjoy your new hyperspace experience
10:59:55 <mangaba_leitosa> ReinH: I don't pass it, that's why it's global :-)
11:00:01 <joneshf-laptop> is thre a concise way to match a record with an as pattern, like if i wanted to match `t@(Tree n1 n2)`, but i didn't want to explicitly name `n1 n2`?
11:00:40 <ReinH> mangaba_leitosa: how do you access it if you don't pass it?
11:00:46 <ReinH> mangaba_leitosa: you just define it top-level?
11:00:52 <mangaba_leitosa> ReinH: right
11:00:56 <Eduard_Munteanu> joneshf-laptop: t@(Tree _ _) ?
11:01:12 <Eduard_Munteanu> joneshf-laptop: if that's not concise enough, consider   t@(Tree {})
11:02:03 <joneshf-laptop> Eduard_Munteanu, thanks, {} is perfect
11:02:23 <Eduard_Munteanu> > \j@(Just {}) -> ()
11:02:24 <joneshf-laptop> incidently, hlint suggested that when i tried your suggestion of underscores :)
11:02:25 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
11:02:25 <lambdabot>    arising from a use ...
11:02:41 <Eduard_Munteanu> > \j@(Just {}) -> 1
11:02:42 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
11:02:42 <lambdabot>    arising from a use ...
11:02:48 <Eduard_Munteanu> Hrm.
11:02:55 <geekosaur> trying to show a function?
11:02:58 <Eduard_Munteanu> Oh.
11:03:07 <Eduard_Munteanu> > \j@(Just {}) -> () $ Just 3
11:03:08 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a0 -> t0'
11:03:08 <lambdabot>              with ...
11:03:36 <Eduard_Munteanu> > (\j@(Just {}) -> ()) (Just 3)
11:03:37 <lambdabot>   ()
11:03:43 <Eduard_Munteanu> > (\j@Just {} -> ()) (Just 3)
11:03:44 <lambdabot>   ()
11:03:54 <Eduard_Munteanu> joneshf-laptop: ^^ is even more concise :)
11:04:05 <tac> @type Just {}
11:04:07 <Eduard_Munteanu> You don't need the parens, that is.
11:04:07 <lambdabot> Maybe a
11:04:24 <tac> Is Just {} the same as Just undefined?
11:04:35 <Eduard_Munteanu> tac: no, it just matches like Just _
11:04:42 <Eduard_Munteanu> tac: record syntax
11:04:43 <monochrom> it is a pattern
11:04:44 <tac> But it says it's a value :X
11:04:48 <tac> It has a type, somehow
11:04:52 <tac> @type Just _
11:04:52 <Eduard_Munteanu> Oh, sure.
11:04:52 <lambdabot> Pattern syntax in expression context: _
11:05:08 <Eduard_Munteanu> tac: yeah, it's   Just undefined
11:05:20 <tac> > case Just {} of Just x -> x;
11:05:21 <lambdabot>   *Exception: <interactive>:3:6-12: Missing field in record construction
11:05:29 <tac> Interesting
11:06:08 <tac> And by that I mean horrifying, but good to know anyway :)
11:06:28 <Eduard_Munteanu> tac: though matching with such patterns is perfectly fine
11:06:42 <tac> right. There have been times I've wish I knew about that
11:06:47 <it3ration> morning all
11:06:50 <monochrom> it is not horrifying to me. it is unifying.
11:06:50 <variable> ReinH: thanks!
11:07:05 <joneshf-laptop> Eduard_Munteanu, nice, thanks
11:07:20 <tac> monochrom: The fact it's a value, not just a pattern, is kind of a wart.
11:07:38 <joneshf-laptop> Eduard_Munteanu, that actuallymakes it look like 10 tims better
11:07:42 <tac> The more undefined stuff that gets into the language, the more can go wrong, despite our types.
11:07:55 <Eduard_Munteanu> joneshf-laptop: as a sidenote, it works because record update syntax binds even tighter than function application
11:08:32 <Eduard_Munteanu> tac: I think you can easily ask GHC to print a warning or even error out if you misuse it
11:08:35 <monochrom> ok, you worry about bottoms. I don't worry about bottoms. I worry about syntax that says "one or more" when it could easily be "zero or more".
11:09:03 <tac> Bottoms are the null pointers of functional programming.
11:09:03 <joneshf-laptop> unfortunately, records are just a pain to deal with it seems
11:09:19 <Eduard_Munteanu> joneshf-laptop: it's nicer with lens
11:09:20 <joneshf-laptop> might need to rethink my types
11:09:44 <monochrom> allowing "Just{}" is exactly right because it allows "zero or more". if it were disallowed and "Just{something=someval}" were the bottom line, that would be a wart for me.
11:10:11 <Eduard_Munteanu> monochrom: unfortunately Haskell does disallow empty record updates :(
11:10:31 <monochrom> yeah, that is the kind of warts I worry more
11:10:34 <joneshf-laptop> Eduard_Munteanu, i'll look into that, thaks
11:10:51 <Eduard_Munteanu> monochrom: which isn't just pedantism, it's actually useful in some cases.
11:11:08 <Eduard_Munteanu> Due to the updates-change-types thing.
11:11:53 <Eduard_Munteanu> It's weird that there's no GHC extension to enable that.
11:12:10 <lpaste> aranea pasted “Instance chooser” at http://lpaste.net/95915
11:13:23 <aranea> The current runChosenIO doesn't work. How do I have to write that?
11:14:59 <Eduard_Munteanu> aranea: what do you mean it doesn't work?
11:15:59 <aranea> Eduard_Munteanu: doesn't typecheck
11:16:22 <Eduard_Munteanu> aranea: also, how are run*PrgmIO related to the PrgmIO class?
11:16:26 <Eduard_Munteanu> aranea: what error?
11:16:49 <monochrom> because you declare "data CharPrgmIO", there is no such thing as "CharPrgmIO a". no?
11:16:50 <Eduard_Munteanu> The example itself isn't detailed enough.
11:17:22 <jml> I've got two functions that return IO Error String Foo, and I'd like to do something interesting if both of them are Right but just error out if either is Left
11:17:24 <aranea> Eduard_Munteanu: I forgot the "a"'s
11:17:55 <aranea> Eduard_Munteanu: the error:
11:17:56 <aranea>     Couldn't match type `CharPrgmIO' with `IntPrgmIO'
11:17:56 <aranea>     Expected type: p a -> IO a
11:17:56 <aranea>       Actual type: IntPrgmIO a -> IO a
11:18:07 <Eduard_Munteanu> jml: run both in another IO Error String ... function
11:18:09 <jml> that should probably read IO (Either String Foo)
11:18:36 <Eduard_Munteanu> Er, my suggestion was referring to ErrorT.
11:18:57 <jml> yeah, sorry for the typo.
11:19:09 <Eduard_Munteanu> jml: is it in a ErrorT String IO a form?
11:19:22 <Eduard_Munteanu> Or EitherT String IO a.
11:19:37 <jml> I don't *think* so.
11:20:00 <jml> but I'm very new to monad transformers
11:21:33 <jml> hmm. I think I could probably do something close to what I want with mapM & something that's probably spelled mapEithers
11:21:50 <jml> 'rights'
11:21:58 <Eduard_Munteanu> jml: ok, but if you run those actions, and get two Eithers, you can use the applicative/monad instance to combine them for proper Right values
11:22:30 <Eduard_Munteanu> > (,) <$> Right 1 <*> Right 3
11:22:32 <lambdabot>   Right (1,3)
11:22:33 <aranea> Eduard_Munteanu: no idea?
11:22:43 <jml> Eduard_Munteanu: interesting
11:22:57 <Eduard_Munteanu> > (,) <$> Left "onoes" <*> Right 3
11:22:58 <lambdabot>   Left "onoes"
11:23:06 <jml> Eduard_Munteanu: in this case I don't see how, because the decision about whether it's Right or Left depends on the result of IO
11:23:41 <jml> hmm. I guess I could split that bit out.
11:24:17 <Eduard_Munteanu> jml: yes, you could run the IO actions then do that, *or* use the EitherT transformer instead.
11:24:23 <Eduard_Munteanu> :t EitherT
11:24:24 <lambdabot> Not in scope: data constructor `EitherT'
11:24:30 <Eduard_Munteanu> @hoogle EitherT
11:24:30 <lambdabot> package EitherT
11:24:38 <Eduard_Munteanu> @hoogle runEitherT
11:24:39 <lambdabot> No results found
11:24:43 <Eduard_Munteanu> Blah.
11:25:28 <Eduard_Munteanu> data EitherT m a b = EitherT :: { runEitherT :: m (Either a b) }
11:25:45 <Eduard_Munteanu> Er, drop the first '::'.
11:26:37 <Eduard_Munteanu> Er...
11:26:56 <Eduard_Munteanu> data EitherT a m b = EitherT { runEitherT :: m (Either a b) }
11:26:59 <jml> the haskell platform docs seem  to say ErrorT
11:27:17 <Eduard_Munteanu> Or that one, but it's a bit different.
11:27:53 <Eduard_Munteanu> :t ErrorT
11:27:53 <lambdabot> m (Either e a) -> ErrorT e m a
11:28:02 <Eduard_Munteanu> jml: ok, let's work with that...
11:28:49 <Eduard_Munteanu> jml: now, you have an   IO (Either String a)   which you can turn into   EitherT String IO a
11:29:51 <Eduard_Munteanu> jml: and EitherT String IO is a monad so if you wrap it up like that, you can sequence those actions without handling IO and Either separately.
11:30:14 <Eduard_Munteanu> Bah, I keep typing EitherT, I mean ErrorT.
11:30:28 <jml> Eduard_Munteanu: it's ok, I'm following you.
11:30:45 <Eduard_Munteanu> :t ErrorT (return (Right 3))
11:30:47 <lambdabot> (Monad m, Num a) => ErrorT e m a
11:31:29 <jml> Eduard_Munteanu: I don't quite get the means by which I turn the IO (Either String a) into an ErrorT String IO a
11:31:45 <Eduard_Munteanu> jml: you just wrap in ErrorT
11:31:53 * jml tries
11:32:10 <Eduard_Munteanu> > (,) <$> ErrorT (return (Right 3)) <*> ErrorT (return (Right 7))
11:32:11 <lambdabot>   No instance for (GHC.Show.Show
11:32:12 <lambdabot>                     (Control.Monad.Trans.Err...
11:32:39 <Eduard_Munteanu> > (,) <$> ErrorT [Right 3] <*> ErrorT [Right 7]
11:32:40 <lambdabot>   No instance for (GHC.Show.Show
11:32:41 <lambdabot>                     (Control.Monad.Trans.Err...
11:32:47 <haasn> :t liftA2 (,) `on` ErrorT . return . Right -- the golfer in me is screaming, sorry
11:32:48 <lambdabot> (Monad m, Functor m) => a -> a -> ErrorT e m (a, a)
11:32:51 <Eduard_Munteanu> > runErrorT $ (,) <$> ErrorT [Right 3] <*> ErrorT [Right 7]
11:32:52 <lambdabot>   [Right (3,7)]
11:33:24 <Eduard_Munteanu> Heh, I was trying to keep it a bit concrete.
11:33:30 <jml> haasn: heh, I'll get to that later :)
11:33:37 <haasn> > runErrorT $ (,) <$> ErrorT [Right 3, Right 4] <*> ErrorT [Right 7, Right 8]
11:33:38 <lambdabot>   [Right (3,7),Right (3,8),Right (4,7),Right (4,8)]
11:33:41 <haasn> > runErrorT $ (,) <$> ErrorT [Right 3, Right 4] <*> ErrorT [Right 7, Left 8]
11:33:42 <lambdabot>   [Right (3,7),Left 8,Right (4,7),Left 8]
11:33:48 <jml> let's go up the abstraction ladder one rung at a time, eh?
11:33:52 <Eduard_Munteanu> Well, that's the list monad.
11:34:19 <Eduard_Munteanu> I had to choose some monad I could "run".
11:34:52 * jml nods
11:36:07 <ReinH> lol I just hope no one writes code like this ;)
11:36:39 <haasn> > x & f $ y :: Expr
11:36:41 <Eduard_Munteanu> > runErrorT $ Left "phail" >>= \r -> return 5
11:36:41 <lambdabot>   f x y
11:36:42 <lambdabot>   Couldn't match type `Data.Either.Either [GHC.Types.Char]'
11:36:42 <lambdabot>                wi...
11:37:06 <Eduard_Munteanu> > runErrorT $ fail "phail" >>= \r -> return 5
11:37:07 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error e0)
11:37:07 <lambdabot>    arising from a use ...
11:37:14 * Eduard_Munteanu :(
11:37:31 <Eduard_Munteanu> > runErrorT $ throwError "phail" >>= \r -> return 5
11:37:32 <lambdabot>   No instance for (GHC.Show.Show
11:37:33 <lambdabot>                     (m0 (Data.Either.Either ...
11:38:13 <Eduard_Munteanu> > runErrorT (throwError "phail" >>= \r -> return 5 :: ErrorT String Maybe Integer)
11:38:14 <lambdabot>   Just (Left "phail")
11:38:41 <Eduard_Munteanu> > runErrorT (return () >>= \r -> return 5 :: ErrorT String Maybe Integer)
11:38:42 <lambdabot>   Just (Right 5)
11:39:02 <haasn> Oh no, I can't mix `on` with ($)
11:39:17 <haasn> Who the hell designed these fixities? :(
11:39:19 <jml> there's a part of me that can't help but think of porridge every time I see Just Right
11:39:27 <Eduard_Munteanu> Heh.
11:40:16 <simpson> :t (<~)
11:40:17 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
11:41:07 <Eduard_Munteanu> jml: ok... so, if you have a bunch of IO actions you're executing, and they can fail, you can place all of them in 'ErrorT String IO a' and sequence them.
11:41:36 <Eduard_Munteanu> jml: if any of them fails, it stops executing the rest and gives you back that Left.
11:42:00 <haasn> λ x & liftA2 (,) `on` replicate 2.f $ y :: [(Expr,Expr)]
11:42:02 <haasn> [(f x,f y),(f x,f y),(f x,f y),(f x,f y)]
11:42:04 <haasn> look ma, no unnecessary parens
11:42:05 <jml> Eduard_Munteanu: perfect. thanks.
11:42:45 * haasn .oO(  x&liftA2(,)`on`replicate 2.f$y::[(Expr,Expr)] -- look ma, no unnecessary spaces  )
11:43:04 <Eduard_Munteanu> jml: you can also handle them as if they were exceptions, using runErrorT / catchError
11:43:11 <Eduard_Munteanu> :t catchError
11:43:12 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
11:43:44 <Eduard_Munteanu> So if you can handle some errors, it needn't fail the entire action.
11:43:48 <haasn> of course, you can just use IO's built-in exception system
11:44:51 <Eduard_Munteanu> @hoogle ErrorT SomeException
11:44:51 <lambdabot> Did you mean: :: ErrorT SomeException a a
11:44:51 <lambdabot> No results found
11:44:57 <Eduard_Munteanu> @hoogle ErrorT SomeException a a
11:44:57 <jml> actually, just to be clear...
11:44:59 <lambdabot> Did you mean: :: ErrorT SomeException a a
11:44:59 <lambdabot> No results found
11:44:59 <jml> I have [IO Either String a] ... I use (map ErrorT) to get [ErrorT String IO a], and then I sequence them using what precisely?
11:45:11 <joelteon> sequence?
11:45:16 <Eduard_Munteanu> :)
11:45:53 <Eduard_Munteanu> :t sequence
11:45:54 <lambdabot> Monad m => [m a] -> m [a]
11:46:25 <Eduard_Munteanu> :t sequence (?xs :: [ErrorT String IO a])
11:46:26 <lambdabot>     Unbound implicit parameter (?xs::[ErrorT String IO a1])
11:46:26 <lambdabot>       arising from a use of implicit parameter `?xs'
11:46:26 <lambdabot>     In the first argument of `sequence', namely
11:46:54 <joelteon> :t \xs -> sequence (xs :: [ErrorT String IO a])
11:46:55 <lambdabot>     Couldn't match expected type `t'
11:46:56 <lambdabot>                 with actual type `[ErrorT String IO a1]'
11:46:56 <lambdabot>       `t' is a rigid type variable bound by
11:47:15 <joelteon> :t sequence `asAppliedTo` (undefined :: [ErrorT String IO a])
11:47:16 <lambdabot> [ErrorT String IO a] -> ErrorT String IO [a]
11:47:19 <joelteon> there we go
11:49:12 <jml> :)
11:49:15 <jml> makes sense.
11:49:18 <jml> thanks so much!
11:51:09 <Eduard_Munteanu> jml: if you have some lone 'foo, bar :: ... -> IO (Either String a)', you can do stuff like 'x <- ErrorT (foo param); ...' in an 'ErrorT String IO a' function.
11:56:20 <whittle> Are libs built with different versions of gcc compatible?
11:57:39 <simpson> Hey, is there a good reason why modifyTMVar doesn't exist?
11:58:15 <chrisdone> what's a TMVar?
11:58:19 <joneshf-laptop> hmm, can you build a kind? that is to say, if you have a kind *, can you somehow make * -> *?
11:58:52 <quchen> chrisdone: TVar that can be empty
11:58:59 <Eduard_Munteanu> joneshf-laptop: that would be a type function
11:59:00 <Eduard_Munteanu> :k Maybe
11:59:01 <lambdabot> * -> *
11:59:34 <chrisdone> aha
12:00:26 <simpson> Like, is there something semantic to TMVars that's not obvious?
12:00:41 <Eduard_Munteanu> joneshf-laptop: any data declaration gives you something of the form '-> *'
12:00:54 <Eduard_Munteanu> Or '*' if it has no parameters.
12:01:06 <simpson> :t \v f -> do { v <- takeTMVar; putTMVar $ f v }
12:01:07 <lambdabot> Not in scope: `takeTMVar'
12:01:08 <lambdabot> Not in scope: `putTMVar'
12:02:03 <quchen> \v f = tryTakeTMVar v >>= putTMVar v . f
12:02:10 <quchen> Something like that is what you want I guess
12:02:26 <quchen> It really comes down in what case you want to retry
12:02:34 <simpson> Well, I want takeTMVar, 'cause I want to retry, but yes.
12:03:04 <simpson> I'm just surprised that while this exists for TVar, it doesn't for TMVar.
12:03:29 <quchen> No reason I think.
12:03:46 <quchen> Maybe because such a function could have multiple different useful behaviours so you have to pick the one you like yourself.
12:03:57 * hackagebot devil 0.1.0.0 - A small tool to make it easier to update program managed by Angel.  http://hackage.haskell.org/package/devil-0.1.0.0 (luanzhu)
12:04:04 <quchen> Retry on empty? Fill on empty? Retry when already full? Overwrite?
12:04:35 <joneshf-laptop> Eduard_Munteanu, okay, so my data takes no parameters, so its kind is `*`, but i feel it should be a functor, is there a way to do this, or do i need to rethink my data?
12:05:23 <quchen> Functors always require * -> *.
12:05:32 <grok22> i have a do block something like: do { x <- myfunc somearg; return ("Test") }, I'm getting a type error for the first statement in the do block, "couldn't match expected type". how is this possible since there is no 'expected type' for x, it isn't even used after assignment
12:05:37 <quchen> :k Functor
12:05:38 <lambdabot> (* -> *) -> Constraint
12:05:54 <simpson> quchen: Yeah, I guess that you'd want tryModifyTMVar as well.
12:06:29 <Eduard_Munteanu> joneshf-laptop: you can either make your own fmap-ish function that changes the contents, or you could make your datatype more polymorphic and make it a Functor, if possible.
12:07:11 <klrr_> :help k
12:07:16 <klrr_> lambdabot:
12:07:18 <arkeet> see: MonoFunctor in mono-traversable, or Setter in lens
12:10:18 <joneshf-laptop> :k Foldable
12:10:19 <lambdabot> (* -> *) -> Constraint
12:10:27 <joneshf-laptop> :k Traversable
12:10:28 <lambdabot> (* -> *) -> Constraint
12:10:43 <joneshf-laptop> meh, probably best to make my data parameterized
12:11:21 <bjorkintosh> so, what's the best supported gui library for ghc these days?
12:11:30 <Taneb> gtk2hs
12:11:38 <bjorkintosh> thank you sir.
12:11:51 <bjorkintosh> no love for fudget?
12:12:02 <Taneb> Don't know much about it
12:12:37 <bjorkintosh> here: http://www.altocumulus.org/Fudgets/springschool95-intro.html
12:12:41 <joneshf-laptop> :k Applicative
12:12:43 <lambdabot> (* -> *) -> Constraint
12:12:45 <bjorkintosh> it's quite dated.
12:12:48 <Taneb> Also, it doesn't seem to be very well supported
12:12:50 <bjorkintosh> so. makes sense.
12:13:14 <joneshf-laptop> hmm, are all of the more used typeclasses kinded `* -> *`?
12:13:43 <fizruk> :k MonadTrans
12:13:43 <Taneb> :k Eq
12:13:44 <lambdabot> ((* -> *) -> * -> *) -> Constraint
12:13:44 <lambdabot> * -> Constraint
12:13:45 <Eduard_Munteanu> joneshf-laptop: no
12:14:04 <Eduard_Munteanu> Eq, Num, Ord, Bounded, Enum...
12:14:17 <fizruk> :k MonadState
12:14:18 <Eduard_Munteanu> All take '*' arguments.
12:14:19 <lambdabot> * -> (* -> *) -> Constraint
12:15:04 <Eduard_Munteanu> fizruk: hey... how did that FreeT thing go after all?
12:15:11 <joneshf-laptop> okay
12:15:12 <joneshf-laptop> thanks
12:15:19 <jml> I just wrote this:
12:15:38 <jml> instance Error ParseError where
12:15:38 <jml>     strMsg s = head (lefts [(parse (fail s) "" [])])
12:15:41 <jml> I'm not proud.
12:15:57 <fizruk> Eduard_Munteanu, hey! I accidentally fell asleep before you answered me back then :) and then you were offline
12:17:15 <fizruk> Eduard_Munteanu, so I am just using type synonyms now, even type MonadX = ... turned out to be not so pretty
12:17:22 <cschneid> if I have a list of arbitrary elements, and want to see if they're all equal to each other, is there a built-in to do that?
12:17:36 <cschneid>  ["a", "a", "a"] => True for instance.
12:17:45 <Eduard_Munteanu> fizruk: yeah, after all, I think it's best to leave it to the user to define his own constraint synonym.
12:17:48 <cschneid> > foldl1 (==) ["a", "a" "a"]
12:17:49 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
12:17:50 <lambdabot>              with actual type...
12:18:11 <fizruk> Eduard_Munteanu, or forall'ed type synonyms of kind *
12:18:28 <cschneid> I found this solution on stackoverflow, but not sure if there's a simpler way:    allSame xs = all (== head xs) (tail xs)
12:18:39 <quchen> > let allEqual [] = True; allEqual (x:xs) = all (== x) xs -- cschneid
12:18:40 <lambdabot>   not an expression: `let allEqual [] = True; allEqual (x:xs) = all (== x) xs...
12:19:01 <cschneid> quchen: that's basically the one I found too. mine just uses head/tail rather than (x:xs)
12:19:07 <cschneid> was just looking for a builtin :)
12:19:12 <fizruk> Eduard_Munteanu, nevertheless now I can be sure there hardly is a better solution :) thank you for the discussion!
12:19:24 <quchen> cschneid: There's an extremely silly "the" function in GHC.
12:19:25 <Eduard_Munteanu> cschneid: (== 1) . length . nub  ?
12:19:33 <quchen> Eduard_Munteanu: :-P
12:21:09 <lpsmith> https://github.com/lpsmith/blaze-builder/commit/066f81840279b526bf4f819fa64fd3e5a9ade7c6
12:21:39 <lpsmith> ^  Kinda scary,  the result was that uninitialized memory was leaking into "pure" Haskell values.
12:23:19 <Lethalman> null . nub
12:23:29 <Lethalman> mh no right
12:23:29 <Lethalman> eheh
12:23:48 <Lethalman> null . tail . nub
12:23:49 <Lethalman> :P
12:23:57 <Eduard_Munteanu> Yeah, I was thinking of that now.
12:24:03 <quchen> > (null . tail . nub) [] -- eww.
12:24:07 <lambdabot>   *Exception: Prelude.tail: empty list
12:24:20 <Eduard_Munteanu> Oh.
12:24:30 <Lethalman> well, the head version fails too
12:24:58 <quchen> Don't use the head version.
12:25:04 <Lethalman> null . drop 1 . nub
12:25:10 <Lethalman> > (null . drop 1 . nub) []
12:25:25 <quchen> nub is O(n^2).
12:25:25 <lambdabot>   True
12:25:34 <supki> :t all (uncurry (==)) . ap zip tail
12:25:35 <arkeet> quchen: only if you walk the whole list
12:25:35 <lambdabot> Eq b => [b] -> Bool
12:25:36 <Lethalman> > (null . drop 1 . nub) ["a", "a"]
12:25:37 <lambdabot>   True
12:25:42 <Eduard_Munteanu> > null . tail . tails . nub $ []
12:25:43 <lambdabot>   True
12:25:46 <quchen> arkeet: Right
12:25:53 <arkeet> it's lazy enough to be linear time here I think
12:25:54 <Eduard_Munteanu> Er.
12:26:16 <quchen> Right, nub builds its result lazily.
12:26:47 <ion> lpsmith: Hah, nice
12:27:03 <Lethalman> > (null . drop 1 . nubSort) ["a", "a"]
12:27:04 <lambdabot>   Not in scope: `nubSort'
12:27:48 <Eduard_Munteanu> > even . length . tails . nub $ [1,1,1]
12:27:49 <lambdabot>   True
12:27:55 <Eduard_Munteanu> > even . length . tails . nub $ [1,1,2]
12:27:56 <lambdabot>   False
12:27:59 <Eduard_Munteanu> > even . length . tails . nub $ []
12:28:00 <lambdabot>   False
12:28:21 <Lethalman> > even . length . tails . nub $ [1,2,3]
12:28:22 <lambdabot>   True
12:28:25 <Eduard_Munteanu> Oh, nevermind.
12:28:26 <Lethalman> :)
12:28:38 <Eduard_Munteanu> Brain glitch.
12:29:35 <arkeet> length . tails = (+1) . length
12:32:56 <fizbin> > tails []
12:32:57 <lambdabot>   [[]]
12:35:29 <ion> > sonic []
12:35:36 <lambdabot>   Not in scope: `sonic'
12:37:17 <tac> > knuckles []
12:37:18 <lambdabot>   Not in scope: `knuckles'
12:37:23 <quchen> @let sonic = let heads = map id in heads :: [a] -> [a]
12:37:24 <lambdabot>  Defined.
12:37:29 <quchen> > sonic [1..10]
12:37:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:39:38 <arkeet> needs a scanning version of nub
12:39:54 <arkeet> scannub [1,2,2,3,4] = [[],[1],[1,2],[1,2],[1,2,3],[1,2,3,4]] or something
12:40:06 <arkeet> equivalent to map nub . inits but faster.
12:40:09 <arkeet> or maybe I want map nub . tails
12:40:18 <arkeet> in which case I already wrote that.
12:41:27 <arkeet> @let nubtails xs = let f y ys ls | x `elem` ls = w ls | True = y:w(y:ls) in map ($[]) (scanr f (const []) xs)
12:41:28 <lambdabot>  .L.hs:146:27:
12:41:28 <lambdabot>      Couldn't match expected type `[Expr] -> [Expr]'
12:41:28 <lambdabot>          ...
12:41:34 <arkeet> @let nubtails xs = let f y ys ls | y `elem` ls = w ls | True = y:w(y:ls) in map ($[]) (scanr f (const []) xs)
12:41:35 <lambdabot>  .L.hs:146:27:
12:41:35 <lambdabot>      Couldn't match expected type `[a0] -> [a0]' with actual t...
12:41:37 <arkeet> oh.
12:41:57 <arkeet> @let nubtails xs = let f y w ls | y `elem` ls = w ls | True = y:w(y:ls) in map ($[]) (scanr f (const []) xs)
12:41:58 <lambdabot>  Defined.
12:42:07 <arkeet> > nubtails
12:42:08 <Eduard_Munteanu> > map (zip tails) . group $ [1,2,2,3,4]
12:42:08 <lambdabot>   <[()] -> [[()]]>
12:42:09 <lambdabot>   Couldn't match expected type `[a0]'
12:42:09 <lambdabot>              with actual type `[a1] -> ...
12:42:14 <arkeet> :t nubtails
12:42:15 <lambdabot> Eq a => [a] -> [[a]]
12:42:19 <arkeet> > nubtails
12:42:20 <lambdabot>   <[()] -> [[()]]>
12:42:20 <Eduard_Munteanu> Er.
12:42:26 <arkeet> what?
12:42:32 <dmwit> arkeet: do you know Haskell lol
12:42:32 <arkeet> :t nubtails
12:42:33 <lambdabot> Eq a => [a] -> [[a]]
12:42:35 <Eduard_Munteanu> > tails . group $ [1,2,2,3,4]
12:42:36 <lambdabot>   [[[1],[2,2],[3],[4]],[[2,2],[3],[4]],[[3],[4]],[[4]],[]]
12:42:38 <arkeet> :t nubtails
12:42:39 <lambdabot> Eq a => [a] -> [[a]]
12:42:42 <arkeet> what?
12:42:56 <dmwit> arkeet: (Maybe you better make your question into a complete sentence.)
12:43:03 <arkeet> what question?
12:43:09 <dmwit> "what?"
12:43:12 <arkeet> well,
12:43:14 <arkeet> here:
12:43:16 <arkeet> :t nubtails
12:43:17 <lambdabot> Eq a => [a] -> [[a]]
12:43:18 <arkeet> :t nubtails
12:43:19 <lambdabot> Eq a => [a] -> [[a]]
12:43:21 <arkeet> what?
12:43:34 <dmwit> Why does the type of nubtails surprise you so much?
12:43:45 <arkeet> is my client being retarded? I'm applying it to a string.
12:43:51 <arkeet> :t nubtails
12:43:51 <lambdabot> Eq a => [a] -> [[a]]
12:43:56 <dmwit> I don't see you applying it to a string.
12:44:02 <arkeet> *what*
12:44:12 <arkeet> what the fuck
12:44:24 <arkeet> :t nubtails "abbcedbde"
12:44:25 <lambdabot> [[Char]]
12:44:28 <arkeet> > nubtails "abbcedbde"
12:44:30 <lambdabot>   ["abced","bced","bced","cedb","edb","dbe","bde","de","e",""]
12:44:34 <arkeet> ok that is messed up.
12:44:42 <chrisdone> @ _@
12:44:49 <arkeet> how is my irc client eating words.
12:44:59 <Hodapp> OMNOMNOM
12:45:07 <arkeet> what the fuck.
12:45:11 <arkeet> sorry.
12:45:38 <klrr_> okey, i tried write a simple program using SDL and reactive-banana , the program is simple supposed to open a window, then print "space" to stdout whenever space is pressed, unfourtunaly the code compiles but dont do the desired behaviour, that is that it does nothing just a black window with no output to the terminal, anyone know what might be wrong? https://gist.github.com/klrr/7551952
12:46:04 <arkeet> hm
12:46:15 <arkeet> now I'm confused how nubtails even works.
12:46:31 <klrr_> ?src nubtails
12:46:31 <lambdabot> Source not found. Whoa.
12:46:31 <arkeet> magic
12:46:36 <arkeet> I defined it above.
12:46:48 <arkeet> and I don't know how it works.
12:46:58 <arkeet> I just took the definition of nub, turned it into a foldr, and replaced foldr with scanr.
12:47:14 <klrr_> aa
12:47:55 <arkeet> @let nub' xs = let f y w ls | y `elem` ls = w ls | True = y:w(y:ls) in foldr f (const []) xs
12:47:56 <lambdabot>  Defined.
12:48:04 <arkeet> > nub' "abcbcd" []
12:48:05 <lambdabot>   "abcd"
12:48:10 <arkeet> > nub' "abcbcd" "b"
12:48:12 <lambdabot>   "acd"
12:48:30 <arkeet> > nubtails "abbcedbde"
12:48:31 <lambdabot>   ["abced","bced","bced","cedb","edb","dbe","bde","de","e",""]
12:48:39 <arkeet> what, suddenly this client isn't eating words anymore.
12:48:45 <dmwit> > let nubtails xs = let f y ls | y `elem` ls = ls | True = y:ls in scanr f [] xs in nubtails "abbcedbde"
12:48:46 <lambdabot>   ["acbde","cbde","cbde","cbde","bde","bde","bde","de","e",""]
12:49:13 <arkeet> hm.
12:49:25 <arkeet> no that's different.
12:49:28 <dmwit> I think the w nonsense is essentially the "implementing foldl with foldr" trick. =)
12:49:33 <arkeet> it is.
12:49:39 <dmwit> So why not use foldl and scanl instead?
12:49:46 <arkeet> because it's not quite a foldl.
12:49:56 <arkeet> @src nub
12:49:56 <lambdabot> nub = nubBy (==)
12:49:58 <arkeet> .
12:50:01 <arkeet> @src nubBy
12:50:02 <lambdabot> nubBy eq []             =  []
12:50:02 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:50:09 <arkeet> no :|
12:50:15 <arkeet> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#nub
12:51:27 <Tomsik> Hi, I want to have an immutable array, but I find IArray's array and accumArray functions insatisfactory. I don't want to go through whole list to access last element of the array.
12:51:39 <dmwit> ah
12:51:49 <dmwit> w isn't the "foldl with foldr" trick, it's the "difference list" trick
12:52:16 <arkeet> no but seriously https://dl.dropboxusercontent.com/u/33903796/wtfff.png
12:52:41 <arkeet> ok I guess that's blah.
12:52:42 <Tomsik> I'd be happy to have something like (idx -> a) -> Array idx a
12:52:52 <arkeet> Tomsik: that exists
12:53:02 <arkeet> I thought
12:53:15 <arkeet> oh, well, Vector has that.
12:53:34 <arkeet> why not use Vector?
12:53:49 <dmwit> arkeet: Perhaps those were Unicode quotes for some reason, and during encoding your client went "NAH".
12:54:01 <arkeet> I don't see how.
12:54:05 <arkeet> I typed " with my bare hands.
12:54:56 <Tomsik> Hmm, I'll see if I can use Vector. I'm not sure if SPOJ has that
12:55:28 <dmwit> Tomsik: Have you looked in GHC.Arr?
12:55:32 <arkeet> I'm surprised Array doesn't have it.
12:57:30 <dmwit> Actually, I don't see much terribly helpful in there.
12:57:31 <dmwit> So forget that.
12:57:34 <fizbin> arkeet: How odd. That jpg doesn't match what I see here when I look at scroll from ~ 15 min. ago.
12:57:41 <arkeet> exactly!
12:57:43 <fizbin> That png, rather.
12:57:47 <arkeet> hence wtf
12:57:54 <Tomsik> Yeah, doesn't seem to have anything useful that isn't in IArray already
12:58:54 <Zorozaster> Hi,
12:59:06 <dmwit> There's amap and ixmap; I'm surprised there's no aixmap.
12:59:11 <Zorozaster> can anybody help me figure out the type signature of a locally defined function?
12:59:36 <fizbin> arkeet: Only thing I can think is that the "space" after nubtails the first few times you tried wasn't really a space, but something like character 160 and your client cut the line off there.
12:59:39 <dmwit> Tomsik: I guess the point is you have to initialize every element of the array anyway. So what's the point in not walking the list?
12:59:41 <Zorozaster> For some reason the function in the where clause works fine when I call it separately, but not when I put it it in a where clause
12:59:51 <Zorozaster> let me just paste it somewhere
12:59:52 <arkeet> that would be pretty messed up.
13:00:05 <arkeet> what.
13:00:14 <arkeet> somehow a \r ended up in there.
13:00:16 <arkeet> after the space.
13:00:29 <Zorozaster> Here is the file: http://pastebin.com/HDFSZNz0
13:00:35 <mauke> The paste HDFSZNz0 has been copied to http://lpaste.net/95917
13:00:58 <Zorozaster> the commented out function is the problem
13:00:58 <simpson> @seen edwardk
13:00:59 <lambdabot> EDw4RDK
13:01:09 <Zorozaster> its type signature seems fine in isolatoin
13:01:18 <simpson> Oh, derp. I wanted preflex.
13:01:23 <Zorozaster> but when I use the same type signature inside the where clause, I get an error message
13:01:32 <dmwit> Zorozaster: What is the error message?
13:01:51 <Zorozaster> This is the error message: Couldn't match expected type `a0 -> t0' with actual type `IO ()'     The function `readInt' is applied to one argument,     but its type `IO ()' has none
13:01:57 <Tomsik> dmwit, well, if I only want to access a few elements and perhaps dependencies are not that deep then touching all the array is perhaps an overkill
13:02:11 <intrados> What do I need to do to apply `try` to a `ResourceT IO a`?
13:02:30 <arkeet> Zorozaster: "works for me"
13:02:40 <fizbin> Zorozaster: It seems to work for me too.
13:02:41 <dmwit> Zorozaster: I think you better show us the exact file you used that produced that message.
13:02:48 <Tomsik> I'll just go with it though, as Vector doesn't seem to be available. Well.
13:02:51 <arkeet> and the exact message.
13:03:10 <dmwit> Tomsik: No, what I'm saying is: there is no underkill.
13:03:15 <simpson> @tell edwardk Is there any reason why Array and friends don't have At instances? It would seem that there are no good indexed lenses for addressing Arrays...
13:03:15 <lambdabot> Consider it noted.
13:03:32 <Zorozaster> I can't believe it... I forgot to recompile. Yes, it's fine here, too.
13:03:34 <dmwit> Tomsik: Every element in the array must be initialized (even if it's just to something like 'error "Oy, you didn't give me an element for this index"').
13:03:36 <arkeet> dmwit: also FunctorWithIndex.
13:03:40 <Zorozaster> (I feel like an idiot now)
13:04:08 <fizbin> Zorozaster: When stuff makes me go wtf, I always reach first for "runhaskell".
13:04:16 <arkeet> more so than At.
13:04:21 <Tomsik> dmwit, it could do that laizily, I guess? Hmm
13:04:39 <dmwit> Array's are spine-strict, like most containers.
13:04:57 <dmwit> s/containers/associative containers/
13:04:58 <Zorozaster> thanks for the hint, fizbin!
13:05:19 <Tomsik> oh, right
13:05:22 <dmwit> Actually, just delete the entire second half of that sentence. Arrays are spine-strict.
13:08:29 * shapr boings cheerfully
13:08:32 <shapr> yay code!
13:08:36 <dmwit> yay shapr!
13:08:41 <shapr> howdy dmwit! How's code?
13:08:50 <dmwit> hacky, but working
13:08:52 <dmwit> and you?
13:08:52 <shapr> dmwit: long time no see... not since HacPhi so long ago
13:09:03 <shapr> Eh, I'm writing Python and OCaml, but I'll be writing more Haskell soon!
13:09:14 <shapr> I'm enjoying writing graphviz and embedding it into LaTeX as well.
13:09:35 <dmwit> Oh yes, the graphviz family of tools is very cool.
13:10:02 <dmwit> Didn't know it interoperated with LaTeX, though.
13:10:12 <dmwit> Is it more exciting than just a \includegraphics kind of thing?
13:10:22 <Hodapp> Errrg. I'm stuck doing some bug fixes in this giant C++ application. It's really annoying to have the combination of "pretending we're using a dynamic, high-level language" with "manual memory management".
13:11:31 <shapr> dmwit: that's all I'm doing, but there are ways to directly embed it.. I just didn't feel like working that hard.
13:12:01 <dmwit> Huh, I never knew.
13:13:09 <Eduard_Munteanu> Say I have unlines ["instance BigConstraint =>", "<indent-unit>BigInstanceHead where"]. If I indent the definition one unit, it looks ugly, if I indent two units it wastes space. Any tips?
13:13:46 <dmwit> indent 1.5 units
13:14:05 <dmwit> (what are the units here?)
13:14:17 <IceDanelol> pixels.
13:14:21 <chrisdone> why does git's merge strategy only have ours but not theirs
13:14:26 <chrisdone> D:
13:14:33 <Eduard_Munteanu> Also if I indent the second line further, the definition looks strangely indented if its indentation is lower than previous line.
13:14:43 <Eduard_Munteanu> dmwit: let's say 8 spaces
13:15:08 <dmwit> Why not indent it (length "instance ") spaces? That's what I do in hand-written code in this situation.
13:15:12 <Eduard_Munteanu> dmwit: or just align BigInstanceHead under BigConstraint
13:15:19 <dmwit> exactly
13:15:38 <Eduard_Munteanu> dmwit: yes, that's what I do usually, but the line after 'where' still looks oddly indented no matter what.
13:15:52 <dmwit> oh, the lines *after* where
13:16:12 <dmwit> For that, I suggest a hard tab.
13:16:21 <chrisdone> NEEVER
13:16:22 <identity> :|
13:16:28 <identity> my god
13:16:30 <identity> what have you done?
13:16:36 <dmwit> http://dmwit.com/tabs <- unfinished blog post on this
13:16:38 <Eduard_Munteanu> The only way it looks nice is when the lines after where are indented more than the previous lines.
13:16:44 <dmwit> blog is not the right word, I guess
13:16:48 * chrisdone injects dmwit with some unidentified drug and carries him back into the hospital
13:17:08 * dmwit acknowledges that other people do not share my aesthetics
13:17:26 <chrisdone> s/other/most
13:17:48 <dmwit> I believe the proposed substitution is accurate.
13:17:57 <identity> dmwit: your indentation style is such that I would never use the layout which you seem to be using to support your arguments
13:18:16 <Eduard_Munteanu> dmwit: so you're saying the BigInstanceHead indentation consists of spaces and doesn't show up as '>', while the definition is tab-indented and gets a '>' before?
13:18:38 <dmwit> identity: I'm having a hard time parsing that objection. And I'm worried that you are arguing against something I haven't said.
13:18:48 <dmwit> Can you try to state your objection clearly so that I can respond to it?
13:19:20 <identity> dmwit: I'm not arguing against you at all. You're free to have your own style/indentation/indentation character preferences without me bothering to enter into a discussion with you about it
13:19:27 <dmwit> Eduard_Munteanu: Yeah, that would be one good choice, I think.
13:19:57 <dmwit> identity: Okay, forget the response then. Can you state your objection clearly so I can re-evaluate my stance against your new information?
13:20:07 <Eduard_Munteanu> BTW, is there any way to do structural editing on Haskell code? I switched to Emacs recently, I wonder if I can just have haskell-mode lay things out assuming I supply "semantics" as hard tabs.
13:20:19 <dmwit> identity: (I want to understand you.)
13:21:05 <Eduard_Munteanu> I'm also hoping to use proportional fonts at some point.
13:21:16 <dmwit> It's a pipe dream, ain't it? =)
13:22:19 <identity> dmwit: it seems I misunderstood the nature of your 'blog post' at first glance so you can happily disregard my previous comment
13:22:26 <dmwit> ok!
13:22:53 <chrisdone> dmwit: i only make the flippant jokes because i don't care about debating it, fwiw. i'm fortunate enough to live in a world where the status quo is what i like, until that changes it's not a big deal =)
13:23:02 <benzrf> hi, is there a way to show a piece of data according to the implementation that would be used if show were derived?
13:23:05 <benzrf> i.e.
13:23:16 <benzrf> data Foo = Foo; instance Show Foo where show _ = "wat"
13:23:23 <benzrf> how can I get "Foo" from Foo now?
13:23:29 <dmwit> chrisdone: Yeah. =)
13:23:43 <dmwit> benzrf: myFancyConstructorNamingFunction Foo = "Foo"
13:24:17 <benzrf> dmwit: without writing it out deliberately ;p
13:24:29 <benzrf> basically is there a backdoor into the default derived implementation of Show
13:24:35 <dmwit> Perhaps you can do something with generics or Data.
13:24:39 <benzrf> hm
13:24:53 <dmwit> But basically the answer to your question is "no".
13:24:54 <chrisdone> dmwit: *ideally* for me, we wouldn't deal in spaces at all. we'd be using something like my browser editor or lamdu that just lays out code in html tables…
13:24:56 <benzrf> alriht
13:24:57 <benzrf> :(
13:25:06 <dmwit> chrisdone: Yes! That's my ideal, too.
13:25:17 <chrisdone> =)
13:25:21 <chrisdone> then proportional fonts! woo!
13:25:40 <dmwit> well
13:25:45 <chrisdone> haha
13:25:51 <chrisdone> what, now *i'm* the weird one? =p
13:25:55 <dmwit> I want a tool that lays things out in html tables, but *also*
13:26:03 <chrisdone> also?
13:26:03 <dmwit> that gives me the ability to create columns it didn't think of.
13:26:27 <chrisdone> you mean storing custom layouts for specific nodes?
13:26:30 <dmwit> e.g. sometimes many branches of a case are of the form "function arg1 arg2 arg3" and I want those to line up even though usually they wouldn't.
13:26:59 <dmwit> (And by the way, no, I don't think wanting to code with proportional fonts is weird. I call it out as a dream of mine in my post. =)
13:27:38 <chrisdone> right, that kind of alignment makes sense. pity there's no way to automatically recognise when it's appropriate
13:27:53 <dmwit> Probably recognizing that is akin to hard AI.
13:27:58 <chrisdone> it seems entirely aesthetic/programmer-brain related
13:28:04 <dmwit> Or worse, since probably even people disagree about when it's appropriate. =)
13:28:20 <chrisdone> lol yeah, so hard AI—with its own opinions!
13:28:29 <tomejaguar> dmwit: Your article is truly excellent.
13:28:32 <chrisdone> bring on the Butlerian jihad
13:28:39 <dmwit> tomejaguar: Thanks! =)
13:28:59 <tomejaguar> You're still my hero :)
13:29:23 <kakos> If I have a type like "data Foo = Bar Int | Baz String", is there any way to use the constructors (Bar, Baz) to fetch Foo's from a [Foo]? Something like "getValue :: [Foo] -> ? -> Foo" that would be called like "getValue someFoos Bar" and it woudl return "Bar 3"?
13:29:41 <benzrf> dmwit: not monospace???
13:29:45 <benzrf> BURN THE WITCH
13:29:53 * dmwit fetches some firewood
13:30:04 * chrisdone leaves his pitchfork by the door
13:30:08 <benzrf> kakos: can you explain a little better?
13:30:28 <chrisdone> proportional fonts are more beautiful <3
13:30:33 <dmwit> kakos: How about getBar vs = [n | Bar n <- vs] -- ?
13:30:40 <benzrf> chrisdone: clearly youve never seen inconsolata
13:30:42 <dmwit> kakos: getBar :: [Foo] -> [Int]
13:30:56 <chrisdone> benzrf: inconsolata, don't make me laugh with that microsoft claptrap
13:31:01 <benzrf> u wot
13:31:05 <benzrf> oh do you mean consolas
13:31:16 <haasn> I wish legal documents were printed in terminus, then I could actually read them without getting a headache
13:31:18 <chrisdone> no, i mean that word i said in what i wrote with my hands
13:31:44 <dmwit> There are some beautiful monospace fonts. There are some beautiful proportional fonts. Can't we all just get along?
13:31:46 <tomejaguar> inconsolata is really nice
13:31:47 <benzrf> but inconsolata is unrelated to migrowsoft
13:32:03 <dmwit> chrisdone and I just want it to be *possible* to code with proportional fonts; we don't want people who hate them to be forced into them...
13:32:04 <kakos> dmwit: Well, I'd like it to be a bit more generic rather than having to write separate functions for every type of constructor? The end type might have quite a few different data constructors
13:32:04 <haasn> dmwit: let's just be like SPJ and use comic sans, then everybody gets annoyed; equality ftw :)
13:32:24 <tomejaguar> If I ever work for MSR, I'm going to use Comic Sans too.
13:32:29 <kakos> Anonymous Pro is really good as far as monospaced fonts go. http://www.marksimonson.com/fonts/view/anonymous-pro
13:32:44 <dmwit> Let's just let everybody have their own preferences about what looks good, why not??
13:32:49 <benzrf> haasn: spj?
13:32:50 <chrisdone> benzrf: (both fonts are kind of the same to me)
13:32:51 <ion> haasn: Important: yellow-on-blue comic sans
13:33:05 <dmwit> kakos: Right. There isn't really a way to do that, though you might be interested in the "first class patterns" stuff.
13:33:09 <dmwit> kakos: See, uh...
13:33:11 <ion> @google spj
13:33:14 <lambdabot> http://www.spj.org/
13:33:14 <lambdabot> Title: Society of Professional Journalists | Improving and protecting journalism sin...
13:33:17 <tomejaguar> benzrf: SPJ = Simon Peyton-Jones.
13:33:19 <ion> heh
13:33:20 <benzrf> kakos: i find anonymous kind of inconsistent
13:33:22 <dmwit> ?hackage first-class-patterns
13:33:23 <lambdabot> http://hackage.haskell.org/package/first-class-patterns
13:33:25 <dmwit> kakos: that
13:33:26 <benzrf> kakos: like the x looks out of place next to the w
13:34:00 <kakos> benzrf: I'm not enough of a font nerd to notice things like that. :)
13:34:02 <geekosaur> yeh, looks like a weird mishmash of styles
13:34:05 <dmwit> kakos: And be sure to read the paper; it's very approachable, and the library probably isn't very easy to get into without it.
13:34:08 <benzrf> kakos: im not a font nerd at all
13:34:11 <benzrf> kakos: it just looks weird
13:34:11 <benzrf> ._.
13:34:14 <kakos> dmwit: Danke.
13:34:15 <geekosaur> but I think I could get used to it; will have to poke more
13:34:37 <benzrf> geekosaur: use inconsolata
13:34:40 <benzrf> it is a thing of beauty
13:34:49 <benzrf> In 3 seconds...
13:34:50 <benzrf> http://benzrf.benzrf.com/imgs/7c4627.png
13:35:00 <benzrf> sorry the 3 seconds is the output of my screenshot script
13:35:17 <chrisdone> i wish that image would load in 3 seconds
13:35:21 * chrisdone still waiting
13:35:21 <benzrf> Hardolaf:
13:35:23 <benzrf> *har
13:35:31 <benzrf> its being served off the comp im on
13:35:34 <benzrf> so dont expect hi speed
13:35:40 <chrisdone> stop torrenting spj videos
13:35:45 <chrisdone> =p
13:35:47 <benzrf> kek
13:35:48 <haasn> oops, did I just make chrisdone's download slower?
13:35:53 <chrisdone> lol
13:35:58 <chrisdone> HOW DARE YOU
13:35:59 * tomejaguar too
13:36:04 * fizruk too
13:36:06 <benzrf> geekosaur: click my screenshot link to see beauty in terminal
13:36:07 <benzrf> :-D
13:36:23 <haasn> http://i.srsfckn.biz/2E.png :)
13:36:26 <benzrf> i use irssi just so i can be in the terminal cuz its so easy on my eyes
13:36:26 <benzrf> B)
13:36:50 <chrisdone> haasn don't need no stinkin antialiasing
13:36:55 <benzrf> haasn: i see youre a native of /g/
13:36:56 <geekosaur> well, what I'm really looking for is a good proportional unicode font for use in irc (monospace wastes too much space) that doesn't make pango blow up
13:37:21 <dcxi> haasn: looks pretty good
13:37:45 <chrisdone> geekosaur: what do you think of ubuntu mono? it's one of the few monospace fonts that downsizes while retaining legibility
13:38:14 * dcxi likes fixedsys excelsior as a font
13:38:33 <dmwit> I find the whole "every round shape must be a perfect circle" thing a bit odd.
13:38:35 <mcstar> dejavu sans is the best, unfortunately osx's 'sry, we dont hint' rendering ruins it for me now
13:38:36 <benzrf> haasn: ill have you know that i moderate /r/projecttox
13:38:37 <benzrf> :Y
13:38:38 <chrisdone> dcxi: mirc!
13:38:53 <dcxi> chrisdone: ha, indeed
13:39:01 <haasn> dcxi: memories ;)
13:39:03 * shapr boings happily
13:39:04 <benzrf> deja vu looks nice
13:39:06 <shapr> yay code!
13:39:06 * hackagebot bytestring-plain 0.1.0.1 - Plain byte strings ('ForeignPtr'-less 'ByteString's)  http://hackage.haskell.org/package/bytestring-plain-0.1.0.1 (HerbertValerioRiedel)
13:39:44 <dcxi> chrisdone: I've just looked at VGA fonts for way too long :D
13:40:00 <chrisdone> dmwit: well, if the purpose of the font is to look like it was constructed with lego, and the reader finds that aesthetically pleasing, so be it
13:40:31 <benzrf> pluggin glass tty
13:40:43 <benzrf> i actually used that font because i thought it looked cool for like a month
13:40:44 <benzrf> :B
13:41:58 <chrisdone> dejavu sans mono was my old love, before ubuntu mono =)
13:42:18 <benzrf> chrisdone: still sticking with inconsolata
13:42:21 <benzrf> it is gorgeous
13:42:23 <chrisdone> we were in the office and my cfriend installed it
13:42:29 <chrisdone> and we all crowded round marvelling at it
13:42:50 <mcstar> let me share a revelation with you, that i had during my time over haskell-blah
13:43:02 <haasn> I think I migrated from Fixedsys to Consolas to Terminus over the course of my IRC life
13:43:30 <zomg> Fixedsys 4 lyfe
13:43:56 <zomg> Oh.
13:43:59 <zomg> I'm actually using Consolas
13:44:01 <chrisdone> lol
13:44:02 <zomg> So much for that then.
13:44:02 <zomg> haha
13:44:03 <mcstar> http://i.imgur.com/y4CRF3Q.png deajvu sans mono, from left to right: osx gui, osx terminal, x11 linux.... thats the best it could do???
13:44:40 <chrisdone> yeah, looks better on linux
13:44:49 <klrr_> looks not the same on linux
13:44:54 <chrisdone> i got a ttf monaco font for linux and it looked poor
13:44:58 <klrr_> totally different font in fact :p
13:45:01 <geekosaur> different size and possibly weight on linux
13:45:04 <haasn> mcstar: I think there are some things you can do to get linux to render more closely to OSX's style, but I forgot the names
13:45:17 <geekosaur> same letterforms
13:45:21 <haasn> the ‘b’ looks different
13:45:26 <chrisdone> i don't think he wants it to look like OSX
13:45:54 <geekosaur> mm, yes, all the extenders above the x-height are oddly stretched on linux
13:45:55 <chrisdone> at least, i hope. the letters look all bent out of shape on os x
13:46:09 <Kaidelong> isn't the whole point of TTF that you can transform them to different letter sizes?
13:46:18 <Kaidelong> and that they look the same in print as they do on screen
13:46:26 <geekosaur> to a limit, yes
13:46:26 <Kaidelong> because of resolution independence
13:46:35 <geekosaur> hinting for low DPI things like screens is always dicey
13:46:47 <chrisdone> but… none of the renderings on that screenshot look good
13:46:48 <chrisdone> yeah
13:46:54 <dmwit> resolution independence sounds like another one of those lies that sounds good until you try it
13:46:55 <geekosaur> there are some knobs for hinting in OS X
13:46:56 <RevJohnnyHealey> I use droid sans mono for my terminals.
13:46:57 <chrisdone> i had to lean forward to read the text
13:47:18 <lecoeus> you guys should try infinality
13:47:37 <Kaidelong> dmwit: it's important mostly because DPI on printers can be very different from PPI on monitors
13:47:40 <haasn> Infinality is what I was referring to, thanks!
13:47:42 <ystael> ubuntu mono is nice but i had to switch to dejavu sans mono to be able to use unicode in aggda
13:48:01 <mcstar> haasn: what?? the problem is that osx does a lousy job!
13:48:02 <simpson> @tell edwardk Derp, sorry. Figured it out; I didn't realize the difference between ix and at. Thanks!
13:48:03 <lambdabot> Consider it noted.
13:48:13 <Kaidelong> so what looks big on screen can end up very small in print
13:48:14 <haasn> dmwit: it all depends on the ppi of the screen of course. It works much better in printing and for newer very-high-ppi screens
13:48:17 <Kaidelong> and that's very confusing
13:48:20 <geekosaur> mcstar, both os x and linux are hosing that font, in different ways
13:48:26 <edwardk> happy to help ;)
13:48:35 <dmwit> haasn: "it all depends on the ppi of the screen" is exactly what I mean by "resolution independence sounds like a lie"
13:48:42 <geekosaur> some aspects look better on each, neither actually looks quite right
13:48:46 <dmwit> haasn: "it all depends" is the exact opposite of "independent"
13:48:58 <mcstar> i got used to linux's curvy(smoothed) but still sharp rendering, but osx ruins it, thats all i see
13:49:06 <mcstar> the fonts are exactly the same, btw
13:49:08 <Kaidelong> dmwit: it isn't a lie in that things will be the same size, but lower resolution, rather than the size changing
13:49:14 <geekosaur> linux is stretching the font vertically
13:49:25 <geekosaur> look how high the dots on i and j are riding
13:49:26 <Kaidelong> it's comparable to vector vs raster graphics, which makes sense because it *is* exactly vector vs raster graphics
13:49:37 <geekosaur> then look at other extenders over the x-height, especially for the lowercase letters
13:49:42 <Kaidelong> ttf fonts are vector fonts
13:49:46 <geekosaur> they're *all* stretched oddly
13:49:47 <Kaidelong> or at least that's how I understood it
13:50:42 --- mode: ChanServ set +o geekosaur
13:50:44 <patate> dodgems :)
13:50:49 <geekosaur> malasi: pm spam is not appropriate
13:50:49 <dodgems> ello
13:51:03 --- mode: geekosaur set +b *!*ircap@213.143.61.*
13:51:09 --- kick: malasi was kicked by geekosaur (malasi)
13:51:21 --- mode: geekosaur set -o geekosaur
13:51:30 <patate> hi geekosaur
13:51:38 <chrisdone> ystael: what operating system are you on?
13:51:45 <ystael> chrisdone: ubuntu
13:51:53 <ystael> (not at the moment, but where i do agda)
13:51:53 <chrisdone> huh
13:51:59 <patate> here idle is allowed or not dodgems ?
13:52:01 <chrisdone> so why did you need to use a different font to use unicode?
13:52:13 <dodgems> yes patate
13:52:21 <patate> good
13:52:24 <patate> good night!
13:52:49 <ystael> chrisdone: It's more that ubuntu mono didn't have all the characters I wanted, and it was easier to switch my emacs font than to figure out how to configure emacs to use dejavu only as a fallback when a character wasn't found in ubuntu mono
13:52:49 <chrisdone> ystael: were the characters misaligning?
13:53:11 <chrisdone> that's weird
13:53:21 <chrisdone> my emacs is using pango i think
13:53:24 <chrisdone> which uses fontconfig
13:53:29 <chrisdone> and fontconfig does automatic fallbacking
13:53:40 <chrisdone> you're saying you got non-fallback characters rendered?
13:53:45 <chrisdone> like ?'s or something?
13:54:22 <ystael> I don't remember clearly.  It may have been an inauspicious choice of fallback font and I couldn't figure out how to force it to use a particular fallback
13:54:24 <chrisdone> if i write → i see it rendered just fine. it's not in my font but emacs renders it with a fallback
13:54:33 <chrisdone> fair enough
13:54:41 <mcstar> geekosaur: on the screenshots AA is set to 0, btw, for the osx rendering, otherwise the font would look really bold
13:54:43 <ystael> like I wanted it to use Symbola and it was picking something else
13:54:46 <mcstar> and hardl readable at all
13:57:16 <saml> > replicate 10 '₪'
13:57:19 <lambdabot>   "\8362\8362\8362\8362\8362\8362\8362\8362\8362\8362"
13:58:24 <mcstar> i cant set font for emacs on osx, for some reason
13:58:51 <mcstar> i cant select the font in the gui, it uses it, and i write it to the config file, then on next start it would fall back to something else
13:59:45 <joneshf-laptop> saml, is that a paperclip ?
13:59:56 <mcstar> the second line, first cant is can
14:00:26 <saml> joneshf-laptop, maze ₪₪₪₪₪₪₪₪₪₪₪₪₪₪₪
14:00:39 <geekosaur> mcstar, that appears to be an emacs bug, I have seen it as well. if I set the font using customize faces and save, it works
14:00:57 <geekosaur> save doesn't save a font set via the menu
14:01:42 <mcstar> geekosaur: , well, custom-set-faces is called in .emacs..
14:01:57 <bz> hm
14:01:59 <geekosaur> yes, but as far as I can tell the font set via the menu item is not written to that
14:02:12 <geekosaur> if I use customize-faces then the right thing goes into custom-set-face
14:02:24 <mcstar> ok, so thats one bug, but then it should display the font i have in .emacs
14:02:35 <mcstar> (i might have the wrong font name there, though)
14:02:36 <geekosaur> and it uses it
14:02:41 <mcstar> no it doesnt
14:02:46 <geekosaur> it does here
14:02:47 <bz> is "data X = X {\n\tone :: Int,\n\tnine :: Int\n}" valid indentation? and if not, why?
14:02:54 <mcstar> but i will try setting a diff. font in .emacs
14:03:19 <dmwit> bz: It is not, because the final } has a ; inserted before it.
14:03:55 <dmwit> bz: Consider "...\n\t}" instead.
14:04:02 <mcstar> geekosaur: youre my hero, it works!
14:04:11 <bz> dmwit: argh
14:04:34 <bz> dmwit: what's the significance of the semicolon insertion?
14:04:37 <benmachine> bz: also, consider not using tabs :P
14:04:41 <mcstar> first i had Fixedsys, but somehow it didnt find it, and fell back on some non monospaced font, but i could set dejavu mono now
14:04:58 <bz> benmachine: actually \t was shorthand for " "*4
14:05:03 <dmwit> bz: It means it tries to parse the part up to the "}" as a data declaration, and the "}" as some other kind of declaration.
14:05:05 <geekosaur> determining the correct face name can be something of a black art :/
14:05:08 <dmwit> bz: Neither of which works. =)
14:05:11 <intrados> I feel like I'm doing the wrong thing when I'm repeatedly doing `liftIO . foo . runResourceT`. Is there something I'm missing?
14:05:12 <benmachine> bz: well, things that are zero-indented get parsed individually
14:05:47 <benmachine> actually, ignore my explanation, I can't remember how it works well enough
14:06:25 <geekosaur> this isn't really emacs' fault, or even os x's (if anything, font book helps you figure that part out). on linux fc-list or fc-match can be used, but even so I have occaisonally been reduced to deciphering utf16 in individual ttf files
14:06:31 <bz> dmwit: given what you've told me, why does "tp = makeTokenParser $ LanguageDef {\n\t...\n}" work?
14:07:49 <dmwit> I don't know!
14:08:09 <dmwit> Perhaps I'm wrong.
14:08:41 <benzrf> dmwit: is that like dimwit
14:10:58 <bennofs> with parsec, is it possible to say that a parser should match the whole input?
14:11:20 <dmwit> <* eof
14:11:46 <bennofs> oh, it's that easy, thanks dmwit !
14:11:52 <dmwit> bz: Section 2.7 of the Report agrees with me. But section 10.3 is the precise definition, and I haven't read that.
14:11:55 <dmwit> But you could take a look.
14:12:10 <dmwit> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7 is 2.7
14:12:19 <dmwit> http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3 is 10.3
14:15:45 <dmwit> Section 10.3 has this gem: "To avoid visual confusion, programmers should avoid writing programs in which the meaning of implicit layout depends on the width of non-space characters.".
14:16:11 <benzrf> dmwit: sounds like sound advice
14:16:14 <benzrf> whats your point
14:16:43 <dmwit> I have no point. I enjoyed this thought, and hoped others might enjoy it with me.
14:17:20 <benzrf> oh
14:17:31 <benzrf> i dont think ive ever heard 'gem' used non sarcastically
14:17:34 <benzrf> my bad
14:17:45 <JuanDaugherty> rly?
14:17:53 <benzrf> i spend too much time on reddit probably
14:18:09 <tac> I used to be a fan of this series as a kid, benzrf: http://www.amazon.com/Game-Programming-Gems-CD/dp/1584500492
14:18:25 <JuanDaugherty> outside of precious stones references, it has no other use I know of
14:18:27 <benzrf> wow that looks great
14:18:46 <benzrf> i wish id had that
14:18:54 <benzrf> JuanDaugherty: yes, i mean used that way non sarcastically
14:18:56 <benzrf> like 'thanks a lot'
14:19:06 <benzrf> when was the last time you heard 'thanks a lot' non sarcastically
14:19:09 <JuanDaugherty> actually I take that back
14:19:48 <JuanDaugherty> it's quite common in a number of disciplines to use it non-sarcastically but even there there's a hint of it
14:20:22 <JuanDaugherty> "jewel" is the one used without derision
14:20:31 <chrisdone> people say gem about peopple or songs all the time where i'm from
14:20:43 <benzrf> chrisdone: yes its common
14:20:47 <chrisdone> locality n all that
14:20:57 <benzrf> but on the internet and particularly reddit it seems to be largely used sarcastically
14:21:12 <chrisdone> heh
14:21:29 <benzrf> le gem
14:23:12 <dmwit> Well, as far as I can tell, 10.3 agrees with me and GHC is accepting more programs than it ought to.
14:23:28 <dmwit> But usually when I think such things I am wrong somehow.
14:23:52 <dmwit> (Those GHC folks are pretty smart.)
14:24:12 <benmachine> I use "gem" near-universally sarcastically
14:24:36 <benmachine> but that might say more about my typical mode of speech than my usage of precious stones as metaphor
14:25:11 <benzrf> benmachine: yea
14:35:36 <maxiepoo> @pl \(f, g) (x, y) -> (f x, g y)
14:35:36 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
14:35:51 <maxiepoo> egh
14:35:55 <benzrf> @pl?
14:35:55 <lambdabot> (line 1, column 1):
14:35:55 <lambdabot> unexpected end of input
14:35:55 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:36:08 <joelteon> pointless
14:36:10 <FreeFull> maxiepoo: There is probably some Arrow combinator for that
14:36:11 <benzrf> huh
14:36:14 <maxiepoo> yeah
14:36:16 <joelteon> @pl \x y -> f y x
14:36:16 <lambdabot> flip f
14:36:22 <benzrf> ah
14:36:24 <benzrf> cute
14:36:59 <benzrf> i wrote a lambda calculus thingy
14:37:01 <benzrf> it was fun
14:37:02 <benzrf> :3
14:37:03 <maxiepoo> I was hoping lambdabot would give me the combinator
14:37:12 <maxiepoo> I'll try hoogle
14:37:57 <dmwit> :t (***)
14:37:59 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:38:05 <dmwit> :t uncurry (***)
14:38:06 <lambdabot> Arrow a => (a b c, a b' c') -> a (b, b') (c, c')
14:38:26 <dmwit> maxiepoo: ^
14:39:09 <maxiepoo> of course
14:39:10 <FreeFull> > uncurry (***) (subtract 1, subtract 2) (3,4)
14:39:11 <maxiepoo> I was so close
14:39:12 <lambdabot>   (2,2)
14:39:16 <FreeFull> That works
14:49:03 <codygman-> I'm trying to write something to simply query google for "haskell". I'm using Network.HTTP.Conduit. All I need to do is add a custom query string right? Here is what I have so far: http://lpaste.net/95918
14:49:30 <chrisdone> does anyone use ghci for their shell?
14:50:09 <acowley> chrisdone: The most likely person I can think of who might do that is chrisdone
14:50:34 <chrisdone> codygman: it should be google.com/search?q=blah
14:50:36 <pqmodn> chrisdone: acowley might have an idea.
14:50:39 <geekosaur> codygman-: "simply query google" is not as simple as you think; it stands a good chance of getting an automatic block on your IP address
14:50:44 <maurer> chrisdone: I donot use ghci for a shell, but I do use haskell as my primary glue scripting language
14:50:51 <chrisdone> acowley: drat
14:51:09 <bobcrash> Is gtk2hs still actively maintained?  I'm kind of surprised what looks to be the most popular gui binding has a package that doesn't build with the latest cabal (that's been out 2 months)
14:51:17 <codygman-> geekosaur: Oh... I'm not using it for scraping. Just to know how to add data to my requests in haskell. I'm familiar with people trying to mass query google, lol.
14:52:04 <geekosaur> bobcrash, there is in fact an update in the works
14:52:20 <codygman-> chrisdone: Yes, that would work... but what would be the best way to build up a querystring? I gues  I asked the wrong question.
14:52:35 <geekosaur> someone has been asking for access to the repo to commit updates but apparently the main devs are busy or away or something
14:52:38 <chrisdone> codygman: there's a http-url package or something like that
14:52:56 <bobcrash> geekosaur:  Good to know.  It's not so much that I can't get it installed/building, but it seemed like a bad sign for something I wanted to use to develop
14:52:59 <Kaidelong> doesn't gtk2hs require special preperation to build through cabal?
14:53:28 <Kaidelong> gtk has to be installed manually and gtk2hs-buildtools must be installed by cabal before invoking it to install gtk2hs
14:53:28 <geekosaur> Kaidelong, slight special prep, yes. but it's also somehow broken by cabal 1.18
14:53:57 <bobcrash> cabal 1.18, or 1.16 or something added a helper function which was already implemented inside the build scripts for gtk2hs causing a naming conflict
14:57:16 <ij> I can have "multiple" declarations of functions only if they're for typeclasses?
14:57:40 <geekosaur> or they are imported qualified
14:57:42 <benzrf> ij: es
14:57:49 <ij> :[
14:57:54 <benzrf> geekosaur: ij means type-based dispatch i think
14:57:58 <benzrf> ij: why would you want that?
14:58:03 <benzrf> just use ADTs & pattern matching
14:58:07 <benzrf> if youre so desparate
14:58:27 <ij> I had some idea what to do with it, but I forgot it! Ha.
14:58:29 <hpc> class Foo a where type Bar a; foo :: Bar a
14:58:36 <hpc> voila!
14:58:55 <benzrf> amazing
15:00:01 <benzrf> ij: data foo = Bar Int | Baz Int; quux (Bar i) = i - 1; quux (Baz i) = i + 1;
15:01:03 <ij> looks nice
15:01:42 <bobcrash> Anyone dealt with libraryConfig is not a (visible) field of constructor LocalBuildInfo trying to build a package?
15:12:53 <tomejaguar> bobcrash: Can you give a fuller error?
15:14:52 <bobcrash_> tomejaguar:  http://pastebin.com/nzDtWuiF
15:14:57 <mauke> The paste nzDtWuiF has been copied to http://lpaste.net/95919
15:15:20 <bobcrash_> And LocalBuildImport was imported with a (..) so I feel like this is one of those things where the structure of APIs changed since the package was created
15:15:25 <bobcrash_> but its gtkglext and the latest source code for it at that
15:16:01 <tomejaguar> bobcrash_: What version of Cabal are you using?  'ghc-pkg list | grep Cabal'
15:16:26 <bobcrash_> tomejaguar: 1.18.1.2
15:16:30 <benzrf> does 'as' imply qualified?
15:16:40 <geekosaur> no
15:17:11 <geekosaur> qualified means that you can't use the unqualified name. as changes the prefix on the qualified name
15:17:13 <benzrf> then what does it do in the absence of qualified?
15:17:16 <benzrf> oh right
15:17:29 <benzrf> i forgot you can still do qualified without explicit requirement of qualification
15:17:32 <benzrf> derp
15:17:57 <ReinH> benzrf: here are all the things http://www.haskell.org/haskellwiki/Import
15:19:04 <bobcrash_> Both Cabal-1.16.0 and Cabal-1.18.1.2 are installed
15:19:34 <bobcrash_> but "cabal --version" says I"m using the latest
15:20:24 <geekosaur> Cabal is a library. the cabal command is a program, and its package is cabal-install (not Cabal)
15:20:57 <codygman-> I have some code to do a simple get request with basic auth, it's not working, and I'm not sure where to go from here. Here is the code + output: http://lpaste.net/95920
15:20:59 <geekosaur> yes, this is somewhat confusing, but the Cabal library predates cabal-install by many years
15:20:59 <acowley> I think I wish they were just one package
15:21:24 <geekosaur> and you should be able to retrofit cabal-install onto an older Cabal
15:22:32 <bobcrash_> well when I run "cabal --version" it lets me know I'm using 1.18 for both cabal-install and the Cabal library
15:23:14 <geekosaur> right, but that's what *it* is using, not what programs will necessarily use
15:23:46 <geekosaur> also it can't retroactively change an installed library that was built against a different Cabal library to use a different one, without rebuilding that library from source
15:24:06 <chrisdone> woah, ghci already makes a nice shell
15:24:07 <geekosaur> (yes, this also is annoying, but it falls out of how ghc optimizes libraries)
15:24:30 <tomejaguar> bobcrash_: Looks like localBuildInfo hasn't existed since 1.16.0.3: http://hackage.haskell.org/package/Cabal-1.18.1.2/docs/Distribution-Simple-LocalBuildInfo.html http://hackage.haskell.org/package/Cabal-1.18.1.2/docs/Distribution-Simple-LocalBuildInfo.html
15:24:35 <geekosaur> (which is nice for performance but a massive headache for library maintenance and the direct cause of what is miscalled Cabal hell)
15:24:37 <chrisdone> it already does file completion
15:24:42 <tomejaguar> bobcrash_: http://hackage.haskell.org/package/Cabal-1.16.0.3/docs/Distribution-Simple-LocalBuildInfo.html
15:25:07 <jle`> why is there a separate Floating and RealFlot classes.  Doesn't the word "floating" imply that that there is an exponent and significand.  Should Floating really be Real
15:25:24 <halp4352> floats aren't real
15:25:28 <chrisdone> i can write:
15:25:29 <chrisdone> λ> ls
15:25:29 <chrisdone> …
15:25:29 <chrisdone> λ> rm "X.
15:25:31 <chrisdone> X.hi  X.hs  X.o
15:25:34 <chrisdone> λ> rm "X.hi"
15:25:54 <jle`> halp4352: hm. that makes sense.
15:25:54 <geekosaur> halp4352, ghci begs to differ (try :info Float)
15:26:14 <tomejaguar> You will also complete '> foo "X. ...', so it's not context sensitive.  It just seems to complete strings with filenames.
15:26:16 <jle`> i feel like Floating is still an awkward term
15:26:49 <halp4352> geekosaur: heheh, fair enough; ghc isn't perfect
15:27:06 <geekosaur> Real means implemented in hardware, more or less. RealFloat is the subset of floating point operations implemented in hardware, and describes how to access the hardware specific details
15:27:38 <halp4352> Not real in the math sense?
15:27:52 <geekosaur> Floating describes floating point operations, which might be implemented in a hardware supported type like Float or Double or in a higher level type not relfected by hardware implementation
15:27:55 <benmachine> hold on, Real doesn't mean implemented in hardware
15:28:18 <halp4352> Like, the set of real numbers real?
15:28:19 <benmachine> Real means real in a vaguely mathematical sense but its only method is toRational which kind of makes a mockery of it
15:28:24 <benmachine> > toRational pi
15:28:26 <lambdabot>   884279719003555 % 281474976710656
15:28:27 <acowley> chrisdone: Looks like I was right about my earlier suggestion!
15:28:42 <chrisdone> =p
15:29:01 <lpaste> chrisdone pasted “simple shell start” at http://lpaste.net/95921
15:29:10 <chrisdone> this simple functions make a good start
15:29:18 <acowley> chrisdone: btw, are you actively working on the cabal repl in haskell-mode?
15:29:19 <jle`> geekosaur: i understand their purpose, but all RealFrac does as a typeclass is provide access to those optimized hardware things.  Floating, by definition, should be able to provide you with all of that same information.
15:29:22 <geekosaur> there used to be a description for the Real class that made clear that it did not mean mathematical real numbers but hardware
15:29:31 <geekosaur> jle`, no
15:29:36 <chrisdone> acowley: nope
15:29:44 <acowley> darn
15:29:46 <tomejaguar> chrisdone: Ha cool.
15:29:54 <chrisdone> acowley: what specific stuff does it need to work?
15:30:06 <geekosaur> there are arbitrary precision floats on Hackage which give you Floating, but not RealFloat because they are not implemented /in silico/
15:30:20 <bennofs> What do you do when you have a type that is a monoid, but only when it has some extra information?
15:30:21 <jle`> i'm looking at the typeclass def of RealFloat
15:30:22 <acowley> chrisdone: I don't have a bug report atm, but I get frustrated by it a lot.
15:30:33 <benmachine> jle`: Complex a is Floating but not RealFloat
15:30:36 <geekosaur> so the operations in RealFloat are meaningless on them
15:30:44 <acowley> chrisdone: So I was wondering if anyone was already working away at it
15:30:46 <ReinH> carter: ping
15:30:50 <chrisdone> acowley: what in particular?
15:30:51 <benmachine> jle`: Rational is RealFloat but not Floating
15:30:57 <benmachine> jle`: does that answer your question?
15:31:23 <geekosaur> all this said, it is well known that the Haskell numeric hierarchy is a bit of a mess :/
15:31:37 <geekosaur> however there are many divergent opinions on how to fix it, so nothing has been done
15:31:37 <jle`> Rational is a RealFloat?
15:31:51 <benmachine> jle`: apparently
15:31:58 <jle`> :info Rational
15:32:04 <jle`> darn
15:32:25 <jle`> it looks to me that rational is just any ordinary ADT sum type
15:32:29 <drostie> geekosaur: I was floored when I learned that descriptions of numbers, encoded as UTF-8, were natural numbers -- hence there are necessarily real numbers which it is not possible to describe with any number of letters. :x
15:32:43 <acowley> chrisdone: Warning: These are very unfair complaints. It makes things more complicated when I don't have a .cabal file in a directory. It crashes on me fairly regularly. It can't be used as a shell the way ghci can in its inferior mode.
15:32:47 <jle`> although i guess it isn't becuase it has those magic reducing/equivalency things.
15:32:58 <acowley> chrisdone: The only fair one is the crashes, but I haven't taken the time to figure out what's causing it :/
15:33:02 <piezoid> simple Attoarsec.Text combinators compile to 50k lines of Core (with O2) 0_0
15:33:03 <drostie> So maybe it's good that there is no "real number class"? :D
15:33:04 <piezoid> at least I'm sure loops are unrolled
15:33:27 <halp4352> Reals & naturals aren't bijective. Hence, floats.
15:33:39 <acowley> chrisdone: I think, as a naive user, I was really hoping it would be more of a drop-in replacement for the old ghci mode that just magically worked with sandboxes when present.
15:33:42 <jle`> i just feel like anything that can be called 'floating' necessarily can implement all of the functions in the RealFloat typeclass
15:33:45 <chrisdone> acowley: fwiw you can enable haskell-process-log so that you can look at what failed
15:33:52 <acowley> chrisdone: Yeah, that's a lifesaver
15:34:22 <jle`> hm. but Complex is floating
15:34:27 <acowley> chrisdone: I use that a lot. Which is also a bit surprising as I can't recall having really any trouble at all with plain old ghci.
15:34:57 <chrisdone> yeah it seems to work flawlessly for me, and not at all for anyone else
15:35:12 <acowley> chrisdone: I'll stop being a crappy user and put together a useful issue report at some point
15:35:19 <chrisdone> but i haven't tried cabal repl yet so there might be some horrors in there that make it not work
15:35:48 <jle`> the definition of 'floating' in haskell is things that are trig/exp/loggable.  not floating in the sense that they are floating point numbers.
15:35:49 <acowley> chrisdone: the whole cabal repl infrastructure makes it run much slower, too
15:35:54 <jle`> oh well
15:36:24 <acowley> chrisdone: Which gets everything off on the wrong foot. Especially when it crashes and you need to restart. I think it takes > 10s to start for most of my projects.
15:36:46 <chrisdone> oh does it do that whole "i'm gonna load everything even tho you didn't tell me to" like cabal-dev used to do?
15:36:56 <acowley> chrisdone: Yes
15:36:58 <benmachine> jle`: yeah, I'd think Floating really ought to be called Transcendental owtte
15:37:08 <chrisdone> sucks
15:37:11 <jle`> chrisdone, acowley: it seems to load more than cabal-dev ever did
15:37:15 <jle`> to me at least
15:38:06 <acowley> What pushes me over the edge is when it loads *everything*, then I ask for a type with :t, and it doesn't respond for so long I think it crashed so start restarting the repl and then it gives me the output
15:38:14 <benmachine> jle`: oh, fwiw, Rational is just an ordinary ADT (it is a product type)
15:38:16 <chrisdone> acowley: if you need help making it work you can always ping me on google+ and hangout with a screenshare
15:38:49 <acowley> chrisdone: Thanks, I may take you up on that. I need to get myself into a bad situation with it when I have time to work on making it work right.
15:38:58 <benmachine> jle`: the magic reducy things aren't magic, they just calculate some gcds before doing operations
15:39:10 <halp4352> benmachine: That's implementation dependent. :)
15:39:26 <benmachine> halp4352: in what sense?
15:39:40 <halp4352> in the sense that it's an ADT in ghc but no guarantees elsewhere
15:40:46 <chrisdone> acowley: nod. partly the mode suffers from not having a proper protocol layer like SLIME does. regexp matching on ghci's iffy output is an 80% solution. i started work on a 'ghc-server' program that has a proper protocol that emacs can communicate with via s-expressions, but it got put on hold
15:41:19 <benmachine> halp4352: I suppose so
15:41:51 <jle`> you can't pattern match to extract things, but you could just say that it hides the constructor
15:41:53 <chrisdone> that goes for anyone else, fyi. i'd rather you ping me on g+ and show what's not working right than keep quiet and wish it worked
15:42:03 <benmachine> jle`: you could just say that true fact :P
15:42:33 <halp4352> unrelated c ffi question: I can't determine the word/int type I should use for writing a binding to strnlen .. GHC refuses to compile w/ CSize, CULong, CInt -- http://lpaste.net/95922
15:42:52 <halp4352> I feel like it's gotta be something dumb.
15:42:58 <benmachine> halp4352: you need to have the constructors in scope, I believe
15:43:01 <ij> i'm words-ing a string, and I want to take 9 words, and then take 9 of those "take 9 words", resulting in [[String]]. I came up with "map [1..9] wordifier", might you suggest anything better?
15:43:04 <benmachine> you are only importing the types
15:43:09 <halp4352> that'd be it
15:43:10 <benmachine> that's my best guess, anyway
15:43:18 <benmachine> the error message could be more helpful
15:43:23 <jle`> benmachine: haha yeah.  but just mentioning the possiblity that it might not even have a constructors at all in the implementation.  but due to modularity, that really doesn't 'matter'
15:43:28 <benmachine> but this restriction is relatively new, possibly the error message predates it
15:44:09 <benmachine> jle`: right, yeah, it's not implementation-dependent like things in C tend to be, i.e. nasal demons
15:44:14 <halp4352> benmachine: thank you very much
15:44:25 <benmachine> halp4352: no problem :)
15:44:59 <khyperia> Woo, I finally learned what "occurs check: cannot construct the infinite type [...]" actually means! (trying to implement hindley-milner for my own language)
15:45:10 <chrisdone> lol
15:45:11 <chrisdone> yay
15:45:12 <Saizan> yay
15:46:13 <ij> How do I go from a [type] of 81 records to a [[type]] of 9x9?
15:46:44 <halp4352> ij: unsafeCoerce#
15:47:15 <ij> That sounds dangerous.
15:47:19 <jle`> lol
15:47:23 <chrisdone> :t transpose
15:47:24 <lambdabot> [[a]] -> [[a]]
15:47:29 <chrisdone> uh
15:47:35 <ij> chrisdone, That would imply I've got [[a]] already.
15:47:42 <chrisdone> it would
15:47:45 <halp4352> :t words
15:47:46 <lambdabot> String -> [String]
15:47:52 <khyperia> ij: splitEvery 9
15:47:58 <jle`> if you have [a], you can make an [[a]].
15:48:05 <khyperia> in Data.List.Split
15:48:07 <halp4352> :t splitEvery
15:48:08 <lambdabot> Int -> [e] -> [[e]]
15:49:01 <ij> Hmm, it's not in hoogle
15:49:02 <halp4352> probably implemented via take n
15:49:09 <jle`> > let l = [1,2,3,4,5,6,7,8,9] in transpose [l]
15:49:11 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9]]
15:49:16 <jle`> darn :|
15:49:21 <khyperia> ij, http://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html
15:49:33 <jle`> :t unjoin
15:49:34 <lambdabot>     Not in scope: `unjoin'
15:49:34 <lambdabot>     Perhaps you meant one of these:
15:49:34 <lambdabot>       `join' (imported from Control.Monad.Writer),
15:49:35 <ij> Is there any reason why it wouldn't be in hoogle?
15:49:43 <benmachine> you can do something with unfoldr and splitAt that isn't quite as elegant as you hoped it would be
15:50:09 <geekosaur> it may be in hoogle, but by default hoogle only shpows stuff fro,m bootlibs (that is, those that are shipped with and used by ghc itself)
15:50:16 <khyperia> ij, 'cause that link isn't the latest version of split package
15:50:31 <khyperia> "chunksOf" is the new function name
15:50:39 <khyperia> http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html
15:50:41 <halp4352> try hayoo: http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:51:00 <khyperia> Oh, never mind, hoogle doesn't find chunksOf either.
15:51:15 <halp4352> chunksOf sounds all bytestringy
15:51:42 <geekosaur> @where hayoo
15:51:42 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
15:51:56 <geekosaur> hayoo searches more than hoogle does by default
15:52:10 <geekosaur> (you can make hoogle search it but you have to know the package name last I checked)
15:52:14 <ij> I would've guessed it would be simpler, but maybe that's why I didn't write it myself. http://hackage.haskell.org/package/split-0.1.1/docs/src/Data-List-Split-Internals.html#splitEvery
15:52:47 <halp4352> ij: I dunno. That seems pretty simple.
15:53:02 <johnw> fpcomplete.com/hoogle is a more complete Hoogle also
15:53:08 <ij> I'm a noob then. :)
15:53:20 <halp4352> ij: :D
15:53:34 <halp4352> ij: that package looks really complex for what it does
15:53:54 <geekosaur> there's umpteen different ways you can split a string/list
15:54:06 <geekosaur> the split package tries to provide as many ways as it can
15:54:33 <geekosaur> (and dealing with String vs. ByteString vs. Text is also rather complex, sadly)
15:54:59 <halp4352> now that I'll agree to
15:55:11 <halp4352> doesn't help that Text likes to hide all the fun internal packages
16:12:48 <halp4352> :t hypothetically
16:12:50 <lambdabot> Not in scope: `hypothetically'
16:13:19 <halp4352> :t realWorld
16:13:19 <lambdabot> Not in scope: `realWorld'
16:17:00 <ij> :t RealWorld
16:17:01 <lambdabot> Not in scope: data constructor `RealWorld'
16:17:14 <halp4352> the constructor is actually lowercase, for whatever reason
16:17:22 <halp4352> (in GHC)
16:21:37 <acowley> jonsterling: ping?
16:21:45 <jonsterling> acowley: What's up?
16:22:41 <acowley> Regarding the <<|>> proposal
16:22:42 <acowley> It would be nice to build the (alt :& alt :& RNil) values automatically
16:22:55 <acowley> which would seem to be adding a pointed to Apply
16:23:55 <jonsterling> Whoa.
16:23:56 <acowley> I'm focusing on that alternate definition because I'm not sure adding a new class is warranted
16:24:29 <acowley> but the requested capability seems like a good thing
16:24:51 <jonsterling> I did indeed really like the second definition in terms of Apply. I tried once to add some kind of point to that, but I couldn't figure out how to do it. If this is indeed what a point would look like for Apply, then we should do it and make it a proper generalized Applicative...
16:25:47 <acowley> Does the class need to be parameterized by arr, or can we move that to the type of <<*>>?
16:26:14 <acowley> Because that would make the pure-equivalent a bit icky for instance resolution
16:26:25 <halp4352> *shiver* arrows...
16:26:48 <acowley> Or maybe profunctors! They have less baggage.
16:27:29 <jonsterling> Hmmmmm... I don't know off the top of my head what the right thing to do is quite... Maybe we should put together a little proposal PR which demonstrates one or two approaches.
16:28:12 <jonsterling> By the way, I've created a #vinyl channel that we can use as well for this sort of thing. I don't care much either way though...
16:28:38 <acowley> it was quiet here
16:33:10 <acowley> gah this is finicky
16:33:18 <acowley> Okay, bad choice for a short diversion
16:42:42 <prooftechnique> Is there a nicer way to write this?
16:42:44 <lpaste> prooftechnique pasted “parser” at http://lpaste.net/95923
16:44:48 <acowley> prooftechnique: At least you could use T.unwords rather than the manual space prepending
16:45:14 <prooftechnique> acowley: It's the production I'm trying to match.
16:45:26 <acowley> prooftechnique: So more becomes: char ' ' *> name
16:45:49 <acowley> This doesn't change the accepted grammar
16:46:26 <prooftechnique> Right, but I think I need to preserve the space. I wrote it as you did just now, but it eats the space
16:47:23 <acowley> names = T.append <$> name <*> (T.unwords <$> many (char ' ' *> name))
16:47:30 <acowley> Something like that
16:54:59 <dmwit> T.unwords <$> manySepBy (char ' ') name
16:55:33 <prooftechnique> @hoogle manySepBy
16:55:34 <lambdabot> No results found
16:55:36 <acowley> my edits were incremental changes from the original
16:55:47 <dmwit> T.unwords <$> sepBy1 (char ' ') name -- I mean
16:55:58 <dmwit> Oh, I still got it wrong.
16:56:01 <dmwit> Anyway, read the documentation.
16:56:04 <acowley> hah
16:56:07 <prooftechnique> :D
16:56:09 <acowley> Did my version work?
16:56:47 <prooftechnique> It still ate the space. I had written it closer to that way at first, but I got it into my head that I should preserve it, so I made it all explicit and wacky and was then going to make it prettier from there
16:57:11 <dmwit> acowley: Yours eats the first space.
16:57:11 <acowley> Oh, you mean the first space
16:57:19 <prooftechnique> Right
16:57:34 <acowley> I'd still do it this way and just insert that first space rather than manually put them everywhere
16:59:02 <dmwit> Yeah, I find it very strange that you want the value returned to be just as unstructured as the thing you "parsed".
16:59:34 <acowley> This is a validator
16:59:39 <acowley> so should just return ()
16:59:52 <dmwit> Less structured I understand.
16:59:58 <dmwit> Just the same as I understand more structured.
17:00:02 <dmwit> But equally structured is weird.
17:00:39 <prooftechnique> Ultimately, this is going to be an XML parser (*ducks*), I'm just trying to get the hang of attoparsec with some of the less ridiculous productions in the standard
17:01:19 <dmwit> Oh, sepBy1 is parsec material. Dunno what it's called in attoparsec.
17:01:23 <dmwit> But I'm sure it's there.
17:02:28 <prooftechnique> dmwit: It is there, as it happens
17:03:04 <prooftechnique> I did remove that redundant char ' ' line in what I pasted, though
17:03:12 <prooftechnique> I just realized how bizarre that was
17:03:18 <prooftechnique> Given that I'm just putting one in
17:04:05 <prooftechnique> Oh, wait, no. That's not quite what I'm after. yeesh
17:04:50 * dmwit swears under his breath
17:04:58 <dmwit> Do what I mean, dammit!
17:05:06 <prooftechnique> I know, right? :D
17:07:23 <hpc> dmwit: ah, DWIMD compliance
17:08:11 <dmwit> Now you know the true meaning of my nick.
17:08:25 <acowley> dmwit: You probably mean, "Do what I mean, tuna!" whose initialism is an anagram of your nick.
17:08:45 <hpc> does mostly what i think
17:08:46 <dmwit> Also, I am a time traveler.
17:08:54 <bz> :t liftM
17:08:56 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
17:08:57 <bz> :t fmap
17:08:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:09:03 <bz> :t (<$>)
17:09:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:09:09 <dmwit> :t liftA
17:09:10 <lambdabot> Applicative f => (a -> b) -> f a -> f b
17:09:18 <acowley> hpc: isomorphic to: is a bit surprising
17:09:45 <hpc> quick, acronym for my nick!
17:09:48 <bz> so i'm guessing that if Monad C Functor then liftM == fmap
17:09:51 <hpc> haskell program coverage doesn't count
17:09:59 <dmwit> bz: correct
17:10:20 <dmwit> hpc: "highlights people constantly"
17:10:28 <hpc> haha
17:10:31 <hpc> i really do
17:10:36 <dmwit> =D
17:11:23 <heatsink> high performance computing, obviously
17:11:32 <dmwit> oh, bravo
17:11:46 <hpc> hasty pudding cipher!
17:13:25 <acowley> I'll bring it back on topic: Haskell Platform Czar. Sorry, Mark.
17:13:35 <dmwit> Cake, piping hot.
17:13:38 <hpc> the c is czar
17:15:08 <prooftechnique> Horridly poisonous czar
17:16:32 <geekosaur> hot pickled catfish
17:16:47 <dmwit> ick
17:17:48 <geekosaur> (I wrote "...carp" at first, decided that was too open to interpretation :p )
17:19:37 <heatsink> he's pretty cool
17:20:39 <ion> he’s pretty, cool.
17:26:45 <dmwit> in other news, he's pretty cool. have extra ail there so I'm not killed after crossing over the walkway leftward/eastward, yes?
17:26:54 <dmwit> okay, that didn't work out too well
17:26:56 <dmwit> but I tried
17:27:03 <dmwit> s/ail/ale/ I guess
17:31:45 <mirpa> who's pretty cool?
17:32:18 <dmwit> hpc
17:33:26 <mirpa> haskell program coverage?
17:33:53 <hpc> that's me!
17:34:11 <mirpa> ah :-)
17:36:04 <testingok> can someone explain to me how (e ->) is a functor, or know of a good document?
17:36:55 <dmwit> Have you heard the "container" analogy for containers?
17:37:03 <dmwit> uh
17:37:04 <ion> testingok: Functor requires fmap :: (a -> b) -> f a -> f b. Let f = (e ->). Can you come up with fmap :: (a -> b) -> (e -> a) -> e -> b?
17:37:09 <dmwit> for functors, of course. =)
17:37:14 <augur_> man
17:37:16 <testingok> dmwit: lol
17:37:21 <augur_> stateful binding is complicated :(
17:37:51 <CADD> augur_: at least you arent doing it in c.
17:37:51 <dmwit> augur_: If you mean State(T)'s (>>=), well... you get used to it, like all math. =)
17:38:02 <augur_> dmwit: no no
17:38:23 <augur_> i mean an LC with variable state
17:38:40 <dmwit> oh
17:38:51 <augur_> trying to figure out how to wrap my head around scope/capture issues
17:38:53 <Hari`> fmap for functions is function composition -- see Learn You a Haskell (lyah.com i think)
17:38:53 <dmwit> I've never really studied an LC with state. What makes it complicated?
17:39:08 <dmwit> I mean, I've seen LC with refs.
17:39:22 <dmwit> But then there's nothing complicated about name binding there.
17:39:46 <ion> testingok: When you come up with a definition for the function, also check that fmap id = id and fmap (f . g) = fmap f . fmap g. If the laws aren’t broken, you have successfully answered your question.
17:40:31 <augur_> dmwit: well, in the system im working in, there are issues with capture and duplication of names and such
17:41:04 <Twey> testingok: Functors have some kind of value they ‘contain’ (for some definition of ‘contain’ that includes things that don't exist yet, that can be generated by the functor).  For functions, that value is the result of the function when applied to a value.
17:41:06 <heatsink> Usually, mutable variables are treated as immutable references to dynamically allocated storage
17:41:56 <heatsink> So you follow the same scoping rules as in pure LC to know what piece of storage each variable refers to
17:42:15 <augur_> heatsink: yeah thats true
17:42:25 <augur_> im using a version of the LC with some more complicated stuff tho :(
17:42:27 <testingok> ion: what is that definition saying exactly? That you have a function that goes from a to be, and that you can give it another function that returns a, and it gives you a function that returns b?
17:42:58 <dmwit> I feel like asking "how come Foo is a Functor" and hearing "here are the types and laws for Functor, *you* figure it out" is a bit like asking "how come cos 0 = 1" and hearing "well, here's the power series for cos, *you* figure it out" instead of just drawing a circle and pointing at the appropriate point on it
17:43:10 <Twey> Heh, aye
17:43:23 <augur_> dmwit: shhh copumpkin might hear you :x
17:44:12 <dmwit> testingok: Yes, exactly.
17:45:38 <heatsink> The "monads as containers" and "monads as computations" analogies are both useful
17:45:59 <heatsink> but there are some monads that can't easily be interpreted as containers, or as computations
17:46:06 <Twey> testingok: The fundamental operation of a functor is fmap, which represents the ability to apply a function to the value the functor ‘contains’.  So fmap for a function is composition: you're applying a function to the (eventual) result of evaluating that function on an argument.
17:46:12 <ion> testingok: You give me a function (a -> b), a function (e -> a), a value (e) and i’ll give you back a value (b).
17:46:13 <heatsink> So the only thing that all monads _really_ have in common is the monad laws
17:46:32 <CADD> heatsink: do you have any examples?
17:46:52 <dmwit> heatsink: You won't get an argument out of me, other than to point out that the particular functor under question has a particularly enlightening interpretation as a container.
17:47:02 <dmwit> (in my opinion)
17:47:04 <testingok> Twey: so lets say my a->b is (+1)
17:47:15 <CADD> heatsink: of monads not acting as computation or containers, i mean.
17:47:18 <testingok> it takes an Int and returns an Int
17:47:19 <heatsink> CADD, edwardk's free variable monad
17:47:43 <CADD> heatsink: thanks, i havent taken a look at that yet.
17:48:02 <testingok> so, i can give a (+2) for my e->b?
17:48:16 <dmwit> testingok: Yep, for example.
17:48:17 <heatsink> CADD, In section "Bird and Paterson, Part 1" here https://www.fpcomplete.com/user/edwardk/bound#higher-order-abstract-syntax--hoas-
17:48:20 <Twey> testingok: Aye
17:48:35 <testingok> > fmap (+1) (+2) 3
17:48:37 <lambdabot>   6
17:48:49 <CADD> heatsink: awesome, thanks a bunch!
17:48:49 <dmwit> > fmap (+x) (+y) z
17:48:51 <lambdabot>   z + y + x
17:49:08 <Twey> testingok: So fmap (+ 1) (+ 2) is the function that adds 2, and then performs (+ 1) on the result
17:49:16 <Twey> Which happens to be the same thing as (.)
17:49:17 <CADD> heatsink: oh, this is in context of his bound library
17:49:19 <CADD> ?
17:49:46 <CADD> heatsink: sorry, you mean the paper?
17:50:05 <heatsink> Well, I learned about that monad from that website
17:50:08 <heatsink> webpage
17:50:17 <Twey> testingok: Where ‘the result of adding 1 to something’ is the thing ‘inside’ (+ 1)
17:50:18 <CADD> thanks, ill take a look
17:50:30 <Twey> Er, sorry, s/1/2/
17:50:31 <Twey> g
17:50:39 <heatsink> dmwit, oh, I didn't see the question about (e ->) that motivated the discussion
17:51:27 <heatsink> There's probably a few papers behind it
17:51:33 <testingok> thats hard to wrap my head around :)
17:51:49 <Twey> testingok: I think Maybe is the easiest functor to understand (after Identity) because it actually has a value in it.  So, for example, fmap (+ 1) (Just 3) gives you (Just 4).
17:52:03 <dmwit> testingok: don't worry, heads are crazy expandable =)
17:52:21 <Twey> testingok: The only difference with functions is that the value you're performing the operation on doesn't exist yet
17:52:34 <heatsink> heh
17:53:17 <testingok> so in the case of Maybe, you are applying or resolving the context, which gives you a 4
17:53:47 <testingok> but in the case of (+1), when you apply or resolve that, you evaluate the context to the value that isnt present yet
17:54:03 <heatsink> An approximate equivalent with functions is fmap (+1) (const 3)
17:54:37 <Twey> testingok: The ‘context’ term is part of the ‘functors as computation’ metaphor, which isn't the one we're using here
17:54:49 <arkeet> Cont r is a pretty fun functor.
17:55:00 <acowley> dmwit's first career as a milliner was not entirely successful.
17:55:07 <Twey> testingok: Rather, think of it like a box with something inside it :þ
17:55:10 <CADD> testingok, Twey: I think the 3rd easiest would then be the these functor. http://hackage.haskell.org/package/these-0.3/docs/Data-These.html
17:55:22 <arkeet> These isn't a functor.
17:55:26 <arkeet> well, not a Functor
17:55:27 <dmwit> ?wn milliner
17:55:29 <lambdabot> *** "milliner" wn "WordNet (r) 3.0 (2006)"
17:55:29 <lambdabot> milliner
17:55:29 <lambdabot>     n 1: someone who makes and sells hats [syn: {hatmaker},
17:55:29 <lambdabot>          {hatter}, {milliner}, {modiste}]
17:55:31 <CADD> it has a functor instance
17:55:35 <dmwit> heh
17:55:36 <arkeet> not These
17:55:43 <heatsink> This is the first time I've heard of these
17:55:52 <CADD> oh, my bad
17:55:56 <dmwit> These is great.
17:55:59 <arkeet> it is.
17:56:06 <CADD> yeah, its is
17:56:14 <Twey> CADD: ‘These a’ is a functor.  But yes.
17:56:37 <dmwit> The best thing about These is how messed up your grammar looks to somebody who doesn't know what These is.
17:56:45 <Twey> Hahah
17:56:48 <CADD> lol
17:56:58 <Twey> Especially when you start talking about These a, I imagine
17:57:25 <Twey> (and there goes the semantic saturation)
17:57:49 <testingok> i think im more confused now
17:57:59 <testingok> i cant even trust english anymore
17:58:22 <CADD> testingok: a look at the source can always help
17:58:43 <testingok> i think ill make a Those type
17:59:33 <dmwit> testingok: Have you played with all of Identity, Maybe, [], and Tree as functors?
18:00:04 <dmwit> or any of them?
18:00:34 <heatsink> or These?
18:00:35 <testingok> yes, i believe i understand the "functors as a box/container" metaphor
18:00:52 <dmwit> Okay, cool.
18:01:07 <dmwit> So, the idea is that there's a bunch of "positions" in your container that each have a value.
18:01:09 <CADD> testingok: alright great, applicatives is the next step
18:01:13 <dmwit> fmap modifies the value in every position.
18:01:15 <dmwit> Right so far?
18:01:27 <testingok> correct
18:01:36 <dmwit> Cool. So, what if we named all the positions?
18:01:40 <dmwit> Would that be okay?
18:01:47 <dmwit> e.g. for lists, the names would be like 0, 1, 2, ...
18:02:02 <testingok> sure
18:02:09 <dmwit> For trees the names would be like [Top], [Left, Top], [Left, Right, Left, Right, Right, Top], etc.
18:02:17 <dmwit> okay
18:02:20 <dmwit> Get ready.
18:02:29 <dmwit> For (e ->), the positions have names drawn from e.
18:03:03 <dmwit> That is, you can think of a function "e -> a" as being a bunch of positions -- one for each "e" -- and an "a" in each position.
18:04:08 <dmwit> Still with me?
18:04:26 <testingok> so we could say, that the type of "e" is locked, and the "a" could be anything?
18:04:32 <testingok> like a one-to-many relationship?
18:04:37 <dmwit> hm
18:04:49 <dmwit> I'm not sure I'm on board with "one-to-many".
18:04:59 <dmwit> Each value for "e" has exactly one "a" associated with it.
18:05:31 <testingok> like a lookup table?
18:05:34 <heatsink> yes
18:05:37 <dmwit> Exactly!
18:05:42 <testingok> \o/
18:06:00 <dmwit> Then fmap is just modifying the entries in the lookup table.
18:06:10 <dmwit> Keep all the same keys, and change the values.
18:06:14 <prooftechnique> I have never seen These before
18:07:11 <testingok> ok, that seems reasonable :)
18:07:18 <acowley> These are the values you're looking for
18:07:58 <CADD> prooftechnique: yeah its a nice semantic middle ground. good invariants.
18:08:01 <CADD> acowley: lol
18:08:02 <dmwit> These things here is the type of a thing that might be things or might be here, or both.
18:08:05 <testingok> > fmap (+2) (*3) 2
18:08:06 <lambdabot>   8
18:08:36 <testingok> > fmap (+3) (*2) 2
18:08:37 <lambdabot>   7
18:08:52 <Twey> dmwit: Actually I think you'll find it's a distinct type from thing.  *hides*
18:09:14 <Twey> And we didn't even introduce an a!
18:09:15 <benzrf> ok so i know almost nothing about parsing
18:09:29 <testingok> ok, so im modifying the output of my LUT
18:09:35 <dmwit> Twey: "things" and "here" are type variables ;-)
18:09:39 <benzrf> but as i understand it, in parsec you get monads where each value represents a parser and then you combine them monadically?
18:09:43 <testingok> how simple. why didnt you guys tell me that in the first place!
18:09:44 <testingok> :)
18:09:48 <Twey> dmwit: Oh, damn it xD
18:10:01 <Twey> testingok: It's always simple once you understand it :þ
18:10:04 <dmwit> testingok: I tried to, but other people were explaining and I thought maybe too many cooks, spoiled broth, etc...
18:10:06 <benzrf> how do you get them to return a value of a type other than string then?
18:10:07 <CADD> benzrf: well, you are combining parser combinators.
18:10:21 <CADD> benzrf: or i mean, composing.
18:10:30 <Twey> benzrf: Because they're monads — they have an associated return type
18:10:51 <benzrf> Twey: hmm wait
18:10:54 <testingok> thanks guys. ill sleep easy tonight
18:11:02 <benzrf> so I can do this to get a number parser:
18:11:07 <Twey> You can change that return type by fmapping a function inside (or equivalent)
18:11:09 <acowley> silly broth, can't handle the intensity of #haskell helpfulness
18:11:16 <Twey> Hehe
18:11:19 <benzrf> numParse = many digit >>= read ?
18:11:27 <Twey> benzrf: >>= return . read
18:11:31 <benzrf> hm?
18:11:38 <benzrf> oh right
18:11:39 <Twey> Also known as numParse = read <$> many digit
18:11:40 <benzrf> derp, forget my return
18:11:41 <dmwit> You could do that. But don't.
18:11:45 <benzrf> dmwit: why not?
18:11:52 <dmwit> read is already a parser. =)
18:12:11 <benzrf> dmwit: you can compose it with parsec parsers?
18:12:17 <dmwit> No, it's not a parsec parser.
18:12:27 <benzrf> then what if you want to use it with them?
18:12:30 <dmwit> But what I'm saying is that you're duplicating a lot of computation if you use read inside a Parsec parser.
18:12:35 <benzrf> alright...
18:12:46 <benzrf> is there a better way to get a number out of one?
18:12:59 <dmwit> Yes, use a function that assumes the input is in the correct format.
18:13:10 <CADD> dmwit: i think the right way(tm) example would help
18:13:29 <dmwit> Well, the simplest way is just to use Parsec's built-in number parser.
18:13:44 <dmwit> But the Right Way is parser-specific.
18:13:55 <CADD> that makes sense
18:14:00 <benzrf> ahihi2:
18:14:02 <benzrf> *ah
18:14:08 <dmwit> e.g. it depends on whether you accept negatives, scientific notation, hex, fractions, or what
18:14:10 <benzrf> ok
18:15:15 <dmwit> > Prelude.- 3
18:15:18 <lambdabot>   <hint>:1:1: parse error on input `Prelude.-'
18:15:38 <Twey> benzrf: sum . zipWith (*) (iterate (* 10) 1) . reverse . map digitToInt <$> many digit -- for simple decimal naturals
18:16:24 <dmwit> > read "( ((- 0xa) )     ) " :: Int
18:16:25 <lambdabot>   -10
18:16:39 <copumpkin> augur_?
18:16:49 <benzrf> ._>
18:16:53 <augur_> copumpkin: :x
18:16:58 <copumpkin> what was that comment
18:17:02 <benzrf> that is impressively powerful parsing
18:17:05 <benzrf> siht
18:17:06 <benzrf> *shit
18:17:28 <dmwit> copumpkin: I was saying something about how people should teach intuition first and details second. augur was objecting that you might not like that approach.
18:17:30 <augur_> copumpkin: dmwit said dealing with definitional equations isnt enough, and i know you're one of those "just hack it through" people
18:17:39 <copumpkin> I am?
18:17:46 <acowley> you are now
18:17:52 * copumpkin sighs
18:18:14 <copumpkin> not sure what gave you that impression
18:18:15 <benzrf> is a copumpkin like a comonad?
18:18:15 <jtcwang> anyone uses Vim here? I installed haskellmode-vim and i'm trying to get :make to work
18:18:20 <benzrf> jtcwang: i use vim!
18:18:22 <benzrf> but not haskellmode
18:18:30 <benzrf> you could try #bim
18:18:31 <benzrf> *vim
18:18:34 <jtcwang> oh what do u use instead?
18:18:40 <benzrf> i don't use any of that
18:18:42 <benzrf> i just use vim
18:18:42 <benzrf> ._.
18:18:45 <jtcwang> what's ur workflow like?
18:19:00 <benzrf> i type some code into vim, then I press :!runhaskell %
18:19:07 <benzrf> or i tab out and use my shell
18:19:13 <benzrf> which is designed for doing that kind of thing
18:19:20 <jtcwang> i see
18:19:27 <jtcwang> runhaskell is ur self defined command?
18:19:29 <benzrf> no
18:19:34 <benzrf> :!calls out to shell
18:19:38 <jtcwang> oh right
18:19:47 <benzrf> why not just tab between vim and your shell window?
18:19:54 <jtcwang> Doesn't help that i'm trying to learn vim + haskell at the same time haha
18:19:55 <benzrf> or make a keybind to run a shell command if you use it enough?
18:20:09 <dmwit> bah
18:20:11 <jtcwang> yeah i'll look into it
18:20:15 <benzrf> the way i see it, shells are great for running code and building things cuz that's what shells are for
18:20:19 <dmwit> I also do low-tech things when hacking on Haskell in vim.
18:20:20 <benzrf> \why make your editor do all the work?
18:20:22 <benzrf> unix stuff
18:20:24 <dmwit> But I don't have to like it!
18:20:28 <dmwit> I wish for something better.
18:20:32 <benzrf> dmwit: make a keybind
18:20:32 <benzrf> :-D
18:20:32 <acowley> It's called emacs
18:20:33 <jtcwang> well if i can stay in one thing
18:20:35 <hattmammerly> is it just an american thing how we never discss how much we make
18:20:35 <dmwit> ...without having to learn emacs. >:|
18:20:35 <jtcwang> its good
18:20:43 <hattmammerly> darn, beaten to the punch
18:20:44 <jtcwang> like visual studio
18:20:48 <benzrf> i figure
18:20:49 <hattmammerly> oh shoot
18:20:50 <CADD> yeah, as an emacs user. i couldnt suggest it more
18:21:03 <benzrf> if i ever catch myself installing 20 plugins to autocomplete my code
18:21:09 <hattmammerly> disregard the first thing I said, I hit up and sent the wrong thing :(
18:21:09 <benzrf> ill just switch to emacs
18:21:20 <Twey> dmwit: Introduction to Emacs: press a key to type that character.  The up arrow goes up.  The down arrow goes down.  The left and right arrows are left as an exercise to the reader.  :þ
18:21:24 <benzrf> as it is i use vim for text editing
18:21:25 <benzrf> ;p
18:21:33 <CADD> benzrf: :D haskell-mode. c-c c-l
18:21:40 <benzrf> CADD: does which?
18:21:42 <dmwit> Twey: Okay. What's the equivalent of diw? di%? dip?
18:21:53 <jtcwang> nothing against emacs, it just sound very yummy so i chose vm instead
18:21:54 <CADD> benzrf: it load the current file into a persisten ghci session
18:22:05 <benzrf> dmwit: C-c M-e C-e M-x
18:22:07 <Twey> dmwit: Sorry, I don't speak vi :þ
18:22:09 <acowley> emacs is a magical wonderland whose only downside is that, if your hands end up misaligned on the keyboard, you might reformat your hard drive while launching a game of tetris when you just wanted to open a file.
18:22:16 <Twey> Hahah
18:22:20 <jtcwang> lol
18:22:26 <CADD> acowley: there is always god-mode for that
18:22:28 <shelf> i use ghc-mod in vim for syntax, occasional typechecking of subterms, basic completion
18:22:29 <jtcwang> well anyone uses haskellmode-vim here?
18:22:43 <dmwit> Twey: How do I delete the word my cursor is over? paragraph? parenthesized block?
18:22:48 <acowley> CADD: Would misaligned hands then lead to an actual fatality?
18:22:51 <dmwit> Twey: And a million others.
18:23:00 <benzrf> jtcwang: emacs is if you want a super powerful Editing Environment with bajillions of commands and stuff that writes half your code for you
18:23:10 <dmwit> Twey: These are all actions I do without thinking. I know I'd be horribly frustrated for at least a year and a half if I switched.
18:23:11 <Twey> dmwit: Aye, but thats advanced emacs.  emacs scales with you!
18:23:20 <benzrf> jtcwang: vim is if you want super fast and efficient text editing
18:23:31 <CADD> acowley: check it out: https://github.com/chrisdone/god-mode
18:23:34 <jtcwang> basically i'm just trying to get it to build and run from inside vim
18:23:39 <benzrf> jtcwang: why?
18:23:48 <dmwit> Twey: I have already scaled...
18:23:52 <benzrf> why send an editor to do a shell's jon
18:23:53 <benzrf> *job
18:24:02 <jtcwang> cuz i am clueless about haskell workflow lol
18:24:04 <acowley> CADD: omnipotence not included?
18:24:16 <CADD> acowley: :D
18:24:20 <Twey> benzrf: I've never been convinced about that.  It seems the mode-switching should make it less efficient.  I don't suppose you'd mind sending a transcript of your vim session to chrisdone for comparison?  I understand he's collecting them
18:24:22 <jtcwang> like how to build exe using ghc
18:24:31 <dmwit> Twey: I just want my "compute the type of this expression" keybinding. =)
18:24:41 <benzrf> Twey: but you dont switch modes much
18:24:44 <benzrf> just after typing
18:24:45 <benzrf> :P
18:24:49 <dmwit> (And I don't think emacs has that, either.)
18:24:52 <hattmammerly> jtcwang: runhaskell is a stock command, just do :!runhaskell % or whatever it is
18:25:12 <jtcwang> got it thanks hattmammerly
18:25:15 <benzrf> Twey: frankly im probably terrible at vim
18:25:19 <benzrf> dont use me as an example
18:25:19 <benzrf> ;p
18:25:34 <arkeet> Twey: vim is pretty cool
18:25:43 <arkeet> it takes as much time to switch modes as it does to hit ctrl in emacs.
18:25:56 <arkeet> ;)
18:26:07 <Twey> arkeet: My thumb is always on ctrl, so I doubt that very much :þ
18:26:21 <CADD> Twey: I tend to use a combination of both. if i am in insert mode and only want to do a quick c-f then I will, otherwise if i have a bunch of stuff i want to do, i think it works rather well
18:27:09 <arkeet> Twey: whatever layout you're using, it sounds awkward
18:27:10 <arkeet> :p
18:27:29 <Twey> dmwit: It's C-TAB
18:27:34 <CADD> Twey: I have it set to default on all the buffers, but i tend to be in insert mode most of the time anyway. its just a nice convenience.
18:27:35 <dmwit> arkeet: https://www.google.com/search?q=kinesis+advantage
18:28:01 <dmwit> worth every penny
18:28:04 <arkeet> oh one of those things
18:28:11 <Twey> dmwit: (I had to look it up: haskell-mode always shows the type of the symbol at point)
18:28:12 <dmwit> I can't speak for Twey, of course.
18:28:16 <Twey> dmwit is correct
18:28:21 <dmwit> Twey: symbol /= subexpression
18:28:40 <Twey> dmwit: I know, but I don't usually use the subexpression.  C-TAB does that (for the region).
18:28:52 <dmwit> ...coooool
18:29:11 <dmwit> Even inside where blocks and stuff?
18:29:18 <Twey> Sorry, C-c TAB
18:30:34 <acowley> Actually I have a question for ghc-mod users. In my emacs (Aquamacs built on emacs 23.4.1) I get pretty highlighting, but when I try emacs 24 I get less pretty squiggly-line style highlighting on warnings and such.
18:30:49 <acowley> Does anyone here use ghc-mod on emacs 24?
18:31:27 <Twey> dmwit: Oh, apparently I lied
18:31:50 <Twey> Sorry :-\  The documentation says ‘expression’
18:32:25 <dmwit> What's the implication of that?
18:32:30 <dmwit> No free variables allowed or something?
18:32:32 <peddie> acowley: I dunno what you mean by 'pretty highlighting,' but I use custom-set-faces to change the highlighting style for flymake
18:32:53 <Twey> dmwit: No, it does something quite different to what I want
18:32:58 <Twey> s/I/you/
18:33:12 <acowley> peddie: I've never customized my highlighting. What I call pretty just changes the background color of the span
18:33:26 <Twey> I'll try setting up ghc-mod and get back to you.  It says it does this, but I don't trust docs any more.  :þ
18:33:36 <acowley> peddie: I guess that's something I could customize if it breaks with a new version of emacs
18:33:38 <peddie> acowley: I see; I explicitly didn't want the background color, and I changed it to use underlining, but I suspect you can configure this in the same way
18:33:43 <acowley> But emacs terrifies me
18:33:48 <acowley> It's much bigger than I am
18:34:04 <CADD> acowley: thats the beautiful part about it
18:34:18 <heatsink> bash shell recognizes lots of emacs commands
18:34:27 <acowley> CADD: I agree! I love that I've used it for a heck of a long time and don't know a fraction of a percent of it.
18:34:50 <dmwit> Twey: Ah HA! I knew it! You do low-tech stuff, too. =D
18:34:51 <acowley> There's pretty much always a way of doing whatever it is you want to do
18:35:09 * Twey cries.
18:35:13 <peddie> acowley: something like (custom-set-faces
18:35:23 <CADD> acowley: and how easily modes tend to share commands. although it does suck when the clash.. :)
18:35:23 <peddie> '(flymake-errline ((((class color)) (:underline "red")))))
18:35:24 <Twey> dmwit: ghc-mod is supposed to be awesome and do all that stuff, but I haven't got around to installing it yet :þ
18:35:31 <Twey> dmwit: There's a vim mode too
18:35:42 <acowley> CADD: Yes, the fragility is a pretty big downer
18:35:46 <dwcook> acowley, sounds like JavaScript programmers
18:35:59 <acowley> peddie: Oooh, that looks pretty reasonable, thanks!
18:36:07 <dmwit> Twey: I'll look into it. Thanks for the pointer.
18:36:12 <dmj`> does vim for haskell have built in ghci repl?
18:36:19 <peddie> acowley: the other variable is flymake-warnline for warnings
18:36:23 <acowley> dwcook: I'm willing to accept more uncertainty in my editor than my programming language :P
18:36:34 <dwcook> haha
18:36:48 <acowley> ghc-mod is wonderful!
18:36:54 <jtcwang> so i have main = putStrLn "hello, world" in an hs file
18:36:54 <CADD> acowley: try m-x customize-group RET flycheck-faces RET
18:37:06 <CADD> acowley: you are using flycheck?
18:37:07 <acowley> flymake, type inseration, auto-complete, etc.
18:37:13 <jtcwang> but when i type :!runhaskell % i get naked expression error
18:37:15 <acowley> No, flymake
18:37:16 <CADD> kk, hopefully that helps
18:37:19 <CADD> hm
18:37:30 <jtcwang> "naked expression at top level"
18:37:46 <jtcwang> anyone know what i'm doing wrong here?
18:37:56 <geekosaur> probably thinking that ghc is like ghci
18:38:04 <geekosaur> a source file contains bindings
18:38:09 <CADD>   geekosaur lol
18:38:13 <geekosaur> a = some_expression
18:38:13 <dmwit> jtcwang: WFM
18:38:15 <benzrf> woo
18:38:22 <dmwit> jtcwang: Show us your exact file (the whole thing) and error (the whole thing).
18:38:24 <dmwit> ?hpaste
18:38:24 <lambdabot> Haskell pastebin: http://lpaste.net/
18:38:25 <benzrf> i used parsec and now i have a program
18:38:30 <geekosaur> if you just have some_expression then it's a bare expresison at top level
18:38:32 <jtcwang> ?hpaste
18:38:33 <lambdabot> Haskell pastebin: http://lpaste.net/
18:38:35 <benzrf> where you put in a ld calculus expr & it normalizes it
18:38:35 <benzrf> :D
18:38:37 <acowley> No bindings, no shoes, no type check
18:38:44 <geekosaur> (whereas that works in ghci and you have to say let a = some_expresison for a binding)
18:38:44 <dmwit> geekosaur: Well, he did specifically say he wrote main =
18:38:45 <CADD> acowley: lol
18:38:56 <geekosaur> so that could mean bad indentation
18:38:58 <dmwit> although perhaps he also put a let or something =)
18:39:35 <dmj`> jtcwang: try echo "main = print 4" >> file.hs && runhaskell file.hs
18:39:46 <dmwit> s/>>/>/
18:39:51 <jtcwang> sec
18:40:05 <jtcwang> i'm running it from vim, fyi
18:40:07 <dmwit> unless you want to find out about all the other errors that were already in file.hs ;-)
18:40:35 <jtcwang> here's my source file http://lpaste.net/95927
18:41:20 <jtcwang> oh wut now it works with :!runhaskell %
18:41:25 <jtcwang> it didn't b4 welp
18:41:30 <dmwit> Another satisfied customer!
18:41:32 <geekosaur> hm. by any chance did you add the `main =` later and then forget to save it?
18:41:39 <dmj`> jtcwang: are you running it in ghci?
18:41:43 <jtcwang> nope
18:41:49 <dmwit> geekosaur: :! saves before it runs
18:41:51 <jtcwang> my current setup is vim + haskellmode-vim
18:41:52 <dmwit> ...well
18:41:58 <dmwit> It does here, but then maybe that's a local setting.
18:42:01 <jtcwang> oh well i did ctrl-s
18:42:05 <geekosaur> does it? that generally requires `:set autosave`
18:42:11 <jtcwang> seems like it saved cuz it said "write blablabla to blabalbalb"
18:42:11 <dmj`> :! drops into the shell
18:42:35 <jtcwang> well thanks guys
18:42:39 <benzrf> jtcwang: ctrl+s does not save
18:42:40 <jtcwang> i can continue doing some basic problems now
18:42:46 <benzrf> jtcwang: :w saves
18:42:59 <dmwit> geekosaur: Okay. :set autowrite? says it's on here, but you're right that I shouldn't assume it is on for jtcwang. =)
18:43:07 <geekosaur> yeh
18:43:12 * startling can't tell if we're talking about vim or ghci
18:43:18 <dmwit> vim
18:43:22 <jtcwang> oh sry, by vim i mean gvim in windows
18:43:23 <geekosaur> autowrite, yes. only reason I'm still up is laundry :/
18:43:24 <startling> ah.
18:43:32 <jtcwang> so i think it does
18:43:59 <jtcwang> what does autowrite setting do?
18:44:07 <dmwit> jtcwang: :help 'autowrite'
18:44:13 <jtcwang> yes!
18:44:18 <jtcwang> that's right i should do that
18:44:45 <jtcwang> i see
18:44:47 <jtcwang> got it
18:45:03 <jtcwang> thx for the help guys
18:45:10 <CADD> dmwit: hey, so i have been struggling setting up lambdabot with ssl and a channel password. the newest major release is great, btw.
18:45:24 <geekosaur> can be quite nice for stuff like this, not so nice if you shell out constantly with few changes that won't affect whatever you're doing
18:45:37 <CADD> dmwit: could you maybe guide me to a page on the syntax of the config? i could find an example anywehere. i even looked through irc logs.
18:45:46 <geekosaur> then again, with a window system or even screen/tmux there's less need to shell out of the editor for stuff unrelated to the file you're working on...
18:45:47 <dmwit> why me?
18:45:48 <CADD> i couldnt find*
18:46:12 <CADD> dmwit: because you helped me last time and you are one of the maintainers, you dont need to. sorry
18:46:20 <dmwit> Well. The answer to your direct question is "nope, sorry".
18:46:27 <CADD> if you are busy i undestand
18:46:27 <dmwit> I'm one of the maintainers?
18:46:31 <dmwit> wtf
18:46:35 <startling> haha
18:46:42 <CADD> dmwit: ok, maybe im confusing people
18:46:44 <acowley> dmwit: you are now
18:46:45 <CADD> dmwit: sorry
18:46:46 <hpc> dmwit: #haskell just reinstituted the draft
18:46:51 <hpc> you are now a maintainer
18:46:54 <hpc> i do xmonad
18:46:55 <benzrf> id be happy to be a maintainer!
18:46:57 <hpc> Cale gets all of acme
18:46:59 <benzrf> i barely know haskell tho
18:47:03 <acowley> It's like how hpc took over the haskell platform earlier
18:47:10 <dmwit> i'm dying
18:47:19 <hpc> protontorpedo can have that one package that's a hardcoded list of 1000 primes
18:47:38 <dmwit> CADD: It's not that I'm busy. I just don't know anything.
18:47:52 <CADD> dmwit: dont we all. :D
18:47:54 <startling> haskell platform czar?
18:47:58 <hpc> acowley: i didn't take it over, i am just one of the included packages
18:48:16 <dmwit> hpc: Wait, are you telling me you took yourself over?
18:48:24 <CADD> dmwit: my bad, i wont assume next time. :)
18:48:31 <CADD> aaaaanyway
18:48:42 <acowley> Yeah, you have to email Ross if you want to take yourself over
18:49:29 <CADD> i have been struggling setting up lambdabot with ssl and a channel password, any help out there?
18:49:30 <hpc> dmwit: i hereby claim this hpc in the name of hpc
18:49:39 <hpc> hpc is dead, long live hpc
18:49:43 <dmwit> =D
18:49:54 <hpc> no, i am hpc
18:50:21 <CADD> no, i am hpc
18:50:22 <peddie> CADD: for using lambdabot with SSL, I think I read a suggestion somewhere to use the program 'stunnel', and it works for me
18:50:26 <hpc> nya, hpc, see?
18:50:49 <CADD> peddie: i tried something like that. i have ssltunnel working, but i might have it configured wrong
18:50:57 <CADD> hpc: :D
18:51:16 <peddie> http://code.haskell.org/lambdabot/README contains an stunnel.conf file
18:52:03 <CADD> peddie: yeah, that is exactly what i did. i guess now my stumblig block is the channel password
18:52:30 <peddie> CADD: sorry, that's all I've got . . . you might have to dive into the code at this point
18:52:41 <CADD> peddie: thanks!
18:55:01 <benzrf> how do I get command line args?
18:55:43 <koala_man> @hoogle IO [String]
18:55:44 <lambdabot> System.Environment getArgs :: IO [String]
18:55:44 <lambdabot> System.Posix.Env getEnvironmentPrim :: IO [String]
18:55:44 <lambdabot> GHC.Environment getFullArgs :: IO [String]
18:55:54 <benzrf> :|
18:56:12 <benzrf> fullargs vs ??
18:56:18 <benzrf> > getFullArgs
18:56:20 <lambdabot>   Not in scope: `getFullArgs'
18:56:21 <benzrf> wait derp
18:56:31 <peddie> benzrf: I think you want System.Environment.getArgs
18:56:46 <benzrf> ok
18:56:48 <benzrf> thanks
18:56:50 <benzrf> :)
18:57:03 <dmwit> The documentation for GHC.* is abysmal.
18:57:08 <benzrf> huh
18:57:31 <dmwit> benzrf: You may also be interested in getProgName, if you're expecting Unix-style args.
18:57:46 <benzrf> thank you!
18:57:48 <CADD> peddie: oh excellent there is a logging flag in lambdabot: -l
18:57:50 <dmwit> Don't try to think about what this does on Windows.
18:58:46 <CADD> dmwit: lol
18:58:51 <benzrf> dmwit: I try to make not thinking about windows a general policy
18:59:39 <peddie> CADD: oh, neat; thanks
19:00:18 <CADD> peddie: sadly it doesnt help much on this problem..
19:01:01 <peddie> CADD: I'd probably check to see whether the code that speaks IRC even knows about keyed channels
19:01:27 <CADD> peddie: i heard you can with something like: rc passwd.rc
19:01:36 <peddie> oh, well then
19:01:41 * peddie shrugs
19:01:44 <CADD> peddie: but i havent found the syntax that would go into the passwd.rc file
19:02:00 <peddie> well, the -l might help with that part if you take a stab at it
19:02:25 <CADD> peddie: i guess i just need to find the function that gets called after it parses the rc command
19:02:38 <peddie> CADD: good luck
19:02:42 <CADD> peddie: ty :D
19:08:33 <CADD> peddie: beautiful, i think this might have solved it(in case you are interested): http://ircbrowse.net/browse/haskell?events_page=359179
19:08:50 <peddie> yes, actually
19:09:18 <peddie> CADD: I see, so the username is registered and that lets it join the private channel
19:12:49 <CADD> peddie: hmm, well now it says im sending a message to a bogus server...
19:13:23 <CADD> peddie: no, i dont think the username has to be registered, just a channel password.
19:13:41 <CADD> peddie: hmm, i think i might be able to change out nickserv for chanserv and that might do something.
19:13:58 <dmwit> nickserv and chanserv do very different things...
19:14:28 <peddie> CADD: it looks like you're just sending a message in that rc line, so maybe you can just do what you'd do in your client and use join freenode:<channel> <key> or something?
19:14:50 <CADD> dwcook: yes of course. the channel does not require a registered nick. just a password to enter the channel
19:15:08 <CADD> peddie: oh that makes so much more sense
19:15:14 <CADD> peddie: ill give that a try
19:15:56 <lpaste> tomejaguar pasted “Weird instance constraint” at http://lpaste.net/95928
19:16:09 <tomejaguar> ^^ Here's an odd question.  Can I do something like this somehow?
19:17:38 <dmwit> no
19:17:40 <dmwit> (sorry)
19:17:44 <tomejaguar> Argh
19:18:21 <dmwit> You could write
19:18:29 <tomejaguar> 'Wrap m f' is a Functor, but to give the instance I need 'f (Wrap m f)' to be a functor.  So I want to say that 'f r is a Functor whenever r is a Functor'.
19:18:33 <Twey> tomejaguar: What's wrong with just Functor r, Functor (f r)?
19:18:39 <dmwit> instance (Functor m, Functor (f (Wrap m f))) => Functor (Wrap m f) where -- though
19:18:47 <tomejaguar> Twey: f r is only a functor if r is.
19:19:01 <geekosaur> that is what Twey sai
19:19:02 <Twey> Oh, sorry, it's an instance not a class
19:19:03 <geekosaur> that is what Twey said
19:19:23 <Twey> Er, but yes, they're equivalent
19:20:02 <dmwit> Twey/geekosaur: I don't get it.
19:20:08 <Twey> tomejaguar: You need both r and (f r) to be a Functor; you don't really care how it got to be that way
19:20:14 <dmwit> no
19:20:18 <dmwit> r doesn't appear in the instance head
19:20:32 <dmwit> He wants (forall r. Functor (f r)) which you definitely can't do today.
19:20:45 <Twey> Ah, right
19:20:49 <dmwit> (forall r. Functor r => Functor (f r))
19:20:50 <tomejaguar> I think I want (forall r. Functor r => Functor (f r))
19:20:53 <dmwit> yes
19:21:05 <tomejaguar> dmwit: Now I have undecidable instances.  Should I be concerned?
19:21:10 <geekosaur> yeh, that makes it harder
19:21:16 <dmwit> tomejaguar: I dunno. Try it.
19:21:24 <dmwit> tomejaguar: If it halts, you don't need to be concerned.
19:21:27 <Twey> Heh
19:21:33 <tomejaguar> OK, it halted :)
19:21:44 <dmwit> \o/
19:22:10 <tomejaguar> I haven't used any instances yet ...
19:22:22 <tomejaguar> But at least it compiles.  Thanks.
19:23:08 <dmwit> The runtime behavior doesn't depend on whether it type-checks or not.
19:23:27 <dmwit> Actually, scratch that.
19:23:37 <simpson> Damn you, DMR!
19:23:47 <dmwit> In any case, I stand by "If it halts, you don't need to be concerned." where here "it" is "the compiler".
19:24:15 <tomejaguar> OK
19:27:57 <heath> will Haskell receive extensible kinds anytime soon?
19:28:50 <dmwit> What are extensible kinds?
19:36:19 <dmwit> Well, I'm not going to stick around to hear the answer, so I can't say. You might like the DataKinds extension available in GHC... then again you might not.
19:45:28 <heath> in introductory material, do you think that overwhelming the person with terminology is the way to go?
19:47:50 <OffsetGoose> Does anyone know of any good encryption libraries in Haskell?
19:47:50 <dmwit> Now there's a leading question if I ever heard one.
19:48:18 <dmwit> http://hackage.haskell.org/packages/search?terms=crypto
19:48:24 <dmwit> Though I have no idea which ones are "good".
19:48:38 <OffsetGoose> I need my program to function similar to how PGP does.
19:48:47 <OffsetGoose> Or at least a part of it.
19:48:51 <sellout-> I think the NSA has recommendations somewhere ;)
19:49:58 <dmwit> If that's your attitude, use twofish. Rejected as a standard because the government couldn't find a backdoor for it... or so they say. ;-)
19:50:14 <dmwit> geekosaur: videocall is doing the malasi thing now
19:50:20 <OffsetGoose> I'm not the best at cryptography, but if there's an easy function that I could write that takes a public key and text and encrypts it, I'll leave, but I'm pretty sure it's more complicated than that?  ChibaCity: :)
19:50:25 --- mode: ChanServ set +o geekosaur
19:50:42 --- mode: geekosaur set +b *!*ircap@*.Red-2-138-167.dynamicIP.rima-tde.net
19:50:42 --- kick: videocall was kicked by geekosaur (videocall)
19:50:47 <dmwit> thanks
19:50:48 --- mode: geekosaur set -o geekosaur
19:53:45 <OffsetGoose> Thanks for the link, dmwit.
20:13:43 <chrisblake> can somebody help me with this three line function: http://lpaste.net/95929
20:14:14 <khyperia> what is "IsString"?
20:14:34 <chrisblake> from Data.String; I want the function to work on both Text and String (or any other instance of IsString)
20:14:51 <chrisblake> but I realize that isDigit might only work on Strings, and not IsStrings...
20:14:53 <dmwit> Not all instances of IsString are String.
20:15:07 <dmwit> isDigit and read are both problematic here.
20:15:39 <chrisblake> I know String -> Maybe Int will work, but there's no way to make the function in such a way it works on both Strings, Texts (and maybe other IsStrings?)
20:15:43 <dmwit> IsString has a "fromString"-like method; perhaps you'd like to create a class with a "toString"-like method and instantiate it for String, Text, and ByteString.
20:15:48 <geekosaur> :t read
20:15:52 <lambdabot> Read a => String -> a
20:15:56 <arkeet> :t fromString
20:15:57 <lambdabot>     Not in scope: `fromString'
20:15:57 <lambdabot>     Perhaps you meant one of these:
20:15:57 <lambdabot>       `BSLC.fromStrict' (imported from Data.ByteString.Lazy.Char8),
20:16:23 <dmwit> fromString :: IsString a => String -> a
20:16:33 <geekosaur> note that it is Read a => String -> a, not (Read a, IsString s) => s -> a
20:17:02 <chrisblake> hrm, well I don't *need* the functionality for all IsStrings.
20:17:15 <chrisblake> can I get that function polymorphic on both Strings and Texts, at minimum?
20:17:33 <dmwit> Yes. I told you how.
20:18:02 <chrisblake> is it currently possible without creating another typeclass, though?
20:18:17 <dmwit> No. Why do you want to avoid creating a type class?
20:18:36 <chrisblake> well because I'm trying to write as little code as needed; I don't mind writing it; I was just curious.
20:18:50 <chrisblake> *curious to see if there was a typeclass that already included Strings and Texts
20:19:23 <dmwit> There probably ought to be.
20:19:40 <chrisblake> yeah, I thought so too.
20:19:47 <chrisblake> but if that's not IsString, then what is it?
20:20:17 <arkeet> type classes are just data types that the compiler can infer values for.
20:22:34 <dmwit> Someday I want to write a blog post about using Default as the One True Typeclass.
20:23:31 <arkeet> except that package got split up and now it's an exploded mess :(
20:23:41 <dmwit> irrelevant
20:24:49 <arkeet> at the very least, data-default-class and -base and -containers should be in the same package.
20:25:07 <dmwit> Problem: there are many possible Monoid's for Maybe. Solution: data Monoid a = Monoid { mempty :: a, mappend :: a -> a -> a }; instanceA :: Monoid (Maybe a); instanceB :: Monoid (Maybe a); instance Default (Monoid (Maybe a)) where def = instanceA
20:26:00 <dmwit> Problem: now my code has "def" everywhere. Solution: yeah, that's why type classes are so much more awesome than data.
20:28:01 <chrisblake> is there a liftToText :: (String -> a) -> (Text -> a) function?
20:28:01 <dwcook> dmwit, that looks like something automatable with TH - a corresponding type for a given class
20:28:28 <dmwit> err?
20:28:32 <arkeet> the type already exists - see the constraints package
20:28:49 <dwcook> I mean that that's something you might potentially want for any typeclass
20:28:52 <dmwit> chrisblake: (unpack .)?
20:29:11 <dwcook> and that it's something that you could do just by examining the typeclass declaration
20:29:17 <arkeet> data Dict c where Dict :: c => Dict c
20:29:20 <dmwit> chrisblake: err, I mean (. unpack), of course.
20:29:36 <dwcook> Oh, the "err?" wasn't directed at me, I guess
20:29:51 <dmwit> arkeet: How does that let you create a custom dictionary?
20:29:52 <chrisblake> dmwit: heh, well that works well :)
20:30:00 <dmwit> dwcook: it was
20:30:17 <arkeet> dmwit: reflection, I suspect.
20:30:25 <dmwit> dwcook: And I agree, it's a totally mechanical translation.
20:30:32 <dmwit> dwcook: In fact, it's one the compiler already does.
20:30:41 <dwcook> But doesn't expose, no?
20:30:47 <dmwit> That's the point, yes.
20:30:51 <arkeet> or:
20:31:06 <arkeet> make a newtype, write your instance for that newtype, and then unsafeCoerce the Dict
20:31:43 <dmwit> I'm pretty sure I don't trust that way of doing things.
20:31:46 <dmwit> Suppose I do that.
20:32:34 <dmwit> Now I write "foo :: Monoid Bool => Dict (Monoid Bool) -> Bool -> Bool -> Bool; foo Dict = mappend".
20:32:42 <dmwit> Which mappend is it using?
20:32:46 <arkeet> good question!
20:32:59 <arkeet> don't write that.
20:33:01 <dmwit> I don't believe Dict gives the control that my solution does.
20:33:20 <arkeet> just write foo :: Dict (Monoid Bool) -> Bool -> Bool -> Bool
20:33:36 <dmwit> arkeet: The way I wrote the type signature is immaterial.
20:33:46 <arkeet> huh?
20:33:47 <dmwit> If there's a Monoid Bool instance floating around, it's floating around whether I put it in the signature or not.
20:33:56 <arkeet> sure. but that doesn't affect foo.
20:34:01 <arkeet> with my type.
20:34:02 <dmwit> How do you know?
20:34:07 <arkeet> because there's no Monoid Bool constraint.
20:34:10 <dmwit> So?
20:34:14 <arkeet> so foo has no way of taking a dictionary for one.
20:34:18 <arkeet> except explicitly.
20:34:20 <dmwit> There is one as soon as you write "mappend" on the other side of the equation.
20:34:29 <dmwit> arkeet: No, that's not true.
20:34:34 <arkeet> and the only one mappend can use is the one brought into scope by pattern matching on Dict.
20:34:48 <dmwit> arkeet: If I write "foo :: Bool -> Bool -> Bool; foo = mappend" today, it will pick a Monoid Bool instance out of thin air when one exists.
20:34:56 <dmwit> I don't have to put it into scope by mentioning it in the type.
20:35:03 <arkeet> well, fine.
20:35:09 <arkeet> then:
20:35:11 <arkeet> <arkeet> good question!
20:35:14 <dwcook> An instance can be used implicitly by picking a concrete type
20:35:35 <dmwit> arkeet: Right. So I don't agree that Dict has feature parity with Monoid. =)
20:35:46 <arkeet> my guess is that it will use the one from the Dict.
20:35:54 <arkeet> but I have nothing to support that, really.
20:35:57 <dmwit> My guess is that half a dozen things will affect it.
20:36:19 <dmwit> File load order, optimization level, interface files, phase of the moon, etc.
20:38:26 <arkeet> have you seen the monoid example in reflection?
20:38:48 <dmwit> No, I haven't really looked at reflection long enough to grok it.
20:38:57 <arkeet> https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
20:39:56 <arkeet> not necessarily convenient, I suppose.
20:41:02 <dmwit> No Dict in sight. =)
20:41:08 <arkeet> yes, it's a different thing.
20:41:15 <dmwit> But very neat. Thanks for bringing it to my attention.
20:42:44 <arkeet> reflection itself uses the idea that you can unsafeCoerce dictionaries around.
20:43:45 <arkeet> specifically, a dictionary for Reifies s a.
20:43:57 <arkeet> or something.
20:44:01 <arkeet> which is precisely a value of a.
21:11:10 <mirpa> Is there some fundamental difference between 'do a <- getA; b <- getB; return foo { fooA = a, fooB = b }' and 'foo <$> getA <*> getB'?
21:11:48 <mirpa> I mean s/foo/Foo/
21:12:06 <dmwit> no
21:12:30 <geekosaur> nope. there's even a monadic version of the second one although it's a bit less convenient
21:12:31 <dmwit> There are several superficial differences and at least one operational one.
21:13:01 <geekosaur> (which however has the same operational difference)
21:13:22 <dmwit> superficial: the former does not rely on fooA being the first argument to Foo and fooB being the second
21:13:35 <mirpa> I am writing binary parser with Cereal and second version is much shorter.
21:13:36 <dmwit> operational: (>>=) can be asymptotically slower than (<*>) in some cases
21:14:17 <mirpa> ok, thx
21:45:52 <gamerman315> so I had a question if anyone might be able to answer it. I am trying to compile gitit using cabal on windows and I am having trouble making it a relocatable exe or rather prefix-independent.
21:47:26 <gamerman315> I have attempted doing this by running the command: cabal install gitit --prefix=... --datadir=$prefix\data --libdir=$prefix\lib --libexecdir=$prefix\libexec --bindir=$prefix\bin
21:48:09 <gamerman315> the resulting gitit is installed to the $prefix location but when i move that directory to a different location it crashes because it cannot find the data files it needs
21:48:35 <gamerman315> any ideas on how I might be able to go about doing this?
21:51:07 <gamerman315> is there anyone else here that isn't a bot?
21:51:18 <gamerman315> awful quiet
21:53:09 <simpson> gamerman315: Happens.
21:53:31 <gamerman315> lol at least I know I am not alone now
21:55:06 * geekosaur is barely here (damn laundry...)
21:55:43 <gamerman315> you think anyone here has had experience trying to create prefix-independent windows exes using cabal?
22:06:31 <mirpa> gamerman315: I don't know, but try cabal-dev or cabal version >=1.18 with sandbox
22:09:32 <gamerman315> not familiar with what cabal-dev is. I am using cabal 1.18.1.2 and i just tried doing it the sandbox route without success
22:10:44 <mirpa> cabal-dev is predecessor of cabal sandbox
22:12:05 <gamerman315> was justt looking it up, alight will give it a shot thanks for the tip
22:14:52 * hackagebot ghc-mod 3.1.4 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.1.4 (KazuYamamoto)
22:17:56 <mirpa> gamerman315: check this http://stackoverflow.com/questions/19007105/portable-package-installation-on-haskell-platform-with-cabal-on-windows
22:22:00 <dmwit> cabal-dev isn't really related
22:22:10 <dmwit> What you want to read about is cabal's Paths mechanism.
22:22:16 <dmwit> Let me find the section in the manual for you.
22:22:59 <dmwit> http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
22:23:02 <dmwit> gamerman315: ^
22:23:13 <gamerman315> building with cabal-dev right now, just saw you posted these other two links
22:23:22 <gamerman315> will look through them real quick
22:24:06 <dmwit> wait
22:24:11 <dmwit> even that isn't prefix independence =(
22:25:38 <dmwit> Here we go. http://www.haskell.org/cabal/users-guide/installing-packages.html#prefix-independence
22:25:54 <dmwit> Luckily for me, I had answered this question on StackOverflow with that link. =)
22:26:00 <dmwit> http://stackoverflow.com/q/12361594/791604
22:27:02 <gamerman315> so the haskell doc is what i have been going off of
22:27:25 <gamerman315> from my understanding when i do the build i just need to specify the other variables in relation to $prefix
22:27:43 <gamerman315> when I attempt that, it does install all the files to the correct location
22:27:50 <dmwit> There's more. You have to write your code in a way that supports relocation.
22:28:12 <gamerman315> but as soon as i move the built folder it crashes
22:28:44 <gamerman315> so the program i am trying to build is called gitit, and to get their data directory that use that getDataFileName function
22:28:52 <gamerman315> which i believe is what this is saying
22:29:10 <gamerman315> still seems to have issues though but I can review their code further
22:29:44 <gamerman315> for reference http://en.wikipedia.org/wiki/Gitit_%28software%29
22:29:46 <dmwit> Okay. It would help a lot if you could cook up a small (less than, say, 50 lines) code sample that exhibits the problem.
22:30:36 <gamerman315> you can see here in their code repo https://github.com/jgm/gitit/blob/master/gitit.hs they use the getDataFileName to access data files
22:31:11 <dmwit> Perhaps not every time. =)
22:31:15 <gamerman315> this is true
22:31:30 <gamerman315> i may have to dig down further to see if they have anything hard coded
22:40:26 <gamerman315> I suppose worst case scenario I can always write a batch file wrapper that detects the location of the exe and sets environment variables up around it, just seems like i am missing something with this prefix independence setup
22:41:10 <dmwit> Probably it's just a bug, not you missing something.
22:41:56 <jfeltz> i have a difficult to test-case problem of using forkIO, within the body of a passed Request -> IO Response, where after handling the first response, the function no longer seems to receive any "request" (i can't print anything),but the client still gets responses back for requests on its end, so I don't know whether to attribute the problem to how i'm using http-server, or to my use of forkIO
22:42:02 <gamerman315> yeah thats what I was thinking but I am fairly new to the whole haskell thing so I wasnt sure
22:42:36 <spaceships> requesting a witty one-liner using (.).(.) or (.).(.).(.) ...
22:45:36 <dmwit> spaceships: Maybe look through the logs a bit with that tool chrisdone made?
22:45:57 <spaceships> dmwit: thanks
22:45:59 <dmwit> or grep if you have extensive personal logs
22:47:01 <lightquake> so, for certain do-blocks, it turns out that you don't actually need Monad to implement them, you just need some weaker type class. for example, do { m <- x; return (f m) } only requires Functor (because it's just fmap f m)
22:47:32 <lightquake> is there a useful characterization of which types of do-blocks only require Applicative?
22:47:56 <johnw> are you aware of the applicative do proposal?
22:48:06 <dmwit> yes, ones which do not inspect the values produced by earlier computations
22:48:20 <dmwit> e.g. ones which don't use case
22:48:47 <dmwit> Or, another way to say it: if you know what side effects are going to happen statically, you can almost certainly do it with Applicative rather than Monad.
22:49:18 <lightquake> dmwit: it's more general than that, though; do {x <- a; y <- f x; g y} still requires Monad, doesn't it?
22:49:36 <dmwit> However, note that the transformation you proposed is only valid under the assumption that all the usual laws are satisfied, which is one of the objections raised every time there's a proposal to do such a thing.
22:49:44 <lightquake> well, yes
22:49:45 <dmwit> lightquake: Yes, because f and g might use case. =)
22:50:17 <lightquake> dmwit: as opposed to being const?
22:50:31 <lightquake> or id, i guess
22:50:39 <dmwit> id is not okay, either
22:50:40 <lightquake> (well, return/pure)
22:50:55 <dmwit> So I will admit that this is a hole in the "doesn't use case" rule.
22:51:43 <lightquake> anyway, yes, it does assume the monad laws
22:52:04 <lightquake> and the applicative laws, etc.
22:52:20 <dmwit> right
22:52:30 <dmwit> It's not *so* worrying, just something to keep in the back of your head.
22:52:58 <dmwit> But you should make johnw link you to the mailing list message about applicative do. ;-)
