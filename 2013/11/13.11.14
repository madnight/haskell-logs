00:00:04 <adnap> Heh. There was this all along: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
00:05:22 <sopvop> in Data.Foldable foldlM uses foldr underneath. So it's not the same as Control.Monad.foldM, right?
00:06:55 <frx> ah, so the problem is not that (+) isn't strict (it is), but that the result in foldl is not used until the end?
00:07:12 <frx> because it is not needed until the end
00:17:15 <staley> can yesod or snap generate static web pages?  if not can some other library?
00:18:17 <mightybyte> staley: Not that I know of.  Check out hakyll.
00:18:41 <mightybyte> staley: You could use heist to generate static markup from templates though.
00:27:14 <staley> thanks!
01:23:04 <monade> pl \x y -> x y
01:24:48 <monade> @pl \x y -> x y
01:24:48 <lambdabot> id
01:25:33 <monade> @pl \acc l _ -> gcd acc l
01:25:33 <lambdabot> (const .) . gcd
01:33:06 <staley> but that isn't equal to id
01:33:46 <staley> @pl \x y -> x y
01:33:46 <lambdabot> id
01:34:06 <staley> > id 4
01:34:11 <staley> > (\x y -> x y) 4
01:34:12 <lambdabot>   4
01:34:12 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
01:34:13 <lambdabot>    arising from a use ...
01:34:49 <apo_> it is for valid inputs :P
01:34:56 <staley> true :)
01:35:43 <FreeFull> id is a superset of (\x y -> x y)
01:36:12 <FreeFull> So you can replace (\x y -> x y) with id but not vice versa
01:39:54 <arkeet> :t undefined `asAppliedTo` \x y -> x y
01:39:57 <lambdabot> ((t1 -> t) -> t1 -> t) -> b
01:40:22 <arkeet> er
01:40:26 <arkeet> :t undefined `asTypeIn` \x y -> x y
01:40:27 <lambdabot> t1 -> t
01:40:56 <FreeFull> :t asTypeIn
01:40:57 <lambdabot> a -> (a -> b) -> a
01:41:11 <arkeet> > id (undefined :: a -> b) `seq` ()
01:41:12 <lambdabot>   *Exception: Prelude.undefined
01:41:14 <FreeFull> Another const ith specialised type
01:41:15 <arkeet> > (\x y -> x y) (undefined :: a -> b) `seq` ()
01:41:16 <lambdabot>   ()
01:41:21 <arkeet> it's still not id ;)
01:41:28 <arkeet> even when used at the same type
01:41:55 <FreeFull> Oh, I didn't think of it having different strictness
01:42:30 <FreeFull> Or rather, interacting with seq in that way
01:43:03 <FreeFull> > (id :: (a -> b) -> a -> b) (undefined :: a -> b) `seq` ()
01:43:04 <lambdabot>   *Exception: Prelude.undefined
01:43:19 <FreeFull> Yeah, it is different
01:43:27 <frx> "In particular, the expression x `seq` x is completely redundant" <- I don't get this. why is it redundant, instead of forcing evaluation of x?
01:43:44 <frx> should have pasted the whole thing.. "In particular, the expression x `seq` x is completely redundant, and always has exactly the same effect as just writing x."
01:43:47 <FreeFull> frx: seq doesn't force evaluation, but rather binds it
01:44:07 <FreeFull> It says "When you evaluate the right side, evaluate the left side too"
01:44:35 <frx> ah I see
01:44:59 <arkeet> x `seq` x means
01:45:04 <arkeet> when you evaluate x `seq` x, evaluate x.
01:45:13 <arkeet> (to whnf)
01:46:29 <frx> so the use is usually (always?) x on left side, and function taking x on right?
01:47:02 <tero-> milestone "ghc 7.8.1" due in 11 days and ghcjs' first official released planned to coincide with the release of ghc 7.8.1
01:47:48 <tero-> is it wishful thinking to expect that both will be out in two weeks?
01:48:13 <frx> is x evaluated before f is called? x `seq` f x
01:49:45 <arkeet> well, actually seq doesn't really guarantee that the left side is evaluated before the right side.
01:50:05 <arkeet> it's just that if x is bottom then x `seq` y is bottom.
01:50:07 <arkeet> otherwise it's y.
01:50:27 <FreeFull> Operationally people do use it as if it did though
01:52:26 <FreeFull> You can use unsafePerformIO to observe that GHC will evaluate the left side before the right side
01:52:36 <arkeet> use pseq if you want to guarantee evaluation order.
01:53:51 <staley> @src foldr'
01:53:51 <lambdabot> Source not found. My pet ferret can type better than you!
01:54:13 <staley> @src foldl'
01:54:13 <lambdabot> foldl' f a []     = a
01:54:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
01:54:13 <FreeFull> I don't think there is a use for a strict foldr
01:55:07 <staley> how can foldl' get away with using seq over pseq then if seq does not guarantee evaluation?
01:58:58 <staley> as far as I understood foldl' could recurse before a' is evaluated, rendering seq useless
02:00:18 <mm_freak_> malorie: reactive-banana does not handle time
02:04:39 * mangaba_leitosa does not even know what arrows are, but is already needing them in his program :-O  lambdabot said that '\(a, b) -> (a, f b)' is beter written as 'second f' :-)
02:05:17 <FreeFull> mangaba_leitosa: You could use lenses instead =P
02:05:55 <mangaba_leitosa> FreeFull: I only know how to use lenses for record fields so far :-)
02:06:19 <fizruk> mangaba_leitosa, second is mapSnd for (->) arrow
02:06:46 <mangaba_leitosa> fizruk: ok :-)
02:06:47 <FreeFull> > (3,4) & _2 %~ show
02:06:49 <lambdabot>   (3,"4")
02:07:25 <fizruk> mangaba_leitosa, i find arrow combinators useful for (->), but i don't need to know what arrows are
02:08:07 <mangaba_leitosa> FreeFull: thanks :-)
02:08:22 <FreeFull> I don't remember what the non-operator name for %~ is
02:08:30 <FreeFull> Oh, it's over
02:08:38 <FreeFull> > over _2 show (3,4)
02:08:40 <lambdabot>   (3,"4")
02:08:42 <mangaba_leitosa> fizruk: so I'm now using second and don't know about arrows either :-)
02:09:01 <FreeFull> over seems to use profunctors
02:09:22 <fizruk> mangaba_leitosa, I do know about arrows, just don't use that knowledge :p
02:09:28 <mangaba_leitosa> fizruk: ok :-)
02:10:32 <volko> hrm, I have a clckwrks project that depends on an external theme library. I built the theme with cabal build, but how do I point the clckwrks project build to the theme?
02:10:40 <volko> I keep getting missing dependency errors
02:10:52 <volko> I've tried using --extra-lib-dirs
02:11:01 <volko> cabal configure --extra-lib-dirs=../clckwrks-theme-rjsantiques/dist/build
02:11:45 <fizruk> volko, Build-Depends in clckwrks.cabal file ?
02:12:05 <volko> contains                        clckwrks-theme-rjsantiques == 0.2.*,
02:12:45 <volko> Does that just check installed cabal packages?
02:13:01 <mm_freak_> mangaba_leitosa: don't worry, you're not using arrows
02:13:14 <mm_freak_> you're using the function arrow, which is quite straightforward =)
02:14:28 <mangaba_leitosa> mm_freak_: ah. so it's not about arrows? :-)
02:14:44 <fizruk> volko, it uses "cabal install"ed packages, so you should either cabal install that or use sandboxes (if I got you right)
02:15:10 <mm_freak_> mangaba_leitosa: to learn arrows, you really need to use a nontrivial arrow =)
02:15:13 <staley> can someone clarify? should foldl' be written with pseq since seq doesn't guarantee evaluation order?
02:15:14 <volko> yea, and the theme import from the clckwrks package is using a package name based import
02:15:18 <volko> good to know there are cabal sandboxes though
02:15:19 <mm_freak_> mangaba_leitosa: (->) is to arrows what Identity is to monads
02:15:20 <volko> thanks
02:16:12 <mangaba_leitosa> I see
02:26:54 <skypers_> donri: hi!
02:27:32 <donri> ohai
02:27:49 <vijaykiran> I can't see my previous question in the logs - but here we go again - What is a "Constraint" in Num :: * -> Constraint ?
02:27:56 <skypers_> I was able to fix my package thank to your advise from yesterday
02:28:07 <skypers_> I'm uploading it right now
02:28:18 <donri> yay!
02:28:53 <donri> vijaykiran: it's the kind for constraints :) ie. the stuff before the fat arrow => in a type signature
02:29:28 <vijaykiran> donri: 42 is a value, Num is a type, * is a kind
02:29:39 <vijaykiran> donri: ah, so Constraint is a kind
02:29:43 <donri> vijaykiran: constraints include type classes like (Num a), equality constraints like (a ~ Char) and tuples of constraints like (Num a, Show a)
02:30:54 <donri> the Constraint kind is only visible with ConstraintKinds, though (but i think ghc always calls them Constraint though so it's also visible in ghci's :kind)
02:31:03 * hackagebot FModExRaw 0.1.0.2 - The Haskell FModEx raw API.  http://hackage.haskell.org/package/FModExRaw-0.1.0.2 (DimitriSabadie)
02:31:19 <skypers_> \m/
02:31:25 <donri> \o/
02:31:49 <vijaykiran> donri: ok, thanks!
02:32:02 <skypers_> I should write CHANGELOG
02:32:06 <skypers_> it might be cool
02:32:24 <donri> skypers_: it's not that cool on hackage yet. just links the plain text file
02:32:33 <donri> make sure to list it in extra-source-files btw
02:32:38 <skypers_> ok
02:32:54 <skypers_> well, it'll be prettier very soon I guess
02:33:08 <skypers_> things evolve quickly in Haskell!
02:33:45 <donri> well the plan involves changes to Cabal, so might take a few months assuming it's even done next release :p
02:33:51 <staley> this bothers me, so sorry if i am boring.. :). but for all practical, when programming in ghc, i can assume that seq evaluates first argument before evaluating second??
02:34:07 <staley> all practical purposes*
02:35:02 <donri> staley: to WHNF, yes
02:35:51 <donri> staley: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html
02:37:33 <staley> why didn't haskell 98 spec guarantee evaluation order, since that seems to be the only reason seq exists?
02:38:18 <skypers_> what is the flag to discard the Defined but not used warning?
02:38:26 <skypers_> when writing a lib it's so annoying
02:38:53 <donri> staley: evaluation order isn't important to pure code, other than bottom. it's primarily used for optimization, or impure code
02:39:10 <donri> skypers_: you shouldn't get that in a lib
02:39:19 <skypers_> I do
02:39:19 <volko> if I leave the directory containing .cabal.sandbox, I also leave the sandbox?
02:39:25 <skypers_> with -Wll
02:39:30 <volko> er, .cabal-sandbox
02:39:37 <skypers_> yes volko
02:39:43 <donri> skypers_: well then you have something that is defined but neither used internally or exported publicly
02:39:45 <staley> donri how isn't it important? if seq evaluates second argument first then foldl' is broken
02:40:05 <skypers_> donri: well, it's a record syntax function In don't actually use
02:40:10 <volko> cool, that's how virtualenv should be
02:40:11 <skypers_> it has a garbage name
02:40:11 <volko> but python is weird
02:40:15 <skypers_> like foo
02:40:19 <donri> staley: but the result is the same (ignoring bottom and stack overflows :p)
02:40:29 <staley> :|
02:40:33 <skypers_> but it has to be there donri because I have other important fields
02:42:33 <donri> skypers_: got an example? there are valid uses of this just like head can sometimes be known to be total but it's dangerous territory :) best avoided if possible
02:43:05 <skypers_> donri: nevermind, I'll refactor a little ;)
02:43:32 <donri> skypers_: anyway it's -fno-warn-missing-fields you're after, probably
02:44:06 <donri> skypers_: this isn't the same as "defined but not used" though
02:44:28 <donri> (that's -fno-warn-unused-binds)
02:44:41 <skypers_> ok, I have a new big issue. I need to "unify" some values which types differ from each other into one single type. The idea is to join all of them to put them in a Ptr () (C void* pointer). For instant I might want to put a (Int, Float, Bool) in a raw memory. I have some idea, like one big allocaArray bytes, and three pokeOff
02:44:48 <skypers_> any other idea?
02:44:51 <fizruk> is there a reason why Identity lacks Eq/Ord/etc. instances?
02:45:03 <fizruk> > Identity 2 == Identity 3
02:45:05 <lambdabot>   No instance for (GHC.Num.Num a0) arising from the literal `2'
02:45:05 <lambdabot>  The type var...
02:45:18 <fizruk> > Identity () == Identity ()
02:45:19 <lambdabot>   No instance for (GHC.Classes.Eq
02:45:19 <lambdabot>                     (Data.Functor.Identity....
02:45:50 <staley> do you prefer to use seq or BangPatterns?
02:46:01 <skypers_> BangPatterns for sure
02:46:33 <donri> i mostly work with strict datatypes instead
02:46:50 <staley> such as?
02:47:24 <donri> data Pair a b = Pair !a !b
02:48:30 <donri> but yeah, bang patterns are neat if you need 'em
02:48:41 <skypers_> does it really improve performance when no laziness is required?
02:48:43 <donri> you have more control with seq, which also means it's easier to screw up :)
02:49:13 <donri> skypers_: it really depends. strictness can hurt performance, too
02:49:29 <skypers_> oh?
02:49:54 <skypers_> so that means typical famous languages like C would be slower than lazy code?
02:50:08 <skypers_> do you have an example?
02:50:29 <donri> well it means a one-liner in haskell can sometimes achieve optimal complexity thanks to laziness
02:50:50 <skypers_> I see
02:51:01 <skypers_> I thought of memoization, actually
02:51:08 <donri> head [1..] is infinitely faster lazy than strict ;)
02:51:10 <staley> donri why do you prefer Pair !a !b over Pair a b?   I never seen anyone use that before
02:51:19 <skypers_> ahah :)
02:51:41 <staley> is it a common practice to prefer strict data types?
02:52:12 <donri> it's common practice among performance buffs :p
02:52:13 <arkeet> it helps to avoid building up thunks when you don't want to
02:52:33 <staley> seems to go against the spirit of haskell though
02:52:49 <donri> http://www.slideshare.net/tibbe/highperformance-haskell
02:54:58 <staley> actually I just fully comprehended seq earlier. only to find out that evaluation order is not guaranteed. and now I see people use strict data types, which I didn't know even exist. I am getting more and more bewildered
02:55:21 <donri> basically strict data types are like bang patterns on the constructor
02:55:33 <FreeFull> You can make a spine-strict data type
02:55:36 <donri> pair !a !b = Pair a b  -- but in Pair itself
02:55:46 <volko> arghh, I cannot get this module to import
02:55:57 <skypers_> ok I think I found somehting for my unified type
02:55:57 <FreeFull> Where the structure get evaluated fully but the data itself doesn't have to be
02:55:59 <donri> it also allows ghc to make optimizations like unboxing small strict fields
02:56:12 <skypers_> I just need a class that defines a function like
02:56:20 <volko> I am specifying the package to import from
02:56:26 <skypers_>   raw :: r -> Ptr ()
02:56:41 <volko> oh nevermind
02:56:45 <skypers_>   raw :: r -> IO Ptr ()
02:57:02 <skypers_> which module volko ?
02:57:57 <volko> sorry I got it after all
02:59:30 <ocharles> Where can I find instance Applicative f => Monoid (f ()) ?
02:59:41 <ocharles> Will settle for instance (Applicative f, Monoid a) => Monoid (f a)
02:59:55 <donri> ocharles: that's dangerous territory though
02:59:58 <ocharles> reducers has this as 'Ap'
03:00:07 <donri> it says everything of kind * -> * is a Monoid
03:00:16 <ocharles> donri: sure, so give me a newtype
03:00:19 <donri> sure
03:00:23 <ocharles> semantically, I want that, I don't literally want that :)
03:00:55 <staley> when performance is not an issue do you prefer lazy data types?
03:01:02 <skypers_> sure
03:01:06 <skypers_> don't you?
03:02:03 <donri> i prefer laziness for control and strictness for data, generally
03:02:47 <ocharles> I'll just use Ap from reducers I think
03:03:32 <ocharles> oh actually, I think it's Traversal I want
03:03:53 <donri> Traversable?
03:04:04 <ocharles> no, Traversal
03:04:08 <ocharles> http://hackage.haskell.org/package/reducers-3.10.1/docs/Data-Semigroup-Applicative.html
03:04:21 <ocharles> I've already written this code, I just don't like duplicating work :)
03:04:22 <donri> oic
03:04:29 <ocharles> so I'll take out my instance and use Ed's
03:04:34 <staley> skypers_ I didn't even know you could avoid laziness in data types until few minutes ago..
03:05:02 <skypers_> staley: you also have unboxed datatypes
03:06:16 <skypers_> @index Storable
03:06:16 <lambdabot> Foreign.Storable, Foreign
03:07:18 <pharaun> i need to sit down and play with unboxed data
03:07:27 <pharaun> been wanting to do some repa work on some images
03:09:30 <skypers_> oh
03:09:46 <skypers_> deriving won't work with polymorphic fields :(
03:10:09 <arkeet> standalone deriving can derive some things regular deriving can't, have you tried that?
03:10:30 <skypers_> arkeet: I don't know what standalone deriving is
03:10:39 <arkeet> er, look it up
03:10:53 <staley> when would you use unboxed data types?
03:11:20 <staley> C FFI?
03:11:21 <arkeet> http://www.haskell.org/haskellwiki/GHC/Stand-alone_deriving_declarations
03:11:41 <skypers_> :o
03:11:57 <skypers_> I always use instance Eq MyType where
03:12:07 <skypers_> deriving instance sounds grat
03:12:09 <arkeet> :)
03:12:12 <skypers_> great
03:12:23 <skypers_> so it's basically inferredM
03:12:26 <skypers_> ?*
03:12:26 <lambdabot> Maybe you meant: v @ ? .
03:12:46 <arkeet> ?
03:13:04 <sub0> does Haskell have loops?
03:13:06 <arkeet> e.g. I had to use standalone deriving for https://github.com/ekmett/bifunctors/blob/master/src/Data/Bifunctor/Join.hs
03:13:13 <arkeet> sub0: haskell has recursion.
03:13:24 <arkeet> you can implement loops with that.
03:13:48 <skypers_> have a first look in this monadic function sub0 :
03:13:52 <skypers_> :t forever
03:13:53 <lambdabot> Monad m => m a -> m b
03:14:01 <arkeet> @src forever
03:14:01 <lambdabot> Source not found. You untyped fool!
03:14:04 <arkeet> oh.
03:14:06 <staley> I doubt that will be helpful to someone asking that question..
03:14:11 <Iceland_jack> Exactly...
03:14:24 <skypers_> well, it's a loop :D
03:14:32 <Iceland_jack> If someone doesn't know whether Haskell has loops or not do people expect name-dropping “monadic functions” is going to help?
03:14:42 <skypers_> er
03:14:45 <skypers_> you're damn right
03:14:48 <skypers_> sorry
03:15:09 <Iceland_jack> sub0: You should check out Learn You a Haskell For Great Good
03:15:09 <Iceland_jack> @where lyah
03:15:09 <lambdabot> http://www.learnyouahaskell.com/
03:15:11 <arkeet> ^
03:15:30 <skypers_> btw, the type is surprising, why m b? I would have expected m ()
03:16:06 <sub0> I just started reading Real World Haskell
03:16:10 <arkeet> skypers_: that tells you that it will never actually produce a b.
03:16:11 <skypers_> since such a loop can't finish, we can't really bind its result to anythin
03:16:18 <arkeet> sub0: LYAH is a much better introduction.
03:16:34 <skypers_> I've learned Haskell with lyah
03:16:38 <skypers_> it's just neat
03:16:47 <skypers_> :)
03:17:04 <arkeet> RWH might be worth reading afterwards.
03:17:09 <sub0> ok LYAH it is then
03:17:09 <Iceland_jack> skypers_: It could be: m a → m ()!
03:17:21 <skypers_> Iceland_jack: yeah
03:17:23 <arkeet> Iceland_jack: logically it should be m a -> m Void
03:17:35 <skypers_> @src Void
03:17:36 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
03:17:37 <Iceland_jack> Well I'm not sure where I stand on the Void issue
03:18:03 <arkeet> there are arguments for m Void or m b
03:18:06 <arkeet> but I don't think there are any for m ()
03:18:19 <Iceland_jack> Indeed
03:18:22 <merijn> skypers_: "data Void"
03:18:31 <arkeet> skypers_: Void has no values.
03:18:34 <merijn> skypers_: (No constructors)
03:18:42 <arkeet> (as opposed to (), which has one value.)
03:18:47 <arkeet> (not counting bottom.)
03:18:52 <skypers_> ah
03:18:55 <skypers_> I see
03:18:56 <Iceland_jack> How does one count bottoms?
03:19:25 <donri> > length (replicate 10 undefined)
03:19:26 <lambdabot>   10
03:19:27 <skypers_> how is it even defined? GHC's internal?
03:19:33 <arkeet> it's defined by: data Void
03:19:42 <arkeet> @hackage void
03:19:42 <lambdabot> http://hackage.haskell.org/package/void
03:19:47 <fizruk> or data Void = Void Void
03:19:55 <arkeet> fizruk: no, that has some values.
03:19:58 <arkeet> like fix Void
03:19:59 <skypers_> yeah
03:20:01 <skypers_> but hm
03:20:04 <arkeet> newtype Void = Void Void is closer.
03:20:05 <skypers_> data Void
03:20:07 <skypers_> it has a ctor
03:20:13 <arkeet> skypers_: no, it doesn't. ;)
03:20:18 <fizruk> arkeet, isn't that bottom?
03:20:19 <skypers_> with the EmptyCtorDecl extension
03:20:24 <fizruk> arkeet, oh yeah
03:20:32 <arkeet> skypers_: huh?
03:20:47 <skypers_> EmptyData
03:20:49 <skypers_> EmptyDataDecl
03:20:52 <skypers_> sorry
03:20:52 <arkeet> EmptyDataDecls yeah.
03:20:57 <arkeet> is on by default these days.
03:21:02 <skypers_> ah
03:21:04 <skypers_> ok :)
03:21:11 <arkeet> Void  ~  forall a. a
03:21:24 <skypers_> tilde?
03:21:35 <arkeet> that's informal.
03:21:41 <arkeet> I'm just saying those two types are isomorphic.
03:21:43 <skypers_> ok
03:22:30 <Iceland_jack> ≅
03:22:35 <arkeet> that's harder to type ;)
03:22:58 <skypers_> is RankNTypes the generalized version of Rank2Types?
03:23:07 <merijn> skypers_: Yup
03:23:17 <skypers_> ok, thank yo
03:23:18 <skypers_> u
03:23:28 <arkeet> I wouldn't say "the", but yes
03:36:57 <skypers_> do you think it's possible at some day having internal lenses?
03:37:08 <skypers_> we have minimum ones
03:37:12 <skypers_> with {}
03:43:37 <rotemy> Hi, I'm new to Haskell and am desperately trying to send a basic JSON over HTTP, so far with no results in sight. This is pretty much the code I have now to send the request: http://pastebin.com/G11qm76W. I'm getting weird errors claiming expected type of sendRequest is Blaze.ByteString.Builder.Internal.Types.Builder, while I'm providing OutputStream. Is there a better/simpler way to achieve what I'm trying to achie
03:43:38 <rotemy> ve? What am I missing?
03:43:39 <mauke> The paste G11qm76W has been copied to http://lpaste.net/95642
03:43:53 <staley> is there any place where foldl would be prefered over foldl' ?
03:44:36 <rotemy> (not all imports are used in the code, some were left form previous experimentation)
03:48:24 <skypers_> have a nice day!
03:48:33 <identity> staley: I don't know that library, but I've had good luck with http-conduit
03:48:35 <Fuuzetsu> rotemy: http://hackage.haskell.org/package/http-streams-0.4.0.0/docs/Network-Http-Client.html#v:sendRequest doesn't say that it takes an OutputStream
03:48:38 <identity> which is excellent
03:48:49 <identity> and rather simple to use
03:49:05 <arkeet> staley: not really ;)
03:49:33 <arkeet> However, if the combining function is lazy in its first argument, foldl may happily return a result where foldl' hits an exception:
03:49:35 <arkeet> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
03:50:01 <Fuuzetsu> identity: Are you addressing the wrong person?
03:50:09 <rotemy> Fuuzetsu: ok, right. It's a function taking an outputstream and yielding some IO value, right?
03:50:11 <identity> oh
03:50:11 <identity> yes
03:50:12 <identity> sorry
03:50:21 <identity> rotemy: ^ see my answer above addressed to staley
03:51:07 <arkeet> staley: but I've never heard of that sort of situation actually happen.
03:51:30 <rotemy> identity: I tried http-conduit, seems to be even more confusing. I couldn't figure out even how to do HTTP Basic authorization with it
03:51:37 <rotemy> the documentation really really sucks
03:51:43 <identity> i disagree
03:52:15 <Fuuzetsu> rotemy: OutputStream Builder
03:52:26 <Fuuzetsu> which is where you are getting the Builder type stuff
03:53:09 <Fuuzetsu> It'd actually be great if you could annotate your paste with the full error, at http://lpaste.net/95642
03:53:23 <staley> I expected this to throw exception but it didn't
03:53:28 <staley> > take 1 $ foldl' (flip (:)) [] [undefined, 1]
03:53:30 <lambdabot>   [1]
03:54:58 <staley> I still didn't fully grasp `seq`/laziness, it seems
03:55:42 <Fuuzetsu> staley: You can use ‘:sprint’ in GHCi to see how much something has been evaluated
03:55:53 <staley> ah that is useful
03:56:38 <Fuuzetsu> There's also :force and friends
03:56:40 <donri> > let xs = 1 : undefined in head (xs `seq` xs)
03:56:41 <lambdabot>   1
03:57:16 <kqr> is there a clever way to get n `choose` k for arbitrary k? for k=2, i can just do [(x, y) | (i,x) <- zip [0..] xs, y <- drop i xs] but that approach doesn't scale very well. i could write a function for it, but i'm just checking so i'm not missing something obvious
03:57:36 <Fuuzetsu> :t choose
03:57:38 <lambdabot> Random a => (a, a) -> Gen a
03:57:52 <donri> staley: seq on a list only forces the constructor ie. Cons or Nil, so to speak
03:57:54 <staley> > let u = undefined in u `seq` head [1, u]
03:57:56 <lambdabot>   *Exception: Prelude.undefined
03:58:11 <staley> donri I see
03:58:23 <staley> that's why we have deepseq..
03:58:27 <kqr> Fuuzetsu, i don't want a nondeterministic choose, i want all the possible combinations of k elements from a list of n
03:58:28 <donri> staley: this is what "weak head normal form" or "WHNF" is all about
03:58:34 <donri> yes
03:58:45 <identity> > replicateM 2 [1,2,3] -- kqr
03:58:47 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
03:59:24 <kqr> identity, that is what i have currently, but i realised i dont want both [3,1] and [1,3]
03:59:36 <identity> ah
04:00:02 <donri> > take 1 $ foldl' (\a b -> a `seq` b `seq` (b:a)) [] [undefined, 1]
04:00:03 <lambdabot>   *Exception: Prelude.undefined
04:00:20 <staley> > let xs = [1,undefined] in xs `seq` head xs
04:00:22 <lambdabot>   1
04:00:23 <staley> > let xs = [1,undefined] in xs `deepseq` head xs
04:00:25 <lambdabot>   Not in scope: `deepseq'
04:00:40 <identity> @hoogle deepseq
04:00:41 <donri> somewhat surprised this even type checks. because Num polymorphism maybe?
04:00:41 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
04:00:42 <lambdabot> package deepseq
04:00:42 <lambdabot> package deepseq-generics
04:00:49 <donri> > take 1 $ foldl' (\a b -> a `seq` b `seq` (b:a)) [] [undefined, '1']
04:00:50 <lambdabot>   "*Exception: Prelude.undefined
04:00:53 <donri> mhm
04:01:09 <FreeFull> foldl' doesn't force the elements of the list
04:01:24 <FreeFull> Just the result of the function being applied
04:01:32 <donri> who are you answering, FreeFull
04:01:47 <identity> isn't that another way of saying it's strict in the accumulator?
04:01:48 * FreeFull shrugs
04:01:53 <identity> @src foldl'
04:01:54 <lambdabot> foldl' f a []     = a
04:01:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:02:01 <kqr> identity, yeah, it is
04:02:28 <staley> foldl' f !a (x:xs) = foldl' f a' xs
04:02:30 <donri> oic why it type checks, i'm being stupid
04:02:33 <staley> much nicer
04:02:43 <staley> s/a'/a
04:03:15 <donri> staley: needs extension though :)
04:03:25 <identity> bangpatterns is sexy though, yes.
04:03:30 <identity> s/is/Are
04:03:37 <identity> gUU
04:03:39 <identity> eh
04:03:42 <identity> guu
04:04:27 <donri> 2g??
04:04:40 <identity> isn't that rot13?
04:04:52 <donri> i wanted it to be rot26, but doesn't seem to twork
04:05:04 <donri> ah it's two lines, not "twice"
04:05:05 <identity> I just stumbled upon that command last night
04:05:15 <donri> g??. there ;)
04:05:18 <identity> g??.,
04:05:19 <identity> yeah
04:05:33 <identity> it's funny that that is an actualy command in vim tbh
04:06:18 <ibotty> because of the usefulness! just image what usenet was like.. back in the day...
04:06:18 <donri> ?funny<CR>ciwsilly<Esc>
04:06:18 <lambdabot> Unknown command, try @list
04:06:34 <identity> hehe.
04:07:03 <tarruda> Is there any command-line utility that I can give a function name and it will display the implementation?
04:07:16 <identity> tarruda: lambdabot
04:07:19 <identity> @src length
04:07:19 <lambdabot> Source not found. My brain just exploded
04:07:25 <hpc> lambdabot's source lies
04:07:36 <identity> oh
04:07:49 <hpc> it's a flat file, it doesn't actually get source
04:07:53 <ibotty> finally found the right image... http://1.bp.blogspot.com/_wb8bAl1P-N0/SyEMBMtJjcI/AAAAAAAALmA/aRPwexXe6oY/s1600-h/Dachshund+of+Time.jpg
04:07:57 <ibotty> well.. back to work
04:09:01 <tarruda> I'm currently using vim-hoogle, it would be nice having something similar but for showing source-code
04:09:04 <donri> ibotty: https://s3.amazonaws.com/lyah/listmonster.png
04:09:19 <ibotty> that's great as well
04:09:23 <tarruda> @src map
04:09:23 <lambdabot> map _ []     = []
04:09:23 <lambdabot> map f (x:xs) = f x : map f xs
04:09:35 <tarruda> that seems nice
04:09:45 <ibotty> (i can never remember init, so that's a nice reminder)
04:10:55 <FreeFull> ibotty: Is that supposed to be about carbon dioxide?
04:10:59 <ibotty> tarruda: great. i did not know vim-hoogle existed. better than my mapping
04:11:15 <ibotty> FreeFull: no. about hipster-talk :D
04:11:31 <FreeFull> What does a dog have to do with it?
04:12:14 <lpaste> Fuuzetsu annotated “pastebin.com/G11qm76W” with “pastebin.com/G11qm76W (annotation)” at http://lpaste.net/95642#a95643
04:13:08 <Fuuzetsu> rotemy: See above. I put in a type annotation to make it clear what outputStream needs to be (and I made SomeObject and an undefined ToJSON instance of it so that I could compile)
04:13:30 <donri> :set keywordprg=hoogle
04:15:03 <ibotty> FreeFull: it's a joke. i guess there are many interpretations, but i like thinking about it as all those categories are not that long ago. and when we are speaking about, say, back in the day, we are only patting us on the back that we were hip a few days earlier, maybe.
04:15:47 <rotemy> quick question: If I have a Request that I need to process several times with modifiers (like applyBasicAuth or similar mutators), can I write it elegantly with a "do" block instead of performing multiple assignments or plenty of '$' signs?
04:16:12 <ibotty> what about a fold?
04:18:51 <rotemy> Fuuzetsu: thanks for the annotation, but I'm finding this extremely tedious to just send an HTTP request...
04:19:04 <rotemy> and I still don't fully grasp the concept of how streams are built in this library...
04:19:20 <donri> rotemy: that's Writer
04:19:40 <rotemy> donri: ?
04:19:41 <donri> e.g. Writer (Endo Request)
04:19:57 <donri> runWriter $ do tell applyBasicAuth; tell ...
04:20:05 <donri> eh plus Endo
04:20:09 <donri> and appEndo :p
04:21:04 <rotemy> donri: oh
04:21:08 <rotemy> never heard of it
04:21:27 <donri> flip appEndo req $ runWriter $ do tell (Endo applyBasicAuth); tell ...
04:21:48 <donri> a lot of noise there but you can abstract it all away
04:22:29 <donri> i'd just use composition though :P
04:22:33 <Fuuzetsu> rotemy: Just FYI, I never used these libraries and didn't even have the modules installed, I just installed them and looked at what types GHC said I needed then used online docs to find the functions that give me these types
04:22:43 <donri> ... . applyBasicAuth $ req
04:23:10 <rotemy> donri: ok, I'll look into it. Thanks!
04:23:28 <rotemy> Fuuzetsu: thanks, I'll try to take it from here!
04:25:09 <ocharles> mm_freak_: oh, congrats on releasing netwire 5
04:25:43 <ocharles> mm_freak_: I'm thinking of using netwire to do some market analysis on bitcoin (specifically, backtesting). Do you think it's suitable for that?
04:25:57 <ocharles> I just want to do some basic things like moving average cross over
04:26:11 <tarruda> how do I initialize lambdabot to display source code?
04:26:23 <tarruda> it says srcPlugin isnt initialized
04:27:22 <tarruda> Plugin `sourcePlugin' failed with: state not initialized
04:27:29 <tarruda> when I ask for the source of a function
04:33:22 <lpaste> deweyvm pasted “avoid generating infinite values” at http://lpaste.net/95644
04:33:37 <deweyvm> new to quickcheck, how do i keep this from creating infinite values?
04:35:28 <hpc> deweyvm: does it currently generate infinite values?
04:36:04 <hpc> oh, it does
04:36:06 <deweyvm> they are presumably infinite though because of the randomness im not sure
04:36:07 <Iceland_jack> deweyvm: You need to bound your generator
04:36:23 <Iceland_jack> check your the QuickCheck tutorial for how to generate arbitrary tree-like structures
04:36:27 <deweyvm> they are at least a couple pages
04:36:44 <Iceland_jack> deweyvm: http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
04:36:54 <deweyvm> will do, thanks
04:36:55 <Iceland_jack> Under “Generating Recursive Data Types”
04:37:27 <Iceland_jack> You take in a paramter for the size, and cut it in half at each recursive step
04:38:31 <Iceland_jack> deweyvm: Does this answer your question?
04:38:48 <deweyvm> yes, thanks :)
04:41:01 <lpaste> Zeke pasted “Instancing doesn't quite work” at http://lpaste.net/95645
04:47:03 <lpaste> Zeke revised “Instancing doesn't quite work”: “No title” at http://lpaste.net/95645
04:47:05 <staley> why does "forever (Just 10)" use constant space, while "forever [10]" doesn't?
04:48:14 <lpaste> Zeke revised “Instancing doesn't quite work”: “No title” at http://lpaste.net/95645
04:49:24 <berdario> Does someone here use classy-prelude?
04:49:56 <berdario> http://www.yesodweb.com/blog/2012/07/clarification-classy-prelude here, the author writes:
04:50:12 <berdario> "foo" ++ "bar" is far easier than T.pack "foo" `T.append` T.pack "bar"
04:50:27 <mauke> "foo" <> "bar"
04:50:51 <berdario> but I just realized that Data.Text.append isn't included... ++ doesn't work with Data.Text, and I'm kinda baffled
04:51:14 <mauke> does <> work?
04:51:31 <lpaste> Zeke revised “Instancing doesn't quite work”: “No title” at http://lpaste.net/95645
04:52:35 <berdario> mauke: yes, thanks
04:52:47 <hamid> How or more importantly why do you use Monad.guard at all?
04:52:59 <hamid> > M.guard False :: Maybe ()
04:53:02 <lambdabot>   Not in scope: `M.guard'
04:53:04 <hamid> > guard False :: Maybe ()
04:53:06 <lambdabot>   Nothing
04:53:17 <mauke> > do x <- [1 .. 10]; guard (even x); return x
04:53:19 <lambdabot>   [2,4,6,8,10]
04:55:00 <volko> why is yesod so complicated?
04:55:50 <mauke> it builds character
04:56:22 <identity> lol
04:56:39 <mm_freak_> ocharles: if it's "online" (i.e. live) market analysis, then yes, netwire should do that very well
04:58:02 <mm_freak_> ocharles: also i just noticed that you don't read all messages i send you =P
04:58:40 <tarruda> any idea how to fix the "Plugin `sourcePlugin' failed with: state not initialized" lambdabot error?
04:59:30 <berdario> mauke: do you have a guide about some similar easy problem when trying to switch String types to Text? right now I'm stuck with `"" tshow 1`... I'd guess that classy-prelude enabled overloaded strings, but it complains that "" is a String and not a Text
05:00:15 <mauke> no
05:03:05 <berdario> explicitly enabling {-# LANGUAGE OverloadedStrings #-} did the trick
05:11:38 <bearclaw> cmd :: CmdArguments args => args :-> Action r   <-- what sorcery is this :->  ?
05:11:48 <chrisdone> looks like fclabels
05:12:22 <chrisdone> http://hackage.haskell.org/package/fclabels-2.0.0.5/docs/Data-Label.html#g:1
05:12:52 <mauke> bearclaw: looks like a normal infix constructor
05:13:42 <bearclaw> let me read that up for the following few hours :)
05:14:13 <mauke> data T x y z = ...
05:14:20 <mauke> data (:->) x y z = ...
05:14:40 <volko> snap seems friendlier
05:15:06 <chrisdone> volko: snap is dumber
05:17:05 <chrisdone> bearclaw: you can read l :: r :-> f as "`l' is lens for `f' into `r'"
05:17:38 <chrisdone> bearclaw: so cmd :: CmdArguments args => args :-> Action r is "cmd is a lens for getting/setting/modifying the Action r inside args"
05:18:17 <bearclaw> ok, so this depends on the concept on lens, I should read on that first
05:18:42 <chrisdone> yeah, fclabels used to have a nice tutorial on the hackage page explaining the concept but now it's gone
05:18:47 <sopvop> snap is dumber in a good way
05:19:12 <bearclaw> chrisdone: there is this http://fvisser.nl/post/2013/okt/1/fclabels-2.0.html that looks quite readable
05:19:16 <chrisdone> bearclaw: here: http://hackage.haskell.org/package/fclabels-0.11.2
05:19:23 <bearclaw> (provided one knows about lens)
05:19:52 <mauke> a lens is a field getter/setter
05:20:10 <chrisdone> bearclaw: their old documentation is better ^
05:20:18 * sopvop thought lens is a traversal
05:20:47 <bearclaw> initially I was trying to understand how this "cmd" from shake could appear like a variadic function. Does it need lens to do that?
05:21:10 <chrisdone> huh?
05:21:27 <chrisdone> no, variadic functions tend to be implemented with simple type classes
05:22:50 <klugez> The same explanation about fclabels is still available in the main module: http://hackage.haskell.org/package/fclabels-2.0.0.5/docs/Data-Label.html for the newest version.
05:23:58 <ocharles> mm_freak_: ok, I thought the plan was to generalise integral
05:24:36 <mm_freak_> ocharles: yeah, although your patch doesn't generalize it =)
05:24:47 <mm_freak_> it changes the interface
05:24:57 <ocharles> right
05:25:36 <mm_freak_> i think the current interface to integralWith is fine and your patch really should be an additional wire
05:26:19 <mm_freak_> however, i'm not sure it would be appropriate to add it, because mtl-specific interfaces should probably be handled by the user project or an additional package
05:26:36 <ocharles> you don't want to depend on mtl?
05:27:17 <mm_freak_> not for a single wire that is really just a different interface to another wire =)
05:28:27 <ocharles> i'd get that if I was depending on something people don't commonly have, but mtl has hundreds of reverse dependencies
05:28:30 <mm_freak_> ocharles: finally i would have solved it differently
05:28:47 <ocharles> it doesn't have to be solved that way
05:28:57 <mm_freak_> ReaderT A (State B) ≃ StateT B ((->) A)
05:29:12 <ocharles> ok, so you'd just run the action a different way
05:29:30 <mm_freak_> no, i wouldn't make it an action in the first place
05:29:44 <malorie> how can I sample a continuous-time function at a certain rate, in reactive-banana?
05:30:18 <mm_freak_> malorie: first construct a timer event
05:30:40 <malorie> mm_freak_: do I have to define time myself?
05:30:51 <mm_freak_> malorie: yes
05:31:02 <mm_freak_> malorie: once you have that event use (<@)
05:31:21 <mm_freak_> signal <@ tick
05:31:37 <malorie> how would such a timer event look like? what would be the type/values of my time?
05:31:59 <mm_freak_> that gives you an event, which you can turn into a behavior again by using 'stepper'
05:32:16 <mm_freak_> that's up to you
05:32:20 <mm_freak_> for me it would be () =)
05:32:36 <mm_freak_> reactive-banana is not framed, it's push-based
05:32:43 <malorie> but where does the actual timing happen?
05:32:44 <evancz> I'd like to start using some sort of Database with HAppStack. Does anyone know a recommended route?
05:32:58 <evancz> I am leaning towards acid-state, but maybe there's something better
05:33:00 <mm_freak_> malorie: you could use a separate thread
05:33:13 <mm_freak_> evancz: start with acid-state
05:33:31 <malorie> and I have to use a package that has some timing primitives for me to construct such an event, right?
05:33:33 <evancz> mm_freak_: why "start"? Will I need something else later?
05:33:45 <mm_freak_> malorie: no, you have to use Reactive.Banana.Frameworks
05:34:04 <mm_freak_> malorie: fromPoll with a threadDelay should do it
05:34:12 <mm_freak_> but it's not accurate
05:35:11 <malorie> but I do want accuracy :-P
05:35:14 <mm_freak_> evancz: not necessarily =)
05:35:22 <mm_freak_> malorie: what's your application?
05:35:38 <malorie> I'm trying to write a simple soft-synth
05:35:47 <mm_freak_> malorie: then i don't recommend reactive-banana
05:35:50 <mm_freak_> try netwire instead
05:36:00 <mm_freak_> it's framed instead of push-based
05:36:05 <malorie> fair enough. I'll have a look at it
05:36:24 <mm_freak_> malorie: http://www.haskell.org/haskellwiki/Netwire
05:36:57 <malorie> thanks
05:37:50 <bearclaw> http://lpaste.net/95651 ah I think I got the basic trick for varargs
05:38:37 <bearclaw> except it doesn't accept literal integers
05:39:03 <tdammers> integer literals are polymorphic, so it can't infer the type
05:39:10 <tdammers> try type-hinting them
05:39:30 <tdammers> e.g. foo (35 :: Int) instead of foo 35
05:39:43 <bearclaw> if I do that it works, but it's anoying
05:39:56 <tdammers> that's the price you pay for polymorphic literals and type inference
05:40:24 <bearclaw> well, here I'm not sure I get why inference fails
05:41:59 <bearclaw> let foo = id :: Int->Int in foo 2   works, I don't see how my case is different
05:42:37 <triliyn> bearclaw: GHC doesn't know that there's only one matching instance
05:43:24 <triliyn> Because type classes are meant to be extendable, so it doesn't bother analyzing the typeclass instance possibilities
05:43:58 <bearclaw> ah I see
05:46:49 <hamid> > do { x <- [1..10]; return () }
05:46:50 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
05:47:00 <hamid> i don't get this :/
05:47:12 <hamid> > do { x <- [1..10]; print "test";return () }
05:47:13 <lambdabot>   Couldn't match type `GHC.Types.IO' with `[]'
05:47:14 <lambdabot>  Expected type: [()]
05:47:14 <lambdabot>    Actual...
05:48:06 <mangaba_leitosa> hamid: you are trying to use an IO monad within the list monad :-)
05:48:18 <bearclaw> [1..10] << (return ())
05:48:49 <bearclaw> [1..10] >> (return ())
05:49:18 <hamid> mangaba_leitosa, how can I know that it's list monad?
05:49:38 <fizruk> hamid, x <- [1..10] ?
05:49:56 <fizruk> [1..10] :: Num t => [t]
05:50:41 <fizruk> in x <- a, a should be of type (Monad m) => m b if x has type b
05:50:58 <fizruk> so in x <- [1..10], [] is m
05:50:59 <hamid> fizruk, i always saw that only as an assignment :/
05:51:14 <hamid> like let x = [1..10]
05:51:34 <fizruk> hamid, well for that you could write x <- return [1..10]
05:51:36 <triliyn> It's not assignment, it's monadic binding
05:52:10 <Fuuzetsu> hamid: You can do ‘let x = [1..10]’. It's going to be the same as ‘x <- return [1..10]’ but you should probably understand what's going on.
05:52:51 <hamid> yeah i think I need to. is there anything about that in Real World Haskell ?
05:53:07 <Fuuzetsu> I imagine it has a section on monads.
05:53:21 <hamid> monadic binding? right? i'm going to look for it. thanks guys.
05:53:32 <mauke> @undo do { x <- [1 .. 10]; doStuffWith x }
05:53:32 <lambdabot> [1 .. 10] >>= \ x -> doStuffWith x
05:53:46 <hamid> mauke, thanks :)
05:55:20 <enthropy> patterns beside the <-  (or ->) is not a recursive binding
05:55:46 <BoR0> is it possible to implement pattern matching using only lambda calculus? e.g. (\2 -> 3) matches pattern 2, but I was thinking something like (\x -> (\2 -> 3) x), how could I combine pattern 2 and pattern 3 say, so that both (\2 -> 3) and (\3 -> 4) are matched?
05:55:52 <enthropy> > do x <- [1,2]; x <- [1+x]; return x
05:55:53 <lambdabot>   [2,3]
05:56:30 <hamid> this list being a monad is kinda wierd to me :P but it works like miracle
05:56:31 * hackagebot conduit 1.0.9.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.9.1 (MichaelSnoyman)
05:56:43 <hamid> what's x type then?
05:56:54 <triliyn> BoR0: I think you need a case statement
05:57:42 <triliyn> I think there might be an extension to allow multiple lambda-heads but I haven't looked at it, I only saw the name
05:57:50 <triliyn> And I don't even rememeber the name anymore
05:57:57 <hamid> > do x <- return [1,2]; x <- [1+x]; return x
05:57:59 <lambdabot>   No instance for (GHC.Show.Show t0)
05:57:59 <lambdabot>    arising from a use of `M7543604392868...
05:58:28 <hamid> > do let x = [1,2] in x <- [1+x]; return x
05:58:29 <lambdabot>   <hint>:1:4: Parse error in pattern: let x = [...] in x
05:58:29 <triliyn> \x -> case x of 2 -> 3; 3 -> 4
05:58:43 <BoR0> this worked fine
05:58:47 <BoR0> > (\x -> if x == 2 then ((\2 -> 3) x) else ((\3 -> 4) x)) 3
05:58:48 <lambdabot>   4
05:58:51 <BoR0> > (\x -> if x == 2 then ((\2 -> 3) x) else ((\3 -> 4) x)) 4
05:58:53 <lambdabot>   *Exception: <interactive>:3:44-50: Non-exhaustive patterns in lambda
05:59:02 <triliyn> > do { let x = [1,2] in x <- [1+x]; return x }
05:59:03 <lambdabot>   <hint>:1:6: Parse error in pattern: let x = [...] in x
05:59:07 <BoR0> so, it is possible to do pattern matching with lambda calculus only
06:00:13 <fizruk> BoR0, x == 2 is not pattern matching
06:00:23 <fizruk> in general
06:00:39 <enthropy> if then else too might also not be "lambda calculus only"
06:00:50 <BoR0> but ifthenelse is well defined in lambda calculus
06:01:32 * hackagebot xml-conduit 1.1.0.8 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.1.0.8 (MichaelSnoyman)
06:01:50 <berdario> If I do :set prompt "> " in ghci
06:02:38 <deweyvm> how would i create a list of elements with n head elements in applicative style? "(:) <$> el <*> rest" works for one element but i need to write a new function for each additional element such as "(<::>) x y xs = x:y:xs" -> "(<::>) <$> e0 <*> e1 <*> rest"
06:02:54 <fizruk> > (\x -> case x of Nothing -> 0; Just x -> x) (Just 10)
06:02:56 <lambdabot>   10
06:03:00 <berdario> when I get continuation lines (for multiline commands), I still get a prompt like "Prelude ClassyPrelude Text.Parsec|"
06:03:23 <BoR0> (\x -> case x of Nothing -> 0; Just x -> x) 5
06:03:25 <BoR0> > (\x -> case x of Nothing -> 0; Just x -> x) 5
06:03:26 <fizruk> berdario, I heard they will have prompt2 for that in 7.8
06:03:27 <lambdabot>   No instance for (GHC.Show.Show a0)
06:03:27 <lambdabot>    arising from a use of `M3499107043542...
06:03:45 <BoR0> so we don't get the non-exhaustive patterns error
06:03:45 <berdario> fizruk: thanks... in the meanwhile what do you suggest? avoid redefining prompt ?
06:03:46 <Twey> triliyn: -XLambdaCase gives you expressions of the form \case { Nothing → 0; Just n → n }
06:04:25 <fizruk> berdario, I redefine it but I don't use multiline input, I write multiline code in a file instead
06:04:25 <enthropy> deweyvm: you can go the way of Text.Printf and have a function that takes any number
06:04:26 <triliyn> Twey: ahhh, okay
06:04:36 <berdario> ok, thanks
06:05:41 <fizruk> > (\x -> case x of Nothing -> 0) (Just 5)
06:05:42 <lambdabot>   *Exception: <interactive>:3:8-29: Non-exhaustive patterns in case
06:06:01 <Twey> BoR0: Depends on which λ-calculus you're talking about :þ  In general λ-calculi don't have data structures other than functions, so no pattern-matching
06:06:06 <fizruk> BoR0, ^ there 's how you get that one :)
06:06:20 <FreeFull> > fromMaybe 10 (Just 5)
06:06:22 <lambdabot>   5
06:06:23 <BoR0> fizruk: so ifthenelse is not pattern matching, but case is?
06:06:33 <FreeFull> > fromMaybe 10 Nothing
06:06:35 <lambdabot>   10
06:06:45 <Twey> BoR0: (you'd typically encode a data structure as its eliminator; pattern-matching can be defined as syntactic sugar for this)
06:07:05 <fizruk> BoR0, test for equality with == is not a pattern matching
06:07:12 <BoR0> Twey: I understand, that makes sense
06:07:58 <fizruk> BoR0, if then else is kind of ifThenElse :: Bool -> a -> a -> a
06:08:25 <fizruk> BoR0, so it only pattern matches on Bool
06:08:30 <dwcook> It's pattern matching on Bool :)
06:08:41 <BoR0> but can't we do if X then Y else if Z then A else B
06:08:53 <Twey> BoR0: Top-level definitions, where definitions, let definitions, lambdas, do-assignment, and pattern guards are pattern-matching (and probably a few more I've forgotten :þ), but if/then/else just takes a Bool
06:09:30 <Twey> BoR0: You need to take two (syntactic) parameters to pattern-match: a value to match and a pattern to match it against.  if/then/else only has a place for the latter: the pattern is hard-coded, if you like.
06:09:31 <fizruk> BoR0, sure you can, but in those X and Z you will use == which is not a pattern matching :)
06:10:07 <fizruk> BoR0, consider a list of functions [(+), (/)] :: [ Int -> Int ]
06:10:37 <fizruk> BoR0, you can't do xs == [], but you can pattern match on it: case xs of [] -> ...
06:10:42 <Twey> BoR0: Pattern-matching means you can insert variables in your pattern that will be filled by the appropriate part of the matched value
06:12:03 <mm_freak_> does anyone know how hackage2 change logs work?
06:12:14 <BoR0> I see! thanks for the explanation guys, it's a bit more clearer now
06:12:41 <shiona_> I would like to use cabal for a single project and arch packages based haskell for all the others. Can I do this?
06:16:45 <tdammers> shiona_: yes. Look into cabal sandbox or cabal-dev
06:18:27 <shiona_> tdammers: thanks, will do
06:19:00 <volko> I'm not sure I follow the $() syntax
06:19:21 <merijn> volko:  $() is Template Haskell syntax
06:20:01 <volko> ah, so that's why I see it in web frameworks
06:20:20 <ghorn> what do you do when Text.Printf doesn't quite fulfill your needs? is there a more poweful library for that sort of thing?
06:20:29 <merijn> volko: It basically lets you use Haskell to generate Haskell source at compile time. And yes it's frequently used in web frameworks (especially Yesod)
06:21:32 <mm_freak_> volko: if a TH expression is at the top-level (non-indented), then you can leave off this weird syntax
06:21:36 <mm_freak_> makeLenses ''Blah
06:21:42 <mm_freak_> instead of:  $(makeLenses ''Blah)
06:22:05 <merijn> volko: The code within the $() returns Haskell source and GHC then compiles that source
06:22:11 <k00mi> ghorn: what do you need specifically?
06:22:41 <merijn> ghorn: I believe there's several pretty printing libraries
06:23:13 <ghorn> k00mi: "%e" is not letting me fix the number of digits in the exponential
06:23:53 <ghorn> it's printing doubles and ints in columns to show iterations in my numerical solver
06:24:46 <lpaste> ghorn pasted “iterations” at http://lpaste.net/95654
06:25:34 <ghorn> (ignore line number on the left, that's lpaste's not mine)
06:27:20 <k00mi> ghorn: most pretty printing libraries should support that
06:34:53 <ghorn> k00mi: i'm looking in "pretty" and "wl-pprint" and nothing's jumping out at me
06:35:24 <ghorn> k00mi: do you mean it's easy to imlement this myself in most pretty printing libraries, or it's already implemented?
06:38:59 <donri> @hackage formatting maybe
06:38:59 <lambdabot> http://hackage.haskell.org/package/formatting maybe
06:40:25 <k00mi> ghorn: I meant already implemented
06:40:51 <k00mi> formatting has it (expt)
06:41:21 <k00mi> text-format aswell
06:44:05 <k00mi> oh wait, you wan to fix the length of the exponential
06:44:32 <k00mi> so, e.g. 1.4e001?
06:44:35 <ghorn> yeah
06:44:38 <ghorn> exactly
06:45:05 <ghorn> though i'm glad to learn about all these libraries (because Text.Printf exceptions are no fun)
06:46:00 <k00mi> I don't know then, I don't think any library has a function for that
06:46:39 * hackagebot diagrams-haddock 0.2.1.2 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.1.2 (BrentYorgey)
06:46:45 <bz> @hoogle biAp
06:46:45 <lambdabot> No results found
06:55:04 <osa1> .hi and .o files generated by ghc is annoying, is there a way to say ghc to don't keep that files?
06:55:51 <slack1256> They are useful for recompilation purpouses, they tell you what hasn't changed and doesn't redo them
06:56:09 <slack1256> but you can do a build directory where all those files live without cluttering your code
06:56:43 <merijn> osa1: How are they annoying?
06:56:53 <slack1256> ghc --make -outputdir ../build
06:56:54 <merijn> osa1: Also, if you use cabal they'll be hidden away in a separate directory
06:57:00 <slack1256> does what you want
06:57:03 <quchen> You can either use Cabal to handle the things for you, or you can use lndir to create a build directory wth soft links to the original source files. The .o/.hi stuff is in the build dir, but you edit in the source dir.
06:57:29 <quchen> Working on GHC for example seems to be an example for the "lndir" approach.
07:07:12 <simon> does anyone know if a Yacc-like DSL was ever attempted embedded into ML/Haskell?
07:09:46 <dcxi> simon: for ML there is ml lex and ml yacc.
07:11:26 <deweyvm> f# has it too if that counts
07:14:24 <bennofs> simon: well, there is alex and happy. Not sure how that compares to yacc
07:14:27 <dcxi> Ocaml too.
07:15:02 <bennofs> ah, I you said embedded. Never mean then
07:16:40 <merijn> I'm not sure I see the point of embedding that in ML/Haskell?
07:17:25 <lpsmith> happy is pretty yacc-like
07:17:42 <lpsmith> although it's not embedded into haskell
07:18:26 <Philippa_> merijn: grammar analyses etc?
07:18:39 <Philippa_> or generating the parsers on the fly
07:18:44 <lpsmith> You can't really do yacc without some kind of compile-time computation.    So it's going to involve some kind of template haskell.
07:19:03 <merijn> Philippa_: I don't see why you couldn't generate parser on the fly without embedding?
07:19:25 <osa1> I'm running this very simple quicktest program but after first 50 test it take too much time for every test. any ideas what could be the reason? all it does is calculate powers of some numbers so it should be instantaneous
07:19:28 <lpsmith> of course, happy preceded template haskell,  so rather it's a happy -> haskell compiler
07:19:32 <merijn> Then again, I've only used bison/flex with C and wasn't sold on them to begin with...
07:19:59 <merijn> osa1: "should be instantaneous" <- that depends on the size of your numbers...
07:20:28 <lpsmith> Integer operations get slow if you are dealing with really big numbers
07:20:38 <berdario> I'm trying to reproduce this: http://stackoverflow.com/questions/2373897/with-parsec-how-do-i-parse-zero-or-more-foo1-terminated-by-foo2-and-all-separat
07:20:52 <berdario> but with (string "foo1") and (string "foo2") instead of foo1 and foo2
07:20:52 <lpsmith> and exponentiation is a pretty fast way to generate big numbers
07:21:10 <berdario> I keep getting `unexpected "2" expecting "foo1"` back
07:22:17 <merijn> berdario: Put a minimal example plus error on lpaste?
07:22:18 <berdario> I also thought about using Parsec's try... but I can't get it to cooperate with endBy
07:24:10 <deweyvm> k <- try (sepBy foo1 (char'.')) <|> return []
07:24:18 <deweyvm> thats how im doing it, probably not the best way though
07:24:26 <berdario> merijn: http://lpaste.net/95658 this should be it
07:25:00 <deweyvm> many seems to just die for me when theres 0
07:26:06 <merijn> I think it should be sufficient to "try" the foo1 parse, lemme check
07:28:03 <berdario> Ok, this is what I was originally trying to do, btw: http://lpaste.net/95659
07:28:10 <merijn> berdario: btw the "j <- string "foo2"" is redundant when you don't use j
07:29:03 <lpaste> merijn annotated “No title” with “Fixed” at http://lpaste.net/95658#a95660
07:29:10 <merijn> berdario: That works for me
07:29:19 <berdario> (I read that parsec is best used as combinators and not with do blocks... but I kept finding documentation that uses it)
07:29:41 <merijn> berdario: The problem is that Parsec doesn't normally do backtracking, so if two option both start with the same prefix it gets stuck
07:30:18 <merijn> berdario: Here it tries to parse a "foo1", but gets stuck when it see the "2", the "try" around "string "foo1"" tells Parsec to backtrack when parse fails
07:30:29 <berdario> merijn: where do you think the try should be put in my original code
07:30:33 <berdario> ?
07:30:43 <berdario> here it is again: http://lpaste.net/95659
07:30:48 <merijn> berdario: So now it tries to parse "foo1", sees a "2" and abandons the parse, going on to the "foo2" bit
07:31:06 <merijn> berdario: I just pasted a fixed version, see the lpaste remark a few lines up
07:31:28 <berdario> merijn: have you looked at 95659?
07:31:37 <berdario> it's different from 95658
07:31:54 <berdario> thanks, btw
07:32:21 <merijn> berdario: Hard to see
07:32:29 <merijn> berdario: I would use the do notation over that code
07:33:38 <merijn> The problem with that newer paste is that I think your grammar is ambiguous
07:33:54 <berdario> is it?
07:34:07 <merijn> "many1 letter" matches "string "at"", doesn't it?
07:34:19 <berdario> exactly
07:34:21 <berdario> uhhhh
07:34:24 <merijn> berdario: How can parsec know whether "at" is part of the "many1 letter" or the end of the sequence
07:35:42 <berdario> it's not the first time I write an ambiguous grammar... it's always painfully obvious when other point it out -_-
07:35:57 <merijn> berdario: endBy detects the end by finding something the first person (many1 letter) fails on. Knowing that it's supposed to stop at "at" requires parsec to be psychic :)
07:36:06 <merijn> eh
07:36:09 <merijn> s/person/parser
07:36:53 <merijn> berdario: You either need to change it so you replace "many1 letter" with something that doesn't accept "at", or determine a non-letter stop condition
07:37:03 <berdario> (actually, I thought that since the second parser matches "at " with a trailing space, it might be enought not get (try (many1 letter)) to trip up)
07:37:27 <merijn> berdario: Yes, but endBy matches the trailing space with the space parser :)
07:37:44 <berdario> yes, thank you
07:38:58 <osa1> in FFI declaration, instead of giving header file and definition name, can I directly pass function signature? (I tried that and it didn't work, I was wondering if there are other ways to do this)
07:39:42 <merijn> osa1: I'm not sure I understand the question, can you give a pseudo code example?
07:40:46 <osa1> merijn: I have this `foreign import ccall "power_lib.h power"' and I want to be able to use this instead: foreign import ccall "unsigned f(unsigned, unsigned)"
07:41:08 <osa1> sorry, that f should be `power'
07:41:41 <mauke> osa1: why do you want to write the type twice?
07:41:53 <osa1> mauke: I don't have a header file
07:41:57 <merijn> I don't think the headerfile is mandatory?
07:42:08 <mauke> osa1: then don't put it in
07:42:26 <mauke> merijn: it might be if you're compiling via C
07:42:30 <osa1> mauke: oh wow. that worked.
07:42:48 <osa1> thanks
07:42:48 <merijn> You can just write "foreing import ccall "power" power :: Word16 -> Word16 -> Word16" or whatever
07:42:57 <osa1> merijn: yes
07:42:58 <merijn> mauke: Does anyone still do that? :x
07:43:20 <mauke> CUInt, actually
07:44:40 <berdario> actually, I just wanted to try to write with parsec something similar to (\d+)\s([a-z]+[a-z ]*)\sat (\d+) ...it seems always so much easier with regexp (for all the limitations that they have :/ )
07:53:54 <zol> If I have a list of names, and I want to create all permutations where each name is tied to a boolean value, like: ["a", "b"] -> [[("a", False), ("b",False)], [("a", False), ("b", True)], [("a", True), ("b", False)], [("a", True), ("b", True)]], what's a good way to do this?
07:55:16 <merijn> zol: List monad!
07:55:31 <mauke> > replicateM 2 [False, True]
07:55:33 <lambdabot>   [[False,False],[False,True],[True,False],[True,True]]
07:56:00 <merijn> > do { name <- ["a", "b"]; value <- [True,False]; return (name, value) }
07:56:01 <zol> mauke: The first list ["a", "b"] can be any length
07:56:02 <lambdabot>   [("a",True),("a",False),("b",True),("b",False)]
07:56:06 <mauke> > (\xs -> zip xs (replicateM (length xs) [False, True])) ["a", "b"]
07:56:08 <lambdabot>   [("a",[False,False]),("b",[False,True])]
07:56:11 <mauke> :-(
07:56:14 <merijn> Ha
07:56:23 <merijn> Mine is prettier than mauke's!
07:56:27 <mauke> they're both wrong
07:56:33 <bennofs> > [[("a", a),("b",b)] | a <- [False,True], b <- [False,True]]
07:56:35 <lambdabot>   [[("a",False),("b",False)],[("a",False),("b",True)],[("a",True),("b",False)...
07:56:56 <bennofs> And this for lists of any length?
07:57:08 <zol> bennofs: Yes
07:57:30 <zol> I guess b will be fixed size.
07:57:33 <mauke> > (\xs -> map (zip xs) (replicateM (length xs) [False, True])) ["a", "b"]
07:57:35 <lambdabot>   [[("a",False),("b",False)],[("a",False),("b",True)],[("a",True),("b",False)...
07:57:47 <merijn> Isn't it maybe easier to compute all permutations of N booleans and then zipping each with the list of names?
07:57:59 <mauke> guess what I'm doing
07:58:05 <merijn> :t permutations
07:58:06 <lambdabot> [a] -> [[a]]
07:58:08 <zol> merijn: That's what I would do in C#..
07:58:19 <zol> merijn: More or less at least.
07:58:37 <zol> :i permutations
07:58:42 <mauke> > liftA2 map zip (flip replicateM [False, True] . length) ["a", "b", "c"]
07:58:43 <lambdabot>   [[("a",False),("b",False),("c",False)],[("a",False),("b",False),("c",True)]...
07:58:45 <berdario> liftA2 (,) [1,2,3] [True, False]
07:58:53 <bennofs> > sequence $ replicate 4 [False,True]
07:58:54 <berdario> > liftA2 (,) [1,2,3] [True, False]
07:58:55 <lambdabot>   [[False,False,False,False],[False,False,False,True],[False,False,True,False...
07:58:56 <lambdabot>   can't find file: L.hs
07:59:03 <merijn> zol: I just realised permutations is no good here
07:59:21 <berdario> > liftA2 (,) [1,2,3] [True, False]
07:59:23 <lambdabot>   [(1,True),(1,False),(2,True),(2,False),(3,True),(3,False)]
07:59:40 <merijn> berdario: Nope, wrong output
08:00:19 <bennofs> > (\names -> map (zipWith (,) names) $ sequence $ replicate (length names) [False,True]) $ ["a","b"]
08:00:20 <lambdabot>   [[("a",False),("b",False)],[("a",False),("b",True)],[("a",True),("b",False)...
08:00:27 <merijn> mauke's approach is most promising, but a bit obfuscated
08:00:34 <mauke> merijn: which version?
08:00:37 <bennofs> Does my approach work?
08:00:43 <mauke> bennofs: yes, but you just repeated what I said
08:00:50 <merijn> Oh, you have without liftA2
08:00:50 <mauke> zipWith (,) = zip
08:00:57 <mauke> sequence .: replicate = replicateM
08:00:59 <bennofs> ah, didn't pay attention :P
08:01:17 <merijn> This one: (\xs -> map (zip xs) (replicateM (length xs) [False, True])) ["a", "b"]
08:01:23 <berdario> Ahhh, yes... list of lists of tuples... but maybe for zol a list of tuples is enough?
08:01:28 <merijn> Could probably use a little cleanup
08:01:43 <merijn> i.e. where/lets to be clearer
08:01:46 <mauke> merijn: why do you think it's obfuscated?
08:01:58 <merijn> mauke: No, that one is relatively fine
08:02:15 <merijn> mauke: I was initially looking at the pointfree one with liftA2 and flip
08:02:27 <mauke> that was just for fun :-)
08:02:38 <bennofs> @ty liftA2 map
08:02:40 <lambdabot> Applicative f => f (a -> b) -> f [a] -> f [b]
08:02:58 <merijn> I would just split out "replicateM (length xs) [False,True]" into a separate where clause
08:05:56 <khyperia> why is "mdo" called mdo? (as in {-# LANGUAGE RecursiveDo #-})
08:07:18 <khyperia> also, I think mdo is preferred over do rec, is this correct?
08:10:54 <donri> the paper says mdo was the closest they could get to "µdo" in ascii
08:11:05 <khyperia> ah
08:11:26 <khyperia> but then follow up question: why ?
08:11:37 <Clint> fsvo "closest"
08:12:34 <khyperia> I'm guessing from http://en.wikipedia.org/wiki/Mu-recursive_function
08:12:40 <merijn> khyperia: mu is typically associated with minimal fixpoint
08:12:49 <khyperia> right.
08:13:45 <merijn> khyperia: I remember one is preferred over the other, but forget which. I do believe the GHC manual explicitly states which should be preferred
08:13:57 <merijn> So I'd just consult that
08:14:26 <donri> merijn: first one was deprecated in favor of the other, than that one was deprecated in favor of the former. now both are de-deprecated. IIUC
08:14:41 <merijn> Progress! \o/
08:14:55 <khyperia> ok then
08:15:10 <khyperia> I like mdo more so I guess I'll just go with that.
08:15:12 <donri> mfix deprecate
08:16:24 <donri> ok i misremember: first RecursiveDo was deprecated in favor of DoRec, and now DoRec is deprecated in favor of RecursiveDo which now enables both
08:17:04 <merijn> donri: You're talking about extensions now
08:17:10 <merijn> I was referring to preferred syntax
08:17:21 <merijn> I remember the manual stating one syntactic form was preferred
08:17:24 <donri> merijn: neither is preferred, as i hinted at :)
08:17:40 <donri> the syntactic forms used to be separate extensions. only extensions are preferred/deprecated
08:25:09 <boothead> Anyone using emacs with haskell-mode, ghc-mod and cabal sandboxes together successfully?
08:25:40 <Taneb> My goal at the moment is to get my sprite-based game library (spriggan) to a point sufficient to where I feel willing to get into the next Haskell Community Report
08:26:26 <mm_freak> Taneb: please make it as pure as possible, otherwise you're making the life of FRP framework developers hard =)
08:26:53 <skypers> hi
08:26:57 <Taneb> mm_freak, alas, at the moment the API seems to make FRP framework developers as hard as possible
08:27:08 <Taneb> That is, it makes their work as hard as possible
08:27:12 <Taneb> And their life
08:27:18 <Taneb> It definitely does not make them hard
08:27:38 <external-reality> boothead, I am. It works amazingly well I and I am greatful for it.
08:28:30 <external-reality> *grateful
08:28:42 <Taneb> mm_freak, at the moment it's pretty much doing FRP itself (sort of)
08:30:39 <skypers> 17:11 < Taneb> mm_freak, alas, at the moment the API seems to make FRP framework developers as hard as possible
08:30:43 <skypers> which FRP lib?
08:31:19 <Taneb> skypers, any FRP lib. We're talking about sprite-based game lib I'm making
08:31:42 <skypers> I see
08:31:53 <donri> Taneb is saying his lib makes it hard for FRP libs, not that any particular FRP lib is too hard
08:31:54 <donri> IIUC
08:32:07 <Taneb> Yeah (also I don't know what IIUC means)
08:32:08 <skypers> oh
08:32:08 <skypers> ok
08:32:09 <conal> Taneb: have you read by paper on sprites & FRP? (http://conal.net/papers/padl99/)
08:32:15 <donri> if i understood correctly
08:32:15 <skypers> if i understand correctly
08:32:16 <skypers> I guess
08:32:18 <Taneb> conal, I have not
08:32:18 <donri> \o/
08:32:22 <skypers> \o*
08:32:32 <skypers> onoes, cut arm
08:32:34 <Taneb> conal, I'll give it a read, thanks for the link!
08:32:57 <skypers> do you think it’s a good idea to agregate polymorphic objects?
08:33:04 <donri> ⁵\o
08:33:08 <skypers> I experience the first issue of such a way to do
08:33:16 <skypers> I think I’m just wrong
08:33:19 <conal> Taneb: i got hundreds and sometimes thousands of frames per second on a 1998 PC in a Fran implementation using this technique.
08:33:25 <skypers> I’m going to post a paste, wait
08:33:30 <Taneb> conal, oh, wow :)
08:33:30 <boothead> external-reality, could you share the relevant bit of your config? My haskell-mode has stopped working properly since I added ghc-mod..
08:34:14 <conal> of course a continuous-time model was important.
08:34:30 <Taneb> conal, my lib at the moment uses a discrete time model
08:34:41 <conal> Taneb: :(
08:35:03 <Taneb> Although it shouldn't be too hard to change it
08:35:26 <Taneb> (actually, my lib atm doesn't have a time model. it's at quite an early stage)
08:35:28 <conal> Taneb: http://stackoverflow.com/a/5878525/127335
08:36:09 <conal> Taneb: and follow the links, especially in the second-to-last paragraph.
08:36:14 <Taneb> :D
08:40:49 <blochchain> what facets of haskell could be proved using induction?
08:40:59 <blochchain> ie fmapping, monads, etc.
08:41:05 <skypers> any one about that issue?
08:41:06 <skypers> http://lpaste.net/95665
08:41:37 <Taneb> blochchain, the correctness of virtually any recursive function
08:43:32 <skypers> donri: may you take a look?
08:44:09 <fizruk> skypers, newtype with 2 fields?
08:44:21 <skypers> yeah, data.
08:44:29 <skypers> fixed
08:44:56 <fizruk> skypers, it's not that constraints are different
08:44:59 <Taneb> conal, I'm on page three of your paper and already I'm rethinking quite a lot
08:45:03 <skypers> fizruk: well
08:45:07 <fizruk> skypers, it's `b`s which are different
08:45:10 <skypers> ghc says b band b1
08:45:12 <skypers> yeah
08:45:33 <fizruk> skypers, you may as well drop that constraint
08:45:34 <conal> Taneb: :)
08:46:08 <skypers> hm
08:46:09 <Taneb> Like, combining sprites into meta-sprites hadn't even occurred to me
08:46:13 <fizruk> skypers, registerBar claims to take *any* b as a first argument
08:46:51 <fizruk> skypers, but Manager has a list of *some* `b`s
08:47:04 <fizruk> oh sorry
08:47:11 <fizruk> i misread
08:47:43 <mm_freak> Taneb: if your library "sort of" does FRP, you could just as well base it on a real FRP library =)
08:47:49 <skypers> fizruk: maybe I need to move the constraint to the data head?
08:47:51 <fizruk> skypers, I thought Manager was existential :D
08:47:52 <skypers> but it’s hugly
08:47:58 <skypers> existential?
08:48:00 <Taneb> mm_freak, yeah, but then I've got the problem of choosing which
08:48:00 <fizruk> skypers, but it's the other way around
08:48:04 <mm_freak> Taneb: one that makes sure you're not doing something weird ;)
08:48:14 <skypers> Manager b?
08:48:22 <mm_freak> Taneb: can you sensibly split your scene rendering into discrete frames?
08:48:25 <fizruk> skypers, yes that will work
08:48:38 <skypers> yeah but I don’t want that
08:48:41 <Taneb> mm_freak, I think so
08:48:43 <skypers> I want Manager working with any b
08:48:51 <skypers> any b in the Bar class
08:49:01 <mm_freak> Taneb: if yes, AFRP (netwire or yampa)
08:49:12 <fizruk> then in registerBar pass (forall b. Bar b => b) :D
08:49:14 <skypers> I think I just can’t do what I want here
08:49:32 <skypers> why would it solve my problem?
08:49:34 <skypers> I don’t get it
08:49:41 <mm_freak> i haven't benchmarked yampa lately, but netwire on my PC reaches ~200M FPS
08:50:11 <fizruk> skypers, do you want bars to be a list of *possibly different* thing which have an instance of Bar?
08:50:36 <bgamari> The impedance mismatch between base and system-filepath is a real bummer
08:50:40 <fizruk> skypers, currently you have bars :: forall b. Bar b => [b]
08:51:06 <skypers> 17:34 < fizruk> skypers, do you want bars to be a list of *possibly different* thing which have an instance of Bar?
08:51:09 <skypers> yeah
08:51:13 <fizruk> skypers, which is for any b which implements Bar you can get a list of `b`s
08:51:15 <skypers> I’ll only use Bar’s function with that b
08:51:16 <skypers> so yeah
08:51:45 <fizruk> skypers, then you need existentials or a different approach to your problem
08:52:19 <fizruk> skypers, this will look like this: data AnyBar = forall a. Bar a => AnyBar a
08:52:49 <skypers> hm
08:52:58 <fizruk> skypers, and bars will be: bars :: [AnyBar]
08:53:12 <skypers> I just can’t do
08:53:17 <Taneb> mm_freak, I've used netwire before but I don't feel like it's right for this
08:53:24 <skypers> bars :: forall b . (Bar b) => [b] … ?
08:53:31 <mm_freak> Taneb: why?
08:53:35 <Taneb> Just a feeling
08:53:44 <fizruk> skypers, that's totally different from what you want :)
08:53:44 <mm_freak> based on …?
08:53:51 <Taneb> Literally nothing
08:53:56 <Taneb> I'll look into it, though
08:54:05 <skypers> arf
08:54:17 <skypers> so I need to create a wrapper data?
08:54:20 <skypers> there’s no other solution?
08:54:29 <mm_freak> Taneb: well, the non-A FRP libraries are more suitable for dealing with push-based applications
08:54:35 <Taneb> Like, the little line in my head going from spriggan to netwire is very thin and goes by "probably not"
08:54:37 <fizruk> skypers, it's not just a wrapper, you should read more about existentials
08:54:41 <mm_freak> like callback-based GUI toolkits
08:55:02 <mm_freak> for continuous framed applications AFRP is exactly the right abstraction
08:55:07 <skypers> fizruk: ok
08:55:10 <skypers> and hm
08:55:22 <skypers> nvm
08:55:25 <skypers> gonna try that
08:55:48 <skypers> I just wonder why it’s complicated to use polymorphic values
08:55:56 <fizruk> skypers, the other solution is not to use OOP in Haskell (which I meant by a different design)
08:56:16 <conal> mm_freak: what does pull-vs-push have to do with A- vs non-A ?
08:56:33 <skypers> yeah, I’m interested in another approach
08:56:42 <skypers> like, which one again? :D
08:56:58 <skypers> Manager b?
08:57:43 <skypers> the thing is, with a b, I can’t handle different Bar instances
08:57:45 <fizruk> skypers, perhaps it requires more knowledge of your problem domain
08:58:05 <mm_freak> conal: AFRP is inherently framed
08:58:07 <fizruk> skypers, perhaps you don't need Manager, Bar, etc.
08:58:25 <skypers> fizruk: hm no, I really need both
08:58:29 <mm_freak> conal: AFRP is based on the automaton arrow, which has a computation network that gets run in cycles
08:58:46 <skypers> thank you for your help, I’m gonna inquire a little deeper :)
08:59:08 <mm_freak> conal: push-based FRP is more like creating behaviors and events by registering callbacks
08:59:11 <Taneb> I think callback-ish things are probably more suited to this than arrows, but I need more time to think
08:59:28 <fizruk> skypers, ok, here's some info on existentials: http://www.haskell.org/haskellwiki/Existential_type
08:59:29 <conal> mm_freak: the original AFRP is about a denotation, not a representation. and the denotation was continuous
08:59:53 <mm_freak> conal: it is still continuous…  the implementation and the "outside" interface is discrete though
09:00:02 <skypers> fizruk: if there’re there to totally or even partially do “like in OOP”, I don’t want them
09:00:17 <skypers> I want an elegant an nice approach of my problem
09:00:30 <skypers> I need to review the problem a bit then
09:00:32 <mm_freak> conal: this is true for yampa and netwire at least, and i'm not sure if there are other arrow-based implementations
09:00:34 <fizruk> skypers, then you should state the problem :)
09:00:43 <skypers> yup fizruk
09:00:52 <merijn> skypers: Existential types don't exist to do OOP like things, but there is a common "existential anti-pattern" where people try to emulate OOP with them, though
09:00:57 <conal> mm_freak: iiuc, you're talking about implementation issues, none of which are inherent in classic or arrow-type FRP.
09:01:55 <mm_freak> conal: let me put it this way:  you would definitely use AFRP for gloss and push-FRP for vty-ui
09:02:06 <mm_freak> the difference in interface matters there
09:02:07 <skypers> ahah
09:02:21 <skypers> I think I can simply replace the (Bar b) => [b] by [Ptr ()]
09:02:28 <mm_freak> that's why the vty-ui FRP lib i'm working on uses reactive-banana and not netwire
09:02:35 <hamid> so when when doing "x <- monad" the x is always going to bind to the next clause ? right? we can't use this x 2 clauses after that?
09:02:56 <merijn> hamid: You can...
09:03:02 <S11001001> hamid: false
09:03:05 <skypers> the main idea (the true one) of my problem is that Bar is actually called MaterialProperties and has to define a function that outputs IO (Ptr ())
09:03:10 <skypers> I can then just use that value
09:03:12 <merijn> @undo do { x <- foo; bar foo; foo }
09:03:13 <lambdabot> foo >>= \ x -> bar foo >> foo
09:03:21 <merijn> eh
09:03:24 <merijn> I mean
09:03:28 <merijn> @undo do { x <- foo; bar x; foo }
09:03:29 <lambdabot> foo >>= \ x -> bar x >> foo
09:03:39 <skypers> hm, no actually, I would need offset and size, f**k it
09:03:48 <merijn> With the scoping of lambda this means that 'x' is visible in everything after the bind
09:04:03 <hamid> no i mean something like this :
09:04:08 <hamid> @undo do { x <- foo; bar ; foo x }
09:04:08 <lambdabot> foo >>= \ x -> bar >> foo x
09:04:15 <hamid> this is okay?
09:04:17 <merijn> Yes
09:04:24 <merijn> That's what I just meant
09:04:41 <merijn> 'x' will be in scope for everything inside the lambda (i.e. every statement following the bind)
09:05:26 <hamid> merijn, got it but something is a little mysterious for me :P
09:05:30 <hamid> like this
09:05:32 <hamid> @undo do y <- [1 .. 10]; guard (even x); return x
09:05:33 <lambdabot> [1 .. 10] >>= \ y -> guard (even x) >> return x
09:05:37 <hamid> wait
09:05:50 <hamid> > do x <- [1 .. 10]; guard (even x); return x
09:05:52 <lambdabot>   [2,4,6,8,10]
09:06:02 <hamid> > do x <- [1 .. 10]; y <- []; guard (even x); return x
09:06:04 <lambdabot>   []
09:06:07 <hamid> this ^ ?
09:06:14 <hamid> i'm using X here :|
09:06:32 <hamid> but it is binding Y to next closure
09:06:51 <mm_freak> conal: my usual terminology differentiates between scene-based applications and widget-based applications
09:06:55 <hamid> by closure i mean the guard function merijn
09:07:02 <mm_freak> for the former i recommend AFRP, for the latter push-FRP
09:07:03 <hamid> @undo do x <- [1 .. 10]; y <- []; guard (even x); return x
09:07:03 <lambdabot> [1 .. 10] >>= \ x -> [] >>= \ y -> guard (even x) >> return x
09:07:33 <merijn> hamid: lambda has the lowest binding, so this translates to
09:07:40 <conal> mm_freak: i see. did you know that the first AFRP application was GUIs?
09:07:54 <fizruk> @undo do { y <- []; return 1 }
09:07:55 <lambdabot> [] >>= \ y -> return 1
09:07:55 <merijn> hamid: [1 .. 10] >>= \ x -> ([] >>= \ y -> (guard (even x) >> return x))
09:08:03 <mm_freak> conal: and that probably motivated you to come up with push in the first place =)
09:08:16 <Eduard_Munteanu> Is there a way to make a singleton type for a function? Say I want to attach a function to a type.
09:08:19 <merijn> mm_freak: I believe push-FRP for GUI is a mistake
09:08:25 <merijn> mm_freak: push-pull is what you want
09:08:34 <merijn> mm_freak: So you can have timers independent of a push events
09:08:57 <merijn> mm_freak: Without busy-looping when rendering static scenes
09:09:01 <conal> mm_freak: my motivation for push wasn't GUIs
09:09:47 <merijn> mm_freak: Which is exactly the idea behind the Push-Pull paper (keep the possibility of pull, but optimise it away when behaviour only depends on push so you don't busy-loop unnecessarily)
09:10:28 <conal> mm_freak: push motivation was performance in general. GUI apps are often the least demanding. much less than the apps i designed frp for in the 90s.
09:10:39 <hamid> merijn, I understand what you mean. but that's how imperative _do_ style I thought would  work :/
09:10:58 <merijn> hamid: I don't understand what you mean?
09:11:20 <merijn> hamid: What did you expect it to mean and how is that different from what it actually means?
09:11:52 <hamid> merijn, here I expected this to use X in those (guard x) not Y
09:11:58 <hamid> merijn,  do x <- [1 .. 10]; y <- []; guard (even x); return x
09:12:00 * hackagebot thorn 0.1 - Template Haskell Library  http://hackage.haskell.org/package/thorn-0.1 (Kinokkory)
09:12:22 <merijn> hamid: Nothing uses y there...
09:12:47 <hamid> merijn, hmm so why it evalutes to [] ?
09:12:52 <hamid> > do x <- [1 .. 10]; y <- []; guard (even x); return x
09:12:54 <lambdabot>   []
09:12:59 <merijn> "[] >>= f" == []
09:13:03 <fizruk> do x <- [1 .. 10]; y <- "hi"; guard (even x); return x
09:13:09 <fizruk> > do x <- [1 .. 10]; y <- "hi"; guard (even x); return x
09:13:10 <lambdabot>   [2,2,4,4,6,6,8,8,10,10]
09:13:16 <merijn> hamid: So the guard is never executed
09:13:50 <hamid> merijn, oh! monad law :|
09:13:54 <yesthisisuser> What would be the best approach for implementing a Shell-like REPL with tab-complete etc. in Haskell?
09:14:12 <hamid> > do x <- [1 .. 10]; y <- [1]; guard (even x); return x
09:14:14 <lambdabot>   [2,4,6,8,10]
09:14:18 <hamid> lol :P
09:14:30 <skypers> MonadZero is great, yeah :)
09:14:31 <hamid> merijn, that's okay then?
09:14:48 <merijn> hamid: Yes
09:15:17 <deweyvm> im having a hell of a time parsing this grammar with parsec, is it actually difficult or have i gone astray?: T = "(" T ")" | T ("->" T)* | T T* | name
09:15:34 <deweyvm> i use lookahead to distinguish between T T and T -> T
09:15:53 <hamid> merijn, thank you. this really helped me to grasp the idea :)
09:16:29 <Eduard_Munteanu> Actually, I think I want to make a singleton type for arbitrary values.
09:17:20 <donri> Eduard_Munteanu: have you tried the singletons package / read the paper? i think it does this to some extent
09:18:00 <Eduard_Munteanu> donri: hm, no, I should look at 'singletons' again. What paper?
09:18:26 <Eduard_Munteanu> donri: nevermind
09:18:27 <mr-> yesthisisuser: haskeline I think
09:18:52 <og01> hello can I not define a type as data Level = 5 | 6
09:19:15 <Eduard_Munteanu> og01: no, you need constructors
09:19:35 <og01> Eduard_Munteanu: can you explain?
09:19:52 <Eduard_Munteanu> og01: besides, what do 5 and 6 mean? A level that can only be 5 or 6?
09:19:57 <og01> Eduard_Munteanu: yes
09:20:07 <fizruk> deweyvm, something like name <|> parens t <|> t <*> optional arrow <*> t ? with appropriate constructors?
09:20:11 <og01> Eduard_Munteanu: for reference i am on chapter 8 of learnyouahaskell
09:20:13 <Eduard_Munteanu> og01: you can do that with singleton types
09:20:17 <Eduard_Munteanu> og01: oh
09:20:27 <og01> Eduard_Munteanu: and am experimenting
09:20:31 <Eduard_Munteanu> og01: nevermind, you don't need to do that... you just want to define a value
09:20:53 <Eduard_Munteanu> og01: what were you reading in particular?
09:21:38 <yesthisisuser> mr-: thanks
09:21:58 <og01> Eduard_Munteanu: well im just trying to put into practice some of what i've learnt in general, I gave myself a challange to write a module that calculates various usable diskspace from various raid arrays
09:22:31 <Eduard_Munteanu> og01: oh, then you probably want data Level = Raid5 | Raid6
09:23:07 <Eduard_Munteanu> og01: because constructor names must start with an uppercase letter
09:23:27 <ParahSai1in> or a colon
09:23:54 <og01> I recall reading that yes, I think i was typing to constain the type while using Int as the type, i think the example in the book gave me that idea
09:24:16 <Eduard_Munteanu> ParahSai1in: I think in newer GHC versions you can use pretty much any symbols for type constructors, not sure about data constructors though
09:24:31 <Eduard_Munteanu> Type constructor operators.
09:24:38 <og01> Eduard_Munteanu: I will go with your suggestion, manythanks, and I think understand
09:25:30 <mr-> yesthisisuser: idris, agda, fay, pugs,... use that
09:25:45 <mr-> (darcs, also)
09:27:04 <Eduard_Munteanu> What would you suggest as a name for horizontal whitespace-separated "tokens" when parsing? Words?
09:27:49 <Eduard_Munteanu> They're not really tokens because an entire expression or line can be a "token".
09:27:53 <madariaga> the typeclassopedia, how haven't I found this before
09:28:14 <yesthisisuser> mr-: I am writing a simple command line application, but I want basic shell stuff like tab-completion and command history.. so this looks perfect
09:28:45 <deweyvm> fizruk: problem with that is it gets into an infinite loop trying t's. i need to make sure progress is made in every branch
09:30:36 <og01> Eduard_Munteanu: do i not have to define the types Raid5 and Raid6 ... aswell?
09:31:19 <Eduard_Munteanu> og01: those aren't types, they're data constructors
09:31:30 <Eduard_Munteanu> og01: Raid5 :: Level
09:31:42 <og01> Eduard_Munteanu: ah i think I know the problem (maybe) perhaps its that im not exporting them?
09:32:40 <Eduard_Munteanu> og01: what problem do you have?
09:33:13 <og01> Eduard_Munteanu: Not in scope: data constructor 'Level6'
09:33:33 <Eduard_Munteanu> og01: Raid5 and Raid6 are just names
09:33:38 <Eduard_Munteanu> og01: there's no Level6
09:33:44 <Eduard_Munteanu> Just Level.
09:34:00 <og01> Eduard_Munteanu: yeah this might be silly, I changed the names of things, onesec
09:35:07 <Eduard_Munteanu> deweyvm: let T = "(" T ")" | name, T' = T ("->" T')* | T T'*
09:35:08 <og01> Eduard_Munteanu: yes, I renamed it to Raid5, but typoed Level5 in part of the code
09:35:13 <og01> Eduard_Munteanu: thanks for your help
09:35:50 <Eduard_Munteanu> deweyvm: as you can see, making progress is pretty much equivalent to consuming input.
09:37:01 <deweyvm> Eduard_Munteanu: how do i get from T to T'?
09:37:30 <`^_^v> it requires adding the apostrophe
09:37:37 <mangaba_leitosa> Eduard_Munteanu: I was able to drastically optimize my app decreasing running time from like 2 minutes to < 1 second :_)
09:38:08 <Eduard_Munteanu> deweyvm: Ts = T' | T
09:38:23 <Eduard_Munteanu> mangaba_leitosa: nice, what did you do?
09:39:17 <mangaba_leitosa> Eduard_Munteanu: instead of generating all possible patterns (99% of which will not any words of my text anyway), I wrote a function for generating all possible patterns wit difference max_distance for each word of my text, and then picking the most frequently generated pattern
09:39:39 <mangaba_leitosa> Eduard_Munteanu: s/99% of which will not any words/of which will not match any words/
09:40:25 <Eduard_Munteanu> mangaba_leitosa: hm, I see... I suppose I hadn't understood your criteria.
09:40:32 <mangaba_leitosa> Eduard_Munteanu: e. g. for the word 'AAAA' and max_distance==1 :
09:40:32 <mangaba_leitosa> ghci> patterns 1 "AAAA"
09:40:32 <mangaba_leitosa> ["AAAA","AAAT","AAAC","AAAG","AATA","AACA","AAGA","ATAA","ACAA","AGAA","TAAA","CAAA","GAAA"]
09:41:53 <deweyvm> Eduard_Munteanu: i dont see how the string "(a -> b)" would parse in that grammar
09:45:15 <Eduard_Munteanu> deweyvm: "a -> b" = T' = T ("->" T') = name ("->" T ("->" T)^0)^1
09:45:36 <fizruk> deweyvm, how do you want "a -> b -> c" to be parsed?
09:45:39 <deweyvm> but with parens it just gets stuck in T forever
09:45:44 <Eduard_Munteanu> Since T* = {"", "T", "TT", ...}
09:46:02 <Eduard_Munteanu> deweyvm: ah
09:46:05 <deweyvm> by T* i actually mean (" " T)* sorry
09:46:39 <deweyvm> fizruk: just a list of types
09:46:52 <deweyvm> Arrow [a, b, c]
09:46:52 <fizruk> deweyvm, ok
09:46:55 <deweyvm> ill curry it later
09:47:06 * hackagebot thorn 0.1.0.1 - Template Haskell Library  http://hackage.haskell.org/package/thorn-0.1.0.1 (Kinokkory)
09:47:17 <Eduard_Munteanu> deweyvm: make the T between parens a T'
09:47:58 <Eduard_Munteanu> deweyvm: now it should be equivalent to your original formulation, except you always consume tokens
09:50:19 <haasn> What's the reasoning behind Text using UTF-16 internally (rather than, eg. UTF-8)? Just for O(1) access?
09:52:07 * hackagebot thorn 0.1.0.2 - Template Haskell Library  http://hackage.haskell.org/package/thorn-0.1.0.2 (Kinokkory)
09:52:37 <k00mi> haasn: Data.Text.index is O(n)
09:52:57 <haasn> oh, indeed
09:52:59 <haasn> Now I'm very confused
09:53:48 <quchen> haasn: Predictable memory usage?
09:53:49 <k00mi> haasn: the thing is, a single "character" (I don't know the correct term) can consist of several unicode code points or whatever they are called
09:53:56 <haasn> also, why is eg. length O(n)? Doesn't Data.Text.Text store an offset and length (in Word16) field internally? and isn't that the same as the number of Chars?
09:54:14 <haasn> k00mi: neither libraries deal with characters
09:54:45 <haasn> Char is a unicode code point and Text stores a scalar value
09:55:14 <haasn> (which is a subset of code points)
09:56:07 <haasn> in fact, Text can't hold all Chars due to this limitation (UTF-16 internally)
09:56:22 <haasn> and will replace them by the replacement character � (U+FFFD)
09:56:31 <fizruk> deweyvm, this seem to work http://lpaste.net/95668
09:57:16 <k00mi> haasn: anyway, I asked about the reason for UTF-16 a while ago in here and the answer was "historical reasons" and that UTF-8 was tested but had performance implications
09:59:30 <fizruk> deweyvm, also consider using Text.Parsec.Expr with operations "->" and " " (I didn't try that)
10:00:46 <haasn> Oh!
10:01:01 <haasn> UTF-16 is variable width. Hence my misconception
10:01:16 <Dodek> haasn: for instance, the character ó can be obtained in two ways
10:01:36 <haasn> I remember having that misconception before, thinking that UTF-16 worked like UTF-32 (but with fewer code points)
10:01:40 <Eduard_Munteanu> haasn: yeah, all UTF encodings should cover the entire Unicode
10:02:15 <Dodek> haasn: 1) you use a codepoint for this character 2) you use a codepoint for character o along with a codepoint for "character modifier" that adds an accent over o
10:02:44 <Dodek> haasn: these two use different number of octets in most encodings
10:02:56 <haasn> “The Unicode standard permanently reserves these code point values for UTF-16 encoding of the lead and trail surrogates, and they will never be assigned a character, so there should be no reason to encode them. The official Unicode standard says that all UTF forms, including UTF-16, cannot encode these code points. However UCS-2, UTF-8, and UTF-32 can encode these code points in trivial and obvious ways,
10:02:58 <haasn> and large amounts of software does so even though the standard states that such arrangements should be treated as encoding errors.”
10:03:14 <haasn> that makes sense
10:03:15 <Eduard_Munteanu> Is there a UTF-8 / ASCII-biased Text?
10:03:45 <haasn> It seems like the issue is that Char allows code points which are not legal in Unicode
10:03:59 <deweyvm> my formulation failed to take into account precedence
10:04:24 <deweyvm> (" " T)* should bind more tightly than ("->" T)*
10:04:29 <deweyvm> ill try it with operators instead
10:04:40 <haasn> oh, or maybe they are legal, but permanently unused
10:05:24 <byorgey> ~/win 9
10:05:25 <Eduard_Munteanu> I suspect Bytestring.Char8 should be used if you expect ASCII text?
10:05:31 <byorgey> oopsy
10:05:40 <haasn> Eduard_Munteanu: FSVO ‘should’
10:06:18 <Eduard_Munteanu> It's odd though... why would you make Text be UTF-16 by default?
10:07:00 <Eduard_Munteanu> It's nowhere near a standard.
10:07:24 <Eduard_Munteanu> I think it mostly gets used in certain Asian countries.
10:07:38 <tdammers> Eduard_Munteanu: much of Windows uses UTF-16
10:07:42 <Dodek> Eduard_Munteanu: utf-16 is used internally by windows everywhere
10:07:50 <geekosaur> also java, I believe
10:07:58 <geekosaur> but windows is the big one
10:08:13 <Eduard_Munteanu> Hm, I was thinking of www.
10:08:35 <Dodek> contrary to popular beliefs, there's a world outside of www.
10:08:53 <geekosaur> that said, didn't they do a benchmark utf8 / utf16 / utf32 and conclude that utf16 had the best overall performance?
10:09:00 <Eduard_Munteanu> Look out the Windows? :P
10:09:04 <haasn> geekosaur: I would be interesting in finding/seeing it
10:09:12 <arpunk> Dodek: www is just tcp/80/443 :)
10:09:38 <Dodek> geekosaur: i'd be surprised if that didn't strongly depend on your criteria for "overall performance"
10:09:42 <tdammers> IIRC windows actually uses UCS-2, which is UTF-16 minus the multi-word code points
10:09:51 <Eduard_Munteanu> geekosaur: I suspect many intensive tasks would benefit from ASCII though
10:09:54 <haasn> 443 is the “get shit through corporate firewalls” port :)
10:10:06 <geekosaur> well, it has been claimed. I don't know if we've seen the numbers ever
10:10:11 <tdammers> the choice was made in the brief time period when al of Unicode still fit inside a 16-bit encoding
10:10:32 <Dodek> Eduard_Munteanu: ascii is not really relevant these days
10:10:46 <tdammers> at the time, it seemed like the right thing to do - 16 bits ought to be enough for anyone :P
10:10:51 <fizruk> deweyvm, annotated http://lpaste.net/95668
10:10:52 <Eduard_Munteanu> Dodek: most code is written in ASCII for example
10:11:14 <Eduard_Munteanu> So things like compilers would benefit from shorter strings.
10:11:18 <tdammers> ascii is very relevant - it's the common subset of practically all 8-bit encodings and utf-8
10:11:31 <Dodek> Eduard_Munteanu: compilers must support non-ascii data as well
10:11:40 <quchen> It's also the set of characters every keyboard can type.
10:11:47 <Eduard_Munteanu> Dodek: yes, hence UTF8
10:11:54 <Dodek> my point was that if the code works only with ascii, it's fucked up big time.
10:12:11 <tdammers> consider XML - the XML declaration can tell you what the document's encoding is, but you have to parse *that* first
10:12:12 * hackagebot pdfinfo 0.1.3.3 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-0.1.3.3 (ChrisDone)
10:12:21 <Eduard_Munteanu> Dodek: no, but your dataset is likely 8-bit-sized wrt char widths.
10:12:34 * geekosaur finds a proposal writeup form 2011 about converting Data.Text ut use utf8 and benchmarking against the original... maybe that is what he remembered. (doesn't seem to have been followed up)
10:12:53 <deweyvm> fizruk: how does "a -> b c d -> e" parse? or just "a" ?
10:13:19 <Hodapp> ugh, UTF-16.
10:13:21 <geekosaur> oh, wrong, just had to find it. was gsoc
10:13:38 <Dodek> Eduard_Munteanu: you can as well assume that your data set is made only from letters A to K
10:13:40 <Hodapp> all the variable-width of UTF-8, and none of the compatibility.
10:13:44 <geekosaur> http://jaspervdj.be/posts/2011-07-10-text-utf8-initial-results.html
10:14:05 <geekosaur> dig out that gsoc and see what the outcome was?
10:14:17 <Dodek> Eduard_Munteanu: seriously, there's hardly a situation these days when you can be _sure_ that the only thing you need to support is 7-bit ascii characters
10:14:17 <fizruk> deweyvm, give it a try, that code compiles :)
10:14:43 <klugez> http://jaspervdj.be/posts/2011-08-19-text-utf8-the-aftermath.html
10:14:45 <fizruk> deweyvm, a should be App [Arrow [Name "a"]]
10:14:54 <Eduard_Munteanu> Dodek: sure, no, but you'd still optimize for the 8-bit case, that's what I meant by "hence UTF8"
10:15:17 <deweyvm> it should just parse to Name "a"
10:15:34 <fizruk> deweyvm, you can do that later
10:15:48 <geekosaur> I guess that would explain it, then
10:16:04 <Dodek> Eduard_Munteanu: frequently, yes. talking about ascii when you actually mean utf-8 is deeply misleading, though.
10:16:08 <cocon> @pl (\n (f,x) -> f n x)
10:16:08 <lambdabot> (`ap` snd) . flip fst
10:16:29 <deweyvm> a -> b (c d) should give Arrow [Name "a", App [Name "b", App[ Name "a", Name "b"]]]
10:16:56 <fizruk> deweyvm, that is how first code sample worked
10:17:04 <Eduard_Munteanu> Dodek: well, you can't really optimize for 7-bit charsets on usual CPUs :)
10:17:20 <deweyvm> instead it gives what looks like (a -> b) (c d)
10:17:43 <fizruk> deweyvm, i misread tighter for looser
10:17:56 <fizruk> deweyvm, first paste is the right one
10:18:00 <deweyvm> i may have misspoke
10:18:13 <cocon>  @pl (\n (f,x) -> f x n)
10:18:25 <cocon> @pl (\n (f,x) -> f x n)
10:18:25 <lambdabot> (`ap` snd) . flip (flip . fst)
10:18:30 <Eduard_Munteanu> > (lcm 7 8, lcm 7 16, lcm 7 32)
10:18:31 <lambdabot>   (56,112,224)
10:18:34 <haasn> klugez/geekosaur: thanks!
10:19:01 <fizruk> deweyvm, for "a -> b (c d)" I get Arrow [App [Name "a"],App [Name "b",Arrow [App [Name "c",Name "d"]]]]
10:19:11 <Eduard_Munteanu> The packing would be horribly slow anyway.
10:20:20 <Eduard_Munteanu> I wonder if there's such a thing as malleable compression, e.g. parse compressed data in a way that's related to the original.
10:21:18 <Dodek> Eduard_Munteanu: even if you're working with unicode, there aren't many optimizations you can do if you can assume that most of the stuff you'll be dealing with can be encoded in utf-8 using one octet
10:21:32 <Dodek> Eduard_Munteanu: you'll only save some space
10:22:03 <Eduard_Munteanu> Dodek: yes, there's nothing to optimize per se.
10:22:19 <Eduard_Munteanu> Just that most data fits 8 bits.
10:24:14 <donri> all data fits one bit
10:24:48 <Eduard_Munteanu> donri: that's just the proof data exists :P
10:25:11 <quchen> We can compress the data by specifying it to be 0, always.
10:25:36 <emaphis> just need a long key. :-)
10:25:42 <quchen> There we go, the universe now has divergent entropy. :-(
10:25:48 <donri> point is almost no data fits 8 bits. notably only a byte. but your point is you can use one byte to say what the next one means. the same is true for binary :)
10:26:05 <Eduard_Munteanu> Or swap the decompressor with the data. :P
10:26:54 <Eduard_Munteanu> donri: not all bytes are born equal, to nitpick :)
10:31:30 <klrr_> hey guys, i got an logical problem (or bug) in some dirty code i wrote while learning SDL, https://gist.github.com/klrr/7471610 it type checks and displays a white cube as intended, but using the arrow keys does not move it, anyone know what might be wrong?
10:32:38 <Eduard_Munteanu> klrr_: does pollEvent block until it receives an event?
10:34:54 <klrr_> Eduard_Munteanu: "Polls for currently pending events. " it says in the docs, using waitEvent :: IO Event might be better option? it's description is "Waits indefinitely for the next available event. "
10:35:30 <Eduard_Munteanu> klrr_: possibly, maybe it happens you miss the event and it's captured by the underlying window?
10:35:30 <klrr_> hmm waitEvent did not work either
10:36:28 <klrr_> Eduard_Munteanu: how do you mean?
10:37:39 <Eduard_Munteanu> klrr_: try printing something to stdout when you catch the event, to see if that's the issue
10:39:07 <klrr_> good idea!
10:40:02 <deweyvm> fizruk: +++ OK, passed 100 tests. ! amazing
10:40:21 <deweyvm> fizruk: any chance you could explain/point somewhere how you derived that?
10:40:27 <klrr_> it does get the events
10:40:49 <klrr_> so either something wrong with the IORef code or the drawing code
10:41:14 <Eduard_Munteanu> klrr_: mmm... does it move at all if you press a key a lot of times?
10:41:21 <Eduard_Munteanu> klrr_: not just keeping it pressed
10:41:22 <klrr_> (most likely IORef since it does draw a white cube even thought it doesnt move)
10:41:24 <fizruk> deweyvm, can you write a parser for an expression with int, + and * ?
10:41:31 <klrr_> Eduard_Munteanu: it does not move at all
10:41:47 <deweyvm> manually with recursive decent sure :P
10:42:28 <fizruk> deweyvm, because your problem is exactly the same with int -> identifier, "+" -> "->", "*" -> " "
10:42:31 <klrr_> gonna try rewrite it using recursion or State instead
10:42:46 <fizruk> deweyvm, see the point?
10:43:27 <deweyvm> my solution would look nothing like this though, i wouldnt have thought to parse names into Arrow [App [Name "s"]]
10:43:38 <Taneb> I'm thinking of doing sprite-clustering by having each sprite have a list of "subsprites"
10:43:38 <Taneb> But I want to enforce that a) no sprite can be a subsprite of itself, indirectly or directly
10:43:38 <Taneb> And b) each sprite can be a direct subsprite of at most one sprite
10:43:38 <Taneb> Another thought would be to use some sort of tree of sprites
10:44:54 <fizruk> deweyvm, try writing out a BNF for expression with int, +, * and BNF for your problem
10:45:18 <fizruk> my code is almost literally encodes that BNF
10:45:23 <Taneb> But then I'd have to force the sprites to only appear once
10:45:37 <Eduard_Munteanu> klrr_: maybe you need to call updateRect{,s}?
10:45:41 <fizruk> deweyvm, hence the types :)
10:46:18 <deweyvm> T = "(" T ")" | int | T "+" T | T "*" T
10:48:59 <klrr_> Eduard_Munteanu: gonna try
10:49:10 <dwcook> deweyvm, I don't know what you're using that for, but do you care that your grammar is ambiguous?
10:49:42 <deweyvm> dwcook: it should not be ambiguous
10:49:54 <dwcook> For example, T+T*T can be parsed as either (T+T)*T or T+(T*T)
10:50:07 <klrr_> Eduard_Munteanu: now it crashes xD
10:50:14 <deweyvm> fizruk: vs your T = A, A = ( P "->" ) *, P = ( name | "(" T ")" )*
10:50:28 <klrr_> hmm, i bet something is wrong with the IORefs tbh, i dont see what's wrong with the drawing code
10:51:02 <dwcook> Err, I should have used concrete numbers, but I imagine you get what I meant.
10:51:14 <dwcook> 1+2*3 is either 9 or 7.
10:51:14 <deweyvm> dwcook: yea
10:51:18 <fizruk> deweyvm, T = Summand { "+" Summand }*; Summand = Factor { "*" Factor }*; Factor = int | "(" T ")"
10:51:44 <deweyvm> but how did you get from one to the other
10:51:51 <fizruk> deweyvm, you mistyped my BNF also :p
10:52:17 <fizruk> deweyvm, just replaced symbols :)
10:52:19 <Jeanne-Kamikaze> all your curry are belong to us
10:52:27 <deweyvm> no i mean
10:52:43 <deweyvm> how did you get from T = "(" T ")" | int | T "+" T | T "*" T to T = Summand { "+" Summand }*; Summand = Factor { "*" Factor }*; Factor = int | "(" T ")"
10:52:46 <fizruk> deweyvm, you mean how i figured out what you meant?
10:53:24 <fizruk> deweyvm, it was rather obvious that you want some precedences (and it was rather obvious which precedences) :)
10:53:48 <deweyvm> what im asking is
10:53:51 <deweyvm> is there an algorithm
10:53:52 <deweyvm> to do this
10:54:20 <deweyvm> what procedure was used to get the latter from the former
10:55:50 <dwcook> The algorithm that fizruk used involved previous knowledge of mathematical conventions
10:56:10 <dwcook> (Among other guesses)
10:56:24 <modus> is this proof right?: a=b ∨ a=c ∨ b=c	(associativity) =	(a=b ∨ a=c) ∨ (b=c) ((1) context: assume (b=c) is a ⊤) =	(a=b ∨ a=c)	((2) context: assume (a=c) is a ⊤, using (2) and transitivity of =) = (b=c)	(using (1)) =	(b=c) = ⊤	QED
10:58:32 <modus> i think its not right because if someone gave me a ∨ a, i could assume a = ⊤, and then thus prove that a ∨ a = ⊤, when in fact it = a
10:58:47 <madariaga> class Functor (f :: * -> *) where ... -- This means the f type must have at least one type parameter, right?
10:59:02 <madariaga> or one and only one?
10:59:12 <dwcook> madariaga, f is a type constructor accepting a single concrete type
10:59:25 <madariaga> dwcook: in the likes of Maybe
10:59:30 <dwcook> Yes
10:59:42 <madariaga> is there any notion similar to "currying" for type constructors?
10:59:59 <dwcook> Sort of. You could use Either e as f, for example.
11:00:03 <madariaga> For example, the functor instance definition for Either is for "Either e"
11:00:19 <dwcook> > fmap (+1) $ Right 10
11:00:20 <lambdabot>   Right 11
11:01:00 <dwcook> @type fmap `asAppliedTo` Right undefined
11:01:00 <dwcook> Erm.
11:01:01 <lambdabot>     Couldn't match expected type `a0 -> b0'
11:01:01 <lambdabot>                 with actual type `Either a1 b1'
11:01:01 <lambdabot>     In the return type of a call of `Right'
11:01:11 <dwcook> Oh duh
11:01:33 <koala_man> in parsec, how do I get the column to use character counts rather than virtual columns (i.e. treat tab as 1 column)?
11:01:42 * dwcook tries to think of a similar function that takes such a type next, but fails
11:02:01 <madariaga> dwcook: that's alright, that's what I wanted to know
11:02:02 <madariaga> thank you
11:05:38 <fizruk> deweyvm, I guess you want to know how to write an unambiguous BNF for an expression with some operators with known precedence?
11:06:15 <fizruk> deweyvm, otherwise - what dwcook said :Ъ
11:06:42 <kuznero> Hi All!
11:06:56 <donri> > fmap (+1) `asAppliedTo` Right 10
11:06:57 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
11:06:57 <lambdabot>    arising from a use ...
11:07:03 <donri> :t fmap (+1) `asAppliedTo` Right 10
11:07:04 <lambdabot> Num b => Either a b -> Either a b
11:07:34 <fizruk> :t asAppliedTo
11:07:35 <lambdabot> (a -> b) -> a -> a -> b
11:08:24 <deweyvm> fizruk: yea, is there an algorithm? wikipedia just has a trick and my notes just say "rewrite" without saying how its done
11:08:36 <deweyvm> a parsing trick, no grammar
11:10:23 <quchen> asAppliedTo = const :: (a -> b) -> a -> a -> b
11:11:19 <fizruk> deweyvm, well basically you do it like so: A = B { op1 B }*; B = C { op2 C }*; C = ...; Z = basic_expr | "(" A ")" if all ops are associative and op1 binds looser that op2, etc.
11:12:14 <deweyvm> oh wow, much simpler than i would have expected
11:12:31 <deweyvm> thanks for the help
11:12:58 <fizruk> you're welcome :)
11:17:25 * hackagebot postgresql-orm 0.2.1 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  http://hackage.haskell.org/package/postgresql-orm-0.2.1 (AmitLevy)
11:17:50 <joelteon> isn't there a many1 to use with trifecta?
11:18:14 <joelteon> oh it's `some'
11:19:05 <wagerlabs> moin
11:19:16 <wagerlabs> anyone seeing this on mac osx mavericks? conduit-1.0.9 failed during the building phase
11:22:52 <bergmark> wagerlabs: that's not enough information to tell what the problem is, but conduit 1.0.9.1 is out so try that first
11:23:11 <wagerlabs> bergmark: cabal update?
11:23:15 <bergmark> yes
11:25:45 <wagerlabs> bergmark: it's a preprocessor issue
11:26:23 * geekosaur points to /topic
11:26:56 <cwraith> wagerlabs: is it the xcode 5 issue that is in the topic...  and geekosaur just mentioned?
11:27:11 <wagerlabs> yay, the latest conduit built
11:27:22 <wagerlabs> so conduit-1.0.9.1 is fine
11:27:34 * wagerlabs is back after ... ugh... 8 years?
11:27:51 <zaphix_> Any OS X users out there know the easiest way to get dynamic versions of the haskell platform libraries installed?  Was worried that --reinstall --enable-shared on a per-package basis might not be the right thing to do
11:28:48 <c_wraith> zaphix_: The easiest way to make sure it works correctly is to delete all the installed packages and start over.
11:29:29 <zaphix_> c_wraith: okay, that makes sense.  should i just start with a ghc binary and install the haskell platform manually from source then?
11:30:05 <c_wraith> zaphix_: Eh. I don't even bother with the platform unless I'm on windows, where it takes care of installing a ton of extra tools
11:30:11 <zaphix_> why shared libraries aren't present by default is beyond me
11:30:28 <zaphix_> c_wraith: fair enough. so just ghc binary + build cabal-install + go nuts with --enabled-shared?
11:31:19 <c_wraith> zaphix_: that's often the way I'd do it.  A couple of points though - there's an option to set that by default in cabal's config file, so you don't need to specify
11:31:36 <zaphix_> c_wraith: ah, yeah, i think i saw that somewhere. i'll make sure to do that.  thanks for the help!
11:31:45 <tarruda> has anyone here installed the lambdabot locally?
11:32:11 <c_wraith> zaphix_: and there's a cabal meta-package called "world" which means "everything I know that has been installed".  If you keep your old ~/.cabal directory, it should remain even if you wipe out your package databases
11:32:27 * hackagebot yesod-bin 1.2.4.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.4.1 (MichaelSnoyman)
11:32:39 <zaphix_> c_wraith: cool, thanks
11:35:56 <ski> wagerlabs : hello
11:39:07 <ski> modus : you didn't stay that long in ##logic ..
11:41:09 <ski> modus : anyway, i'm not even sure what you're attempting to prove, this time
11:53:33 <jrmithdobbs> is there a reason outside of convention that noone seems to store functions inside of record types? eg myFunc x@(MyType { paramFunc = f } = f x ; is it just that type classes can be used for most places where it'd be useful?
11:54:21 <jrmithdobbs> missed a ) before the = there but ya
11:58:02 <geekosaur> hm? functions in records is a fairly common idiom
11:58:04 <wagerlabs> why does cabal install hdevtools into /Users/joelr/Library/Haskell/ghc-7.6.3/lib/hdevtools-0.1.0.5/bin on mavericks and not ~/.cabal/bin
11:58:21 <geekosaur> it does that on all OS X versions
11:58:25 <wagerlabs> or to ask differently, how do i get cabal to install binaries in some central location?
11:58:32 <geekosaur> because it's complying with Apple's guidelines
11:58:44 <geekosaur> that said, it is supposed to symlink to ~/Library/Haskell/bin
11:58:46 <wagerlabs> geekosaur: do i need to manually softlink binaries somewhere else then?
11:58:54 <geekosaur> unfortunately I have never found it to do so reliably :(
11:59:01 <wagerlabs> i c
11:59:39 <wagerlabs> geekosaur: actually, it did do that but didn't tell me
11:59:53 <geekosaur> like, I can install 3 packages with binaries and only one of them gets symlinked. install 3 more, two of them gets symlinked. no rhyme or reason I've found :(
12:00:40 <benneh> I'm currently learning how 'tying the knot' works by implement my own doubly linked list class, but it seems very messy: http://pastebin.com/Vz07vsyT; do things like fmap have to be done like this, or is the previous (commented out) version fine?
12:00:48 <mauke> The paste Vz07vsyT has been copied to http://lpaste.net/95674
12:01:39 <benneh> mauke: thanks?
12:02:06 <mauke> welcome
12:02:37 <benneh> mauke: is lpaste preferred over pastebin for some reason?
12:02:44 <mauke> yes
12:04:34 <WraithM_> benneh: lpaste has hlint that pastebin doesn't do.
12:04:58 <donri> lpaste is clean, pastebin is riddled with ads? :p
12:05:02 <WraithM_> That too
12:05:02 <donri> and "features"
12:05:06 <mauke> lpaste is also not shit
12:05:06 <WraithM_> lol
12:05:18 <WraithM_> Not shit is good.
12:05:18 <jrmithdobbs> WraithM_: pastebin's syntax parser is also broken and you can break it easily with record syntax or gadts and a few other things
12:05:28 <jrmithdobbs> (with haskell specifically)
12:05:54 <WraithM_> lpaste can do Agda too, which is neat.
12:14:04 <jle`> how much of this static checking compile-time safety/assurance do i lose if i try agda?
12:14:45 <Eduard_Munteanu> jle`: um, none? Agda is even more fanatic about types. :)
12:15:02 <WraithM_> What do you mean? Agda has the ability to be way safer.
12:15:03 <geekosaur> agda should provide the same assurances. it also can provide static checking of more things... and won't let you defer it, or write something you can't prove statically
12:15:25 <fizruk> Taneb, do you need anything else for a pull request?
12:15:26 <jle`> that's good to hear
12:15:38 <jle`> when i first heard that types can depend on run-time i freaked out
12:16:18 <WraithM_> This is true, but the types are still checked.
12:16:37 <jle`> sounds interesting then
12:17:25 <geekosaur> well, types can depend on values, which sounds like run time. but in fact you have to provide *static* assurance of what values are possible, or Agda won't be able to type the expressions in question
12:18:43 <WraithM_> Also, functions must be total, which is a big deal.
12:18:45 <donri> no agda checks the types at runtime, but it does so using time travel so it knows how things turn out before they happen. duh.
12:18:51 <jle`> sounds like something worth looking into.  the recent community report has rekindled interest
12:19:21 <donri> idris deserves a mention too. it's a bit less cuh-razy / more practical
12:19:53 <donri> to be fair, the cuh-razy is half the fun of agda ;)
12:20:22 <WraithM_> Holes.
12:20:35 <tharper> truer words have never been written
12:20:37 <donri> idris has those too i think
12:21:08 <WraithM_> Yes, it does, and Haskell too, according to the community report.
12:21:23 <donri> haskell's are comparably weak though
12:21:28 <WraithM_> Yes.
12:22:14 <WraithM_> and certainly nothing like the agda-mode for emacs has been written for Haskell holes (or Idris holes)
12:22:47 <WraithM_> If there's anything like that for Idris, I'd love to know :D
12:24:50 <donri> vim-idris has similar stuff now
12:24:55 <donri> not sure just how similar though
12:25:02 <WraithM_> oooo
12:25:15 <donri> http://edwinb.wordpress.com/2013/10/28/interactive-idris-editing-with-vim/
12:25:24 <joelteon> can I provide a custom error message with trifecta?
12:25:26 <WraithM_> donri: Thank you :)
12:26:41 <ski> WraithM_ : Alfa had nice holes (mostly)
12:27:23 <joelteon> @tell edwardk how do you produce a custom error message with trifecta?
12:27:24 <lambdabot> Consider it noted.
12:28:00 <donri> @ask lambdabot is this the same as @tell?
12:28:00 <lambdabot> Nice try ;)
12:28:03 <donri> :(
12:28:05 <ski> @where Alfa
12:28:05 <lambdabot> Proof editor, using Agda1 proof engine/checker, at <http://www.cse.chalmers.se/~hallgren/Alfa/>,(broken) <http://www.cs.chalmers.se/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested>
12:28:05 <lambdabot> ,<http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz>,<http://ogi.altocumulus.org/~hallgren/untested/Source_code/alfa-050126.src.tar.gz>. Also see `
12:28:05 <lambdabot> Agda',`Fudgets',`GF'
12:33:01 <fizruk> joelteon, raiseErr?
12:33:37 <fizruk> joelteon, raiseErr (failed customMessage) ?
12:33:42 <joelteon> oh
12:34:21 <joelteon> no, i'll give an example here
12:34:22 <joelteon> that still doesn't work
12:36:00 <joelteon> http://lpaste.net/95676
12:36:29 <lpaste> joelteon pasted “trifecta custom error messages” at http://lpaste.net/95676
12:41:27 <fizruk> joelteon, could you provide readOct?
12:41:34 <scriptor> whatever happened to fay-lang's homepage
12:41:47 <joelteon> fizruk: import Numeric
12:41:48 <mauke> :t readOct
12:41:50 <lambdabot> (Eq a, Num a) => ReadS a
12:42:03 <scriptor> I remember it having an actual site (probably with github pages) but fay-lang.org just redirects to the wiki now
12:42:20 <frx> ReadOct is not a function, right? what is it?
12:42:29 <geekosaur> it is a function
12:42:32 <geekosaur> :t ReadS
12:42:33 <lambdabot> Not in scope: data constructor `ReadS'
12:42:39 <geekosaur> oops
12:42:43 <geekosaur> @src ReadS
12:42:43 <lambdabot> Source not found. Are you typing with your feet?
12:42:48 <geekosaur> hm, thought that was in there
12:42:49 <ski>   type ReadS a = String -> [(a,String)]
12:42:53 <geekosaur> ^
12:42:57 <frx> ah
12:43:02 <ski>   type ShowS = String -> String
12:43:06 <ski> @type showsPrec
12:43:07 <lambdabot> Show a => Int -> a -> ShowS
12:43:11 <ski> @type readsPrec
12:43:13 <lambdabot> Read a => Int -> ReadS a
12:43:47 <ski> > (readOct :: ReadS Integer) "103"
12:43:48 <lambdabot>   [(67,"")]
12:44:34 <ski> > (readOct :: ReadS Double) "103.1"  -- :(
12:44:36 <lambdabot>   [(67.0,".1")]
12:44:52 <fizruk> > (readOct :: ReadS Integer) "9640"
12:44:54 <lambdabot>   []
12:45:46 <Eduard_Munteanu> Is there a quick way to get Sing* instances for DataKinds-lifted datatypes, without the 'singletons' package?
12:47:22 <donri> Eduard_Munteanu: you either write them by hand or generate them. singletons does the latter
12:47:39 <Eduard_Munteanu> Hm, I see.
12:50:16 <frx> does Data.List export foldr and foldl? this works import Data.List hiding (foldr, foldl)
12:50:39 <Eduard_Munteanu> frx: it should
12:50:53 <frx> and Prelude does as well, but there's no conflict
12:51:00 <donri> frx: it does, but hiding will work even if it doesn't
12:51:02 <Eduard_Munteanu> frx: because they're the same
12:53:48 <frx> donri just tried, it has to be exported for you to hide it
12:54:01 <donri> frx: then you're on an old ghc :)
12:54:13 <frx> 7.4.2
12:54:19 <donri> yep
12:54:26 <frx> why was this changed?
12:55:13 <donri> it makes it easier to deal with changing APIs
12:55:46 <frx> if a module no longer exports the symbol that was hidden in earlier versions?
12:55:55 <donri> import Prelude hiding (catch)  -- will do nothing on ghc 7.6 where it isn't needed, and will do what you mean on older ghc where it might be needed
12:56:15 <donri> you still get a warning with -Wall though
12:56:26 <donri> >>> import Data.List hiding (batman)
12:56:26 <donri> Top level: Warning: Module `Data.List' does not export `batman'
12:58:02 <quchen> Oh, I thought hiding things does not generate warnings ever
12:58:20 <quchen> Good to know -Wall complains about it
12:58:46 <donri> quchen: it was an error before 7.6
12:59:07 <donri> and in the standards, still
12:59:17 <quchen> I found out about it when doing the AMP warnings
12:59:45 <quchen> Until now I thought it's a silent error, because the hidden thing is never even passed to the typechecker environment
12:59:57 <quchen> But apparently the parser (?) does some checking already
13:00:29 <quchen> Which is weird though, because it means that you can't parse a module without knowing its dependencies. Hmm.
13:00:34 <quchen> Maybe there's another intermediate step.
13:00:48 <donri> it's not a parse error
13:01:07 <donri> it probably runs in the renamer :)
13:01:24 <quchen> Oh right, the renamer comes before the typechecker.
13:01:38 <donri> but, you actually can't parse a module without first parsing all dependencies recursively :) at least not without an ambiguous parse tree
13:01:40 <donri> because fixities
13:01:52 <quchen> Oh, right
13:02:15 <donri> but i think that's in fact what is done. fixities are resolved in a separate step
13:02:31 <donri> and you kinda have to do that anyway because fixities can be local
13:02:53 <ParahSai1in> why doesnt it like IO CInt as return type of a foreing import ccall?
13:03:14 <joelteon> so I'm trying to design a Puppet-type tool with haskell. i have a manifest file like file somefile.txt { mode 0644; content "Hello world!" }. but I need to design it such that "file" is coupled with a function that converts a GenericDirective to a FileDirective, and ideally I'd like to make it extensible.
13:03:31 <joelteon> so people can install plugins and run the executable with plugin names as arguments.
13:03:37 <donri> ParahSai1in: works for me. what are you trying?
13:03:37 <cable729> I'm new to haskell and keep getting "parse error on input `import`", it is on line 6 of this file: https://github.com/cable729/plc2/blob/master/testsuite/tests/pacman/UtilsTests.hs
13:03:37 <joelteon> without having to recompile the whole thing
13:04:50 <ParahSai1in> donri: it just says "Unacceptable result type in foreign declaration: IO CInt" when i cabal install
13:05:07 <joelteon> I feel like using the plugins package for this purpose is overkill, BUT I don't know how else I would do it
13:06:51 <jedai42> cable729: that seems pretty strange, I don't think that's an haskell error at all, more probably you copied it directly (use Raw or the button to do that) and there's some extraneous spaces somewhere
13:07:28 <jedai42> cable729: or maybe some strange character ? How are you compiling this ?
13:09:47 <cable729> @jedai42 I'm using SublimeHaskell. I also tried using :l in ghci
13:09:48 <lambdabot> Unknown command, try @list
13:09:55 <joelteon> haskell is an awful language for this
13:10:19 <cable729> @jedai42 What's a good way to remove strange characters?
13:10:20 <lambdabot> Unknown command, try @list
13:10:37 <mauke> filter (const False)
13:11:45 <fizruk> :)
13:12:18 <jedai42> cable729: generally I would just delete import and some characters from the preceding line and retype them... But that's a pretty strange bug, probably not directly linked to Haskell though (except if that's a whitespace issue but I didn't see any)
13:12:50 <donri> cable729: you're using carriage returns where you should be using line feeds or both
13:13:52 <donri> cable729: are you on a mac predating OS X or something? :p
13:14:00 <donri> or do they still do that silly CR stuff
13:14:23 <benmachine> donri: I'm pretty sure that OS X follows UNIX
13:14:29 <benmachine> in line endings
13:14:34 <donri> yeah
13:14:37 <donri> CR:    Commodore 8-bit machines, Acorn BBC, ZX Spectrum, TRS-80, Apple II family, Mac OS up to version 9 and OS-9
13:14:41 <donri> are you on one of those systems? :D
13:14:48 <cable729> @donri I'm on Windows 8
13:14:49 <lambdabot> Unknown command, try @list
13:15:00 <jedai42> but shouldn't SublimeHaskell handle that correctly ? Besides I thought GHC handled all type of line termination ? Still seems a control character issue...
13:15:56 <donri> Jedai: it works if i convert it to LF
13:16:12 <joe9> is there any way to debug why I get this exception. program: http://codepad.org/t9nvRI9W error message: *** Exception: readProcess: FETCHMAILHOME=/home/j/etc/mail/mailconf/ fetchmail "--fetchmailrc ~/etc/mail/mailconf/fetchmailrc" "--verbose" "--startnum" "1" (exit 127): failed
13:16:13 <donri> cable729: check your sublime settings, it's being silly here
13:16:22 <cable729> I just used regex to replace \n with \r\n and that file is fine now
13:16:23 <joelteon> when trying to install haskell-src, I get "<built-in>:2:2: Not in scope: `#'"
13:16:38 <joelteon> I don't know how to debug this. I don't know what built-in is
13:17:02 <donri> cable729: well there was no \n in the file before. unless \n matches \r too...
13:17:27 <acowley> joelteon: That looks like a recent issue that's cropped up
13:17:34 <cable729> @donri you have to enable regex in sublime to search for \n
13:17:34 <lambdabot> Unknown command, try @list
13:17:37 <Jedai> donri: I think it does (in some regex engines at least)
13:17:37 <acowley> joelteon: Using an older version of happy is a fix
13:17:42 <joelteon> ok
13:17:46 <joelteon> how older?
13:17:53 <acowley> Not very
13:19:00 <joelteon> ok I can't build 1.18
13:19:00 <hamster007_> hey
13:19:15 <joelteon> but 1.18.11 might work
13:19:19 <joelteon> wow they love their patchlevel versions
13:19:21 <cable729> Okay, I got it working
13:19:28 <cable729> I'm not sure what corrupted my files
13:19:31 <acowley> joelteon: I'm looking for the bug report. I haven't hit this issue myself
13:19:49 <cable729> It might have been StylishHaskell
13:19:57 <Eduard_Munteanu> How do you declare SingE instances for a DataKind-lifted type with more than one constructor? :/
13:20:15 <cable729> I also noticed that it would add extra lines between each line once in a while, and sometimes these would pile up. Strange stuff
13:20:28 <donri> cable729: i mean there were no line feeds in the file, and \n doesn't normally match carriage return. i guess it does in sublime
13:21:25 <donri> cable729: presumably that extra line issue is related, maybe the file had a mix of line ending conventions
13:21:26 <Jedai> donri: Right, in Perl at least it doesn't
13:21:32 <cable729> there were \n in the file
13:21:46 <Eduard_Munteanu> Because I have  data Foo = Bar | Baz   instance SingE (Kind :: Foo) Foo where   fromSing SingBar = Bar   fromSing SingBaz = Baz
13:21:53 <Eduard_Munteanu> But GHC rejects that.
13:21:54 <cable729> Computers....... all I have to say
13:21:56 <cable729> :P
13:21:59 <donri> cable729: there were no 0x0A bytes in the file you linked, no
13:22:01 <Eduard_Munteanu> Not being able to unify Bar and Baz.
13:22:08 <acowley> joelteon: Here's the bug report I was thinking about, https://ghc.haskell.org/trac/ghc/ticket/8528
13:22:27 <acowley> joelteon: It might not be the same thing after all, and it was alex that the reporter rolled back rather than happy
13:23:03 <acowley> joelteon: Is Mavericks your OS?
13:23:08 <joelteon> yes
13:23:17 <acowley> joelteon: Have you done the basics to get GHC working?
13:23:26 <acowley> e.g. the clang wrapper or gcc-4.2?
13:23:28 <joelteon> yeah
13:23:33 <joelteon> i have the clang wrapper
13:23:36 <Eduard_Munteanu> donri: any idea if that's supported at all? ^  Sorry to bug you in particular, but you seemed to know a bit about this. :)
13:24:09 <tomejaguar> Eduard_Munteanu: Thanks for the TH help yesterday.  I now have working TH code :)
13:24:13 <cable729> @donri Huh, then I'm not sure. Magic fixed it :)
13:24:14 <lambdabot> Unknown command, try @list
13:24:28 <Eduard_Munteanu> tomejaguar: cool
13:24:33 <acowley> joelteon: carter is one of the most knowledgeable people on these issues, so you might want to ping him to see if he can say which specific variant of the Mavericks issues you're hitting
13:24:43 <carter> whats
13:24:45 <tomejaguar> cable729: Please don't prefix lines with @ because lambdabot thinks they are for him/her.
13:25:08 <acowley> carter: see joelteon's error message above
13:25:43 <joelteon> ok, if I use gcc-4.2, it builds properly
13:25:48 <acowley> fwiw, I'm using gcc-4.2 in my settings
13:25:49 <carter> yup
13:25:55 <carter> the issue is having gcc in your path point to clang
13:26:05 <acowley> so what's the deal with the clang wrapper?
13:26:06 <carter> builds the alex / happy using clang;s cpp
13:26:13 <acowley> I thought it was supposed to work
13:26:14 <carter> acowley: theres a reason why i dont reocmmend it
13:26:20 <carter> acowley: yes, for simple things
13:26:34 <acowley> I think I'm using the clang wrapper on one of my machines
13:26:56 <carter> i tried using clang for code gen and GCC for cpp, and i got weird bugs happen at link time a few times
13:27:06 <acowley> ugh
13:27:23 <acowley> did you see the changes I made to language-c to get it to work?
13:27:35 <Eduard_Munteanu> "Note that fromSing is overloaded based on the kind of the values and not their type---all types of a given kind are processed by the same instances."  -- I guess this means I can't just make multiple instances.
13:27:50 <Eduard_Munteanu> It would fail the kparam -> rep fundep too I suppose.
13:28:10 <acowley> I've never used happy before, and I don't know whatever spec the parser should follow, but at least now things move forward :/
13:29:35 <cable729> Can you tag people in here so they will get a notification?
13:29:45 <Eduard_Munteanu> cable729: like this?
13:30:03 <Eduard_Munteanu> cable729: don't do @cable729
13:30:11 <geekosaur> just mentioning their nick somewhere (usually at the start of the line) is enough
13:30:29 <geekosaur> conventionally followed by colon or comma
13:30:33 * ski keeps tabs on cable729
13:30:51 <geekosaur> also, some (rare) clients *only* notice it at the very start of a line --- which a leading @ does not give you
13:30:58 <Eduard_Munteanu> Some clients don't highlight unless the line starts with your nick, by default. E.g. irssi
13:31:02 * acowley keeps tabs on cable0-728
13:31:07 <carter> acowley: ?
13:31:29 * benmachine keeps spaces on ski
13:31:47 <hamster007_> I am trying to string together monadic actions dynamically; i know how to do that BUT I need to somehow preserve the niftiness of do notation where you can bind the result of an action to a variable and then that variable is available to subsequent actions
13:32:00 <hamster007_> does anyone "get" what I am saying
13:32:34 <acowley> carter: I replied to you on twitter the other day. I had to munge language-c to work with new funky headers on Mavericks. The issue is that c2hs depends on language-c, language-c is unmaintained, and the c2hs maintainers were unwilling to fix things. Thus many (most?) packages that use c2hs broke on Mavericks.
13:32:43 <donri> Eduard_Munteanu: i'd need more code and real error messages to say anything :)
13:32:58 <carter> wtf
13:33:08 <carter> acowley: is language-c a mainland product?
13:33:13 <acowley> carter: It can sneak up on you because if you upgrade to Mavericks, things keep working. It's only when you go to reinstall things that they break
13:33:22 <acowley> carter: I think he does a -quote version?
13:33:27 <carter> oh yeh
13:35:27 <lightquake> what's the necessary RTS options you need to pass to get the maximum memory usage of a haskell program?
13:36:01 <quchen> Compile with -prof, run with -P
13:36:10 <Eduard_Munteanu> donri: with 'data Type = Boolean | Tristate | Str | Hex | Int', GHC gives me "Couldn't match type 'Boolean with '{Tristate,Str,Hex,Int}" if I make the instance like: fromSing SingBoolean = Boolean; fromSing SingTristate = Tristate ; ...
13:36:50 <acowley> lightquake: -s
13:36:54 <Eduard_Munteanu> donri: where Sing* are the data constructors for the Sing Type data family
13:37:12 <Eduard_Munteanu> donri: actually, lemme pastebin it :)
13:38:33 <Eduard_Munteanu> donri: http://lpaste.net/95677
13:40:15 <donri> Eduard_Munteanu: isn't it supposed to be data instance Sing Type where SingBoolean :: Sing Boolean; SingTristate :: Sing Tristate; ...
13:40:31 <ski> Eduard_Munteanu : indeed. i just added a hilight for that ..
13:40:34 <Eduard_Munteanu> donri: hm, no?
13:41:00 <Eduard_Munteanu> ski: that's what I did too, but with your nickname it might become annoying :)
13:41:04 <donri> Eduard_Munteanu: i think it really is
13:41:39 <Eduard_Munteanu> donri: how am I suppose to define them though?
13:41:48 <Eduard_Munteanu> *supposed
13:42:07 <ski> Eduard_Munteanu : works fine with `/hilight -full -level publics,msgs,dcc,dccmsgs,wallpops,snotes,notices,actions,topics,modes,invites,parts,kicks,quits ski', so far (i've already tried asking)
13:42:24 <ski> (s/wallpops/wallops/ :)
13:42:50 <joelteon> is it possible to run a custom task when cabal repl is set up?
13:42:58 <joelteon> I need to compile a couple files and put their output in specific places
13:43:14 <ski> (the operative option being `-full')
13:43:18 <cable729> In HUnit, it says I can make multiple Assertions in a method. How do I do that? http://hackage.haskell.org/package/HUnit-1.2.5.2/docs/Test-HUnit-Base.html#t:Assertion
13:43:57 <Eduard_Munteanu> donri: oh, I misread, sorry. Well, no, those are types themselves.
13:44:12 <Eduard_Munteanu> donri: I want a Sing Boolean indeed.
13:44:18 <cable729> right now I've got this http://pastebin.com/36fmtXbb
13:44:22 <mauke> The paste 36fmtXbb has been copied to http://lpaste.net/95679
13:44:24 <Eduard_Munteanu> donri: think DataKinds
13:45:51 <Eduard_Munteanu> donri: and I want to relate types 'Boolean etc (of kind Type) to values Boolean etc. (of type Type).
13:45:56 <donri> Eduard_Munteanu: i know, but consider the canonical example of Nat and its singleton SNat
13:46:08 <joelteon> it doesn't look like Setup.hs is run before cabal repl is
13:46:38 <Eduard_Munteanu> Oh, I think I know what you mean.
13:47:14 <donri> Eduard_Munteanu: it doesn't work with your SigInt though, you need something of the Type kind or a separate Sing for that one
13:47:17 <Eduard_Munteanu> donri: should it be Sing Type, where Type is phantom for the kind Type?
13:47:30 <joelteon> oh, I have to use build-type: Custom
13:47:32 <Eduard_Munteanu> Hm.
13:47:43 <donri> Eduard_Munteanu: oh wait that's just a namespace issue here, hold
13:48:34 <Eduard_Munteanu> I don't see how, I get errors about the right sort of things.
13:49:17 <lpaste> donri annotated “Sing for multiple constructors” with “this type checks for me” at http://lpaste.net/95677#a95680
13:49:44 <Eduard_Munteanu> Oh, hm.
13:50:05 <Eduard_Munteanu> donri: do instances match on kinds too?
13:50:42 <donri> guess so :)
13:51:08 <Eduard_Munteanu> donri: thanks, it works here too
13:51:14 <donri> \o/
13:51:16 <carter> computionist: i can't even IRC, let alone web
13:51:35 <joelteon> we need a #cabal channel
13:52:00 <donri> Eduard_Munteanu: hah and i missed the comment
13:52:02 <Eduard_Munteanu> I think I've written kind-polymorphic instances before, I suspect I just didn't see it because of the concrete kinds.
13:52:09 <donri> this is my int. there are many ints like it but this one is mine.
13:52:26 <Eduard_Munteanu> :D
13:53:13 <Eduard_Munteanu> I see you had to disambiguate ut.
13:53:15 <Eduard_Munteanu> *it
13:54:59 <Athas> Is there a way to compress the .prof files generated by GHC to exclude boring information, eg. the thousands of call sites taking on 0% CPU and memory?
13:55:18 <lpaste> joelteon pasted “custom build steps” at http://lpaste.net/95681
13:55:23 <carter> Athas: use file compression?
13:55:26 <carter> :)
13:55:44 <carter> or munge it
13:55:57 <Athas> I'm thinking 'grep' if there's no proper solution, but really...
13:56:47 <Athas> I vaguely recall writing this regexp before...
13:58:48 <lightquake> on a scale of TypeSynonymInstances to UndecidableInstances, how evil is FlexibleContexs?
13:59:06 <joelteon> also, I don't understand the structure of HookedBuildInfo.
13:59:14 <joelteon> (Maybe BuildInfo, [(String, BuildInfo)])
13:59:16 <joelteon> it's not self-documenting.
13:59:36 <acowley> lightquake: Haskell2014
13:59:38 <Eduard_Munteanu> lightquake: outside that scale
13:59:55 <Eduard_Munteanu> lightquake: it's not evil at all, really
14:01:44 <Cale> It's slightly more work for implementors than TypeSynonymInstances would be, I expect, but yeah, not evil.
14:02:01 <haasn> since when are undecidable instances evil?
14:02:15 <haasn> they're completely safe, aren't they?
14:02:20 <ski> joelteon : seems there already is one ..
14:02:21 <Eduard_Munteanu> TypeSynonymInstances is evil, at least.
14:02:22 <joelteon> Actually, I need to run this code after build but before repl starts, so I guess I have to use multiple hooks
14:02:27 <joelteon> ski: one what
14:02:34 <ski> channel
14:02:39 <Eduard_Munteanu> Cale: why would it be more work, though?
14:02:44 <joelteon> oh
14:02:53 <joelteon> the one with 3 people and a broken link in the topic
14:02:59 <ski> (but probably not related to Haskell)
14:03:00 <Cale> haasn: They can make the compiler take forever
14:03:05 <Eduard_Munteanu> The kind of contexts you can write with it are rather sane.
14:03:05 <lightquake> hm. anybody in here good with the pipes library?
14:03:07 <joelteon> so
14:03:13 <joelteon> postBuild doesn't fire during repl startup
14:03:14 <lightquake> i'm running into performance issues in what should be really fast
14:03:17 <joelteon> postRepl is after the repl exits
14:03:20 <Peaker> UndecidableInstances switches the built-in highly-false-positive non-termination check for another built-in lower-false-positive non-termination-check (running it for a while)
14:03:32 <haasn> Cale: but once/if it terminates, the resulting code is perfect, isn't it? :)
14:03:43 <Eduard_Munteanu> Really?
14:03:58 <Peaker> GHC has at least one WONTFIX non-terminating compile bug
14:04:06 <Peaker> so it's probably not considered that big of a deal :)
14:04:12 <Eduard_Munteanu> Hm.
14:04:18 <joelteon> or is postRepl run after something else
14:04:23 <joelteon> because it takes some very interesting arguments
14:04:30 <Cale> haasn: Other than that, it's not a problem.
14:04:36 <Eduard_Munteanu> TBH, I don't find decidable typechecking much of a big deal.
14:04:46 <Cale> OverlappingInstances is where the evil begins
14:04:52 * ski . o O ( non-(termination-check) )
14:04:55 <joelteon> oh, nope
14:04:58 <joelteon> it's run after the repl exits
14:05:06 <Cale> (and IncoherentInstances makes that worse)
14:05:07 <joelteon> So this is going to be pretty complicated
14:05:20 <Eduard_Munteanu> If you run TH code then termination checking is out the window too, so that should be evil as well, no? :D
14:05:23 <donri> FlexibleInstances is also somewhat evil in that it leads to bad type inference
14:05:35 <Eduard_Munteanu> Er, provably-terminating type-checking.
14:05:36 <donri> but i don't think FlexibleContexts alone can do that
14:05:59 <computionist> carter: that's alright the web is a tool of oppression.
14:06:09 <runde> Parsec question. I'm writing a simple assembler and I'm struggling to be able to skip comments. The stuff on line 27 doesn't seem to work:  http://lpaste.net/9026126819132178432
14:06:17 <carter> computionist: why aren't you n #haskell-blah, you'd love it
14:06:49 <joelteon> oh, but replHook is run *before* the library is built
14:06:55 <joelteon> and postBuild doesn't run during the repl setup!
14:06:56 <zol> http://hastebin.com/recukuyoge.haskell -- The tautology function almost at the bottom, can it be written prittier?
14:07:00 <Eduard_Munteanu> runde: why optional?
14:07:01 <joelteon> this tool fucking sucks
14:08:05 <runde> Eduard_Munteanu: Because I would like to support both 'add r1, r1; comment' and 'add r1, r1 ; comment'
14:08:26 <runde> HEY, that might be a problem actually... :x
14:08:33 <Eduard_Munteanu> runde: I mean the optional before manyTill
14:09:42 <Eduard_Munteanu> runde: you probably want  space >> optional (char ';' >> manyTill ...)
14:09:51 <Eduard_Munteanu> runde: actually no
14:09:59 <Eduard_Munteanu> runde: 'space' skips newlines too
14:10:12 <runde> Oh really
14:10:20 <Eduard_Munteanu> Yes, any whitespace.
14:11:25 <Eduard_Munteanu> runde: I'd make a skipper parser that skips both whitespace and comments.
14:11:59 <donri> Eduard_Munteanu: btw the singletons stuff is gone from ghc.typelits in ghc 7.8 https://github.com/ghc/packages-base/blob/master/GHC/TypeLits.hs
14:13:02 <Eduard_Munteanu> donri: hm, is the user supposed to provide their own implementation / use 'singletons'?
14:13:26 <runde> Eduard_Munteanu: Instead of my eol-parser? (Which btw is the same as the one found in the CSV example in RWH)
14:13:28 <Eduard_Munteanu> runde: is ';' part of your comments syntax, or does it delimit statements?
14:13:37 <donri> Eduard_Munteanu: something like that i guess, yes. the way i understood it, singletons and ghc.typelits had diverged, and it wasn't really needed for the actual "type literals" per se anyway
14:13:41 <runde> Eduard_Munteanu: Comment start
14:14:05 <frx> foldl (-) 0 [1,2,3] -- this expands to (((0 - 1) - 2) - 3), right?
14:14:16 <mauke> > foldl (-) 0 [1,2,3] :: Expr
14:14:18 <lambdabot>   0 - 1 - 2 - 3
14:15:41 <perebor> hi, I'm new to haskell and I'm trying to count occurances of each n-length substring of a string (ngrams)
14:16:14 <perebor> I used a Data.Map String Int but I feel like the performance could be better
14:16:23 <Eduard_Munteanu> runde: then you should make a horizontal space parser, instead of 'space'
14:16:42 <runde> Yeah right.
14:16:43 <Eduard_Munteanu> runde: unless you allow things like  "mov a, b mov c, d"
14:17:01 <perebor> am I doing this right? Map.insertWith (+) (take n text) 1 $ buildMap (tail text n Map.empty
14:17:04 <skypers> perebor: Map is a balanced binary tree
14:17:37 <skypers> what are the inputs of your program?
14:17:42 <perebor> yeah, O(log n) is fine
14:17:45 <Eduard_Munteanu> perebor: you should look for a trie / radix tree
14:18:17 <Eduard_Munteanu> runde: then you can write comment in terms of that
14:18:18 <perebor> I'm doing some bioinformatics exercizes
14:18:38 <skypers> DNA stuff, right?
14:18:39 <perebor> basically counting n-grams from textfiles
14:18:47 <Eduard_Munteanu> I've seen at least 3 people doing something like that the last few days, I wonder if it's homework or something.
14:19:07 <perebor> there is a coursera course for bioinformatics algorithms right now
14:21:22 <perebor> so is it proper haskell to recursively populate a map the way I did
14:21:31 <perebor> ?
14:21:42 <identity> perebor: yes.
14:21:56 <Eduard_Munteanu> perebor: yeah... I'd use fromListWith though.
14:22:39 <perebor> thanks, I'll check that out. is there a Map-like datastructure that uses radix trees?
14:23:46 <runde> http://lpaste.net/3914224977854857216 - Eduard_Munteanu, I would think that should parse "nop ; comment\nnop" correctly, but I'm getting 'unexpected "n", expected end of line'.. :/
14:25:29 <runde> Hm, I didn't try the >>-stuff you said
14:26:17 <runde> Well, it should be equivalent I guess
14:26:21 <geekosaur> runde: because you handle end of line once in asmFile and once in the comment parser
14:26:47 <Eduard_Munteanu> Hm, good catch.
14:26:50 <runde> Does manyTill consume?
14:26:53 <geekosaur> so if there is a comment you effectively require two consecutive newlines, one for thje comment and one for `eol`
14:26:56 <Eduard_Munteanu> Yes.
14:27:08 <runde> Oh, thanks
14:28:08 <Eduard_Munteanu> runde: that 'optional' still seems odd, you only parse "nop ;" not "nop  ;"
14:29:28 <FreeFull> many spaces
14:29:42 <joelteon> wow
14:30:20 <Eduard_Munteanu> skipMany (char ' ')   rather
14:30:52 <Eduard_Munteanu> Because there's no other statement delimiter than '\n'.
14:30:59 <`cbp> hello, I'm reading haskell the hard way and when I do this: data Complex = Num a => Complex { real :: a, img :: a }. It tells me: Not in scope: type variable `a'. What am I doing wrong
14:31:19 <ski> `cbp : what are you trying to do ?
14:31:43 <carter> @tell tekmo thanks for the repping :)
14:31:44 <lambdabot> Consider it noted.
14:31:45 <Eduard_Munteanu> `cbp: data Complex a = Complex { ... }
14:32:02 <Eduard_Munteanu> `cbp: and put the Num constraint on your instances or functions
14:32:10 <Peaker> `cbp: Say you have a value of type "Complex", what "a" is inside it? Could it be any "a" at all, not knowable to whoever received a "Complex" value?
14:32:32 <`cbp> a would be the typeclass Num
14:33:00 <ski> `a' is a type (variable) not a type class
14:33:02 <Peaker> `cbp: "a" would be an instance -- not the type-class itself. But would it be some unknown instance? "Int", "Integer", "Float"?
14:33:18 <Eduard_Munteanu> Arguably that would work for some purposes.
14:33:34 <Eduard_Munteanu> But I doubt you want an existential 'a' there.
14:33:45 <ski> `cbp : the type variable `a' is not in scope. where should it come from ?
14:34:23 <runde> Wouldn't it be equivalent using many (char ' ') instead of skipMany (char ' ')?
14:34:27 <Peaker> `cbp: There are 2 possibilities here:  Either you want users of "Complex" values to know what the type "a" is -- and thus the "Complex" type must be "indexed" (a.k.a "parameterized") by it: Complex Int, Complex Double.   Or you want to say something like: A value of type Complex has some *unknown* instance of Num inside it. Complex = Complex (exists a such that ...)
14:34:53 <Peaker> `cbp: The latter is much less likely what you want, and less useful, so you probably just want to use: data Complex a = Complex ...  without the "Num" constraint there
14:35:11 <Eduard_Munteanu> runde: many gives you a list back, which could result in an error or warning depending on the case
14:35:14 <`cbp> mmm ok
14:35:32 <Eduard_Munteanu> runde: skipMany = void . many  really
14:35:37 <ski> Peaker : .. or, a value of type `Complex' contains two `a' for *any* type `a' in class `Num' :)
14:35:44 <Eduard_Munteanu> :t void
14:35:45 <lambdabot> Functor f => f a -> f ()
14:36:03 <Peaker> ski: Well, that's confusing because you can't tell if the "forall" is outside or inside the data constructor...
14:36:21 <Peaker> data Complex = forall a. Complex ...      vs.:  data Complex = Complex (forall a. ...)
14:36:33 <ski> well, you'd have to wrap in a pair or other similar thing
14:36:46 <ski> (the former is the existential)
14:37:17 <Peaker> yeah, what I mean is that I think I can interpret the sentence above ("for *any*") as either depending on mood :)
14:37:38 <ski>   data Complex = Rectangular (forall a. Num a => (a,a))
14:37:47 <ski> @where any
14:37:47 <lambdabot> http://www.vex.net/~trebla/weblog/any-all-some.html
14:37:56 <ski> Peaker ^
14:38:33 <Eduard_Munteanu> That's workable for some purposes too.
14:39:01 <Eduard_Munteanu> You can certainly make one, for example.
14:39:46 <Eduard_Munteanu> And you can apply operations on them. You could even get an answer if it was an Integral for example.
14:40:26 <ski> @let data Complex = Rectangular (forall a. Num a => (a,a))
14:40:26 <lambdabot>  Parse failed: Parse error: =>
14:41:51 <Eduard_Munteanu> > (0, 1) :: forall a. Num a => (a, a)
14:41:52 <lambdabot>   (0,1)
14:42:12 <Peaker> Eduard_Munteanu: since Num no longer subclasses Eq,Show, it is much less useful
14:42:24 <runde> Eduard_Munteanu: Thanks a lot! I got it working :-)
14:43:20 <Eduard_Munteanu> I wonder if fromInteger should be ripped out of Num.
14:44:13 <AVariedDeveloper> So I'm new to haskell, looking to get a feel for the best way to do concurrency between STM, channels, etc.  I'm going to have a UI (gtk2hs) which displays in real-time values read from a HID device via HIDAPI.
14:45:18 <AVariedDeveloper> Now, HIDAPI is blocking, and I don't want my UI to lock up between receiving data from the USB device, so I was planning to use a forkOS to poll the usb device for data.  Would STM be the best way to have data the UI can display in its update loop which is provided from the USB loop?
14:45:20 <ski>   Prelude> data Complex = Rectangular {unRectangular :: forall a. Num a => (a,a)}
14:45:36 <ski>   Prelude> instance Num Complex where Rectangular ri0 + Rectangular ri1 = Rectangular (case (ri0,ri1) of ((r0,i0),(r1,i1)) -> (r0+r1,i0+i1)); Rectangular ri0 * Rectangular ri1 = Rectangular (case (ri0,ri1) of ((r0,i0),(r1,i1)) -> (r0*r1-i0*i1,r0*i1+r1*i0))
14:45:52 <ski>   Prelude> unRectangular (let x = Rectangular (1,1) in x^3)
14:45:52 <ski>   (-2,2)
14:45:56 <ski> > (1 :+ 1) ^ 3
14:45:58 <lambdabot>   (-2.0) :+ 2.0
14:46:43 <ski> Eduard_Munteanu : seems to work fine
14:47:12 <quchen> Reading from a Chan is atomic, right?
14:47:23 <quchen> (System.Concurrent.Chan)
14:47:24 <Eduard_Munteanu> Sure.
14:47:35 <Eduard_Munteanu> I was going to suggest Chan.
14:47:38 <ski> Eduard_Munteanu : you could define `fromInteger :: Num a => Integer -> a' anyway, but it might be less efficient in some cases
14:47:38 <allsystemsarego> hello, which module contains the type Expr?
14:47:44 <Eduard_Munteanu> Although an MVar might do too.
14:47:48 <quchen> allsystemsarego: simple-reflect
14:47:58 <allsystemsarego> quchen, thanks
14:48:14 <quchen> Eduard_Munteanu: I've been hunting a bug for a month now so I'm trying all possibilities :-)
14:48:17 <Eduard_Munteanu> ski: how so?
14:48:52 <AVariedDeveloper> quchen: So the issue I noticed with Chan is that there isn't an easy way to clear it.  If for some reason the USB device starts sending data more quickly than the UI updates, I'd prefer to discard the intermediary values and use only the latest.  On the other hand, do chan's block if they are empty when being read from?  Because that would then slow down UI updates to the speed of USB reads
14:49:15 <quchen> AVariedDeveloper: Yes, Chans block.
14:49:25 <quchen> They're basically chained MVars.
14:49:27 <Eduard_Munteanu> AVariedDeveloper: you can use an MVar and tryPutMVar
14:49:29 <AVariedDeveloper> And same issue with MVar, it blocks if empty and reads one at a time
14:49:42 <ski> Eduard_Munteanu : `fromInteger 0 = 0; fromInteger n | n < 0 = negate (fromInteger (negate n)) | otherwise = fromInteger (n - 1) + 1' ?
14:49:50 <AVariedDeveloper> ah, tryTakeMVar combined with tryPutMVar could work
14:50:09 <ski> hm
14:50:13 <ski> @type \0 -> ()
14:50:14 <lambdabot> (Eq a, Num a) => a -> ()
14:50:20 <ski> right, you need `Eq' as well
14:50:31 <Eduard_Munteanu> AVariedDeveloper: I wouldn't do it that way.
14:50:37 <ski> hm .. no
14:50:44 <ski> just for `Integer', which we already have
14:50:52 <quchen> "n" patterns are desugared to "(== n) . fromInteger" I think.
14:51:18 <Eduard_Munteanu> AVariedDeveloper: you could spawn a thread to do the work once you receive an item
14:51:20 <ski> AVariedDeveloper : `SampleVar' ?
14:51:24 <AVariedDeveloper> Eduard_Munteanu:  Am I thinking about this the wrong way?  Basically, I don't want to limit the speed of the UI updates if its faster than the USB input, but I also don't want to build up a chain/ignore new USB inputs if that's running faster
14:51:27 <ion> @let data N = N; instance Num N where fromInteger _ = N
14:51:29 <lambdabot>  .L.hs:144:10: Warning:
14:51:29 <lambdabot>      No explicit method or default declaration for `+...
14:51:43 <ion> > case 42 of N -> "blah"
14:51:44 <lambdabot>   Not in scope: data constructor `N'
14:51:50 <ion> err
14:51:52 <ski> quchen : yes, i just realized it doesn't matter here
14:52:13 <ion> Tried it in ghci. The pattern match doesn’t require an Eq instance.
14:52:15 <ion> @undefine
14:52:16 <lambdabot> Undefined.
14:52:45 <ski> ion : and `Eq' is a superclass of `Num' in your GHCi ?
14:52:46 <quchen> AVariedDeveloper: Funny you mention it, I think your problem would also benefit from knowing how many elements are in a channel. I recently found out that TBQueue has the data, but doesn't expose access. I'll put your example on my list and in case I make a proper proposal it'll hopefully be some kind of a sales pitch. :-9
14:53:04 <acowley> AVariedDeveloper: I handle that situation in my concurrent fork of machines
14:53:05 <ion> ski: no
14:53:18 <acowley> AVariedDeveloper: But the code's in a bad state at the moment as it's full of misguided experiments :/
14:53:20 <Eduard_Munteanu> AVariedDeveloper: you have a few threads: one running the gtk2hs main loop, one that handles the device, and you can spawn a thread to update your GUI elements once you have some data to display
14:53:57 <acowley> I need to beat back the overgrowth and push useful pieces back to the mainline
14:54:29 <Eduard_Munteanu> AVariedDeveloper: I don't remember if gtk2hs is thread safe but you should be able to get some event into the main loop
14:54:30 <AVariedDeveloper> So my GUI is going to be running a game which updates physics at a constant frame-rate.  I want my USB inputs to me integrated into that physics smoothly.  It seems like if I spawn another thread to update my GUI elements that's like running an extra frame based upon when data comes in
14:54:37 <benmachine> ion: No instance for (Eq N) arising from the literal `0' over here
14:54:41 <AVariedDeveloper> Although maybe I'm still thinking about this too procedurally
14:55:01 <carter> acowley: Applicative is kinda amazing on statically sized lists
14:55:12 <carter> acowley: currently i'm yak shaving on the indexing data model
14:55:15 <carter> :)
14:55:16 <ski> carter ?
14:55:22 <Eduard_Munteanu> AVariedDeveloper: http://dmwit.com/gtk2hs/
14:55:24 <carter> ski: for a statically stized list
14:55:34 <ski> what do you mean by that ?
14:55:39 <AVariedDeveloper> acowley:  I know all about code getting full of misguided experiments
14:55:46 <carter> data Shape (rank :: Nat) a where
14:55:46 <carter>     Nil  :: Shape Z a
14:55:46 <carter>     (:*) ::  !(a) -> !(Shape r a ) -> Shape  (S r) a
14:55:49 <acowley> carter: Any examples yet?
14:55:53 <carter> acowley: soon
14:55:56 <ski> ziplist stuff ?
14:55:58 <Eduard_Munteanu> AVariedDeveloper: not really, Haskell threads are quite light
14:55:59 <carter> yes
14:56:01 <carter> stuff like that
14:56:04 <ski> ah, vectors
14:56:06 <carter> yes
14:56:08 <carter> well
14:56:15 <carter> vectors are something different for me :)
14:56:20 <acowley> AVariedDeveloper: The code is specifically designed to deal with different ends of the pipeline running at different rates
14:56:22 <carter> acowley: will have examples hacked out in af ew days
14:56:32 <Eduard_Munteanu> AVariedDeveloper: you could keep it alive if you make it read an MVar and update your state, blocking.
14:56:35 <ski> yeah, not in the sense of vector spaces / linear algebra :)
14:56:40 <carter> yeup
14:56:53 <ski> carter : any tensors ?
14:56:57 <carter> acowley: right now choosing the generic data model internally to make it harder to botch the inital release
14:57:07 <carter> ski: you mean 3dim or higher rank arrays?
14:57:10 <AVariedDeveloper> hmm, interesting.  Thank you
14:57:14 <ski> carter : any rank
14:57:18 <carter> ski: that static sized list stuff is so you can do any rank :p
14:57:28 <carter> but in practice I don't think you'll write code that does more than 6
14:57:35 <carter> everrrrrr
14:57:46 <carter> ski: do you have any examples that need more than 4dim arrays?
14:57:52 <carter> i've asked everyon
14:57:54 <ski> not really
14:57:57 <carter> the highest example i've found is 4
14:58:17 <carter> so i may at some point migrate to a data model that makes it harder to support like 20dim stuff
14:58:20 <ski> (but "any rank" seems simpler and nicer than "at most rank 4")
14:58:21 <carter> but will speciazie better
14:58:24 <carter> nope
14:58:29 <carter> really fucking hard :)
14:58:40 <ski> i mean conceptually, not to implement :)
14:58:50 <carter> "do what i mean "
14:58:53 <carter> simple conceptually
14:58:58 <carter> not practical in practices
15:00:30 <skypers> night
15:00:58 <xico> i need arrays with dims >6 every day :'(
15:01:35 <hpc> neat
15:01:42 <xico> (except sat-sun)
15:01:55 <elementz> hi all. it seems that my .cabal repository is seriously messed up. is there a good way to reset everything and start from scratch? this is on ubuntu 13.04
15:02:43 <carter> xico: really?
15:02:45 <carter> like
15:02:51 <carter> do you have actual examples
15:02:54 <carter> actually
15:03:16 <carter> i'm currently doing a data model where I can support higher dims
15:03:21 <carter> i just question it ever being useful
15:03:44 <elementz> could i simply rm -rf ~/.cabal and start from scratch?
15:03:46 <xico> trivial brain representation, where neurons are tuned for several features such as time, visual field position (x,y), speed, motion direction, local frequency, etc
15:04:28 <khyperia> This is what I get for abusing mdo... <<loop>> and I have no idea where it's from.
15:04:32 <carter> xico: those arent array dimensions.....
15:04:45 <xico> well they are in the code
15:04:57 <xico> it facilitates convolutions in different dimensions and such
15:05:04 <monochrom> elementz: read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove for how to "start from scratch". in fact, read the whole thing
15:05:04 <xico> for linear approximations
15:05:18 <carter> xico: are you really using 10 dimentsiona arrays
15:05:24 <carter> or 10 element rows in a matrix?
15:05:47 <carter> do you have examples you can show
15:05:53 <carter> so i can understand what you're doing
15:06:06 * ski wonders whether there's a name for linear maps `V₀ ⊕ V₁ ⊕ V₂ ⊕ ⋯ ⊕ Vₐ₋₁ ⟶ 𝕂'
15:06:42 <xico> carter: the convolution in any of those dimensions is a basic example where i need that
15:06:50 <carter> no
15:06:51 <carter> i mean
15:06:54 <carter> can you show me code
15:06:56 <carter> where you do this
15:06:57 <carter> by hand
15:06:59 <monochrom> khyperia: have you read http://www.haskell.org/haskellwiki/MonadFix ?
15:07:00 <carter> with explicit indexing
15:07:07 <carter> or what is it you're doing
15:07:09 <xico> carter: explicit indexing?
15:07:12 <khyperia> most of it, yeah
15:07:19 <monochrom> ok, then good
15:07:28 <Kaidelong> ski, what's that set? the complex numbers?
15:07:29 <carter> arr[i,j,k,l,m,n,o,p]
15:07:37 <carter> xico: i'm not talking about model dimension
15:07:44 <carter> i'm talking about "its a rank 10 tensor / arrray"
15:07:48 <ski> Kaidelong : any field (if you're talking about the codomain)
15:07:53 <acowley> xico: If you have a 2D array, then you can pull out individual columns, say, and work with them. But it's still a 2D array.
15:07:58 <carter> yes
15:08:07 <carter> acowley: thanks
15:08:18 <ski> (more specifically, the base ("scalar") field of the vector spaces in question)
15:08:35 <carter> acowley: i'm doing a generic indexing model right now, but may migrate to something thats harder to support higher dim in if the perf merits
15:08:42 <carter> doing the simpler one for now to prevent yak shaving
15:08:55 <xico> carter: http://codereview.stackexchange.com/questions/27249/implementing-recursive-filters-with-haskell-repa
15:09:06 <xico> carter: typical code that i use on any dimension of a repa array
15:09:21 <xico> (my first haskell code actually)
15:09:31 <carter> xico: ok
15:09:48 <carter> soooo, you want to convolve attributes
15:09:52 <carter> thats fine
15:09:59 <carter> that orthogonal to what i'm doing
15:10:02 <carter> talking about
15:10:10 <carter> "do you need rank >=6 indexing"
15:10:39 <carter> i'll support it for some stuff
15:10:56 <carter> but hoenstly i'm going to drop it the moment benchmarks show it creates perf problesm
15:10:58 <carter> problems
15:11:45 <elementz> monochrom: my god, the whole haskell packaging system seems to be an elaborate mess.
15:12:48 <carter> elementz: you should contribute to hackage-server or cabal or cabal-install to help fix it :)
15:12:48 <monochrom> I wouldn't say that. GHC faces contraints not faced by interpreters and gcc.
15:12:58 <carter> which constraints?
15:13:05 <carter> our own abi ? :)
15:13:09 <monochrom> cross-lib inlining
15:13:10 <xico> carter: i still fail to see how this is not a rank>6 array. except that this specific example is separable of course, some others involve several dimensions at the same time.
15:13:20 <carter> xico: i need exmaples
15:13:22 <carter> or i don't care :)
15:13:25 <carter> i will support it for now
15:13:30 <geekosaur> ghc's abi is certainly a complication that a package system can't do much about :/
15:13:39 <carter> but unless i see examples, its not something i care about
15:13:57 <monochrom> it is why I always say, "hugs has no such problem"
15:14:03 <carter> i'm aiming ot generally let people write code how they want
15:14:09 <acowley> I'm having trouble reading that code. carter, have you talked to the repa people for common use-cases they've heard of from their users?
15:14:24 <carter> acowley: images
15:14:31 <xico> lame :)
15:14:34 <carter> and 2d convolutions
15:14:40 <carter> repa is row major only too
15:14:45 <carter> which is crap for convolutions
15:14:48 <carter> no tiling
15:14:58 <acowley> That's not exactly uncommon
15:15:03 <carter> yeah
15:15:08 <carter> tiling would help
15:15:38 <monochrom> carter: if you build containers against your build of base, then your build of containers contains code from your build of base. now you can't switch base. you don't even have confidence in rebuilding base. this problem is not faced by most C libs.
15:15:50 <monochrom> and this problem is definitely never faced by interpreters
15:15:54 <carter> well
15:16:14 <carter> write a patch to fix it :)
15:16:23 <acowley> The thing is
15:16:27 <monochrom> therefore, for example, it is no use yelling "python doesn't have this problem", "ruby doesn't have this problem". hugs doesn't have this problem. are you going to use hugs?
15:16:33 <acowley> for 2d and 3d, you realistically use the GPU for array indexing
15:16:39 <acowley> and then you tile your threads
15:16:43 * ski used a rank 4 "tensor" for a maze in Matlab
15:16:43 <acowley> and everyone wins
15:16:44 <elementz> carter: this wasn't meant as a critique really. if i had the skills to help i would. but i am a mere user that wants to simply install a package [pandoc] (and keep it easily updated) without having to dive into the obscure ways of learning how ghc/cabal chooses manage packages... sometimes i'm just tired of having to deal with overly counterintuitive "interfaces"
15:16:52 <carter> elementz: you can learn :)
15:16:55 <carter> acowley: yeah
15:17:10 <acowley> elementz: I try to build most things in sandboxes these days.
15:17:12 <carter> acowley: I want to make the easy path the peformant path
15:17:19 <carter> yes, sandbxoes are awesome
15:17:43 <carter> acowley: hence why i'll likely not support higher than 6 dim ultimately
15:17:52 <carter> unless someone gives me an example that needs it
15:17:56 <carter> it'll be possible to ADD it
15:17:57 <carter> but
15:18:25 <monochrom> anyway, Dunning-Kruger. the less you more, the more opinion you have.
15:18:31 <acowley> I don't really understand where you're hitting a snag on increasing the dimensionality
15:18:37 <monochrom> err, s/the less you more/the less you know/
15:18:39 <acowley> <monochrom> the less you more, the more you less
15:18:46 <monochrom> haha
15:18:50 <elementz> i was just thinking about just dropping everything in a docker container and be done with it. but sandboxes might be an interesting solution. would this be a good reference on the matter? http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
15:19:00 <acowley> You are the Yogi Berra of #haskell
15:19:40 <carter> acowley: how i support interesting layouts gets …. weird, in higher dimensions
15:19:46 <acowley> carter: Is it just fitting things into registers?
15:19:51 <carter> well, that too
15:19:51 <acowley> oh
15:20:15 <carter> i mean, for rank k, theres 2^(k-1) morton orders and hilbert curves
15:20:22 <carter> so i'm only doing those in 2d and mebe 3d
15:20:52 <acowley> Well, you should just have a branch up front that drops you into a slow path if you are asked an awkward question
15:20:59 <carter> yeah
15:21:00 <carter> well
15:21:03 <carter> i'm doing that at compile time
15:21:09 <acowley> That's what most scientific computing code does, after all
15:21:21 <carter> by having those layouts and ranks handled as type classes you can specialize
15:21:25 <acowley> Got it
15:21:53 <carter> acowley: that actually suggests a hybrid approach I can do later
15:22:02 <carter> where I do the hlist/ sized list stuff for ranks > 2
15:22:07 <carter> and mono tuples for less
15:22:39 <carter> hrmm
15:22:40 <carter> i like this
15:23:54 <acowley> It would be nice to support code like xico wants out of the box, even if perf falls off a bit of a cliff
15:24:15 <acowley> At least that user could write their code, and maybe it would get faster later
15:24:19 <carter> yeah
15:24:22 <carter> i'm doing that approach for now
15:24:37 <carter> then i'll find out later if swapping to my crazy monomoprhic stuff i prototyped out would help perf
15:24:39 <acowley> Reading old GPU code is always depressing because of how many hoops people have to jump through to fit their problem to the available API
15:24:44 <`cbp> what is the triple colon for? (:::)
15:24:54 <carter> which lib?
15:25:14 <carter> acowley: so yeah, for now i'm doing to do the "might be slow, but repa does something like it" generic indexing model
15:25:20 <carter> with a strict sized list
15:25:28 <acowley> `cbp: It's usually used to be analogous to type annotation or list construction
15:25:29 <carter> slicing will not be using the syntax that repa does
15:26:13 <`cbp> I see
15:26:55 <carter> acowley: so yeah
15:27:00 <carter> i'm erring onthe forgiving size
15:27:01 <carter> *side
15:27:10 <carter> but if its the leading cause of slows
15:27:14 <carter> i'll have to change it
15:27:33 <carter> i just want examples of things people want to do that i worry may be bad perf wise
15:27:43 <carter> or just seemingly  "odd"
15:28:57 <xico> carter: are standard computations from standard calculus included?
15:29:05 <carter> what do you mean
15:29:08 <xico> in your representation?
15:29:08 <carter> explain your words
15:29:16 <carter> whats your question
15:29:41 <xico> carter: i the way tensor calculus entangle dimensions for computation
15:29:47 <xico> like in general relativity simulations
15:30:03 <carter> i need concrete links to reading
15:30:07 <carter> to understand what you mean / want
15:30:40 <carter> the likely answer is "not for now, but if you help me understand your goals, i can start thinking about how to do it nicely"
15:31:35 <carter> xico: ok?
15:32:04 <carter> i'm really keen on building a substrate everyone will happily default to using
15:32:15 <carter> though not everything will be there from the outset
15:33:50 <carter> xico: :)
15:34:08 <leroux> carter: I'm having a hard time mixing Double and Int...
15:34:17 <carter> leroux: eh?
15:34:18 <carter> context?
15:34:20 <leroux> Will I have to use a few fromIntegral's?
15:34:32 <leroux> Sec, I'll pastie.
15:34:46 <carter> whats the goal
15:34:46 <carter> ok
15:34:47 <carter> good
15:35:11 <leroux> carter: http://lpaste.net/570628092226174976
15:35:21 <leroux> Numerical integration.
15:35:23 <it3ration> hey folks, new to #haskell
15:35:40 <it3ration> starting through "Real World Haskell"
15:35:44 <leroux> Welome, it3ration. =)
15:35:52 <it3ration> stoked, i hate imperative languages
15:37:19 <ReinH> it3ration: hi :)
15:38:31 <Cale> it3ration: Welcome! Feel free to ask any questions you might have.
15:38:44 <carter> leroux: why are  you using ints for the range?
15:39:03 <carter> leroux: why are you using ints at all?
15:39:07 <leroux> It's a HackerRank problem.
15:39:19 <leroux> I can change it... but they won't input anything other than Int's.
15:39:20 <carter> leroux: just do it all as ints
15:39:21 <carter> until the ned
15:39:26 <carter> leroux: thats ok
15:39:33 <it3ration> will do folks :)
15:39:44 <carter> > (read  "3") :: Double
15:39:46 <lambdabot>   3.0
15:39:48 <carter> :)
15:40:05 <carter> leroux: tada
15:40:12 <carter> also
15:40:15 <carter> :t fromIntegral
15:40:16 <lambdabot> (Integral a, Num b) => a -> b
15:40:17 <leroux> Right.
15:40:19 <carter> well
15:40:20 <carter> hrmm
15:40:31 <carter> you'll need to have
15:40:50 <leroux> Yay, it works.
15:40:51 <carter> just do
15:40:56 <leroux> I just did all Double's
15:40:56 <carter> oh?
15:40:58 <carter> yeah
15:41:01 <carter> did it work work?
15:41:22 <leroux> Uhh, I just need to write the integration for volumes.
15:41:25 <carter> ok
15:41:34 <carter> you could have done all ints
15:41:39 <carter> and just convert as you return
15:41:46 <carter> if you were always doing integral volumes
15:42:26 <leroux> Well, how about l + 0.001?
15:42:33 <carter> heheheheheeh
15:42:36 <carter> dobules
15:42:39 <leroux> =)
15:44:52 <perebor> so I'm counting n-grams from a textfile. I have a python solution thats trivial and fast but I'm trying to learn haskell and my solution with Data.Map.fromListWith doesn't terminate for longer textfiles
15:45:21 <perebor> is it appropriate to use contents <- hGetContents handle to read a 4MB textfile into a string?
15:46:32 <benmachine> perebor: probably, yes, but there are better options
15:47:02 <benmachine> perebor: String is a very high-overhead type, the text library has a packed Text type that might suit your purpose better
15:47:03 <Eduard_Munteanu> perebor: yes, if anything, the problem is String performance-wise.
15:47:14 <merijn> "string" is always inappropriate for any type of file
15:47:30 <perebor> ok, that sounds right
15:47:37 <Eduard_Munteanu> Except for very short strings where you need access to individual characters.
15:47:38 <benmachine> Eduard_Munteanu: that seems a bit premature
15:47:47 <benmachine> 4MB is not that large
15:48:01 <merijn> perebor: Basically, String is a linked list of characters, meaning it can use as much as 24+ bytes per character on some architectures
15:48:42 <benmachine> merijn: "as much as 24+" meaning either less than, equal to, or more than 24? :P
15:48:50 <merijn> perebor: Text is datatype for compact blobs of text, it has an overhead of measured in bytes per kilobyte, rather than per Char
15:48:54 <merijn> benmachine: shush :p
15:49:47 <perebor> well my python solution isn't exactly on a memory diet either and it terminates.
15:49:58 <Eduard_Munteanu> BTW, which name would you prefer for a custom string type, KcString or StringKc? I've been leaning towards the 2nd lately, it makes things look less opaque.
15:50:12 <perebor> but the haskell implementation does work for smaller files
15:50:17 <dpwright_> when including the contents of a file using template haskell, is it possible to make "cabal build" rebuild when the file you're including changes?
15:50:19 <hpc> Eduard_Munteanu: why is it called KcString?
15:50:45 <Eduard_Munteanu> hpc: it stands for the Linux Kconfig type for strings
15:50:45 <acowley> Kansas City String
15:50:50 <acowley> oh
15:51:06 <hpc> i would probably do KcString
15:51:12 <hpc> it's a kernel config string
15:51:21 <acowley> String o' Kernel Config
15:51:30 <dcoutts_> dpwright_: there's a TH feature to say that you depend on a file
15:51:39 <dcoutts_> dpwright_: addDependentFile iirc
15:51:47 <Eduard_Munteanu> Yeah, that's what I've been using... but I noticed it makes the 'Kc' bit too visible.
15:51:51 <hpc> type KcString = Stringo'KernelConfig
15:52:12 <hpc> Eduard_Munteanu: it should be visible
15:52:22 <Eduard_Munteanu> Especially if not all my types / functions are prefixed that way.
15:52:29 <hpc> there's also precedent for such naming in GLint and GLfloat and such
15:52:37 <Eduard_Munteanu> Yeah.
15:52:40 <acowley> Yeah, I wouldn't bury the fact that it's related to Kernel Config
15:52:44 <acowley> lead with that info
15:53:06 * hackagebot simple 0.6.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.6.0 (AmitLevy)
15:53:10 <dpwright_> dcoutts_: Great -- thanks!
15:53:16 <Eduard_Munteanu> I personally find it a bit difficult to read "GLint", "IxMonad" etc.
15:53:19 <acowley> simple?
15:53:25 <carter> heh
15:53:40 <acowley> We need a name draft or something
15:55:32 <acowley> Eduard_Munteanu: For better or worse, most namespace systems are prefix rather than postfix
15:56:00 <hpc> i am not even thinking namespace, just the type name describing what it is
15:56:03 <acowley> Eduard_Munteanu: We have qualified imports in Haskell, and you have modules and packages in other languages where the context is a prefix
15:56:21 <Eduard_Munteanu> acowley: hm, good point
15:56:28 <acowley> hpc: Yeah, I agree with you, but that is perhaps subjective. I think the convention for namespace prefixes is less arguable.
15:57:24 <Eduard_Munteanu> Also, KcFoo seems more readable than KCFoo.
15:57:38 <Eduard_Munteanu> Even if Kc was a real initialism
15:58:02 * Eduard_Munteanu . o O (KFCoo)
15:58:23 <acowley> You have product placement in your code?
15:58:34 <joelteon> how do you perform splices in dec brackets for a data declaration?
15:58:38 <acowley> tacoBellLoComonad
15:58:41 <joelteon> I have a variable name
15:58:47 <joelteon> or rather, a variable `name'
15:58:57 <Eduard_Munteanu> acowley: I wonder if I should provide type synonyms String = KcString for use with qualified imports.
15:59:00 <joelteon> that I need to splice in. but $name is causing a parse error.
15:59:38 <joelteon> let name = mkName "Foobar" in [d|data $(name) = $(name)|] is a good minimal example.
15:59:48 <acowley> Eduard_Munteanu: Yeah, I sometimes think about doing things like that, but I don't think I ever have
15:59:53 <benmachine> Eduard_Munteanu: see also: HttpException
15:59:57 <acowley> Eduard_Munteanu: You could always copy Henning's style!
16:00:04 <benmachine> (re: KcString vs. KCString)
16:00:16 <benmachine> acowley: oh ew
16:00:18 <Eduard_Munteanu> acowley: oh... what is it like?
16:00:35 <acowley> benmachine: But it makes the question of what name to give a type much, much easier!
16:00:36 <benmachine> acowley: so, I use OCaml nowadays and it works there, but Haskell really doesn't like it so much
16:00:40 <acowley> Eduard_Munteanu: types are named T
16:00:51 <benmachine> acowley: the Haddocks are um
16:00:57 <acowley> The haddocks are hilarious
16:00:58 <benmachine> almost comically useless
16:01:17 <acowley> In a "makes you think about quitting the entire programming endeavour" kind of way :P
16:01:26 <benmachine> :P
16:01:41 <Eduard_Munteanu> acowley: I used that for some category theory stuff I did with DataKinds, since tracking the value, type, kind and sorts was getting tricky, and I added a letter to each thing :)
16:02:16 <Eduard_Munteanu> data CategoryK = CategoryT ...
16:02:27 <Eduard_Munteanu> where CategoryK was intended to be used as a lifted kind.
16:02:40 <benmachine> http://hackage.haskell.org/package/haskore-0.2.0.3/docs/Haskore-Composition-ChordType.html
16:02:44 <benmachine> note particularly toChord
16:02:59 <Eduard_Munteanu> LOL
16:03:11 <Eduard_Munteanu> I thought acowley suggested adding a 'T', not calling it 'T' :)
16:03:26 <benmachine> nope
16:03:35 <benmachine> the idea is qualified imports
16:03:39 <benmachine> so you get Chord.T and stuff
16:03:45 <benmachine> but haddock strips all of them
16:03:48 <geekosaur> T.T.T.T.T
16:04:13 <acowley> benmachine: http://hackage.haskell.org/package/gnuplot-0.5.1/docs/Graphics-Gnuplot-Frame.html
16:04:30 <acowley> Oh wait, http://hackage.haskell.org/package/gnuplot-0.5.1/docs/Graphics-Gnuplot-Graph.html
16:04:42 <benmachine> yep
16:04:43 <Eduard_Munteanu> benmachine: interesting
16:04:55 <benmachine> it doesn't help that there's no actual, y'know, docs
16:05:05 <Eduard_Munteanu> Makes me wish for first-class modules.
16:05:26 <acowley> benmachine: Yeah, that really seals the deal
16:05:27 <Eduard_Munteanu> I wonder how hard that'd be to implement.
16:05:38 <benmachine> Eduard_Munteanu: I wonder that too
16:05:42 <benmachine> OCaml and Agda both have them
16:06:04 <Eduard_Munteanu> Renaming-imports would be nice too in the meanwhile.
16:06:04 <benmachine> but those are both quite different languages
16:06:11 <benmachine> heh
16:06:22 <benmachine> anti-Henning imports?
16:06:24 <acowley> Coq and ML
16:06:32 <Eduard_Munteanu> I've had an issue where attoparsec's Parser type synonym got expanded to a huge name.
16:06:51 <Eduard_Munteanu> Even if I didn't use it.
16:07:34 <Eduard_Munteanu> Because certain functions used 'Parser Foo' and if I hid 'Parser' and used 'Parser Text Foo', it would talk about the synonym with a big package name in front.
16:16:26 <Eduard_Munteanu> I sort of wish we could import pragmas too, hm.
16:16:50 <Eduard_Munteanu> Not sure you can do it even with CPP.
16:18:10 * hackagebot simple-session 0.6.0 - Cookie-based session management for the Simple web framework  http://hackage.haskell.org/package/simple-session-0.6.0 (AmitLevy)
16:18:12 * hackagebot simple-templates 0.6.0 - A basic template language for the Simple web framework  http://hackage.haskell.org/package/simple-templates-0.6.0 (AmitLevy)
16:23:10 * hackagebot simple-postgresql-orm 0.6.0 - Connector package for integrating postgresql-orm with the Simple web framework  http://hackage.haskell.org/package/simple-postgresql-orm-0.6.0 (AmitLevy)
16:30:15 <Entroacc1ptor> how is simple simpler than happstack?
16:33:46 <hpc> > length "simple" < length "happstack"
16:33:48 <lambdabot>   True
16:36:17 <Entroacceptor> ah, how silly of me
17:01:45 <general-general> Hello.
17:02:05 <general-general> Anyone want to speculate as to the number of Haskell programmers in the world?
17:02:13 <joelteon> why isn't there a monadic analog of fold?
17:02:16 <joelteon> foldM isn't the same, isn't it?
17:02:17 <joelteon> is* it
17:02:20 <general-general> From beginners who are active through to experts.
17:02:29 <general-general> Just curious.
17:02:33 <Peaker> general-general: "programmer" = "someone using it for real projects" or "someone who can write some Haskell"?
17:03:17 <Peaker> very rough, unbased speculation: maybe 10K's of people who know at least a tiny bit of Haskell?
17:03:33 <general-general> I would include anyone actively learning it... beginners who are moving toward advanced beginners or intermediate.
17:03:41 <general-general> Interesting
17:03:46 <general-general> My guess was 50k total
17:04:44 <monochrom> joelteon: I would say foldM is fold enough.
17:05:06 <general-general> Likely 10k or 5k would actually know how to do something that would serve a purpose for some non-programming people, as in most likely a web app.
17:05:13 <monochrom> but "analog" is always undefined
17:05:18 <ion> There is only one Haskell programmer in existence. You see multiple because it moves back in time occasionally (you observe that as a PHP programmer).
17:05:35 <general-general> Funny.
17:05:42 <general-general> I like that idea.
17:05:56 <general-general> Reminds me of that Eno guy.
17:06:02 <general-general> Musician.
17:06:28 <hpc> ion: there are many haskell programmers, but sharing optimizes them down to just edwardk
17:06:51 <sm> has anyone managed to install cairo on osx+brew ?
17:07:12 <sm> the cairo package on hackage
17:07:26 <general-general> Anyway, thanks for the replies.
17:07:35 <geekosaur> sm: I have had it installed on osx+macports. if you have xcode 5, see the /topic to make it not cause weird preprocessor errors
17:07:37 <general-general> :)
17:08:28 <sm> I keep having to install and link more brew packages, and there are some with different names it still can't see. There must be a better way
17:09:29 <geekosaur> not without teaching cabal how to interface with N different external package managers with sometimes widely divergent names for various packages (and sometimes additional dependencies)
17:09:49 <chrisdotcode> is there any significant reason haskell uses a !!n instead of a[n]?
17:10:27 <ion> chrisdotcode: (!!) is just a function, a[n] would require syntax.
17:10:34 <chrisdotcode> ion: oh, that makes sense.
17:10:41 <chrisdotcode> is there any reason they didn't choose to include that syntax?
17:10:49 <khyperia> It's not very commonly used.
17:10:50 <ion> (!!) is used very, very rarely.
17:11:04 <geekosaur> because indexing linked lists is not something that really should be encouraged?
17:11:10 <monochrom> I don't like built in syntax
17:11:23 <chrisdotcode> yeah, I figured. because this is the first time I'm using it in a while, and I was wondering why it was so ugly.
17:11:28 <monochrom> it is not like we need built in syntax for "forever" either
17:11:29 <ParahSailin> that would be difficult syntax to add in
17:11:34 <ion> I like some built in syntax. For instance, i like do notation.
17:11:48 <monochrom> ugly? you get it all wrong. adding syntax is ugly.
17:11:49 <geekosaur> who's got liquidhaskell? :p
17:12:00 <absence> when working with lots of integers, i find it reasonable to convert them all to the same type to avoid littering the rest of the code with fromIntegral. but what's the most reasonable intermediate type? Num? Integral? Integer? Int? Int32?
17:12:28 <chrisdotcode> ion: I agree! but (!!) isn't so hot on the eyes, either.
17:12:41 <geekosaur> if you don't have a reasonable cap on the size, probably Integer
17:12:49 <geekosaur> also Num is not a type
17:12:54 <geekosaur> nor is Integral
17:13:02 <monochrom> ok you're just arguing subjective preference
17:13:18 * hackagebot purescript 0.1.9 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.9 (PhilFreeman)
17:14:03 <geekosaur> and in fact they buy you nothing whatsoever here because you'd still have to fromIntegral something with an Integral constraint, and Num constraint removes your ability to use fromIntegral
17:14:31 <monochrom> @let monoa = length
17:14:32 <lambdabot>  Defined.
17:14:37 <monochrom> > monoa[4]
17:14:45 <lambdabot>   mueval-core: Time limit exceeded
17:14:51 <monochrom> > monoa[4]
17:15:01 <lambdabot>   mueval-core: Time limit exceeded
17:15:06 <monochrom> oh well
17:15:33 <chrisdotcode> monochrom: yeah, you're correct; I honestly can't think of a better solution either. "index as a function" is awfully elegant, though
17:15:48 <chrisdotcode> I remember i used to hate ($) as well, but now it's decent looking
17:15:51 <absence> geekosaur: ah, that rules out Num. why do i have to use fromIntegral with Integral though?
17:15:59 <lpaste> Cale pasted “Complex square root demo” at http://lpaste.net/95683
17:16:02 <geekosaur> because Integral is not a type
17:16:11 <geekosaur> it is a constraint which allows you to use fromIntegral
17:16:18 <Cale> If tac shows up and I'm not around, link him to that :)
17:16:26 <geekosaur> (and a handful of other things)
17:18:36 <khyperia> What's a good way of running a preprocessor on code? I'm creating a language, and I'd like declarations like infixl/infixr, but that requires all precedence commands to be parsed before any expressions are parsed.
17:19:03 <khyperia> So I think a preprocessor style thing would be good, with the precedence commands removed before normal parsing
17:19:19 <Cale> khyperia: I believe the way that GHC handles infixl/infixr is to not worry about correctly associating operators and to fix the association after parsing.
17:19:36 <c_wraith> ...  I guess that works so long as it does it before the type checking.
17:19:46 <finishingmove> what's the common way of managing project-level dependencies in haskell projects?
17:19:59 <Cale> finishingmove: cabal?
17:20:24 <finishingmove> Cale, yeah, but doesn't it install libs globally on the system?
17:20:31 <khyperia> So essentially just store the big jumble of lexemes, and then once it's in AST form, resolve all of 'em?
17:20:38 <finishingmove> what if i need different versions of a library
17:21:16 <Cale> Well, it installs them user-locally. You can easily have different versions of the same library (though it's probably not recommended), however if you need different builds of the same version, that becomes a problem.
17:21:27 <Cale> There are a bunch of sandboxing tools
17:21:32 <Cale> cabal-dev is one of them
17:22:09 <Cale> istr cabal-install itself was going to get support for sandboxing, that might already be in, I haven't checked.
17:22:34 <chrisdotcode> hey guys, did I accidentally do something to fpcomplete? I searched (>>=) on their hoogle, and now I can't even load the homepage...
17:22:42 <absence> geekosaur: hm.. i know Integral allows me to use fromIntegral, but i'm  not sure i have to. a function :: Integral i => i -> i seems to be able to do calculations without fromIntegral
17:22:44 <Cale> finishingmove: But independently of that, cabal (the library) defines a .cabal file format for specifying project-level dependencies
17:22:44 <monochrom> in version 1.18, released.
17:23:04 <khyperia> loads fine for me, chrisdotcode
17:23:09 <chrisdotcode> khyperia: okay, good...
17:23:15 <finishingmove> hm ok, thanks, Cale
17:23:43 <geekosaur> absence: it does, but if you then want to use ```Integral i => i -> i -> i``` to combine two values in some way, it forces those `i`s to be the same type (not merely both Integral)
17:24:32 <geekosaur> and you can't pull off ```(Integral i, Integral j) => i -> j -> i``` without using fromIntegral on the second parameter. (or for i -> j -> j, on the first)
17:24:42 <geekosaur> because a typeclass is not a type
17:25:24 <joelteon> how do you set file permissions using haskell
17:25:36 <absence> geekosaur: oh right, and then i might be Int8 so all the calculations overflow :s
17:26:13 <monochrom> System.Directory may have something
17:26:35 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/directory-1.2.0.1/System-Directory.html#v:setPermissions
17:27:11 <geekosaur> be aware that this interface, through trying to be portable, will be limited; if you know the target platform, you may want to use POSIX or Win32 functions
17:27:23 <absence> is Int 32-bit in ghc?
17:27:39 <monochrom> sometimes
17:27:59 <geekosaur> depends on the platform
17:28:30 <simpson> I think it's guaranteed to have 27 bits?
17:28:37 <geekosaur> it will generally be either 32 or 64 bits in ghc
17:33:40 <absence> too bad so many library functions take Int instead of Integer
17:34:08 <monochrom> 20 bits ought to be enough for 286 :)
17:36:19 <tarruda> @src Maybe
17:36:19 <lambdabot> data Maybe a = Nothing | Just a
17:36:32 <tarruda> @src Maybe.fmap
17:36:32 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:36:47 <tarruda> @src fmap
17:36:48 <lambdabot> Source not found. Are you typing with your feet?
17:37:15 <khyperia> @src Maybe fmap
17:37:15 <lambdabot> fmap _ Nothing       = Nothing
17:37:15 <lambdabot> fmap f (Just a)      = Just (f a)
17:37:26 <tarruda> thanks
17:38:38 <tarruda> I've installed the lambdabot locally, but still couldn't get it to display sources(Plugin `sourcePlugin' failed with: state not initialized)
17:38:47 <tarruda> does someone knows how to fix this?
17:39:19 <absence> is there something like fromIntegral that can fail if the conversion results in overflow?
17:39:20 <geekosaur> do you have its database in the State directory?
17:39:38 <tarruda> geekosaur: no, how do I build it?
17:39:40 <geekosaur> absence: no. and yes, people have complained about this before.
17:40:14 <geekosaur> tarruda, used to be that lambdabot came with a sample State directory with various databases in it. I haven't looked recently
17:40:33 <tarruda> all I did was 'cabal install lambdabot'
17:41:13 <absence> geekosaur: i see. rolling my own shouldn't be a problem anyway
17:41:22 <geekosaur> mmm, not sure cabal install puts the State db anywhere useful. it's in the source package, try `cabal unpack lambdabot`
17:41:48 <geekosaur> there should be a State dir in the directory created by that
17:42:05 <geekosaur> and one of the databases it holds is `source1
17:42:09 <geekosaur> `source`
17:42:12 <Maxdamantus> @src IO fmap
17:42:12 <lambdabot> fmap f x = x >>= (return . f)
17:42:57 <geekosaur> alternately http://hackage.haskell.org/package/lambdabot-4.3.0.1/src/State/source
17:44:06 <tarruda> geekosaur: actually I've just looked into '~/.cabal/share/lambdabot-4.3.0.1/State
17:44:11 <tarruda> theres a 'source' file in there
17:45:00 <tarruda> maybe theres some configuration to help lambdabot find it?
17:45:21 <tarruda> environment variables and such
17:45:35 <geekosaur> dunno about recent lambdabot. when I ran it, it wasn't nicely cabalized yet and its "running" state was in ~/.lambdabot or something like that
17:45:55 * Maxdamantus wonders if it'd be particularly weird if class instances could be overridden in single contexts.
17:46:07 <geekosaur> I think you need someone who actually runs a recent version now
17:46:13 <mm_freak> conal: good point
17:46:30 <conal> mm_freak: which one?
17:46:34 <Maxdamantus> so you could have a `Monad m => Functor m` instance, and just hope that it behaves the same way as the already defined `Functor IO`, etc
17:46:51 <mm_freak> conal: GUI apps being the least demanding in performance
17:46:57 <conal> mm_freak: ah.
17:47:27 <mm_freak> merijn: at least reactive-banana and sodium are push-only, which is probably their main weakness
17:47:37 <sdrodge> Are the results of max and min when called on NaN or Infinity defined by haskell2010?
17:47:42 <tarruda> I'm also getting this error whenever lambdabot is started: '[ERROR] Plugin.djinnPlugin: Djinn command failed: fd:8: hClose: resource vanished (Broken pipe)'
17:47:55 <hpc> @src max
17:47:56 <lambdabot> max x y = if x <= y then y else x
17:48:00 <mm_freak> and yeah, perhaps i shouldn't be that hesitant to write a GUI wrapper for netwire and see how the performance is
17:48:02 <conal> mm_freak: how so (weakeness)? do they not support continuous time?
17:48:02 <hpc> sdrodge: it's defined by IEEE
17:48:35 <mm_freak> conal: for example you can't really have a continuous 'time' behavior in reactive-banana/sodium
17:48:43 <sdrodge> hpc: experimentation in ghci (7.6) reveals that these functions do not respect the IEEE spec.
17:48:46 <conal> a somewhat unfortunate definition of max, since it doesn't support lazy values well.
17:49:12 <geekosaur> tarruda, it's trying to open a pipe to the external djinn command. You can install that via cabal as well
17:49:23 <sdrodge> hpc: In fact, the functions are not commutative when one or both of the arguments are NaN or Infinity.
17:49:30 <conal> mm_freak: bummer.
17:49:56 <mm_freak> conal: i wonder which FRP framework is your personal favorite, if any
17:49:59 <hpc> sdrodge: i think you are confusing haskell's promises with IEEE
17:50:08 <hpc> IEEE doesn't promise commutativity of.. well..
17:50:09 <hpc> anything
17:50:17 <conal> mm_freak: i don't have one currently.
17:50:44 <sdrodge> hpc: I'm not confused. Those were two separate thoughts. Though actually, IEEE does specify that max and min should be commutative.
17:51:41 <mm_freak> conal: i'd be really interested in your opinion about netwire 5, particularly because it uses an extension to your original FRP formulation (intervals)
17:52:04 <conal> mm_freak: does it have a denotation?
17:52:08 <sdrodge> > min (0/0) 2
17:52:11 <lambdabot>   2.0
17:52:18 <sdrodge> > min 2 (0/0)
17:52:20 <lambdabot>   NaN
17:52:27 <sdrodge> :/
17:52:30 <tarruda> geekosaur: installing djinn fixed the error message, but I still get "Plugin `sourcePlugin' failed with: state not initialized" with the '@src' command, even after copying the 'source' file to the '~/.lambdabot/State' directory
17:52:36 <mm_freak> conal: not in code right now, but i'd be happy to write it
17:52:39 <hpc> > 2 > (0/0)
17:52:41 <lambdabot>   False
17:52:47 <hpc> > 2 < (0/0)
17:52:48 <lambdabot>   False
17:52:59 <hpc> sdrodge: there is no min or max
17:53:03 <hpc> there's no ordering whatsoever
17:53:21 <hpc> so if IEEE says it should commute, they don't know what they are talking about
17:53:29 <tarruda> geekosaur: I noticed the '~/.lambdabot/State' directory has a few '*Plugin' files in it, but 'srcPlugin' is not amongst them
17:53:49 <sdrodge> hpc: IEEE specifies that if one number is NaN and the other is not, then min and max should both return the number.
17:54:13 <conal> mm_freak: if it has an precise & elegant denotation, continuous time, and a correct implementation (relative to the denotation), i might like it.
17:54:19 <geekosaur> sourcePlugin is the name of the plugin, not the database
17:54:36 <geekosaur> typically for a plugin named fooPlugin, the default state is State/foo
17:55:01 <geekosaur> file format may matter although you should get an error during lambdabot initialization if it's wrong
17:55:38 <sdrodge> hpc: Either way, I'm curious to know if haskell2010 says anything about this situation, or if the behavior of min & max are implementation-defined in these cases.
17:56:12 <hpc> hmm...
17:56:34 <geekosaur> my recollection is h'2010 just claims that it should be IEEE conformant
17:56:47 <hpc> i am curious now too, but i will dodge the issue by saying if your code depends on finding the max of NaN and (any defined), you deserve the bugs
17:56:51 <tarruda> is there another command-line utility I can use to display implementation of haskell functions?
17:57:19 <sdrodge> hpc: My code does not depend on this, I've just been reading the spec and the GHC implementation, and noticed this behavior in the process.
17:57:29 <geekosaur> I think most people who care about the corner cases consider IEEE behavior so broken as to not be relied on anyway :)
17:57:34 <hpc> yeah, that was the royal "you" ;)
17:57:44 <sdrodge> geekosaur: Any idea where it says that?
17:59:05 <adnap> wat. http://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Reader.html: "The binding operator >>= produces a Reader that uses the environment to extract the value its left-hand side, and then applies the bound function to that value in the same environment."
17:59:12 <mm_freak> conal: it's precise and continuous (in fact time is required to be a topological space for the denotation)
17:59:12 <mm_freak> not sure whether to write it in agda or haskell
17:59:30 <conal> mm_freak: sounds promising
17:59:33 <hpc> adnap: why does that sentence even exist
17:59:37 <geekosaur> hm, I recalled not entirely correctly. section 6.4 "The default floating point operations defined by the Haskell Prelude do not conform to current language independent arithmetic (LIA) standards. These standards require considerably more complexity in the numeric structure and have thus been relegated to a library. Some, but not all, aspects of the IEEE floating point standard have been accounted for in Prelude class RealFloat."
17:59:41 <hpc> "Reader is a Monad" bam done
17:59:43 <sdrodge> geekosaur: If this violates the haskell2010 spec, should I bring it to someone's attention, or do you think that we truly don't care?
17:59:45 <geekosaur> "Some, but not all, ..."
17:59:46 <mm_freak> conal: also it's quite elegant:  for 3 . pure "Waiting…" --> pure "Ok, done."
18:00:01 <geekosaur> so I guess the haskell committee just punted on the issue
18:00:16 <adnap> My fav is reactive-banana. I haven't looked at netwire
18:00:33 <sdrodge> geekosaur: Wonderful. :P
18:01:16 <mm_freak> conal: the main difference to the original formulation is that in netwire you don't use event-based switching, but rather you convert events to so-called intervals and switch based on them
18:01:29 <geekosaur> "Float is implementation-defined; it is desirable that this type be at least equal in range and precision to the IEEE single-precision type. Similarly, Double should cover IEEE double-precision."
18:01:29 <geekosaur> yep, punted
18:01:29 <geekosaur> maybe it was h98 that was more specific and h2010 decided to describe the facts on the ground instead of someone
18:01:29 <geekosaur> 's vague hope
18:02:03 <mm_freak> conal: example: holdFor 1 . periodically 2 . pure "Blah!" <|> pure "Blubb!"
18:02:09 <geekosaur> (or some other earlier version of haskell did it)
18:02:13 <mm_freak> 'periodically' is the event that fires every two seconds
18:02:20 <mm_freak> 'holdFor' turns it into an interval
18:02:41 <conal> mm_freak: sounds interesting.
18:02:51 <conal> dinner time for me.
18:03:14 <sdrodge> geekosaur,hpc: Thanks for the help!
18:03:32 <mm_freak> conal: bon appetit =)
18:03:45 <adnap> mm_freak: Are there any leaks?
18:03:52 <hpc> sdrodge: we wish you luck on correcting this grave error in implementing the rigorous and consistent standard of excellence that is the IEEE floating point number specification
18:04:00 <geekosaur> heh
18:04:58 <mm_freak> adnap: some of the predefined wires have non-constant complexity with respect to time, but for those the complexity is documented exactly…  it makes sense for them (average over the last ten seconds, etc.)
18:05:41 <tarruda> @src IO fmap
18:05:41 <lambdabot> fmap f x = x >>= (return . f)
18:06:09 <mm_freak> adnap: custom wires can have time leaks of course, but combinators never introduce new time leaks…  they only leak when the component wires leak
18:06:27 <sdrodge> hpc: :p, I was just curious, but it sounds like this situations is supposed to be undefined, so I won't even bother opening a ticket.
18:06:32 <geekosaur> tarruda, btw, did you restart lambdabot after copying the state in? state is initialized during startup only
18:06:34 <conal> mm_freak: thx.
18:06:45 <mm_freak> adnap: in other words:  as long as you don't use the mk* functions you're fine…  and those are not exported by FRP.Netwire (you need Control.Wire for them) =)
18:07:06 <tarruda> geekosaur: yes, I was running commands with 'lambdabot -e', so its reinitialized every time
18:12:40 <tarruda> @src instance Functor IO
18:12:41 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:12:56 <tarruda> @src IO
18:12:57 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:13:04 <ParahSailin> @src IO Functor
18:13:05 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:13:14 <tarruda> :(
18:14:06 <mm_freak> tarruda: magic
18:14:58 <tarruda> mm_freak: ?
18:15:51 <mm_freak> tarruda: IO's fmap is magic
18:16:36 <tarruda> do you mean its implemented in C ?
18:17:00 <mm_freak> not necessarily
18:17:08 <mm_freak> but it probably uses primitives
18:18:11 <dibblego> hello, I am trying to hide Prelude, but as soon as a module imports qualified Prelude, I cannot keep that qualified import out of scope — is there any way to truly hide Prelude? https://gist.github.com/tonymorris/7477939
18:18:30 <mm_freak> dibblego: -XNoImplicitPrelude
18:18:35 <dibblego> mm_freak: yes, I have done that
18:18:40 <dibblego> it does not hide Prelude proper
18:18:40 <mm_freak> oh
18:18:53 <mm_freak> well, if some other module imports the Prelude, you get the instances
18:19:08 <mm_freak> but if those instances correspond to type classes you don't use, then that shouldn't matter
18:19:08 <dibblego> no, I am getting the qualified import
18:19:15 <dibblego> I am not concerned with this
18:19:54 <dibblego> the gist has {-# LANGUAGE NoImplicitPrelude #-} in a module, :set -XNoImplicitPrelude in .ghci, default-extensions: NoImplicitPrelude in wat.cabal, and still, I cannot use ':type length' at GHCi without a clash — why?
18:19:58 <mm_freak> that's weird
18:20:26 <dibblego> holy crap, I am sorry
18:20:27 <joelteon> :set -XNoImplicitPrelude doesn't work in ghci
18:20:33 <dibblego> rm ~/.ghci
18:20:42 <dibblego> that just cost me two hours
18:20:43 <dibblego> thanks
18:20:44 <mm_freak> ah
18:20:51 <mm_freak> that explains it =)
18:21:40 <dibblego> "that's weird" tipped me off by the way
18:21:43 <dibblego> so thanks
18:27:18 <adnap> mm_freak: "The type signatures in Netwire are known to be scary. =) But like most of the library the underlying meaning is actually very simple." One reason I like Haskell is that I can rely on types to help me understand my program.
18:28:29 * hackagebot postgresql-orm 0.2.2 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  http://hackage.haskell.org/package/postgresql-orm-0.2.2 (AmitLevy)
18:29:38 <mm_freak> adnap: well, i'm considering removing the 'e' argument and making the 's' implicit in the 'm'
18:29:59 <mm_freak> nobody uses e ≠ ()
18:36:14 <tarruda> @src ->
18:36:26 <lambdabot> Source not found. Take a stress pill and think things over.
18:36:32 <mm_freak> tarruda: magic
18:36:46 <tarruda> :(
18:36:58 <geekosaur> it would be (->) if it were in there, but it's not because it's syntax
18:38:30 * hackagebot proxy-kindness 0.1 - A library for kind-polymorphic manipulation and inspection of Proxy values  http://hackage.haskell.org/package/proxy-kindness-0.1 (BrandonSimmons)
18:40:37 <tarruda> After a few days of hurting my head, I'm beginning to see some of haskell's beauty
18:41:56 <pavonia> tarruda: "->" can mean different things in different context. Which one are you looking for?
18:42:41 <tarruda> I searching for '->' as a type constructor
18:42:56 <tarruda> function type constructor
18:43:36 <pavonia> Well, I don't think you will find a type definition for that
18:43:47 <pavonia> Do you understand what it's doing?
18:44:33 <tarruda> I'm creating an analogy with type constructors
18:44:45 <tarruda> but no, I dont understand what its doing
18:45:55 <pavonia> "a -> b" is the type of all functions mapping values of type "a" to values of type "b"
18:46:56 <mm_freak> (->) cannot be defined
18:46:56 <mm_freak> it's a primitive
18:47:24 <mm_freak> this applies to all languages in the lambda cube
18:48:16 <tarruda> is there a lightweight http server library that uses select/poll to handle requests?
18:48:30 <tarruda> Something in the spirit of node.js
18:48:51 <mm_freak> tarruda: all of them are pretty lightweight, lighter than node.js actually
18:48:52 <geekosaur> all of them? because that's what the runtime does
18:49:11 <mm_freak> they don't use select/poll, they use haskell concurrency, and that one will use epoll on linux
18:49:24 <tarruda> thats nice to know
18:49:33 <geekosaur> there was once an exposed poll thing but that was testing for an upgrade to the one in ghc's runtime
18:50:00 <tarruda> does haskell concurrency uses userspace threads?
18:50:07 <mm_freak> if you want it to
18:50:21 <geekosaur> and, since it was written on top of the then runtime and there've been something like 4 major rewrites to the runtme since then, probably doesn't work
18:50:28 <mm_freak> compile your program with -threaded and invoke it with +RTS -N
18:50:57 <geekosaur> haskell does green threading with the default runtime, N:M threading with -threaded
18:51:15 <mm_freak> IMO -threaded should become the default
18:53:14 <tarruda> is there a builtin facility for comunication between threads or do I have to use databases?
18:53:41 <mm_freak> tarruda: you use concurrency abstractions like MVars
18:53:50 <mm_freak> or STM
18:55:28 <geekosaur> tarruda, you might want to look at the Control.Concurrent hierarchy
18:56:00 <tarruda> look in hoogle?
18:56:07 <mm_freak> look at The Book
18:56:09 <mm_freak> http://chimera.labs.oreilly.com/books/1230000000929
18:56:21 <mm_freak> it explains this in detail
18:57:01 <tarruda> thanks
19:02:47 <adnap> mm_freak: I think the integral function will produce numerical error if used twice if it uses Euler's method.
19:03:50 <adnap> e.g. if one integrates acceleration to get velocity and then velocity to get position, position will have numerical error
19:23:34 * naomi has interest in haskell but knows nothing
19:23:36 <naomi> where should i start ?
19:24:45 <Clint> @where lyah
19:24:45 <lambdabot> http://www.learnyouahaskell.com/
19:27:23 <naomi> could someone also enlighten me with haskells "strong suits"?
19:27:27 <naomi> what are people mostly using it for ?
19:28:37 * hackagebot zasni-gerna 0.0.4 - lojban parser (zasni gerna)  http://hackage.haskell.org/package/zasni-gerna-0.0.4 (YoshikuniJujo)
19:32:05 <levi> naomi: Everything from high-tech stock trading software to biotech research, with some web app stuff and games in-between.
19:32:43 <naomi> levi, i mean like, PHP is good for the web, Node.js is really good for evented things, etc
19:32:52 <naomi> does haskell have a generic strong suit like this?
19:32:58 * RichyB coughs at "PHP is good for the web".
19:33:08 <levi> PHP and Node.js are not actually all that good for those things.
19:33:23 <naomi> ok well PHP is not good for the web, but PHP is "designed" for it
19:33:38 * hackagebot http-client 0.1.0.0 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.1.0.0 (MichaelSnoyman)
19:33:39 <RichyB> If you want the elevator pitch, Haskell is good at blowing peoples' minds. ;)
19:34:13 <levi> Haskell was "designed" for researching purely-functional programming languages.  But that was before node.js and PHP were a twinkling in their inventors' eyes.
19:35:01 <naomi> fwiw, i loathe PHP, but its "purpose" is quite obvious
19:35:24 <naomi> node.js also has a pretty defined purpose
19:36:33 <levi> Haskell's purpose was exactly as I said.  A bunch of academics got together and said, "Hey, we've all been creating our own languages to research this purely-functional non-strict language field; we ought to get together and collaborate on one language instead."
19:37:11 <levi> Basicaly it was invented to figure out how to write programs in it.
19:37:22 <RichyB> I would give a slightly longer pitch. It's a programming language that is fairly easy to write fairly fast code in. It has a static type system, which makes it very easy to not accidentally write lots of kinds of buggy programs. It also has type inference, which means that you don't have to sacrifice brevity and clarity for that (no need for old-Java style stuff like "List list_of_integers = new ArrayLis
19:37:22 <levi> And then how to make those programs run well.
19:37:22 <RichyB> t<Integer>();").
19:37:38 <levi> And then how to apply those programs to various real-world problems.
19:38:00 <kmels> hey, how can i keep a cabal file compatible for both base 4.5 and base 4.6 (newer ghcs) ?
19:38:28 <RichyB> GHC (the most popular Haskell compiler) produces fairly good code and has a very good run-time, so you can use Haskell for writing the same kinds of software that you might use Go!lang for, for instance.
19:38:35 <gienah> kmels: base >= 4
19:38:38 <monochrom> I wouldn't give much weight to what the inventors intended decades ago.
19:38:52 <naomi> hmm, well thanks levi and RichyB
19:38:52 <kmels> gienah, thanks
19:38:59 <naomi> i suppose i'll just get started and ask questions as they come up
19:39:00 <naomi> :)
19:39:02 <RichyB> Yes, the inventors' intentions have been met and surpassed a while ago. :)
19:39:15 <levi> monochrom: I wouldn't either, but it was the question that was asked.
19:39:17 <naomi> oh, what is haskell implemented in?
19:39:27 <levi> Haskell, and some C.
19:39:29 <RichyB> naomi, I am glad to hear that! Please feel free to ask everything you feel the need to. :)
19:39:35 <naomi> no we are talking
19:39:37 <levi> Depends on the implementation of Haskell, though.
19:39:38 <naomi> now* we are talking
19:39:39 <ion> GHC is implemented in mostly GHC Haskell
19:39:41 <naomi> C is a good thing
19:39:53 <naomi> ion, what is ghc ?
19:39:56 <monochrom> hugs is implemented in C
19:40:00 <naomi> ?
19:40:01 <naomi> :<
19:40:04 <ion> The most popular Haskell compiler
19:40:06 <naomi> oh
19:40:09 <RichyB> GHC is the Glorious Glasgow Haskell Compiler. It's the most popular Haskell compiler.
19:40:27 <monochrom> therefore, hugs is the slowest. "therefore", hehe.
19:40:55 <naomi> monochrom, do you mean to imply that haskell generally faster than c ?
19:41:09 <monochrom> no. in fact, I would imply:
19:41:18 <monochrom> @quote monochrom einstein
19:41:18 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
19:41:23 <RichyB> GHC compiles Haskell source files into (pretty good quality) machine code. GHC itself is mostly written in Haskell. Most of the C code in GHC is in the RTS.
19:41:23 <naomi> also, as an osx dev, is there a recommeded way to get haskell installed on my system
19:41:52 <naomi> "RTS"?
19:42:04 * monochrom takes pleasure in turning a pseudoquestion into confusion
19:42:11 <ion> Runtime system
19:42:13 <lpaste> Cale pasted “Slightly fancier version of sqrt demo” at http://lpaste.net/95685
19:42:20 <naomi> monochrom, it's delightful for beginners, i assure you
19:42:33 <RichyB> naomi, no. What monochrom means by that is, a Haskell program that is compiled to machine code and run on your CPU, will run faster than if you took that same Haskell code and ran it on an interpreter which is written in C.
19:43:04 <monochrom> monochrom's meta point is that the question is unimportant
19:43:47 <levi> Haskell programs are, in some domains, in the same performance ballpark as existing C programs in those domains.
19:44:53 <khyperia> I do remember some very strange instance where supercompiled haskell was barely faster than the equivalent C
19:45:05 <levi> And for some areas, the Haskell code that runs that fast can be a lot cleaner and more high-level than the C code.  But I wouldn't say that's generally the case.
19:47:15 <levi> But you generally don't choose Haskell over C for performance reasons. You do it because Haskell is a very good language for writing correct programs in areas where it's tricky to do so, because it has a very helpful type system and encourages programming via composition of smaller pieces.
19:48:28 <monochrom> a haskell compiler written in a lot of haskell poses a practical problem.
19:49:18 <monochrom> there are linux distros who say, "every package must be buildable with just gmake and gcc". a haskell compiler written in a lot of haskell will not qualify.
19:49:31 <RichyB> naomi, other nice things about Haskell: the community is nice (especially if you join #haskell while Cale is online); some of the libraries on Hackage have both really nice APIs and really good performance; it has laziness, which is an unusual feature that you can use to write some programs in a very straightforward way; it has userland threads multiplexed over operating system threads, which means you c
19:49:32 <RichyB> an start a million threads in less than a second:N th
19:49:33 <monochrom> therefore, hugs easy qualifies, ghc will not qualify
19:50:10 <khyperia> RichyB, adding on to that lazyness thing... it allows some pretty wacky awesome stuff, like mfix/mdo/etc
19:50:13 <monochrom> now, instead of concluding "I should go with hugs", I would conclude, "screw those tunnel vision people"
19:51:09 <RichyB> monochrom, ¡IMPORTANT NOTE! Just because you have decided to forgo using Hugs the Haskell interpreter does NOT mean that you should stop hugging people! 😸
19:51:32 <monochrom> actually, sometimes I recommend hugs
19:51:41 <frx> for what?
19:51:48 <monochrom> for haskell
19:52:03 <naomi> i'm just going to assume monochrom is a bot
19:52:14 <monochrom> I am a bot.
19:52:24 <MedDev> or multiple people. pretty sure he/she doesn't sleep
19:52:25 <jmcarthur> ghc doesn't build with hugs, does it? but if it did then it would qualify
19:52:25 <naomi> i'm reading about the typing and the laziness.. this is exciting :)
19:52:26 <RichyB> naomi, oh, also, Haskell has a pretty good foreign function interface for C, so it's not too difficult to use C libraries from Haskell programs (though it will be about as difficult as using those C libraries from C would be).
19:53:17 <naomi> is testing popular in the haskell community
19:53:18 <naomi> ?
19:53:27 <monochrom> I haven't though of building ghc with hugs. it should be interesting to see. I don't think ghc's source code actually uses much extensions.
19:53:53 <monochrom> otoh, would you like to guess how many days it would take? :)
19:54:04 <jmcarthur> i bet less than one
19:54:34 <jmcarthur> but several unbearable hours, at least
19:55:00 <RichyB> naomi, it varies. There are some really nice libraries for testing in Haskell, such as QuickCheck.
19:55:35 <jmcarthur> naomi: we practice TDD, but it's Type Driven Development more than Test Driven Development
19:55:38 <khyperia> Well, wouldn't you have to interpret GHC to build GHC, since hugs doesn't compile anything?
19:55:55 <jmcarthur> khyperia: right, it would be interpreting the sources in order to build them
19:55:59 <naomi> jmcarthur, a little more explanation on that?
19:56:03 <khyperia> that's weeeeird.
19:56:04 <RichyB> @quickcheck \a b -> (a + b) == ((b::Word32) + a)
19:56:05 <lambdabot> Unknown command, try @list
19:56:50 <jmcarthur> naomi: you drive your implementations by their types. have a type in mind and start filling in the holes. use the compiler to tell you what you need to do next.
19:57:38 <RichyB> @check \a b -> (reverse (reverse a)) == (a) -- quickcheck is a really neat thing; it automatically generates test cases for checking algebraic properties just by writing functions that return True or False.
19:57:43 <lambdabot>   <hint>:1:228:
19:57:43 <lambdabot>      parse error (possibly incorrect indentation or mismatche...
19:58:40 <RichyB> er
19:58:51 <RichyB> @check \a -> (reverse (reverse a)) == a
19:59:03 <lambdabot>   mueval-core: Time limit exceeded
19:59:13 <khyperia> heh
19:59:25 <RichyB> Oh, lambdabot is having a bit of a sad day today. Apparently so am I. ;)
19:59:31 <levi> naomi: Haskell's type system and its community encourage techniques that build correctness properties of programs into types, which means that the compiler will ensure that your programs have those properties (i.e., they don't violate them with coding errors) at compile-time.
20:00:19 <carter> monochrom: jmcarthur  also ghc now uses stuff probably not found in hugs
20:00:25 <naomi> levi, thanks for the tips
20:00:28 <carter> though theres nothing preventing writing an interpereter that would wokr
20:00:44 <jmcarthur> carter: right
20:00:53 <carter> and maybe that'd be good
20:01:09 <carter> 'cause we need more ways to fuzz ghc for build issues
20:01:22 <carter> 'cause honeslty theres tooooo much breakage betwee releases
20:01:26 <RichyB> naomi, that's not to say that you can't do test-driven development in Haskell. There's a unit-testing library called "HUnit" that comes with the Haskell platform, for instance.
20:02:01 <naomi> ... why would the framework come with a version of haskell-platform itself ?
20:02:08 <earldouglas> Is there a way to run cabal in a sort of chroot mode?
20:02:20 <RichyB> but the ability to use the type-checker to try to prove some programs correct is unique to languages that have powerful type systems like Haskell (or ML or Agda or Idris…)
20:02:22 <earldouglas> I keep running into conflicting packages that won't install together.
20:02:24 <carter> earldouglas: cabal sandbox :)
20:02:29 <earldouglas> That sounds about right
20:02:31 <earldouglas> Thanks!
20:02:31 <levi> naomi: There are a bunch of fairly nice testing frameworks, actually. Some let you encode little tests in the comments right before your functions; some let you do 'spec-style' behavioral specifications; some interate with xUnit-style testing.
20:02:34 <carter> earldouglas: cabal-instal 1.18 is kinda awesome
20:02:49 <carter> earldouglas: you need to "cabal update ; cabal install cabal-install"
20:02:57 <carter> earldouglas: you may want to first delete ~/.ghc
20:03:01 <carter> to kill the crazies
20:03:03 <RichyB> naomi, uh, the "Haskell Platform" is a "batteries-included" distribution; it includes GHC and a bunch of the more popular and useful libraries
20:03:29 <earldouglas> carter: Done.
20:03:35 <carter> earldouglas: woot
20:03:39 <carter> cabal 1.18 is nice
20:03:40 <naomi> RichyB, oh i read that in the reverse direction
20:03:47 <carter> i was using it for months before it was released
20:03:51 <naomi> RichyB, i thought HUnit bundled it's own haskell-platform; not the reverse
20:03:53 <earldouglas> I'm now on 1.18.0.2
20:04:01 <RichyB> Ah, no worries.
20:04:05 <carter> earldouglas: congrats, its a baby cabal-install
20:04:07 <RichyB> The Haskell Platform meant to be an equivalent of how, say, when you install Python, it comes with a built-in web server and email client and so on.
20:04:16 <carter> yeah
20:04:23 <carter> though smaller set of batteries currently
20:04:35 <carter> in another year or so i hope to get my stuff into HP :)
20:04:36 <carter> mwahahahahahahahah
20:04:44 <carter> probably 1.5 years for things to stabilize
20:04:46 <Javran> hello, anyone knows how to add module search path for ghci, I tried "-i", but it only works with ghc and runghc
20:04:49 <levi> I'm not sure it's smaller; maybe just a different set.
20:05:26 <RichyB> Other nice thing about Haskell; sometimes programming in Haskell makes people feel godlike, which leads to maniacal world-domination-style cackling, as we have just seen from carter. ;)
20:05:56 <carter> RichyB: i've been working on building the substrate for haskel having nice numerical tools for a year and a half
20:06:03 <enthropy> Javran: it's the same -i in my experience
20:06:06 <carter> and i'm even contribing to GHC to support that
20:06:15 <RichyB> carter, like automatic differentiation and such?
20:06:20 <carter> Javran: make sure you're in the top of the folder tree
20:06:26 <carter> RichyB: edwardk already has that
20:06:31 <monochrom> Javran: it works for me in ghci
20:06:34 <carter> though i've some ideas for it when i have time
20:06:36 <carter> @hackage ad
20:06:37 <lambdabot> http://hackage.haskell.org/package/ad
20:06:38 <carter> is pretty cool
20:06:43 <RichyB> carter, or should I be thinking about linear algebra, or a nicer Num hierarchy, or…?
20:06:48 <enthropy> carter: the ad needs to work with unboxed vectors I think
20:06:50 <carter> heheehee
20:06:53 <carter> yup
20:06:58 <carter> lin alg first
20:07:06 <carter> then some mix of range against the nums
20:07:09 <carter> and unboxed ad
20:07:16 <enthropy> for now it needs a traversable
20:07:24 <carter> enthropy: how?
20:07:36 <enthropy> what do you mean how?
20:07:51 <carter> ad needs traversable instances?
20:07:51 <enthropy> http://hackage.haskell.org/package/ad-3.4/docs/Numeric-AD.html#g:1 the type here is for a traversable container
20:08:06 <carter> whats your remark?
20:08:08 <enthropy> it needs some adaptation to work with unboxed stuff
20:08:16 <carter> yeah
20:08:33 <carter> honestly i think the best approach would be runtme code gen
20:08:41 <carter> that lets you preserve the traversable structure
20:08:43 <zardoz``> I wish we could define | as reverse ($). piping a value would be shell-like
20:09:02 <carter> zardoz``: patch the parser for yourself
20:09:18 <enthropy> the grammar is already very crowded
20:09:19 <carter> zardoz``: RichyB  i actually tested out building ghc with a modified numerical prelude a few months back :)
20:09:19 <jmcarthur> or write a preprocessor
20:09:20 <RichyB> zardoz``, isn't "|>" defined as either reverse ($) or reverse (.) by something or other?
20:09:22 <ion> (.) is like pipes, ($) is not.
20:09:34 <ion> @type (&)
20:09:40 <lambdabot> a -> (a -> b) -> b
20:09:52 <carter> and only 1-5 tests in the ghc test suite failed with the patched numeical prelude
20:09:54 <carter> which is pretty nice
20:09:54 <RichyB> I am almost certain that I have seen a (|>) == reverse (.) operator somewhere
20:09:56 <zardoz``> Richy I don't know
20:10:17 <carter> g2g for a bit
20:10:26 <MedDev> if i use a GPL library as a dependency in a library i'm writing does my library have to be GPL too? or is BSD/MIT fine?
20:10:29 <Javran> ~/lib $ tree
20:10:29 <Javran> .
20:10:29 <Javran> └── ProjectEuler
20:10:29 <Javran>     ├── Everything.hi
20:10:29 <Javran>     ├── Everything.hs
20:10:29 <Javran>     └── Everything.o
20:10:30 <Javran> ~/lib $ ghci -i ~/lib/
20:10:30 <Javran> GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
20:10:30 <Javran> Loading package ghc-prim ... linking ... done.
20:10:31 <Javran> Loading package integer-gmp ... linking ... done.
20:10:31 <Javran> Loading package base ... linking ... done.
20:10:32 <Javran> target `/home/javran/lib/' is not a module name or a source file
20:10:36 <RichyB> and Control.Arrow has (>>>), which on functions is exactly (reverse (.)).
20:10:44 <zardoz``> ion:  "foo" | map toUpper | reverse | print
20:10:55 <Javran> just like this, despite same thing works for ghc & runghc
20:11:06 <ion> javran: Please Please use a pastebin.
20:11:08 <RichyB> Javran, please use hpaste for pasting multi-line error messages.
20:11:26 <Clint> MedDev: you can make your code MIT but the combined work will be conveyed under the GPL
20:11:33 <Javran> ops..sorry about that
20:11:57 <monochrom> Javran: make it "-ilib". no space. and I thought you knew because you said you got it to work in ghc and runghc.
20:12:05 <ion> zardoz: baz = map toUpper | reverse; quux = baz | print; main = quux "foo"
20:12:23 <monochrom> perhaps I should not trust what humans say.
20:12:38 <MedDev> Clint, so an executable will be GPL (because it's linking to GPL code?) but the code itself will be MIT?
20:13:34 <zardoz``> ion wtf
20:14:51 <ion> > let g ¦ f = f . g; foo = map (+10) ¦ show ¦ reverse in foo [1..5]
20:14:55 <lambdabot>   "]51,41,31,21,11["
20:15:08 <Javran> monochrom: http://lpaste.net/95688 I've removed the space but it didn't work either..
20:15:14 <Clint> MedDev: well, anything you license as MIT will be free for anyone to proprietize without compensating you except for any code that a judge determines to be a derivative work of the GPL'd library.. but other than that what you said is probably close enough
20:15:30 <monochrom> it is not :m+. it is :load
20:16:42 <zardoz``> ion I think you missed the point of that operator. It works best as reverse ($). you start with some data, then pipe it from one function to another
20:17:08 <zardoz``> a couple of libraries define it
20:17:54 <ion> Making the data implicit makes it better for refactoring.
20:18:00 <zardoz``>   does look nice though
20:18:23 <Javran> monochrom: cool, it works.. I thought "l" can only be followed by source file names .. so what exactly is the difference between "m" and "l" ?
20:18:56 <monochrom> the GHC user's guide has it. I won't repeat what it says, it's long. the GHC user's guide is already on your hard disk.
20:20:02 <monochrom> https://plus.google.com/u/0/+ConradParker/posts/SQBDa3rkAyb
20:20:48 <Javran> monochrom: fine, thanks a lot
20:24:03 <carter> MedDev: write bsd code, the result will be gpl'd by the deps, but once someone implements a bsd version, youre stuff will be bsd when used too
20:24:43 <MedDev> carter, the bsd 3 clause or public domain is the license i've been using
20:24:48 <carter> cool
20:24:53 <carter> bsd3 is a real licesne
20:24:55 <carter> use that
20:24:57 <carter> or apache2
20:24:59 <carter> or mit
20:25:08 <carter> public domain doesn't exist in every country
20:26:23 <RichyB> carter, I like the "schism" between the MIT and 3-clause BSD licenses.
20:26:33 <RichyB> There's no actual functional difference between the two in practice
20:26:36 <carter> yeah
20:26:41 <carter> they're the same for now
20:26:48 <Clint> except the extra clause
20:27:13 <carter> Clint: yeah, but you can't use peoples names without permission anyways
20:27:15 <RichyB> but 3-clause BSD is from the West coast of the USA, whereas MIT is from the East coast. ;)
20:27:39 <Clint> i like how people insist on 3-clause for no good reason when even BSDs switched to 2-clause
20:27:39 <carter> tehy're more alike than diffferent
20:27:53 <carter> it doesn't amtter though
20:28:00 <MedDev> carter, that's good to know. is there a significant country that doesn't have the concept of public domain?
20:28:05 <carter> not sure
20:28:11 <carter> not a lawyr
20:28:16 <RichyB> MedDev, iirc Germany.
20:28:27 <carter> MedDev: point being: licenses are explicit
20:28:27 <RichyB> Wikipedia lists a few, I think.
20:28:43 <carter> saying "this is public domain" isn't explicit about that that means
20:28:46 <RichyB> So when someone makes a choice between the someone goes with BSD or MIT licenses, what that tells you is mostly where they are from. ;)
20:28:49 <Clint> that's why CC0 exists
20:29:00 <Clint> RichyB: it tells you which programming cult they're in, usually
20:29:06 <carter> nah
20:29:19 <carter> i use BSD licenses, but i've really only been in the north east
20:29:20 <RichyB> s/someone goes with//
20:29:24 <carter> and i've hung out at MIT a bunch
20:29:32 <carter> it only was discernable in the 90s and earlier
20:30:03 <RichyB> Clint, right, which tradition they subscribe to.
20:30:37 <RichyB> You'll learn a little more again about someone if they elect to release software under "the X11 license". ;)
20:31:15 <carter> most haskell  libs use bsd 'cause thats what everyone does
20:31:22 <carter> but mit or apache2 etc would be just as valid
20:31:54 <RichyB> Aye.
20:32:10 <RichyB> Doesn't apache2 have some patent indemnity-ish clauses in it?
20:32:38 <Clint> yes, that's why it's illegal for the U.S. government to use software licensed under it
20:33:03 <carter> wait waht
20:33:06 <carter> really?
20:33:29 <Clint> technically yes
20:33:32 <carter> nope http://www.fiercegovernmentit.com/story/army-lawyers-dismiss-apache-license-indemnification-snafu/2012-03-08
20:34:05 <carter> errrm
20:34:07 <carter> mebe
20:34:50 <carter> section 9:
20:34:54 <carter> http://www.apache.org/licenses/LICENSE-2.0.html
20:36:13 <carter> "While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold
20:36:13 <carter>  each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability."
20:36:20 <carter> switching to blah
20:39:12 <m3ga> carter: company i work will not contribute to anything licensed under apache 2
20:39:20 <carter> m3ga: oh?
20:39:36 <carter> 'cause patents are key part of their revenues, right?
20:39:43 <m3ga> yes
20:39:56 <m3ga> not just 'part', 'large part'
20:40:02 <carter> ok
20:40:46 <carter> so nothing that requires them to say "if our contributiion requires patents we own, we grant those licenses"
20:41:14 <carter> on the flip side, that means anything they contrib to could have a time bomb, right?
20:41:39 <carter> "btw, that patch we gave you infringes on our patent over here"
20:42:01 <sirspazzolot> just got to bytestrings in LYAH. the book implies it's more normal to work with regular strings. is there a reason for this other than 'one less thing to import'?
20:42:15 <carter> pretty much it
20:42:40 <ion> ByteStrings are not for the same thing as Strings. (OTOH, Text is.)
20:42:41 <sirspazzolot> hah okay
20:42:43 <carter> yeah
20:42:49 <carter> Text is better way to go
20:42:51 <ion> ByteString is like [Word8], not like [Char].
20:42:52 <carter> for text
20:43:27 <carter> jah
20:43:43 <carter> that it ever works is a happy accident called extended ascii and westernness
20:43:45 <carter> :P
20:43:50 <sirspazzolot> wasn't aware of text. ion isn't [Word8] basically [Char] for ASCII chars?
20:44:43 <sirspazzolot> oh I guess I'm mistakenly associating 8-bit numbers with ascii necessarily
20:44:56 <ion> sirspazzolot: If we make a contract about putting ASCII chars into Word8, we can deal in ASCII text using Word8. But Word8 doesn’t have anything to do with characters implicitly.
20:45:34 <sirspazzolot> gotcha. thank you for clarifying. I'll read about Text sometime as well
20:45:36 <ion> String and Text are implicitly about text and you don’t need to care about encoding.
21:02:40 <zardoz``> OT but interesting: http://en.wikipedia.org/wiki/File:8_bytes_vs._8Gbytes.jpg
22:00:58 <Twey> What's nice in Haskell GUI libraries these days?  Is Gtk2Hs still what everyone uses?
22:03:01 <Twey> I want something that can embed an OpenGL context and otherwise just do the basics (event handling, buttons, &c.)
22:07:44 <sm> gloss
22:15:26 <Kaidelong> what? Gloss can make an OpenGL context?
22:15:53 <carter> it is opengl
22:15:55 <carter> i think
22:15:57 <carter> i'm off
22:15:58 <carter> night all
22:16:44 <Kaidelong> yeah but I don't think gloss is what Twey was asking for
22:17:09 <Kaidelong> what it sounded like was he wanted to make a window and do the things gloss does on his own
22:17:35 <xico> Twey: glfw-b
22:19:12 <Twey> xico: I think I need to embed a few different OpenGL contexts (orthographic views from different sides, &c.) so I don't think that will cut it
22:19:34 <Twey> Well, I guess I could draw them myself in OpenGL, but that seems like more pain than it's worth
22:20:01 <Twey> Gloss is cool but I'm not sure I'm allowed it (OpenGL assignment)
22:21:58 <xico> Twey: indeed, glfw would separate context in different windows
22:24:51 <zol> https://gist.github.com/Zolomon/7479868 -- isn't it possible to pattern match like this?
22:26:00 <Cale> zol: That is possible
22:26:39 <Ralith> Twey: handling multiple OpenGL contexts is more pain than it's worth. This is why 3D modeling packages just use one big context and draw multiple panes inside it.
22:26:52 <ski> you need to cover the other cases as well, or you get a partial function
22:27:19 <zol> thanks!
22:27:36 <Ralith> Twey: for example, OpenGL resources are all associated with a particular context, and presumably you'll want to use the same models/textures/shaders for each view.
22:29:21 <Twey> Ralith: Ah, I see
23:03:57 <chrisdotcode> can someone please help me fix this:
23:03:57 <chrisdotcode> Just "foo" >>= (\y -> y == "foo")
23:04:10 <chrisdotcode> I'm not quite sure why it's not working.
23:04:23 <ski> > Just "foo" >>= (\y -> return (y == "foo"))
23:04:27 <lambdabot>   Just True
23:04:32 <ski> > Just "foo" >>= (\y -> Just (y == "foo"))
23:04:33 <lambdabot>   Just True
23:04:36 <ski> @src Maybe return
23:04:37 <lambdabot> return              = Just
23:04:37 <chrisdotcode> oh, right
23:04:53 <chrisdotcode> I have return it in context; thank ski
23:04:58 <ski> > liftM (\y -> y == "foo") (Just "foo")
23:05:00 <lambdabot>   Just True
23:05:09 <chrisdotcode> would that also be the same as using <$>?
23:05:10 <ski> @src liftM
23:05:11 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:05:19 <ski> yes, since that's the same as `fmap'
23:05:23 <chrisdotcode> okay, excellent.
23:05:25 <ski> @src IO fmap
23:05:25 <lambdabot> fmap f x = x >>= (return . f)
23:05:26 <chrisdotcode> thanks a lot :)
23:05:41 <ski> np
23:06:22 <ski> `\y -> y == "foo"' can also be abbreviated as `(== "foo")'
23:06:28 <ski> (or alternatively `("foo" ==)', in this case)
23:06:41 <chrisdotcode> sweet, thanks :)
23:06:47 <ski> > ("foo" ==) `liftM` Just "foo"
23:06:48 <lambdabot>   Just True
23:07:20 <hoactzin`> @src liftM2
23:07:20 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:07:43 <ski>   liftM2 f ma mb = return f `ap` ma `ap` mb
23:08:02 <hoactzin`> liftM2 (+) (Just 1) (Just 2)
23:08:03 <hoactzin`> > liftM2 (+) (Just 1) (Just 2)
23:08:05 <lambdabot>   Just 3
23:08:11 <hoactzin`> righto
23:08:32 <ski> > Just (*) `ap` Just 2 `ap` Just 3
23:08:33 <lambdabot>   Just 6
23:09:00 <ski> > [(+),(*)] `ap` [2,10] `ap` [3,100]
23:09:01 <lambdabot>   [5,102,13,110,6,200,30,1000]
23:09:20 <hoactzin`> ahaha nifty
23:10:12 <ski> > [(+),(*)] <*> [2,10] <*> [3,100]
23:10:14 <lambdabot>   [5,102,13,110,6,200,30,1000]
23:10:22 <ski> > getZipList (ZipList [(+),(*)] <*> ZipList [2,10] <*> ZipList [3,100])
23:10:23 <lambdabot>   [5,1000]
23:24:10 * hackagebot smallcheck 1.1 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.1 (RomanCheplyaka)
