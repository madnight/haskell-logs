00:04:27 <kryft> I'm doing monte carlo simulation for a game with dice rolls (using probability from hackage), and on each turn I compute some things that depend on both the dice roll and the state of the simulation (which could have changed based on something that happened on the previous turn).
00:07:43 <kryft> If each turn is evaluated 10000 times (due to the monte carlo), the computations will involve a lot of identical function calls; can I trust that something like f(1,2) will only actually be evaluated once?
00:08:09 <kryft> That's my vague understanding of how lazy evaluation works, but I don't know the details
00:08:30 <SparkySparkyBoom> yay
00:08:33 <SparkySparkyBoom> it's back
00:08:43 <SparkySparkyBoom> haskell.org is back up
00:09:19 <kryft> If it's more tricky than that, then I might have to actually store some intermediate results that are unlikely to change from one turn to the next
00:10:21 <kryft> But it would obviously be nicer to specify how everything is computed and trust that things that never change during the simulation aren't recomputed lots of times
00:10:55 <FreeFull> kryft: It actually depends on how f is implemented
00:11:35 <kryft> FreeFull: Ah?
00:11:46 <bitemyapp> Does anybody know why haskell.org was down?
00:11:58 <FreeFull> kryft: Have a look at http://www.haskell.org/haskellwiki/Memoization
00:13:01 <FreeFull> bitemyapp: http://www.reddit.com/r/haskell/comments/1qrldv/haskellorg_servers_down_at_the_moment/cdg92st
00:13:41 <bitemyapp> FreeFull: thank you.
00:14:08 <bitemyapp> FreeFull: the entirety of hackage was running on a single Hetzner server? jeez, running lean eh? :)
00:14:35 <fxr> for me, it's up now.
00:14:45 <kryft> FreeFull: Ah, so apparently there's no "automatic memoization" as such
00:17:27 <FreeFull> kryft: If you make something that looks like a lazy data structure and is monomorphic, values will only be computed once, and afterwards you only need to pay the cost of retrieval. So to memoize a function, you make it read from a data structure that contains all the possible values.
00:17:45 <FreeFull> I think there is actually a package that will do it for you
00:19:12 <ReinH> FreeFull: representable functors?
00:21:02 <FreeFull> http://hackage.haskell.org/package/memoize  There is this library that uses Template Haskell to do the memoization for you. I haven't used it so I don't know how good it is
00:21:02 <kryft> FreeFull: Ah, I see; so it's almost free memoization then :)
00:21:12 <kryft> Thansk
00:21:15 <kryft> Thanks too
00:21:38 <kryft> I think I'll do it myself first in any case to get a better understanding of what's going on
00:22:05 <FreeFull> The performance will depend on what data structure you choose
00:22:07 <pharaun> seems like hackage is back up?
00:22:19 <FreeFull> pharaun: Yep
00:22:35 <FreeFull> pharaun: http://www.reddit.com/r/haskell/comments/1qrldv/haskellorg_servers_down_at_the_moment/cdg92st
00:22:39 <kryft> FreeFull: Because cost of retrieval depends on the data structure, or is there something less obvious?
00:22:47 <pharaun> do we have any idea what the resolution to their ongoing issue was or if they gave up and rebooted it, oh reading
00:23:02 <pharaun> ahh
00:23:06 <FreeFull> kryft: Just the cost of retrieval
00:24:06 <kryft> Right
00:24:13 <FreeFull> Replaced the RAM and flashed the BIOS. Sounds like troubleshooting by replacing random parts of the hardware
00:24:28 * hackagebot shake 0.10.10 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.10 (NeilMitchell)
00:24:28 * hackagebot http-monad 0.1.0.3 - Monad abstraction for HTTP allowing lazy transfer and non-I/O simulation  http://hackage.haskell.org/package/http-monad-0.1.0.3 (HenningThielemann)
00:25:47 <pharaun> FreeFull: indeed, so not sure how much help that would be but... we'll see
00:44:48 <Dobiasd> Hi, I'm a FP noop (coming from OOP). I try to find something like this C++ code ( http://ideone.com/wbQWzc ) in Haskell. (Have polymorphic types which can be stored in a list, in the C++ case via abstract base class pointers.)
00:44:50 <Dobiasd> So far I came up with this ( http://codepad.org/2WZ4pZs5 ), but it feels more like I did something like that ( http://ideone.com/5RpTc2 ).
00:44:53 <Dobiasd> Is there a possibility to go to the other side of the expression problem? I mean I would like to make it easy to add new object types and difficult to add new functions, like in the first OOP code. At the moment my Haskell version seems to be the other way around.
00:48:12 <ellipsis_> haskell.org is back :D
00:49:24 <bitemyapp> ellipsis_: yeah somebody announced it on the Reddit thread.
00:49:33 <bitemyapp> ellipsis_: apparently the whole schmiel was on a single Hetzner server :)
00:49:44 <ellipsis_> bitemyapp: wat.
00:49:49 <FreeFull> Dobiasd: Using a type like that is the standard solution when you know what you want to end up in the list
00:49:54 <bitemyapp> ellipsis_: including hackage.
00:50:04 <ellipsis_> bitemyapp: moar redundancy
00:50:16 <FreeFull> Dobiasd: Otherwise, you could use something like Data.Dynamic
00:50:23 <bitemyapp> ellipsis_: supposedly they're working on that.
00:50:31 <ellipsis_> How did they even manage to run all that off one box?
00:50:35 <bitemyapp> ellipsis_: I think the community is going to get a bit more serious about mirrors too.
00:50:39 <FreeFull> I haven't actually seen any code that uses Data.Dynamic yet
00:50:58 <bitemyapp> ellipsis_: uh you'd be surprised, in the age of shitty VPSes, a single powerful dedicated server can go a long way for workloads with low amounts of coordination.
00:51:18 <bitemyapp> and anything involving a static website/wiki and a package server is pretty low coordination.
00:51:24 <ellipsis_> fair point
00:51:49 <Dobiasd> FreeFull: Yes, but if I add a new "class", I have to do through every function. Also all the functionality of the different classes are mixed together. I would prefer a separation, where the functions for every single class are in one module. And when I add or change a class, I just have to edit this one module.
00:52:07 <Dobiasd> FreeFull: OK, I will have a look at Data.Dynamic. Thank you.
00:52:16 <bitemyapp> ellipsis_: some of the dedis Hetzner offers are anywhere from 20-100x more powerful than a typical $5-20/month VPS
00:52:40 <bitemyapp> vertical scaling can not only be cost effective, it can be effective for saving programmer time too.
00:52:44 <bitemyapp> at least for an initial ramp-up.
00:53:32 <ellipsis_> the workload probably scales really well
00:53:40 <bitemyapp> vertically and horizontally, yes.
00:53:47 <bitemyapp> it's extremely amenable to mirroring and caching too.
00:53:55 <bitemyapp> no real reason not to have a hot failover IMHO
00:54:05 <bitemyapp> in a different datacenter, ideally.
00:54:07 <ellipsis_> yeah
00:54:16 <ellipsis_> wouldn't be all that much data to push to both
00:54:24 <bitemyapp> da.
00:54:26 <FreeFull> Dobiasd: FP in general tends to separate the data and the functions that operate on it more than OO does
00:55:08 <simpson> Dobiasd: There are no classes. There are types and typeclasses.
00:55:14 <bitemyapp> Dobiasd: as you learn Haskell, having arrived from a different way of programming, you should resist the urge to emulate what you did in other languages - such as with typeclasses - and just use the basics.
00:55:26 <simpson> It *is* called the Expression Problem, not the Expression Inconvenience.
00:56:33 <bitemyapp> I personally believe Clojure does an exceptional job on the Expression Problem, at the expense of some attributes that are less nice.
00:56:36 <Dobiasd> FreeFull: Yeah, and that's cool. But doent't it get quite ugly if I have a lot of types? The functions would become very long with all the downcasting / manual type dispatching.
00:56:49 <bitemyapp> extending existing systems, libraries, etc play out very well in that language.
00:57:38 <Dobiasd> bitemyapp: OK, I was hoping that also in FP there is a way to choose one side of the "expression problem".
00:58:20 <bitemyapp> Dobiasd: http://davidvollbracht.com/blog/the-expression-problem-haskell
00:58:24 <FreeFull> Dobiasd: What do you want your software to do?
00:58:44 <bitemyapp> the only real limitation in Haskell is that you can't monkeypatch typeclasses in other libraries.
00:59:04 <bitemyapp> You can do something comparable in Scala, but that's...ick. I'm not a fan of it.
00:59:31 <Dobiasd> bitemyapp: Thanks for the link. : )
00:59:32 <bitemyapp> In Clojure extending protocols is a first-class feature, but mostly we prefer to write functions you can compose.
00:59:59 <bitemyapp> Dobiasd: but seriously, don't write typeclasses, just use functions and data.
01:00:21 <FreeFull> It might be helpful to look at existing Haskell code
01:01:13 <Dobiasd> FreeFull: I just want to know how to generally solve there problems, that seem to me to occur quite often. In most cases I use Elm at the moment, so I was hoping to find a solution that works there too. : )
01:01:48 <bitemyapp> Dobiasd: Elm doesn't have typeclasses anyway :P
01:01:57 <bitemyapp> Dobiasd: http://lambda-the-ultimate.org/node/4394
01:02:18 <FreeFull> Hmm, I don't know any big Elm codebases
01:03:21 <Dobiasd> bitemyapp: Yes, but if I understand correctly, even if I have many different types that are in the same typeclass, I still can not store them together in one list.
01:05:19 <lpaste> kryft pasted “Convoluted pattern match” at http://lpaste.net/95804
01:06:01 <kryft> How do people usually deal with convoluted pattern matches like the one in my paste?
01:09:45 <leroux> kryft: Possibly lens?
01:10:38 <kryft> leroux: Ah, I guess I really do need to learn about that at some point. :P
01:11:09 <leroux> I do too... There's a reason I said "possibly". (I haven't used it myself)
01:11:49 <bitemyapp> Dobiasd: what you're trying to do is reification. You should avoid getting into things such as this unless you have studied how other people have solved similar patterns.
01:12:00 <bitemyapp> Dobiasd: for your purposes, typeclasses are a dictionary resolved at compile time.
01:14:37 <bitemyapp> Dobiasd: envision the difference in C++ between monomorphized static methods from templates and implementations relying on vtables.
01:17:44 <arkeet> kryft: you might be interested in NamedFieldPuns
01:17:56 <arkeet> and RecordWildCards
01:17:57 <Dobiasd> FreeFull: To be more concrete: This is my current project. Storing and dispatching the "effects" are what I would solve with a virtual base class in OOP.
01:18:14 <Dobiasd> FreeFull: https://github.com/Dobiasd/Demoscene-Concentration
01:18:23 <kryft> arkeet: Thanks, I'll check those out
01:18:37 <Dobiasd> bitemyapp: Yes, I am trying to get something like vtables in Elm/Haskell. ;)
01:18:38 <arkeet> kryft: then you could have written it as Attack {canCrit = True, alwaysHits = False, ..}
01:18:42 <arkeet> after suitably renaming some of your things
01:19:21 <bitemyapp> Dobiasd: the LTU link I provided mentions how to do that.
01:19:28 <bitemyapp> Dobiasd: but I'm pretty sure it was only for typeclasses in Haskell
01:19:43 <bitemyapp> Dobiasd: Elm, as I said, doesn't have typeclasses and its unknown when it will get them.
01:19:56 <arkeet> kryft: alternatively it might simplify your Weapon pattern.
01:20:07 <bitemyapp> Dobiasd: you're going to have to manually reify this stuff to runtime if you really want it. I strongly recommend against seeking out this kind of cruft. Seriously. Just write functions/.
01:20:25 <pharaun> ^
01:20:25 <Dobiasd> bitemyapp: ok, I will read the LTU page and then think about if something is possible in Elm.
01:20:38 <kryft> arkeet: Nice
01:20:40 <pharaun> i tried to do really fancy vtables and it just ended up being pain and suffering
01:20:50 <pharaun> parameterized type records + functions did the trick for me
01:20:59 <Dobiasd> bitemyapp: Yes, but if I have functions and 100 different "subclasses" every function would be veeery long.
01:21:14 <bitemyapp> Dobiasd: dude, you can solve these problems with HOFs
01:21:18 <bitemyapp> Dobiasd: stop trying to write C++ in Haskell.
01:21:22 <FreeFull> Dobiasd: Couldn't you simply make most things polymorphic over the state, and get rid of separate types for every effect?
01:21:33 <bitemyapp> Dobiasd: learn the new tools, don't just try to shove the ones you know into Haskell.
01:21:50 <bitemyapp> I'm with FreeFull, make functions operant on context or data.
01:21:51 <kryft> arkeet: Is either of those extensions controversial? They seem pretty innocuous, but you never know
01:22:09 <Dobiasd> bitemyapp: I would like to solve it with just HOF, but I do not know how.
01:22:18 <bitemyapp> Dobiasd: learn more Haskell
01:22:18 <arkeet> kryft: nah
01:22:25 <arkeet> kryft: they're basically syntactic sugar.
01:22:46 <arkeet> right, they're listed under "syntactic extensions" in the GHC manual.
01:23:00 <bitemyapp> Dobiasd: A reasonable progression might be basic HOFs, then functors and applicatives, then monoids, then monads, then the rest of it.
01:23:00 <Dobiasd> FreeFull: Would this make it possible to not have one giant spaghetti function?
01:23:36 <bitemyapp> Dobiasd: it's called functional programming because that's the fundamental unit of expression. You can do anything you want with functions.
01:23:37 <pharaun> bitemyapp: HOFs ?
01:23:46 <bitemyapp> pharaun: higher order functions.
01:23:52 <pharaun> thanks :)
01:23:55 <bitemyapp> an example of "basic" HOFs would be filter, foldl, foldr, etc.
01:23:56 <arkeet> except haskell isn't about functions
01:23:58 <arkeet> =(
01:24:11 <bitemyapp> Haskell doesn't need to be "about" anything
01:24:39 <bitemyapp> if you're trying to get something done in Haskell, there's a toolkit made available to you. Within that toolkit are functions. Those should be the first resort for most basic programming patterns in Haskell.
01:24:40 <Dobiasd> bitemyapp: Yes sure I can do everything with just functions. That is what I am doing at the moment, I guess. But don't you think it's ugly to have one giant function?
01:24:49 <bitemyapp> Dobiasd: that's not what I'm saying :|
01:24:53 <bitemyapp> `cbp_: herro
01:24:59 <bitemyapp> Dobiasd: I'm saying COMPOSE functions.
01:25:07 <bitemyapp> Dobiasd: you realize you can pass a function to a function right?
01:25:21 <Dobiasd> bitemyapp: yes, sure.
01:25:25 <bitemyapp> I'm not trying to be an ass, I'm genuinely trying to figure out why you think using only functions means using only one function.
01:25:40 <FreeFull> Rather than having one giant function, you will have many small ones
01:25:47 <FreeFull> Very generic ones
01:25:52 <bitemyapp> Precisely. Composition of many small, generic functions.
01:25:53 <pharaun> i faced this struggle before with a project
01:26:03 <pharaun> i kept on trying to build vtable + giant records of functions
01:26:24 <bitemyapp> ^^ don't do this please.
01:26:30 <pharaun> precisely ^
01:26:32 <kryft> Yes, I've never known another language that was as good for eliminating replicated code
01:26:32 <Dobiasd> bitemyapp: OK, but I have no Idea how I can get rid of my long function in Effects.elm, even with HOFs.
01:26:49 <pharaun> its good to try it once but as you are seeing you are learning why its not exactly a good idea to do this :)
01:26:54 <bitemyapp> Dobiasd: link?
01:27:04 <Dobiasd> bitemyapp: https://github.com/Dobiasd/Demoscene-Concentration/blob/master/Effects.elm
01:27:21 <Dobiasd> bitemyapp: or here the whole thing: https://github.com/Dobiasd/Demoscene-Concentration/
01:27:24 <pharaun> Elm?
01:27:29 <Dobiasd> pharaun: yes
01:27:44 <pharaun> i think ive heard of it, looking it up
01:28:01 <bitemyapp> pharaun: FRP frontend Haskell'ish thing
01:28:16 <bitemyapp> pharaun: used to make highly interactive applications
01:28:17 <pharaun> its not a haskell dsl ?
01:28:33 <Dobiasd> pharaun: no
01:28:41 <`cbp> bitemyapp:
01:28:43 <bitemyapp> Dobiasd: stop doing that, you're reifying types when you don't need to.
01:28:43 <`cbp> hi
01:28:45 <bitemyapp> `cbp: hi
01:28:57 <bitemyapp> Dobiasd: just write generic functions that operate on data.
01:29:12 <pharaun> neat
01:29:21 <Dobiasd> bitemyapp: I would love to. :D
01:29:29 <bitemyapp> pharaun: something like Fay is more useful for the sort of stuff I do, but it's still cool.
01:29:54 <bitemyapp> I would like Fay and Elm much more if they had support for typeclasses, but of the two, Fay is much more likely to get TC support soon I think.
01:30:52 <pharaun> i have not used Fay yet, i avoid browser/js stuff
01:30:56 <pharaun> i should play with it eventually :)
01:31:43 <bitemyapp> pharaun: I don't always have a choice about avoiding browser/js stuff. Using things like ClojureScript or Fay is my way of avoiding JS while still addressing my problems.
01:32:01 <Dobiasd> bitemyapp: Do you have an example on how to solve these things without emulating OOP class stuff?
01:32:07 <joelteon> I feel like I should use Go for this project, but it doesn't have any parser combinator libraries
01:32:30 <pharaun> bitemyapp: fair enough :) i'm going to *have* to face the music one of these days, when i do i'll look into these things :)
01:32:32 <bitemyapp> joelteon: don't use Go :(
01:32:35 <pharaun> good to keep them in mind :)
01:32:36 <joelteon> meh
01:32:45 <bitemyapp> joelteon: what are you working on?
01:32:54 <joelteon> a docker container management tool
01:33:00 <joelteon> since docker is written in Go, I figured I'd just "fit in"
01:33:01 <pharaun> isn't there several now?
01:33:05 <paldepind> bitemyapp, why don's you like Go?
01:33:08 <joelteon> i don't think so
01:33:14 <bitemyapp> joelteon: funny you mention that, I've been thinking about writing dev-ops tools for things like Docker in Haskell.
01:33:15 <joelteon> well, none that do what mine does
01:33:17 <joelteon> maybe there is
01:33:24 <bitemyapp> joelteon: I've wanted to get that ecosystem rolling.
01:33:37 <bitemyapp> joelteon: so, you have my encouragement and admiration from afar if you do it in Haskell :)
01:34:00 <bitemyapp> paldepind: I don't want more code written in a language from the 1980s and 1990s to perpetuate itself any more than is necessary.
01:34:58 <paldepind> bitemyapp, do you mean Go is like a language from the 90s?
01:35:04 <bitemyapp> da
01:35:28 <pharaun> go i think has better concurrency than lots of the older languages did
01:35:29 <paldepind> I'm not surprised Go doesn't appeal to "Haskell-people"
01:35:42 <pharaun> but *shrugs* its just not all that appealing
01:35:53 <bitemyapp> paldepind: I'm not a "Haskell person", I'm just a person that programs.
01:36:01 <bitemyapp> paldepind: Haskell isn't even my main language at the moment, that would be Clojure.
01:36:04 <paldepind> But you like Haskell right?
01:36:09 <bitemyapp> Certainly
01:36:11 <pharaun> heh
01:36:16 <pharaun> mine is python at work
01:36:16 <paldepind> Which was what I meant :)
01:36:23 <pharaun> (for better n' worse)
01:36:25 <bitemyapp> paldepind: I'm not in favor of this "technology based identity" thing people do.
01:36:28 <kryft> bitemyapp: Do you find yourself missing static types with clojure?
01:36:30 <bitemyapp> You are not the programming languages you use.
01:36:41 <bitemyapp> kryft: *groans and holds face in hands*
01:36:48 <kryft> I'm not really in favor of identity at all
01:36:56 <paldepind> To me Go doesn't seem all that interesting either. But I think the focus of the language is more towards people who are tired of C.
01:36:56 <kryft> bitemyapp: What? :P
01:36:57 <bitemyapp> kryft: I don't miss static types *per se*, I miss the safety and stupid error prevention.
01:37:05 <joelteon> I thought Go was written in like 2006
01:37:18 <pharaun> sure
01:37:32 <pharaun> but in general outside of some stuff its not really pushing anything new
01:37:33 <bitemyapp> joelteon: its design is identical to languages Pike worked on in the 90s and there's little sign he or the others that worked on it have followed CS developments since then.
01:37:39 <kryft> bitemyapp: Well yes, obviously I mean "the type system and everything it gets you"
01:37:40 <bitemyapp> kryft: it's a sore subject, I've tried to explain the benefits of static typing in #clojure before.
01:37:49 <Dobiasd> bitymyapp (and FreeFull): OK, thanks for your help. I have a lot more to learn. Perhaps then I will someday understand how to solve this problem elegantly. ;)
01:37:58 <bitemyapp> kryft: they're a good lot, for sure, but it gets tiresome when you're talking to people that won't admit their language is less than perfect.
01:38:06 <pharaun> bitemyapp: me too, tho i'm not in #clojure, i've tried to explain typesystem to clojure fans at work
01:38:10 <kryft> bitemyapp: I'm not a haskell evangelist (which is good for haskell I think ;)
01:38:10 <bitemyapp> Dobiasd: it won't take long if you eschew unnecessary distractions and just use functions.
01:38:10 <pharaun> and they're still dubious about it
01:38:23 <bitemyapp> pharaun: the problem is too many of them came to Clojure from languages with garbage type systems
01:38:30 <bitemyapp> like Java, for example.
01:38:34 <pharaun> indeed
01:38:39 <bitemyapp> So static types, to them, mean none of the benefits, all of the costs.
01:38:40 <paldepind> bitemyapp, I'm sorry for expressing myself poorly then. That's actually why I put the Haskell-people part in qoutes.
01:38:46 <kryft> bitemyapp: I've read a couple of books on clojure but haven't actually done anything with it yet
01:38:50 <bitemyapp> paldepind: it's okay, just expressing an opinion.
01:38:54 <bitemyapp> kryft: I use it at work :P
01:39:09 <bitemyapp> I'm a much better Clojure programmer than Haskell.
01:39:14 <Dobiasd> bitemyapp: easier said than done. ;) I try to find an example on how somebody else solved a similar problem.
01:39:45 <pharaun> bitemyapp: haha i'm a terrible clojure programmer
01:39:52 <pharaun> just picked up on it this week for a hackathon
01:39:58 <paldepind> bitemyapp, sure. I get your point.
01:40:08 <pharaun> i understood the concept but i missed the types, and was not familiar with the ecosystem at all
01:40:09 <bitemyapp> pharaun: I've spent most of my life in dynamic languages and Lisps. Clojure was a natural fit.
01:40:15 <pharaun> makes sense
01:40:16 <kryft> bitemyapp: Right, I asked because I know a few people who use clojure at work and say it's mostly really nice but they miss having a type system
01:40:19 <bitemyapp> pharaun: Haskell required a lot more mental rewiring for me.
01:40:43 <bitemyapp> kryft: haha, yeah...I get errors in Clojure all the time that Haskell's type system will catch if you let it.
01:40:51 <pharaun> bitemyapp: indeed but thanks to the rewiring i'm now wanting haskell types in other languages :p
01:41:05 <pharaun> so when i write in python i am sad all the time
01:41:14 <bitemyapp> it's not that fixing the errors is a big deal, it's that getting the errors at compile time means I get my design closer to "right" the first time and I spend less time puzzling over absurd errors far removed from the "source" of the proble.
01:41:22 <pharaun> ^
01:41:29 <bitemyapp> pharaun: although I write Clojure at work, it's a mostly Python company.
01:41:35 <pharaun> same here
01:41:40 <bitemyapp> My next project is likely to be an ORM in Python for Datomic, if you can imagine the horror.
01:41:47 <bitemyapp> yes, an ORM. For Datomic. In Python.
01:41:52 <pharaun> i'm a python programmer, trying to get folks to look into adopting clojure
01:41:54 <pharaun> for some stuff
01:42:08 <pharaun> i would like to get my hand on more functional/lispy stuff at work :p
01:42:12 <pharaun> and haha
01:42:18 <pharaun> oh boy, tl;dr
01:42:24 <bitemyapp> legacy support.
01:42:38 <bitemyapp> Library has to "just work" even though it's a filthy stateful dirty-checking based ORM wrapper around an API
01:42:51 <bitemyapp> but we want to use a database built on immutable data...so...
01:43:22 <pharaun> bitemyapp: indeed
01:43:52 <bitemyapp> pharaun: the horror is worth it (to my mind) just for the sake of getting people past overwrite-based databases.
01:43:56 <pharaun> bitemyapp: nothing makes me cry faster than having to debug "spooky action at an distance" bought on by mocking/monkeypatching and state
01:44:03 <paldepind> I'm currently reading the Learn Yourself a Haskell book. One quick question: In the chapter on mules there's shown two different implementation of a 'findKey' function. One using recursion and one using a fold. The author recommends using the fold. But isn't using recursion more efficient since it doesn't have to go trough the entire list but can halt the recursion once a key is found?
01:44:12 <paldepind> The part of the book is here: http://learnyouahaskell.com/modules
01:44:20 <bitemyapp> pharaun: even fairly simple issues can cause source/sink error distance, like that vectors are "functions" in Clojure
01:44:22 <pharaun> bitemyapp: yeah people have some really strange attachment to state/overwrite databases
01:44:30 * hackagebot libjenkins 0.1.0.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.1.0.0 (MatveyAksenov)
01:44:38 <bitemyapp> pharaun: so you thought you got a function, you actually got a vector, and can't figure out where you fucked up a destructure and got the wrong type.
01:44:45 <pharaun> ow
01:45:12 <bitemyapp> yeah. Last time that specific issue happened, 3 experienced Clojure programmers couldn't figure it out in a whole hour
01:45:21 <bitemyapp> I had to actually make tea and sit and stare at it for 15 minutes.
01:45:39 <bitemyapp> but don't try to tell Clojure users that type errors actually matter, they'll tell you they're totally trivial.
01:45:42 <bitemyapp> Right.
01:45:47 <bitemyapp> I want my 2 fucking hours back.
01:46:04 <pharaun> bitemyapp: another fun one that i have to consistently deal with is the fact that i have to deal with no less than 4 "types" of id, and a dozen timestamp types
01:46:27 <pharaun> and with no doc/type labels i have no idea what to expect when i am looking at a new piece of code
01:46:36 <bitemyapp> pharaun: the JVM ecosystem has a type/library schism in dates.
01:46:49 <bitemyapp> pharaun: the default JVM Date library uses MUTABLE date objects to form the API
01:46:50 <pharaun> i've ran into cases where one function got feed every single "damn" types of id/time
01:46:58 <pharaun> (python here)
01:47:22 <bitemyapp> luckily the Java community wised up and made JodaTime, which uses immutable date objects which simply return results, lo and behold, works a lot better.
01:47:32 <bitemyapp> Only problem? Some libraries expect Joda instances, some expect java.util.Date
01:47:35 <bitemyapp>  :|
01:47:41 <pharaun> oh ive heard of joda time, and haha don't remind me of the old java date/time stuff
01:47:44 <bitemyapp> Clojure, Scala, and every other JVM language is affected by this schism.
01:47:53 <bitemyapp> so stupid.
01:54:52 <paldepind> Question in the gist: https://gist.github.com/paldepind/7511332
01:55:43 <bitemyapp> paldepind: foldr short-circuits
01:55:49 <bitemyapp> that's sort of the point of foldr, actually.
01:55:57 <bitemyapp> so yes, use the fold.
01:56:16 <arkeet> those two are equivalent.
01:56:22 <absence> i'm writing a parser for a strange old binary format that comes in two versions - one where offsets are relative and one where they are absolute. apart from an id they're identical otherwise. to avoid writing two nearly identical parsers, i first considered using a continuation for seeking, but maybe a Reader is enough. are there more elegant ways to handle cases like this?
01:56:58 <arkeet> in foldr, acc isn't really an accumulator
01:57:07 <arkeet> it's more like the result of folding the remainder of the list
01:57:08 <paldepind> bitemyapp, arkeet, is that something the Haskell compiles figures out? Or is it inherent to the way a fold works?
01:57:25 <arkeet> if you apply the definition of foldr to the second, you get the first.
01:57:30 <bitemyapp> absence: abstracting out the seeking into a Reader or something, with the rest of the parsing in generic functions that work on the common form of the data seems sensible to me.
01:57:36 <arkeet> in fact they probably compile to the same code.
01:59:08 <bitemyapp> paldepind: http://stackoverflow.com/questions/1757740/how-foldr-works
01:59:46 <bitemyapp> To steal from my favorite example: [1,2,3,4,5] => 1:(2:(3:(4:(5:[])))) -- sum [1,2,3] = foldr (+) 0 [1,2,3] -- [1,2,3] === 1:(2:(3:[])) -- so sum [1,2,3] === 1+(2+(3+0)) = 6
02:00:21 <absence> bitemyapp: thanks, good to hear my intuition is slowly getting to a useful level :)
02:01:13 <bitemyapp> there's a subtlety to the evaluation rules of Haskell and how foldr is defined that I haven't totally wrapped my head around.
02:01:55 <bitemyapp> Obviously the inside-out-ness of the non-strict semantics is one thing, but there's something else I haven't totally grokked yet.
02:02:35 <paldepind> bitemyapp, I pretty sure I understand how fold works. Except the short circuiting part. Is it something the compiler figures out of something related to how the function is defined? I often use folds in my JS code but I'm pretty sure the library function doesn't short circuit.
02:03:03 <bitemyapp> paldepind: there's no magic here, the compiler is an optimizing compiler, but the semantics of the language as defined are sufficient to explain all behavior in this case.
02:03:10 <bitemyapp> foldl and foldr are too fundamental for it to be otherwise.
02:03:28 <bitemyapp> paldepind: which is to say, there's no magic.
02:05:47 <paldepind> But normally a fold would run trough the entire list passed to it right? If I do: foldr f [1,2,3,4] the function `f` would be passed with the accumulator and every single element in the list on by one right?
02:06:06 * bitemyapp shakes head
02:06:11 <klugez> paldepind: foldr short-circuits due to laziness. It will start evaluating it until it gets a value. Often the folded function depends on the rest of the list, so we have to traverse the whole list. But if it at some point doesn't, we can stop early.
02:06:47 <bitemyapp> paldepind: the non-strict nature of folding in Haskell is something you're going to want to grok sooner than later.
02:07:02 <bitemyapp> "run through the entire list" is a too mechanistic and not very accurate description of the semantics.
02:07:18 <klugez> > foldr const 0 [1..]
02:07:20 <lambdabot>   1
02:07:42 <klugez> Obviously it didn't traverse the whole list.
02:07:53 <paldepind> So it is due to the property of Haskell being lazy? Had it been eager the fold wouldn't short circuit?
02:08:00 <donri> > foldr (const a) b [c,d,e]
02:08:01 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
02:08:01 <lambdabot>                ...
02:08:23 <bitemyapp> paldepind: had it been eager, the fold wouldn't have even executed, the infinite list would've stalled the code before the fold started.
02:08:40 <bitemyapp> paldepind: strictness means "outside in", non-strict in Haskell means "inside out"
02:08:42 <paldepind> bitemyapp, I meant the fold in my gist.
02:09:14 <FreeFull> > foldr (const 3) 0 [1..]
02:09:15 <lambdabot>   No instance for (GHC.Show.Show a0)
02:09:16 <lambdabot>    arising from a use of `M7671662917417...
02:09:21 <FreeFull> :t foldr (const 3) 0 [1..]
02:09:22 <lambdabot> (Num (b -> b), Num b) => b
02:09:34 <paldepind> But your example with an infinite list is good. In that case its more obvious to see that the fold short circuits.
02:09:47 <FreeFull> > foldr (const id 3) 0 [1..]
02:09:48 <lambdabot>   No instance for (GHC.Show.Show a0)
02:09:49 <lambdabot>    arising from a use of `M1536116453167...
02:10:10 <bitemyapp> paldepind: to understand the gist you pasted, look at what I showed you from that stack overflow.
02:10:15 <donri> > expr $ foldr (\a b -> if a == 5 then a else a + b) 0 [1..]
02:10:17 <lambdabot>   1 + (2 + (3 + (4 + 5)))
02:10:19 <absence> paldepind: if you call the function being passed to foldr k, and the elements of the list a0, a1, a2..., then the result is k a0 (k a1 (k a2 ...)). as soon as k returns Just something, no further evaluation is necessary
02:10:43 <absence> paldepind: by "call" i mean "name", not function call
02:10:43 <FreeFull> > foldr (const . const 3) 0 [1..]
02:10:44 <lambdabot>   3
02:10:56 <bitemyapp> FreeFull: going to some trouble there mate.
02:11:48 <paldepind> absence, I think I get I it know.
02:11:51 <bitemyapp> the left-right right-left nature of foldl and foldr take on a very different meaning in light of Haskell's non-strictness. Look at the desugared list syntax from that Stack Overflow post.
02:12:12 <paldepind> I just need to get my mind used to thinking in lazy evaluation mode.
02:12:28 <bitemyapp> you can't use fold-right on an infinite sequence in a language like Clojure or Scheme, even though Clojure supports lazy data structures, the fundamental semantics aren't lazy
02:13:37 <paldepind> It's a bit mind bending. Which is good because that's why I'm learning Haskell in the first place.
02:13:47 <bitemyapp> you'll get it in time.
02:14:31 <paldepind> :)
02:14:40 <bitemyapp> paldepind: both foldr and foldl operate on the collections passed to them left-to-right.
02:15:14 <bitemyapp> paldepind: http://foldr.com
02:15:25 <bitemyapp> paldepind: http://foldl.com
02:16:01 <bitemyapp> paldepind: think about what the parentheses mean. Just in pure mathematical terms. Don't make it "code"
02:16:10 <bitemyapp> paldepind: in the case of the foldr, who gets evaluated first?
02:16:13 <donri> you can't left fold an infinite list ever, right?
02:17:31 <arkeet> right
02:17:49 <arkeet> foldl tail recurses until it hits the end.
02:17:51 <bitemyapp> donri: http://foldl.com look at it.
02:18:00 <bitemyapp> donri: the parentheses define evaluation order.
02:18:05 <paldepind> I think I get it. The difference is not in which direction the list is passed but at which side the remaining things to process a put. Whether they're prepended or appended?
02:18:38 <bitemyapp> paldepind: it's evaluation order + non-strictness. so sorta what you said.
02:18:58 <bitemyapp> I wouldn't call it prepending/appending, that's besides the point.
02:19:13 <arkeet> the difference is that foldr f z (x:xs) = f x (foldr z xs), wihle foldl f z (x:xs) = foldl f (f x z) xs
02:19:28 <bitemyapp> donri: if the "..." is the infinite sequence and the left fold places the first result you have to evaluate in the neighborhood if infinity, then you can't sensibly get a result.
02:19:43 <donri> yes i know how foldl works, mostly i was pondering if there was some trick to never traverse the list in the first place or something :p
02:19:50 <arkeet> I don't understand what foldr.com and foldl.com have to do with foldr and foldl.
02:19:52 <donri> but guess not because the unit element is inserted at the head
02:19:59 <bitemyapp> donri: anything that could, wouldn't be a left fold.
02:20:14 <bitemyapp> arkeet: the semantics of a left and a right fold define the constraint.
02:20:35 <arkeet> I don't understand that sentence.
02:20:54 <bitemyapp> arkeet: if you're comfortable with how foldl and foldr work, then it doesn't matter if you understand what I said.
02:21:15 <arkeet> I'm saying that because I think the sentence doesn't make sense.
02:21:16 <arkeet> to anyone.
02:21:44 <paldepind> bitemyapp, thanks for you help! I think it'll click better in my brain later on.
02:22:03 <pharaun> i'm still not sure i really get foldr, it seems like you still have to eval it all to get a result anyway?
02:22:09 <bitemyapp> arkeet: I appear to have happy customers, so I'm not sure I care :)
02:22:10 <bitemyapp> pharaun: nope.
02:22:42 <bitemyapp> pharaun: have you looked at http://foldr.com/ and clicked on it a few times?
02:22:50 <bitemyapp> not trying to be a pest, I just legitimately think it helps.
02:22:57 <bitemyapp> especially when you think about the parentheses and evaluation order.
02:23:00 <pharaun> oh HA its clickable
02:23:10 <bitemyapp> aha, now it *clicks* for you.
02:23:27 <Fuuzetsu> for your sake I hope http://foldl.com exists
02:23:29 <bitemyapp> pharaun: okay, so given what you know about parentheses and evaluation order, contrast that behavior with: http://foldl.com
02:23:35 <Fuuzetsu> aww yeah
02:23:36 <bitemyapp> Fuuzetsu: it most certainly does.
02:23:49 <donri> no foldl'.com? ;)
02:23:56 <bitemyapp> donri: it's not specific to Haskell at all.
02:24:05 <pharaun> bitemyapp: sure i get that part, but if i want to (use/show/etc) the value out of foldr it still seems like i would have to eval all thunks anyway
02:24:24 <bitemyapp> pharaun: well you only eval as far as you traversed the list.
02:24:30 <arkeet> hmm, I wonder whether one can make a lazier foldl
02:24:33 * hackagebot fixed-vector 0.6.0.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.6.0.0 (AlexeyKhudyakov)
02:24:35 * hackagebot thorn 0.1.0.3 - Datatype Manipulation with Template Haskell  http://hackage.haskell.org/package/thorn-0.1.0.3 (Kinokkory)
02:24:45 <pharaun> bitemyapp: let me play with it in ghci
02:24:55 <bitemyapp> experimentation is always good.
02:25:05 <pharaun> i tend to learn better that way fwiw
02:25:13 * bitemyapp shrugs
02:25:21 <bitemyapp> I learn better from poking at things too.
02:25:25 <bitemyapp> I just found foldr/foldl very helpful.
02:25:31 <bitemyapp> uh, the little webpages I mean.
02:25:31 <pharaun> fair enough :)
02:25:38 <pharaun> its cute :)
02:25:53 <pharaun> great way to show how the thunks/etc is eval'd
02:26:00 <xendron99> I woke up and decided today is the day I learn Haskell (experience in C,Python,Lisp,...) where to start?
02:26:10 <arkeet> xendron99: learn you a haskell :-)
02:26:10 <pharaun> lyah or rwh ^
02:26:11 <arkeet> @where lyah
02:26:11 <lambdabot> http://www.learnyouahaskell.com/
02:26:21 <arkeet> I don't recommend rwh as an introduction.
02:26:37 <pharaun> arkeet: how come? i dove directly into rwh
02:26:39 <bitemyapp> xendron99: I'm going to dissent and say http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ followed by RWH or personal projects.
02:26:52 <bitemyapp> xendron99: I'm not a huge fan of RWH in general, but some people may favor its approach.
02:26:57 <arkeet> pharaun: I don't think it's as good an introduction.
02:27:00 <bitemyapp> luckily, it's a free book online so you can test it for yourself.
02:27:06 <pharaun> arkeet: fair enough
02:27:22 <arkeet> that's not to say it wouldn't be worth going through later.
02:27:26 <bitemyapp> I really like that Yann Eposito tutorial I posted, I just wish he would fix the couple instances of broken code.
02:27:32 <pharaun> indeed
02:27:40 <xendron99> google pointed me to learnyouahaskell
02:27:42 <bitemyapp> RWH covers some nice practical exercises, but I don't think it explains things very well.
02:27:57 <skypers> hey, imagine you have a type, like String, and you want to perform several IO actions which takes the same String
02:28:02 <skypers> how would you do?
02:28:02 <bitemyapp> a good example of where it falls flat here is how I just explained foldl/foldr. I think it does a *terrible* job with fundamentals like that.
02:28:09 <skypers> for now I use something like
02:28:11 <pharaun> well rwh got me coding some functional stuff pretty quickly then i started filling in the fundamentals
02:28:19 <skypers> sequence_ (actions <*> theString)
02:28:29 <skypers> and actions is [String -> IO ()]
02:28:40 <bitemyapp> pharaun: anything that works is good, I just found my knowledge of Haskell was still extremely shaky after RWH even though I could kinda-sorta cobble some practical stuff together.
02:28:43 <arkeet> skypers: ReaderT?
02:29:04 <pharaun> bitemyapp: fair enough, i have actually never read lyah, i should probably read it to see if i missed out on anything
02:29:08 <xendron99> is rwh similar to their head first books? they are a bit slow...
02:29:14 <skypers> arkeet: yeah, well, you mean
02:29:14 <bitemyapp> pharaun: to be clear, I'm not endorsing LYAH either.
02:29:29 <skypers> f = do { action1; action2; action3 }
02:29:29 <pharaun> tho i've probably been coding long enough in haskell that i got most down if only via intution/experience
02:29:31 <skypers> f theString
02:29:32 <skypers> ?
02:29:34 <bitemyapp> pharaun: I think LYAH has some good sections and explains some fundamentals better than RWH, but it's only a "start".
02:29:39 <pharaun> ya
02:29:42 <skypers> that won’t work, it only use action3
02:29:46 <arkeet> skypers: what?
02:29:52 <bitemyapp> pharaun: I really think the mathy bits help a lot.
02:29:53 <skypers> it’ll*
02:30:10 <bitemyapp> none of the math relevant to Haskellers is terribly difficult and it eradicates a lot of mystery rather quickly.
02:30:16 <bitemyapp> like folds.
02:30:28 <arkeet> do { a x; b x; c x }  =  runReaderT (do { ReaderT a; ReaderT b; ReaderT c }) x
02:30:36 <bitemyapp> it's just parentheses and evaluation order. Stuff a child in primary school could understand.
02:30:41 <pharaun> heh
02:30:53 <bitemyapp> I'm not trying to put down people that don't get it, I was stuck for a bit too.
02:30:54 <skypers> arkeet: isn’t it faster to use sequence_?
02:31:00 <donri> see also: zygohistomorphic prepromorphisms
02:31:06 <bitemyapp> But I don't think this is because people are deficient, I think it's because the way things are explained is deficient.
02:31:07 <arkeet> skypers: well, you'll have to tell a bit more about what you're trying to do.
02:31:11 <pharaun> i never had much issues with fold, i just never really got the use of foldr, but then again most of the time when i reached for fold i was "summing" stuff up to spit out one result
02:31:22 <bitemyapp> donri: that's just cherry-picking :)
02:31:46 <bitemyapp> pharaun: if you can be less specific about "how" the computation is acquired while still being truthful to the desired outcome that is better.
02:31:47 <skypers> arkeet: well I have n functions, with different types but taking the same final argument, a String
02:31:57 <bitemyapp> pharaun: and is in keeping with the declarative way one is supposed to write Haskell programs.
02:31:58 <arkeet> can you paste any code?
02:32:00 <skypers> and I want to share a String between those functions
02:32:07 <donri> see also: monoids in the category of endofunctors
02:32:14 <skypers> hurh, it’s just a common issue, I don’t have code no
02:32:19 <pharaun> donri: ha
02:32:26 <bitemyapp> pharaun: accordingly, reduce in Clojure is "fold left", but you have to give up the order specificity and write commutative functions in Clojure to get parallelized reducers (generic fold, no guaranteed evaluation order)
02:32:29 <skypers> I read the (>>=) version for ((->) r)
02:32:33 <skypers> it sounds to solve the issue
02:32:43 <skypers> but it just won’t work with IO actions
02:32:45 <bitemyapp> pharaun: this is because, lo and behold, the less you specify about *how* a computation is performed, the more the computer can do to help you.
02:32:48 <arkeet> skypers: use ReaderT, then.
02:32:58 <pharaun> bitemyapp: ahh, yeah
02:32:58 <bitemyapp> pharaun: tl;dr you were doing the right thing by just "fold"ing
02:33:05 <arkeet> ((->) r) is Reader r
02:33:16 <donri> @src (->) (>>=)
02:33:16 <lambdabot> f >>= k = \ r -> k (f r) r
02:33:43 <skypers> yeah but, why would it change with monadic functions?
02:34:08 <arkeet> skypers: do you mind writing a small code example and pasting it?
02:34:32 <skypers> ok then, wait
02:35:08 <bitemyapp> pharaun: it's worth noting that you end up writing your Scheme code in CPS style if you want things like a short-circuiting fold.
02:35:15 <arkeet> because ReaderT is supposed to solve precisely that.
02:35:25 <bitemyapp> this is tedious, annoying, and error prone if you aren't keeping track of how your operations are nested.
02:35:50 <bitemyapp> Haskell eliminates the necessity of that irritation.
02:36:18 <arkeet> note: using foldr instead of explicit recursion can be *faster*, because of stuff like fusion.
02:36:37 <pharaun> i try to stay with HOFs as much as i can :)
02:36:38 <bitemyapp> because you're specifying less of how to perform the computation and just speaking to the results you want.
02:36:54 <skypers> ok arkeet:
02:37:01 <pharaun> because i figure most stuff are going to have fusion and/or tweaks to speed things up and i'm being less specific so they can do more magic under the hood as needed
02:37:03 <bitemyapp> I find recursion confuses me if I go too deep with it anyway, and 90% of the times I've thought I wanted recursion I actually just wanted a fold or short-circuiting fold.
02:37:09 <pharaun> yup
02:37:12 <arkeet> skypers: I mean on lpaste or something
02:37:18 <bitemyapp> the last time I actually needed recursion was for a very strange use-case that could've been refactored into a fold.
02:37:20 <skypers> can’t we do it here with lambdabot ?
02:37:25 <bitemyapp> and it was my own dumb fault for not doing so.
02:37:28 <arkeet> if it's one or two lines then ok
02:37:28 <pharaun> bitemyapp: i haven't used short-circuiting fold much at all, i need to play with that more :)
02:37:35 <skypers> yeah it is
02:37:38 <skypers> > let actions = [putStrLn . ("Hi, "++),putStrLn . (++", how do you do?")]
02:37:39 <lambdabot>   not an expression: `let actions = [putStrLn . ("Hi, "++),putStrLn . (++", h...
02:37:46 <skypers> ok nevermind, lpaste.
02:37:56 <bitemyapp> pharaun: it's critical for some of the more tricksy data processing stuff I do at work. of course, "short circuiting fold" in Clojure means left-fold (reduce) + reduced.
02:38:03 <pharaun> bitemyapp: heh i often go for naive recursion for the first version but often before i commit it it has been generalized/made better via folds/other nice HOfs
02:38:15 <bitemyapp> reduced being the sad-face hack to short-circuit reduce in Clojure
02:38:24 <pharaun> ah
02:38:25 <skypers> arkeet: http://lpaste.net/95805
02:38:27 <bitemyapp> pharaun: I've been getting better at thinking directly in folds and writing that version first.
02:38:30 <pharaun> bitemyapp: do you have an example ?
02:38:42 <pharaun> it would be helpful (of a short circuit fold?)
02:38:56 <bitemyapp> fold yes, short-circuiting, maybe.
02:39:02 <bitemyapp> let me see what of my work code I can possibly sanitize.
02:39:05 <pharaun> sure
02:39:22 <pharaun> i'm probably just being tired/dummy in that i can't think of a case atm :)
02:39:24 <bitemyapp> sigh, nada.
02:39:31 <pharaun> aw :p
02:39:32 <arkeet> skypers: well, for such a small thing I probably would just do it directly like that, but:
02:39:34 <bitemyapp> uhm, I have a loop/recur form that is short-circuiting
02:39:37 <lpaste> arkeet annotated “No title” with “No title (annotation)” at http://lpaste.net/95805#a95806
02:39:37 <bitemyapp> and is just a fold.
02:39:41 <bitemyapp> let me see if I can demonstrate.
02:39:47 <pharaun> sure
02:39:59 <bitemyapp> yeah, got it.
02:40:15 <bitemyapp> I'll write a sanitized version.
02:40:28 <skypers> I see arkeet
02:40:34 <skypers> thank you
02:41:13 <arkeet> @unmtl ReaderT r IO a
02:41:13 <lambdabot> r -> IO a
02:41:23 <bitemyapp> pharaun: https://www.refheap.com/20967
02:41:38 <bitemyapp> pharaun: "take two items out, merge them into a single item, put them back in the collection"
02:42:11 <bitemyapp> pharaun: plus, "short-circuit and return the final, completely merged item if count == 1"
02:42:25 <bitemyapp> ie, that's a fuckin' fold, but I'm a moron and wrote it as loop/recur.
02:42:34 <pharaun> ah
02:42:42 <bitemyapp> pharaun: make sense?
02:43:15 <bitemyapp> the other part that makes it awkward
02:43:27 <bitemyapp> is that the "carried" value is also the iteratee.
02:43:37 <bitemyapp> that was the other reason I didn't use a normal fold.
02:43:37 <jle`> any haskell libraries that can render latex math equations to an image file
02:43:45 <bitemyapp> the awkwardness made my liver ache.
02:43:51 <jle`> hoping for something self-contained so i don't have to install anything else on my production servers
02:43:57 <pharaun> hehe
02:44:07 <bitemyapp> pharaun: you know that feeling, right?
02:44:12 <pharaun> yup
02:45:15 <bitemyapp> jle`: you're pretty much describing LaTeX. I understand why you'd want to avoid installing that.
02:45:22 <bitemyapp> jle`: is it possible your needs can be simplified to mathjax?
02:45:31 <bitemyapp> or something comparable, which would be much much much lighter-weight?
02:45:34 <pharaun> matjax isn't too bad
02:46:54 <bitemyapp> jle`: http://www.mathjax.org to be specific.
02:47:05 <bitemyapp> there are similar alternatives, but that's probably one of the nicer ones I'm aware of.
02:47:40 <bitemyapp> jle`: if that isn't acceptable there are ways to setup "LaTeX as a service", either through a third-party's API or your own.
02:47:51 <bitemyapp> if, again, you don't want to deploy an embedded LaTeX install in your application.
02:48:12 <bitemyapp> I would recommend avoiding having to use a full LaTeX install if at all possible.
02:48:33 <bitemyapp> the last time I compiled LaTeX I ended up going to sleep in the hopes I'd have a compiler in the morning.
02:48:45 <arkeet> mathjax is pretty good.
02:49:00 <pharaun> i wonder if you can't just install a very small subset of latex just for the math bits?
02:49:03 <bitemyapp> it's as good as we're likely to get for in-browser support for the time being.
02:49:10 <pharaun> but that would probably be... quite tricky
02:49:16 <bitemyapp> pharaun: I wondered the same thing, but my attempts at googling that were foiled.
02:49:26 <bitemyapp> it appears it's 1gb install or nothing in LaTeX-land these days :P
02:49:35 <bitemyapp> I'm sure such a thing exists, I just can't find it right now.
02:49:38 <pharaun> erf, i like latex but not on a server :p
02:49:46 * bitemyapp shrugs
02:50:05 <jle`> the reason why i want to avoid a js solution
02:50:16 <jle`> is that i want something that sites like Pocket/instapaper will render properly
02:50:23 <jle`> so i might want an image
02:50:26 <bitemyapp> jle`: heh, you can do that.
02:50:28 <jle`> but maybe those sites are smart enough to support it
02:50:31 <pharaun> they can't handle mathjax
02:50:32 <bitemyapp> jle`: you render the image in nodejs yo.
02:50:36 <pharaun> lol
02:50:37 <bitemyapp> jle`: and cache it.
02:50:40 <pharaun> oh hm
02:50:48 <pharaun> mathml too?
02:50:50 <jle`> like on a headless browser
02:50:52 <jle`> ?
02:50:53 <bitemyapp> jle`: http://phantomjs.org
02:50:54 <pharaun> tho isn't that more of an firefo thing
02:50:55 <bitemyapp> jle`: yep!
02:51:14 <bitemyapp> phantomjs + dummy page with mathjax + inject content, save image out, cache it on your server.
02:51:46 <bitemyapp> I feel indescribably dirty writing that, but hacks always cheer me up :)
02:51:55 <jle`> this is now about whether or not i would prefer to install nodejs or latex on my server
02:52:02 * bitemyapp laughs
02:52:26 <pharaun> jle`: pick the lesser of the [2 ...] evils
02:52:48 <jle`> i am looking into something called gladtex
02:53:31 <pharaun> jle`: i wonder if instapaper/pocket can handle "mathML"
02:53:33 <bitemyapp> jle`: also: http://www.math.union.edu/~dpvc/jsMath/
02:53:35 <pharaun> which is basically xml math :p
02:53:44 <bitemyapp> pharaun: extremely unlikely IMO
02:53:50 <arkeet> jsmath is slow and ugly in my experience.
02:53:53 <pharaun> you're probably right bitemyapp
02:53:54 <bitemyapp> pharaun: they basically strip all sophisticated rendering of the content out.
02:53:58 <arkeet> especially compared to mathjax
02:54:01 <pharaun> that's unfortunate
02:54:15 <bitemyapp> only raw <img> tags and text in those reader applications.
02:54:26 <bitemyapp> they're not really optimized for people doing work, sadly.
02:54:35 <bitemyapp> neither is my kindle, tho I love it
02:54:51 <pharaun> indeed
02:54:54 <jle`> huh. google offers a latex api
02:54:56 <jle`> http://johnmacfarlane.net/pandoc/demo/mathWebTeX.html
02:55:12 <bitemyapp> expect it to get shut down in the 6 months.
02:55:16 <pharaun> ^
02:55:17 <bitemyapp> anything Google has made that I like gets killed.
02:55:24 <bitemyapp> seriously, like...everything.
02:55:52 <bitemyapp> I've even built applications that relied on APIs they've shut down.
02:55:55 <bitemyapp> APIs I would've happily paid for.
02:56:01 <bitemyapp> No more.
02:56:11 <donri> wikipedia seems to be using texvc to render math to png
02:56:54 <bitemyapp> donri: texvc appears to be equivalent to just installing LaTeX
02:57:11 <bitemyapp> we're trying to avoid that in this case.
02:57:13 <donri> yes. why is that not an option?
02:57:19 <bitemyapp> it's annoying and takes awhile.
02:57:26 <bitemyapp> I chose not to question jle` on that.
02:57:27 <pharaun> and jle` said he didn't want to
02:57:28 <pharaun> fwiw
02:57:37 <bitemyapp> and mostly just wanted to entertain alternatives because they interest me.
02:57:42 <pharaun> so trying to find some alternative solutions
02:57:52 <bitemyapp> I would personally love a lightweight alternative to LaTeX that didn't mean using a browser/phantomjs/node.js
02:57:56 <jle`> i'm deploying to heroku too so i'd probably need to write a custom buildpack
02:58:02 <bitemyapp> oh god fuck that
02:58:06 <bitemyapp> jle`: yeah you're fucked, lol.
02:58:14 <jle`> a custom buildpack if i want to install latex, that is
02:58:20 <pharaun> lol
02:58:20 <jle`> i can install haskell stuff fine
02:58:28 <bitemyapp> this is why I use VPSes and dedis, no offense.
02:58:28 <pharaun> i was going to suggest pandoc
02:58:38 <pharaun> but saw that its output were all mathml or matjax or latex
02:58:45 <bitemyapp> because I can just `sudo apt-get install ...` whatever I need.
02:58:58 <jle`> none taken
02:59:10 <jle`> heroku is free :)
02:59:19 <bitemyapp> nothing is free, some things are just freely given.
02:59:29 <pharaun> i still think there should be a way to make latex very slim, just take the "latex executable, the math tex stuff, few other stuff" done, i don't know :S
02:59:39 <pharaun> but i bet you a dollar... it will be a severe pain in the rear :)
03:00:25 <bitemyapp> pharaun: http://www.tug.org/mactex/morepackages.html "BasicTeX" is 86M
03:00:28 <jle`> gladtex will take HTML w/ latex math, render the image, and replace the text with a url
03:00:40 <bitemyapp> pharaun: but it's Mac only :P
03:01:11 <bitemyapp> pharaun: Debian equivalent appears to be: http://packages.ubuntu.com/trusty/texlive-base
03:01:18 <bitemyapp> ~50MB?
03:01:26 <bitemyapp> I think BasicTeX is a bit more functional.
03:02:35 <pharaun> oh so someone already did it nice
03:02:50 <bitemyapp> Yep
03:03:39 <pharaun> 50mb isn't too bad
03:03:40 <pharaun> tho i do wonder what the math package would drag in
03:03:40 <pharaun> depending on if jle` want to do the really fancy math like ams/whatever
03:03:40 <pharaun> brb
03:03:47 <jle`> i think i am going to use the google api for now
03:03:59 <jle`> and try to work on a solution in the meantime for the future
03:04:06 <bitemyapp> kick the can :)
03:04:17 <jle`> i do want to avoid installing tex though
03:04:25 <jle`> but there seems to be other possible solutions
03:04:28 <jle`> thanks guys
03:05:03 <jle`>  /girls
03:17:54 <skypers> arkeet: I have several lines to show you, it’s from my 3D engine, I’d like having your opinion if you don’t mind :)
03:18:26 <skypers> the createGBuffer function: https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Core/DeferredRenderer.hs#L59
03:19:28 <skypers> I don’t use Reader at all in the withFramebuffer function
03:19:38 * hackagebot labyrinth 0.5.0.0 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.5.0.0 (AlexeyKotlyarov)
03:30:01 <Dobiasd> bitemyapp: Hi again. I think I now have a OK solution for my problem we discussed earlier. The trick is (as you said) not to store objects but functions in a list. This is my code at the moment: http://codepad.org/5zIr2TBt
03:30:22 <Dobiasd> bitemyapp: It should also work in Elm. I will translate it to my project today.
03:34:46 <arkeet> skypers: I would use mapM_ in that case actually
03:34:57 <arkeet> mapM_ ($ tt) (actions f i)
03:35:28 <skypers> hm, yeah
03:35:32 <skypers> :)
03:35:34 <arkeet> :)
03:36:02 <bitemyapp> Dobiasd: seems better, can't say for sure since I don't know your problem domain all that well. Good luck :)
03:36:23 <Dobiasd> bitemyapp: Thanks for your help again. : )
03:39:35 <pharaun> oh that reminds me, i have an parsec question - I can run parsec on Text but it keeps on emitting Chars/String, is there a version of Text.Parsec.Char that emits Text chars?
03:40:28 <donri> Text doesn't have a Char primitive
03:40:31 <donri> it just uses Char
03:41:00 <pharaun> so i'm just going to have to expect to occasionally repack my parse back into Text ?
03:41:32 <donri> if you need to look at individual chars, yes
03:42:28 <pharaun> not as nice as i would like but i guess i can live with that for the textual data that i do intend to keep
03:42:43 <donri> in particular, Char is the token type of the Text stream. you can have your own token parser though
03:48:16 <pharaun> right now i'm tripping up on -     No instance for (Stream T.Text Identity Char) - string
03:48:23 <pharaun> hm
03:49:42 <donri> pharaun: have you imported Text.Parsec.Text?
03:49:51 <donri> (best module name ever)
03:49:56 <pharaun> *facepalm*
03:49:59 <pharaun> i forgot :)
03:50:08 <donri> yeah, stupid orphan instances in parsec
03:50:37 <pharaun> ok now that works, got other types to fix up but i got that to go away
03:50:39 <pharaun> thanks donri
03:51:05 <donri> np
03:52:39 <tharper> wah, I just tried to punctuate my expression in ghci with a full stop
03:52:44 <tharper> I'm so sorry.
03:55:25 <FireFly> You should try Prolog someday
03:55:25 <pharaun> ahhh
03:55:26 <pharaun> much better
03:56:24 <donri> or smalltalk?
03:57:08 <FireFly> doesn't Erlang use terminating '.'s too?
03:57:17 <Rembane> It does.
03:57:23 <Rembane> Inspired by Prolog.
03:57:27 <FireFly> Ah
03:57:45 <eevar> is it possible to build packages in a sandbox and then install them in ~/.cabal ?
03:58:11 <eevar> or do I nuke my sandbox and then install?
03:59:17 <donri> eevar: or possibly install --user
04:00:11 <eevar> tried that and it just wound up in the sandbox
04:01:22 <lpaste> Pharaun pasted “Why is this Illegal?” at http://lpaste.net/95807
04:02:08 <pharaun> is this something to do with the fact that string is basically "type String = [Char]" ?
04:02:09 <eevar> guess what I'm really trying to do is use a non-hackage library without polluting  ~/.cabal with all it's dependencies
04:02:24 <mauke> pharaun: yes
04:02:33 <mauke> String is a type synomynm
04:02:42 <pharaun> well is there any way to do what i want here or ?
04:03:01 <pharaun> i guess i could do [Char] ?
04:03:12 <mauke> you could read the error message
04:03:27 <donri> it'll still require FlexibleInstances
04:03:47 <pharaun> the wiki wasn't really descriptive - https://ghc.haskell.org/trac/haskell-prime/wiki/TypeSynonymInstances
04:04:31 <mauke> why are you looking at the haskell prime wiki?
04:04:50 --- mode: ChanServ set +o mauke
04:04:50 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub' by mauke
04:05:26 <pharaun> first google result, i'm not sure of a better source that describes these extensions and on if i would want to enable them or if i should avoid them and approach my code in a different direction
04:05:39 <donri> ideally you would do something like instance (PackToText a) => PackToText [a] where toText = mconcat . map toText  -- but i'm not sure the overhead here will be optimized away :p
04:06:08 <mauke> pharaun: that page assumes you already know what the extension does. it's discussing whether it should be part of the haskell standard
04:06:50 --- mode: mauke set -o mauke
04:06:59 <pharaun> is there a better source? :)
04:07:39 <donri> a less general alternative is instance (a ~ Char) => PackToText [a] where toText = T.pack
04:07:49 <donri> which needs TypeFamilies
04:08:13 <pharaun> would i prefer that over TyeSynonymInstances and FlexibleInstances ?
04:08:25 <donri> FlexibleInstances makes for bad type inference
04:08:29 <pharaun> and i can probably run some benchmark on the mconcat . map toText
04:08:34 <donri> not sure it'll matter in your case but i try to avoid it
04:09:03 <pharaun> i mainly want to do that so i don't have to do T.pack or T.singleton all over as i parse/extract stuff because sometime i do have to extract it on a per character/word basis
04:09:57 <mauke> I use FlexibleInstances wherever I need it
04:11:20 <raek> pharaun: you could skip the Char instance and wrap the argument to <++> in [ ] whenever it is a char
04:11:40 <donri> raek: that doesn't help here though
04:11:59 <pharaun> raek: sure but the [Char] is the one that i'm stuck on (String)
04:12:27 <raek> hmm
04:12:32 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls
04:13:05 <donri> pharaun: basically with FlexibleInstances toText applied to a list is ambiguous unless the list elements are known to be Char
04:13:13 <donri> not a big deal but can be an annoyance
04:13:36 <pharaun> i would like it to be as specific, so it seems like TypeFamilies would be better? unless there's other pitfalls
04:13:41 <pharaun> digging around in the docs
04:14:58 <donri> pharaun: yes. [Char] means "a list where the elements are Char" and (a ~ Char) => [a] means "all lists, and the elements must be Char"
04:15:47 <donri> pharaun: the pitfall is that you can't have any other list instance. that's also why it isn't ambiguous.
04:16:13 <pharaun> donri: ie i can't have [Text] be an instance of this ?
04:16:21 <donri> in deed
04:16:25 <pharaun> hm
04:16:52 <pharaun> in that case i would be doing an explicit concat first which is a much rarer case so i think i can live with that in this specific case.
04:17:00 <donri> pharaun: on the other hand you get that instance "for free" with the mconcat version
04:17:05 <pharaun> yeah
04:17:16 <pharaun> I could probably do some form of benchmark on that and see
04:17:52 <donri> yeah, it might not be that bad because T.concat is probably finely tuned
04:19:37 <Dasuraga> I'm looking at lazy ByteStrings, does a recv just recieve info continuously until the socket closes?
04:19:38 <donri> ie. it writes into one new array rather than simply folding with mappend
04:19:59 <pharaun> its not super critical to be the fastest here but i'm kinda pretty curious actually
04:20:06 <pharaun> so i'm going to try to do a quick n' dirty benchmark
04:21:00 <Dasuraga> sorry, I meant getContents
04:21:00 <arkeet> pharaun: use criterion ;)
04:21:06 <arkeet> it makes benchmarking easy adn fun.
04:21:07 <pharaun> arkeet: i am :)
04:21:08 <arkeet> ok
04:21:13 <pharaun> i've used it tons before <3
04:21:16 <arkeet> :)
04:21:18 <pharaun> arkeet: thanks for double checking :D
04:22:29 <donri> Dasuraga: just guessing but i'd expect it semi-closes stdin and then reads chunks on demand
04:23:52 <donri> Dasuraga: ie. if you peek at the first byte, it'll read 32k bytes, if you peek at the next byte, it's already read. if you peek at the 32k+1th byte, it reads another 32k bytes ...
04:26:47 <donri> Dasuraga: btw semi-closed means it behaves as if closed, for other operations, but isn't actually closed until the first getContents reaches EOF
04:27:50 <Dasuraga> huh... ok. Performance-wise I guess it's equivalent to doing a bunch of recvFroms by hand right?
04:30:41 <darthdeus> hey guys, i'm having trouble following learn you a haskell .. one of the samples is giving me Not in scope: data constructor `Writer'  Perhaps you meant `WriterT' (imported from Control.Monad.Writer)
04:30:51 <darthdeus> even though i have the same import as he mentions, on Control.Monad.Writer
04:31:25 <donri> darthdeus: yeah, Writer is a type synonym these days
04:31:32 <donri> which means it has no data constructor
04:31:36 <darthdeus> ah :(
04:31:56 <donri> Dasuraga: don't know
04:32:23 <darthdeus> donri: is there something i can do to make it work though?
04:32:43 <donri> darthdeus: use the functions "writer" and "runWriter" instead
04:33:20 <donri> "writer" is equivalent to using Writer as a constructor, "runWriter" is equivalent to pattern matching on the constructor
04:35:11 <donri> darthdeus: for example, logNumber x = writer (x, ["Got number: " ++ show x])  -- note lower case writer
04:35:19 <donri> darthdeus: it's still capitalized Writer in the type though
04:39:44 * hackagebot wraxml 0.4.4 - Lazy wrapper to HaXML, HXT, TagSoup via custom XML tree structure  http://hackage.haskell.org/package/wraxml-0.4.4 (HenningThielemann)
04:39:46 * hackagebot tagchup 0.4.0.3 - alternative package for processing of tag soups  http://hackage.haskell.org/package/tagchup-0.4.0.3 (HenningThielemann)
04:39:48 * hackagebot mohws 0.2.1.3 - Modular Haskell Web Server  http://hackage.haskell.org/package/mohws-0.2.1.3 (HenningThielemann)
04:42:19 * mangaba_leitosa profiled his word frequency counting using -with-rtsopts='-sstderr'. 886,108,144 bytes allocated in the heap; 239,738,856 bytes copied during GC; %GC     time      76.3%  (74.9% elapsed); Productivity  23.7% of total user, 23.3% of total elapsed
04:42:33 <mangaba_leitosa> seems like there is room for more optimizations :-)
04:44:45 * hackagebot xml-basic 0.1.1.3 - Basics for XML/HTML representation and processing  http://hackage.haskell.org/package/xml-basic-0.1.1.3 (HenningThielemann)
04:46:17 <mangaba_leitosa> ah, no. with -with-rtsopts=-H128m, productivity rises to 86% :-)
04:56:39 <lpaste> pharaun pasted “Benchmark of mconcat . map & T.singleton & T.pack” at http://lpaste.net/95809
04:56:51 <pharaun> donri: ^
04:57:42 <pharaun> the string/text length is probably way too short, going to drop out the char and enlargen those and see how that changes things
04:59:38 <pharaun> running an version with longer text length
05:04:42 <pharaun> anyway seems like mconcat is slower - 7us vs T.pack at 1.1us
05:04:47 * hackagebot aws 0.8.3 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.8.3 (AristidBreitkreuz)
05:05:08 <pharaun> but *shrugs* i think at this point i'll live with that because it seems fast enough in my use case
05:05:08 <Malar> any progress on haskell bindings for wayland?
05:14:04 <donri> hm is it just for me hackage is being really slow but not actually down?
05:15:16 <jrmithdobbs> I've had it occasionally start to slowly respond for 1 or 2 page elements before the timeout....
05:15:41 <jrmithdobbs> But haven't seen it complete an entire resource req in >24 hours
05:16:08 <jrmithdobbs> Getting annoying ;p
05:27:25 <jrmithdobbs> donri: It's working for me now...
05:28:10 <jrmithdobbs> Not even particularly slowly...
05:37:51 <piezo> I've just read the  StackOverflow responde about which case defining new class are "legit"
05:38:27 <piezo> Yesod use a lot of type class to define behaviour of types
05:39:07 <piezo> so I'm wondering what would be a better alternative ? (records of functions ?)
05:41:00 <piezo> more precisely *instances* define behaviour, like in implementation of java interfaces for example
05:44:39 <zomg> piezo: I think yesod does a lot of type trickery so you can easily switch out things like the database backend and whatnot so it needs to use typeclasses for that sorta stuff
05:47:32 <piezo> ok, so it's like a plugin system, sort of
06:00:16 <vlatkoB> Must filter a map "filter :: (a -> Bool) -> Map k a -> Map k a", but have (a -> IO Bool) only.
06:00:16 <vlatkoB> Any simple way to achive that?
06:01:38 <donri> :t T.sequence . M.filter (return . f)
06:01:40 <lambdabot>     Couldn't match type `m1 b0' with `Bool'
06:01:40 <lambdabot>     Expected type: b0 -> Bool
06:01:40 <lambdabot>       Actual type: b0 -> m1 b0
06:04:59 <donri> :t fmap M.fromList . filterM (return True) . M.toList
06:05:00 <lambdabot>     Couldn't match type `Bool' with `f0 Bool'
06:05:00 <lambdabot>     Expected type: (k0, a0) -> f0 Bool
06:05:00 <lambdabot>       Actual type: (k0, a0) -> Bool
06:05:11 <donri> :t fmap M.fromList . filterM (\_ -> return True) . M.toList
06:05:12 <lambdabot> (Monad f, Functor f, Ord k) => M.Map k a -> f (M.Map k a)
06:08:30 <vlatkoB> donri, just did something similar myself. Thanks!
06:08:48 <akamaus> I have a project consisting of about a dozen of modules. I decided to reorganize them in a hierarchy. Is there any tool for helping with module renames?
06:14:29 <donri> :t fmap (fmap fst . M.filter snd) . T.mapM (\a -> return (a,True))
06:14:29 <lambdabot> (Monad f, Functor f) => M.Map k b -> f (M.Map k b)
06:15:46 <donri> :t fmap (fmap fst . M.filter snd) . traverse (\a -> pure (a,True))
06:15:46 <lambdabot> Applicative f => M.Map k b -> f (M.Map k b)
06:16:06 <donri> vlatkoB: ^ avoiding list conversion. duno if faster
06:17:58 <donri> akamaus: darcs ;)
06:21:10 <akamaus> donri, oh, never used that feature. And it's a git repository anyway.
06:25:41 <piezo> is there a way to force ghci to access to hidden module definitions ?
06:27:22 <gienah> piezo: :set -package pkgname
06:27:27 <Earnestly> Does ghci read some kind of environment variable to look in a different directory than ~/.ghci (on Linux)?
06:28:38 <donri> Earnestly: that's not a directory, normally
06:28:45 <Earnestly> It can be
06:29:07 <donri> Earnestly: what's in it?
06:29:31 <Earnestly> Uh, I mean .ghc
06:29:43 <donri> Earnestly: GHC_PACKAGE_PATH IIRC
06:29:58 <donri> https://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#ghc-package-path
06:30:11 <piezo> gienah: i get "package flags have changed, resetting and loading new packages...", but the module still can't be load (by import and :l)
06:30:52 <gienah> piezo: strange, it works with: :set -package ghc
06:30:57 <Earnestly> donri: Hm, that should do nicely.  Thank you
06:31:46 <donri> Earnestly: also -package-db for flag version
06:32:35 <piezo> gienah: i tried "ghci -package shakespeare-css" too
06:32:51 <Earnestly> donri: Ah no, I just want to move as much as I can out of $HOME.  We've had XDG for awhile now and it's lovely
06:33:23 <Earnestly> Although many programming languages seem to be behind the times in that regard, mostly because it's not all that important I'll admit.
06:33:44 <klugez> piezo: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/interactive-evaluation.html#ghci-scope - Try :module + *Module
06:34:17 <gienah> piezo: another thing to try is to check that shakespeare-css is listed in the .cabal file
06:35:31 <donri> Earnestly: not sure it lets you configure the location of the user db though
06:35:56 <donri> Earnestly: my suggestions only let you point to individual packages. not even as collections
06:37:21 <piezo> gienah: it is, but how ghci look into .cabal file ?
06:37:46 <gienah> piezo: other things to try are: ghc-pkg list --user shakespeare-css; ghc-pkg list shakespeare-css # the second one will probably be blank as I guess you wouldn't have it in your global db unless you are using gentoo or something
06:37:50 <Earnestly> donri: Since, like many others, there is no single generalised variable or configure option, I'll probably just leave it as is.  I don't want to have to maintain multiple different settings if I can help it.
06:38:07 <Earnestly> Maybe one day Unix will grow out of the "dotfile" bug
06:38:40 <gienah> piezo: I'm not sure if ghci looks in the .cabal file, but the .cabal file affects how the library and/or executable is built
06:38:55 <donri> Earnestly: xdg just moves things to other dotdirs ;)
06:39:03 <yitz> Earnestly: ghci reads ~/.ghci, and also .ghci in the current directory. you can script that to do lots of other things.
06:39:13 <Earnestly> donri: No it doesn't
06:39:23 <yitz> Earnestly: if you don't like the dotfile idiom, though, you're not going to be happy with all that obviously :)
06:39:26 <donri> Earnestly: ok well the defaults
06:39:35 <Earnestly> donri: It provides a mechanism to set your own or falls back to defaults
06:40:05 <Earnestly> yitz: Hidding dotfiles with a bug in `ls` back in unix v1/2 when they wanted to hide . and ..
06:40:13 <Earnestly> s/with/was
06:40:43 <Earnestly> Ever since developers have felt it fine to dump all sorts of .this and .that to the users $HOME
06:40:57 <yitz> Earnestly: it's not a bug. it's expected behavior. everyone knows how to look for dotfile when they want to see them, and how to keep them out of their faces when they don't/.
06:41:12 <donri> yitz: it's not a bug *now*
06:41:32 <Earnestly> yitz: As I said, it was a bug.  It's not become some kind of defacto standard, and GUI filemanagers have to even hack around it to emulate the same behaviour
06:41:36 <Earnestly> s/not/now
06:41:47 <yitz> Earnestly: it sure beats "Documents and Settings\Roaming\App Defaults" and all of its myriads of broken variations
06:42:20 <Earnestly> You're presenting a false dichotomy
06:43:33 <Earnestly> Anyway, I doubt it'll change but XDG is a wonderful standard and thankfully most things use it
06:43:41 <lpaste> piezo pasted “loading shakespeare-css module” at http://lpaste.net/95811
06:43:59 <yitz> generally the mac os x system of plists, standard places for config files, and app bundles, together with support for unix-style dot file when you need them, works pretty well. probably the best of the three.
06:44:19 <piezo> i think i will end cloning the repo :/
06:45:08 <Earnestly> yitz: You might find this slightly enlightening: http://blogs.msdn.com/b/oldnewthing/archive/2006/12/28/1374334.aspx
06:45:21 <Earnestly> (And the links within)
06:45:23 <yitz> Earnestly: i hate xdg. i won't use it. i don't want a zillion unknown daemons, and new ones behind my back, working behind my back to undermine my system, and violating every standard of how system directories are supposed to be used.
06:45:31 <Earnestly> Daemons?
06:45:38 <yitz> new ones every day
06:45:43 <Earnestly> What?
06:45:44 <yitz> ps ax
06:45:47 <donri> xgd isn't a daemon
06:45:50 <donri> xdg
06:45:53 <gienah> piezo: I guess Text.Css is just not exposed, that its not listed in Exposed-modules: in the shakespeare-css.cabal file
06:46:59 <yitz> e.g. dbus. e.g. the xdg "standard" for launch screen savers even though i already have xscreensaver running, hanging my system. etc. etc.
06:47:09 <Earnestly> dbus has nothing to do with XDG
06:47:21 <Earnestly> It doesn't even follow XDG, *grr* :P
06:47:40 <gienah> piezo: if you look in: http://hackage.haskell.org/package/shakespeare-css-1.0.6.4/shakespeare-css.cabal you can see its in 'other-modules:'
06:48:09 <piezo> gienah: yes, that why i said it's a hidden module (sorry, the correct term is not exposed)
06:48:39 <gienah> piezo: so I go off on a tangent about hidden modules like ghc :-/
06:48:55 <yitz> Earnestly: you're referring to just the xdg directory structure, not the all the other freedesktop.org junk?
06:49:10 <piezo> I try to debug it and need unexposed data types
06:49:22 <chrisdone> moin
06:49:34 <Earnestly> yitz: freedesktop.org is an umbrella for lots of different projects.  There is no other "XDG" than the XDG Base Directory Specification.
06:49:46 <gienah> piezo: I don't know what to do about that other than hacking the .cabal file to expose stuff
06:49:52 <donri> Earnestly: well yitz does have a point. XDG was just the old name for fd.o
06:50:04 <donri> and there are at least two directory related "xdg" specs
06:50:27 <Earnestly> donri: Can you point them out?
06:50:45 <piezo> gienah: ok thanks, I will try hack the tests
06:51:12 <donri> Earnestly: http://freedesktop.org/wiki/Software/xdg-user-dirs/ is a separate spec
06:51:19 <merijn> yitz: w.r.t. to .ghci stuff, it is a major bug and filing a bug report for it is still in my todo list
06:51:23 <Earnestly> It is not
06:51:29 <yitz> Earnestly: in my mind all that junk is in one bin.
06:51:34 <yitz> merijn: what's the bug?
06:51:34 <merijn> yitz: The way .ghci is currently setup is a massive security hole
06:51:48 <yitz> merijn: it has security issues, yes.
06:51:59 <merijn> yitz: "cabal get somepackage; cd somepackage; ghci" -> completely owned
06:52:16 <Earnestly> yitz: Including KMS? glibc? Wayland? gstreamer? evdev?
06:52:24 <merijn> yitz: You wouldn't classify "running command in a directory may completely compromise the machine" a bug?
06:52:50 <mr-> Earnestly: do you have a referene for "hiding .dotfiles used to be a bug"? ;-)
06:52:55 <merijn> yitz: ghci should read $HOME and only consider the current dir if actively instructed too
06:53:03 <donri> mr-: https://plus.google.com/101960720994009339267/posts/R58WgWwN9jp
06:53:17 <Earnestly> Yup ^
06:54:04 <yitz> merijn: then specify a new mechansim for setting up custom interactive environments without having to learn ghc api and code up a whole complex module.
06:54:07 <chrisdone> merijn: i like the idea of having a program whose aim is to run arbitrary code, and getting fussy about the fact it does that very thing
06:54:15 <yitz> merijn: i agree the security issue needs to be addressed.
06:54:38 <chrisdone> is bash a security hole?
06:54:48 <merijn> yitz: Simple specify a flag that *does* read .ghci file from the current dir
06:55:03 <merijn> chrisdone: bash only read from $HOME
06:55:16 <merijn> chrisdone: ghci reads the current directory of whatever haskell package you're browsing
06:55:36 <merijn> chrisdone: I wanna be able to fire up ghci inside a cabal package without running arbitrary code
06:55:49 <chrisdone> nod, so you fire it up
06:55:52 <chrisdone> you :l Main
06:56:00 <yitz> merijn: i guess a flag would be ok.
06:56:04 <merijn> chrisdone: wrong, already compromised
06:56:15 <klugez> chrisdone: ghci looks for ./.ghci
06:56:16 <merijn> chrisdone: .ghci gets read on startup
06:56:18 <chrisdone> merijn: “wrong”?
06:57:09 <merijn> chrisdone: "cabal get somepackage; cd somepackage; ghci" <- this runs whatever arbitrary haskell (including IO) that is in .ghci in somepackage
06:57:21 <chrisdone> merijn: i haven't said anything to the contrary so far
06:57:37 <chrisdone> merijn: so you: $ rm .ghci; ghci; :l Main
06:57:48 <chrisdone> and then template haskell deletes your $HOME
06:57:52 <chrisdone> what now, atheists?
06:58:16 <merijn> chrisdone: At least I have the source open in vim in these scenarios
06:58:30 <merijn> So I'm less likely to miss TH awfulness
06:58:36 <chrisdone> so too with .ghci
06:58:37 <merijn> .ghci is hidden and has no reason to be opened
06:58:43 <chrisdone> do you run a Makefile before read the contents?
06:58:54 <merijn> chrisdone: You habitually open .ghci when browsing source?
06:59:09 <sipa> the question is whether the behaviour is expected or not
06:59:20 <merijn> chrisdone: Name one reasonable use case for this default for .ghci
06:59:48 <monoidal> ghc -ignore-dot-ghci
06:59:55 <monoidal> and -XSafe
07:00:11 <merijn> monoidal: -ignore-dot-ghci ignore the one in $HOME too
07:00:15 <monoidal> though, you can use OPTIONS_GHC and still execute something malicious
07:00:19 <merijn> monoidal: I want it to read $HOME and ignore whatever local
07:00:25 <SrPx> Would you guys recommend a resource for me to understand better how the Haskell's type system work?
07:00:40 <merijn> SrPx: How well do you want to understand it?
07:00:41 <chrisdone> merijn: well the use-case is obvious. the question is how must you trust package authors to not put bad things in various places. the .ghci file, their .hs code, the .cabal file, the Makefile
07:00:50 <donri> alias ghci='ghci -ignore-dot-ghci -ghci-script ~/.ghci' or whatever :p
07:00:50 <yitz> Earnestly: dunno. stopped following it years ago, waste of time. the whole mentality is to emulate a windows-like environment. i want working man pages, everything easily scriptable from shell, sane and simple directory structure, no gratuitous daemons. in short - a nice, clean easy-to-use system.
07:00:59 <merijn> donri: Doesn't work, tried it
07:01:26 <chrisdone> the per-project .ghci file is very useful, i use it all the time
07:01:30 <merijn> donri: I spend an afternoon trying to work it
07:01:37 <SrPx> merijn: i actually want to copy it for my language so ridiculously well (it was a dynamic language, i want a type system now)
07:01:45 <merijn> chrisdone: And the ability to optionally load a local .ghci breaks this work how?
07:01:47 <chrisdone> the whole “security” fixes against it have been a pain in the ass
07:01:48 <yitz> chrisdone: yes i agree. definitely a nice feature of ghci.
07:01:58 <merijn> SrPx: Ah, so you wanna design a PL?
07:02:06 <merijn> @where TaPL
07:02:06 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
07:02:09 <merijn> SrPx: Read that
07:02:47 <SrPx> merijn: it is done i just want a type system now... because people convinced me i wont be able to compile it to near c speeds if I keep the dynamic structures (hashes)
07:02:49 <merijn> SrPx: It's the de facto standard book for learning type systems and language design :)
07:03:04 <SrPx> TaPL?
07:03:07 <SrPx> ty
07:03:13 <donri> hah you're right, that smells like a bug
07:03:22 <donri> -ignore-dot-ghci makes -ghci-script do nothing
07:03:40 <merijn> chrisdone: Even if I could do the alias donri just mentioned I would be happy
07:03:45 <SrPx> merijn: but does it actually mention haskells type system? it is much different from c etc
07:04:08 <yitz> SrPx: merijn's right that's a great reference have a look.
07:04:10 <chrisdone> merijn: sure
07:04:11 <merijn> SrPx: I believe it covers ML, but both ML and Haskell use Hindley-Milner, so it should be close enough
07:04:58 <merijn> SrPx: And Haskell's type system is rather complex, but after TaPL you should know enough to just read the papers about Haskell's advanced stuff
07:05:05 <SrPx> fine, thanks !
07:05:11 <haasn> TaPL?
07:05:16 <SrPx> (:
07:05:24 <chrisdone> the .ghci is no more dangerous than Setup.hs
07:05:28 <haasn> Oh, I saw the link
07:05:29 <chrisdone> in fact it's probably less dangerous
07:05:41 <chrisdone> because everyone cabal installs, many people never use ghci
07:05:58 <merijn> chrisdone: Sure, but the flaw in your assumption is that all code I'm looking at is code I will run :)
07:06:28 <chrisdone> merijn: you don't have to run code to be exploited. simply compiling it is enough
07:06:35 <merijn> chrisdone: I trust most of hackage fairly well, but if someone publishes a cabal package with a security exploit I would like to browse through it even though I don't trust it
07:06:36 <chrisdone> and if you're launching cabal or ghci, you're compiling code
07:06:44 <merijn> chrisdone: -XSafe helps for that
07:07:04 <merijn> Although in practice a VM might be better
07:07:10 <yitz> chrisdone: i'm actually not sure that a general Setup.hs is needed anymore.
07:07:29 <merijn> yitz: It is for people that don't have cabal-install
07:07:35 <chrisdone> yitz: sure, tho the problem is irrelevant to that because a malicious person would add a Custom build anyway
07:08:08 <yitz> merijn: does anyone do that anymore? why would they?
07:08:09 <monoidal> fyi in 7.6 you can write unsafeCoerce with -XSafe
07:08:34 <chrisdone> monoidal: lol
07:08:38 <merijn> yitz: Eh, what if you have a compiler that doesn't ship with cabal-install/cabal-install doesn't exist in binary form for your platform?
07:08:51 <yitz> monoidal: GeneralizedNewtypeDeriving?
07:08:54 <merijn> yitz: i.e. whan bootstrapping a new platform
07:09:02 <chrisdone> all the -X safe/trustworthy extensions seem pointless so far
07:09:06 <monoidal> yitz: no, typefam exploit. that's not -XSafe
07:09:13 <monoidal> yitz: I mean GND is not Safe
07:09:18 <chrisdone> almost actively bad because they give people a false sense of security
07:09:37 <monoidal> I think they're a good idea, as long as they're understood
07:09:44 <yitz> merijn: we don't need Setup.hs in every package just for people who bootstrap new platforms.
07:09:50 <merijn> yitz: True
07:10:39 <monoidal> yitz: https://ghc.haskell.org/trac/ghc/ticket/8162
07:10:50 <yitz> merijn: the bootstrap process is a little rusty anyway (or have they fixed it now?) the Setup.hs issue can be addressed for that some other way.
07:11:34 <yitz> chrisdone: i like SafeHaskell (even though sometimes i'm cranky and argue with merijn about it)
07:13:46 <aranea> Hi. I'm using a custom monad based on the State monad in a library. To make things easier, I derived a MonadState instance for it using GeneralizedNewtypeDeriving. However, I don't want to export that instance. Is this possible, or do I have to remove the instance completely and explicitly unwrap the State monad for all operations on it?
07:13:47 <yitz> monoidal: ha. didn't see that one.
07:13:58 <FreeFull> With unsafeCoerce, can you make unsafePerformIO?
07:14:04 <monoidal> FreeFull: yes (and vice versa)
07:14:40 <monoidal> FreeFull: use unsafeCoerce for IO ~ ST RealWorld ~ ST s and then runST
07:15:44 <hpc> can unsafeInterleaveIO be used to create unsafePerformIO or unsafeCoerce?
07:16:11 <yitz> aranea: how hard is it to write a MonadState instance without GND?
07:16:23 <monoidal> hpc: I'm doubtful, since it returns IO a, and it would be hard to get rid of that IO
07:16:32 <hpc> yeah
07:17:13 <hpc> i like how unsafeInterleaveIO is technically another form of concurrency
07:17:18 <aranea> yitz: 5 lines of pure boilerplate code
07:17:20 <monoidal> unsafeInterleaveST, on the other hand, is more dangerous
07:17:23 <hpc> except it is unsafe because it still ties execution to evaluation
07:18:07 <monoidal> hpc: IMO it's technically it's as dangerous as other lazy io functions
07:18:14 <gfredericks> so I'm using this library (hedn) that parses things, and it seems to have just one parsing function: Data.ByteString.Lazy.Internal.ByteString -> Maybe ParsedValue
07:18:16 <aranea> yitz: but that's not the problem. I don't want the exported type to have any MonadState instance at all, but I need that instance inside the module
07:18:25 <gfredericks> and I'm not familiar with how lazy bytestrings are supposed to be used
07:18:28 <monoidal> hpc: I mean, they also tie execution and evaluation
07:18:39 <yitz> hpc: i wonder if you could cause some kind of crash by exhausting a resource like open fds and somehow exploit that to do IO :)
07:18:46 <hpc> haha
07:18:56 <gfredericks> my current approach is to do a normal getLine and convert it to a lazy bytestring
07:19:03 <gfredericks> but that precludes multi-line input
07:20:00 <aranea> I don't understand why this instance is exported at all – I export the type using "Type" and not "Type(..)"
07:20:11 <hpc> aranea: instances are always exported
07:20:17 <hpc> even if you do "module Foo () where"
07:20:25 <aranea> any way do disable that?
07:20:28 <hpc> no
07:20:45 <gfredericks> could could I hook some magical lazy bytestring up to the parser such that it reads as much as it has to to parse a single thing?
07:20:46 <hpc> such ability would be quite problematic for the compiler's ability to do instance resolution
07:20:54 <hpc> and awkward for modularity too
07:20:56 <aranea> I don't want users to mess with my state – but I need the instance to get rid of boilerplate code
07:21:08 <hpc> which instance is picked for identical code will depend on which module it happens to be in
07:21:14 <monoidal> aranea: what class you use?
07:21:19 <aranea> MonadState
07:21:21 <gfredericks> I guess it doesn't return back the rest of the input, so maybe this is impossible... :/
07:21:37 <aranea> hpc: I understand
07:27:18 <yitz> hpc: ghc should have that ability. not by default for regular use for what aranea wants, but for getting around problematic instances exported by 3rd party libraries without massive newtype refactoring in large systems
07:28:10 <hpc> hmm, yeah
07:28:27 <hpc> some kind of -XInstanceExports flag maybe?
07:28:30 <yitz> hpc: and no that wouldn't cause any problem with instance resolution. it would open the possibility of creating crashes by misue, so it would be in the Unsafe category.
07:28:47 <yitz> hpc: -XUnsafeInstanceImports
07:29:01 <yitz> or something
07:29:05 <hpc> maybe both
07:29:36 <hpc> that way you have the lower module explicitly stating "i am not exporting all instances", and the importing module "i am not importing all instances"
07:30:18 <yitz> hpc: in the use case i am thinking of the exporting module is offensive and uncooperative. otherwise i wouldn't need this.
07:31:43 <enthropy> maybe the Control.Monad.Instances module is an example of this?
07:32:08 <enthropy> it used to be reserved for offensive instances like Monad ((->) r)
07:32:21 <yitz> enthropy: that used to be a real problem, especially because of instance Monad Either where...
07:35:41 <yitz> enthropy: we have instance Applicative ((->) r) by default nowadays...
07:36:17 <triliyn> Why are (->) r instances offensive?
07:36:33 <Tekmo> I don't find them offensive
07:36:39 <enthropy> dunno exactly, but it can be confusing
07:36:43 <hpc> triliyn: it causes a lot of surprise typo-correct programs
07:36:53 <chrisdone> geekosaur: hey i just saw once of your answers on stackoverflow =)
07:36:57 <triliyn> hmm, I guess that makes sense
07:37:01 <Tekmo> Oh, here's a good example of where it can be confusing
07:37:09 <chrisdone> geekosaur: (postfix configuration)
07:37:14 <gfredericks> how does attoparsec relate to parsec?
07:37:18 <Tekmo> In the reader monad, forever (m :: a -> b) = _|_
07:37:20 <monoidal> I saw several bugs from x >> y used for (->) r
07:37:35 <Tekmo> So if you apply `forever` to a function by mistake you will get a non-terminating program
07:37:36 <monoidal> this instance does make me a bit uncomfortable - it's a tradeoff
07:37:52 <yesthisisuser> Hello everyone. I have trouble with GADTs and GHC's brain exploding.. I suspect there is no simple solution to this problem.. Here is the program: http://lpaste.net/95812
07:37:53 <yitz> hi Tekmo. showed your stuff to a friend who is a biochem prof. she really liked it.
07:37:58 <monoidal> (what was meant was \r -> x r >> y r)
07:38:04 <Tekmo> yitz: Thanks!  What's her name?
07:38:05 <yesthisisuser> the problem is on line 39
07:38:06 <triliyn> @src forever
07:38:06 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:38:37 <yesthisisuser> where I am trying to pattern match over the GADT constructor
07:38:43 <yesthisisuser> which GHC doesn't like :(
07:39:04 <monoidal> yesthisisuser:  case a of ActionType at -> (a, ActionStack as st)
07:39:11 <monoidal> yesthisisuser: instead of let
07:39:32 <enthropy> monoidal: would people get angry if the >> method for that ((->) r) had a warning attached to it?
07:39:33 <yesthisisuser> monoidal: .. ok let me try that
07:39:33 <monoidal> yesthisisuser: you can pattern match, but not using let
07:39:50 <monoidal> enthropy: angry? no, I would be happy. but it would be very adhoc.
07:40:21 <triliyn> > ((+1) >> (+3)) 5
07:40:22 <yesthisisuser> monoidal: ok.. well.. the problem is that i would want to maintain that separation
07:40:22 <lambdabot>   8
07:40:32 <yesthisisuser> that was the whole idea of using these "actions".
07:40:32 <enthropy> I see, that kind of thing could probably get enabled by -fwarn-unused-something
07:41:04 <enthropy> but I guess warnings don't get added that way
07:41:12 <yesthisisuser> monoidal: i want to be able to separate these actions into different modules.. sort of client code vs. library code
07:41:13 <enthropy> or maybe -fwarn-unused-do-bind takes care of this
07:41:31 <monoidal> yesthisisuser: but "case x of ... -> ..." and "let ... = x in ..." are equivalent. there's no issue of separation here
07:41:39 <monoidal> yesthisisuser: it's like (+) 2 3 vs 2 + 3
07:41:51 <yesthisisuser> monoidal: with the case statement i have to list all of the actions
07:41:54 <yitz> Tekmo: ellerton. interesting though, not finding her on google. maybe uses her maiden name.
07:42:01 <monoidal> yesthisisuser: and with let?
07:42:25 <maikklein> does anyone know if there is an haskell code game? Something like http://scalatron.github.io/ ?
07:42:39 <lvella> is haskell.org offline?
07:42:43 <yesthisisuser> monoidal: .. the idea was that since i now that i have a (Action a) => a .. i can "pull out" the reverse method..
07:42:56 <yesthisisuser> *know
07:43:05 <chrisdone> lvella: it's back up for me
07:43:22 <monoidal> yesthisisuser: but you can do this in a case too.
07:43:30 <yitz> Tekmo: oh ok. sharon ellerton. she teaches at queensboro.
07:43:33 <m1dnight> hey gys
07:43:35 <m1dnight> quick question here
07:43:41 <m1dnight> http://lpaste.net/95813
07:43:48 <Tekmo> yitz: Got it.  Thanks! :)
07:43:58 <lvella> hey guys, what is the biggest profile haskell game engine?
07:44:02 <m1dnight> that lambda, that's mapped over the array, has as last expression "return color"
07:44:07 <yesthisisuser> monoidal: could you show what you mean on lpaste..?
07:44:12 <m1dnight> which takes a string "and puts it in a IO box"
07:44:23 <m1dnight> but why is it that my array is an array of strings, and not of IO strings?
07:44:30 <Tekmo> lvella: Helm, maybe
07:44:31 <monoidal> yesthisisuser: exactly your code, but "let (ActionType at) = a in (a, ActionStack as st)" replaced with "case a of ActionType at -> (a, ActionStack as st)"
07:44:38 <Tekmo> lvella: Haskell has very few game engines right now
07:44:58 <monoidal> m1dnight: check :t forM
07:45:20 <m1dnight> yea it uses monads, but i'm not there yet in LYAH :( :p
07:45:24 <yesthisisuser> monoidal: now i get it.. hehe
07:45:27 <chrisdone> Cale: https://twitter.com/Damientg/status/401757893948489728
07:45:35 <yesthisisuser> i think.. wait.. let me try
07:45:39 <burp> http://hackage.haskell.org.nyud.net/packages/ somehow this is working
07:45:55 <monoidal> m1dnight: in short, if you used "map", it would be a list of IO Strings
07:46:23 <lvella> what do you say about hgamer3d?
07:46:28 <monoidal> m1dnight: i.e. [IO String]. but "mapM" changes that to IO [String], and "colors <- " makes colors the [String] type
07:47:01 <Tekmo> lvella: I didn't know about it
07:47:06 <monoidal> m1dnight: I mean, forM not mapM (they're the same with different order of parameters)
07:47:31 <Tekmo> lvella: A really good rule of thumb for Haskell packages is to go on Hackage and check the last updated field (assuming Hackage is up, which it is not right now)
07:47:40 <Tekmo> lvella: This is a good measure of how well a package is maintained
07:48:14 <Tekmo> lvella: After a while you begin to recognize certain package authors by name and you know their packages are usually good
07:48:40 <monoidal> m1dnight: map (\x -> getLine x) ["a", "b"] :: [IO String]. But mapM (\x -> getLine x) ["a", "b"] :: IO [String], forM ["a","b"] (\x -> getLine x) :: IO [String]
07:48:51 <lvella> well, my team wants to take a bold step and use haskell or a functional language on our next game
07:48:52 <yitz> Tekmo: http://www.qcc.cuny.edu/biologicalsciences/Faculty/Sellerton/ i see she's teaching more intro level stuff now. didn't realize that. she used to teach biochem courses where - had it been available then - your app would have been amazing.
07:49:08 <yesthisisuser> monoidal: Thanks!! It worked. I would never have been able to figure that one out without your help.
07:49:18 <Tekmo> yitz: Yeah, one of the things I'm marketing it for is educational purposes
07:49:32 <lvella> it always seemed to me that haskell had an active game community branch
07:49:48 <lvella> it even have the channel #haskell-game
07:49:56 <Tekmo> lvella: So the bottleneck is on the output end (i.e. SDL or what hav eyou)
07:50:39 <Tekmo> lvella: I can warn you about potential pitfalls
07:50:56 <lvella> my alternative would be monogame and F#
07:51:06 <lvella> what pitfalls?
07:51:11 <monoidal> m1dnight: it might get clearer later, once you get more comfortable with the type system
07:51:28 <Tekmo> lvella: The first main pitfall is keeping garbage collection under control
07:51:37 <Tekmo> lvella: GHC garbage collection is optimized for throughput rather than latency
07:52:13 <Tekmo> lvella: It depends on how complicated your game is and how much you are outsourcing to an external graphics engine
07:52:32 <Tekmo> lvella: One person you should really talk to is Jonathan Fischoff (jfischoff)
07:52:43 <Tekmo> lvella: He can give you tons of useful advice
07:53:15 <lvella> if that HGamer3D is to be used, it uses ogre3d as backend
07:53:37 <Tekmo> If you're using Haskell as game logic, then you should have no problems at all
07:54:07 <Tekmo> I'm probably going to get flack for mentioning this second pitfall, but I'll throw it out there
07:54:11 <lvella> but it doesn't fell very productive if I have to use directly a C or C++ library from haskell
07:54:23 <Tekmo> The second pitfall is overuse of concurrency
07:54:43 <Tekmo> lvella: How graphics-intensive is your game?
07:54:52 <lvella> little
07:54:56 <lvella> it is 3d
07:55:03 <lvella> but 2d logic
07:55:06 <Tekmo> Then you can probably do the rendering within Haskell
07:55:07 <lvella> side scrolling
07:55:51 <Tekmo> So there are OpenGL/GLUT/GLFW-b bindings that you can use
07:55:58 <lvella> I fear that to use raw opengl would take us to much time
07:56:18 <lvella> we was hoping to be able to use an engine
07:57:03 <lvella> what you said about overuse of concurrency?
07:57:31 <Tekmo> So there are basically two approaches to this sort of thing in Haskell
07:57:56 <Tekmo> One is to fork several threads for various behaviors and to communicate between them using channels and STM
07:58:26 <jpcooper> hello
07:58:31 <Tekmo> The other is to serialize concurrent events into a single stream and then feed that into a pure core
07:58:35 <Tekmo> The latter works much better
07:58:46 <jpcooper> what value in Haskell is equal to the largest of an Int type?
07:58:48 <jpcooper> like Int64
07:59:00 <Tekmo> jpcooper: maxBound :: Int64
07:59:29 <jpcooper> thanks
08:01:27 <Tekmo> You're welcome
08:01:35 <Tekmo> lvella: Then try Helm
08:02:13 <lvella> but it doesn't even uses OpenGL...
08:02:17 <lvella> or has it changed?
08:02:23 <Tekmo> Oh yeah, I forgot that you wanted 3D
08:02:29 <lvella> well
08:02:47 <lvella> we are developing the concept
08:02:52 <lvella> 2D might well fit
08:03:01 <lvella> since it is a side scrolling game
08:03:05 <Tekmo> Don't compromise on your vision! :)
08:04:00 <Tekmo> So I have a question: what kinds of things do you look for in a higher-level game framework?
08:05:47 <lvella> well, I am familiar with Ogre3D, and I hoped I could find the kind of features I find there
08:06:02 <lvella> scene graph, camera abstraction
08:06:21 <lvella> resource loader, mesh loader
08:06:38 <lvella> texture and material loader
08:06:46 <lvella> animation
08:06:53 <lvella> collision detection
08:06:57 <lvella> physicis
08:07:04 <ginmaniac> hey guys. I am using hmatrix library: 'let a = (2><2) [1..]' and 'let b = 23.323'. Why is 'a*23.323' working whereas 'a*b' is raising the error 'Couldn't match expected type `Matrix Double' with actual type `Double''?
08:07:27 <Tekmo> lvella: So I guess my next question is what are the main things that appeal to you about using Haskell?
08:07:50 <Tekmo> ginmaniac: This is the monomorphism restriction
08:07:51 <lvella> the idea to use haskell of f# came from me
08:08:10 <Tekmo> ginmaniac: when you define `b = 23.323` it defaults `b` to an `Integer`
08:08:15 <lvella> but we are inclined in experimenting developing a game in a functional language
08:08:15 <geekosaur> ginmaniac, numeric literals have fromIntegral or fromRational implicitly wrapped around them. but `let a = ...` triggers monomorphism restriction + defaulting and gets fixed as Double because Matrix Double isn't dfaultable
08:08:21 <hpc> Tekmo: it defaults to Double
08:08:31 <lvella> and I believe in haskell's development speed
08:08:31 <Tekmo> Oops!
08:08:36 <Tekmo> `hpc` is right: `Double`
08:08:36 <hpc> :t 23.323 -- it's not Num
08:08:37 <lambdabot> Fractional a => a
08:08:45 <lvella> less code do more
08:08:47 <LambdaDusk> or perhaps I should ave asked here first if anyone has a tip about this: https://gist.github.com/scan/45687045b0199581512e
08:08:51 <geekosaur> (although you might be able to add it to the default types, you are better off adding type annotations)
08:08:59 <Tekmo> In the second case, the `23.323` is type-checking as the more general `(Fractional a) => a` type
08:09:13 <Tekmo> ginmaniac: And matrices implement `Fractional`, so it acts like a matrix
08:09:46 <ginmaniac> Tekmo: okay, thank you I think I understand
08:10:05 <Tekmo> ginmaniac: You're welcome
08:10:06 <ginmaniac> geekosaur: ty
08:10:20 <lvella> now, I have experience both with C++ and Ogre, and C++ and raw opengl
08:10:36 <lvella> we never actually worked with a full featured game engine
08:10:42 <Tekmo> lvella: So here's the issue.  Bindings to C++ are a pain in the butt
08:10:51 <lvella> that was what we was hoping for, this time
08:12:21 <lvella> but I am beginning to realize that I must use a mainstream commercial language, like C#, to use such full featured engine
08:12:22 <Tekmo> lvella: I think that if you really want to do this in Haskell you should expect to have to write more library code first
08:12:40 <lvella> yes
08:12:49 <lvella> that HGamer3d I talked about
08:12:56 <lvella> I have downloaded the code
08:13:09 <lvella> it is from march 2013
08:13:16 <lvella> but seems to be windows only
08:13:47 <semithinking> hi everyone
08:13:47 <Tekmo> What I recommend you do is that you use another language, but also write up a blog post explaining what you need in a Haskell framework
08:13:58 <Tekmo> Having a post like that will help Haskell developers understand the need of game programmers
08:14:37 <Tekmo> Then maybe a year down the line there might be a better game framework waiting for you later on
08:15:40 <lvella> do you know who is Peter Althainz
08:15:57 <Tekmo> No
08:15:58 <lvella> he is the author of HGamer3D
08:16:20 <lvella> I can't find the project repository/version control system
08:16:53 <Tekmo> I found his github account
08:17:06 <Tekmo> Never mind
08:17:10 <Tekmo> It's not a 404 link
08:18:00 <semithinking> I was wondering if anyone could recommend a package for linear algebra and plotting in haskell.
08:18:02 <Tekmo> Hackage is working now!
08:18:36 <Tekmo> semithinking: The best linear algebra package is hmatrix
08:19:02 <semithinking> i had been looking at that
08:19:04 <Tekmo> The plotting libraries are not superb, but there is one that is decent.  Let me look it up
08:19:13 <semithinking> there was a good tutorial available with Ruiz
08:19:34 <semithinking> i think most of the plotting libraries are just wrappers to gnuplot
08:19:35 <hvr> if anyone cares about 'instance Bits Bool' ==> http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/20663
08:19:39 <lvella> tell me, how productivity compares to other languages, like, python
08:20:12 <semithinking> lol @Ivella ... well in Java ... you could write a 100 lines and still have done nothing :)
08:20:21 <Tekmo> lvella: The biggest source of productivity increase in Haskell is the type system
08:20:49 <hvr> semithinking: it's all about the sideffects :)
08:20:57 <semithinking> xD
08:21:13 <semithinking> yes yes ... everyone keeps telling me about these side effects
08:21:42 <semithinking> but i have had not the opportunity to work with group of programmer larger than 2
08:21:42 <Tekmo> lvella: However, if you are a new programmer to Haskell, the type system will benefit you the most if you are using other people's code
08:21:55 <lvella> I don't think java is a good reference in productivity
08:22:03 <Tekmo> lvella: If you are writing most of the bindings that you are consuming, it may not be obvious to you how to use the types to enforce correct behavior
08:22:16 <bz> is hackage down?
08:22:23 <Tekmo> bz: Not any more
08:22:51 <lvella> I think I may consider myself just past the "beginner" status
08:22:55 <lvella> but maybe not
08:23:14 <semithinking> I'm still at the beginner stage myself
08:23:24 <bz> loading a bit sluggish for me
08:23:31 <Tekmo> lvella: Well, the key thing is that types basically replace many types of tests
08:23:42 <Tekmo> lvella: Effective use of types is like having an auto-generated test suite
08:23:52 <Tekmo> lvella: It makes development move along much more quickly
08:24:11 <Tekmo> lvella: For large projects, types help a LOT
08:24:13 <lvella> what you mean by effective use?
08:24:26 <Tekmo> lvella: Here's an example
08:24:31 <lvella> like, to define all your algebraic types?
08:24:38 <Tekmo> Let's say that I am deciding how to represent a unit in my game
08:24:47 <Tekmo> I will propose two solutions:
08:25:00 <Tekmo> Solution #1: Use a Haskell record to store attributes as fields
08:25:13 <LambdaDusk> or maybe asked differently: What can I do when I get overlapping instances from using a function from another lib?
08:25:16 <Tekmo> Solution #2: Use a Python-like dictionary (i.e. Map String Val)
08:25:31 <Tekmo> Solution #2 is an example of an "ineffective" use of types
08:25:44 * hackagebot regex-applicative 0.3.0.2 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.3.0.2 (RomanCheplyaka)
08:25:46 * hackagebot tasty-hunit 0.4.1 - HUnit support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hunit-0.4.1 (RomanCheplyaka)
08:25:50 <Tekmo> by using strings and other weakly typed representations of data, you basically hide a lot of useful information from the type system
08:25:59 <Tekmo> So it can't catch mistakes
08:26:05 <lvella> oh
08:26:11 <Tekmo> If you use a strongly typed record, then the type system can give you very specific errors and advice
08:27:01 <lvella> yes, that is good
08:27:35 <Tekmo> The second productivity improvement is from high-level design patterns
08:27:41 <lvella> so it will be sorted out at compile time
08:27:43 <Tekmo> Right
08:27:55 <Tekmo> Haskell design patterns tend to be much more reusable than design patterns in other languages
08:28:21 <Tekmo> I'm using the term "design patterns" very loosely to refer to category theory type classes like `Functor`, `Monad`, and `Category`
08:28:33 <enthropy> x:xs is a design pattern I think
08:28:34 <Iceland_jack> lvella: Also if you have a function that acceps two different things that are represented using the same type you can swap the arguments and it will still compile (this is such a common mistake for memset(3) that Stevens' book on UNIX Network Programming opts to use bzero instead)
08:28:56 <enthropy> it's a pattern at least
08:29:17 <Iceland_jack> enthropy: That's a normal value constructor
08:29:42 <Iceland_jack> In Haskell you can use a newtype to take the same type but make it mean different things
08:29:45 <Tekmo> Haskell type classes tend to have a high power to weight ratio
08:29:57 <enthropy> Iceland_jack: I mean the naming convention
08:30:06 <Tekmo> So when you learn things like `Functor` and `Monad`, that time you invested in learning them is well-spent
08:30:17 <Iceland_jack> enthropy: I wouldn't call naming conventions a design pattern
08:30:17 <enthropy> that people will hand-write something that can be shoehorned into a foldr but don't
08:30:23 <enthropy> since that's less clear
08:30:33 <enthropy> @src drop
08:30:33 <lambdabot> drop n xs     | n <= 0 =  xs
08:30:33 <lambdabot> drop _ []              =  []
08:30:33 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
08:30:48 <Iceland_jack> An idiom would be more like it
08:31:19 <enthropy> when does an idiom become a design pattern?
08:31:26 <Tekmo> lvella: Here's an example to give you an idea of something clever you can do with Haskell design patterns
08:31:37 <Tekmo> Let's say you have three textures you may want to load
08:31:40 <Iceland_jack> enthropy: A common variable name is not a ‘design’
08:31:46 <Tekmo> I will assume that your texture has type `Texture`
08:32:01 <Tekmo> Let's also assume that you have three loading actions, one for each `Texture`
08:32:16 <Tekmo> load1 :: IO Texture, load2 :: IO Texture, load3 :: IO Texture
08:32:39 <Tekmo> Now what I will do is stick all three of them in a tuple, and just hand-wave and say that the tuple is my set of lazily-loadable textures:
08:32:53 <Tekmo> textures = (load1, load2, load3) :: (IO Texture, IO Texture, IO Texture)
08:33:19 <Tekmo> Now, let's say that I want to load just texture2, replacing the `IO Texture` with a `Texture`
08:33:24 <Tekmo> In other words, the function I want should have type:
08:33:39 <Tekmo> demand2 :: (IO Texture, IO Texture, IO Texture) -> IO (IO Texture, Texture, IO Texture)
08:34:00 <Tekmo> In other words, it takes the tuple as an argument and performs IO, returning the tuple with the second element now available
08:34:12 <Tekmo> The implementation of demand2 is one line of code:
08:34:18 <Tekmo> demand2 = sequenceOf _2
08:34:22 <Tekmo> That's using the `lens` library
08:35:01 <chrisdone> ahahaha http://www.reddit.com/r/haskell/comments/1qtr88/criticism_of_haskell_xpost_from_rprogramming/cdge3mf?context=2
08:35:35 <chrisdone> someone should write a “how to criticise haskell” article to avoid common pitfalls =p
08:36:00 <Iceland_jack> chrisdone: hah!
08:36:14 <Tekmo> lvella: So, for example, if I wanted to demand textures 3, 1, and 2 in that order
08:36:17 <Tekmo> lvella: Then I would write:
08:37:01 <Iceland_jack> When someone says “purity is neat 'n all but real-world programs use IO all the time” I immediately put them on ignore mentally
08:37:05 <Tekmo> sequenceOf _3 >=> sequenceOf _1 >=> sequenceOf _2 :: (IO Texture, IO Texture, IO Texture) -> IO (Texture, Texture, Texture)
08:37:36 <Tekmo> That's an example of how Haskell has a very high power-to-weight ratio
08:38:20 <zardoz``> is using unsafePerformIO to read a config file to have globally accessible options considered a bad style?
08:38:27 <mcstar> and how the code is usually redundant (the typing suffices) </joke>
08:38:48 <chrisdone> zardoz``: i'd think that's considered bad style, yeah
08:38:59 <Dasuraga> are word8s from ByteStrings basically the same as chars from a c-style string?
08:39:10 <mcstar> word is unsigned
08:39:14 <lvella> sorry, I am having trouble to follow
08:39:31 <lvella> what were trying to show me?
08:39:35 <Tekmo> lvella: Yeah, maybe that was too sophisticated of an example
08:39:39 <zardoz``> chrisdone even though it could be considered pure, for some definitions of pure? :)   (ie, does not change during the single runtime of the program)
08:40:12 <lvella> you can invert the order of the loading?
08:40:47 <lvella> or, preselect the order of the loading
08:40:49 <zardoz``> what's the recommended way of doing this? reading config file in main, then passing things around?
08:40:57 <zardoz``> as they are needed
08:40:58 <lvella> ?
08:41:20 <Tekmo> lvella: So this is a bit hard to explain, but imagine that you have a tree of resources
08:41:30 <lvella> in this case, I don't really think it matters the order, right?
08:41:32 <Tekmo> lvella: All of them that you only want to lazily load when you actually need them
08:41:36 <lvella> not even if it is loaded at all
08:41:46 <lvella> yes
08:41:58 <Tekmo> lvella: You can write code that lets you declaratively load only the portions you actually need using nice lens-like syntax
08:42:06 <lvella> IIRC, there is an UsafeIOsSomething function
08:42:23 <Tekmo> Yes, but that's definitely not what you want to do
08:42:23 <lvella> that strips the IO, but can't guarantee when it actually happens
08:42:40 <lvella> why not?
08:42:46 <lvella> because it is unpredictable?
08:42:56 <lvella> may cause undesired latency?
08:43:15 <Tekmo> Probably the reason that you might care about the most is exceptions
08:43:29 <Tekmo> Let's say that loading the resource might throw an exception
08:43:36 <Tekmo> For example, the resource is not found
08:44:07 <Tekmo> When you use unsafe IO, that exception will be thrown in the middle of pure code, wherever you first demand the resource
08:44:34 <Tekmo> Another problem is evaluation
08:44:44 <Hannibal_Smith> Is there a guide to help select a string library? A lot of people use ByteString, but ByteString I did read that create fragmentation because GC can't move it
08:44:55 <Tekmo> For strings, use `text`
08:45:01 <Hannibal_Smith> Ok
08:45:21 <Tekmo> lvella: When you use `unsafePerformIO`, the `IO` action is performed every time you evaluate that term
08:45:37 <Tekmo> lvella: That means that if GHC reorganizes the code and causes it to be evaluated twice, it will be loaded twice
08:46:16 <zardoz``> teko i am pretty sure it will be called only once by default?
08:46:19 <mangaba_leitosa> Hannibal_Smith: I was memory profiling my app for counting words frequencies represented as ByteString: got this: 886,108,144 bytes allocated in the heap; 114,218,424 bytes copied during GC; 10,957,632 bytes maximum residency (5 sample(s))
08:46:41 <Tekmo> zardoz``: Are you sure?  What if he uses the texture in more than one place?
08:46:42 * zardoz`` tests
08:46:51 <mangaba_leitosa> Hannibal_Smith: this is for processing a 4 MB file. so, basically it says that 886 MB was used  :-)
08:46:54 <Tekmo> zardoz``: Make sure to turn on `-O2` when testing
08:47:04 <Tekmo> zardoz``: This problem arises when optimizations are on
08:47:49 <mangaba_leitosa> Hannibal_Smith: with Text it will be more because AFAIU Text is like ByteString, but with unicode support
08:47:50 <lvella> where that sequenceOf function came from?
08:48:11 <Hannibal_Smith> mangaba_leitosa, so what did you end using?
08:48:18 <donri> lvella: i didn't follow the conversation but have you looked at http://helm-engine.org/ ?
08:48:18 <Tekmo> zardoz``: Read this: http://stackoverflow.com/questions/19371636/am-i-abusing-unsafeperformio/19372414#19372414
08:48:35 <lvella> yes, I was hoping for 3D
08:48:37 <mangaba_leitosa> Hannibal_Smith: I'm using ByteString because my text is ascii-only...
08:48:52 <mangaba_leitosa> Hannibal_Smith: and it is more than 2 times faster than when I used String
08:49:09 <Tekmo> mangaba_leitosa: `Text` is faster than `String`, too
08:49:36 <mangaba_leitosa> Tekmo: yes, I tried Text, too (much faster than Stream, significantly slower than ByteString)
08:49:49 <mangaba_leitosa> Tekmo: s/Stream/String/
08:50:02 <Tekmo> mangaba_leitosa: Alright, then `ByteString` is probably fine for your purposes
08:50:09 <Hannibal_Smith> So...if you have to process a lot of strings, you have to use...String?
08:50:17 <mangaba_leitosa> Tekmo: right, but not for everyone's...
08:50:51 <mangaba_leitosa> Hannibal_Smith: it seems that if you are reading long strings Text/ByteString is faster than String
08:50:51 <Hannibal_Smith> Memory constrains are an important topic for me, more than raw performance
08:51:03 <MarcWeber> Hannibal_Smith: String is a [char] list (lazy). ByteStrings can be strict or lazy. Lazy ByteStrings is a List of blocks of memories. A strict byte string is a block of memory, only.
08:51:10 <mangaba_leitosa> Hannibal_Smith: but if you generate a lot of short strings (like using list operations), then String is faster
08:51:10 <zardoz``> getLine is only executed once: http://lpaste.net/95816
08:51:20 <Destinova> hello everyone
08:51:28 <Hannibal_Smith> mangaba_leitosa, yes the later is my case
08:51:39 <lvella> Tekmo, where that function sequenceOf came from?
08:51:43 <zardoz``> Tekmo did you expect it to be call multiple times? or did I misunderstand your argument
08:51:49 <Tekmo> lvella: The `lens` package
08:51:50 <zardoz``> called
08:52:01 <Tekmo> zardoz``: In some circumstances it can be.  One second
08:52:10 <mangaba_leitosa> Hannibal_Smith: I ended up generating short strings as String, then converting them to ByteString for later storage in Map/Hashtable
08:52:28 <mangaba_leitosa> Hannibal_Smith: even with conversion overhead, in my case it's faster than using either String or ByteString alone
08:53:16 <mangaba_leitosa> Hannibal_Smith: but memory was not my concern...
08:53:27 <mangaba_leitosa> Hannibal_Smith: speed was
08:54:03 <Hannibal_Smith> I can live with poor string functions performance, but not with a program that needs severals gb of memory
08:54:58 <Hannibal_Smith> I don't really like the fact that one would end using different string libraries in the some code...
08:55:11 <Tekmo> `ByteString` is intended for binary data
08:55:14 <Tekmo> `Text` is for textual data
08:55:56 <Hannibal_Smith> Tekmo, yes but if having a lot of little strings are going to needs severals gb of heap
08:56:07 <mcstar> bytestring is closer to a vector, thats the way it should be handled, if you need both speed and memory
08:56:08 <Hannibal_Smith> With Text
08:56:38 <Tekmo> Hannibal_Smith: Text is UTF-16 encoded, and the only overhead on top of that are two Ints per string
08:56:58 <Hannibal_Smith> mceier, I did read some not so goods story about ByteString, like that they are not movable by the GC
08:57:43 <mangaba_leitosa> Tekmo: I was talking about ByteString.Char8, actually
08:57:55 <Tekmo> mangaba_leitosa: Yeah, I understand
08:59:17 <mangaba_leitosa> Hannibal_Smith: acccording to "886,108,144 bytes allocated in the heap; 114,218,424 bytes copied during GC", for my ByteString app, most of it gots garbage-collected rather than moved :-)
09:00:07 <Tekmo> ByteStrings are pinned, so they cause memory fragmentation
09:00:21 <mangaba_leitosa> Hannibal_Smith: and here data for the combined String/ByteString app that I was talking about: "4,843,282,104 bytes allocated in the heap; 844,627,380 bytes copied during GC"
09:00:22 <Tekmo> This is only an issue if you have lots of long-lived bytestrings that occupy a ton of memory
09:00:37 <Hannibal_Smith> Tekmo, it's my usercase
09:00:40 <mangaba_leitosa> "77,562,244 bytes maximum residency (16 sample(s))"
09:00:48 <Tekmo> Hannibal_Smith: How many strings do you have?
09:01:16 <mangaba_leitosa> looks like the app never needed more than 77 MB of data at once, yet during processing of a 4 MB text file 4 GB was used :-)
09:01:17 <Hannibal_Smith> Tekmo, I have to sustans like 500 circa at seconds
09:01:22 <Hannibal_Smith> *sustains
09:01:34 <Hannibal_Smith> I don't need raw performance
09:01:44 <Philonous_> zardoz``, Duplication it just one of the problems. You lose control of when the action is performed. You might end up changing the config file before it's begin read. Sure, you can prevent this by forcing the value, but it muddles operational and denotational semantics.
09:01:47 <Tekmo> Okay, so my guess is that your huge memory usage is not because of the choice of data type
09:01:54 <Tekmo> That sounds like a space leak
09:01:55 <Hannibal_Smith> But I need that it will not consume severals gb of memory
09:02:04 <Tekmo> I think your program is leaking space
09:02:25 <Philonous_> zardoz``, Besides, it makes it much harder to reuse your code.
09:02:59 <Tekmo> Hannibal_Smith: Because like I said, `Text` is very space-efficient
09:03:06 <mcstar> ghc allocates a lot, why is that allocation number so suprising? as it was said, maximum residency is reasonable
09:03:42 <stelleg> yay haskell.org is back!
09:03:46 <Tekmo> Hannibal_Smith: I'd expect a typical file to at most double in size when converted to `Text`
09:04:02 <Philonous_> zardoz``, The point is, the value of your configuration changes depending on when you look at it. So it's really not pure. A better, more composable way of doing it is using a Reader transformer
09:04:10 <Tekmo> Hannibal_Smith: If 4 MB explodes to 4 GB, that's not a problem with `Text`, but more likely a space leak
09:04:39 <Tekmo> Hannibal_Smith: Do you want me to guide you through debugging space leaks?
09:04:40 <mcstar> that is total allocation during the lifetime of the program, sint it?
09:04:41 <Hannibal_Smith> Tekmo, actually it's a socket server that have to elaborate some like 500 new string per seconds of variable length (150/500 chars)
09:04:49 <mcstar> he probably does a lot of processing
09:05:05 <mangaba_leitosa> mcstar: riight
09:05:09 <Hannibal_Smith> Each of these live for several minutes
09:05:33 <Hannibal_Smith> And have some text processing on it that generate some more shorten strings
09:05:42 <Tekmo> Hannibal_Smith: That should not consume more than 100 MB
09:05:47 <akamaus> can I export all the symbols from a module which was imported using qualified import?
09:05:55 <Hannibal_Smith> Ok, so I will use Text
09:06:05 <iLike> What's a good source to look through in order to get how Haskell is used in 'the real world'
09:06:07 <Hannibal_Smith> Thank you Tekmo
09:06:10 <shapr> Yow, that's many people
09:06:13 <Tekmo> Hannibal_Smith: You're welcome!
09:06:25 <shapr> Does anyone know of a transparent web proxy written in Haskell?
09:06:35 <MarcWeber> iLike: hackage. Look at the libraries which exist
09:06:41 <mcstar> i lost it, and cant find it
09:07:08 <mangaba_leitosa> mcstar: the first figure (886,108,144 bytes allocated, 18,556,064 bytes maximum residency) is for counting word frequencies in a 4 MB text file, and runtime is 5 sec
09:07:08 <iLike> MarcWeber, every package on Hackage consists of quality-code?
09:07:20 <hpc> @hackage acme-php -- iLike
09:07:20 <lambdabot> http://hackage.haskell.org/package/acme-php -- iLike
09:07:24 <MarcWeber> iLike: No, but if users "do something with Haskell" its likely to end up there.
09:07:25 <Tekmo> shapr: Any reason that you need it written in Haskell?
09:07:33 <shapr> Tekmo: No, Python would work... but I like Haskell
09:07:34 <mcstar> mangaba_leitosa: i think that is reasonable
09:07:46 <mangaba_leitosa> mcstar: the second figure with 4 GB is some more additional processing/transformation and runtime of about 15 seconds
09:07:49 <Tekmo> shapr: I mean, are you just deploying it, or are you going to be modifying it?
09:07:51 <mcstar> did you use maximum optimizations?
09:08:01 <mangaba_leitosa> mcstar: I used -O2, yes
09:08:22 <shapr> Tekmo: For my final project I want to do statistical learning on the words a user browses and try to find other web pages they might like as a background process.
09:08:24 <Destinova> Is notepad++ good enough for beginning to code in Haskell? Or would it be good programming practice to start off using something like emacs/vim?
09:08:45 <mcstar> anyway, if you have doubt about space usage, i suggest you space profile, and use -hy (iirc)
09:08:55 <mcstar> the easisest thing with ghc, and very useful
09:08:57 <iLike> hpc, thanks :)
09:08:59 <shapr> So, I want a transparent web proxy that dumps words into a support vector machine, and a simple web interface for thumbs up/down.
09:09:10 <hpc> Destinova: notepad++ is windows only
09:09:21 <shapr> Tekmo: The idea seems simple enough, and I know I could do it in Python, but I'd rather do it in Haskell if possible.
09:09:25 <FireFly> Destinova: use whatever editor you prefer. notepad++ is fine if you like using that
09:09:28 <hpc> Destinova: if you are on windows i suggest notepad++, but using vim on windows is absolutely miserable
09:09:30 <iLike> MarcWeber, yea that's what I thought. I'd like to get a (good) grasp of haskell formatting & best practices
09:09:33 <shapr> Tekmo: any thoughts or input?
09:09:36 * mcstar needs to go through vimtutor
09:09:40 <mangaba_leitosa> mcstar: thanks, will try :-)
09:09:43 <Destinova> I do have a windows machine.
09:09:44 <hpc> i use n++ all the time
09:09:49 <Tekmo> shapr: I'm not an expert on proxies, but maybe I can write up one for you right now
09:09:53 <Tekmo> shapr: What features does it need?
09:09:54 --- mode: ChanServ set +o Tekmo
09:10:07 <shapr> Tekmo: you have the power!
09:10:10 <Tekmo> Haha
09:10:37 <shapr> Tekmo: I just want to pull out the words from the body and dump them into a support vector machine, so not many features needed at all.
09:10:37 <Destinova> FireFly: I really have no preference, so far the little coding I've done has been on ordinary notepad
09:10:51 * shapr looks for a svm library for Haskell
09:10:54 <mangaba_leitosa> mcstar: I was just trying to minimize 'GC percentage' and maximize 'productivity' by allocationg more heap using -H128m, -H640m and so on to find out if productivity will stablize at some point
09:11:06 <MarcWeber> iLike: For each task there is a "good/best" tool. For a lot of tasks Haskell can be a good choice, for others there are existing solutions written in other languages eventually.
09:11:12 <Tekmo> shapr: So you mean that you need to basically log all incoming data to this SVM and then forward it on?
09:11:34 <mangaba_leitosa> mcstar: but I cannot allocate more than -H1600m before swapping begins, so I don't know what's the optimal heap value really is :-)
09:11:45 <shapr> Tekmo: The words will get sent to the SVM for training, yes.
09:11:51 <FireFly> Destinova: if you go with emacs or vim or something you'll probably have to spend some time getting to know the editor before actually starting to code (well, I can't speak for emacs.. but for vim you definitely have to :p)
09:11:52 <Tekmo> shapr: Got it
09:12:07 <shapr> I could probably use scotty now that I think about it.
09:12:13 <Tekmo> shapr: Alright
09:12:22 <FireFly> Destinova: so I guess it's a tradeoff if you want to learn both a new editor and a new language, or just want to dig into Haskell with learn you a haskell or something. In the latter case I'd just go with notepad or NP++ or something
09:12:23 <shapr> I do like the simplicity of scotty :-)
09:12:27 <shapr> Tekmo: How's fun code treating you?
09:12:34 <Tekmo> shapr: Great!
09:12:45 <shapr> Written anything nifty lately?
09:12:50 <Tekmo> shapr: Yeah
09:12:54 <mcstar> mangaba_leitosa: imho you shouldnt mess with those, the real benefits will come from having a good understanding of  your program's space usage
09:13:01 <Tekmo> shapr: My favorite work at the moment is cleaning up my `rcpl` library
09:13:14 <Tekmo> shapr: It's a prelude to a proposal for how to structure FRP programs for game programming
09:13:14 <mcstar> and when thats done, you could increase minimum allocation amount..
09:13:27 <mcstar> (if the prog. still benefits from it)
09:13:36 <shapr> Tekmo: that does sound nifty
09:13:38 <Tekmo> Yeah
09:13:53 <Tekmo> The basic idea is that I distill the game logic into the `ListT (State Game)` monad
09:13:53 <shapr> Tekmo: So you're gabriel439 on github?
09:13:56 <Tekmo> Yeah
09:13:59 <shapr> spiffy
09:14:03 * shapr follows Tekmo on github
09:14:05 <Tekmo> :)
09:14:13 <mangaba_leitosa> mcstar: probably I shouldn't, but without '-with-rtsopts=-Hsomething' the app takes 17 seconds instead of 5 :-)
09:14:21 <shapr> Tekmo: What's the 439?
09:14:30 <Tekmo> The first 438 Gabriels were taken
09:14:41 <shapr> ha
09:15:01 <mangaba_leitosa> mcstar: so, I see -H like a real benefit :-)
09:15:26 <Tekmo> So I find that `ListT` + `State` works really well for structuring concurrent program logic
09:15:31 <zardoz``> Philonous_ I know
09:15:58 * hackagebot pipes-postgresql-simple 0.1.1.2 - Convert various postgresql-simple calls to work with pipes  http://hackage.haskell.org/package/pipes-postgresql-simple-0.1.1.2 (OliverCharles)
09:15:59 <hpc> Tekmo: be careful, ListT isn't a real transformer; read the docs
09:16:05 <Tekmo> Ha!
09:16:07 <Destinova> It is the latter. I was in here bugging people about wanting to learn Haskell and someone recommended Learn you a Haskell..... So notepad++ it'll be then
09:16:09 <Tekmo> You assume that I'm using that ListT
09:16:13 <Tekmo> I'm using the `pipes` ListT
09:16:13 <zardoz``> Philonous_ I will look at the reader transformer
09:16:17 <Tekmo> ... which is ListT done right!
09:16:22 <Destinova> Thanks hpc and FireFly
09:16:23 <Tekmo> It's a proper monad and monad transformer
09:16:24 <hpc> ah
09:16:28 <hpc> LogicT by any other name
09:16:30 <Tekmo> Nope
09:16:35 <hpc> no?
09:16:39 <Tekmo> Wait
09:16:41 <Tekmo> Let me confirm that
09:16:46 <Tekmo> It's been a year since I studied LogicT
09:17:29 <Tekmo> Never mind
09:17:33 <Tekmo> Yeah, it's the same as LogicT
09:17:41 <Tekmo> Isomorphic, technically
09:17:44 <zardoz``> > let (x,y) = (1,2) in x + y   -- any nicer way of writing this?
09:17:46 <lambdabot>   3
09:18:17 <triliyn> > uncurry (+) (1,2)
09:18:18 <lambdabot>   3
09:18:37 <mcstar> anyone knows if it is recommneded to install GHC via homebrew?
09:18:39 <zardoz``> nice one
09:23:09 <shapr> Tekmo: Are you writing up a proxy right now? Just wasn't sure how that conversation ended :-)
09:23:19 <Tekmo> shapr: Yeah, I was writing one up for fun
09:23:22 <Tekmo> You still interested?
09:23:25 <shapr> yes!
09:23:29 <Tekmo> Ok! :)
09:31:31 <chrisdone> Tekmo: http://www.reddit.com/r/haskell/comments/1qtr88/criticism_of_haskell_xpost_from_rprogramming/cdgfamu
09:31:38 <chrisdone> Tekmo: right?
09:32:06 <deweyvm> is there a good C parser for haskell?
09:32:15 <donri> @hackage language-c
09:32:16 <lambdabot> http://hackage.haskell.org/package/language-c
09:32:22 <donri> duno if good
09:32:39 <deweyvm> i really just need to parse headers
09:33:40 <donri> @hackage cpphs
09:33:41 <lambdabot> http://hackage.haskell.org/package/cpphs
09:34:35 <deweyvm> er i mean
09:34:40 <deweyvm> function declarations and constants
09:35:00 <Tekmo> chrisdone: Thanks for the link.  I'm on it
09:35:33 <shapr> chrisdone: howdy!
09:36:06 <shapr> chrisdone: How's code?
09:37:01 <deweyvm> ill try out language-c
09:38:19 <Tekmo> shapr: Oh wait, one thing I forgot to ask
09:38:24 <Tekmo> shapr: Is this an HTTP proxy?
09:38:35 <Tekmo> shapr: Or is it raw binary data?
09:39:56 <shapr> Tekmo: http proxy
09:40:08 <shapr> since I want to pull out the words of the pages the user browses
09:42:04 <Tekmo> shapr: Damn, then I won't be able to complete my `pipes`-based solution
09:42:15 <Tekmo> shapr: People are still working on the HTTP parsing stuff
09:42:21 <Tekmo> However, I'll just give you what I had so far
09:44:53 <bgamari> Tekmo, Would something like `interleave` here be nice to have somewhere?
09:44:57 <bgamari> perhaps pipes-concurrency
09:45:09 <Tekmo> I got a much simpler solution working
09:45:16 <Tekmo> The only thing it's missing is a decoder for HTTP headers
09:45:38 <bgamari> Tekmo, https://github.com/bgamari/job-server/blob/master/JobServer.hs#L37
09:47:04 <bgamari> Tekmo, (it takes multiple producers, runs them concurrently, and returns a producer which interleaves their results in non-deterministic order
09:47:21 <Tekmo> bgamari: Oh, I thought you were referring to shapr's problem
09:47:25 <Tekmo> shapr: Here: http://lpaste.net/95817
09:47:34 <Tekmo> shapr: There's only one part missing, which is a HEADER decoder
09:47:47 <Tekmo> shapr: If you know of a way to decode Headers using `Binary` then I can complete it
09:47:54 <bgamari> Tekmo, I should have been more clear
09:48:02 <Tekmo> bgamari: Yeah, I understand now :)  Sorry about that
09:48:16 <bgamari> Tekmo, You usually aren't on IRC so when I saw you were around I jumped on the opportunity to ask before you vanished ;)
09:48:20 <Tekmo> bgamari: :)
09:48:26 <shapr> Tekmo: thanks!
09:48:47 <Tekmo> bgamari: So the way I usually prefer to structure this is to convert a `Producer` to an `Input`, then use `mconcat` on the `Input`s
09:49:01 <Tekmo> bgamari: That then correctly interleaves their values
09:49:05 <Tekmo> shapr: You're welcome
09:49:59 <Tekmo> bgamari: So maybe I should add a `fromProducer` function to `pipes-concurrency` that converts Producers to Inputs
09:50:11 <bgamari> Tekmo, Yep, that would have solved my problem
09:50:43 <Tekmo> bgamari: Okay, I will open up an issue to remind myself to do this
09:51:20 <bgamari> Tekmo, I thought there must be a way to accomplish what I wanted with pipes-concurrent
09:51:33 <bgamari> cy*
09:52:00 <alexander__b> I wish types & type synonyms could have non alpha chars. */
09:53:25 <bgamari> Tekmo, now that I actually read the tutorial things make more more sense ;)
09:53:49 <Tekmo> bgamari: :)
09:55:54 <stelleg> so I'm getting different behavior for the functions (hPutBuf stdout) and (fdWriteBuf stdOutput), any ideas?
09:56:29 <stelleg> basically I'm piping raw ppm data to ffmpeg and it runs fine with hPutBuf but chokes on fdWriteBuf
09:56:50 <hpc> stelleg: maybe the line mode is munging things?
09:57:16 <stelleg> hpc: hmm, not familiar with line modes, I'll look into it though thanks
09:57:34 <hpc> stelleg: binary mode and text mode
09:59:21 <stelleg> that could be the issue, because its actually alternating between hPutStr and hPutBuf
09:59:36 <stelleg> or fdWrite and fdWriteBuf in the posix case
09:59:46 <stelleg> @src hPutStr
09:59:46 <lambdabot> Source not found. You untyped fool!
09:59:52 <stelleg> :(
10:00:18 <stelleg> @src hPutStrLn
10:00:18 <lambdabot> hPutStrLn hndl str = do hPutStr  hndl str; hPutChar hndl '\n'
10:00:25 <stelleg> duh
10:03:37 <lvella> a haskell package depends on vect
10:04:16 <lvella> if I apt-get install libghc-vector-dev
10:04:20 <lvella> will it do?
10:05:14 <Tekmo> lvella: Hav eyou installed the Haskell platform?
10:05:44 <lvella> from ubuntu's repositories
10:06:05 <lvella> I mean
10:06:13 <lvella> I have installed ghc and hugs
10:06:41 <Tekmo> You should install the haskell-platform package
10:06:57 <Tekmo> That will bring in the `vector` library
10:07:14 <Tekmo> So the basic idea is that the Haskell Platform was created to give a stable set of packages to minimize dependency conflicts
10:07:42 <lvella> just found it
10:07:43 <lvella> thanks
10:07:45 <Tekmo> So the rule of thumb I like to use is that the only packages that go in the global package database are the Haskell platform packges
10:07:52 <Dasuraga> Is there a place that sort of summarizes all the optimizations GHC is prone to make? Out of curiosity more than anything
10:08:01 <Tekmo> Then everything else I install locally using cabal or cabal-dev/cabal sandbox
10:08:25 <Tekmo> There's a good Stack Overflow answer on this.  Let me look it up
10:08:44 <daniel31415> @Botsnack
10:08:44 <lambdabot> :)
10:09:48 <Tekmo> daniel31415: http://stackoverflow.com/questions/6048194/good-introductory-text-about-ghc-implementation/6048706#6048706
10:09:51 <Tekmo> Oops
10:09:55 <Tekmo> I mean Dasuraga
10:10:53 <Tekmo> Dasuraga: Another answer that you might find useful: http://stackoverflow.com/questions/15750998/which-techniques-have-contributed-the-most-to-haskells-improving-performance/15759123#15759123
10:11:03 * hackagebot haskeline 0.7.1.0 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.7.1.0 (JudahJacobson)
10:13:22 <yepyep> :t join
10:13:22 <lambdabot> Monad m => m (m a) -> m a
10:13:33 <yepyep> :t Nothing
10:13:34 <lambdabot> Maybe a
10:13:56 <Tekmo> yepyep: Note that the `a` can itself be another `Maybe`
10:14:11 <intrados> If I want to parse JSON from multiple sources into the same type with Aeson, what's the best way to do that and avoid orphan instances?
10:14:44 <yepyep> :t join Nothing
10:14:45 <lambdabot> Maybe a
10:14:48 <desheng> I think I've figured out something about how things like the State monad work but i'm not sure: would it be correct to say "the State monad could be completely implemented in Haskell without any "magic", but by using the built-in monad, the compiler will optimize your code to "cheat" and use "real" state "
10:15:07 <yepyep> I don't understand how (join Nothing) works
10:15:10 <Tekmo> :t join (Nothing :: Maybe (Maybe Int))
10:15:11 <lambdabot> Maybe Int
10:15:15 <Tekmo> Maybe that will help
10:15:28 <danr> join (Just (Just a)) = a; join _ = Nothing
10:15:31 <yepyep> ah
10:15:32 <danr> uh
10:15:35 <danr> = Just a *
10:15:36 <MarcWeber> desheng: Try to learn more about monads.
10:15:46 <MarcWeber> There are many tutorials. There is no "builtin monad".
10:15:47 <osa1> do we have any libraries to make terminal based user interfaces like vim/emacs -nw etc. ?
10:15:54 <mm_freak> intrados: i suppose you don't want to have everything in a single module, in which case that's a surprisingly difficult problem
10:15:55 <MarcWeber> Monad is a class only providing >>= >> and return
10:15:56 <yepyep> so it's casting to join (Nothing :: Maybe (Maybe a))?
10:16:01 <Tekmo> yepyep: Right
10:16:05 <yepyep> ok
10:16:12 <yepyep> i didn't know that was possible. cool.
10:16:17 <Tekmo> yepyep: the `a` in the type `Nothing :: Maybe a` can itself be another `Maybe`
10:16:40 <yepyep> i see.
10:16:57 <yepyep> so it implicitly assumes it's another nested Maybe
10:17:02 <mm_freak> intrados: you can use auxiliary types X', X'', X''' that are isomorphic to the target type X, then write functions like X' -> X
10:17:31 <desheng> does the compiler do any sort of optimization when Control.Monad.State is used, that would be different than how it would act if I defined State' on my own?
10:17:36 <mm_freak> intrados: in other words, use different types in different modules, and in the module defining X all you do is to map from X', X'' and X''' to X
10:17:49 <MarcWeber> desheng: Get your hands dirty and "define state on your own"
10:18:14 <intrados> mm_freak: Yeah. I thought of that though it seemed somewhat ungraceful. Maybe type synonym instances?
10:18:30 <monochrom> desheng, the answer is no.
10:18:38 <mm_freak> intrados: well, i think keeping the types separate would be helpful actually
10:18:48 <mm_freak> intrados: you can write Iso lenses between them
10:18:59 <desheng> thank you monochrom
10:19:09 <mm_freak> intrados: like: write a 'class HasX a' that defines an Iso between X and 'a'
10:19:44 <MarcWeber> desheng: You should have a look at the State implmenetation, then you'll understand how it works, then you'll understand how that might differ from "defining state on your own" or whatever you mean by talking so.
10:20:00 <MarcWeber> desheng: Do you need help finding the State monad implementation eg of ghc base library?
10:20:01 <intrados> mm_freak: Hm. I'll look into Iso lenses. Thakns
10:20:12 <mm_freak> intrados: see the 'lens' package
10:20:39 <mm_freak> an Iso is really just a pair of functions, the two components of an isomorphism
10:21:04 * hackagebot haskeline 0.7.1.1 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.7.1.1 (JudahJacobson)
10:21:16 <desheng> MarcWeber: yeah that would be helpful I think. should I checkout the source code to GHC or is there a searchable "look at how GHC implements it" site online?
10:22:18 <MarcWeber> desheng: haskell.org -> links to Hoogle, Hayoo
10:22:36 <desheng> I just figured that the compiler might look for ways to make the compiled code more "imperative-like" with real mutable state as long as the implementation acts the exact same way as a fully FP one would
10:22:42 <MarcWeber> desheng: In Hoogle type "State"
10:22:50 <desheng> thanks, i'll check out Hoogle
10:22:56 <MarcWeber> Then you'll learn that there are two implementations: lazy and strict.
10:23:12 <MarcWeber> desheng: bottom right there is a _source_ link
10:23:54 <desheng> okay thank you
10:24:39 <deweyvm> how would i discard all input in parsec until i find a certain word?
10:25:56 <chrisdone> manyTill
10:26:13 <chrisdone> e.g. manyTill anyToken (string "potatoes")
10:26:38 <deweyvm> ahh thats perfect, thanks
10:26:43 <deweyvm> i was looking in the wrong module
10:26:52 <hpc> parsec's a big package
10:29:47 <MarcWeber> desheng: newtype State s a = State { runState :: s -> (a, s) } this is the most simple implementation.
10:29:53 <chrisdone> hpc: working on anything?
10:30:10 <MarcWeber> In GHC it has changed ?. So in Haskell a state is basically a function to which you pass a state, and which returns a result and a new state.
10:30:11 <hpc> chrisdone: anything haskell/hackage? why?
10:30:17 <MarcWeber> Everything else is just syntastic suggar.
10:30:25 <chrisdone> hpc: just wondering =)
10:30:34 <hpc> nah, slow weekend for me
10:30:48 <chrisdone> =)
10:39:51 <Iceland_jack> já
10:45:37 <lvella> is there some kind of conditional import?
10:45:52 <lvella> this package uses Win32
10:46:32 <hpc> lvella: sounds like a job for CPP
10:46:34 <lvella> I want to make it optional, and use Linux equivalent when not on windows?
10:46:41 <hpc> i think the relevant flag is MINGW
10:47:18 <lvella> you mean, I have to precompile the haskell source? like C?
10:47:55 <hpc> no, CPP is just the macro part of C
10:48:10 <hpc> {-# LANGUAGE CPP #-} enables it, and ghc does the rest
10:48:14 <hpc> (also ghci)
10:49:20 <zardoz``> C preprocessor in haskell? :-O
10:50:47 <quchen> zardoz``: It's pretty common.
10:57:03 <haasn> can't you also use conditional includes in .cabal files?
10:57:10 <haasn> and include a different version of the module source
10:57:14 <haasn> if it's significantly different
10:57:27 <haasn> (but exposes the same API)
10:57:57 <dcoutts_> haasn: actually you could, by using a conditionally defined search path
10:58:36 <mrmonday> I'm looking for a function which takes "hello" and [1,2,3] and gives me [("hello", 1), ("hello", 2), ("hello", 3)] could someone point me in the right direction please?
10:58:50 <Rembane> mrmonday: zip and another one.
10:59:16 <haasn> :t zip . repeat
10:59:17 <lambdabot> a -> [b] -> [(a, b)]
10:59:40 <mrmonday> ooh, cool, thanks
10:59:55 <nooodl_> @unpl zip . repeat
10:59:55 <lambdabot> (\ c -> zip (repeat c))
11:00:39 <nooodl_> oh. of course. anyway i'd write (\x ys -> zip (repeat x) ys) for clarity i think?
11:01:08 <haasn> :t fmap . (,)
11:01:09 <lambdabot> Functor f => a -> f a1 -> f (a, a1)
11:01:28 <haasn> (generalized)
11:01:58 <FireFly> @pl \x -> map ((,) x)
11:01:58 <lambdabot> map . (,)
11:02:04 <FireFly> Oh, naturally
11:03:31 <mangaba_leitosa> > zip . repeat $ "hello" [1,2,3]
11:03:32 <lambdabot>   Couldn't match expected type `[t0] -> a0'
11:03:32 <lambdabot>              with actual type `[G...
11:03:45 <mangaba_leitosa> > zip . repeat "hello" $ [1,2,3]
11:03:46 <lambdabot>   Couldn't match expected type `[t0] -> [a0]'
11:03:47 <lambdabot>              with actual type `...
11:03:49 <mangaba_leitosa> :-(
11:04:02 <Rembane> > (zip . repeat ) "hello" [1,2,3]
11:04:03 <lambdabot>   [("hello",1),("hello",2),("hello",3)]
11:04:13 <lvella> what liftIO does?
11:04:25 <mangaba_leitosa> Rembane: thanks :-)
11:04:26 <k00mi> > (map . (,)) "hello" [1,2,3]
11:04:27 <lambdabot>   [("hello",1),("hello",2),("hello",3)]
11:04:32 <Rembane> mangaba_leitosa: np. :)
11:04:40 <dv-> :t liftIO
11:04:41 <lambdabot> MonadIO m => IO a -> m a
11:04:44 <dv-> lvella: that ^
11:04:53 <lvella> yeah
11:04:56 <lvella> I saw that
11:05:12 <lvella> but I think I didn't grasp the meaning
11:05:39 <dv-> it lets you run IO actions in other monads (that have a MonadIO instance)
11:05:44 <geekosaur> so, when you base a monad stack on IO, you need to reach the IO. so you derive MonadIO for ach level of the stack, and then liftIO lets you lift an IO action directly to the IO at the base of the stack
11:05:54 <geekosaur> instead of having to keep track of how deep your stack is
11:06:29 <lvella> ok, then what I really need is a monad tutorial...
11:06:38 <lvella> because I could understand nothing
11:06:48 <FireFly> I'm not sure if you need a monad tutorial
11:07:02 <Philonous> Am I mistaken in assuming that it's possible to translate basically any random C program into an haskell IO program?
11:07:14 <Philonous> Safe for global variables, perhaps
11:07:17 <FireFly> But you might want to look into LYAH's portion on monads or typeclassopedia or something
11:07:45 <geekosaur> Philonous, they're Turing equivalent. figuring out how is of course another matter, and doing it idiomatically something else again, but it's guaranteed to be possible
11:08:08 <geekosaur> (see also: Turing tarpit)
11:08:30 <mangaba_leitosa> Philonous: I guess that you can't do *(NULL) = 'a'  in Haskell :-)
11:09:39 <lvella> what is the difference between a Monad and a MonadIO ?
11:09:44 <Philonous> Well, my point is, I don't understand why people keep wailing about typed effects. If you don't like checked effects you can just write your entire program in IO and basically have everything that C offers you, including nullpointers, though maybe a bit more verbose.
11:10:04 <Philonous> lvella, a MonadIO is a Monad that allows you to perform IO actions.
11:10:18 <mm_freak> FireFly: you need an mtl/transformers tutorial, not a monad tutorial =)
11:10:33 <mm_freak> MonadIO is pretty much like MonadState, MonadReader, MonadWriter, etc.
11:10:56 <Philonous> mangaba_leitosa, I'm pretty sure you can
11:11:03 <mm_freak> you have an IO somewhere in the stack and you want to perform an IO action using it
11:11:14 <mangaba_leitosa> Philonous: I don't know how anyway :-) Maybe be linking to a C library :_)
11:11:18 <mm_freak> MonadState:  you have a StateT somewhere in the stack and you want to perform a state update using it
11:11:21 <mm_freak> etc.
11:11:21 <Cale> lvella: To put it another way, MonadIO is a subclass of Monad which has just one operation: liftIO :: (MonadIO m) => IO a -> m a -- i.e. it gives you a way to turn IO actions into m-actions.
11:11:24 <Philonous> @type poke (castptr nullptr) 'a'
11:11:25 <lambdabot> Not in scope: `poke'
11:11:25 <lambdabot> Not in scope: `castptr'
11:11:25 <lambdabot> Not in scope: `nullptr'
11:11:54 <lvella> I never used any monad besides IO
11:11:54 <triliyn> mangaba_leitosa: there's a library for working with pointers I think; there's just no syntax for it
11:12:04 <Cale> :t Foreign.Ptr.nullPtr
11:12:05 <lambdabot> GHC.Ptr.Ptr a
11:12:06 <mangaba_leitosa> lambdabot: yes, I know that you can get a pointer. But can you assign to memory pointed by them? :-0
11:12:07 <mm_freak> lvella: i don't believe that =)
11:12:20 <mangaba_leitosa> triliyn: yes, I know that you can get a pointer. But can you assign to memory pointed by them? :-0
11:12:21 <mm_freak> lvella: you certainly used lists or Maybe ;)
11:12:26 <lvella> yes
11:12:27 <lvella> I did
11:12:31 <Cale> :t Foreign.Ptr.poke (Foreign.Ptr.castPtr Foreign.Ptr.nullPtr) 'a'
11:12:32 <lambdabot> Not in scope: `Foreign.Ptr.poke'
11:12:33 <Philonous> mangaba_leitosa, poke (castPtr nullPtr) 'a'
11:12:35 <mm_freak> there, you already used three monads
11:12:44 <mm_freak> at least ;)
11:12:44 <lvella> but the only name I saw written about as IO
11:12:46 <Philonous> mangaba_leitosa, from Foreign.Ptr
11:12:49 <Cale> :t Foreign.Storable.poke (Foreign.Ptr.castPtr Foreign.Ptr.nullPtr) 'a'
11:12:50 <lambdabot> IO ()
11:12:52 <mangaba_leitosa> Philonous: ah, ok, thanks :-) will now do it in all my apps :-)
11:12:54 <lvella> IO () and such
11:12:56 <Cale> there we go ;)
11:12:58 <lvella> IO Int
11:13:01 <lvella> etc
11:13:26 <mangaba_leitosa> Cale: and where is core dump?
11:13:29 <FreeFull> lvella: import Foreign; import Foreign.Ptr; main = poke nullPtr 3
11:13:29 <mm_freak> lvella: well, IO isn't really the most interesting monad
11:13:33 <Cale> mm_freak: Well, you're not really using the list monad until you use something which works with all monads and specialise it to lists
11:13:47 <Cale> mangaba_leitosa: You'll have to execute that code
11:13:50 <mm_freak> lvella: it's an easy one to get started…  you need to wrap your head around the idea of first class actions
11:13:52 <Cale> (lambdabot won't)
11:13:56 <maikklein> can someone explain this error to me? "cabal: can't find source for Horde3DUtils_h in src, dist/build/autogen". Does this mean it can not find the .h file?
11:13:57 <FreeFull> lvella: That's pretty much equivalent to *(NULL) = 3;
11:14:02 <mm_freak> Cale: map
11:14:05 <mangaba_leitosa> sorry lambdabot
11:14:06 <Cale> ghci> Foreign.Storable.poke (Foreign.Ptr.castPtr Foreign.Ptr.nullPtr) 'a'
11:14:06 <Cale> Segmentation fault
11:14:13 <mangaba_leitosa> ah, ok :-)
11:14:33 <dv-> > replicateM 2 [1,2]
11:14:34 <lambdabot>   [[1,1],[1,2],[2,1],[2,2]]
11:14:36 <koala_man> @hoogle a -> [a] -> [[a]]
11:14:37 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
11:14:37 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
11:14:37 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
11:14:53 <Cale> mm_freak: map (unfortunately) doesn't work with other monads right now ;)
11:14:55 <koala_man> how do I split a list on some element?
11:14:58 <mangaba_leitosa> Cale: it's relieving to know you ARE able to shoot you in the foot in Haskell :-)
11:15:10 <mm_freak> Cale: but 'map' is a monadic function =)
11:15:15 <Cale> :t map
11:15:16 <lambdabot> (a -> b) -> [a] -> [b]
11:15:20 <mm_freak> you may prefer to call it liftM ;)
11:15:22 <Cale> ^^ no abstraction over the monad
11:15:30 <Cale> :t liftM
11:15:31 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:15:34 <Cale> ^^ this is different
11:15:35 <Philonous> mangaba_leitosa, Well, Haskell is useful, after all
11:15:51 <Cale> (but yes, it's also the same ;)
11:15:53 <mangaba_leitosa> Philonous: :-)
11:15:56 <mm_freak> Cale: i understand your point, but my point is that you have already used a monadic interface to lists, when you have used 'map'
11:16:04 <lvella> the thing is, when I learned about functional programming, in the first semester of college, the only stuff they taught us was the pure stuff, and we completed the course writing pure functions and running it with parameters on hugs
11:16:13 <Cale> Actually, that's just a functorial interface to lists
11:16:22 <mm_freak> lvella: nothing wrong with that
11:16:22 <Cale> You can't get return or bind only knowing fmap
11:16:44 <Philonous> mangaba_leitosa, Btw. did you have an IRC name before this one?
11:16:46 <Cale> But if you've used concatMap, that's a good deal closer
11:16:58 <mm_freak> or just concat
11:17:00 <mangaba_leitosa> Philonous: yes, umbu_travoso
11:17:03 <Cale> Or list comprehensions
11:17:16 <Cale> (especially ones with more than one generator)
11:17:18 <FreeFull> You can get return knowing fmap and some sort of f ()
11:17:18 <Philonous> mangaba_leitosa, I see
11:17:23 <mm_freak> or the good old (:[]) smiley =)
11:17:38 <FreeFull> The robot monkey I think
11:17:48 <scott_> Is there a tool for playing with specializing types? Say :t (>>=) with m = [] without typing out the full specialized signature mantually?
11:17:55 <yepyep> koalaman: did you try splitOn?
11:17:59 <yepyep> :t splitOn
11:18:00 <lambdabot> Eq a => [a] -> [a] -> [[a]]
11:18:08 <Cale> :t asTypeIn
11:18:09 <lambdabot> a -> (a -> b) -> a
11:18:20 <mm_freak> scott_: you can specialize one of the components
11:18:39 <mm_freak> :t \x -> ((x :: [a]) >>=)
11:18:40 <Cale> :t (>>=) `asTypeIn` (\(>>=) -> [] >>= return)
11:18:41 <lvella> now to these actions
11:18:41 <lambdabot>     Couldn't match expected type `t' with actual type `[a1]'
11:18:41 <lambdabot>       `t' is a rigid type variable bound by
11:18:41 <lambdabot>           the inferred type of it :: t -> (a -> [b]) -> [b] at Top level
11:18:41 <lambdabot> [b] -> (b -> [b]) -> [b]
11:18:48 <Cale> hrm
11:18:48 <Philonous> FreeFull, No. Consider (foo = putStrLn "Side effects here" :: IO ()). \x -> fmap (const x) foo is not return
11:18:49 <lvella> I just assume they are just like functions
11:18:59 <lvella> but enforced by monads to run in order
11:19:03 <mm_freak> Cale's solution is better
11:19:08 <Cale> :t (>>=) `asTypeIn` (\(>>=) -> [1,2,3] >>= (\x -> [x,10*x]))
11:19:09 <lambdabot> Num b => [b] -> (b -> [b]) -> [b]
11:19:21 <Cale> asTypeIn is lambdabot-specific though
11:19:55 <mm_freak> lvella: the connection between monads and sequencing is that you can use the monadic interface to express sequenced actions
11:19:56 <Cale> lvella: You should think of IO actions as being *descriptions* of things to be done.
11:19:57 <yepyep> koala_man: sorry, i typed your name wrong.  Would splitOn do the trick?
11:20:00 <mm_freak> that's exactly what IO does
11:20:09 <mm_freak> lvella: but monads aren't related to sequencing in general
11:20:26 <koala_man> yepyep: perfect, thanks
11:20:30 <yepyep> :)
11:20:33 <Cale> lvella: There are various ways to glue these descriptions together, and due to the nature of I/O, recording the ordering somehow is obviously important.
11:21:19 <Cale> lvella: The Monad interface just describes some of the ways that things can be glued together, and IO actions have operations which fit that interface.
11:21:31 <mm_freak> lvella: it may be helpful to think of IO as a language for first class actions
11:21:54 <mm_freak> if an IO Int is an action to produce an Int, then the type of (>>=) becomes more obvious
11:21:58 <Cale> The fact that IO happens to be a monad is not as big a deal as the fact that IO actions are values of a separate type.
11:22:06 <Cale> :t getLine
11:22:07 <lambdabot> IO String
11:22:38 <Cale> getLine is an IO action which gets a line of text from the user. Evaluating getLine doesn't do a whole lot except make your computer ever-so-slightly warmer.
11:22:53 <Cale> *Executing* it actually carries out the effects it describes
11:22:59 <ion> IO could refrain from providing a Monad instance and provide its own way to put together multiple IO actions and it would work just fine.
11:23:15 <Cale> ion: right
11:23:32 <mm_freak> lvella: and execution happens beyond haskell…  you can think of a haskell interpreter as actually reading your 'main' IO action and executing what real world side effects it denotes
11:23:50 <mm_freak> conceptually think of a compiled haskell program as being such an interpreter
11:23:52 <FreeFull> > getLine `seq` 3
11:23:53 <lambdabot>   3
11:23:54 <ion> “What is inside Haskell IO?” may or may not be helpful. https://gist.github.com/ion1/7154691
11:24:20 <FreeFull> Haskell didn't always have monads
11:24:27 <mm_freak> lvella: the monadic interface solves a very specific problem
11:24:41 <mm_freak> lvella: think of putStrLn…  it produces an IO action from a string
11:24:44 <mm_freak> :t putStrLn
11:24:44 <lambdabot> String -> IO ()
11:24:53 <lvella> yes
11:24:58 <mm_freak> what if the String itself is the result of an IO action like getLine?
11:24:59 <Cale> Given the same string, this function always produces the same action.
11:25:15 <mm_freak> you have an IO String, that is an action to produce a string
11:25:28 <mm_freak> and you have putStrLn, which expects a String (not an IO String)
11:25:31 <mm_freak> that's where (>>=) comes in
11:25:49 <mm_freak> (>>=) :: IO String -> (String -> IO b) -> IO b
11:25:54 <mm_freak> it glues the two together
11:26:02 <FreeFull> I'm not sure how IO worked before monads, but it worked
11:26:10 * hackagebot mongodb-queue 0.3 - message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.3 (GregWeber)
11:26:11 <Cale> FreeFull: Well, it was pretty awkward
11:26:11 <mm_freak> FreeFull: rather poorly
11:26:24 <scott_> http://stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o
11:26:34 <lvella> well, you are explaining to me about how IO works
11:26:44 <lvella> that notion I had already
11:26:45 <Cale> lvella: Let's look at a few other monads
11:26:48 <mm_freak> FreeFull: pretty much like 'interact', but with something more general than String -> String
11:26:59 <mm_freak> [Response] -> [Action]
11:27:05 <Cale> Remember that a monad is something which implements this class:
11:27:08 <Cale> class Monad m where
11:27:14 <Cale>   return :: a -> m a
11:27:18 <mm_freak> lvella: oh, ok
11:27:24 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
11:27:36 <Cale> Let's make an instance for lists
11:27:41 <SaBer> lvella: are you familiar with Functors?
11:27:41 <mm_freak> lvella: then what's your confusion about?
11:27:56 <Cale> return :: a -> [a] -- Let's use the most obvious function of this type
11:28:00 <Cale> return x = [x]
11:28:18 <Cale> and then what should (>>=) :: [a] -> (a -> [b]) -> [b] do?
11:28:36 <Cale> We have a list of a's, and a function from a's to lists of b's, and we want to get a list of b's.
11:28:59 <mm_freak> a useful way to solve that is to ask what flip (>>=) should do =)
11:29:00 <Cale> lvella: Any ideas? :)
11:29:12 <lvella> thinking here
11:29:44 <yepyep> @run return 2 :: [Int]
11:29:45 <lambdabot>   [2]
11:30:02 <lvella> it could map and concatenate, I dont know
11:30:05 <FreeFull> One thing about haskell, you often can just blindly follow the types and end up with something that works, even if you're not sure how it works
11:30:06 <Cale> yes!
11:30:12 <mm_freak> lvella: you solved it =)
11:30:13 <Cale> xs >>= f = concat (map f xs)
11:30:46 <Cale> So, what does this give us?
11:30:55 <Cale> Are you already familiar with do-notation for IO?
11:31:00 <lvella> yes
11:31:06 <lvella> actually, no
11:31:11 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
11:31:12 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
11:31:14 <lvella> I have learned it some time in past
11:31:18 <Cale> This is equivalent to:
11:31:36 <Cale> > [1,2,3] >>= \x -> [4,5] >>= \y -> [6,7,8] >>= \z -> return (x,y,z)
11:31:37 <lvella> but I would have to look if you asked me to write it
11:31:38 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
11:32:09 <mm_freak> btw, we've often had a debate about better names for 'return'
11:32:16 <mm_freak> my personal favorite is 'singleton'
11:32:21 <Cale> I'm strongly on the side of calling it "return"
11:32:21 <lvella> but I know it maps >>= to a more imperative syntax
11:32:24 <FreeFull> singleton is too long
11:32:30 <Cale> The do-notation desugars as follows:
11:32:36 <Cale> do { x } = x -- base case
11:32:37 <FreeFull> We could just call it pure
11:32:47 <FreeFull> > do do do do do 3
11:32:49 <lambdabot>   3
11:33:00 <chrisdone> in wearing the hair shirt it's listed as `unit'
11:33:08 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> } -- whenever v is a single variable or other unfailable pattern
11:33:29 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
11:33:43 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
11:34:01 <Cale> where   x >> y = x >>= \k -> y
11:34:27 <FreeFull> Note that the k gets discarded
11:34:37 <Cale> (though (>>) is a method of Monad with that as the default implementation just in case there's some more efficient way to implement it)
11:34:45 <yepyep> or equivalently x >> y = x >>= \_ -> y
11:34:51 <yepyep> :t (>>)
11:34:51 <lambdabot> Monad m => m a -> m b -> m b
11:34:59 <mm_freak> or const y or …
11:35:13 <mm_freak> that's not really important here =)
11:35:27 <FreeFull> I still wish join was part of the class
11:35:56 <mm_freak> lvella: now let me go slightly beyond Cale's explanation…  what problems are we actually solving?
11:36:16 <yepyep> mm_freak: you can use an ellipsis as a discardable value?
11:36:28 <mm_freak> Functor:  you have an [a] and an a -> b, and you want a [b]:  (a -> b) -> [a] -> [b]
11:36:42 <mm_freak> Applicative:  this time you have an [a -> b]:  [a -> b] -> [a] -> [b]
11:36:51 <yepyep> err. sorry, i interpreted that too literally.
11:36:55 <mm_freak> Monad:  this time you have an a -> [b]:  (a -> [b]) -> [a] -> [b]
11:37:14 <Cale> If Monad is to be a meaningful abstraction, if there's to be any point to this, we'd better be able to define some operations which will work with any instance of Monad
11:37:34 <mm_freak> lvella: the problems they solve are very related, only differing in what kind of map you want to apply
11:37:42 <Cale> So that there will be some reason for people to define instances of the class -- they then get those operations for free.
11:37:49 <FreeFull> Comonad: This time you have an [a] -> b: ([a] -> b) -> [a] -> [b]
11:38:01 <Cale> sequence is one such library function
11:38:03 <Cale> :t sequence
11:38:03 <lambdabot> Monad m => [m a] -> m [a]
11:38:24 <mm_freak> lvella: in each case you have some 'wrapped value' and you want to map a function over it
11:38:31 <edwardk> FreeFull: sadly the [a] -> a operation is partial, so [] isn't a Comonad.
11:38:32 <Cale> It takes a list of m-actions giving results of type a, and produces an m-action which gives a result which is a list of a
11:38:38 <FreeFull> edwardk: Yeah
11:38:44 <mm_freak> lvella: here is a fun exercise:  given the monadic mapper (called (>>=)) implement the functorial mapper (called fmap)
11:38:48 <FreeFull> You need non-empty lists
11:38:55 <Cale> It does this by running each in turn, and collecting a list of the results:
11:38:59 <Cale> sequence [] = return []
11:39:14 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:39:19 <edwardk> :t (Data.List.NonEmpty.:|)
11:39:20 <lambdabot> a -> [a] -> Data.List.NonEmpty.NonEmpty a
11:39:27 <mm_freak> lvella: for the list monad this means:  implement 'map' in terms of 'concatMap'
11:39:35 <lvella> it is too fast!
11:39:47 <edwardk> > extract (1 Data.List.NonEmpty.:| [2])
11:39:49 <lambdabot>   Not in scope: `extract'Not in scope: data constructor `Data.List.NonEmpty.:|'
11:39:54 <edwardk> > Control.Comonad.extract (1 Data.List.NonEmpty.:| [2])
11:39:55 <lambdabot>   Not in scope: `Control.Comonad.extract'Not in scope: data constructor `Data...
11:39:56 <mm_freak> lvella: expect this to happen in this channel =)
11:39:56 <Cale> In the list monad, this means we're "running" each of the lists in turn
11:39:59 <edwardk> bah safe haskell
11:40:01 <mm_freak> lvella: we're very helpful people =P
11:40:07 <mm_freak> sometimes too helpful =)
11:40:12 <SaBer> lvella: if you just want to learn about monads, I recommend reading http://learnyouahaskell.com/a-fistful-of-monads
11:40:15 <Cale> and well, what does that mean?
11:40:26 <nooodl_> haha i love how #haskell gets really excited and fast-paced when people ask about stuff like this
11:40:41 <Cale> You can think of "running" a list as picking one element from it in all possible ways
11:40:59 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return [x,y,z]
11:41:01 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
11:41:17 <mm_freak> Cale: warning: you started using "you can think of … as …" phrases!
11:41:24 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
11:41:25 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
11:41:34 <Cale> mm_freak: I see no problem with such phrases
11:41:50 <mm_freak> i'm just joking =)
11:42:07 <mm_freak> > sequence ["Hh", "Ee", "L", "l", "Oo0"]
11:42:08 <lambdabot>   ["HELlO","HELlo","HELl0","HeLlO","HeLlo","HeLl0","hELlO","hELlo","hELl0","h...
11:42:57 <Cale> lvella: In the IO monad, sequence can be applied to a list of IO actions to get a single IO action which runs them in turn and produces a list of their results
11:43:25 <Cale> lvella: In a parsing monad, sequence can be applied to a list of parsers to get a single parser for their concatenation, producing a list of the results.
11:43:44 <mm_freak> :t sequence [getLine, hGetLine stdin, return "blah"]
11:43:45 <lambdabot>     Not in scope: `hGetLine'
11:43:45 <lambdabot>     Perhaps you meant one of these:
11:43:45 <lambdabot>       `BSC.hGetLine' (imported from Data.ByteString.Char8),
11:45:17 <lvella> ok, about lift
11:45:45 <lvella> liftIO
11:46:17 <lvella> why it is needed?
11:46:35 <mm_freak> lvella: it's not needed
11:46:36 <Cale> lvella: In order to understand liftIO, you'll probably want to see an example of a monad which is built in terms of IO, and so can support that operation.
11:47:08 <mm_freak> lvella: liftIO is a convenience…  you may want to learn about monad transformers now
11:47:53 <mm_freak> lvella: how deep is your understanding of monad transformers?
11:49:16 <SaBer> mm_freak: he said just a while ago that he "hasn't used any other monad than IO", so I think his understanding on monads isn't that deep, not to mention monad transformers...
11:49:31 <mm_freak> i see
11:50:12 <mm_freak> lvella: before explaining liftIO you should implement a non-straightforward monad yourself
11:50:22 <mm_freak> lvella: Reader is easy
11:50:46 <mm_freak> newtype Reader e a = Reader (e -> a)
11:50:53 <mm_freak> try to write a Monad instance for this type
11:51:18 <lvella> I am still on the functor from monad thing
11:51:32 <lvella> (I think it is that what you asked, right?)
11:51:47 <mm_freak> lvella: oh, sure
11:52:02 <mm_freak> i thought you're not doing that exercise, but carry on =)
11:52:22 <aristid> would priority search queues make sense to implement something like a lru cache?
11:59:01 <jpcooper> what's the easiest way to do an inner product between two Data.Vector.Generic vectors?
11:59:23 <mm_freak> jpcooper: as in dot product?
11:59:33 <jpcooper> that is, I have (a -> b -> c), v a, v b, and I want v c
11:59:53 <jpcooper> not really an inner product, but I want a vector of all products between the vectors
12:00:16 <Tekmo> You mean you want element-wise multiplication?
12:00:27 <enthropy> there is a zipWith
12:00:29 <aristid> jpcooper: not a zipWith though?
12:00:43 <jpcooper> zipWith is not the same, no
12:00:56 <jpcooper> I want the product of every pair between the two vectors
12:00:57 <mm_freak> jpcooper: you want the equivalent to 'ap' for lists
12:00:58 <shapr> zipWith is way cooler than zipWithout
12:01:09 <quchen> @call-out-shapr
12:01:09 <lambdabot> Unknown command, try @list
12:01:15 <mm_freak> jpcooper: you can express it in terms of concatMap
12:01:16 <shapr> quchen: haha, what's up?
12:01:25 <jpcooper> good point
12:01:26 <shapr> quchen: how's code?
12:01:31 <enthropy> @get-shapr
12:01:31 <lambdabot> shapr!!
12:01:41 <shapr> you screamt?
12:01:46 <aristid> enthropy: but shapr is already here!
12:01:57 <enthropy> it's not idempotent?
12:01:57 <shapr> hurrah! Yay me!
12:02:00 <Tekmo> jpcooper: Doesn't `(*)` do that?
12:02:01 <shapr> :-P
12:02:08 <quchen> shapr: Annoying! The code is annoying. I have a nonlinear memory leak. I know where it is, but none of its parts can account for it.
12:02:18 <aristid> enthropy: i think it may have dangerous side effects
12:02:29 <quchen> If I keep going at that pace, I'll have to bake a birthday cake for this leak one day.
12:02:31 <shapr> quchen: whoa, that does sound exciting
12:03:01 <quchen> Anyway, I just wanted to call you out for that lame joke above ;-)
12:03:10 <shapr> yeah, it was terrible, but it entertained me!
12:03:19 <quchen> Right, me too. It was a good joke.
12:03:47 <quchen> Like a joke that's not funny but its parts are very funny. Like my memory leak, except not evil.
12:03:55 <jpcooper> Tekmo: I want equivalent of [a * b | a <- L, b <- M]. concatMap will do
12:03:59 <jpcooper> cheers
12:10:07 <mangaba_leitosa> interesting, I found a blog post by Jon Harrop comparing performance of the standard hash table in Haskell, Ocaml and F#, claiming that Haskell is 32 times slower than F# (22 sec. vs 0.706). I tried the haskell code and got 4 sec instead of 22, but roughtly the same numbers for ocaml and F#. The blog post is dated 2010, has GHC improved that much in 3 years? :-))
12:10:12 <mangaba_leitosa> http://flyingfrogblog.blogspot.ru/2009/04/f-vs-ocaml-vs-haskell-hash-table.html
12:13:10 <aristid> mangaba_leitosa: you were using Data.HashTable as well?
12:13:28 <mangaba_leitosa> aristid: yes, just I copy/pasted the exact code
12:13:57 <Saizan> mangaba_leitosa: iirc, mutable arrays caused a lot more work for GC back then, and the benchmark was a pretty pathological case for that
12:13:59 <aristid> mangaba_leitosa: maybe Data.HashTable switched to a better implementation.
12:14:11 <quchen> Harrop is the troll guy right
12:14:13 <quchen> ?
12:14:20 <mangaba_leitosa> quchen: right :-)
12:14:36 <aristid> mangaba_leitosa: you should probably use this instead of Data.HashTable though http://hackage.haskell.org/package/unordered-containers
12:14:49 <Saizan> mangaba_leitosa: at the time if any position of the array was written into, the GC had to scan the whole array, now only a chunk
12:15:05 <ReinH> omg hi
12:15:17 <mangaba_leitosa> aristid: yes, I know
12:16:13 <mangaba_leitosa> Saizan: ah, I see, saw there was some improvement indeed. I wondered if he just invented these numbers :-)
12:17:10 <mangaba_leitosa> Saizan: the conclusion he draw is "Unfortunately, this means that Haskell's defacto-standard compiler is incapable of handling any data structure that maps values onto values efficiently"
12:17:19 <mangaba_leitosa> "he draws"
12:19:06 <aristid> mangaba_leitosa: let's not get overworked over trollish writings from 2009 ;)
12:20:14 <chrisdone> harrop is one of those guys that delights in any X failing, and will never concede one single positive aspect of X
12:20:16 <mangaba_leitosa> aristid: ok :-)
12:20:20 <chrisdone> where X is the thing that doesn't support his business
12:20:24 <chrisdone> (in this case Haskell)
12:21:26 <chrisdone> i had one argument with him in which he rejected that type-classes are a haskell innovation
12:21:51 <dwcook> I think we should just concede that every programming language is terrible and then skip to the part where we start fixing things :P
12:22:07 <zomg> chrisdone: I thought Haskell just stole everything from math!
12:22:15 <mangaba_leitosa> dwcook: :-)
12:22:41 <mangaba_leitosa> emaphis: hi :-)
12:22:43 <dwcook> As SPJ put it, Haskell is useless, after all
12:23:00 <emaphis> mangaba_leitosa: hi. :-)
12:23:20 <quchen> chrisdone: Haskell invented typeclasses?
12:23:23 <dwcook> Hmm, what was that one quote about how Haskell was "only used" for some things?
12:23:33 <emaphis> mangaba_leitosa: how is the bioinformatics class going?
12:23:57 <chrisdone> quchen: they first appeared in haskell
12:24:41 <quchen> chrisdone: I always suspected that, but then I also didn't know about ML and friends until a couple of years ago
12:25:08 <chrisdone> http://en.wikipedia.org/wiki/Type_class
12:25:13 <mangaba_leitosa> emaphis: cool. I have been working 3 days on making my haskell solution work on the week 1 assignment as fast as the effy wrote in python :-)
12:25:25 <quchen> chrisdone: Wikipedia, the trustworthy encyclopedia :P
12:25:30 <mangaba_leitosa> emaphis: s/the effy/effy/
12:25:38 <chrisdone> SML and OCaml has their modules
12:25:47 <chrisdone> quchen: wikipedia fallacy
12:26:35 <lvella> mm_freak, I assumed you wanted some generic function, like myMap :: Monad m => (a -> b) -> m a -> m b
12:26:57 <emaphis> mangaba_leitosa: the effy? is that a person? :-)
12:27:03 <lvella> but now I am starting to believe that to be impossible
12:27:07 <chrisdone> see also http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html
12:27:11 <chrisdone> “How to make ad-hoc polymorphism less ad hoc” 1989
12:27:24 <mangaba_leitosa> emaphis: just "effy". He's on #courseraprogfun, too
12:27:48 <chrisdone> it's actually the best source material to explain type-classes, i think
12:27:49 <lvella> mm_freak, so I made one function for list only: myMap f a = a >>= (\b -> [f b])
12:27:55 <emaphis> mangaba_leitosa: Oh, I haven't noticed him.
12:28:10 <mangaba_leitosa> emaphis: how is reactive going? :-)
12:28:43 <scott_> lvella: Recall that return x = [x] for lists so you can write \b -> return (f b) there
12:28:49 <emaphis> mangaba_leitosa: Ok, but I've been loosing interest.
12:29:23 <dwcook> lvella, are you trying to reimplement fmap/liftM?
12:29:34 <quchen> I think he's rediscovering it.
12:30:38 <mm_freak> lvella is solving my exercise =)
12:30:47 <mangaba_leitosa> emaphis: I ended up with Haskell at 16 secs and effy's Python at 12. Then rewrote it in ocaml, got 13 seconds :-)
12:30:47 <mm_freak> write map/fmap in terms of concatMap/(>>=)
12:30:48 <lvella> oh crap
12:30:50 <mangaba_leitosa> efscher: initially, my haskell version was like 26 seconds
12:30:56 <dwcook> Oh, neat.
12:31:00 <lvella> I should had look at :i Monad from start
12:31:09 <lvella> using return I get the general case
12:31:17 <mm_freak> lvella: that's fine, your solution is correct
12:31:24 <mangaba_leitosa> emaphis: initially, my haskell version was like 26 seconds
12:31:26 <mangaba_leitosa> wrong nick :-)
12:31:44 <mm_freak> :t \f xs -> xs >>= return . f
12:31:45 <lambdabot> Monad m => (a -> b) -> m a -> m b
12:31:58 <mm_freak> lvella: btw, that exact function is predefined:  liftM =)
12:32:14 <mm_freak> despite the name it is unrelated to liftIO/lift
12:32:20 <FreeFull> Now write ap/(<*>) in terms of concatMap/(>>=)
12:32:32 <emaphis> mangaba_leitosa: hmm. I'm suprised the Python solution was so fast. :'P
12:32:55 <mangaba_leitosa> emaphis: it was with the pypy JIT compiler
12:32:56 <mm_freak> lvella: before doing FreeFull's exercise do the Reader exercise
12:32:58 <quchen> The python version is probably more of a C version.
12:33:15 <mm_freak> newtype Reader e a = Reader (e -> a)
12:33:17 <mangaba_leitosa> emaphis: and basically the key feature affecting performance are dictionaries for counting word frequencies
12:33:27 <mm_freak> lvella: first implement a Functor instance, then a Monad instance for this type
12:34:01 <pavonia> Is there a better way of prematurely exiting an IO action than using fail and catch?
12:34:11 <mm_freak> pavonia: not recursing
12:34:27 <pavonia> I'm not recursing
12:34:45 <emaphis> mangaba_leitosa: I wonder how fast a Scala solution would be?
12:34:52 <mm_freak> pavonia: you can use a monad transformer that adds 'abort' like ContT
12:34:59 <mm_freak> pavonia: another option is to use MaybeT/EitherT
12:35:11 <mangaba_leitosa> emaphis: I do't know, it would be interesting to learn :-)
12:35:15 <augur> the interactions between (co)variants and applicatives/monads is interesting
12:35:20 <mangaba_leitosa> emaphis: join the course and write your solution :-)
12:35:24 <quchen> Or pipes. Pipes are like infinite loops that can return.
12:35:26 <chrisdone> you can't teach very well in #haskell, people are too enthusiastic about telling newbies things and spoiling the teaching method ;)
12:35:40 <dwcook> Sorry :(
12:35:57 <chrisdone> dwcook: don't be :)
12:36:02 <emaphis> mangaba_leitosa: ohhh. I'd be waaay behind.
12:36:08 <augur> like, you can always get from   f (a -> b) to a -> f b, but not vice versa, and you can always get from bind to app but not vice versa
12:36:17 <mangaba_leitosa> emaphis: but the week 1 due date is Nov 21 :-)
12:36:30 <pavonia> mm_freak: EitherT looks good at a glance, I'll try this. Thanks!
12:36:33 <chrisdone> it's actually impossible to employ the socratic method in here. ask a newbie a question and it *will* be answered by someone else
12:36:35 <quchen> chrisdone: It's a primal urge to loudly solve easy programming riddles you had serious problems with a couple of months ago.
12:36:35 <mangaba_leitosa> emaphis: or maybe not....
12:36:39 <mangaba_leitosa> emaphis: will check now
12:36:42 <augur> precisely because the former is in a contravariant position
12:37:17 <mangaba_leitosa> emaphis: ah, no, it was Nov 14. too late :-)
12:37:40 <mangaba_leitosa> emaphis: 21 is hard deadline with -50%  :-)
12:38:01 <emaphis> mangaba_leitosa: I wouldn't worry about the grade, but I'd be behind the class :(
12:38:32 <chrisdone> quchen: =)
12:38:52 <mangaba_leitosa> emaphis: actually, there was not too much to learn in week1. It was just initial testing of coding skills :-)
12:39:01 <quchen> chrisdone: I think I'm done with the loeb thing. I slept, I peed, I showered. No new ideas. This means there are none.
12:39:34 <emaphis> mangaba_leitosa: oh, damn, then I'd need coding skills. :-)
12:39:52 <mangaba_leitosa> emaphis: what's wrong with them? :-)
12:40:05 <quchen> chrisdone: I tried doing fibonacci with loeb, mutably updating the list in the process until the spreadsheet converges, but couldn't do it :-(
12:40:17 <chrisdone> quchen: yeah, i once tried to do a sudoku solver
12:40:30 <chrisdone> i'm still not sure that it's impossible
12:41:27 <emaphis> mangaba_leitosa: oh nothing.  What are you using for a haskell development set up?  I'm using emacs/haskell mode.
12:41:42 <mangaba_leitosa> emaphis: I use vim for everything
12:42:01 <emaphis> mangaba_leitosa: I'm now trying the  set up eclipse.
12:42:21 <mangaba_leitosa> emaphis: for haskell? :-)
12:42:42 <emaphis> mangaba_leitosa: yes, eclipse has a Haskell set up.
12:43:02 <mangaba_leitosa> emaphis: seriously? Never heard about it
12:43:04 <chrisdone> quchen: can you think of a way to solve sudokus with loeb?
12:43:11 <khyperia> eclipsefp is a great plugin, I use it quite a bit.
12:43:33 <quchen> chrisdone: I can't wrap my head around mutability with loeb yet. For a sudoku solver you would have to successively eliminate candidates.
12:43:40 <emaphis> mangaba_leitosa: http://eclipsefp.github.io/
12:43:45 <mangaba_leitosa> emaphis: thanks
12:44:03 <quchen> chrisdone: But even then solving the puzzle is still hard because elimination does not always solve the thing.
12:44:05 <chrisdone> quchen: yeah i think last time i tried to do it i thought it required backtracking that loeb can't do
12:44:11 <emaphis> mangaba_leitosa: It's nice, but emacs is much faster. ;-)
12:44:18 <chrisdone> quchen: yeah
12:44:25 <quchen> chrisdone: Right, it's probably a better fit for the list monad
12:44:34 <quchen> Which isn't half as mindblowing as loeb :-)
12:44:47 <mangaba_leitosa> emaphis: right, I think using eclipse would be making haskell as slow as scala :-)
12:46:03 <mangaba_leitosa> khyperia: isn't eclipse too slow? :-)
12:46:04 <emaphis> mangaba_leitosa: I don't know, Haskell's compiler doesn't seem to be too much faster.
12:46:19 <khyperia> What do you mean?
12:46:53 <mangaba_leitosa> emaphis: it usually takes me < 1 second to get to REPL or recompile a file there... With sbt, it was more like 10 seconds to enter console when compilation was needed :-)
12:47:25 <khyperia> Most of the waiting time for edit-time errors is around 3/4ths to 1.5 seconds, and that time is actually compiletime - which spits out an exe that you can run immediately.
12:47:52 <mangaba_leitosa> khyperia: startup time, for example :-)
12:48:16 <khyperia> Oh, startup time, obviously yeah. I only start eclipse once per coding session, though, so it's not that important.
12:48:43 <khyperia> If you're using eclipse with constantly opening/closing the program, you're doing something wrong.
12:49:26 <chrisdone> i haven't restarted my emacs for weeks
12:49:47 <emaphis> how do you rebuild eclipses data base, my build failed last night because hkage was down?
12:50:03 <mangaba_leitosa> khyperia: I have 2 GB of RAM and when I was using trying eclipse and also had firefox and sbt (for scala) opened and acidentally started one more scala REPL, it usually died on OOM :-)
12:50:24 <khyperia> ah
12:50:31 <khyperia> yeah, 2GB ram is a little small
12:50:50 <mangaba_leitosa> khyperia: nobody will ever need more than 640 KB :-)
12:51:01 <khyperia> heh
12:51:02 <intrados> What's the easiest/lightest way to spawn multiple network request threads? Is Control.Concurrent.Future a good option?
12:51:03 <maik_> is it possible to auto generate a C interface in haskell?
12:51:25 <emaphis> 640 KB, a luxury.
12:51:54 <Hodapp> I'm working on an MSP430 now with 512 bytes of SRAM.
12:52:37 <khyperia> I kind of want to get into something other than eclipse, though, to open up options. Does anything have a massive amount of edit-time help, like type errors, integrated hlint, autocomplete, things like that?
12:53:01 <chrisdone> emaphis: back in my day you were lucky to have the price of a 640 KB, without milk or sugar
12:53:21 <emaphis> khyperia: emacs/haskell mode/ghc mode.
12:53:21 <intrados> khyperia: Emacs with ghc-mod has all of that
12:53:24 <scott_> khyperia: I've got the first two working in vim easily. I haven't played with autocomplete yet
12:53:29 * mangaba_leitosa has a second note with 2 DIMMS 1.5 GB each. Tried to move 1 DIMM to my working laptop yesterday and the DIMM size factor happened to be different :-(
12:53:33 <mangaba_leitosa> it just doesn't fit :-)
12:53:51 <khyperia> Can someone walk me through setting up emacs to do so?
12:53:51 <donri> khyperia: both emacs and vim with appropriate addons, maybe sublime too
12:53:52 <chrisdone> khyperia: https://www.fpcomplete.com
12:54:01 <maik_> found it "c2hs"
12:54:07 <emaphis> mangaba_leitosa: laptop memory usualy is different.
12:54:24 <khyperia> I tried fpcomplete, was annoyed by the lack of packages I wanted to use, like llvm-general
12:54:36 <donri> you can get fpcomplete to install from hackage
12:54:38 <emaphis> khyperia: haskell.org has a page on setting up emacs.
12:54:47 <mangaba_leitosa> emaphis: yes, but I was trying to move from one laptop to another. Sony vs. Lenovo :-)
12:54:55 <khyperia> thanks, emaphis, I'll read that
12:54:57 <mangaba_leitosa> emaphis: but Sony is always special, I know :-0
12:55:01 <khyperia> donri, I didn't know that, how?
12:55:10 <chrisdone> khyperia: in the project settings
12:55:54 <emaphis> khyperia: http://www.haskell.org/haskellwiki/Emacs
12:55:57 <mangaba_leitosa> donri: fpcomplete as a standalone IDE? Wasn't it web-browser only?
12:56:29 <emaphis> yeah, I thought fpcomplete was cloud only.
12:57:09 <chrisdone> it is on the cloud, yeah
12:57:22 <NemesisD> hey guys. looking for some help with quasi quoting. trying to create a quasi quoter that can turn Foo Int Bool into [q|data Foo = Foo Int Bool|]
12:57:26 <chrisdone> i'm currently implementing an emacs interface to  it
12:59:19 <NemesisD> is there a way to lookup a type from a string in qq?
13:00:05 <chrisdone> NemesisD: probably parse the string, then reify the resulting Name
13:07:16 <enthropy> chrisdone, NemesisD qq runs before typechecking so I think you'll only get a type from reify if the identifier is imported from somewhere else
13:08:51 <linduxed> hey guys, i want to do something like "all (isUpper || isDigit) "ARST123"" but i'm not sure how i should do it
13:09:07 <linduxed> how would i quickly combine those two?
13:09:10 <chrisdone> :t liftA2 (||) isUpper isDigit
13:09:11 <lambdabot> Char -> Bool
13:09:31 <chrisdone> :t (||) <$> isUpper <*> isDigit
13:09:32 <lambdabot> Char -> Bool
13:09:47 <enthropy>  (\x -> isUpper x || isDigit x) -- might be more obvious
13:10:34 <NemesisD> sometimes i define (<||>) = liftA2 (||)
13:10:39 <linduxed> hmmm
13:10:43 <linduxed> i've never used lifts
13:10:44 <chrisdone> personally i'd just write the lambda
13:10:50 <linduxed> those look interesting
13:11:03 <linduxed> erm... the applicative solution i like however
13:11:06 <linduxed> really like it actually
13:12:01 <chrisdone> :t \x -> any ($ x) [isUpper,isDigit]
13:12:02 <lambdabot> Char -> Bool
13:12:07 <chrisdone> @pl \x -> any ($ x) [isUpper,isDigit]
13:12:07 <lambdabot> flip any [isUpper, isDigit] . flip id
13:12:57 <linduxed> ok that's taking it too far though
13:13:06 <linduxed> i can make no sense out of that
13:13:15 <chrisdone> even the first one?
13:13:40 <chrisdone> > map ($ 10) [(*2),(+3)]
13:13:41 <lambdabot>   [20,13]
13:14:06 <chrisdone> > any ($ 3) [(==2),(==3)]
13:14:07 <lambdabot>   True
13:14:19 <chrisdone> oh, also
13:14:33 <chrisdone> :t or . map [isUpper,isAny]
13:14:34 <lambdabot> Not in scope: `isAny'
13:14:42 <chrisdone> :t or . flip map [isUpper,isDigit]
13:14:43 <lambdabot> ((Char -> Bool) -> Bool) -> Bool
13:14:46 <chrisdone> uhh
13:14:53 <chrisdone> nah, that's not good
13:14:56 <NemesisD> gah you can't run reify in IO
13:16:27 <chrisdone> sometimes, you know, deriving lashes out at me, and i just Functor,Applicative! and oh, baby! ghc's okay!
13:19:18 <chrisdone> donri: in emacs you hit q to insert the next key literally. i use that in god-mode so i can insert a key without having to switch to “insert-mode” back into god-mode =)
13:21:08 <chrisdone> (well, C-q. but in god-mode it's just q.)
13:21:20 * hackagebot pbkdf 1.1.1.0 - Haskell implementation of the PBKDF functions from RFC-2898.  http://hackage.haskell.org/package/pbkdf-1.1.1.0 (ChrisDornan)
13:21:23 <Philonous> god mode?
13:21:28 <chrisdone> https://github.com/chrisdone/god-mode/
13:21:37 <Philonous> Thanks
13:21:42 <Philonous> Is there also no-clip mode?
13:21:56 <chrisdone> what's no-clip?
13:22:17 <ion> idkfa
13:22:25 <chrisdone> what?
13:22:32 <ion> idspispopd
13:22:48 <hpc> chrisdone: clipping is when a thing bumps up against a limit
13:23:00 <hpc> chrisdone: in the case of photography, that's overexposure
13:23:02 * chrisdone wonders whether he just entered an alternate universe
13:23:12 <hpc> in electronics, it makes a square wave
13:23:12 <Philonous> chrisdone, It was a joke, because I though you took "god mode" from first person shooters like doom
13:23:27 <hpc> no-clip in games makes your dude not bump up against walls and floor
13:23:36 <chrisdone> oh ok
13:23:38 <Philonous> chrisdone, iddqd and idkfa are the keys you have to press to enable those cheats in id games (like doom)
13:23:39 <hpc> etymology yay!
13:24:26 <chrisdone> http://i.imgur.com/o7x1oEZ.gif
13:25:10 <hpc> chrisdone: a lifetime compilation of jack nicholson's great moments in acting
13:25:24 <scott_> Is there a way to hide the Monad [] instance so I can redefine it?
13:25:29 <chrisdone> hpc: =)
13:25:39 <hpc> scott_: nope, you're screwed
13:25:44 <scott_> Alright, thanks =)
13:25:46 <chrisdone> don't import Prelude
13:25:46 <hpc> scott_: you can newtype it htough
13:25:57 <scott_> I'll do that
13:26:14 <intrados> Does anyone know of examples of forkPromises from Control.Concurrency.Future?
13:26:19 <chrisdone> if you're on ghc 7.dooby you can use OverloadedLists
13:26:45 <Philonous> scott_, I'm interested, what does your monad instance look like?
13:26:54 <scott_> chrisdone: Thanks for the tip
13:27:06 <scott_> Philonous: Oh, I was just going to try redefining the standard [] one
13:27:17 <Philonous> Oh, ok.
13:27:32 <scott_> Are there any interesting ones besides that and ZipList?
13:27:34 <Philonous> Because I was about to say that it's unique.
13:27:43 <Philonous> ZipList is only applicative
13:27:47 <scott_> Oh, my bad
13:29:05 <donri> mangaba_leitosa, emaphis: i meant you can get it to install packages from hackage, not that you can install it from hackage
13:29:14 <NemesisD> anyone know anything about quasi quoting? i have no idea how i can test Q [Dec], i have a file that uses one i wrote seemingly without error but the type doesn't get declared
13:29:52 <chrisdone> printQ :: (Ppr a) => Q a -> IO ()
13:29:53 <chrisdone> printQ f = do
13:29:53 <chrisdone>   s <- runQ f
13:29:53 <chrisdone>   putStrLn $ pprint s
13:30:15 <chrisdone> use it wisely
13:31:18 <donri> there's -ddump-splices
13:33:21 <NemesisD> thanks! turns out my parser was failing!
13:34:51 <aranea> Hi. I'm writing an interpreter for a simple programming language. I'm using several custom monad classes (currently Tape and PrgmIO, later on I'll perhaps add a third), each having multiple instances. Now I have a function which needs a monad which is an instance of both of these classes. So, I need some kind of custom monad transformers. How would you do that?
13:35:16 <quchen> chrisdone: Could you give me your address so I can send you flowers for http://www.reddit.com/r/haskell/comments/1qtr88/criticism_of_haskell_xpost_from_rprogramming/cdgdt3p
13:35:17 <quchen> ?
13:35:30 <ryantrinkle1> is there any literature on how to deal with "diffing" datastructures? what's the algebraic concept?
13:35:46 <ryantrinkle1> e.g., Diff (a, b) is clearly equal to (Diff a, Diff b)
13:35:55 <ryantrinkle1> but Diff (Either a b) isn't quite so clear to me
13:37:38 <Cale> Diff (Either a b) = Maybe (Either (Diff a) (Diff b))?
13:37:43 <jfeltz> do transformer stacks ever become easy and intuitive? I gave up trying to map over a transformer type, and resorted to runReaderT etc to convert to a similar transformer, I'm also getting to the point where I don't understand something like this: result <- liftIO $ runReaderT (runEitherT app) full_app_url, for a type of: EitherT (Context, String) (ReaderT a IO) r
13:38:08 <chrisdone> quchen: haha
13:38:44 <Cale> jfeltz: The important thing is not to think of things as "transformer stacks", and instead look at exactly which monads are involved.
13:38:45 <ryantrinkle> Cale: does that cover the case where you switch constructors?
13:39:02 <Cale> ryantrinkle: Well, that's what the Maybe is for, I guess.
13:39:19 <Cale> ryantrinkle: But I don't really know what we're representing ;)
13:39:20 <ryantrinkle> i guess Diff a should have the same cardinality as the set of invertible functions from a to a ?
13:39:33 <ryantrinkle> well, i'm looking for a "no-junk, no-noise" style diff
13:39:36 <chrisdone> aranea: what do they monads do?
13:39:52 <ryantrinkle> i.e.: it should be the minimum possible data necessary to tell you how to go in both directions
13:40:03 <ryantrinkle> i guess it's heavily partial, too
13:40:10 <ryantrinkle> so, not just invertible functions
13:40:33 <ryantrinkle> Diff (Either () ()) ~= Bool
13:40:37 <ryantrinkle> you either flip the either or you don't
13:40:56 <chrisdone> has anyone ever done a diff :: Exp -> Exp -> Diff Exp for hse?
13:42:22 <chrisdone> maybe it would be better if HSE's AST types were fixpointed
13:42:27 <monoidal>  there's the antidiagonal (http://blog.sigfpe.com/2007/09/type-of-distinct-pairs.html) if that's the question
13:42:38 <chrisdone> data Exp r = Lit Literal | App r r
13:42:43 <enthropy> chrisdone: I think there's some "generic programming" diff algorithm that can probably apply to Exp
13:43:30 <linduxed> ok so "shouting = all $ (||) <$> isUpper <*> isSpace" works, but if i add " <*> isPunctuation" it breaks
13:43:30 <aranea> chrisdone: PrgmIO is a restricted version of IO only allowing reading/writing stdio, and also the different instances do some pre- & postprocessing. The Tape monads store the program state (there's currently only one instance, based on lists in a State monad, but I plan to experiment with other options)
13:43:32 <enthropy> dunno if this actually works http://hackage.haskell.org/package/gdiff
13:43:38 <chrisdone> enthropy: sure, i could write a diff over HSE's AST with Data.Data. but the output type would be interestin
13:43:53 <linduxed> i picture it as it being possible to put the || in between once, but not on all the consecutive times
13:44:05 <linduxed> any way to string these together multiple times?
13:44:10 <chrisdone> huh
13:44:13 <linduxed> so i can use <*> any amount of times?
13:45:01 <monochrom> I don't know how to answer that literally. you can write any correct program. I'll leave it at that.
13:45:33 <chrisdone> aranea: they're presumably implemented in terms of newtype wrappers over ReaderT/StateT and IO?
13:45:39 <aranea> yup
13:45:53 <Cale> ryantrinkle: You might end up needing something like Iso
13:46:10 <ryantrinkle> Cale: i think so
13:46:10 <monochrom> people look so hard for rules of thumb where there is none
13:46:15 <ryantrinkle> this type is kind of like
13:46:29 <ryantrinkle> the type of isomorphisms, where you're only allowed to care about one input/output pair
13:47:10 <scott_> linduxed: Something like this works: all (\x -> any ($ x) [isUpper, isSpace, isPunctuation])
13:48:05 <linduxed> scott_: that is so mindbending...
13:48:17 <linduxed> have to process it
13:49:01 <scott_> linduxed: Read ($ x) as "applied to x", we're asking if any of the functions in the list applied to x are True
13:49:08 <monochrom> do not think. calculate.
13:49:25 <aranea> chrisdone: saw my answer?
13:49:57 <monochrom> any ($ x) [p1, p2, p3] = or [p1 $ x, p2 $ x, p3 $ x] = p1 x || p2 x || p3 x
13:50:25 <monochrom> see also http://www.vex.net/~trebla/haskell/prerequisite.xhtml
13:50:25 <scott_> This is the same thing: all (\x -> or [isUpper x, isSpace x, isPunctuation x])
13:51:15 <chrisdone> oh, so it wasn't just me then
13:51:40 <FireFly> @src and
13:51:51 <chrisdone> i guess a node just went down
13:51:51 <FireFly> :(
13:52:13 <monochrom> and [] = True; and (b:bs) = b && and bs
13:52:24 <scott_> Or and   =  foldr (&&) True
13:52:27 <aranea> chrisdone: yup, they're newtype wrappers
13:52:31 <FireFly> I was wondering if it'd suggest  and = all id
13:52:53 <monochrom> oh, heh
13:53:05 <hpc> FireFly: and = unsafeCoerce . catMaybes . unsafeCoerce
13:53:12 <monochrom> haha
13:53:18 <chrisdone> maybe all f = and . map f
13:53:25 <chrisdone> aranea: so why do you need a transformer?
13:53:58 <chrisdone> ibid: you have the eyes of the Ibid?
13:54:22 <aranea> I need a monad that is both a PrgmIO and a Tape. This just made me think of transformers...
13:54:27 <monochrom> if I take my laptop power block and write "monad" on it, is it a monad transformer? :)
13:55:02 <chrisdone> aranea: why not just make a type that implements MonadPrgm and MonadTape? :3
13:55:31 <chrisdone> monochrom: herp herp =p
13:55:56 <aranea> the implementations are a bit more than just newtypes, I'd prefer to keep them separate
13:57:59 <linduxed> scott_: ok i feel i understand it now
13:58:05 <linduxed> but is there no way to do it with applicative?
13:58:35 <scott_> Well, (||) only takes two arguments, so there's no way you can or 3 things with it without using it twice
13:59:50 <scott_> If you had or3 :: Bool -> Bool -> Bool -> Bool you could write liftA3 or3 $ isUpper <*> isSpace <*> isPunctuation
14:00:22 <linduxed> ah ok
14:00:26 <linduxed> that makes sense
14:00:45 <scott_> I screwed up the syntax there... no <*>s
14:16:16 <Aetherspawn> where is llc/opt on OSX?
14:16:29 <Aetherspawn> ghc complains it cannot find them, and i can't see them on path either
14:16:38 <Aetherspawn> but I know for sure I have them somewhere with Xcode 5 ...
14:21:45 <stelleg> is there an hPutWord function analagous to hPutChar?
14:23:03 <Ralith> Aetherspawn: why do you know that for sure?
14:23:04 <stelleg> ah looks like you can do it "with" fom storable
14:24:51 <Aetherspawn> Ralith: because clang uses it
14:25:06 <Aetherspawn> meh, I just decided to brew install llvm to get one on path
14:25:12 <Aetherspawn> probably more robust anyway
14:25:17 <Ralith> Aetherspawn: clang doesn't use those tools, no.
14:25:27 <Aetherspawn> oh :/
14:25:48 <donri> stelleg: try also binary/cereal
14:29:21 <jrmithdobbs> Aetherspawn: Make sure you have cli tools installed inside xcode.
14:30:14 <prooftechnique> Also, how are you getting ghc to work with clang, anyway?
14:30:25 <prooftechnique> Are you using the wrapper?
14:30:35 <aranea> chrisdone: so, how would you do this?
14:31:26 <Aetherspawn> prooftechnique: I used the tap for homebrew-haskell by danmorrison
14:31:56 <prooftechnique> I didn't know that played nice with clang. Interesting
14:32:17 <Aetherspawn> I think it pulls in gcc42 and configures it for that instead, not sure
14:34:34 <wolftune> hi, I have a beginners question: in function that takes multiple arguments, why the heck does the type sig use -> to list the arguments? It seems obvious that the arguments are a different concept than the result the function gives. Why is it -> for the symbol for multiple arguments as well as between arguments and evaluation results??
14:35:13 <hpc> wolftune: haskell functions are from one parameter to one result
14:35:13 <Aetherspawn> wolftune: lets explore that
14:35:21 <donri> wolftune: there are no multi-argument functions
14:35:27 <Aetherspawn> imagine that all functions take 1 argument and return something else
14:35:33 <Aetherspawn> what does f :: Int -> Int -> Int return?
14:35:48 <Aetherspawn> (Let's make it easier -- f :: Int -> (Int -> Int)
14:35:49 <hpc> wolftune: to write a multi-argument function, you write a function of one parameter that returns a function of one parameter that ...
14:35:59 <hpc> wolftune: this is called currying
14:36:33 <wolftune> hmm, gimme a sec to parse and read your answers
14:36:37 <FreeFull> > let add x y = x + y in (add 3) 4
14:36:46 <Cale> wolftune: When you write  f x y z  what it means is  ((f x) y) z
14:36:51 <FreeFull> Oh, lambdabot is gone
14:36:55 <ReinH> :(
14:36:58 <ReinH> lambdabot nooooo
14:37:09 <Cale> wolftune: and similarly  f :: X -> Y -> Z -> W  means  f :: X -> (Y -> (Z -> W))
14:37:41 <hpc> :t curry
14:38:14 <ReinH> let's maybe let wolftune catch up :)
14:38:22 <prooftechnique> curry :: ((a, b) -> c) -> a -> b -> c
14:39:47 <Aetherspawn> blah, fail
14:40:00 <Aetherspawn> "You are using a new version of LLVM that hasn't been tested yet!" using llvm 3.3
14:40:11 <Aetherspawn> build spews out pages of llvm dump gibberish :(
14:40:39 <testingok> hey guys im writing a simple application to exercise my skills. it works, but it looks terrible. wondering if i could get some critiquing http://lpaste.net/95824
14:40:44 <wolftune> so I've seen these explanations. I think there's a way to spread it out further… is this right?  { f :: x -> y -> z } is really like f :: x -> z with f' :: x -> y in the middle ?
14:41:00 <hpc> no
14:41:03 <linduxed> is there an opposite of the "any" function?
14:41:17 <hpc> f :: x -> (y -> z)
14:41:18 <sipa> not . any
14:41:31 <QuartheX> lol @ sipa
14:41:32 <prooftechnique> testingok: That page has a number of style suggestions, to begin with
14:41:37 <wolftune> hpc: so there is a f' :: y -> z, right?
14:41:37 <linduxed> well i guess that works :-P
14:41:46 <NemesisD> isn't there a trick to build a heterogenous list full of types all belonging to the same typeclass, such as show?
14:42:05 <sipa> :t any
14:42:16 <prooftechnique> any :: (a -> Bool) -> [a] -> Bool
14:42:28 <Cale> :t all
14:42:30 <hpc> wolftune: there's many f' - (f' = f x) for whatever x is given
14:42:37 <prooftechnique> all :: (a -> Bool) -> [a] -> Bool
14:42:39 <Cale> tee hee
14:42:52 <Cale> prooftechnique is honorary lambdabot for now
14:42:57 <sipa> @pl \f l -> not (any f l)
14:42:58 <prooftechnique> oh, no
14:43:07 <NemesisD> none f = all (not . f)?
14:43:08 <hpc> not .: any
14:43:10 <scott_> (not .) . any
14:43:17 <prooftechnique> (not .) . any
14:43:18 <NemesisD> oh or that
14:43:52 <Aetherspawn> testingok: lpaste (hlint) has a lot of suggestions for you :)
14:44:41 <testingok> prooftechnique, Aetherspawn, thanks ill begin with cleaning those up
14:45:15 <testingok> though really, im more concerned with the implementation
14:45:46 <testingok> StateT seemed like a good idea at the time...
14:46:22 <wolftune> ok, wait so… f x y z = ((f x) y) z, so that's *really* um, so like, I'm get the parsing, but how can f(x) give y? y is just some argument, not something that a function using x gives… that's where I'm confused…
14:46:56 <hpc> wolftune: y is a parameter to the function (f x)
14:47:07 <hpc> functions returning functions
14:47:18 <Cale> wolftune: f is a function, you apply it to x, and get another function, which you apply to y, and that gives you another function, which you apply to z
14:47:19 <hpc> wolftune: to put it in more C-like syntax
14:47:27 <hpc> instead of f(x, y, z), it's f(x)(y)(z)
14:48:08 <wolftune> ok so… f(x) in this gives f' yes?
14:48:14 <hpc> yes
14:48:19 <wolftune> and f'(y) gives f''
14:48:19 <prooftechnique> f x y z = ((f x) y) z => f = fix id
14:48:24 <hpc> also yes
14:48:36 <Cale> prooftechnique: ?
14:48:39 <QuartheX> wolftune: -> http://learnyouahaskell.com/higher-order-functions#curried-functions
14:48:47 <QuartheX> Nice tutorial, I think
14:48:58 <Cale> prooftechnique: f x y z is syntactically equal to ((f x) y) z
14:49:03 <hpc> wolftune: you pretty much have it now
14:49:10 <prooftechnique> I know :D
14:49:16 <Cale> prooftechnique: So the only things it implies are tautologies
14:49:18 <wolftune> is there a type sig that means *function* ?
14:49:27 <prooftechnique> Cale: Exactly :D
14:49:30 <hpc> (a -> b) is the type of "function from a to b"
14:49:35 <Cale> But f = fix id is not in general true
14:49:42 <wolftune> hpc: ok
14:49:58 <prooftechnique> Fair enough
14:49:58 <hpc> and it associates right
14:50:05 <hpc> a -> b -> c == a -> (b -> c)
14:50:21 <hpc> we leave off the parens because this isn't lisp, we got work to do
14:50:24 <sipa> also, (->) a b
14:51:02 <testingok> ok, cleaned up as per hlint
14:51:20 <wolftune> so in f x y z, the type is f :: a -> (a -> b) -> (a -> b) -> a ??
14:51:28 * hackagebot Hach 0.1.2 - Simple chat  http://hackage.haskell.org/package/Hach-0.1.2 (DmitryMalikov)
14:51:52 <Cale> wolftune: If f :: X -> Y -> Z -> W, x :: X, y :: Y, z :: Z, and f x y z :: W
14:52:49 <Cale> Suppose that f :: X -> Y -> Z -> W
14:52:59 <Cale> and that x :: X, y :: Y, and z :: Z
14:53:05 <Cale> then f x :: Y -> Z -> W
14:53:09 <Cale> and f x y :: Z -> W
14:53:13 <Cale> and f x y z :: W
14:53:20 <NemesisD> man quasi quoting is hard. i just want to generate a string of the source and have ghc figure out the ast
14:53:22 <hpc> as an aside, i love that we are ordering it "xyzw"
14:53:29 <QuartheX> wolftune: given a function that “take” n argument, you just remove as many type in the signature of that function as you give argument.
14:53:45 <Cale> hpc: You mean that's not the order that they come in? ;)
14:53:47 <prooftechnique> hpc: W stands for "wesult"
14:53:49 <wolftune> so in natural language, if a function takes two arguments, then really the function takes one argument that gives a new function which itself takes the other argument and then evaluates to some result, right?
14:53:57 <Cale> wolftune: right
14:54:03 <QuartheX> \o/
14:54:11 <hpc> pwooftechnique: damn straight!
14:54:18 <razieliyo> now I get why haskell is called PURE FUNCTIONAL
14:54:48 <Cale> A&W stands for 'amburgows and wootbeew
14:55:13 <ion> wolftune: Pragmatically, everything being (a,b) -> c directly lets you either apply f to an (a,b) or pass f to something that applies it to an (a,b) but doesn’t let you pass (f a) to something that will apply it to b. Say, map ((+) 100) [0..5]
14:55:21 <mauke> did someone say schönfinkeling?
14:55:46 <c_wraith> no, this is a serious channel.
14:56:20 <hpc> we save the good jokes for -blah
14:56:21 <Cale> ghci> map (map (*10)) [[1,2,3],[4,5],[6,7,8]]
14:56:22 <Cale> [[10,20,30],[40,50],[60,70,80]]
14:56:31 <Cale> ^^ this sort of thing is why currying is really nice
14:56:33 <wolftune> so the only confusing thing, I think, in translating my natural language to type sig is that the a -> a -> a signature style seems like it has the right number of arguments but is leaving out the values of the intermediate functions. Or at least the intermediate 'a' parts are themselves a complete function *with* an argument, which is really two values. Yes??
14:56:41 <danilo2> Hello! Do you know where can I read about the -B command line option in GHC? This option is used on Unix platforms in "ghc" wrapper (if you run "ghc" it is a bash script, which runs ghc binary with this option).
14:56:46 <Cale> a -> a -> a means a -> (a -> a)
14:56:53 <Cale> because -> by convention associates to the right
14:57:20 <pavonia> Is there a convenient way of modifying the contents of a text file, i.e. reading from that file, modfy some lines and write it back to the same file?
14:57:26 <Cale> wolftune: does that help you?
14:57:29 <derdon> by convention? not by definition, Cale?
14:57:32 <testingok> what is the recommended approach for separating out user input/output from logic? (http://lpaste.net/95824)
14:57:34 <hpc> danilo2: -B isn't in the manpage
14:57:36 <Cale> derdon: both
14:57:42 <derdon> ok
14:57:48 <Cale> derdon: The definition is a specification of the convention that we chose
14:57:53 <derdon> I see
14:57:56 <hpc> danilo2: haskell.org has a fairly long manual
14:57:56 <danilo2> hpc: Oh - maybe this is the reason I could not find it :D so what is it?
14:58:00 <c_wraith> pavonia: Not really.  The most convenient unless the file is huge is just to read it in, modify it, then write it out.
14:58:19 <hpc> http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html -- somewhere in here, maybe
14:58:21 <danilo2> hpc: ahh I was thinking you're talking about the online manual - I was srearching there, but no luck so far
14:58:31 <hpc> hmm
14:58:32 <mm_freak> pavonia: streaming abstractions are convenient enough, but if all else fails you can use the good old unfortunate lazy I/O
14:58:47 <pavonia> c_wraith: But wouldn't laziness cause problems here?
14:58:49 <mm_freak> pavonia: in either case writing right to the same file is wrong
14:58:51 <hpc> try asking #ghc too; if nothing else it's a problem with the documentation
14:59:21 <mm_freak> pavonia: you should write to a new file, unless the application inherently needs to modify an existing file
14:59:26 <danilo2> hpc: I was looking here: http://www.haskell.org/ghc/docs/6.10.4/html/users_guide/using-ghc.html
14:59:33 <danilo2> hpc: Ok, I will :)
14:59:37 <danilo2> hpc: thank you :)
14:59:40 <hpc> that's a spectacularly old manual
15:00:11 <danilo2> hpc: ohh, I'm sorry, wrong link
15:00:15 <prooftechnique> testingok: I think you have it pretty much right. Your input and output stuff is separated pleasantly.
15:00:28 <prooftechnique> Does something not sit well with you?
15:00:29 <danilo2> hpc: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/using-ghc.html
15:00:43 <hpc> danilo2: better ;)
15:00:46 <Cale> *shakes fist at google for prioritising old documentation over new*
15:00:50 <testingok> prooftechnique: i feel like im doing too much in the io monad
15:01:11 <danilo2> hpc: there should be a list of all flags in one place imo :(
15:01:14 <pavonia> mm_freak: The problem is the file may be big, so I'd like to avoid having it twice on disk
15:01:20 <hpc> danilo2: i wish there was
15:01:28 * hackagebot stm-lifted 0.1.0.0 - Software Transactional Memory lifted to MonadIO  http://hackage.haskell.org/package/stm-lifted-0.1.0.0 (MaksymilianOwsianny)
15:01:29 <hpc> the best i know of is my ghc-man-completion package
15:01:33 <hpc> which... also doesn't have -B
15:01:34 <testingok> prooftechnique: and the StateT transformer feels a bit kludgy
15:02:00 <mm_freak> pavonia: is the modified portion rather small compared to the whole file?
15:02:46 <pavonia> mm_freak: not really, the worst case is modifying every single line
15:03:22 <mm_freak> pavonia: you can't do it on a line-by-line basis easily
15:03:33 <mm_freak> unless you make sure that line lengths are never increased
15:03:59 <pavonia> Aww, you're right
15:04:10 <wolftune> Cale: thanks for the help. It's still hard, but I'm getting there.
15:04:32 <mm_freak> pavonia: this is really a dangerous way to do it
15:04:34 <prooftechnique> testingok: I don't particularly see anything in IO that shouldn't be there. Getting the time, taking user input, writing to the screen. I suppose you could make instructions just a list and then mapM_ print over the list to print them rather than having a list of putStrLns
15:04:44 <mm_freak> pavonia: i recommend the separate file regardless
15:05:25 <prooftechnique> That won't really do anything, but I guess it slightly lowers the amount of IO you're carrying around in the types
15:05:36 <Cale> wolftune: Eventually you'll come to regard something of type X -> Y -> Z -> W as just a function with three parameters, and just know that you can take advantage of the fact that you can apply it to fewer to obtain a function of the remaining arguments.
15:06:10 <Cale> wolftune: Also, it's worth noting that this means the order of arguments to functions actually matters.
15:06:22 <Cale> wolftune: or rather the order of their parameters does
15:06:28 <wolftune> sure, I just tend to think best when I really get things and don't just accept things by rote
15:06:31 <pavonia> mm_freak: I guess I should tackle the problem in the first place, currently I'm doing a "curl -o". Modifying the lines here would be more efficient
15:06:40 <Cale> wolftune: You'll generally want the parameters to be in order of increasing expected rate of change.
15:06:53 <Cale> wolftune: The parameters which are "more like constants" you want to come first.
15:07:11 <mm_freak> pavonia: definitely…  you can stream from stdin into a file
15:07:17 <Cale> This is for two reasons:
15:07:21 <mm_freak> and do the manipulation on the fly
15:07:29 <Cale> 1) It makes the function easier for users to specialise
15:07:51 <pavonia> yep, that's way better :)
15:08:06 <NemesisD> have any of you guys ever tried out GHC.Generics
15:08:09 <testingok> prooftechnique: thanks. ill try that out
15:08:28 <Cale> 2) It sometimes allows you to produce something which efficiently computes part of the result in terms of the initial parameters, and then uses that along with the final parameters to more efficiently compute many results.
15:08:29 <dreixel> NemesisD: yep
15:08:34 <Cale> (i.e. partial evaluation)
15:09:06 <testingok> prooftechnique: and maybe ill find a cleaner way to parse the input than those nested cases :)
15:10:00 <NemesisD> dreixel: i'm trying to use it for a default typeclass instance for a type of the shape Foo Int Bool, that is 1 constructor, n arguments
15:10:20 <wolftune> I'm havin trouble thinking for f x y = x + y, What is the function that happens with x that then takes y as an argument?
15:10:30 <NemesisD> i've got most of it there but i'm trying to figure out how i can associate some metadata about the constructor
15:11:00 <FireFly> wolftune: think of (+) as taking a number, and returning a function that adds that number to a thing
15:11:16 <FireFly> > let add5 = (+) 5 in add5 10
15:11:22 <FireFly>   15
15:11:25 <wolftune> ah ok
15:11:34 * FireFly is a temporary lambdabot stand-in
15:12:14 <wolftune> so f x y = x + y makes an intermediate function like: let f x = (+) x ?
15:12:34 <wolftune> wait
15:12:38 <Cale> wolftune: Yeah, it's the same as f = (\x -> (\y -> x + y))
15:12:43 <nooodl_> f   = \x -> (\y -> x + y)
15:12:43 <nooodl_> f 3 =        \y -> 3 + y
15:12:48 <lpaste> NemesisD pasted “Generics Question” at http://lpaste.net/95829
15:12:50 <wolftune> I mean the intermediate is f y = (+) x ?
15:13:02 <Cale> and then f 5 = (\x -> (\y -> x + y)) 5 = (\y -> 5 + y)
15:13:33 <Cale> wolftune: (are you familiar with lambda?)
15:13:43 <wolftune> Cale: we've met but are not familiar
15:13:49 <Cale> (\x -> y) means the function which given x, produces y as the result
15:13:57 <wolftune> ok
15:14:00 <Cale> So, e.g. (\x -> x*x) 5 = 25
15:15:01 <wolftune> ok so what's the lambda notation for what happens with f x y = x + y ?
15:15:17 <Cale> Well, first of all, we can move the parameters to the other side of the equals sign
15:15:30 <Cale> f x = \y -> x + y
15:15:38 <Cale> f = \x -> (\y -> x + y)
15:15:48 <wolftune> ah
15:15:50 <wolftune> ok
15:15:52 <wolftune>  that helps
15:15:53 <Cale> Now, suppose we apply f to 5
15:15:58 <Cale> f 5
15:16:04 <Cale> = (\x -> (\y -> x + y)) 5
15:16:08 <Cale> (by substitution)
15:16:17 <Cale> = (\y -> 5 + y)
15:16:24 <wolftune> great
15:16:30 * hackagebot chatter 0.0.0.1 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.0.0.1 (RoganCreswick)
15:16:30 <pavonia> mm_freak: Any ideas how I would read the process output of a process and write it to a file line-by-line?
15:16:46 <Cale> (by something called beta reduction)
15:16:54 <intrados> What's the idiom for waitAll in Control.Concurrent.Async?
15:18:08 <wolftune> Cale: thanks, I think I got it
15:18:16 <NemesisD> basically i need to figure out how to define a generic instance for a constructor, one that can't be mechanically derived
15:19:00 <Cale> intrados: odd that doesn't exist
15:19:13 <intrados> Cale: Yeah. I thought so
15:19:34 <nooodl_> wolftune: <Cale> ghci> map (map (*10)) [[1,2,3],[4,5],[6,7,8]] <-- i bet this is a nice little thing to piece apart when you're learning about currying
15:19:50 <Cale> waitAll [] = return []; waitAll (x:xs) = do (v,vs) <- waitBoth x (waitAll xs); return (v:vs)
15:20:01 <quchen> "Idiom"?
15:20:20 <intrados> Cale: Thanks.
15:20:54 <intrados> quchen: I wasn't sure if there was some common means of expressing waitAll that I just didn't realize (thus explaining its absence)
15:21:14 <wolftune> Cale: so in f :: a -> a -> a -> a -> a, (that is possible, right?), I'm confused because I thought all a means they are all the same type, but some of these a's must be functions and others might not be functions but could be Int or whatever…
15:21:18 <quchen> intrados: Oh, I thought waitAll existed and you were asking for "its idiom".
15:21:32 <Cale> wolftune: All the a's are the same there
15:21:49 <wolftune> Cale: so in *that* case, all the a's MUST be functions?
15:21:53 <Cale> wolftune: If you were to apply such an f to a single value of type a, then the result would have type a -> a -> a -> a
15:21:56 <skypers> night everyone
15:22:03 <Cale> no, they could all be Integer, for example
15:22:05 <quchen> Cale: How is your solution different compared to "mapM wait"?
15:22:37 <quchen> Or is it just the same thing but with inlined definitions
15:22:50 <Cale> quchen: It's whatever the difference is between waitBoth and liftM2 (,) wait wait
15:22:58 <Cale> quchen: (exception handling stuff)
15:23:21 <wolftune> Cale: ok, but here' where I'm still confused: if the function that appears to take multiple arguments is actually a function that takes an argument and evaluates to another function which itself takes and argument, etc. then doesn't there have to be a point in the definition where the output is a function and not an Int?
15:23:36 <Cale> That's right
15:23:45 <Cale> If f :: Int -> Int -> Int -> Int -> Int
15:23:54 <Cale> then f 4 :: Int -> Int -> Int -> Int
15:24:00 <quchen> Cale: But 'wait' also rethrows any exceptions its argument produces, doesn't it?
15:24:07 <Cale> and f 4 8 :: Int -> Int -> Int
15:24:27 <mm_freak> pavonia: well, i'd use a streaming abstraction, my favorite being pipes
15:24:30 <intrados> quchen: So `mapM wait` wouldn't wait on the elements in sequence?
15:24:53 <wolftune> so wait (Int -> Int) is itself a value right? it's type is FUNCTION, yes?
15:25:12 <mauke> Int -> Int is the type of a function taking an Int and returning an Int
15:25:15 <Cale> Int -> Int is a type
15:25:21 <wolftune> Cale: right
15:25:21 <monochrom> no no, Int->Int is a type, not a value. that type is a function type.
15:25:26 <Cale> It's the type of functions which take an Int and produce an INt
15:25:28 <Cale> Int*
15:25:46 <quchen> intrados: "mapM wait" is sequential
15:25:58 <pavonia> mm_freak: Nice, thanks!
15:26:04 <wolftune> now functions are themselves values, but the function as a value would be the actual function definition, whereas Int -> Int is just its type
15:26:04 <quchen> intrados: it's "sequence [wait a1, wait a2, wait a3, ...]
15:26:27 <Cale> oh
15:26:41 <Cale> You're right, we should probably use waitSTM here
15:26:48 <Cale> hmm
15:27:11 <dwcook> wolftune, a function definition is essentially a description of a function value.
15:27:21 <wolftune> dwcook: yes, thanks
15:27:37 <quchen> intrados: What are you trying to do? A "waitAll" function that executes a number of asyncs and collects their results ordered by time taken?
15:28:06 <Cale> wolftune: Yeah, it's important to realise that at runtime, values of any type at all can still be in something like an expression form.
15:28:18 <wolftune> The point is, in a -> a -> a -> a, is it not true that I could substitute an (a -> a) for just a placeholder called b (say), if it were possible for that value to be something other than a function?
15:28:37 <intrados> Order doesn't matter but yeah. Basically I just want to set up several futures and block until they've all resolved
15:28:44 <Cale> Well, a -> a only occurs once as a subexpression of a -> a -> a -> a
15:28:52 <Cale> -> isn't associative, it's right-associative
15:29:15 <quchen> intrados: Then what Cale wrote or "mapM wait" should do the trick. mapM wait won't finish until all the waits are done.
15:29:23 <Cale> So you can't treat a function of type a -> a -> a -> a as something of type (a -> a) -> (a -> a), for example, those are different
15:29:31 <Cale> a -> a -> a -> a means a -> (a -> (a -> a))
15:29:32 <wolftune> So could I say that (a -> (a -> a)) is itself a possible version of (a -> b) ?
15:29:36 <Cale> yes
15:29:49 <dwcook> b can be a -> a, yes
15:29:49 <Cale> You absolutely could!
15:29:54 <wolftune> ok!
15:29:59 <monochrom> wolftune: maybe it's time I suggest my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
15:30:02 <intrados> quchen: But won't `mapM wait` take ~n times as long?
15:30:13 <quchen> intrados: Why?
15:30:45 <intrados> quchen: Because it waits for the the first element, and doesn't move on to wait on the second element until the first resolves
15:30:57 <quchen> intrados: The async starts calculating as soon as you crete it. "wait" just waits for the result.
15:31:09 <quchen> It's true that you won't get any output before the first "wait" finishes.
15:31:18 <Cale> wolftune: for example, you can write  map (+) :: [Integer] -> [Integer -> Integer]
15:31:30 <quchen> But when the first "wait" takes forever, all the asyncs are still calculating.
15:31:42 <quchen> "wait"ing for an async is not necessary for the computation itself.
15:31:54 <intrados> quchen: Ah, thanks. I wasn't thinking that the others were running while waiting on any
15:31:54 <Cale> Since  map :: (a -> b) -> [a] -> [b]
15:32:07 <Cale> if we put in a = Integer and b = Integer -> Integer
15:32:28 <Cale> we can specialise map :: (Integer -> Integer -> Integer) -> [Integer] -> [Integer -> Integer]
15:32:31 <quchen> intrados: "wait" is really just to get the result out of an Async. Putting it in there is what does the actual work though.
15:32:55 <quchen> intrados: Requiring "wait" would be pretty awkward if you wanted an infinite loop in an Async :-)
15:33:02 <quchen> (Say for a server)
15:33:39 <intrados> quchen: Yeah, it makes sense now that you say it. I think I was expecting otherwise because it seemed lazier
15:34:16 <quchen> intrados: You may also want to have a look at Marlow's book, it's fairly comprehensible and explains Async in its own chapter
15:35:13 <codygman> If I'm going to be piping a video file to a haskell program, what should I use? I'm guessing not getLine... lol. Is there a binary equivalent perhaps? Am I on the right track?
15:36:00 <Cale> codygman: you should be using ByteStrings
15:36:06 <Cale> (Maybe Lazy ones)
15:36:08 <intrados> quchen: Yeah. Perhaps I'll read that once I finish Pierce's TAPL
15:36:23 <quchen> intrados: Haha, I'm chewing on that one as well right now
15:36:31 * hackagebot chatter 0.0.0.2 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.0.0.2 (RoganCreswick)
15:37:06 <Cale> quchen: Using async on something which intentionally takes forever feels wrong
15:37:50 <Cale> quchen: I would expect it to be a valid thing for the async library to attach a finaliser to the Async values that kill threads off if nothing can ever wait on the computation.
15:37:56 <Cale> kills*
15:40:00 <quchen> Cale: Hm. I pretty much use Async exclusively instead of forkIO.
15:41:32 * hackagebot pipes-rt 0.4.1 - A few pipes to control the timing of yields  http://hackage.haskell.org/package/pipes-rt-0.4.1 (imalsogreg)
15:43:11 <Cale> Has anyone else noticed that the new hackage often has bad documentation links?
15:43:15 <razieliyo> http://ideone.com/AnKlKc
15:43:16 <quchen> Yes.
15:43:20 <razieliyo> is there anything wrong with this?
15:43:21 <quchen> Cale: file:///...?
15:43:30 <razieliyo> indentation or using a binding inside the same where
15:43:34 <quchen> It's a known issue, at least I've been told that.
15:44:45 <wolftune> thanks everyone for the help, gonna go back to more studying cheers!
15:44:46 <Cale> quchen: I believe they were http links, just 404s
15:45:40 <NemesisD> is there any way to see the source of a derived instance of a class in ghci
15:45:41 <quchen> Cale: Oh, I know why asyncs shouldn't be killed if nothing waits for them: that would disallow building process hierarchies. "withAsync a $ \aa -> withAsync b $ \bb -> wait aa" for example has the main computation a, but also launches b alongside. If a finishes, b is canceled. If either throws, both are.
15:45:56 <scott_> Cale: Like the source links here: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html
15:46:10 <Cale> quchen: I mean, if the Async itself is garbage collected, kill the thread.
15:46:48 <quchen> Oh.
15:47:41 <Cale> (You'd have to be careful when building process trees, but that should still be possible)
15:48:11 <zardoz``> is there epsilonEq in Prelude?  epsilonEq e x y = abs (x - y) < e
15:48:19 <Cale> I just mean, if nothing could conceivably ever receive the result of the computation, then stop doing it immediately.
15:48:32 <Cale> zardoz``: no
15:48:33 <quchen> zardoz``: No, there's nothing like that in Prelde
15:49:11 <hpc> Prelde sounds like the name of a large scandanavian bond villian henchman with a mole on her upper lip
15:49:28 <quchen> Cale: I guess that's debatable. Non-terminating computations can still have effects. I guess the issue is more that executing processes should not be GC'd.
15:49:32 <Philonous> hpc, That is a very specific sound
15:49:38 <zardoz``> what's a better name? epsilonEq, floatEq?
15:49:40 <hpc> extremely
15:49:53 <quchen> zardoz``: "withinRange(Of)"?
15:50:12 <zardoz``> like it
15:50:16 <Philonous> zardoz``, Eq suggests some form of equivalence relation, which it is not.
15:50:38 <zardoz``> Philonous it is in a way. we define what we mean by equal with epsilon
15:50:51 <Philonous> zardoz``, Except that it's not transitive
15:50:56 <quchen> zardoz``: neighbourhoodOf!   epsilon `neighbourhoodOf` x
15:50:57 <quchen> :-D
15:50:57 <zardoz``> true
15:51:04 <zardoz``> :)
15:51:08 <Cale> quchen: Yeah, I just see Async as a way to discuss effectful processes whose entire purpose is to produce values, such that if the values aren't needed, then the effects might as well not happen anymore.
15:51:31 <Cale> (e.g. like downloading files)
15:51:49 <quchen> Cale: Makes sense. I'll be more careful when using asyncs then.
15:51:52 <quchen> Just in case.
15:52:02 <chrisdone> acquiring any resource you have to wait for, i guess
15:52:44 <chrisdone> cabal install needs a --also-executables  flag
15:53:04 <chrisdone> so i don't have to manually install gtk2hs-buildtools, happy, etc
15:54:21 <Philonous> Cale, You can't always tell if someone is waiting for the value with the current API since somebode might be using the STM cell rather than the Async itself
15:55:01 <eben> Would you guys say it's worthwhile to learn arrows and use them in code?
15:55:17 <pharaun> HXT uses arrows
15:55:32 <pharaun> lots of xml parser apparently(?) uses arrows so they're useful to learn about
15:56:02 <eben> I've been looking at yampa which is what got me interested
15:56:16 <eben> But saw on stackoverflow people didn't like them being used
15:56:34 <Clint> hakyll used to use them, then stopped
15:57:02 <bennofs> I think many people agree that using Arrow for FRP is ok
15:57:23 <bennofs> They just don't like HXT arrows, which could actually be made monads
15:57:36 <eben> Awesome, I'm intending to be using them for FRP
16:00:07 <CADD> pharaun: HXT is AWESOME
16:00:15 <quchen> Cale: How would you create such a finalizer anyway? Weak IORefs?
16:01:40 <pharaun> CADD: HXT isn't bad, but i do wish it operated on Text instead of STring :) but i may eventually try to do some work there
16:01:53 <Philonous> quchen, addFinalizer from System.Mem.Weak
16:02:26 <CADD> pharaun: i couldnt agree with you more. i found the HXT pickler to be a delight
16:18:45 <chrisdone> https://ghc.haskell.org/trac/ghc/ticket/5212#comment:4
16:18:48 <chrisdone> can anyone reproduce this?
16:19:58 <enthropy> chrisdone: xmonad messes around with signal handlers which might be the reason?
16:21:32 <chrisdone> hmm, yeah, it installs a sig pipe handler
16:21:39 <chrisdone> also sig child
16:21:46 <chrisdone> probably the sig child one
16:21:50 * chrisdone tests
16:23:12 <Tekmo> Is it possible to upload packages to Hackage yet?
16:24:13 <razieliyo> can I declare the type of multiple vars? let's say: var1,var2,var :: (Int,Double)
16:24:18 <Tekmo> Yes
16:24:50 <enthropy> Tekmo: you mean documentation? hackage has always accepted package uploads
16:24:58 <dibblego> Are there any people from Canberra, Australia? If so, are there any user groups for haskell or functional programming in general?
16:25:05 <Tekmo> enthropy: I mean packages
16:25:09 <enthropy> at least when you have an account
16:25:17 <chrisdone> enthropy: yep, that's the reason
16:25:21 <Tekmo> I tried to upload something using `cabal upload` and it failed with an error
16:25:26 <hpc> dibblego: the best place to check is -cafe
16:25:30 <lpaste> chrisdone pasted “signals” at http://lpaste.net/95832
16:25:32 <dibblego> hpc: ok thanks
16:25:53 <enthropy> well I'm confused because I think you've uploaded stuff
16:26:12 <rdesfo> I installed fay with cabal install how can I call 'fay' from the prompt?
16:26:22 <razieliyo> Tekmo: if that Yes was to me, say it
16:26:33 <Tekmo> razieliyo: Yes
16:26:41 <scott_> rdesfo: You probably need .cabal/bin in PATH
16:26:42 <augur> does Parsec choke on left-recursion?
16:26:54 <carter> you can upload haddocks to hackage2 too
16:26:55 <Tekmo> enthropy: I just tried a few minutes ago and it failed
16:27:04 <carter> Tekmo: ask on #haskell-infrastructure
16:27:08 <carter> #haskell wont' know :)
16:27:12 <Tekmo> Ok
16:27:25 <enthropy> if you `cabal upload -v3` you'll get more information about what went wrong
16:28:32 <Tekmo> Oh, hah
16:28:36 <Tekmo> I know exactly what is wrong now
16:28:39 <Tekmo> Thanks for the tip, carter
16:28:46 <Tekmo> It's because I was still using hdiff.luite
16:29:15 <chrisdone> hehe
16:29:22 <rdesfo> scott_: I already have cabal/bin in my PATH
16:29:40 <scott_> rdesfo: And the fay binary is in there?
16:30:15 <dwcook> augur, from what I've seen, yes
16:30:39 <carter> Tekmo: cooking up a good multidimensional array api is almost as hard as desigin a good incremental streaming library
16:30:45 <augur> dwcook: :(
16:30:54 <Tekmo> carter: :)
16:30:58 <augur> well im a chart-y person anyway :p
16:31:11 <augur> i wonder tho if its possible to write applicative-style parsers that are bottom up
16:31:17 <carter> augur: yes
16:31:22 <augur> carter: are there? :o
16:31:26 <carter> its a recurrent dream we share
16:31:32 <carter> you can design some neat stuff like that
16:31:35 <carter> ummm
16:31:36 * hackagebot pipes 4.0.1 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.0.1 (GabrielGonzalez)
16:31:38 <carter> utrech parsers
16:31:41 <carter> and a few other things
16:31:43 <carter> have stuff
16:31:45 <augur> carter: link?
16:31:53 <carter> @hackage  uuparse ?
16:32:25 <chrisdone> lambdabot is gone again
16:32:44 <rdesfo> .cabal/bin is missing.
16:32:46 <hpc> lambdabot's flakier than fresh baklava
16:32:50 <dwcook> more like scramdabot
16:33:04 * chrisdone cabal unpacks lambdabot on hits hetzner
16:34:03 <rdesfo> I created dir ~/bin and ran 'cabal sandbox init... install ---only-dependencies... build'
16:34:38 <chrisdone> i imagine lambdabot went when that node went offline, and because it doesn't have a bouncer it didn't reconnect =)
16:41:37 * hackagebot pipes-bytestring 1.0.2 - ByteString support for pipes  http://hackage.haskell.org/package/pipes-bytestring-1.0.2 (GabrielGonzalez)
16:46:40 <khyperia> I'm creating a lambda-calculus based language, but with top-level definitions like Haskell (these top-levels can be recursive against each other, again like haskell). Is there a way to extend Milner Hindley to allow such variable recursion?
16:47:02 <carter> there must be :)
16:47:19 <carter> khyperia: all the top level defns are in a implicit letrec
16:47:22 <ion> khyperia: So you’re creating Haskell?
16:47:25 <quchen> @botsnack
16:48:25 <khyperia> I've never heard of letrec, is there another rule in hindley-milner that I don't know about? I'm just going off these six - http://stackoverflow.com/questions/12532552
16:48:47 <khyperia> ion, haha, sort of. My own (very basic) spin on it, as a sort of introduction to a more complex compiler.
16:48:50 <carter> khyperia: read bob harpers book
16:49:10 <carter> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
16:49:18 <carter> khyperia: you have a bit of reading to do :)
16:49:32 <khyperia> heh
16:49:33 <carter> bob favors ML over haskell wrt language style, but he covers all the types stuff
16:49:39 <quchen> carter: I like how it's 558 pages of preview.
16:49:50 <carter> the print version is pretty affordable
16:50:30 <quchen> carter: How does it compare to TAPL (in terms of content covered in particular)?
16:50:36 <carter> newer
16:50:42 <carter> more mathematically sophisticated
16:50:45 <carter> they're different books
16:50:53 <carter> i last read TAPL in like …. 2005?
16:51:14 <carter> like, bob's book covers MORE and more Densly
16:51:22 <carter> TAPL is probably a good warm up
16:51:26 <Hodapp> khyperia: what do you mean by variable recursion?
16:51:38 <carter> it means he's needing to read up more :)
16:51:58 <amosr> implicit letrec is a mistake…
16:52:09 <khyperia> Hodapp, classical lambda calculus doesn't have top-level arbitrary variable bindings.
16:52:18 <khyperia> more like value bindings, not variable
16:52:21 <khyperia> because immutability
16:52:47 <dcoutts_> khyperia: letrec vs let  is just distinguishing whether the defined variable is available in the body or not. Haskell doesn't have two kinds, it's let is letrec. In ML (iirc) they have both forms.
16:53:03 <dcoutts_> so the let in the HM rules is letrec
16:53:30 <Hodapp> I don't see how top-level arbitrary variable bindings would change anything in classical lambda calculus...
16:54:10 <khyperia> x = y; y = x; is invalid in normal lambda calc, but *is* valid if you have arbitrary bindings (note "arbitrary bindings" is a made up term by me)
16:54:43 <khyperia> wait... oh... writing that out made me see something
16:54:54 <Hodapp> what's that?
16:55:02 <khyperia> ... maybe, not sure. Lemme think.
16:55:38 <quchen> dcoutts_: Ah, so let is to letrec like do is to "do … rec"
16:55:50 <quchen> Is that where the "do-rec" name comes from?
16:55:52 <khyperia> that example would be "letrec x = (let y = x in y) in [something]", right?
16:56:41 <dcoutts_> quchen: yes I guess so
16:57:56 <jle`> let rec lets you specify if you want bindings to refer to the previous definition or the current definition
16:58:22 <khyperia> jle`, why does it have to refer to the previous definition?
16:58:33 <jle`> by previous, i mean the environment of the outer level
16:58:43 <khyperia> ah, yeah, but that's normal let as well
16:58:44 <jle`> (we're talkinga bout ocaml, right?)
16:58:51 <khyperia> we're talking about lambda calc
16:58:53 <jle`> (/ml)
16:59:01 <jle`> ml/ocaml is just a series of nested let statements
16:59:19 <jle`> not series, but...literally thin shells of let statements
16:59:23 <jle`> with one statement per level
16:59:36 <Hodapp> a thin candy crust on top of that?
16:59:48 <jle`> indeed
16:59:55 <khyperia> but theoretically you could refer to a variable as far down as you wanted
17:00:03 <khyperia> if you abuse let rec
17:00:20 <jle`> er, do you mean outwards or inwards
17:00:38 <jle`> actually i lied, you can have multiple statements per level in ocaml; forgot about and's
17:00:58 <jle`> you can't refer to a variable outwards if all references have been shadow'd away
17:02:27 <jle`> you can't refer anything downwards in ocaml, i believe
17:02:51 <jle`> unless you're outside of the let ... in
17:02:57 <jle`> don't listen to me i don't know what i'm talking about
17:03:15 <khyperia> but if you do this translation - "let x = z; let y = x; let z = y; [something]" == "letrec x = (letrec y = (let z = y in z) in y) in [something]"
17:03:48 <khyperia> "it's letrecs all the way down"
17:03:52 <jle`> yes that is the desugaring
17:04:07 <khyperia> alright, good, making sure I understand it.
17:04:11 <jle`> wait
17:04:17 <khyperia> since I plan on implementing a compiler to do so.
17:04:32 <jle`> i misread what you wrote
17:04:41 <jle`> but with my new reading i am still thinking of an answer
17:04:48 <khyperia> or something like that, not sure on the order of x, y, and z
17:05:14 <jle`> you can't express this as nested let recs in ocaml i believe
17:05:24 <jle`> someone more experienced can correct me if i'm wrong
17:05:39 <jle`> ocaml provides the syntax structure let rec x = z and y = x and z = y
17:05:49 <jle`> you need the 'and' for anything mutually recursive
17:06:36 <jle`> i don't think you can express mutual recursion as nested let recs.
17:10:31 <khyperia> ah, this post explains it - http://softoption.us/content/node/44 essentially, letrec desugars to standard lambda calc terms (!), and multiple letrec/and bindings desugars to a tuple
17:11:23 <carter> thats one way to do it
17:11:25 <carter> BUT
17:11:34 <carter> not always the best way
17:11:37 <carter> depends on the goal :)
17:11:55 <khyperia> then what *is* the best way? My goal is to typecheck a haskell-like language.
17:12:11 <carter> depends on the goal
17:12:17 <carter> typechecking is but one step
17:12:24 <carter> khyperia: have you seen the type checker as a library
17:12:25 <carter> ?
17:12:30 <khyperia> nope
17:12:40 <carter> http://hackage.haskell.org/package/haskell-type-exts
17:13:40 <khyperia> Ah. I'd rather make it myself, though, since my language isn't *exactly* like haskell, and I need the learning experience anyway.
17:13:50 <carter> sure
17:13:59 <carter> don't do typeclasses
17:14:03 <carter> those are a rabbit hole :)
17:14:14 <khyperia> heh
17:15:04 <khyperia> but do you have any advice on how to solve the problem of the top-level definitions?
17:15:07 <carter> yes
17:15:14 <carter> collect the defns
17:15:24 <carter> and treat them as being impliciently in a top level let rec
17:15:30 <carter> done
17:15:41 <carter> NB: in haskell let = letrec
17:15:47 <khyperia> yeah
17:16:24 <khyperia> so does hindley-milner allow letrecs, or do I have to desugar to standard lambda calc?
17:17:11 <carter> khyperia: read that book
17:17:17 <khyperia> heh
17:17:17 <carter> or the papers
17:17:20 <carter> read them
17:17:30 <carter> IRC is not a type ssytem paper or exposition
17:18:54 <carter> @tell bos your tweets are so amusing i'm like "Y = Y"
17:18:58 <carter> darnit
17:19:01 <carter> no lambda bot :(
17:19:52 <chrisdone> @djinn a -> a
17:19:55 <lambdabot> f a = a
17:20:08 <carter> @tell chrisdone  doesn't work :(
17:20:09 <chrisdone> ok. i just installed it, running on lpaste's server
17:20:11 <lambdabot> Consider it noted.
17:20:11 <carter> ok
17:20:14 <carter> darn
17:20:17 <carter> @tell bos your tweets are so amusing i'm like "Y = Y"
17:20:19 <lambdabot> Consider it noted.
17:20:21 <carter> yay
17:20:21 <chrisdone> carter: you did it just before lambdabot joined =p
17:20:24 <carter> hehe
17:20:46 <carter> @faq can lambdabot work for me even when its not connected?
17:20:46 <lambdabot> The answer is: Yes! Haskell can do that.
17:21:04 <carter> @faq will lambdabot lie to me?
17:21:04 <lambdabot> The answer is: Yes! Haskell can do that.
17:21:07 <triliyn> hmmm, it just occurred to me that perhaps it would be nice to have a "has-type" operator that is not visually symmetrical
17:21:07 <chrisdone> > 1
17:21:08 <lambdabot>   1
17:21:11 <chrisdone> nice and fast
17:21:16 <Iceland_jack> > 5
17:21:16 <lambdabot>   5
17:21:19 <triliyn> Not that it's really a necessary thing
17:21:36 <triliyn> Just nice, since the two sides of :: are not the same semantically
17:21:48 <danharaj> > 1 / 3
17:21:48 <lambdabot>   0.3333333333333333
17:22:09 <chrisdone> i don't have the L.hs of normal lambdabot, so it probably doesn't have things one might expect. not sure where to get that file
17:22:10 <triliyn> And then we could use its flipped version to replace the = in data declarations
17:22:18 <triliyn> Which are not really a declaration of equality anyway
17:22:28 <carter> > let fact n = if n == 0 then 1 else n *  fact (n-1 ) in  fact 20
17:22:29 <lambdabot>   2432902008176640000
17:22:35 <carter> > let fact n = if n == 0 then 1 else n *  fact (n-1 ) in  fact 50
17:22:36 <lambdabot>   30414093201713378043612608166064768844377641568960512000000000000
17:22:39 <carter> snappy
17:22:41 <chrisdone> :D
17:23:37 <carter> > let fact n = if n == 0 then 1 else n *  fact (n-1 ) in  fact 80 `mod` 2
17:23:38 <lambdabot>   0
17:23:49 <carter> > let fact n = if n == 0 then 1 else n *  fact (n-1 ) in  fact 100 `mod` 2
17:23:49 <lambdabot>   0
17:23:53 <carter> hot damn
17:24:10 <carter> i hope i'm not spiking the ram usage on your machien :)
17:24:23 <enthropy> is there a nicer way to specify    x `asTypeOf` (undefined :: blah)?
17:24:39 <enthropy> this is not exactly the same as   (x :: blah)
17:24:45 <chrisdone> carter: it's a dedicated server, it has 16gb of ram. if it caused any trouble the rlimits would kill it =)
17:24:55 <carter> > let fact n = if n == 0 then 1 else n *  fact (n-1 ) in  fact 1000 `mod` 2
17:24:56 <lambdabot>   0
17:25:20 <carter> > let fact n = if n == 0 then 1 else n *  fact (n-1 ) in  (fact (100 :: Integer)) `mod` 2
17:25:21 <lambdabot>   0
17:25:32 <carter> i'll stop
17:25:39 <chrisdone> lol, are you trying to make a non-infinite computation that reaches the limits?
17:25:41 <enthropy> that Integer shouldn't be needed
17:25:54 <carter> :t 7
17:25:55 <lambdabot> Num a => a
17:25:56 <chrisdone> > let r = r in r
17:26:00 <lambdabot>   mueval-core: Time limit exceeded
17:26:11 <carter> > let fact n = if n == 0 then 1 else n *  fact (n-1 ) in  (fact (1000 :: Integer)) `mod` 2
17:26:12 <lambdabot>   0
17:26:15 <enthropy> triliyn: = also looks symmetrical but isn't either
17:26:21 <carter> > let fact n = if n == 0 then 1 else n *  fact (n-1 ) in  (fact (10000 :: Integer)) `mod` 2
17:26:21 <lambdabot>   0
17:26:34 <carter> be glad i'm doing mod 2
17:26:43 <triliyn> enthropy: I suppose so, but it's at least closer to symmetrical
17:27:21 <triliyn> If you have a = b, it's admissible to substitute a for b or vice versa, even if the compiler doesn't necessarily do this
17:27:36 <triliyn> But if you have data a = b, you can never ever substitute
17:27:53 <triliyn> It wouldn't even make sense to attempt substitution
17:28:01 <triliyn> You wouldn't get incorrect equations, you'd get nonsense o.o
17:28:15 <enthropy> @where promotion
17:28:15 <lambdabot> I know nothing about promotion.
17:28:56 <enthropy> @where+ promotion http://www.haskell.org/ghc/docs/latest/html/users_guide/promotion.html
17:28:56 <lambdabot> I will remember.
17:28:57 <chrisdone> enthropy: i don't have the recent state file. however, i have all the irc logs since 2001, so i can probably generate a rather complete @where list
17:29:16 * enthropy isn't sure if that one was ever in there
17:29:43 <enthropy> but triliyn, that's one way you can kind of cross over the ::
17:30:08 <chrisdone> heh, i could make lambdabot hook into ircbrowse for actions on the logs
17:30:11 <enthropy> rather it's the only way
17:30:39 <chrisdone> like "@grep promotion\.html" to call up the first result matching that
17:30:48 <triliyn> enthropy: I know about promotion, but I don't consider kinds and types with the same name to be the same thing
17:31:22 <triliyn> I model it as being like "data a = b; data kind A = B"
17:31:30 <triliyn> Even though they use the same names
17:32:15 <ski> @tell quchen re typing rules, did you try "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://cs.au.dk/~mis/typeinf.pdf> yet ?
17:32:15 <lambdabot> Consider it noted.
17:32:47 <ski> <kqr> is there a sort of "Num a" division, that does (/) on types where it is possible, and div on types where that is all you get?
17:32:52 <ski> kqr : with what laws ?
17:38:23 <ski> augur : "directional conjunction" ?
17:38:56 <augur> ski: conjunction in a stateful system where new vars in the left conjunct are available in the right conjunct
17:39:03 * ski isn't seeing the diff-lists
17:39:51 <augur> ski: to do that, you have a stateful environment, which you implement via diff lists
17:40:58 <ski> why do you think of it as a diff-list, rather than as an accumulator pair ?
17:41:20 <augur> ski: well, it would be an accumulator pair in practice, yes. but the stateful component is a diff list
17:41:37 <ski> only if you only add to it, no ?
17:41:47 <augur> ski: yes, but you'd need to add to it!
17:41:56 <augur> thats what new var declarations do! :)
17:42:09 <ski> wouldn't you like to also be able to remove variables ?
17:42:19 <augur> yes that too
17:42:24 <augur> anyway its just a rough analogy.
17:42:31 <ski> (and then it's no longer a diff-list)
17:42:47 <augur> actually the adding is the non-diff-y part
17:42:53 <augur> since diff lists should reduce the list
17:43:03 <ski> depends on how you order the pair
17:43:08 <augur> not really
17:43:14 <augur> im thinking prolog diff lists fwiw
17:43:18 * ski too
17:43:47 <ski> in a sense, diff-lists don't exist in Prolog
17:43:57 <augur> sure they do, sort of
17:44:02 <ski> or, perhaps more clearly : they aren't first-class concepts
17:44:06 <augur> yeah
17:45:12 <ski> i think one could probably manage them with a uniqueness mode system, to ensure no double use
17:46:49 <ski> hm .. i wonder whether this noncopyability is related to noncopyability of data structures represented using church/continuations
17:50:31 <Audiblade> Hello! I have a newbie question about Haskell. Is this a good place to ask it?
17:50:37 <Iceland_jack> sure! ask away
17:50:51 <Audiblade> Thanks!
17:51:11 <Audiblade> For a homework assignment (I'm not going to ask for answers, just help using command line tools),
17:51:16 <Audiblade> I was given this file:
17:51:19 <Audiblade> import Prelude
17:51:20 <Audiblade> import System.Environment ( getArgs )
17:51:22 <Audiblade> import Data.List
17:51:23 <Audiblade> import Data.Maybe
17:51:24 <hpc> oh god
17:51:25 <Audiblade> -- The main method that will be used for testing / command line access
17:51:26 <Audiblade> main = do
17:51:28 <Audiblade> 	args <- getArgs
17:51:29 <Iceland_jack> Audiblade: You shouldn't copy code
17:51:29 <Audiblade> 	pacFile <- readFile (head args)
17:51:31 <Audiblade> 	map <- mapTuple pacFile
17:51:32 <Audiblade> 	let
17:51:34 <Audiblade> 		pac = map
17:51:35 <Audiblade> 		in yourMain pac
17:51:37 <Audiblade> partFiveOutput :: (Int, Int, Int, [[Char]]) -> IO ()
17:51:38 <Audiblade> partFiveOutput pac = do
17:51:40 <Audiblade> 	print pac
17:51:41 <Audiblade> -- Converts a string to a tuple representing the pac-man map
17:51:43 <Audiblade> mapTuple :: String -> IO (Int, Int, Int, [[Char]], [Char])
17:51:44 <Audiblade> mapTuple = readIO
17:51:45 <Peaker> @ops
17:51:45 <lambdabot> Maybe you meant: pl oeis docs
17:51:46 <Audiblade> -- YOUR CODE SHOULD COME AFTER THIS POINT
17:51:47 <Audiblade> -- yourMain
17:51:49 <Audiblade> yourMain pac =
17:51:50 <Audiblade> 	partFiveOutput $ moveall pac
17:51:51 <Peaker> @where ops
17:51:51 <Audiblade> --moveall :: (Int, Int, Int, [[Char]], [Char]) -> (Int, Int, Int, [[Char]])
17:51:51 <lambdabot> I know nothing about ops.
17:51:51 --- mode: ChanServ set +o geekosaur
17:51:52 <Audiblade> sorry =P
17:52:07 <Iceland_jack> Audiblade: Go to http://lpaste.net/new/haskell, paste the code there
17:52:10 <Audiblade> Anyway, my question is, how would I run this from the command line?
17:52:10 <Iceland_jack> please
17:52:12 <geekosaur> don't paste into the channel, use the pastebin in the /topic
17:52:19 --- mode: geekosaur set -o geekosaur
17:52:25 <Iceland_jack> Audiblade: You can use ‘runghc <file>.hs’
17:52:36 <Audiblade> ok
17:52:49 <Iceland_jack> or compile the program ‘ghc --make <file>.hs’ which should produce a binary
17:52:58 <geekosaur> ghc is a compiler, like gcc. normally you compile Haskell code into an executable or a library
17:53:09 <geekosaur> um, it's been some years since you needed --make...
17:53:21 <Iceland_jack> yes sorry, omit --make :)
17:53:30 <Iceland_jack> old habits
17:53:36 <Audiblade> I tried using ghc and ran into problems... let me try it again
17:53:38 <chrisdone> @choose cake death
17:53:38 <lambdabot> death
17:54:47 <hpc> death is much healthier than cake
17:55:03 <Audiblade> while that's compiling, if I want to share a code snippet on IRC, how should I do so?
17:55:15 <Iceland_jack> Audiblade: Use lpaste
17:55:18 <chrisdone> http://lpaste.net/new/haskell
17:55:34 <Audiblade> Thanks!
17:55:47 <pavonia> which is mentioned in the topic, btw
17:56:09 <Audiblade> so it is...
17:56:19 <ski> int-e : it appears the `where' state in lambdabot has disappeared (in the last few days) ?
17:56:41 <chrisdone> ski: it's because i'm running it
17:56:56 <chrisdone> the other lambdabot d/c'd after a server node went down
17:56:57 <Audiblade> all right
17:57:01 <chrisdone> didn't come back
17:57:03 <Audiblade> Thanks for your help!
17:57:09 <ski> chrisdone : oh, so this is just a temporary one ?
17:57:21 <zennist_> Newbie here. I have a list of [Either (M a)] How can I execute all the M a in side the Either and collect the results as M [Either a]?
17:57:30 <zennist_> M is a monad
17:57:33 <Iceland_jack> zennist_: that's a wrong type signature :)
17:57:53 <chrisdone> ski: possibly. i can run it permenantly if someone gets me the data files. this one is stable and fast
17:58:19 <zennist_> Iceland_jack: why...
17:58:24 <Iceland_jack> Either takes two arguments
17:58:50 <chrisdone> ski: i'm just looking at how lbot stores its @where state. i can technically generate a very large @where database from ircbrowses's 10 year logs
17:58:53 <zennist_> Oh sorry then I mean [Either (M a) (M a)]
17:59:09 <chrisdone> ski: (same for @quote, @karma, etc)
17:59:30 <Iceland_jack> this is a fairly strange thing to want to do imo
17:59:41 <scott_> Either (M a) (M a) seems like a weird type to use
17:59:42 <sipa> zennist_: that sounds equivalent to [(Bool, M a)]
18:00:04 <Iceland_jack> @ty mapM (either id id) -- zennist_
18:00:04 <lambdabot> Monad m => [Either (m b) (m b)] -> m [b]
18:00:10 <Iceland_jack> You probably want to do something else though
18:00:39 <Clint> you mean either Left Right?
18:00:58 <zennist_> Clint: yep
18:02:07 <chrisdone> @djinn These a b -> a
18:02:07 <lambdabot> Error: Undefined type These
18:03:30 <zennist_> Iceland_jack: doesn't your solution lost the Either information
18:03:53 <zennist_> Monad m => [Either (m b) (m b)] -> m [Either b]
18:03:56 <zennist_> to be precise
18:03:59 <Iceland_jack> zennist_: Yes it does, but it would be helpful if you told us what you're really trying to do
18:04:08 <Iceland_jack> This seems like an odd use of Either
18:04:31 <ski> @type sequence . map Data.Traversable.sequence :: Monad m => [Either e (m a)] -> m [Either e a]
18:04:35 <lambdabot> Monad m => [Either e (m a)] -> m [Either e a]
18:04:55 <pavonia> zennist_: That's why Clint suggested "either Left Right"
18:05:14 <Iceland_jack> @type mapM (either Left Right)
18:05:14 <lambdabot> [Either a b] -> Either a [b]
18:05:40 <zennist_> mhh, I'm working with XMonad and a module is using Either Left to represent the window is hidden or Right to represent the window is focused. It gives me back a list of (Either Window Window). I'd like to perform some monad on the Window while still retaining the information about whether the result is for a focused window or not
18:05:56 <scott_> Isn't either Left Right = id?
18:06:02 <ski> chrisdone : though i think some were added in other channels (like ##logic, e.g.)
18:06:12 <chrisdone> ski: true
18:06:19 <scott_> :t mapM id :: [Either a b] -> Either a [b]
18:06:19 <lambdabot> [Either a b] -> Either a [b]
18:06:21 <chrisdone> ski: for those i have no data
18:06:24 <geekosaur> zennist_, could you report that as a bug? it should really be using (Bool,Window) or something
18:06:32 <hpc> scott_: (either Left Right) will make your computer slightly warmer than id ;)
18:06:44 * hackagebot assert 0.0.1.2 - Helpers for Control.Exception.assert  http://hackage.haskell.org/package/assert-0.0.1.2 (LiyangHu)
18:06:44 <lambdabot> Title: Hackage: assert: Helpers for Control.Exception.assert
18:07:07 <geekosaur> https://code.google.com/p/xmonad/issues
18:07:28 <hpc> is lambdabot automatically titling links now?
18:07:41 <geekosaur> the real lambdabot is b0rked again
18:07:45 <geekosaur> this is a temporary replacement
18:07:56 <chrisdone> hpc: it's a default setting of lambdabot. i'll see if i can turn it off
18:08:01 <geekosaur> which apparently has url-title enabled
18:08:05 <hpc> weird
18:08:21 <chrisdone> it had it for years, it's only in the past couple years someone disabled it
18:08:45 <hpc> it could at least ignore hackagebot and hpaste
18:08:47 <kfish> liyang, i only just noticed your newtype Arse
18:08:51 <kfish> http://hackage.haskell.org/package/assert-0.0.1.1/docs/Control-Exception-Assert.html#t:Arse
18:08:52 <lambdabot> Title: Control.Exception.Assert, http://tinyurl.com/l94w8su
18:10:47 <liyang> kfish: thanks for noticing my Arse.
18:11:06 <chrisdone> lol
18:11:18 <ua> Kaczynski was born on May 22, 1942, in Evergreen Park, Illinois, to second-generation Polish Americans Wanda (ne Dombek) and Theodore Richard Kaczynski.
18:11:32 <ua> sorry wrong # lel
18:11:57 <kfish> liyang, it's Exceptional!
18:12:23 <pavonia> and fortunately it has a show instance
18:12:30 <chrisdone> @djinn-names
18:12:30 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool
18:12:30 <liyang> your powers of observation are puntastic.
18:13:09 <chrisdone> @djinn-add data These a b = This a | That b | These a b
18:13:31 <chrisdone> @djinn These a b -> a
18:13:31 <lambdabot> -- f cannot be realized.
18:13:42 <chrisdone> @djinn These a b -> Maybe a
18:13:42 <lambdabot> f a =
18:13:42 <lambdabot>     case a of
18:13:42 <lambdabot>     This b -> Just b
18:13:42 <lambdabot>     That _ -> Nothing
18:13:42 <lambdabot>     These c _ -> Just c
18:13:45 <chrisdone> cool
18:13:55 <chrisdone> i never knew you could add stuff to djinn in lambdabot
18:14:05 * chrisdone is reading through \bot's source
18:15:14 <Hodapp> huh, just discovered 'do notation considered harmful' and the like
18:21:13 <derdon> is the /quit command considered harmful as well? let's find out...
18:21:20 <chrisdone> no wait!
18:22:42 <ion> Everything considered harmful.
18:23:26 <liyang> 'xyz considered harmful' articles considered harmful.
18:23:44 <jle`> harmfulness considered harmful
18:23:48 <chrisdone> fix $ consideredHarmful
18:23:50 <liyang> Use your judgement.
18:24:08 <ion> chrisdone: Excess $ considered harmful.
18:24:08 <Hodapp> I see the reasoning behind it a bit.
18:24:24 <chrisdone> > fix (\x -> x ++ " considered harmful")
18:24:27 <lambdabot>   mueval-core: Time limit exceeded
18:25:29 <scott_> > fix ("considered harmful " ++)
18:25:30 <lambdabot>   "considered harmful considered harmful considered harmful considered harmfu...
18:25:38 <jle`> i'm never happy with my usage of $ and .'s.  f . g $ x vs f $ g x.  i feel like it depends on the context of the variables but i can never find myself being both self-consistent and looking readable.
18:25:40 <chrisdone> @get-shapr
18:25:40 <lambdabot> shapr!!
18:26:26 <lvella> mm_freak, I don't even know how to instance that Reader as Functor
18:26:27 <jle`> i go for readable when i can but them my code just "looks" inconsistent
18:26:33 <jle`> such troubles.
18:26:45 * hackagebot pipes-safe 2.0.1 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-2.0.1 (GabrielGonzalez)
18:26:46 <lambdabot> Title: Hackage: pipes-safe: Safety for the pipes ecosystem
18:26:49 <lvella> mm_freak, every attempt leads to syntax error
18:28:38 <shapr> chrisdone: you called?
18:28:46 <chrisdone> shapr: it still works!!
18:28:52 <shapr> yay!
18:28:56 <sdrodge> Anyone in the mood to help optimize an inner loop?
18:29:50 <sdrodge> http://lpaste.net/95835
18:33:13 <derekv> trying to do something based off this example https://github.com/xich/scotty/blob/master/examples/json.hs#L52-L56
18:34:04 <chrisdone> lol comment in \bot's Modules.hs
18:34:05 <chrisdone>                     -- these must be listed first.  Maybe.  Nobody really
18:34:06 <chrisdone>                     -- knows, but better to be safe than sorry.
18:34:36 <derekv> so I'm reading it as, jsonData is something that scotty has already turned into an object via Aeson, and the case syntax is determining what type of object it is
18:34:38 <geekosaur> sounds like lambdabot :p
18:36:39 <Cale> Gotta cult that cargo
18:37:37 <chrisdone> Cale =)
18:38:33 <lvella> hey guys, what do you know of the clean programming language?
18:38:57 <zennist_> for a list of tuples, say [(a, b)], how can I sort first by value of b and then by a
18:39:12 <pharaun> i got an airplane strip to sell you guys
18:39:39 <zardoz``> sortBy (compare . swap) xs
18:39:47 <chrisdone> :t swap
18:39:47 <lambdabot> (a, b) -> (b, a)
18:40:33 <zennist_> That's great! didn't think of that
18:41:21 <jmcarthur> :t compare . swap
18:41:22 <lambdabot> (Ord b, Ord a) => (a, b) -> (b, a) -> Ordering
18:41:45 <jmcarthur> that isn't right...
18:41:46 <zardoz``> actually I am not quite sure that will work
18:41:51 <jmcarthur> :t comparing swap
18:41:51 <lambdabot> (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
18:41:55 <jmcarthur> that's what you want
18:42:25 <triliyn> @src comparing
18:42:25 <lambdabot> Plugin `sourcePlugin' failed with: state not initialized
18:42:58 <jmcarthur> triliyn: comparing f = compare `on` f
18:43:09 <triliyn> jmcarthur: ahh, right, that makes sense
18:43:27 <derekv> so look at this type jsonData :: (A.FromJSON a) => ActionM a .... then somewhere else I "do v <- jsonData" , how does it get the type for v?
18:44:13 <jmcarthur> derekv: depends on how you use it
18:44:39 <derekv> there's an example here https://github.com/xich/scotty/blob/master/examples/json.hs#L52-L56
18:45:09 <jmcarthur> derekv: in that case, it sees that the patterns are Quux, Bar, and Baz, so it can determine the type from those
18:45:10 <zardoz``> mine did (\x y -> compare (swap x) y), right?  types were right, but semantics aren't
18:45:31 <jmcarthur> zardoz``: right
18:45:37 <jmcarthur> zardoz``: type wasn't right either, though
18:45:48 <jmcarthur> zardoz``: unless both components of the tuple are the same type
18:45:57 <zardoz``> yes true
18:46:00 <derekv> all I want to do instead is, I have an account object created with the Persistent dsl quasiquotes, and a 'put' endpoint, and for now i just want to store it in the table
18:46:38 <derekv> jmcarthur: so in reality does it just try to parse it each way at that point?
18:47:11 <jmcarthur> derekv: not sure what you are asking. the type checker doesn't have the luxury of delaying until runtime, so it can't just try a bunch of ways of parsing
18:47:28 <jmcarthur> derekv: it just determines the type based on how it's used, in this case
18:48:23 <jmcarthur> derekv: when you look at the code, how can *you* tell what the type should be?
18:49:29 <derekv> jmcarthur: ok wait i was confusing myself, data Foo is just one type.  its not like Bar is a different type from Foo
18:49:51 <jmcarthur> derekv: yeah, all the constructors have to produce the same type
18:50:02 <jmcarthur> *values of the same type
18:50:13 <derekv> yep I see it now
18:50:30 <Rylee>     Rylee | @src return
18:50:31 <Rylee> lambdabot | Plugin `sourcePlugin' failed with: state not initialized
18:50:34 <Rylee> all of my tears
18:51:13 <scott_> You can't get the source of return like that without a specific instance anyways
18:51:25 <scott_> But it does suck that lambdabot's not working :P
18:51:30 <geekosaur> someone else was complaining about that the other day
18:51:42 <chrisdone> oh, hum
18:51:59 <scott_> I ripped the @src database out of lambdabot and got it working in my ghci
18:52:15 <geekosaur> at some point I should probably try to build it locally and then dtruss to see where it's actually looking for the database or something
18:53:38 <chrisdone> the source file is in State/, i wonder why it's not initializing
18:55:43 <derekv> so in my case I don't have different constructors, how can I tell it that I want an Account object? http://lpaste.net/5234305484340592640
18:56:28 <derekv> This is almost my first time writing anything in haskell so thanks for the help =]
18:59:42 <copumpkin> int-e: looks like @src is b0rked
19:00:05 <copumpkin> int-e: you might also want to update the ident on lambdabot to indicate that you run it, to make it easier to report weirdness to you
19:00:30 <chrisdone> copumpkin: actually i'm running it. int-e's went MIA
19:00:36 <copumpkin> oh!
19:00:53 <chrisdone> i think i'll update to mokus's version, might fix this weirdness
19:00:59 <copumpkin> cool
19:01:07 <copumpkin> does the ident suggestion make sense to you?
19:01:11 <zardoz``> I am trying to wrap my hand around why second argument in `on :: (b -> b -> c) -> (a -> b) -> (a -> a -> c)'  is `(a -> b) instead of `(b -> a). can someone explain?
19:01:13 <copumpkin> not sure how you convince it to report that you own it
19:01:29 <zardoz``> my head :)
19:02:01 <zardoz``> I got the definition right, but not types.  myon f g = \x y -> f (g x) (g y)
19:02:02 <copumpkin> zardoz``: it takes the a you pass in, applies the a -> b to it, and passes the result into the function taking b
19:02:17 <chrisdone> copumpkin: i could put chrisdone in the user field?
19:02:33 <copumpkin> if that's easy to do, it might make it easier to bug you :) not sure you want that :P
19:03:35 <derekv> ah figured it out finally
19:03:47 <chrisdone> huh, mokus's version is really separated. not sure what to install
19:03:58 <derekv> (account :: Account) will tell it what type i wanted
19:04:26 <chrisdone> https://github.com/mokus0/lambdabot ← wha??
19:05:42 * geekosaur digs for his old lambdabot config
19:06:20 <geekosaur> ...erp. looks like I only saved State/
19:06:27 <pharaun> its amazing, i'm starting to understand applicative
19:06:28 <chrisdone> ah, the main project is lambdabot/ that depends on the others
19:06:40 <pharaun> i've *used* it tons but i'm now starting to get good feeling of it
19:07:42 <geekosaur> ah, right. the last parameter in the irc-connect command is what you want to change
19:08:03 <chrisdone> cabal install `*/*.cabal` did the trick
19:08:20 <chrisdone> geekosaur: sure. it's currently connecting through my irc bouncer, tho, so i can just change that
19:09:14 <scott_> Two nicks beginning with "chrisdo" this is a tab completion nightmare
19:09:26 <scott_> :P
19:09:35 <chrisdone> i got here first =p
19:10:01 <chrisdone> hold on, need to patch lbot to support sending PASS to the server again
19:12:02 <derekv> the indentation in haskell-mode doesn't seem to do anything like what I see in people's code
19:12:42 <carter> pharaun: applicative is cool
19:12:42 <chrisdone> there are several indentation modes in haskell-mode
19:12:50 <carter> also was only invented / discovered in the past 5years
19:14:23 <stolaruk> I'm a relatively new Haskell programmer. I recently found that I was able to refactor a lot of my do blocks into >>= chains. Is is considered good style to chain binds instead of do when you can?
19:15:21 <chrisdone> depends on the code
19:15:24 <sclv> tastes vary
19:15:33 <sclv> if you can do so without explicit lambdas then that can be quite nice
19:15:46 <stolaruk> sclv: Yeah I'm avoiding lambdas
19:15:58 <scott_> stolaruk: do blocks can *always* be written as >>= chains, they are just a shorthand
19:16:08 <sclv> certainly its recommended to use applicative style over do monadic combinators where possible
19:16:53 <stolaruk> scott_: I guess what I meant was I found I could refactor some of my do blocks into >>= without having to use explicit lambdas. But some of the bind chains are long, which left me wondering about readability/style preferences
19:17:21 <stolaruk> sclv: you mean <$> and <*> ?
19:17:24 <carter> yup
19:18:02 <stolaruk> Yeah I should go back and see where I can use applicative style
19:19:17 <stolaruk> BTW I also started using the "maybe" combinator and I wrote this little function:
19:19:18 <stolaruk> onJust = maybe (return ())
19:19:30 <stolaruk> Is this a common idiom?
19:19:35 <chrisdone> @src fst
19:19:39 <lambdabot> fst (x,_) =  x
19:19:41 <chrisdone> yay
19:19:45 <copumpkin> whee!
19:19:48 * copumpkin hugs chrisdone 
19:19:51 <chrisdone> \o/
19:20:11 <chrisdone> @djinn worky -> worky
19:20:15 <lambdabot> f a = a
19:20:20 <chrisdone> mmk
19:20:23 * chrisdone installs hoogle
19:21:01 <pharaun> what happened to lambdabot?
19:21:30 <enthropy> stolaruk: that's called Data.Foldable.traverse_
19:22:08 <stolaruk> enthropy: ok cool I guess I should use that then ;)
19:22:12 <chrisdone> pharaun: got d/c'd on a freenode node dying and didn't come back. i started one up on my dedicated host
19:22:23 <chrisdone> @hoogle isAlpha
19:22:23 <lambdabot> Data.Char isAlpha :: Char -> Bool
19:22:23 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
19:22:27 <chrisdone> woot
19:23:17 <stolaruk> enthropy: Thanks I appreciate it.
19:23:39 <zardoz``> could >>= for list monad have been implemented as just map instead of concatMap? if not why not?
19:23:48 <copumpkin> type doesn't fit
19:23:53 <copumpkin> :t (>>=)
19:23:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:23:59 <copumpkin> :t flip concatMap
19:24:00 <lambdabot> [a] -> (a -> [b]) -> [b]
19:24:09 <copumpkin> :t flip map
19:24:09 <lambdabot> [a] -> (a -> b) -> [b]
19:24:27 <levi> stolaruk: Opinions vary on stylistic things. Some prefer concise code, while others prefer 'obvious' code.
19:24:32 <zardoz``> [a] -> (a -> [b]) -> [b], with b being []?
19:24:54 <scott_> You'd end up with [a] -> (a -> [b]) -> [[b]]
19:25:06 <pharaun> chrisdone: ah
19:25:12 <stolaruk> levi: I am continually amazed at how concise Haskell code can be
19:25:38 <pharaun> i enjoy reducing verbose code to something that is quite concise and after a little thinking, still readable
19:25:41 <levi> Some people write a lot of point-free code, others introduce pointed functions for clarity even when the point-free code is fairly straightforward.
19:25:54 <pharaun> char '.' *> ((,) <$> ((Just <$> numParse) <|> (pure Nothing)) <*> textParse)
19:26:15 <levi> Some people even like to use explicit {} and ; in do notation. And slides in Comic Sans.
19:26:18 <zardoz``> oh right, because map would turn each a into a [b], resulting in [[b]]
19:26:19 <pharaun> probably could be done better
19:26:48 <stolaruk> pharaun: I was just reading in RWH today about striking a balance btwn "density" and readability, which naturally makes sense
19:26:51 <pharaun> too many parens :) and oh could use optional as well
19:27:00 <pharaun> stolaruk: yup
19:27:53 <stolaruk> oh hey is there any bk I should really read after LYAH and RWH? I also own Parallel and Concurrent Prog in H and will get to that. Wife is ordering something form Amazon and if I throw a book in the order we can get free shipping ;)
19:28:21 <pharaun> and that expression ^ just reduced again to - char '.' *> ((,) <$> optionMaybe numParse <*> textParse)
19:28:31 <levi> Anyway, I wouldn't take responses that you get from one query about style on #haskell as anywhere near representative of actual consensus on things.
19:28:35 <pharaun> which is *even* more concise and more readable!
19:29:15 <pharaun> anyway yeah what levi said, there's a wide range of style, best way to to just look through code you like
19:29:23 <pharaun> and adopt that style or some such
19:29:58 <stolaruk> well I really do appreciate the feedback.
19:30:28 <pharaun> stolaruk: for me there is a thin line between a concise and readable code and one that should be expanded to be readable
19:30:54 <pharaun> ie my 2 example, first version is a little tricky (too many ())'s while the second one is much more readable and still even more concise
19:31:15 <derekv> really? Process haskell segmentation fault: 11?
19:31:18 <levi> While you're learning, it's better to get something written and working than to spend a lot of time fretting over style. I mean, you might try transforming your code to different styles as an exercise, but reading and writing lots of code is the best way to arrive at a reasonble style.
19:31:24 <pharaun> ^
19:31:36 <pharaun> often when i am first exploring i'll do lots of case/if/else/do etc...
19:31:44 <pharaun> then once i feel like i understand i start to clean and reduce
19:32:18 <stolaruk> levi: Yes, I could be reading more code but I've been writing a lot lately, and I've learned a ton
19:32:42 <pharaun> stolaruk: i like reading library code when i am using it so i can understand how some of it works
19:32:50 <pharaun> some.... are scary but some are quite readable and nice
19:33:20 <stolaruk> pharaun: Yeah I've found not all HAskell libraries are well documented, too
19:33:27 <levi> Neither the reading nor the writing alone are sufficient; gotta strike a balance that exposes you to good code an also gets you writing good code.
19:33:35 <mikeplus32> anyone know how to get a TypeQ from an expression at compile-time? i mean, something like: getType :: a -> TypeQ; getType (_ :: a) = [t| $a |]
19:33:39 <mikeplus32> but working
19:34:33 <chrisdone> copumpkin: k, now the ident est moi
19:37:25 <intrados> Anyone know how to fix a linker error during template Haskell profiling compilation? (/usr/bin/ld: cannot find -lHStransformers-compat-0.1.1.1_p)
19:40:01 <stolaruk> Is there a way to execute a shell cmd from within a Haskell program and grab it's output to stdout? I want something like "rawSystem" but I would like it to return "IO String" where the String is whatever the external program wrote to the screen.
19:40:31 <Iceland_jack> stolaruk: Check outSystem.Process
19:40:40 <stolaruk> ok cool
19:40:54 <Iceland_jack> @hoogle readProcess
19:40:55 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
19:40:55 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
19:41:02 <Iceland_jack> stolaruk: ↑
19:41:19 <stolaruk> looks perfect, thanks
19:41:33 <Iceland_jack> Pre> readProcess "date" [] ""
19:41:34 <Iceland_jack> "m\225n n\243v 18 04:24:50 CET 2013\n"
19:41:49 <chrisdone> note that readProcess actually launches the process
19:42:01 <chrisdone> if you want to execute a shell command you should use the shell function with createProcess
19:42:40 <chrisdone> readProcess "help" won't give anything, for example
19:42:42 <geekosaur> well, there's always readProcess "sh" ["-c", "shell command here"]
19:43:08 <stolaruk> chrisdone: I'm looking to execute uptime on a Mac or Linux machine
19:43:11 <chrisdone> sure,  tho that's shell-specific then
19:43:20 <chrisdone> stolaruk: ah then readProcess is fine
19:43:21 <stolaruk> oh ok
19:43:50 <geekosaur> enh. getEnv "SHELL" >>= \sh -> readProcess sh ["-c", "shell command here"] "" -- :p
19:43:52 <stolaruk> Yeah looks like an actual cmd here: /usr/bin/uptime
19:44:10 <geekosaur> with some extra stuff in case it's not defined (use /bin/sh) of course
19:44:43 <stolaruk> geekosaur: that's cool too
19:45:06 <chrisdone> i think `shell' is best because it's cross-platform
19:45:42 <chrisdone> the readProcess thing seems a awkward API
19:45:52 <chrisdone> @hoogle createProcess
19:45:52 <lambdabot> System.Process createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
19:45:52 <lambdabot> System.Posix.Process.ByteString createProcessGroup :: ProcessID -> IO ProcessGroupID
19:45:52 <lambdabot> System.Posix.Process createProcessGroup :: ProcessID -> IO ProcessGroupID
19:45:54 <chrisdone> ^ that's good
19:45:59 <geekosaur> I think it predates createProcess
19:46:02 <chrisdone> but there should be a readProcess :: CreateProcess -> IO String
19:46:18 <chrisdone> and then you could readProcess (shell "foo")
19:47:04 <geekosaur> runProcess is the same generation as readProcess, IIRC, and gives you some idea of how the interface has evolved
19:48:21 <chrisdone> nod, i remember when it changed to the createProcess stuff and i was all omgwtf
19:48:45 <carter> what are we talking about?
19:49:04 <chrisdone> hmm actually
19:49:05 <chrisdone> http://hackage.haskell.org/package/process-1.0.0.0/docs/System-Process.html
19:49:16 <lambdabot> Title: System.Process, http://tinyurl.com/mwt8324
19:49:19 <carter> http://hackage.haskell.org/package/process-1.1.0.2/docs/System-Cmd.html
19:49:20 <carter> ?
19:49:20 <lambdabot> Title: System.Cmd, http://tinyurl.com/npr4zkf
19:49:23 <chrisdone> readProcess doesn't actually predate createProcess
19:49:24 <Tekmo> carter: We're talking about how much harder it is to run shell commands in Haskell
19:49:34 <Tekmo> I kid!  I know about shelly
19:49:39 <carter> why doesn't rawSystem work?
19:49:56 <geekosaur> they wanted to capture the output as well
19:49:58 <carter> ooh
19:50:03 <carter> i did someting for that recently
19:50:24 <stolaruk> carter: I want to do this:
19:50:25 <chrisdone> so readProcess is actually just a bad non-legacy api
19:50:25 <stolaruk> getEnv "SHELL" >>= \sh -> readProcess sh ["-c", "uptime"] ""
19:50:51 <carter> readProcessWithExitCode is pretty nice
19:51:23 <carter> ok
19:51:23 <geekosaur> no, you probably want the first one I gave you, that was a response to chrisdone
19:51:59 <chrisdone> readProcess as-is should be fine?
19:52:00 <geekosaur> and it's not really "production ready" since the non-POSIX getEnv throws an exception for an unknown envar whereas we want to substitute "/bin/sh" in that case
19:52:07 <stolaruk> oh
19:52:16 <chrisdone> uptime is a binary, it shouldn't require a shell?
19:52:21 <geekosaur> but you don;t need a shell here so just use readProcess "/usr/bin/uptime" [] ""
19:52:27 <stolaruk> ok yeah
19:52:46 <chrisdone> even without /usr/bin/ should be ok
19:52:51 <chrisdone> i think readProcess uses findExecutable
19:52:55 * chrisdone checks
19:53:09 <chrisdone> yeah
19:53:12 <stolaruk> yes w/out the path in GHCi it's working
19:53:50 <chrisdone> -- * on Unix systems the @execvp@ semantics is used, where if the
19:53:51 <chrisdone> --   filename does not contain a slash (@/@) then the @PATH@
19:53:51 <chrisdone> --   environment variable is searched for the executable.
20:24:01 <carter> chrisdone: which channels is lambdabot  on?
20:24:32 <carter> could you add #haskell-llvm ?
20:24:44 <carter> (i may have 1-2 other such requests soon)
20:38:31 <pharaun> is there a list of other #haskell-* channels?
20:38:41 <carter> yes
20:38:42 <carter> on the wiki
20:38:48 <carter> *haskell*
20:38:52 <pharaun> k checking
20:47:00 <cschneid> how do I get the requirements of a typeclass in ghci? ie, "what do I need for implementing Eq"
20:47:22 <carter> :info Eq
20:47:43 <carter> cschneid: also read the haddocks
20:47:57 <cschneid> info eq seems to just dump instances of it?
20:48:01 <carter> scroll up"
20:48:05 <cschneid> ahh, of course :)
20:48:06 <cschneid> thanks
20:49:19 <carter> also read the haddocks
20:51:58 * hackagebot clckwrks 0.20.0 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.20.0 (JeremyShaw)
20:52:01 * hackagebot clckwrks-cli 0.2.9 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.9 (JeremyShaw)
20:52:02 * hackagebot clckwrks-theme-clckwrks 0.3.14 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-clckwrks-0.3.14 (JeremyShaw)
20:52:04 <lambdabot> Title: Hackage: clckwrks: A secure, reliable content management system (CMS) and blo...
20:52:05 * hackagebot clckwrks-theme-bootstrap 0.2.14 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.2.14 (JeremyShaw)
20:52:07 * hackagebot clckwrks-plugin-page 0.2.6 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.2.6 (JeremyShaw)
20:52:09 <lambdabot> Title: Hackage: clckwrks-cli: a command-line interface for adminstrating some aspect...
20:52:17 <thirsteh> I have a package with an error (not importing 'catch' from Control.Exception). I cloned the repo and fixed the error. Is there an easy way for me to use this modified one as the original in my binary that depends on it? (In a cabal sandbox.) I tried installing it, then installing my own, but it just tries to configure and compile the original
20:53:58 <carter> thirsteh: type cabal sandbox help
20:53:58 <carter> :)
20:54:27 <thirsteh> carter: cabal: Unknown 'sandbox' subcommand: help
20:54:37 <thirsteh> and I have a feelign that wouldn't answer my question either
20:54:39 <carter> thirsteh: "cabal update; cabal install cabal-install"
20:54:40 <carter> :)
20:54:41 <thirsteh> I've read all the docs for cabal install
20:55:15 <thirsteh> carter: Are you sure that's an actual command?
20:55:25 <carter> thirsteh: do the things i tell you
20:55:25 <thirsteh> I already have a recent version of Cabal with the sandbox
20:55:27 <carter> you don
20:55:33 <carter> cabal hehrm
20:55:36 <carter> hangon
20:55:45 <carter> cabal help sandbox
20:56:13 <thirsteh> so you want me to use add-source?
20:56:18 <carter> yeah
20:56:20 <thirsteh> why not just answer the question instead of speaking in riddles? :)
20:56:24 <thirsteh> ok, thanks
20:56:27 <carter> because i don't remember the command
20:56:33 <carter> and this way you know how to find it :)
20:56:42 <carter> show don't tell :)
20:57:08 * hackagebot clckwrks-plugin-media 0.6.2 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.2 (JeremyShaw)
20:57:09 <lambdabot> Title: Hackage: clckwrks-plugin-media: media plugin for clckwrks, http://tinyurl.com/osvuccr
20:57:10 * hackagebot clckwrks-plugin-bugs 0.6.4 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.6.4 (JeremyShaw)
20:57:13 * hackagebot clckwrks-dot-com 0.3.4 - clckwrks.com  http://hackage.haskell.org/package/clckwrks-dot-com-0.3.4 (JeremyShaw)
20:57:13 <lambdabot> Title: Hackage: clckwrks-dot-com: clckwrks.com
20:57:15 <lambdabot> Title: Hackage: clckwrks-plugin-bugs: bug tracking plugin for clckwrks, http://tinyurl.com/naa6sad
20:57:32 <pharaun> s/[:vowels:]//gc
20:58:00 <thirsteh> carter: that solved the problem I was having. thanks
20:58:04 <carter> thirsteh: np
21:03:18 <pavonia> @pl \x f -> f x
21:03:18 <lambdabot> flip id
21:04:32 <carter> @pl  (a->b)->b
21:04:32 <lambdabot> (line 1, column 5):
21:04:32 <lambdabot> unexpected '>'
21:04:32 <lambdabot> expecting operator
21:04:44 <carter> umm
21:04:59 <carter> @djinn (a->b)->b
21:04:59 <lambdabot> -- f cannot be realized.
21:20:50 <thirsteh> carter: not sure why, but it says "an add-source package has changed" and reconfigures it every time
21:20:58 <carter> i know nothing
21:21:00 <carter> :)
21:32:47 <pavonia> What's the proper way of parsing partial contents of a file using Parsec? I'm using readFile and if my parser consumes the whole file contents, the file gets closed. But if the parser fails, the file seems to be still open for some time.
21:45:35 <derekv> so i really can't make much of this, it like, almost works but... i when i'm declaring an endpoint for scotty i'm working on an "Action" monad, then when I try to do stuff with Persistent based of examples, those are taking place on an IO monad
21:45:44 <derekv> and i don't know how to bridge the two
21:48:56 <thirsteh> derekv: You're looking for liftIO, e.g. liftIO someIOAction
21:49:23 <thirsteh> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
21:50:04 <thirsteh> there's also a liftIO in the mtl package
21:50:45 <Audiblade> Hello! I have a quick question
21:50:54 <Audiblade> I have a tuple of (Int, Int).
21:51:07 <Audiblade> Is there a quick, idiomatic way to cast it to a tuple of (Num, Num)?
21:51:34 <thirsteh> Audiblade: those are typeclasses, not types. What are you trying to do?
21:51:56 <thirsteh> (Int, Int) already is a "(Num, Num)" -- there is a Num instance for type Int
21:53:33 <Audiblade> I'm typing up a code snippet to demo my problem...
21:53:58 <lpaste> Audiblade pasted “Problem with casting tuples” at http://lpaste.net/95839
21:54:44 <thirsteh> Audiblade: change "-> Num" to "-> Int" in doAThingWithInts
21:55:40 <derekv> thirsteh: liftIO is working everywhere but the trouble spot... so probably the monad type isn't the problem
21:55:56 <thirsteh> distanceBetweenPoints takes any value that has an instance of Num as the type 'a', so when you call it with your int tuples it "becomes" (Int, Int) -> (Int, Int) -> Int. The result is still an int
21:56:05 <Audiblade> ok
21:56:15 <Audiblade> I want to to return a float
21:56:22 <scott_> Audiblade: distanceBetweenPoints needs (Floating a) => instead of (Num a) => because of its use of sqrt
21:56:24 <scott_> :t sqrt
21:56:24 <lambdabot> Floating a => a -> a
21:56:37 <scott_> All Floating types are also Num, but not the other way around
21:56:44 <Audiblade> Let me play around with it a bit more, then ask again once I know what I'm going better
21:57:19 <thirsteh> what scott_ said. You probably want to change the type constraints of distanceBetweenPoints and do "fromIntegral n" on the numbers to turn them into floats
21:57:43 <thirsteh> or use e.g. Double from the beginning
21:58:53 <lpaste> Audiblade revised “Problem with casting tuples”: “No title” at http://lpaste.net/95839
21:59:24 <Audiblade> Now I'm being more clear that I want a Float from distanceBetweenPoints
21:59:45 <Audiblade> and I tried to write a function fromIntTup to convert the tuples for me
21:59:54 <Audiblade> it fails with this compile error:
22:00:30 <thirsteh> Can you do: http://lpaste.net/95839 ?
22:00:32 <lpaste> Audiblade pasted “Compile error for fromIntTup” at http://lpaste.net/95841
22:01:04 <Audiblade> Unfortunately, I'm stuck starting from (Int, Int)
22:01:12 <thirsteh> Audiblade: Int is not a typeclass. You probably meant to write Num
22:01:31 <thirsteh> in the type constraints for fromIntTup
22:01:48 <Audiblade> I'm very new, so I'm not sure what the difference between a type and a type class is
22:02:15 <Audiblade> kk
22:02:26 <Audiblade> did some reading on them
22:02:34 <thirsteh> :t fromIntegral
22:02:34 <lambdabot> (Integral a, Num b) => a -> b
22:02:45 <derekv> trying to use replace :: PersistEntity val => Key val -> val -> m ()   but whatever I feed it for the first parameter (key) the compiler comlains..
22:02:49 <thirsteh> so it should be Integral b
22:03:07 <Audiblade> why does it make a difference that my functions' definitions use types instead of typeclasses?
22:03:18 <derekv> unfortunatly i have to give up
22:03:49 <thirsteh> Audiblade: they're just two completely different things. Typeclasses are like interfaces, types are types
22:03:57 <dita> anda bermasalah dengan kartu kredit/KTA?? Kami bantu dibebas bayarkan hub. Dita 02190409949
22:04:02 <Audiblade> ok
22:04:07 <thirsteh> Audiblade: typeclasses are what's before the =>. Conditions that some types (specified after the =>) must satisfy
22:04:16 <Audiblade> okl
22:04:18 <thirsteh> "interfaces" they must implement
22:04:18 <Audiblade> * ok
22:04:22 <Audiblade> that makes much more sense
22:04:25 <Audiblade> thank you!
22:04:43 <thirsteh> If you change "Int b" in the beginning of fromIntTup to Integral b, I think it'll work
22:04:48 <scott_> Some examples of types satisfying the Num "interface" are Int and Double
22:04:53 <Audiblade> Yep
22:05:03 <Audiblade> I made that change, and it compiled and worked as expected
22:05:04 <scott_> So a function like (+) has type Num a => a -> a -> a so it works for both Ints and Doubles
22:05:31 <scott_> (In fact there are different versions of (+) for each of them)
22:06:03 <thirsteh> derekv: What's the error?
22:06:15 <Platz> scott_: why are there different versions of (+) ?
22:06:52 <thirsteh> addition for Int is different than for Int64, Double, uints, and so on
22:07:05 <Platz> ahh, makes sense
22:07:18 <scott_> Platz: Each Num instance declaration has to provide an implementation of (+), e.g. instance Num Int where x + y = 
22:08:07 <Platz> ahh yeah, forgot Num was a typeclass for a sec
22:17:05 <derekv> thirsteh:  Couldn't match expected type `Key Account' with actual type `()'
22:17:05 <derekv>     Expected type: ActionM (Key Account)
22:17:10 <derekv>       Actual type: ActionM ()
22:17:17 <derekv> sorry for multiline paste
22:17:42 <kakos> Is it possible to have an ADT that contains a type rather than a value?
22:19:07 <thirsteh> derekv: can you paste a snippet of the code on http://lpaste.net/? Sounds like you need to insert some parantheses or $
22:19:50 <apples> kakos, maybe a phantom type?
22:20:14 <derekv> http://lpaste.net/5234305484340592640
22:20:39 <derekv> line 54
22:21:18 <bergmark> derekv: insert returns the key
22:21:37 <arkeet> :t void
22:21:38 <lambdabot> Functor f => f a -> f ()
22:21:46 <arkeet> use this ↑
22:21:49 <bergmark> i think there's insert_ as well
22:21:56 <arkeet> or that
22:22:06 <arkeet> also, you can (and maybe should) put the liftIO . runDb outside the case
22:22:21 <thirsteh> derekv: you can change the whole "exists" to "liftIO $ do { case exists of ... }. That way you don't have to lift all the rest
22:23:06 <kakos> apples: Don't think that gets me what I need.
22:23:09 <thirsteh> Like arkeet said it's probably not related to liftIO, but that you're not discarding the result from the commands. You can do that with "void"
22:23:11 <thirsteh> :t void
22:23:11 <lambdabot> Functor f => f a -> f ()
22:23:24 <derekv> yea the whole thing with runDb and liftIO has to be doable some other way, if I look at the examples for persistence i don't see any of that junk
22:23:57 <thirsteh> derekv: you're liftIO'ing to get into the IO monad from the ActionM monad
22:24:20 <thirsteh> you only have to lift once to run a big section of code in IO, unless you want to use ActionM actions like "jsonData"
22:24:23 <bergmark> derekv: the error is kind of reversed, it infers the return type of case from the first branch, but you probably expected it to not return anything
22:24:37 <lpaste> arkeet annotated “No title” with “No title (annotation)” at http://lpaste.net/5234305484340592640#a95843
22:24:39 <arkeet> ↑
22:24:43 <derekv> hmm
22:24:56 <derekv> ok let me see...
22:25:31 <bergmark> yeah what arkeet did is good, then you can pull that out into a separate function that is just a db action
22:26:51 <Audiblade> I'm still having problems casting my tuples
22:26:53 <apples> kakos, how's that? data X a = X; then you can have a value X :: X Int, X :: X String, etc. without any corresponding value
22:26:59 <Audiblade> I have this code:
22:27:12 <lpaste> Audiblade pasted “Type issues” at http://lpaste.net/95844
22:27:24 <Audiblade> which, when compiled, gives me this error:
22:27:25 <apples> (other than X, of course)
22:27:39 <derekv> so your all saying the type error on the replace function actually has to do with the return type on the first branch for the case?
22:27:49 <kakos> apples: Hmmm. Actually, maybe that will work.
22:27:53 <lpaste> Audiblade pasted “Comile error” at http://lpaste.net/95845
22:28:19 <derekv> moving the liftIO outside the case doesn't help the error
22:29:26 <Audiblade> Shouldn't the fromIntTup function ensure that the tuples are instances of Floating before they're passed into distanceBetweenPoints, preventing the conflict?
22:29:50 <derekv> nor does changing it to Control.Monad.void
22:30:22 <arkeet> my paste did two different things.
22:30:56 <derekv> well if only insert returns Key and you need key for replace then replace is sortof useless, how often do you need to replace in the same transation that you inserted?
22:31:07 <arkeet> ??
22:31:12 <arkeet> who is doing that?
22:31:45 <arkeet> you can hold onto a key for longer than one transaction...
22:32:46 <derekv> arkeet: I mean to say, more then one web request, like... nevermind i can use update
22:32:49 <scott_> Audiblade: Strange, that code seems to work for me
22:32:56 <derekv> what i really wanted was idempotent insert
22:33:11 <Audiblade> I've been playing with it in ghci and gotten similar cases to work for me, too
22:33:16 <Audiblade> but it won't work in my program...
22:33:31 <arkeet> Audiblade: I think you might be getting bitten by the monomorphism restriction.
22:33:39 <arkeet> try giving minDistance a type signature?
22:34:13 <scott_> minDistance :: Double for me, and that works
22:34:22 <arkeet> hm
22:34:27 * arkeet looks at the code.
22:35:41 <derekv> gtg thanks. I should be happy to have something working at least.
22:35:52 <arkeet> Audiblade: you sure oldPosition and p2 are pairs of Ints?
22:36:09 <Audiblade> Pretty sure
22:36:18 <Audiblade> oldPosition is for sure
22:36:33 <arkeet> urgh that wouldn't be it either.
22:36:38 <Audiblade> potentialPositions is defined as
22:36:43 <Audiblade>     (oldY, oldX) = oldPosition
22:36:44 <Audiblade>     (pacX, pacY) = pacPosition
22:36:45 <Audiblade>     potentialPositions = [(oldY - 1, oldX), (oldY, oldX + 1), (oldY + 1, oldX), (oldY, oldX - 1)]
22:36:53 <Audiblade> (paxPosition is also an (Int, Int))
22:36:53 <arkeet> ok I have no idea why that wouldn't work then.
22:39:07 <Audiblade> I worked around it with this:
22:39:10 <lpaste> Audiblade pasted “Workaround” at http://lpaste.net/95846
22:41:26 <scott_> Audiblade: Actually you can just write: distanceBetweenPoints (y1, x1) (y2, x2) = sqrt (fromIntegral ((x2 - x1)^2 + (y2 - y1)^2))
22:41:42 <Audiblade> oh! good point
22:41:58 <kakos> apples: *kiss* This actually looks to be just waht I was looking for
22:41:59 <scott_> And the most general type is (Integral a, Floating b) => (a, a) -> (a, a) -> b
22:42:29 <apples> kakos, cool :)
22:56:19 <derekv> you were all right about the void
22:56:21 <derekv> using void
22:56:26 <derekv> :t void
22:56:26 <lambdabot> Functor f => f a -> f ()
22:56:51 <derekv> but it took me a long time to see where to put it and why.
22:57:50 <derekv> one of the biggest challenges if your switching to a whole new language is learning to read the compiler/runtime errors
23:12:09 <chrisirc> Can methods be inherited in Haskell?
23:12:30 <arkeet> what's a method?
23:12:55 <chrisirc> I'd like to write a derivative type, that has all the same methods as the normal one, but is used under certain constraints.
23:13:10 <arkeet> what's a method?
23:13:19 <arkeet> also, if you're learning haskell, it's best to leave all your OOP notions behind.
23:13:23 <chrisirc> A method like "instance Shape Point where points p = [p]"
23:13:35 <ski> a method is an operation in a type class
23:13:43 <chrisirc> yep
23:13:52 <ski> (or maybe a specific implementation of it, for a specific instance of the type class ?)
23:14:07 <arkeet> the former.
23:14:24 <arkeet> haskell has no notion of inheritance.
23:14:43 <chrisirc> ah deriving, of course
23:14:54 <ski> chrisirc : "a derivative type, that has all the same methods as the normal one", types don't really "have" methods, type classes (or maybe instances of them) do
23:15:20 <arkeet> or subtyping.
23:15:22 <ski> (and `deriving' is another thing)
23:16:29 <arkeet> (except for the one you get by specialization of polymorphic types, I suppose.)
23:18:22 <ski> "haskell has no notion of inheritance" -- yes and no (depending on what one means)
23:19:02 <ski> in OO, one sometimes distinguishes between "implementation inheritance" and "interface inheritance"
23:19:09 <ski> Haskell definitely hasn't got the former
23:21:13 <ski> however, interface inheritance is typically coupled to a single type, such that (a specific set of implementations for) the operations in the interface get an implicit input of the type in question
23:21:30 <ski> in type classes, this doesn't happen
23:22:04 <ski> but one could perhaps describe extension of a type class as "interface inheritance" anyway
23:23:51 <ski> then, there's also another thing where you can simulate some aspects of (more OO-like) interfaces by using a record of "methods", which may or mayn't imperatively access and update some hidden "instance variables", using some kind of state monad, e.g.
23:24:29 <ski> here, "interface inheritance" would correspond to subtyping for records
23:24:34 <ski> (which Haskell doesn't have)
23:24:50 <ski> (OCaml has something like that, though)
23:25:29 <zRecursive> It is better to think in FP way not OOP way
23:25:58 * ski think universal instantiation is another kind of thing
23:26:18 <ski> zRecursive : i was mostly looking at some OO concepts from an FP POV here :)
23:26:23 <ski> chrisirc : sufficiently confused, yet ?
23:26:43 <lieven_> could you emulate CLOS style multimethods?
23:27:56 <ski> i haven't looked in much detail at CLOS multimethods, but i think they're a different kind of thing
23:35:42 <jxv> Is there an function with a type signature of "Monad m => (t -> m ()) -> Maybe t -> m ()", where (t -> m ()) is typically (t -> IO ())?
23:36:30 <simpson> jxv: Not that I know of, although it would be easy to build. (I, too, have desired such a combinator.)
23:36:59 <simpson> :t \f ma -> case ma of { Nothing -> return (); Just a -> f a }
23:36:59 <lambdabot> Monad m => (t -> m ()) -> Maybe t -> m ()
23:37:07 <jxv> yup
23:37:15 <arkeet> :t maybe (return Nothing)
23:37:15 <lambdabot> Monad m => (a -> m (Maybe a1)) -> Maybe a -> m (Maybe a1)
23:37:19 <arkeet> er.
23:37:25 <scott_> Data.Foldable.mapM_ has (a more general version of) that type
23:37:37 <arkeet> oh yeah that's mapM_.
23:37:44 <jxv> :t mapM_
23:37:45 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
23:37:52 <scott_> :t Data.Foldable.mapM_
23:37:52 <lambdabot> (Monad m, Data.Foldable.Foldable t) => (a -> m b) -> t a -> m ()
23:37:56 <jxv> ah
23:38:01 <arkeet> :t maybe (return ())
23:38:01 <scott_> And Maybe is an instance of Foldable
23:38:01 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
23:38:10 <jxv> scott_, just what I need
23:38:18 <arkeet> mapM_ is the nicer thing to use yes
23:38:32 <arkeet> :t Data.Foldable.traverse_
23:38:32 <lambdabot> (Applicative f, Data.Foldable.Foldable t) => (a -> f b) -> t a -> f ()
