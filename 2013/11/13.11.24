00:09:08 <lasticot> hi, everyone!
00:10:18 <lasticot> I would like to know more about graphics in Haskell, does someone know of a tutorial that would give some knowledge on how to interact with the gpu in functional way?
00:20:04 <peddie> lasticot: http://hackage.haskell.org/package/nehe-tuts perhaps
00:23:43 <lasticot> peddie: I may be wrong but I thought that thare was another approach than through openGL
00:24:24 <peddie> well, there are things like GPipe and LambdaCube
00:25:08 <lasticot> peddie: thank you I was looking fro things like that!
00:25:15 <peddie> or gloss and not-gloss use OpenGL under the hood, but they give a higher-level interface
00:25:24 <peddie> ok, good luck!
00:25:44 <lasticot> peddie do you advise me to simply read the code or try use the librairies ?
00:25:53 <lasticot> using*
00:26:17 <peddie> I haven't used either GPipe or LambdaCube, but I suspect they might have some tutorials if you google around
00:26:30 <lasticot> peddie: ok thanks very much!
00:26:51 <peddie> looks like all four packages I mentioned have an associated -examples package on hackage
00:27:06 <lasticot> peddie: inded on the haskell page og GPipe at least there is a tuto
00:47:55 <ellipsis_> anyone here?
00:49:07 <ellipsis_> how exactly does the instance Ser String conflict with Ser a => Ser [a] given that there's no instance for Ser Char?
00:49:57 <pavonia> because String = [Char]
00:50:15 <ellipsis_> yeah
00:50:18 <ellipsis_> but there's no instance for Ser Char
00:50:24 <ellipsis_> so Ser a => Ser [a] doesn't apply
00:50:58 <pavonia> What if one would be added?
00:51:14 <ellipsis_> Ser is custom
00:51:22 <ellipsis_> also, I checked
00:51:33 <ellipsis_> and it fails if I try to use Char as an instance of Ser
00:52:02 <pavonia> I mean, which instance for [Char] should be selected if there were an instance Ser Char?
00:52:13 <ellipsis_> well yeah
00:52:20 <ellipsis_> but there isn't an instance for Ser Char
00:52:24 <ellipsis_> that's why I'm confused
00:52:49 <pavonia> But you could add one and that makes it overlapping/undecidable
00:52:59 <ellipsis_> how should I implement that then?
00:53:15 <pavonia> What are you trying to do?
00:53:32 <ellipsis_> implement a serialization thing, and I want to have a generalized serializer for arrays
00:53:39 <ellipsis_> but strings need their own special code
00:54:40 <ellipsis_> can I add a specialization of it for Ser a when a = Char or something?
00:54:53 <pavonia> you could use a wrapper type, like `newtype Wrapper a = Wrapper a' and then declare an instance for Wrapper String
00:56:10 <ellipsis_> wouldn't I have to wrap String whenever I serialize it then?
00:56:29 <ion> ellipsis: http://stackoverflow.com/a/1072523/584163
00:57:39 <ellipsis_> ion: thanks
00:58:49 <pavonia> ion: What's the preferred solution to that problem?
01:00:54 <ion> ellipsis: Also read this: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
01:01:18 <ion> pavonia: Depends on the situation, i guess. I haven’t had that problem myself.
01:02:52 <ion> pavonia: The Show class uses a kluge for that: showList.
01:03:22 <pavonia> Yes, I was thinking of that too
01:03:48 <pavonia> Well, I have to go. Bye!
01:05:44 <ellipsis_> figured it out
01:06:15 <ellipsis_> added a IsntChar typeclass and made it (Ser a, IsntChar a) => NBT [a]
01:06:21 <ellipsis_> s/NBT/Ser/g
01:11:51 <ion> Won’t that just move the same problem to IsntChar?
01:14:49 <ellipsis_> had to add OverlappingInstances
01:15:01 <ellipsis_> but at least it's really really obvious that you shouldn't declare IsntChar Char
01:17:43 <ion> Closed type families in 7.8 might be useful here.
01:19:00 <ion> type family Blah a where { blah Char = Foo; blah a = Bar }
01:19:05 <ion> or something
01:20:27 <ion> Or perhaps even an equality type family and instance (Equal a Char ~ False) => …. Dunno if that would work.
01:21:57 <ellipsis_> what's ~ do?
01:22:29 <ellipsis_> nm
01:22:35 <ion> Type equality
01:23:03 <ion> (No, there’s no /~ unfortunately.)
01:25:44 <marko2> Hey guys! Is it true that the ST monad has better performance than the strict state monad (even with strict modify), or am I doing something wrong? In my example, the ST monad is much faster for otherwise identical code
01:26:12 <ellipsis_> marko2: I'd think it'd depend on whether your code benefits from laziness
01:26:35 <ion> marko2: There’s a reason for ST’s existence.
01:26:41 <marko2> ellipsis_: In this case I do not want any laziness, rather full srictness
01:27:03 <ellipsis_> marko2: Full strictness as in you're sure it'll require full evaluation?
01:27:25 <ellipsis_> if so it seems a little strange for lazy ST to perform better
01:27:25 <marko2> ion: The normal reason is that there are algorithms/data structures that intrinsically need mutable variables to be fast. In my case, the code is identical to the state monad
01:27:38 <marko2> ellipsis_: yes, every step of the way
01:27:59 <ellipsis_> marko2: I mean the final result
01:28:09 <marko2> ellipsis_: Yeah, the result as well
01:28:19 <ellipsis_> not sure then
01:28:22 <marko2> It is not lazy ST, it is strict ST
01:28:36 <ellipsis_> yeah, but you said that lazy ST performed better
01:28:59 <marko2> ellipsis_: I don't recall saying that :)
01:29:20 <ion> marko2: Would you mind posting the code?
01:29:24 <ellipsis_> <marko2> Hey guys! Is it true that the ST monad has better performance than the strict state monad (even with strict modify), or am I doing something wrong? ***In my example, the ST monad is much faster for otherwise identical code***
01:29:47 <marko2> ellispis_: Yeah, no word of lazy ST :P
01:29:59 <marko2> I am just importing Control.Monad.ST, which is the strict one I believe
01:30:06 <ellipsis_> when you said ST monad vs strict state monad I figured it was implied
01:30:15 <marko2> ellipsis_: sorry about that
01:30:19 <haasn> strict state monad refers to Control.Monad.State.Strict
01:30:28 <haasn> as opposed to the regular state monad, which is Control.Monad.State
01:30:30 <marko2> I wanted to stress that the state monad is slower even with full strictness
01:30:56 <ellipsis_> oh
01:31:21 <ellipsis_> you mean Control.Monad.State.State vs Control.Monad.ST
01:31:58 <joelteon> ls
01:32:01 <joelteon> whoops
01:32:02 <marko2> ion: I would post the code, but it is on my other machine. Will post as soon as I can. Anyway, the state is a HashMap, and the code is a monadic for loop updating the map.
01:32:05 <ellipsis_> marko2: http://stackoverflow.com/questions/5545517/difference-between-state-st-ioref-and-mvar
01:32:34 <marko2> ellipsis_: Control.Monad.State.Strict vs Control.Monad.ST, yes
01:32:46 <ellipsis_> marko2: Check the SO link - ST uses mutable memory
01:33:36 <marko2> I know, but I still wonder - I do not make intrinsic use of this, so the state monad should be able to compile down to the same thing
01:34:17 <ellipsis_> marko2: I'd guess that GHC isn't smart enough for that
01:34:19 <marko2> The only thing that changed is that I have on STRef for my state (which I would otherwise pass to evalState), and use modifySTRef' instead of a strict state modify
01:35:42 <marko2> ellipsis_: If this was the case, would not everybody be using a version of the State monad that is a simple wrapper around ST?
01:36:02 <marko2> ellipsis_: and it would instantly make all state related code faster
01:37:03 <marko2> ellipsis_: something like myEvalState f state = runST (newSTRef state >> f); etc
01:37:04 <ellipsis_> marko2: Fair point - I'm not sure then
01:37:18 <ellipsis_> marko2: someone with more knowledge of GHC internals would have to answer that
01:37:29 <marko2> ellipsis_: okay, thanks anyway!
01:38:40 <marko2> On a related note: everyone using the state monad has needed the strict version of State.modify at some point, right?
01:38:48 <marko2> to avoid stack space overflows
01:39:33 <marko2> modify' f = do { v <- get; put $! f v }
01:39:59 <Twey> marko2: I don't think the types are even compatible
01:40:01 <marko2> I was wondering if one can achieve the same without this definition, which I have repeated a thousand times already
01:40:42 <Twey> marko2: The point of ST is that you can't use an STRef outside its owning runST block
01:41:14 <Twey> You'd have to wrap the entire state computation in an ST block and you wouldn't be able to compose them
01:41:25 <Twey> State isn't really like ST
01:41:30 <marko2> marko2: yes, but there is a trivial way of implementing the State monad in terms of ST
01:41:46 <marko2> oups, I wrote to myself ;)
01:42:17 <Twey> Have you tried implementing it?
01:42:34 <simpson> State can be implemented without regards to ST: data State s a = State (s -> (s, a))
01:42:47 <Twey> I feel like either a) types or b) forking (intro- and inter-thread) would break
01:42:53 <marko2> Twey: Well, I had a state monad computation before, which I quickly converted to ST, by putting the state in a STRef and modifying that
01:43:12 <marko2> just to compare the performance, and ST was the clear winner
01:43:13 <Twey> You can certainly use ST in many cases instead of State, but that doesn't mean they're the same thing
01:43:31 <marko2> Twey: I am not saying they are the same. You can't implement ST using State, obviously
01:43:33 <Twey> You can usually use IO instead of State, too, but that doesn't mean I want all my State programs to be in IO!
01:44:00 <marko2> Twey: you are missing the point; I do not actually want to use the ST monad but the State monad. My problem is that the State monad is much slower
01:44:15 <marko2> Twey: and I was wondering if I was using the State monad wrong or if the ST monad is just faster
01:45:45 <Twey> I was responding to this: 081510 <marko2> ellipsis_: If this was the case, would not everybody be using a version of the State monad that is a simple wrapper around ST?
01:46:06 <marko2> Twey: Okay. So: anytime I have a State monad, I can trivially use the ST monad instead. Why should I not do that, seeing it is faster?
01:46:08 <Twey> It doesn't seem unlikely to me that ST should be faster, since you don't have to worry about sharing the contents of the reference
01:46:12 <marko2> Twey: what is the downside=?
01:47:25 <Twey> marko2: They're not semantically similar.  State is ultimately just sugar for threading arguments through functions, whereas ST is actual in-place mutable state.  You can't e.g. share ST across threads, or ‘fork’ it in a single thread.
01:47:29 <marko2> Twey: That makes sense. Kind of disappointing, however, because all I do is update a HashMap in a loop
01:48:49 <marko2> Twey: ST is still pure and referentially transparent once you run it (runST), right? But I see, you can't do forking etc. inside the monad like you could in the State monad
01:49:24 <marko2> http://hackage.haskell.org/package/STMonadTrans-0.2/docs/Control-Monad-ST-Trans.html
01:49:54 <Twey> marko2: Yes, but it's locally impure — you can't use it independently in two different places like you can with State, because it will be modified in-place and the changes from the first one to run will infect the other
01:49:55 <marko2> It can be used though if the base monad plays nice
01:53:40 <timblechmann> hi, i wonder, what is the preferred way to read command line arguments from a haskell script?
01:54:16 <Twey> timblechmann: http://www.haskell.org/haskellwiki/Command_line_option_parsers
01:55:19 <timblechmann> Twey: thnx ... any recommendation for a package?
01:57:01 <Twey> timblechmann: Depends on your use-case.  For a quick script, as you seem to be implying, parseargs or simpleargs is nice.  For bigger programs I usually use getopt.
01:57:22 <timblechmann> Twey: thanks!
01:57:24 <Twey> I heard there's something new and fancy out now, but I can't remember what it's called…
01:57:53 <Twey> Maybe console-program?
01:57:56 <marko2> optparse-applicative is quite nice
02:15:41 <absence_> why can you write "id $ \a -> a" but not "id \a -> a"? is \ or -> an operator with some precedence rather than syntax?
02:16:42 <Twey> absence: No
02:16:54 <Twey> It's just a quirk of the grammar
02:18:41 <Twey> In general any special syntax needs to stand alone in its node; the same applies to do, case, if/then/else, &c.
02:18:55 <Twey> > (+ 1) if True then 3 else 4
02:18:55 <lambdabot>   <hint>:1:7: parse error on input `if'
02:19:06 <Twey> > (+ 1) case () of () -> 3
02:19:07 <lambdabot>   <hint>:1:7: parse error on input `case'
02:19:19 <Twey> > (+ 1) $ case () of () -> 3
02:19:19 <lambdabot>   4
02:19:34 <absence> Twey: ahh understand. thanks!
02:30:50 <ion> I wish those worked.
02:31:20 <ion> “id \a -> a” should work like “id (\a -> a)”
02:31:38 <ion> Also: do
02:31:43 <lpaste> dpwright pasted “Inference based on return type” at http://lpaste.net/96130
02:32:13 <ion> runFooT do { … }
02:32:46 <Twey> ion: Maybe
02:32:47 <dpwright> I am trying to write a function which returns all the potential neighbouring co-ordinates of a point
02:33:00 <dpwright> in 2D space
02:33:04 <Twey> I find that unpleasant to read, but maybe just because I'm used to how Haskell works now
02:33:14 <dpwright> sorry, in any dimensionality
02:33:42 <dpwright> so for 2D the neighbours would be [(0, 1), (0, -1), (1, 0), (-1, 0)]
02:33:49 <Twey> In a discrete space?
02:34:12 <dpwright> I'm using repa, so the Shape of the return type describes how many dimensions there are
02:34:55 <dpwright> Currently my solution (linked above) works, but requires that I pass the number of dimensions in.  Is there anything clever I can do to figure that out based on the return type?
02:35:30 <dpwright> Twey: I'm not sure what you mean, but probably?  The co-ordinates are integers.
02:35:35 <Twey> dpwright: I don't know about repa, but it sounds like you want singleton types
02:36:19 <Twey> Something like SingI n ⇒ Shape n, perhaps
02:38:20 <dpwright> Twey: Hmm, I'll have a look into singleton types, thanks
02:38:59 <dpwright> there is a function that you can run on a Shape to get its rank (number of dimensions)
02:39:13 <dpwright> there is also a function to get a unit Shape
02:39:51 <dpwright> the commented out bit at the end of my lpaste shows that I can use those to get the dimension value, but I have to explicitly set the type of 'unitDim'
02:40:32 <benmachine> dpwright: is that a problem?
02:40:35 <dpwright> I know I want it to be of the same type as 'test', the function which is calling it, but I don't know any way of expressing that
02:40:41 <benmachine> ah
02:40:50 <benmachine> there are a few ways!
02:41:08 <benmachine> the simplest is turning on the ScopedTypeVariables extension
02:41:22 <benmachine> then doing something like test :: forall a. [a]
02:41:23 <Twey> Ah, it's a typeclass
02:41:33 <benmachine> and (R.unitDim :: a)
02:42:03 <dpwright> ah, that does sound appropriate!  is ScopedTypeVariables one of the "good" extensions?  Are there any caveats I should bear in mind?
02:42:20 <benmachine> the forall in the type of test says "make this type variable mean the same thing wherever it's used within the test function" instead of being a fresh type variable each time
02:42:34 <benmachine> dpwright: hmm, it's /relatively/ good
02:42:39 <benmachine> I personally think the syntax is silly
02:42:47 <benmachine> but that's a pretty minor complaint
02:43:18 <benmachine> but yeah, this is probably the best way
02:43:24 <benmachine> there is however a way to do it without extensions
02:44:02 <FreeFull> Is there anything in Haskell that would be equivalent to   exists a.
02:44:15 <Twey> benmachine: What's wrong with the syntax?
02:44:17 <dpwright> benmachine: Oh?  How does that work?  I am not averse to extensions, but it would be nice to understand both techniques :-)
02:44:31 <benmachine> dpwright: sec, I'll show you
02:45:09 <Twey> FreeFull: http://www.haskell.org/haskellwiki/Existential_type
02:45:50 <lpaste> benmachine annotated “Inference based on return type” with “Inference based on return type (annotation)” at http://lpaste.net/96130#a96131
02:46:12 <benmachine> dpwright: ^ that should work, although I admit I haven't tested it
02:46:32 <benmachine> Twey: it's just not really obvious that "forall" would be a binder
02:47:33 <FreeFull> Twey: How would you write something like   foo :: exists a. (a,a -> b)  using that?
02:47:57 <FreeFull> Would you have to wrap it in a type?
02:48:05 <Twey> benmachine: Is it not?  It introduces a variable
02:48:21 <benmachine> Twey: well sure, but there's an implicit forall if you don't supply one
02:48:36 <benmachine> so you have to have that implicit foralls are the same as explicit foralls but non-binding
02:48:37 <Twey> benmachine: That's an inconsistency for the sake of convenience :þ
02:48:51 <Twey> Mm, yes
02:48:55 <benmachine> and also, you can't write a rank-2 type without inadvertently binding a variable
02:49:16 <Twey> Implicit foralls should probably be binding, too, but backwards compatibility
02:49:20 <dpwright> benmachine: It does!  Thanks.  That's actually quite close to something that I tried a bit earlier, where I tried creating a wrapper function inside the 'neighbours' function itself to do it.  Glad to know I was on the right lines
02:49:52 <Twey> Personally I'm a fan of type-level Λ
02:50:00 <Twey> But since we don't even have value-level λ… :þ
02:50:01 <benmachine> Twey: personally I'm a fan of Agda :D
02:50:12 <benmachine> but
02:50:20 <Twey> We could probably write /\ or something
02:50:27 <benmachine> much like Perl, I like Agda the more I don't try to actually program in it
02:50:46 <Twey> benmachine: Well, yes, once the elimination problem is solved
02:50:53 <Twey> Let's all cheer Idris on :þ
02:51:58 <benmachine> woooo
02:52:06 * benmachine waves pom poms
02:53:01 <FreeFull> Go go Idris!
02:55:08 <Twey> °\o/°
02:55:28 <Twey> /°o/° °\o°\ /°o°\
02:56:23 <quchen> Is there a reason RSA needs a RNG for encryption, like the RSA package requires? http://hackage.haskell.org/package/RSA-1.2.2.0/docs/Codec-Crypto-RSA.html
03:03:28 <monoidal> quchen: key generation
03:03:45 <monoidal> you need two large primes
03:03:46 <quchen> monoidal: Key generation has its own API function
03:03:57 <quchen> The encryption function requires a public key
03:04:01 <quchen> So that's already been done
03:04:07 <xnyhps> quchen: OAEP padding requires random numbers.
03:04:30 <Twey> quchen: It's used for the padding method: http://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding
03:05:08 <quchen> xnyhps, Twey: Ah, that sounds good. Thanks for the hint!
03:05:09 <Twey> The padding doesn't have to be randomized, but you'll get a more vulnerable ciphertext.
03:06:06 <xnyhps> If you don't use any randomness or padding, you end up with distinguishing attacks.
03:06:34 <quchen> And verification doesn't need padding because it's only a hash that is signed anyway?
03:08:18 <Twey> quchen: The padding method is to create an integer less than the base; if your message already fits that description, you're good to go
03:08:21 <xnyhps> Well, I'd expect verification to be deterministic. :P
03:08:45 <quchen> Woops, s/verification/signing
03:08:46 <Twey> Er, yes, and you're strictly decrypting for verification.
03:44:25 <funcorize> is using "top level mutable state" always avoidable?
03:47:05 <Cale> funcorize: sure?
03:47:38 <funcorize> Cale: dont catch ya sorry
03:47:50 <Cale> funcorize: At the absolute worst, you can always parameterise everything over that state.
03:48:03 <Maxdamantus> The top level is just where you decide to call the top level.
03:48:34 <funcorize> Maxdamantus: thats a good point
03:48:42 <Maxdamantus> The program's still probably running on a computer, on Earth, in the Solar system.
03:49:03 <funcorize> Maxdamantus: we are getting into philosophical here :D
03:49:13 <funcorize> but true, I agree
03:49:32 <Twey> Top-level mutable state?  Is that the kind where you unsafePerformIO an IORef into your module?  :þ
03:49:55 <Cale> That's what I'm thinking is meant
03:50:28 <Cale> and yeah, you can pretty much always do that
03:50:39 <funcorize> dw I will just use an IORef local to my main
03:51:06 <Cale> Yeah, you can always push the IORef's creation into main, and then pass it around explicitly
03:51:29 <funcorize> i want to keep a list of servers connected to my server, and these are querying each other at 5sec intervals
03:51:42 <funcorize> its quite IO heavy and this is the first similar problem I attack in Haskell
03:52:18 <funcorize> s/similar/problem like this
03:53:45 <Cale> So, when you have thread communication, you usually have to set up (at least some of) the ways in which your threads will communicate somehow before spawning the threads, and in a simple case, you might just have an IORef that gets manipulated by various threads. That can obviously get messy, so the next level of control over what happens might be to use MVar and/or Chan
03:54:42 <Twey> funcorize: Generally IORefs are also avoidable.
03:55:02 <funcorize> Twey: but I need to update that list all the time :D
03:55:12 <funcorize> servers connect/disconnect etc
03:55:20 <Twey> Cale: Are IORefs even threadsafe?  I thought sharing an IORef between threads could result in corruption
03:55:43 <Twey> funcorize: Are you sharing it between threads?
03:55:44 <Cale> Twey: They're "threadsafe", in that you can't half-write values
03:55:46 <FreeFull> If you care about certain operations being atomic you can use STM
03:55:51 <Twey> Cale: Oh, good.
03:55:52 <funcorize> Twey: yeah MVars are a better option but theres an atomicUpdate or sg like that for IORefs
03:55:55 <funcorize> Twey: yes
03:55:59 <Twey> Ah, okay
03:56:02 <Cale> Twey: But nothing is transactional in any way of course
03:56:18 <funcorize> Is STM hard to get/learn
03:56:23 <funcorize> (i know hard is relative)
03:56:26 <Cale> funcorize: It's not too bad
03:56:27 <FreeFull> I'd say STM is pretty simple
03:56:34 <Twey> funcorize: No, it's easier than not-STM :þ
03:56:42 <funcorize> Twey: ha!
03:57:24 <funcorize> I'm spreading Haskell love at UK's one of biggest startup BTW
03:57:27 <funcorize> :D
03:57:39 <Twey> funcorize: In STM you just worry about which sequences of reads/writes should be atomic, you stick an atomically $ in front of them, and all the rest goes away.
03:57:41 <Cale> Using STM can be a bit of a performance hit, but it tends to make certain concurrent programs *way* easier to get right.
03:58:24 <Cale> (relative to MVar and Chan)
03:58:26 <Twey> funcorize: Depending on what you're doing, some sort of FRP might also be an option
03:58:41 <Twey> funcorize: What is the UK's biggest startup?  :þ
03:59:02 <funcorize> Twey: basically I am writing a coordinator for nodes/services for a service orinted architecture platform im planning to write in Haskell
03:59:03 <funcorize> :D
03:59:58 <funcorize> Twey: one of the biggest, but being the social weirdo I am, I do not want to tell if you don't mind:D
04:00:24 <funcorize> but gave a talk 2 weeks ago and everyone seemed to love it
04:00:34 <funcorize> (I mean the language, my talk sucked lol)
04:00:41 <Twey> funcorize: I just wasn't aware we had big startups in the UK.  Or that ‘big’ was a term that could be meaningfully applied to startups :þ
04:01:35 <funcorize> depends on if moving a couple of hundred mils of pounds of cash a year is considered big lol
04:01:57 <Twey> That's pretty big for a startup
04:01:59 <Twey> O.O
04:02:15 <funcorize> its not startupish anymore though couple of hundred empoyees, ha!
04:02:21 <funcorize> but we still like to think we are a startup
04:02:25 <funcorize> :D
04:03:41 <FreeFull> Haskell is great if you like your code to work
04:03:58 <funcorize> I do. I prefer to drink beer in pubs to debugging
04:05:04 <benmachine> Twey: see also atomicModifyIORef
04:05:10 <benmachine> I'd hope that was atomic :P
04:05:13 <Twey> Heh.
04:05:22 <funcorize> benmachine: thats what i was talkin about
04:05:29 <funcorize> hope it werks
04:18:07 <funcorize> is there data structure what I can use like a map, but it is sorted by value, so I can query it by value but update/delete by key?
04:19:14 <augur> whats the pragma for getting all errors?
04:19:26 <augur> well, warnings and such too
04:19:28 <augur> like partiality
04:19:42 <Cale> -Wall
04:19:49 <augur> ahh right
04:20:22 <Cale> I usually don't even turn that on, because it complains about too many things which are not problems
04:20:29 <augur> thats not LANGUAGE tho is it, Cale?
04:20:37 <Cale> no
04:20:39 <augur> i want my totality :p
04:20:42 <Cale> maybe OPTIONS_GHC would work
04:21:05 <augur> ahh yes thats it
04:21:07 <augur> thank you :)
04:21:58 <Cale> -fwarn-incomplete-patterns
04:22:21 <Cale> (is another option)
04:22:30 <augur> Cale: mm ill try that
04:22:43 <Twey> funcorize: There's a bimap, which is basically just two maps
04:23:21 <Twey> funcorize: Or you could traverse the whole tree for either the key or the value
04:25:21 <funcorize> Twey: I want to avoid traversing cause thats O(n)
04:26:44 <funcorize> Twey: bimap doesnt give me back the min X/max X values only min/max :S
04:26:57 <arkeet> there's even a bimap package
04:27:17 <arkeet> implemented as a pair of maps
04:27:28 <arkeet> @hackage bimap
04:27:28 <lambdabot> http://hackage.haskell.org/package/bimap
04:27:32 <funcorize> arkeet: im reading that at the moment
04:27:34 <arkeet> :)
04:28:01 <arkeet> This function will return the result in the monad, or fail if the value isn't in the bimap.
04:28:02 <arkeet> =(
04:28:22 <arkeet> no one should use fail.
04:34:26 <mr-> Right, use error instead
04:35:56 <arkeet> no!
04:36:03 <arkeet> use mzero instead
04:36:46 <FreeFull> Use whichever is relevant
04:37:45 <arkeet> well in this case it should be mzero.
04:37:57 <arkeet> or empty.
04:38:05 <Twey> unsafePerformIO (evaluate ((unsafeCoerce 0 ∷ String → Void) "Oops, something went wrong."))
04:41:48 <haasn> Twey: what could POSSIBLY go wrong?!
04:42:57 <Hafydd> Does it really take too much space to just type :: and ->?
04:43:07 <Twey> haasn: I'm wondering if I missed something that couldn't…
04:44:18 <Twey> Hafydd: I got used to typing → and now I can't stand -> any more :þ  The hyphen is the wrong length, it's not connected to the head, it's not centred properly, the head is too big…
04:44:46 <Hafydd> Depending on the font.
04:44:49 <FreeFull> Twey: I tried running that code and it just seems to go into an infinite loop
04:45:00 <Hafydd> Also, TWSS
04:45:14 <FreeFull> It's not even using any CPU
04:45:20 <Twey> Hafydd: It would be a very strange font indeed that arranged -> into a proper arrow :þ
04:45:36 <Twey> Oh dear, we need an abbreviation for that now?
04:45:55 <Twey> FreeFull: I'm surprised — I fully expected it to segfault
04:45:57 <Hafydd> Maybe we need a Unicode character for "TWSS".
04:47:36 <Hafydd> Twey: I think the two-character versions look better in my 1:2 aspect ratio fixed-width font (i.e. Terminus 16px); but perhaps I'm just used to them.
04:48:09 <FreeFull> Twey: I wonder what it's actually doing
04:49:12 <FreeFull> I'll try compiling it to see if it has different behaviour from GHCi
04:49:22 <Hafydd> If there were double-width versions, then we might be onto something...
04:50:10 <FreeFull> Twey: Is the unsafePerformIO necessary?
04:51:15 <Twey> FreeFull: Not if you're in IO
04:51:45 <Twey> Usually coercing something to a function and then calling it is enough to segfault.  Guess I got lucky.  :þ
04:51:57 <Twey> FreeFull: Compiled gives me <<loop>>.
04:52:06 <hpc> also, unsafePerformIO . evaluate = id
04:52:18 <sipa> :t evaluate
04:52:18 <lambdabot> a -> IO a
04:52:38 <FreeFull> Twey: Compiled terminates for me
04:53:19 <FreeFull> No error, no error code
04:53:31 <Twey> Hafydd: For me :: is slightly too wide, and ∷ is slightly too narrow.  But semantically they're better: → is unambiguously an arrow, where -> is a hyphen followed by a greater-than sign, that just happens to look a bit like an arrow in some renderings.  :þ
04:53:59 <hpc> Twey: what crazy renderings make it not look like an arrow? :P
04:54:14 <Hafydd> -
04:54:15 <Hafydd> >
04:54:19 <Hafydd> When it wraps!
04:55:07 <Twey> hpc: Screenreaders, for example
04:55:27 <Hafydd> If you're using a screenreader to read Haskell, I feel bad for you.
04:55:41 <Hafydd> Although I suppose it could be worse: you could be reading Perl.
04:55:48 <sipa> well it's a screenreader, not a screenshower!
04:55:50 <FireFly> Just teach it to read >>= as "bind", <*> as "ap", and so on
04:55:54 <Twey> My friend's screenreader would render -> as ‘hyphen greater-than’ (though to be fair it would read ‘→’ as ‘special character’, but the point stands in theory :þ)
04:55:57 <FreeFull> Twey: What do you think about ⇒?
04:55:59 <sipa> it's not supposed to _look_ the same :p
04:56:02 <FreeFull> For =>
04:56:05 <Twey> FreeFull: I use that too
04:56:18 <hpc> if you're using a screenreader to read any code, then if open parenthesis eye plus plus less than sign one zero zero close paren space open curly brace
04:56:22 <FireFly> Twey: I think operators are a bigger issue than the -> syntax for screen readers.. :p
04:56:35 <Twey> Also ★
04:57:01 <FreeFull> if (i++<100) {
04:57:08 <Twey> hpc: All the blind coders I know code like that
04:57:12 <Twey> I guess you get used to it
04:57:38 <hpc> Twey: there's certainly less convenient parts of being blind
04:57:44 <FreeFull> Rather than use a screenreader you could use something that converts every character into a sound
04:58:06 <Twey> FreeFull: Textual sonification?  Neat idea
04:58:06 <FreeFull> Which would be tough to learn
04:58:20 <mhskehavat> @pl \x y z -> f (g x y) z
04:58:20 <lambdabot> (f .) . g
04:58:24 <Twey> You could probably speed up output that way, though.
04:58:35 <Hafydd> Wouldn't it perhaps be better to read out tokens rather than characters?
04:58:49 <FreeFull> Hafydd: Of course
04:58:54 <Twey> Hafydd: Yes
04:59:02 <ij> If i want to use lambdas to pass 'em to funcs, I need to enparens them? Why can't I do "fun arg arg \x->x+1"?
04:59:15 <mhskehavat> @pl g k -> u (b l) $ q (\i -> mod i k < 1) x
04:59:15 <lambdabot> (line 1, column 7):
04:59:15 <lambdabot> unexpected '>'
04:59:15 <lambdabot> expecting operator
04:59:17 <hpc> ij: it's for parsing reasons
04:59:27 <FreeFull> Preferably you don't deal with text anymore
04:59:30 <FireFly> It'd be interesting to write an AST->"sane" pronounciation converter
04:59:31 <hpc> ij: you can also do "fun arg arg $ \x -> x + 1"
04:59:31 <Hafydd> ij: you could use fun arg arg $ \x -> x+1
04:59:36 <FreeFull> But something that wraps pieces of text
04:59:37 <ij> ah!
04:59:38 <mhskehavat> @pl g x k -> (u (b l) $ q (\i -> mod i k < 1) x)
04:59:39 <lambdabot> (line 1, column 9):
04:59:39 <lambdabot> unexpected '>'
04:59:39 <lambdabot> expecting operator
04:59:42 <Hafydd> Heh.
04:59:51 <ij> Silly me.
04:59:55 <Hafydd> I like that they lined up despite everything.
05:00:04 <FireFly> That'd turn "if (x > 2) { x++; }" to "if x greater-than two then x plus-plus" or so
05:00:15 <mhskehavat> @pl \i -> mod i 10 < 1
05:00:15 <lambdabot> (< 1) . flip mod 10
05:00:58 <hpc> FireFly: syntax highlighting with voice changing
05:01:14 <hpc> "if x *greater-than* two *then* x *plus-plus*"
05:01:47 <FireFly> Hm, I think I'd want emphasis on keywords/control structures in such a case. perhaps
05:01:56 <FireFly> i.e. if and then
05:02:00 <FreeFull> Who knows, maybe if we make a system that is better for the blind, it might turn out to be better for everybody
05:02:16 <hpc> FireFly: i did it by emphasizing things that weren't code literals but being interpreted
05:02:21 <FireFly> But I wouldn't know, I'm not blind so I haven't had to use a screen-reader
05:02:23 <hpc> except for plus-plus which i mentally misread as "increment"
05:02:29 <FireFly> hpc: oh
05:02:52 <hpc> also i would enounce indentation reduction too
05:03:11 <hpc> "if x *greater-than* two *then* x *increment* *down*"
05:03:23 <mhskehavat> @pl \n -> [1..10] !! (n-1)
05:03:23 <lambdabot> ([1..10] !!) . subtract 1
05:03:27 <hpc> since even sighted people fuck that up all the time
05:04:03 <mhskehavat> \ g x -> ( g x > max (g $ x-1) (g $ x+1))
05:04:16 <mhskehavat> @pl \ g x -> ( g x > max (g $ x-1) (g $ x+1))
05:04:16 <lambdabot> liftM2 ap ((>) .) (ap (ap . (max .) . (. subtract 1)) (. (1 +)))
05:04:31 <FireFly> hpc: even more fun would be doing the converse: speech-to-code translation :D
05:04:49 <hpc> heh
05:05:04 <FireFly> without having to explicitly pronounce every brace etc.
05:05:08 <mhskehavat> @pl \ g x -> ( g x > max (g $ x-1) (g $ x+1)) whre g x = 2
05:05:08 <lambdabot> (line 1, column 53):
05:05:08 <lambdabot> unexpected " "
05:05:08 <lambdabot> expecting operator
05:05:19 <mhskehavat> @pl \ g x -> ( g x > max (g $ x-1) (g $ x+1)) whre g x = x
05:05:19 <lambdabot> (line 1, column 53):
05:05:19 <lambdabot> unexpected " "
05:05:19 <lambdabot> expecting operator
05:05:28 <hpc> i wonder how much of a market there is for this sort of thing
05:05:34 <mhskehavat> @pl \ g x -> ( let g x = 2 in g x > max (g $ x-1) (g $ x+1))
05:05:34 <lambdabot> const (flip (ap (ap . ((>) .) . flip id) (ap (ap . (max .) . flip id . subtract 1) (flip id . (1 +)))) (const 2))
05:05:35 <hpc> specialized IDE for the blind
05:07:15 <mhskehavat> @pl \x y -> x+y
05:07:15 <lambdabot> (+)
05:08:00 <mhskehavat> @pl \x y z -> max (x y) (x z)
05:08:00 <lambdabot> flip =<< (((.) . max) .)
05:08:18 <haasn> :t max `on` x
05:08:19 <lambdabot>     Couldn't match expected type `a0 -> c0' with actual type `Expr'
05:08:19 <lambdabot>     In the second argument of `on', namely `x'
05:08:19 <lambdabot>     In the expression: max `on` x
05:08:27 <haasn> :t max `on` ?x
05:08:28 <lambdabot> (Ord c, ?x::a -> c) => a -> a -> c
05:08:39 <kartoffelbrei> FireFly: http://ergoemacs.org/emacs/using_voice_to_code.html
05:08:45 <mhskehavat> @pl \x y z -> max (x y) (x z)
05:08:45 <lambdabot> flip =<< (((.) . max) .)
05:09:04 <kartoffelbrei> it's fascinating how fast this guy can input code with only voice commands
05:09:05 <mhskehavat> @pl \x y z -> max (x y) (x z)
05:09:05 <lambdabot> flip =<< (((.) . max) .)
05:12:35 * hackagebot lambda-devs 0.3.1 - a Paralell-DEVS implementaion based on distributed-process  http://hackage.haskell.org/package/lambda-devs-0.3.1 (alios)
05:14:07 <FireFly> kartoffelbrei: interesting
05:16:12 <james-sh> I m learning about lambda abstraction. One of the applications of this is to define functions which return functions. For example  "addNumber :: Integer -> (Integer -> Integer)" with this definition  "AddNumber m = (\n -> n + m )" returns a function which gets a number and adds it to m. Is there any way to define such a thing without using lambda abstraction ?
05:16:55 <piezoid> AddNumber = (+)
05:17:07 <Twey> james-sh: In Haskell you can use operator sections, addNumber = (+) or addNumber m = (+ m)
05:17:19 <Hafydd> addNumber m n = n + m
05:17:24 <lpaste> bennofs pasted “Cabal install problem” at http://lpaste.net/96132
05:17:25 <Twey> (AddNumber is not a valid function name, as initial capitals are reserved for types and constructors)
05:17:50 <epta> Where can I find list of all `-fno-warn-...` ghc options?
05:17:57 <Hafydd> (or addNumber = flip (+))
05:17:58 <Twey> james-sh: The default Haskell function syntax produces a curried function, so this is equivalent to the standard addNumber m n = m + n
05:18:00 <bennofs> I have a problem with cabal install (see the paste). transformers is installed and the hash is correct
05:19:23 <james-sh> can you explain a bit more?
05:19:25 <Twey> james-sh: You could also define a second function, with a let or where: addNumber m = f where f n = m + n, addNumber m = let f n = m + n in f
05:19:53 <Twey> james-sh: Which part?
05:20:06 <james-sh> the curried functions
05:22:25 <Twey> james-sh: In Haskell, all functions take exactly one argument.  This argument can be a tuple, which is one way of passing multiple values to a function, but more commonly one defines a function that takes the first argument and returns a second function, which takes the second argument and returns a third function, and so on until all the arguments are passed and it can return a value
05:22:38 <Twey> This is what the usual function-definition syntax produces
05:22:56 <skypers> do you think it’s possible to write a program in Haskell to solve a problem in a few minutes? I mean, write it faster than any other languages?
05:23:00 <Twey> :t \a b c -> b
05:23:00 <lambdabot> t -> t2 -> t1 -> t2
05:24:06 <Twey> james-sh: A ‘binary’ function of type a → b → c simply means a → (b → c), i.e. a function that takes an a and returns a function that takes a b and returns a c
05:24:11 <Twey> :t (+)
05:24:12 <lambdabot> Num a => a -> a -> a
05:24:33 <Twey> james-sh: So you can ‘partially apply’ such a function to get a new function with one of the arguments filled in
05:24:40 <Twey> :t (+) 3
05:24:40 <lambdabot> Num a => a -> a
05:25:00 <Twey> james-sh: (and again, this is what the default syntax does: f x y means (f x) y)
05:25:05 <james-sh> ok
05:25:14 <skypers> :t (+3)
05:25:15 <lambdabot> Num a => a -> a
05:25:16 <Twey> skypers: Depends on the problem, depends on the programmer
05:25:31 <skypers> Twey: yesterday I did a programming contest
05:25:37 <james-sh> i am following. so all functions are represented like this
05:25:43 <skypers> the first question was trivial, and I made it in a few minutes
05:25:54 <skypers> but the second one was an OCR over beats partition
05:25:58 <skypers> it was _hard_
05:26:16 <skypers> and no one in Haskell sub-section succeeded to make it through
05:26:24 <skypers> whereas some dude won in PHP…
05:26:27 <skypers> or Java
05:26:30 <skypers> it made me sad
05:27:02 <Twey> skypers: IMO Haskell encourages you to put more thought into the design of your programs, and thus isn't ideal for programming competitions, where cleanness or reusability of code mean very little
05:27:25 <Twey> OTOH the existing functions can shorten simple programs considerably
05:27:27 <scshunt|nospoile> it's also harder to optimize
05:27:33 <scshunt|nospoile> which is often key in competitions
05:27:50 <w0rm_x> Twey, so the whole point of currying is to allow partial application and to avoid writing function arguments' parenthesis, hmm can't think of another advantage.
05:28:02 <Twey> james-sh: Yes
05:28:07 <skypers> yeah I see
05:28:17 <Twey> w0rm_x: That's pretty much it
05:28:20 <skypers> I just wonder why FPL dudes just failed
05:28:29 <skypers> it was the same for the Scala ones
05:28:47 <skypers> they failed to solve the OCR
05:28:55 <james-sh> right, it seems I have to learn why partial application is important then
05:29:08 <james-sh> cool. I have another question
05:29:11 <Twey> w0rm_x: Curried vs. uncurried functions isn't a huge design feature languages hinge around.  It's largely superficial.  But it makes a few things nicer.
05:29:43 <skypers> james-sh: partial application is really nice, but you can avoid it if you want
05:29:49 <skypers> instead of foldl (+)
05:29:51 <james-sh> I want to write  a haskell program which reads a process algebra description and shows how the process can evolve.
05:30:05 <skypers> you can write foldl (\x a -> x + a)
05:30:05 <james-sh> any suggestions which bits of haskell I need ?
05:30:24 <james-sh> I think at least i need algebraic data types to represent my process
05:30:25 <Twey> skypers: There's a lot more algorithms research in imperative languages, and most algorithms material assumes an imperative language.  Some imperative algorithms don't translate directly to functional code, and functional equivalents are sometimes open research problems.
05:31:51 <Twey> skypers: Also, in my experience people who focus on learning different programming languages, the sort who are likely to encounter and devote time to learning Haskell, don't study algorithms as much.  That's certainly been the case for me, anyway.
05:32:43 <james-sh>  i know that in process algebra community, it is straightforward to write functional programs to check different things. Most researchers write programs functionally even when they use Java or ....
05:33:02 <ij> Is there a way to make the `` infix sugar work with variable-functions? let a = (*); (`a` 3)?
05:33:09 <james-sh> so they have a translation of functional structures but in Java language . thats easier than thinking in Java itself
05:33:09 <Twey> ij: No.  ☹
05:33:14 <Twey> Er
05:33:17 <Twey> May
05:33:22 <Twey> Wait, that should work
05:34:04 <Twey> > let a = (*) in 2 `a` 3
05:34:05 <lambdabot>   6
05:34:30 <ij> oh, right, but if I have a function-scope variable, then it won't.
05:34:43 <monoidal> ij: scope shouldn't matter
05:35:08 <Twey> > let f a = 2 `a` 3 in f (*)
05:35:09 <lambdabot>   6
05:35:15 <ij> hmm, nice
05:35:52 <Twey> james-sh: Well, the first thing you'll need is a representation of the terms of your algebra.  A data-type is a good choice here, though you *can* do the Lispy thing and encode it with tuples &c.
05:41:20 <james-sh> how should I define the semantics and find the state space? any ideas?  any tutorial or point of reference is appreciated
05:45:15 <Twey> james-sh: Defining the semantics basically consists of defining an evaluation function that does what you want.  Finding the state space, I'm not so sure about.
05:45:42 <james-sh> whats an evaluation function?
05:46:11 <tavarish> Hi, I build a program with typed as IO Int, but the program always return 0 (no error) even if I manage to return a non zero int
05:46:17 <james-sh> i am asking too many question
05:46:24 <tavarish> How can I manage exit code correctly?
05:46:25 <monoidal> tavarish: use System.Exit to give an exit code
05:46:37 <Twey> james-sh: A function that evaluates your term
05:46:40 <monoidal> tavarish: the result of main (the IO Int value) is ignored
05:46:46 <tavarish> monoidal, it won't print extra things on stdin or stderr ?
05:47:01 <tavarish> does-it kill the program ?
05:47:11 <monoidal> tavarish: it's equivalent of exit(n) in C.
05:47:19 <tavarish> if I use my main in another program it will exit ?
05:47:23 <tavarish> I never use exit in C
05:47:33 <monoidal> or "return n"
05:47:34 <tavarish> i rather like to go back to my main and handle my return
05:47:36 <Twey> james-sh: You're not, but you're asking about how to implement heavy technical code in a language of which you don't seem to have a basic understanding
05:47:46 <tavarish> like that I can call my main from another program withotu exiting
05:48:00 <Twey> james-sh: It might be more productive to learn Haskell with more basic examples, then try translating your process-algebra code afterwards
05:48:52 <arkeet> tavarish: you are free to e.g. write some myMain :: IO ExitCode
05:49:04 <arkeet> and then let main = exitWith =<< myMain or something
05:49:14 <arkeet> but there isn't really any reason to
05:49:20 <tavarish> but I have to use the evil function exit ?
05:49:26 <arkeet> what's evil about it?
05:49:50 <tavarish> arkeet, it breaks a program violently
05:49:53 <arkeet> ???
05:49:59 <tavarish> it break stack, return and everything else
05:50:18 <arkeet> tavarish: did you read my suggestion?
05:50:37 <arkeet> if for whatever reason you want to use your main action from elsewhere, you can just run myMain instead.
05:50:50 <tavarish> arkeet, I read it, but I ask is the Exit function mandatory (I really like to never use it)
05:51:02 <monoidal> tavarish: if you want to have a exit code, yes.
05:51:34 <monoidal> tavarish: if you want your code to be used only in a library, don't have main, only myMain.
05:51:45 <tavarish> monoidal, there is no flags for GHC to respect the Int of IO Int when main is IO Int ?
05:51:46 <arkeet> (maybe find a better name for it.)
05:51:49 <monoidal> tavarish: no.
05:52:11 <arkeet> the only way to exit with a nonzero exit code is to use exitWith or similar.
05:52:13 <tavarish> will they implement it once or are we stick to use the evil exit method?
05:52:18 <arkeet> it's not evil.
05:53:05 <tavarish> arkeet, OK it's not evil, but my computer as allergy to that function and it will burn if I use it, so I'm doomed
05:53:32 <monoidal> once you're saying "here's exit code for my program", there's no point in running further IMO.
05:57:12 <james-sh> Tewy: I was looking for the starting point. Thanks.
05:57:21 <james-sh> Twey: I was looking for the starting point. Thanks.
05:58:43 <Twey> james-sh: http://www.learnyouahaskell.com/ comes highly recommended
06:01:06 <james-sh> thanks
06:01:13 <piezoid> hi
06:01:17 <piezoid> is it possible to use parsec for parsing multiple interpretations of the same string ?
06:01:44 <tavarish> monoidal, arkeet thx for your explanation, I could success to have decent return code (even if I hate that method)
06:02:05 <fizruk_> piezoid, you mean ambiguous syntax?
06:02:53 <piezoid> yes, then I send them to ghc parser/typchecker and select the first working
06:03:37 <deweyvm> if you keep all possibilities it would explode exponentially wouldnt it?
06:04:53 <piezoid> it's for simple cases, and I would chack and eliminate subexpression a some point
06:05:38 <donri> piezoid: silly answer: if you use the parsers package, you can switch between parsec and readp
06:05:38 <deweyvm> it doesnt take a very long string to cause it
06:05:43 <piezoid> one usecase is to be able to use unquoted strings in hell, and wraping pure result in print
06:05:50 <donri> readp provides all possible parses
06:05:54 <deweyvm> in any case though i dont think parsec supports that, it just gives you the first match it finds
06:06:17 <piezoid> maybe Parsec s u ListT, but I need a combinator doing Monoid m a => [Parser s u m a] -> ParsecT s u m a
06:06:35 <Twey> piezoid: Parsec allows you to keep arbitrary state, so yes
06:07:38 <Twey> You might want to wrap the monad for convenience, though (so that when you parse something it gets appended to all the parses in the state)
06:07:40 * hackagebot websockets-snap 0.8.2.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.8.2.0 (JasperVanDerJeugt)
06:08:05 <piezoid> i dont understand fully the semantic of the inner monad with ParsecT transformer...
06:11:14 <piezoid> not related, but it look like the look ahead semantics of <|>/try is different is Parsec than in Attoparsec, right ?
06:11:46 <arkeet> yes
06:11:51 <Tehnix> anyone here toyed with fpcomplete? Tried cloning my yesod setup and been getting `OpenProjectException "runnerSetTarget(save): " (RestAPITimeout "POST" ["project","open"]...` if that sounds familiar to anyone (I'm stabbing in the dark atm)
06:12:41 * hackagebot egison-tutorial 3.0.0 - A Tutorial Program for The Programming Language Egison  http://hackage.haskell.org/package/egison-tutorial-3.0.0 (SatoshiEgi)
06:12:42 <piezoid> arkeet: ok, so lookahead is more explicit (you have to use try) than in attoparsec ?
06:13:39 <ij> Isn't >>= so standard it should be imported by default?
06:13:53 <arkeet> it's in the prelude.
06:16:09 <Twey> Tehnix: I think chrisdone has played with it a bit…
06:17:41 * hackagebot egison-tutorial 3.0.1 - A Tutorial Program for The Programming Language Egison  http://hackage.haskell.org/package/egison-tutorial-3.0.1 (SatoshiEgi)
06:22:41 * hackagebot language-lua 0.2.1 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.2.1 (OmerAgacan)
06:26:30 <ij> arkeet, hmm, but the compiler throws a parse error, if I don't include control.monad.
06:26:43 <arkeet> surely not a parse error.
06:27:31 <ij> Oh, damn true. Sorry.
06:28:27 <Fuuzetsu> @src init
06:28:27 <lambdabot> init [x]    = []
06:28:27 <lambdabot> init (x:xs) = x : init xs
06:28:27 <lambdabot> init []     = undefined
06:39:40 <Eduard_Munteanu> Is there a (tentative) standard documenting the module hierarchy, as in what goes where?
06:39:54 <Eduard_Munteanu> Not necessarily official.
06:40:04 <Sculptor> module?
06:40:08 <Sculptor> ah, wrong channel
06:40:15 <Sculptor> i though you were talking about something else
06:40:27 <donri> Text.ParserCombinators.XML.Data.Control just put everything here
06:40:45 <Eduard_Munteanu> :)
06:41:17 <donri> i wish Control was called Category and Data was called Algebra and they were principled like that
06:42:28 <Eduard_Munteanu> I'm interested in figuring out a place for applications and ad-hoc stuff, when defined as libraries (I could use Main.* but that's more suitable for the executable package).
06:43:00 <Eduard_Munteanu> And using MyApp.* at the toplevel seems odd.
06:43:12 <ij> Can I send records from a list to a function as arguments(assuming there are always N of them)?
06:43:20 <donri> for applications i just use the name of the app as the namespace
06:43:56 <Eduard_Munteanu> ij: how large is N?
06:44:28 <Eduard_Munteanu> ij: and how about sending the list itselfF?
06:44:56 <donri> yeah just send the list
06:44:58 <Eduard_Munteanu> Thtis kekyboard hahs aa wewird bubg. :(
06:45:00 <donri> varargs in haskell are messy
06:45:25 <Eduard_Munteanu> Hhowever nnot aa bbug llike tthis.
06:45:58 <Eduard_Munteanu> I don't think he means varargs, but for small fixed N you can pattern-match the list.
06:46:30 <Eduard_Munteanu> Before calling the function, or in the function itself.
06:46:32 <donri> if the N is fixed, use tuples and curry instead
06:46:40 <donri> eh uncurry
06:46:55 <donri> @hackage tuple type classes it for larger tuples
06:46:55 <lambdabot> http://hackage.haskell.org/package/tuple type classes it for larger tuples
06:47:03 <ij> Hmm, well I don't want to send the list itself, because it comes from getArgs and i'm trying to make an interface for existing functins.
06:47:58 <donri> and there are tuple versions of getArgs in packages like simpleargs and ReadArgs
06:48:13 <ij> Theoretically, wouldn't foldr1 and ($) do the trick?
06:48:17 <donri> or just use optparse-applicative and parse into the function directly
06:48:31 <ij> Hmm, I will look at the pkgs.
06:48:37 <arkeet> ij: no
06:48:42 <Eduard_Munteanu> This last one seems reasonable to me.
06:48:42 <donri> folds don't want the type to change
06:48:59 <ij> I see.
06:49:38 <arkeet> :t foldr ($)
06:49:39 <lambdabot> b -> [b -> b] -> b
06:49:55 <arkeet> :t foldr
06:49:56 <lambdabot> (a -> b -> b) -> b -> [a] -> b
06:50:00 <Eduard_Munteanu> It's also quite neat as a syntax, using applicative.
06:51:02 <arkeet> > foldr ($) 0 [(+1),(+2)]
06:51:02 <lambdabot>   3
06:51:16 <Eduard_Munteanu> ij: it would look like  someFun <$> parseInt <*> parseBool <*> ...
06:52:00 * Eduard_Munteanu isn't very familiar with optparse-applicative, hence that's just a general idea
06:52:44 * hackagebot HMap 0.9 - Fast heterogeneous maps.  http://hackage.haskell.org/package/HMap-0.9 (AtzeVanDerPloeg)
06:53:27 <ij> It looks rather complex.
06:54:05 <donri> ij: what's the type of your function and what does your arguments look like?
06:54:16 <Eduard_Munteanu> Any idea if 'cabal init' suggestions for categories are meant to have some relationship to toplevel modules?
06:54:46 <ij> donri, yes, i'm already thinking of just short-circuting it.
06:54:55 <ij> I think pattern matching will do (a:b:_)
06:57:15 <donri> ij: ? i was asking so i could help you with optparse
06:58:00 <Eduard_Munteanu> Unless you only want to pass the Strings as they are to your functions.
06:58:20 <ij> And if I do?
06:59:05 <Eduard_Munteanu> ij: you can just pass the list as an arg and pattern-match on it... but don't do that if you're doing 'read' on them anyway, a parser is better then
06:59:45 <Eduard_Munteanu> Pass the list as it is if you the intended interpretation of those strings is just strings. :)
07:00:00 <Eduard_Munteanu> s/if you/if/
07:13:36 <khyperia> I implemented Algorithm W (from Hindley Milner), and it *almost* works, but when I change the let binding to default to letrec, things blow up. (I'm implementing it by "letrec x = v in e" -> "let x = fix (\x -> v) in e") What is a good way to debug such a large algorithm with no idea where the problem is?
07:17:10 <quchen> Why is `splitAt` defined as `(take n xs, drop n xs)`? Is there no version with better sharing that only traverses the list once?
07:17:15 <Eduard_Munteanu> khyperia: check if your substitution doesn't capture or shadow names
07:18:11 <khyperia> and how would I check that?
07:18:12 <Eduard_Munteanu> quchen: that should traverse it only once
07:18:17 <khyperia> If you'd like to see the code, I can paste it
07:18:19 <Eduard_Munteanu> @src take
07:18:19 <lambdabot> take n _      | n <= 0 =  []
07:18:19 <lambdabot> take _ []              =  []
07:18:19 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
07:18:22 <Eduard_Munteanu> @src drop
07:18:22 <lambdabot> drop n xs     | n <= 0 =  xs
07:18:22 <lambdabot> drop _ []              =  []
07:18:22 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
07:18:30 <Eduard_Munteanu> Hrmpf.
07:18:32 <quchen> Eduard_Munteanu: Take and drop each traverse once
07:19:00 <quchen> Funny thing is I can't come up with a simple implementation that traverses only once. I think there may be some tricky knot-tying involved.
07:19:23 <arkeet> nah it's not that trycky
07:19:25 <arkeet> tricky
07:19:53 <Eduard_Munteanu> quchen: it should be enough to make splitAt and implement take/drop in terms of that instead
07:20:25 <arkeet> uh let me write somtehing
07:21:10 <benmachine> quchen: what makes you think splitAt is defined like that?
07:21:20 <quchen> benmachine: The source code.
07:21:26 <benmachine> quchen: which?
07:21:33 <quchen> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#splitAt
07:21:48 <benmachine> ah, ok, just checking
07:22:30 <benmachine> quchen: it may be fusion-related
07:22:44 <benmachine> oh no hold on
07:22:46 * hackagebot tcache-AWS 0.0.1 - tcache using Amazon Web Services as default persistence mechanism  http://hackage.haskell.org/package/tcache-AWS-0.0.1 (AlbertoCorona)
07:23:01 <benmachine> it's inside ifdef USE_REPORT_PRELUDE
07:23:05 <Eduard_Munteanu> Are take/drop actually implemented like that?
07:23:07 <benmachine> which I believe is usually false
07:23:23 <quchen> Oooh.
07:23:24 <quchen> Right.
07:23:25 <benmachine> Eduard_Munteanu: no, see quchen's link
07:23:32 <quchen> Search for "splitAt (I# n#) ls"
07:23:37 <quchen> That seems to be the actual implementation
07:24:15 <arkeet> yeah
07:24:25 <arkeet> that works
07:24:50 <Eduard_Munteanu> You could implement  right :: ([a], [a]) -> ([a], [a])  then  splitAt n xs = iterate right ([], xs) !! n
07:25:38 <arkeet> I don't think so.
07:26:11 <arkeet> well you could, but that'd be O(n^2) for the take part.
07:26:22 <xcthulhu> quchen: if USE_REPORT_PRELUDE is not set, then it looks like it traverses the list just once, building up its result as a little accumulator it carries around
07:26:27 <arkeet> so use difference lists or something there.
07:26:27 <Eduard_Munteanu> arkeet: er, why?
07:26:35 <arkeet> how would you implement right?
07:27:03 <Eduard_Munteanu> arkeet: oh, duh, you can't cons to the end
07:27:23 <arkeet> you can always cons to the front and reverse later, or something.
07:27:30 <Eduard_Munteanu> The zipper gives you an inverted take.
07:27:34 <arkeet> mhm
07:29:25 <lpaste> arkeet pasted “splitAt” at http://lpaste.net/96135
07:29:30 <arkeet> easy enough.
07:30:01 <ij> I wrote this thing, which makes a sudoku field(think [[list]] of 81 numbers) accessible from cli by arguments. http://sprunge.us/URYK?hs Does it look okay?
07:32:04 <arkeet> quchen: ↑
07:32:16 <xcthulhu> arkeet: Very similar to the haskell source...
07:33:07 <lpaste> quchen annotated “splitAt” with “splitAt (annotation)” at http://lpaste.net/96135#a8531303976262434816
07:33:21 <quchen> Now we can theorize about performance :-)
07:33:54 <arkeet> quchen: I would theorize about correctness first. ;)
07:34:09 <lpaste> xcthulhu revised “splitAt”: “No title” at http://lpaste.net/96135
07:34:12 <Eduard_Munteanu> Any idea if glib can be used to access glib-based libraries without writing bindings?
07:34:29 <quchen> arkeet: Dropping the element is what I actually need. Should've added a comment I guess.
07:34:38 <Eduard_Munteanu> Basically something like CORBA does, getting an object / function by name.
07:35:07 <arkeet> Eduard_Munteanu: can C glib do that?
07:35:14 <Eduard_Munteanu> arkeet: I've no clue :)
07:35:35 <arkeet> my completely uninformed guess is no
07:35:49 <lpaste> lasticot pasted “to pretify” at http://lpaste.net/96139
07:35:53 <lasticot> I find this piece of code I wrote pretty ugly, is there a way for me to better code it?
07:36:03 <arnsholt> My relatively uninformed guess would be no, too
07:36:41 <arnsholt> glib is mostly plain structs with some layout conventions, so if you ever need to access the actual fields you'd be screwed I think
07:36:54 <Eduard_Munteanu> Ah, I see, thanks.
07:37:01 <arnsholt> Although... most operations are done through C functions
07:37:21 <Eduard_Munteanu> arnsholt: I was trying to avoid going through C
07:37:38 <arnsholt> So if you have something like a wrapper around libffi/libdyncall you might be able to get by
07:39:23 <quchen> lasticot: 1. Add comments.
07:41:27 <monoidal> ij: squareFind i = swap (divMod i 3)
07:41:44 <monoidal> ij: you've got several redundant parentheses, hlint will detect them.
07:41:49 <quchen> 2. Use vowels. "Lst" is unreadable.
07:42:03 <monoidal> ij: also, you can add remaining type signatures
07:42:53 <lpaste> arkeet annotated “splitAt” with “splitAt (annotation) (annotation)” at http://lpaste.net/96135#a96140
07:42:56 <arkeet> quchen: :-)
07:42:56 <monoidal> ij: or, write choice' "h" = horizontal; choice' "v" = vertical; ...
07:44:20 <piezoid> Eduard_Munteanu: maybe you're looking for https://wiki.gnome.org/action/show/Projects/GObjectIntrospection ?
07:44:29 <quchen> arkeet: :-)
07:45:03 <arkeet> you can always behead the second part if you don't want the element you're splitting at.
07:45:36 <Eduard_Munteanu> piezoid: cool, thanks
07:45:54 <arkeet> where behead = drop 1
07:45:59 <lpaste> quchen annotated “to pretify” with “to pretify (annotation)” at http://lpaste.net/96139#a96141
07:46:15 <quchen> ^ lasticot. Use guards, indentation, and printf.
07:46:24 <quchen> But address 1. and 2. first.
07:47:22 <khyperia> well, I narrowed down the bug to where "#fix (\x -> 2)" (where #fix is a keyword of type (a -> a) -> a) spits out a polymorphic type instead of integer. So, the bug is somewhere in my abstraction, application, or constant rules.
07:47:34 <lasticot> quchen: ok thanks
07:47:36 <ij> monoidal, That swap fun looks very nice, I will lint it too!
07:47:59 <Eduard_Munteanu> @index swap
07:47:59 <lambdabot> bzzt
07:48:08 <Eduard_Munteanu> @hoogle swap
07:48:08 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
07:48:08 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
07:48:08 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
07:49:40 <quchen> swap, the only non-Prelude function in Data.Tuple.
07:49:54 <quchen> Which is incidentially the only remarkable thing about that thing.
07:57:21 <khyperia> hang on... could someone point me to a most-general-unifier algorithm for arbitrary-length type constructors?
07:57:31 <khyperia> I think I may have implemented it wrong.
08:18:46 <Hodapp> :t randomR
08:18:46 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
08:19:47 <Hodapp> if randomR is just returning a new RandomGen, and I'd be passing this along from call to call... isn't that pretty much what monads are for?
08:23:17 <klrr_> i got a type error that i got a hard time to understand when trying to use Additive class from linear package, https://gist.github.com/klrr/7628782 , anyone understand what's wrong?
08:30:33 <klrr_> i tried change it to "... (Additive v, Num a) => ... Behavior t (v a) -> Behavior t (v a)" but got exactly same type error
08:32:58 <merijn> Hodapp: Yes, hence why there is a Random monad :p
08:33:23 <klrr_> nvm got it working :) problem was the type signatures of the functions it depended on
08:37:12 <Hodapp> merijn: oh, I'd read a couple pages that didn't even mention that
08:37:43 <merijn> Hodapp: http://hackage.haskell.org/package/MonadRandom
08:39:36 <klrr_> i got some problems tranlsating the diffE combinator (originally from breakout game) to use Linear.Vector instead of VectorSpace
08:39:48 <klrr_> here is the code and more information https://gist.github.com/klrr/7628991
08:40:13 <Luke> anyone remember how to get cabal install to just download the source but not build or install it?
08:40:33 <Saizan> cabal get or unpack
08:40:51 <Luke> thanks
08:43:21 <slack1256> If I import Control.Lens and only use some submodules of it. Will ghc import the whole tree or just the parts I use?
08:46:06 <khyperia> well, finally figured it out, Eduard_Munteanu, after probably 4-5 hours of head-to-keyboard pounding. Turns out this function composeSubst that I thought was commutative was not.
08:47:04 <merijn> slack1256: THe linker will, presumably, only link the used bits
08:47:14 <merijn> slack1256: But even if it doesn't, that should really matter
08:51:45 <slack1256> Neat
08:54:40 <merijn> slack1256: Any sane OS I'm aware of (i.e. BSD, OSX, linux, minix and, presumably, windows) uses lazy paging for executables (i.e. the entire executable gets mapped into memory, but pages are only loaded from disk if/when needed) so there's no startup overhead for large binaries
08:56:24 <hpc> merijn: any sane system configuration won't be popping up processes fast enough to care about overhead, will have the IO to deal with binaries in the tens of megs, and won't have binaries larger than that
08:56:31 <hpc> just to cover the other bases ;)
08:56:46 <Mapley> t
08:56:48 <merijn> hpc: Sure :)
09:13:36 <halpPlease234> is there a way to include typedef'd aliases from a c header and use them to build an equivalent haskell type?
09:15:46 <halpPlease234> supposing I were to want to create a file via open, for example, and to do that, I need to call open with a mode parameter.. of type mode_t, which is probably an int, but is opaque.. can I create a haskell type from that?
09:20:25 <FreeFull> halpPlease234: Is this just an example, or is it what you are actually doing?
09:20:39 <halpPlease234> example
09:20:41 <Riastradh> Where does one report Hugs bugs?  <https://www.haskell.org/hugs/> points at <http://hackage.haskell.org/trac/hugs>, but that page doesn't exist.
09:20:53 <halpPlease234> there's a posix types library that I could use for that
09:21:31 <geekosaur> Riastradh, there's nobody listening anyway, hugs development is long dead
09:22:04 <benzrf> hello
09:22:05 <benzrf> i
09:22:16 <benzrf> i think i get the types behind the state monad
09:22:19 <benzrf> ._.
09:22:45 <halpPlease234> FreeFull: example; there's a posix types haskell import for that.. interested in being able to handle opaque pass-by-value types
09:23:07 <FreeFull> halpPlease234: When interacting with C code, or in general?
09:23:13 <benzrf> bind takes a stateful function to a and a function that takes a and gives a stateful function to b
09:23:19 <halpPlease234> FreeFull: with C code
09:23:19 <benzrf> then returns a stateful function to be
09:23:20 <benzrf> *b
09:23:55 <FreeFull> I'm not sure if you can have something implementation independent when interfacing with C in that way
09:24:49 <halpPlease234> FreeFull: Well, if the types are defined for whatever implementation in a header, is there no way I can access those definitions & create a haskell type for them?
09:25:07 <Riastradh> geekosaur, well, that sucks.  What other options are there for platforms that are not Windows, Mac OS X, or GNU/Linux on amd64?  GHC's cross-compilation bootstrapping process is (still, as far as I know) too brain-damaged to deal with.
09:25:27 <lasticot> I've got a question about git, lets say I've been working on the branch master correcting bugs and on a branch feature developing new features. Comes a time where I merge the branch feature into the master branch, but before developing new feature I figure that it would be better to also correct the bugs on the feature branch. Should I then merge the master into the feature branch?
09:26:04 <geekosaur> at the moment there isn't really one, unless (a)jhc will work for you
09:26:47 <geekosaur> but ghc is pretty much the only active full haskell compiler; jhc is still missing a lot of stuff, and hugs is missing pretty much everything done in the past 10 years
09:27:11 <Riastradh> Well, Hugs works, unlike the others, so I'll continue using it...
09:27:19 <geekosaur> (since it's been abount that long since anyone did anything beyond minimally getting it to build)
09:28:13 <halpPlease234> what about nhc?
09:28:52 <Riastradh> No good on LP64.
09:29:08 <mangaba_1eitosa> If I'm working with large lists (~ 200,000) of numbers in the range [0..200], what must be faster, using [Word8] or [Int]? Also, I need to calculates sums of the lists, so in case of [Word8] I'd need to do sum (map fromIntegral list)
09:29:09 <halpPlease234> what platform?
09:29:10 <Riastradh> (Dealing with 32-bit compatibility crud is not something I'm keen on doing.)
09:29:38 <slack1256> Any standard combinator for passing from Maybe -> Either?
09:30:01 <mangaba_1eitosa> however, sums I needed for short lists (up to 50 elements)
09:30:03 <triliyn> maybe (Left ()) Right
09:30:13 <triliyn> or wait
09:30:15 <triliyn> That doesn't work
09:30:26 <triliyn> oh never mind, yes it does
09:30:35 <FireFly> Looks like it should to me
09:30:38 <halpPlease234> It does but () might still be meaningful
09:31:05 <halpPlease234> you'd have to stick a "Nothing"-ish type in there
09:31:54 <FireFly> ? () has precisely one value (apart from bottom, aka diverging), which is ()
09:32:18 * FireFly thinks that's as Nothing-y one could get
09:32:48 <FreeFull> mangaba_1eitosa: Why not fromIntegral (sum list)
09:32:50 <slack1256> trilyn: I don't why I was using the same you put up, but with "either"
09:32:51 <triliyn> Left () in particular is pretty Nothing-y
09:32:54 <slack1256> thanks
09:33:02 <triliyn> Though I guess for the () type it doesn't really matter
09:33:14 <halpPlease234> what if () is a legitimate return value
09:33:24 <slack1256> Maybe = 1 + a
09:33:27 <slack1256> () = 1
09:33:35 <slack1256> yep
09:33:42 <FreeFull> Just Nothing
09:33:45 <FireFly> halpPlease234: well, since Either represents a disjoint union that shouldn't be a problem. it's still tagged with Left
09:33:53 <triliyn> () as a return value never carries information
09:34:02 <triliyn> But yeah, there's also the Left
09:34:17 <jmcarthur> mangaba_1eitosa: Word8 and Int should have roughly the same performance, i think
09:34:18 <khyperia> anyone from fpcomplete around? I've got a problem with git.
09:34:18 <halpPlease234> Fair enough.
09:34:38 <FreeFull> Either () a  is equivalent to  Maybe a
09:34:43 <halpPlease234> jmcarthur: Word8 is actually the same size as system Word, innit?
09:34:58 <jmcarthur> mangaba_1eitosa: it might be different with unboxed vectors or something, due to less memory required for Word8, but for lists i can't see any benefit to using Word8
09:35:22 <jmcarthur> mangaba_1eitosa: no, Word8 is 8 bits. Word is specified to be at least 30 or 31 i think, and in ghc is 32 or 64 depending on architecture
09:35:29 <FreeFull> Word8 won't be the size of the system word unless you are running Haskell code on an 8-bit chip
09:35:46 <joelteon> happens, but not common
09:35:48 <halpPlease234> FreeFull: my confusion was with regards to something of type Just () ..
09:36:02 <FreeFull> halpPlease234: That'd be Maybe ()
09:36:10 <FreeFull> Which is equivalent to Bool
09:36:23 <FreeFull> Ignoring bottoms
09:36:29 <joelteon> oh bottom
09:36:47 <jmcarthur> mangaba_1eitosa: anyway, in memory, [Word8] will actually be the same size as [Int], and it will require about the same amount of work to use.
09:36:56 <halpPlease234> FreeFull: but since it's a disjoint union, as you said, it doesn't matter
09:37:04 <jmcarthur> mangaba_1eitosa: due to the way ghc boxes and aligns
09:37:21 <khyperia> Never mind, fixed it, figured out I had to use the ssh url instead of the http one.
09:37:50 <jmcarthur> halpPlease234: sorry, i meant to address you when i talked about bits, not mangaba_1eitosa
09:38:04 <jmcarthur> got mixed up
09:38:35 <FreeFull> You could probably use unboxed vectors and get a memory saving
09:38:39 <jmcarthur> right
09:38:58 <halpPlease234> or you could use C :)
09:39:16 <jmcarthur> why?
09:39:27 <halpPlease234> if we're jumping that far down the rabbit hole, why not?
09:39:38 <jmcarthur> vectors are not far down the rabbit hole
09:39:48 <jmcarthur> it's just a normal haskell library
09:39:56 <halpPlease234> I mean saving very small amounts of memory
09:40:02 <jmcarthur> this is a big savings
09:40:17 <halpPlease234> is it?
09:40:25 <FreeFull> Word8 is 4 or 8 times smaller than Int
09:40:32 <halpPlease234> + list overhead, I guess
09:40:36 <jmcarthur> also the linked list stuff
09:40:42 <halpPlease234> + head boxing
09:40:44 <halpPlease234> heap*
09:41:07 <halpPlease234> why not parallelize it, too?
09:41:10 <jmcarthur> Nil costs a word. Cons costs three words.
09:41:16 <jmcarthur> plus the things you are holding
09:41:41 <mangaba_1eitosa> jmcarthur: thanks, that's what I can see after trying to use Word8 instead of Int (same performance)
09:42:52 <jmcarthur> so a linked list of 200000 Word8s on a 64 bit machine would cost ~4.5 MB, but an unboxed vector of Word8s would cost ~195 KB
09:43:15 <jmcarthur> oh, no, i'm wrong
09:43:19 <jmcarthur> linked list is even bigger
09:43:30 <jmcarthur> ~6.1 MB
09:43:38 <halpPlease234> jmcarthur: does that list cost include stg overhead?
09:44:30 <FreeFull> And this is why  type String = [Char]  is bad
09:45:20 <halpPlease234> haha, I thought the bigger problem with String = [Char] was to do with random access and ease of copying a linked list vs a block of memory
09:45:26 <jmcarthur> you mean info tables and such? i think so, but i don't remember
09:46:11 <halpPlease234> that's what I meant
09:46:14 <jmcarthur> halpPlease234: "copying" is a sign of doing something wrong anyway
09:46:42 <halpPlease234> why's that?
09:46:48 <jmcarthur> there are a number of tradeoffs involved with String = [Char]
09:47:04 <jmcarthur> copying means you aren't reaping the benefits of persistent data structures
09:47:33 <jmcarthur> persistent data structures are designed to share as much as possible
09:47:41 <halpPlease234> or maybe I have a 100mb string sitting around in memory because I reference a 10 character substring
09:47:46 <jmcarthur> so that you only need to reconstruct the parts that are changed
09:48:08 <jmcarthur> that is more likely with the array representation than the linked list one, actually
09:48:13 <halpPlease234> eh, be that as it may, pointers aren't so amenable to being strung together randomly
09:48:28 <jmcarthur> not sure what you mean.
09:48:37 <jmcarthur> are you talking about cache locality? gc?
09:48:40 <halpPlease234> text & bytestring require copying for most actions
09:48:48 <jmcarthur> that isn't true
09:48:55 <halpPlease234> no?
09:49:17 <Baughn> Bytestring doesn't copy to make substrings
09:49:26 <Baughn> You need to explicitly ask it to do that
09:49:27 <halpPlease234> no, it doesn't copy to make substrings
09:49:40 <jmcarthur> it depends, of course, but it's really easy to write zero-copy stuff with bytestrings
09:49:41 <halpPlease234> but if you want to append something to it, it makes a copy
09:49:44 <jmcarthur> yeah, this is a matter of "don't do that"
09:49:48 <halpPlease234> or if you want to take something out of the middle of a bytestring, it makes a copy
09:49:52 <jmcarthur> always use an appropriate data structure for the operations you need
09:49:55 <jmcarthur> no
09:50:00 <jmcarthur> that makes no copy
09:50:10 <Baughn> Mm, Builder or at least lazy bytestrings are a good place to start for appends
09:50:13 <jmcarthur> or wait, maybe i didn't understand the operation
09:50:41 <jmcarthur> if you mean extract substring, no copy. if you mean split it out of the original and stitch the beginning and end back together, yeah, copy
09:51:06 <jmcarthur> but this is what builder is for, to defer all that copying to just one big step at the end :)
09:51:36 <jmcarthur> also, this is nothing unique to haskell, and is also not any different from linked lists
09:51:45 <halpPlease234> linked lists don't have that problem :P
09:51:57 <jmcarthur> ?
09:51:58 <jmcarthur> they do.
09:52:01 <Baughn> Linked lists have different problems
09:53:05 <halpPlease234> yup
09:53:16 <jmcarthur> if you want to do this substring removal operation, you still have to copy the prefix
09:54:45 <Baughn> If you have solid arrays - bytestrings - you have one problem. If you're dealing with linked lists of bytes you have a different (and larger) problem.
09:55:28 <Baughn> But this is nothing unique to Haskell, you just have to use the right tool
09:55:28 <halpPlease234> jmcarthur: if I were unprincipled, I might be inclined to mutate the list
09:55:28 <jmcarthur> it's only the shared tail that you manage to share
09:55:28 <jmcarthur> err
09:55:28 <jmcarthur> s/to share/to avoid copying/
09:55:28 <jmcarthur> halpPlease234: ah, but then you can't even share tails! ;)
09:55:28 <Baughn> halpPlease234: There are ways of doing that
09:55:28 <halpPlease234> and what about a trie?
09:55:29 <Baughn> *Not* doing it has its advantages, of course
09:55:29 <jmcarthur> what about it?
09:55:29 <halpPlease234> could that give me the benefit of less list-constructing?
09:55:29 <jmcarthur> what does a trie have to do with a list, exactly?
09:55:29 <jmcarthur> i'm not sure i understand the idea
09:55:29 <monochrom> what is the purpose of this discussion? is it to find a rule of thumb, a solution that does not depend on the problem?
09:55:29 <halpPlease234> what if we stored strings as tries instead of linked lists?
09:55:29 <jmcarthur> i don't understand. tries are collections of strings, not just strings.
09:55:29 <FireFly> halpPlease234: is this about how to represent a (somewhat big) editable string?
09:55:29 <FireFly> (I missed the beginning of the discussion)
09:55:34 <Rarrikins> We'd have to store the path through the trie.
09:55:39 <halpPlease234> I'm not sure what this is about at this point.
09:55:55 <Rarrikins> Which would be somewhat the same as just storing the characters.
09:56:16 <FireFly> At any rate, I think ropes deserve a mention: http://en.wikipedia.org/wiki/Rope_(computer_science)
09:56:19 <halpPlease234> could you get away with storing fewer characters?
09:56:22 <halpPlease234> er
09:56:25 <halpPlease234> to rephrase
09:56:35 <FireFly> Very useful e.g. for text editors' buffers
09:56:42 <halpPlease234> could storing the path let you get away with storing less?
09:57:00 <halpPlease234> .. I guess you'd just be back at linked lists
09:57:03 <Rarrikins> halpPlease234: In some very limited circumstances.
09:57:52 <halpPlease234> Firefly, your link is missing the last ')' :O
09:59:16 <halpPlease234> Firefly: that's more along the lines of what I was thinking, to be honest
09:59:20 <FireFly> halpPlease234: it seems to be there for me.. might just be your IRC client not including it in the link
09:59:31 <halpPlease234> probably
10:00:13 <halpPlease234> is there a rope structure package for haskell?
10:00:51 <monochrom> I see ) there
10:00:54 <geekosaur> mine chops it at the ( fwiw
10:01:04 <monochrom> use the channel logs to verify what you see. there are two listed in the topic.
10:01:26 <geekosaur> (but I think I can control that. what's harder is getting it to distinguish between ) as part of the url and ) ending a parenthetical containing a url)
10:01:47 <FireFly> halpPlease234: there seems to be a kmett package 'rope', at least
10:02:28 <monochrom> sometimes this inspires me to suggest "irc should use html" :)
10:03:20 <halpPlease234> right, just like email :)
10:03:22 <monochrom> you may like: http://en.wikipedia.org/wiki/Rope_%28computer_science%29
10:03:32 <Faucelme> @unpl id
10:03:32 <lambdabot> (\ a -> a)
10:08:08 <Hafydd> <marquee>I think that's a great idea.</marquee>
10:08:24 <Faucelme> @pl \(x,y) -> ((++) x) (x ++  y)
10:08:24 <lambdabot> uncurry (liftM2 (.) (++) (++))
10:08:44 <halpPlease234> kmett's ropes even come with a comonad instance.. how thoughtful
10:14:09 <skypers> @index Comonad
10:14:09 <lambdabot> bzzt
10:14:12 <skypers> @hoogly Comonad
10:14:13 <lambdabot> package comonad
10:14:13 <lambdabot> package comonad-extras
10:14:13 <lambdabot> package comonad-random
10:14:17 <skypers> oh, I mistyped hoogle and it worked, ahah!
10:15:55 <skypers> does co-monad stand for contravariant monad?
10:16:50 <danharaj> no
10:16:51 <monochrom> you may like http://hackage.haskell.org/package/comonad-4.0/docs/Control-Comonad.html
10:17:33 <skypers> yeah I’m reading it
10:17:44 <skypers> but there’s nothing about extract, extend and so on
10:17:57 <jmcarthur> skypers: you get a comonad by flipping the arrows of join and return, but leaving fmap the same.
10:18:29 <monochrom> it is not going to be contravariant because it is still a functor, not a contravariant functor
10:18:40 <skypers> ok I see
10:18:46 <monochrom> the types and the laws are already everything
10:18:49 <triliyn> join :: (Comonad m) => m (m a) -> a?
10:18:58 <skypers> so hm
10:19:04 <triliyn> er
10:19:04 <jmcarthur> triliyn: we typically call it duplicate, but yes
10:19:06 <triliyn> m a at the end
10:19:08 <jmcarthur> triliyn: cojoin or somesuch
10:19:15 <triliyn> ...no, wait
10:19:16 <jmcarthur> oh
10:19:18 <skypers> extract just takes the inner type away from the Comonad?
10:19:22 <triliyn> I mangled that very badl
10:19:24 <triliyn> y
10:19:26 <jmcarthur> triliyn: let me restate from scratch. we both mangled it
10:19:31 <monochrom> if you want concrete examples, scroll down a bit to see the list of instances, then try to re-invent them yourself
10:19:34 <jmcarthur> triliyn:    join :: Monad m => m (m a) -> m a
10:19:46 <jmcarthur> triliyn: duplicate :: Comonad w => w a -> w (w a)
10:19:59 <triliyn> jmcarthur: right, that's what I was trying to do, I think
10:20:13 <skypers> ahahah
10:20:18 <skypers> sounds so obscure
10:20:26 <skypers> Comonadic fixed point à la Menendez
10:20:30 <skypers> wat.
10:20:32 <monochrom> for example Tree and (,)e should be accessible
10:20:34 <jmcarthur> also    return :: Monad m => a -> m a;  extract :: Comonad w => w a -> a
10:21:22 <skypers> yeah but
10:21:27 <skypers> oh
10:21:30 <FireFly> duality is all about flipping arrows
10:21:33 <skypers> Maybe a can’t be a Comonad, right?
10:21:39 <skypers> because extract Nothing would result in…
10:21:41 <skypers> nothing.
10:21:49 <danharaj> correct.
10:21:58 <skypers> ok
10:24:18 <halpPlease234> also, for what it's worth, the way I found to import c typedefs is through c2hs
10:26:28 <khyperia> chrisdone (or anyone else at fpcomplete, not sure who is), I'd like to add a package, but I've been scared by the 15 billion experimental/warning labels. If I try to add a package and something screws up, is there anything permanent that I need to worry about?
10:28:06 <klrr_> if im writing a spaceinvaders clone using FRP, does it make sense to make all invaders one entire unit with informations like which invaders are still alive , position, animation frame etc. or should i make each invader a single unit?
10:29:47 <mgsloan> khyperia: Hey! There's nothing permanent to worry about there
10:29:59 <khyperia> Alright, good.
10:30:05 <mgsloan> khyperia: The feature is just quite new, and there's still some little issues being worked out
10:31:33 <mgsloan> khyperia: Namely, we know that currently it's a bit opaque what's going on - there ought to be more feedback about progress / error messages from the build
10:31:51 <khyperia> Ah, right.
10:32:17 <mhsekhavat> @pl (\i g d -> g i > g (i+d))
10:32:17 <lambdabot> ap (ap . (((.) . (>)) .) . flip id) (flip (.) . (+))
10:32:31 <mhsekhavat> @pl (\g d i  -> g i > g (i+d))
10:32:31 <lambdabot> ap ((.) . liftM2 (>)) ((. (+)) . (.))
10:32:32 <mgsloan> khyperia: If something does seem to be permanently broken (if so, that sucks, doh!), you can use the "Restart Backend" button
10:32:44 <mgsloan> (also in the settings page)
10:34:18 <khyperia> Right. I just tried, and what I figured would be the case is what happened. I'm writing a compiler, and would like to use llvm-general, but obviously that requires llvm to be installed. Oh well.
10:36:28 <khyperia> although I only added llvm-general-pure, and it still failed on llvm-general, which I'm a bit confused about. *shrug*
10:37:42 <intrados> GHCi should work for armhf on version 7.6.3, right?
10:38:53 <mgsloan> khyperia: THat might be a good time to restart the backend
10:39:26 <mgsloan> khyperia: As for the library dependency, filing some feedback about it would probably be the best course
10:39:44 <mgsloan> we do try to add requested 3rd party dependencies
10:40:02 <khyperia> oh, so you would actually install llvm?
10:41:28 <mgsloan> Yup! But I can't guarantee that, though - I'm not too involved in that sort of stuff
10:41:45 <khyperia> Right, heh.
10:41:59 <mgsloan> It's definitely worth a shot, though - we've installed previous requests
10:43:10 <klrr_> in reactive-banana, if i have a event of type "Event ()" then how would i convert that to "Behaviour Bool" each time () happens?
10:50:23 <eevar> test-framework seems to just abort when I call C code that invokes assert. input isn't logged, or even which test was running. Would e.g. Tasty work better?
10:51:39 <eevar> upping the verbosity just seems to show me ghc switches it's using to compile my tests, no more useful info being printed/logged
10:52:53 <geekosaur> C's assert kills the process with SIGABRT
10:53:33 <Eduard_Munteanu> Can I just provide a header file to c2hs to have it generate bindings, assuming I might not need access to the defined structs, just the functions?
10:53:33 <eevar> in other words, you're saying that no haskell test framework will produce meaninful output?
10:53:40 <geekosaur> correct
10:54:00 <eevar> ok, thanks
10:54:03 <geekosaur> you're not going to be able to do very much with that
10:55:15 <geekosaur> you *could* set a SIGABRT handler, but there isn't a whole lot you can *do* from it
10:55:33 <eevar> i'll just write my input data to a file from the test code
10:55:36 <geekosaur> it's pretty much only useful for collecting a core dump or for when running under a debugger
10:55:37 <eevar> to narrow the issue down
11:12:09 <darthdeu> hey guys, anyone here using haskell-mode in emacs?
11:13:08 * hackagebot pipes-network 0.6.1 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.6.1 (RenzoCarbonara)
11:13:46 <kartoffelbrei> darthdeu: i do
11:14:57 <darthdeu> i found the problem :) my PATH isn't set
11:28:47 <Feuerbach> geekosaur: wouldn't it be possible at least to block the signal until the test completes, then print an error for that test ("SIGABRT received") and go on with the remaining tests?
11:29:46 <geekosaur> usually the C code will not behave properly if the assertion fails but execution continues. is catching SIGFPE or SIGSEGV or some other potentially non-recoverable error really better?
11:30:08 <geekosaur> I mean, if you're that desperate you can try it, but the result will almost certainly be even more wrong
11:30:25 <geekosaur> really you should force those kinds of tests to run in a subprocess
11:31:48 <brandonw> i'm having trouble understanding how to approach strictness. what would the best way to handle this be: https://github.com/brandonw/haskellbot/blob/master/Main.hs#L30
11:32:11 <brandonw> i want the cmd arg to be parsed into an integer (or fail) before it tries to connect to the server itself
11:34:14 <nomeata> brandonw: one way: in main, add a line "optPort opts `seq` return ()" before connecting
11:34:43 <Feuerbach> geekosaur: well, asserts are not supposed to be used for control flow (and are often optimized out anyway), which means that ignoring them may be not such a big deal
11:34:59 <brandonw> i read a little about seq, and there were some links on how it was bad on some cases because it breaks some the laws? is that something i dont need to worry about typically?
11:35:23 <Feuerbach> I'm just trying to understand if this is a sensible feature for a test framework to have (being an author of one of them). It looks so to me.
11:36:25 <monochrom> ohai nomeata, long time no see
11:36:40 <Feuerbach> perhaps triggerred by an option (to address your concern about sigfpe/sigsegv)?
11:37:12 <nomeata> monochrom: really? or just different IRC times, I guess...
11:37:20 <geekosaur> Feuerbach, asserts are for things that "shouldn
11:37:40 <nomeata> brandonw: from a practical point of view, not really
11:37:45 <geekosaur> 't happen". you can certainly disable them, but the result WON'T work correctly; that's why the assert exists
11:38:23 <geekosaur> if the function were prepared to handle whatever was triggering the assert, it would have a more graceful failure mode / error return in the first place, not an assert()
11:38:45 <monochrom> but I object to seq for this. (seq is suitable for other things.) this is not a strictness issue. this is a parsing issue. you should be using readMaybe (now in Text.Read, comes with GHC) and case. if you get a Just, you know that parsing is successful. does not have to be strict. (well it happens to be. that's a red herring.)
11:38:56 <nomeata> brandonw: although it would be cleaner to not rely on exceptions here, but use functions like readMaybe
11:39:04 <geekosaur> which is why ignoriung the assert / the SIGABRT is very likely to result in a different hard failure
11:39:08 <geekosaur> such as SIGSEGV
11:39:14 <nomeata> what monochrom says :-)
11:39:35 <brandonw> nomeata: readMaybe is exactly what i should use. thanks for the pointer
11:40:02 <brandonw> thanks for the tip nomeata & monochrom
11:40:24 <nomeata> Its just a bit annoying getting it into OptDescr (Options -> Options) (if you don’t want the Options field itself to be of type Maybe Int)
11:40:40 <geekosaur> (I suppose you "could" ignore that too, your program will just never do anything any more because it's getting the same signal over and over again continuously)
11:40:59 <geekosaur> (in other worse, when I say non-recoverable here I MEAN it)
11:41:21 <plcplc> I'm trying to make a type family of kind Constraint.. but just doing "type family Typ a b :: Constraint" (from chapter 7 in the ghc handbook..) has ghc trying to interpret "Constraint" as a type constructor or class... Am I missing something?
11:41:45 <piezoid> how can i test if an arbitrary monoid or a monadplus value is empty ?
11:41:53 <piezoid> (ListT . Identity $ ([] :: [Int])) == (mzero)  =>  "No instance for (Eq (ListT Identity Int))"
11:42:37 <FreeFull> piezoid: You can't without an Eq instance
11:42:41 <geekosaur> piezoid, afaik you can't. empty is not a constructor you can pattern match, you need Eq
11:42:45 <monochrom> plcplc: you need to import the name Constraint from GHC.Exts
11:42:58 <plcplc> monochrom: Oh!
11:43:05 <FreeFull> monochrom: It's possible?
11:43:16 <monochrom> what is possible?
11:43:27 <FreeFull> Oh wait, nevermind
11:43:33 <FreeFull> Confused your reply as reply for something else
11:43:52 <piezoid> FreeFull, geekosaur: ok, thanks
11:44:10 <gilligan_> evening
11:44:25 <m_univ> hello, could someone experienced do win executbale for me?
11:44:29 <m_univ> https://github.com/joelteon/haxparse
11:44:36 <m_univ> thx much
11:44:41 <joelteon> oh hi
11:44:41 <plcplc> monochrom: Thanks ever so much.
11:44:48 <joelteon> i made that
11:45:11 <plcplc> I wonder why the handbook doesn't mention that on the page for ConstraintKinds
11:45:31 <monochrom> yeah, I had to find out myself
11:45:35 <nomeata> plcplc: with handbook, you mean the user guide?
11:45:51 <gilligan_> Any vim users in here ? There doesn't seem to be any good indentation for haskell ? I'm using vim2hs which also features indentation. It doesn't even indent a simple 2 line source with a where clause correctly
11:46:01 <plcplc> nomeata: you're right. by handbook I mean user guide :-)
11:46:07 <m_univ> joelteon pls is is posibble do the win exe?
11:46:12 <nomeata> plcplc: ok, let me just fix this
11:46:13 <enthropy> plcplc: possibly because it used to work without that import?
11:46:44 <plcplc> enthropy: sounds plausible, but then it begs the question of what motivated GHC.Exts imho
11:46:50 <monochrom> well, it is not like Constraint had been a reserved word, ever.
11:47:43 <brandonw> nomeata: agreed. is there a way to handle arg parsing where there is a distinction between an optional option and a required option? so I could have no Maybes in the Options, and automatically have an error if a parameter was not specified, or specified incorrectly?
11:47:55 <plcplc> Ah yeah.. so using -XConstraintKinds could break programs that used to work even though they don't use constraint kinds
11:50:38 <nomeata> plcplc: http://git.haskell.org/ghc.git/commit/5c904ba055147e0a71d5b200c8886ef0b1a47794
11:50:58 <plcplc> nomeata: (a small confession is that I realise the docs i viewed are from 7.4.1, so I wouldn't know for sure if they have changed since)
11:51:26 <plcplc> nomeata: what wonderfull effectiveness :-)
11:53:11 * hackagebot lambda-devs 0.4.0 - a Paralell-DEVS implementaion based on distributed-process  http://hackage.haskell.org/package/lambda-devs-0.4.0 (alios)
11:54:08 <nomeata> brandonw: what I often use is for example OptDescr (Options -> IO Options), this way I can do error reporting right in the definition of the option, and also check if files are existing, or even opening files right away and having handles in Options.
11:54:57 <brandonw> oh right, i remember reading that from http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
11:55:05 <brandonw> that makes sense, thanks again nomeata
11:56:16 <m_univ> anyone could make win executable pls?
11:56:19 <m_univ> https://github.com/joelteon/haxparse
11:56:27 <Feuerbach> brandonw: also check out optparse-applicative; I love it
11:59:05 <brandonw> Feuerbach: i was initially looking over the list of arg parsing libs for haskell (wow htere are a lot). but i figured it would be better to get a grounding in the built in stuff first. then i could delve into more advanced libs as needed
11:59:37 <brandonw> optparse-applicative was the one i was biasing towards before deciding to use getopt
12:13:10 <Feuerbach> well, optparse-applicative is just more convenient to use
12:17:40 <SLi> Hey, I don't know if anyone uses the Stream package from hackage, but... I wondered, it says it provides streams similar to infinite lists, and indeed when I look at the documentation, it seems quite identical to list. So identical in fact that I wonder what's the point, why would anyone use these instead of lists :) Anyway, I started to look into streams because I have a case where I need to read a file (preferably lazily) and deep in the leaves of the
12:17:41 <SLi> computation I need to know the offset of the value in the file. Seems comonads are good for something like this?
12:17:59 <gilligan_> Still looking for any haskellers using vim - anyone? ;-)
12:18:09 <joelteon> gilligan_: I do
12:18:52 <gilligan_> joelteon, do you get proper indentation ? I use vim2hs but either the indentation is next to useless or i've messed something up
12:19:13 <joelteon> my haskell indentation is pretty good, shakespeare is patently dreadful
12:19:21 <joelteon> not sure which one I actually use
12:19:27 <joelteon> I'm gonna have to disable one plugin at a time
12:19:48 <gilligan_> joelteon, i don't even get correct indentation for a stupid 2 line function with a where clause
12:20:03 <gilligan_> joelteon, which haskell related functions do you use anyhow ?
12:20:06 <joelteon> where do you put the where
12:20:45 <gilligan_> joelteon, on a new line
12:21:40 <gilligan_> joelteon, http://lpaste.net/6550023017018163200
12:21:53 <joelteon> what's the problem there?
12:22:06 <gilligan_> joelteon, well that is me indenting it correctly hehe
12:22:19 <t4nk310> https://github.com/joelteon/haxparse
12:22:25 <gilligan_> joelteon, indentation will just put everything to the first column :)
12:22:25 <joelteon> ok but I'm not sure what the problem is
12:22:31 <joelteon> yeah, it won't auto-indent the where
12:22:33 <joelteon> I don't know how to do that
12:22:40 <t4nk310> anyone do win executable of this pls?
12:22:44 <joelteon> if you put the where at the end of the first line, it'll indent the following bindings properly
12:23:03 <joelteon> I should learn vim indentation because I would like to make a decent haskell indenter
12:23:14 <joelteon> and shakespeare :P
12:23:45 <donri> merijn: did anything come of your vim indent adventures?
12:24:43 <radish> io question: if I wanted to have a function that returns True or False based on some io stuff, would i use {do a <- fn', if (var) ...} or {if (fn) ... where fn = do {a <- fn', return a}} or are they the same?
12:25:19 <joelteon> radish: do { a <- f; return a } === f
12:25:32 <donri> i need to try dolio's hindley thing
12:25:33 <radish> do {a <- fn, if (a)} ... OR if (fn) ... where fn = do {a <- fn', return a}
12:25:50 <joelteon> if doesn't take IO Bool
12:26:12 <radish> joelteon: it would inside do block though right?
12:26:25 <joelteon> no
12:26:30 <joelteon> the first option is your only option
12:26:37 <radish> are you sure? I could swear i've been doing that lol
12:27:02 <joelteon> ok, then try the scond
12:27:02 <massou> Hi,
12:27:06 <joelteon> second*
12:27:17 <massou> I could need some help wrapping my head around the definition of 'sequence'
12:27:26 <radish> joelteon: okay. i'm just a bit confused about calling an io as if its a regular function by dumping it inside a definition for said regular function
12:27:31 <massou> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#sequence
12:27:40 <massou> How do I read the 'where' clause?
12:28:05 <massou> sequence ms = foldr k (return []) ms             where               k m m' = do { x <- m; xs <- m'; return (x:xs) }
12:28:07 <joelteon> that's a not very intuitively written function
12:28:09 <joelteon> and I don't know why
12:28:11 <joelteon> someone here probobly k nows
12:28:13 <joelteon> probably knows
12:28:30 <joelteon> something something laziness
12:28:38 <radish> joelteon: i believe you i'm just confused lol - so like, i'm curious as to how you would differentiate a kind of set definition with an io function definition
12:28:51 <joelteon> i don't understand the question
12:29:08 <radish> joelteon: mine or massou's?
12:29:09 <donri> massou: what part confuses you?
12:29:17 <joelteon> yours
12:29:37 <massou> donri: I'm confused about the "k m m' " part
12:29:48 <joelteon> k m m' is just a local definition of a function k
12:29:49 <donri> massou: it's the function passed to foldr
12:29:50 <donri> :t foldr
12:29:51 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:30:17 <massou> okay, I get that k is passed to foldr
12:30:31 <merijn> donri: Well, I'm still using the indent plugin, but I haven't done much on it in a while, since I've been busy moving, working, etc. so haven't had a lot of time to work on the more complicated issues
12:30:49 <radish> joelteon: say you have some io that returns True then False then True and so on. I know you could do like repeat [True, False] or whatever, but bear with me. so this function, you want to get a value and use it twice, or you want to use the function twice but get difference results, how would you write those differently - I think it has to do with <- being done only once, right?
12:31:10 <donri> merijn: it's so hard, yeah? you can sorta make it do your personal preferred style but there are so many possible styles :p
12:31:27 <massou> but where does 'm' then come from?
12:31:35 * donri currently just uses no fancy indent stuff except autoindent
12:31:37 <massou> I have a hard time parsing that function in my head
12:31:42 <massou> it looks like magic to me...
12:31:59 <joelteon> radish: consider do { putStrLn "Hello world!"; putStrLn "Hello world!" }; vs let f = putStrLn "Hello world!"; do { f; f }
12:32:03 <merijn> donri: I never planned to support anything but my personal style
12:32:22 <merijn> donri: Anything that accomodates others is on a strict "as long as it's not too inconvenient to implement" basies
12:32:24 <radish> joelteon: that's the same?
12:32:28 <joelteon> those are the same thing
12:33:31 <radish> joelteon: yeah but see neither of those change value. that's the part that confuses me.
12:34:01 <joelteon> your mental model of IO is flawed
12:34:16 <joelteon> in 'let f = putStrLn "Hello world!"', f is free to never be evaluated
12:34:35 <joelteon> think of f as a computation that can *at some point* be performed
12:34:42 <joelteon> but the only way to actually perform it is to bind it to main somehow
12:34:57 <radish> joelteon: i see that.
12:35:01 <joelteon> okay
12:35:11 <radish> joelteon: say you have some io that counts the number of times it was called
12:35:31 <joelteon> okay
12:35:47 <joelteon> well
12:36:09 <radish> joelteon: if you have do {a <- fn; print a; print a} it prints 1 twice right?
12:36:11 <joelteon> if takes a Bool, not an IO Bool; to test the condition returned by the computation, you'll need to use >>=
12:36:25 <joelteon> yes
12:36:31 <joelteon> if fn returns 1
12:36:34 <radish> joel: wait even inside do?
12:36:35 <joelteon> or "IO 1"
12:36:40 <joelteon> no
12:36:48 <joelteon> you'll need >>=/<-, they're the same thing
12:36:53 <donri> massou: k :: m a -> m [a] -> m [a]
12:37:15 <radish> joel: do { if {-IOBool-} ... } doesn't work?
12:37:24 <radish> joelteon: do { if {-IOBool-} ... } doesn't work?
12:37:25 <joelteon> no
12:37:28 <joelteon> have you tried it?
12:37:40 <radish> joelteon: oh no i get it
12:37:59 <radish> joelteon: but do {a <- fn; if a ...} /would/ work.
12:38:05 <joelteon> yeah
12:38:13 <joelteon> that's what ifM is for
12:38:16 <radish> joelteon: well that's what i meant earlier lol
12:38:19 <joelteon> ok
12:38:27 <radish> joelteon: must've typoed lol
12:39:17 <radish> joelteon: i'm just confused as to how deep you can nest <- in function definitions and still get a different result every time. v
12:39:51 <radish> joelteon: i think it's just inside the do block do fn = do { a <- fn; return a } would be different every time even though fn could be called purely?
12:40:07 <radish> joelteon: or at least with the appearance of purity?
12:40:20 <radish> i looped that i'm sorry
12:40:21 <tdammers> radish: <- is just part of the syntactic sugar of do blocks
12:40:31 <tdammers> I suggest you learn to desugar by hand
12:40:31 <merijn> I keep forgetting, what's the haskell version of ceil?
12:40:46 <radish> foo = { x <- bar; return x }
12:40:48 <donri> :t ceiling
12:40:48 <lambdabot> (Integral b, RealFrac a) => a -> b
12:40:59 <merijn> donri: Thanks
12:40:59 <radish> tdammers: i'm learning that, yes.
12:41:06 <tdammers> ah, OK then
12:41:24 <tdammers> in that case, the answer to your question ("how deeply can you nest <-") can be found by desugaring
12:41:32 <radish> basically foo = { bar >>= return }
12:41:36 <radish> yes?
12:41:54 <tdammers> pretty much, yes
12:42:04 <radish> tdammers: pretty sure that last statement just confuses me more lol :)
12:42:08 <tdammers> although `return` is maybe a pathological example
12:42:20 <tdammers> :t (>>= return)
12:42:20 <lambdabot> Monad m => m b -> m b
12:42:33 <radish> tdammers: i get that. i was a bit worried you were gonna point that out lol
12:42:49 <radish> tdammers: kind of like id for monads right?
12:42:53 <tdammers> yes
12:43:09 <radish> joelteon: i think though you might've helped me enough. something rattling around in my brain, i'll play with it and if i have more questions i'll come back.  thank you. :)
12:43:10 <merijn> radish: My usual beginner advice is to not use do-syntax and just >>=  until you understand it that way
12:43:15 * hackagebot tabular 0.2.2.5 - Two-dimensional data tables with rendering functions  http://hackage.haskell.org/package/tabular-0.2.2.5 (EricKow)
12:43:31 <radish> tdammers: and thank you too good sir, i appreciate the help
12:43:33 <merijn> radish: That, and learn the rules for the do notation sugar, they're not very hard
12:43:33 <tdammers> yeah... approach monads from the monoid angle
12:43:48 <radish> merijn: i'm getting it.
12:43:57 <radish> tdammers: still no clue what a monad or monoid are.
12:44:07 <tdammers> monoids are easy :D
12:44:21 <joelteon> yeah monoids are super easy
12:44:27 <tdammers> basically, you have a binary operation and a neutral element
12:44:30 <tdammers> that's pretty much it
12:44:32 <joelteon> they sound like monads but the similarity is only in the name and in category theory
12:44:36 <Taneb> I love monoids, they're so easy
12:44:40 <tdammers> there's technically more to them, but that's the gist
12:44:48 <radish> tdammers: i watched a google video of this haskell guy explaining monoids called something like 'don't fear the monad' or something -- did not follow at alll lol
12:44:59 <geekosaur> monoid /= monad
12:45:06 <joelteon> > "hello " <> "world!"
12:45:07 <lambdabot>   "hello world!"
12:45:16 <joelteon> > mempty :: String
12:45:17 <lambdabot>   ""
12:45:22 <joelteon> there's a good example
12:45:28 <radish> geekosaur: yep, didn't follow :)
12:45:30 <joelteon> (<>) is mappend
12:45:31 <merijn> radish: I can tell you you know at least three monois already
12:45:44 <radish> marijn: wouldn't be able to name them on a bet lol
12:45:48 <identity> most people 'know' a bunch of monoids
12:45:49 <Qfwfq> The Beckman video rightfully analogises monoids to monads, is radish's point.
12:45:51 <identity> they just don't know they're monoids
12:45:59 <merijn> radish: A monoid has 1) a neutral element 2) an associative operation and 3) some laws
12:46:01 <briennetheblue> if i have a strict function that's defined as a big case statement from contiguous ints to ints is there any advantage to replacing the case statement with indexing into an unboxed array?  or do they both compile down to something similar
12:46:24 <radish> thanks for help everyone i'll get it soon enough
12:46:25 <donri> merijn: aren't 1) and 2) pretty much the laws? :p
12:46:27 <radish> y'all are great.
12:46:38 <joelteon> nah, (<> mempty) is id or something
12:46:41 <merijn> donri: No, you have "a * e = a = e * a"
12:46:47 <joelteon> yeah that
12:47:00 <Qfwfq> donri: Well, closure. The neutral element must be left and right identity.
12:47:21 <merijn> radish: In haskell the neutral element is called "mempty" (monoid empty) and the associative operations is called "mappend" (monoid append)
12:47:22 <geekosaur> briennetheblue, they should compile down to pretty much the same thing (and if you discover they don't you shoud report a ghc bug)
12:47:25 <donri> merijn: what?
12:47:37 <identity> it's associative, not commutative
12:47:38 <briennetheblue> geekosaur: thanks
12:47:55 <Qfwfq> donri: let e = mempty, and a be an arbitary member of the monoid's set.
12:47:58 <merijn> Oh, wait I messed that up
12:48:04 <merijn> or did I?
12:48:07 <identity> oh, nvm
12:48:09 <identity> no, you didn't
12:48:13 <merijn> No, I didn't
12:48:16 * hackagebot pipes-binary 0.2.1 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.2.1 (RenzoCarbonara)
12:48:19 <identity> left and right identity, yup
12:48:28 <donri> merijn: what you gave me was the definition of the neutral element, not a new law :)
12:49:00 <Qfwfq> identity: You mean there are at least two of you?
12:49:04 <merijn> radish: The laws are "mappend mempty x == x == mappend x mempty" and "mappend x (mappend y z) == mappend (mappend x y) z"
12:49:34 <identity> Qfwfq: haha. In my head, there are several
12:49:51 <cschneid> merijn: can haskell / types / quickcheck automatically check that kind of law against instances you write?
12:49:51 <Qfwfq> identity: A terrible case of confused identity.
12:50:02 <merijn> radish: The three examples you know are: natural numbers and addition (the operation is +, the neutral element is 0), natural numbers and multiplication (the operation is *, the neutral element is 1) and lists(operation is concatenation, empty element is empty list)
12:50:08 <cschneid> merijn: I figure quickcheck could, but are there pre-built checks for that kind of thing out there?
12:50:10 <merijn> cschneid: Unfortunately not
12:50:29 <donri> sure there are
12:50:32 <merijn> cschneid: QuickCheck can test things, of course and there's some ideas on extending GHC with an automatic "law" checker
12:50:41 <identity> there's also the closure law, but that is embedded in the type system
12:51:06 <cschneid> Quickcheck could test those two monoid laws, after you write a sufficiently good random instance for QC
12:51:15 <Qfwfq> *cough*dependent types*cough*
12:51:17 <merijn> cschneid: Well, You can maybe encode them using type level hacks to simulate dependent types. But you can't trivially do it in haskell
12:52:10 <radish> yeah i'm just gonna pretend like all that sounds as straightforward as you guys act like it does :)
12:52:14 <Qfwfq> Heh, you can define an Eq instance for function if the domain is bounded. :P
12:52:15 <donri> https://hackage.haskell.org/package/ClassLaws
12:52:33 <donri> https://hackage.haskell.org/package/checkers
12:52:35 <cschneid> yeah, like this: http://hackage.haskell.org/package/quickcheck-properties-0.1/docs/Test-QuickCheck-Property-Monoid.html
12:52:55 <joelteon> is there really not an ifM in Control.Monad
12:53:09 <donri> :t when
12:53:09 <lambdabot> Monad m => Bool -> m () -> m ()
12:53:11 <sipa> :t when
12:53:11 <lambdabot> Monad m => Bool -> m () -> m ()
12:53:12 <Qfwfq> radish: Go read byorgey's paper on diagrams, it's really good. http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
12:53:25 <joelteon> that's not at all like ifM
12:53:39 <joelteon> @let ifM m a b = do { c <- m; if c then a else b }
12:53:40 <lambdabot>  Defined.
12:53:41 <joelteon> :t ifM
12:53:42 <lambdabot> Monad m => m Bool -> m b -> m b -> m b
12:54:11 <donri> :t liftA3 bool
12:54:12 <lambdabot> Not in scope: `bool'
12:54:30 <joelteon> :t liftA3 if'
12:54:30 <lambdabot>     Not in scope: if'
12:54:31 <lambdabot>     Perhaps you meant one of these:
12:54:31 <lambdabot>       `ifM' (line 154), f' (imported from Debug.SimpleReflect)
12:54:50 <donri> :t liftA3 \false true p -> if p then true else false
12:54:50 <lambdabot> parse error on input `\'
12:54:57 <donri> :t liftA3 $ \false true p -> if p then true else false
12:54:57 <lambdabot> Applicative f => f d -> f d -> f Bool -> f d
12:55:13 <magnap> :t liftM3 $ \false true p -> if p then true else false
12:55:14 <lambdabot> Monad m => m r -> m r -> m Bool -> m r
12:55:21 <donri> bool is in Data.Bool in ghc 7.8
12:56:19 <magnap> @let if'' = \ p true false = if p then true else false
12:56:19 <lambdabot>  Parse failed: Parse error: =
12:56:37 <geekosaur> second one should be ->
12:56:43 <magnap> @let if'' = \ p true false -> if p then true else false
12:56:44 <lambdabot>  Defined.
12:56:50 <magnap> Oh, thanks, lambda fail.
12:57:00 <Hermit> radish: think of monoids as stuff of a same type that you can combine. To do that, you need 2 elements, and a combination operation. If your "stuff" is integers, then you can combine say 3 and 5, with addition, or multiplication if you wish. Monoids also define an "empty" value, which varies according to the concrete type you are using and the kind of monoid you are treating it as.
12:57:00 <magnap> :t liftM3 if''
12:57:00 <lambdabot> Monad m => m Bool -> m r -> m r -> m r
12:57:30 <magnap> There you are, joelteon! All the monady goodness you could ever image.
12:58:31 <danbst> [Q] http://stackoverflow.com/questions/20180764/how-can-i-get-ptr-of-a-bytestring
13:00:07 <FreeFull> :t if''
13:00:08 <lambdabot> Bool -> t -> t -> t
13:00:14 <FreeFull> :t if'
13:00:14 <lambdabot>     Not in scope: if'
13:00:15 <lambdabot>     Perhaps you meant one of these:
13:00:15 <lambdabot>       if'' (line 151), `ifM' (line 155),
13:00:21 <FreeFull> :t ifM
13:00:21 <lambdabot> Monad m => m Bool -> m b -> m b -> m b
13:00:36 <donri> danbst: you sure you don't want useAsCString?
13:00:44 <lpaste> Magnap pasted “Spam, ham and eggs” at http://lpaste.net/96150
13:01:13 <lpaste> Magnap revised “Spam, ham and eggs”: “No title” at http://lpaste.net/96150
13:01:23 <danbst> donri, don't know, but I want to use that pointer as source for OpenGL texture
13:01:31 <magnap> What am I doing wrong here?
13:03:02 <identity> magnap: looks like "DB" isn't the right type
13:03:21 <identity> magnap: or rather, you may want to switch the 'arguments' around
13:03:29 <magnap> DB is a type synonym for (Map String (Int,Int))
13:03:31 <identity> DMap.lookup db string
13:03:42 <identity> that'd be my guess anyway
13:04:10 <donri> danbst: hm what functions should i be looking at in opengl for that
13:04:35 <danbst> donri, GL.texImage2D
13:04:44 <identity> magnap: yes?
13:04:44 <donri> oh god opengl has the worst module hierarchy ever
13:04:45 <magnap> According to hoogle, the type of DMap.lookup is k -> Map k a -> Maybe a, so shouldnt i use lookup key db?
13:04:46 <donri> Graphics.Rendering.OpenGL.GL.FramebufferObjects.FramebufferObjects
13:05:18 <danbst> donri, last parameter is PixelData
13:05:24 <identity> magnap: it would indeed seem so.
13:05:34 <danbst> which requires a pointer
13:05:50 <magnap> Would it help having spamProbability' ?
13:06:35 <donri> danbst: ah well CString is a Ptr CChar, where CChar is a newtype around Int8
13:06:42 <identity> magnap: but it's hard to tell what you're doing wrong without the rest of the code. It's specifically pointing out the second argument to lookup, namely 'db'
13:06:53 <merijn> donri: On common architectures!
13:07:11 <merijn> donri: I would not rely on CChar being Int8 if you wanna be portable :p
13:07:39 <merijn> donri: On account of C 1) not specifying the number of bits in a char and 2) not specifying the signedness of char
13:07:59 <donri> oh ok, was just looking at the haddocks
13:08:04 <donri> but guess those are full of ifdefs
13:08:11 <lpaste> Magnap revised “Spam, ham and eggs”: “Spam, spam, bacon and eggs.” at http://lpaste.net/96150
13:08:34 <magnap> This one has all the code where the function is being used.
13:09:02 <Eduard_Munteanu> Does the 'glib' package support gobject introspection?
13:10:16 <identity> magnap: is the call to spamProbability inside itself intentional, or is it supposed to be spamProbability'
13:10:19 <identity> ?
13:10:50 <magnap> Aaah, thanks! That's the error!
13:11:06 <magnap> Any ideas for more sensible names for those functions?
13:12:16 <identity> magnap: Well, heh, it's hard to say as its your code. I often do something similar, but sometimes, the real 'helper' function that does the work is called "go" or something like that
13:12:31 <danbst> donri, useAsCString does copying. I'd like to use memory of ByteString...
13:12:33 <identity> there are a few common idioms, most of which I can't really remember, for such things
13:12:50 <magnap> Maybe (ha!) call the prime (no ') -Handler
13:13:25 <magnap> Or visa versa actually
13:13:27 <lpaste> piezoid pasted “Parallel parsing with Parsec” at http://lpaste.net/96153
13:13:47 <piezoid> my paralell parser kinda works, but I can't keep both results and error messages with MonadPlus...
13:13:54 <identity> magnap: For my own silly purposes, it's often just silly names.
13:13:59 <donri> danbst: https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Unsafe.html#g:2
13:14:00 <identity> "doWorkSon"
13:14:45 <Eduard_Munteanu> Hm, I think it doesn't support introspection. :(
13:14:48 <edwardk> FireFly: rope was an experiment, not sure i like the final design, but it led to the notion of ropes i used in trifecta
13:14:49 <magnap> identity: CI (chuckling internally, alternative to LOL)
13:14:55 <aranea> How can it be that a bug in pure part of my code is only triggered when I compile the program and run if from the shell, but not when I load it into ghci and run it via ":main"?
13:15:29 <danbst> donri: thanks
13:15:52 <monoidal> aranea: maybe buffering?
13:16:46 <aranea> monoidal: I disable buffering on stdin and stdout
13:17:04 <Eduard_Munteanu> But does it offer something extra for FFI?
13:17:14 <aranea> monoidal: I guess I'll upload the code, the bug's very strange
13:18:58 <FireFly> edwardk: oh, okay
13:19:19 <derekv> now playing: trying to learn how to deal with monadic programming without having liftIO $ etc polluting everything everywhere allways
13:21:56 <benzrf> i
13:22:00 <benzrf> think i GET state monad
13:22:04 <benzrf> :D
13:22:04 <Raydiation> lets say i have a solve function, that has a -> b. how do i make this generic?
13:22:49 <Hodapp> benzrf: But is the state monad which can be gotten not the true state monad?
13:22:53 <benzrf> Raydiation: what do you mean by 'solve function
13:23:06 <Raydiation> in java id use public <T, V> static V solve(T value)
13:23:19 <Raydiation> T goes on V comes out
13:23:42 <Raydiation> i want to have a seperate function that fits that interface
13:24:03 <derekv> when I read about the state monad, i thought "Ok this is like what I was doing all along in an imperitive language if you think of all the variables in scope as being in one object, on which your carrying out a chain of transforms"
13:24:18 <Raydiation> for instance a solve function for mergesort of ints, public static int solve(int value)
13:24:19 <benzrf> well i mean the types et
13:24:20 <khyperia> Raydiation, that exact java example translated to haskell would be "solve :: t -> v"
13:24:21 <benzrf> c
13:24:23 <Hodapp> Raydiation: Why not... solve :: t -> v?
13:24:30 <Hodapp> GAH
13:24:31 <aranea> monoidal: https://github.com/atlaua/hbf/archive/pu/optimizer.zip . The bug is triggered with "make test", but not with ghci: > :l test/math.hs > :main. Also it is not triggered if "Val" in HBF.Types is changed to Word{8,16,32,64} or Int, it only appears with Word.
13:24:34 * Hodapp pushes khyperia over
13:24:39 <khyperia> :P
13:24:55 <Raydiation> do i need a seperate data type for that?
13:25:06 <benzrf> Raydiation: why would you need one?
13:25:15 <benzrf> just use 'a -> b' or 't -> v'
13:25:18 <external-reality> @derekv, go on...
13:25:19 <lambdabot> Unknown command, try @list
13:25:25 <Raydiation> what if both types are the same?
13:25:35 <benzrf> Raydiation: then a -> b still works
13:25:36 <Raydiation> in java i *had* to cast
13:25:41 <benzrf> i can have an equation a + b = 2
13:25:45 <benzrf> and a and b can be 1 both
13:25:46 <benzrf> or notdan
13:25:47 <benzrf> *not
13:25:48 <piezoid> Raydiation: to actualy do something with t, you have to constrain the type, for example :
13:25:50 <piezoid> :t (+)
13:25:50 <aranea> for sure, this isn't only a question to monoidal. If someone else can have a look at it, I'd be grateful as well ;)
13:25:51 <lambdabot> Num a => a -> a -> a
13:25:57 <benzrf> a + a = 2, both MUST be the same
13:25:58 <piezoid> is a generic function
13:26:08 <benzrf> diff names does not imply different values
13:26:11 <benzrf> just not necessarily the same
13:26:24 <benzrf> same value IF same name
13:26:25 <benzrf> not iff
13:26:56 <Eduard_Munteanu> Is there a library that provides data structures for interfacing Haskell and C code? E.g. linked lists.
13:27:05 <benzrf> aranea: do you like spiders?
13:27:17 <Raydiation> so basically what im interested in is: i had to implement the divide and conquer algorithm in java 8 (with lambdas and SAMs)
13:27:26 <benzrf> sup lorax
13:27:33 <benzrf> oh its a bot
13:27:35 <benzrf> thelorax123: help
13:28:00 <Eduard_Munteanu> benzrf: did it spam you privately?
13:28:03 <benzrf> no
13:28:06 <benzrf> notice the ident
13:28:10 <benzrf> or w/e it's called
13:28:13 <benzrf> 16:15 -!- thelorax123 [~nodebot@165.225.138.217] has joined #haskell
13:28:18 <Eduard_Munteanu> Ah.
13:28:25 <derekv> external-reality: thats it.  I was responding to benzrf.
13:28:29 <Raydiation> https://dpaste.de/L0Iv
13:28:33 <Raydiation> basically this
13:28:45 <Raydiation> and i dont know how the functions would translate to haskell
13:29:22 <Jeanne-Kamikaze> you have the types written towards the end ?
13:30:19 <FireFly> Raydiation: are you familiar with typeclasses?
13:30:28 <monoidal> areanea: possible ideas (1) you run make test with -O2, ghci does not use -O (2) quickcheck is randomized, and the RNG somehow is not initialized with ghci
13:31:05 <external-reality> derekv: ah, it sounded like you were going to share more. I was interested. :-)
13:31:15 <Raydiation> FireFly: not really
13:31:21 <Raydiation> would i do that with a type class?
13:31:30 <monoidal> aranea: anyway, I seem to get the quickcheck fail both on "make test" and ghci
13:31:55 <aranea> monoidal: I already tried to compile without -O2
13:32:00 <lpaste> wereHamster pasted “Not in scope: `catch', Failed to install mtl-2.0.1.0” at http://lpaste.net/96154
13:32:08 <wereHamster> guys, what do I do now?
13:32:09 <wereHamster> ^^^
13:32:13 <aranea> aranea: you also get it with ghci? Which ghc version are you running?
13:32:17 <wereHamster> that lpaste is from me
13:32:19 <aranea> benzrf: ;)
13:32:20 <monoidal> aranea: 7.6.3
13:32:34 <aranea> so do I
13:32:36 <aranea> hmm
13:32:45 <monoidal> aranea: quickcheck-2.6
13:32:55 <derekv> external-reality: I didn't really study the state monad much or use it much yet.  so this might be off base
13:33:07 <FireFly> Raydiation: I think I would, anyway. A type class is basically a set of types that all satisfy some set of specified functions, so they are a bit similar to interfaces (though some people in here would probably beat me for saying the two have similarities)
13:33:34 <monoidal> wereHamster: this seems to be an old version of mtl which is not supported by newer ghc
13:33:35 <FireFly> Raydiation: anyway, if you haven't I recommend you check out learn you a haskell, it's a great intro to Haskell (and it explains typeclasses a few chapters in)
13:33:39 <FireFly> @where lyah
13:33:39 <lambdabot> http://www.learnyouahaskell.com/
13:33:45 <Raydiation> FireFly: ty
13:33:52 <aranea> monoidal: I also get this error if I compile hbf.hs and run it with the input from test/math.hs, so it can't be quickcheck
13:33:57 <derekv> external-reality: picture a machine with only two data registers, it loads up a program with 10 instructions, each one changes those registers
13:34:18 <derekv> the value of the registers at the start of each instruction is a state of the machine
13:34:35 <external-reality> derekv: ok
13:34:43 <derekv> if you stepped one instruction at a time, you could get 10 states
13:34:51 <wereHamster> monoidal, I have ghc 7.6.3 installed by a system package (arch linux). mtl 2.1.0 is installed in /usr/lib/ghc-7.6.3/package.conf.d
13:35:24 <derekv> you could think of each instruction as a function mapping from one state to anouther
13:35:25 <wereHamster> sorry, 2.1.2 is in /usr/lib/...
13:35:28 <monoidal> wereHamster: try to use 2.1.2 then
13:36:05 <monoidal> wereHamster: if some library has a <2.1 constraint you might try to edit the .cabal file
13:36:16 <wereHamster> monoidal: I have on version restrictions on packages listed in my .cabal file. I assume cabal automatically takes the latest available then
13:36:22 <wereHamster> *no* verison restrictions
13:36:58 <monoidal> wereHamster: maybe some packages you list have those restrictions? otherwise I don't know
13:37:08 <wereHamster> how do I print the dependency tree?
13:38:20 * hackagebot digestive-functors-heist 0.8.1.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.1.0 (JasperVanDerJeugt)
13:38:35 <osa1> does anyone have a script or something like that to upload a package to hackage?
13:39:41 <FireFly> Raydiation: oh, reading a bit more closely it seems I (and maybe you) misunderstood the task.  I think you are to implement a function `divideAndConquer` which accepts the other four functions (as well as the input to the problem) as input
13:40:08 <FireFly> Raydiation: and someone calling the `divideAndConquer` function would pass in functions with concrete types in place of the type variables a/b
13:40:56 <external-reality> derekv: Yes. So I could model state as passing in the contents of the registers to our function call that s computing a return value lets say v along with the new state
13:41:41 <external-reality> So we have  s -> (s,v)
13:41:51 <external-reality> which is pretty much the state monad
13:42:09 <Raydiation> FireFly: yeah, my solution is this btw https://dpaste.de/4tqG#L39,104
13:43:13 <external-reality> @ the state monad lets you reflect that some stateful computation is going in the type of the function.
13:43:19 <aranea> monoidal: pattern matching on (-1 :: Word) seems only to work in ghci, not in compiled programs. However, it does work with Word64.
13:44:35 <tdammers> osa1: you mean, something more than cabal sdist / cabal upload?
13:44:45 <monoidal> aranea: you can match on x | x == (maxBound :: Word) instead
13:44:53 <FireFly> Raydiation: http://lpaste.net/96155 here's the outline of the function
13:45:06 <external-reality> derekv: Just a userful tool to let the reader of the program know that you wish to view some data as state in that it is to be threaded functional calls and changed in each on of those function calls.
13:45:18 <skypers> ok, comonads sound to be great!
13:45:27 <aranea> yes, I'll do that. But it sounds strange
13:45:29 <Raydiation> FireFly: ty
13:45:37 <derekv> external-reality: yea exactly how I was thinking
13:45:44 <Raydiation> so basically i pass these functions and haskell just checks if all the types line up right?
13:45:59 <external-reality> derekv: we can compare that to OO classes such that some of the classes may not make use of the state and thus should not be a part of the class IMHO but are anyway.
13:46:28 <skypers> I wonder how many abstractions exist. I know Arrow, Functor, Applicative, Contravariant, Bifunctor, Profoncteur, Semigroup, Monoid, and so on but, is there a list somewhere ?
13:46:29 <external-reality> *some the the class's methods
13:46:34 <monoidal> aranea: in HEAD you get a warning with -1 :: Word, I think it might be undefined behavior
13:46:35 <FireFly> Raydiation: well, you pass these functions in, and the type variables get instantiated by whatever types the function the caller passes in has. So basically, yes
13:46:43 <Raydiation> oh great ty
13:46:51 <osa1> tdammers: whoa wait we have cabal upload??
13:46:55 <external-reality> derekv: just my two cents.
13:47:19 <tdammers> osa1: been there for ages
13:47:20 <derekv> external-reality: sortof related yea...
13:48:09 <derekv> external-reality: in an imperitive language (OO or not) your "state" is basically the composit of all the scopes you currently can access
13:48:21 * hackagebot language-lua 0.2.2 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.2.2 (OmerAgacan)
13:48:25 <aranea> monoidal: good to know. Thanks!
13:48:26 <monoidal> aranea: if you can make a small test case, I can check head
13:48:42 <derekv> external-reality: I mean, the current values of those variables, as if you were stepping with a debugger
13:48:52 <monoidal> aranea: does it work with maxBound :: Word?
13:49:29 <derekv> external-reality: stepping with a debugger in an IDE, you see a window called "variables" ... thats somewhat like a state monad value right?  I don't know, just the way I was thinking about things, but I'm just learning this stuff
13:50:30 <khyperia> I find it interesting that you can translate any imperative program into SSA form with phi nodes.
13:50:53 <wereHamster> how do I list all the packages and versions in a cabal sandbox?
13:51:12 <skypers> oooh
13:51:15 <skypers> that’s sweet
13:51:32 <skypers> we can make weak lens with comonads!
13:51:41 <edwardk> ?
13:51:49 <skypers> > (show . snd) <<= (1,2)
13:51:50 <lambdabot>   Not in scope: `<<='
13:51:50 <lambdabot>  Perhaps you meant one of these:
13:51:50 <lambdabot>    `<=' (imported from...
13:52:05 <skypers> oh, no Comonad in lambdabot ?
13:52:17 <skypers> so hm
13:52:49 <skypers> (1,2) =>> (snd . show) might work as well
13:52:51 <external-reality> derekv: Although, the touchy part comes when we consider the fact that state can be shared amongst different scopes.
13:52:55 <external-reality> so to speak.
13:53:18 <wereHamster> so, apparently adding 'pool' as a dependency *downgrades* mtl, even though pool itself has only lower bounds on package versions
13:53:52 <aranea> monoidal: even == -1 worked. I'll have a look at it Monday or Tuesday and write a testcase, now I've got to go.
13:54:09 <watermind> hi
13:54:16 <Jeanne-Kamikaze> yo
13:54:16 <watermind> why does cabal hate me?  http://lpaste.net/96158
13:54:17 <FireFly> skypers: Typeclassopedia mentions some such typeclasses
13:54:40 <watermind> ExitFailure 1 is not very telling
13:54:41 <ktlh> hi, lookin at https://github.com/mzero/barley seems fun ("Barley is an environment for tinkering with Haskell. It is a web server with an embedded simple programming environment rendered as web pages."). Question: got ghc 7.6.3, cabal deps among other things  asks for "ghc >=6.10 && <7.1" . First time tryin buildin something, should I get an old ghc for this?
13:54:43 <FireFly> skypers: there's always lists on wikipedia for the corresponding algebraic stuff: http://en.wikipedia.org/wiki/Template:Group-like_structures etc
13:55:12 <monoidal> wereHamster: pool requires monad-control which requires transformers  which requires special-functors which requires old mtl
13:55:16 <skypers> I see
13:55:18 <skypers> but hm
13:55:31 <monoidal> wereHamster: but pool is deprecated, seeing package description http://hackage.haskell.org/package/pool
13:55:34 <skypers> I think I just should dump all Control.*, and read all packages.
13:55:35 <wereHamster> monoidal: ah, resource-pool != pool
13:55:35 <external-reality> Speaking of lens, I thought it might be a good idea to embed a few front end langauges into Haskell that compile to lens code; xpath-lens, css-lens. I was wondering if anyone would find that useful.
13:55:37 <skypers> :D
13:55:48 <derekv> external-reality: yea I think it represents a sortof idealized model of imperitive programming.  its acts how we usually want imperitive programming to act.
13:55:50 <skypers> xpath
13:55:53 <skypers> my god.
13:56:10 <monoidal> wereHamster: you have resource-pool?
13:56:13 <geekosaur> watermind, the important part is at the top, not the bottom
13:56:20 <benzrf> what the hell are lenses
13:56:29 <FireFly> @lens
13:56:29 <lambdabot> Maybe you meant: oeis let leet
13:56:33 <skypers> FireFly: what does the “Totality” mean?
13:56:36 <FireFly> @where lens
13:56:36 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
13:56:41 <skypers> benzrf: they’re great
13:56:42 <watermind> geekosaur: I kind of understand what's happnening, he thinks I have a ton of packages I don't
13:56:48 <skypers> but a bit overwhelming
13:56:52 <FireFly> benzrf: they s t a b you
13:56:56 <FireFly> benzrf: just a warning
13:56:56 <geekosaur> actually the middle
13:57:05 <watermind> geekosaur: i.e. I just updated ghc, now I'm a bit lost as to how update my cabal installed packages
13:57:07 <wereHamster> monoidal: no, I had just 'pool' in my cabal file
13:57:13 <skypers> Totality, Closure?
13:57:19 <skypers> what does that mean?
13:57:21 <wereHamster> monoidal: changing that to resource-pool fixed the problem
13:57:21 <watermind> geekosaur: so I was trying to mv .cabal and start from scratch
13:57:31 <geekosaur> you also need to mv .ghc
13:57:35 <geekosaur> @where sicp
13:57:35 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized
13:57:35 <lambdabot> Packages"
13:57:35 <watermind> right
13:57:41 <geekosaur> the last url
13:57:41 <benzrf> also: if I have 't0 -> t1 -> s -> (s, a)', or something like it, is there a set of funcs to turn it into a state monadic value
13:57:46 <benzrf> *func returning a state monadic value
13:58:06 <FireFly> skypers: an operation is closed over a set if, when applied to values in that set, the result is also in that set
13:58:10 <watermind> geekosaur: thanks!
13:58:27 <geekosaur> so you have a ghc package registry entry (under ~/.ghc) referencing files that were installed under ~/.cabal
13:58:40 <skypers> oh
13:58:41 <skypers> ok
13:58:46 <FireFly> skypers: so (+) is closed over naturals, but (-) isn't since subtracting one natural number from another doesn't necessarily result in a natural number
13:58:52 <skypers> so a Monoid is that thing
13:58:56 <maxiepoo> is there ever a good reason for circular dependencies?
13:59:17 <skypers> FireFly: yeah, it might be Z instead of N
13:59:34 <FireFly> Right
13:59:50 <FireFly> and totality means it's defined for all things in the set
14:00:15 <maxiepoo> seems like it would just make your codebase more confusing
14:00:16 <FireFly> so e.g. (/) isn't total for the set of integers since division by zero isn't defined
14:00:26 <external-reality> skypers: lol, [|xpath|/bookstore/book/title|] compiling to lens code wouldn't be a bad thing???
14:00:32 <mm_freak> given a type A, a monoid is a function of type A -> A -> A that is associative and has an identity of type A
14:00:37 <FireFly> (someone correct me if I'm wrong, I'm a newbie when it comes to abstract algebra :P)
14:00:44 <skypers> external-reality: I don’t like XML
14:00:52 <derekv> heh, i had this type error, so i googled it, and I found someone trying to do almsot the exact same thing as myself
14:00:53 <skypers> and anything XML-related actually
14:00:55 <derekv> http://ask.techwikihow.com/25146/haskell-persistent-crud-typeclass.html
14:00:56 <FireFly> (and plenty of other things too)
14:01:08 <skypers> ok FireFly
14:01:09 <skypers> got it
14:01:18 <derekv> kindof the reverse of finding a function based on a type signature and it does exactly what you want
14:01:20 <joelteon> are there any good libraries for html parsing and dom traversal?
14:01:20 <monoidal> FireFly: division by zero is one reason; the other is quotient of integers is usually not an integer.
14:01:28 <FireFly> Right, that too
14:01:29 <monoidal> FireFly: unless by (/) you mean div.
14:01:36 <skypers> is there a more abstract structure than Magma?
14:01:42 <FireFly> monoidal: but the latter is due to closure, not totality, no?
14:01:42 <mm_freak> in most cases we pretend that bottoms don't exist
14:01:46 <FireFly> or maybe it is. I dunno
14:01:59 <monoidal> FireFly: closure and totality are essentially the same thing
14:02:02 <mm_freak> so (+) is a monoid, (-) is not a monoid (because it's not associative)
14:02:04 <scott_> As wikipedia mentioned, totality is the same as closure. (-) :: Nat -> Nat -> Nat can't be total because (-) isn't defined for 2 and 3 for example
14:02:12 <external-reality> external-reality: I'm in the process of making two front-ends css-selectors and xpath for quering haskell datatypes. The only backend would be lens for now.
14:02:26 <FireFly> scott_: oh, right, that makes sense
14:02:29 <mm_freak> in the same way (*) is a monoid, but (/) is not
14:02:30 <monoidal> skypers: magmas have no laws
14:02:34 <external-reality> lol
14:02:43 <skypers> huh, yes they have
14:02:46 <monoidal> skypers: you can have a different signature, but for a single binary operator, anything is a magma
14:02:51 <external-reality> I'm didn't mean to talk to myself
14:02:58 <skypers> non-associative yes, but they do have inner laws?
14:03:11 <mm_freak> monoidal: the type of that operator is given by the magma law
14:03:26 <skypers> monoidal: yeah so it’s one of the most abstract structure
14:03:32 <mm_freak> given A ≠ B, this is not a magma: A -> B -> A
14:03:58 <skypers> mm_freak: why?
14:04:05 <skypers> because it would need to be A -> A -> A ?
14:04:11 <FireFly> Yes, I think so
14:04:11 <mm_freak> skypers: in set theory terms you still have the "closed" requirement
14:04:16 <monoidal> a binary operation by definition must be A -> A -> A.
14:04:21 <benzrf> excuse me can anybody answer my question ;_;
14:04:22 <lpaste> wereHamster pasted “Ambiguous module name `Control.Monad.State'” at http://lpaste.net/96159
14:04:25 <skypers> yeah
14:04:41 <FireFly> benzrf: I don't know state :|
14:04:42 <mm_freak> (in type theory "closed" is not a sensible concept)
14:04:50 <wereHamster> now this. I only depend on mtl in my cabal file, I don't have monad-tl referenced at all
14:04:56 <skypers> ok so, just after magma, we find…
14:04:58 <monoidal> the more general notion is an "algebraic structure" which encompasses magmas, modules etc
14:04:59 <skypers> semigroupoid?
14:05:05 <fizruk_> :t state
14:05:06 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
14:05:11 <skypers> well, semigroup*
14:05:20 <skypers> which are a magma + associativity
14:05:25 <fizruk_> benzrf, ^ is that what you're looking for?
14:05:39 <benzrf> hmm?
14:05:43 <skypers> then after that, monoid, that adds the neutral element
14:05:44 <benzrf> oh!
14:05:49 <benzrf> probably
14:05:55 <skypers> then what
14:05:57 <briennetheblue> or you can go in a different direction and get quasigroups and loops instead :)
14:05:57 <skypers> group
14:05:57 <mm_freak> skypers: well, it doesn't "add" it…  it requires it
14:06:04 <benzrf> is there a series of funcs that can do that for the next few arities?
14:06:07 <skypers> it adds the requirement, yes
14:06:15 <wereHamster> and I'm already in a sandbox
14:06:19 <skypers> group requires the monoid to have an inverse
14:06:33 <fizruk_> benzrf, so if you have f :: a -> b -> s -> (c, s), you can do \x y -> state (f x y)
14:06:36 <skypers> and an abelian one requires the group to have a commutative inner law
14:06:41 <benzrf> fizruk_: exactly
14:06:45 <benzrf> what i want is
14:06:48 <FireFly> axioms ∪ {assoc}
14:06:49 <mm_freak> skypers: an inverse function =)
14:06:55 <benzrf> to write that like a regular func
14:07:06 <benzrf> then automatically turn it into what you wrote
14:07:25 <benzrf> like how there's liftM and liftM2 and liftM3
14:07:25 <skypers> yeah, that’s quite obvious, sorry
14:07:33 <benzrf> are there a few funcs for arities above 1?
14:07:40 <skypers> do rings used in Control?
14:07:43 <mm_freak> skypers: the distinction can be significant
14:07:44 <skypers> like, Control.Ring
14:07:45 <skypers> ?
14:07:47 <fizruk_> benzrf, you can do that with typeclass hackery (make a polyvariadic variant of state), or with TH
14:07:57 <skypers> are rings used*
14:07:57 <fizruk_> benzrf, otherwise I doubt it
14:08:03 <mm_freak> skypers: most likely rather Data.Ring
14:08:14 <skypers> oh sh*t that’s real
14:08:15 <skypers> :(
14:08:18 <skypers> to much abstraction
14:08:21 * quchen finds wereHamster's problem interesting and would like to direct attention to it.
14:08:21 <skypers> too*
14:08:30 <benzrf> fizruk_: wait though
14:08:30 <monoidal> Ring in Haskell is called Num except for bogus functions.
14:08:48 <monoidal> at least, I never respect abs and signum.
14:08:51 <donri> i like how conduit forms a quasigroupoid which doesn't even seem to be a thing because it means it has no closure, no associativity, no identity, no inverse and no commutativity. but it does have composition!
14:08:53 <fizruk_> :t state . f
14:08:54 <benzrf> state2 f a1 = state (f a1)
14:08:54 <lambdabot> (Show a, Show s, MonadState s m, FromExpr (a1, s)) => a -> m a1
14:08:57 <mm_freak> and Field is called Fractional
14:08:58 <benzrf> that seems easy
14:09:06 <benzrf> :t f
14:09:06 <lambdabot> FromExpr a => a
14:09:09 <benzrf> ??
14:09:17 <skypers> monads-tf, what’s that?
14:09:24 <monoidal> mm_freak: Fractional is field of zero characteristics
14:09:29 <quchen> skypers: type family version of MTL (instead of fundeps)
14:09:30 <fizruk_> benzrf, simple-reflection iirc
14:09:30 <geekosaur> benzrf: single letter names are bound by the simple-reflect package in lambdabot
14:09:31 <donri> skypers: mtl with type families
14:09:48 <skypers> type families?
14:09:49 <fizruk_> :t \f -> state . f
14:09:50 <lambdabot> MonadState s m => (a -> s -> (a1, s)) -> a -> m a1
14:09:56 <quchen> skypers: "Type level functions"
14:10:01 <fizruk_> :t \f -> (state .) . f
14:10:01 <lambdabot> MonadState s m => (a -> a1 -> s -> (a2, s)) -> a -> a1 -> m a2
14:10:13 <skypers> oh
14:10:21 <skypers> why one uses that?
14:10:30 <benzrf> aaah
14:10:38 <quchen> I think it's closer to MTL's intentions, skypers.
14:11:06 <fizruk_> :t \f x y -> state (f x y)
14:11:06 <lambdabot> MonadState s m => (t -> t1 -> s -> (a, s)) -> t -> t1 -> m a
14:12:02 <fizruk_> :t \f -> fmap state . f
14:12:03 <lambdabot> (Functor f, MonadState s m) => (a -> f (s -> (a1, s))) -> a -> f (m a1)
14:12:08 <skypers> Cont
14:12:12 <skypers> I don’t know that monad
14:12:18 <skypers> continuous computations
14:12:24 <skypers> that sounds fancy
14:12:40 <fizruk_> :t \f -> fmap state . f :: MonadState s m => (a -> b -> s -> (c, s)) -> a -> b -> m c
14:12:41 <lambdabot>     Could not deduce (t
14:12:41 <lambdabot>                       ~ ((a1 -> b1 -> s1 -> (c1, s1)) -> a1 -> s0 -> (m1 c1, s0)))
14:12:41 <lambdabot>     from the context (MonadState s m)
14:12:51 <fizruk_> :t (\f -> fmap state . f) :: MonadState s m => (a -> b -> s -> (c, s)) -> a -> b -> m c
14:12:52 <lambdabot> MonadState s m => (a -> b -> s -> (c, s)) -> a -> b -> m c
14:12:57 <quchen> skypers: Continuations, not continuous computations
14:13:04 <skypers> hm
14:13:05 <skypers> ok
14:13:13 <skypers> like f x = … in g (f 1)
14:13:19 <quchen> Cont is for when you want to confuse people, modulo two or three counterexamples
14:13:20 <skypers> +let
14:13:27 <skypers> ahah :D
14:13:36 <skypers> it makes me think of the Endo monoid
14:13:44 <skypers> I don’t understand its use
14:14:00 <quchen> (.) = mappend, id = mempty
14:14:09 <quchen> It's the monoid of composing functions.
14:14:13 <skypers> yeah…
14:14:14 <skypers> I know
14:14:39 <skypers> my question is still the same: what’s its use?
14:14:48 <quchen> applyMultipleTimes n f = (appEndo . mconcat . map Endo) (replicate n f)
14:14:59 <fizruk_> skypers, what's the use of Sum?
14:15:05 <quchen> Or you can use Writer to repeatedly refine your result
14:15:12 <skypers> fizruk_: I seriously don’t know, I never use that
14:15:28 <quchen> must … resist … making … monoid … joke
14:15:29 <skypers> if I want to sum values, I just sum or a foldl
14:15:46 <fizruk_> skypers, there's great "Functional pearl" about using monoids and semigroups for diagrams
14:16:20 * nooodl_ wonders why there isn't a "power" function for monoids
14:16:40 <FireFly> skypers: hm, you'd probably enjoy learning category theory I think
14:16:41 <fizruk_> skypers, http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
14:16:46 <benzrf> ok if i need both possible failure (w/ message) and state, i want to use monad transformers w/ Either and State?
14:17:03 <derekv> ok so if I let it infer the type, it compiles, i just get the warning that i should have explicitly declared the type for the function. so i load it in GHCI and query the type, and then copy that in, and it fails to compile
14:17:06 <nooodl_> like "mpower x 4" would be "x <> x <> x <> x". that'd be useful for most monoids
14:17:20 <skypers> thank you
14:17:48 <quchen> nooodl_: Yeah, I keep redefining that one
14:19:40 <derekv> the infered type is idempotentInsert :: (PersistEntity val, MonadIO m, PersistEntityBackend val  ~ Database.Persist.GenericSql.Raw.SqlBackend) => val -> Unique val -> m ()
14:20:28 <benzrf> hello?
14:20:30 <fizruk_> benzrf, you can use e.g. StateT s (Either e) a
14:20:49 <skypers> oh
14:20:51 <skypers> ok
14:20:55 <skypers> I just got something
14:21:05 <fizruk_> skypers, about monoids?
14:21:20 <skypers> yeah, but with my ghci prompt
14:21:31 <skypers> I always wonder what mconcat is
14:21:32 <skypers> and now
14:21:38 <skypers> I just found a nice example
14:21:39 <fizruk_> =)
14:21:39 <benzrf> fizruk_: i dont know anything about monad transformers
14:21:39 <skypers> wiat
14:21:42 <benzrf> ;-;
14:21:49 <benzrf> i was just confirming that that's what i should read up about
14:22:01 <skypers> > getSum . mconcat . fmap Sum $ [1..10]
14:22:02 <lambdabot>   55
14:22:04 <skypers> ahah
14:22:09 <skypers> that’s funny
14:22:15 <skypers> but still
14:22:25 <skypers> > foldl1 (+) [1..10]
14:22:26 <lambdabot>   55
14:22:32 <skypers> why use Sum then?
14:22:46 <brandonw> wow Feuerbach optparse-applicative is definitely very nice :)
14:23:10 <benzrf> so what are applicatives actually useful for??
14:23:10 <apo> > 10*11/2
14:23:10 <fizruk_> skypers, to be able to abstract from a particular monoid in other places?
14:23:11 <lambdabot>   55.0
14:23:16 <benzrf> like do you have examples
14:23:21 <apo> silly people
14:23:23 <fizruk_> benzrf, lots of things
14:23:27 <quchen> @let foo = \getOut putIn -> getOut . mconcat . map putIn) [1..10] -- skypers
14:23:27 <lambdabot>  Parse failed: Parse error: )
14:23:33 <quchen> @let foo = \getOut putIn -> (getOut . mconcat . map putIn) [1..10] -- skypers
14:23:33 <lambdabot>  .L.hs:152:35:
14:23:33 <lambdabot>      No instance for (Monoid b0) arising from a use of `mconca...
14:23:37 <quchen> Bloody hell.
14:23:37 <fizruk_> benzrf, e.g. x <- read <$> readLine
14:23:41 <quchen> BRB, private session
14:23:47 <benzrf> fizruk_: but that's just regular functors
14:23:56 <benzrf> <$> -> fmap??
14:24:24 <skypers> benzrf: yes
14:24:28 <skypers> well
14:24:30 <skypers> not really
14:24:37 <skypers> <$> -> `fmap`
14:24:38 <skypers> ;)
14:24:42 <benzrf> ik >:P
14:24:52 <skypers> 23:11 < fizruk_> skypers, to be able to abstract from a particular monoid in other places?
14:24:55 <skypers> what do you mean?
14:25:09 <skypers> 23:11 < apo> > 10*11/2
14:25:11 <skypers> you… :D
14:25:15 <skypers> > sum [1..10]
14:25:16 <lambdabot>   55
14:25:20 <skypers> even faster
14:25:41 <apo> skypers: ?
14:25:48 <Iceland_jack> > 55 -- even faster
14:25:49 <lambdabot>   55
14:26:08 <quchen> @undef
14:26:08 <lambdabot> Undefined.
14:26:09 <quchen> @let foo :: Monoid m => (m -> Int) -> (Int -> m) -> Int; foo = \getOut putIn -> (getOut . mconcat . map putIn) [1 :: Int .. 10]
14:26:10 <lambdabot>  Defined.
14:26:17 <apo> skypers: I doubt that sum [1..n] is faster than n*(n+1)/2
14:26:23 <quchen> 'foo' is now a function that does the monoid operation over [1..10].
14:26:28 <benzrf> @get foo
14:26:28 <lambdabot> Maybe you meant: get-shapr get-topic let
14:26:31 <skypers> apo: I meant, in type writing
14:26:32 <benzrf> > foo
14:26:33 <lambdabot>   No instance for (Data.Monoid.Monoid m0) arising from a use of `e_1'
14:26:33 <lambdabot>  The ty...
14:26:38 <quchen> You can substitute the monoid to be whatever supports Int mappending.
14:26:41 <quchen> > foo getSum Sum
14:26:42 <lambdabot>   55
14:26:45 <quchen> > foo getProduct Product
14:26:47 <lambdabot>   3628800
14:26:54 <quchen> ^ that's 10!
14:27:16 <Hodapp> And the closed-form solution for a Fibonacci number is almost always faster than the recursive solution, but the latter is common fodder for example!
14:27:17 <apo> skypers: I don't care much about that kind of speed
14:27:18 <benzrf> why cant i pattern match on data constructors that are inside names
14:27:19 <benzrf> *vars
14:27:20 <skypers> quchen: that’s quite the same thing as with fold1
14:27:22 <benzrf> D:<
14:27:25 <benzrf> NOT ENOUGH DYNAMIC
14:27:36 <Iceland_jack> benzrf: What are you talking about?
14:27:39 <Iceland_jack> Inside vars?
14:27:47 <apo> Hodapp: it's also inaccurate for big n
14:27:57 <joelteon> I forget how to do find and replace in a string
14:28:03 <benzrf> let foo x = Just 3 in x where foo = Just
14:28:05 <Hodapp> apo: it's as accurate as your constants!
14:28:08 <benzrf> :B
14:28:20 <quchen> skypers: Sure. But with foldl you can't write a function that takes any monoid and mashes it together. You have to explicitly write your own sum function, and then your product function.
14:28:22 <darthdeu> hey guys, i'm having trouble getting "non-exhaustive pattern match" ... even though i have a feeling that i'm matching all the cases, could someone help me out please?
14:28:23 <darthdeu> http://lpaste.net/96160
14:28:39 <Iceland_jack> Hodapp: That's not pattern matching on a data constructor
14:28:40 <darthdeu> oh never mind, i forgot to rename one match of the convertText
14:28:49 <Iceland_jack> sorry, benzrf: That's not pattern matching on a data constructor
14:28:53 <Hodapp> >_<
14:28:55 <benzrf> darthdeu: italic
14:28:57 <benzrf> not itallic
14:28:58 <benzrf> ;p
14:28:59 <identity> darthdeu: with all warnings on, the compiler should even warn you which pattern matches aren't met
14:29:00 <Iceland_jack> benzrf: You may be interested in ViewPatterns though
14:29:01 <darthdeu> oops
14:29:05 <skypers> quchen: yeah well, ok :)
14:29:17 <skypers> I actually often use Monoid when I have a configuration type
14:29:22 <skypers> like data Configuration = …
14:29:27 <quchen> skypers: The Writer monad is a pretty good example of monoid usage.
14:29:40 <skypers> and a function that takes external parameters and return another configuration
14:29:49 <benzrf> still nobody has told me how applicatives are useful
14:29:50 <benzrf> ;_;
14:29:54 <skypers> mapping monoid over such a type and mappending is just nice :)
14:29:55 <Iceland_jack> also fold:
14:29:56 <Iceland_jack> @ty fold
14:29:56 <lambdabot> (Foldable t, Monoid m) => t m -> m
14:29:58 <ReinH> darthdeu: also fyi it's spelled 'italic'
14:30:00 <skypers> quchen: yeah
14:30:07 <skypers> I use RWST you know
14:30:13 <skypers> I like Monoid
14:30:15 <skypers> and Semigroup
14:30:24 <quchen> benzrf: Learn Functor and then Monad. After some time you'll see that Monad is often too much and something in between (Applicative) is enough.
14:30:29 <skypers> but I was talking about Sum, Product, Endo
14:30:30 <fizruk_> benzrf, most of things you do with monad are possible with applicatives
14:30:44 <quchen> skypers: First, Last, Ordering
14:30:45 <benzrf> hmmm ok
14:30:56 <Iceland_jack> > (+) <$> Just 5 <*> Just 10 -- benzrf: applicatives
14:30:57 <lambdabot>   Just 15
14:31:14 <Iceland_jack> > (++) <$> Just "benzrf: " <*> Just "applicatives"
14:31:15 <lambdabot>   Just "benzrf: applicatives"
14:31:21 <quchen> The first useful application of Applicatives is probably when using parsers.
14:31:27 <skypers> First?
14:31:29 <skypers> for list?
14:31:37 <quchen> No, it's a Maybe thing.
14:31:38 <Iceland_jack> @hoogle First
14:31:38 <lambdabot> Data.Monoid First :: Maybe a -> First a
14:31:38 <lambdabot> Data.Monoid newtype First a
14:31:39 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
14:31:41 <quchen> Keeps the first Just value.
14:31:44 <Iceland_jack> skypers: ↑
14:31:45 <khyperia> Honestly I sort of like applicatives because going full-out monad usually implies do-notation spanning multiple lines, and applicative is just so much cleaner.
14:31:49 <skypers> oh I see
14:31:50 <benzrf> hmm
14:31:56 <skypers> it’s like or then?
14:32:10 <benzrf> so applicatives are useful for when you have some structured data that you want to put into a function
14:32:13 <quchen> Sort of. Speaking of (||), Bools are monoids as well.
14:32:18 <fizruk_> :t first
14:32:19 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
14:32:24 <quchen> There's the Or monoid and the And monoid.
14:32:25 <benzrf> while monads are when you have multiple functions that need to be chained that way
14:32:29 <skypers> huh?
14:32:29 <quchen> :t First -- fizruk_
14:32:30 <lambdabot> Maybe a -> First a
14:32:32 <Iceland_jack> > mconcat [First Nothing, First (Just "FIRST"), First Nothing, First (Just "NOT FIRST")]
14:32:33 <lambdabot>   First {getFirst = Just "FIRST"}
14:32:37 <Iceland_jack> > getFirst $ mconcat [First Nothing, First (Just "FIRST"), First Nothing, First (Just "NOT FIRST")]
14:32:37 <lambdabot>   Just "FIRST"
14:32:41 <skypers> I always thought first was in Bifunctor
14:32:47 <fizruk_> :t find
14:32:47 <lambdabot> (a -> Bool) -> [a] -> Maybe a
14:32:48 <quchen> > mconcat [Nothing, Just "hello", Just "world", Nothing]
14:32:49 <lambdabot>   Just "helloworld"
14:32:57 <fizruk_> quchen, I meant Data.List.find
14:33:00 <ReinH> skypers: every monad is an applicative, but sometimes the applicative behavior provided by the monad can be improved
14:33:02 <quchen> > mconcat . map First $ [Nothing, Just "hello", Just "world", Nothing]
14:33:03 <lambdabot>   First {getFirst = Just "hello"}
14:33:03 <khyperia> benzrf, I like the notion of parsers: applicative is for when the grammar is "static", as in you always parse one thing, but monad for things that change depending on what you just parsed.
14:33:16 <skypers> what do you mean ReinH ?
14:33:21 <identity> oh, I needed First just a while ago.
14:33:22 <identity> durr
14:33:36 <ReinH> skypers: sort of like how liftM can always be used as fmap, but sometimes you can write a more efficient fmap than the one provided by the monad instance
14:33:41 <khyperia> basically monad allows you to thunk in logic between successive "unpackings" (as in <*> or >>=)
14:34:11 <khyperia> although thunk is probably not the best term, because thunks are a thing in haskell :P
14:34:13 <skypers> I see
14:34:33 <joejev> maybe chunks, like a lazy bytestring?
14:34:41 <ReinH> skypers: Simon Marlow talks about this a bit in the latest podcast, which should be released tomorrow
14:34:44 <quchen> "blobs"!
14:34:56 <skypers> oh that’s nice ReinH
14:35:04 <skypers> I’ll be looking forward to it then
14:35:08 <intrados> Does anyone know of a good example of using the reader monad to avoid threading parameters through a series of functions?
14:35:09 <ReinH> skypers: but check this out too http://skillsmatter.com/podcast/home/simon-marlow
14:35:40 <fizruk_> skypers, I also sometimes enjoy Monoid instance for (a -> b)
14:35:47 <quchen> intrados: I don't think there are many. Using ReaderT often means you have to litter your code with 'lift', and most people prefer passing the argument explicitly.
14:35:55 <ReinH> fizruk_: you mean a -> a, I think
14:35:59 <ReinH> there is no monoid for a -> b
14:36:02 <ReinH> a -> a is Endo
14:36:05 <fizruk_> ReinH, there is
14:36:14 <quchen> Monoid b => Monoid (a -> b)
14:36:15 <ReinH> fizruk_: how?
14:36:17 <joejev> also, speaking of monads, I am using the System.Hardware.Arduino package for controlling an arduino, and I was wondering if anyone knew a good way to get data off the arduino and back into my program in the IO monad, or even the Arduino monad. The only way I can see to run a program is to write a function of type Arduino () and run that trough withArduino, but I need other functions to query sensors on the arduino to perform other
14:36:17 <joejev> actions
14:36:20 <ReinH> quchen: oh
14:36:23 <identity> intrados: it depends on how complicated your state is and so on.
14:36:29 <fizruk_> > show <> ('a':) $ "hi"
14:36:30 <lambdabot>   "\"hi\"ahi"
14:36:32 <quchen> Well, the constraint really confirms what you said, ReinH
14:36:41 <identity> but I hardly ever use Reader. In the cases I need something like it, I need 'mutable' state(e.g. State)
14:36:44 <ReinH> quchen: how so?
14:36:45 <identity> not just readable
14:36:51 <skypers> 23:23 < fizruk_> skypers, I also sometimes enjoy Monoid instance for (a -> b)
14:36:54 <skypers> huh…
14:37:03 <skypers> :D
14:37:04 <quchen> ReinH: Because then it's not a Monoid instance for (a -> b) anymore, because it requires more (namely Monoid b)
14:37:14 <skypers> oh
14:37:18 <skypers> the result has to be a Monoid
14:37:30 <fizruk_> i should've written that...
14:37:36 <Iceland_jack> yes, and mempty would be const mempty
14:37:46 <intrados> identity: I don't really have a particular use case in mind at the moment. I've just seen that mentioned as a use of Reader, but don't have a good sense of how it would actually work
14:37:49 <ReinH> quchen: right
14:38:02 <quchen> The (a -> b) monoid instance is really cool for sorting functions
14:38:40 <ReinH> Endo is a fun monoid though
14:39:10 <briennetheblue> or things like a -> All or a -> Any
14:39:22 <fizruk_> > sortBy (compare <> compare length) ["asd", "sdfsdga", "sxaf", "asdf"]
14:39:23 <lambdabot>   Couldn't match type `GHC.Types.Ordering'
14:39:23 <lambdabot>                with `([a0] -> GHC....
14:39:50 <fizruk_> > sortBy (compare <> compare `on` length) ["asd", "sdfsdga", "sxaf", "asdf"]
14:39:51 <lambdabot>   ["asd","sxaf","asdf","sdfsdga"]
14:39:58 <ReinH> :t foldMap
14:39:59 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:40:00 <quchen> > sortBy (comparing snd <> comparing fst) [(1,2), (2,3), (1,3)]
14:40:01 <lambdabot>   [(1,2),(1,3),(2,3)]
14:40:01 <quchen> Weee
14:40:18 <ReinH> quchen: nice :)
14:40:18 <benzrf> the Reader monad is good when you want to include another function into your expr without explicitly passing it the env, right?
14:40:50 <quchen> ReinH: A noteworthy aha moment in my beginner days. A pretty good exercise to understand how it works if you ask me.
14:41:02 <kqr> quchen, which monoid is <> referring to in comparing snd <> comparing fst?
14:41:06 <quchen> "OOooooh it's two different monoids *zen zen*"
14:41:08 <briennetheblue> or even a -> b -> All or a -> b -> Any :)
14:41:09 <Iceland_jack> benzrf: The reader monad is good if you wnat a constant environment
14:41:30 <joelteon> :t ((<>) <>)
14:41:31 <lambdabot> Monoid m => (m -> m -> m) -> m -> m -> m
14:41:47 <benzrf> Iceland_jack: yes, but unless you're calling into another func, a regular arg works just as well
14:41:52 <fizruk_> kqr: a -> a -> Ordering
14:41:56 <Iceland_jack> benzrf: That's right
14:42:09 <quchen> kqr: (comparing a <> comparing b) x y   ⇒   (comparing a x <> comparing b x) y <using function monoid>  ⇒  (comparing a x y <> comparing b x y) <using function monoid again>  ⇒  <use Ordering monoid>
14:42:30 <kqr> quchen, that's very, very nice
14:42:35 <Iceland_jack> When you have many functions that need some read-only environment, passing it as an explicit argument becomes very ugly
14:42:46 <Iceland_jack> it also gets nicer when you have a larger monad stack
14:42:47 <quchen> kqr: Not only that, it's also very very useful! :-)
14:42:57 <Iceland_jack> well for certain values of ‘nice’ anyway
14:44:05 <benzrf> Iceland_jack: exactly wgat i meant
14:44:05 <benzrf> o:
14:44:09 <benzrf> *what
14:44:30 <Iceland_jack> sorry?
14:44:55 <kqr> quchen, yeah, i'm impressed and surprised i hadn't seen that before
14:44:59 <watermind> so what's up with ghc-mod? is it broken?
14:45:18 <watermind> or do we need a platform > 7.6.3 ?
14:45:27 <intrados> watermind: It at least mostly works for me
14:46:04 <watermind> intrados: I  get     Not in scope: data constructor `ExplicitForall'  during installation
14:46:12 <watermind> intrados: do you have ghc-mod 3.0?
14:46:51 <ij> If I want to have multiple files for a haskell project, I have to make each file as a module? And import it in other files?
14:47:33 <quchen> Each module imports modules it wants to use definitions of.
14:47:37 <benzrf> i enjoy python's module/import system
14:47:43 <benzrf> it's the best one ive seen by far
14:47:49 <quchen> The file name has to match the module name, so "Foo.hs" contains "module Foo where".
14:48:39 <benzrf> quchen: then why bother mentioning the module name
14:48:39 <quchen> Typically you have a main module, and when you compile that one GHC automatically compiles the modules it depends on.
14:48:52 <quchen> benzrf: Because no module name defaults to "module Main where".
14:49:00 <quchen> And then GHC complains when there's no 'main' function in there.
14:49:23 <merijn> benzrf: How is python's better than haskell's?
14:49:30 <benzrf> then why not have it default to the file name's?
14:49:33 <quchen> benzrf: Also when you have modules in subdirectories, you reference them like in "module Foo.Bar.Baz where" when the file is "Foo/Bar/Baz.hs".
14:49:34 <benzrf> merijn: well
14:49:41 <benzrf> 1. non-explicit module defs
14:49:55 <benzrf> 2. better default namespace handlig
14:49:57 <benzrf> *handing
14:49:59 <benzrf> ugh
14:50:07 <benzrf> i guess its a matter of taste
14:50:09 <merijn> What does non-explicit module def mean?
14:50:14 <benzrf> all files are modules
14:50:18 <quchen> What does better default namespace handling mean?
14:50:25 <benzrf> any top-level variables are attrs on the module obj
14:50:46 <benzrf> quchen: by default, you get an object containing the things in the module instead of total namespace pollution
14:50:53 <scshunt|nospoile> benzrf: haskell not exporting all symbols by default is a Good Thing
14:50:58 <watermind> ok so the problem is that ghc-mod is defaulting to 0.30 !
14:51:05 <benzrf> scshunt|nospoile: well, that's like, your opinion
14:51:06 <benzrf> maaan
14:51:10 <watermind> wait no
14:51:12 <watermind> hmm
14:51:14 <Eduard_Munteanu> Where's HsFFI.h supposed to be located? :/
14:51:16 <scshunt|nospoile> and if you don't want namespace pollution, that's what qualified imports are for :)
14:51:26 <fizruk_> benzrf, I rarely use qualified imports
14:51:28 <benzrf> scshunt|nospoile: yes, but python does that by default
14:51:29 <benzrf> ;p
14:51:33 <benzrf> again, like i said, haskell is p. close
14:51:36 <watermind> yes exactly
14:51:36 <benzrf> its a matter of taste
14:51:38 <watermind> geeeez
14:51:43 <quchen> benzrf: How is that different from qualified import in Haskell?
14:51:48 <merijn> Eduard_Munteanu: No clue, if you let cabal compile your C code it'll include the right include path, though
14:51:48 <benzrf> it's not significantly
14:51:50 <benzrf> like i said
14:51:51 <benzrf> derp
14:51:55 <watermind> I was reading it as 3.0 but it is trying to install cabal 0.30!! that is why it fails!
14:52:02 <Eduard_Munteanu> merijn: oh, alright.
14:52:05 <Eduard_Munteanu> Thanks.
14:52:10 <benzrf> again: haskell is close, it's just that i prefer python's defaults
14:52:12 <watermind> any idea how to fix this?
14:52:12 <Iceland_jack> benzrf: You said it was the best by far :P
14:52:22 <benzrf> Iceland_jack: ok so maybe i exaggerated a little
14:52:23 <benzrf> :-D
14:52:34 <Iceland_jack> Do you think exaggeration is OK on this channel?
14:52:58 <benzrf> fuck yeah
14:53:06 <Iceland_jack> It is never OK.
14:53:11 <quchen> NEVER!!
14:53:19 <benzrf> :_(
14:53:38 <fizruk_> Haskell is the best language ever.
14:53:51 <fizruk_> I think that was OK :p
14:54:04 <Iceland_jack> If exaggeration were okay you wouldn't know that I'm being serious when I say I caught a fish thiiiis big
14:54:15 <Iceland_jack> What kind of a world would that be then
14:54:22 <quchen> Iceland_jack: This one?
14:54:36 <Iceland_jack> touché :)
14:54:43 <fizruk_> <><
14:54:49 <Iceland_jack> (<=<)
14:54:55 <briennetheblue> i caught a compiler error thiiiiiiis big
14:55:00 <benzrf> maaan haskell makes my brain hurt
14:55:04 <benzrf> WHY CAN'T I JUST USE PYTHON
14:55:05 <quchen> SOOO MUCH
14:55:06 <Iceland_jack> Using templates in C++ is cheating
14:55:20 <Hodapp> yeah, I've had compiler errors in C++ that were 10 times the size of my program.
14:55:27 <benzrf> if only somebody had shown me haskell years ago
14:55:30 <Iceland_jack> It's easy for an empty program ;P
14:55:32 <benzrf> maybe id be better at it now
14:55:33 <benzrf> >:(
14:55:38 <quchen> Hodapp: Unused variable with Boost?
14:55:43 <Hodapp> quchen: no Boost.
14:57:01 <FreeFull> Hodapp: Missing semicolon?
14:57:04 <quchen> This may be an appropriate time to recommend spamming Lambdabot with "@quote kmc" in a private session (!) again.
14:57:16 <darthdeu> can i somwhow write a type that's    type Foo = Bar String | Baz (Bar | String) ?
14:57:20 <benzrf> @quote kmc
14:57:20 <lambdabot> kmc says: that probably requires mptc+fundeps or asstypes
14:57:26 <Hodapp> FreeFull: it might have been that. I can't remember.
14:57:29 <darthdeu> as in if i wanted to nest those
14:57:34 <benzrf> i first heard of haskell via http://spikedmath.com/448.html
14:58:02 <fizruk_> darthdeu, use Either or define a separate type
14:58:34 <fizruk_> darthdeu, e.g. type Foo = Either String (Either Bar String)
14:58:45 <FreeFull> Where Bar is a separate type
14:59:11 <Iceland_jack> $ clang -xc =(echo -n '') |& wc -l
14:59:12 <Iceland_jack> 26
14:59:12 <Iceland_jack> $ gcc -xc =(echo -n '') |& wc -l
14:59:12 <Iceland_jack> 26
14:59:19 <monochrom> I wonder why it is not more simply "data Foo = C1 String | C2 String | C3 Bar"
15:01:08 <geekosaur> darthdeu, you might note that you need a distinct constructor on every type. Baz (Bar | String) does not include a constructor, moreover Bar is not a type
15:01:17 <geekosaur> (that is, no constructor at the level of the |
15:01:18 <geekosaur> )
15:01:34 <monochrom> Bar is not a type? what is it?
15:01:52 <geekosaur> type Foo = Bar String ...
15:02:13 <geekosaur> I am assuming they are making the common mistake of confusing a constructor for a type with a type
15:02:14 <monochrom> ok, then I don't understand the question.
15:02:35 <geekosaur> (also I suspect that `type` wants to be `data`)
15:02:50 <darthdeu> so let's say i want to have   data Text = Bold String | Italic String, but i also want to be able to nest those, to have something like Bold (Italic String) ... how should i represent that?
15:02:57 <monochrom> but hell, it is a tautology that I don't understand any question that uses the names "foo" and "bar".
15:03:10 <hatds> what's the standard function for displaying numbers (Rationals, in this case) in decimal form that provides a specifier to limit the number of decimals?
15:03:13 <darthdeu> and yeah i meant data instead of type
15:03:43 <monochrom> data Text = C0 String | Bold Text | Italic Text
15:03:55 <geekosaur> assuming you really want to loive with the limits of that representation, what monochrom said
15:04:02 <geekosaur> but that representation has limitations
15:04:16 <darthdeu> I'm not sure if i understand the C0
15:04:17 <darthdeu> hmm
15:04:20 <geekosaur> *live with
15:04:30 <geekosaur> C0 gives you a constructor for a plain string
15:04:35 <benzrf> darthdeu: use 'Plain' instead of C0
15:04:39 <monochrom> it has semantic junk like "Italic (Italic (Italic (C0 x)))"
15:04:47 <quchen> hatds: printf
15:04:49 <monochrom> C0 is like Foo
15:05:01 <darthdeu> hmm, okay
15:05:23 <geekosaur> also there's no good reason to treat Bold (Italic (C0 x)) distinct from Italic (Bold (C0 x))
15:05:26 <darthdeu> my thought was to represent this as "text node that can have either a plain string, or some other node, which can be bold/italic/plain", is there a better way in general?
15:05:37 <monochrom> therefore, I wonder why it is not more simply data Text = Ctor { content::String, italic::Bool, bold::Bool }
15:05:53 <geekosaur> so I'd be inclined to treat a text node as a pair of a string and a set of format specifiers
15:06:13 <geekosaur> or that, yes, for the simplest form
15:06:38 <darthdeu> hmm that makes sense, but what if then I want to add data LinkText = LinkText String String (as in text and href)
15:06:51 <Eduard_Munteanu> What does gtk2hs' c2hs do different vs the plain c2hs?
15:07:04 <benzrf> darthdeu: the C0 example is pretty much what you want
15:07:09 <geekosaur> understand some things specific to gtk+ calling conventions, I think
15:07:16 <benzrf> afacit
15:07:19 <benzrf> *afaict
15:07:24 <darthdeu> bezik: ok, thanks
15:07:24 <FreeFull> You could use    Decoration = Bold | Italic     and    Text = Text (Set Decoration) String
15:07:27 <darthdeu> i'll dig in
15:07:36 <benzrf> darthdeu: it's benzrf ;p
15:07:46 <darthdeu> benzrf: damn my irc client :P
15:07:48 <geekosaur> tab completion fail :p
15:07:52 <benzrf> FreeFull: it's easier to convert to html
15:07:56 <Eduard_Munteanu> Hm, I see.
15:07:57 <benzrf> which is naturally hierarchical
15:08:09 <benzrf> FreeFull: if it were using CSS formatting, yours would probly be easier
15:08:23 <benzrf> as is, it's more equivalent to both the source and the dest
15:08:28 * hackagebot scotty-session 0.0.2 - Adding session functionality to scotty  http://hackage.haskell.org/package/scotty-session-0.0.2 (AlexanderThiemann)
15:08:36 <monochrom> there is, indeed, a better way in general. write down all values you want. don't write down any values you don't want. then design a data structure to allow the values written down, but disallow the values not written down. that is, denotative programming. talk to Conal Elliott for this. he's conal here.
15:08:54 <monochrom> but that is not the best way. the best way is to hire me to do it for you.
15:09:22 <darthdeu> monochrom: haha :P this is kinda the first thing i'm trying to do after finishing LYAH
15:10:55 <chrisdone> is there any process API to launch an external process and disown it?
15:11:16 <darthdeu> probably really stupid question and you probably already explained it, but C0 is just a placeholder name that i should give something meaningful, right? :o
15:11:21 <darthdeu> otherwise i'm really confused
15:11:36 <geekosaur> C0 is stolen from VTxx terminals where it means the default font
15:11:51 <geekosaur> as someone else suggested earlier, you might prefer something like Plain
15:12:08 <darthdeu> cool :)
15:12:16 <darthdeu> i love this channel ... people always willing to help out noobs :P
15:12:43 <monochrom> my C0 means constructor #0
15:12:52 <geekosaur> heh
15:13:18 * geekosaur automaticaly read it as the "character set 0" identifier from vtxx/ansi
15:13:20 <monochrom> I use C0, C1, C2 to fight people's Foo, Bar, Baz.
15:14:18 <benzrf> but i still have muh Fooby & Foobar & Quux
15:14:28 <Iceland_jack> > ("C0", "C1", "C2") > ("Foo", "Bar", "Baz") -- monochrom
15:14:29 <lambdabot>   False
15:14:38 <benzrf> hiyoo
15:14:54 <monochrom> my sequence is more natural. it uses natural numbers.
15:15:22 <Iceland_jack> It's a cultural point, that argument doesn't cut it I'm afraid
15:15:48 <monochrom> if it's cultural, it's a cognitively disonnant culture.
15:16:15 <benzrf> more like YOUR MOM
15:16:19 <monochrom> it is at once "names should be meaningful" and "names should be meaningless" and unable to make up one's mind.
15:16:45 <Iceland_jack> Metasyntactic variables don't need to be meaningful
15:16:45 <Iceland_jack>      
15:17:06 <Iceland_jack> also foo/bar/baz have become traditional making people ask “what does c0 stand for?” when you use that instead
15:17:09 <Hodapp> IFindThatVariableNamesLikeThisContributeToProgramReadabilityWithMeaningBeingProportionalToLength
15:17:31 <monochrom> right. if you don't want meaningful, then why not more simply C0, C1, C2 for "cases #0, #1, #2", and f0, f1, f2 for "functions #0, #1, #2"?
15:17:44 <Iceland_jack> You can
15:18:17 <Iceland_jack> It's nicer to write f, g, h for functions and it's ‘standard’ in mathematics but f₀, f₁, f₂ is possible as well
15:18:25 <Iceland_jack> not as nice to write but no harm in it
15:19:28 <watermind> what do you need for a minimal system, so you can just cabal install the rest?
15:19:37 <watermind> ghc, cabal... anything else?
15:19:38 <ReinH> carter: o/
15:19:45 <geekosaur> ghc and the cabal-install bootstrap
15:19:53 <watermind> ok
15:19:56 <watermind> thanks
15:20:10 <watermind> for some reason cabal keeps trying to fetch ghc-mod 0.30
15:20:29 <watermind> there's a ton of posts of other people with the same problem at several points in time
15:20:31 <geekosaur> if you then want to bootstrap into the platform (as you might want to do on ubuntu-derivatives) you can get the platform as a cabal file
15:20:36 <watermind> but no solutions as far as I can see
15:21:02 <watermind> geekosaur: oh that I didn't know
15:21:09 <watermind> as in cabal install haskell-platform?
15:21:39 <geekosaur> it's not actually on hackage, I think. just `cabal install` in the directory witht eh cabal file
15:21:59 <monochrom> Iceland_jack, you have just seen an empirical example where people used "Bar" and I should have begun by asking "what does Bar stand for", i.e., did it stand for a type? a value constructor? it is no better than "what does C0 stand for". it never is.
15:22:14 <geekosaur> https://github.com/haskell/haskell-platform/blob/master/haskell-platform.cabal
15:22:45 <watermind> geekosaur: I see
15:22:49 <watermind> geekosaur: thanks!
15:23:26 <Iceland_jack> “never”
15:23:29 * hackagebot hPDB 1.0 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.0 (MichalGajda)
15:23:31 * hackagebot hPDB-examples 1.0 - Examples for hPDB library  http://hackage.haskell.org/package/hPDB-examples-1.0 (MichalGajda)
15:28:10 <darthdeu> so here's what i got working :) http://lpaste.net/96162 i guess it could be improved in 5000 ways, but at least it's better than what i had
15:29:17 <Iceland_jack> darthdeu: You don't need parentheses around the cases for future reference :)
15:29:32 <Iceland_jack> You also don't need parentheses around: a ++ (f x y) ++ b
15:31:15 <darthdeu> Iceland_jack: cool, i need to use hlint more :(
15:31:21 <darthdeu> Iceland_jack: is there a better way to write that casE?
15:32:22 <Iceland_jack> It looks okay to me, you might want to use printf
15:32:23 <Iceland_jack>     printf "<a href='%s'>%s</a>" href text
15:32:23 <Iceland_jack> instead of
15:32:23 <Iceland_jack>     "<a href='" ++ href ++ "'>" ++ text ++ "</a>"
15:32:26 <Iceland_jack> but either one is good
15:34:11 <Iceland_jack> You can also eta reduce the convert function and remove the empty case:
15:34:12 <Iceland_jack>     convert [] = ""
15:34:18 <Iceland_jack>     convert xs = concatMap convertOne xs
15:34:28 <Iceland_jack>     ↦ convert = concatMap convertOne
15:35:32 <Iceland_jack> > concatMap (const "hi") [] -- You can see that the empty list gives you the empty string
15:35:33 <lambdabot>   ""
15:37:24 <nooodl_> also you could get rid of the case statement. see annotation http://lpaste.net/96162
15:37:59 <Iceland_jack> nooodl_: Yes but that makes you repeat `convertOne' five times
15:38:05 <Iceland_jack> I'm not sure I'd call it better
15:38:16 <nooodl_> true
15:38:30 * hackagebot Spock 0.1.0.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.1.0.0 (AlexanderThiemann)
15:38:35 <Iceland_jack> That's another option though.
15:39:19 <nooodl_> also something much more nitpicky: i think it's unclear to write "(Plain s)" and "(Bold s)", in those patterns?
15:39:32 <arkeet> the parenthese are unnecessary indeed
15:39:44 <arkeet> all of them
15:39:45 <Iceland_jack> nooodl_: What part of that is unclear?
15:39:50 <nooodl_> because that sorta makes it (intuitively) look like they both contain the same kind of data
15:39:56 <arkeet> it does?
15:40:01 <arkeet> to me it's just noise.
15:40:07 <nooodl_> i'm tnot talking about parens
15:40:08 <Iceland_jack> right, s/(Bold s)/Bold t/
15:40:13 <arkeet> oh.
15:40:14 <Iceland_jack> since Bold contains Text
15:40:15 <nooodl_> yeah i'd write Bold t
15:40:29 * arkeet doesn't think it's an issue
15:41:06 <jle`> is there any alternative to monad transformers for combining effects?  the whole thing feels sort of hack-ish to me.
15:41:13 <arkeet> I got slightly confused by the fact that Text is an already-existing type in Data.Text
15:53:12 <carter> ReinH: hehe
16:00:40 <meretrix> Is there any way to take the type "data X = A | B | C" and turn it into a second type "data Y = A Int | B Int | C Int" with something like "data Y = X Int"?
16:01:25 <meretrix> Basically I want to add a parameter of the same type to each constructor.
16:01:40 <scott_> meretrix: (X, Int)
16:01:51 <quchen> data Y = Tuple X Int
16:02:46 <meretrix> Yeah, I guess that will do.
16:15:06 <marx2> any gtk2hs users?  I can't find bindings for gtk_menu_append. judging by the naming convention it should be menuAppend.  I see no other similar function in here: http://projects.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/Graphics-UI-Gtk-MenuComboToolbar-Menu.html
16:20:21 <Jean> whois Jean
16:23:22 <watermind> every once in  a while a package fails to install because some dependency doesn't install
16:23:41 <watermind> then you cabal install the dependency and it installs just fine
16:23:49 <watermind> which is good... but awkward
16:24:24 <geekosaur> that happens when a dependency is an executable. cabal depends on ghc-pkg to track dependencies, but ghc-pkg only knows libraries, not executables
16:25:03 <geekosaur> so things like alex or happy or the gtk2hs buildtools etc. need to be installed manually
16:25:09 <hamishmack> marx2: menuShellAppend (gtk_menu_append is just a wrapper for gtk_menu_shell_append)
16:27:30 <marx2> hamishmack wow you're right, it is just a define in C. thanks a lot!
16:27:47 <volty> hi, suggest code ternary operator?  (and I'm just learning haskell and wondering if I can avoid some trivial guards using a short elegant ternary style if-then-else)
16:28:34 * hackagebot cereal-conduit 0.7.2 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.7.2 (MylesMaxfield)
16:29:39 <quchen> > if 2 > 3 then "true" else "false" -- ternary operator.
16:29:41 <lambdabot>   "false"
16:30:10 <quchen> Most of the time guards are nicer to read though.
16:32:38 <volty> quchen: couldn't I implement (or already implemented) something like 2 > 3 ? true false        ?
16:32:38 <donri> volty: you can, with two operators
16:32:38 <donri> see e.g. cond package
16:32:38 <quchen> There's nothing like that in the standard libraries, but you can implement something close to it.
16:32:38 <volty> 2 > 3 ? true <delim> false ?
16:32:38 <donri> not really recommending it though :)
16:32:38 <volty> ops
16:32:38 <quchen> It's pretty uncommon to do this though.
16:32:38 <volty> sorry, thanks
16:32:38 * quchen should stop being donri's echo
16:32:40 <donri> you were answering first, so i'm the echo ;)
16:33:09 <quchen> m the echo
16:33:12 <quchen> he echo
16:33:13 <quchen> cho
16:33:48 <donri> i'm the cho cho train!
16:35:25 <ReinH> dmwit: ping
16:37:40 <marx2> volty how about: if' (1 > 2) 10 20?
16:37:42 <carter> ReinH: yooo
16:37:44 <volty> second question: anybody here came from ruby?  to give me courage :)
16:37:57 <marx2> trivial to write it as a prefix function
16:37:58 <carter> volty: blackdog and reinH and others
16:38:01 <volty> marx2: i like it
16:38:06 <arkeet> bool 20 10 (1 > 2)
16:38:06 <carter> learning is a thing that everyone can do :0
16:38:25 <volty> arkeet: i have that bool, thx :)
16:38:29 <marx2> if' check trueX falseX = if check then trueX else falseX
16:39:18 <ReinH> volty: yeah
16:39:24 <joelteon> volty: yes
16:39:25 <ReinH> carter: yooo
16:39:27 <volty> do ReinH & others didn't have a painful separation
16:39:29 <volty> ?
16:39:37 <carter> ReinH: i'm really excited
16:39:38 <joelteon> nope
16:39:40 <joelteon> i use both
16:39:44 <ReinH> volty: well, I still have to do ruby for work so it's somewhat painful ;)
16:39:45 <carter> i've figured out my layout data model sanely !
16:39:51 <ReinH> carter: omg!
16:39:55 <ReinH> carter: wait, what is your layout data model?
16:40:06 <carter> for the arrays
16:40:11 <ReinH> oh! great
16:40:29 <carter> the trick bit was making it easy to extend
16:40:34 <carter> while allso supporting "blocking"
16:40:39 <carter> like
16:41:22 <arkeet> @let True ? x = const x; False ? _ = id
16:41:23 <lambdabot>  Defined.
16:41:25 <volty> ok, thanks, going to continue to read -- slowly -- giving time to neurals to re-organize
16:41:27 <arkeet> doh
16:41:27 <arkeet> @undefine
16:41:28 <lambdabot> Undefined.
16:41:39 <arkeet> @let infix 1 ?; True ? x = const x; False ? _ = id
16:41:40 <lambdabot>  Defined.
16:41:53 <arkeet> >  2 > 1 ? 20 $ 10
16:41:54 <lambdabot>   20
16:41:56 <arkeet> >  2 < 1 ? 20 $ 10
16:41:57 <lambdabot>   10
16:42:04 <arkeet> aw he left.
16:42:14 <ReinH> :(
16:42:15 <carter> I want to be able to say I have "rowmajor of 3x3 block of column major of floats"
16:42:26 <ReinH> arkeet: oh the ternary trick? pretty cool :)
16:42:40 <ReinH> carter: o_O
16:42:49 <carter> and have the indexing just work
16:42:57 <carter> and then make it easy to write things like
16:43:23 <carter> "morton sparse of 4x4 blocks of  Columnajor  of 4x4 blocks of rowmajor  of Doubles"
16:43:30 <carter> and have the indexing / slicing just work
16:44:21 <carter> so that layout tyype would look like  :   MortonSparse :# [(4,ColumMajor),(4,RowMajor)]
16:44:22 <carter> roughly
16:44:49 <carter> with a notation like  dynamicShape :# staticlBlocks
16:46:35 <carter> ReinH: yah follow?
16:46:44 <carter> so normal rowmajor would be like
16:46:51 <carter>  Rowmajor :# []
16:47:06 <carter> and columnmajor would be :   ColumnMajor :# []
16:47:17 <carter> and having any interesting blocking would be in that righthand bit
16:47:51 <carter> ReinH: now… imagine if each little 10x10 block was that wee region of a gam gride
16:47:54 <carter> *game grid
16:48:06 <carter> better lookup time for the typical move logic
16:48:43 <carter> yah follow?
16:53:41 <nelk> Is there any way to pattern match on type like the following?
16:53:42 <nelk> toString :: Show a => a -> String
16:53:42 <nelk> toString (s :: String) = s
16:53:42 <nelk> toString a = show a
16:54:19 <carter> nelk: thats not how show owrks
16:54:27 <carter> > show "help"
16:54:27 <lambdabot>   "\"help\""
16:54:41 <carter> show is for printing out a data structure so you can paste it back in
16:54:52 <carter> > putStrLn $ show "help"
16:54:53 <lambdabot>   <IO ()>
16:54:57 <carter> > do putStrLn $ show "help"
16:54:58 <lambdabot>   <IO ()>
16:55:19 <simpson> nelk: What did you want to do?
16:55:19 <carter> chrisdone: we can't print in the repl?
16:55:20 <nelk> The function is meant to call show on something showable, but not if it's already a string
16:55:24 <triliyn> > read (show "help") :: String
16:55:25 <lambdabot>   "help"
16:55:40 <scott_> carter: Lambdabot doesn't execute IO
16:55:41 <carter> nelk: string need their \" escaped
16:55:42 <carter> ok
16:55:45 <nelk> (So that it doesn't add extra quotations)
16:55:48 <carter> yes
16:55:57 <carter> and the point is that if you print it out
16:56:00 <carter> and paste it back into source
16:56:04 <carter> it'd be valid input
16:56:10 <HectorAE> I love parentheses.
16:56:44 <briennetheblue> parentheses is such an ugly word compared to brackets
16:56:56 <carter> dpeends
16:58:37 <nelk> I'm not planning to read the value back in as a string, I just want to call show on something if it is not a string.
16:59:11 <nelk> More generally, is it possible to pattern-match on a type while constraining only the type class (the type being an instance of the class)?
16:59:18 <carter> nope
16:59:22 <carter> you have to write a new type class :)
16:59:43 <carter> whenever you want ot case analyze over types
16:59:53 <carter> you need either a GADT OR a Type class
17:00:12 <monochrom> I know. eat :: Typeable t => t -> String; eat x = case cast x of { Just y -> y; Nothing -> show x }
17:00:40 <arkeet> probably also needs Show t
17:00:45 <carter> yeah
17:00:48 <monochrom> oh oops
17:00:57 <carter> :t cast
17:00:58 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
17:01:10 <monochrom> eat x = case cast x of { Just y -> y; Nothing -> show x }   -- use type inference
17:01:15 <arkeet> :)
17:01:26 <arkeet> eat x = maybe (show x) id (cast x)
17:01:30 <carter> :t http://lpaste.net/96164
17:01:31 <lambdabot> Not in scope: `http'
17:01:31 <lambdabot> Not in scope: data constructor `://'
17:01:31 <lambdabot>     Not in scope: `lpaste'
17:01:32 <carter> oops
17:01:32 <arkeet> oh, use fromMaybe.
17:01:40 <carter> :t eat x = case cast x of { Just y -> y; Nothing -> show x }
17:01:41 <lambdabot> parse error on input `='
17:01:55 <arkeet> :t \x -> fromMaybe (show x) (cast x)
17:01:55 <monochrom> use \x ->
17:01:55 <lambdabot> (Show a, Typeable a) => a -> String
17:02:10 <arkeet> :t let eat x = fromMaybe (show x) (cast x) in eat
17:02:11 <lambdabot> (Show a, Typeable a) => a -> String
17:02:12 <carter> slick
17:02:24 <arkeet> :t liftA2 fromMaybe show cast
17:02:25 <lambdabot> (Show a, Typeable a) => a -> String
17:02:27 <arkeet> ;)
17:02:30 <arkeet> word soup.
17:02:52 <HectorAE> How does lambdabot work that looks cool
17:03:20 <arkeet> lambdabot uses something like ghci to get that type information.
17:03:24 <monochrom> I don't know how to answer that. actually I know, but it's long, and I'm not paid.
17:03:27 <arkeet> I think.
17:03:45 <monochrom> but let's just say: because computers are cool.
17:03:49 <zRecursive> :t cast
17:03:49 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
17:04:01 <arkeet> :t over
17:04:02 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
17:04:10 <arkeet> I guess that got fixed?
17:05:32 <danilo2> Hello :) I've got a smal lquestion to you :) I want to create an indexed tree in Haskell (each node in tree has got unique index and an item) - having the index, I want to acess the node, its children AND its parent without looking through the whole structure. How would you implement it?
17:06:29 <enthropy> sounds zipper-ish
17:06:50 <danilo2> The only idea I've got righr now is to have a map "nodeMap :: ID -> Node" (which will map an ID to a node) and other map "parentMap :: ID -> ID". Additional each node would have its children as array of ID's. But this solution is not "beautifull" (at least to me) -
17:06:51 <enthropy> lens has a zipper thing in there
17:07:04 <donri> zippers still have you traverse up to the focal point though
17:08:56 <danilo2> enthropy, donri: Thank you, I'm looking into zippers right now, brb
17:10:17 <bss03> So, I'm happily using Network.Browser in the HTTP package for connecting to JSON web service.
17:10:41 <bss03> Unfortuantely, upcoming is the requirement to use https: protocol, which Network.Browser does not support.
17:10:59 <joelteon> http-conduit does
17:11:29 <bss03> Suggestions for a module like Network.Browser that supports https: (AND http:)?
17:11:43 <donri> http-{conduit,streams}
17:11:50 <bss03> Preferrably without having to fiddle with an Iteree library, unless it's pipes. :P
17:13:19 <bss03> Bah, I was afraid those were the only two...  No http-pipes, yet?
17:13:22 <joelteon> not that I know of
17:13:23 <donri> pipes-http isn't ready yet, sadly
17:13:30 <joelteon> you could try it
17:13:32 <joelteon> https://github.com/afcowie/pipes-http
17:14:45 <darthdeu> can i somehow pattern match on    '*' : text ++ "*" where text is a string like "*foo*" ?
17:15:00 <darthdeu> or do i have to do '*' : text, and then somehow get the trailing one?
17:15:41 <bss03> darthdeu: Sorry, no pattern matching on (++) it's not a constructor for normal lists.
17:15:43 <donri> '*':xs | last xs == '*'
17:16:01 <joelteon> nope, you can't pattern match on the last element of a linked list
17:16:55 <darthdeu> donri: why is there the | ? isn't that binary or?
17:17:01 <donri> guard
17:17:23 <latro`a> | is distinct from ||
17:17:58 <darthdeu> hmm, so this seems to be working, but it feels wrong http://lpaste.net/96168
17:18:14 <monochrom> | is syntax
17:18:30 <darthdeu> i thought i can only use it in the beginning of a line
17:18:42 <triliyn> convertWord ('*':text) | last text == '*' -> ...; | otherwise -> Plain word
17:18:52 <bss03> darthdeu: donri's solution is good, I don't see an unsnoc that could be used as a view pattern.
17:18:54 <geekosaur> no semicolon
17:18:57 <donri> i would maybe use a parser library or is{Prefix,Suffix}Of
17:19:07 <triliyn> Well, there should be a newline there anyway
17:19:27 <geekosaur> it's optional
17:19:28 <darthdeu> interesting
17:20:04 <bss03> darthdeu: rview from Data.Edison.Seq and view patterns, maybe?
17:20:16 <darthdeus> yeah i would use a parser library in a real world, but i'm just trying to get the hang of doing some simple things
17:20:43 <donri> darthdeus: also most of your parenthesis are redundant
17:21:18 <monochrom> "last text" may crash
17:21:34 <darthdeus> donri: is Bold $ Plain $ init text preferred over Bold (Plain $ init text) ?
17:21:47 <donri> not by me
17:21:51 <donri> i was talking about the other parenthesis
17:21:59 <darthdeus> yeah, i figured :D
17:22:04 <darthdeus>   '*' : text | last text == '*' -> Bold $ Plain $ init text      this works
17:22:05 <arkeet> Bold $ Plain (init text)
17:22:09 <darthdeus> oh
17:22:14 <darthdeus> that makes more sense
17:22:16 <arkeet> is another option
17:22:20 <donri> yeah i'd write it more like arkeet's
17:22:33 <donri> i'm a bit silly though so i might write (Bold . Plain . init) text
17:22:33 <donri> :p
17:22:45 <arkeet> not Bold . Plain . init $ text ?
17:22:52 <arkeet> :P
17:22:59 <bss03> I usually use Bold . Plain $ init text
17:23:09 <arkeet> that's the other thing I might use.
17:23:10 <donri> no, i'm on a diet
17:23:15 <donri> cutting down on ($)
17:23:18 <arkeet> :p
17:23:54 <bss03> I think it's a diet when you cut down on (syntactic) sugar.  It's a budget when you cut down on ($).
17:24:14 <HectorAE> Mmm
17:24:18 <HectorAE> Syntactic sugar
17:24:19 <donri> darthdeus: isSuffixOf from Data.List might be better though, it won't crash on empty text
17:24:26 <donri> :t isSuffixOf
17:24:27 <lambdabot> Eq a => [a] -> [a] -> Bool
17:24:37 <darthdeus> donri: i'll check that out
17:24:56 <bss03> > isSuffixOf "*foo*" "*"
17:24:56 <lambdabot>   False
17:25:16 <HectorAE> So in Haskell, is it like Lua where I can just create a table and put tons of stuff in it
17:25:20 <khyperia> > isSuffixOf "*" "*foo*"
17:25:21 <lambdabot>   True
17:25:24 <bss03> > "*" `isSuffixOf` "*foo*"
17:25:25 <lambdabot>   True
17:25:27 <donri> darthdeus: '*':text | "*" `isSuffixOf` text = (Bold . Plain . init) text
17:26:06 <bss03> HectorAE: Probably not.  Standard containers are homogenous.
17:26:38 <HectorAE> Meaning only one type can go in it?
17:27:01 <donri> :t Dyn
17:27:02 <lambdabot> Not in scope: data constructor `Dyn'
17:27:23 <danilo2> enthropy, donri: I've read something about zippers and it looks like something I'm looking for. Do you know if zippers would be suitable for such purpose: I've got AST (so it is tree but with very different nodes - few datatypes with many constructors). I want to track location in this AST and be able to replace some nodes or find its parent.
17:27:27 <donri> :t Data.Dynamic.toDyn
17:27:28 <lambdabot> Typeable a => a -> Dynamic
17:27:29 <donri> \o/
17:27:40 <bss03> HectorAE: Yes.  There is HList and/oe Dyn/Typeable for when you really need to do hetrogenous containers, but you usually don't.
17:28:03 <HectorAE> But I like heterogenous containers. They let me do easy objects
17:28:14 <HectorAE> Ah well.
17:28:15 <danilo2> enthropy, donri: I would love to make it working as fast as possible - is it possible to make it O(1) (like pointers in cpp) ?
17:28:18 <bss03> HectorAE: Ensuring the types are "right" at compile time (usually a Haskell requirement) is much harder (for you) with a hetrogenous container.
17:28:31 <HectorAE> I see.
17:28:42 <HectorAE> I guess it comes with static typing
17:28:59 <triliyn> :t Data.Dynamic.fromDyn
17:29:00 <lambdabot> Typeable a => Dynamic -> a -> a
17:29:02 <donri> it's perfectly doable
17:29:04 <bss03> HectorAE: Tuples for "easy objects" without names; Record syntax for "easy objects" with names.
17:29:10 <triliyn> Wait, no Maybe?
17:29:20 <donri> triliyn: note two arguments
17:29:22 <donri> :t fromDyn
17:29:23 <lambdabot> Typeable a => Dynamic -> a -> a
17:29:25 <bss03> HectorAE: There's also OOHaskell, but I've not used that.
17:29:32 <donri> :t fromDynamic
17:29:32 <lambdabot> Typeable a => Dynamic -> Maybe a
17:29:43 <arkeet> :t flip fromMaybe . fromDynamic
17:29:43 <lambdabot> Typeable c => Dynamic -> c -> c
17:29:48 <khyperia> can somebody explain Typeable to me?
17:29:50 <HectorAE> Really I hate OO in anything other than Lua so it's not a big deal, bss03.
17:29:57 <triliyn> oh, so it's a default thing
17:30:27 <triliyn> I thought it was a proxy-ish argument for helping type inference
17:30:32 <arkeet> khyperia: Typeable instances carry type information at runtime.
17:30:39 <khyperia> ah
17:31:08 <arkeet> which lets you cast things if the types match
17:31:09 <arkeet> :t cast
17:31:10 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
17:31:26 <arkeet> cast x = Just x if the two types are the same, and Nothing otherwise.
17:31:38 <HectorAE> For me, a beginner, Haskell is basically like "don't touch this crap bro it's dangerous got monads and crap"
17:31:49 <arkeet> or that's the idea, at least.
17:32:11 <HectorAE> I have the Wikibook but it's mostly impenetrable.
17:32:21 <khyperia> HectorAE, have you read lyah?
17:32:30 <khyperia> @where lyah
17:32:30 <lambdabot> http://www.learnyouahaskell.com/
17:32:56 <HectorAE> Hmm let me see
17:33:04 <khyperia> it has funny pictures!
17:33:24 <merijn> HectorAE: Oh, the wikibook is a pretty terrible intro resource
17:33:51 <merijn> HectorAE: LYAH is quite good (and free online), Real World Haskell is decent, by I tend to recommend that as a followup to LYAH
17:34:01 <HectorAE> So this is basically like Why's Poignant Guide To Ruby but for Haskell?
17:34:37 <triliyn> RWH seems to have a lot of errors in it
17:34:41 <arkeet> I like how the wikibook has four chapters: "Haskell Basics", "Elementary Haskell", "Intermediate Haskell", and "Monads".
17:34:41 <triliyn> Most of them trivial but some distracting
17:34:57 <merijn> HectorAE: It was meant to fill that role, yis
17:34:57 <arkeet> (implying monads are a super advanced topic.)
17:35:13 <merijn> triliyn: It's mostly old
17:35:15 <arkeet> I guess I mean parts.
17:35:27 <merijn> triliyn: The trivial errors tend to be changes in libraries that happend after publication
17:35:27 <HectorAE> Well can't be harder than Perl.
17:35:52 <triliyn> merijn: well, by "trivial errors" I mostly mean the typos I think... it's been a while since I read it
17:36:06 <khyperia> Hmm... while I'm waiting for fpcomplete to respond to me about llvm-general... I noticed that the ghc package is installed. How difficult/stupid of an idea is it to hook into the GHC backend and do codegen that way?
17:36:30 <triliyn> The worst set of errors in the online version was a bunch of mock ghci sessions that just had errors in their output
17:36:45 <triliyn> That sounds like something that was probably due to changed libraries (and auto-generated example sessions)
17:36:56 <arkeet> clearly RWH needs doctests. ;)
17:37:19 <merijn> khyperia: DIfficult I don't know, but stupid certainly not
17:38:04 <merijn> khyperia: GHC gets used both as front-end or back-end for several languages
17:41:43 <khyperia> Is there any documentation on it, or do I have to trudge through and guess about everything?
17:42:10 <emiliano111> hi everyone
17:43:10 <khyperia> I mean, http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/ghc/CodeGen.html looks like a very nice API
17:44:30 <emiliano111> quick question… I am trying to understand the pipes package and did a really simple example to see if I understood it. the problem is when I do "runhaskell pipes.hs" it works; but if I compile it and run it, it gets stuck… does anyone know why this might happen?
17:44:56 <emiliano111> I can provide more details
17:45:39 <amosr> emiliano111: that's interesting, are you compiling with -O2?
17:46:03 <amosr> emiliano111: sorry I misunderstood - it compiles fine but runs differently? hm
17:46:19 <emiliano111> yep
17:47:40 <amosr> what version of ghc etc, want to link to pipes.hs?
17:48:01 <emiliano111> sure one sec
17:48:02 <enthropy> danilo2: yes it's appropriate. You're not O(1) to jump to any node in the AST, but for moving one step from/updating the focus should be O(1).... but that's not counting finding that focus and making the zipper
17:48:24 <emiliano111> ghc version is 7.6.4
17:48:26 <emiliano111> 7.6.3*
17:49:26 <danilo2> enthropy: Hmm, ok, but could we do better? (maybe not, maybe the haskell structures would outperform cpp pointers in other ways).
17:49:40 <emiliano111> http://pastebin.com/uuGgx1N3
17:49:42 <mauke> The paste uuGgx1N3 has been copied to http://lpaste.net/96173
17:51:09 <emiliano111> printer just outputs "Hello!" a few times
17:51:25 <emiliano111> and reader reads stdin and outputs the same thing
17:53:30 <amosr> emiliano111: hum, I'm not sure
17:53:55 <emiliano111> hmmm… did you run it by any chance?
17:54:15 <emiliano111> I know that it gets stuck in the second runEffect
17:54:17 <amosr> yeah, it ran but nothing happened for both runhaskell and compiled
17:54:29 <emiliano111> when it tries to produce
17:54:31 <amosr> but it executed and finished
17:54:45 <emiliano111> when it gets to hIsEOF
17:55:09 <emiliano111> so for some reason reader is not responding?
17:55:25 <emiliano111> but there is nothing special happening in it
17:55:28 <amosr> emiliano111: am I supposed to run it with arguments?
17:55:36 <emiliano111> no
17:55:49 <Guest42217> hi guys I was here yesterday asking about this, Exercise 1: http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf
17:56:10 <amosr> I'm running it with 7.6.2, so maybe it's a 7.6.3 thing…
17:56:17 <amosr> very strange though
17:56:31 <emiliano111> maybe
17:56:45 <emaphis> Guest42217: yeah, I remember, but you where using a different nym. :-)
17:57:32 <merijn> ooh! ooh!
17:57:41 <merijn> emiliano111: Check the buffering mode for stdin/stdout
17:57:54 <emiliano111> hmm… how do I do that?
17:57:55 <merijn> emiliano111: I'm betting they're different between compiled and runhaskell
17:58:03 <merijn> hSetBuffering and hGetBuffering
17:58:11 <merijn> @hoogle hSetBuffering
17:58:11 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
17:58:12 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
17:58:25 <emiliano111> okay
17:58:27 <merijn> Bed time for me, now though.
17:58:50 <Guest42217> I have this much: http://pastebin.com/jkKzS8q7
17:58:55 <mauke> The paste jkKzS8q7 has been copied to http://lpaste.net/96174
17:58:56 <emiliano111> okay thanks!
17:59:20 <Guest42217> and am struggling to find how to structure the program
18:00:00 <monochrom> you already have the structure. you just have to answer: where do you put n `mod` 10?
18:01:14 <Guest42217> so the n `mod` 10 I would need to keep track of to construct a list
18:01:28 <monochrom> I don't understand that sentence. but perhaps yes.
18:01:42 <emaphis> Guest42217: i'm kindof a noob myself. Are you trying to create a list of single digits.
18:01:44 <Guest42217> should it be in the same function?
18:01:50 <monochrom> yes.
18:02:06 <Guest42217> hi emaphis, ya that's correct
18:02:13 <Guest42217> hmmm
18:02:33 <emiliano111> merijn: it looks like they are both LineBuffering
18:02:47 <emaphis> Guest42217: you need to 'cons' the current digit onto your list. (i;m not sure of haskell syntax though)
18:03:08 <monochrom> don't over-think. this is supposed to be shallow, not profound. this is supposed to be short, not long.
18:03:37 <monochrom> prepend or append. I don't know which one you want.
18:03:45 <monochrom> but it's just prepend or append.
18:04:00 <emaphis> Guest42217: some thing like (n 'div' 10) :: lst
18:04:36 <emaphis> or however it's done in haskell. :-)
18:04:43 <Guest42217> ya, I just don't get how to creat a list like that, would it be just another variable, have a feeling I'm thinking procedurally
18:04:50 <monochrom> heh yeah, :: is SML's
18:05:05 <emaphis> monochrom: and Scala.
18:05:10 <monochrom> do not think procedurally. think mathematically.
18:06:10 <Guest42217> sorry what does SML's mean?
18:06:25 <monochrom> perhaps the fundamental problem with imperative programming, even just pedagogically, is to teach you to postpone problems by creating more variables, as opposed to solving problems head on, be done, and see how it's trivial.
18:06:32 <emaphis> Guest42217: for your base case you pass an empty list. for your complex case you cons the digit onto your recursion.
18:06:32 <monochrom> it's a language's name
18:07:07 <emaphis> Guest42217: SML is another functional language.
18:07:39 <monochrom> suppose n is 389. so, toDigits (n `div` 10) is [3, 8], I hope? or is it [8, 3]?
18:08:05 <monochrom> let me just say [3, 8] because I doubt you'll answer. it's always a monologue for me.
18:08:14 <Guest42217> oh ok nice, but in this case I need a list variable right?
18:08:21 <Guest42217> sorry for the slow responses
18:08:47 <Guest42217> 38 div 10 would be 3
18:08:53 <monochrom> so n `mod` 10 is 9? toDigits (n `div` 10) is [3, 8]? how do you combine 9 and [3, 8] to get [3, 8, 9]?
18:09:07 <emaphis> Guest42217: No, you create an empty list in your base case.
18:09:20 <monochrom> no, I am not asking you to unfold the recursion further. never do that. never.
18:09:28 <khyperia> So I found this module: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/ghc/MkCore.html are there any GHC wizards in here that could tell me the steps of how to transform a CoreExpr into a binary executable?
18:09:42 <emaphis> Guest42217: then the conses execute when the stack unwinds.
18:09:48 <lemao> how can I generate a 32bit library using ghc/cabal in a 64bit machine?
18:09:51 <monochrom> so n `mod` 10 is 9? toDigits (n `div` 10) is [3, 8]? how do you combine 9 and [3, 8] to get [3, 8, 9]? just answer this. think nothing else. nothing.
18:10:18 <Guest42217> [3,8] : 9
18:10:35 <monochrom> wrong syntax. right direction. find the right syntax.
18:10:38 <emaphis> > [3,9] : 9
18:10:39 <lambdabot>   No instance for (GHC.Show.Show t0)
18:10:40 <lambdabot>    arising from a use of `M1082921020913...
18:11:00 <emaphis> 9 : [3,8]
18:11:12 <monochrom> that becomes [9, 3, 8]. wrong order.
18:11:12 <emaphis> > 9 : [3,8]
18:11:13 <lambdabot>   [9,3,8]
18:11:17 <emaphis> ha
18:11:18 <Guest42217> ohh yes :[
18:11:19 <khyperia> wait, what the heck was that error message?
18:11:24 <Guest42217> sorry should have known that
18:11:55 <Guest42217> > 3 : 8 : 9 : []
18:11:56 <lambdabot>   [3,8,9]
18:12:06 <monochrom> yeah but that doesn't help
18:12:18 <monochrom> because [3,8] is 3:8:[]
18:12:20 <trolling> :t (++)
18:12:21 <lambdabot> [a] -> [a] -> [a]
18:12:31 <monochrom> yeah you'll need ++
18:12:46 <emaphis> thanks trolling
18:12:55 <enthropy> khyperia: you're going to have to look somewhere else in the ghc-api for that
18:12:56 <trolling> np
18:13:04 <TravisD> I think the biggest challenge I'm having with using Haskell practically is coming up with good representations of data. Does anyone know of something I can read about this? Or is it something you need to pick up from practice and looking at examples?
18:13:11 <Guest42217> > 3 ++ 8
18:13:13 <lambdabot>   No instance for (GHC.Show.Show a0)
18:13:13 <lambdabot>    arising from a use of `M9169848835097...
18:13:27 <monochrom> you need lists on the left and on the right
18:13:27 <emaphis> > 3 ++ [8]
18:13:28 <khyperia> I don't even know where to *start*, though, enthropy
18:13:28 <lambdabot>   No instance for (GHC.Show.Show a0)
18:13:28 <lambdabot>    arising from a use of `M7080267745901...
18:13:36 <emaphis> wah?
18:13:38 <HectorAE> Data structures are the best kinds of structures.
18:13:40 <trolling> > [3] ++ [8]
18:13:41 <lambdabot>   [3,8]
18:13:43 <khyperia> the heck is that error...
18:13:45 <Guest42217> > [3] ++ [8]
18:13:46 <lambdabot>   [3,8]
18:13:56 <enthropy> khyperia: one place to start is to look at how ghc itself uses the ghc-api
18:14:08 <emaphis> HectorAE: hi, I see you in #eamcs. :-)
18:14:11 <marx2> is there a function like like this?  (a -> Bool) -> Maybe a -> Bool.  if passed Nothing it should return False, otherwise return (pred x)
18:14:12 <khyperia> alright
18:14:18 <trolling> khyperia: I suspect it's because ghc can't know for certain there's no Num instance for [Int]
18:14:28 <enthropy> there's plenty been written about parser -> renamer -> typechecker -> something else ...
18:14:40 <HectorAE> emaphis, yes, I've been known to hang out in multiple channels at once.
18:14:40 <trolling> :t maybe
18:14:41 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:14:46 <trolling> :t maybe False
18:14:47 <lambdabot> (a -> Bool) -> Maybe a -> Bool
18:15:05 <trolling> marx2: ^
18:15:09 <marx2> nice thanks
18:15:11 <Guest42217> I'm not sure how ++ helps in the exercise, need a second to think about it
18:15:15 <emaphis> HectorAE: I'm in three.
18:15:22 <enthropy> khyperia: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/ghc/CoreToStg.html + http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/ghc/StgCmm.html
18:15:40 <khyperia> awesome, thanks a ton! You just saved me a bunch of time!
18:16:05 <enthropy> there's some more steps between Cmm and machine code I think
18:16:16 <emaphis> Guest42217: except for consing in you complex case, you funtion is almost done.
18:17:11 <enthropy> actually you might be better off using GHC.compileCoreToObj :: GhcMonad m => Bool -> CoreModule -> m ()
18:18:09 <monochrom> most imperative teachers, except Dijkstra, also teach the wrong way to write and read programs, i.e., by execution.
18:18:45 <khyperia> Gunna have to look how CoreExprs construct into a CoreModule, then
18:19:08 <HectorAE> How is execution the wrong way to write programs
18:19:14 <HectorAE> I don't get it at all
18:19:21 <monochrom> when you are confronted with "toDigits n = ___ toDigits (n `div` 10) ___  how do I complete it?", the last thing you want to do is to execute it. execution completely misses the point.
18:20:56 <monochrom> the point is, by induction hypothesis, toDigits (n `div` 10) already gives you [3,8], now how do you build upon that to get [3, 8, 9]. this is totally not about execution.
18:21:45 <HectorAE> When we talk about hypotheses in programming I start to lose the thread of ideas. So shutting up
18:22:05 <monochrom> how do you draw up a divide-and-conquer plan? how do you complete an incomplete divide-and-conquer plan? whatever you do, it is not by executing the incomplete plan "to see what happens".
18:22:26 <Guest42217> is it still exploratory thought?
18:22:28 <TravisD> It's a bit unclear to me how you'd execute the incomplete plan
18:22:47 <emaphis> monochrom: that looks like a Haskell Koan.
18:22:51 <TravisD> I guess you could put in some placeholder functions or something
18:23:06 <HectorAE> We have koans
18:23:11 <HectorAE> This is new.
18:23:59 <emaphis> If a monad maps in the woods does it make a sound?
18:24:20 <Guest42217> if there is a beaver there to listen, yes
18:24:58 <emaphis> veerrry good young padawan.
18:25:20 <Guest42217> I am now learning haskell
18:25:22 <HectorAE> ^
18:26:32 <HectorAE> Gimme one I want a riddle.
18:27:43 <HectorAE> While you're at it, show me hello world. Show me the magics
18:28:26 <emaphis> HectorAE: does Scheme have the Haskell nature?
18:28:37 <HectorAE> Hmm...
18:28:47 <Guest42217> teach a person to fish vs fish moral applies here Hector
18:29:17 <TravisD> HectorAE: I can show you the world. Shining, shimmering, splendid. Tell me princess, now when did you last let your heart decide? I can open your eyes. Take you wonder by wonder, over sideways and under on a magic carpet ride... A whole new world. A new fantastic point of view. No one to tell us no, or where to go, or say we're only dreaming...
18:29:45 <Guest42217> hahaha
18:29:57 <HectorAE> emaphis, the lambdas of Haskell and Scheme are one and the same.
18:30:24 <trolling> a student asked wadler, what is the nature of recursive types in haskell? Wadler replied: mu
18:30:51 <khyperia> Anybody from fpcomplete around?
18:30:52 <Guest42217> :trolling that one went over my head
18:31:00 <Guest42217> trolling: that one went over my head
18:31:20 <Guest42217> actually they all have so far
18:31:36 <HectorAE> We are learning Guest42217.
18:31:36 <trolling> http://en.wikipedia.org/wiki/%CE%9C-recursive_function
18:31:51 <Guest42217> that we are Hector, that much we are
18:32:11 <HectorAE> One day we shall rule the world.
18:32:17 <augur> trolling: lol
18:32:30 <monochrom> the next day the world ends
18:32:37 <augur> trolling: tho mu has nothing to do with recursive functions directly
18:32:38 <Guest42217> hehe
18:32:42 <augur> mu is about recursive types
18:32:55 <trolling> yeah, realised that after I posted the link
18:32:58 <monochrom> different mu's
18:32:58 <trolling> oops
18:33:05 <HectorAE> Guest42217, you are Pinky and I am the Brain.
18:33:08 <augur> newtype Mu F = In { out :: F (Mu F) }
18:33:45 * hackagebot egison-tutorial 3.0.2 - A Tutorial Program for The Programming Language Egison  http://hackage.haskell.org/package/egison-tutorial-3.0.2 (SatoshiEgi)
18:34:03 <Guest42217> going back to my problem, the only way I can pattern match a list is to return one
18:34:24 <Guest42217> so do I need to change my type signature?
18:34:26 <monochrom> that sounds wrong
18:34:52 <Guest42217> hmm ok back to thinking
18:35:15 <monochrom> you are producing a list, not pattern-matching for a list.
18:35:16 <Guest42217> by return one I mean through recursin
18:35:30 <Guest42217> *recursion
18:35:42 <monochrom> that much is right
18:35:50 <khyperia> mgsloan, sorry for pinging, are you around? I have *yet another* question about fpcomplete.
18:37:24 <witt3rd> hi - i've got a data type Expr = Const Int | ... and elsewhere a Seq Expr.  In one of my functions, I want to extract the constant value from the seq of expressions.  I'm currently using index, which gives me the Expr and calling a helper function to return the integer.  Is there a better way?
18:39:33 <Guest42217> am I warmer or colder? http://pastebin.com/ePbvurjc
18:39:34 <mauke> The paste ePbvurjc has been copied to http://lpaste.net/96177
18:39:55 <monochrom> colder. you're postponing the simple problem.
18:39:59 <danbst> witt3rd: that seems to be right
18:40:19 <witt3rd> danbst ok, thanks!
18:40:49 <Guest42217> I have a feeling this is a significant lesson I'm going to learn once I figure this out
18:40:50 <emaphis> Guest42217: you already have a list in your base case.
18:41:25 <monochrom> what do you do to combine [3,8] and 9 to get [3,8,9]. answer this question now.
18:41:36 <Guest42217> emaphis: ya but that's at the end of the recursion process
18:41:36 <monochrom> then do the same thing to your code.
18:41:59 <necronian> lolwut?
18:42:07 <monochrom> do the same thing to toDigits (n `div` 10) and n `mod` 10.
18:42:15 <emaphis> Guest42217: what happens first, recursing or consing.
18:42:24 <Guest42217> [3,8] ++ [9]
18:42:29 <Guest42217> > [3,8] ++ [9]
18:42:30 <lambdabot>   [3,8,9]
18:42:34 <monochrom> yes. now do the same thing to toDigits (n `div` 10) and n `mod` 10.
18:42:40 <joelteon> snoc?
18:42:44 <Aetherspawn> lol
18:42:50 <Aetherspawn> 70% improvement on pipes IO
18:43:10 <Guest42217> there is no n `mod` 10 in my program yet
18:43:16 <monochrom> then add it.
18:43:32 <monochrom> because 9 comes from n `mod` 10
18:43:44 <Guest42217> ok, here we go this is the moment
18:44:03 <monochrom> I am showing you how to use recursion.
18:44:07 <emaphis> > 389 `mod` 10
18:44:08 <lambdabot>   9
18:53:10 <Guest42217> my issue is that I don't have a list to append to
18:53:27 <Kaam> Hi, I'm trying to use the filter from Data.List to along with function composition to strip all "<" ">" and "/"'s from a string, but I'm getting type errors
18:53:40 <monochrom> toDigits (n `div` 10) is a list. it is [3,8]. no?
18:53:46 * hackagebot SVGFonts 1.4.0.1 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.4.0.1 (BrentYorgey)
18:53:55 <monochrom> [n `mod` 10] is a list. it is [9]. no?
18:53:58 <Kaam> Couldn't match type `a0 -> [[Char]]' with `[Char]'
18:53:58 <Kaam>     Expected type: String
18:53:59 <Kaam>       Actual type: a0 -> [[Char]]
18:54:28 <emaphis> Guest42217: yes you do. think about when consing runs in relation to recursiong.  hint. your function is no tail call recursive.
18:54:49 <danbst> Kaam: you forgot an argument =)
18:55:13 <Guest42217> > :t div
18:55:14 <lambdabot>   <hint>:1:1: parse error on input `:'
18:55:16 <danbst> Kaam: the point is - figure out, where?
18:55:19 <Kaam> I gave it two arguements, is it supposed to take two?
18:55:43 <danbst> show your code
18:55:56 <Kaam> striptags xs = filter (/= "<") . filter (/= ">") . filter (/= "/") xs
18:56:05 <Kaam> This is the line mentioned
18:56:08 <emaphis> :t div
18:56:09 <lambdabot> Integral a => a -> a -> a
18:56:17 <monochrom> I don't understand. why are you having doubts about div at this late stage, long after you've used it in your code?
18:56:34 <monochrom> are you trying to unsolve solved problems?
18:56:36 <danbst> striptags xs = filter (/= '<') . filter (/= '>') . filter (/= '/') xs
18:56:40 <Guest42217> doesn't div return an integer, not a list?
18:56:40 <danbst> maybe this?
18:56:41 <Guest42217> hehe
18:57:01 <Guest42217> same for `mod`
18:57:07 <enthropy> striptags xs = filter (/= '<') . filter (/= '>') $ filter (/= '/') xs -- closer I think
18:57:07 <danbst> ah
18:57:11 <monochrom> div in your context gives you an Integer, not a list. why is it important?
18:57:15 <emaphis> > 89 `div` 10
18:57:16 <lambdabot>   8
18:57:18 <danbst> enthropy, yes
18:57:44 <Guest42217> the only list I have is when n hits 0
18:57:50 <enthropy> striptags xs = filter (`notElem` "<>/") xs
18:57:58 <monochrom> no. wrong.
18:58:04 <Guest42217> hmm
18:58:28 <monochrom> why can you not accept that "toDigits (n `div` 10)" is a list?
18:58:41 <emaphis> Guest42217: again when does your recursion run, then when does consing happen.
18:58:47 * hackagebot diagrams-haddock 0.2.1.3 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.1.3 (BrentYorgey)
18:58:58 <monochrom> I am not talking about "n `div` 10". I am talking about "toDigits (n `div` 10)".
18:59:27 <Kaam> So a large part of my issue is just because I used double quotes?
18:59:28 <Guest42217> oh, so that's  a list of evaluated functions correct?
18:59:45 <jle`> Kaam: double quotes for strings/char lists, single quotes for single char
18:59:48 <monochrom> I don't know what is "evaluated functions". it is a list.
18:59:48 <jle`> it's the same convention that's in C
18:59:51 <Guest42217> aka a list of recursive calls
18:59:54 <monochrom> no
19:00:13 <emaphis> Guest42217: more like a stack of recursive calls.
19:00:22 <emaphis> remember how a stack works.
19:00:31 <monochrom> I only see one occurence of toDigits. it looks like just one call. why should one single call not give you a long list?
19:00:41 <danbst> Kaam, filter (...) . filter (...) xs   is incorrect also
19:00:52 <monochrom> no, I disagree that thinking about stacks and execution is helpful.
19:00:57 <Kaam> I was supposed to use function application instead right?
19:01:17 <danbst> Kaam, it must be that   filter (...) . filter (...) $ xs. Right
19:01:48 <danbst> or simply striptags = filter (...) . filter (...)
19:02:18 <Guest42217> monochrom: so you're saying to think mathematically, but not about what the recursive stack
19:02:24 <monochrom> right
19:02:29 <Guest42217> but it is a stack though right?
19:02:51 <Kaam> danbst: Ok thanks I was just trying to get a function that actually DOES something that's somewhat interesting, given that I'm a brand new FP programmer altogether
19:02:52 <monochrom> some stack can be involved. but not in the sense of "it is"
19:03:13 <Guest42217> hmm
19:03:45 <Guest42217> *is doing
19:04:16 <Kaam> danbst: If I wan't to remove all instances of the substring "<html>" from any string, would there be a simple way to do that?
19:04:35 <danbst> Kaam: I see. These type errors do confuse at start, but after something like 6 months you grok type-error-patterns and can start *real programming* =)
19:05:12 <monochrom> ok, what is the complete sentence, without pronouns, that you ask me to agree or disagree?
19:06:07 <Taneb> Ugh, I'm doing Haskell micro-optimization for the first time and it's blech
19:06:20 <Guest42217> do you mean me monochrom?
19:06:23 <monochrom> yes
19:06:40 <danbst> Kaam, there are several solutions. You can use regexp, as simple one
19:06:50 <emiliano111> is it possible to use an EOF character in haskell?
19:06:51 <jle`> danbst: not a trivial problem to implement from scratch in FP, but really isn't one in any paradigm either
19:07:15 <Guest42217> Pattern matching of a list is involved in this exercise
19:07:19 <Guest42217> agree or disagree
19:07:19 <geekosaur> emiliano111, EOF is not a character
19:07:24 <monochrom> no, there is no EOF character. there is EOF detection and handling, but not as a character.
19:07:28 <geekosaur> EOF is a condition
19:07:49 <geekosaur> what are you really trying to do (and why do you think EOF is a character)
19:07:54 <Kaam> danbst: that is part of the SL?
19:08:06 <monochrom> there is hIsEOF, but I think I don't even trust it. I would just go ahead read, and catch the EOF exception.
19:08:08 <geekosaur> EOF was a character in CP/M and early MS-DOS
19:08:16 <danbst> Kaam, what is SL?
19:08:28 <HectorAE> I thought NUL == EOF
19:08:32 <geekosaur> no
19:08:34 <joelteon> nul is nul
19:08:37 <jle`> NUL is just 0x0
19:08:40 <Kaam> danbst: Standard library
19:08:42 <HectorAE> Hm interesting.
19:08:51 <monochrom> unfortunately, there is still no Haskell implementation on CP/M
19:09:00 <geekosaur> NUL is a character. in C it denotes the end of a string, which imits what C can store in a string (and most other languages do not have that limitation)
19:09:09 <emiliano111> so if I have two haskell programs one of which was sending input to another, which checks to see if the next line is eof and doesn't terminate otherwise
19:09:33 <HectorAE> Um...
19:09:45 <Guest42217> Hector, let's create another programming language instead of learning haskell
19:09:51 <geekosaur> EOF is the condition when a read returns 0 characters
19:10:01 <HectorAE> Sounds like a great idea, Guest.
19:10:13 <emiliano111> hm… okay
19:10:36 <geekosaur> it is not a magic "character", except in C stdio where it is also not actually a character but is making use of the fact that the function does not return (char) but (int) (so EOF is a value that is outside the range of (char))
19:10:39 <emaphis> HectorAE: and write a new emacs in it.
19:10:40 <Guest42217> it will involve interpritive dancing syntax
19:10:59 <geekosaur> in Haskell we handle things a little differently, but how it's handled depends on how you are reading
19:11:01 <Guest42217> similar to Thom Yorke dancing
19:11:13 <geekosaur> if you're using lazy I/O, end of file is the same as end of string
19:11:24 <jle`> Guest42217: http://www.youtube.com/watch?v=ywWBy6J5gz8 ?
19:11:26 <HectorAE> Yes, emaphis, Guest42217, and I will form a committee.
19:11:38 <HectorAE> #heg
19:11:48 <emiliano111> yeah but the second program is a loop, so it keeps reading until isEOF returns true
19:11:48 <danbst> Kaam, yes
19:11:51 <emaphis> the dance monad!
19:11:53 <HectorAE> So named for our initials.
19:12:12 <geekosaur> a loop. in haskell.
19:12:24 <emiliano111> okay I call it a loop
19:12:27 <Guest42217> jle`: not expressive enough
19:12:33 <emiliano111> it's a function that calls itself at the end
19:12:48 <geekosaur> and how is that doing I/O?
19:12:55 <emiliano111> loop = do { x <- getLine; putStr x; loop}
19:13:19 <monochrom> if isEOF works for you, I have no complaint.
19:13:27 <haasn> mapM_ putStr =<< fmap lines getContents
19:13:29 <emiliano111> oh yeah and there is iseof in there
19:13:39 <mike4> is haskell good for systems designing?
19:14:05 <emaphis> yes
19:14:16 <emiliano111> but the inputs are coming from another haskell program that doesn't terminate until this one does
19:14:17 <danbst> no
19:14:20 <Guest42217> monochrom: sorry for being helpless, so should I be trying to pattern match a list?
19:14:37 <emaphis> yes!
19:14:44 <haasn> emiliano111: maybe you want to close the input handle from the ‘upstream’ program?
19:14:48 <monochrom> no, that is not the question.
19:14:49 <danbst> why?
19:14:50 <Guest42217> ok
19:14:58 <Guest42217> hmm
19:15:31 <emiliano111> haasn: the difficulty with that is that the upstream program is listening to the output of this program and then printing it...
19:15:53 <emaphis> because
19:16:02 <monochrom> why do you try to pattern match a list? where does the list come from?
19:16:02 <haasn> I think we are using the words “upstream” and “downstream” in the opposite manner
19:16:08 <danbst> it has no objects, but "system" is a tuple ([Object], [relation_between_objects])
19:16:29 <geekosaur> so either you're using a socket and calling shutdown() on the write end, or you are forced to come up with your own distinct "this is the end of the stream" marker in your protocol because you didn't think through how stuff works
19:16:35 <emiliano111> okay so let me be more clear… let's call this program the echoer  that echoes until it gets eof
19:16:47 <Guest42217> right now I'm thinking in terms of guards and pattern matching
19:17:09 <emiliano111> geekosaur: okay… I guess I can do that, but that feels a little unhaskell-y to me
19:17:16 <emaphis> Guest42217: you don't have to patern match. 'div'ing a comparing to zero work fine.
19:17:17 <monochrom> sure, but why list? where does that list come from?
19:17:22 <geekosaur> this has nothing to do with haskell
19:17:51 <geekosaur> if you misdesigned your protocol, haskell can't make it work sensibly, you have to live with a misdesigned protocol. or redesign it to be sane
19:18:05 <emiliano111> okay, what would be a more sane protocol?
19:18:14 <monochrom> I support getting rid of misdesigned protocols
19:18:17 <Guest42217> I need a list to append/prepend to, so I'm trying to think of a case for that to be executed
19:18:26 <Guest42217> for a list to be created
19:18:37 <Guest42217> so I can append to it
19:18:40 <haasn> the world needs more turing complete protocols
19:18:45 <monochrom> pattern matching a list consumes a list, not produces a list.
19:18:49 * hackagebot diagrams-builder 0.4.1 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.4.1 (BrentYorgey)
19:18:58 <HectorAE> Is the world Turing-complete?
19:19:11 <emaphis> Guest42217: you create a list in your base case. Think how non tail recursive functions work.
19:19:14 <geekosaur> if this is a socket then you have a socket operation (shutdown) which is designed for this case
19:19:19 <haasn> was Alan Turing turing-compatible?
19:19:25 <emiliano111> it is not a socket
19:19:39 <HectorAE> The answer is yes, because you can build Turing-complete systems inside the world.
19:19:44 <geekosaur> if this is not a socket then you have separate read and write streams (or you are on OS X or *BSD and it is actually a socket and you can use shutdown on it)
19:19:55 <haasn> HectorAE: really?
19:20:07 * emaphis wonders if i'm turing complete
19:20:13 <emiliano111> oh what?
19:20:14 <emiliano111> okay
19:20:30 <HectorAE> My nick is Turing-complete.
19:20:38 <geekosaur> so you can close the write end of one stream to indicate that you are done sending, this can be detected as end of file, and the other direction is still open to send the response back
19:21:21 <monochrom> http://lpaste.net/96174
19:21:27 <haasn> HectorAE: theoretical physics might have a thing or two to say about turing completeness' implication of an arbitrary large (bounded) tape
19:22:00 <HectorAE> All physics is theoretical...
19:22:15 <haasn> all mathematics is practical? :)
19:22:29 <emiliano111> geekosaur: okay, that is actually pretty helpful, thanks!
19:22:46 <monochrom> there, the complete fish. you can now execute it, if that is your cup of tea, if execution alone can convince you why the recursive call gives you a list.
19:23:19 <emaphis> haasn: that's right. the universe isn't infinite, so it can't be turing complete.
19:23:32 <monochrom> (as opposed to, like, the type signature already tells you you get a list)
19:23:53 <HectorAE> The "theoretical" in "theoretical physics" is misleading because it's used in the sense of being unsupported by observation.
19:23:56 <Kaam> (The implications of an infinite universe)
19:24:26 <haasn> HectorAE: perhaps “hypothetical physics” would be a better term?
19:24:50 <HectorAE> Yes, that's more in line with the standard terminology, haasn.
19:25:28 <monochrom> what are physics and the world doing in #haskell?
19:25:51 <HectorAE> Instantiating it. :D
19:26:04 <mike4> is haskell good for systems designing?
19:26:06 <monochrom> ok, let me make it clear. stop.
19:26:06 <emaphis>  monochrom: speculation about whether the universe is turing complete.
19:26:18 <emaphis> mike4: yes
19:30:47 <jle`> b 11
19:31:30 <Guest42217> so I am reading a little about tail calls, and I have a suspicion that the [] in the base case is the bookend of the ++ function I need to use here
19:31:48 <Guest42217> if that is a coherent statement
19:33:54 <monochrom> I don't know what is bookend. especially "bookend of ++". (I would understand and agree "bookend of the recursions".) but I wrote a non-tail recursion.
19:34:02 <emaphis> Guest42217: what do you mean by bookend? It is just an empty list your consing against.
19:34:34 <monochrom> I don't understand why the tail non-tail issue is important at this stage. this stage of not even accepting recursion to begin with.
19:35:43 <bobcrash> Has anyone here used Data.ConfigFile?  http://hackage.haskell.org/package/ConfigFile-1.1.1/docs/Data-ConfigFile.html
19:35:48 <bobcrash> O
19:36:19 <bobcrash> I'm having trouble wrapping my head around why "readfile" returns "IO (ErrorT CPError IO ConfigParser) rather than just "IO (ErrorT CPError ConfigParser)"
19:37:00 <geekosaur> because ErrorT is a monad transformer, therefore there is a monad that is being transformed (IO)
19:38:02 <bobcrash> hmm thanks.  Still wrapping my head around monad transformers also, but that's a good starting point
19:38:21 <emaphis> Guest42217: you may find this helpful: http://learnyouahaskell.com/recursion
19:39:01 <Guest42217> emaphis: I'll check it out now, thanks, was going through that resource but havent finished that section yet
19:39:15 <geekosaur> my question would be why it's wrapped in IO
19:39:20 <emaphis> np
19:39:29 <jle`> i did think that too
19:40:23 <geekosaur> but it looks like the library design involves making it work with Hugs, among other things, so who knows
19:40:27 <bobcrash> geekosaur:  So yeah, it's the double case of "IO" that has me confused.  I thought the idea was that it reads a configuration from a file, and then returns either a configuration or an error
19:40:40 <bobcrash> If I'd written it, with my neb knowledge it'd return "IO Maybe Config"
19:41:02 <monochrom> readfile :: MonadError CPError m => ConfigParser -> FilePath -> IO (m ConfigParser)
19:41:15 <monochrom> m could as well be simply Error CPError
19:41:32 <monochrom> (does "Error" exist?)
19:41:32 <ion> http://heh.fi/recursion
19:41:50 <geekosaur> I don't think so?
19:42:25 <monochrom> then ErrorT CPError Identity would do just as well
19:42:37 <geekosaur> yeh
19:43:34 <bobcrash> So liftIO, if you're "working inside" a monad transformer which wraps IO, and it makes a function which normally works with IO work with that transfer, right?
19:43:49 <geekosaur> although the docs show examples using Either CPError
19:44:03 <monochrom> yeah, Either CPError is even more elementary
19:44:22 <monochrom> liftIO is relevant to MonadIO only. I don't see MonadIO here.
19:45:03 <bobcrash> they have an example "cp <- join $ liftIO $ readfile empty "/etc/passwd""
19:45:05 <geekosaur> I think the confusion might be that some of the docs talk about using runErrorT for complex cases, but it's not clear to me this is a complex case
19:45:22 <geekosaur> yes that's for using ErrorT
19:45:37 <geekosaur> you don't really need ErrorT there
19:46:26 <monochrom> let's do a little type-checking by hand there
19:46:39 <monochrom> readfile empty "/etc/passwd" :: IO (whatever)
19:46:52 <monochrom> therefore, the liftIO there is a red herring. delete.
19:47:22 <monochrom> cp <- join (readfile empty "/etc/passwd")
19:47:31 <monochrom> but I don't see why use join
19:47:51 <monochrom> which monad is the "<-" using there?
19:48:24 <bobcrash> That' inside their runErrorT block so I'm assuming its the ErrorT IO etc thingy
19:48:43 <zRecursive> :t liftIO
19:48:43 <lambdabot> MonadIO m => IO a -> m a
19:48:56 <monochrom> ok, then it's what geekosaur says. you don't need to do this.
19:49:01 <geekosaur> yeh, lifting to the IO inside ErrorT CPError IO
19:49:09 <monochrom> and I was wrong about deleting liftIO
19:49:49 <geekosaur> that is one annoying API...
19:50:05 <geekosaur> I can see why you're confused :/
19:51:12 <bobcrash> I've gotten a USB-HID api working, a gui api working, concurrency working, but this API for handling freakin INI files is making me feel like an idiot ;)
19:51:48 <geekosaur> it's either a bad API or a badly documented API. the haddock was really annoying me
19:52:00 <geekosaur> if I'm having trouble figuring out what's going on...
19:52:05 <bobcrash> haha
19:52:36 <geekosaur> (granted, I am far from the best Haskeller in the room, but that was still Really Bad)
19:53:03 <NemesisD> what's that pharse that SPJ uses a lot. its something like obviously correct
19:53:20 <NemesisD> for code you can just look at and see that there are no defects
19:53:31 <monochrom> I only know that he closes his eyes a lot. if that counts as a phrase.
19:53:44 <geekosaur> heh
19:53:48 <NemesisD> lol
19:54:24 <monochrom> ok, now someone not in the know will deduce, "so SPJ closes his eyes and still sees whether code is correct or not"
19:55:35 <dpwright> argh I'm getting "cabal: <file descriptor: 8>: resource exhausted" trying to do "cabal update" on my linode :-(
19:56:02 <geekosaur> I can tell you just from that reading I would not want to use that in any program of mine, at least not until someone makes that haddock comprehensible
19:56:10 <dpwright> does anybody know the cause of this (and does it involve fiddling with ulimit?)
19:56:11 <monochrom> in the japanese manga Saint Seiya, there was an amazing guy who could fight and win without eyes closed usually. "but if he opens his eyes, you are really really doomed."
19:56:27 <monochrom> err, s/without/with/
19:57:23 <geekosaur> dpwright, I doubt ulimit will help although there is not enough information there to be certain. I would have to guess either you ran up against a resource limit on your linode instance, or the hardware it's running on currently is oversubscribed
19:58:00 <dpwright> geekosaur: Thanks... I'm not really doing that much on it at the moment I don't think... maybe I should wait a bit and try again later
19:58:06 <geekosaur> the former would have to do with the level of service you're paying for, the latter is something to contact linode about
19:58:34 * geekosaur notes that he does not actually work with linode so has no idea what if any service levels they have...
19:58:41 <Guest42217> YES, it works but backwards, now i just want to make sure I completely understand why it works
19:58:48 <NemesisD> i'm doing some code kata stuff on exercism.io for some reason. man haskell has such an unfair advantage over other languages at pure code katas
19:59:00 <bobcrash> geekosaur:  Yeah, I think I'll try a different library.  I do want to get my head around this first though just because its really bothering me not to understand"
19:59:19 <NemesisD> on almost every kata i've done, i've looked at a random haskeller's answer and their mirrors mine verbatim aside from variable names
19:59:22 <dpwright> what does "cabal update" actually do? could I just grab the package file with curl/wget/whatever and stick it in the right place?
19:59:23 <geekosaur> but with VPS services there's always the risk that you either hit the limit of what your instance can do or that the hardware is doing too many things at once and you'll hve to try again later
19:59:47 <NemesisD> the OOP solutions vary greatly in complexity and solution. i gotta think this speaks to some advantage of haskell
20:00:39 <geekosaur> I would guess that "resource exhausted" means it got EAGAIN when it wasn't expecting it, but I haven't looked closely at that part of the ghc runtime
20:00:40 <Taneb> Hmm
20:00:52 <NemesisD> that solutions to problems with well defined input/output do not leave much room for reinterpretation and overarchitecting
20:01:44 <NemesisD> lots of the early katas are basically String -> String, several ruby solutions subclass String and tack a bunch of methods onto it D:
20:02:01 <Guest42217> thank you guys, I have generated the correct output, but in reverse, now to draw it out on paper to make sure I understand
20:02:41 <Taneb> How can I get something of the form do {a <- [1..100]; b <- [1..a]; return (a, b)} to play nice with foldr?
20:02:50 <emaphis> Guest42217: It's hard to get your mind around recursion sometimes.
20:02:58 <ion> What does “play nice with foldr” mean?
20:03:32 <Taneb> ion, fuse
20:04:16 <monochrom> perhaps rewrite using map and concat.
20:05:07 <monochrom> or concatMap directly
20:05:23 <Guest42217> ok I'll look that up
20:07:58 <Taneb> monochrom, didn't work :(
20:08:01 <Guest42217> bye guys, thanks again
20:08:10 <HectorAE> Bye Guest42217.
20:08:14 <HectorAE> Remember to keep learning.
20:08:16 <monochrom> then I don't know
20:08:23 <Guest42217> :] yes I will try
20:08:37 <emaphis> g'night Guest42217
20:08:41 <Guest42217> and we will be haskell experts one day
20:08:58 <Guest42217> goodnight emaphis thanks
20:09:13 <Taneb> It should be possible to do this without allocating :(
20:09:18 <emaphis> one looong day ;-)
20:09:44 <Guest42217> yes it was :] hehe, and for monochrom too, he must have been frustrated
20:09:50 <monochrom> last try: add -fno-full-laziness
20:10:10 <Guest42217> bye
20:10:42 <Taneb> monochrom, nope :((
20:10:50 <monochrom> then I really don't know
20:13:01 <bobcrash> What exactly determines the monad type used by a "do" block?  Given a do block is basically sugar for composition of ">>=" and ">>" does it just come down to standard type resolution between the "<-" inside it and whatever is calling the do block?
20:15:10 <geekosaur> pretty much, yes. the first (>>) or (>>=) sets the monad and subsequent ones must match
20:15:26 <ion> It can be dictated by something that constrains the type within the block, or it can come from the outside.
20:15:52 <geekosaur> ..this can confuse beginners who forget to do actual I/O when that's what they intend and the list monad gets picked because they were using a String
20:15:58 <dwcook> You might not even have a specific enough type on the first line, in which case hopefully you get one eventually.
20:16:02 <ion> do { a <- Just 42; … } constrains it to the Maybe monad; do { a <- return 42; return a } has no internal constraint.
20:16:23 <ion> > do { a <- return 42; return a }
20:16:24 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
20:16:24 <lambdabot>    arising from a use of `M82964166...
20:16:25 <dwcook> > do { x <- return 10 ; y <- [1, 2, 3] ; return (x, y) } -- silly example
20:16:26 <ion> > do { a <- return 42; return a } :: Maybe Integer
20:16:26 <lambdabot>   can't find file: L.hs
20:16:26 <lambdabot>   [(10,1),(10,2),(10,3)]
20:16:36 <ion> > do { a <- return 42; return a } :: Maybe Integer
20:16:36 <bobcrash> Cool, that's about what I was thinking.  Yeah, that "No Instance for ..." was killing me for a few minutes
20:16:37 <lambdabot>   Just 42
20:17:09 <ion> It just means something has to pick a concrete Monad instance for it.
20:17:43 <arkeet> :t do { a <- return 42; return a }
20:17:44 <lambdabot> (Monad m, Num b) => m b
20:17:51 <dwcook> You can easily write generalized monadic combinators and such using do, no problem
20:18:07 <dwcook> All that matters is that when they're used, a concrete type is available
20:19:13 <dwcook> > let liftM f m = do { x <- m ; return (f x) } in liftM (+1) [1, 2, 3]
20:19:14 <lambdabot>   [2,3,4]
20:19:39 <dwcook> @type let liftM f m = do { x <- m ; return (f x) } in liftM
20:19:39 <lambdabot> Monad m => (t -> b) -> m t -> m b
20:23:54 * hackagebot extensible-effects 1.1.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.1.0 (BenFoppa)
20:28:13 <isomorphic> @src [] (return)
20:28:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:28:26 <isomorphic> @src [] return
20:28:26 <lambdabot> return x    = [x]
20:31:09 <vividpaws> is this where i into haskell
20:31:33 <emaphis> yes
20:31:56 <geekosaur> you accidentally a verb...
20:31:57 <vividpaws> i'm reading learnyouahaskell book is this a good idea?
20:32:05 <emaphis> yes
20:32:11 <nelk> It's quite good - that's where I started.
20:33:05 <vividpaws> I guess I'll be back when I'm done. Thanks new friends
20:33:31 <isomorphic> vividpaws:  Ask questions as you go.  If I know the answer, I'll help
20:33:33 <ion> Better to ask questions while you’re reading it.
20:33:46 <vividpaws> wow new friends are so smart
20:33:50 <vividpaws> i will be on standby friends
20:34:03 <emaphis>  good
20:34:18 <HectorAE> Friends be smart.
20:34:30 <HectorAE> That's why we have them.
20:35:54 <emaphis> strongly depends on the friends.
20:37:33 <vividpaws> alright then, friend test: will doing project euler give me practical problem solving skills? If i read this learnyouahaskell book, where do I go to learn how exactly to use the language?
20:37:46 <Aetherspawn> the first like 20 are okay
20:38:00 <Aetherspawn> after that they get kind of hard or tedious
20:38:16 <emaphis> vividpaws: project euler is a good way to learn.
20:41:17 <vividpaws> I hear disecting others' code is the most efficient way to get good at this. Where do I find friendly small programs for this? Github?
20:42:47 <isomorphic> vividpaws:  LYAH has very topical things
20:43:06 <isomorphic> Also see Real World Haskell, which has longer examples that they build up
20:43:28 <vividpaws> hooray
20:43:28 <emaphis> vividpaws: that would work. just look for haskell projects in topics that interest you on github.
20:43:56 * hackagebot bittorrent 0.0.0.3 - Bittorrent protocol implementation.  http://hackage.haskell.org/package/bittorrent-0.0.0.3 (SamTruzjan)
20:44:08 <emaphis> vividpaws: http://book.realworldhaskell.org/
20:44:34 <jle`> project euler is a very bad way to learn a language
20:45:53 <vividpaws> my goal is to manipulate filesystems at a binary level to manage corrupt data, does anyone have experience with this?
20:46:21 <vividpaws> corrupt data and harddrive failure
20:46:44 <isomorphic> Stupid question - but …  I'm making a function that has something that looks a lot like bind (but without an explicit monad instance).   I think what I want to do is thread two parameters through on each bind operation, but I'm not sure how to do that syntactically - any suggestions?
20:46:52 <emaphis> vividpaws: RWH has a chapter on systems programming: http://book.realworldhaskell.org/read/systems-programming-in-haskell.html
20:47:18 <vividpaws> woo thanks #1 haskell friend
20:47:35 <isomorphic> vividpaws:  You'll probably want to look at the haskell FFI also
20:50:51 <isomorphic> @src sequence
20:50:51 <lambdabot> sequence []     = return []
20:50:51 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:50:51 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
20:52:08 <joelteon> libgcc_s is in /usr/lib, what's going on? https://gist.github.com/anonymous/939210d8fc1085e76250
20:52:10 <joelteon> should I ask #ghc?
20:52:57 <geekosaur> which one(s) exactly is/are there?
20:54:02 <joelteon> /usr/lib/libgcc_s.{1,10.4,10.5}.dylib
20:54:43 <joelteon> oh, there's a caveat on the hackage page
20:54:48 <joelteon> this is only expected to work on linux
20:54:49 <carter> yeah, the haakell ffi is nice
20:54:53 <TravisD> Are there some exercises that could accompany LYAH?
20:54:58 <joelteon> that's kinda dumb
20:55:03 <joelteon> maybe i should fork it
20:55:11 <carter> joelteon: which lib?
20:55:29 <joelteon> bits-extras
20:55:38 <carter> @hackage  bits-extras
20:55:38 <lambdabot> http://hackage.haskell.org/package/bits-extras
20:56:05 <carter> joelteon: i think edwardk has a lib that does those
20:56:06 <carter> bits
20:56:14 <joelteon> hmm
20:56:15 <joelteon> ok
20:56:17 <carter> http://hackage.haskell.org/package/bits
20:56:38 <joelteon> bittorrent depends on bits-extras
20:56:41 <joelteon> guess i gotta fork that too
20:56:47 <carter> give em a patch!
20:56:48 <carter> yeah
21:00:02 <vividpaws> what does the FFI stand for
21:00:15 <geekosaur> foreign function interface
21:00:19 <ion> @google what does FFI stand for
21:00:20 <lambdabot> No Result Found.
21:00:46 <vividpaws> i feel so equipped to learn
21:00:47 <emaphis> @google FFI
21:00:48 <lambdabot> http://www.ffi.no/
21:00:48 <lambdabot> Title: Forsvarets forskningsinstitutt
21:00:52 <ion> hehe
21:00:56 <ion> @google FFI haskell
21:00:57 <lambdabot> http://www.haskell.org/haskellwiki/FFI_Introduction
21:00:57 <lambdabot> Title: FFI Introduction - HaskellWiki
21:01:06 <emaphis> WAH?
21:01:44 <isomorphic> vividpaws:  The FFI lets you call things like C programs.  If you're interfacing to some already made low lever library, you'd probably use it
21:02:31 <kirstin> um, foreign function interface...
21:03:04 <Aetherspawn> preliminary pipes 4 benchmarks show pure pipes to be 5.5x faster than conduits
21:03:57 * hackagebot system-random-effect 0.1.0.0 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.1.0.0 (ClarkGaebel)
21:04:50 <mikeplus32> Aetherspawn: link?
21:09:52 <Aetherspawn> mikeplus32: https://gist.github.com/kvanberendonck/7622803
21:17:53 <khyperia> What's the difference between, say, Int32 and Word32? (aka Int vs. Word)
21:18:17 <simpson> khyperia: Signed vs. unsigned.
21:18:21 <simpson> > -1 :: Word16
21:18:22 <lambdabot>   65535
21:18:28 <khyperia> Ah. Thought so, but just wanted to make sure.
21:18:40 <danbst> > MAX_INT
21:18:41 <lambdabot>   Not in scope: data constructor `MAX_INT'
21:19:35 <khyperia> > maxBound :: Int16 -- is this what you meant, danbst?
21:19:36 <lambdabot>   32767
21:19:50 <danbst> maxBoun :: Int
21:19:55 <danbst> maxBound :: Int
21:19:59 <danbst> > maxBound :: Int
21:20:00 <lambdabot>   9223372036854775807
21:20:08 <danbst> > maxBound :: Word32
21:20:09 <lambdabot>   4294967295
21:20:20 <danbst> > maxBound :: Int32
21:20:21 <lambdabot>   2147483647
21:20:34 <danbst> khyperia, thanks
21:20:54 <khyperia> maxBound/minBound come from http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Bounded
21:21:01 <danbst> > 2 ^ 31
21:21:02 <lambdabot>   2147483648
21:21:15 <khyperia> wait, there's a instance of Bounded for ()?
21:21:25 <khyperia> > maxBound :: ()
21:21:26 <lambdabot>   ()
21:21:29 <khyperia> Huh.
21:21:31 <johnw> why wouldn't there be?
21:21:34 <kirstin> Well, it *is* bounded....
21:21:36 <johnw> the min and max bounds are the same value
21:21:58 <johnw> you can put deriving Bounded on most enumerated types
21:22:22 <external-reality> Does there exist an explanation of Yi editor source code somewhere.
21:22:23 <isomorphic> is the bound exclusive/
21:22:24 <external-reality> ??
21:22:42 <johnw> isomorphic: it couldn't be exclusive, there isn't a "one beyond the end" value
21:23:03 <johnw> it's up to you to use < maxBound or <= maxBound
21:23:21 <isomorphic> johnw:  I guess I just had trouble with the idea of () having a bound of () that was inclusive
21:23:30 <kirstin> external-reality: there isn't really much user doc on Yi. Sad.
21:23:42 <kirstin> Let alone dev doc.
21:25:10 <external-reality> Well I guess I'll have to look at commits that change things close to what I am trying to change.
21:25:51 <external-reality> Never really like to do that unitl I have some sort of picture but hey...
21:26:15 <kirstin> Godspeed to you. Emacs, forever, really?
21:26:47 <bitemyapp> kirstin: Emacs uber alles.
21:26:56 <bitemyapp> kirstin: also I thought Leksah was preferred over Yi?
21:27:24 <kirstin> Leksah is nice, if you like Eclipse, I guess...
21:27:41 <bitemyapp> kirstin: not really expressing an opinion or value judgment so much as what I thought people actually used.
21:27:45 <external-reality> Yi would be the most awesom thing if it actually worked. yi as=emacs is probably the closest thing to emacs thats not really emacs that I can think of.
21:27:46 <bitemyapp> kirstin: there's EclipseFP too
21:28:32 <khyperia> I like EclipseFP, but I think I'm about to run into big problems with its requires-cabal-file system
21:29:23 <bitemyapp> khyperia: this would be why I just use Emacs.
21:29:51 <khyperia> I'm considering switching to emacs... but change is so hard! :P
21:30:13 <kirstin> I still don't know how to do ctrl-c l in Yi :-(
21:30:46 <bitemyapp> I use Emacs partly because I want to invest in a tool that will last.
21:30:51 <TravisD> there was a discussion of structural editing for Haskell in emacs. Does anyone know what emacs mode they were talking about?
21:31:06 <kirstin> Yi knows how to do that!
21:31:24 <bitemyapp> TravisD: http://chrisdone.com/posts/haskell-emacs-ifs https://twitter.com/christopherdone/status/257161950767742976
21:31:38 <kirstin> omg
21:31:39 <TravisD> thanks!
21:31:50 <TravisD> rem, the video is unavailable
21:31:50 <bitemyapp> the "code aware" structuring in Emacs reminds me of the Erlang mode for Emacs
21:32:14 <bitemyapp> neither are on par with paredit or smartparens for Lisp/Clojure/Scheme, but they're a lot better than most languages.
21:32:22 <bitemyapp> I'm not really sold "syntax" is a good idea anyway.
21:36:10 <TravisD> how do you uninstall things you have installed via cabal?
21:36:27 <Aetherspawn> ghc-pkg unregister whatever
21:36:35 <Aetherspawn> although thats probably bad
21:36:48 <TravisD> ah
21:37:02 <bitemyapp> TravisD: so just a heads up, cabal is just automation/wrapping around ghc-pkg
21:37:09 <bitemyapp> TravisD: ghc-pkg is the actual foundation of the packaging system.
21:37:16 <TravisD> ah, I had no idea
21:37:41 <bitemyapp> right that's why I'm mentioning it instead of spewing terminal commands
21:38:00 <bitemyapp> so in general if cabal doesn't do something, it's because it's considered a "lower level" need that ghc-pkg or something else should handle.
21:38:28 <TravisD> and removing a package is one of those things?
21:40:37 <bitemyapp> TravisD: it's generally a weird thing to do.
21:40:48 <bitemyapp> TravisD: why do you even need to unregister a specific package?
21:41:06 <thobel> Don't you have to unregister if you get dependency issues? cabal seems to be bad at upgrading
21:41:16 <bitemyapp> not really
21:41:28 <bitemyapp> you should be using sandbox and letting the package dependencies do all the work.
21:41:29 <TravisD> I want to try out leksah, so I installed it via cabal. But then I saw that there was a binary package for mac os and I wanted to use that instead. To keep a clean environment, I didn't want two versions of the same thing
21:41:52 <bitemyapp> try to avoid using global packages if you can help it unless it's a utility.
21:42:03 <bitemyapp> cabal sandbox exists, know it, love it, use it.
21:42:22 <thobel> ah, i did not know of this sandbox thing
21:42:48 <bitemyapp> I cannot stay sane with Haskell packaging without cabal sandbox.
21:42:55 <thobel> yeah it looks fancy
21:43:20 <n448> before i start haskell , do i need any prior experience?
21:43:53 <roconnor> n448: it is best if you do not have prior experience
21:44:01 * hackagebot tempodb 0.2.0.0 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.0.0 (ParnellSpringmeyer)
21:45:06 <n448> but the page says "advanced" purely-functional programming language  , just asked since it says advanced
21:45:21 <augur> there's something philosophically/logically beautiful about how => is used in haskell type classes
21:45:36 <augur> because the use is not at all uniform, but actually kind of dual
21:46:54 <Aetherspawn> crazy
21:47:01 <augur> consider:   class Functor f => Applicative f where ...   vs   instance Applicative f => Functor f where ...
21:47:09 <kirstin> hsenv is better than cabal-dev, generally
21:47:11 <Aetherspawn> one day, installing stuff with cabal fails dismally
21:47:16 <augur> both make sense, but they have a different sort of use
21:47:17 <Aetherspawn> the next, magically works
21:47:18 <thobel> probably helps to know some basic category theory language, but only so much is helpful
21:47:46 <augur> => in a class def declares a precondition on giving an instance, whereas => in the instance def gives a way of inducing new definitions
21:48:26 <augur> in a sense, => in class defs is a modal operator:   X => Y in the class def means "if you can show X, you __may try__ to show Y"
21:48:55 <augur> but    X => Y   in the instance def means "if you can show X, then you __can__ show Y"
21:51:38 <kirstin> So here's a question on that subject: Let's say I want to define a typeclass Id, which has a "method" identity.
21:53:03 <kirstin> And then I'd like to say than anything with Idenitity can automatically derive Eq, from Identity Foo => Eq Foo via (identity x) == (identity y)
21:53:19 <augur> kirstin: ok
21:53:45 <kirstin> But it doesn't seem possibly without newtype wrappers.
21:53:52 <kirstin> possible
21:53:56 <augur> why?
21:54:04 <kirstin> Let's try it...
21:54:08 <augur> i mean, it depends on what your identity method is supposed to be doing, ofcourse
21:56:00 <kirstin> it's just a method, identity :: Eq b => a -> b
21:56:42 <augur> so
21:56:56 <augur> class Identity a where identity :: Eq b => a -> b
21:57:12 <kirstin> yep
21:57:20 <augur> instance Identity a => Eq a where a == a' = identity a == identity a'
21:57:30 <kirstin> yep
21:57:44 <augur> whats the problem
21:57:47 <enthropy> what is a meaningful instance of Identity?
21:58:10 <johnw> is there a function like interact, but which modifies files?
21:58:18 <kirstin> Oh, it could be a GUID, or a database row, or something more wierd
21:59:11 <enthropy> well as you've written it, I get to pick any type that's got an Eq instance to be the result of identity
21:59:35 <kirstin> hold on, I'm having issues with emacs+ghci...
21:59:45 <kirstin> recent upgrade...debian.
22:00:21 <thobel> so glad emacs24 is in debian now
22:00:29 <enthropy> so suppose you had  instance Identity I. Then you are supposed to be able to call   identity :: I -> (); identity :: I -> Int; and so on
22:00:30 <kirstin> ;-)
22:00:52 <kirstin> yep
22:00:58 <thobel> my dotfiles repo shrank so much, and I got to throw ghc-mod in there
22:01:40 <augur> kirstin: thats a problem with overlapping instances tho
22:01:58 <enthropy> kirstin: also, if I write in another module:  data J = J1 | J2 deriving Eq,  I also get call   identity :: I -> J
22:02:05 <augur> so i guess in practice sure, you'd have to use newtypes (or maybe fundeps)
22:02:23 <enthropy> so pretty much you're out of luck for writing a sensible   instance Identity I
22:02:39 <external-reality> In Yi it appears that an "editor's" windows are stored in a Pointed Listed. Thats right not a "window store" that happens to be implemented with a pointed list -- no just a raw pointed list.
22:03:16 <external-reality> I hate to be critical but come on now.
22:05:15 <lpaste> isomorphic pasted “Infinite type. ” at http://lpaste.net/6545418069047508992
22:05:31 <enthropy> external-reality: well using `type' instead of `newtype' is more convenient
22:05:31 <isomorphic> I'm trying to create something similar to sequence, that when operating on a list of lists, does not generate lists having any repeated elements, eg: sequencePlus [[1,2][2,3]] = [[1,2],[2,3],[1,3]].   I have an error that I don't really understand.  Paste is above.  Any ideas?
22:05:39 <kirstin> {-# LANGUAGE FlexibleInstances, UndecidableInstances #-}
22:05:39 <kirstin> module Foo where
22:05:40 <kirstin> class Identifiable a where identity :: Eq b => a -> b
22:05:40 <kirstin> instance (Identifiable a) => Eq a where x == y = identity x == identity x
22:07:17 <kirstin> Maybe that makes some sense? If we have a property (eg. identity, which gives us a ==, then we should be able to used that to make any Identifiable as an Eq)
22:09:03 * hackagebot tempodb 0.2.0.1 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.0.1 (ParnellSpringmeyer)
22:09:31 <TravisD> kirstin: Is the purpose of this type class to all you to identify objects of one type with objects of another type (like, maybe an alternative representation of the same thing) and then to say that two things are equal if their alternative representations are equal?
22:09:37 <TravisD> to allow*
22:10:21 <kirstin> I'm not totally sure. I think it's just to abstract away the notion of equality vs identity.
22:10:56 <kirstin> That's probably a silly distinction.
22:11:32 <TravisD> or a very deep one
22:11:36 <enthropy> well you have to say which one you want, right?
22:11:39 <TravisD> eg: http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf
22:15:24 <external-reality> ethropy: apologies, I overreacted.
22:15:27 <kirstin> I think the idea would be to allow one to allow one to generate some sort if unqiue identifier of a thing, just like one might want to generate a unique hash code
22:15:38 <kirstin> some sort of ...
22:15:44 <kirstin> not if
22:16:32 <kirstin> Given a hash code, or a unique identifier, one could use that to add plenty of useful functions.
22:16:52 <enthropy> external-reality: I just think you can complain whichever way the design goes
22:17:25 <toki78> hey jo
22:17:29 <toki78> :)
22:17:41 <enthropy> but probably my biggest issue is when everything is type, and there doesn't seem to be a way to get :t to expand type synonyms
22:18:29 <external-reality> enthropy: It not a problem of design that I complain about but one of domain abstraction.
22:18:35 <enthropy> so understanding what's going on still involves a translation which doesn't show up as a constructor/function involving it
22:19:27 <enthropy> @hackage unordered-containers
22:19:27 <lambdabot> http://hackage.haskell.org/package/unordered-containers
22:20:07 <enthropy> that's one use of a 'generate a unique identifier of a thing'
22:24:31 <external-reality> enthropy: I also see really bad naming, poor directory structure is some parts, very few docs, and of course poor domain abstraction, all amounting to code that is very hard to understand. Which is probably why Yi development has slowed to a crawl.
22:24:59 <external-reality> I let my tongue fly too often.. forgive me.
22:39:45 <zRecursive> :t fix
22:39:46 <lambdabot> (a -> a) -> a
22:40:07 <zRecursive> @src fix
22:40:07 <lambdabot> fix f = let x = f x in x
22:41:00 <augur> fix f = f (fix f)   but you want it to memoize the fix f part
22:41:06 <rohloh> hey guys, I'm pretty new to haskell and am currently working on a project where i compute the root of a function using the method of false position. I got the the algorithm to work just fine and now i need to work on a stopping criterion. I am currently creating an infinite list of consecutively better approximations. my problem is that I can't figure out where to cut off the list. What I would like to do is take the first n element
22:41:07 <rohloh> the list where the nth element is within a tolerable error. to compute the error i need to look at the the nth , (n-1)st, and (n-2)nd elements. any ideas? here is my code so far http://pastebin.com/TFimsVwW
22:41:11 <mauke> The paste TFimsVwW has been copied to http://lpaste.net/96181
22:41:38 <zRecursive> augur: (f (f (f ...)))  ?
22:41:43 <augur> zRecursive: yes
22:42:27 <augur> zRecursive: it only works because of laziness, tho
22:42:56 <augur> you only evaluate what you need to, so if f doesn't use its argument in certain places, then you're right.
22:43:01 <augur> eg
22:43:09 <augur> > fix (\x -> "foo")
22:43:09 <lambdabot>   "foo"
22:43:52 <zRecursive> > fix (\_-> "foo")
22:43:52 <lambdabot>   "foo"
22:44:03 <augur> any system where substitution happens before you evaluate the args has this property
22:44:06 <augur> (\x -> "foo") (fix (\x -> "foo")) =beta=> "foo"
22:45:21 <zRecursive> the side effect is form recursion
22:45:32 <augur> zRecursive: the side effect?
22:46:17 <zRecursive> not accurate though, i mean if you use the passed args
22:46:27 <augur> im not sure what you mean
22:47:04 <zRecursive> "fix $ \more -> do   x <- getAnyProcessStatus False False  when (isJust x) more"
22:47:38 <zRecursive> The "more" is used then form recursion ?
22:47:57 <augur> oh yes
22:48:07 <augur> i mean, `more' here is supposed to be the function you're defining, right
22:48:17 <zRecursive> i see
22:48:19 <augur> thats what these function arguments are
22:48:51 <augur> fac = \x -> case x of { 0 -> 1 ; x' -> x' * (fac (x' - 1)) }
22:49:00 <augur> now you abstract over fac in the rhs and fix:
22:49:18 <augur> fac = fix $ \f -> case x of { 0 -> 1 ; x' -> x' * f (x' - 1) }
22:49:49 <zRecursive> yeah
22:50:52 <enthropy> missing an \x -> too
22:50:59 <augur> that too
22:51:13 <augur> fac = fix $ \f -> (\x -> case x of { 0 -> 1 ; x' -> x' * f (x' - 1) })
22:51:28 <joelteon> it's just \f x -> ...
22:51:53 <augur> joelteon: yes but that form obscures the purposes of the parts, making f and x seem of equal status in the whole
22:52:00 <joelteon> oh
22:52:19 <augur> the \f is bound by the fix, so fix $ \f -> ... looks like a binder
22:52:25 <augur> fix f. \x -> ...
22:53:39 <Kneiva> > takeWhile (<8) $ dropWhile (<5) [1..]
22:53:40 <lambdabot>   [5,6,7]
22:53:45 <augur> the naive fix repeatedly keeps putting fix f into recursive positions tho, whereas the let version just flips up a single variable that gets evaluated once
22:53:57 <enthropy> rohloh: you want to reuse the previous values of the approximation
22:54:04 <augur> which in many ways results in the same thing that a (locally) self-recursive lazy definition does
22:54:09 <Kneiva> rohloh: how about those two functions?
22:54:31 <augur> since the purpose of fix is to introduce a var for the function, which is what normal environment based recursion also does
22:56:46 <augur> environments and laziness have their uses, but they also make things super confusing
22:56:56 <augur> well, envs not so much, but combined with laziness
22:57:02 <rohloh> Kneiva: which ones?
22:57:11 <augur> the whole loeb convo the other day was basically just this whole issue
22:57:28 <augur> loeb is just a sort of reified lazy environment
22:57:50 <augur> using haskell's laziness to handle the internal laziness of the environment
22:57:51 <Kneiva> rohloh: takeWhile and dropWhile
22:58:03 <dpwright> I have a silly little function that does some simple string manipulation, and I want to do some simple speed comparisons between implementations
22:58:33 <dpwright> usually, I would just run the function in a loop in each implementation and time the total time it takes to run 10000 times or whatever
22:58:54 <dpwright> I tried simulating that in haskell but I think it's a bit too clever for that...
22:59:14 <rohloh> kneiva, yeah i considered using those but it seems like i can't look at three consecutive elements of the list at once to compute the error
22:59:50 <dpwright> is there a known best practice for doing this sort of thing?
23:00:23 <FreeFull> dpwright: Apply the function to 10000 different strings maybe
23:01:20 <dpwright> FreeFull: I thought it might be something along those lines... righty-ho, thank you!
23:01:30 <rohloh> Kneiva: basically, i want to take while \frac{p_{n} - p_{n-1})^2}{p_{n-1}-p_{n-2}} < epsilon (forgive the latex code :P)
23:01:57 <rohloh> where p_{n} is an element in the list
23:02:07 <dpwright> oh hey, maximum 10000 you say? heh http://www.random.org/strings/
23:02:15 <lpaste> enthropy annotated “pastebin.com/TFimsVwW” with “pastebin.com/TFimsVwW (annotation)” at http://lpaste.net/96181#a96182
23:03:17 <FreeFull> dpwright: There probably is some library along quickcheck's lines, but for benchmarking
23:03:58 <enthropy> @hackage criterion is relatively popular dpwright
23:03:59 <lambdabot> http://hackage.haskell.org/package/criterion is relatively popular dpwright
23:04:13 <Kneiva> rohloh: can't you use pattern matching for that too eg. (x:y:z:xs)?
23:04:39 <rohloh> enthropy: thanks! i also wrote up some code for bisection but I'm to quite sure why it works...
23:05:04 <rohloh> kneiva: I'm sorry, I'm not quite sure how i would do that.
23:05:22 <enthropy> so the pieces kind of compose a bit better if you write them as I did
23:05:33 <enthropy> false position needs 3 points, right?
23:06:21 <rohloh> enthropy: nope just a bracket is needed so two points
23:06:53 <enthropy> what I mean is selecting the 'c'
23:07:10 <enthropy> or maybe I'm just not remembering correctly
23:09:31 <rohloh> enthropy: false position uses a very similar method to newtons method to calculate c and only needs the bracket endpoints to do so
23:10:35 <rohloh> enthropy: sorry, I'm still pretty new to haskell, can you explain lines 14 and 16 of your annotations?
23:11:00 <lpaste> enthropy annotated “pastebin.com/TFimsVwW” with “pastebin.com/TFimsVwW (annotation) (annotation)” at http://lpaste.net/96181#a96183
23:11:06 <lpaste> enthropy annotated “pastebin.com/TFimsVwW” with “pastebin.com/TFimsVwW (annotation) (annotation)” at http://lpaste.net/96181#a5308848124981149696
23:11:40 <enthropy> ok now I get what the false position selecting that new point is
23:11:58 <enthropy> you can save the (f a) or (f b) evaluation
23:12:51 <enthropy> rohloh: (iterate f x) makes a list like   [x, f x, f (f x), ... ]
23:13:53 <rohloh> enthropy: http://www.csupomona.edu/~rsszypowski/mat201_f13/notes.pdf false position starts on page 23
23:14:06 <rohloh> enthropy: oh thats pretty handy
23:14:19 <dpwright> enthropy: Oh hey, missed your message earlier -- thanks!  will take a look
23:14:29 <FreeFull> Is it possible to do better than O(n) search on a sorted list?
23:15:51 <joelteon> log(n)
23:16:25 <bitemyapp> FreeFull: binary search is log n
23:16:35 <bitemyapp> FreeFull: I think log log n is possible under some circumstances.
23:16:46 <augur> hmm. whats the source of iterate? probably something like   iterate f x = x : map f (iterate f x)
23:16:57 <scott_> @src iterate
23:16:57 <lambdabot> iterate f x =  x : iterate f (f x)
23:17:15 <augur> scott_: hmm hmm.
23:17:45 <augur> iterate f x = let xs = x : map f xs in xs
23:18:08 <augur> all these wonderful ways to write things :T
23:18:41 <augur> oh again, tho, im curious how you have a type system that allows recursive lets
23:18:57 <augur> probably not too hard but
23:19:46 <augur> lets see, a usual way of doing let might be ...   G !- M : A   G, x : A !- N : B   ===let===>   G !- let x = M in N : B
23:20:16 <augur> but i think you'd need to do   G, x : A !- M : A   G, x : A !- N : B   ===let===>   G !- let x = M in N : B
23:20:22 <augur> to get recursive lets
23:21:06 <FreeFull> bitemyapp: There is list traversal though
23:21:28 <FreeFull> If you had an array, sure, you can use binary search (or better if you have more information)
23:21:29 <augur> with an evaluation rule   let x = M in N ===let-reduce===>   N[M[let x = M in x/x]/x]
23:21:31 <augur> or something like that
23:22:07 <enthropy> FreeFull: I think you can still talk about log n for [], if you say n is the number of comparisions not pointer dereferences
23:22:13 <augur> obviously env binding is much nicer here. i wonder if there are type theories that use environments for their reduction rules instead of substitution
23:22:38 <augur> probably. you just define an extra parameter for the reduction relation probably
23:22:57 <augur> E !> M ~> N instead of just M ~> N or something
23:23:34 <augur> or maybe even use the mixed typing-and-binding contexts that conor uses
23:23:35 <FreeFull> With arrays sometimes you can get O(1), depending on what you're doing
23:28:11 <muniv> hi, I need make win executable of this: https://github.com/joelteon/flaghack  Anyone? :-)
23:30:01 <simpson> muniv: Wrong channel.
23:30:33 <ellipsis_> can I do something like "newtype Monad m => ParseT m a" ?
23:30:40 <augur> simpson: not too wrong, since joelteon is in here :p
23:31:00 <simpson> augur: It's an Objective C codebase, though. :3
23:31:10 <muniv> sory bad link: win executable of this pls: https://github.com/joelteon/haxparse
23:31:10 <augur> this is indeed truw
23:31:15 <joelteon> well, that's the 4th different username he's used
23:31:21 <joelteon> and i still don't know how to make a win executable
23:31:28 <joelteon> so might be the wrong channel
23:33:10 <muniv> joelteon i am not experienced at programming. U dont know how to repair cars.
23:34:14 <joelteon> ok
23:34:16 <joelteon> how do you know
23:35:27 <rohloh> enthropy: in line 14 of your annotation, in what order is it evaluated?
23:35:43 <muniv> I love haxball, do u? Do you know http://haxball.vherne.cz?
