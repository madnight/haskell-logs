00:10:02 <oio> Any idea Data.ByteString.hGetLine: invalid argument (Bad file descriptor) ?.. can't send and email through a hotmail or gmail account with smtp-mail :(
00:21:38 * hackagebot word24 1.0.5 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.5 (JohnLato)
00:21:38 * hackagebot word24 1.0.6 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.6 (JohnLato)
00:28:36 <lalala_oops> i'm in Mageia and i wanna get haskel
00:29:03 <augur> lalala_oops: mageia?
00:29:29 <lalala_oops> augur:  it's like mandriva
00:29:34 <augur> mandriva?
00:30:30 <bartavelle> a linux distribution
00:30:52 <bartavelle> lalala_oops, http://wiki.mandriva.com/en/Development/Tasks/Packaging/Policies/Haskell
00:31:18 <bartavelle> not sure how this wiki page is helpful, but that's the link from http://www.haskell.org/platform/linux.html
01:39:28 <skypers> @index par
01:39:28 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
01:42:07 <skypers> hey, would you do to define the order of scheduled parallelized threads?
01:45:46 <exicer> Can anyone suggest some articles on error handling in haskell? I'm going to be travelling for most of today, and would like something to read!
01:46:04 <alexander__b> exicer: http://book.realworldhaskell.org/read/error-handling.html
01:46:22 <alexander__b> exicer: unless you meant something more advanced. I'm a newbie myself. :-)
01:46:58 <skypers> @index Par
01:46:58 <lambdabot> bzzt
01:47:19 <bitemyapp> http://notonlyoo.org
01:48:19 <biscarch> What module is `getDataDir` in?
01:48:34 <alexander__b> biscarch: I like how you need to turn off CSS to be able to read anything
01:48:35 <exicer> alexander__b: Heh, I'm still very much a newbie :)
01:49:44 <biscarch> alexander__b: what?
01:50:03 <alexander__b> biscarch: sorry that was for bitemyapp
01:50:13 <biscarch> ah, gotcha
01:52:02 <skypers> 10:34 < biscarch> What module is `getDataDir` in?
01:52:07 <skypers> System.Directory?
01:53:27 <biscarch> skypers: unfortunately I don't see it there
01:53:42 <biscarch> I'm trying to write a snaplet, if that helps anyone
01:55:27 <Feuerbach> biscarch: I can't know for sure which 'getDataDir' you need, but
01:55:37 <Feuerbach> it's one of the functions automatically generated by Cabal
01:55:53 <Feuerbach> it's in the Paths module
01:56:02 <Feuerbach> e.g. Paths_my_package
01:56:16 <biscarch> Feuerbach:  that sounds like the one I'm looking for.
01:56:23 <Feuerbach> look in dist/build/autogen/Paths_*.hs
01:57:16 <biscarch> awesome, I see it there.
01:57:19 <biscarch> Thanks
01:57:56 <skypers> @hoogle getDataDir
01:57:57 <lambdabot> No results found
01:58:02 <skypers> it doesn’t exist
01:58:05 <skypers> you’re screwed
01:58:11 <skypers> fire all people
01:58:14 <skypers> close the firm
01:58:20 <skypers> it sinks
01:58:21 <skypers> :)
01:58:24 <biscarch> haha
02:06:48 <bearclaw> is there a standard way/fun equivalent to     fand f1 f2 = \x -> if f1 x then f2 x else False
02:09:17 <linduxed> bearclaw: "any"?
02:09:33 <linduxed> bearclaw: something like "any [f1, f2]"
02:10:38 <bearclaw> I could use that, it will require tons of 'not'... actually fnot f = \x-> not $ f x
02:10:54 <linduxed> actually
02:10:56 <linduxed> just fold the thing
02:11:02 <linduxed> provide a list of booleans
02:11:12 <linduxed> fold it checking for True
02:11:17 <linduxed> start with false
02:11:22 <linduxed> *False
02:11:45 <larrry> hello. i just installed haskell platform and I want to install some packages. should i do cabal install cabal-install first?
02:12:12 <linduxed> larrry: IIRC, yes
02:12:19 <linduxed> larrry: but not sure though
02:12:48 <bearclaw> lines = filter (fand (fnot TL.null) ((/= '#') . TL.head )) rawLines
02:12:49 <linduxed> larrry: also, you might be interested in the "cab" package, which gives you a nicer install/uninstall/other-stuff interface
02:12:58 <bearclaw> (removing empty lines and comments)
02:13:02 <linduxed> larrry: makes it more like the "gem" command, if you're famliar with ruby
02:13:19 <skypers> 10:52 < bearclaw> is there a standard way/fun equivalent to     fand f1 f2 = \x -> if f1 x then f2 x else False
02:13:19 <larrry> I will take a look thanks
02:13:22 <skypers> yeah, any
02:13:42 <skypers> any $ [f1,f2] <*> pure x
02:14:11 <linduxed> another way would be
02:14:21 <linduxed> any (== True) [f1, f2]
02:14:42 <linduxed> just as with skypers' example, that list could be made longer
02:14:50 <skypers> hm
02:15:01 <skypers> yeah you curified it?
02:15:15 <bearclaw> linduxed: f1 and f2 are unary functions
02:15:25 <linduxed> skypers: considering i don't know what you mean with that word, probably not
02:15:37 <skypers> what’s the type of your expression?
02:16:02 <skypers> :t any (== True) $ [(==3),(<=5)]
02:16:03 <lambdabot>     Couldn't match expected type `Bool' with actual type `a0 -> Bool'
02:16:03 <lambdabot>     In the expression: (== 3)
02:16:03 <lambdabot>     In the second argument of `($)', namely `[(== 3), (<= 5)]'
02:16:19 <skypers> yeah it doesn’t type
02:16:39 <linduxed> well, i assumed the things inside the list were Bool
02:16:40 <skypers> :t any $ [(==0),(==1)] <*> pure 4
02:16:41 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `[Bool]'
02:16:41 <lambdabot>     In the second argument of `($)', namely
02:16:41 <lambdabot>       `[(== 0), (== 1)] <*> pure 4'
02:16:50 <skypers> huh? :)
02:17:16 <skypers> :t any (==True) $ [(==0),(==1)] <*> pure 4
02:17:17 <lambdabot> Bool
02:17:23 <skypers> yeah that’s better
02:17:45 <linduxed> unclear specification, extremities got stuck in the fan
02:17:51 <supki> (== True) is id
02:17:54 <supki> any id is or
02:18:17 <skypers> hm
02:18:33 <skypers> :t or [(==0),(<=10)] <*> pure 3
02:18:34 <lambdabot>     Couldn't match expected type `f0 (a0 -> b0)'
02:18:34 <lambdabot>                 with actual type `Bool'
02:18:34 <lambdabot>     In the return type of a call of `or'
02:18:41 <skypers> :t or $ [(==0),(<=10)] <*> pure 3
02:18:41 <lambdabot> Bool
02:18:43 <skypers> yeah
02:18:45 <skypers> even better :)
02:19:20 <skypers> we may also use it as
02:19:27 <skypers> :t or $ [(==0),(<=10)] <$> ($ 3)
02:19:28 <lambdabot>     Couldn't match expected type `a0 -> Bool'
02:19:28 <lambdabot>                 with actual type `[a1 -> Bool]'
02:19:28 <lambdabot>     In the first argument of `(<$>)', namely `[(== 0), (<= 10)]'
02:19:36 <skypers> yeah I’m stupid
02:19:38 <skypers> :t or $ [(==0),(<=10)] <$$> ($ 3)
02:19:39 <lambdabot>     Not in scope: `<$$>'
02:19:39 <lambdabot>     Perhaps you meant `<$>' (imported from Control.Applicative)
02:20:25 <bearclaw> lines = filter ((fnot TL.null) <&&> ((/= '#') . TL.head )) rawLines      with <&&> being my fand
02:20:33 <supki> :t (Control.Lens.<&>)
02:20:34 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:21:06 <skypers> :t or $ [(==0),(<=10)] <&> ($ 3)
02:21:08 <lambdabot> Bool
02:21:23 <skypers> why is this in Control.Lens?
02:21:27 <skypers> it’s like (&)
02:21:32 <skypers> it should be in Data.Functor
02:21:40 <skypers> and (&) in Data.Function
02:21:42 <larrry> I got ghc 7.6.3 with haskell platform. did I download older version?
02:22:09 <supki> it's like (&) so it's in lens too :)
02:22:52 <skypers> ghc --version
02:22:52 <skypers> The Glorious Glasgow Haskell Compilation System, version 7.6.3
02:23:00 <skypers> larrry: ^
02:25:46 <larrry> so haskell platform is lagging behind?
02:26:06 <skypers> larrry: huh? we got the same ghc version
02:26:20 <skypers> so no, it’s quite okay right now
02:26:57 <larrry> for some reason I thought 7.8 was the latest version
02:27:20 <skypers> oh ?
02:27:21 <skypers> maybe
02:27:22 <skypers> wait
02:28:08 <skypers> extra/ghc 7.6.3-1 [installed]
02:28:09 <larrry> no it is the latest stable versikn
02:28:14 <skypers> yeah I think it’s quite the latest
02:56:50 <lpaste> lasticot pasted “First Example” at http://lpaste.net/7100830621152313344
02:58:28 <lasticot> Hi everyone! I don't understand the difference between: http://lpaste.net/7100830621152313344 and http://lpaste.net/778969671490600960.
02:58:51 <lasticot> When I compile the second I get this error message: http://lpaste.net/6437679252514013184
03:03:23 <supki> lasticot: what's the type of updateGameState?
03:04:00 <supki> lasticot: oh, actually, you forgot to pass iMVar to loop
03:04:27 <lasticot> supki: updateGameState :: SnakeGame -> SnakeInputs -> SnakeGame
03:05:50 <lasticot> supki: thank you
03:09:07 <supki> lasticot: ghc chooses (e ->) monad instance for a do-block if you don't pass a parameter to loop
03:09:18 <supki> so the error is *a bit* confusing
03:09:35 <lasticot> supki: ok
03:13:32 <TheBrayn> is there a function which takes a list and returns the values which match a certain condition but breaks if the condition is no longer met?
03:13:48 <hpc> takeWhile?
03:14:06 <TheBrayn> yeah, thanks
03:18:13 <lasticot> What is the character produced by the escape key?
03:19:59 <tdammers> the escape character maybe ?
03:21:48 * hackagebot MonadCatchIO-transformers 0.3.1.0 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.3.1.0 (AriePeterson)
03:32:24 <grok23> ["fooxyz", "barxyz]
03:34:48 <grok23> I have a list like ["foofizz", "barxyz","barabc","foobuzz"] and I want to pattern match elements that start with "foo" and I want to have the whole element available to me in the body. should func [("foo":xs):xxs] = ... work?
03:35:23 <grok23> remove the square braces
03:39:11 <chridi> grok23: why pattern matching?  why not using filter ?
03:43:33 <lpaste> lasticot revised “Second Example”: “main.hs” at http://lpaste.net/778969671490600960
03:43:36 <lpaste> lasticot pasted “SnakeGame.hs” at http://lpaste.net/95975
03:43:44 <apo> grok23: blah@("foo":_)
03:45:06 <lasticot> I don't understand why the program is not delaying  as I expected to using threadDelay 1000
03:46:18 <supki> lasticot: threadDelay uses microseconds
03:46:38 <lasticot> supki: lol ok ... I'm sry
03:50:58 <grok23> chridi, apo: I did func (('f':'o':'o':xs):xxs) = ... because it's for a homework and at this point I don't care anymore :) we're marked by unit tests anyway
03:51:07 <grok23> chridi, apo: thanks, though
03:51:32 <grok23> the string was much longer than "foo" :)
03:52:14 <larrry> why are documentation, tests and profiling disabled by default in cabal config file?
03:57:02 <supki> larrry: they slow down the builds, for one thing
03:58:29 <larrry> i cant profile without enabling profiling before installing package?
03:59:12 <larrry> which one do you recommend enabling?
04:00:35 <donri> i enable docs, profs and -O2 and suffer insane compile times :)
04:01:03 <donri> i don't recommend enabling tests; lots of packages provide test-suites that don't pass when installing from hackage
04:06:13 <larrry> I just installed a fresh copy of ghc platform and I have errors when I type ghc-pkg check: http://lpaste.net/95977
04:14:09 <tarruda> How do I convert an UTCTime to an integer representing the number of seconds since 1970 ?
04:14:25 <chrisdone> ho, ho, ho!  surely you must be joking, mr tarruda?
04:14:33 <tarruda> no
04:14:47 <tarruda> I cant figure it out
04:15:20 <donri> utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
04:16:31 <chrisdone> @hoogle NominalDiffTime -> Int
04:16:31 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
04:16:31 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
04:16:31 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
04:17:13 <identity> Is there a .. foo f a = if f a then Nothing else Just a
04:17:15 <tarruda> @hoogle POSIXTime -> Integer
04:17:15 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:17:16 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
04:17:16 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
04:17:18 <identity> -ish function?
04:17:29 <chrisdone> :t fromEnum :: Data.Time.NominalDiffTime -> Int
04:17:31 <lambdabot> time-1.4.0.1:Data.Time.Clock.UTC.NominalDiffTime -> Int
04:17:50 <identity> @hoogle (a -> Bool) -> a -> Maybe a
04:17:50 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
04:17:51 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
04:17:51 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
04:17:52 <chrisdone> :t round :: Data.Time.NominalDiffTime -> Int
04:17:53 <lambdabot> time-1.4.0.1:Data.Time.Clock.UTC.NominalDiffTime -> Int
04:18:28 <chrisdone> i'm not sure whether the Data.Time docs are actively unhelpful on this to discourage conversion to seconds or just unintentionally
04:18:45 <identity> chrisdone: whatever the case, they're horrible to work with
04:18:51 <identity> the API feels like a giant mess
04:19:44 <donri> tarruda: it has all the relevant number instances, use those
04:20:43 <chrisdone> the thyme library is more straight forward
04:20:43 <chrisdone> http://hackage.haskell.org/package/thyme-0.3.0.3/docs/Data-Thyme-Clock.html#v:toSeconds
04:20:49 <tarruda> thanks
04:20:50 <kirillt1> Is there modern tool for interoperaion haskell and java? All what I found seems outdated.
04:22:54 <kirillt1> except of java bridge
04:36:53 <Aetherspawn> wowsers.
04:37:06 <Aetherspawn> cabal is 100x better on OSX than on Windows.
04:37:22 <shiona_> how so
04:37:37 <shiona_> other than it's easier to use the command line
04:37:37 <Aetherspawn> on osx it's much less verbose and automatically multithreads builds
04:37:44 <shiona_> ok
04:37:45 <Aetherspawn> cabal 18 on windows doesn't do that for me.
04:38:03 <donri> Aetherspawn: old .cabal/config laying around?
04:38:12 <Aetherspawn> actually, thats a good point
04:38:17 <Aetherspawn> probably still using the one from HP
04:41:01 <Aetherspawn> btw shiona_ I use PowerShell on windows and it feels better than the osx terminal
04:41:22 <Aetherspawn> Not many people realise that powershell goes great w/  mingw
04:53:20 <ocharles> In the documentation for the new Data.ByteString.Builder, it is mentioned that mconcat . intersperse (charUtf8 ',') is slower than the list comprehension (which is basically a map) - why is that?
04:53:38 <ocharles> it's said that an intermediate representation is built, but isn't that then consumed straight away by mconcat?
04:53:51 <ocharles> http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Builder.html for reference
04:56:40 <jmcarthur> ocharles: i suspect that intersperse does not fuse
04:59:14 <jmcarthur_mobile> Oh, I guess that is probably used in both, so I don't know
05:01:45 <TheBrayn> how would you create every combination of a list where position does not matter?
05:02:19 <TheBrayn> so if there is [1, 2] there should not be a [2, 1]
05:07:02 <Tordek> TheBrayn: you need to be more specific. e.g.: dou you mean the powerset of a list? (that is, all the possible subsets of it?), or for a specific size?
05:07:41 <TheBrayn> every pair which you can create from a list
05:08:02 <TheBrayn> like permutations
05:08:19 <TheBrayn> uhm no, wrong
05:08:21 <Tordek> well, do you mean pairs or permutations or combinations? they're all different things
05:08:43 <TheBrayn> combinations
05:08:44 <Tordek> if you mean all the pairs, you want the cartesian product
05:09:18 <TheBrayn> like what [(n, m) | n <- myList, m <- myList] does only without duplicates (order does not matter)
05:13:30 <Tordek> ok, those are pairs; the cartesian product. try this: f l1 l2 : if l1 is empty, return []; if l1 is not empty, take the head of l1, and pair it with all the elements of l2. then append to that f (tail l1) (tail l2)
05:15:28 <gniourf> TheBrayn, would this work for you? [ (m,n) | l<-tails myList, not $ null l, let m=head l, n<-tail l ]
05:17:03 <TheBrayn> what is tails?
05:17:32 <frx> > tails [1..10]
05:17:34 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
05:17:46 <frx> > tails [1..5]
05:17:47 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
05:18:38 <TheBrayn> I don't have that
05:18:48 <gniourf> TheBrayn, import Data.List
05:18:57 <gniourf> or :m Data.List
05:20:25 <TheBrayn> thanks
05:20:38 <TheBrayn> uhm I also need the combination where both elements are the same
05:20:39 <gniourf> :)
05:21:05 <gniourf> with both the same allowed: [ (m,n) | l<-tails myList, not $ null l, let m=head l, n<-l ]
05:21:54 <TheBrayn> wow, I wish I could have come up with that myself
05:21:59 <gniourf> ;)
05:43:38 <christiaanb> Hi, is there anyone here who can add an entry to the upcoming events at Haskell.org? An entry for the dutch functional programming day 2014: http://staff.science.uva.nl/~grelck/nl-fp-day-2014.html
05:53:36 <fryguybob> christiaanb: If you have a wiki account you can edit it here: http://www.haskell.org/haskellwiki/Template:Main/Events
05:54:25 <christiaanb> fryguybob: I don't have one. But I was just about to email nominolo to get one
06:03:48 <linduxed> i guess this one would count as well
06:03:49 <linduxed> http://www.meetup.com/Haskell-Stockholm/events/150842972/
06:03:58 <linduxed> i'm hosting the first stockholm event
06:04:45 <chrisdone> donri: are you going? ^
06:05:22 <Fuuzetsu> I haven't seen a UK Haskell event yet
06:07:02 * hackagebot threepenny-gui 0.4.0.0 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.4.0.0 (HeinrichApfelmus)
06:15:47 <ReinH> gniourf: if the elements are Ord you can get an O(n log n ) solution by normalizing the pairs and sorting
06:18:20 <ReinH> > let sortPair (x,y) | x <= y = (x,y) | otherwise = (y,x) in map head . group . sort . map sortPair $ [(x,y) | x <- [1..5], y <- [1..5]]
06:18:21 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4...
06:19:03 <fizbin> @src reduceM
06:19:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:19:14 <fizbin> @src foldM
06:19:15 <lambdabot> foldM _ a []     = return a
06:19:15 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
06:19:33 <fizbin> @src sequenceM
06:19:34 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:20:02 <donri> chrisdone: what what
06:20:05 <fizbin> I wonder what lambdabot pulls its @src answers from.
06:20:14 <quicksilver> it's a hand collated list
06:20:19 <quicksilver> it's really not very useful.
06:20:39 <quicksilver> I recommend the library source on hackage/library docs if you want to know the source of things
06:21:15 <donri> someone needs to write a source extractor with haskell-suite!
06:21:17 <quicksilver> (although, sequenceM isn't a function I don't think; it's just called sequence, although there is sequence_ and sequenceA)
06:21:39 <chrisdone> donri: the stockholm event
06:21:55 <ReinH> there's isn't a non-monadic sequence so there's no sequenceM
06:22:04 <fizbin> quicksilver: Right, duh.
06:22:10 <shapr> @quote
06:22:10 <lambdabot> HarriKiiskinen says: banging my head against Haskell, but liking the feeling of hurting brains
06:22:21 <donri> maybe sequenceM does two levels of monads!
06:22:25 <chrisdone> @get-shapr
06:22:26 <lambdabot> shapr!!
06:22:34 <shapr> howdy chrisdone! How's code?
06:22:36 <donri> chrisdone: unlikely :) but i should consider it!
06:22:37 <chrisdone> shapr: working on any haskelly?
06:22:39 <fizbin> ReinH: Well, there is sequenceA - I thought that was "sequence"
06:22:41 <shapr> chrisdone: nah, ocaml
06:22:44 <chrisdone> =o
06:22:47 <shapr> chrisdone: and Python
06:22:56 <chrisdone> ocaml sounds fun
06:23:04 <chrisdone> what for?
06:23:05 <ReinH> fizbin: ah
06:23:06 <shapr> but I graduate Dec 14th, so I hope to have time for Haskell then
06:23:12 <chrisdone> \o/
06:23:15 <shapr> chrisdone: phone interview tomorrow with Jane St Capital
06:23:22 <chrisdone> @choose degree haskell
06:23:22 <lambdabot> degree
06:23:28 <shapr> ha, smart
06:23:28 <chrisdone> lambdabot agrees
06:23:37 <chrisdone> ahaa. sweet =)
06:23:44 <shapr> chrisdone: I sort of doubt Jane Street will hire me, but it'll be fun to interview.
06:23:56 <quicksilver> @type sequence . map sequence
06:23:57 <lambdabot> Monad m => [[m a]] -> m [[a]]
06:23:58 <chrisdone> cannae hurt either way
06:24:03 <merijn> shapr: Good luck, after the 3rd interview they decided they weren't interested, but the programming exercises were fairly fun
06:24:07 <shapr> chrisdone: aye
06:24:09 <identity> I don't get why "for" (flip map) isn't just in the prelude
06:24:18 <shapr> merijn: I'll be happy to get even that far :-)
06:24:34 <chrisdone> identity: yeah i use flip map quick a bit. might as well make it flip fma
06:24:36 <dv-> for would be nice
06:24:41 <chrisdone> @let for = flip fmap
06:24:42 <lambdabot>  .L.hs:153:12:
06:24:42 <lambdabot>      No instance for (Functor f0) arising from a use of `fmap'...
06:24:47 <identity> chrisdone: true
06:24:49 <merijn> shapr: The exercise screens were the first thing in the phone screening, I think
06:24:59 <chrisdone> stop restricting my monomorphs
06:25:13 <identity> chrisdone: or maybe just ffor = flip fmap and for = flip map
06:25:19 <identity> in order to not confuse newbies
06:25:24 <identity> etc.
06:25:37 <chrisdone> the man's trying to bring me down, keep me in this monomorphic prison ♫
06:25:38 <ReinH> I rather like <&>
06:25:47 <shapr> merijn: It'll be entertaining in any case.
06:25:49 <edwardk> @tell haasn the issue is that in the future all instances that have a * final argument would have to be of that form. what if that * wasn't the element type?
06:25:49 <lambdabot> Consider it noted.
06:25:49 <cabalprbs> hello! - question about a memory issue with `cabal update`
06:25:54 <chrisdone> ReinH: makes sense
06:26:06 <ReinH> from lens
06:26:09 <chrisdone> although i hate <$>, that operator is consistent
06:26:18 <edwardk> @tell haasn it isnt that it overlaps today, it overlaps with potentially reasonable instances people may want to write
06:26:18 <lambdabot> Consider it noted.
06:26:19 <identity> why do you hate it?
06:26:38 <chrisdone> it's just a subset of my general distate for operators =)
06:26:51 <identity> I love stringing together functors like that
06:26:55 <identity> ah.
06:27:54 <chrisdone> for = clean, readable, sensical by itself, 6 key presses
06:27:54 <chrisdone> <&> = line noise, nonsensical by itself, 6 key presses
06:28:06 <chrisdone> it's so tough to decide which i like more…
06:28:09 <danr> <&> is four key presses :p
06:28:27 <chrisdone> er, i mean for is 3 key presses, but ja
06:28:33 <quicksilver> you're being a bit absolutist there
06:28:40 <quicksilver> for is barely 'sensical' by itself
06:28:55 <quicksilver> unless you have previously used C or java or another such language
06:29:15 <quicksilver> intuition is rarely actually intuitive it's ust what you've learnt in other contexts
06:29:17 <chrisdone> maybe so, but it's at least a word
06:29:24 <donri> danr: shift keys?
06:29:33 <quicksilver> it's pronouncable yes ;)
06:29:38 <chrisdone> quicksilver: i don't think intuition is anything other than what you've seen in other contexts
06:29:56 <larrry> chrisdone: why do you hate <$> ?
06:30:00 <chrisdone> the word comes from the feeling of experiencing something you're familiar with
06:30:06 <edwardk> :t (for)
06:30:07 <lambdabot>     Not in scope: `for'
06:30:07 <lambdabot>     Perhaps you meant one of these:
06:30:07 <lambdabot>       `T.for' (imported from Data.Traversable),
06:30:11 <edwardk> :t T.for
06:30:11 <quicksilver> chrisdone: #include <boring aphorism about the nipple>
06:30:12 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
06:30:18 <edwardk> :t (<&>)
06:30:19 <lambdabot> Functor f => f a -> (a -> b) -> f b
06:30:29 <osfameron> chrisdone: yes, agreed.  I always think that "common sense" is much less common than people imagine
06:30:51 <cabalprbs> hello! - question about a memory issue with `cabal update` (cabal-install v 0.14.0, Cabal Lib v 1.14.0) - runs out of memory
06:30:57 <tdammers> I'd go with "applying existing knowledge without consciously accessing it"
06:30:57 <edwardk> they serve different purposes, or I have to muck around with pure, tc.
06:30:57 <edwardk> er etc.
06:31:43 <identity> what
06:31:50 <identity> @hoogle (<&>)
06:31:50 <lambdabot> No results found
06:31:50 * shapr hugs edwardk 
06:31:51 <identity> ah.
06:32:00 <identity> at any rate, & is very annoying to type on an icelandic keyboard
06:32:06 <identity> it's S-6
06:32:12 <larrry> should i avoid doing cabal update?
06:32:16 <larrry> :/
06:32:18 <identity> larrry: nope.
06:33:02 <chrisdone> identity: it's s-6 on a us/uk keyboard too
06:33:06 <identity> oh.
06:33:12 <chrisdone> oh, it's s-7
06:33:15 <identity> ew.
06:33:19 <haasn> identity: doesn't seem much worse than stock qwerty. It's a single button here (where 7 usually is on QWERTY), which is nice
06:33:43 <identity> one day I'll waste time learning dvorak or something like that
06:33:46 <identity> and all will be well
06:33:48 <edwardk> I use <&> because it puts the big annoying function on the right. for does that too, but it requres it to have an applicative result, and for the thing you're doing it over to be traversable. <&> is for when you don't meet either of those usecases. It is seen as a drop in replacement for (<$>) that puts the lambda on the right where you can usually shed the parens around it that would have been required by (<$>), because  (\x -> Foo
06:33:49 <edwardk>  b x c) <$> baz  = baz <&> \x -> Foo b x c -- shaving a couple of parens, that is all.
06:34:02 <haasn> identity: grow your own layout dynamically, tailored to your usage patterns :)
06:34:10 <identity> haasn: yeah, I was thinking about that as well
06:34:35 <cabalprbs> I've just installed cabal in order to install Control.Parallel for a basic, introductory language tutorial...but I'm having issues already
06:34:48 <haasn> edwardk: I agree, I like having my big annoying lambdas near the end as well
06:34:52 <haasn> especially if you can put them on a newline
06:34:53 <chrisdone> danr: i count holding down a key as being more costly than just tapping a key. so <&> is as costly as 6 key presses, if not more because you strain a finger more than a tap, it's a hold. this is why i made my god-mode for emacs, instead of M-f/M-b i hit gf/gb
06:35:00 <haasn> like foo <&> \x -> <CR> ...
06:35:06 <edwardk> i'm somewhat parenthesis-phobic, so I tend to use (<&>) rather than (<$>).
06:35:12 <identity> cabalprbs: did you not install the haskell platform?
06:35:16 <identity> (which comes with cabal and ghc)
06:36:18 <fizbin> Huh. fmap f . x is a generalization of (f .) . x  ;  This may make some of the things @pl occasionally spits out much more readable.
06:36:20 <edwardk> but i don't think i'll ever convince chrisdone to use it. the nice thing is he doesn't have to ;)
06:36:22 <dcoutts> cabalprbs: what os, and perhaps you can post a log demonstrating the problem. And presumably your system isn't actually a very memory-constrained system?
06:36:30 <danr> chrisdone: oh right, I've even read that blog post of yours
06:36:40 <donri> fizbin: i (ab)use that all the time :)
06:36:42 <edwardk> fizbin: yeah
06:36:51 <donri> better than .: or (f .) IMO
06:37:03 <chrisdone> edwardk: yeah, i'm grateful for the word function names in lens
06:37:16 <donri> and if you think of functions as reader monads it's intuitive even
06:37:16 <edwardk> fizbin: it requires your reader to be familiar with the (->) a functor instance but that isn't too daunting, and its something they should learn anyways
06:37:40 <edwardk> chrisdone: we're looking at splitting out a Control.Lens.Combinators that just has the combinators, not the operators for folks like you who are operator-phobic ;)
06:37:51 <fizbin> edwardk: It may also sometimes make the resulting type more general in useful ways.
06:38:11 <edwardk> so you cn do things like import Control.Lens.Combinators qualified as Lens and import Control.Lens.Operators   or you can just import the combinators, etc.
06:38:25 <chrisdone> ohhh, nice!
06:38:34 <edwardk> chrisdone: that should be in 4.0
06:38:48 <edwardk> chrisdone: i hope that'll go a long way to appease the folks who hate on the operators we use ;)
06:38:49 <haasn> “i'm somewhat parenthesis-phobic” <- no wonder lens has so many operators
06:38:50 <chrisdone> that sounds awesome
06:38:55 <fizbin> :t (.:)
06:38:56 <lambdabot>     Not in scope: `.:'
06:38:56 <lambdabot>     Perhaps you meant one of these:
06:38:56 <lambdabot>       `.' (imported from Data.Function),
06:39:03 <donri> well if you import qualified, the operators kinda stay out of your way anyway
06:39:06 <identity> @hoogle (.:)
06:39:06 <lambdabot> No results found
06:39:18 <donri> although you get more noise in auto-completions and such, i guess
06:39:23 <identity> aeson uses (.:) but I assumed that was something specific to aeson
06:39:33 <chrisdone> haasn: nod, i'm the opposite, i like parentheses
06:39:34 <haasn> edwardk: but are they combinators?
06:39:35 <donri> (.:) = (.).(.)
06:39:40 <fizbin> Has anyone used lens much with FP complete's IDE?
06:39:41 <edwardk> donri: well, there are some folks who want the names to be qualified but only really _use_ the lens operators, so they are okay with those in scope, its almost the opposite problem.
06:39:41 <haasn> chrisdone: lisp background? :)
06:39:46 <chrisdone> haasn: yes =)
06:39:53 <identity> Why on earth would someone shorten the boob operator?
06:39:55 <edwardk> haasn: perhaps not but it is the most useful name i have =P
06:39:56 <identity> >:(
06:40:05 <identity> I think boobs are fine just as is.
06:40:05 <haasn> .Names :P
06:40:21 <donri> edwardk: but i don't see any big reasons to care about that if you don't want operators and do import qualified
06:40:22 <fizbin> I'm curious how their IDE interacts with all of lens's operators.
06:40:22 <simpson> Strange; doing Lisps made me hate parentheses. :3
06:40:27 <cabalprbs> dcoutts: I am now installing haskell-platform, standard libraries sound like a basic reqt, oops :P
06:40:35 <donri> edwardk: i guess the new module will be for people who want open imports but no operators
06:40:45 <donri> users, gotta catch 'em all
06:40:48 <identity> cabalprbs: did you remove the cabal installation you had before?
06:41:00 <chrisdone> edwardk: haasn: yeah i think combinators is generally understood to mean "things that combine things" rather than the stricter higher order function sense
06:41:01 <danilo2> Hello! :) Are there any plans to introduce rankNTypes inference in Haskell? Like described in this Microsoft paper? http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/
06:41:03 <edwardk> donri: it is simply another scenario i care to support. that covers all 3 major usecases and avoids pre-judging how the library will be used
06:41:07 <dcoutts> cabalprbs: doesn't explain cabal update not working, one still often wants to use cabal, and update is a basic requirement to install anything else of hackage.
06:41:23 <fizbin> simpson: Doing lisp made me hate any code that was not autoformatted to something like what emacs does.
06:41:28 <cabalprbs> identity: I have not - should i
06:41:39 <chrisdone> fizbin: interacts in what sense?
06:41:42 <identity> cabalprbs: well, I guess we'll see if it matters
06:41:54 <chrisdone> fizbin: yeah, me too
06:41:55 <edwardk> Names seems like an awkward fit given that most of them aren't nouns, but are rather prepositions, verbs, etc. ;)
06:41:59 <identity> cabalprbs: you might want to fix your path environment variable to only point to the correct(new) cabal
06:42:08 <chrisdone> simpson: what editor did you use when you did lisp? this is important
06:42:11 <fizbin> danilo2: Haskell (or at least GHC) has RankNTypes with the appropriate {# LANGUAGE #} extension.
06:42:20 <cabalprbs> dcoutts: a tutorial/expl i found at hub.darcs.net on cabal mentions that it can't install external dependencies
06:42:20 <simpson> chrisdone: Same editor I always use: vim.
06:42:37 <chrisdone> simpson: okay, Brain ;)
06:42:55 <danilo2> fizbin: I know that, but it does not have type inferencer of rankNTypes (you have to provide them by hand)
06:43:14 <identity> cabalprbs: Hmm? Cabal is basically *for* installing 'external dependencies' (libraries from hackage)
06:43:31 <simpson> chrisdone: I'm really more of a Pinky. Anyway, my MO is vim and a REPL, and that usually works for any language; only Smalltalk and Java have had more productive editors. (Well, "productive.")
06:43:44 <danilo2> fizbin: Haskell implements the Damas-Milner rule that a lambda-bound argument can only have a monomorphic type. The paper I've linked thorws this restriction away
06:43:54 <dcoutts> cabalprbs: it can't install C libs, if that's what i means by "external"
06:43:55 <chrisdone> simpson: yeah, unless you've used paredit in emacs you've not really had the 'lisp' editing experience. people tend to speak very fondly of it afterwards. the parens change from 'getting in your way' to 'giving more information to the editor'
06:43:57 <fizbin> Ah.
06:44:20 <donri> identity: i guess .: is the penis operator. some people prefer penis over boobs.
06:44:23 <simpson> chrisdone: I'm a pianist and I cannot afford to sacrifice my pinky to the emacs keyboard layout. :c
06:44:29 <identity> simpson: Only reason I'm not using vim for java is because eclim is a gigantic clusterf..unctor and there aren't many other alternatives out there
06:44:45 <identity> donri: .:. is more.. penile
06:44:47 <klrr_> emacs got vim bindings i think :P
06:45:03 <identity> But intellij with vim plugin is survivable
06:45:13 <simpson> identity: Every time I write Java, I want to smack myself in the face. Fortunately, I can usually leave that to other people these days. :3
06:45:19 <klrr_> but now when emacs get wysiwyg word processor i might switch to it ;)
06:46:20 <chrisdone> simpson: not saying you should try emacs, just noting that lisp's syntax really has to be judged in its “natural environment”
06:46:35 <identity> simpson: I have only recently starting writing java because I have to(for OOP class). I feel like taking a shower every 10 lines.
06:46:56 <simpson> chrisdone: Yeah, I can imagine that writing at least emcs-flavored Lisp is easier in emacs. OTOH Vimscript isn't any easier to write in vim! :3
06:47:02 <cabalprbs> identity: excuse me, "cannot install non cabal packaged dependencies"
06:47:13 <identity> cabalprbs: well, that much is true
06:47:25 <simpson> identity: Ha, just wait. I work at a Java and C++ shop; it is never-ending.
06:48:01 <fizbin> identity: There are many things that can be done to make java less painful, but at most you'll reduce the need to shower to once/class.
06:49:34 <haasn> We need a book like “Learn Category Theory in 3 Simple Days”
06:49:36 <fizbin> identity: Step 1) get guava. Step 2) get a modern IDE and a beefy enough desktop/laptop to run it on. Step 3) Get more memory for your desktop/laptop because you underestimated it in Step 2.
06:50:13 <identity> ShowerFactory killMe = new ShowerFactory(new ShowerFactoryFactory()); killMe.produce().douse(Showers.ACID);
06:50:19 <identity> fizbin: guava you say?
06:50:23 <fizbin> identity: It won't make it "nice" but will reduce the pain to "manageable".
06:50:30 <identity> ah.
06:50:48 <fizbin> identity: https://code.google.com/p/guava-libraries/
06:50:54 <identity> well, I'm afraid there's little I can do with guava seeing as we'll be implementing ADTs in java and such from the ground up
06:51:08 <identity> A = abstract here
06:51:40 <identity> I don't particularly look forward to it
06:51:53 <fizbin> identity: Fair enough; the advice about a decent IDE (recent Eclipse, recent NetBeans, or IntelliJ) still stands.
06:51:56 <identity> yeah
06:52:05 <chrisdone> simpson: the emacs rocks guy makes funny videos (his enthusiasm and accent is mostly what's funny), here's his video on paredit https://www.youtube.com/watch?v=D6h5dFyyUX0
06:52:05 <identity> using intellij with vim bindings
06:52:17 <identity> which is livable
06:52:21 <fizbin> Don't forget step 3.
06:52:23 <cabalprbs> identity: I'm running debian 7.1 and when I uninstalled cabal-install deb pkg it uninstalled haskell-platform -- I'm thoroughly confused as to how a noobie like me is supposed to do this (get a haskell env with cabal set up)
06:53:04 <quicksilver> fizbin: the great thing abuot step 3 is you can repeat it every 6-12 months as well
06:53:20 <haasn> identity: I know your pain, I use https://github.com/thejh/pretty-java for university assignments
06:53:31 <haasn> keeps the pain a bit manageable by at least removing the ()(}; line noise
06:54:01 <bartavelle> isn't there something better than guava ? developers here use it, but the API is frankly terrible
06:54:07 <bartavelle> or I missed something ...
06:54:20 <identity> cabalprbs: Well, that sucks. But as long as you're sure there is no other cabal install on your system, you can most definitely just go ahead and install the haskell platform again
06:54:21 <bartavelle> (for collections)
06:54:22 <fizbin> identity: Or, I suppose, you could reduce the pain of coding in Java with "Guava 13": https://www.google.com/search?q=guava+13&tbm=isch
06:55:08 <identity> haasn: oh wow.
06:55:12 <identity> haasn: is that reliable?
06:55:18 <razieliyo> hi haskellers
06:55:19 <identity> (re. regex and stuff)
06:55:46 <identity> fizbin: yeah, I wish.
06:55:56 <haasn> identity: no. It's a dirty mess of regex full of bugs and unhandled conditions; and it uses hacks like consulting the system-wide HTML documentation to extract type signatures etc.
06:56:31 <identity> fizbin: I'm just going to bite the bullet and hope to live through it, and then leave that chapter behind me
06:56:31 <haasn> but for small assignments it's not like it matters :P
06:56:44 <identity> perhaps request financial aid for psychological aid
06:57:00 <haasn> identity: The output is pretty amusing too, https://github.com/thejh/pretty-java/blob/master/java/thejh/prettyJava/PrettyJava.java#L13
06:57:09 <haasn> (scroll to the right)
06:58:20 <identity> haasn: oh, hah
06:58:21 <k00mi> haasn: haha, that's genius, I wonder what my tutor is gonna say when I submit my assignments like that :P
06:58:27 <identity> I wasn't sure what I was looking for
06:58:41 <haasn> k00mi: haha, I don't have the guts. You can reformat it using eclipse from the command line, though
06:59:27 <fizbin> identity: If it were for more than a university course, (after all, bills must get paid) the book "Effective Java" is also rather good at explaining how good Java code should do things, and good code in any language is better than bad code in that language.
06:59:31 <k00mi> my assignments are usually corrected automagically, so maybe I'll be fine
06:59:48 <identity> fizbin: true.
06:59:59 <brandon`> where can I find all the differences between ghc 7.6.3 and 7.4.2 ?
07:00:16 <identity> My programming teacher wants us to hand in code as a pdf.. I'm pretty sure none of it is ever compiled
07:00:17 <brandon`> this shows just the difference between 7.6.3 and 7.6.2 http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/release-7-6-3.html
07:00:18 <bartavelle> Brandon`: they should be in the release notes
07:00:27 <bartavelle> you have to do it incrementally
07:00:34 <brandon`> :(
07:00:37 <identity> compiled/run etc
07:00:52 <cabalprbs> dcoutts: identity: cabal update still failing on a (?last) 1mb memory request
07:01:18 <identity> cabalprbs: as dcoutts asked: you're presumably not using a super memory-constrained system?
07:01:25 <bartavelle> identity, also I agree that intellij + vim bindings is *much* more usable than eclipse
07:01:33 <fizbin> identity: As a pdf, wtf?
07:01:34 <TheBrayn> http://www.haskell.org/haskellwiki/Euler_problems/21_to_30#Problem_23 is this an extremely bad solution? I copied this totient function: http://foobook.org/jwodder/scraps/primes-factorization-and-eulers-totient-function/ replaced it and it has been running for 1 minute and still no result
07:01:41 <identity> fizbin: yup. in the appendix.
07:01:44 <TheBrayn> a python script does it in like 4 seconds
07:02:02 <fizbin> identity: Ah, so as an appendix to a written report, basically.
07:02:08 * hackagebot protobuf 0.1.2 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.1.2 (NathanHowell)
07:02:10 <identity> fizbin: yep, but submitted digitally
07:02:21 <dcoutts> brandon`: look at the notes for 7.6.1, that gives the differences vs 7.4.x
07:02:35 <dcoutts> brandon`: ie the first 7.6 release
07:02:38 <fizbin> Okay. I guess I had a class like that, though we submitted on paper (because that was ~15 years ago)
07:03:42 <identity> fizbin: I see. Well, my point is that 1. that makes it very impractical to test code(I originally zipped my report + code but then the system would only take pdf) 2. when I got my first python assignment back, he had written a single comment on the front page
07:03:56 <identity> so I don't think he gives a flying functor
07:04:16 <identity> just looks through it for obvious semantic errors or something
07:04:23 <identity> it's a pass/nopass basis
07:04:23 <cabalprbs> identity: apparently it is constrained - within a second of it failing it was using only 200MB and the second before that (whenever htop checked) it was at half that
07:04:34 <fizbin> Though I still wound up writing the report part in TeX, and every project had a makefile that would rebuild the .ps final report, running latex as necessary, rebuilding the graphs (using gnuplot), running the code through enscript, etc.
07:04:46 <cabalprbs> identity: there are 8GB of ram available
07:04:58 <identity> cabalprbs: ah, that is strange
07:05:03 <identity> cabalprbs: what is the output of cabal --version ?
07:05:53 <fizbin> identity: Well, my father teaches CS at a local community college and there are a sad number of his students who are not be able to turn in code that passes even the most cursory visual inspection before he even attempts to compile it.
07:05:58 <cabalprbs> identity: mem: total:7.8 used:7.5 free:341M ... cached:5.5G
07:06:31 <cabalprbs> cabal-install v 0.14.0, Cabal Lib v 1.14.0
07:06:37 <cabalprbs> identity: cabal-install v 0.14.0, Cabal Lib v 1.14.0
07:07:21 <identity> cabalprbs: yeah. That's what I suspected. are you running windows?
07:07:25 <identity> or some *nix based system?
07:07:55 <cabalprbs> identity: wheezy
07:07:56 <fizbin> identity: I think cabalprbs said he was on Debian or Ubuntu.
07:08:06 <fizbin> Which is Debian.
07:08:32 <identity> oh, yeah
07:09:07 <identity> oh, wait. wheezy's repo is ridiculously outdated, isn't it?
07:09:12 <identity> what version of the haskell platform is that?
07:09:26 <chridi> is there any function to check if a list has a prefix?
07:09:43 <identity> :t isPrefixOf
07:09:44 <lambdabot> Eq a => [a] -> [a] -> Bool
07:09:48 <chridi> ah.. thanks
07:10:35 <identity> cabalprbs: I'm not sure why you're running out of memory, but you may want to consider building the haskell platform
07:10:57 <identity> Though it might be problematic if all the builddeps for it are out of date in the repo as well
07:11:09 <identity> but building it on ubuntu >= 12.04 is trivial.
07:13:08 <brandon`> chridi it is fun to try to search for a function name by using hoogle on a signature.. you will be surprised how often it works.. http://www.haskell.org/hoogle/?hoogle=[a]%20-%3E%20[a]%20-%3E%20Bool
07:13:20 <cabalprbs> identity: i have it built and installed
07:13:41 <identity> cabalprbs: built as in built from scratch, or built as in installed from the wheezy repos?
07:14:14 <cabalprbs> repos...
07:14:50 <cabalprbs> I'm going to go visit #debian-haskell on debian's irc net
07:15:08 <identity> cabalprbs: Yeah, hm. The problem is that the haskell platform in their repos is pretty old, though cabal should still work regardless
07:15:24 <identity> cabalprbs: you could do that, yes.
07:16:00 <cabalprbs> identity: its empty
07:16:42 <larrry> how do you know signature if you dont know function
07:17:09 * hackagebot AesonBson 0.2.1 - Mapping between Aeson's JSON and Bson objects.  http://hackage.haskell.org/package/AesonBson-0.2.1 (NiklasHambuechen)
07:17:33 <chridi> :)
07:18:50 <SLi> A quick check that I understand things correctly. Does head . reverse take O(1) or O(n) space?
07:18:59 <skypers_> :t encode
07:19:00 <lambdabot> Not in scope: `encode'
07:19:05 <skypers_> damn
07:19:21 <skypers_> how would you do to convert a String into its binary representation ?
07:19:24 <skypers_> encode "Hi"
07:19:24 <skypers_> ?
07:19:42 <merijn> skypers_: Use Text and it's encoding functions
07:19:45 <brandon`> you can guess it most of the time larry. isPrefixOf above had was easy to guess
07:19:54 <merijn> @hoogle encodeUtf8With
07:19:54 <lambdabot> No results found
07:19:59 <brandon`> s/had//
07:19:59 <merijn> wut
07:20:12 <merijn> oh, that's decode, duh
07:20:16 <Sagi> can someone gives me some hints on how to 'debug' syntax errors in multiline let expressions?
07:20:21 <merijn> @hoogle encodeUtf8
07:20:21 <lambdabot> Data.Text.Lazy.Encoding encodeUtf8 :: Text -> ByteString
07:20:21 <lambdabot> Data.Text.Encoding encodeUtf8 :: Text -> ByteString
07:20:30 <donri> SLi: that's like, O(n+1). "last" might be O(n)
07:20:35 <Sagi> I suspect something involving indentation, but I don't see what's wrong.
07:20:37 <quicksilver> SLi: O(n) space
07:20:44 <merijn> Sagi: lpaste the code?
07:20:49 <merijn> Sagi: Are you using tabs?
07:20:52 <quicksilver> donri: "O(n+1)" ?
07:21:02 <donri> well, head is an operation isn't it :)
07:21:04 <cswords> lHow do I run an effect handler?
07:21:12 <cswords> Is there documentation I can read somewhere?
07:21:16 <Sagi> merijn: yes I am. Is that ill-advised?
07:21:21 <merijn> donri: O notation is classes of functions n+1 is O(n)!
07:21:24 <quicksilver> donri: head is an operation but that is not asymptotically relevant
07:21:33 <merijn> Sagi: Yes, tabs align to the next 8 space tabstop
07:21:44 <Sagi> oh, annoying
07:21:46 <quicksilver> and head doesn't allocate anyway
07:22:00 <Sagi> that's my problem then, I have it set to 8 for a more compact view.
07:22:01 <quicksilver> (sli was asking about space usage)
07:22:14 <donri> oh i missed the space part
07:22:19 <Sagi> so I should probably convert everything to spaces? Or is there a smarter solution?
07:22:23 <merijn> Sagi: In general it's advised to just use spaces
07:22:39 <merijn> Sagi: Well, if you have a decent editor, they should have stuff built-in for that
07:22:47 <donri> so last is O(1) space? because unlike reverse it doesn't allocate a new list?
07:23:01 <tv1> anyone here use leksah?  Is it ok for a beginner to use to learn haskell?
07:23:06 <Sagi> I use vim, so it'll be okay. I'm just used to using spaces, so everyone can decide for him/herself how stuff is 'spaced'.
07:23:08 <brandon`> no it is O(n)
07:23:14 <merijn> Sagi: oh, then it's easy
07:23:15 <Sagi> err
07:23:19 <Sagi> used to using tabes
07:23:21 <Sagi> tabs
07:23:27 <Sagi> yeah, it's just expandtab, rigth?
07:23:30 <tdammers> Sagi: I'm a tab person myself, but for Haskell and Python, I use spaces
07:23:35 <brandon`> oh space, sorry
07:23:36 <quicksilver> donri: yes, last should be O(1) space
07:23:47 <tdammers> :set expandtab in your ftplugin/haskell.vim, yeah
07:23:47 <merijn> Sagi: See here the proper vim config for using spaces: https://github.com/merijn/dotfiles/blob/master/vimrc#L36-L43
07:23:58 <brandon`> yes O(1) space
07:25:11 <SLi> Yeah, thanks :)
07:26:00 <Sagi> merijn, tdammers: thanks
07:26:29 <tdammers> heh, kind of confusing to have two discussions about "space"/"spaces" at the same time
07:26:42 * tdammers wonders if there is such a thing as a tab leak
07:27:02 <donri> -fwarn-tabs detects tab leaks for you
07:28:11 <MrGwen> Hi, today I've done my first haskell pgm (with ghcjs) but I've an error : "uncaught exception in Haskell thread: TypeError: s is null" https://gist.github.com/anonymous/7580996 any idea ?
07:30:44 <ij> Could this be made sorter? "getArgs >>= mapM_ (putStrLn . reverse)"
07:31:17 <identity> ij: probably not no.
07:31:28 <ij> Okay then!
07:31:55 <identity> well, fmap (putStrLn . reverse) getArgs
07:31:59 <identity> but that won't typecheck with main :: IO ()
07:32:09 <identity> or even putStrLn . reverse <$> getArgs
07:32:29 <identity> @ ij
07:33:06 <donri> is that the same thing though
07:33:12 <identity> isn't it?
07:33:13 <identity> wait
07:33:15 <donri> on reverses the arglist, one reverses each arg?
07:33:20 <ij> :t fmap (putStrLn . reverse) getArgs
07:33:20 <lambdabot> Not in scope: `getArgs'
07:33:24 <ij> :/
07:33:31 <ij> :t fmap (putStrLn . reverse) []
07:33:32 <lambdabot> [IO ()]
07:33:36 <ij> hmm
07:33:50 <donri> :t fmap (putStrLn . reverse) (return [])
07:33:51 <lambdabot> (Monad f, Functor f) => f (IO ())
07:34:17 <merijn> ij: I don't think it can be shorter, I might use =<< instead of >>=, though
07:34:31 <ij> hmm, true that
07:34:35 <merijn> ij: i.e. "mapM_ (putStrLn . reverse) =<< getArgs"
07:34:36 <identity> donri: it's the same, isn't it?
07:34:41 <merijn> Looks more like function application
07:34:47 <identity> you're fmapping into IO here
07:34:48 <identity> not the list
07:35:06 <merijn> identity: You're missing the mapM_, though
07:35:13 <ij> merijn, I'm used to these train calls, so I'm not too troubled about that. :)
07:35:16 <merijn> identity: >>= deals with the IO, mapM maps over the list
07:35:27 <donri> > mapM_ (Identity . reverse) =<< return [a,b,c]
07:35:28 <lambdabot>   Couldn't match expected type `[a0]'
07:35:28 <lambdabot>              with actual type `Debug.Si...
07:35:32 <identity> merijn: ah yes
07:35:33 <identity> silly me
07:36:19 <danr> "mapM_(putStrLn.reverse)=<<getArgs", perhaps? :)
07:36:24 <donri> > mapM_ (Identity . reverse) =<< return ["foo","bar"]
07:36:27 <lambdabot>   Identity {runIdentity = ()}
07:36:31 <donri> lol
07:36:34 <donri> > mapM (Identity . reverse) =<< return ["foo","bar"]
07:36:36 <lambdabot>   Identity {runIdentity = ["oof","rab"]}
07:36:39 <dv-> you can drop the _ in mapM_ too
07:36:51 <donri> > fmap (Identity . reverse) (return ["foo","bar"])
07:36:52 <lambdabot>   No instance for (GHC.Show.Show
07:36:52 <lambdabot>                     (f0 (Data.Functor.Identi...
07:37:05 <donri> > runIdentity $ fmap (Identity . reverse) (return ["foo","bar"])
07:37:09 <lambdabot>   Identity {runIdentity = ["bar","foo"]}
07:37:37 <donri> so 1) you'll need "join" to run the IO actions and 2) you're reversing different things :)
07:37:51 <brandon`> does main's return type make any difference?
07:38:17 <identity> don't think stuff compiles if main isn't :: IO ()
07:38:23 <identity> i don't remember though
07:38:34 <donri> main can have any type that unifies with IO a
07:38:42 <donri> runghc will even show the returned value :p
07:39:12 <donri> (if it is Show, of course)
07:39:29 <brandon`> any if it isnt?
07:39:44 <ij> <$> == fmap?
07:39:58 <WraithM_> ij: Yes.
07:40:05 <ij> Should fmap be able to return "m ()"?
07:40:23 <ij> it should
07:40:54 <donri> :t fmap (const ())
07:40:55 <lambdabot> Functor f => f a -> f ()
07:42:51 <donri> but if you fmap something like putStrLn it's gonna be a nested monad that you need to "join"
07:42:57 <donri> :t fmap putStrLn getLine
07:42:58 <lambdabot> IO (IO ())
07:43:01 <donri> :t join
07:43:02 <lambdabot> Monad m => m (m a) -> m a
07:43:09 <donri> :t join (fmap putStrLn getLine)
07:43:10 <lambdabot> IO ()
07:43:28 <ij> If I write "main arg = ", then what is arg?
07:43:31 <donri> :t putStrLn =<< getLine
07:43:32 <lambdabot> IO ()
07:43:42 <donri> (that's what "bind" is: fmap plus join)
07:43:51 <donri> ij: type error :)
07:43:53 <merijn> ij: That's a type error
07:43:59 <merijn> ij: main must be "IO a"
07:44:10 <merijn> An argument would make it "a -> IO b"
07:44:17 <ij> I see, so args come only from getArgs?
07:44:22 <donri> main isn't actually a function in haskell
07:44:25 <donri> yes
07:44:41 <ij> It was hard to parse the compiler error.
07:44:52 <larrry> what is main?
07:45:31 <merijn> larrry: An IO action
07:46:08 <donri> larrry: main:Main.main is the main entry point of an executable haskell program
07:55:08 <hvesalai> Hi! Are there any javascript haskel interpreters?
07:55:19 <hvesalai> javascript-based that is
07:55:28 <scriptor> there are haskell to javascript compilers
07:55:28 <hvesalai> so I could run haskel in a browser
07:55:56 <hvesalai> are those compilers written in javascript?
07:56:03 <scriptor> don't think so
07:56:50 <jrmithdobbs> is there an existing implementation of a mutable map that's file backed and mmap'ed? a specialized intmap using 256bit keys eg (hence, mmap'ed/etc, cannot reside in ram)
07:57:27 <levi> donri: I'm not sure it's correct to say main is not a function. I'd say it's a function returning an IO action, but its unique property is that its *caller* is not a function.
07:58:39 <donri> haskell doesn't have 0-ary function
07:59:22 <tomejaguar> What's a 0-ary function?
08:00:07 <fizbin> donri: You could either say that haskell doesn't have 0-ary functions, or that haskell, through laziness, eliminates the difference that strict-evaluation languages have between a value and a 0-ary function.
08:00:11 <lingxiao> hey all, is there a synonym for function : `foldr (:) []`
08:00:26 <tomejaguar> lingxiao: Isn't that id?
08:00:27 <danr> id?
08:00:29 <donri> fizbin: no, because there's no such thing in haskell
08:00:33 <lingxiao> wait nv, yeah haha
08:00:39 <lingxiao> thanks tomejaguar
08:00:54 <tomejaguar> You're welcome.  I only copied danr from the future anyway :)
08:01:06 <donri> sorry i'm coming off hostile here, not intended
08:01:09 <danr> tomejaguar: haha well done
08:01:27 <lingxiao> haha
08:01:48 <jrmithdobbs> donri: conceptually argv stands in for main, no? it's an IO array from a non-function caller returning to nowhere but ... that's just an impl detail
08:02:08 <donri> what?
08:02:16 <donri> main /= getArgs
08:02:21 <fizbin> donri: See, I would say that haskell only has functions, and those that take no arguments are conventionally called "values".
08:02:39 <simpson> fizbin: But then who was CAF? It is a mystery~
08:02:43 <donri> fizbin: yes, this has been debated to death in here :) but no, it doesn't make any sense at all
08:02:54 <donri> fizbin: conceptually everything is a list, some things are just singleton lists
08:03:31 <donri> (...isn't true either, but just as sensible)
08:03:37 <triliyn> fizbin: I think in standard terminology, a function is a value whose type contains ->
08:04:38 <fizbin> Fair enough, but then a n-ary function is a value whose type contains (at the top level) n instances of ->
08:04:52 <fizbin> So a 0-ary function would clearly be...
08:04:57 <donri> yes, haskell only has unary functions
08:05:15 <mr-> Oh, I love that discussion!
08:05:24 <mr-> and almost missed it..
08:05:53 <tomejaguar> What's a unary function?
08:06:05 <alexander__b> id?
08:06:10 <quicksilver> everything is a funciton in the same sense that everything is an IO action and everything is a number and everything is a bytestring and everything is a pointer and everything is a lobster
08:06:19 <quicksilver> which is to say, not a very useful sense.
08:06:29 <donri> fizbin: but there's a difference here. thinking monadically, you can "join" a nested type up until it's nolonger nested, but you can't actually change the type
08:06:31 <fizbin> A value whose type matches A -> B where "B" does not contain any ->
08:06:45 <quicksilver> http://conal.net/blog/posts/everything-is-a-function-in-haskell
08:06:56 <fizbin> (In reply to "what is a unary funciton)
08:07:02 <donri> > join ['a']  -- type error
08:07:05 <lambdabot>   Couldn't match expected type `[a0]'
08:07:05 <lambdabot>              with actual type `GHC.Type...
08:07:15 <Peaker> quicksilver: if (a -> b -> c) can be viewed as a 2-arg function under some view, then  "a" can be viewed as a 0-arg function under that same view.  It's useful for example to see that "pure" is "liftA0" in the "liftAn" functions, for example
08:07:15 <alexander__b> I've always viewed abs, cos, sin, tan, etc as unary functions
08:07:31 <donri> alexander__b: they are
08:07:45 <mr-> quicksilver: there are no lobsters in that article :-/
08:08:43 <donri> a list of lists is still a list, just like a binary function is still a function
08:09:03 <donri> that doesn't mean there are things like lists without a list or nullary functions
08:09:20 <jrmithdobbs> donri: i was saying that conceptually main is really :: IO [String] -> IO (); with a special interface to it's args (getArgs) basically as an ffi between the caller (os) and haskell runtime, the fact that it's not just implemented as IO [String] -> IO () and requires getArgs is an impl detail/design decision
08:09:26 <jrmithdobbs> so it's not as special as it appears anyways
08:09:31 <alexander__b> quicksilver: that was an interesting read
08:09:34 <donri> jrmithdobbs: that's not the case though
08:09:42 <quicksilver> alexander__b: you read it quite fast :)
08:09:50 <alexander__b> quicksilver: I read quite fast
08:09:55 <donri> jrmithdobbs: that's a special case of C programs that has nothing to do with haskell
08:10:29 <alexander__b> quicksilver: I would say "it makes things more elegant" rather than "it makes things simpler" though
08:10:31 <jrmithdobbs> donri: I'm not sure I understand the distinnction you're making?
08:10:39 <alexander__b> quicksilver: i.e. as the reason I thought so
08:11:15 <donri> jrmithdobbs: there's nothing special about getArgs. what about getEnvironment? readFile? any IO action ever invented?
08:11:24 <tomejaguar> I'm confused under what definition of function we are working.
08:12:29 <fizbin> tomejaguar: That's deliberate. This discussion is about definitions.
08:12:48 <fizbin> If you go and just *define* stuff, it goes away.
08:13:47 <fizbin> So you can either say "there is no such thing as 0-ary functions", or you can say "there is such a thing as a 0-ary function, but not such a thing as a (-1)-ary function"
08:14:09 <simpson> Wat.
08:14:26 <jrmithdobbs> donri: so you're saying that the fact that in the c runtime and derivs the values returned by getArgs being treated as args to an initial function *doesn't* imply that, at least conceptually, main() in any runtime environment is inherently a function?
08:14:28 <fizbin> Tell me, what do you get when you pass an argument to a n-ary function?
08:15:10 <donri> jrmithdobbs: main() is a function, but that's not haskell
08:15:19 <jrmithdobbs> donri: with basic type IO [String] -> String
08:15:28 <levi> jrmithdobbs: If programs were always pure functions of the command line arguments, i.e. [String] -> (), then there'd be no need for IO. But since the runtime environment is so much more than the command line params, there's no particular reason to privilege them by pretending they're the arguments to the Haskell main function.
08:15:30 <jrmithdobbs> err IO [String] -> IO ()
08:16:05 <fizbin> Under the view "values are 0-ary functions", when you pass an argument to an n-ary function, you get a (n-1)-ary function. Since there is no such thing as a (-1)-ary function, passing an argument to a 0-ary function is an error.
08:16:30 <benzrf> hive-mind:
08:16:31 <benzrf> *hi
08:16:58 <benzrf> oh wait never mind
08:17:16 <donri> fizbin: that's an interesting thought: if values are 0-ary functions, that means functions are fix (+1)-ary functions
08:17:23 <donri> ie. infinity
08:17:23 <fizbin> Under the view "functions all have arity >= 1. Values are values, not functions", then when you pass an argument to a n-ary function you get a (n-1)-ary function if n > 1, and a value otherwise.
08:18:01 <donri> well values are values but functions are also values :)
08:18:24 <donri> a list is a value but not every value is a list
08:18:26 <triliyn> fizbin: there's also "There are values and function. Passing a value of type a to a function of type a -> b gives you a value of type b."
08:18:39 <benzrf> why isn't there a builtin rotate function?
08:18:48 <benzrf> i.e. [1, 2, 3] -> [3, 1, 2]
08:18:48 <donri> what's rotate do
08:19:13 <benzrf> last l:tail l
08:19:37 <haasn> benzrf: don't you mean last l:init l -- ?
08:19:39 <fizbin> triliyn: So that's the view where there is no concept of arity per se, merely a boolean measure of "is this a function type"
08:19:49 <benzrf> oh right
08:19:49 <haasn> probably because deconsing lists like that is really slow
08:19:49 <benzrf> derp
08:19:56 <benzrf> then how should I rotate?
08:20:06 <donri> > (:) <$> last <*> tail $ [1,2,3]
08:20:07 <lambdabot>   [3,2,3]
08:20:17 <benzrf> that is not correct
08:20:21 <saml> > reverse [1,2,3]
08:20:22 <lambdabot>   [3,2,1]
08:20:25 <donri> > (:) <$> last <*> init $ [1,2,3]
08:20:26 <triliyn> > (:) <$> last <*> init $ [1,2,3]
08:20:26 <lambdabot>   [3,1,2]
08:20:27 <lambdabot>   [3,1,2]
08:20:39 <Cale> benzrf: If you really need to rotate, you can implement it with last and init, but it's inherently not a very nice thing to do to a list.
08:20:40 <benzrf> w/ever, i'm not using any large lists
08:20:42 <haasn> > liftA2 (:) last init [1,2,3] -- ugh, applicative notation
08:20:44 <lambdabot>   [3,1,2]
08:20:44 <benzrf> i'll just use last and init
08:20:46 <benzrf> Cale: I know :(
08:20:50 <saml> oh rotate
08:20:56 <saml> > rotate [1,2,3]
08:20:57 <lambdabot>   No instance for (Data.Bits.Bits [t0])
08:20:57 <lambdabot>    arising from a use of `e_1123'
08:20:57 <lambdabot>  Po...
08:21:28 <saml> you might want circular linked list
08:21:32 <donri> haasn: canhas idiom brackets? (| last:init |)
08:21:34 <saml> or two lists
08:22:07 <saml> [1,2,3] [],  [2,3] [1],  [3] [2,1], [] [3,2,1]
08:22:08 <haasn> or maybe a Data.Sequence
08:22:14 <haasn> Data.Sequence.Seq
08:22:14 * hackagebot extensible-effects 1.0 -   http://hackage.haskell.org/package/extensible-effects-1.0 (BenFoppa)
08:22:15 <triliyn> How do idiom brackets work? Do they only transform the outermost operator/function within them?
08:22:16 <saml> wait that's not rotate
08:22:16 <levi> or a Forth interpreter
08:23:26 <donri> triliyn: i imagine it translates first to (:) last init, then to pure (:) <*> last <*> init, but not deeper than so (nest brackets for that, i guess)
08:23:29 <saml> @google purely functional circular list
08:23:30 <lambdabot> http://stackoverflow.com/questions/2222963/
08:23:31 <lambdabot> Title: functional programming - O(1) circular buffer in haskell? - Stack Overflow
08:23:42 <triliyn> donri: hmm, okay
08:23:49 <Cale> triliyn: (| f a1 a2 ... an |) ---> pure f <*> a1 <*> a2 <*> ... <*> an
08:24:02 <donri> SHE has lots of weird special syntax though
08:25:29 <donri> i want idiom tuples, not sure she does that?
08:26:00 <Cale> I wouldn't be surprised if it magically worked
08:26:01 <donri> (| a,b,c |) => liftA3 (,,) a b c
08:26:06 <Cale> not like that though
08:26:17 <benzrf> is there a func that counts occurrences of an item in a list
08:26:28 <Cale> (| (a,b,c) |) --> pure (,,) <*> a <*> b <*> c
08:26:30 <donri> well (| (,,) a b c |) probably works, sure
08:26:32 <donri> oh
08:26:37 <Cale> (possibly)
08:26:43 <Peaker> the word "idiom" seems like a really weird name for "Applicative".  It's so generic
08:26:52 <donri> well it's idiomatic!
08:26:55 <benzrf> hello?
08:26:57 <benzrf> :|
08:27:00 <Cale> benzrf: length . filter (== x)
08:27:04 <benzrf> derp
08:27:07 <saml> > let rotate _ [] = []; rotate n l = zipWith const (drop n (cycle l)) l in rotate 1 [1,2,3]
08:27:08 <lambdabot>   [2,3,1]
08:27:44 <Chris__> Hi all, can anyone give me a hand using conduits please?
08:27:49 <saml> sure
08:28:12 <Cale> benzrf: Or depending on what you're doing, something like  map (\x -> (head x, length x)) . group . sort  can be pretty effective.
08:28:24 <Chris__> I'm trying to use zip-conduit, and need to source lines of files out of a zip archive.
08:28:35 <Cale> (it's also possible to write that lambda as (head &&& length) if you import Control.Arrow)
08:29:46 <Chris__> (i.e., the zip file contains a file, and I basically want to do the equivalent of lines $ readFile aFile
08:30:39 <donri> :t liftA2 (,) head length
08:30:41 <lambdabot> [a] -> (a, Int)
08:32:23 <Hodapp> https://en.wikipedia.org/wiki/Surreal_number my brain hurts.
08:35:50 <shergill> mm conway. onag was a nice read
08:37:17 <klrr_> :t liftA2 . liftA2
08:37:18 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
08:39:36 <Hodapp> shergill: onag?
08:39:46 <Hodapp> oh, On Numbers and Games?
08:40:50 <w0rm_x> Any known tool for evaluation traces?
08:46:59 <Redz> i try to read a file in strict way, so i wrote:
08:46:59 <Redz>   withFile p ReadMode $ hGetContents
08:46:59 <Redz> but this seems not to work. why?
08:50:50 <Feuerbach> because it's not strict
08:51:09 <donri> Redz: hGetContents uses lazy IO so it returns immediately
08:51:13 <Feuerbach> Google gives pretty good results for "haskell strict read file", have you tried that?
08:51:19 <donri> Redz: withFile then closes it
08:51:21 <lpaste> Redz pasted “read a file strict. doesn't work. ” at http://lpaste.net/95978
08:52:31 <chrisdone> Redz: use the strict package
08:52:39 <chrisdone> http://hackage.haskell.org/package/strict-0.3.2/docs/System-IO-Strict.html
08:53:59 <Redz> i've written a strict readfile with hGetLine, but i looked for something easier. i was just wonder, why this not work.
08:55:37 <chrisdone> Redz: hGetContents doesn't read the list of bytes in strictly, it reads them lazily
08:57:04 <chrisdone> Redz: http://hackage.haskell.org/package/base-4.3.1.0/docs/src/GHC-IO-Handle-Text.html#hGetContents
08:57:58 <chrisdone> i wonder if haddock could generate .texi files
08:58:03 <Redz> i thought, hClose force reading. well then.
08:59:22 <Redz> thanks. i will use the strict package. :)
08:59:32 <razieliyo> :t (\x -> x + 1)
08:59:33 <oio> how to acces a hidden folder on windows?
08:59:34 <lambdabot> Num a => a -> a
09:00:03 <oio> or create a hidden folder in windows?
09:00:11 <razieliyo> :t (\x -> x >>= putStrLn)
09:00:12 <lambdabot> IO String -> IO ()
09:00:34 <razieliyo> :t putStrLn
09:00:35 <lambdabot> String -> IO ()
09:01:00 <Feuerbach> chrisdone: I've got a branch which generates man pages (although it's not quite finished, as far as I remember)
09:03:44 <chrisdone> Feuerbach: nice. is it on github?
09:04:37 <Feuerbach> I think I took it down
09:05:04 <chrisdone> .texinfo would be sweet because emacs supports it natively ^_^
09:05:40 * chrisdone looks at haddock's source
09:07:18 * hackagebot mersenne-random-pure64 0.2.0.4 - Generate high quality pseudorandom numbers purely using a Mersenne Twister  http://hackage.haskell.org/package/mersenne-random-pure64-0.2.0.4 (BenGamari)
09:08:15 <chrisdone> @vixen give me wisdom
09:08:15 <lambdabot> Once you get into this great stream of history, you can't get out.
09:08:31 <m1dnight> looks like i'll have to build a calender web app in haskell for my project
09:08:37 <m1dnight> we just finishe with monads
09:08:41 <m1dnight> and they throw this at us :p
09:09:22 <chrisdone> lol
09:09:52 <Feuerbach> m1dnight: where do you study?
09:09:56 <m1dnight> Brussels
09:10:14 <m1dnight> 'Vrije Universiteit BRussel' -> "Free univeristy Of BRussels"
09:10:23 <Feuerbach> cool
09:10:24 <m1dnight> I'm in my first master computer science
09:10:48 <tangentstorm> Hey guys.
09:10:49 <chrisdone> https://www.fpcomplete.com/school/project-templates/yesod-web-site
09:10:59 <m1dnight> So I have a backlog of project with one prolog project, one smalltalk project, one paper, one haskell project, two other papers
09:11:06 <m1dnight> i have my work cut out for me :p
09:11:18 <chrisdone> hehe. cut
09:11:42 <chrisdone> @choose funny unfunny
09:11:43 <lambdabot> funny
09:11:49 <chrisdone> you got my back, lambdabot
09:12:35 <tangentstorm> I'm trying to implement a monad that lets me write in a concatenative style (where everything operates on an implicit stack). I thought I understood what I was doing but I can't get it to compile. Details are in the file: https://github.com/tangentstorm/tangentlabs/blob/master/haskell/CmdShell.hs
09:12:39 <tangentstorm> Can someone help? :)
09:16:42 <Feuerbach> tangentstorm: it seems that you confuse the monad's inner type with the type of stack elements
09:16:52 <Feuerbach> tangentstorm: see if the Writer monad does what you want
09:17:01 <Feuerbach> together with the Endo monoid
09:19:35 <tangentstorm> Feuerbach: thanks, I'll take a look. But can you elaborate a bit? Why should the inner type be different than the type of stack elements?
09:23:41 <Feuerbach> well, for example, the expression do { lit 1; lit 2; lit 3; add; mul } kinda suggests that your inner type is (). Otherwise you'd probably want to bind the results to some variables
09:24:07 <tangentstorm> hrm
09:25:03 <tangentstorm> what I expect that to do is create a function (TCmd) that takes a stack and returns that same stack with the number 6 on it.
09:25:13 <tangentstorm> er the number 5
09:25:19 <tangentstorm> i see now my comment is wrong.
09:25:45 <tangentstorm> then, since run creates an empty stack, i expect the result of run demo to just be [5].
09:27:08 <tangentstorm> Hrm. I actually don't know what the result is because I couldn't compile. I will try just commenting the main routine out and experimenting.
09:27:28 * Guest68988 pleasee visit nuevo webchat page --> http://www.ChatSocial.org please yeah???? http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org
09:31:31 <Dasuraga> is there a backwards version of sequence? I know I could just write it but wanted to check if there was already a "canonical" function for it
09:31:55 <Feuerbach> > let op = tell . Dual . Endo in appEndo (getDual $ execWriter $ do { op (2:); op (3:); op (\(x:y:xs)->(x+y):xs); }) []
09:31:57 <lambdabot>   [5]
09:32:03 <quicksilver> "backwards" in what sense?
09:32:08 <Feuerbach> tangentstorm: that's the basic idea
09:32:21 <quicksilver> liftM reverse . sequence . reverse?
09:33:18 <sellout-> Dasuraga: Like (m [a] -> [m a])?
09:33:42 <joelteon> :t \xs -> do { x <- xs; map return x }
09:33:44 <lambdabot> Monad m => [[a]] -> [m a]
09:33:50 <joelteon> oh, right
09:33:52 <joelteon> :t \xs -> do { x <- xs; fmap return x }
09:33:53 <lambdabot> (Monad m, Monad m1, Functor m) => m (m a) -> m (m1 a)
09:33:58 <joelteon> no, that's not right either
09:34:52 <Dasuraga> I was more looking for something that would sequence the actions in reverse
09:35:32 <sellout-> Dasuraga: so … (sequence . reverse)?
09:36:09 <Feuerbach> Dasuraga: see http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Applicative-Backwards.html
09:36:27 <Feuerbach> that should be more efficient than reverse and also work with arbitrary Traversable
09:37:32 <Feuerbach> (but you'll need to use Data.Traversable.sequence, not the monadic one)
09:38:10 <tangentstorm> Going to take me a while to digest that, Feuerbach ... Thanks.
09:38:32 <tangentstorm> Commenting out my 'main' routine exposed some other compiler errors so i'm trying to clear those up.
09:43:11 <definity> are their any good videos of how to learn haskell
09:43:58 <zennist> how can I group the elements in a list such that all the same elements fit into a sublist but then the order is still preserved? e.g. group' "654456" = ["66", "55", "44"]
09:45:22 <Dasuraga> zennist: what do you use to decide how to group the elements?
09:45:40 <zennist> Dasuraga: just Eq
09:45:45 <mangaba_leitosa> > group $ sort "654456"
09:45:46 <lambdabot>   ["44","55","66"]
09:45:58 <zennist> mangaba_leitosa: that breaks the order of the elements
09:46:11 <mangaba_leitosa> zennist: ah, right
09:46:23 <mangaba_leitosa> zennist: but in you case, the last 6 is moved left :-)
09:47:39 <zennist> mangaba_leitosa: yes, maybe I should define it more precisely: so all the same elements in the list are grouped together, but the order of the groups is determined by the position of the first element in that group in the original list
09:47:50 <mangaba_leitosa> aha
09:48:43 <zennist> mangba_leitosa: can't think of a good way except sort and then group and then resort in the end
09:51:08 <mangaba_leitosa> zennist: or use Data.Map for memorizing positions and reconstruct the list :_)
09:54:43 <klrr_> what's the most appropriate termology, bind or lift when talking about (<-) (>>=) etc.
09:54:46 <klrr_> ?
09:54:50 <chrisdone> bind
09:54:58 <chrisdone> lift is a different concept
09:55:04 <klrr_> okey
09:55:11 <Iceland_jack> <- is not an operator so you shouldn't write it as (<-)
09:55:23 <klrr_> yeah true
09:55:55 <Iceland_jack> There is a page on the Haskell wiki with operators/syntax and their names though
09:55:59 <klrr_> well, so when talking about (a >>= b) i bind the value "inside" a and pass it to the function b?
09:56:25 <klrr_> and when i do (return a) i lift a into a monad?
09:56:36 <klrr_> just want to be sure i use right terms
09:57:06 <Dasuraga> I'm working with a lazy bytestring gotten from a sockets getContents, is there a way to know if the head of the bytestring is "ready" to be read?
09:58:20 <Dasuraga> basically I want to listen to two network ports instead of 1 and fuse the result into one bytestring, and I can't think of a way to do it that won't make the system block without testing whether theres a value to be read
09:58:42 <saml> stcp?
09:59:40 <klrr_> :t liftIO
09:59:41 <lambdabot> MonadIO m => IO a -> m a
10:02:41 <bearclaw> Dasuraga: I'm guessing it can't be done without explicitly using an asynchronous IO api
10:02:48 <Iceland_jack> Dasuraga: You can use threads or async
10:03:12 <mangaba_leitosa> @let import qualified Data.Map.Lazy as Map
10:03:15 <lambdabot>  Defined.
10:03:20 <mangaba_leitosa> @let import Data.Map.Lazy ((!))
10:03:20 <lambdabot>  Defined.
10:03:31 <mangaba_leitosa> > let l = "654456" in map (\(a, b) -> replicate (length b) a) $ sortBy (\a b -> compare (snd a) (snd b)) $ Map.toList $ Map.map reverse $ Map.fromListWith (++) $ zip l (map (:[]) [0..])
10:03:34 <lambdabot>   ["66","55","44"]
10:03:37 <mangaba_leitosa> zennist: ^ see above
10:04:10 <Dasuraga> actually the biggest issue I have is that right now my code expects one ByteString in the input
10:13:43 <Fuuzetsu> Shou: by the way, what's that new Haskell project you put up on GitHub?
10:14:14 <Fuuzetsu> Web IIRC client?
10:14:16 <Fuuzetsu> IRC*
10:16:14 <Shou> Fuuzetsu, it's just a simple web interface for IRC, through an IRC bot.
10:19:59 <moofy> applicative functors make me want to curl up into a ball
10:20:45 <zomg> A ball of joy, or a ball of HATE?
10:20:47 <zomg> ;)
10:21:13 <merijn> moofy: How so?
10:21:20 <moofy> a ball of ?_?
10:21:26 <merijn> moofy: They're pretty easy
10:21:32 <merijn> moofy: Do you understand Functor?
10:22:00 <roconnor> moofy: applicative functors of functors with liftA, liftA2, liftA3, ...
10:22:12 <moofy> possibly maybe. I'm not sure if up == down anymore
10:22:29 <roconnor> *are functors with
10:22:32 <FreeFull> moofy: For lists, applicative lets you combine a list of functions with a list of values
10:22:36 <merijn> moofy: Right, if you look at fmap it has type "(a -> b) -> f a -> f b", right?
10:22:43 <moofy> yes
10:22:49 <merijn> moofy: The trick is to realise that "b" can still be a function!
10:23:01 <merijn> moofy: Lets say we have Int addition (plus :: Int -> Int -> Int"
10:23:02 <moofy> i just don't know where <$> and <*> are sprouting from
10:23:10 <FreeFull> <$> is fmap
10:23:11 <alkabetz>  /reload
10:23:14 <moofy> ah okay
10:23:17 <bennofs> Is there ever a reason to use free monads over operational or the other way around? It seems that those two packages do basically the same
10:23:23 <alkabetz> Darn you irssi, sorry.
10:23:31 <moofy> could you do `fmap` instead of <$> ?
10:23:36 <FreeFull> Yes
10:23:37 <merijn> moofy: Yes
10:23:43 <moofy> aaaah okay
10:23:48 <moofy> this makes slightly more sense
10:23:56 <FreeFull> > (+1) <$> [3]
10:23:57 <lambdabot>   [4]
10:24:02 <FreeFull> > (+1) `fmap` [3]
10:24:04 <lambdabot>   [4]
10:24:13 <FreeFull> > (,) `fmap` [1,2] [3,4]
10:24:14 <lambdabot>   Couldn't match expected type `[t1] -> f0 a0'
10:24:15 <lambdabot>              with actual type ...
10:24:15 <merijn> moofy: basically, "fmap plus" 'a' is Int and 'b' is "Int -> Int"
10:24:18 <FreeFull> > (,) `fmap` [1,2] <*> [3,4]
10:24:20 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
10:24:38 <merijn> moofy: So "fmap plus :: f Int -> f (Int -> Int)"
10:25:00 <merijn> moofy: The problem now is, I have an "f (Int -> Int)" but how do I apply that function inside 'f' to something?
10:25:05 <FreeFull> :t fmap (+) [1,2,3]
10:25:06 <lambdabot> Num a => [a -> a]
10:25:20 <FreeFull> :t fmap (+) [1,2,3] <*> [5,6,7]
10:25:20 <merijn> moofy: Well, "(<*>) :: f (a -> b) -> f a -> f b"
10:25:21 <lambdabot> Num b => [b]
10:25:47 <merijn> moofy: So applicative functors are functors that can "apply" the functions "inside" the functor
10:25:51 <Fuuzetsu> Shou: Oh, how boring ;x I thought it might be something more exciting.
10:25:54 <merijn> (hence, applicative)
10:25:58 <moofy> right
10:26:06 <moofy> i think I just need to practice
10:26:25 <skypers> hey
10:26:51 <skypers> @let data Foo = Foo { foo :: Int }
10:26:52 <lambdabot>  Defined.
10:27:22 <skypers> @let newtype Foo2 = Foo2 Foo
10:27:23 <lambdabot>  Defined.
10:28:00 <skypers> arf I’m an idiot
10:33:35 <Shou> Fuuzetsu, yeah ;_;
10:33:52 <pamojarpan> hi, is some here doing some image processing with haskell?
10:38:29 <m1dnight> Can I ask ghci to show me, say the instance of Applicative by []?
10:38:34 <m1dnight> i thought I had seen it
10:38:51 <tarruda> @src newIORef
10:38:51 <lambdabot> newIORef v = stToIO (newSTRef v) >>= \ var -> return (IORef var)
10:39:05 <tomejaguar> m1dnight: I think you'll need to have imported the module where the instance is defined first.
10:39:31 <tarruda> @src newSTRRef
10:39:31 <lambdabot> Source not found. My pet ferret can type better than you!
10:39:34 <tarruda> @src newSTRef
10:39:34 <lambdabot> newSTRef init = ST $ \s1# ->
10:39:34 <lambdabot>     case newMutVar# init s1# of { (# s2#, var# #) -> (# s2#, STRef var# #) }
10:39:45 <lpaste> Fristi pasted “Simple validation” at http://lpaste.net/95981
10:39:47 <Fuuzetsu> Mhm, magic hash
10:39:56 <Fristi_> ello
10:40:05 <Fuuzetsu> Greetings.
10:41:06 <Fristi_> Haskell beginnner here , just started with a simple validation system (pasted above).. is there anyway i could make it simpler and would it be possible to only supply the result (Right) once in my validation sequence?
10:41:22 <roconnor> @src pure []
10:41:22 <lambdabot> Source not found. Sorry.
10:41:26 <roconnor> @src [] pure
10:41:26 <lambdabot> pure = return
10:41:34 <roconnor> @src [] (<*>)
10:41:34 <lambdabot> (<*>) = ap
10:42:06 <roconnor> m1dnight: for every monad, the canonical implemenation of Applicative is pure = return and (<*>) = ap
10:42:38 <Cale> Fristi_: This is unrelated to your question, but as soon as possible, you should configure your text editor to convert tabs to spaces
10:43:20 <Fristi_> @Cale I know :) Using Sublime on Windows, not properly configured.. usually cabal starts complaining about it.. but not using that atm :)
10:43:21 <lambdabot> Unknown command, try @list
10:44:11 <m1dnight> Preferences > Settings -Default >     "translate_tabs_to_spaces": true,
10:44:12 <m1dnight> done!
10:45:00 <Cale> Fristi_: notEmpty = not . null  -- this is more efficient, remember that length costs O(n) time
10:45:15 <Fristi_> @m1dnight: cheers :)
10:45:15 <lambdabot> Unknown command, try @list
10:45:41 <Fristi_> @Cale good point and more concise :)
10:45:41 <lambdabot> Unknown command, try @list
10:46:11 <alkabetz> Fristi_: Use “nick:”, not “@nick”; the former is IRC convention, and lambdabot latches onto the latter.
10:46:40 <Fristi_> alkabetz: i see thanks
10:46:48 <alkabetz> :)
10:49:31 <Cale> > sequence [Right 6, Left "e1", Left "e2"]
10:49:33 <lambdabot>   Left "e1"
10:49:45 <Cale> I guess sequence isn't quite what you want, hmm
10:50:34 <Cale> mconcat/mappend would be what you want if the individual validation steps gave Maybe Error results
10:51:01 <Cale> (Though perhaps it would be better to collect all the errors than to produce just one?)
10:51:51 <Fristi_> Cale: hmm good point..
10:52:18 <Fristi_> Cale: what would you suggest if you would catch all the errors? would sequence be applicable?
10:52:37 <Cale> Have each validator produce a [Error]
10:53:09 <Fristi_> from the transformers lib?
10:53:11 <Cale> and then only if every one of them passes (i.e. you concatenate the results and have an empty list), you give Right of the input string.
10:53:21 <Cale> No, that's meant to be your Error type
10:53:28 <Fristi_> ah i see
10:53:41 <Cale> (I'm assuming they won't always be mutually exclusive like they are now)
10:54:10 <fizbin> Can someone give me an example of using foldRight on an infinite list that couldn't be trivially replaced with map ?
10:54:44 <Cale> > foldr (\x xs -> if x > 10 then x : xs else xs) [] [1..]
10:54:45 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35...
10:54:57 <Cale> (you can write filter as foldr)
10:55:15 <fizbin> Cale: Okay. Hrm....
10:56:41 <fizbin> :t fix
10:56:42 <lambdabot> (a -> a) -> a
10:58:27 <Cale> > foldr (\x xs k s -> if k == 10 then s : xs 0 0 else xs (k + 1) (s + x)) (\k s -> []) [1..] 0 0 -- note that you can also have additional accumulated parameters in this way
10:58:28 <lambdabot>   [55,165,275,385,495,605,715,825,935,1045,1155,1265,1375,1485,1595,1705,1815...
10:58:44 <Cale> That computes sums of each 10 consecutive elements
10:59:00 <Cale> It might be clearer if I made them lists rather than adding them:
10:59:16 <Cale> > foldr (\x xs k s -> if k == 10 then s : xs 0 0 else xs (k + 1) (x : s)) (\k s -> []) [1..] 0 []
10:59:17 <lambdabot>   [[10,9,8,7,6,5,4,3,2,1],[21,20,19,18,17,16,15,14,13,12,0],[32,31,30,29,28,2...
10:59:36 <Cale> oh, oops
10:59:40 <fizbin>  Wait, what?
10:59:42 <Cale> Type error-ish
10:59:46 <Cale> > foldr (\x xs k s -> if k == 10 then s : xs 0 [] else xs (k + 1) (x : s)) (\k s -> []) [1..] 0 []
10:59:47 <lambdabot>   [[10,9,8,7,6,5,4,3,2,1],[21,20,19,18,17,16,15,14,13,12],[32,31,30,29,28,27,...
10:59:58 <Cale> I guess there's an instance of Num for lists around
11:00:02 <Cale> > 0 :: [Integer]
11:00:04 <lambdabot>   [0]
11:00:05 <Cale> yep
11:00:23 <bennofs> > [1,2,3] + [3,4,5]
11:00:24 <lambdabot>   [4,5,6,5,6,7,6,7,8]
11:00:26 <bennofs> :O
11:00:41 <Cale> ah, it's the Monad-derived instance
11:00:46 <fizbin> > [1, 2, 3] + [400, 500, 600]
11:00:48 <lambdabot>   [401,501,601,402,502,602,403,503,603]
11:00:57 <bennofs> it's liftA2 (+) ? That's weird
11:01:41 <FreeFull> > (id + id) 3
11:01:43 <lambdabot>   6
11:01:55 <FreeFull> > Just 3 + Just 4
11:01:56 <lambdabot>   Just 7
11:01:58 <Cale> oh, also, I suppose I messed that up a little, hehe
11:02:30 <Cale> (I'm not doing anything with the x in the case where it actually emits an element)
11:03:07 <Cale> > foldr (\x xs k s -> if k == 10 then s : xs 1 [x] else xs (k + 1) (x : s)) (\k s -> []) [1..] 0 []
11:03:09 <lambdabot>   [[10,9,8,7,6,5,4,3,2,1],[20,19,18,17,16,15,14,13,12,11],[30,29,28,27,26,25,...
11:03:14 <Cale> there we go
11:03:54 <Cale> > foldr (\x xs k s -> if k == 10 then s : xs 1 x else xs (k + 1) (x + s)) (\k s -> []) [1..] 0 0 -- the sums, done right now
11:03:55 <lambdabot>   [55,155,255,355,455,555,655,755,855,955,1055,1155,1255,1355,1455,1555,1655,...
11:04:08 <Cale> cute
11:05:38 <Cale> What else can't you do with map...
11:06:05 <Cale> > foldr (\x xs -> x : x : xs) [] [0..] -- duplicate all the elements
11:06:06 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,1...
11:06:19 <lightquake> why do all the network packages take a string as their port number? :/
11:06:25 <Cale> :t Branch
11:06:26 <lambdabot> Not in scope: data constructor `Branch'
11:06:30 <Cale> :t Node
11:06:30 <lambdabot> a -> Forest a -> Tree a
11:06:33 <Cale> cool
11:07:46 <skypers> :t forM
11:07:47 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
11:07:51 <Cale> > foldr (\x xs -> [Node x xs]) [] [0..]
11:07:52 <lambdabot>   [Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {...
11:08:08 <Cale> Worst Tree datastructure NA.
11:08:15 <Cale> but yeah
11:08:46 <simpson> Oh, good, I'm not the only one that dislikes it.
11:09:05 <maurer> Cale: Wait, I thought this was #haskell, not #lol
11:09:07 <maurer> >_>
11:09:44 <skypers> 19:52 < lightquake> why do all the network packages take a string as their port number? :/
11:09:51 <skypers> whaaaaat?
11:10:04 <Cale> > foldr (\x xs -> (\tip branch -> branch x xs xs)) tip [0,1,2] "Tip" (\x l r -> concat ["(Branch ", show x, " ", l, " ", r, ")"])
11:10:05 <lambdabot>   Not in scope: `tip'
11:10:05 <lambdabot>  Perhaps you meant one of these:
11:10:05 <lambdabot>    `zip' (imported fro...
11:10:07 <Cale> errr
11:10:17 <Cale> > foldr (\x xs -> (\tip branch -> branch x xs xs)) (\tip branch -> tip) [0,1,2] "Tip" (\x l r -> concat ["(Branch ", show x, " ", l, " ", r, ")"])
11:10:18 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:10:18 <lambdabot>              with actual ty...
11:10:20 <Cale> hmm
11:10:42 <skypers> lightquake: have a loot at PortNumber ;)
11:11:04 <lightquake> skypers: well, all the ones i'm looking at!
11:11:05 <skypers> PortNumber . fromIntegral $ 80
11:11:10 <Cale> oh, of course
11:11:19 <lightquake> like network-simple
11:11:29 <Cale> > foldr (\x xs -> (\tip branch -> branch x (xs tip branch) (xs tip branch))) (\tip branch -> tip) [0,1,2] "Tip" (\x l r -> concat ["(Branch ", show x, " ", l, " ", r, ")"])
11:11:30 <lambdabot>   "(Branch 0 (Branch 1 (Branch 2 Tip Tip) (Branch 2 Tip Tip)) (Branch 1 (Bran...
11:11:35 <skypers> lightquake: in Network
11:11:41 <Cale> there we go, so we could do that on an infinite list too
11:11:45 <skypers> @index PortNumber
11:11:45 <lambdabot> Network, Network.Socket, Network.BSD, Network
11:11:47 <Cale> > foldr (\x xs -> (\tip branch -> branch x (xs tip branch) (xs tip branch))) (\tip branch -> tip) [0..] "Tip" (\x l r -> concat ["(Branch ", show x, " ", l, " ", r, ")"])
11:11:48 <lambdabot>   "(Branch 0 (Branch 1 (Branch 2 (Branch 3 (Branch 4 (Branch 5 (Branch 6 (Bra...
11:11:55 <skypers> :t PortNumber
11:11:55 <lambdabot> Not in scope: data constructor `PortNumber'
11:11:57 <lightquake> @index ServiceName
11:11:57 <lambdabot> Network.BSD
11:12:06 <lightquake> that's what i'm looking at
11:12:07 <Cale> and get the complete depth-indexed infinite binary tree
11:12:14 <skypers> lightquake: yeah, ,but :
11:12:16 <skypers> data PortID = Service String | PortNumber PortNumber | UnixSocket String
11:12:20 <lightquake> right
11:12:23 <Cale> (but the string won't show us all of it)
11:12:29 <skypers> just use the right ctor :)
11:12:43 <Cale> (I'm simulating algebraic datatypes there using lambdas)
11:12:57 <Cale> Oh, lambdabot supports data now doesn't it?
11:13:05 <skypers> sounds to
11:13:24 <Cale> @let data T a = Tip | Branch a (Tree a) (Tree a) deriving (Eq, Ord, Show)
11:13:25 <lambdabot>  .L.hs:162:24:
11:13:25 <lambdabot>      No instance for (Ord (Tree a))
11:13:25 <lambdabot>        arising from the 'd...
11:13:36 <Cale> er, okay
11:13:39 <Cale> @let data T a = Tip | Branch a (Tree a) (Tree a)
11:13:40 <lambdabot>  Defined.
11:13:46 <Cale> oh
11:13:48 <Cale> lol!
11:13:52 <skypers> > Tip
11:13:53 <lambdabot>   No instance for (GHC.Show.Show (L.T a0))
11:13:53 <lambdabot>    arising from a use of `M2474237...
11:13:55 <Cale> @undefine
11:13:55 <lambdabot> Undefined.
11:14:04 <Cale> @let data T a = Tip | Branch a (T a) (T a) deriving (Eq, Ord, Show)
11:14:06 <lambdabot>  Defined.
11:14:09 <Cale> there!
11:14:29 <skypers> I read somewhere it’s bad to include empty ctor in such containers
11:14:36 <skypers> and a better use would be through Maybe
11:14:40 <Cale> > foldr (\x xs -> Branch x xs xs) Tip [0..]
11:14:41 <skypers> I don’t understand why
11:14:42 <lambdabot>   Branch 0 (Branch 1 (Branch 2 (Branch 3 (Branch 4 (Branch 5 (Branch 6 (Branc...
11:14:54 <Cale> It depends on what you're after
11:15:06 <ReinH> chrisdone: new haskell cast should come out Monday
11:15:06 <Cale> I think it's perfectly natural to admit an empty tree
11:15:24 <skypers> I think so as well
11:15:30 <Cale> > foldr (\x xs -> Branch x xs Tip) Tip [0..3]
11:15:32 <lambdabot>   Branch 0 (Branch 1 (Branch 2 (Branch 3 Tip Tip) Tip) Tip) Tip
11:15:35 <chrisdone> ReinH: i have to wait till monday!!
11:15:40 <Cale> > foldr (\x xs -> Branch x Tip xs) Tip [0..3]
11:15:44 <lambdabot>   Branch 0 Tip (Branch 1 Tip (Branch 2 Tip (Branch 3 Tip Tip)))
11:15:53 <chrisdone> ReinH: \o/
11:15:59 <ReinH> :p
11:16:03 <skypers> you seem having fun, chrisdone :)
11:16:05 <skypers> Cale*
11:16:39 <Cale> > foldr (\x xs k -> if k then Branch x Tip (xs (not k)) else Branch x (xs (not k)) Tip) Tip [0..3] True
11:16:40 <lambdabot>   can't find file: L.hs
11:16:43 <Cale> wat
11:16:59 <ReinH> Cale: L.hs, lambdabot can't find it. What part of that is unclear? :p
11:17:05 <skypers> :D
11:17:12 <Cale> Was a type error anyway
11:17:52 <Cale> > foldr (\x xs k -> if k then Branch x Tip (xs (not k)) else Branch x (xs (not k)) Tip) (\k -> Tip) [0..3] True
11:17:53 <lambdabot>   Branch 0 Tip (Branch 1 (Branch 2 Tip (Branch 3 Tip Tip)) Tip)
11:18:02 <Cale> (zigzag tree)
11:18:39 <Cale> fizbin: Convinced that it's powerful? :)
11:18:43 <Cale> > foldr (\x xs k -> if k then Branch x Tip (xs (not k)) else Branch x (xs (not k)) Tip) (\k -> Tip) [0..] True
11:18:45 <lambdabot>   Branch 0 Tip (Branch 1 (Branch 2 Tip (Branch 3 (Branch 4 Tip (Branch 5 (Bra...
11:18:50 <mizu_no_oto> What's the current status of ghc 7.8?
11:19:22 <skypers> 7.6.3
11:19:30 <Cale> skypers: lol
11:19:55 <skypers> 7.6.3, which is not!
11:19:56 <fizbin> Cale: Fair enough.
11:19:57 <skypers> :–’
11:20:02 <Cale> https://ghc.haskell.org/trac/ghc/query?status=!closed&milestone=7.8.1&order=priority
11:20:24 <Cale> https://ghc.haskell.org/trac/ghc/wiki/Status/Oct13
11:20:56 <mizu_no_oto> Cale: thanks
11:21:18 <mizu_no_oto> Basically, sometime in the next month or so?
11:21:40 <Cale> I think that sounds reasonable, but I'm not a GHC dev :)
11:21:47 <skypers> TypeHoles
11:21:55 <skypers> sounds a brillant extension!
11:22:26 <Cale> It shouldn't be called TypeHoles though
11:22:41 <Cale> Because it's value holes :P
11:22:48 <skypers> :)
11:22:52 <skypers> or Stub
11:22:59 <skypers> I’d use them for that
11:23:10 <Cale> They set out to do type-level holes, but that was too hard
11:23:23 <Cale> But the name of the extension didn't change :P
11:23:28 <w0rm_x> > Debug.SimpleReflect.a * 23
11:23:29 <lambdabot>   a * 23
11:23:58 <w0rm_x> :t Debug.SimpleReflect.a
11:23:58 <lambdabot> Expr
11:24:31 <skypers> :t traverse
11:24:32 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:26:25 <lightquake> is it possible to pull the do the whole 'clone a socket, close the read end on one copy and write end on another' thing? i can't find any functions that dup a socket, nor ones that only close one end
11:26:36 <klrr_> :t nub
11:26:36 <lambdabot> Eq a => [a] -> [a]
11:26:44 <klrr_> > nub [1,2,3]
11:26:45 <lambdabot>   [1,2,3]
11:26:53 <klrr_> > nub [3,2,1]
11:26:54 <lambdabot>   [3,2,1]
11:27:00 <Cale> lightquake: er, does it have to remain a Socket?
11:27:02 <klrr_> ?src nub
11:27:02 <lambdabot> nub = nubBy (==)
11:27:08 <klrr_> ?src nubBy
11:27:08 <lambdabot> nubBy eq []             =  []
11:27:08 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:27:30 <lightquake> Cale: no, I guess not
11:27:52 <Cale> lightquake: One thing which I've found to be a very effective thing to do in the past is just to pre-apply whatever the appropriate read/write functions are to the thing and pass the resulting functions/IO actions around instead.
11:28:33 <lightquake> hmm, I guess that makes sense
11:29:00 <lightquake> what i'm actually trying to do: write a simple chat server using pipes, pipes-network, and network-simple
11:30:44 <Cale> lightquake: So I guess you can pre-apply fromSocket and toSocket to your given Socket value, and pass those in as parameters to the rest of whatever it is that you have to do, if you want to control read/write permissions.
11:32:00 <lightquake> yeah, I think that gives me a good enough guarantee for what I need
11:33:37 <bennofs> How would I use pipes to compare a bytestring to an incoming stream of bytes?
11:35:12 <bennofs> (I only need equal / not equal)
11:37:05 <lightquake> bennofs: is 'compute the length of your bytestring, take that many bytes from the stream, compare' an acceptable answer?
11:38:10 <bennofs> Well, that will work, but I'd like to know if there is a way to avoid pulling in the input bytestring at once in memory?
11:38:29 <bennofs> In theory, it should be possible to only consume one Char8 at a time and compare it
11:38:38 <lightquake> right
11:38:40 <mornfall> bennofs: very inefficient
11:38:48 <bennofs> I know
11:38:48 <mornfall> pull out 1K bytestrings
11:38:52 <mornfall> or something like that
11:39:04 <lightquake> how long is your target bytestring?
11:39:39 <bennofs> lightquake: Hmm, I think in my case it's not so long that it actually matters :P Still, I'm curious how to do that ...
11:40:46 <mornfall> there's zillion iteratee libraries that do that stuff
11:41:10 <lightquake> what i'd do is i'd pick some chunk size, like 4096, and break my input bytestring into chunk-size bytestrings
11:41:22 <lightquake> then read a chunk at the time from the pipe and compare
11:41:22 <bennofs> lightquake: and then?
11:42:21 <lightquake> and what you do at the end depends on the semantics: does "abc" compare equal to the stream "abcde"?
11:42:45 <bennofs> no.
11:43:09 <levi> lightquake: Heh. I'm in the process of turning my simple Pipes chat server into a full-blown IRC server, and hopefully thereafter into a multi-protocol chat server.
11:43:09 <lightquake> well once you've consumed the pattern you'll need to do one more read from the pipe, which i'm not sure how to do in a nice way; i don't know much about pipes
11:43:15 <ReinH> bennofs: lazy zip?
11:43:47 <lightquake> comedy answer: ask on /r/haskell, wait for tekmo to read your post
11:44:17 <levi> lightquake: Pipes automatically chunks bytestrings for you.
11:44:55 <lightquake> levi: i don't know how pipes interacts with bytestrings specifically, i thought it didn't have text/bytestring support built-in
11:46:06 <levi> See pipes-bytestring, pipes-network, pipes-parse, pipes-attoparsec, and pipes-network.
11:46:37 <levi> Possibly also pipes-concurrency
11:46:51 <lightquake> oh, i didn't know pipes-bytestring exists
11:47:40 <ReinH> the general lazy solution would be like `let (.:) = fmap fmap fmap in and .: zipWith (==)', right?
11:48:02 <ReinH> bennofs: ^
11:49:04 <ReinH> > let (.:) = fmap fmap fmap in (and .: zipWith (==)) [1..] [2..]
11:49:05 <lambdabot>   False
11:51:33 <levi> lightquake: And here's some example code from Tekmo: http://lpaste.net/95782
11:52:01 <joelteon> :t (.:)
11:52:02 <lambdabot>     Not in scope: `.:'
11:52:02 <lambdabot>     Perhaps you meant one of these:
11:52:02 <lambdabot>       `.' (imported from Data.Function),
11:52:13 <joelteon> @let (.:) = fmap fmap fmap
11:52:14 <lambdabot>  .L.hs:149:13:
11:52:15 <lambdabot>      No instance for (Functor f0) arising from a use of `fmap'...
11:52:20 <joelteon> b-but
11:52:22 <joelteon> that's the point
11:52:34 <lightquake> levi: heh, i was like 'wow, this is like 100 lines for a simple chat server?' and then i noticed it was heavily commented
11:52:38 <ReinH> wat
11:52:40 <lightquake> :t fmap fmap fmap
11:52:41 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:53:00 <joelteon> @let (.:) = fmap fmap fmap; (.:) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
11:53:02 <lambdabot>  Defined.
11:53:08 <ReinH> :t (.).(.)
11:53:09 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:53:16 <zennist> mangaba_leitosa: thanks! in the end I went a simpler approach of just using
11:53:31 <joelteon> > (* 3) .: [Just 4, Just 5, Nothing]
11:53:33 <lambdabot>   [Just 12,Just 15,Nothing]
11:53:46 <ReinH> sweet
11:54:41 <levi> lightquake: That's not a chat server, but it should help you put together the infrastructure for one.
11:56:40 <joelteon> can you build a local hooglE?
11:56:44 <joelteon> that would be helpful for me
11:56:55 <bennofs> What I don't like about pipes is that chunking is so explicit. I feel like I always have to manually implement much of pipes logic for dealing with the chunk boundaries
11:56:59 <levi> lightquake: Also relevant are the chat server examples from Parallel and Concurrent Programming in Haskell.  They don't use pipes, but you can't really do a chat server with a single pipeline anyway.
11:57:02 <bennofs> joelteon: cabal install hoogle
11:57:34 * hackagebot http-conduit 1.9.5.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.5.2 (MichaelSnoyman)
11:59:47 <lightquake> bennofs: yeah, i'm not sure what to do about that
11:59:53 <levi> bennofs: Are you referring to the FreeT stuff for delimiting things?
12:00:40 <bennofs> For example, how would I implement a splitter that splits on a given ByteString (not only a given Char8) ?
12:03:31 <levi> Well, I just used pipes-attoparsec to create a producer that modifies the underlying producer of ByteString instead of trying to put a splitter into a pipeline.
12:16:04 <m1dnight> Sorry for another question but
12:16:13 <m1dnight> I'm havind trouble with Applicative ((->) r)
12:16:25 <m1dnight> (+) <$> (+3) <*> (*100) $ 5
12:16:34 <m1dnight> this is explained in the book as follows:
12:16:45 <m1dnight> the 5 first got applied to (+3) and (*100), resulting in 8 and 500. Then, + gets called with 8 and 500, resulting in 508
12:16:58 <m1dnight> Doesn't it first evaluate everything to the left of the $?
12:18:07 <geekosaur> <$> is not $
12:18:09 <raek> I think that explanation refers to the way the resulting expression is built up
12:18:41 <geekosaur> and, you do not seem to have a handle on lazy evaluation, what 'first evaluate everything to the left'
12:18:48 <raek> when the expression gets evaluated is not relevant
12:19:27 <m1dnight> well
12:19:43 <m1dnight> I tried to replace everything by the implementation in the Applicative instances
12:19:47 <m1dnight> and this is what I cma eup with
12:19:51 <m1dnight> (sorry, lag on puttyà
12:20:06 <m1dnight> \y -> (\x -> (+) ((+3) x)) y ((*100) y)
12:20:14 <m1dnight> that looks so freakin nasty
12:20:23 <raek> think of it as "let a = (+3) 5; b = (*100) 5 in (+) a b"
12:20:45 <geekosaur> it is nasty, that
12:20:51 <geekosaur> s why we have applicative to hide it :)
12:21:01 <lilred> hey guys, I've noticed that the Haskell community tends to have solid perspectives on a whole lot of hard problems, so I come with this interrogation: is there a better theoretical alternative to HTML et al. for UI markup?
12:21:14 <m1dnight> well that's right
12:21:22 <lilred> like general semantic principles for UI markup languages and tooling
12:21:26 <m1dnight> It's just weird to me that it feeds the parameter to each function
12:21:31 <m1dnight> really weard
12:21:34 <m1dnight> weird
12:21:38 <m1dnight> i'll red some more in the book
12:21:42 <m1dnight> if i dont get it ill be back :p
12:21:42 <ReinH> m1dnight: <*> for functions is (<*>) f g x = f x (g x)
12:21:42 <arkeet> m1dnight: if I define
12:21:44 <m1dnight> thanks already
12:21:47 <m1dnight> ho
12:21:50 <m1dnight> yeah
12:21:55 <ReinH> what is f and what is g?
12:21:59 <ReinH> in your example?
12:22:01 <arkeet> well
12:22:06 <m1dnight> f and g are functions which expect 1 more parameter
12:22:09 <m1dnight> so partially applied functions
12:22:38 <m1dnight> in my case the first one would be (fmap (+) (+3))
12:22:39 <ReinH> m1dnight: right, but can you write them out?
12:22:44 <m1dnight> and the second one would be (*100)
12:22:46 <ReinH> what is fmap for functions?
12:23:01 <m1dnight> fmap is (.)
12:23:13 <m1dnight> So I would apply (+) to the result of applying (+3) to the input
12:23:23 <chridi> hi
12:23:39 <m1dnight> and then I can't get it into my brain with the <*>
12:23:50 <chridi> I want to do some IO stuff inside a ServerPart Response monad from happstack.lite
12:24:16 <alkabetz> chridi: Is the 'ServerPart' monad a 'MonadIO'?
12:24:17 <stepcut> chridi: liftIO $ putStrLn "foo" ?
12:24:17 <arkeet> (h <$> f <*> g) x = ((h . f) <*> g) x = (h . f) x (g x)
12:24:26 <arkeet> the first = is by definition of <$> = fmap, the second by definition of <*>
12:24:41 <arkeet> and (h . f) x = h (f x), so the whole thing is  h (f x) (g x)
12:24:45 <m1dnight> yes, but wouldnt (h . f) x resolve to an integer (in this case)
12:24:53 <arkeet> no, it's a function
12:25:05 <ReinH> :t (+) . (+3)
12:25:06 <lambdabot> Num b => b -> b -> b
12:25:48 <ReinH> > let f = (+) . (+3) in f 10 100
12:25:49 <lambdabot>   113
12:25:57 <chridi> stepcut: you're talking of liftIO from Control.Monad.IO.Class ?
12:26:01 <arkeet> > let f = (,) . (+3) in f 10 100
12:26:02 <lambdabot>   (13,100)
12:26:09 <stepcut> chridi: yes
12:26:23 <m1dnight> aaaaaaah
12:26:26 <m1dnight> i think I see it now
12:26:29 <stepcut> chridi: usually you just get it via, import Control.Monad.Trans (MonadIO(liftIO))
12:26:30 <ReinH> right, (+) . (+3) takes two Nums and adds 3 to the first, then adds them together
12:26:50 <chridi> ah yes
12:26:53 <m1dnight> because (+3) applied to a value returns a value, (+) on that return a new partially applied function
12:26:53 <arkeet> ((+) . (+3)) x = (+) ((+3) x)
12:26:59 <chridi> seems like it's the thing I wanted :)  thanks
12:27:05 <arkeet> ((+) . (+3)) x y = (+) ((+3) x) y = (+) (x+3) y
12:27:14 <arkeet> m1dnight: yep
12:27:17 <arkeet> :)
12:27:23 <m1dnight> okay, aback to the book!
12:27:26 <m1dnight> im gonna figure this one out! :D
12:27:28 <m1dnight> thanks guys!!!
12:27:33 <arkeet> honestly I prefer writing  liftA2 f x y  over f <$> x <*> y
12:27:51 <arkeet> :t liftA2 (+)
12:27:51 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
12:28:23 <ReinH> arkeet: the function instance for many typeclasses seems to be the one that makes them click for me
12:28:28 <ReinH> starting with Functor
12:28:38 <arkeet> yeah
12:28:41 <arkeet> perhaps
12:28:57 <arkeet> I use the Applicative instance for functions all the time.
12:29:09 <arkeet> Functor not so much because you may as well write (.)
12:29:26 <ReinH> arkeet: I mean that (-> a) is a motivating example for a lot of typeclasses for me
12:29:36 <ReinH> and understanding it helps me understand the typeclass
12:29:40 <arkeet> (I hope you mean ((->) a)
12:29:41 <arkeet> indeed
12:29:44 <ReinH> yeah
12:29:44 <arkeet> )
12:30:02 <ReinH> functor for ((->) a) was my first "oh it's not just for containers" moment
12:30:06 <frx> above didn't work for me
12:30:16 <frx> > ((+) . (+3)) 10 20
12:30:18 <lambdabot>   33
12:30:24 <arkeet> sure it's a container.
12:30:33 <arkeet> ((->) a) x contains one x for every value of type a.
12:30:35 <frx> nevermind it does
12:30:48 <ReinH> arkeet: I know, it's isomorphic to a total map, but you know what I mean
12:30:55 <arkeet> :)
12:31:07 <arkeet> exercise: figure out how Cont r is a container.
12:31:32 <ReinH> that notion of functions as a container comes back with representable functors and memoization, which was also a big insight for me
12:33:36 <ReinH> arkeet: I made the mental switch form "container" to "mapping from object to object and arrow to arrow", i.e. "Functor is a functor", relatively recently in my Haskell career
12:33:45 <ReinH> *from
12:34:43 <ReinH> Yay abstract nonsense
12:34:45 <FireFly> What is the etymology of 'map' in `map` and `fmap`?
12:35:05 <alkabetz> FireFly: From Lisp, I suspect.
12:35:28 <jle`> it's from math
12:35:47 <FireFly> I mean, since I knew `map` from way back I initially though of it as "well, it applies a function (which is a mapping) to every element" and of fmap as "well, it's like map except more general and map was already in use"
12:36:01 <jle`> when you map a space to another space, it means that you apply the function to every point in the space
12:36:14 <alkabetz> jle`: Oh, that’s cool!  I never thought of it like that.
12:36:28 <jle`> that's what a 'map' in real life is, too.
12:36:37 <jle`> every point in the world is transformed into a point on your paper map
12:36:41 <FireFly> But after learning what a functor is, it kinda makes sense for "fmap" to represent the mappings the functor does, and "map" as a specialisation of it..
12:37:13 * alkabetz looks up etymology for 'map'
12:37:19 <FireFly> jle`: hm, interesting point
12:37:24 <ReinH> jle`: pretty sure that mapping is surjective ;)
12:37:26 * alkabetz looks up etymology for 'map'
12:38:07 <jle`> map is just a synonym for function i think i mathematics
12:38:17 <jle`> *in
12:38:20 <arkeet> https://www.google.com/search?q=etymology+map
12:38:21 <alkabetz> Huh, apparently, the etymology of 'map' (as in a paper map) is a bit uncertain
12:38:24 <ReinH> FireFly: I suspect that fmap followed map
12:38:53 <ReinH> as map appears in many langauges for the same concept (the list functor)
12:39:37 <jle`> what is the established way of dealing with a 2D vector
12:39:44 <jle`> not a matrix
12:40:03 <ReinH> jle`: what size?
12:40:04 <jle`> i don't need any linaer algebra. just want to index/store things in two dimensions
12:40:21 <bjorkintosh> what's wrong with a table, jle`?
12:40:26 <alkabetz> jle`: You want a pair '(,)', no?
12:40:27 <ReinH> I also suspect that map was used (consciously or otherwise) as a "friendlier" synonym for morphism
12:40:48 <arkeet> ReinH: that doesn't make sense in context. ;)
12:40:49 <jle`> the size is not necessairly bounded, but eventually will be about 500 x 500
12:41:00 <ReinH> jle`: Vector with some Ix isomorphic to (,)
12:41:39 <m1dnight> great, I solved it
12:41:41 <asmyers> Anyone know how to customize where haskell-mode looks for the "cabal" command?  I've been poking around in the .el files but can't find it
12:41:45 <m1dnight> drew it out on my whiteboard, added the types
12:41:49 <asmyers> Right now it's using the system cabal which is old
12:41:52 <FireFly> ReinH: I suppose. I wish I'd know what I first thought when I learned about `map`..
12:41:58 <m1dnight> this is something I'll never shake out of my sleeve just like that though
12:42:00 <jle`> ReinH: i need to be able to index into it, so tuple doesn't really work
12:42:02 <m1dnight> needs some experience I suppose
12:42:03 <asmyers> My path and exec-path both have ~/.cabal/bin on the front
12:42:24 <ReinH> arkeet: doesn't make sense in context? map = morphism is pretty widely used
12:42:31 <jle`> unless i abuse TH
12:42:36 <arkeet> ReinH: I mean in the context of map/fmap in haskell.
12:42:46 <arkeet> I mean those are mappings of morphisms.
12:42:47 <monochrom> asmyers: does emacs see the same PATH as your shell does? it is not always true.
12:43:06 <ReinH> arkeet: I don't understand
12:43:14 <arkeet> fmap :: (a -> b) -> (f a -> f b)
12:43:19 <arkeet> I wouldn't call that a morphism.
12:43:27 <ReinH> er
12:43:31 <arkeet> ;)
12:43:50 <ReinH> but ofc it is? A functor is a category homomorphism?
12:44:07 <ReinH> in Haskell they are endomorphisms in Hask
12:44:19 <asmyers> monochrom: hrm, looks like the problem was an unexpanded ~ in the path emacs saw
12:44:20 <ReinH> fmap maps arrows to arrows
12:44:30 <asmyers> monochrom: I am never sure when it will expand those and when not :p
12:45:49 <arkeet> perhaps it is, but not in any category I know.
12:46:02 <ReinH> it's a morphism morphism :p
12:46:31 <arkeet> =(
12:47:05 <ReinH> arkeet: ?
12:47:19 <arkeet> <ReinH> it's a morphism morphism :p
12:47:37 <Guest57834> I think I have asked this question here before but I am designing an alarm system in Haskell and am interested in maybe using FRP to handle incoming alarms.  Trying to decide which library to try.
12:47:41 <ReinH> Well... that's what a functor is...
12:47:55 <arkeet> perhaps.
12:47:56 <ReinH> fmap is a morphism from one arrow (morphism) to another
12:48:10 <arkeet> uh.
12:48:19 <ReinH> ?
12:48:35 <arkeet> I dunno. bye
12:49:04 <oleo> a->b->c, a->b->a->c
12:49:06 <ReinH> Functor in Haskell is an endomorphism on Hask, right?
12:49:08 <alkabetz> Guest57834: You mean like SIGALRM?
12:49:26 <oleo> (a->b)->(a->c)
12:49:27 <alkabetz> ReinH: *a* Functor in Haskell is an endomorphism on Hask.
12:49:43 <ReinH> alkabetz: that's fair
12:49:48 <alkabetz> :)
12:49:55 <ReinH> any concrete fmap implementation is an endomorphism on Hask
12:50:04 <ReinH> morphisms in Hask are functions
12:50:11 <ReinH> fmap is a morphism morphism
12:50:16 <ReinH> QED
12:50:17 <ReinH> :p
12:50:37 <Guest57834> No, like something that monitors a database which is connected to a PLC and when an alarm is set to active in that database, calls out to a user.
12:50:45 <ReinH> so fmap fmap fmap is a morphism morphism morphism morphism morphism morphism
12:50:59 <ReinH> buffalo buffalo buffalo buffalo buffalo buffalo buffalo
12:51:04 <alkabetz> Darn it, you beat me to it.
12:51:06 <oleo> lol
12:51:15 <ReinH> :D
12:51:26 <alkabetz> Guest57834: PLC?
12:51:33 <Guest57834> sorry
12:51:40 <Guest57834> Programmable Logic Controller
12:51:57 <ReinH> Guest57834: the question is what interface does it provide? Some kind of socket?
12:52:12 <Guest57834> The database?
12:52:30 <alkabetz> Guest57834: Do you want to monitor the database or the PLC?
12:52:31 <Guest57834> I just need to handle alarms present in a MySQL
12:52:37 <Guest57834> Database
12:52:41 <Guest57834> just check it for triggers
12:53:00 <Guest57834> The PLC puts its out put into the database
12:53:05 <alkabetz> Guest57834: Ah, gotcha.  (Sorry, I’m not super familiar with how alarms work in databases, so I’m just trying to make sure I really understand)
12:53:12 <Guest57834> I want to read them out and then do things
12:53:22 <Guest57834> no problem
12:53:41 <alkabetz> Guest57834: I would advise against FRP for this, unless your app is already using it
12:53:48 <TallerGhostWalt> It is not
12:53:55 <TallerGhostWalt> sorry I was Guest57834
12:53:58 <TallerGhostWalt> lol logged in wrong
12:54:04 <alkabetz> TallerGhostWalt: Yeah, no worries
12:54:10 <TallerGhostWalt> alkabetz: why?
12:54:22 <alkabetz> TallerGhostWalt: FRP tends to add a lot of complexity to an app, so it doesn’t seem worth it to introduce it just for this one use case
12:54:46 <alkabetz> alkabetz: Or, more accurately, trying to use FRP in a non-FRP app introduces a lot of complexity
12:55:03 <alkabetz> Derp, one day I’ll figure out how to use my IRC client
12:55:17 <alkabetz> TallerGhostWalt: FRP seems to be kind of an all-or-nothing proposition.
12:55:33 <TallerGhostWalt> Yeah, I have tried several ways of handling the alarms
12:55:38 <simpson> alkabetz: Which library are you looking at? netwire and sodium both appear to be as-you-like.
12:55:39 <TallerGhostWalt> They have several states
12:56:05 <alkabetz> simpson: I only have experience with bananas
12:56:38 <TallerGhostWalt> I should say the alarms have to monitor clears, acknowledgement, a call list, trip times, and clear times
12:57:03 <TallerGhostWalt> I have been doing it with Monad.Loops
12:57:34 <TallerGhostWalt> I just feel the state is really hard to follow because there is a lot of recursion and I would like to make it more "on the surface"?
12:57:47 <levi> TallerGhostWalt: FRP tends to be most useful for things that vary continuously over time, like physical models of things. It sounds like you may just need concurrency and mailboxes or streams unless your state is truly a function of time rather than a set of discrete events.
12:58:17 <alkabetz> TallerGhostWalt: So, what’s your database interface like?  Does it poke you when an alarm occurs? or do you have to poll?
12:58:22 <TallerGhostWalt> poll
12:58:38 <ReinH> This doesn't sound like a job for FRP to me
12:58:45 <TallerGhostWalt> fair enough
12:58:46 <alkabetz> TallerGhostWalt: Yeah, I would just 'forkIO' off a poll thread
12:59:47 <TallerGhostWalt> Okay then, I will proceed in a forky IOy way!
12:59:48 <alkabetz> levi: I had never heard of mailboxes, that’s kind of cool
12:59:50 <TallerGhostWalt> Thanks everyone
12:59:59 <alkabetz> You’re welcome!  Good luck!
13:00:12 <TallerGhostWalt> Waaiiit I missed the mailboxes!
13:00:18 <TallerGhostWalt> lol
13:00:39 <levi> alkabetz: Parallel and Concurrent Programming in Haskell is a great intro to the cool primitives GHC has got for that kind of thing.
13:00:46 <skypers> @pl flip . foldM
13:00:46 <lambdabot> flip . foldM
13:00:49 <TallerGhostWalt> hear something on hirc... Type it into Google... get pictures of mailboxes
13:00:51 <skypers> oh thank you.
13:00:52 <levi> And it's readable for free!
13:00:59 <alkabetz> levi: Yeah, it’s on my reading list …
13:01:01 <skypers> @hoogle flip . foldM
13:01:01 <lambdabot> Parse error:
13:01:01 <lambdabot>   flip . foldM
13:01:01 <lambdabot>         ^
13:01:22 <TallerGhostWalt> okay I will look them up in the book
13:01:23 <TallerGhostWalt> thanks
13:01:27 <TallerGhostWalt> adios
13:01:47 <skypers> adios le pido
13:01:51 <skypers> ok sorry, it was lame
13:01:52 <skypers> :D
13:01:56 <levi> alkabetz: It's worth skimming *right now* if you are doing anything in Haskell that might benefit from parallelism or concurrency.
13:02:30 <alkabetz> levi: I’m not today, but I’ll be sure to have a look next time I am :)
13:02:39 * hackagebot yesod-static 1.2.1.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.1.1 (MichaelSnoyman)
13:02:47 <activeaspect> i am playing around with processing of infinite stream of events, receive events, transform events, collate them, and if enough events are received, do something with the transformed events. this seems very common in a general sense. is there a pattern that you would recommend for this? my naive attempt doesnt support removing the collated events from future evaluation after they are processed.
13:03:34 <jle`> hm computer automatically updated on me so i'l re-ask the question
13:03:41 <jle`> what is the established way to deal with indexable 2D vectors?
13:03:42 <levi> I mean, it's not the sort of book where you need to wait until you have the time to read the whole thing. See what's in it and refer to it in more depth when the need arises.
13:03:54 <jle`> i don't require a matrix with the linear algebra stuff...only a way to store 2D things.
13:03:59 <jle`> er, store things with 2D indices
13:04:07 <structuralist> how do you implement type-level sets in Haskell?
13:04:18 <jle`> ofc it'd just be a normal 1D array in memory, but abstractions to index with two coordinates would be nice.
13:04:20 <activeaspect> here is what i have so far: main = print . map Map.keys . map (hasVotes 1) . scanr aggregateReports Map.empty events -- where hasVotes and aggregateReports are defined to generate and act on Maps
13:04:25 <alkabetz> jle`: There was a recommendation for an array with indices isomorphic to '(,)', which seemed like the right way to go
13:04:53 <jle`> alkabetz: hm arrays can do that?
13:05:03 <jle`> that's fascinating
13:05:05 <quchen> jle`: Arrays are like Vector+Ix, but with bad API.
13:05:11 <alkabetz> jle`: Yeah, you can use arbitrary data for the indices, provided they have Ix instances
13:05:13 <quchen> So I would recommend using Vector+Ix.
13:05:23 <jle`> an Array (Int,Int) Double, for example?
13:05:49 <simpson> Arrays are useful when you intend for your containers to be fixed-size.
13:05:50 <jle`> quchen: what is vector+Ix? is that its own library?
13:06:19 <jle`> Vectors aren't designed for same-size usage?
13:06:25 <jle`> i guess they have slice etc. in their api
13:06:29 <quchen> Vector+Ix is Data.Vector + Data.Ix. Vector is for the storage, Ix is the typeclass (also used by Array) that takes care of the indices.
13:06:37 <alkabetz> jle`: No, they’re variable-length arrays
13:06:46 <m1dnight> Can I say that the type for <*>, as in Applicative ((->) r) is:  (a->a->a) -> (a->a) -> (a->a) ?
13:06:50 <levi> activeaspect: The streaming libraries like Pipes, Conduit, Iteratees, etc. are helpful for dealing with stateful infinite streams.
13:07:03 <alkabetz> quchen: How would that work?  Would you manually convert your index type to an 'Int' before indexing into your vector?
13:07:05 <quchen> jle`: Arrays don't have slicing at all, Vector do have slicing but only one-dimensional.
13:07:06 <mirpa> jle`: I was just thinking whether I can use Ix with Vector...
13:07:12 <quchen> alkabetz: Yes.
13:07:30 <alkabetz> quchen: I’m kind of surprised there’s not a convenience library for that yet.
13:07:37 <activeaspect> levi: thanks
13:07:40 <jle`> All of my arrays are fixed, it's basically for numerical computation
13:07:43 <alkabetz> quchen: That seems like a natural thing to want, given how unpleasant Array’s API is.
13:07:45 <quchen> alkabetz: Same here. I've been annoyed by this for days now.
13:07:46 <jle`> so do i even need vector?
13:08:06 <quchen> alkabetz: Seems like I may have a useful library to write after all now. If only my pet project was done ;-)
13:08:08 <skypers> isn’t there a flip . foldM function?
13:08:24 <quchen> skypers: I don't think so.
13:08:36 <quchen> :t flip . foldM
13:08:37 <lambdabot> Monad m => (a -> b -> m a) -> [b] -> a -> m a
13:08:48 <skypers> :t traverse
13:08:48 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:08:50 <alkabetz> jle`: If your sizes are fixed, you know them in advance, and you are sure you won’t have any missing entries in your array, then it might be reasonable.
13:08:55 <alkabetz> I think.
13:09:07 <skypers> I might need a better approach to my problem then
13:09:07 <alkabetz> quchen is right, though, Array has some unfortunate API warts
13:09:13 <jle`> what does vector even offer anyway? slicing/size changing API?
13:09:23 <jle`> why have people always told me that vector > array
13:09:32 <skypers> I have a list [a] and I want to traverse it, accumulating another list and a modified value on the fly
13:09:33 <alkabetz> jle`: Because the array API has warts.
13:09:36 <quchen> alkabetz: Well they're not really warts but just lack of functionality. It's almost only the bare minimum you need to have with some container.
13:09:40 <skypers> maybe a fold + StateT would make it through
13:10:04 <jle`> skypers: just use a tuple?
13:10:08 <alkabetz> quchen: Ah, fair enough.
13:10:11 <levi> activeaspect: Of that set of libraries, I've only really used Pipes, but it's reasonably nice to work with. I can't really give an opinion relative to the others yet, though.
13:10:26 <alkabetz> quchen: My primary complaint about Array has always been fun 'Prelude: undefined' errors when you forget to initialize correctly :/
13:10:29 <skypers> jle`: well, it might be not convenient to use?
13:10:43 <quchen> alkabetz: Oh, I haven't seen that yet. But using 'undefined' is *very* smelly.
13:10:49 <jle`> you want to produce both a list and a value, right?
13:10:55 <skypers> yeah but hm
13:11:00 <skypers> I want to mapM on the first list
13:11:07 <alkabetz> quchen: Yeah, IIRC boxed arrays get initialized to be full of 'undefined'
13:11:07 <skypers> but for each element of the first list
13:11:13 <skypers> I want to alter a value
13:11:18 <skypers> and return both at the end
13:11:22 <activeaspect> levi: how would this relate to using FRP libraries for the task? similar or would reactive banana be a super set of a streaming library?
13:11:25 <skypers> (the mapped list,the final monoid)
13:11:45 <jle`> is performance a concern
13:11:49 <levi> activeaspect: The general idea behind all of the streaming libraries is the creation of a set of coroutines that form a chain or pipeline, processing data a chunk at a time as it arrives and passing it along.
13:12:00 <skypers> I think of mapM + StateT would make it perfectly
13:12:05 <skypers> jle`: yes it is
13:12:59 <jle`> if you are only appending to a list you could use WriterT
13:13:31 <skypers> jle`: well
13:13:33 <skypers> actually
13:13:49 <skypers> it’s a list of Material I want to alter
13:13:54 <skypers> so mapM is perfect
13:14:16 <skypers> but, for each altered Material, I want to push them in the MaterialManager (the state)
13:14:48 <skypers> if I got a function like Material -> MaterialManager -> MaterialManager, a WriterT would make it a better way instead
13:14:59 <skypers> because it would make a pretty nice Monoid
13:15:48 <skypers> yeah I definitely need a StateT
13:16:02 <skypers> I need to read back the value of the state and so on
13:16:12 <activeaspect> aaaand im back
13:16:12 <jle`> mhm
13:19:17 <jrm2k6> Hi guys, how can i make the following correct? http://lpaste.net/95988
13:19:24 <jrm2k6> I defined my datatype
13:19:46 <jrm2k6> but it doesnt work when I want to create a list containing element of this datatype
13:20:43 <_justjust> can dataconstructors even have the names of existing types?
13:21:12 <tdammers> sure
13:21:29 <_justjust> crazy
13:21:46 <tdammers> there's one namespace for functions, constructors, and values
13:21:52 <tdammers> and one for types and type variables
13:21:58 <tdammers> data Foo = Bar
13:22:05 <tdammers> Foo is a type name, Bar is a constructor
13:22:21 <_justjust> crazy :)
13:22:24 <tdammers> however, it is common for data types to use the same names for both the type and the constructor
13:22:35 <_justjust> thx
13:22:40 <tdammers> but not required, and many types do not do this
13:22:41 <jrm2k6> if I have data Foo = Bar | Bir and I want to create a list containing some Bar and Bir, how can I do that?
13:22:59 <tdammers> let f = [ Bar, Bir, Bir, Bir, Bar ]
13:23:18 <jrm2k6> tdammers: in my case it doesnt work
13:23:26 <jrm2k6> http://lpaste.net/95988
13:23:49 <jrm2k6> but they are supposed to be Content type.
13:23:53 <stevely> jrm2k6: it looks like what you want is: data Content = String String | Num Int deriving (Show)
13:24:01 <jrm2k6> hm
13:24:19 <stevely> when you parameterize the type of Content, then the parameter has to be the same across all values when you put it in a list
13:24:46 <xrz> Hi, is there any way to add "--executables --haddock-hyperlink-source" options to cabal.config? I can only think of a sh script to do that.. Is there a better way?
13:24:49 <tdammers> in your paste, a is a type variable
13:25:09 <tdammers> and while it is variable, it has to be the same type for any given incarnation of the Content type
13:25:15 <jrm2k6> oh i see
13:25:24 <jrm2k6> thanks stevely and tdammers
13:25:27 <tdammers> so your list can be of type [ Content Int ], or [ Content String ]
13:25:36 <tdammers> but not [ Content (String-or-Int) ]
13:26:06 <jrm2k6> I m always confused about this. Thanks for the clarification
13:27:26 <skypers> hey, what’s the function to get the state back in State?
13:27:28 <skypers> get?
13:27:36 <skypers> :t get
13:27:37 <lambdabot> MonadState s m => m s
13:27:45 <tdammers> get for the whole state, gets to apply a projection function
13:27:47 <tdammers> :t gets
13:27:48 <lambdabot> MonadState s m => (s -> a) -> m a
13:27:58 <skypers> ok so
13:28:02 <skypers> if the state is a list
13:28:06 <skypers> a <- get
13:28:09 <skypers> a :: [a]
13:28:10 <skypers> right?
13:28:14 <tdammers> yes
13:28:25 <skypers> just… wonderful :)
13:28:26 <skypers> thank you
13:28:33 <tdammers> and if you do a <- gets head, then a :: a
13:28:36 <skypers> yeah I already used gets
13:28:40 <tdammers> ah, ok
13:28:47 <skypers> my state is a tuple
13:28:50 <skypers> then hm
13:28:58 <skypers> a <- gets snd
13:29:01 <tdammers> yes
13:29:03 <tdammers> that works
13:29:04 <skypers> seriously
13:29:12 <tdammers> sure, why not?
13:29:13 <skypers> Haskell is just future.
13:29:19 <skypers> :)
13:29:22 <tdammers> also, get = gets id
13:29:30 <skypers> yeah sure
13:29:34 <skypers> but hm
13:29:40 <skypers> I think it’s not implemented that way
13:29:46 <tdammers> no, of course not
13:29:53 <skypers> I’d say gets f = liftM f get
13:30:10 <tdammers> yeah
13:30:32 <tdammers> I'd write that as f <$> get, but that's because I'm deeply in love with <$>
13:30:54 <dv-> f `fmap` get
13:30:56 <simpson> Eventually, learn how to lens.
13:31:04 <simpson> :t _2 += 1
13:31:05 <lambdabot> (Num b, Field2 s s b b, MonadState s m) => m ()
13:31:14 <tdammers> lens, oh yeah
13:31:29 <skypers> simpson: yeah but hm
13:31:36 <skypers> I don’t really like them finally
13:31:39 <skypers> for a lot of reasons.
13:32:20 <simpson> You might have to have a lot of State experience before they seem reasonable, but they were kind of a magical thing when they finally clicked for me.
13:32:36 <skypers> the first one is that it makes a lisible code illisible and hard to follow; another would be I never actually _need_ them; still another it’s really HUGE
13:32:50 <skypers> yeah simpson!
13:32:55 <skypers> definitely
13:33:03 <skypers> I’m not enough experienced :)
13:33:17 <simpson> Well, yeah, it's a Control package, not a Data package. It helps you simplify and organize your code.
13:33:30 <skypers> simpson: I just disagree on that
13:33:57 <skypers> it definitely simplifies your code, but it make it quite hard to read
13:33:59 <simpson> Being able to think about game state is what really attracted me: `game . sprites . monsters . location . step += seconds`
13:34:25 <skypers> yeah in that case
13:34:32 <skypers> I’d have used them as well
13:34:42 <skypers> hm
13:35:11 <saparvia> \o/
13:35:12 <skypers> it’s always the same pattern for me you know simpson
13:35:18 <skypers> each time I see a wtf concept
13:35:26 <skypers> “Oh, I won’t ever need that”
13:35:29 <simpson> skypers: Sure.
13:35:30 <skypers> two months later
13:35:37 <skypers> “That concept just rocks!”
13:35:39 <skypers> :D
13:35:48 <simpson> I remember the first time I could justify using RWST. It was a magical moment.
13:36:06 <skypers> simpson: that moment occured like a month ago for me
13:36:08 <moofy> I have a question that's making me feel deeply foolish
13:36:16 <skypers> and it was “YEAAAAAAAHAHHH !!!!!”
13:36:18 <skypers> :D
13:36:29 <simpson> moofy: There are no stupid questions, just good opportunities for learning. :3
13:36:52 <skypers> yeah come on up
13:36:57 <moofy> Maybe is confusing me
13:37:06 <moofy> I get that it returns Nothing or Just x
13:37:15 <moofy> but why does it return Just
13:37:20 <moofy> why not x?
13:37:30 <skypers> because it’s a type moofy
13:37:39 <dv-> it needs a constructor
13:37:43 <simpson> moofy: You mean, why not `data Maybe a = Nothing | a` ?
13:37:47 <acowley> because if there isn't a data constructor on the value, we don't know the value is an element of the type
13:37:49 <simpson> Data types need to have constructors.
13:37:50 <FireFly> Maybe is a type that contains either nothing, or a single thing. It's a kind of container
13:37:51 <moofy> yeah
13:38:21 <skypers> moofy: yeah, Nothing as a type, and Nothing as another
13:38:29 <moofy> I've been trying to go through learn you a haskell
13:38:35 <FireFly> moofy: I find it easiest to think of Maybe as a very special kind of list/set that contains either no elements or exactly one element
13:38:35 <moofy> but that I just don't seem to get so far
13:38:38 <skypers> for instance, you can have Nothing :: Maybe Int and Nothing :: Maybe Char
13:39:08 <skypers> moofy: yeah actually you have to think of types as functions that create types
13:39:16 <acowley> ...
13:39:34 <moofy> so
13:39:35 <moofy> Just x
13:39:39 <skypers> Just _is_ a function that takes a value and returns a Maybe a
13:39:39 <moofy> is a bit like f x
13:39:45 <skypers> sure
13:39:45 <moofy> if f does something
13:40:05 <skypers> and such functions are called type constructors
13:40:06 <moofy> but why then is there no Just Nothing?
13:40:10 <skypers> that construct types
13:40:14 <acowley> I don't think that's a good suggestion. If you want to name types whose kinds have arrows in them, then they are most commonly referred to as "type constructors," but not all types are type constructors.
13:40:22 <Clint> :t Just Nothing
13:40:24 <lambdabot> Maybe (Maybe a)
13:40:28 <FireFly> moofy: there is a Just Nothing, but it's of type Maybe (Maybe a)
13:40:35 <FireFly> moofy: Just Nothing is a bit similar to [[]]
13:40:44 <moofy> huh
13:40:45 <skypers> you’re right acowley
13:40:46 <FireFly> (except for the Maybe type rather than the [] type)
13:40:49 <skypers> let’s sumup
13:41:21 <skypers> moofy: when you declare a type, you have to declare how to build it as well (don’t say type keyword folks)
13:41:24 <skypers> so
13:41:24 <skypers> when you right
13:41:41 <skypers> data Foo = MkFoo a, you declare both a type and a way to construct it
13:41:46 <skypers> Foo is the type
13:42:00 <moofy> right
13:42:14 <skypers> and MkFoo is the function that given a Int (not a `a`, it’s confusing), it gets you a Foo
13:42:24 <skypers> @let data Foo = MkFoo Int
13:42:26 <lambdabot>  Defined.
13:42:43 <zomg> Foo is the class and MkFoo is the constructor!
13:42:44 <moofy> okay
13:42:47 <zomg> Confusion! \o/
13:42:48 <skypers> @unlet
13:42:49 <lambdabot>  Define what?
13:42:54 <skypers> ahah
13:43:12 <skypers> @let data Bar = MkBar Int deriving (Eq,Show)
13:43:13 <lambdabot>  Defined.
13:43:36 <skypers> ok so
13:43:36 <skypers> MkBar 4
13:43:38 <skypers> it will construct a Bar
13:43:40 <skypers> > MkBar 4
13:43:43 <lambdabot>   MkBar 4
13:44:08 <simpson> :t MkBar 4
13:44:08 <skypers> :t MkBar 4
13:44:08 <skypers> come on!
13:44:09 <lambdabot> Bar
13:44:09 <lambdabot> Bar
13:44:16 <skypers> so moofy
13:44:21 <simpson> zomg: Note that Foo, here, is a *type*, not a "class".
13:44:22 <skypers> Maybe is the same thing
13:44:22 <moofy> with you so far i think
13:44:56 <skypers> but it has two constructors
13:45:18 <skypers> @data Zoo = MkZoo Int | MkOtherZoo Float deriving (Eq,Show)
13:45:18 <lambdabot> Unknown command, try @list
13:45:26 <skypers> @let data Zoo = MkZoo Int | MkOtherZoo Float deriving (Eq,Show)
13:45:27 <lambdabot>  Defined.
13:45:40 <skypers> :t MkZoo 314
13:45:41 <lambdabot> Zoo
13:45:49 <skypers> :t MkOtherZoo 6.0
13:45:50 <lambdabot> Zoo
13:46:09 <skypers> you can of course write type constructors with no parameter
13:46:11 <skypers> and then
13:46:18 <skypers> let’s talk about Maybe :
13:46:29 <zomg> simpson: but does it inherit from System.Object?
13:46:46 <skypers> @let data Maybe' a = Nothing' | Just'  a deriving (Eq,Show)
13:46:47 <lambdabot>  Defined.
13:47:02 <skypers> you can construct a Maybe' Int with two constructors
13:47:03 <simpson> zomg: What package is that in?
13:47:07 <skypers> Nothing'
13:47:14 <zomg> simpson: java.lang I think
13:47:19 <skypers> and Just' x where x :: Int
13:47:25 <simpson> zomg: Ah. You're not thinking of Haskell, then.
13:47:27 <moofy> but isn't nothing here lacking something?
13:47:33 <zomg> simpson: good you're catching on ;)
13:47:33 <skypers> nope
13:47:38 <moofy> whi isn't it Nothing null or something
13:47:39 <skypers> it’s a function
13:47:44 <skypers> that takes nothing
13:47:54 <tulloch> Is there an idiomatic Haskell way to structure code that is mutating a graph?
13:47:56 <skypers> and creates a Maybe' a
13:48:21 <skypers> moofy: because type constructors are regular functions
13:48:26 <tulloch> e.g. message passing in Bayesian networks
13:48:32 <skypers> they can have as many parameters as needed
13:48:52 <skypers> they’re actually more than regular functions
13:49:05 <skypers> (you can pattern match them, but you’ll see that later)
13:49:21 <skypers> > Just 4
13:49:22 <lambdabot>   Just 4
13:49:25 <moofy> i still don't really get what this gives you
13:49:26 <skypers> :t Just 4
13:49:27 <lambdabot> Num a => Maybe a
13:49:29 <moofy> or why it's useful
13:49:34 <skypers> :t Nothing
13:49:35 <lambdabot> Maybe a
13:49:56 <skypers> moofy: imagine a function that takes a list and returns its first element
13:50:00 <moofy> right
13:50:05 <skypers> if the list is empty, what would you return?
13:50:16 <moofy> an empty list?
13:50:19 <quchen> moofy: Every time you return (-1) in other languages, that should be a Nothing. For example "lookup index i in a vector" in C. C doesn't have Maybe. C has to return a silly (-1) if it's out of bounds.
13:50:27 <skypers> you can’t, it wouldn’t type match
13:50:32 <moofy> ah
13:50:40 <skypers> let’s do it moofy
13:50:55 <jrm2k6> If I am doing pattern matching on a list,how can i detect that I am processing the first element (first iteration)
13:51:11 <skypers> x:xs, jrm2k6
13:51:29 <skypers> moofy: such a function would be [a] -> a
13:51:31 <skypers> if the list is empty
13:51:37 <moofy> got you
13:51:42 <skypers> you need to return a value that say “hey it’s empty”
13:51:46 <skypers> you can’t return -1
13:51:54 <skypers> it’s obvious
13:52:13 <FireFly> skypers: you can't return a value that says "hey it's empty" though, since `a` could be any type
13:52:17 <skypers> in C, you would have maybe write a function that returns a pointer on the first element, and NULL if no element
13:52:27 <jrm2k6> skypers: it is not what I mean, lets say i have [2,3,4] I wanna do something specific for the head of the initial list (2) but not for the others
13:52:27 <skypers> so the idea is Haskell here
13:52:30 <valdyn> jrm2k6: you use a 2nd function f' where f does whatever special you want to do for the 1st element
13:52:38 <skypers> is not returning a, but Maybe a
13:52:44 <skypers> because it might be Nothing
13:52:51 <moofy> so that it could be a or it could be an absence of a
13:53:01 <moofy> to fit in with the need for it to return an a
13:53:07 <jrm2k6> valdyn: i dont see how it resolves my issue.
13:53:14 <skypers> 22:38 < moofy> so that it could be a or it could be an absence of a
13:53:16 <skypers> exactly.
13:53:38 <moofy> that explains nothing
13:53:39 <skypers> it could be just a, or nothing because the list is empty
13:53:55 <moofy> but i don't see why that explains the need for a just
13:54:02 <moofy> couldn't it either return a nothing
13:54:04 <FireFly> moofy: anyway, the reason you use  Just x  rather than  x  is because the former is of type  Maybe a  whereas the latter is of just type  a , so you have a type mismatch
13:54:07 <moofy> or return a list with something in it?
13:54:27 <moofy> ah
13:54:32 <skypers> moofy: because of Haskell strong type
13:54:32 <moofy> so it's to agree with types there too
13:54:33 <skypers> in PHP
13:54:34 <skypers> yes
13:54:36 <skypers> it’s possible
13:54:38 <skypers> not in Haskell
13:54:44 <skypers> yes moofy
13:54:49 <FireFly> No, they're different types! something of type  Maybe a  has to be either  Nothing or  Just x  for some x that is of type a. that's how it's defined
13:55:06 <FireFly> s/No/Yes/ I suppose. /me writes too slow
13:55:22 <moofy> but you can then change the type of just a into an a to do something concrete with it?
13:55:32 <skypers> yes
13:55:32 <valdyn> jrm2k6: f (x:xs) = (special x):(f' xs)
13:55:36 <dv-> :t fromJust
13:55:36 <lambdabot> Maybe a -> a
13:55:39 <skypers> you have to learn a bit more
13:55:42 <skypers> dv-: oh!
13:55:46 <skypers> forget about that moofy
13:55:52 <moofy> heh
13:55:53 <skypers> fromJust is not what you want
13:55:55 <jrm2k6> oh valdyn, got it
13:56:05 <FireFly> :t maybe
13:56:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:56:13 <skypers> yeah, maybe is a way
13:56:19 <jrm2k6> how is it different than having an Int that i pass around?
13:56:23 <skypers> but the first and favourite one is pattern matching
13:56:28 <dv-> :t catMaybes
13:56:28 <FireFly> moofy: you could use pattern-matching, but you want to cover the case if it's Nothing too
13:56:29 <lambdabot> [Maybe a] -> [a]
13:56:34 <dv-> that one's a bit better maybe
13:56:49 <FireFly> moofy: in which case you can't turn it into a "plain" `a` since you don't have anything of type `a` to begin with
13:57:03 <moofy> right
13:57:04 <valdyn> jrm2k6: its not different in functionality, it just adds another parameter that you need to carry around
13:57:10 <jrm2k6> Yes
13:57:11 <skypers> moofy: as I said earlier, type constructors (ctor) are not really regular functions
13:57:14 <jrm2k6> True.
13:57:16 <moofy> so say i want to find out if an element exists in a list
13:57:19 <skypers> you can pattern match them
13:57:27 <moofy> i could check for either nothing or maybe a
13:57:31 <FireFly> moofy: (what `maybe` does is it takes a default value, and uses the default value in case the  Maybe a  is  Nothing)
13:57:42 <moofy> oh
13:57:43 <skypers> so there’s a keyword in Haskell that lets you know whether a Maybe a is Just x or Nothing
13:57:51 <moofy> okay that makes MUCH more sense
13:58:02 <skypers> and it’s very convenient to use :)
13:58:07 <moofy> so i could use maybe to see if a value is there
13:58:17 <moofy> and either return a value or a default?
13:58:22 <skypers> yes
13:58:23 <FireFly> Yup, basically
13:58:27 <skypers> it’s the maybe function
13:58:40 <skypers> but please, first learn pattern matching! :)
13:58:43 <moofy> sorry, I don't know why i'm being so slow to actually parse this
13:58:53 <FireFly> > maybe "nope" show Nothing
13:58:54 <lambdabot>   "nope"
13:58:59 <FireFly> > maybe "nope" show (Just 1)
13:59:01 <lambdabot>   "1"
13:59:22 <dv-> > fromMaybe 0 Nothing
13:59:23 <lambdabot>   0
13:59:29 <FireFly> (in this case  show :: Int -> String  to simplify a bit)
13:59:38 <moofy> yeah got you
14:00:07 <skypers> moofy: http://lpaste.net/8938899172971511808
14:00:11 <skypers> it’s the general idea
14:00:39 <skypers> you’ll use maybe, fromMaybe and all the other functions for convenient use later
14:00:45 <skypers> but you have to understand pattern matching first
14:00:52 <skypers> it’s really important
14:01:40 <skypers> and that’s why I think it’s interesting to see types values (objects?) as functions
14:01:52 <skypers> for a simple way of thinking I mean
14:02:03 <brandon`> hello
14:02:10 <brandon`> how to resolve this?
14:02:28 <skypers> btw dv-, fromJust might raise exceptions
14:02:42 <brandon`>     Ambiguous module name `Control.Monad.State': it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2 Failed, modules loaded: none.
14:02:43 <skypers> I think it’s not a good way to start :D
14:02:52 <dv-> pft, it gets the job done
14:03:24 <skypers> it’s a function to avoid imho
14:03:26 <quchen> fromJust is almost certainly a code smell.
14:03:35 <valdyn> brandon`: use "import qualified"
14:03:38 <skypers> a code smell?
14:03:43 <skypers> what do you mean?
14:03:51 <acowley> import qualified isn't the issue
14:04:02 <geekosaur> ^
14:04:22 <quchen> skypers: You don't want your code to smell, therefore you should avoid smelly things. Like 'head' and 'fromJust' etc.
14:04:23 <acowley> brandon`: You can use PackageImports, a cabal file, or uninstall monads-tf
14:04:37 <skypers> btw moofy, learn you a haskell is a _really_ good reference to begin with haskell :) so hang on! and don’t hesitate to ask your questions here :)
14:04:44 <acowley> s/smelly things/partial functions
14:04:48 <brandon`> acowley I did not install it so I am guessing some module I installed uses it
14:04:48 <skypers> quchen: ooooh
14:04:48 <dv-> you use them when you know they can't fail
14:04:51 <moofy> it's just a bit overwhelming
14:04:56 <skypers> someone who thinks like me!
14:04:59 <quchen> There are other code smells that aren't about partial functions.
14:05:02 <moofy> and lots of
14:05:06 <quchen> Therefore no s/blabla.
14:05:08 <moofy> this is this, then this which means that
14:05:08 <brandon`> is there a way to check module dependencies?
14:05:16 <skypers> moofy: you know, even after one year of Haskell
14:05:18 <moofy> and one unclear step scuppers the lot
14:05:21 <brandon`> like "what  modules depend on monads-tf"
14:05:28 <skypers> I still find things overwhelming at some point :D
14:05:45 <skypers> (Control.Lens for instance)
14:05:46 <moofy> I'm still dreading the idea of monads
14:05:48 <brandon`> also I am having this issue in ghci, with cabal i can decide what module to use
14:06:00 <geekosaur> easiest way is to try to unregister it and see what it complains about
14:06:11 <geekosaur> also, easiest workaround is `ghc-pkg hide monads-tf`
14:06:25 <brandon`> and I can show it later if there are problems?
14:06:29 <skypers> yeah monads will become clear in… a long time, and a lot of practrises and self-thinking :D
14:06:29 <acowley> quchen: I was trying to make "avoid smelly things" more precise. There was no implication of totality in smellyness vis-a-vis partiality!
14:06:30 <geekosaur> yes
14:06:34 <brandon`> cool
14:06:53 <quchen> moofy: The only thing scary about Monad is people repeating that Monad is scary.
14:07:03 <skypers> yeah
14:07:08 <skypers> that’s quite true actually :D
14:07:11 <moofy> well everything i've read and heard from other people seem to suggest the concept is a total mindfuck
14:07:15 <quchen> moofy: See your example. You don't know Monad so you can't be scared of it.
14:07:20 <moofy> I have no real reason to think otherwise
14:07:24 <skypers> moofy: it’s too generalized actually
14:07:28 <mirpa> monads are awsome =)
14:07:45 <moofy> hell, I've got flack for even showing interest in haskell
14:08:00 <skypers> monads are just _simple_ when you understand their laws
14:08:01 <brandon`> did you just use monads-tf as example? or you meant that mtl more popular than monads-tf
14:08:01 <quchen> I found monads useless and weird, but not difficult. (My recommendation: don't read about monads in PHP blogs.)
14:08:11 <skypers> I had really hard times to get into profonctors… :(
14:08:33 <moofy> Might not help I don't come from a computer science background
14:08:41 <skypers> no
14:08:45 <skypers> I think it’ll help
14:08:50 <skypers> I was coming from C++
14:08:51 <hpc> read about monads from javascript blogs!
14:08:53 <skypers> it was horrible.
14:08:54 <geekosaur> type families are still somewhat experimental and still changing
14:09:01 <skypers> I had to rethink about everything
14:09:24 <quchen> skypers: First understand contravariant Functor. A contravariant Functor is like Functor, but the mapping is "backwards": fmap' :: (a -> b) -> f b -> f a
14:09:33 <geekosaur> most production code uses mtl, but there are some areas where type families are better (especially with recent closed type family stuff)
14:09:36 <skypers> quchen: I know that
14:09:46 <skypers> I also know bifunctors
14:09:50 <quchen> So you've got something where you can map forwards and backwards.
14:09:52 <moofy> it's *me* who doesn't get it, not skypers :p
14:09:53 <skypers> and profonctors as well
14:10:11 <skypers> edward kmett helped me A LOT a few days ago about that :)
14:10:27 <quchen> He has a habit of doing that, yes. :-)
14:10:29 <moofy> I wish i had a university where I could bug people for advice :/
14:10:35 <brandon`> those two packages have same author, and identical functionality. what is going on :)
14:10:54 <skypers> quchen: it’s just pure hilarity when I discovered the type of contramap ;)
14:10:55 <quchen> moofy: I have a university and when I start talking about types and functional languages I get crazy looks.
14:11:02 <skypers> (the name you were looking for your fmap')
14:11:06 <moofy> Heh
14:11:10 <quchen> It's not the dream world you imagine at universities ;-)
14:11:13 <skypers> 22:57 < quchen> moofy: I have a university and when I start talking about types and functional languages I get crazy looks.
14:11:16 <skypers> same here
14:11:20 <skypers> you can bug people here moofy
14:11:20 <moofy> I went to art school, most people there didn't even know what HTML was
14:11:26 <skypers> :D
14:11:35 <skypers> I’d love not to know what it is actually
14:11:52 <quchen> Well of all the programming languages, HTML is one of the lesser interesting ones. It has one statement: print, which is implicit. ;-)
14:12:11 <moofy> my background is in charcoal renderings, rather than group theory
14:12:15 <quchen> Makes writing a compiler easier though. compileHtml = id
14:12:48 <Taneb> moofy, group theory is probably applicable to charcoal renderings!
14:12:52 <moofy> Heh
14:13:02 <skypers> group theory?
14:13:04 <quchen> Taneb: That's a long shot :-)
14:13:10 <moofy> Possibly. I'd like to see your reasoning there though.
14:13:12 <skypers> you mean category theory don’t you?
14:13:19 <moofy> ahh
14:13:20 <moofy> see
14:13:27 <Taneb> skypers, group theory and category theory are quite closely related
14:13:29 <FireFly> skypers: no, groups is another kind of thing
14:13:34 <moofy> told you I never studied this :p
14:13:40 <skypers> well goups as hm
14:13:46 <skypers> abelian groups?
14:13:47 <skypers> and so on?
14:13:59 <FireFly> A group is basically a monoid where every element has an inverse
14:14:05 <skypers> yeah
14:14:07 <FireFly> And you're probably familiar with Monoid :p
14:14:09 <Taneb> FireFly, a group is exactly that
14:14:10 <skypers> I know what it is
14:14:10 <moofy> I got to a hazy level of algebra at school and ended up teaching myself bits when I needed it to code
14:14:13 <skypers> but hm
14:14:14 <quchen> moofy: Just in case it comes over like it: you need nothing of this to program in Haskell.
14:14:22 <skypers> group theory?
14:14:36 <quchen> Category theory, group theory, type theory, all those things.
14:14:40 <FireFly> Taneb: I'd hope so. I'm supposed to have a kind of test on them tomorrow
14:14:42 <skypers> 23:00 < FireFly> A group is basically a monoid where every element has an inverse
14:14:45 <skypers> hmmm
14:15:00 <skypers> I think there’s another thing
14:15:04 <FireFly> skypers: not to be confused with group therapy
14:15:04 <moofy> hmm, i've heard of monoids too
14:15:08 <skypers> like transitivity
14:15:18 <FireFly> associativity?
14:15:24 <skypers> it’s implicit
14:15:27 <FireFly> But that applies to monoids too :D
14:15:28 <skypers> because a group is a monoid
14:15:30 <skypers> yeah
14:15:48 <skypers> well actually
14:15:58 <jle`> are ther any libraries already out there that integrate Vector and Ix?
14:15:59 <skypers> associativity comes from semigroup I think
14:16:01 <frx> MultiWayIf is cute
14:16:03 <Taneb> A group is just a monoid with an inverse function such that x <> x^-1 = x^-1 <> x = mempty
14:16:04 <quchen> jle`: Nope.
14:16:16 <moofy> One thing I liked about art school was the idea that a tutor told me
14:16:28 <skypers> ok so a group with an associative inner law is just… an associative group?
14:16:31 <moofy> 'you're not stupid, this stuff is hard and everyone finds it hard'
14:16:36 <quchen> frx: And in 7.8 it's even better, you can nest it! (In 7.6 nesting MultiWayIf is broken.)
14:16:51 <moofy> it's too easy to get despondant about this stuff
14:16:52 <Taneb> skypers, all groups are associative?
14:16:57 <skypers> no
14:16:58 <FireFly> moofy: that's a good mindset
14:17:12 <skypers> well huh
14:17:15 <skypers> yes actually
14:17:19 <moofy> I spent years trying to draw well
14:17:22 <quchen> A group with an associative law is called a group.
14:17:34 <moofy> and it's *still* hard to do a good portrait
14:17:41 <FireFly> existence of identity, closure, associativity, existence of inverse for each element
14:17:41 <skypers> the associativity comes from the semigroup category
14:17:46 <skypers> a magma is not.
14:17:53 <FireFly> a magma is hot. (sorry)
14:17:55 <skypers> (set + inner law)
14:17:57 <moofy> so it's not like haskell would be any different in that regard
14:17:58 <skypers> ahah :D
14:18:31 <skypers> and hm, it’s quite funny to see that the (<>) is in the Semigroup class :)
14:18:52 <skypers> yeah moofy
14:18:58 <skypers> Haskell is quite the same thing
14:19:11 <skypers> you’ll learn slowly but surely
14:19:14 <skypers> get strong skills
14:19:15 <skypers> and then
14:19:19 <skypers> a guy will come
14:19:19 <jle`> is there an easy way to zip an array without constructing a list, which defeats the whole purpose of using an array in the first place
14:19:25 <jle`> *zip two arrays
14:19:28 <skypers> “hey I use profunctors everywhere!”
14:19:29 <moofy> and take me away to the loony bin?
14:19:35 <bz> tonight's the night
14:19:36 <skypers> and you’ll just think “dafuck?!”
14:19:37 <skypers> :D
14:19:38 <Kaidelong> @remember quchen A group with an associative law is called a group.
14:19:38 <lambdabot> I will never forget.
14:19:39 <quchen> jle`: No. Use Vector.
14:19:47 <bz> tonight i shall understand monad transformers
14:19:56 <brandon`> can one use -interactive-print to pretty-print functions?
14:19:57 <jle`> :'(
14:20:04 <quchen> Kaidelong: ;-)
14:20:08 <Peaker> jle`: you want to get an array of tuples?  That's probably suboptimal, compared to just a pair of arrays treated as if it were zipped
14:20:18 <jle`> i meant zipWith
14:20:23 <jle`> sorry
14:20:39 <Taneb> I think learning is a process of turning the un-understandable into the obvious
14:21:04 <Peaker> jle`: http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Generic.html#v:zipWith
14:21:13 <moofy> Some manage it better than others though
14:21:20 <Peaker> http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector.html#v:zipWith is a better link
14:21:27 <moofy> the number of tutorials i've been through that were just horrible is huge
14:21:54 <jle`> Peaker: been trying to use Arrays in order to circumvent having to implement my own Vector/Ix integration
14:22:20 <Peaker> jle`: I thought arrays were mostly old-style/superceded by vectors..
14:22:43 <acowley> they are
14:22:48 <jle`> yes but you can only index on integers in vectors
14:22:55 <jle`> i want to index on tuples :'(
14:22:58 <acowley> but Array's fancy indexing didn't make it across
14:23:07 <jle`> i am probably just being uneedily stubborn
14:23:09 <acowley> jle`: Can you write your own indexing function?
14:23:16 <jle`> unnecessarily?
14:23:29 <Peaker> jle`: repa does multidimensional vectors, I think?
14:23:29 <jle`> acowley: yes i can, but my motivation for arrays is that i wouldn't have to
14:23:44 <acowley> jle`: This is one short line of code, though, isn't it?
14:23:52 <simpson> Also Vectors are not fixed-size, AFAICT?
14:24:14 <quchen> They are
14:24:15 <acowley> Vectors from the vector package are not fixed-size, but there are various fixed-size vectors out there
14:24:20 <jle`> Peaker: oh yes.  i guess I didn't consider repa because i did not think about parallelizing, but repa is also a good general purpose array library isn't it.
14:24:26 <quchen> acowley: They aren't??
14:24:26 <acowley> I guess this depends what you mean by fixed-size
14:24:31 <Peaker> jle`: AFAIK
14:24:33 <acowley> They're not statically sized
14:24:34 <simpson> So is there anything *wrong* with Array? They seem quite serviceable to me.
14:24:46 <simpson> acowley: I do mean statically-sized, I suppose.
14:24:49 <jle`> acowley: it's a short line but i am always averse to writing 'general'/library functions in my scripts/code. i feel like they don't belong.
14:24:49 <quchen> acowley: Oh, the size does not appear in the type, no.
14:24:50 <carter> acowley: hello!
14:24:52 <acowley> simpson: I thought so
14:24:56 <acowley> hey carter!
14:25:00 <carter> jle`: i'm working on index tuppling
14:25:01 <Peaker> simpson: I think ecosystem fragmentation is bad... If Vector can handle array's use-cases and more, let's dump array to have a smaller more focused ecosystem
14:25:04 <Peaker> (around arrays)
14:25:24 <acowley> simpson: I have a goofy little statically sized Storable vector module I use for some things, but I think there are a few on hackage
14:25:33 <skypers> got to go
14:25:39 <skypers> bye
14:25:41 <carter> acowley: i'm not going to hiearchical layouts in my first Numerical release
14:25:43 <skypers> good night
14:25:44 <carter> BLAH
14:25:48 <carter> i just made that decision
14:25:52 <simpson> Peaker: Well, I don't think that it can handle this use-case, and it sounds like Vectors don't directly support Ix-based indexing either.
14:25:54 <jle`> carter: really? is it similar to sized-vector
14:25:55 <carter> theres some subtle trickybits
14:25:59 <carter> jle`: no
14:26:02 <carter> layouts
14:26:04 <carter> row major
14:26:05 <Peaker> simpson: I don't think Ix is a good idea...
14:26:06 <carter> column major
14:26:07 <acowley> carter: Anything that simplifies things sounds good to me
14:26:08 <carter> ix is wrong
14:26:10 <carter> yes
14:26:31 <carter> Ix doesn't let you have more than one layout per array rank
14:26:54 <jle`> interesting
14:26:59 <acowley> Ix is programmer-friendly after it starts out seeming programmer-unfriendly.... and then it maybe gets unfriendly again after you lose a bit of perf :/
14:27:26 <carter> just having row and col major both == huge
14:27:28 <henk> hi, how do I tell whether a type is a functor? (does that question even make sense?)
14:27:48 <jle`> henk: you can use :info in ghci
14:27:54 <hpc> Ix is also inclusive of the tail end, so an array of (0, 10) has 11 elements
14:28:11 <quchen> henk: Call ":i Functor" in GHCi. If your type is in scope and a Functor, it will be listed.
14:28:15 <Peaker> hpc: yeah, I hate that
14:28:20 <carter> vs what?
14:28:30 <carter>  0 … 10 is 11 things
14:28:31 <henk> ok, thanks
14:28:39 <jle`> it similar to how Arrays define normal ranges, anyways, though
14:28:39 <Peaker> carter: the Dijkstra convention, [0..10)
14:28:45 <hpc> i am /this/ close to newtyping Ix
14:28:47 <carter> oh
14:28:50 <jle`> you make an array with (0..10) to have indices 0 through 10
14:28:52 <carter> i thought you meant [0… 10]
14:28:56 <hpc> *newtyping Ix's instances
14:29:06 <Peaker> carter: the 0-sized range becomes something ugly like (0,-1) with Ix :(
14:29:23 <carter> so i'm best off not remembeing iX :0
14:29:36 <carter> i remember looking at it and thinking "whats this crap"
14:29:37 <carter> :P
14:29:37 <Peaker> And Dijkstra's zero-based, inclusive/exclusive range essay is convincing
14:29:44 <carter> vs what?
14:30:08 <jle`> vs one-indexing, and inclusive/inclusive, i presume
14:30:08 <Peaker> vs one-based and inclusive/inclusive or exclusive/exclusive
14:30:15 <Peaker> (or exclusive/inclusive)
14:30:25 <carter> i don't care as long as i can write my math
14:30:29 <carter> soooo
14:30:32 <simpson> At any rate, I'd much rather have a 16x16x16 container indexed with (x,y,z) instead of (x * 256 + y * 16 + z).
14:30:41 <carter> simpson: i have some code for that
14:30:44 <carter> will be public soon
14:30:45 <oio_> any image inversion libraries?
14:30:50 <oio_> conversion?
14:30:52 <simpson> carter: Is it...Ix? >:3
14:30:52 <Peaker> carter: IME the math tends to be simpler and less off-by-one'y with the Dijkstra conventions
14:30:55 <carter> not ix
14:31:08 <carter> 0 based and what
14:31:17 <carter> what doe the intervals specs mean for the api?
14:31:22 <Peaker> simpson: use a multidimensional repa for that? Or a vector of vector of vector?
14:31:29 <carter> repa is a good stop gap
14:31:50 <simpson> Peaker: TBH Array works *really well* for me here. I've got the ix lens and all.
14:31:50 <jle`> i've never had to many problems in matlab with there 1-index inc/inc though, either
14:32:03 <jle`> *their
14:32:06 <jle`> how embarassing
14:32:08 <carter> Peaker: i don't understand the point about open vs closed stuff
14:32:16 <carter> its just one convention or another
14:32:28 <carter> as long as its consistent and clear, doesn't matter
14:32:39 <Peaker> carter: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html explains why not
14:32:40 <jle`> carter: the main argument is that in one, the number of elements is the difference, and in one, the number of elements is the difference+1
14:33:19 <carter> yes
14:33:22 <carter> I understand the zero indexed bit
14:33:30 <Peaker> carter: it explains the inclusive/exclusive bit too
14:33:32 <carter> i mean the other point
14:33:37 <carter> where would this happen in the api
14:33:43 <carter> no in how i write for loops
14:34:00 <carter> i need a concrete example because currently i don't understand why i'm typing this question
14:34:20 <carter> i really don't care about peoples style perfs for how to write for loops
14:34:24 <carter> *prefs
14:34:28 <carter> as long as its consistent
14:34:32 <jle`> honestly though i have never found 1-based inclusive indexing any less intuitive
14:34:33 <chrisdone> @choose sushi gnocchi pasty
14:34:33 <lambdabot> gnocchi
14:34:50 <jle`> see: matlab
14:35:00 <carter> matlab is crap
14:35:01 <Peaker> carter: [x..y] ++ [y..z] is nicer than [x..y-1] ++ [y..z].   Also nicer that: length [x..y] == y-x   rather than y+1-x
14:35:04 <hpc> 1-based inclusive is only really more useful when you have to display the index
14:35:13 <carter> ok
14:35:18 <carter> sooo, doesn't matter for arrays
14:35:19 <carter> :)
14:35:19 <hpc> and even then i try and use a (Map Int a) instead
14:35:35 <Peaker> carter: array slices have the exact same argument
14:35:53 <carter> in vector the slice syntax is "starting position and length"
14:35:56 <carter> not start and end
14:36:25 <Peaker> ah, ok. well it's much more similar to [x,y) than it is to [x,y] so I'm happy :)
14:36:40 <carter> yeah
14:36:48 <carter> agree that base + length is a good api style
14:36:55 <carter> less "fragile"
14:36:57 <jle`> does Repa have mutable arrays?
14:37:01 <carter> sortah
14:37:04 <Peaker> making illegal states (negative lengths) unrepresentable
14:37:10 <carter> jle`: but fusion is the point of repa
14:37:12 <Peaker> (at least if the length is a Word)
14:37:15 <carter> so try writing it functionally
14:37:33 <carter> Peaker: doing indexing off the tail can be nice
14:37:47 <acowley> Peaker: But this is programming, so it's probably an int
14:37:50 <Peaker> carter: well, we can't recommend repa/vector to replace Array and then recommend avoiding mutable side altogether :)  even without fusion, repa/vector should probably supercede other array libs
14:38:02 <Peaker> (even for low-level imperative algorithms)
14:38:04 <Rylee> I sure do wish "A monad is just a monoid in the category of endofunctors, what's the problem?" was in the topic
14:38:12 <Peaker> acowley: :(
14:38:14 <carter> Peaker: i'll have an imperative api thats decen
14:38:19 <carter> yeah
14:38:43 <Peaker> acowley: in a structural editor, the overhead of having a Word there is negligible (the IDE throws in a "fromIntegral" as needed when choosing an int value there) *ducks*
14:38:44 <carter> i have some ideas to make indexing types decoupled from Ints / words
14:38:46 <carter> in the underlying api
14:38:52 <acowley> haha
14:38:53 <carter> "AddresDiff"
14:39:10 <jle`> i wonder if i can change things to take advantage of fusion.
14:39:15 <jle`> i guess everything is a combination of maps and zips
14:39:19 <carter> SPJ is open to it, SimonM is "the compiler should be able to figure it out"
14:39:25 <jle`> oh, i have scans.
14:39:32 <carter> jle`: if thats the case, trying to port it repa is a good exercise
14:39:36 <jle`> can scans be fused?
14:39:57 <Kaidelong> @src mapAccum
14:39:57 <lambdabot> Source not found. Are you on drugs?
14:40:00 <Peaker> I've never seen Marlow's name written that way. It looks like Control.Monad.SimonM
14:40:15 <carter> jle`: probably
14:40:17 <chrisdone> SimonM_ when he's at facebook
14:40:19 <carter> look at the repa/ accerlate apis
14:40:20 <ReinH> I wish my brain operated inside a Somin Marlow monad
14:40:24 <chrisdone> ohhhh, no he didn't
14:40:27 <Peaker> chrisdone: haha :)
14:40:28 <acowley> buuurrrrnnnn
14:40:38 <ReinH> chrisdone: I see what you did there but actually he's still going to be releasing open source stuff :p
14:40:40 <carter> i don't even understand this meming
14:40:54 <chrisdone> ReinH: i'd know that if i'd heard a haskellcast about it =p
14:41:13 <carter> he's def pushed patches to GHC ins recent time
14:41:17 <ReinH> chrisdone: let's just say I have an authoritative source
14:41:25 <jle`> carter: don't see a scan.  hm.
14:41:30 <carter> :t scan
14:41:31 <lambdabot>     Not in scope: `scan'
14:41:31 <lambdabot>     Perhaps you meant one of these:
14:41:31 <lambdabot>       `scanl' (imported from Data.List),
14:41:34 <carter> :t scanl
14:41:35 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
14:41:53 <carter> i'm quite certain you can write one
14:41:59 <carter> jle`: a scan isn't very parallel though
14:42:18 <jle`> http://stackoverflow.com/questions/6300428/poor-performance-with-transpose-and-cumulative-sum-in-repa/6340867#6340867
14:42:47 <maurer> carter: An associative scan can be parallelized!
14:42:54 <carter> truuue
14:43:18 <carter> repa head may give better perf therer
14:43:32 <maurer> carter: If you want to try that, look up parallel prefix sum
14:43:36 <jle`> my scan is just a cumulative sum. that's associative, right?
14:43:42 <maurer> jle`: Yes
14:43:46 <acowley> In mathematics or on computers?
14:43:56 <maurer> jle`: http://en.wikipedia.org/wiki/Prefix_sum
14:44:32 * chrisdone bops to https://www.youtube.com/watch?v=BdHK_r9RXTc&t=2m28s
14:44:42 <acowley> I spent a day debugging a difference between a serial and a parallel summation not that long ago
14:44:48 <carter> urk
14:45:01 <carter> float or double
14:45:08 <acowley> Yes, one resulted in an answer, the other left me a singular matrix
14:45:28 <acowley> carter: single precision, and on a GPU so probably 19.7 bits
14:45:29 <carter> urk
14:45:55 <carter> serial has betterr stability?
14:46:13 <acowley> I judge not better or worse, that they were different is what tripped me up
14:47:10 <carter> basically depending on how the data is permuted, one could be better than the tohers?
14:47:12 <jle`> i'm going to try my stuff with Array for now, in order to test that my algorithm even works.  I can probably analyze it and see how well it fuses later.
14:47:37 <carter> acowley: could you do compensated summation?
14:48:04 <jle`> or maybe i can just use Accelerate.
14:48:19 <acowley> carter: Probably, but instead I switched linear system solvers from Cholesky to LU, everything worked with both summations, and I called it a day :/
14:48:27 <carter> cool
14:49:31 <ReinH> carter: I thought there was a pearl on this! http://www.iai.uni-bonn.de/~jv/popl202-voigtlaender.pdf
14:51:06 <ReinH> Aaaand now it's in my queue
14:53:45 <carter> hehe
14:53:49 <carter> parametricity
14:54:58 <monochrom> parametricity is good
14:55:16 <tac> Is there a nice, formal statement of parametricity?
14:55:36 <tac> All I really know about it is that parametricity means "no typecase operator"
14:55:57 <carter> look for "free theoremes"
14:56:12 <hpc> carter: free theorems are defined in terms of parametricity
14:56:14 <monochrom> the standard statement is from Wadler's "theorems for free!". it is nice. it is not formal enough for me.
14:56:16 <carter> yes
14:56:23 <carter> hpc: the papers explain both though
14:56:32 <hpc> ah
14:57:45 <Eduard_Munteanu> hpc: not sure if it really rules out typecase. If you look for things that make parametricity useless, you can also think about types like Bool. :)
14:58:06 <tac> Eduard_Munteanu: why wouldn't it rule out typecase?
14:58:09 <hpc> Eduard_Munteanu: Bool isn't parameterized
14:58:14 <Eduard_Munteanu> Er, tac.
14:58:18 <Eduard_Munteanu> hpc: exactly
14:58:38 <monochrom> it is also a pretty long statement. on the surface, it look like just "the relation R relates a term to itself". the hard part is defining the relation R. it's long. and not formal enough for me.
14:58:50 <hpc> parametricity = "forall is type-level lambda"?
14:58:53 <tac> If I can tell what type a and b are, then Functor f => (a -> b) -> (f a -> f b) becomes much more rich, as a type
14:58:58 <Eduard_Munteanu> hpc: but data Booool a = Faaalse | Trrrue  would be parametric and useless :)
14:59:09 <tac> from what I understand, too, parametricity forces a -> a to be the identity function, right?
14:59:17 <monochrom> yes
14:59:29 <tac> But you could have f : a -> a; f {a} (x) = typecase a of Nat -> 0; _ -> x
14:59:30 <Eduard_Munteanu> tac: *in Haskell*
15:00:09 <monochrom> tac's example shows that parametricity rules out type-case. in fact, even Reynolds said it first.
15:00:10 <Eduard_Munteanu> I think you can talk about natural transformations in arbitrary categories as extensions of parametricity, no?
15:00:15 <augur> for the first time, I find myself actually needed to read a Conor paper, and it's the one I least expected: Clowns to the Left of Me, Jokers to the Right
15:01:06 <Eduard_Munteanu> monochrom: yes, but that's a different typesystem. Why expect 'a -> a ~ id' if you have a *-eliminator?
15:01:16 <monochrom> the Bool example merely shows that parametricity gives you a tautology on Bool. does not show that parametricity rules out Bool.
15:01:35 <carter> tac: Eduard_Munteanu  nope, you need a type class constraint to get that info
15:01:50 <carter> in haskell land, you can only break parametricity with type classes
15:02:11 <Eduard_Munteanu> monochrom: I was just saying that Bool is an instance where parametricity is useless even when it exists
15:02:21 <intrados> Is there some way to avoid `liftIO . foo . runResourceT`? something like `liftT foo`?
15:02:22 <carter> parametricity is often useless :)
15:02:25 <carter> except when it sin't
15:02:50 <tac> carter: Well, I'm not really speaking of Haskell here. Haskell has so many warts, it wouldn't make sense to look at hardly anything the way _Haskell_ does it.
15:02:52 <Eduard_Munteanu> intrados: it might be a MonadBase / MonadBaseControl
15:03:00 <carter> eh
15:03:06 <carter> its not as warty as you claim
15:03:17 <carter> yes every type is inhabited by bottom :)
15:03:27 <carter> but that + seq aside, its pretty reasonable
15:03:32 <monochrom> Wadler uses System F in "theorems for free!". and then adds "fix" and say what to do and what is weakened
15:03:38 <carter> jah
15:03:56 <monochrom> there are also recent papers detailing out what to do with "fix" etc etc
15:04:09 <Eduard_Munteanu> What I'm saying is perhaps we should expect an altogether different parametricity for such type systems. E.g. perhaps the types involving types of those eliminators exhibit some different form of parametricity.
15:04:51 <carter> not different, merely stronger vs weaker
15:05:30 <monochrom> ok, I am fine with "parametricity in Eduard_Munteanu's sense" and "parametricity in Stratchey's and Reynolds's sense". because Reynolds explicitly said "by parametricity I mean Stratchey's sense, for example no type-case".
15:05:31 <Eduard_Munteanu> Maybe... we could argue the id-kind of parametricity is simply a poverty of types.
15:06:04 * carter runs off befroe i start getting sucked it
15:07:12 <monochrom> sorry, s/parametricity/parametric polymorphism/
15:07:19 <Eduard_Munteanu> Still it's a weird thing... richer types would also give you less assurance?
15:07:25 <mirpa> *NifTest> nf <- DBS.readFile nifName
15:07:26 <mirpa> *NifTest> runGet (skip 1082 >> getNifVector 4) nf :: Either String (NifVector Float)
15:07:28 <mirpa> <interactive>:33:59:
15:07:31 <mirpa>     Predicate `NifVector Float' used as a type
15:07:33 <mirpa>     In an expression type signature: Either String (NifVector Float)
15:07:36 <mirpa>     In the expression:
15:07:38 <mirpa>         runGet (skip 1082 >> getNifVector 4) nf ::
15:07:40 <Eduard_Munteanu> mirpa: stop
15:07:41 <mirpa>           Either String (NifVector Float)
15:07:43 <mirpa>     In an equation for `it':
15:07:46 <mirpa>         it
15:07:48 <mirpa>           = runGet (skip 1082 >> getNifVector 4) nf ::
15:07:51 <mirpa>               Either String (NifVector Float)
15:07:53 <mirpa> *NifTest>
15:07:56 <mirpa> oops
15:07:58 <mirpa> sorry
15:08:14 <mirpa> ...anyway do you find that error message clear?
15:08:16 <Eduard_Munteanu> @where lpaste   -- but I guess it was a mistake
15:08:16 <lambdabot> http://lpaste.net/new/haskell
15:08:42 <Eduard_Munteanu> mirpa: sounds like NifVector is a typeclass
15:08:48 <mirpa> NifVector is type class
15:08:57 <monochrom> "richer" is the wrong way to look at it, just like "any". richer for the writer? richer for the reader?
15:09:06 <Eduard_Munteanu> mirpa: then why does it occur in a type?
15:09:17 <Eduard_Munteanu> mirpa: typeclasses go to the left of '=>'
15:10:22 <mirpa> yes, I was confusing type with type class ... I just wonder if that error makes sense to you - it took me few minutes to figure it out
15:10:24 <Eduard_Munteanu> mirpa: for example, you don't write   5 :: Num
15:10:54 <nisstyre> Has anyone noticed some documentation files are missing from hackage? e.g. http://hackage.haskell.org/package/gloss
15:11:06 <Eduard_Munteanu> mirpa: "predicate" is a more general term
15:11:13 <nisstyre> Is that due to the server problems the other day?
15:11:21 * mangaba_leitosa downloaded a collection of 470f color schemes for vim and was checking how a haskell text looks for each of them until the 360-th color scheme turned out to be more or less similar to the default scheme (not depressively dark nor crazily vivid), but used distinct colors for comments/function definitions while using vim2hs syntax file :-)
15:11:26 <Eduard_Munteanu> mirpa: typeclasses are predicates, constraint synonyms are predicates, type equalities are predicates
15:11:28 <mangaba_leitosa> "470"
15:11:48 <Eduard_Munteanu> mirpa: basically any Constraint if you're familiar with that
15:12:32 <Eduard_Munteanu> mirpa: (if you're not, don't worry :D)
15:13:09 <mirpa> Eduard_Munteanu: I would probabbly miss explicit info that NifVector *is* type class and not a type (I am beginner to Haskell)
15:18:53 <brandon`> how can i build documentation for all the installed packages?
15:21:53 <johannesbodannes> What's the general sentiment about http://www.fpcomplete.com as a haskell development environment?
15:22:17 <johannesbodannes> One of the things I've noticed about GHC and Haskell until now is that it's painful getting the environment set up
15:22:25 <cwraith> It is?
15:22:30 <cwraith> Always seemed easy tome.
15:22:33 <cwraith> *to me
15:22:52 <johannesbodannes> I've found so anyway. Like I had this debian server once, I had to install an IRC bot I made but it was written in Haskell
15:22:57 <c_wraith> I have more trouble getting git set up.
15:23:11 <johannesbodannes> But Debian didn't have sufficiently new versions of GHC stocked that supported the libraries I was using
15:23:17 <johannesbodannes> in the public repository anyway
15:23:25 <c_wraith> Oh.  yeah, using debian packages for GHC is a terrible mistake
15:23:41 <c_wraith> It's best to pretend they don't exist.
15:23:44 <johannesbodannes> : (
15:24:17 <hpc> i always try to install my own ghc and cabal, then immediately cabal install cabal-dev and then work up from there
15:24:42 <jchee> hpc: cabal sandbox isn't good enough?
15:24:50 <johannesbodannes> That's pretty good advice, but annoying if you're working on more than one platform though
15:24:54 <quchen> 1. Download GHC precompiled as tarball. 2. cabal install everything  ← Am I missing something?
15:24:58 <hpc> jchee: well, this predated cabal sandbox
15:25:02 <simpson> I just use Debian packages and not worry about the bleeding edge.
15:25:03 <johannesbodannes> Then you have several machines to install and update GHC and cabal on <_>
15:25:04 <jle`> @src iterate
15:25:04 <lambdabot> iterate f x =  x : iterate f (f x)
15:25:14 <jchee> hpc: ah, ok
15:25:18 <hpc> i haven't updated my stuff so i can't say anything about cabal's implementation
15:25:20 <jle`> is iterate tail call optimized?  does that even make sense in this context
15:25:27 <_justjust> isnt ghc in debian sid 7.6.3 or something?
15:25:35 <quchen> jle`: No and no :-P
15:25:38 <nooodl_> iterate doesn't have a tail call
15:25:42 <c_wraith> johannesbodannes: if you have several machines, you probably need something like puppet to keep them in sync anyway.  Just add GHC to the list of things it's managing
15:25:43 <johannesbodannes> simpson: Oh, yes, but then on your -development- environment you have to use the same packages that are in the horrible outdated debian server
15:25:51 <simpson> johannesbodannes: I also develop on Debian.
15:25:56 <hpc> jle`: ghc counterintuitively doesn't do well with tail calls
15:26:10 <hpc> or rather, it doesn't do /as well/
15:26:23 <c_wraith> Eh, GHC does fine with tail calls.  But yes, the optimal case is productive corecursion, which iterate is.
15:26:27 <johannesbodannes> hpc: Really? Wow that's weird
15:26:30 <quchen> hpc: It optimizes tail calls whenever it's sensible, doesn't it?
15:26:32 <_justjust> hpc: huh? i always thought the opposite is true
15:26:42 <TallerGhostWalt> So if I have a config like data CFG = CFG { cfg1 ::T1, cfg2::T2} and then a function that depends on cfg1 which calls a function that depends on cfg2... any rules of thumb?  should I make each function accept CFG or pull the record apart at the parent level?
15:26:45 <hpc> tail calls can lead to some awkward thunk evaluation
15:26:52 <quchen> The thing is just that tail recursion isn't as important in Haskell as it is in other languages
15:26:53 <TallerGhostWalt> Sorry for the giant question, we were just sitting here debating it!
15:27:10 <hpc> don't take it as "tail calls bad", just understand that it has the potential
15:27:14 <jle`> if i wanted to say, (iterate (* 2) 1) !! n, to get the nth power of two...does it take up O(n) space?
15:27:23 <jle`> it really should only need to take up O(1) space, doesn't it?
15:27:30 <c_wraith> well, yes, it does, but only because of laziness
15:27:44 <c_wraith> If you want it to be O(1), you need a somewhat stricter version of iterate
15:27:50 <hpc> @src iterate
15:27:50 <lambdabot> iterate f x =  x : iterate f (f x)
15:27:58 <quchen> jle`: Well it's O(n) by default, but optimizations might (!) make it O(1)
15:28:04 <hpc> that should only take O(1) space
15:28:10 * jorendorff thinks O(1) too
15:28:11 <hpc> (the whole expression)
15:28:30 <oio_> how can i get something out of a Either?
15:28:31 <jle`> is there any way I can check?
15:28:35 <jle`> oio_: pattern match
15:28:41 <quchen> :t either -- oio_
15:28:42 <c_wraith> jle`: look at the core
15:28:43 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:28:44 <hpc> oh no wait, it is O(n)
15:28:51 <jchee> jle`: if you really want to know the space and time complexity of something, in general your best solution is to profile that thing
15:28:52 <hpc> because it reduces to 2 * (2 * (2 * ...
15:28:55 <jorendorff> right
15:28:59 * jorendorff was wrong before
15:29:14 <quchen> > either ("Left: " ++) ("Right: " ++) (Left 8) -- oio_
15:29:16 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
15:29:16 <lambdabot>    arising from the literal ...
15:29:21 <hpc> the strictness analyzer theoretically catches that though
15:29:27 <quchen> > either ("Left: " ++) ("Right: " ++) (Left "Hello World") -- oio_
15:29:28 <lambdabot>   "Left: Hello World"
15:29:29 <jle`> jchee, c_wraith: thanks, will have to learn how to do that some time
15:29:44 <c_wraith> and yes, you need a stricter version of iterate to make that expression use O(1) space.  Something like:  iterate' f x = x `seq` (x : iterate f (f x))
15:29:54 <c_wraith> err, change that iterate to iterate'
15:30:04 <jle`> c_wraith: i feel like that would still create the list?  will it neve?
15:30:08 <jle`> *never
15:30:18 <hpc> iterate' (* 2) 1 !! n => iterate' (* 2) 2 !! (n - 1) => ...
15:30:27 <hpc> and that parameter becomes an accumulator
15:30:35 <jorendorff> jle`: neither one creates the whole list at once
15:30:39 <jmcarthur_mobile> Strict iterate should really be in base
15:30:39 <c_wraith> It will create the list (well, maybe, depending on list fusion).  But it will use O(1) space, even if it does O(n) allocation.
15:30:43 <oio_> quchen: wut
15:30:47 <hpc> (n - 1) is in normal form already from the zero test of (!!)
15:30:52 <hpc> making it O(1)
15:30:55 <jorendorff> jle`: even with the lazy iterate, it can drop each cell as it goes; it never needs the whole list
15:31:03 <jle`> oh that's neet.
15:31:06 <jle`> neat
15:31:18 <jle`> i guess it's in the implementation of !! as a recursive funciton?
15:31:22 <jorendorff> yes
15:31:23 <jle`> @src (!!)
15:31:23 <lambdabot> xs     !! n | n < 0 = undefined
15:31:23 <lambdabot> []     !! _         = undefined
15:31:23 <lambdabot> (x:_)  !! 0         = x
15:31:23 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:31:27 <jle`> how clever
15:31:47 <hpc> those bottoms are nice errors
15:31:54 <hpc> otherwise correct
15:32:02 <quchen> To be fair list indexing is usually not a good idea to use anyway.
15:32:17 <quchen> Put it into the same corner as head-tail-init-last.
15:32:28 <jle`> quchen: in that case how would you recommend taking the nth application of a function on a value?
15:32:33 <simpson> I always figured that that's why they picked a bang. It's supposed to be alarming and dangerous.
15:32:34 <hpc> list indexing is fine as a "pick from a sequence", so long as you only do it once
15:32:51 <hpc> but yes, you should think twice
15:32:54 <hpc> (!!) is aptly named
15:33:11 <quchen> jle`: Well this may be one of the cases where (!!) is alright. I would probably write my own function anyway though.
15:33:11 <jle`> this seems like one of those narrow situations that (!!) was perhaps made for
15:33:31 <jle`> if it could be said that (!!) has a specific, idomatic purpose
15:33:42 <quchen> The idiomatic purpose is avoiding it ;-)
15:33:57 <hpc> it's a fine ghci tool
15:33:58 <simpson> I think that it is provided, caveats and all, to prevent independent reinvention. :3
15:34:28 <hpc> a lot of bad things suddenly become pretty much indispensable in the presence of the REPL
15:34:48 <simpson> Oh, totally.
15:35:16 * hpc wants to make acme-unsafe now
15:35:49 <quchen> hpc: That exists, it's just misspelled "Prelude" by default
15:35:51 <hpc> all combinators that are safe (in ghc) and defined in terms of unsafeCoerce
15:35:52 <geekosaur> not already covered by acme-php? :p
15:36:30 <quchen> let isJust = unsafeCoerce :: Maybe a -> Bool
15:36:32 <quchen> etc
15:36:32 <jchee> if there was a natural number type with foldr :: (a -> a) -> a -> Nat -> a wouldn't that be a reasonable alternative to using iterate and (!!) ?
15:36:44 <hpc> geekosaur: i am very proud of using unsafeCoerce in implementing acme-php's sort function, but i wanna go further
15:37:19 <hpc> (also sort works now)
15:37:24 <quchen> jchee: [()] is Nat-ish
15:37:29 <jle`> jchee: are you saying foldr over [1..n]?
15:38:52 <jchee> data Nat = S Nat | Z; foldr (*2) 2 n
15:39:35 <quchen> @botsnack
15:39:35 <jchee> quchen: ah, nice, now when I want natural numbers I can just newtype [()]
15:39:41 <lambdabot> :)
15:39:47 <quchen> Welcome back, lambdabot
15:39:49 <monochrom> hpc: you may like adding a dose of unsafeDupableIO :)
15:39:58 <hpc> :D
15:40:13 <quchen> jchee: If you wanna go one step crazier, [forall a. a] is Nat-ish-er. But it doesn't print as well as [()].
15:42:14 <jchee> quchen: It's not computing for me, can that list be inhabited by any type?
15:42:33 <hpc> jchee: it can only be inhabited by polymorphic values
15:42:35 <hpc> aka bottom
15:42:45 <quchen> jchee: You mean by any value?
15:42:49 <quchen> Eh, what hpc said.
15:42:55 <jchee> ok
15:43:01 <quchen> [Void] ≅ Nat
15:43:17 <jamesjb> dsfd
15:43:56 <jchee> quchen: there's no example value of that though, right?
15:44:08 <Peaker> quchen: in a non-strict language, in a strict language: [Void] ≅ ()
15:46:51 <quchen> Peaker: Right, I only meant Haskell.
15:47:47 <Peaker> I wonder if this is what Robert Harper means by "Haskell has no products, ML has no sums" (or was it the other way around)?
15:48:35 <chrisdone> haskell has no products because they contain bottoms?
15:48:43 <quchen> Peaker: Wasn't this something with bot...ninja'd
15:48:59 <tac> http://james-iry.blogspot.com/2011/05/why-eager-languages-dont-have-products.html
15:49:18 <tac> It's a matter of bottoms, yeah.
15:49:25 <tac> In a total language, it shouldn't be an issue, I don't think
15:49:34 <Peaker> oh, it's the other way around
15:49:50 <chrisdone> oh, neat post
15:50:14 <chrisdone> That has a practical consequence. A compiler for an eager language can't necessarily simplify first(a, someComplicatedExpression) unless it can prove that someComplicatedExpression is never ⊥, and in general it can't do that. A lazy language compiler would always be free to throw away someComplicatedExpression.
15:50:17 <chrisdone> ^ good point
15:50:53 <tac> Yeah. Harper is a smart dude
15:51:01 <Peaker> is that from Harper?
15:51:04 <Peaker> A compiler for an eager language can simplify it -- if it is total
15:51:05 <tac> I think so
15:51:29 <quchen> I thought Haskell has no products as well. I remember people talking about this in here. Could it be because the tuple type constructor adds another bottom?
15:51:35 <Peaker> no, it's from James Iry
15:51:41 <tac> Peaker: first line says it's a response to a comment by Harper
15:51:49 <tac> http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/
15:52:12 <Peaker> Yeah, Harper is an amazing composition of brilliance and ... I don't know what to call the other thing :)
15:52:29 <tac> opinion?
15:52:39 <Peaker> Intentionally ignorant about a subject, saying nonsense with confidence
15:52:51 <monochrom> James Iry is also who brought you the funnest history of programming languages, beginning with the 1801 looming machine and "redditers of the time were unimpressed"
15:53:07 <Peaker> monochrom: oh, that's awesome :)
15:53:27 <quchen> monochrom: Did he invent the "what's the problem" joke or did it exist before?
15:53:39 <Peaker> Harper says "It is not possible in Haskell to define the type of natural numbers, nor the type of lists of natural numbers" <-- isn't this nonsense because of strictness annotations?
15:53:40 <monochrom> I don't know
15:54:11 <chrisdone> monochrom: yes, redditers are always unimpressed =)
15:54:30 <Peaker> chrisdone: pshh.. anyone could do that with decades of intense practice
15:55:11 <gfredericks> what do nix users typically do wrt haskell? just ghc? cabal and haskell-platform don't seem available from my basic setup
15:55:21 <donri> ask ocharles
15:55:40 <chrisdone> is nix an actual OS or does that mean linux?
15:55:48 <gfredericks> I meant the package manager
15:55:54 <chrisdone> oh ok
15:55:58 <gfredericks> but nix-os is a linux distro as well
15:56:12 <chrisdone> thought i'd heard that before
15:58:58 <quchen> NixOS is a Linux distribution built with the Nix package manager.
15:59:05 <quchen> Or bundled if you prefer.
15:59:37 <quchen> gfredericks: I think the majority here installs GHC manually and hates package managers (that aren't Cabal) for Haskell.
16:00:02 <donri> except nix users, i hear
16:00:10 <donri> they have some cabal wrapper thing
16:00:51 <Kaidelong> I was so disappointed when I discovered nix just rapped cabal
16:00:52 <dcoutts_> gfredericks: but lots of users go via their distro package manager, it's a very reasonable option for many use cases
16:01:05 <Kaidelong> because I was really craving an alternative to cabal
16:01:10 <Kaidelong> wrapped cabal*
16:01:35 <dcoutts_> Kaidelong: they do generate proper nix packages for Cabal packages
16:01:53 <dcoutts_> the cabal wrapper is just for using cabal-install itself in that environment
16:02:45 <chrisdone> quchen: so you just start with the linux kernel and nix and then install gnu/linux and the rest from there?
16:03:10 <alexander__b> how do I do "fmap fst .: lookup" with applicative <$>? .: is (.).(.)
16:03:22 <quchen> chrisdone: "you" as in "quchen"? Hell no.
16:03:36 <chrisdone> quchen: you as they-who-made-that-distro-n-that
16:04:04 <donri> :t (fmap.fmap.fmap) fst lookup
16:04:05 <lambdabot> Eq a => a -> [(a, (b, b1))] -> Maybe b
16:04:22 <chrisdone> quchen: i mean, 'built with the nix package manager' sounds like it's more low-level and bootstrappy than aptitude or yum?
16:04:29 <quchen> chrisdone: Oh. I'm not sure about that. NixOS is the result of a PhD thesis applying purely functional concepts to package managers. I'm not sure what level of tinkerish the distro is, but I've heard of people using it for their computer.
16:04:37 <chrisdone> ohhh
16:04:46 <chrisdone> was it always called nix? that's the "pure" package manager, right?
16:04:53 <donri> yep
16:04:57 <quchen> I would have to look that up.
16:05:14 <k00mi> it does a lot of strange stuff to your directory structure and binaries and whatnot
16:05:14 <quchen> The idea behind Nix is pretty compelling if you ask me.
16:05:33 <k00mi> there is a talk by one of the developers that explains it all quite well
16:06:04 <dcoutts_> it's really a great idea
16:06:12 <chrisdone> it sounds kinda nice
16:06:17 * quchen is procrastinating from fixing his space leak by looking for an appropriate name for the space leak, but prefers procrastinating from that on #haskell :-C
16:06:23 <chrisdone> especially the no-breaking upgrades
16:06:44 <k00mi> I use it on my desktop but I rarely do anything with it
16:07:35 <quchen> I don't remember who it was, but someone here had NixOS as his main thing.
16:07:45 <quchen> It's been some time ago though, possibly on #blah.
16:08:02 <alexander__b> oh I figured it out
16:08:11 <chrisdone> yeah… someone from here asked me to add #nixos to ircbrowse a while back, might've been him
16:08:20 <alexander__b> I was using :t and I had to do (<$>) not just <$>, which was why I was getting errors
16:08:25 <k00mi> that would be ocharles
16:09:05 <chrisdone> no wai
16:09:17 <quchen> Hm?
16:09:56 <chrisdone> sounds like it would be nice to try for a server
16:10:01 <levi> I want to see a combination of Nix and something Docker-like.
16:12:50 <levi> Instead of building your sandbox images from layered unionfs installs, you'd build them from Nix packages.  So each base image would be just a bunch of hardlinks in a directory, with a single COW fs of some sort on top for scratch space while running containers.
16:12:54 * hackagebot tempodb 0.1.0.0 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.1.0.0 (ParnellSpringmeyer)
16:15:14 <quchen> Oh wow. I found my leak. It is in a place I wouldn't have imagined it'd be in in forever. I commented it out because the debug message it generates as a side effect cluttered my log.
16:15:32 <quchen> One month. ONE MONTH for this leak.
16:15:35 <Engen> Is there a default editor you guys recommemnd that has the best auto-indentation and such for Haskell or?
16:15:36 <hpc> haha, nice
16:15:58 <quchen> Space: Constant. Connections: constant.
16:16:02 <intrados> If I get a GHC panic, should I definitely file it as a bug? Or only if it's something that seems like it results from using Haskell in a sensible way?
16:16:09 <quchen> I wish I had someone to get drunk with and dance naked now or something :>
16:16:14 <hpc> intrados: ghc panic is always a bug
16:16:30 <hpc> make sure it isn't a known bug first though, and a small reproduction is good too
16:16:43 <Peaker> quchen: what was the leak?
16:16:44 <hpc> as much work as you can do beforehand to make it fixable by a dev
16:16:56 <Peaker> quchen: does it relate to lazy I/O?
16:17:20 <levi> Engen: I find emacs with flymake-mode and haskell-mode very slick.
16:17:34 <quchen> Peaker: Not sure about what the leak is (I just found it, haven't identified it yet). It's unrelated to lazy IO though.
16:18:06 <levi> Also with the ghc-mod mode add-on for haskell-mode.
16:18:11 <Engen> levi: because I've seen some videos on youtube with which they're all using emacs and it looks all natural which
16:18:18 <intrados> Yeah, it's a small case. Like 3 lines. Is there a recommended way to look for known bugs?
16:18:20 <Engen> is pretty neat*
16:18:26 <quchen> Peaker: In fact the primary reason I rewrote the program to use pipes was to get rid of that leak. Instead I got a pipes-based program where the leak is still in anyway. :-)
16:18:47 <quchen> Peaker: I'm assuming it's bad exception handling in some place. Threads get killed, but ressources stay open.
16:18:55 <levi> Engen: If you are comfortable in Eclipse, the EclipseFP IDE is actually pretty nice, too.
16:19:16 <dropdrive> Hi, newbie here.  I can see why one might claim that `loeb` is a generalization of `fix`.  But is it obvious that you can't implement `loeb` using `fix`?
16:19:17 <Peaker> quchen: pipes aren't about prompt finalization, are they? That's what conduits are bout
16:19:22 <hpc> intrados: just spend like a minute or so looking for anything obviously the same; it's not the end of the world if it's a duplicate, a search is more about politeness ;)
16:19:29 <hpc> @src loeb
16:19:29 <lambdabot> Source not found. Whoa.
16:19:35 <Peaker> quchen: "killed" means "Sent an exception that asks them to die, pretty please" :)
16:19:48 <quchen> Peaker: Right. Async.cancel.
16:19:49 <Engen> levi: actually, I've been using vim and geany/kate occasionally :/
16:20:06 <Peaker> quchen: are you masking exceptions anywhere?
16:20:06 <quchen> Not sure what you meant with prompt finalization and conduits, I'm not very familiar with them.
16:20:15 <augur> quchen: did you see my little interpretation of loeb?
16:20:15 <Aetherspawn> when this trifecta parser doesn't match anything it silently fails without an error like "expecting statement" https://gist.github.com/kvanberendonck/7592227 . is there a way I can demand a match, or is `choice` not really suitable for parsing this way
16:20:18 <hpc> dropdrive: loeb x = ($ loeb x) <$> x
16:20:25 <Peaker> quchen: Snoyman wrote some blog posts about how conduits does prompt finalizations in some examples where pipes would leak (temporarily)
16:20:25 <quchen> I'm not manually calling 'mask', but 'bracket' uses it internally, so yes.
16:20:31 <levi> I think that you can get nice vim integration with ghc-mod and maybe some other tools, but I do most of my coding with emacs so I don't know much about the vim extensions for programming.
16:20:35 <hpc> dropdrive: loeb = fix $ \loeb x -> ($ loeb x) <$> x
16:20:38 <Engen> levi: I'll give this Haskell wiki emacs page a read and see if I can get emacs up and running
16:20:49 <Peaker> quchen: and that to avoid leaking, the pipes code gets quite tricky, whereas conduits avoid leaking with straightforward code
16:20:50 <hpc> dropdrive: trivial recursion transformation
16:21:11 <quchen> Peaker: Oh, my leak wasn't temporary. It took around 15 minutes of linear memory growth up to the order of 100 megs, and then the OS said "too many connections" (sockets) and flicked me off.
16:21:12 <dropdrive> hpc: OK, I'll think about that.  And `moeb`?
16:21:29 <Peaker> quchen: finding a socket leak, without lazy I/O, is probably much easier than finding a memory leak
16:21:39 <hpc> i don't know moeb, but it can be similarly transformed
16:21:52 <Peaker> quchen: figuring out why the socket owners are misbehaving sounds like a relatively localized debugging task?
16:21:54 <quchen> Peaker: Well I had both a memory and a socket leak. I strongly suspected they are tied together somehw.
16:22:01 <levi> Engen: EclipseFP is probably the easiest thing to set up if you're not familiar with configuring Emacs or vim. They're all based around tools like ghc-mod and hdevtools, though, which are wrappers around the GHC API for integration with IDEs.
16:22:15 <Peaker> quchen: sure, sounds likely, I just mean debugging the socket leak is probably easier than the memory leak
16:22:28 <hpc> (foo x y z = f foo x y z) => foo = fix $ \foo x y z -> f foo x y z -- just apply that sort of transformation to moeb
16:22:33 <hpc> try it in ghci, it should work
16:22:38 <Aetherspawn> keep in mind pipes is much faster than conduits
16:22:53 <Peaker> does anybody here use EclipseFP? I tried it a few times and couldn't get it to work.. but then, I tried Eclipse for Java and Eclipse for C a few times, and couldn't get it to work reasonably
16:23:04 <levi> Oh, I think there may be a SublimeText integration with ghc-mod or something as well.
16:23:14 <dropdrive> hpc: Thanks.
16:23:16 <Peaker> Aetherspawn: it is? I thought they were relatively competitive, haven't seen benchmarks showing pipes being much faster
16:23:18 <acowley> magit is quite wonderful
16:23:22 <Aetherspawn> is anyone able to answer my parser question up the scroll buffer? :)
16:23:34 <intrados> hpc: Thanks. It looks like it was a known bug. https://ghc.haskell.org/trac/ghc/ticket/7368
16:23:40 <hpc> dropdrive: this is the transformation you often see in lambda calculi
16:23:44 <Aetherspawn> Peaker: pipes round trip is 50ns less or so, about 30% less than a conduit roundtrip
16:23:51 <levi> Peaker: I have used it before and got it to work pretty well, but I am not really comfortable in Eclipse for editing, so I don't use it much.
16:24:10 <Peaker> Aetherspawn: that sounds like 1 particular micro-benchmark, and would not necessarily qualify as "much" :)
16:24:10 <hpc> dropdrive: if a particular calculus takes a fixed point combinator as a primitive, any recursive definition can be transformed; it's one way into turing-completeness
16:24:27 <edwardk> Aetherspawn: that parser has very strange structur
16:24:30 <Peaker> levi: I think none of the Haskell features worked. But it might just be my Eclipse curse. None of Eclipse's features ever work for me anyway
16:24:38 <hpc> intrados: neat
16:24:39 <quchen> Peaker: The main problem when debugging this is that many effects (such as this) only occur when the program is run on a sufficiently large scale, i.e. many independent actors. I've fixed multiple bugs that were probably related to this leak, but those didn't fix it. I think the problem is that I have a complex system that has a very narrow phase space where it operates correctly; when there are many things wrong, you only get a crippled sy
16:24:40 <quchen> stem. Fixing one "wrong" isn't enough, which makes debugging awful. I'd like to make one change and see whether it improves something, but it turns out I need to make many many changes in order to see a potentially positive result, at which point it's too late to go back and identify which fix was unnecessary. That should sum up my experience in a nutshell.
16:24:43 <Aetherspawn> yeah, I could not find any examples
16:24:46 <Aetherspawn> I don't  really know how to write a parser
16:24:47 <Aetherspawn> :(
16:24:59 <edwardk> Aetherspawn: you can basically steal parsec examples
16:25:12 <mlen> Is it possible for something to be a Monad and not a Functor?
16:25:14 <hpc> intrados: oh, that's a really cool reproduction
16:25:31 <bobcrash_> wtf a couple of days ago I was hacking around with GtkGLExt trying to get it to build to no avail
16:25:31 <quchen> mlen: In current Haskell yes, but morally it's wrong. Future GHC versions will fix that though.
16:25:32 <Peaker> quchen: I had a similar problem on a much smaller scale.. had so many little problems that I couldn't fully debug any of them, as I'd hit others in the middle that would disrupt my debugging
16:25:42 <bobcrash_> today I just ran the build and it worked just fine
16:25:44 <Peaker> quchen: just managed to ignore some problems long enough to fix others and then attend to them
16:26:00 <edwardk> Aetherspawn: https://github.com/DylanLukes/Winchester-STG-Compiler/blob/master/WSC/Parser.hs shows a reasonably well worked out trifecta parser
16:26:01 <bobcrash_> I guess time to look at the diff logs and figure out if my change are worth issuing a pull for or if they are just pure nonsense that worked out
16:26:02 <mlen> quchen: Can you provide an example of such thing?
16:26:04 <levi> Peaker: It's been long enough ago that I can't remember any particular bumps I ran into, but there may have been a couple things I had to tweak (like PATHs or something) to get everything working.
16:26:06 <quchen> Peaker: Right, that's pretty much what I did: start refactoring and think about your code, hope for the best
16:26:34 <Aetherspawn> edwardk: cool, thanks
16:26:48 <quchen> mlen: Every Monad should be a Functor. Due to historical reasons, Haskell doesn't enforce this. However, all respectable libraries have the appropriate instances.
16:26:48 <edwardk> Aetherspawn: you may have to update it for current trifecta but the structure is closer to right =)
16:27:13 <quchen> Peaker: At least it got me to using pipes by default now :-)
16:28:23 <mlen> quchen: So basically there are no useful reasons why it's not enforced. Thanks!
16:28:50 <quchen> mlen: Right. In GHC 7.10 there will probably be  Functor => Applicative => Monad  though.
16:28:50 <lambdabot> That's Numberwang!
16:29:10 <quchen> Lambdabot, you're drunk.
16:30:33 <quchen> mlen: See also http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
16:31:38 <Aetherspawn> doh, sepEndBy
16:31:51 <levi> Does Trifecta backtrack by default like Attoparsec or does it require 'try'?
16:31:56 <Aetherspawn> spent minutes ctrl+f'ing stuff to find out where the hidden `many` is
16:31:59 <edwardk> requires try
16:32:17 <edwardk> that lets it prune the continuation tree, so it matters asymptotically
16:35:23 <chrisdone> off-topic, but this bugs me http://www.depesz.com/2010/03/02/charx-vs-varcharx-vs-varchar-vs-text/
16:35:48 <chrisdone> _the documentation of PostgreSQL_ states that there is no performance difference between these types
16:36:14 <chrisdone> ლ(ಠ益ಠლ) y u no read manual?
16:37:30 <Peaker> is there any Applicative/non-Monadic parsing library that uses the lack of Monadic composition to pre-compile faster parsers yet?
16:38:20 <Peaker> it would also have to ban general recursion and provide a fixpoint combinator, but it could be much faster!
16:38:56 <Aetherspawn> edwardk: any idea why it doesn't throw any errors when it hits ba; ? https://gist.github.com/kvanberendonck/7592227
16:39:07 <Aetherspawn> it just terminates silently and outputs half the AST :/
16:39:28 <carter> Peaker: you can write it
16:39:37 <carter> i looked into doing something like the first half of that
16:39:47 <carter> decided i was working on enough other hard problems and shelved it
16:39:50 <carter> for now
16:40:35 <Peaker> carter: hmm.. I would, as a cute problem to solve, but I don't actually believe in parsing :)  i.e: It's a central CS problem rather than a super-niche problem because of the wrong-headed way we encode language ASTs
16:40:49 <carter> hehe
16:40:51 <carter> fair
16:41:02 <carter> except parsing is handy because of how fucked all those formats are :)
16:41:05 <carter> g2g for a while
16:43:07 <Taneb> Is the Monad.Reader available in plaintext format?
16:44:25 <acowley> You could probably get your hands on raw tex
16:45:05 <augur> oh cosmic coincidences!
16:45:22 <augur> the most recent episode of buzzcocks happens to feature ... stuck in the middle with you
16:45:27 <augur> what a coincidence!
16:46:42 <khyperia> I'm writing up Algorithm W/M (both of them), if I want to annotate the AST with type information, should I just do a sweep of the resulting substitution across all type annotations in the AST, or should I try to return both the result of the algorithm and a new expression?
16:47:16 <edwardk> Aetherspawn: your parser doesn't check that it parsed to EOF, its perfectly happy consuming half the input.
16:47:34 <augur> edwardk: i heard you were interested in chart parsing or something?
16:47:37 <augur> a while back, i mean
16:48:03 <edwardk> yes. i have a couple of nice tweaks to valiant parsing that have been working out well in practice
16:48:25 <Aetherspawn> the example parser doesn't either I don't think
16:49:07 <augur> edwardk: is it combinator parsing?
16:49:20 <edwardk> augur: yes
16:49:25 <augur> i cant figure out how to do combinator chart parsers cause the whole grammar needs to be available all at once :\
16:49:32 <augur> edwardk: anything i can read?
16:50:01 <edwardk> augur: start with http://www.cse.chalmers.se/~bernardy/PP.pdf then we can have a common vocabulary i guess, and i can fill in details
16:50:27 <edwardk> re having the whole grammar available at once i use observable sharing
16:50:33 <mlen> quchen: Can you also recommend a good read on category theory?
16:50:37 <edwardk> then reconstruct the grammar
16:50:54 <Aetherspawn> I don't really get very nice error messages when I do something like `pStmt `sepEndBy` semi <* eof`
16:51:21 <Aetherspawn> I get `error: expected: end of input` instead of `error: expected: statement`
16:51:28 <Aetherspawn> is there a better way?
16:51:36 <quchen> mlen: Functor and Monad in Haskell really aren't about category theory. There exists a connection, but it depends on your motivation whether making it is a good idea.
16:51:47 <levi> Aetherspawn: You told it to parse something that matches a specification, and it did so successfully. If you consume the parsed bit and run the remaining text into the parser, you'll probably get a more informative error.
16:52:13 <Narvius> Who'd have thought that understanding how "fib = 1:1:zipWith (+) fib $ tail fib" works would help me in writing a concise solution to "How many ways are there of making change for N, given a list of coin denominations?"
16:52:28 <mlen> quchen: I'd like to have a better understanding of the underlying theory, not more than that.
16:52:30 <quchen> mlen: If you want to understand how to use Haskell monads better than category theory is most likely the wrong direction to go. If you really want to know the (very abstract) mathematical background, then there are other people much more knowledgeable than me. Awodey is a popular book suggestion for cats though.
16:52:32 <edwardk> that lets me put it in 2nf or cnf and  can go from there
16:52:59 <quchen> mlen: There is a lot of preliminaries before you get to monads in category theory, they typically appear in the second half of 500-page books.
16:53:04 <Aetherspawn> levi: sepEndBy has a `many` inside, otherwise I didn't understand your suggestion sorry
16:53:28 <edwardk> Aetherspawn: why does it have the many?
16:53:38 <edwardk> why not 'some'?
16:53:54 <Aetherspawn> "sepEndBy1 p sep parses one or more occurrences of p, separated and optionally ended by sep. Returns a list of values returned by p."
16:54:06 <Aetherspawn> oh, I don't know the internals \o/
16:54:27 <edwardk> i don't really grok your grammar
16:54:50 <Aetherspawn> let me upload the updated one
16:54:56 <levi> Aetherspawn: Right, it parsed many of them, but then it reached a point where the remaining text no longer matched, so the ending semi was the last bit that matched and that ending semi completed the rule.
16:58:52 <edwardk> Aetherspawn: when i run the code you had in the last paste i get: (test):1:13: error: expected: end of input, statement -- isn't that exactly what it should say?
16:59:09 <edwardk> ba is neither an end of input nor a statement
16:59:10 <Aetherspawn> I kind of want it to say "error: expected statement"
16:59:53 <Aetherspawn> I think levi was on the money and I'm currently trying to figure out how to fmap concat or something over some
17:00:38 <edwardk> the 'expected' clauses are autogenerated by sorting the strings of all the expected tokens together for the current position
17:01:57 <edwardk> as an aside: pFoo = curry Foo <$ string "foo" <*> position <* modify (+1) <*> get
17:02:00 <edwardk> that cleans up your parens
17:02:14 <edwardk> only ever use <$ <$> <* and <*> and you never need parens
17:02:21 <Aetherspawn> oh cool
17:02:31 <hpc> edwardk: i see two parens there ;)
17:02:35 <levi> edwardk: You really do have something against parens, don't you? :)
17:02:41 <edwardk> hpc: =P
17:02:43 <edwardk> levi: yes
17:02:51 <hpc> levi: a tragic lisp allergy
17:02:51 <monochrom> I don't want to recall what <$ is
17:03:01 <edwardk> levi: i had a traumatic childhood involving a lisp.
17:04:08 <levi> I only really get uneasy when my open and close parens are on different lines or are nested.
17:05:04 <Saizan> ?ty (<$)
17:05:05 <lambdabot> Functor f => a -> f b -> f a
17:05:35 <levi> Although I will often use $ to eliminate parens if I accumulate too much stuff between them.
17:06:05 <edwardk> note (<$) is actually a member of Functor, and can make asymptotic improvements in code
17:06:15 <levi> I am still fond of Lisp, but Lispy-looking Haskell doesn't feel right.
17:06:33 <edwardk> yeah, lispy's haskell is weird.
17:06:53 <levi> I do use (<$) in applicative-style parsers fairly often.
17:08:20 <levi> Sometimes I forget which of < or > to leave off of a <*> and spend a few minutes scratching my head over the resulting errors.
17:08:47 <levi> But I'm still fairly new at this.
17:10:26 <pavonia> you can think of the angle brace pointing to the side to use the result from
17:10:34 <levi> Ow! I left wireshark running on a monitor-mode WiFi interface for about 24 hours.
17:11:25 <levi> pavonia: Yes, but which operator do you modify? That's what I forget.
17:12:10 <pavonia> Ah, I missed the previous discussion
17:13:32 <levi> I don't think the previous discussion would have made what I said any clearer, I was just vague in my description and your suggestion was not out of place given the vagueness.
17:13:47 <heatsink> Is there a parenthesis-free way to write C <$> (T <$> foo <*> bar) ?
17:14:43 <hpc> T . C <$> foo <*> bar
17:14:44 <Aetherspawn> Something like `concat <$> manyTill pTest eof` just goes forever because my testing language is like haskell and ; mustn't necessarily be matched by a statement
17:16:00 <heatsink> hpc, that passes only one argument to C
17:16:17 <hpc> oh yes, hmm
17:16:30 <hpc> if we assume (.:) this becomes easier
17:16:35 <chrisdone> man, is ANYTHING in the ghc api an instance of Show?
17:16:41 <heatsink> :t (.:)
17:16:42 <lambdabot> (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
17:17:06 <chrisdone> it's like a great plot to make debugging a complete PITA
17:17:10 <heatsink> The ghc api has its own show-like class, Ppr or Pretty or something
17:17:17 <levi> Heh.
17:17:28 <chrisdone> http://haddocks.fpcomplete.com/fp/7.4.2/20130922-179/ghc/InteractiveEval.html
17:17:33 <chrisdone> ^ no instances of anything
17:17:52 <heatsink> ah
17:18:51 <levi> ~9gb of traffic captured and I didn't even notice it was still running.
17:19:00 <chrisdone> bog bless deriving instance Show
17:19:11 <hpc> chrisdone: haha
17:19:17 <Engen> levi: I see, but figuring out how to set up vim wouldn't hurt :)
17:19:22 <Aetherspawn> I don
17:19:32 <hpc> chrisdone: if you upload ghc-api-desperate-fixes, i wouldn't mind
17:19:35 <chrisdone> grr can't derive
17:21:20 <levi> Engen: Well, I think there are some how-tos out there if you google for them. Look at the pages for ghc-mod and hdevtools as well. I can't give any advice beyond that for vim configuration.
17:25:26 <Aetherspawn> T___T even the Idris parser doesn't use any EOF stuff
17:26:53 <levi> Aetherspawn: Have you tried running the other parsers to see how they handle garbage at the end of a file? You might also look at the code that invokes the parsers.
17:31:44 <Aetherspawn> honestly I shouldn't really need to
17:33:17 <Aetherspawn> I've looked at both the Idris parser and the example parser edward sent and mine doesn't differ in any way I can see, yet it terminates without consuming the rest of the input but when I force eof upon it I get a really stupid error
17:33:36 <carter> Aetherspawn: you mean they're the same codE? :P
17:33:38 <Aetherspawn> Idris and the example parser don't use eof.
17:34:01 <carter> i mean why is your parser barfting
17:34:04 <Aetherspawn> well, no, but same structure -- ish.
17:34:07 <carter> clearly they're not the same code
17:34:12 <carter> @lpaste the ish
17:34:12 <lambdabot> Haskell pastebin: http://lpaste.net/
17:34:50 <lispy> edwardk: agreed
17:34:57 <Aetherspawn> it's at https://gist.github.com/kvanberendonck/7592227
17:35:50 <carter> lispy: whats quircky about your code?
17:36:06 <lispy> > take 10 . length . group $ fix show
17:36:07 <lambdabot>   Couldn't match type `GHC.Types.Int' with `[a0]'
17:36:07 <lambdabot>  Expected type: [[GHC.Types...
17:36:08 <carter> :t (<$)
17:36:09 <lambdabot> Functor f => a -> f b -> f a
17:36:17 <lispy> > take 10 . map length . group $ fix show
17:36:18 <lambdabot>   [1,1,1,3,1,7,1,15,1,31]
17:36:23 <lispy> carter: ^^
17:36:44 <carter> :t fix
17:36:45 <lambdabot> (a -> a) -> a
17:36:50 <carter> wait
17:36:58 <carter> you write stuff like that deliberately?
17:37:04 <carter> fix show
17:37:08 <carter> > fix show
17:37:09 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:37:22 <carter> :t group
17:37:23 <lambdabot> Eq a => [a] -> [[a]]
17:37:30 <oio_> any lib ray for bmp to jpg conversion?
17:37:35 <oio_> library*
17:37:37 <carter> group $ fix show
17:37:42 <carter> > group $ fix show
17:37:43 <lambdabot>   ["\"","\\","\"","\\\\\\","\"","\\\\\\\\\\\\\\","\"","\\\\\\\\\\\\\\\\\\\\\\...
17:38:04 <carter> i feel like i just saw some APL code in ghci
17:38:10 <carter> but LispyPL
17:38:13 <hpc> oio_: if you don't mind the extreme overkill and external dependencies and general untestedness, https://github.com/headprogrammingczar/magick-mirror
17:38:37 <lispy> carter: thankfully, I don't write like that for things that get commited to a repo. Only for fun :)
17:39:13 <lispy> Understanding `fix show` is interesting. It only does what it does because of the instance for String
17:39:16 <lispy> :t fix show
17:39:17 <lambdabot> String
17:39:26 <carter> Aetherspawn: hehe
17:39:28 <lispy> Whatever string you are showing, it has to start with "
17:39:32 <carter> hehe
17:39:35 <carter> thats clever
17:39:43 <carter> what do the \\ come from?
17:39:54 <lispy> Because the string we're showing contains a string
17:39:55 <hpc> carter: the string of " is "\""
17:39:57 <lispy> ad nauseum
17:40:06 <carter> urk
17:40:09 <carter> hehe
17:40:16 <lispy> the escaping has to come in pairs
17:40:28 <lispy> That's why the group/length goes up in powers of 2 minus 1
17:40:29 <chrisdone> it doesn't have to descend *into* the string to get the first \" part of it
17:40:46 <hpc> > iterate (\n -> 2*n + 1) 11
17:40:47 <Rc43> I just installed java-bridge via cabal (its on hackage).
17:40:48 <lambdabot>   [11,23,47,95,191,383,767,1535,3071,6143,12287,24575,49151,98303,196607,3932...
17:40:49 <hpc> > iterate (\n -> 2*n + 1) 1
17:40:50 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,26...
17:40:53 <Rc43> Does it works at all?
17:40:57 <oio_> hpc: ... needs to be small
17:41:19 <mangaba_leitosa> why does 'fix show' print a backspace?
17:41:26 <Rc43> I try `j2hs --help' and it says to use `j2hs help' for commands, I try `j2hs help' and no info.
17:41:26 <lambdabot> That's Numberwang!
17:41:29 <oio_> hpc: been looking juicy pixel seems promising.. but can't get it to work
17:41:41 <chrisdone> int-e: =p
17:41:44 <Rc43> I try `j2hs <file>' and nothing.
17:41:53 <lispy> mangaba_leitosa: i think you mean backSLASH
17:42:02 <mangaba_leitosa> lispy: right :-)
17:42:07 <lispy> mangaba_leitosa: and that's because it's trying to print a string inside a string
17:42:08 <hpc> oio_: if you're getting an error message, paste it and maybe someone can help
17:42:34 <mangaba_leitosa> lispy: ah, ok, thanks :-)
17:43:05 <lispy> > cycle "inside a string "
17:43:06 <lambdabot>   "inside a string inside a string inside a string inside a string inside a s...
17:43:39 <Aetherspawn> meh, fixed the parser
17:44:07 <Aetherspawn> sepEndBy wasn't really the right tool for the job
17:44:28 <Aetherspawn> went back to `pStmt = semi *> pStmt <|> pFoo <|> pBar <?> "statement"` and it started working.
17:47:14 <chrisdone> i have a vampire movie on my other screen in which the vampire henchmen use karate chops on their victims
17:47:58 <oio_> hpc: readImage :: FilePath -> IO (Either String DynamicImage) and saveJpgImage :: Int -> FilePath -> DynamicImage -> IO ()
17:48:34 <oio_> hpc: or readBitmap :: FilePath -> IO (Either String DynamicImage)
17:49:11 <hpc> oio_: what error do you get?
17:50:16 <oio_> hpc: always goes left so error
17:50:32 <hpc> (Left ??) -- what's the error?
17:53:06 <oio_> hpc: im <- readImage "aaaa.bmp" ; case im of ; Right bmp -> "good"; Left err -> "bad"
17:53:20 <hpc> oio_: what's err?
17:53:36 <oio_> hpc: always left err is error
17:53:45 <hpc> no, i mean
17:53:47 <hpc> err :: String
17:53:49 <hpc> err = ???
17:55:39 <chrisdone> Iceland_jack: SLEEEEEEP
17:57:45 <oio_> hpc: says the specific error
17:58:13 <oio_> hpc: fileHeader truncated
18:02:26 <lykos_> How can I change a [m a] -> m [a]?
18:02:31 <chrisdone> :t sequence
18:02:32 <lambdabot> Monad m => [m a] -> m [a]
18:03:21 <lykos_> Thank you
18:03:34 <lykos_> I'm learning gtk2hs, it's an excellent library
18:03:42 <Iceland_jack> > sequence [Just 't', Just 'e', Just 's', Just 't']
18:03:43 <lambdabot>   Just "test"
18:03:52 <chrisdone> i miss the old days when google would return results for the words you typed in
18:04:34 <roconnor> Is there a research paper that goes with IOSpec beyond data types a la carte?
18:04:44 <pavonia> chrisdone: hahaha, so true
18:05:42 <maxiepoo_> :t sequenceA
18:05:43 <lambdabot>     Not in scope: `sequenceA'
18:05:43 <lambdabot>     Perhaps you meant one of these:
18:05:43 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
18:07:35 <chrisdone> lykos_: yeah it's a nice binding
18:24:27 <lemao> does someone have an example of a cabal project that generates a dynamic shared library?
18:26:25 <c_wraith> I don't think you do anything different in the project's cabal file to get that to happen.
18:26:43 <c_wraith> You just make sure that when you install the package, you also install the dynamic version of it
18:26:53 <td123> lemao: are you talking about the --enable-shared flag?
18:30:23 <bobcrash_> I'm having trouble googling this and I swear I've seen it before.  How could I do [IO a] -> IO [a] ?
18:30:39 <dwcook> @type sequence
18:30:39 <Iceland_jack> sequence :)
18:30:39 <lambdabot> Monad m => [m a] -> m [a]
18:30:42 <Iceland_jack> @ty sequence
18:30:42 <lambdabot> Monad m => [m a] -> m [a]
18:30:49 <bobcrash_> Thank you!
18:30:56 <Iceland_jack> You may have seen it on this very channel some minutes ago
18:31:03 <bobcrash_> I think I saw it in learn you a haskell
18:31:12 <frx> @hoogle [m a] -> m [a]
18:31:12 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
18:31:13 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
18:31:13 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
18:31:24 <bobcrash_> I've been bouncing back and forth between mulling over that and various tutorials/discussions and writing horrible horrible haskell for my pet project
18:31:30 <bobcrash_> ah that's cool
18:32:05 <Iceland_jack> So for your specific question you could have done:
18:32:06 <Iceland_jack> @hoogle [IO a] -> IO [a]
18:32:06 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
18:32:06 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
18:32:06 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
18:33:25 <Iceland_jack> For future reference :)
18:33:49 <lemao> c_wraith td123: I need to generate a shared lib that can be linked to a C/C++ exe
18:34:15 <td123> ah
18:34:19 <c_wraith> ah, that's an entirely different issue.  I know little about using the FFI in that direction
18:34:42 <lemao> I already have an .hs that exports a simple function
18:34:56 <td123> lemao: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
18:35:00 <lemao> I have a .cabal with ghc-options:         -shared -fPIC -dynamic
18:35:01 <td123> lemao: have you seen that?
18:35:38 <lemao> I did, but it is not cabal.
18:36:02 <lemao> and I want to dynamically link from C exe with dlopen
18:41:27 <lemao> This works: ghc --make -dynamic -shared -fPIC Aluminium.hs -o Aluminium.so
18:41:42 <lemao> Then I tried adding this to .cabal:   ghc-options:         -shared -fPIC -dynamic
18:42:08 <lemao> but cabal ends up creating an a.out in the project dir (not even in the dist/build folder)
18:44:21 <codh> greeting. when you add two big word32 and overflow, why the least significant digits are not correct?
18:44:21 <lambdabot> That's Numberwang!
18:44:42 <codh> (1836311903 :: Word32)  + (2971215073 :: Word32)  ==> 512559680
18:45:02 <codh> where I'm expecting at least the least significant digit is 6.
18:54:41 <Aetherspawn> edwardk: what happened to all the Language parsing stuff? It kind of vanished and I can't find it in either trifecta or parsers.
18:55:12 <lemao> ok, I need to explicitly set the shared library name: ghc-options:         -shared -fPIC -dynamic -o Aluminium.so
18:55:49 <edwardk> i kind of went on a stripping-things-down rampage, that was perhaps too aggressive ;)
18:57:07 <Aetherspawn> oh ok
18:58:01 <Aetherspawn> theres the token whitespace stuff in that parsers module, however I can't find out how to actually use it to make someSpace also mean whitespace. Are we supposed to instantiate our own parser class and do it ourselves?
19:00:35 <Aetherspawn> oh, thats how Idris does it, so it must be right.
19:01:09 <Aetherspawn> trifecta is great, but it could do with some examples or something. :P thanks for the great lib though
19:02:05 <edwardk> i'm happy to take documentation patches or things that improve usability. its very low on my priority list in that it has been put to use and is doing the things I need it to, but left to my own devices it'd probably not change much
19:07:16 <chrisdone> no wai
19:07:46 <chrisdone> the InteractiveEval lets you compile an IO and run it. nice
19:11:01 <chrisdone> do getDir <- dynCompileExpr "getCurrentDirectory"
19:11:01 <chrisdone>    liftIO getDir
19:11:04 <chrisdone> ^ works
19:11:12 <chrisdone> wasn't aware this was possible. pretty neat
19:12:05 <fragamus> Hadoop map reduce is like a distributed list monad right?
19:12:45 <Iceland_jack> fragamus: Where is the reduce part of the list monad?
19:13:02 <fragamus> In >>=
19:13:14 <Iceland_jack> I think you may be confused
19:13:21 <Iceland_jack> The list monad models non-determinism, map reduce doesn't
19:13:27 <carter> fragamus: mapreduce is ilke a complicated job scheduling system kludged on top of a giant fold
19:13:40 <Iceland_jack> there is no reduction step in the list monad
19:13:45 <Aetherspawn> you would find speculation really interesting
19:13:52 <carter> ooo
19:13:53 <carter> thats a fun lib
19:14:15 <brandon`> chrisdone what package is that? can't find that function on hoogle
19:14:19 <Aetherspawn> useless work makes your programs faster, yaaay
19:15:08 <jcarpenter2> Anyone know where to get the HList paper?  All I can find is a broken link.
19:15:23 <chrisdone> brandon`: http://haddocks.fpcomplete.com/fp/7.4.2/20130922-179/ghc/InteractiveEval.html
19:16:54 <lpaste> chrisdone pasted “Example of InteractiveEval” at http://lpaste.net/1183969239074078720
19:17:01 <bobcrash_> @type liftIO
19:17:02 <lambdabot> MonadIO m => IO a -> m a
19:18:09 <Aetherspawn> so would many (a <|> b <|> c) == many <$ a <|> b <|> c ?
19:18:32 <brandon`>     Could not find module `GHC' It is a member of the hidden package `ghc-7.6.3'.
19:18:34 <brandon`> wtf
19:18:56 <chrisdone> brandon`: use -package ghc
19:19:00 <chrisdone> it's hidden by default
19:23:42 <chrisdone> brandon`: the pwd stuff doesn't quite work as i want yet, the runStmt seems to run in a different context to if i compile an expression and run it
19:24:05 <chrisdone> i'm seeing if i can write my own runStmt in terms of dynCompileExpr
19:24:47 <chrisdone> seems to work
19:26:34 <chrisdone> mwuhahaha, it works
19:27:26 <startling> is there (or will there be) a way to provide default implementations of typeclass members with TH?
19:28:49 <startling> I have a class with a member "name :: Tagged r String" that should just be the name of the type. I was wondering if there was a way to derive it automatically.
19:31:34 <Cale> startling: hmm, perhaps if you demand Typeable
19:31:49 <Cale> startling: You could use  show . typeOf  to define it
19:32:01 <Cale> (I don't know what this Tagged thing is though)
19:32:04 <startling> can I provide a default implementation for when Typeable exists?
19:32:11 <Cale> Oh, perhaps just a phantom type?
19:32:15 <startling> Cale: yeah.
19:32:21 <Cale> uhhh
19:32:24 <startling> https://hackage.haskell.org/package/tagged-0.7/docs/Data-Tagged.html
19:33:19 <startling> I'd rather not require Typeable. It's just for pretty-printing existentially-quantified things.
19:33:53 <startling> I guess I can have name = Tagged "dunno"
19:34:46 <Cale> Well, that's pretty much exactly what Typeable is for: recovering type information you've thrown away via existentials
19:35:27 <startling> That's fair.
19:35:37 <Cale> But I seem to recall people were working on a new feature for GHC to allow default implementations in class declarations which have more restrictive types than the normal type of the method
19:35:45 <Cale> I'm not sure if it's in 7.6 or not
19:36:02 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#class-default-signatures
19:36:04 <startling> I thought so too, but I can't find it.
19:36:05 <Cale> ah, yes it is
19:36:10 <mikeplus32> i think you can do what you said: default name :: Typeable r => Tagged r String; name n' = show (typeOf n) where getType :: Tagged s a -> s; getType = undefined; n = getType n'
19:36:21 <startling> ah !
19:42:30 <chrisdone> oh hell yeah
19:44:12 <lpaste> chrisdone pasted “Hell” at http://lpaste.net/95994
19:44:25 <chrisdone> check it out ^
19:45:14 <lpaste> chrisdone revised “Hell”: “More output” at http://lpaste.net/95994
19:45:49 <intrados> Is there something like liftIO that will lift a function `m a -> m b` to `t m a -> t m b` ?
19:45:57 <chrisdone> haskell shell! auto-completion on files in the current directory and pwd awareness in the prompt
19:46:17 <startling> Has anyone written a fancy database layer with TypeFamilies etc a la tables?
19:46:35 <Aetherspawn> chrisdone: hah thats cool
19:46:56 <Aetherspawn> gogo haskell shell
19:46:57 <Aetherspawn> hash
19:46:59 * chrisdone laughs  maniacally
19:47:24 <chrisdone> yeah that exists as vaporware http://nellardo.com/lang/haskell/hash/
19:47:56 * chrisdone … . o O ( if a project turns to vapour in the forest with nobody there to not write it, did it ever exist at all? )
19:48:06 * startling . o O ( "exists as vaporware"? )
19:48:07 <oio_> can i a program delete itself? its executable?
19:48:27 <startling> oio_, yes, but you might have trouble finding the executable.
19:49:02 <oio_> startling: will be copied elsewhere..
19:49:25 <startling> oio_, not sure what you mean.
19:50:08 <oio_> startling: though you were joking
19:50:26 <oio_> startling: so can you show me how?
19:52:46 <startling> oio_, removeFile myExecutable
19:52:57 <Aetherspawn> chrisdone: ls :: IO [ShowWithOptions File], unshow :: ShowWithOptions a -> a
19:53:28 <oio_> startling: DeleteFile "sp.exe": permission denied (Access is denied.)
19:53:45 <startling> oio_, it generally won't interrupt the program -- the program is stuck in memory somewhere.
19:53:57 <startling> oio_, oh, windows.
19:54:12 <startling> I don't know anything about windows executables and permissions.
19:54:12 <Aetherspawn> mapM_ (\(unshow -> x) -> rm x) ls :P
19:54:19 <Aetherspawn> bleh
19:56:45 <jle`> has any work been done on writing a fusionable prefix sum for repa
19:56:47 <chrisdone> > putStrLn
19:56:48 <lambdabot>   <[Char] -> IO ()>
19:56:53 <chrisdone> ^ where are these Show instances defined?
19:57:32 <startling> @source Show (a -> b)
19:57:32 <lambdabot> Unknown command, try @list
19:57:37 <enthropy> > show (typeOf putStrLn)
19:57:38 <lambdabot>   "[Char] -> IO ()"
19:57:40 <startling> @src Show (a -> b)
19:57:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:58:03 <chrisdone> enthropy: ahh, thanks
19:58:23 <enthropy> well that doesn't say where the  instance Typeable a => Show a  is
19:59:01 <chrisdone> that's in Data.Typeable via the type reps, no big deal
19:59:12 <jle`> enthropy: thank you for the tip
20:00:21 <enthropy> jle`: normally I think you'd just do :type putStrLn  in ghci
20:00:52 <jle`> been wanting a way to "show" a function, like ocaml does
20:01:04 <jle`> although admittedly it's the same as :t
20:03:12 <enthropy> not everything has a Typeable instance, but it's easy enough to make them
20:04:30 <startling> What's the best way to write a Typeable r => Tagged r String containing the name of the type r?
20:05:28 <startling> I have "let x :: Typeable r => r -> Tagged r String; x = Tagged . show . typeOf; in x undefined" but that's kind of ugly
20:08:32 <enthropy> startling: fmap (show . typeOf) (Tagged undefined) ?
20:08:54 <enthropy> but I think that needs a type signature
20:09:46 <enthropy> fmap (show . typeOf) (tagSelf undefined)
20:09:51 <startling> oh, nice.
20:21:35 <slack1256> What is the most popular way to do GUIs in haskell?
20:21:41 <slack1256> wxwidgets bidings?
20:25:58 <Kaidelong> slack1256: probably gtk2hs
20:26:30 <Kaidelong> if only because it is easier to install and use as a library than qthaskell or wxhaskell
20:27:13 <Kaidelong> wxhaskell is probably your best option iff you can actually get it working and compile your wxhaskell program
20:28:42 <Kaidelong> whether you go qt, wx, or gtk, cabal may not be that much help, see about building the bindings from source yourself
20:29:31 <Kaidelong> qthaskell doesn't have a cabal package at all, gtk2hs' one is currently broken last I heard, and wxhaskell is just generally a pain to install
20:36:30 <oio_> how can i create a thread procces? that waits for main to close?
20:38:35 <c_wraith> when main completes, the program terminates
20:39:34 <c_wraith> oio_: how about explaining what you want to do, rather than how you want to do it.
20:40:54 <oio_> c_wraith: i want to delete the programs executable
20:41:33 <c_wraith> that's easy on unix systems. It's more or less impossible on windows without running a second program
20:41:46 <oio_> c_wraith: on windows :(
20:42:04 <geekosaur> thread won't do it then, has to be a separate executable
20:42:23 <geekosaur> windows locks stuff that is open (running executables, open files, etc.)
20:42:35 <oio_> c_wraith: can't i make other thread proccess?
20:42:42 <geekosaur> a thread is not a process
20:43:00 <geekosaur> a thread is a separate execution context within a single process
20:43:06 <geekosaur> threads can't do what you want, processes can
20:43:13 <geekosaur> and "thread process" is nonsense
20:43:35 <oio_> mm
20:44:08 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html
20:44:41 <c_wraith> the typical pattern for something like this on windows is writing a simple program that runs another program, then deletes the executable when it completes
20:45:38 <oio_> c_wraith: so one stays ?
20:45:38 <c_wraith> You often dress it up a bit - only delete if the program completes with the right exit code, allow the program to run to be passed in on the command line, etc.
20:46:17 <c_wraith> Yes, but the program that stays is completely trivial.  Usually you see this kind of pattern in patching software built into games, where it patches the executable, instead of deleting it.
20:46:21 <c_wraith> But the limitations are the same
20:46:46 <geekosaur> oio_, consider installers. the installer .exe is still around after you run it although the programs that it extracts and runs to actually do the installation are gone
20:47:42 <cschneid> I'm spoiled by Ruby's Arel gem (the sql logic backend for activerecord). Is there a nice DSL for building SQL like that in haskell? I'm not looking for strict type checking so much as a nice programmer way of combining clauses into an AST which gets spooled out as SQL at the end
20:47:55 <geekosaur> this is a limitation built into windows and is one of the reasons that a bunch of stuff is done during reboot when you install windows patches
20:48:34 <geekosaur> because even microsoft can't circumvent it
20:49:52 <oio_> geekosaur: http://stackoverflow.com/questions/16057433/how-an-application-can-delete-itself-and-its-containing-folder-in-c
20:50:11 <ParahSailin> is there some st monad magic that could be used to generate graphs containing cycles?
20:50:33 <geekosaur> oio_: yes, that just sais what I just told you
20:51:03 <geekosaur> and the MoveFileEx reference is to the mechanism that windows patches use to make changes during reboot before anything else is running
20:51:09 <c_wraith> ParahSai1in: sure there is.  But you also don't need ST.  knot-tying suffices
20:51:31 <Luke> http://hackage.haskell.org/package/heist-0.13.0.2/docs/Heist-Compiled.html anyone see a way to bind a Splice while inside a RuntimeSplice?
20:51:51 <NemesisD> why do i need flexible contexts for showInfo :: (MonadReader HAConfig m) => m (Either HAError ShowInfoResp)
20:52:05 <oio_> geekosaur: will look
20:52:20 <c_wraith> NemesisD: because you have one concrete type in the arguments to the MonadReader class
20:52:37 <c_wraith> NemesisD: to avoid FlexibleContexts, all type arguments to a class must be type variables
20:52:49 <ParahSailin> c_wraith, isn't that more for toy structures like let {l0 = 0: l1; l1 = 1 : l0}
20:53:33 <NemesisD> hmm so i should probably not pursue that because this function needs a concrete type for the reader
20:53:34 <c_wraith> ParahSai1in: You can use knot-tying to create arbitrary graphs, even with a structure that isn't known at compile-time
20:53:43 <ParahSailin> ah
20:53:50 <c_wraith> NemesisD: FlexibleContexts is totally harmless.  Just enable it. :)
20:55:24 <heatsink> But do you actually want to use knot-tying to create arbitrary graphs?
20:55:37 <c_wraith> sometimes.
20:55:43 <c_wraith> depends on what you want to do with the graph
20:57:09 <heatsink> If you do that, then you must use certain values lazily in your code
20:57:15 <heatsink> but Haskell has no way of statically enforcing that
20:57:23 <heatsink> and it's terribly inconvenient to debug
20:57:29 <heatsink> <<loop>>
20:57:53 <c_wraith> well, yes, I'd make sure to abstract graph construction into a function that just works, regardless of what inputs it is passed.
20:58:12 <ParahSailin> what if you wanted to optimize a trie defined as regular ADT such that modifying nodes would not always require regeneration of a new root
20:58:32 <c_wraith> then you wouldn't be using immutable data
20:58:49 <ParahSailin> is there some st monad trickery to do this sort of thing?
20:59:00 <c_wraith> there's STRef.  You don't need anything more
20:59:51 <ParahSailin> how do i convert all those STRefs into pure ADT structures when i return the result from ST land
21:00:15 <c_wraith> I strongly suspect that whatever you're thinking doesn't work.
21:00:45 <heatsink> Do you want to build a mutable data structure and then freeze it?
21:00:51 <ParahSailin> right
21:01:17 <c_wraith> because if you ever want to thaw it, you've just lost everything
21:02:03 <heatsink> There's library support for freezing arrays
21:02:19 <heatsink> For other data types, you would have to do the freezing yourself
21:02:21 <ParahSailin> suppose i did not want thaw to be a fast operationm but just wanted a fast ST way to generate that immutable structure
21:03:09 <heatsink> Maybe parameterize tree nodes over the type of their child reference
21:04:17 <c_wraith> I'd honestly just figure out how to solve it with knot-tying.
21:04:29 <c_wraith> It'll be way easier to use.
21:06:10 <heatsink> data FixRef t a = FixRef (IORef (t FixRef a)) (IORef (Maybe (t Id a)))
21:07:49 <heatsink> Something like that should work.  Each FixRef has references to the mutable and pure values.  Freezing involves replacing each FixRef with the pure value it refers to.
21:08:00 <heatsink> (and creating the pure values, of course)
22:03:24 * hackagebot ListLike 4.0.1 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-4.0.1 (JohnLato)
22:04:56 <applesauce> will learning haskell help feed me one day?
22:06:34 <carter> good engineering work pays well
22:14:10 <ion> @faq Can Haskell feed me one day?
22:14:10 <lambdabot> The answer is: Yes! Haskell can do that.
22:15:21 <emaphis> Yummy monads!
22:27:40 <Platz> http://bpodgursky.com/2013/08/21/average-income-per-programming-language/
22:39:10 <Aetherspawn> ;__;
22:39:16 <Aetherspawn> Platz: thats depressing as fuck
22:44:01 <johannesbodannes> Platz: UGHHHHH it makes me queasy with disgust that Java pays so highly
22:44:05 <Platz> since those are open-source projects, i think some financial companies may be underrepresented
22:44:21 <Platz> which are more favorable to FP
22:45:13 <startling> I should learn java.
22:45:22 <johannesbodannes> A knuckle-dragging idiot can learn java
22:45:29 <_di> learn scala
22:45:50 <startling> johannesbodannes, I don't know why that would be a discincentive.
22:46:13 <_di> http://www.jobserve.com/gb/en/JobSearch.aspx?shid=6DBBE2C56F1B182441
22:46:24 <johannesbodannes> i guess it isn't really, i just find it a really ugly language. like the complete lack of delegates
22:46:27 <startling> What are the actionscript jobs? Game dev?
22:46:40 <Platz> could probably make a lot if you know jvm bytecode
22:46:40 <_di> startling: flash banners
22:46:42 <Adeon> what about xslt
22:46:42 <_di> *ads
22:46:46 <startling> dilinger: heh
22:46:49 <startling> er
22:46:51 <Adeon> I thought xslt barely qualifies as programming language
22:46:56 <startling> _di: heh
22:47:02 <_di> ;)
22:47:03 <startling> dilinger: sorry, mistab
22:47:20 <johannesbodannes> people actually engineer JVM bytecode directly?
22:47:48 <johannesbodannes> is this for reverse engineering or something?
22:47:50 <Platz> no, but they stare at it when their programs are not behaving nicely
22:48:05 <johannesbodannes> that sounds awful
22:49:27 <startling> I wonder what the average income for writing GHC Core is.
22:49:30 <simpson> johannesbodannes: I've worked on several reverse-engineering projects that disassemble JVM bytecode. It's really not that bad.
22:49:42 <_di> jvm bytcode spec are not that awful
22:53:24 <augur> edwardk: can i ask you some questions about this paper you linked me to?
22:53:32 <levi> johannesbodannes: Probably less awful than staring at disassembled x86 core dumps.
22:53:58 <johannesbodannes> that's true i guess
22:54:42 <startling> Is there a way to derive Show in the GeneralizedNewtypeDeriving way rather than the ordinary way?
22:55:21 <augur> edwardk: actually nevermind, i sorted it :p
22:55:44 <chrisblake> what are "*>" and "<*" called?
22:56:06 <_di> *><*
22:56:16 <NemesisD> ugh. so BasicPrelude exports a FilePath type which is not an alias to string
22:56:27 <startling> chrisblake: I say "keeping" and "discarding".
22:56:34 <NemesisD> yet everything that uses filepaths uses the string verison in other libraries
22:56:38 <startling> "a keeping b", "a discarding b"
22:56:41 <arkeet> I say "*>" and "<*"
22:56:49 <Adeon> keep the left one, keep the right one
22:56:49 <NemesisD> and their show osn't the string equivalent. how the heck are you supposed to use their FilePath
22:57:06 <chrisblake> okay, cool. I just had no idea how to talk about them in a real life sentence.
22:57:08 <startling> NemesisD, don't use alternative Preludes ?
22:57:09 <chrisblake> thanks, startling :)
22:57:29 <augur> "a keeping b" sounds wrong, but
22:58:00 <NemesisD> startling: it is so useful except for this one part. i don't accept your answer. obviously advocates of BasicPrelude must use FilePath somehow
22:58:28 * hackagebot easy-api 0.1.0.0 - Utility code for building HTTP API bindings more quickly.  http://hackage.haskell.org/package/easy-api-0.1.0.0 (IanDuncan)
22:59:47 <startling> NemesisD, it's IsString, so you can use OverloadedStrings or fromString
22:59:53 <startling> (from Data.String)
23:00:20 <startling> I guess there's no toString though
23:00:34 <startling> tail . init . show
23:00:38 <startling> :x
23:00:38 <NemesisD> startling: exactly
23:01:02 <startling> It's really strange that they don't export a constructor.
23:02:03 <startling> > tail . init . show $ "NemesisD"
23:02:05 <lambdabot>   "NemesisD"
23:02:28 <NemesisD> yeah i'm really curious about that. the show of filepath is "FilePath \"derp\"" :(
23:02:41 <startling> NemesisD: >:(
23:03:25 <NemesisD> chrisdone, mgsloan: ping! i imagine you guys use this alternate prelude stuff at fpcomplete
23:03:49 <NemesisD> i say this like there is some mandate there that all of snoyberg's libraries must be used
23:04:19 <startling> heh
23:04:46 <NemesisD> i'd ping johnw too but i'm pretty sure he's asleep in his time zone
23:04:58 <johnw> I'm sitting right here :)
23:05:23 <NemesisD> :O
23:05:29 <startling> he's awake in every other time zone :)
23:05:37 <NemesisD> lol
23:05:48 <NemesisD> do you know anything about BasicPrelude/CorePrelude and friends?
23:06:12 <johnw> only a little bit
23:07:23 <NemesisD> it seems like they may be unusable. they don't export a constructor and there's seemingly no way to turn them into a String (which is what everything outside of that ecosystem means by FilePath) shy of parsing it out of the Show instance
23:07:41 <NemesisD> erm they aren't unusable, FilePath is
23:08:07 <NemesisD> i can file a ticket with them i was just curious if anyone knows what im missing
23:08:12 <lykos_> Hello everyone
23:08:30 <startling> I don't even understand why you would hide that constructor.
23:08:51 <johnw> sure, I'd file a ticket
23:09:39 <lykos_> I'm trying to find out a strict way to evaluate something, with a monadic action executing just before it returns
23:09:56 <arkeet> NemesisD: FilePath is re-exported from Filesystem.Path
23:09:59 <lykos_> I'm using gtk2haskell/cairo
23:10:13 <NemesisD> lol ok so you can get at the string version via its Arguable instance from ReadArgs.name
23:10:35 <arkeet> heh
23:10:45 <startling> arguably.
23:10:51 <arkeet> what the heck is arguable
23:10:51 <lykos_> I'm making a game that draws an updating world to a window
23:11:07 <NemesisD> ahh ok so Filesystem.Path.CurrentOS.encodeString
23:11:10 <startling> arkeet: it sounds like a bad joke, doesn't it.
23:11:14 <arkeet> it is.
23:11:20 <lykos_> I call  (drawWindowClear win), then ( renderWithDrawable win newImage)
23:11:32 <NemesisD> FilePath is arguably a string
23:11:34 <arkeet> looks like a thing with a prism to String
23:11:37 <arkeet> heh
23:11:46 <startling> arkeet, they don't use prisms rhough
23:11:49 <arkeet> I know.
23:11:52 <arkeet> but essentially it is that.
23:11:54 <lykos_> but what happens is the screen blinks for a split second, because it clears then waits for newImage (which is of type Render() ) to evaluate
23:12:21 <lykos_> any ideas how I can ensure that it clears the screen right before it renders?
23:12:35 <startling> lykos_: what library are you using?
23:12:42 <startling> lykos_, (you might like gloss on hackage)
23:12:54 <lykos_> I'm porting my game over from gloss currently
23:12:59 <startling> oh heh
23:13:01 <lykos_> to have better event handling and such
23:13:01 <lykos_> :)
23:13:10 <chrisblake> can you use a value constructor in a type signature?
23:13:18 <chrisblake> Just a -> Int , for example?
23:13:23 <arkeet> no
23:13:29 <startling> chrisblake, with DataKinds or PolyKinds, but I'm not sure Just a -> Int makes sense.
23:13:30 <arkeet> what would that mean?
23:13:39 <startling> other than, like, const 2
23:13:43 <arkeet> startling: that would be a kind error if you used DataKinds.
23:13:53 <chrisblake> it doesn't mean anything in particular, I was mostly concerned with if it was possible
23:14:05 <chrisblake> so why *isn't* it possible?
23:14:06 <startling> arkeet: would it? I don't see it.
23:14:09 <chrisblake> where's the limitation?
23:14:13 <arkeet> chrisblake: because it doesn't make sense.
23:14:17 <startling> chrisblake, because types and values are separate in Haskell.
23:14:19 <arkeet> startling: look at the kind of (->)
23:14:27 <startling> arkeet: oh, I see.
23:14:31 <chrisblake> ah, I don't konw about kinds yet :)
23:14:37 <arkeet> chrisblake: don't worry about us.
23:15:00 <chrisblake> so why doesn't Just a -> Int make sense?
23:15:05 <chrisblake> it isn't a case of pattern matching?
23:15:08 <startling> chrisblake, what would it do?
23:15:11 <chrisblake> (on the type level?)
23:15:14 <NemesisD> well mystery solved. im off. thanks guys
23:15:23 <arkeet> it doesn't make sense because Just a is a value and -> needs types.
23:15:23 <chrisblake> okay, what about Just Int -> Int ?
23:15:27 <startling> chrisblake, what is a value of type Just a?
23:15:30 <NemesisD> /quit
23:15:51 <chrisblake> is Just Int -> Int a dependent type, rather?
23:15:53 <arkeet> :k (->)
23:15:54 <lambdabot> * -> * -> *
23:16:00 <startling> chrisblake, not really.
23:16:25 <chrisblake> startling: it seems to be a "constraint" on the Maybe type that only works on Justs?
23:16:45 <startling> "(Just a : Maybe b) -> ..." would be the dependent way to do it, I guess.
23:16:45 <arkeet> I don't think there's any sensible way to make it mean that.
23:16:59 <arkeet> if you want to constrain your Maybe values to be Justs, then don't use Maybe.
23:17:18 <startling> You could do something like "Monoid a => (Just a : Maybe Type) -> a" in e.g. Idris.
23:17:26 <startling> But yeah, not really relevant.
23:17:42 <startling> chrisblake: the way you say "this function only works on Justs of Maybe a" is "a -> Int".
23:17:59 <chrisblake> I'm mostly curious as to why value constructors don't make sense in type signatures.
23:18:02 <chrisblake> because I'm not really sure why.
23:18:06 <arkeet> because values and types live in separate worlds.
23:18:16 <startling> chrisblake, because types and values are different in Haskell.
23:18:36 <chrisblake> startling: okay, I get that. but how do we get from there to it not making sense?
23:18:36 <arkeet> those worlds basically don't interact.
23:18:48 <startling> chrisblake, what's a value of type Just a?
23:19:00 <chrisblake> startling: oh, okay
23:19:00 <arkeet> or Just Int, for concreteness.
23:19:06 <chrisblake> that starts to make it make some sense
23:19:09 <startling> arkeet: that's even worse. :(
23:19:11 <chrisblake> a type of a type doesn't make sense
23:19:22 <arkeet> startling: it is?
23:19:44 <startling> I guess Just Type would make more sense.
23:19:49 <chrisblake> so they'd have to be a "subtype" of Just for it to be a type of something.
23:20:11 <chrisblake> okay, I think I get it now, guys.
23:20:45 <startling> chrisblake: it's not that "types of types" don't make sense, it's that "values of types" doesn't.
23:20:58 <jle`> that income vs. programming language article was pretty scientific.
23:21:16 <startling> There's a couple senses of "of" involved, so that's a confusing way to say it.
23:21:48 <startling> "values of values", I guess.
23:22:07 <structuralist> how do I evaluate type level functions with promoted types?
23:22:15 <structuralist> I get "Expected kind `OpenKind', but `Max (S Z) (S (S Z))' has kind `N'"
23:22:25 <arkeet> structuralist: show code?
23:22:32 <arkeet> how are Max, S, Z defined?
23:22:50 <arkeet> also what context are you using it in
23:22:51 <arkeet> so, show code.
23:23:15 <structuralist> http://lpaste.net/95996
23:23:40 <arkeet> that doesn't answer the last question.
23:23:46 <structuralist> running ":t undefined :: (Max ('S 'Z) ('S ('S 'Z)))"
23:23:47 <structuralist> in ghci
23:23:59 <arkeet> oh, well all values have types with kind *
23:24:01 <arkeet> so that's obvious.
23:24:03 <structuralist> right
23:24:08 <structuralist> so how do I get it to evaluate
23:24:17 <arkeet> uh.
23:25:26 <arkeet> you could have a singleton thing.
23:27:15 <arkeet> fromSing :: p (a :: N) -> N
23:27:31 <arkeet> uh
23:27:36 <arkeet> I guess you'd need a class for that.
23:27:41 <arkeet> http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html
23:28:02 <augur> structuralist: so why the name
23:28:11 <structuralist> name for?
23:28:15 <augur> your name
23:28:17 <augur> "structuralist"
23:28:22 <structuralist> oh
23:28:28 <structuralist> mathematical structuralism, category theory
23:28:33 <augur> aha
23:28:44 * arkeet doesn't know what else structuralist means.
23:28:52 <arkeet> I mean "structuralist"
23:28:55 <augur> i have an issue of philosophiae mathematica out from the library all about structuralism
23:29:14 <arkeet> oh, I guess it's a thing outside mathematics.
23:29:19 <augur> arkeet: structuralism, as a term, originated in linguistics, and spread through anthropology, sociology, and apparently also to mathematics!
23:29:40 <structuralist> yep
23:29:43 <augur> tho the idea of structuralism pre-dates the linguistic origin of the term
23:29:44 <structuralist> I heard it from awodey
23:29:56 <arkeet> I heard it from reading nlab. :<
23:30:08 <augur> nlab's a good source
23:30:15 <structuralist> <3 nlab
23:37:53 <oio_> How can i hide the CMD console ? in windows
23:41:36 <ReinH>  
23:43:43 <timemage> oio_, ther's a ShowWindow api function to show/hide windows.  getting the window handle of a console process used to be a pain, maybe still s.  involved setting the console title and then enumerating windows searching for a token in the title.  ask #winapi
23:44:08 <arkeet> I'm guessing he means he compiled a program for windows and it pops up a cmd window when he runs it.
23:44:18 <arkeet> and doesn't want that.
23:44:30 <arkeet> I don't know the answer.
23:44:57 <arkeet> the solution isn't windows api though.
23:45:33 <arkeet> e.g. with mingw gcc you'd use -mwindows to make it not a console exe
23:46:03 <arkeet> oio_: http://www.haskell.org/haskellwiki/Windows When compiling a program with GUI, use the compiler option -optl-mwindows to prevent a DOS-shell being displayed behind your GUI.
23:46:13 <arkeet> (This passes the option -mwindows to the linker.)
23:46:18 <arkeet> there's the answer to what I think you were asking.
23:47:17 <timemage> arkeet, i took the question literally.  it used to come up fairly often regardless of the lanuage involved.
23:47:18 <oio_> mm
23:48:11 <timemage> arkeet, "hide" vs "not create"
23:48:32 <oio_> done
23:49:43 <lightquake> so how safe is the unsafePerformIO top-level MVar sort of hack?
23:50:05 <arkeet> reasonably safe.
23:50:08 <arkeet> provided you NOINLINE it.
23:50:27 <smith_>  Is the implicit maybe stuff for view patterns not implemented? Trying to use '=>' in a view pattern is giving me a parse error.
23:50:39 <arkeet> smith_: code?
23:51:00 <smith_> arkeet: Sec, let me condense it a little.
23:51:03 <arkeet> oh you mean that thing.
23:51:24 <arkeet> no that's not implemented.
23:51:30 <smith_> arkeet: Aw. Thanks.
23:51:47 <smith_> Would've been good to know before I used it all over the place, haha :)
23:51:49 <supki> what's implicit maybe stuff?
23:52:02 <arkeet> https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#ImplicitMaybe
23:52:03 <smith_> supki: In here: https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
23:52:15 <arkeet> "Next, we describe two further syntactic extensions that we will implement."
23:52:19 <arkeet> implying it's not implemented yet. :p
23:52:29 <arkeet> consult the ghc manual for what exactly is supported.
23:52:39 <arkeet> user's guide.
23:52:47 <arkeet> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html#view-patterns
23:52:56 <smith_> Ahh, I misunderstood--I thought that was written from a perspective of before any implementation had begun.
23:53:00 <smith_> Thanks!
23:53:33 * hackagebot language-objc 0.4.2.7 - Analysis and generation of Objective C code  http://hackage.haskell.org/package/language-objc-0.4.2.7 (JohnLato)
23:53:42 <smith_> Any word on whether it will ever make it in there?
23:55:06 <arkeet> no idea.
23:55:29 <smith_> Okay. Thanks for the help
