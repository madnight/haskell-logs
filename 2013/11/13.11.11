00:00:25 <shiona_> courseram about haskell?
00:00:36 <shiona_> which course is that
00:00:52 <external-reality> No, this one Reactive programming with Scala
00:01:07 <external-reality> However, we are just writing property tests for this first assignment
00:01:21 <shiona_> ah, I though about taking that too. Haven't yet had the time to do the exercise though
00:02:00 <external-reality> I have spent more time than I would like to admit doing the exercise.
00:02:27 <external-reality> It took time for me to come to terms with Scala's syntax. Never really used it before.
00:02:30 <shiona_> I took the intro to scala though and I must say it's not a language I'm too keen on learning
00:03:24 <external-reality> I'm kind of feeling the same way about Scala but I don't want to be that guy who doesn't give it a shot just because I like Haskell.
00:03:36 <albertid> I'm taking the course too.. using scala for the first time... the syntax is kinda messy, expecially function signatures...
00:04:39 <external-reality> I have to find a property to flex bogus binomial heap #4
00:05:10 <albertid> well I planned to do the exercises tonight
00:05:32 <albertid> did you create a generator?
00:05:46 <external-reality> Yes, I did create a generator.
00:06:07 <albertid> did you use meld?
00:06:09 <alexander__b> does anyone know where edwardk got that beautiful =<< hoodie he's wearing in the lenses video on youtube?
00:06:16 <alexander__b> I want some haskell gear too :-D
00:06:24 <external-reality> I did
00:06:31 <sopvop> which talk?
00:07:11 <external-reality> Without meld I would end up with one node per heap
00:07:31 <alexander__b> sopvop: https://www.youtube.com/watch?v=cefnmjtAolY if you were talking to me
00:08:04 <sopvop> Thanks.
00:08:26 <sopvop> it's actually a  \>>= not a =<< :)
00:08:28 <albertid> external-reality, but.... what if the meld implementation is bogus. then you may not create all possible heaps?
00:08:41 <alexander__b> sopvop: ah, yes of course, hehe
00:09:12 <albertid> external-reality, anyhow, I'll only take look at it tonight
00:17:25 <external-reality> albertid, meld is busted in two of the bogus cases
00:20:17 * hackagebot bifunctors 4.1.1 - Bifunctors  http://hackage.haskell.org/package/bifunctors-4.1.1 (EdwardKmett)
00:20:17 * hackagebot zasni-gerna 0.0.3 - lojban parser (zasni gerna)  http://hackage.haskell.org/package/zasni-gerna-0.0.3 (YoshikuniJujo)
00:20:34 <external-reality> In those cases properties wont hold for the generated heaps. I guess you can't ask for correctly generated heeps when your definition of a heap is broken.
00:40:14 * hackagebot threads 0.5.0.3 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.5.0.3 (BasVanDijk)
00:43:17 <cbw> Do you guys use Sets in data definitions?
00:43:45 <cbw> It seams cleaner to make instances of them if Sets are not used
00:45:12 <danr> cbw: it happens. I found this in my codebase data Subtheory = Subtheory { defines :: Content , clauses :: [Clause LogicId] , deps :: Set Content }
00:45:44 <danr> the only instance for it is Show though
00:45:55 <danr> what do you want to use Set data types for?
00:46:50 <cbw> data NFAe q s = NFAe {
00:46:52 <cbw>     states  :: Set q,
00:46:54 <cbw>     symbols :: Set s,
00:46:56 <cbw>     delta   :: q -> Maybe s -> Set q,
00:46:58 <cbw>     start   :: q,
00:47:00 <cbw>     final   :: Set q
00:47:02 <cbw>     }
00:47:19 <cbw> Without sets using NFA is much easer
00:47:56 <cbw> NFAe "ABC" "01" delta' 'A' "C"
00:48:00 <danr> I would start with just using lists
00:48:18 <cbw> what do you mean start
00:48:41 <danr> well, if you find out that it is too inefficient for your needs, profile it and change it accordingly
00:49:20 <external-reality> I use sets if what I am modeling is actaully a set of things.
00:49:57 <cbw> If haskell just had builtin set notation
00:50:00 <Twey> cbw: It may make the definition messier, but it makes the code cleaner to not have to worry about permutations (compared to lists)
00:50:38 <danr> well, there are a few set implementatins in Haskell
00:50:47 <Twey> If you don't care about notions of size or equality, lists might not be so bad
00:51:14 <arkeet> you could use OverloadedStrings and define a fromString instance for Set Char...
00:51:17 <arkeet> er, IsString
00:51:24 <arkeet> where fromString = fromList
00:51:35 <Twey> arkeet: Nice.  I think.
00:52:01 <sbidin> How about using OverloadedLists? Are those even available yet?
00:52:07 <arkeet> not yet
00:52:24 <cbw> it would be nice if you could do {1,2,3}
00:53:14 <arkeet> they're coming in 7.8
00:53:25 <cbw> https://github.com/cameronbwhite/ComputationalStructures/blob/master/Haskell/NFAe.hs
00:53:43 <cbw> thats my code BTW
00:54:21 <danr> cbw: right, if you're doing union etc on NFAs, Sets indeed sounds more appropriate
00:55:13 <cbw> arkeet: Set notation is comming in 7.8 you say?
00:58:44 <supki> cbw: no, overloaded list notation, which you could use for sets
00:59:43 <supki> @google OverloadedLists
00:59:43 <lambdabot> http://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
01:00:13 <cbw> https://ghc.haskell.org/trac/ghc/wiki/Status/Oct13
01:00:30 <tdammers> that sounds nice
01:00:59 <Ove_> STEFAN OCH KRISTER
01:01:09 <Ove_> ÄTER KLISTER
01:01:13 <Ove_> SNIFFAR ISTER
01:02:17 <cbw> This extension allows programmers to use the list notation for construction of structures like: Set, Map, IntMap, Vector, Text and Array
01:16:22 <cbw> Idea! I could use List.intersectBy (==) ... and List.unionBy (==)
01:16:32 <TravisD> I've taken a few stabs at Haskell. On my last attempt I actually managed to write a non-trivial experiment for my thesis. Can anyone suggest a book that would help me get closer to using Haskell practically?
01:16:55 <TravisD> I feel like I understand it well enough to think about things very abstractly, but I struggle with actually doing things
01:17:09 <TravisD> (sorry for the vague question)
01:17:10 <danr> TravisD: what did you read so far?
01:17:22 <zomg> Real World Haskell has examples on variety of "real" problems
01:17:40 <zomg> though personally I would recommend just doing stuff, at least for me that's the best way to learn stuff like that =)
01:17:43 <danr> perhaps the best is to read some actual code, browse hackage and read the source of packages that interests you
01:17:48 <cbw> TravisD: watching the videos found on this page helped me http://www.cs.nott.ac.uk/~gmh/book.html
01:17:48 <TravisD> danr: I've read a few chapters of Real World Haskell, and a few other things that I can't remember the names of
01:18:33 <cbw> Now I am writting every math algorithm I can think of.
01:18:33 <TravisD> just a sec
01:18:59 <TravisD> ah, Programming Haskell is one of the books I looked at :)
01:19:09 <arkeet> cbw: such operations on lists are slower than on sets.
01:20:16 <TravisD> zomg: that's probably good advice
01:20:34 <TravisD> the thing that really jammed me up before was some lazy memory explosion
01:20:36 <arkeet> cbw: another option would be to use Set inside NFAe, but also write another function (Ord q, Ord s) => [q] -> [s] -> (q -> Maybe s -> [q]) -> q -> [q] -> NFAe q s
01:20:44 <arkeet> to construct such a thing using lists.
01:21:09 <TravisD> I had a surprisingly hard time writing code to efficiently compute the mean of sequence of numbers
01:21:10 <cbw> arkeet: wrapper constructor
01:21:10 <arkeet> or something along those lines.
01:21:12 <arkeet> yes
01:21:25 <cbw> I like it
01:21:32 <arkeet> TravisD: yes, you want to be careful not to traverse the list twice. =)
01:21:45 <cbw> its what Set.fromList
01:22:05 <TravisD> arkeet: In my case I was building up an ever-larger thunk
01:22:16 <TravisD> and I needed to request strictness
01:23:44 <Twey> foldl' is appropriate here, I think
01:24:27 <TravisD> Twey: Yeah, I wrote a version using foldl'
01:24:48 <identity> TravisD: Once you start thinking about strictness/laziness whilst writing code, those problems will mostly stop coming up
01:25:52 <TravisD> identity: that's good to know
01:26:19 <TravisD> So, does anyone know of a series of exercises that would be good practice for this sort of thing?
01:27:05 <identity> TravisD: you could look over www.slideshare.net/tibbe/highperformance-haskell
01:27:18 <cbw> My python code has changed alot due to that change in thinking
01:27:21 <TravisD> thanks!
01:27:31 <identity> and www.johanntibell.com/files/haskell-performance-patterns.html
01:27:41 <identity> both of which are guides on optimization and laziness/strictness etc
01:27:46 <identity> though not really exercises
01:27:54 <TravisD> identity: that second link seems to be broken
01:28:48 <identity> hmm
01:28:49 <identity> sec
01:29:15 <identity> TravisD: oh, it's johan, not johann
01:29:21 <identity> it's because I can't copy/paste into my terminal
01:29:24 <identity> need to get that set up
01:29:27 <identity> so I'm typing links manually haha.
01:29:39 <TravisD> ah, thanks!
01:29:42 <TravisD> That was a lot of typing :)
01:30:20 <Twey> > (\(d, n) -> n / d) . foldl' (flip $ (***) succ . (+)) (0, 0) $ [1 .. 3]
01:30:22 <lambdabot>   2.0
01:30:27 <danr> identity: sleep 1 ; xclip -o
01:30:40 <danr> uh wait.
01:30:50 <danr> xdotool type $(xclip -o) :p
01:31:05 <Twey> Eww :þ
01:31:37 <danr> indeed, Twey.  get a decent terminal  :p
01:31:49 <identity> danr: aye, I know -- except I'm in a tmux session in irssi on a remote shell
01:31:51 <identity> so that sucks
01:31:57 <Twey> I'd be okay with /exec - -o xclip -o
01:32:11 <Twey> Just the xdotool hack was particularly unpleasant :þ
01:32:29 <Twey> cbw: Really?  Python code is always strict; how does thinking strictness/laziness change your Python code?
01:33:04 <Twey> identity: Only your terminal is relevant to pasting
01:33:17 <Twey> (in the simplest case)
01:34:36 <identity> Twey: really?
01:35:14 <TravisD> anyways, I'm off to bed. Thanks for the encouragement and suggestions :)
01:36:23 <Twey> identity: Yeah, it should just send whatever you paste as if you'd typed it to whatever it might be connected to
01:36:54 <Twey> There's the xterm mouse integration protocol and suchlike too, of course, but that's generally optional
01:37:21 <Twey> (er, did I reply to the right message?)
01:37:42 <identity> Twey: oh, I know I could paste with the mouse etc. Except I have a mousepad and can't get the whole paste-with-mouse thing to work
01:37:55 <identity> nor shift-insert because of the stupid fn-key shizzle
01:37:57 <identity> (for insert)
01:38:09 <identity> though it seems I should be able to get xclip to work via ssh
01:38:11 <Twey> identity: If you're on a Linux you should be able to press both buttons at once to paste
01:38:23 <Twey> xclip via SSH will be a pain
01:39:28 <identity> Twey: aye, doesn't work either
01:39:32 <identity> mousepad is silly
01:40:30 <Twey> Damn.  And you can't right-click to paste or anything?
01:41:11 <identity> Twey: nope :/
01:41:25 <identity> the mousepad is so annoying my entire 'workflow' is based around the keyboard
01:41:31 <identity> vimium for chrome, xmonad, vim, etc
01:41:34 <identity> no need for the mouse
01:42:02 <identity> only need to make urxvt work with url select so I can actually follow links in the terminal and then I'm more or less set
01:42:11 <identity> copy/paste-ing is a luxury
01:42:13 <identity> not a right!
01:43:23 <Twey> Hehe
01:45:34 <danr> identity: you can xmodmap `Insert' to some other key if "fn" doesn't work :)
01:46:04 <identity> danr: true, I could try that
01:48:30 <MercurialAlchemi> identity: try a trackpoint
01:49:01 <MercurialAlchemi> identity: I had stopped using mice until I got a Lenovo keyboard for my desktop (and then a Lenovo laptop)
01:49:26 <MercurialAlchemi> identity: it's just brilliant, you don't lift your hand from the home row, and it's very accurate
01:49:42 <identity> MercurialAlchemi: yeah, my friend has an old thinkpad with a trackpoint and he loves it compared to the mousepad
01:49:51 <identity> but my laptop doesn't have one and I prefer the keyboard at any rate
01:49:58 <BoR0> are monads generally useful as syntactic sugar?
01:50:49 <Twey> BoR0: The syntactic sugar for monads is generally useful in that many useful things that would otherwise be quite ugly are monads and can be sugared
01:50:50 <MercurialAlchemi> identity: (at least the Lenovo-made trackpoint, the Dell laptop I have makes you feel you're manipulating it with thick gloves)
01:50:52 <BoR0> I am asking this, because when I compare add with cases, and add with bind operator (for the Maybe monad), the only difference that I can see is syntactic sugar
01:51:23 <Twey> BoR0: Not all monads can be deconstructed with ‘case’
01:51:40 <MercurialAlchemi> identity: it's an acquired taste, but it's awfully addictive
01:51:42 <identity> BoR0: if you're in the maybe monad, it takes care of 'unwrapping it' for you, so to speak. you don't need to check the result
01:51:49 <identity> MercurialAlchemi: hehe :)
01:52:05 <BoR0> I can see that, but are you saying that each monad has a different role?
01:52:12 <BoR0> (depending on how we define bind I guess?)
01:52:13 <MercurialAlchemi> BoR0: monads give you early termination
01:52:16 <Twey> BoR0: Well, yes
01:52:19 <Twey> And return
01:52:23 <BoR0> I see
01:52:31 <identity> > let addMaybe x y = do { x' <- x; y' <- y; return $ x + y; } in addMaybe (Just 3) Nothing
01:52:32 <lambdabot>   No instance for (GHC.Show.Show t0)
01:52:33 <lambdabot>    arising from a use of `M8056490510967...
01:52:43 <identity> eh
01:52:54 <identity> > let addMaybe x y = do { x' <- x; y' <- y; return $ x' + y'; } in addMaybe (Just 3) Nothing
01:52:55 <lambdabot>   Nothing
01:53:00 <identity> > let addMaybe x y = do { x' <- x; y' <- y; return $ x' + y'; } in addMaybe (Just 3) (Just 3)
01:53:02 <lambdabot>   Just 6
01:53:07 <Twey> A Maybe is different to a Cont is different to an IO in the same sense that a string is different to an integer is different to a list
01:53:32 <MercurialAlchemi> BoR0: essentially you can keep chaining your maybes happily in the same function without checking if you actually got something
01:53:37 <MercurialAlchemi> BoR0: same with Either
01:53:38 <identity> ^
01:53:39 <Twey> They support some kind of operation that obeys certain laws, but that's all they have in common
01:53:48 <FireFly> A string is different to a list? :p
01:53:56 <Twey> FireFly: Potentially.  :þ
01:54:05 <BoR0> MercurialAlchemi, identity, thanks but I am looking into more general description of what really a Monad represents. I think I understand the Maybe monad
01:54:07 <identity> String = [Char], but "string" != [Char]
01:54:17 <Twey> FireFly: ‘But they're all integers under the hood!’
01:54:42 <MercurialAlchemi> BoR0: well, it kind of represents an effect
01:54:50 <identity> BoR0: Well.. On top of what everyone else has said, Monads can be viewed generally as some form of computation. What that computation does and how it behaves depends on the particular monad
01:54:51 <Twey> BoR0: A monad doesn't represent anything.  A monad is simply a type that supports the bind and return operations, nothing more.
01:55:32 <Twey> What those operations actually do or mean depends on the type in question, much as the meaning of ‘+’ depends whether you're talking about a list, an integer, &c.
01:55:47 <BoR0> aha. so we have a structure that we should define its behaviour
01:55:51 <Twey> Yes
01:56:16 <BoR0> ok, now I think I get it. this is the second time I am attacking monads and hopefully the last :D thanks guys
01:56:24 <Twey> And if you can define the monad operations on a type, you get to use all the functions that are defined to work on any monad (and do notation)
02:02:41 <nkpart> Hey. Are there GHC 7.8 RCs floating around somewhere?
02:03:37 <Twey> nkpart: There's HEAD :þ
02:05:39 <haasn> Twey: including Stream Bool? :)
02:05:41 <k00mi> wasn't 7.8 supposed to be released right after ICFP?
02:06:31 <Twey> haasn: 3D positions of electrons, in Planck lengths!
02:06:51 <Twey> k00mi: Yes, but AFAIK it hasn't happened yet
02:07:03 <Twey> There are some bugs that should be fixed before the release
02:07:08 <haasn> oh, wait, are we limiting ourselves to finite haskell programs? Wait, are all Haskell programs finite?
02:07:39 <Twey> I think the end of file is a part of the Haskell grammar :þ
02:07:40 <k00mi> ah :(
02:17:55 <haasn> oh, but I can produce a program that uses IO to output a random infinite stream of bools
02:18:00 <haasn> a finite program
02:18:11 <Twey> That is pretty much the definition of a program
02:19:13 <navaati> hi
02:19:50 <navaati> is there a package containing a type that can store a number of N bits, N being a compile-time parameter ?
02:20:59 <Twey> navaati: I guess a Vect Bool would do it
02:21:07 <Twey> But not nicely as far as I know, no
02:21:13 <navaati> uuuuh... nevermind, I'v just realized that either it would be useless, or either i'd need dependent-types...
02:21:28 <navaati> Twey: ah, clever anyway :D
02:21:53 <Twey> navaati: You can do a fair amount with DataKinds
02:26:13 <identity> How do I go about easily benchmarking several functions that take the same parameters with criterion, making it pass these arguments to each function?
02:26:34 <identity> something like defaultMainWith [my, args] benchmarks or some suh
02:26:37 <identity> such*
02:26:39 <navaati> Twey: not the case when parsing "192.168.0.2/24" would give me an ":: IPv4 24" object :)
02:28:02 <yesthisisuser> I'm trying to figure out GADTs .. I guess there is no way to achieve something like this: http://lpaste.net/95500
02:28:38 <yesthisisuser> where line 20 is the crucial part
02:28:53 <skypers> I’m reading Control.Lens
02:28:59 <navaati> so either i give up about ipv4 static safety, or either i go agda... Oh, wait, is this the eternal dilemma of the haskeller again ?
02:29:00 <skypers> edwardk: you’re such a god.
02:29:33 <alexander__b> ok so this is one of these things I have no clue how to do in haskell
02:29:43 <Narvius> navaati: Can't you simply enumerate all the possible IPv4 lengths?
02:29:44 <alexander__b> any ideas on what to look at for timing? I want to write a simple stopwatch
02:32:05 <alexander__b> basically I want to do something like "time    <- frame    [text := updateTime]" with reactive-banana-wx
02:32:06 <navaati> Narvius: there are 32 of them. Not talking about ipv6 128 possibilities
02:32:29 <klugez> alex   qqq3
02:33:09 <navaati> Narvius: and the same dependent types problem applies anyway
02:33:46 <klugez> Sorry, stupid lag in mobile internet.
02:34:01 <skypers> seriously, lens is so huge
02:34:09 <alexander__b> I guess I could use Data.Time.Clock, and then make updateTime use that
02:34:12 <skypers> I wonder how edwardk made that alone
02:35:14 <skypers> what do you think of lens?
02:35:22 <skypers> does it make your code clearer?
02:35:28 <Narvius> skypers: Yes. Very, very, yes.
02:35:33 <skypers> because ^. and .~ don’t look very friendly
02:35:42 <Narvius> That's if you used to reading lens, though.
02:35:50 <supki> you don't need to use operators if you don't want to
02:35:53 <skypers> reading lens, what do you mean?
02:35:58 <navaati> skypers: he didn't make it by himself, there are theories and papers behind it
02:36:12 <Narvius> Well, if you're used to reading code that uses lenses it's clearer than non-lens code, in my opinion.
02:36:29 <Twey> navaati: I think it's sufficient, actually
02:36:39 <skypers> I see
02:36:41 <skypers> but hm
02:36:46 <skypers> it’s _very_ huge
02:36:54 <Twey> You'd just have to deal with a ‘∀ n ∷ Nat. IPv4 n’
02:37:44 <Maxdamantus> I hope this IPv4 parser accepts "192.168.2/24" as an alternative notation for "192.168.0.2/24"
02:38:16 <navaati> Maxdamantus: dafuk no oO
02:38:51 <Maxdamantus> PING 192.168.2 (192.168.0.2) 56(84) bytes of data.
02:39:27 <skypers> ^@.
02:39:29 <skypers> holy
02:39:41 <skypers> I don’t think it will make my code clearer
02:39:54 <navaati> Twey: the trick here is I'll need to have it as a result of parsing, so basically "String -> Maybe (IPv4 m)" where m depends of the string
02:40:07 <navaati> Maxdamantus: wow, I've never seen this...
02:40:23 <Narvius> skypers: Just because you're not used to operators, doesn't mean they're not readable. :P They follow pretty sensible patterns most of the time.
02:40:35 <Twey> navaati: If you know the length at compile time you can insert a type annotation there
02:40:37 <Narvius> skypers: If you know .~ (set), then you know what +~, -~ and so on do.
02:40:50 <Twey> If you don't, you get a forall
02:40:53 <Narvius> skypers: And it's enough to know that .= is the State-monad version of .~
02:41:05 <Narvius> skypers: And you suddenly know the entire [something]= family, too
02:41:10 <skypers> hm
02:41:14 <skypers> the MonadState?
02:41:28 <Maxdamantus> the last item in the dot-separated list represents the last 2^(32 - <number of dots>*8) bits.
02:41:36 <Twey> The difference from real dependent typing is that the distinction between the string and the parameter is implicit, so you'll have to work around that
02:41:55 <Maxdamantus> so 192.168.256 == 192.168.1.0
02:42:10 <Twey> Maxdamantus: So 10.8 is a valid representation of 10.0.0.8?
02:42:16 <Maxdamantus> Twey: yes.
02:42:21 <Twey> Neat
02:42:32 <navaati> Twey: i don't know it at compile time !
02:42:34 <k00mi> you can even write IP adresses as decimals!
02:42:40 <Maxdamantus> that generalises to the "long decimal" notation.
02:42:44 <Twey> navaati: So you get a forall :þ
02:42:58 <Narvius> Hm
02:42:59 <navaati> Maxdamantus: is it in the norm ? Like, would it work everywhere ?
02:43:05 <Maxdamantus> > 10*2**24 + 8
02:43:07 <lambdabot>   1.67772168e8
02:43:13 <Maxdamantus> > 10*2^24 + 8
02:43:14 <lambdabot>   167772168
02:43:28 <Maxdamantus> navaati: it works pretty much everywhere.
02:43:31 <Twey> That's basically what you'd get with dependent typing, too, except that you'd have it as some function of the string
02:43:42 <Maxdamantus> navaati: it's specified by POSIX's inet_addr function.
02:43:47 <Twey> But the value would be unknown, so effectively you'd have to treat it as a forall
02:43:49 <navaati> Maxdamantus: damn... I'll test it on these cisco boxes next week
02:44:04 <navaati> Aaaaah, posix norm, not ivp4 rfc !
02:44:08 <Twey> Unless you could make whatever you're doing with it syntactically similar
02:44:30 <Maxdamantus> also note that all of these numbers can also be in hexadecimal or octal too.
02:44:49 <Maxdamantus> whenever you write ".0." in an IP address, it's not interpreted as decimal.
02:45:35 <skypers> <>~ is funny
02:45:43 <skypers> :t (&)
02:45:43 <lambdabot> a -> (a -> b) -> b
02:45:50 <skypers> oh
02:45:53 <skypers> :t ($)
02:45:54 <lambdabot> (a -> b) -> a -> b
02:45:55 <Narvius> reverse $
02:45:56 <Narvius> yeah
02:45:57 <skypers> funny
02:46:02 <Narvius> It's cool for writing phrases like
02:46:15 <Narvius> (1, 2) & _1 .~ 5
02:46:20 <skypers> so hm
02:46:22 <Narvius> > (1, 2) & _1 .~ 5
02:46:24 <lambdabot>   (5,2)
02:46:31 <Narvius> And you can chain it infinitely
02:46:37 <skypers> this will apply the function _1 .~ 5 to the tuple?
02:46:44 <Narvius> > (1, 2) & _1 .~ 5 & _2 .~ 5
02:46:46 <lambdabot>   (5,5)
02:46:49 <Narvius> Yeah.
02:47:01 <navaati> Twey: are you sure it would be unknown ? The goal here is being able to verify i don't add an host offset greater than (2^(32-n)) to a /n network
02:47:02 <skypers> woh
02:47:06 <skypers> that’s nice!
02:47:35 <Narvius> Though the most awesome thing about lenses is that they compose easily.
02:47:56 <Narvius> > ((((1, 2), 3), 4), 5) ^. _1._1._1._1
02:47:57 <lambdabot>   1
02:48:02 <Narvius> > ((((1, 2), 3), 4), 5) ^. _1._1._1._2
02:48:04 <lambdabot>   2
02:48:47 <skypers> that’s great
02:48:48 <navaati> (Twey : with agda I mean)
02:49:14 <skypers> > over _2 (^~ 2) ((),6)
02:49:14 <Twey> navaati: Yes, it would be unknown.  In a dependently-typed language you can say that the length is read (snd (split "/" str)) or whatever, but that doesn't help you because that value is unevaluated
02:49:15 <lambdabot>   Could not deduce (GHC.Num.Num
02:49:15 <lambdabot>                      ((GHC.Integer.Type.Integ...
02:49:57 <skypers> > ((),6) & _2 ^~ 2
02:49:59 <lambdabot>   ((),36)
02:50:11 <skypers> hey
02:50:14 <skypers> that’s AWESOME
02:50:22 <Narvius> Also, the most important operator
02:50:29 <Twey> navaati: The interesting part of having dependent types is when you have something else that has a parameter like read (snd (split "/" str)) (where ‘str’ is the same value), in which case you can use the two interchangeably even though the value is unknown
02:50:43 <skypers> it will significantly reduce the number of a { aField = otherField a + … }
02:50:43 <Narvius> > (["cake", "stuff"], 5) & _1 %~ concat
02:50:45 <lambdabot>   ("cakestuff",5)
02:50:48 <skypers> yeah
02:50:53 <skypers> user-supplied function?
02:50:59 <Narvius> It's mapping, yeah
02:51:08 <Narvius> If you watch edwardk's talk on yt
02:51:09 <skypers> great :)
02:51:14 <skypers> yt?
02:51:17 <Narvius> youtube
02:51:22 <skypers> ok
02:51:24 <skypers> thank you
02:51:34 <Narvius> You'll learn that %~ was named for "mod[ify]", since % usually is modulo
02:51:34 <Twey> navaati: In this case, in Agda as in Haskell, you'd basically have to runtime-test that the length is below n (and then, in the branch where it is, you can get a proof of that fact that adding it to the network requires)
02:51:48 <Narvius> So yeah, it's a joke.
02:51:50 <Narvius> Basically.
02:52:53 <Narvius> Also, skypers: You can automatically generate lenses for your record data types, with TemplateHaskell enabled and "makeLenses ''[name of type]"
02:52:59 <skypers> yeah
02:53:04 <skypers> it’s great
02:53:12 <skypers> I need to learn a bit TH
02:53:19 <Narvius> I didn't xD
02:54:15 <skypers> Narvius: I mean
02:54:24 <skypers> it could be useful for other purposes :)
02:57:28 <Narvius> I think TH has more applications in library rather than application programming, also after Common Lisp I probably wouldn't find TH very satisfying. :3
02:58:33 <skypers> Common Lisp?
02:58:48 <skypers> the language with (())(((()())(()()()()()(()))))))())))(()))))))))
02:58:49 <skypers> ?
02:58:53 <skypers> :––’)
02:59:01 <Narvius> Yeah, Lots of Irritating, Superfluous Parentheses
02:59:28 <Narvius> But they're not really a problem, and S-Expressions make useful macros really easy to write.
03:00:07 <Kinnison> skypers: tsk, unbalanced
03:01:07 <Twey> Macros are a syntactic answer to a semantic problem ☹
03:06:20 <identity> how would i go from a mutable unboxed vector to a list?
03:07:27 <Twey> identity: Fold over it with [] and (:)?
03:07:50 <identity> it just doesn't look like it wants to expose that kind of functionality
03:07:51 <identity> :(
03:08:31 <danr> is it an STUArray?
03:08:40 <identity> it's Data.Vector.Mutable.Unboxed
03:08:47 <identity> but it seems I may have been wrong
03:08:56 <identity> e.g. the Data.Vector interface works on the mutable unboxes ones as well
03:08:59 <identity> it would seem, anyway
03:09:09 <Twey> It's Foldable
03:09:52 <quchen> Twey: I don't see the instance though
03:09:54 <quchen> http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Unboxed-Mutable.html#t:MVector
03:10:31 <Twey> Oh, you're righ
03:10:31 <Twey> t
03:10:57 <Twey> Well, you can do it yourself with ‘null’ and ‘tail’
03:11:32 <Twey> Or just ‘read’, I guess
03:12:48 <yesthisisuser> If I have a data type which is an instance of Ord.. there is no way I can translate a value to a Int?
03:13:04 <Twey> map (($ v) . DVUM.read) [0 .. DVUM.length v - 1]
03:13:07 <yesthisisuser> I mean since I can compare two values.. hmm
03:13:15 <Twey> yesthisisuser: Not all Ords are Ints
03:13:20 <quchen> yesthisisuser: The reals are ordered, but cannot be translated to Int.
03:13:21 <Twey> E.G. Reals
03:13:30 <yesthisisuser> oh. right
03:13:34 <Twey> Or vectors with various orderings
03:13:35 <yesthisisuser> darn .. hehe
03:13:50 <Twey> Enum can be converted to Int
03:13:58 <Twey> (unfortunately)
03:14:07 <quchen> Unfortunately?
03:14:19 <Twey> quchen: Should be Integer
03:14:23 <yesthisisuser> yes Enum is what i need. thanks
03:14:40 <quchen> Oh, I thought you didn't like the conversion in principle
03:15:19 <quchen> Funny how that makes Integer not a proper instance of Enum :-)
03:15:22 <Twey> It doesn't feel right, but I think I've just been exposed to too much C-style abuse of integers; as far as I can see it's logically sound
03:15:30 <Twey> Indeed
03:17:16 <quchen> > fromEnum (2^65 :: Integer)
03:17:17 <lambdabot>   0
03:17:49 <Twey> >.<
03:18:05 <quchen> The question now is whether silent overflow or partiality is worse.
03:18:29 <donri> > toEnum maxBound :: Integer
03:18:30 <lambdabot>   9223372036854775807
03:18:39 <quchen> Haha
03:18:43 <donri> > maxBound :: Integer
03:18:44 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
03:18:44 <lambdabot>    arising from...
03:18:54 <donri> ^_^
03:18:56 <Narvius> what
03:18:58 <Narvius> how does that even
03:19:04 <quchen> maxBound :: Int there
03:19:10 <donri> > maxBound :: Int -- ;)
03:19:11 <lambdabot>   9223372036854775807
03:19:21 <Narvius> Aaah.
03:19:22 <Narvius> hah.
03:19:24 <Narvius> :t toEnum
03:19:25 <lambdabot> Enum a => Int -> a
03:19:33 <Narvius> xDDD
03:19:38 <donri> > toEnum 1 :: Bool
03:19:40 <lambdabot>   True
03:19:47 <Narvius> > toEnum 1 :: Ordering
03:19:48 <lambdabot>   EQ
03:19:52 <donri> > toEnum maxBound :: Bool
03:19:53 <lambdabot>   *Exception: Prelude.Enum.Bool.toEnum: bad argument
03:19:55 <donri> \o/
03:19:57 <Twey> quchen: Silent overflow is always worse
03:20:06 <quchen> Probably
03:20:18 <quchen> > (maxBound :: Word) + 1
03:20:19 <lambdabot>   0
03:20:22 <donri> > maxBound + 1 :: Word8
03:20:22 <quchen> :C
03:20:23 <lambdabot>   0
03:20:35 <Twey> Or rather, it's worse for things that are semantically not supposed to overflow
03:20:37 <yesthisisuser> hmm.. Data.Binary or Data.Serialize?
03:20:47 <donri> Twey: Char8!
03:21:05 <yesthisisuser> sorry. that was not a complete question but
03:21:05 <quchen> :-D
03:21:27 <donri> yesthisisuser: probably binary, unless you're only working with strict bytestrings
03:21:28 <Twey> succ ∷ Char8 → Maybe Char8
03:21:42 <yesthisisuser> donri: ah. great, thanks
03:21:46 <Twey> Or you could just cap it
03:22:00 <quchen> succ maxBound = maxBount?
03:22:01 <donri> cap is what Char8 does
03:22:07 <quchen> "bount", argh
03:22:09 <Twey> Aye
03:22:19 <Twey> donri: It is?  I thought it overflowed
03:22:30 <Twey> Why does Char8 cap but Word8 not?
03:22:58 <donri> > Data.ByteString.Char8.pack "\256"
03:22:59 <lambdabot>   Not in scope: `Data.ByteString.Char8.pack'
03:23:01 <donri> :(
03:23:17 <donri> Twey: because there is no Char8, there's only Char and Char8 are modules
03:24:23 <Twey> Ah
03:24:33 <Narvius> @djinn (Monoid m) => m [a] -> m a
03:24:34 <lambdabot> Error: Undefined type []
03:24:39 <Narvius> Cute.
03:24:43 <donri> it's a hack to use string operations and literals with bytestrings, silently truncating everything to latin-1
03:25:05 <Twey> Hideous
03:25:15 <donri> kinda wish we had python style b""
03:25:31 <quchen> What does that do
03:25:36 <quchen> byte-wise interpretation?
03:25:38 <tdammers> bytestring literal
03:25:40 <Narvius> bytestring, probably
03:25:40 <Twey> Yes
03:25:43 <quchen> b"65" = a?
03:25:46 <Twey> No
03:25:51 <yesthisisuser> Data.Binary is actually very straight-forward.. it's nice with Haskell libraries that doesn't have a 4-month learning curve .. hehe (at least for me)
03:25:59 <donri> latin-1 string literals i guess
03:26:04 <donri> not quite sure exactly how it works in python
03:26:16 <quchen> b"a with dots on it" = ä?
03:26:24 <Twey> It's like a string, but the value is the literal value of the bytes in the source file, regardless of source encoding (I think, or at least that's what it should be)
03:26:25 <tdammers> literally the bytes in the source file, I think
03:26:27 <tdammers> so usually utf-8
03:26:34 <donri> ä is in latin-1 i think
03:26:41 <quchen> It is.
03:26:47 <yesthisisuser> it is lätin :)
03:26:59 <donri> Twey: agreed. but haskell is always utf-8 i think?
03:27:02 <quchen> That is even pronounced right, yesthisisuser
03:27:07 <Twey> donri: That's irrelevant
03:28:39 <Twey> donri: The point is that if you type something like あ you don't get a character あ but the bytes that make it up
03:28:46 <donri> Twey: depends. arguably it's more useful to say it decodes as utf-8 and encodes to latin-1 at compile-time, with compile-time errors
03:29:12 <Twey> That's a subset of the functionality, though
03:29:43 <donri> Twey: but what i want is to get a compile-time error for characters outside the char8 range
03:29:49 <Twey> I don't think we really need compile-time errors to make sure that someone who explicitly marks a string as being bytes and then types in something bigger than a byte knows what they're doing :þ
03:29:53 <donri> if you want "literal bytes" there's always pack [Word8]
03:30:18 <Twey> donri: That doesn't give you a literal bytestring
03:30:26 <donri> we could easily do your suggestion without any language extensions
03:31:00 <donri> since as i said, source is always utf-8, so you just make a IsString ByteString where fromString = decodeUtf8 . fromString
03:31:20 <Twey> Aye
03:31:21 <donri> uuuh encodeUtf8
03:31:21 <alexander__b> I thought wxhaskell's start would start a... loop? I do cur <- getCurrentTime and make a label out of it. what do I need to do to make that actually rerun/redraw/update/etc?
03:31:25 <Twey> But not truncating
03:31:39 <donri> you wouldn't get any truncation with encodeUtf8
03:31:53 <Twey> Exactly
03:32:03 <donri> the problem is the current Char8 API and IsString instance does encodeLatin1With ignoreErrors, basically
03:32:10 <Twey> Right
03:32:32 <donri> and what i suggested was adding b"" as a way to keep this latin-1 assumption but with compile-time errors :)
03:32:39 <donri> could do it with QQ but ugly
03:34:21 <BoR0> why does every monad implementation require to satisfy the three laws (i.e. left unit, right unit, and associativity) ?
03:34:48 <donri> BoR0: it's not "required" but you'll get a stern look from me if you don't ;)
03:35:13 <BoR0> :) my question is, what are the gains from obeying and disobeying the laws?
03:36:09 <merijn> BoR0: The gains are "code behaves as expected", the downside of disobeying the laws is that code might behave unexpectedly
03:36:12 <donri> BoR0: it lets you reason about the monad and enables composition
03:36:49 <merijn> BoR0: i.e. imagine "do { foo; bar }" first executing "bar" or "do { foo; return () }" executing foo twice
03:37:05 <merijn> BoR0: It's almost impossible to find sensible implementations that disobey the laws
03:37:36 <yesthisisuser> Blaze.Html?
03:37:47 <merijn> BoR0: For some complicated types the laws aren't always that clear and checking they hold is a good way to stop yourself from getting code that behaves unexpectedly weird later
03:37:50 <donri> BoR0: without associativity you don't know if you can safely split "do a; b; c" into "bc = do b; c" and "do a; bc" etc
03:38:12 <yesthisisuser> Blaze is not a true monad.. or maybe that is not what you were talking about
03:38:18 <danr> this is an interesting and simple monad attempt that breaks the laws: http://stackoverflow.com/questions/7956668/is-it-possible-to-create-a-monad-that-count-the-number-of-instructions
03:38:49 <donri> yesthisisuser: i think it is a true monad, just not a monad transformer, and the monad is just a monoid and otherwise the identity monad
03:39:08 <donri> but that's no different from Writer
03:40:07 <merijn> BoR0: associativity, do you envision a case where "a >> (b >> c)" not equalling "(a >> b) >> c" is desirable? Because there's countless of edge conditions where things may break if that doesn't hold
03:43:48 <BoR0> danr, that's interesting. but, if something is implemented like that and is not a monad, what is it?
03:43:48 <donri> and unit; you *really* expect 'return' to do just that: return this value with no special effects
03:44:32 <donri> BoR0: it should be noted, it's still a "Monad", just not a "monad", although technically haskell doesn't have any "monads" only approximations of them ("Monad")
03:45:03 <donri> but if you follow the laws, the Monad is as close as it can get in haskell to a monad :P
03:45:04 <BoR0> I see, so it is still possible to have an instance of Haskell's Monad and not obey laws?
03:45:08 <merijn> BoR0: Sure
03:45:09 <donri> yes
03:45:20 <merijn> BoR0: It will just piss off other programmers/maintainers :)
03:45:44 <Twey> Yes, Haskell's type system is not sufficient to guarantee adherence to the laws
03:46:16 <BoR0> so we have Monads that make monad, and Monads that don't make monad. specifically for the Von Neumann's example, if it couldn't be implemented as monad, but it is implemented as Monad, why would this piss off other programmers?
03:46:36 <merijn> BoR0: It depends on how things break
03:46:56 <donri> BoR0: associativity and identity is really really fundamental. it's all over the place in algebra and category theory.
03:47:12 <merijn> BoR0: It might not be an issue, but it may break assumptions in other code. Some library might optimise their functions on the assumption that associativity/identity hold
03:47:23 <BoR0> I see
03:47:34 <merijn> BoR0: Passing your pseudo-monad to that library might now break the optimisation causing whatever weird effect
03:47:35 <BoR0> so, obeying the laws guarantee code elegance and integration?
03:47:49 <yesthisisuser> the point is to be able to apply thinking from other domains also.. in a more mathematical sense
03:47:57 <donri> BoR0: imagine if you had an int type where adding zero changed the value
03:47:59 <merijn> BoR0: Yes, one can use the laws to prove "this optimisation is always correct", etc.
03:48:07 <quchen> Monad laws in the presence of bottom are violated by some instances. For non-bottom data I think they should always hold.
03:48:15 <yesthisisuser> just like abstract algebra identifies operations on different structures
03:48:37 <merijn> I disregard bottom for laws
03:49:12 <quchen> merijn: Right, as a programmer you can mostly do that. On the other hand, it's quite important for GHC's rewrite engine.
03:49:20 <merijn> Sure
03:49:50 <BoR0> what does bottom and non-bottom data mean?
03:50:08 <quchen> Bottom is the value of an expression that doesn't terminate, throws an uncaught exception, etc.
03:50:12 <merijn> bottom is a non-terminating computation (i.e. usually a crash/infinite loop)
03:50:14 <quchen> You can read it as "crash".
03:50:22 <merijn> See undefined
03:50:24 <merijn> :t undefined
03:50:25 <lambdabot> a
03:50:27 <srhb> Where's the name from anyway?
03:50:28 <quchen> "let x = x in x" is bottom for example.
03:50:39 <srhb> "bottom" I mean.
03:50:39 <merijn> srhb: the _|_ symbol, I believe
03:50:45 <BoR0> I see
03:50:51 <merijn> srhb: Or the other way around
03:50:52 <donri> BoR0: currently ghc doesn't use the monad laws for any optimization AFAIK, i kinda wish it did just to break violating code ;) but it's also about refactoring. if a monad isn't lawful, you don't know if a refactoring will change the program when it shouldn't
03:50:57 <quchen> srhb: There is a partial order of definedness of expressions, and bottom is the lower end of this hierarchy.
03:51:05 <pcapriotti> srhb: the fact that it's the bottom element in the corresponding poset
03:51:22 <srhb> Right.
03:51:24 <quchen> srhb: For example "fix" yields the *least* defined fixed point of an expression. Often that "least" is bottom.
03:51:41 <donri> bottom comes from its relationship to the related concept of the "top" type, i imagine
03:51:45 <quchen> In other words, you can't be less defined than bottom and still be defined :-)
03:52:06 <srhb> quchen: That seems very.. vague :P
03:52:29 <quchen> srhb: There was a really nice talk about this and related concepts, maybe I can find it again
03:52:39 <srhb> quchen: That would be cool :)
03:52:49 <quchen> Oh, that was easier than I thought https://vimeo.com/67174266
03:52:51 <quchen> srhb: ^
03:53:07 <srhb> Thanks!
03:53:42 <AshyIsMe> wow the yesod bare project takes a while to compile
03:53:44 <quchen> It's one of those "doesn't help but broadens your horizon" videos for me at least
03:54:48 <quchen> Saying "definedness of expressions" reminds me to look up the difference between a term and an expression.
03:55:04 <quchen> Which is probably like looking up the difference between voltage and current :>
03:55:32 <merijn> BoR0: In the end it boils down to us haskellers liking equational reasoning, the laws simplify this/let us make stronger assumptions
03:56:01 <BoR0> that makes sense to me, thanks for all the help!
03:56:10 <quchen> BoR0: If you want a crazy example of this: there's the pipes library, and its core has no unit tests. What it does have though is a file proving the correctness by equational reasoning.
03:56:19 <quchen> In other words, it ships with mathematical proofs of its correctness.
03:56:35 <quchen> (And pipes is very useful, and not just an academic exercise.)
03:56:38 <Narvius> Eh, building lambdabot is apparently impossible on Windoze. Cygwin fails.
03:56:40 <BoR0> that's way much better than having even more than million unit tests
03:57:02 <donri> quchen: (it does have quickcheck tests now, although those are arguably not "unit" tests)
03:57:03 <quchen> BoR0: Right, because a million unit tests check a million outcomes. Proofs check *all* outcomes.
03:57:09 <srhb> BoR0: It is. Often it's very hard to do though. But hard is better than impossible. Try proving correctness for php. :P
03:57:21 <quchen> donri: Yeah I saw the post, but that's mostly a proof of concept I think ..?
03:57:23 <BoR0> :)
03:57:32 <donri> quchen: don't think so...
03:57:47 <donri> https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/tests/Main.hs
03:57:58 <quchen> donri: Hm, right. Now that I think of it, only the core is provably correct. The API functions etc can still make use of testing.
03:58:14 <quchen> Also the core proofs could be wrong so unit tests may point that out as well.
03:58:20 <donri> you could probably scram some properties out of other parts too but yeah
03:59:16 <alexander__b> I'm aware this isn't exactly pretty, but, how do I make reactive-banana-wx redraw/update my times here: http://lpaste.net/1128287973083709440 ?
03:59:52 <alexander__b> errr sorry s/reactive-banana-wx/wxhaskell -- I am only using wxhaskell in that example
04:00:11 <yesthisisuser> I am reading Robert Harper's "Practical Foundations for Programming Languages". Has any one else read it?
04:01:17 <donri> BoR0: all quickcheck does here though is machine-check the proof, although not exhaustively, but via fuzz testing. so it's still about laws!
04:01:57 <donri> BoR0: money quote: "For example, let's suppose that some enterprising young NSA employee were to try to commit a modification to the identity pipe pull' to try to log the second value flowing upstream. We could set up a test case to warn us if the modified pull' function failed to obey the identity law"
04:02:04 <donri> http://www.haskellforall.com/2013/11/test-stream-programming-using-haskells.html
04:02:08 <yesthisisuser> The chapter on judgments and derivability gets really "deep".
04:03:01 <yesthisisuser> I guess i should look into Martin Lof type theory before starting to read this
04:04:04 <Twey> yesthisisuser: TAPL is a nice introduction
04:05:03 <Twey> quchen: When you say ‘a file’, is this a formal proof in Agda or something?
04:05:16 <yesthisisuser> Twey: thanks..
04:05:30 <donri> Twey: https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/laws.md
04:05:45 <Narvius> Oh well.
04:05:45 <donri> Twey: i think they're working on an agda proof
04:07:47 <donri> Twey: http://www.haskellforall.com/2013/10/manual-proofs-for-pipes-laws.html "First, there is the obvious caveat that these proofs are still not machine-checked, but that's the next step. Paolo Capriotti has been patiently teaching me how to encode my reasoning into Agda. However, I believe this should be possible and that the proofs are very close to sound, taking into account the following caveats below."
04:08:30 <pcapriotti> yeah, it should be doable, with some patience
04:08:57 <pcapriotti> here's a taste of how it would look like: http://lpaste.net/95393
04:09:49 <Twey> Aha
04:10:10 <Twey> pcapriotti: Nice
04:10:39 * Twey feels a little more confident that proofs will replace tests soon.
04:11:37 <donri> problem is it's not actually checking the haskell implementation. let's all move to agda eh ;)
04:12:22 <srhb> donri: Can't we just, like.. Make Haskell into Agda? Please? <_<
04:12:29 <Twey> Or something
04:12:34 <donri> {-# LANGUAGE Agda #-}
04:12:36 <srhb> I'd miss my libraries. And compiling my programs.
04:12:36 <Twey> srhb: We did.  It's called Agda.  :þ
04:12:37 <srhb> :P
04:12:53 <Twey> Agda has a strong Haskell FFI, and can compile to Haskell.
04:13:08 <srhb> It's just not quite enough.
04:13:16 <raichoo> Use idris :P
04:13:21 <srhb> Idris looks nice.
04:13:27 <Ghoul_> so whats the fastest haskell web framework
04:13:29 <srhb> Not sure I understand the effects system
04:13:40 <srhb> Ghoul_: don't they all use the same web server these days?
04:13:47 <Twey> Ghoul_: Currently Yesod, I believe
04:13:48 <Ghoul_> warp?
04:13:54 <Twey> Unless it's changed again recently
04:14:02 <srhb> Ghoul_: Yes.
04:14:03 <Ghoul_> someone should make one based on pipes :/
04:14:13 <Ghoul_> I dont like conduits very much
04:14:18 <srhb> They're all so stupidly fast now it doesn't matter.
04:14:25 <donri> i wish ghc had an extension for pi types so we didn't need singletons
04:14:53 <haasn> warp is the fastest server, and I think those posa benchmarks used mighty on top of it
04:15:11 <haasn> as in mighttpd
04:15:32 <donri> acme-http is faster ;)
04:15:45 <merijn> @hackage acme-http
04:15:46 <lambdabot> http://hackage.haskell.org/package/acme-http
04:16:08 <srhb> "Winning the PONG benchmark at all costs"
04:16:09 <donri> acme-http beats nginx with mio
04:16:51 <alexander__b> how did you circumvent ambiguous module names in the src again?
04:16:55 <Ghoul_> warp beats nginx with mio
04:17:02 <alexander__b> i.e. in the import line in the source code, not as an argument to ghc
04:17:03 <donri> alexander__b: PackageImports?
04:17:06 <Ghoul_> aren't all the acme packages jokes?
04:17:16 <Ghoul_> so what's odd about this one ..
04:17:18 <alexander__b> donri: ... probably? :-)
04:17:38 <donri> Ghoul_: don't think warp does, does it? and yes acme-http is not a serious server
04:17:57 <Ghoul_> according to the paper it smashes nginx with mio
04:18:02 <merijn> donri: That isn't even nearly as half-baked as I expected :p
04:18:02 <donri> it's meant to show the upper limit of a haskell web server
04:18:07 <Ghoul_> past like 10 cores or something like that, nginx hits a wall and warp keeps scaling
04:19:13 <hpc> holy crap, how did i not know about acme-http
04:19:18 <donri> Ghoul_: i didn't know they even tested warp directly in the mio paper
04:19:52 <donri> they test mighty, which does not beat nginx unless i misread the numbers
04:20:11 <donri> i only skimmed the paper though ;)
04:21:49 <Twey> alexander__b: PackageImports allow you to import "mtl" Control.Monad
04:21:58 <alexander__b> Twey: yep, I figured it out. thanks.
04:22:26 <Twey> The next question is, how do you circumvent ambiguous package names…?  ;)
04:22:45 <Ghoul_> donri: https://github.com/snoyberg/posa-chapter/blob/master/warp.md#performance-of-warp
04:23:24 <donri> oh posa
04:23:31 <volko> yesod seems overly complicated to me
04:23:41 <donri> but posa predates mio doesn't it
04:23:56 <donri> and it still beats nginx? maybe nginx sucks
04:23:58 <donri> needs moar haskell
04:24:03 <srhb> donri: ;)
04:24:04 <Ghoul_> im pretty sure posa is all about Mio
04:24:15 <Ghoul_> wait, nvm
04:24:16 <Twey> volko: The complication is a neccessary price for the type-safety, I think
04:24:23 <Ghoul_> but, actually, theres a graph in the mio paper
04:24:35 <Ghoul_> thats exactly the same as that but shows a post-mio thing, and its like 15-20% better something like that
04:24:38 <Twey> The TH makes it less complicated at the price of making you learn several DSLs
04:25:07 <Ghoul_> http://webcache.googleusercontent.com/search?q=cache:http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
04:25:08 <srhb> volko: Happstack feels less like that. I always plug it when someone says that, mind, because I had exactly the same feeling with Yesod
04:25:12 <srhb> Like "what's going on here?!"
04:25:21 <srhb> Whereas Happstack (and Snap, I hear?) feels like Haskell.
04:25:30 <Ghoul_> gah, all the graphs are missing and the oringinal copy is down. thats shitty
04:25:55 <pyr> snap is the go-to solution for quick rest+json apis in haskell, right ?
04:26:13 <pyr> as-in an equalivent solution to ring in clojure or sinatra in ruby
04:26:48 <srhb> pyr: There's something even tinier for that.. The name escapes me right now
04:28:10 <quchen> Twey: Gabriel mentioned that Agda/Coq would (will?) be the next step though.
04:28:22 <srhb> pyr: Scotty
04:28:40 <pyr> thank you
04:28:50 <srhb> pyr: It's excellent, and so tiny.
04:29:01 <quchen> Twey: But then that's not a proof that the proofs are correct :-P
04:29:12 <donri> happstack-lite! :)
04:29:44 <srhb> Yeah, I think happstack-lite is awesome too.
04:30:55 <volko> Twey: does happstack lack the same kind of safety?
04:32:37 <srhb> volko: Not necessarily. But you have to plug it in yourself. In general I think it feels more DIY than Yesod.
04:33:17 <Ghoul_> so heres the other question
04:33:24 <Ghoul_> which database adapter is the fastest
04:33:41 <srhb> Ghoul_: Jebus, are you building Facebook mkII? :P
04:34:01 <Ghoul_> naw, just getting into haskell w/ web and getting a feel for it before I dive in
04:34:18 <srhb> I've only used acid-state, so can't comment on all the SQL-stuff.
04:34:31 <zomg> Ghoul_: MongoDB with Yesod has worked reasonably well for me
04:34:40 <Twey> quchen: It's really quite hard to build a proof that looks like it proves one thing but actually proves something else (especially if you use the proof elsewhere; it gets harder the more you use it)
04:34:46 <hpc> hdbc is quite comfortable to anyone who has used another DBI before
04:34:46 <Ghoul_> I know that in phpland mongo is the fastest there
04:34:58 <Ghoul_> (or one of) so mongo sounds good to me
04:35:13 <srhb> Ghoul_: If you're not going to have several GBs of data, I'd go with acid-state
04:35:17 <hpc> Ghoul_: mongo is only fast because it breaks acid
04:35:20 <srhb> Indeed.
04:35:28 <srhb> It's a terrible database, really
04:35:28 <mrmonday> win 22
04:35:30 <srhb> "database"
04:35:33 <identity> anyone here know how the hell criterion defaultMain compares names of benchmarks?
04:35:35 <mrmonday> oops :<
04:35:44 <hpc> Ghoul_: it stages writes, so your written data isn't actually written
04:35:55 <hpc> then you crash and end up with a corrupt database
04:36:03 <hpc> time to restore from your week-old backups!
04:36:03 <identity> it's not taking anything I pass to it. ./foo Benchmarkname (shown by ./foo -l) just tells me there's nothing named that.
04:36:25 <Ghoul_> oh .. :/
04:36:35 <srhb> Ghoul_: There are plenty of resources out on the web on "why MongoDB is bad" - but really, just check out acid-state
04:36:41 <hpc> this gets into one of my very favorite rants
04:36:49 <Ghoul_> well, what if I do want to save GB's of data
04:36:50 <srhb> I think for the great majority of projects it's very sufficient, and awesome, and fast.
04:36:50 <hpc> about relational vs non-relational, and database vs non-database
04:36:59 <srhb> Ghoul_: Postgres?
04:37:00 <hpc> mongo is a nonrelational nondatabase, acid is a nonrelational database
04:37:12 <hpc> oracle/mysql/postgres/mssql are all relational databases
04:37:17 <hpc> sqlite is a relational nondatabase
04:37:38 <srhb> hpc: presumably nonrelational is not _necessarily_ bad?
04:37:46 <zomg> I'm not sure what the FUD about Mongo is
04:37:49 <hpc> no, nonrelational can be good
04:37:57 <hpc> zomg: it doesn't have durability
04:38:07 <hpc> zomg: you crash mid-write, the database is corrupt
04:38:11 <zomg> I was running an app with a relatively high number of writes all the time and even though it crashed a few times including mongo
04:38:18 <zomg> it never corrupted the database
04:38:29 <zomg> I had to run a restore, but it was just the normal step for starting from a crashed state
04:38:44 <zomg> I know it used to be pretty shitty in the earlier versions
04:38:53 <zomg> but from what I understand it's not so bad now
04:38:56 <hpc> zomg: it also stages writes; you can get halfway through 1000 writes and then your system crashes
04:39:06 <hpc> as far as the API knows, those writes are done and in the db
04:39:12 <hpc> but when you restore, all of those writes never happened
04:39:15 <srhb> zomg: It's broken by design. It's not a matter of fixing anything.
04:39:16 <hpc> because they were in RAM
04:39:31 <zomg> well I just told you I haven't had any problems with my use case with it
04:39:33 <hpc> but that's what it takes to get such kickass benchmarks!
04:39:38 <zomg> doesn't make it a" broken by design" if it doesn't fit your use :P
04:39:44 <srhb> "It works well for me!" is not as good as guarantees
04:39:51 <srhb> Fact is, there are no guarantees
04:39:55 <hpc> zomg: my use case is "i need a database"
04:40:27 <hpc> nobody uses innodb to run a large website because if it crashes you're fucked
04:40:44 <hpc> nobody should use mongo to run a large website either, because if it crashes you're still fucked
04:40:53 <hpc> data doesn't get written when it says it will
04:41:06 <hpc> and that means a crash equals DATA LOSS
04:41:45 <srhb> But fsync is expensive :<
04:41:54 <hpc> this is the part in the conversation where a mongo fanboy will say "you should set up a second server for more uptime"
04:42:19 <hpc> which is a fucking microcosm of the mongodb user's state of mind
04:42:29 <mm_freak_> a crash often entails data loss…  DBMSes don't necessarily protect you from data loss, they only protect you from data inconsistency
04:42:51 <hpc> mm_freak_: it's loss if the db claims to write data and doesn't
04:43:09 <hpc> just because you have lost 10 seconds instead of 0.2 seconds doesn't mean "everything has data loss"
04:43:22 <lpsmith> A little bit of benchmarking I've done suggests postgresql-simple is ~4x faster than hdbc-postgresql,  and about 20x slower than writing a C program that uses libpq directly.    Not great,  but it's sure as heck nowhere close to the same speed gulf that sqlite-simple had between haskell and C before Janne started benchmarking
04:43:41 <hpc> lpsmith: ... you seriously benchmarked sqlite?
04:43:54 <mm_freak_> hpc: not sure about mongodb, but usually a DBMS does not claim to have data written, it only claims, "ok, got it…  i will try to write it soon, but i might forget the transaction"
04:44:10 <lpsmith> it's still fast enough for me,  and a number of other commercial ventures are using it... so I haven't put much effort into optimization yet
04:44:19 <hpc> mm_freak_: no, they claim "i will not return until i write the data, even if it takes many transaction fails"
04:44:25 <lpsmith> hpc, Janne Hellstein did,  I just started with his benchmarks.
04:44:31 <hpc> blocking writes are the difference
04:44:55 <hpc> it's so weird having to explain this to a channel full of smart people
04:44:56 <mm_freak_> hpc: well, to be fair i only know postgresql =)
04:45:23 <lpsmith> I still need to write a haskell program that uses postgresql-libpq directly,  and probably a python program to get a feel for where postgresql-simple really is, performance wise
04:45:29 <srhb> mm_freak_: I think postgresql blocks on write until fsynched by default
04:45:34 <mm_freak_> hpc: and postgresql has no full transaction isolation by default, so transactions cannot "fail"
04:45:52 <lpsmith> Admittedly Janne's benchmark is not very broad,  only tests a very small portion of the code.
04:46:17 <lpsmith> sqlite is quite fast for simple tasks
04:46:29 <hpc> sqlite is a simple library for simple people
04:46:32 <mm_freak_> sqlite is quite slow for anything but simple tasks
04:46:41 <hpc> and in haskell, you have no excuse even then for not using acid-state
04:46:57 <srhb> "tables isn't quite ready yet" ? :P
04:47:06 <lpsmith> ehh,  I have a lot of excuses for using acid state.
04:47:08 <mm_freak_> that's a consequence of it being a single-file DB
04:47:29 <hpc> acid-state is a single-file DB too, and i don't know of any performance problems it has
04:47:30 <lpsmith> A lot of what I do I have to be fairly conservative about the persistence layer,  as the data is more important than the application
04:47:36 <mm_freak_> acid-state does not make that mistake…  its transaction log has one file for each transaction
04:47:38 <lpsmith> it has a number of them
04:47:40 <mm_freak_> that makes acid-state really really fast
04:47:45 <hpc> oh, that's why
04:48:10 <mm_freak_> hpc: acid-state is not single-file
04:48:25 <hpc> i really want to take a dive into the inside of acid-state, but when the API is TH i quickly change my mind
04:48:41 <mm_freak_> hpc: the relevant API is not TH
04:48:46 <mm_freak_> the TH stuff is only convenience
04:48:55 <yesthisisuser> you can still use acid-state without TH
04:48:56 <lpsmith> not to mention that last time I looked at acid-state,  you couldn't really just add an index and have your program use it without modifying your program.
04:49:14 <mm_freak_> lpsmith: that's not acid-state's fault
04:49:17 <hpc> yesthisisuser: you can use anything without TH; TH expands to normal haskell code
04:49:20 <mm_freak_> if you use Map, you get only a single index
04:49:28 <srhb> lpsmith: tables :-)
04:49:31 <hpc> yesthisisuser: it's the preferred interface, and doing without TH is a pain
04:49:40 <mm_freak_> use data-store, ixset or tables
04:49:42 <merijn> I believe people thinking of acid-state as a database is a mistake
04:49:55 <merijn> It's persistent heap data, not a database
04:49:57 <lpsmith> mm_freak_, well it is a major reason to use databases,  so that your access method isn't tied to your code
04:50:09 <hpc> merijn: it's persistent heap data with database-level guarantees
04:50:12 <merijn> lpsmith: Sure, but acid-state isn't trying to be a database
04:50:21 <mm_freak_> lpsmith: your access method is always tied to your code…  you do provide a data model layer, don't you?
04:50:24 <hpc> it stores data, and it does it with acid supapowah!
04:50:27 <merijn> hpc: acid guarantees are hardly database specific
04:50:30 <hpc> i call that a database
04:50:39 <merijn> hpc: I didn't say it wasn't very good at what it does
04:50:42 <hpc> it doesn't have to be tabular to be a database
04:50:46 <hpc> or relational
04:51:00 <merijn> hpc: I just think people thinking of it as a database are missing the point of the main use cases for this stuff
04:51:25 <srhb> It feels like a database as soon as you have acid-state with a Map something in it.
04:51:28 <mm_freak_> acid-state can be thought of as a database abstraction for the basic meaning of "database"
04:51:35 <mm_freak_> it just doesn't enforce any data model
04:51:39 <mm_freak_> all it gives you is ACID
04:51:41 <merijn> srhb: Sure, but I believe Map inside acid-state isn't that wise anyway
04:51:51 <srhb> merijn: Agreed, just a simple example
04:51:53 <mm_freak_> "adding an index" is a highly relational view
04:52:10 <mm_freak_> merijn: why?  Map is fine for many things
04:53:04 <merijn> mm_freak_: It depends on the size and use of your map, but if you just want a single Map (or potentially multiple) why not just use SQLite
04:53:50 <mm_freak_> merijn: because if the Map is small, then sqlite adds a lot of unsafety to your code for almost no gain
04:54:02 <merijn> mm_freak_: Which unsafety?
04:54:10 <mm_freak_> merijn: because sqlite is stringly typed
04:54:33 <merijn> mm_freak_: Oh, the database? I guess, although I'm pretty sure you could have haskell wrappings to fix that
04:54:54 <Twey> SQLite just doesn't have very many types
04:55:13 <Twey> There's only so much you can do about making it better from the Haskell side
04:55:33 <mm_freak_> merijn: then you still have to translate your data model into a relation and provide the SQL wrappers…  all in all your code is either much longer or uses TH heavily
04:56:29 <mm_freak_> also sqlite is very slow compared to acid-state
04:58:24 <sbidin`> How do I simplify this function? (Using MaybeT.) http://lpaste.net/95505
04:59:22 <mm_freak_> when using sqlite most of your time is wasted working around the stringly typedness and the bad performance of sqlite…  it doesn't really offer any advantage over acid-state, except that a bad and slow caching mechanism allows part of your data to be off-RAM
05:00:07 <tdammers> well, one advantage would be is that virtually every goddamn programming language on this godforsaken planet has bindings for sqlite
05:00:27 <tdammers> (excuse the language, I've been doing too much PHP lately)
05:00:50 <srhb> tdammers: You're excused, that would piss anyone off. :P
05:01:01 <mm_freak_> sbidin`: use 'MaybeT' instead of 'lift' and use (>=>) or (<=<)
05:01:14 <mm_freak_> MaybeT :: IO (Maybe a) -> MaybeT IO a
05:02:28 <mm_freak_> tdammers: this article could ease your pain: http://phpmanualmasterpieces.tumblr.com/post/65544023819/php-2-0-a-review-in-retrospect
05:03:17 <mm_freak_> conclusion: "People defend PHP by saying it’s a lot better than it used to be.  Well, they’re not /wrong/."
05:03:48 <Walther> reminds me of the argument "java isn't bad, you just need the right IDE / tools"
05:03:51 <sbidin`> mm_freak_: Thanks!
05:04:27 <Walther> which to me sounds like, "walking in a swamp isn't that bad if you have nice boots", which is kinda partially true but why the fuck would you want to walk in a swamp in the first place :P
05:04:34 <mm_freak_> tdammers: but to comment on your remark, have you ever actually accessed the same sqlite database from two different applications in two different languages?
05:04:36 <tdammers> mm_freak_: read that
05:04:46 <tdammers> mm_freak_: and yes, I have
05:05:11 <quchen> Twey: Re proofs, that's good to know.
05:05:30 <quchen> (I haven't used proof assistants.)
05:05:41 <mm_freak_> tdammers: ok, never had to suffer from that
05:05:42 <Twey> quchen: I think it's a lot easier to write wrong tests than to write wrong proofs.
05:06:03 <quchen> Twey: I believe that, yes.
05:06:12 <mm_freak_> even though i tried
05:06:12 <mm_freak_> sqlite doesn't even allow multiple processes to access the same file
05:08:08 <mm_freak_> Twey: the art is to formulate the right theorems…  proofs are usually quite mechanical
05:08:45 <mm_freak_> it's easy enough to prove things you don't actually care about =)
05:08:52 <yesthisisuser> i thought multiple processes were allowed to do SELECT
05:09:12 <mm_freak_> yesthisisuser: no, you get an exception thrown at you
05:09:38 <yesthisisuser> mm_freak: oh, ok. well i haven't tried
05:09:55 <mm_freak_> SqliteError "Sorry, buddy.  I suck, so don't expect me to do you a favor!"
05:11:06 * hackagebot alex 3.1.1 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.1.1 (SimonMarlow)
05:11:18 <yesthisisuser> hmm.. the SQLite FAQ says: Is SQLite threadsafe? A: Threads are evil. Avoid them.  :)
05:13:50 <tdammers> well, I've used the sqlite CLI a lot, actually
05:14:10 <tdammers> I like having direct access to the database, outside the application
05:14:14 <mm_freak_> better set up a local postgresql and use that one's CLI instead ;)
05:14:40 <tdammers> obviously postgresql rocks in every conceivable way, but it's not always an option
05:15:04 <donri> you can connect to acid-state from ghci
05:15:14 <yesthisisuser> sqlite is good as an embedded database i think
05:15:37 <yesthisisuser> as in, embedded in an application
05:16:00 <yesthisisuser> if you need to store things using the relational model
05:16:01 <alexander__b> hm. trying this again: what is the easiest library/thingy to use for a stopwatch? i.e. a counter that starts at 00:00:00 and then starts counting. with second precision.
05:16:04 <tdammers> donri: it's not quite the same
05:16:23 <alexander__b> (using utctDayTime strikes me as suboptimal)
05:17:02 <donri> tdammers: of course not :) there'd be no point to it if it was exactly the same thing :)
05:17:07 <mm_freak_> yesthisisuser: well, there is a whole continuum from "good" to "great", and if that's the whole scale, then firstly sqlite is really only "good", and secondly it's by far not the only option =)
05:17:21 <srhb> alexander__b: time should be fine for that?
05:17:26 <mm_freak_> just because something is "sufficient", you shouldn't throw yourself at it
05:17:32 <srhb> alexander__b: just diffUTCTime?
05:18:01 <Twey> mm_freak_: True that
05:18:05 <srhb> alexander__b: That is, a <- getUTCtime; blah; b <- getUTCtime; return (diffUTCtime a b)
05:18:30 <alexander__b> srhb: right now I have stuff like hh t = show (floor (utctDayTime t / (60*60)) :: Int)
05:19:00 <mm_freak_> btw, if application configuration management is all you need, you can use safecopy without acid-state
05:19:24 <mm_freak_> but then it doesn't really make much sense not to go all the way to acid-state
05:19:38 <alexander__b> I guess it works. my main issue is doing the whole... impure thing. I have avoided it forever. but now I really need to figure out how to do it.
05:20:20 <srhb> alexander__b: There's no way of getting a clock time without doing IO, after all :)
05:20:37 <mm_freak_> srhb: there is =)
05:20:47 <tdammers> of course not. you need the real world to tell what time it is in the real world
05:21:05 <srhb> mm_freak_: What?
05:21:07 * hackagebot alex 3.1.2 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.1.2 (SimonMarlow)
05:21:14 <mm_freak_> you want to derive an X from Time
05:21:17 <alexander__b> srhb: my problem is updating the labels, let me show you
05:21:18 <mm_freak_> one option is:  IO X
05:21:23 <mm_freak_> the other option is:  Time -> X
05:21:31 <srhb> mm_freak_: I don't follow.
05:21:57 <Twey> Pure values as a function of time
05:21:59 <alexander__b> srhb: in buttonSwitch: http://lpaste.net/3352812468106690560 -- I need to set the hhLabel, mmLabel, ssLabel to the results of hh/mm/ss. ideas on how to do that?
05:22:00 <mm_freak_> srhb: in most cases your computation does not need to /retrieve/ the current time, it only needs to /use/ it
05:22:09 <mm_freak_> srhb: in that case you can write it as a pure function of time
05:22:12 <mm_freak_> no need for IO
05:22:13 <alexander__b> srhb: it's just this basic chaining together of impure stuff that's a bit lost on me, since I've been avoiding it.
05:22:17 <Twey> alexander__b: FRP is nice ☺
05:22:29 <alexander__b> Twey: yes yes yes damnit I'm getting to it! :-P
05:22:32 <mm_freak_> you use IO at the very last instant:  fmap myComputation getCurrentTime
05:22:35 <srhb> mm_freak_: Um, sure. I don't see how that's relevant to his stopwatch problem. :)
05:22:38 <alexander__b> Twey: I'm learning gtk2hs first, then frp. ;-)
05:22:57 <mm_freak_> srhb: the current time is not the only concept you can express that way
05:23:10 <mm_freak_> a stopwatch is a simple application of time-varying values
05:23:19 <alexander__b> Twey: well actually, I'm learning howto impure wtf first. that's my main issue. groking the flow of the program.
05:23:25 <mm_freak_> and from there it's a small step to full-blown FRP
05:27:30 <Lambi> I'm trying to use the list difference function from Data.List (\\) in a function that is to return a Float. However, the \\ function gives me an Int. Does anyone have suggestions for what to do about this?
05:27:41 <alexander__b> ok I have labels working now. this code makes me unhappy with life. but I'll try to finish the functionality, and then worry about doing things The Right Thing.
05:27:48 <alexander__b> s/things/the
05:28:10 <Narvius> "the The Right Thing"? ;)
05:29:06 <alexander__b> oh yeah I already had the the there :-P
05:29:48 <alexander__b> does gtk2hs have an "onIdle"? hm. I need my window to always update itself
05:30:11 <mm_freak_> :t (\\)
05:30:12 <lambdabot> Eq a => [a] -> [a] -> [a]
05:30:22 <alexander__b> (I guess I should be asking about gtk not gtk2hs but...)
05:30:26 <mm_freak_> Lambi: not sure how (\\) can give you an Int
05:31:14 * hackagebot happy 1.19.1 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.19.1 (SimonMarlow)
05:31:23 <mm_freak_> alexander__b: search for the equivalent C code…  the haskell API is usually close to the C API
05:31:26 <Lambi> My bad, I'm using length $
05:31:38 <Lambi> length $ list1 \\ list2
05:31:40 <Lambi> for example
05:31:55 <mm_freak_> Lambi: have you considered using Data.Set instead of Data.List?
05:33:11 <Lambi> mm_freak_: is there a function similar to (\\) in Data.Set?
05:33:22 <ketil> e
05:33:34 <mm_freak_> Lambi: yes, (\\)
05:33:35 <mm_freak_> =)
05:33:36 <Lambi> Ah, the (difference) function
05:33:49 <alexander__b> is there no way in hackage to just search a package for a keyword?
05:33:53 <mm_freak_> Lambi: or the (\\) function =)
05:33:56 <mm_freak_> :t (S.\\)
05:33:57 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
05:34:11 <alexander__b> http://hackage.haskell.org/package/gtk-0.12.3 search here will search hackage for a package with the keyword. how do I search through the current package for a keyword?
05:34:22 <Lambi> mm_freak_: but then, going length $ a \\ b will give me an Int again
05:34:31 <mm_freak_> alexander__b: hoogle searches the gtk2hs library as well, IIRC
05:34:38 <mm_freak_> @hoogle Button
05:34:39 <lambdabot> Graphics.UI.GLUT.State type ButtonCount = Int
05:34:39 <lambdabot> Graphics.UI.GLUT.Callbacks.Window type ButtonIndex = Int
05:34:39 <lambdabot> Text.XHtml.Strict button :: Html -> Html
05:34:43 <alexander__b> @hoogleidle
05:34:44 <lambdabot> Unknown command, try @list
05:34:46 <alexander__b> @hoogle idle
05:34:46 <lambdabot> Graphics.UI.GLUT.Callbacks.Global idleCallback :: SettableStateVar (Maybe IdleCallback)
05:34:46 <lambdabot> Graphics.UI.GLUT.Callbacks.Global type IdleCallback = IO ()
05:34:58 <mm_freak_> or was it hayoo?
05:35:10 <mm_freak_> try the web versions of them
05:35:28 <alexander__b> I am willing to bet it has something akin to g_idle_add, but...
05:35:36 <mm_freak_> Lambi: it will give you the Int in constant time, then you're only a fromIntegral away
05:35:37 <alexander__b> hackage really should allow you to search a package's docs.
05:36:04 <Narvius> Hackage should allow you to easily find instance definitions
05:36:55 <mm_freak_> hackage should do a lot of things…  you're welcome to send patches =)
05:37:17 <Narvius> It's written in Haskell as well, I presume?
05:37:22 <mm_freak_> yeah
05:37:25 <Narvius> Hm.
05:37:36 <mm_freak_> it's on hackage =)
05:37:39 <Narvius> xDDDDd
05:37:51 <Lambi> mm_freak_: Right! (fromIntegral) solved my problems
05:38:15 <alexander__b> mm_freak_: hayoo to the rescue
05:39:09 <Narvius> What is it with those terrible, punny search engine names, though
05:39:14 <Narvius> Hoogle and Hayoo? Seriously?
05:39:28 <alexander__b> hackhackgo would be better
05:39:47 <Lambi> mm_freak_: thanks :)
05:39:48 <sopvop> bink -> honk?
05:40:09 <sopvop> sorry, bing
05:40:36 <tdammers> hing
05:41:13 <Narvius> If it was for TH stuff
05:41:14 <Narvius> THing
05:41:30 <quchen> You can also use Hoggle!
05:41:33 <quchen> @hoggle a -> a
05:41:33 <lambdabot> Prelude id :: a -> a
05:41:33 <lambdabot> Data.Function id :: a -> a
05:41:33 <lambdabot> GHC.Exts breakpoint :: a -> a
05:41:57 <Narvius> What's the difference :o
05:42:09 <quchen> Narvius: It was just autocorrection ;-)
05:42:19 <quchen> Narvius: Hoogle and Hayoo are the only big search engines
05:42:34 <Narvius> I don't like automatically lauching autocorrected queries.
05:42:47 <Narvius> That's one "auto" too many at once.
05:42:48 <alexander__b> apparently idleAdd requires a function that returns IO Bool -- how do I uh make my function do that?
05:42:58 <BoR0> @@src map
05:43:02 <BoR0> @src map
05:43:02 <lambdabot> map _ []     = []
05:43:02 <lambdabot> map f (x:xs) = f x : map f xs
05:43:08 <k00mi> alexander__b: you can search only a specific package with +package
05:43:20 <alexander__b> k00mi: in hackage?
05:43:34 <k00mi> yes
05:43:35 <quchen> Or click on the package on the left of the Hoogle search results if there are too many from too many packages.
05:43:38 <alexander__b> k00mi: cool, thanks
05:43:43 <quchen> (Which is equivalent)
05:44:29 <alexander__b> oh return True. duh.
05:44:29 <joneshf> i'm reading some data from a file, it comes in as two number, say "m n". I've got a "memoizing" function that takes one argument, but i need to use both numbers from the file and attempting to memoize with two arguments has been less than futile. Is it possible to store the second number "somewhere" and refer to it from my memoizing function?
05:44:44 <alexander__b> well now I have a watch. that's *almost* a stopwatch.
05:46:09 <joneshf> the idea is to store one of these numbers as a constant somewhere
05:46:44 <mm_freak_> Narvius: lambdabot does not auto-correct your queries, it reads your mind
05:47:04 <mm_freak_> @djinn b -> (a -> b) -> Maybe a -> b
05:47:05 <lambdabot> f a b c =
05:47:05 <lambdabot>     case c of
05:47:05 <lambdabot>     Nothing -> a
05:47:05 <lambdabot>     Just d -> b d
05:47:05 <Narvius> mm_freak_: I guess that's alright, the.
05:47:06 <Narvius> then*
05:48:50 <alexander__b> so anyone have any idea how I should start counting in here: http://lpaste.net/4017659622977437696 ? when the user hits START, the clock should start counting from 00:00:00, obviously.
05:51:01 <mm_freak_> alexander__b: i think GTK+ allows you to add event handlers dynamically
05:51:08 <mm_freak_> so you probably need some timer
05:51:16 * hackagebot hPDB 0.9999.1 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-0.9999.1 (MichalGajda)
05:51:49 <zrho> @djinn (Functor f, Traversable g) => (a -> b) -> g (f a) -> f (g b)
05:51:49 <lambdabot> Error: Class not found: Functor
05:52:23 <zrho> Why am I disappointed that lambdabot didn't figure that one out?^^
05:53:21 <Narvius> @djinn [a] -> [[a]]
05:53:21 <lambdabot> Error: Undefined type []
05:53:23 <Narvius> See
05:53:32 <zrho> @djinn Either b c -> (b -> a) -> (c -> a) -> a
05:53:33 <lambdabot> f a b c =
05:53:33 <lambdabot>     case a of
05:53:33 <lambdabot>     Left d -> b d
05:53:33 <lambdabot>     Right e -> c e
05:53:34 <Twey> @quote need a double
05:53:34 <lambdabot> No quotes for this person. Where did you learn to type?
05:53:46 <Twey> Aww.
05:53:49 <quchen> @quote need.a.double
05:53:49 <lambdabot> No quotes match. You speak an infinite deal of nothing.
05:53:50 <quchen> :-(
05:54:41 <quchen> @quote monochrom Double
05:54:41 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
05:54:46 <quchen> :-)
05:55:07 <Twey> \o/
05:55:29 <Twey> Unfortunately Lambi has vanished and is not present to benefit from monochrom's sage advice
05:55:33 <zrho> lambdabot isn't the greatest comedian of our time, I guess^^
05:56:08 <quchen> Oh there are some pearls in there
05:56:19 <zrho> @djinn (Monoid m) => m -> m -> m
05:56:20 <lambdabot> Error: Class not found: Monoid
05:56:20 <quchen>  /q lambdabot and spam "@quote kmc" for example
05:56:35 <zrho> @quote kmc
05:56:36 <lambdabot> kmc says: agda is super mutant haskell
05:57:30 <zrho> I see what you meant. Those are actual quotes by users from here?
05:57:35 <quchen> Yes
05:57:58 <quchen> Jafet is another one you can check out.
05:58:12 <quchen> But again, there are many many quotes, so use a private session. It gets spammy fast.
05:59:41 <alexander__b> mm_freak_: I was thinking I could do something like http://lpaste.net/6349239935949602816 for now, but IDK what startTime would have to look like atm. heh.
05:59:52 <zrho> Actually thinking about writing a "@quote kmc" bot for a private session to harvest all the goodness.
06:01:48 <zrho> Ah, feuerbach, do you mind a quick question?
06:02:37 <Feuerbach> hey zrho
06:02:58 <zrho> Some fellow students and I are currently experimenting on how minimal we can build a haskell compiler.
06:03:09 <zrho> You are the author of haskell-names, right?
06:03:14 <Feuerbach> indeed
06:04:09 <zrho> I am currently working on the naming part of the compiler; it is working quite well right now, but I guess there might be some pitfalls.
06:05:16 <zrho> Are there any really non-intuitive parts of it that are more than traversing the AST in a way that maintains the current scope and a replacement map for local to qualified names?
06:05:47 <Feuerbach> yeah, there are many non-intuitive parts :)
06:06:35 <Feuerbach> one very confusing thing is the module system. I wrote a bit about it here http://ro-che.info/articles/2012-12-25-haskell-module-system-p1.html and I'm going to write part 2 sometime
06:08:10 <Feuerbach> I guess you only care about Haskell2010, but with extensions there are many more pitfalls too. One of the most problematic is RecordWildcards
06:08:31 <teneen> Ok so I checked the source of the array and base packages and found out that "unsafeReadArray" actually double checks the index range instead of not checking it!!
06:10:04 <Feuerbach> zrho: things like recursive modules and fixities are fun, too
06:11:07 <zrho> Currently I use a data structure that reversely topologically sorts the module dependency DAG for that; I think mutually recursive modules aren't allowed in Haskell 2010, are they?
06:11:21 <Feuerbach> they sure are
06:12:26 <Feuerbach> see the beginning of Chapter 5 of the Report
06:12:50 <zrho> Is there a ghc flag to turn them on? They seem not to work by default.
06:13:02 <Feuerbach> in GHC you need hs-boot files
06:13:09 <Feuerbach> this is explicitly allowed in the report
06:13:17 <Feuerbach> see 5.7
06:15:14 <zrho> Hm, you're right. Then it boils down to finding strongly connected components and compiling them as a unit. Argh.
06:15:21 <jaspervdj> If anyone here has a hacker news account, please consider upvoting my latest Haskell webapp: https://news.ycombinator.com/item?id=6711534 :-)
06:16:39 <zrho> jaspervdj: funny idea :)
06:17:00 <Feuerbach> zrho: yes, and when you're compiling them as a unit, you're essentially finding the least fixpoint
06:17:49 <zrho> Luckily I'm not resolving haskell-src-exts, but a quite reduced core, so RecordWildcards boilds down to desugaring it some place else.
06:21:08 <zrho> Feuerbach: Regarding fixity: I use haskell-src-exts for parsing, does it get the fixity right, if I parse without supplying any such info, but them feeding it in aftwards with applyFixities?
06:21:57 <jaspervdj> Thanks zrho
06:23:27 <Feuerbach> zrho: yes. But remember that fixity declaration may appear not just on the top level
06:23:39 <Feuerbach> *declarations
06:23:49 <zrho> Where else?
06:23:59 <Feuerbach> e.g. in let or where bindings
06:24:03 <zrho> Oh, I see.
06:24:36 <Narvius> > let infixr 9 (+) in 2 + 3* 4
06:24:37 <lambdabot>   <hint>:1:14: parse error on input `('
06:24:46 <Narvius> > let infixr 9 +; in 2 + 3* 4
06:24:47 <lambdabot>   The fixity declaration for `+' lacks an accompanying binding
06:25:23 <zrho> > let infixr 9 (+++); a +++ b = a + b in 2 +++ 3 * 4
06:25:24 <lambdabot>   <hint>:1:14: parse error on input `('
06:25:34 <zrho> > let infixr 9 +++; a +++ b = a + b in 2 +++ 3 * 4
06:25:35 <lambdabot>   20
06:26:04 <Narvius> Interesting.
06:26:06 <zrho> appareantly you can't rebind fixity of existing definitions, but only of new ones.
06:26:15 <Feuerbach> > let infixr 9 +; (+) = (Prelude.+); in 2+3*4
06:26:16 <zrho> Like in top level
06:26:17 <lambdabot>   20
06:26:22 <Narvius> Though I never really define operators or anything infix in lets.
06:26:28 <Narvius> Huh.
06:26:31 <Narvius> Cool.
06:26:47 <Feuerbach> fixity decls are very much like type signatures
06:27:00 <zrho> It is a new definition in a way, if you write it that way
06:27:06 <zrho> It only shadows the old one.
06:27:08 <Feuerbach> sure
06:27:40 <Feuerbach> it's like you cannot write let id :: Int -> Int in id 3
06:27:41 <Narvius> How so?
06:27:55 <Narvius> Oh, okay.
06:33:56 <lpaste> BoR0 pasted “My first Monad(?)” at http://lpaste.net/95508
06:34:09 <BoR0> how can I easily check if this obeys monad laws? http://lpaste.net/95508
06:34:42 <lpaste> BoR0 revised “My first Monad(?)”: “No title” at http://lpaste.net/95508
06:35:23 <zrho> Feuerbach: Compute SCCs and sort them in topological order (tarjan), calculate the fix point of exported names and fixities on each SCC, apply fixities to each module, traverse AST to replace names by qualified names (respecting local scopes), profit.
06:35:28 <zrho> Am I missing something?
06:35:57 <Feuerbach> BoR0: Element 1 (Element 2 Empty) >>= return evaluates to Element 1 Empty
06:36:02 <Feuerbach> so it's not a proper monad
06:38:41 <zrho> BoR0: The idea of >>= on lists, is that it produces a list for each element of the original one; that's the point of (a -> [b]) in the signature.
06:38:44 <zrho> cf. concatMap
06:39:19 <BoR0> so, is my return is properly defined, I should look at >>=?
06:39:25 <zrho> Yes
06:39:46 <zrho> Basically try to incorporate all values in the list, not just the first one.
06:40:01 <BoR0> I don't know how to do that, I tried several combinations.. my latest one is Element x y >>= f = (f x) y
06:40:31 <Feuerbach> zrho: yes, something like that (if in "apply fixities" you include "traverse and apply local fixities as well")
06:40:38 <Narvius> BoR0: You probably won't get away without some recursion.
06:40:48 <BoR0> aha
06:40:58 <Narvius> Look
06:40:59 <zrho> Tip: write concat :: MyList x -> MyList x -> MyList x and fmap :: (a -> b) -> MyList a -> MyList b
06:41:07 <Narvius> > [1, 2, 3] >>= const [5, 5, 5]
06:41:09 <lambdabot>   [5,5,5,5,5,5,5,5,5]
06:41:47 <Feuerbach> zrho: haskell-names has a test suite, feel free to reuse it. But we don't support fixities yet, and there are no tests for them, unfortunately.
06:41:51 <BoR0> @src fmap
06:41:51 <lambdabot> Source not found. stty: unknown mode: doofus
06:41:55 <BoR0> @src concat
06:41:55 <lambdabot> concat = foldr (++) []
06:41:59 <mauke> > "hello" >> "A"
06:42:00 <lambdabot>   "AAAAA"
06:42:56 <quchen> > "Hello Satoshi" >>= (:('f':[]))
06:42:57 <lambdabot>   "Hfeflflfof fSfaftfofsfhfif"
06:43:22 <Narvius> Frankly, I found the monad instance for lists harder to reimplement than Maybe and State.
06:43:33 <BoR0> so I see, bind operator on lists behaves like that due to its definition with concat and fmap
06:43:38 <BoR0> is this correct?
06:43:44 <hpc> yes
06:43:48 <quchen> Narvius: It's more obvious if you consider implementing Monad as fmap+join though.
06:43:59 <Narvius> True.
06:44:02 <BoR0> great, thanks. I'll continue with my trial & error approach and see if I get to something useful :P
06:44:07 <hpc> BoR0: or to be a bit pickier, join and fmap
06:44:15 <hpc> but join = concat so your intuition is correct
06:44:26 <quchen> ^ for lists at least.
06:44:34 <zrho> Many monad instances become much simpler, when implementing join and fmap instead of bind.
06:44:50 <BoR0> what is an easier exercise related to monads than implementing lists monad?
06:44:59 <quchen> Maybe Maybe?
06:45:06 <Narvius> Definitely Maybe.
06:45:15 <zrho> quchen: pun. höhö ;)
06:45:21 <BoR0> ok, I'll Maybe give a shot.
06:45:23 <Narvius> I called mine Probably a = Kinda a | Nope
06:45:27 <joe9> I am trying to figure out how to decode html in a string such as removing &quot; etc. I tried to install web-encodings haskell package but it is a breaking a bunch of other packages. Just wanted to check if there is something better.
06:47:14 <zrho> Feuerbach: Thanks for your help. Definitely made the compiler more correct
06:47:16 <hpc> joe9: i think somewhere on hackage is a (Map String String) of all the named html escapes
06:47:29 <joe9> hpc, oh, really.
06:47:34 <hpc> joe9: and you can use those, "&#xxx;" syntax, and a few lines of parsec
06:47:34 <joe9> hpc, thanks.
06:47:38 <hpc> not sure what it's called though
06:47:48 <hpc> if it doesn't exist, you should upload it
06:48:13 <joe9> http://stackoverflow.com/questions/4218205/haskell-remove-html-character-entities-in-a-string
06:48:13 <hpc> as a kind of "data package"
06:48:24 <joe9> is where I got the web-encodings from.
06:52:20 <quchen> hpc: Maybe something with "entities"?
06:52:27 <joe9> http://stackoverflow.com/questions/6845422/unescaping-html-entities-including-named-ones?lq=1
06:52:32 <Feuerbach> zrho: you're welcome
06:55:03 <Narvius> Couldn't someone just quickly hack together a parser for the entity table on wikipedia?
06:55:13 <Narvius> I'd do it, but my ParsecFu is weak.
06:55:34 <mm_freak_> Narvius: the parsec tutorial is quite accessible
06:55:55 <Narvius> Learning Parsec is not the issue here, getting a map of HTML entities is. ;)
06:56:33 <quchen> string "&#" >> do { entity <- string; return Map.lookup table entity }
06:56:37 <quchen> Something along those lines.
06:56:37 <Narvius> But yeah, I used Parsec before, it's just it'd take me way longer than someone who has actual use experience with it.
06:57:03 <sbidin`> How do I simply count the rows of a table using Esqueleto? Nothing I do seems to work. The examples online seem to be outdated.
06:57:05 <Narvius> quchen: I meant parsing the table of entities of wikipedia to get the table in the first place.
06:57:20 <quchen> Oh. Grep.
06:57:30 <mauke> did you mean: perl
06:57:42 <hpc> Narvius: seek to the string "<tr>\n<td>quot</td>" and then every line after a <tr> is an entity until the next </table>
06:57:52 <quchen> I don't know Perl. I know grep.
06:58:02 <hpc> it's a horrifying hack though
06:58:17 <tdammers> TagSoup
06:58:31 <tdammers> parse the thing into a DOM tree, then extract the parts you need
06:58:37 <Narvius> hpc: How is it a hack? It's just extracting data from an uncooperative source.
06:58:44 <lpaste> BoR0 revised “My first Monad(?)”: “No title” at http://lpaste.net/95508
06:58:51 <tdammers> beautifulsoup would also work, if python is acceptable
06:58:57 <hpc> Narvius: well, extracting data from an uncooperative source is hacky
06:59:02 <BoR0> how can I check if http://lpaste.net/95508 makes a monad? (I know it does, but how can I check it?)
06:59:04 <tdammers> or just DOMDocument in case you want to endure PHP
06:59:09 <hpc> hasn't stopped me from trying though ;)
06:59:40 <hpc> Narvius: you can get a quick framework for such a parser out of ghc-man-completion, btw
06:59:59 <hpc> which parses the ghc man page to generate a bash completion file
07:00:02 <quchen> BoR0: Show that the laws hold. For example, start with "return x >>= f" and show that it's always equal to "f x".
07:00:03 <Narvius> BoR0: Look up the monad laws and write functions to test with data you provide, it's not a proof, but it works.
07:01:13 <BoR0> quchen, but it is already equal to "f x", by definition
07:01:25 <Narvius> So the first law is fullfilled. :)
07:01:34 <BoR0> wow, was it that easy
07:01:44 <Narvius> Now do the other two :3
07:01:51 <BoR0> thanks, I'll try those myself
07:01:52 <quchen> BoR0: Not by definition. You first have to insert "return = Kinda" and then use the definition. :-P
07:02:19 <BoR0> well return x is equal to Kinda x, and the bind operator by definition states that Kinda x >>= f = f x
07:02:53 <quchen> Sure. But then all mathematical proofs are true "by definition" if the intermediate steps don't count.
07:02:59 <Narvius> xD
07:03:04 <quchen> (The intermediate step is trivial here of course.)
07:03:06 <BoR0> I see :) you are right
07:03:23 <Narvius> In a sense, mathematical proofs can't be true by anthing other than definition
07:03:27 <Narvius> But if one were to say it this way
07:03:33 <Narvius> "Definition" would lose all meaning
07:04:44 <Hodapp> this paper on "Total Functional Programming" is interesting. Had I read the intro a little more carefully the first time, I'd have realized that he purposely kept most of it separate from Martin-Löf type theory.
07:11:34 <Narvius> Huh, Kleisli Composition. Another one of those not hugely important things that make your code nicer nonetheless.
07:11:40 <Narvius> Haskell has waaay to many of those.
07:11:50 <Hodapp> bah?
07:12:17 <Narvius> (>=>)
07:12:58 <tdammers> :t (>=>)
07:12:59 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:13:21 <BoR0> how can I prove associativity? it doesn't look as trivial as left and right identity
07:14:19 <skypers> hey
07:14:22 <skypers> with a lens
07:14:41 <skypers> is it possible to view a part of a tuple using fst?
07:14:42 <skypers> on snd?
07:14:43 <skypers> like
07:14:51 <skypers> view fst (a,b) == a
07:14:55 <skypers> I don’t find it
07:14:57 <Narvius> It's called _1
07:15:03 <skypers> Narvius: I don’t what _1
07:15:04 <Narvius> And works on any tuple up to size 9
07:15:05 <donri> :t to fst
07:15:06 <lambdabot> (Functor f, Conjoined p, Contravariant f) => p a (f a) -> p (a, b) (f (a, b))
07:15:09 <skypers> I want a general function
07:15:10 <skypers> oh
07:15:10 <Narvius> view _1 (a, b) = a
07:15:10 <skypers> to
07:15:14 <skypers> thank you
07:15:28 <Narvius> _1 through _9 exist.
07:15:36 <mauke> _1 is a general function
07:15:39 <skypers> Narvius: I don’t want them here
07:15:40 <mauke> fst isn't
07:15:41 <donri> :t view (upon fst)
07:15:42 <lambdabot> (Data a, Data b, Monoid a, MonadReader (a, b) m) => m a
07:15:52 <skypers> huh
07:15:57 <skypers> to, or upon?
07:15:59 <donri> to
07:16:04 <donri> upon is evil magic
07:16:11 <Narvius> skypers: Just out of curiosity, why not?
07:16:19 <mauke> is upon the one that can write through fst?
07:16:21 <skypers> Narvius: because here it’s a simple example
07:16:25 <donri> mauke: yes
07:16:34 <skypers> I want to apply that concept to much complicated example
07:16:41 <skypers> like user-defined selector
07:17:01 <skypers> :t (%.)
07:17:02 <lambdabot>     Not in scope: `%.'
07:17:02 <lambdabot>     Perhaps you meant one of these:
07:17:02 <lambdabot>       `.' (imported from Data.Function),
07:17:05 <Narvius> Can you paste the more complicated example, please?
07:17:13 <Narvius> I wanna see it. :3
07:17:34 <Narvius> @hoogle to
07:17:34 <lambdabot> Prelude toEnum :: Enum a => Int -> a
07:17:34 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
07:17:34 <lambdabot> Prelude toRational :: Real a => a -> Rational
07:17:54 <skypers> well, imagine a transparent type you can access a part from with a function (not in the record syntax)
07:17:58 <skypers> how would you do that?
07:18:05 <skypers> not transparent
07:18:06 <skypers> opaque*
07:18:30 <Narvius> Write two functions, one that updates it and one that returns said part. Compose Lens from that.
07:18:51 <Narvius> Though I never had to do that before. x3
07:19:04 <donri> > [0..9] & upon (last . init) *~ 10
07:19:06 <lambdabot>   [0,1,2,3,4,5,6,7,80,9]
07:19:11 <donri> giggity
07:19:14 <skypers> yeah
07:19:16 <skypers> thank you donri
07:19:22 <skypers> this is exactly what I was looking for
07:19:23 <Narvius> Whoah
07:19:26 <Narvius> That looks like goddamn magic.
07:19:27 <lpaste> BoR0 revised “My first Monad(?)”: “No title” at http://lpaste.net/95508
07:19:29 <donri> skypers: why?
07:19:44 <Narvius> Such lens, very power
07:19:45 <Narvius> :t upon
07:19:45 <donri> oh, heh, didn't even read what you said
07:19:46 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
07:20:03 <mauke> Narvius: it is black magic
07:20:11 <Narvius> :t (*~)
07:20:12 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
07:20:38 <mauke> > (1, 2, 3) & _1 *~ 10
07:20:40 <lambdabot>   (10,2,3)
07:20:48 <mauke> > (1, 2, 3) & _2 *~ chr
07:20:49 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Char))
07:20:49 <lambdabot>    arising...
07:20:53 <donri> skypers: you need "upon" if you need to set or modify, but it's evil magic. if all you need is a getter, use "to"
07:21:19 <Narvius> donri: Could you please elaborate on what is evil about it?
07:21:22 <skypers> ok so hm
07:21:26 <zrho> these are from ed kmetts lens library?
07:21:33 <donri> zrho: yes
07:21:36 <skypers> (a,b)^._1 == (a,b)^.(to fst)
07:21:39 <skypers> right?
07:21:50 <Narvius> > (1, 2) ^. to fst
07:21:52 <lambdabot>   1
07:21:54 <Narvius> Yes.
07:21:55 <donri> > [0..9] & upon tail *~ 10
07:21:56 <lambdabot>   No instance for (GHC.Show.Show t0)
07:21:56 <lambdabot>    arising from a use of `M6830309360785...
07:22:13 <skypers> that sounds great
07:22:16 <Narvius> Wait, what
07:22:23 <Narvius> I need to run that in my own ghci to see what the error is
07:22:38 <Hodapp> http://mergeconflict.com/tag/kleisli-composition/ huhhhh.
07:23:23 <donri> > [0..9] & upon tail . traverse *~ 10
07:23:24 <lambdabot>   [0,10,20,30,40,50,60,70,80,90]
07:23:26 <donri> did not expect that to work
07:23:52 <donri> oh wait
07:23:59 <skypers> > (*10) <$> [0..9]
07:24:00 <lambdabot>   [0,10,20,30,40,50,60,70,80,90]
07:24:01 <donri> > [0..9] & upon tail . traverse +~ 10
07:24:03 <lambdabot>   [0,11,12,13,14,15,16,17,18,19]
07:24:24 <donri> why does it work!
07:24:53 <donri> oh, hm
07:24:53 <Narvius> Why don't I have upon loaded when I fully import Control.Lens? oO
07:25:00 <donri> because of how lists are defined
07:25:36 <skypers> donri: you always make me fell like crap with your lambdabot queries
07:25:39 <skypers> seriously.
07:25:40 <skypers> :D
07:25:43 <donri> why?
07:25:51 <donri> > [0..9] & upon init . traverse +~ 10
07:25:53 <lambdabot>   [0,11,12,13,14,15,16,17,18,19]
07:25:55 <skypers> because you’re so far away better than me
07:25:56 <donri> this is weird
07:26:02 <skypers> it takes me several minutes to read your lines :D
07:26:17 <donri> skypers: clearly i suck at readability then ;)
07:26:27 <skypers> donri: no
07:26:29 <mauke> Narvius: Data.Data.Lens
07:26:35 <chrisdone> skypers: if you remove the line noise it's not that hard
07:26:41 <Narvius> You can't beat @pl though; the way it uses composition operator sections
07:26:41 <Narvius> God
07:26:44 <skypers> I just lack some knowledge here
07:26:46 <Narvius> How can anyone decipher what it does
07:26:59 <mauke> Narvius: @pl is very mechanical
07:27:07 <skypers> Narvius: agreed :D
07:27:10 <mauke> lambda elimination is an old and simple trick
07:27:21 <Narvius> mauke: Also, thanks
07:27:32 <donri> > (1,2,3,4) & partsOf each %~ reverse
07:27:33 <lambdabot>   (4,3,2,1)
07:27:37 <hpc> we should teach @pl the lens operations
07:27:44 <Narvius> donri: What
07:27:48 <Narvius> How does that even
07:27:48 <donri> ;)
07:27:50 <mauke> Narvius: http://holumbus.fh-wedel.de/hayoo/hayoo.html
07:28:10 <skypers> donri: my very problem in Haskell
07:28:18 <skypers> is how everyone use magic to me
07:28:21 <skypers> like bifunctor
07:28:23 <skypers> semigroups
07:28:26 <ion> > ("good", "bye", "world") & partsOf (each . each) %~ reverse
07:28:28 <lambdabot>   ("dlro","wey","bdoog")
07:28:30 <skypers> and all that weird things
07:28:32 <Narvius> :t each
07:28:33 <skypers> those*
07:28:34 <lambdabot> (Indexable (Index t) p, Each f s t a b) => p a (f b) -> s -> f t
07:28:42 <chrisdone> bifunctors and semigroups are trivial, nothing magic there
07:28:43 <skypers> lenses actually scare me :D
07:29:01 <skypers> chrisdone: yeah but I don’t know them, and I feel like I should
07:29:01 <chrisdone> it's literally just a functor that has two types instead of one
07:29:06 <chrisdone> and a semigroup is monoid without an empty
07:29:12 <Narvius> That's
07:29:14 <Narvius> trivial
07:29:17 <skypers> chrisdone: yeah it’s really trivial
07:29:28 <skypers> why _everyone_ uses them then?
07:29:34 <sellout-> skypers: Lenses are great. When I discovered them, it eliminated so much code.
07:29:36 <chrisdone> because they're convenient?
07:29:54 <skypers> chrisdone: sure, but what for?
07:29:58 <skypers> I just wonder
07:30:00 <tdammers> my #1 reason for using lenses is because they fix the record syntax problem
07:30:08 <sellout-> And I discovered them in a code review, when the reviewer responded to my pile of new code with a suggestion of how to do it in one line.
07:30:11 <donri> > (1,2,3,4) & partsOf each %~ tail
07:30:11 <tdammers> particularly, record updates
07:30:13 <lambdabot>   (2,3,4,4)
07:30:13 <Narvius> tdammers: Indeed. Didn't have to use that in forever now.
07:30:13 <skypers> tdammers: this is why I’m learning them
07:30:15 <chrisdone> skypers: well, how do you (*2) the left value of an Either Int Int?
07:30:18 <sellout-> That was quite embarrassing.
07:30:27 <chrisdone> :t Data.Bifunctor.first
07:30:28 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
07:30:33 <chrisdone> :t Data.Bifunctor.first (*2)
07:30:34 <lambdabot> (Num b, Bifunctor p) => p b c -> p b c
07:30:38 <tdammers> skypers: do you have the lens cheatsheet handy at all times?
07:30:43 <skypers> chrisdone: hm
07:30:44 <chrisdone> > Data.Bifunctor.first (*2) (Left 23)
07:30:46 <lambdabot>   Not in scope: `Data.Bifunctor.first'
07:30:51 <chrisdone> stupid lambdabot
07:30:55 <skypers> I extract the left value, apply (*2) on it
07:31:00 <chrisdone> yeah, that's boring
07:31:00 <mauke> @let import Data.Bifunctor
07:31:01 <lambdabot>  <no location info>:
07:31:02 <lambdabot>      The package (tagged-0.7) is required to be trusted ...
07:31:05 <chrisdone> instead you just use `first'
07:31:21 <skypers> yeah
07:31:25 <skypers> great :)
07:31:36 <skypers> chrisdone: and what are semigroupoid?
07:31:43 <skypers> I see this package everywhere too
07:31:51 <mauke> I've never seen that :-)
07:31:59 <ion> It’s a category without id.
07:32:07 <skypers> so it’s semigroup?
07:32:10 <skypers> it’s the same thing?
07:32:16 <donri> no, that's monoid without mempty :)
07:32:22 <Narvius> xD
07:32:29 <ion> semigroupoid : category = semigroup : monoid, i think.
07:32:31 <tdammers> https://github.com/ekmett/lens/wiki/Operators
07:32:40 <chrisdone> skypers: are you familiar with the uses for monoids?
07:32:49 <skypers> chrisdone: yes
07:32:50 <skypers> I do
07:32:52 <donri> :t (Control.Category.., mappend)
07:32:52 <lambdabot> parse error on input `,'
07:32:54 <skypers> use them a lot
07:33:06 <donri> :t ((Control.Category..), mappend)
07:33:07 <lambdabot> (Category cat, Monoid a1) => (cat b c -> cat a b -> cat a c, a1 -> a1 -> a1)
07:33:19 <chrisdone> skypers: so sometimes you have something like monoid but nothing to write for mempty. so instead you use a semigroup
07:33:32 <tdammers> view, set, over, and their stateful counterparts are incredibly useful by themselves
07:33:38 <chrisdone> skypers: e.g., a non-empty list
07:33:47 <skypers> I see
07:33:54 <donri> obligatory read ;) https://www.fpcomplete.com/user/edwardk/editorial/procrustean-mathematics
07:34:01 <skypers> and semigroupoid are just category without di
07:34:02 <skypers> id*
07:34:33 <ion> Categories are (among other things) a generalization of monoids.
07:34:53 <danharaj> Categories are the categorification of monoids.
07:35:14 <bz> :t sum . zipWith (*
07:35:15 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:35:16 <bz> :t sum . zipWith (*)
07:35:17 <lambdabot>     Couldn't match type `[c1] -> [c1]' with `[c0]'
07:35:17 <lambdabot>     Expected type: [c1] -> [c0]
07:35:17 <lambdabot>       Actual type: [c1] -> [c1] -> [c1]
07:35:30 <Iceland_jack> bz: zipWith (*) takes two arguments
07:35:35 <skypers> ahah
07:35:43 <skypers> I don’t even find the french for semigroupoid
07:35:46 <skypers> :D
07:35:51 <bz> :t zipWith
07:35:52 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
07:35:54 <skypers> that’s disturbing
07:36:03 <donri> :t fmap sum . zipWith (*)
07:36:04 <lambdabot> Num c => [c] -> [c] -> c
07:36:55 <skypers> oh
07:37:06 <skypers> group, groupoid, semigroup, semigroupoids
07:37:07 <skypers> hihi
07:37:12 <skypers> reminds me my math course
07:37:50 <donri> skypers: "oidification" http://ncatlab.org/nlab/show/horizontal+categorification
07:38:05 <mauke> demi-groupoïde or something
07:38:23 <skypers> thank you
07:38:25 <skypers> oh
07:38:34 <skypers> I have my own <~ operator for my 3D engine
07:38:39 <skypers> and lens has its own too
07:38:43 <skypers> conflict…
07:39:49 <bz> donri: i don't get why fmap
07:39:50 <chrisdone> don't worry about that, lens takes up most of the operator namespace
07:40:02 <chrisdone> just don't import *.Operators and use the lens functions
07:40:22 <skypers> 16:26 < chrisdone> don't worry about that, lens takes up most of the operator namespace
07:40:25 <bz> let f u v = sum $ zipWith (*) [1..3] [2..4]
07:40:27 <skypers> isn’t it infinite?
07:40:29 <chrisdone> over, each, upon, view, etc. rather than %~ %+ .~ .<@ >@@>@#>@@@##
07:40:32 <chrisdone> woops, went a bit insane there
07:40:40 <bz> > let f u v = sum $ zipWith (*) u v in f [1..3] [2..4]
07:40:41 <lambdabot>   20
07:40:42 <skypers> @@@##
07:40:43 <skypers> :D
07:40:48 <skypers> :t (@@@##)
07:40:49 <lambdabot> Not in scope: `@@@##'
07:40:53 <skypers> « ouf »
07:41:01 <chrisdone> skypers: i think there's a finite set of operators that are desirable
07:41:08 <chrisdone> the rest are just ugly as hell and annoying to read and type
07:41:16 <skypers> chrisdone: I mean
07:41:19 <mauke> Control.Schtroumpf
07:41:23 <skypers> if we can define a (====) operator
07:41:30 <chrisdone> speak for yourself ;)
07:41:30 <skypers> can’t we define a (=====) operator as well?
07:41:31 <Iceland_jack> Needs more ='s
07:41:34 <skypers> :D
07:41:45 <chrisdone> yeah, and i'd burn the source code and the computer i read it on
07:41:52 <skypers> so yeah in theory I think it’s infinite
07:42:00 <skypers> chrisdone: definitely :D
07:42:03 <Hodapp> didn't PHP already claim up to ==========?
07:42:13 <chrisdone> sure, but the actual namespace of operators people want to use is quite limited
07:42:13 <skypers> sure it did
07:42:26 <chrisdone> at least, operators i want to use and read
07:42:27 <skypers> yeah up to two or three characters
07:42:34 <Hodapp> where 0 ========== 0.0 but 0.0 !========== 0
07:42:50 <mauke> does lens use (?)?
07:42:52 <Iceland_jack> I don't see a problem with that
07:42:58 <skypers> Haskell has already 100 times much more operators than any language
07:43:16 <supki> mauke: it did
07:43:28 <supki> someone cried and now it's (??)
07:43:32 <supki> =(
07:43:34 <skypers> Hodapp: 1 <========== 0.0 ========== "false"
07:43:34 <tdammers> skypers: not really... it just allows you to define your own
07:43:35 <skypers> in PHP
07:43:47 <skypers> tdammers: yeah, so it does
07:43:49 <chrisdone> supki: don't worry, any operator not claimed by lens will be eventually
07:43:51 <skypers> doesn’t it?
07:44:06 <Narvius> Well, I'd complain about lens operators
07:44:12 <skypers> ok so
07:44:13 <Narvius> But they're grouped sensibly
07:44:13 <skypers> view
07:44:16 <Narvius> ^.
07:44:17 <skypers> is the same thing as…
07:44:19 <skypers> ^.
07:44:21 <skypers> yeah
07:44:22 <skypers> and views?
07:44:25 <Narvius> ^?
07:44:29 <Narvius> I think?
07:44:30 <skypers> holy crap :D
07:44:31 <Narvius> What does views do?
07:44:33 <edwardk> mauke: we deliberately chose not to use (?) and used (??) instead. this fact consistently pains me ;)
07:44:37 <skypers> it’s like gets
07:44:39 <skypers> or puts
07:44:40 <skypers> or asks
07:44:44 <Narvius> aah
07:44:45 <skypers> it applies a function
07:44:47 <Narvius> Iunno then
07:44:59 <edwardk> views doesn't have an operator form, its ternary and has no good binary split
07:45:01 <Narvius> Probably still ^.
07:45:04 <Narvius> xD
07:45:10 <skypers> yeah
07:45:27 <bob_s> Any idea why I get this: "No instance for (Data.Graph.Inductive.Graph.Graph g0) arising from a use of graphviz' " ?
07:45:42 <edwardk> views i reserve the right to revisit the (?) vs (??) question now that folks have seen how useful (??) is ;)
07:46:25 <skypers> :t ((?))
07:46:26 <lambdabot> Not in scope: `?'
07:46:26 <edwardk> > (1,"hello")^._2.to length
07:46:27 <lambdabot>   5
07:46:33 <mauke> edwardk: you can always use one of ⁇ ¿ ؟ ﹖ ❓ ❔ ⍰ ︖ instead
07:46:35 <edwardk> you can always model views with that
07:46:36 <chrisdone> Narvius: more importantly there're human word versions of each operator =)
07:46:51 <skypers> mauke: please don’t.
07:46:53 <chrisdone> mauke: what's the last one? i have no font capable of rendering it
07:47:04 <tdammers> also, namespaces / qualified imports
07:47:04 <mauke> U+FE16 (ef b8 96): PRESENTATION FORM FOR VERTICAL QUESTION MARK [︖]
07:47:05 <chrisdone> mauke: also ‽ =p
07:47:06 <edwardk> skypers: lens restricts the use of unicode to the comments for now =)
07:47:21 <jrmithdobbs> chrisdone: as someone new to haskell i agree with you re: operators
07:47:24 <skypers> that’s a great idea :D
07:47:41 <jrmithdobbs> why so goddamned many of them for every different abstraction
07:47:42 <mauke> chrisdone: http://mauke.hopto.org/stuff/javascript/unicode.html?q=%E2%81%87%20%C2%BF%20%D8%9F%20%EF%B9%96%20%E2%9D%93%20%E2%9D%94%20%E2%8D%B0%20%EF%B8%96
07:47:46 <Narvius> :t (??)
07:47:47 <lambdabot> Functor f => f (a -> b) -> a -> f b
07:47:56 <skypers> jrmithdobbs: this makes Haskell harder to learn, indeed
07:48:05 <skypers> Narvius: hm
07:48:12 <skypers> :t (<*>(
07:48:13 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:48:13 <tdammers> Haskell isn't optimized for a shallow and short learning curve anyway
07:48:14 <skypers> :t (<*>)
07:48:15 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:48:24 <Narvius> edwardk: Can you show me some simply application of (??)?
07:48:46 <mauke> > [id, (+1), (*20)] ?? 5
07:48:47 <chrisdone> mauke: bêåüṫïﬀųĺ!
07:48:48 <lambdabot>   [5,6,100]
07:48:51 <Narvius> Haskell is like fighting games; high entry level, infinite learning afterwards.
07:49:08 <sellout-> bimap Set.findMin Set.findMin x – is there any way to eliminate the duplicate findMin?
07:49:22 <skypers> oh
07:49:26 <skypers> that (??)
07:49:31 <skypers> I needed it some days ago
07:49:34 <edwardk> I originally wrote lens for me. I wasn't optimizing it for its learning curve, but rather for assuming it should do what I wanted it to do when I was using it a year out.
07:49:35 <Narvius> mauke: Is there a reason it's called "??", then? It's not a very evocative name.
07:49:37 <jrmithdobbs> skypers: i think haskell is a great justification for c++/ruby's approach to overloading operators ... a fixed small well defined set (preferably not abused via context like << but we'll ignore that) that be overridden but especially with infix functions arbitrary operator definition to leads to ugliness
07:49:44 <chrisdone> what's the word version of (??)?
07:49:50 <edwardk> > set _1 ?? (1,2) $ 3
07:49:52 <lambdabot>   (3,2)
07:49:54 <skypers> edwardk: arf
07:50:05 <edwardk> ?? goes in like a placeholder.
07:50:05 <lambdabot>  goes in like a placeholder.
07:50:14 <ion> :-D
07:50:16 <edwardk> see, even lambdabot agrees
07:50:17 <mauke> sellout-: depends on the types
07:50:21 <jrmithdobbs> skypers: i just don't get all the operators when you can just `bareword` and have an infix function that's easy to ready =/
07:50:22 <skypers> jrmithdobbs: Haskell isn’t ugly
07:50:24 <edwardk> chrisdone: 'flip'
07:50:27 <skypers> but lenses
07:50:29 <skypers> well yeah
07:50:35 <skypers> I really think it makes code harder to read
07:50:45 <edwardk> as an operator though with its fixity it slots in very well with evrything else
07:50:46 <Narvius> I think Haskell is about the only language that *can* allow itself to use a multitude of operators.
07:50:48 <tdammers> that sounded a bit like a quine-ish statement / predicate
07:50:52 <Narvius> Exactly due to it's high abstraction level.
07:50:57 <skypers> I have my operators
07:50:58 <tdammers> "goes in like a placeholder" goes in like a placeholder
07:51:01 <sellout-> mauke: Yeah, that’s what I figured. The sets are different types.
07:51:01 <skypers> for instance
07:51:05 <edwardk> skypers: its a matter of taste. i recommend using just the few core operators for getting started
07:51:18 <jrmithdobbs> Narvius: and i think it gives a lot of examples of fine justification for why others have decided not to allow that, specifically re: operators at least ;p
07:51:22 <tdammers> which is even nicer considering that "??" itself can be considered a placeholder
07:51:22 <edwardk> and branch out later once you get a feel for how they extend
07:51:33 <skypers> if you know OpenGL, there’re uniforms, that allows you to “bridge” variables over GPU. I use the <~ operator for that
07:51:42 <skypers> because it’s VERY common to do
07:51:47 <skypers> I don’t want the user to write
07:51:53 <Narvius> jrmithdobbs: Well, if we were to disallow every feature that can be abused, we wouldn't have gotten past interrupts a few decades ago
07:51:55 <Narvius> :)
07:51:58 <edwardk> (??) was added because the alternative was giving in and giving people the 50 other functions they wanted that were all flipped versions of things with the last two args flopped so they could pipeline them
07:51:59 <tdammers> jrmithdobbs: about the c++ example - I would counter by asking what makes the operators C++ allowed special
07:52:00 <skypers> myGPUvariable `sendToGPU` 4
07:52:16 <edwardk> or forcing the user to contort their code in awkward ways
07:52:21 <mauke> > let quine = liftA2 (++) show (' ' :) in quine "is a sentence with a hole"
07:52:22 <lambdabot>   "\"is a sentence with a hole\" is a sentence with a hole"
07:52:27 <skypers> edwardk: so the core ones are… what?
07:52:28 <skypers> ^.
07:52:30 <tdammers> also, C++ is actually a nice example of how restricting the available operators has somewhat undesirable consequences
07:52:32 <skypers> %=
07:52:35 <skypers> .~
07:52:36 <skypers> %~
07:52:40 <skypers> that’s it?
07:52:41 <Narvius> The mathematical setters
07:52:44 <Narvius> +~ and so on
07:52:47 <skypers> they’re clear
07:52:49 <skypers> but hm
07:52:52 <skypers> the nail one
07:52:54 <skypers> the fish
07:52:54 <jrmithdobbs> tdammers: they're fairly arbitrary, i'll give you, and of course to the latter, it goes both ways
07:52:55 <skypers> the rabbit
07:52:57 <skypers> the poney
07:52:58 <skypers> and so on
07:52:58 <edwardk> I'd add (^?) and (^..)
07:53:00 <skypers> please :D
07:53:03 <Narvius> Yes, ^? is useful.
07:53:08 <tdammers> just consider >> in C++
07:53:13 <skypers> what is it for?
07:53:15 <edwardk> nail one?
07:53:15 <chrisdone> jrmithdobbs: i subscribe to the lisp school of just using english words
07:53:21 <jrmithdobbs> tdammers: i called out << and >> in my use of teh example, no fair!
07:53:26 <skypers> edwardk: snail*
07:53:30 <edwardk> ^@. >
07:53:31 <edwardk> ?
07:53:54 <edwardk> @ is used to modify any of the other operators you've given so far to make it also return the index of an index lens.
07:53:56 <edwardk> thats it
07:53:58 <skypers> edwardk: no
07:53:58 <edwardk> its one rule
07:54:02 <tdammers> jrmithdobbs: well, then you'll agree with me that bit shifting and stream output have absolutely nothing in common except precedence rules and fixity
07:54:02 <skypers> :t (^@..)
07:54:03 <lambdabot> s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
07:54:04 <edwardk> now you know 5 other operators
07:54:05 <skypers> that one…
07:54:07 <jrmithdobbs> chrisdone: ya, i really really like haskell's infix-ability of normal functions
07:54:07 <haasn> ^? is probably my most used lens operator
07:54:09 <tdammers> which is mere coincidence
07:54:19 <haasn> next to ^..
07:54:24 <kuribas> What's a good functional programming language for programming android?
07:54:26 <skypers> :t (^..)
07:54:26 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
07:54:28 <tdammers> and having dedicated operators for each would have been a lot less confusing
07:54:37 <benj_> my personal taste is that I find `infix` english words a lot ugiler than symbolic ones :)
07:54:40 <edwardk> > ["hello","world"]^@..traversed<.>traversed
07:54:41 <lambdabot>   [((0,0),'h'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o'),((1,0),'w'),((...
07:54:43 <kuribas> I have been reading some scala, but it doesn't look very functional.
07:54:47 <edwardk> > ["hello","world"]^@..traversed.traversed
07:54:48 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(0,'w'),(1,'o'),(2,'r'),(3,'l'),(4...
07:54:50 <tdammers> anyway, it's a fine line
07:54:53 <skypers> I just can’t read edwardk lines
07:54:55 <edwardk> it tells you the index
07:55:01 <jrmithdobbs> tdammers: yes, and I'd say that particular problem in c++ is expressed better in ruby where they took the same "small subset of special overridable operators" but stole enough functional concepts to make nobody care
07:55:01 <skypers> I really suck at Haskell actually
07:55:03 <skypers> dammit!
07:55:03 <chrisdone> jrmithdobbs: i don't like that much, personally. any exceptions from the general simple rules of function application make it more laborious to read, write and edit
07:55:16 <Narvius> edwardk: That's cool, I didn't know about @!
07:55:28 <mauke> > let quine = var . liftA2 (++) show (' ' :) in quine "is a sentence with a hole"
07:55:29 <lambdabot>   "is a sentence with a hole" is a sentence with a hole
07:55:42 <edwardk> ^@.. is just ^.. with the extra index information kept around when applied to an indexed traversal.
07:55:44 <jrmithdobbs> chrisdone: i like it better than arbitrary character-only bare operators though for sure
07:55:57 <jrmithdobbs> *special-character-only
07:56:08 <edwardk> many of the traversals in lens are indexed. you can do things like walk down a map, using the key as an index. filter on the index, etc.
07:56:14 <skypers> seriously
07:56:20 <edwardk> yes, seriously.
07:56:24 <skypers> who (except edwardk) can read that:
07:56:24 <edwardk> i use this stuff all the time =P
07:56:25 <skypers> ["hello","world"]^@..traversed<.>traversed
07:56:31 <mauke> skypers: I can
07:56:37 * bennofs too
07:56:38 <mauke> doesn't mean I know what it means, though
07:56:42 <edwardk> > ["hello","world"]^..traverse.traverse
07:56:44 <lambdabot>   "helloworld"
07:56:44 <mauke> but the tokens are clear
07:56:50 <chrisdone> skypers: you just can't read the operators
07:56:50 <edwardk> > ["hello","world"]^@..traverse.traversed
07:56:51 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(0,'w'),(1,'o'),(2,'r'),(3,'l'),(4...
07:56:55 <edwardk> > ["hello","world"]^@..traversed.traversed
07:56:56 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(0,'w'),(1,'o'),(2,'r'),(3,'l'),(4...
07:56:58 * hackagebot DrIFT 2.4.2 - Program to derive type class instances  http://hackage.haskell.org/package/DrIFT-2.4.2 (KiwamuOkabe)
07:56:59 <edwardk> > ["hello","world"]^@..traversed<.>traversed
07:57:01 <lambdabot>   [((0,0),'h'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o'),((1,0),'w'),((...
07:57:01 <bennofs> It's just a double traverse with the indices as pairs afair
07:57:08 <Narvius> I still don't understand
07:57:22 <Narvius> > (1, 2, 3, 4) & partsOf each %~ reverse
07:57:24 <lambdabot>   (4,3,2,1)
07:57:24 <edwardk> (<.>) glues together two indexed traversals into an indexed traversal that tuples their indices.
07:57:25 <bennofs> > [a,b,c] ^.. traversed
07:57:27 <lambdabot>   [a,b,c]
07:57:27 <skypers> I still don’t wanto to understand
07:57:29 <bennofs> > [a,b,c] ^@.. traversed
07:57:30 <skypers> it would blur me
07:57:31 <lambdabot>   [(0,a),(1,b),(2,c)]
07:57:44 <zrho> :t traversed
07:57:45 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
07:57:50 <edwardk> Narvius: partsOf turns a traversal into a lens of the list of its targets
07:57:51 <Narvius> But that's probably because I've never used partsOf or each before.
07:57:52 <tdammers> my biggest gripe with lens is how the type signatures are sometimes so massive that I don't feel like figuring them out
07:58:00 <chrisdone> i need to write a lambdabot plugin that translates lens operators back  to english
07:58:02 <skypers> exactly tdammers
07:58:04 <skypers> exactly.
07:58:05 <zrho> exactly.
07:58:13 <Narvius> That's about the only flaw.
07:58:21 <skypers> a big one
07:58:25 <Narvius> Naaah.
07:58:28 <edwardk> i don't know how to fix that without losing the other properties i like about lens
07:58:29 <skypers> why is it so big btw?
07:58:31 <kuribas> How does scala compare to haskell?
07:58:38 <tdammers> I figure it's kind of necessary in order to keep it sufficiently abstract
07:58:38 <Narvius> There are enough sources to learn about it than type signatures.
07:58:50 <edwardk> skypers: because there are about 20 other tiny little minimalist lens libraries, so i decided to try to do something different.
07:58:51 <tdammers> i.o.w., lenses and lens operators work "magically" on lots of things
07:58:51 <Narvius> other than*
07:58:54 <skypers> I mean, what is the main purpose of your lens package edwardk?
07:58:57 <tdammers> so they *have* to be fairly abstract
07:58:58 <edwardk> It seems to have somehow taken off as a result
07:59:09 <chrisdone> edwardk: just like jQuery!
07:59:19 <zrho> It has been a prohibiting flaw, although you might not be able to fix that. I am therefore guilty of often prefering fclabels over lens.
07:59:23 <edwardk> chrisdone: jquery for haskell ADTs is a fair comparison
07:59:25 <chrisdone> sizzle is the core of jQuery, everything else is embellishment
07:59:56 <edwardk> zrho: i can't think the thoughts i want to think in fclabels. i find that i fall out of the narrow range of applicability too easily.
07:59:56 <Narvius> Frankly, "it's a traversal", "it's a lens" and so on is all you have to know most of the time
07:59:58 <chrisdone> but nobody uses sizzle
08:00:18 <edwardk> what i like about lens is i can write simple stuff with lens, but when i go to write harder stuff there is still vocabulary available at my disposal.
08:00:34 <edwardk> if i go to bolt a function on the end of an fclabels lens, i'm out of the box, i need to switch abstractions
08:00:57 <mauke> lens makes hard things easy and impossible things possible?
08:01:05 <skypers> zrho: fclabels has get and set
08:01:06 <edwardk> if i go to write something with data-lens and need to change a type i have to stop, throw out all the things i wrote and start over.
08:01:28 <skypers> it collides with the State’s ones right?
08:01:34 <zrho> Yes.
08:01:42 <benj_> kuribas, somewhat disappointingly
08:02:03 <zrho> I see how lens is more powerful than fclabels. I still did not quite get them.
08:02:15 <edwardk> my goal with lens was to write something where f you reached for something and went to use it with something else, it 'just worked' for deep abiding sensible reasons, not for any ad hoc overloading purpose, but because of something you could go back to the underlying form of and look around at the laws you had at your disposal and _know_ that was the only possible thing it could have done
08:02:21 <lpaste> bob pasted “error: No instance for (Graph g0) arising from...” at http://lpaste.net/95513
08:02:31 <zrho> edwardk: you once did a talk about lenses, folds and traversals. are the slides somewhere out there? I can't read them in the video.
08:02:47 <edwardk> zrho: they should be linked from the youtube link
08:02:48 <skypers> woah edwardk
08:02:51 <skypers> impressive then
08:02:54 <benj_> they are just about readable at 1080p on youtube :D
08:03:01 <sellout-> Is there any way to make a typeclass an instance of another class? IE, if you implement the new typeclass, you get the other classes for free.
08:03:07 <skypers> I’m just looking for a little library that fix the record syntax issue
08:03:26 <skypers> because I don’t – up to know – feel to need your snail and shark and mouse operators
08:03:32 <edwardk> skypers: sure. it does that 'in passing', but its basically an afterthought. ;)
08:03:35 <zrho> edwardk: oh, they are^^ totally overlooked them.
08:03:37 <skypers> even if I can see how powerful lens is
08:03:40 <edwardk> skypers: then by all means don't use them
08:03:47 <bob_s> guys, I got a little problem: http://lpaste.net/95513. Any help ?
08:03:53 <jrmithdobbs> the record syntax issue?
08:03:56 <skypers> yeah
08:03:59 <edwardk> most users never mov beyond the basics that SPJ got to in his talk
08:04:07 <skypers> when you want to scope in a value with nested types
08:04:14 <skypers> and returns the whole thing
08:04:17 <edwardk> skypers: just because the stuff is there doesn't mean you have to rush out and figure it all out right away
08:04:19 <skypers> you end up with ugly {}
08:04:29 <skypers> edwardk: yeah but
08:04:39 <edwardk> just knowing that it is there and that you won't get stuck in a corner with no way out is reassuring to a lot of folks
08:04:54 <skypers> that’s a very true statement
08:05:09 <edwardk> but its overwhelming. i'm sorry. can't do anything about that without crippling my ability to think about the library, which i frankly, am not in a hurry to do
08:05:41 <quicksilver> it is a problem with the haskell language that a certain kind of entirely reasonable composition of functionality
08:05:49 <quicksilver> leads to unmanageable type signatures
08:06:01 <skypers> edwardk: well, the “basic” operators are very clear
08:06:08 <quicksilver> "unmanageable" is not the right word, actually
08:06:11 <skypers> but the other ones really scare me
08:06:11 <edwardk> i've been trying to figure out a type system that can give me binders for the sort of optics used by lens.
08:06:12 <quicksilver> just unriendly.
08:06:18 <teneen> can I profile an executable which uses libraries which weren't installed with -p cabal option?
08:06:32 <skypers> teneen: no
08:06:41 <skypers> you have to reinstall the whole as profiled
08:06:43 <nooodl> hmm... i wrote my first lens program and i can't tell if the code is unreadable or if i'm just not used to how programs using lens look
08:06:45 <edwardk> e.g. _1 :: Lens x. (x,b) b    with the right rules for composition, ec.
08:06:47 <dcoutts> teneen: you can get a limited heap profile without using profiling mode
08:07:01 <edwardk> er
08:07:06 <quicksilver> anyway, the 'unfriendliness' of types with multiple MPTC constraints has discouraged lots of people from writing code using this kind of abstraction.
08:07:08 <edwardk> Lens x. (x,y) x
08:07:09 <teneen> dcoutts: I can't add cost centres?
08:07:21 <quicksilver> which is a shame. But it's not obvious how to solve, either.
08:07:24 <teneen> skypers: I'll have to go through some cabal hell :S
08:07:32 <skypers> teneen: not really
08:07:44 <skypers> you should alter your .cabal
08:07:52 <skypers> to always install the profilling version of libraries
08:07:57 <dcoutts> teneen: the cost centre stuff requires using profiling mode, the non-prof heap profile has a very limited kind of breakdown
08:07:58 <skypers> or use cabal sandboxes*
08:08:00 <edwardk> quicksilver: i tend to try to minimize the use of MPTCs in my code, which s kind of humorous when you consider te types in lens ;)
08:08:23 <skypers> MPTC?
08:08:33 <zrho> multi param type classes
08:08:50 <skypers> ok, thank oyu
08:08:51 <skypers> you*
08:08:57 <shergill> carter: thanks for telling me about zinkov's project
08:09:20 <edwardk> but thats one reason why lens gets so much mileage out of single parameter typeclasses, profunctor, contravariant, applicative, bifunctor, traversable, etc.
08:09:31 <nooodl> http://lpaste.net/95514 am i doing anything obviously awful/ugly here?
08:09:45 <skypers> nooodl: reading
08:09:50 <nooodl> thank you!
08:10:10 <quicksilver> edwardk: *nod*
08:10:18 <skypers> step b = b & pc %~ wrap . ((b ^. dir) +)
08:10:29 <skypers> I’m not very used to reading lens but hm
08:10:39 <skypers> it’s very hard for me to understand that line
08:10:52 <donri> bz: sorry i was away. fmap here relies on the functor instance for functions, aka. the reader monad
08:11:00 <edwardk> https://www.fpcomplete.com/user/edwardk/editorial/procrustean-mathematics talks a bit about the motivations behind 'rightsizing' abstractions
08:11:21 <edwardk> that line is pretty hard for me to read to
08:11:28 <nooodl> maybe: step b = b & pc .~ wrap ((b ^. dir) + (b ^. pc))
08:11:29 <ski> (s/ monad//)
08:11:58 <edwardk> over pc ?? b $ \x -> wrap (b^.dir + x)
08:12:05 <bennofs> skypers: I usually find it easier to read if you write ((b ^. dir) +) as (b^.dir +)
08:12:09 <skypers> edwardk: which one?
08:12:11 <edwardk> thats more legible to me
08:12:17 <edwardk> thats 'step b'
08:12:26 <nooodl> :t (??)
08:12:26 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:12:27 <skypers> ok, I’m not alone then
08:12:34 <bob_s> guys, any idea what I'm getting wrong here: http://lpaste.net/95513 ?
08:12:34 <chrisdone> i like this post! http://philipnilsson.github.io/Badness10k/articles/waterflow/
08:12:41 <edwardk> i don't tend to pointfree functions passed to %~
08:12:46 <bennofs> > f ?? x $ a
08:12:47 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
08:12:47 <lambdabot>    arising from a us...
08:12:51 <edwardk> thats the compromise i use for readability
08:13:05 <skypers> > [1+, 3+] ?? 4
08:13:06 <lambdabot>   A section must be enclosed in parentheses thus: (1 +)A section must be encl...
08:13:17 <skypers> > [(1+), (3+)] ?? 4
08:13:18 <lambdabot>   [5,7]
08:13:23 <tdammers> I find it funny how Haskell code often becomes *more* readably when you pointfree it (or point-reduce at least)
08:13:37 <edwardk> the fact that (??) works for fmapping lik that is mostly an accident
08:13:39 <skypers> hm
08:13:39 <edwardk> :t (??)
08:13:40 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:13:55 <edwardk> ^- f there s almost always (,) e
08:14:00 <skypers> > (+) <$> [1..4] <*> pure 1
08:14:01 <lambdabot>   [2,3,4,5]
08:14:13 <skypers> is (??) faster than my last line?
08:14:16 <edwardk> :t (<**>)
08:14:16 <bennofs> > (f :: Expr -> Expr -> Expr) b $ a
08:14:17 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
08:14:17 <lambdabot>   f b a
08:14:43 <edwardk> hard to say for that case
08:14:57 <bennofs> > let f' = f :: Expr -> Expr -> Expr in f' ?? b $ a
08:14:58 <skypers> edwardk: pure 1 here yiels [1]
08:14:59 <lambdabot>   f a b
08:15:08 <edwardk> sure
08:15:09 <skypers> but with (??), I’m not sure
08:15:21 <donri> edwardk: wait, (,)? not (->)?
08:15:24 <donri> (f)
08:15:33 <edwardk> the issue is that the >>= used under the hood of (<*>) may not get inlined nough to turn that into an fmap
08:15:58 <edwardk> donri: you're right,its (->) e
08:16:47 <haasn> edwardk: you mean (-> -- oh yeah
08:17:04 <donri> 2slow
08:17:15 <haasn> sorry, I was being distracted :(
08:17:23 <donri> =)
08:18:12 <skypers> where is (&) from?
08:18:18 <skypers> @hoogle (&)
08:18:19 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
08:18:19 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
08:18:19 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
08:18:19 <donri> also lens
08:18:24 <skypers> arf
08:18:26 <donri> it's flip ($)
08:18:37 <skypers> it should be in Data.Function
08:18:46 <nooodl> i guess i could write: step b = b & pc +~ b^.dir
08:18:46 <nooodl>                                   & pc %~ wrap
08:18:52 <donri> that's been debated to death on libs@
08:18:53 <edwardk> skypers: the core libraries committee just agreed with you. the patch should be forthcoming
08:18:57 <hpc> a lot of lens stuff could be made less generic and go there
08:18:58 <donri> oh!
08:19:08 <skypers> YEAH!
08:20:17 <edwardk> i even recused myself from the discussion. it was unanimous from everyone who participated, so i don't feel bad
08:20:36 <donri> edwardk: is this on some other list?
08:21:17 <donri> hm i was looking at ghc-users :/
08:21:37 <skypers> (&) is great
08:21:52 <cschneid> & is just a flipped $, yes?
08:21:53 <Narvius> :t (??)
08:21:54 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:21:56 <Narvius> So
08:21:57 <Narvius> ??
08:21:59 <donri> nope nothing new on libs@ either
08:22:00 <Narvius> is just an extended &
08:22:11 <Narvius> flipped map
08:22:15 <skypers> @let (&) = flip ($)
08:22:17 <lambdabot>  Defined.
08:22:23 <skypers> > (1,2) & fst
08:22:24 <lambdabot>   Ambiguous occurrence `&'
08:22:24 <lambdabot>  It could refer to either `L.&', defined at L.hs:1...
08:22:25 <donri> skypers: it was already in lambdabot :p
08:22:26 <mauke> @undefine
08:22:26 <lambdabot> Undefined.
08:22:38 <skypers> ah
08:22:43 <skypers> sorry then :/
08:22:54 <skypers> but hm
08:23:02 <skypers> yeah
08:23:10 <skypers> is there a reverse version of (.)?
08:23:16 <skypers> like (>=>) and (<=<)
08:23:22 <nooodl> (<<<)
08:23:25 <simpson> :t (>>>)
08:23:26 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
08:23:26 <nooodl> err (>>>)
08:23:30 <haasn> hpc: like traverseOf ;)
08:23:48 <edwardk> donri: ping http://www.haskell.org/haskellwiki/Core_Libraries_Committee
08:24:00 <mauke> > (show >>> length) 100
08:24:01 <lambdabot>   3
08:24:31 <skypers> > 100 & (show >>> length)
08:24:33 <lambdabot>   3
08:24:36 <skypers> ok so hm
08:24:47 <skypers> if I have nested type with record syntax
08:24:57 <skypers> I can make weak lenses with & and >>> or <<< !
08:25:06 <Narvius> Generate lenses with TH
08:25:09 <Narvius> Use as usual
08:25:30 <nooodl> i feel code often makes more sense using (&) and (>>>)
08:25:31 <Bor0> could anyone help me with this http://lpaste.net/95508, how can I start proving associativity?
08:25:37 <edwardk> skypers: now, write back to that
08:25:53 <skypers> wait I’m experiencing the stuff!
08:25:54 <skypers> :)
08:26:37 <nooodl> Bor0: expand "(m >>= f) >>= g" and "m >>= (\x -> f x >>= g)" for m = Nope and m = Kinda x?
08:28:19 <nooodl> should get you Nope ≡ Nope, Kinda (g (f x)) ≡ Kinda (g (f x))
08:29:54 <nooodl> or wait. i can't read
08:33:35 <skypers> ok, creating getters with (&) and (>>>) is simple
08:33:39 <skypers> but a setter…
08:36:24 <Bor0> nooodl, can you refresh that page and check if what I did is ok?
08:37:23 <nooodl> Bor0: (Kinda n >>= f) should be (f n), not (Kinda (f n))
08:37:54 <Bor0> hmm, how's that?
08:37:55 <nooodl> so you have to split it into two cases for "(f n) = Nope" and "(f n) = Kinda o"
08:38:31 <nooodl> i made an error earlier, though. you won't get Kinda (g (f x))
08:38:34 <Bor0> oh yeah, I am just proving for Kinda. I think the same can be applied to Nope analogously so I left that
08:39:17 <FreeFull> f is some function from a to Kinda a
08:39:35 <FreeFull> Or whatever it is called
08:40:21 <p2147483647> Where have natural transformations from category-extras gone?
08:40:30 <edwardk> they haven't.
08:40:31 <p2147483647> has that become lens?
08:40:37 <edwardk> i just write them out by hand =)
08:40:37 <mm_freak_> p2147483647: ad hoc functions
08:40:42 <edwardk> forall x. f x -> g x
08:41:08 <mm_freak_> p2147483647: for monad morphisms you can use the mmorph library, but that's not for general NTs
08:41:18 <p2147483647> I probably mean monad morphisms
08:41:21 <p2147483647> I'm mapping Either to IO
08:41:30 <teneen> when compiled using -fprog-all -prof and run using +RTS -p the profiler is telling me that main took 100% of time and alloc. How can I get more useful info? :D
08:41:43 <mm_freak_> p2147483647: not sure if that's a proper NT
08:42:03 <FreeFull> Either to IO? What happens to Left?
08:42:12 <mm_freak_> FreeFull: throwIO probably
08:42:19 <p2147483647> error, because I hate good code
08:42:28 <mm_freak_> forall a. (Exception e) => Either e a -> IO a
08:42:54 <FreeFull> Ok, if you restrict the left type
08:43:46 <p2147483647> I have a small library I use for 'requiring' values in Snap, where it will write an error response on Left, I was thinking it might exist already
08:44:30 <mm_freak_> p2147483647: note that snap's monad is an Alternative
08:44:34 <donri> :t either throwIO return
08:44:35 <lambdabot> Exception a => Either a a1 -> IO a1
08:44:36 <Narvius> :t (>>>)
08:44:37 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
08:45:06 <p2147483647> donri: was hoping to generalise to multiple "error types"
08:45:12 <mm_freak_> p2147483647: in other words, you should probably just use snap's error response mechanism
08:45:17 <Narvius> Isn't (>>>) == (.)?
08:45:29 <donri> p2147483647: it's generalized to Exception
08:45:29 <Narvius> And (<<<) = flip (.)?
08:45:30 <mm_freak_> Narvius: no, it's a generalization of flip (.)
08:45:32 <p2147483647> mm_freak_: it is
08:45:40 <Narvius> Okay
08:45:43 <Narvius> Let me rephrase
08:45:43 <mm_freak_> Narvius: (<<<) is a generalization of (.)
08:45:45 <p2147483647> donri: I meant like Maybe as well
08:45:49 <Narvius> For functions, [as above]
08:46:00 <skypers> @src (><)
08:46:00 <lambdabot> Source not found. You untyped fool!
08:46:04 <donri> p2147483647: the failure package kinda does that
08:46:09 <nooodl> Narvius: other way around
08:46:18 <Narvius> Okay.
08:46:28 <mm_freak_> http://ro-che.info/ccc/12
08:46:30 <nooodl> (>>>) :: (a -> b) -> (b -> c) -> (a -> c)    for cat = (->)
08:47:14 <chrisdone> mm_freak_:  i love that one =p
08:47:24 <mm_freak_> me too =)
08:47:29 <skypers> ahah
08:47:31 <skypers> so sweet
08:47:42 <Narvius> xDDD
08:47:48 <Narvius> Dat comic.
08:47:59 <skypers> (><) is (<>) when considered as a Monoid
08:48:02 <skypers> that’s sweet :)
08:48:13 <p2147483647> donri: that might be what I want. it seems like a lens might be nicer though
08:48:27 <p2147483647> wait, that might not work...
08:48:49 <p2147483647> yeah nevermind..
08:54:47 <skypers> hey
08:55:02 <skypers> I got that on the terminal: <<loop>>
08:55:06 <skypers> what is that?
08:55:18 <quchen> GHC detected your program loops infinitely.
08:55:19 <hpc> it detected an infinite loop
08:55:27 <quchen> main = main -- Produces <<loop>>
08:55:29 <hpc> @faq can ghc solve the halting problem?
08:55:29 <lambdabot> The answer is: Yes! Haskell can do that.
08:55:54 <skypers> hm, yes but well, I want an infinite loop
08:56:02 <skypers> it might be because of the returned type
08:56:12 <chrisdone> it detects infinite loops that don't do anything
08:56:12 <quchen> I don't think you want an infinite <<loop>> though.
08:56:22 <simpson> skypers: What are you building?
08:56:40 <quchen> As far as I know <<loop>> is issued when GHC detects that in order to evaluate a thunk, it has to evaluate that thunk.
08:56:59 <quchen> So it's a thunk-level infinite loop.
08:57:00 <mauke> :t forever (sleep maxBound)
08:57:01 <lambdabot> Not in scope: `sleep'
08:57:08 <mauke> :t forever (threadDelay maxBound)
08:57:09 <lambdabot> Not in scope: `threadDelay'
08:57:09 <mm_freak_> you need a (>>)
08:57:15 <mm_freak_> main = return () >> main
08:57:21 <mm_freak_> or:  main = forever (return ())
08:57:38 <mm_freak_> that should work, because (>>) is nonstrict
08:57:42 <tarruda> How is the foldr function implemented?
08:57:47 <quchen> @src foldr
08:57:47 <lambdabot> foldr f z []     = z
08:57:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:58:06 <quchen> "Implemeneted" it's a little more advanced for performance reasons.
08:58:20 <quchen> In particular there are rewrite rules to make it fuse with other functions better.
08:58:53 <quchen> (So you have to walk over a list only once and not twice when using `foldr f z . takeWhile foo ...`
08:58:55 <quchen> )
08:59:31 <skypers> 17:43 < simpson> skypers: What are you building?
08:59:34 <chrisdone> mm_freak_: (>>) is non strict?
08:59:37 <skypers> a 3D engine for my demoscene stuff
08:59:44 <skypers> it’s written in C++11
08:59:48 <skypers> and I’
08:59:50 <chrisdone> mm_freak_: in what way?
08:59:54 <skypers> I’m migrating it in Haskell
09:00:01 <quchen> chrisdone: Sure, m >> n doesn't have to evaluate n to do something with m.
09:00:18 <mm_freak_> chrisdone: x >> ⊥ ≠ ⊥
09:00:27 <mm_freak_> it's only left-strict
09:00:32 <mm_freak_> ⊥ >> y = ⊥
09:00:36 <glguy> > Nothing >> undefined
09:00:38 <lambdabot>   Nothing
09:00:47 <mm_freak_> for IO that is
09:01:00 <mm_freak_> it's fully strict for some monads
09:01:01 <skypers> actually
09:01:03 <chrisdone> but to evaluate (x >> y) in IO it's strict
09:01:05 <skypers> I’m not sure I should go on
09:01:16 <mm_freak_> chrisdone: don't confuse evaluation with execution
09:01:16 <chrisdone> it will execute y before giving you a result
09:01:17 <tarruda> quchen: The code shown does something similar to a post-order traversal
09:01:27 <mm_freak_> IO critically depends on (>>) and (>>=) being non-strict
09:01:32 <chrisdone> mm_freak_: i'm not. x <- (a >> b) will execute b before you have x
09:01:39 <tarruda> quchen: Does that mean the foldr implementation will use as many stack frames as there are list elements?
09:01:52 <mm_freak_> chrisdone: that's confusing evaluation with execution =)
09:01:56 <mm_freak_> execution is necessary to get x
09:02:17 <quchen> tarruda: That depends on the strictness of the "f" in there.
09:02:20 <mm_freak_> if (>>) were strict, then:  forever (putStrLn "Hello world!") = ⊥
09:02:34 <quchen> tarruda: foldr can, but does not necessarily have to, run in constant space.
09:02:39 <simpson> skypers: Okay, so, you're getting a <<loop
09:02:57 <quchen> tarruda: The classical example is "foldr (+) 0", which causes a stack overflow for large lists.
09:02:57 <simpson> Bluh. <<loop>>... what are you looping, and how are you looping it?
09:03:11 <quchen> tarruda: On the other hand, "foldr (:) []" is the identity on arbitrarily-sized lists.
09:03:39 <skypers> simpson: yeah, and I don’t know where
09:03:47 <quchen> simpson: So if "f" is strict in its second argument, the whole fold has to be built up, leading to overflows.
09:04:12 <simpson> skypers: Well, what code did you recently change?
09:04:14 <quchen> Woops, that was for tarruda as well above there.
09:04:35 <skypers> simpson: https://github.com/skypers/skyoralis_samples/blob/master/src/Raytracing.hs#L70
09:04:40 <skypers> the issue is in the loop function
09:04:58 <skypers> I putStrLn just to see whether it would make a change
09:05:01 <skypers> but it doesn’t
09:06:08 <simpson> skypers: Is `elapsed` actually changing there? I don't see how it could be...
09:06:32 <tarruda> quchen: I can how a haskell compiler could use tail-call optimization for foldl but fail to see how it could work for foldr and arbitrary-sized lists
09:06:34 <skypers> simpson: sure it does
09:06:35 <mm_freak_> moduleName = "Raytracing"
09:06:37 <mm_freak_> what's that for?
09:06:56 <skypers> elapsedTimePoint is IO
09:07:01 <quchen> tarruda: foldr isn't tail recursive.
09:07:04 <skypers> mm_freak_: it should be exported
09:07:16 <tarruda> yes I can see that
09:07:17 <quchen> tarruda: And although foldl *is* tail recursive, it can still cause a stack overflow.
09:07:24 <tarruda> so how can one in haskell iterate in reverse order?
09:07:39 <mm_freak_> tarruda: by applying 'reverse' first
09:07:48 <quchen> foldl is reverse in a certain sense.
09:07:51 <chrisdone> mm_freak_: oh yeah. i implemented this non-strictness for fay. dunno what i was thinking
09:07:55 <quchen> Or using mm_freak_'s excellent hack :-P
09:08:10 <mm_freak_> chrisdone: =)
09:08:17 <skypers> simpson: https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Utils/TimePoint.hs#L43
09:08:22 <skypers> elapsedTimePoint
09:08:31 <tarruda> mm_freak_: isnt 'reverse' implementation a bit like  foldr ?
09:08:45 <mm_freak_> tarruda: it's a bit like foldl =)
09:08:45 <quchen> @src reverse
09:08:45 <lambdabot> reverse = foldl (flip (:)) []
09:08:47 <simpson> skypers: Hm, yeah, you're right.
09:09:07 * chrisdone collects his brainfart in a jar
09:09:30 <mm_freak_> chrisdone: isn't fay nonstrict by default anyway?
09:09:31 <tarruda> quchen: you said that even though foldl is tail recursive it can cause stack overflows
09:09:33 <tarruda> how so?
09:09:50 <skypers> simpson: so that’s weird
09:09:52 <mm_freak_> tarruda: foldl (+) 0 [1,2,3] = 0 + 1 + 2 + 3
09:09:57 <skypers> I don’t understand the <<loop>>
09:10:01 <mm_freak_> tarruda: not 6
09:10:04 <mauke> tarruda: recursion doesn't use stack
09:10:23 <quchen> tarruda: "foldl (+) 0" builds up a long thunk of "a + (b + (c + ...))"
09:10:33 <quchen> In other worse "because laziness"
09:10:37 <mm_freak_> tarruda: foldl only builds the expression without evaluating it
09:10:37 <quchen> words*
09:10:40 <chrisdone> mm_freak_: sure. i meant when implementing >>= for IO it's function(m,f){ var v = force(m); return f(v); }
09:11:50 <ski>      foldl (+) 0 [1,2,3]
09:11:53 <chrisdone> mm_freak_: `forever' was the first test-case i made sure worked =)
09:11:59 <ski>   =  foldl (+) (0 + 1) [2,3]
09:12:08 <ski>   =  foldl (+) ((0 + 1) + 2) [3]
09:12:13 <tarruda> I'm having a lot of pain in understanding how haskell works
09:12:16 <ski>   =  foldl (+) (((0 + 1) + 2) + 3) []
09:12:23 <quchen> tarruda: In general tail recursion in Haskell is usually not that important, because laziness often prevents huge amounts of data being built up. There are places where it matters though.
09:12:24 <ski>   =  ((0 + 1) + 2) + 3
09:12:29 <ski>   =  (1 + 2) + 3
09:12:33 <ski>   =  3 + 3
09:12:36 <ski>   =  6
09:12:36 <quchen> tarruda: (Compared to say Lisp)
09:12:45 <ski> tarruda ^
09:12:53 <skypers> simpson: I tried to replace the go function with return ExitSuccess
09:12:56 <skypers> no more <<loop>>
09:13:01 <chrisdone> laziness ends up acting like a limited trampoline
09:13:03 <skypers> so it’s definitely there
09:13:17 <tarruda> quchen: Ok I get it
09:13:31 <ski> tarruda : the stack overflow can happen in the part after the `foldl' on empty list has returned
09:13:33 <skypers> it may not like the go function?
09:13:43 <glguy> tarruda: foldl itself won't cause a stack overflow, but attempting to evaluate the result of foldl can
09:14:33 <mm_freak_> chrisdone: sure…  obviously when you have IO you want infinite loops to work =P
09:14:45 <tarruda> Ok I got it, I was in doubt because I didnt consider haskell laziness
09:15:21 <simpson> skypers: Haskell thinks that something in that function causes an infinite loop. Keep dividing and conquering.
09:15:31 <tarruda> I'm still having a lot of trouble understanding Monads/IO. Is there something like a "Monad for dummies" tutorial?
09:15:54 <chrisdone> tarruda: Learn You a Haskell?
09:15:55 <mm_freak_> tarruda: not really…  did you try LYAH?
09:16:08 <ski> @google you could have invented monads
09:16:09 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
09:16:09 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
09:16:19 <Narvius> That's a good one, yes.
09:16:25 <tarruda> I started it
09:16:28 <Narvius> Or rather, it helped me.
09:16:34 <mm_freak_> tarruda: my suggestion is to learn IO, not monads =)
09:16:40 <glguy> tarruda: You don't need to focus on learning monads to use IO
09:16:41 <tarruda> I'm looking for something shorter that lets me get started with general haskell programming
09:16:45 <glguy> you can just start with learning IO
09:17:59 <ski> tarruda : you could also try "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>
09:18:03 <tarruda> Still, I'd like to understand Monads
09:18:14 <mm_freak_> tarruda: you will
09:18:17 <mm_freak_> but learn IO first
09:18:42 <tarruda> ok I'm gonna go back to LYAH
09:18:42 <mm_freak_> then learn Maybe, then learn [], then Either, then State, then …
09:18:54 <glguy> tarruda: Get good about building things with IO and then once that makes sense you can discover how the same operations make sense at other types
09:18:55 <mm_freak_> eventually the understanding will emerge by itself
09:20:21 <chrisdone> i got monads in an instant after Cale said something about something i was implementing. it was very zen
09:20:48 <quchen> But Chris
09:20:51 <quchen> You are the Monad
09:20:56 <quchen> And Chris was enlightened
09:21:09 <mm_freak_> chrisdone: and in the next instant you started writing a monad tutorial, didn't you?
09:21:32 <Hodapp> does Buddha have the monad nature - for he carries around his worldly-nature, yet does not attempt to touch it?
09:21:33 <chrisdone> i've never written one!
09:21:48 <mm_freak_> chrisdone: never published
09:21:53 <chrisdone> mm_freak_: haha
09:21:55 <chrisdone> did you write one?
09:21:57 <mm_freak_> everybody has written a monad tutorial
09:21:59 <chrisdone> seems to be a rite of passage
09:21:59 <mm_freak_> chrisdone: yeah
09:22:07 <chrisdone> in this sense i'm not yet a true haskeller
09:22:14 <mm_freak_> hehe
09:22:27 <mm_freak_> the more it sucks, the better for you =)
09:22:44 <zomg> Even I have written a monad tutorial that I never posted anywhere!
09:22:47 <chrisdone> i say at that moment i 'got' monads,  more accurately realised there was nothing *to* get, just the abstraction and the laws
09:22:53 <kryft> chrisdone: You should write a koan about it
09:22:54 <Mortomes> Bonus points if you make a bogus analogy.
09:22:55 <zomg> Well, it really wasn't a monad tutorial, but it sorta touched the topic of monads on the side
09:22:58 <zomg> :P
09:23:02 <Mortomes> "Think of a monad like a burrito"
09:23:14 <quchen> I have drawn one! It now lives on my desk.
09:23:26 <Hodapp> http://blog.plover.com/prog/burritos.html
09:23:28 <Hodapp> what's wrong with that one?
09:23:37 <mm_freak_> extra bonus points if you claim that your tutorial doesn't rely on analogies =)
09:23:48 <quchen> I also like this one. http://www.chrisstucchio.com/blog/2013/write_some_fucking_code.html
09:23:48 <zomg> my tutorial doesn't! I swear
09:23:54 <mm_freak_> or metaphors, as we like to call them
09:23:59 <zomg> it's as straight to the point as humanly possible
09:23:59 <zomg> :D
09:24:13 <zomg> because all the analogies just made it more confusing than it was
09:24:15 <tomejaguar> Should we do something like this for monad tutorials?: http://craphound.com/spamsolutions.txt
09:24:46 <quchen> tomejaguar: There's one for new programming languages as well
09:24:59 <tomejaguar> "Your analogy is flawed because it doesn't take into account ( ) List monad ( ) Reverse state monad ..."
09:25:00 <ski> (the only "monad tutorials" i've written has been conversations on this channel)
09:25:05 <quchen> @google so you invented a programming language
09:25:06 <zomg> I wonder if anyone has written a monad library for PHP yet
09:25:07 <lambdabot> http://colinm.org/language_checklist.html
09:25:07 <lambdabot> Title: Programming Language Checklist
09:25:08 <chrisdone> i was implementing the state monad in javascript with like stateBind and such, showed #haskell like "look, monads in javascript!" and Cale said something like "it's not really monads if there's no abstraction over the type of monad" and i zen'd
09:25:10 <zomg> Should write one as a joke
09:25:18 <zomg> My previous joke PHP library has grown a bit old
09:25:53 <mm_freak_> zomg: in fact i have used algebraic structures in PHP
09:25:54 <quchen> acme-php?
09:25:55 <mm_freak_> but not monads
09:25:57 <quchen> Or a PHP-based one
09:26:00 <donri> "joke PHP library" "military intelligence"
09:26:24 <zomg> I wrote a library for PHP which would let you use a jQuery-style syntax
09:26:30 <zomg> because at that time, fluent interfaces were all the rage
09:26:34 <augur> anyone have any references for how to de-mutualize data structures?
09:26:45 <zomg> only thing was, my library took the fluent interface paradigm to 11
09:26:45 <zomg> :D
09:27:14 <zomg> basically the code looked much like take(10)->and->then(multiply(it())->by(5)->and->print()
09:27:41 <zomg> sad part was
09:27:45 <zomg> some people took it seriously
09:28:21 <hpc> zomg: there isn't a single part of that story which i choose to believe is fact
09:28:29 <hpc> zomg: you should contribute to acme-php
09:28:35 <mm_freak_> zomg: writing PHP code is universally bad, even when you're just joking
09:28:42 <quchen> Antribute you mean, hpc
09:28:44 <zomg> hpc: I wrote a PHP parser, evaluator and generator in Haskell. Does that count?
09:29:17 <zomg> mm_freak_: yeah what can you do when that's what paid the bills for a good amount of years :D
09:29:19 <hpc> zomg: acme-php is so far beyond that
09:29:27 <hpc> it is the soul of programming itself
09:29:48 <quchen> foldl f z xs = foldl (flip f) z (reverse xs)
09:29:56 <zomg> hpc: ah yes I actually looked at this at some point.. =)
09:29:57 <quchen> Eh, foldr in one of those places.
09:30:06 <zomg> all languages need an acme-* namespace
09:30:19 <hpc> perl's acme namespace is even better than haskell's
09:30:23 <quchen> foldl' f z xs = xs `seq` foldl f z xs
09:30:28 <quchen> hpc: Wooot
09:30:38 <hpc> except for haaslich = unschoen
09:30:46 <hpc> i don't think any joke ever will be that good
09:31:01 <zomg> only if you speak german I guess
09:31:20 <joelteon> i don't get it
09:31:26 <joelteon> probably because i don't speak german
09:31:27 <quchen> I'm German and I don't get it.
09:31:30 <ski> ("häßlich" ?)
09:31:36 <quchen> Hässlich.
09:31:36 <hpc> schoen means "nice"
09:31:41 <quchen> ß is so 1990.
09:31:49 <hpc> hasslich means very roughly, "not nice"
09:31:56 <joelteon> lol
09:31:58 <joelteon> i see
09:32:10 <quchen> It means very accurately "ugly".
09:32:15 <hpc> schoen is being used in the library as the first part of schoen-finkel
09:32:16 <mauke> beautiful/ugly
09:32:21 <hpc> which is a mathematician's name
09:33:00 <chrisdone> heh, found it http://ircbrowse.net/browse/haskell?id=5348984&timestamp=1208577970#t1208577970
09:33:04 * ski . o O ( Raphael Finkel )
09:33:24 <chrisdone> 2008-04-19 06:07:16 +0200	<Cale> 	Nicely done, but completely misses the point of the monad abstraction.
09:33:24 <chrisdone> 2008-04-19 06:11:46 +0200	<chris___> 	Cale: in what way does it miss the point?
09:33:24 <chrisdone> 2008-04-19 06:12:20 +0200	<Cale> 	chris___: Well, the way that things are designed there, it looks impossible to write code which would reliably work across all monads.
09:33:24 <chrisdone> 2008-04-19 06:12:50 +0200	<Cale> 	chris___: For there to be any point in calling something a monad, you have to be able to write code which works in any monad.
09:33:27 * chrisdone hits gong
09:33:48 <chrisdone> https://www.youtube.com/watch?v=nVZdCG5J34I
09:33:50 <Narvius> *reads acme-php*
09:34:14 <hpc> chrisdone: one instance of an abstraction is good enough for the gang of four
09:34:18 <hpc> so it's good enough for everyone
09:34:26 <kryft> chrisdone: Maybe he could hit you with a stick or put his sandals on his head and walk out
09:34:31 <zomg> GoF is only the beginning
09:34:33 <kryft> chrisdone: But pretty good as it is!
09:34:46 <chrisdone> kryft: lol
09:34:46 <zomg> after GoF, there's PoEAA, Patterns of Enterprise Application Architecture!
09:34:53 <quchen> chrisdone's school of Monad. Step 1: reinvent State in JS. 2, tell Cale about it.
09:35:02 <chrisdone> quchen: :D
09:35:12 <emaphis> It's in scala but I've always like this talk on monads: http://www.youtube.com/watch?v=Mw_Jnn_Y5iA
09:35:14 <hpc> quchen: nonono
09:35:28 <p2147483647> GoF is the best haskell propaganda out there
09:35:28 <gecco> hi all, I'm quite new to Haskell, and I experiement with lenses and Template Haskell. Just curious how to combine them, like in this code: http://lpaste.net/95521
09:35:31 <hpc> chrisdone's school of Monad. Step 1: write a monad tutorial in JS. 2, tell Cale about it.
09:35:37 <quchen> GoF?
09:35:43 <Narvius> I concur, GoF?
09:35:48 <p2147483647> quchen: Gang of Four
09:35:50 <quchen> Is that one of those made up abbreviations to confuse people?
09:36:03 <p2147483647> It's a book on "design patterns" for object oriented programming
09:36:08 <hpc> the gang of four is the authors who wrote the design patterns book
09:36:11 <quchen> Ah.
09:36:18 <Hodapp> bluagh
09:36:18 <hpc> championing the cause of copy-paste code
09:36:28 <Hodapp> It's a catalog of limitations of languages
09:36:34 <chrisdone> hpc: it wasn't a tutorial! it was just a paste of an implementation, but i copied it onto my web site =p
09:36:41 <Hodapp> because it's all abstractions that you can see in your head, but cannot express as a construct in the language
09:36:52 <Qfwfq> chrisdone: So, how would you abstract over monads in JS? You could define an expected interface for all monad types. Like, Array.return = function(x) { return [x]; }; Array.prototype.bind = function(c) { return _.flatten(this.map(c), true) }. And then in functions for monad refer to the subject's bind instance, and subject.constructor.return...
09:36:55 <chrisdone> i will one day write a monad tutorial, but i'll have to invent my learning tool first
09:37:26 <zomg> I think GoF (and PoEAA) are decent enough books
09:37:35 <zomg> but the problem is when people get stuck to mindlessly following them
09:37:38 <hpc> they make these wearable suit things now
09:37:43 <zomg> then everything has to be one of the patterns shown in the book
09:37:50 <zomg> and everything is forced into one of the patterns
09:37:53 <hpc> which create tactile sensation based on the position of another person wearing an identical suit
09:37:55 <zomg> no matter what it is or if it makes any sense
09:37:56 <hpc> so you can teach muscle memory
09:38:01 <hpc> programming needs one of those
09:38:45 <zomg> sounds more like something that would be fun to wear while playing Mortal Kombat for that extra touch of realism
09:39:16 <Qfwfq> hpc: Is muscle-memory learnt if you aren't in the same position..?
09:39:16 <p2147483647> Qfwfq: I don't know that it's possible at all is it?
09:39:25 <quchen> zomg: That game is right up the top when I think of things I'd like to be more immersed in.
09:39:26 <p2147483647> (to abstract over monads)
09:39:42 <ski> hpc : reminds me of an experiment in which a person got to wear a belt for a month that provided tactile feedback on the current north direction
09:39:47 <Qfwfq> p2147483647: My message included a proposal, what's wrong with it? :-)
09:39:53 <chrisdone> Qfwfq: yeah, that approach works
09:39:56 <hpc> Qfwfq: the feedback "pushes" the wearer into specific actions
09:40:03 <hpc> ski: that one was damn cool
09:40:07 <hpc> he dreamed in north
09:40:24 <hpc> and felt a phantom compass after the experiment ended
09:40:27 <Qfwfq> ski: A team and noisebridge are shipping ankle-versions commercially. Called Southpaw or something.
09:40:39 <p2147483647> Qfwfq: oh I see- you can't call return without it being attached to an object, right?
09:40:55 <skypers> 18:02 < simpson> skypers: Haskell thinks that something in that function causes an infinite loop. Keep dividing and conquering.
09:40:56 <Qfwfq> ski: Someone at CCC was talking about implanting the vibrators subdermally...
09:40:59 <skypers> ok, thank you :)
09:41:48 <skypers> @hoogle profonctor
09:41:49 <lambdabot> No results found
09:42:23 <yogurt_truck> I think GoF patterns are too little too late, just like MVC/etc-kind of big picture "enterprise patterns". it's like "hey, here's how to architecturally structure your mutable, side effect-y, impossible-to-reason-about code that you're writing in some Java-like language!" -.-
09:43:06 <skypers> :t bimap
09:43:08 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
09:43:10 <zomg> yogurt_truck: that book was published in '95, I don't thint it was too late then
09:43:13 <zomg> :D
09:43:52 <carter> shergill: no problem
09:43:55 <zomg> I think it's good for people working with OO languages to read that book tbh
09:43:58 <carter> not much is public yet
09:43:58 <carter> but its a thing
09:44:00 <yogurt_truck> zomg: not late in the age of the earth. i meant too late in the development process
09:44:08 <zomg> especially for less experienced devs
09:44:11 <zomg> yogurt_truck: ah
09:44:11 <carter> geekosaur: thanks for mentioning the berw stuff
09:44:46 <zomg> yogurt_truck: well I don't think the idea of it is so much about "hey do these patterns" but "here's a bunch of common patterns"
09:45:16 <chrisdone> yogurt_truck: i think separation of model and view is pretty valuable. you want to know where things are updated/saved you go to the model. you want to know how things are presented you go to the view
09:45:18 <zomg> and in that I think for less experienced devs I think it's good because it can help them see patterns in the code better which is certainly something that can be helpful
09:45:21 <yogurt_truck> zomg: oh it's certainly not a bad idea to go through them if only to know what it's all about
09:45:55 <yogurt_truck> chrisdone: yes but that is not even remotely close to important, compared to other aspects of a codebase
09:46:05 <skypers> @src fst
09:46:05 <lambdabot> fst (x,_) =  x
09:46:07 <chrisdone> yogurt_truck: what other aspects?
09:46:18 <skypers> @let fst' = first id
09:46:20 <lambdabot>  Defined.
09:46:26 <skypers> fst' (1,6)
09:46:32 <skypers> > fst' (1,6)
09:46:36 <lambdabot>   (1,6)
09:46:42 <chrisdone> yogurt_truck: i'm working on a codebase where such separation isn't done and i can tell you it wastes my time figuring out where things are
09:47:02 <yogurt_truck> chrisdone: a Drupal codebase can still be separated in "view" and "controller", but that doesn't save it from the nightmare that it is because of all the mindless mutability, side effects, exception throwing, and fundamental lack of DRYness
09:47:11 <Qfwfq> Software engineering seems to come down to writing code that's welcoming to new and novice developers. "I don't know where to find this thing?" => "I have some expectation, as it adheres to patterns."; "I don't understand this system well enough to comfortably change this thing!" => "Oh, there are comprehensive tests that'll let me know if I break anything."
09:47:57 <skypers> there’s nothing in Profonctor that returns the first part?
09:48:10 <chrisdone> yogurt_truck: neither does a static type system and purity with re-usability save you from having a disorganized codebase that an MVC organization would mitigate
09:48:14 <yogurt_truck> chrisdone: one you have those fundamentals, then sure, implement your MVC or whatever architecture, but that larger level organization will almost come for free if you star working on the more fundamentals aspect of development first
09:48:36 <chrisdone> i don't agree
09:48:56 <chrisdone> haskell permits you to create mess, with a low cost. it doesn't prevent it
09:49:41 <skypers> Bifunctor*
09:50:30 <shergill> ooc, is there a reason why laziness/strictness isn't expressed in the type system in haskell?
09:50:39 <nooodl_> skypers: you can't write anything like that. (how'd it work for Either?)
09:50:39 <chrisdone> the notion that you just add haskell and hurrah! you now have a well structured application is bogus. i've seen my fair share of haskell mess. the arrogance that "i don't need no stinkin' architecture standards" contributes
09:50:46 <yogurt_truck> chrisdone: refactoring a pure codebase into whatever big picture pattern you want (MVC, PAC, or whatever arbitrary buzzword you like) is trivial if your codebase is pure and DRY.
09:51:12 <yogurt_truck> chrisdone: I haven't said anything about haskell
09:51:13 <skypers> nooodl_: hm
09:51:16 <chrisdone> yogurt_truck: yeah, liike i said -- haskell permits you to create mess with low cost -- the low cost being, it doesn't cause many breaks, and you can always refactor it
09:51:23 <yogurt_truck> chrisdone: it could be PHP. and I have done it in PHP
09:51:24 <skypers> I mean it would retourne the error type?
09:51:32 <skypers> return*
09:51:33 <chrisdone> <yogurt_truck> chrisdone: I haven't said anything about haskell  -- uh, ok. i'm leaving
09:51:51 <skypers> fst' :: p a b -> a
09:51:51 <yogurt_truck> huh?
09:51:57 <skypers> snd' :: p a b -> b
09:52:10 <skypers> with (Profonctor p) => p
09:52:35 <skypers> @hoogle (Profonctor p) => p a b -> a
09:52:36 <lambdabot> Warning: Unknown class Profonctor
09:52:37 <lambdabot> Control.Monad.Trans.Writer.Lazy execWriter :: Writer w a -> w
09:52:37 <lambdabot> Control.Monad.Trans.Writer.Strict execWriter :: Writer w a -> w
09:52:38 <nooodl_> you mean Bifunctor
09:52:43 <skypers> .
09:52:44 <skypers> yeah
09:52:45 <skypers> Bifunctor
09:52:47 <skypers> damn me
09:52:53 <monochrom> it is strictness/non-strictness and eagerness/laziness, not strictness/laziness or up/green
09:53:00 <skypers> @hoogle (Bifonctor b) => b a b -> a
09:53:00 <lambdabot> Warning: Unknown class Bifonctor
09:53:00 <lambdabot> Control.Monad.Trans.Writer.Lazy execWriter :: Writer w a -> w
09:53:00 <lambdabot> Control.Monad.Trans.Writer.Strict execWriter :: Writer w a -> w
09:54:05 <skypers> weird there’s nothing for that
09:54:21 <nooodl_> it really only makes sense for (,) though!
09:54:24 <haasn> does laziness imply nonstrictness?
09:54:34 <monochrom> no
09:54:37 <skypers> nooodl_: no
09:54:46 <skypers> it makes sense for Either too
09:54:51 <skypers> hm
09:54:52 <skypers> wait
09:54:52 <skypers> no
09:54:54 <skypers> it doesn’t
09:54:57 <skypers> you’re righgt
09:55:00 <skypers> right*
09:58:21 <bz> :t read . drop
09:58:23 <lambdabot>     Couldn't match type `[a0] -> [a0]' with `[Char]'
09:58:23 <lambdabot>     Expected type: Int -> String
09:58:23 <lambdabot>       Actual type: Int -> [a0] -> [a0]
09:58:57 <bz> :t read . (drop 6)
09:58:58 <lambdabot> Read c => [Char] -> c
09:59:37 <skypers> hm
09:59:51 <skypers> the highest class that defines composition is Semigroupoid
09:59:59 <skypers> interesting
10:00:12 <skypers> and (,) is in such a class
10:00:25 <skypers> > (1,3) o (2,5)
10:00:27 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
10:00:27 <lambdabot>                ...
10:00:40 <skypers> > o (1,3) (2,5)
10:00:42 <lambdabot>   Couldn't match expected type `(t1, t2) -> (t3, t4) -> t0'
10:00:42 <lambdabot>              with...
10:01:00 <tomejaguar> :t o
10:01:02 <lambdabot> Expr
10:01:13 <skypers> yeah it’s been erased
10:01:16 <tomejaguar> > o + o
10:01:18 <lambdabot>   o + o
10:01:21 <skypers> is there a way to unlet something?
10:01:26 <skypers> @unlet o
10:01:27 <lambdabot>  Parse failed: TemplateHaskell is not enabled
10:01:48 <FireFly> I don't think it's defined as anything
10:02:00 <skypers> > Data.Semigroupoid.o (1,2) (10,20)
10:02:01 <lambdabot>   Not in scope: `Data.Semigroupoid.o'
10:02:04 <skypers> .
10:02:23 <skypers> ok
10:02:27 <skypers> I did it with my ghci
10:02:33 <skypers> it’s odd
10:03:03 <skypers> oh
10:03:09 <skypers> ok, got it
10:03:12 <Luke> chrisdone: any word on hi2 indentation mode being merged into haskell-mode?
10:03:25 <tomejaguar> I really like hi2
10:03:44 <skypers> it discard the first snd and the second first
10:03:47 <skypers> discards*
10:04:05 <Narvius> Extremely offtopic, but some of you are likely to know: Is it possible to buy Google searches or something, so that you can perform searches in an automated way without being blocked due to suspicious activity?
10:04:05 <Luke> chrisdone: also, how does haskell-mode get released to ELPA?
10:04:23 <ski> skypers : `@undefine' removes all auxilary bindings
10:04:34 <skypers> thanks
10:04:37 <skypers> @undefine o
10:04:37 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
10:04:45 <skypers> hm
10:04:58 <Cale> @undefine
10:04:58 <lambdabot> Undefined.
10:05:09 <skypers> > (1,2) `o` (4,undefine)
10:05:10 <lambdabot>   Not in scope: `undefine'
10:05:10 <lambdabot>  Perhaps you meant `undefined' (imported from Prel...
10:05:11 <bz> is is possible to simplify: f xs = read . drop (length xs)?
10:05:14 <skypers> > (1,2) `o` (4,undefined)
10:05:15 <lambdabot>   Couldn't match expected type `(t1, t2) -> (t3, t4) -> t0'
10:05:15 <lambdabot>              with...
10:05:18 <ski> @define
10:05:18 <lambdabot>  Define what?
10:05:20 <ski> :(
10:05:25 <skypers> yeah Semigroupoid are not loaded
10:05:47 <ski> bz : `f = (read .) . drop . length'
10:05:58 <augur> ski: you must know!
10:06:00 <Narvius> @pl \f xs = read . drop (length xs)
10:06:01 <lambdabot> (line 1, column 7):
10:06:01 <lambdabot> unexpected "="
10:06:01 <lambdabot> expecting pattern or "->"
10:06:08 <Narvius> @pl \f xs -> read . drop (length xs)
10:06:08 <lambdabot> const ((read .) . drop . length)
10:06:10 <augur> ski: what are some references for how to de-mutualize data structures?
10:06:22 <ski> de-mutualize ?
10:06:25 <Narvius> wait
10:06:29 <bz> jesus, that's worse
10:06:32 <Narvius> @pl \xs -> read . drop (length xs)
10:06:32 <lambdabot> (read .) . drop . length
10:06:38 <bz> thanks anyhow
10:06:44 <Narvius> :t (read .)
10:06:45 <lambdabot> Read c => (a -> String) -> a -> c
10:06:57 <Narvius> :t ((read .) .)
10:06:58 <lambdabot> Read c => (a -> a1 -> String) -> a -> a1 -> c
10:07:05 <Narvius> :t (((read .) .) .)
10:07:06 <lambdabot> Read c => (a -> a1 -> a2 -> String) -> a -> a1 -> a2 -> c
10:07:11 <Narvius> Now that's a reasonable pattern.
10:07:20 <augur> ski: like, if you have a pair of mutually defined types and you dont want to use mutual definitions, so you do some transformations
10:07:43 <ski> @type let infixr 9 .:; (.:) = (.) . (.) in read .: drop . length
10:07:44 <lambdabot> Read c => [a] -> [Char] -> c
10:08:20 <Narvius> :t (.).(.)
10:08:21 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:08:29 <Narvius> :t (.).(.).(.)
10:08:30 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
10:09:00 <Narvius> I really need to get a sheet of paper and write out some of this stuff.
10:09:08 <Narvius> IIRC from edwardk's talk, fmap behaves the same
10:09:09 <ski> Narvius : i called that one `(.::)', number of dots matching
10:09:36 <Narvius> Because while I see the pattern, I can't wrap my head around how it is generated.
10:09:45 <ski> augur : i suppose you can use `Fix' in some cases
10:10:24 <augur> ski: im curious about when it is and isnt possible
10:10:48 * ski isn't sure of a general treatment
10:11:00 <ski> do you have any example where it's clearly not possible ?
10:11:07 <augur> it seems like the ADT analogy of sets of differential equations that cant be properly solved
10:11:09 <ski> @where DecoratingStructures
10:11:09 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
10:11:11 <ski> @where IndirectComposite
10:11:12 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
10:11:14 <augur> ski: no, i dont! but im curious!
10:11:40 <augur> ski: ill give these a look
10:12:04 <ski> Narvius : just start with `(f .: g) x y = f (g x y)' and rewrite it
10:12:19 <Narvius> Yeah, I'll do that, thanks.
10:12:59 <ski> augur : for mutual recursion, it'd be nice to have type records (as distinct from record types)
10:13:10 <augur> ski: oh?
10:13:43 <ski> augur : it gets tiresome to say `data ExprF expr decl pat comm = ...' after a while
10:13:49 <ski> augur : but i believe one can partly use GADTs for the same purpose
10:14:01 <augur> ski: im not entirely sure what you mean but ok :D
10:14:31 <skypers> simon: I found my <<loop>> :)
10:14:43 <skypers> a vicious one
10:14:49 <ski> @wiki Multiplate
10:14:49 <lambdabot> http://www.haskell.org/haskellwiki/Multiplate
10:15:06 <ski> augur : ^ isn't quite what you're asking about, but might be interesting to check out, if you haven't seen it before
10:15:30 <skypers> simon: https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/GL/VertexArray.hs#L120
10:15:32 <augur> i dont know what a uniplate is, nevermind a multiplate!
10:15:40 <skypers> I wonder why I didn’t get a warning
10:15:54 * ski . o O ( viscous loops )
10:16:21 <skypers> yeah…
10:17:07 * augur . o O ( mollasses loops )
10:17:33 <ski> @wiki uniplate
10:17:33 <lambdabot> http://www.haskell.org/haskellwiki/uniplate
10:17:55 <ski> augur : perhaps start with the manual linked from there ^ ?
10:18:08 <augur> ski: maybe!
10:18:23 * augur . o O ( is this how telepaths communicate? )
10:18:38 <teneen> in my heap profile only main is shown. how can I show other functions?
10:18:45 <teneen> I compiled using -fprof-all
10:19:51 * augur .oO()
10:21:33 <blueonyx> is there a name or easier version for uncurry (+) . flip quotRem 2?
10:22:25 <Iceland_jack> uncurry (+) . (`quotRem` 2) ?
10:22:36 <Iceland_jack> I'd just write it in the obvious way though
10:23:05 <cschneid> what is uncurry useful for? I've seen it around, but haven't really understood why I'd want to do that
10:23:14 <Iceland_jack> cschneid: If you want to operate on pairs of values
10:23:29 <Iceland_jack> > uncurry (+) (10, 5) -- e.g.
10:23:31 <lambdabot>   15
10:23:45 <Iceland_jack> so if you have:
10:23:45 <Iceland_jack> > [(1, 10), (2, 20), (3, 30)]
10:23:46 <lambdabot>   [(1,10),(2,20),(3,30)]
10:23:51 <blueonyx> or ceiling . (/2) . fromIntegral  :/
10:24:00 <FireFly> I find it funny how much more useful `uncurry` is than `curry`
10:24:02 <Iceland_jack> you can do
10:24:02 <Iceland_jack> > map (uncurry (+)) [(1, 10), (2, 20), (3, 30)] -- to sum them
10:24:03 <lambdabot>   [11,22,33]
10:24:10 <FireFly> Despite being the "inverted" of the two, so to speak
10:24:18 <Iceland_jack> curry is almost never used because there are almost no functions that take a tuple
10:24:46 <Iceland_jack> uncurry (+) ≡ \(x, y) -> x + y
10:24:48 <cschneid> Iceland_jack: does that come up often? Where you'd have tuples like that?
10:25:03 <cschneid> I get the type signature, but more of understanding why I'd come across that
10:25:05 <Iceland_jack> cschneid: It depends, it doesn't come up too often
10:25:15 <ski> @type \x -> (?f *** ?g) x
10:25:16 <lambdabot> (?f::b -> c, ?g::b' -> c') => (b, b') -> (c, c')
10:25:17 <Iceland_jack> but if you do have a tuple value (tuplic value?)
10:25:31 <ski> "pair" ?
10:25:48 <Qfwfq> @type curry . uncurry
10:25:49 <lambdabot> (a -> b -> c) -> a -> b -> c
10:26:14 <cschneid> Iceland_jack: ok, I see it in lots of arrow definitions, but that's inherently tuple-heavy code, so that makes a lot of sense
10:26:31 <ski> augur : hum, i actually meant
10:26:35 <ski> @hackage uniplate
10:26:35 <lambdabot> http://hackage.haskell.org/package/uniplate
10:28:12 <augur> ski: not that the manual is much help x3
10:28:27 <augur> ski: ill have to read syb
10:28:30 <augur> or watch it
10:30:30 <shergill> has the idea for strictness annotation as highlighted by stefan in this email been extended by anyone? https://groups.google.com/d/msg/fa.haskell/crXl7KQAaSo/H3tQ4CMS5lwJ
10:31:26 <augur> actually
10:31:29 <augur> is there an SYB video??
10:31:54 <tomejaguar> Haskell eXchange 2013
10:32:10 <tomejaguar> ^^ that goes out to augur
10:32:11 <blackdog> anyone know why i can't build comonad with shared: True on linux with GHC HEAD?
10:32:19 <blackdog> is complaining about no "dyn_hi" files
10:32:26 <Eduard_Munteanu> Where's the proper place to detect ends of line if I'm parsing EOL-terminated statements with a multistage parser? Right now I have a lexer that does word splitting and a parser that calls that lexer.
10:33:00 * ski always thought SYB was kinda icky
10:33:01 <Eduard_Munteanu> Putting EOL parsers into higher level parsers seems error-prone.
10:33:26 <augur> tomejaguar: ill look
10:33:53 <monochrom> perhaps include EOL as a token produced by the lexer
10:34:24 <Eduard_Munteanu> monochrom: sure, but the next stage will have to specify it manually, and I could forget to do that.
10:35:21 <monochrom> I don't understand what's wrong with "specify manually". the whole bloody grammar at that level has to be specified manually.
10:35:24 <Eduard_Munteanu> monochrom: btw, I'm not parsing a parser's output, I'm lifting lexers into parsers.
10:35:30 <ski> monochrom :(
10:36:46 <Eduard_Munteanu> monochrom: I have a function 'lex :: Lexer a -> Parser a' where Lexer wraps the actual attoparsec parser. If I make a 'eol :: Lexer ()' I could forget to apply it in the parser. I just want some type safety.
10:37:24 <Luke> ReinH: great job on haskell cast guys!
10:37:29 <Luke> soooo good
10:37:54 <monochrom> why is it not Lexer Token? where Token has one case being EOL?
10:38:03 <Eduard_Munteanu> e.g. someLine = lex (stringTok "foo") *> ... <* lex eolTok
10:38:43 <monochrom> I give up.
10:39:48 <Eduard_Munteanu> monochrom: I was trying this approach instead of the more traditional, completely separate parser stages.
10:40:27 <arkeet> why is it Lexer a -> Parser a, with the same type argument on both sides?
10:40:28 <monochrom> what is the type of lex (stringTok "foo")? is it also Lexer ()?
10:40:51 <Eduard_Munteanu> monochrom: no, it's 'Parser a'
10:40:56 <Eduard_Munteanu> Er.
10:41:00 <Eduard_Munteanu> monochrom: no, it's 'Parser String'
10:41:27 <arkeet> I dunno what Lexer or Parser is, though
10:41:43 <monochrom> ok, so stringTok "foo" :: Lexer String? not Lexer Token? and not Lexer Foo?
10:42:08 <Eduard_Munteanu> monochrom: yes
10:42:24 <augur> tomejaguar: the examples from this talk seem to be a good justifiction for record update syntax :P
10:42:26 <Eduard_Munteanu> Actually 'Lexer ()' in that very specific case, but I wanted to make a point.
10:42:52 <Eduard_Munteanu> I also have a  keywordTok :: Lexer String  .
10:43:46 <Eduard_Munteanu> augur: Lexer is just a newtype wrapper for the attoparsec parser monad, but Parser is a wrapper for 'Free Lexer'
10:43:47 <monochrom> ok, so suppose you have two keywords in your language, "foo" and "data". but both are Lexer String, and you don't worry about "type safety", "I have to manually tell them apart", "I may forget to". and suddenly you worry about \n being Lexer ()?
10:43:49 <Eduard_Munteanu> Er.
10:43:56 <Eduard_Munteanu> arkeet: Lexer is just a newtype wrapper for the attoparsec parser monad, but Parser is a wrapper for 'Free Lexer'
10:44:12 <Eduard_Munteanu> Because I want my runParser to automatically skip whitespace.
10:45:06 <Eduard_Munteanu> monochrom: the language I'm parsing is mostly line-oriented. So I wanted to make sure I don't try to read across two adjacent lines.
10:45:31 <Eduard_Munteanu> Because it's a very common thing.
10:45:33 <monochrom> and you don't want to make sure you can't distinguish foo from data
10:46:02 <monochrom> you can always "data EOL = EOL" and make Lexer EOL.
10:46:41 <Eduard_Munteanu> monochrom: I do the same thing for skipping whitespace, that's the reason for the Free Lexer stuff. It seemed like this and newline handling would be a lexer job.
10:47:06 <monochrom> I don't understand. "foo" is a keyword, not whitespace. "\n" is also a keyword, not whitespace. what's the problem?
10:47:25 <Eduard_Munteanu> monochrom: I know... but I'd prefer to write   myParser = Line $ ...   instead of   myParser = ... <* eol
10:47:56 <Eduard_Munteanu> monochrom: and have the run* functions take care of adding the eol parser.
10:47:57 <tomejaguar> line = (<* eol)
10:48:10 <Eduard_Munteanu> :t (<* ?p)
10:48:11 <lambdabot> (Applicative f, ?p::f b) => f a -> f a
10:48:23 <monochrom> I give up for the second time.
10:48:47 <Eduard_Munteanu> The hypothetical 'line' could be something like Parser a -> LineParser a.
10:49:09 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #3
10:49:10 <Eduard_Munteanu> So the compiler sees if I forget it.
10:49:15 <chrisdotcode> hello everyone :)
10:49:26 <tomejaguar> Eduard_Munteanu: another newtype then I guess?
10:49:49 <Eduard_Munteanu> tomejaguar: yeah, I was thinking of that, I wanted to look for alternatives though.
10:50:09 <bz> f = map f' . takeWhile (/= "") ; g = map g' . tail . dropWhile (/= ""); is there a way to convince ghc to apply stream fusion onto f and g?
10:50:37 <Eduard_Munteanu> bz: are you using the stream-fusion package?
10:51:18 <bz> Eduard_Munteanu: no
10:51:29 <Eduard_Munteanu> monochrom: do you dislike this approach in particular, namely making parsers transparent instead of running them in succession?
10:51:36 <Eduard_Munteanu> s/parser/stages/
10:51:42 <monochrom> that is not the problem
10:52:13 <Eduard_Munteanu> bz: try it, base lists rarely fuse, at least relative to stream-fusion
10:52:37 <Eduard_Munteanu> monochrom: just that it's not worth wasting effort on it?
10:52:46 <monochrom> that is still not the problem
10:52:50 <Eduard_Munteanu> :)
10:52:55 <Eduard_Munteanu> monochrom: which is it then?
10:53:24 <monochrom> in a nutshell, you are saying, \n is a keyword, and \n is not a keyword.
10:55:12 <Eduard_Munteanu> Hm, I see. Though I'm not sure it's more of a keyword than whitespace is.
10:55:29 <Eduard_Munteanu> Well, I actually see why you say that.
10:55:46 <monochrom> If the context-free-language level needs to know something, then that thing is not whitespace.
10:56:15 <Eduard_Munteanu> Hm, alright, makes sense. Thanks.
10:57:50 <haasn> monochrom: #6 is my favorite
10:57:52 <Eduard_Munteanu> BTW, is there a comparison of this sort of transparent stages, versus the completely-separate stages approach?
11:01:25 <chrisdone> monochrom: tautalogy #2 reminds me of the state of haskell on windows
11:01:34 <monochrom> haasn: #6 is a little bit less tautological than it looks. it arises when one day shachaf and I discussed: if functor F is both a right adjoint and a left adjoint of functor G, what can we conclude? we decided that we can conclude very little. to get a little bit more conclusion, we have to assume a little bit more about F and G. so, it's a "the more you know about the premises, the more you know about the conclusion"
11:01:50 <chrisdone> monochrom: there's a typo in #3
11:01:52 <monochrom> s/arises/arose/
11:02:26 <monochrom> not all typos are meant to be typed :)
11:02:50 <chrisdone> ;)
11:03:17 <chrisdone> monochrom: yeah, i like that. solving this typo is not a problem that needs to be solv
11:03:49 <mangaba_leitosa> Eduard_Munteanu: using Text.IO speeded up wordfreq counting by 70%, and increasing the heap size via RTS gave 30% more :-)
11:04:28 <Eduard_Munteanu> mangaba_leitosa: hm, nice
11:04:49 <chrisdone> monochrom: you learn something from pain. but is learning pain? are they the same?
11:05:11 <Eduard_Munteanu> mangaba_leitosa: you should try stream-fusion if you still have things like [Text].
11:05:23 <Eduard_Munteanu> Might reduce the GC overhead even more.
11:05:42 <emaphis`> mangaba_leitosa: Hi
11:05:43 <monochrom> I don't think learning is pain. I think many things are learned not from pain.
11:05:49 <mangaba_leitosa> emaphis`: hi :-)
11:06:06 <mangaba_leitosa> Eduard_Munteanu: yes, I tried stream-fusion before trying Text and there was no difference
11:06:10 <emaphis`> mangaba_leitosa: I figured you'd end up here eventiall.
11:06:20 <mangaba_leitosa> emaphis`: :-)
11:06:20 <monochrom> typo fixed
11:06:50 <Eduard_Munteanu> mangaba_leitosa: I'd try it again, it might be more significant now
11:06:59 <mangaba_leitosa> Eduard_Munteanu: good idea, thanks
11:07:22 <mangaba_leitosa> emaphis`: I'm doing the bionformatics class in Haskell :-)
11:07:44 <tarruda> Can I define infix functions with symbolic names for custom types?
11:07:51 <tarruda> Eg vector multiplication
11:07:59 <tarruda> v1 * v2
11:08:12 <chrisdone> monochrom: i've heard it argued that learning (via e.g. observation) is just accumulating facts. whereas *learning* something genuinely new, like how to walk or delimited continuations, requires pain. maybe that's just a no true scotsman fallacy. but there's some truth to the idea. if things are easy to learn i've observed it's because i've already learned it, just in different clothes
11:08:19 <emaphis`> mangaba_leitosa: great way to learn Haskell. :-)
11:08:28 <Eduard_Munteanu> tarruda: make an instance of Num for square matrices of a given size
11:09:01 <Eduard_Munteanu> tarruda: oh, vectors... you can do it on vectors too
11:09:06 <tarruda> Eduard_Munteanu: Actually, I'm trying to define multiplication between string and integers
11:09:18 <tarruda> heres my try:
11:09:19 <Eduard_Munteanu> tarruda: err, how so?
11:09:25 <tarruda> `*` :: String -> Int -> String
11:09:27 <tarruda> str `*` 1 = str
11:09:29 <tarruda> str `*` int = str ++ (str * (int - 1))
11:09:40 <tarruda> eg: "abc" * 3
11:09:40 <Eduard_Munteanu> tarruda: that won't work unless you hide (*) somehow.
11:09:44 <tarruda> "abcabcabc"
11:09:48 <ski> scaling on an additively written monoid
11:10:11 <tarruda> Can you adapt my example?
11:10:24 <dv-> > concat (replicate 3 "abc")
11:10:25 <lambdabot>   "abcabcabc"
11:10:53 <Eduard_Munteanu> tarruda: there's no nice way to actually overload (*) like that
11:10:58 <monochrom> chrisdone: there are two things here. knowledge and body skill. they have to be treated differently
11:11:01 <ski> > replicate 3 () >> "abc"
11:11:02 <lambdabot>   "abcabcabc"
11:11:43 <haasn> tarruda: `*` is a syntax error, * is already an (infix) operator
11:11:44 <Eduard_Munteanu> You could make an MPTC variant of Num
11:11:58 <tarruda> The replicate is nice, I just thought there was a way to define standard operations(+,-,*...) for custom types
11:12:07 <Eduard_Munteanu> Likely you'll split it into multiple classes though.
11:12:31 <ski> > let (*) :: String -> Int -> String; str * 1 = str; str * n = str ++ (str * (n - 1))  in  "abc" * 4
11:12:32 <lambdabot>   "abcabcabcabc"
11:12:33 <Eduard_Munteanu> tarruda: no, we don't have ad-hoc polymorphism
11:12:37 <kuznero> Hi All!
11:12:37 <monochrom> but learning delimited continuation was not painful to me :)
11:12:43 <chrisdone> monochrom: maybe another way of putting it can be: if it comes naturally, you're not learning anything new
11:13:00 <Iceland_jack> tarruda: There is a way, but (*) is already used and it doesn't match the type you propose
11:13:09 <ski> tarruda : the standard `(*)' takes two values of the same type, and yields a result of the same type
11:13:09 <monochrom> no no, if it doesn't come naturally, it still doesn't have to be painful
11:13:13 <haasn> > replicateM 3 "abc"
11:13:14 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
11:13:16 <haasn> Oops
11:13:24 <haasn> that uses sequence, not join :P
11:13:48 <chrisdone> monochrom: that depends on what pain means. if it's not coming naturally it requires patience, and people hate patience
11:13:59 <chrisdone> @devils patience
11:14:00 <lambdabot> *** "patience" devil "The Devil's Dictionary (1881-1906)"
11:14:00 <lambdabot> PATIENCE, n.  A minor form of despair, disguised as a virtue.
11:14:00 <lambdabot>  
11:14:03 <ski> tarruda : how would you define `(-)' in your case ?
11:14:11 <tarruda> I tought it was possible to overload functions
11:14:23 <Iceland_jack> tarruda: I answered that
11:14:26 <Iceland_jack> and so did ski
11:14:33 <Iceland_jack> :t (+)
11:14:34 <lambdabot> Num a => a -> a -> a
11:14:37 <monochrom> ok, the broader sense of pain, frustration, wanting to give up at some point. I guess.
11:14:42 <redscare> I have found it is a common idiom for me to map a function over a list and then zip that result with the original list. is there some kind of built-in function to abstract over this?
11:15:32 <monochrom> no, my pain is not in my own learning, but in seeing how other people don't learn :)
11:15:44 <tarruda> ski, if I understand correctly, your example works because you hide '*' in the 'let' scope right?
11:15:52 <Iceland_jack> shadow, yes
11:16:08 <chrisdone> monochrom: the tragedy of untapped potential
11:16:10 <tarruda> So theres no way to shadow in a module scope?
11:16:27 <Eduard_Munteanu> The TDNR proposal could help these situations.
11:16:30 <monochrom> more pessimistic than that
11:16:32 <dv-> redscare: zipwith?
11:16:34 <monochrom> @quote monochrom history
11:16:34 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
11:16:34 <lambdabot> entire human race would have to be rewritten!
11:16:52 <monochrom> oh, it probably isn't there
11:16:57 <ski> > map (ap (,) (2 ^)) [0 ..]
11:16:58 <lambdabot>   [(0,1),(1,2),(2,4),(3,8),(4,16),(5,32),(6,64),(7,128),(8,256),(9,512),(10,1...
11:17:20 <ski> tarruda : you can `import Prelude hiding ((*))'
11:17:20 <monochrom> "those who have learned from history are bound to helplessly watch other people repeat it" is an example
11:17:30 <chrisdone> monochrom: hehe, nice
11:17:39 <ski> redscare : not sure the above example helps
11:17:41 <Eduard_Munteanu> Is there a reason type synonyms have to be fully applied?
11:17:45 <monochrom> I said it on haskell-cafe rather than here
11:19:08 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/23654/
11:21:13 <chrisdone> monochrom: i counted 2 major advancements the human race has ever developed, and 2 tenuous ones: 1) technology (wheel, fire, computers,  etc.), 2) inaliable human rights (abolition of slavery, etc.), 3) gender/sexual equality, 4) scientific method. the latter two are still in development in terms of general acceptance, as whole human race. ironically, you need (4) for (2) to work, but only a few inventors are required. the general
11:21:13 <chrisdone> population can be a tribe of raving lunatics =)
11:21:18 <redscare> ski, dv-: thanks to both of you, both examples work
11:21:55 <redscare> ski's example is perhaps more what i was looking for, but both work
11:23:31 <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f; cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
11:23:32 <lambdabot>  Defined.
11:24:05 <ski> > ((2 ^) `graph`) `map` [0 ..]
11:24:10 <lambdabot>   [(0,1),(1,2),(2,4),(3,8),(4,16),(5,32),(6,64),(7,128),(8,256),(9,512),(10,1...
11:25:25 <chrisdone> monochrom: (oh, perhaps also (5) free speech, ish) i mean -- if you take a modern person and put them back, say, 500 years, the concept of technology will be familiar. the fact you can weild electricity and metal and plastic to make an iphone isn't *fundamentaly* new, it's just clever technology. but (2), (3), (4) and (5) will be fundamentally alien ideas
11:27:37 <Hodapp> I'd count #5 as part of #2.
11:28:12 <chrisdone> Hodapp: yeah, i guess it follows naturally
11:29:15 <valdyn> the idea of inalienable human rights is like at least 2000 years old
11:29:18 <valdyn> no, 2500
11:29:56 <chrisdone> valdyn: i'm not talking about the idea, but the general implementation and acceptance of being "this is the way things should be" across the human race as a general  whole
11:30:26 <valdyn> there would be no discussion about abortion then
11:32:35 <chrisdone> valdyn: well, the issue there is whether the host's rights are being violated or the parasite's =) the fact that human rights exist is nevertheless true
11:32:43 <chrisdone> anyway, </offtopic>
11:32:52 <valdyn> yea
11:35:51 <chrisdone> http://philipnilsson.github.io/Badness10k/articles/waterflow/
11:35:58 <chrisdone> i wonder whether you can solve this with loeb =)
11:37:27 <donri> 2500 years is at least 2000 yearsh ;)
11:38:03 <mangaba_leitosa> emaphis`: and much less frustration than with Scala :_)
11:38:25 <Eduard_Munteanu> Many people think humans aren't kind enough. Actually they aren't smart enough, because all those things come naturally if you don't have insane beliefs.
11:40:41 <Eduard_Munteanu> That being said, I'm rather disappointed of humanity.
11:40:50 * chrisdone gives eduard_munteanu a hug
11:41:05 <Eduard_Munteanu> Aw.
11:41:44 <chrisdone> Eduard_Munteanu: have you read A Fire Upon the Deep?
11:41:59 <Eduard_Munteanu> Mm, no.
11:42:17 * Eduard_Munteanu hasn't read much normal literature :/
11:42:43 <Ralith> that's not normal literature, it's good scifi
11:43:08 <Eduard_Munteanu> Ralith: I mean as opposed to technical stuff
11:43:13 <Ralith> ah
11:43:16 <Ralith> well, it's good times
11:43:36 <chrisdone> Eduard_Munteanu: ah. scifi. there's a race of canids in it that require packs of minimum 5-6 'members' to form a general intelligence matching a human. their superiority lies in that members can die and be replaced, thus a "consciousness" and live for thousands of years. they note, in the book, that every single human starts out stupid and has to learn from scratch every time
11:44:18 <chrisdone> Eduard_Munteanu: i thought that was interesting =)
11:44:46 <Eduard_Munteanu> chrisdone: well, yeah... For instance, I don't think a lone human can even make a fire, unless taught to.
11:45:22 <external-reality> How did the first guy to make fire do it?
11:45:25 <chrisdone> Eduard_Munteanu: yeah, that's interesting. i suppose fire is the quintessential definition of culture. culture is something learned and passed down from generation to generation
11:45:36 <amalloy> external-reality: aliens
11:45:48 <ski> external-reality : perhaps there were two firsts at the same time ?
11:45:51 <chrisdone> Eduard_Munteanu: and i guess fire making is the oldest, most powerful culture
11:45:51 <external-reality> :-)
11:46:00 <yng> external-reality: he made fire and lived to tell it
11:46:19 <Eduard_Munteanu> external-reality: humans didn't always make fires, they'd take a piece on wood already on fire and use it.
11:46:20 <Hodapp> he stole it from a thunderstorm
11:47:02 <Eduard_Munteanu> external-reality: and at some point, some humans discovered how to actually make a fire and passed it on, but chances are slim for a lone human I suppose.
11:47:04 <mischov> external-reality: fire occurs naturally, allowing for easier research
11:47:38 <Hodapp> Eduard_Munteanu: said human was probably stoned to death.
11:47:40 <Eduard_Munteanu> The same for language too.
11:47:51 <chrisdone> Hodapp: hahaha
11:48:29 <Eduard_Munteanu> Hodapp: clearly fire is the work of thunder gods, making it yourself is heresy :P
11:49:17 * ski . o O ( `unsafeFire :: a -> Fire a' )
11:49:19 <chrisdone> Eduard_Munteanu: yeah, i wonder whether language was a linear, slow process of development or whether it exploded in a relatively short number of generations and has been selecting ever since
11:49:35 <chrisdone> ski: surely unsafeFire :: Fire a -> a?
11:49:53 <ski> that would remove the fire, not making fire
11:49:58 <external-reality> Hodapp: I don't know about you but I'm not going to try to stone a dude who is carying a flaming stick. What if I miss?
11:50:17 <ski> (possibly `Fire' is a comonad)
11:50:18 <chrisdone> ski: but how is it unsafe? =p ahh. like an unsafePtr
11:50:33 <monochrom> perhaps it is a comonad
11:51:16 <external-reality> No `OnFire` is definately a monad.
11:51:41 <Eduard_Munteanu> chrisdone: I suspect it was an incremental process, involving smaller steps, each group rediscovering it. There are notions of culture in monkeys too, related to the way certain groups of monkeys have their own signals and knowledge of tools.
11:52:07 <chrisdone> Eduard_Munteanu: yeah. i've seen monkeys develop a culture of bathing in hot springs
11:53:32 <ij> Can I get rid of the lambda here? \x -> 4 == f x
11:53:46 <ski>   (4 ==) . f
11:53:51 <Iceland_jack> @pl \x -> == f x
11:53:51 <lambdabot> (line 1, column 7):
11:53:51 <lambdabot> unexpected "="
11:53:51 <lambdabot> expecting lambda abstraction or expression
11:53:56 <Iceland_jack> @pl \x -> 4 == f x
11:53:56 <lambdabot> (4 ==) . f
11:54:25 <jle`> think about what you are doing to x.  you are applying f to it then comparing it to 4
11:54:28 <Eduard_Munteanu> ij: if 4 also comes from an application of 'f', you can do '(==) `on` f'
11:55:11 <jle`> interesting dialog.  it reminds me of a chapter of hofstdter's "godel, escher, bach", where he describes a conscious anthill
11:55:23 <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f
11:55:24 <lambdabot>  Defined.
11:55:30 <jle`> the ants themselves are not conscious, simply following simple rules, like our brain cells do
11:55:31 <joelteon> sanity check--what version of base is in ghc 7.6?
11:55:35 <ski> @type comparing
11:55:36 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:55:39 <maikklein> does anyone know if there are plans for a concurrent gc?
11:55:46 <jle`> but the ant hill itself has an emergent intelligence
11:55:52 <joelteon> oh, 4.6
11:56:19 <ski> jle` : also in "Planescape: Torment"
11:56:32 <chrisdone> Eduard_Munteanu: https://www.youtube.com/watch?v=vDSWAWNHsDk
11:56:38 <maikklein> or at least a non global pause gc?
11:56:40 <Eduard_Munteanu> jle`: you can also think of individual animals / humans as being emergent beings
11:56:59 <ski> (not ants but rats, though)
11:57:04 <Eduard_Munteanu> jle`: as in we're just colonies of cells :)
11:57:07 <external-reality> jel` humans follow rules too yes but where is the emergent intelligence?
11:58:08 <jle`> external-reality: well, emergent intelligence is a rather fragile thing. we might not have one ourselves.  but i suspect that even if we did it would be hard to see/understand it, by the same way a brain cell can't understand a human
11:58:43 <Eduard_Munteanu> chrisdone: heh, nice... I've also seen something about language being a result of culture in monkeys, like certain sounds they make, specific to a group
11:58:56 <Narvius> external-reality: Ants probably do not realize the emergent intelligence they are part of; why would we?
11:58:57 <chrisdone> ski: interesting =) the dog packs in Fire communicate via high bandwidth directed sound to form a live unfiltered collective consciousness. packs can't go near eachother due to the mixed signals causing temporary insanity
11:59:37 <Eduard_Munteanu> And if you think about it, quite a few diseases emerge from inter-cell competition. Say cancer.
11:59:54 <jle`> ij: you can also fmap onto (==)
12:00:00 <jle`> er
12:00:03 <jle`> fmap (==) onto f
12:00:05 <ij> Where is it defined?
12:00:07 <ij> the onto
12:01:01 <jle`> > let f = (+) 2; compr = fmap ((==) 4) f in map compr [1,2,3,4]
12:01:02 <lambdabot>   [False,True,False,False]
12:01:36 <jle`> f has to already be defined for some reason
12:01:42 <ski> ij : i believe jle` meant : you can also `fmap' onto `(==)'
12:02:10 <jle`> ski: is that the proper term?
12:02:23 <ski> sorry ?
12:02:29 <jle`> er, terminology
12:02:38 <jle`> i would suspect you fmap the mapping function onto the mapped opbject
12:02:47 <monochrom> ok, is "onto" code?
12:03:01 <jle`> (i have no authority on this issue, just wondering)
12:03:24 * ski would probably have said "over"
12:03:28 <jle`> such as, when you do map ((*) 2) [1,2,3], you are mapping (*) 2 onto the list [1,2,3]?
12:03:33 <jle`> ah yeah
12:03:36 <jle`> over makes more sense
12:03:53 * ski isn't sure
12:04:22 * monochrom would write actual code rather than speak half-english half-code
12:04:44 <monochrom> after all, "f x" is also so much shorter than "apply f to x"
12:04:49 <Cale> jle`: I think mostly people were confused by whether to interpret the string "fmap onto (==)" as being Haskell code or partly English :)
12:05:16 <chrisdone> yeah =p
12:05:23 <chrisdone> :t onto
12:05:24 <jle`> fair enough :)
12:05:24 <lambdabot>     Not in scope: `onto'
12:05:24 <lambdabot>     Perhaps you meant `unto' (imported from Control.Lens)
12:05:31 <chrisdone> :t unto
12:05:32 <lambdabot> (Functor f, Profunctor p, Bifunctor p) => (b -> t) -> Overloaded p f s t a b
12:05:37 <ski> @type fmap ?onto (==)
12:05:38 <lambdabot> (Eq a, ?onto::(a -> Bool) -> b) => a -> b
12:05:54 * ski . o O ( "Do unto others .." )
12:06:03 <Cale> :t others
12:06:04 <lambdabot> Not in scope: `others'
12:06:09 <chrisdone> heh
12:06:43 * Narvius . o O ( What's this about, eh? )
12:06:47 <ski> `others' sounds like it might be a zipperish thing
12:07:35 <Cale> ski: Yeah
12:07:41 <chrisdone> :t let in these for view
12:07:42 <lambdabot> Not in scope: `these'
12:07:43 <lambdabot>     Not in scope: `for'
12:07:43 <lambdabot>     Perhaps you meant one of these:
12:07:50 <chrisdone> let in these for view
12:07:50 <chrisdone>   :: (Control.Applicative.Applicative f, Traversable t) =>
12:07:50 <chrisdone>      (t a
12:07:51 <chrisdone>       -> Getting (f (t b)) (a -> f b) (f (t b)) -> (a -> f b) -> f (t b))
12:07:54 <chrisdone>      -> These (t a) (Getting (f (t b)) (a -> f b) (f (t b)))
12:07:57 <chrisdone>      -> (a -> f b)
12:08:01 <chrisdone>      -> f (t b)
12:08:04 <chrisdone> :p
12:08:06 <Cale> haha
12:08:07 <chrisdone> can you make a bigger english sentence that type-checks?
12:08:37 <Cale> chrisdone: you could put a 'do' at the start of that
12:08:44 <chrisdone> haha :D
12:08:53 <chrisdone> wait, can you?
12:09:06 <chrisdone> :t do let in ()
12:09:07 <lambdabot> ()
12:09:23 <chrisdone> so you can! huh. `in' doesn't normally work in `do'
12:09:33 <Cale> do { x } = x
12:09:45 <Cale> and it does work
12:09:54 <nooodl> > (do 3) + (do 4)
12:09:56 <lambdabot>   7
12:10:00 <Cale> (it's just you have the option of leaving the 'in' out)
12:10:03 <chrisdone> :t do let x = 1 in (); return () -- i was thinking of this
12:10:04 <lambdabot>     Couldn't match expected type `m0 a0' with actual type `()'
12:10:05 <lambdabot>     In the expression: ()
12:10:05 <lambdabot>     In a stmt of a 'do' block: let x = 1 in ()
12:10:12 <tac> > (do {(+)}) (do {1}) (do {2})
12:10:14 <lambdabot>   3
12:10:27 <Narvius> chrisdone: That's because () is not a monadic thingstuff
12:10:30 <Narvius> Not becuse of the in
12:10:32 <chrisdone> hang on
12:10:35 <joelteon> :t do {()}
12:10:38 <lambdabot> ()
12:10:49 <Cale> wow    so imperativ   many do    such monad
12:10:50 <chrisdone> whenever i try to use `in' ime it always yields syntax error
12:10:53 <Narvius> > do {();()}
12:10:54 <lambdabot>   Couldn't match expected type `m0 a0' with actual type `()'Couldn't match ex...
12:11:01 <joelteon> wtf happened, shibe is absolutely everywhere
12:11:07 <Narvius> If it's one, it desugars without even knowing it requires a monad.
12:11:23 <nooodl> if otherwise then do let in these for view else do let in these for view
12:11:29 <nooodl> arguably valid english?
12:11:31 <Narvius> do { let x = 5 in return 5 } :: Maybe Int
12:11:37 <Narvius> > do { let x = 5 in return 5 } :: Maybe Int
12:11:38 <lambdabot>   Just 5
12:11:40 <Narvius> Works
12:12:17 <chrisdone> nooodl: nice =)
12:12:41 <chrisdone> here:
12:12:44 <Narvius> "these for"?
12:12:47 <chrisdone> foo  = do putStrLn "Yo!"
12:12:47 <chrisdone>           let x = 5
12:12:47 <chrisdone>           putStrLn "Ho!"
12:12:47 <chrisdone> ^ ok
12:12:54 <chrisdone> foo  = do putStrLn "Yo!"
12:12:57 <chrisdone>           let x = 5
12:13:00 <chrisdone>           in return ()
12:13:03 <chrisdone>           putStrLn "Ho!"
12:13:07 <chrisdone> ^ parse error
12:13:11 <chrisdone> probably the let needs to be one line
12:13:20 <moops> what makes monads not composable (in general), is it a type system limitation or a theoretical one?
12:13:22 <chrisdone> that often trips me
12:13:27 <monochrom> indent "in return ()" more
12:13:29 <ski> you could indent the `in'
12:13:31 <Narvius> > do { Just 1; let x = 5 in return x; Just 7 }
12:13:31 <geekosaur> ^
12:13:32 <lambdabot>   Just 7
12:13:51 <monochrom> because currently you have "let {x=5}; in ..."
12:13:58 <chrisdone> sure, but i always write let and in on the same line. `do' ruins it
12:14:16 <ski> chrisdone : align the `t' in `let' with teh `n' in `in' ?
12:14:21 <monochrom> on second thought, my theory may be wrong
12:15:47 <chrisdone> ski: looks bad =(
12:16:08 <chrisdone> ski: looks like someone accidentally put a space there
12:16:14 <joelteon> :t do let in
12:16:15 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:16:18 <joelteon> :t do let in ()
12:16:19 <lambdabot> ()
12:16:33 <joelteon> :t do let let do let in in in ()
12:16:34 <lambdabot> parse error on input `in'
12:16:37 <joelteon> aw
12:17:04 <alkabetz> 'do', 'let', and 'in' are syntax, not functions. :)
12:17:05 <chrisdone> :t do let in let in ()
12:17:06 <lambdabot> ()
12:17:29 <geekosaur> fwiw the align-leT-with-iN thing is what I normally do, and it works both inside and outside of do notation
12:17:44 <joelteon> nice, a SLOC inflation system built in to the language
12:17:47 <ski> chrisdone : how can alignment look bad ? :(
12:17:50 <joelteon> just add another "let in"
12:17:51 <Narvius> :t do do do let in do let in let let do do in in ()
12:17:51 <lambdabot> parse error on input `in'
12:17:55 <alkabetz> Wait, sorry, never mind that’s what I get for not paying attention to this channel
12:19:21 <chrisdone> ski: because the normal alignment is left alignment.. that's suddenly aligning it differently just because `do' hijacks the meaning of let
12:19:27 <joelteon> :t do do do ()
12:19:28 <lambdabot> ()
12:19:39 <joelteon> so you can't put a do after a let in
12:19:44 <joelteon> but you can chain dos and let ins
12:19:46 <chrisdone> :t do do do "da da da"
12:19:47 <lambdabot> [Char]
12:20:00 <chrisdone> is all i want to say to you ♩
12:20:50 <chrisdone> ski: you don't think consistency is better than arbitrariness?
12:22:12 <ski> i'm not sure why "the normal alignment is left alignment" ?
12:22:21 <Cale> moops: Theoretical
12:22:58 <Cale> moops: If M and N are monads, in order for MN to be a monad, you need to define a natural transformation mu: MNMN -> MN
12:23:01 <chrisdone> ski: let x = 1
12:23:01 <chrisdone> ski: in x * x
12:23:01 <chrisdone> ski: is the normal way to align lets
12:23:33 <Cale> moops: but in general, there won't be a way to do that
12:23:39 <moops> whats MNMN -> MN ?
12:23:50 <Cale> Oh, I'm using category theoretical notation
12:23:58 <joelteon> wouldn't that be analogous to join
12:24:00 <ski> chrisdone : mhm, if you say so
12:24:01 <Cale> yes
12:24:15 <joelteon> moops: you'd have to be able to define join :: m (n (m (n a))) -> m (n a)
12:24:19 <Cale> In Haskell, if you had instances of Monad for M and N, then you'd be defining  join :: m (n (m (n a))) -> m (n a)
12:24:20 <Cale> yeah
12:24:33 <chrisdone> ski: well, a quick google of "haskell let" shows the 'let' and 'in' aligned in the examples i looked at
12:24:36 <Cale> er, uppercase M and N, or whatever
12:24:39 * ski usually does it to the right, but ok
12:24:51 <moops> ah gotcha
12:25:16 <chrisdone> ski: i've never seen that before o_o
12:25:53 <Cale> One extra bit of information you can throw in to make that possible is something like  distr :: N (M a) -> M (N a)
12:26:17 <Cale> and then fmap distr :: M (N (M (N a))) -> M (M (N (N a)))
12:26:41 <Cale> and then you can fmap join . join . fmap distr :: M (N (M (N a))) -> M (N a)
12:26:57 <inkjetunito> i can see that many of the thicker haskell books are a bit old. are they outdated?
12:27:00 <Cale> There are some laws that distr has to satisfy in order for this to result in a monad.
12:27:10 <maikklein> can someone explain me what mapM_ is doing? seems rather useless to me "mapM_ (\x -> Just x) [1,2,3,4] "
12:27:14 <ski> inkjetunito : the craft is still good, imo
12:27:21 <Cale> inkjetunito: Slightly, but not completely.
12:27:22 <ski> (probably others as well)
12:27:23 <Eduard_Munteanu> @src mapM_
12:27:23 <lambdabot> mapM_ f as = sequence_ (map f as)
12:27:36 <ski> i hear RWH is less up-to-date
12:27:39 <Cale> maikklein: It's more useful in IO.
12:27:54 <Cale> maikklein: Or other monads with more significant effects.
12:28:11 <magicman> Even does cool stuff for "simple" [].
12:28:14 <Cale> > It's like a for-each loop which ignores the result of each iteration.
12:28:15 <lambdabot>   <hint>:1:52: parse error on input `of'
12:28:23 <Cale> (rather than collecting them into a list)
12:28:24 <magicman> Wait M_, not M. Never mind <_<
12:28:25 <maikklein> hm
12:28:28 <ski> maikklein : `mapM return as = return as', for finite lists `as'
12:28:39 <inkjetunito> ski, Cale: ok. thanks
12:28:40 <Cale> maikklein: Try:  mapM_ (\x -> print x) [1..10]
12:29:03 <Eduard_Munteanu> > mapM_ (\x -> guard (x < 10)) [5, 9, 14, 19]
12:29:04 <lambdabot>   No instance for (Control.Monad.MonadPlus m0)
12:29:04 <lambdabot>    arising from a use of `e_11...
12:29:04 <maikklein> Cale, ahh okay
12:29:11 <Eduard_Munteanu> :(
12:29:16 <ski> > mapM_ (\x -> guard (even x)) [0,1,2,3] :: Maybe ()
12:29:17 <lambdabot>   Nothing
12:29:24 <ski> > mapM_ (\x -> guard (even x)) [0,2,4,8] :: Maybe ()
12:29:25 <lambdabot>   Just ()
12:29:46 <Eduard_Munteanu> Oh, right.
12:29:55 * ski apparently had the same thing in mind as Eduard_Munteanu
12:29:57 <Cale> Yeah, in the Maybe monad, you just get to see whether the whole thing succeeded or failed, and not what the result is.
12:30:16 <maikklein> k thanks, now I get it
12:30:23 <Eduard_Munteanu> ski: oh, heh, I thought you corrected mine, which had an ambiguous type
12:30:32 <monochrom> "mapM_ (\x -> Just x) [1,2,3,4] " is useless. but what can you conclude? as much as you can conclude "therefore mapM_" is useless, you may as well conclude "Just" is useless, or "[1,2,3,4]" is useless.
12:30:47 <ski> > mapM_ (\x -> if even x then return () else Left x) [0,2,4,8] :: Either Integer ()
12:30:48 <lambdabot>   Right ()
12:30:50 <ski> > mapM_ (\x -> if even x then return () else Left x) [0,3,4,7] :: Either Integer ()
12:30:51 <lambdabot>   Left 3
12:31:14 <ski> this giving the first example of a "failing" element in the list
12:31:18 <monochrom> anyway, don't you love strawman examples
12:31:22 <Eduard_Munteanu> maikklein: yours was mapM_ return, which is useless because it's the identity, just like 'map id' is the identity for normal maps.
12:31:36 <ski> monochrom : indeed :)
12:31:53 <Eduard_Munteanu> > map (\x -> x) [1,2,3,4] -- is useless too
12:31:53 <lambdabot>   [1,2,3,4]
12:32:45 <chrisdone> ski: in fact all the major haskell books use the style i described. LYAH, RWH, YAHT, Gentle. in fact that seems to be one of the few styles that is actually consistent across the board
12:33:35 <chrisdone> ski: so i'd expect anything else to be rare and unexpected
12:33:43 <jfischoff> chrisdone: unfortunately that doesn't say much.
12:34:03 <ski> chrisdone : not saying i haven't used the left style, just that i wouldn't hesitate to use the right one, in case i thought it prettier
12:35:00 <chrisdone> jfischoff: it says that authors weren't contested on the style, that most new haskellers since 2000 have been reading these books and copying the styles
12:35:13 <chrisdone> jfischoff: but it depends on your definition of 'much'
12:35:44 <inkjetunito> ski: looks like the craft of fp was revised in 2011. nice
12:36:30 <jfischoff> chrisdone: I don't look at those books for guidance on haskell coding style. Nor do I know any professional Haskellers that do.
12:36:40 <jfischoff> beside you :)
12:37:13 <carter> hehe
12:37:23 <carter> i have my own style at this point
12:37:26 <carter> its very bland
12:37:44 <carter> except when its crazy and I use unsafeCoerce or duppablePerformIO as a party trick
12:39:39 <donri> i guess i'm the only one who likes to newline after both let and in
12:40:30 <kakos> Is it possible to make a custom class support the automatic deriving ala Show, Eq, etc.?
12:40:53 <donri> kakos: Generic or TH
12:40:59 <ski> donri : tabs ?
12:41:06 <donri> ski: no thanks :)
12:41:12 <donri> -fwarn-tabs should be default
12:41:18 <kakos> tabs > spaces
12:41:19 * ski keeps tabs on donri
12:42:04 <donri> kakos: doesn't work well with haskell though
12:42:15 <kakos> donri: Sadly. :(
12:42:48 <ski> donri : if you newline between layout-introducing keywords and multi-line bodies, it works
12:42:55 <ski> (which was why i asked)
12:43:34 <dmwit> I use tabs, and it works well with Haskell.
12:43:40 <dmwit> But unless somebody asks, I'm going to leave it at that.
12:43:43 <ski> (obviously you can't use any space at all for indentation of code, as well)
12:45:43 <donri> ski: what i like to do is put the let keyword at the end of the previous line (like people do with "do") and the in keyword half-indented (like people do with "where")
12:46:08 <donri> it arguably looks silly but consistent :p
12:46:18 <ski> i do that sometimes
12:46:37 <donri> plus the gotchas with let indentation become obvious
12:46:44 <ski> (except i'm not sure what "half-indented" means here)
12:47:29 <shergill> donri: care to hpaste?
12:47:31 <dmwit> :t (==#)
12:47:32 <lambdabot>     Not in scope: `==#'
12:47:32 <lambdabot>     Perhaps you meant one of these:
12:47:32 <lambdabot>       `==' (imported from Data.Eq),
12:48:00 <ski> @type (GHC.Prim.==#)
12:48:00 <lambdabot> GHC.Prim.Int# -> GHC.Prim.Int# -> Bool
12:48:28 <monochrom> if your normal indentation is 6.28, then half indent is 3.14
12:48:34 <donri> ski: two spaces, normally four, and four for the actual let bindings and the "body" after "in"
12:48:44 <donri> monochrom: exactly!
12:48:48 <dmwit> Prelude GHC.Prim> :t (==#)
12:48:48 <dmwit> (==#) :: Int# -> Int# -> Int#
12:48:50 <dmwit> =/
12:48:54 <monochrom> now argue over tau vs pi :)
12:49:56 <magicman> Are there any good algorithms for transitive-de-closuring (or any search terms I could use)? As in, if we have aRb, aRc, and bRc, return only aRb and bRc, as aRc is implied by transitive closure?
12:50:01 * monochrom has yet to invent "indent by 4 + 6.28i"
12:51:17 <sclv_> magicman: hmmm goood question
12:51:18 <ski> magicman : not unique ?
12:51:31 <monochrom> you can ask for the smallest relation
12:51:50 <sclv_> you could pull a graph into strongly connected components
12:51:58 <sclv_> and then take an arbitrary choice of loops in each one
12:52:00 <magicman> Not necessarily unique.
12:52:16 <monochrom> the smallest relation s such that s* includes the given relation r
12:52:19 <ski> strongly connected components is an adjoint, so unique
12:52:24 <sclv_> right
12:52:28 <sclv_> but then you make an arbitrary choice
12:52:36 <sclv_> of the relations you keep to preserve the scc structure
12:53:20 <magicman> Right.
12:53:33 <sclv_> i don't know if it gives you a minimal answer but its a good first past at clearing out lots of extraneous info at least
12:53:58 <sclv_> actually obv doesn't give a minimal answer
12:54:27 <Cale> The magic keywords you're looking for are "transitive reduction" and "Hasse diagram"
12:54:29 <ski> (which ?)
12:54:40 <Cale> http://en.wikipedia.org/wiki/Transitive_reduction
12:54:46 <magicman> Ah, cheers!
12:54:48 <sclv_> aha, excellent
12:55:26 <ski> figures, for infinite graphs
12:55:34 <ski> e.g. `<' on rationals
12:55:44 <lpaste> donri pasted “silly example for shergill” at http://lpaste.net/95529
12:55:52 <sclv_> oh nice my intuition was half of the algo
12:56:04 <magicman> I'll look into it, I just really had no clue where to search next.
12:56:12 <magicman> But now I do, so yay ^_^
12:56:28 <ski> donri : btw, you know you can attach `where' to `case' branches, yea ?
12:56:46 <donri> ski: did not know that no
12:56:56 <donri> is that like having let ... in case ...?
12:57:05 <sclv_> love that Aho worked on this problem
12:57:07 <shergill> donri: ah that's clearer, thanks
12:57:08 <ski> no, it attaches to a particular branch
12:57:19 <sclv_> he's got such a wide range of neat results
12:57:19 <donri> oh
12:57:33 <donri> ski: how's that even work with the parser
12:57:36 <ski> (and bindings from the pattern in the branch are in scope)
12:57:53 <ParahSai1in> it took me a while to figure out that where binds to all branches of a guard multiwayif
12:57:54 <ski> donri : just indent `where' more than the start of the branch
12:58:07 <ski> (like with your `in' there)
12:58:12 <madariaga> I'm trying to add a redis connection to the haskell wiki example irc bot
12:58:50 <madariaga> but I'm not sure what's the best way to go about it. Should I save the connection in the reader monad?
12:59:13 <lpaste> donri annotated “silly example for shergill” with “case-where” at http://lpaste.net/95529#a95531
12:59:31 <madariaga> and call runRedis in each function that needs to do IO with redis?
13:00:16 <donri> ski: i guess the most common styles for "where" is same indentation as function body or less indented, so they don't run into this other parse
13:00:21 <ski> oh sorry. strong connectedness is of course not the same as connectedness
13:04:31 <donri> ski: i guess it could trip you up for oneliners: example a = case a of putStrLn -> output a where output = putStrLn
13:04:37 <donri> only type checks if you move the where to a new line
13:07:05 <arcke> is there a more complete work on implementing functional languages than "The Implementation of Functional Programming Languages" by Simon Peyton Jones?
13:07:32 * ski isn't sure of what would be a more realistic example of the above snippet
13:08:25 <nisstyre> arcke: the source code of GHC?
13:08:53 <dmwit> arcke: I think there are several more pieces of writing by SPJ on implementing Haskell, if you're interested in that kind of thing.
13:09:11 <monochrom> that example relies heavily on shadowing. you normally avoid shadowing to begin with
13:09:25 <dmwit> One is a chapter in that one book on the architecture of big, open-source projects.
13:09:42 <dmwit> And there's the STG-machine paper, of course (perhaps that is the one you mentioned already? not sure).
13:14:26 <arcke> dmwit: exactly, implemetation of haskell and ghc and an overview of research topics associated with this
13:16:04 <dmwit> Well, and if you're specifically interested in GHC there's a lot of writing on the wiki aimed at people interested in hacking on GHC.
13:16:13 <dmwit> That's probably very relevant.
13:16:40 <arcke> it somehow feels weird that a book written two decades ago is still the most accurate
13:16:43 <donri> how about http://eb.host.cs.st-andrews.ac.uk/drafts/impldtp.pdf
13:16:49 <donri> design and implementation of idris
13:17:42 <levi> I wouldn't say it's 'more complete', but Appel's Compiling With Continuations is an interesting take on compiling functional languages.
13:18:24 <arcke> donri: i am interested in haskell in particular
13:18:47 <donri> it's implemented *in* haskell ;)
13:19:11 <dmwit> Wait, there's more than one unsafePerformIO?
13:19:24 <levi> Until there's a large demand for languages *like* haskell but not haskell, it's unlikely a book will be published on the topic.
13:19:27 <donri> yes, the unsafeNoReallyUnsafeDupablePerformIO
13:19:47 <donri> makes unsafePerformIO look safe
13:20:02 <arcke> donri: dependently-typed languages have sparked my interest before
13:21:02 <dukedave> Hey gang, can anyone help me think about this? https://gist.github.com/dukedave/8c5a556573e74e88f6cb
13:21:19 <dukedave> I think I'm just out of the Haskell mindset...
13:21:32 <donri> dmwit: you can also derive it with unsafeCoerce (and vice versa) or with unsafeSTtoIO (both dupable, i think)
13:21:49 <donri> uh IOtoST*
13:23:25 <dmwit> donri: You misunderstood my question.
13:23:30 <donri> ok :)
13:23:41 <dmwit> At the moment, I am crying because Foreign.unsafePerformIO is not the same as GHC.IO.unsafePerformIO.
13:23:47 <dmwit> i.e. it is not just a re-export
13:23:59 <dmwit> causing my build t ofail
13:25:00 <geekosaur> it's still in there? thought it had been replaced by unsafeLocalState which is also not quite the same as unsafePerformIO
13:25:12 <donri> oh, heh
13:25:29 <donri> it's because one has a deprecation notice isn't it?
13:26:03 <donri> dmwit: System.IO.Unsafe is the official place i think
13:26:07 <donri> @hackage unsafe
13:26:07 <lambdabot> http://hackage.haskell.org/package/unsafe
13:28:06 <dmwit> Okay, seems S.IO.U has been around since at least GHC 7.0. So I'll skip Foreign entirely.
13:32:27 <xenocons> am I right in saying that any function can be curried?
13:33:08 <donri> not sure i would call a unary function curried
13:33:14 <ski> xenocons : how about `not :: Bool -> Bool' ?
13:33:38 <xenocons> hmm heh
13:34:23 <navaati> would there exist some sort of multiline printf quasiquoter ?
13:34:37 <donri> @hackage printf-mauke maybe
13:34:37 <lambdabot> http://hackage.haskell.org/package/printf-mauke maybe
13:34:41 <bz> what's the difference between Attoparsec.ByteString and Attoparsec.ByteString.Char8
13:34:57 <donri> oh, no qq
13:35:07 <bz> aren't bytestrings just lists of word8 which are equivalent to char8s?
13:35:20 <xenocons> this stems from me trying to work out how to curry printf in another language, but i thought i usually get the most interesting answers here
13:35:24 <donri> bz: it's a hack to use Char, there is no Char8 type
13:36:49 <navaati> bz, the first one deals with bytes, the other one deals with 8 bits characters (it truncates the upper codepoints in Char)
13:36:58 <bz> why not unify the two types?
13:37:00 <levi> bz: ByteStrings aren't lists.
13:37:14 <levi> Char8 isn't a type at all.
13:38:05 <levi> Data.ByteString.Char8 is a package where the regular ByteString functions that would deal with Word8 instead deal with Char.
13:39:38 * Hodapp attempts to understand corecursion.
13:39:44 <navaati> donri: close enough (i knew about it), but it's not multiline stuff
13:40:01 <chrizz_> using pipes-bytestring and pipes-parse, how might I do something like remove blank lines from a file?
13:40:17 <chrizz_> Pipes.ByteString.lines wraps my Producer in FreeT to process lines separately, but i'm not sure where to go from there
13:40:51 <levi> It also provides an IsString instance for ByteString which lets you use -XOverloadedStrings easily.
13:41:02 <navaati> uh, or maybe there is a way to have multiline string literals in haskell, like python's """
13:41:14 <chrisdone> yeah
13:41:18 <chrisdone> " foo \
13:41:18 <chrisdone> \ bar"
13:41:23 <mm_freak_> chrizz_: unfortunately 'lines' doesn't really do what you need by itself
13:41:40 <mm_freak_> chrizz_: i believe you will have to write your own pipe for that
13:41:44 <chrisdone> or you can use a quasiquote like
13:41:54 <chrisdone> [string|
13:41:54 <chrisdone> and then write
13:41:54 <chrisdone> whateever you want
13:41:54 <chrisdone> |]
13:41:54 <chrizz_> something like splitOn '\n' ?
13:41:57 <dmwit> chrisdone: It's not quite like Python, in that the newlines in that literal don't appear in the value.
13:42:10 <chrisdone> dmwit: which is good
13:42:12 <dmwit> or maybe that should be aimed at navaati instead of chrisdone
13:42:21 <dmwit> Maybe it's good. Depends on what navaati is looking for. =)
13:42:22 <chrisdone> yeah it was aimed at navaati
13:42:32 <ion> http://hackage.haskell.org/package/raw-strings-qq
13:42:48 <navaati> chrisdone: ah ! does this quasiquoter exist somewhere ?
13:42:51 <navaati> eh
13:42:52 <chrisdone> ion: yeah, that's good
13:43:12 <chrizz_> mm_freak_: regardless of if 'lines' works like I think it does, how do I then filter the FreeT (Producer m a) m r?
13:43:13 <mm_freak_> chrizz_: that's a type error
13:43:18 <chrisdone> navaati: see ion's link
13:43:19 <navaati> y'all write faster than i do. thank you all
13:43:34 <mm_freak_> chrizz_: you can't filter it
13:43:41 <chrizz_> why not?
13:43:43 <moon> hey everybody
13:43:58 <chrisdone> dmwit: although annoyingly GHC has some weird difference with \ in its printing
13:44:22 <chrisdone> dmwit: like it will print "foo\bar" as
13:44:23 <chrisdone> "foo\
13:44:23 <chrisdone> \bar"
13:44:44 <chrisdone> or something like that. there's a bug in the printer that conflates the syntax of multi-line strings. confused the hell out of me once
13:44:52 <Guest71743> somebody here who has 5 minutes to help me with a question?
13:45:05 <chrisdone> Guest71743: for you brad, i've got 10
13:45:33 <mm_freak_> chrizz_: because it still denotes the same stream, but in a sense with delimiter marks scattered over it
13:45:41 <chrisdone> https://www.youtube.com/watch?v=MsvjpIUFM2k
13:46:08 <Guest71743> thanks a lot
13:46:09 <mm_freak_> chrizz_: you can apply a stream processor to each individual substream
13:46:19 <Guest71743> is there any way to open a privat chat?
13:47:11 <chrisdone> just ask in here?
13:47:17 <navaati> now... can i use a quasiquoter in a th invocation...
13:47:49 <geekosaur> "/query nick" or "/msg nick whatever" --- but note that it's considered poor manners to pm someone (other than a bot, where it's actually encouraged) without an invitation
13:48:12 <Guest71743> oh ok, well then one minute :)
13:48:47 <Guest71743> I have a task "The two-argument function iff returns True exactly when both -- Boolean operands have the same value. Otherwise it returns False. Construct -- a design recipe for the iff function and implement it using"
13:48:52 <donri> mm_freak_: hm isn't it just lines >-> filter (not . null)
13:49:18 <Guest71743> my contract is defined as iff :: Bool -> Bool -> Bool
13:49:32 <Guest71743> now i need to use Conditional expressions
13:49:52 <donri> oh because FreeT
13:50:08 <chrizz_> donri: right, so what do i do about FreeT?
13:50:08 <scriptor> you could do it with pattern matching, Guest71743
13:50:36 <Cale> You could also use == but that might be cheating ;)
13:50:40 <Guest71743> iff = head [iffC] , and if im not wrong the normal way is if n >0 then n else -n
13:50:48 <Guest71743> yeah, not allowed to use ==
13:50:52 <hulahoop> Hello
13:51:06 <Cale> hello hulahoop
13:51:20 <Guest71743> so i tried iffC x y = if x y >=0 then True else False
13:51:44 <Cale> Guest71743: why do you have iff = head [iffC]?
13:51:54 <Cale> That seems like a really strange thing to do
13:51:54 <Guest71743> but there's always a warning if i try to compile it
13:52:07 <mm_freak_> chrizz_: i'd write a custom pipe that collapses multiple '\n' into a single '\n'
13:52:07 <Cale> x y means "apply the function x to the value y"
13:52:16 <scriptor> Guest71743: how much haskell have you learned so far?
13:52:18 <amalloy> Guest71743: (if foo then True else False) is just foo
13:52:18 <Cale> presumably x and y are meant to be Bool values, not functions
13:52:20 <Guest71743> actually it is iff = head [iffC, iffG, iffP, iffB], for Conditional expressions (iffC). -- b) Guarded equations (iffG). -- c) Pattern matching (iffP). -- d) Simple logical connectives (&&, ||, not) (iffB)
13:52:45 <Cale> ... weird
13:53:00 <Cale> You could equivalently just write  iff = iffC
13:53:14 <Cale> because head [iffC, iffG, iffP, iffB] = iffC
13:53:16 <chrizz_> mm_freak_: say I want to do arbitrary transformations on each line of a file, like capitalize every character after the first 'a'
13:53:42 <Guest71743> the task is in my opinion pretty wird, thats why i was asking for a pm so i dont spam here with my code i got so far
13:54:03 <scriptor> feel free to put any code in a gist or pastebin and link to it here
13:54:10 <Cale> Guest71743: If you have code to paste, put it on lpaste.net
13:54:28 <chrisdone> @where lpaste
13:54:28 <lambdabot> http://lpaste.net/new/haskell
13:54:46 <mm_freak_> chrizz_: it depends on the kind of transformation…  mapping is quite straightforward, just use transFreeT with 'map'
13:55:15 <mm_freak_> transFreeT (>-> myPipe)
13:56:08 <mm_freak_> the trouble starts when you want to transform the /structure/ of the delimited stream, e.g. filter the substreams
13:56:08 <chrizz_> ok, thanks
13:56:19 <Guest71743> tried iffC x y = if x>y then False else if y>x then False else True , now its working :/
13:57:35 <Peaker> Guest71743: what's the point of that?
13:57:42 <Cale> Guest71743: Hah, that's an interesting approach
13:58:04 <scriptor> Peaker: looks like the assignment was to implement iff using only if-then expressions
13:58:13 <Peaker> oh
13:58:15 <Cale> Though if using (==) was cheating, then using (>) is about as bad
13:58:19 <ski> hehe
13:58:43 <Cale> But I guess you have to use something
13:58:51 <hulahoop> What are suffixes and prefixes?  I need to define a function, but don't know where to start. The only thing I do know is, that suffixes/preffixes :: [a] -> [[a]]. I using learn you a haskell as a way to learn, but I am still trying to understand Types and Typeclasses.
13:59:15 <Cale> > "cat" `isPrefixOf` "catalogue"
13:59:16 <lambdabot>   True
13:59:20 <Cale> > "dog" `isPrefixOf` "catalogue"
13:59:21 <lambdabot>   False
13:59:38 <Cale> > "logue" `isSuffixOf` "catalogue"
13:59:39 <lambdabot>   True
13:59:45 <Cale> > "log" `isSuffixOf` "catalogue"
13:59:46 <lambdabot>   False
13:59:52 <Cale> > "log" `isInfixOf` "catalogue"
13:59:53 <Peaker> > "dog" `isPrefixOf` "dogalogue"
13:59:53 <lambdabot>   True
13:59:54 <lambdabot>   True
14:00:14 <scriptor> "hula" `isPrefixOf` "hulahoop"
14:00:15 <Guest71743> yes, have to use for a only conditional express, for iffG only guarded equations, for c iffP only pattern matching and so on
14:00:29 <scriptor> stupid  > character
14:00:35 <hulahoop> ah, i see it now.
14:01:49 <hulahoop> Now I will try it on my editor to see what I can do to make it. Thank you.
14:02:09 <jle`> just saw that you can take advantage of not needing spaces around operators and using lens tricks to write things like object.method
14:02:22 <jle`> feels so wrong in my heart
14:02:26 <Cale> jle`: yes
14:02:51 <jle`> i am not sure whether to be in awe or in horror
14:03:03 <Cale> Well, at least it's still function composition.
14:03:11 <jle`> just saw someone write boss.health -= 10
14:03:12 <Cale> I would just write the spaces
14:03:22 <Cale> and not use things like -=
14:03:27 <ski> > "stupid" > "character"
14:03:28 <lambdabot>   True
14:03:45 <lightquake> what's the difference between a ByteString and something like Vector Word8?
14:04:19 <Ralith> lightquake: bytestrings aren't necessarily contiguous
14:04:28 <jle`> so doing things like boss.health -= 10 is probably not recommended?
14:04:39 <jle`> granted it provides an interestingly expressive dsl
14:04:47 <jfischoff> Ralith: strict bytestrings?
14:04:50 <lightquake> Ralith: what do you mean?
14:04:58 <jle`> http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
14:05:01 <ParahSai1in> @src B.ByteString
14:05:01 <lambdabot> Source not found. You speak an infinite deal of nothing.
14:05:06 <FreeFull> One time where I think you do need spaces is when you are using a constructor as one of the functions
14:05:10 <Ralith> lightquake: in memory
14:05:10 <Ralith> jfischoff: ?
14:05:13 <FreeFull> > Just.(+1) $ 3
14:05:14 <lambdabot>   Just 4
14:05:17 <FreeFull> Oh, seems not
14:05:33 <Cale> jle`: Just by me. I don't like all the wacky infix operators that lens provides
14:06:01 <FreeFull> The operators are optional
14:06:11 <lightquake> FreeFull: yes you do, Just.show gets interpreted as a single qualified name
14:06:30 <FreeFull> I guess I used a wrong example
14:06:30 <jfischoff> Ralith: I don't see how PS (ForeignPtr Word8) Int Int would not be contigious?
14:06:34 <FreeFull> > Just.show $ 3
14:06:35 <lambdabot>   Not in scope: `Just.show'
14:06:51 <Cale> FreeFull: right, but people will end up using them because they're there
14:07:06 <FreeFull> True
14:07:14 <Cale> %= is enough, we don't need += -= etc etc.
14:07:29 <S11001001> jle`: https://twitter.com/PLT_Borat/status/228009057670291456
14:07:38 <Ralith> jfischoff: perhaps that only applies to lazy ByteStrings then, but that's somewhat surprising to me. I don't know much about the internals so I can't comment on the constructor.
14:07:39 <prooftechnique> So if I'm translating a BNF to Parsec (well, attoparsec, really), am I right in thinking that <term>? goes to option (sensible empty) <parser> and that <term>* goes to many' <parser> (or takeWhile, I guess)?
14:07:58 <Ralith> jfischoff: that certainly does look like pointer+offset+length, though.
14:08:23 <jfischoff> Ralith: Lazy bytestrings are a list of strict bytestrings
14:08:42 <prooftechnique> *BNF grammar
14:08:42 <Ralith> jfischoff: okay then
14:08:45 <ski> Cale : perhaps relegate them to a submodule ?
14:08:56 <Cale> ski: Yeah, that might help.
14:09:11 <mm_freak_> newtype FreeT f m a = FreeT { runFreeT :: m (Either a (f (FreeT f m a))) }
14:09:21 <Ralith> jfischoff: it does surprise me a bit that ForeignPtr Word8 is used instead of an unboxed vector though
14:09:23 <mm_freak_> would be A LOT easier to deal with if it were defined just like that
14:09:41 <jfischoff> Ralight: yes
14:09:44 <jfischoff> err
14:09:50 <quchen> mm_freak_: Is the current definition that much different?
14:09:52 <jfischoff> Ralith :p
14:09:57 <Cale> (%=) would also be a synonym of modifyL or something if I had my way
14:09:58 <quchen> It's just a split in two data types, isn't it
14:10:11 <mm_freak_> quchen: yes, it uses a custom type FreeF instead of Either
14:10:23 <mm_freak_> so all existing Either functions can't be used =/
14:10:42 <quchen> Hm. Well that's bad.
14:10:56 <FreeFull> FreeF highlights me
14:11:15 <mm_freak_> and that type doesn't do you a favor at all by being parameterized on the functor as well
14:11:25 <mm_freak_> it makes the whole thing just really complicated and tiring to work with
14:13:24 <ski> `data FreeF f m a = Yes a | No (f (FreeR f m a))' ?
14:13:40 <ski> (s/FreeR/FreeT/)
14:17:00 <Peaker> Cale: it's nice that we can appeal to imperative programmers with +=, -=, etc :)
14:17:16 <Peaker> (those operators aren't used anyway, and they don't require memorizing much)
14:17:23 <Peaker> and save some parens to boot!
14:18:50 <mm_freak_> ski: that would work, too
14:19:01 <mm_freak_> just not this ugly mix between specifying here and there
14:19:17 <mm_freak_> ski: in fact i like that solution best
14:21:00 <ski> mm_freak_ : oh ?
14:21:12 <ski> i thought that was what it currently did
14:21:48 <mm_freak_> ski: no, currently it forces me to look back and forth
14:21:59 <ski> i'm not sure what you mean by that
14:22:02 <mm_freak_> because it's No (f a) instead
14:22:07 <skypers> hey
14:22:08 <donri> data FreeF f a b = Pure a | Free (f b)
14:22:25 <skypers> how does fixity work?
14:22:27 <skypers> for instance
14:22:35 <skypers> a * b + c
14:22:43 <prooftechnique> :info (*)
14:22:43 <ski> that's precedence, not fixity
14:22:45 <skypers> * has a higher fixity, or not?
14:22:51 <skypers> yeah precedence, sorry
14:22:54 <ski> no, higher precedence
14:23:01 <skypers> ok
14:23:16 <skypers> so if I want my operator to always bind to everything and its right
14:23:19 <skypers> infixr 9
14:23:21 <skypers> right?
14:23:41 <ski> `*' "binds tighter" / "pulls harder" on the betwixt `b' than `+' does
14:24:08 <ski> "always bind to everything" is a strong requirement
14:24:19 <skypers> is there a keyword to know the precedence of on operator?
14:24:25 <skypers> well
14:24:29 <ski> try `:info *' in GHCi ?
14:24:39 <skypers> ($) has a high precedenc right?
14:24:49 <geekosaur> low
14:24:49 <Guest71743> can i set in guarded equations otherwises as much as i want?
14:24:55 <skypers> infixr 0 $
14:24:56 <skypers> 0
14:24:58 <skypers> WHAAAAT
14:24:59 <ski> no, `$' is `infixr 0'
14:25:09 <skypers> oh
14:25:10 <skypers> I get it
14:25:16 <geekosaur> that's the point of ($), it's lowest precedence so you can omit some parentheses
14:25:20 <skypers> it will be evaluated the last
14:25:27 <donri> Guest71743: only the first will match
14:25:29 <skypers> ok
14:25:32 <dmwit> Let's not drag evaluation order into this. =P
14:25:32 <ski> application has precedence `10' (and is left-associative)
14:25:38 <donri> Guest71743: it's just an alias for True
14:25:51 <skypers> left associative means hm
14:25:54 <skypers> a + b + c
14:25:55 <ski> precedence and fixity is just a way to elide some brackets
14:25:57 <skypers> is (a + b) + c
14:25:58 <skypers> right?
14:25:59 <ski> yes
14:26:00 <geekosaur> yes
14:26:01 <skypers> ok
14:26:07 <skypers> so
14:26:10 <skypers> if I write
14:26:16 <skypers> infixr 0 <~
14:26:17 <skypers> and do
14:26:22 <skypers> a <~ b <~ c
14:26:25 <skypers> it the same as
14:26:27 <FreeFull> Some people say $ should be infixl
14:26:30 <skypers> a <~ (b <~ c)
14:26:38 <ski> also that `a + b - c' and `a - b + c' is `(a + b) - c' and `(a - b) + c', since `+' and `-' have the same precedence, and are both left-associative
14:26:45 <dmwit> (Side note: you should press enter less.)
14:26:47 <ski> skypers : yes
14:27:07 <skypers> ok
14:27:09 <skypers> easy then
14:27:13 <skypers> just one last question
14:27:15 <tomejaguar> Woludn't infixl defeat the purpose of $?
14:27:25 <skypers> is there a table that maps operators to their precedence?
14:27:25 <skypers> like
14:27:27 <ski> what's the purpose of `$' ?
14:27:31 <dmwit> tomejaguar: I don't think so; why do you think it would?
14:27:34 <skypers> ski
14:27:34 <tomejaguar> Err wait, maybe I missed the joke :)
14:27:43 <benmachine> skypers: the easiest way to discover fixities is with :info in ghci
14:27:43 <ski> tomejaguar : no joke
14:27:45 <dmwit> no joke
14:27:45 <skypers> putStrLn $ "hi" ++ "lol"
14:27:48 <Guest71743> so if I would like to write a guarded equations with x and y, that if x=y true is, how would it look like? :/
14:27:55 <skypers> oh ok benmachine
14:28:06 <skypers> ski: I use ($) _everywhere_
14:28:10 <dmwit> Guest71743: foo x y | x == y = bar
14:28:11 <skypers> maybe I’m wrong doing so
14:28:15 <benmachine> tomejaguar: often $ is used with . which has much the same effect as a right-associative $
14:28:16 <skypers> but I just love the ($) operator
14:28:17 <ski> skypers : imo, `putStrLn ("hi" ++ "lol")' would be just as clear there
14:28:31 <skypers> ski: yes sure
14:28:39 <tomejaguar> I'm confused, but to be honest I only ever really use .
14:28:49 <skypers> but putStrLn $ … yiels shorter code
14:28:50 <benmachine> tomejaguar: so you can write f $ g $ x or f . g $ x and they're roughly the same
14:29:09 <skypers> I often use it at the end of a function call
14:29:10 <benmachine> tomejaguar: this is with $ infixr; with it infixl instead you could write different things that you can't write with .
14:29:11 <skypers> like
14:29:14 <Guest71743> is there any other way without == ?
14:29:23 <ski> i very seldom write stuff like `foo x $ bar y z $ ...'
14:29:27 <ski> Guest71743 : yes
14:29:30 <skypers> aFunction a b c $ show d
14:29:46 <skypers> Guest71743: make a guarding function?
14:29:56 <Guest71743> yes
14:30:09 <benmachine> tomejaguar: however I tend to use parens anyway :P
14:30:10 <skypers> hm, you still use (==)
14:30:23 <skypers> so I’m wrong using ($) everywhere?
14:30:32 <tomejaguar> Maybe people use ($) everywhere
14:30:44 <ski> skypers : imo, you should consider using it less. just my opinion, though
14:30:49 <skypers> why?
14:30:50 <Cale> skypers: Typically I'll turn all the ($)'s in a chain except the last one into (.)
14:30:58 <ski> because it's ugly to overuse ?
14:31:00 <Cale> skypers: This has a bunch of little benefits
14:31:07 <skypers> Cale: oh, I do the opposite :D
14:31:08 <skypers> like
14:31:13 <tomejaguar> Personally I use . because it is an associative operation
14:31:23 <tomejaguar> which is not sensitive to its context
14:31:27 <skypers> lift . gets $ aFunc
14:31:32 <Cale> One is that (.) is associative, so expressions written with it have more effective subexpressions.
14:31:45 <tomejaguar> Cale++
14:31:51 <Cale> for example, in that expression you just wrote,  lift . gets  is a valid thing
14:31:57 <Cale> It's meaningful on its own
14:32:06 <Cale> while  lift $ gets  is a type error
14:32:14 <ski>   blah = foo a b
14:32:17 <skypers> https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/GL/Buffer.hs#L122
14:32:19 <ski>        . bar x
14:32:20 <skypers> here
14:32:24 <ski>        . baz y z
14:32:27 <ski>       $ frotz
14:32:34 <skypers> I just love ($).
14:32:55 <skypers> lift . gets $ binds . bufferStack
14:33:02 <Cale> yeah, that's fine
14:33:03 <skypers> it might be astonishing at first
14:33:07 <mp> how can I convince ghc-mod that Prelude exports Fay? I'm using Syntastic inside Vim
14:33:08 <skypers> but I just like it
14:33:11 * hackagebot stompl 0.1.0 - Stomp Parser and Utilities  http://hackage.haskell.org/package/stompl-0.1.0 (TobiasSchoofs)
14:33:12 <skypers> and now I know (&)
14:33:21 <Cale> but for instance, two lines below that
14:33:22 <skypers> I’m gonna make love to both of them AHAHHAHAHA
14:33:22 <Philonous> skypers, And yet some people say 'id' is a silly function.
14:33:24 <Cale> I would write
14:33:25 <skypers> (ok I’m tired.)
14:33:35 <Cale> lift . modify . newBufferStack . BufferStack $ tail s
14:33:38 <Cale> or perhaps
14:33:44 <Cale> lift . modify . newBufferStack . BufferStack . tail $ s
14:33:48 <yesthisisuser> I am trying to wrap my head around GADTs.. http://lpaste.net/95533 I can see how this is not working, but is there a way around this?
14:33:55 <skypers> Cale: not sure it works
14:34:02 <skypers> I would have written that as well
14:34:13 <skypers> Philonous: id is silly?
14:34:15 <skypers> why?
14:34:19 <Philonous> skypers, It's not.
14:34:29 <Cale> Whenever you have f $ g $ h x, you can always rewrite that as f . g $ h x
14:34:34 <Philonous> skypers, But you seem to have acquired at particular fondness for it
14:34:35 <FreeFull> Well, the uses of an identity function aren't obvious at first sight
14:34:36 <skypers> I don’t actually ever use it, but hm, it’s okey?
14:34:41 <Guest71743> and how would x,y look like if i would like to do it with pattern matching?
14:34:44 <Peaker> Cale: *almost* always (RankNTypes hack for $)
14:34:47 <Philonous> skypers, ($) = id
14:34:48 <skypers> Philonous: for… what?
14:34:54 <Cale> Peaker: well, yeah, but that hack is terrible
14:35:01 <Peaker> Cale: sure, still :)
14:35:05 <skypers> Philonous: yeah, but the precedence of id is… what?
14:35:06 <benmachine> Cale: but it's so *handy*
14:35:21 <FreeFull> $ is infix id
14:35:24 <Peaker> benmachine: it would be more handy to just not require $ before "do", "case", etc
14:35:32 <benmachine> Peaker: good point
14:35:40 <FreeFull> skypers: I don't think it's defined
14:35:48 <FreeFull> But you could do   infixr 0 `id`
14:36:00 <skypers> ok
14:36:02 <benmachine> the default fixity is infixl 9
14:36:10 <FreeFull> Well, there is a default fixity
14:36:11 <skypers> ok
14:36:13 <ski> > let infixr 0 `id`; id = Prelude.id in (2 +) `id` (2 ^) `id` 3
14:36:15 <lambdabot>   10
14:36:47 <ski> Peaker : yes
14:37:01 <skypers> 23:21 < Peaker> benmachine: it would be more handy to just not require $ before "do", "case", etc
14:37:04 <skypers> yeah
14:37:09 <skypers> I have a lot of that too
14:37:22 <skypers> fillBuffer d u t = gl ("fill buffer target " ++ show t ++ " as " ++ show u) $ do
14:37:26 <skypers> here for instance :)
14:37:29 <Peaker> when showing Haskell to beginners, that extra ($) noise before my "do"s is another little obstacle in my way to explaining it :(
14:37:43 <Guest71743> would it be like iffP x y = not False = True ?
14:37:45 <skypers> Peaker: yeah
14:37:51 <skypers> even in simple statement
14:38:05 <Philonous> Peaker, You could say you need to bribe the "do" into doing it's job
14:38:08 <Peaker> yeah, I can avoid ($) in ordinary expressions when showing beginners stuff. I can't avoid it for "do" blocks without massive ugly parens
14:38:12 * hackagebot postgresql-orm 0.2 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  http://hackage.haskell.org/package/postgresql-orm-0.2 (AmitLevy)
14:38:13 <Peaker> hah
14:38:14 * hackagebot stomp-queue 0.1.0 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.1.0 (TobiasSchoofs)
14:38:16 <skypers> Guest71743: what do you mean with that?
14:38:21 <ski> Guest71743 : you'd need to change the stuff to the left of the first `=', for pattern-matching
14:38:35 <skypers> Peaker: avoiding ($) leads to (())(()))
14:38:38 <donri> yeah parenthesis around layout is ugly as sin
14:38:39 <skypers> I don’t really like that
14:39:22 <Peaker> skypers: I agree, I use ($) and (.) to avoid parens in my code. but for showing beginners, it's nice to stick to a small subset of the language
14:39:41 <Peaker> btw, if Haskell had no ($) at all, it could be nice to just use a single () and dots
14:39:43 <FreeFull> Avoiding ($) and (.) leads to lisp
14:39:49 <skypers> (.) to avoid parens?
14:40:05 <ski> Scheme is nice
14:40:07 <skypers> ahahah
14:40:14 <skypers> FreeFull: I thought of it as well :D
14:40:16 <Peaker> skypers: (foo . bar . baz) x
14:40:31 <ski> Peaker : i often write like that
14:40:33 <arnsholt> I must confess it took me a little bit to keep (.) and ($) straight, at first
14:40:34 <preflex>  arnsholt: you have 1 new message. '/msg preflex messages' to read it.
14:40:40 <skypers> Peaker: foo . bar . baz $ x
14:40:45 <donri> i like parenthesis, easier to manipulate
14:40:52 <AlexS90> Is there a straightforward way to disable the automatic vector-of-tuples -> tuple-of-vectors transformation that Data.Vector.Unboxed does?
14:41:04 <benmachine> so it's known that Applicative is equivalent to a class with f () and f a -> f b -> f (a, b), but are there standard names for the latter thing?
14:41:10 <Peaker> skypers: I know, it's not clear that ($) is worth it for just one set of parens, though
14:41:27 <skypers> benmachine: maybe in Arrow?
14:41:37 <benmachine> skypers: nope
14:41:37 <Peaker> benmachine: There's a "Zip" class with that in it.. So it seems to be an alternative instance attachment for Applicative
14:41:44 <FreeFull> What if you want to write something like map ($ 3)
14:41:52 <Peaker> benmachine: Not sure if "f ()" is in it
14:42:12 <skypers> FreeFull: can we write your line with ??
14:42:23 <Peaker> FreeFull: that's probably worth ($) yeah :)
14:42:25 <skypers> map (?? 3) [1,2]
14:42:29 <skypers> > map (?? 3) [1,2]
14:42:30 <lambdabot>   Could not deduce (GHC.Num.Num (f (GHC.Integer.Type.Integer -> b)))
14:42:30 <lambdabot>    arisi...
14:42:33 <skypers> yeah, fail.
14:42:33 <FreeFull> ?? isn't in Prelude
14:42:34 <lambdabot>  isn't in Prelude
14:42:36 <donri> > map (flip id 3) [(1+), (2+)]
14:42:37 <lambdabot>   [4,5]
14:42:59 <skypers> donri: I would have written something like
14:43:07 <skypers> [(1+),(2+)] <*> pure 3
14:43:13 <skypers> > [(1+),(2+)] <*> pure 3
14:43:14 <lambdabot>   [4,5]
14:43:17 <FreeFull> Applicative isn't in Prelude (yet)
14:43:18 <donri> :)
14:43:23 <skypers> yet?
14:43:26 <skypers> what yet
14:43:35 <skypers> hey hey hey
14:43:44 <FreeFull> I'm assuming AMP will bring it in
14:43:55 <skypers> if you put Applicative in prelude, put <$> with it
14:44:10 <skypers> Prelude*
14:44:23 <donri> > pure 3 <**> [(1+), (2+)]
14:44:24 <lambdabot>   [4,5]
14:44:35 <skypers> ooooooh
14:44:41 <skypers> so <**> is flip <*>?
14:44:43 <donri> yes
14:44:47 <skypers> funny
14:44:59 <ski> > sequence [(1+), (2+)] 3
14:45:00 <lambdabot>   [4,5]
14:45:09 <skypers> and I guess this would work:
14:45:22 <FreeFull> sequenceA
14:45:34 <skypers> > pure 3 <**> [1..3] <$$> [10,20]
14:45:35 <lambdabot>   Not in scope: `<$$>'
14:45:35 <lambdabot>  Perhaps you meant `<$>' (imported from Control.Applic...
14:45:38 <skypers> arf
14:45:41 <FreeFull> > sequenceA [(+1), (+2)] 3
14:45:42 <lambdabot>   Not in scope: `sequenceA'
14:45:42 <lambdabot>  Perhaps you meant one of these:
14:45:42 <lambdabot>    `T.sequenceA'...
14:45:45 <donri> :t (<&>)
14:45:46 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:45:49 <FreeFull> > T.sequenceA [(+1), (+2)] 3
14:45:49 <skypers> > pure 3 <**> [1..3] <&> [10,20]
14:45:50 <lambdabot>   [4,5]
14:45:51 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
14:46:07 <skypers> > pure 3 <**> [1..3] <&> (+)
14:46:09 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> a))
14:46:09 <lambdabot>    arising f...
14:46:13 <FreeFull> Probably wrong fixity
14:46:21 <skypers> ok I just suck at that lambdabot thing.
14:46:22 <skypers> :D
14:46:33 <FreeFull> Well, numbers aren't functions
14:46:37 <FreeFull> So that's a problem too
14:46:47 <ski> > let flip fab a = fmap ($ a) fab in [(1+), (2+)] `flip` 3
14:46:48 <lambdabot>   [4,5]
14:46:49 <FreeFull> At least, lambdabot doesn't have a function instance for numbers
14:47:02 <alkabetz> … anymore.
14:47:14 <donri> ... thankfully.
14:47:25 <prooftechnique> What did that even look like?
14:47:33 <FreeFull> It does let you do cool stuff
14:47:38 <donri> @hackage NumInstances
14:47:39 <lambdabot> http://hackage.haskell.org/package/NumInstances
14:47:50 <hpc> FreeFull: my favorite side effect of it was that 0xford = 15
14:48:20 <skypers> hey
14:48:36 <skypers> a <~ b :: Float
14:48:41 <skypers> what does the :: Float refer to?
14:48:46 <skypers> (a <~ b)
14:48:47 <skypers> or b?
14:48:54 <Iceland_jack> a <~ b
14:48:54 <donri> former
14:48:57 <ski> @let instance Num n => Num (rho -> n) where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = liftA negate; abs = liftA abs; signum = liftA signum; fromInteger = pure . fromInteger
14:48:58 <lambdabot>  Defined.
14:48:59 <skypers> yeah…
14:49:12 <skypers> ski: dafu**
14:49:12 <donri> you need explicit parenthesis with :: or it's the whole expression
14:49:18 <Iceland_jack> skypers: You can try it out yourself
14:49:19 <FreeFull> <~ isn't syntax so (a <~ b)
14:49:32 <jmcarthur_mobile> Do notation
14:49:32 <donri> > 0xford
14:49:39 <lambdabot>   15
14:49:39 <FreeFull> Something like <- would be different
14:49:45 <alkabetz> *headdesk*
14:49:47 <FreeFull> r isn't valid hex
14:49:50 <alkabetz> Not again … :(
14:49:55 <ski> > (sin^2 + cos^2) `map` [0 , pi/8 .. pi/2]
14:49:55 <jmcarthur_mobile> Oh is that a tilde. I can't even tell on my phone
14:50:02 <lambdabot>   [
14:50:18 <FreeFull> [
14:50:23 <ski> @botsmack
14:50:23 <lambdabot> :)
14:50:43 <donri> what
14:50:59 <skypers> jmcarthur_mobile: yes it is
14:51:09 <FreeFull> > map (sin^2 + cos^2) [0,pi/8 .. pi/2]
14:51:13 <lambdabot>   [1.0,1.0,1.0,1.0,1.0]
14:51:16 <skypers> and btw, it might be a bad operator; I’ll change it
14:51:19 <prooftechnique> Oh, god, these Enum instances for tuples
14:51:40 <FreeFull> > [(0,0)..(3,3)]
14:51:42 <lambdabot>   No instance for (GHC.Show.Show t1)
14:51:42 <lambdabot>    arising from a use of `M5688882463615...
14:51:44 <hpc> > enumFrom (False, False)
14:51:45 <lambdabot>   No instance for (GHC.Enum.Enum (GHC.Types.Bool, GHC.Types.Bool))
14:51:45 <lambdabot>    arising...
14:51:49 <skypers> 23:37 < FreeFull> > map (sin^2 + cos^2) [0,pi/8 .. pi/2]
14:51:50 <skypers> omg
14:51:57 <ski> > range ((0,0),(3,3))
14:51:58 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
14:52:00 <skypers> how does the .. work here?
14:52:13 <prooftechnique> :t enumFromTo
14:52:14 <lambdabot> Enum a => a -> a -> [a]
14:52:14 <skypers> it just calls
14:52:17 <Peaker> Ix instance, not Enum instance
14:52:18 <skypers> succ?
14:52:20 <FreeFull> skypers: That's just enum for floats
14:52:38 <FreeFull> Which actually behaves pretty weird
14:52:39 <ski> > (sin^2 + cos^2) `map` enumFromThenTo 0 (pi/8) (pi/2)
14:52:42 <lambdabot>   [1.0,1.0,1.0,1.0,1.0]
14:52:45 <skypers> > succ (pi/8)
14:52:46 <FreeFull> > [0..3.3]
14:52:47 <lambdabot>   1.3926990816987241
14:52:48 <lambdabot>   [0.0,1.0,2.0,3.0]
14:52:56 <FreeFull> > [0,0.1..3.3]
14:52:58 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
14:53:01 <prooftechnique> Peaker: No, I mean in the commented out chunk at the bottom of Data.NumInstances.Tuple
14:53:04 <FreeFull> > last [0,0.1..3.3]
14:53:06 <lambdabot>   3.300000000000002
14:53:08 <skypers> it’s going dirty with lambdabot
14:53:17 <FreeFull> > last [0,0.4..3.3]
14:53:18 <lambdabot>   3.2
14:53:48 <FreeFull> The Float instance doesn't really use the last bit as a strict upper bound
14:56:13 <skypers> ok new question, how, from 4 Word32, would you end up with a (Float,Float,Float,Float)?
14:56:17 <skypers> I have this:
14:56:39 <skypers> (realToFrac a,realToFrac b,realToFrac c,realToFrac d) :: (Float,Float,Float,Float)
14:57:22 <FreeFull> You could use lenses
14:57:23 <donri> :t over each realToFrac
14:57:25 <lambdabot> (Fractional b, Real a, Each Mutator s t a b) => s -> t
14:58:00 <donri> :t over each realToFrac `asAppliedTo` (1,2,3,4)
14:58:01 <FreeFull> I don't think there is any other clean way
14:58:02 <lambdabot> (Fractional b4, Real t) => (t, t, t, t) -> (b4, b4, b4, b4)
14:58:12 <skypers> ok
14:58:14 <skypers> thank you
14:58:56 <skypers> functions like each are mainly TH aren’t they?
14:59:39 <skypers> btw, is there a class that represents OneType types?
14:59:42 <skypers> like (a,a,a,a,a,…)
14:59:44 <skypers> and so on?
14:59:53 <skypers> we could make Functor instances of those
15:00:00 <FreeFull> I don't think there is any TH involved
15:00:24 <donri> skypers: that's what Each is, sort of
15:00:25 <prooftechnique> There's some TH in lens for convenience, but a very minimal amount that is actually necessary, IIRC
15:00:45 <FreeFull> Well, technically none is necessary
15:00:51 <skypers> @hoogle Each
15:00:52 <lambdabot> Foreign.C.Error eHOSTUNREACH :: Errno
15:00:52 <lambdabot> Foreign.C.Error eNETUNREACH :: Errno
15:00:52 <lambdabot> Data.Graph reachable :: Graph -> Vertex -> [Vertex]
15:01:08 <donri> :t each
15:01:09 <lambdabot> (Indexable (Index t) p, Each f s t a b) => p a (f b) -> s -> f t
15:02:07 <skypers> hm, ok :D
15:02:10 <skypers> thank you
15:02:33 <Philonous> skypers, You can't make them into Functors because the kind doesn't match up. Functors need to have exactly one type parameter.
15:02:59 <donri> well i assume skypers meant e.g. data Pair a = Pair a a
15:03:09 <FreeFull> I assume something like that too
15:03:21 <FreeFull> Which would work
15:04:02 <donri> skypers: https://hackage.haskell.org/package/tuples-homogenous-h98-0.1.1.0/docs/Data-Tuple-Homogenous.html look what i found
15:04:05 <SwineFlu> Hi, Can someone tell me whats going on in variables herhttp://hackage.haskell.org/package/hatt-1.5.0.3/docs/src/Data-Logic-Propositional-Core.html#Expr
15:04:15 <SwineFlu> Surely you only need the first line v : vs?
15:04:23 <SwineFlu> The first line of the let I mean
15:04:38 <bz> argh
15:04:43 <bz> anyone knwo where the llvm haddock is?
15:05:01 <joelteon> anyone have a link to that clang wrapper script?
15:05:30 <FreeFull> SwineFlu: Which definition are you looking at?
15:05:35 <donri> bz: older version at https://hackage.haskell.org/package/llvm-3.0.1.0
15:06:14 <donri> bz: and you can always install with --enable-documentation
15:06:15 <FreeFull> Oh, it's called variables
15:06:22 <donri> bz: or cabal get and cabal haddock
15:06:23 <SwineFlu> the function variables
15:06:29 <SwineFlu> i'm having trouble understanding
15:06:58 <chrisdone> donreeee
15:07:34 <FreeFull> SwineFlu: You could have something like  (Negation (Variable x) (Variable y))
15:07:43 <donri> SwineFlu: consider: variables (Negate (Variable (Var 'x')))
15:07:55 <FreeFull> I mean, not Negation
15:07:58 <FreeFull> But one of the other ones
15:08:03 <donri> chrisdonreeee
15:08:06 <chrisdone> :D
15:08:11 <skypers> 23:49 < donri> well i assume skypers meant e.g. data Pair a = Pair a a
15:08:14 <skypers> yeah well
15:08:19 <SwineFlu> So varsiables with remove logical equivalency's?
15:08:24 <skypers> a weakened version of (,)
15:08:31 <skypers> like Pair, yeah
15:08:49 <FreeFull> variables just makes a list of all the variables
15:09:11 <donri> also, this code is begging for plated/uniplate ;)
15:09:48 <SwineFlu> I think I need to read more about prop logic then come back to this
15:11:35 <donri> skypers: another https://hackage.haskell.org/package/tup-functor-0.2.0.3/docs/Data-Tup-Tup-Lazy.html
15:12:00 <chrisdone> donrij =)
15:12:23 <chrisdone> what's Data.Tup.Tup.Lazy for?
15:12:50 <triliyn> https://hackage.haskell.org/package/tup-functor-0.2.0.3/docs/Data-Tup-Tup-Concat.html#t:TupConcat this is horrendous D:
15:12:54 <donri> chrisdone: homogeneous tuples, which enable instances like Functor
15:13:37 <donri> triliyn: hah nice
15:13:56 <joelteon> whoa, did cabal-install get an update recently
15:14:05 <joelteon> output and config files look totally different
15:14:08 <chrisdone> triliyn: if by horrendous you mean beautiful!
15:15:52 <donri> skypers: also https://github.com/ku-fpg/sized-types which uses more type level programming and might be nicer
15:16:45 <jrmithdobbs> does anyone happen to know what exactly is referenced in this issue? https://github.com/yesodweb/yesod/issues/431
15:16:53 <jrmithdobbs> says added but no links anywhere on how to use it :(
15:18:19 <piezoid> hi everyone
15:18:30 <jhinkle> i'm trying to do something I think may be impossible, but I'm not sure.  I have data A = forall a. (C a) => A a. I'd like to unravel this and write sameUnder :: A -> A -> Bool to compare whether the same quantified type
15:19:25 <piezoid> what sould be the type of function taking an optional argument and can fail only if the argument is not provided ?
15:19:32 <geekosaur> if you put a Typeable constraint on it you may be able to do something with it
15:19:44 <piezoid>  some thing like f :: Maybe a -> Maybe b with the assumption that  isJust . f . Just == const True
15:20:32 <piezoid> I think of (a -> b, Maybe b), is it right ?
15:22:24 <donri> piezoid: fmap (f :: a -> b)  :p
15:23:28 <Cale> I agree with donri
15:24:11 <Cale> If the function can only fail when the argument is Nothing, then it's secretly an ordinary function a -> b which you could write and then apply fmap to
15:24:12 <piezoid> donri: yes but it can compute a 'Maybe b' without a 'a'
15:25:43 <donri> i thought you wanted f Nothing = Nothing
15:25:55 <donri> @src Maybe fmap
15:25:56 <lambdabot> fmap _ Nothing       = Nothing
15:25:56 <lambdabot> fmap f (Just a)      = Just (f a)
15:27:16 <piezoid> ok, I sould mention that I have some context, so it's more like f :: Maybe a -> m (Maybe b)
15:27:25 <alexander__b> haskell cafe subscribers: how much traffic does it get?
15:28:42 <donri> piezoid: fmap (flip f :: m -> a -> b) ?
15:29:25 <donri> uh
15:29:34 <donri> piezoid: fmap (flip f m :: a -> b) ?
15:29:52 <zrho> As a big Dr. Who fan I'm currently totally happy about Control.Monad.Tardis ^^
15:30:00 <jrmithdobbs> ok, i'm feeling retarded again, how do you handle query params in yesod at all? I feel like i'm completely missing something ... i know it's supposed to be REST and all but i need a query param :(
15:30:09 <khyperia> what is it, zrho? Or should I google it?
15:30:18 <zrho> State and reverse State monad
15:30:29 <zrho> Reverse state working with lazyness.
15:30:42 <zrho> Basically you can send state in the past and the future^^
15:30:50 <khyperia> oh geez
15:31:04 <monochrom> Control.Monad.Tardis is at http://hackage.haskell.org/package/tardis
15:31:16 <Rarrikins> That's an interesting name for it.
15:31:32 <khyperia> but I can see how that's really really useful
15:31:36 <monochrom> perhaps it looks like the future rather than is the the future
15:31:37 <khyperia> sort of like mfix
15:31:48 <simpson> Honestly, I can't see how it's useful, but then again I am not a Time Lord.
15:31:49 <Rarrikins> It's useful for game bots.
15:32:07 <zrho> Also for compilers
15:32:09 <jle`> why can't we have something like a fstable/sndable/thdable typeclass and have the 2-tuple and 3-tuple implement them
15:32:10 <Rarrikins> You can make nice monadic bots that way. I merged the two monads to do that.
15:32:22 <khyperia> simpson, you want me to give an example? (it's a compiler example)
15:32:37 <donri> jrmithdobbs: does this help? https://hackage.haskell.org/package/yesod-core-1.2.4.5/docs/Yesod-Core-Handler.html#g:6
15:32:42 <monochrom> jle`: we can. you can. I am just not interested in it.
15:32:52 <piezoid> jrmithdobbs: reqGetParams <$> getRequest :: Handler ![(Text, Text)]
15:32:55 <simpson> khyperia: An informal example would be great, yes. I know compilers, but I can't think of any compiler algorithm that would benefit from this.
15:33:04 <zrho> GHC uses something like this: http://blog.ezyang.com/2013/09/of-monadic-fixpoints-and-heap-offsets/
15:33:13 <zrho> But not explicitly packed in a RState monad.
15:33:58 <khyperia> Essentially, when you're doing a code-gen pass on, say, a while loop, you need to jump from the beginning to the end (if it's false). You don't know what label is at the end until you generate the body, though, so you send the resulting label back to the beginning with tardis-witchcraft
15:33:59 <jrmithdobbs> piezoid: but how do I define the route in the first place?
15:34:52 <khyperia> the same thing can be done with mfix, but I assume tardis allows other more powerful things
15:34:58 <monochrom> Rarrikins: can I say, "tardis is good for making Daleks"? :)
15:35:07 <simpson> Oh my! This could be quite nifty.
15:35:10 <zrho> For defeating them maybe.
15:35:12 <piezoid> jrmithdobbs: do you use the scaffolded site ?
15:35:52 * monochrom likes Daleks
15:36:01 <jrmithdobbs> piezoid: i'm using a layout loosely based on the school of haskell yesod tutorial thing
15:36:07 <donri> jrmithdobbs: i don't think you can route on query params. you route a path to a handler and inspect the query params there
15:36:12 <donri> i haven't used yesod though
15:36:48 <jrmithdobbs> piezoid: so I'm not sure what you're asking
15:37:03 <Rarrikins> Sorry, I don't know much about Dr. Who :(
15:37:26 <zrho> I have used yesod for two smallish projects; I didn't see any possibility to route on query params. I think they are handled like a form transmitted over GET
15:37:32 <zrho> Can you route on forms?
15:37:53 <piezoid> jrmithdobbs: yogsototh's tutorial ?
15:38:32 <jrmithdobbs> piezoid: https://www.fpcomplete.com/school/advanced-haskell-1/building-a-file-hosting-service-in-yesod
15:39:52 <jle`> Rarrikins: can you give an example/reference?  i am interested in seeing this.
15:40:02 <jle`> about the reverse state
15:40:36 <jle`> and game bots
15:41:34 <joelteon> cabal-install doesn't give the file-by-file compile output anymore
15:41:40 <joelteon> can I get that back? I liked it
15:41:53 <geekosaur> -v1?
15:42:11 <joelteon> is that equivalent to verbose: 1 in the config file
15:42:24 <joelteon> because that doesn't work
15:42:27 <piezoid> jrmithdobbs: you have a mkYesod statement somewhere with either a parseRoute, you add the route here
15:42:28 <geekosaur> oh
15:43:21 <jrmithdobbs> piezoid: yes, i have a parseRoutesFile, I have the route defined there, i have the getWhateverR defined as :: Handler TypedContent
15:43:28 <jrmithdobbs> :t <$>
15:43:29 <lambdabot> parse error on input `<$>'
15:43:38 <khyperia> :t (<$>)
15:43:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:44:06 <monochrom> joelteon: perhaps look for stuff in $HOME/.cabal/logs
15:44:23 <joelteon> nope, not there
15:44:32 <joelteon> what version did this change in? did I miss something?
15:44:40 <donri> joelteon: -j1
15:45:17 <joelteon> oh, multiple jobs
15:45:18 <joelteon> that must be it
15:45:44 <donri> although not 100% sure -j1 gets you complete output anymore. try
15:45:57 <joelteon> it did
15:46:02 <donri> anyway use cabal build for your own work
15:46:02 <joelteon> -j1 showed me the output I was expecting
15:46:13 <monochrom> well, the thing is, when multiple jobs, then $HOME/.cabal/logs has stuff. works for me.
15:46:13 <donri> after cabal install --only-dependencies
15:46:19 <donri> ok
15:46:39 <piezoid> jrmithdobbs: what are you trying to do ? maybe you should use forms, or put the arguments in the route itself
15:46:48 <jrmithdobbs> piezoid: ok, seeing how this works now i think
15:47:00 <Rarrikins> jle`: I put the code up at http://forums.aichallenge.org/viewtopic.php?p=4611#p4611
15:47:01 <jrmithdobbs> piezoid: I'm, unfortunately, trying to mockup an exsting not-really-RESTful api
15:47:26 <jrmithdobbs> piezoid: the param in question should be PATH_INFO but i don't have that luxury
15:48:11 <jrmithdobbs> really wishing it wasn't a query param because the type checking of routes thing is one of the coolest parts of yesod ;p
15:53:22 <Guest71743> Provide a function myTail that behaves like Tail except that myTail returns no error for the empty list. Think about a useful return value. Follow the design recipe and implement myTail using Conditional expressions. Somebody an idea?
15:54:06 <Iceland_jack> Guest71743: Sure!
15:54:15 <Iceland_jack> But I'm not sure what to say without saying too much :)
15:54:31 <Guest71743> :$
15:54:31 <Iceland_jack> Any ideas yourself?
15:54:42 <simpson> Guest71743: What type should your function have?
15:55:14 <Iceland_jack> Guest71743: Essentially what you want is a way to indicate “I have an answer” (non-empty list) and “there is no answer” (empty list)?
15:55:21 <Guest71743> worked so long today, my head feels like its already shut down, but need to finish this today
15:55:40 <jle`> Rarrikins: thanks :)
15:56:14 <Rarrikins> jle`: No problem
15:56:42 <monochrom> Guest71743: where can I read "the design recipe"?
15:57:39 <monochrom> I am also not convinced that using condition expressions is a good idea.
15:57:47 <Guest71743> http://lpaste.net/95535
15:57:54 <monochrom> http://www.vex.net/~trebla/haskell/crossroad.xhtml
15:58:15 * ski . o O ( `yourTail :: [a] -> Either () (a,[a])' )
15:58:23 * hackagebot missing-py2 1.0.0 - Haskell interface to Python  http://hackage.haskell.org/package/missing-py2-1.0.0 (domdere)
15:59:19 * simpson . o O ( `wowSuchTail :: [a] -> Maybe a` )
15:59:29 <hulahoop> Sorry, I tried to make it work, but it's just not working.
16:00:22 <monochrom> I am also not convinced of the headings "contract" and "purpose". why are they not under the same heading and it is "contract"?
16:01:06 <Guest71743> because they're connect to different tasks :/
16:01:13 <monochrom> you will have to decide "think about a useful return value". if you want me to decide for you, just tell me, I'll be glad to.
16:01:33 <hulahoop> I am not good enough. I tried to calculate every suffix and prefix of a list by using  suffix/prefix :: [a] -> [[a]] and it just doesn't work.
16:01:34 <Guest71743> please, decide for me
16:01:37 <Iceland_jack> It won't be any use if Guest71743 doesn't actually know the type
16:01:41 <Iceland_jack> @src Maybe
16:01:41 <lambdabot> data Maybe a = Nothing | Just a
16:01:53 <monochrom> then the useful value is Nothing, which is what everyone says
16:01:54 <Iceland_jack> ↑ Guest71743: that should be enough
16:02:07 <monochrom> myTail :: [a] -> Maybe [a]
16:02:55 <ski> Guest71743 : instead of "the x and y values" you could say "the abscissas and ordinates"
16:02:59 <monochrom> if the list is non-empty, you use the "Just" thing. if the list is empty, you use Nothing.
16:03:14 <hulahoop> Sorry, but what is maybe? is it an individual function
16:03:16 <hulahoop> ?
16:03:28 <Iceland_jack> hulahoop: Maybe is a type constructor
16:03:29 <ski> > tails "hulahoop"
16:03:30 <lambdabot>   ["hulahoop","ulahoop","lahoop","ahoop","hoop","oop","op","p",""]
16:03:30 <monochrom> this may or may not be what your grader wants to see. but to hell with that, if the grader doesn't like it, he/she is wrong, we are right.
16:03:30 <Iceland_jack> maybe is a function
16:03:39 <ski> @type maybe
16:03:40 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:04:08 <Iceland_jack> maybe is also an adverb
16:04:38 <Guest71743> "Ambiguous occurrence `Maybe'     It could refer to either `Main.Maybe', defined at Ex02.hs:63:6                           or `Prelude.Maybe',                              imported from `Prelude' at Ex02.hs:1:1                              (and originally defined in `Data.Maybe')  Ex02.hs:61:16: Not in scope: `myTailCond'  Ex02.hs:71:14: Not in scope: `myTailCond'"
16:04:54 <dmj`> > maybe "No" (\_ -> "Yes") $ Just "huh?"
16:04:55 <lambdabot>   "Yes"
16:05:02 <dmj`> maybe "No" (\_ -> "Yes") Nothing
16:05:05 <Iceland_jack> Guest71743: Are you defining your own Maybe?
16:05:09 <ski> yes
16:05:56 <prooftechnique> Why is there a tails but no heads?
16:05:56 <dmj`> Guest71743: If you want to do that you need to hide the Prelude's version of Maybe, which is imported into every file by default.
16:06:11 <dmj`> import Prelude hiding (Maybe(..))
16:06:13 <Iceland_jack> prooftechnique: What would “heads” do?
16:06:14 <prooftechnique> Oh, wait, probably inits
16:06:18 <Iceland_jack> yes
16:06:20 <ski> @let heads :: [a] -> [a]; heads = id
16:06:22 <prooftechnique> Ah, there it is
16:06:22 <lambdabot>  Defined.
16:06:25 <dibblego> Iceland_jack: map return
16:06:31 <Iceland_jack> How very useful
16:06:40 <monochrom> "myTail = head [myTailCond, myTailGuard, myTailMatch]" is very saddening
16:07:08 <Cale> monochrom: Yeah, extremely weird.
16:07:23 <ski> monochrom : replacing `head' with something that unsafely used sources of random bits to select a member would be funnier ..
16:07:43 <ski> (or perhaps used `unamb' in some way)
16:08:00 <Cale> I guess it's a way of enforcing that all these things have the same type without actually having to say what that type is, but even then, it's quite bizarre.
16:08:16 <monochrom> I am a fan of randomly choosing an implementation detail, too
16:08:37 <monochrom> more accurately, randomly choosing during run time, yes, that's right.
16:08:41 <Guest71743> its just a normal haskell data where we get a document to and have to work on the exer., normally no problem but today my head is just dying
16:08:44 <schell> does anyone know John Goerzen?
16:09:14 <Iceland_jack> Guest71743: Did you look at the hints given above?
16:09:43 <Guest71743> yes, but i dont know how to declare data maybe
16:09:52 <Iceland_jack> It's a part of Prelude
16:09:55 <ski> you don't need to declare it, it's already in `Prelude'
16:10:01 <ski> you get it automatically
16:10:02 <Guest71743> if i use a crossroad at a brunch i got a bad report
16:10:08 <monochrom> Cale will object this, but I said in haskell-cafe I would really like nub and nubBy to have 3 different implementations (they behave the same if (==) is an equivalence relation, behave different if not), and, yes, during run time, randomly choose one. to frustrate people who use nub with a random relation, yes.
16:10:08 <Guest71743> oh
16:10:28 <Cale> heh
16:10:45 <Iceland_jack> > Just [1,2,3,4]
16:10:46 <lambdabot>   Just [1,2,3,4]
16:10:47 <Iceland_jack> > Nothing
16:10:49 <lambdabot>   Nothing
16:10:57 <Guest71743> how i am doing this? didnt had this in lesson yet
16:11:14 <Cale> I think nubBy should be specified more precisely (to do the thing which the Report implementation presently does), so that it shouldn't matter that you give it an equivalence relation.
16:11:22 <Cale> any relation would then do
16:11:50 <Rarrikins> I wish there was an equating that corresponded to comparing.
16:12:01 <ski> @type equating
16:12:02 <lambdabot> Eq b => (a -> b) -> a -> a -> Bool
16:12:08 <Rarrikins> @hoogle equating
16:12:08 <lambdabot> No results found
16:12:11 <Cale> "equating" as a word doesn't really mean the right thing though
16:12:29 <Cale> It normally means "forcing to be equal"
16:12:40 <Iceland_jack> Guest71743: The solution using “Maybe” is pretty much the standard solution, I find it odd that you are assigned something like that without Maybe having been tought at all
16:12:57 <Rarrikins> What module is equating in?
16:13:05 <Rarrikins> Cale: That's true.
16:13:14 <Rarrikins> Hmm
16:13:41 <ski> <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f
16:13:47 <ski> (about four hours ago)
16:13:52 <Rarrikins> Oh :)
16:14:36 <chrisdone> @dict equate
16:14:36 <lambdabot> There is no dictionary database 'equate'.
16:14:44 <Rarrikins> I can't think of a good name for it.
16:14:46 <ski> hm, yea, we'd need the "complement" of the quotient object
16:14:56 <ski> @wn equate
16:14:57 <lambdabot> *** "equate" wn "WordNet (r) 3.0 (2006)"
16:14:58 <lambdabot> equate
16:15:00 <lambdabot>     v 1: consider or describe as similar, equal, or analogous; "We
16:15:02 <Rarrikins> eqComparing
16:15:02 <lambdabot>          can compare the Han dynasty to the Romans"; "You cannot
16:15:05 <lambdabot>          equate success in financial matters with greed" [syn:
16:15:07 <lambdabot> [7 @more lines]
16:15:38 <ski> ("mplement" ?)
16:16:32 <jrmithdobbs> piezoid: got what I needed working, thanks
16:16:36 <chrisdone> seems like a limitation of english
16:16:54 <chrisdone> english only has 'comparing', there's no word i can think of like 'comparing for specific kind of equality'
16:17:35 <Cale> ski: equalisers and coequalisers *are* dual after all :)
16:17:47 <Guest71743> no, not working :(
16:18:30 <Rarrikins> I think a modification to comparing would work.
16:18:46 <Cale> Rarrikins: what modification?
16:18:55 <Rarrikins> Just calling it like eqComparing
16:19:01 <Cale> oh, sure
16:20:33 <benmachine> we could call "comparing" "orderingBy"
16:20:45 <benmachine> and correspondingly use comparingBy for the Eq version
16:20:55 <benmachine> no that's rubbish
16:21:00 <chrisdone> but `compare' ruins that
16:21:05 <benmachine> english, you are rubbish, be less rubbish
16:21:16 <ski> `ignoringEverythingElseBut'
16:21:20 <benmachine> I think I'd say go with equating even though it's english-wise wrong
16:21:30 <geekosaur> it's english, it can't help being rubbish
16:21:40 <chrisdone> it's english, let's go borrowing!
16:21:46 <benmachine> :P
16:21:50 <chrisdone> hey german, you got any words for "comparing for equality"?
16:21:51 <Cale> I suppose we could do...  class Comparing t where type ComparisonC t :: * -> Constraint; comparing :: (ComparisonC t a) => (a -> t) -> a -> a -> t
16:22:11 <chrisdone> Cale: true…
16:22:13 <benmachine> Cale: here, have an overengineer's hat
16:22:19 <Cale> :D
16:24:49 <hulahoop> it's me again, sorry.
16:24:59 <Cale> er, no, that's not quite what we want
16:25:30 <Cale> class Comparing t where
16:25:30 <Cale>   type ComparisonC t :: * -> Constraint
16:25:30 <Cale>   comparing :: (ComparisonC t b) => (a -> b) -> a -> a -> t
16:25:34 <Cale> there, that's right ;)
16:25:44 <Cale> ghci> comparing fst (3,5) (4,6) :: Bool
16:25:44 <Cale> False
16:25:44 <Cale> ghci> comparing fst (3,5) (4,6) :: Ordering
16:25:44 <Cale> LT
16:26:23 <hulahoop> So i tried using maybe in an editor, but hugs, the compiler I must use,  doesn't play along. Is it because it's old or something ?
16:26:28 <Cale>      wow       such polymorphism     many type
16:26:47 <Rarrikins> :)
16:26:51 <Cale> hulahoop: Perhaps you could tell us what message you're getting?
16:28:31 <Cale> hulahoop: Maybe is about as old as Haskell itself, so despite Hugs being super ridiculously outdated, it's not *that* outdated.
16:28:44 <Cale> (actually, it's older)
16:29:37 <Cale> hulahoop: If you need a place to put your code so that we can see, use lpaste.net
16:32:03 <khyperia> haha, Cale
16:32:28 <khyperia> the wow thing
16:33:06 <Cale> khyperia: :)
16:39:12 <tarruda> can someone tell whats wrong with this simple binary search tree: http://lpaste.net/95539 ?
16:39:40 <tarruda> I cant figure out what I'm doing wrong
16:40:47 <pavonia> define "wrong"
16:41:04 <tarruda> I keep getting a deadlock when I try to show a tree after the second insert
16:41:06 <tarruda> eg:
16:41:15 <tarruda> let bst = set Nil 1 "one"
16:41:23 <tarruda> let bst = set bst 2 "two"
16:41:26 <tarruda> show bst
16:42:11 <tarruda> ghci never returns from 'show bst'
16:42:24 <triliyn> tarruda: redefining the same name isn't generally allowed, so it's probably not set up to interpret that in the way you mean
16:42:58 <geekosaur> the second let bst hides the first. and the bst on the right side of its = is the same as on the left
16:43:04 <geekosaur> which is to say, infinitely recursive definition
16:43:10 <tarruda> I see
16:43:22 <tarruda> well, how do I insert more than one element then?
16:43:33 <tarruda> how do I produce a tree with many elements
16:43:35 <monochrom> use different variable names. as simple as that.
16:43:36 <Rarrikins> You can make a thing that inserts a list.
16:43:42 <Rarrikins> Or that :)
16:43:45 <monochrom> let bst1 = set bst0 2 "two"
16:44:05 <geekosaur> ghci or ghc, it's still haskell. bst is not a variable, you are not updating its value
16:44:17 <tarruda> ok
16:44:40 <tarruda> this is being hard for me to grasp
16:44:53 <monochrom> Rarrikins: if this "variable name clash" issue is not understood, an attempt at coding up inserting a list will simply preserve the issue
16:45:02 <Rarrikins> monochrom: Ahh, good point.
16:46:00 <monochrom> actually, maybe not, there is a bit of luck factor in what approach is chosen, one approach won't have the issue :)
16:47:04 <monochrom> at a meta level, I don't know whether the word "variable" is a blessing or a curse
16:47:44 <Rarrikins> tarruda: Just remember that you're not allowed to change any variables yourself. It's against the rules. You can only set them once. So, one way is to use more than one variable.
16:48:36 <tarruda> I've read about that, I just still cant see how one can implement a hashtable or bst without changing data
16:48:40 * hackagebot missing-py2 1.0.1 - Haskell interface to Python  http://hackage.haskell.org/package/missing-py2-1.0.1 (domdere)
16:48:45 <Rarrikins> tarruda: Well, you can change data.
16:48:57 <Rarrikins> tarruda: You can produce new values from old ones.
16:49:12 <Rarrikins> tarruda: Like 143 + 1 takes 143 and gives 144.
16:49:13 <monochrom> hashtable needs changing data yes, that's baked into the definition of "hashtable". bst doesn't need it.
16:49:42 <Rarrikins> tarruda: Adding something to a hashtable takes the old hashtable and gives you a new one.
16:50:02 <Rarrikins> tarruda: Even your set function takes a tree and gives you a new one.
16:50:05 <tarruda> Are you saying that everytime I insert something in a tree it will copy the entire tree so that the old one isnt modified?
16:50:20 <Rarrikins> tarruda: Yes, though it uses tricks to avoid using a lot of memory.
16:50:35 <Rarrikins> tarruda: But that's pretty much how it works.
16:50:38 <dmj`> Rarrikins: where can we read about these tricks?
16:50:47 <tarruda> I'd love to read about them too
16:51:06 <Rarrikins> dmj`: I don't know. I think there's probably deforestation RULES and other things.
16:51:22 <Rarrikins> I'm not too informed on the compiler stuff.
16:52:19 <monochrom> I don't know if you can call it a trick, or you should call it "by definition". look, you just did it yourself, "let bst1 = set bst0 whatever". does it copy bst0? or can it simply reuse bst0? it is not like bst0 will change in the future.
16:52:22 <schell> anyone have an idea on how to port this to use mkTyCon3 instead of myTyCon?
16:52:24 <schell> mkTypeName name = mkTyConApp (mkTyCon name) []
16:52:32 <jmcarthur> purely functional data structures are usually designed to share as much with the older version as possible when updating
16:52:52 <Rarrikins> monochrom: I mean trick more in the sense of diverging from the programmer's model.
16:53:00 <jmcarthur> no trick there either
16:53:15 <Rarrikins> jmcarthur: Yeah, that's true.
16:53:18 <monochrom> well, ok, but the programmer should fix his/her model
16:53:22 <Rarrikins> jmcarthur: That's a good point.
16:53:24 <jmcarthur> since when does making a new linked list node pointing to an existing one in C copy the one you are pointing to?
16:53:29 <jmcarthur> :)
16:53:52 <jmcarthur> (singly linked, at least)
16:54:00 <schell> without changing `mkTypeName`?
16:54:15 <Rarrikins> I wonder if it can optimize insertions.
16:54:29 <Rarrikins> If it's not going to be using the old version.
16:54:42 <hulahoop> http://lpaste.net/95538 okay. Even though  I am not leaping, I hope at least that I am doing the right steps
16:55:14 <tarruda> ghc must really be a piece of art if it can abstract computer memory in such a high level and still be efficient as other imperative languages
16:57:11 <monochrom> there are two parts, and people keep mixing them up. 1. if the code literally asks for reuse, does reuse happen, and is that magic?  2. if the code doesn't literally ask for reuse, but after a powerful static analysis you find that there can be reuse, does it happen, and is that magic?
16:57:51 <monochrom> I am fine with "if it needs powerful static analysis, you can call it magic", but ghc doesn't do that yet.
16:58:38 <Cale> hulahoop: I don't know how you ended up with what you did there...
16:58:54 <Cale> hulahoop: That looks like a mangled version of the definition of the Maybe type
16:59:00 <Cale> data Maybe a = Nothing | Just a
16:59:10 <Cale> (but you don't have to write that, it's in the Prelude)
16:59:17 <hulahoop> I don't either. I am not a clever guy
16:59:20 <monochrom> but right now, "tree1 = Node key value tree0 tree0", you literally ask for tree0 to be reused. and so tree0 is reused. how is that magic?
16:59:55 <Cale> hulahoop: What do you intend maymaybe to do?
17:01:09 <Cale> hulahoop: Based on the type signature, maymaybe is meant to take a list as an argument, so you might want to pattern match on that:
17:01:16 <Cale> maymaybe [] = ...
17:01:17 <tarruda> monochrom: I wasnt considering the lazy evaluation
17:01:20 <Cale> maymaybe (x:xs) = ...
17:01:43 <tarruda> monochrom: In my mind the right side was being evaluated and then assigned to the left side
17:01:50 <monochrom> this is not due to lazy evaluation. SML is eager. when you say "tree1 = Node key value tree0 tree0" in SML, you get the same reuse.
17:02:01 <Cale> and it's supposed to produce something of type Maybe [a], which means in each case, it'll either produce Nothing, or it will produce Just ys for some list ys
17:02:24 <tarruda> what is SML?
17:02:34 <monochrom> a programming language
17:02:35 <carter> standard ml
17:02:37 <alkabetz> Standard ML, another functional programming language
17:02:49 <monochrom> do you trust me?
17:03:21 <monochrom> when I say, "this is not due to laziness. the reuse happens the same in this other eager language", do you trust me?
17:04:17 <tarruda> Its not a matter of trust, I just dont understand. If the right side is evaluated eargely, how can it enter an infinite loop when I try to evaluate the left side?
17:04:44 <monochrom> what loop? it's tree0, not tree1, on the right side
17:05:15 <tarruda> Ok if using different names then yes, I accept that it will have the same result no matter when they are evaluated
17:05:47 <carter> schell: whats convertible ?
17:05:59 * monochrom frowns. since when did I use not different names?
17:06:25 <schell> convertible is a lib that i'm guessing helps with Typeable derivation
17:06:34 <triliyn> monochrom: I think tarruda was thinking of his previous problem, where he did use the same name at one point
17:06:36 <tarruda> monochrom: sorry I tought you were arguing about my first example, where I used the same name in both sides
17:06:44 <tarruda> and still didnt understood the result
17:06:52 <triliyn> <tarruda> let bst = set Nil 1 "one"
17:06:52 <triliyn> <tarruda> let bst = set bst 2 "two"
17:06:52 <triliyn> <tarruda> show bst
17:06:55 <schell> but it uses mkTyCon, which has been deprecated and is no longer available in ghc-7.7+
17:07:02 <carter> schell: so don't use it
17:07:03 <carter> :)
17:07:06 <carter> or fix it
17:07:06 <tarruda> yes
17:07:15 <tarruda> that was what troubled me
17:07:21 <monochrom> <monochrom> but right now, "tree1 = Node key value tree0 tree0", you literally ask for tree0 to be reused. and so tree0 is reused. how is that magic?
17:07:22 <tarruda> I didnt consider haskell's lazy evaluation
17:07:31 <monochrom> where is "bst" in that sentence?
17:07:43 <schell> i'm trying to submit a patch but i have no familiarity with mkTyCon or what convertible is used for
17:07:57 <carter> schell: then why are you using it?
17:08:09 <schell> i'm not - ghcmod uses it
17:08:11 <monochrom> I'm sorry I get very mad when people misinterpret what I say
17:08:23 <schell> which is part of my dev environment
17:08:38 <schell> ghcmod-vim
17:09:45 <tarruda> monochrom: What I considered black magic was not your example, but the way haskell uses lazy evaluation to "copy" big data structures and still be efficient as other languages that let the programmer do direct memory manipulation
17:10:08 <schell> i'm just trying to port from mkTyCon to mkTyCon3
17:10:13 <schell> never used either
17:10:21 <monochrom> there is no copy
17:10:32 <amalloy> tarruda: it doesn't copy anything, it just makes another reference to the existing data
17:10:46 <amalloy> that's really more closely related to immutability than lazy evaluation
17:10:48 <hulahoop> I am just trying to make maymaybe a function that connects to the suffix and prefixes, so that this happens: I want a list that has the suffixes calculated and has the prefixes empty. Then I want a list that has every prefixes of a list calculated, while the suffixes are listed as empty. One Start, two ways I can choose from . Sorry, I am only thinking about sleep.
17:11:06 <tarruda> ok
17:11:11 <monochrom> but you are right to say, "x = f x" requires lazy evaluation
17:11:37 <monochrom> but there is still no copy in "x = f x"
17:11:48 <augur> ski: so uniplate = lens, more or less
17:12:11 <augur> for only one data type at a time
17:13:05 <carter> schell: file a bug report ans ask for help
17:13:29 <schell> carter: i sent an email to the maintainer a week ago
17:13:38 <schell> i doubt he's still the maintainer
17:13:42 <carter> for which?
17:13:50 <carter> schell: 1 week isn't tha tlong
17:14:01 <schell> it looks like there's another maintainer on github
17:14:05 <carter> for which?
17:14:09 <schell> but he's never uploaded a package
17:14:12 <schell> for convertible
17:14:21 <carter> i've never heard of convertible
17:14:27 <carter> schell: lets zoom out
17:14:28 <schell> https://github.com/hdbc/convertible
17:14:30 <carter> what do you need it for
17:14:34 <schell> ghcmod
17:14:53 <carter> ok
17:14:56 <carter> lets focus on t
17:14:58 <carter> hat
17:15:03 <carter> how does ghc-mod use convertible?
17:16:38 <ReinH> Luke: thanks!
17:17:42 <carter> schell: because heres the thing: any patch needs to be one that works on both ghc 7.6 and head
17:17:58 <schell> right
17:18:01 <carter> i helped patch ghc-mod for 7.6 along with dysinger many moons ago
17:18:11 <monochrom> yikes, that sounds like a tall order
17:18:41 <dmj`> Hey guys, I'm trying to install conduit on Windows, but getting a strange error.
17:18:42 <dmj`> Win32File.hsc:32:19: fatal error: Share.h: No such file or directory
17:18:52 <dmj`> when doing cabal install conduit-1.0.9
17:20:21 <dmj`> any idears
17:21:21 <schell> well, convertible uses mkTyCon in mkTypeName and ghcmod doesn't seem to use that
17:21:29 <monochrom> hmm, who asked with http://lpaste.net/95538 ?
17:21:34 <schell> the only reference (according to github search) is https://github.com/kazu-yamamoto/ghc-mod/blob/d58c11bcc3c0536d1f52edf6f04cb83094e023b9/Language/Haskell/GhcMod/Gap.hs#L68
17:22:02 <fl00r> yep...the import is wrapped in #if __GLASGOW_HASKELL__ < 706
17:22:14 <schell> carter: which looks like that means it's for ghc 7.6?
17:22:24 <carter> for < 7.6?
17:22:33 <carter> or = 7.6
17:22:45 <monochrom> ah, hulahoop: you have to answer these two questions: 1. suffixes [] = ?  2. suffixes (x:xs) = ?  in the second question, you may use recursion.
17:22:46 <carter> ok
17:22:54 <schell> <
17:22:55 <fl00r> and then convert (i'm guessing part of that package) is called on L84
17:22:58 <carter> schell: soooo, it shouldn't be building it ;)
17:23:01 <carter> schell: file a bug report :)
17:23:12 <carter> saying that on 7.7 it tries to build it
17:23:14 <schell> so maybe we just need a different...cabal dependency listing?
17:23:18 <carter> yes
17:23:23 <monochrom> prefixes is a bit harder.
17:23:49 <carter> schell: file a report on ghc-mod
17:23:59 <carter> it shouldn't pickup the convertible dep
17:24:02 <carter> is what you're saying
17:24:11 <schell> right, got it
17:24:24 <carter> your quick fix could jsut be deleting that line from .cabal :)
17:24:27 <carter> and testing that things owkr
17:24:32 <carter> report it to kazu :)
17:24:40 <carter> schell: see how this is a better bug fix?
17:24:46 <carter> you get something working now
17:24:53 <carter> and the lib that you care about finds out if thing work as is
17:25:01 <carter> there maybe some other breakages you need to deal with
17:25:06 <carter> because ghc API's change :)
17:25:14 <schell> yeah, totally
17:25:39 <schell> thanks
17:26:01 <jle`> anyone want to help me review my first ever baby haskell article...it's probably atrocious and long-winded and doesn't contribute anything, but i just felt like maybe trying to contribute :)
17:26:05 <jle`> (is this welcome here)
17:26:18 <monochrom> it is welcome. but I fear long articles.
17:26:29 <jle`> http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
17:26:46 <monochrom> good title
17:26:58 <jle`> any ideas on what i could cut out and what i could add/ajust to make it actually useful/contribute somehow
17:27:00 <jle`> thanks :)
17:31:15 <asmyers> jle`: How does this follow from the IO discussion? "It is also apparent that any “true” pure, functional language is necessarily lazy, which implies that there is no inherent ordering in your statements."
17:32:15 <monochrom> that is a true statement. if you replace "true" by "practical". a practical pure language needs laziness.
17:32:25 <jle`> asmyers: hm.  amittedly while i was writing it, it seemed more "obvious".
17:32:36 <dibblego> is there something like LANGUAGE OverloadedDo extension?
17:32:36 <monochrom> or more advanced technology than laziness
17:32:57 <Cale> It needs some implementation of non-strict semantics
17:34:01 <jle`> asmyers: i will try to rethink my thought process and lay it down more clearly/qualify the statement.  if i can't, the statement might be an unecessary one
17:34:12 <tomejaguar> A practical pure languange needs a way of delaying evaluation.  But practical language needs that anyway.
17:35:46 <jle`> it should be, a pure language that 'works' by purely generating an io object/instruction set must be lazy
17:35:58 <jle`> but that is not the only way to structure a pure language admittedly
17:36:50 <tomejaguar> Not really, the "IO object/instruction set" needs to be lazily evaluated, but that can still be done in a strict-by-default-language
17:37:29 <jle`> tomejaguar: hm.  as in, the IO object may be evaluate strictly?
17:37:32 <jle`> *evaluated
17:37:39 <jle`> that makes sense
17:37:48 <jle`> as long as those strict evaluations do not produce side-effects
17:37:51 <jle`> right?
17:38:04 <tomejaguar> I don't think that's what I meant.
17:38:10 <Cale> Well, bind can be strict because even strict languages are usually not so strict that they'll evaluate underneath lambdas
17:38:42 <tomejaguar> Imagine OCaml, where every IO effecting function of type 'a -> b' has its type signature replaced by 'a -> IO b'
17:38:56 <tomejaguar> You also have to make sure that 'let x = action' works
17:39:01 <tomejaguar> where 'action :: IO a'
17:39:14 <tomejaguar> The latter is why I say that the IO must be lazily evaluated
17:39:23 <tomejaguar> but I don't think there's any problem with that recipe.
17:39:48 <Cale> Well, the issue of the order of evaluation is fairly well separated from the issue of whether the execution of I/O actions is separate from the evaluation of expressions.
17:39:49 <jle`> are you saying that the IO is lazily evaluated, but the lambdas/structure itself is not necessarily lazily constructed?
17:41:07 <jle`> in any case it is clear that my statement "pure languages must be lazy" is somewhat overly strong and even the reasons for my saying it in the first place are clearly misguided
17:41:08 <Cale> However, if you're using lazy evaluation (or basically any other implementation of non-strict semantics), it doesn't make much sense to allow I/O to occur inside of expression evaluation.
17:41:11 <tomejaguar> I mean that IO could be implemented something like 'data IO a = IO (() -> a)' in a strict Haskell
17:41:47 <tomejaguar> jle`: The reason that SPJ has given for laziness being so closely tied to purity is that if your evaluation is strict it is simply *too tempting* to allow side effects.
17:42:07 <Cale> Originally, sure
17:42:12 <tomejaguar> And you can't be tempted into that in the lazy setting, as order of evaluation is distant from order of side effects
17:42:26 <Cale> But now, I'd argue that even strict functional languages would do well to have an IO monad :)
17:42:35 <tomejaguar> Oh absolutely!
17:42:47 <tomejaguar> I'm pretty sure what I just said is an implementation of one :)
17:42:52 <Cale> (and not allow effects during expression evaluation)
17:43:00 <tomejaguar> Agreed
17:43:04 <Cale> (which would disallow your implementation of IO)
17:43:08 <tomejaguar> How so?
17:43:43 <Hodapp> this "Total Functional Programming" paper makes some interesting points, but the author seems to create a system which is stricter than what Haskell allows, but weaker than a dependently typed system, and one which still keeps the proof and the program separate (although it makes the proof similar)... I wonder what the goal was
17:43:54 <Hodapp> s/similar/simpler/
17:44:24 <Cale> tomejaguar: Because functions () -> a wouldn't be able to express enough information about what effects should occur
17:44:52 <tomejaguar> Oh I think I'm conflating two points
17:45:01 <Cale> tomejaguar: (of course, GHC internally uses something quite similar-looking to that, but it cheats badly)
17:45:10 <Hodapp> but he does make an interesting point: if you have only total functions, then strict and lazy are identical (from a correctness perspective)
17:45:26 <Hodapp> though he didn't mention anything about runtime complexity there
17:45:33 <tomejaguar> What I wrote won't work if (->) is already pure.  But if it's impure and you want to wrap all IO effects then it will work.
17:45:55 <tomejaguar> Basically you could have a pure wrapper on an impure language, if you were willing to wrap every impure function!
17:46:03 <jle`> thank you for the comments guys
17:46:28 <tomejaguar> Hodapp: They're identital denotationally, because the only difference anyway can be _|_
17:47:02 <tomejaguar> Hodapp: the runtime can be significantly difference, as can the space usage (lazy is always at least as good as strict when it comes to run time)
17:48:01 <Hodapp> tomejaguar: I was thinking about how the runtime could be different to a basically unbounded degree
17:48:29 <tomejaguar> Well it's bounded by the run time of the strict version ;(
17:48:30 <hulahoop> I give up, good night.
17:48:35 <tomejaguar> I mean ;)
17:49:38 <monochrom> sleep deprivation is the enemy of learning
17:50:08 <Saizan> so true
17:50:15 <Hodapp> tomejaguar: but the author does also make an interesting point: if you have an algorithm (presumably a pure one) for which you have a correct worst-case complexity computed, you can turn this into a total function by rewriting it with an iteration limit
17:50:43 <tomejaguar> If you have a worst-case complexity isn't it already total?!
17:51:41 <Hodapp> tomejaguar: well, he's using a more constrained form of total, I believe, in terms of what recursion is permitted
17:51:43 <monochrom> yes, unless "infinity" is a valid complexity :)
17:52:36 * monochrom is happy to say "the complexity of proving programs correct is infinity"
17:53:11 <Hodapp> tomejaguar: in that he gives some guidelines that are guaranteed to produce total functions, but plenty of functions that sit outside of these guidelines still are total.
17:53:31 * monochrom should be careful with that wording, actually. after all, the complexity of proving correct programs correct is O(1) :)
17:54:35 <monochrom> err, O(n)!
17:54:46 <Hodapp> monochrom: 'n' is what here?
17:54:51 <Hodapp> program size?
17:55:28 <monochrom> yes. I'm thinking we should at least read the program in entirety, just to be polite :)
17:56:16 <Hodapp> monochrom: But what if the program *is* correct, and you simply lack the proof of it?
17:56:53 <monochrom> oh, I see, yeah that's a problem. I should just use the decision problem version.
17:57:18 <monochrom> "the complexity of deciding program correctness" is pretty good wording
18:00:40 <Hodapp> monochrom: I don't see how that helps you :P
18:01:31 <moops> every program is correct
18:01:34 <moops> for some problem
18:01:49 <moops> O(1)
18:02:27 <monochrom> no no moops, the unsaid specification is that the input is both a program and a property to check the program against
18:02:43 <moops> so its about the equivalence of the program and a function
18:02:55 <monochrom> not all properties are like that
18:03:11 <moops> so
18:06:42 <schell> where can i find docs for the ghc-7.7.x GHC API?
18:07:34 <jle`> hm. is there any haskell compiler that compiles an IO object into human-readable instructions, like a recipe/grocery list?
18:08:33 <jle`> although i guess things would be too detailed/complex to be useful/followable by a human
18:08:40 <monochrom> no. the do-block you write is more readable than anything GHC produces
18:09:10 <jle`> because i imagine even things like getLine are composed of many applications of primitives
18:10:14 <flebron> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-IO-Handle-Text.html#hGetLine
18:11:27 <jle`> although
18:11:38 <jle`> maybe i could write a Recipe/Instruction List monad
18:11:47 <jle`> a recipe monad
18:11:58 <jle`> that can be run to produce a markdown recipe or something
18:12:09 <jle`> or a book
18:12:12 <jle`> yes that will be my new life goal
18:12:31 <frx> and replace IO Monad with your own? is that possible?
18:12:46 <jle`> no not an IO monad any more than State or Blaze's HTML
18:13:13 <jle`> i just wanted to find an excercise to emphasize the entire io-monad-is-just-instruction-list thing
18:13:32 <jle`> i could maybe write a Baking monad that componses instructions to bake a cake or other pastry
18:13:40 <Rarrikins> It's more like a tree, since you can have branches.
18:13:40 <Hodapp> BURRITO!
18:13:53 <Rarrikins> Or a graph, since you can have loops.
18:14:02 <jle`> and provide a runBaking :: Baking a -> a
18:14:07 <jle`> that generates human-readable recipes
18:14:42 <jle`> er, runBaking :: Baking a -> String technically
18:15:02 <jle`> basically some state monad
18:15:16 <tomejaguar> jle`: You probably want to look into free monads.
18:15:54 <jle`> tomejaguar: thanks, i'll look into it
18:17:32 <madariaga> http://lpaste.net/95545
18:18:39 <madariaga> I'm using that rget function to run some redis commands and return the string in the reader mt
18:19:19 <madariaga> it works, but I'm not sure about the notation, or if this is a common pattern
18:36:40 <hkarim> Is it possible to generate bitcode using 'ghc -fllvm'?
18:38:34 <dainanaki> Can anyone give me any insight into this issue? http://stackoverflow.com/questions/19917285/ghc-generics-behavior-seems-to-differ-in-ghci
18:38:49 <dainanaki> I'm really curious what I'm missing.
18:44:38 <enthropy> dainanaki: make the f :*: fs pattern match lazy?
18:45:52 <dainanaki> hmm, how so?
18:46:06 <enthropy> one option: gfields ~(f :*: fs) = gfields f ++ gfields fs
18:46:09 <enthropy> this works for me
18:46:32 <enthropy> pretty much when you have an undefined, it doesn't make the :*: constructor defined
18:46:49 <dainanaki> hmm
18:46:50 <enthropy> but selName is lazy apparently
18:47:06 <enthropy> I mean you can pass it an undefined and it will happily give you a string
18:47:32 <khyperia> If I want to attach type metadata (or other metadata) to an AST, how would I do that? Create a separate type with the data as new fields, or create a massive (Map AST Metadata), or what?
18:47:46 <dainanaki> I've never really grokked the lazy pattern operator squiggle thing
18:47:51 <enthropy> another option is to use -XScopedTypeVariables, and then have    gfields _ = gfields (undefined :: f) ++ gfields (undefined :: fs)
18:48:33 <khyperia> Possibly attach a list to the end of every AST type with whatever metadata I want?
18:50:23 <khyperia> I feel like I should learn lenses or something, they're probably built for exactly this.
18:51:04 <edwardk_> khyperia: http://comonad.com/reader/2009/incremental-folds/ describes one system
18:51:04 <dainanaki> enthropy: thanks for the help. That's the first time I've really encountered a need for ~
18:51:16 <enthropy> well you can get by without it there
18:51:18 <alkabetz> khyperia: You might also look at http://blog.ezyang.com/2013/05/the-ast-typing-problem/
18:51:37 <khyperia> Oh, neat, thanks
18:56:30 <khyperia> I feel like "Explicit Typing + Nullable field", names from that blog, is the way I'm going to go. Also, I'm too noobish a haskeller to understand that, edwardk_, sorry, lol
18:59:55 <ski> @where DecoratingStructures
18:59:55 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
19:00:00 <ski> khyperia ^
19:00:43 <ski> @where IndirectComposite
19:00:44 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
19:00:45 <ski> is related
19:02:25 <khyperia> "The machine that serves this file is down. We're working on it." heh
19:04:18 * hackagebot itanium-abi 0.1.0.0 - An implementation of name mangling/demangling for the Itanium ABI  http://hackage.haskell.org/package/itanium-abi-0.1.0.0 (TristanRavitch)
19:04:20 * hackagebot llvm-base-types 0.3.0 - The base types for a mostly pure Haskell LLVM analysis library  http://hackage.haskell.org/package/llvm-base-types-0.3.0 (TristanRavitch)
19:04:20 <ski> hm, worked earlier today
19:10:39 <ryantrinkle> what is the part of the type after the => actually called?
19:13:14 <dmwit> ryantrinkle: Hm, I'm not sure I've heard a name for that.
19:13:33 <ryantrinkle> dmwit: yeah, it's funny :P
19:13:45 <ryantrinkle> i'm pretty sure i haven't either
19:17:28 <td123> ryantrinkle: you mean like isequal :: Eq a => a -> a -> Bool
19:17:51 <ryantrinkle> i'm just wondering what the name for the "a -> a -> Bool" part of that is
19:18:11 <ryantrinkle> the part before is called the context, i think
19:18:45 <td123> I would call Eq a the class constraints
19:19:11 <td123> and the right side the type signature
19:19:14 <fryguybob> ryantrinkle: It looks like the report calls that the type, I'm not sure if it is consistent about that though.
19:19:21 <td123> not sure if those are the official terms though
19:19:33 <ryantrinkle> fryguybob: well, that raises the question: what do i call the whole thing, then :P
19:20:03 <dmwit> Depending on the audience, you might call "a -> a -> Bool" an open, monomorphic type.
19:20:09 <fryguybob> ryantrinkle: A type signature :D
19:20:27 <ryantrinkle> fryguybob: lol, no, just the part *after* the ::
19:20:29 <dmwit> Call the whole thing a type scheme or a closed type.
19:20:49 <ryantrinkle> dmwit: haha yeah, that makes sense
19:20:55 <dmwit> On second thought, this may be bad advice.
19:20:57 <ryantrinkle> unfortunately, i'm targeting relative beginners
19:21:10 <dmwit> Since probably the types are not actually closed, what with type constants and all.
19:21:20 <ryantrinkle> ah, yes
19:21:40 <dmwit> Why not call them head and body?
19:21:47 <dmwit> head => body
19:22:16 <dmwit> Or something like that. Nonstandard terminology is okay as long as you define it up front. =)
19:22:45 <ryantrinkle> yeah
19:22:57 <ryantrinkle> maybe i should call it the "quantifyee", lol
19:23:02 <ryantrinkle> that would really roll off the tongue
19:23:26 <ryantrinkle> or would it be 'quantifiee'
19:23:35 <dmwit> yikes
19:23:39 <ryantrinkle> lol
19:23:47 <Cale> Quantificand
19:24:06 <ryantrinkle> haha yeah, that sounds way better
19:25:58 <dmwit> Is it really necessary to distinguish these parts of the type?
19:32:37 <ski> dmwit : also method signatures in classes
19:33:56 <jack> hello
19:34:05 <ski> hello yourself
19:34:16 <jack> why am I getting error in here?  instance Num [Char] where
19:34:37 <Guest71189> "Illegal instance declaration for `Num [Char]'(All instance types must be of the form (T a1 ... an) where a1 ... an are *distinct type variables*, and each type variable appears at most once in the instance head."
19:34:49 <ryantrinkle> dmwit: no, i wouldn't say it's *necessary*
19:34:56 <ryantrinkle> i'm just trying to sort out how to explain =>
19:35:12 <ski> jack` : because `[Char]', which is really syntactic sugar for `[] Char', isn't a of the form : type constructor applied to distinct type variables
19:35:18 <geekosaur> the reason is even in asterisks
19:35:18 <ryantrinkle> and i was hoping to point at the slide and say "the part before the => is the X, and the part after it is the Y"
19:35:23 <geekosaur> Char is not a type variabl;e
19:36:09 <ski> ryantrinkle : in some papers "monotype" and "polytype" are used
19:37:05 <ryantrinkle> i think the real issue might be that, technically, you can use as many quantifiers as you like
19:37:06 <ski> jack` : it's hard to say something more intelligent here, without knowing what you're *really* attempting to do here ..
19:37:33 <ryantrinkle> so i'm really talking about a false dichotomy: you could write any type on the rhs of the =>
19:37:39 <ryantrinkle> hence, no distinct name for that
19:37:56 <ryantrinkle> anyway, no big deal
19:38:01 <geekosaur> (also, trying to make that kind of Num instance is a really bad smell)
19:38:01 <ski> ryantrinkle : is that really true in Haskell with no extensions ?
19:38:16 <ryantrinkle> ski: hm, i'm not actually sure about that
19:38:36 <jack`> I want to make "4" + "3" work for fun and practice. I still don't really get why above didn't work. I guess I don't know what a type variable is
19:38:41 <ryantrinkle> anyway, thanks for the suggestions guys; i've gotta head out :)
19:39:23 * hackagebot llvm-data-interop 0.3.0 - A low-level data interoperability binding for LLVM  http://hackage.haskell.org/package/llvm-data-interop-0.3.0 (TristanRavitch)
19:39:25 <ski> jack` : "work" how ?
19:40:01 <jack`> by returning "7"  :D
19:40:26 <ski> how about `"4" + "oops !"' ?
19:40:54 <jack`> error or "error" are both reasonable options
19:41:31 <ski> if you really want it, go for `{-# LANGUAGE FlexibleInstances #-}'
19:41:46 <ski> but this isn't really a sensible thing to attempt to do, imho
19:41:50 <jack`> I know, I just wanted to understand the error
19:42:07 <geekosaur> types start with uppercase letters. type variables start with lowercase
19:42:30 <geekosaur> a type variable is a placeholder for a type that will be provided later
19:43:04 <ski> @type take
19:43:05 <lambdabot> Int -> [a] -> [a]
19:43:15 <ski> @type take :: Int -> [Integer] -> [Integer]
19:43:16 <lambdabot> Int -> [Integer] -> [Integer]
19:43:23 <ski> @type take :: Int -> String -> String
19:43:23 <geekosaur> you don't normally provide a specific instance for a parameterized type ([] Char in this case), but for something like [] a (more commonly known as [a])
19:43:24 <lambdabot> Int -> String -> String
19:43:44 <ski> @type take :: Int -> [(String,Double -> Double)] -> [(String,Double -> Double)]
19:43:45 <lambdabot> Int -> [(String, Double -> Double)] -> [(String, Double -> Double)]
19:44:13 <jack`> ski of course it's not sensible, I just  wanted to see if it's possible. when I accidentally added a string to a Number I got "No instance for (Num [Char])" error. so I was wondering if I could make such an instance
19:44:29 <ski> in those three cases, the type variable `a' in the original type for `take' got "instantiated" to `Integer',`Char',`(String,Double -> Double)' respectively
19:44:43 <ski> you can also do "partial instantiations"
19:44:43 <jack`> geekosaur let me try to process that
19:44:57 <ski> @type take :: Int -> [(k,v)] -> [(k,v)]
19:44:59 <lambdabot> Int -> [(k, v)] -> [(k, v)]
19:45:18 <ski> introducing new type variable which could be further instantiated later
19:45:49 <geekosaur> so, the problem with an instance for a specific instantiation (Maybe Int, or [Char], etc.) is that it causes a conflict if someone later defines an instance for Maybe a or [a]
19:46:03 <jack`> ah I see
19:46:27 <geekosaur> there are ways to overcome the cnflict but they're risky because of the open world assumption: that other instance could be *anywhere* and somehow has to know about your more specific one
19:46:41 <geekosaur> even if it doesn't exist at the time the module is compiled
19:50:51 <geekosaur> (in case it's not clear, you're poking at a dark corner of the language which is probably best left unexplored by beginners. nasty surprises await.)
19:51:25 <jack`> it is, but it is just a silly code to explore typeclasses, specifically how to define your own Num class
19:52:19 <ski> > map (sum [sin^2,cos^2]) [pi/4,pi/3,pi/2]
19:52:26 <lambdabot>   [1.0,1.0,1.0]
19:52:37 <ski> jack` ^
19:53:14 <ski> that's imo a more sensible example of a "silly `Num' instance"
19:53:19 <jack`> whoa, how did that work?
19:53:33 <jack`> Num class for functions?
19:53:56 <jack`> oh, Num class for lists
19:54:13 <jack`> :t sum [sin^2,cos^2]
19:54:17 <lambdabot> Floating a => a -> a
19:54:19 * ski watches cogs spin inside jack`s head
19:54:25 * hackagebot llvm-analysis 0.3.0 - A Haskell library for analyzing LLVM bitcode  http://hackage.haskell.org/package/llvm-analysis-0.3.0 (TristanRavitch)
19:54:27 * hackagebot llvm-tools 0.2.0.0 - Useful tools built on llvm-analysis  http://hackage.haskell.org/package/llvm-tools-0.2.0.0 (TristanRavitch)
19:54:30 <jack`> yeah, I am not getting it :)
19:54:59 <ski> would you like to ponder it for awhile ?
19:55:04 <jack`> sure
19:55:36 <jack`> :t sum
19:55:36 <lambdabot> Num a => [a] -> a
19:55:39 <jack`> :t (^)
19:55:40 <lambdabot> (Integral b, Num a) => a -> b -> a
19:56:06 <geekosaur> I will mention, by the by, that a Num instance for lists is exactly the kind of conflict you can get into with your attempt... since a String is just a list of Char
19:56:08 <khyperia> ... why have I not heard of ^ before? I always thought it was only **
19:56:32 <geekosaur> and even with a constraint (Num a => [a]) it's dangerous, because the constraint doesn't get used in picking an instance
19:56:38 <geekosaur> khyperia, it's worse than that
19:56:44 <geekosaur> :t (^^)
19:56:45 <lambdabot> (Fractional a, Integral b) => a -> b -> a
19:56:51 <khyperia> oh, awesome!
19:59:26 <jack`> > (sin^2) 5
19:59:33 <lambdabot>   mueval-core: Time limit exceeded
19:59:42 <jack`> :-O
19:59:51 <ski> > (sin^2) 5
19:59:56 <lambdabot>   0.9195357645382262
20:00:09 <ski> @help run
20:00:09 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
20:00:34 <jack`> it continued computation?
20:00:50 <geekosaur> hrm. did That Bug creep back in during the latest maintainer handoff?
20:01:01 <kraai> Is this the right place to ask about a problem building ghc?
20:01:23 <geekosaur> or is that just another esample of the problem with shared hosting?
20:01:37 <ski> jack` : i don't think so. sometimes lambdabot seems a bit too busy to give queries enough notice
20:01:42 <jack`> I expected (sin^2) 5 to be the same as (sin 5)^2, but it seems to be doing something else
20:01:50 <geekosaur> kraai, you can ask, if nobody can help then try #ghc or one of the mailing lists
20:01:56 <ski> > (sin 5)^2
20:01:58 <lambdabot>   0.9195357645382262
20:02:04 <kraai> geekosaur: ok, thanks.
20:02:18 <jack`> ah, so it is. must have mistyped it in my hand calculator
20:02:36 <jack`> neat Num instance
20:02:50 <kraai> when I try to build ghc, ""inplace/bin/ghc-cabal" check libraries/base" fails with the error "Unknown extensions: NegativeLiterals, RoleAnnotations"
20:03:02 <jack`> you were right, much cooler than what I planned on writing. I will try writing it myself
20:03:03 <Hodapp> jack`: either that or radian/degree mismatch.
20:03:13 <kraai> this is on an up-to-date Debian unstable system w/ the ghc build-dependencies installed.
20:03:38 <kraai> I didn't see any mention of this error in Google or the GHC trac.
20:04:29 <ski> > (id^2 - id - 1) `map` [(1 + sqrt 5) / 2,(1 - sqrt 5) / 2]
20:04:35 <lambdabot>   [0.0,0.0]
20:05:14 <ski> > (fst^2 + fst * snd + snd^2) (3,4)
20:05:19 <lambdabot>   37
20:05:27 <ski> > (fst^2 + fst * snd + snd^2) (3,4)  :: Expr
20:05:31 <lambdabot>   3 * 3 + 3 * 4 + 4 * 4
20:11:18 <Hodapp> hmm, interesting that near-identical proofs can be used to show the existence of total computable functions which are not primitive recursive, and the undecidability of the halting problem.
20:12:34 <copumpkin> http://mathoverflow.net/questions/131173/lawveres-fixed-point-theorem-and-the-recursion-theorem
20:13:04 <copumpkin> I think this is a super simplistic statement of it: https://gist.github.com/copumpkin/6562417
20:13:30 <Hodapp> are you a pumpkin built up from a base case?
20:15:40 <jack`> can't one check if `read` succesfully parsed the string in non-IO code? catch function has `IO a -> (IOError -> IO a) -> IO a` type
20:17:57 <simpson> So, I know that it's possible to use lenses to add or update things like Maps.
20:18:16 <simpson> :t at "key" ?= 42
20:18:20 <lambdabot> (Num (IxValue s), At s, MonadState s m, Index s ~ [Char]) => m ()
20:18:25 <ski> > (reads :: ReadS Integer) "123"
20:18:27 <lambdabot>   [(123,"")]
20:18:29 <ski> > (reads :: ReadS Integer) "123abc"
20:18:30 <lambdabot>   [(123,"abc")]
20:18:34 <ski> > (reads :: ReadS Integer) "abc"
20:18:35 <lambdabot>   []
20:18:35 <simpson> So is it possible to *remove* things from Maps this way?
20:18:48 <ski> > (reads :: ReadS Bool) "False()"
20:18:49 <lambdabot>   [(False,"()")]
20:18:59 <ski> > (reads :: ReadS Bool) "FalseOrTrue"
20:19:00 <lambdabot>   []
20:19:05 <ski> jack` ^
20:19:12 <jack`> thanks! what about catching exceptions in general, it is only possible in IO? why?
20:19:59 <ski> because it would allow one to distinguish between one and another way of evaluating `error "foo" + error "bar"'
20:20:06 <ion> jack: As far as pure code is concerned, there is no difference between an exception and let x = x in x.
20:20:29 <copumpkin> Hodapp: nope
20:20:30 <ski> @type Control.Exception.catch
20:20:31 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
20:20:53 <Hodapp> copumpkin: then what are you >_>
20:21:29 <ion> hodapp: I’m afraid you parsed his nick incorrectly. It’s actually cop-umpkin.
20:21:45 <copumpkin> Hodapp: I'm an IRC bot
20:21:55 <Hodapp> copumpkin: How do you feel about I'm an IRC bot?
20:22:02 <copumpkin> good
20:23:15 <emaphis> a squash in the vegitable semi-group.
20:23:36 <Hodapp> bah.
20:23:49 <geekosaur> cosquash
20:24:00 <ion> cosplay
20:24:16 <ion> cow
20:24:35 <Hodapp> copulation
20:24:43 <djahandarie> Funnily enough, the term "squash" is actually used a little in HoTT
20:25:12 <emaphis> hot pumkin pie?
20:35:50 <ion> Is there a package based on <http://okmij.org/ftp/continuations/PPYield/yield-pp.pdf>?
20:36:06 <ion> For the yield part, not the pretty-printing part.
20:39:36 * hackagebot llvm-tools 0.2.0.1 - Useful tools built on llvm-analysis  http://hackage.haskell.org/package/llvm-tools-0.2.0.1 (TristanRavitch)
20:57:23 <xrz> Hi, I am trying to convert JSON structures like "[1,2,3,\"a\"]" to any sensible Haskell data type (with Aeson?). Is there any way to do that?
20:59:31 <Cale> xrz: Yeah, there's a type called Value, iirc
20:59:59 <Cale> http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson.html#t:Value
21:03:32 <vonDraco> okay, so is there any way to have a compiled haskelled program hang after completion? example, i make main print out a line, and then once it prints it out in an instant, the command prompt disappears.
21:04:48 <lispy> vonDraco: are you on windows?
21:04:49 <xrz> Cale: Great, thanks for your help. Will try Value, that should work. (I was playing with tuples before that.)
21:04:59 <vonDraco> yes, lispy
21:06:36 <lispy> vonDraco: Personally, I think the best solution is to simply run the program from the command line. If you don't want to do that, you could use getLine. Then  it will sit there until you press enter.
21:09:10 <vonDraco> lispy, it isn't important, but i just remember being able to do it in C++ with System("pause") or something like that. and i know i could do that :P
21:09:37 <vonDraco> so I guess just adding a random getLine after the last putStrLn would be the best solution, like you said.
21:09:52 <pavonia> xrz: What exactly are you trying to achieve? Aeson already has functions for converting JSON to and from Value
21:10:10 <lispy> vonDraco: you could still use runProcess (or some variant) to call pause
21:10:54 <lispy> vonDraco: when I do haskell stuff on windows, I install mingw and mintty and then use the command line as much as I can
21:10:54 <blaenk> vonDraco: it's generally preferred in any language to do what lispy is suggesting, ask for input
21:10:59 <simpson> Hey, how do I get wall time?
21:11:00 <blaenk> than to spawn an entire new process just for that
21:11:38 <lispy> vonDraco: but, I come from a linux background :)
21:11:52 <vonDraco> ah, okay. thanks guys, this is pretty much what i was looking for
21:12:00 <simpson> :t getCPUTime -- I found this, but I want wall time.
21:12:01 <lambdabot> Not in scope: `getCPUTime'
21:12:14 <simpson> :t System.CPUTime.getCPUTime
21:12:14 <lambdabot> IO Integer
21:13:53 <xrz> pavonia: I am writing a (hopefully simple) module, which converts JSON like [[Number, Number, String|Number, String|Number]] from/to some Haskell representation.
21:15:01 <pavonia> xrz: Are you doing that for fun/practice?
21:15:13 <xrz> pavonia: I think Value should work fine for that purpose. I was a bit confused, because I tried to convert that JSON to a list of tuples with no success.
21:16:26 <lispy> vonDraco: you're welcome!
21:18:07 <xrz> pavonia: That is my experimental project. I am fetching/pushing updates from/to handsontable spreadsheet (you may check handsontable.com) over websocket channel.
21:19:53 <pavonia> Hhm, I'm just asking because I think it isn't necessary to re-implement all the parsing stuff
21:24:20 <xrz> pavonia: That is not an issue at all - nothing is implemented yet. I was trying to use Data.Aeson.TH to parse JSON messages. Does that seem like a reasonable choice for the task?
21:26:28 <pavonia> xrz: If you use your own data structures, yes
21:30:10 <frx> > 1 + 2
21:30:27 <frx> why is lambdabot so slow?
21:30:52 <ski> perhaps she's sleeping
21:31:18 <Cale> int-e: ^^
21:35:31 <jack`> instance Num a => Num (a -> a) where     f + g = \x -> f x + g x
21:35:33 <xrz> pavonia: Thanks for your help, appreciated
21:35:47 <arkeet> or even Num (b -> a)
21:35:52 <jack`> how can this make (sin+2) work?
21:36:02 <arkeet> 2 :: Num a => a
21:36:23 <arkeet> so you also need to write a definition of fromInteger in that instance.
21:36:30 <jack`> oh, it calls fromInteger
21:36:35 <arkeet> yes.
21:36:42 <jack`> yes I have it, I just didn't realize what was going on
21:39:45 * hackagebot crypto-numbers 0.2.3 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.2.3 (VincentHanquez)
21:40:11 <ski> jack` : great work :)
21:40:30 <jack`> had fun writing it :)
21:40:36 <ski> i can imagine :)
21:44:45 * hackagebot crypto-pubkey 0.2.2 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.2 (VincentHanquez)
21:46:02 <idletom> hi, I just installed haskell platform for OS X and when trying to run ghci at terminal i get The build-tool has reset ENV. --env=std required
21:46:06 <idletom> can anyone help me
21:46:54 <jmcarthur> a lambda calculus question... does there exist two *distinct*, *normalized* LC terms f and g such that forall x. f x == g x? let's say we're only talking about the simply typed lambda calculus, if it affects the answer.
21:48:21 <ski> beta-normalized ?
21:48:50 <jmcarthur> let's say they are canonical. beta-normal and eta-long
21:49:12 <jmcarthur> not sure if eta-long affects it
21:49:23 <jmcarthur> not sure of anything about this question, really
21:49:31 <c_wraith> I would assume it is
21:49:34 <idletom> anyone?
21:49:40 <ski> if you forget about eta, then there's `f' vs. `\x. f x'
21:49:46 * hackagebot cpu 0.1.2 - Cpu information and properties helpers.  http://hackage.haskell.org/package/cpu-0.1.2 (VincentHanquez)
21:49:48 * hackagebot pem 0.2.1 - Privacy Enhanced Mail (PEM) format reader and writer.  http://hackage.haskell.org/package/pem-0.2.1 (VincentHanquez)
21:49:54 <jmcarthur> yeah i guess if you say both are normalized then the answer is easy
21:50:06 <jmcarthur> so yeah, s/normalized/canonical/
21:50:10 <c_wraith> Err, I'd assume it's possible, due to the fact that there are different algorithms to express the same computation.
21:51:00 <c_wraith> Like, come up with some lambda calculus representation of graphs, and then you can have an expression for Prim's algorithm and an expression for Kruskall's algorithm
21:51:31 <c_wraith> idletom: I'd guess it's due to the recent version of xcode changing the build tools.  There are a bunch of resources on the topic.
21:51:31 <ski> but do they have a normal form ?
21:52:06 <idletom> google doesn't provide a ubnch of resources
21:52:08 <idletom> for that error
21:52:16 <idletom> but i'll update xcode i guess
21:52:27 <jmcarthur> i guess the gist of my question is do different algorithms that produce the same results have different canonical forms
21:52:27 <c_wraith> no, updating xcode is the opposite of fixing it.
21:52:33 <structur_> is there a simple way to read out all the contents of a Chan at once and get a list back?
21:53:11 <ski> @hoogle Chan a -> IO [a]
21:53:12 <lambdabot> Control.Concurrent.Chan getChanContents :: Chan a -> IO [a]
21:53:12 <lambdabot> Prelude repeat :: a -> [a]
21:53:12 <lambdabot> Data.List repeat :: a -> [a]
21:53:39 <c_wraith> idletom: http://www.haskell.org/pipermail/haskell-cafe/2013-September/110320.html is a resource on the problem I'm thinking of
21:53:49 <idletom> ty
21:53:51 <c_wraith> idletom: http://www.reddit.com/r/haskell/comments/1ml97r/haskellcafe_psa_do_not_install_xcode_5_if_you_are/ has more info
21:55:02 <structur_> is that what getChanContents does? I'm not too familiar with lazy IO and such
21:55:17 <ski> iirc `getChanContents' gets all future values on the channel
21:55:26 <structur_> that's what I thought
21:55:36 <structur_> is there a way to get all current values?
21:55:41 <c_wraith> nope
21:55:41 <ski> yeah, looks like it
21:55:42 <ski> <http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Control-Concurrent-Chan.html#v:getChanContents>
21:55:55 <structur_> isEmptyChan being deprecated seems non-promising
21:55:57 <c_wraith> If you want functionality like that, you need to use TChans and STM
21:58:30 <jmcarthur> my question seems so naive that surely it has been answered a million time in the past. the problem is i just don't know what to search for.
21:58:36 <jmcarthur> *times
22:00:33 <jmcarthur> perhaps this is trivial to answer, actually
22:01:41 <jmcarthur> the fact that, for example, (a + b) + c = a + (b + c) is not just trivial for the agda compiler to see by just reducing both sides
22:02:07 <jmcarthur> but maybe that's due to the way data types work. maybe the simply typed or untyped LC doesn't work this way
22:02:30 <jmcarthur> i guess i could try that example
22:08:36 <carter> c_wraith: idletom  the psa links in the topic work for xcode 5
22:09:12 <carter> http://www.haskell.org/platform/mac.html and https://gist.github.com/cartazio/7131371
22:09:25 <idletom> im still not sure its an xcode 5 issue
22:09:37 <idletom> Believe i had this same problem many months ago
22:09:51 <idletom> in mac and i never resolved it because i didnt use this computer much
22:09:59 <idletom> trying some things though
22:11:01 <carter> idletom: whats the problem?
22:11:19 <carter> do you have CLI tools installed?
22:11:25 <carter> what shell are you using?
22:11:30 <idletom> trying to run ghci at terminal i get The build-tool has reset ENV. --env=std required
22:11:36 <idletom> zsh
22:11:50 <carter> idletom: do you have CLI tools installed / xcode ?
22:11:55 <carter> what OS X version?
22:11:57 <carter> what ghc version
22:12:39 <idletom> im installing clean right now
22:12:40 <carter> idletom: you have my attention for the next 5 mintues
22:12:44 <idletom> 10.8.4 OSX
22:12:45 <carter> what clean
22:12:46 <carter> ok
22:12:51 <carter> do you ahve CLI tools?
22:12:51 <idletom> im installing haskell platform fresh
22:12:52 <idletom> again
22:12:53 <idletom> yes
22:12:57 <carter> what Xcode version
22:13:10 <carter> what do
22:13:11 <carter> clang --version
22:13:13 <carter> and gcc --version
22:13:14 <carter> say
22:13:35 <carter> do you use brew / macports or other?
22:13:41 <idletom> brew
22:13:56 <carter> are you using the offcial Haskell platform distor
22:13:58 <carter> or the brew one
22:13:58 <idletom> clang --version
22:13:58 <idletom> Apple LLVM version 4.2 (clang-425.0.28) (based on LLVM 3.2svn)
22:14:04 <carter> ok
22:14:08 <idletom> gcc 4.2.1
22:14:11 <carter> ok
22:14:15 <carter> so xcode 4
22:14:31 <carter> how're you using ghci?
22:14:35 <carter> does cabal-install work?
22:14:43 <idletom> terminal
22:14:44 <carter> idletom: you need to describe what you're doing
22:14:47 <carter> what terminal
22:14:49 <idletom> im typing
22:14:51 <idletom> ghci
22:14:52 <carter> ok
22:14:53 <idletom> in the terminal
22:15:06 <carter> show me a transcript
22:15:08 <carter> @lpaste
22:15:08 <lambdabot> Haskell pastebin: http://lpaste.net/
22:15:35 <carter> does ghc --interactive  not work too?
22:15:45 <idletom> http://lpaste.net/95554
22:15:52 <idletom> cannot try right now it is building
22:16:04 <carter> ok
22:16:05 <carter> soooo
22:16:14 <carter> why are you using 7.4 instead of 7.6?
22:16:28 <idletom> was an old version
22:16:30 <idletom> i updated
22:16:31 <carter> ok
22:16:32 <idletom> 7.6.3
22:16:34 <idletom> and it did the same thing
22:16:38 <carter> ummm
22:16:43 <carter> does cabal install / ghc work?
22:17:09 <idletom> i never cabal installed anything or tried ghc
22:17:11 <idletom> i tried cabal update
22:17:12 <carter> ok
22:17:12 <idletom> and it ran
22:17:25 <carter> what does "which env" do?
22:17:40 <idletom> usr/bin/env
22:17:42 <carter> ok
22:18:05 <carter> ok
22:18:06 <carter> well
22:18:34 <carter> what custom things do you have in your dev setupt?
22:19:08 <carter> because i've never seen this before
22:19:09 <carter> ever
22:19:17 <idletom> I mean im not sure what you mean, i;m using zshell and oh-my-zsh
22:19:21 <carter> ok
22:19:23 <carter> well
22:19:32 <carter> i'm asking for info because i've never seen this problem before
22:21:56 <leroux> Hello.
22:21:59 <leroux> carter: What's up?
22:22:21 <carter> leroux: welll, idletom  has a WEIRD error
22:22:31 <leroux> Environment variable issues?
22:22:39 <carter> http://lpaste.net/95554
22:22:41 <carter> is his
22:23:17 <leroux> Is that `--env=std' from homebrew?
22:23:29 <carter> i have no clue
22:23:38 <carter> idletom: are you using brew or the official installer?
22:24:01 <idletom> i downloaded the pkg from the website earlier and tried that with no luck
22:24:04 <idletom> removed everything now
22:24:08 <idletom> and am installing
22:24:10 <idletom> using homebrew
22:24:12 <idletom> its building right now
22:24:26 <idletom> its done
22:24:27 <leroux> Okay, it should work...
22:24:28 <idletom> and works
22:24:29 <idletom> now
22:24:30 <idletom> :O
22:24:31 <carter> idletom: DONT USE BREA
22:24:49 <carter> idletom: NEVER USE BREW FOR HASKELL
22:24:49 <leroux> =)
22:24:51 <carter> everrrrrrrr
22:24:59 <carter> i say this despite donating to their kick starter
22:25:11 <carter> one of the 10-20 largest donations
22:25:14 <idletom> well it works somehow now
22:25:18 <idletom> so theres that
22:25:19 <idletom> thanks
22:25:29 <carter> well
22:25:31 <carter> don't use brew
22:25:46 <carter> unless you're using darin's haskell atp
22:25:47 <carter> tap
22:26:02 <carter> because he knows what hes doing
22:26:13 <carter> idletom: well, if we can't understand WHY the bug is happening
22:26:17 <carter> we can't prevent it from happening again
22:26:33 <carter> idletom: whats your $PATH look like?
22:27:12 <carter> i kinda wanted to debug this
22:27:24 <carter> because any bug we hear about on IRC
22:27:26 <carter> once
22:27:29 <carter> probably happens more than once
22:27:37 <idletom> https://gist.github.com/anonymous/45216f96a8104e14ddd2
22:27:58 <carter> oooo
22:28:00 <carter> i have a theory
22:28:04 <carter> hrmm
22:28:10 <idletom> im going to remove Library/Haskell
22:28:13 <idletom> i just added it
22:28:18 <idletom> because i read something
22:28:21 <carter> what
22:28:23 <carter> where
22:28:23 <idletom> i don thtink i need it?
22:28:28 <carter> read what
22:28:33 <carter> also don't use berw
22:28:36 <carter> brew
22:28:46 <carter> you'll probably need to add ~/.cabal/bin
22:28:50 <carter> depending on how you've got things setup
22:28:56 <idletom> well it works and im not going to mess with it anymore
22:29:00 <carter> ok
22:29:17 <idletom> cabal is in usr/local/bin
22:29:21 <carter> nope
22:29:29 <idletom> it is..
22:29:32 <carter> ~/.caba/bin  is where cabal by deafult INSTALLLS
22:29:33 <carter> bins
22:29:42 <idletom> which cabal
22:29:43 <idletom> /usr/local/bin/cabal
22:29:45 <carter> yes
22:29:46 <carter> i know
22:29:49 <carter> CABAL INSTALLS
22:29:51 <carter> STUFF
22:29:53 <carter> to a PLACE
22:29:58 <carter> that place
22:30:00 <carter> by default
22:30:05 <carter> is ~/.cabal/bin
22:30:08 <carter> cabal install happy
22:30:10 <carter> and see where it puts it
22:30:13 <carter> well
22:30:14 <carter> hehe
22:30:32 <carter> wheres you ~/.cabal/config say?
22:30:47 <carter> cat ~/.cabal/config
22:30:52 <leroux> carter: I've been having pains with cabal package conflicts for the past week.
22:30:58 <leroux> I ended up sandboxing.
22:31:05 <carter> leroux: delete ~/ghc and start again
22:31:07 <leroux> But there's so much overlap...
22:31:09 <leroux> Mhm.
22:31:26 <carter> and use sandboxes mroe :)
22:31:31 <leroux> =\
22:31:34 <carter> no
22:31:36 <carter> those aer good
22:31:40 <carter> why the frownie
22:31:48 <leroux> Because there is soooo much overlap.
22:31:57 <carter> what do you mean
22:31:59 <carter> explain your words
22:32:04 <leroux> Package overlap?
22:32:16 <carter> yes
22:32:19 <carter> you mean module name conflict?
22:32:23 <leroux> I know that's the point.
22:32:31 <carter> whats the points?
22:32:36 <carter> your'e being vague
22:32:37 <leroux> No, I'm just saying that I wouldn't want two copies of the same package.
22:32:38 <carter> be explicit
22:32:41 <carter> nope
22:32:44 <carter> if youre getting conflicts
22:32:48 <carter> use sandboxing
22:32:51 <leroux> I'm not getting conflicts anymore.
22:32:51 <carter> and if you want it to be cleverer
22:32:54 <carter> ok
22:33:01 <leroux> It's all cleaned up.
22:33:03 <carter> if you want it to be cleverer, start contributing to cabal
22:33:41 <leroux> Fine.
22:33:58 <carter> :)
22:34:18 <carter> soon you'll be a greybeard open source burnout :)
22:34:19 <carter> mwahahahah
22:34:36 <TravisD> that's a very depressing image :(
22:35:26 <carter> hehe
22:35:29 <carter> note the :)
22:35:45 <TravisD> Heh, at least he'll be happy
22:36:09 <carter> getting thanks from SPJ et al is kinda sweet
22:36:36 <TravisD> that would be pretty great
22:36:48 <TravisD> Right now i'm patting myself on the back for knowing who that is. lol
23:05:43 <xl1> jmcarthur: the Lambda Caculus book has a theorem that answers your question, it is true if neither f nor g is a "universal generator" (whose reduction graph is a supergraph of all lambda terms'), iirc
23:12:24 <ski> good old Barendregt
23:23:56 <identity> I dreamt that I was at a movie theater, and that the owner who was working in the shop selling refreshments looked like Dean Norris, and he had a The Art of Computer programming-ish series of books on Haskell 98 on a shelf behind him and he was learning Haskell.
23:24:00 <identity> what does it mean?!
23:24:30 <simpson> Dreams don't mean anything.
23:27:04 <ski> it might mean that you had been thinking about TAOCP and Haskell
23:27:23 <identity> perhaps
23:28:45 <Taneb> And Dean Norris
23:29:14 <identity> i don't remember thinking about dean norris
23:50:08 * hackagebot HTTP 4000.2.9 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.9 (GaneshSittampalam)
