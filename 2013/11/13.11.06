00:02:18 <arkeet> spot the bug https://github.com/haskell/win32/blob/master/System/Win32/Process.hsc#L116
00:02:27 <carter> arkeet: windows!
00:02:31 <arkeet> haha
00:02:52 <carter> take a neodynium magnet to your computer
00:02:57 <carter> and reinstall something less crufty
00:02:58 <arkeet> =(
00:03:08 <carter> i kid
00:03:18 <carter> i know nothing of win32
00:04:08 <arkeet> hint: the bug makes this function not work at all ever.
00:04:14 <carter> i know nothing
00:04:26 <arkeet> :p
00:04:31 <carter> like
00:04:35 <carter> actually igorant
00:04:39 <carter> *ignorant
00:05:00 <carter> i'm going to go back to watching tv on my laptop while writing the ultimate array library everrrrr
00:05:00 <arkeet> well, it's using the wide char API functions but not the corresponding version of the PROCESSENTRY32 structure
00:05:01 <arkeet> (which is called PROCESSENTRY32W)
00:05:08 <carter> ok
00:05:11 <arkeet> ok!
00:05:16 <carter> yer the expert :)
00:06:01 <arkeet> anyway, so then those functions throw an error because you didn't give it a big enough size to fill that structure with.
00:06:09 <arkeet> ok.
00:07:41 <carter> ok
00:07:43 <carter> cool
00:07:46 <carter> you can fix it right?
00:07:52 <carter> will it make it into 7.8?
00:09:01 <arkeet> it's not part of ghc
00:09:05 <carter> ok
00:09:06 <carter> welll
00:09:09 <arkeet> I guess I could fix it and send a pull request or something.
00:09:12 <carter> i'm ignorant
00:09:13 <carter> yay!
00:09:14 <carter> :)
00:09:24 <carter> or at least info on a ticket explaining it
00:09:31 <arkeet> well I already have a fix.
00:09:37 <carter> ok
00:09:37 <arkeet> but really
00:10:06 <carter> ?
00:10:25 <arkeet> look at how that function works.
00:10:25 <arkeet> it's awful.
00:10:25 <arkeet> so win32 gives you one entry each time you call its thing.
00:10:25 <arkeet> so this function keeps consing those onto the front of a list.
00:10:26 <arkeet> and then reverses it at the end.
00:10:40 <arkeet> =(
00:11:03 <elliott> that's about as efficient as it can get, isn't it?
00:11:09 <arkeet> is it?
00:11:11 <arkeet> I don't know.
00:11:25 <arkeet> I would get one, recursively call myself for the rest, and just cons that.
00:11:48 <elliott> but you could run out of stack, or somethin'.
00:11:56 <arkeet> I thought about that.
00:11:57 <arkeet> =(
00:12:06 <arkeet> :t foldrM
00:12:06 <lambdabot>     Not in scope: `foldrM'
00:12:07 <lambdabot>     Perhaps you meant one of these:
00:12:07 <lambdabot>       `F.foldrM' (imported from Data.Foldable),
00:12:09 <arkeet> :t F.foldrM
00:12:10 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
00:12:20 <carter> well, 7.8 has unlimited stack by default
00:12:45 <arkeet> they should expose something of type (ProcessEntry32 -> b -> IO b) -> IO b
00:13:03 <carter> propose it
00:13:13 <arkeet> I dunno, it would feel way out of place.
00:13:38 <carter> why?
00:13:48 <arkeet> that's my feeling
00:13:58 <carter> educmate me on why
00:13:59 <carter> :)
00:14:13 <arkeet> then again, a thin win32 api wrapper wouldn't have that thing to begin with.
00:14:42 <carter> which?
00:15:01 <arkeet> the function with the bug.
00:15:33 <arkeet> oh, also CreateToolhelp32Snapshot returns INVALID_HANDLE_VALUE (-1) on error, not NULL (0)
00:15:37 <arkeet> so createToolhelp32Snapshot is also wrong. =(
00:16:40 <arkeet> also, the other thing I don't like.
00:16:49 <arkeet> it throws exceptions for everything.
00:16:58 <carter> give feedback
00:17:02 <arkeet> so.
00:17:04 <carter> 3am feedback is better than none
00:17:14 <arkeet> it's midnight =(
00:17:36 <carter> east coast!
00:17:37 <arkeet> and it throws IOErrors (created by userError), not some custom exception type.
00:17:37 <carter> :P
00:17:42 <carter> huh
00:17:47 <carter> sounds like someone needs to clean i tup
00:18:23 <arkeet> and lots of error codes for win32 aren't actually exceptional situations either
00:18:25 <carter> arkeet:its only gotten  5 commits in the past 2 years
00:19:00 <carter> arkeet: i think the rooms wide up to for your to burn it with fire into a pretty phoenix
00:19:14 <arkeet> maybe
00:19:20 <arkeet> I'd probably lose interest quickly though.
00:19:26 <carter> well
00:19:32 <carter> at least write down these thoughts on a ticket
00:19:38 <carter> so someone can stay interested
00:19:40 <carter> pleaseeeeeeee
00:19:44 <arkeet> ok
00:19:48 <carter> yay!
00:19:49 <carter> :)
00:19:53 <arkeet> tomorrow though, I'm sleepy.
00:20:22 <carter> ok
00:20:26 <carter> i'll pester you tomorrow then
00:20:26 <carter> woot
00:20:27 <carter> :)
00:20:28 <carter> night
00:20:34 <carter> i should actually crash soon too
00:25:54 <arkeet> ok, sent a pull request for the first thing.
00:25:55 <arkeet> nn
00:30:01 <jmzcool> noob question google does not seem to say "yes" to: is there a way to save a current ghci session? i am giving a presentation tomorrow and want to precompute some stuff that takes a few minutes to load up (~14 megs of data)
00:31:42 <arkeet> by not really, I mean no.
00:33:37 <jmzcool> that's a shame :(
00:37:05 <sopvop> Hm, do I really need a typeclass for "generalized apply". with instances like `applyIt :: (a->a', b->b', c->c') -> (a,b,c) -> (a', b', c')` ?
00:37:42 <arkeet> with 6 parameters?
00:37:51 <arkeet> er
00:38:01 <arkeet> no, 3.
00:38:08 <sopvop> 3 parameters, and tuples up to, say, 9
00:38:51 <arkeet> I can't tell you whether you really need that.
00:39:23 <sopvop> Or make a typeclass like  toNested (a,b,c) -> (a,(b,c)), and work from that? eh
00:40:07 <donri> or don't use anything larger than a triple? :P
00:40:07 <donri> or pair, even.
00:40:35 <sopvop> Thats to represent rows in DB, tuples are natural
00:41:02 <arkeet> why not some sort of heterogeneous list?
00:41:14 <sopvop> It does not "look" right :)
00:41:42 <arkeet> why not? =(
00:41:59 <sopvop> I dunno, it looks unfriendly
00:42:30 <arkeet> tuples are pretty unfriendly
00:42:59 <sopvop> Nah, you just pattern match and go home
00:44:21 <lpaste> sopvop pasted “Ugly tuples” at http://lpaste.net/95275
00:44:49 <sopvop> The good thing about ^ that code, is that users don't need to see this
00:47:52 <donri> sopvop: uniplate? duno
00:49:24 <sopvop> dependend types!
00:49:25 <sopvop> :)
00:57:09 <lpaste> f-a pasted “record fields woes (possibly: template haskell)” at http://lpaste.net/95276
00:59:50 <bz> any way to section-ize (\n -> n .&. (n-1)) ?
01:01:48 <hamid> @src Monad []
01:01:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:01:48 <lambdatwo> Plugin `source' failed with: state not initialized
01:01:49 <Iceland_jack> @pl (\n -> n .&. (n-1))
01:01:49 <lambdatwo> ap (.&.) (subtract 1)
01:01:52 <lambdabot> ap (.&.) (subtract 1)
01:01:52 <lambdabot> optimization suspended, use @pl-resume to continue.
01:02:57 <Chat4282> Helo
01:04:18 <quchen> We have a Lambdabot surplus.
01:08:17 <arkeet> whoever put lambdatwo here, please remove it
01:08:20 <arkeet> =(
01:08:31 <elliott> lambdatwo: @part #haskell
01:08:31 <lambdatwo> Not enough privileges
01:08:35 <elliott> ok :)
01:08:51 <arkeet> I think you need to be more forceful.
01:09:27 <arkeet> on the other hand, lambdatwo has a working @pl
01:13:27 <bz> Iceland_jack: thanks
01:34:35 <maybefbi> my sha256 pure function only gives correct hash for blank input :(
01:47:37 <alexander__b> is it possible to use haddock with space/
01:47:42 <alexander__b> eh
01:47:49 <alexander__b> is it possible to use haddock with cabal?
02:01:24 <dEPy> when using algebraic data types is it common practice to name type and constructor the same?
02:01:42 <Taneb> When it makes sense, yeah
02:02:09 <dEPy> When does it make sense to do so?
02:02:28 <Taneb> When you want to name them the same, basically
02:02:58 <tdammers> when both the thing and the kind-of-thing are conceptually named the same
02:03:26 <dEPy> so:  data Name = Name String
02:03:35 <dEPy> this is ok?
02:03:50 <tdammers> sure
02:03:55 <dEPy> I can't think of any case when to name them differently thought
02:04:01 <tdammers> might consider newtype in this case
02:04:08 <tdammers> anyway
02:04:11 <pamojarpan> dEPy: data TaskState = NotDone | Started | Done deriving (Eq)
02:04:20 <pamojarpan> data Task = Task {state :: TaskState, name :: String} deriving (Eq)
02:04:26 <tdammers> data ExitStatus = ExitOK
02:04:35 <tdammers> data ExitStatus = ExitOK | ExitError Int
02:04:38 <tdammers> that kind of thing
02:04:50 <tdammers> or even just data Either a b = Left a | Right b
02:04:56 <dEPy> A.. ok :)
02:05:15 <jmzcool> Suppose I have 8 ascii chars as a 64-byte string, which I have as a Word64. What's the best way to dump this into an 8-character string?
02:05:30 <jmzcool> 64-bit*** string,
02:07:36 <t7> (char*) &myWord64
02:08:01 <donri> jmzcool: binary or cereal, perhaps
02:08:36 <quicksilver> the clearest way is to write up something of type Word64 -> [Word8] using bit shifts
02:08:38 <t7> or undigits . digits
02:09:16 <quicksilver> (or 8-tuple if you like)
02:09:29 <quicksilver> and then map (chr.fromIntegral)
02:10:08 <donri> or ByteString.pack
02:10:22 <quicksilver> that's what http://hackage.haskell.org/package/digits-0.2/docs/Data-Digits.html does, I guess.
02:10:27 <lambdatwo> Title: Data.Digits, http://tinyurl.com/kx92q92
02:10:44 <quicksilver> (if you set the base to 256)
02:12:53 <jmzcool> thanks for all the suggestions, i'll check it out :D
02:16:19 <bartavelle> hello, I am looking for a data structure the supports pairs of values, and that is good at doing something like this : Map.fromListWith (+) . map (first xxx) . Map.toList
02:16:27 <bartavelle> that is altering the "key" and merging the values
02:16:53 <bartavelle> I don't need efficient access to the values
02:17:11 <bartavelle> but I need to do a bunch of those "alter key / merge" operations
02:17:21 <bartavelle> anyone has an idea ?
02:18:15 <fizruk> bartavelle, Data.Map has mapKeys, isn't that what you want?
02:18:34 <haasn> fizruk: he wants to merge the colliding elements
02:18:44 <haasn> oh
02:18:46 <haasn> mapKeysWith
02:18:47 <alexander__b> hm. what do you guys think of using haddock? I'm trying to use it now, but I find that it results in... a lot of lines per file.
02:18:47 <bartavelle> it is probably not as efficient as it could be, as it is mostly doing a fromList / toList, and I don't need most of the runtime properties of Map
02:18:54 <haasn> mapKeysWith (+) xxx -- bartavelle
02:19:01 <fizruk> haasn, mapKeysWith, yeah
02:19:10 <donri> MVector in ST?
02:19:12 <haasn> it's n log n, which looks pretty efficient to me
02:19:22 <arkeet> maybe he wants good constant factors
02:19:27 <bartavelle> exactly
02:19:43 <bartavelle> fromList is n log(n) too
02:19:49 <alexander__b> so if I have open 4 -> 6 windows with code, with about 25 lines visible in each, they will mostly be comments. if I don't have haddock stuff, I can see several functions in a window size.
02:20:26 <bartavelle> just wondered if someone knew of a nice data structure that would give me excellent performance in that specific use case, I'll stick with HashMap if nobody has an idea
02:20:31 <haasn> alexander__b: fwiw I think you can defer the comments to the end of the file by using named sections or whatever that's called
02:21:03 <quicksilver> Are you sure hashmap outperforms binary tree here?
02:21:03 <alexander__b> haasn: that's true. but then it's just as well (imo) to just do it explicitly -- i.e. in a technical documentation file.
02:21:13 <quicksilver> personally I'd try mapKeysWith.
02:21:32 <bartavelle> quicksilver, I'll go for this then
02:21:38 <quicksilver> changing all the keys is inherently a full map rebuild but it's also a full hashtable rebuild
02:21:58 <quicksilver> hashtables and maps are the same complexity in many cases, it's all about the constant factor
02:22:01 <quicksilver> just try it :)
02:22:18 <bartavelle> yeah it is pretty easy to switch between implementations
02:22:43 <haasn> alexander__b: but haddock has the advantage of generating standard documentation pages that everybody's used to
02:22:51 <haasn> plus, keeping things in the same source file is still a great idea imo
02:23:25 <alexander__b> haasn: I'm still not sold on it. it adds a lot of noise when you have succinct, compartmentalised and modular code.
02:23:49 <identity> Ugh. Contrasting the haskell community to something like the java community(at least here on freenode) just shows how good the haskell community is
02:24:17 <identity> but I guess I'd be come an asshole as well if I had written java for years as well
02:24:47 <alexander__b> identity: #haskell is nicer than all other language channels I've been in, and I've been in lots.
02:25:00 <identity> alexander__b: this is my experience as well.
02:25:32 <donri> alexander__b: you could probably get your editor to fold comments
02:25:44 <identity> You can't ask a question in #haskell without unintentionally nerd-sniping everyone in here, resulting in a cascade of different versions of the function you were hoping to implemented, golf'd and regolf'd in terms of different structures and ididoms :P
02:26:11 <identity> in #java, I barely got an answer, and when I did, the guy was a pompous asshole
02:26:16 <alexander__b> donri: presently it only folds {- -} comments. maybe I should set it to fold multiline comments as well
02:27:22 <alexander__b> donri: do you happen to have vim set up to fold haskell comments? heh /me is lazy today
02:27:48 <donri> i don't, sorry
02:28:08 <identity> alexander__b: vim2hs does some folding of code (which I wish I could remove, actually), i'm not sure if it can do comments, but you can check it out
02:28:18 <alexander__b> identity: it doesn't by default
02:28:23 <alexander__b> it folds {- -}s
02:28:34 <donri> i think it does by default, which isn't a good thing :p
02:28:46 <fizruk> donri, but are a vim user? you okay with long comments?
02:29:01 <donri> i'm the author of vim2hs, so yes i use vim ;)
02:29:08 <identity> donri: oh!
02:29:16 <identity> donri: Can I disable folding?
02:29:22 <fizruk> good to know :)
02:29:25 <identity> I looked and looked and couldn't find the appropriate setting
02:30:12 <donri> identity: sure, autocmd FileType haskell setlocal foldmethod=marker, or something
02:30:13 <alexander__b> I like folding. I want moar not less. :-P
02:30:27 * donri used to use folding a lot, but not lately, not sure why :p
02:31:06 <donri> identity: or i guess foldmethod=manual is the default that vim2hs overrides.
02:31:38 <donri> when i added folding to vim2hs i didn't realize vim's defaults would mean it folds and closes everything by default
02:32:07 <identity> donri: thank you. so set it to manual?
02:32:20 <donri> identity: actually
02:33:19 <donri> identity: if you don't like folding at all, anywhere, maybe simply :setglobal foldlevelstart=99
02:33:37 <identity> donri: hmm, okay. thanks
02:34:07 <alexander__b> to disable folding :set nofoldenable
02:34:20 <identity> oh.
02:34:35 <donri> well that option is window-local and set by vim2hs, unfortunately
02:34:59 <alexander__b> foldmethod is also window-local
02:35:13 <donri> yes that's why i suggested autocmd there :) but foldlevelstart is global
02:36:49 <identity> seems autocmd + nofoldenable works fine
02:37:03 <donri> sure
02:37:47 <identity> donri: Ihave another question, if you don't mind. It seems that vim2hs messes with my indentation as well. I basically follow tibbe's style guide, and my indents are 4 spaces. When vim2hs is enabled, I'd sometimes to: foo = do<Enter>, and it'd drop to 8 spaces indentation below, instead of 4
02:37:52 <identity> which it did before vim2hs
02:38:08 <identity> Is there a way to fix this?
02:38:28 <donri> identity: yeah another mishap, i had misinterpreted the style guide. vim2hs assumes you're using sw=2
02:38:41 <donri> so it uses double indent for function bodies
02:38:53 <donri> but tibbe's guide is rather suggesting using half indent for 'where'
02:39:14 <identity> I do that as well
02:39:19 <identity> Looks the best IMO
02:39:31 * donri is secretly working on a rewrite of vim2hs
02:39:40 <identity> Ah, neat!
02:39:56 <identity> I will more than happily be a guinea pig :)
02:39:57 * hackagebot classify 2013.11.6 - Library for classification of media files.  http://hackage.haskell.org/package/classify-2013.11.6 (DavidHimmelstrup)
02:39:57 <lambdatwo> Title: Hackage: classify: Library for classification of media files.
02:40:19 <donri> well it doesn't really do much yet, basically just basic syntax highlighting :p
02:41:01 <donri> https://github.com/dag/vim-haskell and https://github.com/dag/vim-cabal anyway. moving slow though
02:41:12 <identity> i tried disabling vim2hs -- i couldn't really do without it, and I decided that immediately just because of the syntax highlighting alone
02:41:37 <donri> hehe yeah i really don't like the standard syntax/haskell.vim either
02:41:59 <donri> but vim2hs is too invasive and heavy
02:42:06 <alexander__b> vim2hs syntax highlighting is good. I think. I have too many addons to tell.
02:42:24 <alexander__b> I'm pretty sure vim2hs does *something* though.
02:42:26 <donri> https://github.com/dag/vim2hs/issues/45
02:42:33 <identity> alexander__b: that is somewhat my feeling as well haha ;)
02:42:43 <identity> I had so many plugins I wasn't sure what was doing what
02:42:46 <identity> which was doing what*
02:43:07 <identity> I eventually removed necoghc and neocomplcache in favor of YCM, and some such
02:43:26 <identity> But I'm still not quite sure if syntastic is doing anything for me or if it's all ghcmod
02:43:54 <donri> ghcmod doesn't do anything unless commanded to
02:44:04 <alexander__b> ghc-mod is awesome
02:44:10 <donri> but syntastic uses ghcmod
02:44:18 <identity> donri: Oh, I know. I've got it doing hlint and typechecking on bufwrite
02:44:36 <identity> But iirc, I was getting error pointers on lines before installing syntastic
02:44:41 <alexander__b> autocmd BufWritePost *.hs GhcModCheckAndLintAsync
02:44:43 <alexander__b> autocmd BufReadPost *.hs GhcModCheckAndLintAsync
02:44:49 <identity> alexander__b: aye
02:44:50 <alexander__b> I use that, and then I put syntastic in passive mode for haskell
02:44:58 * hackagebot classify 2013.11.6.1 - Library for classification of media files.  http://hackage.haskell.org/package/classify-2013.11.6.1 (DavidHimmelstrup)
02:44:58 <lambdatwo> Title: Hackage: classify: Library for classification of media files.
02:45:07 <identity> I guess I'll have to look into that
02:45:24 <identity> hmm. I might be able to use that classify package
02:45:57 <identity> seems his docs are broken
02:46:23 <donri> or not built yet
02:46:27 <donri> see the 2012 version
02:46:33 <identity> yeah, saw the 2012
02:46:41 <donri> doesn't seem to do much, that package :)
02:46:43 <identity> donri: not built yet? does hackage build it?
02:46:49 <identity> nah, was a bit disappointed
02:46:49 <donri> yes
02:47:00 <identity> oh. I thought it was uploaded along with it or something
02:47:11 <donri> you can do that too these days, i think
02:47:49 <alexander__b> OK so now I have a bajillion haddock strings. now what? surely there is some way to use cabal or to make it pick up stuff recursively?
02:48:12 <donri> not sure what you're asking
02:48:17 <alexander__b> well... s/surely/hopefully, as I ended up having to do it manually with ghc-mod linting.
02:48:46 <alexander__b> donri: I have a bunch of files with haddock strings. I don't want to have to invoke "haddock src/file1.hs src/Module/file322.hs" and so on manually
02:49:01 <donri> oh. cabal haddock :P
02:49:05 <alexander__b> ah, nice
02:49:06 <donri> or install --enable-documentation
02:49:21 <donri> or documentation: True in ~/.cabal/config
02:49:39 <alexander__b> great. I'll search around for that stuff to figure out just how it works.
02:50:47 <identity> donri: anywho, thanks for vim2hs! It may not be perfect but I can't live without it :)
02:50:55 <identity> hmm, I say that about my girlfriend as well
02:51:14 <alexander__b> identity: your girlfriend is an "it"?
02:51:27 <alexander__b> I think she might take offense at that ;-)
02:52:04 <identity> alexander__b: well, substitute it for her etc. But yes, she definitely would
02:52:16 <identity> baby has a temper
02:52:44 <donri> \o/
03:02:43 <ibotty> hi
03:04:36 <ibotty> can i somehow tell in the types, that something like a Enum a => Map(a, SomeType) is fully inhabited?
03:04:58 <ibotty> what i mean is, that every lookup for a will return something
03:05:01 * hackagebot hxt 9.3.1.2 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.2 (UweSchmidt)
03:05:01 <lambdatwo> Title: Hackage: hxt: A collection of tools for processing XML with Haskell.
03:05:31 <ibotty> is there a data structure that can do that and maybe even enforce me to fully inhabit it
03:07:15 <startling> ()
03:07:43 <startling> ibotty, a -> SomeType is probably total (but this isn't enforced in haskell)
03:07:43 <identity> ibotty: you want to know if there's a way to tell from type signatures whether some kind of a map contains all possible elements and all lookups will succeed?
03:08:44 <ibotty> no, i am looking for alternatives to `Map` as i am sure, that it is not possible.
03:09:03 <ibotty> ah. 'some kind of map', yes
03:09:17 <donri> ibotty: only way to escape bottom in haskell is with datakinds, AFAIK
03:09:52 <startling> ibotty, well, (->) a is the only way to say it.
03:10:18 <ibotty> ic
03:10:44 <donri> Map.lookup already has this property
03:10:44 <donri> :t M.lookup
03:10:45 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
03:11:04 <identity> ibotty: I am no expert haskeller, but I reckon you could roll your own data type/newtype as a wrapper around a map with and Enum a constraint and ensure that all possible values of a are in the map
03:11:08 <startling> :t \k -> fromMaybe mempty . M.lookup k
03:11:08 <ibotty> but that's not easily used with traverse, etc. and will not let me use the fact, that it's bounded
03:11:08 <identity> but that sounds strange
03:11:09 <lambdabot> (Ord k, Monoid c) => k -> M.Map k c -> c
03:11:45 <startling> :t traverse `asAppliedTo` id
03:11:46 <lambdabot> (Applicative f, Traversable t) => (f b -> f b) -> t (f b) -> f (t b)
03:11:52 <lambdatwo>     Not in scope: `traverse'
03:11:52 <lambdatwo>     Perhaps you meant one of these:
03:11:52 <lambdatwo>       `Data.Traversable.traverse' (imported from Data.Traversable),
03:11:52 <lambdatwo> Ord k => k -> M.Map k a -> Maybe a
03:11:52 <lambdatwo> (Ord k, Monoid c) => k -> M.Map k c -> c
03:11:55 <donri> oic you basically want a Map pre-populated with enumFrom bounded, but without actually computing that up front
03:11:56 <startling> :t flip traverse `asAppliedTo` id
03:11:57 <lambdatwo>     Not in scope: `traverse'
03:11:57 <lambdatwo>     Perhaps you meant one of these:
03:11:57 <lambdabot> (Applicative f, Traversable ((->) a)) => (a -> a) -> (a -> f b) -> f (a -> b)
03:11:58 <lambdatwo>       `Data.Traversable.traverse' (imported from Data.Traversable),
03:12:15 <ibotty> donri:  right
03:12:16 <fizruk> ibotty, perhaps you want an array/vector?
03:12:46 <startling> ibotty, do you have a "default" value?
03:12:54 <ibotty> startling: no
03:13:08 <donri> hm if you don't have a default then how
03:13:30 <startling> fromJust, I guess.
03:14:41 <donri> Map.fromList (enumFrom minBound `zip` repeat def) -- is what i thought you wanted, in effect
03:16:43 <ibotty> fromJust will work, i know. but i'll phrase my question differently. i have the following reply: http://www.discogs.com/developers/resources/marketplace/price_suggestions.html, and i already have a type that enumerates the possible conditions. so whenever i get that suggestion i wanted to return (more or less) `Map(ListingStatus, CurrencyPrice)`
03:16:53 <lambdatwo> Title: Price Suggestions — Discogs API 2.0 documentation, http://tinyurl.com/q43q2gn
03:17:26 <ibotty> but as i know i'll return every price suggestion per status, i wanted to indicate it in the types
03:17:26 <jophish> Yo yo yo
03:18:02 <jophish> A rather unusual question for this channel:
03:18:07 <jophish> I'm writing a Haskell compiler which compiles to GLSL using LLVM. I can't seem to come up with a witty title for this
03:18:12 <jophish> can anyone help?
03:18:22 <donri> ibotty: that's Map.(!)
03:18:39 <ibotty> ic
03:18:47 <quicksilver> jophish: lambshade
03:18:47 <ibotty> so i'll just tell that in the documentation
03:18:51 <ibotty> that's fine with me
03:19:05 <startling> jophish: lowly
03:19:19 <donri> ibotty: actually http://hackage.haskell.org/package/total-map-0.0.4/docs/Data-TotalMap.html
03:19:20 <lambdatwo> Title: Data.TotalMap, http://tinyurl.com/qy52t9s
03:19:23 <jophish> quicksilver: pronounced lampshade?
03:19:24 <donri> found randomly now :)
03:19:47 <ibotty> that sounds exactly like what i had in mind
03:20:06 <jophish> startling: care to elaborate?
03:20:29 <ibotty> do you think i should go with that or should i just use a common map?
03:20:29 <quicksilver> jophish: probably. Just a weak pun on lambda and shader and lampshade :)
03:20:44 <quicksilver> jophish: maybe lambdshade is better.
03:20:57 <jophish> It's the best so far
03:21:14 <ibotty> quicksilver: i like your suggestion
03:21:14 <jophish> After perhaps: How to render a triangle in 5000 lines of code
03:21:17 <startling> jophish: lots of ls
03:21:32 * startling shrugs
03:21:42 <fizruk> jophish, sλady
03:22:09 <jophish> quicksilver: It seems as though lambshade is taken by a "music band"
03:22:14 <jophish> fizruk: That's good!
03:22:24 <fizruk> \o/
03:23:35 <donri> lambda of god!
03:24:38 <jophish> having a lambda in the title may make things hard to search for
03:25:28 <yesthisisuser> If i have a c program that I want to call using FFI.. Do I have to first compile it to a static library or can I link it directly?
03:25:32 <fizruk> jophish, i think shady with λ in logo
03:26:03 <tdammers> I'd read "sλady" as "slady"
03:26:14 <jophish> tdammers: me too
03:26:19 <tdammers> whatever that is supposed to mean
03:26:28 <tdammers> maybe s-Lady, the mistress of s-expressions
03:26:34 <benj_> Sλade
03:26:36 <jophish> in the manner of Slade?
03:26:40 <tdammers> some kind of lisp-fetish site or so
03:27:15 <fizruk> I guess λ is something both "h" and "l"
03:27:22 <donri> yesthisisuser: you can have cabal compile it for you or have it link an existing library
03:27:31 <fizruk> no idea how one generally reads that
03:27:46 <tdammers> it looks a bit like latin 'h', but the greek letter is pretty much 'l' I think
03:28:37 <fizruk> jophish, anyway, you can stick with either "shady" or "slade" or etc. and just use λ in the logo
03:30:23 <fizruk> tdammers, I just remember seeing λ as H in logo of something (can't remember what was it)
03:33:13 <jophish> so I guess the full title is: Sλady -or- An LLVM based functional shader compiler
03:33:23 <jophish> that's pretty dense
03:34:09 <fizruk> so it's "slady"?
03:34:20 <ij> How do I hint the type checker that I want an Int in place of the f type's "a", if the f returns (a, g)?
03:34:53 <fizruk> ij, f x y z :: (Int, g) ?
03:35:52 <yesthisisuser> it looks like I can just compile as usual, using ghc --make Main.hs stuff.h stuff.c
03:36:05 <jophish> fizruk: I prefer shady
03:36:07 <cariveri> hi. how do I get the typeName from a variable like in (type X = AC B C; let x = AC myb myc) ? ":t" reveals "AC B C" but not "X". how to?
03:36:18 <fizruk> jophish, me too :)
03:36:22 <donri> sλim shady
03:36:26 <quicksilver> you can't, cariveri
03:36:35 <quicksilver> that's just a synonym and there might be more than one
03:36:59 <quicksilver> if you explicity annotate a term with a synonym it does try to use it, though
03:37:10 <quicksilver> let x :: X; x = AC myb myc;
03:37:14 <cariveri> quicksilver: ok. can I restructure it to be able to make a typeNameOF x  function?
03:37:18 <quicksilver> ^^ I think that will show the type X
03:37:31 <yesthisisuser> perhaps using a newtype instead?
03:37:32 <cariveri> oh.. let me tr<
03:38:53 <quicksilver> using newtype is good if you really want it to be a different type, yes.
03:39:01 <quicksilver> I tend not to use type synynoms myself.
03:39:45 <chrisdone> Peaker: poke-er
03:39:59 <cariveri> ok. let x ::X must be declared where lehm is decalred. so that means not at runtime, I guess.
03:40:09 <cariveri> quicksilver: how would I use newtype ?
03:46:04 <ij> How may I loop/recurse a function of type IO a -> IO a? Are there any std functions for that?
03:47:10 <jophish> Say I have: newtype MyInteger = MyInteger Integer; Is there a way to have MyInteger be an instance of Integral by using the instance of Integer
03:47:22 <ij> Forever seems to be doing that, but it doesn't send the return value to the next iteratoin.
03:47:34 <jophish> without specifying all the methods of Integral manually
03:48:02 <quicksilver> jophish: yes.
03:48:05 <donri> @hoogle iterateM
03:48:05 <lambdabot> No results found
03:48:06 <lambdatwo> No results found
03:48:08 <quicksilver> deriving (Integral)
03:48:18 <jophish> oh, and that will just work?
03:48:21 <quicksilver> which is an extension called "GeneralisedNewtypeDeriving"
03:48:23 <jophish> great
03:48:28 <quicksilver> it just 'copies the methods through the newtype'
03:48:30 <quicksilver> as it were.
03:48:54 <donri> ij: maybe this? http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html
03:48:55 <lambdatwo> Title: Control.Monad.Loops, http://tinyurl.com/pgvfdkc
03:48:59 <jophish> quicksilver: thanks
03:49:15 <johnw> iterateM loops a -> m a
03:49:31 <johnw> iterate will loop m a -> m a
03:50:27 <donri> :t fmap sequence . iterate
03:50:28 <lambdatwo> Monad m => (m a -> m a) -> m a -> m [a]
03:50:30 <lambdabot> Monad m => (m a -> m a) -> m a -> m [a]
03:51:09 <jophish> quicksilver: It seems it necessary to derive a bunch more stuff too, such as Num, Real...
03:51:14 <jophish> but that's no problem
03:51:20 <quicksilver> jophish: yes, but it's no problem as you say.
03:51:28 <quicksilver> just stick them all in brackets
03:51:31 <quicksilver> :i Integer
03:51:39 <quicksilver> will give you a list of classes to consider deriving :)
03:53:49 <jophish> If only mercurial wasn't taken
03:53:55 <jophish> then Hg would be an excellent name
03:53:59 <donri> :t fixIO
03:54:00 <lambdatwo> Not in scope: `fixIO'
03:54:00 <lambdabot> Not in scope: `fixIO'
03:54:10 <merijn> :t mfix --?
03:54:10 <lambdatwo> MonadFix m => (a -> m a) -> m a
03:54:11 <lambdabot> MonadFix m => (a -> m a) -> m a
03:54:31 <merijn> I believe IO is a MonadFix
03:54:36 <donri> yes
03:54:39 <cariveri> quicksilver: I figured newtype does not help me. please have a look at http://pastebin.com/CmHHQ7tv . Id still like to either :getTypeAlias x or better yet call a typeNameOf x . in the paste x=lehm
03:54:45 <donri> i was hoping for a specialized type signature
03:54:45 <mauke> The paste CmHHQ7tv has been copied to http://lpaste.net/95279
03:56:21 <quicksilver> cariveri: I think you are asking the wrong question, and I do not understand what you are doing.
03:56:30 <quicksilver> "typeNameOf" is a very non-idiomatic idea
03:56:42 <quicksilver> (by all means see Data.Typeable and see if it does what you want, but heed the warning)
03:57:02 <quicksilver> there are almost certainly more natural ways to solve the actual problem you have at hand.
03:58:04 <Peaker> chrisdone: :)
03:58:30 <ij> donri, Thanks, I made it! \o/ I am still alive after this: http://sprunge.us/XJJP
03:58:43 <jophish> How about Ag - hAskell for graphics... stupid mercurial
03:58:45 <Peaker> chrisdone: I've not had much of a chance to toy with structural-haskell yet, had some emergencies that threw me behind schedule, so now that's an emergency too :P   In a couple of weeks, I hope to be more relaxed
03:58:48 <chrisdone> Peaker: pull latest shm!
03:58:58 <chrisdone> Peaker: ah, hehe
03:59:17 <Peaker> Will look at the git logs though :)
04:00:12 <Peaker> chrisdone: IME, TODO inside version control is a bit of a burden because branching/merging/rebasing becomes really annoying :)
04:00:16 <donri> :t sequence $ repeat $ state random
04:00:17 <lambdatwo> (MonadState s m, RandomGen s, Random a) => m [a]
04:00:18 <lambdabot> (MonadState s m, RandomGen s, Random a) => m [a]
04:01:06 <chrisdone> Peaker: yeah, the TODOs will be removed when i make a public release
04:02:31 <chrisdone> Peaker: i put the sub-expression thing on the backburner for now, while that's ideally where i'd like to go, it'll take more time to perfect. so for the time being it re-parses the whole declaration, but editing operations will still work on the existing parsed tree, it just can't be incrementally improved. at least, not in a way i'm happy with or that can be used for real work presently
04:04:12 <merijn> jophish: Hate to break it to you, but Ag is already a command too :)
04:04:14 <chrisdone> Peaker: (although the good news is it can be incrementally added)
04:04:15 <Peaker> chrisdone: are you using it for some work?
04:04:22 <Peaker> chrisdone: or not yet?
04:04:37 <merijn> jophish: "ag - The Silver Searcher. Like ack, but faster."
04:04:42 <jophish> merijn: :(, how about Sg
04:04:55 <merijn> jophish: I'm not aware of sg being anything
04:04:56 <jophish> haSkell for Graphics
04:05:04 <jophish> It's a little contrived
04:05:24 <jophish> I could make it a scheme compiler...
04:05:50 <chrisdone> Peaker: i've just now started using it. it's behaving well so far. i realised while writing this just how stable shm v1 was, and that a key to using that successfuly (at least inside my emacs setup) is that it recovers from failure very well. shm2 is shaping up to be better
04:06:17 <Peaker> chrisdone: Awesome :)
04:06:53 <jophish> Seaborgium?! I've never heard of that
04:18:44 <cariveri> quicksilver: ok I enabled Typeable, but still I dont understand how I would add my own type representation.
04:23:32 <cariveri> quicksilver: typeOF returns the type as expected, but I want it to return my own specification of that type. or typerepresentation. do you know how to?
04:27:03 <cariveri> can I overload functions derived form classes?
04:35:56 <quchen> Can someone explain the 'wrap' function from MonadFree to me? http://hackage.haskell.org/package/free-4.2/docs/Control-Monad-Free.html
04:35:57 <lambdatwo> Title: Control.Monad.Free, http://tinyurl.com/oqd4j68
04:36:28 <quchen> And for what that is useful
04:38:08 <quchen> Is it just the generic "append another action to the free monad" function?
04:38:10 <jophish> How about HaSl
04:48:09 <jmcarthur> quchen: basically, yes.
04:48:11 <kooellekarl> hello, what does "one-step beta reduction "can copy parts of a term, but is not parallel" mean?
04:48:54 <jmcarthur> quchen: Free just composes a functor with itself some number of times. wrap just adds another.
04:48:55 <kooellekarl> oh nevermind,
04:49:27 <kooellekarl> while writing the question the answer popped up in my head :)
04:50:05 <kooellekarl> besides, is it ok to ask questions about lambda calculus in here?
04:50:17 * hackagebot hist-pl-lexicon 0.6.1 - A binary representation of the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-lexicon-0.6.1 (JakubWaszczuk)
04:50:17 <lambdatwo> Title: Hackage: hist-pl-lexicon: A binary representation of the historical dictionar...
04:50:29 <fizruk> quchen, I understand wrap just like that, though an "action" could be "Bin a a" and so it would combine two "free monadic values"
04:51:31 <ski> kooellekarl : imo, yes
04:52:05 <ski> kooellekarl : by "one-step', do you mean "big-step" ?
04:52:39 <fizruk> ski: does your nickname refer to SKI combinators or skiing? :)
04:52:56 <ski> yes
04:53:03 <kooellekarl> ski: one single beta reduction step, not multiple or parallel ones
04:53:03 <fizruk> ok :)
04:53:38 <ski> kooellekarl : ok
05:06:16 <chrisdone> ski: jot!
05:06:36 <chrisdone> iota is cool
05:07:13 <chrisdone> only requires one combinator and grouping
05:08:38 <chrisdone> U = \xf.((fS)K), I = UU, K=U(U(UU)), S=U(U(U(UU)))
05:08:45 <chrisdone> mmm. sexy
05:08:48 <ski> <briennetheblue> ski: i think i found a nice example of before "f x `before` (guard . predicate) >>= ..."
05:08:52 <ski> nice
05:11:12 <quchen> chrisdone: That's a little too much syntax for my taste, I find it hard to remember
05:11:22 <quchen> In particular the different parentheses confuse me
05:11:28 <quchen> I prefer to code in Gödel numbering
05:11:56 <quchen> Unary encoding of course
05:15:42 <tdammers> I prefer nullary encoding
05:28:27 <kooellekarl> can anyone give me a hint how i can proof that it's undecidable to show that a \-term has a normal form?
05:29:10 <johnw> try to prove that its decidable and find a counter-example?
05:33:45 <kooellekarl> hmm
05:35:29 <nomeata> Hi. Is there a verified compiler for Haskell, or a toy funcional programming language with lazy evaluation? If not, why not? Should there be one?
05:35:35 <kooellekarl>  (\x.xx)(\x.xx) is not weak-normalizing, but does that show that this is undecidable?
05:35:40 <kooellekarl> don#t think so
05:35:59 <nomeata> (Yes, I raised that topic yesterday evening, but I’m still looking for more opinions ;-))
05:36:43 <kooellekarl> nomeata: sorry "don't think so" wasn't directed towards you, i have no idea
05:39:44 <asmyers> So this seems like a silly question but I can't find anything in the attoparsec docs
05:39:57 <asmyers> Is there a combinator for something that may or may not be there?
05:40:08 <johnw> you mean, zero or one?
05:40:12 <asmyers> yeah
05:40:18 <asmyers> I'm going to throw it away
05:40:20 <asmyers> so
05:40:32 <asmyers> zeroOrOne "foo" *> parseSomething
05:40:58 <asmyers> an optional prefix that I don't care about basically
05:41:41 <asmyers> I can use skip
05:41:44 <asmyers> but tha ttakes a predicate
05:42:01 <asmyers> I was wondering if there was something that just took the optional input directly
05:42:06 <johnw> you could use option
05:42:11 <johnw> and just throw away the result
05:42:18 <johnw> option "" "foo" *> parseSomething
05:42:35 <johnw> option "" (string "foo)" *> parseSomething
05:42:38 <donri> nomeata: (i don't have any answers, only questions, sorry!) what is verified compiler here?
05:43:08 <johnw> asmyers: ah, you want optional
05:43:15 <johnw> optional (string "foo") *> parse...
05:43:30 <johnw> :t optional
05:43:30 <lambdatwo> Alternative f => f a -> f (Maybe a)
05:43:31 <lambdabot> Alternative f => f a -> f (Maybe a)
05:43:32 <quicksilver> presumably optional x = x <|> empty
05:43:37 <johnw> yep
05:43:49 <quicksilver> oh, Just <$> x <|> Nothing $> empty
05:44:06 <asmyers> johnw: hmm strange, where is that defined?  I've literally searched for that exact thing
05:44:09 <quicksilver> modulo (1) precedence and (2) quicksilver getting operator names wrong
05:44:13 <asmyers> but don't see it
05:44:13 <johnw> it's in Control.Alternative
05:44:20 <johnw> it's more abstract than attoparsec
05:44:24 <asmyers> johnw: ah I see, I was looking in attoparsec
05:44:25 <quicksilver> this is a generic haskell documentation problem
05:44:29 <asmyers> johnw: Makes sense
05:44:37 <quicksilver> no clear way to document when some "obvious" notion is actually provided by a typeclass directly
05:44:40 <alexander__b> haasn: having a standardised html format for technical documentation sold me on haddock. also it looks really pretty.
05:45:04 <asmyers> Thanks for the help
05:45:26 <johnw> yeah, attoparsec should really re-export those
05:45:30 <johnw> along with many and some
05:45:42 <nomeata> donri: a compiler from, say, haskell to assembly with a formal proof that the semantics of the compiled program relates to the semantics of the haskell program
05:45:44 <alexander__b> is there a way to make the haddock docs embed the source?
05:46:11 <ij> I tried to install fclabels with cabal, which didn't fail, but when importing Data.Record.Label, it failed with: http://sprunge.us/RBhh
05:46:24 <alexander__b> like e.g. here http://www.haskell.org/ghc/docs/latest/html/libraries/hoopl-3.9.0.0/Compiler-Hoopl-Internals.html#t:MaybeO you see the "Source" links everywhere. can I make haddock do that with my project?
05:46:25 <lambdatwo> Title: Compiler.Hoopl.Internals, http://tinyurl.com/lnr3kfn
05:46:35 <johnw> yes
05:46:44 <alexander__b> do you happen to know how?
05:46:45 <johnw> pass --haddock-hyperlink-source to cabal
05:46:52 <alexander__b> excellent! thanks a lot
05:46:57 <donri> ij: the module is Data.Label
05:46:58 <alexander__b> is there a way to set this in project.cabal?
05:47:09 <johnw> i don't think so, actually
05:47:21 <johnw> i have a wrapper script named "cabal" to make sure I always use this flag
05:47:34 <alexander__b> cabal: unrecognized option `--haddock-hyperlink-source'
05:47:38 <ij> donri, Hmm, well when installing monad-state it was whining about the absence of "Data.Record.Label" too.
05:47:45 <johnw> what version is your cabal?
05:47:50 <donri> alexander__b: to cabal haddock it's just --hyperlink-source or something like that
05:47:51 <johnw> I use: --haddock-hoogle --haddock-html --haddock-executables --haddock-internal --haddock-hyperlink-source
05:48:00 <haasn> alexander__b: exactly
05:48:07 <haasn> alexander__b: everybody around here expects haddock documentation
05:48:10 <haasn> anything else is weird
05:48:10 <johnw> (on "cabal install")
05:48:10 <donri> ij: older version of fclabels
05:48:15 <alexander__b> johnw: I think --haddock-html is implicit
05:48:22 <alexander__b> at least I get html when running just cabal haddock
05:48:22 <ij> donri, Should I install it?
05:48:29 <alexander__b> donri: thanks
05:48:29 <johnw> --haddock-html gets disabled if you use --haddock-hoogle with also specifying it
05:48:33 <donri> ij: i can't answer that :)
05:48:34 <alexander__b> johnw: I see
05:48:53 <ij> donri, So what did you mean by "older version of fclabels"?
05:51:02 <alexander__b> so what's the common way of making sure docs get installed when people use cabal install?
05:51:19 <alexander__b> or with cabal build even, as that's what I do as a dev
05:51:42 <donri> ij: that module was in an older version
05:51:44 <dcoutts_> alexander__b: when you're hacking you can use cabal build; cabal haddock
05:52:09 <alexander__b> dcoutts_: OK so there's no way of making cabal haddock --executables --hyperlink-source a part of just "cabal build"?
05:52:18 <dcoutts_> alexander__b: no
05:52:22 <alexander__b> OK, thanks.
05:52:33 <alexander__b> so for cabal install for users, I just put something in project.cabal?
05:52:52 <alexander__b> (documentation: True)
05:52:59 <dcoutts_> alexander__b: right, the person building the package decided if they want docs, not the package author
05:53:34 <dcoutts_> alexander__b: so that's why that "documentation: True" thing lives in the user's cabal config, not in the project .cabal file
05:53:44 <alexander__b> dcoutts_: oh, OK, thanks
05:54:20 <dcoutts_> alexander__b: just like the person building the package (ie often the user) gets to decide which platform they build on, or where the files will be installed.
05:56:02 <fishduck> hai inventors and developers of haskell. How do you make monii of your invention?
05:56:06 <madariaga> Does someone remember the first time they said "this problem can be solved by creating this monad"? What sings were there that some problem was fit for that solution? (other than "debuggable functions")
05:56:59 <dcoutts_> fishduck: by making software that works
05:57:14 <zomg> madariaga: when you actually start understanding how monads work and know what monads there are available, that's when I started doing that :P
05:57:41 <tdammers> for a second, I thought someone had invented a new plural form of "monad"
05:58:12 <johnw> madariaga: usually when I find myself thinking that some kind of "context" must accompany every value I'm using in a region of my program; monads give me a way of operating on the values within the context such that any mutations of the context are preserved
05:59:29 <madariaga> johnw: I see
05:59:35 <tdammers> the most frequent situation for me to grab a monad is when I need to keep some kind of state around
05:59:43 <tdammers> i.e., StateT, ReaderT or WriterT
05:59:49 <johnw> i use ReaderT more than any other monad
06:00:07 <tdammers> I use StateT a lot too
06:00:13 <fishduck> dcoutts: I mean, do they not make any direct profit from haskell?
06:00:14 <tdammers> WriterT somewhat less so
06:00:22 <fishduck> dcoutts: or do they maintain haskell for free?
06:00:26 <khyperia> What's an idiomatic way to make an AST evaluate function... I've got a *bunch* of functions of the form "eval (Addition left right) = eval left + eval right" - seems like the right hand side could be applicative or some such thing, "(+) <$> left <*> right", but I'm not sure how to write that.
06:00:32 <madariaga> I wonder how common it is to say "I could model this in the way of a monad"
06:00:41 <dcoutts_> fishduck: oh, much of the original research was in academia
06:00:43 <johnw> I guess I don't use StateT much because usually the mutations I'm doing is asynchronous, so I use STM for managing statefulness
06:00:50 <ij> Where is monad actually defined?
06:00:52 <tdammers> fishduck: AFAIK, Haskell receives some heavy sponsoring from Microsoft Research
06:01:10 <fishduck> hmm, aight
06:01:18 <quchen> Heavy sponsoring?
06:01:19 <madariaga> other than the "classic" tutorial monads
06:01:27 <ij> Oh, it's control.monad.
06:01:30 <tdammers> well, idk how much it is exactly
06:01:42 <fishduck> tdammers: can't just someone fork haskell and get their own funding or something? Or make a better fork and STEAL that funding?
06:01:43 <quchen> tdammers: They pay SPJ, paid Marlow, and some interns I thought
06:01:47 <johnw> madariaga: actually, it's a lot more common than you'd think
06:01:48 <chrisdone> enough to pay spj and simon marlow for 15+ years
06:01:49 <dcoutts_> fishduck, tdammers: where heavy means 2-3 people for 10+ years
06:01:53 <quchen> tdammers: That's not "nothing", but also not "heavy" I think
06:01:58 <quchen> Ah okay.
06:02:01 <tdammers> that's more than I could afford ;)
06:02:10 <ij> So if something is a type of Monad, it just means it's composable with >>=/>>/return/fail?
06:02:21 <tdammers> and probably enough in itself to keep the project going
06:02:22 <madariaga> johnw: do libraries commonly provide a type that's a monad to use them?
06:02:30 <individual> I define a function 'concat'. How can I use it in the same module without conflicting with Prelude's concat?
06:02:32 <tdammers> (as long as you pay the right people)
06:02:35 <quchen> ij: Yes.
06:02:39 <dcoutts_> tdammers: sure, but also don't over-count it. There's lots of people at other academic institutions.
06:02:47 <johnw> madariaga: I'm not sure what you mean; ij listed the only operations that constitute a "Monad"
06:02:51 <tdammers> dcoutts_: oh yes, absolutely
06:02:52 <quchen> ij: A Monad is literally "something that has return and >>=, and obeys the Monad laws".
06:03:11 <ij> Hmm, well this is surprisingly simple.
06:03:29 <johnw> it's simplicity is what makes it complex
06:03:33 <ij> I suppose it's everything else that is coupled with it is complex.
06:03:39 <chrisdone> johnw: like Go
06:03:45 <johnw> yes, exactly like Go :)
06:03:47 <ij> the game?
06:03:51 <johnw> yeah
06:04:07 <johnw> the rules are few and easy to state, but the implications are tremendous and full of detail
06:04:12 <quchen> No, everything else that is coupled with it is also easy. The thing that makes Monads complex sometimes is that it has non-obvious instances. Finding those is tricky, using them easy.
06:04:36 <tdammers> the problem with understanding monads is not that they're complex: they're not. It's that they are such an abstract thing that it's difficult to develop an intuition.
06:04:37 <khyperia> Theoretically, I kind of like the thing that I learned when studying the phrase "a monad is a monoid in the category of endofunctors"... a monad is an extention on a functor that allows you to join "m (m a) -> m a", since you can define (x >>= f) = join (fmap f x)
06:04:52 <ij> Backgammon is complex, yet simple too. Might not be on par with Go, though.
06:04:58 <quchen> khyperia: That quote is a joke.
06:04:59 <madariaga> tdammers: exactly
06:05:05 <khyperia> I know, quchen
06:05:08 <khyperia> I still learned from it.
06:05:15 <johnw> Backgammon has way more rules
06:05:51 <khyperia> it helped me see the connection between monad and functor
06:06:10 <tdammers> I mean, observing that exception handling, doing I/O, carrying state around, logging, continuations, and a thousand other things all follow the same abstract kind of structure is quite a leap
06:06:20 <ij> Hmm, well maybe. Though most of it "checked" for me, without reading the rules and starting with some basic things, that I later found to be true.
06:06:41 <madariaga> johnw: I'm not entirely sure what I meant, sorry
06:07:16 <quchen> khyperia: "join" does not really appear in the quote directly though.
06:07:39 <quchen> The monoid part is that it doesn't matter whether you join "m (m (m a))" from outside or inside first.
06:07:56 <quchen> It's not "return >=> m = m >=> return = m".
06:08:07 <khyperia> It sort of does. Join is a monad's definition of the... shoot, I forget the name, the monoid combine operation
06:08:08 <quchen> Although that looks like a monoid too.
06:08:47 <khyperia> the doesn't matter which way is a property of a monoid, I think
06:09:11 <khyperia> since (a x b) x c == a x (b x c)
06:09:27 <quchen> <> is the usual Haskell name
06:09:35 <khyperia> ah, yeah, thanks.
06:10:14 <quchen> Sure, the above "return >=> m = m >=> return = m" looks like it's monoidal, but that is not the monoid your quote speaks of.
06:10:51 <khyperia> yes, I know
06:11:01 <khyperia> you gave that example, not me.
06:11:14 <quchen> join . join = join . fmap join   ← That is the associativity part of the monoid operation of the quote
06:11:23 <khyperia> Yes.
06:12:38 <khyperia> and "the definition of <> for monads" (even though there isn't one, just hang with me) is join, not >>= or >=>
06:13:38 <quchen> It's closely related to join, but yes.
06:13:49 <adimit> A question on ghci: my ghci does not have the :complete command (7.6.3, debian.) Why, and how can I fix that? (I need that command for emacs' haskell-mode.) Thanks!
06:13:55 <quchen> join is unary, and monoids have a binary operation.
06:15:30 <quchen> khyperia: This SO post shines some light on the quote: http://stackoverflow.com/a/3870310/1106679
06:15:49 <khyperia> yeah, I've studied that.
06:16:17 <khyperia> eh, we're trying to explain to each other what we both know
06:16:37 <khyperia> I'm just bad with words
06:16:44 <quchen> Deadlocked
06:18:16 <quchen> khyperia: We just get a lot of talk about that quote here, and I generally assume somebody mistook it for something remotely helpful instead of nothing but a joke. :-)
06:19:00 <khyperia> Well, I'm a strange person and like to understand things, even if they're jokes, heh.
06:19:09 <mr-> khyperia: you are completely correct in saying that join is the multiplication if you consider a monad as a monoid in endofunctors (endofunctors itself is monoidal with composition as product, so join _is_ binary)
06:19:11 <frx> quchen it is technically correct though, is it not?
06:19:22 <quchen> frx: Yes.
06:19:31 <shiona_> I still haven't learned how to read hackage, so I guess I'll have to ask you: How do I get (hour, min) <- getLocalHourAndMinute
06:20:33 <quchen> shiona_: I don't understand the question
06:21:23 <shiona_> what would be the implementatio of getLocalHourAndMinute, if it's type is IO((Int, Int))
06:21:30 <shiona_> its
06:21:53 <quchen> Oh, so you have something of type IO (Int, Int) and you want to get the (Int, Int)
06:22:02 <shiona_> No
06:22:25 <shiona_> I want ghci to kindly print me the clock
06:22:40 <Eduard_Munteanu> What do you call (A \ B) U (B \ A)? I want to do that for a Map.
06:22:43 <ion> Enter the name of the method in the ghci prompt.
06:22:47 <sopvop> http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-LocalTime.html
06:22:48 <lambdatwo> Title: Data.Time.LocalTime, http://tinyurl.com/nfp2mzr
06:22:49 <quchen> In that case what you wrote was correct. `do { (h, m) <- getLocalHourAndMinute; print (h, m) }` for example
06:22:53 <ion> err, s/method/action/
06:23:00 <quchen> Or shorter, `getLocalHourAndMinute >>= print`
06:23:03 <Eduard_Munteanu> It's a bit annoying there's no function that does that.
06:23:05 <sopvop> whoa, who is this lambda impostor?
06:23:06 <shiona_> sopvop: that's what I'm reading. I said I cannot understand what I am reading
06:23:15 <shiona_> quchen: there is no such function, how would you implement it
06:23:33 <int-e> Eduard_Munteanu: "symmetric difference"
06:23:45 <quchen> shiona_: There's the "time" package: http://hackage.haskell.org/package/time
06:23:45 <lambdatwo> Title: Hackage: time: A time library
06:23:46 <Eduard_Munteanu> Thanks.
06:24:36 <quchen> @botsnack
06:24:36 <lambdabot> :)
06:24:36 <lambdatwo> :)
06:24:37 <shiona_> quchen: are you willing to walk me through the hackage then?
06:24:38 <Eduard_Munteanu> I wonder how to implement it best... A \ B + A ∩ B + B \ A, where + is a variant on Either, perhaps?
06:24:46 <quchen> shiona_: Sure
06:24:58 <Eduard_Munteanu> Actually that's sort of what I want.
06:25:16 <shiona_> ok. Let's say I would start with getCurrentTime
06:25:18 <int-e> Eduard_Munteanu: mergeWithKey (\_ _ _ -> Nothing) id id
06:25:18 <mr-> Eduard_Munteanu: isn't that just the union?
06:25:25 <quchen> shiona_: Step 1: Randomly search for a place that could have your method. Data.Time.LocalTime looks promising.
06:25:41 <shiona_> that's IO UTCTime, so I assume it get's the time from system in some format
06:25:42 <Eduard_Munteanu> mr-: no, it's a disjoint union
06:26:12 <quchen> shiona_: Right, getCurrentTime :: IO UTCTime.
06:26:23 <quchen> And in the LocalTime module, there are functions to convert UTCTime to LocalTime.
06:26:29 <quchen> LocalTime contains stuff like minutes and hours.
06:26:36 <sopvop> shiona_: something like liftM (localTimeOfDay . zonedTimeToLocalTime) getZonedTime
06:27:11 <shiona_> sopvop: but that returns a LocalTime, how do I extract the pieces I'm interested in?
06:27:36 <sopvop> with todHour, todMin, todSec
06:27:46 <shiona_> ok, let's see
06:27:47 <sopvop> http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-LocalTime.html#v:TimeOfDay
06:27:48 <lambdatwo> Title: Data.Time.LocalTime, http://tinyurl.com/nfp2mzr
06:28:23 <quchen> shiona_: LocalTime has two fields, and one of them contains a TimeOfDay.
06:28:56 <quchen> shiona_: So you'd look at LocalTime, see what it consists of, and then look around whether any of its contents consist of useful data.
06:29:10 <Eduard_Munteanu> int-e: hm... I think I want  mergeWithKey (const Change) Remove Add   where data Diff a = Remove a | Change a a | Add a   as I'm implementing some sort of diff.
06:29:42 <shiona_> I tried using todMin etc. before asking you but somehow I messed it up
06:29:44 <Eduard_Munteanu> I thought mergeWithKey would be overkill and didn't even look at it, but it seems to do exactly what I want.
06:29:46 <shiona_> but I'll try again
06:29:56 <Eduard_Munteanu> Thanks.
06:30:59 <Eduard_Munteanu> Er, should be \_ a b -> Just (Change a b)
06:31:40 <Eduard_Munteanu> And fmap on the others.
06:35:27 <shiona_> hmm, now that I think of it, is there a nicer way of getting minutes since midnight?
06:36:12 <quchen> hours * 60 + minutes?
06:36:28 <shiona_> quchen: ok, so no
06:37:15 <Eduard_Munteanu> Good, it works.
06:37:26 <Eduard_Munteanu> I got myself a kernel config diff.
06:41:07 * hackagebot abstract-par 0.3.3 - Type classes generalizing the functionality of the 'monad-par' library.  http://hackage.haskell.org/package/abstract-par-0.3.3 (RyanNewton)
06:41:08 <lambdatwo> Title: Hackage: abstract-par: Type classes generalizing the functionality of the 'mo...
06:42:04 <Eduard_Munteanu> I should finish the Kconfig toolkit I started, sometime.
06:59:11 <fizruk> I want to try and write some deriveClass stuff with TH, what should I read for that?
07:00:32 <donri> fizruk: why not Generic
07:00:38 <chrisdone> ghc manual on template haskell, existing TH codebases like persistent, lens
07:01:16 <chrisdone> donri: why not Genericberg?
07:01:26 <fizruk> donri, haven't used Generic either, how should I use it?
07:01:46 <chrisdone> fizruk: with great difficulty, apparently
07:02:09 <fizruk> chrisdone, okay :)
07:02:21 <fizruk> thanks for the response!
07:02:51 <donri> chrisdone: -XDeriveZoidberg
07:03:28 <donri> #define whynot deriving
07:04:00 <chrisdone> Monoidberg
07:04:23 <donri> fizruk: http://www.haskell.org/haskellwiki/GHC.Generics
07:04:25 <lambdatwo> Title: GHC.Generics - HaskellWiki
07:05:36 <tdammers> > forever $ putStr "woob"
07:05:38 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
07:05:38 <lambdabot>    arising from a use ...
07:05:38 <lambdatwo>   No instance for (GHC.Show.Show (GHC.Types.IO b0))
07:05:38 <lambdatwo>    arising from a use of ...
07:06:03 <fizruk> donri, if my Class is for types of kinds (* -> *) -> * -> *, will Generic approach (whatever it is) work?
07:06:22 <fizruk> s/types/type constructors/
07:06:35 <donri> maybe not
07:06:45 <donri> i wonder if they're making a polykinded Generic...
07:06:56 <donri> dreixel?
07:07:26 <fizruk> donri, ok, so I'll stick to TH for now :)
07:08:02 <donri> fizruk: ok see source for some of these http://hackage.haskell.org/packages/search?terms=derive
07:08:03 <lambdatwo> Title: Hackage: Package search
07:08:31 <fizruk> donri, thanks!
07:11:18 * hackagebot snaplet-redis 0.1.3.1 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.3.1 (DmitryDzhus)
07:11:19 <lambdatwo> Title: Hackage: snaplet-redis: Redis support for Snap Framework
07:22:38 <Reite> Is there a function: a -> Set a -> Maybe (Set a) that returns Nothing if a is already in the set?
07:23:59 <FreeFull> Reite: I don't think so, what do you need it for?
07:25:51 <Reite> FreeFull: Im generating IDs for json objects based on their content, and it might happen that they get the same id, in that case I want to change it a bit so its unique.
07:26:51 <edwardk> jmcarthur: so i made the simplest change to get the overmars representation into structures for Map. it slows things down quite a bit, but i'm hopeful i can adapt the algorithm in less elegant ways to get the speed i want
07:27:16 <Reite> I could do a member check first then insert, but it seems unnecessary to traverse it 2 times.
07:30:43 <chrisdone> Reite: what type is the ID?
07:30:59 <jmcarthur_mobile> edwardk: disappointing, but not unexpected
07:32:41 <Reite> chrisdone: Integer or Text for now, but I think it should work with any Ord
07:48:15 <adimit> Reite: what you're looking for is insertWith, I think.
07:48:31 <adimit> (Though I don't know if Data.Set has it, I work with unordered-containers, usually.)
07:49:14 <adimit> nope, not in there.
07:49:17 <adimit> bummer.
07:49:42 <mr-> it does have union, which prefers the first element
07:50:25 <chrisdone> i was wondering whether you could use a buffered array, if speed's a concern
07:51:39 <chrisdone> i.e. allocate an array of 1024, when you hit the max, reallocate it to 2024. then use the array for doing O(n) lookup
07:51:44 <chrisdone> sorry, O(1)
07:51:46 <chrisdone> lol
07:51:49 <adimit> funny, it's not even in unordered-containers' HashSet. But it's a pure value-based function for HashMaps: insertWith :: (v -> v -> v) -> k -> v -> HashMap k v -> HashMap k v
07:52:48 <chrisdone> i mean an array type is generally going to be a set restricted to ints anyway, it's just array re-sizing isn't probably as fast (or maybe it is?), would have to benchmark
07:53:36 <Reite> Performance was why I asked yes, its kind of premature optimization but I wanted the best way, and it seems it should be a solved problem
07:53:44 <Reite> its basically hash collision detection isnt it?
07:55:27 <chrisdone> yeah. i need something similar actually on a project. need a pool of unique ids to extract from and restore. was just going to use a Set of Ints, probably, but performance isn't a biggie for me
07:55:36 <adimit> Reite: Data.Set doesn't hash.
07:55:47 <chrisdone> adimit: he's doing the hash himself
07:55:58 <chrisdone> there is a Hashable library, though
07:56:17 <adimit> yes, Data.HashSet does hash :-)
07:56:43 <chrisdone> http://hackage.haskell.org/package/hashable-1.2.1.0/docs/Data-Hashable.html
07:56:43 <lambdatwo> Title: Data.Hashable, http://tinyurl.com/nanrtpr
07:56:48 <biscarch> is there a way to import from a specific package when two packages export the same Module (function)?
07:57:42 <mr-> biscarch: import qualified Foo as Foo ?
07:57:50 <chrisdone> and http://hackage.haskell.org/package/unordered-containers-0.2.1.0/docs/Data-HashSet.html
07:57:51 <lambdatwo> Title: Data.HashSet, http://tinyurl.com/mxgqwbp
07:58:15 <chrisdone> biscarch: with the PackageImports extension
07:58:29 <biscarch> chrisdone: Thanks
07:58:30 <chrisdone> import  "packagename" Blah
08:03:10 <dEPy> I dont get what reader monad actually is good for, it looks like a normal function with 1 argument -> http://adit.io/posts/2013-06-10-three-useful-monads.html
08:03:11 <lambdatwo> Title: Three Useful Monads - adit.io
08:05:30 <Iceland_jack> dEPy: It's good for read-only environments
08:06:00 <Iceland_jack> for example if you have a configuration, instead of passing it as an explicit argument to every function:
08:06:01 <Iceland_jack>     foo ∷ Config → a → b → c
08:06:01 <Iceland_jack>     foo conf = …
08:06:01 <Iceland_jack>  
08:06:19 <Iceland_jack> You can use the reader monad:
08:06:19 <Iceland_jack>     foo ∷ a → b → Reader Config c
08:06:19 <Iceland_jack>  
08:06:23 <FreeFull> Also good if you want to use join on a function
08:06:36 <chrisdone> dEPy: functions with arguments are explicitly passed around. with reader it's implicit in the monad
08:06:38 <Iceland_jack> FreeFull: …really?
08:06:39 * geekosaur considers that last more of an obfuscation, usually
08:06:40 <FreeFull> > let square = join (*) in square 30
08:06:41 <lambdatwo>   900
08:06:42 <lambdabot>   900
08:06:50 <chrisdone> ohhh
08:07:00 <geekosaur> (join, that is)
08:07:01 <chrisdone> he means the reader monad, not the Reader monad
08:07:05 <chrisdone> k
08:07:27 <Iceland_jack> ((→) r) isn't as useful as most of the other instances
08:07:33 <briennetheblue> ((->) a) monad is very useful for writing idiomatic #haskell
08:07:45 <Iceland_jack> and the join example is ridiculous
08:07:46 <dEPy> I still have no clue what you talkin about. :/
08:07:55 <Iceland_jack> dEPy: Do you know what monads are?
08:08:16 <dEPy> how is  runReader something $ "param"   better than normal function    something "param"
08:08:19 <FreeFull> A Reader-Writer-State (RWS) combo is common
08:08:42 <dEPy> I have a basic understanding of monads yes
08:08:47 <Iceland_jack> dEPy: Of course it isn't going to make sense if you're writing a one-liner
08:09:17 <quicksilver> dEPy: it's not better.
08:09:18 <chrisdone> > runReader (do x <- ask; return (x*x)) 2
08:09:19 <lambdatwo>   4
08:09:19 <dEPy> Then that example (http://adit.io/posts/2013-06-10-three-useful-monads.html) is just not good.
08:09:20 <lambdabot>   4
08:09:20 <lambdatwo> Title: Three Useful Monads - adit.io
08:09:29 <quicksilver> where it (might) be better is inside the writing of 'something'
08:09:46 <quicksilver> having the param implicitly passed to everything may be more convenient than manually threading it everywhere.
08:09:50 <quicksilver> or it may not be.
08:09:57 <quicksilver> such automated plumbing is a trade-off but is useful at times.
08:10:24 <dEPy> can someone point me to a good example (but not too complicated) ?
08:10:37 <Iceland_jack> dEPy: What I just posted above
08:10:49 <Iceland_jack> You have a bunch of functions that depend on some global configuration
08:10:50 <dEPy> but in this example, the name is passed to greeter same as the function
08:11:10 <Iceland_jack> it isn't passed to ‘greeter’
08:11:24 <Iceland_jack> greeter doesn't have any arguments
08:12:06 <dEPy> this is so confusing :D
08:12:28 <dEPy> everytime you runReader on greeeter you need to pass that parameter
08:12:39 <Iceland_jack> dEPy: You only runReader once
08:12:49 <himh> Hi. If I have a stateful function that I want to call multiple (possibly n) times in the do block of main, how can I achieve this without hard coding the calls n-times?
08:12:54 <Iceland_jack> you can then combine multiple instances together that use the Reader monad
08:13:04 <Iceland_jack> himh: replicateM
08:13:11 <fizruk> :t replicateM_
08:13:12 <lambdatwo> Monad m => Int -> m a -> m ()
08:13:12 <lambdabot> Monad m => Int -> m a -> m ()
08:13:12 <Iceland_jack> @ty replicateM_
08:13:13 <lambdatwo> Monad m => Int -> m a -> m ()
08:13:13 <lambdabot> Monad m => Int -> m a -> m ()
08:13:16 <dEPy> Iceland_jack: ok how to I do that?
08:13:31 <fizruk> wow, there's two of them :)
08:13:32 <Iceland_jack> dEPy: The same way you combine monads
08:13:43 <Iceland_jack> or monadic values
08:13:52 <FreeFull> :t runReader (do x <- ask; y <- ask; return (x*y))
08:13:53 <lambdatwo> Num r => r -> r
08:13:53 <lambdabot> Num r => r -> r
08:14:15 <himh> Iceland_jack: Thanks! :)
08:14:31 <Iceland_jack> himh: replicateM if you want the results, repliateM_ if you want to ignore them
08:14:52 <FreeFull> Ignoring results in the Reader monad wouldn't be very useful
08:15:33 <Iceland_jack> FreeFull: I wasn't talking about the Reader monad
08:15:43 <chrisdone> > let f = (do x <- ask; return (x*x)); g = (do x <- ask; return (x+x)) in runReader (do a <- f; b <- g; return (a,b)) (5 :: Int)
08:15:44 <lambdatwo>   (25,10)
08:15:45 <lambdabot>   (25,10)
08:15:57 <chrisdone> dEPy: ^ see here. f and g don't take any arguments, and i only pass 5 once
08:16:16 <chrisdone> dEPy: they both "ask" from the environment to get that implicit argument
08:16:16 <FreeFull> You don't actually need runReader there AFAIK
08:16:22 <FreeFull> Not for the simple Reader monad
08:16:41 <dEPy> chrisdone: ok that makes alot more sense now
08:20:09 <dreixel> donri: what was it?
08:20:21 <quicksilver> FreeFull: if you leave out runReader then it works in the (->)r monad rather than the Reader monad
08:20:31 <quicksilver> FreeFull: (they are of course the same monad but one has a newtype in the way)
08:21:53 <Eduard_Munteanu> Is there a full-blown Text API for Parsec? A lot of Parsec things still use String even with the Text variant, I'm worried packing will hurt performance.
08:22:43 <identity> Eduard_Munteanu: if you're worried about performance, why not use attoparsec?
08:22:46 <identity> it does Text as well
08:24:13 <Eduard_Munteanu> identity: I keep jumping between the two, hm.
08:25:48 <Eduard_Munteanu> Ah, I remember what annoyed me about attoparsec last time... namely that you can't easily capture the input consumed by a parser.
08:26:25 <identity> Eduard_Munteanu: it, too, has some Char stuff for Text that amounts to [Char], but it mentions it in the docs and you can use other combinators instead
08:26:28 <identity> Eduard_Munteanu: ah.
08:27:21 <Eduard_Munteanu> identity: er, actually I was thinking about the Parsec tokenizer. I think attoparsec doesn't even have that.
08:30:15 <dEPy> ok let's say I have this  reader monad  hello and by runing  runReader hello $ "Myname" it gives me "Hello, Myname!"
08:30:38 <dEPy> how can I combine two of these without "do" syntax?  with the >>=   ?
08:30:50 <dEPy> I can't seem to get it right
08:30:58 <ion> Sorry, which two? I didn’t see do notation in your example.
08:31:02 <Iceland_jack> dEPy: Which two?
08:31:08 <Saizan> Eduard_Munteanu: trifecta should have that
08:31:13 <mr-> dEPy: can you link the example again?
08:31:19 <Iceland_jack> You sound a bit confused about how the Reader monad (monads?) work
08:31:25 <Eduard_Munteanu> Hm, I should try it sometime.
08:31:47 <dEPy> these two "hello" reader monads http://adit.io/posts/2013-06-10-three-useful-monads.html
08:31:48 <lambdatwo> Title: Three Useful Monads - adit.io
08:31:59 <Eduard_Munteanu> Three little piggies?
08:32:05 <dEPy> I mean "greeter"
08:32:11 <donri> dreixel: oh just wondering if there's any work towards polykinded Generic a la the new Typeable, if that's even possible / makes sense
08:32:31 <ion> @undo do name <- ask; return ("hello, " ++ name ++ "!")
08:32:31 <lambdabot> ask >>= \ name -> return ("hello, " ++ name ++ "!")
08:32:32 <lambdatwo> ask >>= \ name -> return ("hello, " ++ name ++ "!")
08:32:45 <Iceland_jack> > runReader (do name <- ask; return ("Hello, " ++ name ++ "!")) "Myname" -- dEPy
08:32:46 <lambdatwo>   "Hello, Myname!"
08:32:46 <lambdabot>   "Hello, Myname!"
08:33:00 <Eduard_Munteanu> Polykinds are pretty cool, not just for that, but for some kind safety as well.
08:33:05 <ion> > "Department of Redundancy Department"
08:33:05 <lambdatwo>   "Department of Redundancy Department"
08:33:06 <mr-> dEPy: greeter is not a monad it is a value with type Reader String String
08:33:06 <lambdabot>   "Department of Redundancy Department"
08:33:06 <dEPy> is there "undo" in ghci?
08:33:09 <himh> If I have a list of indices represented as Integer and another list, how can I fetch all of the elements of the second list that correspond to the indices represented in the first?
08:33:16 <Iceland_jack> dEPy: No
08:33:32 <ion> depy: Not by default. But the desugaring rules for do notation are straightforward.
08:33:38 <Iceland_jack> himh: reader monad! (for one)
08:34:06 <Eduard_Munteanu> himh: map (!! xs) is
08:34:13 <Iceland_jack> > let indices = [1,3,5] in mapM (flip (!!)) indices "testing" -- himh
08:34:13 <lambdatwo>   "etn"
08:34:14 <lambdabot>   "etn"
08:34:16 <Eduard_Munteanu> himh: but really, you shouldn't be using a list
08:34:18 <Iceland_jack> ;P
08:34:22 <ion> depy: “Translation” http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
08:34:23 <lambdatwo> Title: 3 Expressions, http://tinyurl.com/85p9zsr
08:34:32 <Eduard_Munteanu> For the 'xs'.
08:34:55 <Eduard_Munteanu> Er, probably (xs !!).
08:35:04 <Iceland_jack> Eduard_Munteanu: Yes
08:35:15 <ion> “greeter returns a Reader monad”, huh? depy: You might not want to use http://adit.io/posts/2013-06-10-three-useful-monads.html, it lies to you.
08:35:17 <lambdatwo> Title: Three Useful Monads - adit.io
08:36:27 <himh> Eduard_Munteanu: I'm running into difficulties because the indices are represented as Integers, not Int so the (!!) operator doesn't seem to work
08:36:35 <Iceland_jack> himh: Just convert them to Int
08:37:12 <himh> Iceland_jack: how? I only found toInteger but not toInt
08:37:18 <Eduard_Munteanu> himh: fromIntegral
08:37:18 <Iceland_jack> :t fromIntegral (undefined :: Integer) :: Int -- himh
08:37:19 <lambdatwo> Int
08:37:19 <lambdabot> Int
08:37:38 <Eduard_Munteanu> lambdabot: no no, you're not allowed to bring your friends
08:37:58 <geekosaur> lambdatwo: @part
08:37:58 <lambdatwo> Not enough privileges
08:38:00 <geekosaur> bah
08:38:01 <dv-> there are two, just in case one gets it wrong
08:38:10 <Iceland_jack> But like Eduard_Munteanu said, you shouldn't be using lists for any serious work since they don't provide random-access
08:38:23 <Iceland_jack> *for any serious indexing
08:38:35 <Lethalman> ops sorry
08:38:47 <Lethalman> I've commented this server
08:38:50 <Lethalman> still started
08:38:59 <Eduard_Munteanu> dv-: we could've used a majority voting system if we had three!
08:39:26 <Lethalman> lambdatwo joined despite I've commented this server in the config :-(
08:39:33 <Iceland_jack> > let indices = [1,5,10,14] :: [Integer] in map (\ind -> "this is my string" !! fromIntegral ind) indices -- himh
08:39:34 <lambdabot>   "hi i"
08:39:34 <Eduard_Munteanu> lambdabot... now with ECC.
08:40:37 <Iceland_jack> Before one of the (other) #haskell smart-asses point out '("hi" !!) ∘ fromIntegral' :)
08:40:46 <Iceland_jack> *points
08:41:41 <himh> Iceland_jack: what do you recommend as an alternative to list?
08:41:55 <Iceland_jack> depends on what you're after, Seq or Vector should be fine
08:42:12 <dv-> Eduard_Munteanu: it's all rigged maaan
08:42:14 <Iceland_jack> a neat trick I sometimes do is to define sequences that I index into a lot as functions of their indices like in mathematics or Clojure:
08:42:14 <Iceland_jack>     list = ("list" !!)
08:42:14 <Iceland_jack> since I hate the (!!) syntax
08:42:52 <Eduard_Munteanu> himh: if you want an array, use one. Or Data.IntMap if it's sparse.
08:43:08 <Eduard_Munteanu> himh: but what are you trying to write?
08:45:53 <himh> Eduard_Munteanu: Just a toy program, but essentially I'm reading a large-ish text file, one record per line, and then selecting the lines that I want from that file
08:46:09 <Iceland_jack> himh: I say try to write it using lists first :)
08:46:20 <HugoDaniel> how can i disable the "No explicit associated type or default declaration" warning in ghc ?
08:46:26 <Eduard_Munteanu> himh: by line number? Is there a more direct criteria you can use?
08:46:42 <himh> Iceland_jack: I've got it to work with lists, I tried to refactor using ByteStrings to get some performance improvement
08:46:49 <himh> Eduard_Munteanu: Unfortunately not
08:46:55 <Eduard_Munteanu> himh: Text is more appropriate for text
08:47:21 <dreixel> donri: have thought about it, but it's not so easy
08:47:33 <dreixel> donri: http://dreixel.net/research/pdf/trkgp.pdf
08:48:06 <donri> dreixel: cool thanks
08:48:15 <kooellekarl> is there a named function for the S combinator in haskell?
08:49:25 <ion> (<*>) or ap. I prefer the former due to its lack of a Monad constraint.
08:49:27 <monoidal> kooellekarl: ap
08:49:41 <kooellekarl> thank you
08:49:50 <ion> But for using it as S it doesn’t matter.
08:49:57 <monoidal> you need an instance of Monad (or Applicative) for r ->, but this is the default in 7.6
08:50:33 <Iceland_jack> kooellekarl:
08:50:33 <Iceland_jack> @pl \x y z -> x z (y z)
08:50:33 <lambdabot> ap
08:50:38 <Iceland_jack> :t \x y z -> x z (y z)
08:50:39 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
08:50:45 <Iceland_jack> @djinn (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
08:50:45 <lambdabot> f a b c = a c (b c)
08:50:46 <kuznero> Hi All!
08:50:50 <Iceland_jack> hi kuznero
08:51:01 <monoidal> kooellekarl: I recommend the paper introducing Applicative http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf to see how ap fits the more general framework.
08:51:20 <kooellekarl> monoidal: thanks i#ll have a look
08:52:33 <FreeFull> @@ @pl @djinn (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
08:52:33 <lambdabot>  f = ap
08:52:34 <himh> Iceland_jack: Is there a canonical way to read the contents of a file into a vector?
08:52:50 <Iceland_jack> I don't think so
08:53:20 <himh> Ok. Thanks for the help
08:54:25 <kooellekarl> so id = ap const const, why not ap const ap?
08:55:36 <monoidal> kooellekarl: that too, but it has less polymorphic type
08:55:55 <monoidal> (ap const const) x = ap const const x = const x (const x) = x
08:55:57 <khyperia> what's a good way to evaluate an AST? It seems like there's a better way than having a ton of functions of the form "eval (Add left right) = eval left + eval right"... specifically, I'm looking for a way to get rid of all the eval recursive calls. I was thinking maybe Applicative, (+) <$> left <*> right, but I'm not sure how that would work.
08:56:26 <monoidal> khyperia: I'm afraid the canonical way is using "eval" recursively
08:56:42 <monoidal> khyperia: you can use Applicative to avoid passing the environment many times
08:56:46 <khyperia> alright, just making sure there wasn't a fancy way, heh.
08:56:48 <glguy> khyperia: You can parameterize your expressions by their recursive type
08:57:07 <khyperia> what, glguy?
08:57:09 <glguy> and then provide a combinator:  (Expr a -> a) -> "RecursiveExpr" -> a
08:57:25 <glguy> newtype RecursiveExpr = RE (Expr RecursiveExpr)
08:57:32 <monoidal> data Expr a = Add a a | Num a
08:57:37 <fizruk> hmm.. why is not $> in Data.Functor ?
08:58:30 <mr-> :t ($>)
08:58:31 <lambdabot>     Not in scope: `$>'
08:58:31 <lambdabot>     Perhaps you meant one of these:
08:58:31 <lambdabot>       `$' (imported from Data.Function),
08:58:39 <khyperia> monoidal: it'd be data Expr a = Add (Expr a) (Expr a) | Num a
08:58:47 <fizruk> :t (Control.Comonad.$>)
08:58:48 <lambdabot> Functor f => f a -> b -> f b
08:58:56 <monoidal> khyperia: if you follow glguy's advice, you can use what I wrote
08:59:07 <fizruk> :t (<$)
08:59:08 <lambdabot> Functor f => a -> f b -> f a
08:59:12 <kooellekarl> monoidal: (ap const const) 1 == 1 but (ap const ap) 1 == No instance for (Num (m0 (a0 -> b0)))
08:59:12 <khyperia> I'm not sure what glguy is *saying*...
08:59:55 <monoidal> kooellekarl: ap const ap 1 = const 1 (ap 1) <- and "ap 1" does not make sense without a funky instance
09:00:13 <khyperia> Oh... and then have... hmm...
09:00:24 <monoidal> khyperia: you know how fix (Y) works? it abstracts recursion to a single combinator
09:00:40 <nyancats> I'm trying to define an Executable that depends on a Library defined in the same .cabal file, but cabal is telling me I need to add said package to the Executable's build-depends. what is going on?
09:00:45 <monoidal> khyperia: here you can abstract recursion hidden in your Expr type, and make the dependency explicit
09:00:53 <glguy> khyperia: I'll make you an example
09:01:09 <ski> > fromHFS (toHFS "{{{},{}},{{},{{}}}}" `differenceHFS` toHFS "{{{}}}")
09:01:10 <kooellekarl> monoidal: so S K S /= I?
09:01:13 <lambdabot>   "{{{},{{}}}}"
09:01:28 <ski> > map fromHFS [toHFS "{}" ..]
09:01:31 <monoidal> kooellekarl: with types, S K S has different type than I
09:01:31 <khyperia> I think I get it, although it's very hard to understand this chatroom with join and part messages (I'm at school on webchat)
09:01:32 <lambdabot>   ["{}","{{}}","{{{}}}","{{},{{}}}","{{{{}}}}","{{},{{{}}}}","{{{}},{{{}}}}",...
09:01:34 <fizruk> @pl m >>= return x
09:01:37 <lambdabot> m >>= return x
09:01:37 <lambdabot> optimization suspended, use @pl-resume to continue.
09:01:56 <monoidal> kooellekarl: in an untyped language, S K S are beta-eta equivalent
09:02:01 <monoidal> S K S and I
09:02:04 <fizruk> @pl m >> return x
09:02:04 <lambdabot> m >> return x
09:02:24 <maik_> I just finished 'lyah' and I am in need of some very simple libs that I can read. Any recommendations?
09:02:29 <kooellekarl> ahh that explains a lot still at untyped lambda calculus here, thanks monoidal
09:02:57 <FreeFull> @pl \m x -> m >>= return x
09:02:57 <lambdabot> (. return) . (>>=)
09:03:01 <maik_> bigger examples would suffice too
09:03:29 <monoidal> note m >>= return x and m >> return x are different.
09:03:42 <FreeFull> @pl \m x -> m >> return x
09:03:45 <lambdabot> flip ((.) . (>>)) return
09:03:45 <lambdabot> optimization suspended, use @pl-resume to continue.
09:03:59 <FreeFull> Accidentally wrote >>=
09:04:15 <zebr> hi all. are there any examples of simple, common, third-order functions? they seem a rare breed.
09:04:44 <FreeFull> What would a third-order function be?
09:04:59 <nyancats> someone help me with my cabal issues!!!!!
09:05:11 <zebr> FreeFull: something with a type like :: ((a -> b) -> c) -> d
09:05:24 <FreeFull> Oh, I see
09:05:27 <glguy> khyperia: http://lpaste.net/95289
09:05:36 <lpaste> glguy pasted “exprs” at http://lpaste.net/95289
09:05:56 <FreeFull> @hoogle ((a -> b) -> c) -> d
09:05:56 <lambdabot> No results found
09:06:14 <mr-> FreeFull: undefined!
09:06:16 <khyperia> Oh, huh, thanks!
09:06:17 <Philonous> @type flip (<$) -- FreeFull
09:06:18 <lambdabot> Functor f => f b -> a -> f a
09:06:57 <FreeFull> Philonous: fizruk was the one messing around with that
09:07:17 <monoidal> zebr: >>= of the continuation monad is third order
09:07:51 <FreeFull> I have seen functions that took functions that took functions before
09:08:15 <fizruk> Philonous, I was wondering why ($>) is not in Data.Functor (or at least Control.Applicative), but only in Control.Comonad (in comonad package)
09:08:29 <monoidal> zebr: if you look at what is internally going on in Parsec, you will probably see third- or fourth order functions
09:09:10 <Philonous> fizruk, Oh, yeah, I wonder that myself.
09:09:20 <ion> nyancats: That tone of voice will discourage people from helping you. Anyway, try doing what it suggests.
09:09:41 <nyancats> ion: I did that obviously...and that gave compile errors
09:10:13 <monoidal> zebr: there's a paper by okasaki containing 6-th order functions, but I haven't read it. http://dl.acm.org/citation.cfm?id=969615
09:10:32 <fizruk> FreeFull, Cont ~ ((a -> r) -> r), StateT s Cont ~ s -> (((a, s) -> r) -> r)
09:10:38 <zebr> monoidal: oh my.
09:11:07 <nyancats> ion: I've never had to add the package itself to a build-depends on an executable
09:11:56 <glguy> nyancats: You should make sure the executable and library sources are in different directories as specified by hs-sources-dir
09:12:04 <glguy> and then the executable should list the library in its build-depends
09:12:17 <fizruk> :t callCC
09:12:17 <nyancats> glguy: why can't they be in the same directory?
09:12:18 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
09:12:19 <glguy> otherwise it will rebuild all those modules once or for the library and once for the executable and not actually use the library
09:12:26 * hackagebot git-annex 4.20131106 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20131106 (JoeyHess)
09:12:34 <monoidal> zebr: ^ see callCC
09:12:34 <glguy> nyancats: Because it won't be able to tell which modules are local to the executable and which are from the library
09:12:35 <ski> zebr : you may want to look at "Even higher-order functions for parsing or Why would anyone ever want to use a sixth-order function?" by Chris Okasaki in 1998-03
09:12:45 <ski> <http://www.eecs.usma.edu/Personnel/okasaki/jfp98.ps> might or might not work to access it
09:12:51 <nyancats> glguy: I've always kept the executable and the library under src/ and never had any problems...what changed?
09:13:10 <fizruk> :t catch
09:13:11 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
09:13:31 <glguy> nyancats: At one point, and I don't know when you last updated, cabal learned how to have executables depend on the library in the same cabal file
09:13:39 <ski> @type HFS
09:13:39 <ski> copumpkin ^
09:13:40 <lambdabot> Mu S.Set -> HereditarilyFiniteSet
09:13:50 <glguy> It's much cleaner to do it right than to mix things up whether it works or not
09:14:05 <nyancats> glguy: so if the library goes in src/ where should the executable go?
09:14:07 <glguy> but once you split things out correctly it'll either work or you'll get the next bug
09:14:21 <glguy> nyancats: in a different directory than src/
09:14:35 <glguy> my-awesome-executable/
09:14:45 <nyancats> glguy: I'm asking what is a popular place to put it
09:15:04 <ski> @let heriditaryUnion ss = ss `unionHFS` foldr unionHFS (wrapHFS []) (map heriditaryUnion (unwrapHFS ss))
09:15:05 <glguy> There isn't one that I'm aware of. Name it after the executable you're making
09:15:06 <lambdabot>  Defined.
09:15:23 <glguy> nyancats: Each .cabal can have zero to many executables defined
09:15:26 <ski> > map (toNat . heriditaryUnion . fromNat) [0 ..]
09:15:28 <glguy> so there isn't one magical name
09:15:30 <lambdabot>   [0,1,3,3,7,7,7,7,11,11,11,11,15,15,15,15,23,23,23,23,23,23,23,23,31,31,31,3...
09:15:51 <nyancats> glguy: I know that. but it's common to keep the code in src/
09:16:04 <glguy> yes, the library code goes in src/
09:16:23 <zebr> monoidal, ski: callCC and parser combinators are good examples, thanks. :)
09:16:34 <nyancats> glguy: maybe a better thing to ask is: where will other people expect to find the executable code?
09:16:50 <ski> > map (map toNat . unwrapHFS . heriditaryUnion . fromNat) [0 ..]
09:16:53 <lambdabot>   [[],[0],[0,1],[0,1],[0,1,2],[0,1,2],[0,1,2],[0,1,2],[0,1,3],[0,1,3],[0,1,3]...
09:17:29 <glguy> In the directory named after the executable or they consult your .cabal and see what you picked. The status of things hasn't changed since last time you asked me :)
09:17:40 <ski> > map (map fromHFS . unwrapHFS . fromNat) [0 ..]
09:17:43 <lambdabot>   [[],["{}"],["{{}}"],["{}","{{}}"],["{{{}}}"],["{}","{{{}}}"],["{{}}","{{{}}...
09:17:57 <ski> > map (map toNat . unwrapHFS . fromNat) [0 ..]
09:18:01 <nyancats> glguy: when did this behavior change in cabal?
09:18:01 <lambdabot>   [[],[0],[1],[0,1],[2],[0,2],[1,2],[0,1,2],[3],[0,3],[1,3],[0,1,3],[3,2],[0,...
09:18:15 <glguy> nyancats: It's been a year or two
09:18:37 <glguy> I don't remember when they added executables depending on the local library
09:18:39 <nyancats> annoying
09:18:49 <glguy> no, it's great, you just don't seem to understand what it's doing yet
09:19:20 <nyancats> it's not really great. before it just worked, now I need to keep code in two places for some theoretical benefit
09:20:15 <glguy> Well, if you're going to be difficult I can move on
09:21:26 <nyancats> glguy: can you give an example of a concrete problem with the previous behavior?
09:22:28 * hackagebot texmath 0.6.5.2 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.5.2 (JohnMacFarlane)
09:22:30 * hackagebot rdf4h 1.2.2 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.2.2 (RobStewart)
09:24:09 <khyperia> glguy: would it be possible to make this? foldExpr :: (Monad m) => (Expression a -> m a) -> RExpression -> m a
09:24:16 <khyperia> I tried and I have no idea how
09:25:02 <glguy> khyperia: You'd probably need:     (Expression (m a) -> m a) -> RExpression -> m a
09:25:36 <khyperia> Right.
09:25:48 <glguy> which is just the "foldExpr" I wrote
09:26:04 <khyperia> ... oh, haha
09:26:17 <khyperia> Ack, thanks for your help, I gotta run.
09:26:22 <glguy> ciao
09:27:30 * hackagebot hoodie 0.1.0.0 - A small, toy roguelike  http://hackage.haskell.org/package/hoodie-0.1.0.0 (dvolk)
09:31:40 <ski> > read "HFS (In (fromList []))" :: HereditarilyFiniteSet
09:31:44 <lambdabot>   wrapHFS []
09:31:57 <ski> > read "HFS (In {out = fromList []})" :: HereditarilyFiniteSet
09:32:00 <lambdabot>   wrapHFS []
09:32:07 <ski> > read "HFS {unHFS = In (fromList [])}" :: HereditarilyFiniteSet
09:32:10 <lambdabot>   wrapHFS []
09:32:17 <ski> > read "HFS {unHFS = In {out = fromList []}}" :: HereditarilyFiniteSet
09:32:21 <lambdabot>   wrapHFS []
09:32:31 * hackagebot ed25519 0.0.1.0 - ed25519 cryptographic signatures  http://hackage.haskell.org/package/ed25519-0.0.1.0 (AustinSeipp)
09:32:38 <skypers> hi
09:32:44 <ski> > read "HFS (In (fromList [HFS (In (fromList []))]))" :: HereditarilyFiniteSet
09:32:45 <skypers> I want to stack StatT in EitherT
09:32:46 <hamid> @src shows
09:32:46 <lambdabot> Source not found. My brain just exploded
09:32:48 <lambdabot>   wrapHFS *Exception: Prelude.read: no parse
09:32:48 <skypers> how should I do that?
09:33:01 <ski> > read "HFS (In (fromList [wrapHFS []]))" :: HereditarilyFiniteSet
09:33:04 <lambdabot>   wrapHFS *Exception: Prelude.read: no parse
09:33:14 <skypers> EitherT e (StateT s IO ????) a
09:33:25 <skypers> it will lead in two a
09:33:26 <skypers> or
09:33:29 <skypers> EitherT e (StateT s IO ()) a
09:33:30 <skypers> ?
09:33:47 <ski> > read "HFS (In (fromList [In (fromList [])]))" :: HereditarilyFiniteSet
09:33:47 <glguy> skypers: What kind does EitherT have?
09:33:50 <lambdabot>   wrapHFS *Exception: Prelude.read: no parse
09:33:56 <ski> @kind EitherT
09:33:57 <lambdabot>     Not in scope: type constructor or class `EitherT'
09:33:58 <lambdabot>     Perhaps you meant `Either' (imported from Data.Either)
09:34:04 <skypers> EitherT e m a
09:34:12 <skypers> e is the error type
09:34:14 <skypers> m the inner monad
09:34:17 <glguy> skypers: No, that's not a kind
09:34:17 <skypers> and a the return type
09:34:22 <skypers> oh
09:34:24 <skypers> well
09:34:36 <glguy> I promise this is going somewhere
09:34:43 <skypers> EitherT :: * -> (* -> *) -> * -> *
09:35:13 <glguy> so the second argument needs to be a :   *->*
09:35:26 <skypers> yes…
09:35:34 <glguy> so don't apply anything to: StateT s IO
09:35:38 <glguy> which is a *->*
09:35:43 <glguy> you don't need () or ???
09:35:44 <skypers> oh
09:35:47 <skypers> I’m stupid
09:35:57 <skypers> for now
09:35:59 <skypers> I have
09:36:06 <skypers> EitherT e IO a
09:36:11 <skypers> it’s quite the same thing
09:36:15 <skypers> it’s not (IO a)
09:36:22 <skypers> I’m too tired…
09:36:22 <skypers> :D
09:36:25 <skypers> thank you ;)
09:36:27 <ski> > read "HFS (In (fromList [In {out = fromList []}]))" :: HereditarilyFiniteSet  -- bah
09:36:30 <lambdabot>   wrapHFS [wrapHFS []]
09:36:47 <ski> > read "fromNat 5" :: HereditarilyFiniteSet
09:36:50 <lambdabot>   wrapHFS [wrapHFS [],wrapHFS [wrapHFS [wrapHFS []]]]
09:37:00 <ski> > read "read \"fromNat 5\"" :: HereditarilyFiniteSet
09:37:03 <lambdabot>   wrapHFS [wrapHFS [],wrapHFS [wrapHFS [wrapHFS []]]]
09:37:11 <ski> > read "read \"read \\\"fromNat 5\\\"\"" :: HereditarilyFiniteSet
09:37:14 <lambdabot>   wrapHFS [wrapHFS [],wrapHFS [wrapHFS [wrapHFS []]]]
09:40:42 <joelteon> what's a hereditarily finite set
09:41:26 <skypers> ok and hm
09:41:30 <skypers> to extract values from that
09:41:32 <skypers> I guess
09:41:40 <skypers> :t runStateT . runEitherT
09:41:41 <lambdabot>     Not in scope: `runEitherT'
09:41:41 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
09:41:42 <ski> joelteon : a finite set, all whose elements are sets of the same kind
09:41:45 <skypers> :)
09:42:37 <ski> > fromHFS (fromNat 100)
09:42:40 <lambdabot>   "{{{},{{{}}}},{{{}}},{{{}},{{{}}}}}"
09:42:53 <ski> is the 100th such set
09:43:15 <ski> @type fromNat
09:43:16 <lambdabot> Integer -> HereditarilyFiniteSet
09:43:17 <ski> @type fromHFS
09:43:18 <lambdabot> HereditarilyFiniteSet -> String
09:44:28 <ski> joelteon : try "A Functional Hitchhiker's Guide to Hereditarily Finite Sets, Ackermann Encodings and Pairing Functions" by Paul Tarau in 2008-08-06 at <http://arxiv.org/abs/0808.0754> for some info on them
09:44:41 <fizruk> why can't GHC infer that MonadTrans t, Monad m => Monad (t m)? Isn't it always true?
09:45:27 <ski> one would need `instance (MonadTrans t,Monad m) => Monad (t m) where ...', which would be overlapping
09:46:07 <alexander__b> how do I find out which version of base I have
09:46:07 <fizruk> ski, yeah, but is there another way to tell GHC that?
09:46:22 <ski> i suppose one potential alternative would be to say `class (forall m. Monad m => Monad (t m)) => MonadTrans t where ...' -- but that would require rank-2 contexts
09:46:48 <ski> fizruk : you can tell it for each specific `t' ..
09:46:53 <fizruk> ski, do we have rank-2 contexts (with extensions)?
09:46:55 <ski> (which isn't always enough)
09:47:00 <ski> fizruk : i don't think so ?
09:47:09 <fizruk> okay :(
09:47:47 <fizruk> I also need to write Functor m for each monad, so I get something like (MonadTrans t, Monad m, Monad (t m), Functor (t m), Functor m) => ...
09:47:50 <allsystemsarego> Hi all, I'm going through the "Composing Lenses" section of http://www.haskell.org/haskellwiki/LensBeginnersCheatsheet and I get this error: http://lpaste.net/95290 Any ideas?
09:47:53 <fizruk> which is pretty annoying
09:47:56 <ski> indeed
09:48:27 <ski> in many cases, you can avoid that by using `liftM' instead of `fmap' (or `(<$>)' or `liftA')
09:48:58 <ski> (avoid the extra `Functor'-constraints, i.e.)
09:49:17 <fizruk> ski, in my case I use something like Free m a, and then use some functions that require f in Free f a to be a Functor...
09:49:31 <ski>   newtype HereditarilyFiniteSet = HFS {unHFS :: Mu S.Set}
09:49:41 <ski> joelteon : that ^ is basically the definition
09:49:48 <ski> another way of seeing it is like
09:50:48 <ski>   newtype HereditarilyFiniteSet = WrapHFStoList {fromListUnwrapHFS :: S.Set HereditarilyFiniteSet}
09:50:54 <ski> @type HFS
09:50:55 <lambdabot> Mu S.Set -> HereditarilyFiniteSet
09:50:56 <ski> @type unHFS
09:50:58 <lambdabot> HereditarilyFiniteSet -> Mu S.Set
09:51:03 <ski> @type wrapHFS
09:51:04 <lambdabot> [HereditarilyFiniteSet] -> HereditarilyFiniteSet
09:51:06 <ski> @type unwrapHFS
09:51:07 <lambdabot> HereditarilyFiniteSet -> [HereditarilyFiniteSet]
09:51:13 <ski> @type toNat
09:51:15 <lambdabot> HereditarilyFiniteSet -> Integer
09:51:16 <ski> @type fromNat
09:51:17 <lambdabot> Integer -> HereditarilyFiniteSet
09:51:32 <ski> @type fromHFS
09:51:33 <lambdabot> HereditarilyFiniteSet -> String
09:51:36 <ski> @type toHFS
09:51:37 <lambdabot> String -> HereditarilyFiniteSet
09:52:08 <ski> plus `Show' and `Read' instances (and `Eq' and `Ord'), plus
09:52:12 <ski> @type memberHFS
09:52:13 <lambdabot> HereditarilyFiniteSet -> HereditarilyFiniteSet -> Bool
09:52:15 <ski> @type unionHFS
09:52:21 <ski> @type intersectionHFS
09:53:08 <fizruk> > element 0.at 1 .~ Just 10 $ [M.fromList [(1,2),(3,4)]] -- allsystemsarego
09:53:10 <lambdabot>   [fromList [(1,10),(3,4)]]
09:53:17 <ski> @type differenceHFS
09:53:32 * ski idly wonders whether `type' got stuck
09:53:46 <ski> fizruk : anyway, yea, not much to do in that case :/
09:54:11 * fizruk sighs...
09:54:33 <ski> (except to do more code duplication ..)
09:54:51 <allsystemsarego> fizruk, thanks
09:55:34 <ski> @type ()
09:55:35 <lambdabot> ()
09:55:37 <ski> hmm
09:56:01 <fizruk> ski, what did you expect? :D
09:56:20 <fizruk> oh, I see
09:58:15 <monoidal> ski: is there a package providing hfs operations?
09:58:21 <ski> no idea
09:59:56 <Eduard_Munteanu> What's a nice serialization format if I want to cache the results of parsing text?
10:00:17 <Eduard_Munteanu> Basically an AST.
10:00:33 <Eduard_Munteanu> I figure it should be binary.
10:00:49 <simpson> Eduard_Munteanu: Why can't you just parse it in again?
10:01:16 * ski is also looking at "Arithmetic Algorithms for Hereditarily Binary Natural Numbers" in 2013-06-05 at <http://arxiv.org/abs/1306.1128> and "A Prolog Specification of Giant Number Arithmetic" in 2013-06-17 at <http://arxiv.org/abs/1307.4642>, both by Paul Tarau
10:01:16 <monochrom> depends on what is "results"
10:01:19 <Eduard_Munteanu> simpson: I can, just wondering, in case it's too slow. I'm writing a parser for the Linux kernel kconfig files.
10:02:10 <ski> > unionHFS (wrapHFS []) (wrapHFS [])
10:02:14 <lambdabot>   wrapHFS []
10:02:18 <issimus> write naive implementation then profile if necessary, is the usual advice
10:02:45 <supki_> allsystemsarego: what happens when you say :kind! Index (Map String Int) in ghci?
10:05:38 <allsystemsarego> supki_, it says Not in scope: type constructor or class `Index'
10:06:42 <supki_> well, yeah, you need to import Control.Lens
10:06:56 <allsystemsarego> oh wait, yes, duh
10:07:29 <allsystemsarego> λ: :kind! Index (Map String Int)
10:07:29 <allsystemsarego> Index (Map String Int) :: *
10:07:29 <allsystemsarego> = Index (Map [Char] Int)
10:07:29 <allsystemsarego> λ:
10:08:04 <supki_> huh
10:08:11 <allsystemsarego> so I need to provide explicit signatures, I would guess
10:08:12 <supki_> allsystemsarego: and the version of lens installed?
10:08:26 <supki_> no, your lens is broken apparently
10:09:26 <allsystemsarego> $ ghc-pkg list | grep lens
10:09:26 <allsystemsarego>     data-lens-2.10.3
10:09:26 <allsystemsarego>     data-lens-template-2.1.7
10:09:26 <allsystemsarego>     lens-3.10
10:11:47 <glguy> allsystemsarego: Which GHC?
10:11:53 <fizruk> how do you call a function of type (Functor f, Monad m) => forall a. f a -> m a ? natural transformation?
10:13:05 <quchen> I think natural would be for two functors.
10:13:08 <allsystemsarego> glguy, 7.6.3
10:13:17 <ski> monads are functors
10:13:31 <quchen> Sure, but maybe the transformation has another name given the additional structure.
10:13:39 <glguy> allsystemsarego: do you have more than one version of containers installed?
10:13:51 <glguy> ghc-pkg list containers
10:13:53 <ski> quchen : would there be any additional law(s) (which ?) ?
10:14:01 <fizruk> quchen, ski: is "natural transformation" consistent with the type?
10:14:13 <ski> fizruk : yes
10:14:45 <fizruk> then "natural transformation" is okay to me :)
10:14:51 <ski> fizruk : any more laws intended, than the usual natural transformation law ?
10:15:02 <allsystemsarego>    containers-0.5.0.0
10:15:02 <allsystemsarego>    containers-0.5.3.1
10:15:02 <allsystemsarego>  - glguy
10:15:03 <ski> (which holds automatically by parametricity in Haskell)
10:15:12 <glguy> allsystemsarego: That's the problem. You shouldn't have that
10:15:27 <allsystemsarego> ok, so uninstall the older one
10:15:30 <monochrom> no
10:15:32 <glguy> allsystemsarego: No
10:15:41 <allsystemsarego> oh
10:15:46 <glguy> containers-0.5.0.0 comes with GHC 7.6.3
10:15:58 <glguy> and that's the version you'll need to use until you get a new GHC
10:15:59 <fizruk> ski, no just need the codomain to be monad
10:16:00 <monochrom> get rid of the version installed by hand. get rid of the version that did not come with GHC
10:16:18 <allsystemsarego> ok
10:16:21 <ski> fizruk : so it's a natural transformation into a functor that happens to be a monad
10:16:23 <fizruk> ski, so just a restricted natural transformation, I guess
10:17:45 <fizruk> edwardk, hey!
10:17:52 <edwardk> heya
10:18:05 <fizruk> edwardk, have you seen my iterM' messy issue? :p
10:18:07 <edwardk> if i promised to do something for you. it'll be after i get some sleep ;)
10:20:00 <fizruk> edwardk, okay then :) I'm gonna write you some blocks of text via email on iterM stuff, are you okay with that?
10:21:39 <Philonous> I can't write a prism without import something from the lens library like I can with lenses, can I?
10:22:35 <fizruk> Philonous, you can makePrisms without importing anything except Control.Lens afaik
10:23:06 <glguy> Philonous: You need the profunctors package to make prisms
10:23:40 <glguy> type Prism s t a b = (Data.Profunctor.Choice p, Control.Applicative.Applicative f) => p a (f b) -> p s (f t)
10:23:52 <Philonous> fizruk, Yes, but then I need to add the lens package to my dependencies, which is exactly what I want to avoid (at least until lens is in the platform)
10:24:30 <fizruk> Philonous, write your own Prisms :)
10:24:44 <fizruk> oh that's what you want
10:24:49 * fizruk disappears...
10:25:16 <allsystemsarego> OK, so I unregistered the newer containers package (the one in my home dir) and now I get: "Illegal literal in type (use -XDataKinds to enable): 42" - I'm still confused
10:25:52 <Flonk> Wikipedia articles on category don't particularly... give a lot of insight. Does anyone know of a good site that explains what 'profunctor' even means?
10:26:17 <Philonous> glguy, ok, so I only need profunctors. That might be acceptable. Thanks.
10:26:51 <fizruk> Flonk, f a b which is contravariant on a and covariant on b?
10:27:11 <supki_> Flonk: http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
10:28:26 <Flonk> fizruk: Okay, I see
10:28:31 <Flonk> supki_: I'll check it out, thanks!
10:29:01 <supki_> well, that assumes you know what Contravariant functor is, I guess
10:29:14 <fizruk> Flonk, that really helped?
10:29:29 <Cale> allsystemsarego: what are you trying to compile?
10:30:18 <Flonk> fizruk: It isn't mentioned on the wikipedia and I know the definitions of co- and contravariance, so yeah
10:30:35 <allsystemsarego> Cale, the code at http://lpaste.net/95290 where I've gotten past those errors in the paste
10:31:01 <fizruk> Flonk, if I myself get it correctly, I guess Map k v is a Profunctor
10:31:35 <Cale> allsystemsarego: that code works for me. How are you getting a 42 into a type signature?
10:32:40 <allsystemsarego> Cale, I'm going through the "Composing Lenses" section of http://www.haskell.org/haskellwiki/LensBeginnersCheatsheet
10:32:58 <allsystemsarego> I copied the code from there
10:33:05 <Cale> Are you sure that paste is really the code that you're trying to compile right now?
10:33:16 <Cale> Check that the contents of your file really match the paste
10:33:19 <allsystemsarego> maybe my cabal stuff is messed up
10:33:39 <allsystemsarego> ok, rechecking
10:34:44 <Cale> allsystemsarego: The error message you got seems to indicate that somehow the 42 in that expression ended up on the right hand side of ::
10:34:51 <briennetheblue> there's an easy to understand profunctors introduction here https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
10:34:59 <allsystemsarego> that worked, thanks Cale
10:35:03 <edwardk> fizruk: sure
10:35:10 <edwardk> fizruk: i will eventually get around to it =)
10:35:32 <edwardk> Philonous: you can write a prism with just the profunctors package, its just tricky
10:35:48 <briennetheblue> easier for me to understand than the sigfpe post anyway :)
10:35:57 <fizruk> edwardk, I'm going to be optimistic about that :P
10:36:52 <Philonous> edwardk, I have no compunction about getting some "inspiration" from your code ;)
10:37:04 <lpaste> glguy pasted “Prisms for Philonous” at http://lpaste.net/95292
10:37:17 <Philonous> Otoh it might be instructive to figure it out on my own.
10:38:48 <Philonous> glguy, Thanks
10:51:09 <Hari``> hi
10:51:22 <ski>    lo
10:52:56 <Hari``> i have a question about threading and caching in haskell...
10:53:07 <haasn> edwardk: have you thought about providing a lightweight lens-creating-functions-only library?
10:53:27 <haasn> that has ‘lens’, ‘prism’, ‘iso’ and whatever
10:53:28 <edwardk> there is lens-family for that in theory
10:53:36 <arkeet> `lens` =(
10:53:52 <edwardk> and 'lens' is almost universally a bad idea ;)
10:54:13 <edwardk> (the function, not the library)
10:54:18 <arkeet> :)
10:54:30 * monochrom is tempted to @remember it!
10:55:04 <arkeet> maybe you could provide prism and iso in profunctors? ;)
10:55:06 <monochrom> "breaking news: lens a bad idea: edwardk" :)
10:55:12 <edwardk> =P
10:55:25 <edwardk> arkeet: i could be talked into that
10:55:40 <arkeet> since that's exactly what you need to depend on to define them anyway
10:55:46 <haasn> Choice would have to move there
10:55:49 <arkeet> it already did
10:55:53 <haasn> oh okay
10:56:05 <edwardk> the reason we didn't back in the day was that we didn't want to prejudice it against pure profunctor lenses
10:56:57 <Hari``> i have this function...
10:57:00 <Hari``> bankFeeds :: IO ()
10:57:00 <Hari``> bankFeeds = do
10:57:00 <Hari``>   fmap force cachedWeeklyTransactions
10:57:00 <Hari``>   force $ threadDelay (3600000000 * 4) >> fmap force bankFeeds
10:57:16 <Hari``> whoops..
10:57:21 <edwardk> but now there are actual isomorphisms n there, so i could go for it
10:57:36 <Hari``> i have THIS function...
10:57:55 <Hari``> bankFeeds :: IO ()
10:57:55 <Hari``> bankFeeds = do
10:57:55 <Hari``>   fmap force cachedWeeklyTransactions
10:57:55 <Hari``>   threadDelay (3600000000 * 4) >> fmap force bankFeeds
10:57:55 <monochrom> I don't know what is "force"
10:57:59 <ski> @hoogle force
10:57:59 <lambdabot> Control.DeepSeq force :: NFData a => a -> a
10:57:59 <lambdabot> package force-layout
10:57:59 <lambdabot> Graphics.UI.GLUT.Initialization ForceDirectContext :: DirectRendering
10:58:07 <arkeet> Hari``: have you tried a pastebin?
10:58:07 <arkeet> @lpaste
10:58:08 <lambdabot> Haskell pastebin: http://lpaste.net/
10:58:08 <monochrom> ok, that force
10:58:11 <Hari``> force applies deepSeq, which forces evalatuion
10:58:13 <ion> hari: “force x” unevaluated doesn’t evaluate anything more than “x” unevaluated.
10:58:27 <ion> hari: You’re not *using* the result of fmap force … anywhere.
10:58:42 <ion> hari: You may want to look at Control.Exception.evaluate
10:58:42 <Hari``> the problem is that the threadDelay is also lazily evaluated, i think
10:58:43 <arkeet> if you really want to evaluate, consider
10:58:44 <arkeet> @hoogle evaluate
10:58:44 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
10:58:44 <lambdabot> Control.Exception evaluate :: a -> IO a
10:58:44 <lambdabot> Control.OldException evaluate :: a -> IO a
10:58:47 <monochrom> "fmap force cachedWeeklyTransactions" does not do what you think
10:58:58 <Hari``> ah :)
10:59:27 <arkeet> force blah doesn't evaluate blah at all unless force blah is evaluated (which it isn't, in your case).
11:00:31 <monochrom> "evaluate" may not do what you think either
11:00:52 <monochrom> it is not like "evaluate bankFeeds" or "fmap evaluate bankFeeds" is really useful
11:01:56 <Eduard_Munteanu> I wonder how far you can get by using Data.Set by default, instead of lists.
11:02:19 <Hari``> yeah, i think that threadDelay is itself not executed/evaluated as i want
11:02:22 <Hari``> right
11:04:38 <WraithM_> Eduard_Munteanu: Something that I've actually been having a problem with lately is that I don't know where the good :: Seq a -> f a functions are, where f is say, Vector or something like this.
11:04:38 <monochrom> no, you have the totally wrong model. the threadDelay part is about the only part that works and does what you want.
11:06:36 <Eduard_Munteanu> WraithM_: I think lists are generally used to convert between them, and Y.fromList . X.toList should fuse.
11:06:37 <Hari``> heh, ok. i'll try the evaluate function (which evaluates to weak head normal form, it says in the documentation)
11:06:47 <Eduard_Munteanu> At least theoretically.
11:07:04 <WraithM_> Eduard_Munteanu: Right, and that's what I've been doing, but it sorta has trouble a lot of the time :(
11:07:16 <WraithM_> I mean, maybe I'm doing it wrong
11:09:01 <WraithM_> But this is one reason why Seq is sorta difficult to use by default.
11:09:13 <WraithM_> Other people don't use it by default
11:10:19 <monochrom> how about try to use neither "force" nor "evaluate"?
11:11:09 <Hari``> actually, i "solved" my problem earlier by printing out certain values, which forces evaluation, but i was told (and agreed that) that it's not very elegant to use printing to affect the semantics of the program
11:11:13 <WraithM_> Like, I wanted something like a circular buffer recently, and then convert it to a JSON array (with aeson). So, I used Seq, and wrote my instance ToJSON as, toJSON = toJSON . V.fromList . S.toList
11:12:40 <monochrom> that only means replace "print" by "(evaluate . force)". it does not mean "insert force everywhere"
11:13:15 <Hari``> so print might not have solved my problem?
11:13:58 <monochrom> ok, I'll shut up, clearly I'm making myself unclear.
11:14:15 <Hari``> no, don't shut up :)
11:16:20 <fizruk> supki_, that article on profunctors is really good! thanks!
11:19:47 <bz> @hoogle void
11:19:47 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
11:19:47 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
11:19:47 <lambdabot> package void
11:21:30 <quchen> void = fmap (const ())
11:22:19 <joelteon> :t (() <$)
11:22:20 <lambdabot> Functor f => f b -> f ()
11:22:37 <lpaste> mp pasted “cabal-dev install snaplet-fay build error” at http://lpaste.net/95295
11:23:24 <ski> imo, that `void' should only be in `Foreign.Marshal.Error', not in `Control.Monad'
11:24:00 <ski> (if it's deemed useful for non-FFI code, it shouldn't be named `void' in those cases)
11:24:33 <quchen> ski: void is very useful.
11:24:42 <quchen> Also the next release moves it to Data.Functor.
11:24:50 <ski> and renames it ? :)
11:24:52 <jrmithdobbs> is regex-tdfa probably what I want for posix regexes?
11:24:55 <quchen> Yes. To "void".
11:25:04 <ski> not good enough :)
11:25:38 <quchen> Feel free to tell the mailing lists.
11:26:39 <monochrom> just move it to Prelude
11:27:39 <FreeFull> :t void
11:27:40 <lambdabot> Functor f => f a -> f ()
11:27:41 <quchen> monochrom: We can only do that if we make it more monomorphic before.
11:27:54 <FreeFull> What should it be called? unitify?
11:28:08 <quchen> I think void is a fine name.
11:28:23 <fizruk> quchen, where can I find info on "next release"?
11:29:11 <monochrom> SML calls it "ignore"
11:29:35 <Eduard_Munteanu> :t void ?main
11:29:36 <lambdabot> (Functor f, ?main::f a) => f ()
11:29:52 <quchen> fizruk: I don't think there's a neat list. The GHC manual shipped with the source lists many changes, I think that's a good start.
11:29:57 <FreeFull> () isn't Void though
11:29:59 <quchen> Not sure how to create the HTML docs from that thogh.
11:30:17 <quchen> And neither is it void.
11:30:40 <fizruk> quchen, so I should just look at ghc HEAD?
11:30:42 <Eduard_Munteanu> FreeFull: ⊥-elim / bot-elim for Void seems more common
11:31:11 <quchen> fizruk: Yeah, that's what I meant. It has a doc subdirectory that can somehow be made into useful files.
11:31:32 <fizruk> quchen, thanks!
11:31:32 <Eduard_Munteanu> @djinn (a -> Void) -> a -> b
11:31:32 <lambdabot> f a b = void (a b)
11:31:42 <quchen> fizruk: You can also read the XML source if you dare: http://ghc.haskell.org/trac/ghc/browser/ghc/docs/users_guide/7.8.1-notes.xml
11:31:50 <Eduard_Munteanu> Well, not in Haskell. :P
11:31:54 <quchen> fizruk: It's not terribly unreadable
11:32:16 <quchen> It doesn't mention the void change though :-P
11:32:50 <fizruk> quchen, oh it's readable enough, thanks! :)
11:33:08 <FreeFull> What does djinn think void is?
11:33:35 <FreeFull> Void -> a?
11:33:36 <quchen> @djinn Void
11:33:36 <lambdabot> -- f cannot be realized.
11:33:50 <FreeFull> @djinn Void -> a
11:33:50 <lambdabot> f = void
11:33:52 <ski> FreeFull : yes
11:34:03 <ski> cf.
11:34:03 <ski> @type either
11:34:04 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
11:34:13 <ski> @type maybe
11:34:14 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:34:20 <FreeFull> Makes sense
11:34:25 <quchen> @type foldr
11:34:26 <lambdabot> (a -> b -> b) -> b -> [a] -> b
11:34:29 <quchen> Combo breaker!
11:34:39 <FreeFull> @type list
11:34:40 <lambdabot>     Not in scope: `list'
11:34:40 <lambdabot>     Perhaps you meant one of these:
11:34:40 <lambdabot>       `last' (imported from Data.List),
11:37:15 <FreeFull> @let list :: (a -> [a] -> c) -> c -> [a] -> c; list _ x [] = x; list f x (a:as) = f a as
11:37:17 <lambdabot>  Defined.
11:37:23 <FreeFull> I don't think this is that useful
11:40:03 <justinle_> Hi folks! Anyone know why looking up items in a Map may be broken after deserializing from a file? Think it may be something related to encoding but haven't had luck finding out the source. It's for an OSS project (Elm). Here's what happens: https://gist.github.com/jsl/7294493 and here it is in the project's repo: https://github.com/evancz/Elm/blob/dev/compiler/Metadata/Prelude.hs#L78
11:47:10 <glguy> justinle_: Looks like the map is somehow internally inconsistent
11:47:53 <glguy> justinle_: Could you evaluate: M.valid Metadata.Prelude.interfaces
11:48:15 <justinle_> glguy: sure will try to do that now
11:48:29 <bergmark> mp: snaplet-fay is missing upper bounds, i'll see if i can update it
11:48:30 <glguy> justinle_: One way to break Data.Map is probably to use: fromAscList somewhere on a non-ascending list
11:49:35 <glguy> Prelude Data.Map> Data.Map.lookup 20 (fromAscList [(20,'a'),(10,'b')])
11:49:35 <glguy> Nothing
11:49:52 <glguy> your output from M.keys was not sorted which is probably related
11:52:36 <justinle_> glguy: ok, think we're on to something thanks to your help :) M.valid Metadata.Prelude.interfaces => False
11:54:58 <bz> @hoogle ▵
11:54:58 <lambdabot> Parse error:
11:54:58 <lambdabot>   ▵
11:54:58 <lambdabot>    ^
11:55:10 <quchen> Sounds like a bug then.
11:57:10 <mp> bergmark: thank you! which dependency is missing upper bound? maybe I'd update it locally for now
11:57:44 <bz> zenzike ∷ Integer → Integer
11:57:44 <bz> zenzike = uncurry (*) . id ▵ id
11:57:50 <bz> anyone knwo what the heck that triangle does?
11:58:16 <Iceland_jack> bz: may be the diagonal morphism
11:58:26 <Iceland_jack>     diagonal x = (x, x)
11:58:44 <Iceland_jack> hm no on the other hand it's not
11:58:46 <bz> does it have a higher or lowe rprecedence than (.)?
11:58:53 <bergmark> mp: should be fay < 0.18
11:59:16 <Iceland_jack> bz: ah!
11:59:24 <bz> Iceland_jack: it's here: http://zenzike.com/posts/2010-06-17-genesis
11:59:48 <bz> bothers me that his "::" is actually a unicode char, didn't know that ghc permitted unicode shenanigans
12:00:02 <Iceland_jack> it has type
12:00:02 <Iceland_jack>     ▵ ∷ (C × C → C) → (A → A) → T
12:00:04 <glguy> triangle f g x = (f x, g x)
12:01:01 <Iceland_jack> oh so it's just a pairing
12:01:29 <geekosaur> bz: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
12:01:33 <Iceland_jack> Normally that's written ⟨f, g⟩
12:02:32 <bz> so main ∷ IO ∅ isn't valid, right?
12:03:03 <ski> `∅' ought to correspond to `Void', anyway
12:03:04 <glguy> ∅ is the empty set symbol
12:03:14 <glguy> so it wouldn't mean ()
12:04:01 <glguy> > isSymbol  '∅'
12:04:02 <lambdabot>   True
12:04:25 <MindUser26886> !list
12:04:25 <monochrom> MindUser26886: http://okmij.org/ftp
12:04:30 <glguy> > let (∅) = (+) in 1 ∅ 2
12:04:31 <lambdabot>   3
12:04:32 <lpaste> mp pasted “fay-0.17 build error” at http://lpaste.net/95296
12:05:42 <fizruk> following tutorial on profunctors I think I found a bug in it https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
12:05:56 <fizruk> instance Indexable i (Indexed i) where ...
12:06:00 <fizruk> is not working
12:06:34 <fizruk> it should be instance i ~ j => Indexable i (Indexed j) where ... (as in http://hackage.haskell.org/package/lens-3.10/docs/Control-Lens-Indexed.html#t:Indexable)
12:07:26 <fizruk> though I don't fully understand why
12:09:42 <supki_> fizruk: not working how?
12:09:50 <supki_> it probably infers worse
12:10:03 <fizruk> supki_, it infers worse, yes
12:10:12 <supki_> that's expected
12:10:24 <bergmark> mp: it's updated for fay 0.18 on https://github.com/faylang/snaplet-fay, need to update the example too and then i'll upload it to hackage
12:10:37 <supki_> ghc needs to prove both  i  are the same, before choosing an instance
12:10:52 <fizruk> I just tried: mapIndexable (Main.Indexed (+)) $ M.fromList $ zip [1..] [2, 5, 4, 3, 5]
12:10:57 <chrisdone> anyone got a script to download all the latest version of all packages from hackage?
12:11:05 <fizruk> and got a bunch of errors
12:11:44 <fizruk> supki_, ah, I see
12:12:20 <geekosaur> chrisdone, maybe you can use http://hackage.haskell.org/package/hackager ?
12:12:43 <chrisdone> geekosaur: oh, cool. i'll check it out, thanks
12:12:52 <mp> bergmark: thank you
12:13:01 <fizruk> supki_, am I right that a similar behavior can be achieved with fundeps in class definition: class Indexable i p | p -> i where ... ?
12:13:35 <supki> fizruk: no?
12:13:57 <supki> well, in this case yes
12:14:13 <kooellekarl> can anyone give me an example where a term has multiple different types in an implicitly monomorphic typed lambda calculus while in explicitly typed the type is unique?
12:14:41 <fizruk> supki, hm... you mean for this instance? or for this class?
12:15:44 <supki> fizruk: for this inference problem :)
12:16:34 <fizruk> supki, wow :)
12:19:01 <chrisdone> i wonder if we should have a haskell-emacs channel
12:19:11 <Luke> definitely
12:19:29 <stolaruk> Does anyone know how I can verify/set the version of HLint that SublimeHaskell uses?
12:19:30 <stolaruk> or, I should say, which hlint on my system it is using
12:19:33 <Luke> did you see my pings about the haskell snippets btw? chrisdone
12:19:41 <chrisdone> woah
12:19:42 <shergill> chrisdone: why not just talk in #emacs?
12:20:04 <chrisdone> shergill: or #haskell?
12:20:24 <chrisdone> Luke: uhm, let me check my inbox?
12:20:32 <Luke> we should all just talk in a big #computers chat room
12:20:36 <chrisdone> lol
12:20:46 <Luke> chrisdone: not an email. just pinged you here a few days ago.
12:20:57 <chrisdone> oh, hm
12:20:59 <shergill> sure, either. i just assumed your desire to create a new channel might have somethign to do with #haskell trying harder to be more on point
12:21:12 <Luke> the gist is we were planning on eventually putting my haskell snippets into haskell-mode
12:21:17 <chrisdone> Luke: nah. if i'm not around it's better to @tell or so
12:21:23 <chrisdone> ahh
12:21:23 <Luke> i think it's ready  now (it's been stable for months0)
12:21:27 <chrisdone> sweet =)
12:21:37 <Luke> where do you want that to go? how should it be organized?
12:21:46 <chrisdone> can you re-link me? i don't have the backlog
12:21:54 * chrisdone checks on ircbrowse
12:21:58 <Luke> https://github.com/LukeHoersten/shnippet
12:22:07 <Luke> no worries. nothing to look back at
12:22:12 <Luke> i recapped it all already
12:23:14 <moops> is there some way to do this with mfilter? m [a] -> (a -> Bool) -> m [a]
12:23:24 <moops> or otherwise
12:24:51 <ski> @type flip (liftM . filter)
12:24:52 <lambdabot> Monad m => m [a] -> (a -> Bool) -> m [a]
12:25:01 <moops> ahh perfect
12:25:03 <moops> thanks
12:25:52 <chrisdone> Luke: i guess it can be put in the haskell-mode repo as yasnippets/? i've no particular preferences
12:25:57 <chrisdone> hvr: any preferences?
12:26:12 <Luke> and then how should we wire it up? enable by default? etc
12:28:10 <chrisdone> Luke: i think we can pop it down as an option to not inconvenience those that don't have yas or have their own yas (e.g. tibbe)
12:28:27 <Luke> right
12:28:29 <chrisdone> Luke: but make it somehow "blessed" and recommended
12:28:44 <Luke> just by the sheer fact that it's shipped together?
12:28:51 <chrisdone> yeah
12:28:53 <Luke> sounds good
12:29:20 <Luke> well I'll drop it in there and I'll leave it to you and hvr about how to wire it up. sounds like we want to default to not anyway
12:29:35 <chrisdone> right
12:29:52 <Luke> are you opposed to me catting my README into the main one or perhaps split it off into a special file
12:31:11 <chrisdone> i think a special file -- hvr's been pushing for us documenting features in the docs thingie
12:31:23 <chrisdone> which i should start contributing to
12:31:32 <Luke> docs thingy?
12:31:35 <chrisdone> sec
12:31:39 <chrisdone> http://haskell.github.io/haskell-mode/manual/latest/
12:31:56 <Luke> oh interesting
12:32:08 <chrisdone> we want to start fleshing it out. it's nice because it can not just generate this html, but also a texinfo file ready for consumption within emacs itself
12:32:28 <Luke> nice
12:33:04 <chrisdone> hm, let me test locally. iirc i got the docs generating
12:33:22 <Luke> yeah where do I contribute the content to get put into this doc page?
12:33:56 <chrisdone> haskell-mode.texi seems to be the place
12:34:23 <chrisdone> if it's too much bother to convert your doc to that, you can just include the README in the snippets dir and i'll try translating it
12:34:54 <Luke> I probably wont attempt a translation into texi until I can generate it locally first too to confirm it works
12:35:06 <chrisdone> yeah, so let me check this makefile setup
12:35:28 <chrisdone> cool, looks pretty easy
12:35:47 <chrisdone> yeah
12:36:03 <chrisdone> install texi2html
12:36:10 <chrisdone> and then just run: make haskell-mode.html
12:36:12 <chrisdone> does it work?
12:36:25 <bergmark> mp: i uploaded snaplet-fay 0.3.3
12:38:35 * hackagebot snaplet-fay 0.3.3 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3 (AdamBergmark)
12:42:01 <chrisdone> ohhh. suave
12:42:12 * chrisdone looking through the .info file in emacs
12:42:24 * chrisdone drools a little
12:42:32 <bergmark> .info? O_o
12:42:56 <chrisdone> yeah, from gnu's official documentation format, texinfo
12:43:48 * ski . o O ( `Emacs.info' )
12:44:14 <chrisdone> bergmark: when you run M-x info and get the nice documentation, that's the system
12:44:36 <chrisdone> Luke: if you run C-u M-x info you can open the .info file to preview it
12:45:10 <bergmark> " loosely based on Brian Reid's Scribe " :)
12:48:58 <stolaruk> Has anyone else had issues w/ HLint getting upset over MultiWayIf?
12:49:05 <chrisdone> Luke: don't worry if you can't get the docs to generate, just submit a pull request and i'll merge it in appropriately by this weekend
12:49:20 <chrisdone> stolaruk: by getting upset you mean it can't parse it?
12:49:30 <stolaruk> yeah parse error on |
12:49:59 <chrisdone> probably because it's not supported by haskell-src-exts yet
12:50:08 <chrisdone> http://hackage.haskell.org/package/haskell-src-exts-1.14.0/docs/Language-Haskell-Exts-Extension.html#t:KnownExtension
12:50:36 <stolaruk> hmm
12:51:14 <chrisdone> so hse & hint will need patching
12:51:28 <stolaruk> I guess it's a very new thing.
12:51:41 <chrisdone> yeah, relatively
12:51:52 <stolaruk> ok, thank you
12:52:28 <tswett> Dang, I really should be using Cont here instead of writing (a -> e) -> e everywhere.
12:53:26 <ski> tswett : linear logic ?
12:53:39 <tswett> ski: yup. Apparently I actually have it working now.
12:53:44 <tswett> Miraculously.
12:54:44 <ski> and your `blah -> bleh' ?
12:54:44 <monochrom> a Cont here and there a day, keeps the Oleg away :)
12:55:00 <tswett> ski: you're asking how that's represented?
12:55:50 <chrisdone> i made a #haskell-emacs channel fiw
12:55:53 <tswett> "a -> b" turns into "forall e. ((a e -> (b e -> e) -> e) -> e) -> e".
12:55:54 * chrisdone → bed
12:56:11 <tswett> Which I'm pretty sure is equivalent to "forall e. a e -> (b e -> e) -> e".
12:56:14 <khyperia> Can someone explain "left" and "up" in a type to me? Or, linking a general type tutorial would be good too.
12:56:34 <tswett> khyperia: can you show me the type you're talking about?
12:57:11 <khyperia> I'm just browsing through those language ext docs, saw RankNTypes, remembered that I have no idea what those terms left and up mean in a type.
12:57:14 <ski> tswett : no, your expression syntax `blah -> bleh'
12:57:49 <tswett> ski: you're asking how that's represented? If I remember correctly, that can be thought of as syntactic sugar for the double negation elimination function.
12:58:09 <tswett> khyperia: lemme take a look here, one sec.
12:58:43 <khyperia> I remember it has something to do with the syntax tree
12:58:50 <mp> bergmark: thanks, I'll github version worked (compiled), I'll reinstall from hackage
12:59:12 <tswett> khyperia: as in "a forall appearing within the left-hand side of (->) cannot be moved up"?
12:59:35 <khyperia> Something like that, yeah.
13:00:03 <tswett> Looks like "up" here pretty much means "out of the parentheses".
13:01:06 <khyperia> alright, so "left" means horizontally (as in same level of depth) on the syntax tree, and "up" means "towards the root"?
13:01:30 <khyperia> root as in the entire tree root, not a leaf
13:02:09 <tswett> ski: the double negation elimination function has type "((a -> Bottom) -> Bottom) -> a", which translates to (God forgive me)...
13:02:55 <tswett> forall e. ((((a e -> (e -> e) -> e) -> (e -> e) -> e) -> (a e -> e) -> e) -> e) -> e, if I'm not mistaken.
13:11:24 <teneen> edwardk: is there any example of how to use Data.Bits.Coding for binarizing a data type?
13:17:27 <jonkri> Why doesn't "head . (take 5) [1..]" work? :->
13:17:52 <FreeFull> (take 5) [1..] isn't a function
13:17:59 <Saizan> > (head . take 5) [1..]
13:18:00 <lambdabot>   1
13:18:05 <tromp_> > head . (take 5) $ [1..]"
13:18:06 <lambdabot>   <hint>:1:25:
13:18:06 <lambdabot>      lexical error in string/character literal at end of input
13:18:12 <tromp_> > head . (take 5) $ [1..]
13:18:14 <lambdabot>   1
13:18:17 <FreeFull> It will work with $
13:18:30 <tromp_> > head . take 5 $ [1..]
13:18:31 <lambdabot>   1
13:18:38 <dacc> hah, i just read about this in LYAH on the train today
13:18:55 <jonkri> Ah, infix functions can't take three argument.
13:18:56 <jonkri> s
13:19:02 <Taneb> ocharles, I'd like to do one of the 24 days of Hackage posts
13:19:44 <Taneb> ocharles, but I don't really know what to do it on
13:20:56 <enthropy> > (+) `foldr` 0 $ [1 .. 10]
13:20:57 <lambdabot>   55
13:21:15 <jonkri> In "head . (take 5) [1..]", how come "head . (take 5)" does not result in a function that takes a list and produces an Int?
13:21:30 <haasn> jonkri: that's head . (take 5 [1..])
13:21:37 <Eduard_Munteanu> jonkri: function application binds tighter
13:21:39 <haasn> not (head . take 5) [1..]
13:21:50 <Fuuzetsu> I'm sure There's A Lens For That™
13:21:52 <jle`> :t head . (take 5)
13:21:53 <lambdabot> [c] -> c
13:21:58 <jrmithdobbs> people providing libs to work with pure data types and not deriving data but not exporting all constructors so i can should be shot ;p
13:22:01 <Eduard_Munteanu> Actually tightest with the exception of record updates.
13:22:07 <haasn> Fuuzetsu: preview (taking 5 folded)
13:22:51 <jonkri> Eduard_Munteanu: Which function application are you referring to?
13:22:55 <jle`> jonkri: you can think of it as being interpreted as head . ( (take 5) [1..] )
13:23:08 <Eduard_Munteanu> jonkri: applying 'take 5' to [1..]
13:23:09 <jle`> the right hand side of the (.) needs to be a funconi
13:23:13 <jle`> *function
13:23:24 <Flonk> I'm dealing with triples and want to be able to compare them to Ints ( compare (_,_,x) y = compare x y ). Is such a thing possible in haskell?
13:23:25 <jle`> but ( (take 5) [1..] ) is a list
13:23:41 <haasn> Flonk: not using ‘compare’
13:24:01 <jonkri> Eduard_Munteanu: Why is not function application from "left to right" in this case?
13:24:09 <quchen> haasn: preview = (^..) ?
13:24:11 <Flonk> haasn: Okay, thats what I thought..
13:24:14 <Flonk> Thanks
13:24:21 <Eduard_Munteanu> jonkri: it is, but operators bind differently
13:24:21 <jonkri> s/Eduard_Munteanu/
13:24:24 <haasn> specifically, compare :: Ord a => a -> a -> Ordering -- so you can't have one ‘a’ be (Int, Int, Int) and the other be Int
13:24:27 <haasn> quchen: (^?)
13:24:30 <quchen> Ah.
13:24:44 <jonkri> Eduard_Munteanu: Infix operators, or in general?
13:24:46 <haasn> (^..) = toListOf
13:24:46 <Flonk> haasn: I thought maybe implicit casting is a thing
13:24:54 <Eduard_Munteanu> jonkri: infix
13:25:07 <Eduard_Munteanu> jonkri: '(.)' works like a function
13:25:16 <haasn> Flonk: of Int -> (Int,Int,Int) you mean?
13:25:50 <Flonk> haasn: Foo (a,b,Int) -> Int, but yes, somewhere along those lines
13:25:51 <haasn> Flonk: if you want to compare against numeric literals, keep in mind that they're polymorphic - and indeed, (Int, Int, Int) permits a sensible Num instance; so you can write compare (x,y,z) 5
13:26:03 <jonkri> Eduard_Munteanu: I see. :-)
13:26:04 <jonkri> Thanks, everyone!
13:26:05 <Eduard_Munteanu> jonkri: so that can be rewritten as (head) . ((take 5) [1..]).
13:26:26 <FreeFull> (Num a, Num b, Num c) => Num (a,b,c) would be a sensible instance
13:26:27 <Eduard_Munteanu> jonkri: or (.) head ((take 5) [1..])
13:26:31 <Flonk> haasn: Yeah, that might work!
13:27:08 <haasn> (though the one I'd expect is probably (Num a, Num b, Num c) => Num (a,b,c))
13:27:19 <haasn> and not Num a => Num (x,y,a)
13:27:29 <jonkri> I see. :-)
13:27:47 <haasn> Best make your own data type instead of (x,y,Int) ;)
13:27:56 <Eduard_Munteanu> jonkri: mind parsing isn't type-dependent, so things like  head foo bar   will appear as function application even if 'head' only takes one argument.
13:27:58 <tswett> On the one hand, it's difficult to imagine how this code could possibly work. On the other, it's also difficult to imagine how this code could possibly not work.
13:28:10 <tswett> I apologize in advance if the universe is destroyed by the code I'm about to run.
13:28:41 <Flonk> haasn: Its for an assignment, doesn't need to be beautiful :P
13:29:28 <mm_freak> Flonk: sorry, we can't help with nonbeautiful solutions =/
13:30:53 <Flonk> mm_freak: Haha
13:31:01 <Flonk> For uni I take the path of least resistance though
13:32:38 <Flonk> However I could restructure my program it so I only need an Ord (a,b,Foo c) instance, which isn't too bad I guess
13:38:45 <Eduard_Munteanu> Let 'data Parser a = Pure a | Token (Lexer a)' with 'pure = Pure' and a trivial (<*>) except (Token f) <*> (Token x) = Token (f <*> lex x), where lex takes care of skipping whitespace.
13:39:11 <Eduard_Munteanu> This looks a bit like the free monad for Token.
13:39:58 <Eduard_Munteanu> I suspect I can rewrite it as such. Is this a known thing?
13:40:19 <tswett> Free monads? Those are certainly a known thing.
13:40:20 <Eduard_Munteanu> For 'Lexer', sorry.
13:40:33 <Eduard_Munteanu> tswett: I mean this particular application to parsers.
13:41:26 <johnw> the free monad for lexer would be data Lexer a = Pure a | Lexer (Lexer a)
13:44:00 <Eduard_Munteanu> johnw: data Free f a = Pure a | Free (f (Free f a)), so I was considering Parser a ~ Free Lexer a ~ Pure a | Token (Lexer (Free Lexer a))
13:44:32 <johnw> ahh
13:44:47 <Eduard_Munteanu> So  Parser a ~ Pure a | Token (Lexer (Parser a))
13:44:53 <johnw> ok, I didn't see the change of Token (Lexer a) to Token (Free Lexer a)
13:45:04 <johnw> right
13:45:10 <johnw> that makes sense
13:45:15 <Eduard_Munteanu> johnw: yeah, I wonder if that's a reasonable generalization.
13:45:22 <johnw> so you end up with a chain of Lexer contexts around an ultimate Pure value
13:45:28 <johnw> Lexer (Lexer (Lexer (Pure a)))
13:45:49 <johnw> what information is Lexer preserving here?
13:45:53 <Eduard_Munteanu> johnw: yes, and each layer can do 'lex', AFAICT
13:46:04 <Eduard_Munteanu> johnw: Lexer can be a Parsec parser
13:46:15 <johnw> oh, it expresses the parser grammar as a tree, I get it
13:46:28 <johnw> so you represent it as a Free monad, and then reduce to do the actual parsing
13:46:41 <johnw> that sounds right
13:46:45 <Eduard_Munteanu> johnw: not really as a tree, I'm trying to automate skipping whitespace when you parse.
13:47:04 <johnw> oh, right, Lexer is linear
13:47:30 <johnw> how would you encode <|> then?
13:47:44 <Eduard_Munteanu> It could be something like a tree if used as a monad I suppose.
13:48:13 <Eduard_Munteanu> johnw: mm, I expect to pass <|> to the underlying parser
13:48:37 <johnw> another way to do this would be to use pipes-parse, I suppos
13:48:38 <johnw> e
13:48:56 <johnw> then you can automate the skipping without having to represent your parser structurally all-at-once
13:49:17 <Eduard_Munteanu> You need 'Pure' because you don't want to eat whitespace when you write stuff like Foo <$> pure A <*> pure B.
13:49:35 <Eduard_Munteanu> johnw: hm, I don't know that, I'll google it.
13:49:35 <lelf> is there a simple way to do negative look-behind in parsec?
13:49:50 <johnw> pipes-parse gives you "effectual streaming"
13:50:00 <johnw> effectful, I meant
13:50:13 <johnw> so, you'd have a stream of tokens, where the "effect" is to consume whitespace
13:50:34 <johnw> and then pipes-parse would let you consume that stream via a parser
13:50:48 <Eduard_Munteanu> Hm, that seems nice. I was working with attoparsec which doesn't provide a monad transformer though. :/
13:51:08 <johnw> oh, it doesn't?
13:51:12 <johnw> didn't know that
13:51:25 <jonkri> Good night, everyone!
13:51:43 <Eduard_Munteanu> johnw: that's nice. I tried to model something like layered parsers as comonads on Kleisli Maybe, but it's rather annoying in Haskell.
13:52:44 <johnw> Eduard_Munteanu: http://www.haskellforall.com/2013/06/pipes-parse-100-pushback-delimited.html
13:53:16 <Eduard_Munteanu> Because extract :: FedParser a -> Maybe a is like runParser and (=>>) :: (FedParser a -> Maybe b) -> (FedParser a -> FedParser b) would sort of refeed a parser.
13:53:32 <Eduard_Munteanu> Er, -> Maybe (FedParser b)
13:54:41 <johnw> ah, i see what you means about "comonads on Kleisli Maybe" now
13:54:48 <Eduard_Munteanu> (or perhaps a Store on Kleisli Maybe)
14:02:54 <jle`> anyone know any resources on how combinator parsers work/building one form the ground up?
14:03:11 <jle`> i have some vague idea
14:03:11 <tswett> Every so often, here, I evaluate the type of an expression including an implicit parameter, in order to see what type GHC expects to be there.
14:03:16 <Iceland_jack> jle`: There is a YouTube lecture by Wadler
14:03:24 <tswett> Usually it works, but sometimes I get an "unbound implicit parameter" error.
14:03:49 <Iceland_jack> jle`: Also http://www.cse.chalmers.se/edu/course/TDA452/FPLectures/Vid/
14:03:49 <alkabetz> Why do some libraries on Hackage not have Haddock links?
14:04:07 <tswett> Why do I get those sometimes? Can't it always give me a type that tells me what type the implicit parameter is supposed to have?
14:04:07 <Iceland_jack> jle`: Week 4 deals with parser combinators I believe
14:04:08 <Clint> alkabetz: usually because the documentation wasn't built, due to a build failure
14:04:11 <johnw> alkabetz: sometimes there are no docs, sometimes the process of generating the haddocks on the server crashes (most often because hscolour has a problem)
14:04:25 <jle`> Iceland_jack: thanks :)
14:04:28 <monochrom> jle`: http://www.cs.nott.ac.uk/~gmh/bib.html#monparsing is one way. there are others.
14:04:51 <alkabetz> Clint, johnw: :/  Where should I report that?  Upstream?
14:04:57 <johnw> yes
14:05:03 <Iceland_jack> jle`: You can also search for parser combinators and you'll find plenty of PDFs
14:05:07 <johnw> they may or may not be able to do anything about it, though
14:08:49 * hackagebot monad-extras 0.5.3 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.5.3 (JohnWiegley)
14:12:37 <ocharles> Taneb: great! give it some thought
14:12:42 <ocharles> I'm sure you could find something
14:13:50 * hackagebot HsOpenSSL 0.10.3.5 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.3.5 (MasatakeDaimon)
14:15:56 <Taneb> ocharles, thinking about tables or free-game
14:16:29 <ocharles> Taneb: both would be great! I find tables very interesting, but don't let me sway you
14:16:36 <ocharles> s/both/either/
14:16:37 <ocharles> :)
14:16:40 <johnw> tables is pretty cool
14:17:03 <Shapeshifter> Hi. I'm watching a video on parallelism in haskell and those par pseq bits as well as repa, and about how it's important to get the right granularity. So, if I write an algorithm in haskell, it will be completely sequential, unless I use these par/pseq things or repa or something?
14:17:20 <tswett> It'd be nice if I could just leave all my newtype constructors out and GHC would just say, "Hey, you need to add constructors here and here and here."
14:17:29 <johnw> Shapeshifter: right, there is no automatic parallelization
14:17:36 <Shapeshifter> johnw: I see.
14:17:40 <tswett> johnw: wouldn't it be up to the compiler?
14:17:53 <johnw> the compiler can't make the right trade-off decisions
14:18:04 <johnw> so it doesn't try
14:18:12 <tswett> Huh.
14:18:46 <Shapeshifter> Is it really that hard to auto-detect the right granularity? I mean, the RTS could measure the size of a spark versus the time it executed and after a few randomly sized sparks it could detect the ideal size or decide against parallelism...
14:18:53 <johnw> Shapeshifter: haha
14:18:59 <monochrom> johnw speaks the truth.
14:19:00 <johnw> Shapeshifter: what you ask has been the subject of deep research for many decades
14:19:09 <Shapeshifter> interesting.
14:19:20 <johnw> I've worked at companies whose entire funding was based on government grants to solve this very problem
14:19:37 <johnw> i know that BAE Systems is actively working on it right now, in fact
14:19:49 <Cale> It's like a quantitative version of the halting problem
14:19:54 <johnw> right
14:20:14 <johnw> now, if you could somehow embed a human being into the compiler, then it could work
14:20:28 <Eduard_Munteanu> Maybe types aren't rich enough.
14:20:55 <alkabetz> *gasp* Blasphemy!
14:21:08 <Eduard_Munteanu> It would be interesting to have types indexed by term sizes times some weights for the subterms.
14:21:14 <johnw> wow, I may have to permaban him for that
14:21:33 <monochrom> the good news for Haskell (and generally pure-functional languages) is: once you have decided what to parallelize, you can implement it by as simple as adding "par" at your chosen places.
14:21:41 <Cale> and even if you manage to parallelise subexpression evaluation automatically, that presumes that the algorithm was already in a form which was suitably branched to parallelise already
14:22:33 <Shapeshifter> It's an interesting topic...
14:22:56 <tswett> Richer type systems? I'm on it! No longer will newbies have to deal with the IO monad; with Hylisk, they'll be able to write their programs as functions of type World -> World!
14:23:09 <tswett> And then they'll write "\x -> x + x" and get an error message because you're not allowed to duplicate numbers.
14:23:11 <fryguybob> monochrom: Buit it may depend on where in memory things live :(
14:23:36 <Eduard_Munteanu> I find the dual problem interesting as well... what sort of logic do you get from a typesystem if you place bounds on e.g. complexity of subexpressions, not just expecting termination.
14:23:41 <monochrom> that goes into deciding what to parallelize, no?
14:24:11 <monochrom> my point is, with languages or programs that have mutable state all over the place, it is not as simple as adding "par"
14:24:32 <johnw> right, Haskell sets up your code very easily to add "par" here and there
14:24:52 <johnw> oftentimes I've achieved *n-cores speedup with a single s/map/parMap/ in my code
14:25:46 <johnw> (or more usually map ... `using` parListChunk n)
14:27:00 <Shapeshifter> Yeah it's surprisingly easy.
14:27:01 <Eduard_Munteanu> monochrom: hm... that sounds a bit like another thing I was thinking about. I heard Tanenbaum mentioning they tried to semi-automatically turn a monolithic kernel into a modular one. Turns out that's difficult too, because the trivial solution doesn't give you any more safety.
14:27:46 <monochrom> what is the trivial solution?
14:28:16 <Eduard_Munteanu> monochrom: you could turn all r/w into message passing, but that alone still doesn't prevent things from crashing other things.
14:28:48 <Eduard_Munteanu> Just like par everywhere doesn't give you benefits, if there's any duality in that.
14:29:44 <Eduard_Munteanu> (because e.g. what if you tell some other component to read a null pointer it has?)
14:31:12 <monochrom> aha, I don't find the two alike, but I see that the right thing to do is not to turn every individual r/w into a message, but rather, to group all r/w's suitably, and turn every group into a message. the problem is "suitably".
14:32:05 <Eduard_Munteanu> Yeah.
14:32:29 <taejo> in lens, why does (view (ix 0) "abc") complain about there being no Monoid instance for Char?
14:33:33 * quchen guesses that ix requires a traversal, which in general can have multiple targets, and when you view them they're mappended
14:33:34 <edwardk> ix 0 acts as a Traversal' String Char there. you may or may not have a target char, so it needs to know what to tell you when you ask for a char that is out of range
14:33:35 <Eduard_Munteanu> I'm not saying speed is opposite to correctness, but they do seem dual problems in the limit of non-termination. Perhaps there's more to Curry-Howard in the middle of that spectrum.
14:33:45 * quchen wins! :-)
14:33:52 <twilson> Hi, just checking whether there is an already existing name for f True = Just True ; f False = Nothing
14:34:04 <edwardk> e.g. what should view (ix 4) "abc"  return?
14:34:29 <quchen> twilson: True <$ guard p
14:34:32 <edwardk> > "abc"^!?ix 3  -- works if you know its there
14:34:34 <lambdabot>   No instance for (GHC.Show.Show
14:34:34 <lambdabot>                     (m0 (Data.Maybe.Maybe GH...
14:34:37 <edwardk> > "abc"^!?ix 0  -- works if you know its there
14:34:39 <lambdabot>   No instance for (GHC.Show.Show
14:34:39 <lambdabot>                     (m0 (Data.Maybe.Maybe GH...
14:34:47 <edwardk> > "abc"^?!ix 0  -- works if you know its there
14:34:49 <lambdabot>   'a'
14:34:52 <Iceland_jack> twilson: There is no single name for it afaik, what do you need it for?
14:35:06 <quchen> twilson: (x <$ guard p) is the general function for "if true put it in Just, else Nothing".
14:35:22 <quchen> Bonus: it works for any MonadPlus.
14:35:29 <twilson> quchen: thanks!
14:35:31 <tswett> Now there ain't no staafl.
14:35:34 <edwardk> you can also use preview (ix 0), view (singular (ix 0)), etc.
14:35:34 <Eduard_Munteanu> If you're writing code in Maybe, then guard is the right thing.
14:35:51 <Eduard_Munteanu> Since Maybe is a MonadZero.
14:36:03 <quchen> Eduard_Munteanu: Plus, you mean.
14:36:13 <quchen> twilson: It may be help to understand how guard and <$ work.
14:36:16 <johnw> x <$ guard p == mfilter (const p) (Just x)
14:36:22 <taejo> the type I'm looking at guarantees the presence of the element
14:36:23 <Eduard_Munteanu> quchen: er right, that's not in standard libs... but that would be correct as well for this
14:36:26 <taejo> it's a total map
14:37:15 <tswett> Having spent a couple of hours writing code consisting entirely of conversions between equivalent types, my brain's out of juice.
14:37:25 <tswett> See all y'all later.
14:38:53 <jle`> shouldnt something like add5 = (+) 5 be automaticlaly polymorphic?
14:39:04 <geekosaur> @where DMR
14:39:04 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:39:09 <geekosaur> ^
14:39:47 <jle`> geekosaur: thanks
14:39:53 <Eduard_Munteanu> jle`: add5 x = 5 + x  should
14:40:23 <Eduard_Munteanu> Otherwise you want to provide a type signature or disable MR.
14:40:51 <Hari`> if you do :t for your add5 function, jle, you can see it's not polymorphic: add5 :: Integer -> Integer
14:41:00 <jle`> was just playoung around in ghci, and looked at the :t of it
14:41:11 <jle`> i was surprised, becuase :t (+) was Num a => a -> a -> a
14:41:19 <jle`> and :t 5 was Num a => a
14:41:32 <Eduard_Munteanu> (+) is a typeclass method, and has a signature anyway.
14:42:02 <Iceland_jack> :t (5 +)
14:42:03 <lambdabot> Num a => a -> a
14:42:17 <Hari`> gteekosaur's function is of type Num a => a -> a
14:42:19 <dwcook> :t ((5 :: Int) +)
14:42:20 <lambdabot> Int -> Int
14:42:53 <geekosaur> I didn't give a function, just pointed at the docs for the MR
14:42:53 <dwcook> geekosaur, what's the D in DMR?
14:42:58 <quchen> Dreaded.
14:42:58 <geekosaur> "dreaded"
14:42:58 <Eduard_Munteanu> dwcook: Dreaded
14:43:02 <dwcook> Haha
14:43:22 <Eduard_Munteanu> Yeah, funnily DMR is even more common than MR, as names for that.
14:43:50 <quchen> 90% of everything is crap.
14:44:16 <jle`> :t (+) 5
14:44:17 <lambdabot> Num a => a -> a
14:44:25 * alkabetz tilts head at quchen
14:44:36 <dpwright_> I have a class which specifies some functions with class constraints
14:45:08 <dpwright_> if I want to specify that for a particular instance of that class, I want to use this specific type (which conforms to those constraints)
14:45:26 <dpwright_> is that possible / what should I be looking into to do that?
14:45:48 <Eduard_Munteanu> dpwright_: yes, you can provide specific types for more than one variable
14:45:55 <geekosaur> :t let x = (+) 5 in x
14:45:55 <lambdabot> Num a => a -> a
14:46:21 <Eduard_Munteanu> dpwright_: class Foo a b where ...    instance Foo Bar Baz where ...
14:46:51 <dpwright_> ahhh... is that with the multiparamtypeclasses extension?
14:46:52 <Eduard_Munteanu> dpwright_: can you give an example of such a class?
14:46:57 <Eduard_Munteanu> dpwright_: yes
14:47:06 <Eduard_Munteanu> MPTCs are *really* common.
14:47:16 <Eduard_Munteanu> It shouldn't even be an extension in 2013.
14:48:00 <dpwright_> what I'm trying to write is like a "context" monad, which is basically like the reader monad but the thing that you use to run it calls bracket first (pretty much)
14:48:22 <alkabetz> What’s the command to get lambdabot to remove all definitions?
14:48:27 <quchen> @undef
14:48:27 <lambdabot> Undefined.
14:48:28 <dpwright_> so I'm trying to make what is essentially the "r" in the reader monad conform to a typeclass Contextual which provides "init" and "finalise" functions
14:48:56 <dpwright_> at the point at which I'm instantiating Contextual, I know what I expect my "parent" context to be
14:48:56 <alkabetz> quchen: Ah, thanks.
14:49:06 <dpwright_> and sometimes I want to call functions specific to that context
14:49:20 <nimish> @dpwright_ pretty sure monads must not constrain the types they range over
14:49:20 <lambdabot> Unknown command, try @list
14:49:27 <skeuomorf> @list
14:49:27 <lambdabot> What module?  Try @listmodules for some ideas.
14:49:31 <skeuomorf> @listmodules
14:49:31 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
14:49:31 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
14:49:37 <Eduard_Munteanu> You can make your MonadContext class.
14:49:42 <taejo> So is there a class I should use instead of Ixed if my datatype is total?
14:49:45 <skeuomorf> @list system
14:49:45 <lambdabot> system provides: listchans listmodules listservers list echo uptime
14:49:49 <Eduard_Munteanu> That'd be the fully-polymorphic approach to it.
14:49:50 <dpwright_> nimish: Ah, is that a thing? I wasn't aware of that
14:50:12 <skeuomorf> @list dict
14:50:12 <lambdabot> dict provides: dict-help all-dicts bouvier cide devils easton elements foldoc gazetteer hitchcock jargon thesaurus vera wn world02
14:50:17 <skeuomorf> @list easton
14:50:18 <lambdabot> dict provides: dict-help all-dicts bouvier cide devils easton elements foldoc gazetteer hitchcock jargon thesaurus vera wn world02
14:50:30 <prooftechnique> skeuomorf: You can query lambdabot if you'd like to explore the options
14:50:43 <nimish> dpwright_: I think you can get around it by making an indexed monad or something but you lose do-notation unless you enable rebindablesyntax
14:50:48 <dpwright_> Eduard_Munteanu: Sorry, I don't follow.   You mean, as well as the monad itself, make a class representing it (as MonadIO is to IO)?
14:51:01 <skeuomorf> prooftechnique: query, how?
14:51:08 <Eduard_Munteanu> dpwright_: yes, that's one approach, more like MonadReader I mean
14:51:20 <prooftechnique> Type /query lambdabot and it will open a query window with lambdabot
14:51:23 <nimish> or maybe I'm misunderstanding you
14:52:21 <skeuomorf> prooftechnique: oh, awesome, thanks :)
14:53:38 <briennetheblue> is there a way to put lambdabot's djinn in multiple solution mode?
14:53:54 <quchen> I don't think so
14:54:17 <jle`> is there any way to show the sql query that a particular Persistent backends produce
14:54:19 <briennetheblue> i tried to cabal install djinn but the build failed :(
14:55:11 <dpwright_> nimish: Ah -- I don't think you are, but I think looking back at my code it might not be an issue in my case.  I'm not applying the constraint at the class level, but at the function level -- in my "runContext" function
14:55:19 <hpc> briennetheblue: can you paste the error?
14:55:33 <briennetheblue> hpc: gcc: error: unrecognized command line option ‘-Wl’
14:55:41 <dpwright_> the Context itself is pretty much just a newtype wrapper around Reader
14:56:36 <dpwright_> Eduard_Munteanu: I will take a look at the MPTC approach... I think I tried it briefly yesterday but then I got sidetracked trying to do it with type families instead and started tying myself in knots
14:56:36 <Eduard_Munteanu> dpwright_: do your functions need access to the 'r'? Or can 'r' be the context and only that?
14:56:54 <dpwright_> I think I have the MPTC version somewhere in my undo history still ;-)
14:57:23 <dpwright_> Eduard_Munteanu: No, actually I want to hide the "r" from them and provide my own accessors, really
14:58:20 <dpwright_> in particular, I don't want them to be able to call something like "runReader" because that would circumvent the bracket call, which happens in my runContext
14:58:54 <Eduard_Munteanu> dpwright_: oh, then you could just wrap it in a data/newtype. Anything else you want to do with the underlying monad?
15:00:53 <dpwright_> nothing fancy... I think the problem I was having was with accessing functions from the surrounding context, which I was imagining could be almost anything, but in reality is probably always going to be another one of these context monads or IO.  But if I make a MonadContext typeclass as you suggest I can access Context stuff through that, and if I constrain to that and MonadIO then I should have access to everything I need.  Sometimes I *wo
15:01:20 <Eduard_Munteanu> dpwright_: that got cut off at "Sometimes I *wo"
15:01:40 <hpc> i am known to *wo sometimes as well
15:01:47 <dpwright_> Eduard_Munteanu: That'll teach me for being verbose on irc!  "*won't* want IO, but I suppose I could just define Context and ContextIO as two separate things
15:01:50 <dpwright_> "
15:02:22 <dpwright_> hpc: Heh, it was an admission, I just had to get it out there
15:04:48 <dpwright_> Thanks Eduard_Munteanu, you've given me a couple of things to think about.  I think I have a good idea how I'm going to approach this now.
15:05:32 <dpwright_> I still don't have a good feeling of which GHC extensions are widely accepted and which I should be careful of, so it's good to know that MPTC is so common
15:05:35 <briennetheblue> i don't understand why gcc is involved in building djinn
15:06:17 <hpc> dpwright_: most of the scary extensions are going to have scary names
15:06:36 <dpwright_> hpc: Like?
15:06:43 <hpc> incoherent instances
15:06:54 <dpwright_> haha, fair point
15:07:07 <jml> I quite like the syntax highlighting in LYAH
15:07:12 <Eduard_Munteanu> Power outage.
15:07:31 <hpc> undecidable instances is on the fence
15:07:37 <dpwright_> Eduard_Munteanu: In case you missed it: "Thanks Eduard_Munteanu, you've given me a couple of things to think about.  I think I have a good idea how I'm going to approach this now.
15:07:45 <hpc> and then the stuff below that on the "expand instances" heirarchy are all super safe
15:07:49 <int-e> hpc: that name is not nearly scary enough. (compared, say, to the fairly harmless UndecidableInstances)
15:07:54 <Eduard_Munteanu> dpwright_: if you want access to an underlying monad like IO, there's MonadBase.
15:08:42 <hpc> template haskell is iffy, but not because it's really dangerous, so much as that it enables you yourself to be dangerous
15:08:44 <dpwright_> Eduard_Munteanu: Oh, interesting!  So that will lift me to the topmost monad, whatever that may be?
15:09:31 <dpwright_> hpc: Coming from lisp, I can't decide whether diving into template haskell is going to be a rediscovery of former joy or a painful experience
15:09:38 <hpc> and then the other one is when you mess around with the monomorphism restriction
15:09:41 <Eduard_Munteanu> dpwright_: but really, you should try just making a data wrapper like   data ContextT m a = ContextT (m a) Context   and a MonadTrans instance, hide the constructor and provide a  runContextT.
15:09:45 <hpc> other than that the rest are quite safe
15:09:53 <hpc> according to a quick scan through ghc -X<tab><tab>
15:10:15 <dpwright_> Eduard_Munteanu: Right, I've been dropping my "t"s in this conversation but my original plan was to model this as a monad transformer
15:10:22 <alkabetz> dpwright_: It’s going to be painful.
15:10:38 <briennetheblue> is gcc used in the linking of the .o files?  i don't know much about compiling/linking...
15:10:52 <hpc> it uses the linker, which is separate from gcc
15:11:01 <alkabetz> I forget, does it use gold yet?
15:11:15 <hpc> gcc does cpp (external tool), then compilation and code generation, then calls the linker (usually ld)
15:11:39 <Eduard_Munteanu> dpwright_: have you seen Yesod's ResourceT?
15:11:43 <briennetheblue> ok.  the error is specifically from gcc though
15:11:48 <hpc> in one version of ghc there's a bug that makes gold unusable
15:11:52 <dpwright_> Eduard_Munteanu: No, I haven't worked with Yesod
15:11:57 <hpc> but yeah, that's weird
15:12:09 <Eduard_Munteanu> dpwright_: it's pretty much what you want, and available as a separate thing.
15:12:09 * dpwright_ searches hackage
15:12:33 <donri> hpc: and then there's the Safe extension, which is really unsafe because it prevents your code from compiling!
15:12:35 <Eduard_Munteanu> dpwright_: http://hackage.haskell.org/package/resourcet
15:12:51 <hpc> donri: pppsh, more like it's safe because it prevents your code from compiling
15:13:09 <hpc> at the very worst, "whoops, that's wrong" and you remove the extension
15:13:10 <donri> i like how innocent extensions like type families and newtype deriving let you write unsafeCoerce
15:13:11 <Eduard_Munteanu> It does more though.
15:13:27 <donri> hpc: (i was being silly)
15:13:34 <hpc> ah
15:13:44 <dpwright_> Eduard_Munteanu: Oh, thanks, this looks like it might do the job actually
15:13:46 <hpc> yeah, that coerce thing is a more serious concern
15:14:25 <hpc> donri: does it need to be newtype deriving, or could you "derive" the instance yourself and have just type families?
15:14:48 <donri> hpc: you can write unsafeCoerce because unsafeCoerce is what generalized newtype deriving *is*
15:14:58 <hpc> ah, that's a bummer
15:15:04 <hpc> or rather, a releif
15:15:06 <hpc> ief
15:15:09 <donri> (it's fixed in 7.8)
15:15:14 <hpc> i figured
15:15:16 <Eduard_Munteanu> Hah.
15:15:17 <Hari`> hi, is there a way, besides doing something like printing, to force the execution of a forked (forkIO, i.e. threaded) function in haskell?
15:15:52 <Eduard_Munteanu> Hari`: what does your thread *do*?
15:15:55 <donri> :t evaluate
15:15:56 <lambdabot> a -> IO a
15:16:02 <lpaste> briennetheblue pasted “entire output for cabal install djinn” at http://lpaste.net/95301
15:17:29 <alkabetz> briennetheblue: Oh yeah, that’s the fun GHC/gold problem
15:17:45 <alkabetz> Can you paste the output of ld --version?
15:18:23 <lpaste> briennetheblue pasted “ld --version” at http://lpaste.net/95302
15:18:38 <alkabetz> Oh, hmm.  That’s weird.
15:19:05 <Clint> shouldn't gcc understand -Wl no matter what?
15:19:08 <alkabetz> Guess it’s not a gold problem after all.  Sorry. :(
15:19:31 <briennetheblue> version 7.4.1 of ghc btw (not sure if that's relevant)
15:20:26 <Clint> briennetheblue: are you diverting or wrapping gcc somehow?
15:21:59 <briennetheblue> Clint: i don't think so... gcc does complain if i try to pass it the -Wl flag myself though
15:22:15 <cfoch> hello. I want to make a program to show the solutions of the classical N Queens problem. It's a graphical one. So... When I press the "NEXT" button, it show me the first solution, if I press it again, it shows the second one, then the 3th and the 4th, and... But how can I do that? So I have my list with each solution, but Haskell DOESN'T ALLOW CHANGING STATES OF VARIABLES! How could Haskell change from the state Solution 1 to Solution 2, for example?
15:22:59 <Clint> briennetheblue: ah, well, there should be something after -Wl
15:23:10 <Eduard_Munteanu> cfoch: do you have a function that shows you a solution if you give it one?
15:23:25 <Clint> briennetheblue: you could try grabbing the debian djinn source package and building that
15:23:46 <hpc> or fixing the cabal file
15:23:55 <Eduard_Munteanu> cfoch: if you have such a function, and a list of solutions, then you can make it iterate over all solutions.
15:23:57 <hpc> and then contributing to djinn!
15:24:05 <Eduard_Munteanu> :t mapM_
15:24:06 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
15:24:17 <Clint> oh yeah
15:24:22 <Clint> briennetheblue: http://anonscm.debian.org/darcs/pkg-haskell/djinn/patches/
15:24:22 <cfoch> Eduard_Munteanu: I have a list of solutions
15:25:15 <Eduard_Munteanu> cfoch: ok. But do you have a function (an IO action really) that takes a solution as input and displays it?
15:25:49 <japesinator> The easiest thing I can think of is do notation to change a variable.  That's messy though and there's probably a better solution.
15:26:27 <Eduard_Munteanu> japesinator: I think they're trying to display the list of solutions before having a way to display one solution.
15:26:54 <Eduard_Munteanu> That alone doesn't require stateful stuff.
15:26:54 <cfoch> Eduard_Munteanu: yes... I give it a solution and it display it on the screen
15:27:11 <cfoch> Eduard_Munteanu: but only works for one solution
15:27:32 <Eduard_Munteanu> cfoch: ok, so you have  display :: Solution -> IO ()  and  xs :: [Solution].
15:28:30 <Eduard_Munteanu> cfoch: there's 'mapM_' which can apply your 'display' to the entire list of solutions...
15:28:33 <Eduard_Munteanu> :t mapM_
15:28:33 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
15:28:53 <cfoch> Eduard_Munteanu: Yes... something like that... Not exactly a type Solution... but represents the idea
15:28:54 <Eduard_Munteanu> Where a = Solution, m = IO and b is ().
15:29:25 <Eduard_Munteanu> mapM_ f :: [Solution] -> IO ()
15:29:48 <Eduard_Munteanu> Er, I mean 'display' by 'f'.
15:31:30 <Eduard_Munteanu> :t mapM_ print
15:31:30 <lambdabot> Show a => [a] -> IO ()
15:32:09 <Eduard_Munteanu> cfoch: is this still confusing?
15:32:55 <cfoch> Eduard_Munteanu: but remember when I press the button NEXT I want to stop it in the current solution1 (the first time I press the button). If I again press the NEXT button it change to the solution2 and stops until I've pressed the NEXT button again
15:33:14 <cfoch> Eduard_Munteanu: I think mapM_ iterates but doesn't "stop"
15:33:41 <Eduard_Munteanu> cfoch: yes... but if you apply mapM_ to a function which displays a solution and waits for input...
15:34:49 <Eduard_Munteanu> Then for each solution in your list, it will display it and wait for you to press the button.
15:41:11 <cfoch> Eduard_Munteanu: when you say "waits for input" do you mean "waits for the next click on the button"?
15:42:00 <Eduard_Munteanu> cfoch: yes
15:54:17 <briennetheblue> Clint: thanks, i was able to build it after applying that patch :)
15:57:45 <lilred> anyone comfortable with higher-order abstract syntax? I've got a couple questions
15:58:35 <lilred> damn it
15:59:44 <Eduard_Munteanu> lilred: hard to be comfortable not knowing the question :)
16:00:16 <Hari`> hi
16:00:20 <edwardk> lilred: a lot of us in here are generally comfortable with HOAS
16:00:29 <edwardk> lilred: ask away, we'll answer as we can
16:00:55 <alkabetz> Hi, Hari`
16:01:03 <lilred> Eduard_Munteanu: I'm not even sure what my question is, I'm just dabbling in language implementation and I feel like it would be difficult to perform function-local transformations if the declaration site is directly referred to in many places
16:01:40 <edwardk> lilred: HOAS is generally hard to work with when you want to transform the code much at all. I tend to switch to other systems, such as bound for that case.
16:01:51 <lilred> in more general terms I'm wondering how to do graph transformations in a purely functional way
16:02:19 <edwardk> if you haven't read it https://www.fpcomplete.com/user/edwardk/bound may be useful
16:02:29 <lilred> Thank you edwardk :)
16:03:03 <lilred> is bound strictly for DSL implementations within Haskell? I'm trying to implement a stand-alone language
16:03:15 <edwardk> i use bound inside compilers as well
16:03:20 <lilred> awesome
16:03:33 <edwardk> its useful for manipulating the language you're writing in general
16:03:38 <edwardk> basically it takes care of name capture for me
16:03:46 <jrmithdobbs> is there a way to add a where or let clause to an instance definition so that it can have local functions to make things more readable?
16:03:52 <edwardk> leaving me the interesting parts to work on
16:04:00 <edwardk> jrmithdobbs: sadly no
16:04:08 <jrmithdobbs> so they have to be toplevel?
16:04:15 <edwardk> jrmithdobbs: yep
16:04:20 <jrmithdobbs> sad panda
16:04:59 <enthropy> you can put a let/where on each method definition
16:05:14 <jrmithdobbs> ya I needed a shared one amongst a couple different pattern matches
16:05:26 <jrmithdobbs> (toJSON definition, i'm sure you can come up with reasons why this would be useful ;p)
16:05:31 <Bor0> @@src id
16:05:36 <Bor0> @src id
16:05:36 <lambdabot> id x = x
16:05:54 <jrmithdobbs> i'll just make the function name less generic and not export it I guess :(
16:07:15 <apo> Hey, I'm messing around with classes and trying to create a common interface for Data.Set and Data.List, but I'm failing pretty hard. Could somebody tell me my error in the line "size (_:xs) = succ (size xs)" in http://p.0au.de/97cbf2f6/ ?
16:08:17 <enthropy> jrmithdobbs: instead of    toJSON (C1 x) = ...; toJSON (C2 x) = ...; another option is:    toJSON cx | C1 x <- cx = ... | C2 x <- cx = ...
16:08:26 <ion> apo: The compiler is better at that than us. Please tell us what the compiler said.
16:08:26 <lilred> edwardk: I have no idea what I'm looking at :(
16:08:27 <enthropy> the latter will have one where
16:08:47 <apo> ion: http://p.0au.de/8de712d2/
16:09:06 <lilred> I'm thinking, maybe I could make the whole program a graph, and
16:09:07 <ion> apo: Try adding a functional dependency to the class.
16:09:19 <lilred> represent it using adjacency lists
16:09:22 <apo> ion: That was ListSet a b | a -> b, right?
16:09:26 <ion> apo: I think so
16:09:29 <jrmithdobbs> enthropy: was wanting thath whole replaceQueryOp in a where clause for the instance of toJSON :(
16:09:32 <edwardk> lilred: perhaps the examples will make more sense https://github.com/ekmett/bound/blob/master/examples/Simple.hs and https://github.com/ekmett/bound/blob/master/examples/Deriving.hs
16:09:37 <apo> ion: thanks
16:09:47 <lilred> Thank you so much edwardk!
16:10:18 <apo> that worked
16:11:26 <jrmithdobbs> anyways, other than not being able to scope that how I want to, is that code particularly ugly? ;p
16:12:06 <apo> now... how can I make map return the same (i.e. Set or List of type e)? I tried "map :: (b -> e) -> a -> a e", but then I get "`a' is applied to too many type arguments"
16:12:16 <apo> which makes sense, really
16:12:31 <apo> hm
16:12:34 <apo> I guess it's a whole new type
16:13:15 <geekosaur> (b -> e) -> a b -> a e ?
16:13:34 <geekosaur> but you probably need a constraint on a
16:14:05 <apo> I tried "map :: (b -> c) -> a -> d" for the class, and "map :: (a -> b) -> [a] -> [b]" for the instance, but now it says that the signature doesn't match
16:16:21 <apo> same with "map :: ListSet c d => (b -> d) -> a -> c" for the class
16:16:47 <apo> signatures are black magic X_x
16:19:06 <Bor0> @src last
16:19:06 <lambdabot> last [x]    = x
16:19:06 <lambdabot> last (_:xs) = last xs
16:19:06 <lambdabot> last []     = undefined
16:19:54 <geekosaur> (ListSet c b, ListSet c d) => (b -> d) -> c b -> c d -- ?
16:20:25 <geekosaur> signatures are quite logical, actually
16:21:23 <apo> geekosaur: but c is [d], not [b]
16:21:48 <jrmithdobbs> i seriously love this language, still can't believe I ignored it for so long ;p
16:21:58 <geekosaur> maybe I am confused. are you really mapping over always-a-list?
16:22:34 <geekosaur> also I don't quite see how you got what you just said from what I just said, which means you probably have a very wrong understanding of signatures
16:23:13 <apo> geekosaur: http://p.0au.de/687b61aa/
16:23:14 <geekosaur> which may go along with your attempts to say you are always mapping over a list, when you seem to be trying to build a thing which can be either a list or a set
16:23:30 <apo> I'm building the instance for lists right now
16:23:41 <apo> so right now I'm always mapping over a list :P
16:24:00 <geekosaur> but your class signature for map is nonsense for either list or set
16:24:16 <geekosaur> I gave you the right class instance. you should try to understand why it is right
16:25:11 <geekosaur> your List instance map cannot match the class signature you have for map. I'm not sure *anything* can match your class signatire for map, in fact
16:25:53 <geekosaur> (aside from the degenerate case, bottom / undefined)
16:27:21 <apo> I am, but I don't see it. If I want to e.g. map some (Int->Char) to [Int], the map would be (Int->Char) -> [Int] -> [Char], with a and b in the instance signature being Int and Char, and for the class signatures I'd have "ListSet [Int] Int" (a b), "ListSet [Char] Char" (c d)... but not "ListSet [Char] Int" (c b), right?
16:27:32 <geekosaur> I'll give you a hint here: in ```(ListSet c b, ListSet c d) => (b -> d) -> c b -> c d```, c will be [] for the list case
16:27:49 <geekosaur> unless you are doing something very strange which doesn't seem to match your code
16:28:42 <geekosaur> note, c is not [Int] or [Char]
16:28:51 <apo> I thought c was "Array containing <some type>"
16:29:12 <geekosaur> oh, I see, you're doing it in what is probably not the ideal way to do it
16:29:17 <apo> since I have instance ListSet [a] a where
16:29:18 <geekosaur> and possibly a not very sensible way to do it
16:29:25 <apo> Should I write "instance ListSet [] a"?
16:29:37 <apo> (Then I shouldn't need the functional dependency, either...)
16:29:40 <geekosaur> right, the problem I have with that is: what does ```instance ListSet [a] b``` mean?
16:29:48 <apo> Nothing.
16:30:21 <apo> I /thought/ that this is a weird way to write it, but didn't see anything better
16:30:26 <geekosaur> then why do you formulate your type so that it can be written?
16:30:34 <geekosaur> instance ListSet [] Char
16:31:04 <benmachine> I don't htink apo's class is wrong
16:31:09 <apo>     Expecting one more argument to `[]'
16:31:27 <geekosaur> it's not strictly *wrong*, just far from ideal because it permits nonsense like instance ListSet [Int] Char
16:31:37 <geekosaur> apo: you need to change the types to match
16:31:41 <apo> I did
16:32:08 <apo> er, I think?
16:32:15 <geekosaur> what you have assumes that in ListSet a b, a is of kind * (something like Int). with mine it is of kind (* -> *) (something like Set or [])
16:32:58 <geekosaur> which is why my signature for map uses types like c b and c d
16:33:08 <geekosaur> c will be [] or Set
16:33:18 <apo> That error's not for the map anymore
16:33:20 <apo> It's just for the instance
16:33:28 <apo> so right now the map signature is irrelevant
16:33:34 <geekosaur> right, all the other types would have to change as well, as I said
16:34:04 <geekosaur> well, maybe go back to what you had and forget what I said, you can "make it work" but you wll find there's no good way to prevent nonsense instances like ListSet [Int] Char
16:34:30 <geekosaur> I'm trying to show you a different way to do it which maybe you're not ready to handle yet
16:34:38 <geekosaur> but which avoids the possibility of nonsense
16:35:08 <geekosaur> but it involves "higher order" types
16:35:20 <lilred> hey guys, are there formatting guides for Haskell?
16:35:31 <apo> geekosaur: I'm ready to handle it, but only if it actually /works/ :P
16:35:52 <geekosaur> it works but ALL your signatures assume simple types
16:35:54 <AshyIsMe> lilred: i'd love a vim auto format plugin with haskell support also, let me know if you find one
16:36:03 <geekosaur> and won't work with a higher order type like []
16:36:13 <geekosaur> you need different signatures everywhere
16:37:18 <mm_freak> just a terminology note:  i wouldn't call a type higher order, unless it takes an argument of kind a -> b
16:38:13 <geekosaur> well, I originally used it in scare quotes, for a reason. but I don't think we've nailed down a good term for those yet
16:38:25 <mm_freak> type constructor
16:38:38 <geekosaur> oh, also, I see you are importing two different modules both as L
16:38:40 <mm_freak> i hate it, but it's common
16:38:50 <alkabetz> lilred: Have a look at http://www.haskell.org/haskellwiki/Category:Style
16:39:15 <alkabetz> lilred: I wouldn’t say there’s a style guide, but there are definitely some style points that the community has agreed on
16:39:24 <mm_freak> geekosaur: that's fine…  i do that a lot
16:39:31 <lilred> Should I prefer nested let statements or multiple bindings in one let statement? (Right now I can't get multiple bindings style to compile)
16:39:38 <mm_freak> import Pipes as P; import qualified Pipes.Prelude as P
16:39:59 <geekosaur> multiple bindings will compile but: indentation matters
16:40:08 <prooftechnique> GHC head, why you so slow to build? -_-
16:40:20 <lilred> can someone show me how to do multiple bindings? http://ideone.com/dTIcxa
16:40:24 <lilred> (lines 7 and 8)
16:40:31 <Peaker> lilred: the main semantic difference is allowing/disallowing recursive references
16:40:34 <monochrom> GHC is slow to build
16:40:49 <mm_freak> lilred: the error is that you're using tabs
16:41:06 <monochrom> but you ought not need to build GHC yourself, even for HEAD
16:41:09 <lilred> jesus :( any good editor on Windows that automatically turns tabs into space?
16:41:17 <alkabetz> Emacs?
16:41:19 <mm_freak> emacs, vim
16:41:25 <Peaker> tabs :((((
16:41:28 <alkabetz> Maybe Notepad++?
16:41:28 <prooftechnique> Notepad++
16:41:46 <monochrom> most editors can. but not default setting. you must manually change setting.
16:41:50 <mm_freak> notepad++ hardly qualifies as a "good editor"
16:41:52 <mm_freak> SCNR =)
16:42:05 <Peaker> It's amazing that the default is "please corrupt my file with characters noone agrees upon the meaning of"
16:42:21 <monochrom> notepad++ is good enough for me, but that's just me
16:42:41 <apo> whew
16:42:42 <apo> got it
16:42:46 <apo> geekosaur: thanks for the help
16:43:06 <geekosaur> I'm working on an example of what I'm talking about btw
16:43:39 <mm_freak> > let foo = "foo " ++ bar; bar = "bar " ++ foo in foo
16:43:40 <lambdabot>   "foo bar foo bar foo bar foo bar foo bar foo bar foo bar foo bar foo bar fo...
16:44:22 <lilred> Can someone explain to me the syntax error on line 11? http://ideone.com/dTIcxa
16:44:38 <monochrom> I think I know why editors default to: 1. inserting tabs; 2. displaying tabs to your liking, not to the traditional standard
16:44:55 <monochrom> unfortunately, it doesn't pan out with Haskell
16:45:01 <lilred> sorry for bothering you guys with silly questions, I'm moving to Haskell from ML and the syntax is proving an issue
16:45:19 <mm_freak> lilred: doesn't look like there is a syntax error
16:45:34 <mm_freak> lilred: are you using ideone for development or just for pasting?
16:45:44 <lilred> just for pasting, I'm using WinGHCi for dev
16:45:58 <monochrom> what is with the random greening on ideone.com? can I turn it off?
16:46:12 <lilred> monochrom: their syntax highlighting algorithm is broken
16:46:12 <mm_freak> lilred: then i'd ask you to use lpaste.net instead
16:46:36 <mm_freak> ideone makes the code really difficult to read
16:46:37 <alkabetz> lilred: You don’t use 'in' in a 'do' block (line 10)
16:46:41 <lilred> mm_freak: sure, here it is in lpaste form http://lpaste.net/95309
16:46:51 <monochrom> oh! what alkabetz says
16:46:51 <lilred> alkabetz: great, thank you!
16:46:56 <mm_freak> alkabetz: there is no do-block
16:47:07 <monochrom> line 6 the end
16:47:13 <mm_freak> but there are two nested lets
16:47:20 <mm_freak> oh
16:47:22 <mm_freak> d'oh
16:47:31 <lilred> removing the "in" fixed it :D
16:47:40 <mm_freak> you should indent to do-block further
16:47:47 <monochrom> yeah, that too
16:47:49 <mm_freak> past the indentation level of the outer 'let'
16:47:49 <lilred> I wonder why "in" is necessary though? I come from F# and there are no "in"
16:48:09 <prooftechnique> let in a do block is different from let in a let ... in block
16:48:19 <lilred> monochrom, mm_freak: can you show me what you mean by indenting further? Like how much further?
16:48:21 <mm_freak> 'let' without 'in' is allowed in do-notation and comprehensions
16:48:25 <mm_freak> otherwise it doesn't make sense
16:49:00 <jrmithdobbs> lilred: it might scare you off but the "demystifying do block syntax" section of realworldhaskell will help you understand that
16:49:04 <jrmithdobbs> "do" isn't want it seems
16:49:12 <jrmithdobbs> s/want/what/
16:49:40 <lilred> jrmithdobbs: I'm already well acquainted with monad syntax in F#, do you think this would still be useful? L(
16:49:43 <lilred> :)*
16:49:51 <mm_freak> lilred: http://lpaste.net/95309
16:49:53 <mm_freak> see annotation
16:50:07 <jrmithdobbs> lilred: ya he covers the semantics pretty well
16:50:13 <jrmithdobbs> lilred: but you can probably skim most of it in that case ;p
16:50:39 <lilred> jrmithdobbs: gotcha. Haskell is a pretty sweet language btw.
16:51:16 <geekosaur> hrm. have written myself into a corner on fold, it seems
16:51:23 <mm_freak> that's how i would have likely written it (disregarding folds, etc.)
16:51:49 <lilred> my only concern with Haskell so far is its seeming lack of metaprogramming facilities (reflection, etc)
16:52:07 <geekosaur> actually I'm not sure fold can be typed properly...
16:52:19 <jrmithdobbs> lilred: they're there, they're just hidden and kind of confusing and semi-limited from what i've seen
16:52:31 <jrmithdobbs> lilred: and all in extensions (TemplateHaskell is probably what you're looking for)
16:52:38 <mm_freak> lilred: what do you mean by reflection?  haskell certainly has something called "reflection", but it may be something different =)
16:53:03 <geekosaur> reflection requires runtime tyoes
16:53:05 <geekosaur> *types
16:53:18 <jrmithdobbs> geekosaur: no it doesn't
16:53:28 <geekosaur> it also imples dynamic types; while you can do these it's not "natural"
16:53:30 <mgsloan> lilred / jrmithdobbs: Template Haskell, SYB, or Generics can pretty much do everything you might want. TH does come with some compile-time performance issues though
16:53:32 <mm_freak> geekosaur: haskell's Typeable doesn't require run-time types
16:53:52 <lilred> mm_freak: the two things I'd be looking for are Lisp-style introspection (without necessarily allowing for run-time modification of code) and attaching metadata to expressions in code
16:53:59 <geekosaur> it requires enough of a runtime type to know whether cast can succeed, at least
16:54:03 <jrmithdobbs> mm_freak: i'm really disliking typeable
16:54:13 <mgsloan> And SYB comes with some runtime performance issues :) Which are largely solved by things like generics or uniplate / multiplate / etc
16:54:21 <mm_freak> lilred: the former is not possible, the latter is actually easy enough
16:54:23 <jrmithdobbs> mm_freak: because if something in your type is from a type someone else defined but didn't export constructors for you're fucked and can't use it (basically)
16:54:34 <prooftechnique> jrmithdobbs: I think Typeable is being fixed in some fashion in 7.8 or 7.10
16:54:44 <prooftechnique> Though maybe that was a dream
16:54:49 <lilred> mm_freak: do you mean not possible given the current state of Haskell, or not theoretically possible?
16:55:02 <mm_freak> lilred: fundamentally impossible
16:55:06 <jrmithdobbs> prooftechnique: though, I'm fairly new to haskell too ;p
16:55:20 <jrmithdobbs> prooftechnique: i'm finding most of the things I wanted typeable/generics for work better with well thought out GADTs
16:55:23 <lilred> mm_freak: can you briefly explain why?
16:55:31 <jrmithdobbs> GADTs is like magic.
16:55:32 <mm_freak> lilred: but that really just means:  you solve problems differently…  in other words:  don't try to write lisp in haskell =)
16:55:56 <jrmithdobbs> mm_freak: or in my case, ruby
16:55:57 * jrmithdobbs ducks
16:56:05 <prooftechnique> jrmithdobbs: Yeah, I think most people handle that magic with GADTs in reality, so you're probably on the right track
16:56:05 <lilred> mm_freak: but I really like introspection for targeting heterogeneous environments, or doing static analysis :)
16:56:06 <lpaste> geekosaur pasted “apo: type constructors” at http://lpaste.net/95311
16:56:12 <mm_freak> lilred: well, "0 :: Integer" and "1 + 1 :: Integer" are indistinguishable
16:56:21 <mm_freak> lilred: distinguishing them would be a huge side effect
16:56:33 <geekosaur> fold was fine once I realized the original code had a bug >.>
16:56:35 <jrmithdobbs> prooftechnique: ya, GADTs + DataKinds + FlexibleInstances == win
16:56:46 <lilred> mm_freak: all I'm asking for is the possibility to browse the AST :)
16:56:55 <mm_freak> lilred: you're asking a lot there
16:56:58 <geekosaur> (the new code may still have a bug, but that's up to apo to decide, and if so to correctly fix...)
16:57:08 <mm_freak> lilred: you can of course browse the AST of your EDSL, but not of haskell itself
16:57:14 <lilred> :(
16:57:31 <prooftechnique> Can't haskell-src-meta do some of that?
16:57:37 <prooftechnique> @hackage haskell-src-meta
16:57:37 <lambdabot> http://hackage.haskell.org/package/haskell-src-meta
16:57:53 <jmcarthur> lilred: lisp treats code as data in the syntactic sense, as in an AST, and takes that close to an extreme. haskell treats code as data in the semantics sense, as in "functions are values", and takes that close to an extreme.
16:57:55 <mgsloan> prooftechnique: Yup!  It's not complete, but it handles almost everything
16:58:00 <jrmithdobbs> lilred: my impression thus far is basically that what you're asking for wouldn't be as useful as you'd think based on experience with other tools because the type system stuff catches most of the nonsense you'd use it for analysis-wise
16:58:21 <jrmithdobbs> if that sentence makes any sense
16:58:24 <jmcarthur> lilred: the extreme haskell takes is so far that even "effects" are values
16:58:39 <mgsloan> You *can* use HSE / HSM / TH to make quasiquoters that do compile time transformations on code
16:58:40 <mm_freak> lilred: ultimately you'll hit the "function wall" when trying to extract the AST of an expression…  functions are completely opaque, and there are only some limited RTS interfaces to ask some basic questions about them
16:58:44 <mm_freak> they all involve IO
16:58:54 <lilred> jrmithdobbs: one of the cool things I've seen done with reflection is Microsoft's Code Digger, which analyses C# code and generates unit test cases with maximum coverage
16:58:57 <mm_freak> lilred: as said, asking for the AST is a huge side effect
16:59:02 <jmcarthur> lilred: anyway, i don't think either subsumes the other here, but there is that philisophical difference about what "data" is
16:59:29 * mgsloan is very glad that Haskell doesn't give you the AST to just anything
16:59:29 <thoughtpolice> Typeable is getting 'fixed' in that it will have a polymorphic kind. rather than Typeable (t :: *), Typeable1 (t :: * -> *), etc, you get one typeable
16:59:31 <jrmithdobbs> lilred: i'm less than impressed by such systems, tbqh, they're "nifty" but not pratically useful
16:59:44 <bz> is every monad an applicative, or do i have it backwards?
16:59:44 <jrmithdobbs> lilred: who cares if you have 500% code coverage with tests that don't apply to the real world, for instance
16:59:48 <jrmithdobbs> (I hate TDD ;p)
16:59:58 <thoughtpolice> Typeable (t :: k), where 't' could be both 'Int' or 'Maybe' or something. so it's more consistent and we can derive instances for them now
16:59:58 <mgsloan> lilred: You can also use TH's AST quotes for a bit of a less hacky way to go about doing compiletime AST transformations
17:00:02 <lilred> jrmithdobbs: I'm (sadly) a big fan of TDD ;)
17:00:03 <bz> hm wait
17:00:11 <mm_freak> lilred: CL and haskell have very different ideas about what has to be first class…  for haskell it's functions and actions, for lisp it's code
17:00:20 <moops> every monad is applicative
17:00:21 <bz> functor C applicative C monad
17:00:25 <jmcarthur> bz: every monad is an applicative, but (right now) not every Monad is an Applicative
17:00:27 <jrmithdobbs> lilred: i like aspects of it, but don't find that I get the benefits from it until a project is at least in a workable defined-api (or equiv) state
17:00:39 <glguy> bz: The methods of Applicative can be implemented in terms of Monad operations and eventually Applicative will be a super-class of Monad
17:00:42 <bz> C = superset
17:00:43 <jrmithdobbs> lilred: once it's defined well enough to write tests the app is already mostly written at which point you want the tests to prevent regression
17:00:44 <mm_freak> lilred: you'll learn to become a fan of TDD instead =)
17:00:47 <mm_freak> Type-Driven Development
17:00:58 <bz> so in the context of monads, (*>) and (>>) are identical, no?
17:00:59 <jrmithdobbs> lilred: anything outside of that, like the people who say you should write tests before code, is a load of crap imho
17:01:01 <prooftechnique> bz: As far as typeclasses are concerned, no, for now, but morally yes
17:01:10 <prooftechnique> And that'll get fixed eventually
17:01:17 <joe9> what is the simplest method of reading a .json file? I do not want to create the types for all the fields. I just want 1 field. Any thoughts, please?
17:01:18 <jmcarthur> bz: yes
17:01:18 <lilred> jrmithdobbs: yeah, I agree that it's patently useless for prototyping
17:01:27 <lilred> jrmithdobbs: don't knock it until you've tried it! ;)
17:01:32 <bz> jmcarthur: thanks
17:01:49 <mm_freak> jrmithdobbs: i do that for arithmetic stuff
17:01:56 <jmcarthur> jrmithdobbs: i'm with you to some extent, but i do find it very useful to follow the TDD methodology specifically when trying to fix existing bugs
17:02:05 <lilred> jrmithdobbs: writing tests before the code tend to transform my understanding of the problem space, which usually leads me to getting it right the first time.
17:02:06 <jmcarthur> jrmithdobbs: write the test, make sure it fails, then make it pass
17:02:12 <mm_freak> because arithmetic invariants are mostly too difficult to encode in the types in haskell
17:02:43 <prooftechnique> mm_freak: Prototype in Agda :D
17:02:55 * jmcarthur often prototypes in agda :)
17:03:01 <mm_freak> prooftechnique: then remove the fancy types and make a poor haskell version? ;)
17:03:24 <mm_freak> i prototype /ideas/ in agda, not implementations
17:03:49 <lilred> it sounds like everyone here is employed doing Haskell except for me o.O
17:04:04 <jmcarthur> not me
17:04:07 <jmcarthur> i do ocaml
17:04:09 <shergill> me neither
17:04:17 <shergill> (scala here)
17:04:40 <lilred> I'm moving from an F# role to a C# role... :((((
17:04:44 <jmcarthur> aw
17:05:13 <mm_freak> lilred: write in F#, offer binaries and tell them you wrote it in C#
17:05:34 <lilred> mm_freak: I'll be working as part of a team (Microsoft)
17:05:36 <mm_freak> the only way to get C# right is to write F# and pretend you've written C# =)
17:05:51 <mm_freak> that's fine…  F# and C# are compatible =)
17:05:58 <bz> is it even possible to be employed doing haskell?
17:06:07 <bz> outside of academia, that is
17:06:10 <mm_freak> bz: sure
17:06:17 <apo> geekosaur: I have this: http://p.0au.de/bd26a785/
17:06:18 <mm_freak> see fpcomplete for example
17:06:28 <thoughtpolice> bz: i write haskell for work :)
17:06:42 <shergill> or galois
17:06:44 <bergmark> bz: me too!
17:06:57 <schell> has anyone ran into trouble with `cabal install convertible` ?
17:06:59 <mm_freak> me too, if self-employed counts =)
17:07:01 <lpsmith> Hmm, is there a way to go from System.Process.ProcessHandle to System.Posix.Process.ProcessId?    I'd like to set the niceness on a sub-process
17:07:03 <schell> with ghc HEAD?
17:07:04 <bz> shergill: seems galois is the only place
17:07:22 <lpsmith> Or do I just fork and exec?
17:07:35 <shergill> bz: there's also fbcomplete and now facebook (for haxl)
17:07:40 <bz> bergmark, thoughtpolice: i guess you two are galois?
17:07:45 <thoughtpolice> no
17:07:48 <bergmark> bz: Silk
17:07:49 <mm_freak> shergill: facebookcomplete?
17:07:50 <lpsmith> and avoid System.Process altogether?   That seems like a bit of an incompleteness in the interface
17:07:59 <carter> schell: many things break with major ghc version
17:08:00 <carter> s
17:08:00 <shergill> *fpcomplete
17:08:03 <thoughtpolice> i work for Well-Typed.
17:08:15 <carter> schell: you get to write patches and email them to all the maintainers
17:08:32 <carter> and i'm at Wellposed :)
17:08:48 <carter> (my own wee company)
17:09:08 * jmcarthur works at Well-Water
17:09:09 <schell> carter: cool - just not sure of the convention
17:09:15 * hackagebot fay 0.18.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.1 (AdamBergmark)
17:09:18 <carter> schell: what convention
17:09:27 <carter> language / compiler changes = things break
17:09:43 <carter> early adopters of new ghc versions get to find all the problems and give maintainers patches
17:09:55 <jmcarthur> that's the early adoption fee ;)
17:10:03 <carter> yes
17:10:07 <schell> sometimes it's hard for me to be sure if the breakage is my fault and I'd rather not bother busy people who know what they're doing ;)
17:10:08 <bergmark> thoughtpolice: oh i never connected you with your real name :)
17:10:14 <carter> schell: pester the shit out of people
17:10:25 <carter> assume things are bugs
17:10:36 <carter> building a library shouldn't break
17:10:39 <thoughtpolice> bergmark: :)
17:10:46 <carter> unless theres a bug
17:10:51 <carter> jmcarthur: thats a new one :)
17:11:33 <carter> schell: its to report bugs that may not be bugs
17:11:36 <carter> than not to report bugs
17:11:56 <carter> arkeet: you were the one talking about win32 right?
17:12:04 <schell> :) reporting
17:14:16 * hackagebot fay-jquery 0.5 - jQuery bindings for Fay.  http://hackage.haskell.org/package/fay-jquery-0.5 (AdamBergmark)
17:16:53 <lilred> (ML : let (head :: tail) as list = ...) :: (Haskell : ????)
17:17:21 <monochrom> let list@(head : head) = ...
17:17:28 <lilred> thank you! :D
17:17:39 <schell> is there a better regex backend than regex-tdfa?
17:17:49 <monochrom> "@" is chosen because it is close to "as" :)
17:17:52 <frx> double-headed monster?
17:18:04 <monochrom> oh oops typo hehe
17:19:17 * hackagebot snaplet-fay 0.3.3.1 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.1 (AdamBergmark)
17:20:52 <joe9> this is my .json data file: http://codepad.org/8FrNCdSJ . I want just the "rawEmail" field. wondering if there is a simple way to extract that field, please?
17:20:58 <ski> lilred : s/ML/OCaml/
17:21:19 <lilred> ski: I'm an F# habitual, so saying Ocaml is a bad idea :)
17:21:21 <ski> (SML goes the other way around)
17:21:25 <lilred> and no one knows F#
17:21:34 <ski> yea, F# would likely do the same as OCaml
17:21:42 <lilred> actually F# has it both ways
17:21:51 <ski> oh, that's nice
17:21:55 <lilred> :)
17:22:08 <ski> especially with view-like stuff
17:22:32 <ski> (maybe active patterns as well ?)
17:23:16 <lilred> exactly
17:23:35 <lilred> I have limited experience with Ocaml, but so far I've found that F# wins in every way except for the job market
17:23:37 <thoughtpolice> joe9: if you look at the aeson documentation, it has an example that should work for you. see 'Decoding a mixed-type object', which has an example
17:23:54 <joe9> thoughtpolice: thanks.
17:24:03 <thoughtpolice> in paraticular you decode the string into an Object, and then you use parseMaybe to pick out the relevant field
17:24:19 <thoughtpolice> the formatting in the example looks kinda messed up, though
17:24:47 <joe9> thoughtpolice: I used aeson-pretty to pretty print the json
17:25:47 <thoughtpolice> joe9: oh, so you already have the Object and want to pick out the field? well an Object is just a HashMap
17:25:53 <thoughtpolice> so you can just use lookup on it
17:26:02 <thoughtpolice> or am i misunderstanding
17:26:44 <joe9> thoughtpolice: I do not have anything. I want to parse that file. I was looking at some old aeson documentation earlier. From your suggestion, I got the newer aeson docs and they seem better.
17:26:59 <joe9> I will read through it and try it myself before bothering you good folks.
17:27:17 <thoughtpolice> oh ok, yes hopefully that will help then. if you just want a one-off field that looks like the way to go
17:27:56 <joe9> I just one-off field. I am wondering why I cannot just string match that particular field and it's value out.
17:28:07 <joe9> just a thought.
17:28:38 <rck> schell: if you want posix regex-tdfa seems to be the way to go
17:29:19 <schell> rck: thanks, just making sure i made a sane choice
17:31:12 <rck> anyone have issues with cabal install cabal-install 1.16 -> 1.18 on windows?
17:31:35 <carter> rck: is the install directory in your path?
17:32:36 <rck> carter: whatever ~/.cabal/bin is on windows should be yeah. it's on my work computer so I can't answer right now sorry
17:33:31 <rck> for what it's worth I have things like hlint & ghc-mod that work fine
17:34:07 <rck> fails with 'setup.exe: not found' or some such
17:34:08 <schell> when writing an issue for a library is it more common to call ghc HEAD 7.7.2013... or 7.8?
17:35:14 <bergmark> bah i'm updating all my packages in the wrong order :<
17:46:01 <sdrodge> I'm having a devil of a time trying to figure out how to specify a maximum number of digits after a decimal point when showing a float without also _forcing_ that number of digits to appear (even when all zero).
17:46:37 <geekosaur> easiest way to do that is probably to use Text.Printf (or one of the saner alternatives found on hackage) with the %g format
17:47:45 <geekosaur> you could also produce the string with all the trailing zeroes, then strip those (although it's not an ideal case for pattern matching unless you reverse it, trim leading zeroes, and reverse again or something)
17:48:30 <intrados> Is there a good way to trace down a index out of bounds error? I think it's something internal to vector because I'm not directly indexing any vectors
17:49:21 * hackagebot cab 0.2.6 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.6 (KazuYamamoto)
17:50:13 <sdrodge> geekosaur: I tried %.4g, but it suffers from the same problem as %.4f (printing 4 digits after the decimal point always).
17:51:25 <cschneid> Where are the core libraries hosted? I'd like to start working on documentation
17:51:35 <geekosaur> hrm. bug...
17:51:54 <geekosaur> you'll have to do it the other way. I think someone may actually have reported that recently too
17:55:02 <glguy> joe9: If you were using lens-aeson the answer would be: preview (_Value . key "ygData" . key "rawEmail" . _String) :: ByteString -> Maybe Text
17:59:36 <triliyn> Is there a good reference on DataKinds? All I can find is this section from the GHC manual version 7.4.1, and it doesn't go into much depth
17:59:54 <triliyn> (Also, I'm not sure if that's the most recent version of the manual?)
18:01:29 <monochrom> the current version is 7.6.3, and even that will change soon. but you don't miss much.
18:02:07 <triliyn> Datakinds hasn't changed much since 7.4.1, you mean?
18:02:12 <enthropy> triliyn: it isn't a complicated extension by itself I think
18:02:41 <triliyn> It seems to be, yes
18:02:50 <edwardk> triliyn: there is byorgey;s paper
18:03:04 <triliyn> Also it has a bunch of unfortunate (but understandable, I guess) restrictions :(
18:03:18 <edwardk> http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
18:03:32 <byorgey> many of those restrictions are going away soon
18:03:55 <byorgey> (for sufficiently large values of "soon")
18:04:07 <triliyn> hehe, that's good to hear
18:04:58 <triliyn> I'd love to ask more questions but I only half-understand what most of them mean
18:05:36 <triliyn> The only one I really get is that you don't get promoted types whose kinds mention other promoted types
18:05:41 <triliyn> (At least, I THINK I get that one)
18:06:19 <byorgey> right, because that would require double promotion
18:07:01 <triliyn> I don't suppose that's one of the restrictions that is going away?
18:07:06 <byorgey> it is =)
18:07:10 <triliyn> oh, yay
18:07:29 <byorgey> but the idea is to collapse types and kinds into a single system, so there's not really much difference between promoting once or any number of times
18:07:44 <triliyn> hmm, okay
18:07:58 <triliyn> Like dependent kinding!
18:08:23 <byorgey> that's *precisely* what it is!
18:08:28 <byorgey> see http://www.seas.upenn.edu/~sweirich/papers/nokinds-extended.pdf
18:08:34 <triliyn> I guess that makes more sense than implementing double, triple, quadruple, ... promotion separately
18:08:40 <triliyn> hehe, thanks
18:09:11 <byorgey> The other restriction is that you can't promote GADTs, because you can't have equalities between kinds (GADTs have equalities between types)
18:09:18 <byorgey> that is going away too:  from the GHC manual version 7.4.1, and it doesn't go into much depth
18:09:21 <byorgey> (20:49) <   triliyn> (Also, I'm not sure if that's the most recent version of the manual?)
18:09:25 <byorgey> blargh, sorry
18:09:38 <byorgey> http://cis.upenn.edu/~justhsu/docs/nokinds.pdf
18:11:01 <triliyn> I seem to be having a lot of papers on my plate lately :)
18:11:22 <byorgey> welcome to the club =)
18:14:24 * hackagebot fay-text 0.3 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3 (AdamBergmark)
18:41:50 <bergmark> mgsloan: maybe you know, a couple of packages need to be updated for stackage, but there aren't any tickets for it. can i add tickets  for it or is that automated?
18:43:27 <mgsloan> bergmark: Yeah, I think the procedure is to either open a ticket or a pull request
18:44:39 <bergmark> mgsloan: ok, thanks!
18:44:48 <mgsloan> bergmark: welcome!
18:44:57 <himh> Is there an fmap for ByteStrings?
18:46:01 <himh> Actually... wait. Is that sensible?
18:46:11 <roconnor> himh: yes it is sensible
18:46:56 <roconnor> map :: (Word8 -> Word8) -> ByteString -> ByteString
18:49:35 <bergmark> luite: your packages are only transitively on stackage right? anyway https://github.com/fpco/stackage/issues/137
18:51:34 <asmyers> What's the best way to share dependencies between multiple sections in a cabal file?
18:51:43 <asmyers> I have a library and an executable for testing
18:52:02 <asmyers> Can I share the build-depends between them somehow?
18:54:04 <enthropy> asmyers: not really. You can put 99% of stuff into the library then have the executable just list the library in build-depends
18:55:46 <asmyers> enthropy: Ah, I see thanks
18:57:15 <himh> I'm trying to take an small program that reads a large text file and converting to lazy bytestring seems to break everything
18:58:27 <bergmark> asmyers: you need to expose a lot of modules, or have them in both sections (meaning they will be compiled twice)
18:58:54 <Tekmo> himh: What do you mean?
19:00:07 <himh> Tekmo: Well, I did a qualified import and changed all string functions to their bytestring equivalents, but it won't run
19:00:19 <Tekmo> What type error do you get?
19:00:22 <bergmark> asmyers: if you end up having to expose internal modules you may want to name them .Internal or document that they aren't really part of the api so you don't need to do as many major bumps when updating them
19:00:54 <himh> Tekmo: Compiler says: I expected type 'B.ByteString' but got '[B.ByteString]'
19:00:57 <asmyers> bergmark: That's good to think about.  Right now it doesn't really matter since I'm just hacking together stuff
19:01:04 <asmyers> bergmark: If I release it I
19:01:09 <asmyers> 'll worry about that
19:01:19 <Tekmo> himh: Whenever reading type errors, the first thing you should look at is the line number
19:01:29 <Tekmo> himh: It's usually really accurate and will point to which line triggered the problem
19:01:39 <Tekmo> himh: Does it also mention the name of the function that is giving the type error?
19:02:01 <Tekmo> himh: Also, if you need more room to paste something large, you can use lpaste.net
19:03:13 <jle`> himh: post it on lpaste.  but the error message is usually pretty helpful.  it usually not only tells you the line but also the exact variable that is giving you trouble
19:03:13 <himh> Tekmo: Thanks, yea. What I find interesting is that the plain String implementation works fine, but using the ByteStrings somehow causes a list of bytestrings to be produced instead
19:03:29 <jle`> himh: it might be from the fact that String is [Char]
19:03:36 <jle`> so you might be dealing with lists implicitly
19:03:39 <Tekmo> himh: That's why you need to know the name of the function
19:03:46 <jle`> *might have been
19:04:04 <frx> > let foo = do { n <- get; put (n+10); put (n+10); return n } in execState foo 0
19:04:05 <Tekmo> himh: Can you paste the entire type error?
19:04:05 <lambdabot>   10
19:04:10 <frx> why is result 10 instead of 20?
19:04:25 <Tekmo> frx: Because `n` is still 10 even after you `put` it
19:04:42 <Tekmo> frx: If you want to retrieve the stored value you need to use `get` again and bind it to a new variable (i.e. `n2`)
19:04:58 <jhormuz> I am looking at some sample haskell code with strange types....  It uses "*" (::*->*).  What GHC extension do I need to make this compile?
19:05:22 <jle`> frx: it might help to look at the desugaring
19:05:23 <frx> Tekmo why isn't it 0 then? I can only put once? I think I need to read more about it
19:05:25 <Tekmo> jhormuz: That's a kind signature
19:05:32 <geekosaur> those are kinds, and you probably need KindSignatures
19:05:35 <Tekmo> jhormuz: Try the `KindSignatures` extension
19:05:42 <jle`> frx: n is 0, you are putting in n+10 so 0+10
19:05:49 <himh> Tekmo: Ahh I found it, there was a putStrLn that I thought didn't touch ByteStrings... turns out it did. Thank you for your help though :)
19:05:54 <Tekmo> frx: It is 0, but `execState` restored what you `put`, not what you `return`
19:06:00 <abg> frx: When you "put (n+10)", you're changing the value stored in the monad, not 'n'. 'n' remains the same between the two calls.
19:06:00 <Tekmo> himh: You're welcome!
19:06:14 <Tekmo> frx: If you want to see it return `0`, then use `evalState`, instead
19:06:27 <jhormuz> I added {-# LANGUAGE KindSignatures #-} and GHC still complains....
19:06:42 <Tekmo> jhormuz: Can you paste the full code and the type error using lpaste.net?
19:06:56 <jhormuz> tekmo- one sec (thanks)
19:07:23 <jle`> frx: try runState
19:07:25 <jle`> :t runState
19:07:26 <lambdabot> State s a -> s -> (a, s)
19:07:36 <abg> :t modify
19:07:37 <lambdabot> MonadState s m => (s -> s) -> m ()
19:07:45 <jhormuz> http://lpaste.net/95313
19:07:55 <Tekmo> frx: To elaborate on what `jle` is saying, every state computation has two outputs: the final state and the return value
19:07:56 <frx> thanks, I got it now
19:08:32 <jle`> * try looking at runState
19:08:37 <jle`> but yeah you get the picture
19:09:43 <himh> Wow using ByteStrings makes a huge difference
19:10:32 <jhormuz> Tekmo- have you ever seen code like this before?
19:10:52 <Tekmo> Yes
19:10:52 <Tekmo> Give me a second
19:10:53 <Tekmo> I'm fixing it
19:11:09 <jhormuz> Tekmo- thanks!
19:12:40 <Tekmo> Here: http://lpaste.net/95315
19:13:59 <jhormuz> Tekmo- Thanks, I will go look and report back....
19:16:12 <jhormuz> Tekmo- Just looked....  Actually the purpose of me playing with this code was to understand how the "*" works....  It is from http://dreixel.net/research/pdf/ghp.pdf, section 2.1.  Sorry, I was more interested in the "*" than getting it to work.
19:16:36 <Tekmo> Let's use a simpler example, then
19:16:45 <Tekmo> Are you familiar with Haskell's `Maybe` type?
19:16:49 <jhormuz> yup
19:17:21 <Tekmo> `*` is what we call a "kind" (i.e. a type of types)
19:17:31 <Tekmo> For example, a type like `Int` has kind `*`
19:17:40 <Tekmo> We denote that like this: Int :: *
19:17:57 <Tekmo> `Maybe` on the other hand, has a more complex kind:  Maybe :: * -> *
19:18:09 <jhormuz> Types I am very familiar with, but perhaps not kinds....
19:18:17 <desheng> can you define your own Kinds?
19:18:17 <Tekmo> In other words `Maybe` takes a single type of kind `*` and returns a new type of kind `*`
19:18:29 <Tekmo> For example: Maybe Int
19:18:51 <Tekmo> Think of `Maybe` as a function that takes a type as an argument and returns a new type
19:18:59 <DiegoNolan> doesn't rm -r ~/.ghc remove all my packages?
19:19:07 <Tekmo> In the case of `Maybe Int`, the `Int` is the argument and `Maybe Int` is the result
19:19:12 <jle`> DiegoNolan: you are thinking of ~/.cabal
19:19:14 <DiegoNolan> should that give me a clean environment
19:19:16 <jhormuz> I get it, because it takes the "a" parameter (basically a function over types?)
19:19:20 <DiegoNolan> well i did both
19:19:23 <Tekmo> jhormuz: Exactly
19:19:26 <DiegoNolan> still having problems
19:19:34 * hackagebot snaplet-fay 0.3.3.2 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.2 (AdamBergmark)
19:19:35 <Tekmo> So that's why `Vec` had that kind:  Vec :: * -> * -> *
19:19:43 <Tekmo> `Vec` takes two types as arguments
19:19:44 <jle`> DiegoNolan: what kind of problems?
19:20:06 <glguy> jhormuz: With the "KindSignatures" language extension you can write: data Vector :: * -> * -> * where
19:20:12 <DiegoNolan> jle`: do both those things then try to reinstall postgresql-simple
19:20:17 <jhormuz> Why wouldn't I just use the old fashioned Vec a b?
19:20:27 <Tekmo> jhormuz: You can.  Both will work
19:20:33 <DiegoNolan> jle`: run query says not in scope 'exceute' maybe you meant 'execute' or execute_'
19:20:43 <jhormuz> There must be some advantage though?
19:20:51 <DiegoNolan> and the only pkg install after is postgresql-simple
19:21:02 <DiegoNolan> so don't know i could have conflicts
19:21:26 <Tekmo> jhormuz: So this is not totally my expertise, but my understanding is that once you move onto more advanced type systems like dependent type systems then the version with the kind signature is more flexible
19:21:32 <jhormuz> Oh, I see you did exactly that when you changed the code.
19:21:34 <tk_995> I noticed on haskell.org that the planned release date for the haskell platform 2013.4.0.0 was Nov 4... of course that date has passed, but I wondered if anyone has any insight into when this will be released?
19:21:44 <glguy> jhormuz: "Vector a b" is a bit misleading, it gives the impression that "a" and "b" mean something in the constructors below
19:21:45 <Tekmo> jhormuz: For example, you could write `Vec :: * -> Int -> *`
19:22:18 <tk_995> I am very interested to try out ghcjs and need ghc 7.8 to make that easy
19:22:33 <jhormuz> isn't that the same thing as Vec a Int?
19:22:35 <dbuckalew> DiegoNolan: maybe because your command is 'exCEute' and should be 'exECute' (caps added for illustration)?
19:22:35 <Tekmo> jhormuz: And then you actually use `Int`s as "type parameter"s, instead of a pale shadow of them
19:22:54 <Tekmo> jhormuz: I'm not sure.  This is where I'm out of my league.  Maybe `glguy` can elaborate more
19:23:05 <DiegoNolan> dbuckalew: no, that was just bad typing
19:23:15 <DiegoNolan> dbuckalew: it was running before it blew up
19:23:20 <Tekmo> jhormuz: At this point we're not in the range of legal Haskell
19:23:27 <glguy> jhormuz: Vec :: * -> Int -> *    means that     Vec () 3 :: *
19:23:33 <dbuckalew> DiegoNolan: drat... I hate it when things blow up
19:23:33 <khyperia> Is there a function "reverse lookup", as in "insert"? Essentially, insert :: (Eq a) => (a, b) -> [(a, b)] -> [(a, b)]
19:23:50 <jhormuz> Tekmo- Yeah, I pretty much never am anymore (I always seem to need some GHC extension) :)
19:24:07 <Tekmo> jhormuz: :)
19:24:23 <Tekmo> jhormuz: Just out of curiosity, what got you interested in advanced type tricks?
19:24:47 <khyperia> or do I want to use Map? (never heard of that before)
19:25:07 <Tekmo> khyperia: Yes, use `Data.Map` from the `containers` package
19:25:14 <jhormuz> tekmo- From this stackoverflow question that I posted today- http://stackoverflow.com/questions/19820294/haskell-records-setting-getting-using-string-fieldname
19:25:30 <Tekmo> khyperia: However, there's a really simple answer to your question
19:25:33 <Tekmo> khyperia: insert = (:)
19:25:43 <Tekmo> khyperia: That just prepends the key-value pair to the list
19:25:44 <khyperia> Well, insert without replication of keys
19:26:01 <lpaste> glguy pasted “jhormuz: an example” at http://lpaste.net/95316
19:26:02 <Tekmo> khyperia: Oh, then you'd need something like `nubBy` to get rid of duplicates, but that's inefficient
19:26:12 <Tekmo> khyperia: By that point you should be using `Data.Map`
19:26:17 <khyperia> yeah
19:26:27 <jle`> Tekmo: yeah, thought that too, but notice the Eq constraint on a
19:26:38 <Tekmo> It has the function you're looking for: insert :: Ord k => k -> a -> Map k a -> Map k a
19:27:02 <Tekmo> If you want just an `Eq` constraint, then you can use a `HashMap` from the `unordered-containers` package
19:28:00 <jhormuz> Tekmo- I started researching some of the stuff referred to in the comment/answer and it led to this stuff.
19:28:10 <Tekmo> Oh yeah, I saw that question
19:28:34 <Tekmo> So why do you not use `Map String Val`?
19:28:39 <jhormuz> Tekmo- I think I have a reasonable understanding of the Haskell basics, but this stuff goes way above my head (so far at least)
19:28:59 <jhormuz> Tekmo- I want to move stuff out of Val, to have type safety
19:29:03 <Tekmo> jhormuz: The nice thing about using a `Map` is that you can then use lenses to easily get and set elements from the map
19:29:10 <S11001001> Tekmo: just Eq?
19:29:15 <Tekmo> No
19:29:21 <Tekmo> S11001001: Also a `Hashable` constraint
19:29:36 <monochrom> you must accept either Ord or Hashable
19:29:50 <jhormuz> Tekmo- I have used map a bunch of times, but for mixed types it isn't as good.
19:29:55 <Tekmo> monochrom: Or poor performance :)
19:30:04 <Tekmo> jhormuz: Right
19:30:11 <Tekmo> jhormuz: So why are you unsatisfied with records?
19:30:12 <jhormuz> Tekmo- I also looked at hlist, but that has some problems.
19:30:25 <jhormuz> tekmo- like hlist, you mean?
19:30:41 <Tekmo> jhormuz: No, just ordinary records
19:30:46 <enthropy> jhormuz: what are the problems?
19:31:22 <jhormuz> enthopy- with hlist?  I think it needs to know everything about the value at compile time....
19:31:43 <DiegoNolan> Dear cabal Gods, please resolve this dependecy conflict and I promise I will never use -fforce-install ever again
19:31:47 <enthropy> yes it does
19:31:54 <jhormuz> tekmo- I want to use a record, but want to write a lib that converts to one.
19:31:54 <Tekmo> jhormuz: If you have a `String` interface to something, what you usually do is parse it first, before executing any Haskell code
19:32:18 <Tekmo> jhormuz: In other words, rather than make `String`s the API to your record, you instead convert your `String`s to typed values and then you do everything past that point in the type-safe world
19:32:26 <Tekmo> If parsing fails, you abort before you begin doing type-safe operations
19:32:35 <scshunt> DiegoNolan: The voice of the Cabal God boom: "Thou art arrogant, mortal."
19:32:40 <scshunt> *booms
19:32:52 <scshunt> "Thou must relearn thy lessons!" You feel foolish!
19:33:18 <jhormuz> Tekmo- Exactly....  But I want to have a library to automatically do this conversion.  It is harder than it seems with non-extended haskell.
19:33:23 <Tekmo> jhormuz: For example, consider setting the value of a record from a configuration file
19:33:36 <Tekmo> jhormuz: You would first parse the configuration file and then convert the parsed value to a record
19:33:42 <Tekmo> jhormuz: Are you familiar with Haskell parsing libraries?
19:34:05 <DiegoNolan> scshunt: if there is one thing that drives me nuts it is this.  I mean i am making a whole new droplet for this crap
19:34:19 <jhormuz> tekmo- I've used parsec a few times....  I ended up writing my own parser later on.
19:34:44 <Tekmo> jhormuz: Parsing is a staple of idiomatic Haskell programming
19:34:48 <Tekmo> jhormuz: I personally recommend `attoparsec`
19:34:56 <Tekmo> jhormuz: No `try` nonsense and it is much faster
19:35:03 <Tekmo> jhormuz: But it gives terrible error messages
19:35:09 <jhormuz> Tekmo- I haven't had any need for binary parsing yet....
19:35:12 <jhormuz> wait, no try?
19:35:25 <Tekmo> jhormuz: `attoparsec` automatically backtracks for everything
19:35:25 <jhormuz> now I am interested.
19:35:38 <Tekmo> jhormuz: `attoparsec` also works for text, not just binary
19:35:42 <jhormuz> oh, everything, I am losing interest.
19:35:43 <glguy> try was a feature
19:35:49 <Tekmo> jhormuz: That's what `Data.Attoparsec.Text` is for
19:36:00 <jhormuz> tekmo- automatic backtracking is exponential in time.
19:36:04 <jhormuz> kind of ruins it.
19:36:12 <Tekmo> jhormuz: In practice it is very fast
19:36:38 <scshunt> DiegoNolan: oh I agree
19:36:43 <scshunt> DiegoNolan: cabal is shit
19:36:50 <Tekmo> jhormuz: It doesn't backtrack on a character-by-character basis, if that's what you mean
19:36:50 <jhormuz> problem with exponential parsing is that it works very fast until it doesn't....  Can suddenly take a half an hour to do something.
19:37:05 <Tekmo> jhormuz: It provides a `string` primitive which parses a string atomically
19:37:26 <Tekmo> jhormuz: and it also provides several other primitives for parsing lists of elements which tack care of avoiding pathological backtracking scenarios
19:38:13 <Tekmo> jhormuz: Anyway, the point is that it doesn't really matter with parsing library you choose
19:38:22 <Tekmo> jhormuz: What really matters is that you make yourself really comfortable with at least one of them
19:38:39 <jhormuz> tekmo- I'll look at it.  I have run into scenarios in the past with auto backtracking that blew up (rarely, which is worse than often in my opinion)
19:38:45 <Tekmo> jhormuz: Parsing is how you interface with the untyped world.  If you do it fluently then you can very easily move everything into the world of types and then you are a happy Haskell programmer
19:39:17 <simpson> That's an interesting viewpoint.
19:39:28 <Tekmo> jhormuz: What you don't want to do is spread out the parsing throughout your whole API
19:39:50 <Tekmo> jhormuz: In other words, you don't want your `getField` and `setField` functions from your Stack Overflow question to be the points where you do parsing
19:40:01 <Tekmo> jhormuz: You want to catch the parsing error long before it gets to that point
19:40:11 <Tekmo> jhormuz: Haskell is all about failing early and fast
19:40:15 <jhormuz> tekmo- I actually used a few libs (parsec, yacc/lex, etc) but ended up writing my own.  It is in haskell, and does a bunch of symbolic manipulation of the grammer before doing anything to make the grammer lr(1) ahead of time.
19:40:35 <Tekmo> jhormuz: It's okay if you use your own parsing library
19:41:05 <Tekmo> jhormuz: The main point is to not intersperse parsing throughout your whole code base
19:41:20 <Tekmo> jhormuz: Try to concentrate it into a single entry point, so that the rest of your code can be strongly typed
19:41:22 <jhormuz> tekmo- my main goal is to just write code where I create a record, then pass it to a function to parse the command line options (or sql result, etc)
19:41:31 <jhormuz> getopt is still pretty involved.
19:41:48 <Tekmo> jhormuz: Use `optparse-applicative`
19:41:52 <Tekmo> I can give you some sample code.  Hold on
19:42:01 <enthropy> there is a http://code.haskell.org/HList/examples/cmdargs.hs
19:42:39 <Tekmo> jhormuz: Here: http://stackoverflow.com/questions/17395388/command-line-arguments-reading-monad-library/17407774#17407774
19:42:55 <Tekmo> jhormuz: It's very much like parser combinators
19:43:05 <Tekmo> jhormuz: You can build an applicative parser that directly converts command line options to a record
19:43:55 <Tekmo> Right now I have to go, but if you need further help my gmail address is Gabriel439
19:44:03 <jhormuz> I've been given much to read....  One sec guys, I'll go read and be back.
19:44:11 <jhormuz> tekmo- Thanks!
19:44:15 <Tekmo> You're welcome! :)
19:44:25 <jhormuz> I will write you one way or the other to let you know how it goes.
19:44:32 <Tekmo> Alright.  :)
19:45:22 <jhormuz> talk with you later
19:46:24 <abg> Hey, is there a reason to use EitherT (from ekmett's either package) over ErrorT (from transformers)?
19:50:10 <elliott> abg: no Error constraint
19:50:35 <chrisdotcode> does String have a monoid instance?
19:50:50 <abg> elliott: Is that it? Because ErrorT has the advantage of being included with the haskell-platform while either requires extra dependencies.
19:50:51 <chrisdotcode> becauseI couldn't find one using ghci
19:50:56 <abg> chrisdotcode: Yes.
19:51:11 <chrisdotcode> abg: where can I find it? I imported Monoid, and I didn't get it defaultly.
19:51:29 <abg> chrisdotcode: String is [Char], and [a] has a monoid instance
19:51:39 <abg> So, [Char] has a monoid instance.
19:51:44 <chrisdotcode> abg: oh, sweet. okay, thanks :)
19:54:56 <intrados> Does it make sense that standalone `deriving instance Ord (Foo a b)` fails on ADT Foo with 'couldn't match A1 with A2' where A1 and A2 are types in the a slot?
19:55:10 <cfoch> How do I get the nth element of a tuple?
19:55:37 <simpson> cfoch: Depends. The easy way is with the lens library. What are you building?
19:56:50 <cfoch> simpson: I just want to handle a tuple Num t => ([Char], [Char], t)
19:57:09 <simpson> cfoch: Why not just pattern-match it into pieces?
19:58:06 <cfoch> simpson: you are right... and what about lens library?
20:01:50 <simpson> > (1,2,3) ^. _2
20:01:51 <lambdabot>   2
20:06:24 <vonDraco> how could i go about checking a list for more than one element? something like this, elem (2 or 5) [1,3,4,5], which would evaluate to True
20:07:32 <joe9> code: http://codepad.org/sQBmr6w4 , data: http://codepad.org/ZX0tSnYg , error: http://codepad.org/bs9UrZZW . Any suggestions on what I am missing, please? It worked for another data file. I am not sure what the message  "Failed reading: satisfyWith" means or where the error is.
20:07:50 <centrinia> > [2,5] `intersect` [1,3,4,5]
20:07:51 <lambdabot>   [5]
20:08:21 <lispy> @src elem
20:08:21 <lambdabot> elem x    =  any (== x)
20:08:43 <centrinia> > not $ null $ [2,5] `intersect` [1,3,4,5]
20:08:44 <lambdabot>   True
20:08:54 <enthropy> > any (`elem` [2,5]) [1,3,4,5]
20:08:55 <lambdabot>   True
20:09:30 <lispy> let elems xs ys = any (\y -> elem y xs) ys in [2,5] `elems` [1,3,4,5]
20:09:33 <lispy> > let elems xs ys = any (\y -> elem y xs) ys in [2,5] `elems` [1,3,4,5]
20:09:34 <lambdabot>   True
20:09:59 <vonDraco> ah, thank you guys
20:10:12 <lispy> vonDraco: are you doing homework?
20:11:13 <vonDraco> pretty much.
20:12:44 <lispy> vonDraco: in that case, make sure to fully understand those implementations and how they are similar
20:13:03 <lispy> For example, could you take one and use equational reasoning to derive a different one?
20:13:29 <joe9>  any aeson users here. could you please help?
20:13:35 <johnw> by equational reasoning he means "evaluating step by step to transform one form into another"
20:13:46 <johnw> joe9: what do you need?
20:14:11 <joe9> johnw: I get the error "Failed reading: satisfyWith"
20:14:19 <johnw> paste code and full error?
20:14:24 <joe9>  johnw code: http://codepad.org/sQBmr6w4 , data: http://codepad.org/ZX0tSnYg , error: http://codepad.org/bs9UrZZW . Any suggestions on what I am missing, please? It worked for another data file. I am not sure what the message  "Failed reading: satisfyWith" means or where the error is.
20:14:25 <johnw> and input
20:14:39 <vonDraco> lispy, i'll make sure of understanding it.. after i finish this before the deadline. :P
20:14:41 <johnw> satsifyWith is from attoparsec
20:15:07 <joe9> johnw, the code fails with Nothing at decode. I get the "failed reading" error when I use eitherDecode.
20:15:29 <joe9> johnw: Is there no way to get more details on where or why?
20:15:30 <Fuuzetsu> joe9: it fails with Nothing because it fails to parse the file
20:15:45 <johnw> joe9: i wonder if it's the unicode you have embedded in there...
20:15:53 <joe9> Fuuzetsu: I understand that. I am trying to figure out why.
20:15:54 <johnw> but that should be ok
20:16:11 <joe9> it works with this data file: http://codepad.org/cuXIG5bo
20:16:11 <Fuuzetsu> joe9: No, not out of that message. Attoparsec has some pretty… terse error handling.
20:16:12 <johnw> yeah, attoparsec really blows at error messages
20:16:42 * Fuuzetsu says this while compiling Attoparsec instead of just suing Parsec like a normal person
20:16:43 <johnw> joe9: you are using C.pack in parseFile
20:16:44 <Fuuzetsu> m-muh speed
20:16:48 <johnw> i'm almost 100% sure this is your problem
20:16:56 <johnw> use Data.Text.Encoding.encodeUtf8 instead
20:17:17 <joe9> johnw: ok, thanks. let me try that.
20:17:17 <johnw> you'll probably have to taken on a . Data.Text.pack too
20:17:19 <Fuuzetsu> oh oh, unicode problems with Attoparsec
20:17:29 <johnw> beacuse you've got Unicode in your data, but you're interpreting it as ASCII
20:17:30 <Fuuzetsu> it's all flashing in front of my eyes
20:17:31 <joelteon> probably unicode problems with bytestring
20:17:41 <johnw> and Aeson expects uTF8
20:18:09 <johnw> can you tell how many Unicode issues I've fixed in our production environment in just the last 3 months alone? :)
20:18:29 <Fuuzetsu> enough to retire?
20:18:32 <johnw> unicode in path names, unicode in Git trees, unicode in files, unicode in environment variables, etc., etc.
20:18:39 <Fuuzetsu> unicode in unicode
20:18:46 <johnw> EXACTLY
20:18:47 <johnw> omg
20:18:56 <johnw> there should be a Unicode codepoint for "OMG, It's Unicode Again"
20:19:13 <johnw> PROGRAMMER_FIXING_UNICODE_BUGS
20:19:21 <Fuuzetsu> at that point jump ship, terminate program
20:19:24 <joelteon> heh
20:19:38 <johnw> and then there's Linux and which encoding is default for process communication
20:19:39 <joelteon> i'm trying to convert double encoded UTF8 to single encoded UTF8 in our prod app at the moment
20:19:41 <joelteon> >_>
20:19:42 * hackagebot reified-records 0.1.0.0 - Reify records to Maps and back again  http://hackage.haskell.org/package/reified-records-0.1.0.0 (jozefg)
20:22:48 <Adeon> what is double encoded UTF-8
20:22:59 <johnw> UTF8 encoded as UTF8
20:22:59 <Adeon> is it like you encode in utf-8 and then something assumes it's not utf-8 and encodes it in utf-8 again
20:23:31 <arkeet> <carter> arkeet: you were the one talking about win32 right?
20:23:33 <arkeet> carter: yes, why?
20:23:39 <joelteon> yeah, Adeon
20:23:40 <carter> arkeet: did you file the ticket yet? :_
20:23:41 <carter> :)
20:23:44 <joelteon> i have an example in an email somewhere
20:23:46 <arkeet> uh
20:23:49 <Adeon> ouchies
20:23:52 <arkeet> no I just got home.
20:24:07 <arkeet> oh, since Win32 is a ghc thing, it should go on ghc trac?
20:24:09 <joelteon> but you just get strings like "fÅ©Å©bar" encoded as UTF8 in your database
20:24:35 <carter> arkeet: oh , no pressure
20:24:44 <carter> arkeet: you should probably file tickets on the github
20:24:50 <carter> since the lib is maintained there
20:24:51 <arkeet> ok
20:25:10 <arkeet> ah so it is
20:26:04 <carter> BUT: it may be worth emailing the libraries list saying "hey, win32 lib needs some love, heres some obviosu problems i can explain / put on the issue tracker and a sketch of how to clean things up"
20:26:14 <carter> who's the maintainer for it?
20:26:15 <joe9> johnw: error: http://codepad.org/AbwVFo3R  , code: http://codepad.org/WtXqkw1F
20:26:22 <joe9> johnw: can you please help?
20:26:28 <joe9> I seem to be missing something.
20:27:19 <johnw> yo'ure mixing bytestrings
20:27:21 <johnw> lazy vs. strict
20:27:35 <johnw> you may need Data.Text.Lazy.Encoding
20:27:53 <carter> dont cross the streams! :P
20:28:19 <maikklein> has someone written https://github.com/guard/guard in haskell?
20:28:43 <carter> arkeet: seems like bos is the maintainr, but hasn't gotten many commits in the past year or several -fforce-recomp
20:28:45 <carter> ooop
20:28:47 <carter>  http://hackage.haskell.org/package/Win32
20:29:22 <joe9> johnw: is it a good idea to read a string and then use encodeUtf8? Can I just read the file with utf8?
20:29:32 <johnw> you can read the file directly with Data.Text
20:29:39 <johnw> i think that's in Data.Text.IO?
20:29:44 <arkeet> yes
20:29:48 <johnw> you can read it directly with ByteString too
20:29:56 <johnw> that might be the best thing to do here
20:29:57 <arkeet> oh. encode
20:30:00 <johnw> leave Aeson to interpret it
20:30:13 <johnw> use Data.ByteString.readFile
20:30:23 <joe9> johnw: ok, thanks. let me try that.
20:31:53 <enthropy> maikklein: there is a http://hackage.haskell.org/package/hinotify
20:32:09 <enthropy> but I guess guard is more portable
20:32:36 <joe9> johnw: thanks. that helped.
20:32:40 <joe9> arkeet: thanks.
20:32:59 <arkeet> hm? I didn't help
20:33:14 <arkeet> well, maybe I helped just by being here.
20:40:13 <ski> copumpkin : you mentioned `Mu Set' ?
20:40:52 <copumpkin> yup
20:40:54 <copumpkin> what about it?
20:41:10 <ski> > fromHFS (toHFS "{{{},{}},{{},{{}}}}" `differenceHFS` toHFS "{{{}}}")
20:41:14 <lambdabot>   "{{{},{{}}}}"
20:41:19 <ski> > map fromHFS [toHFS "{}" ..]
20:41:23 <lambdabot>   ["{}","{{}}","{{{}}}","{{},{{}}}","{{{{}}}}","{{},{{{}}}}","{{{}},{{{}}}}",...
20:41:39 <ski> basically using
20:41:46 <ski>   newtype HereditarilyFiniteSet = HFS {unHFS :: Mu Set} deriving (Eq,Ord)
20:41:54 <ski> (also a `Read' and `Show' instance)
20:43:18 <ski> > succ (fromNat 9)
20:43:22 <lambdabot>   wrapHFS [wrapHFS [wrapHFS []],wrapHFS [wrapHFS [],wrapHFS [wrapHFS []]]]
20:43:50 <copumpkin> HFS?
20:43:59 <copumpkin> hmm!
20:44:27 <copumpkin> got some code up?
20:44:29 <ski> it's not very complicated, but i thought it might be fun to ponder
20:44:40 <ski> only in lambdabot
20:44:42 <copumpkin> what's the relationship to naturals?
20:45:00 <ski> "A Functional Hitchhiker's Guide to Hereditarily Finite Sets, Ackermann Encodings and Pairing Functions" by Paul Tarau in 2008-08-06 at <http://arxiv.org/abs/0808.0754> mentions the relationship with naturals
20:45:14 <ski> > map (fromHFS . fromNat) [0 ..]
20:45:18 <lambdabot>   ["{}","{{}}","{{{}}}","{{},{{}}}","{{{{}}}}","{{},{{{}}}}","{{{}},{{{}}}}",...
20:46:42 <copumpkin> neat paper, thanks
20:46:59 <ski> there's also `toHFS',`toNat',`unwrapHFS',`memberHFS',`unionHFS',`intersectionHFS',`differenceHFS' to play with
20:47:17 <ski> i also found "Arithmetic Algorithms for Hereditarily Binary Natural Numbers" in 2013-06-05 at <http://arxiv.org/abs/1306.1128> and "A Prolog Specification of Giant Number Arithmetic" in 2013-06-17 at <http://arxiv.org/abs/1307.4642>, both by Paul Tarau, but i have only skimmed those
20:48:42 <ski> > read "HFS (In (fromList []))" :: HereditarilyFiniteSet
20:48:45 <lambdabot>   wrapHFS []
20:48:54 <ski> > read "wrapHFS []" :: HereditarilyFiniteSet
20:48:58 <lambdabot>   wrapHFS []
20:49:03 <ski> > read "fromNat 0" :: HereditarilyFiniteSet
20:49:06 <lambdabot>   wrapHFS []
20:49:12 <ski> > read "read \"fromNat 0\"" :: HereditarilyFiniteSet
20:49:16 <copumpkin> :O
20:49:16 <lambdabot>   wrapHFS []
20:49:22 <ski> > read "read \"read \\\"fromNat 0\\\"\"" :: HereditarilyFiniteSet
20:49:26 <lambdabot>   wrapHFS []
20:49:34 <copumpkin> wat
20:49:35 <ski> was just a fun twist i added ;)
20:49:39 <copumpkin> weirdo :P
20:49:53 <copumpkin> dude, transcribe the code out of your PM with lambdabot
20:49:58 <copumpkin> it could make a fun blog post or something
20:50:20 <copumpkin> if anything, you don't want it to be lost when lambdabot restarts
20:50:48 <ski> (btdt)
20:51:56 <dibblego> is there this function in QuickCheck, generateUntilJust :: Gen a -> (a -> Maybe b) -> Gen b
20:52:11 <ski> @let hereditaryUnion ss = ss `unionHFS` foldr unionHFS (wrapHFS []) (map hereditaryUnion (unwrapHFS ss))
20:52:13 <lambdabot>  Defined.
20:52:55 <ski> > map (toNat . hereditaryUnion . fromNat) [0 ..]
20:52:58 <lambdabot>   [0,1,3,3,7,7,7,7,11,11,11,11,15,15,15,15,23,23,23,23,23,23,23,23,31,31,31,3...
20:53:02 <ski> > map (map toNat . unwrapHFS . hereditaryUnion . fromNat) [0 ..]
20:53:06 <lambdabot>   [[],[0],[0,1],[0,1],[0,1,2],[0,1,2],[0,1,2],[0,1,2],[0,1,3],[0,1,3],[0,1,3]...
21:07:40 <lpaste> dibblego pasted “QuickCheck” at http://lpaste.net/95317
21:08:10 <dibblego> which part(s) of QuickCheck are being re-implemented here?
21:09:13 <Tekmo> I just got here and just saw the lpaste and your question.  I don't understand the question.  Is there some context that I am missing?
21:09:42 <dibblego> Tekmo: no, what more context is required? I have implemented a QuickCheck function that I suspect might already be implemented, or at least parts of it.
21:09:59 <dibblego> is there some QuickCheck library function(s) that I am overlooking to make this easier?
21:10:03 <bergmark> is there a pcre regex library that works with Text?
21:10:07 <carter> lhowdy Tekmo  :)
21:10:15 <Tekmo> carter: Hi! :)
21:10:26 <Tekmo> dibblego: Oh, I see.  That's much clearer. :)
21:10:39 <dibblego> if I asked this, where have I re-implemented? foldr (++) [], you would say "concat"
21:10:56 <Tekmo> dibblego: Give me a second to study it.  I'm not too familiar with QuickCheck myself, but I will take a stab at it
21:11:02 <dibblego> Tekmo: ok cheers
21:12:31 <dibblego> brb
21:12:37 <carter> i really need to use quickcheck more
21:15:50 <ski> dibblego : not sure what the deal with `2*k + n' is
21:16:15 <ski> @type \gen amb f -> forAll gen (\a -> let mb = amb a in isJust mb ==> f (fromJust mb))
21:16:16 <lambdabot> (Show a, Testable prop) => Gen a -> (a -> Maybe a1) -> (a1 -> prop) -> Property
21:16:52 <ski> if one could "reify" `(a1 -> prop) -> Property' into `Gen a1', that might perhaps be close to what you want
21:17:36 <Tekmo> dibblego: I think you can simplify `maybe (try (k+1) (n-1)) (return . Just) (p x)` to `try (k + 1) (n - 1) <|> p x`
21:18:15 <Tekmo> dibblego: Wait, not quite
21:18:24 <ski> when `k' is incremented and `n' decremented, then `2*k+n' is incremented by one
21:18:52 <ski> so why not just increment `k' starting from `n' (`k' starts from `0') ?
21:19:08 <ski> (as well as decrementing `n', i mean)
21:19:50 * hackagebot ed25519 0.0.2.0 - ed25519 cryptographic signatures  http://hackage.haskell.org/package/ed25519-0.0.2.0 (AustinSeipp)
21:20:27 <Tekmo> dibblego: I'm still having trouble understanding what this code is supposed to do
21:21:11 <ski> some kind of repeated testing, with sizes changing in some way
21:21:55 <ski> ignoring the sizes, it sounds like a `catMaybes' for `Gen'
21:22:05 <mischov> When looking through some attoparsec code I ran across the symbols *> and <* symbols. They are a bit hard to google. Can anybody tell me what they mean?
21:22:13 <ski> @hoogle (*>)
21:22:13 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
21:22:13 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
21:22:13 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
21:22:15 <ski> @hoogle (<*)
21:22:15 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
21:22:16 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
21:22:16 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
21:22:22 <mischov> Thanks.
21:22:31 <ski> @where hoogle
21:22:31 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
21:22:58 <Tekmo> mischov: `(*>)` is basically the same thing as `(>>)`, except only using `Applicative` instead of `Monad`
21:23:02 <mischov> Honest to god I went to hoogle and typed *> in..
21:23:08 <mischov> Didn't help.
21:23:19 <Tekmo> mischov: Use Hayoo
21:23:27 <Tekmo> mischov: It indexes all packages by default
21:23:33 <ski>   fa <* fb = liftA2 (\a b -> a) fa fb
21:23:37 <ski>   fa *> fb = liftA2 (\a b -> b) fa fb
21:24:16 <Tekmo> mischov: If you were to implement `(<*)` using `Monad`, it would look like: m <* n = do { r <- m; n; return r }
21:24:31 <mischov> Thank you sir.
21:24:32 <ski>   liftA2 f ma mb = pure f <*> ma <*> mb
21:24:45 <ski>                  =      f <$> ma <*> mb
21:24:58 <carter> Tekmo: hows the dissertatiioning?
21:25:04 <Tekmo> carter: Good
21:25:24 <carter> Tekmo: i'm in that horrible yet exctiting stage of library writing called api whack amole
21:25:25 <Tekmo> carter: I finished the first draft, minus the `pipes` stuff, so I'm feeling good now
21:25:28 <carter> cool
21:25:39 <carter> i wanna investigage that cps stuff if i find the time / a clone
21:25:50 <ski> which CPS stuff ?
21:26:01 <Tekmo> carter: Trust me, the CPS stuff is not worth it
21:26:05 <carter> ok
21:26:06 <carter> finee
21:26:10 <Tekmo> ski: He means `pipes`
21:26:11 <carter> youre the expert
21:26:28 <Tekmo> CPS only works well if you can predict in advance all the ways you want to traverse the structure
21:26:46 <Tekmo> But if you want to be flexible and allow multiple traversal schemes then ordinary data types work better in my experience
21:26:47 <carter> machines does a 2 phase compilation like thinyg right?
21:26:52 <Tekmo> Right
21:26:59 <carter> and that solves that problem
21:27:00 <Tekmo> Machines compiles CPS to a non-CPS type
21:27:08 <carter> ohhh. hrm
21:27:31 <Tekmo> Plus, I prefer to keep the core of `pipes` simple
21:27:33 <carter> thoughtpolice: btw why does the github repo for your curve package have a spellcheck script? https://github.com/thoughtpolice/hs-ed25519/tree/master/scripts
21:27:55 <carter> so any fancy predilections i should aim at machines :)
21:27:56 <carter> ok
21:27:57 <carter> got it
21:28:40 <Tekmo> Only if you don't mind not being able to sequence things after you compose them
21:28:48 <carter> huh
21:28:50 <carter> what do you mean
21:28:57 <Tekmo> Then you lose the time complexity guarantee
21:29:09 <Tekmo> It has the same quadratic blowup once you convert to the composable representation
21:29:21 <carter> which does when?
21:29:30 <carter> sequence in which sense?
21:29:35 <Tekmo> In the monadic sense
21:29:46 <carter> for which
21:29:57 <Tekmo> Here, let me look it up to remember what the names of these things are
21:30:04 <Tekmo> I can never get the name of the 20 different types straight
21:30:10 <carter> ok
21:30:13 <carter> many thanks
21:30:24 <thoughtpolice> carter: i copied it from edwardk
21:30:27 <carter> ok
21:30:33 <carter> which?
21:30:35 <thoughtpolice> also, i love love love hvr's GHC setup
21:30:36 <thoughtpolice> lens
21:30:38 <carter> repo?
21:30:45 <thoughtpolice> lens
21:30:47 <Tekmo> Got it
21:30:48 <carter> whats the scripts do ?
21:30:51 <Tekmo> So `Plan` is the CPS type
21:30:55 <Tekmo> and `Machine` is the non-CPS type
21:31:05 <Tekmo> Only `Machine`s can be composed
21:31:14 <thoughtpolice> it spellchecks? :P
21:31:32 <carter> ohhh
21:31:34 <carter> that neats
21:31:38 <Tekmo> But once you convert to the `Machine representation to compose them you lose the linear time complexity guarantee because you are stuck in the ordinary free monad
21:31:52 <Tekmo> As far as I can tell, there's no way to convert back from a `Machine` to a `Plan`
21:31:54 <carter> Tekmo: i thought you're supposed to only write plans
21:32:05 <carter> and then convert the assembly to a machine to run
21:32:07 <Tekmo> carter: Then that means you can't do the equivalent of this `pipes` code
21:32:20 <carter> ok
21:32:28 <Tekmo> carter: (p1 >-> p2) >> (p3 >-> p4)
21:32:40 <Tekmo> pipes is all about gracefully switching between all the different ways to connect things
21:32:49 <carter> can i read that as
21:33:08 <carter> do (p1 >-> p2) ; (p3 >->p4)  ?
21:33:13 <Tekmo> yes
21:33:20 <carter> so run one pipeline then another
21:33:24 <Tekmo> Let me give a concrete example:
21:33:28 <carter> how would there be a blowup there?
21:33:33 <Tekmo> There wouldn't
21:33:46 <Tekmo> However, both `pipes` and `machines` would blow up on this:
21:33:54 <Tekmo> replicateM n (p1 >-> p2)
21:34:16 <ski> space leaks ?
21:34:17 <carter> run a pipeline n times
21:34:22 <carter> for its effedts
21:34:23 <carter> ?
21:34:27 <Tekmo> ski: Quadratic time complexity
21:34:42 <ski> hm, why ?
21:34:43 <Tekmo> ski: Because they both use a naive free monad when you start composing things
21:34:57 <ski> mhm, i think i sortof see
21:34:59 <Tekmo> ski: pipes always uses a naive free monad, and `machines` uses it when you start composing things
21:35:07 <ski> (repeated substitution)
21:35:34 <carter> really? http://hackage.haskell.org/package/machines-0.2.3.1/docs/Data-Machine-Plan.html ?
21:35:42 <carter> you can compose plans...
21:35:43 * ski has no idea how pipes and machines are defined, though
21:36:02 <carter> use the source ski
21:36:04 <Tekmo> carter: How?
21:36:05 <carter> sourcski
21:36:19 <carter> Tekmo: lets look at the monad instance! :)
21:36:34 <Tekmo> carter: No, I mean compose horizontally (i.e. analogous to `>->`)
21:36:58 <Tekmo> Here, let me be more precise with terminology
21:37:02 <carter> Tekmo: http://hackage.haskell.org/package/machines-0.2.3.1/docs/Data-Machine-Process.html
21:37:10 <carter> Process is the machines analogue of pipes
21:37:12 <Tekmo> Yes, but that is the naive free monad
21:37:23 <Tekmo> Once you switch to that you lose the linear time complexity for `replicateM`
21:37:43 <carter> huh
21:37:47 <carter> i'll have to ask edward about this
21:38:02 <carter> i asked him about this last summer
21:38:04 <carter> at hacphi
21:38:14 <carter> and he gave a really good explanation about how he worked around that
21:38:26 <carter> and i don't remember it
21:38:31 <carter> but you raise good point
21:38:31 <carter> s
21:38:52 <Tekmo> The problem I have with `machines` is the huge proliferation of types
21:39:16 <Tekmo> You have to constantly convert between representations to get good efficiency and to do anything at all
21:39:46 <carter> yeah
21:39:48 <Tekmo> It's great if your brain is an encyclopedia like Edward's
21:39:58 <carter> or have his Cell # :)
21:40:06 <elliott> all two representations
21:40:21 <carter> :)
21:40:31 <Tekmo> elliott: The `k` type parameter to `machine` effectively makes it multiple types
21:40:36 <carter> yeah
21:40:40 <carter> its kinda awesome
21:40:46 <carter> helped me really really understand GADTS :)
21:40:50 <elliott> well, those are used to define the input language. it's flexibility
21:40:59 <carter> yeah
21:41:01 <carter> its really neat
21:41:38 <ski> ah, i suspected `k' would commonly be instantiated with GADTs
21:41:50 <Tekmo> elliott: Again, flexibility is great if you can keep track of it all, like Edward
21:42:09 * ski suspects a mode system might help
21:42:56 <Tekmo> What's a mode system?
21:43:06 <carter> "power rangers activate"
21:43:11 <Tekmo> Haha :)
21:43:11 <carter> shape of a "TYPE FAMILY"
21:43:18 <carter> "shape of a GADT"
21:44:54 <ski> Tekmo : just a vague idea, i dunno details
21:45:17 <Tekmo> Vague ideas are the best kind! :)
21:45:26 <Tekmo> Precise ideas are rarely innovative
21:45:30 <ski> Mercury uses a static mode system to keep track of which predicates can be run "forward", which can be run "backward", which can be run "sideways", &c.
21:45:48 <ski> that's also very vague, but is backed by more precise details ;)
21:46:10 <ski> Tekmo : do you know any Prolog ?
21:46:23 <Tekmo> No, unfortunately :(
21:46:23 <ski> (or really, any logic programming with backtracking and unification)
21:46:33 <Tekmo> Well, I have read of some concepts, but never actually tried it
21:46:40 <Tekmo> I understand how it does clever things using unification
21:46:43 <Tekmo> But that's about it
21:46:51 <ski> well, here's a simple example of multiple modes
21:47:08 <ski> there's an append/3 predicate, corresponding to `++' in Haskell
21:47:25 <ski> in Mercury, it's type signature is
21:47:42 <ski>   :- pred append(list(T),list(T),list(T)).
21:48:14 <ski> the intended meaning of `append(Front,Back,List)' is that `List' is the concatenation of `Front' and `Back', in that order
21:48:32 <ski> in Haskell (and Mercury) terms, roughly `List = Front ++ Back'
21:48:48 <Tekmo> And it works both ways, right?
21:48:51 <ski> now, here's some examples of queries using append/3
21:49:03 <ski>   ?- append([0,1,2],[3,4],List).
21:49:11 <ski>   List = [0,1,2,3,4]
21:49:20 <ski>   ?- append([0,1,2],[3,4],[0,1,2,3,4]).
21:49:21 <ski>   true
21:49:25 <ski>   ?- append([0,1,2],[3,4],[0,1,3,2,4]).
21:49:27 <ski>   false
21:49:36 <ski>   ?- append([0,1,2],Back,[0,1,2,3,4]).
21:49:43 <ski>   Back = [3,4]
21:49:47 <ski>   ?- append([0,1,2],Back,[0,1,3,2,4]).
21:49:49 <ski>   false
21:50:00 <Fuuzetsu> I'm looking to do a configuration file in my program and while I could parse everything out at runtime, having it as a Haskell file would be much better because I wouldn't have to deserialise by hand. Something like what XMonad achieves. Are there resources on this?
21:50:09 <ski>   ?- append(Front,Back,[0,1,2]).
21:50:16 <Tekmo> Fuuzetsu: configurator
21:50:18 <ski>   Front = [],Back = [0,1,2] ;
21:50:19 <Fuuzetsu> Yi does this too.
21:50:23 <ski>   Front = [0],Back = [1,2] ;
21:50:27 <Fuuzetsu> @hackage configurator
21:50:27 <lambdabot> http://hackage.haskell.org/package/configurator
21:50:29 <ski>   Front = [0,1],Back = [2] ;
21:50:33 <ski>   Front = [0,1,2],Back = []
21:50:45 <copumpkin> ski: what if there are loads of them?
21:50:49 <ski> the `;' signifies "or", multiple alternative solutions of the "equation"
21:51:02 <ski> copumpkin : loads of solutions ?
21:51:05 <copumpkin> yup
21:51:52 <Fuuzetsu> Tekmo: not exactly what I'm looking for, I'd be looking for something that compiles against a lib I would expose so it's all nice and type-checked.
21:51:55 <ski> Prolog interactors ("read-prove-print-loops", RPPLs) typically let you press `;' in case you want it to look for more solutions, or hit enter/return in case you want to abort search
21:52:03 <copumpkin> ah
21:52:16 <Tekmo> Fuuzetsu: Oops.  For some reason I thought `configurator` compiled native Haskell
21:52:22 <ski> anyway, the first query of append/3 above is calling it in the following mode
21:52:32 <ski>   :- mode append(in,in,out) is det.
21:52:43 <ski> the next two are calling it in the mode
21:52:51 <ski>   :- mode append(in,in,in) is semidet.
21:52:54 <ski> the next two in
21:52:54 <Tekmo> Fuuzetsu: Maybe `dyre` is what you want
21:53:00 <ski>   :- mode append(in,out,in) is semidet.
21:53:07 <ski> and the final one in mode
21:53:10 <lpaste> dibblego revised “QuickCheck”: “No title” at http://lpaste.net/95317
21:53:15 <ski>   :- mode append(out,out,in) is multi.
21:53:24 <Fuuzetsu> @hackage dyre
21:53:24 <lambdabot> http://hackage.haskell.org/package/dyre
21:53:25 <ski> `det' means "deterministic", there's exactly one solution
21:53:27 <lpaste> dibblego revised “QuickCheck”: “which part(s) of QuickCheck are being re-implemented?” at http://lpaste.net/95317
21:53:38 <ski> `semidet' means "semi-deterministic", there's at most one solution
21:53:47 <ski> `multi' means "multi-deterministic", there's at least one solution
21:53:56 <lpaste> dibblego revised “QuickCheck”: “No title” at http://lpaste.net/95317
21:54:00 <ski> there's also `nondet' for "non-deterministic", any number of solutions
21:54:06 <dibblego> gah the title keeps being lost
21:54:11 <Tekmo> So `semidet` would be like a return value of `Maybe a`, multi would be `[a]`, and `det` would be `a`
21:54:17 <ski> yes
21:54:18 <Tekmo> Oh wait
21:54:22 <dibblego> who owns lpaste?
21:54:23 <Tekmo> `multi` would be `NonEmptyList a`
21:54:26 <Tekmo> But otherwise, I follow
21:54:41 <ski> except the *same* code for append/3 implements all these varying functionality
21:54:46 <dibblego> @tell chrisdone there appears to be a bug in lpaste in that revising a post loses the title
21:54:46 <lambdabot> Consider it noted.
21:55:26 <ski> in Prolog, the same code is executing -- there's an interpretative performance penalty for this
21:55:58 <ski> in Mercury, the compiler compiles each separate mode (from the single common source) to separate procedures in the target language
21:56:17 <Tekmo> This is a question both for ski and others.  How would you model a Prolog-like predicate in Haskell?
21:56:34 <ski> and it statically keeps track of which variables are known yet and which aren't and automatically reorders conjunctions so as to not attempt to use anything which isn't known yet
21:57:37 <ski> (different modes of the same predicate source might execute the same conjunction in different orders, to satisfy data dependencies going "forward" or "backward" in different modes)
21:57:57 <Fuuzetsu> Tekmo: That… looks like what I want. I think. Thanks.
21:58:04 <Tekmo> Fuuzetsu: You're welcome
21:58:28 <ski> Tekmo : with a logic programming monad that supports both backtracking and (efficient implementation of) logic variables
21:58:50 <Tekmo> ski: Well, I get how you would implement it in a given direction using a backtracking monad
21:59:07 <ski> Tekmo : istr Seres and Spivey(?) had a paper about implementing logic variables, and then Koen Claesson had one about implementing typed logic variables
21:59:30 <carter> do we have a nice lib for this on hackage?
21:59:44 * ski extended that to a more powerful system with goal implications, as a project on a course
21:59:57 <Tekmo> I feel like Koen Classen seems to anticipate almost every subject that I find cool
22:01:03 <ski> Koen is cool
22:03:07 <ski> Tekmo : anyway, i think Mercury <http://www.mercurylang.org> is one cool project
22:03:16 <ski> (there's also a #mercury channel here)
22:03:58 <ski> but it might be nicer to learn basic Prolog first, to appreciate just how cool Mercury is :)
22:05:28 <gabemc> I have a library that I would like to have open a an HTTP connection and make multiple requests against the server. I'm using io-streams and Network.Http.Client. Is there a common idiom for retaining that connection over several calls, only running the "close" action on the connection when there is an exception? What might a library user expect to see in terms of an API for such a thing?
22:05:33 <ski> (also see <http://web.archive.org/web/20080816104744/http://www.cs.mu.oz.au/research/mercury/mailing-lists/mercury-users/mercury-users.200610/0057.html> in 2006-10-09 and <http://web.archive.org/web/20080816090753/http://www.cs.mu.oz.au/research/mercury/mailing-lists/mercury-users/mercury-users.200610/0068.html> in 2006-10-10 by Richard A. O'Keefe for some more comments on Mercury vs. Prolog)
22:05:36 <Tekmo> So besides type systems, what are some other neat applicaitons of constraint-based programming?
22:07:09 <ski> non-overlapping layout of GUI elements is one example
22:07:13 <intrados> Is there a way to depoint record access? From something like `foo x = bar (baz x) (qux x)`
22:07:19 <ski> various kinds of scheduling, of course
22:07:27 <Tekmo> ski: Wow, that's crazy that it interleaves IO with logic-based programming.  Does Prolog do that, too?
22:07:41 <ski> Tekmo : which are you thinking about ?
22:07:53 <Tekmo> ski: The way it uses state passing to simulate threading of state
22:07:56 <ski> Mercury is a pure declarative language, no side-effects
22:08:12 <Tekmo> I'm looking at the first examples here: http://www.mercurylang.org/documentation/papers/book.pdf
22:08:34 <ski> both Mercury and Clean uses uniqueness for I/O sequencing and update-in-place of arrays
22:08:38 <enthropy> intrados: you can liftM2 bar baz qux
22:09:06 <enthropy> intrados: or -XNamedFieldPuns,   foo C{bax, qux} = bar baz qux
22:09:18 <ski> Tekmo : Prolog does I/O by side-effecting
22:09:19 <enthropy> provided C is actually the (only) constructor
22:09:51 <ski> enthropy ?
22:10:32 <enthropy> ski: am I making no sense?
22:10:41 <intrados> enthropy: liftM2 looks right. Thanks
22:10:49 <ski> enthropy : i'm not sure why it would need to be the only constructor
22:11:07 <Tekmo> ski: If it's not then `foo` is partial
22:11:12 <enthropy> well if it's not the only constructor then the translation will be off
22:11:20 <ski> Tekmo : `main' is specified by specifying the relation between the world state before executing the program and the world state after executing it
22:11:31 <enthropy> and I guess it's still off in terms of strictness
22:11:35 <mzero> or even -XRecordWildCards    foo x{..} = bar baz qux
22:11:42 <ski> Tekmo : assuming there's no other definition equation for `foo' ..
22:11:48 <Tekmo> True
22:11:51 <copumpkin> ski: how about concurrency?
22:11:53 <ski> .. which i didn't see intrados claim
22:12:22 <Tekmo> He meant about IO for logic programming, I think
22:12:54 <Tekmo> Well, I have to get some sleep.  Thanks for introducing me more to logic programming, ski!
22:13:05 <ski> Tekmo : there's also ##prolog for Prolog :)
22:13:10 <enthropy> mzero: that doesn't seem to work with a lowercase x
22:13:20 <ski> Tekmo : also see those two mailing list messages i linked to above
22:13:39 <Tekmo> Well, I can barely handle on IRC channel
22:13:39 <mzero> whoops need parens:    foo (x {..}) = bar baz qux
22:13:43 <Tekmo> I'm very bad at casual IRC chat
22:14:00 <Rylee> @pl f x = x * x
22:14:00 <lambdabot> f = join (*)
22:14:07 <Rylee> wow what
22:14:12 <ski> copumpkin : <http://www.mercurylang.org/information/doc-latest/mercury_library/thread.html> and <http://www.mercurylang.org/information/doc-latest/mercury_library/thread_002emvar.html> e.g.
22:14:24 <ski> copumpkin : but you should really ask Boney about concurrency stuff
22:14:53 <ski> Rylee : for our purposes here `join f = \x -> f x x'
22:15:14 <Rylee> ski, oh! okay, thank you.
22:15:19 <johnw> Tekmo: hello!
22:15:34 <ski> Rylee : this is the `(rho ->)' monad
22:15:40 <ski> akak `(->) rho'
22:15:42 <enthropy> mzero: what compiler do you use?
22:15:48 <mzero> GHC
22:15:49 <ski> s/akak/aka/
22:16:13 <johnw> mzero is the guy I turn to when I'm out of alternatives
22:16:22 <mzero> enthropy: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html#record-wildcards
22:16:42 <enthropy> yeah, but all those examples name a constructor
22:17:14 <mzero> shouldn't you be turning to empty when you're out of Alternative(s)?  :-P
22:17:16 <enthropy> and you don't need parentheses around the C { }
22:17:41 <ski> record construction syntax binds tighter than function application
22:18:06 <ski> > Just Node {rootLabel = (),subForest = []}
22:18:08 <lambdabot>   Just (Node {rootLabel = (), subForest = []})
22:18:08 <mzero> I'm sorry, a) my syntax is wrong, and b) I assumed because of the RecordPuns mention, you had a constructor here
22:19:22 <mzero> > let allNames Node{..} = rootLabel ++ concatMap allNames subForest
22:19:24 <lambdabot>   not an expression: `let allNames Node{..} = rootLabel ++ concatMap allNames...
22:19:45 <mzero> > allNames Node{..} = rootLabel ++ concatMap allNames subForest
22:19:46 <lambdabot>   <hint>:1:19: parse error on input `='
22:19:51 <mzero> grrrr.
22:19:54 <ski> @let allNames Node{..} = rootLabel ++ concatMap allNames subForest
22:19:54 <lambdabot>  Parse failed: RecordWildCards is not enabled
22:20:01 <ski> there you go
22:20:02 <mzero> :-)
22:21:35 <oio_> so i am getting different results from javascript and haskell
22:22:04 <mzero> shocking!
22:22:12 <bergmark> :OO
22:22:22 <mzero> do you have a piece of code that runs in both! a polyglot!!
22:22:35 <mzero> er, but, lemme guess - this is about floating point?
22:22:37 <bergmark> i'm actually working on a library that works in both :)
22:22:51 <ski> a polyglot library ?
22:22:58 <ski> that's new to me
22:23:03 <oio_> > (1+2::Floating a => a ) * (log 45)
22:23:04 <lambdabot>   11.419987469310959
22:23:17 <bergmark> it's polyglotic in two dimensions
22:23:40 <bergmark> it runs on js and haskell, and converts between latin and korean
22:23:50 <oio_> in javascript i get 8.61332497954064
22:24:15 <ski> bergmark : and the same source is used for both Haskell and ECMAScript ?
22:24:17 <oio_> 1+2*Math.log(45)
22:24:31 <ski> > log 10
22:24:32 <lambdabot>   2.302585092994046
22:24:42 <ski> oio_ : try that in ECMAScript ?
22:25:07 <newsham> > log 10 / log 2
22:25:09 <lambdabot>   3.3219280948873626
22:25:12 <ski> > logBase (exp 1) 10
22:25:13 <lambdabot>   2.302585092994046
22:25:23 <ski> > logBase 2 10
22:25:24 <lambdabot>   3.321928094887362
22:25:27 <bergmark> ski: well compiling it to js, so pretty cheating :( but i'm using they JS->Fay stuff so you can use it as a JS library too
22:25:34 <oio_> look here http://math.chapman.edu/~jipsen/js/
22:26:05 <bergmark> i can't figure out what namespace to put it under though
22:26:09 <newsham> > 10^(3.33 * 32)
22:26:10 <lambdabot>   Could not deduce (GHC.Num.Num b0) arising from a use of `GHC.Num.*'
22:26:11 <lambdabot>  from t...
22:26:15 <newsham> > 10**(3.33 * 32)
22:26:17 <lambdabot>   3.6307805477010323e106
22:26:20 <bergmark> Language.* sounds right, but it's not usually what Language means :)
22:26:34 <newsham> > 10**(32/3.33)
22:26:35 <lambdabot>   4.070142453219439e9
22:27:09 <mzero> so, log in Haskell and Math.log in JS are both in the same base (e)
22:27:39 <newsham> naturally
22:27:53 <jle`> ^^
22:28:28 <mzero> olo_
22:28:30 <oio_> soo.. who is right haskell or javascript?
22:28:34 <mzero> you have two different expressions
22:28:45 <mzero> in HS you are computing 3 * log(45)
22:28:55 <mzero> in JS youa re computing 1 + 2 * log(45)
22:29:10 <ski> hm, if `exp' counts subsets with natural cardinality, what counts subsets with conatural cardinality ?
22:29:34 <oio_> so 1 +(2 log 45 )
22:29:43 <mzero> > 1 + 2 * log 45
22:29:44 <lambdabot>   8.61332497954064
22:29:48 <oio_> !@#$%^
22:29:54 <mzero> ;-)
22:30:11 <mzero> and I was right - it *was* about floating point!
22:31:20 <ski> hm, right, it's not subsets, but subbags
22:31:30 <oio_> k thnx
22:31:36 <newsham> when it comes to floating point there is no right, just varying degrees of wrong
22:31:38 <ski> you forgot "bye"
22:31:39 <carter> ski: have you seen the book analytic combinatorics?
22:31:44 <carter> newsham: float has semantics
22:31:48 <carter> just not the ones you expect :)
22:31:50 <ski> carter : no ?
22:31:55 <carter> oooooo
22:31:59 <Fuuzetsu> I want to provide executable and a library, is there anything special I need to pass to cabal or will just ‘cabal install’ take care of both?
22:32:07 <newsham> carter: varying degrees of wrong semantics
22:32:19 <ski> there's a topic of "numeric analysis"
22:32:23 <carter> yes
22:32:25 <carter> and a spec
22:32:33 <carter> that say "heres what things means"
22:32:37 <carter> thats pretty precise
22:32:38 <mzero> cabal can take care of both
22:32:49 <carter> ski: http://algo.inria.fr/flajolet/Publications/AnaCombi/ :)
22:32:52 <Fuuzetsu> ski: ‘unts’
22:32:56 <carter> pdf is free online on the author's site
22:33:00 <carter> he passed 2 years ago
22:33:07 <Fuuzetsu> oh, I misread, joke failed
22:33:08 <carter> he's got lots of really amazing apers
22:33:17 <carter> also the book is beautiful
22:33:22 <carter> i need to finish working through it sometime
22:34:27 <carter> newsham: floats at a very very clearly specified thing
22:34:33 <carter> they just aren't what you think they are
22:34:41 <carter> they're a funny lattice on the real line
22:35:14 <newsham> carter: worst straight-man evar
22:35:19 <carter> ?
22:35:37 <ski> carter : i'd like to get a hold of "Combinatorial Species and Tree-like Structures" by François Bergeron,Gilbert Labelle,Pierre Leroux in 1994 at <http://web.archive.org/web/20120205041505/http://bergeron.math.uqam.ca/Species/especes.html> ..
22:35:53 <carter> ski: neat
22:36:19 <carter> does that inclue stuff thats not in flajolett's book + generatingfunctionology?
22:36:20 <mzero> not only that, compared to the crazy myriad of floating formats that existed prior, IEEE 784 is a pretty elegant design
22:36:30 <ski> carter : dunno, i haven't see it :(
22:36:42 <ski> s/see/seen/
22:36:43 <carter> ski: click http://algo.inria.fr/flajolet/Publications/AnaCombi/book.pdf :)
22:36:55 <carter> mzero: and it actually has nice hardware implementations
22:36:56 <carter> :)
22:37:18 <mzero> AND nice software implementations (Jerome Coonan's thesis, if I'm not mistaken)
22:37:18 <carter> i do think we should figure out how to make some of the features like rounding modes more accessible from haskell
22:37:31 <johnw> carter: thanks for that link!  There's a coursera course based on that book
22:37:43 <carter> johnw: 2 courses i think
22:37:46 <ski> carter : didn't edwardk have something for that ?
22:37:47 <carter> haven't taken em mind you
22:37:52 <carter> sk for what?
22:37:59 <ski> rounding modes
22:38:09 <ski> perhaps i confuse it with something else
22:38:36 <mzero> carter - are rounding modes every actually used?
22:38:54 <ski> @where floating-point
22:38:54 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
22:38:54 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
22:38:55 <carter> mzero: for testing for numerical stability I think
22:38:56 <mzero> I can't say that I've seen code that employs them anytime in the last 20 years
22:39:22 <carter> mzero: i think its mostly to fuzz algs to test for precision issues
22:39:33 <enthropy> @hackage intervals
22:39:33 <lambdabot> http://hackage.haskell.org/package/intervals
22:39:43 <mzero> hmmm... pretty obscure use for such an awful, stateful, feature!
22:40:02 <mzero> (awful in its statefulness, not it's roundingness)
22:40:10 <carter> mzero: i'm thinking something like withRoundingMode exp
22:40:22 <carter> which strictly evaluates a computation and sets + unsets the rounding mode
22:40:23 <enthropy> hmm, that one says "We do not control the rounding mode", but maybe there is a version that did
22:40:35 <mzero> though - how do you do that compositionally?
22:40:54 <carter> mzero: the withMode bit
22:41:00 <carter> it'd note the current mode
22:41:04 <carter> set the specified mode
22:41:05 <mzero> I mean, even if that is in IO, you really wouldn't want the pure computations called by such code to be affected, would you?
22:41:21 <carter> darn it
22:41:22 <carter> hrm
22:41:34 <carter> i guess you could have floating point ops with a phantom type for the mode
22:41:53 <carter> hrmmm
22:41:55 <enthropy> mzero: why should changing a rounding mode necessarily be impure?
22:41:57 <mzero> Perhaps better would be to newtype the Floats:    unRoundDown $ RoundingDown x * RoudningDown y
22:42:28 <enthropy> so long as your  changeMode :: RoundingMode -> Double -> Double doesn't affect any calculations besides what gives the double
22:42:29 <carter> mzero: the problem then is every op needs to set and thenunset the mode
22:42:46 <mzero> yes it woudl
22:43:05 <carter> example please :)
22:43:16 <mzero> enthropy: rounding mode isn't a proprty of a Double - it is a property of the floating operations
22:43:32 <carter> yeah
22:43:51 <carter> chnge the mode, and * and such give different answers :)
22:43:51 <mzero> so     changeRoundingMode :: RoundingMode -> Double -> Double    couldn't do anything
22:44:14 <carter> it'd have to be withMode :: Mode -> (a ->b )-> a -> b
22:44:14 <mzero> but if we have      withRoundingMode :: IO a -> IO a
22:44:20 <carter> or that
22:44:33 <Ralith> why IO?
22:44:42 <Ralith> seems like a pure version a la the original would work fine
22:44:45 <carter> Ralith: because you're changing how floating point ops work
22:44:45 <mzero> only, we couldn't have withMode  as you describe, as we can't look "into" the (a->b) operation
22:44:54 <mzero> and even so, that would be an impure operation
22:44:56 <carter> why not?
22:44:59 <carter> it'd set the mode
22:45:01 <Ralith> carter: so?
22:45:10 <carter> hrmm
22:45:14 <Ralith> oh, I guess you're changing the definition of * dynamically there
22:45:15 <carter> i think you *migth be right*
22:45:17 <carter> yes
22:45:18 <Ralith> that would be IOy
22:45:20 <intrados> @pl f l = writeFile l . bold
22:45:23 <lambdabot> f = id (fix (const (flip ((.) . writeFile) bold)))
22:45:23 <lambdabot> optimization suspended, use @pl-resume to continue.
22:45:28 <mzero> but then, carter, the semantics of /any/ f that you pass in is changed by external circumstance --- but f is pure!!
22:45:34 <carter> true
22:45:41 <intrados> @pl-resume
22:45:45 <carter> I guess for my use case i'd be ok with it be in IO
22:45:47 <lambdabot> f = id (fix (const (flip ((.) . writeFile) bold)))
22:45:47 <lambdabot> optimization suspended, use @pl-resume to continue.
22:45:47 <mzero> and now, all of Haskell is no longer compositional!
22:45:51 <ski> intrados : `f = (. bold) . writeFile'
22:45:58 <mzero> but even in IO you can't do it
22:46:01 <carter> why not
22:46:03 <intrados> ski: Thanks
22:46:04 <mzero> because again, the f's are pure
22:46:13 <carter> which?
22:46:18 <ski> all of them ?
22:46:36 <carter> withMode :: Mode -> (a -> IO b ) -> a -> IO b
22:47:00 <ski> i don't see the point of `a' there
22:47:01 <mzero> where do you get a divde with type   a -> IO b   ?
22:47:36 <carter> pure code can throw exceptions too
22:47:42 <chrisdone> dibblego: i think it's just not clear in the UI: specifying the title for a post revision specifies the title of the revision for the history display
22:47:45 * ski thinks it's clear that we need new types for this
22:48:21 <mzero> yes, it can, but it can't change the ref.trans. of pure code
22:48:28 <carter> it doest
22:48:38 <carter> it changes the code thats lifted into io
22:48:50 <mzero>        withMode RoundDown (\a -> return $ 2 * a) pi
22:48:56 <carter> :)
22:48:57 <chrisdone> dibblego: i should probably allow to update the title too
22:49:07 <mzero> your implication is that * has been changed by withMode
22:49:11 <carter> yup
22:49:17 <carter> so you're saying we cant do it period
22:49:24 <mzero> but I assert you can't do that - NO monadic operation does that
22:49:37 <mzero> you can't change a pure function (*) in this case
22:49:39 <carter> unless we set and unset the mode for every "moded" arith  op
22:49:45 <mzero> NO
22:49:55 <chrisdone> implicit params could perhaps do that
22:49:56 <ski> let g = (2 *) in withMode RoundDown (return . g) pi  -- look ma, no `(*)' inside `withMode'
22:49:57 <mzero> because what if that * is burried deeeeeeeep in some code
22:50:08 <mzero> you have, from afar, changed the guts of some other pure function
22:50:20 <mzero> this can't be allowed
22:50:36 <chrisdone> mzero: implicit params does that?
22:50:58 * ski is with mzero on this point
22:51:06 <ski> chrisdone : but types note it
22:51:14 <chrisdone> of course
22:51:16 <mzero> chrisdone - I dont' think so - insofar as using implicit params in my code, when it calls your code that doesn't use it, can't possibly affect your code
22:51:18 <carter> yes, but its easy to write this code
22:51:20 <carter> even if its wrong
22:51:46 <enthropy> mzero: ski's substitution should make no difference to the rounding mode stuff
22:51:59 <mzero> oh - it certainly would be easy, thanks to the mode bits in teh CPU to write it.... but it is easy to write  unsafePerformIO too....!
22:52:54 <mzero> enthropy: I'm not sure what you're pointing out? ski's example was to show that the rounding mode could affect pure code outside the call site
22:54:21 <ski> well, that it's not static/lexical scope, but dynamic extent, is evident
22:54:39 <carter> mzero: you'll love this piece of evil I wrote in a dash of silly last month: it bus errors in ghci, but gives me back a memory location for compiled haskell values when used via ghc :   https://gist.github.com/cartazio/c0b0f624ff0ba7489085
22:54:51 <carter> mzero: lets zoom out
22:54:59 <carter> i have no plans to use it in code ever
22:55:11 <ski> the question is why `withMode' would be allowed to augment the denotation of any function of type `Double -> Double' (and `Integer -> Integer' as well, via encodings)
22:55:13 <carter> aside from a test suite where i want to know about the numerical stability of code i wrote
22:55:33 <carter> because its useful
22:55:46 <carter> for testing numerical behavior
22:55:53 <carter> it hink
22:55:54 <ski> expressiveness is good
22:55:55 <carter> *i think
22:56:10 <enthropy> well you can already can "augment" it like     pretendToRoundUp f = f . (+ 1e-20)
22:56:10 <carter> if someone figures out how to make that fast and type safe, cool
22:56:13 <ski> expressiveness to the detriment of "resonability", need not be a good bargain
22:56:14 <carter> enthropy: nope
22:56:25 <carter> thats VERY VERY DIFFERENT
22:57:04 <carter> theres a dynamic "resolution size" to floats called the "unit of least precision"
22:57:15 <enthropy> in what sense? You get a different function out
22:57:27 <carter> enthropy: do you know about ULPs?
22:57:36 <carter> + 1e-20 isn't an ULP
22:57:42 <carter> or at leat wont be most of the time
22:58:04 <carter> you have interval   a -------- b
22:58:12 <carter> where  (a-b)= ULP
22:58:31 <carter> and for some arithmetic op you're computing
22:58:40 <enthropy> is this about nextafterf and such?
22:58:45 <carter> a --------- f(x) --------- b
22:58:45 <carter> yes
22:59:00 <carter> and the rounding mode is the rule for choosing a vs b
22:59:06 <mzero> well - before we run a class on IEEE 754
22:59:07 <ski> > exp (exp 5) + 1e-20
22:59:08 <lambdabot>   2.851123567946141e64
22:59:38 <mzero> a) I believe it is possible, for a given preceision, to emulate all the rounding modes given only one of them - though it makes that code somewhat ugly
22:59:47 <carter> agreed
22:59:56 <mzero> b) very little code needs this
23:00:01 <carter> agreed
23:00:21 <carter> c) if you're writing a lib for numerical computation, the more ways you can test your algs in your test suite, the better
23:00:33 <mzero> c) I think one could use newtype wrappers to "annoint" the values (not the ops), which isn't how IEEE 754 does it, but could work without sacraficing purity
23:00:52 <carter> actually… nope, not if you're sometimes calling out to C code for subroutines :)
23:01:01 <mzero> and lastly, if there suitable numeric instances for these newtype wrappers, and good rewriting fusion rules, it could be fast
23:01:16 <carter> how does fusion come into play?
23:01:23 <enthropy> what does fusion have to do with newtypes? newtypes are not runtime things
23:01:32 <mzero> well, carter, as we know, once you call out to C, even if you have given it a pure type in the FFI, you are playing with fire
23:01:38 <carter> yes
23:01:44 <jle`> is there any way to get ghc's rte to print out line numbers or anything for runtime exceptions
23:01:54 <enthropy> @where -xc
23:01:54 <lambdabot> I know nothing about -xc.
23:02:01 <carter> mzero: i agree that this shouldn't be used in normal code
23:02:02 <jle`> or is there something inherent in the way things work in haskell that prevents this
23:02:04 <carter> i'm not talking about normal code
23:02:11 <mzero> well, imagine if......    newtype RoundingDown a = RoundingDown { unroundingDown :: a }
23:02:13 <carter> I just want to have a very very thorough test suite
23:02:27 <carter> mzero: yes, you could optimzie by hoising the set/unset regions
23:02:32 <carter> merging them
23:02:37 <chrisdone> @+where -xc http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
23:02:37 <lambdabot> I know nothing about -xc.
23:02:43 <mzero> imagine if...     instance Num (RoudningDown Double) where ....   (*) = multRoundedDown
23:02:44 <chrisdone> @where+ -xc http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
23:02:44 <lambdabot> Good to know.
23:02:53 <carter> mzero: i accept all your points
23:03:09 <bitemyapp> ocharles: I take it you saw the Reddit thread response?
23:03:20 <carter> but what does doing it that way buy my test suite?
23:03:40 <mzero> and if     multRoundedDown was something like      unsafePerformIO $ between (pushRoudningMode RoundDownMode) (popRoudningMode) $ return a * b
23:03:48 <carter> i enver want to use dynamically changed rounding modes in real code
23:03:53 <carter> only in my test suite
23:03:56 <carter> *never
23:04:02 <carter> never ever
23:04:06 <mzero> NOW, if we chain a seriese of RoundedDown operations, we get a lot of mode set and unsetting
23:04:09 <carter> yes
23:04:23 <carter> and you could optimzie it
23:04:24 <carter> sure
23:04:26 <mzero> but if we have rewrite rules, then we can see when they are juxtaposed (perhaps???) and elide them away
23:04:37 <carter> rewrite rules aren't right for this
23:04:56 <carter> mzero: at this point you may as well have an AST and just do this at runtime
23:04:58 <mzero> possibly - but we all agree on the idea.... kthx
23:05:02 <carter> yes
23:05:06 <carter> butttt
23:05:12 <carter> i don't want anyone to use rounding modes
23:05:19 <carter> i just want to abuse them in my test suite
23:05:28 <carter> and not have them used in real code
23:05:41 <codygman> Can anyone make some recommendations on my code? I would like to use it with Yesod to let users upload a video and get image stills returned to them: http://lpaste.net/95322
23:05:44 <carter> debugging numerical algorithms is hard enough
23:05:51 * mzero imagines     withRoundingMode RoundingDown $ import My.Numerical.Code as MNCRoundedDown
23:06:26 <mzero> carter - in that case, just define some C externals that set rounding mode, and be done with it!
23:06:26 <carter> btw i think this is the floating point IEEE standard ftp://ftp.heanet.ie/disk1/openwatcom/devel/docs/ieee-754.pdf
23:06:30 <carter> mzero: yup
23:06:42 <carter> i'll just have some wee haskell wrappers to make it pleasant
23:06:46 <mzero> I have hardcopy of 754 at my desk!
23:06:47 <carter> thats all i was mulling about
23:06:51 <mzero> also 854!
23:07:02 <carter> whats that one?
23:07:07 <mzero> (which is floating point in other bases!)
23:07:20 <mzero> but both have now been subsumed by IEEE 754bis
23:07:22 <carter> oo
23:07:53 <mzero> (has implemented at least three floating point libraries in his time.... and they were in three different bases!!!!)
23:08:30 <carter> whyyyyy
23:08:35 <carter> i'm curiuos
23:08:39 <carter> and can't spell
23:09:09 <mzero> I'm sorry, it is called IEEE 754-2008
23:09:53 <mzero> there are some very good arguments that base 10 floating point is more convienent, and more appropriate for many kinds of calculation
23:10:02 <carter> huh
23:10:05 <carter> what'd you use them for?
23:10:12 <carter> http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=4610933 is paywalled :(
23:10:34 <mzero> notably, a bit proponent is IBM's Mike Cowlishaw (of Rexx fame), who is on the IEEE floating point committee
23:10:46 <mzero> er, a big proponent...
23:10:48 <ski> @where+ ieee-754 ftp://ftp.heanet.ie/disk1/openwatcom/devel/docs/ieee-754.pdf
23:10:48 <lambdabot> I will remember.
23:10:52 <enthropy> your bank account?
23:11:00 <mzero> yes, for one
23:11:14 <enthropy> if you're fortunate enough to have that much in there
23:11:40 <mzero> in any event, the manthematics behind iEEE 754 (in particular the subtle, default rounding mode, and the denormalized numbers) can be extended to other bases
23:12:03 <carter> true
23:12:12 <mzero> actually, enthropy, the less you have, the better decimal floating point is --- try representing 0.01 in a double!
23:12:42 <enthropy> well you just round on output/display
23:12:46 <enthropy> > 0.01
23:12:47 <lambdabot>   1.0e-2
23:12:59 <carter> mzero: but yeah, agree that there should never be a haskell lib for setting rounding modes as i described :)
23:13:00 <latro`a_> > 0.01 - 0.099
23:13:01 <lambdabot>   -8.900000000000001e-2
23:13:04 <carter> i may just use it in private
23:13:11 <carter> mwahahah
23:13:22 <latro`a_> erm
23:13:26 <latro`a_> > 0.01 - 0.0099
23:13:27 <lambdabot>   9.99999999999994e-5
23:13:35 <latro`a_> ^thta's what I meant to do
23:13:38 <latro`a_> *that's
23:13:41 <carter> mzero: so what were the use cases for those soft float in various radixi you wrote?
23:13:44 <mzero> anyhow, I once wrote a programming langauge and run time that would be primarily used for business applications - we choose to have decimal floating point available - so it was base 10 --- we also had an arbitrary precision floating point system (think bigint merged with arbitrary floating point) - and that one was base 100
23:14:01 <carter> neat
23:14:02 <enthropy> > print "%.2f" (0.01 - 0.0099) :: String
23:14:03 <lambdabot>   Couldn't match expected type `a0 -> GHC.Base.String'
23:14:03 <lambdabot>              with actu...
23:14:07 <carter> pre second life?
23:14:16 <enthropy> > printf "%.2f" (0.01 - 0.0099) :: String
23:14:17 <lambdabot>   "0.00"
23:14:49 <mzero> enthropy: rounding on output really really really doesn't work if what you are doing is, say, reconcilling millions of financial transactions ---over very longs periods of time
23:15:05 <mzero> yes, quite pre second life
23:15:12 <mzero> before the Internet, actually!
23:15:18 <carter> hehe
23:15:40 <carter> the 2008 spec seems to be a bit shorter than some IETF docs ive seen
23:15:50 <carter> i suspect its a bit denser because it uses math though
23:16:09 <enthropy> mzero: yes people say that. But why? If you've ever counted inventory somewhere... it never reconciles exactly
23:16:11 <mzero> it was an prototype based language (successor to Smalltalk, much like Self), with full graphical development environment, and GUI app framework, ..... in under 500k
23:16:34 <carter> neat
23:16:41 <carter> will we ever see its like in haskell?
23:16:51 <carter> we still don't have some of those! :)
23:16:58 <carter> i kid
23:16:59 <carter> ish
23:17:03 <mzero> enthropy: you try to explain to banking regulators that when you add a penny, it might add two!
23:17:08 <chrisdone> we don't really have anything like that
23:17:27 <carter> chrisdone: aren't you working on fixing htat?
23:17:34 <carter> a lil bit
23:17:36 <carter> ? :)
23:17:46 <mzero> true - and it *was* cross platform (four OSes - GUI apps written once ran on all of them)
23:17:54 <mzero> but cross-platform was easier back then
23:17:55 <chrisdone> yeah, sans the gui app framework
23:18:16 * chrisdone was thinking of CLIM
23:18:20 <carter> clim?
23:18:29 <mzero> it also was somewhat reactive in style - programmers wrote almost no code to keep the input and output and data values in sync
23:18:40 <chrisdone> http://en.wikipedia.org/wiki/Common_Lisp_Interface_Manager
23:18:47 <carter> would it be possible to steal the gui engineering work the racket-lang folks have done
23:18:57 <carter> to get a portable gui toolkit thats actually portable?
23:19:31 <mzero> anyhow, if you want to waste some time looking at 20+ year old programming environments - there is some material about it here: http://www.ozonehouse.com/mark/codeworks.html
23:19:49 <carter> unrelatedly http://www.cs.utep.edu/interval-comp/index.html is a doc on recent interval computation algorithm research
23:19:52 <carter> mzero: neat
23:20:01 <chrisdone> last i looked at the mzscheme gui it was kinda rudimentary. it's easy to be portable when you don't do much. maybe racket's improved since 5 years ago, tho…
23:20:28 <mzero> aaaaaaand, just how good does that GUI look?
23:20:38 <ski> improving intervals is interesting
23:22:02 <carter> mzero: chrisdone  they have some native gui bits per platform
23:22:02 <chrisdone> pantsman: pananananan-pantsman!
23:22:14 <carter> though i'm not super familiar
23:22:21 <carter> and i'm not gui adept at all
23:22:23 <chrisdone> ah, sort of like a mini wx?
23:22:42 <carter> ?
23:22:48 <carter> i know nothing of guis
23:22:51 <carter> i just use them
23:23:54 <chrisdone> SWT? i.e. using native gtk+ on linux, cocoa on os x, win32 on windows
23:24:12 <chrisdone> but under one abstract interface. i like that approach
23:24:23 <chrisdone> the Swing approach looks rubbish on all os's
23:24:25 <carter> i think racket does that
23:24:32 <carter> the look native on all of them approach
23:24:34 <carter> wiht modern racket
23:24:42 <chrisdone> cool
23:24:55 <carter> i've not http://docs.racket-lang.org/gui/
23:24:58 <carter> http://docs.racket-lang.org/gui/
23:25:06 <chrisdone> it's not that hard, really, for a subset. i wonder whether someone started doing that for haskell
23:25:54 <carter> i should learn sometime
23:26:05 <carter> just need the time
23:26:44 <chrisdone> neat, looks pretty comprehensive
23:26:56 <chrisdone> ish
23:26:57 <carter> chrisdone: yeah
23:27:00 <carter> point being
23:27:10 <carter> it might be a good starting skeleton
23:27:14 <carter> that someone could leverage
23:27:14 <chrisdone> indeed
23:27:27 <carter> where a lot of the ffi bits are mostly teased out sanely
23:27:44 <carter> theres of course adapting to modern idiomatic haskell style
23:27:46 <chrisdone> a straight port would make good GSoC or something
23:27:47 <carter> or inventing that
23:27:49 <carter> yeah
23:27:51 <carter> agreed
23:28:52 <carter> some of the binding for c++ stuff could be semi automated by wavewave's fficxx stuff
23:28:56 <carter> if its not done already
23:29:38 <chrisdone> it makes sense, too. the haskell gtk+ is now really easy to setup on linux. packge installation just flies. but it's super hard on windows (apparently) and looks bad anyway. whereas the win32 is already on windows, ready to be used. such a cross-platform library would definitely help with the gui problem
23:29:40 <carter> huh, intel has a decimal floating point lib
23:29:51 <carter> yeah
23:30:14 <carter> we just need to find a plucky young student we can prep for doing that for a summer
23:30:31 <chrisdone> another factor is possibly that people simply aren't doing desktop gui programming like they did 10-15 years ago. it's all web stuff these days
23:30:50 <carter> yes and no
23:30:56 <carter> i mean
23:31:00 <carter> idk
23:31:04 <chrisdone> obviously some people are doing it, but there are so few that the intersection of that group of people and haskellers is very small, probably
23:31:12 <carter> true
23:31:31 <carter> otoh, with the right lib, desktop gui is a bit saner than JS
23:31:34 <carter> JS scares me
23:31:40 <chrisdone> nod
23:31:41 <carter> though they're all quircky
23:31:46 <carter> desktop and web
23:32:04 <carter> but web…. the fact that browsers had to become wee JS lisp machines introspection wise
23:32:17 <carter> to make JS + CSS + famlily sane to work with
23:32:20 <carter> is mind boggling
23:32:30 <chrisdone> hm, maybe i'm discounting it with a bias because we don't have those good libraries
23:32:37 <mzero> no no - same approach is applicable to all:  Write the thinest layer at the top to interface with the GUI and OS and write it in the language of choice for that OS --- write the rest in Haskell
23:32:44 <carter> yes
23:32:45 <carter> agreed
23:32:48 <chrisdone> after threepenny was announced, there were a few apps released using it rather quickly
23:33:04 <carter> i thin mzero  has  point
23:33:05 <bergmark> chrisdone: \o/ https://github.com/bergmark/transliterate
23:33:08 <mzero> sure, you need to re-implement, but really, to get a good GUI, you need to taylor it t
23:33:26 <carter> in which sense?
23:33:34 <Fuuzetsu> anyone familiar with dyre and has a minute? It refuses to pick up my config file for whatever reason. I'm running out of ideas, all provided examples run fine.
23:33:38 <chrisdone> bergmark: \o/
23:33:39 <Fuuzetsu> I must be doing something retarded.
23:33:57 <mzero> so, instead, I just wish we had a better Objective-C bridge for Haskell (for Mac), something for web/JS (many approaches in progress), and equivalent for Windows
23:34:21 <mzero> Linux - still no winner, eh? so Gtk? or what are Ubunutu folks advocating these days?
23:34:54 <chrisdone> dunno. gtk+ seems sufficient, but i've never written a full app with it, only toys
23:35:10 <carter> unrealtedly: http://www.netlib.org/misc/intel/ intel decimal floatin point
23:35:19 <carter> mzero: have you seen objective haskell?
23:35:42 <carter> https://github.com/jspahrsummers/ObjectiveHaskell
23:36:28 <mzero> yes, but never used it
23:36:38 <mzero> anyhow - bed time for this monad
23:36:40 <chrisdone> there's also the gtk-server approach
23:36:42 <mzero> night all
23:36:56 <carter> ok
23:39:34 <chrisdone> carter: i'd probably work on such a thing (the racket approach) but i haven't wanted to make a desktop gui for years, i've no personal motivation for it sadly
23:39:53 <carter> so you're saying i need to come up with a way to nerd snipe you
23:39:57 <carter> noted :)
23:40:00 <chrisdone> lol
23:40:27 <enthropy> Fuuzetsu: I've used it once
23:40:39 <Fuuzetsu> Did it Just Work™?
23:41:35 <enthropy> kind of. There were some subtle differences between built-in xmonad recompiling and what dyre does
23:41:48 <Fuuzetsu> I'm getting pretty desperate, I just don't understand why it doesn't work. I can call customCompile from the program and it clearly sees and compiles the config. I can load my config into GHCi and run it that way and it works. I just can't run the bloody binary and have use the config.
23:41:51 <enthropy> which is why there's been no switch-over
23:43:14 <carter> chrisdone: well, i can think of ways i'd use one
23:43:17 <carter> but i'm overcommited
23:43:33 <carter> with my pending release for Numerical Haskell soon ™, plus helping on ghc
23:48:14 <Fuuzetsu> Oh my fu**ing God, got it to work, I'm so angry right now
23:49:38 <chrisdone> carter: when i'm overcommitted and i see other interesting projects http://4.bp.blogspot.com/-JXoQgkDdmG0/UO7aEvqnxxI/AAAAAAAABTo/_iEbI0UAksA/s1600/test.gif
23:53:53 <akegalj> hi there. "inc1 = (+) 1; sub1 = (-) 1; something = inc1 . sub1 . inc1 . sub1" can haskell somehow deduce that "something" is realy "id" and not evaluate +1 -1 +1 -1 . i wonder is ghc able to optimize this somehow? Does he preforms similar optimizations?
23:54:41 <opqdonut> akegalj: it can't. it could if you wrote some rewrite rules
23:55:02 <Jaxan> the assembly optimizer can, if those are ints
23:55:13 <Jaxan> as in, I know of llvm doing this
23:55:14 <opqdonut> right, yeah
23:55:42 <akegalj> opqdonut: what rewrite rules... can you show me example?
23:56:50 <elliott> akegalj: I strongly suspect that will get optimised out.
23:57:41 <akegalj> elliott: :/ ok
23:57:51 <elliott> akegalj: why is that a :/?
23:58:23 <lpaste> dmj pasted “No title” at http://lpaste.net/2797993261438861312
