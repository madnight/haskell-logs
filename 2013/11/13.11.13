00:18:17 <d3lxa> are there people who successfuly used fay, optionally with jquery, in production, etc? I'm looking for opinions about it in "real world"
00:20:21 <alpounet> FPComplete does, for a starter
00:20:41 <alpounet> Silk maybe
00:21:42 * hackagebot Win32-extras 0.2.0.0 - Provides missing Win32 API  http://hackage.haskell.org/package/Win32-extras-0.2.0.0 (KidoTakahiro)
00:21:42 * hackagebot Win32-extras 0.2.0.1 - Provides missing Win32 API  http://hackage.haskell.org/package/Win32-extras-0.2.0.1 (KidoTakahiro)
00:25:54 <dmj`> d3lxa: I'd like to, Don't know where to start to learn it though
00:26:38 * hackagebot wai-handler-launch 1.3.1.5 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.3.1.5 (MichaelSnoyman)
00:26:40 * hackagebot wai-websockets 1.3.2.0 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.3.2.0 (MichaelSnoyman)
00:36:34 <solrize> is this thing on?
00:42:58 <teneen> can the {-# UNPACK #-} pragma be applied to any data type even if it's not primitve?
00:45:15 <teneen> data MyInt = MyInt {-# UNPACK #-} !Int
00:45:31 <teneen> data MyMyInt = MyMyInt {-# UNPACK #-} !MyInt
00:45:48 <teneen> does the second declaration make sense?
00:47:57 <dmj`> teneen: It would seem so
00:48:03 <dmj`> data T = T {-# UNPACK #-} !S
00:48:08 <dmj`> data S = S {-# UNPACK #-} !Int {-# UNPACK #-} !Int
00:48:15 <alpounet> teneen, yes
00:48:22 <dmj`> will store two unboxed Int#s directly in the T constructor
00:48:35 <dmj`> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/pragmas.html#7.13.10
00:49:34 <alpounet> teneen, http://alpmestan.com/2013/10/02/oh-my-laziness/#exercise see just above that exercise there, the paragraph right before
00:50:27 <teneen> I see
00:50:53 <teneen> What about {-# UNPACK #-} ![Int]? what does it mean?
00:51:29 <alpounet> teneen, it won't wor
00:51:29 <alpounet> k
00:51:41 <alpounet> teneen, list has two constructors
00:52:46 <teneen> alpounet: Is it about the number of constructors?
00:53:06 <alpounet> teneen, read the paragraph I pointed you to, it lists some constraints on when this works and when it doesn't
00:55:20 <dmj`> Having issues signing urls w/ hmac-sha1. Any help would be appreciated.
00:55:25 <dmj`> http://stackoverflow.com/questions/19948886/signing-temporary-s3-upload-urls-w-haskell
00:58:37 <alpounet> teneen, let me know if there's still something bugging you after reading it
00:59:18 <teneen> alpounet: I got it
00:59:39 <teneen> alpounet: I believe vectors should be unpackable? isn't it?
01:00:19 <alexander__b> the function should return a Time, how do I uhm make this work?
01:00:21 <teneen> ohh no they have type variables
01:01:07 <alexander__b> right now I get "Couldn't match type `IO (Maybe UTCTime)' with `Maybe (IO UTCTime)'"
01:01:45 <alexander__b> worth mentioning that I'm not convinced/sure it should be Maybe (IO UTCTime)... I just know I'll need it to use getCurrentTime, so I assumed that it should be this.
01:02:40 <alpounet> teneen, well, i don't think the type variable influences the size
01:03:09 <alpounet> err actually it does, nevermind :-)
01:04:41 <alpounet> teneen, anyway, making the "vector" field strict is most likely a good idea, but not sure about unpacking the whole vector in your dat atype
01:04:44 <alpounet> data*
01:04:54 <alexander__b> ahh I can just liftIO I think
01:05:31 <dmj`> alexander_b: care to paste your code?
01:05:49 <teneen> alpounet: yeah
01:06:17 <alpounet> teneen, also, the representation is different depending on which Vector you use
01:06:17 <alexander__b> dmj`: I did
01:06:24 <alexander__b> dmj`: oh
01:06:32 <alexander__b> dmj`: lol. sorry. http://lpaste.net/3808027835537293312
01:06:34 <alpounet> unboxed, storable, ...
01:07:02 <alexander__b> I thought maybe I could turn Time into just a Maybe UTCTime and use liftIO on getCurrentTime or similar. I'm very new at this side of haskell.
01:07:56 <alpounet> alexander__b, you most likely want "IO Time"
01:08:17 <alpounet> getTime = Just <$> getCurrentTime
01:08:27 <alexander__b> alpounet: I want Maybe because I initialise it to Nothing and have two Times in my program.
01:08:35 <johnw> fmap Just <$> getCurrentTime
01:08:42 <johnw> ah, no
01:08:52 <dmj`> @typ getCurrentTime
01:08:53 <lambdabot> Not in scope: `getCurrentTime'
01:09:02 <alpounet> @hoogle getCurrentTime
01:09:03 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
01:09:03 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
01:09:19 <alexander__b> that results in Couldn't match type `Maybe UTCTime' with `UTCTime'
01:09:31 <alexander__b> I have startTime ::  Maybe UTCTime
01:09:46 <alpounet> alexander__b, no, it's IO (Maybe UTCTime)
01:09:50 <alexander__b> oh
01:09:50 <dmj`> alexander_b: are you trying to profile execution time?
01:09:55 <alexander__b> dmj`: no
01:09:58 <alpounet> you have to ask the system what time it is, so side effects
01:10:15 <alexander__b> alpounet: well, then I get Couldn't match type `Maybe a0' with `IO (Maybe UTCTime)'
01:10:36 <alpounet> alexander__b, you need to change your Time type accordingly too
01:10:44 <alexander__b> alpounet: I have
01:10:59 <alexander__b> both Time and the typesig for the function is IO (Maybe UTCTime)
01:11:57 <alpounet> can you annotate your paste with the current code?
01:12:19 <alexander__b> alpounet: no need. the code is just startTime = Just <$> getCurrentTime, with the type Time = IO (Maybe UTCTime)
01:12:27 <alexander__b> that's it. it's not called anywhere.
01:12:59 <alexander__b> waaait
01:13:18 <alpounet> Time should just be Maybe UTCTime, shouldn't it?
01:13:20 <alexander__b> the problem is elsewhere. I was misreading ghc-mod.
01:13:29 <alpounet> oh ok
01:13:37 <alexander__b> alpounet | alexander__b, no, it's IO (Maybe UTCTime)
01:13:48 <dmj`> why does UTCTime need to be in a Maybe
01:13:49 <alexander__b> alpounet: I thought you said it was IO (Maybe UTCTime)?
01:14:05 <alexander__b> dmj`: because I initialise it with Nothing and it can be Nothing sometimes in the program.
01:14:12 <alpounet> alexander__b, I said getting the time was necessarily sending you in IO
01:14:22 <alpounet> but for your Time type, i'd just use Maybe UTCTime
01:14:24 <alexander__b> OK I misinterpreted then.
01:14:35 <alpounet> the IO will just appear when you'll perform any to achieve whaty ou need
01:14:38 <dmj`> what is the programs intended purpose
01:15:02 <alpounet> a game i guess ?
01:15:05 <alexander__b> dmj`: it's a gui stopclock.
01:15:14 <alpounet> eh
01:15:22 <alexander__b> dmj`: just to teach myself working with IO. I have avoided it thus far.
01:16:04 <yesthisisuser> what to do if two packages use different versions of the same package?
01:17:21 <alexander__b> alpounet: so "Just <$> getCurrentTime" gives a UTCTime?
01:17:36 <johnw> it gives an IO (Maybe UTCTime)
01:17:42 <alpounet> alexander__b, ok, let me state that it is equivalent to your original code
01:17:47 <alpounet> just a bit shorter
01:17:51 <alexander__b> ah
01:18:02 <dmj`> yesthisisuser: which packages
01:18:03 <alpounet> so you're still in IO, because you're using getCurrentTime
01:18:14 <alpounet> and then you wrap the result in the "Just" constructor
01:18:17 <alexander__b> OK. but if Time should be a Maybe UTCTime, how do I work with that?
01:18:21 <alpounet> just as you were doing.
01:18:41 <alpounet> well your function would just return a "IO Time"
01:19:13 <yesthisisuser> dmj`: It looks like I have Data.Aeson that uses one version of Data.Text.. and most other packages use a different version
01:19:15 <alexander__b> OK, so how do I use that in my init function to get a Just UTCTime?
01:19:26 <yesthisisuser> so there are two versions of Data.Text installed
01:19:36 <alexander__b> in my init function I'd like to do Program $ Timer startTime Nothing -- Program has a Timer, and a Timer has two Times.
01:19:40 <yesthisisuser> 0.11.2.0 and 0.11.3.1
01:19:52 <yesthisisuser> and I can't remove either without breaking other packages
01:20:01 <alpounet> alexander__b, you need to be in IO at some point to get the startTime
01:20:20 <alpounet> so you'll likely have your function returning a "IO Program"
01:20:26 <dmj`> yesthisisuser: are you using a sandbox?
01:20:32 <yesthisisuser> no
01:20:44 <dmj`> yesthisisuser: this is why we use sandboxes
01:20:53 <dmj`> yesthisisuser: what version of cabal are you running
01:20:59 <alexander__b> alpounet: OK I can use gloss's IO.Game instead of Pure.Game then, which is what I suspected I had to do.
01:21:07 <yesthisisuser> 0.14.0
01:21:11 <yesthisisuser> 1.14.0
01:21:18 <yesthisisuser> 0.14.0 is cabal-install, sorry
01:21:31 <alpounet> alexander__b, yeah, whenever you're going over the network or the filesystem during the game, you need the IO interface of gloss
01:21:42 <yesthisisuser> cabal version 1.14.0.. i am not familiar with sandboxing
01:21:48 <dmj`> yesthisisuser: do cabal install cabal-install, once you hit 1.18 you get the sandbox feature, works on windows and osx
01:22:07 <yesthisisuser> i am on debian
01:22:14 <alexander__b> alpounet: it's not a game. it's literally just a stopwatch lol. I thought I'd make it in Gloss because I know Gloss. so... I'm making it in Gloss first, then I'm looking at wxHaskell. then I'm looking at reactive-banana-wx. so one step at the time. :-)
01:22:49 <dmj`> yesthisisuser: it's really simple, just make a new folder, cd into it, call 'cabal sandbox init' and then any further cabal install's you do will go into a hidden directory .cabal-sandbox directory
01:23:31 <dmj`> yesthisisuser: if things are not salvageable then run 'cabal sandbox delete'
01:23:43 <alpounet> alexander__b, it was interesting to read how you went through learning the basics of haskell game programming by the way
01:24:04 <alexander__b> alpounet: what? where?
01:24:09 <dmj`> yesthisisuser: note though, if you cd out of that folder, your cabal installs will be global. Does this make sense?
01:24:09 <yesthisisuser> dmj`: thanks. i'll try it out
01:24:17 <dmj`> k
01:25:12 <alpounet> alexander__b, didn't you write something about bweakfwu?
01:25:33 <alexander__b> alpounet: oh. right. I'm always surprised to learn that anyone actually read it. thanks for reading!
01:25:52 <yesthisisuser> dmj`: it sounds like i still need to do some uninstall/reinstall to get this to work.. but I should be using sandboxing in the future.. is that correct?
01:25:58 <alexander__b> alpounet: if you peeked at the source code, you might had noticed that there was no mention of IO at all. so I really need to learn that now. ;-)
01:26:09 <alpounet> alexander__b, well, i was curions, having seen you work your way through writing it on #haskell-game
01:27:11 <alexander__b> alpounet: yes. I *do* whine a lot, don't I. ;-)
01:28:23 <alpounet> have seen much worse
01:31:56 <alexander__b> alpounet: it's kind of frustrating to use haskell when you basically know game design and game programming quite well, because you get stuck at the silliest things. but at the same time, I have yet to not be amazed once I grok something in haskell.
01:35:08 <alexander__b> alpounet: OK now I have rewritten everything to use the IO interface. how do I use startTime (which now returns IO Time) in my step function, to get a Just UTCTime
01:35:34 <alpounet> alexander__b, ok so now your step function returns something in IO
01:35:39 <alexander__b> yep
01:35:40 <alpounet> so you can use, for example, do notation
01:35:47 <tdammers> alexander__b: traditional game programming makes heavy use of mutable state, so I guess it takes more getting used to than some other programming domains
01:36:05 <alexander__b> tdammers: indeed! I'm doing my masters on it actually. :-)
01:36:06 <tdammers> e.g., web programming or parsing are more intuitive things to fit into a pure idiom
01:36:56 <tdammers> I really should be picking up my old passion some time and build a game or two in haskell
01:37:14 <tdammers> I used to have a lot of fun doing that in C and C++
01:37:36 <nomeata> Hi. Can I modify variables like +RTS -K from within my code?
01:37:40 <alexander__b> tdammers: feel very free to contribute to bweakfwu. ;-) all this learning haskell business is really slowing down progress.
01:37:41 <alpounet> alexander__b, and get something close to: step :: Float -> Program -> IO Program ; step f w = do { t <- startTime ; return Program startTime Nothing }  -- that doesn't really make sense as a step function (it's more of an init function) but still should help you
01:38:12 <alexander__b> alpounet: yes I know it's stupid for a step function, I just want to see it type check and do something for now, hehe.
01:38:26 <alpounet> err, I forgot parens around 'Program ...'
01:38:28 <tdammers> alexander__b: nah, I have too many ideas of my own
01:38:38 <tdammers> alexander__b: but out of interest, which libraries are yo using?
01:38:41 <tdammers> *you
01:39:04 <alpounet> alexander__b, I hope you can still make sense out of it and manage to write your own useful step function from this
01:39:07 <alexander__b> alpounet: you also forgot the Timer constructor.
01:39:11 <alpounet> ah right
01:39:23 <alpounet> well I think you got the idea anyway
01:39:32 <alexander__b> alpounet: I had exactly what you wrote except I had "Just t" instead of t in the Program constructor, so your post made me realise this silly mistake and now it works!
01:39:56 <alexander__b> so do { t <- startTime; return $ Program $ Timer t Nothing }
01:40:00 <alexander__b> tdammers: gloss
01:40:25 <alexander__b> tdammers: and uh base lol. https://github.com/plaimi/bweakfwu
01:41:53 * hackagebot yackage 0.7.0.1 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.7.0.1 (MichaelSnoyman)
01:42:10 <Brongue> I'm having some difficulties with text encoding on Windows. I'm writing a program that outputs a csv-file for use in Excel, but I can't seem to get the unicode characters to work properly. Has anyone got any experience with that?
01:42:35 <srhb> Brongue: Sounds weird, sure it's not the receiving end that isn't unicode-aware?
01:42:54 <srhb> Brongue: Otherwise you'll need to give us some more to go on. :)
01:43:04 <alpounet> alexander__b, right, your do block looks good, just one odd thing is that the old "Program" isn't used to compute the new one
01:43:23 <alexander__b> alpounet: yes, as far as step functions go, this isn't one. ;-)
01:43:24 <alpounet> but it's just a first shot at this stopclock thingy so you'll fix that later
01:48:09 <alexander__b> so now I just have to figure out how to use IO in init
01:49:10 <tdammers> Brongue: have you tried encoding to 16-bit unicode?
01:50:04 <tdammers> (UCS-2, specifically)
01:50:08 <alexander__b> alpounet: this gloss prototype is almost "done", heh. the only reason I'm doing it in gloss first is because there I know how to get a damn loop. ;-) I had all the buttons and such in place in gtk2hs and wxHaskell, but I didn't figure out how to do getCurrentTime in a reasonable manner.
01:50:39 <tdammers> alexander__b: forever $ do { } ?
01:50:50 <alexander__b> tdammers: I really really really doubt you're supposed to do that
01:50:57 <tdammers> hehe, probably not
01:51:01 <srhb> alexander__b: In gloss?
01:51:13 <lpaste> Brongue pasted “encoding issues” at http://lpaste.net/95594
01:51:13 <alexander__b> gtk2hs had an idle callback, so I used that, but couldn't figure out IO there. in wxhaskell I was a bit more lost.
01:51:33 <alexander__b> srhb: no, glos is what I'm using because I *do* know how to do a loop properly. I was working with gtk2hs and wxhaskell.
01:51:52 <srhb> alexander__b: Ah, right. :)
01:52:30 <alexander__b> so I'm prototyping in gloss to teach myself IO a bit more, and then going back to gtk2hs or wxhaskell. :-)
01:52:40 <Brongue> tdammers: I haven't tried utf16 yet.
01:52:47 <srhb> alexander__b: Sounds like a good idea. :)
01:52:55 <alpounet> alexander__b, I can't help you with wxhaskell nor gtk2hs specifics, but let me know how these two other versions go, I'm curious how they would look
01:52:57 <tdammers> ucs-2 /= utf16
01:53:04 <tdammers> although the 16-bit subset is identical iirc
01:53:24 <tdammers> utf16 can express >16bit codepoints; ucs-2 can't
01:53:34 <tdammers> but anyway, much of windows uses ucs-2
01:53:40 <tdammers> so I guess it's worth a shot
01:53:41 <srhb> alexander__b: So I'm guessing you're using simulateIO right now?
01:53:46 <srhb> (Or one of the similar functions)
01:54:01 <Brongue> There doesn't seem to be a ucs-2 in System.IO.
01:54:05 <tdammers> ah
01:54:12 <tdammers> well, utf-16 might have to do then
01:54:26 <alexander__b> alpounet: sure. BTW the reason I'm making a stopwatch in the first place (apart from a) learning IO and b) learning widgets instead of scene based gui) is so I can emulate jcarmack's neat trick of using a stopwatch whenever's he's working to make himself aware of how much he's actually working, hehe.
01:54:33 <alexander__b> srhb: playIO, yes.
01:54:48 <Brongue> Could i use mkTextEncoding "ucs-2" or somesuch?
01:54:54 <tdammers> (this is a wild guss on my part, mind you; haven't touched Windows in years)
01:55:00 <srhb> alexander__b: Right. :)
01:56:48 <alpounet> alexander__b, hah, I would be worried it would grab too much of my attention, just seeing it in a corner right there, all day long
01:58:12 <alexander__b> alpounet: I wouldn't look at it except for when I stop/start it. it's just to be more aware of breaks. :-)
02:01:59 <alexander__b> alpounet: http://lpaste.net/3002845931394564096 lol! works. :-)
02:02:39 <alexander__b> first one should be Timer t current, but same difference.
02:02:44 <dor_> needs moar frp
02:03:02 <alexander__b> dor_: that's step 104324566573778 or something. :-)
02:03:17 <dor_> hah
02:04:54 <dor_> as for continuous IO in gtk2hs, i don't know but an "obvious" way to me would be forkIO
02:05:45 <dor_> is gtk thread safe? surely?
02:05:56 <alexander__b> I used some idle callback myself, but couldn't get it to work with IO. I'll look into forkIO on my return, I guess.
02:08:40 <dor_> idleAdd? looks like you just pass it an io action that it keeps running
02:10:05 <alexander__b> dor_: probably, IDR.
02:10:20 <alexander__b> what do you do when you have a maybe and uh you know it's not nothing? fromMaybe seems a bit overkill
02:10:40 <alexander__b> i.e. I have already pattern matched Nothing, so I know it must be Just Something and I want to use Something
02:10:48 <mr-> alexander__b: fromJust, but people frown upon that
02:11:03 <mr-> alexander__b: or just use the result of the pattern match, much nicer
02:11:16 <alexander__b> I didn't mean pattern match per se, I use guards
02:11:20 <alexander__b> | start == Nothing || current == Nothing = "00:00:00"
02:11:26 <alexander__b> | otherwise = [stuff...]
02:11:30 <_tsk> hi, i've little problem defining an instance, anybody can suggest some direction?
02:11:39 <_tsk> the program is here http://pastebin.com/5drr4jYr
02:11:44 <mauke> The paste 5drr4jYr has been copied to http://lpaste.net/95596
02:11:59 <_tsk> Could not deduce (Generator m1) arising from a use of `generate'
02:12:00 <_tsk>     from the context (Generator m, Num m)
02:14:52 <dor_> _tsk: what if you remove the type signature on line 26?
02:15:39 <alexander__b> alpounet: done!
02:16:05 <_tsk> dor_, wow... it worked
02:16:14 <dor_> AleXoundOS: you can use pattern guards
02:16:22 <dor_> alexander__b: that was for you
02:16:25 <dor_> gah
02:16:34 <_tsk> why it's not working if we specify the type signature?
02:16:42 <Iceland_jack> _tsk: Because it's not the same ‘m’
02:17:08 <dor_> alexander__b: | otherwise, Just something <- start = ...
02:17:11 <alexander__b> dor_: a nice mix of not being up to date on terminology and not knowing haskell well enough prompts me to ask for an example. http://lpaste.net/3277493464882741248
02:17:15 <alexander__b> dor_: ah
02:17:31 <alexander__b> dor_: I'm honestly not convinced that's a win/nicer than what I have though.
02:17:34 <_tsk> super... thanks
02:17:49 <haasn> Chromium thinks https://raw.github.com/copumpkin/categories/master/Categories/Grothendieck.agda is in dutch and asks if you'd like to translate it
02:17:49 <Iceland_jack> _tsk: you need to use ScopedTypeVariables
02:18:53 <dor_> haasn: because of Grothendieck?
02:19:33 <arkeet> probably because of "het"
02:19:49 <arkeet> and "dom" maybe
02:20:15 <arkeet> mostly "het" though
02:21:13 <dor_> alexander__b: i would just make two stringTime definitions
02:21:32 <alexander__b> dor_: what do you mean?
02:22:10 <dor_> stringTime Nothing Nothing = "0:00"
02:22:22 <haasn> arkeet: yeah ‘Het’ most likely
02:22:33 <dor_> stringTime (Just t) (Just dt) = ...
02:22:50 <dor_> although you need to deal with the case where only one is Nothing
02:23:03 <alexander__b> dor_: ah
02:23:20 <dor_> you could move the first one to the bottom and make it stringTime _ _ = "0:00"
02:25:52 <alexander__b> dor_: so stringTime (Just t) (just dt) = dostuff; stringTime _ _ ="00:00:00" right?
02:26:10 <dor_> yep
02:26:30 <alexander__b> I mean the Nothing scenario never actually happens but heh
02:27:02 <dor_> maybe get rid of Maybe then ;)
02:27:32 <dor_> brb switching computers
02:27:33 <Iceland_jack> just get rid of Just
02:27:38 <zol> http://hastebin.com/hunobahite.sh -- I can't seem to get all of my functions into scope -- how can I get all functions into scope?
02:27:47 <tdammers> nothing to see here
02:28:29 <alexander__b> oh wait, yes of course it happens.
02:28:35 <haasn> stringTime = uncurry.view $ (_Just `beside` _Just).stuff `failing` (to.const) "00:00:00" -- or some other Monoid ideally, whoop whoop
02:28:39 <alexander__b> that was the point in the first place, duh. :-)
02:28:51 <haasn> okay never mind my definition
02:28:52 <alexander__b> haasn: that kind fo looks awful donotwant stuff.
02:28:56 <alexander__b> s/fo/of
02:28:56 <haasn> yours is simpler and cleaner :)
02:29:10 <alexander__b> I'm not a big fan of uncurry, flip or `on`, heh
02:29:17 <haasn> b-but mine is composable with other optics!
02:29:52 <alexander__b> ;-)
02:30:14 <alexander__b> I wonder if gloss would want this little prototype to add to their examples
02:30:58 <alpounet> alexander__b, you can email Ben, he's quite friendly so just ask him :-)
02:31:24 <alexander__b> alpounet: I thought I'd make an actual patch and email it to him. now I need to learn darcs first of course, but hey.
02:31:45 <alexander__b> I'm sure there's a darcs format-patch or equivalent. :-)
02:31:57 <alpounet> darcs is dead easy to use
02:32:08 <alpounet> (for most day-to-day tasks)
02:32:16 <fizruk> > fromMaybe "00:00:00" $ liftA2 (++) (Just "14") (Just ":18")
02:32:18 <lambdabot>   "14:18"
02:32:42 <fizruk> > fromMaybe "00:00:00" $ liftA2 (++) (Just "14") Nothing
02:32:44 <lambdabot>   "00:00:00"
02:32:44 <haasn> alexander__b: modify the file, record the change with ‘darcs rec’ to make a patch, send the patch using ‘darcs send’ (automatically formats and emails it to the given maintainer address) ;)
02:33:31 <alexander__b> I guess there's a good chance it will be rejected because of GPL. Haskell seems to be one of those BSD communities, heh.
02:35:21 <tdammers> well, you can't include GPL code in a BSD-licensed project
02:35:35 <donri> you could examples
02:36:21 <alexander__b> tdammers: I just found there was a LICENSE file
02:36:33 <alexander__b> I guess I'll release it under BSD
02:36:53 <alexander__b> he claims copyright on all the examples apparently
02:37:47 <tdammers> donri: point in case
02:38:18 <tdammers> stallman would probably disagree, but yeah
02:39:01 <donri> an example is just a separate program that links the bsd library
02:39:06 <donri> i don't think stallman would disagree
02:39:42 <alexander__b> donri: the examples are released under some lax licence
02:40:15 <tdammers> idk... stallman seems to use a very broad definition of "derived'
02:40:42 <alexander__b> with copyright to Ben. I'll just remove my header and let him have the copyright. it's hard to imagine Apple picking up my gloss example and use it to subjugate software users.
02:40:50 <pyr> morning
02:41:33 <pyr> my haskell tool is shaping up fast now but I'd like insight into how to handle "modularity"
02:42:08 <pyr> I want to have a tool where "modules" can be imported from a configuration file, which might bring in specific configuration parsing helpers
02:42:16 <pyr> I guess I have 2 questions:
02:42:38 <pyr> 1. is it easy / possible to retain the ability to distribute a built executable alongside optional "plugins/modules"
02:42:54 <ocharles> Feuerbach: I'm looking at this ingredients stuff again. It doesn't look particularly compositional.
02:43:10 <ocharles> Hmm, actually it doesn't matter
02:43:24 <pyr> 2. is it easy / possible for plugins to augment a parsec parser with specific instructions ?
02:43:29 <ocharles> I was going to say "I want to augment a test run with JUnit XML", but I guess I don't care about stdout/stderr so much at that point
02:44:39 <Feuerbach> ocharles: "It doesn't look particularly compositional" — what do you mean?
02:44:52 <pyr> I guess I could do away with 2. by building a somewhat more abstract AST and submitting that to plugin configuration functions and let them parse that
02:44:59 <alpounet> pyr, have you checked out "dyre" ? maybe a bit too strong, but hey.
02:45:27 <johnw> > "00:00:00" & upon (tail.tail).partsOf (biplate.filtered (== '0')) .~ "1234"
02:45:30 <lambdabot>   "00:12:34"
02:45:40 <pyr> alpounet: i will consider
02:49:22 <alexander__b> uhm so what's the equivalent of git format-patch origin/master? i.e. make .patches of all local patches
02:50:09 <srhb> alexander__b: I made a Hello World example in gtk2hs with an idlecallback if you're interested
02:50:15 <srhb> alexander__b: (Because I thought it'd be fun to learn)
02:50:17 <alexander__b> srhb: shur
02:50:43 <srhb> alexander__b: I basically just repurposed the Hello World from the gtk2hs tutorial, so no promises of prettiness :P
02:51:06 <lpaste> srhb pasted “gtk2hs with idle callback” at http://lpaste.net/95597
02:51:24 <alexander__b> alpounet: what's ben's actual email address? I can't seem to find it *anywhere*
02:51:34 <alexander__b> srhb: I'll check it out, thanks!
02:51:55 <alpounet> alexander__b, use the one on gloss' hackage page: http://hackage.haskell.org/package/gloss
02:52:14 <alexander__b> alpounet: but there is none?
02:52:17 <alexander__b> oh there
02:52:20 <alpounet> "Maintainer"
02:52:25 <alexander__b> it wasn't a link so I missed it
02:52:49 <srhb> alexander__b: Particularly I dislike the checking if the MVar is empty and then just dying, but I don't know how to work with callbacks really :P
02:52:57 <srhb> Perhaps someone can comment on that.
02:53:16 <srhb> In fact it may be better to simply just forget about using the GTK callbacks and just forking it off beforehand
02:53:33 <alexander__b> alpounet: would you happen to know darcs well-ish? well enough to know how to make a .patch?
02:54:23 <alpounet> alexander__b, darcs record after your changes, and then: darcs send -o foo.patch -- if i remember correctly
02:54:43 <alexander__b> ah. -o was what I was looking for.
02:54:58 <quicksilver> ocharles++ # 24 days of hackage
02:55:04 <alexander__b> thanks!
02:57:27 <lpaste> srhb annotated “gtk2hs with idle callback” with “gtk2hs with without callback” at http://lpaste.net/95597#a95598
02:57:43 <srhb> Much nicer.
02:58:25 <alexander__b> srhb: I'll look at it after lunch
02:58:33 <srhb> alexander__b: :)
02:58:45 <srhb> Just toying around with it myself.
02:58:48 <srhb> Not sure what the right method is.
02:58:54 <srhb> (But hey, they both compile!)
02:59:20 <alexander__b> srhb: I barely know basic haskell, but look at me. simon peyton jones has reviewed a paper I wrote, and I have a moderately popular arcade game. :-P
02:59:39 <srhb> alexander__b: I'm impressed! I've achieved nothing even close to that.
02:59:45 <srhb> In fact nothing is probably a good summary :P
03:00:40 <alexander__b> srhb: you are probably a lightyear ahead of me in terms of haskell skill though hehe
03:02:03 <Lethalman> eek priorityDefaultIdle -> def  :(
03:03:54 <Lethalman> srhb, glib has timeout functions if what you are doing is a timer
03:04:37 <srhb> Lethalman: I don't know what I'm doing! Well, I'm just trying to not have the loop burn too many cpu cycles when I only want to update once a full second has passed.
03:04:48 <Lethalman> srhb, use glibg timeout then
03:04:54 <Lethalman> not idles
03:04:54 <srhb> Alright :)
03:05:33 <Lethalman> srhb, timeoutAdd
03:05:54 <Lethalman> mh, haddock is missing permalinks
03:08:24 <srhb> Lethalman: The descriptions are super confusing as well
03:08:32 <Lethalman> srhb, what you mean?
03:08:34 <srhb> Is the second argument the interval? In what unit?
03:09:03 <Lethalman> srhb, ahah right
03:09:09 <Lethalman> srhb, well, I guess you have to check glib C docs ;)
03:09:16 <srhb> Lethalman: ._.
03:09:22 <Lethalman> srhb, yes the Int is the interval
03:09:34 <Lethalman> it calls you function every x seconds (or milliseconds)
03:09:42 <Lethalman> but most probably it's milliseconds
03:10:02 <srhb> The fact that there's no catchup also seems to make the forkIO-solution nicer
03:10:05 <srhb> Then I can handle it myself.
03:10:29 <Lethalman> srhb, catch up?
03:10:50 <srhb> Lethalman: As in, if the thread has been delayed too much, I don't want to wait a full x milliseconds before going again
03:11:25 <Lethalman> srhb, a thread delay won't be more precise than timeoutAdd
03:11:31 <Lethalman> timeoutAdd is precise enough, just test it
03:11:37 <srhb> Right. :)
03:11:55 <Lethalman> srhb, and there's written nowhere you have to wait twice for the function to be called, it's just a little delayed because there are other functions being called
03:12:29 <Lethalman> srhb, keep in mind timeoutAdd function gets called in the same thread of the gui already
03:12:35 <srhb> Aye.
03:12:36 <Lethalman> so it's blocking, do things as fast as you can
03:12:39 <Lethalman> :)
03:13:11 <Lethalman> but I always prefer timeoutAdd over sleeping in a thread, it works ok for every gui application
03:13:46 <srhb> Lethalman: Got it. Thanks :)
03:14:24 <Lethalman> srhb, also if you really wanted to your thread, there's no reason to use idleAdd :S
03:14:31 <Lethalman> just run a forkIO $ yourfunc
03:14:50 <Lethalman> call yourfunc time recursively and you're done without that ugly MVar
03:14:51 <srhb> Lethalman: Yes, it's in the annotation
03:15:06 <srhb> Lethalman: I realized the very same thing. :P
04:11:54 <lpsmith> ugh,  the moment you realize that the "binary" package just isn't going to cut it for your use case.
04:12:30 <Eduard_Munteanu> lpsmith: because it insists on big endian?
04:13:11 <lpsmith> Eduard_Munteanu, it does?
04:13:18 <Eduard_Munteanu> AFAIR.
04:13:57 <lpsmith> If it does, no biggie for me,  but my problem is I want to implement a log-following processor.
04:14:20 <lpsmith> And the log data has a few minor-ish binary components to avoid quoting things.
04:14:41 <lpsmith> I really need something like attoparsec,  but it doesn't have quick or convenient ways of dealing with binary data.    I did see attoparsec-binary,  but I wasn't particularly impressed with the implementation.   Still, it's probably plenty good enough for my purposes
04:14:57 <mangaba_leitosa> Eduard_Munteanu: ok I understood that I need something as you proposed because trying all combinations is too slow even for words of length 11 :-)
04:15:40 <mangaba_leitosa> Eduard_Munteanu: thanks for the idea, will try to implement calculating the combinations based on the word stats
04:16:05 <lpsmith> Eduard_Munteanu,  the problem is,  you read a chunk of log file,  and if you get an EOF then you wait on a filesystem notification that the file has been written to.   (and thus you can re-try the read and it won't come back eof again.)
04:16:29 <Eduard_Munteanu> mangaba_leitosa: it would help to know what you're trying to do
04:16:47 <lpsmith> Doing that with binary would seem to be a mighty kludge,  whereas it's fairly straightforward with attoparsec.
04:17:00 <Eduard_Munteanu> lpsmith: attoparsec can deal with incremental input
04:17:05 <lpsmith> exactly
04:17:24 <lpsmith> but attoparsec is missing efficient primitives for reading in binary data.
04:17:39 <Eduard_Munteanu> lpsmith: technically you could do it with binary too, with lazy IO
04:17:45 <lpsmith> no
04:17:55 <mangaba_leitosa> Eduard_Munteanu: find a pattern that will match the maximum number of words of length len with distance <= max_distance
04:18:10 <lpsmith> because if you just slurp the file,  your lazy bytestring gets terminated the first eof I see, IIRC
04:18:25 <lpsmith> I suppose I could write my own lazy IO routine
04:18:50 <Eduard_Munteanu> lpsmith: you could run 'tail -f' and read its output
04:19:18 <lpsmith> I already have proof-of-concept log following programs running,  with my linux-inotify package.
04:19:22 <mangaba_leitosa> Eduard_Munteanu: ... and if there are more than one pattern satisfying the criteria, find all of them
04:19:30 <lpsmith> I'd rather not, for a couple of reasons.
04:19:51 <lpsmith> not to mention that trying to get tail -f to work with log rotation is going to be tricky
04:19:57 <Eduard_Munteanu> mangaba_leitosa: what do you mean "match"? Exact match, or up to a distance?
04:20:06 <lpsmith> basically I'd still have to use linux-inotify.
04:20:14 <mangaba_leitosa> Eduard_Munteanu: match = distance(pattern, word) <= max_distance
04:20:37 <Eduard_Munteanu> lpsmith: there's 'tail -F' if the file can disappear
04:20:43 <Lethalman> lpsmith, just verify the inode of the file hasn't changed
04:20:47 <Eduard_Munteanu> Or not exist in the first place.
04:20:49 <mangaba_leitosa> Eduard_Munteanu: where max_distance is given as input
04:20:50 <Lethalman> lpsmith, that solves log rotation finely
04:21:06 <Lethalman> or tail -F
04:21:19 <Eduard_Munteanu> -F     same as --follow=name --retry
04:22:25 * hackagebot ex-pool 0.1.0 - Another fork of resource-pool, with a MonadIO and MonadCatch constraint  http://hackage.haskell.org/package/ex-pool-0.1.0 (KimAltintop)
04:23:09 <lpsmith> and kill tail -f as soon as it actually has reached the end.
04:23:09 <lpsmith> So really,  it hasn't bought me much
04:23:50 <lpsmith> I hacked up a patch to attoparsec that is a better implementation of attoparsec-binary,  but as I'm currently using vincent's cpu package for endianess conversion and cpu isn't part of the haskell platform whereas attoparsec is.
04:24:19 <radicality> Hi. What does it mean when there is a 'type' definition but without an = symbol ? I'm looking at the YesodAuth typeclass ( http://hackage.haskell.org/package/yesod-auth-1.2.3/docs/src/Yesod-Auth.html#AuthId ), and there is a "type AuthId master
04:24:20 <radicality> " but without an equal sign. why is that?
04:24:53 <jorgno> Are anyone here familiar with the Gnuplot package? If so is there a way to create a bar chart with Y error bars?
04:24:53 <Eduard_Munteanu> radicality: that's an associated type family declaration
04:25:28 <Eduard_Munteanu> radicality: it's a type synonym associated with a class, and each instance can define it
04:25:33 <hpc> radicality: the type family doesn't have a definition for the same reason getAuthId doesn't either
04:25:38 <hpc> radicality: it's defined with the instance
04:25:58 <hpc> "instance YesodAuth Foo where type AuthId master = Int; ...
04:26:50 <radicality> Ah I see. Thanks, will read up a bit on type families
04:28:10 <Eduard_Munteanu> mangaba_leitosa: so it seems 0 <= max_distance <= length(word), as each unit of distance comes from a changed base.
04:28:38 <mangaba_leitosa> Eduard_Munteanu: right
04:31:30 <lpsmith> Eduard_Munteanu,  what do you mean that binary insists on big-endian?   There primitives to read/write either endian-ness,  but if you go through the typeclass,  get and put both assume big endian (network byte order).
04:31:43 <Eduard_Munteanu> lpsmith: ah, yeah, that
04:53:18 <Ghoul_> although afaik there are  BE and LE wrappers you can use
04:54:54 <Ghoul_> uh, nvm. binary doesn't instantiate them
04:55:10 <donri> where are you finding these wrapperS?
04:55:45 <Ghoul_> http://hackage.haskell.org/package/typesafe-endian-0.1.0.1
04:55:56 <Ghoul_> & http://hackage.haskell.org/package/data-endian
04:56:29 <donri> oh separate packages
04:56:41 <Ghoul_> and theres even this
04:56:41 <Ghoul_> http://hackage.haskell.org/package/storable-endian
04:57:00 <Ghoul_> the BE and LE constructors on the last one would be perfect for making binary of strange endians automatic and easy
04:57:18 <Ghoul_> one thing I noticed writing a server for minecraft was that the endians were all wrong and it was EXTREMELY verbose to do anything :(
04:58:10 <donri> i'm not sure you could have a generic Binary a => Binary (LE a) though
04:58:29 <Ghoul_> why not
04:58:49 <alexander__b> srhb: ping
04:58:54 <Ghoul_> class Endian a where
04:58:54 <donri> i think you'd need to change Put/Get to include a Reader Endianness or something
04:59:31 <Ghoul_> unendian :: whatever
04:59:47 <Ghoul_> instantiate that on all the wrapper types, do the binary instantiation, and then just use unendian everywhere to unpack stuff
05:00:25 <Ghoul_> I don't think you need to use a reader or anything
05:00:30 <Ghoul_> it should be pretty straightforward
05:04:04 <Ghoul_> donri: what about this
05:04:32 <Ghoul_> instance Binary a => Binary (a, LE) where
05:04:36 <Ghoul_> (can you even do that?)
05:06:49 <osa1> where can I learn more about `unsafe` keyword used in `foreign import ccall unsafe ...` in FFI ?
05:08:41 <Feuerbach> osa1: e.g. the Haskell 2010 report, FFI section
05:10:51 <alexander__b> http://lpaste.net/5081882029922975744 how on earth would I set a startTime in buttonSwitch and use it in updateLabel? (yes, these things will be more modular in the future, but right now I'll settle for "working")
05:11:35 <merijn> osa1: unsafe means The call is made "unsafel" i.e. you're 1) not allowed to call back into haskell 2) haskell runtime can't interrupt the call
05:11:48 <merijn> osa1: So if the call blocks/hangs for a long time, your program can get stuck
05:12:13 <osa1> in case of `safe` how does Haskell runtime interrupt the call?
05:12:22 <osa1> I mean what happens when call is interrupted
05:12:24 <merijn> osa1: pthread signals most likely
05:12:39 <osa1> so an exception is thrown?
05:12:46 <merijn> I'm not sure about all the details, you'd want the Haskell 2010 report
05:12:51 <osa1> okay
05:12:53 <osa1> I'm currently reading it
05:12:58 <merijn> osa1: There's no such thing as "exceptions" on this level
05:13:06 <osa1> but it's only one paragraph and I'm afraid it doesn't mention that details
05:13:13 <merijn> Exceptions are a language construct and they don't exist in C
05:13:28 <donri> Ghoul_: it can be done easily yes, but not generically ie. a once-and-for-all LE instance
05:13:37 <osa1> "If it does, the system behaviour is undefined" <-- callbacks in unsafe mode
05:13:57 <osa1> merijn: of course. I mean what happens in Haskell when a FFI call is interrupted by Haskell RTS
05:14:19 <Ghoul_> actually, now I see what you mean
05:14:48 <donri> Ghoul_: if my Binary instance does putWord16be you have no way of knowing i didn't do putWord32be
05:14:54 <donri> you can't generically transform it to LE
05:15:08 <donri> without making Builder/Get/Put track the endianness
05:16:04 <merijn> osa1: Oh, interruption is only available when explicitly enabled I just saw in the docs
05:16:25 <osa1> merijn: which part?
05:16:35 <osa1> can't see it here http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
05:17:07 <merijn> 8.1.4. Interruptible foreign calls
05:18:12 <osa1> merijn: um .. where? http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1500008.1
05:18:16 <donri> https://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html#ffi-interruptible
05:18:31 <osa1> ah you're referring to ghc docs
05:28:10 <Eduard_Munteanu> mangaba_leitosa: let c(i, b) be the number of words matching base 'b' in position 'i', and N the number of words you have.
05:28:50 <Eduard_Munteanu> mangaba_leitosa: if c(i, b) < N, then the max distance you get with that base is 1.
05:29:21 <Eduard_Munteanu> mangaba_leitosa: and if c(i, b) = N, the max distance wrt that position is 0.
05:30:32 <Eduard_Munteanu> mangaba_leitosa: since dist(pat, word) = ∑_i dist(pat[i], word[i]) <= max_distance, you can minimize it by adding those bases that give you a 0 max distance in a given position.
05:32:33 <Lethalman> ∑ᵢ
05:33:34 <Eduard_Munteanu> mangaba_leitosa: in other words, dist(pat[i], w[i]) is 0 iff all words match pat[i] in i.
05:33:43 <Eduard_Munteanu> Which makes it quite simple.
05:33:48 <Lethalman> ≤
05:34:05 <Eduard_Munteanu> Lethalman: hm?
05:34:28 <Lethalman> Eduard_Munteanu, just using some unicode chars for your expression above :P
05:34:54 <Eduard_Munteanu> For some reason \leq doesn't show up in vim here, but it does in irssi.
05:35:09 <Eduard_Munteanu> Huh... no, it doesn't if I type it myself, hm.
05:35:36 <Eduard_Munteanu> Lethalman: can you see ' '?
05:36:21 <Lethalman> ' '
05:36:32 <Eduard_Munteanu> I see ' '.
05:36:46 <Eduard_Munteanu> As in space.
05:36:51 <Lethalman> yes
05:37:38 <Eduard_Munteanu> Hm, it works if I type it in Firefox and copy it here... ≤
05:37:47 <moops> @hoogle Maybe a -> String -> Either String a
05:37:47 <lambdabot> No results found
05:37:51 <moops> really?
05:38:06 <Eduard_Munteanu> :t eitherToMaybe
05:38:08 <lambdabot> Not in scope: `eitherToMaybe'
05:38:12 <Lethalman> @hoogle Maybe a -> b -> Either b a
05:38:13 <Eduard_Munteanu> @hoogle eitherToMaybe
05:38:13 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
05:38:13 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
05:38:13 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
05:38:13 <lambdabot> No results found
05:38:28 <Lethalman> hayoo is down :S
05:39:04 <moops> ah its in Either Utils
05:39:06 <moops> thanks :)
05:39:27 <Lethalman> maybeToEither though
05:39:38 <Eduard_Munteanu> Is there a better way to type unicode than SCIM? xcompose is awkward if you don't know the combos
05:39:42 <Lethalman> but it requires MonadError
05:40:21 <Lethalman> ah Either is monaderror
05:40:49 <tdammers> you can define your own combos
05:41:02 <Eduard_Munteanu> tdammers: which is what I'm trying to avoid, actually :)
05:41:30 <Eduard_Munteanu> tdammers: I just want a big selection, and some popup that lets me see selections as I type would be great
05:41:39 <haasn> Eduard_Munteanu: fcitx lets you pop up a search box in which you can search for sym names etc.
05:41:55 <tdammers> Eduard_Munteanu: that sounds terribly GUI-ish
05:41:55 <haasn> that sounds exactly like what you want
05:42:00 <tdammers> :x
05:42:00 <mangaba_leitosa> Eduard_Munteanu: thanks, analyzing :-)
05:43:03 <Eduard_Munteanu> tdammers: SCIM pops up a small window that shows selections as I type.
05:43:09 <Eduard_Munteanu> It goes away on its own.
05:43:31 <tdammers> idk, never used it
05:43:45 <tdammers> standard compose sequences cover my needs, pretty much
05:43:52 <tdammers> although snowman would be a nice character to have
05:44:00 <t7> lol
05:44:06 <quchen> ☃
05:44:49 <haasn> I have ☃ on what used to be my F12 key
05:44:56 <haasn> I think it's more useful than my F12 key.
05:45:03 <tdammers> yes, probably
05:45:09 <quchen> haasn and his keyboard ♥
05:45:16 <tdammers> especially if you want to use it in vim keybindings
05:45:16 <donri> michael snowman?
05:45:26 <donri> why not snowberg
05:45:33 <tdammers> :map ☃ :make<CR>
05:46:53 <Eduard_Munteanu> haasn: that looks similar to SCIM in a few ways... any idea if it has a math / latex table by default?
05:47:11 <haasn> Eduard_Munteanu: no idea. fcitx is known for how easily you can extend it with plugins
05:47:13 <Eduard_Munteanu> I don't mind stealing one from Agda if it's easy to make though.
05:47:22 <Eduard_Munteanu> Hm, cool, thanks.
05:47:32 <haasn> I haven't looked myself though, I wanted to use it for spell checking but that goes against its design philosophy
05:47:45 <haasn> ie. I wanted it to highlight words I'd already typed, rather than just show hints on words I'm currently typing
05:55:34 <skypers_> hi
05:56:23 <skypers_> I just discovered the use of (<>~)
05:56:27 <skypers_> kinda powerful :)
05:56:48 <skypers_> btw, what is the over way to write a & selector .~ aValue?
05:56:50 <skypers_> with over?
05:57:15 <skypers_> over a selector .~ aValue
05:57:15 <skypers_> ?
05:58:13 <Eduard_Munteanu> I'm encoding types of a foreign language in Haskell as  data Type = B | T | ...   and   data Value :: Type -> * where ...  (T has no relation to ⊤)
05:58:36 <Eduard_Munteanu> I want B to be a subtype of T, and I can think of a few variants.
05:59:16 <Eduard_Munteanu> I can have a constructor for Value that goes like: Sub :: (Subtype a b) => a -> Value b
05:59:24 <donri> skypers_: "set"?
05:59:25 <donri> :t set
05:59:26 <lambdabot> ASetter s t a b -> b -> s -> t
05:59:28 <Eduard_Munteanu> Do you have a better idea?
05:59:31 <donri> :t flip over id
05:59:32 <lambdabot> Setting (->) s t a a -> s -> t
05:59:53 <donri> :t flip over . const
05:59:54 <lambdabot> a -> Setting (->) s t b a -> s -> t
06:00:04 <Eduard_Munteanu> I could make Subtype a GADT but I prefer to make it easy to write values.
06:00:11 <skypers_> :t over
06:00:12 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
06:00:24 <Eduard_Munteanu> Er, T <: B.
06:00:56 <jmcarthur_mobile> Eduard_Munteanu: subtyping is hard. Whatever is most explicit and relies on the least magic, that is probably what you should do.
06:00:57 <skypers_> Setting?
06:01:02 <skypers_> @hoogle Setting
06:01:02 <lambdabot> No results found
06:01:46 <Eduard_Munteanu> jmcarthur_mobile: well, I aim to represent that language without much headaches.
06:02:08 <alpounet> > over _1 (_2 .~ 4) $ (("hello", 0), 1) -- skypers_
06:02:10 <lambdabot>   (("hello",4),1)
06:02:37 <skypers_> thank you alpounet
06:02:56 <skypers_> couldn’t you make put the _2 as composed with _1?
06:02:57 <skypers_> like
06:03:03 <donri> > set (_1 . _2) 4 (("hello", 0), 1)
06:03:05 <lambdabot>   (("hello",4),1)
06:03:11 <Eduard_Munteanu> My B is a boolean, really.
06:03:16 <donri> > over (_1 . _2) (const 4) (("hello", 0), 1)
06:03:18 <lambdabot>   (("hello",4),1)
06:03:19 <skypers_> yeah, like that
06:03:51 <skypers_> I think I need to learn what a Profunctor is
06:03:53 <skypers_> plus, Setting.
06:03:55 <jmcarthur_mobile> Subtyping: Headache for language implementor. Headache for language user. Pick two.
06:03:58 <alpounet> the latter is uglier IMO because of the const, i'd recommend using 'set'
06:04:23 <Eduard_Munteanu> I suspect I could also do  Y :: (Subtype s B) => Value s; N :: (Subtype s B) => Value s
06:04:30 <donri> yeah, just to show that set is the same as over and const
06:04:41 <alpounet> right
06:04:41 <Eduard_Munteanu> jmcarthur_mobile: heh... it's not my language though.
06:04:48 <skypers_> ok
06:04:49 <skypers_> thank you
06:04:51 <skypers_> and hm
06:05:02 <skypers_> I have a type that wraps a []
06:05:09 <Eduard_Munteanu> jmcarthur: I'm parsing Linux kconfig files and they've got a notion of bool and tristate, where tristate = y / m / n
06:05:09 <skypers_> in order to concat it to something
06:05:12 <skypers_> I got that:
06:05:28 <skypers_> mgr & matCach <>~ [m]
06:05:43 <skypers_> I don’t know whether it’s the best way to deal with Monoid and lens though
06:05:55 <jmcarthur_mobile> Not sure my last message got through.
06:05:57 <jmcarthur_mobile> Subtyping: Headache for language implementor. Headache for language user. Pick two.
06:06:02 <jmcarthur_mobile> :)
06:06:27 <Eduard_Munteanu> I must've missed it because of the headache. :P
06:07:03 <Disgrntld> hello, noob question: where can I find the source for filterM?
06:07:15 <Eduard_Munteanu> @index filterM
06:07:15 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:07:22 <Eduard_Munteanu> Gr.
06:07:31 <Eduard_Munteanu> Oh, there you go.
06:07:31 <Adeon> @src filterM
06:07:31 <lambdabot> Source not found. My brain just exploded
06:07:39 <Adeon> poor brain
06:07:45 <Eduard_Munteanu> Disgrntld: just hoogle for Control.Monad and look at the source
06:07:51 <alpounet> Disgrntld, http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#filterM
06:07:52 <Disgrntld> ok, thanks guys
06:07:54 <donri> skypers_: seems alright. maybe you could use Cons though
06:07:54 <Disgrntld> awesome
06:08:25 <skypers_> btw, I’m looking for a good way to deal with mutable values, like this scenario: I have two types, Foo, and FooManager. I got a registerFoo :: Foo -> FooManager -> (Foo,FooManager), that alters both the type. It adds the former in a list inside the second one and modifies a part of the Foo using FooManager’s internals. Is the (Foo,FooManager) the best idea to deal with?
06:08:58 <skypers_> s/adds/pushes
06:09:08 <jmcarthur_mobile> Eduard_Munteanu: honestly I would just make them two different types and provide a function to convert bools to tristates explicitly
06:09:12 <donri> skypers_: although xs <> [x] is slow with list, you want to use x:xs and reverse the order
06:09:24 <skypers_> hm
06:09:27 <skypers_> yeah
06:09:43 <skypers_> so mgr & matCache %~ ((:) m)
06:09:49 <skypers_> right?
06:10:29 <donri> (m:)
06:10:33 <mangaba_leitosa> Eduard_Munteanu: I'm going to try applying calculating these stats and see what happens. I don't expect that c(i, b) == N will never occur, though
06:10:37 <skypers_> for my first issue, I may want using State or StateT
06:10:48 <skypers_> but for both value, I don’t really know whether it would convenient
06:10:52 <skypers_> values*
06:11:08 <mangaba_leitosa> Eduard_Munteanu: "I don't expect that it ever occur" even
06:11:13 <mangaba_leitosa> Eduard_Munteanu: "I don't expect that it will ever occur" even
06:11:37 <Eduard_Munteanu> mangaba_leitosa: it would be quite common for small word sets like your examples, possibly the reason you concluded your criteria is relevant.
06:11:57 <mangaba_leitosa> Eduard_Munteanu: right, but this was just an example :_)
06:12:40 <mangaba_leitosa> Eduard_Munteanu: it's not going to be applied for sets where a single common pattern can match all (or most of) the words
06:14:11 <mangaba_leitosa> Eduard_Munteanu: in real application, these example set would be a subset of a larger set of including words unrelated to the pattern
06:14:58 <skypers_> alpounet: btw, long time no see ;)
06:16:09 <mangaba_leitosa> Eduard_Munteanu: however, the frequency of words matching the pattern will be high, and that's the task -- identify frequently repeated similar words
06:17:12 <Eduard_Munteanu> mangaba_leitosa: well, then don't use a max distance.
06:18:20 <mangaba_leitosa> Eduard_Munteanu: then I'll need patterns for all possible distances, which also makes sense
06:18:22 <Eduard_Munteanu> mangaba_leitosa: would you prefer it matches words statistically, or matching the largest subsequence of a word perhaps?
06:18:46 <mangaba_leitosa> Eduard_Munteanu: largest subsequence
06:22:03 <Eduard_Munteanu> mangaba_leitosa: if you group words by Levenshtein distance such that any two words in a group have the same distance? You have to decide. :)
06:22:35 <Eduard_Munteanu> Presumably lower distance => smaller group.
06:22:55 <Eduard_Munteanu> The criteria has to be sorted out.
06:23:35 <Eduard_Munteanu> (e.g. maybe count times distance)
06:24:20 <notdan> Hi
06:24:32 <mangaba_leitosa> Eduard_Munteanu: yes, it seems like I need to group the words somehow. but for example [AACAA, ATAAA, AAACA, AAAGA] would go to the group distance=2, wheres the common pattern AAAAA matches them with distance == 1
06:24:48 <Eduard_Munteanu> mangaba_leitosa: what is your application, btw? Identifying small variations of a gene?
06:26:25 <mangaba_leitosa> Eduard_Munteanu: identifying the so called 'DNA-boxes' (frequently occuring sequences of nucleotides, but the sequences can have mismatches)
06:28:36 <Eduard_Munteanu> mangaba_leitosa: you seem to be doing it the other way around... finding candidates for them, rather than identifying a particular sequence occurs up to an error.
06:29:01 <mangaba_leitosa> Eduard_Munteanu: but we don't know what the correct sequence is
06:29:02 <merijn> Isn't dynamic programming the usual algorithm for identifying DNA sequence matches with shifts/deletions?
06:29:30 <mangaba_leitosa> merijn: yes, like an algorithm for calculating Levenshtein's distance
06:29:35 <notdan> can someone please explain to me why is (.. ((a ++ a) ++ a) .. ++ a) is way worse than (a ++ .. (a ++ a) ..)? I figured that assuming that |a| = n and we are doing m concatenations the complexity of the former is (n + 2n + .. + mn) = O(nm^2), while the complexity of the former is (n + n + .. + n) = O(nm), is this correct?
06:30:01 <notdan> (I am reading about Codensity monad and "CPS"-style optimizations, having a hard time understanding this stuff)
06:30:12 <Eduard_Munteanu> notdan: because the right-associative concatenation only occurs after you've read the left operand
06:30:39 <Eduard_Munteanu> notdan: whereas the left associative one starts concatenating immediately
06:31:26 <merijn> notdan: If the ordering is right concatenation can fuse to O(1)
06:31:28 <notdan> so you mean the right-associative version performs "linearly" on the first n elements, while the left-associative versions performs as usual?
06:31:35 <notdan> as usual = power of 3
06:32:05 <merijn> notdan: It's impossible to see without seeing how the code using the concatenation works
06:32:20 <merijn> notdan: "map foo (a ++ b)" <- concatenation is O(1) here
06:32:28 <skypers__> http://lpaste.net/3080931950119092224 << any idea with my two issues in here? (do I should use State or StateT? and how can which lists will be called length on?
06:32:40 <Eduard_Munteanu> notdan: right (++) is productive, so you can build it as you consume it.
06:33:14 <Eduard_Munteanu> notdan: left (++) is accumulative, so you have to do the O(n) traversal as you apply it.
06:33:18 <notdan> Well, I am not talking about fusing right now. I am trying to understand codensity monad http://comonad.com/reader/2011/free-monads-for-less/ http://www.iai.uni-bonn.de/~jv/mpc08.pdf
06:33:29 <notdan> so I want to simply things for now and not care about fusing
06:34:05 <Eduard_Munteanu> @src concat
06:34:05 <lambdabot> concat = foldr (++) []
06:34:14 <Eduard_Munteanu> @src foldr
06:34:14 <lambdabot> foldr f z []     = z
06:34:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:34:51 <notdan> Right, so concat is efficient in the presense of laziness
06:35:18 <Eduard_Munteanu> notdan: yeah, only in the presence of non-strictness.
06:35:50 <Eduard_Munteanu> notdan: for example, you can right-concat an infinite list of lists just fine
06:35:57 <Eduard_Munteanu> notdan: but you can't left-concat it.
06:37:12 <notdan> makse sense, thanks
06:37:36 <Eduard_Munteanu> Same reason why lazy naturals would be defined with a right-associative plus.
06:38:59 <brainacid> hello room
06:40:23 <Eduard_Munteanu> (well assuming you increase the first argument and decrease the second)
06:41:13 <skypers__> no one for my issues?
06:45:56 <skypers__> ok about the length issue, I just figured it out
06:46:09 <skypers__> for using State, it mightn’t be usefull :)
06:46:11 <skypers__> -l
06:51:22 <Eduard_Munteanu> Hm, can you use a type synonym as a result type in a GADT constructor declaration?
06:51:37 <skypers__> GADT?
06:51:40 <skypers__> General ADT?
06:51:46 <Eduard_Munteanu> Generalized.
06:51:52 <skypers__> hm
06:52:26 <Eduard_Munteanu> skypers__: http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype‎
06:52:47 <skypers__> I’m reading this one http://en.wikibooks.org/wiki/Haskell/GADT
06:52:56 <skypers__> I’ll check out yours later
06:52:57 <skypers__> :)
06:52:59 <notdan> http://lpaste.net/95602 am I right to say that given a balanced tree of height 'n' and f \in O(1), subst t f \in O(2^n), and hence fullTree n is \in O(n2^n)?
06:55:02 <skypers__> oh
06:55:06 <skypers__> GADTs are nice :)
06:55:47 <remdezx> Hello. I'm new to haskell's protocol buffers. I have code similar to this from paragraph "Nested Extensions" in here: http://www.indelible.org/ink/protobuf-polymorphism/ . I have serialized Cat object, how can I get it from Animal instance?
06:56:34 <remdezx> I'm using also hprotoc ofc
06:57:57 * hackagebot reform 0.2.1 - reform is an HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.2.1 (JeremyShaw)
06:57:59 * hackagebot reform-hsp 0.2.2 - Add support for using HSP with Reform  http://hackage.haskell.org/package/reform-hsp-0.2.2 (JeremyShaw)
06:58:12 <merijn> skypers__: GADTs rock :)
06:59:27 <skypers__> I think I lack experience and that makes me blind to how I could use GADTs :)
06:59:59 <bennofs> Can I find examples using ContT/Cont somewhere? I think I understand the implementation of Cont, but what would one use this for?
07:00:02 <merijn> skypers__: I think they're a good tool to know about, because when you hit a problem that requires them you think "oh, right! GADTs"
07:00:17 <skypers__> yeah :)
07:00:20 <skypers__> I know them
07:00:33 <skypers__> but I won’t think of them immediately imho
07:00:50 <skypers__> merijn: maybe you can help me with my questionning
07:01:10 <Eduard_Munteanu> notdan: subst itself is O(n 2^n) I think.
07:01:20 <skypers__> I have a function that takes two values A and B, alters both and returned the altered values as a (A,B)
07:01:23 <merijn> skypers__: I use them for things like typesafe tagging like "data RecType = Control | Other; data Record (a :: RecType) where ControlRec :: ?? -> Record Control; OtherRec :: ?? -> Record Control" (using DataKinds, obviously)
07:01:37 <merijn> eh
07:01:43 <skypers__> I plan to call that function A LOT, so I’ll be creating temporaries
07:01:44 <skypers__> like hm
07:01:45 <merijn> Second should be Record Other, obviously
07:02:04 <skypers__> let (newA,newB) = theFunction a b
07:02:16 <skypers__>     (newA1,newB2) = theFunction newA newB
07:02:18 <skypers__> and so on
07:02:26 <merijn> Looks like State to me
07:02:27 <skypers__> maybe State here could help
07:02:28 <skypers__> yeah
07:02:38 <skypers__> State (A,B) ()
07:02:58 <skypers__> but hm
07:02:59 <Eduard_Munteanu> notdan: with k the number of nodes, lookup is O(log k), so looking up all nodes is O(k log k), unless you assume the traversal is O(k)?
07:03:07 <skypers__> it’s not exactly State
07:03:15 <merijn> skypers__: Why not?
07:03:18 <skypers__> I can’t call modify with A and B
07:03:27 <skypers__> because the function is A -> B -> (A,B)
07:03:34 <skypers__> not (A,B) -> (A,B)
07:03:40 <merijn> :t curry
07:03:43 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:03:46 <merijn> eh
07:03:47 <bennofs> :t uncurry
07:03:48 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:03:49 <merijn> :t uncurry
07:03:49 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:03:55 <merijn> :t modify . uncurry
07:03:56 <lambdabot> MonadState (a, b) m => (a -> b -> (a, b)) -> m ()
07:03:56 <skypers__> from Data.Tuple?
07:04:08 <merijn> skypers__: Pretty sure uncurry is in prelude
07:04:08 <bennofs> @index uncurry
07:04:08 <lambdabot> Data.Tuple, Prelude
07:04:15 <skypers__> nice!
07:04:17 <skypers__> love you!!
07:04:17 <skypers__> :)
07:04:31 <skypers__> btw, does such a function have a runtime cost?
07:04:34 <skypers__> like flip
07:04:36 <skypers__> or hm
07:04:38 <skypers__> id?
07:04:42 <merijn> skypers__: Hard to say
07:04:44 <skypers__> ($), and so on
07:04:57 <merijn> skypers__: It is highly likely GHC optimises a lot of this stuff away
07:05:15 <skypers__> even without -O?
07:05:18 <merijn> skypers__: I wouldn't worry about it, write it, test it, profile it, optimise based on profiling
07:05:27 <skypers__> sure :)
07:05:38 <skypers__> it was just a matter of curiosity
07:06:19 <skypers__> State is a really REALLY nice Monad
07:06:43 <Eduard_Munteanu> Grr... looks like I can't use type synonyms as constructor types for GADTs. :(
07:12:38 <bartavelle> If I have [IO (Either a b)], is there a nice combinator that will run the IO action until I get a Right, with type : [IO (Either a b)] -> IO (Maybe b) ?
07:13:01 <bartavelle> (that will stop at the first correct value)
07:13:03 <merijn> bartavelle: Maybe in monad-loops?
07:13:06 * bartavelle looks
07:13:37 <merijn> I should write a script that automatically replies "Maybe monad-loops?" to any monad combinator question :p
07:13:43 <bartavelle> heh
07:13:49 <bartavelle> untilJust might fit the bill
07:14:09 <bartavelle> well not really
07:14:11 * bartavelle sighs
07:14:11 <zomg> merijn: you'd think someone would've already written an AI to solve questions
07:14:35 <zomg> merijn: 'cause there's like a whole category of them which are sorta easy to just answer right away
07:15:14 <merijn> bartavelle: Should be easy to write something using the stuff in monad-loops, though
07:15:24 <bartavelle> yes
07:16:31 <merijn> bartavelle: firstM with "fmap isRight"?
07:16:50 <merijn> oh, no that doesn't typecheck
07:16:55 <merijn> But something similar to that, anyway
07:17:25 <merijn> Actually, maybe "fmap isRight" would typecheck
07:17:38 <merijn> oh, but that'd return the wrong result type
07:17:43 <bartavelle> yes
07:20:56 <merijn> I think haskell's main flaw is making people to lazy to program :p
07:21:01 <narens> is it possible to only perform compilation when using cabal build? (i.e. i would like to skip the linking step)
07:21:13 <merijn> "Hey, I'm looking for something of this type. Does that exist yet?"
07:21:22 <bartavelle> the problem is, it is often true
07:21:31 <merijn> narens: I don't think so, why do you want that?
07:22:16 <narens> merijn: linking takes long on my slow comp... and everytime I use cabal build I just want to check for compile errors and not build the whole executable
07:22:49 <tomejaguar> narens: How about -fno-code?
07:22:55 <narens> merijn: mostly I use ghci for that reason.. but sometimes external C lib links fails with ghci
07:23:04 <tomejaguar> That will type check only.
07:23:25 <tomejaguar> I use 'cabal build --ghc-options=" -fforce-recomp -fno-code -Wall"'
07:25:10 <narens> tomejaguar: that still does the linking
07:25:47 <narens> tomejaguar: actually, it doesn't seem to....
07:26:45 <remdezx> Hi! I asked a question before, but anyone responsed. Have anybody used protocol buffers with message extensions and could provide me example how to manage with them in Haskell?
07:26:49 <tomejaguar> narens: It should be really, really fast.  About a second to type check one thousand lines say.  Maybe quicker.
07:27:08 <narens> tomejaguar: it is... thanks. I'm just looking up the doc for that option
07:27:46 <tomejaguar> narens: It does type checking only.  If it passes '-fno-code' it's hard to imagine it will fail to compilee.
07:28:41 <narens> tomejaguar: "-fno-code
07:28:41 <narens> Omit code generation (and all later phases) altogether. Might be of some use if you just want to see dumps of the intermediate compilation phases."
07:28:50 <narens> cool
07:29:09 <tomejaguar> Yes I was very pleased to find that option :)
07:30:14 <haasn> that's the complexity of prime factorization as implemented in arithmoi?
07:30:17 <haasn> what's*
07:30:25 <South> I have a quick question!
07:30:34 <South> (Also, hello everyone!)
07:31:11 <haasn> oh, most likely exponential
07:31:33 <South> So, in Text.Parsec.Token, there's a function reservedOp with type reservedOp :: String -> ParsecT s u m ()
07:32:07 <South> But, I have the latest version of parsec installed, and on my system it has type reservedOp :: GenParser s u m -> String -> ParsecT s u m ()
07:32:30 <South> and I can't get one of the sample programs in Parsec to work properly...any ideas what might be happening here? I'm really confused.
07:32:36 <Eduard_Munteanu> South: it's a record field
07:32:51 <South> Eduard_Munteanu: What does that mean?
07:33:21 <South> Eduard_Munteanu: I'm having issues with the types, I'm trying to compile the example at the bottom of this page http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Expr.html
07:33:28 <South> But getting a type mismatch
07:33:33 <Eduard_Munteanu> South: data GenParser s u m = ... { ... reservedOp : String -> ParsecT s u m () ... }
07:33:39 <Eduard_Munteanu> s/:/::/
07:33:46 <mm_freak> haasn: exponential in the smallest prime (ECM)
07:34:12 <South> Eduard_Munteanu: Ooooh okay
07:34:44 <Eduard_Munteanu> South: you just have to give it your GenParser
07:34:54 <haasn> mm_freak: ah, okay
07:34:59 <Eduard_Munteanu> South: which you build using Text.Parsec.Token stuff
07:35:11 <South> Eduard_Munteanu: Makes sense, I'll try that out
07:35:14 <South> Eduard_Munteanu: Thanks!
07:36:02 <Eduard_Munteanu> South: you can use  haskell :: TokenParser st  from Text.Parsec.Language to get going
07:36:27 <mm_freak> i wonder what happened to daniel fischer
07:36:36 <skypers__> what’s about him?
07:36:48 <mm_freak> his last commit is from 2012 and apparently he didn't see my feature request
07:36:58 <mm_freak> (arithmoi)
07:37:07 <South> Eduard_Munteanu: Thanks!
07:37:15 <haasn> mm_freak: he has more recent updates on his bitbucket.org profile
07:37:19 <skypers_> does he have an email address?
07:37:42 <haasn> 2013-04-10
07:37:54 <mm_freak> yeah, indeed
07:38:03 <mm_freak> i think my request is younger
07:38:08 <mm_freak> skypers_: sure
07:38:35 <skypers_> you may want to email him something
07:38:49 <skypers_> I don’t like saying that but if he got injured in something…
07:39:07 <mm_freak> @seen dafis
07:39:07 <lambdabot> dAFi5
07:39:27 <skypers_> what is @seen?
07:39:27 <Eduard_Munteanu> Huh... that gets corrected to 'leet'? :)
07:39:35 <haasn> I wonder if there's a more efficient way to calculate: map divisorCount [1..n -- by reusing past results
07:39:37 <Eduard_Munteanu> @leet dafis
07:39:37 <lambdabot> dAFis
07:39:41 <haasn> maybe it would help to memoize divisorCount?
07:39:47 <Eduard_Munteanu> preflex: seen dafis
07:39:48 <preflex>  dafis was last seen on #haskell 1 year, 207 days, 21 hours, 39 minutes and 3 seconds ago, saying: so there's no point verifying that it's a tuple
07:39:54 <mm_freak> haasn: use a sieving method
07:40:02 <mm_freak> you'll have to write it yourself though
07:40:26 <skypers_> woah that’s great
07:40:30 <skypers_> preflex: seen skypers
07:40:31 <preflex>  skypers was last seen on #haskell 17 hours, 30 minutes and 44 seconds ago, saying: night folks
07:40:42 <skypers_> ahah :)
07:41:23 <haasn> mm_freak: you mean eg. for number n with prime factors n, mark (n+{2}) at n*2, (n+{3}) at n*3, etc.?
07:41:27 <mm_freak> haasn: you can also use a bulk factoring method (not implemented by arithmoi) and then use divisorSumFromCanonical
07:41:36 <mm_freak> haasn: pretty much
07:41:37 <haasn> then using divisor-- yeah
07:41:57 <haasn> prime factors p, mark (p+{2}) at n*2 etc*
07:42:26 <mm_freak> one of the few applications of mutable arrays/vectors =)
07:42:41 <haasn> yes :)
07:42:57 <haasn> though it would be nice to make it an infinite lazy list
07:43:06 <haasn> and use Data.Set.Set
07:43:11 <mm_freak> don't…  it'll be very slow
07:43:16 <mm_freak> you can make it a list of sieves
07:43:26 <mm_freak> see how arithmoi's FactorSieve is implemented
07:43:30 <mm_freak> or PrimeSieve
07:43:43 <Eduard_Munteanu> You should be able to make a stream and take as much as you need no?
07:43:56 <mm_freak> yes, but it's very slow
07:44:17 <Eduard_Munteanu> mm_freak: well, you could still make them in batches, I suppose
07:44:52 <haasn> mm_freak: ah, I see what it does; makes sense
07:44:53 <Eduard_Munteanu> I guess that's sort of what you meant by list of sieves.
07:45:10 <mm_freak> let me put it this way:  it's harder to express, harder to read and doesn't give you any real advantage
07:45:21 <mm_freak> this is an imperative algorithm, so you could just as well write it imperatively
07:45:59 <haasn> I wonder if that would be faster than just going through the numbers 1-n n times and adding 1 to each field
07:46:03 <mm_freak> and enjoy the speedup that may well be on the order of 1000-100000x =)
07:46:05 <haasn> which is n²
07:46:25 <haasn> to each k-th field*
07:46:36 <mm_freak> well, my implementation would likely do something like:  MVector (Map Int Int)
07:46:48 <haasn> benchmarking time?
07:47:00 <mm_freak> hmm?
07:47:20 <haasn> re: my question
07:48:01 <mm_freak> the asymptotic complexity is O(n²), but note that with each item your step size increases
07:48:47 <mm_freak> for 10000 elements after having visited 100 elements each further element will only take up to 100 steps, decreasing
07:49:20 <mm_freak> and after visiting half of all elements, you can stop
07:49:56 <dmwit> I roughly think of foldr as accumulating information from the end of the list towards the front, and foldl as accumulating information from the front of the list towards the end.
07:50:09 <dmwit> Is there a sensible fold that accumulates information from both directions in one pass?
07:50:21 <mm_freak> dmwit: both folds are left-to-right
07:50:58 <notdan> I like thinking of foldr as an operation that replaces (:) in lists with arbitrary functino
07:51:01 <notdan> function*
07:51:11 <mm_freak> notdan: both foldr and foldl do that
07:51:21 <mm_freak> their only difference is associativity
07:51:25 <dmwit> mm_freak: Sort of? I mean, in foldr, the recursive call gets to inspect only the end of the list; in foldl, the accumulator can only have information about the beginning of the list.
07:51:47 <mm_freak> dmwit: foldr (\x xs -> …)
07:51:55 <notdan> mm_freak: yes, foldl changes the order
07:51:56 <notdan> http://www.haskell.org/haskellwiki/Fold#List_folds_as_structural_transformations
07:52:17 <mm_freak> x is totally the beginning of the list for its first iteration
07:52:21 <dmwit> Motivation: I have a list that contains either elements of interest or "line markers" with an Integer inside. I'd like to annotate all the elements of interest with the line marker closest to it on either side.
07:52:31 <mm_freak> notdan: no, it changes associativity
07:52:59 <dmwit> mm_freak: Right. But in later invocations, it's just one element, not information about the whole beginning of the list.
07:53:01 <notdan> yeah sorry, s/order/associativity/
07:53:11 * hackagebot http-conduit-browser 1.9.0.2 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.9.0.2 (MikhailKuddah)
07:53:16 <dmwit> mm_freak: Unlike in foldl, where the accumulator has information about the entire beginning of the list.
07:53:21 <notdan> and the placement of z for that matter
07:54:05 <haasn> http://oeis.org/A000005
07:54:29 <dmwit> In any case, I've written a function which does what I want. I'm just wondering if there's a nice operation underlying what I'm doing here.
07:55:13 <identity> I met a haskell guy! Another, real, living haskell guy!
07:55:28 <albertid> ...on the net?
07:55:37 <identity> no, in real life!
07:57:23 <dmwit> Perhaps it makes more sense to ask about combining scanl and scanr instead.
07:57:45 <tdammers> identity: they do exist
07:57:56 <dmwit> In fact, perhaps the right way to implement this is by combining scanl and scanr. =)
07:58:26 <dmwit> ?src scanr
07:58:26 <lambdabot> scanr _ q0 []     =  [q0]
07:58:27 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
07:58:27 <lambdabot>     where qs@(q:_) = scanr f q0 xs
07:59:27 <identity> tdammers: The haskell community in my country seems to be non-existent
07:59:38 <identity> thus my surprise
07:59:47 <mm_freak> i haven't met another haskell guy in person
07:59:47 <tdammers> ah
07:59:51 <tdammers> right
07:59:55 <tdammers> I've met a few, actually
07:59:58 <tdammers> netherlands
08:00:02 <mm_freak> even though i'm using haskell commercially
08:00:16 <skypers_> mm_freak: ?
08:00:18 <skypers_> commercially?
08:00:21 <skypers_> in your firm?
08:00:26 <haasn> huh
08:00:29 <mm_freak> i'm a freelancer
08:00:34 <skypers_> nice!
08:00:39 <skypers_> how did you start?
08:00:45 <skypers_> I might be interested
08:00:59 <mangaba_leitosa> what's a shorter method for writing 'fToString arg1 arg2 arg3 arg4 = intercalate " " . f arg1 arg2 arg3 $ arg4' ? lambdabot's @pl proposes '(((intercalate " " .) .) .) . f', but I don't like multiple nested parens
08:01:14 <mm_freak> well, it started as a hobby
08:01:31 <haasn> filter even (map divisorCount [1..]) == map (^2) [1..] -- ?
08:01:32 <mm_freak> netwire is one of the children of my commercial work =)
08:01:41 <haasn> filter odd*
08:01:57 <bartavelle> mm_freak, I suppose the question is something like "how the hell did you find someone willing to pay you to write Haskell, as a freelancer ?"
08:01:57 <haasn> err
08:02:00 <haasn> let me retry that:
08:02:06 <skypers_> yeah
08:02:09 <skypers_> kinda, bartavelle
08:02:12 <haasn> filter (odd . divisorCount) [1..] = map (^2) [1..] -- ?
08:02:18 <skypers_> I’d love to write Haskell programs as a freelancer
08:02:34 <tomejaguar> mangaba_leitosa: for a start: 'fToString arg1 arg2 arg3 = intercalate " " . f arg1 arg2 arg3'
08:02:42 <bartavelle> as it will (arguably) be hard for a company to find another Haskeller freelancer in case they don't like you anymore or you change occupation
08:02:42 <mangaba_leitosa> bartavelle: I suppose that's simple: you just find someone willing to have some task done, and not bothering about the tools/languages with which it is done
08:02:56 <mm_freak> bartavelle: what mangaba_leitosa says
08:03:03 <bartavelle> doesn't sound that easy :)
08:03:29 <skypers_> yeah
08:03:35 <skypers_> where would you find such a guy?
08:03:36 <mangaba_leitosa> tomejaguar: yes, but I still have to copy paste 'arg1 arg2 arg3' :-(
08:03:39 <mm_freak> and my solutions work (it's haskell after all)…  i'm proud to say that i've never had a single commercial bug report =)
08:03:50 <mm_freak> in four years
08:03:53 <bartavelle> nice !
08:03:56 <skypers_> had you already developped your job network befro that?
08:03:59 <skypers_> before*
08:04:16 <mm_freak> i was mainly a C++ and PHP developer before that
08:04:22 <bartavelle> (and you need to find more than one guy)
08:04:35 <skypers_> definitely bartavelle
08:04:45 <skypers_> mm_freak: C++ and PHP in a firm?
08:04:50 <skypers_> or still as freelancer?
08:04:55 <mm_freak> skypers_: freelance
08:05:20 <skypers_> currently I’m working in firm, but I’d like doing some freelance projects in the same time
08:05:24 <skypers_> in a film*
08:05:47 <mm_freak> skypers_: you can sneak haskell into your company by writing small helper tools for your job
08:05:59 <tomejaguar> mangaba_leitosa: I think you have 'fToString = (intercalate " " .) .:. f' and then you can go from there ...
08:06:20 <skypers_> mm_freak: I think I can’t, because we have ITIL and all that kind of stuff
08:06:46 <skypers_> Quality Managers that freak out if someone try something else that planned
08:06:47 <skypers_> you know.
08:07:26 <bartavelle> I was able to sneak quite a few Haskell programs in the infrastructure at my company, but it isn't snowballing
08:07:35 <bartavelle> I suppose I am not convincing enough
08:07:44 <skypers_> how do you do?
08:07:53 <skypers_> my manager is a Perl-boy
08:08:06 <mm_freak> skypers_: no, tools for personal use
08:08:06 <skypers_> he writes everything in Perl
08:08:09 <mangaba_leitosa> tomejaguar: what are .:. and f' here?
08:08:14 <mm_freak> stuff to manage files, etc.
08:08:28 <skypers_> mm_freak: I see
08:08:36 <skypers_> I might do that, yeah, but hm
08:08:48 <skypers_> how do you put the topic on with your manager?
08:09:00 <tomejaguar> mangaba_leitosa: f is your f.  .:. is from Data.Composition
08:09:10 <mm_freak> skypers_: you'll need a command line utility for your work…  it's called GHC
08:09:20 <mm_freak> =)
08:09:32 <skypers_> “Hey, have you ever heard of FPL? Haskell then? Well, I wrote a few tools, do you mind to take a look and train people to write Haskell to support it?”
08:09:34 <skypers_> mm_freak: well
08:09:36 <mangaba_leitosa> tomejaguar: thanks looking it up...
08:09:48 <skypers_> I have a ssh remote connection to unix machines
08:10:09 <mm_freak> skypers_: no, that goes too far…  to be honest i didn't ask management, i just did it
08:10:19 <merijn> <- same here
08:10:23 <skypers_> ok
08:10:25 <mm_freak> i wrote haskell utilities like other people write python/perl utilities
08:10:25 <bartavelle> <- same
08:10:37 <mm_freak> without asking anyone for permission
08:10:37 <bartavelle> in my case I rewrote some ruby utilities too :p
08:10:43 <skypers_> so you don’t earn any money thank to that Haskell lines then :(
08:10:53 <merijn> "Hey guys, I just wrote this incredibly useful tool in 15 minutes, oh, btw it's haskell because else I could never have been so productive!"
08:11:00 <mm_freak> skypers_: you do, it's within your work hours
08:11:15 <skypers_> yeah
08:11:20 <skypers_> you’re right
08:11:24 <skypers_> but hm, I know my manager
08:11:36 <mm_freak> and don't tell people that you did it…  let them discover it by themselves =)
08:11:42 <merijn> It's easier to beg for forgiveness than beg for permission :p
08:11:45 <merijn> eh
08:11:46 <mm_freak> "oh, nice, where did you find that tool?" — "uhm, i wrote it"
08:11:47 <merijn> ask for permission
08:11:58 <bartavelle> merijn, begging for permission works
08:12:02 <mm_freak> what merijn says =)
08:12:05 <merijn> bartavelle: :p
08:12:09 <skypers_> he’s the kind of guy who’d say “Well your tool is incredibly useful, but no one here knows Haskell so please port it for our knowledge and rewrite it in Perl pleas.”
08:12:31 <mm_freak> skypers_: then you do
08:12:32 <skypers_> mm_freak: :) “I wrote it”
08:12:49 <merijn> skypers_: "Ok, it'll take me 10X hours, though. Where X is the hours it took to implement originally."
08:12:49 <mm_freak> skypers_: obviously the perl solution will take days to write
08:12:55 <moops> is there a trick to getting parsec to work with utf8?
08:12:55 <mm_freak> while the haskell version took only 30 minutes
08:13:02 <moops> unexpected "\9580" expecting "\955"
08:13:11 <skypers_> mm_freak: yeah well
08:13:12 <merijn> moops: I thought parsec used String/Text normally?
08:13:20 <merijn> moops: Those are already unicode data types...
08:13:30 <bartavelle> skypers, there are a couple tools I could shoehorn because of time pressure : "I can only write it in haskell in that amount of time, will rewrite it in X when I have time", and as everything temporary is forever ..
08:13:32 <mm_freak> "i'm still rewriting that utility, because it's difficult to get it right in perl"
08:13:37 <merijn> moops: Are you sure your import is actually correct?
08:13:38 <skypers_> here we have a nice mind vision (is that even english? :D sorry) of programs and languages
08:13:54 <skypers_> my manager doesn’t
08:14:09 <moops> merijn: import? i just have it in a string literal, though the string to be parsed is loaded from a file
08:14:10 <skypers_> he’s narrow-minded
08:14:15 <merijn> moops: eh, I meant input
08:14:19 <bartavelle> merijn, moops I believe the question is related to the error ?
08:14:25 <mm_freak> skypers_: don't worry too much
08:14:33 <bartavelle> he's like to see an unicode character, not \216615
08:14:40 <mm_freak> skypers_: if it works, good for you…  if it doesn't, at least you tried =)
08:14:52 <merijn> moops: How do you load the file?
08:14:59 <skypers_> and btw, Perl just sucks. It’s a horrible language. My manager keeps saying it’s “nice for files processing”, but sorry dude, Haskell’s files are just sugar.
08:15:15 <moops> merijn: readFile
08:15:29 <merijn> @hoogle readFile
08:15:30 <lambdabot> Prelude readFile :: FilePath -> IO String
08:15:30 <lambdabot> System.IO readFile :: FilePath -> IO String
08:15:30 <lambdabot> Data.ByteString.Lazy.Char8 readFile :: FilePath -> IO ByteString
08:15:31 <skypers_> mm_freak: sure! but I don’t really know what tools I could actually write :)
08:15:35 <tomejaguar> All you non-Haskell programmers need to quit and become Haskell freelancers :)
08:15:38 <bartavelle> skypers_ : I have found out that pointing out that the others person pet language sucks is not an effective persuasion technique
08:15:40 <moops>  bartavelle: not really worried about the escape sequence, just that they dont match
08:15:45 <merijn> moops: The prelude one?
08:15:45 <bartavelle> oh
08:15:56 * merijn is betting $10 on misconfigured environment
08:15:57 <mm_freak> skypers_: whenever you're tempted to write a shell script or a download a small utility, consider installing the haskell platform instead ;)
08:15:57 <moops> merijn: yes
08:15:57 <skypers_> bartavelle: I never told him ;)
08:16:07 <mangaba_leitosa> tomejaguar: great, 'fToString = (T.intercalate " ") .:: f' is what I needed! thanks!
08:16:08 <mm_freak> skypers_: that surely comes up often enough
08:16:09 <skypers_> I keep telling “Oh yeah that rocks!”
08:16:12 <merijn> moops: readFile guesses encoding from your environment
08:16:21 <merijn> moops: Are you sure your locale is set correctly?
08:16:21 <mangaba_leitosa> tomejaguar: however, without type signatures it only works with -XNoMonomorphismRestriction
08:16:28 <skypers_> mm_freak: I already have it installed :)
08:16:30 <mangaba_leitosa> tomejaguar: but that's OK I think
08:16:38 <mm_freak> skypers_: then there's nothing to stop you
08:16:40 <moops> merijn: no, my locale is japan i think. is there a way to bypass that detection and force utf8?
08:16:48 <skypers_> ahah
08:16:57 <skypers_> Raise of Haskell in Industry™
08:16:59 <merijn> moops: Alternatively, read as ByteString and decode manually
08:17:01 <tomejaguar> mangaba_leitosa: Nice.
08:17:01 <skypers_> by mm_freak
08:17:05 <mm_freak> skypers_: if all else fails, you can always use GHCi as your command line calculator
08:17:09 <moops> merijn: okay ill try that, thanks!
08:17:11 <merijn> @hoogle decodeWith
08:17:11 <lambdabot> No results found
08:17:19 <skypers_> mm_freak: :)
08:17:27 <dcoutts> merijn, moops: System.IO has support for encodings, no need to do anything manually
08:17:29 <skypers_> okay it’s 5:00 PM
08:17:30 <skypers_> leaving
08:17:34 <skypers_> talk to you later
08:17:50 <merijn> dcoutts: How do you specify them?
08:17:54 <dcoutts> hSetEncoding h utf8
08:18:09 <merijn> moops: I usually use "decodeUtf8With", but apparently you can force the encoding as dcoutts points out
08:18:42 <dcoutts> e.g. withFile blah ReadMode $ \h -> do hSetEncoding h utf8; content <- hGetContents h; ....
08:18:57 <dcoutts> or utf8_bom
08:19:16 <dcoutts> or any of the other standard unicode encodings
08:19:29 <dcoutts> otherwise it defaults to the localeEncoding :: TextEncoding
08:25:27 <mangaba_leitosa> tomejaguar: ah, I don't even need parens, 'fToString = T.intercalate " " .:: f' also works :-)
08:25:44 <tomejaguar> Yup :)
08:30:15 <tomejaguar> Does anyone know a reference for what (| ... |) mean in arrow notation?
08:32:16 <moops> merijn, dcoutts: that fixed it, thanks again
08:32:45 <Eduard_Munteanu> tomejaguar: where did you see that?
08:33:41 <tomejaguar> Eduard_Munteanu: http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/arrow-notation.html and http://en.wikibooks.org/wiki/Haskell/Arrow_tutorial
08:34:09 <monoidal> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/arrow-notation.html 7.15.3
08:34:45 <monoidal> the manual seems laconic though
08:35:11 <tomejaguar> monoidal: Yeah I doesn't actually say what they mean.
08:35:18 <tomejaguar> Or at least, not enough for me to actually get it.
08:39:29 <merijn> dcoutts: utf8_bom?! Since when does utf8 have a bom?
08:39:45 <Kinnison> Unicode has a BOM
08:39:50 <dcoutts> merijn: it doesn't, but some stupid programs write one
08:39:54 <merijn> ...
08:40:04 <Kinnison> many things use the presence of a BOM encoded at the start of a document to indicate it's UTF8 rather than any other encoding
08:40:08 <Kinnison> It's dumb
08:40:10 <Kinnison> but it's done
08:40:12 <moops> yea im pretending that doesnt exist for now :)
08:40:46 <Kinnison> Most sensible input stream processors notice and discard it during stream startup
08:41:25 <geekosaur> http://qdb.dreamwidth.net/dw/428 utf8 bom...
08:42:43 <Eduard_Munteanu> Why does GHC complain when type synonyms aren't fully applied, really? It seems to me that's reasonable in many cases.
08:43:05 <dcoutts> merijn: utf8_bom encoding ignores one at the beginning, and never generates one
08:43:20 <geekosaur> because a not fully applied type synonym may turn out to be a type lambda, which causes all sorts ofproblems
08:43:39 <dcoutts> Eduard_Munteanu: it would allow direct recursion at the type level
08:43:51 <monoidal> Eduard_Munteanu: there's LiberalTypeSynonyms for (rare) cases
08:44:10 <Eduard_Munteanu> Hm. But can't it just do some limited form of termination checking? It does for type families anyway, I think.
08:44:28 <dcoutts> merijn: but sensibly it's not our default, our default is to be strict. But we make it easy to be lenient.
08:45:53 <Eduard_Munteanu> monoidal: yeah, that doesn't help me... I'm passing a partially-applied type synonym to a newtype as a parameter, which applies it fully in the constructor.
08:48:24 <`cbp> Hi. Does scion require an older version of haskell/cabal-install? (Note: I'm new to haskell)
08:48:48 <`cbp> I do cabal update, cabal install cabal-install and then cabal install scion but that last one fails
08:55:07 <donri> why is this needed, shouldn't that be a type error? https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html#t:NestedAtomically
08:55:56 <Eduard_Munteanu> donri: possibly when using unsafe* functions
08:56:11 <donri> yeah but that's just silly! :P
08:56:25 <Eduard_Munteanu> donri: well, they do provide a few for things like toplevel STM vars.
08:56:37 <donri> i guess
08:57:19 <Eduard_Munteanu> donri: and it's sort of nice that STM can detect that, I suppose
08:57:39 <Eduard_Munteanu> Instead of e.g. locking up.
09:01:01 <Sculptor> hello
09:04:59 <Brongue> Hey everyone
09:20:13 <`cbp> Is scion no longer maintained? It looks outdated and it wont build
09:21:30 <danr> `cbp: I'd go for ghc-mod
09:21:48 <teneen> how can I detect the encoding of a text file programmatically?
09:22:09 <`cbp> danr: what is the standard for emacs + haskell? is it haskell-mode + ghc-mod?
09:22:22 <teneen> is there a function somewhere in the system libraries which does this?
09:24:20 <geekosaur> teneen: autodetection isn't really a thing
09:25:23 <geekosaur> you *may* be able to distinguish between a handful of possibilities if they're different enough, but in general you can't do it at all (how do you distinguish between iso8859-1 and iso8859-15 with no information but a body of text that is in one of them?)
09:25:49 <teneen> geekosaur: how do text editors do it then?
09:25:59 <fizbin> `cbp: I've found an emacs setup I like fairly well using flycheck and hdevtools.
09:26:20 <fizbin> `cbp: It
09:26:24 <moops> teneen: may want to look at http://en.wikipedia.org/wiki/File_%28command%29
09:26:46 <geekosaur> guessing. usually incorrectly in my experience (since they just assume if it contains *this* it's utf8, if it contains *this* it's iso8859-1 (don't even consider the other iso8859s because no way to distinguish), if none then assume ASCII)
09:26:57 <Brongue> Is it possible to create a parser for reactive-banana events?
09:27:19 <geekosaur> and even so, it's entirely possible to misrecognize utf8 as iso8859-1 or vice versa
09:27:20 <bergmark> `cbp: i basically just use haskell-mode's syntax highlighter. I don't know if i can use flycheck/ghc-mod when developing multiple packages
09:28:41 <fizbin> `cbp: It's not perfect, and integrating it with sandboxed cabal is currently done with a very hackish hack that I need to rework, but I've got something that's let me work on both work stuff (in a cabal sandbox) and hack on the lens library (in a different sandbox).
09:28:47 <andrew123> @pl \xs n -> take n xs ==> flip take
09:28:48 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
09:28:56 <teneen> moops: does it mention the encoding?
09:29:05 <andrew123> @pl \x y -> p y . p x
09:29:06 <lambdabot> flip ((.) . p) . p
09:29:11 <teneen> geekosaur: but they almost always get it correctly
09:29:21 <moops> teneen: yes
09:29:26 <teneen> geekosaur: Notepad++ and notepad at least
09:29:29 <teneen> moops: where?
09:29:45 <bergmark> fizbin: that's good to know! but cabal sandboxes aren't good enough for me to use yet :/
09:30:12 <fizbin> bergmark: Are you still using cabal-dev?
09:30:46 <bergmark> fizbin: yes
09:30:56 <South> Does anyone know of a simple way to render literal haskell on blogspot with code formatting / color?
09:31:22 <bergmark> fizbin: there are several open issues for sandboxes that need to be fixed before i can start using them
09:31:41 <geekosaur> teneen: then I will guess you use at most the 3 I mentioned that are often but not always detectable
09:31:57 <fizbin> bergmark: Well, my flycheck+hdevtools hack can probably be adapted so long as you can get cabal-dev to show you the full ghc command line used when invoking it.
09:32:06 <geekosaur> if that really is all you care about, I don't know if there is a canned halfass-guesser that will usually get just those 2-3 right
09:32:09 <fizbin> I should maybe write it up.
09:32:27 <teneen> teneen: I mainly use ASCII, utf8, utf_bom and utf16le
09:32:36 <teneen> geekosaur: I mainly use ASCII, utf8, utf_bom and utf16le
09:32:37 <fizbin> Except it's really too ugly right now to write up anywhere real. Maybe an anonymous lpaste...
09:32:44 <geekosaur> those can be (mostly) distinguished, yes
09:32:56 <geekosaur> people who care abourt encoding detection usually care about more than that
09:35:18 <fizbin> One of the appendices to the original XML spec. gives an algorithm for detecting enough to be able to read and interpret the xml declaration (which should then have the real encoding in "encoding")
09:37:11 <teneen> geekosaur: so I'll have to do the distinction manually. Or are there system functions in Haskell which might help?
09:37:18 <fizbin> But that algorithm relies on the fact that the first two characters of a conforming xml document that isn't in UTF-8 should be "<?",
09:37:19 <geekosaur> there are not
09:47:56 <partyallnight> https://www.facebook.com/events/569654679757110/581579548564623/?notif_t=like
10:12:07 <dmwit> ?quote sprynge
10:12:08 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
10:12:25 <moops> hahaha
10:12:41 <kqr> ocharles, would you be interested in having someone write about cassava for 24 days of hackage this year?
10:12:42 <bz> is cabal sandbox a replacement for hsenv?
10:12:42 <blochchain> so, i'm in an undergrad discrete math class and we're supposed to write a 6-8 page paper discussing some topic of our interest as a discrete math problem. We've spent most of the semester on induction proofs, proving algorithms, and graph theory. what would be some interesting and manageable Haskell topics to explore? I understand a good amount of Haskell (including the monoids/monads/fmapping stuff)
10:13:50 <dmwit> bz: That's the idea, I think.
10:14:10 <moops> blochchain: proving stuff by structural induction could be a good topic
10:14:25 <bz> dmwit: i'm really not getting it, because i just cabal installed attoparsec into a sandbox and it's not showing up in ghc-pkg list
10:14:38 <dmwit> It's not supposed to.
10:14:49 <dmwit> It will only show up in the package database for your sandbox.
10:15:55 <dmwit> bz: Try cabal sandbox hc-pkg list
10:17:23 <dmwit> blochchain: You might be interested in thinking about how to rewrite some of the graph algorithms you studied in a way that's amenable to inductive proofs.
10:18:03 <dmwit> blochchain: That kind of line of inquiry led to Haskell's finest graph library, fgl. =)
10:18:26 <derdon> moops: what is special about a *structural* induction? I know the meaning of weak and strong induction, but what is structural induction?
10:18:44 <dmwit> (After you've thought a bit, you could read the fgl paper and see if you recognize any of your thoughts in the paper, and if the thoughts in the paper give you any ideas about new ideas of youl own.)
10:19:03 <tac> derdon: structural induction is strong induction.
10:19:14 <derdon> ah, I see
10:19:16 <tac> You may call on any "subpart" of the argument
10:19:16 <dmwit> derdon: weak and strong induction is induction over naturals
10:19:28 <dmwit> derdon: Structural induction can work on richer structures than boring old nats.
10:19:40 <derdon> dmwit: and structural is over structures such as lists or trees?
10:19:45 <moops> such as data structures/programs
10:19:49 <dmwit> derdon: for example, yes
10:19:56 <Eduard_Munteanu> derdon: your step is an arbitrary constructor
10:20:10 <bz> any way to make a sandbox inherit global packages?
10:20:38 <derdon> thanks for the answers :)
10:20:43 <mjga> bz: good question. would be nice to have a clone op on sandboxes, so they would start with all Haskell Platform packages, or so...
10:20:50 <dmwit> bz: cabal sandbox add-source --snapshot?
10:21:02 <blochchain> is there any good introduction to optimization techniques that are unique to functionally pure languages? I was also thinking about looking at algebraic data types
10:21:21 <Eduard_Munteanu> @where okasaki
10:21:21 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
10:21:25 <mjga> dmwit: is there a way to select a subset of packages to be copied to sandbox?
10:21:29 <Eduard_Munteanu> blochchain: the above might be what you want ^^
10:21:41 <dmwit> I dunno.
10:21:53 <dmwit> I'm just picking the most likely command from http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html for each question. =)
10:21:55 <Eduard_Munteanu> blochchain: but more on the algorithmic side
10:22:24 <jrmithdobbs> is there an easier way to write: case res of Left x -> provideJson x ; Right x -> provideJson x ; where the types of the Left and Right results differ?
10:22:26 <Eduard_Munteanu> blochchain: there are specific optimizations, like deforestation / fusion and memoization.
10:22:47 <dmwit> blochchain: You might also like Bird's papers on (human-based) optimization by equational reasoning.
10:22:53 <Eduard_Munteanu> :t either
10:22:55 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:22:55 <jrmithdobbs> i don't care about the types i just want it unwrapped from Either so that the serialization doesn't include that
10:23:03 <dmwit> jrmithdobbs: either provideJson provideJson
10:23:06 <bz> dmwit: but then i'd have to add-source individually for each global package, right?
10:23:07 <blochchain> lol this might all be a little intense
10:23:11 <blochchain> this class isn't all that rigorous
10:23:23 <blochchain> and I don't have a massive amount of free time
10:23:33 <jrmithdobbs> dmwit: huh?
10:23:41 <dmwit> blochchain: You may find academic papers more approachable than you're guessing you will. =)
10:23:57 <blochchain> dmwit: i was more just referring to the page count
10:24:01 <mjga> blochchain: Google for "haskell optimization" will show you a lot of generic tutorials. Articles concentrate on specific subtopics, like fusion, deforestation, tail-call optimization. The topic is too broad.
10:24:03 <blochchain> of the supplied papers
10:24:03 <jrmithdobbs> :t either
10:24:04 <dmwit> jrmithdobbs: Can you turn that into a full question?
10:24:05 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:24:25 <jrmithdobbs> dmwit: nm, I got you, didn't notice the lower cased e
10:24:31 <enthropy> can a happy parser be loaded into ghci without manually calling the happy foo.y?
10:24:41 <dmwit> blochchain: Well, naturally you're going to have to focus a bit. You won't be able to write about *all* of these things. =)
10:24:46 <mjga> blochchain: maybe there would be a sense in publishing a review, but progress in the field of FP optimization is too fast for the review to stay up to date.
10:25:00 <donri> enthropy: with cabal repl, probably
10:25:16 <enthropy> yes I was imagining something like that
10:25:19 <jrmithdobbs> dmwit: that is a handy function. knew there had to be one. :)
10:25:39 <dmwit> There's always a catamorphism.
10:25:56 <dmwit> Unless you're Bool. =(
10:26:13 <lingxiao> hey does anyone know the details of how function signatures are represented ?
10:26:22 <mjga> blochchain: there is a Haskell wiki page, though. http://www.haskell.org/haskellwiki/Performance/GHC
10:26:37 <dmwit> lingxiao: What kind of details?
10:26:44 <Eduard_Munteanu> lingxiao: in GHC specifically?
10:26:54 <lingxiao> yes
10:27:13 <dmwit> lingxiao: Got a copy of the source handy? I can point you at the right file and line. =)
10:27:34 <Eduard_Munteanu> lingxiao: you might be able to extrapolate from http://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/Language-Haskell-TH.html if the TH API is enough
10:27:45 <mjga> where optimization
10:27:54 <mjga> where performance
10:28:09 <mjga> :t (<$>)
10:28:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:28:14 <lingxiao> dmwit: I don't have the source unfortunately, but if you point me to the file, I can read them later?
10:28:31 <dmwit> lingxiao: compiler/types/Type.lhs:105
10:28:33 <lingxiao> Eduard_Munteanu: thank you, I'll start there!
10:28:35 <Eduard_Munteanu> There should be a Git repo somewhere, no?
10:28:37 * hackagebot haskell-pdf-presenter 0.2.2 - Tool for presenting PDF-based presentations.  http://hackage.haskell.org/package/haskell-pdf-presenter-0.2.2 (MichaelAdams)
10:28:47 <dmwit> lingxiao: compiler/types/TypeRep.lhs:105 I mean
10:28:59 <donri> mjga: did you mean @where?
10:29:13 <mjga> donri: thx a lot
10:29:16 <mjga> @where optimization
10:29:16 <lambdabot> I know nothing about optimization.
10:29:19 <mjga> @where performance
10:29:20 <lambdabot> http://haskell.org/haskellwiki/Performance
10:29:27 <lingxiao> dmwit: ah ok I will be checking it out
10:30:30 <enthropy> donri: it kind of works, but if I change the .y file, the generated file doesn't get updated
10:31:27 <lingxiao> Eduard_Munteanu : yup just foundit
10:32:00 <chrisdone> Peaker: hey peeky
10:32:22 <Peaker> hey chrisdone
10:32:32 <donri> enthropy: did you :reload?
10:32:51 <enthropy> yes when I reload it doesn't re-run happy
10:33:00 <donri> ok i thought it was supposed to do that
10:34:27 <enthropy> me too. seems like a bug
10:37:03 <lingxiao> dmwit: any idea which folder the data types for Core is ?
10:37:05 <tomejaguar> This is a longshot, but, is there a way of grepping all of Hackage?
10:41:57 <donri> tomejaguar: there's the 300 mb download http://old.hackage.haskell.org/packages/archive/00-archive.tar not sure if new hackage has this
10:42:24 <tomejaguar> donri: Hmm maybe I'll just give that a go :)
10:43:15 <moops> what are rho and phi in the context of kinds?
10:45:14 <S11001001> moops: a record, and one field of a record, respectively.  Maybe.  At least in the context of Ermine.  Not sure what the etymology is.
10:45:47 <moops> ahh okay, that clears it up
10:46:11 <Eduard_Munteanu> S11001001: ρecord and φield, maybe? :)
10:46:27 <moops> haha
10:47:09 <S11001001> Eduard_Munteanu: the pun is "row" :)
10:47:22 <Eduard_Munteanu> Hm, even better.
10:47:34 <S11001001> in the kind language of ermine row ≡ rho ≡ ρ
10:47:49 <geekosaur> and phi-ld? (well, not with the English mispronunciation...)
10:47:54 <S11001001> geekosaur: yeah
10:56:16 <yfyf> uhm, any "general" reason why I should not be able to define a generic instance of a `class GBiArrowable f` with a function gbarr :: (BiArrow arr) => arr b c -> arr (f a) (f c)?
10:56:24 <modus> i know someone's name, but forget their IRC username
10:56:29 <yfyf> think Foldable f from the generic-deriving pacakge
10:56:57 <yfyf> and BiArrows are just like arrows, but the lifting operation is biarr :: (a -> b) -> (b -> a) -> arr a b
10:57:03 <modus> is there a way i can find their username again if i know the name they attached to their irc username?
10:57:31 <yfyf> I can define a class `Arrowable f` just fine
10:57:53 <yfyf> but if I do an equivalent for biarrows it seems to loop infinitely even in trivial cases
10:58:09 <yfyf> ugh, I realised this might be too complicated to answer without code : /
11:00:59 <koala_man> modus: /who *Name*
11:01:49 <modus> ahh
11:01:55 <schell> modus: also, you may have luck with logs http://ircbrowse.net/browse/haskell
11:01:56 <modus> koala_man: let me try that
11:02:29 <modus> schell:  that worked beautiful, many thanks
11:02:39 <schell> ;)
11:11:03 --- mode: ChanServ set +o Saizan
11:12:15 --- mode: Saizan set -b *!~klrr@*
11:12:20 --- mode: Saizan set -o Saizan
11:19:15 <chrisdone> Peaker: did you try recent shm? i've been using it for a few days for normal hacking, it's feeling usable
11:20:00 <threestrikes> #ledger
11:22:02 <Peaker> chrisdone: Can't wait to... I'm currently behind schedule on my C projects, so haven't Haskelled in weeks :(
11:22:18 <Peaker> chrisdone: the git log seems like you've been productive :)
11:23:31 <prooftechnique> chrisdone: shm?
11:23:42 <merijn> shared memory, most likely?
11:23:55 <merijn> (SYSV shared memory, usually)
11:25:05 <donri> structural haskell mode
11:25:14 <prooftechnique> Sounds neat
11:25:24 <Ralith> ooh
11:25:35 <merijn> aww, that sounds boring and emacsy
11:25:36 <bennofs> Using the pipes library, I often wonder if I should take a Producer of Inputs as an argument to a function, or have the function itself be a Consumer of inputs. Is there any rule when I should use which technique?
11:25:39 <Ralith> donri: link?
11:26:06 <merijn> bennofs: I would go with "whatever makes most semantic sense"
11:26:07 <bennofs> Example: I could do both of: f :: Producer Input IO () -> IO Return or f :: Consumer Input IO Return
11:26:16 <klugez> Ralith: chrisdone is being evil and is only telling everyone how awesome it is, not actually publishing it.
11:26:27 <Ralith> chrisdone: >:(
11:27:05 <bennofs> Unfortunaly, the latest pipes api doesn't seem very coherent in that sense. For example, most of the folds only work with the first type :|
11:27:27 <bennofs> Is there a way around that?
11:27:46 <prooftechnique> Are you on the mailing list?
11:27:54 <bennofs> Not yet.
11:28:13 <prooftechnique> I'd recommend it. That's where most of the pipes discussion goes on
11:30:01 <quchen> There is a pipes mailing list?
11:30:11 <klrr_> yup
11:30:16 <klrr_> https://groups.google.com/forum/#!forum/haskell-pipes
11:30:45 <bennofs> prooftechnique: ok, signed up :)
11:30:50 <quchen> "Google Groups"? How do I subscribe to that list?
11:31:19 <klrr_> hmm, i guess you need gmail account :/
11:31:29 <quchen> In other words, it's not a mailing list
11:31:35 <quchen> :-(
11:31:39 <klugez> quchen: Send an email to haskell-pipes+subscribe@googlegroups.com
11:31:48 <klugez> It is a mailing list. Google just hides it very well.
11:31:56 <klugez> The same with all the Google groups lists.
11:31:58 <quchen> klugez: Oh, that's good to know, thanks.
11:32:08 <Ralith> chrisdone: are you indeed not publishing this? Do you have a timeline?
11:32:34 <klugez> Ralith: I meant hasn't published yet. Not *that* evil. :)
11:32:56 <Ralith> klugez: right, I meant 'not yet publishing'
11:33:04 <Ralith> thus hope for a timeline
11:36:26 <quchen> Haha. You have to login to subscribe.
11:36:42 <quchen> I'm going to spare you the rant, but feel free to imagine me yelling at my computer.
11:41:26 <klugez> quchen: Hmm. I've subscribed without logging in. The response mail said "please reply to this email or visit the following ...". If you reply, you should be subscribed.
11:42:05 <quchen> I got a "server error" with a reload button that did nothing. And it went well once I logged in.
11:42:06 <klugez> I had to try a few times, because at first I got subscribed with my Gmail address even though I didn't want to use that.
11:42:11 <quchen> Glad I still have that trash account.
11:42:19 <quchen> Could just be coincidence though.
11:43:17 <klugez> Yeah, but I mean just sending the subscribe mail and then replying to confirm. No visiting the web browser. Otherwise Google decided that I wanted to use my gmail address even if that was not the address I sent the mail from.
11:44:03 <zaphix_> Hi folks, I'm trying to build a shared lib from some haskell code for use in a multi-language project (I want it callable from C, etc.), but do not want to have to use ghc to link things from inside an IDE, etc.  http://tinyurl.com/lkkhdav has decent instructions (section 4.12.3 describes exactly what I want), but if I use -shared without -dynamic, I get strange link errors.  I'm guessing this is because my Haskell platform
11:44:03 <zaphix_> pre-built static libs weren't built with -fPIC, and I don't have the dyn libs installed.  Is rebuilding from source my only option (to either create the dyn libs or ensure everything is built with -fPIC)?
11:44:12 <chrisdone> Ralith: yeah, within the next couple weeks. i haven't had much spare hacking time lately, there are still some obvious deficiencies/edge cases to iron out
11:44:26 <Ralith> sweet, looking forward to it
11:44:41 <zaphix_> the linker error I am getting via -shared and no -dynamic is like 'ld: illegal text reloc in '_sdpc_info' to '_stg_ap_2_upd_info' for architecture x86_64' but the latter symbol doesn't seem to exist in any of the haskell .a files, so I'm not sure what it is
11:44:45 <Eduard_Munteanu> zaphix_: why not use cabal to build?
11:45:09 <chrisdone> Ralith: if you want to be an alpha guinea pig i can add you to the private repo, as long as you promise not to be annoyed when it breaks
11:45:30 <zaphix_> Eduard_Munteanu: not sure how to use cabal to build a shared library that has all of the haskell runtime libs as well as my own package and other package dependencies
11:45:43 <Ralith> chrisdone: sounds like fun!
11:46:26 <Ralith> the bleeding edge may bleed indeed, but it's still an exciting place to be
11:46:28 <tomejaguar> bennofs: surely 'Producer Input IO () -> IO Return or f' is easily converted to 'Consumer Input IO Return' but not the other way round.  It seems like saying "Should I write 'IO a -> IO b' or 'a -> IO b'".
11:46:28 <Eduard_Munteanu> zaphix_: if you run 'cabal init' in the root dir of your project, it will guide you through it
11:46:52 <bennofs> tomejaguar: How would I convert that?
11:47:22 <zaphix_> Eduard_Munteanu: hmm, can i supply an additional .cpp file and so forth for the FFI bindings as well with cabal?
11:47:41 <quchen> preflex: seen Tekmo
11:47:41 <preflex>  Tekmo was last seen on #haskell 3 days, 23 hours, 9 minutes and 7 seconds ago, saying: Alright, thanks everybody for your help, especially `johnw`! :)
11:47:51 <tomejaguar> bennofs: given 'Consumer Input IO Return' just compose it with a producer and then run it?
11:48:12 <tomejaguar> bennofs: but I'm not overly familiar with the pipes API
11:48:26 <chrisdone> Ralith: added. you need to cabal install so that structured-haskell-mode is in your PATH that Emacs can see, or otherwise customize shm-program-name. then simply load up structured-haskell-mode.el (i recommend M-x byte-compile-and-load for extra possible speed) and run M-x structured-haskell-mode in a haskell buffer. the syntactical node at point should be highlighted in a color (probably that doesn't match your color theme) and M-x
11:48:26 <chrisdone> shm/describe-node should say what kind of node that is in the message area. let me know if you get that far ;)
11:48:27 <Eduard_Munteanu> zaphix_: I don't think it can build .cpp's directly but you can make it call 'make' or whatever build system you have for the C++ bits.
11:48:39 <zaphix_> Eduard_Munteanu: from what i've read i think i either need static libs compiled with -fPIC or the dynamic rts libs in order to get what i want -- i guess i'm a bit unclear as to what cabal does for me
11:48:52 * hackagebot shelltestrunner 1.3.2 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.3.2 (SimonMichael)
11:48:53 <bennofs> I mean, how can I write (Producer Input IO () -> IO Return) -> Consumer Input IO Return?
11:49:08 <zaphix_> Eduard_Munteanu: basically i want my haskell code + some FFI bindings goop + a few dependent haskell packages + haskell runtime all in one dynamic lib that can be used in a multi-language project
11:49:19 <Eduard_Munteanu> zaphix_: how did you install GHC?
11:49:32 <tomejaguar> bennofs: You can't.  I meant the other way!
11:49:49 <zaphix_> Eduard_Munteanu: platform haskell platform binary distro for OS x, i will probably have to rebuild from source if it's the case that i need -fPIC'd statics or the dynamic libs to do what i want
11:50:03 <bennofs> tomejaguar: yes, the other way is easier :)
11:50:07 <zaphix_> Eduard_Munteanu: (but wasn't sure what to give configure in order to make that happen)
11:51:08 <Eduard_Munteanu> zaphix_: I think HP ships dynamically-linked Haskell libs for most platforms
11:51:46 <zaphix_> Eduard_Munteanu: if i try to build the dylib via -dynamic -shared, I get a message that the "den" libraries for base are not installed, so i suspect I have to build them
11:52:39 <zaphix_> Eduard_Munteanu: "den" = "dyn"
11:52:39 <Eduard_Munteanu> zaphix_: for Haskell code?
11:52:53 <Eduard_Munteanu> Hm.
11:53:12 <zaphix_> Eduard_Munteanu: Yeah, I'm basically doing: ghc --make -no-hs-main -dynamic -shared -c FFI.hs ffi_bindings.o -o libblah.so
11:54:00 <Eduard_Munteanu> zaphix_: you should try cabal, it could supply the right options
11:54:24 <zaphix_> Eduard_Munteanu: I guess I'm just trying to determine the path of least resistance given that I get link errors from attempting to link against the static libs, and the dyn libs don't seem to be installed
11:55:03 <Eduard_Munteanu> zaphix_: that, or you might be missing a ghc flag telling it where to look for them.
11:55:21 <Ralith> chrisdone: kk
11:55:26 <zaphix_> Eduard_Munteanu: my haskell lib directory only has .a files, and nothing named "dyn" so they are probably not here
11:55:47 <Eduard_Munteanu> Hm, that doesn't seem right.
11:55:51 <zaphix_> Eduard_Munteanu: I'm happy to try to use cabal, I just don't see how I'm going to get it to support this (seemingly, to me) non-standard use case
11:56:07 <Eduard_Munteanu> zaphix_: why non-standard?
11:56:38 <Eduard_Munteanu> That's normal linking behavior on all platforms.
11:56:42 <zaphix_> Eduard_Munteanu: i'm trying to build a shared library that contains (or has dylib deps on) the entire haskell runtime plus some extraneous object files i also generate for some of the FFI bindings
11:57:14 <Eduard_Munteanu> zaphix_: hm, why not a big static lib instead?
11:57:22 <zaphix_> Eduard_Munteanu: all or most of the stuff i've seen online just seems to suggest that i should be using ghc for linking things that involve the FFI, but that's not really an option since it's a pain in the ass vis-a-vis the IDE context in which the project is being used
11:57:34 <Eduard_Munteanu> By normal behavior I meant building dynamic libs, dynamic wrt Haskell object files.
11:57:40 <zaphix_> Eduard_Munteanu: big static lib is just fine too, but again, i don't want to use ghc to link the final executables and such
11:57:43 <zaphix_> Eduard_Munteanu: ah i see
11:58:44 <Eduard_Munteanu> zaphix_: you mean you can't make the IDE call GHC?
11:58:48 <zaphix_> Eduard_Munteanu: basically i have a bunch of haskell stuff and i want people to be able to use it from inside Xcode for other projects with only a header file for the (very small) C API for FFI bindings and a library of some kind, with no custom makefile projects or other stuff
11:59:25 <zaphix_> Eduard_Munteanu: I can, but would really prefer not to if it can be avoided
12:00:47 <zaphix_> Eduard_Munteanu: or it could be invoked to build a standalone library, but not for the actual executables that link against the haskell code
12:01:12 <Eduard_Munteanu> zaphix_: ah, sure.
12:01:19 <zaphix_> Eduard_Munteanu: the problem is right now i can build exes that link against my FFI stuff, but in order to link against other parts of the overall application, I have to tweak other projects etc. etc. to make sure that ghc is used as the final link step, and it's a pain in the ass
12:01:49 <zaphix_> Eduard_Munteanu: would be much better if I could just -lmyhaskellcrap and include myhaskellcrap_ffi.h =)
12:03:35 <Eduard_Munteanu> zaphix_: sounds like you want a proper static lib then, a dynamic lib normally does not gather multiple other libraries into it.
12:04:03 <Eduard_Munteanu> Unless you intend to copy the dependencies too along with your .so
12:04:58 <Eduard_Munteanu> zaphix_: though the latter is doable too
12:05:01 <zaphix_> Eduard_Munteanu: hmm, i guess that means that i'd need to manually specify all of the haskell .a files as well as the .a files for any dependent packages in the IDE then
12:05:40 <Eduard_Munteanu> zaphix_: no, I mean you should be able to make a big .a containing everything
12:06:08 <zaphix_> Eduard_Munteanu: hrm, that does sound good, but i'm not sure how to do that
12:06:33 <Eduard_Munteanu> zaphix_: http://tldp.org/HOWTO/Program-Library-HOWTO/static-libraries.html
12:06:45 <zaphix_> Eduard_Munteanu: I've got an FFI.hs file that imports stuff from my haskell library that needs to be exposed via the ffi
12:07:03 <zaphix_> Eduard_Munteanu: oh, sorry, i knew how to do that part of it ;P but that doesn't aggregate .a's, does it?
12:07:23 <Ralith> chrisdone: working as you describe so far
12:08:27 <drewr> am I missing something in haskell-mode that allows me to configure it to be sandbox-aware?
12:08:29 <zaphix_> Eduard_Munteanu: okay, i'll try to see if i can build a .a that has everything i want in it. thanks.
12:08:59 <drewr> for example, I want C-c C-z to hoist me into a ghci that's aware of the cabal-sandbox-installed deps, not the ~/.cabal ones
12:09:15 <Ralith> chrisdone: pretty impressed just tinkering around; reminds me of paredit. I'll do some real hacking tonight and let you know how it goes
12:09:55 <Ralith> this appears to be just what I've been wanting
12:10:04 <Eduard_Munteanu> zaphix_: you could extract all your installed Haskell .a's and the libc .a, then combine them all into one.
12:10:37 <Eduard_Munteanu> zaphix_: or you could try building a PIC executable and dlopen()-ing it
12:10:38 <chrisdone> Ralith: excellent! so this mode introduces a few re-bindings of keys that you may/may not want to have enabled, which you can peruse with your leasure. features of interest are: ) to go to the end of the node or outwards, like paredit. M-a to go up in the tree, like paredit. C-k which will delete to the end of the line, but no delete closing things. M-k or C-M-k (either) will kill the currently highlighted node, and it will re-indent,
12:10:38 <chrisdone> when you C-y it back elsewhere, it'll be indented to the right place
12:11:01 <Eduard_Munteanu> zaphix_: since executables contain everything they need to run.
12:11:20 <chrisdone> Ralith: C-j takes the current selected node into account, like paredit. it doesn't have all cases yet, but it has some basics (see shm-newline-indent). it's not behaving quite perfectly yet, some edge-cases there
12:11:49 <zaphix_> Eduard_Munteanu: hmm, does something like ld -static automatically unpack includes libraries for combining in that fashion, or would i actually need to manually unpack all of the contents of the haskell static libs?
12:12:00 <chrisdone> Ralith: typing (self-insertion) normal letters and such will also re-indent dependent child nodes, and backspace will 'bring' them back
12:12:14 <zaphix_> Eduard_Munteanu: i'd like to try the PIC executable approach, but I think that means I'd need to recompile the haskell libs with -fPIC, and am not sure how to do that -- is it easy?
12:12:20 <Eduard_Munteanu> zaphix_: manually, .a's don't contain their dependencies, only the final executables
12:12:28 <Ralith> I'm a big fan of autotermination and terminator-preserving stuff, and you'd probably be hard pressed to make an indent more annoying to use than the alternatives even with bugs
12:12:40 <chrisdone> Ralith: yeah, it's definitely inspired/modelled off of paredit
12:12:45 <Ralith> \o/
12:13:25 <Ralith> it had never occurred to me that paredit for haskell syntax might be feasible, though now it seems obvious
12:13:28 <dmwit> ?tell lingxiao Sorry, I don't know -- I haven't looked at that stuff. But the GHC commentary almost surely says something about this.
12:13:28 <lambdabot> Consider it noted.
12:13:30 <Eduard_Munteanu> zaphix_: actually hm... you could just try and see if Cabal can build your library first
12:13:33 <chrisdone> Ralith: right -- in this mode the intention is that you just indent like you do in paredit, with C-j. and M-k/C-y are supposed to make sure whenever you paste it keeps indentation correct
12:13:38 <chrisdone> Ralith: yeah :D
12:13:53 <zaphix_> Eduard_Munteanu: hah, okay, will try it
12:14:01 <Ralith> chrisdone: I'm totally going to try to crib this for idris ^^
12:14:08 <Ralith> (come release)
12:14:26 <chrisdone> Ralith: hm, i just noticed M-^ is bound to shm/delete. just comment that out and C-M-x the map and the minor mode to get rid of it, meanwhile i'll push a fix. that should (eventually) be delete-indentation
12:15:12 <Ralith> noted
12:15:14 <chrisdone> Ralith: yeah :D in fact -- it's fairly haskell-agnostic, it could be generalized quite easily, i think. provided you can make a program to parse idris and return a list of nodes
12:15:21 <skypers> hi
12:15:23 <Ralith> wonderful!
12:15:29 <zaphix_> Eduard_Munteanu: i currently have a pair of source files called ffi_bindings.cpp and ffi_bindings.h which wrap the ghc-generated FFI_stub functions.  no idea how to get cabal to compile that and/or link in a separately generated .o.
12:15:32 <Ralith> there's been talk of doing just that
12:15:33 <chrisdone> Ralith: i'll help you out with that if you decide to do it
12:15:35 <agoebel> I was going through the haskell wiki book and specifically on monad transformers and I have created the askPassword functions except I can't figure out how to simply go from a "MaybeT IO ()" to an "IO ()" for my main function
12:15:42 <Ralith> chrisdone: that would be awesome, thanks :D
12:15:44 <chrisdone> Ralith: sweet! using the idris compiler itself?
12:15:48 <Ralith> yeah
12:15:51 <chrisdone> makes sense
12:16:02 <Ralith> a grad student recently did a big parser rewrite
12:16:03 <Eduard_Munteanu> agoebel: runMaybeT
12:16:07 <Eduard_Munteanu> :t runMaybeT
12:16:09 <lambdabot> Not in scope: `runMaybeT'
12:16:10 <Ralith> refactoring's in the air
12:16:13 <Eduard_Munteanu> @hoogle runMaybeT
12:16:15 <lambdabot> Control.Monad.Trans.Maybe runMaybeT :: MaybeT m a -> m (Maybe a)
12:16:42 <agoebel> look at that, thanks Eduard_Munteanu
12:17:18 <Ralith> chrisdone: even if I don't find time, this is sufficiently exciting that I'm sure one one of the other idris-mode hackers will; we want to give agda-mode a run for its money, after all
12:17:31 <Eduard_Munteanu> zaphix_: http://stackoverflow.com/questions/4959802/how-to-specify-dependency-on-external-c-library-in-cabal
12:17:59 <zaphix_> Eduard_Munteanu: thanks muchly, i'll google more aggressively next time ;P
12:18:35 <chrisdone> Ralith: makes sense! agda-mode is lovely, a mode of similar smarts for idris would be wicked
12:18:42 <Eduard_Munteanu> zaphix_: well, that's actually for pkg-config driven libs... I guess the manual should explain how you build external things.
12:18:58 <chrisdone> Ralith: it has or will have tactics and stuff, right?
12:19:01 <zaphix_> Eduard_Munteanu: Yeah i'll give the cabal attempt a fair shake before resorting to other means.  Thanks again.
12:19:23 <Ralith> chrisdone: yeah, that's in
12:19:54 <chrisdone> sweet. i've not yet written my first program with idris, but i'm looking forward to sitting down on a quiet weekend to do so
12:21:08 <chrisdone> Ralith: i suppose the cool thing about idris being so new is that you can get edwin's ear on making sure editor integration is getting all the necessary exposed APIs from the compiler, something more difficult/time consuming to get through ghc
12:21:10 <Luke> chrisdone: how's structured mode coming?
12:21:32 <haasn> Ralith: w-what about adding vim s-support to idris m-mode?
12:22:10 <Eduard_Munteanu> Hm, is there a thing (transformer?) that, given a 'Free f', has a run function such that it applies a function on each unwrapping of that 'Free f'? Ideally you'd provide the function in a type. :)
12:22:20 <Ralith> chrisdone: yeah, it's a great time for laying groundwork for that sort of thing; we've already got a basic ideslave interface modeled after SLIME's
12:22:38 <chrisdone> Luke: i haven't hacked on it much since you last tried it (we're pushing out a new release soon at fp complete), but i did fix some bugs so that it fails less often. i'm using it in my day-to-day hacking now, at least. should get some quiet time next week with emacs to nail down some of the todo's
12:22:54 <Ralith> haasn: vim actually has better support for the moment, since edwin uses it and thus it was the first to receive interactive case-splitting
12:23:07 <Ralith> well
12:23:11 <haasn> Ralith: interesting
12:23:12 <Luke> chrisdone: good to hear
12:23:18 <Eduard_Munteanu> I'm interested in the case where 'f' is a Monad.
12:23:19 <Luke> blog about it when you get a chance
12:23:24 <Ralith> I think that's been merged roughly into the emacs mode too now
12:23:27 <haasn> maybe that will be a motivating factor to use idris and not agda ;)
12:23:43 <Ralith> but vim had an advantage for a little while there, and there are people working to keep it well supported
12:24:06 <chrisdone> Ralith: oh man, you read my thoughts with that. i was thinking that: common lisp compilers are *so* wordy and enthusiastic about giving you all the info you want, as an editor, so their integration is just tip-top with SLIME. getting that for haskell has been tough. if idris has that out of the box, that's spiffy
12:24:08 <Ralith> in general we have an explicit goal of not being tied to any one editor
12:24:59 <Ralith> chrisdone: that's just the structure of the API, mind; exposing all useful info is an ongoing task
12:25:12 <chrisdone> Ralith: (i.e. ghc's always been "one-shot" focused, with ghci being just "okay" — idris's compiler can providing swank-like slaves is a great direction)
12:25:17 <Ralith> (christiansen's the one who laid out the design)
12:25:27 <chrisdone> nod
12:25:41 <Eduard_Munteanu> So, pretty much a  FooT b (Free m a) ~ (m b, Free m a)  or maybe even   FooT b m a ~ (m b, Free m a).
12:25:42 <Ralith> ah, yeah
12:25:58 <chrisdone> Luke: yeah i'll make a proper announcement
12:26:09 <Eduard_Munteanu> Such that runFooT :: FooT b m a -> m a.
12:27:10 <chrisdone> Ralith: (btw, if the " key and ' things like that are bugging you, i'd just comment them out in the map. you kinda have to press C-q ' to get a normal ' presently)
12:27:14 * chrisdone makes dinner
12:27:44 * Ralith has frankly missed that functionality from paredit
12:29:13 <Ralith> you're probably already aware of this, but it might be prudent to disable special bracket/quote handling when inside a context where they have no special meaning, e.g. string literals
12:29:55 <chrisdone> Ralith: yep, aware of it. you mean how ) will just jump out of a string instead of inserting it. definitely planned to fix
12:30:47 <Ralith> chrisdone: that and the automatic balancing and so on
12:31:01 <chrisdone> Ralith: yep. the same thing for when inside a comment
12:31:14 * Ralith nod
12:31:48 <chrisdone> Ralith: i'll pop them down as TODO items so i don't forget
12:35:55 <Eduard_Munteanu> Can you make a singleton type for a function?
12:39:05 <Eduard_Munteanu> I guess I could make a singleton for a newtype wrapping a function, though I don't gain much if I have to define it, since I was hoping to plug the function right into the type.
12:41:25 <pyr> Is there a common attitude towards "open" polymorphism in haskell
12:41:50 <Eduard_Munteanu> pyr: what do you mean by "open"?
12:42:30 <Eduard_Munteanu> pyr: ad-hoc polymorphism perhaps?
12:42:36 <pyr> yup
12:42:38 <pyr> having a function that acts on anything implementing a contract
12:43:19 <pyr> let's say I want a fn that sinks to a list of things respecting Output
12:43:28 <roconnor> Isn't the purpose of the class mechanism to implement ad-hoc polymorphism?
12:43:47 <pyr> I can't store the list of outputs in an Output out => [out]
12:43:49 <Eduard_Munteanu> roconnor: not really
12:44:12 <Eduard_Munteanu> roconnor: ad-hoc means you can override existing function for a particular type, not just class methods
12:44:12 <pyr> since this wants a homogeneous list of outputs
12:44:46 <pyr> of course it could be described as OutputType1 | OutputType2 | ...
12:44:53 <Eduard_Munteanu> pyr: you can use an existential
12:45:00 <pyr> ah
12:45:02 <roconnor> pyr: you can use existental types extension in GHC
12:45:12 <pyr> ah, I need to look up that
12:45:24 <roconnor> people have varying opinions about that topic.
12:45:34 <pyr> I bet they do
12:45:40 <pyr> (pardon my ramblings, I'm discovering haskell everyday)
12:46:28 <roconnor> pyr: I would say that Existential types have their place but they tend to be overused somewhat by ... new haskell users.
12:46:36 <roconnor> sorry
12:47:04 <pyr> well, no worries
12:47:20 <Eduard_Munteanu> roconnor: typeclasses are more like bounded quantification, AFAICT.
12:47:32 <pyr> I am a new haskell user used to a language with very open polymorphism :)
12:47:53 <roconnor> pyr: generally speaking, I would say it is better to make a record type with all the functions you want in your class and make a list of such records.
12:48:23 <pyr> roconnor: I'll start that way
12:48:29 <Eduard_Munteanu> pyr: the idea is you can define   data AnyOutput = forall out. AnyOutput (Output out)   and you can make a list [AnyOutput]
12:48:41 <pyr> ok
12:48:48 <jle`> i have read that ghc, for executables, compiles even IO objects that will never be accessible by main, and all items in a module even if they are never referenced by any of the exported elements.  is this true?  what is the motivation for this?
12:49:05 <jle`> it sounds like a bunch of wasted space in the binary for things that would never be called
12:50:29 <Eduard_Munteanu> It can also take the form of a more general combinator  data Exists p = forall a. Exists (p a)
12:50:46 <Cale> jle`: There's dead code elimination.
12:50:59 <Eduard_Munteanu> Using it like [Exists Output].
12:51:01 <Cale> jle`: But if you export things from a module, they will have to be compiled
12:51:02 <pyr> Eduard_Munteanu: alright, it would work my use-case, at the expense of betraying my being a new haskell user :)
12:51:39 <Eduard_Munteanu> pyr: I'm only saying you *can* use that, but generally you should look if there's a better way to accomplish the same thing
12:52:00 <jle`> Cale: i am referring to things that you never export and are never even referenced from any of the exported items
12:52:04 <monochrom> jle`: instead of just reading, you should perform experiments to reproduce or refute it
12:52:07 <pyr> Eduard_Munteanu: are you familiar with logstash / riemann and or collectd ?
12:52:16 <Eduard_Munteanu> pyr: mm, no
12:52:33 <Eduard_Munteanu> jle`: without an export list, a module exports everything by default
12:52:33 <monochrom> my experiments refute it so far
12:53:07 <pyr> Eduard_Munteanu: too bad, I'm building a tool in the same space, providing a list of inputs, a list of outputs and processing in between
12:56:48 <bgamari> Why is it that network doesn't bind inet_pton?
12:59:00 <Eduard_Munteanu> bgamari: inet_addr :: String -> IO HostAddress  ?
12:59:32 <bgamari> Eduard_Munteanu, Yes, but there is no IPv6 equivalent that I know of
12:59:56 <geekosaur> there's no IPv6 to speak of in the network package anyway
13:00:13 <Eduard_Munteanu> Ouch.
13:00:15 <geekosaur> well, not Network.BSD at least
13:00:17 <dmj`> if I have a data Person { _age :: Int }, and a p = Person 55, how do I use lenses to update it? Something like let g = p^.age = 99, but it returns a new Person, with the age at 99
13:00:32 <geekosaur> the higher level stuff supports it but that's not the level inet_pton() operates at
13:00:35 <bgamari> geekosaur, that's not quite true
13:00:44 <bgamari> geekosaur, alright, yes
13:00:45 <rck> having issues with cabal instal cabal-install 1.16 -> 1.18 on windows. Compiles, links, then during "Configuring Cabal-1.18.1.2..." it errors with "setup.exe: does not exist"
13:01:00 <bgamari> geekosaur, What is the solution here?
13:01:39 <monochrom> dmj`: p is immutable (so is g). after obtaining g, throw p away. that is all.
13:01:39 <geekosaur> someone probably has to come up with either a new interface or some way to backward compatibly extend the existing one
13:01:40 <bgamari> geekosaur, What is solution here?
13:01:48 <bgamari> ahh
13:01:57 <geekosaur> I would suggest talking to whoever maintains the network package
13:01:57 <bgamari> ouch
13:02:00 <geekosaur> maybe they have ideas
13:02:06 <Eduard_Munteanu> dmj`: set p^.age 99 ?
13:03:22 <geekosaur> actually, perhaps you want http://lambda.haskell.org/platform/doc/current/packages/network-2.4.1.2/doc/html/Network-Socket.html#v:getNameInfo
13:04:12 <geekosaur> getaddrinfo and getnameinfo are (supposedly) the correct replacements for the old inet_* functions
13:04:33 <geekosaur> sorry, getAddrInfo there
13:04:43 <geekosaur> hm, I am confusing myself
13:04:47 <geekosaur> (otoo much going on here)
13:06:32 <geekosaur> getAddrInfo, AI_NUMERICHOST
13:06:55 <bgamari> geekosaur, I see
13:06:56 <bz> gah
13:07:13 <bz> i don't understand how you people can call either of cabal-dev or sandbox an improvement over hsenv
13:07:17 <bz> seriously
13:07:43 <bz> ghc-pkg list needs to be specially invoked, need to keep cwd == the sandbox or else imports don't work
13:07:46 <bz> etc etc
13:07:47 <moops1> im trying to print out "⊥" in a String but my exe crashes with <stdout>: commitBuffer: invalid argument (invalid character). am i doing something wrong?
13:07:52 <geekosaur> hsenv has its place if you want to build a whole separate haskell ecosystem. most of the time you only need a package database
13:08:13 <Eduard_Munteanu> moops1: if on Windows, you might need to set the encoding on the Handle
13:08:13 <monochrom> why do you want a quarrel?
13:08:20 <geekosaur> moops1: your locale isn't UTF8 (or ghc isn't recognizing it as UTF8)
13:08:27 <bz> geekosaur: i'm simply trying to emulate virtualenv.py
13:08:38 <geekosaur> then you want hsenv
13:08:45 <bz> geekosaur: hsenv worked until i realized that it doesn't inherit global packages
13:08:59 <geekosaur> well, no, it won't. it virtualizes the whole thing
13:09:37 <geekosaur> I do think the cabal sandbox functionality could use some helper stuff at the shell level, but I thought cabal-dev already had that?
13:09:48 <geekosaur> (admittedly I have not paid close attention)
13:10:14 <bz> cabal-dev requires its own special invocation of ghc-pkg among other things
13:10:27 <bz> serious ugh
13:11:27 <moops1> Eduard_Munteanu: geekosaur -- that fixed it, thanks
13:11:50 <moops1> why cant the world just be utf8
13:14:55 <monochrom> well, the world except windows is already utf8
13:15:55 <monochrom> it is just windows who still hold on to that "national code page" bullshit
13:16:38 <monochrom> anyway, chcp 65001
13:16:39 <ion> There used to be a lot of Finns who thought UTF-8 on IRC was cancer but nowadays only a few of them remain. I guess it’s like when they switched from ISO 646-FI to ISO 8859-1.
13:17:13 <monochrom> there are still ##math influential people who think non-ascii is cancer
13:17:23 <ion> s/they switched/IRC (as it was) switched/
13:18:17 <jle`> monochrom: thank you for the suggestion to testing.  yeah, my tests have been against the claim so far
13:19:20 <monochrom> the scientific method triumphs again
13:19:36 <jle`> actually
13:19:42 <jle`> there is 1 more byte
13:19:46 <jle`> in the one with dead code
13:20:07 <monochrom> interesting
13:20:45 <jle`> but the object files are identical
13:20:51 <Eduard_Munteanu> That could be due to variations in generated names etc.
13:20:52 <jle`> it is only in the final binary
13:21:18 <monochrom> ah yes. strip then compare again, maybe.
13:21:35 <jle`> strip?
13:21:45 <Eduard_Munteanu> jle`: man strip
13:23:20 <jle`> after stripping the object files
13:23:23 <jle`> they both have the same md5sum
13:23:40 <jle`> so i'm guessing they are identical
13:23:54 <monochrom> :)
13:24:07 <jle`> how do i compile the object files with the hi files to a binary?
13:24:11 <jle`> er, link
13:24:15 <haasn> would it be sexist to suggest changing it to “woman strip” due to sexism?
13:24:33 <monochrom> you don't need the hi files for linking
13:25:01 <Eduard_Munteanu> jle`: .hi files are generated by ghci
13:25:22 <jle`> hm.  how do i turn the .o files into an actual binary so i can compare them, then?
13:25:33 <jle`> but i'm guessing if they are the same .o files they will be turned into the same binary
13:25:38 <hamid> I'm understadning monads now. but i still need help to fill some gaps like this:
13:25:47 <jle`> referential transparency right
13:25:48 <jle`> heh
13:25:56 <hamid> > filterM (\_ -> Just True) [1..10]
13:25:58 <lambdabot>   Just [1,2,3,4,5,6,7,8,9,10]
13:26:02 <hamid> > filterM (\_ -> []) [1..10]
13:26:03 <lambdabot>   []
13:26:06 <hamid> > filterM (\_ -> [1]) [1..10]
13:26:08 <lambdabot>   Could not deduce (GHC.Num.Num GHC.Types.Bool)
13:26:08 <lambdabot>    arising from the literal `...
13:26:11 <hamid> last one ?
13:26:12 <tomejaguar> Eduard_Munteanu: Don't think so.
13:26:21 <monochrom> what is "binary"? are you referring to executables and *.a, *.so files?
13:26:26 <fizruk> hamid, it should be [True]
13:26:35 <Eduard_Munteanu> tomejaguar: what are you referring to?
13:26:36 <hamid> fizruk, oh! right. thanks
13:26:36 <tomejaguar> Eduard_Munteanu: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/IfaceFiles
13:26:41 <jle`> monochrom: yeah, i'm referring to executable files
13:26:50 <fizruk> hamid, or [True, False, False, True]...
13:26:57 <tomejaguar> Eduard_Munteanu: .hi files are generated by GHC too.
13:26:59 <jle`> i realize now the ambiguity in calling them binaries...
13:27:02 <Eduard_Munteanu> Hm.
13:27:07 <hamid> fizruk, ohhh! rigghhht! i get that now more :D
13:27:21 <hamid> @src filterM
13:27:22 <lambdabot> Source not found. I feel much better now.
13:27:57 <monochrom> then it is better off asking ghc to produce executables for you. you need many parameters. use ghc -v to see how many parameters ghc gives to ld.
13:29:45 <jle`> i just wanted a way to strip the .o files before they get linked
13:29:48 <monochrom> some parameters may be inessential. but the essential ones are how many library files get involved. it's hard to track by hand.
13:29:53 <Kaidelong> I'm getting the impression you can't, in general, convert Either a b to Not a -> b and Not b -> a, which makes intuitive sense thinking about the implementation but seems a bit surprising
13:30:41 <tomejaguar> Kaidelong: What's not?
13:30:46 <tomejaguar> I mean Not
13:31:21 <monochrom> @djinn Either a b -> Not a -> b
13:31:21 <Kaidelong> IIRC, Not x is just short for (x -> Absurdity)
13:31:22 <lambdabot> f a b =
13:31:22 <lambdabot>     case a of
13:31:22 <lambdabot>     Left c -> void (b c)
13:31:22 <lambdabot>     Right d -> d
13:31:45 <monochrom> ("void" there is absurdity)
13:32:48 <skypers> I tried to read the wikipedia page of profonctor
13:32:54 <skypers> I just failed :D
13:33:14 <Eduard_Munteanu> skypers: what background in category theory do you have?
13:33:22 <fizruk> skypers, there's a nice post on FP Complete
13:33:23 <tomejaguar> skypers: If you want to learn about Haskell profunctors, the category theory ones are probably not the best place to start ...
13:33:42 <tomejaguar> In fact, if you want to learn about Haskell X, the category theory ones are probably not the best place to start ...
13:33:42 <hamid> @src print
13:33:43 <lambdabot> print x = putStrLn (show x)
13:33:45 <skypers> Eduard_Munteanu: well, not so much
13:33:48 <Kaidelong> monochrom: I think the issue is that that only shows implication and not equivalence
13:34:02 <skypers> I know magma, monoids, groups, abelian groups and so on
13:34:02 <fizruk> skypers, https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
13:34:07 <skypers> thank you fizruk
13:34:07 <FireFly> tomejaguar: what if I want to learn both about Haskell X and CT X?
13:34:41 <tomejaguar> FireFly: I guess learning about Haskell X makes learning CT X easier, if you already know some Haskell.
13:34:43 <skypers> oh
13:34:58 <skypers> I need to learn how to write the arrow key, it’s awesome
13:35:12 <Kaidelong> @djinn (Not a -> b) -> Either a b
13:35:13 <lambdabot> -- f cannot be realized.
13:35:20 <Eduard_Munteanu> skypers: if you know what a functor is, profunctors can also be formulated as bifunctors contravariant in the first argument and covariant in the second, like Hom(-, -)
13:35:28 <Kaidelong> @djinn (Not a -> b) -> (Not b -> a) -> Either a b
13:35:29 <lambdabot> -- f cannot be realized.
13:36:09 <fizruk> skypers, perhaps you would be interested in this as well then https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#unicodesyntax
13:36:09 <Eduard_Munteanu> skypers: so basically C^op x D -> E
13:36:18 <skypers> 22:20 < Eduard_Munteanu> skypers: if you know what a functor is, profunctors can also be formulated as bifunctors contravariant in the first argument and covariant in the second, like Hom(-, -)
13:36:22 <skypers> ok
13:36:31 <skypers> I just learned what bifunctors are a few days ago
13:36:35 <skypers> bimap, and so on
13:36:50 <tomejaguar> Kaidelong: I guess that direction is not constructively valid
13:36:51 <Eduard_Munteanu> skypers: yeah, a plain bifunctor is C x D -> E
13:37:01 <tomejaguar> @djinn (Not (Not a)) -> a
13:37:02 <lambdabot> -- f cannot be realized.
13:37:07 <tomejaguar> @djinn a -> (Not (Not a))
13:37:08 <lambdabot> f a b = b a
13:37:23 <Eduard_Munteanu> skypers: just like normal (covariant) functors vs contravariant functors: C -> D vs C^op -> D
13:37:26 <skypers> > bimap ((+1),show) (1,2)
13:37:27 <lambdabot>   Couldn't match expected type `a0 -> b0'
13:37:27 <lambdabot>              with actual type `(a1 ...
13:37:36 <Kaidelong> tomejaguar: that example of double negation elimination was exactly what made this light up for me because it's what you arrive at when you use Either a (Not a)
13:37:37 <skypers> oh?
13:37:48 <skypers> > bimap (+1) show (1,2)
13:37:50 <lambdabot>   (2,"2")
13:37:55 <skypers> better :)
13:38:15 <tomejaguar> Kaidelong: this is not constructively valid either.  It's the law of the excluded middle.
13:38:20 <Kaidelong> @djinn Either a (Not a) -> Not (Not a) -> a
13:38:21 <lambdabot> f a b =
13:38:21 <lambdabot>     case a of
13:38:21 <lambdabot>     Left c -> c
13:38:21 <lambdabot>     Right d -> void (b d)
13:38:21 <tomejaguar> @djinn Either a (Not a)
13:38:21 <lambdabot> -- f cannot be realized.
13:38:28 <skypers> Eduard_Munteanu: yeah well, I’m not used to knowing what contravariant concept is
13:38:35 <skypers> it sounds “reversed” for me
13:38:42 <skypers> but I need to read more about the concept
13:38:52 <skypers> like reversed function, f-1, you know
13:38:58 <Eduard_Munteanu> skypers: contravariant means it flips arrows
13:39:04 <Kaidelong> tomejaguar: right, if it was, then double negation elimination has to be valid too
13:39:16 <skypers> if you have a function f : A -> B, the “contrafunction” would be B -> A
13:39:17 <skypers> right?
13:39:36 <tomejaguar> Kaidelong: yup
13:39:38 <Eduard_Munteanu> skypers: are you talking about Set^op? That's a completely different thing from Set, unrelated to inverting functions.
13:39:38 <skypers> so we say contravariant function?
13:39:56 <Eduard_Munteanu> skypers: no
13:40:00 <fizruk> skypers, f :: A -> B is covariant in B and contravariant in A
13:40:00 <skypers> no, just about the word, Eduard_Munteanu, the word contravariant
13:40:10 <skypers> oh!
13:40:12 <skypers> I see!
13:40:23 <fizruk> skypers, are you familiar with covariant/contravariant?
13:40:28 <skypers> not at all
13:40:32 <hamid> :t (->)
13:40:33 <lambdabot> parse error on input `->'
13:40:38 <skypers> that’s what I’ve been saying for a few minutes :)
13:40:44 <donri> :k (->)
13:40:45 <lambdabot> * -> * -> *
13:40:53 <skypers> hamid: (->) is a type
13:41:06 <hamid> hmm that made it worse!
13:41:12 <skypers> you cannot take its type then
13:41:19 <skypers> but its kind, has donri mentionned :)
13:41:24 <skypers> worse?
13:41:29 <skypers> as*
13:41:31 <haasn> when using type systems as a substitute for a proof checker, would it be a good idea to simply manually turn off the checker and define “undefined :: Either a (Not a)” or “undefined :: Not (Not a) -> a”?
13:41:40 <haasn> Suspending our belief for those two functions
13:41:48 <haasn> disbelief*
13:41:49 <hamid> skypers, I'm seeing this: data (->) a b   -- Defined in `GHC.Prim'
13:41:58 <skypers> hamid: yep
13:42:07 <skypers> a -> b -> c is two nested (->)
13:42:10 <hamid> skypers, there was always (=) there :P
13:42:17 <skypers> it’s (((->) c) b) a
13:42:24 <hamid> skypers, oh! i think i got it.
13:42:33 <skypers> or the oppsite thing, never really know :D
13:42:41 <donri> hamid: that's probably just for documentation
13:42:42 <Eduard_Munteanu> hamid: you can add those as postulates in Agda for example. But you can just as well make it an argument to your theorems or make the classical monad
13:42:51 <skypers> btw
13:42:57 <skypers> about the type syntax for function
13:43:01 <skypers> ((->) r)
13:43:01 <haasn> Eduard_Munteanu: fair enough
13:43:04 <skypers> what is r here?
13:43:08 <haasn> Eduard_Munteanu: classical monad?
13:43:33 <skypers> the “return” type? or the first parameter? I think it’s the first parameter, otherwise I don’t understand the Monad instance
13:43:40 <Eduard_Munteanu> hamid: the double negation monad, I mean, which embeds classical logic into intuitionistic logic. It's just Classical a = Not (Not a).
13:43:44 <haasn> something like a GADT giving you Foo :: Classical (Not (Not a)) -> Classical a -- ?
13:43:57 <quchen> What was the reason again Haddock won't get Markdown support?
13:43:59 <haasn> oh
13:44:21 <skypers> @src (->)
13:44:21 <lambdabot> Source not found. Do you think like you type?
13:44:38 <Eduard_Munteanu> haasn: you can just prove   Classical (Not (Not a)) -> Classical a  directly.
13:44:41 <skypers> yeah so, ((->) r), what is r here?
13:44:55 <Eduard_Munteanu> @djinn Not (Not (Not (Not a))) -> Not (Not a)
13:44:56 <lambdabot> f a b = void (a (\ c -> void (c b)))
13:45:04 <skypers> because, the monad instance defines >>= as :
13:45:04 <Eduard_Munteanu> @djinn Not (Not a) -> a
13:45:05 <lambdabot> -- f cannot be realized.
13:45:05 <tomejaguar> quchen: A long thread: http://www.mail-archive.com/haskell-cafe@haskell.org/msg105520.html
13:45:21 <Eduard_Munteanu> haasn: which is also the type of join for it :)
13:45:50 <haasn> Eduard_Munteanu: yes :)
13:46:14 <quchen> tomejaguar: Ah, thanks
13:46:18 <skypers> (>>=) :: m a -> (a -> m b) -> m b, which is (>>=) :: ((->) r) a -> (a -> ((->) r) b) -> ((->) r) b
13:46:21 <skypers> right?
13:46:32 <haasn> Eduard_Munteanu: I can't imagine that being very clean to work with, syntax noise all over the place :(
13:46:34 <skypers> then it’s :
13:46:37 <haasn> Unless you guys have applicative brackets?
13:47:13 <skypers> well, if the r is the returned type, it turns to be (>>=) :: (a -> r) -> (a -> (b -> r)) -> (b -> r)
13:47:28 <skypers> it doesn’t make any sense to me
13:47:43 <Eduard_Munteanu> haasn: some alias it to ¬¬, e.g. ¬¬ P, where P is a classical proposition
13:48:02 <ion> skypers: (-) a b = a - b
13:48:07 <ion> skypers: (->) a b = a -> b
13:48:12 <skypers> if r is the first parameter of the function, it turns to be (>>=) :: (r -> a ) -> (a -> (r -> b)) -> (r -> b)
13:48:15 <skypers> and now it makes sense
13:48:31 <ion> > (-) 42 10
13:48:33 <lambdabot>   32
13:48:47 <skypers> > (-5) 15
13:48:48 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
13:48:48 <lambdabot>    arising f...
13:48:49 <haasn> note: ((/) x) y is x/y, not to be confused with (/ x) y which is y/x
13:49:10 <skypers> so hm
13:49:14 <skypers> in ((->) r)
13:49:19 <haasn> we'd like to be able to write (r ->) instead of ((->) r) but alas, type operator sections are not allowed, not even LHS ones
13:49:27 <Eduard_Munteanu> What's a good word that stands for both 'parser' and 'lexer'? Just 'parser'?
13:49:29 <skypers> what is r? for me, giving both the (>>=) instance I wrote, it’s the first parameter
13:49:47 <ion> @type (.)
13:49:48 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:49:59 <kayloos> Eduard_Munteanu: yes
13:50:03 <ion> skypers: What is b? Well, anything you want. Depends on what you apply (.) – or (>>=) – to.
13:50:04 <skypers> yeah I’m idiot
13:50:09 <Eduard_Munteanu> skypers: 'r' is a fixed parameter
13:50:12 <skypers> it’s definitely the first parameter
13:50:18 <alkabetz> Eduard_Munteanu: “frontend”?
13:50:25 <skypers> I wonder why it’s called r, and not a
13:50:30 <skypers> it sounds like “returned”
13:50:32 <skypers> “result”
13:50:41 <skypers> but hm
13:50:44 <Eduard_Munteanu> alkabetz: nah, I was building some stuff based on an attoparsec Parser.
13:50:50 <skypers> (->r), is that even possible?
13:50:53 <skypers> :k (->r)
13:50:54 <lambdabot> parse error on input `r'
13:51:01 <skypers> :k ((->) r)
13:51:02 <lambdabot> Not in scope: type variable `r'
13:51:13 <Eduard_Munteanu> I basically have two parser transformers WordT and LineT, and I wonder what to call the based monad, which is a newtype for Parser.
13:51:16 <ion> skypers: I suppose it refers to “reader”. With the ((->) r) instance you get to carry an environment through the computation that can be read at any point.
13:51:16 <fizbin> We need a type-operator version of "flip"
13:51:25 <skypers> oh
13:51:28 <skypers> you’re right!
13:51:38 <skypers> but the Applicative instance uses a
13:51:41 <skypers> ((->) a)
13:51:58 <ion> It’s pretty arbitrary, but yeah, it would be nice if the instance definitions were consistent in that regard.
13:52:01 <skypers> btw, functions as type is really hard to get into at first :)
13:52:04 <Eduard_Munteanu> skypers: you can only make _ -> r as a newtype.
13:52:05 <fizruk> :k ((->) Int)
13:52:06 <lambdabot> * -> *
13:52:27 <skypers> ok :)
13:52:28 <Eduard_Munteanu> Which is the (->) for Hask^op really.
13:52:49 <Eduard_Munteanu> newtype Op a b = Op (b -> a)
13:53:38 <skypers> ahah
13:53:40 <skypers> :t contramap
13:53:41 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
13:53:44 <skypers> SO MAGIC
13:53:45 <skypers> :D
13:54:01 <fizruk> sometimes I wish instance MonadReader r (r -> m _) where ...
13:54:24 <khyperia> suddenly skypers has a magic-attack
13:54:26 <Eduard_Munteanu> fizruk: what does it do?
13:54:37 <khyperia> I don't even know what Contravariant is, so...
13:54:58 <fizruk> Eduard_Munteanu, ReaderT without a newtype
13:54:58 <skypers> khyperia: well
13:55:08 <skypers> it’s like a backward operation
13:55:08 <ion> khyperia: Well, it’s the variant of functor with (a -> b) -> f b -> f a
13:55:10 <triliyn> khyperia: they're like functors, but instead of yielding values, they consume values
13:55:15 <hamid> lol now that i get the idea this is fun to play with:
13:55:22 <skypers> you have a (a -> b) and you deduce a from b
13:55:26 <fizruk> Eduard_Munteanu, so I don't have to write runReaderT m a and just write m a
13:55:28 <skypers> it’s seriously pure magic. :D
13:55:33 <skypers> I love that!
13:55:33 <hamid> > void ( do { print "hello dudes"} )
13:55:34 <khyperia> ... oh, I didn't notice the flipped a and b
13:55:35 <lambdabot>   <IO ()>
13:55:40 <hamid> lol
13:55:51 <khyperia> that... I don't... yeah, magic. I'm going with magic.
13:55:57 <skypers> hamid: void is nice
13:56:05 <skypers> khyperia: well actually it’s no magic
13:56:08 <skypers> but sounds like
13:56:11 <hamid> skypers, yeah didn't know that till now :D
13:56:25 <Eduard_Munteanu> fizruk: that looks like Kleisli Reader a _
13:56:26 <triliyn> For functions, contramap f g = g . f (f is applied to the input)
13:56:43 <triliyn> While fmap f g = f . g (f is applied to the output)
13:56:58 <khyperia> right
13:57:06 <identity> how is contramap even used? o.o
13:57:23 <ion> I don’t think a Contravariant instance for ((->) r) is possible.
13:57:37 <skypers> identity: no idea
13:57:42 <ion> @djinn (a -> b) -> (r -> b) -> r -> a
13:57:42 <lambdabot> -- f cannot be realized.
13:57:44 <skypers> maybe for rollback?
13:57:56 <briennetheblue> (->) is a profunctor though so you can get contramap that way i think
13:57:57 <triliyn> Right, it has to be for like newtype (<-) a b = a -> b
13:57:58 <Eduard_Munteanu> identity: you can make a Hom(-, A) contravariant functor
13:58:03 <triliyn> Which doesn't work
13:58:23 <triliyn> (And then the instance would be for (<-) r)
13:58:29 <skypers> or >-
13:58:42 <triliyn> Sure
13:58:55 <triliyn> I think both of those symbols are taken, but >- is an arrow thing or something
13:58:56 <skypers> because <- is syntactic sugar for monad binds
13:59:00 <triliyn> Which is somewhat more esoteric
13:59:03 <skypers> yeah
13:59:07 <Eduard_Munteanu> Also the indexed state monad is contravariant in the input index.
13:59:18 <skypers> right arrow I don’t rember which operation
13:59:26 <skypers> Eduard_Munteanu: you guys
13:59:29 <skypers> are so fluent in maths…
13:59:42 <skypers> it’s seriously impressive and _always_ makes me feel like crap
13:59:48 * Eduard_Munteanu isn't really... as opposed to others in here
14:00:01 <skypers> though I try really hard to get to know that
14:00:06 <tomejaguar> Can anyone talk me through some basic template Haskell?
14:00:18 <khyperia> I don't even know what *type* of math Haskell is. Like, what is it even called?
14:00:28 <skypers> FPL maths
14:00:30 <skypers> FTW.
14:00:40 <ion> khyperia: What is math Haskell?
14:00:48 <triliyn> Most people seem to talk about category theory
14:00:54 <haasn> khyperia: computer science
14:00:56 <fizruk> Eduard_Munteanu, ehmm... no?
14:00:56 <Eduard_Munteanu> What Haskell is math? :)
14:00:57 <triliyn> There is also type theory, which is probably related in some way
14:01:20 <Eduard_Munteanu> fizruk: what do you mean?
14:01:28 <khyperia> heh, thanks triliyn
14:01:48 <hamid> Is there any :doc thing in GHC ? I know :t is too damn good but I still need some descriotion about the function :P
14:01:52 <skypers> ooooooh
14:01:53 <fizruk> Eduard_Munteanu, I mean ReaderT is not Kleisli Reader
14:01:58 <skypers> multifunctor
14:02:05 <skypers> is that even possible in Haskell?
14:02:08 <skypers> I don’t think so
14:02:16 <identity> hamid: use hoogle
14:02:21 <skypers> * -> * -> * -> … -> *
14:02:26 <triliyn> khyperia: I found https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors to be a very good explanation, if you haven't seen it yet
14:02:30 <briennetheblue> there are bifunctors
14:02:39 <skypers> yeah
14:02:43 <skypers> I know them
14:02:45 <skypers> hamid: here
14:02:52 <Eduard_Munteanu> fizruk: oh...
14:03:03 <skypers> you get make hoogle searches with @hoogle, but don’t abuse it as flood ;)
14:03:10 <haasn> there's :i which provides a bit more information than :t
14:03:18 <skypers> yep
14:03:20 <hamid> ok i'll flood in private :P
14:03:20 <identity> hamid: :def doc    \x -> return $ ":!hoogle --color --info --count=10 " ++ show x
14:03:23 <skypers> very useful
14:03:24 <Eduard_Munteanu> fizruk: I was thinking of a Reader on the Kleisli category of m, but mangled it up
14:03:29 <haasn> such as the module it's exported from, which helps you figure out where to search
14:03:32 <haasn> identity: nice!!
14:03:33 <identity> in your .ghci
14:03:47 <fizruk> Eduard_Munteanu, nevermind :)
14:03:50 <haasn> (but note that you want a local hoogle database for this)
14:03:56 <identity> just cabal install hoogle before you do that
14:04:09 <skypers> or he can use the online hoogle
14:04:14 <skypers> http://www.haskell.org/hoogle/
14:04:20 <skypers> which is kinda nice too :)
14:04:36 <skypers> you can make type search in there if you want
14:04:39 <skypers> like hm
14:04:56 <hamid> identity, oh! that's even cooler :) thank you.
14:05:00 <skypers> @hoogle (a -> b -> a) -> [a] -> b -> b
14:05:01 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
14:05:01 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
14:05:01 <lambdabot> Data.ByteString.Lazy foldlChunks :: (a -> ByteString -> a) -> a -> ByteString -> a
14:05:15 <identity> skypers: I have a command for that as well
14:05:16 <c_wraith> ...  Is there a way to simulate infinite kinds in GHC, the way you can simulate infinite types with recursive newtypes?
14:05:31 <skypers> identity: I think it’s really nice to make search here
14:05:39 <skypers> everyone can see it, and learn stuff!
14:05:50 <identity> perhaps
14:05:55 <skypers> it’s thank to that I discovered the snail operator! :)
14:06:09 <hamid> cable is able to build in concurrent right?
14:06:11 <c_wraith> It's handy as a teaching tool, but when it's overused it gets tough to do anything *else* in here.
14:06:11 <triliyn> Snail operator?
14:06:15 <skypers> :t (^@..)
14:06:16 <lambdabot> s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
14:06:24 <triliyn> ah
14:06:30 <briennetheblue> it's official name is the happy snail operator
14:06:36 <skypers> c_wraith: sure
14:06:40 <triliyn> That is gibberish to me, but perhaps someday I will learn to make sense of it!
14:06:42 <c_wraith> well if it's happy, that's even better
14:06:52 <skypers> ahah yeah
14:07:04 <c_wraith> triliyn: that type is especially "interesting" because usually it has type synonyms in it to make it easier to read.
14:07:10 <skypers> triliyn: it actually blurs me ;)
14:07:24 <c_wraith> triliyn: lens types often look really scary without the type synonyms
14:07:27 <triliyn> oh, is it a lens thing?
14:07:28 <triliyn> ahh, right
14:07:29 <skypers> I’ve been studying kmett’s lenses for a few days
14:07:32 <skypers> yep
14:07:43 <triliyn> The .. reminds me of the traversal-to-list thing
14:07:49 <skypers> ?
14:07:59 <briennetheblue> ^.. ?
14:08:03 <triliyn> I think so
14:08:06 <skypers> :t (^..)
14:08:07 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
14:08:09 <briennetheblue> yeah
14:08:21 <skypers> I don’t wanna know.
14:08:47 <briennetheblue> there is apparently method in the lens operator naming madness
14:10:21 <FireFly> ^@.. is "snail"
14:10:43 <vijaykiran> In "Num :: * -> Constraint" what is a Constraint?
14:10:55 <vijaykiran> I can't get its :t or :k
14:11:09 <triliyn> Constraint is like a class constraint
14:11:16 <monochrom> it is :kind
14:11:16 <triliyn> Num a => a -> String
14:11:17 <Iceland_jack> A Constraint is something you can use in a type constraint
14:11:24 <triliyn> Num a is a constraint
14:11:38 <Iceland_jack> ( … bunch of things of type Constraint … ) => ...
14:11:54 <monochrom> err, maybe not that simple. nevermind me. try both. :)
14:12:05 <joelteon> :k Num
14:12:06 <lambdabot> * -> Constraint
14:12:26 <skypers> how do we delimet if statement in a .cabal?
14:12:36 <haasn> Constraint *is* a kind, it can't have one
14:12:40 <Iceland_jack> @kind forall a. (Num a, Show a)
14:12:41 <lambdabot> Constraint
14:12:52 <Iceland_jack> Constraint is a kind just like * is a kind
14:13:02 <briennetheblue> so... i suppose (^@..) being snail makes (^..) slug
14:13:09 <hamid> what
14:13:15 <triliyn> I think it looks more like a worm than a slug
14:13:55 <hamid> sorry typo
14:13:55 <briennetheblue> but for consistency's sake.  it's clearly a ^@.. without a shell :)
14:14:01 <monochrom> I think a more complete story is this. begin with Constraint being a type. then, after turning on ConstraintKind, you can use it as a kind too.
14:14:40 <triliyn> It can't be a type, can it? It has no values and appears in kind signatures
14:14:57 <skypers> :t os
14:14:58 <lambdabot>     Not in scope: `os'
14:14:58 <lambdabot>     Perhaps you meant one of these:
14:14:58 <lambdabot>       `cos' (imported from Prelude), `or' (imported from Data.List),
14:15:11 <monochrom> "has no value" does not let you deduce "not a type"
14:15:28 <monochrom> also, "is a kind" still does not let you deduce "not a type"
14:15:41 <FreeFull> Void is a type
14:15:44 <triliyn> What is a type, then?
14:15:46 <skypers> I tried a if !os(linux) in the cabal, but it keeps compiling (I use linux)
14:15:47 <skypers> why?
14:15:52 <skypers> :k Void
14:15:53 <lambdabot> Not in scope: type constructor or class `Void'
14:15:55 <monochrom> now cue the Hitler video raging about open sets and closed sets :)
14:16:07 <skypers> monochrom: godwin point
14:16:13 <ion> monochrom: That exists?
14:16:22 <identity> ion: yep
14:16:23 <haasn> ion: http://youtu.be/SyD4p8_y8Kw
14:16:27 <ion> thanks
14:16:42 <monochrom> yeah hehe
14:17:58 <mcstar> ooh homebrew has ghc
14:19:15 <mcstar> is it the preferred way of having haskell around on osx?
14:19:54 <mcstar> (if recommended, i wouldnt want to use haskell-platform)
14:21:10 <skypers> http://hackage.haskell.org/package/FModExRaw-0.1.0.1/FModExRaw.cabal any idea why Errors and Errors.Functions still get compiled (see the if !os down) even on linux?
14:21:39 <skypers> please have a look
14:21:49 <skypers> I think the issue is trivial
14:24:29 <hamid> > guard True :: []()
14:24:31 <lambdabot>   [()]
14:26:25 <mcstar> that was one very funny video
14:27:50 <donri> skypers: i think that should work, but i'm not sure conditional exposed-modules will do what you mean in every case
14:28:30 <donri> skypers: i mean either it's not gonna include them at all if you sdist on linux, or, it's gonna try to be smart about that which maybe causes it to compile them too duno
14:30:09 <donri> skypers: also conditional exposed-modules seem a bit evil, don't you want other-modules rather?
14:31:19 <donri> skypers: anyway to solve the sdist problem you didn't have yet :) make sure to list those files in extra-source-files
14:32:07 <skypers> donri: extra-modules no?
14:32:49 <donri> skypers: there is no extra-modules
14:33:01 <skypers> oh, other-modules
14:33:02 <skypers> sorry
14:33:21 <skypers> well I think I’m gonna use  the System.Info module instead
14:33:26 <skypers> seems to be saner
14:33:28 <donri> skypers: but if you make a conditional other-modules, it still won't package those files if you cabal sdist on linux
14:34:06 <donri> skypers: anyway it seems bad to expose different modules on different platforms in one package
14:34:12 <skypers> yeah
14:34:23 <skypers> that’s why I’m gonna use System.Info :)
14:35:54 <skypers> oh, I might not be able to use it actually
14:36:25 <skypers> I can do something like hm
14:36:48 <skypers> foreign import ccall "CFunction" c_function :: if os(linux) …
14:36:55 <skypers> or even wrap the foreign import in a if
14:36:56 <skypers> do I?
14:38:48 <donri> skypers: you can use os() in cabal and cpp-options: -D...
14:38:58 <donri> then LANGUAGE CPP and #ifdef
14:43:32 <malorie> this might be a dumb question, but how does reactive-banana handle time? does it at all?
14:44:38 <briennetheblue> malorie: how do you mean?
14:44:52 <briennetheblue> "The Moment monad denotes a value at a particular moment in time."
14:47:28 <malorie> briennetheblue: ok. I think I need to do some further reading. thanks
14:48:15 <briennetheblue> malorie: sorry, i don't know why i pasted that line, Event and Behaviour are the types you should look at r.e. time varying values :)
14:48:39 <tomejaguar> Can Template Haskell splice in Decs and Exps at the same time?
14:49:22 <Eduard_Munteanu> tomejaguar: does your Dec contain an Exp, or how?
14:50:11 <malorie> briennetheblue: ok. but I have to define time myself, don't I?
14:50:45 <tomejaguar> Eduard_Munteanu: Ah I think I was misunderstanding what Dec and Exp are.  Type, function and instance declarations are all Dec.
14:51:21 <Eduard_Munteanu> tomejaguar: any declaration really, including function definitions I think
14:51:49 <tomejaguar> Got it.  That's exactly what I wanted.
14:52:38 <briennetheblue> malorie: no
14:53:01 <briennetheblue> malorie: have you looked at some of the reactive banana examples?
14:53:03 <jrmithdobbs> so has 6.8.1 actually been released yet?
14:53:10 <jrmithdobbs> erm 7
14:55:52 <malorie> briennetheblue: I tried. afaict, the only example that actually deals with time is wave.hs, and that relies on some scheduled events queue.
14:56:20 <malorie> (which is written using some timing functions from an external package)
14:56:23 <wirrbel> so what does a haskeller usually do when he would write a "print a" command in  a side-effectful programming language (debugging)
14:56:49 <quchen> jrmithdobbs: No. The branch hasn't even been forked yet. Current estimation is a release by the end of the year I think.
14:56:58 <geekosaur> i fyou really need to see output, see the Debug.Trace module
14:57:09 <jrmithdobbs> quchen: ah, was asking because last i'm seeing is the email from 10/5 saying 11/1 for the branching
14:57:29 <geekosaur> you can also wrap stuff in a Writer / WriterT to capture trace information to be output when you're back in IO
14:57:43 <paf31> there's always Debug.Trace
14:57:46 <quchen> jrmithdobbs: The schedule has been pushed back a couple of times in the past
14:57:59 <wirrbel> thanks, I will look into Debug.Trace
14:58:23 <wirrbel> and a little more generally? What are haskell debugging patterns?
14:58:30 <quchen> jrmithdobbs: Austin mentioned there are some things that should be merged before the 7.8 branch is split off, and it seems that's not happened yt.
14:58:36 <jrmithdobbs> quchen: just trying to plan some stuff and have a project that depends on the new scheduler for some claims i'm making so just trying to figure out timing :)
14:58:39 <wirrbel> in C I use asserts a lot
14:59:05 <quchen> jmcarthur: I don't suggest starting a project that absolutely depends on 7.8.
14:59:13 <Flonk> Is there a reason that there is no Zip or Zippable typeclass?
14:59:20 <quchen> Woops, that was for jrmithdobbs above there
14:59:25 <geekosaur> assert in its natural form is still possible
14:59:26 <jrmithdobbs> quchen: it doesn't, just some of my performance claims depend on 7.8 ;p
14:59:28 <geekosaur> :t error
14:59:29 <lambdabot> [Char] -> a
15:00:01 <quchen> jrmithdobbs: Maybe wait at least until 7.8 is released to check those claims (or use 7.7 to test them)
15:00:09 <Eduard_Munteanu> Flonk: it's pretty much subsumed by Applicative if I get what you want
15:00:24 <Peaker> wirrbel: I find Debug.Trace to be a little underpowered. I use a little wrapper around it Debug.TraceUtils, which has conveniences like:  tracePutStrLn x = trace x $ return ()  (basically a putStrLn which works in any monad, with laziness caveats)
15:00:39 <jrmithdobbs> quchen: i've tested with 7.7 already, but not going to deploy off a build from an unreleased compiler :)
15:00:53 <Peaker> also:  traceId prefix x = trace (prefix ++ show x) x
15:01:01 <Flonk> Eduard_Munteanu: Ah, which I guess makes sende.
15:01:04 <Flonk> *sense
15:01:23 <quchen> jrmithdobbs: Anyway, that's the current status, I don't know much more about it.
15:01:27 <Eduard_Munteanu> Flonk: zip xs ys = (,) <$> xs <*> ys
15:01:33 <Peaker> traceAround s f = traceId (s ++ " result: ") . f . traceId (s ++ " input:)
15:01:50 <Peaker> various useful tracing wrappers such as that make tracing easier than throwing prints in most mainstream languages :)
15:01:57 <Flonk> Eduard_Munteanu: Yeah, should have thought of that.
15:02:06 <alkabetz> Peaker: Is this on Hackage?
15:02:27 <Peaker> alkabetz: http://hackage.haskell.org/package/TraceUtils
15:02:58 <alkabetz> Cool, I'll have to look at that next time I'm tracing.
15:03:25 <Peaker> alkabetz: http://hackage.haskell.org/package/file-location seems like a more advanced library than mine for the same purpose
15:03:27 <Eduard_Munteanu> Flonk: er, for the ZipList instance I mean
15:03:32 <Peaker> alkabetz: I'm just used to mine :)
15:04:51 <Eduard_Munteanu> > getZipList $ (,) <$> ZipList [1,2,3] <*> ZipList [True, False, True]
15:04:53 <lambdabot>   [(1,True),(2,False),(3,True)]
15:05:05 <Eduard_Munteanu> vs ...
15:05:15 <Eduard_Munteanu> > (,) <$> [1,2,3] <*> [True, False, True]
15:05:16 <lambdabot>   [(1,True),(1,False),(1,True),(2,True),(2,False),(2,True),(3,True),(3,False)...
15:06:18 <skypers> 23:23 < donri> skypers: you can use os() in cabal and cpp-options: -D...
15:06:23 <skypers> great! thank you :)
15:06:59 <skypers> good night
15:08:12 <donri> you too
15:08:17 <tomejaguar> How do I do a type signature in a Template Haskell Dec?
15:09:17 <briennetheblue> malorie: sorry, i think i misunderstood what you meant by handling time.  you might want to look at the function stepper though, that's how you turn a stream of events into a time varying signal
15:09:25 <Eduard_Munteanu> tomejaguar: the SigD constructor?
15:09:46 <tomejaguar> Eduard_Munteanu: Indeed, thank you :)
15:09:48 <Eduard_Munteanu> Or 'sigD'.
15:13:09 <briennetheblue> malorie: well, i guess you understand that based on your comment on wave.hs :)
15:13:28 <tomejaguar> Eduard_Munteanu: Do you know how to represent a type constraint?
15:13:38 <tomejaguar> or rather, class constraint.
15:13:51 <tomejaguar> ConstraintT doesn't have any constructors ...
15:14:21 <Eduard_Munteanu> tomejaguar: they're part of the 'Cxt'
15:14:41 <malorie> briennetheblue: the problem I'm having is, that none of the examples I've seen has any reference to actual time values
15:15:27 <briennetheblue> malorie: is what you want something that takes "Time -> a" to "Behaviour a"?
15:15:52 <malorie> I guess, yes
15:16:17 <malorie> for example, I'd like to define a function on continuous time, and then sample it for values at a certain rate
15:20:03 <madariaga> I'm looking at a haskell main function that has many do blocks, one right after the other
15:20:18 <madariaga> I didn't know this was correct syntax. Does it have any special meaning?
15:20:35 <madariaga> This is the file: http://michaeldadams.org/repos-pub/hg/haskell-pdf-presenter/file/7b4bf755a527/HaskellPdfPresenter.hs
15:20:40 <madariaga> and the function is "guiMain"
15:21:34 <Kaidelong> madariaga those do's are actually nested, I think
15:21:43 <Kaidelong> but do you know what do syntax desugars to?
15:22:23 <Eduard_Munteanu> > do { a <- [1]; return a }
15:22:25 <lambdabot>   [1]
15:22:31 <Eduard_Munteanu> > do { a <- [1]; do return a }
15:22:32 <lambdabot>   [1]
15:22:33 <madariaga> Kaidelong: I do, but I'm quite the newb
15:22:49 <Kaidelong> @undo do {a ; b <- c; do {a' ; b' <- c' } }
15:22:49 <lambdabot> <unknown>.hs: 1: 37:Parse error: Last statement in a do-block must be an expression
15:22:53 <Eduard_Munteanu> > do { a <- [1]; do return a } do return a
15:22:54 <lambdabot>   <hint>:1:30: parse error on input `do'
15:22:57 <Kaidelong> @undo do {a ; b <- c; do {a' ; b' <- c' }; d }
15:22:57 <lambdabot> <unknown>.hs: 1: 36:Parse error: Last statement in a do-block must be an expression
15:23:11 <Eduard_Munteanu> I don't think they're nested.
15:23:18 <Eduard_Munteanu> > do { a <- [1]; do return a }; do return a
15:23:20 <lambdabot>   <hint>:1:29: parse error on input `;'
15:23:32 <Eduard_Munteanu> Hrm.
15:23:42 <madariaga> Kaidelong: but for example, lines commented "*** Previews" and "*** Thumbnails" don't look nested
15:23:48 <Eduard_Munteanu> Hypothesis: he's limiting the scope of those <- bindings.
15:23:56 <acowley> Yeah
15:24:04 <acowley> It's scope management
15:24:11 <acowley> but that is not what I'd call idiomatic code
15:24:52 <acowley> You may encounter that style of scope management more frequently when binding the result of a sub do-block
15:24:54 <madariaga> acowley: so that means each bound name is local to its own do block
15:24:58 <Kaidelong> managing scope does wind up having a semantic meaning because you're changing where the lambda expressions are respective to the parenthesis
15:25:07 <acowley> madariaga: Yes
15:25:12 <Eduard_Munteanu> > do { do { a <- [1]; do return a }; do { return a } }  -- not sure why this works
15:25:14 <lambdabot>   [a]
15:25:26 <Eduard_Munteanu> I mean the second return.
15:25:37 <geekosaur> it's still in scope
15:25:39 <fizruk> Eduard_Munteanu, that's different a
15:25:48 <acowley> a useful variation is something more like: do { step1; x <- do {tmp1 <- foo; tmp2 <- bar; baz tmp1 tmp2}; print x}
15:25:50 <geekosaur> oh, right
15:25:51 <Eduard_Munteanu> Oh, lol.
15:25:59 <Eduard_Munteanu> It's a :: Expr
15:26:01 <fizruk> > do { do { a <- [1]; do return a }; do { return x } }
15:26:02 <lambdabot>   [x]
15:26:17 <monoidal> <interactive>:2:48: Not in scope: ‛a’
15:26:27 <monoidal> (that's what you get in GHCi)
15:26:32 <acowley> The idea in my little example (that may not be valid syntax) being that you don't have to think too hard about the names "tmp1" and "tmp2"
15:27:07 <madariaga> alright, thanks
15:27:12 <madariaga> good to learn something.
15:27:41 <acowley> But I really don't know why you'd write this code this way with a few giant definitions in a monster source file
15:27:49 <lpaste> madariaga pasted “redis” at http://lpaste.net/95611
15:28:12 <madariaga> now for my second question. I've added these two small functions to the haskell wiki irc bot
15:28:34 <Eduard_Munteanu> acowley: sometimes you need monster functions if you're building monster records
15:28:46 <madariaga> and they seem (to me at least) to be very much non-idiomatic
15:29:02 <acowley> Eduard_Munteanu: Agreed, but this is doing a bunch of separate imperative setup steps afaics
15:30:31 <madariaga> how could I abstract away the Either (Maybe a) handling part of the redis actions?
15:30:42 <Eduard_Munteanu> I wish we had placeholders (like metavariables) to put into types.
15:30:56 <briennetheblue>  malorie as far as i understand it you have to fmap your fn on an event that's sampling at the appropriate rate (as in wave.hs) but i'm far from an expert on reactive banana so hopefully someone can answer your question better
15:30:56 <lpaste> jfeltz pasted “Could not deduce (r ~ [a0])” at http://lpaste.net/95612
15:31:11 <jfischoff> Eduard_Munteanu: me too
15:31:32 <malorie> briennetheblue: ok. thanks
15:31:55 <Eduard_Munteanu> Because I was thinking you could use that to build extensible records if you had HasFoo classes for each field, if you could manage the types.
15:31:57 <jfeltz> is there a general solution to these problems? I feel like those errors are black-boxes
15:31:58 <Tekmo> jfischoff: I think I finally have an FRP solution for obedient
15:32:08 <jfischoff> Tekmo: oh cool
15:32:23 <jfischoff> Tekmo: sorry I have been MIA
15:32:27 <Tekmo> jfischoff: No worries :)
15:32:32 <Tekmo> What have you been up to?
15:32:44 <jfischoff> Work the baby you know
15:32:49 <Tekmo> Oh yeah :)
15:37:33 <jfeltz> nevermind, I actually need to replace the type variable with a type, anyway
15:38:19 <acowley> madariaga: fold . fold
15:38:44 <acowley> > fold . fold $ Right (Just "hey")
15:38:47 <lambdabot>   "hey"
15:39:33 <Tekmo> :t fold
15:39:36 <lambdabot> (Foldable t, Monoid m) => t m -> m
15:40:12 <madariaga> thanks
15:51:13 <S_J> !1.0 :+ !1.0 parse error on input `!' ----why?
15:51:20 <S_J> comple nbrs ^^
15:52:01 <monochrom> what is "!" doing there anyway?
15:52:53 <S_J> i removed ! and it worked, but the example showed it that way, i misundertsood it i guess
15:53:09 <ReinH> S_J: what example?
15:53:48 <monochrom> erase that example from the surface of Earth.
15:54:21 <ReinH> monochrom: we need to know which one it is so we can expunge it
15:55:11 <acowley> What if somebody who doesn't know Haskell got it as a tattoo because they thought it looked cool?
15:55:19 <quchen> S_J: "!" is for patterns and data constructors only, the former requires -XBangPatterns.
15:55:20 <ReinH> kill them
15:55:29 <monochrom> erase the tattoo and arrest the person
15:55:31 <acowley> hahaha
15:55:42 <quchen> To be fair, the Haskell logo is pretty damn cool.
15:55:42 <ReinH> it's the only way
15:56:18 <acowley> Stand back when ReinH "sanitizes the wiki"
15:56:47 <acowley> I don't really know why I don't have a neck tie with the haskell logo on it
15:57:14 <navaati> heya
15:57:34 <navaati> does anyone know about when ghc 7.8 is to be released ?
15:57:41 <quchen> "End of the year"
15:58:14 <navaati> I tried using the typehole feature thinking it was actually here, and... deception
15:58:16 <navaati> ok
15:58:18 <navaati> well
15:58:34 <navaati> seems like a good xmas present, eh ?
15:58:35 <quchen> For now you can just use implicit parameters.
15:59:11 <navaati> quchen: oh, yeah, but that's not nearly as cool :)
15:59:27 <navaati> (for now i can just use good ol' undefined)
15:59:42 <quchen> That won't do the same thing at all.
16:00:02 <quchen> Undefined makes silent holes. What you want for development is one that yells when you compile it.
16:01:06 <navaati> depends on what you use them for, what i needed right now is only the "oh i'm lazy, i'll code that later"
16:01:16 <navaati> ofc, holes provide much more
16:02:15 <monochrom> translate to agda. use agda's holes for now. after you're done, translate back to haskell. :)
16:02:30 <quchen> monochrom: Plus you get the benefit of no Halting problem!
16:02:41 <monochrom> "the problem is solved by a reduction" :)
16:02:59 <quchen> For placeholders I usually use "undefined' = undefined" in some utilities module. When I go for release I delete the definition and it won't compile when I forgot something.
16:03:15 <quchen> Unless what I forgot is the "'" of course.
16:03:19 <Tekmo> I prefer: todo = undefined
16:03:20 <monochrom> nice
16:03:52 <quchen> Tekmo: That's a good idea actually.
16:04:07 <navaati> ah, clever !
16:04:07 <augur> true holes are better
16:04:19 <ion> Any news on when we’ll get holes in GHC?
16:04:25 <quchen> 7.8
16:04:26 <navaati> ion: next version
16:04:28 <ion> awesome
16:04:33 <augur> quchen: true holes or just fake holes?
16:04:36 <navaati> yup :)
16:04:43 <quchen> Pretty holey holes.
16:04:50 <fizruk> when's 7.8 coming?
16:04:52 <hpc> holey moley!
16:04:59 <hpc> (that should be the 7.8 codename)
16:05:05 <quchen> fizruk: End of the year
16:05:06 <quchen> ish
16:05:16 <augur> i would honestly think holes would be easy to do
16:05:21 <fizruk> quchen, great!
16:05:51 <monochrom> after holes, you will want moles. then you can say, "programming by wacking moles in the holes". but wait, people already do that.
16:06:04 <quchen> augur: The new holes also suggest things that are in scope and would fit, I think that is the harder part about the implementation
16:06:28 <ion> quchen: Oh, that’s neat.
16:06:48 <navaati> is _ a valid identifier in haskell atm ?
16:06:50 <quchen> Well if it weren't for that implicit params would already be pretty much it
16:06:55 <augur> quchen: if GHC's type checker were properly exposed, that would've been doable in a few minutes of hacking :\
16:07:04 <monochrom> no. but _hi is
16:07:05 <ion> > let _ = 42 in _
16:07:07 <lambdabot>   Pattern syntax in expression context: _
16:07:07 <quchen> navaati: On its own it's not, no. You can use it in patterns though.
16:07:28 <augur> but then, GHC was initiated a long time ago, probably before anyone had any clue what a good interactive type checker should look like
16:07:32 <quchen> augur: "A few minutes"
16:07:32 <navaati> ah, yeah, forgot about it in patterns, stupid me
16:07:45 <augur> quchen: _if_ the type checker were properly exposed.
16:07:54 <augur> not merely "the way GHC is now"
16:08:05 <quchen> augur: It still sounds like a book calling a proof trivial and it takes you a week to figure it out ;-)
16:08:51 <augur> quchen: no. to make the type checker, you need to carry around your context anyway, so the context is right there with the hole, you can just look at it
16:09:18 <quchen> augur: I'm not sure how a good interactive typechecker works or even looks like, but after looking around a bit in GHC's typechecker source I'm not terribly fond of it.
16:09:35 <quchen> Which is probably what you meant.
16:09:48 <augur> quchen: what i mean was what i said :p
16:09:57 <Peaker> Tekmo: todo = error "TODO".. or maybe some TH macro that tells you where it was encountered
16:10:32 <quchen> Peaker: Is that possible without compiling everything with TH?
16:10:38 <augur> GHC was designed to type check efficiently, not to be interactive, so its almost certainly not designed in a way that makes interactivity easy
16:10:43 <Tekmo> Or maybe
16:10:45 <Peaker> quchen: maybe with CPP
16:10:45 <Tekmo> todo = error
16:10:47 <ion> #define todo (error ("todo: " ++ __FILE__ ++ ":" ++ show __LINE__))
16:10:49 <ion> or something
16:10:49 <RichyB> Peaker, can you set LANGUAGE CPP and use __FILE__ and __LINE__ macros like C compilers give you?
16:10:49 <Tekmo> As in
16:10:56 <Tekmo> todo "Fix this frubnitz"
16:11:06 <RichyB> ion, :)
16:11:32 <quchen> Tekmo: And make sure your CD drive pokes you when you supply an empty string there!
16:11:39 <Eduard_Munteanu> Can I make ghc/ghci stop at the first error(s), instead of spamming all of them at once?
16:12:04 <Tekmo> quchen: todo "" = unsafePerformCDDrive; todo str = error str
16:12:06 <quchen> Feature request: open optical tray when you have a type error. Also make an open tray a critical error.
16:12:18 <tomejaguar> Eduard_Munteanu: does -Werror do what you want?
16:12:41 <tomejaguar> I guess that would stop after showing all the errors in the first module to have an error.
16:12:46 <Eduard_Munteanu> tomejaguar: no
16:12:59 <tomejaguar> Oh sorry I misunderstood errors for warnings.
16:15:04 <Eduard_Munteanu> I guess I'll use 2>&1 | head -n 20 for now
16:16:02 <Tekmo> Eduard_Munteanu: I think there is a shortcut for that on some shells: |& head -n 20
16:16:08 <Tekmo> Or it might be &|
16:16:11 <Tekmo> I always forget
16:16:15 <Eduard_Munteanu> The latter I think.
16:16:29 <geekosaur> I think it's &| in bash. |& in {,t}csh and zsh
16:16:45 <geekosaur> bash may accept |& with a whine, depending on version
16:17:02 <jrmithdobbs> use <()
16:17:10 <jrmithdobbs> if you're going to use bashisms anyways
16:17:22 <Tekmo> What does that do?
16:17:37 <jrmithdobbs> head -20 <( grep root /etc/passwd )
16:17:43 <jrmithdobbs> eg
16:18:09 <madariaga> > fold . fold $ Right Nothing
16:18:11 <jrmithdobbs> so head -20 <( grep root /etc/passwd 2>& )
16:18:12 <lambdabot>   ()
16:18:29 <madariaga> > fold . fold $ Left (Just 3)
16:18:31 <lambdabot>   Could not deduce (Data.Monoid.Monoid (t0 c))
16:18:32 <lambdabot>    arising from the ambiguity ...
16:19:25 <geekosaur> <() and >() read / write to a program, and are replaced with a (virtual) file name. this is useful with things that require -o instead of writing to stdout, or require a filename for input. (if you use them with redirection, you must do something like `> >(foo)`)
16:19:32 * hackagebot nerf 0.5.1 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.5.1 (JakubWaszczuk)
16:20:01 <hpc> i need to keep that in mind with imagemagick
16:21:33 <geekosaur> especially useful if you want to pipe to/from multiple programs (for pipe to, use `| tee >(whatever) | whateverelse`
16:22:08 <jrmithdobbs> ya <() and >() are the best bashisms
16:22:25 <jrmithdobbs> almost as good as bash's bulitin printf ;p
16:22:42 <jrmithdobbs> (3.0+ if you needed to know)
16:24:32 <merijn>  /j #chrome
16:24:40 <merijn> yay, type fail!
16:25:21 <geekosaur> Expected IO Hask, found IO Browser :p
16:25:49 <merijn> Doesn't seem to be the channel I'm looking for anyway >.>
16:41:29 <haasn> but more importantly
16:41:33 <haasn> how do >() and <() relate to monads??
16:41:57 <Tekmo> Now you have two problems
16:43:26 <acowley> join (x :: Problem (Problem a))
16:43:54 <pavonia> What are >() and <()?
16:44:07 <Eduard_Munteanu> pavonia: bash process substitution
16:44:19 <pavonia> oh
16:44:45 <Eduard_Munteanu> No... no new lens combinators this week I'm afraid. :P
16:45:10 <acowley> Control.Lens.Bash
16:46:46 <haasn> import Control.Lens.Bashing
16:48:55 <lpaste> mangaba_leitosa pasted “word frequencies and patterns” at http://lpaste.net/95621
16:49:02 <mangaba_leitosa> Eduard_Munteanu: I tried to calculate character frequencies by position as you proposed. Just as I expected, it only gives immediately usable results when all words in the list match a common pattern. If mixed with many other random works, the usability is less obvious. Please see example in paste ^ if you are interested
16:50:03 <mangaba_leitosa> Eduard_Munteanu: under the URL above, there are char frequencies by position and common patterns calculated using a brute force method
16:50:33 <mangaba_leitosa> Eduard_Munteanu: from looking at the char frequencies, it doesn't seem that the same patterns can be generated using them
16:51:46 <Eduard_Munteanu> mangaba_leitosa: how many words are there in total?
16:52:02 <lpaste> mangaba_leitosa revised “word frequencies and patterns”: “wordFrequencies -- fixed formatting” at http://lpaste.net/95621
16:52:25 <Eduard_Munteanu> Looks like 21.
16:52:30 <mangaba_leitosa> Eduard_Munteanu: right, the list of words is included to lpaste.
16:53:23 <mangaba_leitosa> Eduard_Munteanu: 21 unique words, but 27 words in total
16:53:54 <Eduard_Munteanu> mangaba_leitosa: GATG doesn't seem to match the first word, ACGT, at distance 1. :/
16:53:55 <structuralist> what's the rigorous definition of a *greatest* (or least) fixed point of an endofunctor?
16:54:22 <Eduard_Munteanu> structuralist: there's a relation of definedness
16:54:37 * hackagebot system-posix-redirect 1.1.0.1 - A toy module to temporarily redirect a program's stdout.  http://hackage.haskell.org/package/system-posix-redirect-1.1.0.1 (LiyangHu)
16:55:01 <mangaba_leitosa> Eduard_Munteanu: they are not supposed to match all words, just a maximum number of words as compared to all possible patterns. each of ["GATG", "ATGC", "ATGT"] patterns matches 5 words from the list
16:55:21 <Eduard_Munteanu> structuralist: e.g. ⊥ < Just ⊥ < ....
16:55:22 <mangaba_leitosa> Eduard_Munteanu: (5 words including repetitions, not unique words)
16:55:52 <lpaste> madariaga revised “undone”: “undone” at http://lpaste.net/410690111487868928
16:55:53 <Eduard_Munteanu> structuralist: the least fixed point means the least according to that relation
16:56:22 <madariaga> hlint was really helpful in actually *learning* about new stuff
16:56:25 <madariaga> pretty cool.
16:56:29 <structuralist> Eduard_Munteanu: that's an ordering on terms of a type, but I'm asking about fixed points of endofunctors, which are themselves types. is it the same ordering?
16:56:55 <madariaga> helped me find where and when to use liftM, either, etc
16:56:55 <structuralist> is there a definedness relation on types?
16:57:29 <mangaba_leitosa> Eduard_Munteanu: 5 out of 27 is not much, but all other possible patterns match from 1 to 4 words each
16:58:02 <Eduard_Munteanu> structuralist: there is, for fixpoint operators such as mu.
16:58:14 <Eduard_Munteanu> structuralist: https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
16:58:51 <mangaba_leitosa> Eduard_Munteanu: also, this is not a real life example. In real data, those "best" patterns are expected to match significantly more words than the rest of the patterns
16:59:09 <Eduard_Munteanu> mangaba_leitosa: I'm not sure how to formulate the criteria though
16:59:40 <mangaba_leitosa> Eduard_Munteanu: the criteria for defining the pattern in general or based on char frequencies?
16:59:48 <Eduard_Munteanu> mangaba_leitosa: generally
16:59:59 <acowley> structuralist: I suspect that http://www.cs.nott.ac.uk/~rcb/G53PAL/FPandGC.pdf will be of interest
17:00:11 <prooftechnique> mangaba_leitosa: I wrote something for character frequencies for this kind of data, though not by position like you have. I don't really know how it scales to large volumes of data, either
17:01:58 <structuralist> acowley: thanks. is the idea to generalize Galois connections to adjunctions?
17:02:54 <Eduard_Munteanu> structuralist: mind we're talking about isorecursive types, you don't really get undefined types, so it's not really about definedness for types.
17:02:59 <mangaba_leitosa> Eduard_Munteanu: let Count(max_distance, pattern, [(Word, Frequency)]) be the total number of occurrences of Pattern in words_frequencies (taking frequencies into acount). The patterns we need are those maximizing Count among all our words
17:03:07 <acowley> Yeah, but I'm fuzzy on the area. The main thing I was thinking about is that GCs are intimately tied to the lattice you want to consider for least and greatest FPs
17:03:20 <structuralist> Eduard_Munteanu: yeah I was confused about what a type-level _|_ would be
17:03:30 <structuralist> I'm still confused
17:03:53 <acowley> If only we had a lazy type checker, we could get compile errors at run time!
17:04:05 <mangaba_leitosa> Eduard_Munteanu: "occurrences of Pattern" means that the distance between the pattern and the word <= max_distance
17:04:06 <enthropy> acowley: there is a -fdefer-type-errors
17:04:14 <mangaba_leitosa> prooftechnique: can I see your code? :-)
17:04:17 <acowley> The future is now!
17:04:26 <enthropy> it's rather nice to have that in your .ghci
17:04:27 <Eduard_Munteanu> structuralist: take lists for example: [a] ~ 1 + a * [a]. Which you can write as a fixed point of List a r = 1 + a * r.
17:04:40 <structuralist> ok
17:04:46 <prooftechnique> Let me try to dig it up. It was really basic. I think I wrote it for some project euler style thing
17:04:58 <structuralist> so what's the ordering on fixed points of List?
17:05:03 <structuralist> er, List a
17:05:15 <mangaba_leitosa> Eduard_Munteanu: in our example, the patterns ["GATG", "ATGC", "ATGT"] are those for which Count(1, pattern, [(Word, Frequency)]) == 5
17:05:18 <enthropy> so when you break one function (in some limited way that's a type error not a syntax error), you can still run/check types for other things in the file
17:05:38 <Eduard_Munteanu> structuralist: well, Mu(List a) ~ 1 + a * List a < 1 + a * Mu(List a) < ...
17:06:27 <navaati> what is the lens to operate on the nth element of a list ?
17:06:46 <structuralist> "1 + a * List a" looks ill-typed to me
17:07:03 <mangaba_leitosa> prooftechnique: actually, I already have frequency calculation. Now I need to generate patterns based on it :-)
17:07:06 <structuralist> List :: * -> * -> *, right?
17:07:25 <enthropy> > [1 .. 10] & ix 5 .~ 2
17:07:28 <lambdabot>   [1,2,3,4,5,2,7,8,9,10]
17:07:30 <Eduard_Munteanu> structuralist: er, yeah, I mean [a]
17:07:31 <acowley> There's an implicit mu hiding in there :P
17:07:39 <prooftechnique> mangaba_leitosa: Ah, okay. The code I had was just a one or two liner based on http://rosalind.info/problems/dna/
17:07:49 <enthropy> navaati: ^^
17:07:54 <prooftechnique> You probably need something more robust, regardless
17:08:14 <mangaba_leitosa> prooftechnique: I'm also just playing with DNA :-)
17:08:16 <Eduard_Munteanu> structuralist: you can say  [a] ~ Mu(List a) ~ 1 + a * Mu(List a) < 1 + a * (1 + a * Mu(List a)) < ...
17:08:16 <structuralist> [a] is Mu(List a) by definition, right?
17:08:32 <Eduard_Munteanu> structuralist: it's not, it's just isomorphic to it.
17:08:48 <Eduard_Munteanu> @src Mu
17:08:48 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
17:08:55 <structuralist> ohh I think I get it
17:08:57 <structuralist> maybe
17:08:59 <structuralist> hmm
17:09:15 <structuralist> no
17:09:30 <acowley> I think it does help if you write it out: μ. 1 + a * μ
17:10:01 <structuralist> (I'm trying to understand the difference between data and codata)
17:10:23 <navaati> enthropy: but this is not a lense i can compose with others right ?
17:10:37 <enthropy> why not?
17:10:44 <acowley> μ vs ν
17:11:17 <enthropy> > [(1,'a'),(2,'b')] & ix 1 . _2  .~ 'c'
17:11:19 <lambdabot>   [(1,'a'),(2,'c')]
17:11:39 <Eduard_Munteanu> structuralist: oh... data is finite, codata is possibly infinite and productive.
17:11:46 <structuralist> yeah, I know that much
17:12:17 <navaati> enthropy: "qwerty"^.ix 0 gives me an error
17:12:19 <structuralist> I'm trying to get a categorical grasp on it
17:12:40 <structuralist> starting with the difference between least and greatest fixed points of endofunctors... maybe that's the wrong place to start
17:12:49 <Eduard_Munteanu> structuralist: I don't think there's the same duality as in other CT co- things.
17:13:13 <enthropy> navaati: I think that doesn't work because they didn't want you to get error from  ""^.ix 0
17:13:17 <Eduard_Munteanu> structuralist: you can relate induction and coinduction
17:13:26 <enthropy> you can do   "qwerty"^? ix 0
17:13:31 <structuralist> initial algebras and terminal coalgebras are pretty dual, right?
17:13:39 <structuralist> aren't those data and codata respectively?
17:13:43 <haasn> navaati: Char isn't a Monoid
17:13:46 <structuralist> ignoring negative occurences
17:13:58 <haasn> navaati: ix is a traversal, *not* a lens
17:14:03 <haasn> so reading out requires a monoid
17:14:09 <Eduard_Munteanu> structuralist: in induction you work on structurally-decreasing terms, while on codata you leave a "tail" of increasing terms as you go to infinity
17:15:04 <briennetheblue> sometimes i wish there were fmapping lens operators so that "f$^.a.b" = "f <&> (^.a.b)"
17:15:09 <Eduard_Munteanu> structuralist: yeah, I think that is one connection
17:15:31 <haasn> briennetheblue: f <&> view (a.b) -- is fine imo
17:15:34 <navaati> haasn: hum... don't understand why the monoid...
17:16:05 <structuralist> is there any reason to associate monads with data and comonads with codata?
17:16:49 <haasn> navaati: (^.) reads out using the Const x Functor; but a traversal requires the argument to be an Applicative instead of a Functor (as with a lens). Const x's Applicative instance requires Monoid x
17:16:53 <haasn> to satisfy the laws
17:17:15 <merijn> structuralist: Nope
17:17:31 <haasn> structuralist: maybe the free (co)monad is relevant?
17:17:32 <Eduard_Munteanu> structuralist: certain infinite coinductive structures do fit comonads, because you are guaranteed to produce an element in finite time, if you look at e.g. extract on Streams.
17:17:33 <merijn> structuralist: Hell, something could be both a monad and a comonad
17:18:04 <structuralist> is there any reason free monads would be data as opposed to codata?
17:18:09 <briennetheblue> i guess so haasn i just hate brackets for some reason :o
17:18:14 <structuralist> (N.B. free)
17:18:54 <structuralist> in a language that would hypothetically distinguish them
17:19:59 <navaati> i tought that in lens, the "may fail" kind of lens (which is the case for ix, eh ?) were Prisms, not traversal
17:20:14 <structuralist> motivation for this question: terminal F-coalgebras (vF ~ FvF) are naturally thought of as behaviors of systems. but it seems convenient to write these out using do-notation, treating vF as Free F Void
17:20:31 <navaati> and why would ix be a traversal ? It does operate on only one element
17:21:18 <structuralist> but I'm wondering if that's only possible because Haskell doesn't distinguish between data and codata; it seems strange to think of Free F [anything] as codata
17:21:18 <acowley> A Prism is a 0-or-1 Traversal
17:21:39 <structuralist> maybe it's not actually strange, I don't know
17:21:40 <Eduard_Munteanu> structuralist: for dynamic systems, don't you want codata?
17:21:46 <haasn> navaati: prisms are specific cases of traversals
17:22:05 <briennetheblue> 0 or 1 traversals :)
17:22:17 <Eduard_Munteanu> structuralist: say, represented as Streams of states.
17:22:41 <structuralist> yes, exactly; and then I found that using do-notation along with the vF ~ Free F Void coincidence to write out these systems is convenient
17:22:54 <structuralist> but I'm wondering if that's sketchy and only possible because of Haskell's laziness
17:23:06 <navaati> haasn, briennetheblue: oooooh.
17:23:22 <navaati> so ix is actually a prism, right ?
17:23:41 <briennetheblue> kinda like how Maybe is a 0 or 1 length List
17:23:42 <Eduard_Munteanu> structuralist: hm... I think Free F might be an algebra for a monad, which gives you an F A -> A, IIRC.
17:23:57 <structuralist> Free F is the free monad on F
17:24:16 <monochrom> Free F Void = Void + F (Free F Void). it looks like it is using nu, not mu
17:24:50 <Eduard_Munteanu> structuralist: yes but I wonder if you get algebras in that sense, because those would match the behavior you want, namely that you can extract a state out of them.
17:24:55 <structuralist> monochrom: how?
17:25:42 <mangaba_leitosa> Eduard_Munteanu: oh, I have an idea. I probably need a markov chain, not just raw char frequencies :-)
17:26:52 <monochrom> given the act of using Free F Void where you expect nu F.
17:28:32 <structuralist> monochrom: then is it not really the free monad on F?
17:28:45 <monochrom> that one I don't know
17:29:03 <structuralist> free monoid on a set is finite lists only
17:29:18 <acowley> You could try asking in ##categorytheory
17:29:19 <structuralist> free monad on an endofunctor I'd expect to be a finite number of F's only
17:29:59 <monochrom> ah, but then it may depend on the actual category and objects
17:31:33 <structuralist> is there a language that does rigorously distinguish between data and codata?
17:31:45 <Eduard_Munteanu> structuralist: it is finite, but every bind should be adding a layer you can observe if you unwind it. Maybe that helps. :/
17:31:55 <monochrom> I think coq and agda do
17:32:10 <Eduard_Munteanu> structuralist: Agda does, but it doesn't distinguish only data from codata, you have shades inbetween.
17:32:30 <Eduard_Munteanu> structuralist: as in, you can have types that are partly inductive and partly coinductive.
17:33:05 <Eduard_Munteanu> e.g. a binary tree inductive on the left branch and coinductive on the right.
17:33:34 <briennetheblue> is it actually practical to use types like (ListF a r) when it's such a PITA to define Functor (List a) since you have to constantly wrap and unwrap a newtyped List rather than just using type List = ...
17:33:54 <structuralist> XDeriveFunctor
17:34:11 <Eduard_Munteanu> briennetheblue: you can define an isomorphism between the two
17:34:21 <briennetheblue> Eduard_Munteanu: how?
17:34:28 <monochrom> it is practical or impractical depending on what you do
17:34:46 <Eduard_Munteanu> briennetheblue: well, I just mean you can convert an ordinary list to and from that
17:34:47 <briennetheblue> i want a functor both for List and (ListF a)
17:35:22 <Eduard_Munteanu> briennetheblue: don't you mean Mu (ListF a)?
17:35:28 <monochrom> "is tool T practical" is a pseudoquestion. why is it so hard to accept that the correct question is "is tool T practical for problem P"
17:35:45 * Eduard_Munteanu has to go get some sleep
17:35:56 * derdon likes hammers
17:36:05 <briennetheblue> no, (ListF a) i think
17:36:08 <briennetheblue> hmm
17:36:13 <dmwit> Can I use fixpoint functors to teach high schoolers how to drive robots.
17:36:26 <monochrom> ok yikes, "T" looks like a hammer, doesn't it? :)
17:36:45 <monochrom> "if all you see are nails, the letter T looks like a hammer" :)
17:37:00 * dmwit like T-squares
17:37:09 <enthropy> @quote turnstile
17:37:09 <lambdabot> No quotes match. Are you typing with your feet?
17:37:13 <zomg> T also looks like a nail :P
17:37:13 <dmwit> you can use them as hammers in a pinch
17:37:19 <briennetheblue> ListF is just an example though, this is what i have https://github.com/soapie/daily-programmer/blob/master/E-135-Arithmetic%20Equations/Intersperse.hs
17:37:50 <structuralist> is there a dual to do-notation for comonads?
17:38:16 <monochrom> I haven't seen one. but could we invent one now and call it "od"? :)
17:38:56 <structuralist> apparently so: http://www.cl.cam.ac.uk/~dao29/drafts/codo-notation-orchard12.pdf
17:38:59 <acowley> D. Orchard has a paper on that
17:38:59 <Eduard_Munteanu> structuralist: I've seen proposals but one problem is how you get the value *into* the comonad, because that seems to be the tricky thing for them.
17:39:03 <acowley> there you go
17:39:32 <monochrom> DO rchard. damn me. :)
17:39:44 <ion> haha
17:40:05 <geekosaur> shouldn't that be codo?
17:40:14 <Eduard_Munteanu> The Benoit B. Mandelbrot of CS.
17:40:20 <briennetheblue> i guess by practical i meant that i don't want to be constantly wrapping and unwrapping :(
17:40:21 <acowley> He got a job as a corrections officer
17:40:32 <acowley> CO D.O rchard
17:40:36 <ion> “Dominic Orchard and Alan Mycroft” – they should call the comonad do “am”.
17:46:35 <redscare> are people familiar with attoparsec? I am parsing a file and do not care about the header, so would like to say something like "many anyChar *> bodyParser" but I obviously can't do that since many anyChar will just match the whole input…
17:47:10 <acowley> What separates the header from the body?
17:47:13 <dmwit> Teach your parser how to recognize when the header is done.
17:48:41 <redscare> what separates the header from the body is the first thing that the body parser will be able to match
17:48:51 <monochrom> "many anyChar" is the wrong way to think about it
17:49:18 <dmwit> How about wholeParser = bodyParser <|> (anyChar *> wholeParser)?
17:49:21 <briennetheblue> i suppose i'm wondering if the f-algebra style is actually a useful way to structure your data or just an interesting thought experiment
17:49:42 <structuralist> briennetheblue: check out the compdata package
17:49:57 <byorgey> better make that  wholeParser = try bodyParser <|> (anyChar *> wholeParser)
17:50:00 <redscare> dmwit: that's very creative. is that the "right way"?
17:50:01 <structuralist> it solves the expression problem
17:50:07 <monochrom> you may say, "but I have always been doing that with regex, .*monochrom". ok, but the regex engine does expensive, elaborate backtracking. are you ready for even more expensive, elaborate backtracking too?
17:50:27 <monochrom> thing is, attoparsec exactly avoids backtracking
17:50:40 <briennetheblue> structuralist: thanks, that's new to me :)
17:50:40 <geekosaur> also relying on backtracking in regex is just bad
17:50:41 <dmwit> As byorgey says, depending on exactly what you meant by "the first thing that the body parser will be able to match", you may need to add some backtracking.
17:50:44 <dmwit> But don't overdo it.
17:50:52 <acowley> but byorgey's bringing backtracking back!
17:51:01 <dmwit> actually he's not
17:51:06 <dmwit> try = id -- =(
17:51:11 <redscare> so I'm just trying to learn to use attoparsec, and in my example it's a simple literal string that marks the beginning of a "body"
17:51:28 <redscare> so i could do a "takeWhile STRING"
17:51:36 <acowley> Is it really?
17:51:41 <byorgey> oh, this is attoparsec?  I don't know anything about attoparsec
17:51:52 <dmwit> http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/src/Data-Attoparsec-ByteString-Internal.html#try
17:51:54 <redscare> but that felt like code duplication since I already encoded that in the parser of the body
17:51:58 <dmwit> And it *lies* about this being okay.
17:52:02 <dmwit> I have been bitten by this before.
17:52:03 <byorgey> eek
17:52:21 <dmwit> It says "attoparsec parsers always backtrack on failure" but this is untrue. =(
17:53:00 <acowley> dmwit: How so?
17:53:13 <acowley> Now I'm scared of the massive amount of attoparsec code I've written :/
17:53:39 <dmwit> It will probably take me 30 minutes to reconstruct the example, but it's something like (a >> b) <|> c backtracks if a fails, but not if b does.
17:53:44 <dmwit> Or something like that.
17:54:05 <acowley> Ah
17:54:13 <redscare> monochrom: so what's the "right way" to think about it?
17:54:23 <dmwit> (And there's no combinator to "group things" together so that it will backtrack from either failure.)
17:54:23 <monochrom> what everyone says
17:54:32 <acowley> Parsers are great at hiding bugs
17:55:48 <dmwit> You don't notice much, because fewer of attoparsec's main functions actually use the combinators under the hood.
17:56:10 <dmwit> e.g. in Parsec string is like mapM char, but in attoparsec string is made from whole cloth so that it backtracks correctly.
17:58:29 <acowley> I think I have actually hit that.
18:01:32 <redscare> so is this solution: wholeParser = bodyParser <|> (anyChar *> wholeParser) efficient? it might be an old way of thinking, but it seems that recursing for /each/ character before the bodyParser is excessive
18:01:59 <dmwit> You can probably do something more efficient in some cases.
18:02:13 <dmwit> e.g. if you're looking for a static string there's that one efficient string search algorithm
18:02:16 <dmwit> KMP or whatever
18:02:19 <monochrom> it depends. (what doesn't.)
18:02:51 <dmwit> But since you won't tell us anything about bodyParser no matter how hard we ask, you can hardly expect us to give good advice. =)
18:02:54 <monochrom> it is efficient if nothing is known about the prefix to be skipped and you insist "I am solving the most general problem"
18:03:18 <monochrom> it is beyond inefficient --- it is stupid --- if anything is known about the header.
18:04:41 <Fuuzetsu> Any nice and short equivalent to lens ‘over _2 f (a, b)’ or do I have to succumb to lens?
18:05:13 <Fuuzetsu> Oh, that doesn't do what I want actually. Ignore me.
18:05:26 <redscare> dmwit, monochrom: that's fair. so suppose that bodyParser starts out with "string "ABCD"", but I don't want to type that twice
18:05:28 <briennetheblue> fmap f, right?
18:05:48 <redscare> and on the first occurence of "ABCD" i know i am in the body
18:06:02 <briennetheblue> > fmap (+ 1) (0, 0)
18:06:03 <lambdabot>   (0,1)
18:06:07 <monochrom> then don't type that twice.
18:06:11 <Fuuzetsu> briennetheblue: Actually mapping over a list of tuples and I want to apply f to second element of each one.
18:06:40 <Fuuzetsu> I just wrote a helper for mapping over it but I think I might get away with fmaping fmap
18:07:07 <alkabetz> @let (<$$>) = fmap . fmap
18:07:09 <lambdabot>  .L.hs:141:10:
18:07:09 <lambdabot>      No instance for (Functor f0) arising from a use of `fmap'...
18:07:16 <Fuuzetsu> overSnd = fmap fmap fmap
18:07:24 <Fuuzetsu> with overSnd :: (b -> c) -> [(a, b)] -> [(a, c)]
18:07:55 <briennetheblue> > (fmap . fmap $ (+1)) [(0,0),(1,1)]
18:07:57 <lambdabot>   [(0,1),(1,2)]
18:08:10 <alkabetz> Huh, I wonder why my (<$$>) didn’t work
18:08:41 <geekosaur> at a guess, monomorphism restriction intervened somewhere
18:08:55 * alkabetz shakes fist at the monomorphism restriction
18:09:24 <briennetheblue> "fmap fmap fmap" is just an ugly way of writing "fmap . fmap" :p
18:09:49 <enthropy> traverse . _2 -- is another option
18:10:04 <enthropy> maybe there's a better word for traverse that does the same thing
18:10:07 <jamesjb> > map (second (+ 1)) [(0, 0), (1, 1)]
18:10:08 <lambdabot>   [(0,1),(1,2)]
18:10:12 <enthropy> > [(1,'1')] & traverse . _2 %~ succ
18:10:14 <lambdabot>   [(1,'2')]
18:10:30 <Fuuzetsu> alkabetz: I was actually going to say ‘don't forget to shake your fist at monomorphism restriction’
18:10:45 <alkabetz> lol
18:12:08 <monochrom> "(<$$>) = fmap . fmap" is forbidden by the monomorphism restriction
18:12:20 <briennetheblue> what a tyrant
18:14:38 <dmwit> redscare: Does bodyParser actually start out with string "ABCD"?
18:15:59 <fragamus> Hey is there a persistent hash map
18:16:13 <dmwit> acowley: In case you're still interested, I found a paste with this kind of problem in it.
18:16:17 <dmwit> http://lpaste.net/85932
18:16:37 <monochrom> yes, the standard hash map is already persistent
18:17:09 <dmwit> fragamus: See
18:17:13 <dmwit> ?hackage unordered-containers
18:17:14 <lambdabot> http://hackage.haskell.org/package/unordered-containers
18:17:24 <monochrom> it comes with Haskell Platform
18:17:38 <fragamus> I did it seems memory based
18:17:50 <monochrom> what does that mean?
18:17:53 <geekosaur> wrong persistent there
18:18:03 <monochrom> ok, then I don't know
18:18:13 <geekosaur> fragamus means lasts beyond a single process
18:18:24 <geekosaur> so, disk backed or etc.
18:18:25 <dmwit> Oh, that kind of persistent.
18:18:26 <briennetheblue> > [(0,0), (1,1)] <&> fmap (+1)
18:18:27 <fragamus> Yah
18:18:27 <lambdabot>   [(0,1),(1,2)]
18:18:34 <geekosaur> (or memcache, etc.)
18:24:49 <redscare> dmwit: yep
18:25:41 <dmwit> I don't think you can do very much better than just looking at every character to see if "ABCD" starts there, then.
18:28:56 <acowley> Something Boyer-Moore'ish would be better than checking every character
18:29:48 <acowley> Thanks for the example dmwit, I'm pretty sure I have hit that. But I didn't know that try was id! I bet that would have solved some mysteries in the past.
18:30:03 <augur> seriously, someone explain the monomorphism restriction
18:30:06 <augur> it makes no sense
18:30:38 <dmwit> acowley: Would it? Even with a needle like "ABCD"?
18:30:45 <heatsink> It's supposed to facilitate sharing
18:31:01 <augur> heatsink: is that to me?
18:31:09 <heatsink> By ensuring that nullary global functions are thunks
18:31:10 <heatsink> yes
18:31:19 <augur> heatsink: elaborate please?
18:31:49 <heatsink> The idea is that, if you define a variable
18:31:59 <heatsink> let x = ... in f x (g x)
18:32:03 <monochrom> I would think the explanation and examples in the Haskell 2010 report suffice.
18:32:03 <dmwit> (Just to double-check: did you read the wiki page? It explains the motivation for the MR in some detail.)
18:32:06 <heatsink> You expect x to be evaluated once
18:32:17 <augur> heatsink: sure
18:32:32 <heatsink> But if x is polymorphic, it may be evaluated more than once
18:32:40 <augur> heatsink: how so
18:32:56 <heatsink> It becomes a function taking type class parameters
18:33:03 <heatsink> Are you familiar with how type classes are implemented?
18:33:08 <augur> yes
18:33:36 <augur> ah, is the monomorphism restriction only an issue when type classes are involved?
18:34:07 <heatsink> That's the motivation for it.  It applies whether or not type classes are involved.
18:34:35 <augur> i couldve sworn there were examples of it causing "problems" (conceptual ones) for just polymorphic cases
18:34:48 <augur> is that a misremembering on my part?
18:35:44 <monochrom> try "x = id" or "y = \x -> [x,x,x]". will not have a problem.
18:35:45 <geekosaur> at the very least it has to be evaluated once per type it gets instantiated at. I think for typeclasses it also, because it's really a function taking a dictionary as a parameter, doesn't get shared anyway because it's no longer a "constant applicative form" but an actual function
18:35:50 <dmwit> Okay, maybe I was wrong. Maybe Boyer-Moore/KMP can do better than brute force even for a needle like "ABCD".
18:36:22 <heatsink> The MR might cause surprises without type classes, I dunno
18:36:26 <augur> geekosaur: for merely polymorphic types, and not constrained types, it only needs to be evaluated once
18:36:32 <augur> geekosaur: in principle, anyway
18:39:51 * hackagebot mpvguihs 0.1.1 - A minimalist mpv GUI written in I/O heavy Haskell.  http://hackage.haskell.org/package/mpvguihs-0.1.1 (pse)
18:43:53 <augur> conal: :)
18:45:41 <augur> conal: these sorts of meaning drifts/argument drifts are fairly common in natural language. pinker has a bunch of cute examples in The Stuff of Thought
18:45:58 <augur> sometimes its literally one generation
18:46:41 <conal> augur: thx for the pointer.
18:46:53 <augur> conal: also regarding your just-now tweet
18:47:15 <augur> you mentioned it in the context of "is comprised of". That's a passive-ish construction. there are two primary syntactic frames for "comprise"
18:47:18 <augur> X comprises Y
18:47:22 <augur> and X is comprised of Y
18:47:48 <augur> people generally don't have much of a sense of what a word means in isolation, especially if you try to extract it from a construction like that
18:48:04 <augur> what you want to do is ask people what each of those constructions mean
18:48:27 <augur> usually with passives, "X Vs Y" = "Y is Ved by/of/... X"
18:49:53 * hackagebot husk-scheme 3.14 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.14 (JustinEthier)
18:50:08 <carter> acowley: hello!
18:52:10 <augur> conal: is Ved = flip V   so while we expect "consist" to mean the same thing in both (the passivization contributing the meaning difference), most people wont necessarily have conscious knowledge of which parts contribute which meaning differences
18:52:33 <augur> er, not consist, comprise
18:52:34 <augur> :p
18:52:34 <conal> augur: do you use "comprise" consistently with this rule ("Y is Ved by/of/... X")?
18:53:02 <redscare> what do people do for data visualization from haskell? i see a few plotting programs on hackage, any experience or recommendations for those?
18:53:04 <conal> augur: i mean consistently with the rule and with understanding of "is comprised of"?
18:53:05 <augur> conal: for me, it is consistently the case that    "X consists of Y" == "Y consits of X" == "X containts/is made up of Y"
18:53:21 <augur> damnit i keep writing consist >_<
18:53:50 <augur> "X comprises Y" == "Y is comprised of X" == "Y contains/is made up of X"
18:54:21 <augur> the parts comprise the whole, the whole is comprised of the parts, the whole is made up of the parts
18:55:10 <conal> augur: i don't think i've seen that meaning of "comprise" in a dictionary. only the reverse.
18:55:36 <augur> conal: probably true. most "fancier" dictionaries tend to be normative, not descriptive.
18:55:42 <augur> i suspect MW records it. Wiktionary does.
18:55:43 <conal> augur: https://www.google.com/search?q=comprise
18:56:21 <augur> conal: yes, i know. like i said, dictionaries aren't accurate reflections of actual language usage, they're more like IEEE standards
18:56:47 <conal> augur: i'm guessing most people do not use "comprise" the way you (apparently) do, even if they use "is comprised of" the way you do.
18:56:50 <carter> redscare: thats still a nascent area
18:56:56 <augur> (only, they're run by language snobs, as opposed to members of the relevant professional community)
18:56:57 <chrisdone> i use comprise as 'conists of' or 'contains'. but generally i don't use the word, other words seem satisfactory
18:57:11 <carter> redscare: though all the newer efferts are building on top of diagrams
18:57:15 <augur> conal: well, we'll have to do a study to really know :)
18:57:20 <chrisdone> and words like this that people confuse aren't worth using
18:57:27 <conal> augur: hence my poll.
18:57:45 <augur> conal: yes but you need to ask the question with both syntactic frames, as i said
18:57:57 <redscare> carter: that's too bad. haskell is very well suited to the type of data analysis i am doing, but intermediately visualizing my results speeds me up too much to give it up.
18:57:58 <augur> asking just about "comprise" in one single frame is going to tell you nothing
18:58:16 <carter> redscare: there are tools
18:58:43 <augur> conal: http://www.merriam-webster.com/dictionary/comprise
18:58:57 <carter> we just dont have magically awesome stuff yet
18:58:58 <augur> see the usage discussion
18:59:09 <conal> augur: ah. first i've seen of the reversed sense.
18:59:23 <chrisdone> yeah, that's weird
18:59:40 <augur> conal: strangely, "comprising" is the other way for me
18:59:51 <heatsink> Like 'constitute' with subject and object reversed
18:59:52 <conal> augur: wow.
18:59:53 <augur> "comprising" = "consisting of/made up of"
19:00:03 <carter> redscare: the chart lib is a decent basic chartting lib
19:00:16 <chrisdone> the US comprises 50 states. therefore, the states are comprised by the US
19:00:19 <carter> and the various gnuplot based tools are nice
19:00:19 <augur> this is not too surprising tho. the word is rare, and therefore each form is likely to be treated separated by the brains learning algorithm
19:00:28 <chrisdone> so saying "the US is comprised of" sounds  *really* weird
19:00:53 <augur> conal: actually i dont know, maybe its not that way. its hard to tell.
19:01:05 <chrisdone> it's like saying "the US is constituted of"
19:01:16 <redscare> carter: thanks. maybe a free time project for me then :)
19:01:29 <augur> chrisdone: idiolectal variation :)
19:02:18 <chrisdone> augur: yeah, which is pretty much why i never use this word. it's lost any useful meaning imo. there are plenty of other non-ambiguous words that do its job better
19:02:23 <carter> redscare: good data vis libs are hard work
19:02:45 <carter> i've spent the past 1.5 years building substrates to support what i want in data vis
19:02:47 <augur> if you run the same statistical learning algorithm on slightly different data sets, you expect slightly different results. no two people are exposed to the exact same language environment, so no two people acquire the exact same grammar/semantics/whatever.
19:03:17 <carter> redscare: theres also a few other folks doing data vis rsearch tooling in haskell
19:03:17 <chrisdone> augur: sure, but we've a great deal of words that aren't ambiguous like that
19:03:25 <augur> chrisdone: yeah its a tricky word. but until conal's tweet, i certainly didn't know it was!
19:03:27 <chrisdone> 'contains' and 'constitutes'' are good
19:03:30 <augur> i thought everyone had my usage! :)
19:03:49 <chrisdone> hehe =)
19:04:11 <chrisdone> at school i remember learning the word, the teacher making a big deal about its proper use
19:05:47 <conal> augur: tricky indeed. the double-inverted use (like yours) of "is comprised of" always bugs me, and especially in teaching material and research writing.
19:06:24 <chrisdone> conal: it's like irregardless =p
19:06:25 <conal> i've wondered how people can reconcile that use with "comprise". and with "compose" vs "composed of".
19:06:32 <conal> chrisdone: yow! :p
19:06:45 <copumpkin> chrisdone: nice blog post!
19:06:50 <chrisdone> copumpkin: thanks!!
19:06:52 <carter> chrisdone: what post?
19:06:57 <augur> conal: well for me, it seems to be uniformly the case that comprise = flip compose
19:07:03 <chrisdone> carter: http://chrisdone.com/posts/twitter-problem-loeb
19:07:23 <augur> conal: which shouldn't be hard to reconcile at all!
19:07:40 <conal> augur: note that that MW page (http://www.merriam-webster.com/dictionary/comprise) gives two examples of comprise, both with the whole-comprises-parts sense.
19:08:04 <augur> conal: for usage 1 and 2, yes. usage 2 has parts-comprise-whole
19:08:39 <augur> sorry, usage 3 has parts-comprise-whole
19:08:40 <augur> derp
19:09:22 <Transhumanist> I <3 Haskell
19:09:33 <carter> cool
19:10:11 <conal> augur: you use comprise = flip compose *and* parts-comprise-whole ? so you say that whole composes parts??
19:10:30 <Transhumanist> is composed of
19:12:10 <augur> hmm.. maybe i said the wrong thing. this is why its tricky talking about the words, conal!
19:12:15 <monochrom> the mathematicians do it right. "a complexifying lambda model is an icosatuple <A1, A2, A3, ..., A20> where..."
19:12:22 <augur> "X comprises Y" = "Y is comprised of X" = "Y is made up of X"
19:12:39 <augur> "Y is composed of X" = "Y is made up of X"
19:12:49 <augur> i dont know that i ever say "X composes Y"
19:13:31 <augur> (except as in "Bach composed sonata", which is obviously a different "compose"; also as in function composition, etc etc)
19:13:46 <heatsink> An agent composes Y of X.  Y is composed of X.
19:14:15 <conal> augur: composes is implied by your "is Ved of" rule.
19:14:30 <augur> conal: how do you mean?
19:15:11 <fl00r> the usage notes in http://en.wiktionary.org/wiki/comprise are actually exactly the comprise vs. compose example
19:16:50 <conal> is-Ved-of = flip Vs, so Vs = flip (flip Vs) = flip is-Ved-of
19:17:19 <augur> anyway, the real moral of this story is: if you want to understand usage of a word, you have to ask about whole constructions, and then figure out the meaning, rather than asking about the words
19:17:31 <augur> conal: yes, well, you'd like to think, wouldn't you. :)
19:17:56 <augur> conal: unfortunately, not all verbs have passive forms, and some verbs are only passive!
19:18:01 <conal> augur: it's your rule. assuming you're okay with flip . flip = id
19:18:15 <augur> conal: its not the semantics thats the problem, its the syntax/morphology
19:19:16 <prooftechnique> A whole comprises parts, whereas parts compose a whole
19:19:32 <augur> conal: think of it like this: syntax and morphology pretty print the semantics. so: its usually the case that  pretty (flip V) = pretty V ++ "-ed"  (or "-en")
19:20:08 <augur> or maybe you want to add "is" ++ in there as well
19:20:13 <augur> but sometimes V is matched on:   pretty (flip compose) = "is composed of"
19:20:15 <conal> prooftechnique: in my use they do. but not in augur's. and not in  many people's.
19:20:19 <augur> but there's no definition for pretty compose
19:20:43 <conal> prooftechnique: my guess, however, is that most of those people do not use "comprise" (or "compose").
19:20:45 <augur> so there's no verb "compose" for me, not with the meaning you intend, anyway. there's only the passive "is composed of"
19:20:53 <augur> its a weird thing, but it happens all the time in language
19:21:20 <augur> verbs that have only a passive form are called deponent verbs
19:21:21 <augur> http://en.wikipedia.org/wiki/Deponent_verb
19:22:20 <conal> augur: interesting. and yet there are active verbs "compose" and "comprise".
19:22:42 <augur> conal: yep, but active "compose" for me has a different meaning. its mere homophony
19:23:28 <augur> you have to think of it like this:   type Word = (Phonology, Semantics)
19:23:39 <augur> or probably,   type Word = (Phonology, Syntax, Semantics)
19:23:50 <conal> augur: i mean the "compose" that's related to "composed of". e.g., http://www.merriam-webster.com/dictionary/compose
19:24:15 <augur> conal: which compose?
19:24:17 <conal> augur: but i hear you: that sense doesn't exist for you.
19:24:37 <conal> augur: sense 1
19:25:09 <augur> composed of exists for me. :)
19:25:12 <conal> augur: and in many other places. see, e.g., https://www.google.com/search?q=comprise+vs+compose
19:25:13 <augur> bare compose doesn't
19:26:09 <augur> well, actually i think all occurances of compose with "of" are the pseudo-passive probably?
19:26:48 <conal> augur: i wonder as well.
19:27:01 <augur> but yeah, its certainly true that the active and passive version of compose_1 are related. in most people the passive probably comes from the active via a rule
19:27:51 <augur> and historically theres no doubt that my passive-only compose_1 is derived from active compose_1
19:28:11 <augur> rumor!
19:28:36 <augur> no not rumor
19:28:55 <augur> rumor is a non-raising dummy subject verb. hrmph
19:29:20 <augur> what are these english deponent verbs im thinking of
19:29:25 <augur> hmm hmm
19:31:26 <South> :t <?>
19:31:28 <lambdabot> parse error on input `<?>'
19:31:34 <South> :t (<?>)
19:31:35 <lambdabot>     Not in scope: `<?>'
19:31:35 <lambdabot>     Perhaps you meant one of these:
19:31:35 <lambdabot>       `<>' (imported from Data.Monoid),
19:31:46 <augur> fwiw, conal, language is nuts. :p
19:32:37 <augur> ill see if i can find you some examples of these argument structure changes that pinker mentions
19:34:11 <conal> augur: my caring comes from wanting less nutty thinking and more clear & reliable conveying of ideas. some of the nuttier aspects are optional. hence my preferences about "is comprised of" (etc).
19:35:06 <augur> conal: well, luckily, thinking isnt done in language, its just the communication thats done in language, so if you're aware of the lack of a standard semantics for "comprise", you're fine!
19:36:17 <augur> tho often with things like this, its obvious what is meant. i mean, if i say "the whole is comprised of the parts" you-conal think i mistyped, you won't think "thats nonsense, ill write a big reply about how this guys philosophy is nuts!
19:36:26 <augur> so itll be a minor hiccup
19:39:48 <augur> conal: its almost always the case that the stuff you worry about with language is something you dont _need_ to worry about. that you can perceive it at all means you're capable of navigating the problem. what you really should worry about is those usages that are so radically different that you'll never be able to detect a difference in grammar -- you just don't understand and dont know why
19:39:52 <augur> thats the real tricky stuff!
19:40:39 <augur> a lot of technical writing is like that to an outsider, especially philosophy, and even more especially, postmodern philosophy
19:46:21 <BigJ> /bin/sh: open: command not found                      when I try to run a function
19:58:58 <small_student> radio test.. a o sdfadf .
20:00:02 * hackagebot assert 0.0.1.1 - Helpers for Control.Exception.assert  http://hackage.haskell.org/package/assert-0.0.1.1 (LiyangHu)
20:00:11 <small_student> Hello?
20:00:19 <big_student> Yeah....
20:01:00 <augur> o_o
20:01:19 <small_student> :>
20:01:24 <big_student> QAQ
20:01:25 <augur> can we help you, small_student/big_student
20:01:45 <small_student> ah~ thank you for responding.
20:02:00 <big_student> yes, he means it
20:02:21 <augur> you can stop pretending to be different people. your hostname is visibly the same.
20:02:31 <simpson> I don't think he realizes that we can see that. :3
20:02:42 <augur> simpson: well he does now
20:02:48 <small_student> still struggling on the basic idea of haskell
20:02:57 <simpson> Got a specific question?
20:03:03 <augur> small_student:
20:03:05 <augur> @where LYAH
20:03:05 <lambdabot> http://www.learnyouahaskell.com/
20:04:19 <ion> One didn’t really need to see the hostname to figure that out.
20:04:47 <small_student> this is a awesome learners book
20:04:50 <jefimenko> that's for sure
20:05:03 * hackagebot wai 1.4.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.4.1 (MichaelSnoyman)
20:05:16 <carter> ion: indeed
20:05:17 <small_student> I've never learned anything like haskell
20:05:20 <carter> well
20:05:22 <carter> now you can :)
20:05:32 <augur> ion: well, they could just be two people who know each other and are hanging out together and are being lulzy in the channel
20:05:34 <small_student> so the way it is a little bit weard
20:05:47 <augur> ion: or they couuld be just two people who know each other
20:06:03 <carter> and typing on the same keyboard/ip address
20:06:16 <small_student> it is so different from c and java
20:06:20 <not_ion> carter: well that requires that we know the hostname, which ion said we didnt need
20:06:32 <carter> true
20:06:43 <carter> not_ion: not that not not ion would agree
20:06:49 <not_ion> small_student: i remember when i first got into FP
20:07:02 <not_ion> i couldnt grok it. it was so alien to me
20:07:03 <simpson> small_student: There are many languages that are not like C or Java.
20:07:04 <carter> 2004 for me I think
20:07:08 <not_ion> like genuinely just completely baffling
20:07:11 <carter> like brainfuck :)!
20:07:14 <simpson> Like Forth!
20:07:20 <not_ion> this was i guess ~2006? via Functional JS
20:07:20 <carter> befunge
20:07:32 <not_ion> a library with all sorts of stuff for FP in JS
20:07:40 <small_student> thats interesting
20:07:44 <not_ion> small_student: my suggestion is, watch SICP
20:07:49 <not_ion> that helped me a lot
20:07:50 <carter> SICP is great
20:07:54 <carter> little schemer is great
20:07:58 <carter> how to design programs is great
20:08:02 <carter> theres so many great ways to learn
20:08:36 <not_ion> i know people have argued against SICP (calculating is better than scheming) but there's nothing like implementation and syntactic purity to make learning easier
20:08:41 <ion> You can only make an educated guess about whether it’s one or two people based on the hostname being the same. You can also only make an educated guess about whether it’s one or two people based on the nicks being big_student and small_student, them joining simultaneously and starting to talk to each other in the same style. :-P
20:09:14 <carter> also the ip addresses are the same
20:09:43 <not_ion> i shouldve said the address, really, not hostname
20:10:02 <not_ion> + the login name
20:10:33 <small_student> I am doing a homework on haskell for a few pac-man game functions, like move, reset, and so on
20:10:35 <not_ion> its not a guarantee of identity, but all the factors combined make it highly probably
20:10:43 <carter> well, probability ~ 1
20:10:52 <not_ion> highly :)
20:11:18 <carter> augur: indeed
20:14:20 <BigJ> guys what's up with this error http://pastebin.com/ktGaEeDa
20:14:25 <mauke> The paste ktGaEeDa has been copied to http://lpaste.net/95633
20:14:48 <carter> mauke: you do that by hand always?
20:14:51 <carter> or is that a script?
20:15:04 <ion> A script obviously
20:15:16 <carter> BigJ: mountain lion or snow leopard?
20:15:19 <carter> or mavericks
20:15:20 <carter> or waht?
20:15:35 <BigJ> Gentoo
20:15:38 <BigJ> Linux
20:15:39 <carter> ok
20:15:44 <carter> what GHC version?
20:15:49 <carter> oh
20:15:51 <carter> 7.6.3
20:15:54 <carter> how is it installed?
20:15:57 <carter> thats really weri
20:15:59 <carter> weird
20:16:09 <BigJ> ya, I have never had  a problem up until now
20:16:10 <ion> bigj: Please share the source code for problem1.
20:16:25 <carter> yes
20:16:26 <carter> that too
20:17:20 <BigJ> http://lpaste.net/95634
20:17:36 <Transhumanist> For a lover of Haskell, would you still recommend SICP? I am leery of LISPs. They seem very dirty compared to Haskell.
20:17:38 <ion> What’s traceProgram?
20:17:43 <augur> Transhumanist: yes
20:17:51 <Transhumanist> okie dokie
20:17:56 <augur> Transhumanist: i would say do SICP first
20:18:14 <Transhumanist> Already taken Haskell at uni, so I can't do it first. :p
20:18:19 <augur> oh well ok then :)
20:18:45 <BigJ> ion, figured it out, it writes to a txt file
20:18:52 <BigJ> ion, just have to open the txt file manually
20:23:32 <augur> how can two abstract objects be shown to be the same, without seeing them? hmm
20:23:47 <carter> defien them to be the same, abstractly :)
20:23:51 <augur> carter: :p
20:24:01 <augur> alas, equality is given externally
20:24:13 <carter> define them the same
20:24:27 <augur> they're predefined :(
20:24:38 <carter> well
20:24:45 <carter> then either they're teh same or not
20:24:51 <augur> carter: yes, but how to know!
20:25:00 <carter> reallyUnsafePointerEquality
20:25:16 <augur> carter: lol
20:25:25 <augur> if only this were truly a question about haskell
20:30:16 <adnap> Can I set up automatic insertion and removal of imports in modules?
20:31:01 <carter> adnap: waht does that mean
20:31:18 <carter> augur: what additional structure does your problem have?
20:32:39 <adnap> carter: When I use a function from a module that is not imported, an import is added if it is unambiguous, or I am asked to choose if it is ambiguous. When I am not using in any functions from an imported module, the import statement is removed.
20:32:48 <enthropy> @where module-management
20:32:48 <lambdabot> I know nothing about module-management.
20:32:50 <augur> carter: ~magic~
20:32:54 <enthropy> @hackage module-management
20:32:54 <lambdabot> http://hackage.haskell.org/package/module-management
20:33:07 <carter> adnap:: the problem is functions can be in more than one package
20:33:23 <enthropy> that one doesn't add imports... since that needs human intervention often
20:33:38 <adnap> carter: I said "...or I am asked to choose if it is ambiguous." Does that not cover it?
20:33:54 <carter> adnap: you could build one
20:33:55 <carter> it'd be hard
20:33:59 <carter> good luck
20:34:10 <enthropy> the pieces kind of exist already
20:34:24 <carter> cool
20:34:28 <enthropy> the various editor modes / ides out there can import identifiers under the cursor
20:34:36 <enthropy> /prompt you for which one to grab it from
20:34:42 <adnap> Okay, I am taking this advice as aknowledgement that there is no such thing as far as either of you know.
20:35:21 <enthropy> yes
20:36:27 <enthropy> but maybe there is an integration with ghci somewhere that will have a "click on variable-not-in-scope to select the import to add"
20:36:28 <adnap> In Eclipse with Java, there is a command to automatically remove and add package imports.
20:37:12 <adnap> And if there is ambiguity, a little window comes up asking you to chooes a package.
20:41:00 <khyperia> and it's the same with Eclipse for Haskell. http://eclipsefp.github.io/features.html
20:45:58 <NemesisD> anyone ever used aeson with generics before?
20:46:33 <NemesisD> i'm trying to figure out if i could use generics to reflect on a value's to/fromjson instances and generate documentation
20:59:34 <pavonia> Is there a briefer way of writing "let Foo y = x in y", maybe using a language extention?
21:00:16 <heatsink> Can you change the definition of Foo?
21:00:37 <pavonia> No
21:01:04 <heatsink> You can define a function to get y from x
21:01:23 <heatsink> Then the expression will just be a function call
21:02:03 <pavonia> Yes, that would be possible, but I'm wondering if there's a special syntax for that
21:02:11 <augur> pavonia: whats the context?
21:02:31 <pavonia> No real context, just unwrapping a constructor
21:02:45 <augur> pavonia: well then write a destructor!
21:02:58 <augur> the_y (Foo y) = y
21:03:54 <pavonia> that's what heatsink suggested too
21:04:14 <NemesisD> maybe you guys could tell me if i'm barking up the wrong tree. maybe i need to make some sort of monadic edsl for specifying how a type relates to a json structure and then it can generate parser/serializer/docs from that
21:05:06 <augur> pavonia: yes but he didnt write it. :p
21:06:11 <heatsink> If you want to generate stuff from a type definition, that would be a use of Template Haskell
21:08:30 <NemesisD> heatsink: i admit i haven't fully baked this yet and i've also never done th
21:09:10 <NemesisD> but i basically want to piggyback on aeson's existing code generation stuff, like th for example, but *additionally* generate additional code from it
21:10:07 <NemesisD> is it possible to call into another module's TH from your th
21:10:08 <enthropy> what kind of docs?
21:10:24 <enthropy> X has fields a,b,c int etc.
21:11:00 <enthropy> yes you can call a  Q [Dec] from other TH code that isn't at top-level
21:11:26 <NemesisD> enthropy: ultimately i want something like json schema http://json-schema.org/
21:12:14 <NemesisD> yeah exactly, it expects field a to be a string with valid values of x,y,z, field b is an object described by this other schema...
21:14:29 <NemesisD> the real trick though is that i'm not sure how i'm going to get at the json type representations from the haskell code
21:14:58 <enthropy> seems like a bigger problem is getting stuff like "description": "Age in years"
21:15:00 <NemesisD> i'd have to reflect on whatever toJSON decides the types should serialize to, and i don't know how i'd get that information
21:16:12 <NemesisD> enthropy: yeah. so 2 choices there could be either have the th compile to a low-fi form of json schema or maybe its back to the drawing board of create a DSL that can derive toJSON, fromJSON and a schema for the type
21:16:56 <enthropy> might it be better to start off with a json-schema?
21:17:32 <NemesisD> what do you mean? define that datatype or...?
21:18:17 <enthropy> if you're trying to avoid writing things twice, it's better to write the version that's more expressive
21:18:27 <NemesisD> yeah i think you're right
21:18:43 <enthropy> you might get those description things out of haddock comments or something
21:18:49 <enthropy> but that's not easy to get at
21:19:25 <NemesisD> the vague idea i have in my head is that i create a monadic dsl (maybe?) for specifying the spec, that turns it into some sort of tree-like datatype and then mechanically translating that to a parser and a serializer may be straightforward
21:19:45 <NemesisD> i'd like this to be as typesafe as possible so i don't want to get into comment parsing
21:20:39 <enthropy> you could for example have a quasiquoter   [jsonAndSchema| data Person = Person { firstName :: String, lastName :: String, age :: Int -- ^ age in years \n } |]
21:20:57 <enthropy> ok. also another option to put strings in places is with -XDataKinds
21:21:35 <NemesisD> hmm not familiar with those
21:22:06 <NemesisD> i'd probably avoid the qq approach: i think i want this to be a typeclass, so the user is free to define the datatype separately
21:22:33 <enthropy> what I mean is have     data Person = Person { age :: Description "age in years" Int }; data Description (string :: Symbol) a = Description a
21:23:02 <enthropy> or I guess it Description can be newtype
21:23:08 <NemesisD> woah
21:23:57 <enthropy> and you can write a function like    f :: Description a b -> String; that gives you the string that was in the type
21:24:12 <enthropy> lots of options
21:24:54 <NemesisD> i think i want to avoid anything that would force users to change how their types are defined
21:25:14 <enthropy> yes
21:25:30 <enthropy> but how else are they going to include their descriptions?
21:27:40 <NemesisD> i was thinking i could give a way to build up a representation of the schema so it knows the names and types of fields, so there they'd specify all the metadata about the schema
21:28:50 <NemesisD> that's where things get hazy though, so i have a data structure but that's a value at runtime, which means i couldn't use TH for example to generate compile-time parsers/serializers
21:29:55 <NemesisD> so i'd have to write something like genParser :: HasJSONSchema a => a -> Parser a
21:30:27 <NemesisD> and it would have to traverse the schema at runtime when parsing each message. seems bad
21:31:34 <NemesisD> it really does seem like a 2 phase problem. maybe QQ is the way to go if it can be expressive enough and doesn't have to actually define the type withing the qq
21:34:17 <enthropy> NemesisD: how about that version that has Description above, plus some way to generate one without the Description?
21:37:29 <NemesisD> enthropy: but doesn't that tie description to the core type itself?
21:38:02 <NemesisD> the principle i'm operating on here is that members of these json typeclasses live lives outside of json, and that it is just a secondary feature necessary for things like APIs
21:39:24 <enthropy> dunno it seems better to annotate the data type where you define it, rather than having some way to express "that place right over there has a description such and such"
21:39:32 <enthropy> since that's more stuff to keep in-sync
21:42:16 <NemesisD> i can see your point. i think if i were to not annotate it where defined i would want something typechecked, i.e. the parser code it is generating will fail to compile if you've mismatched a type
21:43:07 <NemesisD> i'll give the way you described a shot though, it seems to eliminate some complicating factors and given that i've never done qq or th before its probably best i not try to push it
21:44:20 <NemesisD> one way i could see this going wrong is lets say you use the persistent package's qq for generating the datatype and database stuff for your web app
21:44:57 <NemesisD> that's unfortunately probably my main target case: that person would also want to be able to represent that data type in json and have a schema for it
21:46:36 <NemesisD> man this type of macroing stuff is kind of tricky in haskell
21:46:57 <carter> NemesisD: ermine
21:47:36 <enthropy> eventually it makes sense
21:48:25 <enthropy> there are similar stumbling blocks learning haskell in general, in that some things "are supposed to work" but that way isn't accepted
21:49:05 <NemesisD> lol sure just use a different language carter :P
21:49:32 <NemesisD> i've got enough of a problem of people not using my libraries in haskell, best not make things worse
21:50:56 <carter> NemesisD: have you seen vinyl?
21:51:11 <carter> http://hackage.haskell.org/package/vinyl-0.2
21:52:39 <NemesisD> carter: hmm i heard about it when it got announced but i haven't delved in
21:53:01 <carter> you could totally (ab)use it to have a strongly typed data model for json'y thing
21:53:03 <carter> s
21:53:21 <sopvop> I totally want vinyl tutorial
21:53:28 <NemesisD> it seems like ive found a reasonably meaty problem, i'm willing to entertain many solutions, really glad people who know more about what's out there are willing to point things out. i have a limited set of tools at my disposal in haskell right now
21:55:06 <NemesisD> i'd prefer to not get too exotic on the type side since i intend this to be a general purpose library though. hmm
21:55:36 <carter> NemesisD: whats goal?
21:55:52 <carter> NemesisD: why not aeson?
21:56:29 <sopvop> and there it is http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html
21:57:13 <NemesisD> carter: aeson will be integral to this. say i have a type data Person = Person { age :: Int, name :: String}. i'm  looking to write something that will let you specify (preferably after defining it) a schema a-la http://json-schema.org/examples.html
21:57:44 <carter> NemesisD: so just generate some haskell data types with named fields
21:57:48 <carter> and also some aeson instances
21:57:51 <sopvop> NemesisD You can make an encoding which generates schema
21:57:54 <NemesisD> carter: and via the wonders of qq, th or some other black magic, have it define the FromJSON, ToJSON and something else that generates a structure represetning the schema
21:57:55 <sopvop> erm
21:58:03 <carter> yeah
21:58:06 <carter> agree with sopvop
21:58:11 <NemesisD> an encoding?
21:58:17 <sopvop> I'll show some code now
21:58:32 <NemesisD> is this yet another haskell concept i don't know
21:58:52 <carter> its really easy to write an aeson instance
21:58:55 <carter> like
21:59:04 <carter> really easy
21:59:08 <carter> like
21:59:14 <carter> i'm not sure what you're trying to solve :)
21:59:18 <lpaste> sopvop pasted “json with schema encoder example” at http://lpaste.net/95636
21:59:23 <sopvop> That's mine
21:59:56 <NemesisD> carter: a library that gives you the aeson instances PLUS a schema for documentation, that's the trick
21:59:57 <sopvop> This one generates an a -> Value and Schema
22:00:11 <carter> NemesisD: but i have a schema
22:00:13 <carter> the haskelly type
22:00:19 <carter> json is a pretty weak schema
22:00:25 <carter> like
22:00:37 <sopvop> carter: you may need it for not haskell clients, don't you?
22:00:40 <carter> true
22:00:48 <carter> but its a derivation of the haskell type
22:00:53 <sopvop> not really
22:00:56 <carter> and for sharing it
22:01:00 <carter> i'd write it out in the docs
22:01:06 <NemesisD> carter: correct. but say you were building a web API, you have your nice haskell types but at the border you need to serialize/deserialize over HTTP
22:01:11 <carter> yes
22:01:14 <sopvop> docs get out of date quickly
22:01:17 <carter> i'd use aeson
22:01:19 <carter> sopvop: yes
22:01:24 <NemesisD> it would be nice if your haskell type also generated a schema automatically that you could use to document your api
22:01:28 <sopvop> it's much better to derive docs from code
22:01:31 <carter> true
22:01:36 <carter> BUT: will your TH do that?
22:01:41 <carter> tahts a different problem
22:01:46 <carter> than the other one you described
22:02:03 <NemesisD> that's the idea yeah. still want to use aeson for the parsing/serializing, want to stack onto that the schema gne
22:02:03 <sopvop> these things I generate from code like the one I pasted http://imgur.com/7Q98uYm http://imgur.com/1jxlqTK
22:02:04 <NemesisD> gen*
22:02:22 <sopvop> no, TH is not needed. see paste
22:02:37 <carter> neat
22:02:56 <carter> sopvop: props
22:02:59 <carter> what do you use this for?
22:03:11 <NemesisD> sopvop: that is awesome and exactly what i'm after. assuming closed source?
22:03:27 <sopvop> closed source but because I'm too lazy to make this generic and cleanup :)
22:03:30 <carter> its so pretty it must be proprietery :)
22:04:27 <NemesisD> i'd love to read more about the implementation of ResourceCoder etc. would also abandon my nacent project and help you open source yours if you think that would help
22:04:32 <sopvop> I make the backend which is just an restful fronted for DB + a bit of logic. client guy wanted docs, I've spend 3 day to come up with this
22:04:36 <sopvop> haskell power!
22:05:03 <NemesisD> i should be doing a lot more reading of haskell code than i'm doing these days
22:05:41 <sopvop> ResourceCoder a = RC { schema :: SomeKindOfMonoid, encoder :: a -> HashMap Text Value } make a monoid instance.
22:06:08 <sopvop> Alternatively encoder a -> Endo (HashMap Text Value)
22:06:40 <carter> this looks like a neat use of applicative
22:06:48 <sopvop> it's a monoid
22:06:53 <carter> both even?
22:07:07 <sopvop> input parser is applicative, and it makes schema too :)
22:07:09 <carter> really looks similar to optparse-applicative
22:07:32 <sopvop> optparse uses Free stuff
22:07:53 <sopvop> this is proper way to deal with it http://comonad.com/reader/2012/abstracting-with-applicatives/
22:08:37 <sopvop> I derived mine from reform library, but without indexed stuff
22:10:06 <NemesisD> hmm interesting
22:10:17 <carter> @hackage reform
22:10:17 <lambdabot> http://hackage.haskell.org/package/reform
22:10:21 <NemesisD> sopvop: do you work at a haskell shop primarily?
22:10:34 <sopvop> no
22:10:50 <sopvop> I work in animation studio...
22:11:39 <NemesisD> cool
22:12:52 <NemesisD> well if you do ever decide you want to opensource that and you could use some help let me know. this sort of thing definitely seems useful given the stuff people are doing with haskell json apis
22:13:33 <NemesisD> hell i'd love to have something like this for ruby, which is completely impoverished documentation-wise
22:13:52 <carter> sopvop: NemesisD  looks like its indexed functor should actually be a bifunctor
22:14:09 <carter> its not really indexed…..
22:14:15 <carter> it just carries two things
22:14:22 <carter> @hackage bifunctor
22:14:22 <lambdabot> http://hackage.haskell.org/package/bifunctor
22:14:30 <carter> @where bifunctor
22:14:30 <lambdabot> I know nothing about bifunctor.
22:14:34 <carter> @hoogle bifunctor
22:14:35 <NemesisD> i don't know either of those 2 concepts
22:14:36 <lambdabot> package bifunctors
22:14:46 <sopvop> Jeremy Shaw calls it indexed so..
22:14:58 <carter> http://hackage.haskell.org/package/bifunctors-3.2.0.1
22:14:59 <carter> nope
22:15:01 <carter> not indexed
22:15:09 <sopvop> it is biapplicative
22:15:10 <carter> wrong word
22:15:26 <sopvop> oh, edwardk has biapplicative too
22:15:38 <carter> jah
22:15:53 <carter> and it has more structure
22:16:04 <carter> you actually want the maps to be composed at different ends
22:21:18 <carter> hrmmm
22:21:23 <carter> i'm thinking of something else
22:21:48 <carter> sclv: do you know what the thing that has the co/contravariant functor stuff with 2 parameters is?
22:21:55 <carter> i've seen it talked about on the lens channel
22:22:00 <sclv> profunctor
22:22:56 <carter> yes
22:22:57 <carter> thanks!
22:23:01 <carter> sopvop: NemesisD  http://hackage.haskell.org/package/profunctors-3.1.1/docs/Data-Profunctor.html
22:23:22 <carter> "Intuitively it is a bifunctor where the first argument is contravariant and the second argument is covariant. "
22:24:23 <carter> hrmm
22:25:26 <carter> are any profunctors applicative?
22:27:44 <carter> ok
22:27:47 <carter> i should start crashing
22:36:12 <sopvop> well  MaybePro a b = MaybePro (a -> Maybe b) so is an Applicative  (MaybePro a)
22:43:15 <NemesisD> sopvop: carter i gotta run. thanks for your help. i'll take a look at the notes i've written down some time tomorrow hopefully
23:11:46 <frx> @src foldl
23:11:47 <lambdabot> foldl f z []     = z
23:11:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:13:17 <frx> isn't that tail recursive? why does it overflow on long lists?
23:13:54 <frx> ie foldl (+) 0 [1..]
23:15:03 <frx> it uses up all the memory and makes GHCI crash
23:17:43 <frx> likewise if I compile it
23:23:01 <adnap> frx: There is no way to get premature output. foldl is called recursively without producing a first element: http://lpaste.net/7570660989197090816
23:23:38 <frx> adnap I know. isn't that tail recursive? doesn't haskell have TCO?
23:23:43 <TravisD> adnap: Did a program automatically do those substitutions?
23:23:48 <adnap> TravisD: No, I did
23:24:06 <TravisD> frx: I believe the issue is that you're building up a very large thunk that describes how to compute the sum of the list. You need to add strictness to avoid the memory consumption
23:24:09 <frx> adnap I would have expected "infinite" loop, without increasing memory
23:24:15 <TravisD> adnap: :( I've wanted something like that
23:24:34 <adnap> frx: The increasing memory is due to the "plus expression" building up without being evaluated
23:24:54 <frx> hmm
23:24:55 <TravisD> "sum". I guess you maybe aren't adding :)
23:25:23 <adnap> frx: Maybe you could solve that with a strict (+)?
23:25:52 <adnap> I don't have any experience with this.
23:25:55 <gabemc> Is there a way to pull the version information from cabal when building a package, possibly using something like the CPP extension? I would like to update a version string in an executable without having to hand-edit it every time.
23:25:58 <TravisD> I think fold' also works
23:26:02 <TravisD> er, foldl'
23:26:13 <Ghoul___> does anyone know if a stable ptr is freed when its garbage collected?
23:26:30 <frx> the same thing happens with foldl', probably for the same reason
23:26:34 <adnap> @src foldl'
23:26:34 <lambdabot> foldl' f a []     = a
23:26:34 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:26:50 <Ghoul___> I will be eliminating all references to a thing and then magically pulling it back (with maths) and I don't want the GC collecting my thing before I go to read it agai
23:26:56 <adnap> foldl' should solve the memory issue
23:27:01 <frx> it did not
23:27:41 <frx> it uses up over a GB of ram, then terminates.
23:28:24 <TravisD> frx: with foldl' you're only adding one level of strictness. It's still possible for your thunks to grow
23:28:28 <frx> no sorry, my mistake
23:28:41 <adnap> You should use foldr anyway
23:28:42 <TravisD> frx: I think, anyways. Take anything I say with a heap of salt
23:28:43 <frx> I wrote sum' using foldl', but still used sum in the code. foldl' fixed the problem
23:29:13 <frx> adnap for (+) ?
23:29:15 <adnap> You can see the seq in the foldl' source which evaluates the sum in frx's case each time the function recurses
23:30:15 <nlogax> @src foldr
23:30:16 <lambdabot> foldr f z []     = z
23:30:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:30:33 <adnap> Actually, I'm not so sure.
23:30:36 <adnap> Sorry
23:36:29 <adnap> Yeah, foldlr seems no good. It wont be able to avaluate any sum because the right operand will always depend on another call to foldr: http://lpaste.net/3179127422335320064
23:38:02 <supki> unless your (+) is lazy or something
23:39:37 <frx> this is like the opposite to what I'm used to. tail recursive function can sometimes lead to memory exhaustion, while recursion without tail call (like map on a large list) won't.
23:43:31 <Cale> frx: Well, it's quite literally the opposite order of evaluation
23:43:59 <Cale> (outermost-first, rather than innermost-first)
23:48:36 <adnap> Okay, so foldr is usually the one you want to use for infinite lists, right? With foldr (:) 0 [1..], (:) is able to partially evaulate the result and you get a result immediately with no thunk build-up
23:48:52 <adnap> So the problem is with (+)
23:50:00 <Cale> Well, yeah, sort of
23:50:01 <adnap> * foldr (:) [] [1..]
23:50:16 <Cale> Definitely foldr is the one you want for infinite lists
23:50:35 <Cale> foldl will do nothing except to apply itself to new arguments until it reaches the end of the list
23:50:39 <Cale> @src foldl
23:50:40 <lambdabot> foldl f z []     = z
23:50:40 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:50:44 <Cale> @src foldr
23:50:44 <lambdabot> foldr f z []     = z
23:50:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:50:51 <Cale> while foldr passes control to f immediately
23:50:54 <adnap> Did you see http://lpaste.net/3179127422335320064 ?
23:51:07 <adnap> With (+), nothing is evaluated immediately
23:51:36 <adnap> I guess because there's no result to give...
23:51:50 <adnap> Hm, wait. The result could be a partially applied function
23:52:00 <adnap> Where the left operand is constantly updated
23:52:57 <adnap> I'm not sure if that is happening though
23:55:52 <[swift]> curious if anyone knows how clever haskell's STM is at avoiding repeating pure computation that occurs during a retried transaction. if they have no data dependency on a transactional variable, they won't get repeated, right?
23:58:44 <Transhumanist> @src map
23:58:44 <lambdabot> map _ []     = []
23:58:44 <lambdabot> map f (x:xs) = f x : map f xs
