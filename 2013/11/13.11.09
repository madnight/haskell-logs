00:06:47 <TallerGhostWalt> prisms!
00:06:49 <TallerGhostWalt> I see
00:07:10 <TallerGhostWalt> hehe, I have been beating myself up trying to get Lenses working on a sum type... probably should just read more and code less
00:18:54 * hackagebot tdd-util 0.3.0.0 - Test framework wrapper  http://hackage.haskell.org/package/tdd-util-0.3.0.0 (ByronJohnson)
00:18:54 * hackagebot tdd-util 0.3.0.1 - Test framework wrapper  http://hackage.haskell.org/package/tdd-util-0.3.0.1 (ByronJohnson)
00:23:49 * hackagebot tasty 0.4.0.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.4.0.1 (RomanCheplyaka)
00:41:30 <shiona_> I've tried to avoid cabal up until now for problems I encountered some years ago when first trying out haskell. Now I'm pretty much forced to give it a try. Where does it actually install the stuff it does, how does it work and can it live side by side with a non-cabal installation of haskell?
00:42:49 <crocket> Why don't people use haskell as a system programming langauge?
00:45:05 <c_wraith> crocket: low ability to control exact memory layouts
00:45:25 <crocket> c_wraith, Some people tried to use lisp to build an OS.
00:45:39 <crocket> And some other people built an OS with haskell.
00:45:51 <c_wraith> I mean, you *can* do systems programming with managed languages
00:46:19 <c_wraith> But the reason people tend not to is that you often want it to be easy to control the hardware more exactly
00:47:01 <c_wraith> and while haskell has tools for doing so (the FFI can be used for those purposes without native code, for instance), it's just not what the language makes easy
00:53:56 <hvr> Fuuzetsu: ping?
00:54:25 <lpsmith> argh,  ok,  does anybody know how to set up a custom signal handler for SIGUSR1 that doesn't result in the termination of the process
00:54:27 <lpsmith> ?
00:54:38 <Fuuzetsu> hvr: pong
00:54:57 <hvr> Fuuzetsu: I was wondering, how does Haddock decide whether 'FooBar' is a type or a constructor?
00:55:42 <Fuuzetsu> hvr: GHC passes multiple possibilities in a list to it and we default to one of them. There was a rather big bug due to this. Let me see…
00:55:45 <hvr> Fuuzetsu: I've noticed that when I refer to something like 'Control.Concurrent.forkIO', Haddock thinks it's a type
00:55:55 <hvr> and thus the link is broken
00:56:38 <Fuuzetsu> hvr: https://github.com/sol/haddock/commit/87f255f4407e4548083c8c87d27cdfab08a1f504
00:57:16 <Fuuzetsu> hvr: is this your bug http://trac.haskell.org/haddock/ticket/253 ?
00:57:37 <hvr> yes
00:58:10 <Fuuzetsu> Finally I have a chance to use http://spl.smugmug.com/Humor/Lambdacats/i-6djpLdS
00:58:25 <hvr> hehe
00:59:12 <hvr> Fuuzetsu: so there is no facility to tell Haddock what I mean by an ambiguous reference to 'FooBar' in case there's multiple targets?
00:59:25 <Fuuzetsu> Nope.
00:59:35 <hvr> ...any plans wrt that? :)
00:59:40 <Fuuzetsu> Nope.
00:59:52 <hvr> :-/
01:00:27 <Fuuzetsu> File a ticket I suppose but I think it'd be difficult to do considering how we currently do it.
01:00:29 <hvr> fwiw, Emacs docstrings disambiguate by looking if the reference is preceded by certain keywords such as "info node", "function", etc
01:02:34 <Fuuzetsu> Hm, we could maybe carry this kind of information with all the way to when we actually make the decision… File a ticket! Provide a use case &c and it will be looked at but I don't think it'll happen. It's not a huge issue and we'd have to add new syntax for it.
01:03:23 <Fuuzetsu> Well, maybe a FooBar:v or FooBar:t syntax would be fine. In any case, such thing won't be implemented any time soon and needs some discussion first.
01:03:37 <hvr> Fuuzetsu: oh, and btw, is there a release notes or something for the great new features that are part of Haddock as shipped in GHC 7.8?
01:03:47 <Fuuzetsu> Currently it'd be great if we could get any new features released…
01:04:05 <Fuuzetsu> hvr: I updated docs which will be released
01:04:24 <Fuuzetsu> and I'll almost certainly write a blog post once it's out with a quick outline
01:04:28 <Fuuzetsu> and probably a small cheat sheet
01:04:37 <hvr> \o/
01:05:23 <Fuuzetsu> Ideally it should be out already but then again so should 7.8. The big problem was that there were a few major blocking bugs related to Haddock and 7.8 so there's a great delay
01:16:53 <Taneb> ghc-mod isn't picking up user-installed modules, can anyone help?
01:45:01 <mangaba_leitosa> is there a standard equivalent of 'until cond f' which would call 'f' until reaching a fixed point (f returning the same value as previous call to f)?
01:46:04 <mangaba_leitosa> ah, it's Data.Function.fix, it seems
01:46:28 <Taneb> mangaba_leitosa, be careful with it
01:46:39 <Taneb> I don't think that does quite what you want it to do
01:47:28 <mangaba_leitosa> Taneb: why? :-)
01:48:14 <Taneb> Just be careful with fix
01:48:23 <Philonous> mangaba_leitosa, fix doesn't stop when the result is the same.
01:48:27 <Philonous> @src fix
01:48:27 <lambdabot> fix f = let x = f x in x
01:48:37 <Philonous> @type fix
01:48:38 <lambdabot> (a -> a) -> a
01:48:48 <Philonous> mangaba_leitosa, It couldn't, because there is no Eq constraint on a
01:49:01 <mangaba_leitosa> Philonous: ah.... I see :-)
01:49:13 <mangaba_leitosa> Philonous: is there a standard function for what I want then? :-0
01:49:48 <mangaba_leitosa> Philonous: but why the description is saying 'f is the least fixed point of the function f, i.e. the least defined x such that f x = x' ?
01:49:51 <Philonous> mangaba_leitosa, fix may seem strange at first because it looks like an infinite loop, but laziness allows it to converge for certain functions
01:50:08 <mangaba_leitosa> Philonous: it says f x = x'
01:50:12 <Philonous> mangaba_leitosa, Oh, it is, but you have to ask, respective to what ordering.
01:50:31 <Philonous> mangaba_leitosa, In this case, it's _|_ < everything else
01:51:12 <mangaba_leitosa> Philonous: what's '_|_' ?
01:51:17 <Philonous> mangaba_leitosa, Regarding the function you describe, I wouldn't know of it.
01:51:21 <Iceland_jack> Bottom (⊥)
01:51:28 * mangaba_leitosa checking the implementation of fix in the source code
01:51:29 <elliott> mangaba_leitosa: it is the domain theory least fixed point
01:51:36 <elliott> the ordering is "definedness"
01:51:57 <Philonous> mangaba_leitosa, Bottom or the undefined value. It can come in many flavors, for example nontermination, exception, error, haskells undefined
01:52:38 * mangaba_leitosa checked: 'fix f = let x = f x in x'. Yes, it does not seem to do any equality check :-)
01:52:53 <mangaba_leitosa> Then I need another function
01:52:58 <Philonous> mangaba_leitosa, As I said, it couldn't. The type already tells you that.
01:54:33 * mangaba_leitosa doesn't understand "the least defined x such that f x = x" :-(
01:54:33 <Iceland_jack> > fix (\f n -> if n == 5 then [] else n:f (n+1)) 0 -- mangaba_leitosa
01:54:34 <lambdabot>   [0,1,2,3,4]
01:55:55 <Philonous> > let myFix f x = let y = f x in if y == x then x else myFix f y in myFix (\x -> x `div` 2 + 3) 11
01:55:56 <lambdabot>   6
01:55:59 <funfunctor> anyone here used the vty package?
01:56:40 <mangaba_leitosa> Iceland_jack: yes, I see the usage pattern now, not what I wanted :-)
01:57:32 <Philonous> @type let myFix f x = let y = f x in if y == x then x else myFix f y in myFix
01:57:33 <lambdabot> Eq a => (a -> a) -> a -> a
01:57:54 <Iceland_jack> mangaba_leitosa: ‘fix’ rarely is what you want :)
01:58:53 <mangaba_leitosa> Iceland_jack: I want a standard equivalent of 'until (\(previous, actual) -> previous == actual) (\(previous, x) -> (x, f x)) (x, (f x))'
01:59:05 <funfunctor> https://gist.github.com/victoredwardocallaghan/7383779 I am trying to get the geometry right for the status bar..
02:00:00 <mangaba_leitosa> Iceland_jack: to be used as 'fixed_point f x'
02:00:02 <Philonous> mangaba_leitosa, Because you don't give fix a starting value, only the function it can only ever produce something if the function produces at least something without looking at it's input. A function with that property is called "productive". For example f x = 1:x . Otherwise there's no way fix could conjure up a value.
02:00:13 <funfunctor> sbar _should_ be a single line strip
02:00:32 <mangaba_leitosa> Philonous: I see
02:01:01 <Philonous> mangaba_leitosa, I don't think there is one. But it's easy enough to implement yourself.
02:01:27 <mangaba_leitosa> Philonous: sure. It's easy to implement 'until' yourself, too, but why not check if it's already implemented for you. Thanks!
02:02:24 <mangaba_leitosa> Philonous: I find myself writing something like 'until (\(previous, actual) -> previous == actual) (\(previous, x) -> (x, f x)) (x, (f x))' quite often
02:02:40 <mangaba_leitosa> Philonous: so it's weird that until exists and this one doesn't :-)
02:06:07 * mangaba_leitosa defined let fixed_point f x = until (\(previous, actual) -> previous == actual) (\(previous, x) -> (x, f x)) (x, (f x))
02:07:59 <funfunctor> ah I worked it out ! :D
02:11:21 <adnap> Record functions for data types have an implicit first argument, which is a value of the data type, right? But, I think record functions cannot access other fields of the data type value. Why?
02:12:45 <adnap> For example, if I have data F = F { i :: Integer, s :: String }, s has type F -> String, but s cannot be defined by the Integer.
02:12:58 <adnap> ...contained in F
02:13:34 <shiona_> I don't think I got any answers so I'll try to rephrase: How do I make sure my cabal installation (all the packages installed with cabal) stays in a safe and sandboxed state where I can delete it when it dies on itself, but can use it for multiple projects without the need to install every package for each project
02:15:09 <adnap> shiona_: Maybe this will help you: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html I have not learned about sandboxes yet.
02:16:30 <shiona_> adnap: let's see. I'm not sure if sandbox is the word I'm looking for so I'll need to check your link before I can tell anything more
02:16:59 <shiona_> it seems sandbox is totelly the opposite what I'm looking for
02:18:05 <shiona_> well, I'll have to read about cabal at some point
02:18:16 <mangaba_leitosa> how can I define an equivalent printf which would return String instead of PrintfType ([Char] -> t) => t ?
02:19:17 <mangaba_leitosa> if I use printf for generating the result in my  'something -> String' functions, their inferred type changes
02:20:00 <Philonous> adnap, You functions s and f are automatically implemented by the compiler to make accessing the data easier. They are a mere convenience. You can defined your own functions that access all of the fields in whatever manner you wish
02:20:18 <mangaba_leitosa> looks like I need printf which would do (Text.Printf.printf args ++ "")
02:21:54 <Philonous> > printf "abc %i" 15 :: String
02:21:56 <lambdabot>   "abc 15"
02:22:08 <Philonous> mangaba_leitosa, You don't have to do anything, printf already returns a string.
02:22:20 <mangaba_leitosa> Philonous: I mean without doing ::String manually
02:22:22 <Philonous> mangaba_leitosa, The weird type signature is only there to accomodate it's vararg nature
02:22:52 <mangaba_leitosa> @type printf "abc %i" 15
02:22:53 <lambdabot> (Num a, PrintfType (a -> t)) => t
02:23:06 <Philonous> mangaba_leitosa, You don't necessarily have to write :: String. It will often be inferred from the context.
02:23:35 <mangaba_leitosa> Philonous: but is it possible to define my function which a fixed signature something -> String which would call printf?
02:23:45 <Philonous> Sure.
02:23:50 <mangaba_leitosa> Philonous: and how?
02:24:02 <mangaba_leitosa> Philonous: I need 'myprintf' which is just like printf, but returns String
02:24:33 <mangaba_leitosa> @type printf
02:24:34 <Philonous> @type let myprintf = printf :: String -> Int -> String  in myprintf
02:24:35 <lambdabot> PrintfType r => String -> r
02:24:36 <lambdabot> String -> Int -> String
02:24:59 <adnap> Philonous: But suppose I have data F = F { x :: Integer, g :: F -> String }. I would like the creator of an F to define a value, corresponding to g, which depends on an F; Specifically, the F the creator is defining, and more specifically, that F's Integer. However, the type of g is F -> F -> String, which seems a bit redundant when the intention is to call g with the very F that is being defined. Thus, it will be passed twice.
02:25:10 <mangaba_leitosa> > myprintf "%s\n" "abc"
02:25:11 <lambdabot>   Not in scope: `myprintf'
02:25:11 <lambdabot>  Perhaps you meant `printf' (imported from Text.Pr...
02:25:31 <mangaba_leitosa> @let myprintf = printf :: String -> Int -> String
02:25:34 <lambdabot>  Defined.
02:25:42 <mangaba_leitosa> > myprintf "%s\n" "abc"
02:25:43 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
02:25:44 <lambdabot>              with actual type ...
02:25:56 <mangaba_leitosa> Philonous: doesn't work like printf :-(
02:26:35 <Philonous> mangaba_leitosa, Well, once you fix the type you can't pass it arguments with another type.
02:26:58 <mangaba_leitosa> Philonous: so, it's impossible?
02:27:17 <mangaba_leitosa> Philonous: myprintf working exactly like printf and returning String?
02:27:29 <Philonous> mangaba_leitosa, You have to either fix a type (and stay with it) or keep it at it's polymorphic type
02:27:55 <mangaba_leitosa> Philonous: I see... thanks
02:28:35 <adnap> How do you define data types with lambdabot?
02:28:46 <dor>  @let
02:34:14 <Philonous> adnap, well, the g is merely a selector function. So the first F tells you where the function you want comes from, the second F says which value you want to apply it to. If you need them to coincide you have to define that in another function, say g' :: F -> String; g' f = g f f
02:36:05 <Philonous> adnap, Haskell doesn't directly support open recursion.
02:36:05 <adnap> Philonous: I wish the creator of an F was allowed access to the first argument of g
02:36:23 <adnap> Philonous: ...when defining g
02:43:52 <lpaste> manjunaths pasted “Data keyword” at http://lpaste.net/95433
02:44:08 <manjunaths> Hmmm
02:44:31 <manjunaths> How would I implement this data type for let us say a circle ? Where
02:44:44 <adnap> Philonous: This is the most satisfactory thing I came up with: http://ideone.com/n2V8XL
02:45:09 <manjunaths> area r = pi * r * r and perimeter r = 2*pi*r
02:45:33 <manjunaths> Code is in the above paste...
02:46:11 <Philonous> adnap, Yeah, that's one way of doing it. The class is orthogonal to the problem, though.
02:46:30 <Philonous> adnap, You only need it if you want to reuse g.
02:47:12 <adnap> Philonous: I don't understand
02:47:39 <manjunaths> I get an error if I do this
02:47:41 <manjunaths> circle = Shape { area a =  pi * a * a, perimeter a = 2*pi*a }
02:48:14 <Philonous> adnap, You will only need class G a ... if you have another type that you want to use g at.
02:48:59 <genquinta> ciao
02:49:04 <genquinta> !list
02:49:05 <monochrom> genquinta: http://okmij.org/ftp
02:49:19 <adnap> Philonous: Oh, right. You're saying I could just export g as a standalone function
02:49:35 <adnap> Philonous: I don't know why I made it needlessly complicated
02:49:40 <Philonous> manjunaths, circle needs "a" as a parameter
02:49:53 <adnap> Philonous: And it's possible to export x and not _g, right?
02:49:53 <Philonous> adnap, Yes
02:50:23 <manjunaths> circle a = Shape { area a =  pi * a * a, perimeter a = 2*pi*a } ?
02:50:37 <adnap> Philonous: Actually, I have never tried defining a data constructor with only some fields labeled
02:50:40 <manjunaths> Even this gives an error, parse error at a
02:50:40 <Philonous> manjunaths, Yes, though I have to say it's a surprising way of going about this.
02:51:37 <Philonous> adnap, I'm not sure you can. If you don't export the constructor you'll have to export a function to construct the F as well.
02:51:46 <manjunaths> Philonous, I saw a data type defined like this, I wanted to understand how that came about. So I wrote this simple example. But I can seems to create a data type.
02:52:20 <manjunaths> can't
02:54:02 <manjunaths> Philonous, circle a = Shape { area a = pi*a*a, perimeter a = 2*pi*a } this doesn't work either...
02:54:12 <adnap> Philonous: How about this? http://ideone.com/K9X2r6
02:54:25 <Philonous> @let data Shape a  = Shape {area :: a -> Float; perimeter :: Float}
02:54:26 <lambdabot>  Parse failed: Parse error: ;
02:54:27 <quchen> manjunaths: That's mixing two things. First you have the data type, `data Shape = Shape { area Double, perimeter Double }`, and then you can construct a value with this type using `circle r = Shape { area = pi * r * r, perimeter = 2 * pi * r }`.
02:54:55 <chrisdone> The program 'cvs' is currently not installed. You can install it by typing:
02:54:55 <chrisdone> sudo apt-get install cvs
02:54:55 <chrisdone> hmm. do i, don't i
02:55:19 <adnap> Philonous: I guess I do want to hide the real constructor for F to prevent the creator from calling "_g"
02:55:22 * chrisdone found a git mirror
02:57:28 <adnap> So... http://ideone.com/4ybWmh
02:59:29 <Taneb> I'm now getting a worryingly un-line-wrappy error with emacs
03:00:53 <Taneb> "Flymake: Failed to launch syntax-check process 'ghc-mod' with args (check filepath): Searching for program: no such filepath or directory, ghc-mod. Flymake will be switched OFF
03:00:54 <Taneb> "
03:01:12 <manjunaths> quchen, that didn't work.
03:01:32 <manjunaths> parse error on input 'Double'
03:02:02 <Taneb> Actually, the problem is that .cabal/bin isn't in my path
03:02:06 <Taneb> How do I do that again?
03:04:22 <ersran9> export $PATH=".cabal/bin":$PATH should work I guess
03:04:40 <jjauhien> Hi, where could I get source code and instruction on how to install Leksah IDE?
03:04:59 <manjunaths> jjauhien, cabal install leksah ?
03:05:52 <manjunaths> Oh, great the guy who was helping me got kicked out....
03:05:53 <funfunctor> next issue, what is wrong on line 152? https://gist.github.com/victoredwardocallaghan/7383779 the event handler here is not getting trigger?
03:06:31 <funfunctor> jjauhien: I think cabal can do that for you? try cabal install leksah ?
03:06:44 <ersran9> manjunaths: could you make a paste of your problem?
03:07:04 <jjauhien> I just think about having the latest version - that's why I am looking for sources
03:07:12 <manjunaths> ersran9, http://lpaste.net/95433
03:07:20 <manjunaths> I have that, and I have
03:07:38 <manjunaths> circle a = Shape { area a = pi*a*a, perimeter a = 2*pi*a }
03:07:51 <manjunaths> I don't know how to put these 2 together...
03:09:50 <Taneb> Nope, emacs still isn't finding ghc-mod
03:10:04 <Taneb> (gnome terminal can find it no problem)
03:11:54 <dv-> did you edit your .emacs?
03:12:39 <Entroacceptor> you have to set the path before launching emacs
03:12:42 <ersran9> manjunaths: something like this? http://lpaste.net/95434
03:12:59 <Philonous> manjunaths, Uhh, I'm sorry, when I told you circle needs a parameter, that was nonsense.
03:13:04 <manjunaths> ersran9, checking...
03:13:14 <Taneb> dv-, no
03:13:15 <Entroacceptor> Taneb: or use http://www.emacswiki.org/emacs/ExecPath
03:13:24 <ersran9> oh and make that Float -> Shape, instead of Double -> Shape
03:13:24 <Philonous> manjunaths, The problem is that record field names don't take parameters.
03:13:37 <manjunaths> Philonous, I have been struggling for more than a day, every help is appreciated!
03:13:50 <Philonous> manjunaths, So is has to be "Shape {area = \a -> ... "
03:13:56 <dv-> Taneb: http://lpaste.net/95436 here's what worked for me
03:14:28 <Taneb> dv-, it's got the emacs mode, it hasn't got the executable ghc-mod
03:16:15 <manjunaths> ersran9, Parse error: naked expression at top level
03:17:06 <Philonous> manjunaths, http://lpaste.net/95433 <-- to make your original data type work
03:18:06 <manjunaths> Philonous, Ok, that worked!
03:18:18 <manjunaths> Philonous, Now to see why it worked ?
03:19:20 <manjunaths> Philonous, Ok, record field names don't take parameters, great. Where is this written ?!
03:19:53 <manjunaths> Philonous, How would some rank newbie figure this out ?
03:20:27 <Philonous> manjunaths, I figured it out by plundering into the same mistake and eventually asking in here.
03:20:39 <manjunaths> Philonous, hahaha
03:21:14 <Philonous> manjunaths, other than that you could read the language report.
03:21:57 <Philonous> s/plunder/blunder
03:22:01 <ersran9> manjunaths: if you're using ghc and compiling, then this should work http://lpaste.net/95440 ( for the data type I made :( )
03:22:05 <manjunaths> Philonous, Yeah, that would've worked, if I understood something that arcane and dense...
03:23:16 <Philonous> I perceive that ghc's error message is particularly helpful in this case. "Parse error on input r". I love those.
03:24:02 <manjunaths> ersran9, Yeah, that worked.
03:24:26 <manjunaths> Philonous, Yeah. It is trying to compete with ed
03:25:05 <ersran9> heh
03:25:37 <manjunaths> ersran9, So for each shape type, like circle, square etc., I need to make a new make_circle, make_square etc., function ?
03:27:05 <ersran9> manjunaths: Not really, you could make it with Shape { .. } syntax where you want
03:27:24 <manjunaths> ersran9, Hmm...
03:29:55 <tharper> Is emacs still the popular editor for haskell?
03:30:15 <ersran9> manjunaths: for example http://lpaste.net/95440
03:30:34 <ersran9> its not very nice but you get the idea right
03:30:53 <manjunaths> ersran9, Yes, yes, thank you.
03:31:12 <manjunaths> Ok, full disclosure, I saw this first here...
03:32:11 <manjunaths> https://www.fpcomplete.com/user/tel/lenses-from-scratch
03:32:24 <Philonous> tharper, It's at least a popular editor for haskell
03:32:28 <manjunaths> The early lenses part.
03:32:42 <tharper> Philonous: just wondering, i have used emacs my entire haskell career
03:32:53 <tharper> but recently I switched from Emacs to Intellij for Erlang (my day job)
03:32:56 <tharper> and it was life changing :D
03:33:08 <Philonous> tharper, condolences.
03:33:10 <tharper> wondering if I am being a Luddite by still using it for Haskell
03:33:15 <tharper> Philonous: tell me about it
03:34:23 <manjunaths> So there is a better editor than emacs ?
03:34:28 <manjunaths> For haskell ?
03:35:12 * funfunctor pulls hair out over event handler..
03:36:19 <Taneb> Oh dear, I'm heading towards cabal hell and I don't have time to fix it
03:36:52 <Taneb> free-game is the offender
03:37:12 <ersran9> manjunaths: From my limited experience with haskell, think of it like this : in my data type I have a Shape, which holds area (a value of type float) and  perimeter (same again). The type Lens a b holds get (a function of type a ->b) and set (a function of type b ->a -> a)
03:39:05 <manjunaths> ersran9, So the type parameters a and b are only given when a value is created. Like circle 10.0
03:40:07 <ersran9> well, I think you're confused between type and data constructors :(
03:40:42 <ersran9> are you familiar with Maybe ?
03:40:46 <manjunaths> Yeah.
03:40:53 <manjunaths> Right, understood.
03:40:56 <manjunaths> Damnit.
03:41:15 <ersran9> :)
03:41:24 <manjunaths> Haha...
03:41:49 <jjauhien> Folks, when I am trying to install leksah from cabal (i.e. cabal install leksah) I permanently get an error: http://lpaste.net/95444. What do I miss?
03:42:52 <manjunaths> jjauhien, http://leksah.org/download.html
03:43:01 <manjunaths> Did you try the installer for your platform ?
03:45:18 <jjauhien> manjunaths, I did try (I am on Ubuntu). It is installed fine. However, the version there is only 0.12.<smth> (which is like 1.5 years old) and I would like to try the new version
03:46:11 <manjunaths> jjauhien, hmmm
03:46:44 <manjunaths> jjauhien, Have installed the lib development libraries ?
03:46:53 <manjunaths> s/lib/glib
03:47:12 <manjunaths> The solution is to go to config.log and check what failed and install those.
03:47:14 <jjauhien> no
03:47:25 <manjunaths> It might not be easy...
03:47:30 <jjauhien> hehe
03:47:43 <manjunaths> I think you should see if glib devel libraries are installed...
03:47:52 <jjauhien> How?
03:48:13 <jjauhien> I mean, how could I check if they are installed or not?
03:48:18 <donri> jjauhien: try installing gtk2hs-buildtools first
03:48:32 <jjauhien> from cabal or from Ubuntu?
03:48:53 <jjauhien> (I mean cabal or apt-get?)
03:48:54 <donri> whatever you're installing leksah from
03:49:13 <jjauhien> ok, wait a sec
03:51:39 <jjauhien> OK, cabal install gtk2hs-buildtools  succeeded to finish
03:51:53 <donri> now try cabal install leksah
03:52:36 <jjauhien> :( the same error - what is that glib?
03:53:20 <donri> it's the foundation for gtk
03:53:52 <donri> jjauhien: paste full output from cabal please
03:54:00 <lpaste> pharaun pasted “I could use some advice on if this is the right approach” at http://lpaste.net/95445
03:54:17 <donri> jjauhien: oh btw do you have ~/.cabal/bin in $PATH?
03:54:30 <jjauhien> donri, let me check
03:55:08 <jjauhien> no :)
03:55:15 <jjauhien> should I add it?
03:55:28 <pharaun> Re my paste ^ I know why let c won't type check because - TestComic TestTag != TestComic String - But i'm just wondering how i would do that?
03:55:31 <donri> jjauhien: yes
03:55:55 <donri> export PATH=$HOME/.cabal/bin:$PATH
03:56:18 <pharaun> Ie i want to be able to define a record, give it a parameterized type that the rest of the code doesn't care about (its for the functions in the record itself (state))
03:56:46 <pharaun> and i can always call processor one at a time but it would be nice to be able to pass in a list of records and have it go do its thing one at a time
03:58:13 <yesthisisuser> What indentation level is considered most "standard"? if there is any such consensus
03:58:17 <jjauhien> donri, OK, done
03:58:35 <yesthisisuser> 2, 3?
03:58:46 <Philonous> yesthisisuser, 4
03:59:19 <yesthisisuser> Philonous: oh, isn't that very large
04:00:07 <yesthisisuser> well, i guess 4 is ok. i have used 3 before
04:00:23 <Philonous> yesthisisuser, I like to use this style guide: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
04:00:54 <Philonous> yesthisisuser, it makes larger and nested blocks more easily discernible
04:01:28 <Philonous> yesthisisuser, I find that when I hit the right margin I should break it up into smaller parts.
04:02:05 <Philonous> Or use better abstractions (deeply nested case expressions are a good indicator for that)
04:02:38 <jjauhien> donri, so this is the full output of cabal: http://lpaste.net/95446
04:03:06 <yesthisisuser> Philonous: Thanks, I'll have a look at it. My internet connection is goofing up .. or maybe github
04:04:40 <gienah> jjauhien: setup: The pkg-config package gtk+-2.0 is required but it could not be found. # <== means you need some -dev package
04:04:42 <yesthisisuser> I have become much more pedantic about alignment and stuff, even in other languages since I started with Haskell
04:05:24 <jjauhien> gienah, I wonder which one :)
04:05:35 <int-e> > Right 4 ^? _Left
04:05:36 <lambdabot>   Nothing
04:05:47 <gienah> jjauhien: I have no idea, I use gentoo so I always have all the dev stuff
04:05:56 <jjauhien> :)
04:06:47 <gienah> jjauhien: maybe its some variation on something like gtk2-dev or something
04:07:06 <pharaun> anyway any pointer would be great on if the path i am going down is a good/bad path? :)
04:07:26 <jjauhien> gienah: ok, let me look for something close-naimed
04:08:22 * donri lalala yum install pkgconfig(gtk+-2.0) lalala
04:08:27 <donri> silly non-fedora users :)
04:08:37 <Saizan> pharaun: you could use existential types
04:08:58 <Saizan> pharaun: not sure if it's worth it though
04:09:02 <pharaun> Saizan: ya, i'm just not sure if its the right approach, and i'm still having a little bit of trouble wrapping my head
04:09:36 <pharaun> Saizan: i'm just trying to figure out how to make the api nice, it just seem like it would be nice to be able to write up several records with each site, and their parser, then feed it into a list and send it into the api to be process
04:09:41 <pharaun> processed, rather than doing it one by one
04:09:52 <pharaun> and doing it with list means it would be easy to do parallel map for ex
04:09:54 <jjauhien> donri, boo
04:10:08 <Saizan> pharaun: it's the natural thing to solve your typing problem, but maybe there's some higher-level design choice that could be changed instead
04:10:25 <pharaun> that's what i am wondering if i should be adjusting my approach here
04:10:39 <Saizan> right, but you're not giving enough context to judge
04:11:27 <Saizan> for example, why is it important to parametrize your types? is processor really going to be that polymorphic?
04:11:59 <pharaun> ya, basically 1) I wrote a thing that will fetch webpage and parse them, 2) some website doesn't need additional state/information to completely parse it, others do hence parameterized records. 3) by having parameterized records, means i can write the whole fetch/processor that can just grab the data, bring it back feed it into the testPageParse
04:12:14 <pharaun> and let testPageParse generate additional pages to fetch with *tags* if they need it
04:12:23 <Saizan> are you really going to mix TestComic's with different parameters that often?
04:12:35 <pharaun> i tried to do an ADT of the tags but every time i run over a new site that needed a different set of state/tags
04:12:47 <pharaun> i would have to extend it again and again so i wasn't for sure that it was the right approach
04:13:03 <pharaun> and on TestComic, atm its 6 webcomic sites but i'm looking at maybe having a dozen
04:13:06 <pharaun> or more
04:14:17 <pharaun> Tried to make the parser as context free but the unfortunate thing is some site, i need additional context at latter stage of parsing
04:15:20 <pharaun> Ie i got a page that is a list of chapter, i send this list of chapter to the fetcher to get those pages back, then i parse those page to find additional information, but those pages don't specify what chapter they belong to, thus i need to carry that piece of data along
04:15:36 <Saizan> well, if you really can't find a common api for these "state" types then i guess there's not much we can do
04:15:39 <pharaun> so i've been stuck on this for a bit :) and parameterized type is the best approach i've found so far
04:15:46 <pharaun> i've done an plain ol' ADT
04:15:57 <pharaun> but that gets tendious and i haven't found a common pattern for the "state"
04:16:13 <pharaun> basically i just want a blank box to hold the state, because its *only* consumed/generated in the testPageParse
04:16:17 <Saizan> yeah, you don't want a sum type
04:16:20 <pharaun> the rest of the system need not to care what is inside them
04:16:28 <Saizan> you want a record of functions, if you can tell which functions :)
04:16:36 <pharaun> sum type is what i used initially, it worked but ya
04:17:18 <Saizan> pharaun: then put testPageParse in it! or whatever testPageParse needs to look at it
04:17:34 <pharaun> yup, i used to have like 8 functions and it was getting messy, so i reduced it to "testPageParse :: TestReplyType (blackbox) -> [TestFetchType (blackbox)]"
04:17:41 <pharaun> Saizan: hm?
04:17:53 <pharaun> Saizan: i thought that's what i did here with the TestComic record ?
04:18:19 <pharaun> name is just the name of the site, seed = initial page to fetch, seedType = initial "state" to feed with the initial page to fetch
04:18:31 <pharaun> then after that only thing that should ever be called is the testPageParse
04:19:03 <pharaun> and i have a parameterized type on that function which would do the trick, so i can have various sites have their own state in the a type, works great
04:19:51 <pharaun> but of course by virtue of it being a parameterized type its not going to be the same type so i can't put it in a list to just map over :)
04:20:06 <Saizan> yeah, that was clear
04:20:20 <pharaun> sorry wasn't for sure, i'm still trying to grapple with it
04:22:10 <pharaun> http://stackoverflow.com/a/13107692
04:22:42 <pharaun> ^ seems like that would be what I would want - Encapsulate it into a generic wrapper for passing through the rest of the system
04:23:06 <pharaun> then i can invoke the testPageParse to get a list of next pages to fetch
04:23:45 <Saizan> that's the existential type way
04:24:04 <pharaun> so i guess that would be the best approach for now i guess unless i'm able to find a better way to tackle this
04:27:16 <pharaun> yeah it looks like its what i want, alright thanks Saizan wanted to see if there was a better way :) guess i'll keep on playing with it but mean while i think this existential type will work
04:31:21 <jjauhien> gienah, donri, it was libgtk2.0-dev if you are interested. But there is a new error - src/Text/PrinterParser.hs:230:42: Not in scope: `catch'
04:31:35 <jjauhien> omg
04:31:46 <donri> classic :)
04:32:01 <donri> you'll need to patch it to fix that i think
04:32:03 <donri> or use an older ghc :p
04:32:15 <pharaun> >_<
04:34:49 <gienah> jjauhien: if you would like to paste the build log it might let me know which pkg it is
04:36:07 <jjauhien> gienah, http://lpaste.net/95447
04:36:31 <jjauhien> it's something like ltk
04:38:38 <donri> jjauhien: cabal unpack ltk; $EDITOR ltk-*/src/Text/PrinterParser.hs; add an import Control.Exception; cabal install ./ltk-*
04:38:45 <donri> and report upstream
04:39:10 <gienah> jjauhien: its an old version of ltk, ltk-0.12.1.0 would have more chance of working
04:39:10 <jjauhien> ok, let me try
04:39:30 <jjauhien> hm, maybe I should try to install it then...
04:39:42 <jjauhien> I mean ltk-0.12
04:40:15 <gienah> jjauhien: yeah but it probably requires a sed and a patch: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/ltk/ltk-0.12.1.0-r5.ebuild
04:41:35 <gienah> jjauhien: the sed is on line 46 and 47, and the patch is in the files directory, here: https://github.com/gentoo-haskell/gentoo-haskell/raw/master/dev-haskell/ltk/files/ltk-0.12.1.0-ghc-7.6.patch
04:41:38 <jjauhien> gienah, btw, when I call cabal unpack ltk, it downloads the version 0.12
04:42:23 <gienah> jjauhien: that might be due the Cabal constrain that the sed loosens, but then later you will need to use a cabal command with a constraint on the Cabal library anyway
04:42:37 <gienah> jjauhien: leksah is really tough to build
04:42:55 <jjauhien> gienah: yeah, I feel it :)
04:43:10 <hamishmack> This might help.. https://travis-ci.org/leksah/leksah
04:43:19 <gienah> jjauhien: if you persist though, all the patches and tweaks to build it are in the gentoo-haskell overlay that you can crib from
04:43:54 <hamishmack> It is running this... https://github.com/leksah/leksah/blob/master/.travis.yml
04:44:56 <hamishmack> I recomend trying out the Leksah 0.13 version that is only github currently
04:45:24 <hamishmack> it has quite a lot of fixes that are not in 0.12
04:46:54 <jjauhien> hamishmack, good, but in order to install it from GitHub, should I follow the steps from https://travis-ci.org/leksah/leksah?
04:47:04 <hamishmack> Some instructions also on the bottom of this page http://leksah.org/download.html
04:48:40 <jjauhien> hamishmack: but what version is in cabal?
04:48:46 <jjauhien> 0.12?
04:49:05 <hamishmack> Yes 0.12 is in hackage
04:49:37 <gienah> hamishmack: last time I tried it 2 days ago leksah from git build failed for me: http://lpaste.net/95448
04:50:26 <hamishmack> Hmm that looks like you might have an old version of ltk
04:51:24 <gienah> hamishmack: neat, thanks, will try rebuilding ltk (also the gtk stuff version no.s are renamed in this build log as they clash with the gtk2 ones)
04:51:40 <hamishmack> Latest version should be using conduit instead of enumerator
04:52:12 <gienah> hamishmack: thanks, will see if I can get it building again
04:57:50 <xy127> Hey there anybody cann look over this http://pastebin.com/yCGLrP6H and tell me why it causes a parse error in fiths line? the goal is to calculate the integer sqrt ("wurzel" in german)
04:57:55 <mauke> The paste yCGLrP6H has been copied to http://lpaste.net/95449
05:01:13 <augur_> oh man, ski_: i had been wondering for a while (since like last august) if it was possible to automatically generate proofs of local soundness for connectives
05:01:53 <augur_> ski_: i only just now realized that McBride's Elimination with a Motive is precisely this -- deriving the elims and the soundness in one fell swoop
05:02:01 <augur_> what a derp i am
05:02:36 <prophile> missing a McBride theory is very easy to do, given the sea of puns one usually has to wade through
05:02:49 <augur_> prophile: no see, i've read this paper a bunch
05:02:57 <augur_> i just never made the connection to my ponder
05:03:40 <augur_> and i absorbed the paper. so much so that im almost a mcbridian in thinking this is The One True Way!
05:04:25 <xy127> did small change in lpaste(http://lpaste.net/95449) nevertheless causes this "parse error (possibly incorrect indentation)"
05:10:25 <pharaun> Saizan: ok i've tried it out and i think this will work, thanks <3
05:17:07 <Entroacceptor> xy127: the "if" starts at the same column as the "wurzelHelper". Try indent it more
05:17:19 <xy127> ah ok
05:18:30 <Entroacceptor> and "wurzel 5" is 3, I don't know if that is what you intent :)
05:22:02 <jjauhien> hamishmack: why do I need darcs for installing?
05:22:24 <xy127> ^^no it wasnt :/
05:22:31 <gienah> jjauhien: because gtk uses darcs I guess
05:22:37 <hamishmack> gtk2hs used to be in darcs
05:23:06 <hamishmack> But it has moved to github now
05:23:30 <jjauhien> so I don't need to install it? Because I get an error from cabal :)
05:23:39 <hamishmack> cabal-meta used to run darcs to get it
05:23:55 <hamishmack> you should not need darcs any more
05:25:05 <jjauhien> ok
05:26:08 <shiona_> Control/Monad/Trans/Error.hs:55:21: Not in scope: `catch'
05:26:17 <shiona_> which unwritten dependency am I missing?
05:26:43 <chrisdone> probably a bad version
05:28:06 <shiona_> is there anything I could do?
05:30:10 <shiona_> I thought that I might have just misused cabal the last time but it seems I cannot get it working even from a clean slate
05:35:46 <shiona_> seems that somewhere down the requirement chain from diagrams is transformers 0.2.2.0, which depends on catch, which was dropped from prelude
05:36:41 <shiona_> so we have a) probably too strict requirement for transformers version, and one too non-strict requirement for core
05:39:29 <shiona_> I also assume there is no way to find reverse dependencies, making tracing the problem next to impossible
05:44:45 <byorgey> shiona_: diagrams definitely does not depend on transformers 0.2.
05:45:02 <byorgey> shiona_: what versions of GHC/cabal/Haskell Platform do you have?
05:45:25 <byorgey> and what version of diagrams are you trying to install?
05:45:48 <xy127> ok thanks u now i fixed it and everything works fine http://lpaste.net/95449 :)
05:45:51 <xy127> cu
05:52:04 <kryft> I have a character with an inventory of various kinds of items (weapons, armor, potions, etc.). Some methods make sense for all items where as some only make sense for specific kinds, so one way of modeling this would be to have a type class with subclasses. But I guess then I couldn't have a heterogeneous collection of them?
05:52:23 <kryft> s/methods/functions :P
05:54:06 <shiona_> byorgey: umm a second, I'll have to check
05:54:31 <shiona_> but I installed the newest cabal and ghc from debian testing
05:55:13 <kryft> I could also just have an ADT (something like Item = Weapon | Armor | Potion), but then I would lose the natural hierarchy
05:55:25 <shiona_> ghc 7.6.3-5, cabal-install 0.14.0-2
05:55:37 <kryft> Any thoughts on this?
05:55:54 <shiona_> byorgey: sorry for the late answer, had to afk
05:56:49 <kryft> (Also I guess the ADT would have to be something like Item = Weapon WeaponRecord | Armor ArmorRecord etc.)
05:57:12 <kryft> Oh, but I guess I can have the type class structure for the FooRecord types
05:57:45 <kryft> I think I answered my own question, but do let me know if there are other solutions worth considering :)
06:00:53 <shiona_> wait what, cabal install diagrams installed some ancient 0.5 version
06:00:57 <kryft> Would existential types work, if that's the right term? It seems like they might, but I'm too tired right now to absorb the concept properly
06:01:01 <shiona_> why would it do such a thing
06:04:07 <shiona_> for some reason my cabal platform knows diagram only up to 0.5. I ran cabal update an hour or so ago
06:04:31 <shiona_> oh, cabal update is per-user based right?
06:10:22 <hpc> shiona_: "cabal update" is the same as apt-get update
06:10:27 <hpc> it just downloads the db
06:10:48 <hpc> it also doesn't try to keep packages "up to date", it merely manages dependencies
06:11:30 <hpc> trying to keep things fully up to date can cause dependency issues, so you really only want to install a new version of a package when you need a new feature
06:11:39 <hpc> or a bugfix or something
06:12:19 <shiona_> hpc: but cabal update downloads the repo for the current user, not globally, right?
06:12:23 <shiona_> that must have been my problem
06:12:43 <hpc> oh, yes
06:12:50 <hpc> quite likely
06:13:13 <shiona_> I thought I had not ran cabal update ever for my user, but it seems I had
06:13:57 <shiona_> I ran update as root, started install, immediately remembered I should not do that, switched to my user, started install, thought that it would tell me to run update again but it worked
06:14:16 <shiona_> so I thought the package list would have been downloaded globally across users
06:14:45 <hpc> root has a local repo too, btw
06:15:18 <shiona_> but now it seems it might work
06:15:31 <shiona_> how do I purge old versions of packages?
06:16:13 <int-e> ghc-pkg unregister, though that leaves the files in place
06:16:35 <shiona_> I guess I'll end up walking through .cabal manually then
06:16:47 <shiona_> In the evening once the install completes
06:17:03 <shiona_> now I'll need to do some work
06:18:48 <hpc> you also need to make sure you don't unregister a dependency of something else
06:42:03 <byorgey> kryft: type classes and existential types are almost certainly *not* the right solution.
06:42:41 <byorgey> type classes don't really work well for modelling OO class hierarchies.
06:50:00 <funfunctor> Anyone around used vty? I rather stuck trying to get my application to switch focusGroups on an event handler
06:50:21 <mm_freak_> you mean vty-ui
06:50:45 <mm_freak_> i'm really really glad those two are separate projects =)
06:51:02 <funfunctor> mm_freak_: yep
06:51:14 <funfunctor> Its a fantastic bit of work
06:51:20 <mm_freak_> vty is
06:51:37 <moops> is it possible to do this with fold? my brain is broken: data Apply = Apply Int Int; [1, 2, 3, 4, 5] => (Apply (Apply (Apply (Apply 1 2) 3) 4) 5)
06:52:20 <funfunctor> mm_freak_: all the code is here https://github.com/alterapraxisptyltd/serialterm I am trying to get a key to invoke a help menu dialog to flash up..
06:52:44 <funfunctor> mm_freak_: I seperated out the menus into their own functions so its easier to read now.
06:53:02 <mm_freak_> moops: data Apply = Apply Apply Apply | Lit Integer
06:53:36 <moops> err thats what i meant
06:53:40 <mm_freak_> funfunctor: sorry, i'm not that experienced with vty-ui
06:54:23 <moops> its like an inside out list
06:54:47 <funfunctor> mm_freak_: what the diff between vty and vty-ui?
06:54:51 <mm_freak_> :t foldl1
06:55:05 <mm_freak_> oh, lambdabot is gone
06:55:20 <mm_freak_> moops: it's a foldl1
06:55:31 <moops> that gets me (Apply 1 (Apply 2 ( Apply 3 (Apply 4 5))))
06:55:33 <int-e> :t foldl1
06:55:39 <lambdabot> (a -> a -> a) -> [a] -> a
06:55:43 <mm_freak_> moops: no, that's foldr1
06:55:56 <moops> i just tried it
06:55:59 <int-e> > 1
06:56:09 <lambdabot>   Could not find module `Data.Default'
06:57:44 <int-e> > fix ((0:) . scanl (+) 1)
06:57:53 <moops> im like 99% sure
06:57:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:58:01 <mm_freak_> > foldl1 f [x,y,z]
06:58:08 <lambdabot>   f (f x y) z
06:58:31 <mm_freak_> moops: foldl1 Apply . map Lit
06:58:32 <moops> maybe my list isnt what i think it is
06:58:48 <int-e> good. (compiler update, I was still using 7.6.2, now it's 7.6.3, and I got some practice for the coming 7.8.1 :-) ... sorry for that.)
06:59:25 <jophish> yo yo yo
07:00:59 <bz> priority queue recommendations?
07:01:52 <moops> mm_freak_: my list wasnt what i thought it was, thanks for the sanity check :)
07:02:13 <mm_freak_> there you go =)
07:05:35 <jophish> How can I get ghc to output llvm IR?
07:09:08 <jophish> ah, -keep-llvm-files
07:10:24 <jophish> Where could I read about lowering a language such as Haskell to a language without currying?
07:10:49 <jophish> The specific question I have is, what's the standard way of calling a curried function.
07:11:02 <jophish> for example I have: foo:: Int->Int->Int;
07:12:46 <jophish> Would I have a data type in my program "FooData" which holds onto an Int and a function pointer, and two functions to simulate a call to foo. Foo1 :: Int -> FooData, and Apply2 :: FooData -> Int -> Int
07:13:51 <jophish> a better way of saying that would be: FooData foo1( Int ) and Int Apply2( FooData, Int)
07:14:59 <jophish> I suppose that this is a special case of defunctionalization, where instead of just storing an identifier for a function to call, one stores the identifier and all curried arguments so far
07:15:15 <jophish> What a nightmare
07:16:52 <jophish> This may be what GHC is doing, I can't tell for sure, there seems to be a lot of extra information being given to llvm
07:17:04 <jophish> whois simon
07:17:41 <jophish> oops, disregard that
07:17:51 <jjauhien> ;)
07:31:03 <moops> is there a simple way to create a function with a timeout? i am running tests that might get into infinite loops
07:31:11 <moops> some sort of blocking subprocess maybe
07:33:26 <moops> Int -> a -> IO (Either Timeout a)
07:34:09 <quchen> moops: System.Timeout?
07:34:41 <quchen> moops: You can also make one using Control.Concurrent.Async.race
07:35:07 <moops> oh this looks perfect
07:35:13 <moops> thanks
07:36:18 <moops> the stuff on stackoverflow made it seem super complicated
07:37:35 <zol> I am doing some homework at the moment, where I have to implement some functions -- to make it easier for me I thought I would write some tests that I can run all at once instead of doing it manually over and over ghci. However LYAH haven't really gone through how to produce output yet. How would you call the same function a few times with different input and output the result?
07:38:19 <moops> main = do
07:38:19 <moops>     print $ map runMyTest [input1, input2, input3]
07:38:40 <TallerGhostWalt> so what is the trick to compose Lenses after an Indexed Lens?
07:38:49 <zol> moops: Aha, thank you!
07:43:04 <zol> moops: My function is taking two parameters, how can I use map to apply a function onto two values? I will need an auxiliary function?
07:43:24 <moops> you can have a list of tuples then use uncurry
07:43:30 <supki> TallerGhostWalt: what do you mean?
07:43:54 <moops> map (runMyTest . uncurry) [(x1, y1), (x2, y2)]
07:44:04 <zol> moops: Aha, again - thank you!
07:44:04 <moops> i may have those backwards
07:44:10 <zol> moops: I will sort it out. :)
07:44:16 <moops> im new to this myself :P
07:45:31 <supki> :t map (uncurry ?runMyTest)
07:45:32 <lambdabot> (?runMyTest::a -> b1 -> b) => [(a, b1)] -> [b]
07:45:49 <funfunctor> what does 'const' do? evalue a function to a constant value?
07:46:01 <zol> supki: What does the ? mean in this case?
07:46:06 <moops> @src const
07:46:07 <lambdabot> const x _ = x
07:46:26 <supki> zol: "please figure out this type for me" :)
07:46:32 <dv-> > map (const 1) [1,2,3]
07:46:34 <lambdabot>   [1,1,1]
07:46:50 <supki> zol: it's ImplicitParams extension
07:48:05 <Taneb> How do I use TH to do IO at compile time?
07:49:27 <chrisdone> Taneb: use runIO
07:49:57 <Taneb> chrisdone, how do I then get the result of the IO into the code?
07:50:11 <chrisdone> return it as some expression or declaration
07:51:06 <zol> http://hastebin.com/qarafiroyu.haskell -- this error message is a little beyond me.
07:51:42 <zol> Does this mean it worked, just that it can't print the returned statement because it is lacking a Show?
07:52:06 <chrisdone> zol: yeah
07:52:11 <chrisdone> zol: use :t instead
07:52:44 <Taneb> Hmm, I don't think I can in this instance
07:52:49 <zol> chrisdone: Thanks!
07:53:14 <shiona_> is there a way to get cabal install to give a bit more information where the installation is going in the big picture
07:54:04 <shiona_> I'm installing around a hundred packages and the [x of y] information is package specific
07:54:44 <shiona_> I don't know if there are no packages to go after the one it's working on atm, or fifty
07:55:22 <funfunctor> this is a bit dumb but how do I rewrite this with "where" https://gist.github.com/victoredwardocallaghan/7386689 so its IO () and not IO ( IO ()).
07:55:39 <DanielDiaz> :t join
07:55:40 <lambdabot> Monad m => m (m a) -> m a
07:55:56 <DanielDiaz> funfunctor: maybe that helps
07:58:12 <funfunctor> DanielDiaz: its a bit of a hack.. I should be lambda lifting I think..
08:00:58 <DanielDiaz> funfunctor: I don't know the type of the functions you are using there, but join applied to anything of type IO (IO ()) will do it IO ().
08:02:23 <funfunctor> yep I am using join for the moment now..
08:06:12 <chrisdone> Luke: hey
08:06:27 <Luke> hey how's it goin?
08:06:46 <chrisdone> good. i'm near to an alpha release of structured-haskell-mode :3
08:07:02 <Luke> oh what's that?
08:07:04 <chrisdone> should be complimentary to snippets, too
08:07:18 <Luke> want me to check them in now?
08:07:20 <chrisdone> a mode that gives you paredit-like functionality for haskell-mode
08:07:25 <Luke> nice!
08:07:38 <Luke> ast transforms?
08:07:40 <chrisdone> whenever you feel like it
08:07:50 <Luke> yeah I actually have free haskell time just now
08:08:02 <chrisdone> yeah, it parses the declaration and then makes markers for all those node positions in the buffer
08:08:26 <Luke> wow. did you write it as an external haskell process or all in elisp?
08:08:46 <chrisdone> the parsing step is an external haskell process that uses HSE, and the rest is elisp
08:09:07 <funfunctor> DanielDiaz: I am having a lot of problems (with lazy evalutation I *think*) trying to get a event handler to trigger
08:09:13 <chrisdone> Luke: wanna try it?
08:09:21 <Luke> absolutely!
08:09:34 <chrisdone> k i'll add you as a collab to the project (it's private atm)
08:09:35 <cinimod> I need to sequentially update a grid
08:09:47 <cinimod> afaics one should use Data.Vector for efficiency
08:09:48 <funfunctor> DanielDiaz: all the code is here https://github.com/alterapraxisptyltd/serialterm
08:09:57 <Luke> chrisdone: unrelated: I've been having a weird side affect with stylish-haskell where when I add a new import and run the save hook, it kills a big chunk of the import list
08:09:59 <cinimod> And it does seem fast
08:10:11 <cinimod> I am getting 10^9 updates on 100 x 100 grid in 1 minute
08:10:12 <Luke> chrisdone: sounds good
08:10:33 <Luke> We have the haskell chicago hackathon today so I should have ample time for this stuff =) so excited
08:10:41 <chrisdone> sweet!
08:10:42 <funfunctor> DanielDiaz: the main issue is on line 120 of Main.hs
08:10:51 <cinimod> But a) I don't really want to calculate the offsets myself
08:10:57 <chrisdone> Luke: yeah i rarely use stylish. it seems to require a save before running it. is that related?
08:11:00 <cinimod> And b) I'd like parallelism
08:11:06 <DanielDiaz> funfunctor: what's Graphics.Vty?
08:11:12 <cinimod> http://lpaste.net/95455
08:11:26 <Luke> chrisdone: why don't you use stylish? didn't you write it?
08:11:34 <DanielDiaz> funfunctor: terminal access library, ok.
08:12:00 <funfunctor> yep
08:13:12 <chrisdone> Luke: i did write the elisp binding to it, i just don't seem to use it much =o
08:13:19 <Luke> I see
08:13:34 <chrisdone> Luke: added. so you just need to clone it and cabal install it. ah, and you need mgsloan's haskell-src-exts version. hold up
08:13:36 <Luke> yeah I just run it on save hook but I think you're right. It requires a save first
08:13:48 <Luke> k
08:16:37 <zol> I am somewhat confused. I have a function singleWildcardMatch :: [a] -> [a] -> Maybe [a], if I want to make a recursive definition, won't I need a bunch of Ifs and Elses to handle the different results?
08:17:25 <funfunctor> :t const
08:17:26 <lambdabot> a -> b -> a
08:17:42 <funfunctor> :t id
08:17:43 <lambdabot> a -> a
08:18:35 <moops> zol: not sure what you mean
08:18:54 <moops> what does the function do?
08:19:04 <DanielDiaz> funfunctor: I have never used vty, but the docs say that you have to execute the action returned by addToCollection to "switch to the interface specified in the call"
08:19:31 <funfunctor> DanielDiaz: ok but am I not doing that on line 120 in Main.hs?
08:19:50 <zol> moops: The instructions are actually quite unclear, maybe that is why I am having problems with it. Will try to verify it. Brb.
08:20:09 <DanielDiaz> funfunctor: I see in your code that you are skipping the result of "addToCollection c ui fgr". I don't know if it has something to do with that.
08:20:21 <jophish> I often find myself writing (id &&& foo) exp. Is there a nicer way of doing this?
08:21:04 <Iceland_jack> @unpl (id &&& foo)
08:21:04 <lambdabot> ((\ a -> a) &&& foo)
08:21:04 <Iceland_jack> :D
08:21:10 <funfunctor> DanielDiaz: well that works fine, have a look at line 39 and 120
08:21:11 <Luke> chrisdone: sorry disconnected
08:21:11 <Iceland_jack> now wasn't that useful?
08:21:51 <triliyn> @unpl f &&& g
08:21:51 <jophish> :)
08:21:51 <lambdabot> (f &&& g)
08:21:53 <funfunctor> DanielDiaz: I have another addToCollection in changeToHelp
08:21:57 <DanielDiaz> funfunctor: right.
08:22:08 <triliyn> Does it not know &&& and ***?
08:22:12 <chrisdone> Luke: i couldn't figure out what version of sloan's HSE i'm using. i'm just gonna strip out the code i don't need so it works with hackage hse
08:22:31 <Luke> sounds good
08:22:54 <khyperia> Is there an easy way to have a function "(Read a) => Parser a" (where Parser is the type from Parsec)?
08:22:57 <dv-> jophish: _1 %~ id ?
08:23:13 <funfunctor> DanielDiaz: So the line I suspect is 120, although the changeToHelp function could be written better with some lambda lifting?
08:23:18 <jophish> dv-: ?
08:23:29 <Iceland_jack> jophish: Lens
08:23:29 <dv-> jophish: if you use lenses
08:23:49 <Iceland_jack> I wouldn't say it's any better than just using a lambda
08:23:49 <jophish> ap (,) foo may do
08:24:00 <jophish> ah, I've never used lenses
08:24:12 <Iceland_jack> :t \a -> (a, ?foo a)
08:24:13 <lambdabot> (?foo::t -> t1) => t -> (t, t1)
08:24:19 <Iceland_jack> perfectly legible
08:24:37 <chrisdone> i prefer (id &&& f)
08:24:37 <dv-> > (_2 %~ (+1)) (1,1)
08:24:40 <lambdabot>   (1,2)
08:24:43 <funfunctor> DanielDiaz: I have this inclination that I should be using const here or something?
08:24:57 <dv-> > (_2 %~ (+1)) (1,1,1,1)
08:24:58 <lambdabot>   (1,2,1,1)
08:24:59 <Iceland_jack> That's the good thing about preference :)
08:25:05 <jophish> ap (,) (+1) 2
08:25:09 <jophish> > ap (,) (+1) 2
08:25:11 <lambdabot>   (2,3)
08:25:24 <dv-> with lens you get the same syntax for , ,, ,,, ...
08:25:40 <chrisdone> dv-: what's the non line noise version of %~?
08:26:01 <dv-> chrisdone: over i think
08:26:06 <nooodl> over
08:26:11 <nooodl> > over _1 (+1) (3,4,5)
08:26:13 <lambdabot>   (4,4,5)
08:26:17 <chrisdone> much better
08:26:52 <dv-> i've been thinking about using pretty-mode.el to replace lens operators with nicer unicode characters
08:27:22 <chrisdone> dv-: so only your audience have to suffer, not you?
08:28:01 <dv-> they should just use emacs then :p
08:28:14 <DanielDiaz> funfunctor: I think join is nice. It is just ">>= id". I don't think this is about lazy evaluation. In any case, maybe you should ask someone who knows more about this particular library.
08:28:36 <jophish> I think I prefer (id &&& foo), Thanks guys
08:29:20 <DanielDiaz> I'm leaving now, bye-bye. : )
08:29:30 <DanielDiaz> funfunctor: good luck.
08:29:33 <jfeltz> is there a way to coerce a newtype to the type of it's payload, without creating an accessor function, or pattern match?
08:29:34 <funfunctor> DanielDiaz: hmm ok, so it _looks_ like I am doing the right thing though? Because I am still pretty bad with my arrows syntax at the moment. I keep forgetting them.
08:29:44 <funfunctor> Cheers DanielDiaz
08:29:55 <Iceland_jack> jfeltz: What's wrong with using an accessor function?
08:30:08 <zol> How can I make a list as long as another list?
08:30:14 <Iceland_jack>     newtype IPv4 = IPv4 { getIPv4 ∷ Word32 }
08:30:28 <Iceland_jack> there you've made an accessor function, no biggie
08:30:29 <nooodl> zol: what do you want to pad the list with, if the other one is longer?
08:30:31 <donri> > over (upon fst) (+1) (3,4,5)
08:30:32 <lambdabot>   Couldn't match expected type `(a0, b0)'
08:30:32 <lambdabot>              with actual type `(t0,...
08:30:37 <Iceland_jack> zol: zipWith const :)
08:30:38 <donri> > over (upon fst) (+1) (3,4)
08:30:39 <lambdabot>   (4,4)
08:30:41 <donri> :p
08:31:33 <jfeltz> Iceland_jack, it occured to me because newtype constrains itself to just 1 field (and only one constructor), that the logical advantage is to skip using an accessor alltogether
08:31:53 <Iceland_jack> > zipWith const "Only first 4 character!" [1..4]
08:31:55 <lambdabot>   "Only"
08:32:07 <WraithM> I let my program run with profiling turned on for a couple of hours (maybe a bad plan...). Should hp2ps take a really long time?
08:32:35 <zol> noodl: Well, actually what I really want (trying to solve it myself), is to perform a longer wildcard match, so that longWildcardMatch "*do" "dobedo" returns "dobe". I thought that if I reverse the two lists and then iterate over them till they are not equal anymore, I can return the sublist. :)
08:32:38 <Iceland_jack> jfeltz: How would you distinguish between the contained type and the newtype wrapper?
08:32:52 <Iceland_jack> zol: Did you see my example?
08:32:58 <zol> Iceland_jack: No!
08:33:05 <Iceland_jack> Well that's very honest of you
08:33:16 <zol> Iceland_jack: Am looking now :)
08:33:20 <cinimod> WraithM: I have a vague recollection that if the profile data gets corrupted hp2ps sits there doing nothing
08:33:59 <cinimod> WraithM: How big is your hp file? I am talking from a level of ignorance as it is several years since I have used the tool.
08:34:14 <WraithM> Oh, well, that's not good. It seems to be doing something. It's eating up CPU and memory.
08:34:23 <jfeltz> Iceland_jack, what I want is the option, so a function such as generalCoerce thenewtype is what I want, but I understand that kind of defeats the purpose of newtype
08:34:49 <WraithM> My hp file is 700 MB...... :(
08:35:01 <cinimod> WraithM: That does sound quite large
08:35:10 <Iceland_jack> So you'd like to be able to use (ip ∷ IPv4) both as an IPv4 and an Int?
08:35:13 <zol> Iceland_jack: It is the second argument that I want to return the rest of, is it possible to use flip to switch the arguments to const?
08:35:28 <jophish> zoli: flip the list order?
08:35:32 <jophish> zol*
08:35:39 <Iceland_jack> zol: What jophish said
08:35:47 <jfeltz> Iceland_jack, dependant on the context, because I can't predict all the possible use-cases
08:36:04 <Iceland_jack> Well I mean, a part of newtypes is type safety
08:36:21 <zol> jophish: I can't. This is homework, the interface was decided by someone else.
08:36:35 <jophish> zol, use flip const then
08:36:38 <Iceland_jack> zol: experiment on your own :)
08:36:39 <moops> in ML you can rebind a variable in the same scope using the old value, eg let a = 1 in let a = a + 1 in expr, is there a type system reason to disallow this in haskell?
08:37:02 <moops> ocaml*, dunno about SML
08:37:10 <jophish> zol, sorry, that Iceland_jack said
08:37:16 <donri> moops: recursion?
08:37:20 <Iceland_jack> moops: The type system doesn't disallow it
08:37:22 <Iceland_jack> :t let a = 1 in let a = a + 1 in undefined
08:37:23 <lambdabot> a
08:37:26 <donri> ocaml makes you say "let rec" doesn't it
08:37:59 <moops> its not recursive in ocaml
08:38:05 <donri> exactly
08:38:08 <Iceland_jack> But ‘a’ is in scope as you're defining it allowing you to do things like:
08:38:08 <Iceland_jack> > let xs = 1:xs in xs
08:38:09 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:38:18 <moops> so its about lazy semantics?
08:38:20 <donri> so the 'a' can't refer to itself, so it must be the outer scope
08:38:46 <donri> in haskell, "let" is "let rec" so 'a' can refer to itself, and therefore does
08:38:58 <moops> ahh okay
08:39:07 <Iceland_jack> moops: Is this a problem for you? The type system certianly allows it as I showed earlier
08:39:33 <Iceland_jack> > let a = 'a':map succ a in a
08:39:35 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
08:39:56 <jfeltz> Iceland_jack, wait a second, you don't actually gain any safety by the accessor, because by the time I've passed the newtime in to the function, i've already made the decision to use it
08:40:06 <jfeltz> newtype into the function*
08:40:32 <shiona_> I remember there being some language derived from haskell with some added functionality to types whose name was some hot spice (no, I'm not talking about curry)
08:40:37 <khyperia> oh that's cool, Iceland_jack
08:40:39 <shiona_> any idea what it could have been
08:40:40 <zol> I like how undefined is defined.
08:40:57 <Iceland_jack> jfeltz: If you have a function which gives a score to an IPv4 address (for whatever reason) might look like this:
08:40:57 <Iceland_jack>     giveScore ∷ IPv4 → Int → IO ()
08:41:11 <donri> Iceland_jack: moops is talking about referring to the "a" of the outer scope
08:41:26 <Iceland_jack> donri: Well don't shadow the name then
08:41:43 <donri> in deed
08:41:49 <Iceland_jack> So if IPv4 were a type synonym for Int, you would swap the arguments and it would compile
08:42:06 <Iceland_jack> jfeltz: If IPv4 is a newtype wrapper around Int however, you would get a type error
08:42:52 <moops> Iceland_jack: just making a toy language and trying to choose which to follow
08:43:17 <moops> probably will follow neither because my language is strict and rebinding like that will complicate type inference i think
08:43:17 <nooodl> hmm... is there like, a way to write a type for (m x n) matrices, or arrays
08:43:25 <Iceland_jack> moops: I mean either one is fine, but shadowing variables and then referring to the outer one is not much of a feature
08:43:34 <jfeltz> Iceland_jack, I'm not asking the coerce the binding of the newtype alone, i'm asking for _another_ function, which can coerce the binding
08:43:36 <shiona_> it was cayanne
08:43:49 <nooodl> i'd like to write chessBoard :: Matrix Eight Eight Piece instead of Map (Int, Int) Piece or something
08:43:54 <Iceland_jack> nooodl: Sure, Google “haskell type-safe matrices”
08:44:15 <Iceland_jack> jfeltz: Well there exists no such function in general, at least none which you should use
08:44:28 <jcarpenter2> nooodl: dependent types perhaps?
08:44:33 <Iceland_jack> you can easily make an accessor function however, I hope that answers your question
08:44:43 <Iceland_jack> jcarpenter2: You don't need full-blown dependent types for that
08:44:53 <moops> its a fairly common idiom in ocaml iiuc, but its a bit silly too
08:44:54 <jcarpenter2> really?
08:45:03 <nooodl> isn't this a GADT or something
08:45:51 <Iceland_jack> jcarpenter2: You encode natural numbers int the types, parameterize the matric type with them
08:46:07 <lpaste> gniourf pasted “Problems Showing IO Chars” at http://lpaste.net/95457
08:46:09 <zol> nooodl: Iceland_jack moops: This is how I wrote it: http://hastebin.com/qalovuloke.haskell :)
08:46:10 <Iceland_jack> GHC 7.8 even has a type-nat constraint solver so that will only get better
08:46:24 <Jeanne-Kamikaze> put your monads in the air, this is a robbery
08:46:44 <Iceland_jack> Jeanne-Kamikaze: I don't own anything
08:46:46 <nooodl> also relatedly, the "chessboard" i'm looking to implement is really 80x24. that sounds a lot more painful to write with type naturals
08:46:49 <Iceland_jack> jokes on you
08:47:10 <nooodl> is there a better syntax for them than data One = Succ Zero, data Two = Succ One, ... data Eighty = Succ SeventyNine?
08:47:23 <Iceland_jack> nooodl: There are libraries for this :) check them out
08:47:29 <nooodl> err i mean type*
08:47:31 <jcarpenter2> oh, dependent types would give you the ability to make a program where you pick the size of the chess board at runtime?
08:48:11 <Iceland_jack> dependent types just say that you can have types depend on the input values
08:48:23 <jcarpenter2> okay
08:48:34 <Iceland_jack> jcarpenter2: an example would be the printf function
08:48:37 <Iceland_jack> gniourf: You need to do:
08:48:37 <Iceland_jack>     a ← rndSelect "Hello, World!"
08:48:42 <chrisdone> Luke: can you try cabal install now? it should work with HSE 1.14
08:48:54 <Iceland_jack> let a = … makes (a ∷ IO Char)
08:48:58 <Luke> yup
08:49:10 <nooodl> Iceland_jack: would you happen to know which one's most popular?
08:49:19 <Iceland_jack> nooodl: not really
08:49:28 <Iceland_jack> and 'print a' is a type error if 'a ∷ IO Char'
08:49:34 <gniourf> Iceland_jack, oh dear, it works!!! thanks so much...
08:49:49 <Iceland_jack> gniourf: You're welcome
08:50:13 <gniourf> I'm trying to learn this stuff about IO's but it's not the easiest :) and very frustrating when you just can't compile :D
08:50:29 <Iceland_jack> zol: you can turn 'all (== True)' into 'and'
08:51:08 <kryft> byorgey: Thanks! Can you suggest something instead?
08:51:13 <zol> Iceland_jack: Do you think it is more expressive to use just and?
08:51:32 <Iceland_jack> Expressive?
08:51:36 <zol> More clear
08:51:37 <Luke> chrisdone: what's the package called?
08:51:39 <Iceland_jack> yes
08:51:46 <Iceland_jack> @src and
08:51:46 <lambdabot> and   =  foldr (&&) True
08:51:46 <Luke> i have HSE already
08:51:54 <Iceland_jack> @ty all
08:51:55 <lambdabot> (a -> Bool) -> [a] -> Bool
08:51:57 <chrisdone> Luke: it's in the repo itself, so just cd structured-haskell-mode; cabal install
08:52:00 <Iceland_jack> sorry,
08:52:00 <Iceland_jack> @src all
08:52:00 <lambdabot> all p =  and . map p
08:52:08 <kryft> byorgey: I was starting to think that this is probably not the best way to do it. :P
08:52:18 <Luke> oh you were only talking about HSE being in hackage. gotcha
08:52:39 <Iceland_jack> so you see that what you're writing really turns into: 'and ∘ map (== True)'
08:52:57 <Iceland_jack> where 'map (== True) xs' is always the same as 'xs' if it type checks
08:53:02 <Iceland_jack> (modulo ⊥)
08:53:13 <Iceland_jack> > map (== True) [True, False, True]
08:53:14 <lambdabot>   [True,False,True]
08:53:27 <Iceland_jack> so you might as well use 'and':
08:53:27 <Iceland_jack> > and [True, False, True]
08:53:28 <lambdabot>   False
08:53:56 <chrisdone> Luke: yeah. and then you should be able to just load the structured-haskell-mode.el and switch to a haskell buffer and M-x structured-haskell-mode. the minor mode's default keybindings might conflict with your own, and they're still a bit rough. but you should see a highlight when you move between nodes. and in your modeline there should be "SHM" when all is well, and "SHM!" when there's a parse error
08:54:28 <Luke> nice! installing now
08:54:37 <chrisdone> i just pushed a tweak so that you can configure the current node face
08:54:55 <nooodl> the Linear package looks cool but it only supports up to 4x4 matrices, apparently?
08:54:57 <chrisdone> shm-quarantine-face -- for erroneous declarations, and shm-current-face -- for the current node
08:55:14 <chrisdone> (by default they're tailored for zenburn, so probably look like hell on anything else)
08:56:29 <Luke> chrisdone: I'm using solarized - dark should be close enough
08:57:05 <chrisdone> Luke: cool =)
08:58:54 <Taneb> What's the best way to get a Haskell program to play an MP3?
08:59:13 <chrisdone> i managed to get SDL to play .wavs
08:59:18 <Luke> chrisdone: I'm getting dependency issues (I think unrelated to your package) - may take a bit to work through
08:59:24 <rasfar> if i were about to rebuild World, is there something I can do to force all necessary downloads to happen up front? my online time is limited unfortunately.
09:00:05 <rasfar> (had profiling libs being NOT installed by default, for the same reason, and now find I need 'em)
09:00:06 <chrisdone> Luke: what are the dep issues?
09:00:21 <Luke> base
09:00:24 <chrisdone> Luke: i'm only using base and haskell-src-exts. but the version of HSE doesn't have to be so high, perhaps
09:00:28 <chrisdone> ahhh
09:00:42 <Luke> looking to resolve now
09:00:42 <chrisdone> maybe just loosen the restriction. it's ==4.5.* in my cabal file but that's just what cabal init put there
09:00:44 <Luke> this is my fault
09:00:46 <rasfar> meantime guess i'll try a sandbox build for this project
09:00:49 <Luke> yeah
09:00:56 <chrisdone> i'll change it to >= 4 && < 5
09:00:59 <Luke> my cabal is a super mess right now =)
09:01:30 <Luke> yeah that did it
09:01:32 <chrisdone> sweet
09:01:42 <Luke> I'm building in cabal sandbox... doesn't it just try to rebuild everything anyway?
09:01:48 <chrisdone> i pushed that version, fwiw (so you don't have to have a dirty copy of SHM)
09:01:54 <Luke> do you know if you can use cabal-meta on top of cabal sandbox?
09:01:58 <Luke> ok
09:01:59 <Luke> thanks
09:02:05 <chrisdone> huh, dunno. not tried cabal sandbox yet
09:02:14 <chrisdone> still on hsenv
09:03:04 <chrisdone> does that install now?
09:03:24 <rasfar> i need to "cabal init" in my project if I want to sandbox, right?
09:03:28 <rasfar> can that stomp any files?
09:05:15 <rasfar> okay thanks, i'll just move everything then
09:05:28 <jophish> Does anyone here use any kind of source formatter for Haskell?
09:05:44 <Luke> jophish: stylish-haskell
09:06:02 <jophish> I've come to rely on clang-format for c++, There's a pretty printing module for haskell ASTs, but it eats all comments
09:06:22 <jophish> Luke: That doesn't seem to do things like column limits
09:06:23 <chrisdone> stylish-haskell uses HSE but retains comments
09:06:42 <chrisdone> although it strips out other things like ^L, but only arcane emacs users like me care about that
09:06:54 <jophish> what's ^L?
09:07:08 <jophish> ah, page break
09:07:10 <chrisdone> the page separator character interpreted by emacs
09:07:30 <chrisdone> yeah, i think stylish tries to do very very minimal changes
09:08:12 <chrisdone> it's pretty easy to break haskell code. stylish just changes some imports stuff
09:08:32 <jophish> It would be great to have a tool which will produce the same output for code which generates the same AST (modulo comments)
09:08:33 <Luke> its the first thing you see in a file though!
09:08:57 <chrisdone> yeah, i want an 'indent' for haskell
09:09:06 <jophish> I had one idea a bout how to do it
09:09:09 <jophish> about*
09:09:12 <chrisdone> that will normalise any styled file into the same style
09:09:46 <TallerGhostWalt> alright, I think I can ask this question better now.  When I use the 'at' lens it returns: at :: Index m -> IndexedLens' (Index m) m (Maybe (IxValue m))
09:09:51 <jophish> use the comment eating formatter to generate a corrected AST, flatten that AST and the unformatted AST to create a mapping between them and splice in the comments in the new position
09:10:20 <TallerGhostWalt> but the lens I want to compose with it would be inside the maybe
09:10:56 <TallerGhostWalt> I can't compose an at like a regular lens so I am little lost on how to do it
09:11:45 <Luke> chrisdone: got it installed in emacs
09:11:49 <Luke> so far so good =)
09:11:53 <chrisdone> Luke: hurrah!
09:12:04 <chrisdone> got the minor mode enabled?
09:12:15 <chrisdone> M-x structured-haskell-mode
09:12:52 <Luke> yeah
09:12:55 <chrisdone> jophish: yeah, if in your printer you recorded where your nodes start/end then i guess you could place comments in appropriate positions
09:12:56 <Luke> looking at the key bindings now
09:13:10 <chrisdone> Luke: do you get the highlighted nodes when you move around a declaration?
09:13:20 <Luke> doesn't look like it
09:13:49 <Luke> SHM is in my mode line. Any way I can force it to reevaluate?
09:14:01 <chrisdone> shm/reparse
09:14:18 <Luke> ran but nothing highlighted
09:14:24 <chrisdone> what does this say? M-x shm/describe-node
09:14:33 <jophish> chrisdone: better yet would be to write a formatter which returns the position deltas themselves
09:15:02 <khyperia> what's the proper way to write a parsec parser of the form ((f <*> a) <|> (f <*> b)), aka a choice between two parsers starting with the same thing?
09:15:22 <jophish> khyperia: you can factor out the common f, right?
09:15:29 <khyperia> Yeah, I'm not sure how.
09:15:45 <jophish> f <*> (a <|> b) perhaps?
09:15:49 <chrisdone> Luke: it should print a message describing the node at point. if it doesn't there's a problem =)
09:15:52 <khyperia> Oh, neat, didn't think of that
09:15:57 * khyperia facepalms
09:16:21 <Luke> chrisdone: in the message buffer? I see nothing when keying around
09:16:30 <Luke> I use flymake, is that a problem?
09:16:33 <chrisdone> Luke: M-x shm/describe-node should print something in the message buffer
09:16:48 <chrisdone> in the minibuffer too
09:17:03 <chrisdone> what does it say?
09:17:42 <Luke> split-string: Wrong type argument: stringp, nil
09:18:02 <chrisdone> aha! hold on then
09:19:38 <chrisdone> Luke: what does this give? M-! structured-haskell-mode
09:19:50 <chrisdone> Luke: let's check that the binary structured-haskell-mode can actually be called by emacs
09:20:03 <chrisdone> it should return a haskelly pattern match error
09:20:26 <Luke> chrisdone: ah - command not found. I have to restart emacs probably
09:20:34 <chrisdone> hmm
09:20:44 <chrisdone> where did the binary get installed to? maybe it's only installed in a sandbox?
09:20:50 <khyperia> jophish, ran into another problem, it's actually ((f <*> a <*> b) <|> (f <*> c <*> d)), and doing f <*> ((a <*> b) <|> (c <*> d)) doesn't work. I solved it by putting a ((,) <$> (a <*> b)) and making f be uncurried, but that doesn't seem very good.
09:21:00 <chrisdone> Luke: actually, no biggie, this is customizable as a variable as…
09:21:22 <chrisdone> Luke: (setq shm-program-name "/your/path/to/structured-haskell-mode")
09:21:27 <Luke> hmm the bin doesn't seem to be installed on my path
09:21:28 <Luke> one sec
09:21:44 <chrisdone> k
09:21:54 <Luke> ooh crap - sandbox =)
09:21:56 <kryft> khyperia: Why doesn't f <*> ((a <*> b) <|> (c <*> d)) work?
09:21:56 <Luke> that's me
09:22:01 <chrisdone> hehe
09:22:09 <khyperia> kryft, it expects "a" and "c" to be functions
09:22:11 <chrisdone> so you can either cp' the binary or specify the program-name
09:22:33 <khyperia> where the original is (f <*> a) <*> b
09:22:45 <khyperia> so factoring out (a <*> b) breaks the parens
09:23:27 <kryft> khyperia: Ah, I've only really used monadic parsec so far
09:23:42 <khyperia> well, this is a sort of general applicative question
09:24:06 <TallerGhostWalt> Man, lenses are just so crazy
09:24:33 <khyperia> If you'd like me to spit out a BNF of what I'm trying to parse, sure.
09:24:37 <kryft> khyperia: Well I'm not really that familiar with applicative style in general, which is one of the reasons why I've used monadic parsec so far. :) (I'm not really that familiar with anything, being a newbie)
09:25:06 <Luke> chrisdone: still getting that same error even with an explicitly set path to the binary
09:25:24 <khyperia> ifStatement := if /expression/ then /statements/ else /statements/ end | if /expression/ /statement/
09:25:32 <khyperia> the "if /expression/" is common to both
09:26:14 <chrisdone> Luke: try shm/reparse and maybe typing a few characters to force it to refresh the parse
09:26:32 <chrisdone> Luke: possibly it's just not robust to handle a missing exe so it built a bad tree first time round
09:26:43 <khyperia> well, the else clause on the first one is optional, but I already figured that out.
09:26:44 <Luke> hmm still no luck
09:27:00 <khyperia> kryft, I started learning haskell about 4 months ago, so :P
09:27:05 <Luke> chrisdone: any way I can confirm it's accessing the binary correctly?
09:27:22 <chrisdone> Luke: there is, sec
09:27:54 <khyperia> @pl (\a (b, c) -> f a b c)
09:27:55 <lambdabot> (`ap` snd) . (. fst) . f
09:27:57 <khyperia> oh boy.
09:29:03 <chrisdone> Luke: M-: (let ((points (shm-decl-points))) (shm-get-ast "decl" (car points) (cdr points)))
09:29:24 <chrisdone> Luke: that should print a raw list of AST positions. what do you get?
09:30:16 <Luke> chrisdone: entered the elisp debugger backtrace
09:30:51 <chrisdone> Luke: interesting… with a READ error?
09:31:38 <kryft> khyperia: I took a course early last year (iirc, my sense of time isn't the best) and read most of LYAH and about half of RWH, but didn't really write a program until three months ago
09:31:48 <Luke> chrisdone: http://lpaste.net/6729621481136848896
09:31:50 <chrisdone> Luke: you can also try even more low level: (let ((points (shm-decl-points))) (call-process-region (car points) (cdr points) shm-program-name nil (current-buffer) nil "parse" "decl"))
09:32:43 <chrisdone> Luke: lol your program path is set to: "/Users/lhoersten/Code/haskell/structured-haskell-mode/.cabal-sandbox/bin\nInstalled structured-haskell-mode-0.0.0"
09:33:00 <chrisdone> Luke: set it to: /Users/lhoersten/Code/haskell/structured-haskell-mode/.cabal-sandbox/bin/structured-haskell-mode
09:33:01 <Luke> chrisdone: haha oh geez what happened tehre
09:33:08 <Luke> i figured it was the binary not being loaded
09:33:09 <kryft> khyperia: I suspect haskell is like the game of go in that one will continue to feel like a newbie for at least a few years. :)
09:33:17 <chrisdone> Luke: xD
09:33:19 <khyperia> heh, yeah
09:33:23 <Luke> maybe the mode should test for the binary on startup and print out a "your an idiot" message
09:33:27 <Luke> youre*
09:33:30 <kryft> If the feeling ever passes
09:33:40 <Iceland_jack> kryft: Not really, it depends on how hard you apply yourself and where you focus your efforts
09:33:46 <chrisdone> Luke: indeed, i'll add that as part of the transition to public release
09:36:05 <Luke> chrisdone: working!
09:36:08 <chrisdone> yaaay!
09:36:17 <chrisdone> Luke: so moving around and stuff highlights the node?
09:36:20 <Luke> sorry about the complications
09:36:23 <Luke> yes
09:36:25 <chrisdone> sweet
09:37:04 <Luke> chrisdone: only once per line though
09:37:18 <Luke> as I jump tokens on the same line it stays highlighted on the first
09:37:56 <chrisdone> how are you jumping tokens?
09:38:35 <chrisdone> do you have g+? let's hangout =p
09:39:09 <Luke> I'm not in a decent state =)
09:39:13 <Luke> let me mess around with it for a bit
09:39:17 <chrisdone> hehe
09:39:27 <Luke> i'm going to read through the code to get an idea of what it can do
09:39:30 <chrisdone> it should only highlight one thing at a time and always be the node you're at
09:39:37 <chrisdone> so the commands of interest are:
09:39:37 <chrisdone> ) - takes you to the end of the node and marks that as the current node.  you can keep hitting it to go outwards,  like paredit mode
09:39:37 <chrisdone> M-a - takes you to the parent node and does the same as the previous
09:39:47 <kryft> Iceland_jack: Well, I just know that there still seems to be loads of stuff that I don't grok at all despite having grokked quite a few things; of course the impression may be deceptive
09:39:59 <chrisdone> C-k kills until the end of the line, but to the extent that it doesn't break any nodes. so it won't chop off closing parens or w/e
09:40:00 <Luke> chrisdone: oh that's neat!
09:40:09 <Iceland_jack> kryft: There is always loads of stuff :)
09:40:38 <Luke> chrisdone: oh it's parsing every node per line now. not sure what the problem was before
09:40:44 <chrisdone> Luke: and M-k or C-M-k will kill the current node but normalize the indentation somewhat
09:40:44 <chrisdone> Luke: then when you C-y elsewhere, it re-indents the whole expression so that it fits properly
09:40:59 <kqr> is there a standard library function to count the occurrences of an element in a Eq a => [a]? or do i make one (by filtering and checking the length or something)
09:41:01 <chrisdone> fair enough =)
09:41:03 <Luke> chrisdone: if I navigate by arrow keys it doesn't parse multiple nodes per line but with C-f and C-b it does
09:41:08 <chrisdone> ahhhhhhh
09:41:08 <Luke> hat's the issue
09:41:21 <chrisdone> gotcha. yeah i only use C-f/C-b for my setup so i forgot about arrows
09:41:28 <Luke> yeah
09:41:29 <Luke> np
09:41:38 <Luke> i do too except when I'm experimenting with new nodes apparently =)
09:41:49 <chrisdone> hehe
09:42:33 <Luke> chrisdone: I use er/expand-region mode to do stuff like this right now but it doesn't understand haskell, only tokens
09:42:41 <Luke> and it's not automatic like this! huge upgrade for me!
09:43:06 <Luke> wow this works amazingly well!
09:43:07 <chrisdone> C-j for indentation works, but it's only the basics presently. if you're familiar with writing lisp, then depending on how wide your current node selection is, it'll indent according to that level of nesting. sometimes it knows the type of expression and indents cleverly. i've a bunch of more types to add
09:43:11 <chrisdone> Luke: awesome!!!
09:43:18 <stepcut> If I plan to install the Haskell Platform on OS X today -- what version of Xcode should I use ?
09:43:34 <Luke> stepcut: any
09:43:41 <Luke> stepcut: I can help you get it set up once I get to your place
09:44:00 <Luke> stepcut: I start with a fresh install of OS X just the other day and used home brew to install platform and everything worked out of the box
09:44:04 <Luke> mavericks
09:44:13 <stepcut> Luke: excellent! I don't actually need it setup, but I figured someone will
09:44:30 <Luke> yeah
09:44:33 <Luke> I can help with that
09:44:40 <stepcut> well.. I should probably update my os x install anyway
09:45:09 <stepcut> I still have GHC 7.4.1 on my OS X box
09:45:32 <Luke> chrisdone: you need to release this ASAP. its totally usable as it stands
09:46:10 <mightybyte> Anyone know why the ghc package on ubuntu doesn't work?
09:46:20 <Luke> stepcut: I'm only going to use home-brew now on OS X
09:46:25 <Luke> its so much better
09:47:14 <chrisdone> Luke: haha, thanks for the vote of confidence. still some rough edges and caveats to iron out, but yeah i'm excited to release it
09:47:28 <chrisdone> Luke: did you also try the automatic re-indentation? e.g.
09:48:01 <chrisdone> foo = do bar
09:48:01 <chrisdone>          mu
09:48:01 <chrisdone> type something after foo
09:48:15 <chrisdone> it should bring 'mu' along for the ride. backspace too
09:48:35 <Luke> mightybyte: what version? I have it working OK on 13.10 w/ 7.6. whatever platform has
09:48:35 <chrisdone> it's limited -- so C-d isn't bound yet, but i plan to add those too
09:48:50 <mightybyte> 13.10
09:49:19 <mightybyte> Luke: I just installed it yesterday.  Then apt-get install ghc.  But when I try to build things I get error messages about missing libraries.
09:49:23 <Luke> chrisdone: wow that's awesome! I didn't even notice it was doing that at first
09:49:28 <chrisdone> :D
09:49:48 <Luke> mightybyte: weird - no idea. 13.10?
09:49:57 <mightybyte> Luke: And I can't install the binary distribution either because of errors about libgmp
09:50:03 <mightybyte> Luke: Yes, 13.10
09:50:22 <chrisdone> (it's a bit rough, sometimes it'll trigger when maybe you didn't want it to, but i use haskell-move-nested to correct that)
09:51:00 <chrisdone> (it'll be smarter once i get round to it, and before releasing it)
09:51:18 <Luke> release early and often!
09:51:33 <Luke> i'd say if it's in this usable state already, go for it. call everything from now on a "feature"
09:52:14 <Luke> chrisdone: except for the light background-theme people. its going to look weird =D
09:52:40 <chrisdone> yeah. tho i learned emacs lets you specify two colors, one for dark themes and one for light themes. so i can do that
09:53:11 <Luke> chrisdone: just make it work with solarized and I'll be happy =)
09:54:52 * chrisdone has to finish the items in TODO.org
09:55:08 <mightybyte> Luke: How did you install Haskell?
09:55:34 <Luke> same way: apt-get install ghc, then installed platform over it
09:55:50 <mightybyte> Oh, I didn't install the platform.
09:56:09 <mightybyte> I hate having all those platform packages cluttering things up.
09:56:10 <Luke> i thought you said ghc didn't even install though?
09:56:17 <mightybyte> ghc installed
09:56:25 <mightybyte> And cabal-install installed
09:56:27 <Luke> ooh - yeah I use platform to kinda boostrap me
09:56:31 <Luke> yeah
09:56:38 <mightybyte> But then when I try to build things, they fail.
09:57:48 <Luke> what kinda fails?
09:58:14 <mightybyte> Could not find module `Data.Traversable'
09:58:23 <Luke> and make sure your cabal binary folder is in your path
09:58:33 <Luke> building form the command line or emacs shell?
09:58:37 <mightybyte> Yeah, I know
09:58:47 <mightybyte> command line
09:59:31 <Luke> yeah I've never built stuff without platform
09:59:44 <mightybyte> Ok, let me try that.
09:59:56 <Luke> seems like if you have cabal-install and ghc, you should have everything you need to start going though right?
10:00:04 <mightybyte> Yep
10:00:21 <mightybyte> That's usually the only things I need to be off and running.
10:00:39 <mightybyte> But apparently the ubuntu install is borked for that model.
10:00:45 <Luke> haha
10:00:56 <mightybyte> I've also tried installing ghc manually, but that doesn't build either.
10:01:08 <Luke> I have a VM i need to install on - I'll try your method first to see if I can reproduce
10:01:31 <mightybyte> Ok, thanks
10:03:45 <mightybyte> The platform sucks because it puts a whole bunch of stuff in --global
10:04:07 <Luke> yeah
10:04:11 <Luke> agreed
10:04:22 <Luke> btw do you know if you can use cabal-meta with cabal sandboxes?
10:04:28 <Luke> I really have been liking sandboxes
10:04:32 <Luke> super streamline
10:04:34 <mightybyte> Hmm, not sure.
10:04:40 <mightybyte> I use cabal-meta when I don't want to use sandboxes.
10:04:57 <Luke> you need them both... cabal-meta still builds into global right?
10:05:22 <mightybyte> It builds into --user
10:05:34 <Luke> oh sandbox builds into the project folder
10:05:43 <Luke> to me --user is global =)
10:06:18 <Luke> i bet it will use sandbox because sandbox replaces all your normal commands with cabal commands for installing into the project dir only
10:06:31 <mightybyte> Yeah, I think so
10:07:46 <Luke> awesome
10:08:17 <Luke> mightybyte: as long as your paths are set up ok, then all your --user packages override your system platform packages anyway
10:08:46 <mightybyte> But what happens when different versions coexist?
10:09:15 <mightybyte> Crap, same thing happens even after I install the platform.
10:09:17 <mightybyte> Could not find module `Prelude'
10:12:45 <Luke> mightybyte: cabal will use the latest
10:12:56 <Luke> if you want an older package than platform you're kinda out of luck
10:13:11 <mightybyte> Well, that's not even the problem.
10:13:32 <mightybyte> It's when one package gets an old version, then another one pulls in a new version and they end up conflicting.
10:22:47 <aford> Can anyone help me with a build problem I'm having? http://lpaste.net/95456
10:23:13 <aford> For some reason I can't link utf8-string, despite bytestring, array etc. being in the same (parent) directory
10:24:15 <aford> And there don't seem to be any .so's corresponding to haskell libraries on this machine, but I get the same error compiling on ones that do
10:25:19 <loadedanvils> how to debug my haskell script?
10:26:02 <int-e> aford: hmm, does ghc-pkg list complain about any packages?
10:26:18 <aford> Nope, a check comes up clean
10:26:32 <Adebar> I've got a quick question regarding QuickCheck
10:26:53 <aford> http://lpaste.net/95461 output of ghc-pkg list -v
10:26:54 <Adebar> I wrote a property to test a function that takes a particular datastructure and an integer
10:27:03 <Adebar> however, the integer is not supposed to be negative
10:27:24 <Adebar> unfortnately, quickCheck generates random numbers, positive and negative
10:27:32 <Adebar> and I would like to exclude all negative numbers
10:27:35 <aford> I've tried this on a couple of arch installs and an ubuntu one, and it's always the same thing
10:27:47 <Adebar> so that I can properly test the property with QuickCheck
10:28:37 <monochrom> Adebar: "==>" may help
10:29:00 <int-e> aford: oh, you're building ghc; ghc compiles some libraries locally; have a look around in  libraries/{bytestring,utf8-string,etc.}/dist-install/build, perhaps
10:29:51 <int-e> aford: and perhaps ping #ghc, somebody might recognize the failure (I don't).
10:30:17 <Adebar> monochrom, thanks for the hint! I think I found a good source about it.
10:31:05 <aford> Thanks, I'll have a look. iirc utf8-string is a new dependency for some changes I made. I added it to the build tree but I might have missed something I need to do.
10:33:51 <ReinH> hai
10:38:54 <int-e> aford: oh. have a look at ghc.mk, you probably have to add it to PACKAGES_STAGE1
10:40:18 * hackagebot uuid-le 0.2013.313.0 - Codec for little-endian Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-le-0.2013.313.0 (StijnVanDrongelen)
10:40:18 <jrmithdobbs> dsls are fun
10:40:21 <jrmithdobbs> B> newCond "myval" $ ISnot . ISins . ISreg . ISext . PlainKey $ "mykey"
10:40:21 <jrmithdobbs> SearchCond (ISnot {prevCond = ISins {prevCond = ISreg {prevCond = ISext {prevCond = PlainKey {plainKey = "mykey"}}}}}) (FinalKey {lastCond = PlainKey {plainKey = "myval"}})
10:42:34 <aford> int-e: It's already there. It's possible I've messed up the order if it depends on that, although it doesn't look like it.
10:49:26 <pamojarpan> Text
10:49:36 <pamojarpan> uch, sorry
10:49:44 <Adebar> again regarding QuickCheck: I now rewrote the property using "==>", and I reject all cases where the defined predicate is not True
10:50:00 <Adebar> however, now I get output like *** Gave up! Passed only 7 tests.
10:50:12 <Adebar> ...because QuickCheck still generates those very large numbers
10:50:18 <Adebar> is there any way to work around taht?
10:50:29 <Adebar> Or maybe a way to increase the timeout limit for QuickCheck
10:50:34 <shiona_> cmdargs 0.10.5 installation fails with a million errors that contain "Perhaps you are using a stage-1 compiler?"
10:50:41 <shiona_> any ideas+
10:53:02 <rasfar> so i don't know, it's been about 3 hours i'm struggling to re-build my wee test project with profiling
10:53:25 <rasfar> did a sandbox init, and installed all the deps, and the .o_p's were all built
10:53:43 <rasfar> but if I put -prof in my .cabal file ghc-options, it tells me not to
10:54:02 <rasfar> and if I don't put it, at runtime it rejects the -p RTS option
10:54:23 <rasfar> I also have done cabal configure --enable-executable-profiling --enable-library-profiling
10:54:50 <rasfar> i've scoured all the IRC logs and other hits I found, but I haven't found the answer
10:55:04 <rasfar> do i need to use cabal-dev for this?
10:55:48 <rasfar> the project is, incidentally, a small executable
10:57:14 <monochrom> rasfar: is it because of http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#install ?
10:57:23 <rasfar> tried ghc-prof-options: -prof -auto-all together with ghc-options: -prof -auto-all as I've seen recommended, but the problem is always that it rejects the -prof option at all
10:58:12 <meiji11> I want to examine each element in a list, and return to the beginning of the list if and when an element meets some condition, to start the examination again, under a modified condition.. is there something in the Prelude that can do that nicely?
10:58:31 <rasfar> thanks monochrom, I'm looking at that page but still not sure how it related; will read it again more carefully
10:59:56 <klugez> rasfar: Which cabal version are you using? Is it after this https://github.com/haskell/cabal/issues/1199 was fixed?
11:00:30 <rasfar> yeah, I've got 1.18.0.2 (I did note that link before)
11:00:44 <rasfar> *notice
11:02:09 <rasfar> i think, after another once-over, and some reading of monochrom's link, my best bet is to start fresh (compiling all the deps including HSE and Repa takes some time, like an hour).
11:02:44 <rasfar> but this was a fresh start in a sense, so I don't know, I guess I'll pare down the project as well
11:03:00 <rasfar> it's just possible there's something wrong with my .cabal file, I'll paste it
11:05:51 * rasfar pasted http://lpaste.net/95462
11:06:23 <rck> exit
11:07:18 <rasfar> i notice there's a lot of language extensions listed -- they may be due to some of the heavier deps? or they may be because I have them in a #if 0 / #endif block in my sources, and cabal configure didn't omit them.
11:07:30 <rasfar> (not sure that that should matter in any case)
11:11:59 <kqr> how can I, with lenses, do something like [[K a b]] -> [[a]]?
11:12:03 <rasfar> anyway klugez and monochrom thanks for the suggestion
11:12:21 <kqr> when i have a lens for K
11:15:23 <monochrom> why is ghc-prof-options not simply -auto-all?
11:15:23 * hackagebot uuid-le 0.2013.313.1 - Universally Unique Identifiers with little-endian-ish encoding tools  http://hackage.haskell.org/package/uuid-le-0.2013.313.1 (StijnVanDrongelen)
11:16:27 <rasfar> i will try that
11:16:51 <rasfar> do i need to list all the modules (Parable/Types etc.) in the other-modules field?
11:16:55 <monochrom> I can't reproduce the problem. well, I haven't tried sandboxing, I don't know how to sandbox.
11:17:14 <rasfar> it's really easy to do, except maybe if you need profiling...
11:17:22 <monochrom> I don't have enough information about your source code organization to answer that
11:18:45 <rasfar> well i suppose the field is there for a reason -- but as it builds using "cabal build" without the field, it seems the use is for something more than basic within-project import deps
11:19:52 <rasfar> maybe the sandbox executable is someplace else and I'm running the pre-sandbox one, oops
11:21:41 <rasfar> excuse the delay, i'm being asked to add this and that compiler option that I had in my shell build script previously
11:22:35 <rasfar> and SUCCESS!! thanks a lot for giving me some support, these things are frustrating for everyone, esp. when the same sort of problem comes up almost daily on #haskell
11:22:59 <rasfar> what a relief; break time
11:23:26 <monochrom> ok, so it's just a PATH problem?
11:23:46 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
11:24:42 <monochrom> well, the frustration for me comes from not being able to reproduce 99% of the problems reported daily on #haskell
11:24:58 <rasfar> yeah, i have to admit the crux was a path problem -- just slipped my mind. i build usually to a ramdisk as it's a wee machine and Haskell can tax the HD recompiling.
11:24:58 <monochrom> it is like no one in the world cares about controlled experiments
11:25:15 <monochrom> or the scientific method
11:25:27 <rasfar> and then the sandbox builds under dist/ which I'm not at all used to
11:25:31 <chrisdone> monochrom: we're working on that at fp complete =p
11:25:50 <monochrom> perhaps I should join the evil FP Complete
11:26:04 <chrisdone> evil? haha
11:26:19 <rasfar> it's difficult to offer a controlled experiement when you've tried about 200 things before asking, but it would be ideally that all information was provided yeah
11:26:23 <monochrom> well, FPC caring is no use if no one else cares
11:27:49 <Rembane> Minimum-complete-example would be a good start.
11:27:58 <Rembane> prepend "A "
11:28:08 <rasfar> (i'm a qualified empirical scientist, so i do understand your concerns; anyways, that break...)
11:28:40 <monochrom> rasfar, a controlled experiment for this one is trivial. create a clean directory. (that's right, walk away from parable completely.) cabal sandbox init. cabal init. edit. cabal configure --enable-executable-profiling. cabal build -v. test.
11:32:47 <rasfar> fair enough, you're right :)
12:07:20 <gnguyen> Hey guys, I'm new to Haskell and am having some trouble implementing a simple standard IO program. I've read up on some of the IO functions but can't piece them together to do what I want. Can anyone help?
12:08:18 <johnw> gnguyen: can you paste your attempts so far?
12:10:02 <gnguyen> sure, one sec
12:10:23 <gnguyen> do i paste it in the chat? or use http://lpaste.net/new/haskell?
12:10:28 <monochrom> or read my example http://lpaste.net/52480
12:10:50 <johnw> yes, that will work
12:10:53 <geekosaur> don;t paste stuff directly into channel, no
12:10:55 <johnw> (lpaste.net)
12:11:49 <gnguyen> one sec while i read over this example and make sure i didn't do anything stupid lol
12:14:19 <lpaste> gnguyen pasted “read double (fail)” at http://lpaste.net/95463
12:15:42 <monochrom> why is it not "getDouble :: IO (Maybe Double)"?
12:16:38 <monochrom> and "return (readDouble input)"?
12:17:41 <gnguyen> ahh, for some reason i thought haskell returned the last statement by default. Is that not correct?
12:17:58 <geekosaur> return is not a command
12:18:00 <monochrom> I don't know what that means
12:18:02 <khyperia> haskell return != normal programming language return
12:18:22 <FreeFull> return wraps a value
12:18:47 <rasfar> put for example, if in your main :: IO (), the last action is putStrLn "", that satisfies the type
12:18:47 <khyperia> in your case, return :: Maybe Double -> IO (Maybe Double)
12:18:55 <monochrom> but to satisfy the type "IO String" for example, it's either "getLine" or "return "hello""
12:19:44 <monochrom> and it is neither "return getLine" nor ""hello""
12:19:56 <rasfar> no need for return ()
12:20:17 <Tekmo> I have a terminology question.  What is the term for when it is safe to inline a function with is definition (or, vice versa, to refactor a code block into a separate function)?  I want to say "referential transparency", but the definition I find on Wikipedia talks more about the substitution of a function with its value rather than its code.  Is referential transparency still the appropriate term for this or is there another relate
12:21:12 <monochrom> Tekmo, consider my new http://www.vex.net/~trebla/haskell/prerequisite.xhtml#leibniz
12:22:27 <Tekmo> Are you the official source of that term? Can I cite you on that? :)
12:23:06 <rasfar> so, substitutability /= referential transparency
12:23:09 <monochrom> the official term is Leibniz's law. I guess I am the first one to say Leibniz's substitutability principle
12:23:15 <Tekmo> Also, I didn't realize you were the one who hosted that site.  I loved your detailed guides on how to solve cabal problems! :)
12:23:29 <monochrom> thank you for choosing monochrom!
12:23:45 <chrisdone> another satisfied customer
12:23:48 <Tekmo> :)
12:24:01 <rasfar> yeah, i have two of those pages open right now :)
12:24:21 <Tekmo> But is that a well understood concept in the context of computer science?
12:24:34 <Tekmo> Or would I have to explain what I meant a bit more?
12:25:25 <Tekmo> Let me motivate why am I interested in this
12:25:29 <Tekmo> I'm discussing Python generators
12:25:55 <Tekmo> where something like "yield x; yield x" cannot be replaced with the function: "def duplicate(x): yield x; yield x"
12:26:05 <Tekmo> ... because `yield` only returns to the immediate caller
12:26:17 <Tekmo> So inlining a generator or refactoring out a generator is not a safe transformation
12:26:24 <Tekmo> That's the concept I'm aiming for
12:26:25 <monochrom> I don't know about compputer scientists. (well, they have math skill, the idea is trivial to them, they probably just don't know there is a name.) but I am definitely sure that programmers either don't know the idea or know but deliberately trash it.
12:27:09 <rasfar> a word in that section about how it differs from "referential transparency" would probably be useful
12:27:18 <Tekmo> Yeah, definitely
12:27:33 <Tekmo> The distinction was not even clear to me until I checked more carefully how referential transparency was defind
12:27:39 <moops> rasfar: so, substitutability /= referential transparency << huh?
12:27:56 <Tekmo> In Haskell they mean the same thing
12:28:00 <rasfar> moops: i was echoing what i thought was being said; but it still not clear
12:28:04 <Tekmo> In other languages, I think they mean subtly differnet things
12:28:11 <johnw> Tekmo: a referentially transparent statement does not care if its terms are replaced with equivalent definitions
12:28:15 <monochrom> rasfar, I have decided that I don't know what is referential transparency.
12:28:20 <moops> based on the description here they seem identical
12:28:24 <rasfar> yeah i was about to ask if one doesn't imply the other / monochrom haha
12:28:56 <rasfar> if two expressions evaluate to the same value, they are interchangeable by referential transparency -- no?
12:28:59 <Tekmo> What confused me was the Wikipedia definition: "An expression is said to be referentially transparent if it can be replaced with its value without changing the behavior of a program"
12:29:09 <Luke> Tekmo: interested in helping me where we left off last night?
12:29:14 <johnw> I think that definition may not be entirely accurate
12:29:19 <Tekmo> In the context of other languages, people distinguish between values and the code, whereas in Haskell they are one and the same
12:29:24 <dwcook> Wikipedia is saying, in other words, that evaluation has no notable side effects.
12:29:32 <johnw> I don't think the term itself is said to be referentially transparent, but the context in which the substitution of the term occurs
12:30:00 <kazagistar> Tekmo: you used yield as an example, but wouldn't "return" be just as good an example?
12:30:01 <Tekmo> Luke: I'm a bit busy at the moment doing some writing (which is motivating this question).  I'll be on tonight, though
12:30:11 <Tekmo> kazagistar: Yes, it would
12:30:16 <johnw> for example, a pure Haskell function is said to be referentially transparent since, due to purity, you can replace any expression within it with its definition and expect the same result
12:30:17 <Luke> Tekmo: ok thanks
12:30:23 <Tekmo> kazagistar: I'm just using this for the `pipes` appendix of my thesis, which is why the topic of `yield` comes up
12:31:30 <johnw> Tekmo: the best article I've read on the subject is the first answer here: http://stackoverflow.com/questions/210835/what-is-referential-transparency
12:31:36 <sx_> is it possible to lift a function which is only applied when both monadic values exist and otherwise gives back the existing argument? (or is my thought process wrong and this is impossible with bind?)
12:31:40 <kazagistar> Tekmo: I just mentioned that because python has slightly ugly implicit coroutines (generators), but languages like Lua have proper coroutines where that is not a problem
12:31:55 <johnw> sx_: can you give an example?
12:32:21 <ihm1> Does anyone have a good reference for generic derivation of elimination principles of polynomial functors?
12:32:33 <Tekmo> kazagistar: In this case I just needed an explicitly bad example to motivate the problem that `pipes` solves, making coroutines referentially transparent and also making their composition pure
12:32:39 <sx_> johnw: foo (+) (Just 1) Nothing = 1, foo (+) (Just 1) (Just 2) = 3
12:33:02 <sx_> johnw wrapped in a Just, sry
12:33:10 <sclv> everything in haskell is referentially transparent
12:33:12 <sclv> by definition
12:33:34 <Tekmo> johnw: Thanks.  That answer is much closer to what I understood referentially transparent to mean before I read wikipedia
12:33:57 <sclv> rt in that definition is "the whole is defined purely in terms of operations on its parts"
12:34:09 <Tekmo> johnw: I'll just use the term "referential transparency" then, and if people are confused then I will clarify
12:34:17 <chrisdone> Luke: do i see you on the live stream right now?
12:34:18 <kazagistar> Tekmo: python's yield problem can now be manually solved with "yield from" in the parent, but that is pretty ugly :/
12:34:32 <Luke> haha yeah
12:34:41 <Tekmo> kazagistar: Well, not quite.  I tried that.  The only solution that works is to loop over the generator and re-yield all the elements
12:34:44 <Luke> what's the URL?
12:35:00 <Tekmo> kazagistar: I want to be able to substitute in all the values of the generator, not just a single value
12:35:07 <Tekmo> kazagistar: That's why I used the `duplicate` example
12:35:07 <chrisdone> ahh, i love programmer meetups. so many bad posture examples
12:35:08 <johnw> sx_: you want Nothing to be a zero; I'm not sure this is possible without using a restricted monad (where you can impose a Monoid constraint)
12:35:12 <chrisdone> Luke: http://www.ustream.tv/channel/happstack
12:35:19 <sx_> john: i guess fold is what i need
12:35:28 <sx_> johnw: i guess fold is what i need
12:35:30 <kqr> can i create a "class Summable a where summation :: a -> Int" and then define instances selectively for something like "instance Summable [Int] where summation = sum"? GHC seems to want -XFlexibleInstances but for some reason I recall not needing that earlier for pretty much the same thing
12:35:41 <johnw> chrisdone: I'm in that picture!
12:35:45 <kqr> (this is not solving any actual problem, I'm just toying around with the type system)
12:35:49 <Tekmo> Alright, thanks everybody for your help, especially `johnw`! :)
12:35:53 <chrisdone> johnwave to the camera
12:35:55 <johnw> chrisdone: I'm just right from the center
12:36:15 <chrisdone> lol
12:36:18 <Ralith> kqr: try instance Num a => Summable [a]
12:36:25 <chrisdone> johnw: you found it =p
12:36:28 <chrisdone> above to the left
12:36:31 <chrisdone> hahaha
12:36:36 <chrisdone> who's the dude behind you?
12:36:38 <WraithM> I'm here too :)
12:36:41 <WraithM> Me
12:36:41 <johnw> that's WraithM
12:36:48 <chrisdone> hey WraithM :D
12:36:57 <WraithM> Hey :)
12:37:00 <chrisdone> what is that place? looks cosey
12:37:00 <kqr> Ralith, i want to define it specifically for Ints, and not any Num a
12:37:16 <Ralith> kqr: then that needs FlexibleInstances, yes
12:37:23 <Luke> stepcut's place
12:37:30 <Luke> chrisdone: it's really delayed
12:37:35 <johnw> sx_: yeah, I don't think you can define such a thing generally, using only Applicative (which is what you'd need to lift a 2 argument function
12:37:37 <chrisdone> stepcut: nice place
12:37:38 <kqr> Ralith, oh okay, maybe i get it. i'll play a little with it and see if it makes sense soon
12:37:42 <kqr> Ralith, thanks
12:38:19 <rasfar> looks like the audio situation at stepcut's is covered, nice
12:38:56 <rasfar> here's a thought related to some discussion yesterday, about numeric promotion or lack thereof
12:39:33 <rasfar> suppose there was a language extension to allow to constrain any type allowed to occur in a function?
12:39:56 <rasfar> for instance f :: Double | (Num a,Ord b) => a -> [a] -> etc. etc.
12:40:21 <rasfar> would say that in fact, nothing but Double is allowed to occur in that function
12:40:29 <rasfar> (this is a crummy example, but you get the idea)
12:41:09 <rasfar> then promotion could be inferred for that function, without constaining the freedom of numeric types in the large
12:43:22 <gnguyen> monochrome: in the example that you sent earlier. What are the "Left" and "Right" things doing?
12:43:26 <rasfar> in this example, you'd prefer to just declare f :: Double -> [Double] -> etc but that might not always be possible or at least easy to reason about
12:45:21 <chrisdone> johnw: pushed some shm updates. Luke tried it out earlier =)
12:45:29 <johnw> oh nice!
12:45:39 <Luke> its nice
12:45:48 <rasfar> better example would be f :: Double,Int | => Int -> [Int] -> Int
12:46:07 <monochrom> gnguyen: they are from the Either type. it's in Prelude. most books and tutorials cover it.
12:46:21 <rasfar> so there are some floating operations involved in the function, although the type Int -> [Int] -> Int doesn't reflect that
12:46:29 <gololog> hi, what is this channel about? thank you :-)
12:46:42 <monochrom> see the topic line
12:47:11 <chrisdone> > reverse "gololog"
12:47:12 <lambdabot>   "gololog"
12:47:15 <chrisdone> this pleases me
12:47:20 <gololog> Still cant get it.
12:47:32 <rasfar> :( no interest i take it
12:47:33 <gololog> there is only a few links
12:47:40 <chrisdone> gololog: it's a programming language
12:48:13 <monochrom> you could have followed at least the first link
12:48:15 <gololog> Anyone can help me to get in #java channel? its only for invitations
12:48:25 <monochrom> no one here can help you
12:48:40 <gololog> monochrom yes I could. Thank you :) It helped :)
12:48:56 <chrisdone> monochrom: i read that in a “no one can help you now, mwuhaha” voice
12:49:04 <monochrom> heh
12:49:14 <monochrom> err, I mean mwuhahaha
12:49:24 <chrisdone> :D
12:50:17 <gololog> I have heard haskell developers are really nice ppl and can help me to get in there O:-)
12:50:36 <monochrom> I haven't.
12:50:50 <gnguyen> monochrom: ahh, It was after the IO section. Thanks for the help. Do you have any suggested readings other than "Learn You a Haskell.." ?
12:51:32 <johnw> gnguyen: http://book.realworldhaskell.org/
12:51:58 <monochrom> http://www.vex.net/~trebla/haskell/learn-sources.xhtml
12:52:03 <gololog> "/disconnect" is really powerfull command
12:53:29 <gololog> if someone help me to get in #java I will send him this funny video https://www.youtube.com/watch?v=1JkaJf2gSlc
12:53:45 <monochrom> you already sent it
12:54:02 <Narvius> I find it really amusing how I can use (thing %~ f) inside larger composition chains, which especially in case of tuples basically sidesteps the entire issue of functor instances. :D
12:54:04 <monochrom> I am now unconvinced that you are not a spammer
12:54:07 <mauke> gololog: there is no #java
12:54:07 --- mode: ChanServ set +o monochrom
12:54:11 --- mode: monochrom set +b *!*@ip57-165.cablenet.cz
12:54:11 --- kick: gololog was kicked by monochrom (gololog)
12:54:18 --- mode: monochrom set -o monochrom
12:54:39 <Taneb> What's a nice data structure to have a mapping from names to images?
12:54:42 <Taneb> Map?
12:54:53 <Narvius> Yeah, probably, why not?
12:54:53 <Cale> yes
12:55:20 <monochrom> try Map. try also HashMap (from unordered-containers, comes with Haskell Platform)
12:58:24 <Luke> chrisdone: https://github.com/haskell/haskell-mode/tree/master/snippets/haskell-mode mission accomplished
13:00:01 <chrisdone> Luke: yay!
13:00:01 <Luke> chrisdone: README included but haven't ported to text yet
13:00:04 <Luke> texi*
13:00:05 <kqr> Narvius, could you expand on what you mean by (thing %~ f)
13:00:12 <kqr> Narvius, or rather
13:00:24 <kqr> Narvius, what you mean by using it inside larger composition chains
13:00:31 <kqr> Narvius, it might be related to a question i had earlier
13:00:40 <Narvius> Well, %~ is a lenses operator for mapping, basically.
13:00:59 <Narvius> So I can do (_1 %~ (+1)) to increase the first element of a tuple by one, for example.
13:01:08 <Narvius> That takes a third argument, by the way.
13:01:10 <Narvius> The tuple itself.
13:01:33 <kqr> Narvius, what i'm trying to do is reach a few levels into nested data structures and remove the innermost layer of nesting
13:01:42 <danom> hi, can I get some help with my question? thanks. http://stackoverflow.com/questions/19875636/data-constructor-promotion-in-ghc-7-6
13:01:53 <rotemy> hi, noob question here
13:02:08 <kqr> Narvius, so for simplicitys sake, say i have a lens "a :: K -> a" I want to turn a [[K]] into an [[a]]
13:02:46 <Taneb> rotemy, ask away?
13:03:11 <rotemy> If I have an f :: IO String and I do "main = putStrLn =<< f", is it supposed to work (i.e. be equivalent to a 'do' with obtaining a value and then passing to putStrLn?)
13:03:19 <rotemy> Taneb: sorry, hit RET too quickly
13:03:30 <chrisdone> Luke: i'mma try it. i want some of the expansions to be cleverly activated with shm
13:03:43 <Luke> yeah some integration there would be awesome
13:03:51 <Narvius> kqr: Well, if f is a *function* :: K -> a, then (mapped.mapped %~ f)
13:04:01 <chrisdone> Luke: e.g. if <space> should just insert an if. and if i type C-j at the end of a case alternative, it should insert a new case alternative snippet below at the right place like _  -> _
13:04:16 <kqr> Narvius, hey that's a good point i didn't think about
13:04:23 <kqr> Narvius, i think that solves my problem very nicely
13:05:33 <Luke> chrisdone: the way I handle that now is checking what column the cursor is on
13:05:44 <kqr> Narvius, is it possible to do if f is a lens instead, or would that violate the lens/traversal laws so i should forget even thinking about it?
13:05:58 <chrisdone> Luke: handle which?
13:06:02 <Taneb> rotemy, yeah, that should work
13:06:33 <kqr> rotemy, that should work fine. doesn't it?
13:06:35 <Luke> chrisdone: not any of the cases you mentioned specifically but in general, i use columns as a way of cheating to find context
13:06:47 <chrisdone> ah, sure
13:06:47 <Luke> chrisdone: if there's a way we can make it smarter because it now depends on haskell-mode, that'd be awesome!
13:06:57 <gnguyen> monochrom: I was reading over some of your website and found the article on "reads". Would you recommend that I change my program so that it uses reads instead of maybeRead?
13:08:05 <chrisdone> Luke: with shm we have info. e.g. try M-: (shm-current-node) somewhere in a declaration. i'd like to get shm into haskell-mode eventually too, so it's just working out of the box
13:08:59 <chrisdone> Luke: in shm we know if we're in a case, a case alt, an app, a string, an if, whatever. so we can do any kind of type-specific behaviour
13:10:14 <Luke> chrisdone: makes sense. if we ship it all together they can all depend on each other and be "smarter"
13:10:50 <chrisdone> nod
13:11:23 <Narvius> kqr: The lens is on the *left* side of that operator. It tells you where to do stuff, basically.
13:11:44 <Narvius> The function provides the "what".
13:12:44 <rotemy> kqr: not really. Trying "main = L.putStrLn =<< sendCommand $ cmd" complains: ouldn't match expected type `L.ByteString -> t0'
13:12:45 <rotemy>                 with actual type `IO ()
13:13:06 <rotemy> while "main = do
13:13:27 <rotemy>      resp <- sendCommand $ cmd
13:13:34 <rotemy>       putStrLn resp"
13:13:36 <rotemy> does work
13:13:41 <Narvius> (sendCommand cmd)
13:13:44 <Narvius> Not sendCommand $ cmd
13:14:09 <Narvius> At least that's what I'd think.
13:14:25 <rotemy> Narvius: that's right! that was the issue
13:14:35 <rotemy> I'm still often perplexed by the precedence rules
13:14:49 <rotemy> thanks!
13:14:53 <Narvius> As a rule of thumb, everything has higher precedence than ($).
13:15:21 <Narvius> No problem. :)
13:16:15 <jophish> yo yo yo
13:16:25 <Narvius> rotemy: In doubt, you can check the precedence of an operator with ":i (op)" in ghci.
13:16:30 <jophish> I can't seem to get ghc-mod to find local modules
13:16:33 <jophish> I'm using vim
13:17:10 <jophish> I have set g:ghcmod_ghc_options to ["-i/Users/jophish/test"] and in test I have AAA.hs and BBB.hs,
13:17:30 <jophish> I can't seem to get any completions for symbols in BBB.hs from AAA.hs
13:17:42 <Narvius> Function application via whitespace has the highest possible precedence, right?
13:18:08 <FreeFull> Yes
13:18:20 <kqr> Narvius, right, so I was thinking if it's possible to combine (^.) (or something) with traversals to both dig deep into a structure and unwrap the deepest layer
13:18:44 <geekosaur> Narvius: record syntax is the only thing I can think of with higher precedence
13:18:52 <jophish> Lint seems to find errors in BBB.hs correctly though
13:18:55 <geekosaur> that is, foo { bar=baz }
13:19:06 <edwardk> you can use holesOf to determine if something has more of the same within it, or if its a 'leaf'
13:19:19 <Narvius> geekosaur: I see, thanks.
13:19:45 <kqr> edwardk, was that directed toward me?
13:19:55 <edwardk> kqr: yes
13:20:07 <Narvius> He's infinitely more qualified to answer those questions than me, actually. :D
13:20:27 <edwardk> also probably infinitely more distracted at the moment =)
13:21:15 <kqr> edwardk, what i'm going for, in a simplified example, is if i have a lens `f' that extracts an `a' from a `K', i'd like to turn `[[K]]' to `[[a]]'
13:21:48 <Narvius> kqr: (mapped.mapped.f %~ functionFromKtoa), no? :D
13:21:55 <kqr> edwardk, but i'm not sure if that would violate some law, so maybe i should stick to what Narvius suggests
13:21:58 <teneen> How or why are CPSd data types more efficient?
13:22:03 <kqr> Narvius, yeah that works beautifully, i just got curious
13:22:20 <edwardk> :t over (mapped.mapped) . view
13:22:21 <lambdabot> (Functor f, Functor f1) => Getting b a b -> f (f1 a) -> f (f1 b)
13:22:59 <edwardk> @google asymptotic improvement of computations over free monads
13:23:00 <lambdabot> http://www.iai.uni-bonn.de/~jv/mpc08.pdf
13:23:00 <lambdabot> Title: Asymptotic Improvement of Computations over Free Monads
13:23:05 <edwardk> teneen: ^- that
13:23:07 <Narvius> I really gotta rewatch your presentation on Lens. ;_;
13:23:15 * kqr snaps his fingers in realiseation
13:23:21 <kqr> that's great! thanks
13:23:46 <kaenga> hello
13:24:02 <kaenga> Maybe Int Bool is it union type or sum type?
13:24:14 <FreeFull> You mean Either Int Bool?
13:24:15 <mzero> Maybe Int Bool isn't a type
13:24:18 <mzero> Maybe takes only one
13:24:31 <kaenga> ah, either, yes
13:24:42 <FreeFull> That'll be a sum type
13:24:48 <FreeFull> (Int,Bool) would be a product type
13:24:57 <mzero> Either Int Bool is a sum type - you can think of it as the set of all Int values and the set of all Bool values
13:25:47 <teneen> edwardk: I skimmed through the paper, can't find what's relative to CPSd data types
13:25:53 <FreeFull> I think lists would be exponentiation, depending on the length of the list
13:25:54 <kaenga> FreeFull: thank, but what is union type then?
13:26:00 <kqr> Narvius, i realised `view l' is just the function K -> a
13:26:08 <kqr> Narvius, so that was kind of obvious-but-not-quite
13:26:13 <edwardk> teneen: it shows how cpsing a free monad can asymptotically improve its performance by the way binds get reassociated
13:26:34 <Narvius> kqr: That's how learning Haskell works. _^_
13:26:48 <edwardk> it precisely captures when its a win, which is when your monad doesn't do much 'renormalization'. monads are about substitution and renormalization. free monads skip the renormalization phase.
13:27:12 <edwardk> so codensity/cps which puts it off indefinitely til the end is always okay there.
13:27:20 <edwardk> other monads can some times suffer for that transformation
13:28:05 <kaenga> can you suggest haskell type which is union type?
13:28:16 <tredontho> :q
13:28:19 <chrisdone> Luke: ahhh, thought there was something odd. it wasn't supposed to only select the node when you used the special keys. it re-parses on a timer, but i must've changed something and forgot to make it re-init the node. pushed a fix. now any movement will update the highlight to the node at point
13:28:27 <FreeFull> A union type is a sum type
13:28:40 <teneen> edwardk: I see. What if the data type is not monadic? is CPS a win?
13:29:06 <kaenga> FreeFull: hm, are you sure?
13:29:08 <mzero> kaenga: union types (as in C) are sum types (as in algebraic data types)
13:29:16 <FreeFull> Yeah
13:29:16 <edwardk> teneen: cps is a win only if you ever 'consume' something once, since if you consume it multiple times you're going to redo all that CPS'd work
13:29:35 <kaenga> ah, okay. thank you guys
13:29:39 <edwardk> this is why we often use it to generate something else, then inspect _that_ repeatedly, for things like free monad
13:30:37 <FreeFull> C doesn't keep track which type of data is stored in an union (although accessing anything but the stored data is undefined)
13:31:57 <mzero> hence, Haskell's sum types are often refered to as "tagged unions" or "discriminated unions"
13:32:18 <teneen> edwardk: I kind of understand what you mean. But let me make it more concrete. Consider "newtype Pair a = Pair (forall r. (a -> a -> r) -> r)" when is this type more efficient (in terms of a and r) than (a,a)?
13:32:45 <hpc> mzero: discriminated unions are racist ;)
13:33:00 <teneen> edward: Do you mean the r should be used once?
13:33:10 <Narvius> hpc: Nah, discriminating unions would. Discriminated unions, on the other hand, are pretty poor fellas.
13:33:10 <edwardk> teneen: in practice, it sometimes wins if the compiler can avoid building up unneeded (,)'s on the heap in exchange for work on the stack
13:33:48 <edwardk> teneen: if you consume a given 'Pair Int' with two different choices of 'r' you're going to do work over and over
13:34:11 <edwardk> in general you should collapse 'Pair Int -> (Int, Int) by passing it (,) then inspect that twice if you need to look at it multiple times
13:34:26 <edwardk> otherwise if you passed it fst  and then passed it snd, it might do all the work to compute both each time
13:34:38 <edwardk> er if you passed it const and (const id)
13:35:07 <teneen> edwardk: Oh I see
13:35:25 <minopret> Additional topic, yeah you've heard it before, is there a better way for me to get over the Haskell hump? Currently reading chapter Functors, Applicative Functors, and Monads in Learn You a Haskell. Have a BS in math and MS in computational sciences. I did read a few pages of Pierce Basic Category Theory and of an intro to Algebraic Topology. Just keep grinding with LYAH?
13:36:39 <frege> why is the interactive mode different from running from a file?
13:36:50 <geekosaur> frege: for debugging etc.
13:36:57 <bz> wow
13:37:02 <geekosaur> you want to be able to test particular functions, not just run the file
13:37:33 <kyle__> <dumb question>does avg always mark various haskell packages as viruses?</>
13:37:46 <geekosaur> it has done so before, I think
13:37:48 <chrisdone> people still use avg, hehe
13:38:03 <chrisdone> retro
13:38:49 <kyle__> bootable disc, supports linux.  I got some odd behavior this morning, and recently have installed a third party binary.  Being paranoid.
13:39:01 <frege> geekosaur: but why is the syntax different?
13:39:09 <geekosaur> um?
13:39:13 <geekosaur> which syntax?
13:39:41 <geekosaur> if you mean :main, it's so that your parameters are available via getArgs where a main function expects them
13:39:50 <frege> geekosaur: I can't do factorial n = product [1..n]
13:39:52 <frege> > factorial n = product [1..n]
13:39:53 <lambdabot>   <hint>:1:13: parse error on input `='
13:39:58 <geekosaur> use let
13:40:00 <frege> I have to use let
13:40:02 <frege> yeah why?
13:40:24 <geekosaur> because it's like the inside of a do block. (why that decision was made, I could not tell you)
13:40:40 <tomejaguar> So you can run IO actions, I guess.
13:40:48 <frege> geekosaur: but in the file I can write "factorial n = product [1..n] " right?
13:40:52 <geekosaur> possibly just to emphasize the "you're in the IO monad", I guess
13:40:55 <yesthisisuser> minopret: maybe i misunderstood your question but having a small project to work on helps if you're trying to get some better intuition for using the language in real-world situations
13:40:56 <geekosaur> yes
13:43:04 <minopret> yesthisisuser I'm sure you're right. Don't have a small "real" project but I do Project Euler in Python. I did a couple of those question with Haskell, could do more as I progress. I'd like to "get" category theory like I "get" set theory and first-order logic. I suppose I forget how long it took to absorb those.
13:46:29 <yesthisisuser> minopret: well, i don't have a very strong background in mathematics. i am reading category theory for computing science, because it is really easy to follow ... at the same time, i find that just writing programs is the best way to learn Haskell, like any other language i suppose
13:48:30 <frege> is there an IDE for haskell?
13:48:44 <hpc> leksah
13:48:45 <frege> I can do emacs but just wondering
13:48:47 <hpc> it's not the greatest
13:48:55 <minopret> yesthisisuser: Hmm yes, I'll see if I have something more compelling than Project Euler in mind as an exercise in Haskell. For a cybersecurity theory project I was reading about HMMs and data provenance so maybe something with that. OK.
13:49:00 <hpc> emacs has a module plugin whizzy doodad thing
13:49:03 <Taneb> frege, there's Leksah, and there's an Eclipse plugin but most people use emacs or vim
13:49:06 <hpc> haskell-mode
13:49:13 <frege> gotcha
13:49:20 <hpc> i use straight vim, no ice
13:49:51 <yesthisisuser> minopret: writing some stuff using happstack was a major break-through for me... it was the first stuff i did in Haskell that actually did something "useful"
13:50:22 <hpc> happstack is cool
13:50:30 <hpc> and i am a big fan of acid-state
13:51:03 <minopret> yesthisisuser: hey, that's cool, I only seem to hear of Yesod. Good to know of another one that someone likes.
13:51:22 <mzero> there is also Snap - also well liked
13:51:36 <hpc> you can use snap without writing code, as i understand it
13:51:37 <yesthisisuser> yep they are all good
13:51:52 <hpc> which i guess makes it the most "real" of the frameworks
13:53:03 <joelteon> yesod is debatably the most complete of the three
13:53:18 <hpc> happstack is deliberately incomplete
13:53:41 <nisstyre> joelteon: I like http-conduit but I dislike the complexity of Yesod
13:53:43 <hpc> it leaves enough open that you can write most of a traditional GUI program and slap a web UI on top
13:53:53 <joelteon> agreed, nisstyre
13:56:00 <minopret> yesthisisuser: so if web apps are my aim, maybe I should take a look at https://www.fpcomplete.com/school
13:57:27 <yesthisisuser> minopret: yeah you can probably find some good tutorials for any of the mentioned web frameworks.. happstack, snap or yesod
13:57:38 <johnw> yesod has a book
13:57:48 <minopret> Cool. Thanks, yesthisisuser those are some good directions for me to think about. That's pretty much what I needed.
13:57:53 <nisstyre> yeah there is an oreilly book snoyman wrote
13:58:07 <leroux> yesthisisuser: Would you recommend Category Theory for Computing Science to others?
13:58:16 <nisstyre> leroux: the bcpierce book?
13:58:27 <leroux> No, It's Barr and Wells.
13:58:39 <yesthisisuser> leroux: i think most people would say that it's very basic
13:58:40 <nisstyre> not this? http://www.amazon.com/exec/obidos/ASIN/0262660717/benjamcpierce
13:58:44 <frege> how is haskell for parallel processing?
13:58:51 <nisstyre> leroux: you might like that one better anyway
13:58:53 <yesthisisuser> it's like the "category theory for dummies" hehehe
13:59:09 <leroux> Yeah, I'm looking around for a good intro to category theory.
13:59:11 <yesthisisuser> i mean the "category theory for computing science" one
13:59:15 <hpc> minopret: i found the happstack tutorial easy to go through, but it encourages some ugly code that you have to be mindful of
13:59:15 <leroux> I don't have a math background either.
13:59:44 <nisstyre> leroux: have you read any books on abstract algebra?
13:59:46 <leroux> So, nisstyre, you think the bcpierce one will be better to take a look at first?
13:59:46 <yesthisisuser> leroux: well then i can recommend it..
14:00:06 <leroux> nisstyre: No.
14:00:10 <nisstyre> leroux: try this first then http://www.amazon.com/Book-Abstract-Algebra-Edition-Mathematics/dp/0486474178
14:00:45 <yesthisisuser> oh. that's interesting.. i'm reading that one also
14:00:49 <leroux> What do you think about Dummit and Foote Abstract Algebra?
14:01:06 <nisstyre> leroux: no idea, I have that Pinter one though and so far it's pretty good
14:01:13 <yesthisisuser> i bought those two books from amazon
14:01:14 <asmyers> leroux: I have been liking this one
14:01:14 <nisstyre> it covers automata and stuff
14:01:14 <asmyers> http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X/ref=sr_1_3?ie=UTF8&qid=1384033689&sr=8-3&keywords=category+theory
14:01:24 <leroux> asmyers: I have that on my list as well.
14:01:29 <asmyers> but I'm only 150 or so pages in
14:01:57 <leroux> What are the prereqs for category theory anyways?
14:02:01 <leroux> Abstract algebra?
14:02:17 <nisstyre> leroux: yeah and set theory maybe?
14:02:18 <Taneb> A bit of sets, maybe groups/monoids?
14:02:32 <nisstyre> set theory is sort of a requirement to understand abstract algebra anyway though I guess
14:02:34 <Taneb> (but you DEFINITELY want to know about sets before going deep)
14:02:52 <leroux> I've read through Suppes's Axiomatic Set Theory.
14:02:55 <leroux> Is that enough?
14:02:58 <donri> leroux: all of math
14:03:01 <yesthisisuser> you should definitely have some familiarity with algebraic structures and that type of stuff
14:03:11 <nisstyre> leroux: is that ZF(C) more or less?
14:03:16 <leroux> nisstyre: Yep.
14:03:18 <donri> leroux: none of math
14:03:22 <leroux> 0.o
14:03:26 <nisstyre> leroux: well that is probably more than enough
14:03:32 <nisstyre> it's definitely more than enough for the Pinter book
14:03:33 <leroux> donri: Somewhere in the middle? =)
14:03:40 <donri> they say category theory is the foundation of math so you either need it to understand math or you need math to understand it!
14:04:35 <nisstyre> leroux: if you know what sets are, what a function is, and have some idea of the various types of functions, surjective, injective, bijective, etc... then it's enough for the book I mentioned
14:04:37 <FreeFull> Homotopy type theory?
14:05:05 <donri> (others say it's not the grand unified theory you're hoping for)
14:05:33 <leroux> nisstyre: Thanks, Pinter sounds good then.
14:05:41 <schell> has anyone had trouble cabal installing happy with ghc-7.8 ?
14:06:00 <yesthisisuser> .. and that there is a category "Hask"
14:06:12 <donri> FSVO "category"
14:07:00 <schell> i have happy 1.19.0 but it was built with ghc 7.6.3 - i don't know if that has any effect on the matter though
14:07:24 <frege> how's concurrency in haskell?
14:07:36 <frege> any of you familiiar with goLang?
14:07:49 <haasn> wonderful
14:07:51 <FreeFull> Haskell is good at concurrency and parallelism
14:07:54 <hpc> concurrency in haskell is a generation beyond any other language
14:07:56 <frege> how can I easily compute in parallel?
14:07:58 <hpc> except for maaaaaaybe erlang
14:08:00 <haasn> frege: http://chimera.labs.oreilly.com/books/1230000000929/index.html
14:08:11 <haasn> parallelism /= concurrency
14:08:36 <frege> right
14:08:39 <hpc> parallelism is the easy part
14:08:47 <donri> hpc: but erlang doesn't have typed actors :(
14:08:49 <FreeFull> http://www.haskell.org/haskellwiki/Parallel
14:08:54 <haasn> concurrency is the easy part
14:08:57 <nisstyre> frege: http://chimera.labs.oreilly.com/books/1230000000929/index.html
14:09:06 <hpc> concurrency is the hard part because it's where the abstraction is
14:09:09 <nisstyre> oh shit ninja'd
14:09:19 <hpc> parallelism is an implementation detail
14:09:33 <hpc> which in haskell happens to also have its own abstraction, because of the miracle of types
14:09:34 <FreeFull> Haskell probably has the best implementation of STM, which is a huge boon for concurrent programs
14:09:47 <hpc> for a long while, haskell had the ONLY implementation of STM
14:09:59 <haasn> http://aosabook.org/en/posa/warp.html <- wonderful read
14:10:20 <haasn> that article is my personal “why should you learn haskell?”
14:10:51 <Lambdacolyte> I like `par` because it's easy
14:10:54 <frege> very interesting
14:11:01 <frege> why aren't people in the industry using haskell?
14:11:09 <haasn> unfamiliarity
14:11:26 <frege> srsly?
14:11:27 <nisstyre> frege: some of them are
14:11:35 <Lambdacolyte> its cheaper to hire unacademic programmers :)
14:11:41 <frege> there is this fear of functional programming in the industry
14:11:41 <hpc> programming language choice in industry is complicated
14:11:51 <nisstyre> frege: I worked at a startup over the summer that is using Haskell for their payments system
14:11:56 <hpc> and very much an economics question
14:12:00 <frege> nisstyre: neat
14:12:23 <glguy> frege: They are, just not necessarily at the same scale as other languages
14:12:26 <frege> but what they use is shit; the current place that I work they are using python mostly, some C and now golang
14:12:34 <Taneb> I wonder if in 30 or so years Java programmers will be as rare as Cobol programmers are now
14:12:53 <frege> but if you tell them why not haskell or erlang; they will wet their pants
14:13:04 <nisstyre> frege: if Python, C and Go works the fine
14:13:09 <nisstyre> none of those are bad languages perse
14:13:20 <frege> true
14:13:42 <Lambdacolyte> Oh boy, I can imagine them sitting down the new guy on the block in front of the source code to their shiny new system
14:14:03 <Lambdacolyte> and instead of invisibly just breaking whatever, he keeps getting type errors and has to poke the guy next to him to fix it
14:14:19 <nisstyre> Lambdacolyte: imagine who?
14:14:43 <Lambdacolyte> if Haskell was used in industry I don't think bad programmers would have jobs tbh
14:14:56 <FreeFull> frege: You do have to think differently to write Haskell code compared to imperative languages
14:15:01 <Taneb> Lambdacolyte, you can be a bad Haskell programmer
14:15:08 <Taneb> Heck, I know what it's like to be one
14:15:14 <zomg> Lambdacolyte: that's like... really, really.. reaaaally optimistic thinking
14:15:14 <zomg> :P
14:15:16 <Taneb> (I'm getting better, though)
14:15:16 <doomlord_> you think good programmers would be so much more productive in haskel
14:15:24 <doomlord_> so there wouldnt be as much programming needed
14:15:26 <nisstyre> bad Haskell programmers do exist
14:15:26 <Lambdacolyte> zoktar, haha totally
14:15:43 <nisstyre> they write everything with do notation and use if-then-else expressions everywhere
14:16:05 <zomg> but why would those be in the language if using them was bad!
14:16:06 <zomg> ;)
14:16:19 <doomlord_> i think we've eliminated enough jobs already, lol
14:16:27 <minopret> Awesome! Why can't chat.stackexchange.com be anything like #haskell on freenode? Oh well :-)
14:16:55 <Taneb> minopret, because Haskell's got a small enough community that a lot of us at least recognise eachother's nicks
14:17:05 <Taneb> So we're all friends
14:17:07 <doomlord_> at least if more people are encouraged to program they have more chance of doing something constructive
14:17:17 <pharaun> oh man i love that warp article
14:17:41 <Lambdacolyte> I'm Ghoul but my subscription to the IRC panel thing I was using before expired and I forgot my NS password
14:17:43 * Lambdacolyte hangs head in shame
14:17:49 <minopret> I see, but you have no idea who I am and that was no problem. I've been here like twice in the past two years and talked mostly to Cale. Who was great.
14:18:02 <frege> how do I import everything from a file to shell?
14:18:57 <Taneb> minopret, because they are always watching.
14:18:59 <Taneb> And remembering.
14:19:36 <hpc> frege: bash file.sh
14:19:40 <hpc> or something like that
14:19:46 <pharaun> is MIO confirmed to be in ghc 7.8.1 ?
14:19:58 <hpc> if you want it run in the current shell, ". file.sh" without the quotes
14:20:01 <frege> hpc: no I'm in the shell, can I do import file ?
14:20:04 <hpc> there's merits to each
14:20:12 <hpc> . file.sh is how bashrc is loaded
14:20:14 <frege> hpc: by shell I mean ghci
14:20:17 <hpc> oh
14:20:18 <hpc> uh
14:20:20 <FreeFull> Everyone knows edwardk
14:20:25 <hpc> i always do "ghci file.hs"
14:20:37 <pharaun> :load file.hs or import x
14:20:37 <minopret> ciao
14:20:39 <frege> wut if you want to import from multiple modules?
14:20:43 <frege> right import x
14:20:59 <frege> > capital :: String -> String
14:21:01 <lambdabot>   Not in scope: `capital'
14:21:01 <yesthisisuser> you can import as many  modules as you want
14:21:07 <yesthisisuser> :m + module
14:21:09 <pharaun> older version of ghci you had to do :something for import, the newer one you can just do direct import
14:21:12 <pharaun> ah the :m
14:21:19 <frege> right, python took that from haskell/lisp I guess
14:21:32 <FreeFull> :m doesn't let you do qualified imports and such
14:21:36 <FreeFull> It lets you unimport though
14:21:43 <Lambdacolyte> sometimes I wonder if edwardk loves inflicting hurt on peoples heads
14:22:00 <frege> > let capital "" = "Empty string, whoops!"
14:22:01 <lambdabot>   not an expression: `let capital "" = "Empty string, whoops!"'
14:22:42 <Rarrikins> ZOMG, you can do import in GHCi.
14:22:52 <Cale> Rarrikins: yes
14:22:58 <frege> I have funcs.hs
14:23:04 <frege> but when I do > import funcs
14:23:07 <frege> I get "<interactive>:1:8: parse error on input `funcs'"
14:23:19 <frege> I tried > import funcs.hs
14:23:19 <Cale> Module names have to start with an uppercase letter
14:23:20 <frege> same
14:23:24 <enthropy> you should be able to splice $( f :: Q [Dec] )  in ghci
14:23:33 <enthropy> frege: :load funcs.hs  will work
14:23:34 <pharaun> Lambdacolyte: when edwardk is in here i know i'm going to have a good time having my head hurting
14:23:34 <frege> oh gotcha
14:23:36 <FreeFull> Rarrikins: You can also do data, type and newtype in ghci
14:23:41 <yesthisisuser> :load funcs.hs is probably what you want
14:23:45 <FreeFull> And instances
14:23:49 <frege> what's thediff?
14:23:56 <Rarrikins> I'd heard about data and so on, but not about import. Typing :m + is awkward.
14:24:21 <Cale> :load will bring everything in the file into scope, even things which are not exported from the module it defines
14:24:35 <Cale> and will replace whatever other file was loaded
14:24:43 <Cale> (if any)
14:24:45 <FreeFull> :load is the same as passing the file as an argument to ghci when starting it
14:24:48 <hpc> :load is the same as giving a filename parameter, i think?
14:24:52 <Cale> yes
14:24:56 <halvrg> I have a function f that takes another funciton g in as a parameter and when I recurse I want to pass that function on. Problem is GHC thinks I want to apply said function (g) to the remaining parameters to f. I haven't encountered this issue before, thoughts?
14:25:03 <hpc> FMTYEWTKA ghci
14:25:08 <frege> gotcha
14:25:25 <FreeFull> halvrg: Paste your code to lpaste.org
14:25:37 <frege> <no location info>: Could not find module `Funcs' It is not a module in the current program, or in any known package.
14:25:42 <FreeFull> Wait, not .org
14:25:45 <frege> Cale: I also tried cap
14:25:49 <FreeFull> @hpaste
14:25:49 <lambdabot> Haskell pastebin: http://lpaste.net/
14:25:52 <hpc> halvrg: you wouldn't by chance happen to be writing it as f(g x y z)?
14:26:38 <halvrg> http://lpaste.net/95467
14:26:42 <halvrg> f is the function here
14:26:55 <halvrg> it doesn't do anything worthwhile, ive modified it somewhat to debug
14:27:04 <halvrg> the | otherwise ... line throws the error
14:27:10 <c_wraith> that's not a recursive call
14:27:17 <Cale> frege: Is the file named Funcs.hs now, and does it start with "module Funcs where"?
14:27:26 <halvrg> oh god
14:27:29 <halvrg> right, thanks
14:27:56 <pome> struggling to write a 'mex' function -- minimally exclusive member of a set
14:27:59 <c_wraith> also, it'll loop infinitely
14:28:05 <c_wraith> if you make it recursive
14:28:06 <pome> such that it returns the smallest natural number which isn't part of the set
14:28:08 <c_wraith> since it changes no arguments
14:28:22 <halvrg> yes, I know, was just testing to see if mem' (and what) was broken
14:28:26 <c_wraith> ah, ok
14:28:48 <pome> i.e., mex {1,4,5} = 0; mex {0,1,2,3} = 4
14:29:07 <frege> Cale: it's Funcs.hs but it doesn't start with module Funcs where
14:29:21 <pome> can anyone help me approach this? the only ways i can think of involve sorting the list beforehand
14:29:23 <c_wraith> pome: can you put the code you have so far on lpaste.org?
14:30:13 <pome> c_wraith: i don't have any code yet - i'm just trying to think how to approach. i suppose i've got 'mex :: [Int] -> [Int]' though
14:30:36 <c_wraith> pome: this is actually a kind of classic problem.  Bird's recent book on pearls of functional algorithm design contains this problem - I think it's actually the first chapter
14:30:47 <pome> sorry, [Int] -> Int, rather
14:31:05 <pome> c_wraith: i did some searching, i couldn't find much - i assume i wasn't using the correct terms
14:31:10 <Rarrikins> pome: Is it the smallest natural number that isn't in the set?
14:31:27 <pome> Rarrikins: that's what i'm trying to do, yeah
14:31:39 <c_wraith> pome: the simplest approach is just to iterate candidate numbers. Check to see if it's in the set. If it isn't, you're done. Otherwise, increment.
14:32:05 <c_wraith> pome: it's easy to show that solution is O(n^2) in the worst case, where n is the size of the input set.
14:32:13 <pome> c_wraith: perfect. i'm not sure why that didn't occur to me.
14:32:16 <c_wraith> pome: you can do better, but start with that, then think about improving it
14:32:25 <pome> i will - thank you.
14:34:10 <frege> do I have to set a path or anything for GHCI?
14:34:38 <c_wraith> pome: by the way, Bird calls that problem the "smallest free number" problem, and it is the first chapter in that book.
14:35:28 <halvrg> haskell arrays are 0 indexed yeah?
14:35:43 <Rarrikins> halvrg: Yes.
14:35:45 <halvrg> ty
14:35:51 <c_wraith> depends.  The Array type allows indexing by an arbitrary range of values
14:35:57 <Taneb> halvrg, Haskell /arrays/ are indexed whatever you set it to
14:36:00 <hpc> haskell arrays are also inclusive, which gets rather frustrating
14:36:06 <Taneb> Haskell lists, however, are 0-indexed
14:36:14 <Rarrikins> Ahh, yes. That's correct.
14:36:16 <geekosaur> yeh, that's a slightly weird question. lists and vectors are 0 based. arrays let you specify the range.
14:36:20 <c_wraith> But the unsafe interface to Arrays is 0-indexed, as is the vector interface
14:36:21 <hpc> a 0-indexed array of length 10 has a range of (0, 9) and that's what you use to construct it
14:36:27 <haasn> haskell lists are not indexed
14:36:31 <haasn> (!!) uses an index
14:36:38 <haasn> but that's a list function
14:36:39 <geekosaur> yes, that also
14:36:45 <haasn> and it could easily use a different arbitrary indexing
14:36:53 <hpc> halvrg: long story short, read a few of the libs ;)
14:37:29 <Taneb> (is the 0-indexing vs 1-indexing question the same question as "Is 0 a natural"? hmm)
14:37:42 <frege> I still can't import Funcs
14:37:44 <haasn> “is 0 an ordinal?”
14:38:10 <frege> this is inside my file: http://lpaste.net/95468 and then I do import Funcs (capital, bmiTell)
14:38:27 <hpc> the government faked zero
14:38:31 <hpc> it's actually 6.5
14:38:38 <FreeFull> frege: What error do you get?
14:38:41 <frege> can someone help me please
14:38:55 <frege> Prelude> import Funcs (capital, bmiTell); <no location info>: Could not find module `Funcs' It is not a module in the current program, or in any known package.
14:39:04 <haasn> hpc: and remember, π=3.2
14:39:18 <FreeFull> frege: Make sure you are in the same directory as the file, and that the file is called something like Funcs.hs
14:39:25 <frege> I am
14:39:36 <frege> FreeFull: it's called Funcs.hs
14:39:39 <geekosaur> hrm. does import work with arbitrary source files? or only with registered modules? I have not tried it
14:39:40 <hpc> haasn: http://hackage.haskell.org/package/acme-php-0.0.3/docs/src/Prelude-PHP.html#line-72
14:39:57 <Taneb> frege, is there a cabal file anywhere arond
14:40:11 <FreeFull> Oh, I guess you can't do it like that
14:40:29 <frege> Taneb: I don't think so
14:40:36 <frege> Taneb: no
14:41:17 <Rarrikins> frege: I think you need to do :l Funcs.hs
14:41:18 <Taneb> frege, are you running GHC from the same directory as Funcs.hs
14:41:25 <haasn> hpc: I was referring to https://en.wikipedia.org/wiki/Indiana_pi_bill :)
14:41:52 <FreeFull> Taneb: I just tested it, import won't work like that it seems
14:41:53 <frege> Taneb: yes
14:42:08 <frege> Rarrikins: I don't want to; I want to import it
14:43:38 <frege> am I doing something wrong?
14:43:53 <hpc> i like mine better
14:43:58 <hpc> indiana should have hired me ;)
14:45:04 <frege> I tried "haskell ) ghc --make Funcs.hs"
14:45:15 <frege> but still I can't import it
14:45:56 <hpc> what's "haskell ) ", here?
14:46:02 <hpc> is that your shell prompt?
14:46:03 <frx> starting ghci in a directory where Funcs.hs is and typing "import Funcs" worked in here
14:46:08 <fryguybob> hpc: There were STM implementations before GHC's.
14:46:37 <`Jake`> > map(exp.exp)[1,2]
14:46:39 <lambdabot>   [15.154262241479262,1618.1779919126539]
14:46:48 <`Jake`> I didn't even know that you could omit all of those spaces
14:46:54 <Cale> I think orElse didn't exist in STM implementations before GHC's though.
14:46:56 <frege> hpc: yeah
14:47:02 <frege> not working for me
14:47:04 <frege> :(
14:47:14 <frx> frege looking up, you did not define module Funcs
14:47:25 <frx> put module Funcs where at the top of your file
14:47:38 <frx> "module Funcs where"
14:47:40 <hpc> there is, in the paste
14:47:53 <hpc> module Funcs (bmiSay, ...
14:48:45 <fryguybob> Cale: Yes, as far as I know.
14:48:54 <Cale> frege: Well, that
14:48:58 <Cale> that's a bit odd
14:49:05 <Cale> But it's also not something I'd ever try to do
14:49:28 <Cale> If you import Funcs from another module in the same directory, it should work.
14:49:44 <Cale> If you're just using ghci, you can always just load the module directly.
14:51:29 <frege> It is not a module in the current program, or in any known package.
14:51:45 <frege> I'm using ghci
14:51:52 <frege> but I was expecting it to work Cale
14:52:41 <Cale> frege: Yeah, I guess ghci doesn't look at everything in the current directory to try to find modules you ask it to import.
14:53:20 <ill_logic> Dummy check-  I have a .hs file I'm working on with main in it. It compiles and runs. However in ghci it only finds the main function. I can run it. But I want to play with other functions. What am I missing here?
14:53:35 <mzero> nothing
14:53:36 <frege> Cale: yeah I guess it needs a path or something
14:53:37 <enthropy> ill_logic: :load *filename
14:53:52 <ill_logic> interesting.
14:53:53 <enthropy> that will force it to be interpreted which gives you everything exported
14:53:56 <ill_logic> :l filename didn't work
14:53:59 <ill_logic> :load filename did
14:54:03 <mzero> the star makes ghci put all top levels in scope, not just those exported by the module
14:54:14 <ill_logic> ok now it does work
14:54:16 <c_wraith> ill_logic: ghci is loading the compiled code, given the .o and .hi files.  putting the * before the name forces it to interpret instead
14:54:32 <enthropy> yes mzero is right
14:54:32 <Cale> frege: If you have another module, say Foo.hs, with module Foo where import Funcs (bmiTell) in it, you can load Foo in ghci and then import Funcs (capital), and that'll work, because it will know that Funcs exists at that point.
14:54:37 <ill_logic> heh, I actually didn't even put the star, I thought I was supposed to fill in the blank. and it worked anyway
14:54:45 <ill_logic> any rate, thanks
14:54:59 <Cale> ill_logic: You can also just delete the .o file
14:55:35 <mzero> ill_logic: if you don't have an explicit export list, then the module exports all top levels - in which case star/no-start would be the same
14:55:57 <ill_logic> I see.
14:56:09 <ill_logic> I must have nudged something to make it work this time.
14:56:14 <frege> in this example : http://lpaste.net/95468 what does the first line do? http://lpaste.net/95468
14:56:17 <frx> it seems that import Foo, where Foo.hs is in cwd only works if you manually load the file first. I never noticed because I always used a key binded to inferior-haskell-load-file in emacs
14:57:11 <frege> I noticed that it also works without the first line
14:57:19 <c_wraith> frx: yes, that's true.  importing a module in ghci requires it to either be in a library, or interpreted.
14:57:24 <Cale> frege: It specifies the type of the thing being defined
14:57:36 <c_wraith> frx: and :load is the command to interpret a module
14:57:37 <frege> do functions need an input output signature in haskell? like capital :: String -> String
14:57:39 <Cale> frege: The compiler will check that the type which it infers that code has matches the type that you give.
14:58:02 <Cale> If you don't explicitly give a type, the compiler will (usually) be smart enough to determine it for you.
14:58:13 <frege> Cale: 'usually'?
14:58:15 <Cale> But it's useful as a form of documentation which the compiler will check.
14:58:21 <frege> can I depend on compiler for this?
14:58:25 <frege> right gotcha
14:58:27 <frege> makes sense
14:58:40 <Cale> There are some cases where the type is ambiguous and you'll need to specify what you want.
14:58:45 <frege> I love the syntax so far; can someone give me an interesting function?
14:59:02 <yesthisisuser> it's considered good practice to write the type declaration
14:59:09 <jophish> Yo
14:59:14 <c_wraith> And there are crazy type system extensions which allow things with types that can't be inferred. (higher-rank types is my favorite example)
14:59:14 <jophish> Does anyone here use neco-ghc?
14:59:25 <jophish> I'm having trouble getting it to find local modules
14:59:34 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
14:59:35 <jophish> for example, complete a symbol from another module
14:59:35 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:00:08 <frege> Cale: what does \ do in \p ?
15:00:36 <Cale> That's ascii art for a lambda
15:00:53 <Cale> which is a way of introducing functions without having to give them names
15:00:54 <mauke> lambda is non-ascii art for \
15:00:57 <Taneb> :t \a -> \b -> \c -> a c (b c)
15:00:58 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
15:01:05 <mauke> well, for ^ really
15:01:10 <Cale> (\x -> x^2) for instance is the function which given a value x will result in x^2
15:01:15 <Cale> > (\x -> x^2) 5
15:01:17 <lambdabot>   25
15:01:28 <frege> shit I have to leave; this coffee shop is closing
15:01:29 <frege> bbl
15:01:33 <Cale> > (\x y -> x^2 + y^2) 5 7
15:01:35 <lambdabot>   74
15:01:38 <Cale> see you!
15:01:59 <bz> i require a sanity check
15:02:15 <bz> readLn :: IO a
15:02:29 <c_wraith> I don't think that's actually the type of readLn
15:02:34 <c_wraith> :t readLn
15:02:35 <lambdabot> Read a => IO a
15:02:36 <bz> um
15:02:40 <bz> Read a => IO a
15:02:50 <ion> readLn = readIO =<< getLine
15:02:51 <c_wraith> Yeah, that difference is the reason it can work. :)
15:03:09 <bz> so if readLn is a pure func, then (IO "asdf") == (IO "dsd")
15:03:20 <c_wraith> readLn isn't a function
15:03:23 <c_wraith> it's just a value
15:03:24 <ion> There’s no such thing as IO "asdf", IO "dsd" or (==) for IO.
15:03:37 <haasn> bz: IO isn't a (value) constructor
15:03:51 <ion> bz: This may or may not be helpful. “What is inside Haskell IO?” https://gist.github.com/ion1/7154691
15:04:07 <c_wraith> readLn is a value that represents an IO action that reads a line of input and parses it in a limited way.
15:04:07 <bz> the fundamental definition of purity is that calling the func again and again with the same args yields the same ret val
15:04:17 <haasn> http://www.haskell.org/haskellwiki/Introduction_to_IO
15:04:19 <c_wraith> bz: readLn *is not a function*
15:04:22 <haasn> or just read LYAH etc
15:04:24 <c_wraith> bz: that *matters*
15:04:36 <bz> wtf? everything is a function. it's functional programming
15:04:40 <c_wraith> Nope!
15:04:48 <bz> ugh
15:04:54 <ion> bz: How do you apply "hello" to a value?
15:04:54 <haasn> bz: common misconception; http://conal.net/blog/posts/everything-is-a-function-in-haskell
15:04:56 <bz> please, no hairsplitting semantic debates
15:05:13 <chrisdone> it's not hair splitting, it's trivial basics
15:05:13 <c_wraith> this isn't a hairsplitting semantic debate.  This is a fundamental point.
15:05:16 <chrisdone> a -> y is a function
15:05:17 <chrisdone> a is not
15:05:18 <ion> bz: No, “everything is a function” is a fundamental misunderstanding that will make everything unclear.
15:05:25 <bz> f :: Read a => Maybe a is a function
15:05:30 <haasn> nope
15:05:31 <ion> no
15:05:33 <tabemann> no
15:05:35 <chrisdone> nuh-huh
15:05:35 <Rarrikins> no
15:05:48 <c_wraith> Ok, too much piling on at this point.
15:05:51 <Cale> Well, maybe inside the implementation once the compiler's done some stuff ;)
15:05:53 <Rarrikins> :P
15:05:57 <chrisdone> aw, you ruined the "no" chain =p
15:06:19 <Cale> But, yeah, if f has that type, it's not a function
15:06:28 <ion> cale: Yeah, thunks can also be implemented as procedures so "hello" is a function. This might not be helpful. :-P
15:06:44 <Cale> Right.
15:06:46 <c_wraith> > "hello" 5
15:06:47 <lambdabot>   Couldn't match expected type `a0 -> t0'
15:06:47 <lambdabot>              with actual type `[GHC...
15:07:01 <elliott> bz: it's not hairsplitting.
15:07:03 <chrisdone> actually i'm not sure that "Read a => Maybe a" can be populated by anything other than Nothing
15:07:03 <elliott> it's just wrong.
15:07:13 <haasn> chrisdone: Just (read "")
15:07:14 <elliott> it's no more hairsplitting than telling someone who says everything is a list that they're wrong.
15:07:40 <Cale> :t Just (read "5")
15:07:41 <lambdabot> Read a => Maybe a
15:07:44 <haasn> elliott: but I thought everything was a list in lisp! ;)
15:07:49 <chrisdone> haasn: you might as well write Just undefined
15:08:01 <haasn> > Just (read "5") :: Maybe Int
15:08:02 <lambdabot>   Just 5
15:08:06 <haasn> > Just (read "5") :: Maybe Word8
15:08:07 <lambdabot>   Just 5
15:08:10 <haasn> more useful than undefined :)
15:08:14 <chrisdone> > Just (read "5") :: Maybe String
15:08:15 <lambdabot>   Just "*Exception: Prelude.read: no parse
15:08:17 <bz> f :: Int -> Maybe Int
15:08:19 <chrisdone> oh noes, the function is pants
15:08:20 <bz> function or not?
15:08:27 <Cale> bz: f is a function then
15:08:27 <haasn> bz: yes
15:08:31 <tabemann> yes
15:08:37 <ion> bz: It’s a function iff there’s (->) in the type signature.
15:08:38 <haasn> (->) is the type of functions
15:08:50 <Cale> A function is something of type a -> b where a and b are any types.
15:08:51 <haasn> ion: Maybe (a -> b) -- is not a function
15:08:59 <ion> haasn: Thanks, i was just about to clarify that.
15:09:02 <bz> what's the diffference then? i'll just contrive a wrapper function accepts a random argument and returns the value of readLn
15:09:08 <c_wraith> Also, you need to expand type synonyms
15:09:09 <Cale> i.e. functions are things with (->) as their top level type constructor
15:09:11 <chrisdone> actually here's one that is reasonable
15:09:22 <c_wraith> like ShowS is a function.
15:09:23 <chrisdone> readMaybe "5" :: Read a => Maybe a
15:09:28 <Cale> bz: You can do that, and that'll be a function then.
15:09:34 <chrisdone> your versions are all rubbish =p
15:09:48 <Cale> bz: It'll be a constant function, but constant functions are functions too.
15:09:49 * chrisdone chants to-tal to-tal to-tal
15:09:52 <c_wraith> :t id :: ShowS
15:09:53 <lambdabot> ShowS
15:10:00 <bz> Cale: what?
15:10:07 <bz> Cale: it's not a const funcat all
15:10:14 <ion> :t id `asTypeIn` (undefined :: ShowS)
15:10:15 <lambdabot>     Couldn't match type `[Char]' with `a0 -> a0'
15:10:15 <lambdabot>     Expected type: (a0 -> a0) -> String
15:10:15 <lambdabot>       Actual type: ShowS
15:10:32 <ion> :t id `asTypeOf` (undefined :: ShowS)
15:10:33 <lambdabot> String -> String
15:10:33 <haasn> bz: \_ -> foo -- is a constant function, because it returns ‘foo’ no matter what parameter you pass it
15:10:39 <Cale> bz: A constant function is a function which produces the same result independently of which value it's applied to.
15:11:00 <Cale> i.e. a function which is equal to const x for some x
15:11:04 <Cale> :t const
15:11:05 <lambdabot> a -> b -> a
15:11:11 <Cale> :t const "hello"
15:11:11 <lambdabot> b -> [Char]
15:11:17 <haasn> :t const readLn
15:11:18 <lambdabot> Read a => b -> IO a
15:11:27 <bz> Cale: f x = readLn
15:11:38 <ion> A.k.a. f _ = readLn
15:11:42 <bz> whatever
15:11:46 <haasn> A.k.a. f = const readLn
15:11:49 <Cale> bz: Right, that's a constant function, because no matter what x is, it produces readLn as the result.
15:12:10 <bz> christ, readLn is the value
15:12:19 <Cale> hm?
15:12:23 <c_wraith> bz: maybe the problem is that you misunderstand what a value of type (IO a) means.  It doesn't mean "this is a value of type a that may do some IO".  It means "This is a representation of a program that does some IO to generate a value with type a".  The key difference is that IO values are programs for generating values, not the values themselves
15:13:04 <Cale> bz: Are you expressing the fact that you just understood something, or frustration about not understanding what I'm saying?
15:13:17 <chrisdone> it's about as much a function as this: https://gist.github.com/ion1/7154691#file-miniio-hs-L21
15:13:22 <Cale> readLn is indeed a value, and it's the value of f x for any x
15:13:36 <Cale> f is a function, but readLn is not
15:13:40 <bz> Prelude> readFile "argh.hs"
15:13:40 <bz> "f x = readLn\n"
15:13:40 <bz> Prelude> :t readFile "argh.hs"
15:13:40 <bz> readFile "argh.hs" :: IO String
15:13:42 <Cale> f is also, as it happens, a value
15:13:53 <yesthisisuser> it's not helping that everything is referred to as "Miscellaneous functions " in the docs
15:14:05 <yesthisisuser> undefined for instance
15:14:08 <mauke> yesthisisfunction
15:14:08 <bz> how the hell can the retval for that look like the retval for a String when its type is IO String, not String?
15:14:14 <yesthisisuser> http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html
15:14:26 <mauke> bz: IO String doesn't look like anything
15:14:36 <mauke> ghci doesn't display IO values
15:14:39 <mauke> it executes them instead
15:14:45 <Cale> bz: When GHCi sees an IO action, it executes the IO action, and then tries to show the result of executing the action, if possible.
15:14:48 <ion> bz: ghci executes IO actions. The "f x = readLn\n" in your terminal is not the value of readFile "argh.hs", it is the result of do { x <- readLine "argh.hs"; print x }
15:14:50 <haasn> @@ bz @quote /bin/ls
15:14:50 <lambdabot>  bz shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:15:06 <ion> readFile that is
15:15:20 <Cale> (I agree this is needlessly confusing, and I think it sucks. I'd prefer that it go back to the original behaviour by default of not always printing the results of IO actions.)
15:15:37 <jfeltz> how do you convert from Reader to ReaderT? I've tried: liftReader (Reader f) = ReaderT (return . f)    but I get "cannot import data constructor Reader" errors
15:15:39 <ion> I find it very convenient that ghci executes IO actions.
15:15:47 <Cale> The value of readFile "argh.hs" is *not* that string that it printed.
15:15:55 <bz> okay, so it's just being smart about reducing IO a
15:16:15 <Cale> That string it printed is the result of executing the action which is the value of readFile "argh.hs"
15:16:15 <haasn> I find it convenient too. confusing, but convenient. Maybe it should be a default-off option?
15:16:21 <geekosaur> jfeltz, it's a little complex because Reader doesn't really exist (it's a type alias for ReaderT Identity)
15:16:23 <chrisdone> bz: check this out, it's cool https://gist.github.com/ion1/7154691
15:17:01 <mauke> you need to distinguish between evaluation (part of Haskell-the-language) and execution (something special the runtime does with IO actions)
15:18:02 <chrisdone> (or ST or STM, i suppoe)
15:18:43 <mauke> no, there are run functions for those
15:19:01 <mauke> except runSTM is called 'atomically' for some reason
15:19:03 <tomejaguar> chrisdone: It's a cool idea to have that hypothetical implementation of IO as an example (though I don't know why it uses a GADT)
15:19:37 <mauke> tomejaguar: isn't Bind hard to type otherwise?
15:19:39 <haasn> Another (but significantly more complicated) example of IO-under-the-hood is http://comonad.com/reader/2011/free-monads-for-less-3/
15:19:47 <mauke> (maybe I should actually open the links people post here)
15:20:29 <elliott> you need an existential for that form, but you can do it as a free monad instead for H98
15:20:36 <haasn> tomejaguar: so you have a well-typed runMiniIO
15:20:38 <haasn> or whatever
15:20:41 <elliott> jfeltz: use "reader" lowercase
15:21:10 <geekosaur> in a pattern?
15:21:56 <haasn> jfeltz: I think you want http://hackage.haskell.org/package/mmorph-1.0.0/docs/Control-Monad-Morph.html#v:hoist
15:22:08 <jophish> hmm
15:22:17 <jophish> ghc-mod doesn't seem to have any support for local modules
15:22:37 <jophish> Is there any haskell vim plugin which supports completion for local modules?
15:22:57 <chrisdone> jophish: fp complete's does, but that'll be released in december
15:23:40 <jophish> chrisdone: does it have vi keys?
15:23:47 <haasn> :t Control.Monad.Morph.hoist (\(Identity x) -> return x) :: Monad m => State s a -> StateT s m a
15:23:48 <lambdabot> Monad m => State s a -> StateT s m a
15:23:57 <haasn> Or Reader, whatever
15:24:27 <chrisdone> jophish: the ide does, mgsloan and snoyberg are vim users, they're happy with the bindings. but we're providing an API for external editors to use, too (december)
15:24:54 <frx> will fp complete have argument hints when you type function name?
15:26:13 <jfeltz> elliott: think I just solved it the hard way: liftReader rdr = mapReaderT (return . runIdentity) rdr
15:26:16 <chrisdone> frx: it shows the type of the function at point, but we also have some intentions of showing the funcion args with an overlay of some kind with some tricky cleverness. no solid plans yet for that
15:27:37 <jfeltz> haasn: thanks, heh
15:27:51 <bz> oy, so it's necessary that readLn be the value
15:28:01 <bz> readLn, "asdf", 3
15:28:34 <jophish> In the meantime, Is it possible to get ghcmod-vim to do what I want?
15:28:46 <burbul> I have a typeclass used for prettyprinting, like this:
15:28:47 <burbul> instance Tex Formula where
15:28:52 <chrisdone> have you tried hdevtools? might be able to do it
15:28:58 <burbul>     tex (Not f) = "\\neg " ++ tex f
15:29:01 <chrisdone> it's basically ghc-mod with more make-up on
15:29:03 <bz> haasn, ion, Cale, c_wraith: thanks
15:29:22 <burbul> the type-specific all call each other -- so for example the 'tex' for Formula calls
15:29:27 <burbul> 'tex' for Term.
15:29:50 <burbul> Now, the problem is that I've realised I need an extra argument
15:30:02 <burbul> i.e. tex a(Not f) = "\\neg " ++ tex f
15:30:06 <jophish> chrisdone: I don't think that hdevtools does completion
15:30:07 <frx> chrisdone if I got that right you plan on doing something similar to what slime does, highlighting the type of the current argument you are typing within the type of the function?
15:30:09 <burbul> *tex arg (Not f) = "\\neg " ++ tex f
15:30:37 <Cale> bz: Yeah, it's important to separate in your head the processes of evaluation (reducing expressions to values, ultimately for the sake of pattern matching) and execution (carrying out the effects described by IO actions) which will be interleaved in a running Haskell program.
15:30:43 <burbul> this argument is passed into the tex code from outside and remains the same whatever kind of thing you're trying to tex --
15:30:44 <chrisdone> frx: yeah, i'm a fan of slime. i like that feature
15:30:53 <burbul> I'd like to avoid repeating it all the time.
15:31:00 <burbul> i.e. I'd like to be able to write *tex arg (Not f) = "\\neg " ++ tex f
15:31:08 <frx> chrisdone me too. it would be neat to have something similar for haskell
15:31:09 <burbul> Rather than tex arg (Not f) = "\\neg " ++ tex arg f
15:31:16 <chrisdone> frx: if that can be done. it's not often clear whether you're applying a function or just refering to it in haskell, compared to lisp. so some trickery is required to do it reliably
15:31:16 <burbul> Is there any way of accomplishing this?
15:31:26 <burbul> If I had normal functions (rather than the type class functions)
15:31:31 <burbul> I could manage it using a closure ...
15:31:41 <Cale> bz: When we say that Haskell is pure, what we mean is that evaluation of Haskell expressions doesn't have side-effects, and produces the same result every time it happens to the same expression. All the effects happen in execution.
15:32:11 <burbul> I suppose another way of asking that is: can you define a type class inside a function?
15:32:52 <haasn> I like to think of ‘purity’ in terms of “let x = y in ... x ... x ...” is the same as “... y ... y ...”
15:33:00 <Cale> (there are some funny low-level hooks which can be used to sidestep this, but they're something to take quite seriously, as a sort of last-resort before you modify the compiler, rather than something to use casually in everyday programming)
15:33:25 <haasn> (where ‘y’ could be ‘putStrLn "hello world"’, for example)
15:34:04 <Cale> yeah
15:34:28 <chrisdone> haasn: http://www.vex.net/~trebla/haskell/prerequisite.xhtml#leibniz
15:35:36 <haasn> chrisdone: yes
15:35:47 <chrisdone> let's start using that phrase =)
15:37:23 <Cale> chrisdone: Thanks for linking that, btw. I hadn't seen that one before. :)
15:37:31 <haasn> +1
15:38:21 <Cale> monochrom: and thanks for writing it ;)
15:39:22 <chrisdone> monochrom++
15:42:10 <loadedanvils> how do you check a haskell function's dependency?
15:42:17 <loadedanvils> in hackage
15:42:41 <Cale> loadedanvils: You're looking for which package defines something?
15:42:54 <Cale> loadedanvils: usually I find just googling works well
15:42:55 <loadedanvils> looking for outside dependencies
15:43:18 <Cale> oh, and then look at the deps for the package which it's defined in, perhaps?
15:43:25 <loadedanvils> specifically for Aeson's parseJSON, I want to know which functions from Data.Text it uses
15:43:36 <skypers> @hoogle e -> [e] -> Maybe e
15:43:38 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
15:43:38 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
15:43:38 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:44:32 <Cale> loadedanvils: It's a class method, so you'll have to look at all the instances
15:44:38 <AshyIsMe> what's a good way to build a haskell script from within vim?
15:44:50 <AshyIsMe> atm i'm swapping to a different tmux window and doing: ghc blah.hs
15:44:52 <skypers> AshyIsMe: what does you question mean?
15:44:53 <chrisdone> :q! emacs x.hs
15:45:06 <Cale> http://hackage.haskell.org/package/aeson-0.6.0.2/docs/src/Data-Aeson-Types-Class.html -- if you search here for parseJSON, you'll find lots of them
15:45:07 <skypers> AshyIsMe: oh
15:45:08 <hpc> AshyIsMe: you likely want to cabalize your project
15:45:12 <skypers> yeah
15:45:14 <skypers> cabalize it
15:45:16 <skypers> and hm
15:45:18 <hpc> then it's at least reduced to "cabal install"
15:45:26 <skypers> noremap <C-d> :sh<cr>
15:45:29 <AshyIsMe> this is just a simple script so far though
15:45:30 <skypers> it will help you ;)
15:45:41 <hpc> skypers: :! is easy enough for that
15:45:41 <mauke> and then set makeprg=cabal\ build
15:45:43 <chrisdone> cabal init # will make a file for you
15:45:43 <mauke> and then :make
15:45:56 <skypers> hpc: well
15:46:02 <skypers> I don’t agree
15:46:07 <AshyIsMe> oh nice, didnt know about :sh
15:46:08 <skypers> I use cabal’s sandboxes
15:46:23 <skypers> yeah :sh is quite nice :)
15:46:27 <skypers> for build
15:46:28 <skypers> yeah
15:46:31 <skypers> :!cabal build
15:46:35 <skypers> would make it as well
15:46:46 <Cale> chrisdone: lol :q! emacs x.hs
15:47:12 <hpc> Cale: C-c C-x cat > x.hs
15:47:15 <skypers> ok well, I have a user input through getLine
15:47:29 <skypers> I’d like to launch some function depending on what the user typed
15:47:36 <skypers> for now I use a table type
15:47:37 <skypers> like
15:47:48 <skypers> [(String,IO a)]
15:47:55 <hpc> this discussion makes me want to try and pipe a tty into dd
15:48:00 <skypers> but hm, I don’t actually know how to use that
15:48:03 <skypers> oh
15:48:10 <skypers> foldM it!
15:48:15 <AshyIsMe> chrisdone: ah yeap, cheers
15:48:19 <mauke> #include "/dev/tty"
15:48:22 <chrisdone> Cale: =p
15:48:25 <skypers> forM*
15:48:48 <mauke> skypers: did you mean: Map String (IO a)
15:48:54 <dwcook> skypers, fyi, since Strings have Ord, you can use a Map String (IO a) for that.
15:49:10 <skypers> I don’t know Map
15:49:18 <dwcook> Data.Map from containers
15:49:19 <skypers> why wouldn’t list good at it?
15:49:25 <dwcook> @hoogle Data.Map
15:49:26 <lambdabot> Data.Map module Data.Map
15:49:26 <lambdabot> Data.Map.Lazy data Map k a
15:49:26 <lambdabot> Data.Map.Strict data Map k a
15:49:28 <loadedanvils> @hoogle <$>]
15:49:28 <lambdabot> Parse error:
15:49:28 <lambdabot>   <$>]
15:49:28 <lambdabot>      ^
15:49:31 <loadedanvils> @hoogle <$>
15:49:31 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
15:49:32 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
15:49:34 <dwcook> skypers, Map is more efficient for one thing
15:49:41 <skypers> strictness?
15:49:45 <loadedanvils> @hoogle <*>
15:49:45 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:49:51 <Cale> skypers: There is lookup for lists, but it takes linear time, and lists don't have a lot of the other convenient operations that maps do.
15:50:02 <skypers> oh yeah
15:50:04 <loadedanvils> @hoogle (.:)
15:50:04 <lambdabot> No results found
15:50:07 <Cale> skypers: Not strictness, this is algorithmic efficiency
15:50:09 <skypers> maps are n*log(n)?
15:50:16 <mauke> no, maps just are.
15:50:25 <Cale> Maps take log(n) time to look up an element
15:50:28 <mauke> Map.lookup is O(log n)
15:50:40 <skypers> hm
15:50:46 <skypers> how are they implemented?
15:50:46 <hpc> asymptotic time is in the docs for Map
15:50:49 <mauke> lists allow nonsense like [("foo", return ()), ("foo", print 42)]
15:50:53 <dwcook> My favorite thing about Maps, though, is that they don't make me think about lists when what I want is looking up stuff
15:50:53 <skypers> brtree?
15:50:54 <mauke> maps don't
15:50:55 <Cale> They're internally balanced binary trees
15:51:18 <skypers> Cale: nice
15:51:19 <skypers> thank you
15:51:34 <skypers> so yeah, sounds more convenient for what I wanna do
15:51:35 <Cale> "Binary search trees of bounded balance"
15:51:51 <skypers> I need to learn how to use that
15:51:58 <skypers> maybe I should stop by Sequence
15:52:11 <loadedanvils> what does .: mean?
15:52:12 <skypers> the |> and all that stuff I don’t know yet
15:52:17 <skypers> :t (.:)
15:52:18 <lambdabot>     Not in scope: `.:'
15:52:19 <lambdabot>     Perhaps you meant one of these:
15:52:19 <lambdabot>       `.' (imported from Data.Function),
15:52:21 <mauke> loadedanvils: (.) (.) (.)
15:52:34 <Cale> skypers: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Lazy.html
15:52:47 <skypers> oh? there’s an operator for triple tities?
15:52:52 <monochrom> Cale, I just finished that artile yesterday! :)
15:52:54 <mauke> no
15:52:58 <loadedanvils> mauke: what is that?
15:53:03 <mauke> but if it existed, it would be called (.:)
15:53:06 <Cale> monochrom: Ah, that explains it then!
15:53:13 <mauke> loadedanvils: do you know (.)?
15:53:23 <loadedanvils> yes
15:53:28 <Cale> :t (.) . (.)
15:53:29 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:53:39 <mauke> well then
15:53:48 <mauke> (.) (.) (.) is (.) applied to (.) and (.)
15:53:56 <loadedanvils> ok
15:54:03 <mauke> it's 2-into-1 function composition
15:54:09 <mauke> \f g x y -> f (g x y)
15:54:24 <Cale> :t fmap . fmap -- Even though this is more abstract, I find it much easier to work out what's going on when you generalise like this
15:54:25 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:54:28 <hpc> (.:) is more interesting when it's fmap
15:54:37 <skypers> 00:42 < mauke> \f g x y -> f (g x y)
15:54:39 <skypers> hm
15:54:52 <skypers> I feel like I’ve already seen that somewhere
15:55:12 <Cale> Specialising, this becomes (a -> b) -> (e -> (e' -> a)) -> (e -> (e' -> b))
15:55:55 <epta> Attoparsec question. Suppose there is a parser (many entry <* optional endOfLine) which fails when particular line could not be parsed with entry Parser. How to make a parser which will continue parsing the next line?
15:56:14 <skypers> hey, I read on reddit haskell that lists are not intented to be used to store things but for flow manipulation
15:56:17 <skypers> is that even true?
15:56:26 <Cale> skypers: Partly!
15:56:30 <skypers> why would the foreign API use lists to represent C arrays then?
15:56:39 <Cale> skypers: It's not completely true
15:57:04 <Cale> But quite often, you'll want to think of lists as being for the case where you're definitely going to iterate over the elements in order.
15:57:07 <skypers> Cale: is this because GHC’s compilation’s optimizations?
15:57:14 <hpc> lists are intended to be lists
15:57:18 <Cale> This is just because of how lists are built up
15:57:21 <hpc> you can use lists for containment and flow control
15:57:48 <skypers> Cale: sure, so if I want to store values I’ll iterate over later, lists are great, right?
15:57:54 <mauke> \f g x y -> f (g x y)  ==>  \f g x y -> (f . g x) y  ==>  \f g x -> f . g x  ==>  \f g x -> (.) f (g x)  ==>  \f g x -> ((.) f . g) x  ==>  \f g -> (.) f . g  ==>  \f g -> (.) ((.) f) g  ==>  \f -> (.) ((.) f)  ==>  \f -> ((.) . (.)) f  ==>  (.) . (.)
15:57:54 <skypers> and if I want random access
15:57:56 <skypers> arrays
15:58:01 <Cale> Just as a loop either doesn't occur at all (because its precondition isn't met, say), or it consists of a single iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
15:58:05 <skypers> or whatever else
15:58:22 <unbirthday> hate to barge in, but can someone please help, i can't get sdl to work with haskell in both windows and linux
15:58:23 <gniourf_gniourf> If I have a function: a :: Int -> IO [Int], why does 'a _ = []' fail compiling? how can I make it work?
15:58:32 <skypers> unbirthday: yeah sure
15:58:33 <Cale> Right, lists are *exactly* what you want if you're going to iterate over a structure, and less than ideal in any other case.
15:58:36 <mauke> gniourf_gniourf: because [] is not an IO something
15:58:38 <donri> gniourf_gniourf: return []
15:58:40 <linz>  hi, is the find-union set data structure possible in Haskell?
15:58:44 <skypers> ok Cale
15:58:48 <linz> disjoint set
15:59:03 <linz> it is like a tree
15:59:10 <hpc> linz: well, haskell is turing complete, so...
15:59:13 <mzero> gniourf_gniourf: you need to say   a _ = return []
15:59:15 <mauke> no, haskell doesn't support trees
15:59:22 <skypers> and what do you thing about people saying that lists are not a good idea when you know you’ll iterate over the whole list?
15:59:23 <Cale> hah
15:59:23 <mzero> the return type is a list in IO, not just a list
15:59:26 <skypers> because of laziness?
15:59:27 <hpc> @remember mauke no, haskell doesn't support trees
15:59:27 <lambdabot> Okay.
15:59:31 <skypers> think*
15:59:43 <gniourf_gniourf> mauke, donri, mzero, thanks! I guess I have to read about IO's and return...
15:59:48 <mauke> skypers: I don't understand how that follows
15:59:49 <Cale> skypers: uh, I disagree on that
16:00:03 <skypers> mauke: how that follows?
16:00:06 <linz> haskell don't support trees..
16:00:07 <mzero> but - did you really want to have  a :: Int -> IO [Int]     -- why not a :: Int -> [Int]
16:00:15 <linz> it supports..
16:00:17 <linz> right
16:00:24 <skypers> mauke: they talked about infinity because yes
16:00:27 <skypers> lists are recursive
16:00:28 <Cale> linz: It does, mauke is kidding :)
16:00:29 <linz> data Tree= Tree | ...
16:00:32 <skypers> and might be not finite
16:00:41 <mzero> gniourf_gniourf: you only need to return the value in IO if a is going to do something with the rest of the world
16:00:41 <linz> okay. thank.
16:00:49 <mauke> data Tree = Tree | Τree Tree
16:00:52 <linz> I guess I all pass a list of trees?
16:00:54 <Cale> linz: btw, if you want to represent sets, make sure to try Data.Set
16:01:04 <linz> where each tree has its father , rank
16:01:08 <Cale> linz: It has Set.union which is linear time.
16:01:24 <Earnestly> wow
16:01:26 <linz> no that Set.union
16:01:32 <linz> I mean the find-union set
16:01:38 <linz> you can find the root of a set
16:01:47 <linz> you can merge the two set
16:02:06 <R1022> does >> need to be for monads? can't it work also for applicative functors?
16:02:17 <mauke> R1022: *>
16:02:28 <R1022> let (>>) a b = flip const `fmap` a <*> b
16:02:29 <R1022> oh
16:02:35 <R1022> :D
16:02:39 <mauke> @src (*>)
16:02:39 <lambdabot> (*>) = liftA2 (const id)
16:03:37 <R1022> thanks
16:03:52 <monochrom> skypers: FFI does not use Haskell list to represent C array. instead, it copies between Haskell list and C array. the choice of list is not meant to be fast, it is only meant to be lowest common denominator.
16:04:21 <R1022> what's the reason that there's both >> and *>?
16:04:28 <skypers> monochrom: I see
16:04:38 <skypers> R1022: well to work with Applicative only?
16:04:40 <Cale> linz: Aha, http://hackage.haskell.org/package/data-partition -- this looks good!
16:04:41 <mauke> >> came first
16:04:49 <Zearen> An easy one: What kind of exception does prelude error raise ?  (Yes, I know about style and all that; this is for a unit test.)
16:05:00 <mauke> @src error
16:05:00 <lambdabot> error s = throw (ErrorCall s)
16:05:01 <R1022> @mauke: i see
16:05:01 <lambdabot> Unknown command, try @list
16:05:21 <Cale> linz: You can see the source code here: http://hackage.haskell.org/package/data-partition-0.2.0.1/docs/src/Data-Partition.html
16:05:55 <mzero> I love that in Haskell reading source one-liners is the easiest way to understand what a function does!
16:06:17 <Cale> mzero: Or just look at the name of the function and its type ;)
16:06:34 <Cale> mzero: In the old days, that was about all the documentation you'd get!
16:07:13 <AshyIsMe> argh, i seem to be able to hang ghci within :GhciFile super easily
16:07:14 <mzero> I was trying to explain to my spouse that amazing wonder that for so many things in Haskell, you can tell from the type "the only possible useful thing it could do"
16:07:38 <mzero> and thence that if what you have compiles - it must work
16:07:45 <mauke> x :: Uphill snow (Either Way)
16:07:52 <monochrom> parametricity is hard won. a lot of programmers prefer type-case, which breaks parametricity.
16:08:32 <dwcook> Why doesn't Haskell have a typeclass for numbers capable of being negative, much as it has Fractional, so that, e.g., -1 is (Negative a) => a?
16:08:46 <Rarrikins> dwcook: Num
16:08:55 <dwcook> Rarrikins, I'm aware Num can be negative.
16:08:56 <mauke> Rarrikins: ಠ_ಠ
16:09:14 <dwcook> I'm asking why it isn't something separate so that, e.g., you can still use numeric literals for Nat with some safety.
16:09:21 <elliott> dwcook: because Num sucks
16:09:33 <elliott> this is the honest, complete answer
16:09:43 <geekosaur> it is well known that the existing numeric hierarchy is, frankly, broken
16:09:52 <mzero> for half the room, the numeric TypeClasses are overwraught --- for the other half, there aren't enough of 'em!
16:09:58 <dwcook> So, to put it another way, hysterical raisins?
16:09:59 <hpc> it is also well known that certain existing numeric types are broken
16:10:02 <geekosaur> there's also about zero consensus on how to fix it properly >.>
16:10:27 <dwcook> Ah, no consensus would do that.
16:10:39 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #1
16:10:48 <geekosaur> and how, if at all, IEEE floating point should fit into a fixed hierarchy, given that it's not exactly designed with number theory in mind
16:11:41 <monochrom> people would fight religious wars on whether IEEE floating point qualifies for Ord or not
16:11:54 <monochrom> so nevermind Num
16:12:30 <dwcook> What is one argument for float not being Ord?
16:12:47 <geekosaur> heck, we can't even get Enum/Bounded changed and I thought there was pretty decent consensus there (again modulo IEEE floats)
16:12:49 <Rarrikins> dwcook: NaN
16:12:53 <mauke> dwcook: broken ==
16:12:53 <dwcook> Ah, yes.
16:12:58 <monochrom> the obvious one is that Ord begets Eq
16:13:33 <mauke> > toRational (0/0)
16:13:34 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
16:13:41 <monochrom> well, unless you also say, you prefer Ord to not beget Eq. now you start a second religious war.
16:13:47 <geekosaur> -0 is also a bit weird, no?
16:15:28 <Cale> I think the numeric hierarchy is actually a lot closer to being perfectly reasonable than it looks at first
16:15:39 <Cale> There are just a bunch of small refinements
16:15:52 <Cale> Like moving signum and abs into their own class
16:16:05 <geekosaur> actually I would say it's pretty reasonable for its purpose but its purpose isn't what most people wish it were
16:16:39 <mauke> purposterous
16:16:51 <skypers> woah
16:16:57 <skypers> what is actually Seq?
16:16:59 <Cale> If we had a "Ring" class, I'd want to be a lot more picky about the laws.
16:17:00 <monochrom> -0 is there for -Infinity
16:17:06 <Cale> skypers: It's a finger tree
16:17:12 <skypers> it has O(1) on almost everything
16:17:17 <skypers> finger tree?
16:17:25 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
16:17:37 <skypers> why isn’t it called FingerTree then ? :)
16:17:49 <Cale> skypers: Well, it's a specialisation of FingerTree
16:17:53 <mauke> finger trees are more general
16:17:58 <ion> It’s *a* finger tree, not *the* finger tree. Or so. :-P
16:18:01 <Cale> with various things plugged in and then hand-optimised
16:18:25 <skypers> I see
16:18:28 <skypers> sounds great :)
16:18:30 <Cale> There is a fingertree package here: http://hackage.haskell.org/package/fingertree
16:19:29 <Cale> which is more general, and can be used to do many many data structures with asymptotically optimal bounds, but it'll tend to have worse constant factors than a hand-tuned version
16:19:50 <Cale> (still, it's a lot of fun to use, once you understand it)
16:21:24 <skypers> Cale: I lack theory here :)
16:23:05 <skypers> hm
16:23:09 <int-e> @unlambda ``ci`c`. `.!`.i`.hi
16:23:09 <lambdabot>   hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi!...
16:24:04 <unbirthday> out of about 15 games, so far only one has compiled successfully on the latest haskell, and that is HticTacToe
16:24:54 <unbirthday> is hackage truly this out of date? does anyone know even one platform (mario-like) game in haskell, preferably using sdl, that i can play and learn from
16:25:43 <mzero> I don't think Hackage is out of date - just people's SDL game projects have a tendency to go stale - the maintainers give up on 'em
16:26:03 <skypers> Cale: with Map, how can I construct it without using singleton and insert?
16:26:07 <unbirthday> actually only 2 or 3 of the games i tried were sdl
16:26:10 <skypers> I mean, using a simple notation?
16:26:26 <unbirthday> frag and Raincat don't compile, and i am learning haskell, so i can't even attempt to repair
16:26:45 <mzero> skypers: Map.fromList [("yo", "greeting"), ("l8trs", "closer")]
16:27:09 <unbirthday> bloxorz-0.1.1 failed during the building phase. The exception was:
16:27:09 <unbirthday> ExitFailure 1
16:27:12 <skypers> thank you mzero
16:27:17 <mzero> assuming you mean to create it from constants or simple expressions in source
16:27:18 <geekosaur> gui stuff in general tends to bitrot because most gui interfaces either are too painful or change too quickly
16:27:38 <mzero> b.t.w. that idiom     Foo.fromList   works with most container types in Haskell
16:28:10 <chrisdone> @karma Cale
16:28:10 <lambdabot> Cale has a karma of 36
16:28:20 <chrisdone> nuh-huh. lambdabot
16:28:25 <unbirthday> geekosaur: then is it possible to install an older version of haskell aside the newer version so that i can get things compiling?
16:28:26 <skypers> @karma skypers
16:28:26 <lambdabot> You have a karma of 0
16:28:28 <skypers> :(
16:28:29 <chrisdone> http://ircbrowse.net/nick/Cale?recent=false
16:28:33 <chrisdone> ^ Cale has 195
16:28:35 <chrisdone> =)
16:29:27 <geekosaur> the problem there is that you generally need system libraries as well, and getting older versions of those usually means going outside of whatever package manager your system uses
16:30:38 <geekosaur> (and the system gui libs change as fast or faster than the haskell interfaces: wx has had at least one major compatibility break recently, gtk+ tends to have them regularly)
16:30:53 <skypers> @hoogle while
16:30:54 <lambdabot> package while-lang-parser
16:30:54 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
16:30:54 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
16:31:44 <skypers> @hoogle IO Bool -> IO a -> IO a
16:31:44 <lambdabot> Network.HTTP.Base catchIO_ :: IO a -> IO a -> IO a
16:31:44 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
16:31:44 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
16:31:51 <skypers> ok, nevermind.
16:32:13 <mzero> skypers: just do it with tail recursion
16:32:29 <FreeFull> :t when
16:32:31 <lambdabot> Monad m => Bool -> m () -> m ()
16:33:00 <unbirthday> geekosaur: ok, thanks for the info
16:33:00 <Zearen> In Haskell, this is a perfectly reasonable way to test for an error:
16:33:00 <Zearen> assertPreludeError msg e = test $ catch ((return $! e) >> assertFailure msg) $ \e -> return $ const () (e :: ErrorCall)
16:33:06 <Zearen> ♥
16:35:34 <frx> skypers what are you trying to do?
16:35:51 <Zearen> Anyway, skypers, when I'm feeling procedural, I find this works better:
16:35:51 <Zearen> loop :: IO Bool -> IO ()
16:35:51 <Zearen> loop act = act >>= \continue -> if continue then loop act else return ()
16:36:03 <Zearen> Though when is far better.
16:36:04 <skypers> frx: just curious
16:36:11 <skypers> a while function doesn’t exit
16:36:12 <skypers> like
16:36:24 <skypers> while (IO condition) (IO a)
16:36:42 <Zearen> That's because it would be awful to use.
16:36:48 <skypers> why?
16:36:54 <chrisdone> use fix =p
16:37:08 <chrisdone> fix $ \loop -> if continue then loop else return ()
16:37:52 <Zearen> You'd almost necesarily have to define the condition in terms of IORefs or MVars.
16:38:08 <skypers> Zearen: yeah
16:38:11 <skypers> you’re right
16:39:05 <mzero> naw       loop = stuff_at_head >> compute_condition >>= $ \cond -> if cond then stuff_at_tail >> loop else return ()
16:39:43 <mzero> just use that pattern --- but you can use when to make it smaller
16:40:13 <mzero>     loop = compute_cond >>= $ \cond -> when cond $ body_of_loop >> loop
16:40:14 <mzero> or
16:40:23 <enthropy> @where om
16:40:23 <lambdabot> I know nothing about om.
16:40:28 <skypers> 01:28 < mzero>     loop = compute_cond >>= $ \cond -> when cond $ body_of_loop >> loop
16:40:32 <mzero>      loop = body >> computer_cond >>= $ \cond -> when cond loop
16:40:36 <skypers> when is returns m ()
16:40:46 <skypers> it’s not great here
16:40:49 <mzero> ah, you want to return the last value computed
16:40:53 <skypers> yep
16:40:56 <skypers> I ended with that:
16:40:59 <mzero> see -- this is why there is no good generic - there are SO many varients
16:41:12 <skypers>     where loop = do
16:41:12 <skypers>             choice <- makeChoice
16:41:12 <skypers>             if choice == Quit then return ExitSuccess else runWith choice >> loop
16:41:35 <mzero> it just seems easier to factor your loops into little custom functions in the where clause, then the body of your bigger function reads cleanly
16:42:02 <mzero> skypers: that code is no better than return ()   --- it only returns ExitSuccess
16:42:17 <skypers> hm
16:42:21 <skypers> you’re right
16:42:26 <skypers> I just need one other condition
16:42:30 <skypers> after the runWith
16:42:54 <skypers> if runWith choice == ExitFailure n, I quit with that
16:42:57 <skypers> otherwise I loop
16:43:06 <mzero> is runWith going to just do a lookup in the aforementioned map?
16:43:12 <mzero> if so - put an entry for Quit in it!!!!
16:43:22 <skypers> yes
16:43:27 <skypers> an entry ?
16:43:30 <mzero>  ah then do this
16:43:31 <skypers> yeah
16:43:32 <skypers> it is
16:43:40 <unbirthday> does indenting matter, as in python? and can i use a single tab?
16:43:43 <skypers> choiceTbl :: Map String RunChoice
16:43:43 <skypers> choiceTbl = fromList
16:43:43 <skypers>   [
16:43:43 <skypers>     ("raytracing", Raytracing)
16:43:43 <skypers>   , ("quit"      , Quit)
16:43:45 <skypers>   ]
16:43:48 <skypers> (sorry for the paste)
16:44:26 <mzero> heh - why bother with the data!   consider this
16:44:35 <mzero> commandTable :: Map String (IO Bool)
16:44:42 <skypers> yeah
16:44:51 <skypers> directly put the action in the map
16:44:54 <FreeFull> unbirthday: Indenting matters, and it's recommended that you don't use tabs at all, only spaces
16:45:00 <skypers> it’s what I first thought of but hm
16:45:16 <mzero> commandTable = fromList [ ("quit", return True), ("raytracing", raytraceMovie >> return False) ... ]
16:45:20 <skypers> well it might make it through you’re right
16:46:41 <mzero> now        cmdLoop = do  c <- getLine; keepGoing <- maybe (reportError c >> return True) id $ lookup commandTable c; when keepGoing cmdLoop
16:46:42 <FreeFull> unbirthday: You can also use {;} syntax, but indentation is preferred
16:47:09 <skypers> mzero: the thing is
16:47:10 <mzero> and don't use tabs - just spaces (tabs work, buy you'll regret it later)
16:47:24 <skypers> I already asked about that
16:47:32 <skypers> Cale told me to use Map
16:47:39 <skypers> and hm
16:47:44 <mzero> I'm sorry - Map.lookup
16:47:48 <skypers> oh
16:47:49 <skypers> ok :)
16:47:59 <fxr> still watching miss universe, I think I'm too far to be intellectual
16:48:11 <mzero> no matter - the Map thing is just an optimization - you could, for this use, get ride of the fromList and Map. and just use the list version
16:48:14 <mzero> it would be fine,
16:50:51 <frx> lookup works with association lists
16:51:09 <frx> > lookup "one" [("one", 1), ("two", 2)]
16:51:10 <lambdabot>   Just 1
16:51:29 <mzero> :t Map.lookup
16:51:30 <lambdabot> Couldn't find qualified module.
16:51:39 <mzero> :t M.lookup
16:51:40 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
16:51:52 <mzero> and Map.lookup works with Maps!
16:56:01 <arkeet> if you need something like a Map, you probably should use Map.
16:56:10 <arkeet> generally
16:58:06 <FreeFull> You can also use some Map type from a different package, which would be more efficient than the built-in Map
16:58:23 <frx> the only difference is efficiency, and with N being small enough list lookup can be faster than Map.lookup
16:58:27 <mzero> I disagree -- if all you are doing is looking up something into a short, static association written in the source (like mapping one of a dozen command names to an IO action) -- then there's really nothing wrong with a bare [(a,b)]
16:58:33 <dor> there's a built in Map?
16:58:49 <mzero> dor: The standard package containers has a Map and a Set
16:59:04 <mzero> and unordered containers has HashMap and HashSet
16:59:12 <dor> yes
16:59:22 <arkeet> mzero: ok, sure
16:59:23 <dor> i wouldn't call any of these built in :)
16:59:29 <mzero> you were looking for something more "built-in", dor?
16:59:44 <mzero> would you call Maybe built in?
16:59:52 <arkeet> assuming it's smart enough to inline that stuff
16:59:54 <dor> i was wondering what FreeFull was referring to
16:59:56 <mzero> or Either?   or even [] for that matter?
16:59:58 <arkeet> mzero: those are in base
17:00:17 <mzero> and base is? special somehow?
17:00:18 <arkeet> well, containers comes with ghc too
17:00:43 <mzero> even 90% of the Prelude is just pure Haskell ...
17:00:57 <mzero> so, built-in doesn't really carry much useful meaning in the Haskell universe
17:00:57 <hpc> 100% of the GHC Prelude is pure haskell
17:00:59 <dor> kinda silly that lists aren't
17:01:20 <FreeFull> Just because it isn't hardcoded into the compiler doesn't mean it doesn't count as built in
17:01:24 <mzero> that lists aren't what? built-in?
17:01:36 <dor> aren't pure haskell
17:01:54 <Rarrikins> Are you talking about what you can use without 'import'?
17:01:54 <mzero> uhm... they are, they just have syntatic sugar in the langauge
17:02:05 <arkeet> there is no data [a] = ...
17:02:12 <arkeet> anywhere
17:02:20 <dor> you can't define list as it is defined without any sugar
17:02:26 <mzero> @src []
17:02:26 <lambdabot> data [] a = [] | a : [a]
17:02:31 <mzero> there isn't?
17:02:32 <geekosaur> arkeet, actually I think there *is* somewhere in GHC.*
17:02:33 <arkeet> @src lies
17:02:37 <mzero> ;-O
17:02:39 <frx> :)
17:02:40 <arkeet> geekosaur: I just looked in GHC.List
17:02:45 <dor> it's not a desugaring because there's no first-class type it desugars to
17:02:46 <arkeet> module GHC.List (
17:02:47 <arkeet>    -- [] (..),          -- Not Haskell 98; built in syntax
17:03:45 <FreeFull> There is some special syntax that requires built-ins
17:03:52 <mzero> nonetheless - these senses of built-in are not at all like the sense in which dict is "built-in" to Python
17:03:57 <FreeFull> Tuples, lists, pattern matching on numerals
17:04:15 <arkeet> the tuple type isn't built in
17:04:19 <geekosaur> haskell98 didn't allow (:) to be defined IIRC (symbolic infix constructors), but I think it is legal now.
17:04:25 <dor> i disagree there; dict is very much like lists and tuples in haskell IMHO
17:04:37 <frx> what is the syntax for lists in Haskell 98?
17:05:05 <dor> frx: same as always
17:05:14 <FreeFull> > [1,2,3]
17:05:15 <lambdabot>   [1,2,3]
17:05:22 <mzero> no - dor - I don't think so - there is no way you can replicate dict in pure python --- but [] and : enjoy no more specal status that your own   data List a = Nil | Cons a (List a)
17:05:33 <AshyIsMe> > ['a','b','c']
17:05:34 <lambdabot>   "abc"
17:05:42 <AshyIsMe> > "easy as"
17:05:43 <lambdabot>   "easy as"
17:05:47 <AshyIsMe> > [1,2,3]
17:05:48 <lambdabot>   [1,2,3]
17:05:52 <dor> mzero: all i said was it's kinda silly that's not what list is - Nil and Cons with sugar
17:05:53 <frx> this led me to believe it was something else. "-- [] (..),          -- Not Haskell 98; built in syntax"
17:05:58 <FreeFull> You could do lists without the syntactic sugar, but the syntactic sugar itself has to be built in as things are right now
17:06:10 <arkeet> frx: you can't *define* the type in haskell 98.
17:06:21 <frx> ah ok
17:06:36 <mzero> the syntax is built in, but other than that, they are just like any other data type
17:06:58 <geekosaur> note that haskell 98 is not the current standard and in any case the syntax ghc accepts can define it fine
17:07:12 <dor> mzero: well [] *is* the constructor and you couldn't define that yourself
17:07:17 <dor> it's not just sugar for List/Nil
17:07:21 <mzero> dor - sorry, it sounded like you were searching for a built-in map, perhaps on the assumption that it would be somehow better or more desirable than map from some package
17:07:22 <Cale> geekosaur: To be fair, Haskell 2010 is almost identical to Haskell 98 :)
17:07:44 <geekosaur> true. but the language ghc accepts isn't, quite :p
17:07:55 <mzero> dor - true at the synatx level, but at the semantics (and operationally), it is no different than Nil
17:08:03 <dor> mzero: no iwas just wondering what FreeFull meant by "built in Map" because it sounded like they meant there's a Map in base or the core language
17:08:24 <FreeFull> dor: I meant in standard libraries
17:08:39 <mzero> and we come full circle - hence my "built in" in Haskell isn't as useful a concept as it is in other langauges!
17:08:56 <identity> Writing code, testing, and trying to find some strange bug because visual representation doesn't match expectation for 2 hours because 3rd party program isn't reading output file right .. grrrreat
17:09:00 <mzero> anyhow - nice chatting - off to dinner!
17:09:02 <mzero> l8trs
17:09:18 <pome> i understand if this is perhaps not the most appropriate channel in which to post this, but i'm confident in my ability to program this imperatively in java etc; i'm just struggling with the haskell implementation
17:09:18 <dor> mzero: i don't see how dict in python is any different from that then. you could make a lookup table object in just python, no reason you couldn't
17:09:30 <pome> i'm trying to get this int seq: http://oeis.org/A002188
17:09:53 <pome> it presumably won't mean much to those without at least a vague knowledge of combinatoric game theory
17:11:06 <pome> i also don't know enough mathematica to decipher the code they have on the page for it there
17:11:14 * hackagebot hArduino 0.7 - Control your Arduino board from Haskell.  http://hackage.haskell.org/package/hArduino-0.7 (LeventErkok)
17:12:59 <identity> pome: and what is your issue?
17:13:26 <identity> :t digitToInt
17:13:27 <lambdabot> Char -> Int
17:13:44 <pome> identity: i'm not sure how to go about the recursion i need to build the list
17:13:45 <FreeFull> > digitToInt '3'
17:13:46 <lambdabot>   3
17:13:49 <FreeFull> > digitToInt 'A'
17:13:50 <lambdabot>   10
17:13:52 <FreeFull> > digitToInt 'Z'
17:13:54 <lambdabot>   *Exception: Char.digitToInt: not a digit 'Z'
17:14:27 <identity> > let num = "123" in sum $ map ((\x -> x*x) . digitToInt) num
17:14:28 <lambdabot>   14
17:14:43 <identity> FreeFull: wait wat
17:14:47 <identity> oh.
17:14:50 <identity> it does hex as well
17:14:51 <identity> I get it
17:14:54 <FreeFull> Yeah
17:15:36 <identity> pome: Well, you should probably create a function that takes a list of numbers and gives you the sum of their squares
17:16:02 <identity> then you probably also need a function that takes a string representation of a number and gives you its digits as a list of integers
17:16:26 <identity> (that is one way to do it, anyway)
17:17:19 <identity> pome: If you manage to make all the parts, you should be able to glue them together, and you can probably use iterate or until or some such to implement the recursion
17:17:23 <identity> :t iterate
17:17:24 <lambdabot> (a -> a) -> a -> [a]
17:17:25 <identity> :t until
17:17:25 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
17:18:22 <FreeFull> > map digitToInt "184882"
17:18:22 <pome> identity: i wasn't aware of any algo. to create this list which concerns itself with the string representation of a number
17:18:23 <lambdabot>   [1,8,4,8,8,2]
17:19:06 <identity> pome: I'm not sure what you mean
17:20:06 <haasn> > "Z" ^? base 36
17:20:08 <lambdabot>   Just 35
17:20:53 <pome> identity: i think we have crossed wires somewhere - i sent a link to a list of values resulting from a combinatoric game-theory function. i haven't been able to implement an algorithm which gives me the same list that exists on the OEIS, in haskell
17:21:12 <FreeFull> lens again
17:21:23 <pome> identity: as i prefaced, i probably should have asked this in a math channel instead of here
17:21:28 <identity> pome: Yes. A000218?
17:21:41 <haasn> identity: 2188 :)
17:21:55 <pome> identity: ha
17:21:57 <identity> ugh.
17:21:59 <identity> hahaha
17:22:07 <pome> there's the crossed wire there
17:22:21 <identity> that's what you get for not setting up your terminal for link clicking and manually typing links into your browser at 2 am
17:22:28 <identity> yes, I'm sorry. ignore everything I said
17:22:43 <pome> identity: don't worry about it
17:23:45 <haasn> at least now I can stop trying to figure out why identity started mentioning digitToInt :)
17:23:57 <identity> oh god that was silly.
17:24:05 <pome> i thought that someone had asked a question before i joined the channel
17:24:13 * identity crawls back into his cave
17:24:26 <FreeFull> Is there anything lens doesn't do?
17:25:51 <scooty-puff> is there a good reason to use IORef over STRef RealWorld?
17:26:38 <Rarrikins> scooty-puff: IORefs are in the IO monad.
17:27:00 <scooty-puff> :t stToIO
17:27:01 <lambdabot> ST RealWorld a -> IO a
17:27:20 <pome> why have 'f (n+k)' patterns been discontinued/disallowed?
17:27:52 <FreeFull> Their semantics weren't clean enough
17:27:54 <pome> this is the first time i've tried to use one since i heard the news
17:27:58 <edwardk> FreeFull: laundry
17:28:06 <scooty-puff> it looks like STRef RealWorld has just as much power as IORef, and as easy to use if you use liftST and redefine all the STRef functions to use MonadST
17:28:10 <FreeFull> edwardk: I'm sure there is a way to make it do that too
17:28:19 <scooty-puff> as far as i can tell - would very much like to know if this is not the case
17:28:26 <elliott> scooty-puff: no atomic stuff for STRef afaik
17:28:31 <scooty-puff> k
17:28:33 <FreeFull> scooty-puff: RealWorld probably shouldn't be exposed
17:28:38 <edwardk> pome: they were a rather large section of the report for how poorly they worked
17:29:03 <haasn> pome: http://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010
17:29:36 <pome> haasn: i suppose i probably could have gotten to that myself with a bit of effort - thanks.
17:29:44 <edwardk> pome: (n + k) has weird ties to Eq, (-), strange positivty conditions, etc.
17:30:10 <edwardk> they don't respect the definitions you bring into scope and generally were a language wart
17:30:46 <haasn> edwardk: Eq? Not Ord?
17:31:36 <edwardk> it ties to Integral, -, (>=) from Ord, abuses int as if it were a nat, doesn't use whats n scope...
17:33:39 <FreeFull> You probably can use ViewPatterns as a cleaner alternative
17:34:09 <arkeet> f (subtract k -> n) = ...
17:34:27 <arkeet> I don't really like it.
17:35:37 <pome> how well if at all is strathclyde uni regarded within the fp / mathematically structured programming community?
17:35:49 <pome> is anyone outside of scotland really aware of it?
17:36:04 <haasn> I know the strathclyde haskell extension but that's about it
17:36:35 <elliott> McBride is there, so :)
17:36:57 <pome> elliott: i checked the user list to make sure he wasn't in the channel before i asked
17:39:24 <^LiNuXMaN^> why use haskell
17:39:29 <un1xguy> hi ^LiNuXMaN^ welcome 2 #haskel
17:39:57 <un1xguy> i use php its great ^LiNuXMaN^
17:40:52 <^LiNuXMaN^> no php sucks
17:40:57 <^LiNuXMaN^> i want to haskell
17:41:17 <un1xguy> php is great lots of fun =)
17:41:21 <pharaun> have you read lyah and rwh ?
17:41:29 <^LiNuXMaN^> how?
17:41:34 <identity> i smell trolls
17:41:45 <chrisdone> how is haskell formed ?
17:41:45 <chrisdone> how function get curried?
17:41:53 <^LiNuXMaN^> tell me
17:41:53 <un1xguy> ^LiNuXMaN^: pointers.... haskel doesnt have those, incomplete language...
17:41:57 <FreeFull> how is lambbda formed?
17:42:08 <identity> lol
17:42:18 <^LiNuXMaN^> i like curry
17:42:20 <FreeFull> un1xguy: Haskell has pointers
17:42:24 <un1xguy> ^LiNuXMaN^: also in php u can change variables
17:42:25 <^LiNuXMaN^> no
17:42:32 <identity> no
17:42:33 <^LiNuXMaN^> in haskell you can not change variables
17:42:35 <chrisdone> they need to do way instain monad. because the pure function can't frigth back?
17:42:43 <FreeFull> And IORefs
17:42:50 <^LiNuXMaN^> lolrefs??????????
17:42:52 <zomg> chrisdone: lol
17:43:04 <^LiNuXMaN^> bye ikoo_
17:43:07 <un1xguy> $a = "hi" and  $a = 10 compiles =) in php not haskel
17:43:07 <zomg> I smell a troll
17:43:20 <zomg> un1xguy: I made a PHP interpreter in haskell, does that count?
17:43:25 <un1xguy> no??
17:43:28 <AshyIsMe> chrisdone: they apply it way instain their functors
17:43:32 <^LiNuXMaN^> ehhhh why would that count
17:43:37 <zomg> because I said so
17:43:39 <FreeFull> > let a = "Hi"; a = 10 in a
17:43:39 <un1xguy> i dont count
17:43:39 <zomg> lel.
17:43:40 <lambdabot>   Conflicting definitions for `a'
17:43:40 <lambdabot>  Bound at: <interactive>:1:5
17:43:40 <lambdabot>            <in...
17:43:41 <zomg> @ops
17:43:41 <lambdabot> Maybe you meant: pl oeis docs
17:43:41 <hpc> zomg: make it a quasiquoter
17:43:46 --- mode: ChanServ set +o geekosaur
17:43:46 <^LiNuXMaN^> you see
17:43:52 <FreeFull> > let a = "Hi"; in let a = 10 in a
17:43:53 <lambdabot>   10
17:44:02 <pome> one of my favourite things about fp generally is that the user base (or, at least, the active, contributing theoretical members) is small enough that i can recognise names pretty quickly
17:44:02 <chrisdone> i love writing code in ghci
17:44:07 <AshyIsMe> oh i wasnt reading fast enough
17:44:14 <chrisdone> i build up my expressions incrementally with :t until i'm ready to eval it
17:44:18 <^LiNuXMaN^> c# is also functional
17:44:28 <identity> pome: aye
17:44:29 <un1xguy> php is functional 2
17:44:36 <AshyIsMe> so, what's the deal with arrows?
17:44:39 <pome> i went to a lecture a couple of weeks ago hosted by a phd student whose name i recognised from r/dependenttypes
17:44:40 <hpc> haskell is functional 1.1
17:44:41 <AshyIsMe> im reading this: http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html
17:44:42 <^LiNuXMaN^> you make it like this: public static void Function() { }
17:44:43 <identity> pome: you're intermingling with guys that wrote the books and the guys that wrote the compilers and everyone in between
17:44:46 <identity> basically
17:44:47 <FreeFull> Brainfuck is functional
17:44:49 <AshyIsMe> they just sound like functions, what am i missing?
17:44:52 <un1xguy> php is functional ++
17:45:17 <un1xguy> how many operating systems r written in haskell vs php
17:45:31 <FreeFull> I think Haskell has two
17:45:36 <hpc> wow, you caught us now
17:45:46 <hpc> php is clearly the superior language for writing operating systems
17:45:53 <zomg> hpc: you didn't know?
17:45:56 <pome> haskell has xmonad, at least
17:45:57 <zomg> the internet is written in php
17:45:59 <zomg> ;>
17:46:07 <FreeFull> One Haskell OS is called House
17:46:08 <chrisdone> AshyIsMe: they're very similar to functions yeah. they abstract the idea a little bit so things other than functions can take one type to another. honestly after learning them years ago i haven't used them since for anything. i use the combinators for tuple manipulation. but yeah, i hear all the XML libraries love that arrow stuff
17:46:14 <un1xguy> first web server was written in php...
17:46:20 <triliyn> AshyIsMe: someone said a while ago that in theory, you can do more computation-fusing on arrows because the second argument to >>> is a data type you control
17:46:29 <triliyn> Unlike the second argument to >>=, which is an opaque function
17:46:35 <zomg> nono the first web server was actually an OS written in PHP with built in web serving
17:46:45 <un1xguy> srsly
17:46:50 <un1xguy> zomg: r u sure
17:46:53 <zomg> yes
17:46:53 <Cale> triliyn: Could have been me :)
17:46:56 <zomg> look it up on the wikipedias
17:46:56 <pharaun> chrisdone: ghci is one of my *many* favorite thing :)
17:46:59 <triliyn> But also that in practice this doesn't happen often because arr constructs a simple wrapper around an opaque function
17:47:04 <AshyIsMe> ah ok, so basically think of them like functions and continue messing around parsing html :P
17:47:07 <un1xguy> zomg: y
17:47:11 <triliyn> Cale: maybe! You do seem to say lots of interesting things
17:47:35 <identity> A Team of Trolls uses Hurr Durr Troll on #haskell
17:47:40 <identity> .. it is not very effective.
17:47:44 <Cale> triliyn: Yeah, the problem isn't just that arr is there, but that if you use the proc/do syntax, the translation for that syntax uses it in between literally every pair of computations.
17:47:52 <chrisdone> AshyIsMe: in practice, pretty much. kind of like how a monad can thread some state through, arrows can do that too, wheras a function would have to explicitly have it as an argument
17:48:00 <zomg> identity: this is pretty amusing, probably the worst trolling attempt I've seen in a while
17:48:01 <Cale> triliyn: which makes it impossible to analyse what's going on
17:48:23 <chrisdone> AshyIsMe: but a monad lets you control the flow as a user of the library. arrows don't let you do much other than compose them and filter on the pipeline, hence them being attractive for XML processing
17:48:24 <elliott> un1xguy: are you here to talk about haskell or php?
17:48:34 <un1xguy> sry haskel is great
17:48:35 <scooty-puff> is there a good template project for cabal projects on github (including basic .travis.yml, etc.)?
17:48:40 <scooty-puff> i thought i saw one a while ago..
17:48:49 <pome> this is probably a long shot, but i presume there's no one here from st. andrews?
17:48:53 <AshyIsMe> zomg: this is probably my favourite trolling that i can remember: https://github.com/jayferd/balls
17:48:54 <identity> zomg: yeah, they get an F for effort
17:48:58 <AshyIsMe> bash on balls mvc framework
17:48:58 <Cale> triliyn: Adding a few additional primitives to the Arrow class (the extra data which is included in the definition of a symmetric monoidal category, as it happens), and rewriting the Arrow desugarer to use those operations makes Arrow far more practical.
17:49:00 <joelteon> scooty-puff: edward has one
17:49:03 <joelteon> edwardk has one
17:49:08 <scooty-puff> k
17:49:12 <zomg> AshyIsMe: haha =)
17:49:21 <joelteon> he's ekmett on github
17:49:27 <pome> AshyIsMe: that's an excellent name
17:49:34 <AshyIsMe> it's good aye
17:49:40 <un1xguy> i have an idea 4 the next facebook its all done except the codes
17:49:47 <edwardk> you're thinking of https://github.com/lens/project-template
17:50:14 <un1xguy> any1 wanna join ThE revOluTion??
17:50:17 --- mode: ChanServ set +o elliott
17:50:27 --- kick: un1xguy was kicked by elliott (un1xguy)
17:50:31 <scooty-puff> edwardk: thanks!
17:50:35 <pome> ha
17:50:42 <geekosaur> what I get for looking away
17:50:44 --- mode: geekosaur set -o geekosaur
17:50:59 <identity> too bad
17:51:02 <Cale> @quote un1xguy first web server was written in php...
17:51:02 <lambdabot> No quotes for this person. :(
17:51:07 <Cale> @remember un1xguy first web server was written in php...
17:51:07 <lambdabot> Good to know.
17:51:10 <identity> I was really ready to join the revOluTion
17:52:59 --- mode: elliott set -o elliott
17:56:11 <pome> i hate google's new parser
17:56:18 <pharaun> ?
17:56:31 <pome> '+' is treated as punctuation now, not a bool operator
17:57:00 <jle`> probably makes more sense for normal people
17:57:09 <jle`> google has been doing this for a while though
17:57:13 <jle`> wish they had some kind of power mode option
17:57:16 <moops> + is now ""
17:57:29 <Cale> Why would you need + ?
17:57:33 <NemesisD> anyone doing haskell professionally? i'm looking for some advice
17:57:47 <Cale> Personally I think it makes more sense to be able to search for +
17:58:08 <pome> Cale: what if one is searching both for something common and obscure?
17:58:20 <Cale> what?
17:59:15 <jrmithdobbs> that moment where you realize you started with the .Types module and accidentally already implemented half of what you intended to without putting it in the other modules ;p
17:59:22 <Cale> pome: Doesn't + mean the same thing as whitespace?
17:59:52 <geekosaur> I think they mean the bit where +foo meant exact match for foo was required in the results
18:00:03 <Rarrikins> I think they switched that to quotes.
18:00:03 <Cale> Oh, in that case, "foo" works
18:00:08 <pome> yeah, that expresses it better than i could
18:00:14 <Rarrikins> I know it warned me about that in the past.
18:00:21 <geekosaur> and yes, quotes are how you do it now
18:00:23 <frx> does - still work?
18:00:24 <jrmithdobbs> the old boolean syntax works if you apply it to quoted strings
18:00:29 <Rarrikins> - still works.
18:00:29 <moops> - still works
18:00:36 <jrmithdobbs> eg, -"string" +"string"
18:00:40 <pome> i think - only works with -"x" though
18:00:57 <moops> it works without quotes
18:01:03 <pome> otherwise it's treated as punctuation (or stripped: i'm not sure)
18:01:09 <moops> i always come across it when searching for command line options
18:01:12 <jrmithdobbs> all of it still works, you just have to use quoted strings to make the parser know what you're doing in some very non-obvious questions
18:01:17 <jrmithdobbs> s/questions/situations/
18:01:33 <jrmithdobbs> so just always quote if you're using the modifiers
18:02:11 <pome> it took me a while to get out of the habit of tapping num-plus with my right-thumb when quickly searching though
18:04:02 <pome> the existence of case- and punctuation-sensitive search engines running on top of google leads me to believe that google are indeed indexing +, -, /, etc. anyway
18:04:21 <pome> one wonders why there isn't indeed a power-user mode
18:05:05 <jrmithdobbs> htere is
18:05:16 <jrmithdobbs> i forget where the help page is but the syntax *is* documented
18:06:04 <Cale> - still appears to work without quotes
18:06:20 <pome> jrmithdobbs: yeah, https://support.google.com/websearch/answer/136861 is still around
18:06:37 <jrmithdobbs> there it is
18:06:48 <pome> but there exist case-sensitive search engines which appear only to be google overlays
18:07:19 <hpc> also duckduckgo
18:07:46 <pome> there is this though: http://www.google.com/advanced_search
18:08:02 <geekosaur> symbolhound.com
18:08:20 <Cale> "an upper maximum or a lower minimum" -- as opposed to a lower maximum or an upper minimum
18:08:21 <pome> geekosaur: that's what i generally use
18:08:26 <NemesisD> what's this about duck duck go?
18:08:42 <pome> geekosaur: it's decent when hoogle is useless
18:08:46 <Cale> NemesisD: What advice are you looking for btw?
18:08:55 <pome> which seems to be more frequently, recently
18:09:04 <NemesisD> i use duckduckgoog. bang searches like !hoogle and !hayoo work, passes regular searches through to google
18:09:20 <chrisdone> pome: hoogle or google?
18:09:30 <pome> chrisdone: the former
18:09:35 <chrisdone> i'm finding more and more that google tries to guess what i _really_ meant, when i meant exactly what i wrote
18:09:49 <chrisdone> "we searched this instead for you. click this other link to search what you actually wanted to search"
18:09:50 <NemesisD> Cale: I may be on the job market soon and I really want to look seriously into remote haskell work. Want to get an idea of the lay of the land (salary, who is using it, etc). in private is fine
18:10:19 <pome> http://www.haskell.org/hoogle/?hoogle=%5Ba%5D+-%3E+%28%5Ba%5D+-%3E+%5Bb%5D%29+-%3E+b
18:11:22 <pome> has anyone heard of the job(s?) barclays are offering in kiev
18:12:49 <gfredericks> can I specify -XOverloadedStrings in my .cabal file?
18:12:52 <jrmithdobbs> so I notice something interesting, modules which import modules defining/using GADTs don't seem to need to enable the extension to use them?
18:13:10 <hpc> gfredericks: it's a better idea to put it in source
18:13:35 <Cale> jrmithdobbs: I suppose you only need to turn on the extension to define them.
18:13:37 <jrmithdobbs> gfredericks: but if you really want, you can use default-extensions in the library section
18:13:39 <hpc> gfredericks: in the cabal file, there's a dependency between having the cabal file and being able to compile the source manually at all
18:13:51 <gfredericks> how do I put it in my src file?
18:14:13 <hpc> {-# LANGUAGE OverloadedStrings, OtherExtension #-}
18:14:14 <gfredericks> something source-local would be great
18:14:17 <jrmithdobbs> {-# LANGUAGE ext1,ext2,ext3 #-}
18:14:45 <chrisdone> In the use of `chunk'
18:14:45 <chrisdone>              (imported from Data.List.Split, but defined in Data.List.Split.Internals):
18:14:45 <chrisdone>              Deprecated: "Use chunksOf.
18:14:50 <chrisdone> but chunk is superior =(
18:14:56 <gfredericks> that totally worked thanks hpc, jrmithdobbs, etc
18:15:14 <jrmithdobbs> Cale: i'll play with it a bit, i may be that i've, for once, actually segregated my code well enough where I wouldn't notice anyways, ha
18:15:48 <jrmithdobbs> Cale: seeing as only the defining modules are manipulating the gadts other than exporting their constructors and/or convenience constructors
18:16:50 <pome> night.
18:20:05 <jrmithdobbs> how do i tell if this got merged or not?
18:20:08 <jrmithdobbs> http://trac.haskell.org/haddock/ticket/43
18:20:11 <jrmithdobbs> very confusing
18:20:45 <jrmithdobbs> s/merged/fixed/
18:21:52 <gfredericks> the sandbox config file is not a good one for version control, right?
18:22:42 <enthropy> jrmithdobbs: maybe nwf knows?
18:22:49 <enthropy> or just try it out in your haddock
18:26:43 <jrmithdobbs> enthropy: i'm having issues with the syntax with record syntax + gadts ... i can get it to document records in the constructors but the constructors themselves not so much
18:27:54 <jrmithdobbs> ya, I can document the records with -- | or -- ^ but not the constructors with -- | or the returns with -- ^
18:28:00 <jrmithdobbs> so, still broken i guess
18:49:01 <nwf> enthropy: I don't, sorry.
18:53:01 <cschneid> is there a tutorial people like that would help me grok the idea of arrows?
18:53:47 <FreeFull> I haven't actually seen much code that uses arrows
18:54:02 <Clint> cschneid: https://en.wikibooks.org/wiki/Haskell/Understanding_arrows ?
18:54:26 <cschneid> FreeFull: it seems like it's handy as a tool to reach for, but maybe less so as a full-blown core abstraction?
18:54:55 <cschneid> ie, the *** and &&& combinators are pretty slick all by themselves, and the guy presenting at the last haskell meetup locally used them in a single function to make it nicer
18:56:29 * hackagebot ghc-time-alloc-prof 0.0.0 - Library for parsing GHC time and allocation profiling reports  http://hackage.haskell.org/package/ghc-time-alloc-prof-0.0.0 (MitsutoshiAoe)
18:57:32 <FreeFull> I know arrowised FRP exists
18:58:59 * geekosaur pokes his external brain, there was an arrow tutorial somewhere...
19:00:04 <srhb> cschneid: The only thing that makes them unnice is that they're not in the Prelude :/
19:00:10 <cschneid> also, what's the normal "I dont' care what you do" license in haskell libraries?
19:00:14 <cschneid> MIT / BSD / ... ?
19:00:15 <srhb> cschneid: I keep thinking "but is it really worth the import...?"
19:00:33 <geekosaur> ...
19:00:36 <cschneid> srhb: hah, good to keep in mind there. It is core haskell though right? Any given haskell impl should have arrows handy?
19:01:09 <enthropy> you also need a {-# LANGUAGE Arrows #-}
19:01:15 <geekosaur> oh heck. domain gone...
19:01:15 <enthropy> to keep sanity
19:01:16 <srhb> enthropy: wat
19:01:20 <srhb> :P
19:01:21 <cschneid> enthropy: assuming I use the -< thingies right
19:01:39 <enthropy> yes
19:01:46 <srhb> cschneid: I think BSD3 is the most common one
19:01:49 <enthropy> you don't write all your code point-free, right?
19:02:19 <cschneid> found an ekemett library that used bsd2, so going with it. Doesn't really matter, just wanted to stay "standard" for a tiny thing I'm writing
19:02:22 <FreeFull> Not unless I am working in a concatenative language
19:02:25 <nullcone> http://mnxmnkmnd.tumblr.com/post/24282883888/a-teeny-bit-of-category-theory Lisp, the gateway to functional programming
19:02:27 <FreeFull> And even then, no
19:02:30 <geekosaur> looks like someone pastebin-ed it though. http://lpaste.net/94914
19:03:10 <srhb> I've  not yet had use for arrows, really.
19:03:13 <cschneid> geekosaur: amazing, thanks a ton. (clint as well, I'll read through that). A few tutorials is typically enough to triangulate something into my head.
19:03:18 <srhb> (&&&) is just stupidly useful so often.
19:03:23 <cschneid> srhb: mostly I want to know what they're about and the kind of things they solve.
19:03:30 <srhb> cschneid: Yeah. :)
19:03:38 <srhb> I didn't mean to imply it's a bad endeavour.
19:03:42 <cschneid> even if the answer is "rarely the problem you have." :)
19:03:54 <srhb> cschneid: Aye, that's the feeling I have. But dive in anyway, it's fun.
19:04:04 <srhb> Slightly traumatizing, as with the rest of Haskell, but fun!
19:04:21 <identity> Is it safe to assume that a Complex Double is just about as efficient as (Double, Double)?
19:04:28 <srhb> identity: Yes.
19:04:31 <srhb> fsvo efficient.
19:05:07 <srhb> identity: data Complex a = !a :+ !a
19:05:18 <identity> srhb: ah.
19:05:21 <identity> very well
19:06:04 <srhb> identity: So the only danger in thinking is the extra strictness I guess.
19:06:17 <identity> I don't think that's an issue here at all
19:06:26 <srhb> No, me neither. The converse would be troubling
19:06:32 <srhb> 1 :+ undefined <_<
19:07:55 <cswords_> \/wc
19:09:00 <FreeFull> > 1 :+ fix const
19:09:01 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = b0 -> a0
19:09:01 <lambdabot>  Expected t...
19:09:08 <FreeFull> > 1 :+ fix (const id)
19:09:10 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
19:09:10 <lambdabot>    arising from a use ...
19:09:39 <FreeFull> Oh, that's wrong
19:09:52 <FreeFull> I wanted fix id
19:09:55 <FreeFull> > 1 :+ fix id
19:10:02 <lambdabot>   mueval-core: Time limit exceeded
19:10:15 <frx> I am curious what are legit uses of unsafeCoerce in user code? any examples?
19:10:42 <FreeFull> Probably writing something that otherwise would be slower
19:10:45 <enthropy> > 1 :+ undefined :: Complex Double
19:10:47 <lambdabot>   *Exception: Prelude.undefined
19:11:37 <enthropy> http://stackoverflow.com/questions/19072648/gfoldl-data-data-data-instance-for-hlists-without-unsafecoerce
19:11:40 <srhb> > realPart (1 :+ undefined) -- this is what I think is good about it.
19:11:41 <lambdabot>   *Exception: Prelude.undefined
19:12:44 <enthropy> probably the interesting things you do with complex numbers are not going to let you get away with one of the parts being undefined
19:12:52 <srhb> Indeed.
19:13:30 <identity> i'm just drawing some mandelbrot sets, and I'm trying to determine where to optimize
19:13:49 <srhb> identity: Not there, for sure. :)
19:13:53 <enthropy> frx: also http://www.haskell.org/haskellwiki/SYB#fmap might be "legitimate"
19:14:06 <frx> thanks
19:14:07 <enthropy> which is the same trick again
19:14:29 <enthropy> basically "I can't convince the type system but I'm sure it's going to be ok"
19:14:58 <enthropy> also the docs on unsafecoerce list the conditions where it's ok
19:14:59 <srhb> Aren't we getting safe coerces any moment?
19:15:29 <enthropy> srhb: yes. But I don't think they address those two examples of mine
19:15:52 <srhb> No, they probably can't.
19:19:25 <srhb> Speaking of upcoming things, where does making Applicative a superclass of Monad actually break code?
19:20:12 <enthropy> it breaks code that has a Monad instance but no Applicative instance
19:20:18 <enthropy> for a given type
19:20:18 <gfredericks> so setting OverloadedStrings at the top of the file doesn't effect my `cabal repl`
19:20:39 <srhb> enthropy: Oh duh, of course. :-)
19:21:01 <enthropy> if you set the extensions in your .cabal file (default-extensions: OverloadedStrings) maybe it'll set it for ghci too
19:21:22 <enthropy> gfredericks: otherwise you can just :set -XOverloadedStrings
19:21:40 <gfredericks> yeah the :set is what I'm trying to avoid
19:22:40 <gfredericks> enthropy: that did it, thanks
19:28:46 <gfredericks> I apparently don't understand how to write something recursively
19:29:00 <gfredericks> I'm just trying to write a function that takes a list and returns true if they're all equal
19:29:36 <enthropy> do it without recursion
19:29:59 <enthropy> @type all (uncurry (==)) . (zip `ap` drop 1)
19:30:00 <lambdabot> Eq b => [b] -> Bool
19:30:35 <gfredericks> ap
19:30:39 <gfredericks> @type ap
19:30:40 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:31:13 <enthropy> @quote aztec
19:31:13 <lambdabot> alpounet says: map succ/pred is a scandinavian name generator or what? ... well, scandinavian and aztec
19:34:27 <gfredericks> enthropy: where does ap come from? ghc can't find it
19:34:54 <enthropy> Control.Monad
19:35:20 <enthropy> and if you have an ancient ghc you also need to import Control.Monad.Instances
19:36:35 * hackagebot direct-sqlite 2.3.8 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.8 (IreneKnapp)
19:37:15 <gfredericks> okay apparently it wasn't my recursion; maybe it's my dubious support of Eq
19:38:45 <gfredericks> that would have to be it
19:38:58 <srhb> gfredericks: Whatcha doing?
19:39:23 <srhb> Writing funky Eq-instances sounds scary. :-)
19:39:33 <gfredericks> well I had "written" it
19:39:48 <gfredericks> meaning I typed "instance Eq Foo" and left it at that
19:40:03 <gfredericks> srhb: a lisp interpreter
19:40:09 <srhb> That should be fine?
19:40:39 <solrize> is there some notion of sets (i.e. small sets of constants) as types?  like     File "foo"  :: [Readable,Writeable,Executable]
19:41:09 <srhb> Or actually it should say deriving somewhere, shouldn't it
19:41:50 <gfredericks> srhb: I don't think the derivation is trivial in this case
19:42:09 <gfredericks> there's probably a better way to do this
19:42:15 <lpaste> khyperia pasted “Strange GHCI error” at http://lpaste.net/95476
19:42:23 <khyperia> Can someone look at that, please?
19:43:09 <chrisdone> http://ircbrowse.net/calendar/haskell
19:44:46 <srhb> solrize: Excellent question. Sounds like you'd need dependent types to make use of them though
19:45:13 <enthropy> people already can/do such things
19:45:35 <enthropy>  x :: (MonadReader Foo m, MonadWriter Bar m) => m ()
19:46:11 <enthropy> the order that you write (or infer) constraints doesn't matter
19:47:36 <srhb> enthropy: I don't follow. You'd have seperate classes for WriteableFile, ReadableFile, ExecuteableFile?
19:48:24 <enthropy> yes you could do it that way
19:48:36 <chrisdone> you can also implement a set member ship class
19:49:20 <enthropy> you can't really manipulate things that are to the left of the => as you can things to the right of it
19:49:29 <PudgePacket> Hello, I'm writing a small text game in Haskell to familiarise myself with the language, i've completed most of "Learn you a Haskell" and have begun planning my game. It seems if I want to structure it securely I should create my own types in game, but creating types for everything and interactions feels like OOP all over, am I looking at it the wrong way ?
19:49:56 <srhb> PudgePacket: I don't understand why you that it's like OOP all over.
19:50:11 <srhb> PudgePacket: It's hard to say if you're looking at it the wrong way, try writing something concrete first. :)
19:50:44 <solrize> chrisdone hmm you mean with an associated type?    so if the type had constraint Readable then you'd get a read type that belonged to a class the read function could use, otherwise you'd get an error type
19:50:49 <carter> data types are awesome
19:50:52 <carter> create many :)
19:51:11 <Polarina> And if you feel lost, coercion is your friend.
19:51:49 <Narvius> I just can't help it but marvel at how I can write three concise lines of code perform three semi-complicated checks without sacrificing readability.
19:51:58 <PudgePacket> srhb, It just feels very similar, instead of making a class, i'm making a type then providing it interfaces with my other types, having a little type hierarchy to hold the data.
19:52:17 <PudgePacket> srhb, I'll admit I haven't done much in it yet, my opinion is probably wrong :)
19:52:29 <srhb> PudgePacket: I think the feeling is too vague to say anything sensible about, really.
19:52:46 <Narvius> The Maybe monad is such a simple tool, but how powerful it is. :D
19:52:55 <srhb> PudgePacket: There's very little boilerplate in Haskell, I feel, and when you add data types for your program, you're usually doing it to make yourself more sane, not less.
19:53:01 <srhb> PudgePacket: Adding safety along the way :)
19:53:11 <srhb> Narvius: Yes, it is fantastic.
19:53:30 <PudgePacket> srhb, i'll stop procrastinating and have a crack then
19:53:32 <chrisdone> solrize: yeah, the `has' package is an example of this. except you don't need the storage part, you just need the type restriction part
19:53:39 <srhb> PudgePacket: That's the spirit. :-)
19:54:01 <chrisdone> solrize: e.g. foo :: (Has X r,Has Y r) => r -> …
19:54:17 <srhb> PudgePacket: ("How do I model a game map without representing it in my program?" - that's what your question felt like to me :P)
19:54:17 <solrize> hmm i'll look for that
19:54:32 <chrisdone> https://github.com/nonowarn/has/blob/master/examples/Announce04.lhs
19:56:33 <PudgePacket> srhb, something along those lines. The way functional programming sounded to me is that instead of types and objects/classes I just pass around and operate on basic types like lists and strings
19:56:43 <chrisdone> edwardk_ also has an exceptions style of writing e.g. (Has IOException e,Has Whatever e,MonadThrow m e) => m …
19:56:55 <solrize> chrisdone thanks, this is neat
19:56:58 <srhb> PudgePacket: It's more like "I can now pass my complex something around without going crazy"
19:57:01 <enthropy> @hackage explicit-exception
19:57:01 <lambdabot> http://hackage.haskell.org/package/explicit-exception
19:57:02 <chrisdone> welcome =)
19:57:26 <enthropy> what's the edwardk version of that library?
19:57:50 <PudgePacket> srhb, I guess it's just hard for me to see the practical difference between an object and a haskell data type :P
19:57:54 <srhb> PudgePacket: My first game in Haskell - a snake clone - had a main loop that looked like move . changedirection . eatcheese . die $ gameState
19:57:59 <srhb> PudgePacket: Right, that will come. :)
19:58:06 <osa1> what does that mean " the following files would be used as linker inputs, but linking is not being done:" ?
19:58:53 <chrisdone> enthropy: well it was this http://hackage.haskell.org/package/mongoDB-0.9.5/docs/Control-Monad-Throw.html
19:58:53 <chrisdone> enthropy: but with an additional "Has" sort of constraint for specifying detailed exception types
19:59:11 <chrisdone> dunno if it's in a library
19:59:12 <enthropy> the reason such an approach isn't common is because I think people don't like to have your types get as large as your original code
19:59:40 <chrisdone> thanks to constraint extensions they don't have to be
20:00:15 <enthropy> eh, you still have to write out   type I'mHidingSomething v1 v2 v3 = (Has A v1, ... )
20:00:31 <chrisdone> but yeah, our interface with the compiler is medieval so we like short types
20:00:48 <enthropy> my biggest issue with constraint kinds is that you can't hide type variables
20:00:58 <enthropy> so you have to use type families for stuff
20:01:34 <enthropy> hmm, or maybe you can do    type T a = forall b. (C1 a b, C2 b)
20:03:18 <chrisdone> e.g. type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
20:04:17 <srhb> PudgePacket: I messaged you privately and I'm not sure it go through to the web client
20:04:21 <srhb> got*
20:04:28 <chrisdone> please ban rapeseed
20:05:01 <enthropy> chrisdone: oh the problem is when you start trying to write stuff like  [Lens a b c d]
20:05:14 <enthropy> which needs -XImpredicativeTypes or something like that
20:05:15 <chrisdone> enthropy: impredicativity?
20:05:47 <enthropy> right. you might be happy with a  [Lens f a b c d] instead
20:05:58 <chrisdone> rapeseed just spammed me in PM with some racist stuff that comes straighht out of an American History X script
20:06:13 <enthropy> same here
20:06:18 <srhb> same
20:06:27 <srhb> @ops
20:06:27 <lambdabot> Maybe you meant: pl oeis docs
20:06:30 <srhb> @op
20:06:30 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
20:06:31 <srhb> ..
20:06:38 <srhb> What is it D:
20:06:39 <enthropy> @where ops
20:06:39 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
20:06:39 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
20:06:41 <srhb> Thanks.
20:06:44 <enthropy> so many ops
20:06:56 <chrisdone> so many ops, all asleep at the same time
20:07:43 --- mode: ChanServ set +o dolio
20:09:54 --- mode: dolio set +b *!~rapeseed@*
20:09:58 --- kick: rapeseed was kicked by dolio (rapeseed)
20:10:18 --- mode: ChanServ set -o dolio
20:12:59 <chrisdone> dolio: cheers
20:13:49 <dolio> Jus' doin' mah job.
20:14:00 <djahandarie> Hahahaha
20:15:38 <pharaun> thanks dolio
20:24:25 <solrize> the has lib was written 4 years ago? i didn't realize type families and Lens existed then
20:26:55 <geekosaur> lens was around but was, er, simpler :) type families have been kicking around for a while as well, but again in a simpler form than the current
20:30:00 <solrize> ok :)
20:30:02 <johntrom_> > 42*34*89-1
20:30:03 <lambdabot>   127091
20:31:29 <srhb> geekosaur: "simpler" :-)
20:31:48 <johntrom_> > 34*47-1
20:31:49 <lambdabot>   1597
20:31:55 <enthropy> solrize: HList is almost 10 years old
20:33:10 <Zearen> Argh, having a cabal test target automatically import all the depencies for the modules under test would be great :/
20:33:22 <solrize> entrhopy yeah i never really understood it....  is there a newer way to do it now?  like with the current Lens?
20:42:46 <slack1256> what does hlist buy me?
20:54:00 <jmcarthur> slack1256: not much
20:54:18 <enthropy> solrize: the ideas are pretty much the same, code is different
20:54:25 <jmcarthur> slack1256: it's essentially just a set of combinators for nested tuples
20:56:19 <enthropy> there's a bit more than that
20:56:29 <enthropy> unless you're using a very liberal definition of combinator
20:57:42 <elliott> geekosaur: lens itself wasn't around four years ago :)
20:57:45 <elliott> but lenses were I guess
20:57:53 <slack1256> Mmm, nested tuples and heterogeneous list makes me think in (a,(b,(c,(...)))) as a list
20:58:05 <slack1256> those are used in type families right? a mean at least as an example
20:58:21 <unbirthday> hello, can someone help me with SDL-image, I keep getting the same error in almost everything (my own code and from hackage). I get "Couldn't match expected type `SurfaceStruct'" when using loadTyped or load. I tried an older version of SDL, but it wouldn't compile :/
20:59:34 <unbirthday> I checked the sources, and load/loadType in the newer SDL-image uses IO Surface, instead of just Surface ~ what can I do?
21:00:03 <unbirthday> sorry, I mean it doesn't use IO Surface
21:09:11 <chrisirc> There seems to be an issue with Inf-Haskell mode in Emacs, in that long lines lead to "lexical error at character '\EOT'"
21:09:23 <chrisirc> Can't find anything useful on google.
21:09:52 <chrisirc> (The only hit is the IRC log of this channel :), where fasta asks for the same issue.)
21:13:14 <chrisirc> Hm, different search terms led me to this  http://projects.haskell.org/pipermail/haskeline/2009-May/000028.html
21:13:53 <Cale> > '\4'
21:13:55 <lambdabot>   '\EOT'
21:14:15 <Cale> chrisirc: My guess is that for some reason emacs is sticking that character into your source file
21:14:22 <Cale> I don't really know why it would do that though.
21:15:03 <chrisirc> Cale, yes it does (it's not a source file, but repl input)
21:15:23 <Cale> Did you happen to hit ctrl-d?
21:15:38 <chrisirc> No. see https://ghc.haskell.org/trac/ghc/ticket/3256
21:15:46 <chrisirc> i.e. emacs does this after 500 characters.
21:15:53 <chrisirc> I'm going to ask in #emacs
21:16:31 <Cale> yeah, seems like a bug in emacs
21:16:45 <khyperia> Ahaha, I'm excited and I can't help but share, my computer just spat out "42" at me, and the program that did so was created by *my* compiler that I wrote today.
21:17:02 <Cale> congrats
21:18:26 <Zearen> Horray \o/
21:19:04 <solrize> yay  :)
21:19:08 <srhb> khyperia: Congrats :)
21:19:42 <solrize> data Nat = Z | S Nat                        type ThreeOrMore = forall (a :: Nat) S (S ( S a))
21:20:50 <slack1256> nice
21:24:25 <chrisirc> Ok, creating a shell wrapper around ghci that contains "cat | ghci" solves it for me.
21:24:45 <chrisirc> Well, maybe this will break other stuff, though.
21:26:16 <slack1256> why not "ghc -e 'print 4' "
21:35:27 <AshyIsMe> khyperia: haha awesome
21:36:21 <khyperia> Of course I just abused the program exit code, since I don't have methods implemented yet, lol
21:36:35 <khyperia> I'm about to have methods, though, in about 30 minutes
21:42:00 <unbirthday> can someone please help with my SDL problem. I can't seem to use functions in SDL-image, it uses IO Surface instead of just Surface. What can I do?
21:43:30 <pavonia> unbirthday: please provide more details of what you're trying to do
21:52:44 <dwcook> @type (>>=) -- unbirthday
21:52:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:53:08 <dwcook> unbirthday, IO Surface can be handed to (>>=), along with a pure function, to create a new IO action that makes use of that Surface.
21:53:36 <solrize> www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf    seems like a really good article
21:57:52 <joelteon> how should I generate a salt for a SHA1 hashed password?
21:57:56 <joelteon> "securely"
21:58:19 <solrize> joelton salts are usually public therefore "secure" means what?
21:58:27 <solrize> but anyway get random chars from /dev/urandom
21:59:12 <unbirthday> dwcook: come back please
21:59:14 <solrize> what is the application?
21:59:15 <solrize> you should avoid keyless hashes if you can help it
21:59:17 <joelteon> so newStdGen?
21:59:45 <solrize> i dunno if there's an instance for urandom... just read some bytes from it
21:59:57 <dwcook> unbirthday, state your problem concretely.
22:00:18 <dwcook> And speak in here, not through PM.
22:01:48 <dwcook> unbirthday, please give an lpaste. I won't respond to PMs about this.
22:02:19 <unbirthday> dwcook: lpaste?
22:02:23 <dwcook> See the topic.
22:03:09 <unbirthday> dwcook: you want me to paste here?
22:03:22 <Kron> unbirthday: there is a pastebin-like site called lpaste
22:03:26 <solrize> has anyone read martin-lof's book on type theory?  is it a good way to find out what dependent types actually are?
22:03:27 <Kron> http://lpaste.net/
22:03:35 <Kron> you can paste your code there!
22:03:44 <unbirthday> ah ok
22:03:50 <joelteon> ok
22:03:55 <joelteon> how should I read N bytes from /urandom then
22:04:20 <Kron> you can just read from it after opening it like a file, I think
22:04:31 <Kron> it's basically an infinite stream of random stuff
22:04:42 <joelteon> yeah, but I want to read a specific number of bytes
22:04:53 <joelteon> and I don't see how to do that
22:04:54 <Kron> (by opening it like a file I mean opening up a stream in a programming language, not opening it in your friendly neighbourhood text editor)
22:04:57 <unbirthday> dwcook: http://lpaste.net/7383758654018682880
22:05:02 <joelteon> yeah, i know.
22:05:08 <solrize> joelton:   just open the file and use hGetChar
22:05:09 <joelteon> i'm saying, how do I read N bytes from a handle in binary mode.
22:05:11 <Kron> you can open it in a given program and just read N bytes from the stream
22:05:21 <Kron> hGetCar of scanf or (read)
22:05:23 <joelteon> is there not a function for this?
22:05:26 <Kron> depends on your language
22:05:30 <joelteon> haskell
22:05:30 <Kron> ah
22:05:35 <Kron> I get hGetChar
22:05:38 <Kron> *I think
22:05:40 <dwcook> unbirthday, what's the specific issue?
22:05:51 <solrize> withBinaryFile "/dev/urandom" ReadMode $ bytes <- replicateM nbytes . hGetChar
22:05:57 <joelteon> replicateM
22:05:59 <joelteon> that makes sense
22:06:06 <solrize> withBinaryFile "/dev/urandom" ReadMode $  replicateM nbytes . hGetChar
22:06:12 <solrize> something like that
22:06:51 <solrize> you could use bytestrings and Data.Binary.Get if you need a lot of them
22:06:54 <unbirthday> dwcook: doesn't compile, gives an error stating, "Couldn't match expected type `SurfaceStruct'"
22:06:56 * hackagebot yesod-fay 0.4.0.7 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.4.0.7 (MichaelSnoyman)
22:07:15 <dwcook> unbirthday, what's the exact error message?
22:07:29 <Kron> I'm curious as to the error message as well
22:07:31 <dwcook> Go ahead and give an lpaste of that too.
22:07:47 <dwcook> Or add it to the same one.
22:07:48 <unbirthday> dwcook: animal-machine.com_tut.hs:13:21:
22:07:48 <unbirthday>     Couldn't match expected type `SurfaceStruct'
22:07:48 <unbirthday>                 with actual type `SDL-0.6.3:Graphics.UI.SDL.Types.SurfaceStruct'
22:07:48 <unbirthday>     Expected type: Surface
22:07:48 <unbirthday>       Actual type: SDL-0.6.3:Graphics.UI.SDL.Types.Surface
22:07:49 <unbirthday>     In the first argument of `blitSurface', namely `tileSurf'
22:07:51 <unbirthday>     In a stmt of a 'do' block: blitSurface tileSurf r mainSurf Nothing
22:08:18 <Kron> hmm
22:08:19 <dwcook> Well that's odd.
22:08:36 <dwcook> It seems to be using two different versions of the module.
22:08:44 <unbirthday> dwcook: sdl works otherwise, all functions in SDL work, it's just SDL-image
22:08:50 <unbirthday> dwcook: yes
22:08:54 <lispy> unbirthday: do you have a library and executable in the same cabal file?
22:09:07 <lispy> unbirthday: if so, do the directories they use overlap?
22:10:08 <unbirthday> dwcook: SDL is 0.6.5 and SDL-image is 0.6.1, tried downgrading SDL, but it wouldn't compile, tried upgrading SDL-image but 0.6.1 is newest
22:10:32 <unbirthday> lispy: not sure what you mean
22:11:24 <lispy> unbirthday: do you have executable and library sections in your cabal file?
22:11:29 <lispy> unbirthday: or just executable?
22:14:09 <unbirthday> lispy: still don't know what you mean
22:14:33 <unbirthday> how can i simply remove all SDL libraries and start again?
22:14:47 <lispy> ghc-pkg unregister
22:15:01 <unbirthday> already tried that one
22:15:16 <lispy> Can you show us your .cabal file?
22:16:00 <unbirthday> where is it?
22:17:37 <unbirthday> im just going to remove cabal and delete .cabal and start again
22:17:46 <lispy> unbirthday: it would be in the top level directory of your source code
22:18:00 <lispy> Are you invoking ghc directly?
22:18:07 <lispy> or typing 'cabal build'?
22:18:29 <unbirthday> sure, directly?
22:18:38 <unbirthday> ghc file.hs
22:18:40 <unbirthday> like that
22:18:52 <lispy> ah
22:19:39 <lispy> unbirthday: I wouldn't recommend doing that. cabal is the tool we normally use to build Haskell programs
22:20:10 <lispy> It's like a combination light weight build tool and light weight package manager
22:20:26 <unbirthday> it's an abomination, why does it not have remove/uninstall
22:21:04 <arkeet> because cabal isn't a package manager
22:21:04 <lispy> To remove/uninstall you use ghc-pkg
22:21:13 <arkeet> also, removing .cabal won't do a whole lot
22:21:13 <unbirthday> haskell is radically different from c, why on earth make it even more radically different from standard unix tools? grrrrrr
22:21:17 <arkeet> you need to look at .ghc
22:21:59 <arkeet> well
22:22:02 <lispy> unbirthday: Actually, these sorts of build tools are pretty common these days. Python and ruby do such things.
22:22:04 <arkeet> that may be the solution to the wrong problem.
22:22:06 <unbirthday> lispy: how do i build with cabal
22:22:22 <lispy> unbirthday: http://bob.ippoli.to/archives/2013/01/11/getting-started-with-haskell/
22:23:08 <arkeet> lispy: why does that page mention hugs?
22:23:10 <lispy> unbirthday: if you already have cabal installed, then you can use 'cabal init' to get started
22:23:17 <arkeet> :<
22:23:19 <etrepum> That still needs to be updated for cabal sandbox
22:23:36 <arkeet> I suppose that question should be for etrepum.
22:23:58 <etrepum> There is no mention of hugs
22:24:04 <arkeet> "Another implementation of note is Hugs, which is more for teaching than for production code."
22:24:40 <lispy> arkeet: I almost gave this link, but it seems even further out of date: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Structure_of_a_simple_project
22:25:07 <arkeet> a guide written in 2013 should not mention hugs. ;)
22:25:53 * Iceland_jack . o O ⸨ wonders why some people insist on Hugs so much ⸩
22:26:44 <etrepum> Nobody insisted on hugs
22:26:59 * hackagebot yesod 1.2.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.3 (MichaelSnoyman)
22:27:00 * hackagebot yesod-bin 1.2.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.4 (MichaelSnoyman)
22:27:02 * hackagebot yesod-core 1.2.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.5 (MichaelSnoyman)
22:27:05 * hackagebot yesod-form 1.3.4 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.4 (MichaelSnoyman)
22:27:07 * hackagebot yesod-static 1.2.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.1 (MichaelSnoyman)
22:27:10 <Iceland_jack> I've seen some tutorials that don't even mention ghc
22:27:36 <etrepum> I mentioned Hugs mostly because some (in print) books still use it
22:27:51 <arkeet> =(
22:31:34 <unbirthday> so i'm getting these same SDL problems with other stuff, such as raincat, where i do: cabal install raincat, it gives me a very similiar problem, where it complains about Surface and SurfaceStruct
22:31:56 <unbirthday> other sdl based stuff on hackage too
22:32:09 * hackagebot html-conduit 1.1.0.1 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.0.1 (MichaelSnoyman)
22:32:11 * hackagebot conduit 1.0.9 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.9 (MichaelSnoyman)
22:43:42 <lpaste> jrmithdobbs pasted “wtf” at http://lpaste.net/95477
22:44:10 <jrmithdobbs> anyone have any thoughts on that? so confused :(
22:44:59 <mzero> where is httpLbs defined?
22:45:10 <jrmithdobbs> http-conduit
22:45:16 <jrmithdobbs> Network.HTTP.Conduit
22:47:06 <jrmithdobbs> it's almost verbatim out of the example in it's haddock except i generate the url from somewhere instead of hardcoding a string :(
22:47:20 <jrmithdobbs> and disable ssl verification
22:48:32 <pavonia> unbirthday: Could you paste the output of "ghc-pkg describe SDL" and the same for SDL-image?
22:49:59 <solrize> chrisdoner or anyone else: do you know how Atom works?  basically it's a GADT for programs in a quirky imperative language, so that types of expressions in the embedded program are handled with type indexes in the gadt, so haskell's own typechecker makes sure the user program is well-typed.  then you run it through a pretty-printer-like thing that generates C code that you compile for the final target.  and it's cool but kind of messy, the abstrac
22:49:59 <solrize> tions leak, the stuff in the embedded program collides with haskell etc.
22:50:14 <solrize> and my question is whether it's normal and maybe easier to use agda instead of haskell for stuff like that
22:51:19 <jrmithdobbs> isn't that just how it goes, I have all this code to generate the info to make the request, and all this code to handle the json responses, but can't get the (seemingly should be) simplest part to work, the dumb http req =/
22:51:23 <jrmithdobbs> frustrating
22:52:45 <mzero> jrmithdobbs: no freakin' idea -- it is missing an instance that should be in one of those modules
22:53:04 <jrmithdobbs> mzero: ya i know, it's like i'm missing an include somewhere that it should be doing it's damned self
22:53:10 <jrmithdobbs> s/include/import/
22:53:22 <jrmithdobbs> ;p
22:53:31 <jrmithdobbs> thank you for confirming i'm not insane at least
22:54:07 <mzero> ah
22:54:09 <mzero> use withManager
22:54:47 <mzero> OR
22:55:05 <mzero> runResourceT $ httpLbs request myman
22:55:13 <unbirthday> yeeeeeeeeeeeeeeeeeeeees i've done it at last, it compiled
22:56:28 <unbirthday> i just unregistered every SDL-* and deleted every directory with SDL* in ~/.cabal and then re-cabal'd all the SDL stuff
22:56:58 <mzero> jrmithdobbs: you need to be in a MonadResource context which is something that will do deallocation on exiting the context... and IO isn't one on purpose
22:57:04 <jrmithdobbs> mzero: i can't use withManager because I need to override the ssl checking =/
22:57:45 <mzero> then    res <- runResourceT $ httpLbs request myman
22:58:08 <mzero> though, really, you should mimic the source code of withManager so that you get proper cleanup
22:58:51 <mzero> wait, what's wrong with using withManagerSettings?
22:59:42 <mzero> res <- withManagerSettings (def { managerCheckCerts = (\_ _ _ -> return CertificateUsageAccept) }) $ httpLbs request
23:03:32 <mzero> did that work, jrmithdobbs
23:03:47 <jrmithdobbs> no :(
23:04:02 <mzero> the withManagerSettings version didn't work?
23:06:32 <jrmithdobbs> no it didn't giving me:
23:06:34 <jrmithdobbs>     Couldn't match type `(->) (Request m'0)' with `IO'
23:06:34 <jrmithdobbs>     When using functional dependencies to combine
23:06:34 <jrmithdobbs>       MonadBaseControl ((->) r) ((->) r),
23:06:34 <jrmithdobbs>         arising from the dependency `m -> b'
23:06:36 <jrmithdobbs>         in the instance declaration in `monad-control-0.3.2.2:Control.Monad.Trans.Control'
23:08:49 <mzero> er, that looks like we droped an argument? perhaps you should update the paste with the current code and error?
23:10:07 <jrmithdobbs> ya doing so with more context
23:11:26 <jrmithdobbs> oh that one's just i've been staring at this too long and put a $ in the wrong place
23:11:29 <jrmithdobbs> i think
23:13:33 <jrmithdobbs> ya that got me to an auth error which is what i was expecting and I know how to fix that :)
23:14:13 <jrmithdobbs> am I just missing the "convert this Data.URI to a Network.HTTP.Conduit.Request" function or is that really missing?
23:15:10 <jrmithdobbs> because Data.URI can already hold the auth creds in the structure (doesn't show with Show though) and i'd think Request would just gobble that up
23:15:12 <mzero> no idea
23:15:38 <jrmithdobbs> but looks like i have to modify the req separately, meh
23:35:11 <shiona_> is there a way around cmdargs installation whining about possible stage-1 compiler?
23:35:25 <shiona_> something like install ghc though cabal?
23:41:47 <AshyIsMe> is there an unimport for ghci?
23:43:29 <Maxdamantus> if you imported it with `:m +..`, you can unimport it with `:m -..`
23:47:04 <dmj`> ':m' alone removes all imports
23:48:32 <AshyIsMe> ah cheers
