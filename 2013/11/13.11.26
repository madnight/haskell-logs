00:00:05 <jle`> i always want to separate function compositions with spaces
00:00:12 <jle`> but then people do that weird lense style like point.x
00:00:15 <scott_> I see it without spaces in lenses
00:00:34 <jle`> i guess i am referring specifically to not.p
00:00:42 <identity> Silverfalls: You could use pattern guards instead of if statements
00:00:45 <identity> or even case statements
00:00:55 <ion> I dislike using it without spaces, but feel free to do whatever suits you.
00:00:58 <identity> or you could try using the MultiWayIf extension for some better layout
00:01:05 <identity> (I'm with ion here)
00:01:50 <Silverfalls> identity: Yeah, I'll probably switch it to guards. It's the general structure I'm trying to change though, not the layout stuff.
00:02:02 <mm_freak> Silverfalls: if not based on a lot of different cases i generally try to keep functions short and straightforward
00:02:44 <identity> I'd probably go for guards and case expressions. I'd start with that, anyway
00:02:52 <mm_freak> Silverfalls: also what often makes code unnecessarily hard to read is too long identifiers for variables
00:03:06 <jle`> yeah i don't know why but i also feel really weird using explicit if/then statements.
00:03:09 <identity> Silverfalls: It *could* look like a fold, what you got going on there
00:03:11 <identity> though I'm not sure
00:03:17 <jle`> probably because the if/then syntax in haskell is so awkward compared to the rest of the language syntax
00:03:22 <identity> jle`: They're hideous
00:03:30 <cizra> *phew* Ready, the program works. Now the hard part begins: marketing. Guys and gals, I wrote a C library for restarting the program (it execls the program itself, preserving command-line arguments, and most importantly, some state) (meant to use in long-running things which you still want to update, like game servers). Now I wrote Haskell FFI code around it -- you can pass an arbitrary Storable to be retained over reboot. How do I package it so that it'd 
00:03:31 <mm_freak> f theStuffIAmManipulating = map (theStuffIAmManipulating*) [1 .. theStuffIAmManipulating]
00:03:32 <identity> jle`: If you haven't already, look at MultiWayIf
00:03:36 <mm_freak> vs.
00:03:40 <mm_freak> f x = map (x*) [1 .. x]
00:03:43 <Silverfalls> The general idea is this: I have two lists of entities: a list of agents and a list of bullets, and I want to remove any that are in collision (within a certain range of) eachother. And, I want to add additional bullets at the begining of the list at the point of collision if there is a collision.
00:03:46 <jle`> identity: is there a @where for that
00:04:03 <identity> jle`: Don't think so, but if you google MultiWayIf you should get some docs
00:04:15 <scott_> cizra: Your message was cut off at "How do I package it so that it'd"
00:04:39 <Silverfalls> Most of my other functions use guards/case statements, I just havn't gotten around to changing this one. I wrote it at 5ish in the morning, which is probably the cause of the nested if/elses
00:04:39 <cizra> *phew* Ready, the program works. Now the hard part begins: marketing. Guys and gals, I wrote a C library for restarting the program (it execls the program itself, preserving command-line arguments, and most importantly, some state) (meant to use in long-How do I package it so that it'd be easily accessible from Haskell Cabal? Do I bundle the C lib with Haskell? Do I count on the user to install it manually before?
00:04:48 <jle`> identity: thanks, found it
00:04:51 <cizra> Oh damn, now it's not cut off enough.
00:05:19 <Silverfalls> mm_freak: You think? I've always thought informative identifier names were cleaner than short cryptic ones.
00:05:51 <mm_freak> Silverfalls: well, often the nature/semantics is a lot less important than the operation you're applying to it
00:06:03 <mm_freak> compare the two examples i wrote
00:06:10 <mm_freak> f theStuffIAmManipulating = map (theStuffIAmManipulating*) [1 .. theStuffIAmManipulating]
00:06:13 <mm_freak> f x = map (x*) [1 .. x]
00:06:18 <mm_freak> which one is clearer?
00:06:55 <scott_> cizra: I don't know much about cabal, but I think it varies. hslua for example seems to bundle and build the Lua source with the package: http://hackage.haskell.org/package/hslua-0.3.9/hslua.cabal
00:07:10 <scott_> cizra: Actually it appears they make it an option to use the system Lua alternatively
00:07:17 <cizra> scott_: Thanks! I'll have a look at how they do it.
00:07:30 <Silverfalls> Fair enough, but that's a short utility function where semantics are easy enough to understand at a glance or in a quick comment
00:07:41 <identity> Silverfalls: At any rate, for actual suggestions -- as I said before, it looks like your function is essentially a left fold
00:07:56 <mm_freak> Silverfalls: even in your case the types are descriptive enough
00:08:20 <mm_freak> myAgent :: Agent, myBullet :: Bullet
00:08:24 <mm_freak> a :: Agent, b :: Bullet
00:08:38 <mm_freak> i'd use the latter
00:08:39 <identity> something like foldl' prependBulletHelper ([], agents, score) bullets
00:09:04 * cizra finds type inference utterly cool. Namely the pointer casts -- "just cast it to whatever is necessary". Also, I'll shut my random rambling off now. Have a nice quiet day.
00:09:27 <Silverfalls> mm_freak: Good point, thanks. What do you think about descriptive function names vs. short ones?
00:09:34 <identity> cizra: I agree. You can do some pretty magical things with the type system
00:09:53 <scott_> Like printf
00:09:58 <Silverfalls> identity: That helps, thank you. I had a feeling that a fold could work from what I'd heard of them, but I've never actually learned them (I'm still pretty new)
00:10:05 <identity> Silverfalls: Oh, I see
00:10:13 <mm_freak> Silverfalls: use the shortest one that isn't cryptic…  in particular try to unify your algorithm with a known structure
00:10:19 <jle`> it's all the safety of explicit type systems with all the expressiveness/productivity of dynamic type systems
00:10:29 <mm_freak> for example your example is probably a pair of concatMaps
00:10:40 <identity> Silverfalls: Anyway, it looks like a fold because you're basically processing a list and returning some kind of an accumulator. You're 'folding' the list in a way
00:10:44 <Silverfalls> mm_freak: I have to show you the game I'm making at some point. I recently ported it over to GTK/Cario from gloss, and it's becoming pretty cool.
00:11:53 <Silverfalls> mm_freak: I'm Lykos by the way, I just changed my name because it was taken. You've helped me a few time before. What exactly do you mean "try to unify your algorithm with a known structure"? You mean try to write it so the algorithm fits a certain kind of pre-existing interface?
00:12:13 <identity> Silverfalls: I think that's what he means, like with the fold
00:12:19 <mm_freak> Silverfalls: ah =)
00:12:35 <mm_freak> Silverfalls: yes, either identity's fold or my concatMap
00:12:36 <jle`> Silverfalls: by structure he probably means design pattern
00:12:47 <jle`> that can be abstracted away using h-o- functions
00:12:48 <mm_freak> well, yeah, the buzzword is "design pattern" =)
00:13:16 <jle`> you just learn to recognize things that 'look' like folds from certain angles
00:13:23 <jle`> things that 'look' like concat maps
00:13:30 <Silverfalls> heh. I'm taking a class in design pattern now, although it's mainly about object-oriented designs. I've thought it would be really interesting to try to "port" the book over to a functional language.
00:13:32 <jle`> and then when you spot them, refactor
00:14:02 <jle`> refactoring into a known h-o function/design factor means your code is immediately understandable by someone reading it.  or at least, the 'structure' of your code.
00:14:18 <jle`> it will take people a few minutes to understand a map written using explicit recursion
00:14:28 <jle`> but if you see map f xs then you know what's going on
00:14:34 <tdammers> the nice thing about languages like Haskell is that you can make almost any "design pattern" abstraction explicit
00:14:41 <tdammers> encode it in some sort of language construct
00:14:49 <mm_freak> Silverfalls: what jle` said…  at some point you will be able to see certain fold/traversal/unfold patterns
00:15:16 <mm_freak> then most of your functions will look something like this:  fold f z . map g . …
00:15:22 <Silverfalls> mm_freak: Okay. I definitely had an intuition that a fold would work here, but that's from the little I know of folds.
00:15:22 <mm_freak> foldr rather
00:15:35 <Silverfalls> did you check out the code I posted a minute ago?
00:15:38 <jle`> it's really an art though that only comes through practice.  there's a certain experience/skill necessary to look at something and say 'oh hey...this looks like a fold. this looks like a concat map/traversal/state monad'
00:15:40 <kryft> tdammers: Yes, of the languages I've used so far, haskell has definitely been the best for eliminating any kind of repetition
00:16:14 <jle`> so don't worry about not being able to see it right away at first
00:16:41 <Silverfalls> On a different note, I've been learning multithreading (for the gtk game) in haskell and it's beautiful, very intuitive.
00:16:43 <jle`> i took an FP course that spent two weeks basically refactoring function after function into folds
00:16:57 <mm_freak> Silverfalls: yeah…  you have a bunch of agents and a bunch of bullets…  the result is a list of remaining unchanged agents, a list of remaining unchanged bullets and a list of new bullets
00:17:01 <mm_freak> correct?
00:17:01 <Silverfalls> Unfortunately I just havn't had enough time to focus on programing since I'm in school right now.
00:17:18 <Silverfalls> mm_freak: Correct.
00:17:28 <mm_freak> Silverfalls: that's a fold
00:17:51 <mm_freak> alternatively it's two concatMaps
00:17:52 <Silverfalls> Also, a score variable that is incremented occasionally.
00:18:16 <Silverfalls> so, how could I transfer this over to a fold? Or, could you give me a super quick run down on folds?
00:18:30 <mm_freak> for things like incrementing score i don't think of changing an x, but rather of returning a dx
00:18:34 <mm_freak> do you see what i mean?
00:18:35 <Silverfalls> I get the general fold (+) [1..5]
00:18:57 <jle`> not sure how familiar you are with folds. but they can be thought of as 'collapsing' a list into one value/state/tuple.  or, in 'imperative' terms, walking trhough a list and updating a state/value at every step, and returning the final state/value
00:18:57 <Silverfalls> yes, I do. that's a really good way to think about it
00:19:09 <mm_freak> Silverfalls: state approach:  f x y score = (…, score')
00:19:22 <mm_freak> Silverfalls: my writer approach:  f x y = (…, dscore)
00:19:32 <mm_freak> where score' = score + 1 and dscore = 1
00:20:13 <jle`> yeah when you realize that your accumulator can be a tuple containing arbitrary data structures/combinations of data structures, it opens things up a bit.
00:20:14 <Silverfalls> What do you mean "writer" approach? I definitely prefer the dx idea, much more fluent. I'm still trying to really get into a functional frame of mind.
00:20:15 <mm_freak> Silverfalls: first try concatMap…  it's easier to wrap your head around
00:20:23 <mm_freak> Silverfalls: note how concatMap is a generalization of 'filter'
00:20:26 <Silverfalls> Haskell's inspired me to add a math major to my CS one, by the way.
00:20:36 <mm_freak> it allows you to leave elements out /and/ put new elements in
00:21:00 <mm_freak> > concatMap (\x -> if x == 'a' then "aaa" else [x]) "haha"
00:21:02 <lambdabot>   "haaahaaa"
00:21:27 <identity> 7win 3
00:21:29 <identity> eh,
00:21:30 <mm_freak> now instead of Char you can have Agent or Bullet =)
00:21:48 <jle`> things like foldl (+) [1..5] sort of constrain your thinking to the idea that accumulators have to be the same type as what you are folding over
00:22:04 <mm_freak> Silverfalls: it's really the monoid approach…  and there is a monad for it:  Writer
00:22:12 <mm_freak> that's why i say "writer approach" =)
00:22:25 <tdammers> :t foldl
00:22:26 <lambdabot> (a -> b -> a) -> a -> [b] -> a
00:22:38 <tdammers> a doesn't have to be the same type as b ;)
00:22:41 <mm_freak> deltas to some state usually form a monoid
00:22:59 <mm_freak> (probably always)
00:23:17 <mm_freak> yeah, always:  you can always represent a sequence of deltas as a list of deltas =)
00:23:52 <Silverfalls> When you say a concat map allows you to leave elements out, I assume you mean treating it like a filter as such?
00:24:18 <Silverfalls> concatMap (\x -> if x == 'a' then [] else [x]) "haha"
00:24:32 <Silverfalls> > concatMap (\x -> if x == 'a' then [] else [x]) "haha"
00:24:33 <lambdabot>   "hh"
00:24:59 <jle`> hey, aren't any of the Num classes instances of Monoid
00:25:00 <BoR0> > filter (/= 'a') "haha"
00:25:01 <lambdabot>   "hh"
00:25:03 <jle`> what gives.
00:25:19 <scott_> jle`: There's Sum and Product monoids
00:25:20 <mm_freak> jle`: which monoid would you like?  (+) or (*)?
00:25:28 <jle`> ah that makes sense.
00:25:31 <jle`> mm_freak:
00:25:41 <arkeet> > concatMap (\x -> guard (x /= 'a') >> [x]) "haha"
00:25:42 <lambdabot>   "hh"
00:26:11 <arkeet> > "haha" >>= \x -> guard (x /= 'a') >> return x
00:26:12 <lambdabot>   "hh"
00:26:14 <ion> > concatMap (\x -> x <$ guard (x /= 'a')) "haha"
00:26:15 <lambdabot>   "hh"
00:26:19 <mm_freak> > concatMap (join replicate) [1,2,3,4]
00:26:19 <lambdabot>   [1,2,2,3,3,3,4,4,4,4]
00:26:22 <arkeet> > do { x <- "haha"; guard (x /= a); return x }
00:26:23 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:26:23 <lambdabot>              with actual type...
00:26:23 <Silverfalls> I see how concat map could work for mine, but it would put the new bullets in the middle of the list instead of at the end. It would work in my case, but I don't want to be limited to that.
00:26:32 <arkeet> > do { x <- "haha"; guard (x /= 'a'); return x }
00:26:33 <lambdabot>   "hh"
00:26:45 <mm_freak> Silverfalls: huh?  lists are homogenous in haskell
00:26:48 <arkeet> > [x | x <- "haha", x /= 'a']
00:26:49 <lambdabot>   "hh"
00:26:51 <mm_freak> you can't mix agents and bullets
00:27:11 <Silverfalls> I know, I didn't mean that exactly.
00:27:13 <Maxdamantus> @@ @do . @undo [x | x <- "haha", x /= 'a']
00:27:13 <lambdabot>  <unknown>.hs: 1: 1:Parse error: .
00:27:16 <mm_freak> Silverfalls: oh, i understand
00:27:22 <arkeet> @@ @do @undo [x | x <- "haha", x /= 'a']
00:27:22 <lambdabot>  concatMap (\ x -> if x /= 'a' then [x] else []) "haha"
00:27:24 <Silverfalls> Although I have been looking into existential types a bit.,
00:27:24 <mm_freak> Silverfalls: is that a problem?
00:27:36 <mm_freak> Silverfalls: no, don't…  existentials don't exist =)
00:27:43 <fdsa> @pl \x -> f x >> g x
00:27:43 <lambdabot> liftM2 (>>) f g
00:28:03 <arkeet> :t liftA2 (>>)
00:28:04 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (m b) -> f (m b)
00:28:18 <jle`> if only there was a less ugly liftM2
00:28:24 <arkeet> what's wrong with it?
00:28:30 <mm_freak> Silverfalls: if you need new bullets at the end, then think consider state/writer again
00:28:33 <jle`> maybe i'm just not used to it
00:28:40 <jle`> it feels hack-ish
00:28:43 <arkeet> I think liftA2 is fine.
00:28:43 <mm_freak> Silverfalls: just read "newBullets" as "dbullets" =)
00:28:46 <Silverfalls> mm_freak: Oh? They seem orderly enough to me, why are they bad? <-- off topic question
00:29:05 <Silverfalls> I'd prefer the new Bullets at the beginning.
00:29:08 <mm_freak> Silverfalls: because they will probably just make your code more complicated without gain
00:29:25 <mm_freak> Silverfalls: you can put dbullets where you want
00:29:38 <arkeet> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
00:29:57 <ion> fix (\exists -> exists exists)
00:29:58 <fdsa> liftM2 is like this magic function.
00:30:21 <Silverfalls> Can you explain left/right folds real quick?
00:30:29 <Silverfalls> Then I'm going to rewrite the code with it.
00:30:56 <mm_freak> Silverfalls: (agents', bullets', dbullets, dscore) = collisionUpdate agents bullets
00:30:58 <jle`> Silverfalls: you can think of folds as carrying some 'state', and then updating it with every element of your list
00:31:09 <jle`> :t foldl
00:31:10 <lambdabot> (a -> b -> a) -> a -> [b] -> a
00:31:12 <ion> jle: left folds
00:31:18 <mm_freak> Silverfalls: where you would probably have written "newBullets" instead of "dbullets" =)
00:31:26 <jle`> @src foldl
00:31:26 <lambdabot> foldl f z []     = z
00:31:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:31:43 <jle`> Silverfalls: do you mean the difference between left and right folds?
00:31:56 <Silverfalls> mm_freak: Where agents' and bullets' are the lists with the collisions filtered out, and dbullets are the new bullets?
00:32:03 <mm_freak> yeah
00:32:22 <mm_freak> Silverfalls: notice how the score argument is gone
00:32:27 <Silverfalls> dbullets seems a slighty strange notation, as it's only have the change from the intial bullets list
00:32:48 <Silverfalls> Yeah, I see, I definitely like that way of doing it.
00:32:51 <mm_freak> Silverfalls: you can apply your own convention
00:33:01 <mm_freak> Silverfalls: i read the prefix 'd' as 'delta'
00:33:05 <Silverfalls> I know
00:33:15 <Silverfalls> It's not the delta though, exactly
00:33:22 <Silverfalls> it's the delta after the filtered list
00:33:40 <mm_freak> it's still a delta
00:33:54 <Silverfalls> dbullets would be some sort of partially applied function that would filter over intial bullets and return the end-result list, in my mind
00:34:16 <mm_freak> yeah, and that's a way to do it =)
00:34:28 <mm_freak> and it again forms a monoid under composition and identity
00:34:48 <Silverfalls> I guess it's just my assocative way of thinking that x+dx should always be the final x
00:35:02 <Silverfalls> as opposed to x-(something)+dx
00:36:24 <mm_freak> well, sometimes it's just more practical to have two steps…  also if you return a new list of bullets, then it's quite obvious that you apply the delta to that one
00:36:28 <Silverfalls> I love the idea of dscore, but dbullets just seems slighty off kilter to me, although it's a pretty pedantic distinction.
00:37:21 <Silverfalls> I could partition the list into collisions/non-colisions, then filter the collisions into new bullets.
00:37:49 <Silverfalls> But I'm trying to be efficent, and it seems like it would be a more expensive operation?
00:37:53 <mm_freak> yeah, that sounds very reasonable =)
00:38:04 <mm_freak> no, it wouldn't
00:38:20 <Silverfalls> but moreso than a strict fold, maybe?
00:38:42 <mm_freak> why a strict fold?
00:39:14 <Silverfalls> well less memory usage, and I got the impression that laziness was a tiny computatinal overhead?
00:39:21 <Silverfalls> more passing around thunks and such?
00:39:37 <mm_freak> a strict fold will use a lot more memory in this case =)
00:40:01 <Silverfalls> Why?
00:40:02 <mm_freak> and it will be slower
00:40:19 <Silverfalls> Double-why? Pardon the questions, this is just very interesting.
00:40:36 <mm_freak> remember that the result is not a number or some other small strict data
00:40:46 <mm_freak> it's a bunch of lists and a score delta
00:40:53 <Silverfalls> Ah, I see.
00:41:35 <maimsige> When do we use let ? Only in REPL?
00:41:55 <mm_freak> maimsige: all the time
00:42:05 <scott_> In do blocks and let ... in expressions
00:42:21 <BoR0> what is REPL? the interactive mode?
00:42:30 <maimsige> Yes, interactive mode
00:42:38 <scott_> read-eval-print-loop
00:42:56 <Silverfalls> maimsige: It's used for defining a variable name with a certain scope I believe. Let in REPL adds it to the scope of the loop.
00:43:03 <Silverfalls> Adds the function to the scope of the loop, that is
00:43:22 <Silverfalls> whereas a let binding in do blocks would add a function in the scope of the do block.
00:43:42 <maimsige> which loop? it's written in tutorial that there are no loops at all
00:43:52 <arkeet> the L in REPL.
00:44:14 <arkeet> you can make your own loops.
00:44:26 <BoR0> recursion by definition makes a loop
00:44:36 <TravisD> Does anyone know of a good place to read up on laziness?
00:44:43 <identity> > let for = flip map in for [1..10] id
00:44:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:44:45 <identity> for loop!
00:44:47 <TravisD> Right now I have a hard time imagining what actually happens when my programs execute
00:46:12 <ion> forsooth
00:46:14 <identity> TravisD: Hmm. Try googling "High performance haskell" and "haskell performance patterns" .. those are guides on optimizing haskell programs, but they go into laziness and (non-)strictnes and so on
00:46:15 <Silverfalls> maimsige: Haskell doesn't really have loops in the standard imperative-language way. However, recursion can be used as a loop.
00:46:20 <alpounet> TravisD: http://alpmestan.com/2013/10/02/oh-my-laziness/ hopefully this will help — feel free to ask questions though
00:46:32 <TravisD> identity: Ah, I actually have one of those bookmarked!
00:46:38 <TravisD> I wasn't sure if it was the right place to start with that sort of thing
00:47:02 <TravisD> alpounet: thanks :) Is that your blog?
00:47:04 <identity> well, you could skip through them and judge for yourself, etc
00:47:14 <TravisD> identity: good point
00:47:14 <arkeet> also this is a good read http://www.vex.net/~trebla/haskell/lazy.xhtml
00:47:30 <identity> lolwat. TravisD, it seems i've already linked you ths before, haha.
00:47:35 <tdammers> read-eval-print-LISTEN
00:47:37 <tdammers> not loop
00:47:39 <tdammers> listen.
00:47:42 <identity> googling it I found an irc log where I'm telling you about it
00:47:52 <TravisD> identity: :D for different reasons, though, no?
00:47:56 <tdammers> at least that's what I was taught
00:47:59 <arkeet> tdammers: wikipedia disagrees =(
00:47:59 <TravisD> There we were talking about strictness in folds
00:48:03 <tdammers> hmm
00:48:14 <identity> TravisD: didn't check
00:48:15 <identity> perhaps
00:48:24 <tdammers> maybe we should settle on R-Erlang-Perl-Lisp then
00:48:24 <TravisD> brb
00:48:28 <scott_> tdammers: I'm curious where you were taught that
00:48:40 <identity> TravisD: you could also just post some source code and ask questions regarding it
00:48:40 <tdammers> idk... I think some lisp beard told me
00:48:52 <TravisD> identity: Ah, I'm not actually having any problems
00:49:07 <TravisD> identity: It's just one of those things that feels like a major gap in my understanding
00:49:10 <identity> ah, i see
00:49:11 <tdammers> always made sense to me that way
00:49:30 <TravisD> identity: it came up once before when I was trying to compute the mean of a long list of numbers
00:49:33 <identity> regardless, you could still post some code and ask questions, "what exactly is happening here?" and so on
00:49:42 <identity> TravisD: That is basically the canonical example
00:49:42 <TravisD> identity: I had no need to store the entire list
00:49:45 <TravisD> yeah, I know :)
00:49:52 <TravisD> Found exactly the same problem in a book
00:50:00 <identity> it's also in tibbe's slides
00:50:06 <TravisD> ah
00:50:07 <identity> (high perf.. )
00:50:11 <alpounet> TravisD: yes, and I wrote it because I thought the existing material wasn't really good enough for beginners. Let me know how that goes with my article
00:50:19 <TravisD> alpounet: sure thing!
00:50:40 <TravisD> identity: I wouldn't have come up with the solution to the averaging myself. I want to get to that point
00:50:48 <identity> I see
00:50:53 <alpounet> you'll get there soon enough
00:50:56 <identity> yep.
00:51:09 <alpounet> and then have more complicated problems
00:51:12 <alpounet> and get past them too :)
00:51:33 <TravisD> Hehe, I hope so!
00:52:12 <identity> I was in your situation once as well, but eventually, it will make sense, and you'll be able to look at your code and spot functions that are being overly lazy and so on
00:52:28 <identity> but a lot of the problems can be avoided just using foldl' and stuff like Data.Map.Strict
00:53:03 <identity> (Most people seem to agree on there being almost no reason to ever use the lazy foldl)
00:53:05 <BoR0> could anyone explain to me how is replicate >>= id equal to \x -> replicate x x
00:54:16 <ion> @type (>>=)
00:54:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:54:27 <ion> bor0: With m = ((->) r), what is the specialized type of (>>=)?
00:54:54 <Silverfalls> mm_freak: How would I use folds in this case?
00:55:06 <BoR0> r -> a -> (a -> (r -> a) b) -> r -> b ?
00:55:51 <arkeet> errr
00:55:59 <ion> It’s (->) r a -> (a -> (->) r b) -> (->) r b
00:56:09 <BoR0> I can't understand prefix arrow
00:56:13 <BoR0> what does that mean?
00:56:13 <ion> Which is (r -> a) -> (a -> r -> b) -> r -> b
00:56:14 <arkeet> parentheses are important
00:56:19 <ion> (+) 4 5 = 4 + 5
00:56:19 <arkeet> (->) r a  is (r -> a)
00:56:23 <simpson> (r -> a) -> (a -> r -> b) -> r -> b
00:56:24 <mm_freak> Silverfalls: a fold is just a general traversal…  each time you consume a list element by element to formulate a result, it's most likely a fold
00:56:49 <ion> bor0: Can you come up with a definition for the function f :: (r -> a) -> (a -> r -> b) -> r -> b?
00:57:07 <TravisD> anyways, I'm going to read the links posted now! Thanks!
00:57:19 <arkeet> (keep in mind that a -> b -> c is really a -> (b -> c) )
00:57:24 <Silverfalls> but how could I traverse two lists and return dbullets and dscore as well as the remaining bullets and agents?
00:58:01 <BoR0> I can see that it takes three parameters, the first two being another function
00:58:02 <Silverfalls> wait, 1 sec
00:58:28 <ion> bor0: Correct
00:58:50 <arkeet> hint: there is only one way to write it
00:59:21 <identity> isn't that just (.)?
00:59:25 <arkeet> no
00:59:26 <ion> identity: no
00:59:33 <codygman> How would I use a data type from Data.Time.Units? I imported Second(..) but it doesn't seem to work out.
00:59:53 <identity> or foo f f1 = f1 . f?
01:00:16 <BoR0> f x y z = z x y ?
01:00:31 <arkeet> codygman: what doesn't work out?
01:00:52 <ion> bor0: It must return a “b”. Which parameter can you use to get a b?
01:01:02 <BoR0> the y in "f x y z"
01:01:31 <codygman> import Data.Time.Units (Second(..),TimeUnit(..)) and then :t Second gets "Not in scope: data constructor `Second'"
01:01:45 <ion> bor0: Correct. f ra arb r = arb something something
01:01:46 <arkeet> codygman: well, stop trying to use Second as a value. ;)
01:01:47 <arkeet> it's a type.
01:01:58 <BoR0> oh right, so f x y z = y x z?
01:02:03 <arkeet> stop guessing
01:02:06 <arkeet> :p
01:02:07 <codygman> arkeet: There's nothing to create a Second type though is there?
01:02:09 <ion> bor0: You’ll need to apply it to something of type a and something of type r. Can you figure out how?
01:02:16 <BoR0> let me try
01:02:23 <scott_> codygman: Try :i Second for info
01:02:34 <codygman> scott_: Oh, okay thanks. Trying that.
01:02:48 <arkeet> codygman: it has Num instances and so on.
01:02:54 <ion> ra :: r -> a, arb :: a -> r -> b, r :: r
01:02:55 <jle`> :t (->)
01:02:56 <lambdabot> parse error on input `->'
01:03:01 <jle`> :'(
01:03:15 <codygman> arkeet: OH! Whoa... well that makes a ton of sense.
01:03:18 <arkeet> codygman: so you can write e.g. 10 :: Second
01:03:25 <identity> :t \ra arb r -> arb (ra r) r
01:03:25 <lambdabot> (t2 -> t1) -> (t1 -> t2 -> t) -> t2 -> t
01:03:34 <arkeet> identity: :-(
01:03:39 <scott_> jle`: Only values have types, (->) isn't a value
01:03:41 <codygman> arkeet: Yeah, I just put together "typeclass", it has Num instances, and then tried that :P
01:03:44 <identity> sorry, I'm following this too, haha
01:03:59 <identity> that's almost a lady gaga song
01:04:17 <jle`> scott_: what is (->) then?
01:04:21 <jle`> syntax?
01:04:23 <scott_> jle`: A type constructor
01:04:28 <jle`> ah
01:04:38 <scott_> It takes two types as arguments and gives a type
01:04:40 <scott_> :k (->)
01:04:41 <lambdabot> * -> * -> *
01:04:50 <scott_> That's called its kind, read * as "type"
01:05:00 <jle`> :t (->) Int Bool
01:05:01 <lambdabot> parse error on input `->'
01:05:06 <scott_> Use :k
01:05:13 <jle`> :t (->) 'a' 5
01:05:14 <lambdabot> parse error on input `->'
01:05:25 <scott_> :k (->) Int Bool
01:05:26 <lambdabot> *
01:05:34 <jle`> why can i do
01:05:34 <arkeet> :k (->)
01:05:35 <lambdabot> * -> * -> *
01:05:37 <jle`> :t Maybe 5
01:05:38 <lambdabot> Not in scope: data constructor `Maybe'
01:05:40 <arkeet> you can't
01:05:42 <arkeet> ;)
01:05:43 <jle`> :t Just 5
01:05:44 <lambdabot> Num a => Maybe a
01:05:44 <jle`> :P
01:05:54 <scott_> Maybe is a type constructor like (->)
01:06:09 <jle`> oh it's a type constructure, not a data/value constructor?
01:06:15 <ion> 'a', 5 and Just exist in the namespace of values. Int, Bool, (->) and Maybe exist in the namespace of types.
01:06:17 <scott_> Correct
01:06:20 <arkeet> -> is a thing you see in types, not values.
01:06:30 <jle`> Maybe takes a type and returns a new type
01:06:38 <jle`> Just takes a...data? and returns a new data?
01:06:41 <jle`> value?
01:06:44 <scott_> :t Just
01:06:44 <lambdabot> a -> Maybe a
01:06:45 <ion> yeah
01:07:08 <jle`> so there are no value constructors for (->)
01:07:19 <scott_> data Maybe a = Nothing | Just a -- Maybe is a type constructor, Just and Nothing are data constructors
01:07:45 <ion> You can create a value of type (->) a b by creating a function.
01:07:49 <jle`> i guess the value constructor for (->) is syntax
01:08:15 <ion> @type \a -> "hello"
01:08:15 <lambdabot> t -> [Char]
01:08:21 <jle`> what if you could infix it heh
01:08:28 <jle`> (->) (\a) "Hello"
01:08:29 <ion> @type let f a = "hello" in f
01:08:30 <lambdabot> t -> [Char]
01:08:38 <jle`> *prefix
01:09:03 <jle`> (->) (\a) "Hello" should be valid.
01:09:05 <ion> You can’t take the \ and the -> apart from lambda notation.
01:09:20 <jle`> (i am saying this facetiously)
01:10:04 <jle`> so you can only create (->) values using syntax, not using data constructors like with other types?
01:10:18 <jle`> sounds like an arbitrary limitation!
01:10:31 <BoR0> ion: is this correct? f x y z = y (x z) z
01:11:03 <scott_> :t let f x y z = y (x z) z in f
01:11:04 <lambdabot> (t2 -> t1) -> (t1 -> t2 -> t) -> t2 -> t
01:11:41 <scott_> Kinda messy with the t's, but that's the same as: (r -> a) -> (a -> r -> b) -> r -> b
01:11:43 <ion> bor0: Yes. Congrats. Now, what is f replicate id?
01:11:44 <scott_> So you got it
01:12:46 <BoR0> f z = id (replicate z) z
01:12:59 <BoR0> I got it from here
01:13:13 <BoR0> thank you. but, can you please explain to me the (-> r) part? what did you do there?
01:13:49 <scott_> Your original expression replicate >>= id uses the Monad instance for ((->) r). Have you learned about Monads?
01:14:14 <BoR0> I only know about monads in general. how can I see that replicate >>= id uses ((->) r) monad instance?
01:14:22 <Silverfalls> mm_freak: Okay, I kind of figured out folds. Here's my attempt at implementing my function with a fold. I haven't tested it yet really, but here it is:
01:14:23 <Silverfalls> foldr (\(a,b) (as,bs,db,dx) -> if (collision a b) then (as,bs,[nb] ++ db ,1+dx)  else ([a] ++ as, [b] ++ bs, db, dx))  ([],[],[],0) $ zip agents bullets
01:14:23 <Cale> :t replicate
01:14:24 <lambdabot> Int -> a -> [a]
01:14:30 <Cale> :t (>>=)
01:14:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:14:36 <Silverfalls> (where nb means the new bullet I'm going to add)
01:14:44 <arkeet> replicate :: (->) Int (a -> [a])
01:14:47 <Cale> BoR0: In order for  Int -> t -> [t] to unify with m a
01:15:08 <ion> @type (replicate >>=)
01:15:09 <lambdabot> ((a -> [a]) -> Int -> b) -> Int -> b
01:16:00 <BoR0> sorry, I still can't see how you extracted ((->) r) from that
01:16:04 <Cale> Int -> (t -> [t]) = (->) Int (t -> [t]) = ((->) Int) (t -> [t])
01:16:18 <BoR0> ahhh right
01:16:28 <ion> bor0: This may or may not be helpful: http://heh.fi/haskell/functors/#function-instance
01:16:30 <Cale> which matches against m a with m = ((->) Int) and a = (t -> [t])
01:17:18 <Cale> > (do f <- replicate; n <- id; return (f n)) 5
01:17:19 <lambdabot>   [5,5,5,5,5]
01:17:21 <BoR0> thanks guys! I'll re-read this log and read the link you posted
01:17:23 <Cale> tee hee
01:18:04 <Cale> BoR0: The function monad instance is one where "running" a function means applying it to the parameter to which the whole function has been applied
01:18:09 <Cale> BoR0: Check this out:
01:18:16 <scott_> > (do f <- replicate; id f) 5
01:18:17 <lambdabot>   [5,5,5,5,5]
01:18:26 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
01:18:27 <lambdabot>   ("hello","olleh","HELLO")
01:18:52 <Cale> > join replicate 5
01:18:53 <lambdabot>   [5,5,5,5,5]
01:19:44 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
01:19:45 <lambdabot>   [5,7,10,25,32]
01:20:03 <BoR0> wow, sequence. is that like map but kind of "reversed" ?
01:20:11 <Cale> Yeah
01:20:25 <Cale> sequence runs each of a list of actions in turn and produces a list of the results
01:20:40 <Cale> or rather it produces an action which does that
01:20:53 <ion> bor0: sequence [ma, mb, mc] = do { a <- ma; b <- mb; c <- mc; return [a,b,c] }
01:21:08 <danr> > flip map ($5) [id, (+2), (*2), (^2), (2^)]
01:21:09 <lambdabot>   Couldn't match expected type `[a0]'
01:21:09 <lambdabot>              with actual type `(a1 -> b...
01:21:09 <Cale> In the function monad, "running" a function means applying it to the parameter to which the function as a whole has been applied
01:21:11 <danr> :(
01:21:16 <scott_> No need for flip
01:21:23 <BoR0> great! I woke up this morning wondering what to do, and now I have tons of stuff to explore! thanks again
01:21:47 <ion> > do { a <- id; b <- (+2); c <- (*2); d <- (^2); e <- (2^); return [a,b,c,d,e] } 5
01:21:48 <lambdabot>   <hint>:1:80: parse error on input `5'
01:21:52 <danr> scott_: right :p
01:21:53 <ion> > (do a <- id; b <- (+2); c <- (*2); d <- (^2); e <- (2^); return [a,b,c,d,e]) 5
01:21:54 <lambdabot>   [5,7,10,25,32]
01:22:13 <Cale> So, sequence takes a list of functions and makes a function that gives lists by applying each of the functions in the original list to its parameter
01:22:18 <arkeet> > sequence [id, (+2), (*2), (^2), (2^)] 5
01:22:19 <lambdabot>   [5,7,10,25,32]
01:22:31 <ion> > let a = id 5; b = (+2) 5; c = (*2) 5; d = (^2) 5; e = (2^) 5 in [a,b,c,d,e]
01:22:31 <lambdabot>   [5,7,10,25,32]
01:22:33 <arkeet> :t sequence
01:22:34 <lambdabot> Monad m => [m a] -> m [a]
01:22:35 <arkeet> :t flip
01:22:36 <lambdabot> (a -> b -> c) -> b -> a -> c
01:22:38 <arkeet> :t (??)
01:22:39 <lambdabot> Functor f => f (a -> b) -> a -> f b
01:23:03 <BoR0> @src sequence
01:23:04 <lambdabot> sequence []     = return []
01:23:04 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:23:04 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
01:24:27 <Cale> The foldr definition of sequence I think is particularly beautiful :)
01:24:43 <Cale> Especially when you consider that foldr (:) [] is the identity function on lists
01:24:56 <BoR0> @src liftM2
01:24:57 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:25:26 <Cale> :t liftM2
01:25:27 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:26:30 <BoR0> > liftM2 (+) (Just 1) (Just 2)
01:26:31 <lambdabot>   Just 3
01:26:36 <arkeet> @src sequenceA
01:26:36 <lambdabot> Source not found. I am sorry.
01:26:46 <arkeet> Cale: I prefer
01:26:48 <arkeet> map id = id
01:26:50 <arkeet> traverse id = sequenceA
01:27:13 <arkeet> I guess I mean fmap
01:27:26 <ion> there’s no map but fmap ;-)
01:28:24 <codygman> Why can't I convert "seconds" into a Second and store it in x: http://lpaste.net/96221
01:29:35 <ion> codygman: :: doesn’t do conversion of any kind, it just in this case gives the two facts “seconds :: Integer” and “seconds :: Second” which conflict. You can convert integral values with fromIntegral.
01:30:00 <ion> (and real numbers with realToFrac)
01:32:16 <BoR0> besides code elegance, is there any other factor as to why would one use replicate >>= id instead of \x -> replicate x x? like optimization and stuff
01:32:31 <Cale> no
01:32:40 <ion> bor0: For code elegance, you’d use \x -> replicate x x instead of replicate >>= id. :-P
01:32:44 <Cale> also, rather than writing replicate >>= id, you might write join replicate
01:32:52 <Cale> which might be slightly easier to understand
01:32:55 <ion> join replicate isn’t too bad, though.
01:33:13 <Cale> In the function monad, join f x = f x x
01:33:22 <BoR0> I see, so the "monadic" version is equivalent to that lambda expression?
01:33:27 <Cale> yes
01:33:35 <ion> (join x = x >>= id)
01:33:53 <ion> (for all monads)
01:34:25 <Cale> If anything, the lambda will have a better chance of being more efficient, but I'd expect GHC to reduce them both to the same thing.
01:34:40 <BoR0> so, >>= id will behave like it behaves for replicate for all functions that have their definition like Int -> a -> [a] ?
01:35:05 <Cale> f >>= id = (\x -> f x x) whenever f is a function
01:35:19 <BoR0> yes that answers it, thanks
01:36:02 <codygman> As an aside what do you all think of my solution to convert seconds to a 00h00m00s time? I felt creative: http://lpaste.net/96221
01:37:02 <ion> codygman: Have you looked at (`quotRem` 60)?
01:37:45 <codygman> ion: I did but didn't quite get it the first time? Perhaps I'll work on a solution with that later. Would that be better?
01:38:31 <arkeet> I wouldn't depend on a whole library just for that.
01:41:00 * hackagebot HMap 0.902 - Fast heterogeneous maps.  http://hackage.haskell.org/package/HMap-0.902 (AtzeVanDerPloeg)
01:42:15 <codygman> arkeet: Thanks for the feedback.
01:42:49 <frxx> how does one emit a signal in gtk2hs? I don't see signalEmit or similar functions. in gtk I would call gtk_signal_emit_by_name
01:44:38 <ion> > let f n = state (\s -> swap (s `quotRem` n)) in evalState (sequence [f 60, f 60, f 24, f 365, get]) $ ((((2*365) + 150)*24 + 9)*60 + 15)*60 + 42
01:44:40 <lambdabot>   [42,15,9,150,2]
01:45:21 <arkeet> unfortunately that doesn't handle leap years.
01:45:25 <arkeet> or leap seconds, for that matter.
01:45:27 <ion> yep
01:45:46 <arkeet> time is hard =(
01:46:27 <Cale> frxx: good question
01:46:47 <jle`> can you pattern guard in let statements
01:47:16 <ion> > let x | Just a <- 42 = a in x
01:47:17 <lambdabot>   No instance for (GHC.Show.Show a0)
01:47:17 <lambdabot>    arising from a use of `M1024275712420...
01:47:21 <ion> err
01:47:23 <ion> > let x | Just a <- Just 42 = a in x
01:47:24 <lambdabot>   42
01:49:20 <codygman> arkeet, ion: Well that shouldn't matter since I'm getting the number of seconds on a daily basis from another source that has to worry about that :P
01:50:00 <jle`> > let f t | t < 60 = return t | otherwise = (f $ t `div` 60) ++ [t `mod` 60] in f 4159
01:50:01 <lambdabot>   [1,9,19]
01:51:06 <jle`> doesn't put it in a tuple though.
01:51:23 <jle`> and breaks after 60 hours :)
01:51:39 <jle`> > let f t | t < 60 = return t | otherwise = (f $ t `div` 60) ++ [t `mod` 60] in f (60*60*60+1)
01:51:40 <lambdabot>   [1,0,0,1]
01:54:51 <codygman> jle`: Haha that is cool :D
01:56:08 <ion> > let f n = state (\s -> swap (s `quotRem` n)) in evalState (sequence [f 60, f 60, f 24, get]) $ 24*60*60+1
01:56:09 <lambdabot>   [1,0,0,1]
02:00:19 <codygman> ion: Also cool.. but I don't imediately get that.. give me a second
02:10:32 <BoR0> where can I see a list of all (or most commonly used) monad instances? such as ((->) r) instance
02:10:57 <jle`> @info Monad
02:10:58 <lambdabot> Monad
02:11:13 <jle`> that was...less useful than I had hoped.
02:11:16 <jle`> :info Monad
02:11:19 <BoR0> :D
02:11:24 <jle`> type it into ghci heh
02:11:47 <ion> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html shows the instances that base includes.
02:12:30 <Silverfalls> do function arguments shadow in where functions?
02:12:44 <jle`> Silverfalls: I hope so
02:12:51 <BoR0> I wrote it in GHCI, are there only 5 instances?
02:13:03 <Silverfalls> jle`: I'm pretty sure they do, but don't know any specifics.
02:13:11 <jle`> BoR0: there are only 5 instances that are imported with prelude
02:13:13 <Silverfalls> I got the foldl working, by the way.
02:13:13 <ion> bor0: You have only imported modules that together provide 5 instances.
02:13:14 <jle`> then
02:13:24 <BoR0> oh, I understand. that link is useful, thanks
02:13:48 <alexander__b> how can I do this: ps = [box, (if active then border), text] -- in a neat way?
02:14:05 <alexander__b> ps = if active then [box, border, text] else [box, text] -- what I do right now
02:14:19 <jle`> if youif you, say, import Control.Monad.ST, and try again, then try :info Monad, you'll see it show up
02:14:29 <alexander__b> so I'd like a more succinct way to express that
02:14:31 <haasn> ps | active = [box,border,text] | otherwise = [box,text]
02:14:32 <ion> alexander__b: concat [pure box, border <$ active, pure text]
02:14:49 <jle`> alexander__b: your first example isn't even well-defined haskell, in case you didn't realize
02:14:50 <alexander__b> haasn: that's not better in the long run
02:14:51 <ion> alexander__b: That is, border <$ guard active
02:15:20 <alexander__b> ion: sort of hideous but maybe worth it in the long run
02:17:13 <ion> let tell' = tell . pure in execWriter $ do tell' box; when active (tell' border); tell' text
02:21:16 <jle`> writer-based solution is probably the most expressive. looks a lot better in multiple lines though.
02:22:10 <jle`> actually i think using concat is the way to go.
02:22:37 <jle`> hm.
02:23:50 <alexander__b> since order doesn't matter I just ended up doing foo = [a, bunch, of, stuff], bar = moar : foo
02:24:00 <alexander__b> then if active foo else bar
02:24:17 <mirpa> I am exhausted by namespace collisions
02:24:26 <tomejaguar> data Activity = Active | Inactive; elements Inactive = [box, text]; elements Active = [border] elements Inactive
02:24:27 <jle`> i wish there was some sort of function try b x = if b then Just x else Nothing
02:24:34 <tomejaguar> (there should be a ++ in there)
02:24:46 <arkeet> try b x = if b then pure x else empty
02:24:51 <jle`> then you can do catMaybe [Just box, try active border, Just text]
02:25:23 <jle`> > let try b x = if b then pure x else empty in catMaybe [Just "box", try active "border", Just "text"]
02:25:25 <lambdabot>   Not in scope: `catMaybe'
02:25:25 <lambdabot>  Perhaps you meant one of these:
02:25:25 <lambdabot>    `catMaybes' (i...
02:25:31 <jle`> > let try b x = if b then pure x else empty in catMaybes [Just "box", try active "border", Just "text"]
02:25:32 <lambdabot>   Not in scope: `active'
02:25:37 <mikeplus32> jle`: not perfect, but you could use [ x | b ], with MonadComprehensions enabled
02:25:58 <jle`> > let try b x = if b then pure x else empty in catMaybes [Just "box", try False "border", Just "text"]
02:25:59 <lambdabot>   ["box","text"]
02:26:05 <jle`> > let try b x = if b then pure x else empty in catMaybes [Just "box", try True "border", Just "text"]
02:26:06 <lambdabot>   ["box","border","text"]
02:26:31 <mikeplus32> > [Just "asdf", [ "test" | True ], Nothing ]
02:26:32 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe [GHC.Types.Char]'
02:26:32 <lambdabot>           ...
02:26:40 <arkeet> we need an Alternative version of guard =(
02:26:42 <mikeplus32> aw, lambdabot doesn't have MonadComprehensions
02:27:07 <arkeet> > [Just "asdf", guard True >> Just "test"]
02:27:08 <lambdabot>   [Just "asdf",Just "test"]
02:27:09 <arkeet> > [Just "asdf", guard False >> Just "test"]
02:27:10 <lambdabot>   [Just "asdf",Nothing]
02:27:49 <arkeet> > "test" <$ guard False
02:27:50 <lambdabot>   No instance for (Control.Monad.MonadPlus f0)
02:27:50 <lambdabot>    arising from a use of `e_1'...
02:27:53 <arkeet> > "test" <$ guard False :: Maybe String
02:27:54 <lambdabot>   Nothing
02:27:55 <arkeet> > "test" <$ guard True :: Maybe String
02:27:56 <lambdabot>   Just "test"
02:28:02 <jle`> oh that's neat.
02:28:37 <jle`> > catMaybes [Just "box", "border" <$ guard True", Just "text"]
02:28:38 <lambdabot>   <hint>:1:61:
02:28:38 <lambdabot>      lexical error in string/character literal at end of input
02:28:42 <jle`> > catMaybes [Just "box", "border" <$ guard True, Just "text"]
02:28:43 <lambdabot>   ["box","border","text"]
02:28:48 <jle`> > catMaybes [Just "box", "border" <$ guard False, Just "text"]
02:28:49 <lambdabot>   ["box","text"]
02:28:56 <jle`> still would like a `try` though.
02:29:27 <jle`> kind of like a `when`
02:29:35 <jle`> @src when
02:29:35 <lambdabot> when p s = if p then s else return ()
02:29:55 <jle`> try p s = if p then return s else fail
02:30:02 <arkeet> no, else mzero
02:30:17 <jle`> we don't speak of fail here?
02:30:20 <arkeet> no.
02:30:21 <arkeet> =(
02:30:24 <tomejaguar> (or empty)
02:30:29 <arkeet> empty is fine
02:30:40 <b_> If I had a biiiiiiig list of numbers that I want to read quickly and use in pure code, should I make it a list in a module and import it, or should I make it a regular text file and readFile >>= lines it?
02:30:48 <jle`> oh totally forgot about Alternative.
02:31:12 <jle`> that's probably what you meant by Alternative, and not the english alternative.
02:31:18 <arkeet> it is.
02:31:28 <arkeet> hence the capitalization.
02:31:40 <jle`> my sense of context clues betray me
02:31:50 <arkeet> well, good night :)
02:32:04 <jle`> good night arkeet
02:35:08 <jle`> @src guard
02:35:08 <lambdabot> guard True  =  return ()
02:35:08 <lambdabot> guard False =  mzero
02:37:58 <BoR0> @src concat
02:37:58 <lambdabot> concat = foldr (++) []
02:39:26 <alexander__b> is there a more succinct way to express this: http://lpaste.net/7915022357364736000 ?
02:39:50 <jle`> b_: well. if it's data, you are technically supposed to separate your data from your code
02:40:41 <alexander__b> so (foo, bar) = (f fu :: Int, f bar :: Int) for instance
02:40:58 <alexander__b> errr, sorry: (foo, bar) = (f fu :: Int, f baz :: Int)
02:41:08 <jle`> alexander__b: well, you can take the type annotations outside to reduce repitition
02:41:20 <jle`> (f fu, f baz) :: (Int, Int)
02:41:23 <jle`> um
02:41:42 <jle`> the repitition in ::, not in Int, heh
02:41:52 <jle`> it's generally cleaner to collect your type annotations all in one place anyway
02:42:00 <alexander__b> right
02:42:11 <alexander__b> no way to put the f outside?
02:42:17 <alexander__b> (that's actually readable as well, mind)
02:42:26 <jle`> hm.
02:42:41 <mangaba_leitosa> jle`: and then be restricted to the I/O monad just because you separated the data from your code? :-)
02:42:48 <jle`> not without defining your own function
02:42:57 <alexander__b> jle`: not worth the hassle then.
02:43:10 <jle`> it's one of the consequences of haskell's type system
02:43:20 <bergmark> (f fu, f baz) == (f***f) (fu,baz)
02:43:23 <jle`> there is no way to define an f that maps over both items of an arbitray tuple
02:43:26 <jle`> oh nevermind
02:43:37 <arkeet> = join (***) f (fu,baz)
02:43:52 <arkeet> = over both f (fu, baz) -- if you use lens
02:44:16 <alexander__b> no lens atm
02:44:22 <alexander__b> but that's pretty nice, thanks arkeet
02:44:33 <alexander__b> and bergmark
02:54:58 <jle`> mangaba_leitosa: if the IO monad is too much to handle maybe you can Template Haskell in the data.
02:55:16 <jle`> but i don't think it would be too hard to structure around the monad
02:58:43 <remdezx> Hello! Has anyone used ZeroMQ on Windows? I can't bring it to work...
02:59:50 <remdezx> I mean haskell-zeqomq ofc
03:00:02 <kayloos> GHCi runtime linker: fatal error: I found a duplicate definition for symbol _c_constTimeEq
03:00:06 <kayloos> Anyone here have had this error?
03:01:58 <kayloos> sorry here is a pastie for the full error: http://lpaste.net/96223, I need some help with the next step
03:02:16 <mangaba_leitosa> jle`: the way to represent "pure" data resulting in your code having side effects (I/O) doesn't seem right to me anyway...
03:03:42 <mangaba_leitosa> jle`: I need to explore the option to use template haskell for this
03:12:24 <jle`> template haskell is probably a bad idea, but it's the only way you can separate code from data without going through I/O.
03:12:43 <jle`> but even in a language with unconstrained sideeffects, you still have to deal with read errors, etc.
03:13:33 <jle`> so reading in data from a file is always going to be 'impure' by nature
03:13:47 <jle`> in haskell or in any other language
03:14:20 <H1FuelCell> hello
03:14:50 <H1FuelCell> I cannot figure out why this code is not working? http://lpaste.net/96224
03:15:25 <danr> H1FuelCell: in which sense is it not working?
03:16:07 <jle`> does it compile?
03:17:59 <H1FuelCell> one second guys, I'll be back, sorry and thanks for trying to helo
03:18:08 <H1FuelCell> I'm needed away from my desk
03:18:43 <mangaba_leitosa> jle`: I'd prefer to have a way for this reading to be performed during compile time and thus be pure :-)
03:19:12 <donri> @hackage file-embed
03:19:12 <lambdabot> http://hackage.haskell.org/package/file-embed
03:19:34 <mangaba_leitosa> lambdabot: thanks, will look at this :-)
03:19:39 <mangaba_leitosa> donri: thanks, will look at this :-)
03:20:04 <donri> make sure to include the file in extra-src-files for cabal
03:20:23 <donri> extra-source-files
03:22:55 <mangaba_leitosa> looks like what I need to move the content of the tables stored as global variables in .hs to separate files
03:26:44 <jonkri> Can I have GHCi complain if not every top-level function has a type signature? Or is that something that I need hlint or such for?
03:27:01 <PierreMC> jonkri: I think hlint takes care of that
03:27:09 <jle`> or ghc-mod
03:27:18 <PierreMC> I could use some help making Haskell interact with the underlying OS
03:27:18 <jle`> but i wonder if -Wall will cause the behavior you want
03:27:30 <PierreMC> I have a hard time figuring out how to use the "system" command
03:28:07 <PierreMC> here's a code snippet: http://lpaste.net/4903524841417605120
03:28:31 <PierreMC> then there is the error message that 'system' is not in scope when I try to compile it
03:28:52 <PierreMC> here is the documentation of "system": http://hackage.haskell.org/package/process-1.1.0.2/docs/System-Process.html#v:system
03:28:56 <PierreMC> What am I doing wrong?
03:28:59 <jle`> jonkri: for some reason -Wall seems to work when i runghc, but not when i ghc.
03:30:13 <jle`> PierreMC: try importing System.Process
03:31:49 <PierreMC> jle`: thanks for your help. It works now!
03:33:09 <jle`> PierreMC: np
03:33:15 <jle`> what text editor/ide do you use?
03:33:39 <H1FuelCell> danr, jle`: this is the error I see http://lpaste.net/96224
03:33:52 <PierreMC> I'm working with gedit
03:33:55 <H1FuelCell> I'm still not advanced enough to understand haskell errors
03:34:31 <H1FuelCell> I thought the show x should convert that into a string
03:34:42 <H1FuelCell> and then those strings should be added together
03:34:50 <jonkri> PierreMC, jle`: Thanks. :-)
03:34:51 <jle`> H1FuelCell: what error are you receiving?
03:34:58 <H1FuelCell> http://lpaste.net/96224
03:35:12 <H1FuelCell> Could not deduce (Show a) arising from a use of `show'
03:35:17 <jle`> hm.
03:35:26 <jle`> you can only call show on things that are showable.
03:35:27 <H1FuelCell> from the context (Integral a)
03:35:34 <jle`> the only constraint you say is that a must be integral
03:35:38 <H1FuelCell> but are integrals not showable?
03:35:38 <jle`> but you don't say that a must be showable
03:35:46 <jle`> not necessarily, they are separate typeclasses
03:35:50 <jle`> integrals are not mandated to be showable
03:36:03 <jle`> that is, the integral typeclass is not dependent on the showable typeclass
03:36:42 <H1FuelCell> hmm... okay, is Int showable?
03:36:47 <jle`> Int is showable
03:36:54 <H1FuelCell> cool
03:36:57 <jle`> in ghci, :info Int
03:37:44 <jle`> afaik all Integrals in Prelude also happen to be Showable
03:37:55 <jle`> but that doesn't stop me from making my own arbitrary Integral typeclass
03:37:56 <axelri> Hey guys! I already have a decent grasp on haskell, but have absolutely no experience on web development. I'm planning to learn basic web dev know and was wondering if haskell is a good choice for this? Is it relatively easy to get up to speed with?
03:38:08 <jle`> er, arbitrary Integral instance
03:38:11 <jle`> that has all of the methods
03:38:12 <donri> H1FuelCell: Integral is not a concrete type, it's a class of types. you can have an Integral type that is not Show
03:38:22 <jle`> and then choose to not make it Showable
03:38:33 <H1FuelCell> oh, cool...
03:38:41 <donri> H1FuelCell: so the type checker is telling you the program would fail if the function is passed such an integral type
03:39:01 <H1FuelCell> wow, that's so much security
03:39:10 <donri> heh
03:39:20 <donri> it's not really about security
03:39:29 <H1FuelCell> I don't mean hacker type security
03:39:31 <jle`> maybe safety is the right word?
03:39:34 <H1FuelCell> yeah
03:39:48 <H1FuelCell> i come PHP (cringes ensue)
03:39:53 <H1FuelCell> and JavaScript
03:40:00 <H1FuelCell> it's the wild, wild wild west
03:40:01 * apo cringes twice
03:41:14 <donri> of course, safety helps to prevent accidental security issues
03:41:45 <donri> but there are escape hatches so it doesn't really do anything to a malicious programmer if you happen to be compiling their code
03:42:26 <donri> somewhat ironically there's a thing called SafeHaskell which sort of *is* about security ;)
03:42:27 <H1FuelCell> but there's the thing donri, I think it's very hard to *compile* and execute arbitrary haskell on my server
03:42:39 <H1FuelCell> compared to executing arbitrary php or js
03:42:40 <donri> but it works by enforcing these safety features, ie. make the types not lie
03:42:59 <H1FuelCell> which is the basis of all hacker livelihood :P
03:43:02 <jle`> axelri: i do haskell web dev.  if you are looking for practical real-world job experience...honestly, haskell mikght not be the right choice.  but i don't think that haskell is in a disadvantaged place for learning web dev stuff necessarily.  this is in theory; i don't know anyone who has learned web dev by starting on haskell
03:43:21 <H1FuelCell> I know web dev well enough jle`  :)
03:43:30 <jle`> addressed to axelri :)
03:43:34 <H1FuelCell> ah
03:44:06 <jle`> axelri: but i am always happy to see more people enter the haskell web scene :)
03:44:22 <H1FuelCell> that's what I'll probably do too ;)
03:44:53 <H1FuelCell> the web scene is booming, and your little community is about to feel the tremors :P
03:45:09 <H1FuelCell> (I don't mean little in a pejorative way)
03:45:19 <CaptainK> google has an ide comeing out or is it out already
03:45:24 <axelri> jle`: I'm not looking for any kind of practical job experience, I'm just charmed by haskell and trying to use it as much as possible. I just don't want the backend-language to be in the way of me learning the whole web development package, if you get my point =)
03:46:35 <donri> i think haskell lends itself well to webdev
03:47:10 <axelri> I took a quick peek at yesod but my first impression was that it felt quite bulky and rigid, but maybe I'm just making unfair comparisons to simple rails and sinatra examples
03:47:23 <CaptainK> javascript is your key for building job experience...but that makes me feel so nauseous to say
03:47:43 <H1FuelCell> CaptainK JS is not that bad... it has good parts, it is just used evilly
03:47:56 <merijn_> axelri: snap and happstack are more lightweight than Yesod
03:48:01 <CaptainK> ys that is so true
03:48:02 <jle`> axelri: one thing for sure is that you will find help/tutorials/resources already written for you if you learn in haskell vs others
03:48:10 <jle`> i use Scotty myself
03:48:16 <jle`> for samller things
03:48:35 <jle`> snap for things with more components
03:48:38 <H1FuelCell> if there is no rails-like in haskell
03:48:38 <donri> the runtime makes deploying in the scale trivial, the syntax makes for good dsls, the functional purity makes things DRY without implicit magic
03:48:42 <H1FuelCell> that's such a huge opportunity
03:48:43 <axelri> So yesod is rails and scotty is sinatra huh? =)
03:48:46 <zebr> where does ghc store module information? i installed something with cabal, then removed it manually (ahem), and despite the fact that there appears to be nothing left in .cabal referencing the module, i still get namespace conflicts because that module used the same namespace as another.
03:48:50 <CaptainK> I've seen some real crap code in haskell also though
03:49:01 <merijn_> axelri: haskell won't be in the way if you already know haskell, and the average haskell web dev is a lot more competent than the average PHP dev, so you'll get better feedback
03:49:12 <dcoutts_> zebr: see ghc-pkg
03:49:25 <merijn_> zebr: In .ghc normally, or ~/Library/Haskell on OSX
03:49:36 <Philonous> jonkri, in ghci: ":set -fwarn-missing-signatures"
03:49:37 <merijn_> zebr: You can "ghc-pkg unregister X" to get rid of it
03:50:02 <jonkri> Philonous: Tyvm. ;-)
03:50:34 <axelri> merijn_: Yeah, and also I've had a great experience with the haskell community, people seem really keen on sharing and trying to help others =)
03:50:45 <Philonous> jonkri, You can also set it under ghc-options in you cabal files and cabal repl will respect it
03:50:46 <jle`> axelri: you'll get better feedback when you find it, but i can't imagine learning this all without being spoiled by hundreds of tutorials on every subject.  but that doesn't mean it is any harder/easier :)  i just can't say from my own experience in learning.
03:51:08 <jle`> i recommend you go for it, but without any misconceptions on the obstacles you will face
03:51:16 <jle`> but the gain at the end is very valuable
03:51:28 <zebr> merijn_: great, thanks. i reinstalled and unregistered it :p
03:51:49 <zebr> cabal ought to have an unregister command for us not-very-clever folks
03:52:23 <hpc> unregister should compute reverse dependencies so it becomes safe
03:52:40 <merijn_> zebr: cabal doesn't actually register/track what's installed
03:52:56 <merijn_> zebr: It just queries the GHC database (which is also why it can't track executables)
03:53:57 <jonkri> Splendid!
03:53:59 <axelri> Sounds like a plan jle`! Worst-case scenario I'll just switch to one of the popular dynamic ones for this project. I already have a command line prototype of my web app, you think the most straightforward way of porting this is by using Scotty?
03:54:35 <Boreeas> @t fun f a b = if f a b then [a, b] else [b, a]
03:54:35 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
03:55:02 <chrisdone> scotty is a trivial let's-a go library
03:55:39 <chrisdone> it caters to people who just want a quick server without caring about things like architecture/long-term
03:57:05 <axelri> sounds kinda like what I need right know. any good tutorials out there?
03:57:38 <Boreeas> @type fun f a b = if f a b then [a, b] else [b, a]
03:57:39 <lambdabot> parse error on input `='
03:57:44 <chrisdone> http://hackage.haskell.org/package/scotty
03:58:00 <donri> or try happstack-lite, which gives you similar simplicity but without the string programming and backed by an architecture you can easily switch to in the long-term
03:58:22 <donri> http://happstack.com/page/view-page-slug/9/happstack-lite-tutorial
03:58:50 <chrisdone> here is the epitomy of stringly hacky programming with scotty https://github.com/chrisdone/listens/blob/master/src/Main.hs
03:59:17 <donri> chrisdone: i like how you didn't even bother with type signatures
03:59:28 <donri> except on main, where it's the least needed ;)
03:59:37 <chrisdone> haha, yeah
04:00:06 <chrisdone> i'd rather like to start using esqueleto
04:00:17 <axelri> I'll look into both, thx guys!
04:00:55 <chrisdone> donri: acid-state should have some tooling that looks at your model and generates a prompt for querying it
04:01:07 <chrisdone> last time i tried it that's what i missed
04:01:16 <hpc> chrisdone: acid-state-lens?
04:01:22 <donri> chrisdone: ghci+lens, all i need ;)
04:01:31 <donri> but yeah there are plans for CLI tools
04:01:59 <Boreeas> Since i can't get it to work with lambdabot: http://lpaste.net/96227 - The type of fun is inferred as fun :: (t -> t -> Bool) -> t -> t -> [t]
04:02:03 <dv-> i wish f do \n == f $ do
04:02:14 <Boreeas> Why not fun :: (t -> a -> Bool) -> t -> t -> [t]?
04:03:36 <chrisdone> why not funberg?
04:04:31 <chrisdone> Boreeas: the types t and a have no option but to be the same
04:05:28 <Boreeas> chrisdone: Yeah, but that doesn't really matter for f, right? f could be a function that takes two different types
04:05:30 <donri> Boreeas: you're putting both a and b in a list, and lists are homogeneous
04:05:38 <chrisdone> donri: i think that's partially what draws people away from it
04:05:43 <chrisdone> it's like, oh i'll just do a refactor
04:05:49 <chrisdone> hum, what was in my db, let's see
04:05:53 <chrisdone> oh, wait, i can't
04:05:55 <donri> chrisdone: yeah it's the number one complaint i hear
04:06:04 <bergmark> chrisdone: yes esqueleto is awesome :3
04:06:12 * hackagebot wai-logger 0.3.2 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.3.2 (KazuYamamoto)
04:06:17 <donri> it's easy to set up ghci but you still need to set up ghci and people don't even realize you could
04:07:19 <adeba> If I send commands from Haskell to the underlying OS, is there a way to capture the result of those commands as, say, a string?
04:07:32 <chrisdone> Boreeas: exercise: think of a function you could put in there that makes sense
04:07:33 <bergmark> tom ellis also has a new sql edsl in the works that i'm gonna check out
04:07:39 <adeba> more concretely, when I send a command like "ls" to the OS, can I then turn this into a string?
04:07:51 <donri> chrisdone: on the other hand you're using haskell types, why do you feel you need to look at the actual data? ;)
04:07:57 <Boreeas> chrisdone: f :: a -> b -> Bool, f a b = True
04:07:58 <chrisdone> bergmark: yeah, something about being even more low level than esqueleto?
04:08:12 <adeba> this does not work: y <- system "ls" ; let lst = read y :: String
04:08:52 <chrisdone> donri: =)
04:08:54 <bergmark> chrisdone: i think the query interface is as high level, but it's not built on persistent so he must have implemented those parts as well :)
04:09:15 <donri> Boreeas: (t -> t -> Bool) is a valid specialization of (a -> b -> Bool)
04:09:38 <Boreeas> donri: But aren't function  signuatures meant to be as general as possible?
04:09:40 <dv-> adeba: system returns an ExitCode, not the output of the program
04:09:47 <chrisdone> Boreeas: go through the evaluation steps
04:10:05 <ktosiek> Boreeas: it is
04:10:07 <nlogax> @hoogle readprocess
04:10:08 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
04:10:08 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
04:10:16 <adeba> dv-: okay, but is there then a way to capture the output from the OS?
04:10:25 <ktosiek> you either return [a, b] or [b, a], so they have to have the same type
04:10:29 <nlogax> adeba: Those should do it ^
04:10:42 <donri> Boreeas: it is as general as can be. it's telling you e.g. (Int -> Double -> Bool) is not acceptable
04:10:42 <adeba> nlogax: Thanks!
04:10:49 <chrisdone> fun f a b | f a b     = [a, b] | otherwise = [b, a]
04:10:50 <chrisdone> 1) fun (\f a b -> True) () 'a'
04:10:50 <chrisdone> 2) fun f () 'a' | f () 'a'     = [(), 'a'] | otherwise = ['a', ()]
04:10:54 <chrisdone> already you have a type error
04:11:20 <Boreeas> Yeah, I understand that both a and b have to be the same type
04:11:21 <chrisdone> the list constraints the types of a and b and therefore f
04:11:43 <dv-> adeba: yes. http://www.haskell.org/ghc/docs/7.6.2/html/libraries/process-1.1.0.2/System-Process.html
04:12:40 <Boreeas> I dont understand why that matters to the type of f. f is going to be called with two parameters of the same type, but it /might/ be defined on two types
04:13:17 <chrisdone> because your type variables are quantified over the whole function's type
04:13:36 <donri> Boreeas: you can pass it a function (a -> b -> Bool) and it will be specialized to (t -> t -> Bool)
04:13:37 <chrisdone> fun :: (t -> t -> Bool) -> t -> t -> [t]
04:13:38 <chrisdone> means
04:13:38 <chrisdone> fun :: forall t. (t -> t -> Bool) -> t -> t -> [t]
04:14:12 <chrisdone> if you want your function to be general then it needs to be a rank-2 type
04:14:29 <chrisdone> e.g. fun :: forall t. (forall a b. a -> b -> Bool) -> t -> t -> [t]
04:14:31 <donri> Boreeas: but imagine "fun" had the type you're expecting, and you pass in a function (Int -> Double -> Bool), how would that work?
04:15:43 <chrisdone> but, when *using* that function, the two t's would still be constrained, so it doesn't help much
04:16:11 <donri> Boreeas: it would mean a ~ Int and b ~ Double, and then you'd have a list [Int or Double] which you can't have
04:16:18 <chrisdone> at least your f would not have to be a -> a -> Bool, tho
04:16:54 <Boreeas> Ah
04:17:00 <Boreeas> Okay, I think I understand it now
04:17:08 <Boreeas> Thank you both
04:17:15 <remdezx> Hello! Has anyone used ZeroMQ on Windows? I can't bring it to work...
04:17:24 <donri> \o/
04:26:14 * hackagebot blastxml 0.3.1 - Library for reading Blast XML output  http://hackage.haskell.org/package/blastxml-0.3.1 (KetilMalde)
04:31:30 <mkay_> hi
04:32:07 <mkay_> and I'm back with another problem...
04:32:14 <mkay_> mm_freak: you here, by chance? :D
04:33:53 <mm_freak> mkay_: yeah
04:34:02 <mkay_> \o/
04:35:14 <mkay_> mm_freak: so, I'm trying to repeatedly compose a function with itself
04:35:47 <mkay_> it's basically "map"
04:36:34 <mkay_> the problem I have is, "map . map" works fine and returns a (a -> b) -> [[a]] -> [[b]], but foldl1 (.) $ replicate 2 map does not (can't construct infinite type, etc)
04:37:51 <mkay_> in my understanding, that happens because the composition changes the function signature, so I can only do this with functions that stay stable in their types through composition
04:39:22 <mkay_> my idea was to define a type that can be either an element or a list, thus hiding the level of nesting...
04:45:00 <chrisdone> ho, ho, ho!
04:45:19 <chrisdone> i just implemented M-r for structured-haskell-mode
04:45:23 <chrisdone> just got real
04:45:23 <RichyB> mkay_, “that happens because the composition changes the function signature, so I can only do this with functions that stay stable in their types through composition” ← yes, that's correct.
04:46:49 <mkay_> RichyB: is there any "standard" way of dealing with this problem?
04:51:23 <RichyB> mkay_, what are you actually trying to do?
04:52:23 <RichyB> If your goal is to be able to map a function over a data type that looks like an arbitrarily-nested-sexpr like (1 2 (3 4) (5) ((6))), then define that type directly, give it a pretty Read and Show, and give it a Functor instance so that you can fmap over it
04:52:53 <RichyB> trying to shoehorn the built-in list type into acting like anything over than a homogenous list is a good way to dive off a cliff
04:53:33 <mkay_> RichyB: it's another coding challenge, we got points for how gracefully we dive off that cliff :D
04:55:13 <mkay_> damn, I need to get going...
04:55:24 <mkay_> RichyB: thanks for your help anyway, I might be back ^^
04:55:39 <RichyB> Good luck, travel safely, think hard about your root use-cases.
04:56:21 <maimsige> Hi everybody. What's wrong with the declaration ? (I am trying to write function which reads file given input path to it)   ReadByLine :: (String path) => path -> IO ()
04:57:05 <RichyB> maimsige, capital letter at the start of the name
04:57:47 <RichyB> capitals at the beginnings of words are only allowed for type and typeclass names (e.g. Int or String or Read or Show) or constructors (e.g. Nothing, Just)
04:57:47 <ezner> maimsige: why not use type Path = String ; ReadByLine :: String -> IO () ?
04:58:35 <merijn_> maimsige: Also, String is not a typeclass so "(String path) =>" makes no sense
04:58:42 <RichyB> maimsige, also the bit where you wrote `(String path) =>` means `there is a typeclass called String which accepts one argument, path has a String instance`
04:59:16 <RichyB> what you actually wanted to write was something more like "readByLine :: String -> IO ()"
04:59:29 <RichyB> but () is an odd thing for a function that reads data in to return
05:00:26 <RichyB> are you sure that you didn't want to write something like "readByLine :: String -> IO String" (assuming it returns entire file contents in one go) or "readByLine :: String -> IO [String]" (if the name is meant to imply that it cuts the file up into lines)
05:00:30 <RichyB> ?
05:00:46 <maimsige> Yes,
05:00:57 <maimsige> Thank you!
05:01:08 <tavarish> :t \f -> fmap lines $ readFile f
05:01:09 <lambdabot> FilePath -> IO [String]
05:01:41 <ezner> :t map lines . readFile
05:01:42 <lambdabot>     Couldn't match type `IO String' with `[String]'
05:01:42 <lambdabot>     Expected type: FilePath -> [String]
05:01:42 <lambdabot>       Actual type: FilePath -> IO String
05:01:47 <chrisdone> donri: Ralith: http://chrisdone.com/shm-raise.ogv
05:01:48 <tero-> I would like to have a monadic action in happy parser rule in the middle. e.g. in a rule "expr : lambda name expr" I want to push 'name' to a scope of names before parsing 'expr'. Is this possible?
05:01:59 <chrisdone> donri: Ralith: now with sound effects so you know something cool happened
05:02:00 <RichyB> ezner, map is specialised to lists. You want fmap.
05:02:14 <donri> chrisdone: haha you said that exactly when the effect started
05:02:28 <ezner> RichyB: yeah I wasn't thinking properly
05:02:58 <tavarish> ezner, your way of writing it is better
05:03:22 <chrisdone> donri: i was trying not to laugh while doing it =p
05:03:31 <donri> chrisdone: yeah i heard the muffled giggle
05:06:59 <chrisdone> donri: anyway in paredit-mode that's M-r (paredit-raise-sexp). pretty useful trick. nice to have it in haskell. obviously in haskell you can't always replace the direct parent, like in a case, "x -> y" is the parent of "y", which you can't replace without making a syntax error. so it jumps up the parents until it finds a node of the same type =)
05:07:34 <donri> chrisdone: coolness!
05:07:47 <chrisdone> which is interesting, as if you're in a where/let and you M-r, it will replace the parent declaration. not sure that's a use-case, but it works
05:08:05 <donri> chrisdone: let me know when all this stuff works well enough that i should try it ;)
05:08:29 <mkay_> RichyB: ok, I'm back
05:08:34 <mkay_> found an outlet ^^
05:09:49 <donri> chrisdone: i'm even honestly considering trying god-mode instead of evil-mode as i expect it will be better integrated with emacs and emacs scripts
05:10:39 <donri> i fear with evil-mode i'll never really learn emacs, but without modality i'll never be able to make the switch :p
05:11:08 <chrisdone> could be interesting
05:11:19 <chrisdone> indeed, the switching is now ingrained in my hands
05:11:23 <mm_freak> new repository for fastirc:  http://hub.darcs.net/ertes/fastirc
05:11:24 <mm_freak> i'm working on it again
05:11:39 <mm_freak> for now updated to pipes 4 and some performance improvements
05:11:46 <donri> chrisdone: i mean switch from vim to emacs
05:11:49 <donri> mm_freak: oh cool!
05:13:00 <donri> chrisdone: do you think it's possible for an emacs newbie to do the emacs tutorial using god-mode? is it sufficiently similar/consistent that you just learn a few basic god-mode concepts and go with it?
05:13:03 <chrisdone> donri: you'll probably miss the mini-language of vim, but certainly it's worth a try
05:13:08 <chrisdone> ermm
05:13:25 <chrisdone> i think so, indeed. it should be a straight set of translations
05:13:34 <mm_freak> it's funny that there are projects based on the ages old fastirc version on hackage =)
05:13:44 <mm_freak> even an IRC server project it seems
05:13:47 <chrisdone> mm_freak: hulk is using that one
05:14:15 <mm_freak> chrisdone: oh, it's from you =)
05:15:07 <chrisdone> donri: some obscure keybindings might not work, but it's not too obstructive, because you just hit the normal keybinding
05:15:25 <donri> chrisdone: ah, they all still work as normal?
05:15:34 <chrisdone> donri: yep
05:16:37 <chrisdone> e.g. `g' is used for the meta key, instead of alt-f you press gf. so you can't use `g' for ctrl-g. instead you just hit ctrl-g. it's acceptable, though, because ctrl-g means quit, which you don't do that often
05:16:41 <jmcarthur_mobile> I use "switched" from emacs to emacs with evil-mode. I love it. It's all the best of emacs combined with most of the best of vim
05:16:59 <jmcarthur_mobile> s/use //
05:17:31 <donri> jmcarthur_mobile: not from vim to emacs?
05:17:36 <jmcarthur_mobile> Nope
05:17:40 <donri> interesting :)
05:18:24 <jmcarthur_mobile> The reason I said this is to highlight that evil-mode doesn't have to be treated as just an intermediate state
05:18:29 <klugez> I've made a switch from Vim to evil-mode and it's working so far.
05:19:26 <jmcarthur_mobile> I use it in weird ways. I use emacs style yanking and such, but vim style rectangular selections and multi-line editing
05:19:32 <jmcarthur_mobile> Etc.
05:19:53 <alexander__b> I've considered trying out evil, as I recognise a lot of advantages in Emacs. the only thing I don't like about Emacs is uh the text editor.
05:20:04 <donri> my main reason for wanting to do the switch is that i'm reaching the limits of vim's extensibility, which is also why the switch is hard for me (i'm comfortable enough in vim that i write my own plugins for it)
05:20:43 <jmcarthur_mobile> alexander__b: evil-mode provides a good text editor!
05:20:46 <klugez> Yeah, I never wrote much Vimscript, just mapped some stuff and used plugins made by others.
05:20:56 <alexander__b> jmcarthur_mobile: that's why I'm considering it. :-)
05:21:22 <klugez> For those plugins the Emacs equivalents mostly match or beat them.
05:21:49 <donri> i kind of know vim inside out, so reaching the same level of proficiency in emacs even with something like evil-mode will take a lot of time and effort, time and effort i already invested in vim previously :p
05:22:08 <jmcarthur_mobile> donri: yeah, and emacs is a lot... Bigger
05:22:28 <danilo2> Hello! I (with some other "haskell people") are porting right now our program to Windows. I want to ask you if someone has used 0mq on this shitty platform (Windows)? As far as I know Haskells 0mq does not work there (as many other things), but its so popular, that I think someone might have a workaround?
05:22:29 <danilo2> https://github.com/twittner/zeromq-haskell/issues/8#issuecomment-29290415
05:22:56 <RichyB> donri, honestly I don't think you should worry about missing the "point" of Emacs by using something like evil-mode. The *point* of emacs is that your editor should do what *you* want it to do.
05:23:01 <alexander__b> hm. I have a module that implements a typeclass that has initialise, draw, handle and step. now I need to call initialise in main "on" that module, but of course I get 'module does not export 'draw'. what do I do?
05:23:42 <RichyB> donri, worst-case scenario is that you end up having to customise a lot of modes' bindings to make them fit in nicely with evil-mode. Eh, won't kill you.
05:23:42 <chrisdone> donri: iirc you already tried evil-mode out. i forgot what you thought of it
05:24:08 <donri> RichyB: my point is that emacs and everything in emacs is designed without evil-mode in mind. evil-mode is a second-class citizen
05:24:23 <b_> I haven't noticed that donri
05:24:34 <b_> but then again, I don't know how emacs feels without it
05:24:46 <alexander__b> http://lpaste.net/4986896195356983296 -- how do I use Game's initialise/handle/draw/step in main here?
05:24:47 <donri> chrisdone: IIRC i found it surprisingly good except for the ex commands
05:25:04 <b_> agda-mode and haskell-mode are worth the impurity
05:25:18 <alexander__b> err http://lpaste.net/8227417452179357696 rather
05:25:24 <chrisdone> donri: what're ex commands?
05:25:28 <b_> :lulz
05:25:38 <chrisdone> ah, nod
05:25:41 <donri> yep
05:26:08 <donri> it's basically sed plus M-x
05:26:36 <b_> I haven't had too much trouble with those, but I'm not a hardcore :user
05:28:32 <donri> alexander__b: perhaps you want main = do
05:28:58 <donri> eh, no
05:29:06 <alexander__b> donri: no
05:29:20 <chrisdone> i'm currently preparing a bundle for emacs newbies to use haskell-mode + fpco api
05:29:36 <alexander__b> donri: this code worked correctly when I hade Game's draw/handle/initialise/step outside of a System instance.
05:30:04 <donri> alexander__b: ah so there's an ambiguity problem?
05:30:25 <donri> alexander__b: you could do (initialise :: Game)
05:30:31 <donri> inline in main
05:30:47 <alexander__b> donri: that was what I was looking for
05:31:06 <alexander__b> donri: thanks
05:31:20 <alexander__b> I actually did/b 51
05:31:23 <alexander__b> err ups
05:34:59 <yezariaely> In the explanation of unsafePerformIO (http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO-Unsafe.html) it says that the example code should core dump, but it does not and I wonder why it should? after all we are just printing an integer?
05:35:09 <yezariaely> of course, it is not type safe.
05:35:42 <yezariaely> The memory location where 42 is stored ist just viewed as a character (which is fine in this case).
05:36:12 <chrisdone> donri: http://www.youtube.com/watch?v=QqfjiuqVrV4&feature=youtu.be
05:36:20 * hackagebot indexed-free 0.3.0 - indexed monads for free  http://hackage.haskell.org/package/indexed-free-0.3.0 (FumiakiKinoshita)
05:36:32 <donri> mm_freak: i'm curious if the overhead of toStrict makes Builder less optimal than, say, a dlist of strict bytestrings plus BS.concat, for small things like IRC messages ...
05:36:57 <donri> chrisdone: i can do that!
05:37:32 <donri> well, could. haven't tried it in a long while and i'm getting old ;p
05:37:51 <Daiver> Hi
05:38:07 <chrisdone> donri: =p
05:39:08 <mangaba_leitosa> yezariaely: it doesn't coredump for me either
05:39:22 <Daiver> Can anyone make this better? (prefix tree by haskell)
05:39:23 <Daiver> http://pastebin.com/tESURdPr
05:39:24 <donri> mm_freak: docs say toStrict is expensive, but maybe it's not expensive if the whole lazy bytestring is a single chunk, hm...
05:39:28 <mauke> The paste tESURdPr has been copied to http://lpaste.net/96229
05:40:02 <yezariaely> mangaba_leitosa: I'd expect it only on machines where sizeof(42) < sizeof(char) if this is the case with haskell anywhere
05:41:55 <mm_freak> donri: renderMessageBS is just a convenience
05:43:00 <donri> mm_freak: well still, fastirc  works with strict bytestrings doesn't it?
05:43:23 <donri> mm_freak: anyway i'm just thinking out loud because it happens to be relevant to a project of mine, too... =)
05:43:23 <mm_freak> donri: serious network code should collect multiple messages and then send them in a burst using renderMessage
05:43:43 <mm_freak> donri: yes, most bytestrings are strict
05:43:52 <donri> mm_freak: hm, does that make sense for irc?
05:44:06 <mm_freak> currently parsing takes around 280ns for one message
05:44:11 <mm_freak> renderMessageBS takes about 700ns
05:44:19 <donri> i guess for a high-load irc server it makes sense
05:44:24 <mm_freak> most of that is probably the conversion to ByteString
05:45:01 <mm_freak> this is low level detail…  as a user, even as a server developer you would use the reactive interface that i'm working on
05:45:33 <donri> aye
05:46:00 <mangaba_leitosa> yezariaely: I tried 'do writeIORef test [0::Data.Word.Word8]; bang <- readIORef test; print (bang :: [Int])', no coredump either :-)
05:47:21 <yezariaely> it might be possible if the value 42 just resides at the end of your processe's memory. But it either is impossible or rather unlikely (I am not familar with haskell's interna here)
05:56:21 * hackagebot BlastHTTP 0.0.1 - Libary to interface with the NCBI blast REST interface  http://hackage.haskell.org/package/BlastHTTP-0.0.1 (FlorianEggenhofer)
06:08:21 <skypers_> hi
06:08:26 <skypers_> > join (liftA2 (*)) [1..5]
06:08:28 <lambdabot>   [1,2,3,4,5,2,4,6,8,10,3,6,9,12,15,4,8,12,16,20,5,10,15,20,25]
06:11:13 <skypers_> > join (liftA2 (,)) [1..5]
06:11:14 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
06:11:16 <piezoid> hi, why is this wrong : type ResOrC tok a = tok -> Either (ResOrC tok a) (Result a) ?
06:11:22 * hackagebot io-streams 1.1.2.1 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.2.1 (GregoryCollins)
06:11:23 <skypers_> is there another way to write that?
06:12:44 <piezoid> > let l = [1..3] in [(a, b) | a <-l , b <- l]
06:12:45 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
06:12:59 <skypers_> yeah, it’s very nice to write
06:13:04 <skypers_> thank you :)
06:13:18 <skypers_> I don’t use list comprehension
06:13:40 <skypers_> I think it’s only usefull when guarding
06:14:31 <skypers_> > let l = [1..3] in [(a,b) | a <- l, b <- l, a == b]
06:14:32 <lambdabot>   [(1,1),(2,2),(3,3)]
06:14:39 <piezoid> or doing nondeterministic evaluation
06:14:42 <skypers_> whereas
06:15:37 <skypers_> hm?
06:15:43 <skypers_> what do you mean?
06:16:17 <skypers_> nondeterministic evaluation can be performed in the monad [] as well iirc
06:16:42 <donri> list monad and comprehensions are the same thing
06:16:59 <skypers_> hm
06:17:14 <piezoid> yeah, you can write []'s primitive with list comprehensions
06:17:57 <skypers_> > let l = [1..4] in do { a <- l; b <- l; guard $ a == b; return (a,b) }
06:17:58 <lambdabot>   [(1,1),(2,2),(3,3),(4,4)]
06:18:01 <skypers_> oh
06:18:04 <piezoid> for guarding, I use a lot [ f extractedField | guardField, Just (MyRecord{..}) <- l]
06:18:05 <skypers_> that’s neat!
06:18:39 <donri> > [ a | a <- Just 123, a > 100 ]
06:18:40 <lambdabot>   Couldn't match expected type `[t0]'
06:18:40 <lambdabot>              with actual type `Data.May...
06:18:45 <skypers_> piezoid: the guard should be placed at the end right?
06:18:49 <skypers_> just like donri wrote it
06:18:51 <donri> guess lambdabot doesn't enable MonadComprehensions
06:19:18 <chrisdone> @choose ListComprehensions MonadComprehensions
06:19:18 <lambdabot> MonadComprehensions
06:19:28 <piezoid> skypers_: your do example is a similar to your liftA2 oneliner
06:19:34 <skypers_> yeah
06:19:37 <skypers_> I prefer using liftA2
06:20:10 <skypers_> > join (liftA2 (,)) [1..4]
06:20:11 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4...
06:21:53 <skypers_> at first Control.Applicative sounded very useless
06:21:55 <skypers_> for a few weeks
06:22:01 <skypers_> I’ve been just enjoying it :)
06:23:07 <piezoid> back to my problem, how can I write recursive types without data ? : type T a = Either (T a) a
06:23:39 <donri> you can't, use newtype
06:24:42 <piezoid> ok, is there theorical reason for this ?
06:26:07 <Feuerbach> piezoid: sure, google for equirecursive and isorecursive types
06:26:52 <Feuerbach> however, you can write recursive types without data using ohter recursive types (such as Mu)
06:27:44 <piezoid> Feuerbach: ok thanks
06:28:32 <khyperia> :t guard
06:28:33 <lambdabot> MonadPlus m => Bool -> m ()
06:28:41 <khyperia> huh, neato
06:42:55 <quchen> "neato" would be Alternative f => Bool -> f ().
06:46:52 <donri> :t bool empty (pure ())
06:46:53 <lambdabot> Not in scope: `bool'
06:46:58 <donri> :(
06:49:35 <quchen> @let bool t f p = it p then t else f
06:49:35 <lambdabot>  Parse failed: Parse error: then
06:49:57 <quchen> Now I'm too embarassed to try again.
06:50:57 <Hafydd> @t ifThenElse
06:50:58 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
06:51:05 <Hafydd> :t ifThenElse
06:51:06 <lambdabot> Not in scope: `ifThenElse'
06:51:32 <Hafydd> There, now your embarrassment is insignificant compared to mine.
06:52:14 <quchen> Hafydd: Maybe ifThenElse is only available when you're using RebindableSyntax.
06:52:22 <alpounet> quchen: you wrote "it" instead of "if" heh
06:52:32 <Hafydd> Yes. I thought maybe lambdabot had that extension on.
06:53:01 <Feuerbach> no way. An extension doesn't introduce anything in scope
06:53:13 <sansor> hi, is it possibly to have an unboxed mutable variable in a record?
06:56:50 <maimsige> Hello! I am trying to write function which takes input path to the file, reads it and prints on the screen: https://dl.dropboxusercontent.com/u/35128663/Haskell/ReadAndPrint.hs.txt  What's wrong?
06:57:18 <Feuerbach> maimsige: tabs?
06:57:26 <mm_freak_> [ i | b <- isEmptyTMVar evVar, not b ]
06:57:30 <mm_freak_> the first time i've used a monad comprehension =)
06:58:00 <Feuerbach> maimsige: just replace all tabs with spaces
06:58:15 <Cale> maimsige: you're missing 'do'
06:58:23 <Cale> in the definition of readByLine
06:58:34 <Cale> (but also you should replace your tabs with spaces)
06:58:54 <maimsige> spaces ? raplece each tab by 4 spaces?
06:59:18 <Cale> You actually lucked out that "else do " is exactly 8 characters, which is the width of a tab here
06:59:26 <Cale> Or else that would have been a problem to
06:59:27 <Cale> o
07:00:44 <Cale> maimsige: In Haskell, it matters which column things line up with, and since editors tend to render tabs as aligning to the next multiple of an inconsistent number of spaces, it can create lots of various problems to have them in source files.
07:01:07 <Cale> (the compiler will treat them as aligning to the next multiple of 8)
07:01:23 <tdammers> doesn't the compiler just treat them as 8 spaces?
07:01:31 <Cale> no
07:01:35 <tdammers> huh
07:01:41 <tdammers> oh wait, that's python
07:01:56 <Cale> If you have space space tab at the start of a line, it's the same as tab
07:02:07 <tdammers> but then, python actually actively refuses problematic whitespace
07:02:10 <tdammers> yes, I am aware
07:02:14 <Cale> Every good text editor will have an option to convert all tabs to spaces automatically.
07:02:21 <tdammers> :set expandtab
07:02:26 <tdammers> \o/
07:03:00 <danilo2> Hello :) I'm learning lenses. Could somebody tell me why when I write such function signature "focusFunction :: Lens' Module [Expr] -> String -> A -> Maybe A" I'm getting error "Illegal polymorphic or qualified type: Lens' Module [Expr]" and suggestion to enable Rank2Types?
07:03:13 <maimsige> Replaced all tabs by 4 spaces : https://dl.dropboxusercontent.com/u/35128663/Haskell/ReadAndPrint.hs.txt
07:03:25 <maimsige> Compliled
07:03:29 <danilo2> I Simply want to create a function, which as a parameter will use Lens' Module [Expr]
07:04:00 <maimsige> But when I execute main  - nothing is happening
07:04:02 <supki> danilo2: Lens' is Rank-2
07:04:04 <maimsige> in Prelude
07:04:27 <danilo2> supki: Ok, but still if I enable rank2Types I have to write "forall" things in my type signature?
07:04:36 <supki> danilo2: nope
07:04:49 <triliyn> Lens' is a type alias that contains a forall in its expansion
07:05:52 <danilo2> supki: Ah, it is working ... I've made an small error in my code (misstyped function name) and it caused an error suggesting I've got to use "forall" there. Thank you! :)
07:06:08 <triliyn> maimsige: you're not doing any output there, are you? It reads the file and then ignores it
07:06:42 <chrisdone> donri: woo! my kobo hd arrived
07:06:50 <maimsige> triliyn, yes, sorry for the stupid question
07:07:00 <donri> chrisdone: oh you got one? jelly!
07:07:38 * chrisdone plugs it in
07:08:08 <brill> Is there no good places to read about regex for Haskell?
07:08:24 <donri> rwh has a chapter on parsec ;)
07:09:18 <maimsige> Thanks !
07:11:13 <chrisdone> donri: it seems to want to setup with my computer or wifi. but i are linux, so i try wifi...
07:11:30 <bergmark> brill: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
07:12:02 <bergmark> I like it "Yep, ghc 6.4.2 is too old. You’ll need 6.6."
07:12:34 <Feuerbach> =)
07:12:50 <sansor> hi, sorry for asking this again but is it possibly to have an unboxed mutable variable in a record?
07:13:02 <brill> bergmark: Yeah, I read that one. But it seems kinda dated. :-)
07:13:51 <quchen> brill: Regex is not really used much in Haskell.
07:14:13 <chrisdone> is there a wiki page about regex?
07:14:18 <chrisdone> i feel like this topic is coverred over and over
07:14:30 <brill> quchen: What do you use instead?
07:14:31 <chrisdone> no one uses regex much, but if you really need, there's x and y, see also parsec, etc.
07:14:35 <tdammers> probably because writing parsers is so easy
07:14:43 <alpounet> parsec and regexp libraries are covered in Real World Haskell, fwiw :)
07:14:56 <Hodapp> I need to get through more of that book.
07:14:59 <tdammers> whenever I would normally break out a regex, I usually just whip up a little parsec in haskell
07:15:23 <Clint> and it only takes 10 times as long to do
07:15:26 <brill> tdammers: Maybe I should have a look at parsec then.
07:15:40 <quchen> brill: Regex is a tool for quick-and-dirty text editing. It's unmaintainable, hard to debug, and in the end it just convertes text to text, which is fundamentally untyped. In Haskell you would typically use a parser to make sense of text, then transform the generated data, and maybe convert it back to text.
07:15:53 <tdammers> exactly
07:16:03 <tdammers> if you're up for it, look at how pandoc does things
07:16:20 <tdammers> it's a textbook example of source code -> AST -> source code transformations
07:16:21 <Clint> regex is a tool for matching, not editing
07:16:28 <quchen> sed would like to disagree.
07:16:41 <brill> quchen: Heh.
07:16:41 <kryft> Parsec is great
07:18:40 <brill> Well I'm learning Haskell to break some bad habits so I might as well look into alternatives to regex.
07:19:15 <alpounet> brill:  there's a pretty nice "Write yourself a scheme in 48 hours" article out there, worth a read
07:19:18 <alpounet> it uses parsec
07:20:24 <brill> alpounet: That one I didn't know. Thanks.
07:21:35 <bergmark> brill: i don't think the regex libraries have changed much
07:22:38 <brill> bergmark: Neither do I. That is what scares me. So either regex libraries stopped being maintained. Or Haskell has something better.
07:22:59 <chrisdone> generally pattern matching is used for string messing
07:23:06 <chrisdone> and if that's not enough people jump to parsec
07:23:37 <Hodapp> alpounet: Interesting, writing yourself a Scheme in 48 hours. This also reminds me of the article which talks about how adding object-oriented behavior to a Lisp is not a massive undertaking, it's an undergraduate homework assignment.
07:23:46 <kryft> The RWH chapter on Parsec was ok too; at least I managed to learn parsec by using that and then writing a couple of parsers/scrapers with parsec
07:23:47 <chrisdone> sometimes regexes are needed, but it's so rare that it's not been given much attention, i think
07:24:28 <kryft> s/using/reading
07:24:29 <levi> Parsec is a language for writing matchers, just like regex is. In fact it is a superset of regex functionality, but it is written in a far more understandable expression language, i.e. Haskell.
07:24:31 <Hodapp> http://www.winestockwebdesign.com/Essays/Lisp_Curse.html - that one.
07:24:47 <bergmark> i haven't found anything lacking from the regex libraries
07:25:13 <brill> bergmark: How about better documentation? :-)
07:26:15 <brill> Sorry. Couldn't resist. I think that comes with the regex syntax. It's rather convuluted to begin with.
07:26:22 <alpounet> Hodapp: heh, well, where I come from, that would require pretty amazing undergrads
07:26:53 <levi> You may still want regular expressions if you want to match something that falls in the category of 'regular languages' and you need it to be very fast. But then you will want to ensure that you use a proper and optimized regular expression library rather than a 'regex' library.
07:27:49 <brill> levi: And Haskell haven't got one, I gather?
07:28:16 <levi> Oh, I think it does, I just haven't looked closely.
07:28:19 <brill> It seems it has a lot of different regex sub libraries.
07:28:43 <levi> Parsec and libraries like it are not *slow*, and so they've been sufficient for everything I've needed.
07:28:47 <alpounet> brill: Haskell has good ones, in particular we have bindings to C regex libraries
07:29:02 <brill> Text.Regex?
07:29:04 <alpounet> (I think the PCRE binding is the one used in Real World Haskell)
07:29:37 <bergmark> Stability: Seems to work, passes a few tests :-)
07:30:54 <levi> Well, if you are going to use a backtracking implementation, you might as well use a more powerful library to begin with.
07:31:06 <brill> Thing like split with keeping delimiters is not possible.
07:31:20 <levi> The nice thing about regular languages is that their matchers can compile to extremely efficient automata.
07:31:41 <brill> splitRegex just splits. :-)
07:32:12 <quicksilver> ironically none of the common regular expression languages is regular
07:32:55 <quicksilver> I think the key virtue of regular expressions is user editability - they are a minilanguage which your user can use in, e.g., an interactive session or in a config file.
07:33:12 <quicksilver> for real parsing I'd normally choose a more data centric parsing library and some of them are pretty fast.
07:33:33 <brill> quicksilver: Perl would disagree.
07:33:55 <quicksilver> brill: I am a Perl programmer by trade :)
07:34:37 <brill> quicksilver: And you've never missed better regex in Haskell? :-)
07:34:43 <levi> Writing data parsers in Attoparsec is much nicer than writing them in regexes.
07:34:45 <quicksilver> but if I had free choice I'd always choose haskell for a task which involved substantial parsing.
07:34:46 <Cale> Perl should serve as an example to all why regular expressions are not a good way to do real parsing.
07:34:49 * chrisdone consoles quicksilver. taking one for the team
07:34:50 <quicksilver> brill: never.
07:35:39 <quicksilver> they are undeniably handy for tiny custom data recognition/extraction tasks
07:36:01 <quicksilver> but I tend to avoid them for larger problems
07:36:17 <brill> quicksilver: And here I thought a whole genetics industry was build on regex. :-)
07:36:25 <osfameron> they're not terrible for specifying the atoms that are pieced together with a proper parser
07:36:36 <danilo2> Hello :) One simple question to somebody, who knows lenses :) Why following code works "set imports (imp : mod^.imports) mod" and this does not "(^~) imports (imp : mod^.imports) mod" ? According to implementation "(^~) = set" :(
07:37:32 <Cale> (^~) :: (Num a, Integral e) => ASetter s t a a -> e -> s -> t
07:37:33 <Cale> Raise the target(s) of a numerically valued Lens, Setter or Traversal to a non-negative integral power.
07:38:09 <supki> danilo2: what documentation says "(^~) = set"?
07:38:27 <danilo2> Cale, supki: http://hackage.haskell.org/package/lens-1.2/docs/src/Control-Lens.html#%5E~
07:38:34 <Cale> (.~) :: ASetter s t a b -> b -> s -> t
07:38:34 <Cale> Replace the target of a Lens or all of the targets of a Setter or Traversal with a constant value.
07:38:34 <Cale> This is an infix version of set, provided for consistency with (.=).
07:38:36 <supki> that's ancient
07:38:37 <danilo2> (^~) :: Setter a b c d -> d -> a -> b (^~) = set
07:38:38 <levi> brill: Take a quick look at Parsec and you'll see why regular expressions are not missed much.
07:38:57 <brill> Thank you for all your input. This a somewhat different from Lisp irc. :-)
07:39:03 <Cale> danilo2: You're looking at Lens 1.2
07:39:20 <Cale> danilo2: The current version is 3.10
07:39:25 <quicksilver> the repetition of "imports" and "mod" in the expression (set imports (imp : mod^.imports) mod) suggests to me that there is a missing piece of composability there
07:39:29 <danilo2> Cale, supki: oh -.- I'm sorry for that ...
07:39:38 <levi> brill: Haskell is *very* different from Lisp. It's best not to try to think of them as particularly related.
07:39:48 <enthropy> danilo2: you can avoid mentioning imports twice with:    mod & imports %~ (imp:)
07:40:04 <Cale> danilo2: If it's any consolation, I really dislike all the numerical lens infix operators
07:40:09 <brill> levi: Good advice.
07:40:43 <Cale> I think they're unnecessary in the face of operations which work with arbitrary functions
07:41:04 <danilo2> enthropy: wow, this is cool !
07:41:11 <danilo2> enthropy: (I'm new to lenses :D)
07:42:04 <Cale> (I also think (&) is a bit weird)
07:42:22 <enthropy> the idea might be that    x .~ (*2) -- looks a bit ugly
07:42:30 <enthropy> at least compared with   x *~ 2
07:42:32 <Cale> I think that looks fine
07:42:59 <Cale> and it's conceptually much cleaner
07:43:16 <Cale> Imagine if we had a dozen versions of the list map function for all the numerical operations
07:43:27 <levi> brill: When you're a bit more familiar with how Haskell works, it might be fun/instructive to look at how they're similar/different, but the practice of writing Haskell programs tends to be rather different even from writing them in languages it's closer too, like ML.
07:43:34 <Cale> Or foldl'
07:43:35 <danilo2> Cale, enthropy: Ok, but If I wiould not use "&" and simply want to replace "set" by an operator, which one should I use in the code "(set imports (imp : mod^.imports) mod)" ?
07:43:52 <triliyn> modify imports (imp:) mod
07:43:54 <triliyn> I think
07:43:57 <Cale> (.~) is set
07:45:19 <danilo2> Cale: hmm, ok, thank you :)
07:45:40 <Cale> levi: Though I think brill was comparing the *IRC* channels :)
07:45:58 <levi> danilo2: I was trying to get a grip on basic lensing last night, and I found it helpful to go straight to the Control-Lens-Getter and Control-Lens-Setter haddock pages.
07:46:06 <levi> Heh. Those are pretty different, too.
07:46:18 <levi> I used to hang out on #lisp
07:46:42 <Cale> Yeah, it used to be that you could just look in Control.Lens, but things have been rearranged a bunch
07:46:46 <levi> I wrote a markdown parser in cl-pcre or something like that. It was horrible.
07:47:30 <chrisdone> if it wasn't horrible i'd be suspicious of the veracity of your markdown implementation
07:48:01 <danilo2> levi: Thanks for the information. I think I'll read it tonight :)
07:48:20 <levi> The Parsec-based parser for markdown in Pandoc is not exactly a thing of beauty, but at least reading through it doesn't bring the taste of bile to my mouth.
07:48:22 <jrmithdobbs> isn't markdown designed to create bad parsers? i thought that was the goal
07:48:46 <geekosaur> multiple incompatible bad parsers >.>
07:49:03 <jrmithdobbs> with overlapping inconsistancies
07:49:16 <jrmithdobbs> too early to spell.
07:49:22 <Cale> http://hackage.haskell.org/package/pandoc-1.12.1/docs/src/Text-Pandoc-Readers-Markdown.html#readMarkdown
07:50:04 <jrmithdobbs> levi: does it handle ```syntax ``` gh syntax?
07:51:01 <levi> My parser? I don't think so. It was not particularly complete, I gave up on the idea of completeness after a few days of hacking on it.
07:51:14 <jrmithdobbs> heh
07:51:25 <levi> I don't think that syntax existed back then, either.
07:51:30 <levi> This was many years ago.
07:52:18 <Cale> http://hackage.haskell.org/package/pandoc-1.12.1/docs/src/Text-Pandoc-Readers-Markdown.html#code -- lol, that looks fun
07:52:25 <brill> levi: So it wasn't common lisp?
07:53:19 <levi> brill: It was in common lisp.
07:53:29 <chrisdone> someone give me a haskell pdf to read!
07:53:34 <chrisdone> with dual column layout
07:53:43 <chrisdone> want to test the kobo =)
07:53:53 <alpounet> chrisdone: the one about the parallel runtime/gc?
07:54:22 <chrisdone> this will do http://ircbrowse.net/pdfs/ i'll find something
07:54:26 <brill> sbcl?
07:54:42 <chrisdone> (er, http://ircbrowse.net/pdfs/haskell)
07:55:21 <levi> brill: Yeah, I mostly used that and the Mac-native one that is now Clozure CL or something.
07:55:25 <benzrf> hi, are there operators for boolean predicate composition?
07:55:39 <benzrf> i.e. (a -> Bool) -> (a -> Bool) -> (a -> Bool)
07:55:42 <brill> Wow. Me too.
07:55:44 <levi> brill: This was back in the days of PPC macs!
07:55:58 <jrmithdobbs> i miss openfirmware
07:56:02 <quicksilver> benzrf: you can use "liftM2 (&&)" etc
07:56:38 <benzrf> hmm
07:56:42 <benzrf> :t liftM2
07:56:43 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:56:52 <benzrf> p:
07:56:54 <benzrf> @src liftM2
07:56:54 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:57:13 <benzrf> im so great at thinking about monads/applicatives/functors yet
07:57:14 <benzrf> :|
07:57:32 <benzrf> ok so lift is basically fmap?
07:57:42 <benzrf> aha
07:57:45 <levi> liftM is similar to fmap
07:57:48 <fryguybob> @src liftA2
07:57:48 <lambdabot> liftA2 f a b = f <$> a <*> b
07:57:49 <benzrf> but for monads
07:58:05 <benzrf> what is the behavior of functions as monads vs functions as functors, again?
07:58:19 <benzrf> also, wouldn't applicatives make more sense here
07:58:29 <benzrf> i don't need binding
07:58:33 <quicksilver> it wouldn't make "more sense"
07:58:38 <quicksilver> it would work precisely the same
07:58:42 <benzrf> ha, true
07:58:49 <benzrf> but the types would make more sense
07:58:49 <benzrf> :U
07:58:55 <quicksilver> liftM2 and liftA2 here both do the same thing
07:58:58 <benzrf> yeah
07:59:00 <quicksilver> for the (->) r instance
07:59:10 <quicksilver> it's irrelevant that it happens to be Monad or Applicative
07:59:22 <quicksilver> it's just a useful construction which, in the libraries, has no name of its own
07:59:31 <benzrf> right
07:59:32 <quicksilver> but exists via the Monad/Applicative instances of (->) r
07:59:40 <benzrf> ok let me try to think the types thru
07:59:51 <benzrf> - to apply a function inside a functor that is a function...
08:00:17 <benzrf> - you compose them?
08:00:23 <benzrf> but wait
08:00:29 <benzrf> umm
08:00:57 <benzrf> ok, you have (a -> (b -> c)) and you want to map it over (b -> c)
08:01:02 <benzrf> you...
08:01:23 <benzrf> \a -> (f1 a) . f2
08:01:26 <benzrf> is that right?
08:02:40 <benzrf> ugh
08:02:49 <triliyn> benzrf: I don't think those two functions can be composed. It has to be (a -> (b -> b)) and (b -> b) or something like that
08:03:01 <benzrf> hmmm
08:03:04 <benzrf> argh
08:03:10 <benzrf> i am really especially terrible at thinking about (-> r) instances
08:03:11 <benzrf> <_>
08:03:23 <benzrf> yknow what ill just use it without understanding it
08:03:27 * benzrf grits his teeth
08:03:29 * benzrf copynpastes
08:03:48 <DarkTiger> You'll have to understand it eventually.
08:03:59 <benzrf> I know
08:04:01 <benzrf> :\
08:04:04 <benzrf> i really want to
08:04:14 <benzrf> my brain just isnt in the right place yet
08:04:23 <benzrf> maybe ill try again when it is more fully developed
08:04:25 <benzrf> B:
08:04:35 <ion> ((->) r) = (r ->), just like ((+) 5) = (5 +), except that the section syntax isn’t available in types.
08:04:43 <benzrf> derp
08:04:55 <benzrf> i know that
08:05:09 <benzrf> i'm saying i'm bad at thinking about functions-as-funtors/applicatives/monads
08:05:28 <ion> benzrf: A cheatsheet: http://heh.fi/haskell/functors/#function-instance
08:05:29 <benzrf> is there a blanket term for types that involve higher-order functions & generic types?
08:05:33 <benzrf> like the 3 i just mentioned
08:06:25 <DarkTiger|Fuuzet> benzrf: ``types''
08:07:33 <benzrf> blih
08:07:35 <benzrf> *bluh
08:07:39 <ion> “``''”
08:07:47 <benzrf> double unix quotes
08:07:47 <benzrf> nice
08:08:11 <benzrf> ion: u & ur fancy curly unicode quotes
08:08:12 <benzrf> bah
08:08:31 <ion> Not unix quotes, LaTeX/m4 quotes. (But neither is really meant for human consumption.)
08:09:43 <ion> I don’t have a problem with ' but using ` as a quote mark is nasty. :-P
08:10:26 <ion> At least use the other accent symbol (´) on the other side for consistency. :-P
08:11:05 <klrr_> i got a problem trying to draw and move a white box on the screen using react-banana and SDL. for some reason this doesnt draw anything and ive hard to understand why. https://gist.github.com/klrr/7660892 anyone got an idea of what might cause this?
08:11:31 <miniBill> @type map
08:11:32 <lambdabot> (a -> b) -> [a] -> [b]
08:11:39 <sx> can someone explain me why '(return $ (fail "foo" :: Either String String)) :: IO (Either String String)' throws an exception in the io monad? should it just put the Left value in the IO monad?
08:12:45 <levi> benzrf: A type class that is polymorphic in a type-level function parameter is sometimes called a constructor class, but that terminology doesn't seem to be used much anymore. Generally Functor and Monad are 'higher-kinded' types.
08:12:59 <ion> sx: Try fail "foo" :: Either String String in ghci.
08:13:28 <sx> ion: same result, i get '*** Exception: foo'
08:13:55 <Saizan> sx: fail for Either is no longer Left
08:14:03 <Saizan> it's error
08:14:22 <sx> Saizan: why not? is there any generic way to do it?
08:14:44 <Cale> I was expecting Left (error "foo")
08:14:58 <triliyn> huh, is the monad instance for Either a not available in prelude?
08:15:01 <Saizan> sx: you could use throwError
08:15:22 <Cale> triliyn: right
08:15:49 <Cale> triliyn: Well, it wasn't, but now it is :)
08:16:02 <sx> Saizan: good idea, thanks, but I don't like it, why should you ever use fail then?
08:16:23 <Saizan> sx: i personally wouldn't
08:16:33 * hackagebot json-assertions 1.0.0 - Test that your (Aeson) JSON encoding matches your expectations  http://hackage.haskell.org/package/json-assertions-1.0.0 (OliverCharles)
08:16:38 <Cale> sx: You shouldn't.
08:16:40 <quchen> triliyn: It is.
08:16:41 <Saizan> fail in the Monad class is considered a mistake by many
08:16:59 <quchen> Saizan: All except those who are wrong ;-)
08:17:10 <levi> benzrf: I should phrase that more clearly: When the polymorphic parameter in a type class is of the type-level function kind, then the type class is a constructor class.
08:17:17 <ocharles> thanks, hackagebot !
08:17:24 <ion> You haters!
08:17:37 <quchen> Funny thing is MonadFail used to exist, but was merged into Monad :-(
08:17:39 <levi> benzrf: And the type-level function kind looks like: * -> *
08:17:45 <Cale> It was MonadZero
08:17:50 <quchen> Or that.
08:18:51 <Cale> Pattern matching against failable patterns would result in a use of mzero :: MonadZero m => m a
08:20:04 <levi> benzrf: So Monad, Functor, etc. are constructor classes.
08:22:05 <Cale> I think GHC actually still uses the Haskell 1.4 concept of failable patterns in translating the do-syntax, it just uses fail in place of mzero. If I recall correctly, you don't get any uses of fail if you're only matching against the subset of patterns which only involve matching constructors of one-constructor types and irrefutable patterns.
08:22:16 <Cale> (which is different from what Haskell 98 says)
08:24:21 <mikeplus32> is there a quickcheck (or test-framework-th) function to test properties defined in a different module?
08:24:52 <unK_> I recall seeing in an article (most likely in a blog) restricted Cont (or ContT), polymorphic in result type (I think it was result, I guess) being called a a name I can't now recall (but it was something strange). Does anyone know what that could be (or I did just mix things up)?
08:26:27 <supki> unK_: Codensity monad
08:26:48 <unK_> supki: ah yes, thank you.
08:27:08 <dmead> ?yow
08:27:08 <lambdabot> I'm also pre-POURED pre-MEDITATED and pre-RAPHAELITE!!
08:27:17 <dmead> i've missed you. lambdabot
08:27:47 <dmead> ?points dmead
08:27:47 <lambdabot> dmead
08:27:59 <dmead> ?points
08:27:59 <lambdabot> Error: expected a Haskell expression or declaration
08:28:04 <dmead> oof
08:28:06 <dmead> ?ergaerg
08:28:06 <lambdabot> Unknown command, try @list
08:28:09 <dmead> @list
08:28:09 <lambdabot> What module?  Try @listmodules for some ideas.
08:30:08 <Cale> The codensity monad of the functor which is the inclusion of the category of finite sets into the category of all sets is the ultrafilter monad, and its T-algebras are compact Hausdorff spaces.
08:30:55 <Cale> (If you ever needed a reason to think that compact Hausdorff spaces are special)
08:32:59 <Cale> http://arxiv.org/abs/1209.3606 for details on that :)
08:38:35 <joelteon> how do I change which CPP GHC uses?
08:38:55 <joelteon> well, through cabal
08:39:32 <chrisdone> ghc-options
08:45:10 <joelteon> ok, so I tried -pgmP cpp-4.7 and it didn't use cpp-4.7
08:45:22 <joelteon> so which one is it actually?
08:46:32 <joelteon> hmm
08:46:33 <joelteon> hang on
08:51:10 <alllex229> hi
08:51:15 <jle`> hi alllex229
08:52:48 <lpaste> benzrf pasted “searchTree” at http://lpaste.net/96237
08:52:57 <benzrf> ok why the hell is that^ giving me a type error
08:52:57 <benzrf> ??!
08:53:57 <jle`> benzrf: what is your type error
08:54:15 <benzrf> jle`: try loading that into ghci
08:54:16 <benzrf> -.-
08:54:20 <benzrf> it gives me 2 errors at line 8
08:54:22 <benzrf> about mismatched types
08:57:25 <jle`> :t mconcat
08:57:26 <lambdabot> Monoid a => [a] -> a
08:58:24 <benzrf> btw, that will be a dfs right?
08:58:29 <benzrf> because i do not want a bfs
08:58:38 <jle`> it is dfs yes.
08:58:43 <benzrf> good
08:58:48 <jle`> your problem is the type of searchTree
08:58:54 <benzrf> hm?
08:58:57 <jle`> and the type of children
08:59:03 <benzrf> how so ?
08:59:04 <jle`> you are mapping searchTree over children
08:59:08 <benzrf> right
08:59:09 <jle`> :t map
08:59:10 <lambdabot> (a -> b) -> [a] -> [b]
08:59:20 <benzrf> searchTree :: Tree a -> First a, right?
08:59:25 <jle`> not quite
08:59:31 <benzrf> ?
08:59:38 <jle`> look closely
08:59:41 <benzrf> p:
08:59:52 <benzrf> oh derp
08:59:54 <benzrf> thanks =]
09:00:00 <jle`> np
09:00:10 <benzrf> ugh i feel dumb
09:00:13 <benzrf> >)
09:00:16 <benzrf> * >_>
09:00:32 <jle`> don't worry :P everyone has done something like this.
09:01:00 <benzrf> kek
09:01:05 <jle`> hm FPComplete is kinda cool
09:01:27 <jle`> sort of wish my vim-haskellmode actaully worked sometimes.
09:14:35 <it3ration> morning all
09:14:43 <klrr_> morning
09:15:27 <piezoid> i have an optimization question : fmap have to reconstruct all the `f b` structure from the `f a` structure, right ?
09:15:34 <piezoid> (at least the indexed parts)
09:16:50 <piezoid> so, can ghc retreive sharing when it's possible ?
09:17:38 <piezoid> for example in fmap id
09:19:19 <Tinned_Tuna> heya, is the getOpt documentation http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt the most "upto date" docs?
09:24:20 <jle`> i wonder, does ghc have any room to be vulnerable to a double parsing exploit like the one discovered in ruby?
09:25:05 <jle`> attempting to 'read' a maliciously constructed string into a double could cause some overflow stuff and then executing of arbitrary code i think
09:29:00 <geekosaur> there is always some potential for something in the runtime to have a buffer overflow although I would expect it to be unlikely. likewise anything called via the FFI has the potential that whatever you called has a bug
09:29:17 <ocharles> Hmm, the time library doesn't have a way to pluck hours/minutes out a NominalDiffTime, does it?
09:30:11 <geekosaur> Haskell's `read` and friends are written in Haskell and you cannot cause a buffer overflow that way (someone would have noticed that severe a problem with allocation/garbage collection by now)
09:31:52 <benzrf> geekosaur: which read?
09:31:54 <benzrf> Num read?
09:32:00 <benzrf> *all num reads
09:32:09 <saml> > read
09:32:10 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
09:32:11 <lambdabot>    arising from a use ...
09:32:18 <saml> just caused buffer overflow
09:33:08 <geekosaur> they're parsers, written in Haskell, they don't downcall to C's strtod() etc. which is probably what ruby is doing
09:33:43 <benzrf> i thought read was a method not a regular func
09:33:48 <geekosaur> it is
09:34:00 <geekosaur> so there are implementations for various types
09:34:13 <geekosaur> which are written in Haskell because who wants to call into C for that?
09:34:16 <geekosaur> and why bother?
09:34:59 <benzrf> alright
09:36:44 <melonmechanic> is there a good way to take a function that returns a tuple and break out the values to pass into another function?
09:36:56 <melonmechanic> so i have a function f a b c d
09:37:00 <pharaun> oh dang we're up to 1200+ users in here
09:37:19 <melonmechanic> and another function that returns (c,d)
09:37:30 <jle`> melonmechanic: you are looking for uncurry
09:37:48 <melonmechanic> how can i compose them together to call f a b (? -> c d)
09:38:27 <jle`> uncurry (f a b) g
09:38:36 <melonmechanic> ah
09:39:03 <cschneid> if I want to grab the contents of a https://... url into a string (or bytestring or text), what's the simplest way to do that in a tiny program
09:39:08 <jle`> > let f a b c d = a+b+c+d; g x = (1,2) in uncurry (f 1 2) (g x)
09:39:09 <lambdabot>   6
09:39:31 <melonmechanic> thats perfect
09:39:34 <melonmechanic> thanks!
09:39:38 <jle`> np
09:40:18 <jle`> currying turns a function f(x,y) into a function ((f x) y).  so uncurry goes backwards and turns a function ((f x) y) into a function f (x,y)
09:48:53 <alpako> Hi, I do not understand why the memory consumption increases with 'n' in this example: http://lpaste.net/6928123891621560320
09:50:58 <Luke> anyone know if daniel patterson is on IRC here and what his handle is?
09:53:34 <sellout-> Is there a DHT package somewhere?
09:57:56 <donri> https://hackage.haskell.org/packages/search?terms=dht
10:01:58 <adzeitor> alpako: try this: loop n p = n `seq` p `seq` loop (n-1) `seq` (map id p)
10:02:21 <supki> alpako: because  seq  does not evaluate list contents
10:02:39 <supki> alpako: seq only evaluate things up to first constructor
10:04:40 <adzeitor> alpako: error in my answer (not equivalent to your code) :) forget about it.
10:07:31 <adzeitor> alpako: loop n p = let k = map id p in n `seq` p `seq` k `deepseq`  loop (n-1) k
10:11:43 <navaati> hi
10:11:46 <bartavelle> anybody wrote a package with RWST and WriterT like the state monad instead of the usual way ?
10:11:58 <alpako> adzeitor, supki: thank you, I thought seq would evaluate the whole list, and I learned that there is 'deepseq' .
10:13:11 <navaati> I'm looking for an ordered data structure (numerically indexed and without holes, like a list or an array) that supports deleting and interting elements at a particular index
10:13:15 <navaati> does that exist M
10:13:16 <navaati> ?
10:14:33 <bennofs> navaati: What operations do you use the most? Insert/delete, lookup, iterate, ... ?
10:15:26 <chrisdone> so what's the popular indentation library for emacs?
10:15:51 <chrisdone> i'm preparing a "haskell-mode for newbies" package. i don't use any of them, i dunno what's best
10:16:25 <navaati> bennofs: about all of them equally
10:16:25 <sellout-> chrisdone: Ooh, I would like something better than whatever haskell-mode does by default. I didn’t even think to look.
10:17:28 <navaati> chrisdone: I use "indentation"
10:18:04 <navaati> chrisdone: I think it's quite reasonable
10:18:46 <navaati> bennofs: what are the options satisfying the properties i need ?
10:19:35 <skypers> hi
10:22:06 <klrr_> hello
10:24:53 <Lycurgus> Hallå
10:29:20 <Lycurgus> if someone pm's you thru lambdabot does it keep delivering it until you reply?
10:30:35 <daneo> During course I encountered this : data PrologData  =  Term String [PrologData] | Var Int deriving Show
10:31:21 <geekosaur> Lycurgus, it only notifies you once
10:31:28 <geekosaur> it will remember the message until you read it
10:31:37 <geekosaur> (or an admin purges it)
10:31:55 <Lycurgus> ah, OK, just seem to have gotten same msg > 1X
10:32:04 <daneo> I don't quite get the meaning of this, they say it is a datatype which can be used to represent Prolog datatypes (and vars) in Haskell.
10:32:08 <sx> is it possible to use throwError with (Either [String] a) and do i have to supply any instance? (for some reason i can not define an instance of Error [String])
10:32:45 <daneo> The left side of the datatype Term String [PrologData]
10:33:08 <daneo> It's possibly a recursive definition ?
10:33:20 <geekosaur> it is definitely recursive
10:34:38 <geekosaur> Lycurgus, it could have been in there multiple times, because the first one had a typo or because the sender forgot they'd sent it and sent it again
10:35:21 <Lycurgus> geekosaur, could be
10:36:07 <geekosaur> or it's also possible that, if there was some amount of time between the two deliveries, that lambdabot crashed and got restarted between and lost the "that was delivered" state
10:36:28 <geekosaur> (more correctly it reloaded the queued messages from out of date state)
10:41:57 <daneo> @geekosaur I think I grasp it. Cheers.
10:41:57 <lambdabot> Unknown command, try @list
10:58:15 <skypers> hey
10:58:33 <skypers> I’d like to allocate a memory of n bytes
10:58:37 <skypers> how can I do that?
10:58:44 <geekosaur> for what purpose?
10:58:46 <skypers> newArray needs an array…
10:59:05 <skypers> geekosaur: I have [Ptr a] and I’d like to merge all
11:00:21 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Foreign-Marshal-Alloc.html raw, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Foreign-Marshal-Array.html slightly more principled
11:00:53 <skypers> mallocBytes then
11:02:09 <skypers> yeah allocaBytes will make it
11:04:09 <skypers> :t foldM_
11:04:09 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m ()
11:09:11 <alllex229> u know any optimized math module for hskl=
11:10:52 <benzrf> hi
11:11:00 <jle`> hello benzrf
11:11:00 <benzrf> how can I validate user input with read while in IO?
11:11:03 <klrr_> hey
11:11:07 <benzrf> i want to read in some coords
11:11:13 <benzrf> [as tuples]
11:11:29 <klrr_> you know the length of them beforehands or not?
11:11:32 <simpson> alllex229: What are you building?
11:11:32 <benzrf> Yeah
11:11:37 <benzrf> 2d
11:12:03 <jle`> read implicitly 'validates' for you, but you have to catch the error.
11:12:04 <klrr_> well, maybe use parsec? (maybe too simple for that)
11:12:06 <jle`> or use readMaybe
11:12:09 <benzrf> jle`: that's my point
11:12:12 <jle`> ah
11:12:13 <klrr_> readMaybe sounds good
11:12:14 <benzrf> jle`: ah, thanks
11:12:15 <alllex229> explicite euler for differential equations
11:12:18 <benzrf> :t readMabye
11:12:18 <lambdabot> Not in scope: `readMabye'
11:12:20 <benzrf> :t readMaybe
11:12:20 <lambdabot> Not in scope: `readMaybe'
11:12:22 <benzrf> ?
11:12:31 <jle`> hm that's not a real thing.
11:12:34 <benzrf> pfft
11:12:35 <alllex229> with an vectorfield with 2 times of cos
11:12:39 <klrr_> :t read
11:12:39 <lambdabot> Read a => String -> a
11:12:47 <klrr_> > read "(1,2)"
11:12:48 <lambdabot>   *Exception: Prelude.read: no parse
11:13:06 <benzrf> aw
11:13:06 <jle`> :t reads
11:13:07 <lambdabot> Read a => ReadS a
11:13:07 <simpson> > read "(1,2)" :: (Int, Int)
11:13:08 <lambdabot>   (1,2)
11:13:12 <klrr_> aa :P
11:13:19 <benzrf> > read "("
11:13:20 <lambdabot>   *Exception: Prelude.read: no parse
11:13:22 <simpson> > read "()" -- IIRC the DMR picks this type
11:13:23 <lambdabot>   ()
11:13:24 <benzrf> > reads "("
11:13:25 <lambdabot>   []
11:13:29 <jle`> lambdabot hates me
11:13:37 <benzrf> > reads "(" :: (Int, Int)
11:13:38 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, GHC.Types.Int)'
11:13:38 <lambdabot>              ...
11:13:42 <benzrf> huh
11:13:47 <benzrf> how can I catch exceptions?
11:14:14 <jle`> that's a type error
11:14:17 <jle`> not an exception
11:14:25 <jle`> :t reads
11:14:26 <lambdabot> Read a => ReadS a
11:14:30 <benzrf> oh
11:14:35 <klrr_> benzrf: how long is the tuple you wanna parse?
11:14:38 <jle`> it doesn't give a, it gives ReadS a
11:14:41 <benzrf> klrr_: 2
11:14:46 <benzrf> > reads "foo"
11:14:47 <lambdabot>   []
11:14:51 <benzrf> ??
11:15:03 <benzrf> :t readLn
11:15:04 <lambdabot> Read a => IO a
11:15:38 <klrr_> benzrf: (a,a) or (a,b)?
11:15:46 <benzrf> the former
11:15:49 <klrr_> okey
11:15:53 <jle`> > reads "(1,2)" :: [((Int,Int), String)]
11:15:54 <lambdabot>   [((1,2),"")]
11:16:02 <jle`> > reads "malicious" :: [((Int,Int), String)]
11:16:03 <lambdabot>   []
11:16:07 <benzrf> hmm
11:16:11 <klrr_> benzrf: what is the complete type (Int, Int)?
11:16:12 <benzrf> how does reads work
11:16:18 <benzrf> probably floatingman
11:16:19 <benzrf> *float
11:16:31 <benzrf> u see im writing a program that identifies shapes for geometry
11:16:43 <benzrf> you plug in 4 coords & it tells you if its a trapezoid or a square or what
11:17:00 <Hafydd> Input n coodinates => it's an n-gon.
11:17:09 <benzrf> :p
11:17:25 <benzrf> it only supports triangles & quads
11:17:36 <jle`> benzrf: reads returns a list of possible parses
11:17:41 <benzrf> ah, NeatBasis
11:17:42 <benzrf> *neat
11:17:42 <benzrf> ugh
11:17:45 <benzrf> ok
11:17:51 <benzrf> > reads "(1, 2"
11:17:52 <lambdabot>   []
11:17:53 <benzrf> > reads "(1, 2)"
11:17:54 <lambdabot>   []
11:17:55 <jle`> the tuple contains the parsed item, and the "remainder"
11:17:59 <jle`> the string that is leftover from the parse
11:18:03 <benzrf> > reads "(1, 2)" :: (Int, Int)
11:18:04 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, GHC.Types.Int)'
11:18:04 <lambdabot>              ...
11:18:07 <benzrf> derp
11:18:15 <benzrf> > reads "(1.1, 2.2)"
11:18:16 <lambdabot>   []
11:18:22 <benzrf> can i read a list w/out brackets?
11:18:34 <jle`> so it returns a list of (parsed, leftovers)
11:18:45 <benzrf> Okasu:
11:18:46 <benzrf> ugh
11:18:48 <benzrf> *ok
11:19:03 <jle`> um not really.  reads is only meant for 'inverted Show' cases
11:19:10 <benzrf> hmm
11:19:13 <jle`> as in, read should be the inverse of show
11:19:17 <benzrf> ill just plop brackets on it
11:19:24 <jle`> > read (show 5) :: Int
11:19:25 <lambdabot>   5
11:19:36 <jle`> if you want more flexibility you can define your own parser
11:19:44 <jle`> it is really pretty simple in a language like Haskell
11:19:48 <jle`> with parser combinators
11:19:53 <benzrf> mhm
11:20:05 <jle`> > read (show [1,2,3]) :: [Int]
11:20:07 <lambdabot>   [1,2,3]
11:20:14 <benzrf> how should i prompt for input?
11:20:17 <lpaste> klrr pasted “tupleparser” at http://lpaste.net/96240
11:20:20 <benzrf> putStr is buffered
11:20:20 <benzrf> :|
11:20:22 <klrr_> benzrf: ^
11:20:34 <klrr_> benzrf: havent tried it but it should work
11:20:41 <benzrf> mhm mhm
11:20:46 <benzrf> prompting for input?
11:21:04 <klrr_> what do you mean with prompting for input?
11:21:08 <benzrf> I want this:
11:21:15 <benzrf> > please enter a number: <cursor>
11:21:16 <lambdabot>   <hint>:1:24: parse error on input `<'
11:21:25 <benzrf> like input("foo") in python
11:21:28 <jle`> :t getLine
11:21:29 <lambdabot> IO String
11:21:40 <jle`> hm that was rather unhelpful.
11:21:45 <jle`> but yeah it's getLine
11:21:50 <benzrf> ?
11:21:58 <benzrf> it does not support prompting
11:22:03 <benzrf> do i have to manually flush?
11:22:10 <jle`> hm?
11:22:21 <benzrf> if i do putstr >> getline
11:22:25 <benzrf> it doesnt show because of buffering
11:22:31 <jle`> hm.
11:22:35 <benzrf> do i have to manually flush or is there a utility for that
11:22:42 <klrr_> use hFlush from System.IO
11:22:42 <benzrf> previously ive gone with just turning off buffering
11:22:43 <benzrf> :[
11:22:49 <klrr_> or set the buffermode to NoBuffering
11:23:01 <klrr_> benzrf: check System.IO
11:23:03 <benzrf> buh
11:25:26 <jle`> you can do putStr "Please: " >> hFlush stdout >> getLine
11:26:02 <jle`> or define your own prompt s = putStr s >> hFlush stdout
11:26:06 <jle`> i don't think there is one in prelude though
11:26:43 <jle`> hmm can't find one.
11:27:12 <benzrf> is there a way to allow bksp in readline?
11:27:15 <benzrf> *getline
11:27:44 <benzrf> haskell's IO facilities HARDLY feel hi-lvl
11:27:47 <benzrf> D:<
11:29:27 <benzrf> also buffering is not being properly set
11:29:28 <benzrf> :{
11:29:45 <mm_freak_> benzrf: getLine is not for reading interactive user input…  use haskeline for that
11:30:05 <benzrf> nvm it works now
11:30:06 <benzrf> derp
11:30:08 <mm_freak_> getLine really just reads from the stdin handle
11:30:16 <benzrf> :)
11:30:19 <benzrf> i was misusing it
11:30:27 <benzrf> i accidentally set 0 buffering on stdin instead of stdout
11:30:28 <benzrf> <_>
11:30:42 <benzrf> how do I catch an error?
11:30:52 <mm_freak_> what type of error?
11:30:52 <benzrf> :t try
11:30:53 <lambdabot> Exception e => IO a -> IO (Either e a)
11:30:59 <benzrf> k that seems to work
11:31:07 <benzrf> usage example?
11:31:12 <mm_freak_> see 'catch' and 'bracket'
11:31:16 <benzrf> :t bracket
11:31:17 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:31:18 <mm_freak_> the two most important exception functions
11:32:02 <benzrf> can I catch a parse error on read
11:32:10 <mm_freak_> use reads
11:32:16 <benzrf> :[
11:32:40 <DrMax_> is there a way to configure print to output data as soon as it is available? say print [ x | x<- xs, p x ]   ouputs only "chunks"
11:32:56 <Cale> DrMax_: it does
11:32:56 <mm_freak_> DrMax_: hSetBuffering stdout NoBuffering
11:33:05 <Cale> oh, right
11:33:15 <Cale> Maybe you have output buffering
11:33:55 <mm_freak_> it's line-buffered by default, if stdout refers to a terminal
11:34:05 <DrMax_> mm_freak_ : where does that go ?
11:34:14 <mm_freak_> DrMax_: before the print
11:34:24 <mm_freak_> hSetBuffering stdout NoBuffering >> print …
11:34:25 <benzrf> :t try
11:34:26 <lambdabot> Exception e => IO a -> IO (Either e a)
11:34:36 <benzrf> where is that try from
11:34:43 <mm_freak_> benzrf: Control.Exception
11:34:44 <Cale> Control.Exception
11:34:51 <benzrf> hmm
11:34:57 <mm_freak_> @hoogle try
11:34:58 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
11:34:58 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
11:34:58 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
11:35:11 <DrMax_> indeed, works fine.
11:35:30 <DrMax_> (it needs import System.IO)
11:35:51 <benzrf> ugh, its giving me an ambiguous type
11:35:52 <benzrf> -.-
11:35:55 <benzrf> because im not using the exc
11:36:17 <Cale> benzrf: What are you trying to do?
11:36:25 <benzrf> ...catch a problem from read
11:36:25 <benzrf> >.>
11:36:43 <Cale> From readIO?
11:36:47 <benzrf> :t readIO
11:36:48 <lambdabot> Read a => String -> IO a
11:36:50 <benzrf> arghhh
11:37:04 <Cale> (that'll throw an exception which is actually easy to catch)
11:37:06 <benzrf> but yes now
11:37:31 <Cale> Note also:
11:37:34 <Cale> :t reads
11:37:34 <lambdabot> Read a => ReadS a
11:37:41 <Cale> of course, type synonym :P
11:37:41 <benzrf> i dont know how to use ReadS
11:37:44 <benzrf> @info ReadS
11:37:44 <lambdabot> ReadS
11:37:47 <benzrf> ???
11:37:51 <smith_> Is there a name for (or a way to pronounce) "::", other than "double colon"?
11:37:53 <Cale> type ReadS a = String -> [(a, String)]
11:38:03 <Cale> smith_: "has type"
11:38:03 <benzrf> urgh
11:38:36 <Cale> benzrf: It'll give you a list of the valid parses (Usual instances give at most one)
11:38:49 <Cale> if that list is empty, then it failed to read
11:38:50 <benzrf> ok, thanks :)
11:39:06 <Cale> You can pattern match it like...
11:39:59 <donri> :t Text.Read.readMaybe
11:40:00 <lambdabot> Read a => String -> Maybe a
11:40:14 <Cale> > case reads "56foo" of [(n,"")] -> show (n + 10); _ -> "error"
11:40:15 <lambdabot>   "error"
11:40:24 <Cale> > case reads "56foo" of [(n,xs)] -> show (n + 10); _ -> "error"
11:40:26 <lambdabot>   "66"
11:40:29 <benzrf> IT WORKS
11:40:29 <benzrf> FINALLLY
11:40:34 * benzrf weeps with joy
11:40:37 <benzrf> thanks =]
11:41:03 <simpson> Every time somebody uses Read to parse, God FFTs a kitten. :c
11:41:30 <donri> that's a lot of kittens then. cabal uses ReadP to parse .cabal files :)
11:41:46 <dcoutts> sadly yes
11:41:48 <Cale> Well, it really depends on what you're doing.
11:41:59 <Hodapp> donri: yes, but it's a uniform chain of kittens. It becomes just a couple spikes in the spectrum.
11:42:01 <dcoutts> it's an ongoing atrocity
11:42:47 <Cale> If you're reading in what would also be valid source code for a Haskell data structure, it seems not too far off the mark.
11:45:07 <Cale> ReadP is another thing though
11:45:16 <Cale> ReadP is actually a pretty nice parser combinator
11:45:22 <Cale> library
11:45:57 <joelteon> smith_: pamaayim nekudotayim
11:46:02 <Cale> There's no need to make a Read instance to use it
11:46:14 <xintron> I did a copy of the "Roll your own IRC bot"-guide ( http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot ) but get the following: Could not load module `Network'.
11:46:15 <yesthisisuser> Hello. I have installed vim-hdevtools but when I try to call HdevtoolsType I get an error "Not an editor command"..
11:46:23 <xintron> Since I'm new I don't really know where to begin :/
11:46:31 <ParahSai1in> xintron: cabal install network
11:46:31 <donri> i kinda like it in its stupid simplicity and messy oldschool API, but it's quite useless in practice; slow and no error handling to speak of
11:46:43 <Cale> xintron: Do you have cabal-install installed?
11:46:49 <xintron> ParahSai1in, So, network isn't a standard library then?
11:46:56 <Cale> xintron: It is.
11:47:02 <Cale> xintron: How did you install GHC?
11:47:14 <xintron> Cale, Arch Linux repository
11:48:16 <Cale> xintron: Okay, I'm not familiar with what they might or might not do vs. the generic Linux binary package, but yeah, you can get cabal-install off of hackage and then cabal install it from there.
11:48:26 <ParahSai1in> distro package managers dont really do well
11:49:16 <Cale> The network package *used* to come with GHC, but I don't think it does anymore, though it's still part of the Haskell Platform.
11:49:27 <donri> yesthisisuser: you need to open a haskell file
11:50:16 <chrisdone> someone implement an 'isConnectionAlive :: Socket -> IO Bool' for Network.Socket  for me =)
11:50:24 <chrisdone> i'll pay you five chillings and sixpence
11:51:14 <Hafydd> How are you defining "alive"?
11:51:16 <geekosaur> ...how's it supposed to know
11:51:21 <donri> chrisdone: https://hackage.haskell.org/package/network-2.4.2.0/docs/Network-Socket.html#g:5 these?
11:51:22 <chrisdone> using http://tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/
11:51:33 <chrisdone> donri: those are lies
11:51:43 <donri> okies
11:51:47 <xintron> Cale, ParahSai1in; Found cabal in the repo as well. Going to read up on it now. Thanks!
11:51:50 <chrisdone> donri: https://github.com/haskell/network/commit/dbef74644cc0d60d646e0749fe522b962d2679b6
11:52:06 <geekosaur> er, you do know those keepalives are part of the kernel network stack, not userspace?
11:52:19 <geekosaur> if you want to do userspace keepalive, that's something you need to design into your protocol
11:52:24 <Hafydd> chrisdone: where does that page define "alive"?
11:52:48 <chrisdone> geekosaur:  you know because i have it in my kernel stack and i'm paying you five chillings and sixpence to implement it
11:52:55 <Cale> chrisdone: What does it mean for the connection to be alive?
11:53:06 <geekosaur> what
11:53:06 <Cale> Isn't it either connected or not connected?
11:53:08 <chrisdone> dudes, read the page?
11:53:15 <geekosaur> I know what TCP keepalives are
11:53:24 <Hafydd> I read enough of the page to suspect that it doesn't.
11:53:27 <chrisdone> cale: it could be disconnected on the other end but you wouldn't know
11:53:32 <geekosaur> why do you think there is any implementation in userspace?
11:53:51 <chrisdone> the keep alives are there to determine a timeout period using empty tcp packets to ping/pong
11:53:59 <geekosaur> keepalives are part of the kernel. if you want to configure them you use sysctl
11:54:38 <geekosaur> or sdo you mean the setsockopt stuff which should be in Network.Socket?
11:54:40 <chrisdone> or setsockopt
11:55:15 * chrisdone → dinner
11:55:39 <alllex229> how can i get an int from IO string?
11:55:53 <alllex229> is there any useful funktion?
11:55:58 <donri> :t fmap read
11:55:59 <lambdabot> (Functor f, Read b) => f String -> f b
11:56:17 <yesthisisuser> donri: sorry late response.. I have a haskell file and set ft shows filetype=haskell
11:56:18 <donri> you can't really get an Int, but you can get an IO Int
11:56:41 <geekosaur> oh, I bet what chrisdone really means is the timeval foo
11:57:06 <geekosaur> "There is currently no API to set e.g. the timeval socket options"
11:57:32 <alllex229> i want to print a function wit a special value
11:57:42 <alllex229> this value ill get from console
11:57:47 <geekosaur> unfortunately I'm pretty sure that is unimplemented because it's going to be annoying and possibly API breaking
11:57:59 <donri> :t readIO
11:58:00 <lambdabot> Read a => String -> IO a
11:58:15 <donri> :t readLine
11:58:16 <lambdabot>     Not in scope: `readLine'
11:58:16 <lambdabot>     Perhaps you meant one of these:
11:58:16 <lambdabot>       `readFile' (imported from Prelude),
11:58:59 <geekosaur> :t readLn
11:59:00 <lambdabot> Read a => IO a
11:59:08 <donri> oh yeah
11:59:23 <alllex229> yeah thanks
12:10:25 <w0rm_x> "Not much work seems to have been done on providing profiling facilities for lazy functional languages."  from a paper back in 1993.
12:11:58 <tiffany> did they mean profiling cpu time, or profiling time/space leaks?
12:12:26 <w0rm_x> they focus on space and time.
12:14:12 <cdk> @unmtl ReaderT a (MaybeT STM) ()
12:14:13 <lambdabot> a -> (MaybeT STM) ()
12:14:35 <cdk> @unmtl a -> MaybeT STM ()
12:14:35 <lambdabot> a -> MaybeT STM ()
12:15:56 <WraithM_> @help unmtl
12:15:56 <lambdabot> unroll mtl monads
12:16:08 <WraithM_> "unroll" ?
12:16:19 <cdk> basically removes the newtype wrapper
12:16:23 <WraithM_> Ahhh
12:16:24 <WraithM_> Got it
12:16:25 <cdk> Reader r a ~ r -> a
12:16:26 <WraithM_> Nice
12:16:30 <cdk> that kind of thing
12:16:39 <geekosaur> most monads are just ordinary data in disguise, this shows you what's behind the disguise
12:16:49 <WraithM_> Got it.
12:17:00 <WraithM_> I was thrown off by the MaybeT STM
12:26:40 <alllex229> how can i write Files in Haskell with forM_ ?
12:27:14 <cdk> alllex229: what do you want to write to those files?
12:28:47 <alllex229> so i want to write some lists with I/O to plot sometin with octave
12:29:25 <alllex229> and this lists needs an int that i get with readLn
12:30:11 <alllex229> and then forM_ [1..k] (\a -> writeFile "data" $ show $ liste a)
12:30:21 <alllex229> somethin like that would be cool
12:31:10 <alllex229> writeFile $ forM_ ... (\a -> liste a)
12:31:10 <sx> alllex229: so where's the problem?
12:31:36 <alllex229> nothing happens
12:31:45 <Guest22602> .
12:31:48 <klrr_> in FRP, how would i create an event x of type Int -> Int that occures each times event y of type () occures?
12:32:15 <sx> alllex299: maybe you should paste your code
12:33:09 <alllex229> ok
12:34:46 <sx> alllex229: do you want that code into one file? because writeFile overwrites, so maybe you should use appendFile
12:35:23 <alllex229> http://lpaste.net/96242
12:35:28 <alllex229> yes appendFile is good
12:35:54 <alllex229> but the same is wrong
12:37:31 * geekosaur wonders if alllex229 thinsk the putStr etc. also somehow get put into the file or something
12:38:38 <alllex229> oh sorry
12:38:43 <alllex229> ive forgotten the file name
12:38:51 <alllex229> :D
12:39:05 <klrr_> do anyone know how to create an event of type 'Event t (Int -> Int)' if i have the function and an event of type 'Event t ()' which should have same frequency as the former
12:39:08 <klrr_> ?
12:41:50 <sx> alllex229: putStr puts your string always to the stdout file handle, if you want to print something into the file you have to either open a file handle and use hPutStr or produce a string and output it with writeFile. (if I assume geekosaur is correct)
12:46:25 <klrr_> anyone know of a function similar to fmap but with this type signature "... :: a -> f (a -> a) -> f a"?
12:47:14 <joelteon> :t (<*>)
12:47:15 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:47:16 <joelteon> hm
12:47:23 <jle`> it sounds like pure and applicative
12:47:29 <joelteon> :t \y -> fmap ($ y)
12:47:30 <lambdabot> Functor f => a -> f (a -> b) -> f b
12:47:38 <joelteon> @pl \y -> fmap ($ y)
12:47:38 <lambdabot> fmap . flip id
12:47:43 <Kams_> :t >>=
12:47:44 <lambdabot> parse error on input `>>='
12:47:53 <Kams_> Wrong order lol
12:47:54 <geekosaur> :t (>>=)
12:47:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:47:55 <klrr_> the data is a functor only not a applicative
12:48:03 <joelteon> my suggestion should work
12:48:15 <klrr_> oph gonna try it thanks
12:48:29 <jroesch> I may be out of the loop but what is the status of 7.8? I was under the impression a release candidate was supposed to be in existence some time in November
12:48:38 <jle`> if you can do this, then it is an applicative.
12:48:54 <joelteon> no
12:49:04 <joelteon> it's just fmapping function application
12:49:17 <klrr_> im just doing inverse fmap basically
12:49:43 <klrr_> (a -> a) -> f a -> f a vs f (a -> a) -> a -> f a
12:49:46 <jle`> isn't applicative just a functor where you can also apply functions over that functor?
12:50:09 <jle`> functions in functors
12:50:18 <joelteon> not really
12:50:39 <yitz> @type fmap . ($)
12:50:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:50:54 <yitz> @type fmap . flip ($)
12:50:55 <lambdabot> Functor f => a -> f (a -> b) -> f b
12:51:15 <yitz> same as joelteon, because $ == id
12:51:40 <fizruk> jle`, it's when you can apply a function "in a functor" to a value "in a functor" and get a result "in a functor"
12:51:53 <jle`> hm
12:52:01 <jle`> so in this case, you have a that was never in a functor in the first place
12:52:10 <jle`> so you don't need any applicativeness
12:52:18 <fizruk> jle`, right
12:52:21 <jle`> but if your a is inside a functor when you get it, then you have applicativeness?
12:52:34 <fizruk> aha
12:52:44 <yitz> jle`: don't get confused by klrr_'s formulation
12:52:53 <Apocalisp> What's a good shorthand for something like this: let b = maybe a f; c = maybe b g in maybe c h
12:53:02 <fizruk> jle`, applicatives should also support `pure` without that it's Apply class
12:53:18 <yitz> jle`: if your *function* is inside the functor, then you need applicative. the a is inside for both of them.
12:53:38 <yitz> @type fmap
12:53:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:53:45 <yitz> @type (<*>)
12:53:46 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:54:02 <fizruk> Apocalisp, h >=> g >=> f or something?
12:54:24 <fizruk> :t (>=)
12:54:24 <lambdabot> Ord a => a -> a -> Bool
12:54:27 <fizruk> :t (>=>)
12:54:28 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:56:21 <jle`> yitz: yes in this case we are only given our function in a functor.  i had incorrectly assumed that that was a sufficient condition instead of just a necessary one
12:56:51 <ParahSai1in> Apocalisp: a <|> b <|> g?
12:57:16 <Apocalisp> ParahSai1in: Something like that yeah
12:58:25 <fizruk> how so? O_o
12:58:57 <navaati> > Identity f <$> Identity a
12:58:58 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr -> b0'
12:58:58 <lambdabot>         ...
12:59:05 <navaati> > f <$> Identity a
12:59:07 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:59:07 <lambdabot>    arising from a us...
12:59:24 <lpaste> Tinned_Tuna pasted “getOpt Issues” at http://lpaste.net/96243
13:00:12 <Tinned_Tuna> Heya, I'm having some issues understanding getOpt; I'm trying to roughly follow the examples on http://hackage.haskell.org/package/base-4.6.0.1/docs/System-Console-GetOpt.html#g:3 and http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt, but failing
13:00:42 <Tinned_Tuna> (I'm just gathering some interesting cases from my console)
13:01:04 <navaati> meh, the f and a and b and c symbolic values trick doesn't work anymore
13:01:06 <navaati> ?
13:01:11 <yitz> ParahSai1in: no it's \x -> h x <|> g x <|> f x <|> pure a
13:01:22 <ParahSai1in> yitz: yeah misread
13:01:56 <lpaste> Tinned_Tuna revised “getOpt Issues”: “No title” at http://lpaste.net/96243
13:02:07 <supki> > Identity f <*> Identity a :: Identity Expr
13:02:08 <lambdabot>   Identity {runIdentity = f a}
13:02:20 <supki> navaati: f is too polymorphic
13:02:45 <navaati> supki: damn. it used not to be, did it ?
13:02:59 <Tinned_Tuna> I've added some of the issues I've had as a comment down at the bottom. My basic issue is that I can't get the options I want into the Options record. It seems to either give me the default, or reads a value that I thought would be un-associated with the reading of options.
13:03:26 <supki> navaati: I don't remember it not being  FromExpr a => a
13:07:25 <YayMe> If someone has some decent ideas how to answer this it would be pretty cool, seems like a very neat question:
13:07:29 <YayMe> http://programmers.stackexchange.com/questions/219581/definition-of-a-type
13:07:58 <YayMe> "Definition of a type" -> Fellow struggling to define what a type is and how to classify and categorize one
13:08:55 <yesthisisuser> hmm.. cabal-dev is redundant once cabal sandbox is fully integrated into cabal-install, or?
13:09:51 <jle`> yesthisisuser: hmmm yes.
13:09:55 <jle`> at least for me.
13:10:19 <geekosaur> mostly, but as cabal-install sandboxes are still new and do have a few shortcomings still it can sometimes still be useful
13:11:16 <yesthisisuser> i have been using cabal-dev now for the last few weeks and i have to say that it is making things a lot easier
13:11:32 <yesthisisuser> but i guess i should switch to sandboxes then
13:12:20 <jle`> i made the switch myself last week and i haven't noticed anything different in my workflow
13:12:21 <skypers> I have a list of Ptr (), and I’d like to put copy them concatenated
13:12:55 <skypers> I know exactly how many bytes they take
13:13:02 <skypers> copyBytes complain
13:13:06 <skypers> s
13:13:16 <skypers> about the fact it needs a type
13:13:22 <skypers> it’s weird btw, because () is one
13:14:10 <simpson> skypers: You can't make Ptrs of the actual types you're representing?
13:14:15 <geekosaur> it needs an instance of Storable. () provides no information about the size of the thing the Ptr is pointing to
13:14:44 <geekosaur> Ptr () is a random pointer, what C calls (void *), and you can't know anything about what's on the other end of the pointer
13:14:54 <geekosaur> including its size
13:15:42 <skypers> simpson: no because hm
13:15:51 <skypers> I have a lot of types in the interface
13:16:02 <simpson> skypers: IOW, what is it a Ptr *to*?
13:16:08 <skypers> let’s assume Int, (Float,Float) and (Float,Float,Float,Float)
13:16:23 <skypers> each of them has to be poke in a Ptr ()
13:16:33 <skypers> in order to use a single representation for each of them
13:16:33 <geekosaur> ideally you'd provide a proper Storable instance and then use pokeArray rather than doing this all manually
13:16:44 <skypers> ok well wait
13:16:48 <geekosaur> which is why I pointed you at the Foreign Array stuff
13:17:05 <skypers> the main idea is to store C-side an array of multiple types
13:17:20 <skypers> such an array is void*
13:17:33 <skypers> for instance if we want it to store one float and one bool
13:17:52 <skypers> void *arr = malloc(sizeof(float) + sizeof(bool));
13:18:07 <skypers> and then we can copy the float and the bool using offsets
13:18:12 <skypers> I just need that in Haskell
13:18:15 <geekosaur> so an untyped and untypeable mess :/
13:18:34 <geekosaur> and you "just" need this untyped and untypeable mess in a strongly typed language
13:18:52 <skypers> geekosaur: well
13:18:54 <skypers> for now
13:19:06 <skypers> I have an interface for that
13:19:09 <skypers> though Ptr ()
13:19:35 <skypers> for instance, you HAVE to define a function that takes a (Float,Float) -> IO (Ptr ())
13:19:43 <skypers> maybe it’s not the best idea?
13:19:49 <skypers> maybe it’s not even possible'
13:21:00 <simpson> skypers: Why do you *have* to define such a function?
13:21:02 <sellout-> “Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.2” – my package isn’t depending on haskell98 directly. Any easy way to find which package is still relying on haskell98?
13:21:23 <skypers> simpson: because look
13:21:29 <skypers> imagine you have (Float,Float) and Int
13:21:49 <skypers> and you want in any possible way to poke both the values in a single Ptr a
13:21:58 * hackagebot diagrams-builder 0.4.2 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.4.2 (BrentYorgey)
13:22:01 <geekosaur> castPtr
13:22:01 <skypers> the thing is
13:22:20 <skypers> I can’t make a a special case depending on (Float,Float) and Int
13:22:21 <simpson> Like a union?
13:22:42 <skypers> because one may want to add a Matrix just after!
13:22:46 <skypers> yeah well no
13:22:56 <simpson> :t poke
13:22:57 <lambdabot> Not in scope: `poke'
13:23:18 <skypers> I still wonder how to perform that
13:23:45 <tarruda> Did anyone experience cabal not generating the pre-linked object after last upgrade?
13:23:49 <simpson> What's wrong with something like `pokeStuff (a, b, c) = poke a >> poke b >> poke c` then?
13:24:28 <skypers> simpson: in which array would you poke that?
13:25:01 <simpson> Oh, right. Derp, haven't done Ptr stuff in a while. I guess I don't understand what you're building.
13:25:24 <skypers> simpson: it’s a general interface for my 3D engine’s deferred renderer’s material system
13:25:42 <skypers> OpenGL buffers are untyped memory area
13:25:51 <skypers> you can push anything you want in there
13:26:03 <skypers> and you can bind some of its range to a typed version
13:26:15 <simpson> skypers: Well, "untyped" to you, maybe, but your GPU certainly has an idea of what kinds of types are in there.
13:26:26 <skypers> sure simpson
13:26:28 <skypers> through flags
13:26:41 <skypers> like
13:26:44 <skypers> GL_FLOAT
13:26:47 <skypers> for float
13:26:48 <skypers> and so on
13:26:56 <skypers> I just want to do the same damn thing in Haskell :D
13:27:03 <skypers> it’s harder than I’ve expected
13:27:09 <geekosaur> surely there is a better way to do this than untyped bit banging
13:27:14 <simpson> skypers: Okay. So, first off, you *have* seen the various OpenGL stuff in Haskell?
13:27:43 <skypers> simpson: yeah, and I just use OpenGL.Raw
13:28:11 <simpson> skypers: Also, pretend that you and your GPU have the same idea of what's gonna be in that buffer. Treat it as an array of Floats or whatnot, and then stuff Ptr Float in there instead of Ptr () .
13:28:37 <skypers> no, it’s not a good idea
13:28:54 <skypers> Float structure is not the same as Int
13:29:03 <skypers> plus it’s bigger than Bool or Char
13:29:37 <skypers> well
13:29:46 <skypers> unifying all the types to Float might work actuall
13:29:47 <skypers> y
13:29:48 <simpson> Yes, GL_UNSIGNED_CHAR is also smaller than GL_FLOAT. So?
13:30:04 <arkeet> what about Double
13:30:08 <simpson> Why "unify"? Why not simply expose this all the way up, the same way that the OpenGL Haskell bindings do?
13:30:14 <skypers> actually, the internal format of my buffer is GL_RGBA32F
13:30:16 <skypers> so it’s float
13:30:38 <simpson> (Float, Float, Float, Float) rather. :3
13:30:38 <skypers> because I write an engine, it has to be abstracted
13:30:49 <skypers> I already have my own OpenGL binding now
13:30:51 <skypers> yeah
13:30:52 <simpson> Yes. Have you seen the abstracting typeclasses in Gl?
13:30:59 <skypers> (Float,Float,Float,Float) might work
13:31:13 <skypers> simpson: in which package?
13:31:15 <skypers> OpenGL?
13:31:33 <skypers> I read it and it’s a bit complicated for what it does
13:31:35 <skypers> like MVar
13:31:58 * hackagebot diagrams-haddock 0.2.1.4 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.1.4 (BrentYorgey)
13:32:23 <skypers> StateVar
13:32:25 <skypers> sorry*
13:32:57 <simpson> It might be a little non-intuitive at first, but it's also solved *all* of your problems already.
13:34:06 <skypers> well, I don’t actually see the need for StateVar in OpenGL
13:34:14 <simpson> How would you do it instead?
13:34:14 <skypers> every OpenGL object are just GLuint
13:34:24 <simpson> And what about the state of the GL context?
13:34:34 <skypers> what about it?
13:34:48 <simpson> Well, you have to set it at some point. Things like glClearColor(), etc.
13:35:08 <simpson> GL is a big state machine. You set a bunch of state and then you draw.
13:35:29 <Hodapp> sounds like a confused CPU >_>
13:35:39 <skypers> simpson: yeah
13:35:41 <skypers> and then?
13:35:41 <solrize> anyone know if Haskell Cast is audio-only, or is it video too?  the page about it is self-contradictory
13:35:46 <skypers> you don’t need StateVar for that
13:36:03 <simpson> skypers: How would you prefer to express calls to these state-setting functions, then?
13:36:18 <skypers> simpson: just as OpenGL.Raw does it?
13:36:26 <skypers> I just have some hn
13:36:29 <skypers> hm*
13:36:37 <skypers> some helpers
13:36:47 <skypers> I have a GL monad, and some stuff around it
13:36:56 <simpson> skypers: Okay. That's fine. StateVar is a similar helper: It abstracts the idea that you can both *get* and *set* this state.
13:37:09 <skypers> simpson: well
13:37:21 <skypers> what’s the statevar for glClearColor()?
13:37:23 <simpson> And then it provides things like *modifying* state on top of that. Similar to e.g. the State monad.
13:38:00 <skypers> simpson: my engine rather works as a giant stack
13:38:04 <yesthisisuser> when I installed the latest version of cabal from github .. it installed the binary to ~/.cabal/bin .. but the old cabal-install is still under /usr/bin
13:38:07 <skypers> there’s no state
13:38:09 <skypers> for instance
13:38:12 <skypers> when I do a bind
13:38:13 <yesthisisuser> I followed the instructions from here http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
13:38:15 <skypers> on anything
13:38:18 <skypers> the unbind is auto
13:38:26 <yesthisisuser> is it safe to remove the old binary or?
13:38:29 <skypers> so I don’t really see the need for StateVar, simpson
13:38:34 <simpson> skypers: glGet(GL_COLOR_CLEAR_VALUE)
13:38:42 <simpson> ...Which I had to look up, BTW. Not obvious.
13:38:46 <geekosaur> probably not but the usual convention is make sure ~/.caba/bin is before /usr/bin in $PATH
13:38:52 <simpson> skypers: It's not a *need*. It's a nice-to-have.
13:38:54 <geekosaur> and you probably need `hash -r` in your current shell
13:39:11 <geekosaur> your system package anager probably won't let you remove the system one
13:39:15 <geekosaur> *manager
13:39:19 <yesthisisuser> geekosaur: ah.. ok. thanks i'll try that
13:39:29 <skypers> oh simpson ok
13:39:35 <skypers> we weren’t talking about the same thing
13:39:44 <skypers> well for now, I don’t have anything around that
13:39:52 <skypers> I just call wrappers functions
13:40:39 <simpson> skypers: And the nice thing is that I don't have to remember GL_COLOR_CLEAR_VALUE, or exactly which glGet type it is (glGet4fv, right?). I just have to know that glClearColor() is a C function, and thus there's a StateVar called clearColor.
13:41:00 <skypers> well
13:41:02 <simpson> Anyway, best of luck; I've got a meeting.
13:41:19 <skypers> the problem with your approach is that it’s too general
13:41:37 <skypers> $= 3 could refer to I don’t know what, or a uniform
13:41:46 <skypers> it’s a bit astonishing I guess
13:42:36 <lpaste> vamega pasted “Taxes” at http://lpaste.net/96246
13:43:25 <alllex229> some question how can i catch some recursion steps of an recursive function?
13:43:41 <vamega> In the above paste I see the error message "Not in scope" for all the values I read in from the command line.
13:43:55 <vamega> Can someone explain to me why they are not in scope at that point
13:44:30 <alkabetz> vamega: Can you paste your error, please?
13:44:34 <Cale> vamega: Because the 'where' is part of the declaration as a whole
13:44:54 <Cale> vamega: If there were multiple guards, it would scope *over* all the guards
13:44:59 <Cale> What you want is probably let
13:45:00 <nooodl> you want "let takeHomePreTax = ..." in your "do" block
13:45:02 <lpaste> vamega pasted “Errors” at http://lpaste.net/96248
13:45:04 <Cale> yeah
13:45:11 <nooodl> (also you want "main :: IO ()" not "main :: IO")
13:45:26 <lpaste> Cale annotated “Taxes” with “Taxes (annotation)” at http://lpaste.net/96246#a96249
13:45:44 <Cale> oh, good catch
13:46:03 <lpaste> Cale revised “Taxes (annotation)”: “No title” at http://lpaste.net/96249
13:46:06 <jle`> yeah you can just think of it as where syntax is incompatible with do syntax
13:46:28 <jle`> as in don't do it.
13:46:41 <Cale> The where clause isn't part of the expression
13:46:56 <jle`> would it make sense to define a where clause in the context of a line of a do block?
13:47:06 <jle`> i think it would.
13:47:10 <vamega> Interesting.
13:47:12 <jle`> that's just not how haskell does it.
13:47:17 <vamega> The let there has the same syntax as ghci
13:47:37 <vamega> i.e not of the form let <bindings> in <expression>
13:47:52 <Cale> Only inside of a let or case
13:48:05 <jle`> you can think of ghci as living inside of a do block in the IO monad
13:48:23 <Cale> vamega: Yeah, that's part of the translation of do-syntax
13:48:29 <jle`> plus with those special commands (:i, :t)
13:48:45 <Cale> do { let { <decls> } ; <stmts> } ---> let { <decls> } in do { <stmts> }
13:49:00 <jle`> you can do x <- readLn in ghci too
13:49:08 <nooodl> hmmm what's the "idiom" for specifying what type of value you want to read? would you write something like "n <- (readLn :: IO Int)"?
13:49:34 <Cale> nooodl: Usually you just use n somewhere later which determines the type
13:49:37 <Iceland_jack> nooodl: Often you don't need to specify it, if it can be inferred by later usage
13:49:54 <Iceland_jack> but if it cannot be inferred, then you can do what you posted and drop the parentheses
13:50:04 <nooodl> ah. yeah
13:50:05 <vamega> Yeah I had to to uncomment the roth401k line
13:50:13 <vamega> Since that hadn't been used quite yet.
13:50:16 <jle`> would you ever have the annotation at where you eventally use it?
13:50:25 <jle`> instead of at the readLn
13:50:36 <jle`> which is more idiomatic?
13:50:45 <nooodl> probably at the readLn
13:50:46 <Cale> I would
13:50:50 <nooodl> it'd just feel cleaner to me
13:50:53 <Iceland_jack> It depends but generally at the source
13:50:56 <Kams_> Hmm as a new haskeller I was unaware that arbitrary functions had access to data that wasn't passed into them or defined inside of them
13:50:56 <hseg> Writing some LaTeX code in which I'll have some Haskell code samples. Suggestions for how to typeset the code?
13:51:08 <Cale> Kams_: ?
13:51:28 <jle`> hseg: maybe look at how pandoc typesets lhs?
13:51:30 <Cale> Kams_: What are you referring to?
13:52:17 <Kams_> Cale: I didn't know you could define variable x somewhere outside of function f, and then use variable x in the function without passing it in as parameter
13:52:20 <johnw> nooodl: you could also say (n :: Int) <- readLn
13:52:30 <Cale> Oh, sure, so long as it's in scope you can.
13:52:35 <nooodl> johnw: yeah i was doubting between that and what i wrote
13:52:43 <nooodl> and also specifying the type later i guess
13:52:48 <Iceland_jack> nooodl: Sometimes later can be nice
13:52:59 <Cale> Kams_: Functions capture the values of all the free variables in their body at their point of definition.
13:53:03 <Kams_> Hm, I thought FP style or something prevented that (wasn't entirely sure, just an assumption)
13:53:18 <Cale> This is usually implemented using a data structure called a closure.
13:53:26 <Iceland_jack> It really depends on the program to be honest, but generally it's nice to entangle the source of something with its type
13:54:01 <jle`> Kams_: you can think of it as function declarations on the same 'level' basically define a tuple of functions that can refer to eachother.
13:54:09 <jle`> er, tuple of functions and values
13:54:26 <Cale> A closure is a pair consisting of the code for a function body together with a dictionary which maps the free variables that code refers to, to actual values.
13:55:22 <Kams_> Makes sense, if you can call outside functions than it only makes sense to be able to call variables from outside the function
13:55:24 <Cale> But you don't have to think on that level, you can just imagine that the functions are being produced by substituting the values into the body.
13:55:42 <Iceland_jack> nooodl: If you're wondering about the difference between:
13:55:43 <Iceland_jack>     'n ← readLn ∷ IO Int' and 'n ∷ Int ← readLn'
13:55:43 <Iceland_jack> I'd go with the second just because of a simpler type
13:55:47 <Iceland_jack> doing the exact same job
13:56:00 <nooodl> yeah
13:56:06 <Cale> e.g. if x = 5 is in scope then  (\t -> t + x)  will be (\t -> t + 5)
13:56:13 <Iceland_jack> but the best situation is of course where the compiler can infer the type for you
13:56:29 <Kams_> As an imperative programmer I'm used to scope and all, just wasn't sure how FP did all of that
13:57:04 <Iceland_jack> If that's an option (e.g. by defining a local function and annotate that), I'd generally go with that
13:57:13 <tdammers> scope and functional vs. imperative are mostly orthogonal issues though
13:57:56 <jle`> is there a reason why haskell does not allow n :: Int <- readLn, without extensions?
13:58:06 <Kams_> Yeah, probably, I'm not aware much of the specifics of their differences beyond the well known basic stuff
13:58:14 <hpc> jle`: even with extensions it can't be done
13:58:21 <johnw> you need parens
13:58:35 <jle`> er yeah, i mean with the parents
13:58:36 <jle`> parens
13:58:39 <Iceland_jack> foo = do
13:58:39 <Iceland_jack>   a :: Int <- readLn :: IO Int
13:58:39 <Iceland_jack>   print a
13:58:43 <Iceland_jack> this compiles for me :)
13:58:50 <johnw> huh
13:58:59 <c_wraith> No particular reason, though.  It just wasn't believe to be useful.  Design mistake.
13:58:59 <hpc> oh, i thought you meant unsafePerformIO
13:59:09 <c_wraith> *believed
13:59:14 <Cale> Kams_: But yeah, it's important to know that this can happen with functions especially, because for example, you can have things like:  f = let { x = 5 } in (\t -> x + t) and then n = let { x = 10 } in f x
13:59:30 <jle`> it must have to be related with why you can't do something like \(x :: Int) -> ...
13:59:42 <jle`> no particlar reason?
13:59:44 <johnw> jle`: you can do that with ScopedTypeVariables
13:59:47 <c_wraith> jle`: it's the exact same thing.  You can't have signatures in a pattern match
13:59:55 <jle`> yeah, i mean without extensions
13:59:58 <c_wraith> jle`: which is a design mistake, in my opinion
13:59:59 <jle`> why it is disabled by default
14:00:05 <jle`> there is no motivation?
14:00:07 <Cale> Kams_: Because things are statically scoped, that'll result in 15
14:00:09 <c_wraith> because that's what the language spec says
14:00:10 <johnw> still not sure what that has to do with type variable scoping, though...
14:00:26 <jle`> it was not an intentional design decision by the language?
14:00:45 <Cale> Kams_: In a dynamically-scoped setting, it might produce 20, but dynamic scope is something everyone should agree is a terrible idea.
14:00:55 <c_wraith> johnw: yeah, it was its own extension at some point.
14:01:00 <c_wraith> Cale: ImplicitParams. :P
14:01:33 <frxx> Kams_ most imperative/OOP languages with lambda support allow you to access variables in scope within a lambda
14:01:59 <Cale> In an imperative setting though, you have a lot of weird issues which come from mutability
14:02:06 <frxx> indeed
14:02:11 <Kams_> :)
14:02:28 <c_wraith> Which is why older java required you to only access final variables in locally-defined functions.
14:02:29 * Kams_ has enjoyed the haskell ride
14:02:52 <Cale> Does the lambda capture the value contained in the mutable cell at the time that the function is defined, or does it capture the mutable cell itself, i.e. the thing which the variable actually is the name of?
14:02:58 <jle`> java has anonymous functions?
14:03:12 <c_wraith> jle`: no, it has anonymous classes with named functions inside them
14:03:19 <jle`> ah
14:03:48 <frxx> in python for example [lambda: x for x in range(10)] <- all generated lambas will refer to the same x, all of them having the value of 10
14:04:16 <frxx> or rather 9
14:04:20 <jle`> Cale: well if the value is an object (a pointer/reference), it doesn't make any sense to capture the value and not the reference
14:04:29 <schell> i've run into an error i've never seen: cannot find normal object file ‛dist/build/snap/snap-tmp/Snap/StarterTH.dyn_o’ while linking an interpreted expression
14:04:34 <Cale> In Haskell, this distinction is made very clear. If you have a lambda which captures an IORef for instance, there's no doubt about what is going on, and if you want to capture the present value of that IORef, you'd better explicitly read it first.
14:04:51 <frxx> java will supposedly get anonymous functions next year
14:04:51 <Cale> jle`: But all mutable variables are implicitly references.
14:05:11 <Cale> jle`: Which is what makes the issue muddy in most imperative languages
14:05:52 <jle`> yeah, your capture-the-value behavior is probably not implementable unless every object has a cloning or deep cloning mechanism by requirement
14:06:19 <jle`> but i see what you mean by the fact that there is muddy behavior that is not explicit/obvious
14:06:40 <Cale> If I have an int x in Java, for instance, x is not really the name of a specific int value, it's the name of a memory location where an int value is stored, and that value may change in the future.
14:07:17 <Cale> Does the lambda capture the location or the present value? Java doesn't even have a way to refer to the value itself with a name!
14:07:18 <jle`> so in this case, it's not obvious if the scoping should capture the value (which it can) or the reference to the value?
14:07:35 <Cale> yeah
14:08:51 <beelike> what does C# do? it has value types as well
14:13:29 <Cale> beelike: I believe it captures the mutable cells
14:14:41 <dacc> is there a generic way to get the additive identity for a type?
14:15:02 <dacc> e.g. Num -> 0, list -> [], etc.
14:15:04 <Cale> beelike: http://msdn.microsoft.com/en-us/library/vstudio/bb397687.aspx#sectionToggle5
14:15:23 <Cale> dacc: Not quite, but there is the Monoid class
14:15:39 <quchen> dacc: Not directly, but the Monoid typeclass encapsulates an identity.
14:15:45 <Cale> dacc: and for numbers, if you want the *additive* identity, you'll need to use the Sum wrapper
14:16:14 <Cale> > foldr mappend mempty [Sum 1, Sum 2, Sum 3]
14:16:15 <lambdabot>   Sum {getSum = 6}
14:16:28 <dacc> Cale, quchen: cool thanks, i'll take a look
14:16:30 <Cale> > foldr mappend mempty [[1,2,3],[4,5],[6,7,8]]
14:16:31 <lambdabot>   [1,2,3,4,5,6,7,8]
14:16:49 <Cale> > foldr mappend mempty [Product 1, Product 2, Product 3]
14:16:50 <lambdabot>   Product {getProduct = 6}
14:17:08 <johnw> Cale: you mean, mconcat?
14:17:18 <quchen> foldr mappend mempty = mconcat, by the way.
14:17:19 <johnw> :t msum
14:17:20 <lambdabot> MonadPlus m => [m a] -> m a
14:17:25 <Cale> (I could also use mconcat, but that would mean that I didn't get to use mempty explicitly)
14:17:29 <johnw> ah
14:17:50 <Cale> oh, Sum and Product are instances of Num
14:18:00 <Cale> er, no they aren't
14:18:01 <Cale> misread
14:18:09 <Cale> They kind of ought to be
14:19:49 <Cale> I really wish I knew why my middle click scroll doesn't work on Haddock pages.
14:19:53 <jle`> > mempty :: Int
14:19:54 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:19:54 <lambdabot>    arising from a use of...
14:20:06 <jle`> > mempty :: Sum Int
14:20:07 <lambdabot>   Sum {getSum = 0}
14:20:13 <jle`> > mempty Product Int
14:20:14 <lambdabot>   Not in scope: data constructor `Int'
14:20:15 <lambdabot>  Perhaps you meant one of these:
14:20:15 <lambdabot>    `I...
14:20:25 <jle`> > mempty :: [a]
14:20:26 <lambdabot>   []
14:20:31 <Cale> > mempty :: Product Int
14:20:32 <lambdabot>   Product {getProduct = 1}
14:20:36 <jle`> just as a direct answer to dacc's question
14:20:54 <jle`> of accessing the identity directly
14:22:24 <jle`> > mempty :: Maybe [a]
14:22:25 <lambdabot>   Nothing
14:22:33 <jle`> i wonder what the monoid instance for maybe is used for
14:22:49 <jle`> > mconcat [Just 5, Nothing, Just 3]
14:22:50 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
14:22:51 <lambdabot>    arising from a use of `e_153'
14:22:51 <lambdabot>  T...
14:23:01 <johnw> the Maybe monoid must wrap another monoid
14:23:06 <jle`> > mconcat [Just (Sum 5), Nothing, Just (Sum 3)]
14:23:07 <lambdabot>   Just (Sum {getSum = 8})
14:23:14 <jle`> so it ignores Nothing's
14:23:17 <johnw> yep
14:23:33 <johnw> same as mconcat . catMaybes
14:23:35 <jle`> why don't I use Any/All more often
14:23:48 <johnw> you may find that the Option type has a saner Monoid instance
14:23:51 <johnw> (from semigroups)
14:23:53 <Cale> Well, 'and' and 'or' exist
14:24:08 <Cale> as well as 'any' and 'all' in the Prelude
14:24:25 <Cale> So it's rare to actually need that monoid, except as part of some kind of lifted instance
14:24:40 <simpson> Or with Writer.
14:24:44 <Cale> yeah
14:25:09 <dacc> jle`: thanks
14:25:43 <johnw> I use Last a lot
14:25:57 <johnw> but I prefer the Last Semigroup when I usually use it
14:26:39 <c_wraith> that's because it makes way more sense as a Semigroup
14:26:52 <c_wraith> since it doesn't inherently have an identity
14:27:28 <jle`> > mempty :: Last a   -- ?
14:27:29 <lambdabot>   Last {getLast = Nothing}
14:27:43 <johnw> i don't even import Data.Monoid anymore, just Data.Semigroup, which pulls in what I need from Data.Monoid for the most part
14:27:50 <simpson> newtype Last a = Last { getLast :: Maybe a } -- IIRC.
14:27:55 <simpson> Wow, thanks lag. :T
14:32:13 <jle`> what is wrong with Maybe that requires Option?
14:32:30 <jle`> *necessitates
14:32:48 <supki> jle`: bad Monoid instance
14:34:02 <simpson> What's Option?
14:34:38 <c_wraith> Option is isomorphic to Maybe, except the Monoid instance makes more sense.
14:34:58 <simpson> Oh. Where's it defined? I've never heard of it.
14:35:16 <c_wraith> It's in the semigroup package, I think
14:37:20 <acowley> ?hackage semigroups
14:37:21 <lambdabot> http://hackage.haskell.org/package/semigroups
14:38:49 <johnw> maybe under the kmett regime we could even fix Maybe
14:39:44 <edwardk> johnw: not in the next couple of years
14:39:55 <johnw> I didn't say edwardk just so you wouldn't notice!! :)
14:40:17 <c_wraith> That seems like a dangerous thing to change.  It would break some programs, but they'd still compile.
14:40:24 <johnw> my plan is to gradually emplant the idea of implicit acceptance of whatever changes you decide to make...
14:43:36 <jle`> haha
14:43:49 <quchen> johnw: A benevolent dictator without regrets!
14:45:22 <skypers> night
14:48:34 <yesthisisuser> so when I use cabal sandbox i have to create a normal cabal configuration file first using cabal-install or?
14:49:41 <ParahSai1in> just do sandbox init
14:51:41 <danharaj> :t mfix
14:51:42 <lambdabot> MonadFix m => (a -> m a) -> m a
14:52:13 <johnw> @src mfix
14:52:13 <lambdabot> Source not found.
14:52:16 <c_wraith> :t mfix return
14:52:17 <lambdabot> MonadFix m => m a
14:52:26 <johnw> > mfix return
14:52:27 <lambdabot>   No instance for (Control.Monad.Fix.MonadFix m0)
14:52:28 <lambdabot>    arising from a use of `e...
14:52:31 <c_wraith> johnw: it's part of the class
14:52:39 <johnw> > mfix (return :: () -> IO ())
14:52:40 <lambdabot>   <IO ()>
14:52:55 <johnw> ah
14:53:00 <c_wraith> johnw: the implementation of mfix varies.
14:53:05 <johnw> right
14:53:26 <yesthisisuser> when i do sandbox init, and then cabal install, it says: No cabal file found
14:54:19 <dcoutts_> yesthisisuser: right, cabal sandbox init makes an environment for installing packages into
14:54:28 <dcoutts_> so that's not the same thing as a package
14:54:50 <dcoutts_> a .cabal file describes a package
14:55:08 <jle`> yes you also need a sandbox
14:55:10 <jle`> er
14:55:12 <jle`> a cabal file
14:55:14 <jle`> for the project
14:55:20 <jle`> but you always needed this...even before sandboxes
14:55:31 <jle`> did you never have one before?
14:55:41 <jle`> cabal init should do it
14:56:05 <yesthisisuser> well with cabal-dev it is a different workflow
14:56:12 <danharaj> :t moeb
14:56:13 <lambdabot> Not in scope: `moeb'
14:56:23 <danharaj> :t loeb
14:56:23 <lambdabot> Not in scope: `loeb'
14:56:31 <jle`> yesthisisuser: oh really? my apologies
14:56:41 <danharaj> > let loeb x = go where fmap ($ go) x
14:56:42 <lambdabot>   <hint>:1:36:
14:56:42 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
14:56:52 <danharaj> @let loeb x = go where fmap ($ go) x
14:56:52 <lambdabot>  Parse failed: Parse error: EOF
14:56:56 * danharaj flips a table
14:57:01 <jle`> danharaj: you need let .. in ..
14:57:16 <danharaj> I thought lambdabot accepted ghci style lets.
14:57:21 <jle`> > let f x = x+1
14:57:22 <lambdabot>   not an expression: `let f x = x+1'
14:57:33 <jle`> oh hm.
14:57:44 <danharaj> anywho
14:57:47 <danharaj> :t wfix
14:57:48 <lambdabot>     Not in scope: `wfix'
14:57:48 <lambdabot>     Perhaps you meant one of these:
14:57:48 <lambdabot>       `mfix' (imported from Control.Monad.Writer),
14:57:56 <danharaj> wow lambdabot why don't you know anything about anything.
14:58:07 <jle`> > let f x = g x where g x = x+1 in f 1
14:58:08 <lambdabot>   2
14:58:12 <jle`> > let f x = g x where g x = x+1
14:58:13 <lambdabot>   not an expression: `let f x = g x where g x = x+1'
14:58:27 <yesthisisuser> jle`: cabal-dev init does essentially what cabal init does.. that's why i was confused
14:58:33 <jle`> oh really?
14:58:39 <jle`> that's neat; i wish i had taken advantage of that
14:58:51 <jle`> danharaj: your where clause doesn't do anything
14:58:52 <danharaj> edwardk: `wfix` and `extract . loeb` have the same type. Coincidence???
14:58:59 <edwardk> no idea
14:59:02 <jle`> it's not an assignment
14:59:02 <edwardk> solve it! =)
14:59:05 <danharaj> heh
14:59:50 <johnw> can extract be used everywhere that loeb can though?
15:00:24 <johnw> Copointed can make a lot of constructions type check, for example, but they don't give you much in the way of correctness
15:01:27 <danharaj> If we are using wfix then extract is subject to the comonad laws.
15:01:31 <danharaj> Copointed has no laws on its own.
15:01:38 <johnw> example: you could write join = copoint, and while it would be a valid definition for some Copointed p, it would hardly do what join is meant to do
15:02:03 <johnw> yeah, if you mean extract . loeb on comonads only, then OK
15:02:09 <johnw> i just thought loeb coered a wider ground itself
15:02:17 <johnw> but then, I should realize what you meant by wfix :)
15:02:22 <johnw> sorry
15:05:37 <johnw> edwardk: are you ready for a turkey to die?
15:05:44 <danharaj> @where fix
15:05:45 <lambdabot> I know nothing about fix.
15:05:48 <danharaj> :t fix
15:05:49 <lambdabot> (a -> a) -> a
15:05:51 <danharaj> @src fix
15:05:51 <lambdabot> fix f = let x = f x in x
15:05:51 <johnw> Data.Function.fix
15:05:58 <danharaj> oh I imported Data.Functor.
15:06:01 * danharaj freudian slip
15:07:16 <scott_> It's also in Control.Monad.Fix
15:07:52 <danharaj> I hate reexports.
15:08:00 <johnw> except when it's Data.Semigroup
15:08:13 <danharaj> sure, because I'll never import Data.Monoid again.
15:08:20 <johnw> same!
15:08:30 <johnw> "I remember the days when I used to import Data.Monoid..."
15:09:47 <gsnedders> If I have an exception from parsec that many is applied to a parser accepting ø, is there any way to find out which call to many that is? Like, which parser is involved?
15:10:07 <johnw> use <?> liberally
15:11:02 <Philippa> <?> around each candidate many
15:15:16 <gsnedders> johnw, Philippa: thanks. Turns out every single use of many is broken, hah!
15:17:43 <Philippa> gsnedders: note that many-in-many gives you that problem, because many itself accepts the empty string
15:18:21 <johnw> you may want many1 in some places
15:18:32 <c_wraith> isn't that some?
15:18:46 <johnw> oh, heh
15:19:03 <johnw> don't think I've ever used "some"
15:19:32 <Philippa> many1 is the traditional parsec name for it
15:19:41 <Philippa> I hope (but don't trust) that some is bound to it
15:19:42 <gsnedders> Philippa: Yeah, this was exactly the cause, thus many1 fixing it.
15:20:06 <Philippa> (parsec substantially predates Control.Applicative)
15:21:03 <jle`> that's interesting. parsec is commonly held up as the poster child for applicative style
15:21:05 <jle`> isn't it?
15:21:28 <johnw> i think that came later
15:21:29 <quchen> Well, parsers in general.
15:21:32 <quchen> jle`: ^
15:21:35 <johnw> initially it was the poster child for monadic parsing
15:21:57 <c_wraith> uu-parsinglib was the one that introduced Applicative, iirc.  (well, the library that become uu-parsinglib)
15:22:02 <jle`> i see
15:22:03 <Philippa> jle`: attoparsec is. Parsec's a nice place to spread it around, but tbh parsing tasks tend to warrant naming some of the intermediate semantic structures for purposes of matching against a spec
15:22:06 <johnw> I definitely don't use Control.Applicative as extensively anywhere else
15:22:23 <Philippa> I mostly use Control.Applicative for logic programming myself, but I'm weird
15:22:54 <c_wraith> I mostly use it for infix fmap.  Which is so popular it got moved into the functor lib.
15:23:00 <Philippa> heh, quite
15:23:06 <Philippa> `liftM` begone!
15:23:20 <acowley> I think I tend not to use packages whose names have the authors names in them
15:23:26 <acowley> which makes uu an edge case for me
15:23:45 <c_wraith> it doesn't say swierstra anywhere. :P
15:23:45 <Philippa> parsec definitely has a lot of uses that strictly-applicative style prevents though
15:24:10 <donri> acowley: so you don't use anything of torvalds, eh
15:24:12 <Philippa> parsec's job is to be the swiss army tacnuke of haskell parsing: highly capable when it comes to making sure something gets parsed, overkill for many tasks and occasionally a bit fiddly
15:24:17 <acowley> c_wraith: it's spelled funny
15:24:39 <c_wraith> I actually emailed him about a bug in uu-parsinglib once.  He's *definitely* a professor. :)
15:24:47 <acowley> donri: That's a fair point! I use OS X for the most part, but I do use Linux and it doesn't bug me there. I meant "packages" in a narrower sense
15:25:17 <acowley> My issue is that having an author's name in the package name tells me that this will bitrot and die soon
15:25:31 <donri> acowley: well git too
15:25:45 <acowley> donri: Is that what it says on Linus' birth certificate?!
15:26:03 <Philippa> acowley: yeah, see that's why I should do it more often :p If people want something that's supposed to be maintained and usable rather than what I can actually get done myself, they can fork off :p
15:26:08 <acowley> I suppose having University in the package name could be interpreted in a similarly cynical way
15:26:15 <donri> "I'm an egotistical bastard, and I name all my projects after myself. First 'Linux', now 'Git'". -- linus
15:26:39 <c_wraith> universities tend to be active longer than individual authors, at least.  Utrecht has a pretty solid CS culture, too.
15:26:47 <acowley> Philippa: That's one approach. But I'd rather if someone just inherited your code, rather than having to endure the uncertainty of a fork.
15:26:49 <jle`> ghc
15:26:54 <jle`> ?
15:26:59 <jle`> or are we talking only packages
15:27:00 <Philippa> acowley: yeah, only that forces me to keep private forks
15:27:09 <acowley> c_wraith: Yes, but it's not like the University is the one taking responsibility.
15:27:10 <johnw> is uu still in much use?  it feels like an artefact from another time, but I'm wondering if my impression is totally wrong on that
15:27:18 <Philippa> (in Flippi's case I was happy to let it be inherited)
15:27:24 <Philippa> (similarly, I'd be happy to bless what looks to be a competently-maintained fork)
15:27:32 <acowley> c_wraith: The personelle turnover rate at Unis is guaranteed to be fast
15:27:59 <acowley> c_wraith: And you are encouraging graduates to stop work on the package when it is now named after their previous place of employment
15:28:01 <c_wraith> well.  among students and non-tenured professors, at least
15:28:35 <acowley> c_wraith: There are certainly exceptions, but who do you think writes most of the code? :)
15:34:33 <xexonixxexillion> Does there exist another (i.e not equivalent) function for the type (Functor f) => f (f b -> b) -> f b that's at least as defined as (\x -> fix (\r -> fmap ($ r) x)). I can't think of any, can any of you?
15:42:46 <johnw> wouldn't parametricity guarantee that there cannot be, in terms of Functor only?
15:43:40 <quchen> johnw: Well, loeb could be a partial version of some mightier function.
15:44:07 <mgsloan> moeb dib!
15:44:16 <quchen> But that has a different type.
15:44:16 <johnw> haha
15:44:23 <johnw> :t Dune
15:44:24 <lambdabot>     Not in scope: data constructor `Dune'
15:44:24 <lambdabot>     Perhaps you meant `Dupe' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
15:44:25 <johnw> Desert Planet
15:44:32 <quchen> ?
15:44:42 <johnw> I think he was playing on "moa`dib"
15:44:45 <johnw> the main character in Dune
15:44:53 <quchen> Ah
15:44:55 * mgsloan just finished Children of Dune
15:45:02 <johnw> since he, chrisdone and I have been talknig about it a lot lately in another channel
15:45:10 <mgsloan> Also, moeb is quchen's generalized loeb
15:45:33 <acowley> I still have trouble deciding what to do with errors
15:45:37 <acowley> in libraries, that is
15:46:07 <acowley> I usually start out by putting things in Maybe or Either
15:46:20 <donri> did kmett and snoyman release their errors thing yet
15:46:21 <acowley> but then some libraries, I always want to apply error to any error messages
15:46:31 <johnw> acowley: that is exactly something I, Tekmo, snoyberg and edwardk have been discussing lately
15:46:44 <johnw> I think the best answer will be to use MonadCatch
15:46:44 <quchen> donri: I think it's just a draft (think of paper).
15:46:45 <acowley> so I end up putting that more convenient version int eh library, and then you've got two definitions for the same thing
15:46:47 <donri> oh johnw is in on it
15:46:50 <quchen> At least it was 2 weeks or so ago.
15:47:22 <johnw> donri: yeah, once the holidays resolve we need to get back on it again
15:47:33 <johnw> donri: we had reached a pretty good place last time
15:47:49 <acowley> which MonadCatch?
15:47:55 <donri> @hackage exceptions
15:47:55 <lambdabot> http://hackage.haskell.org/package/exceptions
15:47:57 <johnw> from 'exceptions'
15:48:10 <johnw> we will be making just a few tweaks to it, although nothing is permanently decided yet
15:48:27 <johnw> but the direction we're headed in will make exceptions subsume what 'failure' currently seeks to achieve
15:48:57 <johnw> so bascially, you model failure by "throwing" exceptions, which if the user wishes to analyze as an Either, will be surfaced to him in an Either
15:49:22 <acowley> There isn't a MaybeT instance
15:49:27 <johnw> that way, the library only deals with maximally information-rich error representation, while the user gets to decide how he prefers to consume them
15:50:06 <johnw> we talked about a way of allowing the user to downgrade to a Maybe representation
15:50:12 <acowley> I see, I have to use CatchT
15:50:16 <johnw> but I'm not sure there will even be a MaybeT instance
15:50:19 <johnw> s/even/ever
15:50:24 <acowley> I use EitherT and MaybeT
15:50:33 <johnw> right, CatchT is for modelling pure computations with exceptional results
15:50:35 <donri> johnw: what's the problem with failure then?
15:50:36 <acowley> well, I probably use ErrorT or whatever it's called
15:50:50 <donri> the MonadTrans instance scares me vaguely
15:50:53 <Philippa> Is there a good/nice lib for multi-error handling in an applicative yet?
15:50:57 <donri> it might be fine, but i don't know
15:51:00 <johnw> donri: failure is not a broad enough type class
15:51:10 <aaa> @pl \x -> f x >> g
15:51:10 <lambdabot> (>> g) . f
15:51:12 <johnw> donri: MonadCatch has both the catch and throw components, which you need for better laws
15:51:42 <acowley> I guess MonadCatch is what I want after all, but I'd really like it if it worked with Maybe and Either as I find them to be the obvious ways to return an error message
15:51:44 <johnw> donri: yeah, that MonadTrans instance is more utility than beauty :)
15:51:57 <donri> laws eh, i'm sold
15:52:10 <donri> don't even need to know the laws, you just mention the word "laws" and i'm sold ;)
15:52:43 <johnw> donri: you can bet that having Tekmo in the discussion keeps laws at the forefront :)
15:52:49 <acowley> johnw: What's the argument against offering Maybe and Either instances?
15:53:36 <johnw> acowley: MaybeT erases the error type, if I recall correctly
15:53:57 <johnw> and we need the error type since the new MonadCatch will be like failure, in that it will be a type parameter (or so we last decided)
15:54:37 <johnw> but that doesn't mean you can truncate an EitherT's result down to a Maybe value
15:54:40 <johnw> s/can/can't
15:54:47 <johnw> that's effectively what the 'attempt' library is about
15:54:53 <donri> EitherT (), bam, MaybeT
15:54:54 <acowley> I don't understand what you mean by erasing the error type
15:55:18 <johnw> donri: well, the EitherT instance for MonadCatch would need an error type in the Left side
15:55:34 <donri> oh right like Exception e?
15:55:38 <johnw> acowley: Either e a <-- the e represents the error information
15:55:41 <johnw> yeah
15:55:43 <acowley> Yeah, I want MaybeT e
15:55:47 <acowley> the unit is implied
15:55:51 <acowley> ahem
15:55:55 <donri> then you have no "a"
15:56:02 <acowley> Right, no 'a' here!
15:56:18 <johnw> interesting
15:56:22 <johnw> so you only care about errors?
15:56:25 <acowley> I generally use MaybeT String IO
15:56:32 <acowley> for silly things that are just side effecting
15:56:36 <acowley> but might error
15:56:40 <johnw> right
15:56:52 <acowley> in theory, I could do something with the error. In practice, I just call error with any error message
15:56:57 <johnw> i actually use MaybeT for that myself sometimes
15:57:03 <johnw> so I'll make sure this gets considered
15:57:07 <acowley> great!
15:57:18 <johnw> but for now, just think about EitherT e m () :)
15:57:30 <acowley> But there's no EitherT instance, is there?
15:57:55 <johnw> ah, not yet
15:58:04 <johnw> maybe I'll start hacking on this this weekend in fact
15:58:12 <acowley> As I said, I guess I'd just use CatchT for that
15:58:33 <acowley> But I really like the idea of having EitherT and MaybeT available, as it means client code can be naive
16:00:12 <benzrf> WOOP
16:00:27 <benzrf> my tiny lisp is sufficiently powerful to implement subtraction in terms of addition!!
16:00:30 <benzrf> :D
16:00:59 <benzrf> OTOH ive screwed myself over so much with antipatterns that adding a builtin function as simple as 'add' takes like 8 lines
16:01:10 <johnw> haha
16:01:24 <benzrf> also i accidentally made scoping work in
16:01:25 <benzrf> uh
16:01:29 <benzrf> an unfortunate manner
16:01:48 <benzrf> closures close over the scope they're in *as it is at the moment they're made*
16:02:16 <benzrf> so I need Y or something similar to implement recursion, because lambdas cant see themselves since they only become assigned after they are created
16:02:19 <benzrf> :[
16:03:03 <benzrf> at least ive gained a bit more of a sense of how functors & applicatives & monads are useful o:
16:03:08 <Philippa> benzrf: nothing wrong with that initially
16:03:12 <benzrf> [but just a lil]
16:03:15 <benzrf> Philippa: :)
16:03:19 <benzrf> want to take a look at my code
16:03:20 <Philippa> you just implemented an actual lambda :p
16:03:31 <benzrf> be sure to wear goggles lest it burn your eyes out
16:03:38 <Philippa> it's nearly midnight and I've had a long day, otherwise I'd say sure?
16:03:42 <benzrf> :P
16:03:47 <benzrf> well, wanna try out the REPL?
16:03:50 <benzrf> :3
16:04:01 <benzrf> tell me if you find any significant  bugs?
16:04:13 <benzrf> i should rly learn how to use monad transformers
16:04:14 <Philippa> heh. Tbh, I'm heading to bed shortly
16:04:17 <benzrf> ok
16:04:40 <danilo2> Hi! :) I'm learning lenses and I just hit a strange problem. Why the following short code snippets gives compilation error? If I comment out line 6 (NOP constructor) it works ... Where this error comes from? http://lpaste.net/96256
16:05:52 <johnw> try removing the type signature for "test" and see if it compiles
16:06:17 <johnw> I'm not sure if Lens' is too restrictive there
16:06:47 <johnw> i've sorted of given up on writing lens type signature; I just let GHC tell me what it should be in a warning, simplifying if I can
16:07:01 <benzrf> heh
16:08:29 <danilo2> johnw: with -XNoMonomorphismRestriction it indeed compiles
16:08:48 <danilo2> johnw: but it is Lens, isnt it? And why it compiles when we comment the "NOP" constructor?
16:09:14 <johnw> it's not a Lens when you have the NOP constructor, it's a prism
16:09:43 <johnw> in the same way that _1 is a lens, but _Left is a prism
16:10:00 <johnw> i.e., name may not always refer to something, and a lens always refers to something
16:10:07 <benzrf> prism
16:10:08 <johnw> NOP ^. name = ....?
16:10:08 <benzrf> :|
16:10:08 <danilo2> johnw: Oh, I didnt hear about Prism before
16:10:17 <johnw> but NOP ^? name = Nothing
16:10:39 <danilo2> johnw, ok,, so what is the type signature of test?
16:10:50 <johnw> comment out what you have, and let GHC tell you with -Wall
16:11:11 <acowley> Or use flymake and hit M-t
16:11:11 <johnw> also, you make need makePrisms, I'm not sure though
16:11:14 <benzrf> i cant see -Wall without seeing Wall
16:11:31 <johnw> benzrf: In my head I say "dash wall"
16:12:06 <benzrf> hur
16:12:14 <danilo2> jahnw: ghc tells it is " Control.Applicative.Applicative f => (String -> f String) -> Expr -> f Expr", but I think we can write it better using Lenses or Prisms, cannot we?
16:12:21 <benzrf> can anybody test out STL? [thats my Shitty Tiny Lisp's name]
16:12:22 <acowley> When I was learning to program, I thought -Wall was saying there was a high wall your code had to get over :/
16:12:26 <benzrf> harovali:
16:12:27 <benzrf> *ha
16:12:28 <johnw> :t Prism' String Expr
16:12:29 <lambdabot> Not in scope: data constructor Prism'
16:12:29 <lambdabot> Not in scope: data constructor `String'
16:12:29 <lambdabot> Not in scope: data constructor `Expr'
16:12:41 <johnw> or rather, Prism' Expr String
16:13:23 <johnw> danilo2: essentially, prisms are dual to lenses, in the way that coproducts are dual to products
16:13:24 <acowley> Oh darnit
16:13:28 <benzrf> hmm, when using parsec, how can I indicate that i would like several of something, with whitespace allowed but not required in between?
16:13:37 <benzrf> i.e. () () () or ()() () would work
16:13:40 <danilo2> johnw, nope - another big error than: Could not deduce (p ~ (->))     from the context (Choice p, Control.Applicative.Applicative f)
16:13:49 <benzrf> [if the thing was 'char '(' >> char ')'
16:13:56 <johnw> many (manyTill anyChar (try whitespace))?
16:14:02 <benzrf> hmmm
16:14:10 <benzrf> meh
16:14:17 <benzrf> ill just stick with necessary whitespace
16:14:18 <benzrf> :[
16:14:20 <acowley> Why can't I have an instance MonadError String IO?
16:14:26 <benzrf> acowley: explain
16:15:00 <acowley> I have some code that can produce error messages. I'd like to abstract how those messages are dealt with
16:15:14 <benzrf> but what do you 'cant have an instance etc'
16:15:37 <acowley> benzrf: Oh, I mean that such an instance isn't defined in mtl, so mine would be an orphan
16:15:52 <benzrf> k im out of my depth cuz i dont know about monadts yet
16:15:55 <benzrf> :\
16:16:03 <acowley> They're like monads, but crappier
16:16:17 <benzrf> bah
16:17:11 <johnw> danilo2: one sec, working on it
16:17:21 <danilo2> johnw: thank you very much!
16:17:42 <johnw> you need this: https://gist.github.com/7668590
16:17:55 <johnw> the makeLenses is unnecessary
16:18:39 <johnw> if Accessor had multiple fields, you'd access them as if it were a tuple, with _1, _2, etc.
16:18:52 <johnw> and you'll need to use ^? with a Prism, rather than ^.
16:18:58 <johnw> because the result is optional
16:19:23 <benzrf> I only associate ^? with that unpleasant feeling you get when you realize youre using unbuffered stdin
16:19:28 <johnw> > Left 10 & _Left .~ Just 20
16:19:30 <lambdabot>   Left (Just 20)
16:19:33 <johnw> > Right 10 & _Left .~ Just 20
16:19:34 <danilo2> johnw: hmm so we cannot use field names like "name" anymore?
16:19:34 <lambdabot>   Right 10
16:19:49 <johnw> but a cool thing about them is that you can write "set" expressions that only take effect if the given constructor is in play
16:20:05 <johnw> danilo2: not that I know of, but I could be wrong there; I'd ask in #haskell-lens
16:20:16 <johnw> > Left 10 & _Left .~ 20
16:20:18 <lambdabot>   Left 20
16:20:27 <johnw> > Left 10 ^? _Left
16:20:28 <lambdabot>   can't find file: L.hs
16:20:31 <johnw> bah
16:20:37 <benzrf> :t (^?)
16:20:37 <lambdabot> s -> Getting (First a) s a -> Maybe a
16:20:41 <benzrf> ...
16:20:43 <benzrf> @info Getting
16:20:43 <lambdabot> Getting
16:20:44 <danilo2> johnw: hmm, I would be very thankfull.
16:20:46 <benzrf> :|
16:20:49 <benzrf> @info echo
16:20:50 <lambdabot> echo
16:20:52 <benzrf> yup
16:20:58 <benzrf> @info i can spaces
16:20:58 <lambdabot> i can spaces
16:21:01 <benzrf> huh
16:21:07 <danilo2> johnw: this is a little owful if I would have to use _1 _2 _3 etc instead of proper names ... :(
16:21:22 <Hafydd> @faq can lambdabot spacse?
16:21:22 <lambdabot> The answer is: Yes! Haskell can do that.
16:21:34 <acowley> Why can't you have names?
16:21:41 <acowley> I missed the setup to this question
16:22:11 <danilo2> acowley: http://lpaste.net/96256
16:22:12 * hackagebot blank-canvas 0.3.1 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.3.1 (AndyGill)
16:22:44 <acowley> Oh
16:22:47 <danilo2> acowley: the only solution so far is johnw's one: https://gist.github.com/jwiegley/7668590 and than I'll access fields in Expr datatype by _1 _2 etc, not by names
16:22:53 <benzrf> @faq
16:22:53 <lambdabot> The answer is: Yes! Haskell can do that.
16:22:56 <benzrf> Hafydd:
16:22:58 <benzrf> *ha
16:23:04 <benzrf> @faq can i have general mutable state
16:23:08 <lambdabot> The answer is: Yes! Haskell can do that.
16:24:03 <acowley> I guess Maybe Expr is out of the question
16:24:22 <acowley> You could always define the name prism yourself, though, right?
16:24:58 <johnw> i don't think name is a prism in that case
16:25:05 <johnw> it's an accessor of the product within the coproduct
16:25:14 <johnw> i've just asked in #haskell-lens
16:25:20 <acowley> But his product has only one component
16:25:23 <danilo2> johnw, acowley: hey, but look, If I not type the test function, I can use "name|" with lenses: http://lpaste.net/96256
16:25:33 <johnw> acowley: well, that's true
16:25:33 <danilo2>  johnw, acowley: (see the annotation)
16:25:57 <danilo2>  johnw, acowley: so, what is the type of "test" function?
16:26:02 <johnw> use -Wall
16:26:04 <johnw> GHC should tell you
16:26:21 <johnw> ah, right
16:26:21 <danilo2> johnw: it tells me Control.Applicative.Applicative f => (String -> f String) -> Expr -> f Expr
16:26:32 <acowley> well that's promising
16:26:38 <acowley> but I don't trust TH
16:26:38 <danilo2> johnw: so I think we can write it somehow better?
16:26:42 <acowley> so I'd write my own prism
16:27:07 <johnw> ah, cool
16:27:18 <danilo2> acowley: but I'm not "makingPrisms" - it works with lenses, see the annotate to: http://lpaste.net/96256
16:27:20 <johnw> this does just work: https://gist.github.com/7668677
16:28:07 <johnw> you don't need to deal with prisms after all
16:28:09 <johnw> good to know!
16:28:16 <danilo2> johnw, acowley : I'm new to lenses, so I can be wrong, but can we write the type of "test" more beautifull ?
16:28:19 <johnw> trying to access "name" within a NOP value returns mempty
16:28:24 <acowley> What does NOP & name .~ "John" do?
16:28:42 <johnw> ""
16:28:45 <johnw> oh
16:28:48 <johnw> it should do nothing at all
16:29:21 <johnw> danilo2: test :: Traversal' Expr String
16:29:42 <johnw> a traversal is a lesser than a lens, in that it may point at nothing at all, or even more than one thing
16:29:43 <acowley> I don't like that it's a lens
16:30:07 <danilo2> johnw: ok, it works. I feel I've got a long way learning lenses
16:30:19 <danilo2> johnw, acowley: where have you learned lenses from ?
16:30:23 <johnw> Main.Accessor "John" 41 & name .~ "Doug"
16:30:26 <johnw> Accessor {_name = "Doug", _foo = 41}
16:30:29 <johnw> NOP & name .~ "Doug"
16:30:31 <johnw> NOP
16:30:41 <seanparsons> If I put just the type of a data declaration (and no "(..)" after it) in the module definition that means that users can't access the constructors right?
16:30:49 <johnw> danilo2: this channel and #haskell-lens, edwardk's many recorded videos on the subject, the Haddocks, writing code
16:30:58 <johnw> seanparsons: exactly
16:31:12 <johnw> seanparsons: they can still use instances though, I believe
16:31:16 <acowley> johnw: What does NOP ^. name give?
16:31:21 <johnw> mempty
16:31:25 <johnw> i.e., ""
16:31:27 <stolaruk> johnw: Have you found haskell-lens to be newby friendly? Just curious
16:31:35 <johnw> stolaruk: yes
16:31:36 <acowley> :t (^.)
16:31:37 <lambdabot> s -> Getting a s a -> a
16:31:37 <stolaruk> I mean the channel
16:31:38 <danilo2> johnw: I didnt know edwardk made any videos! I'm gonna watch them :) Anyway thank you very much for your help and your acowley also! :)
16:31:39 <johnw> edwardk is especially newb friendly
16:31:47 <acowley> danilo2: np!
16:31:57 <acowley> How does it give mempty?
16:32:01 <johnw> danilo2: http://www.youtube.com/watch?v=cefnmjtAolY
16:32:04 <stolaruk> johnw: Cool, I'm new to lenses and I like em but sometimes I have some questions
16:32:24 <johnw> stolaruk: #haskell-lens is a great place for questions
16:32:27 <stolaruk> I saw the above video but it was mostly way over my head
16:32:39 <seanparsons> johnw: That's totally fine, just want to seal off the type so that dubious instances can't be created. It would appear however that "cabal repl" somehow rigs up ghci to ignore that restriction however.
16:33:03 <johnw> actually, in that same vein I'm going to start #haskell-conduit
16:33:03 <stolaruk> This one is a great place to start w/ lenses. http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
16:33:09 <danilo2> johnw: thank you for the link! watching it right now :)
16:33:18 <johnw> because conduit and lens are some of the most powerful libraries that I use in Haskell
16:33:44 <stolaruk> I'm writing a text adventure game; this is my first sizable Haskell project. I'm used to OOP languages where each class gets its own file, and I'm wondering how to formulate a strategy for splitting up my Haskell source code into multiple modules/files to make it more manageable. Presently I have the following modules: Main, StateHelpers, DataTypes, TheWorld. Maybe I should make a module for each major data t
16:33:44 <stolaruk> ype? What are the best practices?
16:34:11 <johnw> making a module for each data type will cause you pain
16:34:22 <johnw> unless you get into the habit of using "hs-boot" files
16:34:38 <stolaruk> Hmm ok
16:34:40 <johnw> I usually start with a Types.hs file, and put all of the types in there, only breaking them out when it makes sense to do so
16:34:58 <johnw> plus, have an Internal.hs module, for things that every module needs, but which shouldn't itself be exported to users
16:35:15 <stolaruk> johnw: Interesting, makes sense
16:35:21 <johnw> then in your cabal file, have "other-modules: Internal"
16:35:52 <johnw> after that, just name modules after the functionality they provide, keep grouping as tight as you can
16:36:06 <johnw> i.e., each module to its task
16:36:13 <stolaruk> johnw: So Types.hs would just have data declarations, newtypes, etc.?
16:36:17 <johnw> yes
16:36:31 <johnw> and instances, and usually I include helper functions that are only 1 or 2 lines long
16:36:38 <johnw> but anything bigger goes into another module
16:36:47 <stolaruk> johnw: Ok sounds like I more or less had the right strategy from the outset
16:37:31 <stolaruk> My Main module is over 600 lines now so I might split it up somehow
16:40:42 <bobcrash> If I"m understanding this correctly: http://dmwit.com/gtk2hs/
16:41:06 <bobcrash> No matter how many threads I have, -threaded, +RTK -N5, forkIO, forkOS, etc
16:41:15 <bobcrash> No two "unsafe" calls will ever run simultaneously
16:41:33 <bobcrash> if I ahve two different threads attempting to run unsafe calls, they will block each-other and grind my program to a single threaded halt
16:41:35 <bobcrash> Is that correct?
16:43:19 <dcoutts_> bobcrash: only if you follow the rule of making all Gtk+ calls from the main thread
16:43:22 <acowley> bobcrash: yes
16:43:40 <acowley> johnw: Which instance of what class is bringing the Monoid constraint to (^.) ?
16:43:48 <johnw> bobcrash: two different threads on the same OS thread, that is
16:43:56 <johnw> different threads on different OS threads will still run concurrently
16:44:22 <acowley> johnw: I think with unsafe FFI imports, all threads are blocked
16:44:33 <johnw> acowley: not an instance, the operator:
16:44:34 <johnw> (^.) :: Monoid m => s -> Traversal' s m -> m
16:44:52 <acowley> That's not the usual type
16:44:52 <dcoutts_> acowley: all Haskell threads on that capability
16:44:54 <bobcrash> So my reading of the "Foreign Imports" section is there is literally nothing I can do to make two FFI calls marked "unsafe" run simultaneously
16:45:02 <johnw> acowley: no, it has many types
16:45:15 <johnw> for Fold and Traversal' it requires Monoid, but not for any of the others
16:45:21 <dcoutts_> acowley: so johnw meant haskell threads running on different capabilities
16:45:36 <dcoutts_> bobcrash: no, that's just right
16:45:38 <dcoutts_> erm
16:45:40 <dcoutts_> just not right
16:46:11 <johnw> the article bobcrash linked to says "Calls to unsafe imports prevent all other Haskell threads on the same OS thread from running"
16:46:47 <dcoutts_> bobcrash: if you're using +RTS -N2 or higher then "unsafe" FFI calls on different cores (RTS calls them capabilities, and it corresponds sort-of to OS threads) can happen concurrently
16:48:15 <bobcrash> dcoutts_:  So I've been using +RTS -N2, and then I forkOS a second thread.  Unsafe calls from th second thread are definitely blocking unsafe calls from the first thread (main).  I'm assuming that forkOS is forking off a haskell "thread" but then binding it to the same OS thread as my main thread?
16:48:30 <dcoutts_> bobcrash: forkOS doesn't do what you think it does
16:48:42 <dcoutts_> forkOS is not the same thing as +RTS -N2
16:50:03 <bobcrash> dcoutts_:  So I'm using ghc -threaded to build, and running with "+RTS -N2".  Is there a way to get my forked haskell thread to bind to the second os thread?
16:50:17 <dcoutts_> the RTS describes this in terms of "capabilities", which is the context for evaluating Haskell code
16:50:47 <dcoutts_> multiple capabilities gives the ability to evaluate Haskell code in parallel
16:50:56 <dcoutts_> +RTS -N sets the initial number of capabilities
16:51:19 <dcoutts_> in terms of impl, only one OS thread is "animating" a capability at once
16:51:59 <dcoutts_> forkOS adds an OS thread, but it doesn't change the number of caps, so there is no more parallelism than before
16:52:32 <dcoutts_> forkOS is for cases where you need to use OS-thread local storage, e.g. for C libs that use it
16:52:54 <dcoutts_> bobcrash: yes, forkOn
16:53:10 <dcoutts_> you can pin a Haskell thread to a capability
16:55:13 <dcoutts_> bobcrash: ghc will do thread load balancing, but you can force an initial placement using forkOn
16:55:31 <hpc> and you can set affinity, too
16:58:10 <bobcrash> forkOn does no good either...  I can recompile the library with the methods marked "safe" rather than "unsafe" (I think it makes sense because they block but do not call back into haskell), and that works great...
16:58:55 <acowley> I wrote a little test program, and it seems to block with -N2
16:59:10 <bobcrash> acowley:  So I'm not crazy here, right?
16:59:30 <acowley> bobcrash: Or we're both crazy
16:59:56 <jmcarthur> acowley, dcoutts_: all threads might block if gc tries to run, though, since the parallel gc will wait for them to be ready
17:00:35 <acowley> There's not a lot of G to C in this program
17:00:41 <acowley> but maybe you're right
17:01:50 * dcoutts_ isn't quite sure what bobcrash is doing or trying to do
17:02:03 <acowley> dcoutts_: It's what we were talking about before
17:02:19 <acowley> if you have multiple threads that make FFI calls into functions imported with unsafe, all threads block
17:02:41 <bobcrash> Basically I have one "thread" which blocks on trying to read a usb device
17:02:45 <acowley> Or, bobcrash and I are doing something dumb
17:02:53 <bobcrash> and another thread copying data to a native array as it loads things from disk
17:03:05 <jmcarthur> bobcrash: generally if you find that an unsafe binding takes long enough to block noticably, then it shouldn't be unsafe
17:03:09 <bobcrash> The two threads don't share any data or use similar FFI calls
17:03:18 <lpaste> acowley pasted “unsafe FFI” at http://lpaste.net/96259
17:03:25 <jmcarthur> unless of course some other technical thing prevents you from making it safe
17:03:34 <acowley> jmcarthur: I think it was more a question of principle
17:03:40 <jmcarthur> but i can't think of anything that would prevent it
17:03:44 <bobcrash> jmcarthur:  Yeah, marking it "safe" makes everything work for me, but the fact I can't get multiple os threads working worries me if I ever dependent on somehting with TLS in teh future
17:03:49 <acowley> It's also a bit annoying, as unsafe calls are described as being faster
17:03:54 <bobcrash> Yes, that also
17:04:14 <bobcrash> If this was a C program I'd have zero issues just having one thread that blocks and waits for USB data that it receives on occassion
17:04:17 <acowley> If it's a GC thing as jmcarthur suggested, there may be some way of hacking that
17:04:23 <bobcrash> Its killing me I can't replicate that behavior here
17:04:38 <jmcarthur> bobcrash: ghc reserves the right to decide what capability a thread will run on, which i think is fine
17:04:55 <jmcarthur> bobcrash: it can't anticipate improper use of unsafe, hence blocking can occur if misused
17:05:16 <bobcrash> jmcarthur:  Fair enough.  I guess this one is really on the library authors
17:05:44 <acowley> bobcrash: I don't really follow your concern with safe
17:05:45 <dcoutts_> acowley: I'm not clear what you're trying to demonstrate with that pasted prog
17:06:20 <bobcrash> acowley:  I was mixing up two different issues.  I think safe is fine
17:06:27 <acowley> dcoutts_: The issue that bobcrash brought up initially
17:07:02 <sevak> hi I'm back, http://lpaste.net/4091314055791247360 it is really cool thanks for the help, but I have two questions
17:07:10 <jmcarthur> if it's the gc thing i mentioned, one way around is to not use parallel gc
17:07:18 <acowley> dcoutts_: You have multiple Haskell threads running on the threaded runtime with at least -N 2, and you want concurrent FFI calls
17:07:36 <dcoutts_> acowley: but you're not even forcing those threads to run on different caps there
17:07:59 <sevak> monochrom: I appreciate the emphasis on not overthinking it, I think I know what you meant
17:08:15 <sevak> and the recursive part of it is interesting too
17:08:24 <sevak> so my questions
17:08:40 <sevak> in lpaste it says "Use list literal", what is that?
17:08:59 <jmcarthur> the idea of unsafe is that for very quick functions it's nonblocking for all practical purposes, and even if they serialize like this it's not so bad. if it's not a quick function, marking it unsafe doesn't even make much sense most of the time
17:09:09 <sevak> and second, isn't it a bit convoluted to have the : [] at the end of line 6?
17:09:10 <acowley> dcoutts_: Ah, you're right!
17:09:26 <dcoutts_> bobcrash: so you don't want to mark blocking foreign calls as unsafe, eventually other cores need to GC and all cores need to take part in GC
17:09:31 <thoughtpolice> jmcarthur: hm? why does the parallel GC make a difference?
17:09:44 <acowley> So you lose the RTS's load balancing
17:09:47 <thoughtpolice> unsafe calls block everything if a GC needs to synchronize caps, parallel GC or not
17:09:47 <dcoutts_> it's not parallel vs non-parallel
17:09:53 <sevak> I originally had it generating the list backwards just uding (the mod function) : (div function)
17:10:00 <jmcarthur> thoughtpolice: only for the one case i mentioned where if the parallel gc triggers during an unsafe call it will wait for the unsafe call to complete
17:10:19 <jmcarthur> thoughtpolice: if the parallel gc isn't being used, the only way it can trigger is in a thread that is otherwise not blocked anyway
17:10:24 <sevak> is there a function that is the opposite of cons, feel like it would make it simpler
17:10:28 <dcoutts_> jmcarthur: yes, but whether it's parallel or not is not relevant
17:10:32 <sevak> aprreciate the help thanks
17:10:38 <acowley> bobcrash: So you can use unsafe if you're willing to do thread scheduling yourself
17:10:41 <dcoutts_> jmcarthur: all ghc's gc mechanism need to sync all caps
17:11:14 <jmcarthur> well, i've been able to work around this problem by disable parallel gc before, and i've tried to fill in the gaps in my mental model to compensate
17:11:18 <thoughtpolice> jmcarthur: right, but even without the parallel GC, another capability (independent of the number of GC threads) could make an unsafe call, and then the sequential GC still needs to wait for synchornization
17:11:19 <jmcarthur> *disabling
17:11:40 <bobcrash> Thanks guys.  Yeah, I'll move this library to "safe" and submit a pull request
17:11:55 <jmcarthur> if it is indeed true that the sequential gc can't run during an unsafe call at all then i must have bumped into something else by changing that rts flag
17:12:18 <thoughtpolice> acowley: also i agree with jmcarthur, efficiency of safe vs unsafe has almost never been a problem in my experience
17:12:28 <acowley> thoughtpolice: I had issues with it once
17:12:54 <acowley> thoughtpolice: So it's always stuck in my head as an annoying thing to remember to check :(
17:12:57 <thoughtpolice> oh really? which library?
17:13:04 <acowley> My own code
17:13:06 <dcoutts_> jmcarthur: Simon had a paper on allowing local generation collections without requiring all caps to sync, but that's never been integrated (turned out not to be worth it)
17:13:49 <acowley> thoughtpolice: It was probably back when I was playing with OpenCV bindings, and I assume it was a small function I was calling
17:14:05 <jmcarthur> dcoutts_: yeah, the gc is really pretty good as it stands, even for low latency applications (unless of course your heap is large enough)
17:14:16 <thoughtpolice> hm, IME unsafe is really only useful in the case you don't have callbacks and the call window is so short blocking is basically a non issue. in any other case, 'safe' overhead is normally dwarfed by the operation itself in my experience
17:14:39 <acowley> thoughtpolice: Yeah
17:14:46 <acowley> thoughtpolice: But I almost never have callbacks
17:14:47 <thoughtpolice> but i suppose it can cut the other way: the difference is obvious if you have something that can be 'unsafe' marked as 'safe'
17:15:16 <jmcarthur> safe is a fine default. you can always switch to unsafe after benchmarking and careful thinking, if it turns out to be a problem
17:15:18 <acowley> So it's a question of messing up GHC threading with unsafe, or taking the overhead hit
17:15:44 <acowley> I don't think I ever use forkOn (as evidenced this evening)
17:15:54 * thoughtpolice doesn't think he has ever used forkOn either
17:16:08 <acowley> It seems like a pretty ugly way to avoid trouble
17:16:38 <jmcarthur> i can't think of any cases i would even want forkOn except for just playing around with the rts for learning
17:17:05 <jmcarthur> forkOS already gives you the ability to use bindings with thread local state and stuff
17:17:16 <acowley> jmcarthur: It's useful when trying to determine if two forkIO threads can block each other by making unsafe FFI calls!
17:17:29 <jmcarthur> acowley: as i said... playing around with the rts ;)
17:17:53 <acowley> jmcarthur: I don't think that use case is that weird, though
17:18:04 <acowley> (the multiple forkIO threads making FFI calls)
17:18:34 <jmcarthur> i just mean it's nothing i would probably commit into a project
17:19:05 <acowley> No, but it stinks if you want to make short FFI calls and you want to use multiple Haskell threads
17:19:32 <jmcarthur> if they are indeed short then unsafe is fine
17:20:23 <acowley> Yeah, but then we get into Programmer Debate Territory where we have to define "short" :(
17:21:15 <jmcarthur> it has a precise, context-sensitive definition ;)
17:21:48 <acowley> hah, good answer
17:22:30 <jmcarthur> it is short if making the binding unsafe does not bring the responsiveness of your application below the level that is desired
17:22:57 <jmcarthur> (in other words... try it and see what happens)
17:23:12 <hpc> jmcarthur: "it's fast if you don't care that it's slow" ;)
17:23:18 <jmcarthur> exactly
17:23:51 <xenon-> how can I portably prevent launching multiple instances of my program?  keeping the file opened and trying to write to it comes to mind, but it seems a bit hackish
17:24:26 <hpc> xenon-: apache does it with a PID file
17:24:35 <hpc> a file in a predictable location with the pid of the current process
17:24:42 <acowley> That sounds like an invitation to a death by a thousand cuts
17:24:49 <acowley> lose 2% here, 5% there
17:24:58 <acowley> and responsiveness is ill defined for batch processing scenarios
17:25:42 <jmcarthur> xenon-: google lockfiles
17:26:01 <jmcarthur> flock and such
17:28:26 <jmcarthur> acowley: 2%-5% is pretty significant, really
17:28:46 <jmcarthur> acowley: or at least large enough to be considered pretty low hanging fruit
17:31:35 <pharaun> also won't that improve with MIO?
17:37:01 <danilo2> Hi! Is there anywhere Edward Kmett presentation in pdf format from this video? http://www.youtube.com/watch?v=cefnmjtAolY
17:37:23 <danilo2> There is a link to a keynote presentation, but I'm not able to conver it on linux (I've tried some online tools but they failed)
17:37:53 <jmcarthur> danilo2: http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf
17:38:07 <danilo2> jmcarthur: Thank you!
17:38:16 <brandonw> what would the best be to get non-blocking IO with line-based input (like hGetLine) ?
17:38:25 <jmcarthur> brandonw: just use hGetLine
17:38:32 <jmcarthur> brandonw: use threads if you want to do other things while waiting
17:39:08 <jmcarthur> brandonw: see the async library if you want to avoid explicitly using threads, but it uses threads under the hood anyway
17:39:36 <jmcarthur> brandonw: the async library is pretty nice to use though, so i still recommend checking it out
17:40:16 <jmcarthur> brandonw: and i'm not just saying "ignore the performance and memory overhead." i'm really saying "'blocking' io and threads in ghc are more efficient than you may expect"
17:40:45 <brandonw> jmcarthur: i know that haskells threads are very fast
17:40:52 <brandonw> it was more that now i have to learn how to use threads :)
17:41:01 <brandonw> i'm having a tough enough time with haskell to begin with :]
17:41:07 <jmcarthur> it's not hard. also, check out the async package ;)
17:41:10 <brandonw> but i will try it out
17:41:12 <brandonw> okay, thanks
17:53:58 <benzrf> sup
17:54:16 <bishopplox> hello
17:54:26 <benzrf> anybody care to try out my Shitty Tiny Lisp & see if you can find any obvious bugs
17:54:29 <benzrf> :B
17:55:19 <nexx> It needs to many parentheses :)
17:55:30 <circ-user-SwpzV> @pl \x -> f x >>= g
17:55:30 <lambdabot> (g =<<) . f
17:55:38 <bishopplox> anyone have experience with the sodium frp library?
17:55:54 <bishopplox> I'm kind of stuck
17:56:12 <circ-user-SwpzV> @pl \x -> a (f x) (g x) (h x)
17:56:12 <lambdabot> ap (liftM2 a f g) h
17:56:21 <circ-user-SwpzV> @pl \x -> a (f x) (g x) (h x) (j x)
17:56:21 <lambdabot> ap (ap (liftM2 a f g) h) j
17:56:28 <benzrf> hat does pl do
17:56:42 <benzrf> @pl \x -> x
17:56:42 <lambdabot> id
17:56:44 <benzrf> ahihi2:
17:56:45 <benzrf> *ah
17:56:47 <circ-user-SwpzV> Who's hat
17:56:49 <benzrf> @pl 3 + 4
17:56:49 <lambdabot> 7
17:56:55 <benzrf> ha
17:57:03 <scott_> @pl \x -> x + 4
17:57:03 <lambdabot> (4 +)
17:57:25 <benzrf> @pl \f g a -> f a && g a
17:57:25 <lambdabot> liftM2 (&&)
17:57:31 <benzrf> o:
17:57:49 <circ-user-SwpzV> @pl \a -> let b = f a in n a b
17:57:50 <lambdabot> ap n f
17:58:00 <benzrf> @pl \(a, b) -> (f a, b)
17:58:01 <lambdabot> first f
17:58:04 <benzrf> !
17:58:08 <benzrf> :t first
17:58:09 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
17:58:11 <benzrf> :t second
17:58:11 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
17:58:23 <benzrf> i should probly learn how arrows work at some point
17:58:25 <circ-user-SwpzV> @pl \a -> let b = f a in n b a
17:58:25 <lambdabot> ap (flip n) f
17:58:50 <scott_> benzrf: (->) is an instance of arrow, so for reading those type signatures imagine replacing the a's with (->)'s
17:59:05 <scott_> first :: (b -> c) -> (b, d) -> (c, d)
17:59:07 <benzrf> hrm
17:59:14 <benzrf> :t ap
17:59:15 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:59:24 <benzrf> ah
17:59:29 <benzrf> right its <*>
17:59:32 <benzrf> :t <*>
17:59:33 <lambdabot> parse error on input `<*>'
17:59:36 <benzrf> :t (<*>)
17:59:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:59:40 <benzrf> k
18:02:20 * hackagebot stringsearch 0.3.6.5 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.6.5 (DanielFischer)
18:03:52 <ok_ok> :t first
18:03:52 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
18:04:21 <benzrf> the lack of general handling of tuples has always made me uneasy
18:04:22 <benzrf> ;_;
18:05:14 <acowley> benzrf: Do lens's definitions help?
18:05:34 <acowley> benzrf: It's not necessarily generalized, but you essentially get third, fourth, fifth, etc.
18:05:36 <benzrf> i dont know anything about lenses
18:05:50 <joelteon> @instances Field1
18:05:50 <lambdabot> Couldn't find class `Field1'. Try @instances-importing
18:05:59 <acowley> :t (_4 %~)
18:06:00 <lambdabot> (Field4 s t a b, Indexable Int p) => p a b -> s -> t
18:06:47 <acowley> That section lets you apply a function to the fourth element of a tuple with at least four components
18:07:02 <benzrf> ._.
18:07:04 <benzrf> > _4
18:07:05 <lambdabot>   No instance for (Control.Lens.Internal.Indexed.Indexable
18:07:05 <lambdabot>                   ...
18:07:13 <benzrf> none of that made sense to me
18:07:24 <scott_> Lens types are pretty complicated
18:07:30 <scott_> Because they are very general
18:07:47 <acowley> Yeah, the types aren't very helpful
18:08:08 <acowley> but its heart is in the right place
18:08:15 <acowley> so it mostly does what you expect
18:11:23 <Tinned_Tuna> > ._.
18:11:24 <lambdabot>   <hint>:1:1: parse error on input `.'
18:11:47 <benzrf> > 3
18:11:48 <lambdabot>   3
18:11:55 <benzrf> why does everybody put a space before the >
18:12:02 <benzrf>  > 3
18:12:08 <benzrf> wait i guess not
18:12:09 <scott_> I don't think anyone does that
18:12:21 <benzrf> i guess ive been misreading the whole time
18:12:22 <benzrf> o_o
18:13:21 <benzrf> ok so I noticed a lot of repeated code and what felt like antipatterns while writing my Shitty Tiny Lisp
18:13:39 <benzrf> can anybody glance over the code and point out useful things for me to know about to avoid my mistakes in the future?
18:13:51 <benzrf> atm it's 210 lines including the parser & REPL
18:14:03 <benzrf> & a few builtin haskell <-> STL funcs
18:14:05 <jmcarthur> somebody can if you lpaste it or github it
18:14:14 <benzrf> i was just asking first :P
18:14:22 <benzrf> does lpaste have a local client or vim plugin like bpaste?
18:14:22 <benzrf> :D
18:14:24 <jmcarthur> don't ask to ask. just ask. ;)
18:14:31 <jmcarthur> hmm, not aware of one
18:14:45 <benzrf> well it really wasnt asking to ask
18:14:45 <benzrf> :P
18:15:05 <xenon-> brandonw I am pretty new to haskell too, but I did something similar before so here's a simple example that uses threads. if there's a nicer way of doing it I would like to know too. :)  http://lpaste.net/96266
18:15:22 <jmcarthur> it sort of was. the actual question is "what's wrong with this code?" but the meta question is "is it worth pasting my code?"
18:15:39 <scott_> Apparently haskell-mode has hpaste support (I assume this works with lpaste)
18:15:42 <benzrf> :P ok
18:15:53 <scott_> haskellmode for vim, I mean
18:16:17 <jmcarthur> neat
18:17:53 <lpaste> benzrf pasted “STL” at http://lpaste.net/96267
18:17:59 <benzrf> aww yeah
18:18:01 <scott_> I'm actually not so sure that works with the new lpaste I may try making a new (standalone) vim plugin for lpaste
18:22:03 <xenon-> given ThreadID can I block until that thread finishes?
18:24:34 <Tinned_Tuna> xenon-: I believe so
18:24:49 <acowley> xenon-: Are you the one starting the thread? If so, tack on an MVar put that you can then take on
18:24:54 <Tinned_Tuna> Although, I am casting my memory back to a quick skim of Marlow's most recent book
18:42:29 <mikeplus32> asked earlier, but perhaps unseen: is there a quickCheckAll or equivalent that works for properties defined in a different module?
18:51:41 <pharaun> benzrf: you can probably use curl + vim to upload to lpaste
18:53:22 <benzrf> all this lpaste blather
18:53:30 <benzrf> i just wanted people to examine my code
18:53:31 <benzrf> :[
19:02:52 <pharaun> looking
19:08:54 <heatsink> Why LispList and not LispCons?
19:14:23 <heatsink> benzrf, your code would be a bit simpler if you make one Haskell object for each Lisp object
19:14:33 <pharaun> Ive mostly avoided env myself and i'm not terribly familiar with lisp, i did read the famous bootstrap lisp paper tho.. and first thing i noticed
19:14:38 <pharaun> symChar1P - that totally could use a parsec builtin
19:17:24 <ReinH> hai
19:17:43 <scott_> hi
19:21:13 <pharaun> its a start :)
19:21:33 <pharaun> oh benzrf left?
19:21:35 <pharaun> damnit
19:25:13 <danilo2> Hello :) I've got another lens problem :( After converting my datatype to use underscores in field names and generating lenses the following code is not working. Why Haskells asks me to create a Monoid from my datatype? Is this really needed? http://lpaste.net/96270
19:26:27 <danharaj> :t view
19:26:28 <lambdabot> MonadReader s m => Getting a s a -> m a
19:27:04 <danilo2> danharaj: I do not think this is this view. I'm talking aobut view from Control.Lens
19:27:13 <danharaj> that is the view
19:27:31 <danharaj> (->) r is an instance of MonadReader
19:27:46 <danilo2> danharaj: oh, ok
19:28:03 <danilo2> danharaj: anyway, I do not see wy the problem occurs yet :(
19:28:31 <pavonia> :t set
19:28:32 <lambdabot> ASetter s t a b -> b -> s -> t
19:30:22 <danharaj> I think more context is needed to diagnose this.
19:32:06 <eyebloom> How does one resolve overlapping instances?
19:32:49 <ReinH> danilo2: what is the code and whta is the error?
19:32:54 <danilo2> danharaj: I was afraid that context would be needed. It is not simple in this case :( I'll try to prepare it, but what can overall cause such error? I always thought, that view and set shoudl simply work that way ...
19:33:02 <danilo2> ReinH: http://lpaste.net/96270
19:33:40 <danharaj> try asking in #haskell-lens
19:34:17 <pavonia> eyebloom: depends on the context
19:34:21 <danilo2> danharaj: Ok, I'm asking right now :)
19:36:08 <eyebloom> I'm trying to compile the Cambridge Haskell Supercompiler and getting lots of overlapping instances for Show
19:37:29 <pavonia> eyebloom: then try setting the -XOverlappingInstances flag
19:39:50 <eyebloom> pavonia: That doesn't solve it unfortunately.
19:40:53 <pavonia> How are you compiling?
19:41:45 <eyebloom> ghc Main.hs -XOverlappingInstances
19:42:13 <eyebloom> I should try cabal install...
19:45:05 <pavonia> I guess another extension is needed too
19:46:59 <TravisD> cabal is giving me the following warning: "cabal: The following packages are likely to be broken by the reinstalls:"
19:47:04 <TravisD> Should I force the reinstalls?
19:49:38 <geekosaur> almost never should you do that
19:52:25 <joelteon> fun fact: i've always forced reinstalls and it has not broken ever
19:52:28 <joelteon> but I assume it's bad
20:01:11 <Luke> I have a Text string with escaped " characters and when I encode it to HTML with Blaze using fromString, it screws up the quoting. any ideas about why?
20:06:50 <Saizan> fromString might be for literal html
20:08:26 <Saizan> try toMarkup?
20:09:15 <SilverFalls> Hello. Does anyone know how I can play music in haskell?
20:09:38 <SilverFalls> Like spawn a thread that plays some .mp3 file on disk.
20:09:39 <sclv> many ways!
20:09:41 <Luke> Saizan: thanks for the suggestion - looking into it
20:09:44 <sclv> oh just that?
20:09:46 <sclv> that's easy!
20:09:53 <SilverFalls> :)
20:10:14 <SilverFalls> I'd definitely prefer something cross-platform if possible.
20:10:33 <sclv> dunno if its bitrotted but dons wrote an mp3 player in haskell some years ago: http://hackage.haskell.org/package/hmp3
20:10:57 <sclv> might be bitrotted tho
20:11:03 <sclv> also might be unix only
20:11:17 <sclv> libsndfile is crossplatform but its for read/write not playback http://hackage.haskell.org/package/hsndfile
20:11:20 <Luke> Saizan: you were right about the focus... text literal serialization isn't right
20:11:21 <Luke> thanks
20:12:13 <SilverFalls> sclv: That mp3 player looks like a stand alone application, I'm looking for a library
20:12:37 <sclv> right but if you read the source you can see what it does :-P
20:14:15 <sclv> i think alut is a good playback lib thats semi xplat http://hackage.haskell.org/package/ALUT
20:14:46 <sclv> searching hackage for relevant stuff is easy http://hackage.haskell.org/packages/search?terms=sound
20:15:46 <SilverFalls> sclv: Thanks!
20:20:14 <TravisD> Hey, sorry, I was ark for a bit
20:20:22 <TravisD> so what should you do instead of forcing the reinstalls?
20:33:05 <enthropy> TravisD: I would force the reinstalls, and cabal install the packages that got broken
20:37:23 <TravisD> ah, there are many
20:37:30 <TravisD> is there a way to automate that?
20:39:08 * enthropy just copy-pastes the output below "these packages will be broken"
20:39:21 <viki_> hi
20:39:49 <enthropy> but in some cases they won't build with the new version of a dependency (say bytestring or hashable)
20:39:58 <enthropy> and that's manual intervention I guess
20:40:07 <enthropy> or maybe use sandboxes or something like that
20:41:10 <viki_> i am i supposed to ask my doubts here? I am new to this ghat group?
20:41:38 <enthropy> viki_: sure, if it's about haskell
20:41:40 <jrmithdobbs> The who
20:42:00 <viki_> thank you.. yes it is about haskell..
20:42:41 <viki_> fold1 :: (a->b->b) -> (a->b) -> [a] -> b fold1 f g [a]   = g a fold1 f g (a:x) = f a (fold1 f g x)
20:43:21 <viki_> how does this code differ from the original foldr function?
20:43:52 <viki_> fold1 :: (a->b->b) -> (a->b) -> [a] -> b
20:44:09 <viki_>  fold1 f g [a]   = g a
20:44:10 <viki_>  fold1 f g (a:x) = f a (fold1 f g x)
20:44:10 <Luke> is there a way to escape Aeson output?
20:44:31 <ion> viki: What’s the result when you apply it to an empty list?
20:45:31 <viki_> @ion: i tried fold1 (+) 0 [1..3]
20:45:32 <lambdabot> Unknown command, try @list
20:45:37 <viki_> but it throws error
20:45:57 <ion> 0 isn’t :: a -> b
20:47:12 <roconnor> @type (0 :: Int -> Int)
20:47:12 <lambdabot>     No instance for (Num (Int -> Int)) arising from the literal `0'
20:47:13 <lambdabot>     Possible fix: add an instance declaration for (Num (Int -> Int))
20:47:13 <lambdabot>     In the expression: (0 :: Int -> Int)
20:47:38 <viki_> so how am i supposed to run this
20:47:47 <viki_> am very new to haskell.
20:48:06 <viki_> i didnt understan the type concept.
20:49:50 <viki_> ion: can u explain me this?
20:51:42 <ion> viki: Let’s start with simpler inputs. fold1 (something) (something) [] will crash. This function isn’t defined for empty inputs (which isn’t good, but let’s skip that for now). How about fold1 (something) (something) [1]? If you look at the definition for a list of 1 item, you’ll see “f” isn’t used. Can you think of a “g” you could use that typechecks?
20:52:44 <TravisD> Alright, I'll do that :) Thanks for the advice
20:53:07 <viki_> ion: so is 'g' a function?
20:54:00 <ion> viki: Its type is a -> b, so yes, it is a function. You can also see it being applied to “a” in the code.
20:54:55 <ion> viki: You might benefit from reading this fine book:
20:54:57 <ion> @where lyah
20:54:57 <lambdabot> http://www.learnyouahaskell.com/
20:58:11 <viki_> Ion: i've gone through few chapters of the book.. still i am not sure of these types.   fold1 :: (a->b->b) -> (a->b) -> [a] -> b  should i take  (a->b->b) corresponds to f.,  (a->b)  correspons to g and so on?
20:59:01 <ion> viki: Precisely.
20:59:23 <ion> The final b is the return value.
21:01:35 <bobcrash> Hey guys, who was here yesterday when I showed you the future of computer graphics?
21:01:59 --- mode: ChanServ set +o Cale
21:02:15 <viki_> ion: what does a->b->b mean?
21:02:54 <jle`> viki_: you can think of it as a function that takes an a and a b and returns a b
21:03:26 --- mode: Cale set -o Cale
21:03:32 <jle`> special thanks to the english language for making that more confusing than it should have been
21:03:45 <viki_> can you explain a little more?
21:04:01 <jle`> a, b, etc. stand for concrete types
21:04:06 <Cale> bobcrash: was that the beautiful red helicopter?
21:04:13 <jle`> like for example Int -> String -> String
21:04:19 <bobcrash> Cale: Yes, yes it was
21:04:27 <jle`> let's say I had a function that took a number, and a string, and repeated the string that number of times
21:04:42 <viki_> ok...
21:04:49 <jle`> like f 3 "hello" = "hellohellohello"
21:04:55 <jle`> that would be a function that takes an int
21:04:58 <jle`> a string
21:05:00 <jle`> and returns a new string
21:05:03 <jle`> a -> b -> b
21:05:12 <jle`> Int -> String -> String
21:05:47 <jle`> when we say a -> b -> b, it means "a function that takes anything of any type A, anything of any type B, and returns a new thing of type B"
21:06:23 <jle`> it might make more sense to think of it as (a, b) -> b
21:06:30 <jle`> but we don't do it that way, because of something you will learn later
21:06:58 <bobcrash> Cale:  So now you can see the ultra-future of graphics... today!  http://imgur.com/Vgm6fFF
21:07:24 <bobcrash> next up... antialiasing
21:07:43 <viki_> jle: thnks jle..
21:08:00 <peddie> bobcrash: this looks awesome
21:08:05 <peddie> well done
21:08:13 <viki_> i think got it.
21:08:25 <jrmithdobbs> Was going to say... Keep reading and the hand waving goes away
21:09:06 <Cale> bobcrash: wow, such sky, very helicopter, many cloud, so grass
21:09:19 <ion> bobcrash: Are you doing helicopter flight dynamics?
21:09:29 <bobcrash> Cale: ROFL
21:09:46 <viki_> jle: But y are we not using int->string->string->  rather than a->b->b which is confusing..?
21:09:57 <bobcrash> peddie:  Thanks (if serious).
21:10:03 <jle`> viki_: because fold1 actually takes *any* function that follows that pattern
21:10:07 <peddie> bobcrash: I'm totally serious
21:10:33 <jle`> fold1 says "I am a function that takes any (a->b->b), any (a->b), and any [a], and i return some b"
21:10:34 <bobcrash> ion:  You could say so.  I'm working on a remote control heilcopter flight sim.  Rather than trying to actually model a heli from the physics equations I'm basically implementing higher level effects based on what I notice most in real life
21:10:46 <viki_> ok..
21:10:53 <jle`> so you can pass *any* function that follows that a->b->b pattern into fold1 and i'll be happy
21:11:09 <ion> bobcrash: Oh, ok.
21:11:10 <jle`> for example, you can give fold1 that Int->String->String function
21:11:15 <jle`> and it will accept it
21:11:22 <jle`> but you can't, for example, give it an Int->String->Int function
21:11:45 <bobcrash> ion:  I'm nowhere near physics-smart enough to tune some complicated model for my needs.  On the other hand, what I have now is letting me whiz about and not feeling too fake
21:11:48 <mouche> fff/close
21:11:53 <mouche> whoops ^^
21:14:59 <td123> in the world of haskell to js compilers, is there a clear advantage of fay over ghcjs or possibly another compiler I don't know about?
21:16:02 <joeyh> fay still lacks type classes, afaik?
21:16:20 <joeyh> but *much* smaller runtime and probably easier to understand generated cde
21:16:37 <viki_> jle: can u tell me how to give inputs to it.. i am again confused..
21:17:37 * hackagebot OpenAFP 1.4.0 - IBM AFP document format parser and generator  http://hackage.haskell.org/package/OpenAFP-1.4.0 (AudreyTang)
21:17:39 * hackagebot OpenAFP-Utils 1.4.0 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.4.0 (AudreyTang)
21:24:18 <pdxleif> Anyone know what hxput does? https://github.com/LeifW/xmonad-utils/blob/master/src/Hxput.hs
21:24:29 <pdxleif> The comment says "Sets the mouse selection."
21:25:01 <enthropy> when you middle click, it pastes something
21:25:15 <enthropy> that text is the "mouse selection"
21:25:35 <pdxleif> Ah, cool - thanks.
21:26:13 <enthropy> or maybe it's one of the others... X has too many ways to cut&paste
21:26:28 <pdxleif> Sort of the inverse of hxsel
21:26:39 <pdxleif> It works as you described
21:29:02 <pdxleif> hslock doesn't ask for a password anymore - pretty sure it used to. Not sure how to fix it.
21:30:23 <carter> patch it
21:31:04 <Hafydd> That sounds like a pretty critical bug.
21:32:38 * hackagebot x509-validation 1.4.6 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.6 (VincentHanquez)
21:42:14 <carter> whats the tool?
22:03:14 <jozefg> Hi all!
22:06:02 <scripty> TIMER
22:06:06 <bobcrash> Hi!
22:07:06 <adnap> Argh. #elm is so dead.
22:07:12 <adnap> ...all the time
22:07:26 <jozefg> @adnap It's a bit young for an active IRC chan
22:07:26 <lambdabot> Unknown command, try @list
22:07:36 <adnap> Elm has all these bugs!
22:08:01 <jozefg> :adnap I haven't played with it yet, worth it?
22:08:50 <adnap> jozefg: I'm mixed. It's like a gimped Haskell with a clean api and weird language quirks/bugs
22:09:22 <jozefg> I tend to bias towards Ur/Web for web-y things. But I'm biased
22:09:48 <jozefg> :adnap Sounds like GHC-JS will be less gimped at least.
22:10:03 <adnap> I don't know what that is. I hate web programming, but Elm is fun and kind of like Haskell
22:10:19 <adnap> I just learned it two days agoo
22:10:46 <adnap> I wish evancz would come back here so I could tell him about the bugs
22:11:03 <carter> report them to trac
22:11:20 <adnap> Can someone report them for me? I'm shy
22:11:22 <jozefg> :adnap Ur/Web is closer to ML but with a more sophisticated/snazzy type system. Decidedly more research-y as well
22:11:22 <carter> i js'd recently, cannot unseee the crazy
22:11:31 <carter> adnap: no
22:11:34 <carter> youre on irc
22:11:35 <carter> go
22:11:38 <carter> report the bugs
22:11:46 <carter> shy is a noneexcuse
22:11:49 <carter> if you want nice things
22:11:52 <carter> report bugs
22:11:56 <adnap> I need an anonymous e-mail.
22:12:06 <ExtraPaws> hello haskell friends
22:12:06 <ion> @google tor email
22:12:08 <lambdabot> http://tormail.org/
22:12:09 <lambdabot> Title: Tor Mail
22:12:24 <jozefg> :ExtraPaws Hiya
22:26:56 <ExtraPaws> would livestreaming coding be cool would you guys watch that
22:28:11 <zomg> ExtraPaws: people watch Notch code so I'd imagine they might watch you code as well if you're internet famous enough for it
22:28:25 <adrian_berg> https://pastee.org/6kv2c
22:31:40 <adrian_berg> What if you did putStrLn show $ lastButOne [1,2,3,4]
22:32:07 <adrian_berg> That gives a longer error :)
22:32:23 <adrian_berg> > last $ init [1,2,3,4]
22:32:24 <lambdabot>   3
22:41:48 <jozefg> Stack based languages are fun :D
22:44:06 <simpson> Yes.
22:45:43 <jozefg> I've been fiddling with a Joy-like language for scripting some of my Haskell projects, it's remarkably pleasant to use
22:55:23 <harovali> jozefg: which Joy variant did you use?
23:00:25 <jozefg> :harovali I started with Kitten and ripped out a few bits and bobs that I didn't think a scripting language needed and added in a more haskell like notation of algebraic types and type classes. This is my "getting to know stack languages better" project
23:01:22 <jozefg> *notion
23:05:58 <joelteon> is there a forkIO generalized to MonadIO?
23:07:54 <TravisD> I was reading Edward Zang's blog posts on the Haskell heap, but i'm finding them a bit hard to follow. I think they're assuming more familiarity with Haskell than I have.
23:12:46 * hackagebot gluturtle 0.0.58 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.58 (YoshikuniJujo)
23:16:29 <fizruk> joelteon, it can't be generalized that way afaik
23:17:34 <fizruk> joelteon, there's however monad-parallel package which provides forkExec http://hackage.haskell.org/package/monad-parallel-0.7.1.1/docs/Control-Monad-Parallel.html#v:forkExec
23:27:47 * hackagebot OpenAFP 1.4.1 - IBM AFP document format parser and generator  http://hackage.haskell.org/package/OpenAFP-1.4.1 (AudreyTang)
23:27:49 * hackagebot OpenAFP-Utils 1.4.1 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.4.1 (AudreyTang)
23:41:39 <scott_> Why does lambdabot's free use $map?
23:41:43 <scott_> @free concat
23:41:44 <lambdabot> $map f . concat = concat . $map ($map f)
23:43:08 <adrian_berg> If anyone has time to look, I would be appreciative: https://pastee.org/6kv2c
23:43:25 <scott_> adrian_berg: I get a 404
23:48:04 <adrian_berg> https://pastee.org/ytjnt
23:48:57 <scott_> adrian_berg: The things in main's do block must be IO actions. You probably want to use print
23:49:29 <passiveobserver> is it ever possible to adapt geordi the c++ bot for command line use?
23:52:49 * hackagebot OpenAFP-Utils 1.4.1.1 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.4.1.1 (AudreyTang)
23:54:36 <fizruk> has anyone here seen extensible-effects? it seems to be pretty cool so far: https://github.com/RobotGymnast/extensible-effects
23:55:50 <fizruk> afaict the idea is similar to that of free monads, but instead of using a single functor for each layer, the authors use an open union of such!
