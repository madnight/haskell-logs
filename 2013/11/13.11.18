00:18:43 <lpaste> sopvop pasted “representing AST of imperative language ” at http://lpaste.net/95847
00:19:04 <sopvop> so, anyone has an opinion on how to represent AST of imperative language?
00:19:14 <sopvop> I'm thinking about turning first one into second
00:19:32 <sopvop> But I'm not sure I'll gain much
00:20:05 <ski> s/Assing/Assign/
00:20:18 <sopvop> oh, thanks
00:20:24 <opqdonut> interesting idea
00:20:42 <ski> you seem to be missing `|'s in the `data' declarations
00:20:53 <ski>   | CallFunc (Expr a) [Expr a]
00:20:55 <sopvop> Consider it a GADT missing where :)
00:20:58 <ski> s/a/var/ ?
00:21:09 <ski> well, then you're missing `::'s :)
00:21:15 <sopvop> :)
00:21:38 <startling> commas too
00:22:35 <ski> why do you call it "lambda-like representation" ?
00:22:40 <sopvop> syntax nazi...
00:22:46 <rerecord> > do x<- [1,2,3]; [x]
00:22:47 <lambdabot>   [1,2,3]
00:23:10 <rerecord> whats stored in x in the above
00:23:21 <rerecord> its type has to be Int right?
00:23:30 <sopvop> ski: well, because of how var binding looks like "let in"
00:23:42 <startling> rerecord, "stored" is the wrong way to look at it
00:23:47 <arkeet> rerecord: x is the name of a function argument.
00:23:52 <arkeet> @undo do x <- [1,2,3]; [x]
00:23:52 <lambdabot> [1, 2, 3] >>= \ x -> [x]
00:24:01 <arkeet> \x -> [x] is a lambda thingy.
00:24:19 <ski> rerecord : the type of `x' is the type of `1', `2', and `3', yes
00:24:55 <arkeet> it's a function, and that function is used 3 times, once each with the arguments 1, 2, and 3.
00:25:11 <pharaun> how do i convert a Either ParseError x into Either String x ?
00:25:18 <rerecord> thanks it makes sense to me now..
00:25:27 <rerecord> whats the undo command?
00:25:29 <pharaun> it keeps on exploding with type errors and i'm having trouble trying to figure it out
00:25:32 <arkeet> it's a lambdabot thing.
00:25:43 <rerecord> i know, what does it do.
00:25:45 <arkeet> rerecord: do syntax is syntactic sugar.
00:25:50 <arkeet> undo desugars it.
00:25:58 <rerecord> ohhh
00:26:15 <frxx> > do x <- [1,2,3]; y <- [10,11]; return (x,y)
00:26:16 <lambdabot>   [(1,10),(1,11),(2,10),(2,11),(3,10),(3,11)]
00:26:31 <ski> pharaun : `case' is the basic way to take apart an `Either ParseError x' ?
00:27:16 <arkeet> :t Data.Bifunctor.first
00:27:17 <lambdabot> Data.Bifunctor.Bifunctor p => (a -> b) -> p a c -> p b c
00:27:29 <pharaun> ski: i want to put it *back* into a new Either
00:27:40 <pharaun> Either ParseError x -> Either String x
00:27:42 <startling> pharaun, Left ?
00:27:46 <scott_> pharaun: fmap show
00:27:48 <ski>   case myEither of
00:27:49 <pharaun> and i've tried the case, but it keeps on exploding with errors
00:27:57 <ski>     Left err -> Left (blah err)
00:27:58 <arkeet> scott_: no, that maps over the Right side, not the Left.
00:28:01 <ski>     Right x -> Right x
00:28:03 <startling> pharaun, oh, yes, D.B.first is exactly what you want.
00:28:13 <ski> or `either (Left . blah) Right'
00:28:18 <scott_> Oh, oops
00:28:20 <ski> or what arkeet said
00:28:21 <supki> :t left
00:28:22 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
00:28:30 <pharaun> startling: ?
00:28:42 <ski> or that
00:28:46 <arkeet> or that.
00:28:55 <arkeet> :t over _Left
00:28:55 <lambdabot>     Not in scope: `over'
00:28:55 <lambdabot>     Perhaps you meant `cover' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
00:28:55 <lambdabot> Not in scope: `_Left'
00:28:59 <arkeet> whaaat.
00:29:07 <ski> > map (left (^2)) [Left 0,Right 1,Left 2,Right 3]
00:29:07 <lambdabot>   [Left 0,Right 1,Left 4,Right 3]
00:29:34 <startling> :t Control.Lens._Left
00:29:34 <lambdabot> (Applicative f, Data.Profunctor.Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
00:29:45 <ski> arkeet : maybe blame int-e/chrisdone ?
00:29:47 <startling> :t Control.Lens.over Control.Lens._Left
00:29:48 <lambdabot> (a -> b) -> Either a c -> Either b c
00:29:59 <arkeet> ski:  I thought elliott was in charge of lambdabot.
00:30:05 <rerecord> :t left
00:30:05 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
00:30:20 <startling> yeah, I doubt 'left' is the right thing.
00:30:29 <startling> arkeet, there's been a coup.
00:30:34 <arkeet> ah.
00:30:46 <arkeet> well, I can still blame elliott.
00:31:20 <pharaun> http://lpaste.net/95848 ?
00:31:45 <pharaun> nvm
00:31:51 <supki> startling: ?
00:31:52 <pharaun> i'm tired, and grumpy
00:31:55 <supki> :t [left, Control.Lens.over Control.Lens._Left]
00:31:56 <lambdabot> [(b -> c) -> Either b d -> Either c d]
00:32:14 <arkeet> :t [left, Control.Lens.over Control.Lens._Left, Data.Bifunctor.first]
00:32:14 <lambdabot> [(b -> c) -> Either b d -> Either c d]
00:32:20 <arkeet> :t [left, Data.Bifunctor.first]
00:32:21 <lambdabot> [(b -> c) -> Either b d -> Either c d]
00:32:38 <pharaun> better
00:33:00 <arkeet> :t left'
00:33:00 <lambdabot>     Not in scope: left'
00:33:00 <lambdabot>     Perhaps you meant one of these:
00:33:00 <lambdabot>       `left' (imported from Control.Arrow),
00:33:05 <arkeet> :t Data.Profunctor.left'
00:33:05 <lambdabot> Data.Profunctor.Choice p => p a b -> p (Either a c) (Either b c)
00:34:04 <ski> arkeet : apparently, int-e has taken over, but the server lambdabot was on went down(?), so chrisdone is temporarily(?) hosting a replacement (with no `src',`where',`karma',&c. database)
00:34:13 <arkeet> I see.
00:34:21 <rerecord> how to start private chat with lambdabot?
00:34:22 <scott_> He fixed src, I think
00:34:56 <rerecord> so that i dont have to spam here.
00:35:27 <sopvop> you can /msg lambdabot >1+1
00:35:30 <scott_> Depending on your client, possibly /query lambdabot
00:37:00 <rerecord> im using the web client
00:37:13 <rerecord> thanks
00:38:46 <startling> the web client is almost universally-acknowledged as bad, fwiw.
00:41:40 <rerecord> startling: what should i use on windows?
00:43:26 <startling> rerecord: I don't know. I don't use windows.
00:46:58 <qnikst> hi, I have a weird situation: when I'm using external library in compiled program everything is ok, but if I'm trying to run it under ghci, then values that I'm reading from that library are wrong (I can paste minimal example), can somebody give a tip where to dig?
00:47:13 <chrisirc> I've just gotten a case where ghci would just hang when trying to evaluate an expression. It's not using CPU, just sits there hanging, evaluating pure code (no monads or unsafe code involved)
00:47:42 <qnikst> (https://gist.github.com/qnikst/324a66914b3aba878be5)
00:47:45 <chrisirc> And it's just asking for the value of a variable at the ghci prompt; the definition of the variable is in a file and compiles fine.
00:48:53 <chrisirc> What could be the reason? Is it possible that exceptions are not printed but just lead to hangs?
00:49:52 <chrisirc> (And it's not eating memory either, thus no swapping. 96 MB RSS.)
00:52:20 <chrisirc> Aha, compiling the program to an executable and running it that way issues a message <<loop>>
00:52:29 <chrisirc> interesting.
00:54:45 <tdammers> recursive definition?
00:54:48 <ion> What’s the source?
00:55:26 <chrisirc> The source is confidential. I'm just going to track it down now that I know it would be a loop.
00:56:48 <chrisirc> Found+fixed it.
00:57:19 * hackagebot clckwrks 0.20.1 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.20.1 (JeremyShaw)
00:57:21 <lambdabot> Title: Hackage: clckwrks: A secure, reliable content management system (CMS) and blo...
00:57:41 <chrisirc> The only surprise was really that ghci would stop execution but not return :). Eating 100% cpu or running out of ram would have been more self-explanatory :)
01:07:04 <rerecord> main = getContents >>= mapM_ (printf "%.1f\n"). (\[a, b, [l, r]] -> solve l r a b). map (map read. words). lines
01:07:12 <rerecord> can someone explain this to me?
01:08:15 <rerecord> solve :: Int -> Int -> [Int] -> [Int] -> [Double]
01:09:03 <dv-> explain what? read it right to left
01:10:54 <tdammers> I read it left to right :x
01:11:09 <rerecord> I know what it is doing, but having hard time understanding how it is doing that.. I will give it another shot..
01:11:55 <rerecord> I don't know if its just me.. but i find doing IO in haskell as a beginner is a little hard
01:12:31 <joelteon> you'll get used to it, it's really quite nice
01:12:33 <scott_> There's actually hardly any IO going on in that snippet
01:13:02 <scott_> getContents grabs all the input from stdin and passes it as a string to the (pure, no-IO) function to the right of >>=
01:15:17 <dv-> rerecord: http://lpaste.net/4531421089779154944
01:15:58 <Cale> scott_: er, what? The function to the right of >>= will have to produce an IO action
01:16:19 <rerecord> mapM_ produces an IO action?
01:16:21 * scott_ facepalms. Thanks, I'm a bit off tonight
01:16:31 <frxx> :t mapM_
01:16:32 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
01:16:46 <scott_> Of course, it returns an IO actions that does all the printfs
01:16:49 <rerecord> dv-: thanks..
01:17:01 <scott_> action*
01:17:08 <Cale> rerecord: main = do xs <- getContents; mapM_ (printf "%.1f\n") . (\[a, b, [l, r]] -> solve l r a b) . map (map read. words) . lines $ xs
01:17:11 <rerecord> ohh you called him out cause he said the rhs is pure?
01:18:06 <frxx> :t mapM_ print [10,20,30]
01:18:06 <lambdabot> IO ()
01:18:13 <rerecord> dv-: thanks.
01:18:16 <Cale> Well, function application doesn't do I/O, because it never does
01:18:25 <Cale> But the result of a function can be an IO action
01:21:40 <rerecord> :t printf
01:21:40 <lambdabot> PrintfType r => String -> r
01:22:23 <Cale> printf is rather polymorphic because it essentially needs to take an arbitrary number of parameters
01:22:44 <Cale> and then it either delivers an IO action for displaying the result, or a String
01:23:11 <Cale> > printf "%s %d" "hello" 5 :: String
01:23:12 <lambdabot>   "hello 5"
01:24:11 <rerecord> what does mapM_ do in this.. it is a little confusing? mapM_ (printf "%.1f\n") . (\[a, b, [l, r]] -> solve l r a b) $ args
01:24:31 <rerecord> the lambda functions results in a list
01:24:36 <rerecord> that i understand
01:25:02 <dv-> it applies printf to each of the elements of the list
01:25:05 <Cale> It applies printf "%.1f\n" to each of the elements of the list, resulting in a list of IO actions, which it then sequences together into a single long IO action for doing all that stuff
01:25:22 <dv-> :t mapM_ print
01:25:22 <lambdabot> Show a => [a] -> IO ()
01:27:29 <Cale> (i.e. mapM_ f xs is just like a for-each loop whose loop body is f, and which iterates over the list xs)
01:27:51 <rerecord> mapM_ (printf "%.1f\n") [Double Double]
01:28:10 <dv-> i don't think it can print types
01:28:23 <Cale> Double is a type, Double Double is a coffee order ;)
01:28:25 <rerecord> no no, im trying to understand
01:29:10 <Cale> rerecord: Try  mapM_ print [1..10]
01:29:11 <startling> rerecord, that lambda function doesn't /result/ in a list.
01:29:27 <startling> rerecord, it (unsafely) deconstructs a three-element list.
01:30:02 <startling> (the third element of which is a two-element list).
01:30:14 <rerecord> it doesnt? but solves type is it takes 4 arguments and results in a [Double]
01:30:15 <ion> It seems to result in a list, but the resulting one doesn’t look like [a, b, [l, r]].
01:30:28 <startling> rerecord, oh, I see.
01:30:32 <startling> yes, you're right. carry on.
01:31:29 <dv-> it would probably be more readable if it had more intermediate variables
01:32:09 <rerecord> :t mapM_
01:32:09 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
01:33:27 <dv-> there's also the flipped version
01:33:30 <yogurt_truck> anyone know of a good talk/paper/etc on gamedev AI with a purely functional approach (structures,etc), etc.?
01:33:37 <dv-> :t forM_ [1,2,3] $ \n -> print n
01:33:37 <lambdabot> IO ()
01:34:44 <startling> yogurt_truck, john carmack has a talk that briefly goes into it.
01:35:05 <startling> Well, maybe not quite. I forget if he went over AI.
01:35:06 <yogurt_truck> I seem to always end up with big dumb lists of things, and a lot of traversal, as my games start needing "intelligent" enemy movement, record-keeping, behavior selection for reacting to things, animations, etc. D:
01:36:09 <yogurt_truck> startling: the one were he talked about haskell? that's a cool talk but he didn't go in-depth into specific iirc
01:36:30 <startling> yeah, I think I'm mixing things but I can't find the one I'm mixing it with.
01:37:47 <rerecord> :t mapM_
01:37:47 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
01:38:01 <rerecord> :t getContents >>= mapM_
01:38:01 <lambdabot>     Couldn't match expected type `String'
01:38:02 <lambdabot>                 with actual type `a0 -> m0 b0'
01:38:02 <lambdabot>     Expected type: String -> IO b1
01:38:26 <startling> :t \f -> getContents >>= mapM_ f
01:38:27 <lambdabot> (Char -> IO b) -> IO ()
01:45:38 <rerecord> maan i feel soo stupid.. I still don't have a clear picture of how things are working, I do know what it is doing..
01:48:19 <rerecord> i will study IO and moand chapter of luah one more time..
01:48:30 <rerecord> thanks guys.
01:48:38 <PTBD> hello. I just started learning haskell couple days ago and trying to write my own remove funciton, which removes every occurence of n from a list. but loading that file into ghci gives me errors which I don't quiet understand and I can't find the error: http://pastie.org/private/kokgf98gvdoxepvsc2rg
01:48:38 <lambdabot> Title: Private Paste - Pastie
01:49:16 <nsa_> Hi there. Guys I have an ByteString from Conduit.simpleHttp, but it encoded as UTF-8 with BOM. So my Aeson dies hard while trying to parse it. Is this possible, to set utf8_bom encoding to whole bytestring or somehow drop BOM nicelly?
01:49:38 <quicksilver> PTBD: You should paste the errors as well. The first thing I see on glancing that code is that you can't use "==" on an arbitrary type 'a'.
01:50:07 <quicksilver> PTBD: if you change the type signature to Eq a => a -> [a] -> [a] you should do better.
01:50:41 <rerecord> else [x] ++ (remove n xs)
01:50:59 <quicksilver> why would that be better, rerecord ?
01:51:38 <dmj`> PTBD: You need an Eq a => a -> [a] -> [a]
01:51:44 <rerecord> ohhh they are the same.. sorry
01:51:54 <PTBD> quicksilver, thank you. can you point me to a page where I can read why exactly  Eq a => a would solve my problem so I can read that?
01:52:10 <dmj`> @lyah
01:52:10 <lambdabot> Unknown command, try @list
01:52:11 <mangaba_leitosa> PTBD: you could just remove the signature, by the way :_)
01:52:14 <PTBD> or tell me what to look for to read it up
01:52:16 <mangaba_leitosa> PTBD: and the code will compile
01:52:31 <dmj`> PTBD: you want to learn about typeclasses, check out learnyouahaskell.com
01:52:33 <PTBD> mangaba_leitosa, yes, I could. but I though this would be better for learning
01:52:52 <quicksilver> PTBD: I'm not sure. The point is that == doesn't work on all types; not all types can be compared. "Eq" is a type class which contains all those types who can be compared with ==.
01:52:54 <mangaba_leitosa> PTBD: indeed
01:53:18 <mangaba_leitosa> PTBD: then do it the hard way and read about typeclases :-)
01:53:30 <mangaba_leitosa> PTBD: and type constraints
01:53:46 <dmj`> and kinds
01:54:11 <PTBD> will do that. thanks a lot to all of you :)
01:56:32 <mangaba_leitosa> PTBD: you need the Eq typeclass in this case: http://www.haskell.org/tutorial/classes.html#tut-type-classes
01:56:33 <lambdabot> Title: A Gentle Introduction to Haskell: Classes, http://tinyurl.com/l8eoq
01:57:01 <PTBD> thank you
02:09:07 <nsa_> Can anyone help me with utf8_bom?
02:12:34 <arkeet> nsa_: why not ask a more specific question?
02:13:14 <nsa_> Oops, sorry, missed to copy-paste. I already asked it early: [15:32] <nsa_> Hi there. Guys I have an ByteString from Conduit.simpleHttp, but it encoded as UTF-8 with BOM. So my Aeson dies hard while trying to parse it. Is this possible, to set utf8_bom encoding to whole bytestring or somehow drop BOM nicelly?
02:17:25 * hackagebot statistics 0.10.5.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.5.1 (AlexeyKhudyakov)
02:17:26 <lambdabot> Title: Hackage: statistics: A library of statistical types, data, and functions
02:19:18 <dmj`> nsa_: can you show us code? simpleHttp uses lazy bytestrings, void of encoding I believe. You would use Data.ByteString.Lazy.Char8 since we know http uses ascii
02:21:54 <supki> wait, why would you use .Char8?
02:22:19 <dmj`> ascii characters are 8 bits
02:22:31 <supki> yes
02:23:07 <dmj`> Oh, well, for the body of the request you'd need text, headers are ascii
02:23:43 <dmj`> I don't know what he's trying to do
02:27:26 * hackagebot colada 0.5.6 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.5.6 (GrzegorzChrupala)
02:27:26 <lambdabot> Title: Hackage: colada: Colada implements incremental word class class induction usi...
02:31:04 <nsa_> A little misunderstood, I don't want to encode [Char8] I just want to get rid of BOM
02:31:26 <nsa_> Ofcourse I can write it by hand, but I don't like idea
02:32:38 <nsa_> code is here: https://bitbucket.org/semka/gimme-models/src/4916737d59c489dab0cb410a9f81b8e588fb9688/src/Gimmemodels.hs?at=default#cl-98
02:38:10 <int-e> ok, this is weird; my lambdabot is running and according to netstat, it has an established connection to 2a02:2f0c:8000:19:62:231:75:133 (one of the chat.eu.freenode.net servers). *sigh* I guess lambdabot should learn to send its own PINGs.
02:46:04 <lasticot> hi, I've got an issue related with class and instance, the code is divided between two files how should I present it, for you to be able to comment on it?
02:46:18 <lasticot> related to*
02:47:28 * hackagebot nlp-scores-scripts 0.1.0.0 - NLP scoring command-line programs  http://hackage.haskell.org/package/nlp-scores-scripts-0.1.0.0 (GrzegorzChrupala)
02:47:30 * hackagebot labyrinth-server 0.1.3.0 - A complicated turn-based game - Web server  http://hackage.haskell.org/package/labyrinth-server-0.1.3.0 (AlexeyKotlyarov)
02:52:28 * hackagebot nlp-scores-scripts 0.2.0.0 - NLP scoring command-line programs  http://hackage.haskell.org/package/nlp-scores-scripts-0.2.0.0 (GrzegorzChrupala)
02:59:52 <sbidin> Is the Language Shootout (alioth.debian.org) dead?
03:01:12 <int-e> chrisdone: thanks for filling in!
03:08:15 <ibid> chrisdone: hmm?
03:08:31 <lpjhjdh> I've been trying to better understand category theory in haskell and was wondering if someone could help me with forgetful functors?  I can't figure out how to express any---is this because I'm stuck in hask so everything's endo?
03:10:10 <lpjhjdh> I imagine I'm wrong since I've read people pointing out other categories in haskell.
03:12:49 <mr-> lpjhjdh: This is not answering your question, but examples of other categories are arrows of the form a -> M b for M a monad
03:14:54 <mr-> (that would be called the Kleisli-category)
03:15:40 <lpjhjdh> mr-: Okay, thanks, the kleisli category is the normal notion of monads in haskell is that correct?
03:16:13 <haasn> Monads
03:17:52 <mr-> lpjhjdh: that question I do not understand. I know that every Monad gives you a category (the Kleisli category) where the objects are just the objects of Hask and the arrows are of the form I described and composition is <=<
03:20:19 <donri> lpjhjdh: you can have categories in categories
03:20:35 <quicksilver> the kleisli construction also gives rise to a functor
03:20:38 <lpjhjdh> mr-: I think that makes sense, thanks.
03:20:42 <quicksilver> from the original category to the kleisli category
03:20:47 <quicksilver> and that functor has an adjoint
03:20:54 <quicksilver> and forms a monad
03:21:01 <quicksilver> and that monad is your original monad
03:21:02 <quicksilver> magic!
03:21:10 <quicksilver> or, rather, that's the point of the construction.
03:21:24 <mr-> quicksilver: Can you describe the functor Kleisli -> Hask?
03:21:52 <int-e> (And if anyone cares: Yes, if lambdabot would send its own PINGs that should help. I have a packet dump, which towards the end shows the IRC server retransmitting packets and my server acknowledging them all, but apparently the acknowledgements got lost. After that - silence - because lambdabot never sends any messages of its own accord. But it explains how the connection could still be considered as open.)
03:22:07 <quicksilver> mr-: it's easier to describte the other one first
03:22:17 <mr-> quicksilver: and is Hask -> Kleisli just f |-> return.f ?
03:22:56 <mr-> Does that make sense, even? ;-)
03:23:24 <lpjhjdh> quicksilver: Thanks can you recommend any reading?
03:23:27 <quicksilver> well, the Kleisli category has as objects the elements 'M a'
03:23:56 <quicksilver> and as arrows between two objects 'M a' and 'M b' it has functions 'a -> M b'
03:24:12 <quicksilver> and the mapping on objects takes a to M a and on functions takes f to return.f
03:24:22 <quicksilver> (so, yes, mr-, you had the function part exactly right).
03:24:48 <lpaste> lasticot pasted “SnakeGame.hs” at http://lpaste.net/95851
03:24:54 <quicksilver> the adjoint functor from Kleisli back to Hask leaves objects where they are - so 'M a' stays at 'M a'
03:25:05 <lpaste> lasticot pasted “HDCEngine.hs” at http://lpaste.net/95852
03:25:36 <quicksilver> and it takes an arrow f::'a -> M b' into (fmap f . join)
03:25:47 <quicksilver> fmap f is M a -> M M b
03:25:53 <quicksilver> and join is M M b -> Mb
03:26:09 <quicksilver> and I hope I didn't get tangled in that mixture of standard categoric notation and haskell notation.
03:26:59 <mr-> You may have gotten the order wrong
03:27:07 <quicksilver> yes, maybe it's join . fmap f
03:27:07 <quicksilver> :)
03:27:08 <mr-> but thanks :-)
03:27:14 <lasticot> I'm getting this error message when I try to compile, there is obviously something I don't get about classes in Haskell:
03:27:15 <lasticot>     Could not deduce (b ~ SnakeInputs)
03:27:17 <lasticot>     from the context (GameInputs b)
03:27:18 <lasticot>       bound by the type signature for
03:27:20 <lasticot>                  updateGameState :: GameInputs b => SnakeGame -> b -> SnakeGame
03:27:20 <quicksilver> @type \f -> join . fmap f
03:27:21 <lasticot>       at SnakeGame.hs:(99,3)-(104,66)
03:27:22 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
03:27:23 <lasticot>       `b' is a rigid type variable bound by
03:27:24 <lasticot>           the type signature for
03:27:26 <lasticot>             updateGameState :: GameInputs b => SnakeGame -> b -> SnakeGame
03:27:27 <lasticot>           at SnakeGame.hs:99:3
03:27:29 <lasticot>     In the third argument of `updatePosition', namely `i'
03:27:29 <quicksilver> mr-: indeed it is.
03:27:30 <lasticot>     In the expression: updatePosition s ps i
03:27:32 <lasticot>     In the `snake' field of a record
03:27:54 <johnw> i think you want join . flip fmap
03:27:56 <quicksilver> lpjhjdh: reading? well, dry but detailed is Mac Lane
03:28:24 <quicksilver> lpjhjdh: we pulled together a list of possible lecture notes the other day and I didn't take note of them
03:30:43 <lpjhjdh> quicksilver: It's on my bookshelf :) though I've not yet been creative enough to make any great connections while working through anything.
03:31:00 <quicksilver> leinster's notes - http://www.maths.ed.ac.uk/~tl/msci/
03:31:08 <quicksilver> the catster videos
03:32:22 <quicksilver> johnw: I don't think so. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a is the right type.
03:32:36 <lpjhjdh> Wow, that looks great thanks.
03:32:57 <johnw> :t (>>=)
03:32:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:33:03 <johnw> :t join . flip fmap
03:33:04 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
03:33:37 <lpaste> lasticot revised “SnakeGame.hs”: “No title” at http://lpaste.net/95851
03:33:52 <quicksilver> lpjhjdh: also Cheng's notes - http://www.cheng.staff.shef.ac.uk/catnotes/
03:34:05 <quicksilver> lasticot: sorry, you ask a haskell question and get ignored.
03:34:16 <quicksilver> lasticot: but please don't paste multiline error messages here :)
03:35:01 <johnw> :t (join .) . flip fmap
03:35:01 <lambdabot> (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
03:35:30 <lasticot> quicksilver: yes sorry about that :-( I realize after doing it that I should have used lpaste
03:35:33 <quicksilver> lasticot: what is the class "GameInputs" ?
03:36:07 <lasticot> quicksilver: http://lpaste.net/95852
03:37:05 <tero-> is there a (small) upper limit for the number of type variables in a function's type?
03:38:00 <quicksilver> lasticot: updatePosition only works for 'SnakeInputs'
03:38:22 <quicksilver> lasticot: but updateGameState is required (by the class definition) to work for an abitrary instance of GameInputs
03:38:41 <quicksilver> so you can't constrain it with an implementation which requires a fixed instance
03:38:54 <lasticot> quicksilver: ok I see! thank you
03:39:14 <chrisirc> I'm looking for a function like map, but which takes two values from the argument list to pass for each call of the argument function. I.e. map2atatime :: (a -> a -> b) -> [a] -> [b]
03:40:05 <chrisirc> Do I need to write and name it myself? (Can't find anything with Hoogle.)
03:40:30 <bergmark> chrisirc: don't think there is such a function in base
03:41:03 <chrisirc> Or, a function like zip that turns a list [a,b,c,d] into [(a,b), (c,d)]
03:41:15 <bergmark> you can check MissingH and split
03:41:26 <mr-> chrisirc: zip l (tail l) ?
03:41:50 <mr-> ah, overlaps..
03:41:54 <chrisirc> mr-, and then also skip every second, yep
03:42:11 <chrisirc> That *must* exist somewhere, doesn't it?...
03:43:52 <Walther> anything in data.pair?
03:44:15 <haasn> lens
03:44:27 <haasn> -ish
03:45:26 <chrisirc> Is there a Hoogle that searches all libraries on Hackage?
03:45:29 <haasn> hayoo
03:45:51 <PTBD> quick question again. why does the upper solution work but the lower gives me error? http://pastie.org/private/h2i5jrgkt9nzx67mjahauw I saw code like my lower solution on 99 haskell problems.
03:46:19 <haasn> :t \f -> folding.chunking 2.map (foldr1 f) -- hmm
03:46:20 <lambdabot>     Couldn't match type `[b0]'
03:46:20 <lambdabot>                   with `(a0 -> Accessor (Endo [a0]) a0)
03:46:20 <lambdabot>                         -> s0 -> Accessor (Endo [a0]) s0'
03:46:26 <haasn> oh
03:48:12 <haasn> :t \f -> chunking 2 folded.to (foldr1 f)
03:48:13 <lambdabot> (Applicative f1, Foldable f, Contravariant f1) => (a -> a -> a) -> (a -> f1 a) -> f a -> f1 (f a)
03:48:25 <haasn> Not polymorphic enough
03:48:37 <dv-> PTBD: i don't get a parse error
03:48:51 <haasn> :t \f -> chunking 2 folded.to (\[a,b] -> f a b) -- ugly but meh
03:48:52 <lambdabot> (Applicative f1, Foldable f, Contravariant f1) => (t -> t -> a) -> (a -> f1 a) -> f t -> f1 (f t)
03:49:33 <PTBD> hm
03:49:40 <haasn> PTBD: whitespace issue possibly
03:50:05 <Walther> hmm, how are haskell's libraries with regards to time and date, say I wanted to create a thingy which involves calendars
03:50:24 <haasn> PTBD: make sure you either use spaces everywhere or your tabstops are set to 8 spaces
03:50:53 <PTBD> haasn, you are right. If I don't indent "where" it works. if I indent it with two whitespace it works again.
03:51:01 <PTBD> %s/again/too
03:51:14 <Eduard_Munteanu> Can you do bottom-up parsing with (atto)parsec? I was thinking of parsing expressions by applying sepBy for each operator, in increasing precedence order.
03:51:24 <PTBD> haasn, my tabspaces are set to 2
03:51:30 <chrisirc> Thanks for mentioning hayoo, haasn
03:51:43 <Eduard_Munteanu> Actually I'm not sure that's bottom-up, but what sort of parser is that?
03:52:07 <Eduard_Munteanu> Walther: they're alright, see Data.Time
03:52:21 <haasn> PTBD: any indentation is fine as long as your alignment is correct and you use spaces instead of tabs. GHC will explicitly assume *any* tab character goes to the next 8-stop, so if your editor shows them at 2 space intervals and you have two tab characters at the beginning of a line, GHC sees a 16-space indentation, even though you see a 4-space indentation
03:52:29 <haasn> That's why it's important to use spaces if you want to rely on nonstandard tabstops
03:53:07 <PTBD> haasn, thanks for the explanation. :) will change to spaces
03:53:30 <Walther> Eduard_Munteanu: say i have a calendar of some format and some spec and i want to parse the *empty/free* hours based on the other events, would there be something wieldly?
03:53:58 <Walther> iirc most calendar formats operate in either start-stop or start-duration format
03:55:33 <Eduard_Munteanu> Walther: it can parse time in various formats... I don't think ranges, but you can parse the endpoints.
03:56:05 <Eduard_Munteanu> http://hackage.haskell.org/package/time-1.4.0.1/docs/Data-Time-Format.html#t:ParseTime
03:56:33 <Walther> mmh, would probably need to whip up a data structure or what where those called myself, shouldn't be too hard
03:56:57 <nsa_> finally I had to solve BOM problem with this ugly thing:
03:57:09 <nsa_> dropBom str   | "\239\187\191" `isPrefixOf` str = drop 3 str     | otherwise = str
03:58:24 <Iceland_jack>     dropBom ('\239':'\187':'\191':str) = str
03:58:25 <Iceland_jack>     dropBom str                        = str
03:58:25 <Iceland_jack> :)
03:58:31 <Eduard_Munteanu> Walther: you can use a Set, since it can look up elements greater/smaller than a certain value
03:59:04 <nsa_> Iceland_jack: hm, nice, thanks
03:59:12 <Eduard_Munteanu> Walther: or a Map probably, if you want additional data
03:59:44 <Walther> nod. I'm thinking of a solution that would take multiple calendars and parse the free hours out of it
03:59:56 <Walther> erm, common free hours, that is
04:01:03 <Eduard_Munteanu> Walther: sounds like extracting the free hours of a Set/Map union of all your calendars.
04:01:23 <Eduard_Munteanu> Assuming the elements denote used hours.
04:02:54 <Walther> Yeah, common calendar formats use either start:stop or start:duration, i'd need to first extract the free hours per calendar and then some sort of union extraction...
04:03:23 <Eduard_Munteanu> Not sure what you should do for different intervals.
04:07:34 * hackagebot websockets-snap 0.8.1.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.8.1.0 (JasperVanDerJeugt)
04:07:58 <Eduard_Munteanu> I guess Map Start (Stop, OtherData) would work like this: to check whether a certain interval is free, you lookup the largest element smaller than the start, and check if its stop value is smaller than start. Then you look up the smallest larger than your start and see if its start is smaller than your stop.
04:09:41 <Eduard_Munteanu> If you just want to get a free interval, get two consecutive elements of the map and check the former's stop against the latter's start.
04:10:43 <Eduard_Munteanu> I've seen an interval map on hackage too, if you want something already done.
04:11:00 <Eduard_Munteanu> Walther: makes sense?
04:11:30 <Walther> yeah, avoiding reinventing the wheel whenever possible
04:12:02 <Walther> but there will be problems as it is not guaranteed that you have only one calendar entry at a time
04:12:05 <trolling> how could WriterT be fixed?
04:12:18 <Walther> at least I have calendars with easily two or three events scheduled for same hours
04:12:21 <Eduard_Munteanu> trolling: fixed?
04:12:24 <Walther> imported student union stuff etc
04:14:36 <lasticot> when I am trying to define a class with two parameters ghc asks me to add a flag at compilation to allow it, why is not natively allowed by the language?
04:16:41 <Eduard_Munteanu> lasticot: yeah, that is unfortunate, some other experimental compilers don't support it since it's more work to do it... but really, don't be afraid to enable it, it's safe to do so.
04:16:55 <Eduard_Munteanu> lasticot: a *lot* of code does that
04:17:04 <Eduard_Munteanu> Including base libraries.
04:18:52 <lasticot> Eduard_Munteanu: thank you for your answer
04:20:37 <Eduard_Munteanu> Arguably that should really get into the next Haskell201* revision.
04:22:54 <chrisdone> @botsnack
04:22:54 <lambdabot> :)
04:24:08 <Eduard_Munteanu> Can you do bottom-up parsing with (atto)parsec? I was thinking of parsing expressions by applying sepBy for each operator, in increasing precedence order. Not sure if that qualifies as bottom-up, what is it?
04:26:01 <Eduard_Munteanu> e.g. a*b + c*d + e*f --> [a*b, c*d, e*f] --> [[a, b], [c, d], [e, f]], where the nesting level corresponds to the operator.
04:27:01 <Eduard_Munteanu> When there are parens, I can "reset" and restart parsing its contents at '+' again.
04:28:01 <sopvop> Eduard_Munteanu: parsers have attoparsec instances for expression parsing like parsec
04:28:30 <Eduard_Munteanu> sopvop: yeah, I know... I wanted to do it myself instead of getting attoparsec-expr
04:28:45 <sopvop> then you just build prefix-suffix stuff
04:29:43 <Eduard_Munteanu> I already have a parser like   expr<n> = expr<n+1> <**> op<n> <*> expr<n> <|> expr<n+1>
04:29:53 <Eduard_Munteanu> But it looks a bit ugly.
04:30:52 <hulahoop> hey people, tried to use the let command in hugs. Why does it not work? Have I forgotten something?
04:31:17 <hpc> hulahoop: since you are using hugs, i am going to guess you are in college
04:31:29 <Eduard_Munteanu> hulahoop: hi... you really shouldn't use Hugs, it's very old. :)
04:31:35 <mauke> hulahoop: hugs has no let command
04:31:38 <hpc> hulahoop: can you paste the line you are trying and the error you get?
04:31:48 <hulahoop> yes, how did you know?
04:31:56 <hulahoop> wait a minute
04:32:37 <Eduard_Munteanu> hulahoop: many teachers stuck with Hugs because it had/has simpler error messages, and it also comes with a GUI for Windows, but it's rather useless for actual code in comparison with GHC.
04:32:58 <mauke> I've always preferred ghc's error messages
04:33:01 <hpc> Eduard_Munteanu: also they can't update their curriculum more than once every 10 years
04:33:12 <hpc> my compilers class was lex/yacc :(
04:33:12 <Eduard_Munteanu> Hah, really?
04:33:40 <Eduard_Munteanu> That sort of sucks, yes.
04:34:22 <Eduard_Munteanu> Sure, you can pretend to do EBNF, but I suspect a compilers class also involves looking at the generated parser, and at that point C is rather messy.
04:35:00 <hpc> one of my on-again-off-again experiments is figuring out how to write a BNF-like parser specification in perl regexes
04:35:22 <hpc> they are powerful enough, but they syntax is not the best
04:35:36 <mauke> hpc: http://mauke.hopto.org/stuff/perl/rfc2822 like that?
04:35:49 <Eduard_Munteanu> hpc: I guess you could convert any context-free grammar to that.
04:35:58 <hulahoop> is there a site I can copy/paste the input and output?
04:36:08 <Eduard_Munteanu> @where lpaste
04:36:08 <lambdabot> http://lpaste.net/new/haskell
04:36:14 <Eduard_Munteanu> hulahoop: ^^
04:36:33 <hpc> mauke: roughly, but i want to be able to pull out an AST in addition to success/fail
04:36:44 <Eduard_Munteanu> Ouch.
04:37:05 <Eduard_Munteanu> I guess you can do it with backreferences.
04:37:10 <mauke> that requires dirty tricks
04:37:57 <hulahoop> http://lpaste.net/95853
04:39:28 <lpaste> sopvop pasted “Eduard_Munteanu: expression_num function here, a shitty example of my expression parsing code” at http://lpaste.net/95854
04:39:38 <hulahoop> if it's old, why does my professor demand from us to use it? Okay, I am a "coding virgin", so to say, so I might have no right to criticize him, but this feels very restricting and it demotivates me a lot.
04:40:39 <hpc> hulahoop: curriculums aren't always kept up to date, for specific reasons like error messages from compilers or just that there's other classes to update first
04:40:48 <mauke> hulahoop: because he hasn't updated his haskell information after 1998
04:42:25 <hulahoop> then I could have been better off learning an IT related trade and then widen my horizon than to live in dire poverty and dependence.
04:42:28 <Eduard_Munteanu> sopvop: hm... but how do you set precedence for that? My unrolling does that simply by the order of expr<n>'s, and AFAICT you have to do that to get precedence levels.
04:43:06 <hulahoop> also, how do you use this red color? is this a private message?
04:43:07 <Eduard_Munteanu> sopvop: oh, yours does the same thing, nvm :)
04:43:13 <hpc> hulahoop: new technology is way easier to learn than new concepts
04:43:24 <hpc> even with hugs, your class is completely worth the price of entry
04:43:40 <Eduard_Munteanu> hulahoop: possibly nick highlighting... if you write others' names,  their client generally highlights them
04:44:04 <Eduard_Munteanu> hulahoop: try using tab-completion... e.g. Edua<tab> --> Eduard_Munteanu
04:44:08 <hpc> there's tab completion so you can type "ed<tab>"
04:44:28 <sopvop> Eduard_Munteanu: I've just unrolled what parsec.expressions do :)
04:44:41 <hulahoop> hpc, Eduard_Munteanu: like this?
04:44:44 <hpc> yep
04:44:50 <hulahoop> cool.
04:44:52 <Eduard_Munteanu> hulahoop: yep
04:45:45 <mauke> this channel blocks color codes so all colors you see are made up by your client
04:46:45 <Eduard_Munteanu> sopvop: any thoughts on my sepBy attempt, though?
04:47:09 <Eduard_Munteanu> I haven't really tried it, but it seems a bit more efficient and you might be able to control associativity.
04:47:50 <hulahoop> I actually like my class. I love to learn new things and try to solve them. Unfortunately I seem to have a really hard time to understand haskell and this natural science related mathematics. They both seem to be reliant on each other.
04:47:56 <sopvop> Eduard_Munteanu: You can as well just parse with sepBy and then float expressions by fixity, like GHC does
04:48:06 <hulahoop> But, it makes fun, just wish they went a bit slower
04:48:23 <hulahoop> so I could have more time to understand it
04:48:30 <sopvop> hm, sepBy won't help
04:48:55 <mauke> "makes fun"? potential german detected
04:49:01 <Eduard_Munteanu> sopvop: GHC does that?
04:49:20 <sopvop> Eduard_Munteanu: yeah, you can specify your own operators and fixity for them, you know...
04:49:23 <Eduard_Munteanu> sopvop: why won't it work?
04:49:35 <Eduard_Munteanu> Well, I have to obey parens, but that shouldn't be a problem.
04:50:02 <Eduard_Munteanu> I could make a first pass and make parens opaque.
04:50:16 <Eduard_Munteanu> Then sepBy the lowest precedence operator.
04:50:26 <chrisirc> What can I do if this happens?: package hashtables-.. is unusable due to missing or recursive dependencies: vector-0.9.1-5feabc311645326f59f50b0ea9890e1a ... is shadowed by package vector-0.9.1-04dd5c58c224b03a4dc90091cf93a01d
04:50:29 <hulahoop> mauke, more an immigrant from turkey who wants to learn and understand.
04:51:00 <mauke> in english things *are* fun, they don't *make* fun :-)
04:51:00 <Eduard_Munteanu> chrisirc: reinstall hashtables
04:51:21 <chrisirc> Eduard_Munteanu, it's the one from Debian, i.e. uninstall that and reinstall with cabal?
04:52:15 <Eduard_Munteanu> chrisirc: ah, no... I guess your user packages mess with that.
04:52:30 <sopvop> Eduard_Munteanu: I think that just complicates things, and I doubt it will run any faster. Because you will have to reparse every expression up to num of ops times, with conventional thing you parse LHS then backtrack on RHS
04:52:45 <Eduard_Munteanu> chrisirc: you could erase ~/.cabal and ~/.ghc if you want to get a clean user repo
04:52:53 <lpaste> lasticot revised “SnakeGame.hs”: “SnakeGame.hs” at http://lpaste.net/95851
04:53:13 <hulahoop> thanks, mauke
04:53:35 <chrisirc> Well, that's what I expected to hear. But this is just a * f*up -- in the end that means, for every program I need to create a separate unix user so that each can have their own .cabal
04:53:43 <lpaste> lasticot revised “HDCEngine.hs”: “HDCEngine.hs” at http://lpaste.net/95852
04:53:48 <sopvop> Eduard_Munteanu: check this out https://ghc.haskell.org/trac/haskell-prime/wiki/FixityResolution
04:53:50 <Eduard_Munteanu> sopvop: not sure, why do I have to *re*parse?
04:54:05 <Eduard_Munteanu> It seems to me every expression is parsed only once.
04:54:20 <sopvop> Eduard_Munteanu: because you retry sepBy?
04:54:46 <lpaste> lasticot pasted “main.hs” at http://lpaste.net/8122470703690678272
04:55:03 <trolling> Eduard_Munteanu: fixed inre the recent space leak thing that gabriel gonzalez brings up
04:55:39 <Eduard_Munteanu> sopvop: I don't retry sepBy, consider e.g.  (...) + a*b + a*(...) --> [(...), a*b, a*(...)]
04:55:50 <Eduard_Munteanu> trolling: link?
04:55:57 <ginmaniac> @source (:)
04:55:57 <lambdabot> Unknown command, try @list
04:56:46 <Eduard_Munteanu> sopvop: so that's done with (+) for the toplevel, the only other plus there can be is inside the parens.
04:57:08 <trolling> http://comments.gmane.org/gmane.comp.lang.haskell.libraries/18040
04:57:56 <sopvop> Eduard_Munteanu: I don't get it
05:00:15 <lasticot> I'm trying to write a generic piece of code in http://lpaste.net/8122470703690678272 that could be used for any instance of GameState I will define in the future (not at the same time but for diffreent project). GHC does not like it because I don't specify  the current instance of GameState I am using . How should I approach the problem to solve it? The other pieces of code are here ...
05:00:16 <lasticot> ...http://lpaste.net/95852 and there http://lpaste.net/95851.
05:00:18 <int-e> ginmaniac: as pseudo-code, that would be  data [a] = [] | a : [a]  but it's actually baked into the compiler.
05:01:26 <int-e> oh wait. GHC.Types has it as  data [] a = [] | a : [a]  ... fun :)
05:04:18 <Eduard_Munteanu> sopvop: let   expr = expr { op expr } | var | '(' expr ')', op = '+' | '*'
05:05:29 <merijn> ginmaniac: (:) doesn't have a source, it's a data constructor, like "Just" and Left/Right
05:06:12 <Eduard_Munteanu> sopvop: in a first pass I can make parens opaque:  expr = simple | '(' expr ')', simple = simple { op simple } | var   and apply sepBy for 'simple' expressions.
05:07:46 <Trevion> Hello.  Does anyone know if there's a way to recover forgotten user names on the GHC trac?
05:08:32 <Eduard_Munteanu> sopvop: which gets me   (var | parens) { op (var | parens) }
05:09:31 <Eduard_Munteanu> So if I sepBy '+', I'm done with '+' except in the parenthesized expressions.
05:10:02 <Eduard_Munteanu> sopvop: does it make any more sense now?
05:10:17 <Eduard_Munteanu> :t sepBy
05:10:19 <lambdabot> Eq a => [a] -> [a] -> [[a]]
05:10:53 <Eduard_Munteanu> > "a*b + c*(...) + d" `sepBy` "+"
05:10:55 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
05:11:20 <Eduard_Munteanu> > sepBy "+" "a*b + c*(...) + d"
05:11:21 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
05:12:08 <Eduard_Munteanu> :t splitBy
05:12:09 <lambdabot>     Not in scope: `splitBy'
05:12:09 <lambdabot>     Perhaps you meant one of these:
05:12:09 <lambdabot>       `splitAt' (imported from Data.List),
05:12:18 <Eduard_Munteanu> :t splitOn
05:12:19 <lambdabot> Eq a => [a] -> [a] -> [[a]]
05:12:29 <Eduard_Munteanu> > splitOn "+" "a*b + c*(...) + d"
05:12:30 <lambdabot>   ["a*b "," c*(...) "," d"]
05:13:27 <Eduard_Munteanu> > map (splitOn "*") . splitOn "+" . filter (/= " ") $ "a*b + c*(...) + d"
05:13:28 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:13:29 <lambdabot>              with actual type...
05:13:36 <Eduard_Munteanu> > map (splitOn "*") . splitOn "+" . filter (/= ' ') $ "a*b + c*(...) + d"
05:13:37 <lambdabot>   [["a","b"],["c","(...)"],["d"]]
05:14:15 <Eduard_Munteanu> sopvop: that's the basic idea ^... and you can choose associativity too it seems.
05:16:16 <sopvop> Eduard_Munteanu: Oh, you also parse separator from sepBy. then check out ghc track link I've already posted for fixity fixing :)
05:16:54 <sopvop> that one https://ghc.haskell.org/trac/haskell-prime/wiki/FixityResolution
05:18:47 <Eduard_Munteanu> sopvop: I actually have rather simple expressions, the levels are known beforehand
05:19:52 <Eduard_Munteanu> sopvop: any idea what that sort of parser would be called? I thought atto(parsec) was LL, but...
05:20:21 <sopvop> no idea
05:20:30 <Eduard_Munteanu> I suspect I want to compute the innermost parens first, making it pretty much a bottom-up parser.
05:21:11 <Eduard_Munteanu> Ok, thanks, let me code it first :)
05:23:48 <zennist> say I have a list of strings [String]; how can I easily prefix each string with its index in the list?
05:24:03 <Eduard_Munteanu> zennist: zip [0..]
05:24:20 <Eduard_Munteanu> > zip [0..] ["foo", "bar", "baz"]
05:24:22 <lambdabot>   [(0,"foo"),(1,"bar"),(2,"baz")]
05:24:50 <zennist> does zip stop zipping at the shorter list?
05:24:51 <Eduard_Munteanu> zennist: what do you want that for?
05:24:55 <Eduard_Munteanu> Yes.
05:24:58 <zennist> cool
05:25:21 <Eduard_Munteanu> It can't possibly do otherwise.
05:25:28 <zennist> nuh, I was showing a list of strings on my statusbar and I want to easily see the order
05:26:03 <donri> @src zip
05:26:04 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
05:26:04 <lambdabot> zip _      _      = []
05:26:05 <FireFly> Eduard_Munteanu: couldn't repeat the other list indefinitely?
05:26:15 <FireFly> (I mean, while adhering to the type signature)
05:26:19 <Eduard_Munteanu> Oh, well, I guess it can.
05:27:38 <identity> How woudl I go about doing something like .. instance (Bounded a, Enum a) => MyClass a where .. doStuff = blah . fromEnum
05:27:41 * hackagebot pipes-cereal-plus 0.2.0 - Streaming serialization library on top of "pipes" and "cereal-plus".  http://hackage.haskell.org/package/pipes-cereal-plus-0.2.0 (NikitaVolkov)
05:27:43 * hackagebot cereal-plus 0.2.0 - Extended serialization library on top of "cereal".  http://hackage.haskell.org/package/cereal-plus-0.2.0 (NikitaVolkov)
05:27:43 <identity> do I need flexible instances for that?
05:28:05 <donri> identity: http://stackoverflow.com/a/3216937/931420
05:28:52 <donri> identity: such an instance would match anything of kind *, meaning you can't have any other instances of that kind
05:29:20 <donri> the constraints are not part of the instance resolution
05:31:32 <identity> donri: I'm not quite sure I get it. I just know that I can make anything that is an instance of Bounded and Enum an instance of my class -- I figured I could express that like that
05:32:07 <Eduard_Munteanu> identity: why not a class constraint then?
05:32:09 <sopvop> identity: but you can't specialize it
05:32:56 <identity> Eduard_Munteanu: Well, I considered that
05:33:13 <identity> but that would then require people to make their types instances of bounded and enum
05:33:33 <identity> which I guess might work
05:34:00 <identity> no, actually. Just enum.
05:34:04 <identity> hmm, guess that'll work
05:35:21 <donri> identity: you can write this instance with the right extensions, but you'll need OverlappingInstances to write any other instances of that kind. it's probably not what you want
05:35:37 <Eduard_Munteanu> identity: well, it depends... do that if MyClass has Bounded and Enum as superclasses, morally. If it just happens you can derive instances for them, then you should probably use a newtype and instance constraints.
05:36:16 <Eduard_Munteanu> identity: or, provide a function  f :: (Bounded a, Enum a) => ...
05:36:35 <donri> identity: and without overlap, it just becomes a synonym for bounded and enum for that kind, and you might prefer ConstraintKinds
05:36:52 <Eduard_Munteanu> Then the user can do  instance MyClass UserType where method = f
05:38:23 <donri> or go with Eduard_Munteanu's suggestion and DefaultSignatures, and you just need to say, instance MyClass UserType
05:40:39 <identity> Hmm. Thanks, I'll try some stuff
05:41:19 <tarruda> how do I specify a path relative to the package directory in cabal's extra-lib-dirs option?
05:43:50 <Guest__________> somebody here with 10minutes time? :-)
05:44:11 <Iceland_jack> Guest__________: Are 9 minutes okay?
05:44:27 <Guest__________> yes, sure :)
05:44:28 <linduxed> !ask
05:44:44 <linduxed> hmmm, that command wasn't handled by the bot
05:44:59 <Iceland_jack> Guest__________: What linduxed is getting at: don't ask to ask, just ask
05:45:00 <Iceland_jack> :)
05:49:22 <Iceland_jack> sure
05:50:56 <tomejaguar> Where does the Show instance for [Char] come from, and is it somehow special?
05:52:47 <grok20> is it possible to pattern match a list like (x:xs) where the value of x is fixed... i.e. ("hi"@x:xs)
05:53:45 <tomejaguar> grok20: how about 'h':'i':xs
05:54:39 <asmyers> tomejaguar: I'm guessing `instance Show a => Show [a] -- Defined in `GHC.Show'
05:54:40 <asmyers> `
05:54:48 <asmyers> From :info Show
05:55:08 <tomejaguar> asmyers: But the Show instance for [Char] is not the same as the one for [a], for a /= CHar
05:55:12 <grok20> tomejaguar: hmm... wouldn't that match ["h", "i", "blah", "blah"]. when I want to match ["hi", "blah", "blah"]
05:55:16 <asmyers> tomejaguar: Ah, right
05:55:22 <quicksilver> grok20: "hi":xs
05:56:11 <FireFly> quicksilver: that doesn't work, does it? that becomes  'h':'i':[]:xs
05:56:24 <quicksilver> > let f ("hi":xs) = "well hello"; f _ = "what kind of greeting is that?" in f ["hi","there"]
05:56:25 <lambdabot>   "well hello"
05:56:38 <tomejaguar> grok20: That would match ['h', 'i', 'b', 'l', 'a', 'h'].  quicksilver has your correct answer.
05:56:39 <FireFly> Oh
05:56:44 <quicksilver> FireFly: it becomes ('h':'i':[]):xs
05:56:50 <k00mi> tomejaguar: Show has method "showList" for that purpose
05:56:57 <grok20> tomejaguar, quicksilver: awesome, thanks :)
05:58:01 <lasticot> I'm trying to write a generic piece of code in http://lpaste.net/8122470703690678272 that could be used for any instance of GameState I will define in future projects. GHC does not like it because I don't specify the current instance of GameState I am using . How should I approach the problem to solve it? The other pieces of code are here http://lpaste.net/95852 and there http://lpaste.net/95851.
05:59:14 <tomejaguar> k00mi: Oh that's cunning!
05:59:17 <merijn> asmyers, tomejaguar: No, Show cheats and has an optional "showList :: [a] -> String" function
05:59:29 <tomejaguar> merijn: Oh that's cunning!
05:59:39 <merijn> asmyers, tomejaguar: "instance Show a => Show [a] where show = showList"
06:00:03 <merijn> tomejaguar: This means that every show instance can override it's list version (which, for example, Char does to pretty print strings)
06:00:18 <tomejaguar> Yup, that's a neat hack.
06:00:58 <merijn> lasticot: You don't list an error anywhere?
06:01:57 <lpaste> lasticot pasted “Error SnakeGame” at http://lpaste.net/5481866252525764608
06:02:27 <lasticot> merijn: here it is: http://lpaste.net/5481866252525764608
06:03:21 <lasticot> merijn: there are others but they are based on the same problem I believe
06:06:40 <lpaste> lasticot revised “Error SnakeGame”: “No title” at http://lpaste.net/5481866252525764608
06:07:48 <merijn> lasticot: How is GHC supposed to know which gameState function to run?
06:14:58 <lasticot> merijn: I agree that currently it is not able to do that, is it possible for me specify the gameState function without changing the main? My idea was to factorize as much code as possible in a video game to be able to use it over different projects.
06:17:34 <merijn> lasticot: Well, why are you using a typeclass at all, can you simply use parametric polymorphism? I.e. provide and "IO a" and "gameLoop :: State a () -> IO a" or whatever you want and use those?
06:17:43 <merijn> lasticot: Why is there a GameState typeclass at all?
06:27:45 * hackagebot bert 1.2.1.1 - BERT implementation  http://hackage.haskell.org/package/bert-1.2.1.1 (RomanCheplyaka)
06:30:15 <khyperia> uhhh... was this supposed to happen? https://dl.dropboxusercontent.com/u/18830644/Screenshot%202013-11-18%2009.12.49.png
06:30:59 <khyperia> "the 'impossible' happened"
06:31:28 <mauke> khyperia: bug in ghc
06:32:01 <Eduard_Munteanu> khyperia: lift assignPolytypes expr  seems to have the wrong type anyway
06:32:12 <Eduard_Munteanu> :t lift ?f ?x
06:32:15 <lambdabot>     Couldn't match kind `* -> *' with `OpenKind'
06:32:15 <lambdabot>     Expected type: t0 -> a0
06:32:15 <lambdabot>       Actual type: t0 -> a0
06:32:20 <Eduard_Munteanu> :t lift $ ?f ?x
06:32:21 <lambdabot> (Monad m, ?f::t1 -> m a, ?x::t1, MonadTrans t) => t m a
06:33:04 <khyperia> ah, yep, it was just newExpr <- assignPolytypes expr
06:33:21 <khyperia> probably the lift was from copy-paste somewhere else
06:40:53 <tarruda> Is there a tutorial/walkthrough on how to create a cabal package that uses FFI to talk to C libraries?
06:43:20 <lasticot> merijn: I'm sorry I was afk, let me think about your question.
06:43:57 <merijn> tarruda: There's some stuff on the wiki and lots of libraries that use it
06:44:17 <merijn> tarruda: The cabal manual also has some stuff to compile C code
06:45:55 <dcoutts> tarruda: were you asking earlier about a C main file? The latest version of Cabal supports that I think.
06:46:06 <merijn> dcoutts: It does
06:46:30 <tarruda> merijn: I've seen some ffi examples, especially the realworldhaskell example on how to link PCRE. I'm missing a complete example that uses cabal to build a haskell library that links to a native C library.
06:46:46 <merijn> tarruda: https://github.com/merijn/posix-pty
06:47:21 <merijn> tarruda: That doesn't deal with custom structs (which can be a bit tricky), but it does import 1) CPP macros 2) link and call C functions and 3) compile some custom C wrappers
06:49:08 <Freundlich> What's the best way to deal with rpath in cabal? I'm linking to a C library that is not in the default LIBRARY_PATH.
06:49:34 <merijn> Freundlich: You can just specify linker flags to GHC, I think?
06:49:45 <dcoutts> ld-options
06:49:55 <eacameron1> cabal installing anything says the package is corrupt...any ideas how to fix it? cabal update does not fix it
06:50:02 <tarruda> merijn: thanks, do I have to install some libraries in order to compile it?
06:50:12 <tarruda> merijn: I've tried cabal configure && cabal build
06:50:35 <merijn> tarruda: That should run and install on any sane posix platform (i.e. anything reasonable other than windows)
06:51:22 <Ropt> Has/can Haskell be used to develop REST-services?
06:51:25 <tarruda> I'm getting      error: ‘TIOCPKT_NOSTOP’ undeclared (first use in this function)  plus a few other errors on cabal build
06:51:35 <tarruda> on ubunt 12.04
06:51:37 <Eduard_Munteanu> Ropt: yes, Yesod goes that way
06:51:39 <Peaker> @faq Can Haskell be used to develop REST services?
06:51:39 <lambdabot> The answer is: Yes! Haskell can do that.
06:51:48 <lasticot> merijn: it was a matter of giving an interface for potential other users to be able to re-use the factorized code
06:51:48 <merijn> tarruda: Oh, Ubuntu does't install development headers by default
06:51:56 <tarruda> yes
06:51:56 <geekosaur> eacameron1, you might look at the package to see if the download got intercepted by a proxy or something
06:52:05 <merijn> tarruda: You need to install those, dunno the package they're in, though
06:52:28 <merijn> Someone here probably knows, though
06:52:36 <dcoutts> eacameron1: what is the error message exactly? and when running what command?
06:52:38 <Freundlich> Ok, I'll try ld-options but that seems to be cumbersome.
06:52:40 <eacameron1> geekosaur: hmmm...never done that before, could it be the network I'm on?
06:53:10 <eacameron1> geekosaur: cabal.exe: internal error when reading package index: could not read tar file entryThe package index or index cache is probably corrupt. Running cabal update might fix it.
06:53:21 <geekosaur> oh, package index
06:53:29 <geekosaur> hm
06:53:43 <eacameron1> I did a cabal update yesterday when everything was down....
06:54:24 <eacameron1> any way I can clear the package index cache?
06:54:58 <dcoutts> eacameron1: rm ~/.cabal/packages/hackage.haskell.org/00-index.*   and then cabal update
06:55:24 <dcoutts> eacameron1: you're using the normal hackage server right? not a mirror
06:55:31 <eacameron1> right
06:57:03 <eacameron1> dcoutts: geekosaur: looking good! clearing the cache seems to have done the trick
07:00:34 <eacameron1> good to know...cabal update when hackage is down can do bad things
07:00:55 <dcoutts> I'm a bit surprised that just doing update didn't fix it
07:03:02 <bz> ideas on obtaining the disjoint subsets of a graph?
07:03:37 <dcoutts> @hoogle graph components
07:03:38 <lambdabot> No results found
07:03:43 <dcoutts> @hoogle components
07:03:43 <lambdabot> Data.Graph components :: Graph -> Forest Vertex
07:03:43 <lambdabot> Data.Graph.Inductive.Query.DFS components :: Graph gr => gr a b -> [[Node]]
07:03:43 <lambdabot> Graphics.Rendering.OpenGL.GL.Evaluators getMap1Components :: (Map1 m, ControlPoint c, Domain d) => m c d -> IO ((d, d), [c d])
07:05:40 <lilred> hey guys, I know this doesn't have much to do with Haskell, but I'm wondering about the semantics of indexing over collections - like, say, a map that also acts as an ordered sequence, or a map that is indexed according to two different fields
07:06:17 <lilred> I'm wondering if there are ways to compose data structure indexing strategies so that everything remains consistent
07:06:20 <bz> dcoutts: thanks
07:07:23 <lilred> I've had to manually design maps that can be indexed on several fields, and it's a tedious and error-prone process
07:08:42 <merijn> lilred: Sounds vaguely like lens might help you, but you'll have to wait for one of them to enlighten you on how
07:09:06 <lilred> Edward Kmett's lens?
07:09:38 <merijn> Yeah
07:10:03 <merijn> lilred: They have things like indexing traverals that can be composed and have all sorts of reasoning you can do about them
07:10:14 <lilred> merijn: that's nice, I've looked into them before but it's abstract enough that it's just out of reach for me D:
07:10:16 <merijn> lilred: (i.e. based on the lens laws)
07:10:36 <merijn> lilred: Usually one of them is available to give a lecture in here or in #haskell-lens :p
07:10:42 <lilred> oh wow
07:10:56 <lilred> well I sometimes see E. Kmett on Reddit so maybe I'll just msg him there :)
07:11:51 <tomejaguar> lilred: You can try #haskell-lens
07:11:52 <lpaste> identity pasted “How to do this instance/typesystem magic?” at http://lpaste.net/95859
07:11:55 <haasn> lilred: sounds like you want edward kmett's tables
07:11:59 <identity> Someone feel like taking a look?
07:12:07 <haasn> which provides a Map-like structure with multiple (arbitrary, user-defined) keys
07:12:15 <identity> I have a feeling this should be possible, but I'm just not sure how to do this
07:12:23 <identity> I kind of want to do a Aeson-ish API
07:12:32 <haasn> composing (indexed) traversals is more about going deeper into structures
07:13:46 <lilred> haasn, merijn: the fact that this exists is pretty damned awesome, are there other things in the Haskellverse I should be aware of? So far I've only played with Parsec
07:14:10 <haasn> Just look at edwardk's github page :)
07:14:22 <haasn> also diagrams. Diagrams is pretty cool. And FRP.
07:14:53 <lilred> haasn: lolwut, this is amazing
07:15:03 <lilred> haasn: is the best FRP framework Netwire?
07:15:25 <lilred> I'm currently working on an FRP framework using linear temporal logic to give typesystem-level guarantees
07:15:28 <haasn> FSVO ‘best’. I like netwire, because I think working with arrows is easier than the other interfaces I've seen
07:16:34 <lilred> also how can I learn how to use GADTs D:
07:16:46 <haasn> by learning GADTs, most likely
07:16:50 <haasn> how to use*
07:17:06 <haasn> I mean, by using GADTs*
07:17:08 <deweyvm> lilred: http://en.wikibooks.org/wiki/Haskell/GADT ?
07:17:38 <deweyvm> but i also agree with haasn
07:18:32 <adnap> lilred: http://vimeo.com/12208838 (GADT)
07:18:53 <byorgey> identity: what error do you get with that code?
07:19:11 <byorgey> identity: note that should be  'encode d'  not  'encode dmg'
07:19:12 <identity> byorgey: Unless Hero is an instance of Enum, it doesn't type-check.
07:19:16 <identity> oh..
07:19:29 <identity> yes, there are a couple of other oversights as well
07:19:51 <byorgey> identity: hmm, I'm actually surprised that declaration of  ToChromosome is valid
07:19:56 <identity> but the point still stands. What I'm trying to do is a aeson-ish API. data SomeType = Foo Int String
07:20:04 <byorgey> identity: because the default implementation of encode does not have type  a -> Chromosome.
07:20:38 <merijn> The wikibook on GADTs is pretty good, and tbh they're not all that difficult :)
07:20:47 <merijn> lilred: Hmm, STM?
07:20:50 <byorgey> identity: perhaps you want the DefaultSignatures extension.  Let me play with this for a minute.
07:21:03 <lilred> merijn: I'm mostly wondering how the heck can GADTs be used to simulate dependent typing
07:21:11 <identity> byorgey: I actually forgot to include the original constraint on the class. It was class Enum a => ToChromosome a where ..
07:21:14 <lilred> merijn: and also, whether they can be used to encode linear types
07:21:19 <haasn> lilred: have a look at the paper on singleton types perhaps
07:21:26 <merijn> lilred: Usually you use a mix of TypeFamilies, GADTs and DataKinds for that sort of stuff
07:21:27 <identity> because I can encode all types that are instances of Enum using fromEnum, etc.
07:21:29 <haasn> lilred: http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf
07:21:43 <haasn> that's the closest to “simulating dependent types” in Haskell I know
07:21:54 <merijn> lilred: GADTs are the simple stepping stone that make the other two extensions a lot more useful
07:22:09 <lilred> thank you haasn, I've added it to my reading list :)
07:22:25 <byorgey> identity: right, though that constrains you to *only* have instances of Enum, which I think is your problem
07:22:31 <merijn> lilred: GADTs give you more control over phantom types and then you use TypeFamilies/DataKinds to encode cool things in phantom types
07:22:44 <lilred> merijn: I'll look into it, thank you so much!
07:22:50 * hackagebot git-annex 5.20131118 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20131118 (JoeyHess)
07:23:23 <identity> byorgey: Yes, I guess. I'm not sure how to do this
07:23:27 <byorgey> identity: just a second
07:23:32 <merijn> lilred: The wikibook also has a chapter on phantom types, but tbh I think they're fairly obvious and the GADT wikibook should explain them fairly well (by examples)
07:23:44 <lilred> merijn: how efficient is STM by the way? I've heard really bad things about it, is it crippled by performance issues or are there use cases for it?
07:23:55 <lilred> merijn: (I typically use the actor model for concurrency)
07:23:57 <merijn> lilred: It depends on your use
07:24:26 <merijn> lilred: The problem is that it suffers from thundering herd problem (i.e. if you have 10k threads blocked on a channel/TVar and it changes they all get woken up)
07:24:34 <lilred> ouch!
07:24:48 <lilred> so latency issues?
07:25:13 <merijn> lilred: Googling for "thundering herd" problem should explain that issue better
07:25:26 <fryguybob> lilred: I'm working on improving GHC's STM performance.
07:25:33 <lilred> merijn: yeah I've just looked into it.
07:25:36 <merijn> lilred: OTOH, if your transactions only clash occasionally or don't block a lot they should be really cheap
07:25:53 <haasn> STM can be a lot cheaper than locking/unlocking if you don't clash much
07:26:14 <merijn> lilred: As long as you don't have a lot of actors blocking on the same things the overhead is fairly low
07:26:31 <merijn> lilred: The STM paper is very readable, btw
07:26:39 <merijn> lilred: It's linked from the docs, I believe
07:26:52 <lilred> will check it out!
07:27:03 <lilred> I'm saving a log of this conversation, so many research leads I'm good for several months
07:27:29 <fryguybob> lilred: Right now it does not handle having a large number of TVar's touched in a single transaction and it isn't particularly fair given contention.
07:27:34 <merijn> lilred: Oh and since I mentioned TypeFamilies, "Fun with Type Functions" is cool too
07:28:09 <merijn> And should be easy if you're comfortable with type signatures and type classes
07:29:01 <byorgey> identity: see my annotation at http://lpaste.net/95859
07:29:24 <lilred> that should work :) I have a lot of experience doing FP dev in F# and Standard ML but Haskell is just this brave new world for me
07:29:26 <identity> byorgey: oh, is that really all?
07:30:10 <lilred> do you guys think Haskell has mainstream potential? o.O
07:30:41 <byorgey> identity: is what really all?
07:31:02 <identity> byorgey: the explicit method declaration thing
07:31:05 <Iceland_jack> lilred: Nope!
07:31:08 <identity> but I see you added an extension as well
07:31:45 <merijn> lilred: Yes, there has been a massive popularity spike the past 5 or so years
07:31:46 <dcoutts> lilred: STM performance often compares pretty well to MVars, surprisingly.
07:32:23 <dcoutts> lilred: yes certainly has mainstream potential
07:32:35 <fryguybob> lilred: We have a wonderful community, vibrant research activity, industrial use, that's enough for me :D.
07:32:49 <lilred> fryguybob: agree on all points :D
07:33:04 <lilred> especially for research, I'm very tech-agnostic but I wouldn't want to break new ground in any other language
07:33:36 <klugez> I'd like to see more industrial use, so that I'd actually get to use it. :)
07:33:49 <byorgey> identity: I added the DefaultSignatures extension, which allows you to give two type signatures to class methods: one "generic" signature (which every instance must satisfy) and one signature for the default implementation
07:34:20 <merijn> klugez: There's loads of financial places using it, and of course facebook is working on stuff internally
07:34:40 <byorgey> identity: so if you just use the default implementations it will require Enum and Bounded.  But you can also explicitly override the methods if you have a way to do it without using Enum or Bounded.
07:34:57 <lilred> I'm working on raising FP adoption at my school, through workshops and such
07:35:24 <lilred> payoff's great, the few employers with open FP jobs come here to get their fill
07:35:32 <haasn> I want Haskell to replace Java as “the language students are forced to use during the first semester” ;)
07:35:47 <klugez> merijn: Yeah, I'm seeing a lot of references to jobs. But they are all expecting way more than I have to offer.
07:36:17 <klugez> Hopefully there will be more and more job offers and I'll improve, so that eventually there's a match.
07:36:25 <jpcooper> looking at http://www.haskell.org/haskellwiki/Performance/Strictness , can someone explain why lgo in the definition for foldl is strict on the argument z, but suminit is not strict on the argument acc?
07:36:35 <identity> byorgey: Aah, I see. Thanks!
07:37:09 <byorgey> identity: note this extension is new in GHC 7.6, so it won't work with anything older
07:37:40 <byorgey> identity: with older GHCs, what I would do is simply to move the default implementations outside the class.  That is, just provide some implementations of the methods using Enum and Bounded.
07:38:13 <byorgey> then when you make an instance, you can just define encode = encodeDefault  and so on.
07:38:20 <identity> Aah, okay. I see.
07:38:21 <byorgey> A bit more boilerplate but it gets the job done.
07:39:05 <merijn> klugez: Have you looked at haskellers.com?
07:39:23 <TheBrayn> hi
07:39:47 <haasn> jpcooper: rough guess: because acc is never returned directly but instead as component of a (lazy) tuple?
07:41:08 <klugez> merijn: Occasionally. Haven't seen any jobs in Finland yet.
07:41:46 <merijn> klugez: There tend to be telecommute openings, also some companies tend to contact people directly from there with offers
07:42:03 <jpcooper> haasn: maxes sense
07:42:06 <jpcooper> whoah, makes
07:42:23 <tdammers> I've been contacted a few times, but it never went anywhere in the end
07:42:29 <tdammers> interesting opportunities though
07:44:31 <tarruda> merijn: I've created a cabal package that depends on a C static library, it compiles and generates the .o files successfully. Clearly the .o file still depends on the object files contained in the static library, so how do I load those in ghci?
07:45:15 <tarruda> merijn: loading the .o file fails since it depends on things defined in the c library
07:45:30 <merijn> tarruda: There was a trick, but I forget. Should be in the ghc/ghci manual (i.e. you want to tell it to load the compiled haskell code, rather than bytecode. The former works with external libraries)
07:46:47 <tarruda> merijn: I see that ghci accepts -l to link against shared libraries, so perhaps I can build a shared library already containing both the 'cbits' compiled code plus the C static library?
07:47:05 <tarruda> merijn: I just dont know how to make cabal output a shared library
07:53:50 <merijn> tarruda: If your cbits are linked into your haskell code, that should be sufficient the only thing you need to do is tell ghci not to use the bytecode version of your haskell, but the proper compiled version
07:53:57 <merijn> tarruda: There's a flag for that, but I forget what
07:55:13 <tarruda> merijn: even if the cbits code depends on a static library? the cbits compiled code clearly doesn't include the static library object code
07:56:12 <tarruda> merijn: as I said, I managed to compile and run a simple cbits file from ghci, the problem is when the cbits code depends on a external static library
07:56:44 <tarruda> merijn: cabal wont build a shared object file containing both the cbits plus the static library
07:57:05 <tarruda> merijn: it just builds standalone object files for my cbits sources
07:59:20 <merijn> hmm, that I don't know
08:00:52 <identity> @hoogle (a -> b) -> (a, a) -> (b, b)
08:00:52 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:00:52 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
08:00:52 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
08:00:59 <identity> huh.
08:01:13 <identity> does that function exist? Maybe in Control.Arrow? I don't really get arrow type signatures
08:02:33 <merijn> identity: Yes
08:02:38 <merijn> :t join (***)
08:02:39 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
08:03:05 <merijn> identity: It's simple, just remember that (->) is an instance of arrow, so you can replace the arro type variable with (->)
08:03:40 <klugez> :t (both %~)
08:03:41 <lambdabot> (a -> b) -> (a, a) -> (b, b)
08:03:49 <merijn> "a b c -> a (b, b) (c, c)" == "(->) b c -> (->) (b, b) (c, c)" == "(b -> c) -> ((b, b) -> (c, c))"
08:03:53 <klugez> Obligatory lens version.
08:04:01 <identity> Haha. :)
08:04:07 <identity> merijn: Okay, that actually made it a lot simpler
08:04:09 <identity> thanks
08:04:23 <merijn> I campaigned for "both = join (***)" in Control.Arrow, but got shot down :\
08:04:36 <merijn> identity: Yeah, once you learn that trick most Arrow signatures become really eassy
08:04:43 <identity> Just now when I needed that function, I thought "it's probably called both if it exists"
08:04:47 <identity> but that's strange :/
08:05:13 <merijn> I blame libraries@ for it not existing!
08:05:53 <klugez> :t over both
08:05:54 <lambdabot> (a -> b) -> (a, a) -> (b, b)
08:06:14 <klugez> That's actually clearer, not sure why I sectioned %~ in the first place.
08:16:53 <Guest__________> what is the meaning of ord in haskell?
08:17:24 <scott_> Ord is a typeclass for types which are ordered (you can compare with < and so on)
08:17:54 <TheBrayn> Ord the class for ordered datatypes?
08:18:15 <TheBrayn> strange question to ask on irc
08:18:40 <mangaba_leitosa> yes, this kind of question is to be asked in person
08:18:41 <klugez> Guest__________: Data.Char.ord takes a character and gives its character code as an Int.
08:19:00 <shiona_> http://lpaste.net/95863 parse error on the second do. What am I doing wrong?
08:19:24 <scott_> shiona_: Why are you using brackets?
08:19:27 <Iceland_jack> > ord 'a' -- Guest__________
08:19:29 <lambdabot>   97
08:20:17 <shiona_> scott_: A habit I guess. Are they the cause?
08:20:37 <TheBrayn> > ord 'ε' -- TheBrayn
08:20:38 <lambdabot>   949
08:20:41 <TheBrayn> huh
08:20:54 <donri> @check \c -> ord c == fromEnum c
08:20:57 <lambdabot>   +++ OK, passed 100 tests.
08:21:16 <merijn> shiona_: No, but the community has mostly standardised on whitespace layout
08:21:30 <donri> @check \i -> chr i == toEnum i
08:21:31 <lambdabot>   *** Failed! Exception: 'Prelude.chr: bad argument: (-1)' (after 1 test):
08:21:31 <lambdabot>  -1
08:21:39 <shiona_> I personally prefer using both
08:21:40 <scott_> shiona_: It works without them, and with a $ in front of the second do (or wrap the whole thing in parentheses
08:21:41 <merijn> shiona_: Anyhoo, the problem is that a second do block can't be written like that
08:21:59 <merijn> shiona_: You either need to surround the entire do block in parenthesis or put a $ in front
08:22:07 <shiona_> merijn: ok, thanks
08:22:25 <merijn> shiona_: currently it's parsed as "((unless (s==i)) do) { .. }"
08:23:12 <donri> :t join bimap
08:23:13 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
08:23:25 <companion_cube> :t bimap
08:23:26 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
08:23:49 <merijn> oh
08:23:51 <shiona_> merijn: ah, of course. do is no special construct so it also obeys the order
08:23:58 <merijn> donri: <3
08:24:04 <donri> wha?
08:24:36 <merijn> donri: That type made me think, "hmm, could functions be bifunctors?" and thinking about that suddenly made me realise "oh! that's why they're profunctors!"
08:24:45 <donri> hehe
08:24:50 <donri> :t join dimap
08:24:51 <lambdabot> Profunctor p => (a -> b) -> p b a -> p a b
08:25:22 <donri> IIUC a -> b is a bifunctor, but not a Bifunctor
08:25:57 <donri> but that's because Profunctors are bifunctors, hm?
08:25:58 <Eduard_Munteanu> Yeah, it's just Hom(-, -), which is a profunctor.
08:26:09 <merijn> shiona_: Well, it's a special construct, but there's no exemption for it in the language parsing. One could argue for either solution, but this is the one we have :)
08:26:09 <triliyn> Profunctors are bifunctors but not Bifunctors in the same sense that Contravariants are functors but not Functors
08:26:31 <Eduard_Munteanu> They're not endo-bifunctors.
08:26:34 <merijn> I will just ignore this discussion and stick with my happy enlightenment before I feel dumb again
08:26:34 <shiona_> now there seems to be a problem with the recursive call
08:26:59 <merijn> shiona_: What is the return type of flatten supposed to be?
08:27:15 <merijn> shiona_: Without types I have no clue what this is supposed to be doing :p
08:27:39 <shiona_> a mutable array   that has the same types as indices and values
08:28:34 <shiona_> I'm mostly thinking about STArray Int Int, but I'm trying to keep it non-strict
08:28:57 <Eduard_Munteanu> shiona_: STArray is non-strict
08:29:08 <Eduard_Munteanu> STUArray isn't.
08:29:27 <shiona_> oI misused the term there. I meant I'm trying not to limit it to a single type
08:29:38 <Eduard_Munteanu> Ah.
08:29:44 <shiona_> I can't reember the correct term, sorry
08:29:52 <triliyn> Polymorphic
08:29:52 <Eduard_Munteanu> shiona_: polymorphic?
08:29:54 <shiona_> and the network connection in this train is horrible
08:30:15 <shiona_> Eduard_Munteanu: not the one I thought of but works wel
08:30:45 <shiona_> but I assume my problem, again, is the lack of understanding of mutability in haskell
08:30:53 <Eduard_Munteanu> shiona_: if you want a more mundane term, "generic" or "general" should do.
08:31:04 <shiona_> yeah
08:34:55 <deech> Is TH able to generate modules?
08:34:56 <mm_freak_> shiona_: the concept of mutability is simple in haskell:  it doesn't exist
08:35:29 <mm_freak_> shiona_: IO and ST actions are merely descriptions of the steps
08:35:59 <wferi> Hi! I'm doing mapM_ (op . prep), where prep is not total, and op undefined is not a no-op. I expected (op <=< evaluate . prep) to help, but it does not. what's the trick?
08:36:17 <shiona_> well, whatever euphemisms we wish to use, I have problems with the concept itself
08:36:18 <merijn> shiona_, mm_freak_: There was a really nice article on the reddit about that recently
08:36:23 <donri> deech: no
08:36:35 <wferi> "to help" = abort execution before doing op undefined.
08:36:59 <donri> deech: it can generate the contents of a module, though
08:37:15 <merijn> shiona_: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
08:37:42 <klrr_> Lemmih: are you the maintainer of sdl bindings?
08:38:04 <merijn> wferi: The best approach would be to make prep total (by wrapping in Maybe/Either) and then have op handle the failures (i.e. Nothing/Left) differently
08:38:54 <merijn> wferi: You could even just use "fmap op" to propagate the failure to the result list if you like. Alternatively if the entire computation should abort on failure, you might want to use exceptions
08:41:30 <wferi> merijn: yeah, I'm looking for a concise solution for this seemingly simple problem. what do you mean by using fmap op?
08:42:07 <merijn> wferi: Well, if prep returns Nothing on error, then "fmap op" will only deal with the Just cases (i.e. success) and do nothing for failures (i.e. Nothing)
08:42:08 <wferi> and care to hint at why evaluate did not work? I'm a little hazy about the strictness of the IO monad...
08:42:19 <wferi> I see
08:42:24 <quchen> IO isn't strict. Haze be gone!
08:42:30 <quchen> ;-)
08:42:49 <wferi> quchen: but I must have to the idea from somewhere...
08:42:55 <wferi> (got)
08:42:59 <merijn> wferi: Stuff like evaluate is horribly foul awful stuff
08:43:26 <taejo> I'm writing a little game in Haskell with a web frontend -- I need a pretty basic http server that can just handle stuff like "GET /game/123/state/" and "POST /game/123/move". I don't need any html or anything so I don't need a big framework
08:43:30 <merijn> wferi: Encoding failures using Maybe/Either is much cleaner/safe *and* easier to deal with
08:43:36 <wferi> okay. but my prep fails by calling error. isn't that an exception?
08:43:47 <merijn> taejo: I believe snap/happstack are pretty minimal
08:43:52 <tdammers> taejo: scotty might fit your bill
08:44:03 <tdammers> taejo: or just use the relevant modules from happstack or snap
08:44:04 <merijn> wferi: Why error instead of returning a Maybe?
08:44:09 <quchen> wferi: With IO it's mostly a question of *how* strict it is. Most of the time you can assume that an IO action that is bound (>>=) is performed at that time. There are exceptions to this rule though, like reading files.
08:44:38 <Luke> taejo: I'd definitely go with Snap for that
08:44:51 <quchen> wferi: And once you get into interleaved IO you're entering a world of pain. As a rule of thumb I'd say if your problem allows using pipes/conduit/iteratee, then you should probably do so.
08:45:07 <Luke> taejo: simple & straightforward routing
08:45:22 <wferi> merijn: you win, I'll introduce explicit error handling then.
08:46:11 <wferi> quchen: it's much simpler, really. op undefined is something, so the damage is already done when the problem arises
08:46:48 <wferi> and evaluate looked like the pretty thing just for this problem
08:47:09 <wferi> apparently, it isn't...
08:48:39 <deech> donri: So I could conceivably generate modules using strings and the contents using TH?
08:48:45 <TheBrayn> @hoogle (a -> Bool) -> [a] -> Bool
08:48:46 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
08:48:46 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
08:48:46 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
08:49:04 <donri> deech: not sure what you mean/want
08:49:24 <donri> deech: modules aren't first class. they're files.
08:49:50 <merijn> wferi: Make sure you handle all cases properly for non-total functions is a real pain and easy to miss something. Explicit error handling gives you much more certainty you've handled everything and Functor/Monad instances make dealing with them fairly painless. I mostly only use exceptions in things like server loops like "forever (handleClient `catch` connectionError)" so the loop is uninterrupted but has an easy way to exit. Exception as fine-grained flo
08:50:27 <deech> donri: I realize that. I was just brainstorming on ways I might generate modules at runtime. That's probably the wrong way to go.
08:50:52 <TheBrayn> any (\(a, b) -> a + b == 7)  [ (x, y) | x <- [1, 2, 3, 4, 5, 6, 7, 8], y <- [1, 2, 3, 4, 5, 6, 7, 8]] <- does this evaluate lazyly?
08:51:00 <tomejaguar> merijn: I think you got truncated, at least on my client.
08:51:17 <ciaranm> TheBrayn: it evaluates non-strictly
08:51:21 <TheBrayn> or will it first generate all possible combinations and then see if any of them meet the condition
08:51:22 <wferi> merijn: yes, after fine-grained
08:51:27 <donri> deech: you can't generate modules at runtime. also, TH runs at compile-time
08:51:33 <klugez> merijn: "Exception as fine-grained flo" is where it truncated.
08:51:49 <scott_> TheBrayn: No, it will only check combinations until it finds the first that meets the condition
08:52:03 <TheBrayn> ok nice
08:52:09 <TheBrayn> thanks
08:52:42 <klugez> One example of silent error handling. IRC servers truncate silently and the client of the sender usually just shows the whole thing, so you don't even realize it happened.
08:53:32 <RichyB> klugez, :)
08:53:39 <merijn> -> Exception as fine-grained flow control in Haskell is rather inconvenient (wich IMO is a good thing, but that's a separate topic)
08:54:08 <cschneid> implementing tic tac toe. Currently I have `type Board = [Cell]`.  Is there a better way to represent that so that I can't accidentally have too many or too few cells in a board?
08:54:16 <cschneid> I could `data Board = Board Cell Cell Cell ...
08:54:26 <cschneid> but that feels a bit hard to work with
08:55:18 <merijn> cschneid: Array?
08:55:33 <cschneid> merijn: well, more of an ability to type-system enforce the count of 9 cells in a board.
08:55:45 <cschneid> You're right array makes more sense than a list, due to random access needs
08:55:59 <merijn> cschneid: And the ability to properly do 2d indexing
08:56:05 <tomejaguar> cschneid: I would suggest not worrying about the data representation now, providing a generic interface to your representation, coding everything else you want, and coming back to the data representation later if you want.
08:56:28 <merijn> cschneid: If one of the matrix/linear algebra libraries has Vectors of three elements you could have a vector of vectors
08:56:52 <merijn> tomejaguar: I tend to disagree, I almost always design data representation first, code later
08:56:57 <cschneid> merijn: right. I'll look into array for sure
08:57:13 <cschneid> I just worry about lines like: `randomBoard = replicateM 9 makeRandomCell`
08:57:24 <cschneid> that 9 is a magic value that I'd prefer to not be able to screw up :)
08:57:41 <cschneid> (doing this as a practice of data modeling & actually using all the things I'm learning in haskell....)
08:57:51 <quicksilver> merijn's tendency is wrong more often than it's right though :)
08:58:08 <quicksilver> naturally values of "more often" vary by the anecdotes of the listener.
08:58:32 <quicksilver> but, there are many problems where data representation is a mere detail and it just needs to be adequate and the real work is in the algorithm.
08:58:35 <cschneid> quicksilver: in this case, my domain is very well defined (tic tac toe is well understood....). So I'd like to lock that down.
08:59:00 <quicksilver> those problems where the perfect data representation is the interesting part of the problem, or even the motivation for the work, exist. But it can be a real distraction.
08:59:34 <cschneid> quicksilver: ok, I'll not worry about it for the moment. I would like to loop back and do it. For now i'll just shift over to Array and implement the rest of the game.
08:59:37 <tomejaguar> merijn: But when you design the actual datatype first, is that to actually lock down the datatype, or just locking down the interface that you really need?
09:00:26 <tarruda> how can I make cabal output a shared library(--enable-shared) but still use static libraries(for ffi modules) when linking? The idea is to create a shared library composed of all ffi modules plus all their dependencies
09:01:07 <merijn> tomejaguar: The datatype is usually the interface
09:02:11 <cschneid> more general question. I have `type Board = [Cell]`. Would it make sense to make that a newtype instead? Does that get me anything?
09:02:26 <cschneid> type checking for sure, breaks the equality of [Cell] == Board
09:03:01 <merijn> cschneid: newtype gets you something if you don't export the constructor but only a smart constructor that sanity checks the board
09:03:32 <tomejaguar> cschneid: It really feels like this should be a newtype with constructor not exported.  Then you can make sure that all board operations preserve the shape of the board, for example.
09:03:47 <pqmodn> you can define your own instances for typeclasses. like, the Monoid instance for [a] probably doesn't make sense for Board, and newtype lets you avoid accidentally using it
09:04:07 <dcoutts> tarruda: I don't think it's clear what you're asking precisely.
09:04:16 <cschneid> merijn: interesting. `newtype Board = Board {getBoard :: [Cell]`, then not export that and instead have an `emptyBoard` function and `randomBoard` that I know do things right (count of cells and such)
09:04:28 <merijn> cschneid: Yeah
09:04:30 <whittle> I’m having XCode 5 issues. If I already have GCC v4.8 installed, is there any benefit to using that instead of the the ghc-clang-wrapper?
09:04:35 <tomejaguar> cschneid: Exactly
09:04:43 <pqmodn> cschneid: that's precisely how Array, Set, Map, etc work
09:04:49 <cschneid> merijn: sweet. let me play with that some. I do like the idea of not inheriting silly typeclasses
09:04:59 <tomejaguar> cschneid: And this is why I said don't worry about the datatype yet, since it's not going to be exposed anyway.  Just provide the necassary API.
09:05:07 <merijn> cschneid: Bonus, you can implement a pretty printing Show instance
09:05:21 <tarruda> dcoutts, its simple: I want cabal to build a shared library(.so file) that includes the code for all libraries used by the ffi modules(files in cbits)
09:05:25 <cschneid> merijn: ahh, much nicer. I have a `showBoard` function. But that should just be `show`
09:05:57 <tarruda> dcoutts: a self-contained shared library
09:06:02 <dcoutts> tarruda: you mean you have a number of c-sources and cabal builds those into the library (shared or static)
09:06:13 <dcoutts> tarruda: or are your C bits in a separate lib?
09:06:52 <eben> Does anyone know if this has a name "foldl (/) 1 [1..5]"? Like how with multiplication it's the product.
09:07:24 <tarruda> dcoutts: I have a single c file in the cbits directory, a third party library(headers + static library). The c file uses the third party library. I want cabal to build a .so file that contains all
09:07:25 <scott_> Isn't that just the inverse of the product? 1 / product [1..5]
09:07:38 <tomejaguar> eben: Well it's just 1 / the product, so probably confusing to implement it like that in the first place.
09:07:55 <dcoutts> tarruda: ok, the C file that cabal builds is fine, that will be included into the static or shared lib.
09:07:56 <eben> Haha, ok, just wondered. Thanks
09:08:17 <dcoutts> tarruda: the separate lib is still separate. Cabal will not do anything special with that.
09:08:56 <tarruda> dcoutts: yes, currently cabal outputs a few .o files which I assume to be the compiled C files from by cbits directory
09:09:20 <sx> Is it bad style if I'm using type classes to "simulate" overloading of functions? Does this cost more? Or is this resolved at compile time?
09:09:55 <merijn> sx: It's generally bad style, yes. Most situations like this can be better solved using polymorphism
09:10:25 <tarruda> dcoutts: I want it to create a single .so file that I can load into ghci(for example) without worrying about the third party library my C file depends
09:10:34 <tomejaguar> sx: Probably depends on the exact type of overloading.  Share some code?  I tend to write Haskell as though typeclasses didn't exist, and then only at the end go back and neaten things up with a typeclass if necessary.
09:11:50 <dcoutts> tarruda: there's no special support for that. The well supported options are 1. using the C lib as an external lib, where the .a and .so are pre-existing; 2. using C files as part of the package (which will be linked into the lib).
09:12:43 <sx> merijn: What do you mean by polymorphism? The problem is I have a recursive data structure. I can't pack them together, since they are not of the same type, and a wrapper data type would not make sense.
09:13:11 <merijn> sx: Hard to say without seeing the exact code you're referring to. Do you have a minimal sample of what you want to do?
09:14:15 <tarruda> dcoutts: do you know an example cabal shared library project that uses ffi to talk to an external C library?
09:14:46 <dcoutts> tarruda: there are many that bind external libs that are expected to be on the system already
09:14:58 <sx> merijn: I have an abstract representation of SQL, where I want to replace fake table references with actual sub queries (and such). The structure uses different kinds of abstract datatypes to model the SQL parts.
09:15:10 <dcoutts> tarruda: there are a few that bundle the C lib with the Haskell package (e.g. because getting the C lib on Windows is a pain)
09:15:50 <TheBrayn> http://lpaste.net/95864 why am I getting this error message?
09:15:59 <tarruda> dcoutts: do you have an example that bundles the C lib?
09:16:27 <dcoutts> tarruda: my zlib package does that on windows, and uses the system one on non-windows
09:16:27 <dcoutts> http://hackage.haskell.org/package/zlib
09:16:46 <tarruda> dcoutts: thanks
09:17:15 <dcoutts> tarruda: but note that that works because zlib is so simple that it can be built by Cabal, not using an external ./configure + makefile
09:18:06 <whittle> TheBrayn: It looks like the line numbers in the errors don’t match the line numbers for the code.
09:18:16 <whittle> Did you paste the whole file?
09:18:19 <TheBrayn> oh, second
09:19:04 <TheBrayn> ok, I'll have to do this later
09:19:06 <TheBrayn> bye
09:20:55 <quchen> What's that quote again about the "certain type of visitor"?
09:21:09 <quchen> "Explain Monads to me" "/me runs around" "foo quit (Quit)"
09:21:14 <quchen> Something along those lines
09:21:20 <shapr> truly
09:21:34 <shapr> quchen: I think syntaxninja first described that kind of visitor.
09:21:59 <apo> quchen: Explain nomads to me!
09:22:00 <quchen> You have remarkable memory.
09:22:12 <quchen> shapr: Could you also have remarkable linking skillz? :-P
09:22:32 <shapr> Eh, it was probably seven years ago, no links for you :-P
09:22:57 <apo> file://C:\home\shapr\irclogs\...
09:23:26 <quchen> apo: Well there are logs since the beginning of #haskell. It's just a matter of searching them.
09:23:49 <apo> :)
09:24:49 <mauke> apo: http://tanasinn.info/wiki/Kopipe:Computers#The_Jungle_Book
09:24:55 <quchen> Ah, found it.
09:28:12 <eben> Is there a good pratical arrows tutorial anywhere?
09:29:09 <merijn> eben: The wikibook was decent
09:29:30 <merijn> eben: Also, the arrow papers (Generalising Monads to Arrows and the other I forget) are very readable
09:29:50 <merijn> eben: Or rather, the first half is readable, the second half gets complicated, but the first half should be sufficient
09:29:51 <tomejaguar> eben: This is very helpful, though not really a tutorial: http://www.mail-archive.com/haskell-cafe@haskell.org/msg106536.html
09:30:17 <eben> Cheers (:
09:35:21 <it3ration> morning all
09:36:39 <emaphis> hi, it3ration
09:47:15 <m1dnight> is the code for the expression evaluator open source?
09:48:02 * hackagebot git-repair 1.20131118 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20131118 (JoeyHess)
09:48:31 <lvella> a fellow from this channel suggested me, as an exercise, to to try to implement the type Reader as a Functor and then as a Monad
09:48:40 <merijn> m1dnight: Lambdabot's you mean?
09:48:45 <m1dnight> yes :)
09:48:48 <merijn> m1dnight: It uses mueval, should be on hackage
09:48:53 <m1dnight> oh, cool :D
09:49:03 <m1dnight> i might try to get it up and running on a channel i'm in then
09:49:04 <m1dnight> thanks
09:49:17 <lvella> he gave me the definition:
09:49:18 <lvella> newtype Reader e a = Reader (e -> a)
09:49:18 <lvella> (if I am not mistaken)
09:49:30 <Eduard_Munteanu> lvella: that looks fine
09:49:32 <merijn> m1dnight: You can request lambdabot to join your channel, I forget who admins her, though
09:50:08 <Feuerbach> Is anyone here closely familiar with sodium? I'm trying to understand what's the Context abstraction is for
09:50:16 <quchen> I think Elliott is responsible for Lambdabot
09:51:01 <merijn> lvella: Presumably it was something like "newtype Reader e a = Reader { runReader :: e -> a }", that way you have an "unwrapper" for the newtype too
09:51:05 <klugez> I think it's now some else.
09:51:10 <klugez> Can't remember who.
09:51:28 <klugez> int-e perhaps?
09:51:40 <merijn> There's multiple people with access to the main lambdabot, I believe
09:51:53 <merijn> lvella: But either way works
09:52:46 <levi> I'm not sure if the currently-connected lambdabot is the main one or the one chrisdone set up last night after the normal one had been disconnected for a while.
09:53:08 <mauke> > def
09:53:09 <lambdabot>   ()
09:53:14 <mauke> nice
09:53:25 <mauke> > def `def` def
09:53:26 <lambdabot>   Could not deduce (Data.Default.Class.Default a0)
09:53:26 <lambdabot>    arising from a use of `...
09:54:41 <lvella> but I fail even the simple task to write the line saying to instance the thing as a Functor:
09:54:41 <lvella> instance Functor (Reader e a) where
09:55:11 <lvella> this line gives me this error on hugs: ERROR "test.hs":3 - Illegal type in class constraint
09:55:19 <merijn_> lvella: It should be "instance Functor (Reader e) where"
09:55:31 <merijn_> lvella: Functor's take one argument type
09:56:07 <lvella> I have tried many other combinations
09:56:14 <lvella> all wrong
09:56:22 <merijn_> lvella: It should be "instance Functor (Reader e) where", Functors take one type as argument
09:56:51 <skypers> I just found back a screenshot I took 7 years ago (I might be 12 or 13 years old): http://dimitri.sabadie.free.fr/Images/screen.JPG . I hadn’t known loops yet at this time :D
09:56:53 <m1dnight> ill come back later when there is an admin here :)
09:56:57 <m1dnight> I can't go around pm'ing everybody xD
09:57:03 <skypers> kinda funny to see that pop again :)
09:57:07 <lvella> merijn_: same error
09:57:14 <lvella> I have tried this too
09:57:50 <merijn_> lvella: "fmap :: Functor f => (a -> b) -> f a -> f b" <- f takes one argument here. You can imagine the "f"being replaced by the argument to Functor i.e. it becomes "fmap :: (a  -> b) -> Reader e a -> Reader e b
09:57:57 <quchen> skypers: French identifiers ಠ_ಠ
09:57:59 <merijn_> lvella: lpaste the file you're using?
09:58:08 <skypers> quchen: yeah I’m french ;)
09:58:26 <quchen> #define NULLE NULL
09:58:38 <skypers> nope
09:58:42 <skypers> pointer is male ;)
09:58:48 <skypers> it would be NUL
09:59:05 <lvella> http://lpaste.net/95867
09:59:42 <merijn_> lvella: And the error?
09:59:54 <chrisdone> levi: it's now int-e's again
09:59:58 <chrisdone> > 1
09:59:59 <lambdabot>   1
10:00:16 <mauke> > 1 2
10:00:16 <tomejaguar> lvella: There's nothing wrong with the types, but there is something wrong with your definition of fmap.
10:00:17 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
10:00:17 <lambdabot>    arising f...
10:00:18 <alexander__b> is there a function that when given (a, b) returns a b?
10:00:24 <ion> snd
10:00:31 <ion> Sorry, let me fix my answer:
10:00:32 <tomejaguar> alexander__b: uncurry ($)?
10:00:38 <ion> @hoogle (a,b) -> b
10:00:40 <lambdabot> Prelude snd :: (a, b) -> b
10:00:40 <lambdabot> Data.Tuple snd :: (a, b) -> b
10:00:40 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
10:00:42 <alexander__b> tomejaguar: ah of course you can just do that
10:01:00 <mauke> @pl \(a, b) -> a b
10:01:01 <lambdabot> ap fst snd
10:01:12 <ion> Oh, “a b”, not a “b”.
10:01:16 <chrisdone> ap fst snd is nice
10:01:16 <mauke> :t fst <*> snd
10:01:17 <lambdabot> (b1 -> b, b1) -> b
10:01:21 <alexander__b> ion: yes, sorry for the confusion
10:01:26 <tomejaguar> ap fst snd is funny.
10:01:33 <mauke> :t uncurry id
10:01:33 <lambdabot> (b -> c, b) -> c
10:01:50 <mauke> :t uncurry asks
10:01:51 <lambdabot> (b -> a, b) -> a
10:02:17 <mauke> :t uncurry (fix <$> return)
10:02:18 <lambdabot> (b -> c, b) -> c
10:02:20 <chrisdone> :t ap _1 _2
10:02:21 <lambdabot> (Functor f, Field2 s t1 a b, Field1 (s -> f t1) t a b, Indexable Int p) => p a (f b) -> f t
10:03:17 <tomejaguar> :t ap (view _1) (view _2)
10:03:18 <lambdabot> (MonadReader s m, Field2 s s b1 b1, Field1 s s (b1 -> b) (b1 -> b)) => m b
10:03:22 <lvella> I am installing ghc on this machine to have more detailed error
10:03:42 <levi> What are you using now if not ghc?
10:03:57 <mauke> g++
10:04:42 <lvella> test.hs:3:19:
10:04:42 <lvella>     Kind mis-match
10:04:42 <lvella>     The first argument of `Functor' should have kind `* -> *',
10:04:42 <lvella>     but `Reader e a' has kind `*'
10:04:44 <lvella>     In the instance declaration for `Functor (Reader e a)'
10:04:46 <lvella> Failed, modules loaded: none.
10:04:48 <lvella> sorry
10:04:56 <lvella> muline post...
10:05:09 <simpson> lvella: instance Functor (Reader e) where ...
10:05:41 <int-e> levi: the currently running lambdabot is mine
10:06:15 <tomejaguar> lvella: You don't have 'Functor (Reader e a)' in the code you posted!
10:06:20 <chrisdone> @choose int-e cale elliott chrisdone
10:06:21 <lambdabot> cale
10:06:24 <chrisdone> aw
10:06:51 <lvella> no, I have changed it because merijn_ told so
10:07:15 <tomejaguar> Sure, and merijn_'s version is correct.
10:07:34 <tomejaguar> You get a different error when you compile that, though, because your implementation of fmap is not correct.
10:08:02 <lvella> so, I need to fix my fmap implementation...
10:08:05 <tomejaguar> Yes
10:08:25 <tomejaguar> The compiler should give you a helpful error though
10:08:43 <lvella> the helpful error is the one I posted here
10:08:51 <alexander__b> I ended up with simply uncurry f $ g x. g x returns (a, b).
10:08:53 <chrisdone> just define fmap = fmap -- nobody will be able to tell whether it works or just isn't finished yet
10:09:22 <tomejaguar> lvella: Try it with 'instance Functor (Reader e)'.  It will give you an error about fmap.
10:09:29 <lvella> what is kind??
10:09:43 <lvella> why the compiler says kind instead of type?
10:09:55 <chrisdone> values have types, types have kinds
10:10:06 <chrisdone> :k Maybe
10:10:07 <lambdabot> * -> *
10:10:09 <absence> how can i rewrite this signature to use MonadState? MonadIO m => StateT (Producer ByteString m ()) m ()
10:10:11 <chrisdone> :k Maybe ()
10:10:12 <lambdabot> *
10:10:21 <_justjust> :k Reader
10:10:21 <lambdabot>     Type synonym `Reader' should have 1 argument, but has been given none
10:10:22 <lambdabot>     In a type in a GHCi command: Reader
10:10:34 <chrisdone> @8ball _justjust
10:10:34 <lambdabot> Unknown command, try @list
10:10:44 <triliyn> :k ReaderT Identity
10:10:45 <lambdabot>     Expecting one more argument to `Identity'
10:10:46 <lambdabot>     In a type in a GHCi command: ReaderT Identity
10:10:52 <chrisdone> @slap everyone
10:10:52 * lambdabot hits everyone with a hammer, so they breaks into a thousand pieces
10:10:54 <lvella> I am trying with the file http://lpaste.net/95867
10:10:58 <cschneid> if I have an Array, can I easily slice off sub-arrays? "give me from 0 to 3" for instance
10:11:14 <lvella> I have this error with 'instance Functor (Reader e)'
10:11:19 <chrisdone> duno. vector can do that
10:11:39 <cschneid> what's the diff between Vector and Array?
10:11:43 <tomejaguar> lvella: Can you paste the error into the lpaste too?
10:12:01 <Eduard_Munteanu> absence: (MonadIO m, MonadState (Producer ByteString m ()) m) => m ()
10:12:03 <quchen> cschneid: Vector has an API, Array has an AntiPI
10:12:27 <quchen> cschneid: On the serious side: Arrays are like vectors but use the Ix class for indexing.
10:12:40 <chrisdone> vector indexes are dynamically resizable and use Ints for the index
10:12:43 <quchen> But you could just as well use Ix with Vector.
10:12:53 <klugez> cschneid: Vector is more modern otherwise, but Arrays have multidimensinal indexing.
10:13:04 <lvella> there now: http://lpaste.net/95867
10:13:07 <chrisdone> s/resizable/sizeable
10:13:19 <cschneid> I need a fixed-length of 9 "array" - random access, and subarrays
10:13:25 <lvella> what kind (* -> *) means?
10:13:40 <chrisdone> it means you have a type function
10:13:42 <Eduard_Munteanu> lvella: things like [], Maybe...
10:13:46 <cschneid> chrisdone: vector seems viable for that?
10:13:59 <scott_> lvella: You aren't compiling what you think you are compiling. The error mentions Functor (Reader e a) which isn't in the code
10:14:00 <klugez> lvella: You have some problem loading, because the error message does not refer to that file.
10:14:03 <Eduard_Munteanu> Maybe :: * -> *   Maybe Bool :: *
10:14:13 <quchen> cschneid: http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector.html#v:slice
10:14:20 <quchen> That's the vector version of what you're looking for.
10:14:31 <chrisdone> vector is win
10:14:34 <cschneid> quchen: works for me
10:15:00 <quchen> There's also unsafeSlice.
10:15:01 <lvella> sorry, fixed
10:15:17 <cschneid> quchen: thanks, I'll just use vector.
10:15:20 <tomejaguar> lvella: Exactly.  That's not a complaint about 'Functor (Reader e)'.  That part is correct.  It's a complaint about your implementation of fmap.
10:15:26 <cschneid> they both have similar performance characteristics?
10:15:45 <quchen> I think Vector is significantly faster.
10:15:52 <quchen> (Lots of fusion laws.)
10:16:14 <quchen> The only drawback of Vector is really just that it doesn't have multi-dimensional indexing out of the box.
10:16:15 <cschneid> sure, more of bigO style speed. random access is good, etc.
10:16:25 <chrisdone> in the small test i did vector was faster
10:16:32 <cschneid> sure. I figure I'd use hmatrix or repa or friends for that
10:17:02 <quchen> You can do many things by manually combining Ix+Vector. But your example of slicing won't work with 2D Vectors for example.
10:17:04 <tomejaguar> Maybe carter will be along soon to save the day with his new matrix implementation.
10:17:22 <quchen> Or it won't slice "square subsets" out of a 2D vector at least.
10:17:32 <chrisdone> Sami Hangaslammi waterflow solution went from 33.80864 us → 26.79492 us by changing the type from Array to Vector
10:17:50 <quchen> That's almost 100% speedup! Give or take.
10:18:04 <cschneid> cool.
10:18:06 <dv-> vectors are 1D aren't they?
10:18:09 <quchen> Yes.
10:18:14 <quchen> Vectors are Int-indexed.
10:18:15 <chrisdone> oui
10:18:35 <quchen> Well, that doesn't really make them 1D.
10:18:55 <quchen> Arrays are as n-dimensional as Vectors. What really matters is how you generate (access) the Int index.
10:19:27 <dv-> array update (//) is so convenient though
10:19:33 <absence> Eduard_Munteanu: thank you. i thought that was the right way, but it doesn't seem to work for more complicated types, so i guess there's something else i'm missing: http://lpaste.net/95870
10:20:11 <quchen> ixLookup ix vector = vector ! index (0, length vector - 1) ix  ← Tadaa, n-dimensional vector
10:20:11 <chrisdone> int-e: are you using the github version of lambdabot?
10:20:17 <klrr_> anyone know what Set is for? to me it seems like a combination of lists and maps
10:20:32 <quchen> klrr_: Right, Set a = Map a ()
10:20:35 <absence> Eduard_Munteanu: (never mind the confusion about B.ByteString vs Pb.ByteString)
10:20:38 <monochrom> absence, it is probably impossible, because of how "Producer blahblah m" mentions m.
10:20:51 <klrr_> so, is there any usecase over a list?
10:20:54 <quchen> klrr_: Set is much more similar to Map than to List
10:21:24 <quchen> klrr_: Sure, Sets are trees internally. That gives you logarithmic complexity for many applications (lookup, update etc.)
10:21:34 <tomejaguar> The implementation is similar to Map but the purpose of the datastructure is somewhat similar to list.
10:21:55 <chrisdone> there's no point comparing them, i suppose
10:22:04 <absence> monochrom: but it works for this case: (MonadIO m, MonadReader Handle m, MonadState (Producer Pb.ByteString m ()) m) => m ()
10:22:07 <klrr_> quchen: not really sure about the termology, but do you mean that Sets are lists which allows more "map-like" functions on them, like looking up and inserting etc.?
10:22:26 <monochrom> ok, fsvo "work"
10:22:33 <Eduard_Munteanu> absence: aside from what monochrom says, you can't really unify StateT with arbitrary MonadState
10:22:53 <tomejaguar> klrr_: A set is an unordered collection of values, at most one of each.  Does that help?
10:22:56 <chrisdone> klrr_: just thing of the data structure as-is rather than comparing to something else. it's an unordered container that you can put instances of Ord in and get decent membership testing, insertion and deletion
10:23:02 <quchen> klrr_: Sets are like lists where the elements are in order, and there are efficient lookup/insertion/update functions available for it.
10:23:05 * hackagebot haskell-pdf-presenter 0.2.4 - Tool for presenting PDF-based presentations.  http://hackage.haskell.org/package/haskell-pdf-presenter-0.2.4 (MichaelAdams)
10:23:21 <Eduard_Munteanu> absence: the point of MonadState is to abstract StateT and be more general
10:23:34 <absence> Eduard_Munteanu: because m is used in the state type?
10:23:36 <klrr_> okey, i think i get it now, thanks!
10:23:37 <chrisdone> sets have unique elements
10:24:01 <Eduard_Munteanu> absence: no... you seem to be trying to use it as if it was a StateT.
10:24:15 <alexander__b> who was the haskellmode author again?
10:24:18 <chrisdone> also, when you use a set you're saying "i have a unique collection of unordered values", which is nice documentation and api to prevent mistakes
10:24:27 <alexander__b> chrisdone: you, maybe?
10:24:29 <Eduard_Munteanu> absence: "Could not deduce (m ~ StateT (Proxy Void () () Pb.ByteString m0 ()) m0)"
10:24:31 <chrisdone> alexander__b: there isn't a single author. me and hvr contribute
10:24:46 <chrisdone> but we contribute on what we're interested in =)
10:24:47 <alexander__b> chrisdone: hvr: any idea on how to fold multi line comments (all comments)
10:24:51 <Eduard_Munteanu> absence: somewhere in there you're doing runStateT or something like that
10:24:52 <alexander__b> s/multi/single
10:24:59 <chrisdone> “fold”?
10:25:16 <alexander__b> :h fold
10:25:17 <Eduard_Munteanu> absence: or combining it with f1
10:25:46 <absence> Eduard_Munteanu: ohhh, i suddenly understand what that error really means :P you're right
10:26:20 <absence> Eduard_Munteanu: i am explicityly "forcing" StateT in that function
10:26:29 <chrisdone> eduard's always right, that's why he carries the Stick of Pride
10:26:39 <absence> :)
10:28:45 <klugez> dv-: Vectors have (//) as well.
10:32:31 <absence> if a library uses StateT rather than MonadState, is it likely in order to be haskell 98 compatible?
10:33:36 <benzrf> whats today's date
10:33:51 <chrisdone> Mon Nov 18 19:17:39 CET 2013
10:33:52 <chrisdone>  
10:34:19 <Eduard_Munteanu> absence: not necessarily, MonadState is only widespread as of mtl2 I think.
10:34:22 <chrisdone> add/subtract hours according to your time zone
10:34:22 <benzrf> derp
10:35:26 <benzrf> crud
10:35:37 <chrisdone> benzrf: are you ok?
10:35:40 <benzrf> this comp doesnt have the haskell platform and i just started a massive apt-get upgrade
10:35:43 <benzrf> -.-
10:35:59 <benzrf> freakin typical
10:36:06 <chrisdone> fpcomplete to the rescue!
10:36:11 <benzrf> perhaps
10:38:06 <benzrf> given a haskell expression as a string, is there a guaranteed safe trivial string transformation i can perform upon it in order to get an executable program that prints the results of the expr
10:39:06 <simpson> benzrf: No; you'd need a Show constraint on the return type of the expression.
10:39:39 <chrisdone> :t System.Process.readProcess "runhaskell" [] . ("main = "++)
10:39:40 <lambdabot> [Char] -> IO String
10:39:55 <benzrf> simpson: hmm
10:40:23 <benzrf> simpson: ok, what if im ok with either getting a result or erroring
10:40:35 <chrisdone> Prelude System.Process> System.Process.readProcess "runhaskell" [] . (\x -> "main = print ("++ x ++ ")") $ "2*4"
10:40:35 <chrisdone> "8\n"
10:40:36 <simpson> benzrf: Can the error be a compile error?
10:40:39 <benzrf> i guess
10:40:49 <benzrf> to be precise, i'm interfacing my irc bot with ideone
10:40:50 <simpson> Then chrisdone's solution looks pretty solid.
10:40:53 <benzrf> ok
10:41:02 <chrisdone> see also http://hackage.haskell.org/package/hint
10:41:06 <benzrf> thanks
10:41:40 <chrisdone> https://www.fpcomplete.com/user/chrisdonefp/try-haskell
10:41:49 <chrisdone> hit 'View Markdown Source'
10:42:22 <chrisdone> (my readProcess was kind of a joke, hint is the proper way)
10:43:53 <tomejaguar> Is it possible to get TemplateHaskell to import stuff?
10:44:39 <chrisdone> dunno, i'd like that but it may be part of the stage restriction
10:45:04 <tomejaguar> I want my splice to say "use this name, but you've got to import it from here"
10:45:37 <tomejaguar> Otherwise when someone uses the splice they're going to get "identifier not found" errors and have to specify the import themselves
10:47:18 <Eduard_Munteanu> @pl \f x -> f <*> x <|> x
10:47:18 <lambdabot> join . ((<|>) .) . (<*>)
10:48:11 <Eduard_Munteanu> @pl \f x -> x <**> (pure id <|> pure f)
10:48:11 <lambdabot> flip (<**>) . (pure id <|>) . pure
10:48:18 <Eduard_Munteanu> Gr.
10:48:37 <augur> Eduard_Munteanu: what are you trying to do
10:49:15 <Eduard_Munteanu> augur: parsing!
10:49:22 <augur> Eduard_Munteanu: parsing what
10:49:37 <chrisdone> the muffin man!
10:49:42 <Eduard_Munteanu> augur: expressions, with attoparsec
10:51:39 <Eduard_Munteanu> augur: btw, since you're a linguist... what's this parser? http://lpaste.net/95872
10:51:59 <augur> Eduard_Munteanu: lol
10:52:23 <augur> Eduard_Munteanu: who knows. linguists dont do that. :D
10:52:27 <Eduard_Munteanu> augur: it is recursive, but I'm not sure given sepBy. It doesn't need to backtrack.
10:52:36 <Eduard_Munteanu> Oh, no?
10:52:56 <Eduard_Munteanu> augur: don't you do grammars and stuff?
10:53:16 <augur> Eduard_Munteanu: we dont do parsing libraries
10:54:15 <FreeFull> Eduard_Munteanu: It parses things like   meow || moo || hello && so || (!a || b == c) || ( d != e )
10:54:43 <augur> edwardk! how can i do a structural analysis of a formal language :(
10:55:27 <ion> Hawking, you’re a theoretical physicist. What’s this parser?
10:57:08 <edwardk> augur: writing code helps =)
10:57:38 <edwardk> abesto: i live =)
10:57:55 <edwardk> abesto: I've made it down to italy. the other talks have gone very well, but no slides yet. =)
10:58:56 * monochrom is more interested in what kind of answer is expected, since the parser code makes the intended grammar pretty clear
11:03:18 <Eduard_Munteanu> monochrom, FreeFull: I'm interested what sort of parser it is... it's certainly not a simple recursive descent
11:03:46 <Eduard_Munteanu> It looks a bit bottom-up or breadth-first.
11:05:34 <Eduard_Munteanu> It seems more efficient because I do all binary ops of a given kind in one go, except nested expressions (in parens).
11:07:41 <monochrom> it looks obviously enough recursive descent to me, but I am not in a mood of arguing.
11:09:34 <Eduard_Munteanu> monochrom: what if I had only "&&" and "||"? Would that still be recursive descent?
11:09:46 <Eduard_Munteanu> Well, those ops and names.
11:10:38 <monochrom> I don't trust that narrative. show actual code.
11:11:09 <zebr> hi all. is the type (x + 1) theoretically (as in, type theory) about the same as (Maybe x)?
11:11:24 <monochrom> yes
11:11:39 <monochrom> the 1 serves as Nothing
11:11:47 <zebr> monochrom: great, thanks.
11:11:58 <scott_> That's like Either x () vs. Maybe x
11:12:05 <scott_> Nothing is like Right ()
11:12:11 <zebr> yeah
11:12:14 <zebr> that makes sense
11:13:41 <Eduard_Munteanu> monochrom: foldr1 Or <$> (foldr1 And <$> name `sepBy1` op "&&") `sepBy1` op "||"
11:14:42 <monochrom> then it is still recursive descent, although it contains little recursion
11:15:54 <Eduard_Munteanu> monochrom: I see... but is this method different from lookahead/backtracking, does it have a name? I've seen something called "precedence climbing" but I'm unsure if it's the same thing.
11:16:25 <Eduard_Munteanu> http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing
11:19:28 <monochrom> you're still doing the classic solution
11:20:37 <augur> edwardk: it does!
11:21:30 <augur> edwardk: im just sort of grasping at anything i can to figure out how to detect structure inside of sentences of a string language, or at least some knowledge about the relationships between the words of the sentence
11:21:31 <Eduard_Munteanu> monochrom: thanks... I think I'll leave it that way, AFAICT it's rather fast anyway.
11:21:55 <augur> and its really hard, because every apparently good idea has some simple counterexamples in either the dyck language or english
11:22:57 <edwardk> augur: just collect all the formalisms, and apply whichever ones you can make fit =P
11:23:51 <monochrom> there are infinitely many formalisms. for each one, the fitness test takes infinite time.
11:24:19 <edwardk> monochrom: sure, but i figure that'll keep him busy while i go off and do other things. think of it as an academic denial of service attack
11:25:57 <identity> wasn't there a new pragma for defining what was a minimum necessary instance declaration?
11:26:32 <monochrom> there will be. not there was.
11:27:18 <cschneid> Can somebody quickly code review?  This is a tic tac toe board, and the `Show` instance to pretty print it. https://gist.github.com/913934706a19656fd3b9
11:27:38 <identity> monochrom: oh :(
11:29:35 <monochrom> some parentheses are redundant. but I'm not anal on that.
11:30:43 <cschneid> monochrom: for my code?
11:30:46 <cschneid> hlint didn't complain :)
11:31:01 <monochrom> "show (X) = ..." can be "show X = ..."
11:31:10 <Vaniax> Hi. Maybe someone here can help me with the cabal utility. Since days I get only this error http://pastebin.com/rHx9t95U when trying to update on my Windows 7 machine and I cant figure out what is going wrong.
11:31:15 <mauke> The paste rHx9t95U has been copied to http://lpaste.net/95873
11:31:29 <monochrom> I don't worry about hlint
11:32:29 <monochrom> I can't find "slice"
11:33:22 <ReinH> cschneid: wondering why not use [[Cell]] instead of Vector Cell
11:33:28 <monochrom> I see, it's from Data.Vector
11:33:29 <FreeFull> cschneid: Where are you getting replicate and replicateM from?
11:33:58 <monochrom> probably Data.Vector too hehe
11:34:05 <ReinH> I seriously doubt that list performance will be an issue when n is 9
11:34:05 <zennist> how can I build an infinite list containing the same element?
11:34:15 <FreeFull> > cycle 3
11:34:17 <lambdabot>   No instance for (GHC.Show.Show a0)
11:34:17 <lambdabot>    arising from a use of `M5831414440583...
11:34:19 <identity> :t repeat
11:34:20 <lambdabot> a -> [a]
11:34:26 <FreeFull> > repeat 3
11:34:27 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
11:34:28 <identity> > take 10 $ repeat 3
11:34:28 <monochrom> anyway, I'm ok with this code
11:34:29 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
11:35:13 <FreeFull> If you were doing it yourself, you could do it using let
11:35:21 <FreeFull> > let list = 3 : list
11:35:22 <lambdabot>   not an expression: `let list = 3 : list'
11:35:25 <FreeFull> > let list = 3 : list in list
11:35:26 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
11:35:36 <FreeFull> But might as well use repeat
11:35:56 <ReinH> show for [[Cell]] would be intercalate "art = map show . toList $ slice start 3 cells horizRow = "---------\n" . map (intercalate " | ") . map (map show)
11:36:00 <ReinH> uh wtf sorry
11:36:16 <ReinH>  intercalate "---------\n" . map (intercalate " | ") . map (map show)
11:36:20 <fl00r> does anyone know offhand any projects that use the approach edwardk mentioned in the reddit post "Criticism of haskell"? (It recommends gluing states and environments together with classy lenses and writer outputs with prisms.)
11:36:29 <ReinH> which seems a bit cleaner
11:36:43 <ReinH> you could also do it for Vector by adding chunksOf 3 . toList
11:36:56 <Hodapp> classy lenses? sounds hipster-ish.
11:37:06 <cschneid> ReinH: no good reason for Vector over [[Cell]], other than I hadn't ever used vector :)
11:37:15 <ReinH> cschneid: ok :)
11:37:18 <cschneid> random access is helpful, although meaningless on this tiny of a grid
11:37:53 <ReinH> cschneid: so I'd probably write show as: intercalate "---------\n" . map (intercalate " | ") . chunksOf 3 . toList . fmap show
11:37:54 <FreeFull> You could even have Board simply have nine arguments, but that would be a pain since liftM9 doesn't exist
11:37:59 <ReinH> using chunksOf from Data.List.Split
11:38:35 <ReinH> oh throw an unlines on there
11:38:55 <ReinH> and change the first map to concatMap
11:39:04 <ReinH> maybe I should actually write it and get it to typecheck :p
11:39:16 <FreeFull> Maybe you should even run it
11:39:25 <ReinH> nah if it typechecks it's good
11:39:27 <ReinH> :p
11:39:37 <FreeFull> Strings don't get typechecked =P
11:39:46 <ReinH> close enough
11:40:11 <FreeFull> Unless you use a dependently typed language
11:40:45 <cschneid> ReinH: :)
11:40:51 <cschneid> thanks, I'll play with that approach
11:42:31 <ReinH> oh wait intercalate does the joining doesn't it
11:42:34 <ReinH> it's intersperse that doesn't?
11:42:53 <ReinH> yeah it's concat intersperse
11:42:53 <cschneid> ahh, that's right
11:43:12 * hackagebot data-lens-fd 2.0.4 - Lenses  http://hackage.haskell.org/package/data-lens-fd-2.0.4 (RussellOConnor)
11:43:18 <ReinH> so you want unlines . intersperse "---------" . map (intercalate " | ")
11:44:03 <benzrf> :t intercalate
11:44:05 <lambdabot> [a] -> [[a]] -> [a]
11:44:12 <benzrf> hmm?
11:44:33 <eacameron> I still can't figure out why people use ''X vs 'X in TH. Is ''X for types and 'x for identifiers?
11:44:36 <benzrf> > intercalate [1, 2, 3] [[1], [2], [3]]
11:44:37 <lambdabot>   [1,1,2,3,2,1,2,3,3]
11:44:39 <benzrf> aha
11:44:46 <ReinH> benzrf: intercalate xs xss = concat (intersperse xs xss)
11:44:50 <benzrf> yeah
11:45:10 <ReinH> so intercalate xs = concat . intersperse xs
11:45:12 <benzrf> so when used where a is String, it's like .join in ruby
11:45:16 <benzrf> or str.join in py
11:45:19 <ReinH> benzrf: right
11:45:41 <benzrf> alright, so
11:46:30 <bobcrasher> Anyone here using haskell-mode for vim?  Whenever I try to run "make" on a file, the make finishes and then vim locks up going to 100% cpu
11:46:37 <benzrf> > unlines $ intersperse "-----------" $ map (intercalate " | ") $ [["foo", "bar"], ["foobar", "foobaz"]]
11:46:38 <lambdabot>   "foo | bar\n-----------\nfoobar | foobaz\n"
11:46:42 <benzrf> got it
11:46:50 <ReinH> right
11:47:45 <bobcrasher> On the other hand, if my .hs file has an error in it, the compile will fail, show the error message, and return me back to vim no problem
11:48:21 <ReinH> bobcrasher: what does :set makeprg say?
11:49:11 <bobcrasher> makeprg=/usr/bin/ghc -e :q %
11:49:26 <bobcrasher> ReinH: makeprg=/usr/bin/ghc -e :q %, sorry forgot to tag
11:49:51 <ReinH> bobcrasher:hmm
11:52:31 <bobcrasher> ReinH:  And the command itself works fine, does the build.  It's vim locking up once the build completes (and only if the completion was a successful one)
11:53:02 <ReinH> bobcrasher: I've never seen that. Maybe ask in #vim?
11:53:24 <bobcrasher> ReinH:  Trying that now, thank you
11:53:28 <ReinH> it might be an issue with the way vim is trying to parse the make output via 'errorformat'
11:55:02 <bobcrasher> Hmm I'll start there
11:55:46 <cschneid> benzrf: started with yours, extracted a bit to be clearer: https://gist.github.com/913934706a19656fd3b9
11:56:07 <cschneid> ReinH: very similar to yours too
11:56:21 <cschneid> ReinH: style question: how much expansion of sub-functions in where clauses is normal?
11:56:32 <cschneid> the full line felt hard to read. Now it's clearer by breaking it down. But is that normal haskell style?
11:56:52 <ReinH> cschneid: I usually see a bit less. One sec
11:57:10 <cschneid> I do like the top level def reading like this:   show (Board cells) = (unlines . withLines . withPipes) eachLine
11:58:03 <bobcrasher> ReinH:  Clearing out errorformat makes this work properly (obviously with poor error display).  That's a great starting point!
11:59:28 <ReinH> bobcrasher: cool!
11:59:56 <ReinH> cschneid: you can use show unlines . withLines . withPipes . eachLine by using getBoard in eachLine
12:01:17 <benzrf> cschneid: hm?
12:01:35 <benzrf> what's this got to do with me?
12:01:49 <cschneid> benzrf: your unlines thing, but modified - you replied to the intercalate thing, which was my thing
12:02:10 <benzrf> no that was me quoting somebody else
12:02:14 <benzrf> ReinH i think'
12:02:29 <cschneid> benzrf: yeah, who was poking at my thing :)
12:02:38 <benzrf> ok
12:03:21 <cschneid> ReinH: hmm. not sure what you mean by using getBoard in eachLine/
12:05:09 <ReinH> cschneid: https://gist.github.com/reinh/85fca4b3a516ef839992
12:06:28 <jle`> any updates on being able to ghci into our sanboxes
12:06:43 <ReinH> jle`: cabal repl?
12:07:41 <cschneid> ReinH: do you find that more or less clear? imo, seems like it communicates intent less?
12:11:22 <ReinH> cschneid: I think starting with a pointfree style makes it easier to refactor
12:11:37 <ReinH> cschneid: e.g., https://gist.github.com/reinh/85fca4b3a516ef839992
12:12:05 <ReinH> cschneid: but no, I'm not sure that this refactoring is much clearer
12:12:58 <cschneid> ReinH: thanks a ton for your time looking at it. I like seeing different approaches to the same bit of code
12:13:02 <ReinH> cschneid: np
12:13:04 <cschneid> it is most certainly clearer than my first approach
12:13:08 <cschneid> (either way)
12:14:27 <ReinH> cschneid: I think this one reads quite nicely https://gist.github.com/reinh/85fca4b3a516ef839992/691e12ac091c149312e6f2069fd2b586a439887c
12:15:17 <cschneid> ReinH: for the moment, I'm leaning more verbose & clear in my code. My style will probably move towards more succinct over time as I get better at reading code like that.
12:15:21 <ReinH> cschneid: get the board, turn it into a list of shown cells; intercalate chunks of 3 with a pipe and add a space in front; intersperse a horizontal rule and turn the list into lines
12:15:29 <cschneid> yep.
12:15:37 <cschneid> same steps, just how much naming is done on the internal steps.
12:16:03 <ReinH> cschneid: right, when I extracted those steps as functions I found that the overall effect was to make it more verbose without adding much clarity
12:16:28 <ReinH> I don't find "drawRows" or "separateRows" or w/e much more intention revealing than `. map (" "+) . intercalate " | " . chunksOf 3'
12:17:20 <cschneid> ya. I guess I do for now :) I will focus on trying to keep helper names to a minimum (and eventually eliminate) as I get better at reading point free pieces of code.
12:17:38 <cschneid> ReinH: and thus ends my lunch break. Back to work :)
12:17:41 <ReinH> cschneid: I don't think it's necessarily a better style
12:18:04 <ReinH> cschneid: it's just the one I've moved towards after reading lots of code, probably influenced by how much Bird I read ;)
12:18:16 * hackagebot cyclotomic 0.4.2 - A subfield of the complex numbers for exact calculation.  http://hackage.haskell.org/package/cyclotomic-0.4.2 (ScottWalck)
12:20:28 <int-e> @botsnack
12:20:35 <lambdabot> :)
12:24:29 <bobcrasher> ReinH:  Assuming you're using VIM for this, any chance you could pastebin me your errorformat string?
12:26:58 <int-e> fwiw, lambdabot should now recover from one-sided closed connections (which look like ordinary ping timeouts from here) and try to reconnect within a couple of minutes.
12:27:25 <monochrom> nice
12:28:33 <monochrom> I never understand those disconnections. but perhaps it's just a disagreement between two tcp/ip stacks on what tcp/ip means, and therefore not meant to be understood.
12:29:42 <chrisdone> nah the last time was a normal reason
12:30:07 <chrisdone> one of the freenode servers went down so a few hundred people got d/c'd including lambdabot and myself
12:30:30 <monochrom> well, I have many past disconnections of many people, sometimes myself included, in mind. not specific to lambdabot
12:30:59 <monochrom> and not during netsplit or server going down
12:31:59 <Clint> the architecture of irc has always been brain-damaged and has had no improvements since the '90s
12:32:27 <FreeFull> Just have a timeout from last received message and you should be fine
12:32:33 <chrisdone> the worst part is payload length being arbitrary
12:33:22 <FreeFull> Isn't it capped at 256 bytes - some stuff?
12:33:28 <chrisdone> irc mandates a 512 char limit
12:33:32 <chrisdone> inclusive of all the prefixes
12:33:32 <FreeFull> 512
12:33:47 <FreeFull> And the last two chars will be \r\n anyway
12:33:51 <chrisdone> so if your message passes through n servers to  get to someone else, you have no idea how much truncation will happen
12:34:15 <FreeFull> IRC is a bit outdated
12:35:16 <bobcrasher> Anyone else here using the haskell-mode vimball?
12:35:46 <chrisdone> vimball, what on earth is that?
12:36:02 <bobcrasher> http://projects.haskell.org/haskellmode-vim/
12:36:11 <bobcrasher> it's basically a package of plugins for vim that you install all at once
12:36:41 <chrisdone> aha
12:37:51 <newbie|3> Does someone have an idea why I cant get "cabal update" to work on Windows 7? Error Msg http://lpaste.net/6265577855673958400 . Accessing packages from hackage with wget works fine.
12:38:25 <Jeanne-Kamikaze> does the space between the url and the : suggest anything ?
12:40:54 <Vaniax> What do you mean?
12:41:37 <viran> Hey, a little off topic,  hey, L(p) = { x | p(x) = True } ; L' = { p() | L(p) is decidable ; it's known every p halts } ; is L' decidable? To me it seems it is decidable, p halts so it's  L(p) has to be decidable too, for every given x, you check if it's in L(p) by running p(x) ;  am I wrong?
12:45:28 <benzrf> Vaniax: would it be out of line for me to propagandize against windows at you
12:46:25 <geekosaur> Jeanne-Kamikaze, I think if that space is significant then it's something going wrong inside cabal-install
12:46:34 <chrisdone> benzrf: maybe that's antigandize
12:46:56 <Vaniax> In this case yes. I like linux, but my main OS is still Windows. Problem is, with a parallel XP installation everything works.
12:47:20 <benzrf> ok
12:49:05 <fizruk> viran, seems to be true (though I'm not an expert)
12:50:32 <Vaniax> Website access is ok, wget access is ok. No idea why cabal dont want to work^^. I dont use proxys or sth. like that.
12:50:55 <viran> thanks fizruk
12:52:37 <chrisdone> int-e: do you have a github repo for lambdabot?
12:53:05 <int-e> chrisdone: https://github.com/int-e/lambdabot
12:54:21 <benzrf> Vaniax: how strange
12:54:28 <benzrf> Vaniax: wait, how do you have wget on windows?
12:54:30 <benzrf> cygwin?
12:54:55 <Vaniax> msys
12:55:38 <chrisdone> int-e: cool
12:56:22 <int-e> chrisdone: (Please don't look too closely at the IRC stuff. There is currently no sound story for server connection lifetime. I focussed on letting lambdabot die reliably when the connection is lost, so I can just restart it.)
12:56:45 <Vaniax> I have had the problems 3 months ago. But I got it to work somehow. Now I have no idea what I can do.
12:57:12 <chrisdone> int-e: your pass authentication stuff would work fine with znc. i made pretty much the same patch locally
12:57:42 <chrisdone> int-e: but i guess if it works and lambdabot doesn't lose any state, doesn't matter
12:58:15 <benzrf> chrisdone: STATE?
12:58:23 <int-e> benzrf: @tell and stuff
12:58:42 <benzrf> int-e: i was just making a stupid joke
13:02:05 <merijn> benzrf: You do realise that gnu ships windows versions of tools like wget, bash, grep, cat, etc. right?
13:02:30 <merijn> benzrf: Even without cygwin/whatever you can just download those and run them from the commandline on windows
13:02:43 <benzrf> merijn: i guess but i'd never heard of them being used outside of msys or cygwin or something
13:03:00 <merijn> benzrf: I used grep for quite a while when I was working on Windows
13:03:28 <int-e> chrisdone: if for some reason it still doesn't work I'll set up znc. my main worry about znc is that we can end up with lambdabot online but completely unresponsive.
13:05:25 <Vaniax> How possible is it that something with the network configuration is wrong? But cabal on a clean WS7 VM does not work too
13:09:57 <chrisdone> int-e: you mean if the lambdabot process dies?
13:10:09 <int-e> chrisdone: yes
13:10:42 <chrisdone> int-e: angel! :d
13:11:56 * chrisdone puts all his stuff under angel so that if the process dies it gets restarted
13:15:06 <chrisdone> that's also nice for seamless update
13:15:17 <chrisdone> cabal build && killall lambdabot
13:16:09 <int-e> chrisdone: I wrote a small <whisper>Python</whisper> script for that ;)
13:16:52 <monochrom> haha
13:17:29 * chrisdone tears up int-e's haskell card
13:18:58 <bobcrasher> Aha!  I don't think its the null output locking up vim.  After a make, haskell-mode attempts to load symbols/type information assosciated with the file it just built.  I think it's just chocking on trying to parse all of the symbols from gtk2hs
13:19:34 <chrisdone> vimscript for the vin
13:20:03 <bobcrasher> haha
13:20:28 <RichyB> byorgey, Coq is surprisingly addictive.
13:20:47 <phulin> RichyB, it's like a video game
13:21:04 <tac> RichyB: I forget who said it in reference to Agda, but "It's the world's most addicting variant of solitaire"
13:21:08 <tac> or something like that
13:21:17 <RichyB> I've finally started trying to read through Software Foundations in earnest and run all the exercises (thus far I'm pretty much nowhere but hey, sucking is the first step on the road to maybe kinda-sucking instead)
13:22:02 <RichyB> but yeah, I've got proof-general set up in Emacs and I turned proof-electric-terminator on
13:22:36 <RichyB> I seem to get an endorphin hit every time I hit the "." key and another chunk of code lights up blue to show that coqtop accepted it.
13:22:48 <tac> hah
13:22:49 <phulin> Yeah, that feeling is great.
13:22:54 <RichyB> tac, phulin: hah, yeah. :)
13:23:12 <tac> You know it's a drug because of that and the other feeling you get
13:23:23 <RichyB> I think I can understand where people find the stamina to formalise large proofs, now. You just do it part by part and it supplies continuous feedback as you go
13:23:27 <tac> Which is where you're trying to prove something for hours, up until 5am trying to figure out why you can't finish the last hole
13:23:37 <tac> then you realize that a typo cause you to try and prove something that was false
13:23:42 <RichyB> a bit like playing an MMO but the end result isn't virtual goblin corpses but lemmas.
13:23:45 <tac> and you have to throw a few hours of work and wasted effort away
13:24:06 <RichyB> tac, right, like when your raid wipes and you lose a bunch of XP because of a TPK. ;)
13:24:20 <byorgey> RichyB: =D
13:24:22 <phulin> It's like Mario. Every time you solve a goal Coq goes "but the princess is in another castle!"
13:24:24 <bobcrasher> ugh and each time you run a :make it re-does that huge symbol compilation, probably takes like 5 minutes
13:25:09 <tac> Luckily, the thrill of theorem proving wears off when you start running into the standard issues with it
13:25:37 <tac> aka: "Where's my functional extensionality???" "Why doesn't coinduction work right ;___;" and "Why do I have to prove this stuff is equal? It's obvious!"
13:26:02 <Iceland_jack> tac: If it's obvious you define it as an axiom ;)
13:26:22 <RichyB> If it's obvious, "simpl." nails it for you? ;)
13:26:30 <tac> An axiom is indistinguishable from a hole, though
13:26:34 <tac> :<
13:26:38 <monochrom> I am fine with proving obvious equalities. but losing functional extensionality? I don't accept that.
13:26:59 <tac> monochrom: I wonder if there must be models of type theory where extensionality somehow doesn't hold.
13:27:14 <tac> To justify why MLTT doesn't have it.
13:32:30 <viran> Any one have an idea how am I suppose to show that the problem of whether a turing machine moves more than a 100 steps to the left or right on a given input is undecidable?
13:34:36 <phulin> viran, if you could make a turing machine that decides that, you could use it to solve the halting problem
13:34:37 <pavonia> viran: I think you could take an algorithm that is known to be undecidable and use this for creating a Turing machine that doesn't move at all
13:34:44 <mjboa> Well if the program steps to the right forever, isn't it basically a subset of the halting problem?
13:35:45 <phulin> viran, i believe the general approach is "if it stays within the 100-move bounds, there are only a finite number of configurations (and therefore it must repeat configurations eventually)"
13:36:14 <viran> thanks, i'll try to formalize it :)
13:40:03 <benzrf> :t intersperes
13:40:03 <lambdabot>     Not in scope: `intersperes'
13:40:04 <lambdabot>     Perhaps you meant one of these:
13:40:04 <lambdabot>       `BS.intersperse' (imported from Data.ByteString),
13:40:07 <benzrf> :t intersperse
13:40:08 <lambdabot> a -> [a] -> [a]
13:40:19 <benzrf> intersperse isn't in the Prelude?!
13:40:50 <geekosaur> Data.List, I believe
13:41:03 <int-e> @hoogle intersperse
13:41:03 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:41:03 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
13:41:03 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
13:41:16 <geekosaur> the standard Prelude is defined by the Haskell standard, which does not include intersperse
13:41:59 <int-e> lambdabot's @type (:t) and @eval (>) have quite a lot of functions in scope that are not in the prelude.
13:42:05 <benzrf> ah
13:42:20 <Cale> I'm pretty sure that the List module defined by the standard defines intersperse though
13:42:35 <int-e> err, @run :-)
13:42:37 <int-e> @help eval
13:42:37 <lambdabot> eval. Do nothing (perversely)
13:42:42 <Cale> (Yes, I checked, it does)
13:42:59 <int-e> @help run
13:42:59 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
13:43:22 * hackagebot Nomyx-Language 0.4.1 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.4.1 (CorentinDupont)
13:43:24 * hackagebot Nomyx 0.4.1 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.4.1 (CorentinDupont)
13:43:27 <int-e> @. evil botsmack
13:43:27 <lambdabot> Plugin `compose' failed with: Unknown command: "evil"
13:43:45 <benzrf> @botsmack
13:43:45 <lambdabot> :)
13:43:48 <benzrf> ?
13:43:49 <benzrf> @botsmack
13:43:49 <lambdabot> :)
13:43:52 <benzrf> @help botsmack
13:43:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:44:01 <Cale> Yeah, I think the reason for @eval vs. @run was something to do with #perl6 or some other channel where there was another evaluator
13:45:39 <int-e> and it's fine because everybody uses > anyway.
13:46:47 <tac> On my bot, I use the aptly named !haskell command to run my source
13:47:21 <tac> It came about because a friend of mine was fond of using the smiley face > .< every other sentence.
13:47:42 <benzrf> hmm
13:47:46 <benzrf> ok
13:47:47 <benzrf> http://en.wikipedia.org/wiki/Lambda_calculus#Lambda_terms
13:47:54 <benzrf> if application is any term + any term
13:47:58 <benzrf> what if the first term is a var?
13:48:07 <benzrf> what does the expr reduce to?
13:48:16 <tac> benzrf: It doesn't reduce on its own
13:48:34 <tac> benzrf: Imagine in math-y terms: What does f(2) reduce to?
13:48:49 <benzrf> tac: ok, i guess what I mean isomorphic
13:48:51 <benzrf> *is
13:48:52 <tac> (answer: it depends on what f is, and you can't reduce it unless you know that!)
13:48:56 <benzrf> ah
13:49:00 <benzrf> i mean without any definition
13:49:12 <benzrf> where any 'program' is just a term
13:49:13 <tac> without any definition, it's not a reducible expression (redex) and thus, it doesn't reduce
13:49:30 <benzrf> so (a _) is just itself?
13:49:44 <benzrf> the only kind of term that reduces is an application where the first term is a lambda ?
13:49:55 <tac> If you *know* the definition, you use a δ-substitute to replace the VAR with the definition bound to that name
13:50:02 <tac> yes
13:50:20 <tac> Well, yes... unless you have types with reduction rules of their own, but you can ignore those :)
13:50:36 <int-e> benzrf: well you can have redexes (reducible subterms) elsewhere. (x ((\x -> x) y)) --> (x y), for example.
13:50:43 <tac> (a built-in function, like plus, for instance, will have more reduction rules that come with it "for free")
13:54:54 <tac> Raw lambda calculus is, IMO, difficult to think about, because the programs aren't very meaningful to a programmer
13:55:14 <tac> You don't even have data types, or even a built-in notion of a natural number
13:56:03 <tac> If I were to ever write a tutorial, I would use a slightly richer language to start with, and ignore the fact that lambdas alone are turing complete
13:56:20 <tac> (perhaps mention it, but the details are not all that interesting, IMO)
13:57:14 <chrisdone> but at least car/cdr are simple
13:57:36 <chrisdone> you can do lists quite easily and they don't feel too far and away from the real thing
13:58:37 <tac> Still, when you reduce something to a list, it requires some squinting of the eyes to even tell what's in front of you *is* a list :)
13:58:51 <int-e> tac: but ... \p -> p (\f x -> f (f x)) (\a b -> b))  can obviously be read as (2, False)
13:59:06 <chrisdone> car = \f.f (\car cdr.car)
13:59:07 <chrisdone> cdr = \f.f (\car cdr.cdr)
13:59:07 <chrisdone> cons = \car cdr f.f car cdr
13:59:19 <tac> int-e: I know I am guilty of confusing "obvious" things with "computable" things, too :)
14:00:36 <m1dnight> I'm having some issues with pure in applicative functors
14:00:45 <m1dnight> the function signature is pure :: a -> f a
14:01:04 <m1dnight> so, why then when I call "pure (Just 5)", it returns "Just 5"
14:01:19 <m1dnight> my a is of type Maybe
14:01:26 <m1dnight> and when that is "put in a box"
14:01:33 <m1dnight> shouldnt it be something like Just Just 5 or something?
14:01:43 <m1dnight> now it seems like it's just the id function..
14:01:51 <int-e> > pure (Just 5) `asTypeOf` Nothing
14:01:53 <lambdabot>   Just (Just 5)
14:02:04 <m1dnight> ah
14:02:06 <m1dnight> so
14:02:21 <m1dnight> > pure 5 `asTypeOf` Maybe
14:02:23 <lambdabot>   Not in scope: data constructor `Maybe'
14:02:25 <int-e> m1dnight: perhaps it's using the IO variant? return (Just 5) :: IO, in ghci, would just print Just 5.
14:02:26 <m1dnight> damnit
14:02:30 <chrisdone> > pure 5 :: Maybe Int
14:02:31 <lambdabot>   Just 5
14:02:39 <m1dnight> I see
14:02:50 <m1dnight> so..
14:02:51 <chrisdone> (asTypeOf takes a value to get the type from)
14:02:55 <latro`a> > pure 5 :: forall a. Num a => Maybe a
14:02:57 <lambdabot>   Just 5
14:02:57 <m1dnight> > pure 5 :: Maybe Int
14:02:58 <lambdabot>   Just 5
14:03:38 <m1dnight> so when I type simply "pure 5" it takes the typeconstructur for euhm
14:03:41 <m1dnight> well, nothing really
14:04:04 <int-e> Yes, that was probably a bad idea, because it's confusing. I used `asTypeOf` Nothing to force the result of 'pure' to be of type 'Maybe a', without having to specify a.
14:04:16 <m1dnight> I see
14:04:16 <latro`a> just "pure 5" can't typecheck by itself
14:04:17 <int-e> @type Nothing
14:04:18 <lambdabot> Maybe a
14:04:30 <m1dnight> oh great :) now i get it
14:04:39 <m1dnight> i was wondering why there was no type to be specified
14:04:50 <m1dnight> so the canonical use of pure is to add :: or asTypeOf
14:04:56 <latro`a> not at all
14:05:10 <latro`a> typically the context makes it typecheck
14:05:19 <int-e> m1dnight: usually there is enough context that provides the necessary type information
14:05:20 <latro`a> without a signature
14:05:25 <m1dnight> ah okay
14:05:44 <latro`a> occasionally you do need to help the typechecker along, but that's far from universal
14:05:45 <int-e> but for testing 'pure' in isolation, yes, you probably need a type signature.
14:05:56 <m1dnight> ah, i think I have an example in my head
14:06:28 <latro`a> but for example, if you used "maybe" at the end of an applicative calculation, the typechecker could figure out that the Applicative in question is Maybe
14:08:05 <m1dnight> someFunction :: Int -> Maybe Int
14:08:06 <m1dnight> someFunction = pure . (*3)
14:08:37 <m1dnight> so the type inferencers know it has to be Maybe Int and therefore knows it has to take the pure implementation of the instance of Maybe
14:09:02 <latro`a> *nod*
14:09:12 <m1dnight> \o/
14:09:23 <m1dnight> this Haskell, not your ordinary programming language
14:09:50 <m1dnight> thanks again guys :)
14:11:31 <m1dnight> toch ne slimmen ze, dienen type inferencer van haskell :p
14:12:12 <Craig-UKC> Hey there,
14:12:23 <m1dnight> wow, wrong channel guys sorry
14:14:25 <Craig-UKC> Does anyone have any experience with the GHCMonad? - specifically GHC.exprType - and how I can get it to be in context with a module that I have compiled programmatically. I'm building a debugging/analysis tool as part of some research that needs to chuck lots of small programs at the compiler and find out the types of various bits are.. Any help would be much appreciated
14:18:48 <Bambi> Hi!
14:18:54 <jtcwang> Hi!
14:19:04 <Bambi> I'm trying to write a simple game in Haskell
14:19:17 <jtcwang> can't help you i'm a total noob
14:19:18 <Bambi> the problem is that I can't seem to figure out how to print a message on screen and then keep the game loop going
14:19:29 <geekosaur> int-e?
14:19:32 <geekosaur> @lpaste
14:19:33 <lambdabot> Haskell pastebin: http://lpaste.org/
14:19:38 <geekosaur> ^ lpaste.net
14:19:38 <Bambi> so, I've got a simple check for a certain condition
14:20:05 <Bambi> ...followed by a then/else branch
14:20:25 <aranea> Hi. In a project (https://github.com/atlaua/hbf/tree/prgmio/HBF) I am using two custom monad classes (Tape and PrgmIO), each of which has (or will have) multiple instances. Then there's a function "runCmds :: (PrgmIO m, Tape m) => ...", which needs a monad which is instance of both classes, but doesn't care about the exact implementations. What's the easiest way to allow combining of the different instances to custom monads which instantiate both classe
14:20:39 <Bambi> let's say in the 'then' branch I have 'putStrLn "some text"'
14:20:41 <Bambi> that works
14:21:01 <Bambi> or, I could put another call to the game loop in there, with changed paramaters
14:21:10 <Bambi> but I would like to first print to the screen, and then call the game loop
14:21:19 <Bambi> How would I do that?
14:21:38 <lpaste> aepokh pasted “Handling possibilities of failure” at http://lpaste.net/95876
14:21:58 <aepokh> i'm wondering if there's a more idiomatic way of getting something out of an Either?
14:22:24 <hpc> aepokh: fromJust . unsafeCoerce -- :D
14:22:49 <merijn> hpc: ಠ_ಠ
14:23:14 <merijn> aepokh: Well, usually you'd use the Monad/Functor instance of Either to chain potentially failing calls together
14:23:26 * hackagebot smtps-gmail 1.0.0 - Gmail API  http://hackage.haskell.org/package/smtps-gmail-1.0.0 (EnzoHaussecker)
14:23:39 <aepokh> yeah, i am in the module, but when i actually want to propagate these messages to stderr
14:23:54 <merijn> aepokh: Usually you'd just use case/of
14:23:58 <aranea> aepokh: there's "either", if that helps
14:23:58 <aepokh> and terminate the program if some irrecoverable error occurs
14:24:07 <aranea> @hoogle either
14:24:07 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
14:24:08 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
14:24:08 <lambdabot> package either
14:24:24 <merijn> "case finalResult of Left errorMsg -> hPutStrLn stderr ...; Right _ -> doSomething"
14:24:37 <int-e> geekosaur: yes?
14:24:38 <merijn> Ah, yeah and "either" works too
14:24:48 <geekosaur> @lpaste
14:24:48 <lambdabot> Haskell pastebin: http://lpaste.org/
14:24:52 <geekosaur> does not resolve
14:24:54 <geekosaur> lpaste.net
14:24:58 <aepokh> i thought about that, but i'd end up with either nested case expressions and a million indents
14:24:58 <int-e> @paste
14:24:59 <lambdabot> Haskell pastebin: http://lpaste.org/
14:25:04 <jtcwang> just google it
14:25:13 <aepokh> or a huge amount of functions that basically feel like they should be main
14:25:24 <aranea> aepokh: sounds like you want the monadic interface
14:25:27 <geekosaur> I keep pointing people to that in #xmonad and then saying "oh d*mn" and correcting it
14:25:38 <int-e> geekosaur: darn. that's what I get for re-doing other people's patches manually.
14:26:03 <aepokh> i should come back when i actually can show the code i'm writing :P
14:26:13 <aepokh> i'm on the university computers right now
14:28:22 <aepokh> i'm writing a grep clone, so first i have to make sure the regular expression compiles
14:28:38 <aepokh> and my regex compiler does use Either String RegexMachine
14:28:39 <int-e> @paste
14:28:53 <lambdabot> Haskell pastebin: http://lpaste.net/
14:29:07 <aepokh> but then when i run them against files i have to check that they worked
14:29:08 <int-e> geekosaur: thanks
14:29:19 <aepokh> and it'll be Either FileError [String] or something like that
14:29:37 <aepokh> er, [Either FileError [String]]
14:30:22 <aepokh> and if i sequenced that, then a single error would cover the whole thing
14:30:38 <aepokh> like if one file didn't exist but all the others did, the rest of them wouldn't even get grepped
14:31:52 <aepokh> yeah, i think the solution here is to mapM a function with case statements
14:33:20 <aranea> Noone has an idea about my question? I'm really lost with this atm...
14:33:52 <tac> aranea: what was your question?
14:35:04 <aepokh> say, is there any difference between mapM and \f xs -> sequence $ map f xs?
14:35:21 <tac> @src mapM
14:35:21 <lambdabot> mapM f as = sequence (map f as)
14:35:27 <tac> doesn't look like it
14:35:30 <aepokh> neat
14:35:55 <aranea> tap: Hi. In a project (https://github.com/atlaua/hbf/tree/prgmio/HBF) I am using two custom monad classes (Tape and PrgmIO), each of which has (or will have) multiple instances. Then there's a function "runCmds :: (PrgmIO m, Tape m) => ...", which needs a monad which is instance of both classes, but doesn't care about the exact implementations. What's the easiest way to allow combining of the different instances to custom monads which instantiate both c
14:36:07 <aranea> ehh, I meant tac
14:37:01 <tac> What is a "monad class"?
14:37:07 <tac> a subclass of monad?
14:37:39 <aepokh> class Monad m => PrgrmIO m?
14:37:43 <aranea> tac: yes, a "class (Monad m) => Tape m where ...
14:38:24 <tac> ok
14:38:58 <tac> What are you looking to do then? What do you mean by "combine" there?
14:39:02 <aranea> I've got a rough idea how that could be done with custom monad transformers, but I don't want to implement the stacking logic separately in each instance
14:39:21 <tac> aranea: Have you ever worked with free monads or the operational package?
14:39:35 <aranea> tac: I want to derive a custom monad which is both (PrgmIO m, Tape m)
14:39:50 <aranea> tac: never even heard of that. I'm quite new to Haskell
14:40:11 <tac> Operational monads: http://apfelmus.nfshost.com/articles/operational-monad.html
14:40:23 <tac> Basically, you use GADTs to define a set of "commands" your monad implements
14:40:50 <tac> and the library does magic things and makes a monad for you (and a monad transformer) which automatically satisfy the monad laws
14:40:58 <aranea> okay, I'll have a look at that, thanks
14:42:00 <tac> fistinggr8: did you have a question?
14:43:01 <tac> oh fun. fistinggr8 is a spambot.
14:43:18 <aepokh> i'm not seeing anything from them
14:43:27 <WraithM> 1
14:43:27 * hackagebot kure 2.14.4 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.14.4 (NeilSculthorpe)
14:43:32 <tac> (It was a PM)
14:44:48 <Maxdamantus> O_o deriving Monad
14:45:39 --- mode: ChanServ set +o geekosaur
14:46:49 --- mode: geekosaur set +b fistinggr8!*@200.79.253.35
14:47:04 * geekosaur thinks he did that wrong. crap
14:47:13 --- mode: geekosaur set -b fistinggr8!*@200.79.253.35
14:47:26 --- kick: fistinggr8 was kicked by geekosaur (fistinggr8)
14:47:34 --- mode: geekosaur set +b *!*fistinggr@200.79.253.*
14:47:40 --- kick: fistinggr8 was kicked by geekosaur (fistinggr8)
14:48:15 <Maxdamantus> Still wrong.
14:48:24 <Maxdamantus> Oh, nvm.
14:48:28 * hackagebot doctest 0.9.10 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.10 (SimonHengel)
14:48:51 <geekosaur> kicking form here can't stop pms
14:49:04 <geekosaur> but no eason to let an identified spambot hang out here
14:49:06 <jml> if I want to read from a file, does something with its contents and then closes it, is it possible to have a function that does all the IO and returns the contents...
14:49:14 <geekosaur> like the way it rejoined after the first kick...
14:49:22 <jml> i.e. will it get closed before I get a chance to read from the handle
14:53:07 <jml> hmm. I guess another way of asking the question is how does the file handle get closed when using readFile?
14:55:46 <Craig-UKC> jml: all the pure logic will happen inside the do notation. You can't return the contents it will always be tainted by the IO monad.
14:55:59 <Craig-UKC> but that doesn't mean you can't achieve what you want
14:56:16 <jml> Craig-UKC: my question is more "when will the hClose get called"?
14:56:33 <geekosaur> when the file is completely read. don;t call hClose yourself
14:56:38 <geekosaur> it's lazy I/O
14:56:46 <Craig-UKC> ^
14:57:01 <geekosaur> when more data is demanded from ther string, the file will be read; if that gets EOF or error, hClose gets called automatically
14:57:26 <Cale> It happens either when the file is completely read, or at some indeterminate point after the string is garbage collected.
14:57:38 <geekosaur> if you call hClose yourself, you must be certain the entire file has been read first or you *will* break things
14:57:50 <jml> ok, thanks.
14:58:05 <chrisdone> i'd recommend just not using lazy IO if it's all the same
14:58:28 * hackagebot hermit 0.3.2.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.3.2.0 (AndrewFarmer)
14:58:29 <Cale> If you're using (String) readFile to read many tiny files, you do have to be somewhat careful not to run out of filehandles because of the lazy I/O and the fact that OSes have draconian limits.
14:58:31 * hackagebot gpolyline 0.1.0.0 - Pure module for encoding/decoding Google Polyline  http://hackage.haskell.org/package/gpolyline-0.1.0.0 (FinnEspenGundersen)
14:58:31 <Craig-UKC> chrisdone: depends how big your files are, if it's a large log file... probably want to use lazy IO
14:58:47 <jml> in this case, scale isn't an issue.
14:58:57 <chrisdone> there's also the pitfall of trying to write to that file
14:58:58 <jml> (either of file size or number of files)
14:59:15 <chrisdone> you often make the mistake of not having read it all before you start trying to write back to it and you get an exception because the file isn't closed
14:59:29 <Cale> chrisdone: Right, but you should never actually do it that way regardless.
15:00:00 <Cale> It's always been considered better practice, even in strict imperative languages, to write to a new file and then move the complete file over the old one.
15:00:11 <pavonia> Heh, I'm having the same problem. I'm reading a file and parsing its contents, but if the parser fails and only some portion of the file is read, the file is still open. Don't you have to call hClose manually here?
15:00:38 <geekosaur> depends on how it's reading the file
15:00:47 <pavonia> via readFile
15:00:53 <chrisdone> pavonia: probably it's garbage collected if the string is garbage collected
15:01:06 <Cale> pavonia: If you're really sure that you have nothing more to do with it, you can explicitly hClose, but if the hClose goes through and then you try to look at the String, you'll see some arbitrary truncation of the file's contents.
15:01:08 <geekosaur> if using lazy I/O, you would ned to hClose or let the string tgo out of scope (and next major gc it'll be closed(
15:01:18 <chrisdone> but nonsense like this isn't worth the trouble for the advanced use-case of reading something in as an incomplete stream
15:01:58 <Cale> Right, that would be the saner thing to do usually.
15:02:04 <Cale> (just let the GC handle it)
15:02:42 <chrisdone> fortunately you don't have to do much to get strict IO. just import Data.Text.IO or Data.ByteString and you have strict IO
15:03:24 <chrisdone> it would be cool if System.IO was strict and System.IO.Lazy was lazy
15:03:27 <chrisdone> a la bytestring and text
15:03:27 <Cale> Sometimes lazy IO is nice though -- especially if you just have one big file that you're processing.
15:03:46 <chrisdone> Cale: that's what the people said a few lines up, yes
15:03:58 <Cale> Yeah, I've always thought that there should be strict and lazy variants of String IO
15:04:05 <Cale> readFile' etc.
15:04:32 <pavonia> chrisdone, Cale: So when will the string be GC? I display the error message from Parsec and that's all, but the file is still locked
15:04:54 <geekosaur> when a major collection happens. you don't really have control over that
15:05:17 <chrisdone> it's not very straight-forward because it depends on the code
15:05:25 <chrisdone> if you're still hanging onto it somehow it won't be gc'd
15:05:40 <chrisdone> hang-ons like that are subtle
15:05:51 <Feuerbach> pavonia: a parse error may occur (and probably did) before the whole file is read
15:06:10 <pavonia> Feuerbach: Yes, tht's the actual problem
15:06:15 <chrisdone> hm, in fact readFile is probably using hGetContents
15:06:21 <Cale> pavonia: What are you trying to do with the file after the parse error?
15:06:30 <chrisdone> and i'm not sure whether hGetContents actually garbage collects unfinished handles
15:06:49 <chrisdone> i guess if the Handle becomes unreferenced it's auto-closed, tho
15:06:57 <Cale> pavonia: The end of your program will also release all the locks
15:07:04 <chrisdone> (via finalizers)
15:07:26 <pavonia> Cale: I try to debug my pasrer/file contents. But when doing that in GHCi, I can't change the file contents in my editor while GHCi is still running because the file is locked
15:07:36 <chrisdone> pavonia: how big is the file?
15:07:49 <Cale> pavonia: Oh, in that case, just hClose it yourself
15:07:53 <pavonia> about 1 kB
15:08:06 <chrisdone> heh, just use strict io and be done with it
15:08:25 <chrisdone> http://hackage.haskell.org/package/strict-0.3.2/docs/System-IO-Strict.html
15:08:28 <Cale> Oh, if you used readFile, then you couldn't do that, but if you used openFile/hGetContents, then you could.
15:08:44 <Cale> Or yeah, you could switch to strict IO
15:08:59 <pavonia> chrisdone: But that's only for debugging! In real world, the files will be much larger
15:09:20 <chrisdone> how much? also, if they're large, don't use Strings
15:09:44 <pavonia> several MBs
15:10:03 <chrisdone> eh, a few megs isn't a big deal
15:10:25 <chrisdone> today's “large file” is a gig+
15:10:56 <acowley> Even for a file of a few MB, I'd probably avoid loading it into a String
15:11:01 <pavonia> it would be noce to no read them strictly if not necessary
15:11:25 <chrisdone> acowley: sorry,  yeah, to be clear i wouldn't use String for a few mb. i meant a few mb is fine for reading in strictly
15:11:25 <Cale> :t openFile
15:11:27 <lambdabot> Not in scope: `openFile'
15:11:32 <Cale> :t System.IO.openFile
15:11:33 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
15:11:46 <pavonia> I mean it would be fine if the GC eventually release the file handle, but atm for me it's hard to tell if that will happen, and if so, when :)
15:11:48 <Craig-UKC> 20 MB file being loaded into a process farm instance would soon fall over - 100's of workers processing files in the cloud would soon start stepping on swap
15:11:51 <Cale> hdl <- openFile "myFile" ReadMode
15:12:06 <Cale> cs <- hGetContents hdl
15:12:14 <chrisdone> Craig-UKC: pavonia is working in such conditions?
15:12:19 <Craig-UKC> who knows
15:12:24 <chrisdone> pavonia knows
15:12:26 <Craig-UKC> just giving a situation where it may matter
15:12:35 <chrisdone> sure. running it on a raspberry pi would matter too
15:12:39 <Craig-UKC> indeed
15:12:48 <acowley> Is the problem just that we have too many ways of solving pavonia's problem?
15:12:49 <pavonia> no, I'm not
15:12:56 <acowley> Use Handle and bracket is one option
15:12:56 <Cale> acowley: yes
15:13:08 <acowley> Use Text or ByteString is another layer
15:13:25 <chrisdone> strict vs lazy is another option
15:13:30 * hackagebot hermit-syb 0.1.0.0 - HERMIT plugin for optimizing Scrap-Your-Boilerplate traversals.  http://hackage.haskell.org/package/hermit-syb-0.1.0.0 (AndrewFarmer)
15:13:36 <acowley> pipes, conduit, io-streams, machines, iteratees, or enumerators are another set of options
15:13:45 <Feuerbach> well, if you're gonna use bracket, you must use strict IO
15:14:05 <chrisdone> not really -- just strictness inside the bracket
15:14:11 <acowley> Yes, pavonia said that errors are encountered during parsing
15:14:27 <chrisdone> you could let !result = parse …
15:14:40 <acowley> yeah
15:14:46 <Feuerbach> agreed
15:15:13 <pavonia> What would that do?
15:15:31 <chrisdone> it would force the parse result to be evaluated strictly and throw any exceptions if there are any
15:15:49 <chrisdone> > let x = undefined in ()
15:15:50 <lambdabot>   ()
15:15:51 <chrisdone> > let !x = undefined in ()
15:15:52 <lambdabot>   *Exception: Prelude.undefined
15:16:25 <chrisdone> you'd still have your lazy parser, but the result of the parse would be strict
15:16:54 <chrisdone> if you're able to paste your code we could probably demonstrate a few ways to solve the problem
15:16:58 <pavonia> but the result is already evaluated
15:17:26 <Craig-UKC> nominolo: are you around? baffled by some ghc api code that your name is next to. I must admit your commit is 5 years old.
15:17:34 <danilo2> hello :) Is there any DSL or a standard method to write a config file in Haskell? I'm not talking about runtime loaded config - I'm talking about a file, which is a real Haskell file and has lot of hardcoded variables, like version of the program, relative paths to libraries etc?
15:18:15 <pavonia> chrisdone: readFile "foo.tmp" >>= (return . parseOnly (string "#"))  -- after displaying the error the file is still opened
15:18:17 <danilo2> Of ocurse I can make simple datatypes and an instance of such datatype and fill it with needed information - I'm just looking for more "fancy" way, if there exist one :)
15:18:22 <Craig-UKC> danilo2: lots of the things you described are handled by cabal
15:19:02 <chrisdone> pavonia: sure -- so here you just need to make a tweak to force the error so that it can be caught
15:19:07 <chrisdone> pavonia: e.g.
15:19:23 <danilo2> Craig-UKC: ok, bu I want my program to write to console its veriosn after running "myprogram --version" does Cabal have support for passing such variable to Haskell compiled code?
15:21:12 <acowley> danilo2: http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-the-package-version
15:21:41 <chrisdone> pavonia:
15:21:41 <chrisdone> bracket (do h <- openFile "foo.tmp"; c <- hGetContents h; return (h,c))
15:21:42 <chrisdone>         (hClose . fst)
15:21:43 <chrisdone>         (\(_,c) -> do let !r = parseOnly (string "#") c; return r)
15:21:47 <chrisdone> something like that
15:22:11 * pavonia tries
15:22:14 <chrisdone> probably evaluate could also do the job
15:22:29 <chrisdone> (evaluate . parseOnly (string "#") . snd)
15:22:31 <chrisdone> or so
15:22:42 <danilo2> acowley,Craig-UKC: Thnak you very much! this can be exactly what I'm looking for! Can I export my custom "labels" this way?
15:24:57 <Craig-UKC> danilo2: not sure what cabal allows in the area, but the API looks extensive i.e. you probably have access to everything cabal does, so it should be possible.
15:26:25 <acowley> You can probably do anything you want with a custom Cabal build, or you can use CPP and standard define flags
15:26:58 <pavonia> chrisdone: Awesone, that works!
15:27:16 <pavonia> chrisdone: What is evaluate?
15:27:24 <acowley> :t evaluate
15:27:25 <lambdabot> a -> IO a
15:27:27 <chrisdone> evaluate x is the same as let !r = x in r
15:27:34 <chrisdone> (in the io monad)
15:27:46 <chrisdone> err
15:27:55 <chrisdone> evaluate x is the same as let !r = x; return r
15:28:04 <chrisdone> you know what i mean. it's from Control.Exception
15:28:04 <c_wraith> Not quite
15:28:19 <acowley> subtlety awaits
15:28:23 <c_wraith> It actually ensures that it doesn't force its argument unless the action is exectued
15:28:46 <c_wraith> The distinction only matters because of seq, though
15:29:20 <acowley> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Control-Exception.html#g:8
15:29:28 <acowley> I wish evaluate wasn't defined in that module
15:29:29 <heatsink> The Cabal API is extensive, but not stable.  I've had issues supporting multiple versions of the Cabal library.
15:31:53 <chrisdone> acowley: i suppose exceptions is the common use-case for evaluate
15:33:35 <c_wraith> > (return $! undefined :: IO ()) `seq` ()
15:33:35 <acowley> chrisdone: I suppose so, but it's also a way of hacking in pointfree strictness for efficiency purposes. Perhaps that use case is discouraged, though.
15:33:37 <lambdabot>   *Exception: Prelude.undefined
15:34:27 <aranea> tac: Read the article. I guess I understand how this could be used to implement my monad, but isn't there a easy way to keep my current code (reminder: https://github.com/atlaua/hbf/tree/prgmio/HBF , Tape and PrgmIO) and provide an easy way to create a Monad supporting both interfaces?
15:34:36 <chrisdone> huh
15:34:44 <chrisdone> has 'group' ever been a keyword in a haskell mode?
15:34:46 <danilo2> Craig-UKC: thank you, I'm testing it, brb :)
15:35:18 <tac> I'm not sure. In general, making monad instances "by hand" is a PITA :X
15:35:25 <chrisdone> HSE with all extensions enabled does not like to see the word 'group' used as an identifier
15:35:46 <acowley> I'm not aware of it being a keyword
15:36:39 <chrisdone> λ> parseModuleWithMode parseMode "x = group"
15:36:40 <chrisdone> ParseFailed (SrcLoc {srcFilename = "<unknown>.hs", srcLine = 1, srcColumn = 5}) "Parse error: group"
15:36:56 <geekosaur> it's a keyword with a certain extension enabled
15:37:02 <aranea> chrisdone: perhaps you remember my question from yesterday ("custom monad transformers") – now I've got the code in question online, see my last post.
15:37:05 <Saizan> chrisdone: there's some extended list comprehension syntax
15:37:06 <chrisdone> where parseMode = defaultParseMode { extensions = filter (\x -> case x of DisableExtension x -> False; _ -> True) knownExtensions , fixities   = Nothing}
15:37:07 <geekosaur> related to monad comprehensions I think
15:37:13 <chrisdone> ahhh
15:37:14 <Saizan> chrisdone: which has a group by i think
15:37:16 <chrisdone> that'll be it
15:37:21 <geekosaur> supposed to extend monad comprehensions to be sql like
15:39:07 <danilo2> Craig-UKC: Where have you found the API? It seems it is impossible for me right now to add custom fields to Paths_pkgname, but I might be wroong - still searching and testing.
15:39:36 <Eduard_Munteanu> Is there some way to "import" LANGUAGE pragmas? I want some buffed up "Prelude", since I'm getting tired of spewing those magic incantations
15:39:49 <heatsink> The API is on the cabal site, http://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/
15:40:16 <Eduard_Munteanu> Perhaps cabal can supply them?
15:40:18 <c_wraith> Eduard_Munteanu: throw them in your cabal file
15:40:35 <c_wraith> there's a section explicitly for listing language pragmas
15:40:56 <Eduard_Munteanu> c_wraith: can I still have some modules which don't get those pragmas?
15:41:02 <c_wraith> no
15:41:17 <Eduard_Munteanu> Though I guess it's fine.
15:41:21 <c_wraith> also, it really messes with loading those files in ghci
15:41:29 <c_wraith> though maybe it works in cabal repl
15:41:31 <Eduard_Munteanu> Aw.
15:41:32 <c_wraith> which is a thing now
15:41:39 <Eduard_Munteanu> Cabal has a REPL? :O
15:41:46 <aranea> darn it, I'll continue this tomorrow
15:41:49 <c_wraith> sufficiently new versions do
15:42:00 <c_wraith> I think it was added at the same time as sandboxing
15:42:18 <heatsink> The paths module generation code isn't configurable, danilo2.  It just concatenates strings and writes to a file.
15:43:23 <Eduard_Munteanu> Can I define arbitrary targets in cabal, like in Makefiles? I could make one for launching ghci, if possible.
15:43:30 <danilo2> heatsink: Ok, I was asking on the beginnin how to pass such configuration to my haskell program. It would be ideally to me to add some configs to cabal (like XXX:11) and then read it in Paths_pkgname. I understand such functionality is not currently possible ?
15:44:03 <heatsink> That isn't possible.
15:44:22 <dcoutts_> Eduard_Munteanu: cabal repl covers that case of launching ghci
15:44:26 <heatsink> You can add a post-configure hook or a pre-build hook that writes configuration to a module
15:45:48 <danilo2> heatsink: I was thinking right now about it! But can I read in such hook a field that is not allowed in a section - I mean a custom field added to cabal ? If yes, do I have to prse somehow cabal configuration or there is an api which will give me a strightforward access to it?
15:46:07 <danilo2> *parse
15:46:08 <Eduard_Munteanu> I wonder if you could integrate TH with a build system, to get a saner "macro preprocessor".
15:46:49 <derekv> I should ask myself why I am using haskell instead of eg node/restify to build a RESTful service, and the answer is sortof obvious (I want to use haskell so I can learn it), but I worry whether it'll be worth it
15:48:09 * derekv wrings hands
15:48:21 <chrisdone> a bigger question is why use node
15:48:29 <heatsink> You want to add a custom field to cabal?  Do you mean the .cabal file?
15:48:33 <radicality> I'm also trying to learn some more "real" haskell by building a web app in yesod, and i'm having a hard time...
15:48:43 <c_wraith> I'd say things like "maintainability" and "performance" are reasons to use haskell over node.
15:48:47 <chrisdone> radicality: a hard time with what part?
15:49:03 <derekv> radicality: I started out with scotty but i'm considering moving over to yesod because there is more documentation and examples
15:49:07 <dcoutts_> derekv: node.js is actually an awful programming model for concurrency
15:49:31 <Eduard_Munteanu> I had a hard time with Yesod because of the HTML+CSS+JS side. :)
15:49:49 <heatsink> It shouldn't be necessary to modify the cabal file when installing a package.
15:49:57 <radicality> chrisdone: well, first I'm still not very good at haskell so many times i'm stuck looking at type errors. but also since it's not really mature yet with many libraries. just doing CRUD that rails automatically provides, it seems i have to do it by hand in yesod. other than that i'm using yesod mostly to learn some more "real" haskell
15:50:08 <derekv> dcoutts_: i didn't say anything about concurrency.  It was more a comment on the problem I want to solve with my app: its very strait forward ... putting a restful json http api in front of a database
15:50:09 <Eduard_Munteanu> I still can't believe you need to write that stuff to make a webapp in 2013.
15:50:21 <danilo2> heatsink: I mean a package.cabal file - a file describing a library or an executable. I want for example to add there a field "stage : alpha" and read it in code (maybe the example with stage is not perfect, but I hope you understand what I'm trying to do)
15:50:32 <dcoutts_> derekv: web services are inherently concurrent
15:50:58 <dcoutts_> derekv: Haskell lets you do classic imperative sequential programming, rather than forcing you into callback hell
15:50:59 <radicality> Eduard_Munteanu: yeah that too, i haven't even gotten yet to the part in my app where I need to write nice responsive JS, i can imagine it won't be too easy/pretty
15:51:09 <c_wraith> radicality: in my experience, about 75% of what rails "automatically provides" is misconfigured, too limited, or actively harmful.
15:51:35 <chrisdone> radicality: are you going through the yesod book? and aware that there's a #yesod channel?
15:51:36 <radicality> dcoutts_:  yeah, i was working on a large node project once, and it really was callback hell… that's why i'm learning haskell :)
15:51:45 <heatsink> Why not put the data in a haskell file, danilo2?
15:51:46 <dcoutts_> derekv: ^^ :-)
15:51:48 <Eduard_Munteanu> radicality: my problem with it is exactly that, that you have to write JS to implement simple widgets.
15:52:22 <dcoutts_> radicality: it amazes me that they designed node.js with no thread system at all
15:52:37 <danilo2> heatsink: Heh, that was my initial question - I was asing if is there a "fancy" or more beautifull way than hardcoding a file called "config.hs" with all such stuff :)
15:52:38 <radicality> chrisdone:  yep, skimming through the parts i need, sometimes ask questions on #yesod, people are helpful, so I'll stick for now with learning it since the type safety really is great.
15:53:01 <Eduard_Munteanu> I'd much rather write a gtk2hs app.
15:53:15 <dcoutts_> danilo2: why not just install it as a data file?
15:53:30 <heatsink> Is the file only modified by the package maintainer?
15:53:50 <danilo2> dcoutts_: could you clarify it a bit?
15:53:55 <danilo2> heatsink: yes
15:54:12 <chrisdone> radicality: fwiw the fpcomplete ide is pretty sweet for web programming, especially while learning haskell & yesod
15:54:34 <danilo2> heatsink: it should be like a config file, but end user does not need and does not want to change it
15:54:40 <dcoutts_> danilo2: I'm not sure what's in your config.hs, but would it work to just have a config file installed with the app that is read at runtime?
15:55:08 <dcoutts_> danilo2: cabal can install data files for you and provides a way to find them at runtime
15:55:33 <radicality> chrisdone:  yep, was following a tutorial in its 'school' part the other day, and i saw a video demo of fpcomplete ide, and it looks good. will try it soon
15:55:52 <danilo2> dcoutts_: I want to keep in this file sonme relative paths (to a compiler libraries and documentation from the root installation path - etc - a configuration of environmen,t which should be maintained by a maintainer of a package)
15:55:58 <chrisdone> radicality: e.g. this is the demo  project http://chrisdone.com/play.png i hit the play putton and get: https://bf736cd8-f13a-4fa2-8ae3-cf46682ef40f-app.fpcomplete.com/
15:56:05 <derekv> dcoutts_: i'm not here trying to advocate for node... I could have said python/flask or whatever, i guess its sortof more like, should I go for the thing I know will allow me to get more prototyping done faster... given that if I do it in haskell, i'm hampered by an incomplete understanding of the language and tools and especially a lack of experiance
15:56:40 <danilo2> dcoutts_: I know, but I need to access these strings in Haskell. I think I'll stay with simple datatypes for that :)
15:57:18 <heatsink> danilo2, it sounds like the simplest solution is to make a haskell file containing global variables.
15:57:59 <radicality> chrisdone: ahh, Fib numbers as a service, just what I needed :P this looks cool though, thanks for the example.
15:58:08 <danilo2> heatsing: sort of - I wanted to integrate it with cabal, but yes - it is enough :)
15:58:10 <dcoutts_> derekv: ok, I was making a separate point that node is particularly badly suited for writing web services, whereas python, ruby or Haskell don't have that problem
15:58:17 <heatsink> libRelativePath = "compiler" </> "lib"
15:58:27 <acowley> danilo2: Is your objection to a non-executable config file (e.g. yaml) that you'd have the config data in IO?
15:58:58 <danilo2> acowley: No, I know we can make runtime loaded configs, but I do not want something like that, than you :)
15:59:06 <derekv> then again I built a small app in python/pyramid for fun and it took a long time with me being frustrated over stupid langauge unfamiliarity issues so ... yea it could be worth it
15:59:33 <Peaker> dcoutts_: between cooperative threads, explicit callbacks/promises, and preemptive threads in a shared-mutable-state language,  I'd always choose the first 2 over the last one. Cooperative threads aren't that much nicer than explicit callbacks, if you're careful about de-structuring stuff properly.  It's easy to make a mess of callbacks, but it can be manageable
16:00:03 <dcoutts_> derekv: so it's really a short-term vs long-term tradeoff. Learning something new always takes time up front. But if in the long term it lets you do more/better then...  well, there's a break-even point somewhere. Can be a tricky judgement of course.
16:00:16 <Eduard_Munteanu> Is there a way to make ghc accept ∃ as a type constructor? I tried looking it up and it's neither lower- nor uppercase
16:00:39 <hpc> Eduard_Munteanu: is it symbol?
16:00:39 <geekosaur> only infix
16:00:43 <chrisdone> Eduard_Munteanu: it's not a letter?
16:01:02 <Eduard_Munteanu> I think it's not a letter.
16:01:06 <Eduard_Munteanu> http://www.fileformat.info/info/unicode/char/2203/index.htm
16:01:20 <Eduard_Munteanu> geekosaur: oh... wasn't there something like prefix operators?
16:01:28 <Eduard_Munteanu> Maybe that works.
16:01:54 <geekosaur> you maybe thinking of wrapping an operator in () but I don't know if that works for type constructors
16:02:26 <Eduard_Munteanu> geekosaur: no, I vaguely remember GHC accepting infix operators of unit arity
16:02:46 <derekv> dcoutts_: yea and well maybe my app will take off and I'll create a huge vacuum for haskell programmers driving up job oppurtunities and salaries.  never know.
16:02:51 <heatsink> Eduard_Muntenau, that had something to do with section syntax
16:03:09 <RichyB> Peaker, I'm not so sure about that. Given preemptive threads and shared-mutable-state, you can implement all of the other abstractions except for memory-safety. :)
16:03:31 <Eduard_Munteanu> Oh... it's *post*fix.
16:03:32 <Peaker> RichyB: power equivalent is a tarpit -- I'm talking about how you'd rather write code
16:03:36 <dcoutts_> derekv: well, be reassured you're not the only one doing that kind of app :-)
16:03:40 <radicality> Eduard_Munteanu: isn't using that kind of symbols… unmaintainable/difficult if you send it to people? why not have your IDE just change the symbol to what you want. as an example, i use this for vim: https://github.com/Twinside/vim-haskellConceal  and it nicely displays forall as the correct symbol, etc
16:03:56 <Peaker> RichyB: shared-mutable-state by-default + preemptive threads makes software an order of magnitude harder to get right than cooperative multitasking (either with user threads or callbacks)
16:04:00 <dcoutts_> derekv: REST backend services in Haskell is relatively common in commercial use
16:04:23 <derekv> dcoutts_: thats cool to know =]
16:04:23 <Eduard_Munteanu> radicality: I wanted to define a type like that... these days it should be easy to type unicode.
16:04:26 <RichyB> Peaker, yeah, I just mean that, the computer I have came with a shared-memory preemptive environment installed on it, and I can go download implementations of various programming languages that implement the others. :)
16:04:27 <Peaker> and manual CPS is not as horrible as many say -- *if* you make sure it's actually a CPS of decent code. Don't make huge flat chains of callbacks, just like you wouldn't make a huge flat function
16:04:54 <chrisdone> i'd venture that the majority of haskell jobs out there are web services
16:05:10 <chrisdone> that and finance
16:05:21 <Hodapp> DAY TRADING MAN TO THE RESCUE!
16:05:22 <Peaker> RichyB: well, that doesn't say much about what you'd want to use for most programs
16:05:42 <RichyB> I'm not really convinced of the utility of cooperative threading as anything other than a performance technique. It just means that you effectively have *every* basic-block of code running in its own critical section. It's not like it takes asynchronicity out of the picture.
16:05:50 <dcoutts_> Peaker: doing 4 things in order seems like it's quite common, but 4 nested callbacks is already pretty horrible
16:06:30 <hpc> RichyB: that sounds like a semantic technique more than a performance technique
16:06:54 <Hodapp> RichyB: anytime you must run things in sequence, it's like every single bit of code is running in its own critical section.
16:07:02 <heatsink> Why is haskell so popular for finance?
16:07:37 <derekv> heatsink: i have the perception that FP is popular in finance becuase the cost of a but is litteral, immediate and often dramatic
16:07:41 <hpc> heatsink: because it's not fun losing 400k per second due to a preventable software problem
16:07:52 <heatsink> the cost of a but?
16:07:55 <geekosaur> bug
16:07:56 <RichyB> *bug
16:08:01 <derekv> haha bug
16:08:02 <heatsink> ah
16:08:05 <hpc> programmers often care about the cost of butt
16:08:12 <dcoutts_> heatsink: Correctness when you're dealing with lots of money is good for business.  Developing the software quickly is also good for business.
16:08:22 <Peaker> dcoutts_: It's syntactically bad, yeah. But only "skin deep".  It's much better than the deep problems of preemptive threads with shared mutable state -- which explains the appeal
16:08:29 <dibblego> There was a good blog post that pointed out the difference between types (universal) and tests (existential) but I cannot google it into existence. Can anyone remind me of it please?
16:08:38 <Hodapp> dcoutts_: Are you aware of any studies that have attempted to get any hard evidence for the correctness and efficiency here?
16:08:51 <dcoutts_> Peaker: I somehow doubt that's the reason node.js ended up the way it is.
16:08:55 <Eduard_Munteanu> data (∃) :: (k -> *) -> * where Ex :: f k -> (∃) f   -- works
16:08:56 <heatsink> You make it sound as if correctness isn't important most of the time, dcoutts_
16:09:00 <geekosaur> you need a blog post? I think there's a Knuth quote that summarizes it pretty well
16:09:14 <Hodapp> geekosaur: "Programming: You're doing it wrong." ?
16:09:20 <geekosaur> "beware, I have only proved this program correct, not tested it"
16:09:21 <dibblego> geekosaur: no, I need to find good explanations to help explain to others
16:09:22 <RichyB> hpc, it's also a performance technique; switching between cooperative threads may involve nothing more than popping a continuation off a list and jumping to it, pre-empting a thread takes interruption and saving+restoring register sets. Hence why really fast m:n thread implementations like GHC's are partly cooperative.
16:09:31 <geekosaur> or something like that
16:09:31 <dibblego> geekosaur: no, this was far more explanatory
16:09:36 <Peaker> dcoutts_: I have no idea what led to the way Node looks like, but when I use C, I prefer the callback style.  In C, at least, it's because I aim for optimal performance, and even user-level threads are often too expensive
16:09:45 <dcoutts_> heatsink: the money involved concentrates people's minds :-)
16:09:51 <heatsink> haha okay
16:09:59 <hpc> RichyB: that's more low-level than haskell
16:10:14 <Hodapp> dcoutts_: that's persuasive but I was hoping you had some actual case studies on hand!
16:10:21 <RichyB> For some kinds of applications (e.g. "thread-ring" on the computer languages benchmark), running on a single core without any costly locked instructions goes quicker than spreading across multiple cores.
16:10:23 <Peaker> dcoutts_: in a high-level language, user-level threads are probably best, whether they're cooperative (in a shared mutable state language), or preemptive (in a language like Haskell which doesn't share mutable state by default)
16:10:25 <Hodapp> like the famous Ericsson one
16:10:35 <dcoutts_> Peaker: well sure, OS threads in C are neither a great programming model, nor great performance
16:11:05 <Peaker> dcoutts_: even user/green threads in C aren't that great, if you want to be near the optimum
16:11:08 <RichyB> hpc, well yes, but it's also the underlying reason why GHC's threads start, stop and go like greased lightning whereas Python's threads make you want to put a fork in your eye as soon as you have more than about five of them.
16:11:22 <dcoutts_> Hodapp: it's really hard to get good evidence, there's a little bit of "proper" evidence out there about "high level" vs "low level" languages, and team size.
16:11:39 <Hodapp> RichyB: I think Python's threads do that when you get to about 2 of them and suddenly hit GIL :-/
16:12:17 <Hodapp> RichyB: But to be fair, Python has some 3rd-party support for things that are probably closer to green threads.
16:12:27 <RichyB> Hodapp, they suck harder when you get up to 20 and its bewildering task-switching algorithm starts sucking up user-visible quantities of time.
16:13:00 * Hodapp puts 4 angry lobsters at RichyB's feet, and tries to see if he can tell the difference between that and 20.
16:13:09 <danilo2> Hi! I've got a small fast question: can I make aliases to imports in Haskell? I mean - if Ive got "import qualified A.B.C" than I can use it like "print A.B.C.x" but I want to use it like "print B.C.x" (without the A on the beggining) - is it possible?
16:13:19 <Hodapp> dcoutts_: I went looking once for anyone who had tested the claim that object oriented programming was objectively a better way to write programs.
16:13:22 <hpc> Hodapp: 4 angry lobsters fit in a pot!
16:13:44 <RichyB> Hodapp, yes, uh, I think you've elucidated what I was aiming at there. In Python, there are libs like Twisted that do cooperative threading not because it's an easy programming model, but because Python is so bad at switching between different OS threads that cooperation comes out hugely better in benchmarks.
16:14:10 <heatsink> danilo2: import qualified A.B.C as Alphabet
16:14:13 <heatsink> Alphabet.x
16:14:42 <danilo2> heatsink: Ok, I know that :) I but I want to keep the dot in the name - I suppose it is not possible, but I could be wrong :)
16:14:44 <derekv> Hodapp: first you'd have to define object oriented programming
16:14:58 <heatsink> I've never tried it
16:15:02 <dcoutts_> Hodapp: aye, the lack of empirical evidence is rather sad. The problem is it is extremely expensive to get realistic data. Nobody wants to set multiple teams of equally good programmers on the same (non-trivial) task in different languages.
16:15:22 <Craig-UKC> The problem with concurrency is that you need to select if it's worth being concurrent - sometimes the overhead of setting it all up is literally not worth it. Occam-pi uses some seriously low overhead threading, but it does some sensible checks to make sure it doesn't thread like crazy
16:15:22 <RichyB> First thing you should do is go to http://neverworkintheory.org/ and see if they've found any study that covers it. :)
16:15:23 <Hodapp> dcoutts_: Les Hatton did a bit of this and found some results that were not too flattering for OOP (though he admitted that he could not cleanly separate his results from C++). I found one other study that was quite limited, and a little bit of math based on some models of how the brain operates with distinct things in memory and with error rates.
16:15:24 <hpc> dcoutts_: good luck finding two equally skilled programmers
16:15:27 <hpc> let alone a team of them
16:16:00 <derekv> Hodapp: I've had people cite to me that "Java was determined to be the least expensive for coperations to develop in".  I've always imagined that study being fairly sad/hillarious
16:16:03 <danilo2> heatsink: Oh it is possible! the code "import qualified A.B.C as B.C" works. I'm amazed :D thank you :)
16:16:04 <kvda> is Aeson encode known to be slow?
16:16:09 <dcoutts_> Hodapp: there is survey data from big projects, but it's very general. Just shows basically that high level is better than low level (that's the level of detail in language classification in that paper!)
16:16:19 <Hodapp> dcoutts_: The paper from Les Hatton (I believe) found an environment where they were able to test basically this. They had two very experienced teams writing an application of similar complexity.
16:16:20 <dcoutts_> Hodapp: at least, that's what I found.
16:16:32 <dcoutts_> hpc: quite
16:16:54 <Craig-UKC> What was the high level language that they tested it with?
16:17:19 <Craig-UKC> dcoutts_: ^
16:17:20 <RichyB> hpc, I think that you could more easily test a related question that is more interesting to businesses. Don't start with equally-skilled programmers; instead start out with equal budgets with which to hire programmers, and see which comes out more cost-effective. ;)
16:17:36 <hpc> RichyB: yeah, that's the much more relevant question
16:17:42 <Hodapp> dcoutts_: and it was similar in terms of LOC and bug rate, but there was a tremendous difference in the time that it took to correct bugs in the code. Particularly, the bugs in the procedural C version tended to be shallow and easier to fix, while the bugs in the C++ version tended to be much more deeply hidden and took many times longer to fix.
16:17:43 <hpc> even in academia you're beholden to budgets
16:17:47 <dcoutts_> Craig-UKC: iirc, they were IBM + a few other big organisations during the 80s + 90s, so were probably comparing assembler, COBOL, C, ADA etc
16:18:28 <Hodapp> dcoutts_: that sounds like what Mythical Man-Month references
16:18:32 <kvda> A long-winded way of saying what a lot of people know about C++ already
16:18:44 <Hodapp> kvda: a lot of people also "know" that C++ is superior :-/
16:19:18 <kvda> Those people are lost causes
16:19:29 <Hodapp> those people are my coworkers.
16:19:32 <Hodapp> this doesn't mean you are wrong.
16:20:01 <tarruda> why cant I use relative paths in cabal's 'extra-lib-dirs' option? When passing the relative directory as a linker option(-L) I get a warning because I should be using extra-lib-dirs, but it wont let me use relative paths
16:20:02 <dcoutts_> Hodapp: not getting a lower bug rate is certainly disappointing there. Being only left with the deep bugs might be ok, but if there's no fewer of them...
16:20:03 <Craig-UKC> A lot of code in the real world is buggy, and it's fine being buggy. Having no code earns you no money. I think you can create great code in Haskell, but it has facets of a lower-level language (in that the effort required to get something done is more than in say Java)... that doesn't mean the Java code will be *better* it just means you will have a working system quicker. Obviously overly generalizing... I would prefer bug free code, so Haskell is t
16:20:21 <chrisdotcode_> hey guys, I'm trying to build a yesod app, but something broke that wasn't broken literally a second ago:
16:20:21 <chrisdotcode_> Application.hs:18:8:
16:20:22 <chrisdotcode_>     Could not find module `System.Log.FastLogger'
16:20:22 <chrisdotcode_>     There are files missing in the `fast-logger-0.3.3' package,
16:20:25 <dcoutts_> tarruda: because it has to work when it's installed
16:20:31 <ReinH> Craig-UKC: why do you think it requires more effort to get things done than Java? That's precisely opposite to my experience.
16:20:46 <chrisdotcode_> this is definitely a cabal-dev issue, but I don't know what to do, fast-logger is already installed, it says
16:20:53 <Guest__________> http://lpaste.net/95880 why is there always this error message:  Cipher.lhs line 40: unlit: Program line next to comment
16:20:55 <Guest__________> ?!
16:20:55 <lambdabot> Maybe you meant: v @ ? .
16:21:04 <Hodapp> dcoutts_: the paper is "Does OO Sync With How We Think?" if you are interested.
16:21:35 <Hodapp> Craig-UKC: Try even convincing some people that it is possible for programs to not have bugs.
16:21:41 <dcoutts_> Hodapp: ta. I don't recall the one I was thinking of (which was probably obvious ;-), I found it for a talk some time ago)
16:21:42 <kvda> ReinH, i agree with Craig-UKC in general, I've been doing haskell for 6 months or so and it's still seems harder to get things done in Haskell
16:21:47 <tarruda> dcoutts_: Why wouldn't it work when its installed? The library is downloaded to a relative directory
16:22:01 <geekosaur> Guest__________, because you forgot the leading > on line 41
16:22:08 <Craig-UKC> ReinH: Over-generalizing - it might be the tasks you are attempting to solve are best suited to Haskell - so I can't really comment. It turns out the tasks I was attempting to solve are better conceptualized in Java.. not to mention the workforce easier to find for Java.
16:22:29 <dcoutts_> tarruda: a relative dir will be interpreted relative to where the program you're finally compiling is
16:22:33 <Guest__________> oh-.- thanks
16:22:49 <geekosaur> if you actually intended that then you need blank lines around the current line 41
16:22:50 <dcoutts_> tarruda: ie, think of some exe that depends on your lib, that lives in a totally different location on the system.
16:23:15 <dcoutts_> tarruda: anything relative to that location is useless. So cabal is just helping you to not shoot yourself in the foot.
16:23:35 <geekosaur> btw you also need them on lines 29, 30, 32, and 33 if those are not in fact documentation
16:23:44 <Craig-UKC> Testing *well* (and I mean properly well) OO code is a lot more ball ache. Haskell is a breeze.
16:23:54 <dcoutts_> tarruda: what you want is (a missing feature) to install an extra C lib along with the package
16:25:47 <Peaker> kvda, Craig-UKC: I repeatedly read that studies show that the number of LOC written per developer per time is relatively constant, no matter the PL used.  If that's true, then Haskell is far faster to develop in than Java
16:26:06 <Peaker> I don't know if that study is real, though, everybody tends to mention it though :)
16:26:22 <Craig-UKC> Peaker: yeah I've seen that
16:26:31 <quchen> Peaker: I think these claims all go back to a very small number of very obscure studies, handle them with care
16:26:36 <Craig-UKC> but in my anecdotal experience it has not
16:26:43 <Craig-UKC> [been the case]
16:26:49 <quchen> Peaker: They have a huge citation tree though, that's why they appear everywhere.
16:27:23 <Craig-UKC> I find it hard to trust something that I know for myself does not correlate well.
16:27:40 <Craig-UKC> I must admit LOC do more in Haskell :P
16:27:46 <Peaker> Craig-UKC: it took me a relatively long time to become quick with Haskell, as I am with other languages.
16:28:24 <Peaker> Craig-UKC: I've used Python for ~10 years, and Haskell for ~5, and I think I can whip up programs about the same speed in both.  (Python is faster for tiny file I/O programs, because it has a nicer/cleaner prelude for file operations, though)
16:29:05 <int-e> KaneTW:
16:29:22 <Peaker> Craig-UKC: the Haskell programs end up faster, and more reliable, for the same effort.  Going back to modify them later is much less daunting :)
16:29:41 <int-e> (sorry, finger error)
16:30:28 <Craig-UKC> Peaker: My testing in other languages has changed, I hate the way unit tests have been handled by people who do not know haskell
16:30:36 <Guest__________> http://lpaste.net/95871 always have an error if i try to run my test :\
16:30:41 <Guest__________> somebody an idea?
16:31:43 <heatsink> Guest___________, try this:  runhaskell <filename>
16:32:03 <[swift]> Craig-UKC: what are the mistakes you see in unit tests in other languages?
16:32:06 <heatsink> wait, I read your message wrong
16:32:13 <joelteon> :t \x -> fix (\f -> fmap ($ f) x)
16:32:15 <lambdabot> Functor f => f (f b -> b) -> f b
16:32:16 <Craig-UKC> [swift]: Testing non-pure code.
16:32:17 <joelteon> nice
16:32:20 <heatsink> Try telling us what the error is.
16:32:34 <joelteon> > (\x -> fix (\f -> fmap ($ f) x)) [const 1, succ . (!!0), succ . (!!1)]
16:32:35 <lambdabot>   [1,2,3]
16:32:47 <quchen> Löblöb
16:32:48 <Peaker> Craig-UKC: I've mostly stopped using Python (except when interacting with others who refuse to learn Haskell..).  I still use C, though, because Haskell performance is not nearly as good as the hype around it :P
16:33:36 * hackagebot language-ecmascript 0.15.3 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.15.3 (AndreyChudnov)
16:34:15 <[swift]> Craig-UKC: how do you avoid that in practice? that's something i'm doing right now. i've been advised that free monads are useful for substituting in another (pure) implementation of whatever IO operations you may be using, but i haven't tried it yet in practice
16:36:07 <Craig-UKC> [swift]: In Java I would use DI (Google Guice), that way you can mock all the rubbish. I did some stuff with closures to make monad-esque blocks of code for smaller tasks, that seperate the pure from impure.
16:36:24 <Craig-UKC> [swift]: In the end DI is the best way
16:37:09 <[swift]> Craig-UKC: heh, sorry, i meant in haskell =) it seems to me that you've got to be careful with your design even in haskell, or you end up testing non-pure code frequently
16:37:30 <Craig-UKC> [swift]: In Haskell you only need to test your pure functions! Generally anything that causes side effects is a library and you need to trust your libraries
16:38:49 <[swift]> Craig-UKC: ... not sure i get what you mean there. i frequently need to test code that does nontrivial stuff in IO - for example, it may be code that needs to synchronize with other threads, or code that interacts with the database or filesystem
16:40:24 <[swift]> Craig-UKC: have you found ways to structure your applications such that no nontrivial functionality lives in IO? that has so far escaped me =\
16:40:43 <Craig-UKC> [swift]: Well I guess it depends if those monads are of your own creation.
16:43:10 <joelteon> @pl moeb f x = fix (\g -> f ($ g) x)
16:43:10 <lambdabot> moeb = (fix .) . flip . (. flip id)
16:43:54 <acowley> joelteon: *now* it makes sense!
16:43:55 <ReinH> joelteon: that'll do
16:44:12 <hamishmack> What is the process for getting access to upload candidate packages to hackage?
16:44:43 <hamishmack> I would like to upload new Gtk2Hs packages but I get "Not authorized to upload a candidate for this package"
16:44:52 <scott_> hamishmack: http://hackage.haskell.org/accounts
16:45:00 <scott_> Email admin@hackage.haskell.org
16:45:25 <ReinH> Craig-UKC: I don't understand why you wouldn't want to test non-pure code.
16:45:25 <scott_> Or do candidate packages require something else?
16:45:29 <hamishmack> I have an account (HamishMackenzie)
16:45:38 <ReinH> Ultimately, they are the ones that do actual work
16:45:43 <ReinH> And they deserve to be tested
16:45:58 <hamishmack> It seems like I might need to be in a group of some sort
16:47:03 <joelteon> "dude, it's just (fix .) . flip . (. flip id)"
16:48:13 <FireFly> @unpl (f .) . flip . (. g)
16:48:13 <lambdabot> (\ j p -> f (\ d -> j (g d) p))
16:49:27 <Craig-UKC> ReinH: My experience is that the heavy lifting is in data manipulation, so fetching is trivial and storing/outputting is trivial. Maybe my pool of examples is too small.  You need to test your own monads, but generally people use library monads. If you do notation works, then *usually* it's correct.
16:50:39 <quchen> joelteon: I'm pretty sure looking at the definition isn't the right way to understand moeb :-)
16:51:10 <jle`> does anyone know any toy examples of free monads being used for practical purposes?
16:51:30 <quchen> jle`: Sure. Pipes is based on free monads for example.
16:52:28 <ion> jle: Certain kinds of DSLs in general.
16:52:40 <quchen> jle`: Then there's the canonical example of a simple interpreter. My toy Brainfuck interpreter builds up a program that's a free monad of input/output actions. That way it can easily be run with stdin/stdout, or already known input data, or output to Text etc.
16:52:56 <jle`> quchen: hm. should i dig into the source code then?  i was more asking about toy/contrived examples where you see how it would be done without free monads, and then how it would be done with
16:53:13 <jle`> quchen: that's cute :) do you have a link?
16:53:56 <quchen> jle`: It hasn't received much love, and the code isn't really about free Monads. But here you go: https://github.com/quchen/brainfuch/tree/master/src
16:54:15 <quchen> It was basically just me sitting around thinking "let's do something with zippers" and that's the result ;-)
16:54:40 <jle`> quchen: thanks, i'll look into it :)
16:54:45 <jle`> i skipped the zippers chapter in lyah anyway.
16:55:17 <quchen> Zippers are really easy to understand, the chapter should be a breeze if you've learned enough to ask about free monads :-)
16:55:50 <[swift]> Craig-UKC: i think it probably depends on the type of application you're writing. i tend to write a lot of explicitly multithreaded stuff, for example
16:56:13 <quchen> jle`: The free monad stuff is pretty much all in Types.hs at the bottom
16:56:23 <jle`> thanks :)
16:57:13 <quchen> jle`: The best way to start with free monads is probably watching Löh's talk though
16:57:25 <quchen> http://skillsmatter.com/podcast/scala/monads-for-free
16:58:38 * hackagebot haxy 0.9 - A simple HTTP proxy server library  http://hackage.haskell.org/package/haxy-0.9 (AndreyChudnov)
17:01:18 <ion> Why does it say “LöH” in the video?
17:01:36 <quchen> That's the speaker's name.
17:01:41 <quchen> Oh, the "H".
17:01:47 <quchen> That's a typo I would guess.
17:02:06 <ion> Repeated in the video title.
17:02:43 <quchen> Maybe because they didn't find the capital ö
17:03:27 <quchen> There' no lower case "H" character in German, so I am pretty sure it's a mistake. :-)
17:03:38 <ion> > (text . pure . toUpper) 'ö'
17:03:39 <lambdabot>   Ö
17:04:09 <hpc> quchen: DeutcH ist so HasslicH
17:04:20 <quchen> HässlicH
17:04:34 <hpc> i don't have the german keyboard installed
17:04:45 <ion> compose
17:04:50 <hpc> EN-US
17:04:53 <quchen> I have a German keyboard installed. Literally.
17:04:53 <ion> compose
17:05:54 <FireFly> us-international?
17:09:15 <tarruda> Can I use
17:09:23 <tarruda> 'make' to build cabal packages?
17:09:37 <tarruda> and use cabal for installing and distributing
17:09:45 <quchen> "cabal build"
17:09:52 <quchen> That's the cabal equivalent for "make".
17:10:46 <tarruda> yes but how can I add a makefile with custom build scripts, and tell cabal to invoke it when building the package?
17:11:34 <tarruda> I mean, if someone installs the package via cabal
17:11:55 <lvella> mm_freak_: are you there? http://lpaste.net/95883
17:13:17 <lvella> I am still waiting for the liftIO explanation
17:13:38 <countoren> hello
17:15:40 <countoren> im thinking of building a website that will need heavy use of paypal transaction , do u guys thinks its good idea to go with haskell? is there is enough support in haskell for that?
17:16:27 <hpc> countoren: as someone who has dealt with paypal before, your biggest obstacle is paypal itself
17:16:54 <hpc> you'll spend all day googling for some obscure reference on a hairy aspect of IPN, find a link on paypal.com
17:17:04 <hpc> it links to a pdf on paypalobjects.com
17:17:23 <hpc> the pdf says "this document has moved" and a plaintext url for "x.com"
17:17:43 <hpc> you follow that link and the document is still wrong on the exact thing you needed to begin with
17:17:43 <countoren> hpc: if i want to pass money from 2 accounts in paypal?
17:18:22 <hpc> countoren: i would say, go ahead and do it in haskell; there's not going to be library support, but when is there ever when money is involved
17:18:34 <hpc> you have all the tools to do it yourself
17:18:40 * hackagebot http-encodings 0.9 - A library for encoding and decoding bodies of HTTP messages  http://hackage.haskell.org/package/http-encodings-0.9 (AndreyChudnov)
17:18:42 <hpc> and you can put it on hackage for mad internet points
17:19:01 <countoren> and if ill go with ruby?
17:19:08 <hpc> good luck
17:19:20 <countoren> i will have more support or it will be the same?
17:19:20 <hpc> either language, you'll need it ;)
17:20:13 <hpc> i don't know much ruby
17:20:40 <countoren> c#?
17:20:42 <hpc> but both languages do well with http, which is what paypal's api runs on
17:20:44 <countoren> .net?
17:20:58 <hpc> you should look at the paypal docs and get a feel for what you are up against
17:21:42 <hpc> and if you find a language with an open paypal api that's easy to use, buy a lottery ticket for me ;)
17:21:57 <countoren> if it so complicated i prefer to chose the one that will have the best support
17:23:06 <hpc> countoren: if you look at the paypal api, you'll see it's not a language thing, it's a library thing
17:25:16 <countoren> yes i want the best lib to work with it
17:33:41 * hackagebot haxy 0.9.1 - A simple HTTP proxy server library  http://hackage.haskell.org/package/haxy-0.9.1 (AndreyChudnov)
17:38:42 * hackagebot http-encodings 0.9.1 - A library for encoding and decoding bodies of HTTP messages  http://hackage.haskell.org/package/http-encodings-0.9.1 (AndreyChudnov)
17:46:20 <Fuuzetsu> Lens: Given my own structure ‘p’ with a field _someBool and made into a Lens with makeLenses, I can flip the value of ‘someBool’ with ‘over someBool not p’. Is there a shorter way?
17:46:37 <Fuuzetsu> Now that I look at it, I'm asking for an infix version of ‘over’ I think.
17:48:36 <acowley> p %~ not
17:48:41 <acowley> err
17:48:43 * hackagebot jespresso 0.9 - Extract all JavaScript from an HTML page and consolidate it in one script.  http://hackage.haskell.org/package/jespresso-0.9 (AndreyChudnov)
17:48:43 <acowley> sorry
17:48:48 <acowley> someBool %~ not
17:49:02 <acowley> and if 'p' is the value, then p & someBool %~ not
17:49:44 <chrisdone> acowley: what's the english word for %~?
17:49:51 <acowley> "mod"
17:50:08 <chrisdone> k
17:50:37 <Fuuzetsu> acowley: Looks like that's what I wanted, thanks.
17:50:54 <acowley> It's a bit of a neologism that plays upon "modulo" and "modify" afaik
17:51:50 <chrisdone> :t mood
17:51:52 <lambdabot>     Not in scope: `mood'
17:51:52 <lambdabot>     Perhaps you meant one of these:
17:51:52 <lambdabot>       `mod' (imported from Prelude), `moo' (line 140)
17:51:53 <chrisdone> :t mod
17:51:54 <lambdabot> Integral a => a -> a -> a
17:52:13 <chrisdone> i meant the lens word for %~
17:52:20 <chrisdone> @hoogle (%~)
17:52:21 <lambdabot> No results found
17:52:25 <chrisdone> what is that thing
17:52:37 <chrisdone> looks like something from Alien
17:53:09 <chrisdone> \o\ "Ahhh!!"        %~  "SCREEECH"
17:54:10 <Fuuzetsu> Isn't that everything in lens?
17:54:24 <bz> attoparsec vs. scanf
17:54:31 <acowley> Oh, in lens, it's just "over" as Fuuzetsu said
17:54:32 <Fuuzetsu> Just make sure to never ever speak about it with anyone.
17:54:45 <chrisdone> acowley: ahhh
17:55:15 <chrisdone> Luke ma boi!
17:55:16 <acowley> But I find reading it that way a bit tricky as you have to read it right-to-left
17:55:26 <Luke> chrisdone: updates?
17:55:49 <acowley> I have never succeeded in explaining lens to non-Haskellers
17:55:55 <acowley> which actually worries me a bit
17:56:12 <geekosaur> oops
17:56:14 --- mode: geekosaur set -o geekosaur
17:56:26 <geekosaur> forgot about that :)
17:56:34 <acowley> So often it gets summarized as, "So it makes Haskell work more like most other languages?"
17:56:53 <acowley> geekosaur: I thought you were doing that to accommodate the person who was prefixing everyone's nick with @ the other day
17:57:18 <geekosaur> neh, there was a spambot watching activity in here and PMing people earlier
17:57:19 <chrisdone> luke: yep, a couple! adding little bits of improvement each day
17:57:21 <Luke> acowley: C has the same problem: scructs of structs of structs. How do you generically access a certain field arbitrarily deep?
17:57:29 <geekosaur> forgot to deop after giving it its quietus
17:57:36 <sclv> better to say the "lens" library is really about generic traversals?
17:57:40 <sclv> instead of getters and seters?
17:57:47 <acowley> Luke: .
17:57:49 <roconnor> Luke: um, a.b.c.d?
17:58:09 <Luke> yeah... for haskell
17:58:12 <geekosaur> #define u_foo u_a.ua_b.uab_foo
17:58:13 <Luke> that's my point
17:58:19 <geekosaur> (iiiiick)
17:58:23 <chrisdone> luke: i just had the urge to say 'ma boi' (https://encyclopediadramatica.es/LINK_MAH_BOIIIII )
17:58:31 <Luke> ah =)
17:58:46 <acowley> sclv:  "generic traversals" doesn't seem like it will add clarity
17:59:08 <acowley> Luke: But the point is that C doesn't have the same problem
17:59:09 <roconnor> composable iterators?
17:59:11 <sclv> well explain what a traversal is first!
17:59:14 <acowley> hah
17:59:15 <sclv> roconnor: oh thats nice
17:59:27 <chrisdone> acowley: it doesn't?
17:59:33 <Luke> acowley: i'm just saying you can use that concept to explain it to non haskellers
17:59:38 <acowley> chrisdone: Update in place!
17:59:42 <roconnor> a traversal is Haskell's version of an iterator.
17:59:54 <sclv> right, "essence of the iterator pattern" and all
17:59:54 <chrisdone> acowley: yeah, update is the essential innovation of lenses
18:00:07 <roconnor> Not exactly the same thing, but serves more or less the same purpose.
18:00:17 <Luke> roconnor: agreed
18:00:18 <sclv> "i have an iterator of things that have iterators and i want to iterate over the subiterators to give a new structure with the same shape as the old"
18:00:21 <acowley> The utility of these common lens features presupposes that you've accepted pure FP into your heart
18:00:23 <Luke> enough to explain lenses at least
18:00:26 <sclv> "and i want the new thing to _also_ be an iterator"
18:00:37 <sclv> "and i want to have code that lets me do this easily, once and for all"
18:00:49 <chrisdone> sclv: for (yo_dawg i_herd_you_like; …) { … }
18:03:50 <lvella> I am still waiting for the liftIO explanation
18:04:11 <sclv> wat the question is?
18:04:22 * sclv missed it
18:04:26 * acowley too
18:04:27 <Peaker> lvella: do you understand:  lift :: m a -> t m a ?
18:04:35 <hpc> lvella: liftIO takes an IO action and lifts it into another action
18:05:23 <hpc> lvella: so for instance, xmonad has a monad X, which will do IO when you run it
18:05:48 <hpc> lvella: if you want a button that reads a file and puts it on your status bar, it's something like
18:06:16 <hpc> event KeySemiColon (liftIO $ do {x <- readFile; statusbar x})
18:06:27 <hpc> where event :: Key -> X () -> X ()
18:06:56 <hpc> lvella: for monad transformers, liftIO = lift
18:07:12 <hpc> but i wanted to give an example outside of transformers so you can see why liftIO is separate
18:07:26 <Fuuzetsu> how would I combine ‘let bar = foo & f ~. x; let baz = bar & g ~. x’ into a single expression?
18:08:00 <Fuuzetsu> Oh, I got it. Just chain with &
18:08:42 <Peaker> Fuuzetsu: and there's also <&> and >>= with same fixity as &  (all infixl 1), which means you can chain all 3 operators
18:08:57 <Fuuzetsu> :t (<&>)
18:08:58 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:09:32 <Peaker> e.g:   foo <&> f .~ x   >>= g %%~ action    & lift
18:09:59 <Fuuzetsu> :t (%%~)
18:10:00 <lambdabot> Overloading p q f s t a b -> p a (f b) -> q s (f t)
18:10:08 <Fuuzetsu> damn these types
18:10:10 <Peaker> Fuuzetsu: %%~ applies an effectful action to a field
18:10:17 <Peaker> Fuuzetsu: where %~ applies a pure function to a field
18:10:29 <Peaker> so %~ lets you apply (a->b) on a field "a" to make it a field "b"
18:10:45 <Peaker> %%~ lets you apply (a->f b) on "a" to make it a "b" (obviously the whole result is in "f")
18:11:01 <Peaker> basically (%%~) is "id", because that's how lens/traversals are defined internally
18:11:07 <acowley> Lens l m a o
18:11:26 <Peaker> Lens i m a s t a b u
18:11:30 <roconnor> Fuuzetsu: foo & (f .~ x) . (g .~ x) also works but don't quite look as nice IMHO.
18:11:45 <Peaker> anyway, about chaining: (& applies pure function, <&> applies pure function within Functor,  >>= applies effectful function)
18:14:32 <Fuuzetsu> Well, at the moment I have ‘foo & f .~ x & g .~ y’, I don't think you can go simpler or shorter
18:14:40 <basichash> Is there a deb package for haskell?
18:15:11 <joelteon> anyone familiar with the bcrypt package?
18:15:19 <geekosaur> basichash, generally you want haskell-platform
18:15:28 <basichash> cheers
18:15:40 <geekosaur> if you are on ubuntu, they broke it and then removed it from their repo :/ may be able to get it from debian unstable
18:15:43 <dwcook> Does Debian still have that package? I know it's disappeared on Mint
18:15:52 <geekosaur> mint is ubuntu based
18:15:57 <geekosaur> so my previous comment applies
18:15:58 <joelteon> hashPasswordUsingPolicy slowerBcryptHashingPolicy "anything" is giving me Nothing
18:16:00 <dwcook> Yeah, I wrote that before I saw your message
18:16:04 <joelteon> I don't think it should
18:16:16 <basichash> the package is on ubuntu, but you're saying it's broken?
18:16:22 <dwcook> I ended up installing the ghc and cabal-install packages.
18:16:52 <dwcook> The platform also includes certain Haskell packages that can be obtained through cabal.
18:18:21 <geekosaur> however you may need to watch out for versions; the Platform is a collection of known good versions that work together
18:18:29 <basichash> How do I access the haskell REPL?
18:18:32 <geekosaur> installing stuff manually may get you mismatched versions
18:18:34 <geekosaur> ghci
18:18:35 <joelteon> ghci
18:18:54 <basichash> thanks
18:19:10 <sclv> if you can't get platform directly from the package manager, i recommend downloading the tarball and installing it manually
18:19:35 <sclv> over a ghc you got from the package manager. making sure the platform is compat with the ghc version.
18:19:43 <basichash> seemed to work fine from ubuntu (haskell-platform)
18:20:50 <basichash> Kind of new to functional languages, what are they?
18:22:45 <Fuuzetsu> They are… languages that use and support the functional programming paradigm ;P
18:23:28 <basichash> can't imperative do everything functional can though?
18:23:52 <tromp__> yes, it can, just in a more dysfunctional way
18:24:22 <basichash> haha clever
18:24:32 <tromp__> you can interpret a pure functional language in less than a kilobyte of C
18:24:44 <geekosaur> there is Turing equivalence (languages can do the same thing) and there is expressiveness (how easy is it to do?)
18:25:09 <basichash> so functional languages are more expressive?
18:25:15 <geekosaur> (granting that definitions of "easy" differ :)
18:25:42 <geekosaur> they can be, yes. once one is familiar with them at least
18:26:19 <geekosaur> likewise C is as capable as <insert object oriented language here> but OO in pure C is deeply painful and sometimes the non-OO solution isn't much better
18:26:57 <basichash> I played around with Lisp a while back, and that that (just like haskell) seems really strange, coming from an imperative background
18:27:02 <osa1> what does being "parallel" and "incremental" mean for monoids?
18:27:14 <geekosaur> (granted that C, which was designed to be a low level language, is going to be painful for high level programming anyway)
18:27:15 <Peaker> geekosaur: The silly parts of OO (implementation inheritance) is painful.  The nice parts (records of functions) are only slightly painful (not more painful than C++, IMO)
18:27:30 <zRecursive> pkg search haskell => haskell-mode-2.9.1 hs-haskell-platform-2013.2.0.0_1 hs-haskell-src-1.0.1.5_5 hs-haskell-src-exts-1.13.5_3,  then how should i install ghc on FreeBSD 9.1 ?
18:27:45 <geekosaur> hs-haskell-platform
18:27:52 <Peaker> osa1: I am guessing that "parallel" refers to the fact Monoids are associative, so you can destructure a sequence of mappends into arbitrary subsequences and parallelize them
18:28:02 <osa1> makes sense
18:28:22 <zRecursive> geekosaur: thx, it is a big change converting to `pkg`
18:28:27 <geekosaur> haskell-mode is for emacs; haskell-src and haskell-src-exts are Haskell parsers (standard and GHC extensions, respectively)
18:28:47 <osa1> and what about "incremental" part ?
18:29:48 <basichash> should I have access to the sort function?
18:30:06 <geekosaur> @index sort
18:30:06 <lambdabot> Data.List
18:31:18 <jtcwang> any vim users here? what plugins do you guys use related to haskell?
18:31:22 <basichash> @index fst
18:31:22 <lambdabot> Data.Tuple, Prelude
18:31:49 <scott_> jtcwang: I just set up vim for Haskell a few days ago. I'm using hdevtools and syntastic (among others, but those are important to Haskell)
18:32:08 <scott_> I'm looking at some others to make indentation work better but I haven't tried them yet
18:32:20 <geekosaur> the contents of the Prelude are largely governed by the Haskell Report; some things are off in their own modules instead of the Prelude
18:32:59 <basichash> oh ok
18:33:06 <tarruda> @src Maybe (<-)
18:33:07 <lambdabot> Source not found. stty: unknown mode: doofus
18:33:16 <tarruda> @src (<-) Maybe
18:33:16 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:33:18 <geekosaur> <- is syntax
18:33:24 <geekosaur> it does not have source
18:33:27 <tarruda> hmmm
18:33:43 <tarruda> but it does have a per-monad behavior right?
18:33:47 <geekosaur> yes and no
18:33:58 <tarruda> ?
18:33:59 <geekosaur> it has a standard translation, which involves a monad-specific operator
18:34:09 <tarruda> which is?
18:34:16 <geekosaur> x <- expression       becomes     expression >>= \x ->
18:34:45 <geekosaur> (note that this is incomplete syntax; you must follow a x <- expr with something else that presumably uses x)
18:34:45 <tarruda> what happens with:
18:34:53 <tarruda> x <- expr1
18:34:58 <tarruda> y <- expr2
18:35:00 <jtcwang> l
18:35:04 <tarruda> return (x + y)
18:35:17 <geekosaur> @undo do { x <- e1; y <- e2; return (x + y) }
18:35:17 <lambdabot> e1 >>= \ x -> e2 >>= \ y -> return (x + y)
18:35:52 <tarruda> nice
18:35:57 <geekosaur> @src Maybe (>>=)
18:35:57 <lambdabot> (Just x) >>= k      = k x
18:35:57 <lambdabot> Nothing  >>= _      = Nothing
18:36:15 <tarruda> ok that I saw on wikipedia
18:36:18 <tarruda> what about ->
18:36:24 <geekosaur> also syntax
18:36:37 <zardoz``> how would one compare two objects IORef's point to?  == compares references
18:36:43 <geekosaur> \patterns -> expr
18:36:53 <geekosaur> defines a "lambda", or anonymous function
18:37:36 <geekosaur> zardoz``: do { x <- readIORef a; y <- readIORef b; return (x == y) } -- or similar, or the >>= version
18:37:39 <zardoz``> does haskell has a concept of value and reference types, like java?
18:37:46 <geekosaur> nope
18:37:55 <tarruda> so the 'undo' show above, is it creating a lambda function that receives a tuple(x,y) as argument?
18:38:07 <zardoz``> geekosaur what is IORef, if not a reference type?
18:38:18 <geekosaur> it's just a type. it's not a special type
18:38:21 <Peaker> Java "value types" are the unboxed primitives? Or something else?
18:38:41 <geekosaur> keep in mind that evena numeric literal is actually a function call
18:39:08 <geekosaur> tarruda, it creates two separate lambdas, as shown by the expansion
18:39:19 <geekosaur> the translation is entirely mechanical
18:39:40 <zardoz``> I am mainly talking about equality aspect of java's reference/value types.  with value types == compares values, with reference types it compares refernces (or values too, if you consider a value of a refernece type the reference itself, rather than the object it points to)
18:39:53 <Peaker> "function call" is an operational term, better to say "function application" (which will probably get translated to no actual function calls at all)
18:40:03 <geekosaur> zardoz``, you might want to look at the concept of referential integrity
18:40:15 <zardoz``> so I see some parallels in here, in that == compares whether ref1 and ref2 are the same reference, rather than if the objects they refer to are the same
18:40:26 <geekosaur> Java is exposing what in Haksell would be termed an implementation detail that shouldbe invisible to both program and programmer
18:40:40 <Peaker> zardoz``: under this view -- IORef is a reference type (== compares identity), and almost all types are value types.
18:41:00 <zardoz``> Peaker which other one isn't?
18:41:03 <Peaker> what's referential integrity?
18:42:11 <geekosaur> the idea that if you have a binding such as `a = b + c`, there is exactly zero difference between `a` and `b + c`
18:42:12 <Peaker> zardoz``: Haskell values are immutable and comparing them compares their values. The "value" of an IORef happens to be the "location" or "identity"
18:42:22 <Peaker> geekosaur: you mean "referential transparency", I think
18:42:40 <geekosaur> bleh. yes, I think I was sort of brainfarting there
18:42:51 <geekosaur> (who set my mind back 10 years? r.i. is database foo)
18:43:00 <geekosaur> (which I haven't done since, er, 1996)
18:43:22 <geekosaur> referential transparency
18:43:56 <zardoz``> Peaker yeah, so I see parallels with java's reference/value types. I can't really pintpoint what's different, or how == is leaking implementation detail in java but not in haskell
18:45:00 <geekosaur> because the only kind of "reference" in Haskell is artificial (IORef and STRef and similar, which are provided by their respective monads and not actually part of the language /per se/)
18:45:15 <zardoz``> Peaker what other types behave like IORef in this regard? some similar types that refer to some object?
18:45:19 <Peaker> zardoz``: It's not leaking an implementation detail -- it's having an "object identity" for everything in Java, and not in Haskell
18:45:29 <geekosaur> you might say that those are extension libraries, whereas in Java or Python etc. the distinction is baked into the language itself
18:45:34 <Peaker> zardoz``: perhaps MVars have ==? basically types that are much like IORef
18:46:19 <zardoz``> geekosaur yeah that is true
18:47:14 <geekosaur> if you wanted to, you could provide your own kind of "reference types" (and there are modules that do so; for example, several interfaces to mmap() on Hackage)
18:48:56 <geekosaur> but at the same time, there's not a distinction in language between, say, (readIORef foo) and (myArray ! foo). (indeed, in ST you can use a mutable array for the latter, so it's even less different!)
18:49:38 <zardoz``> how isn't there?  the latter will always return the same value
18:50:11 <geekosaur> did you notice the parenthetical at all, or just ignore it?
18:50:19 <zardoz``> I did not read it :)
18:50:22 <zardoz``> sorry
18:50:26 <udevd> aw yiss i finally coded up LU decomposition
18:50:27 <udevd> :3
18:50:49 <zardoz``> what does myArray1 == myArray2 compare?
18:51:09 <zardoz``> value of myArray as well (the reference)?
18:51:23 <geekosaur> Haskell doesn't like mutable values, so you need to hide them in ST, but you can do that and program like you might in another language with mutable variables
18:51:36 <geekosaur> hm, not sure how (or even if) (==) is defined for Array
18:52:17 <geekosaur> looks like it's value comparison
18:52:26 <geekosaur> (Ix i, Eq e) => Eq (Array i e)
18:53:06 <zardoz``> not consistent with IORef :|
18:53:32 <geekosaur> I admit to being a little surprised that there is an Eq instance for IORef.
18:53:54 <geekosaur> but, (==) is pure so it is not allowed to look inside the IORef to do a value comparison
18:54:16 <zardoz``> Array is pure?
18:54:34 <zardoz``> is it mutable?
18:54:36 <geekosaur> no
18:54:43 <zardoz``> oh well then == makes sense
18:54:44 <geekosaur> hence my comments about ST earlier
18:54:55 <geekosaur> there is an STArray which is mutable but can only be used within ST
18:55:06 <geekosaur> there is likewise an IOArray which is mutable but can only be used in IO
18:55:09 <zardoz``> I'd have issue if == compared value for mutable array, but you are right that is not even possible
18:55:30 <zardoz``> since return value would be wrapped in IO
18:58:02 <frxx> I think it makes sense to implement Eq for IORef, value is the reference itself
18:58:44 <geekosaur> at one point no such implementation existed. I suspect this made things difficult for e.g. the gtk2hs folks though
19:06:57 <Fuuzetsu> I have an IORef I pass around and change the state of (using GLUT, I wish I could do without) and I have a lot of expressions that look like ‘get ps >>= \p -> ps $=! (p & someStuff)’. Is there a way to shorten this with the use of lens?
19:10:41 <stolaruk> I just realized that I can replace most of the (>>)s in my code with (*>). Should I prefer (*>) to (>>)?
19:11:56 <Clint> stolaruk: are you dealing with Monads or Applicatives?
19:12:13 <stolaruk> Well I'm in a monad transformer stack
19:12:26 <stolaruk> StateT WorldState IO ()
19:12:45 <stolaruk> But IO is an Applicative as I understand
19:13:16 <Clint> IO is many things to many people
19:14:48 <Fuuzetsu> stolaruk: Whichever one you like. If the code around is in Applicative style, use (*>). If not, don't.
19:15:31 <stolaruk> Fuuzetsu: Ok, that sounds good. Thakns.
19:54:44 <jonplussed> is it possible to have ghci display thunk evaluation like shown in http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl' ?
20:01:11 <carter> tomejaguar: someone said my name? I have to look in the scrollback to figure it out
20:04:16 <geekosaur> jonplussed, not directly. you might look at hood / ghood though
20:04:38 <jonplussed> geekosaur: thanks! just found ghc-vis, too, which looks promising
20:04:43 <geekosaur> (or there might be newer things, I forget)
20:07:29 <bobcrasher> Anyone interested in a type error I'm having no luck figuring out?
20:07:30 <bobcrasher> http://pastebin.com/DYyzeyBR
20:07:31 <mauke> The paste DYyzeyBR has been copied to http://lpaste.net/95886
20:08:06 <geekosaur> you should also include the full error
20:08:13 <bobcrasher> sure, one sec!
20:08:38 <bobcrasher> That is the error: http://pastebin.com/RNVSfu05
20:08:39 <mauke> The paste RNVSfu05 has been copied to http://lpaste.net/95887
20:09:20 <bobcrasher> I'm trying to create a function, which given a function to find a device, tries over and over, until it eventually finds it and moves onto "tryOpenDevice"
20:10:00 <bobcrasher> But it's not liking my type annotation on line 22, can't reconcile that "Maybe deviceInfo" with the annotation on line 20
20:10:10 <geekosaur> yes
20:10:21 <geekosaur> the scope of the one on line 20 is... line 20 only
20:10:41 <bobcrasher> Ah, I thought that "ScopedTypeVariables" would help with that
20:10:51 <geekosaur> it does, but needs some extra information
20:11:00 <geekosaur> you need an explicit forall on the type variables to be kept in scope
20:11:21 <geekosaur> since it's usually wrong to keep *all* type vars in scope
20:12:06 <geekosaur> so: tryFindDevice :: forall deviceInfo. (IO (Maybe deviceInfo)) -> (IO deviceInfo -> IO deviceHandle) -> (IO deviceHandle -> IO RawChannels) -> IO ()
20:12:30 <geekosaur> and then deviceInfo (only) will remain in scope through the definition and not just the declaration
20:13:35 <geekosaur> (the forall is otherwise redundant as all type variables are implicitly top-level `forall` for all purposes other than keeping them scope in the definition)
20:13:39 <bobcrasher> huh interesting.  I'll have to read more about forall, I've only briefly seen it
20:14:22 <geekosaur> it's basically just reusing syntax that ghc was already stealing, rather than inventing yet another keyword
20:14:48 <geekosaur> other uses of forall aren't particularly relevant to this specific usage
20:15:18 <bobcrasher> So now I'm getting "Not in scope: type variable deviceInfo."  What I'm attempting is that "deviceInfo" could literally be anything, because this function I'm writing only passes it between the functions that get passed in
20:15:26 <bobcrasher> Do I need to make it more structured than that?
20:15:43 <geekosaur> (it is also, somewhat ironically, "backwards" form the usual meaning)
20:15:45 <geekosaur> hm
20:15:56 <monochrom> please don't say "anything". please say who gets to choose.
20:16:15 <geekosaur> ^
20:16:45 <monochrom> "user chooses" and "provider chooses" are antitheses to each other. both are said to be "anything".
20:16:54 <bobcrasher> Or sorry, it says "Not in scope: type variable deviceHandle"
20:17:04 <bobcrasher> with tryFindDevice :: forall deviceInfo. (IO (Maybe deviceInfo)) -> (IO deviceInfo -> IO deviceHandle) -> (IO deviceHandle -> IO RawChannels) -> IO ()
20:17:17 <bobcrasher> Ok, so the user (call of my function) chooses what deviceInfo is
20:17:24 <monochrom> yes
20:17:53 <geekosaur> ...but this means you don't know anything about it
20:17:57 <bobcrasher> So placing the "deviceHandle" into the forall made the file build
20:18:06 <bobcrasher> tryFindDevice :: forall deviceInfo deviceHandle. (IO (Maybe deviceInfo)) -> (IO deviceInfo -> IO deviceHandle) -> (IO deviceHandle -> IO RawChannels) -> IO ()
20:18:10 <bobcrasher> but I feel like that was a shot in the dark
20:19:52 <bobcrasher> So basically, I want them to give me a function which returns "IO a", another one which does "IO a -> IO b" and then my function facilitate calling the second function with the return value of the first one.  I don't actually need to manipulate the "a" other than to pass it.
20:20:35 <monochrom> why is the second one "IO a -> IO b" not "a -> IO b"?
20:21:40 <bobcrasher> monochrom:  Thinking that one through.  Despite this building, that might be overly convoluted
20:21:57 <monochrom> and why is the whole thing not simply: simple :: IO a -> (IO a -> IO b) -> IO b; simple x y = y x
20:23:56 <bobcrasher> So basically the (IO a) function can throw an exception, (IO a -> IO b) can throw an exception, and my wrapper function is managing the retry logic
20:24:16 <geekosaur> a -> IO b can also throw an exception
20:24:27 <geekosaur> it's the IO a -> IO b that makes very little sense
20:24:33 <bobcrasher> Yeah, I'm fixing that right now
20:24:45 <bobcrasher> Its a very good point, no need for the IO a -> IO b
20:25:15 <geekosaur> (in general the only reason to have an IO something on the left of a function arrow is when it's a callback of some kind)
20:25:52 <bitemyapp> geekosaur: what does that mean anyway? that the "real world" is changing around the function?
20:26:09 <bobcrasher> hmm wow
20:26:35 <geekosaur> that you want to evaluate an IO action in some context, rather than get the result of a previous evaluation
20:27:19 <geekosaur> an example might be a GUI callback (see gtk2hs or wxhaskell), or a function which does some kind of resource allocation and deallocation on behalf of a user-upplied action
20:27:32 <geekosaur> :t bracket
20:27:35 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:27:58 <bobcrasher> woah, sweet
20:28:05 <geekosaur> so for bracket we have an action, a resource allocator, and a resource deallocator
20:28:21 <geekosaur> and bracket makes sure the deallocator is run even if there's an exception in the provided IO action
20:28:30 <geekosaur> (and then rethrows the exception)
20:28:31 <bobcrasher> Yup, funilly enough just ran across that the other day
20:28:41 <bobcrasher> Stupid me chose a project to learn haskell that involves too much IO
20:30:14 <geekosaur> actually the order there is: allocator, deallocator, user provided IO action
20:30:58 <geekosaur> most common usage is allocator = open a file, deallocator = close it, user action = do something with the file data; even if an exception is thrown, the file will be closed
20:31:17 <geekosaur> instead of leaking a filehandle until the next major garbage collection
20:36:57 <zardoz--> hello
20:40:59 <chemuduguntar> hi all
20:41:14 <danharaj> :q
20:41:16 <danharaj> oops
20:41:49 <chemuduguntar> is it possible to parametric types in haskell and then specify rules on operators that can query them?
20:42:50 <tangentstorm> i think you a verb there, chemuduguntar... but can you give an example?
20:42:55 <chemuduguntar> create* :)
20:43:30 <chemuduguntar> tangentstorm: for e.g. a matrix has size a x b ... to multiply it with another matrix c x d - b must be equal to c
20:43:41 <chemuduguntar> and the result is a matrix of size a x d
20:43:45 <carter> you could do that
20:43:48 <chemuduguntar> (i hope my matrix math is correc here)
20:43:53 <carter> but  itd be a pain
20:43:56 <carter> :)
20:44:19 <carter> chemuduguntar: you can express type level ocmputations using type famllies
20:44:21 <carter> BUT
20:44:28 <carter> you can't quite prove thigns nicely
20:44:36 <carter> idris or agda are better for it
20:45:08 <chemuduguntar> dang, i was hoping to get if it compiles it will work sort of thing
20:45:17 <chemuduguntar> (get, )*
20:45:19 <carter> what compiles and works?
20:45:26 <carter> you can do it
20:45:31 <carter> BUT its a pain and too much work :)
20:45:31 <chemuduguntar> isn't that the common idiom or something :) ?
20:45:36 <carter> which is?
20:45:55 <chemuduguntar> "if it compiles it is correct"
20:45:59 <carter> yes
20:46:01 <carter> thats true
20:46:07 <chemuduguntar> anyway, as you say it's probably over thinking on my part
20:46:09 <carter> but sometimes types are TOO precise
20:47:07 <chemuduguntar> i am trying out 'matrix' library
20:47:16 <chemuduguntar> and it throws an exception if i do funny stuff
20:47:21 <chemuduguntar> it's good enough for me :)
20:47:31 <chemuduguntar> and I will reach all code paths in one cycle
20:47:35 <geekosaur> chemuduguntar, haskell is not particularly good at that particular kind of thing. agda is better at it (but this means agda does not handle a bunch of things that "just work" in Haskell, because you can't describe them properly in its type system)
20:49:16 <carter> and even then, statically sized matrices are kinda rigid
20:49:18 <carter> like
20:49:25 <carter> if i wanted to split the matrix into the 4 quadrants
20:49:38 <carter> the type level computation on the sizes for the sub quadrants would be fugly
20:50:01 <chemuduguntar> hmm i see
20:50:26 <carter> chemuduguntar: so in my numerical array api, i only track array rank statically
20:50:34 <carter> so all matrices are have rank 2
20:50:37 <carter> vectors rank 1
20:50:38 <carter> etc
20:50:38 <chemuduguntar> it's the type inference that gets messy
20:50:41 <carter> nope
20:50:46 <carter> its the type level computations
20:50:49 <enthropy> the split might depend on the values in the matrix at some level
20:51:13 <carter> well, it just depends on the the shape
20:51:13 <enthropy> in which case you can't have types that express the size of the blocks that well
20:51:37 <carter> i'm thinking "split at a power of 2 line"
20:52:08 <enthropy> 1D is easier
20:52:15 <carter> hehe
20:52:17 <enthropy> @type groupBy
20:52:20 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
20:52:32 <zardoz--> is it impossible to lazily generate a list for this problem with foldr? I was unable to do it with foldr but I did it easily with manual recursion
20:52:58 <zardoz--> (moment pasting)
20:54:15 <zardoz--> http://lpaste.net/95888
20:54:54 <zardoz--> sorry for formatting issues it got messed up somehow
20:54:57 <carter> foldr only plays nice with finite lists
20:55:10 * enthropy disagrees
20:55:16 <carter> urmmm
20:55:17 <zardoz--> yeah heh
20:55:31 <carter> enthropy: whats an example of it working on infinite lists?
20:55:42 <enthropy> > foldr (:) id [1 .. ]
20:55:44 <lambdabot>   Couldn't match expected type `[a0]' with actual type `a1 -> a1'
20:55:52 <enthropy> > foldr (:) [] [1 .. ]
20:55:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:55:56 <carter> oops
20:55:57 <carter> i'm tried
20:56:06 <carter> i've had …. 4+ hours of meetings today
20:56:23 <carter> tired
20:56:49 <carter> enthropy: good point though, if the f = constructor on left hand arg
20:57:33 <zardoz--> the issue seems to be related to having to use tuple as an accumulator, rather than just a list
20:59:05 <bobcrasher> Anyone willing to provide some constructive criticism for this little input-reading framework I'm putting together?
20:59:06 <bobcrasher> http://pastebin.com/bCTyqk9i
20:59:08 <mauke> The paste bCTyqk9i has been copied to http://lpaste.net/95889
20:59:20 <bobcrasher> Things that look bad, are poor practice, etc?
20:59:21 <enthropy> zardoz--: the n is also a problem
20:59:33 <zardoz--> enthropy: in what way?
20:59:39 <enthropy> the 0 is at the end of the list
21:00:02 <enthropy> so to check if   x `div` n == 0, you have to add up all these 1+n
21:00:04 <zardoz--> true hmm
21:01:23 <zardoz--> so is it impossible to write a lazy everyNth with foldr?
21:04:57 <chemuduguntar> carter: do you do haskell for a living
21:05:03 <chemuduguntar> or should I say get to use haskell at work
21:05:10 <carter> somehow yes
21:05:18 <carter> partly because i'm slightly self employed
21:05:48 <chemuduguntar> cool
21:06:20 <enthropy> zardoz--: no there's a trick where you give more arguments to foldr to use
21:06:48 <chemuduguntar> i am learning it to use on my own projects
21:07:10 <TallerGhostWalt> Yeah, I designed this whole interface and now I see I made a hash of the way I handled save. Anyone have a good white paper on proper save handling.
21:07:16 <zardoz--> enthropy: ok, dont tell me I will try to figure it out myself :)
21:07:26 <chemuduguntar> it would be pretty hard to convince someone here - maybe a f#
21:07:56 <TallerGhostWalt> like undo and redo implementation in haskell
21:08:06 <chemuduguntar> library that ties in to existing c# apps
21:16:14 <zardoz--> enthropy: are you sure it is possible? I need to keep a counter variable and I see no way to have it without putting it in accumulator
21:23:09 <zardoz--> and if I put it in accumulator and increment it I lose lazyiness.. I would like to see a solution since I cant figure it out
21:24:08 <bobcrasher> is there a way to pattern match on numbers
21:24:17 <bobcrasher> or, I know I've seen it, stupid phrasing to that question
21:24:24 <bobcrasher> But, if I have an array of numbers, and I care about certain values
21:24:42 <bobcrasher> Something like "case myArr of (1:_:_:45:_) = ..."
21:24:50 <bobcrasher> if I want to do one case if certain numbers in a list match
21:25:10 <zRecursive> :t elem
21:25:11 <lambdabot> Eq a => a -> [a] -> Bool
21:26:19 <bobcrasher> So elem looks for something anywhere in the list.  I'm thinking of something, where in the case above "1,9,3,45,6" would match but "9,1,3,45,6" would not
21:27:18 <bobcrasher> I guess if there's nothing built in to pattern matching I can do something with zip easy enough
21:28:47 <zRecursive> seems NO built stuff
21:29:30 <bobcrasher> I was half hoping I could literally match on my "(3:1:_:5)" expression but its understandably a specialized case
21:30:20 <zardoz--> > case [1,2,3] of (1:2:xs) in xs
21:30:21 <lambdabot>   <hint>:1:26: parse error on input `in'
21:30:34 <zardoz--> > case [1,2,3] of (1:2:xs) -> xs
21:30:35 <lambdabot>   [3]
21:30:48 <zardoz--> > case [999,2,3] of (1:2:xs) -> xs
21:30:49 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
21:32:01 <zardoz--> that is as far as you can gom
21:32:06 <zardoz--> go*
21:36:23 <bobcrasher> interesting.  Well thank you for the input
21:36:39 <pavonia> bobcrasher: You could use "3:1:_:5:[]" as a pattern. Note that the last element has to be a list
21:38:06 <zardoz--> yes pavonia is right. for some reason I interpreted _ as takeUntil
21:43:17 <bobcrasher> oh wow.  I was so close
21:43:24 <bobcrasher> Well thanks for all the help guys, I'm going to sleep
21:44:37 <zardoz--> enthropy: I solved it by cheating with zip [1..]  :)
21:44:56 <enthropy> yeah that doesn't count
21:47:46 <augur_> laziness + built-in recursion leads to some interesting programs, and some interesting problems for writing a program like Djinn
21:48:43 <zardoz--> enthropy by passing (go state) to foldr?
21:52:18 <lpaste> enthropy annotated “No title” with “No title (annotation)” at http://lpaste.net/95888#a95890
21:53:26 <enthropy> zardoz--: that's kind of right (except it starts at the wrong point)
21:55:04 <levi> Whee, I figured out why emacs flycheck stopped working.
21:59:18 <augur_> chrisdone: beep
22:00:49 <levi> It uses hsdevtools, which launches a server, which sticks around even when you switch projects. :P
22:00:52 <lpaste> vlion pasted “stupid syntax error” at http://lpaste.net/4932176138752491520
22:01:39 <vlion> Anyone have guidance as to where I forgot my brain there? :-)
22:02:32 <Twey> vlion: You probably meant LoginResult (Either OK ErrorMessage)
22:02:49 <vlion> Yup, there it is.
22:04:10 <zardoz--> enthropy: struggling a lot to understand that one.. we are accumulating a function? and then resulting function with [] argument?
22:04:18 <zardoz--> +calling
22:06:16 <enthropy> the list that's getting ignored is the [()] that gets built up to know when you've ignored enough elements of the input list
22:06:23 <enthropy> my naming is a bit off I guess
22:06:48 <enthropy> also I'm not really clear on why the factor of 2 there is needed
22:07:18 <enthropy> off-by-ones are common, but two?
22:10:16 <zardoz--> no idea. :). still processing it
22:11:00 <enthropy> ok well I suggest adding some type annotations
22:11:16 <enthropy> which list is [a] and which is [()] might help you see how the parts fit together
22:13:51 <augur_> chrisdone: http://www.reddit.com/r/haskell/comments/1qwjk6/l%C3%B6b_and_m%C3%B6b_strange_loops_in_haskell/cdhsefm opines?
22:14:04 <zardoz--> enthropy: ah that helped
22:23:53 <Fuuzetsu> I'm disappointed to see that ‘lens tutorial’ brings up photography related results first.
22:26:33 <zardoz--> enthropy btw it does not work well with nth being 1
22:29:50 <zardoz--> es is _ in (_ -> []).. so puzzling how we can exctact it like that
22:30:55 <zardoz--> or quite possibly i am misunderstanding it again
22:45:36 <Fuuzetsu> zardoz--: you're not extracting anything there, it's simply a pattern that always matches and the expression's value is []
22:46:27 <Fuuzetsu> foo [a] = [7] -- we match a single element list and return [7]
22:46:39 <Fuuzetsu> foo _ = [] -- we match everything else and then return []
22:46:50 <Fuuzetsu> the ‘_ -> []’ is just pattern guard syntax
22:48:27 <zardoz--> I understand (_ -> []). it is a function that always returns []. what I dont get is how go accepts three arguments, and how third argument is [()]
22:50:17 <zardoz--> in http://lpaste.net/95888#a95890
22:56:49 <Cale> zardoz--: what?
22:57:01 <Cale> zardoz--: I only see go being applied to two arguments there
22:57:22 <Cale> Unless you're talking about the annotation?
22:57:23 <zardoz--> see annotation
22:57:25 <zardoz--> yes
22:57:34 <Cale> Well, it's defined as a function of three arguments
22:57:42 <Cale> go x cons es | ... = ...
22:58:40 <Cale> oh, you're confused because it's the argument to foldr
22:58:57 <Cale> This foldr is folding the list xs into a function.
23:00:15 <Cale> This is strangely written though.
23:02:00 <zardoz--> we end up with something like this? cons (cons (cons () : [])))
23:03:34 <Cale> It's using lists as natural numbers
23:04:05 <lpaste> Cale annotated “No title” with “No title (annotation) (annotation)” at http://lpaste.net/95888#a95891
23:04:16 <Cale> That should be equivalent
23:04:52 <zardoz--> oh I think I get the three argument part, it could be written like this go x cons -> \es ...
23:05:02 <Cale> errr
23:05:08 <Cale> I don't understand your notation there
23:05:38 <zardoz--> go x cons = \es -> ...
23:05:46 <Cale> sure
23:05:47 <Cale> yeah
23:06:28 <Cale> You can think of the list es as a unary encoding of a natural number
23:06:38 <Cale> the second [] in the foldr line is the representation for 0
23:06:47 <Cale> () : es is "es + 1"
23:07:59 <Cale> and null (drop (nth-2) es) is checking to see if es - (nth-2) is 0 (or negative), i.e. if es <= nth-2
23:08:21 <Cale> (which I wrote as k < n-1 in my version)
23:10:09 <Cale> zardoz--: does my version make sense?
23:10:39 <zardoz--> it makes more sense, at least :)
23:17:07 <Cale> zardoz--: I guess another thing about this which is a bit weird is the use of 'cons' -- if I were going to name anything here cons, it would be go!
23:17:27 <Cale> zardoz--: because that's the function we're replacing each of the conses in our list with
23:19:30 <lpaste> Cale annotated “No title” with “Yet another version” at http://lpaste.net/95888#a95892
23:20:23 <Cale> So, we're replacing the [] at the end of the list xs with the function nil, which is the constant function resulting in []
23:20:24 <lpaste> isomorphic pasted “Unboxed points. ” at http://lpaste.net/6168829491083739136
23:20:35 <Cale> and we replace each (:) in the list with the function cons
23:20:53 <zardoz--> I see
23:21:04 <Cale> which is going to accept as its parameters an element x from the original list, and the f which is the result of folding over the rest of the list
23:21:32 <isomorphic> ^-- That's a really short attempt at making a data type that stores cartesian points, but using Data.Vector.Unboxed.   Why would ghc report Not in scope: data constructor `DVU.Vector' on the last time (ie: in main)?
23:21:46 <Cale> and it gives us a function whose behaviour depends on this parameter k -- when k is less than n, it simply applies f (the transformed rest of the list) to (k+1)
23:22:23 <Cale> otherwise (when k = n), it produces a list which has x as an element, and it's followed by f 1, i.e. restarting the counter
23:22:53 <Cale> and we're initialising k to 1 by passing that in at the top
23:23:32 <Cale> So, for the first element of the list, k will be 1, then 2 and so on until it gets to n, where we'll emit the nth element, and reset the counter to 1
23:24:21 <Cale> isomorphic: Data.Vector.Unboxed doesn't export a data constructor called Vector.
23:25:17 <Cale> isomorphic: perhaps you're looking for  singleton :: Unbox a => a -> Vector a
23:25:18 <zardoz--> I think I am getting the main idea of it now
23:25:28 <zardoz--> thanks for the help!
23:25:36 <Cale> zardoz--: quite welcome!
23:26:23 <lpaste> liyang pasted “optparse-applicative remaining args” at http://lpaste.net/95893
23:26:42 <liyang> I hope someone is familiar with optparse-applicative. :-/
23:27:22 <isomorphic> Cale:  Thanks.  In expression  Point (DVU.Vector Double) (DVU.Vector Double)  -- DVU.Vector is a data family?
23:27:53 <liyang> If I run that code with -f something as arguments, I get an error rather than the list ["-f", "something"].
23:28:23 <Cale> liyang: Perhaps you want to use runParser somehow instead?
23:28:33 <Cale> (I'm not familiar with the library...)
23:29:17 <liyang> Cale: I can't call runParser because the real problem (rather than the simplified version I posted) is in a subcommand.
23:29:52 <liyang> And in any case runParser takes a ArgPolicy argument type that's not exported.
23:30:33 <Cale> oh, weird
23:30:51 <Cale> Who exports a function without exporting the types of its arguments?
23:35:27 <Cale> liyang: perhaps this could be used somehow? arguments :: (String -> Maybe a) -> Mod ArgumentFields a -> Parser [a]
23:35:51 <liyang> No, that rejects "-f" as well. :(
23:49:08 <supki> liyang: you can pass ["--", "-f", "something"] to arguments, I think
23:49:18 <supki> i.e. it should be parsed correctly then
23:55:59 <Engen> Regarding Haskell textbooks, there are a few on haskell.org. I was wondering which you guys would recommend to someone coming from C? (not that it really matters I think) or anything not on the site?
23:57:04 <liyang> supki: setting prefIntersperse = False with customExecParser worked for me in the end.
23:57:34 <bergmark> Engen: learn you a haskell + real world haskell are the standard recommendations
23:57:50 <Engen> bergmark: cheers
23:58:02 <liyang> I was also getting confused because I was reading through the code in HEAD while having 0.5.2.1 from 2 months ago installed. ¬_¬
23:58:44 <chrisdotcode_> is null ([a] -> Bool) O(1) runtime?
23:58:54 <joelteon> yeah
23:59:23 <chrisdotcode_> thanks :)
