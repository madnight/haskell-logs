00:19:18 * hackagebot haskell-pdf-presenter 0.2.3 - Tool for presenting PDF-based presentations.  http://hackage.haskell.org/package/haskell-pdf-presenter-0.2.3 (MichaelAdams)
00:23:09 * hackagebot smallcheck 1.1 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.1 (RomanCheplyaka)
00:23:09 * hackagebot haskell-pdf-presenter 0.2.3 - Tool for presenting PDF-based presentations.  http://hackage.haskell.org/package/haskell-pdf-presenter-0.2.3 (MichaelAdams)
00:28:34 <carter> so the question is: are michael and roman the same person? :)
00:41:19 <Milos> Is it just me or is this contradictory? http://www.haskell.org/haskellwiki/Beta_reduction
00:41:28 <Milos> "To calculate the result, we substitute 7 for every free occurrence of x, and so the application of the function"
00:41:33 <Milos> http://www.haskell.org/haskellwiki/Free_variable
00:41:45 <Milos> "In the above expression, y is a free variable"
00:42:09 <Milos> In the former page, they refer to a bound variable as free, or am I mistaken?
00:42:10 <johnw> yes, I say the occurrences of x are bound
00:42:22 <Milos> Me too. But this mistake appears twice.
00:42:37 <Milos> So I did doubt myself, but herhaps it was edited by the same person.
00:42:53 <Milos> (it is repeated here: http://www.haskell.org/haskellwiki/Lambda_abstraction)
00:43:19 <johnw> quite possible
00:44:02 <Milos> Sorry I may have caused ambiguity; on the 'free variable' page, I am happy with the definition. But on the other pages it seems like the opposite is being stated. i.e., you replace the bound variables with the parameter, not the free ones.
00:44:37 <johnw> right
00:44:54 <johnw> the very thing that makes them free is that they are not affected by beta reduction
00:45:50 <johnw> (at least, not by that particular lambda abstraction)
00:45:58 <johnw> it has to be bound at some point higher up
00:46:09 <fizruk> in (\x -> E) 4 beta reduction replaces every *free* occurence of x in E ?
00:46:10 <johnw> hence the term "lexical binding"
00:46:39 <johnw> fizruk: I think it's the opposite, isn't it?
00:46:42 <Milos> I still think it should be 'replaces every bound occurence'? Or am I just going- yes
00:46:52 <Milos> johnw, that's what I was trying to say.
00:47:09 <johnw> free occurrences of x in E will have be renamed to x₁ or something, to be different from the x that is bound by the lambda
00:47:27 <fizruk> johnw, i don't think so: (\x -> \x -> x)
00:47:39 <johnw> so, there is no free occurence of x there
00:48:07 <johnw> i see what you're getting at ,though
00:48:15 <fizruk> in \x -> x, E = x and x as a term has a *free* occurence of x
00:48:35 <fizruk> that's how I see it, perhaps I'm wrong though
00:48:42 <johnw> Wikipedia says, "The free variables of a term are those variables not bound by a lambda abstraction"
00:48:43 <vonDraco> what am I doing wrong with using recursion in this instance declaration? http://lpaste.net/6369600310020669440
00:48:44 <johnw> which is what I understood
00:49:12 <johnw> so \x -> x has no free variables
00:49:30 <Milos> So the haskell article is incorrect?
00:49:44 <fizruk> johnw, sure, but x in RHS has?
00:49:50 <johnw> the one on Beta reduction is, I think
00:50:06 <Milos> yeah, it must be incorrect (and on lambda abstraction)
00:50:12 <Milos> because it states the following:
00:51:45 <Milos> "When a lambda abstraction is applied to a value—for instance, (\lambda x -> x^2 ) 7 —the result of the expression is determined by replacing every free occurrence of the parameter variable (in this case x) with the parameter value (in this case 7). "
00:51:57 <Milos> x is not a free variable there
00:52:14 <Milos> because it *is* bound by the abstraction...
00:52:52 <fizruk> i still have a different intuition about that
00:53:27 <fizruk> in \x -> x^2 you have no free occurences, but you're not substituting x in there, you're doing it for RHS
00:53:32 <fizruk> and RHS is x^2
00:54:05 <fizruk> and it has a *free* occurrence of x
00:57:20 <arkeet> beta-reduction of (\x -> A) B replaces every free occurrence of x in A with B.
00:57:21 <arkeet> that's it.
00:57:43 <arkeet> no one cares whether x is free in (\x -> A)
00:57:46 <arkeet> (it never is)
00:57:46 <johnw> ahhh
00:57:49 <johnw> that makes sense
00:57:54 <johnw> now I see what fizruk meant
00:58:07 <johnw> as a term, x itself has x free
00:58:13 <johnw> even if it occurs as the term to the right of a ->
00:58:50 <arkeet> so in something silly like (\x -> x (\x -> x)) 5
00:58:58 <arkeet> so A = x (\x -> x), B = 5
00:59:01 <arkeet> the only free x in A is the first one
00:59:05 <arkeet> so you get 5 (\x -> x)
00:59:29 * fizruk needs to be more accurate with explanations
00:59:32 <Milos> right, I understand - thanks for that
01:02:54 <joelteon> :t \x -> x x
01:02:57 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
01:02:58 <lambdabot>     In the first argument of `x', namely `x'
01:02:58 <lambdabot>     In the expression: x x
01:06:00 <fizruk> :t id id
01:06:01 <lambdabot> a -> a
01:32:27 <mr-> Is there a good way to combine GADTs and record syntax?
01:35:50 <c_wraith> mr-: nope. They're totally independent syntax for declaring a data type
01:38:26 <eikke> huh
01:38:35 <eikke> data G a where G :: { a :: Int } -> G ()
01:38:44 <eikke> that works just fine
01:38:56 <eikke> (whether it's a good idea is another discussion)
01:39:45 <eikke> a (G 1) == 1
01:43:23 <jfpowell> Hello, I've got a fairly basic question, wondering if someone could help me with it?
01:45:16 <jfpowell> Anyone awake?
01:47:10 <danr> jfpowell: don't ask to ask, just ask
01:47:25 <jfpowell> Well I'll go ahead and ask I guess... I have the following code http://lpaste.net/5317066158354989056 the idea for the toDigits function is to turn an integer into a list of it's digits. I was wondering if my approach with two functions, is overcomplicated? Are there more haskell like ways to approach this kind of situation?
01:49:19 <jfpowell> Again sorry for the basic questions, i'm still trying to wrap my head around functional programming.
01:49:44 <danr> jfpowell: toDigits 0 = []; toDigits n | n > 0 = .... : toDigits ...
01:49:47 <danr> can you fill in the blanks?
01:53:41 <jfpowell> Ah, I see :)
01:56:46 <jfpowell> if I do toDigits 0 = []
01:56:46 <jfpowell> toDigits n = mod n 10 : toDigits (div n 10)
01:57:17 <jfpowell> It compiles and works but gives me a reversed list, when I try ...
01:57:42 <Twey> jfpowell: Are you surprised?
01:58:01 <jfpowell> Nope, that makes sense
01:58:19 <jfpowell> When I try and reverse it like... toDigits n =  toDigits (div n 10) : mod n 10
01:58:30 <jfpowell> I get type errors
01:58:31 <Twey> :t (:)
01:58:33 <lambdabot> a -> [a] -> [a]
01:58:51 <Twey> (:) takes an element (of type a) and a list (of type [a]) and conses the former to the front of the latter
01:59:17 <Twey> You can ‘snoc’ a result onto the end of a list like: [1, 2, 3] ++ [4]
01:59:23 <jfpowell> Ah, :)
01:59:28 <mr-> eikke: It does indeed look weird, but thanks!
01:59:40 <jfpowell> So that's just me misunderstanding the basic syntax :)
02:00:07 <Twey> (doing so is slow, though, since it traverses the whole list; in general you would either accumulate your results and reverse the list at the end, or else use a different data structure that supports efficient snoc, like Seq)
02:00:18 <Twey> (but I guess you don't care overmuch about performance here)
02:01:22 <jfpowell> Okay, so toDigits n =  toDigits (div n 10) ++ [mod n 10] seems to be the answer to my problem here :)
02:02:40 <jfpowell> Thanks, I remember last time I tried to pick up Haskell I was using a lot of my original kind of solution, i.e. creating multiple helper functions to solve problems
02:02:50 <quchen> jfpowell: That has terrible runtime behaviour though. Appending to a list is O(n), prepending is O(1).
02:03:02 <quchen> Doing the reverse once in the end should be much more efficient.
02:03:15 <Twey> jfpowell: You can use the standard library to avoid the explicit recursion: toDigits = reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10)
02:03:34 <quchen> … or use unfoldr.
02:03:40 <Twey> Or use unfoldr
02:03:49 <danr> if in doubt, use iterate
02:03:52 <arkeet> :t unfoldr
02:03:53 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
02:04:20 <arkeet> :t swap
02:04:21 <lambdabot> (a, b) -> (b, a)
02:04:24 <quchen> unfoldr, the function with the highest "obscure type sig" to "how simple it actually is" ratio
02:04:41 <FreeFull> Doubtful
02:04:45 <arkeet> > unfoldr (\x -> if x == 0 then Nothing else Just . swap $ x `divMod` 10) 12345
02:04:47 <lambdabot>   [5,4,3,2,1]
02:04:47 <FreeFull> I'd think some lens function would take that price
02:04:59 <quchen> Lens functions aren't easy.
02:05:13 <arkeet> lots of lens things are just id
02:05:14 <arkeet> ;)
02:05:20 <arkeet> also I guess that needs to be reversed.
02:05:37 <quchen> arkeet: The reason why they're id is pretty nontrivial from what I can tell though.
02:05:50 <jfpowell> Ah, didn't know about divMod
02:05:56 <Fuuzetsu> :t divMod
02:05:57 <lambdabot> Integral a => a -> a -> (a, a)
02:06:02 <FireFly> I guess it depends on how you define "how simple it actually is"
02:06:04 <danr> arkeet: guard (x > 0)
02:06:06 <danr> :D
02:06:06 <arkeet> > 357 `divMod` 10
02:06:08 <lambdabot>   (35,7)
02:06:13 <arkeet> danr: yeah
02:06:13 <FireFly> *implementation-wise* id is certainly very simple :p
02:06:16 <FireFly> Probably the simplest
02:06:37 <quchen> iso = dimap -- Typechecks. But that can't be right. Can it? It is? Wat.
02:07:32 <quchen> FireFly: The name is one character too verbose though, it could be easier :-P
02:08:09 <FireFly> haha
02:08:10 <quchen> Anyway, what I meant is that unfoldr has this weird Maybe generator in it, which confused me as a beginner.
02:08:23 <Twey> reverse $ unfoldr (\n -> if n == 0 then Nothing else Just . swap $ divMod n 10) 1234
02:08:36 <Twey> Oh, you got there already :þ
02:08:48 <quchen> (And to this day I can never remember which way round the tuple is. I just know it's "the other way round", but depending on how often I think that that may be a good or bad mnenonic.)
02:09:13 <Twey> quchen: ‘Result first’, I guess
02:09:20 <FireFly> You could define it just fine without the Maybe, right?  (but then it'd always emit an infinite list)
02:09:27 <quchen> Twey: Good start. Now make me remember that. :-P
02:09:29 <Twey> I'm not sure whether I prefer the unfoldr or the chain.  The chain is simpler by my definition.
02:09:44 <Twey> But the unfoldr does seem more directly suited to the problem
02:09:45 <arkeet> Twey: I don't like how divMod gets split up into two parts in that.
02:09:47 <arkeet> or so
02:09:51 <Twey> FireFly: That's basically iterate
02:09:55 <quchen> I think I'm going to need something like when I declared Finland as not part of Europe to remember whether it's Helsinki or Stockholm syndrome.
02:10:09 <arkeet> Twey: nah, iterate doesn't keep any state.
02:10:20 <Twey> arkeet: It can if you use a pair
02:10:30 <arkeet> I guess you can ignore part of the pair on input.
02:10:33 <danr> quchen: Stockholm syndrome!
02:10:35 <FireFly> map snd . iterate  more or less, I suppose
02:10:45 <arkeet> some monadic iterate with State would make more sense.
02:10:54 <Twey> quchen: Haha, that's an extreme mnemonic
02:11:24 <arkeet> Helvetica syndr-hm not quite.
02:11:25 <tarmil> any solution that uses reverse would not take advantage of laziness, right? the whole list is evaluated as soon as you access the first element
02:11:27 <Twey> So, Vinyl exports a type: (:::) $a $b = Field
02:11:32 <Twey> What do the dollar signs mean here?
02:11:34 <tarmil> (not that you'd want laziness for toDigits :P)
02:11:37 <arkeet> tarmil: the spine of the list is, at least.
02:11:46 <jfpowell> If I want unfoldr and swap, do I need to import some standard library?
02:11:47 <pharaun> Oslo Syndrome? :p
02:11:48 <Twey> tarmil: But that's necessary here
02:12:02 <Twey> jfpowell: unfoldr is in Data.List; swap isn't defined but is obvious :þ
02:12:07 <Twey> (swap (a, b) = (b, a))
02:12:13 <jfpowell> okay, sure :)
02:12:31 <tarmil> you can do a first pass to determine which power of 10 is closest to n, then you can build the list forward
02:12:40 <arkeet> that sounds like a bad idea.
02:12:43 <arkeet> for some reason.
02:12:52 <mr-> @djinn (a,b) -> (b,a)
02:12:52 <lambdabot> f (a, b) = (b, a)
02:12:54 <arkeet> > unfoldr (\n -> if n == 0 then Nothing else Just . swap $ divMod n 10) (-123)
02:12:54 <mr-> :-)
02:12:56 <lambdabot>   [7,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,...
02:12:59 <arkeet> ;)
02:13:52 <Twey> arkeet: Pfft, no *real* computer scientist uses non-natural numbers
02:13:59 <arkeet> it's a perfectly fine 10-adic number!
02:14:01 <FireFly> @pl \(a,b) -> (b,a)
02:14:01 <lambdabot> uncurry (flip (,))
02:14:08 <FireFly> Duh.
02:14:08 <arkeet> 10-adic integer, even.
02:14:44 <Twey> But is it equivalent to -123?  :þ
02:14:57 <arkeet> yes!
02:15:12 <arkeet> add 123 to it and carry infinitely many times and you're left with 0.
02:15:24 <Twey> Excellent
02:15:53 <jfpowell> :)
02:16:38 <jfpowell> Thanks for the help guys. Seems I have a lot to learn.
02:17:01 <danr> > let toDigits :: Integer -> [Int]; toDigits = map digitToInt . show in toDigits 1234
02:17:03 <lambdabot>   [1,2,3,4]
02:17:17 <arkeet> =(
02:17:21 <danr> =P
02:17:24 <arkeet> cheater!
02:18:06 <Twey> That's just not sporting :þ
02:18:12 <tarmil> let toDigits :: Integer -> [Int]; toDigits = map digitToInt . show in
02:18:13 <arkeet> :th
02:18:21 <tarmil> ah shit
02:18:50 <tarmil> let toDigits :: Integer -> [Int]; toDigits = map digitToInt . show in toDigits (-1234)
02:20:32 <arkeet> Twey: for a fun thought, consider that any gaussian integer can be represented uniquely in base (i-1) using the digits 0 and 1.
02:20:46 <arkeet> (hint: 2 = 1100)
02:20:51 <arkeet> finitely many digits, even.
02:21:06 <arkeet> unfortunately, addition may involve infinite carrying.
02:21:25 <arkeet> (noting -1 = 11101, try adding 1 + 11101)
02:21:51 <pharaun> trying to define a more precise grammar from imprecise example/input is exhausting :)
02:21:59 <pharaun> i do wish more things were defined with precise grammar
02:22:14 <dv-> > map (read . return) $ show 123 :: [Int]
02:22:15 <lambdabot>   [1,2,3]
02:22:34 <Twey> arkeet: Aye, I've encountered Knuth's quater-imaginary base before :þ
02:22:43 <donri> Twey: hm i think i've seen dollars in my haddocks when ghc filled them in for some reason, possibly involving KindSignatures or TypeFamilies
02:22:47 <Twey> (2i)
02:25:02 <donri> Twey: ah yeah when you use kind signatures such that the parameters of the type are inferred
02:26:49 <donri> ...and it shows up in ghci not haddock
02:26:53 <Twey> Aha
02:27:34 <donri> annoyingly haddock simply doesn't show any parameters
02:28:17 <donri> you need data (:::) (sy :: Symbol) (t :: *) where ... to get haddock to show 'em
02:29:10 <bearclaw> anyone knows Ganesh Sittampalam (maintainer for rmonad) or if he's still actively maintaining it?
02:29:19 <Twey> Heffalump:
02:29:20 <donri> bearclaw: Heffalump
02:30:09 <bearclaw> thanks (I need a script so whois-search myself)
02:30:42 <bearclaw> Heffalump: The doc for rmonad is out of date and does not match the code, I sent you a patch by email
02:30:45 <donri> i didn't whois search, ganesh is famous ;)
02:31:19 <notdan> hm rmonad looks interesting, quite a nifty idea
02:31:26 <notdan> s/idea/implementation/
02:31:44 <donri> you can make a "cleaner" implementation with ConstraintKinds these days
02:37:22 <bearclaw> but that still requires  a Monad "override"
02:37:53 <tarruda> @src Control.Applicative
02:37:54 <lambdabot> Source not found. My pet ferret can type better than you!
02:37:56 <bearclaw> which is anoying, because you can't use any typeclass written on top of the original Monad with RMonad, without rewriting it too
02:38:25 <tarruda> @src [] <*>
02:38:26 <lambdabot> Source not found.
02:38:29 <donri> bearclaw: technically you could use DefaultSignatures to change Monad in base, but it's unlikely to happen
02:38:31 <tarruda> @src [] fmap
02:38:31 <lambdabot> fmap = map
02:39:14 <donri> even though it would be perfectly back-compat AFAICS
02:40:05 <Pantoufle> @type fmap fmap fmap
02:40:07 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:42:22 <donri> :t fmap.fmap
02:42:23 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:43:42 <tarruda> heres an article about functors, applicatives and monads thats really easy to understand: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
02:45:14 <quchen> tarruda: fs <*> xs = [ f x | f <- fs, x <- xs ]
02:45:35 <quchen> And fmap = map for lists
02:45:46 <tarruda> thanks
02:46:02 <tarruda> where did you found that source code?
02:46:55 <quchen> In my head :-P
02:47:03 <tarruda> > [1, 2, 3] <*> [(*2), (+3)]
02:47:04 <lambdabot>   Could not deduce (GHC.Num.Num
02:47:04 <lambdabot>                      ((GHC.Integer.Type.Integ...
02:47:08 <quchen> The other way round.
02:47:15 <quchen> I think the official implementations for this can be found in Control.Applicative.
02:47:38 <tarruda> > [(*2), (+3)] <*> [1, 2, 3]
02:47:40 <lambdabot>   [2,4,6,4,5,6]
02:47:45 <quchen> But those aren't very useful:
02:47:46 <quchen> instance Applicative [] where
02:47:46 <quchen>     pure = return
02:47:46 <quchen>     (<*>) = ap
02:47:59 <quchen> Not really as expressive as what I wrote above.
02:48:06 <tarruda> yes
02:49:04 <tarruda> I wish there was a simple command-line utility that would display the implementation of anything in haskell
02:49:11 <tarruda> it really helps when one is learning
02:49:20 <quchen> Many things don't have simple implementations though.
02:49:50 <quchen> Simple solutions often perform bad, complicated solutions are not helpful to beginners.
02:50:08 <quchen> A good example is the 'sort' implementation.
02:50:18 <tarruda> I know, but the simple implementations ofter help beginners change their way of thinking
02:50:23 <quchen> Sure.
02:51:05 <notdan> sort is insertion sort, right?
02:51:24 <quchen> Lambdabot has her static database she uses for @src. There's some way to view it. Let me see whether I can find it.
02:51:24 <quchen> (It lists many simple implementations of common functions.)
02:51:29 <danr> it's a merge sort in Data.List
02:51:33 <quchen> It's some sort of a hybrid.
02:51:49 <notdan> @src sortBy
02:51:49 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
02:51:56 <merijn> It's optimised merge sort
02:52:00 <quchen> danr: It's not a pure mergesort
02:52:04 <merijn> i.e. it skips sorted sequences
02:52:18 <merijn> quchen: It's fairly pure merge sort, tbh
02:52:24 <quchen> The docs mention where the algorithm was taken from
02:52:50 <notdan> @src Data.List.sort
02:52:50 <lambdabot> Source not found.
02:52:55 <danr> meh, I would definitely call it a merge sort. a non-naive one
02:53:13 <quchen> Anyway: tarruda, also have a look at the Haskell Report. It has a section where it provides example implementations for core functions, and they're written for clarity (not performance) there
02:53:24 * hackagebot geojson 0.0.1 - A thin GeoJSON Layer above the json library  http://hackage.haskell.org/package/geojson-0.0.1 (domdere)
02:53:47 <tarruda> quchen: will do, thanks
02:55:09 <tarruda> Just out of curiosity: is it possible to optimize algorithms written in pure haskell to be on par with C implementations?
02:55:22 <tarruda> like the quicksort example
02:55:29 <jfpowell> Hello again, what's the best way to go about applying say two different functions over a list, depending on whether you are dealing with an odd numbered element and even numbered element?
02:55:30 <tarruda> I found in introduction
02:55:56 <quchen> Some algorithm yes, others not so much. Actual quicksort is fundamentally built on mutation, so you can't do it in basic Haskell.
02:56:09 <quchen> You can write it with ST, but that would be a pretty direct translation of the C version.
02:57:34 <donri> that's controversial
02:57:43 <quchen> Is it?
02:58:24 <tarruda> quchen: I have read somewhere that haskell has a hashtable implementation, which is based on mutability, how can that be?
02:59:13 <donri> i think the argument is that mutation is irrelevant to what defines an algorithm
02:59:30 <donri> others say it is relevant, so, yeah, controversial :)
02:59:33 <quchen> donri: Quicksort is in-place, so there has to be mutation.
02:59:37 <tarruda> its relevant
02:59:46 <donri> that just says which camp you are in ;)
02:59:53 <tarruda> you cant copy the backing array everytime a hashtable is updated
03:00:10 <pharaun> donri: isn't that algo dependent because it seems like some algo depends on "mutation" being an o(1) whatever operation?
03:00:14 <quchen> tarruda: There are ways to have mutation in Haskell, namely STM, IO, ST.
03:00:36 <quchen> tarruda: These are not for beginners though (like "after LYAH level").
03:01:17 <quchen> You can also have mutation in pure code, but that's wizard territory.
03:01:34 <quchen> ("pure" in the sense of the type signature.)
03:01:49 <tarruda> LYAH started to get hard on the chapter about functors
03:01:51 * pharaun spooks people by saying unsafePerformIO :p
03:02:03 <tarruda> for me its easier to approach the problem and then the solution
03:02:27 <pharaun> i dunno, i never got into LYAH, i went direct to RWH when i was learning
03:02:27 <quchen> tarruda: Don't worry about mutation too much while reading LYAH.
03:03:26 * hackagebot tasty-ant-xml 1.0.0 - A tasty ingredient to output test results in XML, using the Ant schema. This XML can be consumed by the Jenkins continuous integration framework.  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0 (OliverCharles)
03:03:32 <quchen> Another thing worth mentioning is that evaluating a thunk is a form of mutation as well, but a non-observable one.
03:03:35 <tarruda> the tutorial I linked above is amazing, it should be linked in haskell official website
03:04:17 <quchen> For every Monad tutorial there's a significant amount of people that think it's bad. Making one official is really hard. :-)
03:04:36 <tarruda> well, it explains functors, applicatives and monads with pictures
03:04:40 <quchen> I regularly get yelled at for thinking of Monads as boxes.
03:05:45 <SaBer> dildo boxes!
03:05:49 <tarruda> its a good analogy for me, boxes that know how to 'talk' to each other
03:05:50 <identity> quchen: silly goose. that's because monads are burritos
03:05:50 <quchen> tarruda: The problem with Monads is not that they're hard on their own; it's more that it's hard to explain the intuition required to work with them.
03:06:09 <identity> burritos that can talk to each other
03:06:31 <quchen> My first encounter with Monads was confusing because I didn't really understand the need for them. "But why" sums my first Monad weeks up quite nicely. :-)
03:06:32 <identity> which also suggests your kitchen hygiene is probably suboptimal, if your burritos have spontaneously come to life
03:06:39 <bearclaw> that no-mutation is distressing when comming from c++, mainly because you put a lot of faith in the compiler. If I write some algorithm that adds/remove stuff on a million-element map, how do I know the compiler will be able to never duplicate it?
03:06:57 <pharaun> donri: anyway i suppose mutation is irrelevant because that would be more of an implementation detail of the algorithm, you could do mutation to speed it up but its not required
03:07:43 <tarruda> I think whats hard about monads is that most tutorials dont explain the problem they're trying to solve
03:07:51 <quchen> bearclaw: Because there is only one two kinds of Maps: the empty one, and the one that holds a value and two other Maps.
03:07:52 <donri> pharaun: something like that is the idea, i guess. i don't claim to know enough to judge this topic myself :)
03:07:53 <tarruda> at least not properly
03:07:58 <arkeet> I think what's hard about moands is that there are so many tutorials.
03:08:07 <quchen> bearclaw: When you can show that this simple type doesn't do anything fishy, nothing built from it will.
03:08:08 <identity> there are a lot of really bad examples for uses of monads
03:08:17 <pharaun> donri: fair enough, it did make me think about some of my preconception for a bit so it was a good one to bring up :) never thought about it in that way
03:08:18 <identity> I rememer one tutorial doing some parent, grandparent shizzle.. it was horrible
03:08:19 <donri> just relaying the fact i've seen smart people like Cale dispute the idea that qsort  requires mutation
03:08:26 * hackagebot tasty-ant-xml 1.0.0.1 - A tasty ingredient to output test results in XML, using the Ant schema. This XML can be consumed by the Jenkins continuous integration framework.  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.1 (OliverCharles)
03:08:37 * donri uses the powerful argument to authority!
03:09:07 <quchen> donri: Well it depends on what you mean with "Quicksort". The original algorithm certainly requires mutation, the pivot-then-recurse-idea doesn't.
03:09:26 <quchen> BRB, got to throw computers away ♥
03:09:44 * pharaun gets out the pitchforks for that argument ;p
03:10:18 <donri> maybe it rather depends on what you think defines an algorithm. maybe you could make a case for quicksort requiring GOTO because while loops are too slow. :P
03:10:20 <pharaun> identity: the you can be your own grandparent "paradox" ?
03:10:29 <bearclaw> copying  the map entirely to update one element is not "fishy", but I don't want that to happen
03:10:33 <identity> pharaun: no, nothing like that
03:10:40 <identity> just determining parents, children, grandparents something
03:10:44 <pharaun> oh
03:10:52 <identity> i don't quite remember it in detail -- just remember it made me thoroughly confused
03:10:56 <pharaun> haha
03:11:01 <identity> I just kept thinking "that's a horrible way to solve this problem" or something
03:11:08 <pharaun> most tutorial ive seen for monads are pretty bad
03:11:12 <identity> aye.
03:11:22 <bearclaw> I'm not woried about a fixed % performance loss compared to procedural stuff, but about a huge complexity value change that I won't be able to predict.
03:11:23 <pharaun> fwiw what *really* clarified monads for me was the 3 laws
03:11:36 <pharaun> just sitting down, reading/thinking about those 3 laws
03:11:40 <identity> bearclaw: You can reason about your code once you get used to it.
03:11:50 <pharaun> i think i got better understanding from that than the tutorials
03:11:51 <identity> and you can get nitty-gritty and even interface with c if you really need that
03:12:01 <donri> bearclaw: rarely is something copied in its entirety in haskell
03:12:06 <donri> bearclaw: there's a *lot* of sharing
03:12:14 <FreeFull> I was taught by LYAH and didn't really find anything difficult or confusing
03:12:30 <pharaun> donri: aye, i mean if you want to do specific performance/space claims i could see that being relevant but i guess i see algos more of "here's how to do X"
03:12:49 <pharaun> where its a guideline of sorts, its up to you to implement it however you want
03:13:01 <donri> pharaun: yeah. i don't know myself :) no formal CS background here
03:13:13 <pharaun> i'm kinda weak with my formal cs background unfortunately
03:13:27 <bearclaw> donri: I hope so, but infering that from some code seems hard to me
03:13:38 <pharaun> but that statement did make me think a bit about that so <3 for that
03:14:04 <kryft> bearclaw: It is hard to begin with, but it does get better; how much better I can't say yet =)
03:14:12 <bearclaw> maybe functional style will make a solution that seems natural to a problem (say, modifying a map, and comparing before and after map to see if anything has changed) have a hidden huge cost (forcing an actual copy of the map)
03:14:54 <FreeFull> I'm pretty sure if you use mutable maps, there won't be much copying going on
03:15:20 <donri> bearclaw: libraries like containers and vector tend to give you big O complexity for operations though
03:15:31 <donri> sadly lacking in Data.List however
03:15:33 <pharaun> bearclaw: there is *lots* of sharing going on under the hood, and lots of the features of the language helps with this
03:15:45 <kryft> When people say that one downside of Haskell (or lazy evaluation) is that it's difficult to reason about performance characteristics, I'm not sure whether the complexity is unavoidable or just a question of what you're used to
03:15:58 <pharaun> also you can benefit from rethinking your problem, IE Trees are more friendly in haskell than some other data structure
03:16:20 <pharaun> because you can usually just change the branch that change and just link the rest to the old version
03:16:25 <pharaun> (under the hood)
03:16:38 <donri> kryft: bit of both i imagine. laziness does make evaluation less "syntactically" obvious/sequential
03:16:40 <FreeFull> Reasoning for strict and lazy is simply different
03:16:40 <bearclaw> kryft: I'm asking for something deterministic with no awful corner cases that requires knowing the compiler implementation to understand
03:17:06 <FreeFull> Someone who learned in a lazy setting might have difficulty reasoning in a strict setting at first
03:17:07 <bearclaw> and all the "usualy" and "mostly" in your answers are frightening me :)
03:17:37 <FreeFull> One thing that would help with lazy reasoning though would be the ability to see which arguments a function is strict in
03:18:17 <kryft> bearclaw: Right, I sympathize; I'm wondering about the same thing
03:20:44 <pharaun> well there are some advantages to be lazy, ie you generate an infinite list, then you have several maps operation then you in the end only take 2-3 elements out
03:20:51 <FreeFull> I wonder, since (+) is only strict in the left argument for lazy naturals, could that cause a space leak in functions that assume (+) is strict in both arguments?
03:20:57 <Twey> bearclaw: Part of the design philosophy of Haskell is that optimization should be done by the compiler
03:20:59 <pharaun> and print em, the rest of the work is never done thus its faster
03:21:29 <pharaun> you should try to write idiomic code and let ghc deal with it :)
03:21:45 <Twey> So we do usually end up writing code that looks naïve but functions reasonably due to well-known optimization techniques like sharing, strictness analysis, or stream fusion
03:21:51 <FreeFull> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
03:21:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:22:04 <FreeFull> Easiest way of generating an infinite list I've seen in any language
03:22:10 <FreeFull> I mean, of fibbonacci numbers
03:22:15 <Rembane> Meh :D
03:22:16 <Rembane> > [1..]
03:22:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:22:19 <pharaun> ha
03:22:25 <FreeFull> And it's memoized too
03:22:38 <quchen> > fix$(0:).scanl(+)1
03:22:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:23:07 <FreeFull> quchen: Does that have the same performance characteristics?
03:23:30 * hackagebot geojson 0.0.2 - A thin GeoJSON Layer above the json library  http://hackage.haskell.org/package/geojson-0.0.2 (domdere)
03:23:31 <Twey> bearclaw: Also, because of typeclasses, the complexity of an operation can sometimes be dominated by the complexity of some method in the typeclass, depending on what type you use, so it's not always easy to ascribe a complexity to a generic operation
03:24:22 <pharaun> one such example could be "direction" of a linked list, ie is it fast to append, or is it fast to prepend
03:24:39 <pharaun> but it would be a o(n) to do the opposite
03:25:08 <bearclaw> Twey: yes, but this is a different problem, present in procedural code, every details count, every line in the code has the power to  break everything
03:25:23 <quchen> FreeFull: Not sure. At least the implementation is memory efficient (in the source code).
03:25:58 <skypers> gosh, I read something about Data.Reflection last night
03:26:07 <skypers> it sounds like advanced Haskell to me
03:26:40 <Twey> bearclaw: Aye.  The reason people say laziness makes performance analysis hard, though, is because while that's still the case, in a lazy language you don't know *where* that might hit.  So you might have an O(1) algorithm, but you might apply it to a value that takes O(n³) to calculate.
03:27:08 <Twey> (or, indeed, it might never occur at all if you don't ever use that value)
03:28:41 <Twey> The (time) performance of the algorithm as it would be in a strict language is an upper bound on the (asymptotic) complexity in a lazy language, but quite often people rely on laziness or other compiler features to write code that looks unacceptably slow to a naïve strict analysis
03:29:52 <FreeFull> quchen: Both seem to be big memory eaters
03:30:26 <quchen> FreeFull: In what sense? fibo grows exponentially, so it needs lots of memory
03:30:40 <FreeFull> quchen: Yeah
03:30:48 <quchen> Well, quadratic memory I guess
03:30:49 <FreeFull> The fix version does use more memory
03:31:12 <allsystemsarego> why does this snippet not work in GHCi? do { let x = 1; x <- return ( x + 1 ); return x }
03:31:25 * mangaba_leitosa is depressed by seeing word frequency counting in Haskell (using Data.Map) being 3 times slower than in Python (using Python's dictionaries)
03:31:33 <quchen> allsystemsarego: What's the error?
03:31:37 <FreeFull> zipWith !! 50000 : (0.21 secs, 9862568 bytes)      fix !! 50000 : (0.54 secs, 121991064 bytes)
03:31:55 <allsystemsarego> quchen, parse error on input `<-'
03:31:56 <skypers> 12:15  * mangaba_leitosa is depressed by seeing word frequency counting in Haskell (using Data.Map) being 3 times slower than in Python  (using Python's dictionaries)
03:32:02 <skypers> seriously?
03:32:34 <mangaba_leitosa> skypers: it seems so. However, for python benchmarks are done using pypy (sort of JIT compiler)
03:32:49 <chrisdone> skypers: that's common. but the reasons for it aren't what's commonly implied
03:32:57 <Twey> mangaba_leitosa: Did you consider using IntMap?
03:33:05 <quchen> chrisdone: Go on
03:33:11 <mangaba_leitosa> Twey: I have 'Text' values as keys
03:33:23 <donri> HashMap?
03:33:34 <donri> Bag?
03:33:34 <skypers> mangaba_leitosa: I always heard that python is kinda slow
03:33:42 <pharaun> it is
03:33:51 <FreeFull> allsystemsarego: Seems to be to do with the let
03:33:54 <skypers> then how slow is Haskell if it’s slower :(
03:33:56 <pharaun> but pypy is a jit, which can in some time have very impressive speed up over cpython
03:33:58 <mangaba_leitosa> skypers: I did, too. Perhaps it doesn't apply to 'pypy'?
03:34:08 <donri> python is slow. pypy is less slow and in any case parts of python are fast. notably dictionaries :)
03:34:23 <Twey> allsystemsarego: You need braces around the let assignments
03:34:23 <pharaun> also dictionaries is the *core* of python, seriously, everything is a dict
03:34:24 <chrisdone> skypers: the usual scenario goes like this: python guy starts trying haskell. python guy rewrites efficient python version that uses data structures and methods written in C, to a pure Haskell version that uses excessive laziness with a bad algorithm. posts to haskell community. haskell community points it out, shows proper way to write haskell version, outperforms or matches python version, in pure haskell (not calling out to C
03:34:25 <chrisdone> library, as python must do to achieve any kind of speed)
03:34:27 <zardoz``> python only appears to be fast when the code heavily relies on python functions that are thin wrappers around C equivalents
03:34:35 <FreeFull> allsystemsarego: The ; is interpreted as part of the let rather as part of the do
03:34:38 <pharaun> all the way down, hence they have very large emphasis on dict speed
03:34:38 <Twey> > do let {x = 1}; x <- return (x + 1); return x
03:34:39 <quchen> allsystemsarego: That is indeed a weird error.
03:34:39 <mangaba_leitosa> donri: I didn't try hashmap. I tried hashtables, though
03:34:39 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
03:34:39 <lambdabot>    arising from a use of `M46181015...
03:34:45 <quchen> FreeFull: Aaah, good call!
03:35:06 <mangaba_leitosa> donri: with mutable hashtables (in IO monad). the speed was increased from 3 times slower than python to 2 times slower
03:35:09 <skypers> chrisdone: outperforms?
03:35:15 <skypers> without any C calls?
03:35:20 <pharaun> sure
03:35:22 <allsystemsarego> ok, let me try with braces
03:35:22 <chrisdone> skypers: sure
03:35:27 <skypers> huh
03:35:31 <skypers> how could it be?
03:35:35 <chrisdone> skypers: well, it's compiling down to assembly anyway
03:35:45 <skypers> yeah, but hm
03:35:47 <chrisdone> hold up, i'll find some examples
03:35:55 <pharaun> and some language features like laziness and so on, *can* lead things to be even faster
03:35:56 <Twey> > do let {x = 1}; x <- return $ x + 1; return x -- allsystemsarego
03:35:56 <skypers> it would be neat :)
03:35:58 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
03:35:58 <lambdabot>    arising from a use of `M31339402...
03:36:01 <allsystemsarego> it works with the braces, thanks all
03:36:04 * chrisdone goes to /r/haskell's history. one of these are posted every two weeks
03:36:06 <Twey> No problem
03:36:07 <pharaun> (not always, but yeah)
03:36:11 <donri> haskell has the potential to be really fast, but it isn't always the case with any give naive implementation of some task
03:36:19 <FreeFull> Twey: lambdabot doesn't default there the way GHCI does
03:36:30 <mangaba_leitosa> chrisdone: I found this: http://blog.malde.org/posts/frequency-counting.html (benchmarks of multiple frequency counting methods in Haskell)
03:36:40 <FreeFull> Although I don't even know what GHCi defaults to there
03:36:42 <pharaun> donri: which is sometime unfortunate :) would be nice if ghc could pick up on some of those but then again, its not a trivial problem to solve
03:36:44 <skypers> donri: so the point here is that the guy that says it’s faster in python wrote a terrible Haskell version?
03:36:48 <mangaba_leitosa> chrisdone: it seems that you have to use mutable Judy (in IO monad) to get decent performance
03:36:55 <mangaba_leitosa> chrisdone: but not immutable Map
03:36:55 <FreeFull> Probably IO
03:37:06 <zardoz``> look at the language shootout, haskell is at worst few times slower than C. at worst, python is 70 times slower than haskell
03:37:18 <donri> skypers: maybe. mostly *my* point is that it's understandable if they did.
03:37:21 <pharaun> skypers: a *very* common problem with language/benchmark shootout, is people who write them are usually good at their specific language, and not as good or terrible on the alternative languages
03:37:29 <pharaun> so it bias the results
03:37:31 <donri> predictable performance isn't haskell's strong point
03:37:43 <quchen> The language shootout presents highly optimized microbenchmarks, it doesn't say much about the performance of normal programs.
03:37:44 <donri> that doesn't mean it can't be fast, though
03:37:56 <FreeFull> Some people who write Haskell libraries care about performance a lot
03:38:05 <mangaba_leitosa> zardoz``: I'm not talking about haskell being slower than python in general . I'm only talking about a task for counting word frequencies
03:38:28 <pharaun> that would be a "microbenchmark" of sort
03:38:47 <skypers> mangaba_leitosa: it might exist a way to do it faster
03:39:02 <mangaba_leitosa> zardoz``: a task that doesn't actually use anything but Map or hashtables (in Haskell) and dictionaries (in Python)
03:39:12 <donri> mangaba_leitosa: i think the point is that you're not really doing it in python, python is doing it in C for you. which is nice, of course.
03:39:16 <frx> why was language shootout name changed? I can't find it now
03:39:23 <mangaba_leitosa> skypers: right. 15:20 < mangaba_leitosa> chrisdone: it seems that you have to use mutable Judy (in IO monad) to get decent performance
03:39:24 <chrisdone> mangaba_leitosa: i can only speculate what would make your program faster
03:39:29 <quchen> frx: "Computer language benchmarks game" or something.
03:39:36 <quchen> @google debian shootout
03:39:37 <lambdabot> http://blogs.perl.org/users/rurban/2011/07/the-alioth-shootout-computer-language-benchmarks-game.html
03:39:37 <lambdabot> Title: The alioth shootout Computer Language Benchmarks Game | Reini Urban [blogs.pe...
03:39:46 <pharaun> ha
03:39:50 <quchen> Hm, not what I expected.
03:40:03 <skypers> 12:23 < donri> mangaba_leitosa: i think the point is that you're not really doing it in python, python is doing it in C for you. which  is nice, of course.
03:40:04 <FreeFull> The Map that comes with containers isn't the fastest possible implementation
03:40:13 <skypers> it would also be possible to write a C function and call it from Haskell
03:40:23 <donri> mangaba_leitosa: i imagine such a python program involves very few lines of actual python code, each of which call out to C implementations
03:40:31 <donri> mangaba_leitosa: much of python's core is C
03:40:33 <chrisdone> skypers: http://www.reddit.com/r/haskell/comments/m03p9/newbie_haskell_code_is_really_slow_compared_to/
03:40:43 <skypers> thank you chrisdone
03:40:45 <skypers> gonna read that
03:40:59 <mangaba_leitosa> donri: actually, the only relevant line of python code is 'freq[word] = freq[word] + 1'
03:40:59 <yesthisisuser> For some reason, to me exception handling doesn't feel very haskelly
03:41:12 <pharaun> one trick that you sometime see with python program is that they sometime try to do as much as possible invoking "c functions"
03:41:18 <pharaun> also there is the numpy approach
03:41:26 <pharaun> scipy, etc...
03:41:38 <donri> mangaba_leitosa: yeah. all that is C. except maybe not in pypy... but then instead it's JITted, so, heh.
03:41:58 * donri does kinda wish ghc had JIT
03:42:02 * quchen goes to /r/C++ and complains that when he writes the naive implementation of a sorting algorithm by implementing a class for a lazy singly linked list without sharing it has awful performance
03:42:23 <pharaun> donri: they have done some pretty impressive thing with pypy considering just how deeply the mutability and dynamicallyness is in python
03:42:28 <frx> I wonder why pypy isn't included in the shootout
03:43:05 <chrisdone> skypers: there're more, better ones that i contributed to, just looking them up
03:44:20 <skypers> 12:25 < yesthisisuser> For some reason, to me exception handling doesn't feel very haskelly
03:44:25 <skypers> agreed
03:44:37 <hpc> exceptions are an invisible goto on every line of code
03:44:37 <skypers> but there’re some exceptions (;))
03:44:44 <skypers> like IO failures
03:44:56 <donri> mangaba_leitosa: you should also look into if the python version is actually handling unicode at all. pypy is still python2 where the default is bytestrings.
03:44:57 <skypers> I think exceptions should only be used in IO
03:45:10 <frx> mangaba_leitosa if you shared your code you will likely get pointers on how to optimize it
03:45:17 <yesthisisuser> skypers: i mean, i can see why it's there.. but it feels kind of ad-hoc
03:45:23 <mangaba_leitosa> donri: I have a concrete task, counting words only consisting of 4 different chars
03:45:38 <mangaba_leitosa> donri: don't need unicode :-)
03:45:41 <donri> mangaba_leitosa: and you mentioned using Text in haskell. if you try it with ByteString instead it is likely to be noticably faster - but less correct!
03:45:44 <skypers> yesthisisuser: yes, well, sometimes it’s convenient
03:45:49 <skypers> like head or tail
03:46:03 <donri> mangaba_leitosa: you really really need unicode to count characters, yes
03:46:16 <yesthisisuser> yep. but there should be a more "elegant" way..
03:46:16 <mangaba_leitosa> donri: I was using String initially and it was slow. Then Eduard Munteanu proposed using Text instead and the speed was increased by about 70%
03:46:17 <skypers> head as head :: [a] -> Maybe a should be the standard imho
03:46:41 <skypers> same thing for tail and so on
03:46:53 <mangaba_leitosa> donri: I have a concrete task. Word consisting of only 4 distinct ASCII chars. Really really don't need unicode :-)
03:47:05 <frx> then use ByteString
03:47:08 <donri> mangaba_leitosa: well in that case try ByteString :)
03:47:10 <Twey> I'd rather just have list ∷ b → (a → [a] → b) → b
03:47:15 <yesthisisuser> yes it is i a bit surprising that it is so easy to crash a program using head
03:47:21 <mangaba_leitosa> donri, frx: will try, thanks :-)
03:47:44 <skypers> yesthisisuser: well, everyone says “you should use null before any use of head”
03:47:44 <yesthisisuser> or any array operation
03:47:55 <skypers> that’s quite the same thing than using a head' version with Maybe
03:48:00 <Twey> skypers: You shouldn't.  You just shouldn't use head :þ
03:48:12 <skypers> Twey: ?
03:48:35 <pharaun> i forgot, is there a list of unsafe prelude functions?
03:48:37 <chrisdone> man i hate searching reddit history
03:48:45 <donri> pharaun: the safe package
03:48:46 <Twey> You can case or use some kind of an eliminator
03:48:46 <skypers> chrisdone: :D
03:48:53 <Twey> Or a fold
03:48:55 <pharaun> donri: figured :)
03:48:57 <chrisdone> can never find what i want, have to manually go through my comment history
03:49:04 <skypers> Twey: well
03:49:13 <donri> chrisdone: same :(
03:49:16 <Twey> Going via Booleans is largely unnecessary
03:49:17 <skypers> head is convenient
03:49:35 <Twey> skypers: And that's why it's in Prelude without a Maybe :þ
03:49:51 <skypers> Twey: it would be nice with a Maybe
03:50:00 <skypers> we could include it in a Maybe monad flow
03:50:09 <Twey> Once you add a Maybe you might as well just pattern-match anyway
03:50:23 <Twey> You can do that by pattern-matching, thanks to fail
03:50:49 <pharaun> http://hackage.haskell.org/package/safe-0.3.3/docs/Safe.html
03:51:01 <skypers> Twey: well, if you plan to access the head of a list, you have to know it can fail
03:51:17 <skypers> so embed all following functions in Maybe wouldn’t be insane
03:51:48 <bearclaw> tarruda: http://adit.io/imgs/functors/monad_nothing.png is kinda wrong though, the plunger handles nothing, not the function
03:51:57 <FreeFull> Using Maybe allows you to compose things
03:51:58 <Twey> skypers: Sure, but there's no need for a Maybe head function to do that
03:53:11 <yesthisisuser> http://lpaste.net/95698
03:53:13 <skypers> Twey: you could do something like
03:53:16 <yesthisisuser> i might as well write this in C++
03:53:18 <yesthisisuser> hehe
03:53:30 <skypers> head x >>= return . (+1)
03:53:33 <skypers> if x is null
03:53:38 <skypers> you just get Nothing
03:53:45 <skypers> otherwise, you get the head incremented
03:54:23 <Twey> skypers: do (h : t) <- x; return $ x + 1
03:54:29 <Twey> Er
03:54:36 <Twey> skypers: do (h : _) <- x; return $ h + 1
03:54:50 <skypers> Twey: longer than me
03:54:52 <skypers> :D
03:55:14 <skypers> but hm
03:55:14 <Twey> skypers: Yours would be better with a fmap: (+ 1) <$> head x
03:55:29 <skypers> yeah indeed:)
03:55:42 <Twey> To be sure, there are some cases where it's beneficial to have a safe head
03:55:50 <skypers> lists as monads
03:55:54 <skypers> it’s a great thing
03:56:00 <skypers> never used them as monads though
03:56:29 <Twey> But generally you can either compose them with your other Maybe instances in a do-block or else combine the condition and the processing into an eliminator
03:56:43 <skypers> sure
03:56:46 <Twey> s/instances/functions/
03:56:59 <skypers> onoes, gotta go
03:57:02 <skypers> see you folks
03:57:04 <skypers> have a nice day
03:57:05 <Twey> o/
03:57:14 <skypers> \o
03:58:41 <pharaun> fuzzy grammar is the bane of my day
03:59:22 <FreeFull> skypers: Pattern match failure in the Maybe monad result in Nothing
03:59:40 <chrisdone> did you guys see the “Clone in IDE” button on lpaste? =)
03:59:52 <FreeFull> > do { [] <- [3]; return 5 } :: Maybe Int
03:59:53 <lambdabot>   Couldn't match type `[]' with `Data.Maybe.Maybe'
03:59:54 <lambdabot>  Expected type: Data.Maybe...
04:00:05 <FreeFull> > do { [] <- Just [3]; return 5 } :: Maybe Int
04:00:07 <lambdabot>   Nothing
04:00:31 <FreeFull> Ok, I just realised that Twey's example is in the list monad afterall
04:00:41 <FreeFull> Which also works I suppose
04:01:03 <skypers> FreeFull: and I already said what you said about Maybe failure :)
04:01:25 <blueonyx> do (h : _) <- x; return $ h + 1
04:01:46 <blueonyx> > do (h : _) <- []; return $ h + 1
04:01:47 <lambdabot>   []
04:02:10 <skypers> @let head' [] = Nothing; head' (x:_) = Just x
04:02:12 <lambdabot>  Defined.
04:02:33 <skypers> > fmap (+1) $ head [1..10]
04:02:34 <lambdabot>   No instance for (GHC.Show.Show (f0 b0))
04:02:35 <lambdabot>    arising from a use of `M28254866...
04:02:39 <skypers> > fmap (+1) $ head' [1..10]
04:02:48 <lambdabot>   mueval-core: Time limit exceeded
04:02:55 <skypers> what?
04:03:16 <skypers> > fmap (+1) $ head' [10,20]
04:03:24 <lambdabot>   mueval-core: Time limit exceeded
04:03:29 <FreeFull> Funny
04:03:31 <skypers> what’s happening?
04:03:33 <FreeFull> :t head'
04:03:36 <lambdabot> [a] -> Maybe a
04:03:45 <skypers> > head' [1..10]
04:03:53 <lambdabot>   mueval-core: Time limit exceeded
04:03:53 <skypers> hm
04:03:57 <FreeFull> > 3
04:03:58 <skypers> gonna try that in my ghci
04:04:00 <lambdabot>   3
04:04:02 <pharaun> oh nifty the fpcomplete ide
04:04:05 <pharaun> haven't tried it out
04:04:07 <FreeFull> skypers: I think lambdabot is just being slow
04:04:18 <FreeFull> > take 20 [1..]
04:04:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
04:04:36 <FreeFull> > head' [1..10]
04:04:45 <skypers> that’s weird :D
04:04:46 <lambdabot>   mueval-core: Time limit exceeded
04:04:48 <skypers> fmap (+1) $ head' [1..10]
04:04:48 <skypers> Just 2
04:04:53 <skypers> :)
04:05:02 <FreeFull> Maybe it's using a different head' somehow
04:05:03 <FreeFull> @und
04:05:04 <lambdabot> Maybe you meant: undefine undo
04:05:07 <FreeFull> @undef
04:05:07 <lambdabot> Undefined.
04:05:19 <skypers> @let head' [] = Nothing; head' (x:_) = Just x
04:05:21 <donri> @underline
04:05:24 <lambdabot>  Defined.
04:05:24 <lambdabot> Undefined.
04:05:27 <donri> mwahah
04:05:27 <skypers> fmap (+1) $ head' [1..10]
04:05:39 <skypers> > fmap (+1) $ head' [1..10]
04:05:42 <lambdabot>   Not in scope: head'
04:05:43 <lambdabot>  Perhaps you meant one of these:
04:05:43 <lambdabot>    `head' (imported fr...
04:05:47 <donri> sorry skypers i just underlined it
04:05:54 <skypers> @let head' [] = Nothing; head' (x:_) = Just x
04:05:55 <FreeFull> > let head' [] = Nothing; head' (x:_) = Just x; in head' [1..10]
04:05:55 <lambdabot>  Defined.
04:05:56 <skypers> > fmap (+1) $ head' [1..10]
04:05:57 <lambdabot>   Just 1
04:06:03 <mangaba_leitosa> What's the most efficient way for doing readFile to ByteString.Char8 ?
04:06:04 <lambdabot>   mueval-core: Time limit exceeded
04:06:07 <skypers> OMG STOP THAT :D
04:06:20 <FreeFull> skypers: Seems local binding works but global doesn't?
04:06:21 <mangaba_leitosa> E. g. Text has Data.Text.IO.readFile
04:06:49 <donri> mangaba_leitosa: Data.ByteString[.Char8].readFile
04:06:51 <skypers> @let foo = (+1)
04:06:53 <skypers> > foo 3
04:06:56 <lambdabot>   Not in scope: `foo'
04:06:56 <lambdabot>  Perhaps you meant `T.for' (imported from Data.Traversa...
04:06:56 <lambdabot>  Defined.
04:06:59 <skypers> > foo 3
04:07:05 <mangaba_leitosa> donri: ah, thanks, missed it!
04:07:07 <skypers> :o
04:07:08 <lambdabot>   mueval-core: Time limit exceeded
04:07:15 <skypers> yeah, sounds that’s the case
04:07:26 <FreeFull> That's really weird
04:07:30 <FreeFull> lambdabot, why don't you work
04:10:08 <FreeFull> @yhjulwwiefzojcbxybbruweejw
04:10:08 <lambdabot> Just 'J'
04:10:24 <FreeFull> @yhjulwwiefzojcbxybbruweejw
04:10:24 <lambdabot> Exception: <<loop>>
04:10:31 <donri> \o/
04:10:49 <mangaba_leitosa> donri, frx: aha, I can see that ByteString is 20% faster than Text
04:11:01 <identity> wasn't there a lambdabot utility that would basically show the expansion of something like: len [] = 0; len (x:xs) = 1 + len xs
04:11:10 <identity> that is, the (1 + 1 + 1 + 1 ...) etc
04:11:18 <FreeFull> mangaba_leitosa: Doesn't Text only do unicode
04:11:27 <identity> trying to demonstrate a recursive length function defined like that to my friends
04:11:48 <FreeFull> identity: You could try that using Expr
04:12:00 <mangaba_leitosa> FreeFull: yes I think so
04:12:21 <FreeFull> > let len [] = 0; len (x:xs) = 1 + len xs; in len [1..30] :: Expr
04:12:26 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (...
04:12:36 <donri> mangaba_leitosa: might also want to see what version of hashable you're using if you're still using a hashable data structure. it used slow siphash for a while
04:12:41 <FreeFull> > let len [] = 0; len (x:xs) = 1 + len xs; in len [1..10] :: Expr
04:12:42 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + 0)))))))))
04:13:28 <FreeFull> identity: Is this useful?
04:13:33 <mangaba_leitosa> donri: thanks, will check it
04:13:38 <identity> FreeFull: that was exactly it
04:13:54 <identity> FreeFull: thanks!
04:14:21 <chrisdone> mangaba_leitosa: paste your code!
04:14:37 <chrisdone> :3
04:15:27 <Twey> identity: SimpleReflect is what you're thinking of, I think
04:15:59 <Twey> Hm
04:16:04 <Twey> How far does Expr evaluate?
04:16:50 <identity> that's really neat
04:16:52 <FreeFull> I think it just evaluates until it can't
04:16:54 <FreeFull> > head x
04:16:56 <lambdabot>   Couldn't match expected type `[a0]'
04:16:56 <lambdabot>              with actual type `Debug.Si...
04:17:15 <identity> > reduce (1 + 2 + 3 + 4)
04:17:16 <lambdabot>   3 + 3 + 4
04:17:21 <identity> > reduce it
04:17:22 <lambdabot>   Not in scope: `it'
04:17:22 <lambdabot>  Perhaps you meant one of these:
04:17:22 <lambdabot>    `id' (imported from ...
04:17:24 <identity> oh.
04:17:24 <FreeFull> :t reduce
04:17:28 <lambdabot> Expr -> Expr
04:17:30 <identity> > reduce ( 3 + 3 + 4)
04:17:31 <lambdabot>   6 + 4
04:17:39 <identity> > reduce (6 + 4)
04:17:40 <lambdabot>   10
04:17:51 <FreeFull> > reduce (f x)
04:17:53 <lambdabot>   f x
04:18:06 <identity> reduce (f $ f x)
04:18:11 <identity> > reduce (f $ f x)
04:18:13 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr t0)
04:18:13 <lambdabot>    arising from a us...
04:18:18 <identity> > reduce (f (f x))
04:18:20 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr t0)
04:18:20 <lambdabot>    arising from a us...
04:18:29 <chrisdone> simple reflect is just a set of instances for common type clases
04:18:46 <identity> > let f = (+1) in reduce (f (f 3))
04:18:47 <lambdabot>   4 + 1
04:18:48 <chrisdone> Num, Show, etc
04:18:54 <identity> chrisdone: yep, seems that way, but it's still pretty neat
04:18:59 <chrisdone> yeah, it's ace
04:23:57 <donri> > map (+1) $ zipWith mappend [a..d] [e..h]
04:23:59 <lambdabot>   *Exception: not a number
04:24:03 <donri> :(
04:25:30 <joelteon> > zipWith mappend [a..d] [e..h]
04:25:32 <lambdabot>   *Exception: not a number
04:26:03 <joelteon> oh, you can't enumFromTo
04:26:57 <FreeFull> > a <> b
04:26:59 <lambdabot>   a <> b
04:27:27 <donri> seems Enum Expr only works for numeral exprs
04:27:31 <FreeFull> > zipWith mappend [a,b,c,d] [e,f,g,h]
04:27:33 <lambdabot>   [a <> e,b <> f,c <> g,d <> h]
04:28:36 <donri> > [0..9] :: [Expr]
04:28:37 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
04:29:48 <mangaba_leitosa> donri, frx: OK, I reached python's performance by switching to ByteString from Text + increasing -with-rtsopts from -H128M to -H640M. thanks for help!
04:29:58 <donri> cool
04:30:07 <mangaba_leitosa> donri: well, almost reached
04:30:14 <mangaba_leitosa> donri: like 15 secs vs. 12
04:30:20 <donri> mangaba_leitosa: what map type?
04:30:31 <mangaba_leitosa> donri: type HashTable k v = H.CuckooHashTable k v
04:30:35 <mangaba_leitosa> donri: not with Map :-(
04:31:00 <mangaba_leitosa> donri: so, inside the IO monad
04:33:19 <donri> > fix (scanl (+) 0 . (1:)) !! 5 :: Expr
04:33:21 <lambdabot>   0 + 1 + 0 + (0 + 1) + (0 + 1 + 0) + (0 + 1 + 0 + (0 + 1))
04:34:02 <donri> > product [1..5] :: Expr
04:34:04 <lambdabot>   1 * 1 * 2 * 3 * 4 * 5
04:34:39 <chrisdone> mangaba_leitosa: are you not gonna paste your code?
04:35:29 <FreeFull> > 0 <> 3 :: Expr
04:35:31 <lambdabot>   0 <> 3
04:35:57 <mangaba_leitosa> chrisdone: those functions are part of a larger 200 line file... Would need some time to extract
04:36:40 <FreeFull> > let fibs::[Expr];fibs = 0:1:zipWith(+)fibs(tail fibs) in take 30 fibs
04:36:46 <lambdabot>   [0,1,0 + 1,1 + (0 + 1),0 + 1 + (1 + (0 + 1)),1 + (0 + 1) + (0 + 1 + (1 + (0...
04:37:43 <mangaba_leitosa> chrisdone: will paste shortly
04:38:08 <donri> > expr.fix$scanl(+)0.(1:)
04:38:09 <lambdabot>   Couldn't match type `[b0]' with `Debug.SimpleReflect.Expr.Expr'
04:38:09 <lambdabot>  Expected t...
04:38:11 <donri> ;(
04:38:18 <chrisdone> mangaba_leitosa: if you're allowed you can try pasting the whole file. i want to try something ;)
04:40:46 <mangaba_leitosa> chrisdone: my file is a solution to an assignemnt for coursera/bioinformatics and coursera fordbids publishing solutions :-)
04:41:17 <mangaba_leitosa> chrisdone: so I need to extract the counting word frequencies part :-)
04:46:36 <evancz> What library is best for http communication from a command line project?
04:46:47 <evancz> There seem to be many options with lots of dependencies
04:47:01 <ocharles> Is there a standard name for 'asum . fmap pure' ?
04:47:08 <FreeFull> :t expr
04:47:09 <lambdabot> Expr -> Expr
04:47:11 <evancz> Is it reasonable to just use the network library?
04:47:14 <evancz> http://hackage.haskell.org/package/network-2.3.0.2/docs/Network.html
04:47:19 <donri> mangaba_leitosa: you could create a private paste and PM chrisdone, that's probably fine
04:47:40 <ocharles> asum . fmap pure :: Alternative f => [a] -> f a, for example
04:48:07 <donri> evancz: HTTP if you want something in the platform; http-{conduit,streams} if you need TLS
04:48:22 <evancz> TLS?
04:48:28 <donri> SSL
04:48:29 <donri> HTTPS
04:48:38 <evancz> gotcha
04:48:47 <evancz> thanks :)
04:49:09 <donri> ocharles: mconcat? :p
04:55:32 <chrisdone> mangaba_leitosa: oh, ok. i wanted a full paste to trry out a new paste feature with
04:56:41 <donri> clone in ide eh
04:57:12 <lpaste> mangaba_leitosa revised “word frequencies”: “word frequencies” at http://lpaste.net/95699
04:57:14 <mangaba_leitosa> chrisdone: ^ here is the version I prepared, having only the wordfreq function (using both Map and Hashtables)
04:57:27 <mangaba_leitosa> chrisdone: the Map version is 2.5 times slower
04:57:57 <mangaba_leitosa> chrisdone: it expects a file containing a long single line as input, and a word length
04:58:15 <mangaba_leitosa> chrisdone: you can test it using this: https://beta.stepic.org/media/attachments/lessons/4/E-coli.txt
04:58:44 <mangaba_leitosa> chrisdone: to be run like that: grg@thinkpad.4:~/coursera/bio$ ./frequent_words2 timesM 9 <E-coli.txt >output
04:59:31 <mangaba_leitosa> chrisdone: this will extract all possible 'words' (any sequence of chars) of length 9 and print their freqs
04:59:45 <mangaba_leitosa> chrisdone: 'timesM' is using hashtables (faster), 'times' is using Map (slower)
05:01:55 <mangaba_leitosa> chrisdone: for me it takes 5 seconds with "timesM" and 14 seconds with "times"
05:04:17 <chrisdone> mangaba_leitosa: let's see…
05:06:21 <mangaba_leitosa> chrisdone: and I compile it with  ghc -with-rtsopts='-H640m' -O2
05:12:25 <chrisdone> mangaba_leitosa: they're pretty much the same speed here. 11secs vs 10secs
05:12:52 <chrisdone> mangaba_leitosa: probably an IO thing
05:13:00 <mangaba_leitosa> chrisdone: try >/dev/null :-)
05:13:20 <mangaba_leitosa> chrisdone: how can it be, anyway? for me it's 5 secs vs. 14 :_)
05:14:06 <mangaba_leitosa> chrisdone: or try to disable printing the list, print just 'length'
05:14:07 <chrisdone> chris@retina:~/Projects/corebot/src$ time (./freqs timesM 9 < e.txt > /dev/null)
05:14:08 <chrisdone> real	0m11.586s
05:14:08 <chrisdone> chris@retina:~/Projects/corebot/src$ time (./freqs times 9 < e.txt > /dev/null)
05:14:08 <chrisdone> real	0m10.874s
05:14:24 <mangaba_leitosa> chrisdone: something wrong with your I/O indeed :_)
05:14:47 <mangaba_leitosa> chrisdone: or maybe you have an older verrsion of hashtables
05:15:50 <mangaba_leitosa> chrisdone: or maybe little free memory?
05:16:20 <chrisdone> i didn't have to adjust the memory in ghc. i have 16gb of memory and an ssd, i doubt the problem is my machine
05:16:24 <mangaba_leitosa> chrisdone: note that for me it only gives this performance with -H640 MB and when there is enough free memory for both the app and OS cache buffers
05:16:26 <chrisdone> i'm using containers-0.5.3.1 and hashtables-1.0.1.8
05:16:27 <chrisdone> you?
05:17:03 <mangaba_leitosa> chrisdone: hashtables-1.1.0.2. then my is older :-)
05:17:26 <chrisdone> and ghc 7.4.2.9
05:17:42 <donri> hashable version matters also
05:17:48 <mangaba_leitosa> chrisdone: GHC 7.6.3 here, and no 'containers' package
05:18:08 <chrisdone> no containers package?
05:18:09 <donri> Map is from containers
05:18:13 <chrisdone> ghc-pkg list containers
05:18:25 <mangaba_leitosa> donri: it seems to be part of GHC in my version
05:18:39 <donri> sure
05:19:00 <mangaba_leitosa> donri: that is, I didn't install it as a package
05:19:02 <chrisdone> could try out upgrading hashtables
05:19:28 <mangaba_leitosa> chrisdone: but my hashtables is older. If I upgrade, performance will worsen from 5 secs to 11 :_)
05:19:29 * chrisdone looks at the algorithm
05:19:49 <donri> i suspect hashable version matters more than hashtables here
05:19:54 <donri> because siphash
05:20:56 <chrisdone> mangaba_leitosa: hmm, yeah, i think there's room for improvement in the algo here. let me try fiddling
05:21:02 <Hodapp> siphash sounds like a mutant STD.
05:29:00 <alFReD-NSH> Hi guys, I'm writing a function which will accept an array of functions
05:29:23 <alFReD-NSH> Will call the functions one by one and returns true when the first function returned true
05:29:27 <alFReD-NSH> else return false
05:29:50 <alFReD-NSH> Any idea what to call this function?
05:29:57 <donri> :t all
05:29:59 <lambdabot> (a -> Bool) -> [a] -> Bool
05:30:00 <donri> :t and
05:30:02 <lambdabot> [Bool] -> Bool
05:30:31 <s2r2> sounds more like "any" to me
05:30:32 <s2r2> :t any
05:30:34 <lambdabot> (a -> Bool) -> [a] -> Bool
05:31:34 <donri> :t or . map ($ a)
05:31:35 <lambdabot> [Expr -> Bool] -> Bool
05:31:42 <monoidal> any ($a
05:31:44 <khyperia> isn't any the same as "any fs xs = or $ zipWith ($) fs xs"?
05:31:45 <monoidal> any ($a)
05:32:10 <donri> :t any ($ a)
05:32:11 <lambdabot> [Expr -> Bool] -> Bool
05:32:54 <khyperia> :t \a -> or . map ($ a)
05:32:55 <lambdabot> a -> [a -> Bool] -> Bool
05:33:11 <monoidal> alFReD-NSH: do you want to call all the functions in the list with the same argument?
05:33:24 <monoidal> donri: or . map f == any f
05:33:36 <donri> yes
05:33:42 <alFReD-NSH> monidal: Actually yeah
05:34:07 <khyperia> oh, yeah
05:34:10 <alFReD-NSH> Basically no argument
05:34:26 <monoidal> alFReD-NSH: so those are not functions, but booleans?
05:34:56 <alFReD-NSH> In haskell yes
05:34:58 <monoidal> alFReD-NSH: use "or" like so:
05:35:04 <monoidal> > or [False, False, True]
05:35:06 <lambdabot>   True
05:35:12 <alFReD-NSH> Well here's comes the tricky part, I'm writing it in javascript.... That's why I need a clever name for it
05:35:41 <miibotree> hello every one ,I am a newer to learn haskell....
05:35:50 <khyperia> can't you just use the Prelude or function?
05:35:51 <ErikBjare_> alFReD-NSH: in_any?
05:36:00 <ErikBjare_> if*
05:36:04 <monoidal> alFReD-NSH: "disjunction", "multior"
05:36:50 <alFReD-NSH> monoidal: never heard those works... I'm just gonna use any
05:36:59 <alFReD-NSH> Thanks guys
05:37:31 <monoidal> alFReD-NSH: check whether javascript has a built-in for this. it should.
05:37:37 <alFReD-NSH> no
05:37:52 <alFReD-NSH> not for array of functions
05:38:03 <monoidal> ok
05:38:08 <khyperia> I thought you said "no argument"
05:38:25 <mangaba_leitosa> chrisdone: any luck? :-)
05:38:32 <alFReD-NSH> function any() { return arr.some(function (someFn) { return someFn() } }
05:38:47 * hackagebot metadata 0.1.5.0 - metadata library for semantic web.  http://hackage.haskell.org/package/metadata-0.1.5.0 (KatsutoshiItoh)
05:39:08 <khyperia> oh, wait, this isn't haskell compiled to js, it's just js?
05:39:09 <khyperia> Oh.
05:39:48 <alFReD-NSH> in javascript there are functions that take no arguments...
05:39:56 <alFReD-NSH> Unlike coolness of haskell :P
05:44:35 <rerecord> newtype Writer w a = Writer {newWriter :: (a, w)}
05:44:44 <rerecord> :t Writer
05:44:45 <lambdabot>     Not in scope: data constructor `Writer'
05:44:45 <lambdabot>     Perhaps you meant `WriterT' (imported from Control.Monad.Writer)
05:45:01 <rerecord> :t WriterT
05:45:02 <lambdabot> m (a, w) -> WriterT w m a
05:45:19 <donri> :t runWriterT
05:45:20 <lambdabot> WriterT w m a -> m (a, w)
05:46:48 <rerecord> can someone explain this syntax newtype Writer w a = Writer {newWriter :: (a,w)}
05:46:59 <Iceland_jack> rerecord: Are you familiar with the record syntax?
05:47:03 <rerecord> how do i use the type constructor
05:47:19 <Iceland_jack>     data Person = MkPerson { name :: String, age :: Int }
05:47:31 <rerecord> yes, im a little confused with the type of Writer type constructor.
05:47:40 <Iceland_jack> rerecord: check out the type of ‘Writer’
05:47:57 <rerecord> (a, w) -> Writer w a
05:48:04 <Iceland_jack> then check out the type of ‘newWriter’
05:48:20 <simukis_> Iceland_jack: why tease?
05:48:24 <simukis_> :t newWriter
05:48:25 <lambdabot> Not in scope: `newWriter'
05:48:29 <simukis_> 😞
05:48:30 <rerecord> newWriter :: Writer w a -> (a, w)
05:48:32 <Iceland_jack> simukis_: Tease? :)
05:48:43 <simukis_> Iceland_jack: never mind.
05:48:45 <Iceland_jack> rerecord: It's just for wrapping and unwrapping
05:49:14 <Iceland_jack>     newtype MyInt = MyInt { getInt :: Int }
05:49:14 <Iceland_jack> Then MyInt is a function which wraps an Int: MyInt :: Int -> MyInt
05:49:27 <Iceland_jack> and getInt ‘unwraps’ a MyInt: getInt :: MyInt -> Int
05:50:14 <rerecord> I did check the types, but I find it counter intuitive.. like why is the Writer typeconstructor taking a tuple instead of two arguments.. i guess i should reread the record syntax
05:50:38 <Iceland_jack> rerecord: Get more familiar with the record syntax and try it with simpler examples than ‘(a, w)’
05:50:41 <rerecord> ohhhh
05:50:44 <rerecord> i got it now
05:50:50 <Iceland_jack> OK good :)
05:51:02 <donri> data Writer w a = Writer w a  -- it could just as well be this
05:51:48 <rerecord> rhs is where type constructor is..
05:51:48 <monoidal> rerecord: it takes a tuple because it's a newtype, if it was a datatype it could take two arguments
05:51:54 <donri> technically it could just be (w,a), not sure why that's not a Monad with a Monoid constraint
05:53:03 <rerecord> so newtypes can only have type constructors that take one argument?
05:53:36 <Iceland_jack> rerecord: Yes, it's mostly for efficiency
05:53:36 <donri> a newtype wraps a single other type and the wrapper is optimized away during compilation
05:53:38 <monoidal> a newtype must have exactly one constructor, and that constructor must take exactly one argument
05:54:47 <cariveri> hi. does aqnyone know the "dr. haskell" parody? I think its german.
05:54:48 <rerecord> newtypes are used when our type has more than one implementation of a typeclass? is this why newtypes are introduced?
05:54:58 <chrisdone> mangaba_leitosa: hmm, no luck here
05:55:07 <merijn> rerecord: Well, not the only reason, but that's a common use, yes
05:56:09 <merijn> rerecord: Another is to have "checked" values like "newtype Nat = Nat Int", now if you don't export the Nat constructor, but only a function "Int -> Maybe Nat" which checks that the Int is positive, you now have a type for "postive integers"
05:56:09 <dwcook> rerecord, you also might use newtypes to make conversion between distinct units explicit, rather than accidentally, say, using feet where meters were required.
05:56:49 <merijn> rerecord: Since at runtime Nat is just an Int, there is no overhead, but it's still more typesafe, since passing an Int to a function expecting Nat is a type error
05:58:03 <chrisdone> mangaba_leitosa: oh wait. messed up my testing
05:58:30 <mangaba_leitosa> chrisdone: how? :-)
05:58:36 <rerecord> yeah, i get it now.. in that case type synonyms are useless.
05:58:47 <merijn> rerecord: Exactly
05:58:55 <rerecord> i was slightly disappointed when type synonyms are liberal in taht way
05:59:02 <rerecord> when i realized
05:59:12 <donri> type synonyms can be useful documentation. they don't improve type safety or give you more expressive power, though
05:59:32 <merijn> rerecord: But because newtypes have no constructors at runtime (i.e. their constructors are a typechecking thing only) there's no way to pass multiple values to a newtype constructor
05:59:33 <dwcook> Type synonyms (that have parameters) are effectively functions over types.
05:59:53 <dwcook> You can still invent a value of the result type with something else aware of that type.
06:00:00 <merijn> donri, rerecord: And of course type synonyms are nice to abstract away really long/complex function types
06:00:35 <merijn> like "type Handler a = a -> Foo -> Bar -> FooHandler -> a -> IO ()" or some such
06:01:07 <donri> rerecord: in this case though, Writer isn't a newtype but a type synonym for WriterT with Identity, and WriterT needs to be defined in terms of tuples because it needs to be wrapped in the parametric monad
06:02:02 <rerecord> i am reading about Writer monad, and hes explaining writer monad by implementing it i guess
06:02:19 <chrisdone> magneticduck: yeah, it seems we're constrained by the hash table implementation
06:02:59 <donri> chrisdone: not hashable?
06:03:00 <merijn> rerecord: Yeah, the LYAH version of Writer used to exist, but has been replaced by a more general version that uses the WriterT monad transformer. The API is still correct, with the one difference that the "Writer" constructor has been replaced with the "writer" function
06:03:03 <mangaba_leitosa> chrisdone: but did you figure out how to make hashtable faster on your system?
06:03:09 <rerecord> i dont yet know what WriterT is
06:03:13 <mangaba_leitosa> chrisdone: downgrade? :-)
06:03:30 <chrisdone> mangaba_leitosa: ah, not tried yet
06:03:34 * chrisdone tries
06:03:38 <monoidal> rerecord: for now, you can disregard WriterT and think only about Writer w a = Writer (w, a)
06:03:43 <donri> guys why don't you tell me what hashable version you're each using
06:03:49 <chrisdone> hashable-1.2.1.0
06:04:05 <merijn> rerecord: It's a monad transformer, it lets you "wrap" writer functionality around an existing monad. But you can ignore it for now, as long as you remember that the "Writer :: (w, a) -> Writer w a" constructor was replaced by "writer :: (w, a) -> Writer w a" function
06:04:07 <mangaba_leitosa> donri: hashable-1.1.2.5
06:04:26 <merijn> rerecord: (The same goes for state/State and reader/Reader respectively)
06:04:35 <chrisdone> donri: is hashable the one that tibbe reverted that big change on?
06:05:54 <donri> monoidal: well i think the question is why it isn't data Writer w a = Writer w a, which it perfectly well could be, and i think the answer is either "because WriterT" or "because other monads are newtypes to show symmetry"
06:05:56 <mangaba_leitosa> chrisdone: so, both my hashable and hashtables are older...
06:06:17 <donri> chrisdone, mangaba_leitosa : hm ok neither of you should have a siphash version methinks
06:07:14 <donri> chrisdone: yes, bos added siphash for security, people cried for performance, and now it seems to be removed
06:07:51 <donri> chrisdone: although maybe you're thinking of the other change where they made the base salt runtime randomized, which made people cry for purity ;)
06:08:07 <rerecord> haskell does have a deep learning curve.. what are monad transformers? it get a little taken aback every time i come across a new word in haskell
06:09:02 <chrisdone> donri: yeah
06:09:21 <merijn> rerecord: The idea behind monad transformers is: "I have the IO monad, but gosh-darnit! I wish I had a weird IO Writer hybrid so I could use both!"
06:09:23 <donri> rerecord: it's just a monad that takes another monad as a parameter and then wraps inside it
06:10:00 <merijn> rerecord: Enter WriterT, which can "transform" to also support Writer behaviour. So you work with "WriterT w IO a" which can do both Writer and IO stuff
06:10:36 <donri> rerecord: and Identity is the monad that adds no structure, so when you embed one monad in identity you get back the "plain" version ie. WriterT + Identity = Writer
06:10:55 <merijn> Identity is "newtype Identity a = Identity a"
06:10:57 <chrisdone> mangaba_leitosa: i at least brought my 12 seconds down to 8.9 seconds by using Data.IntMap + Data.Hashable
06:11:43 <merijn> With the monad "return x = Identity x; Identity x >>= Identity f = Identity (f x)"
06:11:45 <mangaba_leitosa> chrisdone: aha, so with hashtables it must be even faster if I use Int key?
06:12:05 <mangaba_leitosa> chrisdone: but won't there be duplicate keys?
06:12:07 <merijn> rerecord: So people figured, rather than have WriterT and Writer, we could just define Writer as WriterT + Identity
06:12:12 <chrisdone> mangaba_leitosa: hmm, possibly it's the same? i presume Data.Hashable = Data.IntMap + Data.Hashable
06:12:28 <donri> surely there's a good link on transformers somewhere...
06:12:31 <mangaba_leitosa> chrisdone: 'Data.Hashable = Data.IntMap + Data.Hashable' ?
06:12:45 <mangaba_leitosa> chrisdone: in this case, Data.IntMap is zero
06:13:10 <merijn> rerecord: Otoh, it's not that crucial to understand monad transformers when just starting out
06:13:31 <merijn> :t writer
06:13:33 <lambdabot> MonadWriter w m => (a, w) -> m a
06:13:35 <merijn> hmm
06:13:40 <merijn> Not what I was going for :p
06:13:48 <merijn> :t Control.Monad.Trans.Writer.writer
06:13:49 <lambdabot> Monad m => (a, w) -> WriterT w m a
06:13:51 <donri> i really recommend against mtl if you're learning monad transformers
06:13:57 <donri> yeah
06:14:32 <merijn> :t Control.Monad.Trans.Writer.writer :: (a, w) -> Writer w a
06:14:33 <lambdabot> (a, w) -> Writer w a
06:14:38 <chrisdone> mangaba_leitosa: hm, the API of hashtable mandates Hashable instances
06:14:47 <merijn> There we go
06:14:48 <deweyvm> in general what does "Overlapping instances for <typeclass>" mean?
06:15:02 <chrisdone> mangaba_leitosa: so if there are collisions in the Hashable instance, the Hashtable will also have collisions
06:15:02 <merijn> deweyvm: You have to instances that can apply to the same types
06:15:05 <bearclaw> rerecord: at this point it's not realy haskell as the language but its libraries, but a kind of very generic library that can factor a lot of code
06:15:23 <donri> deweyvm: two or more instances would unify with the same type
06:15:24 <bearclaw> I think if you start coding in haskell without learning monad transformers first, at some point you will *need* it
06:15:34 <mangaba_leitosa> chrisdone: but then it seems that using Int for a ByteString is garanteed to generate duplicates sooner or later?
06:15:35 <merijn> bearclaw: s/need/want
06:16:19 <deweyvm> ahhh
06:16:41 <deweyvm> is there a way to make a specific type (say String) override another ([Char]) ?
06:16:52 <deweyvm> instance*
06:16:55 <rerecord> i use python for simple scripting tasks, do you recommend using runhaskell for the same?
06:16:56 <merijn> deweyvm: String and [Char] are identical
06:17:00 <donri> chrisdone: did you mean HashMap = IntMap + Hashable? if so i think no, it's more specialized than that
06:17:02 <chrisdone> mangaba_leitosa: hmm, looking at the implementation, it seems to use both Hashtable and Eq instances, so i'm not sure. seems to be an optimization
06:17:10 <stbuehler> i have a very long lazy bytestring (32MB long, each chunk has 8 bytes). I convert it to a list (toChunks), and foldl over it. The problem is: i foldl more than once, and i'd like the list to be generated each time (which is fast) instead of keeping it in memory (which takes a lot of space)
06:17:18 <merijn> deweyvm: There are several approaches, one of the most common way to "replace" a typeclass instance is by using a newtype
06:17:21 <chrisdone> mangaba_leitosa: http://hackage.haskell.org/package/hashtables-1.0.0.0/docs/src/Data-HashTable-ST-Cuckoo.html#lookup
06:17:28 <skypers_> ohai
06:17:32 <stbuehler> is there any way to not keep the evaluated chunks in memory?
06:17:34 <donri> chrisdone: though actually there's a hashmap package that does that exactly
06:17:47 <chrisdone> mangaba_leitosa: e.g. see searchOne
06:17:55 <HugoDaniel> hi
06:17:57 <skypers_> ok today I understand for good profunctors
06:18:07 <quchen> stbuehler: Why don't you fold over the BS directly?
06:18:12 <HugoDaniel> whats the best way to create a Text datatype that is limited to a certain number of characters ?
06:18:23 <quchen> stbuehler: Data.ByteString.Lazy.foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
06:18:25 <chrisdone> mangaba_leitosa: from what i can gather there, it uses the int generated from the hash as a kind of optimistic lookup and then double checks that the keys match
06:18:27 <merijn> HugoDaniel: newtype + smart constructor?
06:18:45 <chrisdone> mangaba_leitosa: so i think it has no collisions
06:18:56 <mangaba_leitosa> chrisdone: ah, nice :-)
06:19:08 <stbuehler> quchen: i use mapM_ on it with some io action
06:19:15 <chrisdone> at any rate, yeah looks like this is the best we have at present
06:19:25 <HugoDaniel> merijn: something like this: http://hackage.haskell.org/package/special-keys-0.1.0.3/docs/Keys-Constraints.html  ?
06:19:52 <mangaba_leitosa> chrisdone: I wanted to try Judy... here it's described as the fastest method: http://blog.malde.org/posts/frequency-counting.html
06:19:55 <stbuehler> quchen: nettleUmacUpdateLazy in https://github.com/stbuehler/haskell-nettle/blob/master/src/Crypto/Nettle/UMAC.hs#L130 is the thing that evaluates it
06:20:08 <mangaba_leitosa> chrisdone: but it only supports Int keys, so I'm not sure how to go about thi
06:20:14 <stbuehler> i basically need a way to unshare the lazy bytestring
06:20:27 <mangaba_leitosa> chrisdone: also, how do you deal with duplicates in the case of IntMap?
06:20:28 <chrisdone> mangaba_leitosa: aha
06:21:29 <skypers_> hey I don't find the "I love profonctors" link anymore
06:21:32 <skypers_> anyone?
06:21:38 <quchen> Should be easy.
06:21:43 <quchen> Ba dum tsh
06:21:55 <rerecord> is there a place where i can learn to solve algorithmic problems using haskell, like dynamic programming, graph searches etc..
06:22:12 <quchen> stbuehler: Sounds like you want to stream the ByteString instead of generating it in its entirety. Hmm.
06:22:16 <quchen> stbuehler: Pipes? :-)
06:22:22 <donri> skypers_: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
06:22:36 <mangaba_leitosa> chrisdone: can you show your IntMap based version? Will it have collisions?
06:22:38 <chrisdone> mangaba_leitosa: hmm that sounds cool
06:23:02 <chrisdone> mangaba_leitosa: yeah, but i think it's not that fast, hang on i'll paste
06:23:26 <rerecord> i see people solving hard problems using haskell in places like hackerrank etc.. i want to get started..
06:23:27 <skypers_> thank you donri
06:23:48 <lpaste> chrisdone pasted “IntMap” at http://lpaste.net/95702
06:24:29 <mangaba_leitosa> chrisdone: thanks. so, what about collisions?
06:24:49 <chrisdone> mangaba_leitosa: not sure -- looking at the instance
06:26:13 <chrisdone> mangaba_leitosa: yeah i expect it's going to collide
06:26:37 <chrisdone> mangaba_leitosa: looking at judy, that looks promising
06:27:19 <chrisdone> mangaba_leitosa: hmm, yeah, indeed -- it seems Judy will hash a bytestring using its memory address
06:27:50 <chrisdone> instance JE S.ByteString where
06:27:50 <chrisdone>     toWord b   = do
06:27:50 <chrisdone>         p <- newStablePtr b
06:27:50 <chrisdone>         case castStablePtrToPtr p of
06:27:51 <mangaba_leitosa> chrisdone: Judy refuses to work with ByteString, only works with numbers
06:27:53 <chrisdone>              Ptr a# -> return $! W# (int2Word# (addr2Int# a#))
06:28:14 <mangaba_leitosa> chrisdone: hmm, where did you get this code?
06:28:34 <chrisdone> http://hackage.haskell.org/package/judy-0.2.2/docs/Data-Judy.html#7
06:29:41 <mangaba_leitosa> chrisdone: thanks, somehow I missed it and got an impression that it only supports numbers
06:30:00 <chrisdone> right, it seems that it does only support words, but has the nice conversion func to get them
06:30:02 * chrisdone tries it
06:30:04 <mangaba_leitosa> chrisdone: but if hashing by ptr, it will hash identical strings as different keys? :-(
06:30:38 <chrisdone> mangaba_leitosa: hmm, right
06:31:40 <tarruda> what options I have for securely running javascript code within haskell?
06:31:50 <mangaba_leitosa> chrisdone: also, the URL about the wordfreq task above says that the best benchmark result are with a modified Judy version having the insertWith method (the link is given)
06:32:32 <mangaba_leitosa> chrisdone: I downloaded this version and uncommented the insertWith method, for some reason it is commented out (likely a bug found)
06:36:10 <chrisdone> mangaba_leitosa: it would be interesting to make a fast bytestring-specific hashtable, but i think that's another project entirely
06:38:44 <donri> mwahahah bare writer monad with obfuscating view patterns ;)     ~(w,a) >>= (($ a) -> ~(w',b)) = (w <> w',b)
06:38:44 <chrisdone> http://hg.python.org/cpython/file/52f68c95e025/Objects/dictobject.c
06:39:01 <chrisdone> i don't know what idiot created the theme for this source viewer, but anyway
06:39:52 <kryft> You mean the colors?
06:40:03 <chrisdone> the lines are line a zebra crossing
06:40:14 <kryft> Admittedly not the most readable theme
06:40:59 <kryft> chrisdone: Well you see that way your gaze doesn't accidentally slip onto the next line before it reaches the end!
06:41:11 <kryft> chrisdone: I think there's a joke about python programmers here somewhere
06:42:07 <chrisdone> it was an assault on my senses, i opened the chrome developer tab and disabled the css property
06:42:53 <deweyvm> probably inspired by IDLE
06:43:16 <deweyvm> which nothing should be
06:46:42 <mangaba_leitosa> chrisdone: I just tried TrieMap... turned out to be slower than Map
06:47:22 <chrisdone> lol
06:53:47 <chrisdone> mangaba_leitosa: how about you use an IntMap or Vector with Int for the key, using Hashable, with the actual ByteString + count tuple as the value. then you do as: 1) lookup the (ByteString,Int), 2) do a comparison of the ByteString you used to lookup and the one you received, and if they're different then apply some transformation to the key Int and repeat the process
06:53:57 * hackagebot lord 1.20131115 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-1.20131115 (rnons)
06:55:12 <chrisdone> mangaba_leitosa: which i think is a dumb version of how python's hashtables work
06:56:07 <skypers_> ok I understand what a contravariant functor is, but I don't get how we could use it
06:57:27 <mangaba_leitosa> chrisdone: yes, I think that something like that is possible... Also, I'm not sure whether castStablePtrToPtr really makes different pointers for equal ByteStrings
06:57:37 <mangaba_leitosa> chrisdone: I'm now trying it with Judy
06:57:43 <mangaba_leitosa> chrisdone: but here is what I have:
06:58:03 <mangaba_leitosa> ghci> do j  <- J.new::IO (J.JudyL ByteString); return j
06:58:03 <mangaba_leitosa> <Judy a>
06:58:04 <mangaba_leitosa> (woorks)
06:58:15 <mangaba_leitosa> ghci> do j  <- J.new::IO (J.JudyL ByteString); J.insert (S.pack "foo") 1; print "Hello"
06:58:32 <mangaba_leitosa> Couldn't match type `ByteString' with `GHC.Types.Word'
06:58:35 <mangaba_leitosa> (doesn't)
06:58:48 <mangaba_leitosa> chrisdone: 'S' is ByteString.Char8 here
07:00:05 <mangaba_leitosa> chrisdone: so, despite of an instance for ByteString being there, it doesn't seem to work for ByteString.Char8
07:00:37 <chrisdone> mangaba_leitosa: lemmie try
07:03:30 <roconnor> does eta-reduction mean removing the lambdas, thus making it smaller, or does eta-reduction mean adding in lambdas, thus making it closer to eta-long normal form?
07:03:33 <mangaba_leitosa> chrisdone: btw I forgot to add 'j' in the code above...  Must be 'J.insert (S.pack "foo") 1 j'
07:13:36 <mangaba_leitosa> chrisdone: I, got it. I need to use J.toWord to get the key
07:13:45 <chrisdone> mangaba_leitosa: ah, we can't use judy for the collision detection without writing an instance for tuples
07:14:03 <chrisdone> i'll try with vector first
07:14:46 <mangaba_leitosa> chrisdone: yes, but will be there real collistions with 'Judy.toWord bytestring'?  I'm not sure
07:15:19 <mangaba_leitosa> chrisdone: maybe castStablePtrToPtr checks for equality and generates identical pointers for identical strings?
07:15:19 <chrisdone> mangaba_leitosa: more the opposite of collisions, different keys for the same values, i think
07:15:27 <mangaba_leitosa> chrisdone: ah, right
07:16:14 <emaphis> mangaba_leitosa: hi.
07:16:30 <mangaba_leitosa> emaphis: hi
07:16:47 <mangaba_leitosa> chrisdone: I, just verified it. Yes, J.toWord (S.pack "foo") generates a new value each time it's used
07:16:51 <blochchain> is there a general consensus on which is the best Haskell-ish language that compiles to javascript? There are so many
07:17:12 <chrisdone> mangaba_leitosa: right, whereas:
07:17:13 <chrisdone> λ> hash "hello" → 7027304812981075268
07:17:13 <chrisdone> λ> hash "hello" → 7027304812981075268
07:17:38 <chrisdone> restarting the process and running it again yields the same value. so that's content-based
07:17:43 <mangaba_leitosa> chrisdone: yes, but this one will have collisions :-)
07:17:54 <chrisdone> right, so that's why do we do the collision detection
07:17:57 <chrisdone> trying it with vector now
07:20:37 <mangaba_leitosa> chrisdone: btw, generating a new value by J.toFord "foo" outside a monad, should it be even allowed? :-)
07:21:00 <mangaba_leitosa> chrisdone: J.toWord even
07:21:27 <mangaba_leitosa> chrisdone: ah, it's in I/O monad, ok
07:21:37 <chrisdone> ja =)
07:26:56 <k00mi> blochchain: I don't think so, but with GHCJS you have not a Haskell-ish language but actual GHC Haskell with all the cool stuff like STM
07:27:08 <k00mi> I don't think any of the alternatives has that
07:28:33 <quchen> STM is GHC-Haskell, not strictly Haskell, though.
07:32:04 <merijn> blochchain: ghcjs for best library support, afaik it supports pretty much all non-OS specific libraries
07:32:52 <merijn> blochchain: Also, note that UHC and GHCJS both compile actual haskell to JS. Fay compiles a different language whose syntax is a subset of Haskell to JS
07:33:04 <merijn> blochchain: i.e. all Fay is valid haskell, but not all Haskell is valid Fay
07:33:55 <blochchain> interesting
07:34:09 <blochchain> i didn't know how complete GHCJS was
07:34:40 <merijn> blochchain: It supports all GHC extensions and everything, it's really cool :)
07:34:54 <scriptor> does fay have any advantages over ghcjs?
07:35:31 <merijn> scriptor: Less complex, maybe doesn't require a runtime system, thus less overhead?
07:35:49 <scriptor> ah, what's involved with ghcjs's runtime?
07:36:23 <merijn> scriptor: Well, it does lightweight threading, STM and everything
07:36:35 <scriptor> ah
07:36:39 <merijn> blochchain: Oh, right. Another thing, ghcjs supports forkIO threads too :)
07:36:41 <scriptor> Fay's wiki also points to http://www.reddit.com/r/haskell/comments/1ldqav/thoughts_on_uhc_vs_haste_vs_fay/
07:37:42 <chrisdone> http://www.reddit.com/r/haskell/comments/1ldqav/thoughts_on_uhc_vs_haste_vs_fay/cbyrhwz
07:43:51 <scriptor> ah, so ghcjs converts the STG to js
07:47:03 <msafi> In what applications is Haskell most commonly used?
07:47:21 <quchen> @quote Jafet research
07:47:22 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
07:47:22 <lambdabot> s, phone apps, and web services.
07:47:41 <donri> it's mostly used for computing the fibonacci sequence
07:47:47 <Eduard_Munteanu> msafi: it's a general purpose high-level language
07:47:51 <Eduard_Munteanu> Heh.
07:47:52 <quchen> donri: … exponentially!
07:48:02 <joelteon> haskell is really good at "quicksort"
07:48:14 <chrisdone> scriptor: haste also does that
07:50:59 <msafi> So, if I want to build a phone all or a consumer product using Haskell, has someone built an API that works well with Haskell?
07:51:08 <msafi> s/all/app/
07:52:12 <Eduard_Munteanu> Is this a more general thing? unwind :: Applicative f => (f (Free f a) -> (f (Maybe a), Free f a)) -> Free f a -> [f (Maybe a)], such that 'fmap catMaybes . sequence . unwind f' gives you an 'f a' as if you used 'f' directly, instead of Free f a?
07:52:33 <rerecord> let fn l r = takeWhile (<r) $ zipWith (+) (repeat l) (zipWith (*) (repeat 0.001) [0..])
07:52:44 <rerecord> is there a better way of doing this?
07:53:02 <rerecord> I cant do [l, l+0.001..]
07:53:22 <monoidal> rerecord: zipWith f (repeat a) b = map (f a) b
07:53:51 <Eduard_Munteanu> > iterate (+ 0.001) l
07:53:52 <lambdabot>   [l,l + 1.0e-3,l + 1.0e-3 + 1.0e-3,l + 1.0e-3 + 1.0e-3 + 1.0e-3,l + 1.0e-3 +...
07:54:03 <quchen> Eww, iterating +Double
07:54:34 <chrisdone> can someone try cloning this into the ide and running it? http://lpaste.net/3444975980878233600
07:54:34 <Eduard_Munteanu> quchen: his 'fn' did the same, really.
07:54:42 <chrisdone> donri: can you try that?
07:54:54 <quchen> Eduard_Munteanu: Right. But there were other problems there as well.
07:54:57 <donri> not sure i have an account, hm
07:55:19 <chrisdone> donri: you should be able to use your google account, or it'll ask to confirm an email, but that's all, it /should/ take you straight into the ide after that
07:55:19 <donri> oh i do
07:55:38 <donri> i thought the ide cost monies
07:55:46 <chrisdone> it's now free =)
07:56:01 <donri> it's free for now or from now? :P
07:56:25 <quchen> Eduard_Munteanu: Actually no, the zip-based code does not do that. It multiplies 0.001 with a number, and then adds that. Your version repeatedly adds 0.001.
07:56:44 <Eduard_Munteanu> Oh, yeah.
07:57:07 <donri> chrisdone: anyway seems to have worked. i logged in, it remembered to take me to water, running it outputs 10
07:57:21 <quchen> > (sum (replicate 100 0.001),  0.001*100) -- Eduard_Munteanu
07:57:22 <lambdabot>   (0.10000000000000007,0.1)
07:57:24 <khyperia> I had an idea for [1.0..] syntax, specifically for doubles. Because the digits can never have more decimal points than the original number, why not do a round call after every addition, with rounding places set to the number of decimals in the literal?
07:57:26 <chrisdone> donri: free from now on, the base IDE version is the community edition. for git integration & deployment it's the 9.99/mo
07:57:36 <donri> aha
07:57:37 <Eduard_Munteanu> [ l + n * 0.001 | n <- [1..] ]
07:57:40 <Eduard_Munteanu> > [ l + n * 0.001 | n <- [1..] ]
07:57:41 <lambdabot>   [l + 1 * 1.0e-3,l + 2 * 1.0e-3,l + 3 * 1.0e-3,l + 4 * 1.0e-3,l + 5 * 1.0e-3...
07:57:48 <chrisdone> donri: sweet! thanks
07:57:49 <Eduard_Munteanu> > [ l + n * 0.001 | n <- [0..] ]
07:57:51 <lambdabot>   [l + 0 * 1.0e-3,l + 1 * 1.0e-3,l + 2 * 1.0e-3,l + 3 * 1.0e-3,l + 4 * 1.0e-3...
07:57:56 <quchen> khyperia: The numbers can have more decimals than the original number.
07:58:04 <quchen> > [0.1, 0.2 ..] -- khyperia
07:58:05 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600000...
07:58:26 <khyperia> except that's double inaccuracy
07:58:31 <quchen> And?
07:58:32 <khyperia> so why not slap in a round to remove it?
07:58:40 <danilo2> Hello! I really need your help :( I'm not windows user and I have to create a cross platform Haskell program. everything works on Linux, but when I'm trying to setup cabal sandbox on Windows it gives some strange errors: http://lpaste.net/95705
07:58:53 <rerecord> what is the ide you are talking about?
07:58:56 <Eduard_Munteanu> You need to do it consistently across ABIs.
07:59:03 <chrisdone> rerecord: https://www.fpcomplete.com/
07:59:24 <quchen> khyperia: Having an integer-based list that is converted to a list of Doubles would be much cleaner.
07:59:49 <quchen> > map (/ 10^3) [0 :: Int, 1..]
07:59:51 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
07:59:51 <lambdabot>    arising from a use o...
07:59:53 <khyperia> *Something* like that would be good. I dislike the current version that allows it to go all wonky
08:00:02 <quchen> > map ((/ 10^3) . fromIntegral) [0 :: Int, 1..]
08:00:03 <lambdabot>   [0.0,1.0e-3,2.0e-3,3.0e-3,4.0e-3,5.0e-3,6.0e-3,7.0e-3,8.0e-3,9.0e-3,1.0e-2,...
08:00:12 <quchen> Something like that.
08:00:23 <monoidal> danilo2: maybe "ghc-pkg recache" or "ghc-pkg --global recache" solves it?
08:00:23 <quchen> In other words, add the Double inaccuracy as late as possible.
08:00:31 <khyperia> exactly
08:00:32 <danilo2> and indeed, the index.tar file in the cabal sandbox is 10kb of zeros ...
08:00:44 <danilo2> monoidal - I'll try it
08:01:10 <Eduard_Munteanu> I wouldn't convert it to an actual Double, perhaps just a newtype.
08:01:31 <Eduard_Munteanu> Because you could be surprised by 2 /= fromDoubleList 2
08:01:47 <bennofs> chrisdone: Is there any way to get the code out of the IDE in case I use the free community edition?
08:03:01 <danilo2> Hmm where does cabal and ghc keep their settings on windows?
08:03:06 <danilo2> like ~/.cabal on linux?
08:03:44 <rerecord> appdata/roaming/ghc
08:04:04 <rerecord> users/username/appdata/roaming/ghc
08:04:39 <chrisdone> bennofs: that's the restriction for community -- if you want export to git, that's in the 9.99/mo personal edition. or if you get the trial which lasts a month. for now you'd have to manually copy things in/out
08:05:19 <bennofs> I see. I thought maybe there was something like "download source code archive" that I overlooked.
08:05:39 <chrisdone> :)
08:07:12 <emaphis> big NOOB question: should I use Helium to learn Haskell or should I use GHC?
08:07:37 <danilo2> monoidal: there is strange problem - when I'm making a sandbox and running cabal update, in the sandbox/packages folder I see only 2 files - 00-index.cache and 00-index.tar - bthe first one is empty and the second filled with 0. When I'm creating sandbox from scratch - this is always the result ....
08:07:38 <Eduard_Munteanu> emaphis: Haskell... Helium was just an experiment AFAIK.
08:08:05 <danilo2> monoidal: so this is connected with cabal update I think, because the cache downloaded from server is simply wrong
08:08:14 <danilo2> monoidal: am I right?
08:08:26 <emaphis> tnx, Eduard_Munteanu
08:08:41 <Eduard_Munteanu> emaphis: things like typeclasses you can ignore in Haskell too, for a start. Try reading LYAH.
08:08:44 <Eduard_Munteanu> @where lyah
08:08:44 <lambdabot> http://www.learnyouahaskell.com/
08:08:53 <Dodek> afair helium does not support typeclasses, so it's pretty much useless
08:09:01 <Dodek> for anything substantial
08:09:14 <emaphis> yeah, Im using LYAH. :-)
08:09:33 <monoidal> danilo2: sorry, I don't know. maybe someone else will.
08:10:26 <danilo2> monoidal: ok thank you :)
08:11:17 <danilo2> So hello, Does anybody know what is happening on my windows system (I'm a linux user and I have to develop something o n this stupid os ...)
08:11:20 <danilo2> there is strange problem - when I'm making a sandbox and running cabal update, in the sandbox/packages folder I see only 2 files - 00-index.cache and 00-index.tar - bthe first one is empty and the second filled with 0. When I'm creating sandbox from scratch - this is always the result ....
08:11:20 <chrisdone> emaphis: this might be a handy companion while going through LYAH https://www.fpcomplete.com/ see the middle screenshot, you can just select arbitrary expressions and see what the type of it is
08:11:31 <danilo2> more details: http://lpaste.net/95705
08:12:00 <chrisdone> hmm, cabal sandbox
08:12:17 <Eduard_Munteanu> danilo2: FWIW you could use Wine to "crosscompile" for Windows. You'll get some sort of sandboxing for free in the form of Wine's prefix.
08:12:19 <danilo2> chrisdone: it works perfect on linux
08:12:34 <jml> is there a built-in that does 'zip (map f xs) xs'?
08:12:50 <danilo2> Eduard_Munteanu: I know, but we have soem developers on Windows and thyey want to use it also, so wine is not an option here
08:12:58 <Eduard_Munteanu> jml: f &&& id
08:13:08 <Eduard_Munteanu> Er, no.
08:13:15 <chrisdone> map (f &&& id)
08:13:17 <Eduard_Munteanu> map (f &&& id)
08:13:19 <Eduard_Munteanu> Yeah.
08:13:31 <jml> nyah-ah
08:13:33 <jml> thanks.
08:13:54 <jml> (sorry, that was a melodrama villain laugh of victory, not a denial)
08:14:04 <emaphis> chrisdone: Thanks, fpcomplete looks pretty cool.
08:14:46 <chrisdone> :D
08:17:53 <Eduard_Munteanu> Actually I think I want  Applicative f => (f (Free f a) -> (f (), Free f a)) -> Free f a -> ([f ()], f a)
08:18:31 <Eduard_Munteanu> Basically splitting 'Free f a' into effects and result.
08:21:13 <danilo2> Ok, thank you all, I filled the issue here: https://github.com/haskell/cabal/issues/1582
08:21:29 <Dasuraga> Hey haskellers, trying to figure out parsec (looking at Real World Haskell's tutorial), what does the GenParser type mean?
08:21:53 <bartavelle> I believe that I reached feature completeness for version 1.0 of my language-puppet library. Now I'll just have to find a way to convince people to use it.
08:21:55 <danilo2> Dasuraga: General Parser
08:22:07 <Eduard_Munteanu> I'd say Generated Parser. :/
08:22:27 <danilo2> Eduard_Munteanu: Parsec is not generating parsers in any way.
08:22:30 <Eduard_Munteanu> It's a collection of token parsers generated from a LanguageDef.
08:22:49 <danilo2> Eduard_Munteanu: This is a DSL - there is no generation
08:23:06 <Dasuraga> So when we write GenParser Char st [[String]], I get that it takes a sequence of Chars to give [[String]], but what's up with the st?
08:23:13 <Eduard_Munteanu> danilo2: I was thinking of http://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Token.html
08:23:17 <monoidal> I believe it's "general" parser as opposed to normal Parser, which works only on strings/characters
08:23:36 <Eduard_Munteanu> But now I see that's actually "GenTokenParser".
08:23:37 <danilo2> Dasuraga: st is a user state of the parser - you do not have to use it right now
08:23:59 <danilo2> Eduard_Munteanu: exactly as monoidal tells
08:24:18 <Dasuraga> Alright I'll be patient, it's just I have a hard time when I can't identify why I have to write certain things
08:24:29 <Eduard_Munteanu> Ah, alright, I'm used to importing the Text variant directly.
08:29:10 * hackagebot GenI 0.24.3 - A natural language generator (specifically, an FB-LTAG surface realiser)  http://hackage.haskell.org/package/GenI-0.24.3 (EricKow)
08:30:49 <danilo2> As an offtopic does anyone works on Windows here? I'm wondering why this system cannot get more developer friendly and is a "box of shit" for so many years - I'm sorry for that, but I'm totally disgusted today by working on this microsoft product ...
08:32:54 <marko2> Hi all. a quick question regarding binary parsing using attoparsec: why is there no "skip n" function that lets me ignore the next `n` bytes? The closest I can find is "take n", but using this I have huge memory leaks
08:33:29 <marko2> I want to skip over a binary blob during parsing
08:33:36 <Dodek> danilo2: but it is very developer friendly
08:33:37 <emaphis> danilo2: loaded topic. :-)
08:33:45 <Dodek> danilo2: provided you go the microsoft way, though. :)
08:34:36 <danilo2> Dodek: yeah ...
08:35:34 <Eduard_Munteanu> marko2: void (take n)  shouldn't have leaks.
08:36:37 <jml> how do I interrupt the haskell repl in emacs?
08:37:12 <marko2> Eduard_Munteanu: thanks. I tried, but it is still leaking
08:37:20 <Rarrikins> marko2: You might be able to use anyWord8 a few times or samething.
08:37:28 <geekosaur> skip (take N) ?
08:37:43 <geekosaur> mm, maybe not
08:38:23 <marko2> It is still leaking. When I parse the blob instead of disacrding it with "take", there is no leak, but it is slow
08:38:24 <emaphis> jml:  ctrl-c ctrl-c ?
08:38:28 <Eduard_Munteanu> marko2: try using scan
08:39:01 <jml> emaphis: I'll give it a try, thanks.
08:39:12 <marko2> Eduard_Munteanu: I will try, hang on
08:41:17 <marko2> Eduard_Munteanu: scan does not help either
08:41:37 <Eduard_Munteanu> marko2: hm. How do you know the leak is caused by it?
08:41:42 <petermw> marko2: That must be some other problem - "take" should really reduce to "skip" after in-lining if you discard the rsult
08:42:28 <marko2> what other problem could it be? if I dont use "take" but rather parse the binary blob, there is no leak
08:43:09 <Eduard_Munteanu> marko2: are you doing lazy IO?
08:43:29 <marko2> Lazy bytestring readFile
08:43:45 <marko2> I am using Attoparsec.Bytestring.Lazy
08:43:56 <bennofs> mak`: does replicateM_ (void $ satisfy $ const True) leak too?
08:44:03 <Eduard_Munteanu> So it's not Parsec.
08:44:17 <bennofs> ehm, replicateM_ n ...
08:44:27 <Eduard_Munteanu> marko2: you should use strict BS with attoparsec, you can give it increments of input quite easily
08:44:50 <marko2> Isn't Attoparsec.ByteString.Lazy supposed to be doing the increments for me?
08:45:03 <Eduard_Munteanu> Even the chunks of a lazy BS.
08:46:06 <marko2> http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/src/Data-Attoparsec-ByteString-Lazy.html#parse
08:46:09 <Eduard_Munteanu> marko2: not sure... it might be attoparsec is mostly used in the strict configuration
08:46:32 <marko2> this function seems to be doing that
08:48:39 <marko2> or not?
08:48:59 <tonyt_> how to debug "Segmentation fault/access violation in generated code"?
08:49:20 <epta> Is there a way to install unix package inside cygwin?
08:49:53 <Eduard_Munteanu> epta: with cabal perhaps?
08:50:20 <Eduard_Munteanu> marko2: yeah... you should try profiling.
08:50:44 <lpaste> epta pasted “cabal install unix” at http://lpaste.net/95708
08:51:11 <marko2> Eduard_Munteanu: hmm okay, thanks
08:51:27 <Eduard_Munteanu> epta: are you running it in the Cygwin environment?
08:51:56 <Kron> hmmm, is there any way to 'relink' ghc to programs that depend on it? A short while ago I reinstalled ghc to fix something and now my xmonad can't load new configuration files. I think that's why it can't compile my configs anyway
08:52:02 <Kron> or is that just a generic linux problem? I don't know
08:52:25 <Eduard_Munteanu> Kron: not really... reinstalled how?
08:52:35 <Kron> apt-get remove, apt-get install
08:53:05 <geekosaur> that, if it instaleld the same version/revision, should not have affected things
08:53:06 <Eduard_Munteanu> Kron: if it's mismatches between your ~/.cabal packages and the system GHC, you should reinstall those. Perhaps start with a clean ~/.cabal.
08:53:14 <geekosaur> what errors do you get with xmonad --recompile ?
08:53:37 <Kron> it tells me it can't find various modules
08:53:45 <Kron> "could not find module "xmonad.config.gnome""
08:53:48 <Kron> and after I comment those lines out
08:53:51 <Kron> it can't parse a thing
08:54:09 <Kron> hmmm
08:54:11 <Kron> wait
08:54:13 <geekosaur> did you also install xmonad from apt?
08:54:14 * hackagebot reorderable 0.3 - Define compound types that do not depend on member order.  http://hackage.haskell.org/package/reorderable-0.3 (AlexCole)
08:54:15 <Eduard_Munteanu> Kron: maybe apt removed packages that depend on ghc
08:54:15 <Kron> does xmonad register with cabal?
08:54:17 <Kron> or something?
08:54:24 <Kron> maybe when I reinstalled ghc, it can't see xmonad?
08:54:25 <geekosaur> you probably need to reinstall xmonad and xmonad-contrib the same way
08:54:35 <Kron> that could make a lot of sense
08:54:37 <Eduard_Munteanu> And that's not really how you upgrade packages on apt systems.
08:54:39 <Kron> "could nto find moduel xmonad
08:54:45 <Kron> perhaps you meant monad, cgmonad, dsmonad"
08:54:51 <Kron> *not find module
08:54:55 <geekosaur> and apt-get remove-ing ghc would have removed all the other packages too
08:54:57 <Kron> yeah it seems like it just can't find anything
08:55:27 <Eduard_Munteanu> Kron: secondly, why did you install 'ghc'? Isn't there a haskell-platform package for Debian/Ubuntu?
08:55:36 <Kron> not for 13.04
08:55:36 <geekosaur> not for recent ubuntu :(
08:55:37 <Kron> :(
08:55:53 <Kron> I wish I could install haskell platform :$
08:56:01 <Kron> but I'll deal with this with ghc and cabal
08:56:03 <Kron> hmmmmm
08:56:08 <Eduard_Munteanu> Kron: try installing 'xmonad' and 'xmonad-contrib'.
08:56:13 <sirspazzolot> couldn't you install a .deb from a previous release?
08:56:27 <Kron> sure I'll try installing xmonad again
08:56:48 <Eduard_Munteanu> Kron: the proper way to upgrade is through 'apt-get upgrade'
08:57:06 <Kron> I know that
08:57:13 <Kron> but I had to reinstall ghc, not upgrade it
08:57:20 <Eduard_Munteanu> Kron: how so?
08:57:22 <Kron> I was running into some really bizarre cabal errors
08:57:33 <Kron> it's a long story, I eventually resolved it by downloading opt3.0
08:57:36 <geekosaur> that was the wrong solution
08:57:43 <Kron> probably
08:57:49 <sirspazzolot> hah
08:57:53 <Eduard_Munteanu> Kron: IIRC there's '-f' if you want to reinstall a botched package, forcing it to install.
08:58:03 <Kron> ooh, I didn't know that
08:58:29 <geekosaur> if you're getting cabal errors, the answer is not to nuke ghc because that removes the system stuff and leaves all the problematic cabal stuff where it was but dangling so now it's an even worse mess
08:58:55 <Eduard_Munteanu> Most likely it's a ~/.{cabal,ghc} issue.
08:59:06 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml
08:59:14 <Kron> okay!
08:59:15 * hackagebot reorderable 0.3.1 - Define compound types that do not depend on member order.  http://hackage.haskell.org/package/reorderable-0.3.1 (AlexCole)
08:59:16 <Kron> it seems to work now
08:59:20 <Kron> awesome :)
08:59:33 <Kron> earlier I did "aptitude reinstall xmonad", but that didn't work
08:59:42 <Kron> but apt-get removing and installing xmonad seemed to fix everything
08:59:44 <Kron> thanks!
09:00:56 <Disgrntld> Hello, how do I define a recursive function in GHCi? Each let definition of the function with a different pattern (one for base case, one for recursive case) seem to override any previous
09:01:20 <sirspazzolot> Disgrntld: one statement, delimited by semicolons
09:01:25 <Disgrntld> ahh, thanks
09:01:42 <sirspazzolot> ie let expression; expression2 and so on
09:02:12 <Kron> you can also do "-{" or something like that
09:02:21 <Kron> to allow ghci to read multiple lines in one go
09:02:28 <shiona_> wouldn't also "let f x = if baseCase x then baseValue else f (modify x)" work
09:02:32 <Kron> that's a lot neater looking but I can never remember the syntax
09:02:40 <k00mi> :{ foo\nbar :}
09:02:46 <Kron> ah thanks
09:02:53 <Kron> also
09:02:58 <Kron> can't you stack patterns on the same line?
09:03:00 <Disgrntld> just playing around with some short functions, so the semicolon solution is working fine, thanks though
09:03:06 <Kron> hmmm, wait no you can't
09:03:10 <Kron> you can stack guards, not patterns
09:03:34 <Kron> foo x | guard = | guard = ...
09:03:43 <tarruda> is it possible to embed a c++ library that uses RAII ?
09:04:08 <geekosaur> foo [] = ...; foo xs = ...
09:04:45 <t7> tarruda: you could do  a 'using' function maybe? like withHandle :: (Thing -> a)
09:06:45 <bennofs> Is there an easier way to write let choose2 = map (\(h:t) -> map ((,) h) t) . filter (fmap not $ liftA2 (||) null $ null . drop 1) . tails
09:06:47 <bennofs> ?
09:06:50 <tarruda> t7: I really dont  know any c++. I just wanted to try embedding the spidermonkey javascript engine into a haskell program and when I asked how to wrap spidermonkey into a C program they said it wasnt possible because of RAII
09:08:11 <bennofs> @let let choose2 = map (\(h:t) -> map ((,) h) t) . filter (fmap not $ liftA2 (||) null $ null . drop 1) . tails
09:08:12 <lambdabot>  Parse failed: Parse error: EOF
09:08:15 <bennofs> @let choose2 = map (\(h:t) -> map ((,) h) t) . filter (fmap not $ liftA2 (||) null $ null . drop 1) . tails
09:08:18 <lambdabot>  Defined.
09:08:24 <tarruda> what options do I have if I wish to embed javascript into haskell?
09:08:49 <mm_freak> tarruda: "embed"?
09:09:11 <mm_freak> you can write javascript using jmacro
09:09:24 <tarruda> actually I meant run javascript inside a haskell program
09:09:48 <chrisdone> use nodejs?
09:10:01 <mm_freak> well, you can invoke spidermonkey/v8
09:10:03 <chrisdone> or do you want to run the interpreter from haskell with v8 or tracemonkey?
09:10:20 <tarruda> yes I was thinking about embedding spidermonkey
09:10:21 <monoidal> bennofs: ((,) h) t) == (h,t)
09:10:22 <bennofs> @pl \h t -> map (\(h:t) -> map ((,) h) t) . filter (fmap not $ liftA2 (||) null $ null . drop 1) . tails
09:10:22 <lambdabot> const (const (map ((map =<< (,)) . tail) . filter (fmap not (liftA2 (||) null (null . drop 1))) . tails))
09:10:39 <tarruda> but they said spidermonkey doesn't have a C api(just c++)
09:10:48 <bennofs> monoidal: it's passed as a function to map
09:10:59 <bennofs> > choose2 [1,2,3,4]
09:11:00 <monoidal> oh sorry, I miscounted parens
09:11:01 <tarruda> because it uses RAII(c++ feature)
09:11:05 <mm_freak> tarruda: do you need to interface with some existing project?
09:11:10 <lambdabot>   mueval-core: Time limit exceeded
09:11:13 <bennofs> > choose2 [1,2,3]
09:11:19 <chrisdone> tarruda: i'd check prior work on haskell + spidermonkey, but depending on the extent of integration you want, it should be pretty easy to write a binding to it with the ffi, even if it is in c++, you can write some C wrapper
09:11:21 <lambdabot>   mueval-core: Time limit exceeded
09:11:48 <chrisdone> you can checkout the python and ruby integrations for comparison
09:11:57 <abaranosky> is there a link with the best setup for using Haskell from Emacs?
09:12:09 <tarruda> I didnt find any haskell interface to spidermonkey
09:12:13 <mm_freak> abaranosky: start with haskell-mode
09:12:19 <abaranosky> I've got haskell-mode and scion-mode now, are there other tools that are widely-used?
09:12:36 <mm_freak> abaranosky: many people use inferior-haskell-mode and some people use ghc-mod
09:12:37 <merijn> abaranosky: hlint?
09:12:40 <Eduard_Munteanu> tarruda: you can invoke an external interpreter
09:12:47 <tarruda> chrisdone: I tought about writing a C wrapper too, but in spidermonkey channel they said it was problematic to embed from C
09:12:48 <abaranosky> thanks guys :)
09:12:51 <monoidal> bennofs: do you expect [(1,2),(1,3),(2,3)]?
09:12:57 <bennofs> monoidal: yes
09:13:04 <chrisdone> abaranosky: might want to try interactive-mode over inf-haskell, too https://github.com/haskell/haskell-mode/blob/master/examples/init.el
09:14:02 * chrisdone is currently working on emacs integration with fp complete too
09:14:48 <bearclaw> can unsafePerformIO break tracking of makeForeigPtr?
09:16:04 <monoidal> bennofs: f x = zipWith (,) x (tail $ tails x) >>= sequenceA
09:16:27 <monoidal> bennofs: you need Data.Traversable and instance of Traversable for tuples (available in GHC 7.8, or can be written manually)
09:16:37 <monoidal> zipWith (,) is of course zip
09:17:23 <bennofs> > let f x = [(a,b) | (a:rs) <- x, b <- rs] in f [1,2,3]
09:17:25 <lambdabot>   No instance for (GHC.Show.Show t0)
09:17:25 <lambdabot>    arising from a use of `M7981318583786...
09:17:29 <absence> why were genericTake etc. added instead of replacing the original functions? would there be compatibility problems?
09:17:39 <bennofs> > let f x = [(a,b) | (a:rs) <- tails x, b <- rs] in f [1,2,3]
09:17:40 <lambdabot>   [(1,2),(1,3),(2,3)]
09:17:51 <chrisdone> absence: yeah
09:17:58 <bennofs> monoidal: I think I'll use the list comprehension version :) It's easier
09:17:59 <monoidal> bennofs: oh, that's nicer
09:18:33 <chrisdone> the generic ones require more type annotations more often and aren't optimized out of the box like the ints
09:18:51 <absence> chrisdone: oh right, the type signatures..
09:23:41 <it3ration> morning all
09:23:53 <epta> Eduard_Munteanu: yep, I'm running it in the cygwin environment
09:24:39 <absence> chrisdone: is it for performance reasons that Int is used almost everywhere, and without overflow checks? i guess it's rare to work with that large data, but it feels like something that could bite eventually :)
09:25:26 <geekosaur> absence: in many cases, Int overflow can't be a problem in practice because it's also the size of a pointer --- you run out of memory before you overflow :)
09:25:59 * bennofs uses Int instead of Integer because it's shorter to type
09:26:34 <absence> geekosaur: "many cases" being 32-bit platforms? or is Int usually 64-bit on 64-bit platforms?
09:26:52 <geekosaur> the latter (and also 64 bit on some 32-bit platforms)
09:26:58 <chrisdone> absence: yeah, it's a bit warty. SBCL (common lisp compiler) will promote numbers to the right size appropriately unless you explicitly specify an unsafe fixnum. i prefer this than haskell's approach
09:27:09 <geekosaur> ...talking ghc at least
09:29:28 <absence> geekosaur: ah, good to know
09:30:00 <bennofs> How is ContT used? Is it common to have functions like f :: (a -> ContT r m ()) -> ContT r m b?
09:30:25 <Eduard_Munteanu> bennofs: that's what 'cont' wraps, you don't have to do that
09:30:45 <absence> guess i'll live with the Int wart rather than locally reimplement every library function under the sun to support Integral or Integer :)
09:31:00 <bennofs> Eduard_Munteanu: But when I want to exit from a continuation? Then I'll have to pass the contiuation to use when exiting
09:31:12 <Eduard_Munteanu> bennofs: that's what callCC is for
09:31:54 <Eduard_Munteanu> e.g.   callCC $ \exit -> ...
09:31:57 <bennofs> Eduard_Munteanu: callCC gives me a k. But often, I want to pass that k to a function?
09:32:35 <Eduard_Munteanu> bennofs: you can wrap that 'k' in 'cont' again
09:32:42 <Eduard_Munteanu> :t cont
09:32:46 <lambdabot> ((a -> r) -> r) -> Cont r a
09:33:28 <bennofs> Eduard_Munteanu: do you have an example of using the ContT monad? I'm a bit confused.
09:34:27 <Eduard_Munteanu> bennofs: callCC $ \break -> forM_ [1..] $ \i -> when (i == 4) $ break 4
09:35:26 <Eduard_Munteanu> bennofs: which returns 4 from the continuation
09:35:37 <Eduard_Munteanu> The inner loop I mean.
09:36:02 <fizruk> :t callCC
09:36:03 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
09:36:09 <bennofs> But when I have a recursive function, I need another function that uses callCC $ \k -> myRecursiveFunction k ?
09:36:15 <gsnedders> Hey. I have a Maybe Expr, and a function eval :: Expr -> b -> (Integer, b). I want to get a Maybe Integer from those two. I obviously can't just use (fst . eval), because that tries to apply fst to b -> (Integer, b). I presume I'm just missing something obvious with higher order functions here.
09:36:51 <gsnedders> (Apologies if I suddenly vanish, am on rather dodgy on-train wifi!)
09:36:53 <Eduard_Munteanu> bennofs: no, you can just recurse and pass the 'k' around
09:37:29 <Eduard_Munteanu> bennofs: for example your function could callCC and pass the 'k' to itself when recursing
09:37:54 <geekosaur> gsnedders: look at fmap
09:38:19 <gsnedders> geekosaur: Oh, I meant that I obviously can't used fmap (fst . eval).
09:38:33 <fizruk> gsnedders, fmap (fst . flip eval b) or something ?
09:39:34 <lpaste> deweyvm pasted “No title” at http://lpaste.net/95709
09:39:38 <bennofs> > let f 0 k = k 0; f !n k = f (pred n) k in runCont (callCC $ f 5) id
09:39:40 <lambdabot>   0
09:39:44 <deweyvm> is there a more concise way to express this?
09:40:05 <fizruk> deweyvm, depends on bodies?
09:40:16 <deweyvm> body1 is the same for the first two cases
09:40:32 <fizruk> then yes
09:40:32 <monoidal> deweyvm: it ignores x in the second case?
09:40:42 <deweyvm> yea, should probably be _
09:40:48 <fizruk> foo (x:y:xs) = {-body2-}; foo _ = {-body1-}
09:40:49 <monoidal> foo (x:y:xs) = body2; foo _ = body1
09:40:52 <deweyvm> ahh
09:40:59 <deweyvm> im dumb, thanks
09:41:31 <monoidal> btw, another thing you can do is foo [x] = ... instead of foo (x:[]) = ...
09:42:16 <deweyvm> oh neat
09:42:30 <monoidal> this is of course irrelevant given foo _ = body1
09:43:27 <quchen> If there's a memory leak in unoptimized code, can the optimizations get rid of it?
09:43:48 <quchen> Or are leaks something that are somehow unaffected by optimizations based on some principle
09:44:02 <quchen> … like that optimizations don't change semantics and leaks are semantic. Or something.
09:44:06 <Eduard_Munteanu> quchen: sometimes...
09:44:26 <tomejaguar> quchen: Optimizations can change foldl to foldl' for example.  That can git rid of a memory leak.
09:44:26 <Eduard_Munteanu> quchen: not quite a leak, but  foldl (+) 0  is one example.
09:44:47 <tomejaguar> s/memory leak/space leak/
09:44:57 <mangaba_leitosa> chrisdone: did you try it with vector?
09:45:01 <quchen> Hmmm. Nah I've got a real proper leak. Program grows around 1 meg per 10 seconds.
09:45:05 <quchen> For some value of "leak".
09:45:18 <quchen> So it won't blow up but slowly get sick :-(
09:48:39 <gsnedders> Right, I'm overthinking this. And almost at a point to change trains. Elsewhere I use fst $ eval a b; , so so how do I get a function equiv to \x y -> fst $eval a b?
09:49:03 <Eduard_Munteanu> quchen: I hope you're not compiling without -O by default
09:49:28 <quchen> Eduard_Munteanu: Nah, just now so compilation is fast
09:49:52 <quchen> Eduard_Munteanu: That would be awful if I always had GHC run the code as I write it
09:49:53 <quchen> Oh my :-D
09:50:59 <quchen> Might be subjective but -O(2) seems to increase the program's ability to create the leak. It now grows faster.
09:51:05 <quchen> I need an oracle
09:51:17 <quchen> If only my TM had one
09:51:41 <quchen> At least optimizations cut CPU load from 48 to 0
09:55:31 <fizruk> gsnedders, \x y -> fmap (fst . flip eval y) x ?
09:56:21 <pmk> i was helping a colleague understand haskell and found myself at a loss trying to explain why we have all six of (.), map, fmap, liftA, <$>, and liftM in the language.  we are overdue for a spring cleaning.
09:56:24 <fizruk> > fromMaybe a (Just b)
09:56:26 <lambdabot>   b
09:56:33 <fizruk> what package does that? ^
09:56:34 <geekosaur> hysterical raisins
09:56:53 <geekosaur> simple-reflect, IIRC
09:57:14 <fizruk> geekosaur, aha, thanks!
09:57:27 <Eduard_Munteanu> pmk: because we don't have Functor and/or Applicative as superclasses of Monad.
09:57:55 <pmk> that's a small part of the problem
09:58:14 <monoidal> I'm opposed to fmap as a generalization of (.). (.) generalizes to Category, not Functor.
09:58:35 <lpaste> Disgrntld pasted “No title” at http://lpaste.net/95710
09:58:35 <monoidal> map, fmap, liftA, liftM, on the other hand, should be the same function.
09:58:54 <pmk> and <$>
09:59:00 <Disgrntld> At the end of the making monads section in lyah, the author makes a function that returns a probabilistic results of whether three flipped coins (one is loaded) will all be tails. There's eight false results of varying probabilities and one true result. The author then says writing a function to put all the same outcomes into one outcome is pretty easy and is left as an exercise to the reader. Is there a more general way than this
09:59:09 <Eduard_Munteanu> Though technically Applicative and Monad should be unrelated too, they only happen to be nice in Hask.
09:59:18 <Eduard_Munteanu> But that's more of a nitpick.
09:59:23 * hackagebot pipes-postgresql-simple 0.1.1.1 - Convert various postgresql-simple calls to work with pipes  http://hackage.haskell.org/package/pipes-postgresql-simple-0.1.1.1 (OliverCharles)
09:59:49 <fizruk> pmk, <$> is a useful synonym, map and fmap differ in error messages (which is important for newcomers, I believe)
10:01:26 <pmk> yeah well if we just picked one name out of these six and stuck with it, i doubt we'd have newbies complaining that (.) should be six names that do the same thing
10:01:29 <monoidal> Disgrntld: sort the list [(a, Rational)], use group and add
10:01:55 <jpcooper> what is the most efficient map for (Int, Int) -> (Int, Int)?
10:02:01 <monoidal> Disgrntld: this requires an Ord constraint, but in applications it is usually acceptable (and O(n log n))
10:02:46 <monoidal> Disgrntld: I mean, use groupBy fst. alternatively, you could convert to Map a Rational
10:03:55 <fizruk> pmk, can't see how (.) is map/fmap except for a Reader
10:04:24 * hackagebot hmatrix 0.15.2.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.15.2.0 (AlbertoRuiz)
10:04:24 <Eduard_Munteanu> fizruk: functions are implicitly in Reader
10:04:32 <Eduard_Munteanu> Naked Reader.
10:05:25 <fizruk> well I misspoke, I can't see how map/fmap is (.) except for a Reader
10:05:40 <pmk> > ((+1) `fmap` (*2)) 3
10:05:42 <lambdabot>   7
10:05:45 <Eduard_Munteanu> (b -> c) -> (a -> b) -> a -> c ~ (b -> c) -> Reader a b -> Reader a c
10:05:48 <Disgrntld> monoidal: Ok, I could see how that would work, but is there a way to do this all using the monadic instance of Prob or something (I'm new to this that prolly sounds dumb)? I'm guessing no because it has no notion of combining probabilities with addition, just flattening nested Probs with multiplication
10:05:53 <pmk> ((+1) `fmap` [0..3])
10:06:27 <monoidal> Disgrntld: I think your guess is right. Simplifying the Prob falls outside the monadic instance
10:07:02 <Disgrntld> cool, alright, this was a fun exercise so I think I'll take your word about groupBy, thanks for the help
10:10:16 <fizruk> pmk, consider automaton (like Mealy from machines) it does different thing for (.) and fmap
10:10:35 <jfeltz> I've seen a few http server's modelled like this: startServer :: AddrInfo -> (Request -> Response IO) -> IO Server, Isn't typing it as an IO monad bad design? I don't want to have to retrieve the state from some persistent location to test the server (though it eventually will), so I'm wondering why several library designers have chosen this approach
10:11:31 <gsnedders> fizruk: flip because the second argument is invarient, so it can just be curried and then use that?
10:11:35 <Eduard_Munteanu> jfeltz: you can use monad transformers for IO... besides, how else is it going to listen to ports etc?
10:11:56 <fizruk> gsnedders, (flip f) y x ~ f x y
10:12:20 <alexander__b> BTW I have to do some C programming for school at the moment, and I can't for the life of me understand how on earth a language doesn't have the Maybe monad. does this mean I have become haskellite?
10:12:35 <lpaste> jrmithdobbs pasted “wtf” at http://lpaste.net/633657965655621632
10:13:27 <fizruk> wow, i didn't know you can do pattern match like [x,y,z] = [1,2,3] on top-level!
10:14:00 <jrmithdobbs> so given code kind of like that (or, you know, exactly) how can I add enforcement of key values to modifiers based on the contents of the string without convoluted over-specification with a bunch of boilerplate for every consumer of that type?
10:14:38 <gsnedders> fizruk: Right, I get that. I just hadn't seen how flip was helpful. Thanks! :)
10:15:04 <jrmithdobbs> eg, i have certain values that where that gets serialized/sent to where certain modifiers aren't valid, i'd like to use the type system to prevent such combinations from happening somehow but i'm having trouble finding a way :(
10:15:44 <fizruk> gsnedders, perhaps you should swap arguments for eval to get rid of `flip`s
10:15:57 <fizruk> gsnedders, but perhaps not
10:16:47 <jfeltz> Eduard_Munteanu, I know some IO is needed in the passed function, but I still have to retrieve a state via IO (I think), and I don't see a way around that huge inconvenience
10:17:49 <Eduard_Munteanu> jfeltz: you can use StateT YourState IO
10:18:03 <Eduard_Munteanu> jfeltz: assuming you're familiar with monad transformers... are you?
10:18:12 <jfeltz> Eduard_Munteanu, yes
10:18:55 <jrmithdobbs> or am I completely off in the weeds here?
10:19:22 <Eduard_Munteanu> startServer ... $ (`runState` initial) $ do ...
10:19:56 <Eduard_Munteanu> Arguably it could have been polymorphic in the IO monad.
10:20:05 <Eduard_Munteanu> (a-la monad-base)
10:20:19 <Eduard_Munteanu> Er, s/runState/runStateT/
10:21:55 <jfeltz> Eduard_Munteanu, sorry, catching up here, but even the state monad needs to return the response, and that stores some state, so I have no way of telling the server what to do with the next request without restarting the server
10:21:57 <lpaste> jrmithdobbs revised “wtf”: “wtf-with-constructors” at http://lpaste.net/633657965655621632
10:22:54 <Eduard_Munteanu> jfeltz: I can't tell what 'startServer' does, any link to a particular API?
10:23:05 <jfeltz> http://hackage.haskell.org/package/httpd-shed-0.4/docs/Network-Shed-Httpd.html
10:24:05 <Eduard_Munteanu> jfeltz: so you're worried about the 'Request -> IO Response' bit?
10:24:05 <gsnedders> fizruk: Given it's aprt of an assignment, and I'm not allowed to, probably not! I agree, though, that the other order would make more sense.
10:24:22 <gsnedders> fizruk: Unless I've misunderstood what it's meant to be doing. :)
10:24:28 <Eduard_Munteanu> jfeltz: that tends to be a problem, I agree.
10:25:27 <Eduard_Munteanu> jfeltz: the proper fix would be allowing any MonadIO, not just IO.
10:25:28 <jfeltz> yes, and http://hackage.haskell.org/package/http-server-1.0.2/docs/Network-HTTP-Server.html as well, ya, it's a premature bottleneck
10:26:41 <Eduard_Munteanu> jfeltz: you can wrap it into a helper yourself though
10:27:33 <Eduard_Munteanu> You don't have to use IORefs everywhere, just that helper.
10:32:28 <jfeltz> thanks
10:49:12 <eacameron> there are several SQLite libs; what do yall recommend?
10:49:50 <Eduard_Munteanu> eacameron: 'persistent' with the sqlite backend is rather alright
10:50:19 <Eduard_Munteanu> eacameron: not plain sqlite though
10:50:22 <chrisdone> sudo apt-get purge sqlite*; burn sqlite*; burn remains; burn computer; xeyes & sudo shutdown now
10:50:55 <Eduard_Munteanu> chrisdone: hm, you don't really like it, I guess?
10:51:05 <chrisdone> not much >_>
10:51:32 <eacameron> any less biased comments? ;)
10:51:35 <chrisdone> persistent interface is nice tho
10:51:50 <eacameron> cool; I'll check that one out
10:51:53 <eacameron> is it like an ORM?
10:51:55 <chrisdone> once you've deleted sqlite you can seamlessly upgrade to a proper database without any problem
10:51:59 <eacameron> haha
10:52:00 <chrisdone> yeah
10:52:11 <Eduard_Munteanu> eacameron: it's a non-SQL interface
10:52:44 <Eduard_Munteanu> eacameron: so it's more like ordinary code
10:53:07 <chrisdone> yeah, its DSL is limited
10:53:13 <chrisdone> and there is http://hackage.haskell.org/package/esqueleto which is a layer ontop of persistent so that you can write SQL-like queries in a DSL, for those times you need precise/optimized queries
10:53:36 <chrisdone> so going the persistent route is pretty sweet
10:54:20 <eacameron> excellent; thanks!
10:54:56 <chrisdone> eacameron: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/persistent-db
10:55:01 <chrisdone> an sqlite example ^
10:55:06 <eacameron> perfect
10:56:34 * nicoo throws some acid(-state) at chrisdone :)
10:57:49 <chrisdone> nicoo: i like acid-state too
10:57:53 <ibotty> but even esqueleto does not let you do advanced things in the database. well. for sqlite it will suffice :D
10:58:21 <chrisdone> ibotty: you mean like writing procedures?
10:58:24 <ibotty> but when (not if) you go to a real database like postgres, you will feel the limits
10:58:33 <ibotty> cte's for example
10:58:49 <ibotty> these are so extremely useful
10:59:04 <ibotty> and no love from any db-abstraction i know
10:59:25 <chrisdone> yeah, i've read about WITH in the documentation but never had a case to use it
10:59:25 <nicoo> ibotty: CTE ?
10:59:37 <ibotty> that you can't write postgres functions in haskell is the limitation of a missing pl/haskell
10:59:43 <ibotty> common table expressions
11:00:02 <chrisdone> sure -- which is pretty involved
11:00:13 <ibotty> https://wiki.postgresql.org/wiki/CTEReadme
11:00:51 <ibotty> they are great whenever you have to model e.g. graphs in the db
11:01:17 <chrisdone> yeah
11:01:43 <chrisdone> i could implement a pl/haskell, i know how i'd do it. but last time i considered it, it's more of a problem of getting sysadmins to install it
11:02:22 <chrisdone> didn't seem worth doing
11:03:05 <ibotty> supply a debian/rules and a spec and it will be easy
11:03:24 <ibotty> i mean if you let it only use trustworthy code it might work
11:03:43 <ibotty> (btw: i would certainly help with it! i'd really like haskell in postgres)
11:04:14 <ibotty> trustworthy is safe-inferred or something like that, right? i am always mixing up these
11:04:17 <bennofs> what is pl/haskell?
11:04:18 <chrisdone> here's a key ingredient: https://github.com/Peaker/haskell_ffi_tests
11:04:33 * hackagebot sorted 0.0.1 - Efficient, type-safe sorted sequences  http://hackage.haskell.org/package/sorted-0.0.1 (JosephAbrahamson)
11:04:35 <ibotty> hehe
11:04:49 <chrisdone> bennofs: pl/* is postgresql's way of calling languages that postgresql supports for database procedures
11:04:57 <chrisdone> e.g. pl/python
11:05:04 <chrisdone> http://www.postgresql.org/docs/9.0/static/plpython.html
11:05:09 <bennofs> ah, thanks
11:05:11 <ibotty> (well postgres does not have procedures, only functions, but you get the idea)
11:05:57 <benzrf> hello
11:06:08 <chrisdone> heylo
11:06:25 <ibotty> hilo
11:07:16 <fizruk> hylo?
11:07:25 <chrisdone> > permutations "hello"
11:07:27 <lambdabot>   can't find file: L.hs
11:07:29 <ibotty> chrisdone: what kind of api did you envision when you were toying around with the pl/haskell idea
11:07:44 <mangaba_leitosa> chrisdone: lambdabot seems to be infected by a virus lately
11:08:13 <benzrf> > map ((++"lo") . ('h':)) "aeiouy"
11:08:14 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
11:08:14 <lambdabot>  Expected type...
11:08:17 <benzrf> oops
11:08:37 <benzrf> @type ((++"lo") . ('h':))
11:08:38 <lambdabot> [Char] -> [Char]
11:08:47 <benzrf> ah
11:09:13 <benzrf> > map ((++"lo") . ('h':) . (:[])) "aeiouy"
11:09:15 <lambdabot>   ["halo","helo","hilo","holo","hulo","hylo"]
11:09:23 <benzrf> i feel like theres a better way of doing that
11:10:14 <bennofs> > ['h':x:"lo" | x <- "aeiouy"]
11:10:16 <lambdabot>   ["halo","helo","hilo","holo","hulo","hylo"]
11:10:31 <benzrf> >.>
11:10:36 <benzrf> i always forget listcomps
11:11:06 <chrisdone> ibotty: iirc the interface demands that your language driver take in a string, so something hint-based and the library be initialized with the running hint and provided some FFI functions to call back into postgresql. i don't remember the details much more
11:11:23 <chrisdone> mangaba_leitosa: yeah…
11:11:38 <tac> > do x <- "aeiouy"; return ('h' : x : "lo")
11:11:39 <lambdabot>   ["halo","helo","hilo","holo","hulo","hylo"]
11:11:41 <chrisdone> mangaba_leitosa: i might run a lambdabot on lpaste's server, might be more reliable
11:11:47 <ibotty> ah no. that's not what i meant. i meant, what api should a haskell function in postgres use?
11:11:57 <ibotty> it can't really be postgresql.simple
11:12:43 <mien> Can someone recomend a good starter guide for haskell? I have tried to go through "Learn yourself a Haskell for Great Good" and i kind of understand the syntax and everything. But i cant really build anything usefull. Would really need an introduction to popular modules and how stuff actually are made.
11:12:55 <bennofs> @where rwh
11:12:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:13:25 <ibotty> i learned from reading code
11:13:28 <bennofs> @where soh
11:13:28 <lambdabot> School of Haskell https://haskell.fpcomplete.com/school
11:13:29 <benzrf> speaking of which
11:13:38 <benzrf> i could use some simple-ish assignments to try to figure out
11:13:40 <chrisdone> ibotty: are you planning on doing it?
11:13:45 <ibotty> i'm not sure
11:13:58 <ibotty> i'm more thinking about ermine atm
11:14:08 <benzrf> i read most of the bit in RWH about writing a recursive fs search and I feel like i couldve made something like that
11:14:13 <ibotty> it's row polymorphisms sound a great fit
11:14:22 <chrisdone> ibotty: personally, i'd rather that the pl/haskell language can call directly into the current execution context via c functions
11:14:24 <chrisdone> ermine?
11:14:24 <benzrf> anybody have simple-ish programs like that which i could try to make for practice?
11:14:46 <ibotty> ekmett's haskell-like lang for the jvm
11:15:08 <ibotty> row types seems to be a great fit for relational data
11:15:28 <ozataman> join #ermine
11:15:35 <benzrf> ekmett?
11:15:36 <chrisdone> benzrf: if you follow one of the tutorials on SoH, you can run the code snippets or click 'open in IDE' and that copies that code snippet in the ide
11:15:53 <ibotty> i mean, i implemented the same graph reduction algorithms, i don't know, five times now for a project of mine
11:16:00 <chrisdone> ibotty: yeah i like row polymorphism, much better than subtyping
11:16:20 <ibotty> ekmett is edward kmett, benzrf
11:16:30 <benzrf> chrisdone: SoH?
11:16:39 <chrisdone> @where soh
11:16:40 <lambdabot> School of Haskell https://haskell.fpcomplete.com/school
11:16:54 <benzrf> i meant more like something i could try making from scratch
11:16:55 <ibotty> lambdabot is very helpful today
11:17:09 <Taneb> When generalized newtype deriving doesn't break anything, is it nice?
11:17:25 <monoidal> benzrf: a sokoban-like game? rpn calculator?
11:17:43 <benzrf> monoidal: hmm, sokoban could be fun
11:17:46 <monochrom> @botsnack
11:17:47 <lambdabot> :)
11:17:48 <chrisdone> no no no!
11:17:51 <benzrf> i think ill try making that and fail horribly
11:17:53 <ibotty> benzrf: whatever is fun to you
11:17:55 <chrisdone> bennofs: solve the twitter wterflow problem =p
11:17:57 <yesthisisuser> hm.. i have a definition .. say MonadResource IO => IO ()
11:18:08 <ibotty> chrisdone: you spoiled that already
11:18:11 <yesthisisuser> now how do i turn this into a IO ()
11:18:23 <chrisdone> :(
11:18:29 <fizruk> Taneb, sure? :)
11:18:37 <benzrf> erm i still don't know how to use state monad
11:18:42 <benzrf> ~_~
11:18:53 <benzrf> @t runState
11:18:54 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
11:19:02 <chrisdone> benzrf: https://www.fpcomplete.com/school/starting-with-haskell/basics-of-haskell/12-State-Monad
11:19:02 <benzrf> @ty runState
11:19:03 <lambdabot> State s a -> s -> (a, s)
11:19:05 <monoidal> create an empty file, and implement there all standard monads from scratch
11:19:14 <monochrom> do { x <- get; put (2*x); return (x-1) }  -- using the State monad.
11:19:16 <monoidal> reader, writer, state, list, maybe, either e
11:19:21 <ibotty> benzrf: does not matter. start without. then slowly understand it
11:19:39 <ibotty> i remember when i finally 'got' the EitherT monad transformer
11:19:56 <monochrom> perhaps the hardest part to understand is: there is little to understand
11:20:06 <ibotty> the same day i killed at least 20 lines in every web project pf mine
11:20:14 <benzrf> i dont know anything about mt's
11:20:17 <benzrf> :|
11:20:23 <chrisdone> “monads are like a finger pointing away to the moon. *smack* don't look at the finger or you will miss all that heavenly glory…”
11:20:27 <ibotty> that's not important. i did not earlier
11:20:37 * fizruk remembers himself to "finally get" State 3-5 times
11:20:44 <monochrom> haha chrisdone, that's beautiful
11:20:53 <ibotty> fizruk: that's why i put it in quotes :D
11:21:09 <monochrom> hmm, let's immortalize it... :)
11:21:23 <monochrom> @remember chrisdone “monads are like a finger pointing away to the moon. *smack* don't look at the finger or you will miss all that heavenly glory…”
11:21:23 <lambdabot> Okay.
11:21:44 <chrisdone> \o/
11:22:44 <benzrf> the mind is like a dog; its master points to the type definition while it barks at the maybe monad
11:23:15 <ibotty> benzrf: start using it without understanding it, then see for yourself how soon you gain intuition. it's a very small step to understanding monads from that point on.
11:23:15 <monochrom> hahaha
11:24:01 <monochrom> yeah. cart : horse :: intuition : practice
11:24:21 <ibotty> well, gotta go. chrisdone: i might write you an email about pl/something if you are interested.
11:24:24 <benzrf> I thought a : b :: [a]
11:24:45 <monochrom> damn you haha
11:26:30 <benzrf> sorry that should be cart : horse :: [cart]
11:27:45 <monoidal> a : b :: c : d is a notation for "a is to b as c to d", an analogy or a proportion
11:27:54 <benzrf> im aware
11:28:04 <benzrf> merely making a silly joke off of haskells synta
11:28:05 <benzrf> x
11:28:05 <benzrf> ;p
11:29:02 <chrisdone> monoidal: that's a good boards of canada track
11:30:51 <UserA-> hello, do you know a function like that (m a, m b) -> m (a, b)
11:31:06 <monoidal> UserA-: liftM2 (,)
11:31:19 <benzrf> @type lifetM2
11:31:20 <lambdabot>     Not in scope: `lifetM2'
11:31:20 <lambdabot>     Perhaps you meant one of these:
11:31:20 <lambdabot>       `liftM2' (imported from Control.Monad.Writer),
11:31:20 <UserA-> to be more precise (Maybe Text, Maybe FilePath) -> Maybe (Text, FilePath)
11:31:24 <benzrf> @type liftM2
11:31:26 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:31:29 <UserA-> oh thx
11:32:01 <UserA-> I was expecting an arrow (I saw that once) but that works
11:32:15 <benzrf> (>>=) where m == State is basically fancy composition, right?
11:32:34 <monochrom> yes
11:32:39 <benzrf> ok
11:33:04 <benzrf> why is this:
11:33:07 <benzrf> @type writer
11:33:08 <lambdabot> MonadWriter w m => (a, w) -> m a
11:33:19 <benzrf> why not use Monoid & Monad instead of MonadWriter?
11:33:54 <chrisdone> MonadWriter does mandate a Monoid instance on the `w'
11:34:18 <benzrf> is it anything more than 'class Monoid w, Monad m => MonadWriter w m'
11:34:21 <benzrf> or something
11:34:22 <monochrom> I don't understand the question.
11:34:25 <meiji11> what precisely does it mean that the io monad is strict? I realize I haven't really understood the meaning of that statement.
11:34:36 <benzrf> meiji11: it's not 'really' strict
11:34:41 <benzrf> but it lets you simulate strictness
11:34:50 <tomejaguar> meiji11: Where does it say the IO monad is strict?
11:34:51 <monochrom> it's like "why not eat apple & vinegar instead of orange"
11:35:00 <benzrf> in that any IO operation further down the line forces the eval of the ones before it
11:35:04 <benzrf> *evaluating it
11:35:16 <benzrf> meiji11: if I say a + b in haskell, b may be evaled first
11:35:29 <benzrf> if I say getLine >>= putStrLn, this forces getting a line before putting the str
11:35:37 <benzrf> but they're really not equivalent
11:35:48 <meiji11> tomejaguar: on the haskell wiki, in various places.
11:35:49 <benzrf> what I just said is very misleading if you don't understand monads and/or monadic IO
11:35:52 <monoidal> if you say print (2 + 3) >> print (5 + 6), the compiler is free to evaluate 5 + 6 before 2 + 3
11:36:08 <meiji11> you don't understand things in haskell, you just get used to them. :/
11:36:30 <meiji11> I think I understand, but that still seems to clash with this weird behaviour I've observed in a program I'm writing.
11:36:33 <jrmithdobbs> monoidal: also 3 before 2 and 6 before 5*
11:36:46 <jrmithdobbs> (important for understanding, i think)
11:36:47 <benzrf> meiji11: what weird behavior?
11:36:55 <benzrf> meiji11: and u can totally understand haskell
11:37:06 <benzrf> it makes a strange kind of minimalistic sense
11:37:07 <benzrf> or something
11:37:18 <meiji11> I'm working in RWST with IO as its base monad, and I'm trying to memoize results of recursive calls to that same monad.
11:37:25 <benzrf> the problem with haskell is that everything is simpler than you think it is, so you don't realize that you understand something until youve spent hours
11:37:28 <monoidal> well, maybe that is a bad example because print is strict
11:37:29 <meiji11> in an intmap, actually, which is part of the state type of the RWST.
11:37:49 <benzrf> @type strict
11:37:50 <lambdabot> (Functor f, Profunctor p, Strict s a) => p a (f a) -> p s (f s)
11:37:56 <meiji11> I have this insertOrLookup function, which should only evaluate the recursive call for memoization in the event that the key lookup fails.
11:38:17 <meiji11> and.. it looks as though the value is being evaluated regardless of whether the lookup succeeds.
11:38:21 <monochrom> show actual code.
11:38:44 <benzrf> @type print
11:38:45 <lambdabot> Show a => a -> IO ()
11:38:54 <benzrf> @src print
11:38:55 <lambdabot> print x = putStrLn (show x)
11:39:00 <meiji11> it's horribly messy, but ok.. it's ok if I use hpaste?
11:39:05 <benzrf> why not putStrLn . show
11:39:06 <monoidal> meiji11: yes
11:39:07 * monochrom has an axiomatic distrust of human narratives. and everyday more data points from #haskell justifies it.
11:39:31 <ReinH> benzrf: because print gives a useful concept a name?
11:39:47 <ReinH> benzrf: oh why isn't the source putStrLn . show ?
11:40:02 <jrmithdobbs> whether that's what he meant or not, I'm wondering the same thing
11:40:03 <dcoutts> chrisdone: I don't understand about breaking haskellnews with the rss location change, all of them do HTTP redirects, or is the redirect broken?
11:40:06 <FreeFull> printf is funny business
11:40:46 <fizruk> can I simplify this? fun (Left x, w) = Left $ f x w; fun (Right x, w) = Right $ g x w
11:41:09 <jrmithdobbs> :t either
11:41:10 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
11:41:11 <dcoutts> chrisdone: all those URLs work for me, I can't see the problem.
11:41:26 <jrmithdobbs> fizruk: that was for you.
11:41:48 <FreeFull> jrmithdobbs: How do you deal with the tuples?
11:42:01 <fizruk> jrmithdobbs, that won't simplify things
11:42:32 <jrmithdobbs> actually for that it wont cause you'd have to do the tuple unwrapping in the lambdas i guess
11:42:42 <arkeet> :t strength
11:42:43 <lambdabot> Not in scope: `strength'
11:42:47 <benzrf> > either (+10) (++"thing") (Right "this ")
11:42:48 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:42:48 <lambdabot>    arising from a use of `GH...
11:42:50 <meiji11> here it is, line 24 on and on is the salient stuff: http://lpaste.net/95713
11:42:51 <benzrf> oops
11:42:52 <fizruk> i guess something like bimap should work
11:42:52 <FreeFull> Maybe you could use curry somehow
11:42:54 <benzrf> > either (+10) (++"thing") (left "this ")
11:42:56 <lambdabot>   Couldn't match type `Data.Either.Either b0 d0'
11:42:56 <lambdabot>                with `[GHC.Ty...
11:42:57 <benzrf> ug
11:43:00 <benzrf> > either (+10) (++"thing") (Left "this ")
11:43:01 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:43:01 <lambdabot>    arising from a use of `GH...
11:43:05 <arkeet> @let strength (x,a) = fmap (flip (,) a) x
11:43:08 <benzrf> ?
11:43:08 <lambdabot>  Defined.
11:43:10 <fizruk> :t bimap
11:43:12 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
11:43:18 <jrmithdobbs> fizruk: could you refactor so that f and g do the unwraps?
11:43:31 <FreeFull> :t curry $ \t x -> either (f x) (g x)
11:43:32 <lambdabot> (FromExpr (t -> a1 -> c), FromExpr (t -> b1 -> c)) => a -> b -> t -> Either a1 b1 -> c
11:43:57 <FreeFull> :t uncurry $ \t x -> either (f x) (g x)
11:43:59 <lambdabot> (Show b, Show a1, Show b1, FromExpr c) => (a, b) -> Either a1 b1 -> c
11:44:05 <FreeFull> Nope, that's not right
11:44:10 <FreeFull> :t uncurry $ \t x -> either (f x) (g x) t
11:44:11 <lambdabot> (Show b, Show a, Show b1, FromExpr c) => (Either a b1, b) -> c
11:44:27 <arkeet> :t \f -> fmap (uncurry f) . strength
11:44:28 <lambdabot> Functor f => (a -> b1 -> b) -> (f a, b1) -> f b
11:44:48 <FreeFull> arkeet: That doesn't help
11:44:56 <arkeet> oh oops.
11:44:56 <FreeFull> You can't fmap over Left
11:44:58 <fizruk> arkeet, i need bistrength then :)
11:45:00 <arkeet> right.
11:46:01 <fizruk> :t \(e, w) -> bimap (f w) (g w) e
11:46:02 <lambdabot> (Show t, Show a, Show c, Bifunctor p, FromExpr b, FromExpr d) => (p a c, t) -> p b d
11:46:15 <fizruk> :t \f g (e, w) -> bimap (f w) (g w) e
11:46:16 <lambdabot> Bifunctor p => (t -> a -> b) -> (t -> c -> d) -> (p a c, t) -> p b d
11:46:21 <Taneb> mm_freak, ping
11:47:03 <benzrf> btw i found this excerpt from land of lisp amusing: http://benzrf.com/misc/fp.pfg
11:47:05 <fizruk> :t \f g w -> bimap (f w) (g w)
11:47:07 <lambdabot> Bifunctor p => (t -> a -> b) -> (t -> c -> d) -> t -> p a c -> p b d
11:47:07 <benzrf> *pdf
11:47:27 <mm_freak> Taneb: pong
11:47:56 <arkeet> @let import Data.Bitraversable
11:47:57 <lambdabot>  <no location info>:
11:47:57 <lambdabot>      The package (tagged-0.7) is required to be trusted ...
11:47:58 <benzrf> mm_freak: ping
11:48:02 <arkeet> bahhhhh
11:48:02 <benzrf> hmm
11:48:10 <benzrf> i think mm_freak has some bugs
11:48:14 <fizruk> arkeet, is it not imported already?
11:48:26 <fizruk> :t bitraverse
11:48:28 <lambdabot>     Not in scope: `bitraverse'
11:48:28 <lambdabot>     Perhaps you meant one of these:
11:48:28 <lambdabot>       `itraverse' (imported from Control.Lens),
11:48:31 <Taneb> mm_freak, after yesterday, I thought for a while, then realised you were right and something like netwire would work great for spriggan (my sprite-based game engine)
11:48:32 <fizruk> oh
11:48:49 <mm_freak> benzrf: pong
11:48:53 <Taneb> mm_freak, but I'm having difficulty working out how to pass the input into the wire network
11:49:13 <mm_freak> Taneb: what is the input?
11:49:54 <tomejaguar> meiji11: Could you be more precise about what's going wrong.  Also more type signatures would help.
11:49:57 <Taneb> At the moment, I'm using data Input = KeyDown Key | MouseInBox (V2 Int) (V2 Int)
11:50:22 <mm_freak> Taneb: what is MouseInBox?
11:50:35 <mm_freak> i.e. what does it denote?
11:50:38 <Taneb> Ideally, it would trigger when the mouse is in the rectangle specified
11:50:54 <Eduard_Munteanu> Is there a way to place LANGUAGE pragmas in a module or separate file?
11:51:13 <mm_freak> Taneb: or it could be a behavior:  Maybe (V2 Int, V2 Int)
11:51:17 <Eduard_Munteanu> Instead of adding them to each module.
11:51:20 <mm_freak> or rather Maybe (V2 Int)
11:51:23 <fizruk> arkeet, also why did you call that "strength"?
11:51:28 <mm_freak> Taneb: what are the components of MouseInBox?
11:51:50 <Taneb> mm_freak, the V2 Ints? Corners of the rectangle
11:51:56 <meiji11> tomejaguar: sorry, I omitted a lot of code. gr has type RWST CTPEnv () CTPSt IO EPath. you see the (npc,_) <- .. pattern match on line 14? I want the npc to remain unevaluated if the call to lookup in insertOrLookup succeeds.
11:52:10 <meiji11> tomejaguar: sorry, line 24.
11:52:13 <Taneb> And I'm not sure what you mean by behaviour
11:52:54 <mm_freak> Taneb: netwire's AFRP works like this:  MyWire a b
11:52:59 <mm_freak> (let MyWire be some alias of Wire)
11:53:09 <Taneb> Right
11:53:28 <mm_freak> Taneb: Wire is the arrow for signal networks, pretty much what Moment is for reactive-banana and Reactive is for sodium
11:53:37 <mangaba_leitosa> Eduard_Munteanu: I had to use a mutable hashtable (hashtables package) to speed up word frequency counting by 100% more :-)
11:53:39 * hackagebot hmatrix 0.15.2.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.15.2.0 (AlbertoRuiz)
11:53:39 * hackagebot sorted 0.0.1 - Efficient, type-safe sorted sequences  http://hackage.haskell.org/package/sorted-0.0.1 (JosephAbrahamson)
11:53:55 <mm_freak> Taneb: a and b are behaviors, unless they are of the form Event X, in which case they are events
11:54:00 <tomejaguar> meiji11: What's IM?  IntMap?  Strict or Lazy?
11:54:04 <mm_freak> Taneb: Wire X Y
11:54:05 <meiji11> Lazy.
11:54:09 <mangaba_leitosa> Eduard_Munteanu: instead of Map... Having to use the I/O monad for counting freqs looks cumbersome, though :-(
11:54:09 <Eduard_Munteanu> mangaba_leitosa: have you tried a trie instead?
11:54:10 <meiji11> I've added type signatures if you reload the page.
11:54:15 <mm_freak> Taneb: maps a behavior of type X to a behavior of type Y
11:54:19 <Taneb> mm_freak, I was going to do it Wire Event Action
11:54:21 <mangaba_leitosa> Eduard_Munteanu: I tried TrieMap, and it's slower than Map
11:54:28 <mm_freak> Taneb: Wire (Event X) Y
11:54:37 <mm_freak> maps an Event carrying occurrences of type X to a behavior of type Y
11:54:40 <Eduard_Munteanu> mangaba_leitosa: hm... are you sure you used a strict trie?
11:54:40 <mm_freak> makes sense?
11:54:54 <mangaba_leitosa> Eduard_Munteanu: need to check now...
11:55:04 <Taneb> *Wire Input Action
11:55:08 <Taneb> Right
11:55:25 <mm_freak> Taneb: if it's not an Event, it is a Behavior, i.e. a time-varying value…  ask yourself whether Input and Action can be considered behaviors
11:55:40 <Taneb> So, I probably want Wire (Event Input) (Event Action)
11:55:49 <mm_freak> Taneb: seems more sensible, yeah
11:55:56 <Taneb> And that's getting a bit yucky :(
11:56:02 <mm_freak> Taneb: it doesn't have to
11:56:05 <mm_freak> use the 'm'
11:56:08 <mangaba_leitosa> Eduard_Munteanu: I have not found any comments about strict/lazy in the docs for TrieMap: http://hackage.haskell.org/package/TrieMap-4.0.1
11:56:31 <mm_freak> myScene :: (MonadReader Input m) => Wire s e m a X
11:56:55 <mm_freak> Taneb: then instead of passing events around you can construct an event from the underlying reader monad
11:57:07 <Taneb> Hmm, that'd work
11:57:18 <Eduard_Munteanu> mangaba_leitosa: how did you build it?
11:57:35 <mangaba_leitosa> Eduard_Munteanu: 'cabal install' :-)
11:57:49 <mangaba_leitosa> Eduard_Munteanu: or maybe 'cabal -O2 install' even
11:57:58 <tomejaguar> meiji11: Do you know where npc is getting forced?  Is it in insertOrLookup, or in ctpPath'?
11:58:05 <Eduard_Munteanu> mangaba_leitosa: heh, no, I mean how did you build the map from the input?
11:58:41 <mangaba_leitosa> Eduard_Munteanu: in the same way as for Data.Map, using your function: http://lpaste.net/95699
11:58:43 <tomejaguar> meiji11: It's hard to tell anything from here if the definition of ctpPath' is absent.
11:59:06 <meiji11> tomejaguar: the definition of ctpPath' is there.
11:59:12 <mangaba_leitosa> Eduard_Munteanu: your function in this code is 'update_freq'
11:59:47 <tomejaguar> meiji11: Sorry I meant getTruePathCost
11:59:47 <Eduard_Munteanu> mangaba_leitosa: you might need to strictify it
12:00:07 <mm_freak> Taneb: i have to go now…  just try, and i'm happy to review your code later =)
12:00:12 <mangaba_leitosa> Eduard_Munteanu: this code has two versions, one for Map and another for Data.HashTable. The second one is 2.5 times faster
12:00:38 <mm_freak> Taneb: when using the Control.Wire interface you have to be cautious…  it allows you to break out of continuous time semantics
12:01:07 <Eduard_Munteanu> @pl \a -> a `seq` (a + freq_delta)
12:01:08 <lambdabot> ap seq (freq_delta +)
12:01:23 <mangaba_leitosa> Eduard_Munteanu: I did not try it for TrieMap yet, but earlier I had tried inserting takeWhile (`seq` True) in any possible place and it never made any difference :-)
12:01:34 <meiji11> tomejaguar: ah, ok. the definition of getTruePathCost is sum . map getCost.
12:01:46 <Eduard_Munteanu> mangaba_leitosa: try just the above ^^
12:01:56 <Eduard_Munteanu> mangaba_leitosa: instead of (+ freq_delta)
12:02:07 <mangaba_leitosa> Eduard_Munteanu: thanks, will do
12:02:16 <tomejaguar> meiji11: OK, so how do you know that npc is being evaluated regardless of whether the lookup succeeds?
12:02:57 <arkeet> mangaba_leitosa: you should write type signatures for your things ;)
12:03:14 <absence> is there info somewhere about what happened to the haskell.org summer of code projects? curious about the qt bindings
12:03:40 <Eduard_Munteanu> mangaba_leitosa: I mean try it on the trie version
12:03:48 <mangaba_leitosa> Eduard_Munteanu: right...
12:03:57 <Eduard_Munteanu> It's useless for a strict Map.
12:04:17 <mangaba_leitosa> arkeet: not having to write signatures is one of the features of Haskell that I adore :_)
12:04:23 <meiji11> tomejaguar: I rewrote insertOrLookup as a monadic action that took lift $ ctpPath' ... as an input, and tested that out on the same batch of tests that I produced. the tests completed much faster. I don't know what else to attribute that to.
12:04:38 <arkeet> mangaba_leitosa: =(
12:04:57 <arkeet> it makes things much easier to understand.
12:05:16 <meiji11> tomejaguar: also.. I threw in a few putStrLn statements in gr, to try to get some sense of how deep the recursion was going according to the value of i, but.. that's probably one of these schrodinger's cat sort of deals..
12:05:20 <arkeet> and it helps pinpoint errors.
12:05:23 <Eduard_Munteanu> Yeah, I have trouble looking at code without type sigs.
12:05:29 <mangaba_leitosa> arkeet: yes, I realize that
12:05:38 <Eduard_Munteanu> I even find it a bit ugly.
12:05:43 <meiji11> tomejaguar: the i values were going much deeper than they should have, if the memoization was working as intended.
12:05:56 <arkeet> Eduard_Munteanu: yes
12:06:10 <mangaba_leitosa> Eduard_Munteanu: is there a tool or option for GHC to generate all signatures for me?
12:06:17 <Eduard_Munteanu> Back when I first heard about Haskell, I saw some code without type sigs and I thought "oh, ok... some other PHP". :)
12:06:33 <tomejaguar> meiji11: I don't see any recursion here.
12:06:39 <Eduard_Munteanu> mangaba_leitosa: you can use ':t' in ghci, but you should write them yourself
12:06:52 <mangaba_leitosa> Eduard_Munteanu: no, :t in ghci is too slow :-)
12:07:15 <Eduard_Munteanu> mangaba_leitosa: because often the type sig says a lot about the function you're about to write
12:07:15 <tomejaguar> meiji11: Can you paste the version that went faster?
12:07:19 <mangaba_leitosa> Eduard_Munteanu: I value the possibility to get things done by typing less characters :_)
12:07:23 <meiji11> tomejaguar: my fault, some key parts are omitted. the calls to greedyAlg and reposAlg end by calling travel, which calls gr again.
12:07:36 <meiji11> tomejaguar: sure, one moment.
12:08:10 <monochrom> you should do both: add your type sig to see what happens, omit your type sig to see what happens. there is useful information in both.
12:08:51 <mangaba_leitosa> Eduard_Munteanu: and I still have very vivid memories of the verbose C++ declarations and innumerable type castings I had to write, which were longer then the useful code :-)
12:09:02 <monochrom> unlike many questions asked on #haskell, the answers to which either way contains no useful information
12:09:08 <mangaba_leitosa> Eduard_Munteanu: before I got rid of C++ :-)
12:09:13 <Eduard_Munteanu> What would you call whitespace-separated, literal tokens like "foo" or "(" in the context of a parser?
12:09:24 <arkeet> mangaba_leitosa: local type inference is wonderful.
12:09:45 <arkeet> mangaba_leitosa: you can think of signatures on top-level things as serving as machine-checked documentation. ;)
12:10:07 <Eduard_Munteanu> 'keyword' sounds too specific.
12:10:35 <mangaba_leitosa> arkeet: for ocaml, there is an option that generates a module interface part with all automatically inferred signatures. Is there no such a thing for GHC?
12:10:44 <tomejaguar> mangaba_leitosa: If you force yourself to write the type signatures you will encourage yourself to write simpler code.
12:10:49 <monochrom> I would call them literals, tokens, keywords. yes, why is "(" not a keyword. it totally is.
12:10:56 <mangaba_leitosa> tomejaguar: why? :-)
12:11:21 <tomejaguar> Because as you say, you don't want to write complex type signatures.  Complex type signatures can only arise from complex code.
12:11:22 <meiji11> ok, done: http://lpaste.net/95713
12:11:37 <mangaba_leitosa> :-)
12:11:48 <Eduard_Munteanu> monochrom: I would call them literals, but the language I'm parsing also has literals in that other sense, e.g. string literals
12:12:18 <benzrf> ok here is my thought process for making a sokoban-style game
12:12:31 * Eduard_Munteanu ponders something along the lines of "verbatim" as a name for the Parsec string parser, wrapped as a token
12:12:33 <monochrom> I had 3 choices. I am fine striking out literals. I still have 2 choices.
12:12:34 <benzrf> i was thinking making an ADT for tile types, then Level = [[Tile]]
12:12:51 <benzrf> then create a series of monadic State functions that modify a Level
12:12:54 <benzrf> 'modify'
12:12:59 <benzrf> *for movement
12:13:09 <benzrf> is there a better way?
12:13:22 <benzrf> & am i misusing the word 'monadic'
12:13:38 <meiji11> maybe I'll just stick with that code.. I would like to know why they differ in performance, though. if it's a strictness issue or some other thing.
12:13:39 <Eduard_Munteanu> Hm, I already have a 'token' lifting parsers into space-delimited token parsers.
12:13:52 <Eduard_Munteanu> I guess I can just write 'token "foo"'.
12:14:09 <tomejaguar> meiji11: You realise that in the new version "ctpPath' s t (replEdges jev (emap unjam gr0)) im
12:14:18 <tomejaguar> " is only run if the lookup fails?
12:14:25 <tomejaguar> And in the original version it's run every time?
12:14:28 <tomejaguar> That's nothing to do with strictness
12:14:34 <meiji11> tomejaguar: oh? ok then.
12:15:11 <meiji11> tomejaguar: that doesn't match my understanding of how strictness works.
12:15:12 <tomejaguar> meiji11: Sure.  In 'do { a <- x; f a }' the action 'x' is *always* run regardless of whether a is evaluated.
12:15:25 <mangaba_leitosa> tomejaguar: let's assume that I want to write a function that gets a TrieMap as its input parameter, and returns TrieMap. E. g. 'f x = if x == TM.empty then x else x'. The type signature would be: f :: (Eq k, Eq a, TrieMap-4.1.0:Data.TrieMap.Representation.Class.Repr k, TrieMap-4.1.0:Data.TrieMap.TrieKey.TrieKey (TrieMap-4.1.0:Data.TrieMap.Representation.Class.Rep k)) => TM.TMap k a -> TM.TMap k a
12:15:36 <monochrom> in Haskell, "hiding" is not a keyword, but at some places the grammar wants to see the exact sequence h i d i n g. perhaps you can consult GHC source code to see how they call it.
12:15:41 <meiji11> tomejaguar: alright.. my understanding was that f x would be run only if a were needed.
12:15:43 <mangaba_leitosa> tomejaguar: the type signature is complex, but is it really a complex code?
12:16:01 <tomejaguar> meiji11: Nope, always run.
12:16:10 <benzrf> monochrom: huh?
12:16:22 <monochrom> you have a question?
12:16:24 <Eduard_Munteanu> mangaba_leitosa: er, no, you can just import the type, or write your own synonym
12:16:27 <chrisdone> mangaba_leitosa: in emacs i just hit a keybinding and it inserts the type of the declaration at point
12:16:40 <Eduard_Munteanu> Unqualified, that is.
12:16:41 <chrisdone> i never use :t
12:17:04 <meiji11> tomejaguar: I see. thanks very much for your help.
12:17:09 <chrisdone> SHODAN: i like your nickname
12:17:16 <tomejaguar> meiji11: You're welcome.
12:17:28 <bitemyapp> Why does changing this: data Complex a = Complex { real :: a, img :: a}
12:17:38 <bitemyapp> to: data Complex a = Num a => Complex { real :: a, img :: a}
12:17:45 <Eduard_Munteanu> mangaba_leitosa: you also don't really need to compare that to an empty TM
12:17:48 <bitemyapp> make it existential? How do I make it work as-is without enabling existential types?
12:17:50 <monochrom> you don't have a question.
12:17:53 <tomejaguar> mangaba_leitosa: Ha OK.  I wouldn't call that type complex, just long!  In any case, type synonyms will make it clearer.
12:18:14 <chrisdone> bitemyapp: what wouuld working 'as-is' mean?
12:18:15 <mangaba_leitosa> Eduard_Munteanu: I just wrote a simple function to demonstrate that a complex type signature does not mean that the code is overly complex
12:18:16 <FreeFull> The mouse is within bounds of the window
12:18:21 <FreeFull> Woops, was scrolled up
12:18:23 <monoidal> bitemyapp: it doesn't make it an existential, it restricts type of the constructor, it's more a GADT thing
12:18:28 <c_wraith> bitemyapp: it doesn't make it exponential, that's just one extension that allows that syntax to work
12:18:39 <monoidal> bitemyapp: GHC does suggest enabling existentials, but this is rather misleading
12:18:46 <c_wraith> bitemyapp: mostly, though, what you want to do isn't a good idea.
12:18:47 <mangaba_leitosa> tomejaguar: sure, just long. Longer then the definition of the function :-)
12:18:51 <FreeFull> > let hiding = 5 in hiding
12:18:53 <lambdabot>   5
12:18:57 <bitemyapp> c_wraith: this is from a Haskell tutorial, what's the right way to go about this?
12:19:06 <c_wraith> bitemyapp: which is why that syntax was removed in recent versions of GHC
12:19:14 <Eduard_Munteanu> mangaba_leitosa: that can be rewritten as  f :: TMap k a -> TMap k a
12:19:18 <chrisdone> the tutorial's probably old
12:19:22 <bitemyapp> c_wraith: oh, what's the right way to go?
12:19:24 <c_wraith> bitemyapp: just skip that part of the tutorial.
12:19:30 <monoidal> c_wraith: no, you're confusing it with data Num a => Complex a = ...
12:19:54 <mangaba_leitosa> Eduard_Munteanu: are you sure?  I think it will complain about the absense of Eq :-)
12:20:01 <mangaba_leitosa> Eduard_Munteanu: ah, no :-)
12:20:05 <mangaba_leitosa> Eduard_Munteanu: not in this case
12:20:21 <mangaba_leitosa> Eduard_Munteanu: will try now...
12:20:23 <Eduard_Munteanu> mangaba_leitosa: just ask if the map is empty, don't compare it to an empty map
12:20:25 <c_wraith> monoidal: I'm pretty sure it applied the constraint to the constructor, which would mean it would work as a per-constructor constraint
12:20:31 <bitemyapp> okay but what *should* I do when I want something like this?
12:20:31 <chrisdone> using “data Complex a where Complex :: Num a => ” would achieve what “data Num a => Complex a” was expected to achieve but never did
12:20:39 <bitemyapp> specifically to constraint the types?
12:20:47 <mangaba_leitosa> Eduard_Munteanu: this is not a real function I use. it's just an example for this discussion :-)
12:20:50 <Eduard_Munteanu> mangaba_leitosa: null :: TKey k => TMap k a -> Bool
12:20:56 <Eduard_Munteanu> mangaba_leitosa: yeah, I know
12:20:57 <c_wraith> bitemyapp: in general, don't constrain the types.  It doesn't give any extra benefits
12:20:57 <monoidal> c_wraith: it's not deprecated, for example data Dict c = c => Dict is still allowed
12:21:15 <monochrom> contrain the function types
12:21:19 <c_wraith> bitemyapp: instead, constrain the types on functions that *need* the constraint
12:21:20 <monoidal> c_wraith: it handles the constraint properly (match and you get evidence), unlike datatypecontexts
12:21:21 <mangaba_leitosa> Eduard_Munteanu: I was just too lazy to write something more sensible such as insert to the map :_)
12:21:31 <bitemyapp> c_wraith: okay, thank you.
12:21:31 <Eduard_Munteanu> mangaba_leitosa: it's common to import type definitions unqualified, then import everything qualified
12:21:33 <c_wraith> bitemyapp: which is more flexible
12:22:00 <Eduard_Munteanu> Or define   type TMap = TM.TMap
12:22:06 <monochrom> it is also philosophically more correct. I want to see the constraints at the API. that means function types.
12:22:14 <bitemyapp> c_wraith: so I'm making a manual record constructor?
12:22:17 <arkeet> chrisdone: I don't like carrying around dictionaries in my data. =(
12:22:29 <arkeet> unless the point is to do that.
12:22:31 <mangaba_leitosa> Eduard_Munteanu: but I don't even need to work with the TrieMap.Representation.Class.Repr typeclass explicitly, why would I import it? :-)
12:22:49 <Eduard_Munteanu> mangaba_leitosa: don't import it, I doubt you need it
12:22:49 <benzrf> @src sequence
12:22:50 <lambdabot> sequence []     = return []
12:22:50 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:22:50 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:22:53 <c_wraith> bitemyapp: err, that's not quite what I meant.  But I've got to run.  monochrom is covering the same topic, pay attention to what he's saying. :)
12:23:20 <bitemyapp> monochrom: so I should make my own record constructor?
12:23:26 <benzrf> @undo do v <- x; vs <- sequence xs; return (v:vs)
12:23:26 <lambdabot> x >>= \ v -> sequence xs >>= \ vs -> return (v : vs)
12:23:32 <bitemyapp> and gate all access/ability to construct the record type through that?
12:23:47 <monochrom> I don't understand the question and its relation to the rest
12:23:50 <jrmithdobbs> c_wraith: i have a similar question and would be interested in how i can accomplish restricting the "operator" type constructors on this gadt without adding more KeyStates and a type restriction for every possible combination of operator: http://lpaste.net/633657965655621632
12:23:51 <arkeet> sequence (x:xs) = liftM2 (:) x (sequence xs)
12:23:56 <benzrf> @src sequence_
12:23:56 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
12:24:22 <benzrf> @type sequence
12:24:23 <lambdabot> Monad m => [m a] -> m [a]
12:24:25 <benzrf> @type sequence_
12:24:26 <lambdabot> Monad m => [m a] -> m ()
12:24:30 <jrmithdobbs> c_wraith: that type is being used in a function later that uses the modifiers/ops to append/prepend a bunch of crap to the string for the "rest" (it's not really restful, but i digress) api it's talking to for queries
12:25:19 <jrmithdobbs> c_wraith: the problem is certain lvals (keys) can't be modified in (arbitrarily defined) certain ways depending on where in the api the query is being used / what kind of value is being requested
12:25:51 <jrmithdobbs> and I don't want to write a separate type for each combination of options
12:26:32 <mangaba_leitosa> Eduard_Munteanu: ghci> let  f::TM.TMap k a -> TMap k a; f map = if map == TM.empty then map else map
12:26:35 <mangaba_leitosa> <interactive>:30:49: No instance for (TrieMap-4.1.0:Data.TrieMap.TrieKey.TrieKey
12:26:46 <mangaba_leitosa> (TrieMap-4.1.0:Data.TrieMap.Representation.Class.Rep k))
12:26:53 <monochrom> you have multiple versions of TrieMap
12:26:56 <mangaba_leitosa> Eduard_Munteanu: I still need Data.TrieMap.Representation.Class.Rep typeclass :-)
12:27:19 <mangaba_leitosa> Eduard_Munteanu: If I'm to write signatures. If I don't, I don't need it :-)
12:27:20 <Eduard_Munteanu> mangaba_leitosa: what's the entire error?
12:27:26 <monochrom> when ghc error messages start to spew version numbers, it means bad. really bad.
12:27:42 <Eduard_Munteanu> Oh.
12:27:52 <Eduard_Munteanu> mangaba_leitosa: you just need to add TKey
12:28:05 <jrmithdobbs> c_wraith: what's the "right" / "suggested" way to go about that without conditions in the type constructor? a validator functio in a type class and a type for each possible key value?
12:28:06 <mangaba_leitosa> Eduard_Munteanu: aha, so I need to import TKey, too :-)
12:28:14 <Eduard_Munteanu> mangaba_leitosa: f :: TKey k => TMap k a -> TMap k a
12:28:15 <lpaste> mangaba_leitosa pasted “TrieMap” at http://lpaste.net/95718
12:29:17 <mangaba_leitosa> Eduard_Munteanu: tried that: ghci> let  f::TKey k => TMap k a -> TMap k a; f map = if map == TM.empty then map else map
12:29:20 <mangaba_leitosa> <interactive>:33:56: Could not deduce (Eq a) arising from a use of `=='
12:29:37 <Eduard_Munteanu> mangaba_leitosa: well, I told you you don't need to do that :)
12:29:54 <Eduard_Munteanu> mangaba_leitosa: if (TM.null map) ...
12:30:06 <mangaba_leitosa> Eduard_Munteanu: :-) Eduard_Munteanu the signature that works is let  f::(TKey k, Eq k, Eq a) => TMap k a -> TMap k a; f map = if map == TM.empty then map else map
12:30:20 <mangaba_leitosa> Eduard_Munteanu: the signature is longer than the function. I protest! :-)
12:30:22 <Eduard_Munteanu> You don't need any Eq if you don't compare.
12:30:47 <mangaba_leitosa> Eduard_Munteanu: let's imagine that I need to compare it to an older version of the map :-)
12:31:02 <mangaba_leitosa> Eduard_Munteanu: or two maps are passed as arguments :-)
12:32:28 <AVariedDeveloper> Has anyone played with gtk2hs built against Gtk3?  onActivateLeaf seems to have disappeared
12:32:30 <Eduard_Munteanu> mangaba_leitosa: sure but here we're writing polymorphic operations. At some point you might make concrete functions, which have simpler signatures.
12:32:37 <simpson> :t over
12:32:38 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
12:32:47 <simpson> @src over
12:32:48 <lambdabot> Source not found. stty: unknown mode: doofus
12:32:56 <mangaba_leitosa> Eduard_Munteanu: true :-)
12:33:23 <Eduard_Munteanu> mangaba_leitosa: here's a nice example...
12:33:25 <Eduard_Munteanu> :t nub
12:33:26 <lambdabot> Eq a => [a] -> [a]
12:33:49 <Eduard_Munteanu> Compare that to  nub' :: Ord a => [a] -> [a]
12:34:14 <Eduard_Munteanu> mangaba_leitosa: the Eq / Ord there even tells you something about the algorithmic complexity.
12:34:34 <Eduard_Munteanu> Since you can implement the second one much better.
12:34:59 <Eduard_Munteanu> These all are things you decide *before* you write the function, and which can guide you later.
12:35:04 <mangaba_leitosa> Eduard_Munteanu: right..
12:35:37 <Eduard_Munteanu> Now sure, if you spent a lot of time writing the function without signatures, you might see less of a point in writing them.
12:36:25 <mangaba_leitosa> Eduard_Munteanu: I understand that reading someone else's type code without type signatures is very hard
12:36:30 <Eduard_Munteanu> But two days from now you might forget which functions do what, and in many cases it's enough to read the signature.
12:36:35 <mangaba_leitosa> s/type code/code/
12:36:37 <Hodapp> Always put a signature on your functions! People have to know who wrote them!
12:36:46 <Eduard_Munteanu> Well, even yours, you might forget. :)
12:36:59 <mangaba_leitosa> Eduard_Munteanu: in such cases, I do ':t' in ghci :-)
12:38:00 <chrisdone> ideally decl type signatures would only be something our editors would show as overlays
12:38:25 <tomejaguar> Reading *my own* code without type signatures is very hard.
12:38:33 <tomejaguar> Or at least harder than with :)
12:38:51 <mangaba_leitosa> chrisdone: you said that emacs inserts the signature, does it do :t in ghci for you?
12:39:10 <Eduard_Munteanu> We really need structural editors.
12:39:22 <jrmithdobbs> Eduard_Munteanu: stack traces first please
12:39:24 <arkeet> mangaba_leitosa: it presumably goes out to ghc-mod or something to get that information.
12:39:26 <jrmithdobbs> seriously
12:39:50 <chrisdone> mangaba_leitosa: yeah, it calls :t in emacs and then inserts it above the decl
12:39:55 <jrmithdobbs> i'd take a good stack trace over more dumb editor features noone will ever use any day
12:39:59 <Eduard_Munteanu> Not only because you get more info from it, but programmers should stop laying out code.
12:40:04 <mangaba_leitosa> chrisdone: I need to check if there is such a thing for vim :_)
12:40:17 <arkeet> mangaba_leitosa: check out hdevtools ;)
12:40:20 <chrisdone> probably in vim it would be via ghc-mod or hdevtools
12:40:25 <arkeet> or that
12:40:25 <monochrom> how much money will you pay for stack traces?
12:40:26 <Eduard_Munteanu> I should define my own indent style and open anything anybody wrote and have it shown like I want.
12:40:33 <mangaba_leitosa> arkeet: thanks
12:40:48 <chrisdone> monochrom: more than facebook? ;)
12:40:56 <Eduard_Munteanu> And I should be able to use proportional fonts and still have things aligned nicely.
12:41:05 <monochrom> haha, facebook won
12:41:09 <chrisdone> Eduard_Munteanu: one step at a time
12:41:19 <jrmithdobbs> monochrom: right now i don't have anything to justify it, but I'm unwilling to rule that out later down the line.
12:41:31 <mangaba_leitosa> Eduard_Munteanu: and then you would not have been complaining about the missing type signatures (the editor would have visualized them for you) :-)
12:41:52 <chrisdone> i would like haskell code to be like html
12:41:57 <monochrom> justify? rule out? did I ask about justify and rule out? I thought I just asked about paying.
12:41:58 * Hodapp looks at chrisdone
12:41:59 <Eduard_Munteanu> mangaba_leitosa: possibly, though I write the signature before the implementation
12:42:03 <tomejaguar> mangaba_leitosa: No, *automatically generated* signatures are not the point.  Knowing that the compiler and original author *agreed* on a type is teh point.
12:42:06 <chrisdone> before you get the wrong idea, i'll explain
12:42:46 <arkeet> in other words, use the type to guide the implementation
12:43:03 <chrisdone> nobody formats their HTML anymore (apart from kids that think it's important), it's all generated and by the time it hits your browser it's a pile of mush. if you want to view it, you use your chrome developer bar or whatever and view/edit the html as a tree
12:43:35 <jrmithdobbs> chrisdone: so you want :set ts=2 sw=2 sts=2 expandtab syntax=haskell
12:43:40 <jrmithdobbs> chrisdone: and for people to not use tabs
12:43:44 <chrisdone> vim can't do structured editing
12:43:52 <chrisdone> silly vimmers
12:44:21 <jrmithdobbs> wanting structured editing means your source layout and/or code are too complex
12:44:21 <jrmithdobbs> imho
12:44:23 <monochrom> can emacs do structured editing? or is it just your wonderous addition to emacs that can? :)
12:44:26 <chrisdone> we're still at the stage where people place a lot of importance on the control they have over the layout of code
12:44:28 <Eduard_Munteanu> chrisdone: vim can't even do syntax highlighting properly
12:44:41 <adnap> Is it possible to convert an arbitrary function to bits in any way other than the binary reresentation of its source code modulo compression?
12:44:43 <mangaba_leitosa> tomejaguar: I got a Scala course on coursera and I just hate its requirement to always give signatures :-)
12:44:56 <Eduard_Munteanu> Writing regexes for highlighting doesn't qualify as "properly". :)
12:44:58 <chrisdone> jrmithdobbs: wanting structured editing is just natural
12:45:13 <TravisD> what is structural editing?
12:45:16 <chrisdone> people say they don't want structured editing because they don't have it
12:45:27 <simpson> TravisD: Ever used Smalltalk? :3
12:45:32 <TravisD> simpson: no :(
12:45:45 <jrmithdobbs> chrisdone: what does structured editing give me over a few macvim windows and a tmux session? nothing as far as i can tell
12:45:46 <monochrom> indeed, I say "I don't want stack trace" because I don't have it. therefore, I realize that, and I decide to not say it.
12:45:57 <simpson> TravisD: Imagine that your language comes with an editor that groks every aspect of the semantic structure of your language.
12:45:58 <Eduard_Munteanu> TravisD: instead of using a character-oriented editor, you use something that's aware of the language and can divide things into logical units
12:45:59 <jrmithdobbs> chrisdone: its just another toolchain to masturbate over instead of working imho
12:46:10 <TravisD> ah
12:46:13 <Lethalman> Eduard_Munteanu, it does if you use a tree of regexs, there you emulate a descent parser somehow
12:46:15 <simpson> TravisD: And you write code not character-by-character, but piece-by-piece.
12:46:26 <Lethalman> that's what gtksourceview uses
12:46:27 <chrisdone> jrmithdobbs: yeah, exactly. *you* are that guy
12:46:43 <chrisdone> monochrom: see! i was being hyperbolic, but this guy's serious
12:46:56 <Eduard_Munteanu> Lethalman: sort of... it assumes you can tokenize things into the right categories by some rigid rules. That breaks for e.g. Agda.
12:46:56 <simpson> jrmithdobbs: You're probably thinking of Java IDEs like Eclipse, right?
12:47:02 <TravisD> Aren't some languages (I'm thinking of lisp) just textual representations of the structures in the language?
12:47:05 <simpson> jrmithdobbs: Java took all of that from Smalltalk. :3
12:47:07 <jrmithdobbs> chrisdone: i asked a serious question
12:47:16 <monochrom> my measure of seriousness is "put your money where your mouth is"
12:47:18 <jrmithdobbs> chrisdone: what does it give me?
12:47:20 <simpson> TravisD: I think of Forths, but sure.
12:47:21 <Lethalman> Eduard_Munteanu, no because sub regex can fail, just like sub trees of a parser fail
12:47:21 <chrisdone> jrmithdobbs: well what is structured editing?
12:47:41 <jrmithdobbs> chrisdone: it's things like those toy ides for scala and such right?
12:47:57 <chrisdone> i don't know. what are those toy ides for scala and such?
12:48:00 <jrmithdobbs> or is the one i'm thinking of in cloqure
12:48:03 <monochrom> this conversation is becoming, like, a debate in a legislature. how and why to spend other people's money.
12:48:04 <jrmithdobbs> clojure
12:48:15 <Eduard_Munteanu> Lethalman: but you can't always know the meaning of certain tokens just by the name. In Agda you can define your own operators, containing pretty much any character.
12:48:30 <Lethalman> Eduard_Munteanu, there's a context, it's not only a name
12:48:33 <Eduard_Munteanu> Lethalman: if your editor doesn't understand declarations, it can't highlight it correctly
12:48:37 <Lethalman> just like a parser, except you use multiple regexs
12:48:49 <chrisdone> jrmithdobbs: ah, you're thinking of the one that puts code in little bubbles and such. i can't remember the name either
12:48:51 <Lethalman> Eduard_Munteanu, that's contextual parsing, not context-free
12:48:57 <Lethalman> i'm obviously talking about context-free parsing
12:49:37 <jrmithdobbs> chrisdone: ya, can't find it right now
12:49:51 <Eduard_Munteanu> Lethalman: oh, ok. But I still think it's ugly, because the compiler is a much saner and authoritative source of classifying tokens.
12:50:03 <Lethalman> Eduard_Munteanu, but we were talking about editors :)
12:50:16 <Lethalman> and describing syntax with a tree of regexs it's extremely handy
12:50:23 <Eduard_Munteanu> Lethalman: yes, the editor should call the compiler, why reimplement something, and poorly?
12:50:35 <jrmithdobbs> chrisdone: is that *not* what you mean by structured editing?
12:51:03 <Lethalman> Eduard_Munteanu, because sometimes it's too slow, or imprecise, whereas parser-only might be error tolerant
12:51:07 <Lethalman> and fast
12:51:25 <chrisdone> jrmithdobbs: anyway, i think of it in terms of layers. your basic editing is character-by-character. a less dumb setup is word-by-word, line-by-line, paragraphs, "obvious" things like parentheses, string delimieters, etc. then you have proper expression awareness via a full parser "do this thing in this type of expression, go to this expression, grab that", then you don't have parsing anymore, you have a database, etc. until you're in
12:51:25 <chrisdone> the matrix like Neo and Morpheus is looking smug
12:51:47 <jrmithdobbs> Eduard_Munteanu: because editors deployed to build systems to try and build shit (god i wish i hadn't actually seen this done with eclipse before) makes me vomit in your face (not a little in my mouth)
12:51:49 <Eduard_Munteanu> Lethalman: you need a compiler that can do that, yes
12:52:04 <Lethalman> personally I wouldn't use a compiler for highlighting, but just a parser that does the job
12:52:04 <Lethalman> for semantic things, of course use the compiler itself
12:52:21 <chrisdone> jrmithdobbs: most editors are at the "characters, words, delimeters" level. my emacs mode is at the parsing level. lamdu is at the database level
12:52:42 <Eduard_Munteanu> jrmithdobbs: this has nothing to do with building, actually
12:52:59 <Eduard_Munteanu> Asking the compiler for a representation of a text file isn't quite building.
12:53:09 <jrmithdobbs> chrisdone: right so your editor actually becomes an AST storage db that serializes to code the compiler can understand
12:53:21 <mangaba_leitosa> Eduard_Munteanu: I got distracted by the signatures discussion, but now I tried your proposed (ap seq (freq_delta +)) change, no difference :-)
12:53:36 <chrisdone> jrmithdobbs: i see that as going from very little structure to more structure. at some point it becomes "structured" like losing hair becomes "bald", i don't know the exact point, but words and characters isn't it =)
12:53:53 <mangaba_leitosa> Eduard_Munteanu: with my test input, I get 13 seconds for Map, 17 seconds for TrieMap and 5 seconds for Hashtable
12:54:06 <Eduard_Munteanu> Lethalman: there's more nonsense, like ctags and the likes, not just highlighting
12:54:17 <chrisdone> jrmithdobbs: possibly, yeah. lamdu stores code in a database and has its own online type-checker as-you-type
12:54:35 <jrmithdobbs> chrisdone: it's a nifty concept, i just don't see the value to anyone except the least experienced in any given language and that doesn't seem worthwhile to me
12:54:36 <CJIoHuK> hi
12:54:59 <chrisdone> jrmithdobbs: the old interlisp lisp implementation in 1982 would actually update the running program as you typed, no restart, no hotswap, just in-place. there's a variety in the “structured” world
12:55:02 <Lethalman> Eduard_Munteanu, ctags is what you would have in the memory, except in a file and usable by more editors, I don't get the nonsense here
12:55:22 <Eduard_Munteanu> Lethalman: and stuff like gcc is unsuitable, I agree... but you can build incremental parsers in compilers
12:55:49 <chrisdone> jrmithdobbs: you don't see the value in your editor grokking more structure about your code?
12:55:52 <jrmithdobbs> chrisdone: eg, you can accomplish the same productivity goals in ruby with pry and it's edit* commands, you in a running ruby interp, edit-file src/new_class.rb, save it in the vim/whatever window that pops up, and it's loaded into your state (assuming something is referencing it)
12:56:11 <jrmithdobbs> chrisdone: i think paradigms like that are more useful than what i've seen described as "structured editors"
12:56:21 <jrmithdobbs> chrisdone: ghci can do some of that
12:56:21 <Eduard_Munteanu> Lethalman: the nonsense is trying to parse declarations without understanding the language
12:56:25 <jrmithdobbs> (seemingly)
12:56:48 <chrisdone> jrmithdobbs: here's a trivial example. consider indentation, how does your editor know how to indent and re-indent your code?
12:57:17 <jrmithdobbs> chrisdone: from it's syntax rules definitions
12:57:17 <chrisdone> jrmithdobbs: the best indentation modes for haskell come in emacs, and even they are pretty sucky
12:57:25 <Lethalman> Eduard_Munteanu, it's not nonsense, it's nonsense that you are ignoring the fact that it works very well
12:57:28 <jrmithdobbs> chrisdone: (you don't have to pretend, not ashamed of using vim ;p)
12:58:14 <klugez> jrmithdobbs: I think as a Vim user you already have rudimentary structural editing in text objects. They are just generic instead of specific to the language.
12:58:41 <chrisdone> jrmithdobbs: right -- so the more the editor knows about your language, the better it can do that stuff for you, so that you just think about what you're doing rather than how many spaces in or out something should be based on how many characters are here or there
12:58:44 <Eduard_Munteanu> Lethalman: it sort of works, not for all languages though. Many languages probably make that concession for this specific purpose.
12:58:49 <CJIoHuK> ppl can I ask you. i want to improve my english . is it impossible here or i should try another place?) somebody want to talk with russian girl?)
12:59:12 <Eduard_Munteanu> Lethalman: for instance, I'm not sure... what editors can tell a type constructor from a data constructor?
12:59:16 <mcstar> will you marry me?
12:59:16 <chrisdone> ^ please kick the bot
12:59:29 <Lethalman> Eduard_Munteanu, that's semantics, not parsing
12:59:49 <jrmithdobbs> chrisdone: I don't understand the argument, is tabstop legibility such a work-stopping issue for you that this is actually worthwhile?
12:59:51 <Eduard_Munteanu> Lethalman: ok, so how do I get them highlighted differently?
12:59:51 <mcstar> chrisdone: did i offend you in some way? (j/k)
13:00:16 <benzrf> CJIoHuK: why are you asking here, of all places?
13:00:54 <chrisdone> jrmithdobbs: actually, it doesn't matter much. if you're entirely happy with your editing setup—as it appears to be—i don't need to tell you about anything better
13:01:00 <chrisdone> as you were
13:01:00 <klugez> jrmithdobbs: No, I think chrisdone's point is that fixing indentation is busywork that you wouldn't have to do if you'd talk to the editor in terms of the structure of the code.
13:01:25 <jrmithdobbs> klugez: and i'm asking the 80/20 question
13:01:32 <CJIoHuK> benzrf: it was random choice from other rooms
13:01:40 <jrmithdobbs> klugez: is enough time spent prettying up whitespace that the conversation matters to begin with?
13:01:46 <jrmithdobbs> (I'd postulate: no)
13:01:50 <adnap> chrisdone: Can you give a hypothetical example of structured editing with Haskell? I don't understand the concept specifically
13:02:02 <jrmithdobbs> maybe you need a better example than whitespace?
13:02:07 <mcstar> what became of bottle?
13:02:07 <jrmithdobbs> s/you/I/
13:02:11 <Eduard_Munteanu> Lethalman: I'm just saying it's much more easy to talk to a code analysis-friendly compiler.
13:02:37 <Eduard_Munteanu> Lethalman: Agda does this, for example, with its agda-mode for Emacs.
13:02:42 <Zorban> I'm working on a small project with minuscule graphical output, that could also be visualized using simple ASCII characters (think Game of LIfe, for instance)
13:02:44 <chrisdone> mcstar: bottle was renamed to lamdu and is still in active development
13:02:51 <Zorban> I could do this with a GUI framework
13:02:52 <fizruk> CJIoHuK, nice nick)
13:02:56 <mcstar> right, i just always forget the new name...
13:02:58 <Eduard_Munteanu> And it's extremely useful for its purposes.
13:02:58 <Zorban> but how would I do this in the console?
13:02:59 <chrisdone> jrmithdobbs: adnap: let me see if i can make a quick example
13:03:03 <jrmithdobbs> klugez: which is why i made the toolchain masturbation comment earlier, it's like arguing autotools vs cmake, use whichever you know you can get to work
13:03:05 <dv-> Zorban: ncurses
13:03:16 <Zorban> is there a way to keep a "window" and simply redraw the lines
13:03:22 <Lethalman> Eduard_Munteanu, i'm talking about parsing, you about semantics... let's stop this
13:03:23 <geekosaur> ncurses
13:03:26 <Zorban> maybe like ASCII games way back in the days
13:03:30 <geekosaur> also possibly aalib...
13:03:35 <CJIoHuK> fizruk: sure	
13:03:40 <mcstar> @hoogly vty
13:03:40 <lambdabot> package vty
13:03:40 <lambdabot> package vty-menu
13:03:40 <lambdabot> package vty-ui
13:03:50 <adnap> "Use what you know" is not a bulletproof philosophy because it discourages learning new things
13:03:59 <klugez> jrmithdobbs: Well, management of whitespace tends to take way too much time for me, because the automatic indentation for Haskell sucks. So it's one example of things that would be better, if we could talk about the structure instead of doing it with editing commands designed for any text.
13:04:10 <jrmithdobbs> adnap: i'll give you that
13:04:25 <klugez> But it's not like it's anything central.
13:04:26 * mcstar thinks emacs has a nice indenter for haskell
13:04:36 <adnap> I don't spend much time at all managing whitespace
13:04:37 <klugez> mcstar: Which one?
13:04:40 <Eduard_Munteanu> Lethalman: I was under the impression you were arguing for doing these things in the editor, independently of the compiler.
13:04:40 <Zorban> dv- thanks! That's exactly what I had in mind!
13:04:54 <Eduard_Munteanu> Not about parsing per se, except by generality.
13:05:05 <jrmithdobbs> adnap: i don't either, that's why the example doesn't make sense to me (haskell also isn't the language i primarily work in, as I'm sure has become obvious ;p)
13:05:07 <Lethalman> Eduard_Munteanu, yes, for the parsing step, for highlighting and indentation...
13:05:34 <adnap> chrisdone: Please highlight me when you post the example. I'm going AFK
13:05:59 <mcstar> klugez: i think the default one of haskell-mode, it does the right job most of the time
13:06:20 <Zorban> thanks for all the help! Off to work again :)
13:06:22 <mcstar> klugez: are you familiar with emacs' 'smart' indent on tab?
13:06:25 <klugez> mcstar: Umm, I think haskell-mode makes you choose from one of three and doesn't have a default one.
13:06:34 <Eduard_Munteanu> Lethalman: ok, any particular reason, or do you think it's good enough when you don't need to do more? Because I can't really see a reason to do that on purpose, except if the compiler sucks at it, e.g. gcc
13:06:44 <mcstar> klugez: yeah, but i just checked me .emacs and found nothing special :(
13:06:50 <mcstar> i remember i had to choose one...
13:07:28 <Eduard_Munteanu> gcc is quite alright at compiling, but has a reputation of being sucky at using it as a library or for code analysis, I mean.
13:07:32 <klugez> I'm using haskell-indentation right now, but I don't find it very good.
13:08:01 <jrmithdobbs> i have auto ident off in vim completely ;p
13:08:02 <Eduard_Munteanu> (well, aside from being slow-ish at compiling)
13:08:19 <jrmithdobbs> s/ident/indent/
13:08:29 <mcstar> klugez: all i have is (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
13:08:34 <jrmithdobbs> no matter the syntax loaded
13:08:52 <klugez> mcstar: Ah, so you're using the same one, but happy with it.
13:08:59 <monochrom> I use turn-on-haskell-indentation too
13:09:07 <mcstar> klugez: yeah, completely
13:09:22 <Eduard_Munteanu> I should try evil sometime.
13:09:23 <mcstar> klugez: am i missing out on something?
13:09:43 <klugez> mcstar: No, because that's the best one I know. I'm just not happy with it. :)
13:09:43 <Eduard_Munteanu> vim is a bit annoying, but I like its bindings
13:09:50 <klugez> I'm using evil.
13:09:55 <klugez> Recent convert from Vim.
13:10:02 <monochrom> http://lpaste.net/47103/emacs_haskellmode_demo
13:10:17 <jrmithdobbs> Eduard_Munteanu: i'm a fan of how vim modes work vs meta key usage in emacs
13:10:53 <chrisdone> oh, that's better
13:10:53 <jrmithdobbs> Eduard_Munteanu: pretty much the main reason i use vim over emacs (I switched "backwards", started with emacs)
13:11:28 <chrisdone> jrmithdobbs: how about you paste me some of your code and i'll refactor it and record it
13:11:40 <jrmithdobbs> http://lpaste.net/633657965655621632
13:11:49 <chrisdone> something more complex
13:11:54 <monochrom> I don't like modes. I'm forgetful.
13:12:10 <jrmithdobbs> chrisdone: don't have anything more complex i can share that's in haskell ;p
13:12:24 * monochrom thinks
13:12:50 <chrisdone> monochrom: don't do that, it's dangerous
13:13:44 <jrmithdobbs> chrisdone: can you do c? because this code is pretty ugly and I just dumped it before i took a job: https://github.com/jrmithdobbs/sdmckt
13:13:52 <klugez> http://lpaste.net/95719 - Here's my game of life thing. Comments are welcome.
13:15:30 <monochrom> chrisdone: may be http://www.vex.net/~trebla/haskell/gtk-interact.xhtml is interesting enough
13:21:31 <jrmithdobbs> also, wtf does github label that repo as c++? that's definitely 100% c99 code ... i guess using function pointers == c++ to github's parser, ha
13:22:10 <Eduard_Munteanu> jrmithdobbs: it's not really easy to tell them apart generally
13:22:28 <gsnedders> jrmithdobbs: https://github.com/github/linguist is what it uses to identify them, FWIW, if you want to dig in
13:22:29 <Eduard_Munteanu> So they probably biased it towards C++.
13:22:34 <japesinator> Is it possible to take a nested list, an x value, a y value, and another arbitrary value and change the element at the x/y position in the list to the given value?
13:22:47 <benzrf> japesinator: no, that would be mutation
13:22:47 <benzrf> :D
13:22:53 <benzrf> [but yes] probably
13:23:05 <Eduard_Munteanu> japesinator: yeah, but I wouldn't use a list
13:23:22 <Eduard_Munteanu> An array would be nicer.
13:23:29 <japesinator> Yeah, I just thought about that.  How about a function that takes the same parameters as before and generates a new list with the given change?
13:23:30 <Eduard_Munteanu> Or Map.
13:23:32 <benzrf> haskell has arrays?
13:23:38 <Eduard_Munteanu> benzrf: sure
13:23:52 <mcstar> even immutable ones!
13:23:58 <benzrf> how do you recommend representing a static grid with quick lookup?
13:24:07 <johnw> an array :)
13:24:10 <benzrf> thought so
13:24:12 <benzrf> usage?
13:24:20 <Eduard_Munteanu> benzrf: or Map if it's sparse
13:24:28 <mcstar> or vector, if you want mutability
13:24:31 <enzo_> Hey can anyone tell me what is a good data structure for a recombining binomial tree?
13:24:42 <benzrf> Eduard_Munteanu: im gonna try making a simple sokoban-like for practice
13:25:41 <sup_trix> hello
13:26:10 <sup_trix> i have a question about a haskell error i get when using genObjectNames
13:26:19 <japesinator> I'm working on a tic-tac-toe bot to get better at haskell and I want a function to look ahead at hypothetical moves
13:26:20 <sup_trix> anyone out there lend me a hand
13:26:34 <japesinator> sup_trix:  What's your error?
13:26:49 <geekosaur> @lpaste code and error
13:26:49 <lambdabot> Haskell pastebin: http://lpaste.net/
13:26:52 <sup_trix> No instance for (ObjectName b0)       arising from a use of `genObjectNames'
13:27:16 <sup_trix> thanks for asking japesinator
13:27:31 <FireFly> Eduard_Munteanu: you'd think it'd at least use filename as a tie breaker (re. github and C vs. C++)
13:27:32 <Eduard_Munteanu> Heh, for tic-tac-toe even a tuple isn't very annoying
13:27:35 <FireFly> file extension, rather
13:27:41 <Eduard_Munteanu> Hm, fair.
13:27:50 <jrmithdobbs> FireFly: you would, but it doesn't seem to
13:28:11 <sup_trix> i have tried searching on the error message.
13:28:15 <sup_trix> but no luck.
13:28:22 <japesinator> sup_trix: What's :t genObjectNames?
13:28:22 <sup_trix> and i see lots of people using this line of code
13:28:35 <jrmithdobbs> FireFly: that repo i pasted builds with -Wall -pedantantic -std=c99 ... *with llvm*
13:28:35 <benzrf> @type genObjectNames
13:28:36 <lambdabot> Not in scope: `genObjectNames'
13:28:37 <sup_trix> trying to display graphics
13:29:01 <jrmithdobbs> FireFly: so it's definitely not c++ or using c++ filenames anywhere ;p
13:29:02 <benzrf> jrmithdobbs: pedantantic?
13:29:08 <FireFly> Haha
13:29:09 <japesinator> Edward_Munt:  A nested tuple? Would that work better than a nested list?
13:29:36 <Eduard_Munteanu> japesinator: not nested, just 9 components
13:29:36 * FireFly thinks benzrf was compiled with -pedantic
13:29:37 <sup_trix> not in scope?..hum..i think i included the right stuffs
13:29:57 <sup_trix> import Graphics.Rendering.OpenGL
13:30:06 <sup_trix> i think this import should help me?
13:31:19 <sup_trix>      [tex] <- genObjectNames 1
13:31:26 <sup_trix> this is the line that i am using
13:31:37 <japesinator> Edward_Munt:  I think analyzing rows/columns is easier/more readable with transposition and such.  Are there significant benefits to switching data types?
13:31:56 <jrmithdobbs> benzrf: means compile error on warning
13:32:04 <jrmithdobbs> benzrf: and a few other semantics iirc
13:32:11 <benzrf> jrmithdobbs: pedantantic
13:32:14 <benzrf> is what you said
13:32:26 <jrmithdobbs> oh ha
13:32:46 <Cale> sup_trix: That seems like it should work, but you could also use  tex <- genObjectName
13:32:47 <sup_trix> anythoughts japesinator or lambdabot
13:32:53 <jrmithdobbs> someone walked into my office in the middle of typing that line sorry ;p
13:32:57 <sup_trix> ill try that just a min
13:33:01 <sup_trix> thanks Cale
13:33:03 <Eduard_Munteanu> japesinator: you can just transpose indices if you use a Map or array.
13:33:05 <Cale> sup_trix: and avoid the needless list structure since you're only generating one
13:33:11 <sup_trix> righto
13:33:20 <Cale> sup_trix: What error are you getting? Not in scope?
13:34:00 <sup_trix> Not in scope: `genObjectName'
13:34:11 <sup_trix> but i dont get the not in scope for the genObjectNames
13:34:17 <sup_trix> strange..
13:34:23 <Cale> ghc-pkg list OpenGL
13:34:46 <Cale> (so we can tell which version it is)
13:35:21 <sup_trix> OpenGL-2.8.0.0
13:35:40 <Cale> ah, okay
13:35:50 <Cale> Apparently genObjectName is new, oddly enough
13:36:51 <Cale> sup_trix: Oh, I just saw your actual error message above.
13:36:58 <japesinator> Edward_Munt: Maps indexed by coordinates look pretty useful. I'll definitely check those out. Thanks!
13:37:16 <Cale> That sounds like the type of the result isn't being determined by the rest of the code, so it doesn't know *which* type of ObjectName to generate
13:37:31 <sup_trix> righto......
13:37:37 <sup_trix> cale...i guessed that too..
13:37:44 <sup_trix> but so many use this line...
13:37:51 <Cale> sup_trix: So if you just use tex in the rest of the code
13:37:54 <Cale> You'll be fine
13:38:29 <sup_trix> i dont get that
13:38:49 <sup_trix> should i update my openGL
13:39:00 <Cale> no, that's not the problem
13:39:09 <sup_trix> k
13:39:18 <Cale> The problem is not with the line [tex] <- genObjectNames  -- that's fine
13:39:28 <Cale> The problem is you're not *using* tex anywhere else
13:39:33 <sup_trix> oh....
13:39:42 <Cale> So, it doesn't know which instance of genObjectNames you want to use
13:39:44 <sup_trix> i see...lemme try to move on
13:39:50 <sup_trix> i get you
13:39:53 <sup_trix> brb..cale..
13:39:54 <benzrf> sup_trix: under-defined
13:40:01 <sup_trix> thanks..i am gunna try
13:40:10 <benzrf> sup_trix: you could probably add a type annotation to fix it , or something
13:41:48 <Cale> Yeah, you could, but you probably won't have to
13:49:46 <lpaste> fizruk pasted “MonadWriter laws?” at http://lpaste.net/95720
13:50:17 <fizruk> can anyone tell is these (should) hold for any MonadWriter instance? ^
13:58:23 <absence> is there info somewhere about what happened to the haskell.org summer of code projects? curious about the qt bindings
14:00:19 <carter> absence: i mentored it
14:00:26 <carter> the first half of the project worked out
14:00:38 <carter> basically the fficxx lib / tooling got more polished
14:00:55 <carter> which is all i expected to happen
14:01:17 <carter> "generating a c++ wrapper automatically thats resuable" is a bit of work :)
14:07:06 <mafovich> a quick question
14:07:23 <mafovich> is there an easy way to debug haskell code line by line?
14:07:30 <carter> depends on the code
14:07:31 <carter> :)
14:08:15 <Cale> mafovich: There is the ghci debugger
14:08:35 <mafovich> how to use that? I looked it up but I'm a bit confused
14:08:36 <Cale> But "line by line" can be weird in the presence of (partially!) lazy evaluation
14:08:53 * hackagebot shake 0.10.9 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.9 (NeilMitchell)
14:09:32 <Cale> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/ghci-debugger.html has some examples of usage
14:12:24 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html (not sure if there are differences) -- it's sort of unfortunate that googling for documentation is almost certain to give you an old version.
14:12:30 <mafovich> the code seems to throw errors before compiling
14:12:55 <Cale> Well, you can't run code which doesn't compile
14:13:43 <mafovich> this may be a stupid question, but how do I run IO within a function?
14:13:43 <Cale> Though in the next GHC, there will be a feature which will turn type errors into runtime errors when switched on.
14:13:56 <carter> Cale: no… 7.6 has that too
14:14:02 <Cale> carter: oh, does it already?
14:14:07 <mafovich> suppose I have ([[Char]], [Char]) -> ([[Char]], [Char])
14:14:10 <Cale> Nice! I thought that was for 7.8
14:14:10 <geekosaur> 7.6 already has -fdefer-type-errors
14:14:14 <Cale> cool
14:14:32 <Cale> mafovich: A function of that type cannot do I/O
14:14:44 <mafovich> well, how to do it then?
14:14:59 <geekosaur> put the function in IO
14:15:12 <mafovich> okay then
14:15:14 <geekosaur> or try to rearrange things so the IO doesn't need to happen in the function
14:15:17 <Cale> In order to express I/O, the function would have to produce an IO action as its result
14:15:18 <absence> carter: cool, that's a start at least :)
14:15:41 <mafovich> can I run IO function inside of the code
14:15:47 <mafovich> inside the other function
14:15:48 <Cale> e.g. you might make the type  ([String], String) -> IO ([String], String)
14:16:40 <Cale> You cannot execute IO actions inside of the evaluation of a function
14:16:40 <dwcook> IO and functions are two separate concepts. All functions are pure, but they can produce IO procedures.
14:17:00 <Cale> Only other IO actions can execute IO actions.
14:17:57 <Cale> But IO actions can depend on the results of ordinary functions.
14:18:13 <Cale> For example, consider  do x <- getLine; putStrLn (reverse x)
14:18:33 <Cale> reverse :: [a] -> [a], or in this case, String -> String
14:18:47 <Cale> and it doesn't need to know or care that the String it's getting came from user input
14:21:11 <Cale> So, Haskell programs will usually have a fairly clean line between code which says how input and output should take place (i.e. the "view" and "controller" if you're familiar with OOP concepts), and code which manipulates values and expresses how to turn the stuff obtained from input into the stuff which is going to be output in some way (the "model")
14:21:39 <Cale> and that line is enforced by the type system
14:22:33 <Cale> If you want, you can write absolutely everything in such a way that you always produce IO actions, but it does mean giving up on one of the largest advantages of using Haskell in the first place
14:22:55 <Cale> (however, Haskell used in this way still makes an excellent imperative language)
14:23:51 <simpson> I've found that this "Write everything in IO and clean stuff up later" approach doesn't not work. :3
14:24:11 <benzrf> i am suspect of yagni for a similar reaosn
14:24:12 <benzrf> *reason
14:24:19 <Cale> Well, it will "work" about as well as programming in an imperative language does.
14:24:32 <mangaba_leitosa> Cale: "if you want": I don't, please give me another Hashtables which wouldn't force me to use a ST/IO monad :-)
14:24:45 <Cale> mangaba_leitosa: Data.Map
14:25:01 <chrisdone> Cale: yeah, i *really* like that in mvc with haskell, all my view code can be e.g. blaze-html i pop them in *.View modules and i know inside them it can only be x :: Html
14:25:07 <mangaba_leitosa> Cale: 2.5 times slower on counting word frequencies, as discussed here previously :-)
14:25:18 <Cale> mangaba_leitosa: Have you tried Data.HashMap?
14:25:34 <Cale> http://hackage.haskell.org/package/unordered-containers
14:25:39 <mangaba_leitosa> Cale: not yet... Only Map, TrieMap and Hashtables so far :-)
14:25:40 <chrisdone> Cale:  in other codebases i tend to get lost on the difference between the view and the controller. in haskell it's in the types
14:25:45 <Cale> Data.HashMap.Strict perhaps
14:26:05 <mangaba_leitosa> Cale: thanks, will try this one, too. Will it work for ByteString keys?
14:26:07 <acowley> How about edwardk's structures repo?
14:26:14 <Cale> mangaba_leitosa: For the most part, Data.Map is fast enough for 99% of practical use cases.
14:26:21 <Cale> (in my experience anyway)
14:26:28 <mangaba_leitosa> Cale: right, but not for my case :-)
14:26:52 <Cale> yes it will
14:26:57 <mangaba_leitosa> great
14:27:07 <Cale> (either Lazy or Strict ByteStrings, both are instances of Hashable)
14:27:33 * mangaba_leitosa hopes that this ones won't be that much slower than hashtables
14:27:44 <chrisdone> mangaba_leitosa: still on it?
14:28:04 <mangaba_leitosa> chrisdone: yes :-)
14:28:09 <Cale> mangaba_leitosa: It should be pretty trivial to switch your Data.Map code to use this
14:28:18 <chrisdone> mangaba_leitosa: stubborn, you are. you will go far
14:28:21 <Cale> because the interface is nearly identical to Data.Map
14:28:30 <mangaba_leitosa> chrisdone: :-))
14:28:54 <acowley> mangaba_leitosa: Try https://github.com/ekmett/structures/blob/master/src/Data/Vector/Map.hs if you get desperate!
14:29:45 <Cale> mangaba_leitosa: You do have to pay *something* to naively go from a structure which destroys all evidence of its past to one which you can do things to quickly and still have access to all old versions.
14:30:12 <Cale> But usually it's not so expensive that you'd actually worry about it.
14:30:21 <Cale> (It's a log factor)
14:30:25 <mangaba_leitosa> acowley: thanks, did not come accross this one so far :)
14:30:48 <mangaba_leitosa> acowley: this is not a part of Data.Vector, right?
14:31:04 <acowley> mangaba_leitosa: That is experimental code
14:31:14 <acowley> mangaba_leitosa: But perhaps the tradeoffs it makes will work out for your use case
14:31:24 <acowley> e.g. I don't think it supports delete yet, but you don't need that
14:31:25 <chrisdone> i can see the blog posts now. “my hardious hike hacross haskell hashtable hell”
14:31:29 <Cale> mangaba_leitosa: No, it's Ed's experimental stuff. I recall he said Data.Map was still beating it in some cases.
14:31:48 <Cale> But that it was winning in some others
14:31:49 <mangaba_leitosa> chrisdone: :-)
14:31:52 <acowley> Yeah, it wins in a few benchmarks
14:32:09 <carter> acowley: i really need to get back to helping on that project
14:32:11 <acowley> I think the benchmark I wrote way back still has Data.Map winning, though
14:32:37 <chrisdone> i suppose what you're really lacking is the years of effort gone into that C code to do just this one task that python's or javascript's dictionaries have for string
14:34:04 <piezoid> hi
14:34:08 <Cale> hi
14:34:10 <piezoid> are there any attempt at using lens for database interaction ?
14:34:14 <chrisdone> maybe there's a performant c library whose whole job is to provide a dictionary on strings
14:34:54 <piezoid> it could be a good idea to traverse data with schemas (?)
14:36:14 <Cale> piezoid: That seems plausible, but I don't know of anything like it yet myself.
14:37:59 <lemao> I have a Haskell library package that exports some C functions using FFI. Is it possible to have a test Main.cpp that is built by cabal (call gcc, add the FFI includes, etc)?
14:40:06 <Cale> lemao: Probably with a custom Setup.hs, but I don't know how to do it myself off-hand.
14:40:50 <lemao> Cale: how do people usually go about doing this? Makefile?
14:41:21 <mangaba_leitosa> Cale: trying Hashmap now... It doesn't have 'alter', which for Map works faster than 'insertWith'. Changing alter back to insertWith makes the 'Map' version slower (16 sec. vs. 13). Let's see if Hashmap can compensate for this change...
14:41:23 <bz> is it possible to compile cabal-installs remotely?
14:41:36 <Cale> I don't really know, I haven't ever built anything myself which integrated Haskell to C++ code.
14:41:45 <piezoid> Cale: ok, maybe I'll try to cobble something, when I have a better understanding of lenses package...
14:42:21 <mangaba_leitosa> Cale: why! 7 seconds
14:42:26 <mangaba_leitosa> Cale: "wow" even!
14:42:34 <mangaba_leitosa> Cale: almost as good as hashtables (5 seconds)
14:42:54 <Cale> mangaba_leitosa: cool
14:43:08 <mangaba_leitosa> Cale: thanks for the idea :-)
14:43:36 <mangaba_leitosa> Cale: I suppose that if I implement 'alter', like for Map, it will be even faster
14:43:39 <Cale> I wonder why it doesn't have alter
14:43:39 <Cale> yeah
14:44:41 <Cale> I wonder if tibell_ is around ;)
14:44:55 <fizruk> alter = insertWith?
14:45:24 <mangaba_leitosa> fizruk: no, these are different functions of Data.Map
14:45:39 <Cale> fizruk: alter can insert or delete items
14:45:45 <Cale> alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
14:46:04 <fizruk> i think lens does that
14:46:11 <fizruk> with at
14:46:14 <fizruk> :t at
14:46:16 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
14:46:48 <simpson> > M.fromList [(1,2),(3,4)] & at 3 .~ Nothing & at 5 ?~ 6
14:46:51 <lambdabot>   fromList [(1,2),(5,6)]
14:47:13 <Cale> fizruk: The problem isn't implementing it at all, but implementing it at a primitive level so that it's as fast as it could be for the HashMap structure.
14:48:12 <fizruk> Cale, oh, I seem to be out of context then, sorry :)
14:52:54 <Cale> http://hackage.haskell.org/package/unordered-containers-0.2.3.3/docs/src/Data-HashMap-Strict.html#adjust -- I wonder why 'go' here has h and k parameters. They don't appear to change in recursive applications, so it would seem reasonable to just make it refer to h0 and k0.
14:53:21 <Cale> But I'd expect this code to be fairly finely-tuned, so it's possible that I'm missing something.
14:54:28 <acowley> Cale: that is weird
14:54:38 <Rc43> Hi, guys.
14:54:38 <Cale> A similar remark applies to insertWith
14:54:46 <Rc43> I am trying to use console hoogle.
14:55:37 <acowley> The use of bangs is also interesting
14:55:47 <Rc43> But all waht it outputs is "Searching in .... Either the package is not exist or has not been generated. Found 4276 databases, including: ....".
14:55:47 <fizruk> Cale, perhaps something to do with !_ !_ !_ ?
14:55:58 <mangaba_leitosa> Cale: yes, I just looked at these two functions as well and have no idea why one is faster than the other :-)
14:55:58 <Cale> fizruk: Well, that'll matter the first time
14:56:00 <Rc43> I have done "hoogle data all" before it.
14:56:15 <acowley> iiuc, the first case of go will force h0 and k0 and s, but you could just bang h0 and k0
14:56:22 <Cale> yeah
14:56:37 <acowley> now I'm really curious
14:56:48 <acowley> because if this is intentional, it's an optimization I certainly don't know about
14:57:19 <Cale> It'd really be interesting if removing the parameters improved performance :)
14:57:55 <Cale> In insertWith, there are three seemingly-useless parameters to go
14:58:25 <acowley> Does the benchmark suite output expose these two functions explicitly?
15:01:28 <cable729> Hey guys, is it possible for a file like csce322a2p1 to export a module "Part1" and then pick that up in my cabal file? I've got strict requirements for a school assignment
15:02:28 <Cale> cable729: I believe GHC will complain if your source filenames don't end in ".hs" or ".lhs"
15:02:29 <dcoutts_> cable729: no, but you can call your Main module and file name
15:02:41 <cable729> cale, It does end in .hs
15:03:00 <dcoutts_> cable729: e.g. you can have a Part1.hs and then a Main module called csce322a2p1.hs
15:03:51 <cable729> dcoutts_: He has it set up so he has a main method in each file, which kind of makes it hard to test. (but I guess that's how his script accepts the files)
15:04:18 <cable729> dcoutts_: what is a main module?
15:04:45 <Cale> cable729: Main.main is what gets executed in a compiled program
15:05:03 <acowley> Cale: from what I can see, adjust and insertWith aren't really covered by the benchmark suite
15:05:09 <Cale> cable729: If you don't have an explicit module declaration, your module is called Main
15:05:20 <Cale> acowley: Yeah, I sort of noticed that too
15:05:42 <Cale> acowley: I was trying to see whether any of these other tests indirectly covered those, but I got distracted.
15:07:47 <acowley> Cale: fromListWith calls insertWIth
15:08:36 <chrisdone> monochrom
15:08:37 <Cale> Does it? I see it calling unsafeInsertWith
15:09:01 * hackagebot http-server 1.0.3 - A library for writing Haskell web servers.  http://hackage.haskell.org/package/http-server-1.0.3 (IavorDiatchki)
15:09:17 <acowley> Cale: Maybe different versions? I'm looking at the 0.2.3.3 from hackage
15:09:28 <acowley> fromListWith_insert calls HM.insertWith
15:09:44 <Cale> Strict or Lazy?
15:10:07 <acowley> incidentally, I always found ghc-pkg check borderline useless because of missing haddocks, and I'm bummed to see this still in sandbox hc-pkg check
15:10:20 <Cale> oh, it's in .Base anyway
15:10:24 <acowley> Cale: I just looked at Benchmarks.hs
15:10:26 <Cale> fromListWith :: (Eq k, Hashable k) => (v -> v -> v) -> [(k, v)] -> HashMap k v
15:10:26 <Cale> fromListWith f = L.foldl' (\ m (k, v) -> unsafeInsertWith f k v m) empty
15:10:31 <Cale> oh
15:10:40 <acowley> Because if we want to try those changes
15:10:48 <acowley> it would be nice to measure the performance difference
15:10:50 <Cale> I see what you mean
15:11:07 <acowley> but adjust isn't covered, so one would have to add a new group
15:11:26 <acowley> Benchmark.hs tests the Strict variant, btw
15:14:45 <mangaba_leitosa> Cale: I replaced insertWith with 'times l = Map.toList . Map.fromListWith (+) . flip zip (repeat (1::Int)) $ l' and this was 1.5 sec faster, now it is 6 sec. HashMap vs. 5 sec Hashtable :-)
15:16:52 <chrisdone> mangaba_leitosa: can you rephrase that? what's faster than what?
15:18:00 <mangaba_leitosa> fchrisdone: 'times l = Map.toList . Map.fromListWith (+) . flip zip (repeat (1::Int)) $ l' is faster than 'times l = Map.toList . addTimesMap (1::Int) Map.empty $ l where update_freq freq_delta map elem = Map.alter (Just . (+ freq_delta) . fromMaybe (0::Int)) elem map'
15:18:33 <mangaba_leitosa> chrisdone: ... and 'where addTimesMap freq_delta map l = foldl' (update_freq freq_delta) map l'
15:18:54 <chrisdone> mangaba_leitosa: http://i.imgur.com/o7x1oEZ.gif
15:19:05 <mangaba_leitosa> chrisdone: :-)
15:20:36 <mangaba_leitosa> chrisdone: whatever, immutable HashMap is almost as fast as mutable Hashtable :-)
15:20:50 <chrisdone> pretty swish
15:21:32 <Cale> mangaba_leitosa: We'll have to try it again if the changes acowley and I noticed actually manage to be improvements.
15:21:45 <Cale> mangaba_leitosa: In fact, you could perhaps try that yourself as a benchmark
15:22:02 <Cale> (removing the seemingly unnecessary parameters to go)
15:22:49 <mangaba_leitosa> Cale: the code of those functions scares me :-) but maybe I'll try :-)
15:23:52 <monochrom> chrisdone: yes?
15:24:06 <mangaba_leitosa> Cale: so, for Map, I have this: alter is the fastest. fromListWith goes next. insertWith is the slowest
15:24:25 <Cale> mangaba_leitosa: Ah, the reason fromListWith is better is that it uses in-place updates
15:24:37 <mangaba_leitosa> Cale: but alter is even better :-)
15:24:51 <Cale> (in the case of HashMap)
15:25:06 <chrisdone> monochrom: i got sidetracked by work, but just recorded this, just me randomly fiddling with your code http://chrisdone.com/shm-gtk.ogv
15:25:08 <Cale> http://hackage.haskell.org/package/unordered-containers-0.2.3.3/docs/src/Data-HashMap-Base.html#unsafeInsertWith -- it uses this unsafe version of insertWith internally
15:25:53 <chrisdone> monochrom: on the right hand side is the keys i press (i'm using god-mode so just imagine that when i press s, it's as if i pressed C-s), they should resemble paredit-mode
15:25:55 <mangaba_leitosa> Cale: aha... I just checked Data.Map. fromListWithKey does 'fold insertWithKey'
15:25:56 <acowley> I can't run the benchmark as my sandboxed build somehow breaks
15:26:05 <Cale> mangaba_leitosa: But if you search for 'go' there, you'll note that all the recursive occurrences apply go to the same h, k and x
15:26:10 <acowley> cabal tells me the sandboxed aeson is broken
15:26:11 <mangaba_leitosa> Cale: so it seems that Hashmap's fromListWith is faster
15:26:25 <mangaba_leitosa> Cale: yes, I saw that
15:26:41 <chrisdone> adnap: fwiw http://chrisdone.com/shm-gtk.ogv i don't remember the other dude's nickname but it was hours ago anyway
15:27:21 <Cale> mangaba_leitosa: So it *should* work to mindlessly remove those parameters from go and replace remaining occurrences of h, k, and x with h0, k0 and v0
15:27:42 <mangaba_leitosa> Cale: ok, I'll try that :-)
15:27:49 <mangaba_leitosa> Cale: don't expect any difference, though
15:28:16 <mangaba_leitosa> Cale: maybe unused parameter is optimized and not passed anyway :-)
15:28:21 <Cale> Maybe
15:29:03 <Cale> I've been surprised in the past by the optimisations that didn't happen though :)
15:29:51 <mangaba_leitosa> :-)
15:31:12 <monochrom> chrisdone: the part about "x y `orElse` a b" -> "orElse (x y) (a b)" got me thinking. you're still fixing up the parentheses manually :)
15:32:18 <monochrom> the other dude's name is jrmithdobbs
15:32:48 <chrisdone> monochrom: what would you expect to be happening there?
15:33:22 <monochrom> when you re-insert "x y", it automatically becomes "(x y)"
15:33:45 <monochrom> something something. I should not be so sure.
15:34:27 <chrisdone> monochrom: i think rather i did the wrong operation, i should've killed the (foo bar) instead of the foo bar and then i would've have had to re-create them
15:34:46 <chrisdone> monochrom: but yeah, you're right, that's a thing that i could do, too
15:36:04 <chrisdone> monochrom: i have the information to know "this is an App, so when inserting in another App, insert parens"
15:36:29 <mafovich> I think I got my code to compile but GHCi closes before I can read the error, how do I fix?
15:36:30 <acowley> Ugh, the unordered-containers package doesn't include everything you need to actually run the benchmarks
15:36:43 <monochrom> ok good
15:36:46 <acowley> this is too much of a hairball
15:37:22 <monochrom> don't let GHCi close :)
15:37:33 <mafovich> well how? it closes by itself
15:37:50 <monochrom> I don't know. it never closes on me. I can't reproduce the problem.
15:38:05 <Cale> mafovich: Are you on Windows?
15:38:07 <acowley> mafovich: windows?
15:38:13 <Cale> mafovich: Run ghci from the commandline
15:38:17 <mafovich> ok
15:38:39 <monochrom> I don't think even WinGHCi closed on me when I used it.
15:39:11 <Cale> monochrom: OpenGL programs do tend to take ghci with them when they quit for some reason
15:39:11 <monochrom> I can't get it to close. any help?
15:39:30 <monochrom> err ok, but OpenGL is too hard for me
15:39:40 <gsnedders> The wiki refers to http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/, yet "foo foo" =~ "foo" :: [String] finds no instance for [String]. Is there any documentation for =~ anywhere, such as what type instances there are?
15:40:01 <chrisdone> monochrom: did you get a haskell book yet?
15:40:28 <chrisdone> gsnedders: yeah ignore that blog post it was out of date before man grew opposable thumbs
15:40:28 <gsnedders> Essentially, I have a string and a regexp and want to find all matches in that string.
15:40:44 <monochrom> I have two already. http://www.vex.net/~trebla/weblog/fpbooks.xhtml
15:41:11 <acowley> Yes, we all used dialing wands clasped between our paws to type in our haskell programs
15:41:38 <chrisdone> acowley: :p
15:41:42 <acowley> I read monochrom's last statement in response to chrisdone
15:42:09 <chrisdone> gsnedders: as far as i remember that never worked and i end up using a specific regex library
15:42:24 <monochrom> hehe, I am an old geezer anyway
15:42:50 <monochrom> I started using a fountain pen before humans grew fingers
15:42:52 <acowley> The regex libraries in Haskell are amazingly hard to figure out
15:43:03 <chrisdone> monochrom: man i love fountain pens
15:43:12 <chrisdone> acowley: and not worth it either
15:43:54 <gsnedders> I swear, this has to be the worse assessment I've ever seen in any university course. A totally underdefined specification, skeleton code where it's totally unclear what is actually finished, and hints about using badly documented libraries.
15:43:56 <mafovich> can I delete / uninstall haskell? I want to change to old packages
15:43:57 <acowley> chrisdone: but is that because they're so hard to use or because regexps are so limited?
15:44:05 <chrisdone> gsnedders: here's a regex match with pcre-light https://github.com/chrisdone/ircbrowse/blob/master/src/Sphinx.hs#L72
15:44:46 <chrisdone> gsnedders: yeah, that sounds annoying. if you want a trivial regex library, there's …
15:44:56 <chrisdone> http://hackage.haskell.org/package/regex-compat-0.95.1/docs/Text-Regex.html
15:45:17 <chrisdone> returns Maybe [String]. that should be enough for your assignment
15:45:31 <monochrom> gsnedders: perhaps it is designed to simulate typical python projects
15:45:32 <gsnedders> Combined with maybe, that should do.
15:45:55 <monochrom> or make it php projects if you insist "python is not like that"
15:46:18 <mafovich> any way to reset packages to normal? they seem to be giving me problems
15:46:30 <chrisdone> acowley: i think after parsec the places i used to use regexes are few and far between. there's one of them ^ but that's just me. it makes it not worth learning that ~= operator and its various arcane instances
15:46:31 <prooftechnique> mafovich: "Normal"?
15:46:36 <monochrom> (my understanding of the python culture, though, is that the doc can be incomplete because you are supposed to read internal code)
15:46:55 <mafovich> prooftechnique: sorry about that, I mean to those when I installed haskell for first time
15:46:56 <prooftechnique> Try ghc-pkg recache, ghc-pkg check, and if all else fails then nuke your .ghc and .cabal directories
15:47:09 <chrisdone> monochrom: hackage is full of that, too
15:47:16 <acowley> chrisdone: Yeah, I agree it's not worth it, but I think it's a bit shameful that most of that is due to how hard it is to use ~=
15:47:21 <gsnedders> monochrom: It's more how vague everything is, and pointing us to packages which have no documentation with no further clues. At least in all the other courses where languages have been taught we've actually, well, been taught what we need to know.
15:47:22 <chrisdone> monochrom: "what, this vague name and the type aren't enough? read the source, loser!"
15:47:40 <chrisdone> acowley: do you use it?
15:47:47 <acowley> chrisdone: No
15:48:01 <chrisdone> same reasons?
15:48:02 <acowley> chrisdone: But in Python or Ruby I will use regexp more because it's so convenient
15:48:05 <acowley> chrisdone: Yeah
15:48:09 <chrisdone> aha
15:48:18 <chrisdone> yeah, in javascript i use regexes
15:48:30 <prooftechnique> mafovich: Oh, well, unless you cabal installed packages with --global, you should be okay just nuking .ghc and .cabal in your home directory
15:48:54 <acowley> chrisdone: I'm as big an advocate of parser combinators as anyone, but I wish we had a better, "Sure, you could use a regexp for that, but look what we can do!" instead of having to start people off by discouraging them from even trying regexp
15:49:07 * hackagebot presburger 1.0 - A decision procedure for quantifier-free linear arithmetic.  http://hackage.haskell.org/package/presburger-1.0 (IavorDiatchki)
15:49:13 <acowley> !
15:49:18 <chrisdone> acowley: agree
15:49:18 <acowley> presburger in the type system
15:49:26 <acowley> *fingers crossed*
15:49:35 <monochrom> no way. not in the type system.
15:49:45 <chrisdone> acowley: i'd call this a case of overengineering, i think
15:50:07 <acowley> chrisdone: Yeah, it is. And I think it's an interesting case because you can see the appeal in how it was put together
15:50:13 <acowley> or at least, some of the appeal
15:50:14 <koala_man> gsnedders: one of my uni courses once had a networking library whose bugs included not being able to connect to remote hosts and not working for certain cpu clock speeds
15:50:23 <chrisdone> acowley: regex matching is not a big deal, the whole 'you can swap in any back end you want and keep the same API' is sooo inappropriate
15:50:24 <monochrom> I use a few regexs in my own haskell program. it processes log files.
15:50:35 <acowley> It's a great example of the design perils of overloading
15:50:41 <chrisdone> indeed
15:50:51 <acowley> I used to use regexs more often, but I just haven't happened to in quite a while
15:50:59 <gsnedders> acowley: It's rather tempting to just use a parser combinator for this, even though it seems overkill for something that is genuinely regular.
15:51:11 <chrisdone> you just import Text.Regex and then import a "backend". that's the dream
15:51:36 <gsnedders> chrisdone: And inappropriate how, because every backend supports a different regex language, practically?
15:51:38 <acowley> monochrom: why can't we have presburger in the type checker?
15:51:43 <prooftechnique> gsnedders: What's the class?
15:51:47 <monochrom> of course, it's a straightforward regex, not one of those very clever ones. if the regex needs to be clever, then it should be a parser combinator thing instead, which is less clever.
15:52:30 <acowley> gsnedders: In Haskell, regexps are the overkill solution :/
15:52:58 <monochrom> "I can haz prezburger"
15:53:17 <simpson> I had thought that Presburger in the type system was coming Real Soon Now.
15:53:20 <chrisdone> gsnedders: inappropriate because regex isn't a problem that needs overloading. every other language is doing *fine* with just one regex implementation. if i want to use my special regex implementation, i'll use it, but do i need all this Text.Regex abstraction to do that conveniently?
15:53:22 <acowley> 🍔 in the type system!
15:53:37 <gsnedders> prooftechnique: Essentially just a introduction to functional programming. Final year undergrad. The assessed exercise is some bizarre extract OpenCL-from-FORTAN95-compiler-thing.
15:53:41 <smiller_> Given a pipes producer of a bytestring (Producer' ByteString IO ()), how can I simply consume all of the producer's input and return that data?
15:53:42 <monochrom> (when Presburger worked on linear arithmetic, he didn't know one day we would have the lolcat cheeseburger meme)
15:53:53 <prooftechnique> acowley: I keep having this urge to use emoji in my source files
15:54:09 <gsnedders> chrisdone: Hey, I've hit problems with wanting a non-backtracking implementation elsewhere before! :P
15:54:10 <acowley> I keep having the urge to use animaged gifs in source files :(
15:54:14 <prooftechnique> gsnedders: That doesn't sound fun, at all.
15:54:36 <gsnedders> prooftechnique: It would be *okay* if it was actually really defined what the hell the thing is meant to do.
15:54:46 <acowley> gsnedders: If you start working on an OpenCL EDSL in Haskell, I'd be interested in collaborating so I can include it in CLUtil
15:55:02 <prooftechnique> gsnedders: Do you have a problem statement or something?
15:55:04 <gsnedders> acowley: I have no real interest in any such things, tbh. :)
15:55:05 <prooftechnique> Maybe we can give pointers
15:55:21 <smiller_> Ah, runEffect seems promising.
15:55:28 <gsnedders> prooftechnique: At a high level, it's fine. I'm not really scared of Haskell or compilers.
15:55:35 <chrisdone> it reminds me a little bit of the string libraries that attempt to unify all string types into one big-ass type class
15:55:49 <chrisdone> except in doing so you realise the different string types are kinda different
15:55:50 <prooftechnique> gsnedders: Yeah, this just sounds annoying and low-level :D
15:56:15 <benzrf> how do i use arrays
15:56:21 <chrisdone> how do i shot web?
15:56:25 <benzrf> :p
15:56:31 <benzrf> just for storing 2d grids
15:56:33 <chrisdone> what kinda array do you want?
15:56:38 <benzrf> immutable, probably
15:56:38 <chrisdone> ah, then probably Data.Array
15:56:41 <gsnedders> prooftechnique: Like, sure, I hit problems with my Haskell (which has remained not-very-good for a number of years, and doesn't seem to have been improved by the course whatsoever), but typically when trying to do something specific, which is at least easy to ask about.
15:56:45 <benzrf> how do i use it though
15:56:50 <benzrf> what's the lookup func & creation
15:57:13 <Cale> chrisdone: The abstraction over the backend isn't the thing which bothers me about Text.Regex
15:57:16 <gsnedders> prooftechnique: https://www.dropbox.com/s/jl07faqujvqjd10/CW1-desc.pdf if you're curious though
15:57:24 <acowley> benzrf: http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.4.0.1/Data-Array-IArray.html
15:57:28 <chrisdone> Cale: what bothers you?
15:57:31 <Cale> chrisdone: It's all the silly overloading of the results of the matching operators which bugs me
15:57:40 <monochrom> Data.Array, array, listArray, !
15:57:42 <Cale> When you could just define sensible functions of appropriate types
15:57:48 <acowley> Cale: I can't get the unordered-containers benchmarks to build, so I'm giving up
15:57:50 <benzrf> ok thanks
15:57:55 <chrisdone> Cale: agreed there
15:58:08 <acowley> Yeah, the overloading of =~ is what kills me, too
15:58:10 <chrisdone> :t listArray
15:58:11 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
15:58:13 <Cale> acowley: all right, well, maybe mangaba_leitosa can get some result
15:58:30 <benzrf> what is the (i,i)
15:58:36 <benzrf> dimensions ?
15:58:40 <Cale> acowley: and I'll try to keep it in mind to mention it to tibbe next time he's around
15:58:42 <monochrom> smallest index. largest index
15:58:45 <benzrf> ah
15:59:02 <hpc> benzrf: you can have a 1-indexed array, for instance
15:59:03 <chrisdone> :t listArray ((0,0),(10,10))
15:59:04 <acowley> Cale: at this point, I'm guessing it's an oversight
15:59:04 <lambdabot> (Num t, Num t1, Ix t, Ix t1) => [e] -> Array (t, t1) e
15:59:12 <hpc> or a 2d array from (3, 6) to (7, 8)
15:59:26 <benzrf> ooh, thats neat
15:59:30 <prooftechnique> "The mark you get is based solely on the number of unit tests passed" :(
15:59:34 <prooftechnique> No partial credit?
15:59:40 <acowley> Cale: the absence of adjust from the benchmarks is conspicuous, and the availability of the unsafeFromList variant takes pressure off of insertWith
15:59:51 <TallerGhostWalt> is there a way to look at the read instance of a Type
16:00:00 <monochrom> that is partial credit, isn't it? it is not like you will pass all tests.
16:00:10 <chrisdone> > listArray ((0,0),(10,10)) [0..100] Data.Array.! (5,5)
16:00:11 <lambdabot>   60
16:00:15 <hpc> benzrf: tuple indices are a bit frustrating to deal with
16:00:22 <monochrom> or rather, it is not like you have to pass all tests.
16:00:24 <hpc> just a caveat
16:00:33 <benzrf> & a td array?
16:00:36 <benzrf> *2d
16:00:39 <benzrf> just map over ?
16:00:59 <TallerGhostWalt> I need to slightly alter a Read on an existing type but really don't want to change it drastically
16:01:02 <chrisdone> benzrf: what?
16:01:10 <prooftechnique> gsnedders: Also, I like that one of his examples runs off the page. Helpful. :D
16:01:11 <benzrf> chrisdone: nvm
16:01:12 <monochrom> if you know the tests used, you can totally target just one of them and forget the rest. that will give you 1/n marks. that's partial credit for you, and it's so easy to get.
16:01:16 <nisstyre> TallerGhostWalt: use parsec
16:01:23 <gsnedders> Is there any simple way, short of a parser combinator, to get from a string "xxx START xxx END xxx START xxx END xxx" a [String] of /START.*?END/ matches? Because a parser combinator seems like it's gonna be way more code than needed.
16:01:49 <gsnedders> prooftechnique: Hey, this is the revised version, with added correctness!
16:01:57 <monochrom> yes, I would use a regex for that
16:02:10 <geekosaur> the right parer combinator shouldn't be too bad though
16:02:25 <TallerGhostWalt> yeah I will but I was hoping there might be some code to get me started available from the default instance of Read
16:02:27 <jrmithdobbs> monochrom: other dude what
16:02:44 <monochrom> the other dude interested in chrisdone's editor adventures
16:03:04 <monochrom> http://chrisdone.com/shm-gtk.ogv
16:03:09 <acowley> gsnedders: Doesn't parsec's between give you that?
16:03:42 <prooftechnique> monochrom: I mean in the sense that maybe they'll inspect your code and go "Well, you were almost there, have some points." Maybe I'm just used to math
16:03:51 <gsnedders> acowley: I dunno. I'm pretty terrible at writing stuff with parsec.
16:04:03 <chrisdone> Prelude Text.Regex> matchRegex (mkRegex "(.+) HELLO, (.+)") "Oh, HELLO, Dave!"
16:04:04 <chrisdone> Just ["Oh,","Dave!"]
16:04:10 <gsnedders> acowley: Which might lead to my perseption of it being hard than I thought :)
16:04:30 <zardoz``> hello. is there a nicer way of doing this?   do { x <- actOne; actTwo; return x }
16:04:43 <chrisdone> gsnedders: are you matching on a string or a bytestring?
16:04:44 <fizruk> actOne <* actTwo
16:04:49 <monochrom> prooftechnique: ok, but that is more expensive. pay more money for that. pay me.
16:04:52 <fizruk> :t (<*)
16:04:53 <gsnedders> chrisdone: String
16:04:54 <lambdabot> Applicative f => f a -> f b -> f a
16:05:03 <prooftechnique> monochrom: I pay enough money as it is!
16:05:14 <monochrom> ah, I don't know what is "enough"
16:05:16 <fizruk> zardoz``, if you have an Applicative ^
16:05:17 <gsnedders> chrisdone: Actually [String], with one line per String. For some reason I don't get at all.
16:05:35 <fizruk> > Just 3 <* Just 4
16:05:35 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #8
16:05:37 <lambdabot>   Just 3
16:05:40 <chrisdone> gsnedders: one line per string? huh?
16:05:49 <gsnedders> chrisdone: A list of single line strings.
16:05:54 <zardoz``> fizruk it is IO, which is applicative, but I am not sure if that would work?
16:06:05 <fizruk> zardoz``, why not? :)
16:06:07 <gsnedders> chrisdone: i.e., lines s
16:06:31 <zardoz``> fizruk I was under the impression that Applicatives can't replicate >> and >>=
16:06:49 <gsnedders> chrisdone: I wish I knew why it passed around a [String] instead of just the raw String.
16:07:12 <nisstyre> zardoz``: how do you think the instance was defined?
16:07:26 <hpc> zardoz``: it can do (>>) but not (>>=)
16:07:29 <hpc> @src (*>)
16:07:30 <lambdabot> (*>) = liftA2 (const id)
16:07:44 <zardoz``> well I am doing >>= am I not? when assigning actOne to x
16:08:15 <monochrom> prooftechnique: in my opinion actually, grading programs should be exactly unlike grading math homework. customers are not going to look at your code and say "close enough". customers are going to, though, try 10 things and conclude "9 of them work, close enough"
16:08:24 <fizruk> zardoz``, well, Applicative can be a Monad too, so you can use both <* and >>=
16:08:31 <prooftechnique> monochrom: That's fair
16:08:57 <hpc> it's like squares and rectangles
16:08:58 <fizruk> zardoz``, so you can write (getLine <* print "hi") >>= print
16:09:03 <ion> zardoz: The value of x does not affect the control flow, your code is translateable to Applicative code.
16:09:06 <hpc> Applicative is rectangle, Monad is square
16:09:12 <hpc> er, other way around
16:09:12 <ion> the monadic control flow
16:09:21 <hpc> all Monads are Applicative, not all Applicatives are Monad
16:10:36 <derekv> So, I think I could define a function ( disregarding types for a second) as a value giving a computational description which associates any input value with exactly one output value... am I in the ballpark?
16:10:57 <monoidal> hpc: it's not "other way round" regarding rectangles/squares, unless I misunderstood you. Applicative = rectangle, Monad = square
16:11:11 <derekv> But I was wondering, how do I define a value even?
16:11:23 <zardoz``> so I can do this because actTwo is not using x? if it did, I would have to use >>= ?
16:11:27 <chrisdone> :t even
16:11:28 <lambdabot> Integral a => a -> Bool
16:11:36 <hpc> monoidal: one of my guesses was right and that's what counts ;)
16:11:37 <fizruk> zardoz``, yes
16:11:43 <zardoz``> cool. thanks!
16:12:12 <ion> I was recently thinking about transforming mostly-monadic code to mostly-applicative code. Following these steps all monadic operations would vanish from do { x <- actOne; actTwo; return x }. https://gist.github.com/ion1/7016798
16:12:47 <chrisdone> monochrom: hmm, customers aren't the main factor. i'd say there are two main factors, customers and fellow developers, you're catering to both of them
16:12:52 <monochrom> prooftechnique: on grading proofs, I have a radical idea. submit proofs in a computer language. if the computer checker says no, 0 marks. if the computer checker says yes, the mark is high iff the proof is short.
16:12:55 <ion> It would be transformed to (\x -> \_ -> id x) <$> actOne <*> actTwo
16:13:20 <monoidal> ion: btw there's a proposal to make do-notation apply to applicatives in some cases in 7.10
16:13:37 <ion> monoidal: Yeah, there’s a link to that in the gist.
16:13:42 <monochrom> students have easy access to the checker and its doc. they can keep trying before submitting.
16:13:51 <monoidal> oh, sorry
16:13:52 <ion> monoidal: These steps would apply to any code using >>=/pure/return.
16:14:15 <prooftechnique> monochrom: It will certainly increase the quality of assignments. Though depending on the checker, I suppose you could construct an absurdity and conclude whatever you like from there.
16:14:34 <jrmithdobbs> ion: that's a nice little document but that's covered in rwh or whatever the acronym is
16:14:50 <jrmithdobbs> ion: nice summary though
16:14:52 <monochrom> oh, heh, but that is an easier problem than "what if GHC has a bug" :)
16:15:03 <prooftechnique> Cf. any typechecker with a "trust me" notation :D
16:15:12 <prooftechnique> *proof checker
16:15:48 <chrisdone> monochrom: i've been mulling over a teaching system for some time that asks you questions in order to teach you. it tells you a fact, like fix :: (a  -> a) -> a, and then immediately asks you a question, like 'what is fix (\() -> ()) ()?' and builds up from there. if it can be done as ideally as i'd like, the system would never ask you anything it hasn't told you before. i'd want it to be like a book that grows in length, but one that
16:15:49 <chrisdone> interacts with you, like socrates in your face
16:16:03 <jrmithdobbs> ion: oh, i missed the "could be implemented in the compiler" part
16:16:27 <zardoz``> would ideally >>  be a functor? if there applicatives existed before monads were implemented
16:16:44 <zardoz``> sorry, would it accept/return an Applicative, not a functor
16:16:48 <ion> zardoz``: It would have an Applicative constraint instead of Monad.
16:17:05 <zardoz``> yeah
16:17:06 <chrisdone> prooftechnique: monochrom: i've seen such grading things in use that will reject plainly bad programs like, ones that don't compile, that don't output the righht solution. so you can't even be graded if some obviously testable things don't add up
16:17:56 <gsnedders> Things I like having to do, part ten: parse a string "which looks like this, work out the grammar yourself, I'm not going to give any weird edge-cases to test your parser"
16:18:07 <fizruk> zardoz``, we have *> for that
16:18:18 <fizruk> :t (*>)
16:18:19 <lambdabot> Applicative f => f a -> f b -> f b
16:18:26 <chrisdone> gsnedders: well, that's a good assignment. it's just like reading a real spec
16:18:37 <zardoz``> fizruk I know, but  >> seems redundant with it, so we could just have one
16:18:38 <prooftechnique> chrisdone: Needs more Excel spreadsheets
16:18:49 <zardoz``> if Monads were required to implement Applicative
16:18:53 <gsnedders> chrisdone: Every parser I've really implemented had a decent spec, except for one.
16:18:53 <chrisdone> prooftechnique: or loeb!
16:19:01 <ion> p :: Parser String; p = string "which looks like this, work out the grammar yourself, I'm not goin to give any weird edge-cases to test your parser"
16:19:20 <prooftechnique> gsnedders: At least it's not an XML parser!
16:19:42 <chrisdone> if you're parsing xml i can recommend a good regex library
16:19:47 <gsnedders> prooftechnique: The only one without a decent spec I've implemented: XML's EBNF syntax.
16:20:02 * chrisdone sings along to https://www.youtube.com/watch?v=sTSA_sWGM44
16:20:10 <gsnedders> prooftechnique: It /has/ a spec. None of the XML specs *actually use the language that describes*.
16:20:14 <prooftechnique> chrisdone: oh you
16:20:37 <prooftechnique> gsnedders: Yeah, I'm getting that. I'm actually writing an attoparsec parser for XML at this very moment
16:21:02 <chrisdone> prooftechnique: WHY
16:21:07 <chrisdone> ლ(ಠ益ಠლ)
16:21:08 <prooftechnique> chrisdone: It is a long story
16:21:21 <chrisdone> idemandanexplanationforthis.jpg
16:21:24 <jrmithdobbs> xml doesn't need a parser it needs a purger
16:21:28 <cable729> If I want to deserialize "(32,"hi",["hello","world"])" into (Int,[Char],[[Char]]) how would I do that (I'm trying to figure out the read function syntax)?
16:21:35 <jrmithdobbs> of the high speed lead variety to whoever gave you xml data in the first place
16:21:41 <chrisdone> holy lambda the questions are coming in fast tonight aren't they?
16:21:43 <gsnedders> prooftechnique: I've never found it too bad to actually understand. Just, for example, (A B) | (C D) is invalid according to the spec.
16:21:54 <monoidal> > read "(32,"hi",["hello","world"])"  :: (Int,[Char],[[Char]]) --cable729
16:21:56 <lambdabot>   Not in scope: `hi'
16:21:56 <lambdabot>  Perhaps you meant one of these:
16:21:56 <lambdabot>    `pi' (imported from ...
16:21:58 <gsnedders> prooftechnique: (LHS and RHS of | must be "simple expressions")
16:22:02 <geekosaur> heh
16:22:08 <monoidal> > read "(32,"hi\",[\"hello\",\"world\"])"  :: (Int,[Char],[[Char]]) --cable729
16:22:09 <chrisdone> cable729: read will read what you tell it via the type
16:22:10 <lambdabot>   <hint>:1:14: parse error on input `\'
16:22:12 <chrisdone> :t read
16:22:13 <lambdabot> Read a => String -> a
16:22:16 <chrisdone> :t read :: Int
16:22:17 <lambdabot>     Couldn't match expected type `Int' with actual type `String -> a0'
16:22:17 <lambdabot>     In the expression: read :: Int
16:22:21 <chrisdone> > read "3" :: Int
16:22:22 <lambdabot>   3
16:22:27 <geekosaur> you missed one
16:22:28 <chrisdone> > read "[3]" :: [Int]
16:22:29 <monoidal> cable729: ew. anyway, read x :: Type
16:22:29 <lambdabot>   [3]
16:22:40 <geekosaur> > read "(32,\"hi\",[\"hello\",\"world\"])"  :: (Int,[Char],[[Char]])
16:22:41 <lambdabot>   (32,"hi",["hello","world"])
16:23:10 <joejev> I am having an issue with memory, I am trying to evaluate something but my memory usage blows up to quickly, I tried forcing strictness with BangPatterns but that was no help, can someone tell me why it is holding onto values and not freeing them? http://lpaste.net/95727
16:23:16 <cable729> thanks guys, not sure what i had wrong before
16:23:18 <prooftechnique> chrisdone: Okay, so I want to make API bindings in Haskell for a game that I play. I'd like to use pipes while doing so. We have pipes-attoparsec, so cool. But, oh, wait, the API only spits out XML, and there's no pipes-xml, yet. Well, okay, I guess I could give that a shot, I'll just plug an attoparsec XML parser into pipes-attoparsec and we'll be good. Oh, wait, there's no attoparsec-xml.
16:23:21 <prooftechnique> chrisdone: So here I am
16:24:01 <prooftechnique> chrisdone: Tangentially, I'd like to have a parser built against xml-types rather than xml, so there's that
16:24:13 <gsnedders> prooftechnique: Are you implementing 1.0 4th edition, 1.0 5th edition, or 1.1? Are you implementing Namespaces for XML?
16:24:43 <chrisdone> prooftechnique: can't you just use an existing parser that supports chunking?
16:24:48 <jrmithdobbs> prooftechnique: who doesn't take an 'Accept: application/json' header in 2013?
16:24:50 <prooftechnique> gsnedders: I went to the XML spec page, and I'm doing whatever that is. 1.0, I think. Namespaces will be there, I think.
16:24:51 <gsnedders> prooftechnique: Are you susceptable to the billion laughs attack? Are you resolving entities? etc. etc. etc.
16:25:00 <chrisdone> like xml conduit :3
16:25:01 <gsnedders> prooftechnique: Namespaces for XML is a separate spec.
16:25:02 <prooftechnique> jrmithdobbs: I KNOW RIGHT?
16:25:04 <acowley> gsnedders: I put together a parsec parser for that example you had, btw
16:25:22 <prooftechnique> chrisdone: Now you get the joke. :/
16:25:26 <jrmithdobbs> prooftechnique: no that was a question, what game so I can mock them publically on twitter please
16:25:29 <jrmithdobbs> heh
16:25:36 <prooftechnique> But still, it's a neat set of libraries that I'll get to write :)
16:25:39 <cable729> Why can't I do this? let input = read (readFile file) :: Part1Input
16:25:39 <cable729> 	in trymove input
16:25:41 <chrisdone> prooftechnique: which joke?
16:26:00 <prooftechnique> The pipes vs conduit thing :D
16:26:07 <gsnedders> prooftechnique: And 1.0 5th edition allows a superset of documents 1.0 4th edition does — a WF 5th edition document may be a not WF 4th edition document. It's wonderful.
16:26:14 <prooftechnique> jrmithdobbs: It's EVE Online
16:26:16 <geekosaur> cable729, because readFile is in IO
16:26:20 <gsnedders> prooftechnique: Mostly people just ignore the existance of 5th edition, FWIW.
16:26:26 <jrmithdobbs> prooftechnique: oh, no point then, they know
16:26:33 <prooftechnique> gsnedders: I will probably just do that, then :D
16:26:36 <geekosaur> do input' <- readFile file; let input = read input'
16:26:38 <cable729> geekosaur: This means I have to do monad stuff? Like "do"?
16:26:57 <chrisdone> cable729: noooooo! not the do! (゜。゜)
16:26:58 <geekosaur> or, more idiomatically, do input <- fmap read $ readFile file
16:27:15 <geekosaur> (since you;re using let, I presume you're in a do already)
16:27:29 <prooftechnique> chrisdone: As a side note, maybe it'll actually a good and mostly complete parser that'll be general enough that people can use it elsewhere without pulling in all the conduit/pipes machinery.
16:27:31 <chrisdone> cable729: is there a reason you're using Read for storage? is this from a tutorial?
16:27:34 <gsnedders> prooftechnique: 5th edition has the advantage of being based on current Unicode general categories, not the lists of what was in them in Unicode 2.0, though. Which can make it a lot simpler to implement. :)
16:28:05 <cable729> @geekosaur no, i'm in a function. This is reading a test case to be compared with a "golden file". This is for a convoluted school assignment :)
16:28:05 <lambdabot> Unknown command, try @list
16:28:06 <prooftechnique> God, why does anyone still use XML :(
16:28:14 <gsnedders> prooftechnique: tl;dr: if you're just implementing a parser, it doesn't matter to much; if you're implementing a serializer, you really want to use 4th edition to be safe.
16:28:15 <cable729> sorry with the @ lambdabot
16:28:32 <hpc> yeah, irc isn't twitter
16:28:34 <chrisdone> prooftechnique: https://www.youtube.com/watch?v=KaqC5FnvAEc
16:28:36 <cable729> :P
16:28:37 <gsnedders> prooftechnique: It was all fine and well until the XML Core WG published 5th ed a couple of years back, it was so much simpler :(
16:28:40 <gsnedders> chrisdone: :P
16:28:51 <jrmithdobbs> prooftechnique: because that game's a huge java pile of trash on the backend and they had a bunch of free libs to spit out the xml
16:28:52 <prooftechnique> gsnedders: Fair enough. I don't particularly have to do anything with the XML, I just need to read it, so I think a parser will be sufficient
16:29:00 <jrmithdobbs> prooftechnique: oh wait, you were being facetious ;p
16:29:26 <benzrf> hm
16:29:35 <prooftechnique> jrmithdobbs: Agreed, EVE is terrible
16:29:45 <prooftechnique> I mainly just idle in IRC and skillqueue
16:30:07 <gsnedders> prooftechnique: ("simpler", not simple)
16:30:26 <gsnedders> Still, XML *was* a massive improvement over SGML.
16:30:48 <prooftechnique> Fair.
16:31:00 <chrisdone> you know what i like, xml discussions
16:31:07 <chrisdone> @vixen xml?
16:31:08 <lambdabot> A public man must never forget that he loses his usefulness when he as an individual, rather than his policy, becomes the issue.
16:31:11 <gsnedders> HEY GUYS, HTML5 IS THE FUTURE!
16:31:30 <jrmithdobbs> gsnedders: but by the time people were pushing xml in earnest (to the real world, anyways, dunno about you folk in academia) yaml already existed so why GOD WHY
16:31:56 * geekosaur moderately amused that @vixen edit corrects to @nixon
16:31:56 <gsnedders> jrmithdobbs: I've far more to do with the real world than academia, FWIW.
16:32:02 <prooftechnique> IT'S SO SEMANTIC
16:32:16 <jrmithdobbs> gsnedders: that was more for the rest of the channel not an accusation, heh
16:32:22 <benzrf> is it appropriate to implement a map-lookup function like
16:32:24 <benzrf> a 1 = 2
16:32:27 <benzrf> a 5 = 8
16:32:28 <benzrf> etc
16:32:30 <gsnedders> jrmithdobbs: Oh, right :)
16:32:36 <chrisdone> benzrf: lol
16:32:42 <benzrf> im srs
16:32:47 <chrisdone> omg r u series
16:33:15 <gsnedders> jrmithdobbs: I'm still not convinced YAML is actually that much better, but that's a whole different discussion. Just a different load of badness.
16:33:57 <jrmithdobbs> gsnedders: i think json is definitely better and since it's a subset of yaml yaml can be *used* in a way that's much better, noone really uses much of yaml that isn't in the json subset anyways
16:34:13 <jrmithdobbs> (when was the last time you saw a reference that wasn't just a pretty nicity for an environment config? exactly.)
16:34:35 <gsnedders> jrmithdobbs: Indeed, but if you're writing a parser you still have to deal with the badness. As with XML. You can come up with a sane subset of XML. It's just quite verbose.
16:34:51 <chrisdone> benzrf: no
16:35:04 <chrisdone> benzrf: in case you were serious
16:35:19 <chrisdone> > lookup 1 [(1,2),(5,8)]
16:35:21 <lambdabot>   Just 2
16:35:23 <benzrf> ah
16:35:28 * benzrf feels silly
16:35:40 <benzrf> :t lookup
16:35:41 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
16:35:54 <benzrf> :t a -> [(a, b)] -> b
16:35:55 <lambdabot> parse error on input `->'
16:35:56 <benzrf> oop
16:35:58 <gsnedders> acowley: Just using between, or something more complex?
16:35:59 <benzrf> @hoogle a -> [(a, b)] -> Maybe b
16:36:00 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:36:00 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:36:00 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
16:36:04 <benzrf> @hoogle a -> [(a, b)] -> b
16:36:04 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:36:04 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:36:04 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
16:36:10 <jrmithdobbs> gsnedders: well let's just all agree to use json already then! ;p
16:36:10 <benzrf> oh wait
16:36:12 <benzrf> :t unjust
16:36:13 <lambdabot>     Not in scope: `unjust'
16:36:13 <lambdabot>     Perhaps you meant one of these:
16:36:13 <lambdabot>       `IM.adjust' (imported from Data.IntMap),
16:36:15 <benzrf> :t unJust
16:36:16 <lambdabot>     Not in scope: `unJust'
16:36:16 <lambdabot>     Perhaps you meant one of these:
16:36:16 <lambdabot>       `_Just' (imported from Control.Lens),
16:36:22 <benzrf> i feel like that was a thing
16:36:22 <acowley> gsnedders: p = manyTill anyChar (try (string "START")) *> manyTill anyChar (try (string "END"))
16:36:23 <gsnedders> jrmithdobbs: BUT JSON ISN'T A SUBSET OF JS LIKE IT CLAIMS TO BE!
16:36:28 <geekosaur> :t fromJust
16:36:29 <lambdabot> Maybe a -> a
16:36:31 <benzrf> dur
16:36:34 <geekosaur> ...but don't
16:36:36 <gsnedders> acowley: Well, that's something to work out in the morning :)
16:36:40 <benzrf> geekosaur: why not?
16:36:57 <jrmithdobbs> gsnedders: who what
16:37:02 <jrmithdobbs> (i missed a joke there i take it?)
16:37:12 <geekosaur> if you don't know that you might be using it on Nothing, your code will crash. if you do know that, then your code is probably inefficient
16:37:23 <gsnedders> jrmithdobbs: JSON claims to be a subset of JavaScript. JSON allows U+2028 and U+2029, which JS disallows.
16:37:24 <geekosaur> (in general fromMaybe or maybe is the right solution)
16:37:50 <jrmithdobbs> gsnedders: i don't think it actually claims that though since it existed first?
16:38:10 <chrisdone> gsnedders: check mate atheists!
16:38:38 <gsnedders> jrmithdobbs: JSON? No, JSON is only from ~2001 or so, JS from 1994 (or whenever Netscape 2 shipped)
16:39:23 <chrisdone> 1995 iirc
16:39:28 <chrisdone> same date as java
16:39:32 <chrisdone> and ruby
16:39:39 <chrisdone> i think. a lot of horrors happened in 1995
16:39:46 <peddie> can anyone think of a one-liner to take every other byte from a ByteString?
16:39:50 <gsnedders> September 1995, yeah, apparently
16:40:23 <gsnedders> jrmithdobbs: It was meant to be a supserset of ES3 (published in 1999, and mostly already implemented by that point).
16:40:57 <jrmithdobbs> gsnedders: ya so it was, my bad
16:41:02 <chrisdone> :t map snd . filter ((==0).fst) . zip (cycle [0,1])
16:41:03 <lambdabot> [b] -> [b]
16:41:10 <jrmithdobbs> gsnedders: why does js disallow u+2028/9 anyways?
16:41:14 <chrisdone> > map snd . filter ((==0).fst) . zip (cycle [0,1]) $ "hello world!"
16:41:15 <lambdabot>   "hlowrd"
16:41:30 <peddie> ah, fair enough
16:41:34 <peddie> thanks chrisdone
16:41:39 <gsnedders> jrmithdobbs: Good question. I remember this being discussed on es-discuss not too long ago.
16:41:47 <chrisdone> oh, better one!
16:41:53 <peddie> might do it as a foldl instead now that I think of it
16:41:56 <derekv> where's a good channel to discuss which dbms is right for a certain app?
16:41:58 <chrisdone> > map snd . filter fst . zip (cycle [True,False]) $ "hello world!"
16:41:59 <lambdabot>   "hlowrd"
16:42:17 <jrmithdobbs> gsnedders: i mean if you're going to disallow 2028 and 2029 could you at least disallow reverse/etc too, let's protect users with our arbitrary decisions at least! ;p
16:42:32 <benzrf> zip (cycle [True,False]) $ "hello world!"
16:42:34 <benzrf> > zip (cycle [True,False]) $ "hello world!"
16:42:35 <lambdabot>   [(True,'h'),(False,'e'),(True,'l'),(False,'l'),(True,'o'),(False,' '),(True...
16:42:41 <benzrf> neat
16:43:02 * chrisdone watches benzrf learn with pride
16:43:15 <simpson> > let f [] = []; f (x:_:xs) = x:f xs in f "hello world!"
16:43:17 <lambdabot>   "hlowrd"
16:43:42 <benzrf> chrisdone: i know what it does
16:43:44 <chrisdone> oh, suave
16:43:48 <benzrf> but I was double checking
16:44:00 <chrisdone> benzrf: science!
16:44:02 <benzrf> ...
16:44:03 <benzrf> totally
16:44:14 * hackagebot labyrinth-server 0.1.2.0 - A complicated turn-based game - Web server  http://hackage.haskell.org/package/labyrinth-server-0.1.2.0 (AlexeyKotlyarov)
16:44:16 * hackagebot cereal-plus 0.1.0 - Extended serialization library on top of "cereal".  http://hackage.haskell.org/package/cereal-plus-0.1.0 (NikitaVolkov)
16:44:25 <cable729> I've still got a problem with my do syntax apparently. It's a 4 line quick function if someone could check it (errors included) http://lpaste.net/95731
16:44:36 <benzrf> cable729: looking
16:44:55 <benzrf> cable729: why are you using return on line 1
16:44:59 <ParahSailin> @ty readFile
16:45:00 <lambdabot> FilePath -> IO String
16:45:02 <benzrf> *of the do
16:45:15 <ParahSailin> @ty return . readFile
16:45:16 <lambdabot> Monad m => FilePath -> m (IO String)
16:45:19 <gsnedders> jrmithdobbs: AFAIK, essentially it's because line breaks are significant in JS, and they're both line break characters.
16:45:30 <cable729> benzrf: because it was giving me an error, it was saying input was of type IO String
16:45:49 <benzrf> do you know what return does
16:45:58 <cable729> I think I read that it extracts the value from IO
16:46:01 <benzrf> :t return
16:46:03 <lambdabot> Monad m => a -> m a
16:46:12 <cable729> huh
16:46:13 <chrisdone> cable729: do you have a book?
16:46:16 <benzrf> > return "foo" :: IO String
16:46:17 <lambdabot>   <IO [Char]>
16:46:17 <cable729> nope
16:46:23 <chrisdone> @where lyah
16:46:24 <lambdabot> http://www.learnyouahaskell.com/
16:46:29 <cable729> that
16:46:31 <benzrf> > do f <- return "foo" :: IO String; f
16:46:32 <lambdabot>   Couldn't match type `[]' with `GHC.Types.IO'
16:46:32 <lambdabot>  Expected type: GHC.Types.IO G...
16:46:33 <cable729> that's what I'm using mostly
16:46:35 <benzrf> meh
16:46:46 <benzrf> cable729: return PUTS the value into a monadic context
16:47:04 <benzrf> you would do return "foo" to get an 'IO action' that results in "foo
16:47:05 <benzrf> "
16:47:08 <cable729> :t readFile String
16:47:10 <lambdabot> Not in scope: data constructor `String'
16:47:11 <peddie> chrisdone: will zipping two bytestrings cause it to make a lot of intermediate junk?  the one is a few tens of megs long
16:47:17 <cable729> :t readFile ""
16:47:18 <lambdabot> IO String
16:47:29 <benzrf> cable729: also, why do you need the type annotation?
16:47:33 <benzrf> can't it infer it?
16:47:34 <geekosaur> return doesn't take out of IO, it puts in IO
16:47:40 <geekosaur> (here)
16:47:40 <cable729> I'm not sure, my data is in a tuple
16:47:50 <benzrf> cable729: you should almost never need :: inside a function
16:48:06 <benzrf> also, why are you using <- with a regular value
16:48:10 <benzrf> *non-monadic
16:48:18 <cable729> because I don't know syntax :P
16:48:20 <benzrf> :t read
16:48:21 <lambdabot> Read a => String -> a
16:48:30 <monochrom> cable729: where can I read about "trymove"?
16:48:31 <benzrf> cable729: in general,
16:48:36 <chrisdone> peddie: zipping two bytestrings? it depends on the use -- if you're immediately destructing the tuples, it might not even make them. if you're keeping the resulting list around, it will probably keep them. one way to find out is to look at the core
16:48:40 <benzrf> <- is for 'extracting' values from monadic contexts
16:48:42 <benzrf> in a sense
16:48:48 <cable729> That's a function I have to create for my assignment
16:48:55 <cable729> trymove :: (Int, Int, Int, [[Char]], Char) -> (Int, Int, Int, [[Char]])
16:48:58 <benzrf> so if foo is an IO action, you can 'run it and get the result' with <-
16:49:06 <benzrf> foo <- getLine
16:49:11 <benzrf> because getLine is an 'IO action'
16:49:14 <cable729> okay
16:49:18 <benzrf> read "foo"
16:49:21 <monochrom> ok, must you call trymove inside runPart1?
16:49:24 <jjauhien> hey, is there any standard function to check if list has/hasn't duplicates?
16:49:25 <benzrf> :t read
16:49:25 <cable729> how do I use let .... in ... after a do?
16:49:26 <lambdabot> Read a => String -> a
16:49:29 <Cale> Better than saying that "return puts the value into a monadic context" would perhaps be to say "return constructs an action which does nothing except to produce that value as its result"
16:49:30 <benzrf> cable729: what do you mean?
16:49:31 <peddie> chrisdone: ouch, ok . . . the other thing is I guess I need to convert a cyclic list to a ByteString somehow . . . :)
16:49:51 <benzrf> cable729: remember, everything in haskell is an expression
16:49:53 <chrisdone> peddie: what're you trying to write?
16:49:54 <monochrom> ok, I guess too many chefs
16:50:02 <benzrf> do-notation is just sugar for >> and >>=
16:50:09 <chrisdone> jjauhien: i don't think so, not a standard single function
16:50:20 <benzrf> @undo do foo <- getLine; putStrLn foo
16:50:20 <peddie> chrisdone: I'm getting an image over a network connection with 16-bit pixels, and I'm just trying to truncate them so I can get a quick preview in Gloss
16:50:20 <lambdabot> getLine >>= \ foo -> putStrLn foo
16:50:22 <cable729> I'm pretty sure I got errors on contents <- readFile file; let input = read contents in trymove input
16:50:24 <jjauhien> chrisdone, :(
16:50:34 <chrisdone> jjauhien: if you don't care about performance, just xs == nub xs
16:50:36 * monochrom consults the Assassin Creed about price quotes for eliminating all other chefs
16:50:39 <benzrf> cable729: Probably because do does not require in
16:50:41 <benzrf> do
16:50:43 <intrados> If I have a Foo = Bar | Baz, is there a generic way to convert a string "Bar" to Bar? Or do I just have to pattern match for all the variants?
16:50:44 <benzrf>   let foo = 3
16:50:46 <benzrf>   foo
16:50:46 <chrisdone> jjauhien: that will return false if there were duplicates
16:50:50 <benzrf> well, that would't work
16:50:55 <benzrf> because 3 is not a monadic value
16:50:58 <benzrf> but w/e
16:50:59 <simpson> intrados: Did you want to derive Read for your class?
16:51:02 <geekosaur> intrados, deriving (Read)
16:51:07 <simpson> > read "42" :: Int
16:51:08 <lambdabot>   42
16:51:16 <ParahSailin> do also sugars for pattern matching and fail
16:51:18 <chrisdone> jjauhien: (where caring about performance is like "1000 elements? pfft, use nub")
16:51:24 <intrados> simpson: geekosaur: Thanks
16:51:31 <jjauhien> chrisdone, :)
16:52:21 <cable729> benzrf: I'm still not sure how to write this function. I just need to read the file contents into a tuple and call a function with that tuple
16:52:41 <cable729> benzrf: and return whatever that function returned
16:52:59 <monochrom> cable729, I suggest to disclose the full specification to those who help you
16:53:02 <chrisdone> i wonder if we could add a fake IO monad to lambdabot
16:53:20 <cable729> Okay, just a second I'll make a new paste
16:53:27 <chrisdone> then we could demonstrate more stuff
16:53:50 <jjauhien> chrisdone, in fact there are just numbers from 1..9
16:53:53 <jjauhien> :)
16:54:05 <chrisdone> jjauhien: heh. is this for an assignment?
16:54:13 <jjauhien> chrisdone, sure :)
16:54:14 <chrisdone> because there are lots of assignment questions tonight
16:54:16 <chrisdone> hahaha
16:54:16 * hackagebot pipes-cereal-plus 0.1.0 - Streaming serialization library on top of "pipes" and "cereal-plus".  http://hackage.haskell.org/package/pipes-cereal-plus-0.1.0 (NikitaVolkov)
16:54:32 <jjauhien> chrisdone, I also think about null $ xs \\ [1..9]
16:55:15 <k00mi> chrisdone: start of the new semester ;)
16:55:22 <cable729> http://lpaste.net/95732 here it is
16:55:23 <chrisdone> aha
16:55:37 <monochrom> I like assignments. I just don't like lazy disclosure of assignment information bit by bit
16:56:00 <chrisdone> monochrom: nod
16:56:11 <jjauhien> well, the tasks are simple so I try to play with solution - to make it as clear as possible and as beautiful as possible
16:56:17 <monochrom> in Hong Kong we have just coined a term for lazy bit by bit disclosure by untrustworthy politicians. "squeezing out the toothpaste"
16:56:51 <chrisdone> monochrom: is that like getting blood from a stone?
16:57:02 <cable729> @chrisdone I'm not being lazy, I don't want you to do the assignment for me, I'm just looking for help getting the syntax right :/
16:57:02 <lambdabot> Unknown command, try @list
16:57:35 <monochrom> it is not like getting blood from stone. because eventually we did get some confession. :)
16:57:41 <chrisdone> cable729: i wasn't saying you were being lazy =)
16:58:27 <chrisdone> cable729: fwiw, you can use `undefined' wherever you like and the compiler will accept it. it's a good way to put in "holes" where you're not sure what to write yet, you can build the program up incrementally, checking it each step
16:58:45 <cable729> chrisdone: cool
16:59:15 <monochrom> politician: "my home didn't violate any building regulations."  reporter: "we have just photoed this violation at your home."  politician: "ok I admit I have one instance of violation."  reporter: "we have now photoed a second violation."  politician: "ok I now admit I have 2 violations."  reporter: "what else are you hiding?"
16:59:21 <Maxdamantus> >> fmap id undefined
16:59:25 <Maxdamantus> > fmap id undefined
16:59:27 <lambdabot>   No instance for (GHC.Show.Show (f0 b0))
16:59:27 <lambdabot>    arising from a use of `M53328760...
16:59:40 <monochrom> that is an example of squeezing out the toothpaste
16:59:48 <Maxdamantus> Meh, no monomorphism restriction.
17:00:02 <Hafydd> Good name for it.
17:00:09 <Maxdamantus> Maybe it doesn't matter in ghci.
17:00:11 <chrisdone> cable729: do you have ghci running?
17:00:15 <Hafydd> I have a tube of toothpaste that's at that stage, right now.
17:00:17 <cable729> chrisdone: yes
17:00:39 <chrisdone> cable729: ok, try writing  :t readFile
17:00:52 <chrisdone> cable729: then :t readFile "foo.txt"
17:01:11 <monochrom> cable729: your problems, as I see it, are more semantics and less syntactic.
17:01:21 <chrisdone> cable729: then :t let runPart1 = readFile "foo.txt" in runPart1
17:01:25 <chrisdone> etc. gradually build it up
17:01:50 <monochrom> s/semantics/semantic/
17:01:58 <cable729> why do you have runPart1 twice?
17:02:17 <tromp__> making tabs illegal in source code, good idea or not?
17:02:17 <monochrom> the first defines, the second uses
17:02:33 <cable729> so it calls itself?
17:02:35 <monochrom> good idea. tabs die die die.
17:02:40 <monochrom> no doesn't
17:02:42 <chrisdone> cable729: because the syntax is "let <name> = <expression> in <expression>" the latter is just so you get the type (:t) of the function. let syntax requires an `in
17:02:50 <monochrom> simply, define, then use. simply.
17:02:55 <tromp__> i hate tabs too
17:03:24 <chrisdone> cable729: http://tryhaskell.org/#15
17:03:27 <monochrom> I understand why other people use tabs though. it's a good use in Java etc. it's a bad use in Haskell.
17:03:27 <tromp__> too bad haskell allows them:(
17:03:45 <cable729> @chrisdone okay, I see
17:03:45 <lambdabot> Unknown command, try @list
17:03:49 <monochrom> oh, Haskell allows them. it can be made to work. just tricky.
17:03:50 <chrisdone> cable729: try a couple steps in that, it might clarify things
17:04:18 <chrisdone> monochrom: 2-spaces 4 life
17:05:23 <monochrom> why other people use tabs: they respect that different people want different indentations. so, indent with tabs. then each person can set his/her editor to display 1 tab as 3.14159 spaces, 2.71828 spaces, whatever he/she likes.
17:06:03 <cable729> @chrisdone Here's where I'm hitting a roadblock
17:06:04 <lambdabot> Unknown command, try @list
17:06:13 <cable729> :t let p1 = do <- readFile "foo.txt" in p1
17:06:14 <lambdabot> parse error on input `<-'
17:06:18 <Eduard_Munteanu> cable729: ... why are you still using @ ... ?
17:06:21 <monochrom> why that scheme doesn't work for Haskell: because Haskell is layout-sensitive, and it needs to hard-pin tab to mean multiples of 8.
17:06:25 <cable729> It's hard to adjust ..... :(
17:06:44 <monochrom> it's ok, don't feel bad
17:08:19 <monochrom> how to use tabs with Haskell: before you submit code to compiler, submit to lpaste first, verify the layout on lpaste. because that is what the compiler will see, too.
17:08:37 <bitemyapp> What does ⇓  generally mean in a white paper?
17:08:44 <bitemyapp> Specifically from: http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
17:08:57 <monochrom> specific is better than general
17:09:02 <chrisdone> cable729: so the reason that doesn't work is because `do' notation should always end in an expression, "x <- y" is a generator. so you can write:
17:09:05 <monochrom> which page?
17:09:21 <chrisdone> :t let p1 = do foo <- readFile "foo.txt"; return foo in p1
17:09:22 <lambdabot> IO String
17:09:31 <monochrom> x⇓y  iff  when evaluation of x finishes, the result is y
17:09:37 <cable729> So the result is an IO String
17:09:46 <cable729> Do I need to extract the string?
17:10:16 <chrisdone> cable729: `foo' is the string, p1 is the IO String. you already have the string in `foo'
17:10:25 <chrisdone> :t let p1 = do foo <- readFile "foo.txt"; return () in p1
17:10:26 <lambdabot> IO ()
17:10:35 <cable729> Oh, cool
17:10:57 <monochrom> hey! the text has it too. "The notation e⇓v means that the result of completely evaluating e is v". do you see that?
17:11:28 <monochrom> P.S. yes I do hate people's convention of putting a figure before the text that refers to that figure
17:11:31 <bitemyapp> oh, now I see it.
17:12:06 <bitemyapp> monochrom: yeah that was momentarily very confusing, sorry and thank you.
17:12:10 <chrisdone> i'd've used resultIs e v
17:12:24 <chrisdone> but i like obvious clarity. i'm weird like that
17:12:24 <monochrom> I don't know where that convention came from. but it has been in LaTeX. I hate it. but every academic type just goes with it. I don't get it.
17:13:09 <enthropy> monochrom: maybe it's like putting the caption above the thing?
17:13:27 <cable729> @chrisdone I like obvious clarity too. I dream of a day where math textbooks have references to what theorem they reference in every implication (electronically of course)
17:13:27 <lambdabot> Unknown command, try @list
17:13:27 <Eduard_Munteanu> Not sure what you're referring to, putting captions below figures?
17:13:32 <cable729> damn
17:13:35 <monochrom> except, LaTeX puts the caption below the figure
17:13:38 <cable729> chrisdone: haha
17:13:52 <Eduard_Munteanu> cable729: does your IRC client even tab-complete if you start the nick with @?
17:14:08 <chrisdone> it's the twitter generation. they use @
17:14:11 <cable729> I've used @ for twitter, facebook, google+, and I've rarely if ever used IRC
17:14:13 <chrisdone> i kinda like it
17:14:17 <enthropy> Eduard_Munteanu: yes. RE. conventions for documents that are confusing
17:14:24 <bitemyapp> cable729: RapGenius?
17:14:30 <monochrom> I think the convention began with LaTeX or TeX, and it was because ease of implementation, not ease of making sense.
17:14:32 <cable729> bitemyapp: what's that?
17:14:37 <bitemyapp> cable729: references in RapGenius' wiki format shows you the summary data.
17:14:52 <bitemyapp> it's actually a lyrics site for rap songs, but it's very useful for reading things with dynamic context.
17:15:12 <bitemyapp> I've been considering writing an open source derivative of it for programming and math.
17:15:35 <bitemyapp> (I'm a little obsessed with wikis)
17:15:57 <benzrf> wikis are awesome
17:16:02 <cable729> @bitemyapp so people basically just add tags to lines and stuff?
17:16:02 <lambdabot> Unknown command, try @list
17:16:09 <cable729> I did it again
17:16:17 <benzrf> & having been to rapgenius, it is indeed an extremely awesome site
17:16:21 <benzrf> in terms of tech & usage i mean
17:16:51 <chrisdone> i wonder if there are irc channels with teens in them and they all use @nick to eachother
17:16:52 <bitemyapp> cable729: uhhh...they tag fragments that indicate nouns, not specific lines. If you just click around the RapGenius site (it's free to use) you'll see what I mean very quickly.
17:17:01 <bitemyapp> chrisdone: strange, no?
17:17:07 <bitemyapp> the IRC client will do te work for you, no need to use @
17:17:09 <cable729> anyways, thanks for the help, I've got to go
17:17:13 <cable729> cya later all
17:17:42 <monochrom> enthropy: the problem is way more severe than you probably think. suppose the figure is immediately above the referring text, then that is only a small problem. as it is, LaTeX puts the figure at the beginning of the page, this means up to 11 inches above the referring text.
17:17:48 <bitemyapp> benzrf: I've been musing making an OSS alternative to RG for code/math for awhile, you think it'd be a good idea?
17:22:56 <benzrf> bitemyapp: sure
17:23:19 <benzrf> i think a good idea for a website would be something like a wiki
17:23:30 <benzrf> where each page has varying levels of detail
17:23:46 <benzrf> and you can edit the page at any of the levels
17:24:01 <benzrf> then the more you recursively open links, the less detailed version of each page opens
17:24:10 <benzrf> that way you can learn something without going on a wiki walk
17:24:16 <benzrf> if you don't have the time, or actually need to know something
17:25:26 <bitemyapp> benzrf: I think I'd be happy to just have nice inline references.
17:26:20 <benzrf> hm
17:26:32 <bitemyapp> ala RG.
17:27:07 <bitemyapp> Organizing knowledge is difficult, it gets exponentially worse the harder you make it to contribute/maintain or the more automated a fashion you try to process or present the information.
17:27:12 <bitemyapp> Or the less structured it is.
17:27:17 <prooftechnique> benzrf: Louis Lamport had a similar idea for proofs
17:27:26 <benzrf> prooftechnique: oh?
17:27:34 <bitemyapp> that's a neat thought.
17:27:38 <prooftechnique> Yeah, lemme see if I can dig up the paper
17:28:55 <prooftechnique> Sorry, Leslie Lamport
17:28:56 <prooftechnique> Derp
17:29:20 <Hafydd> If each subsequent page had 1/2 the information in the first page, you'd only ever read 1 + 1/2 + 1/4 + 1/8 + ... = 2 pages, even if you read infinite articles!
17:29:49 <benzrf> Hafydd: ;)
17:29:54 <benzrf> exactly my point
17:29:56 <benzrf> :-D
17:30:26 <Eduard_Munteanu> Sort of how I feel when I read stuff and I'm too tired. :P
17:30:51 <prooftechnique> benzrf: I think it's this one: https://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-how-to-write.pdf
17:31:24 <Sakinim> hi
17:32:02 <prooftechnique> hi
17:49:34 <zardoz``> "The throwIO variant should be used in preference to throw to raise an exception within the IO monad because it guarantees ordering with respect to other IO operations, whereas throw does not."
17:50:12 <zardoz``> what does this mean in practice?  will a code using throw instead of throwIO in IO monad potentially cause bugs?
17:51:03 <zardoz``> I am doing something like this.  catch act handler     handler err = do {-# clean up #-} throwIO err
17:51:43 <heatsink> I think that finally does that
17:51:46 <zardoz``> I tested it and throw and throwIO both worked the same
17:51:59 <zardoz``> heatsink ah, I didn't realize it existed
17:52:14 <zardoz``> still curious if using throw instead of throwIO there could cause problems in practice, in ghc
17:53:38 <heatsink> idk
17:54:14 <prooftechnique> zardoz``: I imagine it's exactly what it says. Ordering is not guaranteed unless you use throwIO
17:54:15 <zardoz``> if it can it could be a source of bugs because throw compiles just fine too
17:54:53 <zardoz``> prooftechnique well ordering (of evaluation) is not guaranteed for seq either, but everyone seems to be using it as if it was..
17:55:24 <zardoz``> so maybe it's another case of only theoretical problem, that doesn't exist practice
17:56:16 <prooftechnique> May as well be safe. Are those extra characters not worth removing the uncertainty?
17:56:41 <zardoz``> of course they are. I am just wondering if this is a potential pitfall in practice
18:01:37 <Morpheus> I am a learner of haskell, and working on roll your own irc bot
18:02:12 <Morpheus> I have a problem with the last version shown in the tutorial with the bracket command
18:02:36 <heatsink> ok
18:03:13 <heatsink> What is your problem?
18:07:08 <Morpheus> I just tried pasting into the paste link and it was rejected as spam!
18:07:23 <Morpheus> I am also new to irc xchat
18:08:55 <heatsink> Morpheus, use hpaste.net
18:09:06 <heatsink> Wait, that's not the right link
18:09:07 <heatsink> @paste
18:09:08 <lambdabot> Haskell pastebin: http://lpaste.net/
18:09:12 <heatsink> lpaste.net
18:12:02 <Morpheus> I have just managed to paste the code and errors to the link
18:12:34 <Morpheus> http://lpaste.net/95737 - is the code
18:13:14 <Morpheus> http://lpaste.net/95736 - this is the error i get
18:13:50 <heatsink> :t bracket
18:13:51 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:14:08 <zardoz``> Morpheus just guessing here, replace >>= on that line with newline
18:14:43 <heatsink> 'bracket' runs some setup code, and passes its result to the body and cleanup function
18:14:51 <zardoz``> no ignore me
18:14:55 <heatsink> Your cleanup function is putStrLn "done."
18:16:37 <Morpheus> The previous exercises in the tutorial work ok.
18:16:44 <heatsink> putStrLn "done." doesn't take an argument
18:17:29 <heatsink> I haven't seen the tutorial.  This is just what I noticed from the code and the error message.
18:17:47 <Morpheus> I have also tried replacing the putStrLn with printf "done. \n" but still get the same error
18:18:46 <Morpheus> I think the tutorial was written for earlier version of bracket, and changes to the bracket command aren't reflected in the tutorial
18:19:40 <heatsink> Type signatures are useful for understanding code.  Can you paraphrase the type signature of 'bracket'?
18:19:55 <Morpheus> no
18:20:48 <heatsink> You can see that it's a three-argument function because the type has the form _ -> _ -> _ -> _
18:20:50 <Morpheus> Is there anyway to reduce the noise of users joining/leaving this chat
18:20:58 <heatsink> I don't think so
18:20:59 <prooftechnique> Morpheus: It's a setting in your IRC client
18:22:03 <heatsink> The first argument type is IO a.  It's an IO action.  The next two argument types are (a -> IO b) and (a -> IO c).  These are both one-argument functions that return an IO action.
18:22:30 <heatsink> However, (putStrLn foo) is not a function.  It's an IO action.
18:23:25 <heatsink> That is what the error message is telling you.  The expected type is a function type, () -> IO b0.  The actual type is an IO action type, IO ().
18:23:36 <Morpheus> you beat me, but explained it better - I was going to say bracket looking for 3 args, and putStrLn is providing only one
18:23:57 <prooftechnique> Not quite
18:24:10 <prooftechnique> :t putStrLn
18:24:11 <lambdabot> String -> IO ()
18:24:15 <prooftechnique> :t putStrLn "done."
18:24:16 <lambdabot> IO ()
18:24:21 <Morpheus> ok, so there is going to have to be a change to that line
18:24:29 <prooftechnique> :t bracket
18:24:30 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:24:34 <Morpheus> to change its behaviour
18:24:57 <heatsink> Yes.  You want a function that ignores its argument and returns putStrLn "done."
18:25:09 <heatsink> Have you learned lambda syntax?
18:25:19 <Morpheus> is lambdabot connected in here? I have only just downloaded, but not looked at it yet.
18:25:19 <prooftechnique> :t flip const $ putStrLn "done."
18:25:20 <lambdabot> c -> c
18:26:09 <heatsink> Combinators are a little hard for beginners to use, prooftechnique
18:26:15 <Morpheus> No I have not learned lambda - I am mostly ancient and disabled and started with procedural languages last century using asm, c, c++, cobol and pascal, and brain is having problems
18:26:23 <prooftechnique> heatsink: Yeah, and also that's utter nonsense, so... :D
18:27:03 <heatsink> Okay, well lambdas take a little getting used to.  They're basically an expression syntax for writing functions.
18:27:18 <Morpheus> K
18:27:22 <prooftechnique> Not to mention that I did it backwards
18:27:25 <heatsink> > "hello " ++ "cool" ++ " world"
18:27:26 <lambdabot>   "hello cool world"
18:27:42 <heatsink> > (\x -> "hello " ++ x ++ " world") "cool"
18:27:44 <lambdabot>   "hello cool world"
18:27:59 <heatsink> > let f = (\x -> "hello " ++ x ++ " world") in (f "cool", f "cruel")
18:28:01 <lambdabot>   ("hello cool world","hello cruel world")
18:28:08 <prooftechnique> :t const (putStrLn "done.")
18:28:09 <lambdabot> b -> IO ()
18:28:16 <Morpheus> I am slowly reading Real World Programming in Haskell. I never did calculus
18:28:27 <prooftechnique> It's not that kind of calculus
18:28:29 <prooftechnique> No worries
18:28:34 <heatsink> In your case, you can write (\x -> putStrLn "done.")
18:28:53 <heatsink> The 'const' version does the same thing in a different way
18:28:53 <prooftechnique> Which is equivalent to const (putStrLn "done.")
18:29:09 <Morpheus> and the theory is proving difficult for ossified brain
18:29:23 <Morpheus> but I am enjoying the learning
18:29:51 <Morpheus> I wish there were a lot more tutorials for apprentices like me.
18:30:06 <prooftechnique> @where lyah
18:30:06 <lambdabot> http://www.learnyouahaskell.com/
18:30:07 <heatsink> The other tutorial is lyah
18:30:26 <Morpheus> Yep, aware of that one as well
18:30:28 <prooftechnique> @where wikibook
18:30:28 <lambdabot> http://en.wikibooks.org/wiki/Haskell
18:30:56 <Morpheus> thanks, hadn't found that one yet
18:30:57 <himhm> Morpheus: My .02 -- if you're starting out, LYAH is better than Real World Haskell
18:31:04 <Morpheus> K
18:31:25 <prooftechnique> Definitely for learning theory in a friendly way
18:31:36 <prooftechnique> RWH has more applications, though
18:31:49 <prooftechnique> @where scheme
18:31:49 <lambdabot> I know nothing about scheme.
18:31:55 <prooftechnique> @where write yourself a scheme
18:31:56 <lambdabot> I know nothing about write.
18:32:14 <Morpheus> In past I have found I learn better by entering code myself, and understanding how it works
18:32:14 <prooftechnique> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
18:32:26 <Morpheus> and getting something useful at the same time.
18:32:27 <prooftechnique> Morpheus: That's also a good one, if you want a whole project to do
18:32:32 <nedbat> i'm looking for a discussion of haskell's implementation that will help me understand how I can have immutable datastructures and not copy data all over the place. Does such a thing exist?
18:32:46 <Morpheus> K - will look at that one as well.
18:32:54 <heatsink> @where WMDs
18:32:55 <lambdabot> I know nothing about wmds.
18:33:02 <Morpheus> Thanks for your assistance - it is greatly appreciated.
18:33:27 <Morpheus> Not that I know anything about Scheme
18:33:52 <prooftechnique> @where+ scheme https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
18:33:52 <lambdabot> I will never forget.
18:33:56 <heatsink> I don't think there's a single answer to that, nedbat.  There are lots of programming techniques that are relevant in different situations.
18:34:09 <himhm> nedbat: If you find one, I'd like to know too because to the best of my knowledge it's all just a lot of copying all over the place
18:34:10 <heatsink> Chris Okasaki's book on functional data structures covers some frequently used ones
18:34:38 <Cale> nedbat: If you're interested in a very low-level perspective on that, you might start from the paper for the Spineless Tagless G-machine
18:34:39 <himhm> nedbat: which of course begs the question, does haskell scale?
18:34:56 <Morpheus> @where
18:34:56 <lambdabot>  @where <key>, return element associated with key
18:34:56 <prooftechnique> Agh... I still need to grok STG
18:34:59 <heatsink> @faq does Haskell scale?
18:35:00 <lambdabot> The answer is: Yes! Haskell can do that.
18:35:15 <nedbat> himhm: I have no insight into that, I'm a total haskell newb
18:35:25 <Morpheus> @where write yourself a scheme
18:35:26 <lambdabot> I know nothing about write.
18:35:30 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf <-- this one
18:36:10 <Cale> nedbat: But the short high-level answer is that you don't have to copy immutable data structures because you can just refer to them.
18:36:30 <himhm> nedbat: Well I meant it rhetorically ;)
18:36:32 <Cale> (it's not like they're going to change!)
18:36:48 <nedbat> Cale: let's say I have a map, and I keep adding keys to it, am I copying the map each time I add a key?
18:37:04 <prooftechnique> You're creating a new map that references the old one
18:37:05 <nedbat> Cale: "map" may not be the right word.
18:37:15 <Cale> nedbat: No, you're constructing new binary trees, most of whose subtrees are shared with the old ones.
18:37:32 <prooftechnique> Yes, I guess shares is a better word than references
18:37:43 <Cale> (only the path from the element to the root will be newly constructed)
18:38:09 <Cale> (or some constant-width swath around that to help balance the tree)
18:38:29 <nedbat> Cale: ok, so the map structure has been designed from the start to be incrementally changed without changing the older view of it.
18:38:33 <Cale> right
18:41:09 <Cale> Designing good immutable data structures takes a good deal of care, but they also have some really inherently-useful properties which justify that extra work. It's nice to be able to hang on to older versions of things without worrying about taking copies when testing or implementing "undo" or backtracking algorithms.
18:41:26 <jjauhien> @fl take
18:41:26 <lambdabot> Not enough privileges
18:42:06 <jjauhien> @pl length xs ==9
18:42:06 <lambdabot> length xs == 9
18:42:10 <Cale> (and yeah, Chris Okasaki's thesis and book are probably a good place to learn about that, if you want to try to design your own structures rather than just using existing libraries)
18:42:21 <jjauhien> @pf length xs ==9
18:42:21 <lambdabot> Maybe you meant: pl bf
18:42:35 <prooftechnique> @unpl length xs == 9
18:42:36 <lambdabot> ((length xs) == 9)
18:42:42 <Cale> jjauhien: @pl won't do much to something which isn't a lambda
18:42:52 <jjauhien> ah, thanks
18:43:08 <jjauhien> @pl \xs -> length xs == 9
18:43:08 <lambdabot> (9 ==) . length
18:43:09 <prooftechnique> @pl f a b c = f(a(b(c)))
18:43:09 <lambdabot> f = fix ((. (.)) . (.) . (.))
18:43:52 <jjauhien> @pl \xs -> xs == nub xs
18:43:52 <lambdabot> ap (==) nub
18:43:59 <jjauhien> :t ap
18:44:00 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:44:16 <jjauhien> :t fmap
18:44:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:44:24 <prooftechnique> :t <*>
18:44:25 <lambdabot> parse error on input `<*>'
18:44:29 <prooftechnique> :t (<*>)
18:44:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:45:17 <prooftechnique> How *do* people say (<*>), anyway? I usually say "ap"
18:45:40 <hpc> ap is an apt name
18:47:07 <lpaste> enthropy pasted “sharing pascaltri without monomorphism?” at http://lpaste.net/95738
18:48:10 <enthropy> I'm wondering if there's some way to structure mkCoefs in there such that mkCoefs is works with stuff like Double and Rational, while still sharing the uses of pascaltri inside
18:48:25 <Fylwind> @pl f a b = h . g a b
18:48:25 <lambdabot> f = ((h .) .) . g
18:50:08 <Fylwind> @pl f a b = h (g a b)
18:50:08 <lambdabot> f = (h .) . g
19:18:42 <abg> If I have a function f :: a -> IO Bool, and a list [a], how can I get the first element that 'f' evaluated True for without evaluating it on the others?
19:18:58 <abg> The most obvious solution 'head <$> filterM f list' evaluates f on all elements.
19:19:34 <abg> > head <$> filterM (\v -> print v >> return (v == 3)) [1..6]
19:19:36 <lambdabot>   <IO Integer>
19:21:27 <witt3rd> hi - when i runghc on: main = interact (\s -> "in: " ++ s), it only outputs my "in:" once, but continues to accept input and echo it back out (just without the "in:")?
19:21:48 <hpc> :t interact
19:21:49 <lambdabot> (String -> String) -> IO ()
19:22:03 <geekosaur> witt3rd, s is a lazy single string containing *all* your input
19:22:10 <geekosaur> consider using lines and unlines
19:22:20 <witt3rd> ah!  ok, thanks!
19:22:52 <zardoz``> interact that works on lines is what I want most of the time.. easy to write one though
19:23:57 <himhm> Bit off topic but ever have to grep a really big file that wouldn't fit in memory. What did you do?
19:24:00 <koninkje> abg: you mean?> rec f [] = return Nothing ; ref f (x:xs) = f x >>= \b -> if b then return (Just x) else rec f xs
19:24:27 <koninkje> abg: If so, then check out Control.Monad foldM_ or foldM
19:26:12 <abg> koninkje: Yes. Yeah, I was going for foldM as a last resort. The use case sounded common enough that it was worth checking if something existed for it.
19:26:16 <abg> Thanks
19:26:53 <intrados> I want to transform JSON input from multiple sources into multiple instances of the same data structure. I define Foo in Base and import it into Bar and Baz. This allows me to do the appropriate transformations in the `FromJSON Foo` instances, but it also means orphan instances in Bar and Baz. Is there a better way?
19:27:12 <geekosaur> himhm: laziness handles that quite nicely. (or, stream processing in general --- the grep command works this way, at any time at most 2 blocks are in memory (block size is usually around 4k bytes)
19:28:24 <koninkje> abg: you might also try looking into http://hackage.haskell.org/package/monad-loops
19:29:23 <koninkje> abg: dropWhileM could be twisted to your purpose
19:29:46 <himhm> geekosaur: So why is grep eating all my memory? I set it to --line-buffered so don't understand why it's doing that
19:30:05 <abg> koninkje: Oh, great. That looks like it might work. Thanks!
19:30:42 <geekosaur> himhm: that sounds wrong, unless it's using mmap for some reason (mmap will confuse many programs that track memory, it shouldn't actually in use as such)
19:31:12 <koninkje> himhm: Are you munging unicode? I forget if grep can handle unicode, but sed certainly can't
19:31:23 <geekosaur> mmap-ing files can be quite fast for things like grep but does cause issues with large files and available address space. (the system should not however actually use that much memory)
19:31:46 <abg> koninkje: There's also firstM in that package that fits the use case exactly.
19:32:16 <himhm> koninkje: I don't actually know, I think so. But I set LC_ALL=C so it should only grep for ascii characters
19:32:30 <koninkje> abg: ah, nice
19:32:54 <geekosaur> himhm: are you actually seeing thrashing going on, or just a large process size?
19:33:31 <koninkje> himhm: the sed problem actually leads to cpu churn not memory issues; t'was just a thought
19:33:44 <koninkje> himhm: prolly not that though
19:34:44 <geekosaur> himhm: also, note the difference between virtual size and resident size
19:34:46 <himhm> geekosaur: Yea it would be for sure -- I'm watching my memory slowly go to zero and then kill the process before it starts thrashing
19:37:21 <pyro2> hello, I am new to haskell. how can i have multiple statements in a function?
19:37:42 <geekosaur> linux? possibly mis-tuned vm. if it mmap()s the file, the virtual process size will be the file size + the grep program size but the file is actually paged as needed from disk. this *will* eventually "use up" system memory as buffer cache, but this is only a problem if the system is mis-tuned such that it pages out important stuff to make room for file pages
19:37:47 <geekosaur> note that used/free is not a simplistic "oh no it's 0" thing --- modern memory management is *very* complex, and systems will try to use all available memory as buffer cache
19:38:08 <geekosaur> if you actually see thrashing (stuff being tossed out of memory and then pulled back in, constantly) *then* it is a problem. merely using all memory is normal operation and not at all surprising
19:38:25 <geekosaur> pyro2, Haskell doesn't really have "statements" as such
19:38:53 <geekosaur> there is a construct ("do") that pretends to do statements, but the result is actually a large single expression
19:39:28 <geekosaur> perhaps you should explain what you are actually trying to do, so we can help you understand how to do it in Haskell, rather than try to force an e.g. Python approach on a language that works completely differently
19:39:33 <geekosaur> also:
19:39:35 <geekosaur> @where lyah
19:39:36 <lambdabot> http://www.learnyouahaskell.com/
19:40:46 <pyro2> nothing in particular. i was just wondering how to so more than just returning one thing from a function
19:41:48 <himhm> geekosaur: osx/bsd. I'm getting pageouts so it's definitely writing to swap. But I think the problem might be a poorly crafted regex
19:42:28 <geekosaur> if the regex wants to match the whole file, that would indeed be a problem. (but would also take work as grep is rather line oriented. unless it thinks the whole file is a single line or something)
19:43:34 <himhm> I think the regex was just matching on a very common pattern... trying again.
19:43:35 <geekosaur> also pageouts are not by themselves worrisome; there's a lot of stuff that gets pulled into memory during system boot and is only needed *for* system boot; it will eventually get evicted from memory and not come back because it's not needed. if you are seeing lots of page*in*s, there may be an issue
19:43:37 <pyro2> how would you write cat for example? read lines, print them
19:44:29 <geekosaur> unless I actually needed to do lines, I wouldn't bother with them. main = hGetContents stdin >>= putStr
19:45:03 <geekosaur> this is a lazy string representing the whole file --- it does not mean the whole file is in memory, it will actually be read in a block at a time and written back out again
19:45:20 <geekosaur> make that: main = getContents >>= putStr
19:46:24 <c_wraith> main = interact id
19:46:28 <geekosaur> if I actually needed to do something with individual lines: main = getContents >>= putStr . unlines . map processLine . lines
19:46:46 <geekosaur> and then processLine is a function (String -> String) which does something to a single line
19:47:55 <geekosaur> and yes, "interact" is a convenient shorthand for that common pattern. I might rewrite the processLine one as: main = interact (unlines . map processLine . lines)
19:50:58 <geekosaur> the . there is function composition. you might think of it as being like | in the unix/linux shell, only reversed (data flows from right to left)
19:51:18 <geekosaur> connecting functions together to transform an input into an output
19:52:13 <pyro2> what about >>=?
19:52:35 <geekosaur> similar (although it goes left to right), but it chains monadic actions. that's... more complex
19:53:31 <geekosaur> Haskell is "pure" --- you don't have side effects (including things like assigning to variables). SO we have this construct called a monad which lets us encode things purely that would require side effects in other languages
19:53:56 <geekosaur> But to do this, we need a bit of extra plumbing, specific to each monad; the definition of (>>=) for each monad provides the plumbing
19:55:13 <geekosaur> In the case of IO, it mostly makes sure that things happen in the right order (between laziness and purity, operations can happen in pretty much any order normally because the compiler knows the order can't affect anything. but this is false for IO, so IO uses the monad to enforce order of operations, so you read data before writing it)
19:55:52 <geekosaur> but to enforce this, you can only do I/O operations when using the IO monad --- not in arbitrary code
19:57:59 <pyro2> that is a lot to take in :). thanks for the example though, it allows me play with simple programs that process stdin
19:58:48 <geekosaur> haskell does take a lot of getting used to
20:00:43 <geekosaur> I shuld mention that while monads let us enforce things like ordering, they're much more general than that. in fact they're so general that they're really hard to explain properly
20:01:35 <geekosaur> but, at least at first, the IO monad is the only one you'll care about, and that one is about sequencing effects so your reads and writes happen when they're supposed to. Later on we can break your brain with the list monad or Cont :p
20:01:48 <pyro2> i like how elegant that one-line main is. I can tell what is going on from reading it, even though I don't quite understand how it works
20:02:00 <geekosaur> you will have plenty of brain breaking moments before you get to those, trust me :)
20:05:53 <geekosaur> there's quite a lot going on in that one line that you don't see
20:06:24 <geekosaur> taking the longer one: main = getContents >>= putStr . unlines . map processLine . lines
20:07:09 <geekosaur> getContents returns the program's entire input as a lazy string: more data will be read in as needed, and earlier data you're not using will be quietly and automatically garbage collected (unles syou accidentally hold on to all of it)
20:07:19 <geekosaur> we use laziness a *lot* in Haskell
20:08:15 <geekosaur> so, with this lazy String: "lines" breaks this lazy String into a lazy list of String-s at line boundaries. ("unlines" of course does the reverse.) "map" invokes a function on each element of a list (so, on each line).
20:08:32 <pyro2> so it magically reads by chunks, as we need it
20:08:46 <geekosaur> laziness means you don't need to pay attention to the mechanics of reading and writing individual lines, it's all handled automatically as needed
20:10:39 <geekosaur> you can get some very elegant code because all the gruntwork happens in the background. you get to write what you mean at a higher level (like "find all periods and replace them with commas") and not have to worry about the scaffolding that gets data in and out and loops over lines, etc.
20:11:51 <pyro2> I see.. completely different to what I am used to
20:11:56 <geekosaur> laziness also means that a lot of things that have to be syntax built into the language are writable as normal functions. that "map" is an ordinary function, defineable in simple Haskell code, that acts like the "for" or "foreach" loop hardwired into other languages
20:12:21 <geekosaur> (and doesn't use something like a builtin "for" underneath.)
20:12:26 <geekosaur> @src map
20:12:26 <lambdabot> map _ []     = []
20:12:26 <lambdabot> map f (x:xs) = f x : map f xs
20:13:23 <geekosaur> "for an empty list, return an empty list. for a list consisting of a head element and the tail of the list, return a list consisting of the result of applying "f" to the head element and the list returned by calling map on the tail of the list"
20:13:51 <pyro2> I know map from python, if it does the same thing. I cant quite read that yet though, apart from seeing that it recurses
20:14:46 <geekosaur> (really lists themselves are the equivalent of loops)
20:15:14 <pyro2> so first map definition is called only if a list is empty?
20:15:20 <geekosaur> right
20:15:22 <ion> pyro2: (:) generates a list:
20:15:29 <geekosaur> each of those definitions is a pattern
20:15:31 <ion> > 1:(2:(3:(4:[])))
20:15:33 <lambdabot>   [1,2,3,4]
20:15:35 <ion> > 1:2:3:4:[]
20:15:37 <lambdabot>   [1,2,3,4]
20:15:38 <geekosaur> _ matches anything and ignores it
20:15:49 <geekosaur> since we don't care about the function for an empty list, we just say _ for it
20:15:55 <ion> pyro2: It also deconstructs a list to the head and the tail in a pattern.
20:16:07 <ion> > case "hello" of (x:xs) -> (x, xs)
20:16:08 <geekosaur> then we match an empty list, and the first definition is used which just produces an empty list.
20:16:09 <lambdabot>   ('h',"ello")
20:16:51 <ion> > let f = (+10) in f 1 : map f [2,3,4]
20:16:52 <geekosaur> the second one, we match anything (which, as used, must be a function) and bind it to `f`. we then match a non-empty list, as ion just described
20:16:52 <lambdabot>   [11,12,13,14]
20:16:54 <frx> read : like cons or prependHead
20:17:19 <geekosaur> Haskell doesnt use parentheses for function calls: you don't say `f(x)`, you say `f x`.
20:17:28 <geekosaur> or `map f xs`
20:17:49 <geekosaur> (which would be `map(f, xs)` in Python)
20:18:12 <pyro2> yes I like that
20:18:29 <geekosaur> the reason we do it this way ("curried" notation) is because we can do partial application
20:18:47 <geekosaur> you'll note that map takes a function and a list... but when I used it before, I only specified the function.
20:19:01 <pyro2> yes
20:19:06 <geekosaur> the list comes from the result of `lines`
20:19:29 <geekosaur> and the (.) operator is what feeds that result as the list parameter to `map`
20:20:32 <geekosaur> likewise, `lines` takes a string as a parameter... but here, that comes from the (>>=) operator.
20:21:16 <geekosaur> :t unlines . map ?f . lines
20:21:17 <lambdabot> (?f::String -> String) => String -> String
20:22:01 <pyro2> that is amazing how you can combine functions like that
20:22:11 <geekosaur> given some unspecified function `f` that takes a String and returns a String, `unlines . map f . lines` is a function that takes a String and returns a String
20:23:11 <geekosaur> (that ?f is not something you would normally use in a program but is very useful for asking for the type of something, as I did there. you can do that in ghci as well but you'll need to turn on the ImplicitParameters extension to use the ?f notation)
20:24:49 <pyro2> what is the return value of main function in your example?
20:25:14 <geekosaur> :t getContents >>= putStr . unlines . map ?f . lines
20:25:15 <lambdabot> (?f::String -> String) => IO ()
20:25:19 <ion> main isn’t a function.
20:25:52 <geekosaur> main is an IO action. the ones that don't do input (like getContents does) generally produce ().
20:25:53 <ion> A value is a function iff its type signature has (->) as the root element.
20:26:19 <ion> (ignoring constraints)
20:26:38 <frx> :t main
20:26:40 <lambdabot>     Not in scope: `main'
20:26:40 <lambdabot>     Perhaps you meant `min' (imported from Data.Ord)
20:27:14 <prooftechnique> geekosaur: Oh, wow, I didn't know about ImplicitParameters
20:27:21 <prooftechnique> That's going going in my .ghci
20:27:27 <prooftechnique> *-going
20:28:52 <ion> prooftechnique: Even better: GHC 7.8 is going to have holes.
20:31:14 <prooftechnique> Yeah, I saw that!!
20:31:17 <prooftechnique> I'm way excited
20:31:32 <augur_> what methods are there to have "nested" interaction?
20:31:49 <frx> what are holes? :/
20:32:02 <augur_> frx: holes are parts of a program that haven't been written yet
20:32:22 <augur_> frx: they let you say "im still working on what this should be"
20:32:37 <augur_> they're useful because you can use them to program incrementally
20:32:48 <prooftechnique> Way better than undefined everywhere
20:32:51 <frx> kind of like somefunc = undefined ?
20:32:54 <prooftechnique> Which is what I usually do now
20:32:55 <frx> I see
20:32:58 <augur_> frx: sort of, but more informative
20:33:22 <augur_> frx: true holes (not the fake ones we currently have) let you inspect the environment they're in to see what's in scope
20:33:48 <augur_> they also let you code a little but inside them to find a partial "refinement" of the hole
20:33:49 <augur_> etc
20:34:04 <frx> sounds great
20:34:41 <augur_> so for example, imagine you're trying to write map for lists using foldr
20:34:47 <augur_> you would start like so:
20:34:49 <prooftechnique> augur_: Maybe someday haskell-mode will have some of the agda-mode wackiness :)
20:34:54 <augur_> map f xs = ?
20:34:58 <augur_> where ? is the hole
20:35:08 <augur_> usually this gets transformed by your editor into something like
20:35:14 <augur_> map f xs = {! !}
20:35:20 <augur_> and inside the {! !} you can type stuff
20:35:36 <augur_> if you ask whats in scope inside this hole, itll say:   f :: a -> b, xs :: [a]
20:35:50 <augur_> now you think, aha, i can use foldr, so you type into the hole
20:35:59 <augur_> map f xs {! foldr ? ? ? !}
20:36:05 <augur_> and refine, and it expands like so:
20:36:06 <frx> do you do this interactively? in ghci
20:36:11 <augur_> map f xs = foldr {! !} {! !} {! !}
20:36:26 <augur_> frx: no you need a proper editor to do all of this interactively. currently theres no support, but soon
20:36:53 <frx> ah.. hopefully emacs will support it
20:37:02 <augur_> then you inspect the first hole and it says you need to give it something of type   a -> [b] -> [b]
20:37:09 <augur_> with f and xs still in scope ofcourse
20:37:19 <augur_> the second hole says you need to give it a [b]
20:37:27 <augur_> and the third hole says you need to give it a [a]
20:38:08 <augur_> so in hole 2 you put [], in hole you put xs, and refine:   map f xs = foldr {! !} {! [] !} {! xs !}   ~refine~>   map f xs = foldr {! !} [] xs
20:38:32 <augur_> in hole 1 you could "autorefine", which says, well, since you need to give an a -> [b] -> [b], that must be a lambda, so autorefining produces
20:38:46 <augur_> map f xs = foldr (\x ys -> {! !}) [] xs
20:39:07 <augur_> now your hole needs a [b], and you have in scope   f :: a -> b, xs :: [a], x :: a, ys :: [b]
20:39:23 <augur_> and so on and so on!
20:39:27 <frx> sounds much nicer than typing :t in ghci a lot :)
20:39:32 <augur_> its wonderful
20:39:38 <augur_> if you want to play around with holes, learn some agda.
20:39:47 <augur_> agda-mode in emacs is this, basically
20:40:24 <Hodapp> there's an agda-mode?
20:40:29 <augur_> Hodapp: yep
20:40:34 <prooftechnique> Hodapp: Yeah, it comes with agda
20:40:38 <Hodapp> if I ever start dabbling with agda maybe I'll use it
20:40:42 <prooftechnique> It's Awesome, with a capital A
20:40:46 <Hodapp> but I'm still learning Haskell >_>
20:41:28 <pyro2> is there an editor that supports function names completion for haskell code?
20:42:11 <prooftechnique> pyro2: emacs, vim, sublime (to some degree)
20:42:20 <augur_> pyro2: probably the cloud editor
20:42:28 <pyro2> ah nice
20:42:36 <poxy> emacs does? how??
20:42:38 <augur_> by uh.. FPComplete i guess?
20:42:55 <augur_> poxy: its emacs. its got lisp. what do you mean how? :P
20:43:02 <prooftechnique> poxy: autocomplete + ghc-mod seems to do the trick for me
20:43:18 <prooftechnique> Though vim seems to do it a bit better
20:43:19 <poxy> I use emacs and ghc-mode and I did not notice function name completions
20:43:23 <himhm> poxy: you can get haskell-mode with M-x package-install
20:43:31 <prooftechnique> poxy: Do you use autocomplete?
20:43:43 <himhm> or you could just use vim and be happy. *runs away*
20:44:13 <poxy> is autocomplete a ghc-mode related package, or?
20:44:18 <prooftechnique> Oh, and augur_, I found that hangman code
20:44:42 <prooftechnique> poxy: Nope
20:45:15 <prooftechnique> You can just M-x package-install it along with M-x package-install ghc-mod and haskell-mode, then a little setup and you should be good
20:45:20 <prooftechnique> I'll link my .emacs.d
20:45:30 <poxy> thanks, that would be great
20:45:35 <prooftechnique> poxy: https://github.com/prooftechnique/.emacs.d
20:45:36 <poxy> does it work for local functions as well?
20:45:47 <prooftechnique> It does
20:45:58 <poxy> and even qualified imports?
20:46:07 <prooftechnique> As far as I know, yeah
20:46:17 <prooftechnique> I've never had an issue. I think ghc-mod does the hard work
20:46:19 <prooftechnique> Back in a moment
20:46:34 <poxy> I'll try to get it working, thanks again
20:48:52 <benzrf> hi
20:49:12 <benzrf> should instances of Show be used for display to the user, or for internal string representation
20:49:48 <geekosaur> depends on what you're doing. sometimes it's appropriate for display to the user, often not.
20:50:01 <geekosaur> you might want to think of it as "debug display"
20:50:08 <benzrf> ok, thats what I meant for the latter
20:50:09 <benzrf> :u
20:50:12 <geekosaur> as opposed to "formatted display"
20:51:14 <benzrf> right
20:51:26 <lpaste> rerecord pasted “integration..” at http://lpaste.net/95740
20:51:59 <c_wraith> Do bounded cellular automata also form comonads?
20:52:18 <c_wraith> that is, if I only have 10 cells total, can I still use comonadic representation?
20:52:28 <benzrf> :i Comonad
20:52:36 <benzrf> buh
20:52:38 <rerecord> im getting the compile time error shown in the comment block.. http://lpaste.net/95740
20:53:36 <c_wraith> rerecord: there's no automatic conversion between Int and Double.  If you want to do arithmetic with both, you have to convert one to the other
20:54:01 <c_wraith> rerecord: in particular, that takeWhile in intervals uses < on an Int and a Double
20:54:10 <c_wraith> :t (<)
20:54:11 <lambdabot> Ord a => a -> a -> Bool
20:54:12 <rerecord> ohh
20:54:20 <c_wraith> Note that the two args are required to be the same type
20:54:36 <mcgrathj> might i ask a question about a specific usage of unsafePerformIO?
20:54:44 <danharaj> binding C libraries
20:54:58 <mcgrathj> oh, sorry! i meant to say that i have a specific usage
20:55:00 <geekosaur> what speccific usage did you have in mind?
20:55:11 <c_wraith> mcgrathj: you can always ask, but if you have more than about one line of code to show us, remember to use lpaste
20:55:13 <danharaj> yes but if it's not binding a C library you should feel a bit nervous :3
20:55:41 <benzrf> what other unsafes are there
20:55:43 <benzrf> ?
20:55:44 <mcgrathj> i wrote some json bindings that require thta the use of an api token and subdomain
20:55:49 <danharaj> :t unsafeCoerce
20:55:51 <lambdabot> Not in scope: `unsafeCoerce'
20:55:58 <danharaj> :t unsafeInterleaveIO
20:55:59 <c_wraith> unsafeInterleaveIO
20:55:59 <lambdabot> Not in scope: `unsafeInterleaveIO'
20:56:08 <danharaj> wow lambdabot. Way to be safe.
20:56:10 <c_wraith> for extra evil, there's unsafeInterleaveST
20:56:25 <mcgrathj> and i really wanted to avoid forcing the user to use a Reader or State monad, but still provide a clean interface
20:56:36 <mcgrathj> so i compromised and did something potentially dangerous
20:56:43 <c_wraith> I have an example on lpaste somewhere using unsafeInterleaveST to violate referential transparency in a terrible way
20:56:57 <geekosaur> and reallyUnsafePtrEq# is used sometimes by the runtime etc.
20:57:08 <mcgrathj> i posted the following on reddit: http://www.reddit.com/r/haskell/comments/1qqh15/first_attempt_at_notsothin_json_bindings_feedback/
20:57:18 <mcgrathj> and am trying to understand the reasoning behind the first response.
20:57:24 <geekosaur> (there are not many good uses of that. mostly used by the garbage collector I suspect)
20:57:25 <rerecord> :i fromInteger
20:57:30 <c_wraith> ah, here it is: http://lpaste.net/92226
20:57:32 <rerecord> :t fromInteger
20:57:34 <lambdabot> Num a => Integer -> a
20:57:36 <mcgrathj> (the first response has the code in question)
20:57:41 <rerecord> :t fromIntegral
20:57:43 <lambdabot> (Integral a, Num b) => a -> b
20:58:32 <c_wraith> rerecord: fromIntegral will go Int -> Double.  If you need to go Double -> Int, you need round, ceil, or floor
20:58:47 <intrados> When you fromList a list literal, does GHC vectorize that at compile-time?
20:58:56 <rerecord> i tried to convert all the Int to double using fromInteger. but its not accepting Int.. and asking for Integer
20:58:56 <geekosaur> anyway. the problem with what that code does is that, because of referential transparency, the compiler can decide to use the expression instead of its value. (think of inlining in other languages)
20:58:57 <mcgrathj> So, provided the suggestion in http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO-Unsafe.html are sufficient, it feels like everything should be fine (once I add those)
20:59:09 <c_wraith> rerecord: yeah, you need fromIntegral, not fromInteger
20:59:13 <c_wraith> rerecord: slightly different
20:59:15 <rerecord> k got it
20:59:23 <geekosaur> it is entirely possible that uses of apiTokenRef will turn into brand new MVars
20:59:29 <mcgrathj> right.
20:59:44 <geekosaur> (there si a pragma that can mostly prevent that from happening but there are still corner cases that can happen)
20:59:45 <danharaj> That use of unsafePerformIO is fine if you add {-# NOINLINE #-} pragmas.
20:59:46 <mcgrathj> so if i follow the suggestions in the docs (no inline, -fno-cse, etc.)
21:00:28 <geekosaur> but it is in general quite dangerous and a rather bad idea
21:00:38 <geekosaur> not to mention really terrible style :)
21:00:41 <mcgrathj> geekosaur: what would you recommend in this case?
21:01:38 <startling> intrados, no.
21:01:42 <mcgrathj> As soon as I introduce a MonadReader constraint, everything blows up. I see how to fix it, but it will definitely lead to an uglier implementation, but obviously more safe.
21:02:23 <mcgrathj> It just feels very heavy-weight to have to do thta.
21:02:30 <geekosaur> but that is how we do it. generally a newtype giving us something like withAPIDo somefunction
21:02:53 <geekosaur> and somefunction can then use the wrapped Reader (or State or whatever combination might be appropriate)
21:03:49 <geekosaur> the use of a newtype can clean up the types so you don't have to write long ReaderT types everywhere
21:04:02 <mcgrathj> Am I wrong to think that is less flexible (but obviously more correct)?
21:04:17 <geekosaur> depends on what you mean by flexible
21:04:43 <rerecord> i got a runtime error saying negative exponent what does it mean?
21:04:55 <geekosaur> one of the "tricks" in Haskell is to design your types so that you grant exactly the flexibility needed *and no more* --- doing illegal things should ideally lead to compile time type mismatches
21:04:58 <mcgrathj> So the problem that I run into is that I either have to thread some state by hand into the IO monad so that I can use catch, or whoever uses this library can't use a MonadError...
21:05:00 <geekosaur> and not runtime exceptions
21:05:07 <c_wraith> > 5 ** (-1)
21:05:09 <lambdabot>   0.2
21:05:24 <c_wraith> > 5 && (-1)
21:05:25 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
21:05:25 <lambdabot>    arising from the literal `5...
21:05:30 <c_wraith> gah, wrong button
21:05:35 <c_wraith> > 5 ^^ (-1)
21:05:37 <lambdabot>   0.2
21:05:38 <danharaj> :t &&
21:05:39 <lambdabot> parse error on input `&&'
21:05:42 <c_wraith> > 5 ^ (-1)
21:05:42 <danharaj> :t (&&)
21:05:43 <lambdabot>   *Exception: Negative exponent
21:05:44 <lambdabot> Bool -> Bool -> Bool
21:05:54 <danharaj> :t (&)
21:05:56 <lambdabot> a -> (a -> b) -> b
21:06:08 <c_wraith> rerecord: there are 3 exponentiation operators in haskell.  (^) doesn't work with negative exponents.
21:06:16 <c_wraith> rerecord: (^^) and (**) do.
21:06:20 <geekosaur> designing your types to grant just enough flexibility can take some work (and several iterations) but the payoff in catching logic errors before they crash your program can be pretty huge
21:06:26 <prooftechnique> What's the proper way to one-line guards?
21:06:37 <geekosaur> whereas this design doesn't let you catch much of anything
21:06:43 <rerecord> :t (^^)
21:06:44 <lambdabot> (Fractional a, Integral b) => a -> b -> a
21:06:55 <rerecord> :t (**)
21:06:57 <lambdabot> Floating a => a -> a -> a
21:06:58 <geekosaur> prooftechnique: foo x | x == 5 = 6 | x == 6 = 5 | otherwise = x
21:07:05 <rerecord> :t (^)
21:07:06 <lambdabot> (Integral b, Num a) => a -> b -> a
21:07:19 <rerecord> :t (-1)
21:07:20 <lambdabot> Num a => a
21:07:24 <prooftechnique> I thought so, but lambdabot and ghci seem to not do it the way I'd expect
21:07:26 <prooftechnique> *shrug*
21:07:52 <c_wraith> rerecord: check out the documentation for the three.  It'll explain the differences better than the types do.
21:07:59 <mcgrathj> Assuming unsafePerformIO were okay for a moment, what this design lacks is a mechanism to enforce that the user invoke those two functions before using the rest of the library.
21:07:59 <rerecord> okay
21:08:10 <geekosaur> lambdabot doesn't really let you define things that way. ghci, you'd need a `let` in there but it should work
21:08:29 <geekosaur> mcgrathj, exactly. and this design *cannot* enforce that
21:08:36 * lispy mumbles about multiline input in ghci
21:08:47 <prooftechnique> Yeah, I know, but for some reason it's not playing nice
21:08:56 <prooftechnique> lispy: I know I can, I was just trying to make lambdabot do it
21:09:08 <prooftechnique> So I was trying to work out the right one-liner
21:09:33 <rerecord> c_wraith: but why did it give me a runtime error instead of compiletime?
21:09:36 <geekosaur> perhaps worse than the problems with inlining etc. is that this exposes far too much internals in ways that you have no hope whatsoever of preventing the user from doing bad things
21:09:57 <mcgrathj> geekosaur: could you elaborate?
21:10:26 <geekosaur> um? the most you can do is throw a runtime exception if the user does things in the wrong order
21:10:33 <prooftechnique> Oh, I think it just didn't like the where clause
21:10:53 <geekosaur> if you design a monadic interface correctly, they *can't* use it without setting it up right
21:10:57 <mcgrathj> Ah, I see. Okay.
21:11:59 <mcgrathj> Okay. Now supposing I use a MonadReader constraint. Won't the user have to do a lift somewhere (if they want to user their own MonadReader as well) due to functional dependencies on MonadReader?
21:12:13 <mcgrathj> So I'd require a MonadReader ClientState
21:12:22 <mcgrathj> monad
21:12:40 <c_wraith> rerecord: because (^) only fails on negative exponents, and negative and positive numbers are the same type.  It's beyond the ability of haskell's type system to check that.
21:12:50 <geekosaur> you might want to take a look at some of the resource libraries on hackage --- for example, database interfaces will enforce connection to a database before using them and automatically shutting down the database connection when done
21:13:14 <mcgrathj> good suggestion: thanks
21:13:35 <lispy> It's interesting that we have Integer but no corresponding Natural
21:13:43 <lispy> And we have Word to match Int
21:13:57 <geekosaur> more generally there is ResourceT that lets you abstract access to resources, although it may be more abstract than you
21:14:02 <geekosaur> 'd perhaps like :)
21:14:17 <startling> most monad transformers are more abstract than me.
21:15:34 <lispy> startling: which monad transformers are not more abstract than you?
21:16:34 <danharaj> IdentityT
21:16:41 <startling> lispy, IdentiT
21:17:12 <startling> oh dang danharaj made the joke before me
21:17:23 <startling> MaybeT. I contain multitudes.
21:17:48 <mcgrathj> geekosaur: Thanks for the insights. That was very helpful.
21:40:09 <mcgrathj> geekosaur: I do see the problem with my implementation. But I do think that there is value in making the code accesible to a wider audience. For that reason, I like having only a MonadIO constraint. If I added a monad reader, it would become marginally more complex. But then there's the other side of it where I need to be able to catch an exception in the IO monad, so there can't be another MonadError underneath in the mo
21:40:09 <mcgrathj> that leads me to thinking that I should provide a concrete monad (not transformer) and use GeneralizedNewtypeDeriving to get MonadIO, MonadError, etc. back.
21:40:51 <mcgrathj> Overall this feels like quite a bit of pain to get data in the right place. I saw some stuff about implicit parameters, but I don't think that'd make the API any easier to understand, given that noone seems to use them.
21:43:08 <mcgrathj> I do, however, agree that it's incredibly valuable to have all of this sorted out while typechecking.
21:43:52 <mcgrathj> Maybe I should just accept a tiny amount of boilerplate?
21:44:50 <mcgrathj> Make requestToResponse explicitly take what would be the reader state, and then suggest wrapping that up in a let.
21:47:21 <mcgrathj> Although I think then I'd run into problems related to let bindings being monomorphic. Oof!
21:47:54 <foozbaz> how would one convert a DiffTime to a Float?
21:51:29 <mcgrathj> Correction, an explicit type signature is enough to avoid monomorphism there.
21:52:44 <mcgrathj> :t realToFrac
21:52:49 <lambdabot> (Fractional b, Real a) => a -> b
21:53:03 <mcgrathj> :i DiffTime
21:53:21 <mcgrathj> :i Float
21:54:30 <mcgrathj> foozbazz: DiffTime is an instance of Fractional, and Float is a member of Real, so you should be able to use realToFrac.
21:55:40 <mcgrathj> Notice, however, that realToFrac can give you back any Fractional, so you may need to specify which one you want (e.g. if dt :: DiffTime) you could do something like (realToFrac dt) :: Float
21:55:57 <mcgrathj> sorry, realToFrac can convert to any Real
22:10:47 <poxy> is there a more precise floating point Num type than Double?
22:10:55 <carter> rational :)
22:11:02 <poxy> not what I had in mind :)
22:11:03 <carter> poxy: the ieee spec has  some
22:11:04 <jmcarthur> rational != floating point
22:11:09 <carter> true :)
22:11:11 <carter> i troll
22:11:18 <carter> poxy: theres "Quads"
22:11:24 <carter> @hackage compensated
22:11:27 <carter> does it
22:11:31 <carter> well
22:11:34 <carter> is one appraoch
22:11:43 <startling> You could do floating-point rationals.
22:12:04 <jmcarthur> there's also CReal, which is not really floating point, and really slow
22:12:30 <frx> Decimal?
22:24:28 <lispy> CReal, Decimal, what's the point? get it?
22:28:57 <carter> @hackage compensated
22:29:05 <carter> gah lambdabot is down
22:29:37 <startling> elliott is down too
22:31:49 <carter> oh
22:31:51 <carter> its his?
22:32:03 <carter> http://www.meetup.com/Haskell_For_Cats/
22:32:09 <carter> new beginner haskel meetup in nyc
22:36:05 <startling> he was running lambdabot recently. I guess I don't know if he still does.
22:36:22 * startling has been away for some time
22:37:02 <carter> i know nothing
22:37:06 <carter> i just lurk here all daylong
22:37:07 <carter> afk
22:37:08 <carter> afk
22:37:14 <carter> hacking away
22:37:16 <carter> hehe
22:38:59 --- mode: ChanServ set +o Cale
22:39:14 <Cale> hm
22:39:23 <Cale> startling: It's int-e now
22:42:21 <startling> Cale: oh. good to know
22:42:40 <startling> carter: I do that sometimes but then it becomes an excuse for procrastination.
22:42:58 <carter> startling: which?
22:43:36 <startling> carter: lurk here; but then my involvement steadily climbs.
22:43:46 <Cale> smilefreak: Fix your connection please
22:44:01 <carter> startling: true
22:45:32 <Twey> So, I'm trying to write a program using vinyl-gl, but when I run it I get an exception: Shader info log for 'etc/cube.vert':
22:45:55 <Twey> ^@^A *** Exception: Cannot decode byte '\xa0': Data.Text.Encoding.Fusion.streamUtf8: Invalid UTF-8 stream
22:46:34 <carter> did you file a bug report with your example?
22:46:34 <startling> Twey, do you have a shader with that name?
22:46:43 <Twey> I do, and it's purely ASCII
22:47:03 <Twey> carter: Not yet; I wanted to check it's actually a bug and not me being stupid somewhere :þ
22:47:12 <carter> Twey: well
22:47:18 <carter> share the source first :P
22:47:38 <startling> ^
22:47:44 <lpaste> Twey pasted “Broken Cube” at http://lpaste.net/95742
22:48:12 <carter> i need to learn shaders
22:48:12 <startling> can you add etc/cube.vert too?
22:48:14 <carter> don't know em now
22:49:02 <Twey> startling: Yep, I annotated it
22:51:07 <Twey> (the ^@^A is not a paste artifact: it shows that before raising the exception)
22:51:29 <startling> Twey, it does seem like your file does not contain \xa0
22:51:50 <Twey> Indeed
22:52:00 <Twey> And it certainly doesn't contain ^@
22:53:40 <derekv> I was slightly hoping that, if i used the record syntax i could just sortof derive ToJSON with out writing the encode function
22:59:57 <startling> derekv, there's Data.Aeson.Generic but it's deprecated and the replacement isn't out yet
23:00:30 <levi> Why's it deprecated?
23:00:35 <startling> oh, no, the docs lie; look at Data.Aeson.TH
23:00:55 <startling> levi, for Data.Aeson.TH, apparently
23:07:43 <benzrf> hmm
23:08:30 <derekv> startling: looking thanks
23:22:30 <derekv> startling: it is a good thing.
23:23:47 <startling> derekv: I'm glad. :)
23:26:15 <derekv> i guess tommorow i can play about with persistent and then before long i'll be making an app
23:34:31 <benzrf> hi
23:35:39 <benzrf> as was suggested in passing to me earlier, i'm writing a sokoban game to get more acclimated to hs
23:35:54 <benzrf> this is what i've got so far:
23:35:57 <benzrf> http://lpaste.net/95746
23:36:10 <benzrf> any tips on how to improve it, or any major code smells you see?
23:36:25 <benzrf> i'm really, REALLY new to writing anything more than 10-line programs
23:38:01 <startling> benzrf, the lack of comments is a big one
23:38:19 <benzrf> i uh
23:38:27 <benzrf> not good about writing comments
23:38:41 <benzrf> amaof i don't think ive written more than 25 in the last year
23:39:33 <startling> benzrf, "\y -> cell x y" is "cell x"
23:40:08 <startling> benzrf: pattern-matching on Just/Nothing is kind of unnecessary. toChar = fromMaybe ' '.
23:40:22 <benzrf> derp
23:40:27 <benzrf> ah, ok
23:40:34 <benzrf> is fromMaybe in prelude?
23:41:10 <startling> Data.Maybe (it is in base). you can do "maybe ' ' id" instead; 'maybe' is in the Prelude
23:41:50 <startling> I have no idea what 'merge' does.
23:42:14 <benzrf> it takes two lists of maybes, then mappends them as lasts
23:43:01 <startling> :t zipWith (<|>) `asAppliedTo` Nothing
23:43:04 <benzrf> so [Just 1, Nothing, Just 3] with [Just 2, Just 4, Nothing] -> [Just 2, Just 4, Just 3]
23:43:10 <benzrf> don't know anything about that :|
23:43:38 <startling> ugh, we're lambdabotless
23:43:42 <benzrf> what does asAppliedTo do?
23:43:51 <startling> it just makes the types concrete
23:44:01 <startling> :t zipWith (<|>)
23:44:02 <startling> zipWith (<|>) :: Alternative f => [f a] -> [f a] -> [f a]
23:44:17 <benzrf> well it is basically zipWith mappend
23:44:27 <benzrf> except that I put them into Last and take them out
23:44:44 <benzrf> is the Alterantive behavior for Maybe the same as Last ?
23:44:48 <startling> benzrf: yep.
23:44:51 <benzrf> ah
23:44:55 <benzrf> well i didn't know that >.>
23:44:56 <startling> > zipWith (<|>) [Just 1, Nothing, Just 3] [Just 2, Just 4, Nothing]
23:44:57 <startling> [Just 1,Just 4,Just 3]
23:45:18 <benzrf> no\
23:45:19 <startling> benzrf: sure, that's why you asked. :)
23:45:20 <benzrf> it looks like First
23:45:29 <startling> oh, I'm wrong.
23:45:47 <benzrf> I want last so that they'll be layered in the order i give them
23:45:50 <startling> sorry about that !
23:45:54 <benzrf> i guess i could just reverse it, then use <|>
23:46:18 <startling> yeah, flip (zipWith (<|>)) or zipWith (flip (<|>))
23:46:37 <benzrf> the latter looks clearer to me
23:46:49 <benzrf> also i need to start writing unit tests
23:46:50 <benzrf> ._.
23:46:57 <startling> benzrf, it may be more convenient to import Data.Set (Set) too
23:47:09 <benzrf> oh?
23:47:14 <benzrf> ah
23:47:15 <startling> it's such a pain to write Set.Set everywhere.
23:47:26 <startling> that's up to you, though.
23:47:31 <benzrf> yes, that seems good
23:47:52 <benzrf> where's alternative located?
23:48:04 <startling> Control.Applicative
23:48:09 <benzrf> Oh huh
23:49:09 <startling> it's not clear what gridFor does.
23:49:29 <startling> oh, I see.
23:49:32 <benzrf> hmm
23:49:38 <benzrf> i should probably make it more generic
23:49:43 <benzrf> let it take things besides chars
23:49:56 <startling> yeah, that's true.
23:50:13 <benzrf> done
23:50:26 <benzrf> should I keep using column & cell, or is there a cleaner way/
23:50:41 <benzrf> oh wait
23:51:02 <benzrf> map (map cell [height]) [width]
23:51:03 <benzrf> ?
23:51:50 <augur_> are there methods for doing nested interaction?
23:51:51 <startling> it's such a shame there's no (Num a, Num b) => Num (a, b) instance.
23:52:01 <startling> benzrf, not sure what you mean.
23:52:04 <benzrf> i know, right
23:52:09 <benzrf> nvm
23:52:11 <benzrf> im doing it right now
23:52:25 <augur_> startling: its a shame classes are closed
23:52:42 <benzrf> soko.hs:16:13:
23:52:43 <benzrf>     Couldn't match expected type `[Maybe a]'
23:52:43 <benzrf>                 with actual type `[f0 a0] -> [f0 a0] -> [f0 a0]'
23:52:43 <benzrf>     In the expression: zipWith $ flip (<|>)
23:52:43 <benzrf>     In an equation for `merge': merge a b = zipWith $ flip (<|>)
23:52:49 <benzrf> ?
23:53:09 <startling> benzrf, you need to do merge = zipWith $ flip (<|>)
23:53:30 <benzrf> i did that
23:53:42 <startling> your error claims you didn't.
23:53:43 <benzrf> oh wait
23:53:43 <benzrf> derp
23:53:46 <startling> :)
23:53:58 <benzrf> boy i feel silly
23:54:46 <benzrf> do you know a better way to build the grid than using column & cell?
23:54:58 <benzrf> like is there a 2d map function, or a more concise way?
23:55:05 <startling> benzrf, grids = zipWith (gridFor w h) "#0." [walls, crates, targets], I think
23:55:21 <startling> benzrf, this way strikes me as sane.
23:55:46 <benzrf> dur
23:55:59 <benzrf> i never think of using zipWith on a curried function
23:56:00 <benzrf> :I
23:56:37 <startling> "zipWith f a b = map (uncurry f) $ zip a b", or something
23:57:03 <startling> oh, I see what you mean
23:57:20 <startling> I think "partially-applied" is the right phrase for this.
23:57:25 <benzrf> rightq
23:57:26 <benzrf> (right
23:57:30 <startling> all functions are curried. :)
23:57:37 <benzrf> i know, wrong word choice
23:57:37 <benzrf> ;p
23:57:55 <benzrf> is there something like
23:58:03 <benzrf> Bool -> a -> Maybe a
23:58:11 <startling> what does it do?
23:58:23 <benzrf> takes a bool & an a, false -> nothing, true -> just a
23:58:43 <startling> I guess not.
23:58:58 <benzrf> i just thought the if looked a little long
23:58:59 <benzrf> w/
23:58:59 <benzrf> e
23:59:48 <startling> yeah. it's a shame there's not an "if" function in the Prelude
