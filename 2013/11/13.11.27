00:00:25 <adrian_berg> scott_: That was it, thank you very much
00:03:15 <fxr> hi, is type checking for GADTs decidable and complete? Can we define "typecheck :: String -> T a" ? Can we make it automatic?
00:13:19 <supki> fxr: what's T?
00:14:03 <fxr> supki: a type in a typed world
00:14:44 <fxr> which is surely a GADT
00:17:17 <supki> fxr: I don't think there is any hope to define  :: String -> T a  say,  data T a where A :: T Int
00:17:19 * hackagebot OpenAFP-Utils 1.4.1 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.4.1 (AudreyTang)
00:17:19 * hackagebot OpenAFP-Utils 1.4.1.1 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.4.1.1 (AudreyTang)
00:17:42 <supki> fxr: which is a GADT where you can't return non-bottom  T a
00:22:12 <fxr> @hoogle gcast
00:22:12 <lambdabot> Data.Typeable gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
00:22:13 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
00:22:13 <lambdabot> Data.Typeable gcast2 :: (Typeable2 t, Typeable2 t') => c (t a b) -> Maybe (c (t' a b))
00:22:13 * hackagebot indexed-free 0.3.1 - indexed monads for free  http://hackage.haskell.org/package/indexed-free-0.3.1 (FumiakiKinoshita)
00:22:33 <fxr> hmp
00:22:44 <bartavelle> let's say I'd like to write a data type that would represent actions in a monad, so that I could write arbitrary instances and check my monads property with QuickCheck. Is that possible ? What should I look for to do that ?
00:24:30 <hamid> :t concatMap
00:24:31 <lambdabot> (a -> [b]) -> [a] -> [b]
00:31:59 <alpounet> bartavelle: do you have a precise monad in mind?
00:32:04 <bartavelle> RWS
00:32:46 <pyr> bartavelle: hi
00:32:49 <bartavelle> I am rewriting a version that has the writer part hidden in state, so that it doesn't mappend at every bind, and would like to compare it with the original version
00:32:52 <bartavelle> hey pyr :)
00:32:59 <pyr> bartavelle: great job on language-puppet
00:33:14 <bartavelle> thanks, I believe you are (will soon be) my only user :)
00:33:38 <pyr> I was wondering what your current use case is
00:33:47 <pyr> maybe there's a better channel for this
00:34:03 <bartavelle> /msg then
00:35:13 <alpounet> bartavelle: so you'd like to have something that kind of models the different actions in your monad, and test properties on this? something with several constructors, like Get, Put, Ask, stuffs like that?
00:36:20 <bartavelle> exactly
00:36:32 <fizruk> free monads!
00:36:36 <bartavelle> but I am sort of stuck with how to "bind" the actions in an arbitrary way
00:37:08 <bartavelle> I'm ok with having RWS Int Int Int or something really restricted so that I could spawn arbitrary functions between the elements
00:37:17 <alpounet> bartavelle: take the free monad of some base type describing the different actions, yes, as fizruk suggests that may do what you want
00:37:30 <bartavelle> I'll look at this, thanks
00:37:42 <fizruk> bartavelle, here's a talk on free monads: http://skillsmatter.com/podcast/home/monads-for-free/te-8320
00:39:04 <alpounet> bartavelle: a bit like how ThreadF is Gabriel's base type for his cooperative thread post: http://www.haskellforall.com/2013/06/from-zero-to-cooperative-threads-in-33.html
00:43:35 <bartavelle> ah
00:46:38 <Flonk> If I want to make String an instance of something I need -XFlexibleInstances and -XTypeSynonyms, however hugs 98 doesn't recognize these (all?) language extensions
00:48:05 <fizruk> Flonk, newtype MyString = MyString String ?
00:48:19 <Flonk> Hmm
00:48:31 <Flonk> fizruk: I don't think I can do that, its for an assignment
00:49:08 <Iceland_jack> Flonk: Does your assignment explicitely require you to make String an instance of something?
00:49:12 <fizruk> Flonk, are you sure you need type synonym instance for an assignment?
00:50:06 <Iceland_jack> *explicitly
00:50:23 <Flonk> Iceland_jack: Yep, just checked
00:50:35 <Flonk> Make String an instance of ... which behaves like ...
00:50:54 <Flonk> fizruk: I usually try to get it running on my end and then fix it on the uni servers
00:51:07 <Iceland_jack> That is a poor choice for an assignment
00:51:31 <fizruk> Flonk, perhaps an instance for [a] will do?
00:51:36 <Flonk> Iceland_jack: Most of them are
00:51:45 <Iceland_jack> Not true
00:51:48 <Flonk> fizruk: Nah I can't, because it involves the letters aeiou
00:52:01 <fizruk> oh...
00:52:02 <Iceland_jack> What is the requirement, exactly
00:53:00 <Flonk> We have this class called SimNf that can check if two things are similar (a->a->Bool) and can turn one into its "normal form" (a->a)
00:53:15 <Flonk> Now two strings are similar if they have the same number of vowels
00:53:52 <Iceland_jack> I would wrap it in a newtype and be done with it
00:53:54 <fizruk> I'd definitely used a newtype for that
00:54:32 <fizruk> s/used/use/
00:54:33 <Flonk> I can't though, because they just check against a couple of test cases
00:55:01 <Iceland_jack> Flonk: http://stackoverflow.com/questions/5941701/why-can-i-not-make-string-an-instance-of-a-typeclass http://stackoverflow.com/questions/15285822/cant-make-string-an-instance-of-a-class-in-haskell
00:55:07 * fizruk thinks of Show instance for String...
00:56:07 * Iceland_jack . o ‚∏® another Hugs ‚∏©
00:57:10 <Flonk> Iceland_jack: Hmm yes, I know..
01:17:40 <solrize> http://www.haskellcast.com/episode/004-simon-marlow-on-parallelism-and-concurrency  can anyone see if this has a video, or is it audio-only?  i don't have flash so can't view it if it's video, but i can't tell
01:17:41 <solrize> thanks
01:17:53 <Iceland_jack> It has a video
01:18:00 <solrize> thanks
01:18:08 <solrize> i wish they'd put it in the rss
01:18:32 <Itkovian> meuning
01:18:47 <solrize> ?
02:10:01 <BoR0> is there any free haskell web service like herokku for happstack?
02:12:10 <t7> i think you can run arbitrary 64bit linux binaries on herokku
02:12:59 <zol> I want to iterate over a list but have access to the previous element in the list for each next step. Is there a function that provides this?
02:13:37 <zol> I have a list of chords, [C,C,F,G,E,E,B,C], and I need to iterate over them to create the next chord, but the next chord depends on the previous chord played.
02:14:13 <frihd_> zol, you may want to zip a list with a "shifted" list
02:14:33 <frihd_> which gives you a list of (chord, prev)
02:14:39 <zol> frihd_: Oh.., that's a wonderful idea! :')
02:14:50 <zol> Thanks, that should probably do it!
02:14:54 <frihd_> welcome
02:15:07 <BoR0> very elegant, will zip x $ tail x do the job?
02:15:16 <BoR0> or did you have something else in mind?
02:16:18 <frihd_> something like zip x (drop 1 x) to avoid partiality, then you have to check what to do with the 1st element (because there is no predecessor)
02:16:32 <BoR0> or even zip [1,2,3] $ 0:[1,2,3] ?
02:18:30 <BoR0> @src zip
02:18:30 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
02:18:30 <lambdabot> zip _      _      = []
02:19:07 <frihd_> BoR0:  there are multiple designs possible, you can wrap the "ancestor" with a Maybe if it makes sense to do so
02:20:47 <BoR0> that's even better
02:22:23 * hackagebot GLUT 2.5.0.2 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.5.0.2 (SvenPanne)
02:23:08 <frihd_> well it's better if you want to provide an API with such a function; if your program skips the first data point anyway.. you may not want to pay the cost of wrapping/dewrapping a maybe
02:30:15 <BoR0> is there a more elegant way to do Just (maxBound::Chords) instead of doing maksimum = maxBound::Chords and then just maksimum?
02:30:44 <BoR0> Just maksimum*
02:42:27 <Feuerbach> Just (maxBound::Chords) looks fine to me
02:42:47 <Feuerbach> you could also say Just maxBound :: Maybe Chords
02:44:18 <Feuerbach> of course you can omit the signature at all if the type can be inferred from the context (which seems rather likely)
02:46:42 <andkore> Why doesn't this work? plusOne [a] = map (+1) [a] plusOne [] = []
02:47:25 <andkore> I get Non-exhaustive patterns in function plusOne
02:47:58 <haasn> andkore: first of all, separate definitions need to be separated by newlines or semicolons or something; next, that's a partial definition, [a] is a pattern match on a list with exactly one element
02:48:00 <haasn> [] is a pattern match on a list with zero elements
02:48:02 <haasn> but there's no pattern for lists with 2 or more elements
02:48:05 <haasn> plusOne [a] = [a+1] -- equivalent to your definition
02:49:06 <andkore> haasn: yes, I didn't know how to represent a newline in IRC
02:49:19 <andkore> ah, don't know how I overlooked that, thanks
02:49:49 <andkore> how can I pattern match a list?
02:51:46 <haasn> andkore: (x:xs) is the pattern you're probably interested in. roughly speaking, data [a] = [] | a : [a] -- if this was legal haskell
02:52:08 <fizruk> > let f [x, y, z] = x + y + z; f _ = 0 in f [1, 2, 3]
02:52:09 <lambdabot>   6
02:52:12 <haasn> in words: a list is either an empty list [], or an element (of type a) prepended to a list of a's
02:52:14 <andkore> thanks haasn
02:52:19 <haasn> @src map
02:52:19 <lambdabot> map _ []     = []
02:52:19 <lambdabot> map f (x:xs) = f x : map f xs
02:53:53 <andkore> plusOne a = map (+1) a <-- works as I wanted it to
02:54:06 <andkore> I guess I really was just worried "how would haskell know that a has to be a list"
02:54:33 <haasn> andkore: because of ‚Äòmap‚Äô
02:54:36 <haasn> :t map
02:54:36 <lambdabot> (a -> b) -> [a] -> [b]
02:54:39 <andkore> right
02:54:43 <haasn> its second parameter has type [a], so your ‚Äòa‚Äô does too
02:54:54 <andkore> plusOne :: Num b => [b] -> [b]
02:55:01 <andkore> so that's inferred
02:55:02 <haasn> note that your [] case is redundant if you define it like that
02:55:07 <haasn> since map already handles [] correctly
02:55:10 <andkore> right
02:55:18 <andkore> thanks so much man
02:55:19 <haasn> also, that can be eta-reduced: plusOne = map (+1)
02:56:24 <andkore> wow, that's much more elegant
02:57:41 <andkore> well I better get some sleep. I have some C#/ASP.NET to write tomorrow at work... *shudder*. thanks again haasn.
03:00:55 <tarruda> After last update, cabal-install is no longer generating the HS*.o file for a library project(for loading into ghci)
03:01:02 <tarruda> anyone had the same problem?
03:08:19 <Maxdamantus> if *a* monoid is a set of values, say, String (assuming a type is a set of values), an associative operation, say (++) {- a.k.a. mappend -} :: String -> String -> String and an identity value for it, say "" (a.k.a. mempty), what is *a* functor?
03:09:14 <Maxdamantus> is it a type constructor, like `IO', or an fmap implementation, like `fmap :: (a -> b) -> IO a -> IO b', or .. ?
03:10:29 <bergmark> Maxdamantus: i'd say that a type can be a monoid, so a type could also be a functor
03:10:48 <supki> Maxdamantus: functor is a type constructor F :: * -> *, mapping function :: (a -> b) -> (F a -> F b), and a set of laws
03:10:51 <Maxdamantus> bergmark: but the type can't be a monoid, because the type alone says nothing of the other two things.
03:11:21 <Maxdamantus> (you need something like a Monoid instance to say what the monoid actually is)
03:11:27 <Feuerbach> Maxdamantus: it'd help if you distinguish the mathematical monoid/functor and the Haskell one
03:11:45 <ion> When people say ‚ÄúFoo is a Monoid‚Äù or ‚ÄúFoo is a Functor‚Äú, that‚Äôs shorthand for ‚Äúis an instance of‚Äù. For a more rigorous definition of ‚Äúis a functor‚Äù, what supki said.
03:11:55 <Maxdamantus> I'm trying to understand the connection between the two.
03:12:27 * hackagebot haskell-names 0.3.2 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.2 (RomanCheplyaka)
03:12:56 <bergmark> Maxdamantus: sure, there can be several instances for a type class, but colloquially you say "String is a Monoid" because there is a standard implementation
03:14:22 <Maxdamantus> supki: so when Wikipedia describes a functor as something like a mapping between categories, in Haskell, the corresponding mapping is between the categories represented by `a -> b' and `F a -> F b'?
03:15:30 <ion> Haskell Functors are always endofunctors from the category Hask to the category Hask.
03:15:56 <Maxdamantus> bergmark: yeah, that's why I tried to give a more precise connection between monoids and Monoid.
03:17:58 <Maxdamantus> (where a Monoid instance defines a monoid by specifying the set of values (inherent given the type), and the operator and other value that obey the monoid laws)
03:17:58 <ion> where Hask is the category with Haskell types as objects and Haskell functions as arrows
03:17:58 <Maxdamantus> (rather than saying that some type is a monoid because it has a Monoid instance)
03:18:34 <bergmark> Feuerbach: what does "Annotate QNames in export lists" mean?
03:19:58 <supki> Maxdamantus: well, yes, you need to map objects (that's what type constructor does) and morphisms (that's what fmap does)
03:20:30 <Maxdamantus> and the categories in Haskell's fmap just happen to be limited for some reason?
03:20:50 <Feuerbach> bergmark: previously, QName inside e.g. EVar was annotated as Export. Now it's annotated with GlobalValue (but EVar itself is still annotated with Export)
03:20:55 <arkeet> haskell doesn't have much of a way of talking about categories in general.
03:21:25 <arkeet> the notion of a functor is much more general than a haskell Functor.
03:21:40 <bergmark> Feuerbach: ok, thanks!
03:22:15 <Maxdamantus> Right. So a less Haskellish Functor class might be: class Functor a b where map :: a -> b ?
03:22:37 <arkeet> that doesn't look functorish at all.
03:23:09 <Maxdamantus> Well, each Functor instance defines a mapping between some categories `a' and `b'.
03:23:20 <arkeet> those aren't categories.
03:24:43 <bergmark> Feuerbach: i want hackage to recognize CHANGELOG.md :) i use it for fay as well
03:24:57 <arkeet> one generalization might be
03:25:10 <ion> Something like fmap :: (a ‚Üí‚ÇÄ b) ‚Üí‚ÇÅ (F a ‚Üí‚ÇÇ F b) where ‚Üí‚ÇÄ is from the category of the objects a and b, ‚Üí‚ÇÅ is from the category of functions and ‚Üí‚ÇÇ is from the category of the objects F a and F b.
03:25:52 <arkeet> class (Category c, Category d) => Functor c d where map :: c a b -> d a b
03:26:14 <arkeet> but Category isn't a general category.
03:26:16 <arkeet> er
03:26:33 <Feuerbach> bergmark: http://beta.hackage.haskell.org already does (yay!), but the main hackage instance is not updated yet
03:26:38 <arkeet> also that gives you no way of expressing different functors between the same pair of categories.
03:26:42 <arkeet> so it's not so much like a clsas.
03:26:43 <arkeet> class
03:27:19 <bergmark> Feuerbach: oh awesome!
03:27:44 <bergmark> http://beta.hackage.haskell.org/package/fay :<
03:29:04 <Maxdamantus> Okay.
03:36:50 <ReinH> Maxdamantus: so I guess you aren't accepting that a Functor is an endofunctor on Hask?
03:37:15 <ion> Let‚Äôs rename Functor to HaskEndofunctor
03:37:56 <Maxdamantus> ReinH: I think I might be able to accept that.
03:37:59 <ReinH> that maps objects (values) to objects and arrows (functions) to arrows?
03:38:17 <Maxdamantus> well, that `fmap' is an endofunctor ..
03:38:30 <Maxdamantus> (each fmap instance is)
03:38:39 <ReinH> yes, "a Functor" :)
03:39:05 <ReinH> :t fmap
03:39:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:40:19 <BoR0> I have a program that does getLine and reads into [Int], so that works great, user can input [1,2,3] and it works fine. but in what way can I do so that the user has to input {1,2,3} instead of [1,2,3] ? how can I parse stuff like this?
03:40:47 <ion> bor0: Parsec for instance.
03:40:57 <BoR0> but once the user inputs {1,2,3} I want it to be an ordinary [Int] within my haskell program
03:41:18 <BoR0> okay, I'll check that out, thanks
03:43:48 <ion> You can use integer from http://hackage.haskell.org/package/parsers-0.10.1.1/docs/Text-Parser-Token.html
03:44:29 <Maxdamantus> or you could just copy GHC's implementation of Read a => reads :: ReadS [a] and replace the "["s with "{"s.
03:44:31 <tdammers> alternatively, if you stick with JSON, you can try aeson
03:44:32 <Maxdamantus> Presumably.
03:44:41 <fizruk> > let f '{' = '['; f '}' = ']'; f c = c in read (map f "{1, 2, 3}") :: [Int]
03:44:42 <lambdabot>   [1,2,3]
03:44:50 <Maxdamantus> or do that.
03:44:55 <tdammers> Maxdamantus: parsec is easier than Read though
03:45:05 <ion> Something like numbers :: Parser [Integer]; numbers = braces (integer `sepBy` comma)
03:45:17 <BoR0> ion, I managed to do it with something like parseSquareBrackets (x:xs) = (if x == '{' then '[' else if x == '}' then ']' else x):parseSquareBrackets xs ; parseSquareBrackets x = x
03:45:23 <BoR0> is this the correct way?
03:45:29 <ion> numbers :: Parser [Integer]; numbers = braces (commaSep integer)
03:45:40 <BoR0> ah, fizruk already posted something more elegant
03:45:51 <ion> bor0: Parsec would give nicer error messages.
03:46:18 <BoR0> Prelude.read: no parse will do it for me, this is just experiments. but I will also take a look at Parsec
03:46:30 <fizruk> BoR0, it's okay if you want just that and nothing more complex. for complex input use parsec or similar
03:46:40 <BoR0> excellent! thanks
03:50:12 <BoR0> how elegant is this? http://lpaste.net/96278 (based on chords example that some guy asked here before)
03:50:38 <BoR0> basically it takes a list of chords and increases the element before last, and appends it to the list
03:51:14 <fizruk> I don't like nested where clauses
03:51:46 <BoR0> ah right, updated the paste
03:52:44 <BoR0> is there a way to avoid chordsucc? somehow to make the Enum circular or something like that
03:54:36 <fizruk> BoR0, getPreviousElement is just picks one but last element in a list?
03:54:43 <fizruk> :t butLast
03:54:44 <lambdabot>     Not in scope: `butLast'
03:54:44 <lambdabot>     Perhaps you meant `getLast' (imported from Data.Monoid)
03:55:28 <fizruk> :t last . init
03:55:28 <lambdabot> [c] -> c
03:58:28 <fizruk> BoR0, btw I'd input chords just as C A D G (i.e. without any delimiters)
04:03:03 <fizruk> > let f xs@(_:_:_) = Just (xs ++ [succ . last . init $ xs]); f _ = Nothing in f ['A', 'B', 'C', 'E'] -- BoR0
04:03:04 <lambdabot>   Just "ABCED"
04:04:05 <ReinH> all these partial functions make me sad
04:04:59 <fizruk> they just should not be partial
04:05:52 <donri> i'd rather have localized partiality like, make head return a Maybe and use fromJust if you have to
04:06:34 <donri> and then find = fmap head . findIndices etc, so we could have cleaner APIs
04:07:34 <fizruk> that would be great
04:07:39 <donri> uh filter, rather
04:07:48 <fizruk> some day...
04:08:39 <donri> i guess lens is one answer
04:09:00 <chrisdone> in #haskell, lens is always the answer
04:09:39 <donri> but as much as i like lens, it's quite the beast
04:09:43 <fizruk> donri, can I index one but last element of a list with lens? (I just don't know how)
04:10:24 <quicksilver> if you want to alter the last but one element of a list then possibly a list was the wrong structure
04:10:33 <ReinH> circleSucc :: (Enum a, Bounded a) -> a -> a; circleSucc maxBound = minBound; circleSucc a = succ a
04:10:59 <ReinH> with a => in the right place obv
04:11:06 <fizruk> ReinH, oh is it defined somewhere?
04:11:12 <ReinH> right there ^
04:11:18 <fizruk> I see
04:11:35 <donri> you can't pattern match on maxBound like that
04:11:48 <ReinH> fine
04:12:00 <ReinH> do something with Eq and guards then :p
04:12:13 <donri> why make it easy, do it with view patterns!
04:12:18 <ReinH> ha
04:12:39 <BoR0> fizruk, getPreviousElement [A,B,C] will pick B
04:12:43 <donri> circleSucc ((== maxBound) -> True) = minBound
04:12:54 <ReinH> yeah much better
04:13:33 <donri> too easy... wait for pattern synonyms!
04:13:57 <donri> pattern MaxBound -> ((== maxBound) -> True); circleSucc MaxBound = minBound
04:14:05 <BoR0> ReinH, is it bad to have partial functions? I thought it was in the philosophy of haskell, to make partial functions and glue them easily
04:14:21 <fizruk> BoR0, partially applied is not partial
04:14:33 <fizruk> BoR0, (1+) is partially applied
04:14:39 <fizruk> BoR0, head is partial
04:14:42 <donri> common misunderstanding, confused me too in the beginning
04:14:42 <fizruk> > head []
04:14:43 <lambdabot>   *Exception: Prelude.head: empty list
04:15:13 <fizruk> BoR0, partial ~ partially defined ~ not defined for some inputs
04:15:24 <ReinH> BoR0: nope, the opposite: to make total functions and glue them easily
04:15:45 <BoR0> I don't understand, by total function do you mean partial function that covers all input cases?
04:16:01 <donri> no, total function is the opposite of a partial function
04:16:01 <ReinH> a partial function does not, by definition, cover all cases
04:16:08 <merijn> BoR0: "total function" == always returns a result for all inputs
04:16:10 <donri> a partially *applied* function is something completely unrelated
04:16:14 <ReinH> a total function is a function that is not partial, i.e. that covers all input cases
04:16:18 <merijn> BoR0: "partial function" == a function that crashes on some inputs
04:16:20 <merijn> BoR0:
04:16:53 <merijn> "partially application/partially applied function" == a function that does not have all it's argument yet
04:17:03 <BoR0> okay, I got that. so in my code example, which functions are partially applied functions?
04:17:05 <merijn> s/partially application/partial application
04:17:06 <fizruk> BoR0, in my f implementation functions succ last and init are partial
04:17:16 * ReinH .oO All my functions are total... I just use a more enlightened definition of "defined" than you do.
04:17:38 <hpc> i define all my functions as bottom
04:17:40 <ReinH> BoR0: again, I am not talking about partially applied
04:17:59 <donri> ReinH: bottom is a member of every type, and some of my functions simply return the bottom member of the target type? :P
04:18:03 <ReinH> let's make sure we're clear on the differences
04:18:20 <merijn> BoR0: As fizruk showed how "head" is a partial function, for example
04:18:22 <merijn> > head [1]
04:18:23 <lambdabot>   1
04:18:26 <ReinH> donri: sometimes my bottom even comes with a handy note attached
04:18:28 <merijn> > head [] -- whoops, undefined case
04:18:29 <lambdabot>   *Exception: Prelude.head: empty list
04:18:33 <ReinH> like "head: empty list"
04:18:46 <donri> :P
04:18:54 <BoR0> ok, I think I get the distinction. if you were to rewrite my code http://lpaste.net/96278, what would you change?
04:19:42 <danr> BoR0: I would call the identifiers that are lists for xs, ys, ...
04:20:12 <BoR0> aha, right that is useful notation to follow
04:20:24 <danr> I wold pattern-match on '{' instead of using an if then else,
04:20:27 <fizruk> BoR0, I've given my version with partial functions above ^
04:20:30 <danr> probably with a case
04:20:41 <danr> to avoid repeating the long function name several times
04:20:42 <ReinH> You know, fmap probably should have been called mapF
04:20:46 <ReinH> for consistency
04:21:01 <hpc> maybe mapM should have been called mmap
04:21:06 <ReinH> maybe that
04:21:10 <hpc> that name totally isn't used for anything ;)
04:21:17 <donri> partial functions in that paste include: last, succ, read. that doesn't necessarily mean i'd change anything.
04:21:27 <danr> main = do { l <- getLine ; return (addChord (read (parseSquareBrackets l))) }
04:21:28 <BoR0> fizruk, ah yeah, saw that. I just wanted to use zip and 2 tuple approach (it was discussed before when some guy asked about chords), but yes your function looks far more elegant
04:21:29 <ReinH> nah it's available
04:21:41 <donri> ReinH: liftF? :)
04:22:01 <quicksilver> ReinH: erm? but mapM and fmap are not equivalent
04:22:10 <BoR0> wow danr! that looks awesome
04:22:13 <quicksilver> ReinH: fif you mean fmap should probablby have been called liftF?
04:22:22 <danr> BoR0: you can simplify your main by applying the monad laws. I would only write as you have done right now if I want a poetic effect
04:22:22 <ReinH> danr: isn't that... getLine >>= fmap addChord . read . parseSquareBrackets
04:22:32 <danr> not quite
04:22:37 <donri> i kinda wish fmap was called lift, liftA* were lift*, liftM* didn't exist and i guess monadtrans lift needs a new name
04:22:38 <danr> fmap (addChord . read . parseSquareBrackets) getLine
04:22:55 <BoR0> :)
04:22:57 <fizruk> BoR0, you don't need zips to get one but last element
04:23:14 <ReinH> addChord . read . parseSquareBrackets <$> getLine
04:23:34 <fizruk> BoR0, (last . init) is much simpler than your getPreviousElement
04:23:35 <hpc> donri: i can't imagine a sufficiently generic MonadTrans being pleasant to use
04:23:36 <BoR0> fizruk, I wanted to have the "previous" element for each element, so that I can easily grab the n-1 th element if I know the nth
04:23:46 <BoR0> in my case it specifically takes the element before the last
04:23:55 <donri> hpc: what's that got to do with naming?
04:24:00 <BoR0> I should generalize that too maybe
04:24:07 <ReinH> oh right, duh a >>= (return . f) = fmap f a
04:24:27 <danr> BoR0: why did you name Chords in plural?
04:24:42 <danr> not that I know much of music, but a value of Chords seems to be just one Note
04:24:43 <fizruk> > zip <*> (Nothing:) $ map Just [1..5]
04:24:44 <lambdabot>   [(Just 1,Nothing),(Just 2,Just 1),(Just 3,Just 2),(Just 4,Just 3),(Just 5,J...
04:24:51 <BoR0> :D that too
04:25:23 <fizruk> > zip <*> (Nothing:) . map Just $ [1..5]
04:25:24 <BoR0> ok, that looks beautiful as it is. but I don't know what <*> is
04:25:24 <lambdabot>   [(1,Nothing),(2,Just 1),(3,Just 2),(4,Just 3),(5,Just 4)]
04:25:26 <ReinH> zip <*> is amazing
04:25:30 <ReinH> fun for fibs
04:25:56 <fizruk> BoR0, second variant is nicer, I think
04:26:15 <BoR0> but it still uses <*>, what does that do?
04:26:27 <danr> BoR0: here, (f <*> g) x = f x (g x)
04:27:15 <fizruk> > let xs = [1..5] in zip xs (Nothing : map Just xs)
04:27:17 <lambdabot>   [(1,Nothing),(2,Just 1),(3,Just 2),(4,Just 3),(5,Just 4)]
04:27:33 <fizruk> BoR0, that should be cleaner ^
04:27:54 <ReinH> > let fibs = 0: 1 : (zipWith (+) <*> tail) fibs in take 10 fibs
04:27:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
04:27:58 <donri> fizruk: re your earlier question, the stuff in .Cons seems relevant
04:28:06 <donri> :t _last._init
04:28:07 <lambdabot> (Snoc (->) f s s a a, Snoc (->) f a a a1 a1) => (a -> f a) -> s -> f s
04:28:13 <fizruk> can help my point-free-fu sometimes
04:28:15 <iron_houzi> I tried to do the last example (triangle) from the first chapter in Learn you a haskell, but when I wrote it in a .hs file it wouldn't load into ghci, yet writing it directly into ghci worked fine. Why is it not possible to load it from a file?
04:28:35 <fizruk> donri, oh I totally forgot about .Cons!
04:28:39 <edoceo`> > let fibs = scanl1 (+) (0:1:fibs) in take 10 fibs
04:28:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
04:29:02 <donri> > [a,b,c,d] ^? _last . _init
04:29:04 <lambdabot>   No instance for (Control.Lens.Cons.Snoc
04:29:04 <lambdabot>                     (->)
04:29:04 <lambdabot>           ...
04:29:13 <donri> :(
04:29:18 <fizruk> :t _last
04:29:19 <lambdabot> Snoc (->) f s s a a => LensLike' f s a
04:29:25 <donri> > [0..9] ^? _last . _init
04:29:25 <lambdabot>   No instance for (Control.Lens.Cons.Snoc
04:29:26 <lambdabot>                     (->)
04:29:26 <lambdabot>           ...
04:29:39 <edwardk> > [a,b,c,d]^?_last
04:29:41 <lambdabot>   Just d
04:29:44 <edwardk> > [a,b,c,d]^?_init
04:29:47 <lambdabot>   Just [a,b,c]
04:29:49 <edwardk> > [a,b,c,d]^?_init._last
04:29:50 <lambdabot>   Just c
04:30:01 <ReinH> o_O
04:30:14 <edwardk> > [[a,b],[c,d],[e,f],[g,h]]^?_last._init
04:30:15 <lambdabot>   Just [g]
04:30:23 <edwardk> see the problem?
04:30:25 <edwardk> =)
04:30:28 <ReinH> heh
04:30:38 <ReinH> edwardk: helpful error message is helpful
04:31:22 <donri> edwardk: yes, the problem is i haven't had my morning coffee. i was trying to translate the wrong thing (init.last) which obviously should've been (last.init)
04:31:32 <edwardk> donri: =)
04:31:43 <ReinH> donri: you aren't thinking OOP enough
04:31:52 <donri> ReinH: i was!
04:31:55 <ReinH> :p
04:32:00 <donri> i did try to flip it over for sake of lens
04:32:03 <donri> but i was flipping the wrong thing
04:32:04 <donri> :P
04:32:48 <donri> :t init . last
04:32:48 <lambdabot> [[a]] -> [a]
04:33:02 <donri> :t init . last $ [a,b,c,d]
04:33:03 <lambdabot>     Couldn't match expected type `[a0]' with actual type `Expr'
04:33:03 <lambdabot>     In the expression: a
04:33:03 <lambdabot>     In the second argument of `($)', namely `[a, b, c, d]'
04:33:09 <donri> just to compare error messages ;)
04:33:31 <donri> pointless exercise with lambdabot cutting them off
04:33:45 <xenon-> can I make a lens that is both a setter and a getter?  I thought it would just work, but apparently not, it can be one or the other
04:33:58 <Cale> xenon-: Most lenses are?
04:34:06 <edwardk> xenon-: if it is both a Setter and a Getter, then it is a 'Lens' =)
04:34:19 <ReinH> edwardk: y u no make lens errors play nicely with simplereflect? :p
04:34:20 <edwardk> _2 f (a,b) = (,) a <$> f b  -- is a Lens.
04:34:45 <xenon-> well this did not work: foo lens obj = do print (view lens obj); return $ set lens "asdf" obj
04:34:58 <xenon-> "Expected type: ASetter s0 b0 a0 [Char] Actual type: Getting a0 s0 a0"
04:35:02 <edwardk> ReinH: um, the error message there is that Expr isn't an instance of Snoc. you could make it one if you want. then the error would go away =P
04:35:20 <ReinH> edwardk: :p
04:35:29 <edwardk> foo l obj = do print (view (cloneLens lens) obj); return $ set (cloneLens lens) "asbd" obj
04:35:36 <ReinH> edwardk: I am being completely unserious
04:35:37 <edwardk> you can do better though
04:36:24 <xenon-> cool that worked. why is that needed though?
04:36:28 <edwardk> foo l = l $ \a -> do print a; return "asbd"
04:36:37 <edwardk> notice that that version works in a single traversal
04:36:44 <edwardk> and works for traversals of multiple targets, not just one
04:36:45 <Cale> xenon-: The trouble is that you're taking a lens as a parameter. If you give your function an explicit type signature, and use the ALens type synonym or an explicit forall, then it'll work without cloneLens
04:36:53 <edwardk> because each use-site picked a different 'functor' for the lens
04:37:17 <Cale> xenon-: GHC will never infer a polymorphic type for any type variable.
04:37:19 <xenon-> ok I got it
04:37:32 <edwardk> Cale: he'd have to use Lens, not ALens. ALens was used by cloneLens case, but set and view pick different functors
04:37:47 <edwardk> there are combinators in Control.Lens.Loupe that all use ALens though
04:38:14 <Cale> oh, ALens isn't what I thought it was
04:38:34 <Cale> Yeah, nevermind, just use an explicit forall to make it polymorphic
04:38:46 <BoR0> how can I pattern match on maxBound :: Note? it throws compile error for noteSucc (maxBound :: Note), and for noteSucc maxBound it treats maxBound as variable
04:39:09 <Cale> BoR0: That's because maxBound is a variable there
04:39:14 <Cale> BoR0: Perhaps you want a guard?
04:39:15 <edwardk> xenon-: anyways that foo l = l $ \a -> do print a; return "asbd"   version would realy be the lensy way to write your function
04:39:35 <BoR0> Cale, yeah, that should be the way. I had it done with if then else if then else before
04:39:42 <edwardk> xenon-: you could write it as foo l = mapMOf l $ \a -> do print a; return "asbd"  if it makes you feel better ;)
04:39:55 <xenon-> edwardks thanks, i like it, now I just have to understand it. :)
04:40:26 <edwardk> xenon-: a lens takes Functor f => (a -> f b) -> s -> f t  -- there I'm choosing f = IO!
04:40:51 <edwardk> then just calling it
04:43:48 <xenon-> that makes sense
04:45:11 <robert__> hello. is there a usable higher level GUI library that works on linux/os x/win? something nicer than GTK
04:45:45 <lpaste> BoR0 revised ‚Äúchords fun‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/96278
04:46:19 <BoR0> http://lpaste.net/96278 is this more beautiful than it was before?
04:47:18 <donri> robert__: haven't used any of them but maybe reactive-banana-wx?
04:47:35 * hackagebot egison-tutorial 3.0.4 - A Tutorial Program for The Programming Language Egison  http://hackage.haskell.org/package/egison-tutorial-3.0.4 (SatoshiEgi)
04:50:14 <henk> I have trouble reaching projects.haskell.org via ipv6. Does anyone know who might care about that?
04:50:28 <merijn> henk: #haskell-infrastructure
04:50:41 <henk> merijn: thanks
05:09:22 <robert__> what name convention do you usually use for data fields and their corresponding lenses?
05:09:55 <ion> data Foo = Foo { _bar :: Bar }, bar :: Lens' Foo Bar
05:16:44 <tdammers> robert__: what ion said... it's what makeLenses defaults to
05:17:17 <tdammers> although I sometimes do: data Foo = Foo { _fooBar :: Bar }; fooBar :: Lens' Foo Bar
05:17:31 <tdammers> depends on the mood I'm in when I start the module
05:17:43 <ion> Oh, yeah, i do that too.
05:18:40 <chrisdone> what was the function to expand ~/foo into /home/user/foo in elisp?
05:19:36 <chrisdone> ahh
05:19:38 <chrisdone> expand-file-name
05:21:43 <tdammers> although recently, I do more of the import qualified Acme.Whatever.Foo as Foo; import Acme.Whatever.Foo (Foo), and *not* prefix record fields / lenses
05:22:02 <tdammers> so then I'd use Foo.bar instead of fooBar
05:22:28 <tdammers> this approach works fine with a lot of hackage packages too
05:22:36 <tdammers> e.g. Data.Text, Data.Map, etc.
05:23:38 <troydm> somebody switch off internetz
05:23:43 <troydm> *ed*
05:25:22 <albertid> say w00t
05:25:46 <albertid> what do they had in common?
05:26:26 <albertid> ah, they were all using irccloud
05:46:13 <Guest36821> What's the easiest way to read/parse a (POSIX) timestamp?
05:48:26 <donri> tdammers: we need syntax for this idiom! import type Data.Text (Text)  -- implicit "import qualified Data.Text as Text hiding (Text)"  :P
05:48:31 * donri not really serious but almost
05:49:54 <mm_freak_> Guest36821: Data.Time.Format may be helpful
05:50:40 <tdammers> well, some import syntax to do this kind of thing in a more DRY way would be nice, yes
05:52:00 <Guest36821> mm_freak_: do I really have to bother with a format string?
05:52:30 <mm_freak_> Guest36821: try a hackage search first
05:52:48 <mm_freak_> if it's common, it's most likely in some library
05:55:16 <xenon-> how to pull (Maybe a) out of (Maybe (Maybe a))?
05:55:26 <quchen> :t join -- xenon-
05:55:27 <lambdabot> Monad m => m (m a) -> m a
05:55:36 <quchen> > join (Just (Just 3))
05:55:37 <lambdabot>   Just 3
05:55:43 <quchen> > join (Just Nothing)
05:55:44 <lambdabot>   Nothing
05:55:48 <quchen> > join Nothing
05:55:49 <lambdabot>   Nothing
05:55:50 <xenon-> nice thanks
05:58:28 <Guest36821> posixSecondsToUTCTime 1385558081
05:58:30 <Guest36821> works
05:58:52 <Guest36821> but posixSecondsToUTCTime (read "1385558081") doesn't
05:59:03 <Guest36821> I'm missing something obvious I guess
06:13:54 <danilo2> Hello :) Could somebody help us with this issue please? We are trying to resolve it for couple of days but still without success :( https://github.com/twittner/zeromq-haskell/issues/8
06:13:59 <klrr_> i get an type error, i know why there is one but im not really sure how to solve it, i need move to be of type 'Event t (Int -> Int)' but now its of type 'Int -> Event t Int', anyone know how to solve that?
06:14:06 <bartavelle> if someone has a suggestions for this arbitrary instance of RWS actions, I am interested : https://github.com/bartavelle/stateWriter/blob/master/tests/rwscompare.hs
06:14:36 <donri> guest no Read instance for NominalDiffTime
06:14:50 <donri> Guest36821: ^
06:15:01 <bartavelle> I have been directed to the Free monad stuff, and while I see how it is useful to turn my data declaration into a full blown monad, I didn't see how it would help me write an Arbitrary instance
06:16:19 <donri> Guest36821: there's a Num instance though so try posixSecondsToUTCTime (fromInteger (read "1385558081"))
06:18:13 <klrr_> no one got an idea? y sure how to solve it, i  need move to be of type 'Event t (Int -> Int)' but now its of type 'Int -> Event t  Int', anyone know how to solve that?
06:18:16 <klrr_> ups
06:18:24 <klrr_> pasted by mistake sry
06:18:46 <klrr_> (X11 got that paste when you click middle mouse button, and im on a laptop atm which makes it too easy to do that)
06:20:45 <tdammers> disable middle click maybe?
06:21:46 <alpounet> bartavelle: there should be no "ActionF" in the components of your various actions. That's what the FreeT monad transformer does for you, it ties this up to itself, in some way
06:22:07 <bartavelle> ah !
06:22:18 <yitz> Guest36821: you can also use realToFrac instead of fromIntegral and parse your string as a Double. then fractional seconds are supported.
06:22:23 <alpounet> so you'd have type Action = FreeT ActionF
06:22:33 <ocharles> Hmm, http://mortoray.com/2013/11/27/the-string-type-is-broken/ GHC "fails" the first tests in that blog post
06:22:34 <ocharles> that is:
06:22:41 <ocharles> > reverse "no√´l"
06:22:42 <lambdabot>   "l\235on"
06:22:49 <bartavelle> alpounet, then I'll just have type Action = Free ActionF, and will work with Action ?
06:23:37 <ocharles> wait, wtf? http://lpaste.net/5180072940883935232
06:23:40 <ocharles> Unicode is *weird*
06:24:22 <adnauseam> lo o/ has anyone here make haskell code translate into java code ? i have a java project, but i'd like to stick to haskell
06:24:32 <adnauseam> is this possible ? does something for this already exist ?
06:24:45 <alpounet> bartavelle: well, Free would be enough, FreeT is for embedding this in some monad
06:24:49 <joeyh> ocharles: "noÎl" == "l\235on"
06:24:52 <alpounet> but yes
06:24:54 <donri> ocharles: i don't get that
06:25:00 <bartavelle> ok, will try that later
06:25:25 <ocharles> Right, I can't sometimes get reverse to work, and sometimes not
06:25:26 <klrr_> is it possible to do this? can i get a 'f (a -> a)' from an 'a -> f a'?
06:25:27 <yitz> adnauseam: if we give you javascript, can you take it from there?
06:25:29 <joeyh> so no fail afaics. Otoh the last example ghc fails. But supporting that weird lower case character would make toUpper change the length of a string..
06:25:45 <bartavelle> ocharles, the √´ can be encoded as a signle letter, or " + e, I suppose that is what makes it different
06:25:48 <joeyh> erm,  "noÎl" == "no\235l"
06:25:52 <adnauseam> yitz: i can definitely give it a try!
06:25:54 <ocharles> if I have 'putStrLn "no√´l"', and then change that with <up> and change it to "putStrLn . reverse" it works
06:26:07 <bartavelle> but it's broken
06:26:11 <BoR0> is [ x | x <- "asdf" ] (or set builder notation in general) syntactic sugar for do x <- "asdf"; return x ?
06:26:12 <ocharles> but if I type 'putStrLn . reverse' and paste "no√´l" in again it breaks
06:26:15 <ocharles> maybe it's my terminal
06:26:26 <joeyh> there are different Î's
06:26:29 <ocharles> right
06:26:29 <yitz> adnauseam: there are a few such translations - if you are willing to accept "something very similar to haskell"
06:26:35 <bartavelle> ocharles, it depends on your character input, there are distinct √´'s indeed
06:26:36 <yitz> adnauseam: like fay, for example.
06:26:41 <alpounet> bartavelle: regarding, the arbitrary instances, you can use frequency for your actions and for example frequency for choosing whether you go further in that branch (the Free constructor), or stop there (Pure)
06:26:44 <ocharles> joeyh: I'm just not sure if it's my terminal messing up, or Haskell
06:26:47 <ocharles> probably my terminal then
06:26:49 <quchen> BoR0: No, but it could be. For efficiency reasons GHC treats lists comprehensions in a special way.
06:26:53 <joeyh> > 'Î' == 'Î'
06:26:54 <lambdabot>   True
06:26:54 <adnauseam> ill look it up man ! thank you :)
06:26:57 <joeyh> hmm
06:27:11 <kamatsu> well, that's disappointing
06:27:13 <donri> ocharles: i think this is a common thing for terminals to mess up
06:27:18 <alpounet> or use the arbitrary instance for Int and take this `mod` numberOfActions
06:27:21 <kamatsu> length "noeÃàl" == 5
06:27:22 <BoR0> quchen, aha. so they are equal but not equivalent? or was it the other way around :)
06:27:28 <kamatsu> even with Data.Text
06:27:31 <ocharles> > '√´' == '√´'
06:27:32 <quchen> BoR0: If you enable MonadComprehensions then list comprehensions are converted to Monad code you wrote.
06:27:32 <lambdabot>   True
06:27:35 <bartavelle> alpounet : ah this is smart !
06:27:36 <ocharles> whoops, bad enter
06:27:41 <ocharles> > ord '√´' == ord '√´'
06:27:42 <lambdabot>   True
06:27:43 * hackagebot wai-graceful 0.1.0.1 - Graceful shutdown for WAI applications.  http://hackage.haskell.org/package/wai-graceful-0.1.0.1 (AlexanderBondarenko)
06:27:47 <joeyh> > length "noeÃàl"
06:27:48 <lambdabot>   5
06:27:48 <BoR0> I see. okay, thanks for your help
06:27:53 <ocharles> > (ord '√´', ord '√´')
06:27:54 <lambdabot>   (235,235)
06:27:54 <joeyh> wtf? It's 4 in ghci
06:28:07 <quchen> BoR0: I think list comprehensions are treated as special so they can fuse better. At least that's what I remember from hearsay around here.
06:28:10 <ocharles> joeyh: in my irc client you typed 5 characters
06:28:12 <BoR0> > length "—Ç–µ—Å—Ç"
06:28:13 <lambdabot>   4
06:28:16 * joeyh suspects that irc and/or lambdabot has some mojibake
06:28:18 <kamatsu> this is a unicode composition
06:28:25 <kamatsu> eÃà <‚Äî it's not precomposed
06:28:27 <kamatsu> it's two code points
06:28:29 <BoR0> > reverse "—Ç–µ—Å—Ç test cyrillic"
06:28:29 <MercurialAlchemi> joeyh: it depends if it's composed or not
06:28:30 <lambdabot>   "cilliryc tset \1090\1089\1077\1090"
06:28:31 <ocharles> yea
06:28:40 <MercurialAlchemi> same in Python 3
06:28:54 <kamatsu> also Data.Text.reverse "noeÃàl" = lÃàeon
06:28:57 <kamatsu> which is also wrong
06:29:07 <donri> > length "no√´l"
06:29:08 <lambdabot>   4
06:29:25 <joeyh> ah, so the complaint is that length of 2 decomposed characters is not 1?
06:29:27 <quchen> Is there a "Unicode dead double dots" codepoint or something?
06:29:45 <Clint> combining diaresis
06:29:54 <Clint> er, spell that right
06:30:00 <joeyh> dialysis?
06:30:02 <quchen> diarr...nevermind
06:30:06 <kamatsu> diacritic?
06:30:16 <Clint> serves me right
06:30:24 <donri> > length "eÃà"
06:30:24 <lambdabot>   2
06:30:40 <kamatsu> i understand why that happens with String, as it's just a list of code points
06:30:47 <kamatsu> so if you ask for length you're asking for the number of code points
06:30:56 <kamatsu> but there's no easy way to treat something glyph-wise
06:31:03 <shiona_> > length "√§"
06:31:04 <lambdabot>   1
06:31:04 <joeyh> heh, I pasted donri into ghci and got "length "e" ==> 2
06:31:06 <klrr_> is it possible to do this? can i get a 'f (a -> a)' from an 'a -> f a'?
06:31:10 <adnauseam> yitz: does what im doing have a name? i've heard the term "hooks" before but im not sure if it is it
06:31:11 <joeyh> no dots visible in my terminal
06:31:19 <donri> > ord Ãà''
06:31:20 <lambdabot>   <hint>:1:5: lexical error at character '\776'
06:31:21 <joeyh> "e\766" says ghci
06:31:22 <donri> lol
06:31:31 <yitz> kamatsu: Text is also just an array of code points. you have to renormalize manually.
06:31:35 <donri> U+0308 COMBINING DIAERESIS
06:32:03 <Clint> > length "Ãà"
06:32:04 <lambdabot>   1
06:32:36 <BoR0> klrr_, you can do f (b -> b) from an 'a -> f a', by setting a = b->b, but f (a -> a) is impossible, because you have a = a -> a
06:32:37 <joeyh> obfuscated haskell competition, here you come
06:32:44 * hackagebot parco 0.1 - Generalised parser combinators  http://hackage.haskell.org/package/parco-0.1 (TroelsHenriksen)
06:32:46 * hackagebot parco-attoparsec 0.1 - Generalised parser combinators - Attoparsec interface  http://hackage.haskell.org/package/parco-attoparsec-0.1 (TroelsHenriksen)
06:32:48 * hackagebot parco-parsec 0.1 - Generalised parser combinators - Parsec interface  http://hackage.haskell.org/package/parco-parsec-0.1 (TroelsHenriksen)
06:32:50 <kamatsu> Data.Text.toUpper "baÔ¨Ñe" ==> "BAFFLE"
06:32:53 <kamatsu> ah, that's good
06:32:57 <donri> > "√´" == "eÃà"
06:32:58 <lambdabot>   False
06:33:11 <ocharles> I wonder if TroelsHenriksen is aware of 'parsers'
06:33:18 <fizbin> donri: composed vs. precomposed?
06:33:44 <donri> fizbin: one is the single glyph U+00EB LATIN SMALL LETTER E WITH DIAERESIS
06:33:54 <donri> the other is "e" + U+0308 COMBINING DIAERESIS
06:33:56 <klrr_> BoR0: well i got a function that is "a -> f a" i want to rewrite that functor to "f (a -> a)", is this impossible adn my logic is wrong or is there just no function for this tranfsormation?
06:34:14 <joeyh> ah, makes sense, text can treat it as a whole entity, unlike map toUpper
06:34:21 <fizbin> Right, that's what I figured. NFKD or get out.
06:34:31 <quchen> > let 1 + 1 = 3 in 1 + 1  --  Until 'length "" == 1' I thought this was the silliest thing you could write in Haskell.
06:34:32 <lambdabot>   3
06:34:43 <ocharles> @djinn Functor f => (a -> f a) -> f (a -> a)
06:34:43 <lambdabot> Error: Class not found: Functor
06:34:46 <ocharles> -_-
06:35:08 <yitz> joeyh: use {-# OPTIONS_GHC -F -pgmF <path>} to create your haskell source from the output of a compiled haskell program, and you can really leverage that obfuscation technique
06:35:21 <donri> https://hackage.haskell.org/package/text-icu-0.6.3.7/docs/Data-Text-ICU-Normalize.html  -- if you ever need to deal with this, anyway
06:35:34 <klrr_> BoR0: basically, i need to supply my "a -> f a" to a function that wants "a -> f (a -> a) -> f0 a"
06:35:45 <klrr_> i got the first a already
06:35:46 <ocharles> donri: that's a solution, but the question remains: is the current behaviour useful?
06:35:50 <klrr_> but not the second input
06:36:24 <fizbin> klrr: In f an Applicative?
06:36:25 <yitz> ocharles: what would you suggest? reimplementing icu in haskell? making icu a binary dependency of ghc?
06:36:39 <fizbin> Sorry, *is* f an Applicative?
06:36:51 <zol> In GHCi, how can I specify the type for a function? GHCi induces the wrong type, I have a Haskore.Octave and a TwinkleStar.Octave, I want to use the TwinkleStar.Octave in my function definition..
06:36:59 <yitz> ocharles: neither of those sounds very appealing
06:37:05 <ocharles> yitz: right, I suppose not
06:37:09 <geekosaur> let foo :: type goes here; foo = ...
06:37:15 <Clint> surprise normalization
06:37:17 <quchen> :t (1, 1 :: Int) -- zol
06:37:18 <lambdabot> Num t => (t, Int)
06:37:19 <ocharles> maybe it would be nice to have a newtype'd String/Text that is implicitly normalized
06:37:25 <ocharles> Clint: yea, that is icky
06:37:35 <kamatsu> i sort of feel like the default Data.Text behaviour is wrong though, i don't think you'd ever want to reverse the code points and not the glyphs, for example
06:37:53 <yitz> ocharles: yes that would be nice. but how could we do it without depending on icu?
06:38:13 <alpounet> zol: qualify it, by writing TwinkleStar.Octave explicitly instead of just Octave
06:38:36 <alpounet> note that the TwinkleStar module must be loaded
06:38:49 * joeyh makes a mental note that T.toLower . T.toUpper /= T.toLower
06:39:01 <quchen> kamatsu: To be fair I don't think you'd ever want to reverse text :-√æ
06:39:10 <ocharles> yitz: i don't have a suggestion there (I was backtracking from suggesting base should do this)
06:39:21 <fizbin> yitz: Actually, for doing just NFC or NFD normalization, you'd just need some of the huge text files the unicode consortium puts out.
06:39:25 <kamatsu> quchen: what about an anagram game?
06:39:36 <kamatsu> quchen: you'd certainly want to reorganize characters then
06:39:38 <fizbin> yitz: Though there's weird licensing issues with those files.
06:39:43 <ocharles> yitz: I think my general worry is that if programmers think they are dealing with human readable text, it appears they have to constantly keep considerations in mind
06:39:53 <quchen> kamatsu: H.
06:39:57 <ocharles> and having to remember to do things is something I want to avoid when I write Haskell
06:40:00 <quchen> s/H/Hmm/
06:40:01 <zol> I get the <interactive>:158:21:
06:40:02 <MercurialAlchemi> quchen: can be useful when indexing if you want to make the '*foo' case efficient
06:40:02 <zol>     Illegal signature in pattern: TwinkleStar.Octave
06:40:05 <zol>         Use -XScopedTypeVariables to permit it
06:40:14 <zol> Sorry for the spam..
06:40:22 <donri> combining code points are tricky. i don't think implicit normalization is a solution
06:40:39 <ocharles> donri: if that is opted in for?
06:40:43 <quchen> zol: there's lpaste if you want to show code to the channel.
06:40:45 <quchen> @where lpaste
06:40:45 <lambdabot> http://lpaste.net/new/haskell
06:40:48 <joeyh> personally, I find ghc's behavior of crashing anytime a file that's read happens to not be valid under the user's current encoding much more of a problem for building robust code
06:40:52 <alpounet> zol: it requires a language extension called ScopedTypeVariables. You can enable it from your current GHCi session by typing: ":set -XOverloadedStrings" iirc
06:41:07 <zol> alpounet: Aha, thanks!
06:41:10 <donri> ocharles: i mean i agree with kamatsu; it would be better to have something that understood the semantics of the code points
06:41:28 <alpounet> zol: err, it's obviously ":set -XScopedTypeVariables"
06:41:45 <quchen> joeyh: If you ask me GHC should just crash if there are tabs or non-UTF8 characters around.
06:42:00 <quchen> "Error: No. Just no."
06:42:03 <fizbin> donri: Well, the unicode standard says that if you say you do unicode and you say that you compare unicode strings for equality, then you have to compare with NFC or NFD (or some technique that gives the same results).
06:42:03 <alpounet> i'm just really used to enabling overloaded strings in ghci...
06:42:12 <kamatsu> > length "üò∏üòæ"
06:42:13 <lambdabot>   2
06:42:13 <donri> i guess we need a higher level abstraction... ByteString -> decode -> Text -> interpret -> TextAsVisuallyDisplayed
06:42:16 <kamatsu> yay
06:42:20 <fizbin> See Section 3.2 at http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf#G29705
06:42:33 <donri> fizbin: compare, ok, but what about reverse? etc
06:42:45 * hackagebot file-embed 0.0.6 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.6 (MichaelSnoyman)
06:42:48 <joeyh> quchen: I assume you mean source files, in which case it'd dislike mine strongly, but I mean readFile etc
06:43:03 <donri> fizbin: normalize is lossy
06:43:04 <klrr_> fizbin: it's a functor, but what i wanna achieve in the end is an applicative
06:43:41 <fizbin> donri: The standard doesn't say anything about reverse, though TR9 has some fascinating things to say about stuff that appears to be reversed.
06:43:46 <quchen> joeyh: Oh, that. Well, for reading files the robust way you should probably use ByteString + Text.Encoding.
06:43:49 <donri> fizbin: you want to be able to act on e+combining diaeresis as a single thing, but not collapse it into a different code point
06:43:59 <fizbin> (TR9 is the unicode bidirectional algorithm)
06:44:02 <klrr_> fizbin: i have "f (a -> a) -> f0" where f is functor , f0 is applicative, i want to supply "a -> f a" for it so i need to "convert" that into "f (a -> a)"
06:44:03 <donri> fizbin: i'm not really talking about standards though :)
06:44:13 <donri> ok that sounds interesting
06:44:33 <joeyh> Text.Decode.decodeUtf8 "If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code."
06:44:33 <klrr_> i think i know how to solve it though
06:44:46 <quchen> klrr_: You could also try pasting your code, maybe there's a different approach to the problem.
06:44:51 <chrisdone> for reverse text just render it out and then flip the resulting raster =p
06:45:09 <donri> joeyh: decodeUtf8With lets you control error handling
06:45:26 <quchen> chrisdone: You should work for a consulting company!
06:45:31 <chrisdone> \o/
06:46:00 <donri> i wonder if that has implications for subpixel rendering and whatnot
06:46:12 <klrr_> quchen: already done that (when i asked initially), https://gist.github.com/klrr/7676158
06:46:19 <chrisdone> donri: yeah i think it would
06:46:24 * joeyh uses GHC.IO.Encoding.getFileSystemEncoding :/
06:46:34 <klrr_> quchen: but ive solved it now :) my logic was wrong, i now realize what i *really* wanted to achieve
06:46:50 <quchen> Wonderful. :-)
06:48:42 <fizbin> donri: I think you could come up with some reasonable rules for how to do a unicode reverse that would cover Latin, Greek, and Cyrillic alphabets and combining marks on those. But once you try to handle the mess that is combining Jamo (Korean) characters, may God have mercy on your soul...
06:48:44 <Fuuzetsu> Is there any way to instruct GHCi to print type synonyms when possible? For example, with ‚Äòtype String = [Char]‚Äô, asking ‚Äò:t ['a']‚Äô I'd like to get ‚ÄòString‚Äô. I don't imagine there's a way to do this but it doesn't hurt to ask.
06:49:37 <donri> fizbin: sounds fun
06:49:56 <fizbin> And if you have a string that, in addition to everything else, is full of RLO, LRO, and PDF characters? Gah.
06:50:49 <fizbin> I think that the bidi state machine is the only state machine embedded in unicode rendering that expresses itself as characters that can be arbitrarily far apart...
06:52:53 <fizbin> And I have no earthly idea how Indic unicode characters work normally, let alone if you're trying to reverse them.
06:57:39 <fizbin> > tails "CORP_INVOICE_c‚ÄÆcod.exe‚Ä¨"
06:57:40 <lambdabot>   <hint>:1:22:
06:57:40 <lambdabot>      lexical error in string/character literal at character '\...
06:58:13 <fizbin> Well, I guess that's just as well.
07:00:55 <fizbin> > tails "CORP_INVOICE_c\x00202ecod.exe\x00202c"
07:00:56 <lambdabot>   ["CORP_INVOICE_c\131820od.exe\8236","ORP_INVOICE_c\131820od.exe\8236","RP_I...
07:03:45 <fizruk> Fuuzetsu, if you use type synonym explicitly in the type signature, ghc will try use that
07:04:07 <Fuuzetsu> Yes, I know. I'm looking after a better ‚Äò:t‚Äô output, that's all.
07:04:13 <klrr_> in FRP, is there a function that let a constant value occure in an event whenever some other event occures? (not whenE that's not what  i want)
07:04:37 <Fuuzetsu> A different question: is there a way to nicely emulate Miranda's ‚Äòabstype‚Äô in Haskell?
07:05:37 <alpounet> Fuuzetsu: http://stackoverflow.com/questions/13595773/expand-type-synonyms-type-families-with-ghci ?
07:06:31 <bartavelle> alpounet, I implemented my test suite juste like you suggested https://github.com/bartavelle/stateWriter/blob/master/tests/rwscompare.hs .. but what would be nice would to have better "bind" actions that what I currently have. Would you have ideas for that ?
07:07:22 <Fuuzetsu> alpounet: That doesn't really answer my question.
07:07:42 <fizbin> :t Data.Text.pack
07:07:42 <lambdabot> String -> Data.Text.Internal.Text
07:07:53 <fizbin> > Data.Text.pack "a"
07:07:54 <lambdabot>   Not in scope: `Data.Text.pack'
07:08:09 <fizbin> Wtf, lambdabot? Do you know about it or not?
07:08:38 <geekosaur> what makes you think @type and @run have the same things in scope?
07:08:51 <geekosaur> (for one, @type allows IO stuff, obviously @run does not)
07:09:22 <fizbin> I thought run avoided that by ways that weren't keeping stuff out of scope.
07:09:24 <chrisdone> > putStrLn ""
07:09:25 <lambdabot>   <IO ()>
07:09:43 <chrisdone> probably "reasonable assumption" makes them think type and run have the same things in scope
07:09:59 <chrisdone> the only things i wouldn't put in scope would be unsafeCoerceIO
07:10:08 <chrisdone> er, unsafeCoerce/performIO
07:12:46 <benzrf> @src forever
07:12:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:12:48 <benzrf> huh
07:17:25 <benzrf> can somebody *please* look at the code for my Shitty Tiny Lisp and exposit on what stuff i should learn about to avoid recreating the horrible mess i made next time i make something similar???
07:17:29 <benzrf> code is @ http://lpaste.net/96267
07:18:09 <alpounet> Fuuzetsu: doesn't it? ":kind! String" says: "String :: * = [Char]"
07:18:34 <benzrf> @kind String
07:18:35 <lambdabot> *
07:18:42 <benzrf> yea
07:18:59 <fizruk> @kind! String
07:19:00 <lambdabot> *
07:19:10 <fizruk> ok
07:19:14 <alpounet> i don't think lambdabot has this
07:19:48 <benzrf> hmm, i should turn progn into a wrapped haskell function instead of a special form
07:19:54 <jozefg> :benzrf  Why does your lisp not have cons? :(
07:20:14 <benzrf> because i forgot
07:20:15 <benzrf> -.-
07:20:25 <benzrf> i started with no builtin funcs, then i added them as i felt the need
07:20:33 <benzrf> so i just ended up with add, car, cdr, & list
07:20:49 <benzrf> but yeah i should add cons
07:21:07 <alpounet> bartavelle: i'm not sure I get what you mean by "better bind actions", could you elaborate?
07:21:21 <klrr_> writing a lisp is fun :)
07:21:34 <benzrf> klrr_: not when youre using a language whose features you dont properly know
07:21:41 <benzrf> you may want to wear goggles before looking at my code
07:22:33 <benzrf> i.e. evalEach is probably just sequence, except that i don't know how to use mt
07:22:34 <benzrf> s
07:22:40 <benzrf> so it ended up being a whole func
07:22:41 <klrr_> benzrf:  i followed the Write Yourself a Scheme in 48 hours tutorial though
07:22:46 <benzrf> bah
07:22:57 <benzrf> following tutorials is for LOSERZ
07:23:28 <klrr_> it was my first real program, honestly it was the first time i really got how you *design* a program
07:23:52 <benzrf> also i feel like using existential types or whatever it is that allows you to have heterogeneous typeclass lists probably wouldve gotten rid of a crapload of clutter in my prog
07:24:08 <benzrf> :T
07:24:41 <klrr_> benzrf: your one actually looks very similar to the one in the tutorial, so if you new in haskell that is really impressive
07:24:46 <benzrf> huh
07:24:47 <klrr_> a bit cluttered though
07:24:51 <benzrf> ^ yes
07:24:52 <benzrf> well im not that new
07:24:58 <klrr_> okey
07:25:02 <bartavelle> alpounet, don't worry, I'll figure this out by myself
07:25:04 <benzrf> i've been trying to fit it into my brain for probably at least 6 months now
07:25:05 <benzrf> :D
07:25:07 <bartavelle> thanks for the Free tips
07:25:12 <benzrf> I havent written much in it though
07:25:29 <klrr_> well, maybe put your all your types in LispVal? i dont see the point of having a second type that is really just a synonym to String
07:25:38 <benzrf> hmmm
07:25:48 <benzrf> i wanted more expressive subfuncs
07:25:56 <benzrf> i.e. apply should take a LispFunc, not a LispVal
07:25:56 <sevak> hello, I heard there is a way to do this using concatMap instead: http://lpaste.net/4091314055791247360
07:26:03 <benzrf> less 'runtime type checks' that way
07:26:24 <sevak> can anyone point me in the right direction?
07:26:27 <benzrf> maybe i shouldve gone with your idea, but written a utility function to assert types
07:26:31 <alpounet> bartavelle, also, from the nick I could suggest you to join #haskell-fr :)
07:26:41 <klrr_> benzrf: but in lisp a function is a lispval
07:26:46 <klrr_> data is code and vice versa
07:26:54 <benzrf> bluh
07:27:03 <benzrf> yes, but you cannot apply a number
07:27:07 <benzrf> sevak: lookin
07:27:10 <fizruk> sevak, see iterate
07:27:30 <benzrf> :t iterate
07:27:31 <lambdabot> (a -> a) -> a -> [a]
07:27:41 <benzrf> @src iterate
07:27:41 <lambdabot> iterate f x =  x : iterate f (f x)
07:27:44 <Athas> ocharles: I wasn't, but 'parsers' didn't exist when I did Parco.  Besides, Parco has a slightly more powerful expression combinator library, which was my original mtivation anyway.
07:27:56 <Athas> Maybe I should just get Edward to put that into parsers instead.
07:28:00 <benzrf> hmm
07:28:02 <benzrf> looks like unfold
07:28:20 <benzrf> > take 5 $ iterate (+1) 0
07:28:21 <lambdabot>   [0,1,2,3,4]
07:28:22 <fizruk> benzrf, it is unfold just not stopping
07:28:24 <benzrf> neat
07:28:58 <benzrf> >3
07:29:05 <benzrf> ok, space is necessary
07:29:08 <benzrf> > 3
07:29:09 <lambdabot>   3
07:29:11 <benzrf> >                3
07:29:12 <lambdabot>   3
07:29:14 <benzrf> mmm
07:29:31 <benzrf> > (map read $ show 2343) :: [Int]
07:29:32 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
07:29:32 <lambdabot>  Expected type...
07:29:38 <benzrf> ah
07:29:47 <sevak> hmm
07:29:49 <benzrf> > fromEnum '3'
07:29:50 <lambdabot>   51
07:30:12 <benzrf> > (map ((-48) . fromEnum) $ show 2343) :: [Int]
07:30:13 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Int))
07:30:14 <lambdabot>    arising f...
07:30:20 <benzrf> > map ((-48) . fromEnum) $ show 2343
07:30:21 <lambdabot>   No instance for (GHC.Show.Show b0)
07:30:22 <lambdabot>    arising from a use of `M9017295511235...
07:30:25 <benzrf> guh
07:30:51 <benzrf> > map ((+(-48)) . fromEnum) $ show 2343
07:30:52 <lambdabot>   [2,3,4,3]
07:31:15 <benzrf> dumb ol subtraction sections
07:31:48 <scott_> benzrf: (subtract 48)
07:31:52 <benzrf> dur
07:32:01 <benzrf> @let testing 3
07:32:02 <lambdabot>  Parse failed: TemplateHaskell is not enabled
07:32:04 <lpaste> klrr pasted ‚Äúsimple lisp‚Äù at http://lpaste.net/96287
07:32:04 <benzrf> @let testing = 3
07:32:05 <lambdabot>  Defined.
07:32:08 <benzrf> > testing
07:32:10 <klrr_> benzrf: loop at that paste
07:32:11 <lambdabot>   3
07:32:13 <benzrf> neat
07:32:14 <klrr_> to get an idea of what  i mean
07:32:27 <benzrf> IO
07:32:29 <benzrf> really.
07:32:36 <sevak> benzrf, what is the $?
07:32:36 <klrr_> ?
07:32:49 <benzrf> sevak: grouping operator
07:33:00 <benzrf> it's like parens to the end of the line or to the next right paren
07:33:03 <fizruk> benzrf, what?
07:33:22 <benzrf> fizruk: hm?
07:33:24 <klrr_> benzrf: what? it's just to show what i meant with the LispVal struct, not mean that evals return type is the best)
07:33:42 <sevak> hmm
07:33:51 <fizruk> sevak, $ is function application: f $ x == f x
07:33:58 <scott_> sevak: The definition is simply f $ x = f x, it's just the operator precedence that matters. It's set so that f $ x + y = f (x + y)
07:34:11 <fizruk> sevak, the difference is $ has LOWEST precedence and is RIGHT associative
07:34:33 <fizruk> e.g. f x y == (f x) y, while f $ g $ x == f (g x)
07:34:42 <scott_> Or f $ g x y = f (g x y), but that would work no matter what it's precedence. Still useful for eliminating ()
07:35:08 <sevak> oh ok nice, thanks
07:36:18 <klrr_> the difference between (.) and ($) was something i struggled with in beginning, basically, (.) is to solve this problem "f (f (f (f x))))" and ($) is to solve this problem "f x (f y)"
07:36:40 <Hodapp> I just read a StackOverflow post about that the other day
07:36:49 <fizruk> klrr_, f . g . h $ k x y z
07:36:57 <klrr_> yeah exactly
07:37:17 <sevak> > show $ 4 + 3 --cool
07:37:18 <lambdabot>   "7"
07:37:47 <vektor> hello, nerds!
07:37:57 * Hodapp looks around
07:38:00 <fizruk> sevak, note that f $ g $ x == f . g $ x
07:38:02 <benzrf> hello vektor
07:38:10 <sevak> vector, how dare you sir
07:38:12 <fizruk> sevak, so usually you don't use $ twice
07:38:13 <benzrf> must you call us nerds in that particular tone
07:38:16 <benzrf> nerds we may be
07:38:24 <benzrf> but it doesnt need to be a mean word
07:38:25 <benzrf> ;_;
07:38:37 <vektor> who said it's a mean word?
07:38:40 <benzrf> pfft
07:38:46 <benzrf> you totally implied it maaan
07:38:53 <vektor> anyone who takes nerd to be a mean word doesn't have a clue.
07:39:11 <sevak> fizruk, interesting, I need to try that to understand it
07:39:55 <Hodapp> vektor: Anyone who can't tell when the word's used to be mean is blind.
07:40:05 <scott_> sevak: If this part isn't clear, also note that f . g $ x == (f . g) x
07:40:41 <tdammers> I used to do a . b . c . d $ e a lot
07:40:58 <benzrf> tdammers: is that bad
07:41:00 <tdammers> but I'm now leaning more towards a $ b $ c $ d e
07:41:02 <fizruk> tdammers, did you stop?
07:41:24 <sevak> scott_, hmm
07:41:56 <vektor> sorry if it seemed to be mean.
07:42:03 <benzrf> just needling you
07:42:04 <benzrf> :p
07:42:18 <sevak> vektor, I was just kidding
07:42:38 <vektor> well, Hodapp didn't quite seem to be.
07:43:06 <vektor> dammit. Language nuances via text messaging. Don't make english any harder than it actually is :D
07:43:16 <sevak> scott_, so that is the same as f $ g $ x?
07:43:18 <vektor> s/actually/already
07:43:24 <fizruk> sevak, sure
07:43:25 <scott_> sevak: Yes
07:44:36 <fizruk> sevak, f $ g $ x = f $ (g $ x) = f (g $ x) = f (g x) = (f . g) x = (f . g) $ x = f . g $ x
07:44:48 <scott_> I was just about to write that in the opposite direction :)
07:44:55 <scott_> f . g $ x == (f . g) x == f (g x) == f (g $ x) == f $ (g $ x) == f $ g $ x
07:45:04 <vektor> I wanna create a Database kinda thing (not so much for IO conversation with the world - just for internal use in my program.) In which I wanna look up Strings by using unique IDs as key. (Int presumably... or some other integral numeric type) Is Data.Map the place to go?
07:45:15 <fizruk> scott_, sorry then :p
07:45:30 <benzrf> vektor: that is kind of what maps are for...
07:45:30 <benzrf> :P
07:45:44 <scott_> fizruk: It's good. Independent verification :)
07:45:47 <fizruk> vektor, IntMap or Map
07:45:53 <vektor> alright.
07:46:20 <vektor> Been fooled by "false friends" more than once, coming from c++ (*cough*return*cough*), so I wanted to make sure :D
07:46:21 <fizruk> vektor, there's also HashMap
07:46:32 <benzrf|diffwindo> ugh
07:46:59 <benzrf|nothere> -afk-
07:47:39 <vektor> damn, I'm just realizing how much of a mean DB that actually is gonna be.
07:49:22 <Hafydd> public static false friend
07:49:28 <Hodapp> o_O
07:49:33 <vektor> derp
07:49:45 <vektor> public static is more of a java thing
07:49:54 <vektor> int main(){} for c++
07:51:12 <vektor> also, guys. If you had a genius AI programmer sitting in your basements, and he was writing an AI in Haskell, and you had to determine which data structure / data type he had to use for persistent storage, which one would you have him use?
07:51:38 <Hafydd> If they're such a genius, surely they can make that decision.
07:51:48 <vektor> nope, they can't
07:51:53 <vektor> I don't trust him.
07:52:03 <kamatsu> it really depends on the AI use case
07:52:16 <Hodapp> AI in Haskell? Pffft. He'd probably be using Lisp.
07:52:28 <geekosaur> if you don't trust him, you've got bigger problems than choice of data structure...
07:52:34 <RevJohnnyHealey> Persist to memory and never shut the machine down. It is the fastest solution.
07:52:59 <vektor> I've determined Input/Output as [String] hoping it isn't awfully off. But permanent memory is more critical I think.
07:53:18 <Hodapp> "Skynet took over that day. If only I'd have used static typing, the compiler would have caught this error, and this never would have happened. I always knew that Lisp's ability to construct things on-the-fly was going to lead to something big. I never expected it'd be Skynet."
07:53:37 <vektor> Well, the thing is what I wanna avoid
07:53:52 <Hodapp> RevJohnnyHealey: not sure if joking >_>
07:54:29 <RevJohnnyHealey> Hodapp: I am joking, mostly.
07:54:32 <vektor> that's why my attempt at an AI is gonna consist of haskell code implementing 2 functions that are *not* IO monads.
07:54:53 <alpounet> vektor: depends on what type of data the AI works on, if there are standard or widely-used formats for that, etc
07:54:58 <vektor> so nothing evil will come out any way put the return vals of that Functions.
07:55:14 <RevJohnnyHealey> An AI implemented in 2 functions sounds scary.
07:55:15 <fizruk> vektor, you can write AI with LogicT (State s)
07:55:19 <tiffany> persist to a memory mapped file
07:55:20 <vektor> alpounet: I don't have a clue.. :D
07:55:24 <Hodapp> vektor: whatever the case, this is bound to get you an article in Wired that completely blows out of proportion what you did and what Haskell is.
07:56:13 <vektor> s/put/but
07:56:20 <RevJohnnyHealey> Be sure to mention category theory in the wired interview.
07:56:31 <vektor> Rev: well the AI can define it's own subfunctions. But I'm only calling those 2.
07:56:47 <Kron> hmmmm
07:56:47 <Kron> what sort of AI?
07:56:48 <Kron> general intelligence?
07:56:48 <Kron> someone trying to be human level?
07:56:50 <Kron> you want to make the data storage as general as possible and embed as much contextual metadata into it so that the computer itself can reason about it
07:56:51 <Kron> I'd recommend basically building your own internal operating system
07:56:51 <Hafydd> subFunctio = unsafePerformIO $ ...
07:56:52 <Kron> Hodapp: that gave me a good laugh
07:57:16 <vektor> Hafydd: don't scare me :D
07:57:19 <Hodapp> Kron: hah, what, the Lisp fake-quote?
07:57:32 <Hafydd> If the AI can defined its own code, you'd better be scared.
07:57:35 <vektor> Kron: for now, I'd be ok with ant level.
07:57:50 <RevJohnnyHealey> I once created a tic tac toe AI in 2 functions. Min and Max.
07:58:17 <fizruk> vektor, wouldn't ant level be to high for an AI?
07:58:42 <vektor> well, the AI can define it's own code, but I don't see a way it's supposed to get into a AI monad. I'll be taking care there.
07:58:59 <Hafydd> What is an AI monad?
07:59:07 <vektor> IO ...
07:59:08 <vektor> derp
07:59:12 <radish> Hodapp: can i see the quote?
07:59:15 <Hafydd> What is an IO monad? I think you just mean IO value.
08:00:04 <vektor> well, the return type of any "potentially evil" functions I'll call will be
08:00:05 <Hodapp> radish: "Skynet took over that day. If only I'd have used static typing, the compiler would have caught this error, and this never would have happened. I always knew that Lisp's ability to construct things on-the-fly was going to lead to something big. I never expected it'd be Skynet."
08:00:21 <vektor> *not* IO something. That's what I was going for.
08:00:34 <radish> Hodapp: oh lol yeah so you a static typing fan?
08:00:53 <Hodapp> <smug>I'm a fan of whatever gets the job done most effectively!</smug>
08:01:28 <Kron> it's simple; implement lisp in haskell and then implement the AI in lisp
08:01:29 <Kron> should be about 10 minutes work tops
08:01:37 <radish> Hodapp: i wouldn't leave home without it.
08:01:37 <vektor> lol
08:02:03 <vektor> Kron: I was right now thinking of a tree-array-hybrid thing
08:02:09 <vektor> bit like a FileSystem
08:02:44 <radish> can someone help me map some IO to a list? I don't understand sequence or mapM at all.
08:02:47 <Kron> Hodapp: yes the lisp fake quote
08:02:48 <Kron> intuitively, i'd use a kind of graph
08:02:48 <Kron> some sort of conceptual mesh network
08:02:58 <Kron> where the AI is allowed to draw its own connections between concepts it defines to encapsulate patterns in raw input data or patterns in concepts
08:03:05 <Kron> like Eurisko, if Eurisko actually ever existed. I'm not sure.
08:03:34 <vektor> well, all that knowledge could very well be represented within said FS-rip-off
08:03:53 <jozefg> Gah, I wish Haskell had proper dependent types
08:04:36 <radish> vektor: what are you making?
08:04:41 <vektor> ants
08:04:55 <radish> vektor: use genetic algorithms and have competing ant colonies.
08:05:04 <vektor> self-aware, sentient, hyper-intelligent ant AI.
08:05:12 <vektor> radish: that's the idea.
08:05:47 <radish> vektor: i prefer a top down approach to these kinds of problems, what would you like them to accomplish?
08:06:05 <Eduard_Munteanu> radish: that's exactly what mapM does
08:06:11 <Eduard_Munteanu> :t mapM
08:06:11 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
08:06:13 <vektor> data Node = [String], [Node].... how does that sound? could that kinda-work, Kron?
08:06:31 <radish> Eduard_Munteanu: can't get it to work lol will try again...
08:06:35 <Eduard_Munteanu> radish: you give it an IO function, it maps it over a list and runs the resulting actions in order
08:06:53 <Hodapp> Kron: use neural networks. They may not help with the technical aspects, but you'll get lots of funding and cred.
08:06:56 <Eduard_Munteanu> Where "runs .. in order" is the sequence bit.
08:07:02 <Eduard_Munteanu> :t sequence
08:07:03 <lambdabot> Monad m => [m a] -> m [a]
08:07:12 <vektor> radish: I don't know, I'm just derping around. I wanna have them communicate and collaborate, in the hope of having them gather basic language skills. But that's very much just a wild guess at what could happen.
08:07:40 <vektor> where language ofc doesn't mean human language. that'd be a whole different level.
08:07:44 <radish> vektor: spacial ant colony or something more abstract?
08:08:19 <vektor> right now considering tiled environments. not sure though
08:08:23 <Eduard_Munteanu> radish: for example sequence_ [putStr "Warning", launchMissiles] is like putStr "Warning" >> launchMissiles
08:08:31 <volty> hyper-spatial, maybe
08:08:35 <vektor> sure
08:08:51 <radish> vektor: what kind of communication? touch, line of sight, smell, vibration?
08:08:58 <vektor> because that'll totally be helpful, volty :D
08:09:08 <volty> what about starting with just one ant? :)
08:09:22 <vektor> radish: talk. They just shout around, and everyone can listen. within a certain range.
08:09:28 <vektor> Right now working on the DB.
08:09:38 <vektor> I'll test the concept on TicTacToe first anyway.
08:10:04 <radish> volty: lmao
08:10:08 <volty> ah, ok, if they shout then go with two of them -- just to make sure they "collaborate"
08:10:26 <volty> i need qt
08:10:32 <radish> vektor: yes, do this in non eucladian geometry. for the lulz of course.
08:10:39 <vektor> yeah
08:10:48 <vektor> isn't there a xkcd on that?
08:10:58 <vektor> wait, that was non-cartesian.
08:10:58 <radish> vektor: i have no idea, great comic though
08:11:01 <chrisdone> i wonder what an ant would do on a mobius strip
08:11:05 <lingxiao> hey all, if I have some type synonsym `Tree = [Int]` and I want to write a custom `Show` instance for this
08:11:08 <Kron-phone> Anyway what i wanted to say about ai data storage: it has to be contextual
08:11:14 <lingxiao> how do I go about doing it?
08:11:14 <vektor> it's about centrifugal force in a circular coordinate system
08:11:21 <lingxiao> I put these two flags {-# LANGUAGE TypeSynonymInstances #-} {-# LANGUAGE FlexibleInstances #-} in the file
08:11:22 <volty> i miss qt, anybody can give me hints (vague ones) about the difficulties of generating c headers out of qt one's ?
08:11:31 <Kron-phone> If an ai has a symbol called cat and one called mammal
08:11:33 <lingxiao> Overlapping instances for Show SigTree
08:11:34 <lingxiao>       arising from a use of `print'
08:11:34 <geekosaur> lingxiao, type synonyms are just that, you can't write an instance for one distinct from the other type
08:11:41 <radish> vektor: that sounds painful
08:11:43 <vektor> Kron-Phone: what about the above-mentioned idea?
08:11:43 <Kron-phone> And it think a cat is a mammal
08:11:46 <chrisdone> would it walk for ages thinking "this is a long road" or would it smell its own pheremone trail and think "oh i've already been there 2 minutes ago, i'll go back" and would it do that repeatedly? =)
08:11:48 <lingxiao> ah so there's no way around this you're saying
08:11:54 <geekosaur> use a newtype
08:11:54 <Kron-phone> It actually knows nothing
08:11:57 <lingxiao> aside from wrirint custom "pretty print"
08:12:00 <Eduard_Munteanu> lingxiao: TypeSynonymInstances isn't quite kosher, better wrap it in a newtype
08:12:14 <Kron-phone> I actually missed the last idea
08:12:15 <scott_> vektor: How about something like http://xkcd.com/8/
08:12:21 <Kron-phone> In a doctors office
08:12:22 <Kron-phone> Gtg
08:12:31 <scott_> vektor: Look at the collaboration!
08:12:38 <vektor> data Node = [String], [Node]
08:12:39 <Eduard_Munteanu> lingxiao: or you can make a function showTree :: [Int] -> String instead of writing an instance
08:12:46 <lingxiao> Eduard_Munteanu: just to clarify, I should do `newtype Tree = T [Int]` ?
08:12:46 <geekosaur> TypeSynonymInstances just means you can name a type instance by a synonym, which is a bad idea because it makes the synonym look different from the actual type which it is not
08:12:50 <vektor> Kron-phone: √Æ
08:12:56 <Eduard_Munteanu> lingxiao: yes
08:12:57 <lingxiao> yes that was the other option I had, some prettyPrint thing
08:12:59 <lingxiao> ok great thanks!
08:13:00 <radish> vektor: okay so you want the ants to move around and communicate. you need to give them objectives. food is a good one. the heavier the food, the better the score. food should shout different messages based on weight. preferably with a bit of randomness. then have the ants respond to different messages. let me think on this for a second.
08:13:18 <geekosaur> if you have `type Tree = [Int]` then Tree *is* [Int], you can use Tree anywhere you would use [Int]
08:13:35 <geekosaur> no difference at all, hence no distinct instances that apply to Tree but not [Int]
08:13:38 <vektor> http://xkcd.com/123/
08:13:47 <vektor> that's the one
08:15:10 <vektor> or can I define a very unspecific data structure, so the AI can choose what's best?
08:15:38 <fizruk> Data.Dynamic?
08:16:45 <vektor> I was thinking more of something along the lines of data Memory = Map | [String] | ....
08:16:59 <vektor> data.dynamic sounds kinda unsafe to me... not sure though
08:17:53 <radish> vektor: i would use something really primitive for the sounds. binary or something. but you want them to have a way to pick up on distance and direction. you can cheat and just allow that but you won't get as interesting of results.
08:17:55 <AffiliateOwnz> **Earn 0.25$ Per Lead **. For Details:http://www.StillRemember.Net/Affiliate.htm
08:17:59 <fizruk> vektor, sure you can have some kind of sum of knowledge representations
08:18:17 <Eduard_Munteanu> preflex: seen dmwit
08:18:17 <preflex>  dmwit was last seen on #haskell 1 day, 10 hours, 19 minutes and 23 seconds ago, saying: gotta run, g'luck
08:18:33 <geekosaur> idoru++
08:18:36 <radish> vektor: don't overcomplicate it, you can do the whole thing with ints
08:18:56 <radish> vektor: just saying.
08:19:00 <Eduard_Munteanu> @karma idoru
08:19:00 <lambdabot> idoru has a karma of 3
08:19:04 <vektor> radish: first is TicTacToe. Then we'll see bout those ants
08:19:10 <Eduard_Munteanu> He deserves much more. :)
08:19:25 <radish> vektor: the ants aren't /that/ complicated.
08:19:29 <Eduard_Munteanu> How about we make a bot that spams idoru++ on all channels? :P
08:19:36 <vektor> still, TTT is first
08:20:14 <fizruk> Eduard_Munteanu, who's (s)he?
08:20:40 <Eduard_Munteanu> fizruk: a Freenode service bot that autobans spammers when they message more than N channels at a time
08:21:07 <fizruk> oh great :)
08:23:21 <radish> vektor: okay but i'm gonna help you with the ants right now while my brain is in it. ;) you'll need space, random food drops, hunger; some verbs: walk forward, turn left, turn right, grab, drop, eat, mate, talk; some method of coding speech (i vote binary), direction and distance awareness, a brain that maps states to verbs. then you just make random tweaks to the brain during evolution. bonus points for any limitations you put on the
08:23:21 <radish>  system - ie a fixed number of synapses.
08:23:53 <vektor> you forgot the attack verb
08:24:06 <radish> vektor: whoa now, you never said anything about that!
08:24:14 <vektor> hrhrhr
08:24:15 <volty> the question should be: ¬´What's in AN ant?¬ª -- billions of stupid only multiply the stupidness :)
08:24:34 <volty> s/only/just/
08:24:36 <radish> vektor: sinister schemer.
08:25:01 <radish> vektor: what is a man?? a miserable pile of coding conventions.
08:25:12 <benzrf> radish: meh heh heh
08:25:15 <vektor> buuuurn
08:25:32 <vektor> radish: any ideas regarding persistent memory of the Ant?
08:25:41 <radish> vektor: yes! 8 bits.
08:25:41 <volty> what's i a man? --- Maybe an ant colony dreamer ? :)
08:25:47 <radish> vektor: for each ear.
08:26:02 <radish> volty: :D
08:26:06 <fizruk> radish, they don't have ears?
08:26:26 <radish> fizruk: they're gonna have a hard time shouting at one another, then.
08:26:40 <vektor> radish: well, I don't want to limit my genius ants to 8 bits of memory.
08:26:43 <benzrf> how can i build a windows exe from my loonix computer?
08:26:49 <radish> vektor: yes! yes you do!
08:26:51 <volty> ants usually communicate through an enum of four kinds of smell
08:26:54 <vektor> why?
08:27:00 <radish> vektor: better yet, n bits. let the ant decide how many it wants.
08:27:03 <vektor> what if I want to evolve them to termites?
08:27:23 <AffiliateOwnz> **Earn 0.25$ Per Lead **. For Details:http://www.StillRemember.Net/Affiliate.htm
08:27:49 <radish> vektor: then you want to match patterns in the ant's brain based on the patterns out sound it's receiving. they probably also need an internal clock.
08:28:18 <vektor> well, if it were an imperative language, I'd say that since I'm just abstracting the RAM, I should use a vector or array...
08:28:27 * geekosaur wonders how many times they get before kill becomes kline
08:28:28 <vektor> but with haskell, that won't quite work
08:28:28 <radish> vektor: if you have too many bits they will come up with exotic codes that won't be cross communicable.
08:28:44 <radish> vektor: good, that sounds like a ridiculous way to accomplish your goals lol
08:28:56 <volty> vektor: you can evolve them into elephants too --- as soon as making a single ant with the minimum of critical intelligence & knowledge (genetic imprint - all the same)
08:28:58 <radish> vektor: and this whole thing can be pure, yeah? so shoot for that.
08:29:21 <radish> volty: lets also have the ants pain, yes?
08:29:29 <radish> volty: lets also have the ants paint, yes?*
08:29:44 <volty> radish: yes, i feel them already in my pants :)
08:29:46 <benzrf> excuse me but reposting: how can i build a windows exe from my loonix computer?
08:29:54 <vektor> volty: ouch
08:30:13 <radish> vektor: dude i am so stealing your project lol.
08:30:29 <vektor> benzrf: can you use a virtual windows installation or so?
08:30:32 <geekosaur> benzrf, cross compiling is still in early stages, unreliable, and nonexistent between unix<->windows. run windows in a vm
08:30:35 <benzrf> aw
08:30:44 <radish> vektor: i bet you my ants will beat up your ants.
08:30:50 <vektor> radish: why not collab?
08:31:19 <radish> vektor: i seriously suck at collaborating. ;)
08:31:40 <vektor> I do too.time for some self-improvement.
08:31:59 <radish> vektor: you want to swap notes or share a codebase?
08:32:03 <vektor> well, so how would I go about persistent memory in haskell?
08:32:09 <vektor> both
08:32:31 <vektor> vectors are too slow, or so it seems. change one thing and you gotta rewrite the whole thing to memory.
08:33:14 <vektor> or will haskell's laziness compensate for it, by rewriting the whole array only once per tick?
08:33:36 <fizruk> vektor, I'm not good at writing AI, but if yours is not merely reactive, perhaps you'll need backtracking
08:34:06 <radish> vektor: i'd try just outputing a whole new world each time. just the stuff that changes. can't be worse performance than overwriting, can it?
08:34:22 <radish> minus the stuff that doesn't change, right?
08:34:41 <vektor> there won't be much static content I assume
08:34:53 <radish> vektor: the landscape, if we have one.
08:34:58 <vektor> well, sure
08:35:27 <vektor> I wasn't considering that to be part of the actual tick data.
08:35:39 <radish> vektor: 2D will make this make this even easier.
08:36:13 <radish> vektor: whatever you tick you have to write anyway, I don't see where performance would be lost simply recreating the whole world each step.
08:36:19 <vektor> Also, I think the power of being able to edit our environment (as in make tools and change the landscape) significantly contributed to humanly mental capabilities
08:36:58 <radish> vektor: oh boy here we go D:
08:36:59 <vektor> well, the problem is that the arrays that represent internal memory might be horrificly slowed down, because after every write operation haskell has to completely rewrite them.
08:37:10 <bz> > let x = x in x
08:37:13 <lambdabot>   mueval-core: Time limit exceeded
08:38:02 <vektor> that and collaboration lead to the mental and language capabilities humans have. Or so I read.
08:38:26 <radish> vektor: well let it run slowly then, we can replace everything with a top level IO for performance after it doesn't pan out lol
08:38:36 <fizruk> humans also have souls
08:38:43 <fizruk> sometimes
08:38:59 <vektor> fizruk: depends on your definition of soul. I doubt there's any "magic" to it :D
08:38:59 <radish> vektor: i'm rather excited! just remember that i'm rather new to programming in general so if i suck fair warning.
08:39:09 <vektor> just neurons thinking they're more awesome than they are.
08:39:11 <radish> fizruk: quantum entanglement bro
08:39:42 <radish> vektor: why does magic have to be magical? the entire universe popped out of nothing and does all kinds of crazy stuff. is this not enough??
08:39:55 <vektor> got 3 years of experience in the imperative world, been learning haskell for a few months now. This AI is my first haskell project.
08:40:05 <benzrf> pfft noob
08:40:05 <radish> vektor: the moment you find magic you will find out how to use it and then it becomes boring old science.
08:40:14 <benzrf> i did imperative for EIGHT YEARS before learning haskell
08:40:16 <benzrf> -smug-
08:40:24 <volty> eh?
08:40:35 <radish> vektor: you've been brainwashed by imperative thinking, throw all that out lol.
08:40:38 <fizruk> benzrf, I'm sorry to hear that
08:40:41 <Hodapp> imperative was really all I dealt with since... 1998.
08:40:44 * geekosaur *eyeroll*
08:40:46 <benzrf> fizruk: i am too
08:40:48 <Hodapp> until dabbling a bit with functional in 2012.
08:40:50 <volty> why don't you start with something less intelligent than ants ?
08:40:53 <vektor> "You merely adopted functional programming! I was born into it, molded by it!"
08:40:53 <Hodapp> pure functional that is.
08:41:11 <Hodapp> but reading about Lisp in 2003 sure messed with my head when I saw the possibilities there.
08:41:16 <volty> e.g. worms that find their way through tubes ?
08:41:40 <vektor> volty: first off is ticTacToe. Then we'll see.
08:42:05 <vektor> maybe chess, maybe ants, maybe hunter-prey-stuff.
08:42:28 <radish> vektor: lol what is that from?
08:42:42 <vektor> huh? the functional programming quote?
08:42:50 <radish> vektor: you do the tictactoe thing I'm gonna get started on the ant thing and see if i can figure anything out lol
08:42:57 <radish> vektor: yes its hilarious
08:43:03 <fizruk> for data types ala carte, should I use compdata or something different?
08:43:03 <volty> try with chess and use ants to push the figures :0
08:43:23 <radish> volty: dude you are the devil lmao
08:43:37 <vektor> http://weknowmemes.com/2012/12/you-merely-adopted-the-internet-bane/
08:43:51 <radish> volty: and while pushing they need to replicate the mona lisa from memory, right?
08:43:55 <fizruk> @hackage compdata
08:43:55 <lambdabot> http://hackage.haskell.org/package/compdata
08:43:58 <radish> volty: with little painted feet
08:44:09 <volty> no,those are  just the ants in my pants
08:44:33 <volty> nice idea -- replication
08:44:37 <radish> volty: i too have a full size replica of mona lisa on my butt
08:44:47 <volty> just divide the job between them
08:44:49 <radish> volty: she winks when i flex
08:46:09 <radish> vektor: hook me up with contact info
08:46:22 <radish> vektor: i'm certain this project will take more than a day
08:46:29 <volty> so she must be more beautiful flexed on that side
08:46:32 <vektor> check PM
08:46:55 <vektor> (@ radish that is)
08:47:07 <radish> volty: yes her eyes are quite ugly
08:47:16 <radish> volty: the more closed, the better
08:47:56 <volty> her voice will be nice -- out of that place :)
08:53:02 <vektor> soo.... Haskell has lotsa arrays. Which one would I use for that kinda thing?
08:53:46 <vektor> I want it to be as close to RAM as possible, without risking the pure functional aspect of things
08:54:18 <fizruk> vektor, don't you want to write first something that simply works and then think about performance?
08:54:45 <vektor> thank you
08:54:57 <vektor> (was I just thinkin about prematurely optimizing my shit?)
08:55:06 <fizruk> vektor, until you have something to reason about there would be no clear answer to your question
08:55:07 <vektor> punish me!
08:55:18 <fizruk> vektor, I'll leave that to you
08:55:28 <volty> fizruk: thank you
08:57:19 <radish> i try to sit in the middle. optimize as you go but don't go above and beyond until you need to, right? do nothing that is unreadable ever.
08:57:37 <volty> (i was just thinking about a man, without legs, pondering between running by one leg or with three of them )
08:59:16 <FireFly> Such a missed oppurtunity.. obviously vektor should use Vector
08:59:22 <FireFly> (okay, maybe not)
08:59:33 <vektor> lol
08:59:48 <vektor> so what's the easiest-to-use form of array?
08:59:50 <vektor> vector?
09:00:22 * FireFly doesn't know
09:02:32 <fizruk> > [1..10] !! 5
09:02:33 <lambdabot>   6
09:03:21 <fizruk> vektor, why you think you need array?
09:06:00 <fizruk> anyone familiar with Data Types ala Carte?
09:06:06 <vektor> wanna get as close to the metal as possible, without compomising pure functionality
09:06:42 <fizruk> vektor, you don't want that at the first place
09:07:11 <vektor> well, I want to use the most basic data structure.
09:07:18 <vektor> Everything else is the AI's job.
09:07:29 <fizruk> vektor, most basic is list
09:07:55 <vektor> I'd like to have O(1) access, but I'll go with lists first. Alright.
09:08:13 <fizruk> vektor, I'm not sure you want random access
09:08:23 <vektor> why not?
09:08:40 <radish> vektor: just trust them, they're haskell programmers, they know
09:08:42 <volty> how many log mb's about structures without logic?
09:10:04 <fizruk> vektor, if you want a dictionary (for simple knowledge representation) then use Map
09:10:09 <volty> I am going to write a program that emulates God but I do not have the right structures -- should i use vector, list, head-recursive data structures ?
09:10:26 <vektor> volty: lmao
09:10:47 <volty> tell us something about the intelligence of your ants
09:11:09 <volty> are they going to walk on all the four (or six) ?
09:11:11 <vektor> dumb as fuck atm
09:11:18 <vektor> not reacting at all atm.
09:11:19 <Hodapp> anyone looked at Noble Ape?
09:11:20 <volty> are they going to make love?
09:11:21 <vektor> no memory at all
09:11:28 <volty> will there be a mum-ant?
09:12:36 <volty> make something at least walks/climbs  on a virtual surface and come to ask for vectors and rockets to put your ant on
09:13:37 <volty> that at least ... and, after, come for a talk on necessary structures ... -- that's the sense
09:13:48 <radish> volty: use a tree dude
09:14:08 <vektor> radish: don't feed them trolls.
09:14:11 <vektor> ;-)
09:14:15 <volty> me?
09:14:23 <vektor> nomnomnom
09:14:26 <volty> you are the trolls --- talking about nothing
09:14:45 <radish> volty: mr troll, will you tell us a riddle please?
09:14:54 <radish> volty: oh burn
09:14:57 <vektor> also, be civil, and don't feed on the trolls either :D
09:14:59 <radish> volty: nailed it dude
09:15:50 <radish> we'll be back with word of talking ants
09:15:59 <Hodapp> no troll-accusations!
09:16:03 <Hodapp> it's like the Godwin's law of IRC!
09:16:05 <volty> a few minutes talking about nothing is ok but non for hours
09:16:05 <radish> and hopefully photographs
09:16:22 <radish> volty: its dead anyway so whats the problem?
09:16:33 <radish> volty: you are right of course
09:16:47 <volty> i'm short on space for the log :)
09:16:52 <volty> thanks radish
09:17:24 <radish> wait how do you run out of log space? that's like 1 mb per year lol
09:17:48 <volty> you mist the suffix (it was ':)' )
09:18:32 <volty> missed
09:27:01 <radish> volty: ah yes, sarcasm. god i just /love/ sarcasm.
09:27:37 <volty> you are going to love then :)
09:27:50 <chrisdone> @choose sarcasm wit
09:27:50 <lambdabot> wit
09:32:25 <Fuuzetsu> alpako: No, because I want it to work if I do ‚Äò:t ['a']‚Äô and have it come up as String, rather than go from the other way around‚Ä¶ I don't want to know what some alias is, I want to know what something is aliased (although granted you can have multiple &c which is why I doubt you can do that)
09:33:06 <Fuuzetsu> ^ wrong highlight
09:37:57 <stephe> i want to divide 2 Word16s resulting in a Double, but am having problems with converting between all the types... any help?
09:38:42 <ij> Divide?
09:38:52 <tromp__> :t (/)
09:38:53 <lambdabot> Fractional a => a -> a -> a
09:38:58 <tromp__> use fromIntegral
09:39:03 <ij> oh, that division
09:44:45 <stephe> thanks :)
09:45:28 <ij> Is there any place for general computer chatter except for ##programming, in which I'm banned?
09:45:53 <Fuuzetsu> Any channel on Freenode.
09:48:51 <dmilith> hm "You are using a new version of LLVM that hasn't been tested yet!" - can I ignore it?
09:50:02 <simpson> ij: Maybe you should apologize to an op and get unbanned?
09:50:28 <ij> I did that, then I joined, decided I do not want to say anything at this point, after which I got banned for saying nothing.
09:50:32 <ij> yay, unreal!
09:50:47 <ij> s/this point/that point/
09:51:47 <dmilith> cruel world
09:53:33 <ij> I've skimmed over two wiki pages about formal verification, but I understood almost none of it. Where could I read something that I would understand?
09:56:40 <piezoid> dmilith: I always ignored this message (with archlinux versions), you can do the same if you're not compiling to ARM
09:57:27 <dmilith> i'm compiling to fbsd 9.2 x86_x64 code, but through llvm
10:32:16 <fizruk> is there Void :: * -> * ?
10:32:36 <fizruk> Void1, perhaps
10:33:04 * hackagebot data-memocombinators 0.4.5 - Combinators for building memo tables.  http://hackage.haskell.org/package/data-memocombinators-0.4.5 (LukePalmer)
10:33:47 <fizruk> hm... i guess that's Const Void
10:43:41 <lykos_> I'm having a bit of an error exporting data types
10:44:13 <lykos_> I have a record type data Weapon  = Weapon {speed :: Float, dirrection::Float}
10:44:31 <lykos_> and I have it in it's own file with:
10:45:31 <fizruk> lykos_, you can just paste some code
10:45:37 <fizruk> @where paste
10:45:37 <lambdabot> http://lpaste.net/new/haskell
10:45:38 <lykos_> module Weapon (Weapon, speed, dirrection)
10:45:40 <lykos_> but when I import it and use it in another file, I get "Not in scope; Data constructor 'Weapon'
10:45:40 <lykos_> How should I fix this?
10:45:59 <fizruk> lykos_, Weapon(..), speed, ...
10:46:03 <roconnor> lykos_: module Weapon (Weapon(Weapon), ...
10:46:04 <roconnor> or
10:46:16 <roconnor> module Weapon (Weapon(..), ...
10:46:19 <jle`> remember that Weapon on the left side and Weapon on the right side are different things.
10:46:32 <jle`> one is a Type (or a type constructor), the other is a Data constructor.
10:46:48 <geekosaur> you can export a type without its constructors, in order to preserve invariants or hide implementation details (see Map and IO for examples)
10:46:54 <roconnor> more generally the export is Type(Constuctor1,Constructor2)
10:47:03 <roconnor> or Type(..) to export all constructors
10:47:04 <jle`> for example, Maybe(Just, Nothing)
10:47:16 <jle`> i feel like naming constructors and types the same thing is considered harmful.
10:47:47 <jle`> in any case IDE's and highlighters should definitely highlight them different colors.
10:47:56 <roconnor> it is confusing, but not really harmful.
10:48:07 <fizruk> lykos_, note that Weapon(Weapon) won't export speed and direction functions
10:48:07 <roconnor> well, confusing for beginners
10:48:24 <jle`> roconnor: yes, you're right.
10:48:33 <roconnor> Also, if Weapon is a record type, then Weapon(..) will export all field projectors.
10:48:48 <lykos_> Okay, thanks, I didn't realize about Weapon and Weapon being different, thanks.
10:49:04 <jle`> lykos_: remember Maybe?
10:49:10 <jle`> data Maybe a = Just a | Nothing
10:49:21 <fizruk> lykos_, also direction with single 'r' :p
10:49:30 <jle`> the data and the type constructures are different things completely.
10:51:40 <lykos_> Well, it all works fine.
10:52:01 <lykos_> I do have a question about the idomatic way to do something
10:52:11 <lykos_> I have a Show Unique instance
10:52:20 <lykos_> (for the Data.Unique module)
10:52:41 <lykos_> that multiple of my modules need
10:53:05 <lykos_> it appears I only have to declare it in the bottom-most module, and not above, even if I don't export it?
10:53:35 <lykos_> It seems like it's implicitly getting exported (for instance, if I have a Unique data item in Weapon, and Weapon derives show, and I export Weapon)
10:53:54 <geekosaur> instances are global
10:53:55 <danil> lykos_: there's no way to hide instances, they're always exported
10:53:55 <lykos_> How/where is it good form to declare instances for library functions I import?
10:54:08 <lykos_> Okay.
10:54:27 <danil> instances that aren't for a type or a class that you've defined in that module are called "orphan instances" and are generally bad form
10:55:40 <lykos_> Okay. So I guess I shouldn't do Weapon (Unique, etc.) deriving (Show), I should manually make a show instance for it?
10:56:13 <geekosaur> er? that doesn't really change anything
10:56:18 <fizbin> lykos_: No, that's fine. Why wouldn't that be fine?
10:56:49 <danil> Deriving doesn't make instances for anything but the type you add the deriving clause to -- it'll just complain if one of the components can't be Shown, not automatically make an instance for it as well
10:56:54 <lykos_> It won't let me, unless I define my own Unique show instance, it wasn't derived in the library
10:57:18 <lykos_> Because Uniques can't be shown unless I define my own instance
10:57:45 <lykos_> So if it's bad form to make my own show instance for it..?
10:57:55 <fizbin> Ah. So the question is "make a Weapon show instance manually" or "make a Unique Show instance manually so that the Weapon Show instance can be derived".
10:58:56 <fizbin> Okay, in that case, yeah, the derived instance for Weapon probably isn't a good idea. Which isn't too bad with Show.
11:00:11 <lykos_> fizbin: Okay. What if I want uniques to have a show instance though?
11:01:18 <fizbin> Well, then you can certainly do it, but be careful. Playing with orphan instances is the sort of thing that people frown on for a reason.
11:01:49 <lykos_> fizbin: Well, I don't want use bad form here. What would you recommend?
11:01:54 <danil> Sometimes there's no choice but to define an instance for somebody else's type. The reason it's not encouraged though is that if two different people both want an instance Show Unique and define their own, you can't use both of their modules together -- instances have to be globally unique
11:02:25 <fizbin> But it's not a "will likely blow up unexpectedly" reason, more a "that's going to be annoying to dig out later, but may be the best you can do at the time" reason.
11:03:21 <lykos_> Okay. Perhaps if I really needed a show instance for uniques, I could create my own type as a wrapper around it?
11:03:36 <lykos_> like MyUnique or something?
11:03:48 <lykos_> that imports and interfaces with the unique library?
11:04:09 <danil> Yeah, putting a newtype around Unique doesn't cause any problems aside from the pain of either wrapping/unwrapping it or copying the Unique api into a new module
11:05:09 <lykos_> Okay, thanks
11:07:12 <lykos_> In this case, I just removed all my Show instances, as I didn't actually need them now.
11:07:22 <lykos_> If I need them eventually, I'll probably create a wrapper around unique
11:11:51 <yesthisisuser> Does anyone know if there is a way I can get cabal sandbox to work with hdevtools?
11:13:32 <supki> yesthisisuser: yes, there is
11:13:58 <supki> yesthisisuser: assuming you use vim-hdevtools, add "-g -package-db=..." to g:hdevtools_options
11:14:17 <supki> yesthisisuser: where ... is the path to .conf.d directory inside the sandbox
11:14:36 <yesthisisuser> supki: ah.. fantastic. let me try that
11:15:24 <supki> yesthisisuser: example - https://github.com/supki/liblastfm/blob/develop/.vim.custom
11:18:07 * hackagebot data-memocombinators 0.5.0 - Combinators for building memo tables.  http://hackage.haskell.org/package/data-memocombinators-0.5.0 (LukePalmer)
11:20:59 <conal> Did hackage accounts or passwords get reset? My upload attempts are getting denied.
11:21:21 <yesthisisuser> supki: thanks
11:22:04 <conal> oh -- http://hackage.haskell.org/accounts
11:22:06 <geekosaur> conal, as of when? there was a reset when hackage2 went live, if you log in from the web your hackage1 account will be migrated.
11:22:08 <geekosaur> otherwise no
11:41:28 <conal> geekosaur: thanks.
11:53:10 * hackagebot ShowF 0.1.0 - Show for * -> *  http://hackage.haskell.org/package/ShowF-0.1.0 (ConalElliott)
11:53:12 * hackagebot uniform-pair 0.1.1 - Uniform pairs with class instances  http://hackage.haskell.org/package/uniform-pair-0.1.1 (ConalElliott)
11:54:47 <fizruk> conal, why don't you have Homepage in your cabal? :p
11:56:10 <conal> fizruk: I guess I could point to the github repo page.
11:56:43 <fizruk> conal, yeah I meant that :)
11:56:59 <conal> fizruk: thx for the suggestion. i'll do it now.
11:57:37 <kakos> Is there any way to have a data type that takes a list of EXACTLY n elements?
11:57:53 <vektor> wtf is punning?
11:57:58 <geekosaur> not easily
11:58:10 * hackagebot ftree 0.1.2 - Depth-typed functor-based trees, both top-down and bottom-up  http://hackage.haskell.org/package/ftree-0.1.2 (ConalElliott)
11:58:37 <napping> vektor: record stuff
11:58:52 <vektor> I figured that out I think. But that's about it atm.
11:59:10 <vektor> I wanna instance Show my data record. and not all fields are showable
11:59:18 <napping> It's in the user's guide, 7.3.18
11:59:30 <fizruk> vektor, write it yourself
11:59:39 <napping> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-puns
11:59:40 <scott_> Is there a more succint or clear way to generate this result?
11:59:41 <scott_> > sequence [[True,False], [True,False]]
11:59:42 <lambdabot>   [[True,True],[True,False],[False,True],[False,False]]
12:00:04 <ion> > replicateM 2 [True,False]
12:00:05 <lambdabot>   [[True,True],[True,False],[False,True],[False,False]]
12:00:09 <napping> Various extensions allowing shorthand for record patterns like C{a = a, b = b}
12:00:24 <scott_> ion: Ah, that seems perfect, thanks
12:01:05 <fizruk> :t replicateA
12:01:06 <lambdabot>     Not in scope: `replicateA'
12:01:06 <lambdabot>     Perhaps you meant one of these:
12:01:06 <lambdabot>       `Seq.replicateA' (imported from Data.Sequence),
12:03:11 * hackagebot uniform-pair 0.1.2 - Uniform pairs with class instances  http://hackage.haskell.org/package/uniform-pair-0.1.2 (ConalElliott)
12:03:13 * hackagebot ftree 0.1.3 - Depth-typed functor-based trees, both top-down and bottom-up  http://hackage.haskell.org/package/ftree-0.1.3 (ConalElliott)
12:03:15 * hackagebot ShowF 0.1.1 - Show for * -> *  http://hackage.haskell.org/package/ShowF-0.1.1 (ConalElliott)
12:08:39 <Corey> scrollback end
12:29:24 <dgsgs> I'm looking for an array/matrix package that supports the following: (1) lookups and updates of rows, cols, and cells; (2) strings as elements. Is there such a package?
12:31:24 <kakos> Is there an existing function to convert two Word8s to one Word16?
12:33:51 <conal> I see that the new Hackage knows something about change logs ("No changelog available"). Anyone know where it looks for change logs and what format is expected?
12:34:05 <Clint> kakos: runGet getWord16be . pack ?
12:36:25 <quchen> So I just installed a new system, and I ran into the libgmp.so problem (which apparently others seem to have had in the past as well). libgmp-dev is instaled, but I get libgmp.so.10 instead of the quite dated .so.3. GHC doesn't recognize that one and refuses to ./configure.
12:36:39 <quchen> Is the reason for this that the GHC build servers use the old libgmp?
12:37:01 <quchen> Apparently it's fixable with various dirty hacks, but I'd like to try to find a clean way of doing it first.
12:38:14 * hackagebot HaLeX 1.2.1 - HaLeX enables modelling, manipulation and animation of regular languages  http://hackage.haskell.org/package/HaLeX-1.2.1 (joaoSaraiva)
12:43:14 * hackagebot uniform-pair 0.1.3 - Uniform pairs with class instances  http://hackage.haskell.org/package/uniform-pair-0.1.3 (ConalElliott)
12:44:18 <kakos> Clint: That works perfectly. :) Thanks.
12:48:14 * hackagebot uniform-pair 0.1.4 - Uniform pairs with class instances  http://hackage.haskell.org/package/uniform-pair-0.1.4 (ConalElliott)
12:48:25 <conal> (now with changelog)
13:08:26 * hackagebot HPi 0.3.0 - GPIO and I2C functions for the Raspberry Pi.  http://hackage.haskell.org/package/HPi-0.3.0 (WJWH)
13:14:32 <viki_> can someone explain me the concept of currying?
13:14:58 <viki_> scan1 :: (a->b->b) -> (a->b) -> [a] -> [b]
13:15:05 <viki_> scan1 f g = fold1 f' g'
13:15:10 <viki_>  where g' a   = [g a]
13:15:16 <viki_> f' a s = f a (head s) : s
13:15:32 <tovarish> viki_, f x = g x <=> g = g
13:15:32 <viki_> fold1 :: (a->b->b) -> (a->b) -> [a] -> b
13:15:34 <tovarish> viki_, f x = g x <=> f = g
13:15:40 <tovarish> oups
13:16:40 <viki_> tovarish: in the scan1 example i ve given,
13:17:04 <viki_> can u explain with that?
13:17:58 <viki_> my doubt is fold1 type says that it expects 3 arguments.. but inside scan1, it has only 2
13:18:17 <viki_> arguemnets
13:18:31 <geekosaur> eta reduction
13:18:58 <geekosaur> if the things on both sides of the = both end in x, you can leave x off both sides
13:19:33 <geekosaur> so you could read that line as: scan1 f g x = fold1 f' g' x
13:19:47 <viki_> oh..
13:20:04 <geekosaur> (and the compiler knows from the type signature that you are doing this, because scan1 takes 3 parameters but you only gave 2)
13:20:06 <viki_> then how ll the value to s be passed?
13:20:11 <NightRa> Hello everybody!
13:20:21 <NightRa> Is anyone here femiliar with Lamdu?
13:21:40 <geekosaur> viki_, I do not understand your question about s
13:22:24 <JuanDaugherty> viki wants direction to the wiki article on currying and ur feeding her eta reduction
13:22:57 <simpson> viki_: Consider a type signature: a -> b -> c
13:23:08 <simpson> viki_: Currying is the realization that this is actually: a -> (b -> c)
13:23:13 <geekosaur> they asked about currying and then showed (pasted in channel, sigh) an example that is related to currying but isn't quite
13:23:25 <simpson> viki_: In other words, this is a function taking one argument and returning *a function which takes one argument*.
13:23:27 * hackagebot snap 0.13.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.1 (DougBeardsley)
13:23:29 * hackagebot Nutri 0.1 - A little library to calculate nutrition values of food items.  http://hackage.haskell.org/package/Nutri-0.1 (frosch03)
13:23:34 <geekosaur> or did you just ignore that part and focus on the mentiuon of currying?
13:33:41 <tovarish> viki_, it's just the different step of foldl (or something like that)
13:33:57 <NightRa> Is anyone here femiliar with Lamdu?
13:49:07 <quchen> NightRa: Peaker is a Lamdu dev I think.
13:49:31 <quchen>  @call-peaker -- We really need a generic version of this!
14:08:51 <dwcook> Is there any practical reason that application can't be overloaded? e.g., (a -> b) -> a -> b and (Applicative f) => f (a -> b) -> f a -> f b would be specializations of it.
14:09:47 <dwcook> The syntax would then permit: Just (+1) (Just 1) to give the result Just 2.
14:09:56 <dwcook> Hmm, maybe a bit ugly.
14:10:09 <dwcook> Though it could obviously be done with variables as well.
14:10:19 <NightRa> Is Peaker here?
14:10:27 <ReinH> dwcook: it's hard enough to know what (+) you are using, let alone what space...
14:11:09 <ReinH> overloading whitespace sounds conceptually untenable but maybe that's my puny monkey brain talking
14:11:24 <dwcook> ReinH, what problems with (+) are you referring to?
14:11:43 <ReinH> dwcook: I just mean in general, what does x + y mean?
14:11:59 <dwcook> Depends on what x and y are.
14:12:00 <ReinH> sum / length could easily be operating in some strange applicative without you knowing it
14:12:13 <dwcook> Fair point.
14:12:33 <ReinH> in fact didn't edwardk demonstrate one?
14:12:34 <scott_> There's a thing called idiom brackets which allows "f <$> x <*> y" without the operators, iirc. I don't think they're implemented in GHC.
14:12:41 <scott_> Maybe with TH?
14:12:42 <ReinH> banana brackets? ;)
14:12:50 <ReinH> (| f x y |)
14:12:57 <levi> scott_: Not with TH, but with a custom preprocessor.
14:13:13 <scott_> I just found http://hackage.haskell.org/package/applicative-quoters-0.1.0.8/docs/Control-Applicative-QQ-Idiom.html
14:13:25 <levi> ghc lets you plug in arbitrary pre-processors in the compile phase.
14:14:11 <levi> Oh, didn't know about that one.  I was thinking of SHE.
14:14:18 <scott_> What's SHE?
14:14:25 <ReinH> that's not bad
14:14:48 <levi> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/
14:15:13 <scott_> Ah, interesting
14:15:45 <dgsgs> I'm looking for an array/matrix package that supports the following: (1) lookups and updates of rows, cols, and cells; (2) strings as elements. Is there such a package?
14:16:06 <ReinH> dwcook: abusing Num and Fractional for fun and profit :)
14:16:22 <ReinH> dgsgs: have you tried array?
14:16:51 <ReinH> Any data structure you find is almost certain to be parameterized, allowing (2)
14:17:59 <dgsgs> ReinH: I've looked through; it doesn't seem to provide updates/lookups for cols and rows.
14:19:51 <levi> Another interesting pre-processor is hsx2hs, which lets you use XML literals in your haskell code.
14:20:41 <dwcook> ReinH, what's your favorite abuse?
14:21:06 <ReinH> lifting operations into an applicative
14:21:18 <ReinH> sum / length can calculate in parallel
14:21:42 <skypers> ahah
14:21:55 <skypers> I‚Äôm just having an intersting talk about design in Haskell programs
14:22:07 <skypers> a dude is saying that he‚Äôs written a program
14:22:10 <skypers> in Haskell, in two hours
14:22:24 <skypers> suddenly, he decided to add logging to some huge pure code
14:22:42 <skypers> and he thinks it‚Äôs a huge mess because he would have to change a lot of code just for a logging feature
14:23:24 <dgsgs> ReinH: Will it be haskell-y to sequence several writeArray actions to update a col, for instance?
14:23:48 <ReinH> dwcook: like edwardk's data Reducer a b = forall m. Monoid m => R (a -> m) (m -> b)
14:23:51 <dgsgs> Ideally, I'd rather avoid the IO monad.
14:24:07 <ReinH> dgsgs: how large are your arrays/matrices?
14:26:14 <dgsgs> ReinH: I don't expect them to be larger than 100 x 100. But I also don't want to rewrite everything if someone decides to use something larger.
14:27:03 <vektor> hey. Purge my imperative-programming mind. I wanna define a function later that I know will comply with some specific type signature. I.e. define interface now, implement cmplying function later (but before compile-time)... how would I do this in haskell?
14:27:37 <dgsgs> foo :: Type
14:27:39 <dgsgs> foo = undefined
14:27:40 <dgsgs> ?
14:27:40 <Iceland_jack> vektor: You can define it as ‚Äòundefined‚Äô
14:27:48 <ReinH> type Row a = [a]; type Matrix a = [Row a]; rows :: Matrix a -> [a]; rows = id; cols :: Matrix a -> [a]; cols = transpose
14:27:55 <monochrom> or, foo = error "TODO"
14:28:35 <vektor> monochrom: well, not quite like that. I like your style, it's just that it's an interface, and I don't care who implements it, as long as he does.
14:28:52 <monochrom> you do not have to purge your imperative programming mind. just don't let it monopolize.
14:29:13 <ReinH> take advantage of cols . cols = id to provide _cols = iso cols cols and so on
14:29:21 <Peaker> NightRa: now I'm here, hey :)
14:29:27 <donri> vektor: type classes do that, but beware of the infamous existential anti-pattern
14:29:30 <vektor> can I have multiple possible functions in place of foo? (given I have a way of telling them apart, let's just enumerate them. I don't know how many there are when writing this thogh)
14:29:49 <monochrom> I guess I don't understand the question.
14:30:28 <dgsgs> ReinH: I've already written something like that. But imagine if you want to swap two columns or just update a single one. I ended up using headOfList ++ updatedParted ++ tailOfList, which doesn't look good.
14:30:30 <vektor> donri: that sounds more like my style of doing it. Thank you. Which antipattern, exactly, should I be aware of?
14:30:49 <bartavelle> is there a way to find all types in hackage that are at the same time Monoid and NFData ?
14:30:51 <donri> vektor: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
14:31:22 <Philippa> skypers: you just discovered why a lot of us go applicative and/or monadic early :-)
14:31:40 <Philippa> (once you've done that, bolting on something like logging that needs its own dataflow piping is easy)
14:31:47 <ReinH> dgsgs: lenses will help
14:32:30 <Philippa> for that matter: if you wrote it in two hours, it's probably not going to take another two to get enough of the code into applicative or monadic style to run it in a Writer and then add the logging info
14:32:39 <Philippa> (at least, not if you've done this before)
14:33:31 <skypers> Philippa: what do you mean?
14:33:47 <skypers> yeah
14:33:52 <monochrom> if logging is an afterthought, well, tautologically, all afterthoughts are hard, yes.
14:33:53 <skypers> it‚Äôs what I said
14:34:03 <vektor> donri: tldr ?= "Don't spam typeclasses just because"
14:34:07 <skypers> he keeps saying Haskell sucks because of that
14:34:17 <Philippa> it's also a lot easier to add new concerns once you've done that transformation once
14:34:53 <EvanR> > (1,2) + (3,4)
14:34:55 <lambdabot>   No instance for (GHC.Show.Show t1)
14:34:55 <lambdabot>    arising from a use of `M7868311952635...
14:35:05 <Philippa> monochrom: yeah, but it's pretty much a linear-time refactor through the spine of the code that actually needs to log
14:35:12 <dgsgs> ReinH: Hm, haven't thought about that. Now I have two problems...
14:35:20 <ReinH> dgsgs: :p
14:35:28 <dgsgs> ReinH: Thanks for your help!
14:35:32 <Peaker> Philippa: By going monadic, you mean have your combinators expose an Applicative/Monadic interface instead of a pure function? e.g:  sortBy :: Monad m => (a -> a -> m Bool) -> [a] -> m [a]   vs. the pure sortBy?  Because for pure non-combinators, I am not sure what going monadic would be
14:35:35 <Philippa> and once you've done that, little things like /turning the code completely inside out/ can be done in a line or two
14:36:20 <Philippa> Peaker: It's enough to have them running inside a monad making calls to >>= between any operations that might need to log
14:36:36 * hackagebot hackport 0.3.5 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.3.5 (SergeiTrofimovich)
14:36:55 <Philippa> (the complications only ever arise with higher-order code, of course)
14:38:00 <ReinH> dgsgs: np :)
14:38:26 <Peaker> Philippa: so for the (currently) pure operations, just sticking a "return" on the result, so that users use with (>>=) so that later it can log, I see
14:39:16 <monochrom> I also wonder why adding logging to a pure computation can be an afterthought to begin with. (I am not talking about adding logging to an already effectful computation. that one is easier.)
14:39:22 <Philippa> you put return /in/ the "result" when it's a named thing, not around it. The whole point is that thing-that-might-log needs to know it's in the monad, even if it's currently Identity
14:40:09 <monochrom> I'm thinking, like, on day 1 you write a pure function for the quadratic formula, then on day 2 you suddenly want to log "how many times I use sqrt"
14:40:12 <Philippa> monochrom: "ohshit, I suddenly need instrumentation because I'm not sure how this is working"
14:40:18 <monochrom> like, do people really do that?
14:40:20 <Peaker> Philippa: that's what I meant, iiuc:  foo :: Monad m => ... ; foo = return $ pureFoo .. where pureFoo = ...
14:40:56 <skypers> 23:25 < Peaker> Philippa: By going monadic, you mean have your combinators expose an Applicative/Monadic interface instead of a pure function? e.g:  sortBy :: Monad m => (a -> a -> m Bool) -> [a] -> m [a]   vs. the pure sortBy?  Because for pure non-combinators, I am not  sure what going monadic would be
14:40:57 <monochrom> and I am also not talking about diagnostic purposes. we already have Debug.Trace for that.
14:40:58 <Philippa> Peaker: that's still only really okay if pureFoo is either non-recursive or something you're /utterly certain/ isn't a potential... well, AOP folks talk about joinpoints
14:41:01 <skypers> Identity?
14:41:10 <skypers> monochrom: I said that
14:41:14 <skypers> Debug.Trace
14:41:17 <skypers> and he answered
14:41:24 <Philippa> monochrom: Not all diagnostics want Debug.Trace
14:41:27 <skypers> ‚Äúyeah but can you syslog with that?‚Äù
14:41:30 <Philippa> really not kidding there
14:41:59 <Hodapp> Haskell bullshit generator that I just wrote says: "intelligence simulation from the platform of e-business programming by bringing a new generation of social customer-focused support paradigm"
14:42:02 <Philippa> skypers: the Identity monad is the one that's the same as working in ordinary Haskell, just in monadic style
14:42:14 <monochrom> of course I agree that Debug.Trace and syslog are unrelated
14:43:08 <Philippa> not everything you want to "log" is a string, either
14:43:16 <monochrom> but syslog is exactly not supposed to be an afterthought. "log to syslog" is supposed to be right there in the specification version 0.
14:43:31 <ReinH> > let _cols = involuted transpose in [[1,2],[1,2]]^._cols -- dgsgs
14:43:32 <monochrom> or perhaps I'm just a waterfall old-geezer.
14:43:32 <lambdabot>   [[1,1],[2,2]]
14:43:37 <meiji11> is there support for C-styles string formatting for bytestrings available somewhere?
14:43:45 <skypers> monochrom: yeah so
14:43:53 <skypers> what‚Äôs the counter-argument?
14:44:08 <monochrom> sorry, counter-argument for ... ?
14:44:10 <Philippa> monochrom: it's really not that uncommon to go from "hey, I've got a basic type-checker" to "right, I'd like all these features that involve /totally changing the real control and data flow/" if you're going from a research phase to productisation
14:44:26 <skypers> he keeps saying that ‚ÄúI don‚Äôt foresee to log thinks, then when I want to add logging in ocaml, it takes me 3s. In Haskell it takes me hours‚Äù
14:44:44 <anon351> hi
14:45:15 <Rembane> Hodapp: That's a phrase that makes money.
14:45:29 <Hodapp> Rembane: Then I've a program that generates money.
14:45:39 <Philippa> skypers: write in monadic style by default, just use identity as your default monad. If you're parametric across all monads, you're pure if you want it.
14:45:50 <monochrom> Philippa: that transition implies a completely new specification to begin with. I expect a completely new specification implies completely new work.
14:45:57 <Hodapp> Rembane: Furthermore, since it's based on an FSM, I could just remove the terminal state and have it generate and infinite stream of money!
14:46:01 <Rembane> Hodapp: Well, that depends on if the equality operation is transitive for programs, money and bullshit.
14:46:48 <Hodapp> though my Python version of that program came out with a disturbing number of phrases that resembled "maximizing profits through moral flexibility"
14:46:53 <Philippa> monochrom: whereas in my experience, specifications often have common elements that all you to refactor an implementation of one into part of an implementation of the other
14:47:00 <Philippa> *allow you to
14:47:31 <skypers> Philippa: go one just should work with monadic code
14:47:39 <Philippa> I'm damned if I'm writing out the rules for the simply-typed lambda  calculus /again/. And if I'm having to write them out sprinkled with other stuff just to say that's what I'm type-checking, Perlis says my code's low-level
14:47:41 <skypers> and forget about non-monadic?
14:47:44 <skypers> it‚Äôs bazooka
14:48:07 <Philippa> skypers: it's a dial-a-nuke that goes right down to "only took one wing off a mosquito"
14:48:21 <ReinH> > let _cols = involuted transpose in over _cols (set (ix 0) [5,5,5]) [[1,2,3],[1,2,3],[1,2,3]] -- dgsgs
14:48:22 <Hodapp> so, -ddump-cmm is supposed to dump the generated Cmm but I can't see where it might be dumping that...
14:48:22 <lambdabot>   [[5,2,3],[5,2,3],[5,2,3]]
14:48:27 <Philippa> (also: when code can live in the applicative fragment, it should go ahead and do so)
14:48:35 <ReinH> dgsgs: lots of ways to work with rows and columns using a lens
14:48:50 <ReinH> dgsgs: and if your underlying representation changes and you work fluently with lenses, you just need to update the lenses
14:49:04 <Hodapp> where does GHC dump things?
14:49:14 <dgsgs> ReinH: hey, I wanted to write it myself!  (just kidding)
14:49:18 <ReinH> dgsgs: :p
14:49:20 <monochrom> skypers: at that point, I'll say this, and let the person choose his/her poison. programming is always a tug war between writer's cavalier power and reader's predictive power. in concrete, with ocaml "f : int -> int", the writer is free to add and remove logging, therefore the reader has to work harder to figure out whether it does logging. haskell is the opposite. so it comes down to: are you on the writer's side or the reader's side?
14:49:58 <ReinH> monochrom: add logging, fire the missiles, etc
14:50:06 <Rembane> Hodapp: The Haskell program seems much less scary. :)
14:50:11 <Philippa> monochrom: certainly I'll get snarky about someone wanting to log the inside of a library data structure's operations
14:50:18 <Hodapp> Rembane: I've only run it 10-15 times though...
14:50:57 <Philippa> "am I doing basic data structure ops or stuff that looks like specific program here?" is a reasonable guideline for whether you should go pure style or anticipatory monadic
14:51:07 <Philippa> the latter is a lot more likely to see spec changes
14:51:10 <monochrom> Philippa: when specifications change, I first expect a lot of work. and then, if I find out that there is really less work, I call it windfall savings. :)
14:51:46 <Rembane> Hodapp: Maybe they all converge to something really scary
14:52:04 <Philippa> monochrom: I intentionally plan against things I might want to do later. I just plain don't get the system I'd like to have all built at once, so finding a path that'll get built at all matters
14:52:10 <monochrom> good guideline there
14:52:24 <Philippa> monochrom: in that regard, knowing how to get instrumentation on the cheap is an extremely useful thing
14:52:30 <zennist> Do I get functions like mapM for free when I implement the Functor class?
14:52:41 <zennist> Or do I have to write for that as well..?
14:52:44 <Hodapp> hrmph... still can't get ghc to dump the Cmm output
14:53:14 <Philippa> (but hey, I'm the deranged person who looked at the 2007 SoC proposals, decided the ones to alter Parsec weren't doing enough, /merged/ them and produced a parsing library you can happily have pause itself mid-parse and resume with a different input)
14:53:29 <Philippa> (oh, and it doesn't know anything about pausing itself)
14:53:50 <Hodapp> Pars- oooh a squirrel?
14:53:54 <Philippa> ("produced" is unfair, sorry: xerox did the coding)
14:54:08 <skypers> hm
14:54:46 <Philippa> Hodapp: it's useful if you've got an edit half way through a string and want to do less work. Even better with something targetting a more specific range of languages that'll figure out when it can reuse the rest of its old parse tree, admittedly
14:54:48 <skypers> the frustrated dude said that the reader doesn‚Äôt give a damn about whether the function logs because it doesn‚Äôt change its semantic nor behavior, monochrom
14:55:13 <Hodapp> Philippa: sorry, I quit reading halfway through and started reading skypers' line
14:55:16 <Philippa> someone's never had windows tell them they don't have enough disk space free to delete a file
14:55:48 <Philippa> (which is to say: yes it bastard well does change its semantics and behaviour, and the fact Haskell lets you /parameterise over that/ is intensely useful)
14:55:49 <Rembane> Philippa: That's really cool.
14:56:13 <monochrom> skypers, when I am a reader and I see something in my /var/log/syslog, I need to know which line of code causes them, or put it more pessimistically, which lines of code cannot possibly cause them so I can narrow down.
14:56:21 <Philippa> Rembane: one of those "thank fuck I know what a sector hex editor is for and how FAT works" moments
14:57:13 <Philippa> skypers: your friend wants equivalence up to logging, and is annoyed that Haskell wants you to say that out loud
14:57:15 <anon351> how to make a function that is returning [a] to make it return Maybe [a]?
14:57:17 <mp> is it possible to use Data.Time.LocalTime in fay?
14:57:32 <Philippa> (I can sympathise with the part about the syntactic noise involved in the transformation!)
14:57:40 <Philippa> (Languages like Eff and Frank do better there)
14:57:50 <monochrom> "no change in semantics or behaviour" is a self-deception for the only purpose of winning this debate. clearly, if "it has to log, and it has to go to syslog" is in the specification, then logging is an integral part of "semantics" and "behaviour".
14:58:18 <monochrom> law of excluded middle. logging is either in the specification, or not.
14:58:39 <c_wraith> "what's a specification?"
14:58:51 <monochrom> perhaps I'm being just a logical, waterfall old-geezer
14:59:22 <JuanDaugherty> right they call that splitting
14:59:59 <ReinH> Not sure if I prefer the infix operator version: m & _cols %~ ix 0 .~ [5,5,5]
15:00:01 <JuanDaugherty> in the real world truth values are often continuous
15:00:32 <skypers> 23:47 < Philippa> skypers: your friend wants equivalence up to logging, and is annoyed that Haskell wants you to say that out loud
15:00:40 <skypers> yeah, but he has points
15:00:44 <skypers> like
15:01:06 <skypers> in Haskell, it would make it annoyed to add a single log feature whereas it wouldn‚Äôt in ocaml
15:01:10 <ReinH> anon351: I assume you want something other than "use the Just constructor"?
15:01:21 <monochrom> you can always discretize. here is an example. "logging would be nice". ok, so let's say logging is not in the specification for version 2.1, but is for version 2.2. there, now it is not continuous.
15:01:38 <ReinH> anon351: iow, why doesn't `f' = Just . f' work for you?
15:01:44 <JuanDaugherty> (the opposite is generally the case in matters of principle)
15:01:49 <ReinH> er f' = Just . f, confusing use of quotes
15:02:35 <JuanDaugherty> the truth concept itself being crisp
15:02:56 <Philippa> skypers: yeah. The syntactic overhead in shifting to monadic style. You can't just say "I want this as completely-parametric monadic code instead of 'pure' now"
15:03:02 <monochrom> you always bloody have to discretize in the real world. because, clearly, your program is digital not analog. bring your "real world is continuous" slogan to the op-amp people, they will love you.
15:03:05 <ReinH> skypers: your friend is acting like purity is a pessimasation when in fact it's a principled way to resolve various tensions.
15:03:15 <anon351> ReinH, ill try, ty
15:03:24 <ReinH> It's not the case that enforced purity just means "well shit logging is harder for no good reason"
15:03:27 <ReinH> there are lots of good reasons
15:04:15 <ReinH> And the fact that your friend has never had to think about the ramifications of adding effects to their code doesn't mean that there aren't ramifications
15:04:21 <ReinH> or that dealing with them in a principled way has no value
15:04:22 <Philippa> ReinH: eh. "This'll run in any monad including Identity" implies purity too
15:04:36 <skypers> 23:53 < ReinH> skypers: your friend is acting like purity is a pessimasation when in fact it's a principled way to resolve various tensions.
15:04:39 <skypers> well
15:04:53 <Philippa> really: this is a valid criticism of Haskell, it's just one that's best dealt with by accepting it'll happen sooner or later and getting applicative/monad-happy early on
15:04:55 <skypers> he‚Äôs saying he‚Äôd prefer a more controllable impure code
15:05:12 <Philippa> cool: this is what do notation provides :p
15:05:21 <skypers> like allow people to write safe IO code
15:05:23 <skypers> like logging
15:05:24 <Philippa> (but also what a range of research languages do)
15:05:29 <skypers> I actually disagree
15:05:34 <skypers> but hm, it‚Äôs interesting
15:05:34 <Philippa> "safe IO code". We show it's safe how?
15:05:36 <ReinH> skypers: One decision that Haskell made early on is that there is no such thing as "somewhat pure" code. It's either pure or it isn't, and Haskell choose to make the boundary impermiable.
15:05:39 <monochrom> controllable impure code. guess what, sometimes I want safe unsafe programs too.
15:05:52 <Philippa> or do we just mean "those impure things you've been given capabilities for"?
15:05:58 <ReinH> *chose
15:06:10 <Philippa> ReinH: that's... a worrying misconception
15:06:14 <int-e> well, we have the ST monad :)
15:06:19 <Philippa> it's *all* pure. It might embed a description of something impure.
15:06:32 <Philippa> it might be possible to execute those descriptions in a pure manner.
15:06:39 * hackagebot git-annex 5.20131127 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20131127 (JoeyHess)
15:06:39 <napping> skypers: I think the key point people are making is that yes there is some amount of work but it's not reasonable to say that's the cost for logging, or even worse to think that things more complicated than logging would take more effort
15:06:40 <ReinH> Philippa: the boundary between effectful and non-effectful, then
15:06:42 <Philippa> (but not if they involve missiles or saying hello to the world)
15:06:52 <Philippa> ReinH: recursive let would like a word with you :p
15:07:05 <Philippa> (I take it you don't consider non-termination an effect? Others do)
15:07:09 <ReinH> Philippa: that's fair
15:07:17 <napping> skypers: rather, there is a fixed and unpleasantly high up-front cost to switching to the style that's needed to allow any effects at all
15:07:26 <Philippa> the point is, "effectful" is always an embedded notion
15:07:30 <Philippa> it's just not native to Haskell
15:07:31 <ReinH> Philippa: But I'm unsure if your criticism is pedantic or fundamental, or both ;)
15:07:39 <Philippa> yes :p
15:07:47 <napping> skypers: then once you've done that, the actual logging bit should be easy. Or equally easy if you decided you needed to add continuations or nondeterminism
15:07:51 <ReinH> Philippa: ok :)
15:07:59 <napping> how easy is it to drop backtracking search into existing O'Caml code?
15:08:07 <int-e> > error "gets to the bottom of haskell"
15:08:08 <lambdabot>   *Exception: gets to the bottom of haskell
15:08:24 <Iceland_jack> > error "gets to the ‚ä• of haskell"
15:08:24 <Philippa> napping: and of course, it's only painful /because you have the option of having known-pure code in the middle of all that still/. Which is immensely useful.
15:08:25 <lambdabot>   *Exception: gets to the ‚ä• of haskell
15:08:41 <Philippa> ("hey, at least operating on this tree isn't going to say hello to the world with a bunch of missiles")
15:08:46 <ReinH> Philippa: my point is that Haskell chose purity over convenience
15:08:58 <Philippa> ReinH: sure. It's 2013 though, and we can have both now
15:09:09 <Philippa> (albeit not in a language as well-developed as GHC Haskell is)
15:09:44 <napping> skypers: well, I guess O'Caml does give you call/cc and state, so you're pretty much set for odd effects
15:09:47 <ReinH> Philippa: we've come a long way from SPJ's "safe but useless" :)
15:10:28 <ReinH> Philippa: but lots of the modern developments in that area (like Mio) are only doable in a principled way because of Haskell's safety
15:10:58 <zennist> Hi I need somebody to advise me on the design of a data type. I have a data type, say (MultiStack a); I've now implemented Functor so I can use fmap on it; but I want to go a step further so that if I have (MultiStack (m a)) I can obtain m (MultiStack a) in a single step; just like mapM for lists. What should I do?
15:11:18 <Philippa> ReinH: I won't claim Haskell hasn't been a historically important playground!
15:11:26 <napping> zennist: implement Traversable
15:11:34 <ReinH> or derive it :)
15:11:45 <skypers> 23:58 < napping> skypers: then once you've done that, the actual logging bit should be easy. Or equally easy if you decided you needed to add continuations or nondeterminism
15:11:48 <Philippa> FWIW, my recommendation for an "it would be nice if this language had GHC's level of development" to play with would be Frank. Or there's an embedding of something similar into Idris
15:11:50 <ReinH> you can derive Functor, Foldable and Traversable
15:11:50 <skypers> I totally agree
15:11:58 <skypers> I‚Äôve just stopped talking with him
15:12:02 <ReinH> Philippa: cool :)
15:12:14 <skypers> he kept saying ‚ÄúHaskell is a masturbation language‚Äù
15:12:23 <ReinH> skypers: you can lead a horse to water
15:12:29 <ReinH> but you can't make them not say stupid things
15:12:29 <skypers> personally
15:12:35 <skypers> I use Writter and WritterT
15:12:40 <skypers> and it perfectly fits my needs.
15:12:49 <ReinH> skypers: I use Writest. You've probably never heard of it.
15:12:50 <skypers> yeah ReinH
15:12:54 <skypers> nope
15:13:03 <ReinH> It is the monoidiest.
15:13:07 <Philippa> mmm. And for bonus points, you can recover totally pure code by supplying a dummy implementation that leaves you with the underlying monad and throws away the logs
15:13:15 <zennist> napping: But before that I also have to implement Foldable for it; is that true?
15:13:19 <napping> yeah
15:13:30 <napping> well
15:13:38 * ReinH wonders if you can do cool things with a Kliesli Writer
15:13:38 <Philippa> (the "log here" calls being the most invasive change)
15:14:31 <ReinH> zennist: try just deriving them
15:14:46 <napping> there might be a default implementation of e.g. foldMap in terms of the Traversable methods
15:15:31 <ReinH> napping: Traversable provides foldMapDefault
15:15:38 <ReinH> and fmapDefault
15:15:42 <napping> ah, that's where it is
15:15:49 <ReinH> any Traversable is also a Foldable and a Functor
15:16:35 <napping> zennist: the point of those is that even if you can't derive Traversable, once you've defined it you can just say "instance Foldable MultiStack where foldMap = foldMapDefault"
15:16:40 <ReinH> but seriously, try deriving Traversable with the DeriveTraversable pragma
15:18:19 <napping> Is there any good way to have types for various subsets of a collection of constructors?
15:20:39 <Cale> napping: By refactoring your types perhaps
15:20:50 <napping> I've been doing the data types a'la carte thing, but pattern matching is pretty ugly
15:21:11 <ReinH> Also if it's a Traversable you can get a lot of nice lenses
15:21:16 <Cale> (and introducing constructors for each of the hopefully-disjoint subsets of the constructors of your original type)
15:22:21 <napping> ReinH: is that a suggestion for me?
15:22:52 <skypers> I still wonder about that logging stuff
15:23:05 <skypers> it‚Äôs a solid point he points out there
15:23:11 <zennist> ReinH: thanks, it's amazing that I just used derive to get all those things for free
15:23:17 <skypers> even if I think logging could be foreseen
15:23:30 <skypers> and then use Writter from the beginning
15:23:37 <zennist> till this day it keeps amazing me for what can be 'Derived'
15:23:57 <napping> skypers: the suggestion was more like make most of the code polymorphic in what monad is actually used
15:25:41 <napping> and more generally whether laziness / order independence / equational reasoning in pure code is worth splitting it from effectful code
15:26:02 <napping> If you're willing to be strict and fix and evaluation order, then you might as well slap on an effect system and stuff
15:26:04 <monochrom> skypers: I disagree that it is a solid point at all.
15:26:38 <monochrom> likewise, when a capitalist and a communist are arguing, I consider neither points to be solid at all.
15:27:05 <JuanDaugherty> that should be temporally grounded
15:27:06 <napping> ReinH: I suppose I could wrap up the inject and extract function for the sums as a Prism, maybe with a fancy typeclass
15:27:09 <skypers> so it‚Äôs not a point considering that not a point! :D
15:27:24 <JuanDaugherty> a capitalist and communist in 1950 say vs. 2012
15:27:24 <monochrom> programming is a dialectic class struggle between the writer and the reader. you can state your favourite tradeoffs. but nothing is solid. nothing.
15:27:49 <Tinned_Tuna> heya, it seems that the GHC 7.4.2 manual doesn't match what my GHC actually does, specifically http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/prof-heap.html; I only have +RTS -h -RTS, no other heap profiling options are recognised
15:28:10 <monochrom> I side with the reader. but even I don't consider my stance to be solid. therefore, his is not solid either.
15:28:11 <xenon-> I am curious, is there a language that has both? which one?   <ReinH> Philippa: my point is that Haskell chose purity over convenience <Philippa> ReinH: sure. It's 2013 though, and we can have both now
15:28:31 <JuanDaugherty> Tinned_Tuna, most people I dare say have migrated to 7.6.3 by now
15:29:19 <monochrom> Tinned_Tuna, make sure you're reading the correct manual version?
15:29:38 <Philippa> xenon-: There're research languages that do, yeah. Frank is a good example
15:29:43 <napping> Cale: I suppose at the cost of two layers everywhere I could at least use the same names for the inner constructors, and just need to pick distinct names for the bundle when defining injections
15:29:52 <Philippa> (if anyone managed to get a video of Conor doing his talk about it, it's worth seeing)
15:30:41 <napping> but if I use view patterns more heavily I'm not sure it will turn out that much nicer - I also want both the fixpoint and the free monad of at least some of the subsets
15:31:13 <Tinned_Tuna> JuanDaugherty: unfortunately, it's the packaged version
15:31:34 <Tinned_Tuna> monochrom: I'm fairly certain, I ghc --version shows 7.4.2, and the URL above shows 7.4.2
15:31:46 <JuanDaugherty> you mean haskell platform? I believe it's using 7.6.3
15:32:00 <xenon-> Philippa in what way is Frank's equivalent of IO in haskell more convenient? if it is possible to summarize it in a sentence or two
15:32:15 <skypers> ok well
15:32:19 <skypers> I can‚Äôt even read anymore
15:32:20 <Tinned_Tuna> JuanDaugherty: I'm on Linux Mint 14 -- the packaged version from apt is 7.4.2
15:32:28 <skypers> exhausted as f*c*
15:32:28 <napping> are pattern synonyms in for 7.8?
15:32:36 <skypers> talk to you later
15:32:37 <skypers> night
15:32:52 <monochrom> skypers: I have another example. if you have heard of the "expression problem", you already know what I'll talk about. in an OOP language, I could yell "why is it so hard, I have to edit 10 classes to add 1 method to all of them". but my arch-enemy could yell the opposite about a functional, algebraic-data-type language.
15:32:56 <JuanDaugherty> ah that's what you meant. That's not a linux distro that can be a standard for anything
15:33:12 <Saizan> Philippa: can you do ContT in Frank?
15:33:19 <JuanDaugherty> they all tend to be down level
15:33:25 <monochrom> there is absolutely nothing about what I yell and what my arch-enemy yells.
15:33:28 <monochrom> err
15:33:32 <monochrom> there is absolutely nothing solid about what I yell and what my arch-enemy yells.
15:34:07 <Tinned_Tuna> JuanDaugherty: aye, I but I was wondering if I am looking at the canonical source of information for profiling GHC 7.4.x with the link above?
15:34:40 <JuanDaugherty> well the down levels of the docs are available, you have to match them
15:34:41 <Tinned_Tuna> JuanDaugherty: worryingly, in the TOC for those docs: "1.5. Release notes for version 7.2.1" ¬¨.¬¨
15:34:55 <JuanDaugherty> yourself
15:34:57 <Tinned_Tuna> oop, my bad, it continues after htat
15:35:06 <Tinned_Tuna> down levels of the docs?
15:35:24 <JuanDaugherty> the one matching the binaries with the Mint distro
15:35:34 <JuanDaugherty> 7.4.2 apparently
15:36:22 <Philippa> Saizan: I believe so, yeah
15:36:35 <JuanDaugherty> Tinned_Tuna, because 7.6.3 is the current level
15:36:37 <Tinned_Tuna> JuanDaugherty: and http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/index.html are the docs, but I can't seem to get the profiling RTS flags to work :-/
15:36:38 <Philippa> not that I've written it myself, but I can't see how it wouldn't be "just another handler"
15:36:41 * hackagebot cryptsy-api 0.1 - Bindings for Cryptsy cryptocurrency exchange API.  http://hackage.haskell.org/package/cryptsy-api-0.1 (bss)
15:37:01 <Philippa> (Frank's handlers are structured like a mild rearrangement of monad transfomers)
15:37:21 <JuanDaugherty> Tinned_Tuna, maybe something wasn't included needed for it in that distro
15:37:44 <tarruda> does anyone knows how to use ghc-mod to get the function names for an .hs file?
15:38:00 <Tinned_Tuna> JuanDaugherty: ah, so GHC may've been built by the package maintainers with the profiling tools excluded -- that would explain a fair bit
15:38:57 <Saizan> Philippa: i guess i'd have to try, ContT isn't easy with free-monady stuff
15:40:48 <Philippa> Saizan: you just define what bind of each of the relevant operations (return included) is
15:46:10 <monochrom> Tinned_Tuna: which options are not recognized? I tried -h, and I tried -hy, they looked ok.
15:47:07 <Saizan> Philippa: i guess it boils down on if you can have higher order stuff as operations, e.g. join would be the simplest
15:50:54 <Tinned_Tuna> monochrom: nothing except for -h was working for me; just to check I'm doing it right, I compile the program with -rtsopts, then call it with +RTS -h -RTS (or +RTS -hy -RTS, or others)?
15:51:33 <c_wraith> you don't need the -RTS unless you're passing non-rts arguments as well
15:51:39 <c_wraith> But yes, that looks right
15:52:46 <Tinned_Tuna> c_wraith: my program can take other options, but I'm leaving them default for the moment, so no other args for the minute
15:53:18 <benzrf|afk> ok so i went back and actually read the page about lamdu
15:53:22 <monochrom> I didn't even use -rtsopts at compile or link time. I got success with +RTS -hy -RTS
15:53:28 <benzrf|afk> and it says that the dialect will not have currying
15:53:30 <benzrf|afk> and now i am sad
15:53:32 <benzrf|afk> ;_;
15:53:58 <monochrom> well, my ghc command was "ghc -prof -fprof-auto e.hs"
15:54:44 <Tinned_Tuna> monochrom: ah, -prof for me complains, it seems that it wants to go play with my install of base -- I thought this was a bad idea (for the same reasons that playing with bsae using cabal install is a bad idea)
15:55:18 <monochrom> ok, your mint is not giving you the part of ghc that supports profiling
15:55:33 <Tinned_Tuna> monochrom: is there a reasonably quick/low risk way around that ?
15:55:34 <monochrom> well, it's giving you, but in a separate mint package
15:55:50 <monochrom> it's why I hate all linux distros in this regard
15:55:56 <Tinned_Tuna> that sounds quick and low risk :-)
15:56:03 <c_wraith> just install the generic linux binary from haskell.org/ghc
15:56:15 <c_wraith> It avoids all stupid distros do
15:57:50 <frxx> > both %~ (+10) $ (1,2)
15:57:51 <lambdabot>   (11,12)
15:59:26 <Tinned_Tuna> monochrom: in case you're wondering, the thing I'm trying to profile is https://github.com/TinnedTuna/hacksoc-markov-challenge
15:59:33 <monochrom> every linux distro has its bureaucratic, religious, self-congratulating idea of how to break up one fine piece of software into a hundred shards called packages.
16:01:26 <Fuuzetsu> monochrom: I'm sure monochromOS has a better way to do dependencies ;)
16:02:01 <JuanDaugherty> debian + alien works for me
16:02:30 <JuanDaugherty> and yeah build the hs stack urself until hsOS come out
16:02:31 <Tinned_Tuna> I'm guessing that the issue is related to the fact that the package managment systems all have a slightly different (and incompatible) view into a very similar problem space
16:03:00 * Tinned_Tuna compiles the world
16:03:17 <Fuuzetsu> Tinned_Tuna: you can do that on the distro I use!
16:03:39 <Tinned_Tuna> Fuuzetsu: Gentoo?
16:03:51 <Fuuzetsu> yeah
16:04:26 <Fuuzetsu> anyway I'd love to stay and chat but I'm really tired, gn
16:04:27 <Tinned_Tuna> Fuuzetsu: I tried it once. Only once. Ow. The days I will never get back :-p
16:04:34 <Tinned_Tuna> Slackware was far easier back then.
16:04:59 <Tinned_Tuna> or at least, that's what I knew back then.
16:05:07 <JuanDaugherty> Tinned_Tuna, by build I didn't mean compile ghc, just install ghc, hp then other stuff as needed
16:05:32 <Tinned_Tuna> JuanDaugherty: oh yea, I'm not doing that.
16:06:02 <Tinned_Tuna> JuanDaugherty: I've got the ghc-prof package, and I've instructed cabal to go and re-build some of the hackage dependencies I have with the profiling turned on
16:06:07 <monochrom> http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml
16:06:08 <Tinned_Tuna> at least, I think that's what it's doing.
16:06:42 <monochrom> oh, on that note, http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
16:07:54 <zennist> I tried (length [2,3])/(length [3,1,2]) and ghci tells me that there's no instance for Fractional Int. What am I doing wrong?
16:08:04 * JuanDaugherty used slackware as a first distro.
16:08:29 <nooodl> :t fromIntegral
16:08:30 <lambdabot> (Integral a, Num b) => a -> b
16:08:32 <hpc> zennist: (/) takes two fractional kind of things and returns a fractional kind of thing
16:08:32 <mm_freak> zennist: fromIntegral (length xs) / fromIntegral (length ys)
16:08:41 <mm_freak> Int is not fractional
16:08:44 <hpc> zennist: you either want div for integer division, or you want what mm_freak says
16:09:01 <Tinned_Tuna> monochrom: that cabal page is slightly frightening
16:09:03 <zennist> ok, my bad..I should know this
16:09:05 <nooodl> also maybe worth looking at: genericLength?
16:09:23 <monochrom> yes, I like it frightening :)
16:09:30 <nooodl> i wonder, is that just implemented as (fromIntegral . length)
16:09:33 <nooodl> @src genericLength
16:09:33 <lambdabot> genericLength []    = 0
16:09:33 <lambdabot> genericLength (_:l) = 1 + genericLength l
16:09:41 <nooodl> oh; that makes sense
16:09:41 <mm_freak> fromIntegral . length is usually better than genericLength
16:09:52 <mm_freak> genericLength may be quite a bit slower
16:09:59 <nooodl> :t (fromIntegral.length, genericLength)
16:10:00 <lambdabot> (Num c, Num i) => ([a] -> c, [b] -> i)
16:11:23 <Tinned_Tuna> monochrom: can you see anything in the github repo that I posted that is obviously a no-no wrt. memory usage in haskell ?
16:11:44 * hackagebot feature-flags 0.1.0.0 - A simple library for dynamically enabling and disabling functionality.  http://hackage.haskell.org/package/feature-flags-0.1.0.0 (IanDuncan)
16:20:59 <Aldenious> hey guys, quick question from a noob: does haskell have a process handling libary?
16:21:30 <dwcook> Aldenious, Control.Concurrent may be what you want
16:21:44 <Aldenious> Cheers, thanks dwcook i'll look into it.
16:23:04 <Peaker> Or System.Process
16:23:14 <Peaker> (from the "process" package)
16:28:04 <bitemyapp> has anybody gotten Scion to compile recently? Are Emacs users supposed to be using something else?
16:28:22 * heatsink just uses haskell-mode
16:28:30 <bitemyapp> I'd been getting by on just Haskell mode but wanted the flymake typechecking.
16:28:43 <bitemyapp> it looks like scion is getting a little old?
16:29:59 <bitemyapp> nevermind, I may have gotten it.
16:32:34 <byorgey> bitemyapp: if you want flymake, use ghc-mod
16:32:52 <byorgey> @package ghc-mod
16:32:53 <lambdabot> http://hackage.haskell.org/package/ghc-mod
16:32:54 <bitemyapp> nevermind, didn't work.
16:33:36 <byorgey> and also http://www.mew.org/~kazu/proj/ghc-mod/en/
16:35:00 <bitemyapp> byorgey: looking into it. What about shime?
16:35:52 <byorgey> bitemyapp: shime is very old, its functionality has now been folded into haskell-mode
16:36:11 <bitemyapp> okay.
16:39:47 <frxx> > _1._Just._1._Just +~ 10 $ (Just (Nothing, 0), 0)  -- this works
16:39:48 <lambdabot>   (Just (Nothing,0),0)
16:39:56 <frxx> > _1._Just._1._Just +~ 10 $ (Nothing, 0)  -- why doesn't this?
16:39:57 <lambdabot>   No instance for (Control.Lens.Tuple.Field1
16:39:58 <lambdabot>                     a0 t0 (Data....
16:41:58 <Peaker> frxx: I am guessing the full error (truncated by lambdabot) is saying "ambiguous type" there?
16:42:17 <Peaker> the "No instance" error from GHC when the problem is ambiguous type is confusing
16:42:43 <frxx> oh right, it is complaining about Num ambiguity. easy to fix it, thanks
16:43:03 <Peaker> about Field1 ambiguity (though Num might be a problem too, except it has defaulting rules)
16:43:27 <Peaker> frxx: _1 works on different tuple types (e.g: (a,b,c) and (a,b,c,d)) so it is also in a type-class
16:43:59 <frxx> It said this: Note: there are several potential instances: instance Num Double, instance Num Float, instance Integral a => Num (GHC.Real.Ratio a)..
16:44:20 <edwardk> frxx: it doesn't know which instance to choose
16:44:47 <frxx> I see, so it's both tuple and Num ambiguity
16:44:54 <edwardk> > _1._Just._1._Just +~ 10 $ (Nothing :: Maybe (Maybe Int, Double), 0)
16:44:55 <lambdabot>   (Nothing,0)
16:45:38 <enthropy> > _1._Just._1._Just +~ 10 $ (Nothing `asTypeOf` Just (undefined,undefined), 0)
16:45:40 <lambdabot>   (Nothing,0)
16:45:57 <enthropy> the Num ambiguity is not the problem apparently
16:47:24 <Peaker> enthropy: because Num has ambiguity resolution rules (the "defaulting rules")
16:47:34 <enthropy> yep
16:48:03 <Peaker> I like Python's Zen on this: "In the face of ambiguity, refuse the temptation to guess"
16:48:33 <Peaker> The defaulting rules, especially as such a horrible ad-hoc mechanism for built-in classes, do just that
16:48:45 <enthropy> zen is ambiguous
16:48:47 <Peaker> Yet another reason to work with -Wall -Werror :)
16:50:02 <monochrom> in the face of Zen, use tautologies :)
16:52:19 <enthropy> hmm, is there a more sensible type-level 'error' for type families than the abomination at the bottom of my: http://www.haskell.org/pipermail/haskell-cafe/2013-November/111549.html
16:56:06 <zRecursive> @where lambdabot
16:56:06 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
16:57:06 <pxqr> does there are some package for extraction url query params like the urlencoded?
16:57:15 <pxqr> based on http-types I guess
16:57:25 <anon997> hi, i'm having the error *** Type : Maybe [a]*** Does not match : [a], how to solve it?
16:58:01 <pxqr> I end up with annoying class FromParam a where fromParam :: ByteString -> Maybe a; :(
16:58:12 <Peaker> anon997: don't use a list as though it was a Maybe list?
16:59:19 <enthropy> @type fromMaybe []
16:59:19 <lambdabot> Maybe [a] -> [a]
16:59:29 <anon997> it's a regular list, it's just that i use a function that return a Maybe [a]
17:00:10 <pxqr> add a return/Just/pure then
17:00:31 <anon997> i'll try tyvm
17:00:34 <monochrom> anon997: therefore, first decide what to do if you get Nothing, then use a "case" expression
17:00:50 <iron_houzi> I'm trying to come up with some exercises while reading Learn You a Haskell. I must say the first few chapters were fine, but now I'm really starting to struggle. I want to get the last element of a list. I thought I'd recursively remove the first element in the list until the list is empty, but I cannot even find a basic operator for removing the first element from a list. I've tried with [a] !! 0. Is this
17:00:52 <iron_houzi> approach a dead end?
17:01:58 <monochrom> iron_houzi: recursively remove, yes, but not until empty. until you see exactly one single item in a list.
17:02:21 <monochrom> there is a pattern for exactly that.
17:02:39 <iron_houzi> monochrom: Yes. I realized I worded my intent incorrectly. I actually meant to say this.. I'll paste my code ..1s..
17:03:09 <monochrom> another reason to completely distrust narratives
17:04:17 <iron_houzi> http://lpaste.net/96302
17:04:37 <monochrom> mylast (x:xs) = mylast xs
17:04:43 <iron_houzi> I know I know..
17:05:16 <iron_houzi> I'm just not able to get into the functional way of thinking.. I'm really struggeling here.. I't like learning to speak Tibetan again..
17:05:19 <monochrom> I don't, in fact, understand the logic behind mylast (xs !! 0)
17:06:27 <iron_houzi> monochrom: My idea was that this is the recursive call where use the list minus the first element as the parameter
17:07:45 <monochrom> x:xs is already the list. therefore, xs is already the list minus the first element.
17:07:52 <monochrom> xs!!0 is related to neither.
17:08:06 <monochrom> xs!!0 is like the 2nd element of x:xs
17:08:12 <iron_houzi> oh
17:08:32 <iron_houzi> so whenever I see x:xs it means that the first element is removed from the list?
17:08:49 <scott_> It means x is the first element and xs is the rest
17:08:53 <scott_> > 1 : [2, 3]
17:08:54 <lambdabot>   [1,2,3]
17:09:01 <monochrom> I don't understand that sentence. x:xs is the list.
17:09:21 <iron_houzi> I thought the : operator would add an element to a list, not remove it..
17:09:35 <monochrom> perhaps you should read my recent http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification
17:10:03 <monochrom> the : operator does add an element to a list in another context. not this one.
17:10:23 <iron_houzi> Here it removes an element?
17:10:45 <thebnq> on the left side of the equals, its patternmatched, so it deconstructs the data type
17:10:50 <monochrom> no, here it assigns names to different parts
17:12:01 <monochrom> mylast (1 : (2 : (3 []))) --- now x refers to 1, xs refers to 2 : (3 : []). some parentheses are redundant.
17:12:35 <chrisdone> monochrom: there's a good for-newbies explanation of unification in sicp
17:12:38 <monochrom> read my http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification
17:12:51 <monochrom> ah, but sicp is so thick :)
17:13:12 <iron_houzi> What's sicp?
17:13:43 <jkarni> structure and interpretation of computer programs - a classic programming book
17:13:51 <monochrom> I haven't really read sicp
17:14:06 <jkarni> definitely worth it for people interested in functional programming
17:14:15 <jkarni> for everyone, really
17:14:18 <hpc> much of it is intro to programming
17:14:24 <chrisdone> it's in the section of logic programming http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.2
17:14:29 <hpc> and it assumes access to mutation because of the lisp underpinning
17:14:38 <chrisdone> see Pattern Matching and then scroll down a bit to Unification
17:15:02 <chrisdone> maybe it's only valuable if you know lisp
17:15:04 <hpc> it's a good book but redundant if you know some haskell
17:15:19 <hpc> chrisdone: it's valuable to many imperative language people too
17:15:44 <hpc> it's a very quiet intro to FP disguised as a language intro
17:15:58 <iron_houzi> I'm a vim user, so I'm stuck with a terrible scripting language, no understanding of functional programming, but a very good editor :)
17:16:12 <chrisdone> sort of -- the book kind of criticizes FP, actually
17:16:18 <hpc> iron_houzi: you should use emacs
17:16:31 <hpc> you'll be stuck with a terrible scripting language, understanding of functional programming, and a terrible editor
17:16:54 * hackagebot purescript 0.1.11 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.11 (PhilFreeman)
17:16:55 <chrisdone> but it was written before FP was a thing, before type systems made it possible to have your cake and eat it too with purity and side-effects
17:16:55 <iron_houzi> Let's not go down that road ..
17:17:13 <hpc> chrisdone: yeah; it has certainly aged
17:19:20 <iron_houzi> monochrom: Wow! Thank you for your great explanation and help. I think I managed to solve the problem.
17:20:06 <iron_houzi> monochrom: I liked how you provided help without giving me the syntax for the correct answer.
17:20:33 <monochrom> err, wait, I thought I wrote exactly "mylast (x:xs) = mylast xs"
17:20:40 <chrisdone> ‚ÄúHelp me to help you to help yourself!‚Äù
17:21:40 <hpc> quine: write me writing myself
17:22:13 <jkarni> escher: draw me drawing myself
17:24:09 <iron_houzi> monochrom: haha, lucky for me I didn't realize that. You should take the credit and compliment and I shall give my subconscience the benefit of the doubt.
17:24:24 <monochrom> ok!
17:24:25 * iron_houzi needs a cup of coffee or some sleep
17:25:45 <anon997> is there a way to extract a of a Maybe [a]?
17:26:00 <chrisdone> :t maybe
17:26:00 <monochrom> not if it doesn't have one
17:26:01 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:26:05 <chrisdone> :t listToMaybe
17:26:06 <lambdabot> [a] -> Maybe a
17:26:14 <chrisdone> :t foldr
17:26:14 <lambdabot> (a -> b -> b) -> b -> [a] -> b
17:26:16 <monochrom> it could be Nothing. it could be Just []. no a for you.
17:26:18 <chrisdone> with these tools‚Ä¶
17:26:32 <ParahSailin> :t fromJust
17:26:32 <lambdabot> Maybe a -> a
17:26:40 <monochrom> and therefore, no A for you either
17:26:43 <chrisdone> ParahSailin: be gone, accursed one!
17:26:44 <anon997> what does :t mean?
17:26:48 <ParahSailin> haha
17:26:50 <chrisdone> anon997: type
17:26:51 <jkarni> type
17:29:11 <iron_houzi> monochrom: The answer did it a bit different. Do you have any comments on the way we solved it and the way the author of the answer solved it? http://www.haskell.org/haskellwiki/99_questions/Solutions/1
17:29:37 <iron_houzi> Are they exactly equivalent?
17:29:49 <anon997> any French people by anychances?
17:30:13 <jkarni> iron_houzi: there are several different solutions on that page
17:30:25 <iron_houzi> the top one
17:30:36 <iron_houzi> my answer is pasted above ^^
17:30:43 <monochrom> the are equivalent. [x] vs x:[] is just different notation. x:xs vs _:xs is just giving or not giving a name to something you don't care about.
17:31:09 <chrisdone> anon997: http://haskell.fr/wiki/index.php?title=Accueil
17:31:35 <iron_houzi> monochrom: Cool. Are they also just as efficient when compiled by ghc?
17:31:40 <monochrom> yes
17:31:52 <iron_houzi> Thank you.
17:31:57 <anon997> good to know thank you
17:32:12 <monochrom> perhaps I should make a Haskell Canada logo too
17:32:36 <chrisdone> the british flag already looks like it's composed of haskell's logo =p
17:32:58 <chrisdone> http://resources.woodlands-junior.kent.sch.uk/customs/images/uk.jpg  it's too easy =)
17:33:09 <hpc> haskanada
17:33:35 <monochrom> the Union Jack just needs to be generalized to the Join Jack
17:33:43 <hpc> the tagged union jack
17:34:49 <jkarni> the british flag looks like it's also trying to say something about rings/fields
17:34:56 <jkarni> not yet sure what
17:35:42 <chrisdone> the oppressive nature of st george's cross imposing itself over the others uneased me a little
17:35:50 <monochrom> I know. it says, "they should be Num instances" :)
17:35:57 <jkarni> haha
17:36:18 <thebnq> Monoid instance over conquering others
17:36:20 <chrisdone> in a way it's a monoid
17:36:23 <chrisdone> =)
17:36:28 <thebnq> haha :P
17:39:40 <anon997> if any1 not busy, i would apprecite some feedback on this please https://gist.github.com/anonymous/b2f5c7c83bb6d5e9e83b
17:40:13 <anon997> the code is not working
17:40:32 <monochrom> "length /= 0" is going to be a type error
17:40:38 <jle`> what does not working mean
17:40:41 <ahokaomaeha> anon997: What is it supposed to do?
17:40:51 <jle`> does it compile?
17:41:00 <anon997> nope
17:41:31 <anon997> i'll add some comment
17:41:37 <anon997> in a new paste
17:41:49 <jkarni> anon997: see monochrom comment - length takes an argument
17:42:40 <monochrom> but I like nom. put in more nom's. nom nom nom.
17:43:20 <chrisdone> @lpaste
17:43:20 <lambdabot> Haskell pastebin: http://lpaste.net/
17:43:33 <chrisdone> hmph. it should have the /new/haskell bit
17:43:35 <chrisdone> @where lpaste
17:43:35 <lambdabot> http://lpaste.net/new/haskell
17:43:39 <chrisdone> that one is better
17:43:56 <swagraj> greetings
17:44:06 <jle`> also a style tip; your lines should never have to be more than 79 characters long
17:44:11 <jle`> anon997
17:44:18 <heatsink> anon997: (f (g x)) has many parentheses.  (f $ g x) is better.
17:44:31 <monochrom> I use 100 characters. still, not as long as that one
17:44:45 <jle`> 100 is ok.
17:44:51 <swagraj> question: If I wanted to do 1 + 2 + 3 + 4 in infix, how is that done? I would think it's (+)(1 2 3 4)
17:44:52 <jkarni> yeah, I feel like 80 is outdated
17:44:59 <jle`> i say 79 because of my fortran days
17:45:09 <monochrom> I like fortran
17:45:14 <geekosaur> swagraj, I think you mean prefix?
17:45:16 <heatsink> why?
17:45:21 <swagraj> yes, sorry
17:45:22 <heatsink> I mean, why would you like fortran?
17:45:28 <geekosaur> but (+) does not take indefinite parameters
17:45:32 <JuanDaugherty> y not
17:45:36 <monochrom> 1 + 2 + 3 + 4 is already infix.
17:45:41 <jle`> fortran is probably my favorite imperative language.
17:45:44 <jle`> behind haskell maybe.
17:45:50 <jle`> just barely.
17:45:51 <geekosaur> (+) 1 ((+) 2 ((+) 3 4))
17:45:57 <swagraj> I meant prefix, sorry. So how would that be done?
17:46:14 <swagraj> thanks. However, is there a slightly prettier way?
17:46:21 <ReinH> swagraj: yes, 1 + 2 + 3 + 4
17:46:29 <monochrom> do you like sum [1,2,3,4]?
17:46:38 <swagraj> ah, thanks
17:48:30 <enthropy> jle`: 77 or newer?
17:48:34 <heatsink> My experience with Fortran is F77.  The absence of function type checking really bugged me.
17:49:01 <monochrom> when I say I like fortran, I mean this. when people say, "oh god, y = f (g x) is too hard, I can only understand tmp1 = g x; y = f tmp1", I say, you're trashing the valuable advancement we got from fortran.
17:49:57 <heatsink> If f and g are subroutines, you need 2 call statements, right?
17:50:18 <monochrom> I don't know. it doesn't matter.
17:50:32 <enthropy> well you're allowed  Y = DSIN(DCOS(X)
17:50:38 <enthropy> )
17:50:48 <jle`> enthropy: i was raised on 77 but nowadays i just use gfortran so there is not really any difference anymore.
17:50:51 <heatsink> You forgot the line continuation marker, enthropy
17:50:54 <enthropy> with whatever indentation / line numbering you need yeah
17:50:57 <anon997> the code with comment
17:50:58 <jle`> i can live without most of the 90+ extensions
17:51:00 <anon997> https://gist.github.com/anonymous/c4826465283213e3979a
17:51:10 <monochrom> you can talk me into changing the example. y = 5 * (3 + x). tmp1 = 3 + x; y = 5 * tmp1.
17:52:04 <heatsink> anon997, those comments are just a gloss of the code
17:52:42 <monochrom> I'm ok with a gloss of the code.
17:53:05 <anon997> the main issue
17:53:06 <enthropy> Nom is good
17:53:07 <monochrom> I'm just no ok with needing a 27" screen to read it :)
17:53:14 <anon997> i would like to use the function recursivly
17:53:30 <dlllv> I'm getting this error "bad interface file" and "mismatched interface file versions".  trying to use virthualenv on osx, not sure what changed.
17:53:33 <anon997> but i can't because of the Maybe [a]
17:54:15 <jle`> which funconi?
17:54:26 <jle`> oh
17:54:28 <dlllv> Actually I had to unset GHC_PACKAGE_PATH which is what I thought I did last time.  Otherwise cabal won't work
17:54:29 <heatsink> f (x : xs) = case f xs of { Just r -> foo x r; Nothing -> Nothing }
17:54:43 <anon997> normaliserIngredients
17:54:50 <geekosaur> dlllv, virthualenv is rather out of date, perhaps you want hsenv?
17:55:04 <monochrom> anon997: IngredBase is not a type. but you can say it's a case or branch. the IngredBase case.
17:55:05 <geekosaur> it is not impossible that virthualenv does not work with modern ghc
17:55:08 <heatsink> You can do the recursive call like that.  The Maybe is handled by case ... of Just
17:55:13 <dlllv> geekosaur: ok good, you've given me hope
17:55:19 <geekosaur> (virthualenv was renamed for hsenv for v2+)
17:55:20 <dlllv> hsenv it is
17:55:25 <jle`> anon997: also fix length /= 0, length cannot be compared to 0
17:55:31 <geekosaur> *renamed to
17:56:02 <jle`> :t length
17:56:03 <lambdabot> [a] -> Int
17:56:04 <jle`> :t 0
17:56:05 <lambdabot> Num a => a
17:56:13 <geekosaur> in any case that error means that the ghc api that it is using is not compatible with the interface files you are trying to read
17:56:31 <geekosaur> s/you are/it is/
17:56:36 <dlllv> someone on a web page told me i should use virthualenv.  ofc they might have been telling me to do that from three years ago
17:56:45 <geekosaur> very likely
17:56:47 <bitemyapp> dlllv: use cabal sandbox.
17:56:55 <jle`> dlllv: yeah there are still blog posts out there using virthualenv that i even run into today
17:57:00 <heatsink> Also, as monochrom said, we can read more easily if you write shorter lines of code
17:57:05 <geekosaur> sometimes google is a bad guide. I tend to go into the search settings and limit it to recent pages (6 months or a year(
17:57:15 <geekosaur> for stuff like this
17:57:23 <geekosaur> er, search tools
17:58:04 <anon997> instead of length /= 0 i could do recetteNormalisee /= []
17:58:14 <monochrom> programmers should be restricted by law to netbook-sized screens
17:58:28 <dlllv> maybe someone can do a searchreplace on the internet
17:58:46 <anon997> i think it's 80 character, but i code with notpad so i can scroll horizontally
17:58:49 <bitemyapp> monochrom: that would clearly only work with the use of XMonad.
17:59:30 <jle`> anon997: as long as recetteNormalisee is a number
17:59:41 <anon997> it's an array
17:59:45 <jle`> anon997: everyone can scroll; it's just easier to read code when you don't have to
17:59:49 <geekosaur> um
17:59:56 <geekosaur> don't compare arrays to []
18:00:03 <geekosaur> use nul or (not . null)
18:00:08 <geekosaur> use null or (not . null)
18:00:13 <jle`> also it forces you to make some decisions that end up improving legibility
18:00:19 <iron_houzi> I'm trying to solve the 99 problems. On problem 2, I solved it like this: http://lpaste.net/96302   I noticed that it was quite different from the answers given. Could someone please tell me if my solution is oK?
18:00:28 <jle`> oh didn't notice you did /= [] and not /= 0
18:00:38 <jle`> also small note, [a] is a list, not an array
18:00:56 <jle`> the difference is slightly significant in haskell
18:01:30 <anon997> my bad
18:01:39 <iron_houzi> I'm trying to get the element before the last element in a list..
18:01:50 <jle`> anon997: no bad here don't worry
18:02:29 <anon997> get the size of your list and get the element at the position ( size -2 )
18:02:32 <Peaker> iron_houzi: the name "mylast" is confusing for non-last-resulting function. the error message you give might be confusing:  mylast [1]  -> error "Empty list"
18:03:02 <jle`> anon997: actually that's one of the differences between arrays and lists, lists aren't meant to be indexed/retrieved at arbitrary positions
18:03:16 <jle`> but arrays are.
18:03:40 <anon997> i see
18:03:40 <iron_houzi> Peaker: Good call. I just did a slight modification to problem #1, hence the function name and error message. Apart from that, is my method sound?
18:04:19 <geekosaur> Haskell lists are simple singly linked lists
18:04:25 <geekosaur> so indexing is done by walking them
18:04:30 <Peaker> iron_houzi: seems good to me
18:04:33 <geekosaur> this is convenient, but can be slow for large lists
18:04:41 <jle`> lists aren't meant to be storage for data
18:04:46 <iron_houzi> Peaker: Thank you.
18:04:46 <jle`> lists are more of a control structure
18:04:50 <jle`> it's analogous to like...a stream
18:05:06 <dlllv> is cabal sandbox or hsenv going to be a thing I wish i hadn't looked into?
18:05:10 <geekosaur> yeh, I tend to think of a Haskell list as a "foreach" loop in the form of data
18:05:29 <jle`> dlllv: you should be using cabal sandbox
18:05:44 <jle`> and if it were three months ago you would have should have been using cabal-dev
18:05:57 <dlllv> OK cool thats two out of three I'm done
18:06:15 <Tinned_Tuna> I'm somewhat lusting after Data.Text.copy, but stuck in the dark ages due to Linux Mint 14's version of GHC. Wonderful. I think I'll deal with that another time...
18:06:54 <benzrf> hi
18:06:56 <benzrf> data Possibility a = (//) a a | Only a deriving (Show)
18:06:56 <bitemyapp> Tinned_Tuna: just install a proper ghc. What do you need that function for?
18:06:58 * hackagebot purescript 0.1.12 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.12 (PhilFreeman)
18:07:00 <benzrf> why is // not in scope?
18:07:23 <Tinned_Tuna> bitemyapp: I'd rather not start messing with my system and fighting apt at 2AM :-p
18:07:28 <lpaste> monochrom pasted ‚Äúrecette‚Äù at http://lpaste.net/96307
18:07:44 <Tinned_Tuna> bitemyapp: I'm reasonably confident that it will help aleviate some memory issues
18:07:45 <jle`> monochromme
18:07:54 <monochrom> darn, he has left
18:08:23 <iron_houzi> Can someone please help me with problem 3/99? (Get K'th element from list) I've seemed to have managed to get the general logic working, but I'm unable to catch the exception where K > length of the list. I'd also like to print out the original parameter for K in the error, where I've tried to use nr@
18:08:43 <iron_houzi> http://lpaste.net/96308
18:08:52 <dwcook> benzrf, I'm not sure why that works at all, but I don't think (//) is a valid constructor.
18:08:52 <geekosaur> benzrf: seems to work here? (although I note :i has a bit of a display issue)
18:09:19 <jle`> iron_houzi: hm.
18:09:24 <jle`> there is a better approach
18:09:43 <dwcook> benj_, to my knowledge, infix constructors must begin with :
18:09:49 <jle`> iron_houzi: you are pattern matching on your list
18:09:52 <dwcook> benj_, sorry, wrong person
18:10:02 <jle`> that is a good start
18:10:10 <iron_houzi> jle`: ok..?
18:10:21 <jle`> for explicit recursion problems like this, the solution always sorts of writes itself
18:10:25 <jle`> if you just have complete matches
18:10:29 <jle`> *exhastive
18:10:31 <geekosaur> dwcook, that's just prefix form for an infix constructor
18:10:34 <heatsink> monochrom, the transition from pattern matching to natural deduction seems a bit abrupt to me
18:10:39 <heatsink> in crossroad
18:10:45 <jle`> so handle both cases of [a]
18:10:51 <geekosaur> although yes, it would depend on ghc version whether that is legal or not
18:11:00 <geekosaur> has to start with : in some/most versions
18:11:09 <geekosaur> at least to be infix
18:11:13 <dwcook> geekosaur, I'm not sure why the above is not an error.
18:11:16 <jle`> oh i didn't see that you have to print out the original.
18:11:22 <jle`> yeah use a helper function
18:11:35 <monochrom> no no, please transit in the reverse direction, from natural deduction to pattern matching :)
18:11:41 <geekosaur> so this sounds like the version that accepts it (mine) is actually a ghc bug
18:11:56 <dwcook> Mine accepted it as well, but I have no idea what effect it had.
18:11:56 <jle`> monochrom: really?
18:12:06 <jle`> how so
18:12:07 <iron_houzi> jle`: So I just store the original value of n as a helper function?
18:12:08 <geekosaur> benzrf: infix constructors can't be uppercase, so instead they have to start with :
18:12:22 <jle`> iron_houzi: write a helper function to find the nth value "normally"
18:12:23 <monochrom> I don't know. use the direction that works for you
18:12:24 <dwcook> geekosaur, did you notice they left before seeing either of us respond?
18:12:24 <geekosaur> it should actualy not accept that definition, this appears to be a ghc bug
18:12:26 <jle`> without worrying about storing the original value
18:12:33 <jle`> and then in your error, reference the original passenth
18:12:34 <geekosaur> oh feh
18:12:38 <jle`> *passed nth
18:13:24 <geekosaur> @tell benzrf that it was accepted at all appears to be a ghc bug. symbol (infix) constructors need to start with a colon (:) to distinguish from normal operators, the same way normal constructors must start with uppercase to distinguish from functions
18:13:24 <lambdabot> Consider it noted.
18:13:40 <jle`> getnth xs n = go xs n where go [] _ = ...; go y:ys n = ...
18:13:43 <mm_freak> sm: http://hub.darcs.net/ertes/config/browse/skel/+name+.cabal.bob
18:13:55 <mm_freak> sm: the file does exist, but i get a 404
18:14:00 <geekosaur> wonder if it's worth reporting the bug that it's not detected as illegal if given in infix form, considering 7.8 is around the corner
18:14:00 <jle`> er, getnth xs nr
18:14:08 <jle`> and then you can reference the original nr in your error func
18:14:46 <jle`> monochrom: i'm curious to how you would approach it backwards. but for me...if you just write out the exhaustive pattern match, the function basically 'writes itself'.  no thinking involved.
18:14:54 <jle`> no thinking = less bugs
18:14:56 <jle`> ....
18:14:58 <jle`> i think.
18:15:48 <monochrom> if you already know natural deduction and haven't learned pattern matching, then I can say, add more information, you get pattern matching
18:16:18 <monochrom> if you already know pattern matching and haven't learned natural deduction, then I can say, throw away some information, you get natural deduction
18:16:30 <monochrom> if you already know both, then I shut up
18:16:58 <monochrom> if you have not learned either, then I suggest google or wikepedia or some university courses :)
18:17:17 <monochrom> and maybe LYAH :)
18:18:46 <bitemyapp> I preferred http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ to LYAH.
18:19:02 <heatsink> For me, term algebra + set theory feels like the most natural explanation.
18:19:04 <heatsink> If you try listing every possible value you need to handle, it will either be (something : something_else) or [].
18:19:17 <heatsink> So it's natural to organize your code to handle each case
18:19:33 <monochrom> you are saying, you want me to write http://www.cs.utoronto.ca/~trebla/fp/lecture-02.pdf slides 15 and 16.
18:19:47 <monochrom> but I already wrote them.
18:20:02 <heatsink> ok
18:20:30 <iron_houzi> jle`: I'm not sure how to pattern match to check if [a] is empty. I've tried: | xs == []
18:20:42 <jle`> oh
18:21:29 <jle`> did you know that all lists literals are syntactic sugar? [1,2,3] is 1:2:3:[]
18:21:44 <jle`> where : is the cons operator, which has an element ont he left hand side and a list on the right hand side
18:21:53 <jle`> 1:(2:(3:[]))
18:22:14 <iron_houzi> I have read that and monochrom just showed me this, yes..
18:22:19 <jle`> so when you pattern match the above to x:xs, you pattern match 1 to x, and 2:(3:[])) to xs
18:22:31 <jle`> to pattern match for an empty list
18:22:35 <jle`> well
18:22:41 <jle`> to pattern match for a one-element list
18:22:44 <jle`> you could do x:[]
18:22:46 <jle`> right?
18:22:48 <iron_houzi> indeed
18:22:54 <jle`> so how would you pattern match for a no-element list
18:23:03 <iron_houzi> just [] ?
18:23:06 <jle`> yea
18:23:35 <iron_houzi> I tried that .. still didn't get a match..
18:23:56 <heatsink> The slides look nice
18:24:01 <monochrom> thanks
18:25:02 <jle`> > let isEmpty [] = True; isEmpty _ = False in isEmpty []
18:25:03 <lambdabot>   True
18:25:34 <jle`> > let isEmpty [] = True; isEmpty _ = False in isEmpty [1,2,3]
18:25:35 <lambdabot>   False
18:27:00 * hackagebot thyme 0.3.1.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.1.0 (LiyangHu)
18:27:23 <iron_houzi> jle`: Your tests look solid, but I still don't see what I've done wrong: http://lpaste.net/96308
18:27:40 <jle`> hm you're using guards instad of pattern matches
18:27:59 <iron_houzi> ah.. yes. I'll try to use both .
18:28:00 <jle`> you used pattern matches in problem 2
18:28:07 <jle`> you do'nt need to use both, you only need pattern matches
18:29:07 <jle`> remember that you can only put a Bool in a guard, so you can't put [] (a list)
18:30:55 <iron_houzi> jle`: Yes, The boolean requirement for guards became apparent. I just thought I could make it work by doing a test if the list was empty. I'll keep this in mind, that guards aren't always possible to use.
18:31:12 <monochrom> replace "[]" by "n < 1"
18:31:35 <iron_houzi> I believe I did.. but I'll try again.
18:32:46 <iron_houzi> monochrom: yeah, that doesn't work for some reason.
18:33:26 <jle`> this might be possible with guards, but it's a lot more idiomatic/natural with pure pattern matches
18:34:24 <iron_houzi> jle`: OK. This is good for me to learn and understand, when to use what haskell feature .. I.e learning to use haskell properly
18:35:01 <jle`> mhm :)  this really is something that can only come from practice
18:35:20 <iron_houzi> OK. I need to sleep anyways. Looking forward to trying this out with a fresh head tomorrow morning. Thank you all so much for the great help. I'm really having fun.
18:35:55 <jle`> no problem
18:36:00 <jle`> your solution will be very very similar
18:36:12 <jle`> to your solution to number 2
18:41:04 <cschneid> I have a string like this: "  window.exchangeRatesGlobal = {\"usd_to_btc\":\"0.000997\",\"btc_to_usd\":\"1002.9728\"};" and want to parse out the "1002.97"
18:41:32 <cschneid> in ruby I use a regex to get it done
18:41:39 <cschneid> what's the one-two line solution in haskell
18:41:51 <dlllv> cabal sandbox going, some packages failed to install
18:42:30 <dlllv> one day, one day... one day something will just install.  one day. thats what keeps me going.
18:43:32 <geekosaur> cschneid, you could do it with a regex but the regex stuff is fairly ugly and nobody likes regexes enough to make it less so. the principled way is to use aeson to parse the JSON (although I think that may be not entirely legal JSON)
18:44:19 <cschneid> geekosaur: yeah, but more of a general question. Is there a quick & dirty way to get data out of a string. I don't mind a Maybe result (in fact, probably good)
18:44:26 <dlllv> actually it makes sense, failing to install some postgresql package... o don't have psql installed so... i dont' need that dependancy anyways
18:45:01 <ahokaomaeha> Is there any standard library function foo of type "[a] -> [[a]]" such that "foo [2,3,5,7,11] == [[], [2], [2,3], [2,3,5], [2,3,5,7], [2,3,5,7,11]]"? (I could make my own, but I would rather not.)
18:45:42 <copumpkin> > inits [2,3,5,7,11]
18:45:43 <lambdabot>   [[],[2],[2,3],[2,3,5],[2,3,5,7],[2,3,5,7,11]]
18:46:23 <dlllv> how do I see what package a module comes from?
18:46:33 <hpc> hoogle or hayoo, usually
18:46:37 <hpc> or in ghci, :info
18:46:57 <ahokaomaeha> copumpkin: Thank you.
18:47:01 <copumpkin> np
18:49:46 <cschneid> so, I have a Text type, want to get it to be a lazy bytestring so that Aeson takes it and decodes.
18:49:52 <cschneid> Is there any straightforward way to do that
18:50:31 <geekosaur> ghc-pkg find-module
18:50:48 <geekosaur> (for dlllv)
18:53:22 <dpwright> I am using pipes to handle traffic coming in over the network and respond to it, currently just using the "pipes" and "pipes-network" packages
18:55:56 <dpwright> I have a pipeline with a Producer based on readSocket, two pipes ("interpret" to interpret the input, and "handle" to perform actions based on it), and a consumer which sends the output back to the socket
18:56:57 <dpwright> "interpret" is currently getting the data from the Producer using await, doing some simple text processing, and then passing messages down to "handle", but I would like to switch to using pipes-parse to do some more sophisticated processing of the text
18:57:23 <dpwright> but as far as I can tell most of the functions provided by pipes-parse operate on Producers, not Pipes
18:57:49 <dpwright> am I misunderstanding how I should be using pipes-parse?  can it not be plugged into the middle of a pipeline like that?
19:06:09 <dlllv> geekosaur: hpc: jle` thanks for the help so far
19:06:15 <dlllv> is ghc-mod current?
19:06:38 <dlllv> how do i get cabal sandbox "into" emacs so flymake etc works?
19:08:34 <dlllv> I launched emacs from the term where i ran cabal sandbox init so I assumed.... well it looks like I got a bunch of stuff in  .cabal-sandbox/share/x86_64-osx-ghc-7.6.3/ghc-mod-3.1.4/ so maybe...
19:12:11 <levi> dpwright: I use pipes-parse to modify my raw bytestring producer into a producer of Haskell data structures that are consumed by the pipeline.
19:13:20 <dpwright> levi: That sounds fairly similar to what I'm trying to do
19:13:34 <levi> dpwright: Well, actually I mostly use pipes-parse through pipes-attoparsec
19:13:38 <dpwright> does your whole pipeline have to be inside the StateT monad to make that work?
19:13:48 <dpwright> ah, I haven't looked at pipes-attoparsec
19:15:14 <levi> No, I have a for loop in my parsing function that yields successfully parsed values.
19:15:41 <levi> So my parsing function is a Producer -> Producer function.
19:17:35 <levi> The StateT stuff is hidden inside the parseMany function from pipes-attoparsec
19:18:03 <dpwright> levi: ahhh, ok
19:18:05 <dpwright> I see it
19:18:12 <dpwright> I'll have a go at that -- thanks!
19:42:44 <augur> is there an editor for haskell that does automatic case splitting?
19:50:50 <bitemyapp> http://erlang.org/pipermail/erlang-questions/2013-November/076112.html
19:51:02 <bitemyapp> augur: I think there was something for Emacs in the way of structural editing
19:51:22 <bitemyapp> augur: example: http://chrisdone.com/posts/haskell-emacs-ifs
19:54:14 <chrisdone> bitemyapp: that's way out of date
19:54:32 <chrisdone> augur: what's case splitting?
19:54:36 <bitemyapp> chrisdone: good to know.
19:54:49 <enthropy> some kind of refactoring probably
19:55:42 <copumpkin> @let dot xs ys = sum (zipWith (*) xs ys)
19:55:43 <lambdabot>  Defined.
19:55:56 <chrisdone> bitemyapp: i'll be publishing structured-haskell-mode soonish, whence i've written some unit tests
19:56:10 <copumpkin> > let foo = [1,1] ++ map (dot k) (transpose (tails foo)) in foo
19:56:11 <lambdabot>   Couldn't match expected type `[a0]'
19:56:11 <lambdabot>              with actual type `Debug.Si...
19:56:40 <chrisdone> here's a sample of shm/raise (M-r) which i like http://chrisdone.com/shm-raise.ogv it has sound-effects so you know when to pretend to be impressed
19:58:01 <chrisdone> (i.e. replace the parent expression with this expression. very handy)
19:58:03 <copumpkin> hmm
19:58:05 <mgsloan> chrisdone: haha, nice!
19:58:10 <copumpkin> :t transpose
19:58:11 <lambdabot> [[a]] -> [[a]]
19:58:14 <chrisdone> mgsloan :D
19:58:34 <copumpkin> lambdabot error messages are remarkably unhelpful
19:59:37 <chrisdone> copumpkin: yeah someone should patch it with unlines
19:59:47 <copumpkin> anyone see what's wrong with my expression?
19:59:47 <chrisdone> unwords . lines
19:59:51 <copumpkin> yeah :/
20:00:05 <chrisdone> the k?
20:00:15 <copumpkin> oh
20:00:16 <copumpkin> ugh
20:00:17 <chrisdone> Debug.Si = simplereflect
20:00:21 <copumpkin> thanks :)
20:00:25 <chrisdone> =)
20:00:28 <copumpkin> > let foo = [1,1] ++ map (dot [1,1]) (transpose (tails foo)) in foo
20:00:30 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:00:33 <copumpkin> > let foo = [1,1] ++ map (dot [1,2]) (transpose (tails foo)) in foo
20:00:35 <lambdabot>   [1,1,3,7,17,41,99,239,577,1393,3363,8119,19601,47321,114243,275807,665857,1...
20:00:46 <copumpkin> @oeis 1,1,3,7,17,41,99,239,577,1393,3363
20:00:46 <lambdabot>  Numerators of continued fraction convergents to sqrt(2).[1,1,3,7,17,41,99,23...
20:01:21 <copumpkin> > let foo = [1,1] ++ map (dot [0,2]) (transpose (tails foo)) in foo
20:01:22 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
20:01:36 <chrisdone> neat!
20:01:46 <copumpkin> transpose . tails feels like something else
20:02:01 <copumpkin> @let quux = transpose . tails
20:02:02 <lambdabot>  Defined.
20:02:06 <copumpkin> > quux [1..5]
20:02:07 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
20:02:10 <copumpkin> hmm :P
20:02:11 <mgsloan> chrisdone: It'd be neat if that raise would also copy out the parent
20:02:22 <copumpkin> > let foo = [1,1] ++ map (dot [0,2]) (tails foo) in foo
20:02:24 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
20:02:27 <copumpkin> > let foo = [1,1] ++ map (dot [1,1]) (tails foo) in foo
20:02:29 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:02:33 <copumpkin> there, nicer
20:02:38 <chrisdone> mgsloan: you mean so you could paste the parent elsewhere?
20:02:59 <copumpkin> @check \xs -> transpose (tails xs) == tails (xs :: [Int])
20:03:00 <lambdabot>   *** Failed! Falsifiable (after 1 test):
20:03:00 <lambdabot>  []
20:03:04 <mgsloan> chrisdone: Yup!  I dunno how useful it'd be, but it seems reasonable that the middle bits might still be valuable
20:03:26 <copumpkin> @check \xs -> not (null xs) ==> transpose (tails xs) == tails (xs :: [Int])
20:03:27 <mgsloan> Maybe you're making a new function out of the middle bits
20:03:27 <lambdabot>   *** Failed! Falsifiable (after 1 test and 1 shrink):
20:03:27 <lambdabot>  [0]
20:03:40 <copumpkin> @check \xs -> length xs > 1 ==> transpose (tails xs) == tails (xs :: [Int])
20:03:40 <lambdabot> Plugin `check' failed with: Ambiguous infix expression
20:03:46 <chrisdone> mgsloan: true. that's a good use-case
20:03:48 <copumpkin> lol
20:04:23 <copumpkin> ah, so on a stream it's true
20:04:25 <copumpkin> I think
20:04:32 <chrisdone> > tails [1..5]
20:04:32 <copumpkin> but not on any finite list
20:04:32 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
20:04:36 <chrisdone> it's the last bit?
20:04:47 <copumpkin> yeah
20:04:53 <copumpkin> luckily I have an infinite stream in my case
20:07:29 <chrisdone> mgsloan: paredit also has a neat "convolute-sexp" which swaps two parents, (foo (bar ‚Ä¶)) ‚Üí (bar (foo ‚Ä¶)). saw it on "emacs rocks!" =p https://www.youtube.com/watch?v=D6h5dFyyUX0&t=1m44s gonna steal that one too
20:08:26 <mgsloan> ooh, very nice
20:09:22 <augur> bitemyapp: blegh
20:09:24 <augur> horrible!
20:09:44 <augur> chrisdone: case splitting is when you do this:
20:09:54 <bitemyapp> augur: sorry :(
20:09:57 <augur> foo :: Bool -> Blip
20:09:59 <bitemyapp> I probably misunderstood what you wanted.
20:10:01 <augur> foo b = undefined
20:10:06 <augur> <split on b>
20:10:10 <augur> foo False = undefined
20:10:13 <augur> foo True = undefined
20:10:36 <bitemyapp> so you want it to project a named argument into all its possible values?
20:10:38 <chrisdone> augur: so generate a list of constructor matches?
20:10:57 <bitemyapp> that would be useful pretty much only for booleans and enums, wouldn't it?
20:11:00 <augur> chrisdone: more or less, yeah. split a fun def into the total collection of cases on an arg
20:11:09 <cschneid> How could I simplify this code? http://cschneid.github.io/blog/2013/11/27/same-bitcoin-price-fetcher/ - is there an obvious big win I am missing?
20:11:14 <augur> bitemyapp: its useful for any ADT!
20:11:38 <chrisdone> augur: you use emacs?
20:11:47 <augur> chrisdone: for agda
20:11:53 <chrisdone> oh
20:12:04 <mgsloan> augur: Doesn't exist as far as I know, but that'd be a cool one!
20:12:07 <bitemyapp> augur: I guess I derped and forgot ADTs were abstract enums.
20:12:08 * mgsloan adds to list
20:12:15 <bitemyapp> augur: that's a great idea :)
20:12:33 <augur> mgsloan: yeah, its a nice thing to have, along with holes. case splitting and holes go hand in hand in my opinion
20:12:37 <chrisdone> it'd be pretty easy to add that to my setup. it's been discussed a few times, i've always been skeptical of its use
20:12:53 <augur> chrisdone: its really lovely to have, especially for larger types
20:13:00 <mgsloan> augur: One similar-ish thing is to allow inserting cases that come from exhaustiveness warnings
20:13:04 <augur> its REALLY useful to have in dependent languages
20:13:27 <augur> mgsloan: exhaustiveness warnings go away with auto case splitting!
20:13:33 <augur> cause you just split and get all your cases :)
20:13:47 <chrisdone> he means you could use ghc's exhaustiveness warnings to populate the splitting
20:13:57 <augur> oh?
20:14:13 <bitemyapp> can you get exhaustiveness checking at compile time?
20:14:16 <chrisdone> i.e. by consulting ghci or w/e from emacs or whatever your editor i
20:14:25 <augur> bitemyapp: yeah, -Wall ghc flag
20:14:30 <chrisdone> bitemyapp: sure, enable -Wall or -fwarn-thingie-thingie
20:14:49 <bitemyapp> note to self, turn on -Wall by default, just like in C :)
20:14:53 <augur> chrisdone: oh, but thats not fun. i just want to type "xs C-c C-c" and split on xs
20:15:10 <chrisdone> augur: you're not used to extending your editor i take it?
20:15:17 <augur> chrisdone: no
20:15:20 <chrisdone> =)
20:15:24 <augur> i will never dick around with emacs
20:15:27 <augur> im too scared of it
20:17:09 * hackagebot purescript 0.1.13 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.13 (PhilFreeman)
20:17:24 <himhm> augur: vim
20:17:32 <augur> even worse!
20:17:42 <augur> i know very little emacs, and no vim!
20:18:17 <derekv> speaking of emacs
20:18:28 <himhm> couldn't live without it.
20:18:50 <chrisdone> augur: anyway, our suggestion was that you just bind C-c C-c to my-split-case-function which compiles the file and then looks for incomplete pattern match warnings and inserts what ghc suggests automatically
20:19:00 <derekv> I have cabal sandbox, but now flymake and ghci in emacs don't see any dependancies
20:19:28 <derekv> googling around for a howto but not finding anything
20:19:32 <chrisdone> augur: that was assuming you were able to. thinking about it, let me see how hard it is
20:19:59 <augur> chrisdone: i think it'd just be better to have a proper editor for haskell
20:20:09 <augur> ive got one in the works but its not really near being done
20:20:33 <heatsink> Didn't fpcomplete make one?
20:20:41 <derekv> augur: waitwait
20:20:46 <augur> an interblogosphere editor, sure, heatsink
20:20:50 <mgsloan> heatsink: Yeah, chrisdone and I are working on it!
20:20:52 <pxqr> What is modern replacement for HTTP package? http-conduit?
20:21:04 <chrisdone> pxqr: http-conduit is good
20:21:13 <mgsloan> augur: So does this case splitting stuff duplicate the rhs?
20:21:24 <mgsloan> (in agda or whatever other implementations there are)
20:21:28 <derekv> augur: sorry this isn't to sound mean but you are going to implement a "proper" editor without bothering to learn either of the two existing proper editors?
20:21:35 <pxqr> chrisdone: I guess so :)
20:21:41 <chrisdone> derekv: that's the natural way
20:21:44 <augur> mgsloan: in agda it requires that the rhs is a hole, so you cant split when there's content, no.
20:22:06 <himhm> derekv: I think augur might be pulling our legs
20:22:08 <augur> derekv: if there were two existing proper editors, i would learn them. :)
20:22:24 <mgsloan> augur: Right, but in the presence of content, it all gets copied, right?  What if the variable you're splitting on is used?  Does it use an x@ pattern?
20:22:39 <augur> mgsloan: in the presence of content, agda-mode refuses to case split
20:23:08 <derekv> well then, I won't be having any of my legs pulled sirs
20:23:08 <mgsloan> ahhh gotcha
20:23:25 <mgsloan> augur: I misparsed what you said a bit ago
20:23:43 <mgsloan> (as you can't split when there's <no> content)
20:23:50 <augur> mgsloan: sure you can
20:23:57 <augur> mgsloan: in agda you can: no content = a hole!
20:24:14 <mgsloan> right right
20:24:17 <augur> haskell doesnt have holes tho, so everything has some value or other, to some extent
20:24:37 <mgsloan> Well, I've been working on some refactoring stuff, but don't hold your breath!
20:25:16 <mgsloan> Well, it's got -XTypeHoles
20:25:29 <augur> i cant get that to work, so i have no idea what it does
20:26:06 <mgsloan> I think it's a somewhat prettier version of the implicit parameter trick, but I'm not sure
20:26:15 <enthropy> -XHypeToles
20:26:23 <enthropy> the next best thing
20:26:49 <mgsloan> the implicit parameter trick being inserting "?x" and seeing what the type error says the expected type is
20:27:12 <enthropy> unfortunately type holes steals valuable _ syntax to be used for implicit lambdas or something like that
20:27:25 <joelteon> type holes are only valid in places wild cards aren't
20:27:31 <enthropy> √† la scal√†
20:27:50 <enthropy> yes it steals syntax that was not used yet
20:28:38 <enthropy> I mean that (f x _ y _ _) might stand for  \ a b c -> f x a y b c
20:28:49 <joelteon> ew
20:28:53 <augur> thats horrible
20:28:58 <enthropy> think of the wonders with view patterns
20:29:07 <augur> views are cool
20:29:08 <enthropy> @quote evar
20:29:08 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
20:29:24 <enthropy> there would be some space in there for _ on the function side
20:29:38 <enthropy> err side that is an expression (which also happens to be a function)
20:29:49 <augur> enthropy: what the hell is THAT
20:30:13 <enthropy>  case x of (_ -> x) -> x -- would be like   case x of (id -> x) -> x
20:30:36 <augur> i dont even know what thats supposed to do
20:30:42 <augur> haskell views are confusing
20:31:04 <enthropy> I don't think you should call them views
20:31:14 <augur> why? thats what they are
20:31:29 <enthropy> that's suggesting there's some more complicated stuff going on
20:31:39 <augur> not really
20:31:45 <enthropy> rather than -XViewPatterns which is just like a pointfree -XPatternGuards
20:32:00 <augur> i dont know what you mean
20:32:37 <enthropy> http://www.reddit.com/r/haskell/comments/1kmods/patternsynonyms_ghc_trac/
20:34:41 <augur> enthropy: ok, and what do patternsynonyms have to do with viewpatterns and patternguards and views?
20:35:56 <enthropy> when you say views I think of something more general than -XViewPatterns such as patternsynonyms
20:36:15 <augur> thats.. your fault then. :P
20:36:56 <Adeon> how close is the 7.8 ghc release
20:37:03 <enthropy> if you try to redo pigworker's example with -XViewPatterns you end up with stuff like    node -> Just (a,b)
20:37:10 * hackagebot monoid-extras 0.3.2.4 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.2.4 (BrentYorgey)
20:37:12 * hackagebot dual-tree 0.2.0.1 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.2.0.1 (BrentYorgey)
20:37:14 * hackagebot active 0.1.0.10 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.10 (BrentYorgey)
20:37:16 <enthropy> which is not as good as an actual pattern  (Node a b)
20:37:27 <augur> enthropy: yes, this is true
20:37:33 <augur> pattern synonyms have their own uses
20:37:42 <augur> completely distinct uses tho
20:37:53 <augur> views are a completely separate thing from pattern synonyms
20:37:58 <enthropy> why distinct?
20:38:21 <augur> because they're not even remotely related? i dont know how to explain how two not the same things are not the same :P
20:38:31 <enthropy> you should be able to view patterns on the right hand of a pattern synonym
20:38:48 <augur> the classic example of a view from the DTP literature is stuff like InBounds or whatever
20:39:05 <augur> lemme find you a good example
20:39:24 <augur> itll probably be TVftL no doubt
20:40:55 <augur> enthropy: oh, yes, the Compare view is a nice one
20:41:28 <enthropy> where is it or what is it?
20:41:43 <augur> enthropy: ill give you some pseudo-dependent haskell code for it
20:41:45 <derekv> =.
20:42:02 <derekv> is it flymake or flycheck i should be using?
20:42:04 <enthropy> surely it can just be ordinary haskell
20:42:11 * hackagebot diagrams-core 1.0.0.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.0.0.1 (BrentYorgey)
20:42:17 <augur> enthropy: no, it has to be dependent otherwise its mostly useless
20:42:40 <enthropy> oh well it's probably still mostly useless then :p
20:42:47 <augur> data Compare (x y :: Nat) where
20:42:54 <augur>    CompLT :: (x y :: Nat) -> Compare x (x + Suc y)
20:43:04 <augur>    CompEq :: (x :: Nat) -> Compare x x
20:43:17 <augur>    CompGt :: (x y :: Nat) -> Compare (y + Suc x) y
20:43:24 <augur> and then you define
20:43:38 <augur> comp :: (x y :: Nat) -> Compare x y
20:43:48 <augur> comp 0 0 = CompEq 0
20:43:56 <augur> comp 0 (Suc y) = CompLt 0 y
20:44:10 <augur> comp (Suc x) 0 = CompGt x 0
20:44:24 <augur> comp (Suc x) (Suc y) with comp x y
20:44:42 <augur> comp (Suc x) (Suc (x + Suc y)) = CompLt (Suc x) y
20:44:54 <augur> comp (Suc x) (Suc x) = CompEq (Suc x)
20:45:10 <augur> comp (Suc (y + (Suc x))) (Suc y) = CompGt x (Suc y)
20:45:24 <enthropy> by   data Compare (x y :: Nat), you mean something like:  data Compare  (x :: k -> Nat) (y :: k)?
20:45:38 <augur> no i mean Compare :: Nat -> Nat -> *
20:46:31 <enthropy> so the first argument to CompLT is a pair of Nats?
20:46:52 <augur> enthropy: im just abbreviating successive ->'s with the same arg type
20:47:02 <augur> (x :: Nat) -> (y :: Nat) -> Compare x y
20:47:10 <augur> is far less readable than (x y :: Nat) -> Compare x y
20:47:11 <augur> i think
20:48:03 <enthropy> well then types like (m a) are now something else
20:48:15 <augur> enthropy: its just a gist, gosh
20:48:16 <augur> :P
20:48:23 <augur> the point is not the types
20:48:29 <augur> thats just me being lazy and using agda-ish notation
20:48:39 <augur> the point is the comp view.
20:48:49 <augur> the idea behind this view is that you don't merely compare the two values x and y to get GT EQ or LT
20:48:50 * enthropy feels obligated to defend the haskell against agda
20:49:06 <augur> you compare them in an informative, type-enforced way
20:49:24 <augur> thereby finding out how they relate to one another
20:49:33 <enthropy> now that I understand your (x y :: Nat) notation I will be able to understand comp
20:49:38 <enthropy> /CompEq
20:51:01 <Walnut> Anyone have a reference on the triple colon (i.e. :::) symbol as it pertains to ExistentialQuantification?
20:51:09 <Walnut> Best I can find is this: http://web.cecs.pdx.edu/~apt/icfp05.pdf
20:51:14 <Walnut> Which only mentions it in passing
20:51:28 <enthropy> Walnut: ::: is just a constructor name
20:52:07 <enthropy> so you have  data X a b = Y a b,   you can have   data Z a b = a ::: b
20:52:18 <enthropy> or maybe (:::) can be a type constructor I forget
20:52:53 <enthropy> the point is that it could just be an Uppercase name
20:53:14 <Walnut> Okay, thanks. That makes a lot more sense
20:53:30 <Walnut> pretty bizarre looking the first time you see it
20:53:35 <pqmodn> identifiers beginning with ":" are constructors. most common being one of []'s, and also Complex has :+
20:53:47 <pqmodn> (data constructors)
20:54:32 <lingomaniac> hi all, can someone point me to the goto non-broken package that haskell web app devs use to generate their random security tokens and hashes please?
20:54:39 <derekv> I have too many package management systems and development environment management systems i need a dev environment management management system with a package management management system
20:55:11 <enthropy> augur: I am confused why comp has/needs more than 4 equations
20:55:39 <augur> enthropy: you need to specify the GT/LT/EQ relation...
20:55:45 <augur> oh oh i see
20:55:57 <augur> enthropy: so when you do a with in this fictional pseudo-haskell
20:56:18 <enthropy> the first 4 ought to be enough
20:56:19 <augur> it further case analyzes the line its on, using the view
20:56:46 <augur> you need to make a recursive call to comp, right, but you need to use that in an informed way
20:57:15 <enthropy> why? I can define comp in haskell with just 4 cases
20:57:23 <augur> enthropy: not this comp you cant :)
20:57:27 <augur> this comp is dependent
20:57:44 <enthropy> what does + mean in a pattern?
20:57:47 <augur> the type checker can tell you when you've screwed up
20:57:51 <enthropy> does agda still have n+k patterns?
20:57:56 <augur> enthropy: no
20:58:11 <augur> enthropy: + means that the type checker can PROVE that the argument _must be_ some addition of that shape
20:58:42 <augur> + is just the normal addition function, but rather than that being a _match_, thats the type checker _telling you_ what the argument is
20:59:10 <augur> so the line   comp (Suc x) (Suc (x + Suc y)) = CompLt (Suc x) y
20:59:35 <augur> means that the type checker has proven that the second argument just is an addition of that form   Suc (x + Suc y))
20:59:41 <augur> notice the x is repeated
20:59:56 <augur> the type checker is telling you _its that very same x you got in the first argument)
21:00:09 <enthropy> aren't you missing some patterns where you've flipped the arguments of +?
21:00:18 <augur> no
21:00:21 <enthropy> or does agda know + is commutative?
21:00:26 <augur> neither
21:00:43 <augur> it just comes from how we defined Compare
21:01:44 <augur> i should really have said y' not y probably
21:01:52 <augur> in the last three cases
21:02:00 <augur> but we did a with on comp x y
21:02:13 <enthropy> ok so if you "call"  comp (Suc x) (Suc (Suc y + x))  there is no special case for that?
21:02:42 <augur> enthropy: no, you dont really ever call that directly, see
21:02:49 <augur> what you do is call comp on two Suc's
21:02:55 <augur> comp recursively calls itself
21:03:10 <augur> and then uses the result to refine the case split
21:03:20 <augur> so by calling comp x y
21:03:27 <augur> we know the result of comp x y is one of those three constructors, right
21:03:33 <augur> CompLT, CompEQ, and CompGT
21:04:00 <augur> if its CompLT, then we know that y == x + Suc y'
21:04:01 <enthropy> so you're defining how + works with comp I see
21:04:10 <augur> no, + is already defined elsewhere
21:04:22 <enthropy> it doesn't matter how you split up a tree of  (a + b + (c+d))
21:04:37 <augur> enthropy: there's no splitting
21:04:41 <augur> its all in the types
21:05:27 <augur> combined with the fact that we dont have definite values to resolve in the definition, we only have variables, so we can't compute down
21:05:46 <augur> x + Suc y just is that. it cant be anything else, because no computation rules apply
21:06:21 <augur> enthropy: this is the magic of DTP tho -- your language becomes vastly more expressive
21:07:01 <derekv> dammit nothing will work , so close and yet so far
21:07:22 <derekv> whats the best way to set up emacs for haskell developement and where is it written?
21:07:39 <enthropy> do these rules run backwards? As in I know   x >= y, so together with say  x <= 5 and y >= 5 the two variables are now 5?
21:08:13 <enthropy> where those inequalities are variations on your CompLT/CompEQ
21:08:28 <augur> enthropy: to know x >= y i presume you mean you have a proof of CompGT x y?
21:08:43 <augur> or rather, you have a proof CompGT x y
21:08:46 <augur> or something like that
21:08:55 <augur> maybe its a proof of Compare x y that is a CompGT
21:08:55 <enthropy> CompGT or CompEQ (if that's allowed ... otherwise we define a CompGE)
21:09:01 <enthropy> yes
21:09:09 <augur> i dont know, lemme try :D
21:09:13 <augur> enthropy: but also check out http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf
21:09:20 <augur> page 11 begins talking about a similar view
21:10:08 * enthropy can't really read those tables
21:10:28 <augur> enthropy: read the whole thing then
21:10:29 <enthropy> above the line is the "given" and is "you can deduce from the above"?
21:10:30 <augur> its only 11 pages
21:10:48 <augur> enthropy: yeah, they use natural deduction notation instead of normal notation
21:11:04 <roboguy_> is there a good general way to update a section of a list and leave the rest the same (maybe with lens)?
21:11:18 <augur> enthropy: so something like this:
21:11:31 <augur>   n : Nat
21:11:31 <augur> ‚Äî‚Äî‚Äî‚Äî
21:11:31 <augur> 1+ n : Nat
21:11:38 <augur> would be written in haskell as like
21:11:59 <augur> data Nat = ... | OnePlus Nat
21:12:12 <augur> or as the GADT constructor declaration   OnePlus :: Nat -> Nat
21:13:05 <enthropy> roboguy_: I like some variation on:     f m n y (splitAt m -> (x, splitAt n -> (_, z))) = x ++ y ++ z
21:13:46 <roboguy_> enthropy: I've never really used view patterns before, so I'm going to have to think about that
21:14:10 <enthropy> but I guess you might use (length y) instead of n
21:14:35 <enthropy> depends on what what bits you're trying to replace
21:15:33 <enthropy> another option is to   zipWith fromMaybe xs (replicate m Nothing ++ map Just y ++ repeat Nothing)
21:16:48 <augur> btw enthropy http://lpaste.net/96313
21:16:57 <augur> quite literally, i didnt write any of the RHS's
21:17:30 <augur> all i did was case split, write the with, match on the with, and then automatically solved for the RHS's because there was exactly one answer
21:18:11 <augur> anyway, lemme try to look at your question
21:18:33 <enthropy> but you had to write 7 LHSs while in Haskell I do 4 LHSs + 4 RHSs
21:18:47 <enthropy> so maybe it's a tie
21:18:58 <augur> enthropy: nope
21:19:04 <augur> i didnt write 7 LHSes either
21:19:10 <augur> i did case splits :)
21:19:21 <enthropy> which look like?
21:19:28 <augur> the last thre LHS's were automatically derived from the case on the recursive comp
21:19:49 <augur> enthropy: lemme rewrite it and ill give you the keypress-by-keypress breakdown
21:19:54 <enthropy> so why must they show up in your source code?
21:20:17 <augur> enthropy: because you need to know how the case on comp x y affected the matches on previous arguments
21:20:19 <enthropy> that's not so important I can figure agda out myself... after I learn emacs
21:22:25 <augur> well i cant remember how to do multiple case splits at once, tho there is a way
21:22:26 <augur> but
21:22:34 <augur> C-c C-c three times
21:22:40 <augur> C-c C-a three times
21:22:55 <augur> write with comp x y and make a new line with ... | r
21:23:04 <roboguy_> enthropy: I've run into that general idea before and I've wondered about it. maybe it's a little too general though. What reminded me this time was this StackOverflow question: http://stackoverflow.com/questions/20212973/stopping-list-traversal-as-soon-as-the-transformation-is-carried-on-first-elemen
21:23:08 <augur> C-c C-c on r, then C-c C-a three times
21:23:17 <enthropy> augur: suppose somebody defines a subtract (or a multiply) for Nat. Will it show up in the "generated" code?
21:23:29 <augur> enthropy: what do you mean?
21:23:29 <roboguy_> enthropy: my first thought was thought was that lens might have something, but I don't know that much about lenses
21:24:15 <enthropy> augur: I'm not sure why + is special then
21:24:29 <augur> enthropy: because i wrote + in the type
21:24:42 <augur> look at the constructors for Compare
21:25:55 <augur> enthropy: so with the Compare type, there's no way to construct the example you were looking for earlier because the patterns are just nasty
21:26:18 <augur> lemme try with the <= type tho
21:26:19 <enthropy> so there is no taking advantage of properties of - (suppose it exists...) unless you bake it into the definition of Compare?
21:26:23 <notadog> I started haskell a week ago, and I am absolutely loving it, haven't ever done programming before, but my first project is going well. Except, I am using gtk with gtk2hs, and cannot for the life of me make labels within buttons wrap text.
21:26:38 <augur> enthropy: there's no taking advantage of the properties of anything here
21:27:48 <enthropy> don't you get to use comp to get the difference between the two numbers, if they are different?
21:28:17 <augur> you can use it for that, yes
21:28:19 <enthropy> you could say something like "I only want to accept x,y if x is 5 larger than y"
21:28:27 <augur> no thats not what Compare does
21:28:40 <augur> Compare tells you LT/EQ/GT
21:28:43 <augur> but more importantly
21:28:55 <augur> it tells you how they're related
21:29:04 <augur> if the ordering is LT, then you wanna know, LT by how much?
21:29:06 <augur> same with GT
21:29:19 <augur> and more over, the _type system knows all of this_
21:29:34 <enthropy> I'm not sure what aspect disagreeing about
21:30:00 <augur> Compare is not a predicate _Requiring_ an ordering
21:30:07 <augur> thats a different thing entirely
21:30:19 <augur> its a way of looking at a pair of nats: as things that are ordered
21:30:22 <augur> its a view on Nat
21:30:29 <enthropy> but you can use it to specify such a thing?
21:30:52 <augur> to specify the type-level predicate? no. you could specify a computed test tho, sure
21:31:00 <augur> but that wouldnt be enforced by the type system
21:33:42 <enthropy> f x y | compGT _ diff <- comp x y, compGT _ _ <- comp diff 5 = ... -- I think
21:34:23 <augur> that wouldnt be a type level predicate tho
21:34:25 <augur> just a computation
21:34:54 <augur> anyway, the relevant thing is really tricky because of how evidence propogates
21:35:32 <enthropy> so you can write out a type that will not pattern-match failure on that single case?
21:35:45 <augur> oh it will pattern match appropriately
21:35:59 <augur> im just saying that it doesnt immediately yield the equations x = 5 and y = 5
21:36:38 <enthropy> yes it's the same with type families
21:36:46 <pomino> Anyone use tmux + vim to edit source code? Wondering what people use as the tmux prefix key.
21:37:13 <enthropy> you have to be very explicit about propagating information that a person might be able to see
21:39:16 <augur> enthropy: well the real was in agda is that to show that this stuff holds, you have to case on things until agda can see that the case has been refuted
21:39:50 <augur> agda doesnt do fancy reasoning. you could use some combinators to make that clearer, ofcourse
21:40:09 <augur> also fwiw, once agda figures out that x = 5 and y = 5, that information is instantly sent around to everywhere in scope
21:40:23 <notadog> What is a way to set label text to wrap instead of going out of the button?
21:41:31 <augur> enthropy: http://lpaste.net/96314
21:41:59 <augur> im sure there are other ways to do that, but i just picked the one that was left to right
21:42:13 <augur> by the time you refute down to there, in the hole {!!}, the goal is Compare 5 5
21:46:05 <enthropy> interesting
21:46:53 <augur> im not sure if its possible to do any deep coverage checking tho
21:47:25 <augur> i mean, haskell does shallow coverage checking, to see if anything immediately causes uninstantiability
21:47:51 <augur> i think deep coverage checking would amount to theorem proving or satisifiability checking and would become undecidable
21:57:38 <notadog> I have tried setting properties in glade (and the glade preview works as expected), have also tried set label1 [labelWrap := True] and set label1 [labelWrapMode := WrapAnywhere] but the label text still stays on one line.
22:01:32 <vamega2> Hi
22:01:43 <vamega2> I'm looking for a function of this type
22:01:49 <augur> vamega2: hoogle
22:01:54 <augur> @where hoogle
22:01:55 <lambdabot> http://haskell.org/hoogle ‚Äì See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:02:06 <vamega2> Thanks
22:02:23 <augur> i think you can also hoogle in channel
22:02:28 <augur> @hoogle a -> [a] -> [a]
22:02:29 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
22:02:29 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
22:02:29 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
22:02:49 <augur> humorous that (:) doesnt show up. lol
22:03:04 <augur> i guess its not looking in prelude
22:03:20 <enthropy> it's it is somewhere near the end of the results
22:03:29 <augur> oh
22:04:01 <enthropy> dunno what you'd do to hoogle to make it rank results better
22:04:17 <augur> enthropy: sort by type proximity?
22:04:19 <mm_freak> @hoogle [a]
22:04:19 <lambdabot> GHC.Exts build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
22:04:19 <lambdabot> Prelude repeat :: a -> [a]
22:04:19 <lambdabot> Data.List repeat :: a -> [a]
22:04:31 <enthropy> maybe sort by some distance you mention and also by popularity of the function?
22:05:18 <augur> yeah
22:05:22 * enthropy means the number of uses in hackage perhaps
22:06:16 <vamega2> So I guess what I'm looking for it something most akin to scanl1
22:06:23 <vamega2> The type was (a -> a -> a) -> [a] -> [a]
22:06:34 <vamega2> But I want something that operates on the original list
22:06:42 <vamega2> As opposed to successive reductions
22:06:53 <vamega2> so this mythical function f
22:07:08 <enthropy> @type \f xs -> zipWith f xs xs
22:07:09 <lambdabot> (b -> b -> c) -> [b] -> [c]
22:07:15 <notadog> Anyone got any ideas as to how a newbie could be screwing up setting a label to wrap its text?
22:07:32 <vamega2> Yeah, that's what I thought.
22:07:48 <enthropy> which can also just be map (\x -> f x x)
22:08:06 <vamega2> enthropy - I don't think map would work
22:08:19 <vamega2> I need to operate on an element and the element that precedes it in the list.
22:08:20 <enthropy> notadog: you are using the glade in your project?
22:08:31 <enthropy> yes then zipWith is the answer
22:08:41 <augur> offset the list a bit tho
22:08:48 <notadog> enthropy: yes I am using the glade produced by saving the project.
22:09:07 <zRecursive> Would you mind explaining "let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs" ?
22:09:08 <enthropy> if it shows up in the preview window by glade, those attributes ought to be set when you load the glade/builder file
22:09:23 <augur> zRecursive: sure!
22:09:33 <notadog> hmmmm. I am using gtk.builder, I will post the code in a minute.
22:09:36 <augur> zRecursive: so ill give you a sensible, hands on explanation
22:09:47 <zRecursive> augur: welcome
22:10:02 <augur> zRecursive: what happens is, haskell stores the list   `0 : 1 : zipWith (+) fibs (tail fibs)`   in the variable fibs
22:10:13 <enthropy> notadog: it might be an annoying mistake like "I'm loading the wrong builder file"
22:10:15 <augur> zRecursive: but remember, haskell is lazy, so it doesnt evaluate it all right away
22:10:26 <zRecursive> sure
22:10:52 <zRecursive> what happen when `fibs !! 15` ?
22:10:55 <augur> zRecursive: when you go to access the third element of this list, it evaluates a little bit:   fibs == 0 : 1 : ..., so tail fibs == 1 : ...
22:11:08 <augur> zRecursive: so it can get a little bit of the zipWith done:
22:11:46 <augur> zipWith (+) fibs (tail fibs) evals one notch to 0 + 1 : zipWith (+) (tail fibs) (tail (tail fibs))
22:11:59 <augur> zRecursive: which is ofcourse 1 : bigger ...
22:12:05 <augur> so now fibs = 0 : 1 : 1 : bigger ...
22:12:58 <augur> when you want to evaluate fibs !! 15, it pushes the zipWith down 13 places, exposing more and more of the structure
22:13:09 <toming> I find myself writing " >>= return . "  very often. I know this is the same as flip liftM, but I can't use that as a nice operator unless I redefine it. Is there something that can replace that construct simply?
22:13:38 <zRecursive> augur: is lazy key here ?
22:13:41 <enthropy> there is a <&> in Control.Lens
22:13:43 <augur> zRecursive: absolutely
22:14:03 <enthropy> or just flip things around and write f <$> x
22:14:04 <zRecursive> augur: thanks
22:14:05 <augur> zRecursive: you can do this with manual thunks too, i think
22:14:23 <augur> zRecursive: you might instead want to poke around with a simpler definition tho
22:14:24 <zRecursive> how to get "manual thunks" ?
22:14:39 <augur> well a thunk is just   Thunk a = () -> a
22:14:58 <augur> force f = f ()
22:15:13 <augur> so you'd write that in a strict language
22:15:35 <augur> writing your thunks manually everywhere, or using a macro system so that thunk x == \_ -> x
22:15:59 <toming> enthropy: thanks, i was looking for <&>
22:16:03 <zRecursive> is thunk a function ?
22:16:04 <augur> and you'd just make all of your lists thunky in recursive positions, at minimum, simulating laziness
22:16:11 <augur> zRecursive: no thunk has to be a macro
22:16:30 <notadog> enthropy: I am back, and my programs gui does display, correctly, other than labels not wrapping. I might just push it to my github and link that.
22:16:54 <augur> zRecursive: but you should try to grok these lazy things without looking at fibs first
22:17:09 <augur> maybe look at like a lazy let
22:17:27 <augur> let x = 5 ; y = x + 3 ; z = y * 2 in z
22:17:45 <augur> and try to work out how that actually works with laziness
22:17:53 <augur> then look at the loeb variant of that
22:18:43 <augur> loeb [const 5, (+3).(!!0), (*2).(!!1) ]
22:18:52 <zRecursive> augur: Can i see the thunk of "let x = 5 ; y = x + 3 ; z = y * 2 in z" ?
22:19:05 <augur> if you manually thunk it, its
22:19:33 <zRecursive> ok
22:19:40 <augur> let x = \() -> 5, y = \() -> force x + 3, z = \() -> force y * 2 in force z
22:20:01 <augur> ofcourse haskell hides forces and thunks for you
22:21:13 <zRecursive> great !
22:21:27 <augur> zRecursive: actually try to figure out how map or zip work first just by projecting after one of them
22:21:28 <augur> like
22:21:40 <augur> map f [0..10] !! 5
22:24:10 <zRecursive> augur: "lazy defaut" indeed is my obstacle to use Haskell, as i am afraid i will lose control of our software
22:24:30 <augur> why would you lose control?
22:26:14 <zRecursive> augur: because i donot know how GHC produces the thunks for my codes
22:26:48 <zRecursive> and hard to debug ?
22:27:03 <scshunt> why do you care about debugging it?
22:27:19 <scshunt> if your logic is correct, you generally don't care about how your compiler thunks
22:27:26 <enthropy> the better question is "do I get a stack trace"
22:27:38 <notadog> enthropy: https://github.com/instantepiphany/qsrun/blob/master/qsrun.hs
22:27:38 <scshunt> you have to assume it does it correctly anyway
22:27:50 <enthropy> of what calls happened before you reached some error
22:28:19 <zRecursive> scshunt: i need to used to haskell now as i am very influenced by other languages
22:28:24 <augur> zRecursive: how GHC produces thunks is boring and irrelevant
22:28:27 <notadog> enthropy: I just pushed everything, so it is all up to date. I can provide screenshots of glade preview vs actual program
22:28:37 <augur> zRecursive: an in fact GHC might not even produce thunks at all
22:28:38 <kvda> any reason why I'd be getting not in scope message for a data constructor, when it is there, ie i can tab complete it
22:28:40 <scshunt> zRecursive: did you code in, say, Java?
22:28:41 <kvda> ?
22:28:49 <augur> zRecursive: not in any interesting sense, anyway
22:29:08 <zRecursive> Java, Python and little Erlang
22:29:15 <augur> zRecursive: do you know how to write a scheme interpreter in scheme?
22:29:34 <zRecursive> augur: a little
22:29:44 <enthropy> notadog: maybe you lose the WrapAnywhere when you set the buttonLabel on the line below?
22:29:45 <augur> zRecursive: well, here's how you make a lazy scheme:
22:30:13 <augur> instead of evaling your args, then extending your environment for the lambda expression using the values you got
22:30:52 <augur> zRecursive: you instead just store the args in the environment, and when you use those variables, you check to see if they need to be evalled or not and do so (storing the result in place)
22:31:14 <enthropy> that button0-9 stuff is kind of ugly
22:31:27 <augur> voila, lazy scheme.
22:31:43 <augur> zRecursive: its just a question of eval-before-binding-to-a-var, or eval-when-the-var-is-first-used
22:32:10 <zRecursive> ok
22:32:17 <scshunt> zRecursive: do you care how Java does the virtual offsets and thunks necessary for implementing interfaces?
22:32:58 <zRecursive> scshunt: I first heard of thunks in Java
22:33:16 <scshunt> zRecursive: the thunks in haskell are of a different nature
22:34:38 <zRecursive> Java is default struct
22:34:48 <zRecursive> s/struct/strict
22:36:33 <enthropy> notadog: a while ago I did this (for the button0-9 and such): http://code.haskell.org/~aavogt/psim/src/ThBuild.hs
22:36:56 <enthropy> but that's not really a solution for your actual problem
22:37:40 <enthropy> notadog: you didn't add the qsrun.glade
22:42:14 <osnr_> hi all, I'm having some trouble optimizing an attoparsec parser.. it's parsing ~200MB config files (similar to JSON, but with linebreaks as separators, barewords, etc, so custom parser), and the memory usage and execution time are quite high imo (~2 minutes real, 150GB allocated)
22:42:55 <osnr_> any tips on where to proceed? looks like a common suggestion is to process input incrementally, but not sure how to do that with nested structure (it's not like a network log)
22:49:30 <arkeet> > fix wikipedia
22:49:31 <lambdabot>   Not in scope: `wikipedia'
22:53:39 <notadog> enthropy: oops, I just added and pushed the glade file. I don't actually have a line in there that sets the label (lb3, which is a child of button qs3), it is commented out. So shouldn't I get the text set in the glade file, but wrapped?
22:54:22 <dtgp> hi all. I have a record datatype that only contains 5 Doubles and, separately, a [Double] of the length 5. is there a standard way to pass each element from the list into the constructor? I realize that this can only be only possible if every type in the record is the same,
22:54:40 <enthropy> well you're saying it doesn't look like it's still set
22:55:59 <enthropy> dtgp: you can write out the function \(a:b:c:d:e:_) -> C a b c d e
22:56:38 <enthropy> there are ways to get that function from say a Data or Generic instance (which ghc can write for you)
22:56:46 <enthropy> but probably it's not worth the complication
22:57:04 <arkeet> it becomes easier with stuff like biplate
22:57:08 <notadog> enthropy: like something unsetting it?
22:57:12 <arkeet> and lens
22:57:22 <arkeet> or something
22:57:26 <arkeet> uh
22:57:32 <arkeet> I don't know.
22:58:50 <dtgp> enthropy: yes, i'm looking for a generic way. I'm not too familiar with Data or Generic, can you give some more details? Thanks for the help.
22:59:37 <enthropy> notadog: sure. I would try with commenting out those 'set' to see if they're to blame
23:01:17 <jfeltz> I have a case where forkIO doesn't block in ghci, but blocks when liftIO'd within ReaderT, what is the workaround here?
23:01:20 <enthropy> dtgp: this is another option http://www.haskell.org/haskellwiki/Template_Haskell/Marshall_Data -- though you can leave out the fromDynamic in there
23:01:42 <notadog> enthropy: just tried with all of the set lines commented out, still doesn't wrap. Don't know what to do :( have spent 6 hours just  trying to make labels wrap
23:03:29 <arkeet> jfeltz: show code?
23:04:45 <jfeltz> arkeet: liftIO $ void (forkIO . void . system $ "vlc"), EitherT, sorry
23:07:27 * hackagebot hedis-simple 0.1.0.0 - A simplified API for hedis  http://hackage.haskell.org/package/hedis-simple-0.1.0.0 (IanDuncan)
23:15:50 <jfeltz> arkeet: main = void (forkIO . void . system $ "vlc") >> putStrLn "que?"
23:16:11 <jfeltz> main :: IO ()
23:16:35 <notadog> enthropy: adding "widgetSetSizeRequest lb3 40 80" gave me wrapped text, a little too small but I can tweak it. I don't want to set this for every single label. Does this suggest that gtk.builder is somehow missing attributes of things it pulls from the glade file? or could I have screwed something up in glade?
23:16:39 <jfeltz> so it isn't EitherT..
23:20:59 <monochrom> jfeltz: ghci does several things behind your back to make some other use-cases convenient. the result in short is that ghci does not behave like a standalone program when threads are involved. do not use ghci as the standard. it isn't.
23:24:54 <jfeltz> monochrom: maybe System.Cmd.system doesn't play well with forkIO, otherwise I'm clueless
23:32:17 <jfeltz> monochrome, arkeet: setting -threaded as a ghc-option in cabal fixes it (I was just trying random crap)
23:34:42 <jfeltz> (so effectively, the -threaded flag to ghc)
23:35:16 <arkeet> yes, ghci + threads can have problems
23:37:13 <radish> anybody up who's familiar with Repa?
23:39:12 <enthropy> @tell dtgp http://lpaste.net/96321
23:39:13 <lambdabot> Consider it noted.
23:40:42 <jle`> radish: go ahead and ask
23:41:05 <radish> i need an array of a custom type but Repa seems to be complaining
23:41:07 <enthropy> hmm no lens neded there
23:41:18 <radish> am i doing something wrong or is repa mainly for numbers
23:42:14 <enthropy> it should complain if you're trying to use arrays that are U
23:42:21 <jle`> are you trying to use them boxed or unboxed
23:42:25 <enthropy> the other modes should be fine for a custom type in there
23:42:27 <radish> how do i not do that? lol
23:42:50 <jle`> where is it complaining?
23:42:52 <radish> that's exactly my problem but there doesn't seem to be a fromListDelayed - obviously i have no idea what i'm doing lol
23:43:09 <radish> it's complaining when i tell it fromListUnboxed for obvious reasons
23:43:31 <jle`> have you tried fromList
23:43:32 <chemuduguntar> hi all
23:43:42 <chemuduguntar> can anyone see what I am doign wrong here?
23:43:42 <chemuduguntar> http://lpaste.net/5893117703354318848
23:44:05 <radish> jle`: uh... no.
23:44:06 <jle`> right or wrong i am have no moral authority to judge
23:44:07 <chemuduguntar> when I run the function it never returns
23:44:24 <radish> jle`: cut me slack i'm rookie to repa, haskell, and programming in general ;)
23:44:34 <jle`> don't worry about it :)
23:44:51 <radish> jle`: what are you, some kind of sageguru?
23:44:51 <jle`> chemuduguntar: how are you running the function
23:44:59 <chemuduguntar> oh ghci
23:45:06 <jle`> radish: oh no i was replying to chemuduguntar
23:45:18 <radish> jle`: oh lol :D
23:45:23 <jle`> kind of facetiously saying that he needed to be more specific when he said 'wrong'
23:45:50 <radish> jle`: what repa type should i use? not U obviously. D okay?
23:46:02 <scott_> chemuduguntar: Both branches of your if expression recurse. You have no base case.
23:46:09 <chemuduguntar> it seems logical but I can't see what it is about the function that makes it go forever
23:46:51 <chemuduguntar> hmm
23:47:00 <chemuduguntar> I think I am misunderstanding the meaning of lazy / infinite
23:47:04 <scott_> Oh, I guess that could make sense if you're generating an infinite sequence. I didn't look very closely.
23:47:10 <radish> jle`: wait there is no fromList thats why I didn't try it lol
23:47:30 <chemuduguntar> I expected 'take' to magically cease the infinite looping..
23:47:31 <jle`> radish: there should be a fromList in Data.Array.Repa.Eval
23:48:14 <jle`> radish: and delayed does not refer to the type of the data stored, it just means that the array has not yet been evaluated
23:48:18 <jle`> i think you want V
23:48:58 <scott_> chemuduguntar: Oh, but there is a problem for the reason I gave. iter recurses without actually doing anything towards producing a value
23:49:17 <scott_> chemuduguntar: A function like repeat x = x : repeat x doesn't *just* recurse, it also has that x : on there.
23:49:35 <radish> jle`: fromIndex?
23:49:47 <radish> jle`: no such fromList in Eval either
23:49:56 <scott_> chemuduguntar: So in take 3 (repeat 'x') you get take 3 ('x' : 'x' : 'x' : repeat 'x') and then take ignores the last repeat 'x', essentially.
23:50:16 <jle`> radish: what version are you using?
23:50:22 <jle`> http://hackage.haskell.org/package/repa-3.2.3.3/docs/Data-Array-Repa-Eval.html#v:fromList
23:50:22 <radish> jle`: 3
23:50:23 <chemuduguntar> oh yea ... wtf am I returning :D
23:50:40 <jle`> chemuduguntar: it might help to write out explicit type signatures to your top level functions :)
23:50:44 <radish> jle`: erm... okay?
23:51:06 <scott_> chemuduguntar: That's what you need to figure out, because right now you don't return anything at all ;)
23:51:06 <jle`> radish: fromList is there
23:51:39 <jle`> go into ghci, type import Data.Array.Repa.Eval
23:51:44 <jle`> and then :info fromList
23:51:55 <jle`> does something show up?
23:52:31 * hackagebot SimpleH 1.2 - A light, clean and powerful Haskell utility library  http://hackage.haskell.org/package/SimpleH-1.2 (MarcCoiffier)
23:52:35 <radish> jle`: no  no i figured it out it was a bug on my end
23:52:55 <jle`> oh ok
23:53:01 <radish> jle`: i imported Repa twice not Repa and Repa.Eval - rookie lol
23:53:28 <radish> jle`: i get caught up doing multiple things and ghci doesn't complain like i think it will
23:53:49 <radish> jle`: so Delayed isn't a type i can specify?
23:56:50 <radish> jle`: thanks so much sir.
