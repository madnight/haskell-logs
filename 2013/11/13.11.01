00:00:28 <mm_freak_> Shin-LaC: if it's a small utility for personal use and the files are small, David's suggestion will work
00:00:44 <Shin-LaC> otherwise?
00:01:03 <mm_freak_> fmap (map (map read . words) . lines) (readFile "abc.txt")
00:01:05 <mm_freak_> something like that
00:01:10 <mm_freak_> otherwise it depends on the grammar
00:01:30 * sopvop wanted to use bound for type safe sql thingie. But then just made stupid a writer monad.
00:01:40 <mm_freak_> if the grammer begins by splitting into lines, then i would use a streaming abstraction like pipes to split the file
00:02:02 <mm_freak_> if the grammar is more complicated, i would use parsec
00:02:10 <Shin-LaC> ok
00:02:50 <pharaun> fd:15: hFlush: resource vanished (Broken pipe)
00:02:57 <mm_freak_> if you like brainteasers and the grammar can be constructed by layering features on top of each other, then you can try trifecta
00:02:59 <pharaun> any pointer on how to even start tracking down ^
00:03:01 <Shin-LaC> do I have to do line <- readLn ; map read $ words line :: [Int]? or is there a way to avoid the separate line variable?
00:03:03 <adnap> edwardk: "If you replace Functor constraint the definition above with Applicative you get a Comonad I call the Bazaar."
00:03:09 <mm_freak_> if this is about high speed parsing, try attoparsec
00:03:22 <pharaun> i have been searching the code for any handler/fd stuff but i'm not having luck so far
00:03:32 <edwardk> adnap: ?
00:03:33 <mm_freak_> Shin-LaC: you don't use readLn
00:03:46 <adnap> edwardk: https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1
00:03:54 <adnap> edwardk: Just grammar
00:04:06 <David> Shin-LaC: juts use bind
00:04:12 <edwardk> oh missing 'in'
00:04:27 <Shin-LaC> aah
00:04:36 <adnap> edwardk: And "the"
00:04:46 <mm_freak_> Shin-LaC: for the small-personal-tool case i've given you a snippet that should work
00:04:57 <edwardk> fixed
00:05:05 <mm_freak_> :t fmap (map (map read . words) . lines) . readFile
00:05:07 <lambdabot> Read b => FilePath -> IO [[b]]
00:05:11 <mm_freak_> yeah, seems to work
00:05:12 <Shin-LaC> mm_freak_: I don't like reading the entire file at once
00:05:20 <Shin-LaC> also, different lines will have different formats
00:05:21 <mm_freak_> Shin-LaC: it uses lazy I/O
00:05:26 <mm_freak_> ah
00:05:34 <mm_freak_> depending on what?  the previous line?
00:05:37 <Shin-LaC> yes
00:05:45 <Shin-LaC> for example, the first line might contain a number of records
00:05:51 <Shin-LaC> and then there will be that number of lines
00:06:05 <mm_freak_> Shin-LaC: in that case you may want to use an incremental parser
00:06:18 <Shin-LaC> is parsec such a parser?
00:06:18 <adnap> edwardk: Also, "An interesting exercise for the advanced Haskeller is to take the the definition of experiment as the definition for Store." doesn't quite make sense because the type signature of the first "experiment" doesn't completely match "runPretext"
00:06:52 <mm_freak_> Shin-LaC: every monadic parser is incremental in the sense i'm going to explain
00:07:06 <adnap> edwardk: I'll just keep reading thought because I have no idea where this article is going yet. It just seems like abstract nonsense right now and I don't know what the types are doing
00:07:29 <edwardk> i added a bit about flip in there
00:07:55 <edwardk> fixed
00:08:09 <mm_freak_> Shin-LaC: example:  you want to parse a CSV file, where the first line contains the headers, which specify the type of the values in the corresponding column
00:08:25 <mm_freak_> Shin-LaC: then i would start by writing the header parser:  header :: Parser [Parser Field]
00:08:46 <mm_freak_> Shin-LaC: this parser parses the header line and results in a list of column parsers for the rest of the file
00:08:48 <edwardk> the 'glimpse down the rabbit hole' section is more a short digression about abstract nonsense that is relevant to that sub-topic, but not the problem at hand
00:08:50 <mm_freak_> depending on the header line
00:09:13 <mm_freak_> then all you would to would be to 'sequence' the list 'many' times
00:09:17 <adnap> edwardk: What do you mean by "flip". It doesn't seem to have anything to do with the Haskell function "flip"
00:09:33 <mm_freak_> do fields <- header; many (sequence fields)
00:09:34 <edwardk> experiment :: Functor f => (s -> f s) -> Pretext s a -> f a
00:09:50 <edwardk> flip experiment :: Functor f => Pretext s a -> (s -> f s) -> f a
00:10:11 <edwardk> if we shove the Functor f to the right you get
00:10:15 <mm_freak_> oh, actually:  do fields <- header; many (sequence fields <* endOfLine)
00:10:19 <mm_freak_> whatever your endOfLine is
00:10:29 <edwardk> flip experiment :: Pretext s a -> (forall f. Functor f => (s -> f s) -> f a)
00:11:14 <edwardk> if you define newtype Pretext s a = Prextext { runPretext :: forall f. Functor f => (s -> f s) -> f a }       -- then flip experiment = runPretext
00:11:18 <Shin-LaC> hm
00:11:31 <sopvop> that is the same Pretext thing as used in ALens type?
00:11:36 <edwardk> we're taking the definition then from a universal property that characterizes the description
00:12:00 <edwardk> er the universal property that characterizes the structure in question
00:12:14 <mm_freak_> Shin-LaC: the parsec tutorial is a good start…  and all you need to keep in mind is that the result of a parser can be another parser =)
00:12:19 <edwardk> sopvop: yeah
00:12:39 <edwardk> sopvop: modulo a lack of independent indexing
00:12:43 <adnap> Does experiment :: Functor f => (s -> f s) -> Store s a -> f a have nothing to do with your statement?
00:12:45 <mm_freak_> Shin-LaC: http://www.cs.uu.nl/~daan/parsec.html
00:12:54 <adnap> ...about "flip"
00:13:01 <edwardk> take that type. flip experiment
00:13:09 <edwardk> Store s a -> (s -> f s) -> f a
00:13:26 * hackagebot free 4.2 - Monads for free  http://hackage.haskell.org/package/free-4.2 (EdwardKmett)
00:13:26 * hackagebot yesod-platform 1.2.4.4 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.4.4 (MichaelSnoyman)
00:13:27 <mm_freak_> (as a side note, this is what distinguishes a monadic parser from an arrow parser)
00:14:04 <mm_freak_> (ignore this side note, if you don't understand it at this point)
00:14:24 <Shin-LaC> sequence $ take 5 (repeat readLn :: [IO Int])
00:14:34 <edwardk> Functor f => Store s a -> (s -> f s) -> f a   -- gives you a lot of information about what Store s a could possibly look like inside. if every such function is in one to one correspondence with Store s a the easiest way to ensure that is by picking the most obvious isomorphism: id
00:14:36 <Shin-LaC> it kinda works!
00:14:50 <edwardk> so we say Store s a ~ forall f. Functor f => (s -> f s) -> f a
00:14:56 <edwardk> thats where Pretext comes from
00:15:04 <adnap> edwardk: Oh, I get it
00:15:09 <Shin-LaC> mm_freak_: should I go straight to parsec, or should I try to cobble it together with the prelude IO stuff first?
00:15:30 <mm_freak_> Shin-LaC: if you have time, learning parsec is definitely a good way to spend it
00:15:35 <adnap> edwardk: The type of runPretext takes a Pretext as the first argument. I didn't think about that
00:15:53 <Shin-LaC> also, is there a better way to read five lines than what I did above?
00:15:56 <adnap> edwardk: Or, that's wrong
00:15:56 <edwardk> another way to get pretext is to compare the signature for a lens in the data-lens style and a lens n the lens style
00:16:05 <mm_freak_> Shin-LaC: it's overkill for splitting a file into lines and then words, but for even slightly more complicated scenarios it's definitely a good choice
00:16:36 <edwardk> s -> (a, a -> s) ~ s -> Store a s   is a data-lens
00:16:39 <mm_freak_> Shin-LaC: readLn has the same partiality issue as 'read' itself
00:16:45 <adnap> edwardk: I don't know what you mean by "get pretext". I'm just going to keep reading. I don't know what a Pretext or a Store is supposed to be
00:16:56 <mm_freak_> Shin-LaC: but to answer your question:
00:17:02 <adnap> It's just types with no purpose to me
00:17:02 <mm_freak_> take 5 (repeat x) = replicate 5 x
00:17:10 <edwardk> forall f. Functor f => (a -> f a) -> s -> f s  is a lens-style lens.  if you flip that, you get s -> forall f. Functor f => (a -> f a) -> f s
00:17:11 <Shin-LaC> ah, thank you!
00:17:14 <mm_freak_> sequence (replicate n x) = replicateM n x
00:17:16 <Shin-LaC> what's the partiality issue?
00:17:23 <Shin-LaC> ooh
00:17:27 <mm_freak_> so what you wrote:  replicateM 5 readLn
00:17:28 <mm_freak_> =)
00:17:36 <mm_freak_> the partiality issue is this:
00:17:37 <edwardk> so (forall f. Functor f => (a -> f a) -> f s)  ~ (a, a -> s)
00:17:42 <mm_freak_> > read "abc" :: Integer
00:17:43 <lambdabot>   *Exception: Prelude.read: no parse
00:17:46 <mm_freak_> crashes your program
00:18:00 <mm_freak_> (in a graceful way, but still)
00:18:02 <edwardk> adnap: i just mean 'derive a definition for'
00:19:00 <adnap> edwardk: Okay, so I guess somehow a Pretext is like a lens, but I don't quite get it yet
00:19:11 <sopvop> > reads "abc" ::  [(Int, String)]
00:19:13 <lambdabot>   []
00:19:20 <sopvop> > reads "11abc" ::  [(Int, String)]
00:19:21 <lambdabot>   [(11,"abc")]
00:19:22 <Shin-LaC> oh, I see
00:19:43 <mm_freak_> Shin-LaC: ultimately you will probably want to use Text (instead of String) for dealing with text files
00:19:49 <edwardk> adnap: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t     -- if you partially apply that to the second argument you get a Pretext
00:20:10 <mm_freak_> Shin-LaC: 'read' and 'readLn' won't be available for Text, unless you convert to String first
00:20:13 <Shin-LaC> what does Text do?
00:20:19 <adnap> edwardk: The other thing that is confusing me is that the first Store definition contained an (s -> a), where the Pretext does not
00:20:23 <mm_freak_> Text is a type for text strings
00:20:30 <mm_freak_> a compact type using UTF-16 encoding
00:20:39 <mm_freak_> String is actually a linked list of Char values
00:20:47 <adnap> edwardk: I guess it is hidden in the runPretext function
00:20:51 <mm_freak_> type String = [Char]
00:21:10 <edwardk> adnap: Correct. Pretext is _not_ obviously connected to Store, but they are equally powerful. That was why it was an interesting enough aside to comment about ;)
00:21:22 <mm_freak_> Text likely speeds up your program by orders of magnitude
00:21:23 <edwardk> adnap: the connection between them is fairly subtle
00:21:36 <Shin-LaC> ah
00:22:26 <Shin-LaC> fmap words getLine <- is this how I apply functions to a line I'm reading?
00:22:37 <mm_freak_> Shin-LaC: yeah
00:22:48 <mm_freak_> :t fmap words getLine
00:22:50 <lambdabot> IO [String]
00:22:59 <Shin-LaC> I don't get what David was saying about bind
00:23:11 <mm_freak_> Shin-LaC: equation: let x = y
00:23:17 <mm_freak_> Shin-LaC: binding:  x <- y
00:23:17 <Shin-LaC> isn't bind >>= ? I would need a function that outputs an IO
00:23:23 <Shin-LaC> o
00:23:28 <mm_freak_> yes, (>>=) is binding
00:23:40 <adnap> I just realized something that is a bid odd. I sort of knew this before, but it is only seeming odd now. The type signature for any function inside a data definition has an implicit first argument unlike ordinary function type signatures
00:23:43 <mm_freak_> '<-' is translated (desugared) to an application of (>>=)
00:24:02 <Shin-LaC> but in this case I cannot use just <-, can I? I need fmap
00:24:19 <edwardk> adnap: s -> (a, b -> t) ~ (s -> a, s -> b -> t) can be put into one to one correspondence with the  forall f. Functor f => (a -> f b) -> s -> f t   definition used by lens but its subtle. given s and a function from (a -> f b) you need to get to f t, but you know nothing about 'f' except that its a functor, so you have nothing to make one out of nothing with, so you need to use the function (a -> f b)   that means you must know some
00:24:20 <edwardk>  function from s -> a.
00:24:23 <mm_freak_> Shin-LaC: ln <- getLine
00:24:29 <mm_freak_> Shin-LaC: now you can apply 'words' to 'ln'
00:24:41 <mm_freak_> Shin-LaC: or you can apply it right away:  wds <- fmap words getLine
00:24:42 <Shin-LaC> ah, but that's what I was trying to avoid
00:24:46 <Shin-LaC> having the extra ln variable
00:24:46 <Shin-LaC> ok
00:24:51 <mm_freak_> :t fmap
00:24:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:24:54 <mm_freak_> replace f by IO
00:25:22 <edwardk> now you have 'f b', but you need 'f t'. you still have 's' in the environment and you can use the other parts of it. so you can fmap your 'setter' function (s -> b -> t) partially applied to 's'  to get a function (b -> t) and take f b -> f t
00:25:31 <edwardk> going the other way requires creative choices of 'f'
00:25:32 <mm_freak_> :t fmap :: (String -> [String]) -> IO String -> IO [String]
00:25:33 <lambdabot> (String -> [String]) -> IO String -> IO [String]
00:25:39 <dpwright_> is it possible to set up a private server with cabal-install and have the client try that first, and then fall back on hackage if it can't find the package in there?
00:25:48 <mm_freak_> Shin-LaC: what edwardk said was not for you =)
00:26:18 <edwardk> =)
00:26:23 <mm_freak_> dpwright_: see ~/.cabal/config
00:26:32 <mm_freak_> dpwright_: if it's not there, cabal update
00:26:58 <adnap> edwardk: O dpm
00:27:07 <adnap> edwardk: I don't know what "s -> (a, b -> t) ~ (s -> a, s -> b -> t)" means
00:27:12 <dpwright_> mm_freak_: Thanks.  Is it a relatively recent feature then?
00:27:24 <edwardk> when i put ~ in there i'm just saying 'is isomorphic to'
00:27:24 <mm_freak_> dpwright_: not quite, and i haven't tried it myself =)
00:27:33 <mm_freak_> dpwright_: but i'd expect local-repo to work exactly that way
00:27:34 <edwardk> you could split that function into two functions
00:27:52 <adnap> edwardk: Are you saying both things on either side of ~ are equivalent to a lens?
00:28:02 <edwardk> foo :: s -> (a, b -> t)   can be split into fst . foo :: s -> a    and snd . foo :: s -> b -> t
00:28:05 <edwardk> yes
00:28:42 <adnap> edwardk: Oh!
00:29:03 <edwardk> s -> Store a s ~ s -> (a, b -> t) ~ (s -> a, s -> b -> t) ~ forall f. Functor f => (a -> f b) -> s -> f t ~ s -> s -> (forall f. Functor f => (a -> f b) -> f t) ~ s -> Pretext a s
00:29:28 <Shin-LaC> mm_freak_: is this a sensible way to read a line consisting of integers? fmap (map read . words) getLine :: IO [Int]
00:29:52 <mm_freak_> Shin-LaC: in the small-personal-utility scenario yes =)
00:30:26 <edwardk> its easier to just show 'they satisfy the same universal property and therefore must be isomorphic' than to show the isomorphism directly, but all of these paths yield the same insight in the end
00:30:38 <mm_freak_> Shin-LaC: however, i strongly recommend encoding your parser as a pure function
00:30:54 <mm_freak_> Shin-LaC: parseStuff :: String -> Either Error Stuff
00:31:08 <mm_freak_> Shin-LaC: this function should do the line-splitting
00:31:28 <edwardk> (technically what i wrote was a bit of a lie since the post there used a 1-arg unindexed version of pretext and store iirc, and the intermediate states there used the indexed forms
00:31:42 <Shin-LaC> and I would rely on lazy IO, right?
00:31:42 <mm_freak_> getLine is a poor choice, because it forces you to use an imperative loop
00:31:49 <mm_freak_> Shin-LaC: in that case yes
00:31:55 <edwardk> s -> Store a b t ~ s -> (a, b -> t) ~ (s -> a, s -> b -> t) ~ forall f. Functor f => (a -> f b) -> s -> f t ~ s -> s -> (forall f. Functor f => (a -> f b) -> f t) ~ s -> Pretext a b t -- is not lying, but uses types slightly more complicated than in the post
00:32:10 <mm_freak_> Shin-LaC: lazy I/O is the best you can get without a parser library and/or a streaming abstraction
00:32:31 <mm_freak_> if you want to stay in functional, declarative land
00:33:00 <Shin-LaC> ok, let's try this
00:34:18 <arkeet> edwardk: thanks for the link :)
00:34:40 <edwardk> arkeet: acowley's talk?
00:34:57 <arkeet> yes
00:35:33 <adnap> edwardk: Where does s -> b -> t come from> I didn't see that anywhere in the definitions on https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1
00:35:49 <Shin-LaC> mm_freak_: but a purely functional parser cannot be used interactively, then, because I have to feed it the entire input, right?
00:36:00 <edwardk> b ~ a, s ~ t in the definitions there
00:36:08 <mm_freak_> Shin-LaC: wrong
00:36:10 <Shin-LaC> I cannot parse a record and then write a prompt and read again
00:36:21 <edwardk> i chose to split it becaus its easier for me to keep the variances straight in my head when i have all for s t a b parameters for a lens
00:36:24 <Shin-LaC> oh
00:36:42 <Shin-LaC> I can pass it a lines object and have it return the rest of the lines?
00:36:48 <Shin-LaC> that were left unparsed?
00:37:12 <mm_freak_> well, in a sense…  you can ask for the leftover, but commonly you don't do that
00:37:22 <mm_freak_> write the parser /as if/ you would be parsing the whole string at once
00:37:25 <adnap> edwardk: Also, the page has Store s a but you mentioned Store a b t
00:37:26 <edwardk> usng: newtype Store a b t = Store (b -> t) a    then s -> Store a b t ~ s -> (b -> t, a) ~ s -> (a, b -> t)  ~ (s -> a, s -> b -> t)
00:37:30 <alexander__b> alexander__b | hey whose bot is lpaste and how do I get it to my channel?
00:37:40 <mm_freak_> but the abstraction itself is actually incremental in the sense that you feed it chunk by chunk
00:38:08 <edwardk> adnap: i chose to write the page in terms of the 'normal' store comonad rather than the indexed comonad you need to talk about lens
00:38:22 <adnap> edwardk: What do you mean by "indexed"?
00:39:24 <edwardk> you can make a version of a monad/comonad that carries more information a couple of ways. the easiest would be to look at something like State s a = s -> (a, s)    and ask yourself what would happen if the two 's's could be different types?
00:39:38 <edwardk> You get
00:39:58 <edwardk> newtype State i j a = State { runState :: i -> (a, j) }
00:40:20 <edwardk> now clearly to return you need to have the i and j be the same, return :: a -> State i i a  -- works like it used to
00:40:52 <edwardk> because return a = State $ \i -> (a, i)  -- has no other 'j' to put there and still be a generalization of the existing state monad
00:41:14 <mm_freak_> put :: j -> State i j ()
00:41:19 <edwardk> then if you put in the definition of (>>=), in this more general type, you want the is and j to pair up
00:41:30 <edwardk> but put can change the state as mm_freak_ showed
00:41:38 <adnap> Sorry, this is just making no sense to me. I mean, I have no context for all this
00:41:43 <edwardk> and get sees what s currently there, leavng it alone
00:42:04 <mm_freak_> adnap: do x <- get; put (length x); y <- get
00:42:11 <mm_freak_> adnap: x :: String, y :: Int
00:42:19 <adnap> Why are we talking about State all of a sudden?
00:42:34 <edwardk> class IMonad m where return :: a -> m i i a; (>>=) :: m i j a -> (a -> m j k b) -> m i k b   -- that is an indexed monad
00:42:38 <mm_freak_> adnap: because State is the most intuitive example
00:42:43 <edwardk> because i was hoping you'd have intuition for state
00:42:46 <edwardk> and its easily indexed
00:42:50 <edwardk> store is dual
00:42:57 <adnap> ...
00:43:04 <edwardk> but indexed comonads are hard for folks who don't have intuition for comonads
00:43:18 <edwardk> and its 4am and i have a flight in the morning and i'm tired
00:43:23 <edwardk> =P
00:43:24 <adnap> Okay, I have no idea what you mean by "indexed" still.
00:43:35 <edwardk> you know what a monad is right?
00:43:38 <adnap> Yes
00:43:43 <edwardk> look at the IMonad above, notice the extra two parameters
00:43:44 <arkeet> "indexed" isn't a great word for it. =(
00:43:48 <adnap> Yes, I see them
00:43:50 <edwardk> not my word
00:43:53 <edwardk> those are the indices
00:43:54 <arkeet> just saying.
00:43:59 <adnap> Alright
00:44:12 <edwardk> we're going to let them vary over the course of the computation
00:44:22 <edwardk> your 'state' for your state monad can change _types_ over time now
00:44:44 <edwardk> your output monoid for writer becomes a category, your input for reader can change types as you use local, etc.
00:45:08 <adnap> I don't use Writer or Reader
00:45:18 <mm_freak_> Cont is an interesting example…  your intermediate result can now be different from your final result
00:45:26 <mm_freak_> adnap: you should =)
00:45:26 <adnap> If I recall, Reader is just a function
00:45:51 <adnap> mm_freak_: You should
00:46:05 <mm_freak_> adnap: almost…  the combination of Reader and Writer is an interesting monad
00:46:16 <Shin-LaC> mm_freak_: I'm not sure I understand... I would write the parser to take a String, which would be the output of readFile. you mean I can just call readFile again to read the rest of the file after that? there is no data that gets lost in buffers and suchlike?
00:46:16 <mm_freak_> build a result based on some environment
00:46:28 <edwardk> indexing a monad makes it possble to write functions you couldn't write with the unindexed version of it. likewise with an indexed comonad
00:46:43 <edwardk> this is one of the 3 major ways i know to model indexed structures. i'm sticking to this one for now
00:46:50 <mm_freak_> Shin-LaC: you would leave reading the file to the parser library (or you combine it with a streaming abstraction, as said)
00:47:03 <Shin-LaC> ah, I see
00:47:07 <adnap> So, "indexed" just means carry a state that changes type over time?
00:47:24 <edwardk> no, its that you have that type parameter that changes, its not necessarily state
00:47:30 <hamid> :t (***)
00:47:30 <mm_freak_> adnap: "indexed" in this context means:  the Monad class knows about the index type
00:47:31 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
00:47:33 <edwardk> for "State" it s state
00:47:39 <edwardk> for reader its the type of the envronment
00:47:52 <mm_freak_> adnap: here is the regular 'return':  return :: a -> m a
00:48:04 <edwardk> for writer its the type of the output result you're chaining in
00:48:08 <mm_freak_> adnap: as you see, the Monad class knows nothing about your state/environment/log/…
00:48:19 <mm_freak_> adnap: all Monad cares about is the result type
00:48:30 <mm_freak_> IMonad does care about an additional type
00:48:44 <adnap> Okay, remember I don't use Writer or Reader if you explain this. I just use regular functions and add arguments as needed
00:49:06 <adnap> So, I might not be able to understand
00:49:24 <adnap> ...in terms of Writer/Reader vocabulary
00:49:31 <edwardk> adnap: the section  you're hung up on btw- does very clearly at the top say '(This section is completely skippable and is included as a highly technical aside)'
00:49:41 <adnap> edwardk: I read that
00:49:47 <mm_freak_> adnap: take Either as an example…  allow Either to produce different Left types depending on where you are in the computation
00:49:55 <edwardk> adnap: it was written mostly as a segue for folks who are already familiar with the basic ideas involved but who want to go deeper
00:50:07 <edwardk> adnap: just mentioning that its not necessary for the rest of that article ;)
00:50:30 <adnap> edwardk: Okay, I'll try to read the rest of the article first.
00:50:37 <edwardk> getting more experience with reader/writer, store, etc. before coming back to it may make a lot more sense than slogging through it, because its a _very_ deep dive
00:50:49 <mm_freak_> (>>=) :: Either e a -> (a -> Either e' b) -> Either e' b
00:50:51 <adnap> Well, I just don't know how to get experience
00:50:54 <edwardk> as you may have noticed given the deluge of content every time you ask a question
00:51:00 <adnap> I never know I need these things in my code
00:51:52 <mm_freak_> adnap: i've never knowingly used an indexed monad…  you can get along without them quite well
00:52:08 <mm_freak_> but it's an interesting thing to keep in mind
00:52:25 <adnap> mm_freak_: I was thinking of Writer and Reader when I wrote "these things".
00:52:34 <arkeet> mm_freak_: I wouldn't know how to implement that indexed Either.
00:53:00 <edwardk> i often _write_ my monads out first as an indexed monad even if i'll use it unindexed, because it strengthens the free theorems
00:53:03 <arkeet> (what happens when I throw a Left of e at it
00:53:19 <edwardk> @djinn-env
00:53:19 <lambdabot> data () = ()
00:53:20 <lambdabot> data Either a b = Left a | Right b
00:53:20 <lambdabot> data Maybe a = Nothing | Just a
00:53:20 <lambdabot> data Bool = False | True
00:53:20 <lambdabot> data Void
00:53:21 <lambdabot> type Not x = x -> Void
00:53:23 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
00:53:24 <mm_freak_> arkeet: you're right…
00:53:25 <lambdabot> class Eq a where (==) :: a -> a -> Bool
00:53:39 <arkeet> edwardk: State is a good example.
00:53:58 <arkeet> it's easy to accidentally write >>= for state to use the same state twice, or something
00:54:00 <edwardk> @djinn-add data IState i j a = State (i -> (a, j))
00:54:11 <edwardk> @djinn a -> IState i i a
00:54:12 <lambdabot> f a = State (\ b -> (a, b))
00:54:31 <arkeet> huh, didn't know you could do that with djinn
00:54:33 <edwardk> @djinn IState i j a -> (a -> IState j k b) -> IState i k b
00:54:33 <lambdabot> f a b =
00:54:33 <lambdabot>     case a of
00:54:33 <lambdabot>     State c -> State (\ d ->
00:54:33 <lambdabot>                       case c d of
00:54:33 <lambdabot>                       (e, f) -> case b e of
00:54:35 <lambdabot>                                 State g -> g f)
00:54:39 <mm_freak_> arkeet: i don't remember how i wrote this, but it's possible to have an error-indexed Either
00:54:46 <edwardk> that did all the right things and used all the parts, right?
00:55:16 <edwardk> @djinn-add data State s a = State (s -> (a, s))
00:55:25 <edwardk> @djinn a -> State s a
00:55:25 <lambdabot> f a = State (\ b -> (a, b))
00:55:28 <edwardk> that one works
00:55:37 <edwardk> @djinn State s a -> (a -> State s b) -> State s b
00:55:37 <lambdabot> f a b =
00:55:37 <lambdabot>     case a of
00:55:37 <lambdabot>     State c -> State (\ d ->
00:55:37 <lambdabot>                       case c d of
00:55:37 <lambdabot>                       (e, f) -> case b e of
00:55:39 <lambdabot>                                 State g -> g f)
00:55:47 <arkeet> lucky you.
00:55:49 <edwardk> hh, tat one worked just to mess with me
00:55:57 <edwardk> it often wont =)
00:56:06 <arkeet> djinn could also tell you that there are multiple solutions
00:56:17 <arkeet> it seems to tend to give the most "interesting" one first
00:57:02 <edwardk> mm_freak_: yes, i've done that one as well
00:58:04 <mm_freak_> data Either e1 e2 a = Left (e1 -> e2) e2 | Right a
00:58:07 <mm_freak_> something like that
00:58:18 <arkeet> heh
00:59:19 <edwardk> @djinn-add data ICont i j a = ICont ((a -> i) -> j)
00:59:30 <edwardk> @djinn a -> ICont i i a
00:59:31 <lambdabot> f a = ICont (\ b -> b a)
00:59:49 <edwardk> @djinn ICont i j a -> (a -> ICont j k b) -> ICont i k b
00:59:49 <lambdabot> -- f cannot be realized.
00:59:53 <edwardk> awww
01:00:17 <edwardk> @djinn-add data ICont i j a = ICont ((a -> j) -> i)
01:00:20 <edwardk> @djinn ICont i j a -> (a -> ICont j k b) -> ICont i k b
01:00:20 <lambdabot> -- f cannot be realized.
01:00:56 <edwardk> i've had it derive this before
01:01:01 * edwardk shrugs.
01:01:13 <arkeet> @djinn ICont j i a -> (a -> ICont k j b) -> ICont k i b
01:01:14 <lambdabot> f a b =
01:01:14 <lambdabot>     case a of
01:01:14 <lambdabot>     ICont c -> ICont (\ d ->
01:01:14 <lambdabot>                       c (\ e ->
01:01:14 <lambdabot>                          case b e of
01:01:14 <edwardk> must be more tired than i thought
01:01:16 <lambdabot>                          ICont f -> f d))
01:01:52 <mm_freak_> i should indexify ContinueT =)
01:01:58 <edwardk> ah, must have flopped it around to get the variance wrong
01:02:02 * edwardk shrugs.
01:02:15 <edwardk> with ICont you can write shift/reset
01:02:23 <adnap> I don
01:02:26 <edwardk> or at least a version of it
01:02:29 <adnap> I don't understand "0 & partsOf (taking 3 bits) .~ [f (s+1), f s, f (s-1)]"
01:02:43 <arkeet> it sets the first 3 bits of 0 to those things in the list.
01:02:48 <adnap> & and .~ aren't explained
01:02:49 <edwardk> adnap: it takes the next 6 paragraphs or so and unpacks that statement =)
01:02:52 <arkeet> heh.
01:02:56 <edwardk> x & f = f x
01:03:08 <adnap> I read the explanation
01:04:09 <edwardk> http://hackage.haskell.org/package/lens-3.10/docs/Control-Lens-Setter.html#v:.-126-
01:04:31 <edwardk> > ("hello","world") & _1 .~ 1923123
01:04:33 <lambdabot>   (1923123,"world")
01:04:44 <arkeet> @djinn IState i j (IState j k a) -> IState i k a
01:04:45 <lambdabot> f a =
01:04:45 <lambdabot>     case a of
01:04:45 <lambdabot>     State b -> State (\ c ->
01:04:45 <lambdabot>                       case b c of
01:04:45 <lambdabot>                       (d, e) -> case d of
01:04:47 <lambdabot>                                 State f -> f e)
01:04:52 <edwardk> > (_1 .~ 1923123) ("hello","world")
01:04:54 <lambdabot>   (1923123,"world")
01:13:27 * hackagebot cblrepo 0.9.3 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.9.3 (MagnusTherning)
01:14:02 <adnap> edwardk: Okay, I think I get it. Thanks
01:15:12 <adnap> edwardk: taking 3 bits is a Traversal of an Integer, and partsOf turns it into a Lens on a list, and then we set it with [f (s+1), f s, f (s-1)], so the first 3 bits of the 0 Integer are set to the values in the list
01:19:44 <edwardk> yep
01:20:10 <edwardk> 3 bits = 8 possibilities, so thats the indices into the 8 bits of a Word8
01:21:04 <individual> is it possible to detect if parsec has an unexpected end of input error (apart from checking the error message string which is silly)? I'm making a REPL and I want to give users the chance to type in more input in that case
01:21:19 <adnap> edwardk: Rogjt
01:21:21 <adnap> *Right
01:25:34 <adnap> edwardk: Do you care about the grammar mistakes in your article? There are more, but I don't know if I should bother pointing them out
01:26:44 <edwardk> adnap: i do, but if you could put them into an email it might work better given my level of consciousness and need for sleep before a long day tomorro
01:26:57 <edwardk> ekmett@gmail.com
01:27:00 <mm_freak_> edwardk: is there a trifecta tutorial somewhere?  one that actually explains trifecta, not parsing =)
01:27:34 <edwardk> mm_freak_: not that i know of. mostly because trifecta is still very much a work in progress and large parts of the bare wiring are kind of sticking out
01:27:45 <therp> hi folks, my X server just crashed.. is there anything in the arch build process that saves the symbol map of built shared libraries? or is my only hope to rebuild with debug symbols?
01:28:01 <mm_freak_> edwardk: ok, thanks
01:28:29 <therp> arg, sorry wrong channel
01:31:26 <johnw> mm_freak_: my version of the trifecta docs: "Use it like it's parsec, enjoy the better error messages; go to #haskell-lens when things don't work or don't make sense"
01:32:36 <joncfoo> is there a way to have cabal generate documentation for all installed packages?
01:37:29 <edwardk> johnw: =)
01:39:12 <vonDraco> is there a way to make an IO Char into a regular Char?
01:42:16 <arnsholt> Yes, but if you ask it's probably not what you actually want
01:42:34 <vonDraco> aight
01:42:43 <arkeet> in other words, no
01:42:47 <arkeet> actually
01:43:06 <arkeet> read http://www.haskell.org/haskellwiki/How_to_get_rid_of_IO
01:43:16 <arkeet> and its related links
01:43:38 <edwardk> aight: in practice what you want to do is build a bigger IO action.    do c <- getChar; print c
01:43:43 <arkeet> also don't read section 2.1 for it might give you funny ideas.
01:44:41 <arnsholt> vonDraco: Also, if you explain your problem in some more detail we might be able to say something more useful
01:45:02 <edwardk> do notation there is letting you glue one IO action "getChar :: IO Char"   int another IO action (print :: Char -> IO ())    applied to (c :: Char) gives you (print c :: IO ()), the type of 'do' block is set up so that every action in it has the same monad (here IO) and takes the type of the final result type inside it. here ()
01:45:39 <edwardk> we don't 'get the Char' out of IO in any global sense, but within the do block we can use it.
01:45:49 <vonDraco> thanks for the link.
01:46:19 <edwardk> later on you'll find out that this is all just normal function composition. getChar >>= \c -> print c
01:46:31 <vonDraco> and i'm not completely sure what i'm doing, but i'm taking a hand, which is input, and then seeing if it's the character 'c'
01:46:33 <edwardk> or getChar >>= print
01:46:55 <vonDraco> so i just tacked in an hGetChar before input
01:47:12 <arnsholt> Yeah, then you definitely want do notation or >>=
01:47:22 <edwardk> do ch <- getChar; if ch == 'c' then ... else ...
01:47:42 <edwardk> where each ... should be another IO action
01:47:50 <mm_freak> johnw: could work =)
01:48:32 <vonDraco> i see. i'll try that out
01:48:55 <arnsholt> (Where "should" means "must be an IO action or the compiler will yell at you" =)
01:49:56 <mm_freak> vonDraco: when you write "x <- c", if (c :: IO T), then (x :: T)
01:50:11 <mm_freak> vonDraco: the "<-" notation is intentionally only possible within a 'do' block
01:50:59 <vonDraco> so it's somewhat backwards to = in a non-do block?
01:51:37 <vonDraco> "c = x, if ..."?
01:51:53 <mm_freak> vonDraco: "=" and "<-" aren't much related
01:52:07 <mm_freak> with "=" you construct an equation
01:52:16 <mm_freak> with "<-" you're giving the result of a monadic action a name
01:52:22 <mm_freak> that's why it's called "binding"
01:52:25 <mm_freak> x <- getLine
01:52:36 <mm_freak> you bind the name x to the result of getLine
01:52:58 <mm_freak> (i'm not being overly accurate with terms here, for the sake of understandability)
01:53:35 <vonDraco> okay, then say if from getline you bind x with "text"
01:53:45 <vonDraco> then x is essentially the same as "text"?
01:55:13 <mm_freak> vonDraco: what do you mean?  express your thought in code
01:55:25 <edwardk> x is the same as 'the result of running text', not equal to text.
01:55:37 <edwardk> there is a distinction being made here you aren't used to making elsewhere
01:55:57 <adnap> lol. edwardk didn't go to bed.
01:56:14 <edwardk> let x = getChar   means x is now an IO action that when run will give you a char.   x <- getChar in a do block is saying x is the result from running getChar
01:56:26 <edwardk> adnap: i suck at doing what i'm supposed to
01:56:46 <adnap> I was supposed to go to bed too
01:57:11 <johnw> mutually assured insomnia
01:58:12 <edwardk> vonDraco: let hi = print "hello" in do hi; hi; hi   -- hi is an IO acton there, x <- print "hello"    x is just the result from IO ()  which is a value of type (), which is boring.
01:59:40 <vonDraco> okay, i think i'm getting it
02:00:15 <vonDraco> i think i'll just come back to this later when i have a better understanding on monads.
02:00:44 <mm_freak> vonDraco: don't try too hard to understand monads…  for now just learn to use IO =)
02:05:29 <tdammers> one of the epiphanies I had while trying to "understand" monads is that there is less to understand than you'd think
02:05:55 <mm_freak> vonDraco: in other words:  don't try to understand monads, try to understand IO =)
02:06:06 <mm_freak> ideally just forget that you ever heard of the word "monad" for now =)
02:06:38 <mm_freak> a value of type IO String is a program (literally!) that results in a String…  and that's it
02:06:40 <vonDraco> but i just can't shake it off
02:06:47 <mm_freak> main :: IO ()
02:06:53 <mm_freak> so main is a program that results in a ()
02:07:08 <mm_freak> all you need to understand is how to combine small programs to get larger programs
02:07:30 <mm_freak> and all you need for that is to understand do-notation for now =)
02:08:09 <mm_freak> getLine is a program that reads a line from stdin, "putStrLn x" is a program that writes the line x to stdout
02:08:15 <mm_freak> do x <- getLine; putStrLn x
02:08:19 <mm_freak> this is a combined program
02:08:25 <vonDraco> but earlier you said that () is boring, but it's the result of a whole program!
02:08:39 <mm_freak> vonDraco: i don't remember saying that
02:08:45 <mm_freak> () is one of the most exciting features of haskell =)
02:09:13 <vonDraco> haha
02:09:49 <vonDraco> i'll just keep trudging along for now. bit by byte
02:12:12 <anc768> Hello, I have a strange problem with a file handle and bracket. Seems like my file handle has already been closed automatically everyt time I get to the cleanup code...
02:12:52 <mm_freak> anc768: are you using lazy I/O?
02:12:55 <anc768> It's for a logging system, and on exiting the last few logs operations always encounter a closed handle, the cleanup code of bracket just finds a closed handle as well
02:13:05 <mm_freak> hmm, shouldn't matter actually
02:13:35 <mm_freak> anc768: pass a logging function instead of a handle
02:13:39 <anc768> Yeah, basically I only have a single function that writes to the handle, it's never closed, never leaves that module etc.
02:14:12 <mm_freak> anc768: withLog k = withFile "log" AppendMode (\h -> k (hPutStrLn h))
02:14:20 <anc768> I have a withLogging function and also store it inside a record in a top level mvar
02:14:29 <mm_freak> that makes the handle invisible to user code
02:15:25 <anc768> It's already invisible to the user because of the top level MVar that contains all logging information, but the problem is just that it seems to be closed by somebody around the time the application exits
02:16:08 <anc768> And I'm pretty sure it's not me ;-)
02:17:07 <anc768> The handle is only accessible inside a single  module, and everything is wrapped in a bracket. I do not close the handle, yet before shutdown I start encouter a closed file handle and it's always close by the time I'm in bracket's release code
02:18:05 <anc768> I only ever write to the handle with hPutStrLn, there's no exception or anything, seems like the runtime just closes it for some reason?
02:18:52 <mm_freak> anc768: perhaps some finalizer fires?
02:20:31 <anc768> Ok, but how would I figure that out? I never close this handle, never pass it anywhere. It's pretty much just like withFile, and then it's just closed
02:21:03 <schell> whatever anybody said to me earlier tonight i didn't get - my chat log doesn't go that far back!
02:21:08 <Saizan_> withFile does close the Handle
02:21:22 <anc768> Yes, but I don't use withFile
02:21:35 <schell> is there an official irc log?
02:21:57 <schell> happy halloween all, btw
02:21:57 <anc768> I use bracket, it's already closed shortly before the function returns and I get to the cleanup code
02:22:00 <Saizan> schell: yep, look in the topic
02:22:28 <Saizan> anc768: how do you open this handle?
02:22:28 <anc768> Last few prints into the log have a closed handle, if I add a check 1 line before my hClose, it's already closed
02:22:43 <anc768> openFile
02:23:49 <schell> Saizan: cool, thanks
02:24:20 <schell> carter: thanks, i've since built the newest ghc HEAD and i'll see if it's magically fixed
02:24:29 <schell> fingers crossed
02:27:12 <anc768> The docs say that GHC will close a handle once it is GC'ed, but cleary that can't be the case as I can actually see that is closed...
02:30:33 <Adeon> are you sure it just doesn't collect it really quickly
02:31:41 <anc768> If I can look at it and tell it's closed, how could it GC it? It's clearly still referenced if I can notice it's closed, isn't it?
02:31:42 <merijn> Adeon: Clearly if he has a Handle to inspect, said Handle can't be garbage collected...
02:31:55 <Adeon> oh, right
02:32:03 <merijn> anc768: Can you paste a minimal example on lpaste?
02:32:37 <anc768> Well, as with 99% of Haskell bugs I encounter, they never reproduce in the small example ;-) I'd love to, otherwise...
02:32:55 <merijn> anc768: Well, how big is the non-small example?
02:33:11 <anc768> Can this be related to threading? Like if I have an async exception or something in another thread or anything like that?
02:33:23 <merijn> anc768: "doesn't reproduce in small example" usually means "error is somewhere in this bits you stripped out" ;)
02:33:47 <merijn> anc768: Well, sure, if you have another thread closing the Handle this could happen (or if you close it yourself somewhere), etc.
02:34:37 <anc768> But I don't, handle never leaves the module, module never closes the handle except in the finalizer of bracket, where it's already closed, I don't see much I can screw up there
02:35:56 <merijn> anc768: If you're using bracket anyway, maybe you wanna try withFile and see if that works?
02:36:00 <merijn> @hoogle withFile
02:36:01 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
02:36:01 <lambdabot> System.Posix.ByteString.FilePath withFilePath :: RawFilePath -> (CString -> IO a) -> IO a
02:36:31 <anc768> Doesn't withFile just internally use a partially applied bracket?
02:36:48 <merijn> anc768: Yes, but that rules out any mistakes in the bracket for example :)
02:36:54 <johnw> @src withFile
02:36:55 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
02:37:00 <johnw> bingo
02:46:00 <AshyIsMe> so does anyone else use SHIM?
02:46:02 <anc768> http://lpaste.net/8392134181034917888
02:46:05 <AshyIsMe> i find it really slow sometimes
02:46:14 <AshyIsMe> and sometimes it seems to hang
02:46:20 <anc768> Sorry, It's a bit of a mess, but that's basically it
02:46:28 <AshyIsMe> is there something better for integrating ghci with vim?
02:46:46 <merijn> anc768: I'll see whether I find an issue before I get bored looking at that :p
02:47:09 <merijn> AshyIsMe: Personally I just use tmux to have vim/ghci split screen. What sort of integration are you looking for?
02:47:35 <AshyIsMe> yeah i can do the same but it's nice to have :GhciFile to load the current buffer
02:48:08 <anc768> Yeah, again sorry for the mess, just trimmed it down. I commented out all other logging code, it's really just that, ~50% of the time the handle is already closed
02:48:09 <AshyIsMe> cos it ends up being :gh<tab><CR>  and the file is loaded into ghci
02:49:21 <merijn> anc768: hmm, word of warning using two blocking operations in the initialisation of a bracket is not threadsafe in the presence of async exceptions
02:49:43 <merijn> anc768: Although I'm not sure whether tryPutMVar is blocking
02:50:05 <merijn> anc768: Wait, is your code using withTrace multiple times?
02:51:24 <anc768> No, the try is actually to see if there are multiple initializations and the MVar has been written to (there's a error handler in the full code). withTrace also gets called before any other threads are launched, so no async Exceptions. withTrace is onlt used a single time, all logging happens through the top level mvar then
02:52:01 <merijn> anc768: You don't really need an MVar, though, do you?
02:52:18 <merijn> You could just use this opening code and pass the TraceSettings using Reader
02:52:40 <anc768> Wanted to avoid that, I really just want to be able to log everywhere
02:52:51 <merijn> anc768: I figured you didn't have async exception, that was more of a "raising awareness for later" type thing :)
02:53:27 <anc768> I have a bunch of threads, some conduit http stuff, some worker threads, json parsing, OpenGL ui etc., would've been a bit annoying to make sure all of it runs in the right ReaderT
02:53:44 <merijn> Do you have the code that uses TraceSettings for writing?
02:54:34 <anc768> No, the MVar is never written, it's basically only a lock around the trace module to make sure all traces are atomic (multiline stuff should not be interrupted)
02:55:18 <merijn> I don't see any errors here, so the problem has to be in the code using the MVar
02:55:25 <anc768> Also in the bracket you can see I actually use the original record to close the file, not the one from the MVar
02:55:56 <anc768> So even if the contents of the MVar were totally trashed, it would still have the right file handle returned by openFIle
02:56:36 <anc768> (and you've looked at all the code using the MVar, I commented everything else out and still have the error)
02:59:04 <merijn> anc768: I meant the code doing the actual logging
02:59:14 <merijn> anc768: What's run within this trace?
03:01:20 <anc768> I changed the trace function to return (), same issue. I noticed the error only seems to happen when some other worker threads exit with an STMBlock exception (I check them with waitCatch). THe program is unfortunately rather complex, http conduits, OpenGL, worker threads etc.
03:02:15 <michel> ciao
03:02:29 <michel> !list
03:02:29 <monochrom> michel: http://lpaste.net
03:03:57 <anc768> I guess for me the question is just, how can what any other thread does even have an effect on this code? No other thread has access to the file handle (all commented out), and the bracket exits cleanly. But the handle is closed ;-)
03:04:14 <merijn> anc768: uh, wait
03:04:31 <merijn> anc768: oh, no I think I misinterpreted that
03:04:39 <merijn> I dunno, tbh
03:06:45 <anc768> To me it seems like some strange RTS bug. The other thread exits with BlockedIndefinitelyOnSTM (which itself seems like nonsense since there's only a single transaction in there and I cancel it with asyncCancel), and then my file handle is closed, WTF ;-)
03:08:39 * hackagebot bittorrent 0.0.0.1 - Bittorrent protocol implementation.  http://hackage.haskell.org/package/bittorrent-0.0.0.1 (SamTruzjan)
03:09:28 <anc768> And as usual a simple version of this won't exhibit any bug like this, and I think there's no chance this will get looked at if I file a bug with the whole program
03:19:22 <fxr> hi, I want to execute an IO action which creates a socket and waits for a connection but with a specific timeout. How can I implement such a functionality ensuring that all the resources will be freed after the timeout period?
03:22:59 <Reite> Im creating a library and a front-end(web application) for the library in haskell. I want to separate the library package from the front-end package. The front-end is dependant on the library but not the other way. How can I set up a workflow so that i can work on both packages at the same time while still being able to easily install new library dependencies in the front-end sandbox? I think
03:22:59 <Reite> I basically want the front-end cabal-file to include the local library package as a dependency. Any hints or links for how to achieve this?
03:29:51 <Fristi> Hello there
03:31:54 <Fristi> I just started with Haskell, read most parts of Learn You a Haskell and parts of Real World Haskell, but I wonder after writing my first program which uses IO a good and concise way to deal with IO errors/exceptions like getDirectoryContents :: IO [FilePath] can throw several errors.. what is a general way to deal with these errors?
03:32:34 <ion> fristi: Control.Exception
03:32:56 <Fristi> ya try returns Either
03:33:05 <ion> or catch
03:34:07 <Fristi> guess it dependant on the situation how to deal with these errors
03:34:33 <Fristi> it felt abit much to deal with all the errors, any tips on that ?
03:35:08 <ion> What do you mean by that?
03:36:51 <Fristi> @ion: try returns a Either , dealing with that Either in all your functions which might return an error on IO gets abit repetitive
03:36:51 <lambdabot> Unknown command, try @list
03:36:57 <Fristi> ion: try returns a Either , dealing with that Either in all your functions which might return an error on IO gets abit repetitive
03:37:29 <ion> fristi: 0) use catch; 1) why do you want to catch all possible errors?
03:38:22 <Fristi> ion: i'll take a loon at catch :) I wrote a forever running process, so if it crashes it does need to recover and retry again
03:38:25 <merijn> Fristi: You can also use the Either functor/monad to not have to deal with either in all your functions
03:39:01 <Fristi> ya also was thinking of that, might that give a go :)
03:39:24 <merijn> :t fmap (+1) `asAppliedTo` Left "blah"
03:39:25 <lambdabot> Num b => Either [Char] b -> Either [Char] b
03:39:27 <Fristi> was wondering if there were even smarter ways to cope with errors
03:39:43 <merijn> > fmap (+1) `asAppliedTo` Left "blah"
03:39:46 <lambdabot>   <Either [Char] Integer -> Either [Char] Integer>
03:39:57 <merijn> > fmap (+1) (Right 1)
03:39:58 <lambdabot>   Right 2
03:40:54 <Fristi> ya or: (+1) <$> Right(1)
03:41:10 <merijn> The second parens there are redundant
03:41:12 <Fristi> synonyms :)
03:41:15 <merijn> > (+1) <$> Right 1
03:41:17 <lambdabot>   Right 2
03:41:33 <Fristi> ah ofc hehe :)
03:44:25 <lurkorg> ghci puts all the currently loaded modules into the prompt, which becomes unmanageable with a few modules loaded.. I can fix that with :set prompt, but it comes back when I use :{ and }: for multi line things
03:44:30 <lurkorg> is there a way to switch that off?
03:45:04 <Flonk> lurkorg: :set prompt "> "
03:45:05 <donri> lurkorg: with ghc HEAD or ghci-ng, :set prompt2
03:45:25 <donri> @hackage ghci-ng
03:45:25 <lambdabot> http://hackage.haskell.org/package/ghci-ng
03:45:36 <yaxu> Flonk: aye, but that doesn't work for multiline commands
03:45:41 <ion> fristi: FWIW, you can `catch` \(e :: SomeException) -> … to catch anything, but that may not be what you actually want. For one, it will also catch UserInterrupts.
03:46:01 <Flonk> yaxu: Yeah, I started writing before I read the whole thing there
03:46:09 <yaxu> donri: hm OK thanks
03:47:19 <Fristi> ion: I see. So for example \e :: IOException would be better
03:48:04 <ion> fristi: Depends. You may want to handle UserInterrupt separately but still catch all other errors, for instance.
03:49:11 <Fristi> ion, merijn: going to play with that :) thanks for the help so far
03:56:11 <jophish_> Yo yo yo
05:15:49 <jophish> Yo yo yo
05:16:06 <Taneb> Hi, jophish
05:16:48 <jophish> I'm using ghc-mod with vim, This is fantastic for completion of symbols in other modules, but it doesn't seem to have any information on the current module. Is there any nice supplement to ghc-mod to allow me to tab-complete symbols in the current module?
05:21:29 <donri> jophish: normal vim completions? :P
05:22:13 <jophish> donri: type information would be handy. I don't get any normal completion results either, but I'm sure I can find a way to append these
05:22:52 <donri> jophish: hm i think type info should work...
05:23:32 <donri> jophish: WFM with hdevtools. duno about ghc-mod but they should be mostly the same
05:23:42 <jophish> donri: I'll have to give this another check later.
05:23:58 <jophish> I think I'm using hdevtools
05:24:06 <donri> jophish: uh actually no i don't get completions, but type inspection works
05:24:14 <jophish> yeah, that's what I have
05:24:27 <chrisdone> it's my understanding that hdevtools is like ghc-mod but works
05:24:33 <donri> haha
05:24:41 <jophish> (Also, it's a bit of a pain to have to save the buffer before getting type info. Is there any way to cache this information?)
05:25:00 <donri> i think currently ghc-mod might have the advantage there, by supporting cabal sandboxes directly
05:25:11 <donri> someone said you can set up hdevtools for them too, but it's not automatic
05:28:27 <Sagi> can someone give me a few pointers? I'm trying to repeatedly combining a list of lists and a list, with the intention to cons'ing the second on top of each of the members of the first.
05:28:53 <Sagi> I've been playing around a bit, but somehow I continuously end up with more levels of nesting than I need.
05:29:01 <Sagi> s/combining/combine
05:29:37 * chrisdone gives Sagi ←, → and ↖
05:31:15 <Sagi> errr, what do those symbols mean?
05:32:02 <Sagi> I can see how the first arrow could relate to >>= in do notation, but I don't recognize the others.
05:33:02 <chrisdone> Sagi: what kind of pointers are you looking for?
05:33:25 <Sagi> pff, I get the pun now :-(
05:33:47 <jophish> donri, chrisdone Will you be around later when I get home. Could I interrogate you about your vim setups?
05:34:07 <chrisdone> jophish: i don't use vim
05:34:14 <ocharles> I think chrisdone's vim setup is very simple
05:34:16 <chrisdone> but i'll be around later when you get home
05:34:24 <ocharles> it's probably just a 'apt-get remove vim'
05:34:33 <jophish> boo! hiss!
05:34:34 <chrisdone> ocharles: purge =p
05:34:38 <ocharles> hehe
05:34:49 <ocharles> I installed emacs again today
05:35:03 <ocharles> I tend to oscillate between the two every 6 months or so
05:35:05 <chrisdone> along side your other operating system?
05:35:15 <Sagi> I'm basically looking for a way to repeatedly combine [[1,2]] with [3,4] to arrive at [[1,3],[1,4],[2,3],[2,4]], but attempts I have been making with (:) and applicative operators get me nowhere.
05:35:28 <ocharles> chrisdone: nono, emacs straight onto xen
05:35:32 <ocharles> none of this kernel nonsense
05:36:03 <chrisdone> know that makes gnusense
05:36:27 <chrisdone> Sagi: so what's the type of the function you'd want?
05:36:42 <Sagi> combine :: [[a]] -> [a] -> [[a]]
05:37:06 <chrisdone> maybe a simple list comprehension, looks like the cartaesian product
05:37:18 <chrisdone> > [ [x,y] | x <- [1,2], y <- [3,4] ]
05:37:20 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
05:37:46 <ocharles> Sagi: what is 'combine [[1],[2]] [3,4]' ?
05:37:53 <donri> chrisdone: i played with emacs yesterday; setting up agda-mode ;) figured out how to get it to use my colorscheme (i think it might be a new feature)
05:38:11 <Sagi> chrisdone: yeah, but I want to use it in a fold-like function, so that notation might be somewhat unwieldy
05:38:13 <chrisdone> :t flip (:) :: [[a]] -> [a] -> [[a]]
05:38:15 <lambdabot> [[a]] -> [a] -> [[a]]
05:38:22 <donri> makes the highlighting less detailed though :(
05:38:25 <chrisdone> donri: yay agda-mode!
05:38:43 <Sagi> ocharles: oh, you cought me
05:38:44 <chrisdone> donri: you mean because fewer things have the right color?
05:38:44 <Sagi> caught
05:38:54 <donri> vim-idris recently got agda-mode-like stuff, i gotta play with that
05:39:23 <Sagi> [[1,2]] with [3,4] should yield [[1,2,3],[1,2,4]]
05:39:39 <donri> chrisdone: duno! the default setting uses hard-coded colors which looks shite, but detailed. presumably the setting to use the colorscheme has a limited "semantic" palette
05:39:41 <Sagi> or in front of it, that's more efficient I guess
05:39:48 <donri> chrisdone: i don't know how colorschemes work in emacs though
05:39:56 <Sagi> :t (:)
05:39:57 <lambdabot> a -> [a] -> [a]
05:40:06 <donri> chrisdone: it could just be a bad interaction between solarized and agda-mode
05:40:13 <Sagi> oh
05:40:46 <Sagi> > (:) <$> [3,4] <*> [[1,2]]
05:40:48 <lambdabot>   [[3,1,2],[4,1,2]]
05:40:53 <Sagi> duh
05:41:48 <chrisdone> donri: probably agda-mode has its own font faces that you'll have to additionally configure that the solarize theme doesn't know exist
05:42:00 <Sagi> I used the arguments to (:) in the wrong order, that's what got me confused. Thanks ocharles, chrisdone :)
05:42:04 <chrisdone> donri: you can put your cursor over some text and run M-: (get-text-property (point) 'face) to get the name of the face
05:42:08 <jmcarthur_mobile> That is the case
05:42:28 <jmcarthur_mobile> Agda-mode uses its own colors
05:42:30 <chrisdone> donri: although if they're customization variables, you can run M-x customize-group agda
05:42:40 <donri> jmcarthur_mobile: but it has a setting to use your colorscheme
05:42:41 <jmcarthur_mobile> Yes
05:42:54 <donri> chrisdone: yes, that's how i'm setting it
05:43:15 <donri> chrisdone: but i think the thing is that agda is saying "this is an X, this is an Y" and then solarized is saying "use blue for any X and any Y"
05:43:39 <donri> because solarized only has 16 colors to work with
05:43:48 <chrisdone> donri: yeah, so if you get the name of the face, you can customize it specially in solarize
05:44:22 <donri> and to make colorschemes work across "modes" you need to standardize on some semantics
05:44:35 <AshyIsMe> someone asked me for some python help, so i tried to help: http://pastebin.com/ykuPe3LF
05:44:37 <jmcarthur_mobile> Yeah I just set it up manually. It doesn't pick scheme colors well
05:44:42 <mauke> The paste ykuPe3LF has been copied to http://lpaste.net/95059
05:45:15 <AshyIsMe> ooh lpaste looks nice
05:46:08 <merijn_> AshyIsMe: It *is* nice :) I like the minimal look and lack of adds :)
05:46:15 <chrisdone> donri: yeah, there are standard things
05:46:24 <merijn_> Also, for haskell it has hlint to provide suggestions
05:46:48 <chrisdone> donri: for example, font-lock-string-face is something that all modes with syntax highlighting use
05:47:26 <chrisdone> donri: then, a new mode like agda-mode will define a face like agda-hole-face (or w/e) which will be defiend to something standard or customized if there's nothing standard that's appropriate
05:48:08 <donri> i see
05:48:13 <donri> vim calls these highlighting groups
05:48:37 <chrisdone> sublime calls them potatoes
05:49:30 <sopvop> is there a good xmpp library on hackage?
05:50:03 <donri> which can be linked, and then in solarized for example Function links to Identifier so they get the same color. thus, less detail
05:50:05 <chrisdone> donri: do you want to fix the issue or were just complaining aimlessly? 'cause it can be fixed, but if you don't care, doesn't matter
05:50:24 <donri> oh just chattin'
05:53:04 <AshyIsMe> merijn_: nice
05:55:18 <donri> sopvop: pontarius-xmpp maybe? haven't used any of them
05:55:54 <DeusExMachina> HHi
05:56:07 <sopvop> this one seems promising, actively developed at least. http://hackage.haskell.org/package/network-protocol-xmpp
05:56:27 <sopvop> donri: thanks, I'll check it out
05:56:45 <DeusExMachina> is it possible to write own Data Types which are limited to a few numeric values?
05:57:30 <sopvop> DeusExMachina: like data Numbers = Three | N42 | N9000
05:59:07 <jophish> Haskell has ruined C++ for me
05:59:16 <jophish> I'm going to have to find a new job
05:59:29 <DeusExMachina> ok
05:59:39 <merijn_> jophish: There were a few guys in London hiring haskellers :p
05:59:49 <jophish> I'm in london!
05:59:56 <merijn_> jophish: And if you don't mind moving I believe Standard Chartered is permanently hiring in Singapore :p
06:00:00 <AshyIsMe> haha
06:00:45 <hamid_> merijn_, no one's hiring remote haskellers? :P
06:01:11 <merijn_> hamid_: There was a company in Portland hiring remote haskellers, but they never got back to me :p Their loss :p
06:01:45 <hamid_> gush i'm building gcc only with c&c++. it's almost 2 hours now. i'm getting tired.
06:02:21 <jophish> hamid_: considered clang?
06:02:22 <sopvop> have you forgot -j switch to make?
06:02:24 * ski . o O ( D&D++ )
06:02:41 <hamid_> sopvop, yep :|
06:02:47 <mangaba_leitosa> merijn_: is anyone hiring Haskellers in Southern Western Europe such as Italy/Spain/France/Greece? London is to misty
06:02:59 <mangaba_leitosa> too misty
06:04:11 <hamid_> jophish, yes :) it's just that i wanted to have gcc.
06:04:57 <jophish> I wonder what makes gcc so slow to build
06:05:03 <gtkkkk> mangaba_leitosa:You wanna work there?
06:05:25 <HugoDaniel> jophish: yeah, haskell has been deprecating favourite programming languages for some years now
06:05:30 <HugoDaniel> its the main purpose of the language
06:05:38 <mangaba_leitosa> gtkkkk: Yes, why not. (But I first need to complete learning Haskell) :-)
06:05:53 <HugoDaniel> ahah mangaba_leitosa nice nick :D
06:06:00 <mangaba_leitosa> HugoDaniel: thanks :-)
06:06:11 <donri> aww, DeusExMachine quit, i was gonna suggest something like data N :: [Nat] -> * where N :: (Elem n ns) => SNat n -> N [ns]
06:06:28 <donri> because dependent typing in haskell is so beginner friendly
06:06:29 <mangaba_leitosa> HugoDaniel: are you from Portugal? Aren't you hiring Haskellers?
06:06:35 <HugoDaniel> :)
06:06:35 <gtkkkk> well, I'm from Greece and programmer jobs are almost non existent
06:06:46 <HugoDaniel> im from .pt, i have actually been dismissed by the .pt gov.
06:06:48 <mangaba_leitosa> gtkkkk: that's what I supposed :-(
06:06:59 <mangaba_leitosa> HugoDaniel: :-(
06:07:03 <HugoDaniel> i should start looking for a job
06:07:10 <merijn_> mangaba_leitosa: You might want to make a profile on haskellers.com, I've so far gotten about 3 semi-serious offers that way
06:07:21 <donri> hm that won't work though :(
06:07:21 <hamid_> finally it's finished :)
06:07:27 <mangaba_leitosa> merijn_: thanks for the idea. 3 offers in which period?
06:07:29 <HugoDaniel> yeah, but the .pt gov can even fire right, they said "we are going to dismiss all contracted personnel, but only in 2014"
06:07:35 <gtkkkk> merijn: did you actually get a job?
06:07:48 <merijn_> mangaba_leitosa: About a year to a year and a half?
06:07:54 <donri> -> N ns, might
06:07:56 <HugoDaniel> so if anyone knows of any job, i will code for food :D
06:08:04 <mangaba_leitosa> merijn_: I see... Not really wide choice it seems
06:08:10 <Toeofdoom> Huh... I was apparently the 5000th person to complete a project euler problem
06:08:23 <Toeofdoom> I assumed it was an approximation, but no...
06:08:49 <mangaba_leitosa> gtkkkk: I'm now learning Greek in parellel with Scala/Haskell :-)
06:08:53 <merijn_> mangaba_leitosa: Actually, the more I talk to people at conferences the more I realise tons of people are doing haskell, but everyone is being very hush-hush about it :)
06:08:57 <gtkkkk> Lol
06:09:19 <gtkkkk> mangaba_leitosa : modern Greek?
06:09:29 <HugoDaniel> mangaba_leitosa: what country are you from ?
06:09:40 <merijn_> gtkkkk: In the end we both decided I wasn't a good fit for what they were looking for, so no.
06:09:40 <mangaba_leitosa> gtkkkk: yes. very interesting. I discover new meanings of words I already knew every day :-)
06:09:50 <mangaba_leitosa> HugoDaniel: Russia :-)
06:09:52 <geekosaur> sometimes I think haskell will be the next smalltalk: vanishing into industry proprietary codebases, never to be seen again :/
06:09:59 <HugoDaniel> i already know some math, its somewhat equivalent to greek
06:10:05 <gtkkkk> merijn_, :damn
06:10:06 <HugoDaniel> epsilon, lambda, omega
06:10:06 <mangaba_leitosa> HugoDaniel: :-))
06:10:14 <merijn_> geekosaur: Naah, I think the open source following of haskell has become to big for that to happen, I think
06:10:26 <HugoDaniel> mangaba_leitosa: so why southern europe ?
06:10:40 <mangaba_leitosa> HugoDaniel: I don't like the climate of Russia
06:10:45 <merijn_> mangaba_leitosa: Well, singapore could be sunny, right? :p
06:11:09 <mangaba_leitosa> HugoDaniel: btw, I spent one year in Lisbon studying Portuguese at ul.pt :-)
06:11:11 <HugoDaniel> things are not so good now that we (southern europeans) are the european proletariat
06:11:26 <nooodl> :t (\a -> a a)
06:11:26 <gtkkkk> haha its our fault though
06:11:28 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
06:11:28 <lambdabot>     In the first argument of `a', namely `a'
06:11:28 <lambdabot>     In the expression: a a
06:11:28 <HugoDaniel> ahh, amzing, im working in unl.pt, its the competitor
06:11:50 <mangaba_leitosa> merijn_: yes... But I heard that you have to pay for anything there, because whatever you do is forbidden and you get fined
06:11:54 <nooodl> hmm. i can sorta see why this is impossible but then again it makes perfect sense for some functions
06:11:58 <mangaba_leitosa> merijn_: "for everything"
06:12:10 <Toeofdoom> Hey so the general idea for fast dynamic programming in haskell is to use infinite lists right?
06:12:17 <mauke> Toeofdoom: no
06:12:17 <nooodl> like (\a -> a a) id 3 = (id id) 3 = 3
06:12:39 <mauke> :t undefined :: forall a. a
06:12:39 <mangaba_leitosa> HugoDaniel: interesting :-) Are you teaching CS?
06:12:40 <lambdabot> a
06:12:58 <mauke> :t (\a -> a a) :: forall a. (a -> a) -> (a -> a)
06:12:59 <lambdabot>     Couldn't match expected type `a' with actual type `a -> a'
06:12:59 <lambdabot>       `a' is a rigid type variable bound by
06:13:00 <lambdabot>           an expression type signature: (a -> a) -> a -> a
06:13:22 <HugoDaniel> mangaba_leitosa: no, im working in the development department of the univ., coding boring stuff, but at least i get to do things in haskell :)
06:13:30 <mauke> :t (\a -> a a) :: (forall a. a -> a) -> (forall a. a -> a)
06:13:31 <nooodl> or (\a -> a a) const 3 4 5 = 4
06:13:32 <lambdabot> (forall a1. a1 -> a1) -> a -> a
06:13:34 <mangaba_leitosa> HugoDaniel: :-)
06:13:50 <nooodl> > ((\a -> a a) :: (forall a. a -> a) -> (forall a. a -> a)) id 3
06:13:51 <lambdabot>   3
06:13:53 <nooodl> cool
06:14:04 * hackagebot concraft 0.8.2 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.8.2 (JakubWaszczuk)
06:14:06 * hackagebot concraft-pl 0.4.1 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.4.1 (JakubWaszczuk)
06:14:47 <nooodl> :t (\a -> a a) :: (forall a b. a -> b) -> (forall a b. a -> b)
06:14:48 <lambdabot> (forall a1 b1. a1 -> b1) -> a -> b
06:15:45 <mangaba_leitosa> HugoDaniel: I read that some Portugueses are moving to Angola/Brazil to find better jobs
06:16:02 <AshyIsMe> wow, the vim paragraph text-object works really well with haskell code
06:16:02 <Toeofdoom> mauke: In this case I mean things with similar characteristics to the fibonacci sequence... referring to earlier points in the list etc.
06:19:00 <mangaba_leitosa> merijn_: and what about searching for jobs where you are expected to solve specific task rather than coding in language X?
06:19:25 <HugoDaniel> mangaba_leitosa: yeah, people are fleeing everywhere they can go to... mostly brazil/angola and specially mozambique
06:19:54 <merijn_> mangaba_leitosa: Sure, but those are rare :)
06:20:01 <merijn_> mangaba_leitosa: Unless you freelance/contract
06:20:02 <HugoDaniel> for each friend i have working in brazil or in angola i know some other 3 that went to mz
06:20:38 <mangaba_leitosa> HugoDaniel: why Mozambique is so popular?
06:20:57 <merijn_> mangaba_leitosa: Example of companies you've never heard about using Haskell, I remember someone telling me their company had a 100k+ line ActionScript3 to Flash compiler written in haskell which they apparently made quite a bit of money selling to companies with legacy actionscript code :p
06:21:48 <merijn_> mangaba_leitosa: Essentially, most of the "popular" companies that are writing about their techstuff tend to be these faddish web2.0 startups, meanwhile the people who don't write blogposts are to busy being profitable
06:22:39 <HugoDaniel> mangaba_leitosa: because they are very poor and have lots of money due to their relations with south africa india and china, they also lack know-how in even the most basic stuff, so its sort of an el dorado land of the oportunity for anyone that speaks portuguese
06:22:46 <mangaba_leitosa> merijn_: in Russia, I read about an experience of a hosting company rewriting their functionality from python to haskell. Probably they don't promote haskell everywhere as well :_)
06:23:13 <merijn_> mangaba_leitosa: At IFL I was talking to one of the Intel researchers that worked on their optimising Haskell compiler and during the conversation we found out he didn't even know there were one or two other groups in Intel working on haskell :p
06:23:38 <mangaba_leitosa> merijn_: lol
06:23:46 <merijn_> mangaba_leitosa: And of course facebook is now starting to ramp up their haskell development
06:24:05 * hackagebot concraft-pl 0.4.2 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.4.2 (JakubWaszczuk)
06:24:13 <zomg> brb making sure Haskell is well visible on my CVs around the interwebs
06:24:14 <zomg> :P
06:24:17 <mangaba_leitosa> merijn_: facebook has something in haskell already?
06:24:42 <HugoDaniel> they have some haskell heads working there
06:24:55 <merijn_> mangaba_leitosa: They have bos and Simon Marlow, afaik Marlow has published two haskell libraries since starting there
06:25:19 <merijn_> So presumably both of them are doing non-zero amounts of haskell
06:25:27 <mangaba_leitosa> merijn_: cool
06:25:47 <merijn_> zomg: You joke, but it does really well on CVs if you can actually back it up with writing haskell :)
06:26:19 <bxc> mangaba_leitosa: there was a nic etalk on haskell exchange about what they're doing
06:26:34 <zomg> merijn: Ya I mention it on my SO Careers profile in like the first sentence, and it shows up in my skill list in LinkedIn =)
06:27:24 <zomg> even have a haskell repo on github, so oughta be good!
06:28:06 <HugoDaniel> facebook is ev1l empire though :/
06:29:06 * hackagebot blaze 0.0.1 - Blaze-html-based HTML5 library  http://hackage.haskell.org/package/blaze-0.0.1 (ChrisDone)
06:29:08 * hackagebot sgd 0.3.4 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.3.4 (JakubWaszczuk)
06:30:05 <merijn> HugoDaniel: So are most interesting companies, that's what gives them the power to be interesting :)
06:33:39 <zomg> Yeah I'm currently working with a company which does sorts of online advertising, which is certainly considered annoying by many but perhaps not downright evil
06:33:53 <zomg> But it is certainly interesting as we're working with some rather cutting edge stuff
06:34:03 <chrisdone> merijn: http://i77.photobucket.com/albums/j60/bluinkalchemist/emperor-palpatine.jpg
06:34:50 <yesthisisuser> Is anyone here using haskellmode for Vim? I don't get the :make command..
06:35:28 <yogurt_truck> zomg: have you gotten any interesting offers through SO's careers thing?
06:35:46 <merijn> yesthisisuser: I tried it for a bit, but found the amount of junk and clutter to high, so I went back to almost plain vim with just hdevtools
06:36:06 <zomg> yogurt_truck: I have gotten some offers but nothing particularly interesting
06:36:07 <merijn> chrisdone: Doesn't even load for me :p
06:36:30 <merijn> Probably because I have cookies disabled
06:36:31 <zomg> yogurt_truck: I get some 10-30 views on my profile every month though
06:37:08 <yesthisisuser> merijn: ok, thanks. It looks like it's easier to just build from a separate terminal
06:37:27 <merijn> yogurt_truck: In the end you won't get a good job by passively waiting around (how attractive it sounds), but it's a good starting point for networking and when people google you
06:38:01 <merijn> yesthisisuser: Or, if you work in the same directory, just use :! to run your make command like cabal build
06:38:02 <zomg> Yeah I think it's nice to have, you never know
06:38:15 <chrisdone> merijn: ah, good call. i got a cookie once, couldn't walk for weeks
06:38:26 <zomg> Plus at least in my opinion an SO Careers profile is pretty easy to keep up to date and can be linked to people if you just want to have an online CV
06:38:47 <zomg> Now whether my resume there is any good, I wouldn't know. =)
06:39:55 <yogurt_truck> zomg: merijn: agreed!
06:40:09 <yesthisisuser> merijn: yes, that works also.. it's too bad still -- haskellmode reports errors nicely...
06:40:19 <zomg> This is me: http://careers.stackoverflow.com/jhartikainen
06:41:02 <yesthisisuser> but after running :make.. the whole UI just freezes for a while..
06:41:21 <yogurt_truck> zomg: you're in the top 30% for arrays! :D
06:41:28 <yesthisisuser> i guess i should learn Emacs then :/
06:41:38 <sie> yesthisisuser, No, you should be making from the terminal.
06:41:47 <sie> Do you use tmux?
06:42:10 <zomg> yogurt_truck: whoa!
06:42:34 <yesthisisuser> sie: it works when compiling using :!ghc --make etc
06:42:52 <sie> yesthisisuser, Why do you want to use :make?
06:42:58 <sie> or !ghc
06:43:13 <yesthisisuser> sie: well, mainly because the error reporting was kind-of convenient
06:43:27 <sie> The cursor-to error?
06:43:38 <yesthisisuser> yes and the "quickfix" list
06:43:54 <sie> Do you use tmux?
06:43:59 <merijn> yesthisisuser: syntastic works well for that
06:44:05 <yesthisisuser> ah. ok
06:44:06 <merijn> yesthisisuser: Together with hdevtools
06:44:16 <yesthisisuser> ok. i'll look into that
06:44:21 <yesthisisuser> thanks guys
06:44:21 <merijn> yesthisisuser: Does syntax error highlighting and quickfix list
06:44:56 <shergill> yesthisisuser: you can still move on to emacs *evil grin* :P
06:45:41 <yesthisisuser> shergill: yes, I was looking at this tutorial: http://edward.oconnor.cx/2009/07/learn-emacs-in-ten-years  :)
06:48:41 <kau> hi everybody!
06:49:24 <yesthisisuser> hi there
06:50:19 <kau> I have an error when compiling: ghc: <foo>: unknown symbol <bar>
06:50:33 <kau> It's a linking error right?
06:50:40 <kau> what can cause that?
06:51:51 <kau> The symbol cited by GHC is in the library .a file, I checked with nm
06:52:00 <mauke> what's the error message?
06:52:11 <kau> ghc: dist/build/Nomyx/Nomyx-tmp/Types.o: unknown symbol `NomyxzmLanguagezm0zi4zi0_LanguageziNomyxziEngineziGame_zdfReadSubmitRule_closure'
06:52:23 <kau> when doing cabal install
06:52:51 <mauke> weird
06:53:01 <mauke> does it go away if you clean and do a full rebuild?
06:53:06 <kau> no
06:53:26 <kau> cabal clean; cabal install is enough?
06:55:12 <kau> the symbol in question comes from a library I just refactored
06:55:28 <kau> so there might be some cache somewhere...
06:57:50 <kau> where do cabal puts the libraries that you compile?
06:59:10 <geekosaur> if you're not using a sandbox, the library itself is probably under ~/.cabal and the package info under ~/.ghc. but this depends on cabal-install version and on platform (Macs default to Library/Haskell/...) and it's different again for sandboxes via either cabal-dev or cabal 1.18
06:59:20 <identity> kau: ~/.cabal/lib without sandbox as far as I can see
07:02:08 <lpaste> moops pasted “messing around with functions” at http://lpaste.net/95060
07:02:16 <moops> i dont understand this error
07:03:40 <fizruk> moops, put parens around (Left l) and (Right r)
07:03:57 <moops> aha, thanks!
07:04:14 <fizruk> moops, printEither Left l parses as definition of a function with two parameters: Left and l
07:05:27 <fizruk> moops, since Left is a constructor, ghc assumes you're doing pattern matching, but forgot an argument
07:05:31 <kau> mauke, geekosaur and identity: I deleted the entries in ~/.cabal/lib, it compiles now :)
07:05:45 <kau> strange that the cabal cleans didn't do
07:06:03 <moops> makes sense, i was writing (x:xs) above cause the book did it without realizing why :P
07:06:15 <moops> and now i see
07:07:18 <sie> If I have [(a -> b)] and a, how could I get [b]?
07:07:39 <Cale> map ($x) fs
07:07:58 <sie> Cool.
07:08:00 <Cale> :t (\fs x -> map ($ x) fs)
07:08:01 <lambdabot> [a -> b] -> a -> [b]
07:08:19 <Cale> Note also that this is 'sequence' for the function monad
07:08:26 <Cale> :t sequence
07:08:28 <lambdabot> Monad m => [m a] -> m [a]
07:08:38 <Cale> :t sequence :: [e -> a] -> e -> [a]
07:08:39 <lambdabot> [e -> a] -> e -> [a]
07:09:05 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
07:09:07 <lambdabot>   [5,7,10,25,32]
07:09:11 * hackagebot concraft 0.8.3 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.8.3 (JakubWaszczuk)
07:09:34 <sie> A question about "$ x", that might be expressed as (flip ($)) x, correct?
07:10:17 <merijn> sie: Yes, or "($x)"
07:10:29 <merijn> Yay, operator sections!
07:10:54 <sie> Sweet, so I can flip regular fns with (`fun` arg) sugar as well?
07:11:03 <merijn> sie: Yes
07:11:07 <sie> Really badass.
07:11:25 <fizruk> > map (`div` 2) [1..10]
07:11:28 <lambdabot>   [0,1,1,2,2,3,3,4,4,5]
07:11:56 <t7> > map (`div` 0) [1..]
07:11:58 <lambdabot>   [*Exception: divide by zero
07:14:11 * hackagebot concraft-pl 0.4.3 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.4.3 (JakubWaszczuk)
07:14:53 <skypers_> @hoogle (.|.)
07:14:54 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
07:21:59 <moops> is there a tool for noob-friendlier error messages or should i just suck it up?
07:22:37 <dmwit> Suck it up!
07:22:56 <moops> at least its not as bad as ocaml
07:22:57 <dmwit> More seriously: some people say Hugs has better error messages, and there's the Liquid Haskell project (I think).
07:23:08 <haasn> I don't see what's wrong with the error messages, personally
07:23:13 <haasn> the most important thing to do is actually read them
07:23:20 <moops> but i hate reading!
07:23:27 <dmwit> Yes, I'm with haasn.
07:23:36 <haasn> They're big and scary, true
07:23:47 <dmwit> I've only had a handful of really unreadable error messages, and they always turned out to be bugs in GHC. =P
07:23:58 <dmwit> s/unreadable/unhelpful/ I mean
07:24:12 <haasn> I've had some very unreadable error messages when working with hand-rolled type level strings :)
07:24:16 <haasn> But not unhelpful1
07:24:23 <haasn> I just needed some time to parse them
07:24:31 <dmwit> Yeah, unreadable and unhelpful are very different qualities. =)
07:24:35 <zomg> The problem with error messages is probably that most haskell tutorials don't actually explain them so they're pretty scary for beginners =)
07:24:42 <haasn> (‘unreadable’ here meaning ‘spanning multiple pages’)
07:25:05 <zomg> once you actually know what the error means and how to debug it then they're not so bad unless there's some utterly crazy type magic being done
07:25:17 <haasn> The most confusing error messages, especially ones newcomers are often very exposed to, are due to the DMR, imo
07:25:40 <haasn> Because if you don't know about the DMR, it doesn't make any sense
07:25:47 <moops> whats DMR?
07:25:53 <haasn> “Huh? why is this suddenly ()? There's no mention of () anywhere!”
07:26:07 <haasn> moops: http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:26:14 <haasn> (the D stands for Dreaded)
07:26:26 <moops> haha
07:26:32 <ski> @where DMR
07:26:32 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:26:55 <mangaba_leitosa> haasn: and why is it suddently ()? Why not '?' ?
07:27:09 <mangaba_leitosa> suddenly
07:27:15 <dmwit> mangaba_leitosa: Well, read the wiki page. =)
07:27:37 <haasn> mangaba_leitosa: GHC defaults types to () if it has no better defaulting rule
07:27:52 <dmwit> (only ghci defaults to () in such cases)
07:28:09 <dmwit> (but GHC does default things to Integer or Double even when they could be polymorphic)
07:28:22 <haasn> Oh, right, GHC just throws an error doesn't it
07:30:11 <Twey> dmwit: Do people still say Hugs has better error messages?  I thought that was a thing of the past
07:30:55 <dmwit> Hey, my first-choice advice was "suck it up"...
07:34:12 <shergill> in the context of pl and type systems, what does confluence mean?
07:36:19 <Saizan> shergill: it's about the fact that even if you can reduce the same expression in different ways you'll end up with the same result if you keep at it
07:36:29 <Saizan> shergill: there are a few variations though http://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)
07:36:33 <Twey> Heh
07:37:01 <Twey> Term rewriting with GUTS
07:37:55 <shergill> Saizan: gotcha. term rewriting. that's the context i was missing
07:37:58 <shergill> thanks
07:44:15 * hackagebot blank-canvas 0.2.3.2 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.2.3.2 (AndrewFarmer)
07:45:17 <NickHu> Hey guys, why is this incorrect? (myPixmap, mask) <- pixbufRenderPixmapAndMaskForColormap myPixbuf http://hackage.haskell.org/package/gtk-0.12.4/docs/Graphics-UI-Gtk-Gdk-Pixbuf.html#t:Pixbuf
07:46:34 <dmwit> NickHu: The docs for pixbufRenderPiblahblahblah says it takes three arguments, but you've given only one.
07:48:15 <NickHu> dmwit: Ah, of course, thanks
07:59:26 <quchen> Taneb: Re Alternative laws: wasn't there some issue with "m >> mzero = mzero", namely that some MonadsPlus don't obey it.
07:59:31 <quchen> s/./?
08:00:00 <quchen> I'm all in favour with `empty <*> _ = empty`, but not so sure about the flipped version
08:00:10 <dmwit> http://www.haskell.org/haskellwiki/MonadPlus
08:00:10 <Taneb> quchen, well, MonadPlus does document it
08:00:18 <Taneb> So it's the instances that are at fault there
08:00:41 <quchen> Taneb: Sure. But maybe it was not a good idea to add this law in the first place, that's what I meant.
08:00:56 <quchen> Taneb: In that sense, maybe we should consider this when adding the corresponding law to Alternative.
08:01:04 <geekosaur> for a short time IO was a MonadPlus, I thinkt hat violation got it removed again
08:01:27 <geekosaur> (back around ghc 6.6/6.8?)
08:01:32 <quchen> geekosaur: Some GHC modules still define that instance though
08:01:39 <quchen> geekosaur: But it's probably not official anymore
08:01:49 <erisco> take this function for example:   foo f g n = if g n then foo f g (f n) else f n    due to referential transparency, we can evaluate in any order desired. if we choose to repeatedly evaluate the 'then' block, then we'll evaluate infinitely, which is not useful.
08:02:15 <erisco> therefore, even though we can evaluate in any order, clearly there is some constraints on a desired order so the computation completes
08:02:24 <dmwit> Correct.
08:02:47 <dmwit> The nice fact about lazy evaluation is that if any order completes, the lazy order completes.
08:02:53 <Taneb> quchen, so, which MonadPluses break that law?
08:02:59 <erisco> is this order decided entirely by the lazy evaluation semantic that values are only computed if demanded?
08:03:24 <dmwit> That's one choice, but definitely not the only choice you can make.
08:03:26 <erisco> dmwit, hm, okay :)
08:03:35 <quchen> Taneb: Not sure anymore, that's why I was ask-mentioning it here. Shachaf had some examples, I think one of them was State+Maybe or Maybe+State.
08:03:45 <erisco> dmwit, what other choices are there?
08:03:49 <Eduard_Munteanu> erisco: yes, though you could do speculative evaluation as well
08:04:03 <Eduard_Munteanu> As long as you preserve non-strict semantics.
08:04:19 <dmwit> erisco: Well, GHC does strictness analysis: if it can prove statically that something will always be demanded, that thing needn't be evaluated lazily.
08:04:39 <erisco> dmwit, I see, so the generated code will act eagerly
08:04:43 <dmwit> erisco: And, as Eduard_Munteanu is suggesting, you can run both branches in parallel and then see which one you need.
08:04:47 <dmwit> Or something like that. =)
08:04:57 <erisco> clever idea too
08:05:08 <quchen> > Just 1 `mplus` Nothing -- /= Nothing   ---  Taneb
08:05:10 <lambdabot>   Just 1
08:05:11 <erisco> do processors so this at some level?
08:05:19 <dmwit> processors no
08:05:22 <dmwit> compilers yes
08:05:46 <dmwit> I think somebody was mentioning that they were trying to write a compiler that did some speculative evaluation.
08:05:50 <Taneb> quchen, that wasn't the rule
08:05:54 <Taneb> > Just 1 >> Nothing
08:05:54 <erisco> I suppose I can thinking of branch prediction
08:05:55 <lambdabot>   Nothing
08:05:58 <quchen> Taneb: Oh right.
08:06:00 <quchen> Woops
08:06:21 <erisco> for some reason my verbs are not coming out correctly
08:08:41 <erisco> dmwit, Eduard_Munteanu the advantage to the speculative approach seems to be when there is an expensive computation to decide the branch. how is a compiler to decide this?
08:10:27 <dmwit> That is what is called a Hard Problem.
08:10:43 <dmwit> A good answer is probably worth a Ph.D.
08:11:10 <geekosaur> pretty sure there's already several Ph.D.s and more in the works...
08:11:14 <erisco> I think PhDs have been had for less
08:11:23 <geekosaur> on that problem
08:11:33 <dmwit> That wouldn't surprise me at all.
08:12:22 <geekosaur> I recall a *lot* of work being done in that area back in the RISC days, too
08:12:34 <supki_> Taneb: EitherT breaks it,  left "foo" >> mzero = left "foo"
08:12:56 <Taneb> supki_, then EitherT is wrong :)
08:13:44 <triliyn> What should it be? left () ?
08:14:14 <TallerGhostWalt> When I see people doing bit shifting, I see a lot of functions that look like this: shiftr_w16
08:14:21 <TallerGhostWalt> But I can't find those declared
08:14:29 <TallerGhostWalt> anyone know what lib they are in?
08:14:40 <geekosaur> how/where are you seeing these?
08:14:50 <TallerGhostWalt> Data.Binary.Get
08:15:03 <TallerGhostWalt> definition for getWordxxbe or getWordxxle
08:15:13 <Taneb> triliyn, maybe there shouldn't be an instance, maybe the Monad instance is wrong
08:15:38 <quchen> Taneb: Hm, I can't find it anymore. For now I guess I'll have to go with "IO and STM" as examples then.
08:15:53 <TallerGhostWalt> oh...
08:16:04 <TallerGhostWalt> well maybe I found em
08:16:08 <Taneb> quchen, IO shouldn't be an Alternative
08:16:14 <Taneb> and I think STM obeys these laws
08:16:22 <TallerGhostWalt> looks like macros for uncheckedShiftL#
08:16:32 <quchen> Taneb: Why shouldn't IO be?
08:16:42 <jophish_> Hey hey
08:16:46 <k00mi> triliyn: it requires a Monoid constraint on e, so "left mempty"
08:16:49 <Eduard_Munteanu> What's a nice way to augment the state of a 'State s a'? e.g. State s a -> State t a -> State (s, t) a
08:17:35 <Eduard_Munteanu> Perhaps there's an arrow instance of State?
08:17:48 <Eduard_Munteanu> (*not* Kleisli (State s))
08:17:51 <Taneb> quchen, I'm afraid my main argument for that is that it doesn't obey the laws I'm pitching
08:18:14 <quchen> That's a little circular :-P
08:18:39 <dmwit> Eduard_Munteanu: lens has stuff for that, I'm pretty sure
08:18:50 <dmwit> Eduard_Munteanu: State s a -> State (s, t) a, at least
08:19:02 <dmwit> then (>>) of course
08:19:08 <Eduard_Munteanu> Hm, thanks, I'll look it up.
08:28:16 <jophish_> donri: about?
08:29:13 <jophish_> Or anyone else. I'm looking for a nice way to get vim to complete symbols in the current module. neco-ghc works really nicely for symbols in imported modules, but comes up blank for symbols in the current module
08:29:59 <dmwit> jophish_: ^X^N ?
08:30:21 <jophish_> dmwit: Ideally with some context awareness, or type info
08:30:38 <dmwit> That's harder. There was something on reddit about this a week or two ago, though.
08:30:41 <moops> why does haskell's Monoid have the "concat" function?
08:31:24 <moops> isnt that not part of what a Monoid usually is
08:32:04 <dmwit> moops: No harm in it.
08:32:13 <dmwit> moops: All monoids support it.
08:32:25 <dmwit> moops: And some monoids prefer to support it from the right, some from the left. So.
08:32:33 <moops> dmwit: every possible monoid?
08:32:41 <dmwit> some prefer to support it with a tree fold =P
08:32:46 <dmwit> moops: Yes. See if you can prove it. =)
08:32:49 <mauke> @src mconcat
08:32:50 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:32:51 <moops> hehe okay
08:32:53 <mauke> :-(
08:33:28 <mauke> :t mconcat
08:33:29 <lambdabot> Monoid a => [a] -> a
08:33:33 <mauke> well, that's trivial
08:34:11 <mm_freak> Monoid would benefit from 'times' a lot more than it does from 'mconcat'
08:34:28 <dmwit> What is "times"?
08:34:30 <mm_freak> times :: (Integral a, Monoid b) => a -> b -> b
08:34:55 <mm_freak> 3000 `times` x = mconcat (replicate 3000 x)
08:35:01 <dmwit> Would it really?
08:35:07 <mm_freak> yes
08:35:15 <mauke> I've never needed that
08:35:49 <odites> fryguybob: Are you working on ghc tsx's support?
08:35:54 <mm_freak> you can use the usual square-and-multiply, but some monoids (for example elliptic curves) support a much faster 'times' function
08:36:36 <moops> could just use noncommutative ring if you wanted times?
08:36:46 <moops> probably expresses intent better
08:36:50 <fryguybob> odites: Yes
08:36:51 <mm_freak> moops: no
08:36:58 <moops> no?
08:37:01 <dmwit> no
08:37:07 <moops> oh
08:37:08 <moops> inverses :P
08:37:10 <mm_freak> moops: the "times" function for rings has a different meaning
08:37:25 <moops> my algebra is rusty
08:37:32 <dmwit> This "times" function takes arguments of two different types.
08:37:42 <moops> ohh right
08:39:03 <fryguybob> odites: I suppose it would be more correct to say that I'm working on GHC to make it use TSX where it can.  Not necessarally to enable end users to use TSX directly.
08:40:52 <moops> ahh i get mconcat now, but wouldnt it be nicer if it took any foldable instead of just list?
08:41:09 <mm_freak> moops: see Data.Foldable
08:41:13 <mm_freak> :t F.fold
08:41:14 <lambdabot> (Foldable t, Monoid m) => t m -> m
08:41:28 <moops> ah okay, so its just in a different place
08:41:38 <mm_freak> and with a slightly odd name =)
08:43:15 <odites> fryguybob: I'm glad to know that :) For which release do you think that is possible to have this feature?
08:44:44 <fryguybob> odites: Well, this is still a research problem.  If all goes well perhaps some day it will show up in a GHC release.
08:44:46 <jophish_> dmwit: I can't seem to find the reddit thread
08:44:51 <jophish_> is it in /r/haskell?
08:46:52 <odites> Thank you very much for your time ;)
08:47:14 <fryguybob> odites: No problem!
08:54:51 <moops> ive got 3 source files now, whats the preferred build system for haskell? hopefully not make? ;)
08:55:16 <albertid> moops, cabal
08:56:55 <moops> are there any examples for small projects? all im finding are instructions for distributing packages
08:57:09 <Luke> the next haskell platform says it's slated for nov 4. how often are those dates met?
08:58:15 <dv-> moops: do cabal init, then edit the .cabal file
08:59:17 <Luke> carter: have you tried mzero's os x llvm ghc fix?
09:00:17 <mm_freak> is the benchpress library as accurate as criterion?  it has exactly the API i need for my purpose
09:01:39 <Luke> does normal form mean fully evaluated?
09:02:27 <runde> Parsec question: I'm trying to parse an assembly file (inspired by a CSV parser on Real World Haskell) with http://lpaste.net/2491093740488228864 -- however, it does not produce an error when the opcode is bogus. Why?
09:04:25 * hackagebot ZipperAG 0.1 - An implementationg of Attribute Grammars using Funcitonal Zippers  http://hackage.haskell.org/package/ZipperAG-0.1 (prmartins)
09:04:46 <merijn> Does haskell have syntax for binary literals?
09:06:09 <mm_freak> Luke: pretty much
09:06:11 <mm_freak> merijn: no
09:06:51 <monoidal> merijn: no. closest thing is octal and hexadecimal
09:09:17 <monoidal> runde: does "asmFile = instr `sepBy` eol <* eof" help?
09:09:48 <fryguybob> @hackage binary-literal-qq -- merijn
09:09:48 <lambdabot> http://hackage.haskell.org/package/binary-literal-qq -- merijn
09:10:59 <merijn> meh
09:11:07 <runde> What is '<*'? Not in scope
09:11:08 <merijn> I already used python :p
09:11:15 <merijn> runde: From Control.Applicative
09:11:19 <merijn> :t (<*)
09:11:20 <lambdabot> Applicative f => f a -> f b -> f a
09:11:36 <merijn> runde: Runs the effects of both arguments and returns the result of the first
09:11:49 <maxiepoo> :t (*>)
09:11:50 <lambdabot> Applicative f => f a -> f b -> f b
09:11:54 <monoidal> runde: import Control.Applicative ((<*)) to prevent ambiguity
09:11:56 <merijn> runde: "x <* y" == "run x, then y and return the result of x"
09:12:59 <moops> dv-: got it working, thanks!
09:14:21 <merijn> Luke: The impending release of Xcode 5 and new OSX have postponed the platform release
09:14:38 <Luke> until when?
09:14:46 <Luke> has xcode 5 not been released yet?
09:14:49 <merijn> Luke: GHC 7.8 isn't quite ready yet, but 7.6 currently has trouble with Xcode 5's lack of gcc
09:15:09 <bergmark> xcode5 is out
09:15:10 <ion> Aww, i hoped that would mean Erlang-like binaries.
09:15:29 <Luke> "impending release of Xcode 5" made it sound like it wasn't out yet
09:15:31 <merijn> Luke: So the current discussion is whether to quickfix 7.6 and release another 7.6 platform, wait for 7.8 to be more stable and release that
09:15:39 <merijn> Luke: Oh, I wasn't aware it was out already :p
09:15:55 <merijn> I only update xcode when I reinstall/update OSX >.>
09:17:27 <runde> merijn: Thanks, but it didn't seem to help me out.. "unexpected end of input, expecting opcode"
09:18:30 <merijn> runde: That seems on odd error...
09:19:28 * hackagebot TCache 0.10.2.4 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.2.4 (AlbertoCorona)
09:20:50 <runde> merijn: Hm, "asmFile = instr `endBy` eol <* eof" seems to work better
09:22:17 <runde> It just has to be some way of making this cleaner...
09:23:21 <maxiepoo> @pl flip (\x -> runIdentity . ln (Identity . const x))
09:23:25 <lambdabot> flip ((runIdentity .) . ln . (Identity .) . const)
09:23:25 <lambdabot> optimization suspended, use @pl-resume to continue.
09:23:37 <maxiepoo> @pl-resume
09:23:43 <lambdabot> flip ((runIdentity .) . ln . (Identity .) . const)
09:23:43 <lambdabot> optimization suspended, use @pl-resume to continue.
09:26:30 <runde> "asmFile = instr `sepBy` eol `endBy` eof" looks clean, but also gives "unexpected end of input, expecting opcode" :P
09:26:34 <runde> bleh
09:26:42 <runde> How hard could this be? :-)
09:39:32 * hackagebot git-annex 4.20131101 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20131101 (JoeyHess)
09:42:30 <ocharles> What would you call a function that is :: Monoid m => a -> m (though with a concrete 'a')?
09:42:39 <ocharles> E.g., :: Int -> Sum Int
09:42:50 <ocharles> lift?
09:47:09 <fizruk> ocharles, for Int -> Sum Int I'd pick "wrap"
09:47:32 <fizruk> ocharles, do you have more examples?
09:48:34 <donri> if you're looking for a name from theory, i don't think it makes sense. newtype wrappers are a haskell peculiarity, i imagine
09:48:44 <ion> “Sum”
09:48:54 <donri> you'd say something like "monoid of integers under summation" or something
09:48:58 <plutoniumfire> Hey, could someone help me out with setting up haskell so i can start learning?
09:49:06 <ion> plutoniumfire: What OS?
09:49:12 <plutoniumfire> windows :/
09:49:17 <ion> plutoniumfire: Install the Haskell Platform.
09:49:21 <tdammers> isn't newtype more like a performance hack?
09:49:22 <plutoniumfire> done that
09:49:50 <ion> I wouldn’t call it a hack.
09:49:56 <plutoniumfire> specifically, im having trouble configuring my ghci using the ghci.conf file
09:50:11 <tdammers> yeah well, 'hack' is maybe a bit harsh
09:50:52 <ion> plutoniumfire: Are you sure that’s the correct name for the config file? (I’m not saying it’s not, i don’t know.)
09:51:02 <donri> "under addition", rather, i guess
09:51:07 <ion> plutoniumfire: Do you have it in the correct location?
09:51:21 <plutoniumfire> I believe it is
09:52:13 <ion> I suppose you’ll have to wait for someone with access to ghci on Windows® to reply. I’m ignorant about that.
09:53:11 <plutoniumfire> im going to try create my own ghci.conf and see if it works
09:54:07 <moops> is there a way to force cabal to typecheck/compile unused modules
09:54:38 <ocharles> fizruk: specifically working with things like Relationship -> Map RelationshipPhrase [Relationship]
09:54:51 <ocharles> But there are various target monoids around
09:54:58 <ocharles> Also, this is going to be Javascript, not Haskell ;)
09:54:59 <plutoniumfire> My macgyvered ghci.conf appears to be working! :D
09:56:31 <erisco> are there alternatives to seq?
09:56:34 <fizruk> moops, make them exposed (at least if it's a library) ?
09:56:50 <ion> erisco: For what purpose?
09:57:16 <ion> That’s like asking “are there alternatives to (+)”
09:57:37 <moops> fizruk: its an exe for now, just playing around with stuff.
09:58:15 <erisco> I understand it is not ideal theoretically and causes some laws and optimisations to break
09:58:22 <moops> fizruk: nvm, importing the module seems to do it, thats good enough
09:58:31 <moops> importing the module in main*
10:00:36 <fizruk> ocharles, Map k v is a monoid with mappend = unionWith mappend? and the function is something like singleton?
10:03:54 <fizruk> ocharles, if you have to name different functions, I'd use explicit names like singletonRelationship or something
10:04:27 <fizruk> ocharles, if you have a method in a typeclass, I'd call it wrap or wrapSomething
10:04:33 <chrizz> any ghcjs users out there right now? i'm getting a "No instance for FromJSRef Value", but https://github.com/ghcjs/ghcjs-base/blob/master/GHCJS/Marshal.hs#L89 says otherwise...
10:04:40 <fizruk> ocharles, hope that helps :)
10:04:55 <donri> lol real useful hlint: redundant $!  but changing it changes the strictness!
10:05:21 <chrizz> donri: hlint does warn about increased/decreased laziness though...
10:05:29 <donri> ?
10:06:18 <chrizz> http://community.haskell.org/~ndm/darcs/hlint/data/Default.hs
10:06:55 <chrizz> meaning, it has the capability to make that warning
10:07:00 <MattY> is sequence_ documentation very IO monad specific, despite taking any Monad, or is it proper to call any Monad action?    "Evaluate each action in the sequence from left to right, and collect the results. "
10:07:42 <Eduard_Munteanu> MattY: the one from Prelude, or Data.Traversable.sequence ?
10:07:50 <MattY> from Prelude
10:08:12 <MattY> http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:sequence
10:08:16 <Eduard_Munteanu> MattY: it's not monad specific, it's just a  foldl (>>)   really.
10:08:40 <fizruk> > sequence_ [[1, 2], [3, 4, 5]]
10:08:40 <Eduard_Munteanu> Or you could say (>>) is monad-specific.
10:08:41 <MattY> Eduard I know the function isn't, but documentation seems to be. running actions is specific to IO monad, no?
10:08:41 <lambdabot>   [(),(),(),(),(),()]
10:09:17 <donri> chrizz: error "Redundant $!" = f $! x ==> f x where _ = isWHNF x  -- buggy then, because it isn't whnf
10:10:54 <MattY> no actions being ran in fizruk's example, unless I am missing something. it's seems as if sequence used to work just with IO, but documentation wasn't updated with the code
10:11:26 <fizruk> Matty, you can use sequence_ with State
10:11:52 <MattY> yeah, you can use them with any monad
10:11:53 <fizruk> Matty, e.g. sequence_ [modify (+1), put 10, modify (^2)]
10:12:13 <MattY> > sequence [[1, 2], [3, 4, 5]]
10:12:15 <lambdabot>   [[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]]
10:12:18 <MattY> are any actions being ran there?
10:12:27 <ion> yes
10:12:34 <ion> [1,2] is an “action”.
10:12:36 <Iceland_jack> MattY: You can view monads as being ‘actions’ since it isn't a formally defined term anyway
10:12:45 <ion> s/monads/monadic values/
10:12:49 <fizruk> Matty, [1, 2] is an action that returns both 1 and 2
10:13:34 <fizruk> Matty, Just 1 is an action that succeedes and returns 1, Nothing is an action that fails
10:13:48 <fizruk> > sequence_ [Just 1, Nothing, Just 3]
10:13:48 <MattY> until now, I have heard actions only refer to IO actions.
10:13:49 <lambdabot>   Nothing
10:14:13 <Iceland_jack> MattY: Do you agree with calling 'modify (+1)' an action?
10:14:24 <MattY> fizruk it is odd to call it an action, since nothing happens and we are not running it (as we are IO monad for example)
10:14:27 <Iceland_jack> This is just arguing semantics though
10:14:42 <Iceland_jack> MattY: How are they not being ‘run’?
10:15:01 <Iceland_jack> > execState (modify (+1) >> modify (+1) >> modify (+1)) 5
10:15:02 <lambdabot>   8
10:15:05 <ion> matty: In this context, “action” doesn’t imply any impurity.
10:15:12 <MattY> Iceland I am talking about list monad
10:15:15 <MattY> or Maybe monad
10:15:32 <Iceland_jack> MattY: Yes, the ‘action’ in the list monad is non-determinism
10:16:11 <ion> In the Maybe monad the action refers to the effect of potentially short-circuiting the computation.
10:16:45 <ion> In State s it refers to the effects concerning implicit state.
10:16:59 <ion> In IO it refers to the impurity that will occur upon execution.
10:17:05 <Iceland_jack> And for Identity the action is… returning the value with no action!
10:17:10 <Iceland_jack> No action is an action!
10:18:39 <adas1> im trying to install yesod using cabal. but i keep getting 'The following packages are likely to be broken by the reinstalls' and its asks me to --force-reinstall. should i go ahead and do it?
10:19:08 <geekosaur> generally not
10:19:17 <geekosaur> there are two yesod metapackages
10:19:37 <geekosaur> "yesod" wants a bleeding edge ghc setup, "yesod-platform" wants a standard one
10:20:09 <adas1> i tried installed yesod-platform.. the error i got came from trying to install yesod-platform..
10:20:15 <geekosaur> hm
10:20:22 <geekosaur> that seems wromg then
10:20:48 <adas1> the actual error as follows..
10:20:51 <adas1> "cabal: The following packages are likely to be broken by the reinstalls:
10:20:51 <adas1> regex-posix-0.95.1
10:20:51 <adas1> Use --force-reinstalls if you want to install anyway.
10:20:51 <adas1> "
10:21:26 <adas1> and the actual command used "cabal install yesod-platform"
10:22:49 <adas1> am using haskell-platform with ghc 7.4
10:23:14 <geekosaur> just that one? did you manually upgrade / install that at some point?
10:24:09 <adas1> manually installed haskell-platform using `sudo aptitude install haskell-platform`
10:25:41 <moops> is there a way to export all functions from a module rather than listing them individually?
10:25:53 <MattY> module ModuleName where  IIRC
10:26:02 <geekosaur> just leave out the export list, yeh
10:26:08 <moops> oh hehe
10:26:09 <moops> thanks
10:26:41 <Eduard_Munteanu> Is there a "standard" stream package? Stream as in 'data Stream a = a (Cons a)'.
10:26:49 <adas1> what would happen if i force reinstall
10:26:53 <Eduard_Munteanu> Er.
10:27:09 <Eduard_Munteanu> data Stream a = Cons a (Stream a)
10:34:27 <moops> is there a way to leave out this 'a'? instance Semigroup [a] where (<+>) = (++)
10:34:38 <moops> since it is never used
10:34:59 <Eduard_Munteanu> :t (++)
10:35:00 <lambdabot> [a] -> [a] -> [a]
10:35:08 <Eduard_Munteanu> moops: what do you mean never used?
10:35:17 <monoidal> moops: no
10:35:24 <pavonia> Eduard_Munteanu: Stream is quite popular, I think
10:35:27 <moops> it does not appear in the definition
10:35:31 <geekosaur> it's used, just implicitly. still needed to pick the right (++)
10:35:38 <Cale> moops: This says that for any type a, the type [a] is an instance of Semigroup.
10:35:38 <moops> oh okay
10:35:52 <moops> ohhh
10:35:52 <moops> right
10:36:08 <haasn> ‘Haskell’ has a funny Icelandic pronunciation
10:36:16 <Iceland_jack> haasn: Does it?
10:36:26 <tdammers> *everything* has a funny icelandic pronunciation :x
10:36:33 <haasn> Iceland_jack: já
10:36:47 <Iceland_jack> Not to my knowledge…
10:37:00 <Iceland_jack> moops: Just like the ‘a’ in the ‘[a]’ in the type of length is needed
10:37:00 <Iceland_jack> @src length
10:37:00 <lambdabot> Source not found. Just try something else.
10:37:01 <haasn> WEll I guess to an icelandic person it's completely normal, but to me it sounds funny :P
10:37:05 <Iceland_jack> @@ty length
10:37:09 <Iceland_jack> @ty length
10:37:10 <lambdabot> [a] -> Int
10:37:14 <haasn> Especially the ‘ll’ thing
10:37:28 <Iceland_jack> haasn: You wouldn't pronounce that differently from English
10:37:40 <Iceland_jack> not substantially anyway
10:38:38 <tdammers> isn't icelandic what english would have been if it weren't for the anglons, normans, romans, germans, scots, picts, french, etc.?
10:38:40 <moops> i was thinking of it in the wrong way, i think scala is tripping me up a bit
10:38:56 <alexander__b> Haskell in Icelandic would be almost the same.
10:39:38 * FireFly imagines Haskell with Icelandic keywords
10:40:17 <Iceland_jack> You could possibly pronounce the final -ll as
10:40:19 <Iceland_jack>     [tl]
10:40:32 <haasn> Iceland_jack: yes, that's exactly what I'm doing :D
10:40:36 <Iceland_jack> Yes, rather than staying with
10:40:41 <Iceland_jack> Yes, rather than [lː]*
10:40:44 <adas1> how can i install yesod? 'cabal install yesod-platform' turns up errors about reinstalls
10:40:46 <Iceland_jack> which would be wrong
10:42:20 <adas1> woudl it help if I unregister the offending package and then try the installation?
10:50:08 <adas> can somene please help wiht installing yesod?
10:51:24 <lpaste> moops pasted “No title” at http://lpaste.net/95066
10:51:32 <moops> not sure if what im trying to do there is possible?
10:52:40 <pavonia> moops: You need to enable the extention mentioned in the error message
10:52:49 <moops> but its not otherwise an issue?
10:53:05 <pavonia> no
10:53:10 <moops> okay, thx
10:54:01 <moops> im used to languages where extensions mean you are doing something usually unsafe
10:54:42 * hackagebot temporal-media 0.4.0 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.4.0 (AntonKholomiov)
10:55:45 <Cale> moops: FlexibleInstances is considered very benign. Most of the extensions are pretty harmless.
10:56:55 <geekosaur> haskell has its share of unsafe extensions, but many extensions are just "the standard is *really* conservative"
10:57:13 <geekosaur> and some are "the theory wonks are still arguing over which one should be standard"
10:57:27 <moops> hehe
10:57:33 <moops> same sort of stuff going on with scala
10:57:39 <geekosaur> (vastly oversimplified description of the type families vs. fundeps issue)
10:57:40 <carter> Luke: my fix is better
10:57:40 <carter> well
10:57:41 <carter> Luke: more accurately, theres some ways that his fix makes me nervous
10:57:56 <Luke> i saw your comments =) is your fix posted somewhere?
10:58:32 <carter> Luke: yes, look at the #haskell topic
10:58:38 <carter> the bitly link points to my gist
10:58:44 <carter> bit.ly/1hcZveF
10:59:04 <Luke> nice
10:59:06 <Luke> thanks
10:59:32 <carter> Luke: the best solution is to use clang as the c compiler, and have cabal 1.18 default to calling GCC for the CPP
10:59:38 <carter> though sometimes weird stuff happens then :)
10:59:43 * hackagebot temporal-music-notation 0.4.0 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.4.0 (AntonKholomiov)
10:59:45 * hackagebot temporal-music-notation-western 0.4.0 - western music notation  http://hackage.haskell.org/package/temporal-music-notation-western-0.4.0 (AntonKholomiov)
10:59:47 * hackagebot temporal-music-notation-demo 0.4.0 - generates midi from score notation.  http://hackage.haskell.org/package/temporal-music-notation-demo-0.4.0 (AntonKholomiov)
10:59:51 <carter> i may need to revisit getting that to work well
10:59:55 <Luke> carter: oh nice! I didn't know that was an option
10:59:58 <carter> well
11:00:19 <carter> Luke: do you have cabal 1.18 isntalled?
11:00:21 <Luke> yeah
11:00:38 <Cale> moops: The main ones I'd worry about a bit are OverlappingInstances and IncoherentInstances. The first of those is not *so* bad, but might indicate that you're using typeclasses in a less-than-ideal way. The second can result in confusing behaviour if abused, where you end up committing to a more general instance, even though a more specific one is written later.
11:00:52 <lpaste> carter pasted “suffix of my ~/.cabal/config file ” at http://lpaste.net/95067
11:01:03 <carter> Luke: you'll see a commented out line
11:01:40 <moops> Cale: noted, thanks
11:01:43 <carter> so eg I'd probably have set "gcc location" to "/usr/bin/clang"
11:01:57 <carter> and then pass ghc -pgmP /usr/bin/local/gcc-4.8
11:02:01 <carter> or something
11:02:04 <carter> haven't tested it out
11:02:05 <carter> but I should
11:02:24 <Luke> i'll investigate. i'm not on my os x box right now to try anything
11:02:27 <carter> ok
11:02:36 <fizruk> is the new IterT in free package just a FreeT Identity? http://hackage.haskell.org/package/free-4.2/docs/Control-Monad-Trans-Iter.html
11:02:41 <carter> eitehr way, i'm really unhappy with marks solution
11:02:58 <carter> because its actually more fragile / hard to explain than mine
11:03:21 <carter> and i won't provide support if people hit issues with it
11:03:52 <Cale> moops: Aside from that, linear implicit parameters used to be bad, but they're no longer supported, so you don't have to worry about that. I think pretty much everything else is okay. There were things you could do with interactions between generalised newtype deriving and type families that were unsafe, but you almost had to be trying, and that hole is getting plugged in 7.8
11:03:54 <Luke> carter: how do you feel about this approach: http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9
11:04:02 <carter> Luke: that ones ok
11:04:09 <carter> its just sometimes clang's CPP barfs
11:04:27 <carter> so eg you can't get lens current version CPP to work with clang
11:04:57 <Luke> h
11:05:01 <Luke> ah
11:05:04 <carter> or at least a few people have hit that
11:05:13 <carter> hence why i'm just using my own build of gcc 48
11:05:32 <carter> Luke: that said, edwardk and others are probably going to burn down that CPP so the issues goe way for the next lens release
11:06:02 <carter> tl;dr the right way going forward is to add some "understanding what CPP program to call"
11:06:05 <carter> logic to ghc settings
11:06:16 <Luke> right
11:06:17 <carter> and making it possibly its own field in the ghc settings file
11:06:36 <carter> so we can have it be a dedicated HPP that has CPP compatible syntax
11:06:52 <carter> NB: HPP != H++
11:08:52 <carter> Luke: but yeah, basically "here there be dragons" and just saying "use this one shell wrapper trick" isn't going to fly going foward
11:09:04 <carter> someone will have some WEIRD issues
11:09:06 <carter> and yuck
11:14:33 <Eduard_Munteanu> Weird, is there no scanr in 'Stream'? http://hackage.haskell.org/package/Stream-0.4.6.1/docs/Data-Stream.html
11:15:08 <arkeet> @src scanr
11:15:08 <lambdabot> scanr _ q0 []     =  [q0]
11:15:09 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
11:15:09 <lambdabot>     where qs@(q:_) = scanr f q0 xs
11:15:31 <arkeet> scanr is kind of difficult to use with infinite lists.
11:16:16 <arkeet> well, maybe not.
11:16:53 <timthelion> Is there a library that provides protected types for absolute paths and relative paths that doesn't require darcs? http://hackage.haskell.org/package/darcs-2.8.4/docs/src/Darcs-RepoPath.html#AbsolutePath
11:16:56 <arkeet> well, yes it is.
11:16:57 <arkeet> if you want something less trivial than a map.
11:17:04 <arkeet> well, I dunno.
11:17:06 <HugoDaniel> im trying to use the streams of xml-conduit with network-conduit, and when i put a renderBytes i dont get any output, what am i missing ?
11:17:15 <HugoDaniel> how can i force a flush ?
11:17:52 <Eduard_Munteanu> arkeet: head (scanr f xs) = foldr f xs
11:18:05 <arkeet> yeah never mind.
11:18:11 <Eduard_Munteanu> arkeet: also no foldr either :/
11:18:17 <arkeet> yeah ok
11:19:56 <Eduard_Munteanu> I suppose you could say 'scanr f xs = map (foldr f) (tails xs)'
11:22:41 <msl09> I don't know if this is a place to ask stupid questions, but I have a problem with this function: dfun x x' = sqrt (x * x - x' * x')
11:23:10 <msl09> It always returns NaN, no matter what I pass to it
11:23:27 <cschneid> :t sqrt
11:23:28 <lambdabot> Floating a => a -> a
11:23:38 <quchen> > let x = 3; x' = 1 in sqrt (x * x - x' * x')
11:23:39 <lambdabot>   2.8284271247461903
11:23:49 <Eduard_Munteanu> msl09: does it have a type signature?
11:24:07 <msl09> I haven't given one
11:24:30 <Eduard_Munteanu> msl09: try specifying it
11:24:34 <tromp_> try passing x > x' > 0
11:24:47 * hackagebot csound-expression-dynamic 0.0.0 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.0.0 (AntonKholomiov)
11:24:49 * hackagebot csound-expression-typed 0.0.0 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.0 (AntonKholomiov)
11:25:07 <cschneid> > sqrt (9 - 16)
11:25:09 <lambdabot>   NaN
11:25:32 <Narvius> > sqrt . sqrt . sqrt $ 8
11:25:34 <lambdabot>   1.2968395546510096
11:25:46 <roconnor> > very sqrt $ 8
11:25:48 <lambdabot>   Not in scope: `very'
11:25:54 <cschneid> :)
11:26:00 <msl09> dfun :: (Floating a) => a -> a -> a
11:26:03 <msl09> ah I see
11:26:19 <msl09> no wait
11:27:48 <HugoDaniel> i need help with conduits
11:28:20 <msl09> ahhhhhhhhhhh
11:28:24 <msl09> I see it now
11:28:34 <msl09> thanks
11:28:43 <HugoDaniel> im trying to render a list of xml-conduit events using the renderBytes, but in network-conduit i dont get any output with that function, what am i doing wrong ?
11:29:48 * hackagebot csound-expression-opcodes 0.0.0 - opcodes for the library csound-expression  http://hackage.haskell.org/package/csound-expression-opcodes-0.0.0 (AntonKholomiov)
11:29:50 * hackagebot csound-expression 3.0.0 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-3.0.0 (AntonKholomiov)
11:29:52 * hackagebot temporal-csound 0.2.0 - brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.2.0 (AntonKholomiov)
11:30:03 <cschneid> msl09: note, sqrt works on complex values:
11:30:04 <cschneid> > sqrt $ ( (-4) :+ 0 ) :: Complex Float
11:30:05 <lambdabot>   0.0 :+ 2.0
11:30:27 <msl09> I was passing negative values to sqrt
11:31:31 <msl09> I was using dfun to calculate the distance between two points, but the logic was wrong
11:31:56 <msl09> I needed to do something like this dfun x x' = sqrt ((x - x') ** 2)
11:32:36 <Eduard_Munteanu> msl09: you realize that's just  x - x'  ? :)
11:33:17 <quchen> |x - x'| you mean.
11:33:28 <Eduard_Munteanu> Hm, indeed.
11:34:10 <msl09> I should have used abs (x - x')  :)
11:34:48 * hackagebot csound-catalog 0.1 - a gallery of Csound instruments.  http://hackage.haskell.org/package/csound-catalog-0.1 (AntonKholomiov)
11:34:52 <Eduard_Munteanu> msl09: no... first, what type does x have?
11:35:05 <msl09> Floating
11:35:23 <msl09> well it could be Num
11:35:46 <Eduard_Munteanu> msl09: those are typeclasses, did you mean "any Floating"?
11:36:33 <fizruk> :t abs
11:36:33 <Eduard_Munteanu> msl09: anyway, how do you represent them, two coordinates for each?
11:36:35 <lambdabot> Num a => a -> a
11:37:32 <msl09> the points have type [Floating]
11:37:47 <Eduard_Munteanu> :k Floating
11:37:49 <lambdabot> * -> Constraint
11:38:04 <Eduard_Munteanu> msl09: Floating isn't a type
11:38:11 <msl09> hmmm
11:38:17 <msl09> what is it then?
11:38:32 <Eduard_Munteanu> A typeclass, like Monad, Num ...
11:38:52 <msl09> hmmm
11:39:12 <Eduard_Munteanu> msl09: perhaps you meant Float, that is a type
11:39:23 <msl09> I don't know how to differentiate types and typeclasses yet
11:39:45 <Eduard_Munteanu> Oh, ok. Wasn't sure if that was the case here.
11:39:48 * hackagebot purescript 0.1.0 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.0 (PhilFreeman)
11:40:56 <Eduard_Munteanu> msl09: typeclasses group types which have things in common, for example both Double and Int are Nums, because they can be added, multiplied etc.
11:41:07 <cschneid> :t sqrt
11:41:08 <lambdabot> Floating a => a -> a
11:41:21 <cschneid> msl09: so sqrt can act on anything that behaves like a floating point number.
11:41:34 <msl09> ok
11:41:48 <cschneid> so Floating is a typeclass.  A specific type can then provide definitions for that typeclass to become a member
11:41:55 <rasfar> msl09, you can often get away with avoiding the sqrt altogether, just work with the sum of the squared differences
11:43:10 <msl09> hmmm
11:43:18 <rasfar> well maybe not often! but for testing spherical containment works a treat
11:44:10 <msl09> actually I'm doing some basic haskell exercises :)
11:44:37 <Eduard_Munteanu> msl09: just use concrete types like Double then
11:45:41 <msl09> so typeclasses are like a type with no implementation?
11:46:14 <Eduard_Munteanu> msl09: no, they're more like sets of types
11:46:20 <cschneid> msl09: it's not a type at all. It's a template of functions that a given type can implement
11:46:45 <msl09> hmm, I see
11:46:52 <Eduard_Munteanu> I just got spammed by Zektor6.
11:46:58 <scriptor> roughly speaking, a type can implement a typeclass by implementing some functions for that type
11:47:02 <cschneid> Eduard_Munteanu: me too. :(
11:47:19 <Zektor6> scriptor Tired of niggers? Sick of their monkeyshines? We are too! Join Chimpout Forum! http://www.chimpout.com/forum At Chimpout, we are NOT white supremacists! I myself am a Mexican! Basically, if you are not a NIGGER and you hate NIGGERS, we welcome you with open arms! Join Chimpout Forum today! http://www.chimpout.com/forum
11:47:24 --- mode: ChanServ set +o geekosaur
11:47:26 <Eduard_Munteanu> @where ops
11:47:26 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
11:47:27 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
11:47:31 --- mode: geekosaur set +b *!*Zektor6@187.153.20.*
11:47:32 --- kick: Zektor6 was kicked by geekosaur (Zektor6)
11:47:34 <cschneid> msl09: so for the Floating typeclass, it seems like 3 functions are required, in addition to all of what Num requires.  See: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating
11:47:37 <scriptor> yay
11:48:15 --- mode: geekosaur set -o geekosaur
11:54:58 <lrockmashtime> is there an easy way to define a nth sized tuple/list of Integer types?
11:55:54 <Eduard_Munteanu> lrockmashtime: there's TH stuff to do it, or you can make heterogenous lists in recent GHC versions
11:56:22 <lrockmashtime> thanks Eduard_Munteanu, what is TH?
11:56:39 <Eduard_Munteanu> lrockmashtime: but if you only have Integers you can define a length-indexed list.
11:56:46 <Eduard_Munteanu> lrockmashtime: Template Haskell
11:56:59 <lrockmashtime> sweet I'll look into this
11:58:06 <Eduard_Munteanu> lrockmashtime: for example   data Vec :: Nat -> * -> * where Nil :: Vec 0 a; Cons :: a -> Vec n a -> Vec (n + 1) a
11:58:24 <Eduard_Munteanu> lrockmashtime: you need a few extensions for that though
11:58:33 <lrockmashtime> whoa that looks intense
11:59:00 <lrockmashtime> i'm still trying to get through LYAHG
11:59:15 <Eduard_Munteanu> lrockmashtime: oh, heh, don't bother doing that then just yet :)
11:59:59 <lrockmashtime> I was hoping there was just a shortcut to [Integer, Integer, Integer, Integer, Integer]
12:00:21 <Eduard_Munteanu> lrockmashtime: in many cases you can use normal tuples because many functions are often defined for 2, 3 ... -sized tuples up to some n.
12:00:49 <lrockmashtime> sounds good
12:00:52 <Eduard_Munteanu> lrockmashtime: that's not a valid type, unless you mean a tuple, not a list
12:00:58 <Eduard_Munteanu> :t zip5
12:00:59 <lambdabot> [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
12:01:54 <Eduard_Munteanu> But if you need a tuple that large perhaps you should consider making a record datatype.
12:02:19 <lrockmashtime> a what??
12:03:24 <Eduard_Munteanu> lrockmashtime: [Integer] is a list of Integers, (Integer, Integer, Integer, Integer, Integer) is a tuple containing 5 Integers.
12:03:41 <Eduard_Munteanu> Is the type of, more exactly.
12:04:20 <cschneid> lrockmashtime: and a record datatype is using the `data` keyword like: `data MyFive = MyFive { one :: Integer, two :: Integer, .... }.  So you formalize more about the structure. But if you haven't run into that, you'll get to it soon enough in the book.
12:04:31 <lrockmashtime> oh right, I do that shit allll the time
12:05:00 <lrockmashtime> i'm actually trying to model the powerball lottery
12:05:19 <Eduard_Munteanu> I only very rarely use tuples larger than pairs.
12:05:49 <Eduard_Munteanu> If you need an extra value, in many cases pairs of pairs are more convenient.
12:06:28 <Eduard_Munteanu> :t snd . snd . snd . snd
12:06:30 <lambdabot> (a3, (a2, (a1, (a, c)))) -> c
12:10:05 <lrockmashtime> ok so say you're trying to model the powerball such that u have a function that can take a set of 5 unique numbers all from 1 to 59 and an additional number of 1 to 35 (representing the powerball), it seems like you can get a lot of data validation just by the way you define your types. Or you can create logic in a function to do validation. What's the better practice in this scenario?
12:15:00 <Athan> Hey y'all, haskell noob here
12:15:15 <Athan> how do I import modules found in remote packages via ghci?
12:15:26 <Athan> I've already installed the packages locally via cabal install
12:15:49 <Athan> but when I try to load the module (Data.SVG.SVG), it throws a "package module" error
12:15:56 <Athan> any idea what I should do?
12:17:25 <rasfar> could it be just Data.SVG you want to import?
12:17:51 <Athan> nope, tried that already
12:18:22 <Athan> I wish there was a way to set up a ghci environment via cabal
12:18:42 <rasfar> i guess there are -package flags needed in some cases
12:18:54 <glguy> Athan: "cabal repl" doesn't do what you want?
12:18:57 <peddie> Athan: cabal repl?
12:19:54 * hackagebot purescript 0.1.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.1 (PhilFreeman)
12:20:13 <Athan> wow, I had no idea, sorry guys
12:20:15 <Athan> thank you!
12:22:15 <chrisdone> purescript!
12:24:12 <hamid> chrisdone, what about it? :P
12:24:54 <chrisdone> it's kül
12:28:07 <Shin-LaC> why is "sort" not in the prelude?
12:28:16 <Eduard_Munteanu> Shin-LaC: it is, AFAIK
12:28:21 <Eduard_Munteanu> @index sort
12:28:21 <lambdabot> Data.List
12:28:28 <Eduard_Munteanu> Hm.
12:28:35 <chrisdone> i have some JS code that needs to be fast so it's not in fay, but i'd be interested in rewriting it in purescript
12:28:45 <Eduard_Munteanu> Shin-LaC: don't mind me :)
12:28:48 <Shin-LaC> lol
12:34:03 <lambdaCalculator> Would anyone be willing to help me debug a faulty attempt at writing mergesort?
12:34:41 <Eduard_Munteanu> lambdaCalculator: perhaps, but don't ask to ask, just describe your problem
12:36:10 <lambdaCalculator> Ok.  Problem: I'm writing an implementation of mergesort, and it works sometimes, but most of the time it seems to work for all but the lowest and highest valued elements
12:36:52 <Eduard_Munteanu> lambdaCalculator: would be helpful to pastebin your code
12:37:05 <lambdaCalculator> merge :: (Ord a) => ([a],[a]) -> [a]
12:37:05 <lambdaCalculator> merge ((x:xs),(y:ys))
12:37:05 <lambdaCalculator> 	| x <= y 	= [x] ++ merge (xs,(y:ys))
12:37:07 <lambdaCalculator> 	| otherwise	= [y] ++ merge ((x:xs),ys)
12:37:09 <lambdaCalculator> merge (xs,[]) = xs
12:37:11 <lambdaCalculator> merge ([],xs) = xs
12:37:20 <lambdaCalculator> mergeIter :: (Ord a) => ([a],[a]) -> [a]
12:37:21 <lambdaCalculator> mergeIter (xs,ys)
12:37:21 <lambdaCalculator> 	| and [isPairXs, isPairYs] 	= merge (xs,ys)
12:37:22 <lambdaCalculator> 	| isPairXs 					= merge (xs,mergeIter (splitAt yMed ys))
12:37:24 <lambdaCalculator> 	| isPairYs 					= merge (mergeIter (splitAt xMed xs),ys)
12:37:24 <Eduard_Munteanu> lambdaCalculator: stop, don't paste that much straight into the channel
12:37:26 <lambdaCalculator> 	| otherwise 				= merge (mergeIter (splitAt xMed xs) , mergeIter (splitAt yMed ys))	
12:37:28 <lambdaCalculator> 	where
12:37:30 <lambdaCalculator> 		isPair z = length z <= 2
12:37:30 <geekosaur> pasterBIN
12:37:32 <lambdaCalculator> 		isPairXs = isPair xs
12:37:33 --- mode: ChanServ set +o geekosaur
12:37:34 <lambdaCalculator> 		isPairYs = isPair ys
12:37:34 <Rarrikins> lambdaCalculator: Please use lpaste.net
12:37:36 <lambdaCalculator> 		xMed = medianIndex xs
12:37:38 <lambdaCalculator> 		yMed = medianIndex ys
12:37:41 --- kick: lambdaCalculator was kicked by geekosaur (lambdaCalculator)
12:37:50 <geekosaur> most clients can't stop a paste...
12:38:03 <Rarrikins> lambdaCalculator: Please use lpaste.net for pastes more than one line.
12:38:15 <lambdaCalculator> Ok, will do
12:38:15 <geekosaur> and the ones that can, udually too much is already buffered for it to matter
12:38:20 --- mode: geekosaur set -o geekosaur
12:38:54 <haasn> Popular clients should be patched to automatically upload large pastes via some paste website
12:39:01 <jrmithdobbs> can someone tell me what I'm missing to get this example to actually work? I'm using 7.6.3 and aeson 6.2.1: http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson.html#g:5
12:39:07 <jrmithdobbs> http://pastebin.com/STd9K1Ec
12:39:08 <lambdaCalculator> http://lpaste.net/95070
12:39:13 <mauke> The paste STd9K1Ec has been copied to http://lpaste.net/95071
12:39:49 <haasn> jrmithdobbs: a ToJSON Person instance, most likely
12:40:21 <jrmithdobbs> haasn: so a a specific instance toJSON Person ; is still necessary and they just left it out of their example? thought that was odd ;p
12:41:04 <haasn> Oh, reading the code sample
12:41:10 <haasn> Switch to the Generic module :)
12:41:33 <jrmithdobbs> ok, once I do that it's bitching about missing Generics definitions ... I thought the whole point of using Data/Typeable here was not use generics?
12:42:23 <haasn> Those functions just need a Data instance
12:43:13 <cschneid> haasn: limechat on mac does that. Paste more than one line and it offers to gist it for you. Super slick.
12:43:30 <haasn> cschneid: then lambdaCalculator must have it disabled or something
12:43:54 <lambdaCalculator> cschneid: I didn't disable it, I just only recently started using IRC so I didn't notice the option
12:44:16 <cschneid> no worries. Just impolite to dump a bunch of code on people. No biggie - just pastebin it next time.
12:44:20 <lambdaCalculator> Yeah
12:44:26 <lambdaCalculator> Anyway, the pastebin is here http://lpaste.net/95070
12:44:35 <lambdaCalculator> Actually, wait
12:44:38 <lambdaCalculator> That's missing one piece of code
12:45:11 <HugoDaniel> geekosaur: can you help me with conduits ?
12:45:12 <lambdaCalculator> https://gist.github.com/anonymous/80409ca5cf93ae869402
12:45:16 <lambdaCalculator> There we go
12:46:07 <Rarrikins> lambdaCalculator: [x] ++ is the same as x:
12:46:14 <geekosaur> HugoDaniel, not really. I've been keeping an eye on them but as I kept saying, they're still somewhat evolving. as I dont have much need for the use cases where they're better than standard I/O, I haven't actualy done much with them as yet
12:46:28 <HugoDaniel> ok, thanks
12:46:37 <geekosaur> am willing to wait for things to stabilize a bit, and maybe the pissfest between conduits and pipes to settle down
12:46:37 <Rarrikins> lambdaCalculator: Also, it's clearer to use two arguments rather than a tuple.
12:47:15 <HugoDaniel> im always fond of a good old dick/tits measuring fight
12:47:33 <lambdaCalculator> Rarrikins: yes, I get that there are some stylistic issues, some advice about what's going wrong with the logic itself would be appreciated as well
12:48:48 <Eduard_Munteanu> @type scanr1 seq
12:48:49 <lambdabot> [a] -> [a]
12:48:51 <HugoDaniel> ok, i did a simple server that should stream xml, but doesn't, the error i think is somewhat related to the blaze Builder that it has bellow, but i can't seem to fit a working conduit in it :/
12:49:05 <Eduard_Munteanu> Does that 'scanr1 seq' have a name?
12:49:07 <paf31> chrisdone, I'd be interested to hear your experience with it (PureScript)
12:49:11 <FireFly> @ty seq
12:49:12 <lambdabot> a -> b -> b
12:49:22 <Farre> hi I was wondering if someone could help a newbie like myself with a dumb question
12:49:48 <Cale> Farre: Feel free to ask lots of questions here :)
12:51:01 <Eduard_Munteanu> Example usecase: last . scanr1 seq . scanl f z ~= foldl' f z
12:51:04 <Farre> Cale: Thank you :), well the thing is I'm trying to learn how to program in haskell and the thing is that I'm wondering how to compile a program
12:51:36 <Eduard_Munteanu> Er, s/last/head/
12:52:00 <Cale> Farre: Well, if you have a file like MyProgram.hs containing an IO action called main, you can run  ghc MyProgram  and it will build an executable file for you
12:52:57 <Eduard_Munteanu> It's pretty much a strictifying combinator you can apply to any left scan to make it a strict fold.
12:52:57 <Rarrikins> lambdaCalculator: It looks as if you stop at pairs, and those pairs might not be sorted.
12:53:25 <Rarrikins> lambdaCalculator: For example, check out mergeSort . reverse $ [1..10]
12:53:26 <Farre> Cale: oh ok, well does the file with the ending .hs have to be at any certain place on the harddrive when I'm trying to compile it?
12:53:38 <Cale> No, it can be anywhere you like.
12:53:58 <Rarrikins> lambdaCalculator: It gives [2,1,3,5,4,7,6,8,10,9]
12:54:02 <lambdaCalculator> Yeah
12:54:07 <Eduard_Munteanu> > head . scanr1 seq . take 1000 . scanl (+) z $ [1..]
12:54:08 <lambdabot>   z + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + ...
12:54:14 <lambdaCalculator> Thanks
12:54:16 <Eduard_Munteanu> Er.
12:54:22 <Rarrikins> lambdaCalculator: No problem.
12:54:29 <Eduard_Munteanu> > head . scanr1 seq . take 1000 . scanl (+) 0 $ [1..]
12:54:31 <lambdabot>   499500
12:55:27 <Cale> Farre: Of course, you'll have to run ghc while in that same directory.
12:55:33 <lightquake> the peril of installing everything into ~: when you change usernames suddenly everything breaks
12:56:30 <jrmithdobbs> haasn: i like this method better than generics: http://lpaste.net/95071
12:56:30 <Farre> Cale: oh ok so the file should be in the same directory as the .hs file
12:56:32 <Eduard_Munteanu> Which is quite convenient because you don't need to define separate left folds.
12:57:00 <Shin-LaC> bar.hs:20:19: parse error on input `=' <- there are not even 19 characters on line 20
12:57:09 <Cale> Farre: The executable which gets built will be in the same directory as the .hs file, yes
12:57:26 <Cale> Farre: and you should be in that directory when you run ghc
12:57:41 <Eduard_Munteanu> Strict and non-strict folds, that is. And not just foldl{,'}, think about sum and other things that need to do a foldl.
12:58:01 <Eduard_Munteanu> It sort of sucks if you don't get fusion though.
12:58:17 <Farre> Cale: Okey, how do I move through the drive in the ghc, is it like linux just tying cd?
12:58:49 <Shin-LaC> augh
12:58:55 <Shin-LaC> it was a tab issue
13:11:41 <Cale> Farre: I mean you *run* ghc like that, you don't cd *inside* ghc, it's not interactive
13:11:56 <Cale> You'd run the ghc command from whatever shell you use
13:13:07 <Cale> Shin-LaC: figures! Tabs always count as aligning to the next multiple of 8 spaces, so if your editor shows them as something else, it can be confusing.
13:13:30 <Shin-LaC> I've set it to always expand tabs to spaces now
13:13:43 <Cale> Yeah, that's the right policy
13:14:00 <Cale> imo, tabs should be a lexical error, given all the problems they cause
13:19:21 <CryptoCrack> Off-topic question. If f, g are functions. How do you call h : x |-> (f(x), g(x))?
13:19:33 <CryptoCrack> Like.. Whats the general expression for such a function?
13:19:34 <mauke> &&&
13:19:39 <CryptoCrack> I can't remember :/
13:20:18 <djahandarie> :t (&&&)
13:20:19 <chrisdone> :t (&&&)
13:20:19 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
13:20:20 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
13:20:28 <chrisdone> djahandarie: WE MEET AGAIN
13:20:51 <djahandarie> :t (&&&) :: (b -> c) -> (b -> c') -> (b -> (c, c'))
13:20:53 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
13:21:11 * Qfwfq made a thing https://github.com/AmpexShouldTicklesDazzler/wolfram
13:22:23 <Eduard_Munteanu> Hm, looks like you can unify vecs and streams quite nicely with DataKinds.
13:26:19 <Eduard_Munteanu> I wonder if I can write the omega ordinal.
13:27:15 <scshunt> haha
13:28:05 <Eduard_Munteanu> I should mention Agda does accept omega in some quite cool contexts.
13:28:20 <FreeFull> :t (&&&) `asAppliedTo` id
13:28:21 <lambdabot> (a -> a) -> (a -> c') -> a -> (a, c')
13:28:32 <Eduard_Munteanu> For example, it's incredibly easy to prove Fin ω ~ Nat
13:28:51 <FreeFull> :t (&&&) `asAppliedTo` (undefined :: a -> b)
13:28:52 <lambdabot> (a -> b) -> (a -> c') -> a -> (b, c')
13:29:17 <Dodek> so there used to be a waitTimeout function in Control.Concurrency.Thread
13:29:18 <Dodek> http://hackage.haskell.org/package/concurrent-extra-0.4/docs/Control-Concurrent-Thread.html
13:29:30 <Dodek> as this module seems to be gone, what should I use as replacement?
13:29:35 <tac_> Is there an easy way to get the day of the week in Haskell?
13:29:57 <Eduard_Munteanu> tac_: use Data.Time.Calendar, off the top of my head
13:30:03 <djahandarie> :t asAppliedTo
13:30:04 <lambdabot> (a -> b) -> a -> a -> b
13:30:41 <tac_> Eduard_Munteanu: I found that library, but there doesn't seem to be a way to extract the DoW in a straightforward way
13:30:53 <djahandarie> :t const `asAppliedTo` asAppliedTo
13:30:54 <lambdabot> ((a -> b1) -> a -> a -> b1) -> b -> (a -> b1) -> a -> a -> b1
13:31:28 <briennetheblue> is there anything on hackage that has a sequenceUntil :: Monad m => (a -> Bool) -> [m a] -> m [a] ?  i've tried hoogle...
13:31:36 <Eduard_Munteanu> tac_: try Data.Time.Format if you want to get actual names for days
13:32:22 <tac_> thank you
13:32:22 <tac_> I'll check him out
13:36:04 <jrmithdobbs> so what's lpaste.net using to throw those error/warning messages? is there a hs-lint i missed or somethinG?
13:37:22 <briennetheblue> http://hackage.haskell.org/package/hlint i think?
13:37:40 <augur_> "HDD" is silly
13:37:47 <augur_> HDD is great, but "HDD" is silly
13:38:01 <augur_> those arent scare quotes, by the way, they're real quotes
13:38:44 <haasn> augur_: wrong channel?
13:39:22 <geekosaur> possibly meaning hlint driven development...
13:40:21 <augur_> Hole Driven Development
13:40:30 <chrisdone> holes ftw!
13:40:35 <augur_> one of the topics from LambdaJam
13:40:45 <augur_> chrisdone: indeed. holes are the best thing to ever happen to programming!
13:41:01 <chrisdone> see more http://matthew.brecknell.net/post/hole-driven-haskell/
13:41:05 <augur_> but to give the use of holes its own name is kind of silly. i mean, we've always been doing hole driven development since forever
13:41:05 <runde> Ok guys, I just wrote my first few lines of "real world" Haskell. Improvements plix? https://github.com/terjr/hassembler/blob/master/hassembler.hs
13:41:12 <augur_> even back to pre-computer days
13:41:55 <augur_> back in SICP they taught HDD by way of abstraction, to some extent. the whole programming by faith thing that they talked about
13:42:05 <augur_> its not quite HDD but its the same spirit
13:42:22 <chrisdone> i like mathew's approach in this video because he really takes it to an extreme but it works
13:42:30 <augur_> but to name this whole thing "HDD" is silly to me
13:42:30 <augur_> its just
13:42:40 <augur_> the same thing we've always done, but with better language support
13:42:41 <chrisdone> to me holes is about making the compiler help fill in the gaps for you
13:42:45 <augur_> haskell's holes arent even that good at all
13:42:54 <augur_> agda's holes, now thems some holes
13:43:15 <augur_> you need a proper editor to do real HDD
13:43:21 <chrisdone> downer
13:43:33 <Cale> runde: The new location for Parsec is Text.Parsec -- the Text.ParserCombinators.Parsec path is still supported only for backwards compatibility.
13:43:56 <runde> Noted
13:44:30 <Cale> runde: choice ps = foldr (<|>) mzero ps -- this is in Text.Parsec.Combinator
13:45:10 <chrisdone> augur_: i'd like to see some attempts to make clever holes for GADTs
13:45:19 <Cale> i.e. you could write  opcode = choice . map (try . string) $ ["addi", "fadd", ...]
13:45:55 <chrisdone> augur_: like @djinn that knows about GADTs
13:46:10 <chrisdone> e.g. if the editor knows my types, and it's clever enough, i could write out a type, and it could fill it as best it can
13:46:29 <chrisdone> i wonder how much could be automatically filled out for the classic `eval' function given some setup
13:46:33 <Cale> runde: In regOrImm, you're in a case expression on x, and yet still use head x and tail x
13:46:54 <carter> chrisdone: i'm trying to nerd snipe some folks to work on making holes even better for 7.10
13:46:57 <Cale> runde: You might as well use (v:vs) -> Reg v (read vs)
13:47:15 <chrisdone> carter: :D
13:47:24 <augur_> chrisdone: thats called agsy
13:47:28 <carter> chrisdone: the dude who's the author of vinyl is one
13:47:35 <chrisdone> augur_: what's agsy?
13:47:42 <augur_> chrisdone: djinn for agda
13:47:51 <chrisdone> agda needs a djinn?
13:48:05 <chrisdone> carter: sweet
13:48:10 <augur_> chrisdone: its often ncie to be able to fill in "obvious" lemmas without having to think about it yourself
13:48:40 <Eduard_Munteanu> What's a good name for 'zip <$> inits <*> tails'? "spans", "splits", "zippers", something else?
13:48:49 <chrisdone> augur_: doesn't agda-mode already do that?
13:48:52 <runde> Cale: Excellent, thank you!
13:48:57 <augur_> chrisdone: yes, thats what agsy is
13:49:06 <chrisdone> augur_: ah, agda-mode's using that underneath
13:49:13 <augur_> chrisdone: its a little widget that exists within agda mode that solves proofs for you
13:49:20 <augur_> C-c C-a is agsy
13:49:35 <fizruk> Eduard_Munteanu, consequents ?
13:49:39 <chrisdone> yeah, i've used that
13:50:01 <Eduard_Munteanu> fizruk: hmm... where does that come from?
13:50:11 <chrisdone> augur_: have there been more comprehensive djinn's for haskell with more up to date extensions, do you know?
13:50:20 <fizruk> nvm, I misread inits/tails as init/tail
13:50:39 <augur_> chrisdone: not to my knowledge. it'd be interesting to try to apply some fancier proof theory techniques tho, assuming they havent already been used
13:50:50 <augur_> like, say, focused polarized proofs
13:50:55 <Eduard_Munteanu> > let spans = zip <$> inits <*> tails in spans [1,2,3,4]
13:50:56 <lambdabot>   [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
13:51:24 <augur_> well i guess focusing forces polarization
13:52:07 <chrisdone> augur_: what would that bring to the table for haskell?
13:52:17 <augur_> nothing
13:52:20 <fizruk> Eduard_Munteanu, I like spans :)
13:52:21 <augur_> it would just be a better djinn
13:53:10 <fizruk> > zip <$> init <*> tail $ [1..10]
13:53:12 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
13:53:31 <chrisdone> augur_: how would it be better?
13:53:37 <augur_> chrisdone: faster
13:53:42 <augur_> maybe
13:53:48 <augur_> unless djinn already uses focused proofs
13:55:52 <moops> how would i type hint x in "x <- xs" in do notation?
13:56:05 <moops> trying to track down a type error
13:56:24 <Eduard_Munteanu> moops: what do you mean "hint x"?
13:56:31 <ion> > (zip <*> drop 1) [1..10]
13:56:33 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
13:56:36 <augur_> moops: i dont know if you can hint on x directly there, but you can annotate when you use x
13:56:36 <moops> i want to put what type i think it is
13:56:38 <augur_> eg
13:56:48 <augur_> x <- xs ; ... (x :: Foo) ...
13:56:53 <augur_> or you can hint on xs
13:56:59 <chrisdone> moops: x <- (xs) :: IO ()
13:57:02 <augur_> x <- xs :: M Foo ; ...
13:57:10 <geekosaur> ScopedTypeVars extension should allow (x :: Foo) <- xs
13:57:22 <geekosaur> (since it absorbed PatternSignatures)
13:58:09 <chrisdone> geekosaur: TIL of PatternSignatures
13:58:25 <moops> Unsupported extension: ScopedTypeVars oops
13:58:29 <chrisdone> geekosaur: i use [the functionality of] PatternSignatures way more than ScopedTypeVariables
13:58:38 <geekosaur> yeh
13:59:59 <moops> i might just not understand do notation yet :X
14:00:04 <moops> ill try some more for a bit
14:00:16 <fizruk> moops: ScopedTypeVariables
14:00:44 <geekosaur> yeh, I kinda shorthanded there, sorry
14:02:17 <moops> figured it out, thanks all
14:03:28 <coreyoconnor> Has anybody been able to compile lens from git using GHC HEAD?
14:14:45 <moops> is ((->) r) a the same as r -> a
14:14:53 <Eduard_Munteanu> moops: yes
14:14:56 <moops> wat
14:15:03 <moops> why is r on that side o_O
14:15:17 <moops> ohhhh
14:15:19 <moops> nvm
14:15:21 <moops> hehe
14:15:21 <geekosaur> () on an operator makes it a prefix function
14:15:28 <mauke> ((+) a) b is the same as a + b
14:15:29 <Eduard_Munteanu> moops: because (+) x y is x + y
14:16:00 <moops> treating type constructors and functions the same still tripping me up
14:18:54 <augur_> omg
14:19:01 <augur_> australian raising in YOW's HDD talk
14:19:04 <augur_> how hilarious :D
14:19:07 <FireFly> > Left 1 :: Int `Either` Int
14:19:08 <lambdabot>   Left 1
14:19:15 <FireFly> oh, that works? heh
14:19:21 <augur_> FireFly: ofcourse it does!
14:19:32 <johnw> heh, i never knew that
14:20:35 <johnw> i guess that explains why I've seen `O` as functor composition before, though
14:25:11 * hackagebot texmath 0.6.5 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.5 (JohnMacFarlane)
14:33:17 <`^_^v> i have this function http://lpaste.net/9201315610263289856  - is there a cleaner way of writing this (i.e. eliminating the case expression)
14:34:12 <mm_freak> `^_^v: to get rid of 'case' you can use 'maybe'
14:34:13 <mm_freak> :t maybe
14:34:14 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:34:33 <mm_freak> equivalently for Either and [], you can use 'either' and 'foldr' resp.
14:34:35 <Eduard_Munteanu> :t curry (uncurry ?f *** uncurry ?g)
14:34:36 <lambdabot> (?f::a -> b -> c, ?g::a1 -> b1 -> c1) => (a, b) -> (a1, b1) -> (c, c1)
14:34:41 <Eduard_Munteanu> Is there a name for ^^^ ?
14:35:28 <Eduard_Munteanu> I mean for \f g -> curry (uncurry f *** uncurry g).
14:35:35 <Eduard_Munteanu> :t \f g -> curry (uncurry f *** uncurry g)
14:35:36 <lambdabot> (a -> b -> c) -> (a1 -> b1 -> c1) -> (a, b) -> (a1, b1) -> (c, c1)
14:35:47 <mm_freak> Eduard_Munteanu: not really
14:36:07 <Eduard_Munteanu> :t \f g -> curry (uncurry f &&& uncurry g)  -- or this one :/
14:36:08 <lambdabot> (a -> b -> c) -> (a -> b -> c1) -> a -> b -> (c, c1)
14:36:10 <Eduard_Munteanu> I see.
14:39:12 <Eduard_Munteanu> I'm coming up with a bunch of list / stream functions that don't seem to be very well known.
14:39:54 <djahandarie> There's probably a whole space of combinators here that can just be iterated over.
14:40:37 <Eduard_Munteanu> Yeah. But some seem really general.
14:40:58 <danilo2_> hello! Is there a way to use shared memory in Haskell with C++? I'v got gui in C++ and I'm processing images in Haskell. I want to interactively display the results in the GUI.
14:41:58 <Eduard_Munteanu> danilo2_: you can allocate memory and use pointers on both the Haskell and C++ side.
14:42:30 <Eduard_Munteanu> danilo2_: but are those processes distinct?
14:42:52 <Eduard_Munteanu> If you FFI to C++ it's not quite shared memory, it's just a buffer. :)
14:44:23 <jrmithdobbs> hrm, how can I shove a case statement onto one line for typing in ghci? ( let r = case (decode t :: Maybe MyType) of Just x -> x ; Nothing -> Nothing .... throws an error at the first Nothing
14:44:46 <Eduard_Munteanu> djahandarie: e.g., I was wondering about  strictify = scanr seq  earlier.
14:45:13 <Eduard_Munteanu> jrmithdobbs: I think you need { Just x ...... Nothing }
14:45:23 <Eduard_Munteanu> Braces, that is.
14:45:27 <mauke> you don't
14:45:29 <jrmithdobbs> Eduard_Munteanu: oh that's it
14:45:31 <jrmithdobbs> no?
14:46:13 <jrmithdobbs> err, hrm
14:46:25 <Eduard_Munteanu> I thought you needed braces for one-liner do notation, for example.
14:46:26 <mm_freak> jrmithdobbs: it says type error, because it is a type error
14:46:41 <mauke> Eduard_Munteanu: you don't
14:46:45 <mm_freak> :t maybe Nothing id
14:46:46 <lambdabot> Maybe (Maybe a) -> Maybe a
14:46:58 <mm_freak> nothing to do with syntax
14:47:13 <Eduard_Munteanu> :t maybe
14:47:14 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:48:12 <danilo2_> Eduard_Munteanu: Ok, using FFI it is not shared memory, but Ive got 2 following questions: I've heard FFI is slow (I didnt used it personaly) - is it true? 2) What if that are 2 processes?
14:49:12 <danilo2_> Eduard_Munteanu: If that are distinct processes I have to allocate memory on C++ side and somehow give Haskell access to it?
14:49:46 <Eduard_Munteanu> danilo2_: 1) Not really, 2) Processes are totally separate from each other, so you'll need to use IPC or shared memory or some other way to talk
14:50:35 <jrmithdobbs> i'm staring at it and still not understanding the typing problem :(
14:50:46 <Eduard_Munteanu> danilo2_: not necessarily, you could just use pipes (Handles) for example
14:51:06 <Eduard_Munteanu> danilo2_: e.g. spawn a totally external command and feed data into its stdin
14:51:35 <mauke> jrmithdobbs: what's the error message?
14:52:09 <jrmithdobbs> "Couldn't match expected type `MyType` \n\t\t\t\t with actual type `Maybe a0` \n\t In the expression: Nothing
14:52:21 <mauke> what's unclear about that?
14:52:33 <mauke> Nothing is not a valid value of MyType
14:52:33 <jrmithdobbs> the line that's generating it
14:52:46 <jrmithdobbs> right but it should be doing a case on a Maybe MyType
14:52:51 <mauke> it does
14:52:57 <danilo2_> Eduard_Munteanu: Ok, but I'm talking right now about realtime image processing. So If I want to display the images in realtime in the gui (f.e. 20 - 30 fps) I want to use the fastest method
14:53:15 <mauke> jrmithdobbs: your two cases return different types of values
14:53:49 <danilo2_> Eduard_Munteanu: do you think feeding data over stdin will be as fast as shared memory? Or maybe using 0mq over localhost would be optimized to work as fast as SM ?
14:55:01 <Eduard_Munteanu> danilo2_: do you need to transfer data to the GUI, apart from the preview? If not you could just let the Haskell code draw directly to a X window or GL buffer.
14:56:04 <danilo2_> Eduard_Munteanu: I want to be able to draw it as preview but I would love a solution, which would (in the future) easly extensible in such way, that image processing will be on server and GUI will bu run locally
14:56:32 <Eduard_Munteanu> danilo2_: er, is that over a network?
14:56:36 <jrmithdobbs> mauke: so how should I properly handle that?
14:56:47 <mauke> jrmithdobbs: first you need to figure out what you're trying to do
14:57:10 <jonkri> I can add acidic functions to an acid-state application without worrying about corrupting the database, right? (Keeping the types and previous functions as they are.)
14:57:10 <danilo2_> Eduard_Munteanu: GUI is written in C++ and QtQucik - I know I can draw to X window, but I want this solution to be cross-platform (win,mac,lin, maybe android etc)
14:58:25 <Eduard_Munteanu> danilo2_: I'm not sure I understand, what does "server" mean in this case?
14:58:39 <danilo2_> Eduard_Munteanu: No it is not - it is run on single computer, but I plan it COULD be run over network in the future (this information is right now not very improtant - I'm looking for single machine solution)
14:58:53 <jrmithdobbs> oic, I shouldn't unwrap until i'm actually doing something with it, derr
14:59:16 <jrmithdobbs> now I understand the confusion, I was quite literally trying to do something that didn't make sense
14:59:28 <jrmithdobbs> on the other hand: case decode t :: (Maybe AINetwork) of Just x -> print x ; Nothing -> return ()
14:59:32 <jrmithdobbs> makes PERFECT sense
14:59:33 <danilo2_> Eduard_Munteanu: I'm sorry :) Right now server is Haskell process, which prcess images and client is GUI which displays the results. Both are run on single computer, but in the future
14:59:42 <danilo2_> Eduard_Munteanu: they could be split - if user wish to
14:59:53 <Eduard_Munteanu> danilo2_: then there are quite a few ways you could do that. Even with a pipe, if you can splice() stuff to it, it's practically as good as shared memory.
15:01:23 <danilo2_> Eduard_Munteanu: Ok :) If pipes would be as fast as shared memory I'm very very happy. That would mean, I can use 0mq (because it uses simple sockets and pipes in unix when run on localhost)
15:02:09 <danilo2_> Eduard_Munteanu: So I can use "pipes", what are the other ways? I would love to benchmark and check them :)
15:02:36 <donri> 0mq? needs moar nanomsg
15:03:13 <Eduard_Munteanu> danilo2_: POSIX shared memory... you should look up IPC mechanisms for various OSes
15:04:02 <danilo2_> donri: excuse me?
15:04:46 <Eduard_Munteanu> danilo2_: note drawing to a mapped GL buffer should be easy to generalize
15:04:53 <danilo2_> Eduard_Munteanu: Do you mean - different mechanisms based on OS? I suppose we cannot use Posix SM on Windows?
15:05:05 <Eduard_Munteanu> danilo2_: you're not really stuck to GL, because you're just drawing into an arbitrary buffer.
15:05:17 * hackagebot digestive-functors-scotty 0.1.1.0 - Scotty backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-scotty-0.1.1.0 (MartinsMacs)
15:05:22 <Eduard_Munteanu> danilo2_: dunno about Windows
15:06:37 <moops> you could use sockets
15:07:03 <moops> might be overkill
15:07:20 <Eduard_Munteanu> I think most options should be workable, especially on Linux when you've got ways to do zero-copy splices.
15:08:35 <Eduard_Munteanu> AFAICT you're not concerned about latency, which would be the main issue with separate processes due to context switching.
15:09:49 <donri> danilo2_: it's the shiny new thing
15:09:52 <Eduard_Munteanu> (and which would be more significant if your application involved a lot of short messages between the two components)
15:15:09 <danilo2_> donri: ahh I see - I'll look into the nanomsgs, thank you! :)
15:15:53 <danilo2_> Eduard_Munteanu: Hmm, maybe you're right that context switching will be hard here, but If I'm sending only images previewws and images are big, then maybe it will not disturb so much
15:16:30 <carter> benchmark to find out
15:17:14 <danilo2_> Eduard_Munteanu: Could you please tell me a little more about drawing to OGL buffer from Haskell? I've never used it in Haskell and I do not know where to start to be honest
15:17:15 <danilo2_> carter: I plan to :)
15:17:15 <chrisdone> then benchmark the benchmarks
15:18:10 <carter> to optimize my benchmarks i run them in /dev/null
15:19:21 <Flonk> Can I pass a Type Constructor around as a Type Variable somehow?
15:19:49 <darthdeus> hey guys, what's a good way of profiling some simple haskell code?
15:20:10 <chrisdone> http://book.realworldhaskell.org/read/profiling-and-optimization.html
15:20:12 <darthdeus> i have about 6 functions in one module, ntohing huge, but it performs really poorly, so i wanna find out why :P
15:20:17 <darthdeus> cool thanks
15:20:42 <carter> criterion is great for benchmarking too
15:20:49 <carter> but profiling is its own beast
15:20:57 <carter> chrisdone: i hope the peter wortman stuff lands in 7.10
15:21:04 <carter> then we could have a sampling profiler!
15:21:29 <carter> and that would mean profiled optimized code could behave the same as optmized but unprofiled code
15:21:32 <chrisdone> that would be nice
15:21:36 <carter> 'cause inilning and stuff
15:21:39 <Ezner> Question, is there any function that goes like this: a -> a#? Could unsafeCoerce do that?
15:21:45 <carter> yes
15:21:47 <carter> but you dont want to :)
15:21:56 <carter> i wrote something related as a gag
15:22:16 <carter> Ezner: ooooo, od you just want to unwrap Int to Int#?
15:22:19 <carter> but why?
15:22:19 <chrisdone> hmm, perhaps there is a safe way to do that?
15:22:37 <carter> safe way to do which?
15:22:37 <carter> yes
15:22:51 <carter> you pattern mach on I# or W#
15:22:53 <carter> https://gist.github.com/cartazio/c0b0f624ff0ba7489085
15:22:59 <carter> shows pattern matching
15:23:01 <carter> and then evil
15:23:14 <carter> works "right" when compiled, makes ghci crash ALWAYS
15:23:19 <chrisdone> right, pattern matching is the only way that makes sense
15:23:21 <djahandarie> carter, who is peter wortman?
15:23:30 <carter> some grad student
15:23:48 <djahandarie> Could you provide me with a link to his work? Haven't heard of this at all.
15:23:53 <carter> https://github.com/scpmw
15:24:05 <djahandarie> Thanks.
15:24:32 <djahandarie> (It's funny how the extra 'n' totally changes the Google results...)
15:24:40 <bgamari> Could someone give me a hint for implementing (>>=) for Monad CTree here, http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
15:25:07 <bgamari> It seems to me that I'd need a value of (a -> Tree r) in bind
15:25:12 <Ezner> carter: I want to do it because I'm trying to parse a file and reading some ints, but I think that the laziness of ByteString works better than reading the file directly to some type a#
15:25:16 <bgamari> but I only have a value of type (b -> Tree r)
15:25:21 <chrisdone> @seen ManateeLazyCat
15:25:22 <lambdabot> /\/\AnaTee1azYcaT
15:25:24 <carter> Ezner: …. no
15:26:04 <Ezner> carter: hmm ok, I wanted to test that after this step but you suggest I just rewrite my program completely?
15:26:14 <carter> if you want strictness
15:26:20 <chrisdone> haven't seen ManateeLazyCat in ages
15:26:22 <carter> use bang patterns or strict data types
15:26:59 <Ezner> Already use them but there's loads of mathematical operations and I think it can be faster with unboxed
15:27:40 <Ezner> sorry, not unboxed, I mean primitive types
15:28:25 <chrisdone> if your program's suitably strict then ghc reliably realises that and unboxes
15:28:30 <carter> yeah
15:28:31 <danilo2_> Eduard_Munteanu, donri : thank you for the help :)
15:29:00 <carter> Ezner: unless your complaint is "my code isn't as fast as hand tuned assembly", using the unlifted types wont help
15:29:26 <danilo2_> Btw - does anybody use repa? I've got a problem - I want to read r g and b values of an image and I've found an example, which uses "let (arrRed, arrGreen, arrBlue) = U.unzip3 v"
15:29:31 <Ezner> carter: I can write 3 lines of assembly and that's about it so, don't know
15:29:57 <danilo2_> it works if "v" is array optained from "readImageFromBMP", because it has type of "Array F DIM3 Word8"
15:30:09 <Ezner> the only thing I do know is that the fastness is so important that I'm willing in spending time on trying other solutions
15:30:17 <carter> Ezner: what are you doing?
15:30:43 <danilo2_> but it does not work If we use repas devIL bindings, because then the array has type of "Array F DIM3 Word8" (sorry, the prevous type shoudl be "Array U DIM3 Word8"). Can we convert between them somehow?
15:30:44 <Ezner> carter: something big in graph theory
15:30:51 <carter> thats vague
15:31:07 <carter> Ezner: do you understand how to make data types with a strict field?
15:31:48 <Ezner> carter: input files can be around 100mb, I need to parse them and select the best on some quality metric, and that quality metric needs to be recalculated every time the best one is selected
15:31:53 <Ezner> Yes I do
15:32:20 <carter> are you using those?
15:32:41 <carter> Ezner: what math are you doing
15:32:47 <carter> your'e being kinda vague
15:33:02 <carter> and what parser tool are you using?
15:33:05 <augustss> Ship ahoy!
15:33:14 <carter> if you want it to be fast, you'd better use attoparsec prolly
15:33:15 <carter> augustss: oh?
15:33:26 <augustss> Well, I'm on a ship.
15:33:29 <carter> cool
15:33:31 <carter> with DATA
15:33:48 <augustss> Yes, Inmarsat.
15:33:49 <xico> what is a good way to get a pointer to an internal element in a c struct? my c struct is "struct A { ... ; struct B; }". i have a Ptr to an A, and want a Ptr to the B inside.
15:33:56 <Ezner> carter: Can be everything, the question is which quality metric is best, so I need to try different things. For now only + and *, but it will be extended to ^, / and possibly log
15:34:10 <carter>  Ezner  thats really vague
15:34:15 <carter> you're not describing what your'e doing
15:35:17 <Ezner> carter: because it depends. For example I now have 3 things: A, B, C. A depends on the successors, B on the predecessors and C is known. So A = sum {..}, B=sum{..} and Q=A*B*C
15:35:40 <carter> xico: define a storable instance
15:35:41 <Ezner> carter: but I'm planning on using something like PageRank and that's completely different that this
15:36:43 <Ezner> carter: the parsing is not that important, for now it takes less than 5% of time so I'm not focussing on that. I didn't use any library because it's very simple parsing and pattern matching works better, at least that's what my teacher told me long time ago
15:37:14 <xico> carter: i do have a storable instance, which allows me to go from Ptr A -> A or Ptr B -> B. i want to go from Ptr A -> Ptr B
15:37:56 <xico> (B being a struct, not a pointer to struct, inside A)
15:38:08 <mauke> xico: time for hsc2hs?
15:38:10 <carter> ummm, fix your data model so you can have iteher
15:38:17 <carter> Ezner: so whats the problem?
15:38:45 <xico> mauke: that's indeed the tool i use.
15:38:47 <Ezner> carter: it needs to be as fast as possible, not a real problem
15:39:08 <Ezner> So I'm trying do implement the trics I find online and one of them is with #
15:39:26 <mauke> xico: so you have #offset
15:40:45 <xico> mauke: sounds about right. just need to get the hsc doc i guess :)
15:41:01 <danilo2_> Is it possible to convert  "Array F DIM3 Word8" to  "Array U DIM3 Word8"? (Repa, Haskell) I want simply to use  U.unzip3 on a variable of type "Array F ..."
15:41:20 <Eduard_Munteanu> What's a nice way to get fusion for my defined structures? Just rules, or some fusion combinator library, or perhaps some generics magic?
15:43:48 <xico> danilo2_: copyP?
15:47:13 <xico> (though you'd rather avoid the copy, U.zip3 is pretty trivial)
15:48:16 <danilo2_> xico: thank you, you're right - I'll make it by hand. I'm new to repa and the data types are not yet clear to me :)
15:57:30 <mzero> quick probe: Anyone here on OSX 10.9 (Mavericks) and still using Xcode 4?
16:00:45 <aristid> hmm i believe i upgraded my mac to xcode 5, but i'm not sure and too lazy to get that machine from downstairs right now
16:01:15 <danilo2_> xico: do you know repa? Do you know what would be the best way to convert "Array F DIM3 Word8" to "(Array U DIM2 Word8, Array U DIM2 Word8, Array U DIM2 Word8)" (this is something other than unzip function does)
16:01:34 <danilo2_> xico: Should I convert it to Array U or Array D in such case?
16:01:47 <mzero> aristid: that's somewhat the opposite situation - though I've got a script that makes stock GHC/HP work in that situation if you need it
16:03:58 <aristid> mzero: i might need it if i used that machine more than i do, switched most of my haskelling to my linux desktop :)
16:04:57 <mzero> https://gist.github.com/mzero/7245290  -- if you need it
16:05:19 <skypers> hey, I was wondering, is there any haskell meeting taking place in Paris?
16:05:24 * hackagebot Nomyx-Language 0.4.0 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.4.0 (CorentinDupont)
16:05:26 * hackagebot Nomyx 0.4.0 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.4.0 (CorentinDupont)
16:06:13 <radish> hello, quick question: I created a module X that imports qualified Y as Y and I want to access function Z from Y inside module W.  How come I can't put X.Y.Z inside W?
16:06:16 <xico> can i export a 'foreign import ccall "wrapper"' in a library?
16:06:37 <radish> I have to import qualified Y as Y inside W and then do Y.Z ...  why?
16:07:21 <joshcough> is there a Monad for Data.Map?
16:07:22 <skypers> 23:59 < xico> can i export a 'foreign import ccall "wrapper"' in a library?
16:07:28 <skypers> sure xico
16:07:29 <skypers> I do it
16:07:48 <aristid> mzero: that script is because clang's cpp behaves differently than gcc's cpp, right?
16:08:16 <prophile> joshcough: how would a Data.Map monad work?
16:08:58 <xico> skypers: thanks.
16:09:12 <joshcough> im not sure. are you suggesting i try to write it, and fail, and then have my answer?
16:09:50 <mauke> joshcough: or succeed
16:10:18 <mzero> aristid: yes
16:11:23 <prophile> joshcough: I think it should work
16:11:37 <aristid> mzero: i wonder how long it'll take for upstream ghc to contain a fix for this:)
16:11:46 <prophile> Data.Map k is essentially MaybeT ((->) k) I think
16:11:48 <prophile> which is a monad
16:12:02 <prophile> (in semantics at least, if not implementation)
16:12:03 <joshcough> i was assuming a naive toList, then bind, then fromList would work, at least for pairs.
16:12:22 <quchen> prophile: You can't write 'return' for Data.Map, as you would have to invent an index.
16:12:32 <joshcough> but yeah i need to think it through more
16:12:42 <mzero> aristid: it is in active work in GHC at the moment
16:12:46 <prophile> quchen: ah yes, Data.Map can't do total maps?
16:13:01 <quchen> I don't know what a total map is.
16:13:03 <joshcough> yeah i got into trouble trying to write return.
16:13:17 <prophile> quchen: a map which has a value for every key
16:13:32 <prophile> if you could create a map which returns the same value regardless of what index
16:13:36 <prophile> then you could implement pure/return
16:13:38 <radish> who here is for ? functioning like ' and _ ??
16:13:58 <quchen> prophile: But that has nothing to do with Data.Map.
16:14:28 <quchen> In fact that would be a very useless data type.
16:15:01 <mauke> instance Monad (Map ()) where
16:15:33 <quchen> mauke: That one could still be empty.
16:15:39 <Narvius> I'm proud of myself. I thought of using the Writer monad in a place where it makes sense to use it.
16:16:01 <prophile> mauke: maybe Maybe should be redefined as that :)
16:16:05 <triliyn> quchen: it would be a useless data value, but it could be a member of a type which also contains useful values
16:16:28 <quchen> ..?
16:16:35 <triliyn> The total map thing
16:16:53 <triliyn> Responding to <quchen> In fact that would be a very useless data type.
16:17:29 <quchen> "A Map that returns the same value regardless of what index" is pretty redundant. Instead you could use a plain value.
16:17:51 <radish> how come I can't do X.(
16:17:54 <prophile> quchen: it could be useful if it's part of the type
16:17:56 <radish> X.(Y.Z)
16:18:09 <triliyn> quchen: it's just as useful as const
16:18:10 <quchen> radish: Sure you can do that.
16:18:22 <chrisdotcode> hey guys, I'm gonna be offline and I'm leaving really soon; is there any quick way I can download haddock documentation for offline reading?
16:18:27 <triliyn> Or well, maybe not JUST as useful, because maps are not as widespread as functions
16:18:46 <radish> i mean for modules
16:18:49 <quchen> triliyn: It's isomorphic to a simple value, but encoded in a crazy way.
16:18:49 <triliyn> But it could be useful in the same way that const/(->) r pure is useful
16:19:23 <prophile> quchen: yes, but the suggestion is only that it's part of the type
16:19:27 <radish> trying to access a function Z inside a qualified Y inside an import X
16:19:39 <radish> X.Y.Z
16:19:50 <prophile> PossiblyTotalMap k v = Always v | NotAlways (Map k v)
16:19:58 <quchen> chrisdotcode: You can automatically generate documentation, enable it in your cabal.conf. It won't work after you've installed the library though.
16:20:11 <quchen> chrisdotcode: So the shortest path I can think of is reinstalling everything.
16:20:19 <quchen> (There may of course be better ways, but I don't know any.)
16:20:20 <mauke> radish: what's a "qualified Y"?
16:20:21 <chrisdotcode> quchen: yeah, that's what I was thinking; so I've cloned the source repos, and I can run haddock from there, correct?
16:20:30 <chrisdotcode> quchen: what flags do I need to enable in cabal.conf?
16:20:40 <quchen> chrisdotcode: There's one that mentions documentation
16:20:50 <chrisdotcode> quchen: can I find it in the man page?
16:21:05 <quchen> chrisdotcode: Just open the file, it has many settings commented out in it
16:22:29 <chrisdotcode> quchen: awesome, thank you :)
16:22:54 <quchen> chrisdotcode: While you're at it, it's also useful to enable automatic profiling compilation
16:23:03 <quchen> chrisdotcode: And shared libraries if you want to use that
16:23:10 <chrisdotcode> quchen: thank you :)
16:23:26 <quchen> (Note that the last two increase compilation time a lot.)
16:26:03 <ParahSail1n> is the package "integer-gmp" where Integer in prelude is define?
16:26:44 <geekosaur> sort of
16:26:59 <quchen> ParahSail1n: libraries/integer-gmp/GHC/Integer/Type.lhs
16:30:27 * hackagebot github-backup 1.20131101 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20131101 (JoeyHess)
16:44:45 <Eduard_Munteanu> > let strictify = map (foldr1 (*)) . tail . inits  in  strictify . scanl1 (+) $ [a,b,c]   -- where (*) = seq for clarity
16:44:46 <lambdabot>   [a,a * (a + b),a * ((a + b) * (a + b + c))]
16:45:39 <Eduard_Munteanu> My strictify earlier was wrong, but this seems to be a way to turn foldl into foldl' if you keep it around as a scanl.
16:45:42 <ParahSail1n> how would i make a primop to do atoi on a bytestring?
16:46:26 <ParahSail1n> attoparsec's "decimal" parser is a cpu bottleneck in my application
16:46:29 <hpc> ParahSail1n: you mean a foreign call?
16:47:00 <ParahSail1n> im not sure if ffi would be faster than native, what is the overhead on ffi calls
16:48:15 <quchen> Eduard_Munteanu: What's that code for? Looks horrifying
16:49:19 <Eduard_Munteanu> quchen: I was writing combinators for Streams, and I realized all the strict folds/scans aren't really necessary if you do that.
16:49:42 <hpc> ParahSail1n: so apparently you can actually define your own primops
16:49:53 <hpc> but that's overkill on the level of "i wish php could address arbitrary memory"
16:50:47 <Eduard_Munteanu> quchen: e.g. you can rewrite a "foldl' f z . take n" as a scan, and decide to strictify it later.
16:50:49 <hpc> if you /really/ want atoi, do a foreign call
16:50:52 <hpc> because that's what it is
16:51:22 <ParahSail1n> what is the overhead like on foreign calls?
16:51:43 <Eduard_Munteanu> foldl :: (s -> a -> s) -> a -> Stream a -> Foldl s; foldl f z as = Foldl (scanl f z as)
16:52:06 <Eduard_Munteanu> quchen: ^^ and the caller can strictify and apply the fold if they want to
16:52:08 <hpc> ParahSail1n: try it and profile
16:52:39 <quchen> Ah.
16:52:49 <hpc> there's also the ffi commentary on the ghc trac
16:52:51 <quchen> Still looks horrifying, but now I don't know how to object anymore :-P
16:53:26 <hpc> but really, the overhead on foreign calls is that now you have to deal with C
16:53:46 <hpc> and that's worse than any CPU time you eat up with string parsing
16:53:57 <ParahSail1n> thats what i was asking
16:54:07 <ParahSail1n> and thats why i ask about primops
16:54:28 <hpc> well, implementing atoi as a primop is flat-out the wrong thing to do
16:54:44 <hpc> write it as nice haskell
16:54:49 <ParahSail1n> not literally atoi is what i want
16:54:50 <hpc> and if it hurts, come back then
16:55:10 <ParahSail1n> i want something to fit into an attoparsec parser
16:55:33 <Eduard_Munteanu> quchen: strictify xs = map (foldr seq) as where Cons a as = inits xs   -- looks better I guess
16:55:47 <hpc> atoi is a very easy fold in parsec-y types
16:56:04 <ParahSail1n> hpc, yes, that is what "decimal" in attoparsec does
16:56:14 <hpc> so use that
16:56:22 <ParahSail1n> and i am saying that i profiled that and it was a cpu bottleneck
16:56:34 <Eduard_Munteanu> quchen: (note the foldr = foldr1 for streams)
16:56:47 <quchen> Eduard_Munteanu: Hm, I don't know your data structure, but wouldn't something like "takeWhile (`seq` True)" do as well?
16:57:02 <ParahSail1n> to the point where the python i wrote to do the same thing was actually faster, because it uses c stdlib atoi
16:57:12 <ParahSail1n> which just seems wrong
16:57:54 <Eduard_Munteanu> quchen: mmm, not sure.
16:58:37 <Eduard_Munteanu> quchen: I think it doesn't unless you also evaluate takeWhile's result in order
16:58:58 <Eduard_Munteanu> Or, hm, lemme think.
16:59:14 <quchen> I'm not sure what kind of "strict" you mean here.
16:59:19 <hpc> ParahSail1n: you're doing something else wrong; looking at the attoparsec source it's exactly the same algorithm as atoi
16:59:21 <quchen> It's some place between seq and deepseq it seems.
16:59:26 <hpc> http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/src/Data-Attoparsec-ByteString-Char8.html#decimal
16:59:29 <hpc> http://research.microsoft.com/en-us/um/redmond/projects/invisible/src/crt/atoi.c.htm
16:59:34 <ParahSail1n> hpc, do you want me to send you the .prof?
16:59:37 <Eduard_Munteanu> quchen: as strict as foldl' with respect to foldl
17:00:59 <Eduard_Munteanu> > (! 2) . takeWhile (`seq` True) $ [1, undefined, 3]
17:01:01 <lambdabot>   Couldn't match type `[a0]' with `GHC.Arr.Array i0 c0'
17:01:01 <lambdabot>  Expected type: [a0] ...
17:01:05 <Eduard_Munteanu> > (!! 2) . takeWhile (`seq` True) $ [1, undefined, 3]
17:01:07 <lambdabot>   *Exception: Prelude.undefined
17:01:17 <Eduard_Munteanu> > (!! 2) . takeWhile (`const` True) $ [1, undefined, 3]
17:01:18 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
17:01:18 <lambdabot>    arising from the literal `1...
17:01:26 <Eduard_Munteanu> Er.
17:01:31 <Eduard_Munteanu> > (!! 2) . takeWhile (const True) $ [1, undefined, 3]
17:01:32 <lambdabot>   3
17:03:08 <frx> Eduard_Munteanu how did that not evaluate undefined?
17:03:14 <Eduard_Munteanu> Hm, so basically   takeWhile (`seq` True) [a, ...]   is   a `seq` (a : takeWhile (`seq` True))
17:03:27 <quchen> > const True undefined -- frx
17:03:28 <lambdabot>   True
17:03:29 <Eduard_Munteanu> frx: const ignores the first argument
17:03:33 <Eduard_Munteanu> Er, second.
17:03:38 <frx> ah
17:03:44 <quchen> @src const
17:03:44 <lambdabot> const x _ = x
17:03:45 <Eduard_Munteanu> seq messed me up.
17:05:16 <quchen> Eduard_Munteanu: takeWhile (`seq` True) evaluates each list element to WHNF, up to the point you evaluate the list.
17:05:24 <Eduard_Munteanu> quchen: I think yours works and it's nicer, thanks. It just ties the elements to the list skeleton, no need to connect among themselves.
17:05:24 <quchen> So yes.
17:06:06 <Eduard_Munteanu> quchen: it would only fail when irrefutably matching the stream I suppose
17:08:03 <quchen> Hm, not sure about irrefutables here
17:09:07 <Eduard_Munteanu> > let ~(a, b) = undefined `seq` (1, 2) in a
17:09:08 <lambdabot>   *Exception: Prelude.undefined
17:09:35 <Eduard_Munteanu> I guess it still forces the spine.
17:10:32 <quchen> The spine you can force simply with "takeWhile (const True)".
17:11:34 <Eduard_Munteanu> quchen: no, I mean  seq a b  forces a even when matching b irrefutably, it seems.
17:12:57 <quchen> Eduard_Munteanu: Irrefutable patterns only apply to the construcors involved. In your example above, you requested the "a".
17:13:40 <quchen> Irrefutability just delays the pattern matching.
17:14:18 <quchen> When you request the "a", the expression "undefined `seq` ..." has to be evaluated of course, and then seq crashes.
17:14:19 <Eduard_Munteanu> quchen: indeed, but  a `seq` b  forces 'a' only when 'b' is forced, but if 'b' has deeper data and that alone is forced, then 'a' shouldn't be affected.
17:14:39 <chrisdone> huh, no?
17:14:51 <chrisdone> a `seq` b forces a  when (a `seq` b) is forced
17:14:54 <darthdeus> is there a way to see how many times is each function called and how long it takes? i got to this http://i.imgur.com/Vd0CovM.png but it doesn't really tell me anything
17:15:18 <Eduard_Munteanu> chrisdone: yes, and "forced" here means to WHNF.
17:15:20 <darthdeus> well it does, but i have no idea what CAF:sat_sWR is :\
17:15:28 <chrisdone> Eduard_Munteanu: yes
17:15:40 <quchen> darthdeus: Compile with -P instead of -p to get a few more columns in the statistic. One of them is how many times something was called I think.
17:15:58 <quchen> s/compile/run
17:16:18 <hpc> darthdeus: CAF means constant applicative form
17:16:23 <darthdeus> ha i was missing -auto-all in the compile step, now i get a lot more
17:16:34 <hpc> darthdeus: a typical example of a CAF would be a top-level declaration of an infinite list of fibs
17:16:44 <darthdeus> uhm
17:17:41 <darthdeus> -P and -auto-all made it much better :) thanks guys http://i.imgur.com/J5cuE86.png
17:17:42 <Eduard_Munteanu> chrisdone: I mean   let b = Just c in a `seq` b   shouldn't force 'a' if 'c' alone is forced.
17:17:50 <darthdeus> now i see the problem, i should memoize that call i guess :P
17:18:17 <chrisdone> Eduard_Munteanu: sure
17:19:13 <Eduard_Munteanu> chrisdone: so arguably  a `seq` (Con b)  should not force 'a' if we match on (Con b) *irrefutably*, no?
17:20:33 <chrisdone> Eduard_Munteanu: why would the `a' be forced by evaluating (Con b)?
17:20:33 <quchen> let ~(Con c) = a `seq` (Con b) in … -- this way?
17:21:05 <quchen> That should not force a, unless you use the "c" somewhere.
17:21:11 <Jesin> Eduard_Munteanu: that doesn't sound correct.
17:21:13 <Jesin> Eduard_Munteanu: care to explain your reasoning?  I just came in.
17:21:26 <chrisdone> yeah, in your example, c is now in scope as (case a `seq` Con b of Con c -> c)
17:21:55 <chrisdone> so forcing c must force a
17:22:20 <Eduard_Munteanu> > let ~(Just a) = undefined `seq` (Just 3) in a
17:22:22 <lambdabot>   *Exception: Prelude.undefined
17:22:39 <chrisdone> quchen: actually i don't think you need the ~ in a let
17:22:40 <quchen> That forces a.
17:22:43 <Jesin> Eduard_Munteanu: forcing "seq a b" for any b should force a
17:22:43 <Jesin> and then evaluate to b
17:22:44 <chrisdone> a let is already irrefutable
17:22:44 <Jesin> that is the definition of seq
17:22:54 <quchen> chrisdone: Is it?
17:23:01 <chrisdone> top-level declarations, lets, whereas are all irrefutable
17:23:03 <Eduard_Munteanu> Jesin: yes, but I'm not sure that counts as forcing 'b'
17:23:12 <quchen> chrisdone: I didn't know that.
17:23:12 <chrisdone> there are no alternate cases for them to match on
17:23:26 <quchen> Sure, but that doesn't make it irrefutable.
17:23:30 <chrisdone> (Just x,y) = (Nothing,())
17:23:31 <Eduard_Munteanu> chrisdone: er, why? When would '~' be needed then?
17:23:38 <chrisdone> this doesn't throw an exception when you run main, does it?
17:23:47 <chrisdone> it's only until you evaluate x or y that the pattern is forced
17:23:51 <chrisdone> i've read the spec on this while implementing fay
17:24:01 <chrisdone> Eduard_Munteanu: in a case alt
17:24:03 <Jesin> > let Just x = Nothing in 12
17:24:04 <lambdabot>   12
17:24:16 <chrisdone> Jesin: exactly
17:24:31 <Jesin> quchen: there's your proof
17:24:32 <chrisdone> > case Nothing of Just x -> ()
17:24:34 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
17:24:38 <chrisdone> > case Nothing of ~(Just x) -> ()
17:24:39 <lambdabot>   ()
17:24:55 <quchen> Hm, interesting.
17:24:57 <chrisdone> i can get you the spec page if you want, hold up
17:25:06 <Eduard_Munteanu> chrisdone: oh, I see... so an irrefutable pattern merely postpones forcing the constructor until the field is forced, right?
17:25:17 <Jesin> <Eduard_Munteanu> Jesin: yes, but I'm not sure that counts as forcing 'b'
17:25:26 <Jesin> how wouldn't it?
17:25:35 <quchen> Eduard_Munteanu: Yes. You're basically promising that the data constructor you're matching as *will* be there.
17:26:07 <chrisdone> http://www.haskell.org/onlinereport/exps.html#sect3.12
17:26:15 <Eduard_Munteanu> Actually, I suppose the compiler has to force it, it wouldn't make sense otherwise, unless such patterns were unsafe.
17:26:24 <Jesin> Eduard_Munteanu: if you force evaluation of "seq a b" to WHNF, and the evaluation of "a" terminates, then you're left with the expression being equivalent to "b"
17:26:27 <chrisdone> that section's very helpful, it also has a translation explanation
17:26:49 <quchen> Neat
17:26:56 <Jesin> Eduard_Munteanu: since "seq a b" is now equivalent to "b", forcing "seq a b" to evaluate to WHNF must necessarily force b to WHNF
17:27:03 <Jesin> Eduard_Munteanu: make sense?
17:27:06 <quchen> I've read that section multiple times, but I've never noticed the "irrefutable" part
17:27:21 <chrisdone> yeah
17:27:36 <Eduard_Munteanu> Jesin: yes, I know, I was confused by forcing something that's behind an irrefutably-matched constructor.
17:28:22 <Jesin> > let Just x = Nothing in 12
17:28:23 <lambdabot>   12
17:28:25 <Eduard_Munteanu> Jesin: like whether 'a' is forced in   a `seq` Con b    where 'b' is forced somewhere else
17:28:32 <Jesin> > let Just x = Nothing in seq x 12
17:28:33 <lambdabot>   *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Da...
17:28:55 <quchen> Eduard_Munteanu: a and b are not connected in any way when you write "seq a b" somewhere else in your code.
17:29:20 <Jesin> Eduard_Munteanu: you can't include "seq" in a pattern-match and have it refer to Prelude.seq
17:29:38 <Jesin> Eduard_Munteanu: so "Con b" in that expression can't be a pattern-match
17:29:53 <Eduard_Munteanu> Jesin: it isn't
17:30:25 <quchen> let Con c = a `seq` Con b in b -- Doesn't force a.
17:30:45 <Jesin> > seq (let Just x = Nothing in 12) 88
17:30:47 <lambdabot>   88
17:30:50 <Jesin> erm, I meant
17:31:04 <Jesin> > seq (let Just x = Nothing in Just (seq x x)) 88
17:31:06 <lambdabot>   88
17:31:14 <Eduard_Munteanu> > let Just c = a `seq` Just b in b
17:31:16 <lambdabot>   b
17:31:21 <Eduard_Munteanu> > let Just c = undefined `seq` Just b in b
17:31:23 <lambdabot>   b
17:31:36 <Eduard_Munteanu> Oh, yeah, I missed the extra constructor.
17:31:45 <Jesin> > let Just c = undefined `seq` Just b in c
17:31:47 <lambdabot>   *Exception: Prelude.undefined
17:32:07 <frx> @src replicateM
17:32:07 <lambdabot> replicateM n x = sequence (replicate n x)
17:32:23 <Eduard_Munteanu> Can I simply say irrefutable patterns provide newtype-like semantics with respect to evaluation?
17:32:50 <quchen> I don't understand that sentence.
17:33:00 <Jesin> hmm
17:33:02 <Jesin> :t Identity
17:33:03 <lambdabot> a -> Identity a
17:33:04 <quchen> "Newtype-like semantics" means "like data but operationally id".
17:33:08 <quchen> … to me
17:34:04 <Eduard_Munteanu> quchen: newtypes don't introduce extra bottoms, NewtypeCon undefined = undefined
17:35:00 <Eduard_Munteanu> quchen: so basically I was concluding that irrefutable patterns make the matched constructor behave as if it was a newtype constructor.
17:35:02 <chrisdone> Eduard_Munteanu: i think i have a reasonable semantic transformation you can do
17:35:22 <Jesin> > (\~(Just x) -> seq x 11) (Just undefined)
17:35:23 <lambdabot>   <hint>:1:13: parse error on input `->'
17:35:31 <Eduard_Munteanu> chrisdone: oh... ?
17:35:38 <Jesin> > (\ ~(Just x) -> seq x 11) (Just undefined)
17:35:40 <lambdabot>   *Exception: Prelude.undefined
17:36:21 <Jesin> > (\ ~x@(Just _) -> seq x 11) (Just undefined)
17:36:22 <lambdabot>   11
17:36:34 <mm_freak> ocharles: with no further feedback i'm about to release netwire 5…  if there are any changes you'd like me to do, please highlight me in the next 24 hours, otherwise they may end up in 5.0.1 =)
17:36:49 <chrisdone> (case foo of ~(x,y,z) → …)
17:36:49 <chrisdone> is equivalent to
17:36:49 <chrisdone> (\x y z -> …) (case foo -> (x,_,_) -> x)
17:36:49 <chrisdone>               (case foo -> (_,y,_) -> y)
17:36:53 <chrisdone>               (case foo -> (_,_,z) -> z)
17:36:56 <chrisdone> i think
17:36:59 <Jesin> > (\ ~x@(Identity _) -> seq x 11) (Identity undefined)
17:37:01 <lambdabot>   *Exception: Prelude.undefined
17:37:07 <Jesin> > (\ ~x@(Just _) -> seq x 11) (Just undefined)
17:37:09 <lambdabot>   11
17:37:09 <chrisdone> i mean, if you were to compile the former, i think the core would resemble the latter (but i'd have to check)
17:37:32 <Jesin> Eduard_Munteanu: "Identity" is a newtype constructor while "Just" is a data constructor
17:37:33 <Eduard_Munteanu> chrisdone: hm, makes sense.
17:37:35 <chrisdone> given that all haskell compiles down to case statements and lambdas, i figure that's a good thing to translate to
17:37:35 <Jesin> There
17:37:39 <Jesin> is your difference
17:38:19 <mm_freak> chrisdone: i can't make sense of what you wrote
17:38:31 <mm_freak> 'case' separates sums, not products
17:38:46 <Jesin> > ( (\ ~x@(Just _) -> seq x 11) (Just undefined),  (\ ~x@(Just _) -> seq x 11) (Just undefined) )
17:38:48 <lambdabot>   (11,11)
17:38:54 <Jesin> ...
17:38:55 <Eduard_Munteanu> Jesin: mm, not sure it's what I had in mind
17:38:59 <mm_freak> chrisdone: ah, that's what you did…  nevermind =)
17:39:05 <Jesin> > ( (\ ~x@(Just _) -> seq x 11) (Just undefined),  (\ ~x@(Identity _) -> seq x 11) (Identity undefined) )
17:39:07 <lambdabot>   (11,*Exception: Prelude.undefined
17:39:13 <Jesin> There we go.
17:39:37 <Eduard_Munteanu> > let ~(Just a) = undefined `seq` (Just 5) in a   -- Jesin
17:39:38 <lambdabot>   *Exception: Prelude.undefined
17:40:08 <Eduard_Munteanu> > let ~(Identity id) = undefined `seq` (Identity id) in id a   -- Jesin
17:40:09 <lambdabot>   *Exception: Prelude.undefined
17:40:12 <Jesin> Eduard_Munteanu: well yes, that's because you forced "a"
17:40:15 <mm_freak> type Either e a = forall r. (e -> r) -> (a -> r) -> r
17:40:16 <chrisdone> Eduard_Munteanu: curious, what was the original topic you brought up about the irrefutable patterns and seq?
17:40:32 <mm_freak> type Times a b = forall r. (a -> b -> r) -> r
17:40:51 <mm_freak> a `Times` b ~ (a, b)
17:41:03 <Jesin> Eduard_Munteanu: you're being confusing with your reassignment of "id"
17:41:30 <Jesin> > let ~(Identity id2) = undefined `seq` (Identity id) in id2 a   -- Eduard_Munteanu
17:41:32 <lambdabot>   *Exception: Prelude.undefined
17:41:50 <Eduard_Munteanu> chrisdone: I posted a combinator that turns a left scan into a strict left scan, like [a, a `seq` b, a `seq` (b `seq` c)]. And quchen suggested using takeWhile (`seq` True) instead.
17:41:51 <Jesin> actually I'm not entirely sure that's even the same expression when you remove the "undefined `seq`"
17:42:11 <Eduard_Munteanu> chrisdone: and I was worried matching the stream irrefutably would ignore the strictness.
17:42:27 <Eduard_Munteanu> It is a Stream, not a list.
17:42:54 <chrisdone> stream as in a list without a nil?
17:42:54 <Jesin> takeWhile (`seq` True) should work
17:43:01 <Eduard_Munteanu> chrisdone: (because his variant ties evaluation to the spine, rather than among the elements themselves)
17:43:04 <Eduard_Munteanu> chrisdone: yes
17:43:10 <Eduard_Munteanu> Jesin: yeah, I can see that now.
17:43:41 <Jesin> Eduard_Munteanu: in fact it doesn't even do any pattern-matching
17:43:44 <Jesin> well
17:43:45 <Eduard_Munteanu> Mine was basically  map (foldr seq) . tail . inits
17:43:49 <Jesin> any extra
17:43:53 <Jesin> @src takeWhile
17:43:53 <lambdabot> takeWhile _ []                 =  []
17:43:53 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
17:43:53 <lambdabot>                    | otherwise =  []
17:44:04 <Jesin> oh right
17:44:12 <Jesin> I guess the takeWhile for Streams could be irrefutable
17:44:54 <Eduard_Munteanu> takeWhile :: (a -> Bool) -> Stream a -> [a]   -- of course
17:44:54 <quchen> But why
17:45:25 <Eduard_Munteanu> Why not? I never understood why pattern-matching isn't always irrefutable.
17:45:41 <Jesin> Eduard_Munteanu: because then you couldn't use it for actual pattern-matching
17:45:48 <Jesin> as in, with multiple options
17:46:01 <Eduard_Munteanu> Jesin: I mean the cases when you only match a single constructor.
17:46:19 <Eduard_Munteanu> Either because the type provides just one, or because you wrote a partial function.
17:46:37 <Jesin> Eduard_Munteanu: that would require special-casing the syntax
17:46:39 <quchen> Eduard_Munteanu: That would make pattern matching a little odd. You could make the compiler add automatic ~ there, but then patterns would behave differently depending on how the data type looks like.
17:47:02 <quchen> In particular it would be painful to add new constructors to types that formerly only had one.
17:47:38 <Jesin> quchen: nah, you could accomplish it by adding "~" to functions and case-statements that only had one case
17:48:04 <Jesin> still it seems entirely unnecessary
17:48:25 <Eduard_Munteanu> Well, sure, but it's easy to see things would fail. I mean, implicit Eq when pattern matching is much much worse. :)
17:48:33 <Jesin> Eduard_Munteanu: you have to understand, too, that "~" would still have a place in the language
17:48:50 <Jesin> ... is it really?
17:49:07 <quchen> Implicit Eq only appears for numeric literals I think.
17:49:29 <Eduard_Munteanu> And string literals... char literals actually, I suppose.
17:49:32 <Jesin> and, well, doesn't Num already carry an Eq constraint?
17:49:46 <quchen> Jesin: No, not in GHC
17:49:52 <Eduard_Munteanu> Actually all literals?
17:49:59 <quchen> Jesin: Oh wait let me double-check that.
17:50:18 <quchen> Jesin: Yeah, Num doesn't have any parents.
17:50:34 <quchen> (The report demands it, but it was removed in GHC.)
17:50:36 <Jesin> Eduard_Munteanu: what exactly do you mean by "all literals"
17:50:42 <Eduard_Munteanu> Yes but equality checking can be much deeper than WHNF.
17:51:04 <Jesin> Eduard_Munteanu: Have you been bitten by this before, ever?
17:51:35 <Jesin> what "literals" are there besides numeric and Char?
17:51:45 <Eduard_Munteanu> Jesin: does the report distinguish cases for matching on literals? I mean any possible literals, even those introduced by extensions, would exhibit that behavior.
17:51:50 <Eduard_Munteanu> Jesin: Nat ?
17:52:02 <Jesin> Eduard_Munteanu: Nat has lazy equality
17:52:32 <Jesin> Eduard_Munteanu: and honestly if you're using numeric literals for Nat... you should already know to be careful with that.
17:54:17 <Eduard_Munteanu> Jesin: mm, I suspect matching on Nat equality depends on what your nats are, but it still does evaluate one of them fully, no?
17:54:42 <Jesin> Eduard_Munteanu: um.. yes?
17:54:51 <Eduard_Munteanu> Jesin: and no, I haven't been bitten, just wondering about this stuff
17:55:08 <frx> does this seem like a good type if someone wanted to implement C for-loop for whatever reason? for :: a -> (a -> Bool) -> (a -> a) -> (a -> IO ()) -> IO ()
17:55:14 <Jesin> Eduard_Munteanu: but on the other hand, that is literally the ONLY semantics for pattern-matching on numeric literals that makes any sense, so far as I can tell
17:55:58 <Eduard_Munteanu> Jesin: yeah, I know, it's pretty bad considering you can e.g. pass an expensive computation to a function which matches on the result with such a literal.
17:56:06 <Jesin> frx: should be for arbitrary monads
17:56:24 <Eduard_Munteanu> let f 42 = True in f expensive
17:56:29 <Jesin> Eduard_Munteanu: presumably if the function does that, it's because it has to
17:56:37 <frx> Jesin yes good point
17:57:09 <quchen> frx: 'until' and its monadic friends might be what you're looking for.
17:57:29 <frx> what about second and third argument? should they be (a -> Bool) and (a -> a) or (a -> IO Bool) and (a -> IO a)
17:57:31 <Jesin> Eduard_Munteanu: okay... Can you implement a function with those semantics WITHOUT evaluating "expensive"?
17:57:40 <quchen> @hackage monad-loops <- frx
17:57:40 <lambdabot> http://hackage.haskell.org/package/monad-loops <- frx
17:57:53 <frx> thanks I'll take a look
17:58:10 <Eduard_Munteanu> Jesin: no, I was just saying it's a bit sneaky
17:58:13 <Jesin> Eduard_Munteanu: keep in mind that has the same semantics as "let {f 42 = True; f _ = undefined} in f expensive"
17:58:24 <Eduard_Munteanu> Yeah.
17:58:55 <Jesin> Eduard_Munteanu: it doesn't seem *unintuitive* at all
17:59:39 <Eduard_Munteanu> Jesin: yes, but arguably if you're matching on multiple constructors, you should be aware they get forced, as well, no? :)
17:59:41 <vonDraco> is it always better to go with ((f.g.h) x ) instead of f(g(h(x))) ?
17:59:56 <quchen> vonDraco: Whatever is more readable. So most likely yes.
18:00:05 <Jesin> Eduard_Munteanu: if you're matching on constructors AT ALL you should be aware they get forced UNLESS you include "~"
18:00:09 <quchen> You can also write it as "f . g $ h x" though.
18:00:16 <frx> or even f . g . h $ x
18:00:22 <Jesin> OR unless you're doing the matching in a "let" or "where"
18:00:25 <ion> (f . g . h) x
18:00:40 <vonDraco> oh yeah, i fogot. but it has no impact on the execution of it?
18:00:51 <Eduard_Munteanu> Jesin: yes, but if '~' was implicit I'm not sure it would be surprising when you later extend the type
18:00:58 <Jesin> vonDraco: I would typically write f $ g $ h x
18:01:04 <quchen> Eww.
18:01:07 <ion> jesin: Vade retro
18:01:15 <chrisdone> vonDraco: likely they will compile to the same thing, most of the time. if you have some code where it really matters, you can check the core
18:01:20 <Jesin> Eduard_Munteanu: no, but it would be pretty damn surprising when you REMOVED all but one pattern-match
18:01:24 <vonDraco> that actually looks nice.
18:01:45 <Jesin> meh
18:02:01 * chrisdone would write f (g (h x))
18:02:13 <Eduard_Munteanu> frx: you could pass in a continuation so you can break the loop
18:02:14 <vonDraco> i don't like using so many parenthesis >_>
18:02:26 <Jesin> I suppose surprise is subjective.  Eduard_Munteanu: What advantage do you expect implicit '~' to grant?
18:02:27 <frx> I like f . g . h $ x because function composition stands out
18:02:46 <mm_freak> i like (f . g . h) x because function composition stands out
18:02:56 <mm_freak> but sometimes i go with ($) as well =)
18:03:04 * frx high fives
18:03:12 <Jesin> it's pretty obviously composition either way
18:03:18 <Eduard_Munteanu> Jesin: I think it's natural to make Haskell as non-strict as possible, semantically
18:03:19 <chrisdone> i don't find that seeing function composition helps more than parens when it's not point-free
18:03:44 <Jesin> @src head
18:03:44 <lambdabot> head (x:_) = x
18:03:44 <lambdabot> head []    = undefined
18:03:47 <mm_freak> i prefer not to apply a composition directly though
18:04:01 <mm_freak> if a function is a large composition, chances are you will benefit from giving it a name
18:04:04 <chrisdone> in fact it's often just weird because you have a load of function application and then randomly someone thinks they'll be clever and write (f . g x . z $ x)
18:04:28 <mm_freak> chrisdone: what's wrong/clever about that?
18:04:42 <joelteon> > head []
18:04:43 <Jesin> chrisdone: that can be written equally well as " f $ g x $ z x "
18:04:43 <lambdabot>   *Exception: Prelude.head: empty list
18:04:51 <mm_freak> Jesin: that's terrible
18:04:52 <Eduard_Munteanu> Jesin: in some contrived cases like "expensive `seq` Con ignored", merely matching Con would make expensive get forced.
18:04:53 <joelteon> lambdabot lies
18:04:55 <chrisdone> Jesin: yes it can
18:04:56 <ion> vondraco: baz x = (f . g . h) x presents the option to eta-reduce clearly (baz = f . g . h), and when refactoring, you can give a name to a part of the expression easily. E.g. “baz = f . quux; quux = g . h”. That won’t work with $ abuse.
18:05:05 <quchen> f S g x S z x -- UGH
18:05:05 <Jesin> mm_freak: how so?
18:05:06 <frx> . is less noisy than $, pixel wise
18:05:09 <mm_freak> Jesin: and also wrong
18:05:12 <Eduard_Munteanu> Jesin: or not just ignored, but merely not needed right now
18:05:15 <Shin-LaC> why can I do (+ 1) 2 but not (- 1) 2 ?
18:05:17 <mm_freak> Jesin: no, it's not wrong
18:05:20 <mm_freak> but terrible =)
18:05:30 <chrisdone> mm_freak: it's wrong because it's out of place and not warranted, and clever because it's someone trying to "show the composition" to show off, even tho it's awkward
18:05:34 <quchen> Shin-LaC: https://github.com/quchen/articles/blob/master/fbut.md#--4-is-not-x---x---4
18:05:39 <geekosaur> Shin-LaC, because (-1) is specialcased to be a numeric literal (for any literal number)
18:05:48 <mm_freak> Jesin: mainly because it's not compositional, but also because the symbol "$" is terrible
18:05:48 <geekosaur> it's one of the more annoying warts in the language
18:05:56 <ion> skin-lac: A controversial special case because you might want to write “-1” for negative one.
18:06:03 <Shin-LaC> ah
18:06:04 <geekosaur> and no, the space doesn't affect parsing there
18:06:21 <Jesin> geekosaur: it isn't even "for any literal number"
18:06:24 <geekosaur> the Prelude even defines "subtract" as a cheap hackaround
18:06:25 <vonDraco> ioanel, yeah i see how that works, but in my case i was really in a position to eta reduce.
18:06:33 <Jesin> :t (- undefined)
18:06:33 <mm_freak> it's too letterlike…  "f $ x" almost looks like you're applying 'f' to two arguments
18:06:34 <lambdabot> Num a => a
18:06:48 <Jesin> :t (flip (-) undefined)
18:06:49 <lambdabot> Num c => c -> c
18:07:03 <monochrom> f `apply` x :)
18:07:28 <geekosaur> damn, it's even more annoying a wart than I remembered
18:07:30 <ion> `id`
18:07:41 <Eduard_Munteanu> My complaint is things like  g . f $ x  is so unlike  (g o f)(x)  from math, which for some reason I find more pleasant.
18:07:41 <Jesin> mm_freak: I tend to see the vertical bar that runs down the center of the '$' as a wall, when reading haskell.
18:07:44 <mm_freak> chrisdone: AFAIK you're not new to haskell, so you must have some deeper reasoning than "composition sux!"
18:07:54 <Jesin> geekosaur: that's because "(- x)" parses as "negate x"
18:08:00 <Jesin> which, imo, is terrible
18:08:01 <quchen> I reserve "$" mostly for some special functions that typically range over lots of things. Like "atomically $" instead of "atomically .".
18:08:13 <monochrom> I am fine with (g . f) x
18:08:14 <chrisdone> mm_freak: i didn't say composition sucks, i said such use is often out of place
18:08:16 <ion> ($) should be infixl.
18:08:18 <mm_freak> Jesin: PHP has made me immune to the symbolness of "$" =)
18:08:38 <Jesin> ion: really...
18:08:39 <mm_freak> chrisdone: well, i would write "print (sin x)"
18:08:41 <quchen> mm_freak: Numb, you mean :-S
18:08:42 <chrisdone> mm_freak: i don't see where reasoning has to do with this, though; we're talking about taste
18:08:52 <Shin-LaC> map fst . filter ((==0) . snd) . zip [0..] . binary $ i
18:08:52 <chrisdone> reason is the last thing on your mind when dealing with taste
18:08:54 <Shin-LaC> is this ugly?
18:09:07 <monochrom> guess what, I also write "print (sin x)" more often than "(print . sin) x" :)
18:09:09 <mm_freak> chrisdone: but with more than two functions cascaded i start to prefer composition
18:09:42 <mm_freak> but yeah, it's taste
18:09:45 <chrisdone> mm_freak: right -- print (sin x), or print $ sin x, good. but print . sin $ x is trying to be "oo composition" in a fetishy way but i see no benefit
18:09:59 <Jesin> Shin-LaC: I would prefer (0 ==) or (== 0) over (==0), but otherwise it's fine
18:10:22 <mm_freak> chrisdone: i don't like the latter though…  i don't view parentheses as evil as many other haskellers do
18:10:24 <monochrom> I am above hlint. I don't always write "(f . g) x", and I don't always write "f (g x)". I don't know what hlint does, but it's a deterministic program, it must pick one and stick to it, and whatever it picks must offend me :)
18:10:29 <frx> chrisdone sure, but example was 3 function calls deep. f (g (h x)) is just ugly, IMO. the least readable one
18:10:36 <Jesin> chrisdone: I think some of that is due to the fact that "print" doesn't feel like a mathematical function
18:10:37 <chrisdone> mm_freak: i use parentheses for everything
18:10:40 <mm_freak> in particular you start to love parentheses when you revisit old code after a long time
18:10:52 <mm_freak> and you start to hate ($)
18:10:53 <chrisdone> frx: depends, lispers would say the parentheses the most readable
18:11:11 <mm_freak> that's why i use ($) as seldomly as possible
18:11:37 <chrisdone> when i'm making a choice, and not just typing mindlessly, i only use $ for control structures
18:11:42 <chrisdone> forkIO $ do
18:11:42 <chrisdone>  etc
18:11:49 <mm_freak> indeed, that's about my style as well
18:11:56 <ion> I wish “forkIO do …” worked.
18:12:12 <mm_freak> ($) is good for introducing an indented block
18:12:14 <chrisdone> mostly because parentheses in haskell are annoying to edit in most editors
18:12:17 <quchen> ion: That would finally allow us to write "don't do" as well.
18:12:43 <darthdeus> what's an easiest way to sort a string?
18:12:46 * Eduard_Munteanu wants "od"
18:12:47 <ion> Also: foo \x -> …
18:12:47 <chrisdone> mm_freak: in my personal never-see-the-light-o'-day code i've experimented with
18:12:47 <chrisdone> forkIO (do …
18:12:48 <chrisdone>            …)
18:12:50 <quchen> darthdeus: "sort".
18:12:53 <Rembane> darthdeus: sort
18:12:54 <ion> darthdeus: sort string
18:12:55 <quchen> > sort "hello world"
18:12:56 <monochrom> > sort "a string"
18:12:56 <darthdeus> quchen: that requires a sequence
18:12:57 <lambdabot>   " dehllloorw"
18:12:58 <lambdabot>   " aginrst"
18:13:09 <mm_freak> chrisdone: as you pointed out, that's too annoying to edit
18:13:21 <darthdeus> oh shit, I'm using Data.Sequence.sort and not Data.List.sort
18:13:32 <darthdeus> that explains it :D
18:13:38 <Eduard_Munteanu> niam :: OI (); niam = od  ...
18:13:43 <mm_freak> chrisdone: arrow notation forces you to use it to some extent, so i'm no stranger to that style
18:13:48 <Jesin> darthdeus: I really like GHC's implementation of Data.List.sort by the way
18:13:48 <darthdeus> sorry for being dumb
18:13:59 <chrisdone> mm_freak: yep. at least, it was. with my structured editing minor mode in emacs, it's actually very pleasant to work with
18:13:59 <chrisdone> mm_freak: but if i'm the only one who has that mode, it's putting an editing burden on everyone else
18:14:22 <quchen> Eduard_Munteanu: Maybe call it "odd".
18:14:29 <mm_freak> chrisdone: if your mode can be downloaded from somewhere, i might give it a shot =)
18:14:30 <Jesin> Honestly I think for sorting immutable singly-linked lists, there's probably no way to improve on that algorithm
18:14:30 <monochrom> but you should make everyone use your mode :)
18:14:34 <Eduard_Munteanu> odd-notation :)
18:14:43 <Jesin> If there is I'd be interested to see it
18:14:58 <quchen> Jesin: I don't understand that implementation much.
18:14:58 <ion> noitaton
18:15:12 <mm_freak> we already have don't notation =)
18:15:12 <Eduard_Munteanu> Wow, that's almost a palindrome.
18:15:14 <quchen> Eduard_Munteanu: {-# LANGUAGE ODD #-}
18:15:15 <mm_freak> @hackage acme-dont
18:15:15 <lambdabot> http://hackage.haskell.org/package/acme-dont
18:15:15 <quchen> :-D
18:15:18 <monochrom> human society is non-ideal precisely because everyone thinks, "if I do the ideal thing, it's incompatible with other people"
18:15:38 <monochrom> break the extended prisoner dilemma! do the ideal thing!
18:15:57 <mm_freak> monochrom: so everyone should use SHE?
18:15:58 <ion> It’s sad the word for palindrome isn’t a palindrome.
18:16:15 <Shin-LaC> at least the word for word is a word
18:16:22 <chrisdone> monochrom: yeah
18:16:49 <djahandarie> It's unfortunately that it doesn't handle  don't (don't $ do ...)
18:16:52 <djahandarie> unfortunate*
18:16:54 <Eduard_Munteanu> Yeah, like Benoit B. Mandelbrot has such a fitting name.
18:17:02 <chrisdone> ion: like 'lisp' involves the letter which people affected with a lisp cannot say
18:17:07 <quchen> I'm so meta even this acronym.
18:17:38 <ski> Eduard_Munteanu : for comonads ?
18:17:55 <Eduard_Munteanu> ski: yeah
18:18:23 <Eduard_Munteanu> ski: it's not very useful though
18:18:37 <ski> `od' or `OI' ?
18:18:47 <Eduard_Munteanu> ski: both :(
18:18:52 <quchen> We *need* the OI Monad.
18:18:59 <quchen> Someone invent a package that uses it.
18:19:00 <ion> OI Guvnor
18:19:01 <ski> monad ?
18:19:15 <chrisdone> result =
18:19:15 <chrisdone>   execParserPure (prefs idm)
18:19:15 <chrisdone>                  (info (helper <*> cfg)
18:19:15 <chrisdone>                        (fullDesc <> progDesc desc <> header name))
18:19:19 <chrisdone> ^ here's some random code. it's parens heavy, but just like in lisp, the rules are simple and regular. i suspect if someone here wrote it, it would have some $'s in it
18:19:28 <quchen> Paging edwardk to rename Comonad to Danom
18:19:39 <ski> Eduard_Munteanu : some kind of `od' thing (though probably not expressed like that) could be useful
18:20:01 <quchen> chrisdone: Looks like lisp but with sane syntax.
18:20:01 <mm_freak> chrisdone: except that i break the line after "execParserPure" and indent the next line by four spaces, i would have written it exactly like that
18:20:05 <chrisdone> Danom et Dionom
18:20:11 <mm_freak> execParserPure
18:20:14 <mm_freak>     (prefs idm)
18:20:15 <Eduard_Munteanu> quchen: like the French say Etats :P
18:20:16 <mm_freak>     …
18:20:31 <Eduard_Munteanu> Were they thinking of the Store comonad? :)
18:20:39 <chrisdone> mm_freak: you would break on `execParserPure' but not `info'?
18:20:50 <mm_freak> chrisdone: and it's wrong to say "would have", because i have working code in exactly that style, except that i don't use execParserPure =)
18:20:57 <mm_freak> chrisdone: exactly
18:21:07 <chrisdone> mm_freak: why? seems arbitrary
18:21:13 <mm_freak> chrisdone: it is
18:21:25 <ski> also, i've pondered a syntax where `<expr 0> @\<expr pat> -> <expr 1>' desugars to `<expr 0> <expr pat> (\<expr pat> -> <expr 1>)'
18:21:47 <quchen> That's line noise.
18:21:49 * Eduard_Munteanu has to go to sleep soon
18:21:58 <mm_freak> chrisdone: code layout is for humans, not machines, so sometimes arbitrarily choosing the subjectively best looking style is appropriate =)
18:22:07 <chrisdone> mm_freak: i would break and indent it, but only if the expression doesn't fit within 80 columns or a width i'm pleased with
18:22:08 <ski> it would make it nicer to write `(s,\s -> ..s..)' and `wa =>> \wa -> ..wa..' kind of things
18:22:10 <mm_freak> chrisdone: in fact, i don't like strict layout rules in coding guidelines
18:22:41 <mgsloan> Yeah, chrisdone's code is very lispy.  Sometimes it's beautiful, other times it's terrifying :)
18:22:55 <chrisdone> mgsloan knows =p
18:22:57 <mgsloan> Checkout the outline of this module: http://imgur.com/qveB90H
18:23:03 <ski> (namely, it'd be `(,) @\s -> ..s..' and `(=>>) @\wa -> ..wa..')
18:23:04 <chrisdone> mgsloan: you should find something scary
18:23:12 <mgsloan> chrisdone: Way ahead of you :)
18:23:16 <mm_freak> one company i worked for wanted me to stop aligning the equal signs for multiple equations
18:23:24 <mm_freak> reasoning: "some editors have trouble with that"
18:23:50 <mgsloan> My main gripe is it making version control a little bit less pleasant
18:23:51 <ski> chrisdone : i prefer using not much `$'s -- brackets aren't scary
18:23:59 <mgsloan> but otherwise I prefer the fancier layout
18:24:27 <ion> ski: Also, $ may obfuscate the code structure.
18:24:32 <mm_freak> mgsloan: your favorite version control tool allows you to specify the number of lines of context when displaying diffs =)
18:24:40 <ski> ion : aye
18:24:53 <mgsloan> So, it's actually a 3 step process: 1) Write a structural git merge for haskell 2) Get everyone to use it 3) Get everyone to use structured-haskell-mode
18:24:57 <chrisdone> mgsloan: that's probably the most pathological example, tho i've started intentionally reigning in code recently
18:25:08 <chrisdone> haha
18:25:10 <ion> 4) ???
18:25:15 <chrisdone> 5) profit!
18:25:25 <mm_freak> mgsloan: along the way, do it for darcs, too
18:25:30 <mm_freak> some people don't like git ;)
18:25:45 <quchen> Some people like git?
18:25:56 <mm_freak> quchen: ask edwardk ;)
18:25:57 <mgsloan> mm_freak: True, but the issue with these "dependent layouts" is that they cause a lot more code change.  E.g. a single rename can shift a bunch of lines
18:26:04 <ion> I like git’s data model and i tolerate its UI.
18:26:27 <darthdeus> if i have three infinite lists, xs, ys, zs ... what's the easiest way of merging them into a tuple like (x,y,z) ?
18:26:31 <mm_freak> ion: i don't like anything about git
18:26:40 <darthdeus> list comprehension seems to do combionations
18:26:42 <mm_freak> except perhaps that it's decentralized
18:26:47 <quchen> darthdeus: zip3
18:27:01 <ski> > [(x,y,z) | x <- [0 ..] | y <- [1 ..] | z <- [0,2 ..]]
18:27:02 <darthdeus> ha!
18:27:03 <lambdabot>   [(0,1,0),(1,2,2),(2,3,4),(3,4,6),(4,5,8),(5,6,10),(6,7,12),(7,8,14),(8,9,16...
18:27:05 <quchen> Or parallel list comprehensions.
18:27:16 <chrisdone> my use of structured-haskell-mode so far as gone like: (1) hm, this is neat, still writin' in my old style. stickin' within 80 columns… *month goes by* (2) hm, holy crap, all i need is parens. (3) I AM GOD OF EDITION, (4) oh, people use other editors? better start reigning it in a bit
18:27:19 <mm_freak> mgsloan: sure
18:27:21 <darthdeus> holy shit, this is perfect! :)
18:28:10 <mm_freak> darthdeus: i'd prefer zip3
18:28:18 <mm_freak> > zip3 [0..] [1..] [0,2..]
18:28:20 <lambdabot>   [(0,1,0),(1,2,2),(2,3,4),(3,4,6),(4,5,8),(5,6,10),(6,7,12),(7,8,14),(8,9,16...
18:28:34 <chrisdone> mgsloan: although i've realised that the same is true whenever you add a level of nesting =(
18:28:36 <ski> @type zipWith3
18:28:38 <mgsloan> I almost kinda wish that there wasn't so much thought that can go into style
18:28:38 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
18:28:40 <darthdeus> mm_freak: yeah that seems more reasonable :) but the other way is good too
18:29:13 <chrisdone> foo $ do
18:29:13 <chrisdone>   bar
18:29:13 <chrisdone> to
18:29:13 <chrisdone> foo bob bill $
18:29:16 <chrisdone>   bar $ do
18:29:19 <chrisdone>     …
18:29:21 <darthdeus> also, is there a way to do    a == b && b == c  for a (a,b,c) tuple?
18:29:27 <darthdeus> not sure how to hoogle that
18:29:35 <ski> there isn't
18:29:39 <mm_freak> mgsloan: there shouldn't be…  the only guideline should be:  write code you can read six months later
18:29:40 <mgsloan> chrisdone: Right, the problem of little changes causing big diffs is not exclusive to the fancy layout style
18:29:46 <ion> darthdeus: \(a,b,c) -> a == b && b == c
18:30:01 <mm_freak> don't adapt coding style to technology; adapt technology to coding style!
18:30:03 <darthdeus> ion: yeah, i thought there would be something like "equals3" :P
18:30:18 <ski> you can define it, if you want to
18:30:43 <mgsloan> mm_freak: Right!  That's what I stick to.  It's just a little bothersome that my haskell style has changed quite a few times in just a few years
18:30:51 * mgsloan --> dinner
18:31:23 <mm_freak> mgsloan: nothing wrong with that…  mine changed too, particularly after ($) bit me so hard that i had to rewrite pages of code =)
18:31:31 <quchen> Huh?
18:31:34 <quchen> How can that happen
18:31:39 * ski . o O ( `phrase(mgsloan,[ham,lettuce,boiled_potatoes])' )
18:31:50 <mm_freak> quchen: ($) is a hazard for revisiting old code, because it makes code flat
18:31:58 <darthdeus> uhm, this seems to be illegal syntax though, do i have to use a filter instead of a guard to do this? [(x,y,z) | x <- xs | y <- ys | z <- zs, x == y && y == z]
18:32:08 <quchen> mm_freak: "flat"? Hazard?
18:32:13 <mm_freak> quchen: at that point i started loving parentheses
18:32:21 <ski> darthdeus : or another list comprehension
18:32:57 <mm_freak> quchen: with ($)-heavy code you need quite a bit of brainpower to figure out what is applied to what
18:33:09 <ion> I wish source code existed as an AST (with possible layout hints) and editors/viewers generated the layout when rendering. That could also DTRT with any display, from cell phones to VT-100s to 30-inch 4k displays with proportional fonts.
18:33:22 <ski> darthdeus : `[...| (x,y,z) <- [(x,y,z) | x <- xs | y <- ys | z <- zs],x == y,y == z]' -- somewhat ugly, yes
18:33:27 <quchen> mm_freak: Hm, I don't see the problem here.
18:33:39 <darthdeus> ski:  ok i guess i'll stick with filter and zip3 :D
18:33:41 <ski> darthdeus : a `filter' might look nicer
18:34:01 <mm_freak> quchen: i didn't see it before having to read months old code myself =)
18:34:08 <ski> darthdeus : or `[...| (x,y,z) <- zip3 xs ys zs,x == y,y == z]'
18:34:36 <darthdeus> ski:  hmm, so many ways
18:34:38 <ski> (the basic problem is that you can't write `(x <- xs | y <- ys | z <- zs),x == y,y == z' as qualifiers in the list comprehension)
18:35:14 <ski> darthdeus : but they're basically the same thing. so go with the one which is most readable to you
18:35:19 <mm_freak> quchen: in any case, getting rid of most ($) and replacing them by parentheses improved readability a lot…  see chrisdone's example from above and rewrite it to use ($)
18:35:26 <mm_freak> you will notice that the parens-version is much easier to read
18:35:34 <MattY> hello
18:35:36 <chrisdone> ion: i made a prototype of such an editor for haskell in the browser, it had proportional fonts and rendered from a tree
18:35:51 <quchen> mm_freak: Sure, in that case parens are easier to read.
18:36:09 <quchen> mm_freak: I think "lisp with infix" is a pretty good style for longer functions.
18:36:10 <MattY> why is (+) :: Num a => a -> a -> a  and not   a -> b -> c  ?
18:36:21 <ski> ion : iiuc, Peaker is doing something like that
18:36:28 <quchen> MattY: You can't add apples and oranges.
18:36:35 <MattY> quchen sure you ca
18:36:36 <MattY> n
18:36:47 <bitwiddly> \quit
18:36:55 <monochrom> because I like it that way
18:36:58 * ski . o O ( you can multiply apples and oranges .. )
18:37:31 <chrisdone> ski: you can certainly juggle them
18:37:40 <ion> (++) :: [a] -> [b] -> [c]
18:37:45 <MattY> was it just done for simplicity? even when it was at the expense of expressiveness?
18:37:57 <ion> (>>=) :: m a -> (a -> n b) -> o b
18:38:12 * dwcook cringes
18:38:23 <chrisdone> MattY: because type inference would never work when you wanted it to, and we didn't have associated types
18:38:27 <dwcook> It's like doing mad science to your types
18:38:42 <monochrom> what is "expressiveness"?
18:38:43 <chrisdone> nowadays, we can use associated types to have coercions to the proper type for arithmetic
18:39:01 <chrisdone> but people claim to like Num how it is
18:39:07 <MattY> in particular, I find dimensional package that lets you use math with different physical properties great, but it redefines it's own (+) function, so if you want to use both you have to do something ugly like P.+ for prelude (+).  if (+) and other Num functions were more flexible they could be used
18:39:08 <quchen> Kilogram 1 + Meter 3   Uhmmmm
18:39:29 <dwcook> Melogreterm 4
18:39:33 <dwcook> Problem solved
18:39:37 <ski> MattY : it's not possible to do in general, and it's not clear what `Num a b c' would mean
18:39:42 <HugoDaniel> hi
18:39:49 <chrisdone> not that, however Int 1 + Double 2.2 -> Double 3.3
18:39:56 <chrisdone> uh, 3.2
18:40:11 <dwcook> Wow, those are super inaccurate floats ;)
18:40:12 <chrisdone> yeah, me not good at maths
18:40:14 <ion> chrisdone: I prefer explicit conversion.
18:40:16 <MattY> quchen, how about 10 meter / 1 second?
18:40:24 <chrisdone> ion: i don't believe you
18:40:41 <ion> I dislike how other languages have weak typing with numeric types.
18:40:46 <MattY> or 1 inch + 10 meter
18:40:47 <relrod> dwcook: nah, just cast it to string like JavaScript would, obviously: Kilogram 1 + Meter 3 ==  "Kilogram 1 + Meter 3"   :P
18:41:12 <chrisdone> ion: you don't need weak typing to be able to add an int and a double
18:41:41 <moops> depends what you mean by weak typing
18:41:48 <moops> some people use it to mean any implicit conversions at all
18:42:11 <quchen> Then some people are wrong.
18:42:12 <ski> ion : strong typing with scientific quantities/dimensions (in a nice way) could be useful
18:42:22 <moops> they arent wrong, its an ill defined term
18:42:30 <MattY> moops no implicit conversions would go on. it would just be a function that takes double and int, and returns double
18:42:33 <moops> they are wrong maybe for using it in the first place
18:42:34 <quchen> Then all people are wrong :-P
18:42:47 <moops> MattY: thats true
18:43:03 <moops> i assumed implicit conversions were taking place
18:43:14 <mm_freak> MattY: that works with the current Num class
18:43:29 <Cale> I tend to think of strong vs. weak typing being a spectrum of what things can be expressed at the type level, i.e. they're relative terms
18:43:34 <MattY> mm_freak it doesn't. you can't make (+) (/) etc take different types
18:43:43 <mm_freak> MattY: they don't have to
18:43:53 <mm_freak> meters 3 + inches 4
18:44:16 <mm_freak> MattY: the issue is that haskell's type system doesn't support units of measure
18:44:34 <mm_freak> so 3m / 4m will not yield 3/4
18:44:39 <chrisdone> ion: see http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
18:44:55 <MattY> mm_freak it would not need to suppot it if Num functions were more flexible.  see dimensional. while great, it had to redefine it's own math operators to make it work
18:45:08 <MattY> if Num was more flexible it wouldn't need to
18:45:10 <mm_freak> MattY: more flexible doesn't help…  you need associated types
18:45:17 <chrisdone> ion: section 2.2 “Arithmetic”
18:45:19 <mm_freak> and those are not standard haskell
18:45:48 <ion> chrisdone: /me reads
18:45:52 <edwardk> MattY: making Num more flexible comes at the cost of making inference for it worse
18:45:52 <ski> MattY : what if you try to add an element of `ℤ / 5·ℤ' with an element of `ℂ' ?
18:46:11 <chrisdone> ion: the type function specifically states what combining X and Y result in. type safe, clean, convenient. i can't see anything that isn't awesome about that
18:46:28 <danilo2_> Hello! Could anybody help me to find the most "beautifull" way of converting "(Array F DIM3 Word8)" to "(Array F DIM2 Word8)" by selecting the last index to be 0? (the last index is the color channel - I want to select red)
18:46:51 <danilo2_> (its Haskell Repa structures of course)
18:47:00 <MattY> mm_freak then how does it work in dimensional?  (100.0 *~ kilo meter) / (50 *~ (kilo meter / hour))
18:47:16 <monochrom> I side with the reader, not the writer. the writer may find it very cool ("expressive power", more like heroism cavalier power) to say, "sometimes, x/y's type is the least super type of x's and y's, for example int/double; sometimes, not, for example metre/second". it is very cool to the writer indeed. but I side with the reader, not the writer.
18:47:40 <mm_freak> danilo2_: combine 'map' with 'index'
18:47:52 <MattY> ski I can't read those characters. but whatever it is, it would only work if appropriate (+) function existed
18:47:59 <monochrom> I am on the side of the reader. the reader reads "x+y", x and y have different types. what is the type of x+y? is it a supertype or no? we just don't know. how to read this code?
18:48:02 <mm_freak> danilo2_: you'll need two layers of 'map'
18:49:00 <monochrom> s/x+y/x/y
18:49:21 <mm_freak> MattY: by stacking types, but there is no type class involved
18:49:26 <edwardk> clearly what we need is a 'geometric algebra' of unit types, so you can add 2m + 4m^2 and get a meaningful result, then you wedge product and contort your way down to real answers as needed.
18:49:29 <ski> MattY : integers modulo `5', respectively complex numbers
18:49:32 <ski> chrisdone : "even though we intend that the `IO' monad has *exactly one* reference type, namely `IORef'." -- i'm not convinced of this
18:49:55 <edwardk> each unit combination is then just a basis (co)blade
18:50:25 <mm_freak> MattY: what i suggested to do by type families is done by 'dimensional' using type classes
18:50:35 <mm_freak> (*) :: (Num a, Mul d d' d'') => Dimensional v d a -> Dimensional v d' a -> Dimensional v d'' a
18:50:49 <ski> MattY : i don't think it makes sense to allow adding one kind of thing with another kind of thing yielding a third kind of thing
18:51:10 <ski> MattY : the basic idea, adding one kind of thing to the same kind of thing yielding the same kind of thing is ok
18:51:17 <mm_freak> with type families it would look about like this:  (*) :: (Num a) => Dimensional v d1 a -> Dimensional v d2 a -> Dimensional v (d1*d2) a
18:51:34 <ski> MattY : then one could consider adding implicit conversions for subset types and maybe quotient types to this
18:51:47 <mm_freak> where the second '*' is a type function:  (*) :: * -> * -> *
18:51:58 <edwardk> ski: hence my teasing about geometric algebra
18:51:58 <mm_freak> or slightly nicer with data kinds:  (*) :: Unit -> Unit -> Unit
18:52:02 <danilo2_> mm_freak: hmm, brb
18:52:08 <ski> MattY : finally, in some circumstances, it would make sense to add one kind of thing to another kind of thing, yielding the other kind of thing -- e.g. adding a vector to a point, yielding a point
18:52:10 <MattY> mm_freak are you saying that dimensional could be rewritten to use Prelude math functions?
18:52:18 <mm_freak> MattY: no
18:52:30 <mm_freak> Num simply doesn't support it, neither does any standard haskell type class
18:52:44 <mm_freak> you can't do this at all without type system extensions
18:52:46 <chrisdone> monochrom: you have the same problem with any arithmetic code in haskell. you have no idea what type anything is until you start investigating the individual parts
18:53:02 <mm_freak> MattY: that alone is enough reason not to put it into the base library
18:53:17 <monochrom> no, it is not the same problem
18:53:50 <ski> edwardk :)
18:54:27 <monochrom> in current Haskell, I don't know the types of x and y, but I know x/y has the same type as x's and y's. that is one bit of useful information. in MattY's world, even the weaker bit, the weaker question, "is that a supertype of x's and y's", cannot be answered.
18:54:36 <MattY> ski I was thinking of having more flexible Num functions specifically to support math between different physical units
18:55:44 <MattY> distance / time = speed
18:56:09 <ski> MattY : a laudable goal, but we need to be careful with how to attempt to go about it
18:56:55 <mm_freak> MattY: one thing to note is that in languages like C/C++/C#/java/… the type system makes some assumptions and implicit conversions that aren't allowed in haskell
18:57:14 <mm_freak> in those languages inference and conversion is directed by the result type
18:57:15 <ski> hm, iirc VHDL has physical units ?
18:57:47 <mm_freak> haskell couldn't even assume that the result type has anything to do with numbers, so you would end up writing type signatures everywhere
18:57:56 <mm_freak> (x :: Integer) + (y :: Integer) :: Integer
18:58:09 <mm_freak> i prefer to write x + y and let the type system figure out the rest =)
18:58:13 <danilo2_> mm_freak: btw am I doing something wrong? Is there really no such function in standard repa library? Such function (to get R, G or B color of image) is needed by many algorithms, isnt it?
18:58:36 <chrisdone> monochrom: when i see fromIntegral (x / fromIntegral y) i don't think “now there's a piece of readable code”
18:58:39 <mm_freak> danilo2_: repa is a generic array library…  it doesn't understand color components
18:59:03 <ski> MattY : in any case, we'd like *coherence* : out of multiple possible ways of interpreting an expression (e.g. by inserting implicit conversions in different places), it should still evaluate to the same value
18:59:38 <mm_freak> danilo2_: map (map (index (Z :. 0))) image
18:59:38 <mm_freak> something like that should work
18:59:44 <chrisdone> monochrom: i think “what the hell are those types” and wish i had a better editor
19:00:12 <monochrom> look, I am sympathetic to this plan: have a division operator o1, such that o1 x y has least supertype of x's type and y's type
19:00:38 <ski> monochrom : .. and matrix division ?
19:00:44 <monochrom> and I am sympathetic also to this plan: have another division operator o2, such that o2 x y has composite type of x's type and y's type
19:00:59 <danilo2_> mm_freak: Thank you, I was just wondering why repa devIL has other convince than standard repa functions. f.e: reading bmp in repa returns (Array U DIM2 (Word8, Word8, Word8)), where in devIL its DIM3
19:01:19 <monochrom> but they ought to be different operators. different names. (or different namespaces.) not the same name.
19:01:49 <ski> monochrom : could you elaborate on the intended uses of `o1' vs. `o2' ?
19:01:50 <danilo2_> mm_freak: of course it is no problem, but if they would use the same representation, more functions would be usable in both cases (like unpack3)
19:02:24 <monochrom> o1 (5 :: Integer) (6 :: Double). o2 (5 :: Metre) (6 :: Second)
19:02:36 <mm_freak> danilo2_: there might be reason for repa-devil to work that way…  note that the tuple version assumes RGB
19:02:38 <edwardk> ski: vector + point headaches are why i work projectively not in affine space ;)
19:03:02 <chrisdone> amonochrom: personally ideally i'd like the convenient one to be default, and the precise one to be something i import. like how i use Integer for everything and then when i care i import GHC.Word or w/e
19:03:29 <monochrom> what is "the" convenient one?
19:03:59 <chrisdone> monochrom: operators that don't make me manually coerce an int to a double, for example
19:03:59 <monochrom> to me, "the" convenient way is to have no default.
19:04:08 <ski> monochrom : with the result type of the first one being ? `Double' ?
19:04:38 <monochrom> perhaps Double? I understand that some people raise hell with that
19:04:42 <mm_freak> monochrom: so 'main = print 0' should be a type error?
19:04:59 <monochrom> I don't know. I'll shut up.
19:05:15 <mm_freak> monochrom: i'm not necessarily against that
19:05:18 <danilo2_> mm_freak, yes it assumes rgb and the repa devIL after loading for example bmp uses data structure "RGB" which is repa Array of DIM3, where 3th dimension is always 3 component of R, G, B ... :)
19:05:36 <mm_freak> but the implication could be that we would have to use a lot more type signatures
19:05:47 <chrisdone> monochrom: i think haskell's equality is the most convenient one
19:05:58 <monochrom> I'm unsympathetic to both plans I have said sympathetic to. (Num a) => a->a->a is exactly right. MattY is welcome to fork GHC. happy now?
19:06:04 <mm_freak> danilo2_: so repa-devil doesn't assume RGB ;)
19:06:12 <chrisdone> whereas most every other language out there optimizes for performance first, and for convenience last, in equality
19:06:16 <ski> edwardk : then there's the two kinds of subtraction, and the two kinds of division :)
19:07:05 <chrisdone> "let's have == be pointer or identity equality!" "but what if i want to write [1,2,3] == [1,2,3]?" "use listEqual"
19:07:32 <ski> *nod* syntactic salt
19:07:33 <chrisdone> (java, js, lisp)
19:07:41 <monochrom> I would rather stick with unreadable "fromIntegral (x / fromIntegral y)" then being asked shitty questions like "so what is the least supertype of Integer and Double?"
19:08:09 <mm_freak> i'm glad that the concept of pointer equality is so difficult to access in haskell
19:08:13 <mm_freak> it makes people not abuse it
19:08:15 <danilo2_> mm_freak: ok, maybe it would make sense after I learn repa more. Btw "map" would not work in this case, because map "Apply a worker function to each element of an array, yielding a new array with the same extent."
19:08:16 <dolio> Let's have == be sometimes structural equality and sometimes pointer equality, depending on which you can get for any given type.
19:08:33 <chrisdone> mm_freak: yeah, me too. it's something you manually import if you want with StablePtr or whatnot
19:10:31 <mm_freak> danilo2_: you're right…  it seems like you have to use 'traverse'
19:11:08 <mm_freak> danilo2_: might be an advantage, because 'traverse' can do it in one go
19:11:29 <danilo2_> mm_freak: or "slice" - right now I'm trying to force it to work, becaue it seems it could do what i want
19:12:07 <danilo2_> mm_freak: http://hackage.haskell.org/package/repa-3.2.3.3/docs/Data-Array-Repa.html#g:8
19:12:45 <mm_freak> danilo2_: possibly…  but honestly i never figured out how to use Any/All
19:12:58 <mm_freak> not tried very hard either =)
19:13:33 <danilo2_> mm_freak: slice v (Any :. All :. All :. (0::Int))  -- it seems to work
19:13:44 <mm_freak> interesting
19:13:58 <chrisdone> monochrom: maybe, maybe. but i haven't tried it. maybe it's really bad, maybe it's never an issue
19:14:16 <danilo2_> mm_freak: I think "Any" should always be on the beginning of slice type, rest is self explanatory
19:14:49 <mm_freak> danilo2_: is it?  the semantics isn't self-explanatory, but in this case it may pay off to think more intuitively =)
19:17:41 <danilo2_> mm_freak: I mean - we can read it as "take any element, which on the first index has got constrain "All", on the second "All" and on the third "index = 0" - this is of course only my "interpretation"
19:18:00 <mm_freak> yeah, makes sense
19:18:43 <zugz> anyone here recently tried to get a cross-compiling ghc with target mingw32?
19:19:43 <enthropy> zugz: this is for generating windows binaries not from windows?
19:19:48 <zugz> enthropy: yes
19:20:17 <enthropy> I've had some success installing a windows haskell platform or some such in wine
19:20:49 <zugz> enthropy: hmm, interesting... is it reasonably straightforward?
19:20:49 <enthropy> but probably that other approach has worked for somebody else in the past
19:21:32 <zugz> enthropy: it has, but I can't get it to do so with latest git source
19:22:09 <enthropy> well I didn't compile the ghc for windows
19:22:15 <enthropy> which itself uses mingw I think
19:23:53 <enthropy> so if somehow you already have a windows installer for ghc (and cabal-install and whatever c libraries you need), it's very straightforward
19:24:54 <MattY> mm_freak> i'm glad that the concept of pointer equality is so difficult to access in haskell
19:24:57 <MattY> how do you access it?
19:25:19 <zugz> enthropy: thanks; going to stick with compiling a cross-compiler for now; trying older version
19:25:34 <mm_freak> MattY: there is a library that exposes some of those internals, but i forgot its name
19:25:59 <mm_freak> MattY:
19:26:04 <mm_freak> @hackage ghc-heap-view
19:26:04 <lambdabot> http://hackage.haskell.org/package/ghc-heap-view
19:26:22 <MattY> cool thanks
19:26:57 <mm_freak> MattY: i'm not doing you a favor, so don't thank me
19:27:06 <mm_freak> ;)
19:27:09 <MattY> yes you are. you answered my question :)
19:27:53 <mm_freak> MattY: well, when someone asks, "how do i convert an IO String to a String", i lie by saying, "it's not possible"
19:29:53 <MattY> a person who asks such a basic question doesn't need to know about unsafePerformIO. not sure why you think that applies to my question
19:29:53 <monochrom> http://ro-che.info/ccc/09
19:29:57 <lispy> mgsloan: wait, so is my code beautiful or terrifying?
19:30:16 <lispy> mgsloan: or are you saying I'm beautiful and terrifying?
19:30:20 <mgsloan> lispy: A healthy mix of both, I'll bet!
19:30:26 <monochrom> because http://ro-che.info/ccc/09 . what good timing
19:30:27 <mgsloan> Gotta keep your readers on their toes
19:31:04 <lispy> mgsloan: :)
19:31:20 <Ralith> mgsloan: when someone asks, "how do i compare objects with pointer identity", ...
19:32:35 <mgsloan> Ralith: Haha.  Actually, come to think of it, that might actually be a little bit handy
19:33:00 <mm_freak> MattY: because i think it applies universally =)
19:33:06 <Ralith> actually, that was meant to be addressed to MattY
19:33:09 <mgsloan> If (==) could have the ol pointer equality shortcut
19:33:16 <mgsloan> Ralith: I figured so
19:33:21 <Ralith> kk
19:33:48 <mgsloan> I mean, it'd be totally messed up on one hand, but kinda nice on the other hand
19:33:59 <mgsloan> It's like this lisp-style code layout debate :P
19:34:30 <MattY> Ralith see the question in context
19:34:50 <mm_freak> mgsloan: that shortcut is wrong
19:34:55 <Ralith> MattY: I did
19:35:00 <mm_freak> mgsloan: let xs = [1..] in xs == xs
19:35:09 <mm_freak> will give you True with the shortcut and bottom without
19:35:12 <mgsloan> mm_freak: Right, I know.  That's why I said it's totally messed up
19:35:31 <mgsloan> But if you gave (==) special semantics it'd be alright
19:35:34 <MattY> Ralith and you're still implying I am clueless for asking about it?
19:35:41 <mm_freak> in particular:  (let xs = [1..] in xs == xs) ≠ [1..] == [1..]
19:35:52 <MattY> that I should be protected from such knowledge? :D
19:35:58 <mgsloan> mm_freak: Also, _ == _ = False
19:36:00 <danilo2_> Ok, 1 more happy Repa question (http://lpaste.net/95088) :D Could somebody explain to me why if we use line 44 instead of 45 the code works 2 times faster?
19:36:02 <danilo2_> (this is little modified official repa example code)
19:36:09 <Ralith> MattY: that's not what I said, no
19:36:41 <MattY> you did not say it, no
19:36:53 <MattY> hence "implied"
19:36:58 <danilo2_> The only difference is by using repa devIL to load images (but the performance slowdown is not while loading images ... all the types are the same)
19:37:16 <mgsloan> mm_freak: Why not have a "unsafePtrEq" function?
19:37:31 <thoughtpolice> we do have that
19:37:32 <mgsloan> I guess we don't want such ugliness in Haskell, but it could seriously come in handy
19:37:36 <mgsloan> thoughtpolice: Nice!!
19:37:48 <frx> mgsloan handy for what?
19:38:13 <mgsloan> frx: I imagine it could be handy for many nasty tricks
19:38:34 <mgsloan> In this case, making (x == y) do less work when x and y are the same thing
19:40:20 <mm_freak> it's difficult to do less work correctly =)
19:40:28 <msl09> why doesn't this compile? http://pastebin.com/MKMz1yzx
19:40:33 <mauke> The paste MKMz1yzx has been copied to http://lpaste.net/95091
19:40:36 <mgsloan> thoughtpolice: Ahh reallyUnsafePointerEq# nice
19:40:49 * mgsloan is glad it exists
19:40:56 * mgsloan won't use it tho - it's really unsafe
19:41:34 <mm_freak> msl09: check the second argument of foldl
19:41:57 <thoughtpolice> as a side note, i have probably seen less than a handful of legitimate uses of reallyUnsafePtrEq#, ever. but maybe i'm just not remembering very hard
19:42:19 <mm_freak> msl09: note that the second argument to foldl has the same type as 'acum'
19:42:41 <mgsloan> thoughtpolice: What if you were writing (==) on ASTs, where it's reasonable to assume they're finite
19:43:05 <msl09> oh you are right
19:43:16 <mgsloan> Question is how often would it really come into play.  Still, could avoid recursing down the two trees to figure out if they're equal
19:43:35 <mm_freak> msl09: btw:  distfold xs ys = sum (zipWith (\x y -> abs (x - y)) xs ys)
19:44:24 <mm_freak> mgsloan: if you don't have bottoms, the pointer equality function becomes a little safer to use (but still unsafe)
19:45:04 <jfeltz> is there a way automatically resolve to Foldable's mapM etc, instead of having to go through and hide the same declarations for every data structure imported?
19:45:09 <msl09> thanks!
19:45:25 <mm_freak> jfeltz: unfortunately no
19:45:42 <mm_freak> jfeltz: i just import Data.Foldable qualified as F
19:46:08 <jfeltz> gah, of course
19:46:10 <mgsloan> mm_freak: Yup, seems like it might be safe-ish if Eq had laws :)
19:46:12 <mm_freak> jfeltz: also Foldable doesn't include mapM =)
19:46:20 <mm_freak> that one requires Traversable
19:46:24 <jfeltz> mapM_ i mean
19:46:39 <thoughtpolice> mgsloan: the problem is that reallyUnsafe means so, because it's tied to the GC. if you had 'a `reallyUnsafePointerEq#` b', it's possible that the GC could move 'a' and 'b' inbetween taking the values for the pointers (which would update all the references to 'a' and 'b' as well,) so the pointer you just 'got' could be very wrong
19:46:56 <mm_freak> mgsloan: it's not about laws…  pointer equality is inherently impure
19:47:18 <thoughtpolice> finiteness doesn't have as much to do with it as 'pointers' into the heap aren't really supposed to stick - you need a StablePtr for that.
19:47:18 <mm_freak> even if you use it only as a shortcut…  the shortcut is forbidden in many cases
19:47:42 <thoughtpolice> honestly more stuff could possibly happen there that i can't predict. throw in the -threaded runtime and who knows what else could occur
19:48:17 <danilo2_> Ok, updated repa question - could somebody tell me, why "computeP $ slice v (Any :. All :. All :. (0::Int))" is twice slower than "U.unzip3 arrRGB"?
19:48:18 <danilo2_> (of course the base representation is different, in the first code it is (Array F DIM3 Word8) and in the second (Array U DIM2 (Word8, Word8, Word8)), but why it affects performance like this?
19:48:19 <mm_freak> thoughtpolice: the idea is that if pointer equality returns False, you would do the regular structural equality, but even that is unsafe
19:49:16 <enthropy> danilo2_: do you know which index varies the quickest if you are stepping through a repa array?
19:49:37 <mgsloan> thoughtpolice / mm_freak: Gotcha, that makes sense
19:49:48 <enthropy> maybe the image is like   [ (r1,g2,b1), (r2,g2,b2), ... ]
19:49:49 <mgsloan> Sounds like there are almsot no legitimate uses then
19:50:11 <enthropy> so that unzip3 does one loop over the original
19:50:13 <mm_freak> mgsloan: there are some, but most of those are covered by GHC itself =)
19:50:27 <mgsloan> right!
19:50:29 <enthropy> while your version has three loops
19:50:33 <mm_freak> mgsloan: let x = 3^1000000 in x == x
19:50:44 <mm_freak> mgsloan: likely the underlying equality function will return True instantly
19:50:50 <thoughtpolice> yes, like i said i've seen less than a handful of true uses for that primitive ever (or at least in the past 7 years)
19:51:13 <mgsloan> mm_freak: Huh, no way.  So a special case for Integer?
19:51:18 <danilo2_> enthropy: what do you mean by "varies the quickest"? I read image using 2 methods - one readImageFromBMP (which gives me (Array U DIM2 (Word8, Word8, Word8))) and the pother: "readImage" (devIL)
19:51:21 <mm_freak> mgsloan: GMP does that
19:51:24 <thoughtpolice> i can't even remember the last time i saw it. (or maybe i just don't want to)
19:51:45 <mm_freak> if the number pointers point to the same address, GMP won't compare the limb arrays
19:51:53 <danilo2_> enthropy: http://lpaste.net/95088
19:51:56 <enthropy> danilo2_: I think you might be comparing   unzip  with (map fst, map snd)
19:52:10 <mm_freak> mgsloan: GMP has lots and lots of low level optimizations like that
19:53:13 <mgsloan> mm_freak: Good to know!
19:53:51 <danilo2_> enthropy: unzip is implemented as [...] map (\(a, b, c) -> a) xs [...] (http://hackage.haskell.org/package/vector-0.10.9.1/docs/src/Data-Vector-Generic.html#unzip5)
19:54:22 <danilo2_> enthropy: so it is not different from map fst, snd etc
19:55:14 <danilo2_> enthropy: If you look at my code - I simply want to replce standard repa image loading (wich supports only bmp) with devil repa bindings, but it gives me 50% performance lsowdown ...
19:56:39 <jrmithdobbs> so I'm very confused about how :: binds
19:56:45 <jrmithdobbs> lexically speaking
19:57:05 <jrmithdobbs> how can I fix this so the redundant xs isn't needed?: http://lpaste.net/7400758100216512512
19:57:42 <jrmithdobbs> (contrived example)
19:57:48 <chrisdone> f = decode . encode :: Maybe [String]
19:58:55 <jrmithdobbs> :t f = reverse . reverse :: Maybe [String]
19:58:56 <lambdabot> parse error on input `='
19:59:06 <jrmithdobbs> :t reverse . reverse :: Maybe [String]
19:59:08 <lambdabot>     Couldn't match expected type `Maybe [String]'
19:59:08 <lambdabot>                 with actual type `[a0] -> [a0]'
19:59:08 <lambdabot>     In the expression: reverse . reverse :: Maybe [String]
19:59:13 <jrmithdobbs> that
19:59:40 <chrisdone> wait, what do you want to encode and what you do want to decode?
19:59:49 <MattY> reverse accepts [a] not a Maybe
20:00:05 <chrisdone> [String] in, Maybe [String] out?
20:00:24 <jrmithdobbs> yes
20:00:28 <chrisdone> so: let f = decode . encode :: [String] -> Maybe [String]
20:00:36 <darthdeus> what's a good way of splitting "asdfasdf" into n-sized sub-lists? like ["asd", "sdf", "dfa", ...] so that they overlap, but the members are always in the same order as they appear in the string
20:00:46 <chrisdone> :t splitEvery
20:00:47 <lambdabot> Int -> [e] -> [[e]]
20:00:56 <chrisdone> @hoogle splitEvery
20:00:56 <lambdabot> No results found
20:01:00 <chrisdone> bah
20:01:04 <chrisdone> it's in Data.List.Split, anyway
20:01:45 <chrisdone> oh, with overlaps
20:01:51 <darthdeus> yeah
20:01:55 <chrisdone> perhaps with tails
20:02:21 <chrisdone> > tails "asdfasdf"
20:02:23 <lambdabot>   ["asdfasdf","sdfasdf","dfasdf","fasdf","asdf","sdf","df","f",""]
20:03:12 <chrisdone> > map take 3 . filter ((>=3).length) . tails $ "asdfasdf"
20:03:13 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]] -> c0'
20:03:13 <lambdabot>              with a...
20:03:16 <chrisdone> > map (take 3) . filter ((>=3).length) . tails $ "asdfasdf"
20:03:17 <lambdabot>   ["asd","sdf","dfa","fas","asd","sdf"]
20:03:33 <MattY> chrisdone what happened to parenthesis
20:04:25 <chrisdone> MattY: what happened to question marks?
20:04:49 <MattY> is this too ugly even for a lisper?  map (take 3) (filter ((>=3).length) (tails  "asdfasdf"))
20:05:21 <chrisdone> no, i like that. but peopple in here would bitch about the parens
20:05:53 <MattY> because it's hideous. you can't see what's going on
20:06:32 <chrisdone> uh huh
20:06:40 <sellout-> I’m a lisper and I like it. I don’t really use $ at all.
20:07:05 <chrisdone> sellout-: no, you just think you like it. infix operators are the only way
20:07:19 <jrmithdobbs> chrisdone: i figured out my confusion i think, what I really want is f :: Maybe [String] -> Maybe [String] so that I can do f . f . f . f . f $ whatever
20:07:47 <sellout-> chrisdone: Infix operators make me spend too much time futzing with indentation and line breaks.
20:08:05 <MattY> () gets drowned in () used for partial application. with . you can easily see the chain of functions that value gets piped through
20:08:37 <mm_freak> MattY: "print (sin x)" vs. "(print . sin) x"
20:08:45 <mm_freak> or even worse:  print . sin $ x
20:09:22 <enthropy> > print $ do sin $ x
20:09:23 <lambdabot>   <IO ()>
20:09:29 <MattY> mm_freak that is quite different than above example
20:09:51 <mm_freak> MattY: i'm bringing it up, because style choices should not be a strict application of formal rules
20:09:53 <chrisdone> MattY: sure -- i like the . operator, in this case i was describing a function anyway, i use . to show it's simple function composition
20:10:16 <mm_freak> haskell style can be summarized as:  write whatever you can easily read a year later
20:10:41 <chrisdone> MattY: if i were coding, i wouldn't write it like that. i'd use parens. but then maybe i'd explode it to composition if i was naming just the function
20:12:25 <monochrom> $ gets drowned in many $'s. that's my take on it.
20:12:46 <MattY> there was just one $ there
20:12:52 <chrisdone> i think personally i just like one or the other, in my code
20:13:18 <chrisdone> i don't mind foo $ bar $ mu zot, or x = foo . bar . mu, or foo (bar (mu zot))
20:13:22 <chrisdone> but the mixture bothers me
20:13:40 <dwcook> @type ($) $ ($) $ ($)
20:13:41 <lambdabot> (a -> b) -> a -> b
20:13:44 <monochrom> clearly, you need 30 variations of $
20:13:45 <dwcook> @type id `id` id `id` id
20:13:46 <jrmithdobbs> of the little haskell code i've read so far I think the annoyance factor of more $s is directly porportional to the sqrt() of the number of parens without more $
20:13:46 <lambdabot> a -> a
20:13:49 <jrmithdobbs> ;p
20:14:23 <monochrom> it's 30 because {infix, infixl, infixr} x {0 - 9}
20:14:37 <dwcook> I'm going to play fool's advocate and say we should just use infix id everywhere instead of ($). Way more explicit what it does :P
20:15:01 <chrisdone> but $ is all about convenience
20:15:16 <chrisdone> it just exists to be convenient
20:15:32 <monochrom> come April 1, I will upload a package to hackage for exactly the grand scheme of eliminating all or most parentheses
20:15:51 <chrisdone> monochrom: i have one: chrisdone.com/z
20:15:52 <pharaun> taking no prisoners eh monochrom ;p
20:15:55 <chrisdone> not a parenthesis in sight!
20:16:01 <enthropy> data Tuple2; data Tuple3; ...
20:16:08 <nooodl> monochrom: should name 'em ($) ($$) ($$$) ($$$$) ($$$$$)
20:16:22 <dwcook> Parenthecide!
20:16:27 <nooodl> (are 30-character long operator names a thing. they should be)
20:16:35 <chrisdone> dwcook: lol
20:16:50 <maybefbi> Due to high costs caused by a post-war depletion of the strategic parentheses reserve we need this
20:16:55 <monochrom> I like the word "parenthecide"
20:16:59 <mgsloan> monochrom: I have one too! http://hackage.haskell.org/package/plumbers-0.0.2/docs/Control-Plumbers.html
20:16:59 <chrisdone> me too
20:17:21 <mgsloan> I didn't upload on april first or have an acme prefix, though :(
20:17:24 <chrisdone> for a while i used lots of unicode operators in my code and felt better about haskell's operators
20:17:28 <mm_freak> monochrom: make sure you only export the functions you want to expose:  module NoParentheses (…) where …
20:17:31 <mm_freak> =)
20:17:54 <chrisdone> → ← … ∘ etc
20:18:01 <dwcook> mgsloan, I like how memorable all those names are
20:18:07 <dwcook> Which is to say, I like how I won't remember any of them
20:18:47 <chrisdone> dwcook: actually there is supposed to be a system behind it, so that they are memorable and figure-outable
20:19:13 <mm_freak> where between homicide and suicide lies parenthecide?
20:19:46 <dwcook> mm_freak, I don't know, but I will probably want to commit suicide after viewing code that commits parenthecide
20:19:55 <chrisdone> surely homicide and suicide are parenthesized by parenthecide ;)
20:19:57 <mm_freak> indeed
20:21:25 <mm_freak> type And c d = (c, d)
20:21:34 <mm_freak> Num a `And` Eq a => …
20:21:47 <djahandarie> chrisdone, where are you working at these days again? Was it fpc full-time now, or?
20:25:28 <jrmithdobbs> i don't really understand the passion in this discussion, (), $, or `id` work fine and where any get convoluted f . g where f = ..; g = ...; makes the topic pretty irrelevent
20:25:33 <mgsloan> dwcook: It's actually really a little symbolic sub-language of plumbing operators
20:25:37 <cbw> let getASSwithAnyBFromBs ass bs = filter (\xs -> any (\x -> any (x==) bs) xs) ass
20:25:43 <mgsloan> dwcook: So you only need to learn 5 orso symbols
20:25:43 <cbw> ^ is there a better way
20:25:50 <mgsloan> dwcook: Not that I'm really advocating it :)
20:28:40 <darthdeus> erm, how do i get last 5 items in a list? i can only think of doing recursive last/init
20:29:11 <enthropy> > reverse (take 5 (reverse "get last 5 items"))
20:29:13 <lambdabot>   "items"
20:29:42 <darthdeus> ohh right
20:34:49 <moops> is do notation magic to the built in Monad or is it more general than that?
20:35:27 <enthropy> @type \x -> do x
20:35:28 <lambdabot> t -> t
20:44:36 <dwcook> moops, the sequencing operations it desugars multiple "statements" to are indeed from Monad, (>>=) and (>>).
20:44:49 <dwcook> @undo do { foo <- bar ; baz foo }
20:44:49 <lambdabot> bar >>= \ foo -> baz foo
20:45:10 <moops> ouch
20:45:23 <dwcook> Though as enthropy demonstrated, a single "statement" is fully general.
20:45:28 <frx> can be written as bar >>= foo
20:45:37 <frx> bar >>= baz even
20:45:50 <moops> makes the applicative vs monad shenanigans even more annoying
20:46:39 <pharaun> chrisdone: i've been working on getting lpaste to run, just a headup, if spamc isn't installed it will crash in a very unkind manner (exception).
20:47:16 <pharaun> if you want, i can probably try to write a patch to make that part crash nicer/or have optional support, we were looking at lpaste for internal use
20:48:34 <dwcook> @. @pl @undo do { foo <- bar ; baz foo }
20:48:34 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
20:48:44 * dwcook doesn't remember how to use that
20:49:19 <dwcook> @. pl undo do { foo <- bar ; baz foo }
20:49:22 <lambdabot> bar >>= baz
20:49:22 <lambdabot> optimization suspended, use @pl-resume to continue.
20:49:26 <dwcook> \o/
20:51:58 <mm_freak> http://lpaste.net/95093
20:52:08 <mm_freak> sodium is quite pleasant for widget-based UIs
20:52:17 <mm_freak> most of the awkwardness comes from vty-ui itself
20:54:20 <pharaun> that looks pleasant
20:54:52 <mm_freak> if you ignore everything except 'main' =)
20:55:57 <thoughtpolice> i should get around to trying one of those functional reactive things one of these days.
20:56:20 <pharaun> mm_freak: i've seen worse :p
20:56:32 <mm_freak> i'll most likely combine sodium with netwire in future applications
20:57:33 <mm_freak> in 'suml' the FRP magic happens
20:57:45 <mm_freak> changing the numbers in the edit-boxes changes their sum label automatically
21:39:48 <Shin-LaC> how can I check if a list contains at least an element matching a predicate?
21:40:23 <frx> > any even [1,2,3]
21:40:24 <lambdabot>   True
21:40:25 <Shin-LaC> if I use length (filter p l) >= 0, that will cause it to look through the entire list in order to compute the length, right?
21:40:27 <Shin-LaC> oh
21:40:42 <Shin-LaC> thanks
21:40:46 <frx> welcome
21:41:02 <scshunt> I keep forgetting that any is a second-order function
21:42:07 <mm_freak> Shin-LaC: use 'null'
21:42:22 <mm_freak> instead of comparing length to 0
21:43:13 <Shin-LaC> oh... so any = not . null . filter ?
21:43:29 <mm_freak> any p = not . null . filter p
21:43:50 <Shin-LaC> I see
21:43:58 <mm_freak> use 'length' only when you're actually computing with the length as a numeric value
21:44:21 <Shin-LaC> yes, I wanted to avoid using length
21:46:04 * hackagebot wai-app-file-cgi 0.8.7 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.8.7 (KazuYamamoto)
21:50:34 <lispy> ?src any
21:50:35 <lambdabot> any p =  or . map p
23:05:08 <augur_> anyone know of type systems that represent defined uniqueness? that is to say, uniqueness at a type?
23:05:51 <erisco> augur_ linear types? don't know if that is what you mean. all I can offer
23:05:58 <augur_> no no its not that :p
23:06:43 <nanothief> I'm confused as well. Do you mean something like Data.Unique ( http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Unique.html )
23:07:08 <augur_> nanothief: no no no
23:07:14 <augur_> i mean like
23:07:25 <augur_> im trying to find a nice type theoretic foundation for type classes
23:07:42 <augur_> currently, type classes have to be unique, and this is enforced by the type checker in an ad hoc way
23:08:04 <augur_> it just checks to make sure you dont declare an instance twice, and dies if you do
23:08:22 <augur_> but such a thing has no meaning in type theory as far as i know
23:09:01 <mm_freak> augur_: type class instances have to be unique
23:09:11 <augur_> yes thats what i meant :p
23:10:20 <mm_freak> i don't think they need much more foundation than they already have
23:10:20 <mm_freak> see e.g. agda's {{implicit arguments}}
23:12:11 <mm_freak> also the compiler doesn't quite "check" for duplicates (it can't)…  if two instances apply, it just doesn't arbitrarily pick one of them
23:15:11 <augur> tosh. we need foundations for everything!
23:22:02 <issimus> augur: do you mean something like if x,y both have Z type then necessarily x /=y ? i have no answer for you just curious about what is being discussed
23:22:23 <augur> issimus: yes, basically
23:22:27 <augur> actually no no
23:22:29 <augur> its more
23:22:40 <augur> if you do x :: Z; x = ...
23:22:47 <augur> then you can't later do y :: Z; y = ...
23:23:46 <augur> maybe you could have the types induce names... hmm
23:24:34 <Draconis> ugh can someone help me with a haystack question regarding how to implement prepared_data ?
23:24:58 <Draconis> wrong channel :)
23:24:59 <Draconis> sorry guys
23:31:37 <pdamoc> hello kind people of haskell. I tried installing 64bit haskell and Elm on a OS X 10.9 and run into some problems. the cabal install chocked on a dependency library names lifted-base with "Control/Exception/Lifted.hs:7:4:
23:31:38 <pdamoc>      error: invalid preprocessing directive
23:31:39 <pdamoc>       #-}
23:31:40 <pdamoc>        ^
23:32:17 <pdamoc> this is my first experience with the haskell world so... any ideas about what I could try to get past this?
23:33:42 <adas> .
23:36:22 * hackagebot purescript 0.1.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.2 (PhilFreeman)
23:39:32 <paf31> what happens if you "cabal install lifted-base"?
23:39:40 <paf31> same error?
23:39:47 <pdamoc> yes
23:39:50 <paf31> i was able to install it just now on ubuntu
23:40:40 <paf31> i recently ditched my mac setup and moved to a VM due to maverick/ghc issues
23:40:45 <paf31> what c compiler are you using?
23:41:09 <pdamoc> http://lpaste.net/95094
23:41:59 <pdamoc> Haskell Platform 2013.2.0.0 for Mac OS X, 64 bit
23:42:09 <paf31> which C compiler?
23:42:10 <pdamoc> at least this is what I installed
23:42:45 <paf31> mavericks uses clang by default i belive
23:42:48 <paf31> *believe
23:43:08 <paf31> this looks like its parsing a closing haskell comment as a line C preprocessor directive
23:43:09 <pdamoc> cc --version reports "Apple LLVM version 5.0 (clang-500.2.79) (based on LLVM 3.3svn)"
23:43:22 <paf31> did you try switching to gcc?
23:43:29 <paf31> there are some instructions on haskell reddit
23:43:47 <paf31> i didnt have any luck with it, but i didnt try the latest solution
23:43:59 <pdamoc> nope, will try that and get back with the results :) thanks
23:45:08 <smith_> If I'm using lenses in this code --> http://lpaste.net/95095 <-- what type should go where `XXX` is?
23:45:11 <paf31> here's the latest link from reddit https://gist.github.com/mzero/7245290
23:46:23 * hackagebot labyrinth 0.4.2.0 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.4.2.0 (AlexeyKotlyarov)
23:47:56 <adas> how do i simply remove all the packages installed via cabal? is there any folder i can delete?
23:48:44 <paf31> @type Control.Lens.view
23:48:49 <lambdabot> MonadReader s m => Getting a s a -> m a
23:49:07 <paf31> @type Control.Lens.set
23:49:09 <lambdabot> ASetter s t a b -> b -> s -> t
23:49:21 <augur> regarding the multiple instances problem: phantom types/data kinds for class indexing!
23:49:37 <smith_> See, I'm not sure how to resolve Getting a s a <-> ASetter s t a b. Is there a common type that can unify them both?
23:49:42 <pdamoc> I used the instructions from http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9 and it works now (install moved past lift-base issue) thank you @paf31
23:49:47 <relrod> adas: Usually it uses ~/.cabal/ by default... - make sure you back up ~/.cabal/config if you customized it though.
23:49:59 <augur> i dub this solution "framing"
23:50:36 <adas> relrod: no customization .. can i delete ~/.cabal. would that be like a fresh start?
23:50:49 <relrod> adas: should be able to, yes.
23:51:15 <augur> infact, if you index by classes, you can make framing especially nice!
23:53:56 <adas> what is the standard protocol or procedure to follow when cabal says that I should use '--force-reinstall' for a package?
23:56:00 <mm_freak> adas: there is none…  my procedure is:  cabal update && rm -rf ~/.cabal/{bin,lib,share} ~/.ghc && cabal install -j4 world
23:56:07 <mm_freak> beware of the 'rm' command
23:56:12 <mm_freak> use at your own risk
23:56:52 <adas> what does cabal install -j4 world do?
23:57:08 <adas> i guess j4 splits it to 4 cores
23:57:11 <adas> and world?
23:57:16 <mm_freak> when you install a package (without --one-shot), then it is written to ~/.cabal/world
23:57:25 <mm_freak> 'cabal install world' installs everything in that file
23:57:42 <mm_freak> and yes, -j4 makes it use four builder threads
23:57:57 <augur> this would be interesting to be able to write:
23:58:11 <adas> mm_freak: thanks for the command. ill try your command. hoping it will fix something
23:58:21 <augur> instance (Ord a, Ord b) => Ord (Swap (a,b)) where ...
23:58:22 <smith_> Ah, I see. The proper type is `Simple Lens a b`. I was unsure of this because it requires Rank2Types enabled, but that's because Lens is a type synonym that requires that extension.
23:58:27 <augur> where Swap is not a type, but a _view_
23:58:51 <augur> but really, the instance for it should be derived automatically
23:58:56 <augur> so i dont know if thats how you'd want to write it
23:59:01 <mm_freak> smith_: btw, Simple Lens = Lens'
