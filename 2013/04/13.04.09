00:13:16 <genisage> Sometimes I want to apply a function to all of my arguments, and I usually end up doing something like let h = flip (g . f) . f
00:13:39 <genisage> but that quickly gets ugly with more arguments, so is there a simple way to map over all of the inputs?
00:18:31 <shachaf> There is no way to do it. Often it doesn't make sense because arguments are of different types.
00:19:15 <shachaf> You can also use view patterns: foo (f -> x) (f -> y)
00:19:17 <shachaf> = ...
00:19:36 <genisage> ok, thanks.
00:19:42 <Saizan> for the specific binary case there's on though
00:19:46 <Saizan> ?type on
00:19:47 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
00:20:10 <shachaf> Ah, also true.
00:20:28 <shachaf> > ((+) `on` length) "hello" "genisage"
00:20:29 <lambdabot>   13
00:20:48 <Saizan> (for the n-ary case one could build a typeclass hackery mess not really worth the trouble)
00:20:51 <genisage> Thanks, that's neat.
00:21:05 <shachaf> You can also pass the arguments in a list and then map over it.
00:21:22 <shachaf> But of course that won't be a fixed size and so on.
00:44:23 <no-n[3]> > let infixl 9 \.; (\.) = flip (.); infixl 0 \$; (\$) = flip ($) in [0..10] \$ map (2^) \. filter (>100) \. map (*10)
00:44:25 <lambdabot>   [1280,2560,5120,10240]
00:52:28 <madjestic> hey guys, I am playing with Data.Tree and I think what I need is an alternative declaration of fmap instance Functor Tree where fmap f (Node x ts) = Node (f x) (map (fmap f) ts)
00:52:48 <madjestic> sorry :(  wrong paste
00:52:51 <romand> hi, I'm curoius why `fail` in Monad (Either a) instance is `error`, not `Left`
00:53:05 <madjestic> http://hpaste.org/85453
00:53:22 <shachaf> romand: Because it wouldn't type-check if it was Left.
00:53:38 <shachaf> fail :: String -> Either e a
00:53:45 <shachaf> Left :: String -> Either String a
00:54:04 <romand> aha got it
00:54:08 <shachaf> madjestic: It is not.
00:54:21 <shachaf> madjestic: There are two answers here.
00:54:41 <shachaf> First, it's not possible to have multiple instances of any type class for the same type. You can make a new type, if you want a new instance.
00:55:23 <shachaf> Second, there is only ever one possible instance of Functor for any type. This is a special property of the type class Functor.
00:55:40 <romand> shachaf: fail :: String -> m a
00:55:47 <shachaf> I mean that if I write an instance of Functor Foo and you write an instance of Functor Foo, independently, we're guaranteed to end up with the same instance.
00:55:53 <shachaf> romand: Yes. And m is Either e
00:55:58 <romand> Left :: String -> Either String a
00:56:07 <madjestic> shachaf: a new type, based on the Tree type that is?  Interesting.  Thanks
00:56:11 <romand> ok, I want to use (Either String) as monad for handling error
00:56:21 <romand> how do I do that?
00:56:34 <shachaf> madjestic: New type as in newtype Foo a = Foo (Tree a), with all its own instances.
00:56:39 <hamid> @s scanl
00:56:39 <lambdabot> Maybe you meant: shootout show slap smack source spell spell-all src . ? @ v
00:56:51 <hamid> @src scanl
00:56:51 <lambdabot> scanl f q ls = q : case ls of
00:56:52 <lambdabot>     []   -> []
00:56:52 <lambdabot>     x:xs -> scanl f (f q x) xs
00:57:00 <romand> http://hpaste.org/85455
00:57:11 <romand> thats what I have now
00:57:11 <madjestic> shachaf: thanks, it looks like a way to go then
00:57:21 <Botje> romand: I think it suffices to import Control.Monad.Error
00:57:22 <shachaf> romand: If you want "fail" to give you the String, you won't be able to use the type Either.
00:57:44 <shachaf> Control.Monad.Error gives you a type that would make it work, I think.
00:57:55 <shachaf> Nobody likes it much because it's gross.
00:58:00 <shachaf> A better solution might be not to use fail. :-)
00:58:05 <shachaf> madjestic: What?
00:58:11 <shachaf> madjestic: Did you read the other things I said?
00:58:38 <madjestic> about Foo a... ?
00:58:57 <shachaf> One of the instances you wrote won't type-check.
00:59:04 <shachaf> I suspect it's the second one.
00:59:19 <shachaf> f has type (a -> b), not ([Tree a] -> b)
01:00:46 <madjestic> shachaf: I don't understand.  Did my responce imply that I missed some of your reply?
01:01:27 <shachaf> Well, you said you wanted to make a new type in order to give it a new Functor instance.
01:01:42 <shachaf> I said that you won't be able to give it a new Functor instance because there are no other Functor instances that trees could have.
01:03:42 <romand> shachaf: you mean use `throwError`/`catchError` ?
01:04:05 <shachaf> romand: I don't know.
01:08:13 <madjestic> shachaf: ok, so I can not create a new data type to circumvent that limitation?  What would be a suggested sollution for such scenario then?  I could write a recursive function with pattern matching to do the same thing, but fmap provides a much more concise way for the same funcionlity
01:08:32 <shachaf> madjestic: In the case of most type classes you could create a new data type.
01:08:39 <shachaf> This particular thing has nothing to do with type classes, though.
01:08:48 <shachaf> fmap is a magic function because there's only one way to define it.
01:10:12 <shachaf> Go ahead and try it.
01:10:24 <shachaf> Write map1 :: (a -> b) -> Tree a -> Tree b; map1 = ...
01:10:39 <shachaf> And then write map2 :: (a -> b) -> Tree a -> Tree b; map2 = ... which is different
01:11:15 <donri> @djinn (a -> b) -> f a -> f b
01:11:15 <lambdabot> -- f cannot be realized.
01:11:22 <hamid>  @src []
01:11:23 <donri> shachaf: clearly, you lie
01:11:27 <hamid> @src []
01:11:27 <lambdabot> data [] a = [] | a : [a]
01:11:32 <donri> djinn hath spoken
01:12:13 <shachaf> What?
01:16:06 <hamid> @src (:)
01:16:06 <lambdabot> Source not found. That's something I cannot allow to happen.
01:17:08 <hamid> hmm why no source for that? :/
01:17:21 <shachaf> Because it's built-in.
01:17:39 <donri> because @src is a hand-written database
01:18:02 <hamid> ow. ok
01:18:20 <lightquake> for the (->) e monad, a >> b is the same thing as b, right?
01:18:27 <shachaf> Yes.
01:18:51 <lightquake> @undo do { a; b }
01:18:51 <lambdabot> a >> b
01:19:44 <shachaf> madjestic: I didn't mention that map1 and map2 have to satisfy the functor laws, of course.
01:20:00 <shachaf> madjestic: In particular they have to have those types and the fact that map id x = x
01:20:08 <shachaf> (There's another law but you get it for free in Haskell from the type.)
01:25:18 <quchen> shachaf: How complicated is the proof for the above?
01:25:48 <shachaf> That law 1 -> law 2 via parametricity?
01:25:57 <shachaf> It's somewhat involved. You can find it on -cafe somewhere.
01:26:13 <quchen> I'll have a look then, thanks.
01:26:25 <quchen> (On StackOverflow the answer is basically namedropping)
01:29:11 <quchen> shachaf: Why is the second law mentioned then in the Functor class? If the second one was very easy to check it could make sense as a sanity test, but you can't beat "fmap id = id" in that respect
01:29:41 <shachaf> Because it is a law of functors in general, probably.
01:29:57 <shachaf> There is a very standard definition of "functor" of which the Haskell Functor is a special case.
01:30:27 <quchen> Ah. What's the characteristic thing of this special case? Being constrained to Hask?
01:31:19 <shachaf> It's parametricity.
01:31:53 <quchen> Oh. I thought that was just a short name for some bigger concept. Thanks for the pointers
01:32:08 <shachaf> I think it's might be this, if this is true: If a . b = c . d, then fmap a . fmap b = fmap c . fmap d
01:32:14 <shachaf> For any function with fmap's type, laws or not.
01:32:21 <shachaf> Is this true?
01:32:52 <elliott> @free fmap :: (a -> b) -> f a -> f b
01:32:52 <lambdabot> Extra stuff at end of line
01:32:57 <elliott> @free (a -> b) -> f a -> f b
01:32:57 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
01:33:00 <elliott> @free (a -> b) -> F a -> F b
01:33:00 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
01:33:03 <elliott> :(
01:33:19 <shachaf> @free foo :: (a -> b) -> Blah a -> Blah b
01:33:20 <lambdabot> g . h = k . f => $map_Blah g . foo h = foo k . $map_Blah f
01:33:32 <shachaf> Oh, maybe not.
01:33:44 * shachaf is just going off snippets of the proof.
01:34:14 <elliott> shachaf: that's what you said
01:34:17 <elliott> foo = $map_Blah
01:36:21 <shachaf> Ah, then there you go.
01:36:26 <shachaf> Let a = id and use the other law.
01:37:06 <shachaf> By now I've found ddarius's post on this.
01:37:48 <shachaf> http://www.haskell.org/pipermail/haskell-cafe/2010-January/071641.html
01:37:55 <shachaf> id . b = c . d  ==>  fmap id . fmap b = fmap c . fmap d
01:38:09 <shachaf> b = c . d  ==>  fmap b = fmap c . fmap d
01:38:23 <shachaf> fmap (c . d) = fmap c . fmap d
01:40:24 <quchen> That simplifies the problem to reading about free theorems. (Plus understanding them, maybe.)
01:45:26 * hackagebot yesod-auth 1.1.7 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.7 (MichaelSnoyman)
01:57:29 <spacebark> i can't get llvm-base to build
01:57:57 <spacebark> i have llvm 3.2 installed
01:58:36 <spacebark> anyone have any luck building llvm-base with llvm 3.2?
02:06:24 <alpounet> spacebark, what error are you getting?
02:08:41 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚Äúcabal install llvm-base‚Äù at http://hpaste.org/85457
02:09:02 <spacebark> alpounet: http://hpaste.org/85457
02:09:49 <alpounet> ok spacebark apparently the version on hackage doesn't seem to build with 3.2 and maybe even not 3.1. however, https://github.com/bos/llvm/pull/40 this contains patches that fix that -- in particular maybe you should check out scottgw's branch, as mentioned in one of his comments
02:11:36 <spacebark> awesome! thanks
02:12:53 <alpounet> spacebark, worst case: his branch doesn't fix your issues but you know you can ask him or just comment on the pull request like the others to get some news.
02:41:17 <no-n[3]> data NestedList a = Elem a | List [NestedList a] -- how would I write the "instance Show NestedList where" statement such that these would print like [1,2,[3,4]] ?
02:41:40 <marekw2143> hello, how can I install Data.List.Ordered? I've downloaded Data.List.Ordered.hs but woudl like to install it - how?
02:51:42 <typoclass> marekw2143: hello, normally you install things using cabal. the module Data.List.Ordered is part of the package data-ordlist, as you can see e.g. on the top of this page http://hackage.haskell.org/packages/archive/data-ordlist/latest/doc/html/Data-List-Ordered.html
02:51:54 <typoclass> marekw2143: to install that, try "cabal install data-ordlist"
02:52:54 <marekw2143> typoclass: thanks man!
03:27:49 <hseg> Parsec's parseFromFile acts as if the input is empty. Similarly, if I use ByteString's readFile to construct the input to parse, Parsec seems to see an empty string. But if I pass a packed String to parse, everything's spiffy.
03:27:49 <lambdabot> hseg: You have 1 new message. '/msg lambdabot @messages' to read it.
03:29:06 <Botje> no-n[3]: pattern match on the constructor, print stuff accordingly
03:29:36 <hseg> I have no idea why this is happening. Any help in diagnosing this?
03:31:01 <alpounet> no-n[3], something like: instance Show a => Show (NestedList a) where show (Elem x) = how you want to print a single element ; show (NestedList l) = how you want to print a nested list
03:31:21 <alpounet> err, show (List l) sorry
03:31:28 <Botje> hseg: do you force your parser to eat everything?
03:31:54 <Botje> try using (yourParser <* eof) instead of yourParser
03:33:04 <no-n[3]> Botje, alpoune: I tried "show (Elem a) = show" and "show (List a) = show a" but it said "expected one more argument"
03:33:51 <Botje> no-n[3]: show your full code along with the error
03:34:00 <Botje> the first case should be show (Elem a) = show a
03:34:59 <Kaidelong> why is he shadowing show here anyway
03:35:54 <hpaste> no-n pasted ‚ÄúNestedList‚Äù at http://hpaste.org/85459
03:36:06 <no-n[3]> Botje: ^
03:36:16 <Kaidelong> oh making an instance
03:36:25 <hseg> OK. A) So pack is forcing the evaluation of the contents of the file? B) How do I parse newlines platform-independently (i.e. newline = "\n" <|> "\r" <|> "\r\n")
03:36:36 <Botje> no-n[3]: the type "NestedList" doesn't exist.
03:36:40 <Botje> no-n[3]: only the type "NestedList a"
03:36:47 <no-n[3]> ah, oops
03:37:21 <Botje> hseg: doesn't the built-in newline parser do that automatically?
03:37:36 <Botje> as for A: show code, then
03:37:49 <Botje> lazy bytestrings are lazy :)
03:37:51 <hseg> Apparently it doesn't, since I'm now getting unexpected "\r" errors in my parser.
03:38:30 <hseg> Using non-lazy bytestrings
03:38:32 <Kaidelong> no-n[3]: Dunno if I agree with that entirely, in that example you need to use "NestedList a" because it has a kind * but there is indeed a "NestedList" of kind * -> * which you can use for making instances like Monad or Functor
03:39:32 <Kaidelong> @kind IO
03:39:33 <lambdabot> * -> *
03:39:41 <Kaidelong> @kind IO Int
03:39:42 <lambdabot> *
03:40:24 <hpaste> no-n pasted ‚ÄúNestedList a‚Äù at http://hpaste.org/85460
03:40:29 <no-n[3]> I changed it again and get a new error
03:40:44 <Kaidelong> you need to contextualize the instance
03:40:58 <no-n[3]> what does that mean?
03:40:58 <Kaidelong> instance (Show a) => Show (NestedList a)
03:41:04 <no-n[3]> ok
03:41:32 <Kaidelong> so that NestedList a is only an instance of Show in the context of an a that is an instance of Show
03:42:50 <no-n[3]> ahh :)
03:43:00 <hseg> Botje: newline doesn't do that, from checking the code. In addition, converting the newlines to unix-style makes everything work
03:43:10 <hseg> Well, after being forced
03:43:48 <no-n[3]> awesome, got it, thanks
03:45:04 <Kaidelong> hopefully whatever resource made you do that pointed out that you really should just add "deriving Show" to the end of your data declaration
03:45:33 <hseg> So how *should* I parse newlines in my file?
03:46:20 <hseg> Also, why isn't the read forced? Shouldn't sepEndBy try the longest match in the file?
03:53:46 <hseg> Oh. It wasn't an issue in forcing, it's just that since the file was in windows encoding and the parser expected unix encoding, it never found a newline.
03:54:00 <hseg> How do I parse a newline in a platform-independent way?
03:55:46 <Kaidelong> hseg: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#25 is this helpful?
03:56:08 <Kaidelong> I think you could read the file with the mode LF
03:56:36 <hseg> Right. But how do I pass that to parsec's parseFromFile?
03:56:41 <Kaidelong> oh
03:57:02 <Kaidelong> wait, hmm, no that has the good behavior by default
03:57:11 <Kaidelong> I guess I'll go hit parsec's docs
03:57:41 <Botje> poor parsec docs
03:58:40 <hseg> :-) The docs say that newline parses the char '\n'.
03:59:13 <hseg> And according to the linked page in System.IO, this '\n' should be platform-independent.
03:59:44 <hseg> So it's puzzling that Parsec wouldn't recognize the "\r\n" sequence in my input
03:59:52 <hseg> (on windows, btw)
04:00:40 <dcoutts> hseg: if you're using the ordinary System.IO in text mode on windows then it converts \r\n to \n, so the input string should only contain \n
04:00:51 <dcoutts> see the newline mode stuff in System.IO
04:01:20 <hseg> Right. And seeing as Parsec defines parseFromFile in terms of readFile, this conversion should also happen for parseFromFile. But it doesn't
04:11:45 <Kaidelong> hseg: does this only happen for lazy bytestrings?
04:12:06 <hseg> Not sure...
04:12:46 <hseg> I have to leave, as the deadline for this is in 20m. I'll note thebug for later.
04:13:35 <Kaidelong> ugh
04:13:40 <Kaidelong> I was about to suggest something
04:13:58 <Kaidelong> System.IO.hSetBinaryMode h
04:13:59 <hseg> If it's quick, I might be able to test it.
04:14:02 <Kaidelong> where h is the handle
04:14:07 <Kaidelong> or however you call it
04:14:12 <hseg> Don't have a handle.
04:14:21 <hseg> But it would have been a nice idea, though
04:14:38 <Kaidelong> oh right, readFile should do that for you
04:14:40 <Kaidelong> why doesn't it
04:14:58 <Kaidelong> anyway if that is the cause of the problem, then it'll be just the lazy bytestring that has that issue
04:15:28 <hseg> Because lazy bytestring forgot to be platform-independent?
04:16:35 <Kaidelong> either I'm misunderstanding something or readFile f = openBinaryFile f ReadMode >>= hGetContents  should be  readFile f = fmap hSetBinaryMode (openBinaryFile f ReadMode) >>= hGetContents
04:16:55 <Kaidelong> or something like that
04:17:07 <Kaidelong> @type hSetBinaryMode
04:17:08 <lambdabot> Not in scope: `hSetBinaryMode'
04:17:16 <Kaidelong> well it's in IO so that's hardly surprising
04:17:22 <Kaidelong> @hoogle hSetBinaryMode
04:17:23 <lambdabot> System.IO hSetBinaryMode :: Handle -> Bool -> IO ()
04:17:23 <lambdabot> GHC.IO.Handle hSetBinaryMode :: Handle -> Bool -> IO ()
04:18:03 <Kaidelong> so hSetBinaryMode <$> (openBinaryFile f ReadMode) <*> pure true
04:18:30 <Kaidelong> True, been writing C# all day...
04:18:53 <Kaidelong> anyway g'bye hseg good luck
04:19:01 <hseg> Thanks.
04:35:18 <dell> http://hackage.haskell.org/package/HGL any ideas how to make this work with GHC 7.*
04:36:50 <Botje> at a minimum, change the base requirement to match GHC 7
04:36:59 <Botje> and then probably fix a bunch of compile errors
04:50:05 <quchen> Kaidelong: Wait, GHC auto-translates \n to the appropriate line break? I always felt so linuxy using \n in printf
04:50:17 <quchen> So basically \n is a universal line break then?
04:51:10 <Botje> it would be very weird to have length "\n" be different on various systems
04:51:55 <quchen> Botje: The docs sound like that though
04:52:13 <Botje> well, it's the same on various other languages
04:52:15 <Botje> so wouldn't surprise me
04:52:33 <quchen> I'm not sure what the default mode is though. Maybe newline translation has to be enabled explicitly.
04:53:18 <quchen> Oh: "The default NewlineMode for a Handle is nativeNewlineMode, which does no translation on Unix systems, but translates '\r\n' to '\n' and back on Windows."
04:53:26 <quchen> Looks like it really auto-translates by default.
04:53:45 <Botje> ah.
04:53:47 <Botje> nifty.
04:55:16 <Saizan> yep, when reading/writing from handles
04:55:33 <Saizan> in text mode
04:55:39 <quchen> Saizan: Oh, only for handlers? So the Parsec boilerplate I write for this wasn't redundant after all?
04:56:13 <Saizan> *handles
04:56:18 <Saizan> it's an I/O thing
04:56:54 <Saizan> once you get a string with a "\r\n" it stays that way
04:57:04 <quchen> Ah, okay.
04:57:21 <quchen> Speaking of newlines, is there still any \r on OSX?
04:57:33 <quchen> Or was that before they went to Unix
05:02:13 <ocharles> Any suggestions for sending email in Haskell?
05:02:18 <ocharles> mime-mail?
05:07:01 <nlogax> quchen: That was pre OS X, yeah. \n now
05:14:53 <ocharles> mime-mail?
05:14:55 <ocharles> erm..
05:14:57 <ocharles> wrong terminal :D
05:16:31 <Saizan> aa
05:21:37 <merijn> mm_freak: Hmm, one thing I was thinking is that you probably want Widgets to have behave somewhat like a wire of input events to output events, but unlike Netwire wires you probably want to have multiple types of input and multiple types of output events
05:22:00 <merijn> mm_freak: I don't think netwire really lets you do anything like that, does it?
05:28:17 <mm_freak> merijn: a function of events is a wire combinator in netwire, see for example notE
05:28:25 <mm_freak> notE :: (Monad m, Monoid e) => Event e m a -> Event e m a
05:31:57 <jerng> Hello. Can anyone tell me where to find a (instance Show Network.Wai.Request where) and (instance Show  Network.Wai.Response where) ??
05:32:15 <Spockz> Is there also a variant of |cast| that tells me what went wrong instead of giving me a Nothing?
05:34:08 <Philonous_> Spockz:  But there is only one thing that can go "wrong", and that's when the type representation of the argument and target types don't match
05:34:08 <luite> Spockz: what went wrong?
05:34:25 <luite> Spockz: it checks the Typeable hash signature, if that doesn't match it's Nothing
05:34:27 <mm_freak> jerng: nowhere, because there is no sensible Show instance for those
05:34:52 <merijn> mm_freak: Yes, but I meant that they have the type "Wire e m a a", right?
05:34:54 <Spockz> Philonous_: of course, but I would like to get an error message such as can't unify type X with Y?
05:35:18 <mm_freak> merijn: yeah‚Ä¶  so you mean you want a non-fixed 'e'?
05:35:21 <luite> Spockz: it's typeable, you can get a TypeRep and print it
05:35:25 <merijn> mm_freak: i.e. you only have one type of input and output. Rather than accepting several types of input events and several types of output events
05:35:28 <Philonous_> Spockz:  You can create that yourself. Just use typeOf on the argument and target
05:35:47 <mm_freak> merijn: could you give me an example?
05:36:14 <merijn> mm_freak: I'm not sure, I don't think GUI events make sense as being inhibitions of wire?
05:36:28 <mm_freak> merijn: why not?
05:37:03 <merijn> mm_freak: Well, I'm thinking of things like a widget being focused or receiving input, presumably a focus event and input event don't all produce the same type of "input"
05:37:26 <mm_freak> merijn: one way to solve this is to have two wires
05:37:37 <mm_freak> focus :: MyWire Widget Widget
05:37:47 <mm_freak> gotInput :: MyWire Widget String
05:37:59 <merijn> mm_freak: Yeah, that's what I thought. Have one wire per event type
05:38:18 <mm_freak> you could also do this:  widgetEvent :: MyWire Widget Event
05:38:38 <mm_freak> however, then you need explicit event handling, which destroys the potential beauty of a netwire-based GUI library
05:38:44 <merijn> I think I probably want to define my own Arrow-ish GUI type and then instantiate to whatever number of underlying Wires to implement that behaviour
05:39:07 <merijn> mm_freak: Why does that destroy the potential beauty?
05:39:25 <mm_freak> but in the end you will probably do this anyway:  focus :: MyWire Event Event
05:39:38 <mm_freak> in other words, you will always come back to inhibition
05:39:52 <mm_freak> another option is to use ArrowChoice or switching
05:40:12 <mm_freak> ev <- widgetEvent -< widget
05:40:14 <mm_freak> case ev of ‚Ä¶
05:40:28 <merijn> Well, presumably you want your wire behaviour to somehow depend on the state of the widget, which means explicitly passing in the widget when you have more than 1 wire per widget, no?
05:40:41 <jerng> mm_freak: thanks, rolling my own now.
05:40:54 <mm_freak> jerng: have fun showing the body
05:40:55 <jerng> Was also told in the #yesod forum to look at http://hackage.haskell.org/packages/archive/wai-extra/1.3.3.2/doc/html/src/Network-Wai-Middleware-RequestLogger.html
05:41:20 <mm_freak> jerng: a printer for Request has this type:  Request -> IO String
05:41:24 <mm_freak> Request -> String will not work
05:41:34 <jerng> mm_freak: yea, some things like (instance Show Vault where {show _ = "a :: Vault"}) suffice
05:41:49 <mm_freak> jerng: yes, but you still can't show the body
05:42:12 <merijn> Ha! GHC build system makes the same stupid mistake as cabal used too >.>
05:42:25 <mm_freak> merijn: you can make it depend on the state‚Ä¶  you can use inhibition with (<|>) or ArrowChoice or switching
05:42:42 <mm_freak> ArrowChoice lets you use if/case inside proc
05:42:45 <jerng> mm_freak: haven't tried. you'll see it around if it work haha. this is just for debugging.
05:44:13 <dcoutts> merijn: ?
05:45:49 <merijn> dcoutts: I'm trying to build GHC from source and its selectin the wrong working dir. The last time I had these symptoms was with cabal due to autoconf's location parsing and a missing ./ resulting in autoconf searching my path rather than local directories
05:46:18 <merijn> I'll check if I can locate the offending line and whether that solves it in this case too
05:47:24 <merijn> One of those obscure edge cases of someone doing the wrong thing and not noticing because hundreds of people using the code don't accidentally have the wrong file somewhere in their path :p
05:47:29 <quchen> What's the canonical way of catching exceptions of multiple types? For example a function that does IO (hence may fail with IOError), but can also use the error function (ErrorCall). `catches` with type-annotated lambdas seems hacky.
05:48:01 <merijn> quchen: I specify handlers in a where clause (with types) and then use those as arguments to catches
05:48:29 <quchen> merijn: That's still the type-annotated approach then?
05:49:44 <luite> mm_freak: does netwire depend on funky thinks like StableName or other low level tricks?
05:51:51 <merijn> quchen: You only need to type annotate if the proper exception type can't be inferred by your use of the exception in the handler
05:55:08 <quchen> merijn: Right.
05:55:40 * hackagebot SVGFonts 1.2.1 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.2.1 (TillmannVogt)
05:55:49 <quchen> So the "catch rest" clause would then be of type "Exception e => e -> MyError" I assume?
05:55:55 <mm_freak> luite: no
05:56:14 <mm_freak> luite: its implementation is 100% pure non-IO
05:56:15 <quchen> Differentiating between (data) SomeException and (class) Exception confuses me :s
05:59:32 <luite> mm_freak: ah cool, probably easier to get running than reactive-banana then :)
06:00:17 <Spockz> luite: it works now :)
06:00:41 <mm_freak> luite: you need to satisfy the package requirements and the language extensions‚Ä¶  when that works, you're ready to go
06:00:47 <mm_freak> it doesn't use anything weird under the hood
06:01:17 <luite> mm_freak: well ghcjs needs GHC head, so lots of packages need a bit of fixing for new APIs or just accepting the new base version
06:02:18 <parcs> the Exception/SomeException stuff is a way to achieve subtyping
06:09:46 <quchen> parcs: And this couldn't have been solved with ordinary classes?
06:10:24 <quchen> Or a wrapper type
06:15:41 * hackagebot bed-and-breakfast 0.2.1 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.2.1 (JulianFleischer)
06:17:37 <parcs> quchen: dunno
06:30:05 <Taneb> ...I've been pronouncing Yesod horribly wrong
06:30:49 <Cale> Taneb: How were you pronouncing it?
06:30:55 <Taneb> "Yes, odd"
06:31:21 <elliott> yes, that is an odd pronunciation!
06:32:10 <osfameron> how should it be pronounced?
06:32:47 <ab9rf> i always assumed it was "Yee-sod"
06:32:49 <Taneb> yi SOD, with the sod as in soda
06:33:02 <ab9rf> ah, more like sohd
06:33:13 <osfameron> oh, I don't think I'd ever have guessed that
06:33:17 <ab9rf> the european open O instead of the american squashed O
06:33:34 <Taneb> It's a hebrew word, I believe
06:33:35 <Cale> If you know that it's a Hebrew word, you can just think about how Hebrew sounds and make a reasonable guess :)
06:33:42 <ab9rf> americans are all lazy when it comes to their vowels
06:33:48 * osfameron has no idea how hebrew sounds
06:33:49 <Taneb> That's assuming I know how Hebrew sounds
06:33:53 <ab9rf> Cale: nobody really knows what hebrew is supposed to sound like anymore
06:34:01 <ab9rf> Cale: modern hebrew sounds like yiddish
06:34:31 <Cale> Usually when I say English, I don't mean English from the 1600's either :P
06:35:28 <ab9rf> Cale: middle english had way better vowels
06:35:54 <Taneb> And thorn and eth were the best letters
06:35:57 <Kaidelong> I think it's "Yay-sod"
06:36:05 <Kaidelong> or "Yeah-sod"
06:36:09 <Kaidelong> or something inbetween
06:36:40 <Kaidelong> I guess I'm the weirdest
06:36:44 <ab9rf> Taneb: i miss thorn.  thorn was a great letter.
06:37:05 <ab9rf> shame we gave it up.  damn frenchies.
06:37:08 <Kaidelong> english would be less ambiguous if it still had eth and thorn
06:37:12 <Kinnison> ab9rf: what, √æis old √æing?
06:37:24 <Taneb> Kinnison, the second of those should be an eth
06:37:46 <Kinnison> Taneb: feh, I can't remember the compose sequence for eth
06:38:16 <Kinnison> oooh maybe ‚Ç´is
06:38:27 <ab9rf> hm, why the underbar?
06:38:28 <Taneb> "˛is old ing"
06:38:34 <Kaidelong> what about √∞
06:38:45 <Kinnison> ab9rf: no idea where that came from, that was compose d-
06:38:48 <ab9rf> that looks more like it
06:39:05 <dmwit> ?tell hseg I doubt hpaste links are permanent. Also I have no idea what your comment about Coq was supposed to mean.
06:39:05 <lambdabot> Consider it noted.
06:39:15 <Kinnison> Taneb: what's the compose sequence for eth then?
06:39:18 <Kaidelong> at least english didn't get rid of w
06:39:20 <Taneb> I have no idea
06:39:23 <Kinnison> :-(
06:39:27 <Cale> What was hseg's comment about Coq?
06:39:37 <Taneb> I use character map because I can never remember control sequences
06:40:01 <Taneb> Alt Gr+d has it for me?
06:40:04 <Taneb> 
06:40:18 <Kinnison> aah compose dh
06:40:33 <Taneb> With thorn in Alt Gr+p
06:40:38 <Taneb> ˛ﬁ–
06:41:22 <dmwit> Cale: "Don't know Coq, though, so I can't judge that part." Referring to an hpaste, I'll give you the link in a second.
06:41:32 <Cale> dmwit: I know which hpaste he means
06:42:34 <dmwit> Oh, I see that somebody added some Coq. =)
06:42:41 <merijn> dmwit: Well, hpaste's links ar pretty long lasting. I have pastes from months back that still work
06:42:42 <Cale> dmwit: I added a (somewhat inept :) Coq proof in an annotation to his paste :)
06:42:58 * elliott added Coq to that paste too!
06:43:04 <dmwit> ?tell hseg I now understand what your comment about Coq meant. Cale added the Coq, not me. =)
06:43:04 <lambdabot> Consider it noted.
06:43:26 <Cale> elliott: ah, you annotated my post, so hopefully that also annotated his :)
06:43:41 <merijn> Ugh, GHC compilation takes ages :(
06:43:52 <elliott> yes, two Coq files to be confused about rather than just one
06:43:53 <elliott> a clear improvement
06:44:14 <Cale> elliott: Well, yours is maybe easier to follow :)
06:44:55 <ab9rf> i also miss esh
06:45:01 <dmwit> Well, both of these developments start with the definition of (>=>) in terms of (>>=). hseg was trying to make a proof with a definition of (>>=) in terms of (>=>).
06:45:02 <ab9rf> which was still in use into the 1800s
06:45:04 <dmwit> So.
06:45:15 <Cale> Mine is like "I don't know anything about coq, but I'm going to type stuff at it until it says my theorem is proved!"
06:46:28 <ab9rf> Cale: hah
06:46:30 <elliott> Cale: I'm not much better :) you start to see possibilities for automation and ways you can simplify the proof after-the-fact after a while, though
06:46:37 <elliott> but I am still an amateur.
06:46:51 <ab9rf> i tried to use coq a few years ago and that was about what my use amounted to
06:47:11 <ab9rf> "Look, if I type lots of shit into this it will say the theorem os proved but i have no idea what that means."
06:48:09 <Cale> actually, in some regards I feel more confident about the longer and uglier versions of proofs I've done with it
06:48:28 <Cale> The more you automate stuff, the less you get to actually see what's happening.
06:48:41 <Cale> I don't even really like using simpl.
06:49:56 <Cale> (at least, sometimes)
06:51:08 <elliott> simpl is just evaluation, no magic
06:51:36 <elliott> there's a difference between automating trivial stuff, I think, anyway; the kind of details you'd never write out by hand
06:51:48 <Cale> Well, yes, but given that I'm supposed to be writing a proof, I'd like to actually explain which evaluation steps are needed.
06:51:52 <Cale> (sometimes)
06:51:52 <elliott> and abstracting patterns is what we do all the time :)
06:52:06 <dmwit> simpl is more magic than you might think. There's a lot of choices of what you could mean by "just evaluation".
06:52:29 <d01r> hello, I need some help with the Happy parser generator, is there anybody who is familiar with it?
06:52:57 <elliott> dmwit: yeah, it is magic.
06:53:00 <elliott> but it's not maximally magic.
06:53:29 <elliott> the name is more of a hope as to its effect than a description of its implementation :P
06:53:36 <dmwit> How hard do you unfold and refold definitions? How deep do you look for redexes? When do you allow beta reduction? eta reduction? delta reduction? ...the other reductions? Do you evaluate lazily? strictly? somewhere in between?
06:54:08 <elliott> sure, but from the perspective of a user, they shouldn't worry, because they know the result will be "just evaluation".
06:54:11 <dmwit> This is why there's about 80 different tactics that are also "just evaluation" like simpl but useful at different times.
06:54:25 <elliott> the tactic writer has a more stressful life
06:54:46 <luite> mm_freak: after fixing a minor issue with the build system, netwire at least compiles fine with ghcjs now :) now to see if it works
06:55:38 <Cale> elliott: My point is that if I type something into the machine, and it does a bunch of steps without telling me what those were -- even if it arrives at a result which is what I'm ultimately after, I'm not necessarily very happy in the context of trying to give an exposition of why something is true.
06:56:28 <Cale> If my only goal is convincing the machine that it's true, then that's fine
06:56:38 <aCube> Is there an extension that allows to use type variables of the functions context?
06:57:00 <Cale> aCube: sounds like ScopedTypeVariables?
06:57:24 <dmwit> ?where just ask
06:57:24 <lambdabot> I know nothing about just.
06:57:34 <elliott> Cale: sure. at the same time, if you have to spend your time teaching the machines formalities that your reader already knows -- or doesn't even know are things worth knowing (e.g. details relating to Coq's limitations and the necessity of encoding stuff for it) -- then readability suffers if you include those details explicitly
06:57:37 <Cale> aCube: you'll need to explicitly forall your type variables in order to have them scope over the rest of the definition
06:58:09 <Cale> elliott: Yeah
06:58:10 <elliott> automation serves the dual goal of increasing readability and easing the pain of writing proofs, even if it can be misused
06:58:23 <elliott> (and I don't think Coq tactics are perfect in this respect; they are pretty "low level")
06:58:28 <dmwit> ?where+ justask Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
06:58:29 <lambdabot> Okay.
06:58:41 <dmwit> d01r: That's for you, too, by the way. =)
06:59:16 <Cale> elliott: Basically, you want to be able to say where you're going next, and if there's a way to automate the arrival at that goal, then that's great.
06:59:17 <d01r> perfect thanks :) question incoming :)
06:59:35 <aCube> Cale: thanks, that was what I was looking for. Is it possible to write code that is writting with ScopedTypeVariables without them?
06:59:53 <Cale> aCube: often, but not always
07:00:02 <elliott> Cale: -- in addition, the "sequential" nature of longform unstructured tactics proofs makes them almost impossible to read without going through each line manually; if you automate much of it away (especially using things like (p; q) for "do p, then discharge all generated subgoals with q" -- very useful), then it can be read in a more structured form without stepping through it at all
07:00:04 <dmwit> aCube: yes, using type-restricted things like asTypeOf and asAppliedTo
07:01:03 <Cale> elliott: The stuff that actually ends up in the source file is almost useless for reading, I find, without watching what happens to the subgoal context.
07:01:11 <Cale> (at least in my experience)
07:01:23 <elliott> Cale: right: that's a sign your proofs could be more readable
07:01:37 <elliott> (compare: the kind of imperative code you can't understand without tracking state in your head or using a debugger or such)
07:01:40 <merijn> How can I guesstimate how far my ghc build is along? I wanna know if it's worth waiting to finish or whether I should just hibernate my machine and go home :p
07:01:56 <elliott> I'm very good at writing unreadable proofs and do it all the time, so I think I am quite good at spotting how they are unreadable :P
07:01:57 <Cale> merijn: Why are you compiling GHC?
07:02:16 <Cale> merijn: also, are you using make -j# ?
07:02:20 <merijn> Cale: Because "type instance where" isn't valid syntax in 7.6
07:02:30 <Cale> okay
07:02:31 <merijn> ah crud
07:02:31 <dmwit> Cale: It's possible for Coq experts to write Coq code that is readable to other Coq experts.
07:02:39 <merijn> I forgot -j >.>
07:03:04 <d01r> I need the Happy parser to generate, along with the parse tree, the appropriate line numbers for use within the type checker. Does somebody know how to do that? I'm not very expert with monads :)
07:03:05 <merijn> It's about an hour and a half into the build
07:03:19 <Cale> merijn: You can just stop it without losing progress
07:03:19 <luite> merijn: you can guess a bit by checking whether it's using the boot ghc, stage1 or stage2
07:03:28 <merijn> and afaik 7.7/snapshot binaries aren't available for OSX
07:03:39 <ab9rf> d01r: that requires using a lexer that captures line numbers
07:03:45 <dmwit> d01r: Have you tried looking at the code in some projects that use happy? That seems like a common enough need that it would definitely be covered.
07:03:45 <merijn> stage1
07:03:49 <luite> OS X builds ahve been rather unpredictable for me unfortunately :(
07:04:03 <luite> often crashing or unusable compiler
07:04:10 <luite> i switched ghcjs development to linux because of that
07:04:35 <parcs> if you didn't edit mk/build.mk then you're tripling your build time (by building profiling and dyn versions of each module)
07:05:06 <mm_freak> luite: that's reassuring =)
07:05:19 <Cale> okay, well, I'd better get a little bit more sleep so that I can do some useful work today, bbl
07:05:45 <dmwit> ?localtime Cale
07:05:45 <lambdabot> Local time for Cale is Tue Apr  9 10:05:34
07:05:50 <dmwit> yikes, sleep well
07:05:52 <luite> mm_freak: do you have some simple examples for gtk, like a calculator that adds two text fields? that i can try to port to ghcjs
07:06:02 <Cale> (I'm just short a few hours)
07:07:44 <d01r> dmwit: mmm do you know any projects that are based on happy?
07:10:59 <hpaste> marekw2143 pasted ‚Äúmax_product‚Äù at http://hpaste.org/85479
07:11:14 <fryguybob> d01r: GHC?
07:11:24 <d01r> ab9rf: actually the parser knows about line numbers and uses them itself when it encounters an error, but I don't know how to tell Happy that I want as output of the parser something like a tree with line numbers
07:11:40 <hpaste> aCube pasted ‚ÄúRewrite this without ScopedTypeVariables?‚Äù at http://hpaste.org/85480
07:12:16 <marekw2143> why code at: http://hpaste.org/85479 produces error at 12'th line: No instance for <Num Char> ?
07:12:46 <merijn> aCube: you could put the monoid constraint on the X typeclass
07:12:50 <marekw2143> sorry, error occurs at 7'th line of the paste
07:13:04 <merijn> aCube: i.e. "class Monoid i => X i f where"
07:13:27 <merijn> aCube: Of course, that means it's impossible to define instances where i is not a monoid...
07:13:30 <marekw2143> ohh, I know :)
07:13:45 <d01r> fryguybob: mmm thanks :) i'll try looking at its sources but it sounds like a very complex example
07:13:46 <marekw2143> should pass list of nubmers instead of String
07:13:51 <aCube> merijn: Are there any other ways?
07:14:06 <fryguybob> d01r: Yeah
07:14:21 <merijn> aCube: I don't think so, tbh
07:14:56 <mm_freak> luite: sorry, there is no GUI wrapper yet‚Ä¶  you'll have to do that yourself‚Ä¶  however, i have a small SDL/OpenGL demo, if that helps
07:15:07 <mm_freak> luite: http://hpaste.org/83098
07:16:31 <aCube> merijn: ok, thanks.
07:16:38 <luite> mm_freak: oh that's no problem
07:17:13 <luite> mm_freak: i have javascript event listeners that run an IO action, if that can be used to feed something to netwire it should be ok :)
07:22:23 <mm_freak> good news for some of you guys‚Ä¶  i've finally started to work on a new version of fastirc =)
07:22:39 <mm_freak> https://github.com/ertes/fastirc
07:24:13 <donri> mm_freak: yay!
07:25:41 <donri> mm_freak: not based on netwire? or will that be a separate lib
07:25:46 <merijn> Yay! GHC build is done, time to see if it works!
07:27:18 <mm_freak> donri: not based on netwire
07:27:31 <mm_freak> it's a parser/conduit library‚Ä¶  the session library will be separate now
07:27:47 <donri> not pipes eh
07:29:30 <d01r> just for the sake of completeness i thought that a solution would be to add the line number to each node of the abstract tree generated by the parser, but i'd like to find a more elegant and transparent solution, and maybe you can do that with monads without changing the data structure by keeping the line numbers as some kind of state
07:29:37 <d01r> is that possible?
07:30:25 <Cale> Not in any way which doesn't annotate the tree
07:32:01 <lemao> is it possible to enforce an interface for exported FFI functions? I.e. I want to use Haskell to create a dynamic library that MUST export a set of specific functions and I may need to create any number of different implementations. type classes for foreign functions would be perfect
07:32:14 <mm_freak> donri: conduit is easier to use and faster
07:32:42 <mm_freak> i know about the theoretical advantages of pipes, but conduit has practical advantages
07:33:30 <d01r> Cale: ok :) thank you for your answer :) i'm happy to know it can't be done in any other way :)
07:33:39 <merijn> I can't have record syntax in my GADTs, right?
07:33:44 <d01r> Cale: now i have my mind in peace :P
07:34:41 <Cale> d01r: Well, I guess you could encode somehow paths to nodes of the tree along with their line number information, separate from the tree. But that quickly becomes awkward to manipulate.
07:34:59 <lemao> I basically want haskell to help me enforce statically that I am conforming to the exported C interface
07:35:35 <lemao> across N different shared libs I build with haskell
07:35:37 <donri> mm_freak: i thought pipes was faster in the benchmarks
07:35:48 * hackagebot bed-and-breakfast 0.2.2 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.2.2 (JulianFleischer)
07:35:54 <donri> and easier to use since you can reason with the category laws ;)
07:38:10 <d01r> Cale: mmm would it be ok to use a second tree mirroring the first one just to store the line numbers?
07:38:30 <merijn> Oh, wait, I can have record syntax in GADTs :D
07:38:48 <Sculptor> hello
07:40:40 <ocharles> donri: no, conduit is still faster, but imo the difference is neglible
07:40:47 <donri> aha
07:40:48 * hackagebot esqueleto 1.0.8 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.0.8 (FelipeLessa)
07:40:55 <ocharles> donri: I'd take category laws over conduit's raw speed
07:40:59 <ocharles> (for most things)
07:41:20 <donri> i guess though if you're calling your library "fastirc" ...
07:41:35 * ocharles only read the last few lines of scroll back :)
07:45:50 <mm_freak> donri: so far there is no dependency on conduit/pipes, so i can still switch
07:47:01 <mm_freak> another reason for me to prefer conduit is that there is more ready-made stuff for it
07:47:55 <aCube> Is there a reverse such that (take 10 . reverse . reverse) [1..] == [1..10]?
07:48:26 <Philippa> aCube: of course not
07:49:20 <Eduard_Munteanu> Well, you could do that as a RULES thingy, but I'm unsure you'd want that.
07:49:29 <mm_freak> you don't
07:49:34 <Eduard_Munteanu> (reverse . reverse = id, I mean)
07:50:04 <mm_freak> note, reverse . reverse = id is true regardless of that
07:50:21 <aCube> > reverse . reverse $ [1..]
07:50:25 <mm_freak> up to strictness =)
07:50:26 <lambdabot>   mueval-core: Time limit exceeded
07:50:29 <aCube> :)
07:50:43 <Kaidelong> is it?
07:50:50 <Philippa> aCube: what does the end of an infinitely-long list look like?
07:51:15 <mm_freak> i think, 'reverse' is wrong all by itself, but unfortunately haskell's type system can't enforce that =)
07:51:17 <Kaidelong> how could you get f . reverse . reverse to be as total as f . id just by changing how strict you are
07:51:23 <mm_freak> 'reverse' shouldn't exist for lists
07:52:55 <Kaidelong> actually come to think of it, hmm
07:52:59 <Kaidelong> > id [1..]
07:53:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:53:09 <Kaidelong> > reverse . reverse $ [1..]
07:53:14 <lambdabot>   mueval-core: Time limit exceeded
07:53:19 <byorgey> "pi goes on and on and on / and e is just as cursed. / I wonder, which is larger / when its digits are reversed?"
07:53:35 <_mr> hehe
07:53:54 <byorgey> -- Martin Gardner
07:54:25 <Kaidelong> id =/= reverse . reverse
07:54:45 <Kaidelong> trying to find conal's silly symbol for the relation they did have
07:54:46 <osfameron> byorgey: nice
07:54:47 <DrSyzygy> byorgey: Isn't that just a question of their 10-adic expressions? Should be ... kinda computable, right?
07:54:53 <osfameron> Martin Gardner was a clever chap
07:55:27 <byorgey> DrSyzygy: hehehe
07:55:36 <mm_freak> snoyberg: but that gets me thinking‚Ä¶  are there any cases where you would prefer to use pipes instead of conduit?
07:55:53 <byorgey> DrSyzygy: I assume the poem is referring to their *decimal* representations, though of course it doesn't specify... =)
07:57:03 <DrSyzygy> byorgey: That's actually kinda my point
07:57:47 <byorgey> DrSyzygy: hmm, then I don't understand your point
07:58:05 <aCube> Well, would that what I asked for be possible with Data.Sequence?
07:59:02 <Eduard_Munteanu> Hm, maybe.
07:59:30 <nh2> what is FUN_2_0 in a heap profile?
07:59:49 <aCube> hp2ps
07:59:50 <Eduard_Munteanu> Actually, I think so.
08:00:14 <aCube> Eduard_Munteanu: I fail to construct an infinitely long Data.Sequence
08:01:36 <Eduard_Munteanu> Hm, not *any* Data.Sequence though.
08:02:11 <aCube> Eduard_Munteanu: ?
08:02:24 <aCube> Eduard_Munteanu: What do you mean by *any*? There is only one Data.Sequence?
08:02:42 <Eduard_Munteanu> No, it depends how you construct it.
08:03:11 <aCube> Eduard_Munteanu: how do I construct a Sequence with the numbers [1..] ?
08:04:06 <nh2> aCube: what do you mean with hp2ps?
08:04:45 <aCube> nh2: FUN_2_0 sounds like you're reading the profile output text file? Or did you already convert it to ps/pdf?
08:04:55 <Eduard_Munteanu> aCube: I don't think it works in that particular case. Consider something like  fromList [1..] |> 0
08:05:14 <Eduard_Munteanu> Actually, hm.
08:06:00 <nh2> aCube: no, that's what is says in my ps file
08:06:33 <aCube> Eduard_Munteanu: how do you access the last element of a sequence? :P
08:06:33 <Eduard_Munteanu> > Data.Sequence.reverse $ Data.Sequence.fromList [1..] |> 0
08:06:37 <lambdabot>   mueval-core: Time limit exceeded
08:06:52 <Eduard_Munteanu> aCube: viewr
08:06:59 <Eduard_Munteanu> :t viewr
08:07:02 <lambdabot>     Not in scope: `viewr'
08:07:02 <lambdabot>     Perhaps you meant one of these:
08:07:03 <lambdabot>       `Seq.viewr' (imported from Data.Sequence),
08:07:09 <Eduard_Munteanu> :t Seq.viewr
08:07:11 <lambdabot> Seq.Seq a -> Seq.ViewR a
08:07:21 <Eduard_Munteanu> @src Seq.ViewR
08:07:21 <lambdabot> Source not found.
08:07:49 <aCube> > S.viewr $ S.fromList [1..] S.|> 0
08:07:51 <lambdabot>   Not in scope: `S.viewr'
08:07:51 <lambdabot>  Perhaps you meant `Seq.viewr' (imported from Data....
08:07:57 <aCube> > Seq.viewr $ Seq.fromList [1..] Seq.|> 0
08:08:02 <lambdabot>   mueval-core: Time limit exceeded
08:08:14 <aCube> Hmm, I think the problem is that the underlying Tree is not lazy
08:10:31 <Breadmonster> Okay, so I've been doing SICP.
08:10:42 <Breadmonster> And I read that call by name is much slower than call by value.
08:10:49 <Breadmonster> How does Haskell execute so fast then?
08:14:20 <Taneb> Breadmonster, it's call by need
08:14:31 <Taneb> Which is sort of like call by name, but better
08:14:44 <Breadmonster> Taneb: Ah, thank you.
08:14:58 <Taneb> (it's to do with sharing)
08:17:09 <aCube> @src foldr
08:17:09 <lambdabot> foldr f z []     = z
08:17:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:18:40 <parcs> nh2: FUN_2_0 is a function that's holding on to 2 heap objects and 0 primitive heap objects (i.e. bytearrays)
08:19:11 <Eduard_Munteanu> All that about "need" and "sharing" sounds like a communist quote I can't remember now. :P
08:19:33 <aCube> @src foldl
08:19:34 <lambdabot> foldl f z []     = z
08:19:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:19:44 <nh2> parcs: has the "holding on" anything to do with the number of parameters?
08:21:26 <int-e> parcs: but bytearrays are heap objects; the second one is a number of non-pointers like Int# (or uninterpreted pointers, Addr#).
08:21:54 <parcs> oh, okay
08:21:58 <parcs> nh2: i'm not sure
08:22:03 <nh2> also, I would love to find out which function that is
08:22:21 <nh2> parcs, int-e: how do you know this stuff? is there public documentation about this?
08:22:33 <MOMI> Hi in this example:
08:22:34 <MOMI> [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
08:22:35 <MOMI> ghci> b !! 2
08:22:35 <MOMI> [1,2,2,3,4]
08:22:49 <MOMI> why it isnt [5,3,3,3]
08:22:49 <parcs> nh2: i asked the same question a month or two ago :P
08:23:05 <int-e> nh2: it's open source. (also, there are papers on STG, and there's a wiki with commentary. I couldn't say where I initially found this information.)
08:23:22 <supki> > [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] !! 2
08:23:24 <lambdabot>   [5,3,3,3]
08:23:37 <supki> MOMI: ?
08:23:52 <MOMI> http://learnyouahaskell.com/starting-out
08:24:00 <MOMI> ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
08:24:00 <MOMI> ghci> b
08:24:00 <MOMI> [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
08:24:00 <MOMI> ghci> b ++ [[1,1,1,1]]
08:24:00 <MOMI> [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
08:24:00 <MOMI> ghci> [6,6,6]:b
08:24:00 <MOMI> [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
08:24:01 <MOMI> ghci> b !! 2
08:24:01 <MOMI> [1,2,2,3,4]
08:24:13 <nh2> int-e: "it's open source" means "you have to read GHC code because nobody bothered explaining how to read all things that can appear in a heap profile", I guess?
08:24:15 <elliott> please don't paste long things into the channel
08:24:16 <int-e> MOMI: 0 is the first list element.
08:24:19 <aCube> > let b = http://en.wikipedia.org/wiki/Special:Search?go=Go&search=6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3 in b !! 2
08:24:21 <elliott> use http://hpaste.org/
08:24:21 <lambdabot>   <hint>:1:55: parse error on input `='
08:24:28 <aCube> > let b = [ [6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3] ] in b !! 2
08:24:29 <lambdabot>   [5,3,3,3]
08:25:00 <MOMI> so it uses the original b not the updated one
08:25:15 <int-e> nh2: actually the intended meaning was closer to "I read the source, so unfortunately I can't give a better reference". but I might have phrased it better.
08:25:18 <supki> MOMI: you can't update b
08:25:44 <nh2> int-e: ah, I see, so there *might* actually be documentation somewhere
08:25:47 <MOMI> ah mutable
08:25:53 <MOMI> i get it now
08:26:08 <MOMI> Thanks and sorry for the long text will use hpaste
08:26:10 <int-e> nh2: what you said is not completely wrong though; the precise collection of heap objects in ghc is a moving target.
08:28:09 <nh2> concerning this I also think the haskell community clinging to papers is a development smell. Papers have their place, but if I'm using a tool at version X, I need documentation for version X, not the "we present a method ..." idea for the original version
08:28:35 <nh2> but that's just my opinion, my actual question is:
08:28:44 <nh2> can I find out which function that FUN_2_0 is
08:29:07 <nh2> because, as you can guess, I have a stack space overflow and my program terminates
08:47:03 <DrSyzygy> byorgey: l-adic is "kinda" like base l in reverse; especially when it comes to the resulting topology.
08:48:14 <byorgey> DrSyzygy: oh, I see, so you're proposing to squint at the definition of "reversed".  fair enough. =)
08:48:24 <mm_freak> donri: i'll give pipes a shot for fastirc =)
08:48:34 <mm_freak> implementing an experimental line splitter now
08:49:25 <donri> mm_freak: cool. that might exist in pipes-{bytestring,parser} on github
08:49:57 <arkeet> who's talking about l-adics?
08:50:49 <mm_freak> donri: i know, but i have special needs which i implemented a long time ago for enumerator in the netlines package
08:52:26 <arkeet> oh, I scrolled up.
08:53:00 <arkeet> you don't have an ordering, so the question doesn't make sense
08:55:28 <mm_freak> the IRC RFC is so stupid‚Ä¶
08:55:34 <mm_freak> "the null byte is not allowed"
08:55:51 <mm_freak> great, and that's why nobody will ever send a null byte
08:56:11 <Clint> wut
08:56:39 <Philippa> mm_freak: it's why servers should drop any client that does rather than repeating their messages
08:57:19 <mm_freak> Philippa: in a generic IRC library that doesn't seem like a proper reaction
08:57:27 <mm_freak> unfortunately i don't know what a proper reaction would be
08:59:13 <Clint> what does a generic IRC library do with other invalid input?
08:59:46 <mm_freak> Clint: ignore it
08:59:56 <Clint> so why is a NUL different
09:00:12 <mm_freak> because a generic library should not hide stuff
09:02:26 <typoclass> mm_freak: how do you mean? the irc rfc should have provisions for when you want to send null bytes?
09:02:45 <mm_freak> typoclass: you never send null-bytes in a valid IRC session
09:04:07 <typoclass> mm_freak: yeah that's what i mean. you never want to do that anyway, and it seems appropriate that the protocol would say "not allowed"
09:04:26 <mm_freak> typoclass: what does "not allowed" mean?
09:05:02 <Clint> that means a conformant implementation doesn't send NULs
09:05:35 <typoclass> mm_freak: oh that's what you mean. yeah it could be phrased more clearly
09:05:55 <arkeet> the way I'm interpreting rfc1459, a NUL would cause a parse error.
09:06:06 <typoclass> mm_freak: as a guess, you could treat it like some other kind of malformed unparseable message
09:07:34 <mm_freak> yeah, probably
09:14:13 <arkeet> are there any multi-byte encodings that use bytes 00, 0a, 0d, 20 when encoding characters other than NUL, LF, CR, or space?
09:15:04 <arkeet> hmm, UTF-16.
09:18:50 <arkeet> it's too bad IRC doesn't have any provisions for different encodings.
09:22:35 <ab9rf> arkeet: IRC has no provision for encoding, period
09:22:48 <merijn> Yeah, now I'm not allowed to use utf-8 in my nick :(
09:23:25 <arkeet> well, the rfc clearly specifies which bytes are allowed in a nick
09:23:41 <dmwit> d01r: Hm, I was going to suggest a reverse dependency search for "happy", but happy is a program, not a library...
09:23:54 <ab9rf> IRC is a bytestream protocol.  the interpretation of IRC payloads as text is entirely optional and is not mandated by the specification.
09:24:04 <arkeet> on the other hand,
09:24:18 <arkeet> any bytes other than space, cr, lf, nul are allowed in a username!
09:24:26 <Sculptor> ab9rf, and yet, microsoft chat users always get kicked
09:24:31 <Sculptor> comic*
09:24:38 <dmwit> arkeet: That doesn't sound right.
09:24:39 <ab9rf> Sculptor: that's a social rule :)
09:24:46 <ab9rf> dmwit: it's true though
09:24:48 <Sculptor> ;)
09:24:51 <dmwit> arkeet: Usernames are more strict than messages, aren't they?
09:24:51 <arkeet> <user>       ::= <nonwhite> { <nonwhite> }
09:24:58 <arkeet> <nonwhite>   ::= <any 8bit code except SPACE (0x20), NUL (0x0), CR (0xd), and LF (0xa)>
09:24:59 <ab9rf> you can put damn near anything in the unparsed username field
09:25:17 <ab9rf> it's not used for any "real" purpose, so the server doesn't really care
09:25:23 <Clint> it's amazing that there have been no successful irc replacements in all this time
09:25:33 <arkeet> too much inertia.
09:25:51 <ab9rf> Clint: there's two or three competing server bases but they more ro less interoperate and all of them interop with the gazillion different clients
09:26:01 <ab9rf> and not enough market
09:26:14 <c_wraith> how would you improve on IRC as a user experience in a way compelling enough to convince IRC users to switch?
09:26:23 <ab9rf> multiuser text chat is not high demand
09:27:06 <Clint> well, fix "routing" for one thing
09:27:18 <Clint> then fix charsets
09:27:25 <c_wraith> Neither of those are compelling
09:27:28 <dmwit> arkeet: I suppose you are claiming that Freenode does not conform to the spec, then? That seems reasonable enough.
09:27:38 <c_wraith> If they were, people would have switched away from IRC already
09:27:39 <levi> Not enough demand for something better. Not a lot of group chats outside of hard-core techies, and XMPP handles those that are demanded well enough.
09:27:44 <dmwit> That claim seems reasonable enough, I mean.
09:27:54 <arkeet> RFC 1459 is missing a lot of stuff that all modern IRC implementations do.
09:28:02 <Clint> c_wraith: well, right
09:28:06 <ab9rf> levi: there actually is a significant market, but they're met within the broader app
09:28:16 <ab9rf> that being "chat rooms" associated with live sex video streams
09:29:02 <ab9rf> arkeet: to be fair, rfc 1459 is from 1993
09:29:17 <ab9rf> arkeet: did you check RFCs 2810 through 2813?
09:29:30 <arkeet> yeah I know there are more.
09:29:56 <ab9rf> those are from 2000
09:30:04 <ab9rf> that's all the IRC-related RFCs there are, though
09:30:29 <ab9rf> lilo and i worked on speccing a next-gen IRC back in 2000, but we could not get anywhere on it
09:30:54 <ab9rf> there wasn't any compelling reason to move off the existing architecture
09:30:55 <Philonous_> Clint:  Depends on your definition of "successful". There's XMPP MUC
09:31:18 <ab9rf> and the complexity of maintaining compatibility with existing clients was also a concern
09:31:22 <Clint> Philonous_: yes, there are plenty of things that work and that i don't use
09:32:27 <ab9rf> IRC could desparately use better server-to-server routing, and a more intelligent database convergence approach
09:33:06 <Clint> and that was true in the '90s
09:33:21 <djahandarie> ab9rf, one can get pretty creative ever with the existing protocols.
09:33:23 <ab9rf> the requirement for a strict tree routing architecture is what makes netsplits so problematic
09:33:41 <ab9rf> especially because of the requirement for flooding of all database-altering messages
09:33:47 <ab9rf> whcih often results in cascade splits
09:34:19 <jerng> Hi! Anyone know how I can apply (show) to data of type (ResourceT IO ByteString) ?
09:34:33 <ab9rf> djahandarie: keeping the server-client protocol while ditching the server-server protocol is the obvious thing to do.
09:34:41 <Clint> jerng: you can't
09:34:44 <djahandarie> ab9rf, I mean even with the existing server-server protocol.
09:34:53 <dmwit> jerng: Sounds difficult or impossible, depending on the exact details of ResourceT.
09:34:57 <arkeet> jerng: you can't, and you probably are thinking about it wrong if you are trying to.
09:35:06 <Philonous_> jerng:  You probably want show `fmap` <youraction> , it will be of type  ResourceT IO String
09:35:07 <ab9rf> djahandarie: meh, they really should agument it with a datagram approach
09:35:13 <jerng> clint: ok then, so how would I debug the value of ByteString?
09:35:26 <syntaxfree> hi. Is Data.Tree.KdTree included by default in "stock" GHC?
09:35:50 <djahandarie> ab9rf, there's certainly a lot of improvements, but fact is that most ircds are written in C and it's simply a nightmare to try to make such a massive change to C programs like that.
09:35:52 <dmwit> syntaxfree: Almost certainly not.
09:35:53 <ab9rf> djahandarie: a lot of netsplits could be avoided if best-effort instead of guaranteed-sequenced were used for database transactions
09:36:25 <syntaxfree> ok, is there a way to find out whether an arbitrary hackageDB package is?
09:36:28 <Clint> jerng: depends what you mean by "debug"
09:36:29 <typoclass> syntaxfree: if this is what you mean http://hackage.haskell.org/packages/archive/KdTree/0.2/doc/html/Data-Trees-KdTree.html then no. the package name is given at the top in the dark blue bar (KdTree)
09:36:44 <djahandarie> ab9rf, you can already avoid the large majority of netsplits, if you're creative enough! I'd elaborate but don't want to leak trade secrets ;p.
09:36:50 <jerng> clint: send to stdout, convert to any visible form.
09:37:05 <ab9rf> djahandarie: heh
09:37:07 <dmwit> syntaxfree: perhaps Hayoo knows
09:37:09 <typoclass> syntaxfree: in general you can use hayoo, or just google it
09:37:11 <typoclass> @where hayoo
09:37:11 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
09:37:18 <ab9rf> djahandarie: there are all sorts of ways to avoid them, but none of them have been implemented in IRC :)
09:37:29 <typoclass> dmwit: yes it does find stuff for "kdtree"
09:37:32 <Philonous_> jerng:  You can print it inside a (ResourceT IO) computation with (liftIO . print)
09:37:37 <syntaxfree> ok. Is there a short tutorial readable by people who've only done PHP in their lives that will be installing GHC and this package to compile some code I will be writing?
09:37:40 <Clint> jerng: runResourceT it, then >>= it to print or something
09:37:48 <ab9rf> syntaxfree: you're making me twitch
09:38:00 <djahandarie> ab9rf, I handle a lot of the technical stuff on Rizon BTW. We do some interesting things there, though we haven't gone all the way to the ideal model yet. I'd say we're 70% there.
09:38:02 <jerng> clint: thanks for the pointer to runResourceT
09:38:11 <dmwit> syntaxfree: "apt-get install ghc && cabal install KdTree"?
09:38:22 <ab9rf> djahandarie: ah
09:38:58 <dmwit> syntaxfree: Or better yet, set up the code you're going to write as a cabal package, and then replace "cabal install KdTree" with "cabal install syntaxfree'samazingpackageofdelight"
09:39:01 <bxc_> hmm anyone got ideas off top of head why cabal on a windows machine would sit and not use much CPU or network, but build things incredibly slowly (eg minutes to come up with first line of output)
09:39:05 <bxc_> ?
09:39:26 * bxc_ doesn't know much about running this stuff on windows...
09:39:34 <bxc_> but my own windows VM builds nice and snappy
09:52:50 <ab9rf> b00p
09:52:54 <ab9rf> beh
09:55:38 <hello> http://csgmta.net/forum/index.php?action=forum check this
10:01:33 <rzh> Is there any archive for this channel.. such as a web site, so I can check any day's chat log?
10:01:48 <typoclass> rzh: yes, on tunes.org. check the channel topic, it has a link
10:02:37 <rzh> oh, saw it. thanks!
10:14:47 <merijn> Is there a type level equivalent of _?
10:15:36 <arkeet> it would be nice.
10:15:46 <merijn> It would be brilliant, even
10:15:56 <arkeet> I've wanted it at least a few times.
10:16:13 <merijn> I'll take that as an unfortunately not...
10:16:30 <arkeet> of course, it has the same effect as just using a fresh type variable.
10:17:24 <magicman> @type [] :: [_a]
10:17:26 <lambdabot> [_a]
10:17:38 <magicman> Not quite, but it's something.
10:18:04 <arkeet> :t _1 :: (_2 -> _3 _4) -> (_5,_6) -> _7 (_8,_9)
10:18:05 <lambdabot>     Couldn't match type `_10' with `_14'
10:18:05 <lambdabot>       `_10' is a rigid type variable bound by
10:18:05 <lambdabot>             an expression type signature:
10:18:08 <arkeet> oops.
10:18:21 <arkeet> :t _1 :: Functor _3 =>  (_2 -> _3 _4) -> (_5,_6) -> _3 (_7,_8)
10:18:23 <lambdabot>     Could not deduce (Field1 (_11, _12) (_13, _14) _9 _10)
10:18:23 <lambdabot>       arising from a use of `_1'
10:18:23 <lambdabot>     from the context (Functor _3)
10:18:29 <arkeet> oh right.
10:18:32 <arkeet> :t _1 :: Functor _3 =>  (_2 -> _3 _4) -> (_5,_6) -> _3 (_7,_6)
10:18:33 <lambdabot>     Could not deduce (Field1 (_10, _11) (_12, _11) _8 _9)
10:18:33 <lambdabot>       arising from a use of `_1'
10:18:33 <lambdabot>     from the context (Functor _3)
10:18:35 <arkeet> nope.
10:18:37 * arkeet dies
10:18:41 <magicman> <_<
10:19:04 <arkeet> :t _1 :: Functor _2 =>  (_3 -> _2 _4) -> (_3,_5) -> _2 (_4,_5)
10:19:05 <lambdabot> Functor _2 => (_3 -> _2 _4) -> (_3, _5) -> _2 (_4, _5)
10:26:08 <bxc_> hmm
10:26:34 <bxc_> when i am caballing on this one windows system I get R6016 not enough space for thread data, at which point the previously fast builds go all slow
10:28:04 <drostie> So I was curious to find a Functor which was not Applicative even though it implements `pure`, since probably ((,) t) could be one where it would be hard to generically implement pure.
10:28:17 <bxc_> all i can see in google is stuff that suggests its the program interacting with c++ runtime incorrectly.
10:28:26 <drostie> It strikes me that you need then a non-invertible wrapping of data?
10:28:48 <arkeet> even applicatives have non-invertible wrapping of data.
10:29:26 <byorgey> drostie: I doubt you will find any.  There are not many functors which are not applicative, period.
10:29:38 <arkeet> there aren't?
10:29:41 <drostie> Well yeah, but that's my point. That you'd need, like, the data type which comes out of destroyHalfOfHumanity x.
10:29:56 <drostie> (and less generic than IO.)
10:30:47 <drostie> so that you could say "given destroyHalfOfHumanity (a -> b), I cannot actually construct a -> b for you again."
10:34:05 <drostie> Oh, I guess the parametric type which isn't actually parametric is a trivial case.
10:34:21 * elliott thinks there are quite a few non-applicative functors but mainly because of pure
10:37:02 <klrr> ?src foldl
10:37:02 <lambdabot> foldl f z []     = z
10:37:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:37:11 <klrr> ?src foldl1
10:37:11 <lambdabot> foldl1 f (x:xs) = foldl f x xs
10:37:11 <lambdabot> foldl1 _ []     = undefined
10:37:26 <klrr> foldl1 is more like map?
10:37:54 <merijn> klrr: No, foldl1 is foldl but it uses the first elements of the map as initial elements
10:38:34 <klrr> merijn: it's like map but it returns a total value, not a list
10:38:48 <merijn> i.e. "foldl (+) 0 [1..10]" == "foldl1 (+) 0:[1..10]"
10:39:10 <merijn> it can return a list
10:39:20 <merijn> I think?
10:39:22 <merijn> :t foldl1
10:39:23 <lambdabot> (a -> a -> a) -> [a] -> a
10:39:35 <merijn> It can return a list if it's a list of lists :p
10:40:04 <merijn> klrr: The way you use "total value" is not a meaning many people here would associate with total
10:40:09 <typoclass> klrr: there's really not much practical difference between foldl and foldl1, only the issue that "foldl1 ... []" will give an exception while "foldl ... 42 []" will give 42 instead
10:40:14 <Mortchek> > let map f xs = foldr (\x xs -> f x:xs) [] xs in map (+1) [1, 2, 3]
10:40:16 <lambdabot>   [2,3,4]
10:40:31 <typoclass> merijn: klrr means as in 'sum total'
10:40:33 <merijn> Or rather, I'm not sure what you mean by it and my idea of "total" doesn't relate to the things you are saying
10:41:05 <klrr> what's the diff between foldr and foldl?
10:41:10 <Mortchek> :t foldr
10:41:11 <Mortchek> :t foldl
10:41:11 <lambdabot> (a -> b -> b) -> b -> [a] -> b
10:41:13 <klrr> fold left fold right?
10:41:13 <lambdabot> (a -> b -> a) -> a -> [b] -> a
10:41:20 <merijn> > foldr f z [a,b,c,d]
10:41:21 <lambdabot>   f a (f b (f c (f d z)))
10:41:25 <merijn> > foldl f z [a,b,c,d]
10:41:26 <lambdabot>   f (f (f (f z a) b) c) d
10:41:49 <Mortchek> foldl's type really ought to be (b -> a -> b) -> b -> [a] -> b
10:41:56 <Mortchek> So you can see how it relates to foldr
10:42:53 <Mortchek> > foldl (flip (:)) [] [a, b, c]
10:42:55 <lambdabot>   [c,b,a]
10:44:13 <jesyspa> Is there any standard solution to having an Err a = Either [E] a so that if f is Err (a -> b) and Err a are both Lefts, then f <*> a concatenates the two lists?
10:45:01 <Mortchek> Isn't that basically a Writer?
10:45:07 <Mortchek> Wait no
10:45:44 <jesyspa> It's almost a writer, but with either the value or the error there.  I'm wondering whether something could be constructed with MaybeT or ErrorT.
10:45:49 <merijn> There's no way to have a heterogenous list of functions (i.e. functions with differeing input types) and a value and then apply all the functions with the right type to that value without abusing Data.Typeable, right?
10:46:18 <Taneb> jesyspa, the first thing I could think of is ([E], Maybe a)
10:46:32 <Taneb> @unmtl MaybeT (Writer [E]) a
10:46:32 <lambdabot> (Maybe a, [E])
10:46:54 <jesyspa> Hmm, I guess having the errors always there is good enough.  Thanks!
10:47:01 <chrisdone> merijn: Dynamic gives you that with a little less friction
10:47:12 <merijn> chrisdone: Dynamic?
10:47:33 <chrisdone> merijn: yeah, Data.Dynamic, it's a wrapper for convenient dynamic value stuff, uses Data.Typeable
10:47:46 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
10:48:15 <chrisdone> dynApply :: Dynamic -> Dynamic -> Maybe Dynamic -- this specifically applies "whatever" to "whatever"
10:48:48 <merijn> Oh, that's convenient
10:49:07 <merijn> I guess that also means the implicit answer to my question is "no, not without Data.Typeable"
10:49:40 <chrisdone> nod. you could do it with existentials i think but you'd be replicating typeable for your specific domain, i guess
10:51:03 <merijn> I don't mean a heterogeneous list in the [forall a . a] sense, but in the sense of I have a GADT "data Foo :: [*] -> * where Nil :: Foo '[]; Cons :: a -> Foo xs -> Foo (a ': xs)" list
10:51:24 <merijn> So I know statically the type of each element, just not how to decide based on that
10:51:40 <arkeet> isn't HList sort of that? except without DataKinds
10:51:43 <merijn> I even know how to write the function type so that it matches what I want, I just don't know if it's possible to implement :p
10:53:01 <chrisdone> merijn: what's '[] syntax?
10:53:04 <merijn> But I guess not, since I don't think I can select an implementation based on type alone.
10:53:13 <merijn> chrisdone: promoted literal for lists
10:53:36 <chrisdone> merijn: what does it mean?
10:53:37 <merijn> i.e. '[] has kind [k]
10:53:42 <chrisdone> ah, ok
10:53:47 <merijn> chrisdone: It's an empty list of types
10:54:16 <chrisdone> and ': has kind k -> [k] -> [k]? or what?
10:54:22 <merijn> Foo's argument is a list of types that correspond with the types of the elements in Foo
10:54:25 <merijn> chrisdone: Yes
10:54:32 <chrisdone> nice. when did that happen?
10:54:35 <merijn> 7.6
10:54:46 <merijn> DataKinds + TypeOperators
10:55:00 <merijn> You can even promote arbitrary values
10:55:00 <arkeet> those were present in 7.4
10:55:01 <Mortchek> What are type-level lists useful for?
10:55:11 * chrisdone rubs back. ohh i just can't keep up with these features like i used to
10:55:14 <merijn> So you can have "Maybe *" on the type level
10:55:22 <merijn> arkeet: Yes, but broken
10:55:27 <arkeet> indeed.
10:55:30 <merijn> arkeet: I know, my code wouldn't work with 7.4
10:55:36 <arkeet> indeed.
10:55:40 <merijn> Mortchek: Enforcing invariants i the type system
10:55:47 <merijn> Anyway, I need to go for practice
10:56:07 <merijn> I'll be back later to see if anyone can help or whether I should just give up and use Data.Typeable/Data.Dynamic
10:56:33 <arkeet> don't give up!
10:56:40 <merijn> chrisdone: You can even have type level strings and numeric literals :)
10:56:59 <merijn> Although I don't think we'll have type level comparison/arithmetic until 7.8
10:57:16 <arkeet> we can test for equality, we just can't do math.
10:57:49 <merijn> arkeet: You can't test for equality directly, you can only do unification and you can use that to make decisions in type functions
10:58:07 <arkeet> that's what I meant. probably.
10:58:07 <crdueck_> how can I drop the highest dimension index of a Repa Shape? basically I want to do an init on the constructor (Z :. x :. y :. z) so I get (Z :. x :. y)
10:58:22 <merijn> Œª :k 6
10:58:22 <merijn> 6 :: GHC.TypeLits.Nat
10:58:23 <crdueck_> but for any general Shape, not just DIM3
10:58:37 <merijn> Anyhoo, cya!
10:58:41 <arkeet> me too.
11:00:12 <chrisdone> merijn: GHC: ‚ÄúEVERYTHING YOU CHANGE WITH ME / TAKES ME ONE STEP CLOSER TO AGDA, AND I'M ABOUT TO BREAK!‚Äù
11:01:08 <supersym> :)
11:01:10 <crdueck_> hmm, i could do:  shapeOfList . init . listOfShape, but thats seems ugly
11:01:59 <chrisdone> @src init
11:01:59 <lambdabot> init [x]    = []
11:01:59 <lambdabot> init (x:xs) = x : init xs
11:01:59 <lambdabot> init []     = undefined
11:02:03 <chrisdone> ewww undefined
11:03:16 <armlesshobo> chrisdone: why eww?
11:03:24 <crdueck_> chrisdone: so are most of the list functions like head, tail
11:03:25 <skuggi> chrisdone: initSh (sh :. i) = sh
11:03:54 <crdueck_> skuggi: wow, just pattern match. i guess i wasnt thinking, thanks
11:03:55 <skuggi> oh wait crdueck_ was the one who wanted it
11:05:47 <aristid> armlesshobo: should at least use error in that case
11:05:54 <aristid> but actual init doesn't use undefined
11:05:59 <aristid> > init []
11:06:00 <lambdabot>   *Exception: Prelude.init: empty list
11:06:19 <aristid> which is better
11:06:30 <chrisdone> armlesshobo: until we've got neil mitchell's cool totality analysis, stuff like that is just a pissed off user waiting to happen
11:07:21 <aristid> chrisdone: would you prefer init [
11:07:22 <chrisdone> we laugh at java's null pointer exceptions and cough and shuffle our feet when we get partial function exceptions
11:07:25 <aristid> chrisdone: would you prefer init [] = []?
11:07:48 <fizbin> At least partial function exceptions can be caught at compile time.
11:07:49 <chrisdone> aristid: so init xs = drop (length xs - 1)?
11:07:59 <fizbin> In theory.
11:08:09 <aristid> chrisdone: more like take, but yes
11:09:02 <chrisdone> aristid: yeah. i like the take/drop functions. they're so warm and fuzzy
11:09:10 <fizbin> Except that of course Prelude has partial functions in it, so every time you call one of those functions, you can get a partial function exception.
11:09:46 <chrisdone> fizbin: see http://community.haskell.org/~ndm/catch/
11:09:48 <aristid> chrisdone: like monads!
11:09:58 <chrisdone> A Haskell program may fail at runtime with a pattern-match error if the program has any incomplete (non-exhaustive) patterns in definitions or case alternatives. The Catch tool is a static checker that allows non-exhaustive patterns to exist, yet ensures that a pattern-match error does not occur.
11:10:25 <aristid> .oO(we should rename the "bind" operator. that sounds so dominant.)
11:10:31 <chrisdone> he only stopped working on it due to having to keep up with ghc versions. i'd love it if it were /part/ of ghc
11:10:46 <chrisdone> aristid: heh heh =)
11:10:53 <quchen> aristid: Bitwise right shift sounds less dominant.
11:11:07 <aristid> quchen: bitwise right shift assign?
11:11:11 <crdueck_> skuggi: If I want the last dimension of a Shape, how would I do it? I assume that like lists, I can't pattern match on the last element of the (:.) constructor.
11:11:41 <quchen> chrisdone: Isn't that checking built-in using -Wall?
11:11:53 <skuggi> crdueck_: you the dimension farthest to the right left?
11:11:53 <quchen> chrisdone: Or is that tool doing some more advanced checks
11:12:03 <skuggi> +'mean
11:12:16 <chrisdone> quchen: this tool's more like: head [1] -- OK! head [] -- Bad!
11:12:47 <quchen> chrisdone: Oh, I see, it checks whether the non-exhaustive patterns can potentially be reached then?
11:12:47 <crdueck_> skuggi: the farthest to the right, which should be the "highest" dimension
11:12:49 <chrisdone> quchen: as ndm's approach is "partial functions are OK, partial code is bad", more or less. which i agree is ok
11:12:52 <chrisdone> quchen: yeah
11:13:08 <quchen> chrisdone: Sounds useful!
11:13:28 <chrisdone> yeah! i'd really love ot get it up and running
11:14:04 <skuggi> crdueck_: so, just like in initSh ?
11:14:52 <chrisdone> what do you guys think of liquid types? i really enjoy how they let you make practical constraints without having to go into Serious Type Theory
11:14:57 <crdueck_> skuggi: no, initSh (Z :. x :. y :. z) == (Z :. x :. y), lastSh (Z :. x :. y :. z) == z
11:15:13 <crdueck_> for any dimensional shape obviously
11:15:29 <skuggi> crdueck_: oh wait, i did that a bit wrong
11:15:59 * hackagebot clckwrks-plugin-page 0.1.8 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.1.8 (JeremyShaw)
11:16:05 <skuggi> initSh (sh :. i) = i
11:16:18 <skuggi> that would be the proper implementation of initSh
11:16:33 <skuggi> because shapes are snoc lists
11:17:01 <skuggi> the element to the right is the outermost element
11:17:51 <skuggi> crdueck_: sorry, i'm mixing things up again.
11:18:10 <skuggi> the last function i gave you is more like head
11:18:35 <crdueck_> skuggi: i'm confused, is the "3rd dimension unit" in (Z :. i :. j :. k)  i?
11:18:37 <skuggi> something like init would be difficult to write.
11:19:16 <skuggi> crdueck_: it depends on what you mean by "3rd dimension"
11:19:24 <skuggi> :)
11:20:13 <crdueck_> well (Z :. i) is obviously DIM1, so i is the "1st dim unit", (Z :. i :. j) is DIM2, but what index is for the 1st dim. and what index is for the 2nd dim?
11:21:31 <skuggi> crdueck_: i don't really understand what you're asking.
11:22:26 <eacameron> I have several functions that all look identical, except that the constructor they're using for pattern matching is different. How can I DRY this up?
11:22:26 <eacameron> f (MyType x) = x
11:22:26 <eacameron> f _                  = Fail "fail"
11:22:26 <eacameron> g (OtherType x) = x
11:22:26 <eacameron> g _                      = Fail "fail"
11:22:27 <eacameron> etc.
11:22:30 <crdueck_> skuggi: okay, sorry. I dont think an answer to that question would help anyways. I'm going to play around in ghci a bit and see if I can figure it out myself.
11:22:32 <yitz> preflex: seen mzero
11:22:33 <preflex>  mzero was last seen on #haskell 5 days, 12 hours, 25 minutes and 38 seconds ago, saying: how ya doin', wess ?
11:22:46 <supersym> heck chris I had never even heard of them before now :P
11:23:03 <skuggi> but for example, Z :. 1 :. 1 and Z :. 1 :. 2 would be next to each other in memory in a manifest array
11:23:15 <skuggi> crdueck_: does that help_
11:23:19 <skuggi> ?
11:23:59 <crdueck_> skuggi: perhaps, I'm trying to visualize DIM3 arrays because I'm doing something geometric with them, but I dont think it lends itself very intuitively
11:24:19 <znutar> Is there a good place to look for someone that hasn't written any haskell in the last 3 years or so, to figure out what's new and good and what people stopped using?
11:24:32 <Clint> the internet
11:25:45 <Saizan> znutar: maybe take a look at ghc's changelogs
11:25:48 <skuggi> crdueck_: well, then i guess you can choose which dimension is which in any way you wish. :)
11:26:01 <Saizan> znutar: or ask on stackoverflow
11:26:24 <typoclass> znutar: maybe the haskell community activities report? as for what people are not using anymore, i guess #haskell :-) and as always, stack overflow, but you find that via google anyway if you search for practically any question
11:26:39 <znutar> thanks!
11:26:53 <typoclass> znutar: and welcome back :-)
11:26:56 <hiptobecubic> what did things look like three years ago?
11:27:07 <hiptobecubic> people banging rocks together, i assume
11:27:55 <znutar> Not that different, I'm thinking things like parsec flavors and what have you
11:27:57 <typoclass> hiptobecubic: i think they still used ghc 8.3 back then
11:28:09 <hiptobecubic> hah
11:28:11 <hiptobecubic> single digits
11:28:26 <eacameron> can pattern matching be done with a "variable" constructor instead of hard coded? f (constructor x) = x
11:28:59 <Iceland_jack> eacameron: Look at ViewPatterns
11:29:27 <Iceland_jack> Short answer ‚Äòno‚Äô, but ViewPatterns bring you something close
11:29:45 <hiptobecubic> typoclass, was that before or after we got n+k patterns over groups?
11:29:55 <typoclass> eacameron: just to double-check, do you really need those functions? it looks like any code that used f and g might just as well do "case ... of OtherType x -> ..." directly. of course depending on how abbreviated your example was
11:30:41 <eacameron> typoclass: they're a little more involved, but not much
11:31:00 * hackagebot fsnotify 0.0.7.1 - Cross platform library for file creation, modification,  and deletion notification.  http://hackage.haskell.org/package/fsnotify-0.0.7.1 (GregWeber)
11:32:22 <RpR> First read through (of several I'm sure) of Control.Proxy.Tutorial -- WoW!  What a library.
11:34:47 <amiller> i've made a super complicated version of a redblack tree
11:34:51 <amiller> but ultimately it's an implementation of data.map
11:35:02 <amiller> am i right that i can use quickcheck and a standard battery of tests to do testing of this thing
11:42:39 <eacameron> I guess the big question for me is: is there an abstract way to ask "is this x wrapped with this y constructor?" like "isInstance value MyConstuctor"
11:43:28 <hiptobecubic> pattern matching on the instructor does does that.
11:43:31 <hiptobecubic> does*
11:43:48 <hiptobecubic> > let Just x = Just 4 in x
11:43:49 <lambdabot>   4
11:43:57 <hiptobecubic> > let Just x = Left 4 in x
11:43:58 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t0'
11:43:59 <lambdabot>              with actual...
11:44:29 <hiptobecubic> > let Right x = Left 4 in x
11:44:30 <lambdabot>   *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Da...
11:44:49 <eacameron> hiptobecubic, but what if "Just" is some argument to the function? let constructor x = constructor 4 in x
11:45:46 <eacameron> > let c = Just in c x = c 4
11:45:48 <lambdabot>   <hint>:1:21: parse error on input `='
11:46:28 <hiptobecubic> > let c = Just in c x == c 4
11:46:30 <lambdabot>   False
11:46:44 <hiptobecubic> > let c = Just in c blib == c 4
11:46:46 <lambdabot>   Not in scope: `blib'
11:46:51 <Mortchek> > x == 4
11:46:53 <lambdabot>   False
11:46:58 <typoclass> eacameron: it won't work that way. if you could post some more code to hpaste.org, we may be able to come up with suggestions
11:47:25 <hiptobecubic> Yeah, I also don't see why this would be useful ever.
11:48:01 <hiptobecubic> you can unpack without knowing the constructor
11:48:17 <hiptobecubic> > let f x = Just 4 in iterate f
11:48:18 <lambdabot>   *Exception: show: No overloading for function
11:48:23 <hiptobecubic> awww
11:48:36 <hiptobecubic> > let f x = Just 4 in f 0
11:48:38 <lambdabot>   Just 4
11:48:47 <hiptobecubic> wat
11:48:54 <hiptobecubic> oh
11:49:13 <typoclass> hiptobecubic: yeah, it's essentially like fromJust, and everyone mistrusts that function. though it might be useful in some unlikely cases somewhere
11:50:07 <hpaste> eacameron pasted ‚ÄúHow do I DRY this up?‚Äù at http://hpaste.org/85491
11:51:01 * hackagebot penny-lib 0.12.0.0 - Extensible double-entry accounting system - library  http://hackage.haskell.org/package/penny-lib-0.12.0.0 (OmariNorman)
11:51:03 * hackagebot penny-bin 0.12.0.0 - Extensible double-entry accounting system - binary and documentation  http://hackage.haskell.org/package/penny-bin-0.12.0.0 (OmariNorman)
11:52:14 <plhk> is it possible to express this in haskell? http://hpaste.org/85490
11:53:13 <geekosaur> not like that it isn't
11:53:15 <Botje> plhk: I think you have to export the Version a constraint to decodeFile as well..
11:53:31 <geekosaur> that's not the only issue
11:53:58 <eacameron> typoclass: pasted http://hpaste.org/85491
11:54:06 <zachk> a
11:54:13 <geekosaur> in decodeFile, you do not get to decide which a you want to return; instead, whatever invokes decodeFile decides what a it wants decodeFile to return and decodeFile must comply
11:55:25 <plhk> but somewhere i have to do switching
11:55:27 <typoclass> plhk: when you do "f :: ByteString -> File a", you're saying "this function f can produce a 'File a' for any 'a' that the caller chooses". it's like "g :: a -> b". the caller chooses 'a' and 'b', not just 'a'
11:56:15 <typoclass> plhk: have you considered "data Version = V1 | V2"?
11:58:14 <plhk> typoclass: not yet
11:58:34 <typoclass> eacameron: hm. it's normally recommended to not have a lot of isSomething functions
11:58:45 <typoclass> plhk: i think it'd be much more natural :-)
11:58:52 <eacameron> typoclass: how do you avoid them?
11:59:40 <typoclass> eacameron: instead of doing "if isBool x then ..." you directly do "case x of VBool b -> ..."
12:00:10 <plhk> typoclass: i would have to do case v of V1 -> decode-like-v1; V2 -> decode-like-v2 :/
12:00:24 <[swift]> so i think i'm missing something simple
12:00:45 <[swift]> say I have this function: cursorName c = C.getDisplayName c >>= CStr.unpack
12:01:01 <[swift]> how can i rewrite that using applicative?
12:01:24 <trescenzi> Can anyone explain how unfoldTree works for Data.Tree? I kinda get what's going on but I don't think I understand how to use it to build a tree part by part or even if you can
12:01:31 <eacameron> typoclass: unfortunately in my case, i'm building up a "schema" where each field is a function that does validation
12:01:52 <[swift]> since CStr.unpack has a type like "a -> m b", neither <$> nor <*> seems to work
12:01:55 <eacameron> typoclass: sometimes I just want the validation to be "must be of this type"
12:03:44 <typoclass> plhk: right, but couldn't you do that in lines 30-31?
12:04:13 <eacameron> typoclass: just as good would be "value was created with x constructor" (e.g. instead of isInt, is VInt)
12:06:01 <Mortchek> @type unfoldTree
12:06:03 <lambdabot> (b -> (a, [b])) -> b -> Tree a
12:06:20 <Mortchek> trescenzi, the b -> (a, [b]) is a rule for getting a node from a seed value, the b
12:06:35 <Mortchek> You take that seed value onto a pair of the node's value, and the list of seed values for its children
12:06:51 <supki> [swift]: you can not always rewrite monadic code with applicatives
12:07:05 <[swift]> supki: i know, but i wasn't sure if this was such a case
12:07:06 <supki> [swift]: Applicative is strictly less powerful than Monad
12:07:16 <Mortchek> So say your rule produces ("foo", [1, 2, 3]). Then the rule will be applied in turn to the 1, 2, and 3 to produce further nodes.
12:07:36 <supki> [swift]: well, if you want to compose "m a" and "a -> m b" that's the case
12:07:53 <tromp_> import Control.Expletive
12:08:05 <Mortchek> > unfoldTree (\b -> (b, [b - 1, b + 1])) 0
12:08:08 <lambdabot>   Node {rootLabel = 0, subForest = [Node {rootLabel = -1, subForest = [Node {...
12:08:30 <trescenzi> Mortchek: Ok that makes more sense. But how does it decide when the branching occurs?
12:08:42 <[swift]> supki: i see. we can only use "a -> b" (via fmap) or "m a -> m b" in applicatives, then?
12:08:45 <Mortchek> That generates an infinite tree with a root whose value is 0, with children whose values are -1 and 1, and whose children in turn have -2, 0, 0, 2, and so on.
12:08:46 <trescenzi> Like how would you know how many children the current node has
12:09:00 <Mortchek> trescenzi, it's based on the list you provide.
12:09:07 <Mortchek> How many children is how many items are in the list.
12:09:24 <Mortchek> > unfoldTree (\b -> (10, [])) 0
12:09:26 <lambdabot>   Node {rootLabel = 10, subForest = []}
12:09:35 <[swift]> supki: is this actually the fundamental limitation of applicatives?
12:09:42 <trescenzi> > unfoldTree (\b -> (10, [1,2,3])) 0
12:09:44 <lambdabot>   Node {rootLabel = 10, subForest = [Node {rootLabel = 10, subForest = [Node ...
12:09:56 <supki> [swift]: applicatives have "m (a -> b)", "m a -> m b" would be ($) :)
12:09:59 <supki> [swift]: yes
12:10:02 <hiptobecubic> [swift], yes
12:10:04 <Mortchek> So in your case there, it's an infinite tree where every node has three children
12:10:13 <hiptobecubic> [swift], the second function needs the output from the first
12:10:21 <trescenzi> Mortchek: ok makes sense now. now to just figure out how to write a rule that does what I want it to do I guess
12:10:30 <[swift]> supki: ah yes, my mistake
12:10:31 <Mortchek> trescenzi, what tree are you trying to produce?
12:10:40 <[swift]> supki, hiptobecubic: thanks, i believe i just learned something =)
12:10:49 <trescenzi> Mortchek: a CST for a compiler lol
12:11:36 <trescenzi> I'll most likely have to build it step by step unfolding when I hit certain tokens? No idea. Should be fun though
12:12:11 <hpaste> typoclass annotated ‚ÄúHow do I DRY this up?‚Äù with ‚ÄúHow do I DRY this up? (annotation)‚Äù at http://hpaste.org/85491#a85495
12:12:34 <typoclass> eacameron: i wonder what you're doing :-) but here is a possibility, just for inspiration ^^
12:14:27 <typoclass> eacameron: you'd have the schema as a VValue, possibly containing other VValues recursively (you know the drill), and you'd have the parsed VValue, and then 'validate' would be basically an elaborate variant of (==)
12:16:01 <hiptobecubic> typoclass, that's a nice refactoring job there
12:16:27 <eacameron> typoclass: not bad!
12:16:33 <eacameron> I'll see where that takes me
12:16:53 <typoclass> hiptobecubic: oh thanks :-) i'm kinda not confident, because i wonder what the end goal is anyway :-D
12:16:56 <eacameron> that's the annoying thing in Haskell: if I find it hard to do...it's probably because it's a bad idea
12:17:15 <eacameron> the hard part is finding the good idea that's easy to do!
12:17:28 <typoclass> eacameron: that's true! usually the things that are awkward are the same things you wouldn't want to do anyway, in the long run
12:17:31 <hiptobecubic> typoclass, well i didn't understand what the code was intended do until your version. That's probably a good sign?
12:18:02 <jerng> Any advice on why it's not always possible to substitute (fnA $ fnB $ argument) with (fnA.fnB argument) in Haskell? Is it a compiler quirk? Shouldn't both be equivalent to (fnA(fnB(argument)))?
12:18:22 <armlesshobo> eacameron: i wouldn't call that a problem :P
12:18:24 <Botje> jerng: fnA . fnB argument === \x -> fnA (fnB argument x)
12:18:29 <armlesshobo> eacameron: it's a "feature of the language"
12:18:30 <shachaf> jmelesky: (foo.bar x) is ((foo) . (bar x))
12:19:00 <armlesshobo> jerng: (fnA . fnB) argument
12:19:35 <typoclass> jerng: function application (i.e. space) binds more tightly than practically anything, as shachaf showed
12:19:42 <hpaste> supki annotated ‚ÄúHow do I DRY this up?‚Äù with ‚ÄúHow do I DRY this up? (annotation)‚Äù at http://hpaste.org/85491#a85497
12:19:53 <jerng> botje armlesshobo typoclass : thanks guys!
12:19:54 <jmelesky> shachaf: Beg pardon?
12:19:55 <jerng> Missed that.
12:19:58 <Botje> (fnA . fnB) argument = (\x -> fnA (fnB x) argument = fnA (fnB argument)
12:20:13 <jmelesky> Ah, wrong nick
12:20:13 <shachaf> jmelesky: Sorry, that was meant for jerng
12:20:54 <jerng> shachaf: thanks!
12:20:55 <jmelesky> no worries
12:21:31 <dgpratt> I decided to create a linux vm just for Haskell experimentation
12:21:57 <armlesshobo> dgpratt: why such drastic measures?
12:22:30 <typoclass> supki: well, like most elegant things, that's cheating :-)
12:22:42 <Eduard_Munteanu> Maybe he's running (drums...) Windows.
12:22:50 <supki> typoclass: :(
12:22:51 <dgpratt> armlesshobo: certain aspects of Haskell development are not as Windows-friendly as one would prefer
12:23:24 <armlesshobo> dgpratt: are you not up for a sense of "adventure"? :P
12:23:33 <ab9rf> that's because windows is not developer-friendly under any circumstance
12:23:33 <dgpratt> but alas it seems the latest Ubuntu/Xubuntu distros do not play nice with VBox
12:23:41 <dgpratt> armlesshobo: usually
12:24:00 <armlesshobo> it's a funny trade-off
12:24:13 <dgpratt> armlesshobo: I actually build GHC on Windows at some point; that was adventurous
12:24:15 <chrisdone> more windows haskellers should contribute. together, both of them could really improve the situation. although SPJ's time is probably best spent on new GHC features =p
12:24:15 <armlesshobo> VBox -> good when Windows is host. bad when not.
12:24:19 <dgpratt> *built
12:24:33 <armlesshobo> dgpratt: that sounds like it was painful.
12:24:35 <dgpratt> armlesshobo: well, Windows is host in this case :)
12:25:11 <Eduard_Munteanu> chrisdone: shh... I don't think MS really knows why he's there. :P
12:25:18 <dgpratt> now I'm giving Arch a go -- somehow I got the impression that Arch is the distro of choice for a non-empty set of Haskellers
12:25:49 <Eduard_Munteanu> Well, it's a bit more lightweight anyway.
12:26:02 * hackagebot hspec-meta 1.5.3 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.5.3 (SimonHengel)
12:26:03 <quchen> dgpratt: Careful, the measure could still be zero
12:26:08 <dgpratt> but is it just me, or is Arch the only linux distro where the installer is even less user-friendly than it used to be?
12:26:21 <Eduard_Munteanu> There is no installer. :)
12:26:30 <ab9rf> i've not heard anything good about arch in recent days.....
12:26:36 <Eduard_Munteanu> I too remember it having one at some point.
12:27:04 <dgpratt> Eduard_Munteanu: I thought it did at some point also
12:27:09 <typoclass> dgpratt: my personal 2 cents (based on this one laptop) is that arch was very nice in about 2008-9, but really has deteriorated, and today it's just annoying
12:27:23 <ab9rf> typoclass: that's about the typical useful life of a distro
12:27:34 <dgpratt> typoclass: I appreciate the feedback
12:27:45 <dgpratt> typoclass: so what do you use today?
12:28:04 <Philonous_> typoclass:  What would you replace it with?
12:28:23 <chrisdone> at some point linux became serious-business-desktop-OS-of-choice with ubuntu and fedora, so people started demanding more "just work"-ness and less mandatory configuration to get something decent. i think arch leans towards the latter, at least from my colleagues' experiences
12:28:43 <typoclass> dgpratt: still arch, i just stopped updating some months ago :-/ it is very stable now and requires no babysitting at all :-)
12:28:54 <dgpratt> typoclass: I see
12:28:54 <typoclass> Philonous_: good question, i'm kinda looking
12:28:59 <dgpratt> the measure is non-zero!
12:29:04 <chrisdone> ubuntu is kind of a pig, with a dumbass initial setup, but i put up with it for the just-workiness
12:29:43 <Philonous_> typoclass:  Not updating is a really bad idea, I'm afraid.
12:31:03 <mm_freak> well, i like the "just work"-ness of arch, and it's the main reason i haven't switched to nixos a long time ago
12:31:42 <typoclass> dgpratt: as for the arch haskell packages, i went the cabal-for-everything route. i tested the arch packages initially, but they needed to be installed from aur, which means for each package an editor window comes up with the installation script, which you're supposed to check ("runs as root and could theoretically do anything to the computer" ...). it's ok if you plan to install 5 things, but for dozens of things you get fed up
12:32:19 <chrisdone> mm_freak: hm, ok. i heard it took a lot of tweaking. obvious example is the fonts, ubuntu's fonts are the best linux fonts out there. but apparently more stuff requires messing about. maybe it depends on the use-case
12:32:21 <typoclass> dgpratt: also, the arch packages didn't even come with haddocks at the time. don't know if that's still the case. anyway, i decided to do everything through cabal
12:32:22 <Eduard_Munteanu> I can't really complain about Arch, except some packages might be missing from the main repos.
12:32:30 <Eduard_Munteanu> Say compared to Gentoo.
12:32:43 <Eduard_Munteanu> I'd probably still use Arch for a lappie or such.
12:32:53 <mm_freak> chrisdone: when i install a font package in arch, they get hot-applied‚Ä¶
12:32:55 <chrisdone> Eduard_Munteanu: presumably gentoo isn't a realistic comparison with anything because it's so mental
12:33:02 <dgpratt> typoclass: thanks for the advice, I'm sure it'll come in handy if I ever get Arch installed :)
12:33:13 <chrisdone> mm_freak: hot-applied?
12:33:14 <typoclass> chrisdone: has ubuntu switched away from those dejavu fonts?
12:33:24 <chrisdone> typoclass: ubuntu uses the ubuntu font
12:33:34 <chrisdone> but i didn't mean the font families, i meant the font rendering
12:33:40 <Eduard_Munteanu> chrisdone: unfortunately I really like certain other aspects of Gentoo
12:33:54 <mm_freak> chrisdone: just recently i noticed:  an XFCE installation installs only some ugly base fonts, but once you install more fonts, the UI switches to them immediately
12:34:06 <Eduard_Munteanu> Compiling is a PITA, but it's a sane distro otherwise.
12:34:08 <mm_freak> was quite a pleasing experience
12:34:16 <chrisdone> mm_freak: ah. that's xfce i suppose, nothing related to arch
12:34:35 <mm_freak> chrisdone: well, yes it is, because it performs the font configuration after installation
12:34:39 <eacameron> who posted the makePrisms idea for my hpaste?
12:34:44 <FireFly> Eduard_Munteanu: what kind of aspects?  I want some incentive to try another distro :P
12:34:55 <FireFly> Also, maybe #-blah
12:35:08 <Eduard_Munteanu> Hm, probably better.
12:35:14 <mm_freak> anyway, i'll definitely switch to NixOS sooner or later
12:35:14 <typoclass> chrisdone: oh i see. font rendering might be worth comparing. i'm kinda picky, but i'm happy with these settings on arch
12:35:16 <chrisdone> -blah's appropriate when it's interrupting actual discussion afaik
12:35:28 <FireFly> Oh, carry on then
12:35:57 <supki> eacameron: I did
12:35:59 <typoclass> mm_freak: i'm nearly willing to bet it's fontconfig, which iirc checks the fonts directories every 10 seconds or some such
12:36:17 <eacameron> supki: interesting! I knew there was a TH way to do it
12:36:25 <eacameron> I'm curious how that works
12:36:33 <chrisdone> yeah even putting files in your ~/.fonts makes them available immediately
12:36:35 <typoclass> eacameron: it uses lens
12:36:36 <mm_freak> typoclass: maybe‚Ä¶  i'm just saying stuff just works and i like that
12:36:54 <Eduard_Munteanu> FireFly: well, lots of packages, the eselect goodies for configuring stuff, a reasonable package manager.
12:37:03 <eacameron> typoclass: I'm too afraid to venture into TH
12:37:09 <Eduard_Munteanu> FWIW, Debian always leaves me a bitter taste.
12:37:30 <Eduard_Munteanu> It feels like it's held together by cheap duct tape. :)
12:37:30 <typoclass> mm_freak: sure :-) i just wanted to add it's not xfce afaik, it's a thing used by xfce, gnome, and various others
12:37:33 <mm_freak> nix is eselect on steroids =)
12:37:34 <chrisdone> eacameron: why's that? does there need to be better documentation?
12:37:37 <supki> eacameron: well, lens is open-source =)
12:37:52 <supki> eacameron: I doubt there are any explanations about its TH
12:38:16 <eacameron> chrisdone: I've read GHC's docs a little and got lost really fast
12:38:19 <typoclass> eacameron: well you're mainly using lens, it's just that you need to turn on TH for this particular witchcraft that lens offers
12:38:26 <Eduard_Munteanu> mm_freak: interesting... I should try it sometime, at least in a VM
12:38:54 <applicative> eacameron: the lens package use of it is pretty straightforward and intelligible, it could as well be done with some complicated cpp
12:39:05 <mm_freak> Eduard_Munteanu: definitely‚Ä¶  nix eselects your entire operating system‚Ä¶  i think NixOS is the next generation gentoo
12:39:09 <applicative> eacameron: but you can do without it
12:39:23 <mm_freak> with all the nice customizibility (even user-wise), but without the quirks
12:39:29 <eacameron> applicative: cpp?
12:39:30 <Eduard_Munteanu> Besides, I do like rolling-releases so even though stuff like Fedora is otherwise fun, fixed releases are annoying.
12:39:37 <Eduard_Munteanu> Heh.
12:40:08 <applicative> oh I meant the C-preprocessor
12:40:34 <applicative> eacameron: which has claw marks over half the sound packages on hackage
12:41:34 <eacameron> applicative: yeah...I've seen that too
12:41:37 <eacameron> it's ugly
12:41:48 <aristid> mm_freak: do you use nixos?
12:44:11 <quchen> A
12:45:57 <mm_freak> aristid: not yet
12:46:19 <aristid> mm_freak: go to #nixos anyways.
12:46:28 <applicative> eacameron: yeah TH is ugly too, it wasn't designed by David Turner like most of our syntax
12:46:42 <mm_freak> everybody is telling me to join more channels =)
12:47:10 <eacameron> applicative: I've noticed that as well...it's a real bummer
12:47:25 <aristid> mm_freak: it's ok if you quit unimportant channels like #haskell
12:47:49 <mm_freak> if i had an IRC client that could handle lots of channels i'd join =)
12:47:53 <chrisdone> aristid: TAKE THAT BACK
12:48:03 <aristid> ok ok
12:48:11 <aristid> it's ok to quit channels in which chrisdone is not
12:48:19 <chrisdone> ‚âñ‚Äø‚âñ
12:48:19 <aristid> but certainly not any channels where chrisdone is.
12:48:22 <dmwit> mm_freak: Hey, last time I had access to a NixOS person I ran out of time to ask my question. Everybody says the configuration is written in a lazy functional language. What is the input to the function you are writing? What is the output?
12:49:00 <aristid> dmwit: there is a whole channel with nixos persons.
12:49:34 <dmwit> But will we share enough jargon for my questions (and their answers) to be mutually intelligible?
12:49:38 <mm_freak> dmwit: i think you can view it as [Derivation] -> Derivation, but i'm not sure
12:49:44 <mm_freak> the configuration language is a bit weird
12:50:19 <aristid> dmwit: the input to the function is a configuration attribute set, and the set of all other packages in the package set. this is where laziness comes in, because the package is obviously also part of that package set...
12:50:54 <aristid> dmwit: the output is basically a shell script for building it
12:51:06 <aristid> (not entirely true)
12:51:29 <dmwit> I see.
12:51:46 <dmwit> ...I think. =)
12:52:15 <typoclass> aristid: does the user write stuff in this functional language, or the person who makes a package?
12:52:27 <aristid> dmwit: basically a package looks like this: pkgs: foo
12:52:39 <aristid> x: y is nix' lambda syntax, so pkgs is a function parameter here
12:53:00 <Eduard_Munteanu> What distro reimplemented various system scripts in Haskell, Nix?
12:53:03 <mm_freak> typoclass: both
12:53:03 <aristid> dmwit: pkgs.alsa would for example be the alsa package. pkgs.config contains some general configuration variables
12:53:14 <aristid> Eduard_Munteanu: nix does not use any haskell.
12:53:39 <mm_freak> if nix would have used haskell, the language syntax wouldn't be that ugly
12:54:03 <aristid> i find the syntax entirely neutral
12:54:27 <chrisdone> haskell's syntax?
12:54:31 <aristid> note that they have lists that don't require stupid in-between-but-not-after delimiters.
12:54:35 <aristid> chrisdone: nix'
12:54:49 <aristid> > [ 1, 2, 3, ]
12:54:51 <lambdabot>   <hint>:1:12: parse error on input `]'
12:55:05 <chrisdone> lisp doesn't even require commas =p
12:55:10 <typoclass> aristid: i wish haskell allowed a trailing comma!
12:55:16 <aristid> typoclass: me too!
12:55:17 <Eduard_Munteanu> That reminds me of matlab :)
12:55:25 <shachaf> chrisdone: Can you do something about all the spam on hpaste?
12:55:27 <mm_freak> aristid: the root of the problem is the brackets, not the commas
12:55:29 <ab9rf> why would you want a trailing comma?
12:55:38 <shachaf> It gets into the channel and it's pretty annoying.
12:55:38 <aristid> chrisdone: nix' doesn't require commas either
12:55:39 <chrisdone> shachaf: ah, are the spammers back? let's see‚Ä¶
12:55:47 <aristid> -'
12:55:53 <shachaf> Maybe filter things that consist entire of http://.../ in author and title?
12:55:58 <aristid> [1 2 3] <- list.
12:56:08 <chrisdone> shachaf: what's an example of such spam?
12:56:13 <shachaf> Maybe add some other mechanism to verify humanity. I doubt this is very targeted.
12:56:17 <ab9rf> aristid: no that's an attempt to call the function 1 with the parameters 2 and 3
12:56:27 <shachaf> chrisdone: There's been a lot recently -- I've reported all of it that I've seen.
12:56:29 <aristid> ab9rf: i was talking about nix.
12:56:32 <shachaf> So look at the reported pastes, I guess?
12:56:35 <ab9rf> aristid: you can't have it both ways :)
12:57:46 <chrisdone> shachaf: hmm if it's the one from a couple/few days ago i did ban that IP address. but i'll look through the reporteds
12:57:59 <typoclass> i've actually thought about trying to write a printf-style funky varargs function that would let you do "list 1 2 3". if that's even possible
12:58:00 <shachaf> OK, maybe banning by IP is enough.
12:58:06 <shachaf> It came around more than one day.
12:59:28 <typoclass> chrisdone: have you thought about adding a text field and hiding it with css? it'd be called "email" or something and be empty for all legitimate pastes, and filled in for all spammy nonhuman pastes. if they are nonhuman
12:59:31 <chrisdone> shachaf: there is a naive spam blocker which is a hidden 'email' field which when filled ignores the post. i think that stops most spam, i think these ones were actual humans
12:59:46 <shachaf> Ah.
12:59:48 <chrisdone> anyway, lemmie crosscheck the ips
13:00:17 <ab9rf> chrisdone: ha, that's funny
13:00:44 * typoclass . o O ( he certainly implements stuff quickly. according to the timestamps on this end, it was 4 seconds )
13:00:50 <koninkje> typoclass: it's possible, though it will often require some sort of sentinel to denote the end of the list, or a type sig for similar disambiguation
13:01:24 <chrisdone> typoclass: that's how i roll
13:01:47 <typoclass> koninkje: hm! how does printf work? does it have a sentinel? (never used it so far)
13:02:08 <koninkje> typoclass: printf doesn't, but then printf is unsound
13:02:21 <marutks> can someone help me to fix my program ?
13:02:24 <marutks> data BinTree a = Bin (BinTree a) a (BinTree a) | Empty
13:02:24 <marutks>  
13:02:24 <marutks> mapTree :: (a -> b) -> BinTree a -> BinTree b
13:02:24 <marutks> mapTree f Empty = Empty
13:02:26 <mm_freak> :t printf "%s" :: String
13:02:27 <marutks> mapTree f (Bin l v r) = Bin (mapTree l) (f v) (mapTree r)
13:02:28 <lambdabot> String
13:02:30 <marutks>  
13:02:32 <geekosaur> dont paste into the channe;
13:02:34 <marutks> Couldn't match expected type `BinTree b' with actual type `BinTree a0 -> BinTree b0'
13:02:36 <koninkje> typoclass: You want something like: http://code.haskell.org/~wren/wren-extras/dist/doc/html/wren-extras/Data-List-ZipWithN.html
13:02:38 <mm_freak> > printf "%s" :: String
13:02:40 <lambdabot>   "*Exception: Printf.printf: argument list ended prematurely
13:02:41 <koninkje> typoclass: or http://paczesiowa.blogspot.com/2010/03/generalized-zipwithn.html
13:02:47 <ab9rf> gah
13:02:52 <typoclass> marutks: hello. please use hpaste.org for code > 1 line
13:03:03 <mm_freak> btw, is there a sane printf somewhere on hackage that is still somewhat convenient to use?
13:03:13 <typoclass> koninkje: very interesting, thanks!
13:03:31 <mm_freak> ideally a monoid like Builder
13:03:42 <geekosaur> marutks, but your problem is you are reinvoking mapTree missing f
13:04:01 <hpaste> marutks pasted ‚Äúerror‚Äù at http://hpaste.org/85501
13:04:55 <marutks> oh, I see
13:05:34 <ab9rf> i just found the stackoverflow on how printf works
13:06:00 <ab9rf> i was trying to figure out how to do something like that once and was getting stuck, but now i see how to do it
13:06:16 <Botje> that's a couple of milli-olegs already
13:06:54 <mm_freak> ab9rf: another option is to do it properly using higher rank types
13:07:01 <ab9rf> i knew it had to do with returning functions, but missed the idea of using a class
13:07:16 <ab9rf> i couldn't figure out how to escape from the continuations
13:07:56 <chrisdone> Zer is no escape from Project Continuation, Mr Absworth.
13:07:57 <mm_freak> ab9rf: you mean polymorphic continuations?  like (forall a. a -> ‚Ä¶)?
13:08:15 <ab9rf> mm_freak: i have no idea what you're talking about
13:08:27 <mm_freak> nevermind then =)
13:08:35 <mm_freak> (it's a higher rank type)
13:08:51 <ab9rf> mm_freak: i've not dealt a lot with higher rank types.  i'm still a rank amateur :)
13:08:59 <mm_freak> usually you have two options for lightweight dependent types:  RankNTypes + continuations or existential types
13:09:24 <mm_freak> and printf is one of the best examples for dependent types =)
13:10:14 <chrisdone> mm_freak: printf doesn't really care about what the values are tho
13:10:32 <chrisdone> printf's just clever use of recursive classes to me
13:10:37 <osa1> for some reason hakyll strips <script ..>...</script> part of my template, any ideas why ?
13:11:01 <typoclass> chrisdone: yeah, the type checker would have to look inside the string to figure out if this or that needs to be String or what
13:11:15 <chrisdone> typoclass: *that* would be nice
13:11:44 <chrisdone> typoclass: altho holey monoids do that job well enough for me
13:11:48 <ab9rf> chrisdone: once i read the stackoverflow article it made perfect sense to me
13:12:09 <ab9rf> chrisdone: i may go back to what i was trying to do a couple months ago and essay it again with that idea in mind
13:12:14 <typoclass> chrisdone: oh, interesting
13:12:14 <shachaf> i love holey monoids
13:12:18 <shachaf> they are wholly easy
13:12:45 <mm_freak> chrisdone: i'm not talking about haskell's printf
13:12:55 <mm_freak> i'm talking about printf Done Right
13:13:09 <ab9rf> printf is fundamentally evil anyhow :)
13:13:25 <mm_freak> ab9rf: no, printf in a non-DT language is fundamentally evil
13:13:56 <koninkje> not fundamentally; we just need a true EDSL for the formatting, rather than using strings as a DSL
13:14:31 <koninkje> (i.e., not fundamentally evil; proper EDSLing would probably require dependent types...)
13:15:28 <dmwit> GADTs ought to be enough for anybody.
13:15:29 <mm_freak> i once implemented a variant of printf that got along without dependent types, but it required an operator to delimit the arguments
13:15:46 <chrisdone> shachaf: haha
13:15:56 <mm_freak> something like:  printf "%d: %s" .~. 10 .~. "blah"
13:16:15 <shachaf> chrisdone: You saw the thing I did that used (Prelude..) rather than (Control.Category..), right?
13:16:16 <chrisdone> @remember shachaf i love holey monoids <shachaf> they are wholly easy
13:16:16 <lambdabot> I will remember.
13:16:25 <shachaf> Oh, come on.
13:16:29 <shachaf> @forget shachaf i love holey monoids <shachaf> they are wholly easy
13:16:29 <lambdabot> Done.
13:16:33 <chrisdone> =(
13:16:50 <shachaf> This "love monoids / so easy" thing has gone too far.
13:17:06 <mm_freak> @quote shachaf
13:17:06 <lambdabot> shachaf says: companion_cube: "I don't understand this article at all" edwardk: "Well, when you finish reading it, here's a follow-up article"
13:17:17 <shachaf> Most of my @quotes are bad.
13:17:20 <shachaf> People have no taste.
13:17:22 <mm_freak> @quote shachaf monoid
13:17:23 <lambdabot> shachaf says: And a semigroupoid with identities is called a monoidoid.
13:17:37 <mm_freak> @quote mm_freak
13:17:37 <lambdabot> mm_freak says: bruce schneier is an endofunctor that turns all automorphisms into identities
13:26:28 <vervic> Hi! system: OS X 10.8 + macports (newest version). i'm unable to install hs-cabal via macports due to missing dependencies. sudo port install hs-cabal reports missing dependencies A,B,C,‚Ä¶ . try to port install A -> macports reports missing dependencies E, F, G,‚Ä¶ try to install ‚Ä¶. Since i recognized unresolvable circles, i gave up. Whats the problem here?
13:27:30 <hiptobecubic> mm_freak, is there some actual meaning in that quote w.r.t. bruce or are you just spilling vocabulary onto the floor?
13:27:36 <maria> ciao
13:27:51 <geekosaur> more of a macports question than a haskell one. there are some things out of date in macports though (notably I have not been able to install darcs)
13:28:10 <hiptobecubic> I think i'm comfortable with what it says on its face, but I doubt i have any nuance to my understanding
13:28:15 <geekosaur> the pre-haskell-platform ports are in a bit of disarray still and causing a bit of confusion, I think
13:30:04 <typoclass> vervic: i thought the recommended way these days was to just get the haskell platform. unless you're doing something very particular
13:30:14 <typoclass> vervic: (the platform contains cabal)
13:31:07 <vervic> ohhhh, i have it already :) i use ghci instead of the glassgow.
13:31:41 <geekosaur> you can install the platform via macports
13:31:53 <mm_freak> hiptobecubic: ciphers are automorphisms, but bruce can see everything in clear
13:32:28 <mm_freak> hiptobecubic: check this out: http://www.schneierfacts.com/
13:32:39 <mm_freak> (huh-huh huh-huh uh-huh-huh-huh ‚Ä¶)
13:32:51 <hiptobecubic> mm_freak, ahhhhh yes of course
13:33:29 <ab9rf> glasscow
13:34:48 <vervic> sorry, i was getting confused because i had installed the plattform and hugs98.
13:35:29 <jesyspa> Hm, if m is a monad and mt is a monad transformer, how would I generally go from an m X to an mt m X?
13:35:54 <supki> @ty lift
13:35:55 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
13:35:56 <Ralith> :t lift
13:35:57 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
13:36:15 <jesyspa> Ah, thanks.  Is there any way I can search by function type?
13:36:31 <tdammers> jesyspa: hoogle can do that
13:36:43 <jesyspa> Thanks, I see. :D
14:02:31 <tromp_> > 15*1024/16
14:02:33 <lambdabot>   960.0
14:05:19 <nooodl> http://shuklan.com/haskell/lec12.html#/0/19 "-- a list is a Functor" <- isn't this technically wrong? i feel like it should say "[] is a Functor"
14:06:21 <quchen> nooodl: Yeah, but those slides are a very superficial introduction.
14:06:55 <nooodl> ah, alright
14:07:34 <quchen> The type constructor is the functor.
14:11:18 <typoclass> nooodl: i think what the author means is "of typeclass Functor, there's an instance for lists". it's just shorthand
14:13:17 <hiptobecubic> I thought it wasn't a functor until you equipped it with fmap as well?
14:15:48 <quchen> hiptobecubic: You'll have to specify fmap when defining the instance.
14:48:41 <hiptobecubic> Well yes. But that's because it's not a functor without it
14:49:58 <hiptobecubic> The same way integers aren't a monoid until you define some monoidal concat
14:50:06 <quchen> Also because the compiler complains.
14:51:07 <chrisdone> compile this monoid instance
14:51:08 <hpaste> quchen pasted ‚ÄúFunctor instance without fmap‚Äù at http://hpaste.org/85505
14:51:11 <chrisdone> i'm afraid i can't do that, dave
14:52:16 <hiptobecubic> quchen, well are you talking about functors the algebraic structures or Functors the Haskell types implementing the Functor type class?
14:53:24 <quchen> hiptobecubic: Hm, f vs F again. I meant the F.
14:53:38 <lavorno> quchen: for the haskell version you need to define a fmap for Foo
14:54:32 <lavorno> (i mean for the functor instance of Foo)
14:54:58 <quchen> lavorno: That was just an example paste, but thanks. :-)
14:55:06 <lavorno> np :)
14:56:10 * hackagebot containers-unicode-symbols 0.3.1.1 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.3.1.1 (RoelVanDijk)
15:03:26 <Ontolog_> in a do block, can I move all my let statements to the top, even if they work on data that was bound using <- ?
15:04:41 <c_wraith> Ontolog_: no. declarations inside a single let block can be re-ordered arbitrarily, but names bound via <- cannot
15:04:51 <typoclass> Ontolog_: no, in a do block, there is an order. "first this, then that"
15:05:05 <typoclass> Ontolog_: could you tell us why you need that?
15:05:08 <Ontolog_> i see, so the let declarations are also subject to order
15:05:13 <Ontolog_> it's not a necessity
15:05:17 <Ontolog_> just that the do blocks look messy
15:05:30 <Ontolog_> a <- someIO
15:05:35 <Ontolog_> let blah = somethingWith a
15:05:35 <c_wraith> it sounds like C89ism sneaking in
15:05:37 <Ontolog_> etc
15:05:44 <c_wraith> well, you can eliminate a lot of stuff like that
15:05:55 <c_wraith> blah <- somethingWith <$> someIO
15:06:10 <c_wraith> Obviously, you can overdo that transformation
15:06:20 <c_wraith> But it's handy at least some of the time.
15:07:22 <typoclass> Ontolog_: ok, but i think collecting all the 'let' stuff in one place would only help superficially :-) you'd then have to constantly refer back and forth
15:07:55 <typoclass> Ontolog_: in general, #haskell is a pretty good tool for reorganizing code
15:08:19 <Ontolog_> i also ask because i understand that all operations in haskell are lazy anyway
15:08:36 <croikle> and all programmers
15:08:47 <Ontolog_> so it seems that the order of most statements won't matter
15:08:53 <Ontolog_> lol
15:09:07 <Ontolog_> croikle: only the good ones are lazy
15:09:12 <c_wraith> well.  Don't think of a do block as standard bindings
15:09:20 <quchen> Ontolog_: Laziness is that the actual value can be delayed; however, the object still has to be defined when you use it.
15:09:25 <c_wraith> It's not.  It's syntactic sugar for creating a function call chain.
15:10:04 <c_wraith> And the way the function calls are chained together introduces dependencies between the arguments
15:10:08 <saml> > let me show off my haskell skills
15:10:10 <lambdabot>   <hint>:1:34: parse error (possibly incorrect indentation)
15:10:31 <c_wraith> (the exact dependencies it creates depend on the exact definitions of >>= and >> being used)
15:10:32 <hiptobecubic> saml, needs ""
15:10:52 <saml> " is monad, right?
15:11:04 <hiptobecubic> yes actually
15:11:07 <hiptobecubic> well ""
15:11:29 <hiptobecubic> plus some appropriate definitions borrowed from []
15:11:33 <saml> " :: [CharEscapedQuote]
15:11:49 <saml> " :: [CharEscapedQuote] -> PromiseClosingQuote
15:13:06 <parcs> Ontolog: there's a language extension for that -- RecursiveDo
15:13:37 <parcs> > do rec { y <- return x'; let x' = 1+x; x <- return 1; }; return y;
15:13:39 <lambdabot>   <hint>:1:42: parse error on input `<-'
15:13:50 <parcs> lambdabot probably doesn't have it enabled
15:13:58 <typoclass> this is to announce the following new lambdacat -- http://i.imgur.com/HmimrK8.jpg
15:20:47 <ab9rf> i thought (=^.^=) was a lambdacat
15:23:06 <Xaratas> nice
15:23:41 <Xaratas> which function should i rename to this? :)
15:24:31 <parcs> { std::vector<int> vec{100}; int i = 0; std::for_each(vec.begin(), vec.end(), [&] { ++i }); cout << i; }
15:24:36 <geekosaur> that'd be (=Œª.Œª=) :p
15:24:44 <ab9rf> geekosaur: heh
15:24:47 <parcs> ..damn
15:25:36 <glguy> parcs: What's that "[&]" business?
15:25:55 <parcs> glguy: it's a lambda that captures variables by reference
15:26:04 <parcs> [=] { .. } is by value
15:26:18 <ab9rf> parcs: is that C++11?
15:26:22 <parcs> yeah
15:26:35 <parcs> it's quite nice :)
15:32:26 <ab9rf> about time C++ got lambdas
15:33:16 <typoclass> parcs: what's that code doing?
15:34:54 <c_wraith> My guess is that it's printing 0 to 99
15:35:30 <typoclass> ah, it's got to be a vector (array, list, whatever) of length 100, which then is used only for the loop
15:35:56 <CodeWeaverX> Greetings.
15:36:05 <parcs> typoclass: aside from the silly mistakes, it's calculating and printing the length of a 100-element vector of 0s :P
15:36:28 <c_wraith> oh, right. It's printing i at the end of the loop, not during it
15:36:38 <c_wraith> I missed that semicolon
15:37:15 <quchen> Is {100} some new shorthand?
15:37:27 <quchen> I would've thought it's (100)
15:37:39 <typoclass> parcs: thanks
15:37:42 <quchen> CodeWeaverX: Hello
15:38:43 <typoclass> > foldr (\_ -> succ) 0 (replicate 100 0) -- would this be our way of doing that?
15:38:44 <lambdabot>   100
15:40:52 <CodeWeaverX> Got an odd type question that I can't seem to kick google into giving me an answer to‚Ä¶.
15:40:53 <CodeWeaverX> If I have a data type that takes two type parameters, like Either does (a and b), how do I construct a Foldable instance (or an instance of any class)?    Like, how would you fold over (SomePair a _), and separately over (SomePair _ b)?
15:41:32 <ocharles> typoclass: well, sum (replicate 100 0), probably
15:41:37 <ocharles> oh wait...
15:41:41 <ocharles> it's late :(
15:41:53 * ocharles switches brain off
15:42:08 <CodeWeaverX> I guess the real question is how I can specify one of the two parameters as a real type but leave the other unstated for picking up by being an instance of Foldable.
15:42:22 <glguy> CodeWeaverX: Foldable specifically works on things of kind *->*, so if you want to write a Foldable instance you'd have to make a newtype with the arguments in the other order
15:42:22 <quchen> CodeWeaverX: You can't directly make an instance for "SomePair _ b", you'll have to wrap it in some argument-switching type (as there's no kind-level lambda).
15:42:26 <typoclass> ocharles: sure :-) it's all a bit bananas, i just tried to mimic the c++
15:43:14 <hpc> CodeWeaverX: newtype Flip f b a = Flip {unFlip :: f a b} -- might be one way
15:43:39 <typoclass> CodeWeaverX: part of the answer may be "instance Something (Either a) where ...". note how this only specifies one of Either's parameters
15:44:02 <startling> is there an applicative-only Writer somewhere?
15:44:19 <hpaste> quchen pasted ‚ÄúEither foldables‚Äù at http://hpaste.org/85506
15:44:28 <ocharles> startling: does WrappedMonad Writer count? :)
15:44:34 <startling> ocharles: heh
15:44:43 <ocharles> startling: what about Const?
15:45:29 <parcs> quchen: most of the time T foo{..}; is equivalent to T foo(..); but the former doesn't trigger c++'s "most vexing parse" http://en.wikipedia.org/wiki/Most_vexing_parse
15:45:57 <startling> ocharles: not quite. I want to be able to wrap a function in an applicative that keeps track of which keys in a Map must exist for it to execute.
15:46:43 <ocharles> startling: oh, you want tracing
15:46:45 <typoclass> parcs: what on earth
15:47:01 <startling> ocharles: is that what it's called?
15:47:26 <ocharles> startling: it's covered in http://comonad.com/reader/2012/abstracting-with-applicatives/ and http://gergo.erdi.hu/blog/2012-12-01-static_analysis_with_applicatives/
15:47:33 <CodeWeaverX> Okay, so the short answer is that it's likely the only practical way is a data-type-level Flip.
15:47:37 <startling> ocharles: very cool. thanks
15:47:50 <ocharles> the former is probably what you want
15:47:53 <js6i> Is there some library available for parsing and evaluating simple math expressions?
15:48:01 <ocharles> (namely the 'HasEnv' stuff)
15:48:39 <ab9rf> parcs: C++ is such a fucked up little language
15:48:56 <quchen> parcs: Oh. That is very odd.
15:49:22 <CodeWeaverX> Thanks.  I'll see what I can do.  Thought I was missing some sort of type-level wildcard.
15:49:57 <quchen> js6i: What are "simple math expressions"? If it's just +-*/ etc, it's a beginner exercise to write something like that yourself.
15:49:59 <geekosaur> the more I find out about C++, the less I want anything to do with it
15:50:09 <seliopou> geekosaur: +1
15:50:18 <CodeWeaverX> Heh, you get used to C++.  There are peole I know who use it who won't have anything to do with Haskell.
15:50:20 <CodeWeaverX> *shrug*
15:50:25 <js6i> quchen: operators, parentheses, some predefined functions like exp and predefined variables
15:50:42 <quchen> CodeWeaverX: Most people that dislike Haskell haven't tried it. For C++ it's the other way round.
15:50:45 <seliopou> two words: lib boost
15:50:47 <seliopou> *shudder*
15:50:53 <js6i> e.g. (e-n)*exp(-2.5*e)
15:51:09 <startling> quchen: most people who like C++ haven't tried it?
15:51:11 <CodeWeaverX> quchen:  I'm afraid my experience doesn't agree with that.  I know plenty of people who use it and are fine with it.
15:51:23 <startling> CodeWeaverX: that's not what he said.
15:51:34 <CodeWeaverX> Then my parsing has fail.
15:51:37 <ab9rf> C++ is C with a ton of random shit shoveled on top without rhyme or reason
15:51:40 <CodeWeaverX> S'okay, insufficient coffee.
15:51:46 <startling> it was presumably "most people who don't like C++ have tried it."
15:51:47 <ab9rf> i use C++
15:51:51 <ab9rf> i can't say i enjoy using C++
15:52:04 <CodeWeaverX> I'm not going to even slightly argue with your personal preferences. :)
15:52:26 <ab9rf> in fact, C++ has come close more to once to forcing me to buy a new laptop
15:52:33 <ab9rf> er, more than once
15:52:37 <quchen> js6i: In that case it falls under the beginner exercise. What you want to do is write a parser for expressions of that type (are you familiar with Parsec?), and then an evaluator of the parse result.
15:52:46 <geekosaur> maybe it should be called c??
15:52:53 <CodeWeaverX> ab9rf: That's‚Ä¶ a weird consequence.
15:53:01 <geekosaur> with the additional advantage/warning that it then looks like the start of a trigraph :p
15:53:14 <ab9rf> CodeWeaverX: when you have to resist the urge to throw your laptop out a window becauseof some stupid C++ behavior....
15:53:16 <js6i> quchen: yea I'm familiar with Parsec, but I would rather not reinvent the wheel. I thought it's common enough to have a library.
15:53:29 <CodeWeaverX> ab9rf: AHHH‚Ä¶ got it now. :)
15:54:46 <startling> CodeWeaverX: have you *tried* compiling large C++ projects on a circa-2007 laptop?
15:54:57 <quchen> js6i: Hm. Well I haven't heard of such a lib yet. Searching Hackage for "calculator" however brings up a few results that may be interesting.
15:55:01 <geekosaur> the problem with a library is that how exactly you want the generated ast to look depends strongly on exactly what ypu're going to do with it
15:55:19 <geekosaur> suppose it could be done with a sufficiently complex load of metaprogramming
15:55:27 <js6i> quchen: OK thanks. Maybe I'll roll some lib on my own then.
15:55:28 <seliopou> startling: make -j‚Ä¶ oh
15:55:28 <romm> startling, better slower compile time than a slower runtime.
15:55:58 <startling> romm: false dichotomy.
15:56:03 <quchen> js6i: Hascal looks like a match. http://new-hackage.haskell.org/package/hascal-2.0.0/docs/Hascal.html
15:56:04 <startling> seliopou: :D
15:56:08 <CodeWeaverX> startling: Not sure if I can come up with something that *sounds* that bad, but I've had to build some pretty massive projects in C++ before.  Fortunately, most of the time I was fortunate enough to use a distributed compilation tool for it.
15:56:25 <quchen> js6i: It's pretty much the minimal implementation you'd write yourself though, minus Parsec :-)
15:56:30 <CodeWeaverX> I've had multi-hour builds.  Unfun.
15:56:38 <startling> CodeWeaverX: yeah. sucks. :/
15:56:41 <lavorno> CodeWEaverX: i used c++ quite a lot at a point and i liked it. now getting up to speed with haskell and i think each have their own +/-.. (but more - on c++ = maybe should be called C-- instead :p )
15:56:54 <CodeWeaverX> lavorno:  Yup. heheh.
15:57:03 <js6i> quchen: I saw it but its quite badly limited, no parens and such. I might look at the code though.
15:57:05 <CodeWeaverX> Listen, didn't want to start a language war.  Wasn't really my point.  I find them pointless. ;)
15:57:17 <startling> CodeWeaverX: agreed.
15:57:27 <lavorno> CldeWeaverX: don't even try, haskell people are pacifist
15:57:45 <lavorno> they will fight you to death to keep peace around :)
15:57:45 <CodeWeaverX> Not interested in trying. ;)
15:57:50 <CodeWeaverX> hahaha
15:58:15 <startling> lavorno: if you complain that haskell doesn't have tco, on the other hand ...
15:58:29 <romm> unless every commit you guys do involves 100 translation units, i really don't understand the problem you have with "slow compile time"
15:58:31 <lavorno> startling: ?
15:58:59 <lavorno> type coercion ?
15:59:09 <startling> lavorno: tail-call optimization. ;)
15:59:15 <lavorno> :)
15:59:32 <ab9rf> i parsed tco as 'total cost of ownership'
15:59:35 <lavorno> startling: no, i complain that haskell has too many ways to handle exceptions..
15:59:41 <donri> lavorno: militant pacifists?
16:00:06 <lavorno> donri: yeah - think green peace, but hugging lambdas
16:00:19 <ab9rf> damn lambda huggers
16:00:21 <quchen> lavorno: I can think of two kinds of exceptions.
16:00:32 <startling> I heard the greeks had their worst lambda-hunting season in history this year.
16:00:52 <lavorno> startling: hahaha.. been there last summer.. not a pretty sight
16:01:42 <lavorno> quchen; exceptions, maybe, either / pure, i/o, etc
16:02:44 <quchen> lavorno: Well, Maybe/Either/Error are the same concept, IO is the other one.
16:03:09 <lavorno> quchen: i love hask and trying to use it for a large and so far works great, but i'm really stuck now deciding what unified exc handling approach to take (i hear einstein didn't solve the unification problem to his final demise.. and i don't feel too good nowadays either :) )
16:03:30 <quchen> Maybe doesn't really do much exception stuff, it's more like a hit-and-miss thing, like an early "-1" return.
16:03:47 <lavorno> quchen: agreed, not planning to use it
16:04:03 <croikle> http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/ discusses some of this
16:04:52 <lavorno> quchen: the real contenders are either, exc, but don't have a clue how do use them unified..
16:05:27 <lavorno> crokle: yes, i've read that already, it's a re-hash on a previous 8 ways.. and i think the name itself tells the whole story..
16:05:35 <startling> EitherT [String] is pretty useful imo.
16:05:46 <quchen> lavorno: I wouldn't use them unified.
16:06:04 <lavorno> quchen: sounds good, but how would u use them
16:06:20 <quchen> It's mostly EitherT CustomError for me, and IO if I absolutely can't get around it.
16:06:23 <lavorno> startling: yes, either is a good candidate - but how about i/o, arrows, etc
16:06:37 <quchen> Eh, ErrorT ^^
16:07:14 <lavorno> quchen: the approach i'm trying based on ezyang and other's suggestions is a typed either
16:07:37 <lavorno> and  in general that seems to be ok, but..
16:07:38 <startling> lavorno: how do you mean?
16:08:15 <lavorno> startling: Either CustomError SomeDetails where CustomError is an enum
16:08:27 <startling> oh, that.
16:08:33 <quchen> Enum? Why Enum?
16:08:48 <lavorno> quchen: so i don't have to match on strings
16:09:11 <lavorno> (when catching an exception/Left/etc)
16:09:12 <quchen> Make your own error type then, don't use flat strings
16:09:25 <lavorno> quchen: yes, that's what i was saying
16:09:42 <lavorno> quchen: the problem with that is i have to change the signatures of all the functions so far..
16:09:48 <quchen> Oh. "Either CustomError SomeDetails" confused me.
16:09:54 <lavorno> with Eithers.. sprnklied for good measure
16:09:55 <quchen> lavorno: Use type synonyms for that :-)
16:10:23 <lavorno> quchen: what do u mean ?
16:11:20 <quchen> lavorno: Don't write the error type in each type signature, make a declaration "type Foo = ErrorT ..." at the beginning. Changing the error type will probably be easier this way.
16:11:28 <quchen> Can't do that in retrospect to save work of course.
16:12:19 <lavorno> quchen: so you are suggesting to embed the Either in the types ?
16:13:28 <chrisdotcode> hi haskell guys :)
16:14:52 <ab9rf> quchen: aside from using global search and replace :)
16:15:27 <chrisdotcode> does anybody here use haskell-unicode for vim? can you guys help me get it working?
16:15:29 <lavorno> quchen: wouldn't that be worse ? as i'll have some types that look like regular ones but have embedded error/either/exception semantics (?)
16:15:30 <startling> @pl \g -> f g (a g)
16:15:30 <lambdabot> ap f a
16:16:10 <otters> @pl \g a -> f g (g a)
16:16:10 <lambdabot> (.) =<< f
16:19:35 <Ghoul__> Holy shit
16:19:51 <Ghoul__> 7.6.1 ghc should have been called haskell-redux
16:19:57 <ab9rf> Ghoul__: nah only vaguely reverent shit
16:19:58 <Ghoul__> All those language extensions o-o
16:20:24 <Ghoul__> ab9rf: wot
16:21:59 <quchen> lavorno: Give them useful names
16:22:33 <quchen> Call them "Throws" or something like that
16:22:47 <quchen> Anyway, bedtime! Good night everyone.
16:22:47 <lavorno> quchen: "Throw-Aways" :)
16:22:51 <quchen> :P
16:22:58 <quchen> type FireAndForget = ...
16:23:06 <ab9rf> call them cookies, with operation "toss"
16:23:13 <lavorno> quchen: good night and ForgetAboutIt
16:23:41 <merijn> Ghoul__: Well, 7.6 doesn't have significantly more extensions than 7.4, I think :p
16:23:55 <lavorno> ab9rf: MaybeCookieCrumbler
16:28:34 <ab9rf> where's the changelog for 7.6.x?
16:29:40 <merijn> ab9rf: Linked from haskell.org/ghc, for example: http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/release-7-6-2.html
16:30:16 <hpc> what's the bug for that first bullet?
16:30:46 <ab9rf> merijn: i looked there but didn't see it
16:30:48 <ab9rf> merijn: thanks
16:33:18 <merijn> 1st World Dev Problems, I upgraded to a new compiler with the changes I've wanted for ages and my automatic syntax error highlighter doesn't know the new syntax yet >.>
16:34:32 <Fuuzetsu> merijn: ...and that's precisely why you're going to update the highlighter and release it for others to use, right?
16:37:40 <merijn> Fuuzetsu: Right...because I needed one more layer of yak shaving :)
16:47:31 <startling> is there something like Monoid like "class Something m where mempty :: m a; mappend :: m a -> m a -> ma; pure :: a -> ma;" ?
16:48:21 <byorgey> startling: there's MonadPlus
16:48:32 <byorgey> which may or may not be what you are looking for.
16:48:33 <magicman> startling: Not in that form. Add (>>=) :: m a -> (a -> m b) -> m b, and you have MonadPlus, alternatively, add (<*>) :: m (a -> b) -> m a -> m b, and you have Alternative.
16:48:39 <shachaf> There is http://hackage.haskell.org/packages/archive/reducers/3.0.1/doc/html/Data-Semigroup-Reducer.html
16:48:45 <startling> byorgey: and Alternative, too. hmm
16:49:11 <shachaf> Alternative may or may not actually be what you want...
16:49:19 <magicman> Oh, that Reducer looks good.
16:49:31 <startling> > [1, 2] <|> [3]
16:49:33 <lambdabot>   [1,2,3]
16:49:37 <magicman> I take it snoc and cons are defined in terms of unit and mappend.
16:49:39 <shachaf> Hmm, is there foo :: Alternative f => f a -> f b -> f (Either a b)?
16:50:05 <shachaf> magicman: Taking it from the source link on that page? :-)
16:50:06 <magicman> :t \a b -> fmap Left a <|> fmap Right b
16:50:07 <lambdabot> Alternative f => f a -> f b -> f (Either a b)
16:50:50 <otters> > (\a b -> fmap Left a <|> fmap Right b) $ [1,2] <|> 3
16:50:52 <lambdabot>   No instance for (GHC.Num.Num [a0])
16:50:52 <lambdabot>    arising from a use of `e_1123'
16:50:52 <lambdabot>  Possi...
16:50:56 <otters> > (\a b -> fmap Left a <|> fmap Right b) $ [1,2] <|> [3]
16:50:57 <lambdabot>   *Exception: show: No overloading for function
16:51:09 <otters> Hmm.
16:51:39 <otters> oh, I was doing it wrong.
16:51:44 <shachaf> Yes.
16:56:31 <thirsteh> How do I convert a NominalDiffTime to milliseconds?
16:57:37 <shachaf> Maybe something involving toRational?
16:57:39 <Eduard_Munteanu> thirsteh: it has a Rational instance
16:57:40 <thirsteh> found this: secsToMillis t = realToFrac t * (10^(3 :: Int))
16:57:57 <Eduard_Munteanu> Err.
16:58:09 <shachaf> RealFrac
16:58:18 <Eduard_Munteanu> Real. :)
16:58:24 <shachaf> That too.
16:58:32 <Eduard_Munteanu> I always confuse those.
16:58:40 <shachaf> Oh, you've already found the answer.
16:58:45 <shachaf> Eduard_Munteanu: I don't blame you, given
16:58:47 <shachaf> @src Real
16:58:47 <lambdabot> class  (Num a, Ord a) => Real a  where
16:58:47 <lambdabot>     toRational      ::  a -> Rational
16:59:27 <thirsteh> yeah, I wasn't expecting to find the answer at the bottom of http://hackage.haskell.org/packages/archive/benchpress/0.2.2.6/doc/html/src/Test-BenchPress.html right after
17:01:28 <startling> hmm, what's that typeclass that's just "pure" and where do I find it?
17:01:37 <c_wraith> pointed
17:01:44 <c_wraith> No clue where it lives these days
17:02:17 <byorgey> it lives in http://hackage.haskell.org/package/pointed
17:02:19 <shachaf> @hackage pointed , maybe
17:02:19 <lambdabot> http://hackage.haskell.org/package/pointed , maybe
17:02:22 <byorgey> but why do you want it?
17:02:25 <shachaf> Note that it's evil.
17:02:34 <byorgey> it's not evil.  just useless.
17:02:37 <Eduard_Munteanu> I think edwardk's stuff uses it.
17:03:05 <kfish> startling: what use-case do you have for it?
17:03:17 <startling> because I can do some interesting operations on stuff assuming I have mappend, mempty, and pure, but (<*>) isn't necessary.
17:03:20 <byorgey> Eduard_Munteanu: not much.
17:03:45 <startling> and the data structure I have in mind is a monoid and a pointed but not an applicative.
17:04:03 <byorgey> ah, I have run into that combination before
17:04:11 <byorgey> it lets you build data structures from a collection of elements.
17:04:16 <startling> right.
17:04:55 <startling> this is something like data Tree a = Tree [(a, Maybe (Tree a))].
17:06:18 * hackagebot hoodle-publish 0.1 - publish hoodle files as a static web site  http://hackage.haskell.org/package/hoodle-publish-0.1 (IanWooKim)
17:06:45 <startling> shachaf: so why is Pointed evil?
17:07:03 <shachaf> Well, it's not exactly evil.
17:07:11 <shachaf> Also what you want isn't Pointed, it's a different class.
17:07:33 <startling> shachaf, what's wrong with (Monoid (m a), Pointed m) => ?
17:08:01 <shachaf> What are the laws here?
17:08:38 <otters> uh
17:08:41 <otters> so what is "point" for
17:08:47 <otters> what's the point of it
17:08:56 <startling> shachaf: mempty `mappend` pure x == pure x I guess.
17:09:11 <startling> and associativity of `mappend`
17:09:23 <shachaf> How do you get that from (Monoid (m a), Pointed m)?
17:09:34 <startling> shachaf: from the monoid laws?
17:09:50 <startling> since mempty `mappend` x == x already
17:10:02 <shachaf> Oh, yes.
17:10:09 <shachaf> So what are the laws of this new structure?
17:10:41 <startling> that's it, I think.
17:11:18 <byorgey> I think the laws you want have to be stated in terms of a Foldable or Traversable instance
17:11:21 <otters> uh
17:11:24 <liyang> Wait wat? Tree is obviously and naturally a monad, so you can easily make it Applicative.
17:11:31 <otters> so is point like return or pure?
17:11:46 <Eduard_Munteanu> otters: yeah
17:11:47 <startling> otters: yes.
17:11:50 <otters> what does pointed mean?
17:11:58 <Eduard_Munteanu> otters: it's Applicative without (<*>)
17:12:04 <otters> oh
17:12:20 <Eduard_Munteanu> (which isn't much of an Applicative anymore though)
17:12:27 <startling> liyang: that Tree I wrote above?
17:12:30 <otters> so it's just "pure"
17:12:43 <byorgey> e.g. fold (point x <> point y) == fold [x,y]
17:12:47 <otters> I see
17:13:12 <liyang> startling: Yes, use substitution as as bind. Hutton talks about trees and substitution (as one instance of it) before even mentioning monads.
17:14:23 <shachaf> That could be a reasonable sort of law. It'd be more convincing if Foldable had any laws. :-(
17:14:26 <byorgey> liyang: well, it's not quite that simple, since you have to decide how to substitute for a's which have a Tree paired with them
17:14:44 <byorgey> I am confident you can make it a Monad, but it is not that straightforward.
17:15:06 <byorgey> i.e. just saying 'substitution' is only enough when all the a's occur as leaves.
17:15:10 <startling> liyang: are you sure you read it right? I'm having trouble seeing it.
17:16:00 <liyang> byorgey, startling: oh, didn't realise being bushy made a difference... hmm.
17:16:20 <liyang> (of course I've never written such an instance myself. ^^;;)
17:16:26 <startling> heh
17:19:30 <feliperosa> Hello :). Have any of you guys worked with Database.HDBC.Sqlite3? I'm having some trouble enabling foreign keys (with pragma).
17:19:34 <diracdelta> Math question: I can have multiple functions from String->String. But categories (perhaps this is wrong) seem to allow only one arrow between a pair of objects.
17:19:43 <diracdelta> How can we make Hask a category?
17:19:50 <liyang> Guess you'll need to graft branches onto the tree where the non-leaf 'a's live, as well as extending the leaves.
17:20:18 <byorgey> diracdelta: that is wrong.
17:20:32 <byorgey> diracdelta: a pair of objects can have arrows between them.
17:20:36 <byorgey> *many arrows
17:20:55 <hpc> diracdelta: the rules of categories are that you have an identity arrow from each object to itself, and a way to compose arrows
17:21:11 <hpc> (put roughly, i am not very good at the CT side of things)
17:21:15 <byorgey> diracdelta: in fact, "most" categories have many arrows between pairs of objects.  categories with at most one arrow between each pair of objects are called posets.
17:22:00 <shachaf> Even when they aren't small? :-)
17:22:12 <byorgey> if they aren't small they are called POSETS
17:22:26 <byorgey> or maybe POCLASSES
17:22:39 <shachaf> One place calls them "thin".
17:22:50 <byorgey> I like that
17:23:08 <otters> Oh, that's what "Hask" means.
17:24:34 <no-n[4]> {-would-} func ((0,x):xs) = foo {-\n-} func ((i,x):xs) = bar {-be less efficient than-} func ((i,x):xs) {-\n-} | i == 0 = foo {-\n-} | otherwise = bar {-because more extracting stuff from patterns?-}
17:25:09 <shachaf> They mean the same thing.
17:25:21 <shachaf> I would probably write the former because it looks a bit nicer.
17:25:23 <byorgey> no-n[4]: it is highly unlikely to make any discernible difference.
17:25:35 <no-n[4]> they're logically equivalent, but you're doing something twice in the first case
17:25:48 <no-n[4]> byorgey: yeah, I'm guessing it would be
17:25:49 <shachaf> But pattern matching on numbers is a hack anyway.
17:25:56 <shachaf> no-n[4]: Why don't you try it?
17:26:45 <no-n[4]> there would be no discernible difference I guess I was just asking if it did involve more "doing"
17:26:52 <no-n[4]> please disregard :P
17:27:12 <no-n[4]> why is pattern matching on numbers a hack?
17:27:26 <byorgey> it compiles into a test for equality
17:27:36 <shachaf> I say you should test it.
17:27:41 <byorgey> unlike pattern matching on actual constructors.
17:27:51 <CodeWeaverX> One man's "syntactic sugar" is another man's "hack". ;)
17:27:53 <otters> numbers aren't an algebraic datatype
17:28:00 <otters> not in Haskell anyway
17:28:03 <no-n[4]> so would the idiom be to use guards instead?
17:29:16 <byorgey> no-n[4]: no, pattern matching on numbers is great.  I think shachaf just meant that since pattern matching on numbers works differently anyway, you can't infer anything about "doing something twice"
17:29:38 <no-n[4]> ok
17:31:54 <CodeWeaverX> Also really compact and clear what the intent is.  I love reading straightforward haskell code. ;)
17:32:07 <CodeWeaverX> Wish I was better at reading the scary stuff some of these guys paste.
17:32:14 <CodeWeaverX> hah hah
17:32:16 <merijn> CodeWeaverX: iow, you hate my code xD
17:32:22 <CodeWeaverX> :D
17:32:30 <CodeWeaverX> Its been a while.  I'm getting back into it.
17:32:40 <merijn> Nothing says welcome like 8 lines worth of extensions at the top of the file :)
17:32:50 <CodeWeaverX> Ouch.
17:32:53 <CodeWeaverX> Just ouch.
17:33:02 <CodeWeaverX> I'm not *there* yet.
17:33:05 <CodeWeaverX> For better or worse.
17:33:35 <no-n[4]> :]
17:33:54 <hpc> you can easily end up never writing code that requires language extensions
17:34:10 <merijn> It's a slippery slope, one day you wonder what GADTs are, the next your code all starts {-# LANGUAGE DataKinds, PolyKinds, KindSignatures, GADTs, TypeFamilies, TypeOperators, RankNTypes, etc #-} ;)
17:34:14 <CodeWeaverX> Well, I'd be of the philosophy 'use 'em when its obvious that doing without them causes you 8 weeks more work'
17:34:18 <hpc> if you stick to such pedestrian things as dealing with IO :P
17:34:27 <CodeWeaverX> hah. :)
17:34:49 <hpc> data families are really cool and i want to figure out a good use for them
17:34:52 <hpc> they seem under-used
17:35:09 <merijn> hpc: Encode more invariants in your types!
17:35:59 <hpc> ill figure it out in 50 years when i finally finish my current project
17:36:12 <merijn> Do what I do, never finish your projects!
17:36:22 <startling> oh huh, guess I don't really need Pointed at all.
17:36:24 <hpc> im well on my way to that
17:36:32 <merijn> High five!
17:36:41 <hpc> the end result of... 6 months at this point?
17:36:46 <hpc> is 78 lines of code
17:36:53 <startling> hpc, you've still got a lot of time to cover if you want it to take forever.
17:36:54 <hpc> 8 of which are how to use the script
17:37:02 <hpc> and 10 more are imports
17:37:08 <startling> 20 are extensions?
17:37:17 <hpc> no :P
17:37:41 <merijn> Haskell is for people who have better things to do than something as plebeian as write code
17:37:44 <hpc> i rarely use extensions, unless i have something very particular i want a type to be able to do
17:38:03 <hpc> merijn: it's more laziness, for me
17:38:31 <hpc> i would much rather be doing minecraft :P
17:39:07 <merijn> hpc: Of course, but you have to market yourself if you wanna get paid ;)
17:39:11 <startling> welp, just deleted 80% of that once I realized Pointed wasn't really what I wanted.
17:39:44 <hpc> i plan to wait for the next bitcoin crash, then invest $100
17:39:49 <hpc> 6 months later i will be a billionare
17:39:58 <startling> shachaf: you were right, I had no idea what kinds of constraints I needed.
17:40:21 <merijn> hpc: Join the club ;)
17:40:35 <Eduard_Munteanu> Pfft, you guys wait, I'm making money now. :P
17:40:58 <merijn> I was to busy laughing to get in on the con :(
17:41:05 <hpc> same
17:41:16 <hpc> i do want to put in $100, just to see what happens
17:41:25 <hpc> i am expecting to lose all of it
17:42:00 <hpc> hmm, i am now at the hard part of this tool
17:42:17 <hpc> figuring out from current data if we should increase traffic or reduce it
17:42:34 <hpc> eh, that's for tomorrow (read: next week)
17:42:38 * hpc asleeps
17:43:22 <lavorno> hpc: sweet dreams... assuming you are "investing" 100 and others will probably invest a lot more, how is the value inflation gonna play out ? (if you win one million for 100 others who have invested 10,000 will win.. X :) )
18:06:55 <slack1256> the definition "reNewRegexes :: (MonadState UrlRegex m) => m ()" will be rejected
18:07:23 <slack1256> because fixating the UrlRegex we also are fixating the monad because of functional deps right?
18:14:02 <slack1256> anybody awake? ;_;
18:15:12 <aavogt> slack1256: the fundep goes the other way
18:15:15 <byorgey> slack1256: that definition will not be rejected.
18:17:00 <slack1256> Mmm so "class Monad m => MonadState s m | m -> s where" means that "m" is uniquely defined by s
18:17:07 <slack1256> no the other way around.
18:17:18 <slack1256> but the above definition ask me for flexibleContents
18:18:17 <byorgey> slack1256: that has nothing to do with the fundep.
18:18:47 <hpaste> slack1256 pasted ‚ÄúflexibleContents?‚Äù at http://hpaste.org/85514
18:19:10 <slack1256> I know is dumb code but, reNewRegexes gives me trouble.
18:19:10 <byorgey> it's just that the context MonadState UrlRegex m  is not allowed by the (very conservative) Haskell standard, because UrlRegex is not a variable.
18:19:27 <byorgey> slack1256: turning on FlexibleContexts is about as uncontroversial as it gets.
18:20:02 <byorgey> just add FlexibleContexts after GeneralizedNewtypeDeriving
18:20:06 <slack1256> Mmmm well if you say.
18:20:08 <slack1256> Ok
18:21:04 <shachaf> I,I (MonadState s m, s ~ UrlRegex) => ... -- no FlexibleContexts necessary!
18:21:25 <slack1256> well, it works, now I got to read about, FlexibleContexts
18:21:26 <byorgey> haha
18:21:33 <slack1256> shachaf: let me try that
18:21:46 <byorgey> slack1256: shachaf was joking.  That requires you to turn on TypeFamilies.
18:21:59 <byorgey> but indeed it does not require FlexibleContexts.
18:22:44 <slack1256> Oh. Ok
18:23:19 <byorgey> which is like flying a jumbo jet to your friend's house three blocks away, because you are worried that walking might be bad for the environment
18:24:41 <slack1256> maybe that extension would make more sense if I was using mtl-tf
18:25:06 <slack1256> if it was actualized.
18:25:33 * sw2wolf time to work
18:26:18 <slack1256> thanks byorgey, shachaf
18:26:34 <liyang> Yes time to stop stubbornly trying to make a Tree monad that makes sense and get to work.
18:27:38 <liyang> (The way I thought was obvious meant the whole tree collapsed any time you looked at it funny.)
18:28:45 <wavewave> hi
18:33:16 <CodeWeaverX> ho
18:34:49 <liyang> hi
18:39:06 <wavewave> ho
18:40:17 <liyang> it's off to work we go.
18:43:03 <wavewave> just announced a new package
18:43:20 <heatsink> Hackage does that automatically I think
18:43:41 <wavewave> yes :-)
18:45:51 <heatsink> Are there resources for explaining how to discuss data structures with programmers who aren't comfortable with abstract algebra or type theory?
18:47:10 <wavewave> heatsink : okasaki's book?
18:47:17 <ab9rf> heatsink: crowbars?
18:47:20 <heatsink> For me, if I can't use algebra and type theory, discussion tends to get bogged down in details about what things are allowed to be null, what things can point to what other things, what arrays must have the same length, etcetera
18:47:42 <heatsink> so that it takes a long time to make sense out of stuff
18:47:52 <ab9rf> heatsink: i'm not all conversant with type theory and my algebra is insanely rusty
18:48:06 <Cale> Just start defining clearly what the values belonging to any individual type are using logic.
18:48:06 <ab9rf> heatsink: but the things yu describe are not a problem for me
18:48:11 <Nisstyre-laptop> ab9rf: abstract algebra isn't too hard to learn the basics of
18:48:12 <RichyB> Okasaki's book discusses a whole bunch of functional container data structures by analogies to representations of integers.
18:48:21 <ab9rf> Nisstyre-laptop: no, i learned those when i was 15
18:48:28 <Nisstyre-laptop> it's more about the basic properties of sets and operators, at least when you learn the basics
18:48:33 <ab9rf> Nisstyre-laptop: basic abstract algebra was part of my high school math curriculum
18:48:36 <RichyB> (at least IIRC, since that's the aspect of it that stuck with me)
18:48:50 <Nisstyre-laptop> ab9rf: you learned about groups/fields/semi-groups/etc... in HS?
18:48:58 <ab9rf> Nisstyre-laptop: groups, rings, and fields
18:48:59 <heatsink> Analogies to integers, you mean how linked lists are like peano numbers
18:49:00 <heatsink> ?
18:49:09 <Nisstyre-laptop> ab9rf: where did you go to school?
18:49:16 <ab9rf> Nisstyre-laptop: indianapolis, indiana.  public high school.
18:49:32 <Nisstyre-laptop> weird, I didn't think the American system taught any of that at a HS level
18:49:33 <Cale> heatsink: For example, "Every value of type Maybe a is either the value Nothing, or it is an expression (Just x) where x is of type a."
18:49:37 <Nisstyre-laptop> were you in a "gifted" program?
18:49:53 <ab9rf> we spent one six-week period on introduction to abstract algebra in sophomore math
18:50:04 <ab9rf> Nisstyre-laptop: this was the honors program, but not officially "gifted"
18:50:07 <Nisstyre-laptop> ab9rf: was it the normal curriculum?
18:50:09 <Nisstyre-laptop> oh okay
18:50:11 <heatsink> Cale, that's expanding out an algebraic data type definition, but I don't see what you're getting at
18:50:23 <ab9rf> Nisstyre-laptop: i don't know if it was in the mainline curriculum.  i suppose not.
18:50:28 <dolio> heatsink: Yes.
18:50:39 <Cale> heatsink: I'm saying if people are unfamiliar with the algebraic data type definition, just expand it out in terms of English.
18:50:43 <Nisstyre-laptop> ab9rf: I don't think it's common at all
18:51:05 <ab9rf> we started out on the 3-rotation group, booleans, and modulo integers, iirc.
18:51:12 <Nisstyre-laptop> ab9rf: most people don't even learn that stuff at a *University* level unless they take physics/CS/math/etc...
18:51:13 <Cale> heatsink: and then interact with the person to clear up any remaining confusion after giving that precise definition.
18:51:17 <heatsink> Cale, it's more like someone else has a rough idea of a data structure, and I'm trying to get them to explain it to me
18:51:20 <ab9rf> anyhow
18:51:23 <Cale> oh
18:51:34 <Cale> That's the reverse of the context that I thought you had :)
18:51:38 <heatsink> heh
18:52:04 <ab9rf> heatsink: for me the problem is when someone tries to "explain" something by saying it's a furblenurper over the groat of spines, as if that meant something
18:52:08 <Cale> (I thought you were trying to explain a specific datastructure to someone who didn't know anything about types)
18:52:29 <Nisstyre-laptop> ab9rf: yeah not providing examples is bad
18:52:49 <ab9rf> i'm sure whatever words they're using mean someting to someone who has spent the past 30 years absorbing mathematical jargon, but it's useless to poor ol' me, who just knows how to push around bits
18:52:51 <Cale> heatsink: In that case, I'd just get them to describe what the various possibilities are, and try to work out a design for the type from there.
18:53:02 <Nisstyre-laptop> and any math notation can be explained in English, although it might take ages
18:53:18 <Cale> Maybe if they like pointers and such, get them to draw pictures instead
18:53:26 <heatsink> ab9rf, as long as it's a specific enough case, it's usually possible to drop down into less abstract terms... and people should know how to do that when necessary
18:53:48 <Nisstyre-laptop> you can explain some things with analogies
18:53:59 <Nisstyre-laptop> like subtyping can be explained using the idea of hypernyms/hyponyms
18:54:02 <dolio> heatsink: For instance, you can represent sequences as a list of complete binary trees, where you have at most one tree of any given size. Which corresponds to the typical binary representation of the natural numbers.
18:54:05 <Nisstyre-laptop> which most people understand if they speak a language
18:54:37 <heatsink> To describe what the various possibilities are and work out a design based on that... that sounds workable. I'll keep that in mind
18:55:27 <heatsink> Hmm, interesting dolio.  That might make okasaki's book interesting enough for me to pick up.
18:55:48 <dolio> And then you can us skew-binary to avoid cascading carries.
18:55:58 <heatsink> more interesting than just "here's how a bunch of data structures work"
18:55:58 <dolio> To regain O(1) cons.
18:59:14 <dolio> It has a bunch of stuff on doing amortized resource usage analysis, too.
18:59:46 <dolio> Mostly time, I guess.
19:02:48 <edwardk> whats going on with skew binary?
19:03:00 <scooty-puff> for a simple state (in this case, an Int), is it better to use a custom StateT with Pair a = a :*: {-# UNPACK #-} !Int, or a ReaderT (STRef s Int) (ST s) (knowing that (ST s) will be the underlying monad)?
19:03:16 <edwardk> the latter will be a little bit faster
19:03:44 <scooty-puff> k - just fewer allocations on each return, (>>=)?
19:03:46 <edwardk> presuming you have some actions in the monad that don't read the state ;)
19:03:49 <edwardk> yeah
19:06:00 <napping> is there some way to parameterize a type family over a (poly)kind? I was trying to get some of the unification speculated about here http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html
19:06:20 * hackagebot data-interval 0.1.0 - Interval Arithmetic  http://hackage.haskell.org/package/data-interval-0.1.0 (MasahiroSakai)
19:06:49 <napping> something like type family NatMap k (f g :: k) :: *; type instance NatMap * f g = f -> g; type instance NatMap (* -> *) f g = forall a . f a -> g a ...
19:12:20 <byorgey> napping: I think there is a way to do that but I forget the syntax.
19:12:26 <dolio> edwardk: Someone mentioned Okasaki having various number-system-based data structures.
19:13:07 <cmccann> wavewave: hey! you around?
19:14:55 <ab9rf> snort
19:15:03 <ab9rf> i read that as "various murder-system-based data structures"
19:15:49 <cmccann> apparently he isn't :[
19:17:19 <RichyB> dolio: yes, me. His explains the designs of a couple of data structures in terms of e.g. skew binary numbers.
19:18:17 <dolio> edwardk is a skew binary nut.
19:18:29 <RichyB> dolio: and the fact that you can easily prepend to a singly-linked-list in O(1) is explained by the analogy to Peano numbers.
19:18:42 <dolio> He probably has his irc client set to chirp whenever someone says "skew binary."
19:18:47 <edwardk> =)
19:19:07 <cmccann> I generally assume that edwardk is a fan of anything that involves solving everyday problems in arcane ways.
19:20:08 <djahandarie> Well, the interest in it is not due to it being arcane, but rather due to it just being really useful and able to beat a ton of other things
19:20:51 <cmccann> djahandarie: right and the arcane is why it's not already in common use
19:20:58 <edwardk> cmccann: bah, doesn't everybody think the best way to build their database is to represent literally the entire thing implicitly through overlapping compressed wavelet trees that together tell me the value of everything in it, but individually tell me very little?
19:21:15 <RichyB> cmccann: when "everyday problem" includes things like "I want a pure-functional list that I can cons/uncons from in O(1) and for which the (!!) operation is O(log(n))" then using deep maths helps!
19:21:17 <cmccann> dunno, sounds reasonable to me
19:21:32 * djahandarie takes notes to patent edwardk's new DB system before he does
19:21:52 <edwardk> djahandarie: i look forward to learning from your version of the claims ;)
19:22:05 <RichyB> edwardk: that sounds like a log-structured database that spits fountain codes all over the place.
19:22:30 <RichyB> djahandarie: I look forward to the quadratic algorithm you'll need to run in order to re-spread-out the entropy every time a user adds one more row. ;)
19:22:54 <edwardk> no fountain codes, but technically log structured, at least it only ever does writes sequentially except to sync the nursery
19:23:25 <edwardk> Will be spending a lot of time merging together 'canopies' of wavelet trees though
19:23:45 <RichyB> So call the records r_0, r_1 and so on, you emit r_0, then r_0 + r_1, then you emit (r_0 + r_1) + r_2?
19:24:00 <RichyB> Where "+" means some group operation?
19:24:12 <edwardk> RichyB: actually inserts don't cause me problems i still remain within little o of rank-0 entropy and have an option for rank-k entropy
19:24:54 <edwardk> i do give up and make the structure technically non-succinct to get parallelism in places though
19:25:14 <RichyB> Deliberately-non-succinct is not a problem.
19:25:34 <RichyB> TODO understand wavelets. :)
19:25:42 <dolio> Doesn't everyone know the entropy of their MySQL database?
19:26:13 <sw2wolf> @wn entropy
19:26:14 <lambdabot> *** "entropy" wn "WordNet (r) 3.0 (2006)"
19:26:14 <lambdabot> entropy
19:26:14 <lambdabot>     n 1: (communication theory) a numerical measure of the
19:26:14 <lambdabot>          uncertainty of an outcome; "the signal contained thousands
19:26:14 <lambdabot>          of bits of information" [syn: {information}, {selective
19:26:16 <lambdabot> [6 @more lines]
19:26:27 <edwardk> RichyB: i gather up rows into big batches in the nursery, then write a bunch of them out in a big block. from there its all about merging blocks fast enough to stay ahead of the nursery generating more blocks and using fractional cascading into older blocks to do simultaneous indexing on all of them
19:27:15 <edwardk> the columns of my rows themselves are never stored as such, they are just represented implicitly via the reordering from having the wavelet tree for each
19:27:32 <edwardk> so, in that way i go from rows to columns to nothing at all
19:28:10 <dolio> That title has already been used.
19:28:14 <edwardk> and given my chosen row order high levels of eaveh wavelet tree consist of long runs that are being 'churned up' into smaller runs by all the trees in aggregate. so high level aggregate queries can be answered
19:28:45 <edwardk> er s/eaveh/each/
19:28:50 <sw2wolf> @ty scanl
19:28:52 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
19:30:06 <sw2wolf> @hoogle scanl
19:30:06 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
19:30:06 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
19:30:06 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
19:34:49 <heatsink> The "nothing at all" in the stream fusion paper always brings this to mind. http://www.youtube.com/watch?v=81GQqqv4Mzs
19:37:15 <arkeet> haha
19:41:54 <cmccann> wavewave: ping
19:56:54 <Estrellas> is haskell.org down for everyone or just me
19:58:54 <masteraka> so what happened to haskell.org?
20:00:49 <ab9rf> ran out of penguins
20:01:14 <heatsink> Estrellas, http://downforeveryoneorjustme.com/haskell.org
20:01:35 <Estrellas> I looked at that and it told it was indeed down but I was hoping it wasn't
20:01:40 <Estrellas> now where will I read my documentation
20:01:49 <Estrellas> hackage.haskell.org is up though
20:01:55 <heatsink> Try /usr/local/share/doc/
20:02:22 <heatsink> I think GHC installs documentation in the ghc-doc subdirectory
20:04:13 <masteraka> yeah, but now cabal doesn't work either...
20:04:48 <sw2wolf> masteraka: use alternative repo for cabal
20:04:58 <masteraka> can cabal use any other sources for packages?
20:05:06 <t4nk163> hi
20:05:08 <masteraka> is there a list of free repos?
20:05:46 <masteraka> or mirrors?
20:05:48 <geekosaur> @where hackage-mirror
20:05:49 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
20:07:33 <t4nk163> i just started learning haskell and i have a question: i am going thru the online book "learn you a haskell" and have come across an explanation regarding lazy evaluation in haskell
20:07:44 <t4nk163>  f1(f2(f3([1,2,3,4))) it will perform f3 on the first element, then f2, then f3 on the first element, and then return the result on the first element. After that go for the second element. Is my understanding correct?
20:08:44 <t4nk163> In that case, are the three functions called one after the other for each element?
20:08:52 <masteraka> no
20:09:14 <masteraka> f3 [1,2,3,4]   applies f3 to the list [1,2,3,4]
20:09:46 <masteraka> not to each element of the list
20:10:00 <t4nk163> ok thanks. Another question
20:10:00 <masteraka> then f2 is applied to the result of f3
20:10:05 <masteraka> then f1 to the result of f2
20:10:12 <masteraka> if f3 = map g
20:10:17 <masteraka> then g is applied to each element
20:10:23 <ParahSail1n> if all f's are map something, there should be stream fusion i think
20:10:27 <masteraka> but in general you don't know that
20:10:51 <masteraka> do the arguments of the maps have to be strict?
20:11:00 <masteraka> for fusion to work?
20:11:04 <t4nk163> Since functional programming deals with mostly function calls ... does this type of programming spend a lot of time copying to/from stack in memory?
20:11:59 <andrewsw> t4nk163: depends on what the compiler does
20:12:12 <masteraka> t4nk163: depends on what the function looks like as well
20:12:35 <masteraka> f x = [x,x] will copy stuff onto the stack
20:13:05 <andrewsw> functional programming expresses concepts by way of functions, their composition, and their values. This is often quite different from the implementation on themachine.
20:13:31 <masteraka> generally, if you mention an input argument twice in the body of the function it will copy stuff onto the stack
20:14:04 <ab9rf> masteraka: yeah, but it'll probably bjust two copies of a pointer to the same thunk
20:14:08 <masteraka> also, with recursive functions the compiler can sometimes do optimization
20:14:47 <masteraka> if the function is tail recursive, for instance
20:15:31 <geekosaur> oh wait, that ,ust be humidity
20:15:36 <geekosaur> finally warm enough it shows up
20:15:42 <ab9rf> geekosaur: ?
20:15:57 <geekosaur> oops channe;
20:16:10 <ab9rf> geekosaur: what channel is that relevant in? :)
20:16:13 <t4nk163> what happens if the function is tail recursive?
20:16:48 <geekosaur> any social channel, when it's part of an existing discussion you aren't seeing the rest of...
20:16:51 <heatsink> t4nk163, function calls often become jump instructions after compiling.  Function parameter passing becomes register moves.  These jumps and register moves can get simplified and removed by the compiler.
20:16:56 <ab9rf> geekosaur: heh
20:17:07 <ab9rf> geekosaur: i'm a weather geek, so i'm curious is all :)
20:17:19 <fizbin> geekosaur: so, #haskell-blah
20:17:47 <ab9rf> t4nk163: it's _much_ harder to try to correlate Haskell source code to generated machine code
20:18:23 <ab9rf> t4nk163: don't assume that the evaluation of a function in haskell necessarily creates a "function call" at the hardware level.  it might, it might not.
20:19:12 <geekosaur> ghc does not use a normal function call stack, is my understanding. there's a pattern match stack though
20:19:24 <ab9rf> geekosaur: that was my understanding too
20:19:42 <heatsink> What's a pattern match stack?
20:19:48 <ab9rf> there's a "current expression" thing on the heap that could be partially evaluated
20:20:34 <fizbin> I need to represent a directed graph in haskell with some extra data attached to each node (label, some per-node ints). Is there a standard, well-established structure for doing that?
20:20:44 * cmccann thinks that if you're going to talk about a pure function as "do this, then do this, then..." it makes more sense to think of the outermost call happening "first"
20:21:03 <heatsink> fizbin, there's Data.Graph.Inductive.Graph
20:21:51 <heatsink> If you really need to do constant-time imperative graph updates, then you can use an array of array indices
20:21:56 <t4nk163> For lazy evaluation:   how does this evaluation happen f(g(h[1,2,3,....,a very long list])) ?
20:22:10 <ab9rf> t4nk163: that depends on f, g, and h
20:22:28 <ab9rf> t4nk163: if f is const 5, it evaluates 5 and never looks at g, h, or the list
20:22:47 <cmccann> and t4nk163's question is exactly why I say thinking outermost first is more helpful :P
20:22:57 <heatsink> Evaluation only happens at case expressions and primitive operations such as (+)
20:23:12 <heatsink> and it only happens for one piece of data, not all the data inside
20:23:14 <ab9rf> if f, g, and h are all id, then it returns the very long list without actually evaluating any of its contents
20:23:24 <cmccann> heatsink: also at function application
20:23:35 <cmccann> heatsink: for the function, not the argument
20:23:37 <heatsink> ah, yes
20:23:54 <cmccann> that one's strangely easy to forget :]
20:24:16 <fizbin> Specifically, the main operations I need to be fast are "get all inputs of node x (nodes that have an arrow *to* x)" and "get all outputs of node x", plus I need some operations to join together different graphs, to delete nodes, and add edges. Those though needn't be fast.
20:24:38 <fizbin> heatsink: I'll go look at that.
20:24:42 <CodeWeaverX> "principle of least work"‚Ä¶ or so I like to think of it.  If the function, on receiving the parameters (unevaluated) doesn't need one or more of them, then the parameters are just thrown away, doing no work whatsoever for whatever the value of those parameters would have been.
20:25:31 <CodeWeaverX> Seriously trippy.
20:26:53 <heatsink> t4nk163, if you want to learn how evaluation happens, it's more useful to follow the evaluation of a few specific examples such as sum [1,2,3], head [1,2,3], and [4,5,6] ++ [1,2,3]
20:27:13 <heatsink> focus on what are the differences between the definitions of sum, head, and (++) that give you different evaluation behavior
20:29:35 <t4nk163> Ok...thanks for sharing your knowledge
20:30:10 <CodeWeaverX> "Learn You a Haskell" is a good resource, as is, later, "Real World Haskell".  Both have online versions.  If you haven't stumbled into them yet.
20:31:39 <ab9rf> > [1,2..]
20:31:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:32:22 <ab9rf> t4nk163: think about why sum [1,2..] fails to terminate, while head [1,2..] very quickly evaluates to 1
20:32:35 <fizbin> > [1..]
20:32:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:32:46 <ab9rf> fizbin: purist
20:33:32 <fizbin> The problem with the other view is that you're tempted into stuff like [1, 3..] which does not work as one might expect.
20:33:32 <arkeet> > [undefined..]
20:33:34 <lambdabot>   *Exception: Prelude.undefined
20:33:45 <arkeet> > [1,3..]
20:33:47 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
20:33:56 <fizbin> Oh. Huh.
20:34:07 <fizbin> > [1,3,4..]
20:34:09 <lambdabot>   <hint>:1:7: parse error on input `..'
20:34:20 <andrewsw> > [1, 4..]
20:34:22 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
20:34:32 <arkeet> > [1,1..]
20:34:34 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:34:39 <geekosaur> fizbin: enumFrom, enumFromThen, enumFromThenTo
20:34:44 <andrewsw> > [1, 1, 3, 5..]
20:34:45 <ion> How does [1,3..] not work as one might expect?
20:34:45 <lambdabot>   <hint>:1:12: parse error on input `..'
20:34:50 <andrewsw> :(
20:34:53 <arkeet> > [1.0,1.1..2]
20:34:53 <geekosaur> (desugared versions of those)
20:34:54 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
20:34:54 <cmccann> > [1, 1.3 .. 3]
20:34:56 <lambdabot>   [1.0,1.3,1.6,1.9000000000000001,2.2,2.5,2.8,3.0999999999999996]
20:34:59 <arkeet> er
20:35:01 <arkeet> yeah that
20:35:13 <fizbin> ion: I guess it does work as one might expect after all.
20:35:14 <arkeet> Enum needs more laws.
20:35:24 <arkeet> what did you think it would do?
20:35:36 <arkeet> > 1:[3..]
20:35:37 <geekosaur> barring weirdness with floating point at least
20:35:38 <lambdabot>   [1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
20:38:14 <cmccann> > [1, 1.3 .. 3] :: [Fixed E3]
20:38:15 <lambdabot>   [1.000,1.300,1.600,1.900,2.200,2.500,2.800]
20:38:20 <cmccann> consistency is awesome
20:38:40 <croikle> okay, so with the floating point version it includes the closest value to the endpoint, whether that's lower or higher?
20:38:49 <cmccann> > succ 1 :: Float
20:38:51 <lambdabot>   2.0
20:38:53 <cmccann> > succ 1 :: Fixed E3
20:38:54 <lambdabot>   1.001
20:38:56 <cmccann> yaaaaaay
20:38:57 <magicman> Hmm. I wonder.
20:39:09 <magicman> > [1, 1.1 .. 3] :: [Rational]
20:39:11 <lambdabot>   [1 % 1,11 % 10,6 % 5,13 % 10,7 % 5,3 % 2,8 % 5,17 % 10,9 % 5,19 % 10,2 % 1,...
20:39:27 <cmccann> Rational behaves the same as floats I think
20:39:47 <andrewsw> it looks like it's incrementing by the difference until >= the upper bound.
20:39:49 <croikle> last one there is 31 % 10, yeah
20:39:59 <croikle> andrewsw: not quite
20:40:06 <CodeWeaverX> Floats in the spec have specifically different rules.
20:40:08 <croikle> > [1,1.3..2]
20:40:10 <lambdabot>   [1.0,1.3,1.6,1.9000000000000001]
20:40:13 <croikle> > [1,1.3..2.1]
20:40:14 <lambdabot>   [1.0,1.3,1.6,1.9000000000000001,2.2]
20:40:21 <andrewsw> hmmm...
20:40:23 <magicman> > last [1, 1.1 .. 3] :: Rational
20:40:25 <lambdabot>   3 % 1
20:40:49 <croikle> magicman: whoops, I tried 1, 1.3 .. instead
20:40:51 <CodeWeaverX> If the last quantity is less than half a 'step' above the upper limit, then the upper limit is included.
20:41:01 <CodeWeaverX> As shown by those previous lists.
20:41:06 <cmccann> man Enum is super awesome, all making sense and stuff
20:41:18 <CodeWeaverX> I phrased that badly.
20:41:49 <CodeWeaverX> If going above the upper limit results in a value x that is less than half a step away from the upper limit, then x is included.
20:41:59 <croikle> equivalently, it goes to the closest approximation of the endpoint
20:42:03 <ion> No manual entry for Enum
20:42:13 <CodeWeaverX> No doubt chosen because exact equality with floating point numbers is dodgy.
20:42:54 <ion> Exact equality is defined just fine on floating point numbers.
20:42:55 <cmccann> unlike the Enum instance for floats, which is clearly not dodgy in any way
20:43:12 <cmccann> also that's why Rational does the same thing, because equality is annoying for floats
20:44:00 <shachaf> Floating point number?
20:44:04 <shachaf> Do you mean floating point value?
20:44:19 <CodeWeaverX> Once again, I badly worded.  The math generating the sequence of values can be slightly dodgy, inasmuch as on different hardware you can end up with different behaviour in the low bits causing the upper limit  to be included, or not, if an exact equality test were to be used.
20:44:21 <cmccann> haha yes
20:44:30 <cmccann> shachaf knows the story
20:44:37 <wavewave> cmccann: hi.
20:44:42 <shachaf> hi wavewave
20:44:51 <cmccann> wavewave: heya!
20:44:57 <ion> wave¬≤?
20:45:11 <wavewave> shachaf: hi
20:45:13 <CodeWeaverX> square wave?
20:45:15 <cmccann> wavewave: so I was hacking on the gtk bindings a few days ago and added support for extended input events
20:45:29 <dolio> shachaf: No, it's only defined well for the floating point numbers.
20:45:45 <cmccann> wavewave: primarily for the sake of getting tilt and pressure input
20:46:16 <shachaf> dolio++
20:46:26 <wavewave> cmccann: good. you saw some code in hoodle?
20:46:41 <wavewave> it's in Hoodle.Device
20:46:44 <ion> We should pressure someone to create a peer pressure sensor.
20:46:58 <cmccann> yeah, I looked at hoodle but the pressure sensitivity didn't seem to work when I tried it
20:47:02 <andrewsw> ion: all the kids are doing it these days.
20:47:12 <amiller> is there a way i can use Generics with an existential type like this data Some f = forall a. Some (f a)
20:47:19 <amiller> where i define f using a GADT
20:47:48 <amiller> ExprF :: (* -> * ) -> * -> * where Tip :: ExprF r Tree     and so on
20:48:46 <wavewave> cmccann: i see. device support is probably not very compatible with many kinds.
20:50:19 <wavewave> cmccann : I cannot experiment with many devices..  i need to spend some time on what's most general portable way to autodetect pen devices.
20:50:49 <cmccann> yeah, it can be tricky I think
20:51:20 <cmccann> I'm not sure how portable the GTK extended input device stuff is
20:51:38 <cmccann> but figured I'd at least mention it in case it's something you'd find helpful
20:51:50 <cmccann> at some point I need to put together a patch to get it in the actual gtk package
20:52:40 <wavewave> cmccann: sounds great!
20:53:41 <cmccann> I at least have it working right now with my cheap-o wacom tablet
20:54:06 <wavewave> cmccann : what device do you use?
20:54:25 <cmccann> it's a wacom bamboo that's like a generation or two old maybe
20:54:33 <wavewave> cmccann: so you are running hoodle now? ;-)
20:55:45 <cmccann> sadly I don't really have much I can use it for day-to-day...
20:56:06 <cmears> (I've got a bamboo too that didn't seem to work properly with hoodle)
20:57:05 <wavewave> next time I really need to solve this device driver issue. currently it's too hackish.
20:57:13 <cmccann> wavewave: if you're interested I can send you the code I have currently
20:57:33 <cmccann> I added a couple type definitions and one or two functions to the gtk bindings I think, not much at all
20:57:43 <wavewave> cmccann: sure! just give a comment as an issue on hoodle github.
20:58:55 <cmccann> ok
20:59:07 <cmccann> pretty much I added several things from this: http://www.gtk.org/api/2.6/gdk/gdk-Input-Devices.html
20:59:25 <wavewave> thanks!
20:59:47 <cmccann> the gdk_device_set_whatever functions are probably what you're missing
20:59:56 <fizbin> Is it just me, or is hoogle having issues?
21:00:59 <cmccann> wavewave: what I do is set a few hard-coded things that work with my tablet, enable extension events, then pull the axis data from the event struct (something else I added)
21:01:08 <andrewsw> fizbin: all of haskell.org appears to be down.
21:01:56 <fizbin> At least hackage.haskell.org still seems up.
21:02:05 <amiller> how about derived instances of Generics for gadts?
21:02:28 <cmccann> wavewave: I saw you were doing some stuff with all that in a C file, but to support a wider range of stuff you'll probably need something more sophisticated
21:02:30 <amiller> Can't make a derived instance of `Generic (ExprF (K D) Tree)':
21:02:30 <amiller>       Tip must be a vanilla data constructor
21:02:42 <cmccann> and having that in Haskell instead of a C file is nicer
21:03:34 <wavewave> cmccann: yes. basically i do not know what is the appropraite way yet.
21:04:01 <cmccann> wavewave: I was using the source for MyPaint as an example to see what works
21:04:07 <cmccann> since it's similar to what I'm writing anyway
21:04:39 <cmccann> it's written in Python using GTK bindings so not too hard to compare against
21:06:55 <wavewave> recently i was watching the code https://github.com/ZaneA/WacomWebPlugin  which is linux firefox/chromium wacom javascript plugin
21:07:12 <cmccann> that sounds neat
21:08:10 <wavewave> looks like having some generic solution, but I didn't have much time in looking into it. just compile test and had problem so contacted the author.
21:08:42 <rfw> quick question -- since -XDatatypeContexts is useless, does that mean that if i wanted a Num a => Vector2 a a would i declare it as data Vector2 = Vector2 a a and carry around Num a on all the functions?
21:09:27 <wavewave> rfw: you can put constraint on right hand side of the definition.
21:10:03 <rfw> wavewave: what do you mean?
21:10:22 <wavewave> rfw: data Vector2 = (Num a) => Vector2 a a
21:10:32 <wavewave> rfw: it is valid.
21:10:42 <cmccann> use GADT syntax if you really want a useful constraint on a data type
21:10:50 <cmccann> but generally just putting the context on the functions that need it is better
21:11:04 <wavewave> ugh.. data Vector2 a = (Num a) => Vector2 a a
21:11:10 <wavewave> forgot a
21:11:18 <arkeet> no.
21:11:25 <fengshaun_> are there any haxml tutorials out there?  I can't make heads or tails from the docs!
21:11:48 <hpaste> ‚ÄúC. McCann‚Äù pasted ‚Äútablet input‚Äù at http://hpaste.org/85521
21:11:59 <cmccann> wavewave: that's what the code in my application looks like
21:12:05 <arkeet> data is just data. you should put constraints on the code that operates on the data
21:12:26 <rfw> wavewave: oh, that's cool
21:12:34 <arkeet> no it isn't :(
21:12:54 <rfw> wavewave: except i still need to pass the type context around
21:13:15 <fengshaun_> rfw, don't put constraints on data
21:13:17 <rfw> arkeet: i guess i understand what you mean by that
21:13:22 <fengshaun_> put it on the function instead
21:13:23 <rfw> it just seems, verbose
21:13:58 <rfw> fengshaun_: thanks
21:14:07 <arkeet> writing data Vector2 a = (Num a) => Vector2 a a
21:14:07 <wavewave> data (Num a) => Vector2  a is different from data Vector2 = (Num a) => Vector2 a a at all
21:14:08 <cmccann> rfw: if you really want, you can use "data Vector2 a where Vector2 :: (Num a) => a -> a -> Vector2 a"
21:14:17 <arkeet> has the effect of packing a Num dictionary into your data
21:14:30 <rfw> cmccann: is that a GADT?
21:14:31 <cmccann> which does what you probably wish the datatype contexts stuff did
21:14:39 <arkeet> cmccann: that's what wavewave's thing does.
21:14:40 <cmccann> that's GADT syntax, yeah
21:14:56 <cmccann> oh, does that work without GADT syntax? huh.
21:15:11 <amiller> looks like Generics for GADT is a no go
21:15:20 <arkeet> you still need -XGADTs or -XExistentialQuantification or the like to do it.
21:15:25 <cmccann> anyway, if you play around with it a bit you'll probably see that it doesn't help much and makes some things annoying
21:15:28 <wavewave> Vector2 in the right hand side is  a function.
21:16:18 <rfw> yeah, ExistentialQuantification is kind of gross
21:16:37 <cmccann> wavewave: anyway, the hpaste above shows pretty much everything I added, in case you feel like just sticking it in hoodle yourself
21:16:38 <wavewave> rfw: passing the type context is necessary since it meant to be there. If you can omit the type context, that is inconsistent
21:16:52 <rfw> ah, i understand now
21:16:53 <rfw> thanks
21:17:35 <cmccann> wavewave: otherwise I'll leave you a comment on github with the stuff I actually added to the GTK package that I'm using there and you can do whatever with that
21:17:58 <arkeet> it's like data Vector2 a = Vector2 (Num_dict a) a a
21:18:05 <cmccann> not sure what timeframe might be involved in me having time to make a real patch and then it getting into a release of the gtk package
21:18:22 <wavewave> cmccann: I read it. so did you add eventGetAxis function?
21:18:47 <cmccann> yes, and also the deviceSetWhatever functions I think
21:19:01 <cmccann> and the enum with the Axis values?
21:19:04 <cmccann> I can't remember exactly, heh
21:19:24 <cmccann> think I added devicesList as well
21:19:45 <cmccann> most of those are pretty direct bindings to the underlying API
21:20:31 <wavewave> cmccann: I see. if you can make it inside gtk package, then that's the best for me :-D
21:20:43 <cmccann> yes, that's the eventual goal
21:21:48 <wavewave> cmccann: if not, for the time being, we can have gtk-wacom package or something like that.. (but i am not sure that having separate package for such gtk infrastructure is good idea or not)
21:22:17 <cmccann> oh, it's not
21:22:25 <cmccann> but maybe as an interim thing if you wanted
21:22:42 <cmccann> I figure it'll be in the real GTK package by the time I have anything worth releasing on my application
21:23:05 <wavewave> cmccann: i am going to look into general detection mechanism. how wacom plugin did inside..
21:23:33 <wavewave> cmccann: btw, what's your application about?
21:24:25 <cmccann> drawing
21:24:30 <cmccann> like I said, similar to MyPaint
21:24:36 <cmccann> which is a really nice program
21:25:14 <cmccann> but pretty dedicated to its minimalism and I want something a bit fancier that isn't a lumbering behemoth full of photomanip stuff I don't need like GIMP
21:26:05 <wavewave> cmccann: great! you are making a painter program!
21:26:08 <ivanm> lispy: worked the problem with GLURaw out; it needs to explicitly link to OpenGL as well
21:26:59 <wavewave> cmccann: later, we can have some interoperability between your program and my program ;-)   bitmap side and vector side
21:27:27 <cmccann> I haven't really given much thought to file formats yet...
21:27:49 <ivanm> for some reason I have an executable called "hscolor" in ~/.cabal/bin/, but I have no idea which package it came from :/
21:27:50 <cmccann> was going to start with the format MyPaint uses and something that GIMP can use
21:28:35 <ivanm> oh, from colorize-haskell
21:29:19 <cmccann> wavewave: here, look at this http://gitorious.org/mypaint/mypaint/blobs/master/gui/application.py#line460
21:29:23 <wavewave> cmccann : yes. that's a good idea.
21:29:39 <wavewave> cool. thanks for the sharing
21:29:57 <cmccann> that's the main (?) chunk of MyPaint's device detection code
21:30:13 <wavewave> ah.. i thought that's your program ;-P
21:30:26 <cmccann> I don't really use python anymore :P
21:30:35 <cmccann> but it's easy to see what it's doing
21:32:10 <cmccann> wavewave: oh, and mypaint's default file format is http://en.wikipedia.org/wiki/OpenRaster
21:33:50 <cmccann> a separate package for working with that format is definitely a good idea
21:34:00 <cmccann> something we could both use
21:34:22 <wavewave> yes. that's why i separate out xournal-types and hoodle-types.
21:34:35 <wavewave> but in fact, I feel I separated packages too much.
21:38:41 <cmccann> wavewave: anyway I think that's everything I wanted to mention... I'll let you know how the input device stuff goes
21:39:09 <wavewave> cmccann : Thanks! if you made progress in your program, please let me know. vector graphic program needs some raster graphics editing feature and vice versa.
21:39:57 <cmccann> yes, if nothing else it would be good for mine to import vector images and display them as a layer
21:40:01 <cmccann> even if they can't be edited
21:40:02 <wavewave> so we can make both programs as a plugin for the other. ;-)
21:41:51 <cmccann> also, my big goal once the basics are working nicely is to have some animation support
21:42:15 <wavewave> cool
21:42:17 <cmccann> it seems to be a popular request for mypaint and animating stuff in GIMP is just horrible and unpleasant :[
21:42:37 <cmccann> and everything else I've tried had other problems
21:45:38 <heatsink> I hear that commercial animation software is horrible and unpleasant too.
21:45:59 <cmccann> probably less so
21:46:00 <cmccann> but still
21:48:29 <wavewave> guys. i need to go sleep now. so see you. thank you, cmccann
21:48:34 <cmccann> ok
21:48:42 <cmccann> seeya!
21:49:43 <lavorno> cmcann: i enjoyed your insights on devxchange - wanted to ask - what's the best way to get up to speed with the best approach on exception handling ? i'm trying to use haskell for some large app and everything works great but got to the level where we need to put a unified err/exc handling across the board (either/exc/monadic/arrows/pure/io/etc) - what's your take on that ?
21:50:48 <cmccann> I'm probably not the best person to ask about that to be honest
21:51:44 <cmccann> I tend to be opposed to many uses of error handling monads that other people like
21:51:54 <lavorno> cmccann: no problem, i appreciate your intellectual honesty :) who would be the right person to ask that in your opinion ?
21:52:31 <cmccann> dunno. ask around in here or on StackOverflow, see who responds. that's probably what I'd do.
21:52:50 <amiller> i'm going to start using multirec instead of my copypasta  hfunctors/hfix
21:52:59 <amiller> i notice that multirec uses data instead of newtype
21:53:16 <amiller> if i have a data with a single constructor that could be changed to newtype, is there any performance benefit in actually having it use newtype, or will it figure it out?
21:53:37 <lavorno> (i meant stackoverflow not dev exchange - duh) yeah, i checked that out but they are more like point answers, nothing "end to end for large apps"
21:53:40 <cmccann> lavorno: my rule of thumb is to use control flow monads like Either if backtracking or retrying is an inherent part of something that's mostly pure, and to use exceptions if you're dealing with stuff in IO because you can't avoid them anyway
21:54:24 <cmccann> otherwise, I prefer using Either or Maybe or whatever directly and handling error conditions as immediately as possible
21:55:12 <lavorno> cmccann: agreed, exc for i/o and either for pure - how about passing context between layers (from monads/arrows pure/impure /  io )
21:55:28 <cmccann> and in general, designing things so that error conditions don't really happen. use total functions and quickcheck and whatnot.
21:56:19 <cmccann> that's all stuff I like to be explicit
21:56:26 <chrisdotcode> hey guys is haskell.org down, or is it just me?
21:57:05 <lavorno> that's a great approach, the problem is i have to deal with a lot of stuff that's not in my control. so i convert the data quickly from io into pure and work from there. the probl is data can be malformed sometimes.. and i need to pass that back through layers.. that's where i'm kind of stuck at the moment
23:59:08 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
23:59:08 --- topic: set by monochrom on [Tue Jan 29 09:36:42 2013]
23:59:08 -adams(freenode.net)- [freenode-info] please register your nickname...don't forget to auto-identify! http://freenode.net/faq.shtml#nicksetup
