00:00:09 <mushi> http://pastebin.com/LsQr8T4S (if you need it)
00:00:09 <mauke> The paste LsQr8T4S has been copied to http://hpaste.org/85673
00:05:08 <mdz1> Hey guys! I'm trying to get fuzzyfinder's tag search to work with my Haskell projects, has anyone had any luck doing this? Should I be trying to make ctags work with haskell, or fuzzyfinder work with lushtags? I've tried  both but haven't had any luck.
00:07:02 <beaky> http://ideone.com/n2WxYU how do I improve my program?
00:10:28 <Rotaerk> beaky, add more beer?
00:11:38 <Twisol> Seems like the main difference is the plural, right?
00:11:49 <beaky> right
00:12:20 <Twisol> You could factor that out into a showBeerCount function that takes a number and returns "N beers", "1 beer", and "no beers" depending on the number.
00:12:32 <shachaf> mdz1: I use hasktags to make Haskell tags.
00:13:04 <shachaf> I don't know anything about fuzzyfinder but hasktags generates a ctags-compatible tag file with -c
00:13:26 <beaky> http://rosettacode.org/wiki/99_Bottles_of_Beer#Haskell this page has a nice version
00:26:39 <natnayr> shachaf: sry, i dced.. any word on my issue?
00:28:38 <natnayr> luite: sry i dced.. any word on my program?
00:32:11 <luite> natnayr: perhaps you can break it up in multiple parts. you need to know the total force on every particle. that is the sum of the forces excerted on it by all the other particles
00:32:29 <luite> once you have the total force, you know how to update the velocity, and then the position
00:33:12 <natnayr> luite: u sound like ur in my course
00:33:28 <luite> i can guarantee you i'm not
00:34:00 <natnayr> luite: but that makes alot of sense
00:34:05 <natnayr> luite: thanks
00:35:02 <mushi> luite is in my course
00:35:04 <mushi> unsw?
00:35:18 <luite> don't tell anyone!
00:35:43 <shachaf> luite is at UNSW?
00:35:48 <mushi> wait
00:35:58 <mushi> so who is at uNSW?
00:36:04 <mushi> and is trying to do that assingment 1?
00:38:48 <natnayr> mushi: me
00:39:09 <mushi> same
00:39:10 <luite> mushi: can you ask ben if he can split gloss into a pure gloss-base and a part that depends on opengl?
00:39:30 <mushi> who is ben?
00:39:32 <m3ga> luite: you should send him email.
00:39:32 <natnayr> mushi, luite: lol
00:39:41 <m3ga> benl23 the maintainer of gloss
00:40:14 <luite> mushi: hehe ok, i was just guessing. Ben Lippmeier works there
00:40:26 <luite> don't know if he teaches any courses atm
00:40:48 <luite> m3ga: yeah i'll do that once i have a javascript backend complete
00:40:53 <luite> +d
00:40:56 <mushi> hey natnaye
00:41:01 <natnayr> yeah?
00:41:08 <natnayr> 3141?
00:41:08 <mushi> can you give me help get started on this assingment
00:41:14 <mushi> yeah 3141
00:41:18 <m3ga> luite: i think he'd like that
00:41:24 <natnayr> moveParticle
00:41:28 <natnayr> should be easy..
00:41:39 <natnayr> most of the work is reading the assignment i swear..
00:41:57 <m3ga> natnayr: who set the assignment
00:42:00 <m3ga> ?
00:42:10 <natnayr> unsw cse COMP3141 course
00:42:22 <m3ga> lecturer?
00:42:22 <natnayr> accelerate is like 90% of the work
00:42:41 <natnayr> nah, sry not gonna mention names here, he might be watching...
00:42:43 <luite> m3ga: it needs some work though, both diagrams (with diagrams-ghcjs) and gloss depend on the same canvas api bindings, i've just copypasted them now but it needs to be a separate pkg
00:43:32 <m3ga> natnayr: i'm not at unsw, but i am in sydney. i run fp-syd with benl23 and another guy.
00:44:02 <m3ga> i like to think i know most of the haskellers in sydney
00:45:00 <natnayr> m3ga: u guys are heros
00:45:41 <natnayr> m3ga: please impart to me your greatness
00:45:49 <m3ga> really? no, we just hang out, talk fp and drink beer!
00:45:57 <natnayr> haha
01:06:58 <awgn> Hi there. I have an interesting problem. I'm using the async library and mapConcurrently to perform a large number of IO computation. Basically each computation perform a substring search in strict ByteString. The performance improve up to -N3 and then get worseÖ Any advice to fix this?
01:08:07 <m3ga> awgn: how many cores are you running on. my guess is 4 :-)
01:08:21 <awgn> 6
01:08:47 <awgn> with -N6 the performance are even worse than -N1
01:09:14 <m3ga> awgn: is it possible its actually 3 CPUs, with 2 hyper-threads per real CPU?
01:09:26 <awgn> running on a xeon 6 core
01:09:50 <awgn> hyperthreading disabled
01:09:56 <m3ga> ah ok.
01:10:42 <awgn> using threadscope it turns out that only one core performs computation while the other 5 are running the garbage collector. it is normal ?
01:10:43 <m3ga> its kinda well know than for N CPUs ghc's runtime can scale well up to about N - 1 threads.
01:10:57 <m3ga> awgn: thats your problem right there.
01:11:08 <awgn> I suspected so :-)
01:11:16 <m3ga> not sure what the solution is though.
01:11:34 <m3ga> how much data is transferred between threads?
01:11:57 <awgn> I guess nothing. Each task open a file and perform a substring search wihtin
01:12:50 <m3ga> ok, so i'd be looking at the performance of one of those tasks in isolation.
01:14:12 <awgn> could it be that I run a very large number of task in parallel ?
01:14:34 <awgn> that depends on the file system, since it runs a task per file
01:16:22 <m3ga> if you are spawning many more threads than there are CPUs, you're going to get contention for CPUs which will slow you down.
01:16:57 <awgn> ok then I try the classic approach with a set of working threads
01:17:16 <m3ga> yes, that's what i'm doing for a similar problem.
01:17:31 <awgn> thank you very much :-)
01:17:41 <m3ga> start N threads, all reading from the same STM.TQueue.
01:18:20 <awgn> yep and a single producer thread should be enough in this case :)
01:19:14 <m3ga> yes, that looks like my solution, but i'm only playing with a toy implementation. i haven't started using the real work yet.
01:19:51 <XexonixXexillion> Does anyone know of any decent histogram libraries for Haskell? I've found a few libraries that can make them, but none that offer useful functions like kernel density estimation for them.
01:20:46 <luite> XexonixXexillion: did you see the statistics package?
01:21:58 <awgn> XexonixXexillion, tried HaskellCharts?
01:22:20 <XexonixXexillion> luite: nope... I need to work on my google-fu
01:26:59 <XexonixXexillion> luite: thanks; that is *really* useful
01:33:09 <nh2> how can I cheaply derive Storable for my custom data types? (e.g. template haskell)? An arbitrary implementation is fine
01:51:10 <hpaste> rohit pasted ‚ÄúError installing yesod‚Äù at http://hpaste.org/85678
01:51:16 <rohitkav> I get this error when configuring the project for Yesod project.http://hpaste.org/85678
01:53:45 <rohitkav> kindly help
01:55:12 <mikeplus64> rohitkav: try run cabal install instead of cabal configure
01:55:18 <mikeplus64> that will install the dependencies for you
01:55:25 <mikeplus64> otherwise you can just do cabal install persistent-sqlite
01:56:26 <rohitkav> will try mikeplus64
01:56:47 <rohitkav> it seams it's installing :) mikeplus64
01:57:10 <rohitkav> will trouble you if it doesn't work :) Thanks meanwhile :)
01:57:49 <hpaste> rohit pasted ‚ÄúError installing yesod‚Äù at http://hpaste.org/85679
01:58:05 <rohitkav> Got this error mikeplus64
01:58:44 <mikeplus64> i'm not sure why that would be, maybe your user's home directory permissions aren't right
01:59:04 <rohitkav> could you help me
01:59:14 <rohitkav> I am using ubuntu
01:59:37 <mikeplus64> you can probably use the file manager to see what permissions you have for the home directory
01:59:59 <rohitkav>  how?
02:00:25 <mikeplus64> uh, right click -> properties?
02:00:36 <mikeplus64> on the icon for your home directory
02:01:03 <mikeplus64> it should be fine already if you're using ubuntu, i don't know why this is happening
02:01:36 <rohitkav> It says "You are not the owner, so you cannot change these permissions
02:01:37 <rohitkav> "
02:01:54 <mikeplus64> well, there's your problem
02:02:20 <rohitkav> so how to resolve this
02:02:47 <typoclass> rohitkav: could you give the full path of the directory you are in? i notice in your paste says "/newproject", which would be unusual
02:03:11 <rohitkav> I had my project folder on desktop
02:03:32 <rohitkav> /home/rohit/Desktop/haskellproject/newproject
02:03:36 <rohitkav> that was the path
02:03:40 <typoclass> rohitkav: ok
02:04:15 <mikeplus64> rohitkav: unfortunately this is some underlying problem and not really related to cabal/haskell so idk really
02:05:40 <rohitkav> in the tutorial of yesod it says add $HOME/ .cabal/bin to your path
02:05:42 <rohitkav> how to do that
02:05:49 <rohitkav> Could you help me please
02:06:13 <rohitkav> I couldn't do it
02:09:07 <ocharles> @google how to add to path
02:09:08 <lambdabot> http://www.troubleshooters.com/linux/prepostpath.htm
02:09:08 <lambdabot> Title: Adding a Directory to the Path
02:09:19 <typoclass> rohitkav: which user are you logged in as? run "whoami" to find this out. also, which user owns the "~/.cabal" directory?
02:10:03 <typoclass> ocharles: yes, but i think the 'permission denied' thing he pasted is a separate problem. it can't be solved by adding stuff to the $path
02:10:06 <rohitkav> both got rohit as the user
02:10:11 <rohitkav> typoclass,
02:11:05 <rohitkav> .cabal path is /home/rohit/.cabal
02:13:31 <typoclass> rohitkav: refer to lines 10 and 11 from http://hpaste.org/85679 . check ~/.cabal/share, then ~/.cabal/share/doc, and so on. somewhere there has to be a failure
02:14:01 <typoclass> rohitkav: also check the permissions that ls -l shows
02:15:55 <hpaste> rohit revised ‚ÄúError installing yesod‚Äù: ‚ÄúError installing yesod‚Äù at http://hpaste.org/85679
02:16:12 <rohitkav> kindly check typoclass
02:18:11 <typoclass> rohitkav: well, root owns several directories in ~/.cabal/share/doc (and possibly others). that's the problem
02:18:38 <typoclass> rohitkav: it's dangerous to use sudo. i suspect you did "sudo cabal install something"
02:19:00 <rohitkav> for which one you think I might have used sudo?
02:19:30 <rohitkav> I can't use now sudo cabal install persistent-sqlite
02:19:37 <rohitkav> which you mentioned earlier
02:19:41 <rohitkav> why is this issue
02:19:45 <typoclass> rohitkav: well, that would only make it worse
02:19:45 <rohitkav> basically
02:19:57 <rohitkav> what you suggest than
02:20:48 <rohitkav> you got any docs which relates to clear installing procedures of Yesod as well as Haskell
02:20:54 <rohitkav> I often go wrong doing it
02:21:07 <rohitkav> if you don't mind sharing some docs or related materials
02:21:33 <rohitkav> since I often go wrong with the way site explained me to do
02:23:36 <finishingmove> hello Haskell!!!
02:23:38 <finishingmove> good morning
02:23:41 <finishingmove> :D
02:23:48 <luite> hello finishingmove
02:23:59 <typoclass> rohitkav: i would say in general, inside of /home/john/, it is weird and possibly wrong if there's any files or directories owned by root. specifically, cabal isn't meant to be used with sudo, as far as i know
02:24:35 <typoclass> rohitkav: i suggest you rename ~/.cabal to .cabal-backup, which means cabal will forget all the installed packges. you can then start over from a clean slate. use "cabal install stuff" to install what you wanted
02:24:49 <luite> ooh, that's not enough
02:24:55 <luite> the package db is in .ghc
02:25:04 <typoclass> luite: you're right! absolutely
02:25:05 <luite> don't forget to rename that as well, otherwise you have broken packages
02:25:35 <rohitkav> Hmm. I could go for full reinstalling the whole package though
02:25:52 <rohitkav> but I need a clear guidance of how to do it, since each time I went wrong in this
02:26:25 <rohitkav> I used synaptic package manager to get yesod
02:26:31 <rohitkav> not sure, should I use it or not
02:26:46 <typoclass> rohitkav: have you seen this? http://www.yesodweb.com/page/quickstart
02:27:04 <rohitkav> yes
02:27:26 <rohitkav> when I gave yesod devel
02:27:29 <rohitkav> i got error
02:28:07 <rohitkav> it said "Build failure, pausing
02:28:18 <rohitkav> and insists to run configure
02:28:34 <rohitkav> and when I do it I get that persistent- package missing error
02:29:56 * flebron wonders if he could get some help with golfing.
02:30:01 <typoclass> rohitkav: and when you did "cabal install yesod-platform" as the quickstart page mentions, did it complete without errors?
02:30:19 <rohitkav> i did using synaptic package manager
02:30:27 <flebron> My code is at: http://ideone.com/uoxdiS (including sample input.)
02:30:49 <flebron> I need to get it under 256 bytes, but I don't know how to golf the do statement :(
02:31:08 <flebron> I guess I can remove the second 'let', that's a start :p
02:31:10 <luite> rohitkav: the yesod project has more dependencies than yesod platform
02:31:15 <typoclass> rohitkav: i don't know what's recommended these days, but i use cabal for everything and i don't use the linux package manager's stuff
02:31:24 <rohitkav> ok
02:31:31 <luite> yesod-platform only has the basics, your website probabyl requires a specific db backend etc
02:31:59 <rohitkav> let me try to remove it using synaptic and install as the website says
02:32:08 <typoclass> rohitkav: yes, good idea
02:32:36 <typoclass> luite: i have little clue about yesod, but it sounds misleading that http://www.yesodweb.com/page/quickstart doesn't mention this?
02:33:05 <rohitkav> how to set the path which the tutorial says
02:33:08 <rohitkav> typoclass,
02:33:12 <rohitkav> kindly let me know
02:34:21 <luite> typoclass: oh i thought it mentioned to do a cabal insatll first, before yesod devel
02:35:16 <luite> unfortunately i've been rather busy with ghcjs lately so i haven't had much time to contribute to yesod development and fix things
02:37:18 <typoclass> rohitkav: in the file ~/.profile, add a line like "PATH=~/.cabal/bin:$PATH" and restart the shell/the terminal program
02:37:42 <typoclass> luite: yes it mentions "cabal install yesod-platform"
02:37:47 <rohitkav> what is profile?
02:38:00 <luite> typoclass: yeah that's not enough, need to cabal install the inited project as well
02:39:16 <typoclass> rohitkav: it's a file used by your shell (which is most likely bash). when the shell starts, it reads ~/.profile and several other files. you can read about this by doing "man bash"
02:40:39 <rohitkav> but i can't open it
02:41:01 <rohitkav> ok
02:41:07 <rohitkav> ok I could typoclass
02:41:10 <rohitkav> thanks thanks
02:41:10 <rohitkav> :)
02:41:34 <typoclass> rohitkav: ;-)
02:42:15 <rohitkav> it says if statements!! nothing is needed for the path which we are giving for cabal, isn't?
02:42:17 <typoclass> flebron: that's really difficult to read. it doesn't have spaces or anything
02:42:29 <flebron> typoclass: I'll ungolf it, one sec.
02:42:41 <flebron> (The code needs to be under 256 bytes, that's why it's so ugly)
02:43:44 <flebron> The idea is to read first n, number of cases. Then for each case, read k, number of lines. Then k lines follow. The ith line is i numbers, so each case forms a right sided triangle, if you wish, of numbers.
02:44:17 <flebron> Then, knowing that one starts at the top of the triangle, and one wants to get to the base adding the maximum over your path, and knowing you can only move down or down and right, find the largest possible path.
02:44:42 <flebron> (i.e. most expensive path travelling down or down+right)
02:44:56 <flebron> The input is very large, so I cannot use String, and must use ByteString.
02:47:34 <flebron> The shortest (and thus ugliest) I've gotten it is http://ideone.com/iT9NVS
02:47:42 <beaky> what do I do if my datatypes have lots of fields, or if it has a lot of nested data types in it, and I want to pattern match on them?
02:48:15 <luite> derive lenses for them!
02:48:38 <beaky> e.g. game entity classes are like that :(
02:48:44 <beaky> ah
02:49:07 <beaky> still retain the benefits of pattern matching?
02:49:39 <luite> more or less if you use view patterns or pattern guards
02:50:01 <beaky> oh what are those
02:50:21 <beaky> I only know the basic patterns :(
02:58:43 <dibblego> is there some type-class for things that are Data.Map like?
02:59:58 <beaky> a type class might be nice for such things
03:00:08 <beaky> or is it a bad idea
03:00:37 <supki> @type itraverse
03:00:39 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
03:00:40 <aristid> beaky: i'm sorry i have to think of "i love monoids, they are so easy" now :P
03:00:52 <beaky> lol
03:01:33 <supki> dibblego: that probably depends on what operations do you want, there is (Foldable|Traversable)WithIndex and At in lens
03:01:55 <dibblego> supki: yeah I am thinking of laws between insert/update/delete/member for example
03:02:09 <aristid> dibblego: lens has some laws.
03:02:20 <dibblego> aristid: of course, but they are different
03:02:39 <aristid> dibblego: they might still imply the laws that you want :)
03:03:01 <dibblego> yeah maybe
03:05:09 <FireFly> e
03:09:35 <aristid> can you recommend some introductory reading for embedding (my own) C (actually: C++) code in a haskell project? :)
03:10:41 <typoclass> aristid: seen this? http://www.haskell.org/haskellwiki/FFI_Introduction
03:11:28 <aristid> typoclass: now, yes :)
03:19:38 <quchen> aristid: I wrote a small example of how to use a C++ class using the FFI and a C wrapper some time ago if you're interested
03:19:54 <aristid> typoclass: that link seems to be meant for makefiles. who uses that? oO must be possible to use cabal files
03:19:57 <aristid> quchen: yes, please
03:20:33 <quchen> aristid: Alright, just let me add some comments because currently there are zero
03:21:13 <typoclass> aristid: right, you don't need to use makefiles
03:21:17 * aristid hopes that ghc won't force me to use the system C compiler
03:21:41 * aristid hates apple's oooold llvm-gcc version / clang version
03:22:04 <quchen> aristid: I'm using a custom command for the C++ compilation in the makefile ("gcc ...")
03:22:06 <aristid> damn, i just need a proper linux computer. and sorry for the stream of thought ramblings
03:22:14 <aristid> quchen: please no makefile :/
03:22:33 <aristid> quchen: i thought ghc can compile C code itself?
03:23:01 <typoclass> aristid: what's the problem with old c compilers?
03:23:13 <aristid> typoclass: none, but my code is c++
03:23:23 <aristid> and i want c++11 because it's awesome
03:23:32 <aristid> i don't actually need c++11 but i _want_ it
03:23:38 <quchen> auto auto auto
03:23:45 <aristid> quchen: among other things :)
03:23:46 <quchen> To get that feeling like C has a type system :D
03:23:51 <quchen> C++, pardon
03:23:54 <aristid> for (x : vec)
03:24:03 <quchen> Yeah that one's probably the second most useful
03:24:11 <quchen> Lambda syntax is a little awkward though
03:24:24 <aristid> much better than the old for (std::vector<T>::const_iterator it = vec.begin(); it != vec.end(); ++it)
03:24:28 <aristid> quchen: yea
03:24:32 <aristid> quchen: the <random> header is also cool
03:24:37 <aristid> very nice for testing your code
03:25:19 <aristid> really, c++ is still not a good language but c++11 makes it much more bearable. IMHO
03:26:38 <quchen> For one of the hatable languages it's quite decent.
03:27:13 <quchen> aristid: http://stupidname.org/files/temp/temp_2013_04/ffi_cpp.tar.gz
03:27:52 <quchen> aristid: "<random> is very nice for testing your code" sounds like an awkward version of QuickCheck
03:28:43 <quchen> I haven't played with the example in a long time, so maybe the makefile is redundant.
03:30:30 <quchen> Haha. Just compiled and there's no output.
03:30:49 <quchen> It's left as an exercise to aristid to find the mistake ;-)
03:31:38 <aristid> quchen: your makefile is really terrible
03:32:16 <quchen> Thanks!
03:32:43 <quchen> But is it terribler than other makefiles?
03:34:28 <aristid> quchen: slightly, yes
03:34:45 <aristid> i mean...
03:34:48 <aristid> cpp :
03:34:50 <aristid>  g++ -c foo_c.cpp
03:34:52 * aristid cringes
03:35:40 <quchen> You're very helpful, thank you.
03:37:17 <typoclass> part of the problem is that nobody really knows how to write makefiles without everything turning into a mess in the long run
03:38:07 <aristid> that is true
03:38:27 <aristid> quchen: i can try to be more helpful, but then i don't think you really need a makefile at all.
03:38:59 <aristid> quchen: normal rules in makefile should be in the form of output : deps \n\t command
03:39:02 <aristid> so
03:39:08 <aristid> foo_c.o: foo_c.cpp
03:39:17 <aristid>     g++ -c foo_c.cpp
03:39:48 <quchen> Sure.
03:39:56 <quchen> But this isn't a makefile example.
03:40:12 <quchen> It's more like a batch file now that I think of it.
03:40:25 <quchen> Maybe I should've used a hashbang for it, yes :s
03:41:16 <m3ga> is there any way to get the current number of threads?
03:41:49 <luite> in ghcjs there is :p
03:42:13 <quchen> m3ga: Haskell thread? OS threads?
03:42:31 <m3ga> quaestor: both?
03:42:33 <AfC> m3ga: getNumCapabilities
03:42:50 <luite> gloss compiles with ghcjs: http://hdiff.luite.com:3070/
03:43:00 <quchen> getNumCapabilities is the current OS thread pool size.
03:43:15 <AfC> m3ga: e.g. https://github.com/afcowie/http-streams/blob/master/tests/IsolatedBenchmark.hs#L41
03:43:16 <m3ga> AfC: yes, and what about Haskell threads?
03:43:17 <aristid> quchen: reading some edwardk code, i see that cabal has a "c-sources" directive
03:45:09 <quchen> m3ga: GHC.Conc defines numSparks
03:46:00 <m3ga> quchen: i tried that but it always seems to return 0, even when compiling with -threaded and running with +RTS -N4
03:46:36 <quchen> m3ga: Are you making sure there are sparks? If everything's evaluated, the pool is empty of course
03:47:18 <m3ga> i ran 'replicateM_ 5 $ forkIO $ worker'
03:47:29 <typoclass> m3ga: out of curiosity, for what do you need the number?
03:48:39 <quchen> And worker does what?
03:49:23 <quchen> Also I'm not sure what happens when you start evaluating a spark.
03:49:23 <m3ga> typoclass: my workers exit when they are done. when i want to start a new batch of workers, i want to find out how many of the old workers are still running.
03:49:28 <quchen> Is it taken out of the pool maybe?
03:49:46 <m3ga> quchen: i would hope its take out of the pool.
03:50:36 <typoclass> m3ga: hm, doesn't ghc do that automatically? you can just fork tons of sparks. tens of thousands should be no problem
03:50:48 <m3ga> more basic question, is a spark a haskell thread or something else?
03:51:06 <quchen> It's pretty much a pointer to a Haskell value. It's not a thread.
03:51:16 <m3ga> typoclass: i can do that, but then they all content for CPU and disk and network.
03:51:30 <typoclass> m3ga: have you tested it?
03:51:39 <quchen> The spark pool collects these pointers, and the runtime picks sparks and evaluates them in parallel.
03:52:29 <m3ga> typoclass: i'm trying to get the concurrency working first and then add in the actual processing.
03:53:09 <quchen> m3ga: If you're looking for a way of letting only N computations run in parallel, I think a "work" queue with N permanent worker threads would be a better option.
03:53:58 <quchen> So you'd have your main thread create the computations, and put them in the queue; the workers are loops that read from the queue, calculate results, and put those in the result queue.
03:54:30 <m3ga> quchen: i actually have that working, i was trying to get trickier. maybe i should go with what i have :-)
03:55:16 <quchen> m3ga: "Tricker" is a good description for explicitly monitoring the spark pool.
03:55:45 <typoclass> m3ga: i dunno, it sounds like premature optimization. i think you might be spending a lot of time on something that you don't need
03:55:59 <m3ga> quchen: yes, i think trickier is a needless pain in the neck.
03:56:26 <typoclass> m3ga: i'd recommend that you try the simplest possible thing, and see how it behaves (profiling ...). then you can remove bottlenecks
03:56:38 <m3ga> typoclass: the STM.TQueue with a fixed thread pool implemention took 10 minutes to write :)
03:57:00 <m3ga> i think i'll stick with that until i have problems with it.
03:58:00 <quchen> Sounds like a good solution to me
04:06:19 <quchen> m3ga: Maybe use a TBQueue if you have lots of computations.
04:10:28 <m3ga> TQueue with a tiny bit of extra logic to adequate.
04:20:04 <natnayr> could someone help me with my accelerate function: http://hpaste.org/85681
04:21:03 <Botje> ... what's wrong with it?
04:21:12 <Botje> does it not compile? if so, add the error as well
04:21:17 <hpaste> natnayr pasted ‚Äúaccelerate‚Äù at http://hpaste.org/85682
04:21:48 <natnayr> Botje: i doesnt, im having trouble with list comprehension
04:22:35 <natnayr> trying to use map (f currentParticle) allOtherParticle
04:23:27 <Botje> I don't see any list comprehension in your code
04:23:58 <natnayr> line 47 of http://hpaste.org/85682
04:24:40 <Botje> okay, that's the map (betweenForces cur) xs?
04:25:10 <natnayr> yep
04:25:35 <Botje> and you want to apply betweenForces between cur and every particle in xs ?
04:25:43 <natnayr> yes
04:25:57 <natnayr> cur being the x of x:xs
04:26:01 <natnayr> x being a particle..
04:26:12 <Botje> uh, then why are you passing in cur separately as well?
04:26:46 <natnayr> oh yeah.. ok
04:26:58 <Botje> in accelerate you pinch of an x and pass it separately to calculateAllForces
04:27:00 <natnayr> so i made line 44 to calculateAllForces x:xs
04:27:25 <Botje> calculateAllForces (x:xs), then?
04:27:40 <Botje> then calcualteAllForces :: [Particle] -> Particle
04:27:40 <natnayr> how do i get it to move along the list?
04:28:21 <Botje> I think you can use a fold there.
04:28:31 * hackagebot bed-and-breakfast 0.4 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.4 (JulianFleischer)
04:28:39 <Botje> although a more accurate simulation would calculate the forces separately and apply them all at once.
04:28:52 <hpaste> natnayr pasted ‚Äúnatnayr‚Äù at http://hpaste.org/85683
04:29:20 <Botje> calculateAllforces (cur:rest) = foldl betweenForces cur rest
04:30:09 <natnayr> wow.. ok
04:30:14 <Botje> that will walk rest from left to right, accumulating your particle as it goes along.
04:30:29 <Botje> (note: "later" particles will see the updated state of your "current" particle)
04:31:03 <natnayr> yeah makes sense
04:31:13 <natnayr> considering this "data Particle = Particle Mass Position Velocity"
04:31:29 <natnayr> is the betweenForces function correct?
04:32:32 <hpaste> natnayr pasted ‚Äúaccelerate‚Äù at http://hpaste.org/85684
04:32:47 <Botje> please stop pasting update
04:32:55 <Botje> you can annotate and edit your posts on hpaste
04:33:07 <natnayr> oh, okok didnt know that
04:33:29 <natnayr> Botje: do u think the latest makes sense?
04:33:32 <Botje> if betweenForces only updates the velocity then the foldl is physically okay
04:33:56 <natnayr> for the betweenForces, regarding the composition of particle
04:34:24 <natnayr> Botje: Thanks!
04:34:33 <Botje> natnayr: you should fix all syntax errors first.
04:34:40 <Botje> the double = = on line 49, for example
04:34:48 <Botje> the calculateAllForces just hanging there on line 36
04:34:54 <`nand`> and the parse error on line 36
04:34:59 <Botje> yes, that.
04:35:05 <Botje> fix those.
04:35:07 <`nand`> missing parens in line 34
04:35:08 <`nand`> etc.
04:35:16 <Botje> the _ _ on the right side of 55 are wrong, too.
04:35:33 <Botje> strive to keep your program at least syntactically correct at all times
04:35:45 <natnayr> cant ignore them with _ _?
04:36:09 <`nand`> _ isn't a valid expression
04:36:11 <`nand`> just a valid pattern
04:36:19 <natnayr> ahh
04:36:30 <`nand`> (3 + _) * 2 -- ??
04:36:41 <Botje> you can't expect ghc to magically know which values to fill in there
04:36:52 <`nand`> on the other hand; 0 * _ = 0 -- makes sense
04:36:54 <natnayr> left side would that be ok
04:37:02 <Botje> ordinarily, yes.
04:37:12 <Botje> but you probably want to copy those values on the right hand side.
04:37:21 <natnayr> logically no?
04:37:32 <`nand`> the @ syntax is only valid for patterns as well
04:37:35 <natnayr> icic, makes sense.. gotta think like how the compiller does
04:37:57 <`nand`> you just need to think in terms of what you want to express
04:38:08 <Botje> betweenForces curr@(Particle mass pos (curX, curY)) = Particle mass pos (curX + calx, curY + calY)
04:38:11 <Botje> or something.
04:38:23 <natnayr> so an example could i "look into" cur on line 50 with cur@(Particle m (x,y) (vx,vy))?
04:38:42 <`nand`> a much better way to do this would be with record syntax
04:39:30 <`nand`> data Particle = Particle { mass :: Mass, pos :: Position, vel :: Velocity }; betweenForces curr = curr { vel = (outX, outY) } where (calX, calY) = vel curr; ...
04:39:57 <`nand`> or uh
04:40:21 <natnayr> `nand`: nah i cant touch the construction.. but ur record syntax looks more complicated, sry
04:40:39 <`nand`> betweenForces curr@Particle{ vel = (calX, calY), .. } -- something like this works too I think, but I don't quite remember how the .. worked
04:41:17 <`nand`> an even better way to do this would be with lenses, but that's sort of a given since everything improves with lenses
04:41:49 <`nand`> oh, in my examples I meant (curX, curY) and not (calX, calY)
04:42:48 <natnayr> thanks
04:43:04 <natnayr> i'll look over it now, thanks Botje and `nand`
04:51:12 <phischu> are cabal flags propagated to dependencies? for example if a package defines a "threaded" flag and  i "cabal install package -f threaded" are all dependencies installed with "threaded" if it is defined? what about already installed packages?
04:52:54 <mm_freak_> when writing a pipe proxy (pipes library), what's the correct type?  `(Proxy p) => p a' X b' Y m r`, `(Proxy p) => p a' X a' Y m r` or `(Proxy p) => p () X () Y m r`?
04:53:01 <cmears> phischu, I don't think so
04:53:10 <mm_freak_> phischu: yes
04:53:19 <mm_freak_> phischu: but only newly installed packags
04:54:01 <mm_freak_> phischu: since i want pandoc with syntax highlighting i update my packages like this:  cabal install -j4 --haddock-hyper -fhighlighting world
04:54:03 <`nand`> somehow I had a feeling that was a question about iteratees before I read the name ‚Äòpipes‚Äô
04:54:55 <phischu> mm_freak_: okay thank you
04:55:25 <mm_freak_> `nand`: proxies have an upstream, too, and my intuition is that Pipe p a b m r should be p a' a a' b m r
04:55:30 <mm_freak_> but i'm not entirely certain
04:55:36 <`nand`> sorry, I don't know anything about pipes
04:55:56 <mm_freak_> hmm
04:56:13 <`nand`> just saw the complicated types :)
04:56:24 <mm_freak_> in any case Pipe is defined like this:  Pipe p a b m r = p () a () b m r
04:56:55 <mm_freak_> but my intuition tells me that they should actually be defined like this:  Pipe p a b m r = forall a'. p a' a a' b m r
04:57:17 <`nand`> I guess that depends on the context
04:57:23 <`nand`> they both make sense
04:58:01 <mm_freak_> i think it doesn't‚Ä¶  the former practically acts like a dam for the upstream
04:58:03 <`nand`> in particular, () makes sense in a contravariant position, whereas forall a. a makes more sense in a covariant one
04:58:21 <`nand`> ..if I got that the right way round
04:58:45 <typoclass> i know nothing about pipes, but i always have the weird feeling that someone chose the wrong abstraction when there's so many parameters necessary
04:58:46 <mm_freak_> values flow like:  downstream a -> b and upstream a' <- b'
04:58:53 <`nand`> typoclass: yes, I think so too
04:59:11 <mm_freak_> the types really only look complicated
04:59:55 <`nand`> typoclass: have you checked out ‚Äòmachines‚Äô? it serves a similar role but using a different abstraction that results in much less garbage in the type, since stuff like that is taken care of what other stuff the user decides to stick into it
04:59:56 <mm_freak_> "(Proxy p) => p () a () b m r" is the equivalent of Conduit a m b or Enumeratee a b m r
05:00:40 <typoclass> `nand`: no, haven't checked it out. it's one of ekmett's packages isn't it
05:00:47 <`nand`> yes
05:01:22 <`nand`> the simplest machine is a ‚Äòforall m. Machine m a‚Äô which is just an infinite stream of ‚Äòa‚Äôs
05:01:31 <mm_freak_> i was a conduit user before, but the categorical aspects of pipes are appealing
05:01:49 <typoclass> mm_freak_: interesting; categorical in the sense of CT?
05:01:55 <phischu> with a Proxy you can parametrise your requests (and responds). If you don't need that you "request ()" stating that you "request something" but not "what exactly".
05:02:02 <`nand`> if you want to get more fancy, eg. a machine that acts like a stream transducer, you'd go with something like Machine (a ->) b -- which is a transducer from a to b
05:02:17 <`nand`> and so on, the more complex you want things, the more complex you can make them
05:02:34 <`nand`> need a machine that reads from two inputs while backtracking/unreading and performing IO? no problem
05:02:49 <mm_freak_> typoclass, `nand`: MachineT = Iteratee
05:02:58 <mm_freak_> just a less fancy name =)
05:03:58 <`nand`> (in particular, you'd want Machine (Unread a :+: (b ->) :+: IO) c -- or so
05:04:05 <phischu> you could for example "request 5" and your type would be "(Monad m, Proxy p) => p Int a b' b m a"
05:04:56 <mm_freak_> phischu: consider x >-> y >-> z
05:05:20 <mm_freak_> phischu: if y is a Pipe, then x can't receive upstream values from z
05:05:29 <mm_freak_> (i think)
05:05:50 <mm_freak_> i wonder if i'm talking sense‚Ä¶
05:05:56 <phischu> mm_freak_: yes, all it receives are ()s
05:06:27 <phischu> mm_freak_: a pipe is a more specific proxy namely one where there is no information flowing upstream
05:06:38 <phischu> only (), (), (), ...
05:06:42 <mm_freak_> phischu: and i'm currently using the fully spelled-out version:  p a' X a' Y m r
05:06:52 <mm_freak_> basically to allow values to flow upstream through my proxy
05:07:04 <mm_freak_> is this wrong to do?
05:08:03 <phischu> mm_freak_: this is perfectly fine
05:08:33 <mm_freak_> phischu: doesn't this indicate that the Pipe type synonym could be improved?
05:08:58 <mm_freak_> type Pipe p a b = forall a'. p a' a a' b
05:11:33 <mm_freak_> `nand`: btw, i'm used to ‚â• 4 type arguments =)
05:11:48 <mm_freak_> Wire has 4, ContinueT has 4, proxies have 6, ‚Ä¶
05:12:29 <mm_freak_> perhaps at some point we will introduce type-level records =)
05:12:34 <mm_freak_> and then come type-level lenses =)
05:12:47 <`nand`> I've wanted kind classes before
05:13:07 <`nand`> kind-polymorphic type families get fairly close :)
05:13:43 * ski_ recalls seeing a paper which suggested type-level records for Haskell
05:14:47 <phischu> mm_freak_: i do not know
05:16:46 <mm_freak_> oh wait
05:16:58 <mm_freak_> i'm mistaken
05:17:25 <mm_freak_> the types of 'request' and 'respond' make clear that Pipe is correct =)
05:17:56 <phischu> mm_freak_: my best guess is that it would be possible but it would be someting different, probably less convenient to use since you would have to explicitly handle request parameters and response results instead of filling in ()s everywhere
05:23:24 <mm_freak_> phischu: doesn't really work‚Ä¶  if the upstream input type is polymorphic there is nothing you can pass to 'request'
05:23:26 <beaky> hello
05:23:41 <beaky> what is the difference between type switching and pattern matching
05:23:44 <phischu> mm_freak_: mapP f x = do { y <- request x; x' <- respond (f y); mapP f x'}
05:23:51 <mm_freak_> beaky: well, what is type switching? =)
05:24:30 <beaky> type switching is having a function dispatch based on the type of the data
05:24:50 <beaky> but I think pattern matching does more than just that
05:24:59 <ski_> conceptually they are different
05:25:42 <ski_> if you know `foo :: Int -> [a] -> [a]', then you know that this function can't do different things depending on what the type `a' is
05:26:00 <ski_> iow, it has to treat the elements of type `a' uniformly
05:26:05 <mm_freak_> beaky: if you're asking this in the context of haskell there is no type switching as you defined it
05:26:12 <beaky> ah
05:26:26 <ski_> and the only place it can get the `a' elements of the output list from (apart from stuff like `undefined' and `error ...') is from the input list
05:26:56 <mm_freak_> beaky: there are ways to get something like type switching, though
05:27:23 <ski_> this turns out to be quite handy for higher-order functions, in fact
05:27:49 <mm_freak_> the three most common ways to do it (in order of decreasing commonness): type classes, higher rank types, existential types
05:28:16 <mm_freak_> i often find that the same problem can be solved with both higher rank types and existential types
05:29:00 <beaky> are type classes bad?
05:29:02 <ski_> if the higher-order function is polymorphic, e.g. with type `Int -> (Int -> a -> Maybe b) -> [a] -> [b]', then you know that the only way it can compute a `b' element in the output is by calling your provided argument function; and also it can't depend on what type `a' is, and hence can't depend on what values the `a' elements in the input list has
05:29:03 <romm> mm_freak_, the typeclass method is just defining data MyType = Opt1 | Opt2 ... etc, and then matching on the value ctor?
05:29:28 <mm_freak_> romm: that's not "type switching"
05:29:41 <mm_freak_> that's regular "value switching" aka pattern matching
05:29:50 <beaky> ah
05:29:51 <romm> mm_freak_, how is it done then?
05:29:52 <ski_> this means that you can more easily refactor code, *locally*, without having to look into the implementation of the polymorphic function to see whether your intended refactoring is safe
05:30:34 <mm_freak_> romm: when you write "(Num a) => a -> a" you could interpret it as "Num a -> a -> a", and that's how it's actually implemented in GHC
05:31:09 <mm_freak_> of course that's not like dynamic dispatch, because the decisions are made at compile time
05:31:10 <ski_>   data Num a = NumDict {fromInteger :: Integer -> a,(+) :: a -> a -> a,...}
05:31:32 <mm_freak_> higher rank types allow you to actually switch at run-time
05:31:37 <mm_freak_> i do that quite often
05:31:54 <beaky> so higher-rank types mean parametrising the parametrised types?
05:32:03 <beaky> or not
05:32:15 <ski_> mm_freak_ : seen from one angle, dynamic dispatch is just calling (locally) unknown functions, no ?
05:32:24 <mm_freak_> beaky: one way to interpret higher rank types:  you allow to be explicit about where functions take type arguments
05:32:27 <romm> wait, wait. mm_freak_, how is interpreting as "Num a -> a -> a" help me?
05:32:41 <mm_freak_> ski_: not necessarily
05:32:56 <mm_freak_> romm: you receive what to do as an argument
05:32:57 <ski_> beaky : higher-ranked means that the *argument* of the function is polymorphic, or the argument of the argument is, &c.
05:33:27 <beaky> ah
05:33:35 <mm_freak_> romm: example:  plus x y = x + y
05:33:42 <ski_> romm : you can vaguely think of a value of type `Num a' as a dictionary of "methods" for the type `a'
05:33:46 <mm_freak_> plus :: (Num a) => a -> a -> a
05:33:57 <mm_freak_> romm: another way to write it:  plus (+) x y = x + y
05:34:08 <mm_freak_> now:  plus :: (a -> a -> a) -> a -> a -> a
05:34:19 <ski_> romm : but note that, *unlike* in typical OO programming, we *don't* bundle each value of type `a' with it's own dictionary of methods for the type `a' !
05:34:31 <mm_freak_> at some point you would pass many such functions, so you would collect them in a record type
05:34:52 <mm_freak_> data Ops a = Ops { (+) :: a -> a -> a, (-) :: a -> a -> a, ‚Ä¶ }
05:35:03 <mm_freak_> and then you pass Ops:  plus :: Ops a -> a -> a -> a
05:35:19 <LambdaDusk> fat types or slim types? which is the better idea?
05:35:22 <mm_freak_> haskell allows you to select and pass that "dictionary" of operations implicitly
05:35:38 <mm_freak_> and that's the type class mechanism
05:35:50 <ski_> romm : e.g. we can have a single dict `Num a', and a list `[(String,a)]' -- and now we can use the *same* methods for all of the `a' values here (e.g. we don't have to choose which dict to use, if we want to combine two (or more) `a'-values with a method from `Num a')
05:36:07 <ski_> mm_freak_ : elaborate ?
05:36:19 <mm_freak_> ski_: on what?
05:36:32 <ski_> mm_freak_ : "not necessarily"
05:36:35 <romm> mm_freak_, ski_, i think i understood all that (basically ski_ is saying these are interfaces), but i'm not sure how this mechanism allows me to behave differently for different types `a'
05:37:35 <ski_> LambdaDusk : mayhaps shady types ?
05:37:58 <romm> mm_freak_, what you described is some sort of function applier that can received a function from some defined set Ops, but it doesn't look like "type switching", no?
05:37:59 <LambdaDusk> ski_: Huh?
05:38:02 <mm_freak_> ski_: well, consider C++ where you too get a form of dictionary (the vtable)
05:38:10 <beaky> :t on
05:38:12 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
05:38:15 <ski_> romm : well, in which sense did you mean "interfaces" ? like in Java or C# ?
05:38:21 <mm_freak_> ski_: everything is static, and in particular you don't actually need RTTI for C++ dynamic dispatch
05:38:35 <mm_freak_> C++'s dynamic dispatch gets close to what RankNTypes does in haskell
05:38:57 <ski_> LambdaDusk : sorry, i thought you were (at least partially) joking
05:39:00 <beaky> C++ has rank N types by default?
05:39:08 <beaky> through virtuals?
05:39:12 <romm> wasn't beaky asking about something similar to python's isinstanceof()?
05:39:21 <aristid> beaky: that's an... interesting way to look at the c++ type system.
05:39:27 <mm_freak_> romm: the type switching aspect comes from the fact that you don't /choose/ the instance of Ops in the type class mechanism
05:39:37 <LambdaDusk> ski_: No I wonder if its better to make types with many fields like in object-oriented languages
05:39:37 <beaky> ah I was asking about things like tagged unions in Pascal/C
05:39:39 <mm_freak_> the compiler selects one for you based on the type
05:40:11 <ski_> mm_freak_ : not including virtual(?) methods ?
05:40:19 <mm_freak_> aristid: that's my interpretation
05:40:26 <mm_freak_> ski_: particularly including those
05:40:55 <mm_freak_> LambdaDusk: keep your types slim‚Ä¶  fat types get ugly and unmaintainable
05:41:04 * ski_ only has a pretty vague idea of C++'s idea of OO
05:41:31 <mm_freak_> ski_: it's very similar to java, except that all choises are made at compile time, unless you use weird crap like dynamic_cast
05:41:46 <LambdaDusk> mm_freak_: But what if I need some values trudging along... I have this image type that requires its size and its original size (for sub-imagining)
05:42:21 <mm_freak_> LambdaDusk: that doesn't sound like a fat type =)
05:42:29 <aristid> mm_freak_: i think dynamic_cast requires rtti
05:42:34 <mm_freak_> aristid: exactly
05:42:39 <mm_freak_> everything that requires RTTI is broken
05:42:44 <aristid> :)
05:42:51 <aristid> virtual methods don't require it
05:43:06 <ski_> mm_freak_ : so if you have an array of `Foo's, it knows statically for each element what its `vtable' is !?
05:43:13 <mm_freak_> yeah, just like RankNTypes doesn't, but gives you the ability to make run-time choices based on type =)
05:43:19 <LambdaDusk> mm_freak_: Any haskell data type wit more than 4 fields makes me uncomfortable
05:43:32 <aristid> mm_freak_: :D
05:43:43 <mm_freak_> ski_: the index into the statically compiled vtable is known only at run-time
05:43:44 <beaky> I use types with over 10 fields, and half of those fields are nested 3 levels deep
05:44:28 <mm_freak_> LambdaDusk: me too‚Ä¶  sometimes you can't really get around that, but sometimes it also suggests that your concept may be broken/unfortunate
05:44:42 <ski_> beaky : nested can be fine, as long as it's sensibly factored
05:44:44 <beaky> ah
05:44:45 <mm_freak_> for example ideally you don't have any Bool fields
05:44:48 <romm> mm_freak_, sorry to throw you back, but aren't the type of all the members of Ops equal? if you don't choose the instance of Ops, how do you know the compiler chooses the correct one? (as you can see, i'm new)
05:44:56 <mm_freak_> ideally you don't use Bool at all
05:45:10 <ski_> @where boolean-blindness
05:45:10 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
05:45:14 <LambdaDusk> mm_freak_: Maybe I make it an union type so the original size is only on the values that need it
05:45:17 <mm_freak_> romm: the choice is made based on the type argument of Ops
05:45:23 <mm_freak_> romm: read Ops as Num
05:45:42 <mm_freak_> data Num a = Num { (+) :: a -> a -> a, negate :: a -> a, ‚Ä¶ }
05:45:49 <haskell_love> hello
05:45:54 <haskell_love> I love haskell but I'm banned
05:45:56 <ski_> romm : the compiler ensures there can be at most one value of type `Ops a', for each type `a'
05:45:57 <haskell_love> may I be unbanned please ?
05:46:00 <mm_freak_> the choice of a set of predefined values of that type (called instances) is made based on the type 'a'
05:46:11 <haskell_love> -b please ?
05:46:29 <mm_freak_> haskell_love: if you were banned you couldn't talk ;)
05:46:38 <`nand`> or join the channel
05:46:45 <haskell_love> yeah, I entered through webchat.freenode.net
05:46:50 <haskell_love> can I be unbanned please ?
05:46:58 <`nand`> isn't that a violation of the freenode rules?
05:47:03 <mm_freak_> there are 116 bans on this channel
05:47:09 <mm_freak_> how are we supposed to know who is you?
05:47:17 <haskell_love> my ip is 188.26.210.134
05:47:19 <romm> uh, i need an example. can you implement func x that returns x ++ "foo" if x is a String, and x + 2 if it's a Num?
05:47:24 <ski_> perhaps you could ask in #haskell-ops ..
05:47:24 <haskell_love> my nickname was average_drifter
05:47:51 <beaky> why were you banned
05:48:02 <mm_freak_> romm: no
05:48:24 <haskell_love> ski_: I asked but no answer so far
05:48:26 <mm_freak_> LambdaDusk: as said, first thing is to get rid of Bools
05:48:37 <haskell_love> mm_freak_: I asked in #haskell-ops but no answer so far..
05:48:41 <`nand`> 2013-01-15 02:03:46 <-- mauke has kicked average_drifter (average_drifter)
05:48:47 <`nand`> 2013-01-15 02:04:05     --      Mode #haskell [+b *!~un_golan@*] by mauke
05:48:48 <haskell_love> yeah...
05:48:56 <haskell_love> yes
05:48:57 <romm> mm_freak_, hmm, then it's not "type switching" as i imagined it
05:48:58 <LambdaDusk> mm_freak_: Rid of bools?
05:48:59 <haskell_love> that's me
05:49:03 <`nand`> though I can't seem to discern a reason from that log. Maybe you were disconnecting/reconnecting a lot?
05:49:08 <`nand`> that has caused bans before, simply to stop the spam
05:49:12 <mm_freak_> romm: it's static, but the choice is made based on type
05:49:13 <beaky> are ADTs + Type Classes a solution to the expression problem? (among other things)
05:49:19 <haskell_love> `nand`: no
05:49:24 <haskell_love> I trolled a bit
05:49:26 <`nand`> oh
05:49:28 <`nand`> 2013-01-15 02:04:36 @mauke shachaf: ban evasion
05:49:30 <mm_freak_> romm: you might call it static "type switching", but i don't like the term anyway
05:49:44 <`nand`> looks you were banned for evading some previous ban
05:49:44 <haskell_love> shachaf <== not me
05:49:45 <mm_freak_> LambdaDusk: Bool, you know, True and False‚Ä¶
05:49:52 <haskell_love> no I didn't, that was not me
05:49:53 <mm_freak_> that boolean type that has only two values
05:49:57 <haskell_love> but I did troll and got banned once
05:50:04 <LambdaDusk> mm_freak_: I don't like to use that anyway...
05:50:06 <`nand`> haskell_love: he was replying to ‚Äòshachaf‚Äô asking why mauke banned you :)
05:50:09 <mm_freak_> LambdaDusk: good =)
05:50:11 <romm> mm_freak_, i don't mind if it's static or not. i just don't understand how would you write such a function with this mechanism
05:50:14 <monoidal> `nand`, the reason probably has to do with http://ircbrowse.net/browse/haskell?q=+average_drifter
05:50:16 <haskell_love> oh !
05:50:20 <LambdaDusk> mm_freak_: I prefer Union types there
05:50:30 <eikke> romm, mm_freak_: can't you do that using a typeclass?
05:50:54 <haskell_love> yes... I  trolled
05:50:56 <romm> eikke, i think that's what mm_freak_ is trying to explain to me, though i fail to understand.
05:50:56 <haskell_love> what can I say
05:51:08 <mm_freak_> romm: i can actually implement that function, but only if you tell me what you want to do with the result
05:51:39 <haskell_love> mauke: are you considering unbanning me?
05:51:53 <romm> mm_freak_, let's say... print it to the screen?
05:51:54 <`nand`> monoidal: oh, that's a useful site; if I try ‚Äògrep‚Äôping through my logs I get tons of join/part/nicklist spam
05:52:13 <eikke> romm: http://hpaste.org/85685
05:52:14 <ski_> `nand` : hm, as far as i understood the term, invocation through a virtual method on a run-time-provided object would count as "dynamic dispatch" (but of course doesn't entail having to compare some kind of (e.g) statically known type or class token at run-time with a corresponding one inside the provided object)
05:52:41 <eikke> (I was under the impression hpaste allowed execution of some code... is that some other pastebin then?)
05:52:55 <mm_freak_> romm: first define a GADT:  data Some :: * -> * where SomeString :: String -> Some String; SomeNum :: (Num a) => a -> Some a
05:53:21 <`nand`> hpaste does not, but it does run hlint and show you its output
05:53:22 <mm_freak_> romm: then you can define this function:  something :: Some a -> (forall a. (Show a) => a -> b) -> b
05:53:43 <`nand`> ski_: that doesn't seem like it was aimed at me
05:53:53 <mm_freak_> romm: but of course that function is isomorphic to Some a -> (String -> b) -> b
05:53:53 <ski_> er, so it wasn't
05:53:57 <ski_> mm_freak_ ^
05:54:10 <ski_> LambdaDusk : did you see the boolean blindness link above, yet ?
05:54:15 <romm> eikke, i see. you basically said that String / Int are instances of that type and defined different behaviors. cool.
05:54:28 <eikke> romm: I didnt test that code ;)
05:54:48 <`nand`> eikke: perhaps you were thinking of codepad?
05:54:55 <eikke> `nand`: yeah, found that now :)
05:55:04 <eikke> romm: needed a minor tweak -> http://codepad.org/KqYZc5Ys
05:55:07 <mm_freak_> eikke: that's not dynamic
05:55:25 <LambdaDusk> pretty much like event combinators in FRP
05:55:53 <mm_freak_> eikke: example: the value is read from the user and interpreted as a number given a number and a string otherwise
05:56:40 <eikke> mm_freak_: right. missed that constraint ;)
05:57:19 <ski_> LambdaDusk : discriminated/tagged union / sum / variant record / algebraic data types give different structuring of code than record / object types
05:57:45 <ski_> LambdaDusk : they are good for different circumstances
05:57:49 <luite> http://hdiff.luite.com:4100/
05:57:56 <luite> gloss compiled to javascript again
05:59:33 <romm> mm_freak_, what is the second arg of 'something'?
06:00:43 <romm> btw, if you don't have time for this i can go back to reading LYAH. i'm just curious.
06:01:50 <ski_> romm : it's a "handler", or "callback", that will get the "real result"
06:02:28 <romm> shouldn't it be of type a -> b then?
06:02:33 <ski_> romm : however, it won't be able to know what type `a' is. since `something' decides what type `a' to use, the caller of `something' has to be able to cope with *any* type `a' that is in class `Num'
06:02:37 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù pasted ‚ÄúRun-time type-based choice ("dynamic dispatch"?)‚Äù at http://hpaste.org/85686
06:02:38 <ski_> romm : no
06:02:46 <mm_freak_> romm, eikke: see paste
06:03:01 <`nand`> @tell edwardk you should totally run the lens-pong example through ghcjs and host the result on the website
06:03:01 <lambdabot> Consider it noted.
06:03:17 <mm_freak_> i like the style this gives rise to‚Ä¶
06:03:18 <mm_freak_> main = readSome $ andThen $ print
06:03:20 <mm_freak_> =)
06:04:06 <`nand`> main = someValues & take 5 & reverse & print
06:04:20 <romm> is Some a new kind?
06:04:28 <mm_freak_> romm: no, it's a type
06:04:29 <ski_> romm : if you have `foo :: ..a.. -> ..b..', which is short for `foo :: forall a b. ..a.. -> ..b..', that means the *caller* (the user of the function) decides on *both* the type `a' and the type `b', and the *callee* (the implementor of the function) has to be able to cope with any choice of type for `a' and `b' that the caller makes (which is why it can't inspect any given values of type `a' and `b')
06:04:33 <mm_freak_> romm: see the paste
06:04:38 <romm> sorry, i just read the typeclass chapter of LYAH just yesterday.
06:04:52 <mm_freak_> http://hpaste.org/85686 ‚áê Some is defined as a GADT there
06:05:07 <mm_freak_> if you're new to haskell you'll probably not understand what this is
06:05:44 <ski_> romm : however, if you had `bar :: forall a. (..a.. -> (exists b. ..b..))', then the caller still decides on the type `a', but the *callee* decides on `b' (and the caller doesn't know which type it will choose -- it can even depend on the values of the arguments to the function)
06:05:46 <mm_freak_> in any case the program behaves differently depending on whether you passed a number or a string
06:05:58 <`nand`> andThen :: (String -> b) -> Some a -> b -- this was probably already mentioned, I didn't follow the conversation
06:06:10 <mm_freak_> `nand`: yes, i mentioned it earlier
06:06:28 <mm_freak_> but often the higher rank type is much nicer
06:06:44 <haskell_love> HEY
06:06:47 <haskell_love> can I get a -b here ?
06:06:59 <haskell_love> wtf ...
06:07:22 <mm_freak_> haskell_love: be patient
06:07:31 <ski_> romm : mm_freak_'s function is basically :: `directSomething :: forall a. Some a -> exists b. Show b *> b' -- but Haskell doesn't have direct support for the `exists' syntax -- so you have to express the same concept in a somewhat more roundabout way
06:07:32 <haskell_love> how patient ?
06:07:41 <romm> ski_, mm_freak_ , `nand`, it seems that i need to read some more before i understand any of this.
06:07:44 <ski_> haskell_love : until mauke shows up, presumably
06:08:21 <ski_> romm : i think you should understand the basics of (parametric) polymorphism before trying to tackle existentials, yes
06:08:40 <mm_freak_> romm: understandable‚Ä¶  the code really only needs one extension (GADTs), but i found it looks nicer with the three
06:08:42 <romm> i thought that "typeclass" method would use only the typeclass mechanism, but since i'm not familiar with GADT's etc., i'll just get back to LYAH
06:08:45 <ski_> romm : the type classes are sortof orthogonal to the existentials (but can be useful together)
06:09:23 <ski_> oh, and GADTs is also not directly connected to type classes
06:10:11 <mm_freak_> RankNTypes and ExistentialQuantification together basically give you "(A : Set) -> ‚Ä¶" and "(A : Set, ‚Ä¶)"
06:10:20 <romm> i have to say though, these abstraction mechanisms make some tasks appear much more "complicated" in haskell than in other languages.
06:10:31 <mm_freak_> we often call that combination "lightweight dependent types" =)
06:11:16 <mm_freak_> romm: you would use such an abstraction when you want dynamic code with static guarantees
06:11:22 <ski_> romm : i suspect mm_freak_ brought GADTs up because you asked about how type classes compared "type switching" and dynamic dispatch
06:11:54 <ski_> mm_freak_ : .. btw, did you see my comment a bit about to you, which i misdirected to `nand` ?
06:12:04 <Mortomes> Anyone else got a webcam sex related PM from NataLia upon joining?
06:12:08 <mm_freak_> ski_: i don't think so, could you repeat it?
06:12:35 <mm_freak_> not me‚Ä¶  yet‚Ä¶
06:12:36 <ski_> (about 19 minutes ago)
06:12:50 <ski_> <ski_> `nand` : hm, as far as i understood the term, invocation through a virtual method on a run-time-provided object would count as "dynamic dispatch" (but of course doesn't entail having to compare some kind of (e.g) statically known type or class token at run-time with a corresponding one inside the provided object)
06:13:37 <romm> ski_, understandable. still, compared to isinstanceof() or even RTTI it's quite complicated. static guarantees, however, is something new, so i guess there are advantages.
06:13:39 <mm_freak_> ski_: ah‚Ä¶  well, i don't think the term "dynamic dispatch" has a formal definition
06:13:48 <mm_freak_> you could consider GADTs dynamic-dispatchy
06:13:52 <ski_> mm_freak_ : "lightweight dependent types" -- or, strangely, "second order quantification"
06:14:31 <ski_> mm_freak_ : or indeed just passing around plain old Haskell98 records of "methods"
06:15:16 <mm_freak_> ski_: well, that's really just, what could you call it, "value switching"
06:15:19 <mm_freak_> aka pattern matching
06:15:41 <mm_freak_> GADT pattern matching actually gives type information at run-time
06:15:53 <copumpkin> zomg
06:15:57 <Ankhers> I have a question about folds. I know I am just missing something relatively simple. Can someone explain why left folds will not work on infinite lists, but right folds can?
06:16:23 <copumpkin> > foldl z [a,b,c]
06:16:25 <lambdabot>   Couldn't match expected type `a0 -> b0 -> a0'
06:16:25 <lambdabot>              with actual type...
06:16:29 <copumpkin> > foldl f z [a,b,c]
06:16:30 <lambdabot>   f (f (f z a) b) c
06:16:33 <copumpkin> > foldr f z [a,b,c]
06:16:35 <lambdabot>   f a (f b (f c z))
06:16:36 <mm_freak_> Ankhers: because left-folds are not productive:  foldl f z (x:xs) = foldl f (f z x) xs
06:16:47 <mm_freak_> in other words, the result depends on the recursive call‚Ä¶  over and over
06:17:10 <mm_freak_> with a right fold with each recursion you get one more constructor application
06:17:15 <copumpkin> Ankhers: look at the expression for foldl and tell me how many times the z should be nested at the beginning
06:17:26 <mm_freak_> foldr f z (x:xs) = f x (foldr f z xs)
06:17:47 <ski_> romm : (parametric) polymorphism isn't *that* complicated (though understanding the full ramifications of it takes more time)
06:18:00 <luite> http://hdiff.luite.com/reduce/ <- actual heap+stack view during foldl/foldr/foldl'
06:18:39 <LambdaDusk> is ByteString.unpack == show ?
06:18:39 <quchen> luite: You're the god of JS in here aren't you
06:18:46 <bitonic> luite: that is very cool
06:18:48 <Ankhers> copumpkin: 3
06:19:00 <copumpkin> Ankhers: and it needs to decide on that immediately, right?
06:19:02 <luite> quchen: the javascript is pretty simple
06:19:06 <copumpkin> Ankhers: in some sense
06:19:14 <luite> quchen: only a lot ;p
06:19:16 <ski_> romm : existentials are in some sense "opposite" (dual) to universals (which is just another term for parametric polymorphism) -- this perhaps doesn't tell you much now, but as you learn both, you'll notice there's a nice symmetry between them
06:19:33 <copumpkin> > foldl f z [a,b,c, d] -- Ankhers: this is 4
06:19:34 <lambdabot>   f (f (f (f z a) b) c) d
06:19:46 <luite> but you can see that foldl builds a large thunk, then pushes everytrhing on the stack, foldr builds the stack immediately, foldl' runs in constant space
06:20:00 <romm> ski_, "you people" really like to borrow math names, eh? :)
06:20:20 <mm_freak_> lambdabot: no
06:20:25 <mm_freak_> LambdaDusk: no
06:20:27 <copumpkin> lol
06:20:34 <Ankhers> copumpkin: I think my issues stem from the fact that in my mind the first element in the list is computed first, whereas with a right fold, the last element needs to be computed first. Is my understanding incorrect?
06:20:44 <copumpkin> yes
06:20:50 <luite> bitonic: I've been meaning to add a mode where the user can enter the expression, but i'd have to dig up my ghc sandboxing code first
06:20:52 <copumpkin> both folds traverse the list from left to right
06:20:58 <elliott> romm: because the concepts are identical, usually
06:21:21 <ski_> romm : type classes are perhaps more interesting. one can see it as a way to implicitly pass around values which are determined by types (e.g. possibly by the result type only !) -- that there's at most one "instance" of a type class for a given type is important, it means that we can reason and refactor more about the code
06:21:32 <mm_freak_> Ankhers: consider a custom list type:  data List a = Cons a | EOL
06:21:41 <elliott> mm_freak_: err...
06:21:41 <romm> elliott, probably, although i'm not sure i understand why algebraic type are "algebraic".
06:21:45 <mm_freak_> Ankhers: consider the fold that turns an [a] into a List a
06:21:46 <elliott> mm_freak_: you sure about that type? :P
06:21:57 <mm_freak_> d'oh
06:21:59 <mm_freak_> sorry =)
06:22:05 <mm_freak_> Ankhers: consider a custom list type:  data List a = Cons a (List a) | EOL
06:22:15 <mm_freak_> then consider the fold that turns an [a] into a List a
06:22:24 <ski_> romm : GADTs is a kind of generalization of "ordinary" algebraic data types, where the data constructors doesn't *need* to be polymorphic in the type parameters -- GADTs subsume existentials
06:22:29 <elliott> romm: it's quite a lovely connection, you can get zippers and such from it
06:22:36 <mm_freak_> foldr Cons EOL (x:xs) = Cons x (foldr Cons EOL xs)
06:22:46 <arkeet> they're called algebraic because you have sums and products.
06:22:52 <elliott> ("The Derivative of a Regular Type is its Type of One-Hole Contexts")
06:22:55 <mm_freak_> as you can see the traversal is from left to right, but unlike foldl you get one application of Cons immediately
06:22:59 <copumpkin> arkeet: and 0 and 1!
06:23:11 <arkeet> sure.
06:23:19 <arkeet> those are the empty sum and empty product.
06:23:20 <arkeet> ;)
06:23:28 <copumpkin> https://gist.github.com/copumpkin/2636229
06:23:44 <romm> okay. i basically lost track of what you guys are trying to tell me :)
06:23:51 <ski_> romm : consider `data Either a b = Left a | Right b' -- we can think of the type `Either a b' as `a + b' -- certainly, in case `a' and `b' are finite types, then `a + b' has as many (total) elements as the sum of the (total) elements of `a' respectively `b'
06:24:21 * elliott suspects this conversation of being ten sidetracks deep
06:24:25 <ski_> romm : e.g., the type `data Bool = False | True' has two elements, and the type `data Ordering = LT | EQ | GT' has three
06:24:40 <mm_freak_> elliott: common problem with this channel
06:24:47 * copumpkin sidetracks elliott's sidetrack comment
06:24:53 <copumpkin> elliott: it's 11, actually
06:24:58 <copumpkin> I'll explain
06:25:03 <ski_> romm : and the type `Either Bool Ordering' then has five elements : `Left False',`Left True',`Right LT',`Right EQ',`Right GT'
06:25:04 <mm_freak_> when someone asks a very basic questions, 10 people try to answer it in different ways =)
06:25:06 <elliott> copumpkin: what do you mean by 11?
06:25:09 <ski_> romm : ok ?
06:25:20 <mm_freak_> leading to more confusion than clarity =)
06:25:22 <Ankhers> mm_freak_: Alright, I think I understand... Thanks for the help, you too copumpkin.
06:25:44 <romm> ski_, yes
06:26:06 <mm_freak_> Ankhers: to really understand the semantics of lazy things you have to ask yourself:  "what would happen when i pattern-match?"
06:26:13 <ski_> romm : note that `Either a b' isn't *quite* the ordinary(?) union of sets familiar(?) from set theory
06:26:45 <mm_freak_> Ankhers: for example what happens when you pattern-match "foldr Cons EOL [1..]" against Cons x xs?
06:26:58 <romm> ski_, yes, it's a union of two set products.
06:27:03 <ski_> romm : if you have two sets `{0,1}' and `{1,2,3}', and take the union of them, then the resulting union set `{0,1,1,2,3}' (which is equal to `{0,1,2,3}') only has four elements, not five
06:27:27 <mm_freak_> first step, reduce:  foldr Cons EOL (1:[2..]) = Cons 1 (foldr Cons EOL [2..])
06:27:39 <arkeet> it's a "disjoint union"
06:27:40 <mm_freak_> next step, match:  Cons 1 (foldr Cons EOL [2..])
06:27:42 <arkeet> or "tagged union"
06:27:55 <mm_freak_> foldr didn't finish, but the result is available immediately
06:28:02 <ski_> romm : however, we could take the union of the two sets, after *tagging* the elements from one set and the ones from the other, so that we can keep track of from which original set the element came from
06:28:14 <romm> arkeet, uh, yes, that's what i meant.
06:28:33 <arkeet> or "coproduct"
06:28:40 <romm> yes, yes, you can skip the math explanations for me :)
06:28:40 <arkeet> :(
06:28:43 <ski_> romm : e.g. we can tag the elements `x' of the first set as `(0,x)', and the elements `y' of the second set as `(1,y)'
06:28:50 <mm_freak_> arkeet: or "sum" ;)
06:28:51 <romm> ski_, stop :)
06:29:26 <arkeet> mm_freak_: "coproduct" is the notion that generalizes the most nicely.
06:29:38 <mm_freak_> arkeet: Either x y = x + y
06:29:40 <klrr> isn't addBinding a function?
06:29:42 <copumpkin> elliott: I'm actually talking about 11 in base 7
06:29:43 <mm_freak_> arkeet: (x, y) = x*y
06:29:50 <klrr> ?src addBinding
06:29:51 <lambdabot> Source not found. I feel much better now.
06:29:51 <ski_> romm : and then we get `{(0,0),(0,1),(1,1),(1,2),(1,3)}' -- in more Haskellish notation we could say perhaps `{left(0),left(1),right(1),right(2),right(3)}'
06:29:52 <arkeet> hey, I know that.
06:30:04 <arkeet> you don't have to be telling me. :p
06:30:15 <romm> ski_, ... i told you 5 minutes ago that you don't have to explain this :)
06:30:18 <mm_freak_> arkeet: that's why i prefer "sum" and "product" instead of "coproduct" and "product" =)
06:30:21 <copumpkin> arkeet don't know no maff
06:30:23 <elliott> arkeet: 1+1 = 2
06:30:27 <arkeet> =(
06:30:39 <copumpkin> mm_freak_: but coproduct reveals the connection to product!
06:30:46 <arkeet> mm_freak_: but what if you throw in bottoms and stuff? then what should "sum" mean?
06:30:50 <mm_freak_> arkeet: (let 1 + 1 = 3 in 1 + 1) = 3
06:30:52 <ski_> romm : anyway, the type `(a,b)' in Haskell is just the cartesian product of the sets/types `a' and `b' : we can think of this as `a * b', since the number of elements in the cartesian product is the product of the elements in the "factor" sets (if finite)
06:30:56 <mm_freak_> > let 1 + 1 = 3 in 1 + 1
06:30:58 <lambdabot>   3
06:30:58 <romm> mm_freak_, sum of sets is bad lingo.
06:31:05 <arkeet> romm: it's fine.
06:31:08 <elliott> guys this is a trainwreck. i think romm may be suffering.
06:31:22 <ski_> romm : finally, we can think of the Haskell type `()' as `1', since it's a type with a single element (also written `()', in Haskell)
06:31:23 <romm> it's not fine.
06:31:26 <arkeet> sets up to isomorphism do form a semiring.
06:31:28 <mm_freak_> arkeet: with bottoms you basically destroy everything
06:31:32 <arkeet> where addition is disjoint union and etc.
06:31:36 <mm_freak_> both category theory and sum magnitudes
06:31:40 <Ankhers> mm_freak_: OMG... I can't believe I missed that... thank you SO much!
06:31:45 <romm> arkeet, when mathematician use sums of sets, they usually mean minkowski sums.
06:31:50 <arkeet> they do?
06:31:57 <romm> yes.
06:32:03 <arkeet> I didn't know sets were usually subsets of some vector space.
06:32:05 <mm_freak_> Ankhers: you're welcome =)
06:32:23 <mm_freak_> Ankhers: suddenly the world of folds becomes totally clear, doesn't it? =)
06:32:24 <ski_> romm : btw, the "not quite union" of sets above is commonly called "disjoint union" or "discriminated union" of the two sets
06:32:36 <copumpkin> say no to discrimination
06:32:42 <romm> arkeet, minkowski sums aren't defined only for vector spaces.
06:32:49 <copumpkin> no separate but equal Either a a
06:32:56 <ski_> romm : anyway, now consider a type like `data List a = Empty a | NonEmpty a (List a)'
06:33:03 <arkeet> romm: it very strongly depends on what kind of mathematician you ask.
06:33:14 <Ankhers> mm_freak_: I'm going to have to use them to get used to them, but yes. I'm still not used to lazy languages... So I just need to remember that from time to time...
06:33:20 <mm_freak_> Ankhers: for more mind bending realize that there are folds for Maybe and Either, too, called 'maybe' and 'either' =)
06:33:32 <elliott> ski_: "we can think of the Haskell type `()' as `1', since it's a type with a single element (also written `()', in Haskell)" () is also written as ()?!
06:33:39 <arkeet> like you can talk about sums in chain groups and stuff.
06:33:48 <copumpkin> romm: there are many flavors of mathematicians, some of which don't even care what minkowski sums are, probably  :)
06:33:48 <ski_> romm : now, this type is "basically" the same as `data List a = Empty () | NonEmpty (a,List a)', agree ?
06:33:49 <arkeet> but that's off topic.
06:34:04 <Ankhers> mm_freak_: I think I'm going to stick to follow LYAH at the moment. I still don't fully understand applicative functors...
06:34:06 <ski_> elliott : the element :)
06:34:26 <mm_freak_> Ankhers: sure, go ahead
06:34:52 <romm> arkeet, i'm not familiar enough with algebraic topo to know that...
06:35:01 <Ankhers> mm_freak_: Thanks again for the help. It is nice to see a community actually help the newbs instead of berate them...
06:35:04 <romm> but i'll take your word for it :)
06:35:18 <Chousuke> elliott: the single element of type () is written ()
06:35:35 <Chousuke> makes sense to me
06:35:56 <elliott> yes, it just amused me :)
06:35:58 <romm> anyway, i'm sorry this has come to this.
06:36:19 <ski_> romm : .. and that type is basically the same as `data List a = MkList (Either () (a,List a))' -- or, in the "algebraic" notation :  List a ~= 1 + a * List a
06:36:25 <romm> i have to go, and frankly, i didn't understand the point of what you're trying to say, ski_.
06:36:35 <mm_freak_> Ankhers: http://www.reddit.com/r/haskell/comments/1bcqvw/trolling_haskell/
06:36:36 <romm> when i come back, i'll reread this.
06:36:40 * arkeet is currently staring at a paper where + means a disjoint union of manifolds...
06:36:43 <mm_freak_> Ankhers: we are known for that =)
06:36:58 <ski_> romm : and that one reason why it's called "algebraic datatypes", because they are sums-of-products
06:37:02 <elliott> mm_freak_: (that thread was deleted)
06:37:16 <mm_freak_> uh
06:37:18 <mm_freak_> too bad
06:37:25 <ski_> romm : i sortof reached the point now :|
06:37:33 <elliott> not so bad, it inspired at least one copycat troll after all...
06:37:37 <romm> ski_, yeah i see that. i'll reread it.
06:37:48 <mm_freak_> Ankhers: the corresponding IRC log: https://gist.github.com/quchen/5280339
06:38:01 <mm_freak_> elliott: sorry =)
06:38:04 <elliott> oh well.
06:38:04 <mm_freak_> i just love it
06:38:18 <romm> it's interesting since this notion of "algebraic" is different than what i thought, since you mentioned "existential" before. i thought there's a relation to galois theory.
06:38:42 <monoidal> romm: if you later look at the equation List a = 1 + a * List a defining lists, and treat it as an equation on real numbers, you can solve it to get List a = 1 / (1-a) = 1 + a + a^2 + a^3 + ... which kinda makes sense, a list of elements of a is either 1 (empty list), a (single element), a^3 (three elements) etc
06:38:44 <ski_> romm : .. and apart from using algebraic laws to refactor types, one can also sometimes do even more cool things with them -- like taking the derivative of a type (wrt a type variable), as elliott alluded to
06:39:21 <romm> now i really have to go. thanks for the help!
06:39:28 <romm> i'll read it lal.
06:40:28 <ski_> have fun !
06:42:02 <Ankhers> mm_freak_: lol, that is awesome.
06:43:00 <Ankhers> About this GHCJS project. How stable is it? I do a lot of web work, and am trying to get my boss to let me start using Haskell for a project or two. I think GHCJS could be very useful to me if it is a reasonably stable position.
06:43:33 <mm_freak_> Ankhers: netwire compiles and works in GHCJS, so it can't be that unstable =)
06:44:09 <mm_freak_> i like the slides linked in the reddit thread
06:44:59 <mm_freak_> "Factoid: C# exposes more than 10 integer-like data types, none of which are those defined by (Pythagoras, 500 BC).  In the future, can we get integers right?"
06:48:21 <_mr> like.. no zero, no negative numbers?
06:48:50 <maltem> I had a look at ekmett's algebra package and noticed that he defines an algebra over a ring in a ìdualî way:   mult :: (a -> a -> r) -> (a -> r)
06:49:03 <maltem> Ö where  a  is the algebra and  r  is the base ring. Any compelling reason for this?
06:49:28 <quchen> mm_freak_: That sounds a bit FUDdy. "Haskell exposes more than ten integer-like data types, only one of which is an integer"
06:49:54 <quchen> ... well, sometimes all you need is a Word8, so it's good that exists
06:50:49 <klrr> i get some very strange errors in my code, the errors is included in the paste http://hpaste.org/85687 , any ideas how to fix this?
06:50:54 <mm_freak_> quchen: yes, but there should be at least one real integer type in every language
06:50:56 <quchen> And then there are bigint libs for all languages. I don't see what's so great about Haskell's Integer beyond the convenience of not having to import it
06:51:01 <mm_freak_> even if terribly inefficient it should be there
06:51:36 <mm_freak_> in most languages you get modular rings, but no integers
06:51:45 <mm_freak_> and then you can't even choose the modulus
06:52:10 <Trollkastel> Are signed integers even a ring?
06:52:26 <Trollkastel> I guess you are talking about unsigned ones.
06:52:27 <mm_freak_> Trollkastel: they must be signed to form a ring
06:52:45 <quchen> mm_freak_: In most languages, there's a library to do that. With the same argument you could call Haskell stupid because it has no Map type.
06:52:46 <ski_> maltem : possibly some CPS efficiency thing
06:53:02 <Trollkastel> mm_freak_: Are you sure? I thought you were talking about the quotient ring Z/nZ.
06:53:46 <mm_freak_> Trollkastel: you said integers‚Ä¶  but Int32 also forms a ring
06:54:05 <mm_freak_> in fact the ring is equivalent to Word32, except that you use other representants of the residue classes
06:54:06 <quchen> klrr: Prepending error messages makes all the line references in the error wrong ;-( Maybe paste the code first, and then add the error as an annotation?
06:54:26 <klrr> solve them no problem :)
06:54:29 <klrr> solved*
06:54:30 <klrr> :)
06:54:36 <quchen> Nice :-)
06:54:36 <Trollkastel> mm_freak_: Oh. That is nice to know. I did not know Int(whatever) also formed a ring.
06:54:56 <Trollkastel> mm_freak_: The case for Word(whatever) is of course obvious.
06:54:59 <mm_freak_> quchen: i think integers are sufficiently fundamental to be a feature included in either the language or the base/standard library
06:55:07 <klrr> m writting a scheme irc bot in haskell :DDDDDDDDDDDDDDD !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
06:55:24 <mm_freak_> Trollkastel: technically there is no difference between Int32 and Word32
06:55:35 <no-n[8]> wouldn't that be a haskell irc bot in haskell?
06:55:43 <aristid> mm_freak_: one being signed and one unsigned is no difference?
06:55:53 <mm_freak_> (-1 :: Int32) and (0xFFFFFFFF :: Word32) have the same binary representation
06:56:07 <aristid> > -1 :: Word32
06:56:09 <lambdabot>   4294967295
06:56:16 <aristid> :>
06:56:31 <quchen> mm_freak_: I don't know. Computers aren't Turing machines after all. For finite states, Integers aren't really fundamental.
06:56:37 <maltem> ski_, I'm not convinced yet that this is actually efficient :)
06:56:47 <`nand`> > (-1) + 1 :: Word32
06:56:48 <lambdabot>   0
06:57:15 <mm_freak_> also Word32 has a multiplicative subgroup, where 2863311531 represents 1/3
06:57:26 <mm_freak_> > 15 * 2863311531 :: Word32
06:57:28 <lambdabot>   5
06:57:38 <`nand`> neat
06:57:47 <`nand`> > 2863311531^2 :: Word32
06:57:49 <lambdabot>   954437177
06:57:57 <mm_freak_> that's 1/9 =)
06:57:59 <`nand`> > 954437177 * 90
06:58:00 <lambdabot>   85899345930
06:58:01 <`nand`> err
06:58:04 <`nand`> > 954437177 * 90 :: Word32 -- :)
06:58:06 <lambdabot>   10
06:58:19 <`nand`> up to some limit, presumably
06:58:23 <monoidal> sigfpe has an article related to this: http://blog.sigfpe.com/2010/05/optimising-pointer-subtraction-with-2.html
06:58:27 <arkeet> any odd number has an inverse.
06:58:28 <mm_freak_> no limit, but only for odd numbers
06:58:34 <`nand`> I mean
06:58:37 <arkeet> (being coprime to 2^32)
06:58:47 <`nand`> there must be some smallest fraction that can be represented this way in a Word32
06:58:59 <arkeet> small?
06:59:06 <arkeet> what ordering?
06:59:06 <mm_freak_> `nand`: what do you mean?  2863311531 represents a lot of fractions
06:59:20 <arkeet> Word32 doesn't *really* have an ordering.
06:59:21 <`nand`> ah
06:59:28 <arkeet> well, integers mod 2^32 don't.
06:59:51 <`nand`> so I guess what I was really saying is that there's a limit to the number of distinct pairs that multiply to ‚Äò1‚Äô
07:00:17 <`nand`> but that's obvious
07:00:24 <arkeet> of course. any element with an inverse has a unique inverse.
07:00:56 <mm_freak_> for example 2863311531 also represents 1431655769/11
07:01:04 <arkeet> > product [1,3..255] :: Word8
07:01:06 <lambdabot>   1
07:01:16 <mm_freak_> > 11/1431655769 * 2863311531 :: Word32
07:01:18 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Word.Word32)
07:01:18 <lambdabot>    arising from a use...
07:01:26 <arkeet> uh
07:01:28 <mm_freak_> uh, of course
07:01:48 <mm_freak_> 11/1431655769 is of course 3 =)
07:02:07 <arkeet> > fromInteger (product [1,3..255]) :: Word8
07:02:09 <lambdabot>   1
07:02:10 <arkeet> hm
07:02:12 <Trollkastel> Does it make sense to define a rational type whose numerator and denominator do not come from an integral domain?
07:02:21 <mm_freak_> arkeet: that's to be expected
07:02:22 <arkeet> >length [1,3..255]
07:02:26 <arkeet> > length [1,3..255]
07:02:27 <arkeet> it is?
07:02:28 <lambdabot>   128
07:02:35 <arkeet> I would have expected -1.
07:02:40 <arkeet> maybe I'm not thinking straight.
07:02:52 <arkeet> most of the elements cancel in pairs, except for 1 and -1.
07:02:55 <arkeet> wait.
07:02:59 <arkeet> duh.
07:03:17 <arkeet> Trollkastel: you need some restriction on the denominators if you want something nontrivial.
07:03:31 <arkeet> Trollkastel: you don't want to divide by a zero divisor.
07:03:41 <arkeet> (just like how you don't want to divide by 0 in an integral domain.)
07:03:48 <arkeet> see: "total ring of fractions"
07:03:56 <`nand`> maybe something like Ratio (Complex Integer) vs Complex (Ratio Integer)
07:04:02 <Trollkastel> arkeet: Yeah, that is what I expected, but for some reason Haskell's standard library seems to think it makes sense to define Ratios for arbitrary Integrals.
07:04:17 <arkeet> well, Integral things are supposed to behave like Integer.
07:04:23 <Trollkastel> arkeet: Where Integral does not mean "comes from an integral domain".
07:04:51 <`nand`> doesn't Integral technically not really mean anything?
07:05:01 <arkeet> Integral is a class, you can put anything you want in it of course.
07:05:25 <`nand`> I mean, the types sort of imply an isomorphism to Integer, but almost no instance follows that, instead opting for exceptions
07:05:34 <quchen> "Integral" is more like "Dividable".
07:05:40 <mm_freak_> Trollkastel: there are so-called number fields
07:05:48 <`nand`> all of the haskell numeric classes have basically zero rigor
07:05:51 <`nand`> or laws
07:06:15 <arkeet> haskell's numeric hierarchy isn't supposed to be an accurate reflection of math stuff.
07:06:29 <arkeet> it's just damn convenient to have.
07:06:33 <arkeet> (sometimes.)
07:06:41 <`nand`> you gotta start somewhere
07:06:46 <mm_freak_> arkeet: i often wished they were
07:06:53 <arkeet> of course.
07:07:04 <`nand`> I'd rather be able to write a hello-world program containing ‚Äú5+3‚Äù than having to first pull in a sufficiently complex generalized algebra hierarchy library
07:07:07 <quchen> arkeet: Do you know how >>= came about? It's somewhat weird to come up with and then drop "join" in favor of it
07:07:19 <`nand`> imagine what that would do to newcomers
07:07:28 <mm_freak_> the numeric type classes are pretty much written for the base-predefined types and are slowly adapting to more uses
07:08:00 <mm_freak_> until base 4.5 it wasn't even possible to define a Num instance for functional types
07:08:10 <quchen> mm_freak_: Because of Eq?
07:08:12 <arkeet> yes
07:08:14 <arkeet> and Show
07:08:43 <`nand`> ‚ÄúEvery good agda program starts with a definition of natural numbers‚Äù -somebody
07:09:06 <donri> agda has an stdlib you know
07:09:43 <`nand`> wouldn't be surprised if agda's stdlib has all manners of type trickery and costate comonad coalgebras and whatnot but no natural numbers :)
07:10:02 <mm_freak_> `nand`: but it has them =)
07:10:13 <donri> `nand`: http://www.cse.chalmers.se/~nad/repos/lib/src/Data/Nat.agda
07:10:27 <`nand`> costate comonad coalgebras => CCCs
07:10:57 <mm_freak_> "Every good Agda program needs either Emacs or a good xmodmap." ‚Äî mm_freak
07:10:59 <`nand`> donri: hmm. ‚Äòzero‚Äô and ‚Äòsuc‚Äô; couldn't have gone with ‚Äònil/suc‚Äô or ‚Äòzero/succ‚Äô?
07:11:36 <`nand`> I think I can type everything in that document except ‚â° with my .xmodmap
07:11:47 <`nand`> I have ‚âÖ though which is way cooler
07:11:49 <mm_freak_> i can type ‚â°
07:12:03 <mm_freak_> no, i like ‚â°, because it's modular congruence =)
07:12:07 <donri> `nand`: https://github.com/edwinb/Idris-dev/blob/master/lib/Prelude/Nat.idr
07:12:59 <`nand`> that definition of ‚Äòfib‚Äô can't be healthy
07:13:35 * hackagebot happstack-server 7.1.7.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.1.7.1 (JeremyShaw)
07:13:40 <elliott> I like how "Fibonacci and factorial" doesn't have the latte
07:13:40 <elliott> r
07:14:02 <`nand`> ‚ÄòGCD and LCM‚Äô is empty
07:14:24 <`nand`> guess they're still working on proving their algorithm is correct. or something. I don't know what idris people do
07:15:39 <`nand`> mm_freak_: re: your paste from ages ago which I just got round to looking at: that's really just a less general case of Typeable/Dynamic
07:15:59 <mm_freak_> `nand`: i don't know what you're talking about =)
07:16:04 <`nand`> http://hpaste.org/85686
07:16:18 <mm_freak_> oh, that's not ages ago
07:16:36 <mm_freak_> and no, it's not really Typeable/Dynamic, because the types are static
07:16:55 <mm_freak_> it's just pattern matching with ‚Ä¶  what was it called?
07:17:01 <`nand`> well
07:17:02 <mm_freak_> type refinement?
07:18:42 <`nand`> what it comes down to is observing a constructor (value-level) to know what type something has; which is not that different from looking at a TypeRep to decide how to treat something, except in the case of Dynamic an unsafeCoerce is needed because you really can't make an infinite GADT
07:19:28 <mm_freak_> `nand`: Typeable also requires unsafeCoerce
07:19:33 <mm_freak_> see the implementation of SomeException
07:20:06 <mm_freak_> no type refinement is done‚Ä¶  instead the types are manuallishly encoded as a value
07:20:32 <mm_freak_> then comes an error-prone-in-principle unsafe cast
07:20:48 <Kneiva> hi, I'm trying to use State Monad with a map, but can't understand how do I access the map after doing some stuff. Here is a paste: http://hpaste.org/85689
07:20:59 <luite> the unsafeCoerce is in cast though, not in 'user code' like SomeException
07:21:05 <mm_freak_> in fact SomeException isn't much different from Dynamic =)
07:22:24 <quchen> Kneiva: When using runState, you have to specify an inital state.
07:22:24 <`nand`> what about data Some = SomeStr String | SomeInt Int | SomeBool Bool | ... every other Haskell type -- anyhow? Is that not a form of ‚Äúdynamic dispatch based on type‚Äù?
07:23:47 <quchen> Kneiva: Also, you may find it easier to work with the API functions of State (get, put, ...) instead of using "state" manually.
07:24:45 <quchen> Kneiva: So that'll be "do { currentState <- get; let newState = f currentState; put newState; return 1 } written super explicitly
07:24:49 <hpaste> ‚Äú`nand`‚Äù annotated ‚ÄúRun-time type-based choice ("dynamic dispatch"?)‚Äù with ‚ÄúRun-time type-based choice ("dynamic dispatch"?) (annotation)‚Äù at http://hpaste.org/85686#a85692
07:25:08 <quchen> Kneiva: The short version of the above would've been "modify f >> return 1" by the way.
07:25:22 <quchen> Kneiva: But when you start off with State, using get and put was easier for me at least.
07:25:36 <`nand`> only thing I had to change was the type definition and the type signatures
07:27:06 <Kneiva> quchen: ok, thanks. I‰ll try that
07:28:29 * ski_ recalls writing `‚âÖ' for modular congruence in early school
07:28:47 <applicative> yes, same here
07:28:49 <ski_>     m
07:28:49 <ski_>   a ‚âÖ b
07:28:50 <ski_> iow
07:29:15 <ski_> (which you can then nicely chain)
07:30:06 <hpaste> Quchen annotated ‚ÄúState‚Äù with ‚ÄúState (annotation)‚Äù at http://hpaste.org/85689#a85693
07:30:07 <mm_freak_> `nand`: no, because you don't learn type information from pattern-matching
07:30:21 <mm_freak_> f (SomeInt x) = k (x+x)
07:30:31 <mm_freak_> f (SomeStr x) = k (x ++ "blah")
07:30:34 <quchen> Kneiva: The most important thing here though is that you have to specify an initial state. See above: I used the empty map.
07:30:46 <mm_freak_> `nand`: without GADTs and RankNTypes this would be a type error
07:32:14 <`nand`> I still don't see how it's different. Wouldn't the original also be a type error without GADTs and RAnkNTypes?
07:32:16 <mm_freak_> `nand`: you can do without the RankNTypes, but you need GADTs to learn types from pattern-matching
07:32:26 <Kneiva> quchen: yeah, great. now I can get forward again
07:33:04 <`nand`> can you should me an example not using RankNTypes?
07:33:18 <mm_freak_> `nand`: for example your code (assuming typos fixed) is a type error
07:33:30 <mm_freak_> `nand`: replace andThen :: (forall a. (Show a) => a -> b) -> Some a -> b
07:33:44 <mm_freak_> by: andThen :: (String -> b) -> Some a -> b
07:34:00 <mm_freak_> still works, when Some is a GADT, but not when Some is a non-G ADT
07:35:25 <indoubt> Hello.
07:35:49 <indoubt> Is haskell a future of programming?
07:36:14 <quchen> It'll last at least another ten minutes.
07:36:23 <`nand`> mm_freak_: I get the same type error with or without the GADT; unless I add a ‚Äòshow‚Äô in front of ‚Äúx + 2‚Äù in which case I get the same output from both versions of the program
07:36:30 <`nand`> I'm not seeing it
07:36:59 * ski_ . o O ( `  m       n     [m,n]' )
07:37:00 * ski_ . o O ( `a ‚âÖ b ‚àß b ‚âÖ c ‚áí a ‚âÖ c' )
07:37:02 <quchen> indoubt: It's hard to guess the future. Haskell has centuries of research behind it, so it's unlikely ideas used by it get lost in the future.
07:37:41 <elliott> ski_: nice two-line thought
07:37:58 <indoubt> quchen: Do you mean category theory by "centuries of research"?
07:38:07 * `nand` .oO( My thoughts are all simple one-liners )
07:38:24 <quchen> How do you guys think like that anyway?
07:38:34 <quchen> Everyone seems to have thinking bubbles around here.
07:38:49 <`nand`> Haskell has addition, it's based on thousands of years of arithmetic!
07:38:50 <Botje> you get them after you publish your first monad tutorial
07:38:51 <ski_> `nand` : if it's "dynamic dispatch", it's surely based on value (constructor), not on type
07:39:04 <finishingmove> can you do
07:39:09 <quchen> indoubt: No, I mean math and logic in general.
07:39:13 <finishingmove> prefix addition in haskell ?
07:39:24 <Botje> finishingmove: just write (+) x y
07:39:32 <indoubt> quchen: Ah, it's common thing in programming languages.
07:39:42 <finishingmove> Botje, cool!
07:40:11 * elliott isn't sure the research used by Haskell goes back centuries...
07:40:21 <indoubt> I fear that haskell can be fallacy of ~decade or bright future. Can't decide which.
07:40:21 <quchen> indoubt: Not really. Most languages are ad-hoc descriptions of what the lower end of the computer should do.
07:40:44 <elliott> indoubt: Haskell has been around for more than a decade, at least
07:40:51 <Clint> the lower end
07:40:58 <indoubt> elliott: Right, 2 decades.
07:41:12 <elliott> (it's older than Java, in fact)
07:41:17 <ski_> quchen : i guess it might be spreading
07:41:33 <`nand`> look at #haskell's popularity graphs! it /must/ be exponential!
07:41:56 <indoubt> `nand`: Popularity is nothing realy, look at popularity of PHP.
07:42:28 <indoubt> But if you remember APL, it looked like future back then.
07:42:38 <indoubt> But now nobody even remembers it.
07:43:23 <`nand`> perl sure looks as complicated as it did
07:43:29 <`nand`> may be a spiritual successor in that regard
07:43:37 <elliott> the APl descendent K is still used in finance, aiui
07:43:49 <Botje> indoubt: why are you asking about haskell's future? are you interested in learning it but not sure if there's a future in haskell programming _jobs_ ?
07:44:47 <`nand`> rest assured, haskell will continue to have a future for as long as you use it
07:45:06 <indoubt> `nand`: Agreed.
07:45:15 * indoubt uses J and APL.
07:46:00 <elliott> I hope Haskell isn't the future of programming, because it means the future won't be any better than 2013. the question is whether Haskell is the present of programming.
07:46:02 <indoubt> Botje: No, i'm already know haskell. Just wondering if it was right idea.
07:46:29 <`nand`> I'd learn APL but my keyboard only has so many keys
07:46:38 <aristid> clearly LISP is the future of programming.
07:47:10 <`nand`> elliott: I guess the question is ‚Äúare skills acquired by learning Haskell applicable to the future of programming‚Äù
07:47:20 <indoubt> `nand`: Dyalog APL is a great tool with very convenient hotkeys, it's so natural.
07:47:31 <elliott> anyway, I doubt anyone can answer a question as vague as "is Haskell right?"
07:47:37 <`nand`> indoubt: J is only ASCII-based, right?
07:47:38 <elliott> especially iven the inherent bias of a channel called #haskell
07:47:40 <elliott> *given
07:47:42 <`nand`> how close is it to APL?
07:47:43 <indoubt> `nand`: Yep.
07:47:47 <quchen> aristid: Lisp isn't the future of anything. It's timeless.
07:48:15 <aristid> quchen: in my eyes it's the past.
07:48:15 <`nand`> Lisp is.
07:48:25 <indoubt> `nand`: Iverson created it, it's sequel of APL.
07:48:37 <indoubt> More powerfull, more modern.
07:49:34 <indoubt> (Iverson - creator of APL.)
07:50:04 <indoubt> elliott: How do you think? Is Haskell right?
07:50:49 <`nand`> I enjoy using Haskell more so than I enjoy using other languages I've enjoyed using in the past
07:50:53 <elliott> I'm not sure what right is. I think it moves in the right direction, compared to most mainstream languages; otherwise I wouldn't be here
07:51:02 <`nand`> that's all I can say on the matter
07:51:40 <indoubt> http://www.lambdassociates.org/studies/study01.htm Look.
07:51:43 <`nand`> that does not exclude the possibility of there being languages I have yet to use that I will enjoy using more than Haskell. I simply haven't come across them yet
07:52:29 <`nand`> ‚ÄúQi type theory‚Äù -> but can it explain how Qi's scoring works?
07:52:45 <indoubt> elliott `nand`, Thank you guys for honest answers.
07:54:47 <indoubt> Currently i'm reading "Conceptual mathematics" and i'm enjoying it. Can you recommend next book to read to become better haskell programmer?
07:55:23 <jmcarthur> when somebody says "X is the language of the future" they really just mean "there are some aspects of X which I believe will be copied in other languages for a long time"
07:56:24 <nodoubt> I'm mean not just some book about programming and algorithms but about underlying math like in "Conceptual mathematics".
07:57:08 <aristid> jmcarthur: sadly many new languages seem to ignore _all_ "academic" feature
07:57:17 * aristid looks at "go"
07:58:07 <bitonic> aristid: there‚Äôs some value in creating something that you believe will make people produce more without having to educate them :P
07:58:17 <bitonic> or actually limiting them so they don‚Äôt mess up
07:58:28 <nodoubt> aristid: What academic features you think new language should copy?
07:58:32 <jmcarthur> aristid: i think that's not necessarily intentional
07:58:58 <bitonic> aristid: I mean in the end Go has the explicit goal of being simple and unsurprising
07:59:02 <aristid> nodoubt: SUM TYPES
07:59:31 <`nand`> higher order types
07:59:32 <bitonic> aristid: inheritance!  ehe.
07:59:42 <bitonic> `nand`: java generics!
07:59:42 <aristid> bitonic: *twitch*
07:59:47 <jmcarthur> i think purity is the most easily ignored feature that i wish people would pay more attention to
08:00:04 <`nand`> comonads!
08:00:20 <jmcarthur> and it *is* easily ignored because its presentation is usually "well, you can't do this, or this, or this. oh, that? nope, you can't do that either"
08:00:25 <bitonic> comonads are hardly a ‚Äòlanguage feature‚Äô
08:00:30 <nodoubt> aristid: Nah, it's useless. UNION TYPES
08:01:21 <elliott> union types and sum types are not the same thing
08:01:36 <jmcarthur> that is, i think a lot of people think of purity as being a lack of features rather than a feature itself
08:01:49 <aristid> elliott: well, discriminated union and sum type are the same, no?
08:02:01 <fryguybob> The feature have is equational reasoning.
08:02:04 <aristid> i don't think set-like union types make a lot of sense for programming languages
08:02:10 <jmcarthur> fryguybob: yeah
08:02:18 <quchen> The current trend seems to be creating languages that smooth out the mess of C and friends, rather than inventing something new. It's not a bad thing and certainly boosts productivity, but it doesn't lead to revolution.
08:02:21 <jmcarthur> maybe that's what i should say instead of "purity"
08:02:32 <quchen> It's like evolution. Slow and small.
08:02:33 <aristid> jmcarthur: but yeah purity is very important too
08:02:41 <aristid> jmcarthur: i'm just very pessimistic on people accepting it
08:02:48 <aristid> jmcarthur: meanwhile sum types... why the fuck not?
08:03:01 <quchen> aristid: What's so good about sum types?
08:03:13 <elliott> aristid: right, keyword discriminated.
08:03:20 <bitonic> aristid: a lot of languages that are getting attention now have a focus on immutability
08:03:20 <jmcarthur> aristid: because it is a common believe that inheritance is a good enough alternative :(
08:03:24 <jmcarthur> *velief
08:03:26 <jmcarthur> **belief
08:03:30 <nodoubt> I think sum types have a large overlapping of functionality with product types and cause inelegance and inefficiency.
08:03:41 <jmcarthur> nodoubt: ?
08:03:42 <bitonic> aristid: Scala, Erlang, clojure...  Erlang doesn‚Äôt even have mutable references
08:03:43 <elliott> nodoubt: I have no idea what you mean.
08:03:51 <elliott> what is the overlap? they are dual concepts.
08:03:54 <elliott> what is the inefficiency?
08:04:05 <bitonic> they‚Äôre the opposite of overlapped
08:04:07 <jmcarthur> yeah, not only do they *not* overlap, they actually complement
08:04:32 <bitonic> OK nodoubt probably got the point :P
08:04:42 <jmcarthur> i think he got the point
08:04:50 <jmcarthur>     don't hit me
08:05:19 <nodoubt> It is quite evident that sum types were orginated from some branch of mathematics.
08:05:26 <nodoubt> In those mathematical context, there are no nominal (named) product types.
08:05:39 <nodoubt> All we have are Cartesian products. Cartesian products have no constructors (or type tags) in them.
08:06:02 <bitonic> nodoubt: yes, product types are pretty much like cartesian products.  sum types are something else.
08:06:27 <quchen> ... like direct sums?
08:06:47 <sipa> nodoubt: cartesian product type = tuples ?
08:07:44 <jmcarthur> haskell tuples aren't really cartesian products
08:08:07 <flebron> wohooo
08:08:17 <jmcarthur> unboxed tuples maybe, but i haven't thought about it much
08:08:20 <flebron> finally got that bastard. http://www.spoj.com/ranks/SUMITR/lang=HASK
08:08:22 <bitonic> jmcarthur: well we‚Äôre in different domains but it‚Äôs a similar concept
08:08:33 <elliott> nodoubt: you should look into type theory.
08:08:36 <elliott> or category theory. or whatever.
08:08:37 <flebron> the problem was to solve http://www.spoj.com/problems/SUMITR/ in less than 256 bytes of haskell
08:08:44 <elliott> then you'll see lots of tagged sum and product types.
08:08:46 <cmccann> tuples are morally equivalent to a cartesian product up to appropriate hand-waving
08:08:57 <cmccann> and that's really what matters
08:09:01 <elliott> set theory is weird.
08:09:09 <nodoubt> elliott: Yeah, i'm slowly getting into it.
08:09:13 <jmcarthur> cmccann: that's true
08:09:24 <nodoubt> elliott: So can you answer my question about the book?
08:09:25 <Zenol> Hi guys. I have an efficiency issue. Could you help me to understand what's happpening?
08:09:26 <flebron> my first haskell golf :)
08:09:30 <jmcarthur> Zenol: just ask
08:09:37 <bitonic> nodoubt: you could express sum types as `A + B = ({0} √ó A) ‚à™ ({1} √ó B)' if you like set theory
08:09:57 <bitonic> it‚Äôs union + a way to distinguish where the elements came from
08:10:36 <Zenol> I run profiling and 75%/80% of time/memoryalloc is spend in the fuction stringToInt s = (read s :: Integer) typed [String] ->Integer
08:10:48 <elliott> nodoubt: I'm unsure what kind of book you're after, honestly :P
08:11:12 <Zenol> Does it mean that it's really swaping from String numbers to Integer that is costly, or it's computing the string s wich is costly?
08:11:13 <nodoubt> elliott: Have you read Conceeptual Mathematics?
08:11:17 <hpaste> natnayr pasted ‚Äútotals‚Äù at http://hpaste.org/85695
08:11:32 <parcs> in a -> b, is b in the covariant or contravariant position?
08:11:39 <jmcarthur> parcs: covariant
08:11:58 <Zenol> Sorry, not [String] but String. The function is mapped over a list of integer writen as strings.
08:12:37 <cmccann> parcs: left of a function arrow is contravariant position, doubly contravariant = covariant
08:12:42 <elliott> nodoubt: I haven't
08:12:43 <jmcarthur> parcs: rule of thumb: if you can write an fmap over that type variable, it's covariant. if you can write contramap :: (b -> a) -> f a -> f b over that type variable, it's contravariant (all assuming you arrange for the type variable to be in the right place and such)
08:13:17 <nodoubt> elliott: But what did you read about category theory?
08:13:19 <cmccann> (co/contra)-variant argument position is meaningful even with monomorphic types though
08:13:25 <flebron> Zenol, have you tried ByteString?
08:13:40 <flebron> (Specifically, Data.ByteString.Char8.readInteger)
08:13:47 <jmcarthur> cmccann: yeah. the rule of thumb generalizes if you just think about what *if* you abstracted over it
08:13:54 <elliott> nodoubt: well, what I said about sum types is just referring to coproducts. I don't know all that much category theory, certainly less than I'd like to.
08:13:54 * nodoubt looking for good book about category theory.
08:14:23 <cmccann> jmcarthur: right, just wanted to clarify
08:14:23 <aristid> ok, i had no internet connection for 6 minutes
08:14:27 <Zenol> flebron : Nop, i'll try.
08:14:32 <aristid> meanwhile nodoubt claims that sum types are _inelegant_
08:14:36 <flebron> As far as I know, in GHC, Strings are literally [Char], there's no optimization. You'll get like 12 bytes per element. ByteStrings are what you'd expect :)
08:14:44 <nodoubt> elliott: Oh, then read Conceptual Mathematics, it's really good and explains like you a five year old.
08:14:52 <Zenol> (Nb : I'm working with huger number like 10^90)
08:15:33 <cmccann> jmcarthur: since type variables can end up being invariant, but a single monomorphic type can't
08:15:41 <flebron> Zenol: Let me guess, programming competition?
08:15:55 <cmccann> :t (genericLength, genericTake)
08:15:57 <lambdabot> (Integral i1, Num i) => ([b] -> i, i1 -> [a] -> [a])
08:16:08 <cmccann> note that Integral and Num are used depending on co/contra-variance :]
08:17:15 <jmcarthur> cmccann: i am not sure i understand the dependency you are trying to point out
08:17:23 <aristid> quchen: you asked for an explanation why sum types are nice. consider the common alternatives: (a) a C union with a tag. very nice: as an implementation. but directly using that? (b) just a product of a bunch of optional fields. as kamatsu told me that, counts as "type safe", but... you can fill more than one field, for example. (c) inheritance and use the visitor pattern or something like that to deal with
08:17:26 <aristid> the fact that you don't simply have sum types and pattern matching.
08:17:33 <jmcarthur> cmccann: you mean *how* they are used?
08:17:38 <cmccann> jmcarthur: toInteger vs. fromInteger specifically
08:17:44 <jmcarthur> ah, yeah
08:18:43 <aristid> so maybe i'm overstating the importance of sum types. *shrug* i think they're nice and i'm annoyed that most new languages ignore them.
08:18:45 <cmccann> so a type like "(Integral a) => Foo -> Bar -> a" is not terribly useful
08:19:00 <natnayr> whoopse, took a bath, but i pasted this.. natnayr pasted ‚Äútotals‚Äù at http://hpaste.org/85695
08:19:17 <cmccann> aristid: legit sum types are on my top 5 list of painfully obvious and useful things that many languages lack for no good reason
08:19:18 <quchen> aristid: I agree they're useful, but I don't get what's so great about them Either‚Ñ¢
08:19:42 <quchen> cmccann: So what's your shot at "sum types are amazing"?
08:20:07 <jmcarthur> it's difficult to explain such a fundamental piece of my computer science vocabulary...
08:20:12 <mm_freak_> `nand`: sorry, i forgot the 'show'
08:20:34 <cmccann> quchen: that I find myself thinking "this would be much cleaner code with a sum type" on a nearly daily basis in C#
08:20:38 <mm_freak_> `nand`: btw, your existential type is fully equivalent to my GADT
08:21:10 <cmccann> every curly-brace language with a switch/case construct really should use sum types a la Haskell's case instead
08:21:16 <Zenol> flebron > Yap :)
08:21:19 <quchen> cmccann: How are sum types (let's say Either) so different from C unions?
08:21:24 <aristid> cmccann: you mean pattern matching?
08:21:24 <Zenol> flebron > Google code jam.
08:21:38 <aristid> quchen: C unions don't have a tag built-in.
08:21:42 * flebron can't participate :(
08:21:52 <ab9rf> c unions let types have unprotected sex with one another
08:21:57 <cmccann> aristid: that would be nice, but even something less powerful that could distinguish sum type cases
08:21:57 <mm_freak_> `nand`: sorry, not fully, but you get an equivalent of type refinement
08:22:11 <aristid> quchen: so you need to add the tag yourself and maintain its correctness by hand. which is extremely error prone. hence most C programmers don't even use them where it would make sense.
08:22:15 <jmcarthur> quchen: checking the tag in a tagged union doesn't tell the compiler anything, for one
08:22:23 <aristid> cmccann: i.e. not the visitor pattern?
08:22:28 <mm_freak_> what's a popular choice for haskell text editors for complete programming beginners (i.e. not emacs/vim) on windows?
08:22:36 <ab9rf> and errors in using c unions are extremely hard to debug
08:22:47 <ab9rf> because you don't get a runtime error, you just get arbitrarily weird behavior
08:22:50 <cmccann> pf, the visitor pattern is a horrible baroque mess that shouldn't be necessary at all
08:22:59 <cmccann> mm_freak_: notepad++
08:23:00 <quchen> aristid, jmcarthur: By tag you mean something like "Hey, I'm a Left"?
08:23:08 <mm_freak_> thanks, anything else?
08:23:08 <ab9rf> mm_freak_: i used notepad++
08:23:12 <jmcarthur> i also can think of only one time i wanted an untagged union, ever
08:23:14 <jmcarthur> quchen: yes
08:23:15 <ab9rf> still do
08:23:24 <quchen> mm_freak_: I love Sublime but it's not free
08:23:35 <mm_freak_> it must be at least open source
08:23:36 <aristid> jmcarthur: you wanted an untagged union, ever? what for?
08:23:53 <aristid> jmcarthur: oh, maybe to force alignment?
08:23:57 <mm_freak_> ideally BSD- or GPL-licensed
08:24:16 <aristid> fortunately c++11 has alignment directives now, and i bet c99 also has something like that
08:24:22 <fryguybob> mm_freak_: Notepad++
08:24:24 <quchen> jmcarthur: Then I see your point. Although I haven't written enough C++ since I started using Haskell, so the "oh man I wish I had that" feeling didn't occur yet.
08:24:27 <ab9rf> cmccann: i've never liked the visitor pattern, it seems like a kludge to get around limitations of languages that would be better solved by fixing the language
08:24:37 <aristid> mm_freak_: hmm maybe eclipse?
08:24:43 <aristid> mm_freak_: with eclipsefp
08:24:51 <mm_freak_> too complicated
08:24:53 <fryguybob> @karma notepad
08:24:53 <lambdabot> notepad has a karma of 42
08:24:56 <fryguybob> See!
08:25:01 <ab9rf> eclispefp is ok, but it's very heavy
08:25:02 <quchen> fryguybob: Haha
08:25:07 <jmcarthur> aristid: it was essentially a byte packing thing, yeah
08:25:11 <cmccann> ab9rf: it's a hack to replace recursing over algebraic data types basically, that's really it
08:25:14 <mm_freak_> i need an editor with the lowest possible barrier to entry
08:25:22 <bitonic> mm_freak_: emacs
08:25:25 <cmccann> mm_freak_: then notepad++ is pretty much it
08:25:32 <jmcarthur> mm_freak_: what OS?
08:25:35 <fryguybob> mm_freak_: The only issue is out of the box it has tabs.
08:25:37 <mm_freak_> bitonic: for non-nerds
08:25:38 <aristid> i see a lot of people using notepad++
08:25:40 <ab9rf> mm_freak_: notepad++ is extremely easy to use.
08:25:42 <aristid> jmcarthur: windows he said
08:25:44 <jmcarthur> ah
08:25:45 <mm_freak_> jmcarthur: windows
08:25:51 <cmccann> I've never heard of anything else that isn't vim, emacas, or a fancy IDE used for haskell on windows
08:25:56 <mm_freak_> because i have no experience with windows
08:26:04 <ab9rf> mm_freak_: one warning: if you use notepad++ for haskell, go into the languages tab and set "replace tabs with spaces" or whatever it
08:26:05 <neutrino_> em editor is good
08:26:08 <neutrino_> for windows
08:26:13 <jmcarthur> i like sublime
08:26:18 <aristid> mm_freak_: and presumably you also have no experience with non-fancy editors?
08:26:25 <aristid> ah yeah i bet sublime text isn't hard to use
08:26:26 <jmcarthur> it's very approachable, and very powerful, and very pretty
08:26:31 <mm_freak_> aristid: i'm an emacs user myself
08:26:35 <cmccann> notepad++ is basically a user-friendly wrapper around Scintilla if memory serves me
08:26:36 <osfameron> textpad also
08:26:40 <quchen> jmcarthur: Shame there's no mouse click API though :-(
08:26:41 <aristid> mm_freak_: counts as fancy.
08:26:55 <mm_freak_> aristid: in a way, yeah
08:26:56 <osfameron> but isn't sublime text *usable* in a non-fancy way too?
08:26:56 <jmcarthur> quchen: ha. that didn't even occur to me
08:27:09 <aristid> mm_freak_: hey, how often do you feel the urge to write an editor that doesn't have the annoying parts of emacs? :D
08:27:10 <cmccann> which means notepad++ is the same editor widget as a bunch of linux code editors
08:27:12 <jmcarthur> osfameron: yes, apart from lacking a gigantic toolbar
08:27:21 <mm_freak_> aristid: like what?
08:27:37 <quchen> jmcarthur: Otherwise I would've coded this a long time ago: http://www.sublimetext.com/forum/viewtopic.php?f=4&t=9821
08:27:48 <bitonic> mm_freak_: joke aside, emacs is actually much much more approachable than people believe imo
08:27:52 <aristid> mm_freak_: like how it likes to lock up sometimes due to bugs in components, in combination with single threadedness
08:28:16 <aristid> mm_freak_: maybe i use more experimental components to make that problem more frequent
08:28:28 <mm_freak_> probably
08:28:31 <twopoint718> Is there a simple function that does this:
08:28:31 <jmcarthur> quchen: as an intermediate step between text-only and graphical languages, i've always wanted a textual language that supports blocks of code in 2d space
08:28:32 <aristid> but then, the worst offender in that regard, TRAMP, isn't experimental.
08:28:39 <twopoint718> > let twin n = (n, n)
08:28:40 <lambdabot>   not an expression: `let twin n = (n, n)'
08:28:44 <aristid> mm_freak_: i also want a TRAMP that doesn't suck
08:28:45 <jmcarthur> quchen: commented included, of course
08:28:47 <bitonic> emacs slowly evolves anyway.  we even got dynamic scoping now!  proper multi threadedness is going to come.
08:28:47 <mm_freak_> emacs is far from perfect, but it's the best editor i know of for my personal taste
08:28:48 <jmcarthur> *comments
08:28:58 <osfameron> bitonic: it took me 3 attempts at the emacs tutorial to get through it without wanting to kill everything
08:29:00 <mm_freak_> anyway, i didn't really want to start an editor war
08:29:01 <bitonic> *lexical scoping
08:29:01 <neutrino_> what's TRAMP?
08:29:08 <bitonic> osfameron: that‚Äôs weird.
08:29:09 <quchen> jmcarthur: My next wish would be an undo slider so I can scroll through my changes.
08:29:15 <jmcarthur> neutrino_: edit remote files
08:29:19 <mm_freak_> seems like most people prefer notepad++ or sublime
08:29:20 <`nand`> yi is the best editor!1
08:29:25 <jmcarthur> quchen: such things exist, i think
08:29:33 <osfameron> bitonic: I think it was largely a question of terminology.  "Yank" and "kill" and "meta"
08:29:41 <bitonic> osfameron: yeah that‚Äôs historical baggage
08:29:43 <cmccann> mm_freak_: notepad++ is what I see used most often in general
08:29:45 <neutrino_> jmcarthur: via ssh?
08:29:46 <osfameron> but those things really put you off if you're coming from Windows
08:29:51 <jmcarthur> quchen: also, check out vim's undo tree (or the emacs extension that copies it)
08:29:59 <jmcarthur> neutrino_: it supports ssh
08:30:02 <cmccann> mm_freak_: note that .NET development is my day job
08:30:04 <mm_freak_> so notepad++ (knowing that it's free) is what i will recommend
08:30:15 <bitonic> osfameron: but cmon that‚Äôs not something that hinders usage imo...
08:30:18 <jmcarthur> neutrino_: it can be nicer than running a remote X app, at least :)
08:30:21 <twopoint718> I'm writing "square = uncurry (*) . twin"
08:30:22 <mm_freak_> cmccann: you prefer notepad++ over VS?
08:30:39 <`nand`> I use vim for C#.NET
08:30:41 <osfameron> bitonic: I didn't say it was unusable.  You made a comment about it being *approachable* and my point stands :D
08:30:43 <cmccann> mm_freak_: for anything that isn't directly and fully supported by VS
08:31:02 <mm_freak_> ok, thanks all for your feedback =)
08:31:06 <jmcarthur> twopoint718: join
08:31:15 <jmcarthur> > join (*) 4
08:31:16 <neutrino_> i just use vim with its remote file editing option
08:31:17 <lambdabot>   16
08:31:19 <neutrino_> or ssh
08:31:27 <quchen> jmcarthur: I always thought about an undo tree, bit didn't know it existed. Neat.
08:31:35 <cmccann> mm_freak_: but even for stuff like HTML I often find notepad++ more pleasant than VS with its complicated heavyweight crap
08:31:36 <aristid> neutrino_: opening files via ssh and other protocols
08:31:40 <bitonic> osfameron: OK maybe the weird terminology makes it a bit less approachable
08:31:54 <jmcarthur> quchen: it makes way more sense than emacs' default undo
08:32:16 <jmcarthur> quchen: and both are more powerful than the common undo
08:32:27 <bitonic> ehe.  emacs‚Äô default undo is fun.
08:32:27 <mm_freak_> the reason i ask is that i need a useful yet low-barrier-to-entry-for-complete-programming-beginners editor to recommend for windows players
08:32:30 <fryguybob> mm_freak_: Oddly enough the feature that keeps me using notepad++ is I can open files from a command line into a new tab.
08:32:41 <twopoint718> jmcarthur: Thanks!
08:32:43 <neutrino_> mm_freak_: as i said, emeditor
08:32:53 <neutrino_> but notepad++ is a good free one
08:32:59 <jmcarthur> bitonic: that moment when you undo a bunch of junk, make a change, and then realize you actually wanted to undo one or two more steps...
08:33:10 <cmccann> mm_freak_: of course I'm possibly biased since notepad++ is a slightly more user-friendly version of the code editor I use on linux, heh
08:33:19 <ski_> fryguybob : hmm .. i think `emacsclient' can do something like that
08:33:19 <quchen> jmcarthur: It's like a git commit on every key stroke :D
08:33:25 <`nand`> I use gvim on player, but I hate it
08:33:33 <hamid> :t (.:)
08:33:34 <`nand`> I eventually installed a virtual machine to get my usual environment
08:33:35 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:33:35 <mm_freak_> neutrino_: free (as in BSD/GPL[4~) is a requirement
08:33:35 <jmcarthur> quchen: that sounds more like an undo tree
08:33:37 <`nand`> err
08:33:39 <`nand`> gvim on windows*
08:33:39 <neutrino_> why do you hate gvim?
08:33:42 <bitonic> jmcarthur: yeah.  you do get the hang of it at some point.  but undo-tree is better yes
08:33:43 <`nand`> don't know how that typo came about
08:33:47 <neutrino_> mm_freak_: isn't notepad++ free like that?
08:33:47 <aristid> fryguybob: emacsclient.
08:33:55 <`nand`> neutrino_: probably due to lack of a normal terminal
08:33:59 <`nand`> with normal fonts
08:34:03 <mm_freak_> neutrino_: yes, it is‚Ä¶  it's what i'll probably recommend =)
08:34:03 <neutrino_> `nand`: right
08:34:12 <neutrino_> `nand`: i hate the non-terminalness of windows
08:34:23 <niteria> hamid: .: is 2arg . for (-> a) functor
08:34:29 <bitonic> although [undo-tree] has been acting weirdly lately
08:34:39 <cmccann> neutrino_: I've yet to find a decent alternative either :[
08:34:51 <`nand`> currently I used notepad++ for file editing on windows, but I don't do any development with it
08:34:51 <neutrino_> cmccann: ubuntu
08:35:01 <`nand`> just the routine maintenance one has to do throughout a normal computing session
08:35:07 <hamid> niteria, aha ok
08:35:11 <mm_freak_> is there anything about windows 8 i should keep in mind that may make writing haskell feel different from windows XP?
08:35:13 * cmccann has tried at least 3 or 4 different terminal window applications on windows and none are really satisfactory
08:35:32 <cmccann> neutrino_: har har, I use ubuntu at home but windows at the day job :P
08:35:34 <`nand`> mm_freak_: you may have to instruct people on how to disable metro
08:35:42 <mm_freak_> `nand`: what's that?
08:36:09 <neutrino_> cmccann: i haven't had to use non-ubuntu in my day job for 5 years now..
08:36:22 <`nand`> mm_freak_: the new UI that comes with windows 8 and essentially turns the OS into a mobile phone-like environment
08:36:27 <Zenol> wow, it seams to really improve speed O.o
08:36:29 <mm_freak_> the last windows i used was windows 2000, so please bear with me =)
08:36:32 <neutrino_> cmccann: and nowadays i can just refuse to work if they insist (usually means it'll be a crap job too)
08:36:37 <neutrino_> mm_freak_: heh, same here
08:36:39 <`nand`> mm_freak_: you haven't missed much
08:36:43 <wting> How do I get logBase to return a decimal class / fix floating point errors? e.g. logBase 10 1000 = 2.99999999996
08:36:47 <mm_freak_> i know =)
08:36:56 <flebron> Zenol: Fast enough? :)
08:37:00 <`nand`> mm_freak_: in the meantime, every other windows version has been utterly crap even by windows standards
08:37:10 <mm_freak_> wting: basically impossible, unless you use some exact type like CReal
08:37:11 <cmccann> I dunno, win7 was pretty nice, they were almost catching up to the usability that ubuntu and OSX had at the time
08:37:19 <mm_freak_> > logBase 10 1000 :: CReal
08:37:21 <lambdabot>   3.0
08:37:29 <`nand`> :t logBase
08:37:30 <lambdabot> Floating a => a -> a -> a
08:37:31 <bitonic> wting: well, ‚Äòfix floating point errors‚Äô is a bit broad.  you can use ‚Äòround‚Äô
08:37:33 <`nand`> ah
08:37:49 <`nand`> Floating, you're pretty short on options
08:38:10 <`nand`> apart from computable reals and symbolic arithmetic I don't know any other options
08:38:12 <wting> thx, round sounds like the easiest solution
08:38:36 <bitonic> wting: it depends on what you are doing
08:38:48 <mm_freak_> `nand`: logBase is easy to explain:  logBase = flip (.) log . flip (/) log
08:38:50 <mm_freak_> =P
08:39:16 <cmccann> neutrino_: well, I actually like C# as far as mainstream languages go and the pay is decent so eh
08:39:21 <mm_freak_> did i do this right?  it looks pretty, but it looks wrong‚Ä¶
08:39:31 <bitonic> well they try hard to innovate in C#
08:39:32 * geekosaur suspects that can be refactored into even more gibberish
08:39:34 <mm_freak_> > (flip (.) log . flip (/) log) 10 1000
08:39:35 <neutrino_> cmccann: oh, yeah
08:39:36 <lambdabot>   5.174256719049069
08:39:39 <neutrino_> cmccann: i can see that
08:39:41 <mm_freak_> ok, wrong
08:39:52 <neutrino_> cmccann: one thing that's always been stopping me from getting into C# was.. windows
08:39:57 <niteria> > ((*2) .: max) 10 20
08:39:59 <lambdabot>   40
08:40:21 <cmccann> neutrino_: I've been using linux on my home desktop and doing C# .NET dev at the day job both for like a decade or so
08:40:25 <cmccann> kinda used to it by now
08:40:34 <`nand`> that's (.log) . (/log) or \x -> (x/log) . log or \x y -> log ((x/log) y)
08:40:42 <`nand`> in case that helps you find the correct form
08:40:55 <neutrino_> i do so much that requires the linux env, i just don't know where to start when i'm on windows
08:41:11 <neutrino_> and i used to know absolutely everything you could do there, and still do
08:41:19 <bitonic> neutrino_: well there is decent C# support on linux.  but I get your point
08:41:19 <cmccann> neutrino_: C# is what you get if you start with a cheap Java-knockoff, then give it to a bunch of PL geeks who like Haskell and let them try to fix it, heh
08:41:20 <neutrino_> it's just like downgrading from lego technics to duplo
08:41:23 <mm_freak_> > (flip (.) log . (flip (/) . log)) 10 1000
08:41:26 <lambdabot>   2.9999999999999996
08:41:28 <quchen> It's more like flip ((/) . log) . log
08:41:28 <mm_freak_> there we go
08:41:42 <neutrino_> bitonic: no one will pay me to do C# on linux..
08:41:44 <mm_freak_> > (flip (.) log . flip (/) . log) 10 1000
08:41:46 <lambdabot>   2.9999999999999996
08:41:47 <quchen> > (flip ((/) . log) . log) 10 1000
08:41:48 <neutrino_> bitonic: and i won't do it without being paid
08:41:48 <lambdabot>   2.9999999999999996
08:41:51 <mm_freak_> and of course (.) is associative =)
08:41:59 <bitonic> neutrino_: oh you were talking about work.
08:42:03 <`nand`> > join (/) log 10 1000
08:42:04 <lambdabot>   0.9999999999999999
08:42:10 <`nand`> hmm
08:42:36 <`nand`> oh
08:42:45 <ab9rf> cmccann: it had not occured to me that microsoft's past love for haskell might ahve influenced C#
08:42:54 <monoidal> does anyone know a good example of using runST inside runST?
08:43:11 <Taneb> monoidal, ...why not just use join?
08:43:21 <cmccann> ab9rf: it's true, one of the guys on the C# language team even wrote a monad tutorial on his MSDN blog :P
08:43:24 <monoidal> Taneb: to have different scopes for vars
08:43:30 <cmccann> when all the LINQ stuff was new
08:43:58 <mm_freak_> monoidal: runST (runST (return ()))?
08:44:06 <mm_freak_> > runST (runST (return ()))
08:44:08 <lambdabot>   Couldn't match expected type `GHC.ST.ST s a0' with actual type `()'
08:44:27 <quchen> > runST . return . runST . return $ ()
08:44:28 <`nand`> ab9rf: C# has taken ideas from Haskell in the past
08:44:29 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s c0'
08:44:29 <lambdabot>              with a...
08:44:41 <bitonic> > runST (return (runST (return ())))
08:44:41 <monoidal> mm_freak_: I'm searching for something nontrivial, I know how to do it but maybe there's a nice example where this could be used
08:44:42 <lambdabot>   ()
08:44:46 <`nand`> Linq is almost directly inspired by do syntax as far as I'm aware
08:45:05 <elliott> monoidal: using ST in ST is no different from using ST in pure code.
08:45:17 <bitonic> monoidal: well there are pure functions powered by runST... when you use those inside the ST monad
08:45:22 <elliott> any runST call fully encapsulates all the ST in it, and you can't access any variables from the outer ST.
08:45:32 <mm_freak_> monoidal: i don't see a difference from using it in any other way
08:45:38 <bitonic> monoidal: like there‚Äôs nothing special about that
08:45:43 <mm_freak_> monoidal: except that there is some higher-rank-weirdness with (.)
08:45:58 <mm_freak_> > runST $ return $ runST $ return ()
08:46:00 <quchen> bitonic: Waaait, why does your example typecheck and mine doesn't?
08:46:00 <lambdabot>   ()
08:46:06 <mm_freak_> > runST . return . runST $ return ()
08:46:08 <elliott> quchen: because predicativity
08:46:08 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s c0'
08:46:08 <lambdabot>              with a...
08:46:18 <quchen> elliott: What's that?
08:46:18 <elliott> (because runST is rank-2)
08:46:22 <bitonic> quchen: RankNTypes inference is muddy
08:46:29 <elliott> quchen: you can't instantiate a type variable with a quantified type
08:46:32 <bitonic> well inference, instantiation
08:46:42 <elliott> i.e., something like (forall v. ...)
08:46:51 <quchen> elliott: Ah, I remember a stackoverflow question that resulted in "$ has special rules that . doesn't have"
08:47:01 <elliott> (it works with ($) because GHC special-cases (f $ x) to be (f x))
08:47:04 <monoidal> quchen: in fact, both shouldn't. GHC has a special case for runST $ x that specifically allows it
08:47:08 <jmcarthur> monoidal: are you wanting the inner ST to have access to the STRefs in the outer ST but the outer ST to not have access to the STRefs in the inner ST?
08:47:12 <elliott> the special case doesn't involve runST, actually
08:47:20 <monoidal> jmcarthur: something like this
08:47:28 <jmcarthur> monoidal: i think you want something like monadic regions
08:47:40 <mm_freak_> is there a fundamental reason why (.) doesn't work here or is it just that type inference fails?
08:47:41 <Zenol> flebron > I don't think enouth :/
08:47:55 <mm_freak_> i.e. could i write type signatures to make (.) work?
08:47:56 <jmcarthur> monoidal: there is a package for that
08:47:58 <flebron> Zenol: Is IO still the bottleneck?
08:48:00 <jmcarthur> called regions, i think
08:48:10 <geekosaur> mm_freak_, it's impredicative type weirdness
08:48:11 <wting> Sorry I'm a noob, but is there really no math library / square root in base Haskell?
08:48:11 <cmccann> mm_freak_: just inference issues as far as I know
08:48:21 <jmcarthur> :t sqrt
08:48:22 <lambdabot> Floating a => a -> a
08:48:23 <jmcarthur> wting: ^^
08:48:27 <mm_freak_> wting: sqrt?
08:48:36 <mm_freak_> > sqrt pi
08:48:39 <lambdabot>   1.7724538509055159
08:48:41 <bitonic> mm_freak_: I don‚Äôt think you‚Äôd be able to write a (.) that‚Äôd work.  but it‚Äôs hard to say, inference for higher ranked types in GHC is confusing
08:49:01 <mm_freak_> > sqrt (3^2 + 4^2) :: CReal
08:49:01 <wting> You know, you think that'd be a result for the search query: "haskell square root". Anyway, thanks.
08:49:03 <lambdabot>   5.0
08:49:03 <geekosaur> wting, there's no separate math library as such, there is a lot of math stuff in the Prelude
08:49:13 <cmccann> well, higher-rank types can't be inferred in general
08:49:17 <mm_freak_> wting: depends on where you search =)
08:49:20 <elliott> mm_freak_: with proper impredicative stuff you can do it
08:49:21 <`nand`> there are plenty of separate math libraries in addition to what you get in the Prelude
08:49:25 <cmccann> GHC does a pretty decent job of inferring what it can
08:49:31 <bitonic> cmccann: right, but inference in GHC is surprising and has a few ad-hoc rules
08:49:33 <wting> mm_freak_: I'm using Google, should I be searching elsewhere?
08:49:38 <geekosaur> yes, but not a separate basic math library like in python or etc.
08:49:40 <`nand`> I mean, the prelude doesn't even cover things like automatic differentiation or fast fourier transforms!
08:49:47 <geekosaur> or -lm in C
08:49:48 <`nand`> wting: try hoogle or hayoo
08:50:00 <mm_freak_> elliott: while i'm quite comfortable with higher rank types, impredicativity still breaks my brain (mainly because i haven't really taken the time to learn it)
08:50:02 <bitonic> cmccann: I‚Äôm sure they make the choices they made for a reason, but there are many dark corners
08:50:06 <jmcarthur> cmccann: i have heard that rank-2 types can be inferred, but ghc just doesn't do all the tricks for it
08:50:07 <monoidal> http://www.reddit.com/r/haskell/comments/1c7hiq/undestanding_runst_and_impredicativity/c9efdkd <- I settled for this example
08:50:21 <cmccann> jmcarthur: now that you mention it, that sounds right
08:50:26 <elliott> mm_freak_: I found these papers http://research.microsoft.com/en-us/projects/fcp/ interesting
08:50:41 <wting> Hoogle no results: http://www.haskell.org/hoogle/?hoogle=square+root
08:50:42 <mm_freak_> wting: with "haskell square root" on google that function was the first hit, but there is also hoogle and hayoo
08:50:50 <mm_freak_> elliott: thanks
08:51:16 <mm_freak_> wting: hoogle is really more for searching for function names and/or types
08:51:20 <mm_freak_> @hoogle Integer -> Integer
08:51:21 <lambdabot> Control.DeepSeq force :: NFData a => a -> a
08:51:21 <lambdabot> Data.Bits complement :: Bits a => a -> a
08:51:21 <lambdabot> Prelude id :: a -> a
08:51:31 <`nand`> @hoogle sqrt
08:51:32 <lambdabot> Prelude sqrt :: Floating a => a -> a
08:51:34 <wting> mm_freak_: but that hurts discovery if I don't already know the function name. :-/
08:51:36 <`nand`> okay that's cheating, but ‚Äòsqrt‚Äô is a common name
08:52:03 <elliott> @hoogle Floating a => a -> a
08:52:03 <lambdabot> Prelude acos :: Floating a => a -> a
08:52:03 <lambdabot> Prelude acosh :: Floating a => a -> a
08:52:03 <lambdabot> Prelude asin :: Floating a => a -> a
08:52:04 <mm_freak_> wting: i know‚Ä¶  i don't know how hayoo does it, so give it a try
08:52:29 <wting> Hayoo returns a bunch of results, but nothing in Prelude: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:square%20root
08:52:31 <mm_freak_> wting: my personal way of looking stuff up is pointing my browser to my local haddock documentation and ctrl-f
08:52:40 <niteria> idiom brackets are for monadic functions?
08:52:46 <`nand`> niteria: applicative
08:52:49 <jmcarthur> monoidal: ah
08:53:01 <mm_freak_> wting: only problem with that approach is that you need to know the module name
08:53:05 <`nand`> https://duckduckgo.com/?q=haskell+square+root -> first result
08:53:10 <hpaste> natnayr revised ‚Äúaccelerate‚Äù: ‚Äúnatnayr‚Äù at http://hpaste.org/85682
08:53:13 <wting> and the first Google hit talks about idiomatic solutions for Generic numbers and indirectly mentions sqrt.
08:53:15 <jmcarthur> monoidal: the main difference between that and regions is that regions would allow you to actually read and write the references from the outer scope
08:53:26 <natnayr> hi im having issues fixing this
08:53:27 <elliott> wting: you could search the documentation of Prelude first
08:53:41 <elliott> http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html
08:53:44 <mm_freak_> wting: google gives personalized responses, so your first hit may be different from mine
08:53:58 <mm_freak_> in particular when you have other language settings in your browser
08:54:02 <monoidal> jmcarthur: I see
08:54:11 <niteria> if you want to use a "normal" function inside idiom brackets you have to lift it, right?
08:54:12 <wting> mm_freak_: I have personal search disabled.
08:54:19 <natnayr> need to somehow pinch the list and apply with folds or maps or smth
08:54:35 <mm_freak_> wting: and i'm not even registered, but for example google knows that i'm german =)
08:55:02 <Zenol> flebron > It's isn't io. I'm creating some number as string with a special pattern, then converting them into Integer, doing somme multiplications and co with them, and counting how much number remain after some checks
08:55:26 <mm_freak_> wting: anyway, your point is still correct‚Ä¶  there should be a way for searching for base functionality by keyword, and i agree
08:55:52 <niteria> it'd be nice if haskell had mixfix functions
08:56:03 <mm_freak_> niteria: no, that would be terrible
08:56:06 <hpaste> natnayr revised ‚Äúaccelerate‚Äù: ‚Äúnatnayr‚Äù at http://hpaste.org/85682
08:56:07 <hpaste> natnayr revised ‚Äúaccelerate‚Äù: ‚Äúnatnayr‚Äù at http://hpaste.org/85682
08:56:16 <Zenol> flebron > Using BytString changed speed from 15s to 4s, just with the use of readInteger and pack applyed to the old list (i'm realy surprised \o/), then using ByteString quickier, It decreased by... 0.02 s O.o
08:56:28 <elliott> `nand`: that DDG result is bad, btw.
08:56:35 <flebron> :)
08:56:37 <elliott> zvon.org is an old, inaccurate reference
08:56:49 <`nand`> elliott: I see
08:56:51 <flebron> pack shouldn't be used
08:56:51 <cmccann> @quote copumpkin mixfix
08:56:52 <lambdabot> copumpkin says: THE POWER OF MIXFIX COMPELS YOU (to not use it much)
08:56:54 <elliott> and "See the updated version of this reference." links to... 6.12 docs!
08:56:55 <`nand`> mm_freak_: google is completely unusable for me
08:56:55 <flebron> you should read your input as bytestring
08:57:06 <`nand`> mm_freak_: at least, unless I enable cookies or something
08:57:19 <`nand`> mm_freak_: it always returns answers in german, and you must know how dreadfully bad they are
08:57:20 <mm_freak_> niteria: agda has tried two novel ideas:  using unicode and providing mixfix‚Ä¶  both were a terrible idea, because you know, people actually use it and it's a mess to decipher code =)
08:57:31 <`nand`> heck, I can't even google ‚Äúteamspeak 3‚Äù and get a link to the website
08:57:51 <mm_freak_> `nand`: it's not that bad for me, but i'm not happy typing everything into google
08:58:29 <`nand`> it's always some bullshit ‚Äúchip.de‚Äù link or other german ‚Äòtechy‚Äô site that mirrors every program under the sun for some strange reason
08:58:35 <neutrino_> `nand`: you can add &hl=en to the search query
08:58:47 <neutrino_> `nand`: or you can go to google.com/ncr to get the english version
08:58:53 <natnayr> umm, could someone pls help me look at my code?
08:58:58 <`nand`> neutrino_: ah, that could come in handy. I actually just use startpage.com, because that way I get a proxy to avoid the bubble too
08:59:12 <neutrino_> never used startpage.com, what does it do?
08:59:42 <mm_freak_> `nand`: yes, indeed‚Ä¶  just yesterday i've searched for "$LAPTOP_MODEL $TRIAL manual", where $TRIAL was BIOS, motherboard, mainboard, hardware, UEFI, ‚Ä¶
08:59:55 <mm_freak_> in each case i was referred to some stupid web shop sites
09:00:03 <niteria> I'm sure mixfix if used sparingly is actually useful
09:00:03 <cmccann> natnayr: not sure exactly what you need help with
09:00:05 <`nand`> natnayr: on line 45 you don't have to bother matching (x, y) if you're only going to use it as (x, y) again
09:00:17 <`nand`> natnayr: you can just give the whole (x, y) thing a name, eg ‚Äòxy‚Äô
09:00:24 <mm_freak_> niteria: but it wouldn't be used sparingly
09:00:28 <`nand`> (tuples are really not that special)
09:00:29 <mm_freak_> niteria: see agda
09:01:01 <niteria> I've only seen tutorial agda and it looked kind of cool
09:01:19 <natnayr> `nand`: having an issue with line 36 where i need to move down the list
09:01:34 <mm_freak_> niteria: it does look cool, until you try to actually read the code instead of just looking at it =)
09:01:36 <natnayr> cause line 40 returns back a single particle
09:02:50 <`nand`> the smartass answer would be to wrap [] around it, but other than that, I don't understand what your code is supposed to be doing semantics-wise
09:02:58 <niteria> I think given enough time people will eventually use a style that's readable
09:02:59 <DMcGill> how to I get ghc to give me a dependency tree or order for my modules?
09:03:16 <`nand`> ‚ÄòcalculateAllForces‚Äô only returns a single particle. ‚Äòaccelerate‚Äô needs to return a list of particles. Why? What's the list for?
09:03:25 <cmccann> mm_freak_: to be fair there are plenty of ways that people can make Haskell code look nifty in an unreadable way as is
09:03:39 <cmccann> and they're only overused in moderation
09:03:39 <elliott> agda isn't hard to read.
09:03:42 <elliott> but it's a huge pain to type.
09:03:45 <elliott> even with agda-mode
09:04:11 <natnayr> `nand` its a list of all the floating particles..
09:04:33 <natnayr> `nand` so they actually interact with each other gravity, velocity wise
09:04:34 <`nand`> natnayr: looking some more at your code, you take each particle and calculate the sum of forces based on every other particle? and you want to do this for each particle in the list?
09:04:44 <mm_freak_> niteria: agda is at least 9 years old, and it still suffers from that decision‚Ä¶  more than ever before =)
09:04:45 <cmccann> elliott: that's because it doesn't have... B] ...type inference
09:04:58 <`nand`> cmccann: haha
09:05:09 <natnayr> `nand`: yep.. so right now calculateAllForces returns a particle..
09:05:11 <elliott> cmccann: :(
09:05:17 <mm_freak_> cmccann: yes, but in haskell it's controllable and you can still understand what is applied to what without looking into billions of other modules
09:05:19 <elliott> cmccann: you're a bad person.
09:05:22 <`nand`> natnayr: looks like you want ‚Äòmap‚Äô then
09:05:35 <mm_freak_> to understand agda code i generally have to look into the whole base library just to understand the mixfixes
09:05:38 <natnayr> `nand` which line?
09:05:39 <cmccann> elliott: perhaps. but that was totally worth it.
09:05:51 <elliott> also the things people see as hard to read about haskell aren't really anything to do with mixfix so much as the unicode, it hink.
09:05:53 <`nand`> oh, it's not as simple as that
09:06:15 <`nand`> your ‚ÄòcalculateAllForces‚Äô needs to be changed to something like :: Float -> [Particle] -> Particle -> Particle -- where the ‚Äòcurrent‚Äô particle is separate from the rest
09:06:25 <mm_freak_> often people find haskell code unreadable because they are not familiar with it‚Ä¶  that doesn't really count
09:06:28 <cmccann> overuse of custom operators in Haskell doesn't seem any better than overuse of mixfix
09:06:38 <`nand`> actually I believe a comonad would be most appropriate here
09:06:47 <mm_freak_> consider this:  modify (M.insertWith (M.unionWith (+)) x y)
09:06:54 <mm_freak_> perfectly understandable to the average haskell programmer
09:07:00 <mm_freak_> totally unintelligible to a C++ programmer
09:07:04 <natnayr> `nand` could i pm u?
09:07:16 <`nand`> natnayr: you can keep the discussion in here too
09:07:28 <natnayr> ok
09:07:41 <`nand`> that's more idiomatic here
09:08:15 <natnayr> so my betweenForces function already computes and updates a particle
09:08:28 <Zenol> O.O n^2 isn't rewriten as n*n by GHC?
09:08:39 <cmccann> mm_freak_: anyway, fixities of custom infix operators have the same problems
09:08:45 <mm_freak_> Zenol: if anything it's rewritten to n*n*1
09:08:48 <cmccann> and most Haskell code doesn't go overboard with those
09:09:04 <hpaste> natnayr revised ‚Äúaccelerate‚Äù: ‚Äúnatnayr‚Äù at http://hpaste.org/85682
09:09:10 <cmccann> so, empirically speaking, we can conclude that if Haskell supported mixfix lens would abuse the hell out of it but that's about all
09:09:11 <natnayr> updated the code abit
09:09:21 <mm_freak_> cmccann: the problem isn't as severe in haskell as in agda
09:09:33 <elliott> Zenol: it's not. unfortunately.
09:09:40 <mm_freak_> i think custom infix operators are a good compromise between readability and abusablilty
09:09:50 <XexonixXexillion> I personally found Agda symbols quite intuitive, and the mixfix wasn't very confusing; it seemed to match what one would expect
09:09:59 <niteria> @type \n -> n^2
09:10:01 <lambdabot> Num a => a -> a
09:10:12 <`nand`> http://hackage.haskell.org/packages/archive/comonad-extras/3.0.1/doc/html/Control-Comonad-Store-Zipper.html -- this seems appropriate, but that may be reaching ahead too far, natnayr
09:10:23 <cmccann> mm_freak_: I think that has more to do with the habits of programmers than the languages themselves
09:10:26 <XexonixXexillion> I mean it could be horribly abused, by it wasn't
09:10:32 <XexonixXexillion> s/by/but/
09:10:39 <Zenol> Actualy, compiling n^2 is slower than n*n wich is slowen than... compiler with -O2 and witint n^2 ????
09:10:58 <mm_freak_> cmccann: i'm really just looking at the state of things
09:11:01 <`nand`> natnayr: but essentially, extend :: (Zipper a -> b) -> Zipper a -> Zipper b -- think of a zipper like a list with a movable ‚Äòfocus‚Äô
09:11:13 <niteria> @src (^)
09:11:13 <lambdabot> x ^ 0            =  1
09:11:13 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
09:11:13 <lambdabot>   where f _ 0 y = y
09:11:13 <lambdabot>         f x n y = g x n
09:11:13 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
09:11:15 <lambdabot>                       | otherwise = f x (n-1) (x*y)
09:11:17 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
09:11:23 <mm_freak_> cmccann: consider a*b + c in haskell‚Ä¶  i can look that up in GHCi
09:11:29 <mm_freak_> i do :i on + and *
09:11:29 <`nand`> natnayr: this function works by running the function you give it once for each element in the original list, but with the focus shifted to that position
09:11:45 <mm_freak_> cmccann: for a * b + c in agda what am i looking for?
09:11:47 <natnayr> `nand`: where should i apply that?
09:11:51 <`nand`> natnayr: then you can write your ‚Äòaccelerate‚Äô function to simply update the particle that's currently in the ‚Äòfocus‚Äô by considering everything else
09:11:56 <mm_freak_> _*_?  _+_?  _*_+_?
09:11:57 <niteria> _*_+_ ofc
09:12:10 <cmccann> mm_freak_: I dunno, you'd have to ask someone who uses agda :P
09:12:23 <`nand`> a _ b _ c
09:12:29 <mm_freak_> cmccann: i used agda, and i still don't know, because it could be any of those
09:12:35 <niteria> I think everyone agrees that it can be abused
09:12:49 <cmccann> anyway, that seems like a development environment issue really
09:12:55 <mm_freak_> let me put it this way:  mixfix, especially with unicode, /does/ get abused
09:13:04 <mm_freak_> haskell custom infix operators not that much
09:13:16 <natnayr> what t in zipper?
09:13:27 <XexonixXexillion> mm_freak_: It *could* be any of those, but it's going to be _+_ and _*_
09:13:37 <mm_freak_> XexonixXexillion: that was just an example
09:14:03 <natnayr> `nand` do i have to rewrite my calculateAllForces?
09:14:20 <niteria> well, you can't be sure (+) is comutative, but you make that implicit assumption every time you use it
09:14:36 <`nand`> natnayr: if you want to use my suggestion, somewhat
09:15:01 <mm_freak_> anyway, we could argue about that all day
09:15:11 <mm_freak_> i'm strongly contra mixfix
09:15:20 <natnayr> `nand` i dun know where to start....
09:15:23 <mm_freak_> mainly through my experience with agda
09:15:46 <XexonixXexillion> mm_freak_: I'm strongly for mixfix, mainly through my experience with agda
09:15:53 <niteria> there's always some implicit knowledge you have to carry when you program
09:16:01 <XexonixXexillion> Although apart from the base libraries, I wasn't dealing with anyone else's agda...
09:16:22 <zachk> cant the parsing of mixfix, be computationally, extremely expensive at times?
09:16:46 <mm_freak_> zachk: yeah, but a language shouldn't be designed for the compiler
09:17:05 <`nand`> languages shouldn't be designed for the computer!!1 I want my Haskell+Oracle
09:18:17 <niteria> typechecking in agda is extremely expensive too, I imagine
09:20:00 <beaky> how does a type system improve the expressive power of a programming language? Past languages I've tried (C, C++, Java, C#) bump into a couple of problems expressing stuff, and those problems aren't an issue in dynamically-typed languages
09:21:06 <beaky> e.g. the whole idea of polymorphic containers; in a dynamically-typed language you just make one, while in a statically-typed language you must wrestle with templates (C++), parametric polymorphism, generics, etc.
09:21:42 <fryguybob> beaky: "wrestle with" implies "pin down what it actually is"
09:22:00 * `nand` likes wrestling with monoids
09:22:05 <fryguybob> beaky: That is, you are expressing the meaning of the container.
09:22:20 <Trollkastel> beaky: In a so-called "dynamically typed" language, there is no such a thing as a polymorphic container because there is only one type.
09:22:27 <Trollkastel> s/such a/such/
09:22:54 <beaky> ah right
09:23:16 <beaky> so types are there to add meaning to code?
09:23:19 <thoughtpolice> beaky: it's a broad question. you can focus on specific examples, but this isn't so useful because A) it cuts both ways and B) you don't necessarily want to talk about equivalent direct approaches anyway
09:23:33 <dkasak> beaky, yes, and to ensure correctness.
09:24:04 <thoughtpolice> beaky: i'd agree with everyone else. types are there to guide you. having an expressive type system makes this easier, and more rewarding
09:24:30 <niteria> types are to express checkable assumptions in your code while not being significantly less expressive
09:24:42 <beaky> in C++, it's very hard to write something like cons using closures
09:24:55 <niteria> type system in C++ is laughable
09:24:57 <beaky> haskell manages it somehow
09:25:28 <niteria> C++'s type system is there to help the compiler, not the programmer
09:25:37 <beaky> ah
09:25:51 <cmccann> java's type system is there to help nobody and make things more difficult
09:26:05 <ryant5000> so, if i've got a class C a, and an instance instance (C a, C b) => C (a, b)
09:26:20 <ryant5000> and i've got (C x, x ~ (y, z)) in scope
09:26:34 <ryant5000> is there any way for me to bring (C y, C z) into scope?
09:27:00 <XexonixXexillion> Ada's type system is there to help both the programmer and the compiler but for some reason nobody likes Ada...
09:27:04 <hpc> ryant5000: it should already be in scope...
09:27:21 <Trollkastel> XexonixXexillion: Because kitchensink?
09:27:23 <ryant5000> hpc: that's what i thought, but i'm getting a "Could not deduce"
09:27:29 <Cale> ryant5000: Thinking in terms of the dictionaries involved, I don't think there is
09:27:37 <ryant5000> interesting
09:27:45 <ryant5000> is there an idiomatic way of dealing with this issue?
09:28:06 <monoidal> in some sense it's converse; you want instance C (a,b) => (C a, C b) but that's ill-defined
09:28:06 <Cale> hmm
09:28:07 <ryant5000> i used a nasty hack involving GADTs one time
09:28:20 <ryant5000> monoidal: is it really ill-defined?
09:28:33 <ryant5000> the instance is in scope, and overlapping instances aren't turned on
09:28:45 <ryant5000> so i know it's the only instance
09:28:57 <monoidal> ryant5000: well, you could write "instance C (a,b) => C a" in haskell, but due to how instance resolution works this will not help
09:29:05 <elliott> I don't think it's ill-defined
09:29:18 <elliott> if you have C (a, b), that implies having (C a) and (C b) given that instance
09:29:18 <luite> ryant5000: ghcjs has a gloss backend now \o/ http://hdiff.luite.com/gloss/
09:29:19 <XexonixXexillion> Trollkastel: I just wish Haskell would let me make modulo and ranged types. I have some TH that kind of does it... but it's not the same
09:29:22 <ryant5000> monoidal: yeah, i agree; it would just overlap everything all the time
09:29:35 <ryant5000> elliott: right, especially since i know that's the *only* instance
09:29:56 <ryant5000> luite: nice!
09:29:56 <elliott> ryant5000: if you have (C (y, z)) (i.e. without the equality constraint), does it work?
09:30:03 <elliott> you could try substituting away x or something
09:30:16 <ryant5000> elliott: no, i don't think it does
09:30:21 <elliott> like write (C (y, z) => ...) first
09:30:27 <`nand`> is there some
09:30:30 <`nand`> oops
09:30:39 <`nand`> is there some example of when foldl is ‚Äúbetter‚Äù than foldl'?
09:30:42 <`nand`> efficiency-wise
09:30:47 <monoidal> elliott: but can't another module M import your module, use overlappinginstances, define C (T1, T2) for some T1, T2 and pass a value (T1, T2) to some of your functions?
09:30:58 <monoidal> * sorry, that was meant to ryant5000
09:31:03 <elliott> monoidal: OverlappingInstances is already unsafe :P
09:31:13 <ryant5000> monoidal: can it?
09:31:21 <ryant5000> i'm not really familiar with the details of overlappinginstances
09:31:28 <elliott> an orphan overlapping instance can be expected to break things
09:31:34 <ryant5000> i would hope that the *class* would need to be declared with overlapping instances
09:31:35 <monoidal> I'm not sure either
09:31:41 <ryant5000> in order to allow it for the instances
09:32:09 <ryant5000> but you're certainly right; with overlapping instances, i shouldn't be allowed to do this
09:33:15 <elliott> ryant5000: you could have a constraint like (C (y, z), C y, C z) => ... if that would work
09:34:23 <hpaste> ryant5000 pasted ‚ÄúInstance Context‚Äù at http://hpaste.org/85700
09:34:43 <ryant5000> elliott: unfortunately, in this particular instance, i only know i've got a pair because i'm opening a GADT
09:35:39 <elliott> ryant5000: yeah, I guess you'll have to restructure whatever would use f
09:35:50 <hpaste> ryant5000 annotated ‚ÄúInstance Context‚Äù with ‚ÄúInstance Context (annotation)‚Äù at http://hpaste.org/85700#a85701
09:36:12 <hpaste> ryant5000 revised ‚ÄúInstance Context (annotation)‚Äù: ‚ÄúInstance Context (annotation)‚Äù at http://hpaste.org/85701
09:36:34 <syllojizm> sum [x | x <- [1..999], (x `rem` 3 == 0) || (x `rem` 5 == 0)] this runs in ghci just fine, but when i place it in a file and try to compile with ghc it gives me this:  No instance for (Integral (Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec])) arising from a use of `mod' at
09:36:40 <ryant5000> elliott: seems pretty bogus, lol; i'll probably resort to crazy GADT hackery instead
09:37:00 <monoidal> syllojizm: in files you need to give them a name, like "x = sum ..."
09:37:04 <syllojizm> i'm only a bit through this tutorial i'm reading though - sorry if it's a bad question.
09:37:08 <syllojizm> ah. thank you.
09:37:27 <Cale> If you think of the instance (C a, C b) => C (a,b) as simply being a function C a -> C b -> C (a,b) (rather than a data constructor of this type), then it's clear why you can't get the instance you want. However, it's interesting to consider an implementation of type classes which did use a data constructor in cases like this.
09:37:27 <monoidal> syllojizm: what GHC are you using?
09:37:50 <syllojizm> Glasgow Haskell Compiler, Version 6.12.3
09:37:57 <ryant5000> Cale: yeah; i've gotten around this before, but it was gross
09:38:03 <ryant5000> now i need to remember my gross solution
09:38:04 <ryant5000> lol
09:38:14 <monoidal> syllojizm: you should definitely upgrade, 6.12 is ancient
09:38:18 <Cale> ryant5000: Of course, you could just pass around dictionaries explicitly :P
09:38:28 <ryant5000> Cale: i will not be doing that, lol
09:38:29 <monoidal> syllojizm: we had 7.0, 7.2, 7.4, 7.6 each giving tons of new features and fixes
09:38:52 <monoidal> syllojizm: for example, you'd get "Parse error: naked expression at top level"  for your program instead of the unreadable message
09:39:44 <monoidal> syllojizm: http://www.haskell.org/platform/
09:39:49 <syllojizm> cool grabbing it now
09:40:12 <Cale> monoidal: Of course, turning on TemplateHaskell will give that same error :)
09:40:26 <`nand`> get 7.6 :D
09:40:29 <monoidal> Cale: yes, but older compilers give that error even without TH
09:40:59 <`nand`> I don't even remember any code I've written that compiles on anything before 7.6
09:42:11 <hpaste> ryant5000 revised ‚ÄúInstance Context (annotation)‚Äù: ‚ÄúInstance Context - GADT Hack‚Äù at http://hpaste.org/85701
09:42:23 <ryant5000> well, i guess it's just an existential type, not a GADT
09:42:29 <ryant5000> anyway, that works fine
09:43:35 <ryant5000> it's quite annoying to go around adding that to every class and instance, though, i must say
09:45:04 <klrr> is there any haskell code style guide?
09:45:19 <`nand`> GADTs are just existential types + equality constraints, right?
09:45:20 <monoidal> klrr: http://urchin.earth.li/~ian/style/haskell.html
09:45:57 <monoidal> klrr: http://stackoverflow.com/questions/1983047/good-haskell-coding-standards
09:46:09 <ryant5000> `nand`: i believe so, although they also have their own syntax; since i'm not using equality constraints or the syntax, i shouldn't call it a gadt :P
09:46:10 <monoidal> klrr: also run hlint and ghc -Wall to get tips
09:46:52 <`nand`> ryant5000: GADTs are a superset of ADTs though
09:46:57 <`nand`> so it's still a perfectly fine GADT :D
09:47:02 <ryant5000> `nand`: lol
09:48:36 <klrr> is s and t mostly used as string variables?
09:49:16 <ryant5000> klrr: i don't think i've observed much consistency in single-letter variable names
09:49:45 <ryant5000> klrr: except that, in types, people tend to go alphabetically a lot of the time
09:50:46 <klrr> key
09:51:07 <`nand`> s t a b
09:52:21 <aristid> (s, t) (a, b)
09:53:49 <`nand`> (s, t) (a, b) s a
09:56:10 <quchen> getting a s t a b?
09:56:17 <`nand`> :)
09:59:29 <ski_> jmcarthur,fryguybob : yeah, "reasonability" (how much you can reason about, and refactor, and make localized or at least safe changes) of a programming language is at least comparable in importance to its expressivity, i think
09:59:44 <ski_> mm_freak_ : .. though Agda1 is different from Agda2
10:04:23 <klrr> how do i make so that ghc compiles with certain options and so it compiles with a package in ym program.cabal file?
10:04:25 <ski_> (Agda1 didn't have mixfix, nor unicode syntax. It was Alfa, the structural editor for Agda1, which supported mixfix and symbolic (no unicode, though) presentation of the ascii identifiers, also including natural-deduction-style presentation of proofs with inference rules)
10:04:44 <ski_> <mm_freak_> zachk: yeah, but a language shouldn't be designed for the compiler
10:04:50 <ski_> only true to much of the extent
10:04:54 <ski_> beaky : types checking is partially about automating boring (but important) checks, so we can focus on the more fun stuff
10:06:29 <edwardk> @messages
10:06:29 <lambdabot> sclv said 20h 1m 42s ago: 'sup?
10:06:29 <lambdabot> `nand` said 4h 3m 29s ago: you should totally run the lens-pong example through ghcjs and host the result on the website
10:06:42 <edwardk> @tell `nand` go for it. ;)
10:06:42 <lambdabot> Consider it noted.
10:07:01 <`nand`> @tell luite you should totally run the lens-pong example through ghcjs and send the output to edwardk
10:07:02 <lambdabot> Consider it noted.
10:07:11 <quchen> edwardk: Did you see luite's earlier creations? He got some Gloss programs running in the browser
10:07:27 <edwardk> haven't looked. where?
10:07:41 <`nand`> http://hdiff.luite.com:4100/
10:07:41 <lambdabot> `nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
10:07:43 <quchen> Let me find it again
10:08:02 <`nand`> luite: what physics library is that anyhow?
10:08:14 <`nand`> or is it just custom logic
10:08:19 <klrr> cabal is difficult to use xD
10:08:53 <quchen> edwardk: He seems to have deleted the "bouncing fractal tree" example, but the water simulation is still online: http://hdiff.luite.com:4100/
10:09:12 <edwardk> spiffy!
10:09:45 <klrr> how do i make so my program loads other files?
10:10:00 <klrr> i want my program to load a file called Scheme.hs in same directory
10:10:06 <quchen> edwardk: Is he involved in the development of the compiler? The examples are always between being elaborate and proof-of-concept
10:10:08 <klrr> do i do "import Scheme"?
10:10:20 <quchen> klrr: "import Scheme"
10:10:41 <klrr> quchen: yeah, well i tried didnt work, it says it doesnt find it? do i have to specify it in some cabal file?
10:11:31 <quchen> klrr: Hm, I avoided Cabal so far. :-/
10:11:33 <supki> klrr: do you have  module Scheme where  at top of Scheme.hs ?
10:11:48 <klrr> oh that's it thanks supki
10:13:31 <edwardk> quchen: well, i think he helped push towards the new split-base movement, but thats about the limit of his involvement in ghc itself
10:14:06 <quchen> edwardk: I meant the to-Javascript-compiler.
10:14:15 <quchen> Or is the plan to include that in GHC itself?
10:15:19 <klrr> still doesnt load the scheme file
10:16:35 <edwardk> oh he writes ghcjs
10:16:40 <monochrom> isn't that supposed to be :load Scheme.hs ?
10:18:42 <niteria> @src (.:)
10:18:43 <lambdabot> Source not found. It can only be attributed to human error.
10:21:36 <supki> niteria: fmap . fmap
10:30:25 <paolino> hello, I have a data A a = A (F a) , and a data family F a :: *.  Is it possible to ask for F a to be instance of Show ? Because deriving Show for A a doesn't work
10:30:52 <elliott> instance Show (F a) => Show (A a) wher ...?
10:30:54 <elliott> *where
10:30:59 <elliott> deriving instance Show (F a) => Show (A a) may work
10:31:09 <paolino> ah
10:31:22 <paolino> didn't try that
10:32:51 <klrr> arent there any guides on cabal? (except official one that one doesnt work)
10:33:55 <klrr> how should i make so that "import Scheme.hs" works when running "cabal build" if my main is in ./src/Main.hs and the Scheme.hs file is in ./src/Main.hs ?
10:34:31 <byorgey> klrr: you should write "import Scheme" not  "import Scheme.hs"
10:35:10 <byorgey> klrr: and you will need  hs-source-dirs: src
10:35:13 <byorgey> in your .cabal file
10:35:34 <paolino> elliott, it's undecidable, right ?
10:35:56 <elliott> paolino: quite possibly, yes
10:35:58 <klrr> byorgey: how do i add that? also i changed import Scheme.hs to import Scheme
10:37:06 <byorgey> klrr: also make sure that Scheme.hs has "module Scheme where" at the top
10:37:26 <byorgey> klrr: how did you create your .cabal file?
10:37:31 <klrr> it has
10:37:33 <klrr> byorgey: yes
10:37:33 <andrewsw> klrr: is Scheme.hs in ./src/Main/?
10:37:36 <klrr> yea
10:37:40 <byorgey> ahh
10:37:48 <klrr> how do i add hs-source-dirs?
10:38:11 <byorgey> if it is in  ./src/Main/ then you need to have  "module Main.Scheme where"  and also  "import Main.Scheme"
10:38:21 <andrewsw> :)
10:38:29 <klrr> it's in ./src/Scheme.hs
10:38:37 <byorgey> oh, OK, then never mind
10:38:41 <andrewsw> :(
10:38:42 <byorgey> klrr: how did you create your .cabal file?
10:38:47 <klrr> should it be in ./src/Main/Scheme to load auto?
10:38:50 <andrewsw> thought I was onto something there...
10:38:50 <byorgey> no
10:38:50 <klrr> cabal init
10:39:23 <byorgey> klrr: is there already an hs-source-dirs field commented out?
10:39:33 <klrr> http://hpaste.org/85705
10:39:42 <klrr> that's how it is, there was no hs-source-dirs
10:40:14 <byorgey> klrr: I just posted an annotation
10:40:25 <byorgey> you need to add it in the Executable section
10:40:25 <paolino> elliott, I cannot understand what is undecidable
10:40:49 <elliott> paolino: GHC's criterion for instances is conservative
10:40:55 <elliott> so you often need UndecidableInstances for perfectly fine instances
10:41:33 <klrr> byorgey: annatation?
10:41:48 <byorgey> klrr: reload http://hpaste.org/85705
10:41:55 <klrr> oh
10:42:15 <klrr> also it "other-modules: src/Scheme.hs" needed?
10:42:18 <klrr> thanks btw :)
10:42:31 <supki> other-modules: Scheme  would be right
10:42:35 <aCube> @ping
10:42:35 <lambdabot> pong
10:42:45 <byorgey> klrr: what supki said
10:42:54 <klrr> okey
10:43:25 <klrr> i get "cabal: hbot.cabal:18: Construct not supported at this position: F 18
10:43:27 <klrr> "hs-source-dirs" "./src""
10:43:32 <klrr> ·∫Öhen i run "cabal build"
10:43:58 <paolino> elliott, ok, I take it , I thought the injectiveness of data family was enough, but I'm not really confident with these
10:44:21 <klrr> it works now :D thanks byorgey and supki
10:44:47 <elliott> paolino: I think it should be fine with a data family, yeah
10:45:06 <byorgey> klrr: great!  you're welcome
10:45:23 <`nand`> Undecidable ‚â† Nonterminating
10:45:53 <klrr> okey one last question :P , how do i configure my .cabal so that "-XExistentialQuantification" get's used when ghc runs?
10:46:24 <`nand`> usually you'd want to do that with a language pragma
10:46:26 <`nand`> not a compiler flag
10:46:35 <monochrom> please don't. please put in the haskell file {-# LANGUAGE ExistentialQuantification #-}
10:46:37 <`nand`> {-# LANGUAGE ExistentialQuantification #-} in each of the source files that need it
10:46:52 <klrr> okey thanks
10:55:50 <Iceland_jack> Is there a neater way of determining whether all elements in a list are equal than (null ‚àò drop 1 ‚àò nub)
10:56:10 <Botje> null . tail . group
10:56:15 <Iceland_jack> hm
10:56:31 <Botje> or all (== head xs) xs
10:56:41 <Iceland_jack> that's probably more explicit
10:57:24 <supki> @ty all (uncurry (==)) . ap zip (drop 1)
10:57:26 <lambdabot> Eq b => [b] -> Bool
10:57:39 <byorgey> note that both of Botje's solutions crash on the empty list, whereas Iceland_jack's original solution does not
10:57:40 <FireFly> That's probably less explicit :P
10:58:07 <byorgey> but null . drop 1 . group  works
10:58:27 <Iceland_jack> Yes, I was wondering whether there was a more idiomatic way of doing it
10:58:59 <byorgey> you could also do  (<= 1) . S.size . S.fromList
10:59:11 <aCube> :t (all.) . zipWith (==)
10:59:12 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `[c0]'
10:59:12 <lambdabot>     Expected type: [a1] -> [b0] -> a0 -> Bool
10:59:12 <lambdabot>       Actual type: [a1] -> [b0] -> [c0]
10:59:21 <Iceland_jack> byorgey: It requires Ord and importing Data.Set
10:59:27 <byorgey> true.  also it's not lazy.
10:59:45 <klrr> i get some type mismatch error, http://hpaste.org/85708 (error msg is at buttom), any idea what it might be?
11:00:01 <byorgey> null . drop 1 . group  seems the nicest to me
11:00:23 <byorgey> linear time, stops early, works on the empty list
11:00:57 <Iceland_jack> The time isn't very important to me, I'm using it to test different implementations for equivalence using QuickCheck
11:01:30 <Botje> klrr: what's the type of evalAndPrint / primitiveBindings?
11:02:42 <klrr> Botje: evalAndPrint :: Env -> String -> IO () ; primitiveBindings :: IO Env
11:02:50 <klrr> Env is a IORef
11:03:06 <klrr> and primitiveBindings is a null IORef to start with
11:03:47 <Botje> then you need to do privmsg h =<< flip evalAndPrint x =<< primitiveBindings, I think.
11:04:31 <Botje> klrr: but .. ehh.. if evalAndPrint just returns (), what's the point of printing it?
11:04:46 <klrr> oh shit that's true
11:04:50 <klrr> also
11:04:59 <klrr> by =<< do yoou mean >>= ?
11:05:09 <Botje> =<< = flip (>>=)
11:05:14 <klrr> okey
11:05:30 <Botje> or you write primitiveBindings >>= flip evalAndPrint >>= privmsg
11:05:33 <Botje> that also works
11:05:59 <dmj> does anyone have an inuitive explanation of the State Monad?
11:06:00 <dmj> data State s a = State {}
11:06:01 <dmj>         runState :: s -> (a,s)
11:06:02 <dmj>     }
11:06:04 <dmj> throwing me off
11:06:15 <applicative> what sort of hardware does one use with this hoodle thing?
11:06:24 <flebron> Is there an easy way to define (+) :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int), coordinatewise sum?
11:06:32 <Botje> dmj: runState :: State s a -> s -> (a,s)
11:06:50 <Botje> dmj: so the State data constructor just carries around a function.
11:07:04 <Botje> if you feed that function a state you get a value and a new state
11:07:05 <elliott> flebron: instance (Num a, Num b, Num c) => Num (a,b,c) if you really want
11:07:16 <elliott> you have to do all the other Num methods though.
11:07:16 <aCube> :t sumOf each
11:07:17 <supki> > (1,2,3) + (4,5,6)
11:07:18 <lambdabot> (Num a, Each (Accessor (Endo (Endo a))) s t a b) => s -> a
11:07:18 <lambdabot>   (5,7,9)
11:07:59 <applicative> > let plus (s,t ,u)  (x,y,z) = (s+x,t+y,u+z) in plus (1,2,3) + (10,20,30)
11:08:01 <lambdabot>   Couldn't match expected type `(t0, t1, t2) -> (t0, t1, t2)'
11:08:01 <lambdabot>              wi...
11:08:03 <applicative> > let plus (s,t ,u)  (x,y,z) = (s+x,t+y,u+z) in plus (1,2,3) (10,20,30)
11:08:05 <lambdabot>   can't find file: L.hs
11:08:14 <applicative> hm?
11:08:15 <dmj> Botje: so runState is the opposite of State
11:08:25 <Botje> yep.
11:08:41 <Botje> it's called that because you can do runState (some State action) initialState
11:08:43 * hackagebot epub-metadata 3.0 - Library for parsing and manipulating EPUB files and OPF package data  http://hackage.haskell.org/package/epub-metadata-3.0 (DinoMorelli)
11:09:26 <applicative> > let tick s = ((),s+1) in runState ?? 0 $ tick >> tick >> tick
11:09:28 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
11:09:28 <lambdabot>        ...
11:09:39 <applicative> moron, I agree I should be shot
11:10:02 <applicative> > let tick  = state $\s -> ((),s+1) in runState ?? 0 $ tick >> tick >> tick
11:10:04 <lambdabot>   <hint>:1:23: parse error on input `->'
11:10:55 <dmj> Botje: the "get" function takes a State s s. Why not State s a ?
11:11:05 <dmj> Botje: won't this cause type conflicts
11:11:12 <niteria> > let tick  = state $ \s -> ((),s+1) in runState ?? 0 $ tick >> tick >> tick
11:11:15 <lambdabot>   ((),3)
11:11:18 <Botje> dmj: no, the get function is an action of type State s s.
11:11:30 <Botje> dmj: in other words, it makes the state available in its result.
11:11:31 <quchen> niteria: tick = modify (+1)
11:11:46 <Botje> dmj: so you can do get >>= \state -> ...
11:11:52 <applicative> > let tick  = state $ \s -> ((),s+1) in execState ?? 0 $    (tick >> tick >> tick >> tick )
11:11:54 <lambdabot>   4
11:12:59 <applicative> get 'returns' the underlying state so you can trashily alter it directly with put
11:13:49 <monoidal> dmj: can you write >>= for State?
11:13:58 <monoidal> I'd start from that
11:14:04 <applicative> > runState (do $ n <- get ; put (n+100): get) 0
11:14:06 <lambdabot>   <hint>:1:18: parse error on input `<-'
11:14:25 <applicative> > runState (do { n <- get ; put (n+100): get}) 0
11:14:26 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
11:14:27 <lambdabot>        ...
11:14:48 <applicative> why i'm not querying lambdabot separately I don't know
11:14:53 <Botje> applicative: not your day, is it? :)
11:14:54 <klrr> i still get same error http://hpaste.org/85708 (error and all code this time is in the paste) any ideas?
11:15:01 <applicative> > runState (do { n <- get ; put (n+100); get}) 0
11:15:03 <lambdabot>   (100,100)
11:15:44 <applicative> there we go, the state was 100 at the end (first element), and I asked it to return the state itself, the second tuple.
11:15:55 <applicative> second element in the tuple
11:16:19 <Botje> klrr: evalString wants an Env. you're giving it an IO Env
11:16:39 <klrr> http://hpaste.org/85708 real error at buttom
11:16:49 <klrr> Botje: okey, how can i make it an IO using liftIO?
11:17:06 <Botje> klrr: you're already in the IO monad.
11:17:16 <Botje> klrr: just do something like env <- nullEnv
11:17:22 <klrr> okey
11:17:26 <Botje> klrr: also note, every time you call nullEnv you will get a new IORef.
11:17:39 <klrr> oh didnt thought about that thanks
11:17:40 <dmj> monoidal: ma >>= g = State $ \s -> let (a,b) = runState ma s, return  runState (g a) b
11:18:04 <applicative> > runState ?? 0 $ get >>= \statenow -> put (statenow + 1) >> get >>= \statenext -> put  (statenext + 1) >> get >>= \statethird -> put (statethird +1)
11:18:06 <lambdabot>   ((),3)
11:18:13 <monoidal> dmj: yes, that's correct (only you need "in" instead of ",")
11:18:22 <dmj> monoidal: I see how we are lifting a state into State, pulling it out, doing some runState, then putting it back in.
11:18:30 <dmj> monoidal: yes
11:18:50 <applicative> dmj ^^ here you can follow the 'changing' state with the lambdas \statenow \statenext \statethird ^^^ theres nothing else to it
11:19:03 <dmj> applicative: what is "??"
11:19:41 <applicative> dmj infix flip, just makes it easier, the order of the args for runState isnt convenient, but follows from the type
11:20:57 <hpaste> dmj pasted ‚ÄúStateMo'‚Äù at http://hpaste.org/85715
11:21:01 <dmj> applicative: also, there is no State monad just a StateT right? So did you define your own? This is what mine looks like.
11:21:12 <u_> cabal is using 100% CPU and i can't kill it, not even with -9
11:21:13 <u_> wtf
11:21:22 <Iceland_jack> u_: It begins.
11:21:32 <dmj> u_: what is its pid?
11:21:34 <klrr> how do i do if i want a statement like this "if True then True if False then False else 100"?
11:21:39 <dmj> u_: kill <pid>
11:21:43 <monoidal> dmj: note that "do x1 <- a1; x2 <- a2 x1; x3 <- a3 x2; return x3" is equivalent to "\s -> let (x1, s1) = a1 s; (x2, s2) = a2 x1 s1; (x3, s3) = a3 x2 s2 in (x3, s3)"
11:21:48 <u_> dmj 74928
11:21:50 <u_> dmj i did
11:22:00 <dmj> klrr: you must have the same type returned, I don't think you can do that
11:22:07 <klrr> i know
11:22:17 <klrr> but i mean just the ifthenelse syntax
11:22:57 <monoidal> klrr: usually it's better to use guards, but there's -XMultiWayIf in new ghc
11:23:16 <monoidal> klrr: also in your snippet you're missing an else
11:23:38 <klrr> can i use gaurds in do expressions?
11:24:03 <Iceland_jack> klrr: yes
11:24:12 <monoidal> klrr: you can do "let x | b1 = a1; | b2 = a2" etc
11:24:12 <klrr> how? is there any example?
11:24:12 <Iceland_jack> but maybe not in the way you think
11:25:11 <Iceland_jack> > do x <- [1..10]; guard (even x); return x
11:25:13 <lambdabot>   [2,4,6,8,10]
11:25:18 <Iceland_jack> @src guard
11:25:18 <lambdabot> guard True  =  return ()
11:25:18 <lambdabot> guard False =  mzero
11:25:34 <applicative> dmj, the "State" monad is StateT identity   state is the 'constructor' that puts a function :: s -> (a,s) into StateT Identity, and runState gets it out; so they're the same as with the old State, except the capital.
11:26:07 <Iceland_jack> > do x <- [1..10]; if even x then [()] else []; return x
11:26:09 <lambdabot>   [2,4,6,8,10]
11:26:25 <applicative> dmj if we were doing StateT s IO a, we would use StateT to wrap an s -> IO (a,s) and runStateT to get out of our do block.  maybe this is impenetrably put
11:27:57 <applicative> state f = StateT (\s -> Identity (f s))  -- it just puts the stupid identity wrapper on the value so it has the form s -> m (a,s)
11:29:41 <applicative> dmj so using state to make a State value from a raw function, and runState, not runStateT puts everything in more or less the shape of the old newtype State s a = State {runState :: s -> (a , s)}
11:30:56 <applicative> it's a bit of a menace not to have the old State Reader Writer etc monads, if only for reasons of pedagogical order, but this was the only solution to a war that was abroad when I was was first learning Haskell, or around then
11:37:51 <klrr> i get this strange runtime error message "hbot: Prelude.read: no parse" what may cause this?
11:39:46 <geekosaur> you're invoking read on a string that doesn't contain a valid representation of a value of the expected type
11:39:53 <geekosaur> > read "" :: Int
11:39:55 <lambdabot>   *Exception: Prelude.read: no parse
11:40:15 <geekosaur> > read "6" :: String
11:40:17 <lambdabot>   "*Exception: Prelude.read: no parse
11:40:42 <klrr> okey
11:41:25 <Iceland_jack> > if read "True" then 1 else 0
11:41:27 <lambdabot>   1
11:43:22 <klrr> what is it that can cause this http://hpaste.org/85718 ? "> NICK hbot
11:43:22 <klrr> > USER hbot 8 * :haskell bot
11:43:24 <klrr> hbot: Prelude.read: no parse
11:43:24 <lambdabot>   <hint>:1:15: parse error on input `:'
11:43:25 <klrr> "
11:46:22 <geekosaur> line 40. (should that possibly be "ready" instead of "read"?
11:47:01 <monoidal> klrr: ^
11:47:57 <sordina3> Is there a deleteWhen function or something equally nice?
11:48:03 <ryant5000> is there any way to use qReifyInstances to get an instance, given its head?
11:48:49 <typoclass> sordina3: you mean like filter?
11:49:06 <typoclass> > filter isUpper "LOLcats"
11:49:07 <lambdabot>   "LOL"
11:49:15 <sordina3> typoclass: nope, just the first occurance.
11:49:15 <klrr> geekosaur: THANKS! :D god now i feel stupid
11:49:36 <ryant5000> i can see how to find specific instantiates of a type, but if i give it a type with a forall or unbound type variables, it complains
11:49:50 <typoclass> > delete 'l' "lolcats" -- sordina3, how about this?
11:49:52 <lambdabot>   "olcats"
11:50:07 <sordina3> typoclass: I want to supply my own test.
11:50:27 <geekosaur> :t deleteBy
11:50:29 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
11:50:45 <sordina3> my use case : deleteWhen ((==2).length)
11:50:48 <geekosaur> mm, maybe not
11:50:53 <sordina3> geekosaur: Not quite the same
11:50:54 <geekosaur> :t filter
11:50:55 <lambdabot> (a -> Bool) -> [a] -> [a]
11:51:16 <geekosaur> which is actually the opposite so you want to invert your condition
11:52:05 <sordina3> deleteBy seems like a incredibly weird function, certainly not too useful for me.
11:52:12 <typoclass> geekosaur: heh, that deleteBy thing looks puzzling, just based on the signature :-)
11:52:53 <magicman> @pl \x y -> f x (g y)
11:52:54 <lambdabot> (. g) . f
11:54:44 <sordina3> Anyway, I've just whipped up my own for now, but it seems odd that there's nothing that can do what I want.
11:56:30 <typoclass> sordina3: ah, i've got an idea. you could use break or span
11:56:34 <typoclass> > case break (\x -> length x == 2) $ words "teh lol ca ts" of (a,_:b) -> a ++ b
11:56:36 <lambdabot>   ["teh","lol","ts"]
11:57:09 <typoclass> sordina3: you just need another case for when break gives back (["stuff","stuff"],[])
11:58:33 <sordina3> Hmm I suppose...
12:01:40 <sordina3> Lol: uncurry (++) . (id *** tail) . break ((==2).length) $ words "asdf qwer as sd sg weg sd"
12:01:56 <sordina3> Not too shabby :)
12:02:50 <typoclass> sordina3: heh, cute. though i wouldn't call it more readable than the case-of version
12:03:04 <typoclass> sordina3: if you use "drop 1" instead of tail, it won't drash
12:03:11 <sordina3> Very true.
12:03:15 <sordina3> drash?
12:03:27 <sordina3> Oh yeah
12:03:28 <typoclass> sorry, crash
12:03:30 <sordina3> misshed that
12:03:55 <sordina3> Damn partial functions :)
12:05:31 <quchen> Why isn't tail changed to drop 1 anyway?
12:05:47 <quchen> I can hardly imagine people rely on the error that could be thrown
12:05:57 <typoclass> quchen: historical reasons, i presume
12:06:11 <quchen> typoclass: That doesn't mean you can't update it
12:06:49 <geekosaur> when it's in the prelude, it very nearly does mean that
12:07:14 <elliott> tail shouldn't be drop 1.
12:07:21 <quchen> geekosaur: Because people may try to catch the UserError? :s
12:07:30 <merijn> also, drop 1 is only like 2 characters longer than tail...
12:07:31 <elliott> it's asymmetric with head. you're accessing the two fields of a (:), simple as that
12:07:32 <typoclass> quchen: if we changed head and tail to be total, we couldn't issue stern warnings to beginners anymore
12:07:32 <sordina3> silent bugs are worse than noisy ones, even at runtime
12:07:46 <elliott> code that uses tail will not expect to get [] on [], generally. if you want that, there's a function for it -- drop 1
12:07:48 <chrisdone> because it would break builds
12:07:48 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
12:08:01 <elliott> now, talk :: [a] -> Maybe [a] makes sense of course...
12:08:13 <geekosaur> quchen, because changing something in the prelude and cited by the language report requires pulling teeth and sacrificing your firstborn?
12:08:16 <chrisdone> what's the point of that?
12:08:35 <merijn> chrisdone: Presumably Nothing on empty list and Just in other cases?
12:08:36 <chrisdone> elliott: what's ‚Äútalk‚Äù?
12:08:37 <elliott> *tail ::
12:08:40 <elliott> chrisdone: a typo
12:08:41 <chrisdone> ah, ok
12:08:50 <sordina3> 'safe' provides the maybeish ones anyway now. I use it all da time
12:09:08 <elliott> chrisdone: btw, did you get my message about hpaste spam? it's happened quite a few times recently :/
12:09:26 <merijn> sordina3: You should use pattern matching in almost every scenario where you wanna use head/tail
12:09:29 <quchen> I can see reasons for not changing head to returning a Maybe value. But for tail it seems very unnecessary.
12:10:03 <sordina3> merijn: Yep, but I usually don't bother when I'm doing something like a project euler problem.
12:10:04 <chrisdone> —ã–µ–∞—Ö –∏ —Ä–∞—Ä–µ–ª—ã —É—Å–µ —Ç–∞–∏–ª –µ—Ä –≤–∞—Ç
12:10:06 <chrisdone> –æ—Ö
12:10:15 <chrisdone> sorry, accidentally switched layouts
12:10:15 * typoclass sneaks into Prelude and slaps "deprecated" tags on head and tail
12:10:24 <elliott> heh
12:10:24 <merijn> typoclass: \o/
12:10:25 <chrisdone> elliott: hmm did you report the spams?
12:10:36 <elliott> chrisdone: I think other users did. but the problem is not that they are on hpaste.org
12:10:47 <elliott> the problem is that hpaste spams them in #haskell
12:10:50 <gertc> http://ide.fay-lang.org/# click demo.tailrecursive any and edit the following import Language.Fay.Prelude hiding (sum) why does it not work? it does when i rename sum to sum' in de module itself? Is it a bug or just me?
12:11:07 <chrisdone> elliott: oh right
12:11:11 <chrisdone> gertc: errr
12:11:12 <elliott> chrisdone: e.g., Ctrl+F "spam" in http://tunes.org/~nef/logs/haskell/13.04.12
12:11:21 <quchen> typoclass: Better approach: unlines . intercalate "DEPRECATED" (lines prelude)
12:11:27 <elliott> it happened for several minutes another day
12:11:51 <elliott> chrisdone: maybe just ban urls in titles/author?
12:11:59 <typoclass> quchen: all of Prelude is deprecated?
12:12:13 <chrisdone> elliott: would be an easy solution, if it catches most
12:12:22 <quchen> typoclass: You could delete the non-deprecated things manually. ;-)
12:12:25 <elliott> I doubt bots are specifically doing it to spam #haskell, so something simple should probably work :)
12:12:29 <gertc> chrisdone: yes becuase of sum, but i want to fix it by hiding sum like this import Language.Fay.Prelude hiding (sum) but it seems to hide prelude completly?
12:13:06 <Taneb> Is there a way to negate constraints
12:13:24 <chrisdone> gertc: yeah i think hiding doesn't work on this old version. will have to use sum' instead
12:13:32 <mm_freak_> Taneb: no, unless you do type-level evaluation
12:14:14 <gertc> chrisdone: ok so no need for a bug repport on github
12:15:11 <chrisdone> gertc: if you don't mind it would be good to have it noted anyway
12:15:25 <gertc> ok i am on it
12:18:48 <chrisdone> elliott: ok, added a http:// filter on the announcer
12:18:55 <chrisdone> i don't normally add spam filters, but when i do, i do it in production
12:19:20 <elliott> hehe
12:19:22 <elliott> thanks
12:19:38 * merijn wonders whether this will break mauke's pastebin copy script
12:20:13 <elliott> well, mauke's script links it in channel
12:20:18 <chrisdone> nah, mauke's script announces the links itself. i'm only ignoring in the announcer
12:20:19 <elliott> I guess it does use URLs for the title though
12:20:29 <`nand`> edwardk: http://hdiff.luite.com/gloss/pong/
12:21:31 <gertc> done https://github.com/faylang/fay-server/issues/6
12:21:50 <chrisdone> gertc: cheers =)
12:30:50 <sordina3> Are there a similar set of monad transformer stacks like RWST including MaybeT and ContT?
12:31:23 <ski_> @unmtl ContT o (MaybeT m) a
12:31:23 <lambdabot> (a -> m (Maybe o)) -> m (Maybe o)
12:31:30 <niteria> is there idris like effects library for haskell?
12:31:32 <ski_> @unmtl MaybeT (ContT o m) a
12:31:32 <lambdabot> (Maybe a -> m o) -> m o
12:32:18 <ski_> `Reader r',`Writer w',`State s' commute with each other
12:32:39 <ski_> (well, the corresponding transformer versions, i meant)
12:32:50 <syllojizm> No instance for (Enum (IO t0)) arising from the arithmetic sequence `2 .. 5' for the program (main = sum p1, p1 = [x | x <- [2..5]])
12:33:18 <syllojizm> So I understand that it returns an Enum type and sum needs a Num type, yeah?
12:33:47 <syllojizm> I haven't reached the part of the tutorial where it explains the difference between ghci and ghc, heh.
12:34:42 <applicative> syllojizm: right, try main = print $ sum pl where pl = ...
12:35:47 <applicative> syllojizm: if you open the file inside ghci, then typing main + Return with exectute it.  If you compile with e.g. ghc -O2 mymodule.hs then you can do ./mymodule to execute it.
12:35:52 <sordina3> ski_ what does that mean?
12:36:12 <sordina3> That the order of the stack doesn't matter?
12:36:19 <ski_> yes
12:36:31 <applicative> syllojizm: but even if your file has no main, you can open it in ghci and ask it to evaluate expressions made up of the terms you have defined in your module
12:36:33 <ski_> @unmtl StateT s (ReaderT r m) a
12:36:34 <lambdabot> s -> r -> m (a, s)
12:36:35 <syllojizm> hm... so basically, i was returning a Num to main and it didn't like that?
12:36:45 <ski_> @unmtl ReaderT r (StateT s m) a
12:36:45 <lambdabot> r -> s -> m (a, s)
12:36:51 <ski_> see, that's basically the same
12:37:00 <sordina3> interesting
12:37:15 <applicative> syllojizm: the reason it is rejecting the program is it is trying to understand how main which is an action, could also be a number
12:37:32 <syllojizm> ah. great. thanks
12:37:45 <ski_> @unmtl StateT sr (ContT o m) a
12:37:45 <lambdabot> sr -> (a -> sr -> m o) -> m o
12:37:46 <ski_> @unmtl ContT o (ReaderT sr m) a
12:37:47 <lambdabot> (a -> sr -> m o) -> sr -> m o
12:37:48 <applicative> syllojizm: this is in principal possible, if you gave a num and enum definition for IO actions of some kind
12:37:51 <ski_> sordina3 : how about that one ?
12:38:22 <applicative> syllojizm: but in main = print pl ...  print pl is an action, so it understands you
12:39:26 <sordina3> ski_: I'm not entirely sure what's going on with unmtl to be honest.
12:39:45 <syllojizm> i see
12:39:57 <applicative> it gives the underlying type, once shorn of all the newtype wrappers
12:40:21 <applicative> syllojizm: pl is a number, print pl is an action (IO ())
12:40:30 <ski_> sordina3 : it's unfolding definitions
12:40:37 <ski_> @unmtl ReaderT r m a
12:40:38 <lambdabot> r -> m a
12:40:42 <ski_> @unmtl StateT s m a
12:40:42 <lambdabot> s -> m (a, s)
12:40:48 <syllojizm> haskell is blowing my mind (coming from undergrad student whose experience with programming is basically 10 years of imperative languages + playing around with scheme a couple times)
12:40:49 <ski_> @unmtl ContT o m a
12:40:49 <lambdabot> (a -> m o) -> m o
12:40:56 <ski_> @unmtl MaybeT m a
12:40:56 <lambdabot> m (Maybe a)
12:41:02 <applicative> newtype ReaderT r m a = ReaderT (r -> m a)
12:41:03 <ski_> @unmtl WriterT w m a
12:41:03 <lambdabot> m (a, w)
12:41:23 <applicative> newtype WriterT w m a = WriterT (m (a,w))
12:41:26 <ski_> sordina3 : so it's basically unwrapping `newtype' constructors
12:42:26 <elliott> unmtl has a weird NonDet thing that isn't actually in mtl.
12:42:32 <elliott> this isn't relevant but it confuses me.
12:42:32 <applicative> and since the internal representation of a newtype is in theory that of the wrapped type, it's telling you what the 'real' type is, in some perhaps not too interesting sense
12:42:50 <applicative> @unmtl NonDet a b c
12:42:50 <lambdabot> forall b. ((a -> b -> b) -> b -> b) b c
12:42:57 <applicative> oo
12:43:02 <ski_> @unmtl NonDet m a
12:43:03 <lambdabot> forall b. ((m -> b -> b) -> b -> b) a
12:43:05 <ski_> hm
12:43:22 <ski_> oh, just one parameter
12:43:24 <ski_> @unmtl NonDet a
12:43:24 <lambdabot> forall b. ((a -> b -> b) -> b -> b)
12:43:41 <applicative> @unmtl NonDet a
12:43:41 <lambdabot> forall b. ((a -> b -> b) -> b -> b)
12:43:42 <ski_> @type flip (flip . foldr)
12:43:44 <lambdabot> [a] -> (a -> c -> c) -> c -> c
12:43:56 <applicative> is this a church encoded list?
12:44:00 <ski_> @type GHC.Exts.build
12:44:02 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
12:44:03 <ski_> yes
12:44:37 <ski_> it's a two-level continuation encoding, if you want to think about it from that angle
12:45:27 <ski_> the argument of type `a -> b -> b' is the success continuation, and the one of type `b' is the failure continuation
12:45:48 <applicative> ski, if youre so smart :) how do I church encode an existential type? I was thinking of the free applicative thing data FreeA f a = Pure a | forall b . FreeA (FreeA f b) (f (b -> a) or a similar type
12:46:01 <ski_> the success continuation takes a value to succeed with, and a failure (/redo) continuation, and gives a final result (really a failure continuation)
12:46:08 <applicative> or does that make no sense
12:46:13 * ski_ blinks ?
12:46:19 <ski_> (i'm so smart ?)
12:46:49 * applicative is making an implicit comparison 
12:47:28 <applicative> I was just wondering if it was obvious. I know how to church encode simple recursive types mechanically, but this suggests nothing to me.
12:47:33 <elliott> @unmtl NonDetT m a
12:47:33 <lambdabot> forall b. ((a -> m b -> m b) -> m b -> m b)
12:47:40 <ski_> applicative : well, consider `mu r. f r', aka `Mu f' -- this can be encoded as `forall r. (mu r -> r) -> r'
12:47:51 <applicative> ah NonDetT
12:48:02 <applicative> ski_ yes
12:48:04 <Taneb> NonDetT is LogicT, yeah?
12:48:11 <ski_> and that's more or less a church encoding
12:48:42 <ski_> sorry `forall r. (f r -> r) -> r', of course
12:48:47 <ski_> applicative : dually, `nu r. f r', aka `Nu f', can be encoded as `exists s. (s,s -> f s)'
12:49:31 <applicative> ski_: right thats what I do.  or put mechanically, I write it is Gadt form, replace every occurence of my datatype with r, then conjoin all those types -> r
12:50:05 <ski_> applicative : also, since `a' is iso to `forall r. (a -> r) -> r', if we have `Either a b', it's iso to `forall r. (Either a b -> r) -> r', i.e. `forall r. (a -> r,b -> r) -> r', iow `forall r. (a -> r) -> (b -> r) -> r'
12:50:21 <monochrom> (forall b. (a -> b -> b) -> b -> b) is Boehm-Berarducci encoding. at least Oleg says so. http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html
12:50:34 <applicative> ski_: yes, I know this too, the nu encoding, it was just the trouble generated by the existential b in data FreeA f a = Pure a | forall b . Free (FreeA (b -> a) (f b)
12:50:47 <dysinger> anyone in here using Nix ? https://gist.github.com/dysinger/5379773
12:51:03 <ski_> and similarly, `exists s. f x' is iso to `forall r. ((exists s. f s) -> r) -> r', is iso to `forall r. (forall s. f s -> r) -> r'
12:51:04 <dysinger> ghc-mod is busted for me in Nix.  wondered if anyone else has seen this.
12:51:08 <applicative> oh what is it the Boehm-Barducci encoding of?
12:51:22 <hpaste> suppliercraft pasted ‚Äúpenting, panas, perlu, seru‚Äù at http://hpaste.org/85727
12:51:51 <ski_> dually, `(a,b)' is iso to `exists s. (s,s -> (a,b))' is iso to `exists s. (s,s -> a,s -> b)'
12:52:10 <applicative> ski_: really what I wanted was to turn this 'free applicative' everyone was talking about into a nu sort of type, thinking this was suitable to the applicative only sort of case
12:52:31 <ski_> `forall r. f r' is iso to `exists s. (s,s -> forall r. f t)' .. which is probably *not* in some meaningful sense iso to `exists s. (s,exists r. s -> f t)' ..
12:52:58 <applicative> ok i'm starting to get this
12:53:10 <ski_> (constructively speaking)
12:53:25 <typoclass> dysinger: have you tried -v, as the thingy suggests?
12:53:47 <dysinger> typoclass: I was trying to figure out how to pass it through ghc-mod
12:54:01 <ski_> applicative : hm .. `FreeA' looks vaguely `CoYoneda'ish
12:54:17 <applicative> hm
12:54:46 <monochrom> (forall b. (a -> b -> b) -> b -> b) is Boehm-Berarducci encoding of [a]
12:55:36 <applicative> ski_: yes, I see. The paper on Free Applicative now that I think of it throws around some of the jargon found in Control.Functor.Yoneda, about coyoneda
12:55:51 <sordina3> Is it just part of lambdabot, or something that I can run inside ghci?
12:56:10 <ski_> (iirc you can run lambdabot in GHCi ..)
12:56:40 <typoclass> dysinger: i wonder if those last 2 lines mean that ghc-mod ran successfully and determined that src/Main.hs has a problem, or if they mean ghc-mod itself has a problem and didn't even look at src/Main.hs
12:56:47 <sordina3> heh I suppose, but that's a bit heavyweight.
12:56:58 <sordina3> it seems increadibly useful.
12:57:00 <monochrom> oleg explains some encodings of existentials: http://okmij.org/ftp/Computation/Existentials.html
12:57:09 <typoclass> dysinger: have you tried "ghci src/Main.hs" or some such?
12:57:24 <ski_> applicative : anyway .. i'm not sure whether anything i said helps ..
12:57:36 <dysinger> typoclass: it's ghc-mod running successfully against good compilable code & not seeing the libs that the rest of the system sees
12:57:41 <applicative> sordina what did you want in ghci? just unmtl or something?
12:57:49 <ludamad> Im having a weird issue, I have a function in a where clause 'where get = DB.docLookUp doc :: Val a => T.Text -> a' but GHC doesn't seem to want to see this as a generic function ?
12:57:57 <ludamad> I cant seem to get it to return 2 different types
12:58:33 <applicative> ski_: yes it's helping, I will think about `exists s. f x' is iso to `forall r. ((exists s. f s) -> r) -> r', is iso to `forall r. (forall s. f s -> r) -> r' and a couple other points you made.
12:58:52 <applicative> all obvious on reflection, as is usual with these things....
12:59:41 <Eduard_Munteanu> ludamad: what's the error?
13:00:05 <ludamad> Eduard_Munteanu, either     Couldn't match expected type `ObjectId' with actual type `Time.UTCTime', Or the reverse.
13:00:09 <ludamad> Depending on which one it infers first
13:00:13 <ski_> ludamad : perhaps add a type signature (as opposed to the type ascription you have there)
13:00:23 <ludamad> ok will try
13:00:56 * ski_ suspects DMR
13:01:02 <typoclass> dysinger: http://www.mew.org/~kazu/proj/ghc-mod/en/bug.html mentions that ghc-mod needs a Paths_whatever.hs file, but isn't entirely clear what that means
13:01:21 <applicative> monochrom: oh thanks for the oleg link
13:01:41 <ludamad> ski_: Worked, thanks
13:01:41 <monochrom> you're welcome
13:01:50 <monochrom> enter !list for more links!
13:01:50 <dysinger> typoclass: heer's ghc-mod compiling fine & the using the binary to fail to check itself https://gist.github.com/dysinger/5379845
13:02:07 <ludamad> not sure why GHC can't determine this is what I mean, though
13:02:15 <shachaf> ciao
13:02:19 <shachaf> !list
13:02:19 <monochrom> shachaf: http://hpaste.org
13:02:31 <Eduard_Munteanu> shachaf: ohai
13:02:39 <elliott> !list
13:02:44 <elliott> :(
13:02:47 <elliott> where is my link.
13:02:50 <typoclass> elliott: http://lol.cat
13:02:54 <elliott> does this mean monochrom has me on ignore?!
13:02:59 <monochrom> I throttle it. try again in a minute
13:03:07 <applicative> monochrom: ski_ interesting Oleg mentions      data Expr a = Val a | forall b. Apply (Expr (b->a)) (Expr b) which is close to the 'free applicative'
13:03:14 <elliott> wow, withholding information from the people
13:03:23 <shachaf> !list
13:03:23 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
13:03:29 <dysinger> typoclass: oh I'll check out the known bugs page - hadn't seen that before - thanks
13:03:31 <typoclass> dysinger: ah, that last paste mentions the same sort of thing ... "Could not find module `Paths_ghc_mod'"
13:03:32 <monochrom> no, protecting myself from flooding people
13:04:19 <ski_> applicative : btw, which version of `FreeA' was correct ?
13:04:40 <ski_> (at least one wasn't kind correct)
13:05:04 <shachaf> monochrom: I want the good link.
13:05:05 <shachaf> !list
13:05:05 <monochrom> shachaf: http://hpaste.org
13:05:08 <shachaf> :-(
13:05:12 <applicative> ski_: the paper proves they are isomorphic, they choose one, but edwardk uses the other in the free package.  I think.
13:05:38 <ludamad> ski_: ah, adding an explicit parameter to the where-defined function worked too
13:05:40 <applicative> ski_: here's free http://hackage.haskell.org/packages/archive/free/3.4.1/doc/html/Control-Applicative-Free.html
13:05:50 <Eduard_Munteanu> monochrom: why provide that !list thingy?
13:05:56 <ludamad> I suppose GHC wants to resolve it as a single value
13:05:57 <monochrom> for fun
13:06:34 <applicative> ski the paper is here http://paolocapriotti.com/blog/2013/04/03/free-applicative-functors/ it's the idea behing 'optparse-applicative'
13:06:48 <ski_> (e.g. to amuse italians ..)
13:08:29 <mjrosenb> @hoogle [Bool] -> Bool
13:08:30 <lambdabot> Prelude and :: [Bool] -> Bool
13:08:30 <lambdabot> Data.List and :: [Bool] -> Bool
13:08:30 <lambdabot> Prelude or :: [Bool] -> Bool
13:08:52 <jmcarthur> data FreeCategory a b c where Id :: FreeCategory a b b; (:.) :: FreeCategory a c d -> a b c -> FreeCategory a b d
13:09:39 <jmcarthur> just sayin
13:13:39 <jmcarthur> alternatively, this should also work:
13:13:52 <jmcarthur> data FreeCategory a b c where Id :: FreeCategory a b b; (:.) :: a c d -> FreeCategory a b c -> FreeCategory a b d
13:13:54 <jmcarthur> (i think)
13:14:08 <jmcarthur> i only played with the former because it was what i wanted at the time
13:14:33 <jmcarthur> oh of course that works if the other works
13:16:46 <Trollkastel> jmcarthur: Where a is an instance of some suitable Graph type class?
13:16:58 <niteria> does lambdabot import QuickCheck?
13:17:07 <jmcarthur> Trollkastel: why are you targetting me?
13:17:16 <ski_> @check ()
13:17:18 <lambdabot>   Not in scope: `myquickcheck'
13:17:21 <Trollkastel> jmcarthur: That FreeCategory thing you said.
13:17:30 <jmcarthur> ah
13:17:44 <niteria> i wonder how to use QuickCheck to generate Arbitrary [Int]
13:17:45 <jmcarthur> the a doesn't have to be an instance of any particular type class
13:17:50 <jmcarthur> it works regardless
13:17:53 <ski_> `a' is presumably just some category (if even that)
13:18:01 <ski_> *nod*
13:18:25 <jmcarthur> it's kind of implicitly a graph due to its kind
13:19:23 <jmcarthur> Trollkastel: sorry, i had misread what you asked as "Where is an instance of some Graph type class?"
13:19:46 * ski_ . o O ( "The free functor's left adjoint to .. the-e forgetful functor ... la la la" )
13:20:09 <jmcarthur> ski_: i have no idea what you just said :(
13:20:14 <ski_> (to the tune of "The hib bone is connected to the .. rib cage")
13:20:19 <jmcarthur> lol
13:20:30 <ski_> (er, s/hib/hip/)
13:20:35 <jmcarthur> the hip cage?
13:20:50 <ski_> hm, not iirc
13:21:05 <ski_> i was a long time since i heard the song
13:21:09 <Trollkastel> jmcarthur: Actually, I should apologize. I caught you by surprise.
13:21:55 <jmcarthur> no, in context that shouldn't have surprised me
13:23:28 <calsaverini> hi there
13:23:43 <dmj> hey
13:24:00 <calsaverini> I freshly installed haskell-platform on my pc and cabal seems not to be working with hackage
13:24:06 <niteria> @hoogle unGen
13:24:07 <lambdabot> Test.QuickCheck.Gen unGen :: Gen a -> StdGen -> Int -> a
13:24:07 <lambdabot> Data.Generics.Aliases unGeneric' :: Generic' c -> Generic c
13:24:07 <lambdabot> package FunGEn
13:24:16 <niteria> what's the Int for?
13:24:20 <ski_> size
13:24:41 <ski_> @hoogle sized
13:24:42 <lambdabot> Test.QuickCheck.Gen sized :: (Int -> Gen a) -> Gen a
13:24:42 <lambdabot> Test.QuickCheck sized :: (Int -> Gen a) -> Gen a
13:24:42 <lambdabot> package sized-types
13:30:45 <quchen> niteria: The QuickCheck generators have a size attribute attached to them. Some data type have a certain size, for example you can make a generator create lists of 10 items this way.
13:31:01 <quchen> Changing the size parameter of a generator can be helpful if you want to test your program on large data etc.
13:32:54 <niteria> what's confusing is if I generate [Int] is it the size of the list, size of ints inside or both?
13:33:08 <parcs> class Bar a; type Foo = forall a. Bar a => Bar [a]; instance Foo -- this probably shouldn't work
13:33:27 <quchen> niteria: You can't tell from the type I think, you'll have to look at the implementation. (Spoiler: it's the list's length only.)
13:33:47 <quchen> niteria: As a rule of thumb, the size parameter controls how much memory each test will consume.
13:33:59 <quchen> Making an int bigger doesn't need more memory.
13:34:07 <niteria> I see
13:34:50 <niteria> I just wanted to generate some data for criterion tests, I don't know if this is the best way
13:34:54 <quchen> I'm not sure how Integer is handled.
13:35:13 <quchen> niteria: I don't think you usually have to change the size parameter.
13:35:55 <niteria> it's not like I want to change it, unGen demands it
13:36:23 <quchen> Hm. I've never seen unGen.
13:36:49 <niteria> then how do you run Gen?
13:36:55 <quchen> What do you want to do?
13:37:08 <quchen> If all you want is sample data, there's sample'
13:37:40 <quchen> http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/Test-QuickCheck.html#v:sample-39-
13:38:10 <niteria> ok, sample' is exacly what I need
13:39:03 <niteria> s/exacly/exactly/
13:39:06 <quchen> niteria: Hmm, it seems that's for generator debugging though
13:39:14 <quchen> I'm not sure how to adjust the sample amount generated
13:39:22 <quchen> Hmmmmmmmm.
13:39:31 <edwardk> applicative, ski: equivalent doesn't mean equally useful. Twan's version keeps the 'next' 'f' in the free applicative that you need for interpretation exposed without recursion. Oerjan's requires you to walk uselessly over n levels to get to it.
13:40:07 <edwardk> I started with the simpler Oerjan version, and switched to Twan's because it is more useful for the common separated interpreter case
13:40:40 <kpreid> I'm thinking of doing some procedural image generation. Is there a current recommended library for the whole job and/or writing PNG files?
13:41:20 <__xc> what's the best function to calculate a partial sum [1..n] of (f x) sequence
13:41:28 <quchen> kpreid: JuicyPixels was mentioned recently. http://hackage.haskell.org/package/JuicyPixels
13:41:30 * jmcarthur wonders if there are simple combinators that would allow me to write "f a b c" (with appropriate combinators sprinkled in) to mean "\x y z -> f (a x) (b y) (c z)"
13:41:35 <quchen> kpreid: It didn't make its way into the platform though.
13:41:44 <int-e> __xc: scanl in conjunction with map?
13:41:45 <niteria> quchen: what's worse is that it seems like sample' generates values with increasing variance
13:41:48 <__xc> :t mapAccum
13:41:50 <lambdabot>     Not in scope: `mapAccum'
13:41:50 <lambdabot>     Perhaps you meant one of these:
13:41:50 <lambdabot>       `IM.mapAccum' (imported from Data.IntMap),
13:41:57 <quchen> __xc: Partial sums can be done with scanl
13:42:00 <int-e> > scanl (+) 0 $ map (^2) [1..10]
13:42:02 <lambdabot>   [0,1,5,14,30,55,91,140,204,285,385]
13:42:15 <niteria> so if I generate [Int] I first get lists with {1,0,-1}
13:42:39 <__xc> :t scanl
13:42:40 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
13:43:05 <int-e> > scanl f a [b,c,d]
13:43:07 <lambdabot>   [a,f a b,f (f a b) c,f (f (f a b) c) d]
13:43:35 <int-e> > scanl (+) a [b,c,d]
13:43:37 <lambdabot>   [a,a + b,a + b + c,a + b + c + d]
13:44:24 <__xc> ( needed just the nth term though)
13:44:39 <__xc> S(n)
13:46:15 <quchen> __xc: Then truncate your list?
13:46:27 <quchen> > foldl1' (+) $ take 4 [1..]
13:46:29 <lambdabot>   10
13:46:33 <quchen> 4th partial sum
13:46:36 <int-e> > sum (take 4 [a,b,c,d,e])
13:46:39 <lambdabot>   can't find file: L.hs
13:46:44 <int-e> :/
13:46:49 <int-e> > sum (take 4 [a,b,c,d,e])
13:46:51 <lambdabot>   0 + a + b + c + d
13:47:20 <quchen> niteria: Call me stupid, but I can't find a way of getting data out of a Gen
13:48:48 * hackagebot hspec-discover 0.2.0 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-0.2.0 (SimonHengel)
13:50:59 <quchen> niteria: This may be interesting: http://www.haskell.org/haskellwiki/QuickCheck_as_a_test_set_generator
13:51:09 <aristid> quchen: you don't need to get data out of Gen.
13:51:12 <aristid> it's a monad
13:51:35 <aristid> if you really really want to, you can though.
13:51:45 <quchen> aristid: niteria wants to use it to generate test data
13:51:52 <aristid> @hoogle sample
13:51:53 <lambdabot> Control.Concurrent.SampleVar module Control.Concurrent.SampleVar
13:51:53 <lambdabot> Control.Concurrent.SampleVar data SampleVar a
13:51:53 <lambdabot> Text.Html sample :: Html -> Html
13:51:59 <aristid> lambdabot: no, wrong
13:52:02 <quchen> aristid: Sample has a fixed size output.
13:52:04 <aristid> @hackage QuickCheck
13:52:04 <lambdabot> http://hackage.haskell.org/package/QuickCheck
13:52:25 <aristid> quchen: look at the implementation of sample to find out how to do it
13:52:50 <quchen> aristid: I was trying to get around that ;-)
13:52:55 <aristid> quchen: heck, the unGen constructor is even mentioned in the haddocks...
13:53:02 <aristid> http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/Test-QuickCheck-Gen.html
13:54:16 <__xc> > let myseq n = [1..n] in myseq 4
13:54:19 <lambdabot>   [1,2,3,4]
13:55:10 <quchen> aristid: Oh, so it's unGen after all? Wonderful, then I just spent 10 minutes confusing niteria.
13:55:13 <quchen> :x
13:55:33 <aristid> quchen: tsk.
13:55:49 <quchen> :-(
13:55:52 <quchen> Sorry............
13:57:04 <niteria> generating 1000000 Ints takes 8s
13:57:39 <Cale> niteria: Is that considered good or bad? :)
13:57:56 <Cale> StdGen usually isn't really considered fast as far as PRNGs go.
13:57:57 <quchen> niteria: C has around 10^9 per second I think.
13:58:08 <quchen> GPU can get up to ... more.
13:58:10 <Eduard_Munteanu> BogoMIPS FTW!
13:58:12 <Cale> But it's serviceable in most cases.
13:58:25 <quchen> I have a RNG thermometer in my office of the guy who codes GPUs next to me.
13:58:31 <quchen> I'll look it up on Monday. :-)
13:58:54 <niteria> that's pretty bad
13:59:08 <quchen> 10^7?
13:59:10 <aristid> quchen: 1 nanosecond per random number? i.e. maybe 3 instructions... yeah should be possible
13:59:15 <quchen> How much data do you want?
13:59:16 <Eduard_Munteanu> They should make a bogocoin... something that requires a lot of bogomips to mine.
13:59:25 <quchen> aristid: I think he has it down to 1.5 instructions per number or something.
13:59:35 <Cale> niteria: Well, the amount of time spent on your tests will often be more than that, provided you even bother to do a million of them.
13:59:42 <jfischoff> So I am creating an options record, which is polymorphic over a functor, like data Options f = Options { a :: f Int}
13:59:49 <aristid> quchen: won't be cryptographic quality PRNG
14:00:08 <Eduard_Munteanu> Well, there are cheap USB real PRNGs.
14:00:11 <niteria> maybe I need to compile it with some flags?
14:00:21 <Eduard_Munteanu> s/P//
14:00:24 <Cale> niteria: Well, if you're not using -O2, you should be
14:00:32 <Cale> (or at least -O)
14:00:37 <typoclass> Eduard_Munteanu: unPRNGs
14:00:43 <quchen> aristid: Not sure. He needs it for physics simulations, so the requirements are quite high, although different maybe.
14:00:44 <Eduard_Munteanu> http://www.entropykey.co.uk/  -- this seems promising
14:00:45 <paolino> with DataKinds I have    data Tree (n :: Nat) a where Node :: a -> [Tree (Succ n) a] -> Tree n a, is it possible without GADTs ? I have an OpenKind error.
14:00:54 <Cale> It's not worth even thinking about the performance of Haskell code which hasn't been compiled with -O
14:01:06 * Eduard_Munteanu has to go afk though
14:01:11 <Cale> Because the difference in some cases is really drastic
14:01:25 <jfischoff> Usually it is this, type LastOptions = Options Last, but in the end it is FinalOptions = Options Identity
14:02:26 <jfischoff> anyway, I want to traverse my record and change it from LastOptions to FinalOptions. Is there a traversable type class for (* -> *) -> * kinds?
14:02:30 <quchen> Eduard_Munteanu: There are cheap non-USB real RNGs. /dev/random :-)
14:02:46 <Eduard_Munteanu> quchen: that's slow as hell, in comparison
14:03:00 <quchen> Eduard_Munteanu: That's slow as hell even without comparison :>
14:03:08 <Eduard_Munteanu> :)
14:03:16 <jfischoff> that's one question. The other is what is a good way to store options? Is my data Options f = Options { a :: f Int} a good approach?
14:04:00 <aristid> Eduard_Munteanu: nom nom entropy
14:04:16 <aristid> jfischoff: what would f be?
14:04:41 <jfischoff> its either Last of Identity
14:09:20 <finnrobi> Does anyone have an introduction to automated testing (setting up quickcheck/hunit as a part of the cabal build process)?
14:12:24 <xplat> i finally figured out the answer to 'if haskell is so good why don't i use it for everything?'
14:13:15 <copumpkin> xplat: what is it?
14:13:25 <xplat> the answer is that haskell has such a good ability to create abstractions that i can take all the easy parts out of my programs, leaving only hard parts
14:14:02 <xplat> then because there are no easy parts, i lose momentum.  so i end up making faster progress when i use another language, ironically
14:14:16 <Mathnerd626> no, some things are not abstracted well
14:14:25 <Mathnerd626> that's why they're "hard"
14:14:57 <Mathnerd626> ideal program is 0 lines of code :-)
14:15:21 <xplat> like, i just got good enough at porting C to haskell that it's no longer a huge headache where i have to earn each and every line.  so now i'm writing a program to do it automatically.
14:15:23 <Eelis> Mathnerd626: but then how do you figure out what the program does?
14:15:28 <typoclass> Mathnerd626: well in haskell, it will be 60 lines of imports of course. but 0 lines of active code
14:15:53 <xplat> Eelis: the compiler figures out what the program does by monitoring your brain with fMRI
14:15:55 <quchen> import import import import main=defaultMain
14:15:57 <aCube> typoclass: 10 lines of template haskell
14:16:15 <Eelis> xplat: that would make for very buggy programs :'(
14:17:13 <xplat> Eelis: if you think a bug it shocks you
14:17:40 <Mathnerd626> bugs == not thinking, people don't actively put bugs in
14:17:55 <mauke> >implying I don't actively put bugs in
14:18:08 <xplat> Mathnerd626: what's premature optimization then?
14:18:22 <Mathnerd626> xplat: just that :p
14:18:44 <xplat> it's people working harder to add more bugs
14:19:09 <crdueck> is it possible to map a monadic action over a Repa Array with access to its Shape index? I need something like mapMIndexed_ :: (Monad m, Shape sh, Source r e) => (sh -> e -> m b) -> Array r sh e -> m ()
14:20:45 <yunxing> hi, could someone explain this a little bit? let f1 = (+) , f1's type is : f1 :: Integer -> Integer -> Integer.shouldn't it be f1 :: Num a => a -> a -> a. ???
14:21:15 <paolino> it's ghci
14:21:49 <aCube> yunxing: try running ghci with -XNoMonomorphismRestriction
14:22:12 <niteria> hm, there is an easier way to get random [Int], there's Random class and it takes 5s instead of 8s with that
14:22:15 <yunxing> aCube: Thanks, I can look that up
14:22:19 <yunxing> paolino: Thanks!
14:22:34 <aristid> isn't that pretty much the most damning criticism of the monomorphism restriction? how it single-handedly destroys equational reasoning? :)
14:22:34 <typoclass> yunxing: here is some explanation http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:23:15 <Cale> The MR is dumb and it should be disabled by default, and turned into an optional warning which you can turn on if you want it.
14:23:18 <typoclass> yunxing: if you do ":set -Wall" in ghci, or compile with "ghc -Wall", you will get a warning about this. "Defaulting to Integer"
14:24:40 <xplat> yes, it's kind of like Monad not being derived from Functor.  'the committee should have known better, but they didn't.  seemed like a good idea at the time.'  nobody really wants to defend it.
14:24:50 <yunxing> Thanks guys. Another question is... if I let f1 a b c d = (a.b).(c.d), should it be the same as f2 = (.).(.) ??
14:24:52 <quchen> Cale: And why isn't it changed? Haven't heard a positive thing about it
14:25:01 <quchen> (Or felt, for that matter)
14:25:10 <aristid> xplat: were you also fooled by the april fools that monad would be derived from functor again? :)
14:25:52 <Cale> quchen: Because language standardisation is often more counterproductive than helpful.
14:25:59 <xplat> aristid: missed it actually
14:26:05 <paolino> @type (.).(.)
14:26:06 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:26:07 <aristid> xplat: shame:)
14:26:31 <typoclass> @unpl (.).(.) -- yunxing
14:26:32 <lambdabot> (\ i b c f -> i (b c f))
14:26:48 <Cale> quchen: But we've seen some changes lately which have gone in the face of Haskell 98 without requiring special flags or anything, so that's good
14:27:00 <mjrosenb> @hoogle Ordering -> Ordering -> Ordering
14:27:01 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
14:27:01 <lambdabot> Prelude asTypeOf :: a -> a -> a
14:27:01 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
14:27:49 <quchen> Cale: Like what?
14:32:29 <typoclass> sometimes hoogle really impresses you, out of nowhere. that Monoid instance is spot-on, isn't it
14:34:49 <ion> And sometime it really lets you down. :-P
14:34:54 <ion> s
14:39:25 <typoclass> ion: it does seem to search lots more packages these days. i remember when it didn't find stuff even in packages that come with ghc ('unix' ...). in those days it practically was only reliable inside of 'base'. but that's really changed, it seems
14:39:45 <nade> Hey all, I've been trying to do some JSON processing with the Aeson library. The decode function of the library has a type of FromJSON a => ByteString -> Maybe a. The JSON I want to deal with is in a JSON file and I use the readFile function from Data.ByteString to get its contents. When I try decode the contents with something like liftM decode (readFile jsonfile) I get an error complaining about the ByteString type. Earlier I had been having problems
14:39:45 <nade> conflicting installs of ByteString, and I tried hiding the packages with ghc-pkg but I'm not clear which I should be removing
14:40:26 <ion> @hoogle (<%~)
14:40:27 <lambdabot> No results found
14:40:51 <typoclass> ion: ... iiiiit's not perfect :-)
14:41:28 <supki> nade: aeson decodes from lazy bytestrings
14:41:48 <nade> supki: so import Data.ByteString.Lazy?
14:41:49 <typoclass> nade: hello, could you post the precise error message(s) you're getting to hpaste.org?
14:41:53 <supki> nade: i.e. you need readFile from Data.ByteString.Lazy
14:42:46 <mietek> Is there a nice way to build a 2D array from row ByteStrings?
14:42:59 <mietek> I thought BS is now built on top of UArray
14:44:12 <c_wraith> mietek: no, BS is built on ByteArray# primitives
14:44:35 <shachaf> No, ByteString is built on malloc()
14:44:58 <typoclass> @hoogle malloc ()
14:44:58 <lambdabot> System.Mem performGC :: IO ()
14:44:58 <lambdabot> Foreign.C.Error resetErrno :: IO ()
14:44:58 <lambdabot> Control.Concurrent yield :: IO ()
14:45:03 <shachaf> Text is built on MutableByteArray#
14:45:20 <mjrosenb> > let (<>) = compare in 2 <> 3
14:45:22 <lambdabot>   LT
14:45:32 <mjrosenb> 2 <> 3
14:45:34 <xplat> @hoogle malloc
14:45:34 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
14:45:34 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
14:45:34 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
14:45:37 <nade> typoclass: http://hpaste.org/85728
14:45:40 <cmccann> and they're all built on lots of magic hash apparently
14:45:47 <mjrosenb> > 2 <> 3
14:45:49 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:45:49 <lambdabot>    (GHC.Num.Num a0)
14:45:49 <lambdabot>      a...
14:46:30 <typoclass> mjrosenb: since recent ghc versions, <> is a synonym for mappend
14:47:11 <mietek> Is there a way to build any of the array types from a Ptr?
14:47:14 <xplat> > 2 `compare` 3
14:47:15 <lambdabot>   LT
14:47:28 <mjrosenb> typoclass: and synonym is different from just a regular definition?
14:47:51 <shachaf> No, it's just a regular definition for mappend.
14:48:04 <typoclass> mjrosenb: no, not at all :-) afaik they just added into the source file "(<>) = mappend", or something very like it
14:48:14 <nade> supki: I get the same error
14:48:22 <mjrosenb> typoclass: still doesn't explain this: https://gist.github.com/5380199
14:48:42 <typoclass> mjrosenb: i meant, as a heads-up. you said "(<>) = compare", and that could be confusing to readers :-)
14:48:42 <shachaf> mjrosenb: That's the monomorphism restriction.
14:48:50 <shachaf> It's defaulting (<>) to () -> () -> ()
14:48:58 <supki> nade: well, yeah, you are loading 2 different versions of bytestring, that's not gonna work
14:49:06 <__xc> > let (;)) = (+) in 2 ;) 3
14:49:08 <lambdabot>   <hint>:1:6: parse error on input `;'
14:49:38 <supki> nade: you need to unregister 0.10.0.1 one and reinstall everything that breaks
14:49:45 <nade> supki: I have 0.10.0.1, and 0.10.0.2 installed, shoud i them?
14:49:56 <nade> hide them
14:50:01 <xplat> whose idea was defaulting to ()?  that hardly ever seems to help
14:50:15 <shachaf> Well, you have to default to something.
14:50:26 <cmccann> xplat: it's a GHCi thing mostly
14:50:26 <c_wraith> I think it only defaults to () with ExtendedDefaultingRules
14:50:29 <nade> supki: will I have to remember to expose them sometime in the future?
14:50:32 <mietek> How would you read in a 2D array from file?
14:50:34 <shachaf> show []
14:50:38 <supki> nade: I assume you have them because something depends on them, I don't think just hiding will be enough
14:50:40 <xplat> > let (‚ò∫) = (+) in 2 ‚ò∫ 3
14:50:40 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
14:50:48 <cmccann> mietek: what kind of array?
14:50:49 <yunxing> Hi, I'm still quite confused about how to explain (.).(.)     could someone throw light to me ??
14:50:55 <mietek> cmccann: Char8
14:51:03 <cmccann> mietek: no, what array type
14:51:05 <nade> supki: whats the difference between hiding and unregistering?
14:51:18 <mietek> cmccann: immutable and unboxes
14:51:20 <mietek> unboxed*
14:51:25 <xplat> :t (.)
14:51:26 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:51:27 <cmccann> I mean, ByteString is basically an array of bytes
14:51:44 <mietek> Yes, but indexing in a 1D string posing as a 2D array is annoying
14:52:04 <cmccann> ok, so you want to convert it to something from the array package
14:52:11 <cmccann> though note that the indexing stuff is all the Ix class
14:52:19 <mietek> And going from a ByteString through a list of associations or elements feels inefficient
14:52:19 <cmccann> and you can use that with anything
14:52:31 <typoclass> > sortBy (comparing length <> compare) $ words "lol cats meow yes" -- mjrosenb, here is an example for this. it sorts first by length, and on ties alphabetically (the regular 'compare' for lists of Char). note <>, meaning mappend
14:52:32 <lambdabot>   ["lol","yes","cats","meow"]
14:52:56 <shachaf> Of all the examples of mappend, that one?
14:52:57 <yunxing> i though the (.) takes two arguments, (b -> c) -> (a -> b). But in this case of (.).(.) the central . takes two arguments, both type is (b -> c) -> (a -> b) -> a -> c
14:53:03 <yunxing> thought*
14:53:04 <xplat> last (.) is (b -> c)  ->  ((a -> b) -> (a -> c))
14:53:11 <mietek> cmccann: anything? I don't see a way to Ix with ByteStrings; am I missing something?
14:53:15 <typoclass> shachaf: you mean my thing?
14:53:35 <supki> nade: well, unregistering actually removes package from ghc database
14:53:44 <Cale> yunxing: The easiest way to understand (.).(.) (I think) is to understand fmap . fmap, and then realise that (.) is a special case of fmap
14:53:45 <cmccann> mietek: the Ix class does the conversion from arbitrary index types to a 0-based integer index
14:53:52 <supki> nade: several bytestring versions will cause endless pain =)
14:54:00 <Cale> yunxing: fmap :: (a -> b) -> (f a -> f b)
14:54:04 <typoclass> shachaf: i made it because mjrosenb was originally @hoogle'ing for Ordering -> Ordering -> Ordering :-) and (correctly) finding that Monoid instance
14:54:11 <shachaf> I,I sortBy (comparing length <> comparing void)
14:54:19 <shachaf> @ty sortBy (comparing length <> comparing void)
14:54:21 <lambdabot> [[a]] -> [[a]]
14:54:24 <shachaf> Um...
14:54:26 <Cale> or rather to be more precise:  fmap :: (Functor f) => (a -> b) -> (f a -> f b)
14:54:26 <shachaf> That's backwards.
14:54:34 <shachaf> @ty sortBy (comparing void <> compare)
14:54:36 <lambdabot> (Functor f, Ord (f a), Ord (f ())) => [f a] -> [f a]
14:54:50 <Cale> yunxing: So, fmap . fmap :: (Functor f, Functor g) => (a -> b) -> (g (f a) -> g (f b))
14:54:59 <xplat> first (.) is ((a -> b) -> (a -> c))  ->  ((x -> (a -> b)) -> (x -> (a -> c)))
14:55:12 <yunxing> Cale: if a function's signature is (a->b)->c, it is equivalent to a -> (b->c) because associative ?
14:55:13 <cmccann> mietek: anyway, there's a variety of things you can do, IOUArray has its own file I/O functions for instance
14:55:21 <Cale> no, (->) isn't associative
14:55:25 <cmccann> mietek: and you can make a storable array from a ForeignPtr
14:55:35 <mjrosenb> shachaf: derp,  that error message could probably be better.
14:55:36 <Cale> But a -> b -> c means a -> (b -> c), because it associates to the right by convention
14:55:49 * typoclass doesn't even know what 'comparing void' is. is that the void from Control.Monad ...
14:55:51 <nade> supki: well ghc-pkg list bytestring only shows 0.10.01 and 0.10.0.2. But ghc-pkg | grep "bytestring" gives me bytestring-0.9.2.1
14:55:58 <yunxing> Cale, this makes sense
14:56:08 <shachaf> mjrosenb: It's an odd combination of behaviors that mostly shows up in ghci.
14:56:21 <shachaf> mjrosenb: I heard a rumour ghci will be getting NoMonomorphismRestriction by default?
14:56:22 <Cale> yunxing: So, if we choose g = (->) e and f = (->) e', where (->) a b = a -> b
14:56:44 <Cale> then fmap . fmap :: (a -> b) -> (e -> e' -> a) -> (e -> e' -> b)
14:57:09 <yunxing> Cale, xplat, sorry, i need some time to think about it
14:57:35 <nade> supki: that is ghc-pkg list | grep "bytestring" gives me 0.10.0.1, 0.10.0.2, and 0.9.2.1
14:57:40 <Cale> yunxing: Well, in understanding my case, it probably helps to examine why fmap specialises to (.)
14:58:47 <flebron> What is the idiomatic way of saying, if I have readFrac :: ByteString -> (Int, ByteString), where the second parameter is the rest of the ByteString (unread), "do readFrac k times"?
14:58:57 <supki> nade: okay, and 0.9.2.1 comes with ghc I believe, so you should unregister 0.10.0.1 and 0.10.0.2 (and rebuild everything it says will be broken)
14:59:10 <aavogt> @type unfoldr
14:59:12 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:00:35 <nade> supki: will that cause problems in the future though? I'm fairly new to programming, and Haskell in particular, but isn't it a good idea to keep your packages up to date?
15:00:36 <flebron> :OOO
15:00:44 <flebron> So that's what that guy does!
15:01:10 <flebron> (In my specific case, input has a well defined format, so I'll always output a Just.). Many thanks!
15:01:14 <aavogt> @type let  readFrac :: ByteString -> (Int, ByteString); readFrac = undefined in   take 5 . unfoldr (Just . readFrac)
15:01:16 <lambdabot>     Not in scope: type constructor or class `ByteString'
15:01:16 <lambdabot>     Perhaps you meant one of these:
15:01:16 <lambdabot>       `BSC.ByteString' (imported from Data.ByteString.Char8),
15:01:25 <mjrosenb> @hoogle [a] -> Bool
15:01:26 <lambdabot> Prelude null :: [a] -> Bool
15:01:26 <lambdabot> Data.List null :: [a] -> Bool
15:01:26 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
15:01:58 <ab9rf> @src null
15:01:59 <lambdabot> null []     = True
15:01:59 <lambdabot> null (_:_)  = False
15:02:06 <quchen> nade: I had the same problem a couple of days ago, having incompatible ByteString libs installed. Unregistering the new one helped.
15:02:19 <supki> nade: well, in general, yes, but for specific set of packages that come with ghc it's not
15:02:26 <quchen> nade: When you're doing the unregistering, it'll tell you what packages will be broken - unregister those as well.
15:02:38 <supki> nade: you upgrade bytestring when upgrading ghc
15:03:02 <quchen> nade: When everything's clean again, install an older version of the package you wanted to install in the first place that doesn't need a new ByteString.
15:03:04 <flebron> Hrm... well... unfoldr will keep going for a long time... I actually wanted it to stop after k steps :s
15:03:16 <flebron> (And return the unread stuff.)
15:03:53 <cmccann> flebron: replicateM?
15:03:59 <quchen> flebron: What you're doing looks a little state-y too. How about readFrac = state ... and then replicateM?
15:04:01 <cmccann> after wrapping it in State
15:04:09 * flebron hasn't used State yet
15:04:13 <flebron> But yes, that could well be it.
15:04:13 <cmccann> since that's what "s -> (a, s)" is
15:04:26 <flebron> Yes, it seemed like that. I know nothing of State though :s
15:04:37 <cmccann> it would turn into "State ByteString Int"
15:04:58 <flebron> (I am reading testcases off a ByteString, each testcase has an int n, and then n lines follow it.)
15:05:05 <nade> quchen: gah, that seems like a headache. Especially reverting back to older packages. supki: Are you suggesting that my version of GHC is the problem then?
15:05:27 <quchen> nade: Well, it'll take a couple of minutes, but the it's all good
15:05:30 <hpaste> niteria pasted ‚ÄúsortByIntMap‚Äù at http://hpaste.org/85730
15:05:41 <niteria> ^ am I doing something silly here?
15:05:49 <niteria> this is slow
15:05:51 <nade> quchen: okay, I'll give it a shot
15:06:09 <dmj> using the state monad to make html is pretty much the coolest thing ever.
15:06:57 <niteria> dmj: can you link to example?
15:07:00 <nade> quchen: eh. it'll break repa apparently... I remember that was a pain in the ass to get working...
15:07:06 <supki> nade: nah, it's fine if you avoid to upgrade these core packages
15:07:26 <flebron> How would I use State for this? (Excuse my newbness)
15:07:30 <supki> nade: you probably will need to install older version of repa or something
15:07:46 <dmj> niteria: one sec
15:08:16 <cmccann> > runState (replicateM 5 (state (splitAt 2))) [1..15] -- flebron
15:08:17 <lambdabot>   ([[1,2],[3,4],[5,6],[7,8],[9,10]],[11,12,13,14,15])
15:08:23 <cmccann> :t splitAt 2
15:08:24 <lambdabot> [a] -> ([a], [a])
15:08:51 <flebron> OK, so the fst part of that tuple is the result that will be accumulated?
15:09:12 <yunxing> Cale: I though (.) takes two arguments of (a->b) , but fmap's type is (a -> b) -> f a -> f b how can it possible fit into the the type signature?
15:09:29 <Cale> yunxing: Well, we need f a = e -> a
15:09:41 <Cale> yunxing: which turns out to be a valid choice of f
15:09:58 <hpaste> dmj pasted ‚Äúdas html‚Äù at http://hpaste.org/85731
15:09:58 <xplat> yunxing: the 'a' and 'b' in the argument of (.) can be anything
15:09:58 <typoclass> cmccann: woah, that's a nice example, kudos
15:09:58 <flebron> f a = a -> b i'd imagine?
15:10:12 <Cale> and when we make that substitution, we get  (a -> b) -> (e -> a) -> (e -> b)
15:10:14 <cmccann> > runState (replicateM 5 (state (first read . splitAt 3))) "12345678912345678912345" :: ([Int], String) -- flebron
15:10:16 <lambdabot>   ([123,456,789,123,456],"78912345")
15:10:18 <Cale> which is exactly the type of composition
15:10:18 <yunxing> so it becomes (a -> b) -> (e -> a) -> (e ->b)
15:10:20 <dmj> niteria: keep in mind I just learned about the State monad a few days ago
15:10:20 <cmccann> does that make things clearer?
15:10:21 <Cale> yes
15:10:30 <cmccann> :t first read . splitAt 3
15:10:31 <lambdabot> Read c => [Char] -> (c, [Char])
15:10:43 <dmj> niteria: all we need now is our own web server to deliver this html with
15:10:47 <flebron> :src first
15:10:48 <xplat> yunxing: oh, you're talking about the other direction
15:10:55 <quchen> yunxing: In the box analogy, a function "e ->" is a box that contains the eventual result of a computation that starts with an "e". fmap changes the value in the box by adding a function to the chain.
15:11:00 <flebron> :t first
15:11:01 <cmccann> :t first
15:11:02 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
15:11:02 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
15:11:04 <cmccann> heh
15:11:21 * flebron sees the word arrow and shuts down
15:11:22 <cmccann> read that as (a -> b) -> (a,c) -> (b,c)
15:11:46 <typoclass> > first succ (42,37) -- flebron
15:11:47 <lambdabot>   (43,37)
15:11:50 <quchen> flebron: set a = (->) and it'll be simple.
15:11:54 <flebron> oh
15:12:10 <cmccann> flebron: I was just doing that to have a more interesting function to run anyway
15:12:12 <flebron> first f (a, b) = (f a, b)
15:12:14 <yunxing> but...my question is, for fmap.fmap, the middle (. ) takes two arguments of (b->c) and (a->c), fmap doesn't  seems like can fit into this
15:12:17 <xplat> dmj: have you tried Blaze.Builder for that?  it might be even cooler
15:12:21 <niteria> dmj: that's nice, I wonder if you could produce HTML tree this way
15:12:29 <quchen> :t first `asAppliedTo` (undefined :: a -> b)
15:12:31 <lambdabot> (b -> c) -> (b, d) -> (c, d)
15:12:36 <ab9rf> :t fmap.fmap
15:12:38 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:12:39 <yunxing> (b->c) and (a-b) *
15:12:43 <flebron> I'll give it a shot with ByteString, thanks :)
15:12:48 <flebron> @src asAppliedTo
15:12:48 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:12:51 <nade> supki: well I think that my ghc isn't up to date. What would be the draw backs to updating? 7.4.2
15:12:55 <flebron> :t asAppliedTo
15:12:56 <lambdabot> (t -> b) -> t -> t -> b
15:12:58 <cmccann> flebron: you already have a function to use with a type shaped like (a -> (b, a))
15:13:05 <flebron> Yep
15:13:12 <quchen> flebron: asAppliedTo is const with a specialized type
15:13:31 <xplat> dmj: http://jaspervdj.be/blaze/
15:13:34 <cmccann> where is asAppliedTo from? does it have any use outside of GHCi/lambdabot?
15:13:53 <quchen> flebron: It doesn't really need an implementation, it's just used by Lambdabot for specializing functions. In my example above, I used it to specify that I want "Arrow -> function"
15:14:09 <quchen> cmccann: I don't think it exists anywhere else, no
15:14:12 <cmccann> I know asTypeOf is occasionally useful
15:14:27 <cmccann> ok, just wondering.
15:14:44 <quchen> cmccann: I remember wasting some time on searching for it before someone told me in here :-D
15:14:58 <cmccann> haha
15:15:05 <dmj> xplat: Blaze is cool, but it's nice to know how it works under the hood. What's the simplest way to make a web server in haskell?
15:15:28 <dmj> Network.CGI?
15:15:33 <quchen> Speaking of Blaze, is it a monad yet?
15:15:37 <typoclass> quchen: i dimly remember that the implementation is "asAppliedTo = undefined" or something like that :-) it really only needs a type signature
15:15:37 <quchen> Can we like it now?
15:15:51 <hpc> typoclass: = const
15:16:01 <quchen> typoclass: Yeah that'll do as well.
15:16:15 <quchen> hpc: No, it's not const. The type is specialized. It won't work with const alone.
15:16:34 <typoclass> @type asAppliedTo
15:16:35 <lambdabot> (t -> b) -> t -> t -> b
15:16:39 <hpc> pah
15:16:48 <quchen> @ty first `const` (undefined :: a -> b)
15:16:50 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
15:16:51 <typoclass> @type asAppliedTo `asAppliedTo` const
15:16:52 <hpc> asAppliedTo f = const
15:16:53 <lambdabot> (t -> b -> t) -> t -> t -> b -> t
15:16:54 <quchen> @ty first `asAppliedTo` (undefined :: a -> b)
15:16:56 <lambdabot> (b -> c) -> (b, d) -> (c, d)
15:17:02 <typoclass> @type asAppliedTo `asAppliedTo` asAppliedTo
15:17:03 <xplat> dmj: depends what you mean by simple.  there's no simple way to make a 'real' webserver from scratch.  if you want to look inside, Network.CGI's haskell parts are simpler but the real server's like snap's are simpler overall
15:17:03 <lambdabot> ((t -> b) -> t -> t -> b) -> (t -> b) -> (t -> b) -> t -> t -> b
15:17:07 <hpc> or something along those lines
15:17:16 <xplat> dmj: (including the non-haskell parts)
15:17:19 <cmccann> @src asTypeOf
15:17:19 <lambdabot> asTypeOf = const
15:17:21 * ab9rf swats typoclass 
15:17:24 <cmccann> :t asTypeOf
15:17:25 <lambdabot> a -> a -> a
15:17:27 <cmccann> same idea
15:18:51 <dmj> xplat: if snap doesn't use CGI what does it use?
15:19:02 <hpc> snap is the server
15:19:27 <niteria> it uses sockets and stuff
15:19:28 <hpc> to use CGI, your scripts are below a server like apache or nginx
15:19:50 <hpc> snap does what apache does, and serves your pages directly
15:19:59 <hpc> (or however you program it)
15:20:08 <dmj> hpc: i see, so CGI is just an implementation of sockets that adhere to to http spec? is that fair?
15:20:40 <hpc> CGI is the specification of how apache/nginx exposes information to the lower script
15:20:45 <xplat> dmj: no, CGI is a specification of how a page-generating program communicates to a webserver on the same box
15:21:02 <xplat> dmj: in order to give the webserver pages to serve
15:21:15 <niteria> isn't WAI similar to CGI?
15:21:15 <hpc> i suggest you write a website that uses absolutely no existing libraries
15:21:23 <hpc> and just does CGI on an existing webserver
15:21:32 <hpc> it will teach you a lot about how things work
15:22:04 <typoclass> tangentially, i've sometimes wondered if an unfoldr variant without the Maybe would be useful. it'd give infinite lists of course
15:22:06 <dmj> xplat: ok, so the webserver receives a request, then asks cgi for the proper page, gets it and then responds?
15:22:13 <typoclass> > let iterate2 f x = out : iterate2 f xn where (out, xn) = f x in takeWhile (not . null) $ iterate2 (splitAt 3) [1..19] -- example
15:22:14 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19]]
15:22:22 <hpc> :t unfoldr
15:22:24 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:22:26 <quchen> hpc: Isn't a webserver just a program that executes system commands? (Unless the website is built-in of course, as possible with snap etc)
15:22:46 <hpc> :t \f -> map fst . iterate f
15:22:47 <lambdabot> ((b, b1) -> (b, b1)) -> (b, b1) -> [b]
15:22:49 <dmj> xplat: nm I see, its a specification
15:23:01 <hpc> :t \f -> map fst . iterate (f . snd)
15:23:02 <lambdabot> (b1 -> (b, b1)) -> (b, b1) -> [b]
15:23:02 <eikke> damn, optparse-applicative is scary
15:23:10 <quchen> eikke: ?
15:23:46 <parcs> @ty evalState . sequence . repeat . state
15:23:48 <lambdabot> (s -> (a, s)) -> s -> [a]
15:24:10 <hpc> heh
15:24:11 <eikke> quchen: trying to define a (non-trivial) parser, failing hard :)
15:24:13 <xplat> niteria: WAI serves a similar r√¥le to CGI but in-process and haskell-specific, unlike CGI which is out-of-process and (mostly) language-agnostic
15:25:06 <typoclass> hpc: interesting! though the second (b, b1) means that it's not the same type as the iterate2 thingy
15:25:09 <niteria> so WAI is more like Rack
15:25:27 <parcs> > (evalState . sequence . repeat . state) (splitAt 3) [1..19]
15:25:29 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19],[],[],[],[],...
15:26:03 <latro`a> @ty \f x -> map fst $ iterate f x
15:26:09 <lambdabot> ((b, b1) -> (b, b1)) -> (b, b1) -> [b]
15:26:18 <latro`a> bah
15:26:25 <hpc> parcs: nice use of infinite sequencing
15:26:26 <latro`a> almost the same as that state example
15:26:27 <flebron> So what was the nice way to sum triples of Ints componentwise, other than defining (,,) to be a Num, or defining my own func?
15:26:35 <xplat> does lens have an iso for state/evalState?
15:26:46 <edwardk> xplat: not currently
15:26:48 <edwardk> well
15:26:50 <edwardk> actually
15:26:51 <edwardk> it might
15:26:55 <edwardk> :t wrapped State
15:26:56 <lambdabot>     Not in scope: data constructor `State'
15:26:56 <lambdabot>     Perhaps you meant `StateT' (imported from Control.Monad.State)
15:27:00 <edwardk> :t wrapped StateT
15:27:02 <lambdabot> (Functor m, Wrapped s t (s1 -> m (b, s1)) b) => s -> StateT s1 m t
15:27:04 <edwardk> yep
15:27:08 <edwardk> 'wrapping' works
15:27:08 <flebron> (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)	 <-- seems to be what I want
15:27:10 <quchen> > chunksOf 3 [1..19]
15:27:12 <quchen> lalala.
15:27:12 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19]]
15:27:23 <edwardk> well, at least for StateT and runStateT
15:27:48 <edwardk> :t wrapping StateT
15:27:49 <lambdabot> (Functor f, Profunctor p) => p (StateT s m a) (f (StateT s m a)) -> p (s -> m (a, s)) (f (s -> m (a, s)))
15:28:23 <typoclass> parcs: hm nice :-) though i guess it'd technically be in the category of using monads where a recursive call suffices :-P
15:29:01 <DanielDiaz> tgeeky: are you around?
15:29:22 <xplat> it'd be cool if there were a version of :t/@ty that recognized the lens type synonyms and recompressed them
15:29:43 <edwardk> :t wrappings StateT StateT
15:29:44 <lambdabot> (Functor f, Profunctor p) => p (StateT s m a) (f (StateT s1 m1 a1)) -> p (s -> m (a, s)) (f (s1 -> m1 (a1, s1)))
15:30:25 <edwardk> that is using    wrapped :: Iso (s -> m (a, s)) (s' -> m' (a', s')) (StateT s m a) (StateT s' m' a')
15:30:27 <nbouscal> I'm relatively new to Haskell and am implementing the game Pinochle as a learning exercise. Puzzling over the best way to handle trump, which is kind of referentially opaque by nature. Not sure if here or #haskell-game is the best place to ask
15:31:13 <cmccann> well #haskell-game is kinda quiet these days
15:31:17 <jmcarthur> nbouscal: either should be fine, but this channel is much more active
15:31:18 <cmccann> might as well ask in here
15:31:18 <nbouscal> That's the impression I got
15:31:23 <nbouscal> Cool, thanks
15:31:37 <hpc> nbouscal: hard to say without knowing the structure of your game
15:31:38 <xplat> nbouscal: it's not really a very games-specific question anyway
15:31:41 <jmcarthur> nbouscal: and i say that as the current owner of #haskell-game :\
15:31:49 <hpc> state in haskell is generally handled by passing parameters around
15:32:00 <jmcarthur> nbouscal: we still talk sometimes there, so feel free to lurk or ask questions there, too
15:32:00 <nbouscal> That's kind of what I was guessing, passing around what trump currently is
15:32:10 <nbouscal> jmcarthur: currently lurking there :)
15:32:11 <hpc> you can do it explicitly, which is a huge pain
15:32:15 <hpc> or you can use ReaderT
15:32:32 <nbouscal> I've read a little bit about that in learn you a haskell
15:33:14 <nbouscal> Right now I've really just started building things, I have set up some types and was writing an instance of Ord for my Card type
15:33:24 <hpc> you can use an IORef, if IO is the thing you are trying to learn
15:34:13 <hpc> what i would do is at the start of each hand, set a trump suit, then (flip runReaderT currentTrump) $ do ...
15:34:28 <hpc> where "..." is how the hand plays out from start to finish
15:34:44 <hpc> :t runReaderT
15:34:45 <lambdabot> ReaderT r m a -> r -> m a
15:36:42 <hpc> wow, pinochle looks like a pain to implement the trick logic for
15:36:58 <nbouscal> Yeah, this is I guess an audacious project
15:37:11 <nbouscal> Especially considering that I haven't really built anything in Haskell before
15:38:35 <xplat> maybe start with one of the simpler trick-taking games first
15:38:43 <xplat> and then pinochle
15:39:00 <nbouscal> My eventual (probably unrealistic) goal is to basically design a generic DSL for trick-taking games
15:39:08 <nbouscal> I was originally going to do it in Common Lisp
15:39:34 <nbouscal> Currently I'm playing around in both with some of the ideas, mostly just for learning purposes
15:40:01 <andrus> exit
15:40:38 <xplat> maybe whist would be a good start?
15:40:52 <nbouscal> My dad would enjoy that, Norwegian Whist is his favorite game. I haven't really ever played it myself
15:41:54 <Rotaerk> if I have, say, a GameState record type with a field called Combatants of type, say, CombatantTable, and I have a "State CombatantTable x", is there a standard way to transform that into a "State GameState x"
15:42:09 <nbouscal> Just from the wikipedia article though I'm not seeing why whist would be easier to implement the logic for?
15:42:21 <nbouscal> for the play phase of the game, I mean
15:42:31 <elliott> Rotaerk: lens can do it :p
15:42:31 <xplat> Rotaerk: 'zoom' from lens is a good one
15:42:55 <Rotaerk> hmm k
15:43:23 <crdueck> Rotaerk: Control.Monad.State.modify (\x -> GameState {combatantTable = x})
15:43:31 <ab9rf> Rotaerk: where do the parts of the game state that aren't in the combatanttable coming from?
15:43:31 <edwardk> 'zoom combatants'  given a lens named combatants that can get the CombatantTable out of GameState
15:43:48 <mietek> @pl toDiagonal = snd . mapAccumL (\f row -> (tail . f, head (f row))) id
15:43:48 <lambdabot> toDiagonal = snd . mapAccumL (ap ((.) . (,) . (tail .)) (head .)) id
15:43:55 <edwardk> cru: that doesn't work because the type of the input state and output state have to match there
15:44:11 <crdueck> edwardk: ah you're right
15:44:24 <ab9rf> you want to combind a game state and a combatant table state, replacing the combatant state part of the game state?
15:44:27 <edwardk> cru you have to get the smaller part of the state out. make a state monad, run it with that state, then put the new state back into the larger state. that is what zoom does
15:44:33 <crdueck> forgot how modify works there
15:44:40 <nbouscal> Is there a recommended article/book/something to read about ReaderT and the Reader monad generally?
15:47:32 <dmj> nbouscal: http://learnyouahaskell.com/for-a-few-monads-more#reader
15:47:38 <shanse> tried the lyah chapter?
15:47:44 <nbouscal> Yeah, I've read it once, I'll reread it.
15:48:09 <Rotaerk> speaking of lenses and states and such ... how do you guys handle appropriately naming things?  I mean, if I have a CombatantTable, I might define a function called addCombatant with signature:  CombatantState -> CombatantTable -> (CombatantId, CombatantTable)
15:48:27 <Rotaerk> but I also might define addCombatant with the type CombatantState -> State CombatantTable CombatantId
15:48:36 <Rotaerk> or I might define a lens
15:48:46 <hpc> Rotaerk: i try to write code that looks like what it does
15:48:51 * hackagebot statistics 0.10.3.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.3.0 (BryanOSullivan)
15:48:53 <Rotaerk> just seems like several different things that warrant the same name
15:48:54 <Cale> Rotaerk: Those are generally reasonable things to do, sure
15:48:55 <dmj> nbouscal: actually, LYAH doesn't seem to really cover it, at least not the "runReader" part
15:48:55 <hpc> in which case it all comes down to how you are using the functions
15:49:27 <Cale> Rotaerk: Just distinguish them however, usually by suffixes
15:49:47 <Cale> Or make use of nice combinators to convert :)
15:49:47 <typoclass> nbouscal: roughly, it's for when you have functions which each have some identical arguments. you could pass them around in the plain way (f stuff1 stuff2 stuff3 ... which then will call g stuff1 stuff2 stuff3, etc.). but you can use Reader to simplify this passing around of the same stuff
15:50:08 <Cale> Rotaerk: If you're going to the trouble of defining a lens, then you can use the lens combinators to get the other stuff
15:50:15 <Cale> and avoid giving those things specific names
15:50:21 <Rotaerk> hmm
15:50:24 <xplat> Rotaerk: you could call the State one registerCombatant
15:50:31 <edwardk> well i'd probably use a classy lens for CombatantTable, then you'd get a class HasCombatantTable t where combatantTable :: Lens t CombatantTable;    and then use that in your addCombatant        addCombatant :: (HasCombatantTable s, MonadState s m) => CombatantState -> m CombatantId
15:50:34 <hpc> nbouscal: more specifically, you would do something like data AllTheStuff = HereIsTheStuff {stuff1 :: StuffOne, ...}
15:50:34 <typoclass> nbouscal: Reader is also called "environment". think of the environment variables you have in a unix program which you could read from any function in your program
15:50:44 <edwardk> that would let you work in much larger states or more complicated monad transformer stacks
15:50:47 <nbouscal> typoclass: Okay, that makes sense, thank you.
15:50:53 <edwardk> that said, i tend not to write addFoo methods
15:51:08 <edwardk> but i can understand how they might be useful if the rules are complicated enough
15:51:23 <nbouscal> So now I suppose my question is, if I'm using the environment to do a comparison, is it possible to make my datatype's instance of Ord refer to that environment in some way?
15:51:36 <typoclass> nbouscal: in general, try the simplest thing first :-) if you're at the level of 'learn you a haskell', i suggest you try writing several 1-line and 3-line and 10-line programs before you go to State and lenses and whatnot :-)
15:51:49 <xplat> edwardk: sounds like this one may allocate a locally-unique ID, that's probably worth a method
15:52:16 <edwardk> nbouscal: the answer is, yes, it can be done, but not by means i recommend to anyone who doesn't know everything there is to know about how to do it already
15:52:27 <nbouscal> edwardk: I kind of guessed that would be the case :P
15:52:28 <edwardk> xplat: yeah
15:52:50 <nbouscal> typoclass: I've done a fair amount of functional programming, some in SML and some playing around of my own in Haskell, just no big projects yet
15:52:51 <flebron> Is it possible that, under GHC 6.10.4, I am saying "import Control.Monad.State", and yet state isn't defined?
15:53:13 <hpc> jesus, upgrade your ghc :P
15:53:15 <edwardk> flebron: are you using mtl 1.0?
15:53:26 <flebron> No idea, this is for spoj.pl's online judge :s
15:53:31 <edwardk> flebron: that is ancient enough that that is probably the problem
15:53:46 <nbouscal> typoclass: I'm tiring pretty quickly of the seemingly-standard reimplementing map, fold, filter, rational numbers, etc approach to learning this stuff
15:54:00 <typoclass> nbouscal: ok very good. (i'm just double-checking.)
15:54:06 <geekosaur> so it'll be State instead of state
15:54:09 <flebron> edwardk: Could I just paste the definition of state?
15:54:18 <hpc> nbouscal: irc bot
15:54:19 <nbouscal> typoclass: I'm quite surely jumping way too far by going to this project, but having trouble finding in-between projects
15:54:26 <edwardk> flebron: well, in mtl 1.0 state was just 'State' because it had a separate data type
15:54:29 <flebron> (As in, into my problem.)
15:54:33 <flebron> oh
15:54:43 <flebron> So I should just change state to State? :p
15:54:45 <geekosaur> yes
15:54:49 <nbouscal> hpc: ?
15:55:00 <hpc> as a project to learn with
15:55:03 <nbouscal> oh
15:55:13 <hpc> it's infinitely extendable for other sub-projects
15:55:13 <flebron> That explains why import Control.Monad.State didn't fail :)
15:55:26 <typoclass> nbouscal: he's suggesting you write your own irc bot, since that seems to be what kids these days do all the time :-/
15:55:36 <nbouscal> Haha. I've never even considered it tbh
15:55:36 <xplat> nbouscal: maybe you want to have a HeartTrumpCard, SpadeTrumpCard, etc and overload everything on what 'virtual deck' you're using.  that depends if you're doing large numbers of things that depend on trump suit though.  if you're just using it in a couple of places it's probably better to just use Reader and reference it explicitly
15:55:53 <hpc> typoclass: it's a much better exercise than Prelude ;)
15:56:04 <nbouscal> xplat: It's used to compute score in one phase and to compute order of cards (to win tricks) in another. that should be all
15:56:19 <quchen> typoclass: That's what the guy who created me thought as well, but then it escalated
15:56:37 <typoclass> quchen: very good :-)
15:56:39 <Rotaerk> edwardk, thanks; i like that typeclass suggestion; I was actually doing something similar, but not with lenses
15:57:02 <hpc> quchen: ppsh, you're just a buffer overrun in maukebot
15:57:10 <nbouscal> My go-to programming practice used to be project euler, but it always felt more like math practice than programming practice
15:57:22 <Kinnison> :-)
15:57:23 <hpc> project euler is awful
15:57:30 <typoclass> nbouscal: yes that's true
15:57:35 <xplat> quchen: and then he built a time machine and sent you back in time to learn haskell?
15:57:43 <edwardk> Rotaerk: the nice thing about the lens approach is the class and the instance get built for you just from the definition of the type
15:57:46 <hpc> it's like trying to learn metalworking by making an airplane
15:57:49 <nbouscal> Not to say I don't also need a lot of math practice :P
15:57:57 <edwardk> makeClassy ''CombatantTable   -- and its done
15:58:15 <quchen> xplat: After mastering strong AI, my creator felt like taking a break, so he invented time travel, yes.
15:58:33 <typoclass> nbouscal: have you considered becoming an xmoand user?
15:58:40 <nbouscal> typoclass: I am one‚Ä¶ kind of
15:58:55 <nbouscal> Until very recently my daily driver was a Cr-48 repurposed with Fedora and xmonad
15:59:13 <typoclass> nbouscal: very good, so i trust you're messing around with xmonad.hs all the time? ;-)
15:59:13 <nbouscal> Then I bought a shiny new MacBook Pro, and am currently still using its default window management
15:59:44 <geekosaur> nbouscal, seen osxmonad yet?
16:00:02 <nbouscal> I haven't, though I figured I'd be able to use it somehow since os x can support X
16:00:43 <nbouscal> I'm still getting used to using a Mac at all
16:01:09 <merijn> nbouscal: Oh, I know of a native tiling WM for OSX. I havn't tried it yet myself, but I heard it was decent
16:01:27 <typoclass> nbouscal: well, afaik you can use xmonad on os x, but only for x applications (i.e. none of the native ones, only those that you start in that weird emulator). there's a project underway to reimplement xmonad, but i don't know how far they've gotten
16:01:58 <nbouscal> Oh interesting. I hadn't actually got around to playing around with X on this machine yet
16:02:15 <nbouscal> I was about to, to run xterm, but it turned out that iTerm2 works pretty darn well so I just use it
16:02:32 <nbouscal> I have been missing having a tiling WM though
16:03:14 <merijn> nbouscal: Unfortunately OSX' support of X doesn't extend to native apps, so you can't have your X wm manage your native windows
16:03:25 <nbouscal> That is unfortunate =/
16:03:56 <nbouscal> this mac has been like a long game of 'fortunately / unfortunately'
16:04:09 * merijn just uses Terminal.app
16:04:19 <merijn> nbouscal: https://github.com/jigish/slate
16:04:42 <merijn> That one supports native apps, like I said I haven't tried it out myself, but my friends/colleagues though it was nice
16:05:16 <nbouscal> looks pretty configuration-heavy
16:05:51 <nbouscal> might try it out though, thanks :)
16:05:52 <geekosaur> https://github.com/xmonad/osxmonad
16:06:02 <nbouscal> geekosaur: was just looking at that :)
16:06:07 <merijn> Yeah, that's why I didn't bother yet. Didn't feel like spending 3 days configuring :p
16:06:19 <Rotaerk> edwardk, though I can't use classy in this case, because I don't actually have a CombatantTable, I have a (EntityTable e) where e is CombatantState or some other type of entity's state
16:06:21 <typoclass> am i understanding this correctly, 'slate' is something where you press a button and it places the window somewhere?
16:06:25 <geekosaur> rather incomplete at present, largely because the corresponding hooks aren't available in os x
16:06:44 <Rotaerk> and last I checked, classy doesn't work on parametrized type constructors
16:06:44 <nbouscal> Yeah I'm not particularly surprised that apple of all people didn't make it easy to replace their software :P
16:06:50 <edwardk> Rotaerk: it does now
16:07:01 <Rotaerk> oh? recent development?
16:07:08 <edwardk> we fixed it back in 3.8 or so
16:07:31 <edwardk> So january or december
16:07:36 <merijn> nbouscal: Actually, window management in OSX is pretty doable (I looked into for writing my own tiling wm, but then I realised I didn't care enough)
16:07:43 <geekosaur> nbouscal, you'd be surprised. go see what it takes to write a window manager for wayland
16:07:44 <Rotaerk> oh, I may be thinking of one of the other template-haskell functions
16:07:59 <Rotaerk> makeLensesWith
16:08:08 <merijn> The accessibility UI of OSX gives you pretty good control, it's just that not many people are willing to invest the time
16:08:10 <edwardk> that is also perfectly happy with them
16:08:15 <Rotaerk> hmm
16:08:15 <nbouscal> Interesting.
16:08:22 <edwardk> makeLensesWith is used to implement makeClassy
16:08:28 <edwardk> makeClassy = makeLensesWith classyRules
16:08:52 <merijn> Nowadays I just run 1 full screen terminal, 1 full screen browser and 1 desktop for IM, etc. and then I just use tmux inside the terminal for window management, most my applications are text/terminal apps anyway
16:08:55 <typoclass> merijn: i think "press a button to place a window" is a bit different from what xmonad or other tiling wm's do
16:09:02 <Rotaerk> k, I'll try that again and bring it up again if I have issues; don't have my use case on hand
16:09:04 <merijn> But we should probably move this to blah
16:09:22 <merijn> typoclass: I used wmii and dwm in the past, those are the direct inspiration of xmonad
16:09:29 <edwardk> kk. you'll need to turn on MPTCs and fundeps in the module where you use it, but with those on it'll support it
16:09:38 <Rotaerk> ah
16:09:43 <edwardk> (because it makes an MPTC)
16:10:56 <typoclass> merijn: i'm not saying it's useless, i'm saying it's not really comparable
16:11:30 <nbouscal> i usually have a fullscreen terminal and then several browsers and assorted other applications (codekit, ftp, some others), as i do web development
16:12:08 <nbouscal> large part of the clutter is just because i work at a place that does things silly, really
16:12:18 <nbouscal> not sure a tiling WM would even help
16:12:33 <merijn> nbouscal, typoclass: We might wanna move this to -blah it's a bit off-topic :)
16:16:55 <t7> lets say I wanna abstract databases: I want a class of things that have some operations (lookup, put, delete) that can run under a monad (IO or state or whatever)
16:17:29 <t7> should i do   class Monad m => DB m a where ?
16:17:48 <t7> no that cant be right
16:17:59 <Eduard_Munteanu> t7: why do you need a "class"?
16:18:22 <Eduard_Munteanu> Oh, nvm.
16:18:30 <t7> because i wanna seperate backend crap from my core algorithms
16:18:51 <t7> i should just look at StateM, right? that does what i want
16:19:02 <Eduard_Munteanu> StateM? :/
16:19:35 <t7> StateT
16:20:12 <Eduard_Munteanu> I don't think that helps abstracting it.
16:20:55 <t7> i can copy it and change the declare functions
16:21:23 <Eduard_Munteanu> Huh? Why would you do that?
16:22:08 <t7> I want a monad that works like that
16:22:43 <Eduard_Munteanu> Well, that's easy, write a wrapper for State.
16:23:02 <xplat> t7: you're saying you want a monad transformer, right?
16:23:10 <t7> I need to write my own
16:23:30 <A__A> is there a haskell plugin for eclipse? any good?
16:23:34 <Eduard_Munteanu> I thought I knew what you were asking, now I'm confused. :)
16:23:51 <typoclass> A__A: i think there's eclipsefp, but i haven't tried it myself
16:23:55 <Kaidelong> A__A: EclipseFP, when I used it it was pretty good
16:23:55 <xplat> right.  something like state in that it's a monad transformer, but not like state in that it wouldn't do the same thing
16:25:49 <t7> yes :)
16:31:22 <t7> @hoogle lift
16:31:23 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
16:31:23 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
16:31:23 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:32:06 <t7> whats the difference between lift and return?
16:32:37 <tgeeky> t7: I thought you said pure and return. Which are the same. Lift is not.
16:32:58 <tgeeky> @type lift
16:33:00 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:33:00 <tgeeky> @type return
16:33:01 <lambdabot> Monad m => a -> m a
16:33:37 <Nisstyre> tgeeky: return puts something back into a monad, lift takes something out, applies a function to it, and puts it back in
16:33:48 <Nisstyre> er
16:33:49 <Nisstyre> t7
16:34:18 <copumpkin> not sure I'd put it that way
16:34:32 <Nisstyre> yeah that's an oversimplification
16:34:36 <copumpkin> lift is putting the _function_ in as well, so it can operate on the things inside
16:34:39 <copumpkin> nothing ever comes out
16:34:46 <Nisstyre> true
16:34:46 <Eduard_Munteanu> I wouldn't put it at all, you can usually write a newtype wrapper and derive all that stuff. :)
16:35:17 <tgeeky> copumpkin: Monads are like Hotel Californias. You can check in, but you can never check out.
16:35:24 <copumpkin> *never leave
16:35:25 <copumpkin> :P
16:35:27 <copumpkin> but yeah :)
16:37:03 <Eduard_Munteanu> Also, if you need to do IO, you probably want to require MonadIO on the transformee.
16:37:26 <Eduard_Munteanu> :t liftIO
16:37:28 <lambdabot> MonadIO m => IO a -> m a
16:38:19 <latro`a> why is liftIO separate from lift btw
16:38:34 <latro`a> (I haven't had to use either that much)
16:39:04 <Igloo> lift always goes up 1 level. liftIO goes up until it reaches IO.
16:39:34 <tgeeky> http://stackoverflow.com/questions/3921237/haskell-lift-vs-liftio
16:40:06 <Eduard_Munteanu> latro`a: because if you want to abstract over the IO monad, plain lift requires you to place IO just below your transformer.
16:40:27 <latro`a> I don't see why that description is specific to IO, edward
16:40:33 <`Jake`> hey guys, is there a simple way for letting a program wait a certain amount of time?
16:40:47 <latro`a> that seems like it'd motivate liftState or such madness
16:40:47 <Eduard_Munteanu> latro`a: stuff like State has MonadState and such
16:41:05 <tgeeky> `Jake`: http://hackage.haskell.org/packages/archive/concurrent-extra/0.5/doc/html/Control-Concurrent-Thread-Delay.html ?
16:41:12 <Eduard_Munteanu> latro`a: yes but normal IO functions only work in IO
16:41:19 <`Jake`> tgeeky: thanks, I
16:41:22 <`Jake`> 'll try that
16:41:22 <Eduard_Munteanu> They're always   -> IO something
16:41:27 <tgeeky> `Jake`: perhaps the original threadDelay
16:41:38 <`Jake`> I'll look itno that as well, then
16:41:58 <geekosaur> also note that there's only a small handful of MonadState functions, but a wole lot of stuff in IO
16:41:58 <harrisonku> Hi - I'm trying to use QuickCheck to test pure code, as this is what the Cabal docs say I should do. However I find it really hard to come up with any properties to test. For example, I have a function that tests if a point is inside a triangle. What on earth properties am I supposed to be able to make to test a function like that?
16:42:40 <tgeeky> harrisonku: points that are inside the triangle should give some value, points outside some other value, and points on the lines making up the triangle, some other value
16:43:37 <harrisonku> tgeeky: But quickcheck gives me a random point and a random triangle for each test - isn't that the whole idea? so I don't know whether the point is in the triangle, without running the function, but that's what I'm trying to test...
16:44:52 <tgeeky> harrisonku: smallcheck might be better suited for your case. Otherwise, you will need to constrain the arbitrary generators you use for that test case
16:46:15 <`Jake`> hmm, threadDelay doesn't seem to be working, but maybe I'm doing something wrong
16:46:35 <t7> @pl return . either Just undefined =<< outputs
16:46:36 <lambdabot> either Just undefined `fmap` outputs
16:46:42 <harrisonku> tgeeky: does quickcheck not work the way i think? i've read the paper and the examples with lists seem very sensible, but the first time i try to come up with properties, it seems impossible, so do i have the wrong end of the stick? another example: i write an add function, and a substract function, then write a property that they should inverse each other. but that doesn't test that those functions are correct, only that they are 
16:46:59 <t7> are all monads functors?
16:47:22 <tgeeky> harrisonku: "only that they are" was the last part of your comment
16:47:37 <tgeeky> harrisonku: and no, it works the way you think. However, I must say that quickcheck has changed tremendously since the paper
16:47:57 <hpaste> ‚Äú`Jake`‚Äù pasted ‚ÄúthreadDelay doesn't delay‚Äù at http://hpaste.org/85733
16:48:25 <`Jake`> Oh, by the way, I'm on windows right know, unfortunately
16:48:36 <`Jake`> s/know/now
16:48:53 <geekosaur> threadDelay is in microseconds
16:48:55 <tgeeky> `Jake`: Windows is fully supported
16:49:01 <`Jake`> ok
16:49:04 <geekosaur> maybe you can spot a 1ms delay, most of us can't
16:49:23 <`Jake`> wait, I read it's the elay in millieconds... was it microseconds?
16:49:51 <geekosaur> Suspends the current thread for a given number of microseconds
16:49:58 <geekosaur> quoting from the haddock
16:50:03 <`Jake`> ok, sorry, that's easy to fix
16:50:08 <tgeeky> geekosaur: that would be 'us' or whatever, right?
16:50:19 <tgeeky> mu-s
16:50:39 <tgeeky> `Jake`: either way, too short to be noticable.
16:50:41 <geekosaur> 1000us = 1ms = 1/1000 second
16:50:50 <`Jake`> ¬µs
16:51:12 <`Jake`> Yeah, I've set it to 1,000,000 now
16:51:35 <t7> @hoogle Either a b -> Maybe a
16:51:35 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
16:51:36 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
16:51:36 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
16:51:38 * tgeeky does the Dr. Evil pinky finger thing
16:53:26 <`Jake`> wait geekosaur... I'm pretty sure that 1¬µs (aka us) is 1/1000 ms
16:53:41 <`Jake`> oh dammit
16:53:43 <`Jake`> sorry
16:53:44 <geekosaur> yes
16:53:46 <`Jake`> that's what you wrote
16:54:16 * tgeeky just commented that geekosaur said "1ms".
16:54:27 <tgeeky> that's all I was looking at. Presumably a 1 microsecond delay is even harder to spot. :)
16:54:37 <geekosaur> yes, I was reacting to threadDelay 1000
16:54:44 <tgeeky> geekosaur: ah ha!
16:55:29 * typoclass thinks the threadDelay function should really be like "delay (30 :: Seconds)" or "delay (500 :: Millisec)". everyone has run into the millisecond/microsecond thing once
16:55:50 <tgeeky> typoclass: first class times!
16:56:11 <typoclass> tgeeky: there's a package or two that offer that :-)
16:57:23 <t7> @hoogle (a -> b) -> [a] -> [(a, b)]
16:57:24 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
16:57:24 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
16:57:24 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
16:57:58 <geekosaur> otoh that has lovely possibilities for behavior even more insane than that of PortNum
16:58:31 <Eduard_Munteanu> geekosaur: the Num instance of PortNum in 'network'?
16:58:46 <Eduard_Munteanu> That one is odd, yeah.
16:58:53 <geekosaur> yeh, the one that is byteswapped on little-endian platforms
17:13:26 <typoclass> geekosaur: woah that sounds terrible
17:17:18 <ExternalReality> What do you ladies and gents think about the truthiness of these statements that I am thinking about:
17:17:45 <ExternalReality> "There is one fundamental operation that can be performed on data and that is to transform it"
17:18:28 <Eduard_Munteanu> Vague.
17:18:32 <elliott> i think it is vague enough that you can assign any truth value you want to it
17:18:40 <typoclass> ExternalReality: that's pretty broad :-) it could mean anything
17:20:38 <ExternalReality> What about "There are two fundamental operations that can be performed on collections of data while preserving its shape and that is to transform the collection elements or change its size."
17:21:32 <Eduard_Munteanu> That's rather vague too... although there's a smell of parametricity to it.
17:21:36 <Eduard_Munteanu> Why do you ask, anyway?
17:22:11 <Eduard_Munteanu> Anyway, I probably shouldn't guess unless you provide more info.
17:22:14 <typoclass> ExternalReality: sounds like an explanation of Functor to me :-) or partially, at least
17:23:18 <shachaf> No, that's not what Functor is at all. :-(
17:23:35 <shachaf> Nice attempt to bring it on-topic, though!
17:24:19 <typoclass> shachaf: it sounded to me like that for a moment? "preserving the container's structure while transforming the contents" kind of thing
17:24:24 <flebron> The first one might be vague enough to talk about categories :p (As might anything, really)
17:24:40 <typoclass> shachaf: anyway, could mean anything :-) you're right
17:24:47 <flebron> "The fundamental object in category theory is the morphism", or whatever.
17:25:15 <A__A> > anyone here used AMQP or any other message broker? what problem did you solve with it?¬®
17:25:15 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
17:25:53 <ExternalReality> Thank you for the feedback :-)
17:25:59 <elliott> I think we should not bother considering the statement any more
17:26:11 <Cale> These statements are way too vague to mean anything.
17:26:34 <flebron> Ceci n'est pas un vague statement.
17:26:41 <elliott> Cale: have you ever, like, really *looked* at a functor, man?
17:26:50 <Cale> heh
17:26:52 <ExternalReality> Yes, I understand that now. Like elliot said we stop considering it.
17:26:58 <flebron> elliott: You mean through some sort of lens?
17:27:07 <typoclass> ExternalReality: i think you need some examples to go along with that :-)
17:30:10 <shachaf> @remember SaulGorn A formalist is one who cannot understand a theory unless it is meaningless.
17:30:11 <lambdabot> Good to know.
17:30:50 <ExternalReality> typoclass: I was meant to be kind of Newtonian "An object that is at rest will stay at rest unless an external force acts upon it"
17:31:28 <ExternalReality> :typeclass: This implies that the only thing you can do with an object at rest is leave it alone or act upon it.
17:32:06 <ExternalReality> typoclass: the only thing you can do with a some data is leave it alone or transform it.
17:32:24 <typoclass> shachaf: heh, nice quote
17:32:33 <ExternalReality> typoclass: that is where I was coming from with that.
17:32:41 <shachaf> It was in lambdabot before.
17:32:46 <typoclass> ExternalReality: hm, i see
17:33:57 <Cale> ExternalReality: That sounds more like a definition of transform than anything
17:34:29 <shachaf> typoclass: http://www.ling.upenn.edu/~rclark/gorn.html
17:34:44 <shachaf> I guess this is the wrong channel.
17:35:28 <typoclass> shachaf: excellent link, thanks a lot
17:39:29 <A__A> wow, the plugin for eclipse really takes forever to install
17:41:03 <geekosaur> it builds a bunch of stuff
17:41:16 <A__A> you use it?
17:41:28 <A__A> im tired of emacs
17:41:31 <geekosaur> (it is, more or less, building a special version of ghc that it can use for typechecking and such)
17:41:34 <geekosaur> occasionally
17:42:00 <geekosaur> I'm more of an emacs user but most of the editor interfaces use similar helper programs/libraries
17:43:54 <A__A> > 5 >> 6
17:43:55 <lambdabot>   Could not deduce (GHC.Num.Num (m a0))
17:43:55 <lambdabot>    arising from the ambiguity check f...
17:43:59 <A__A> > 5 >> Just  6
17:44:01 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
17:44:01 <lambdabot>    arising from the lit...
17:44:03 <A__A> > 5 >> Just 6
17:44:04 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
17:44:05 <lambdabot>    arising from the lit...
17:44:08 <A__A> > Nothing >> Just 6
17:44:09 <lambdabot>   Nothing
17:44:17 <A__A> > Just 5 >> Just 6
17:44:18 <lambdabot>   Just 6
17:44:30 <A__A> > Nothing >>= Just 5¬®
17:44:32 <A__A> > Nothing >>= Just 5
17:44:33 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
17:44:37 <lambdabot>   Couldn't match expected type `a0 -> Data.Maybe.Maybe b0'
17:44:39 <lambdabot>              with ...
17:44:50 <A__A> > Nothing >>= return . Just 5
17:44:52 <lambdabot>   Couldn't match expected type `a0 -> b0'
17:44:52 <lambdabot>              with actual type `Data...
17:44:57 <A__A> > Nothing >>= return . (Just 5)
17:44:58 <lambdabot>   Couldn't match expected type `a0 -> b0'
17:44:58 <lambdabot>              with actual type `Data...
17:45:01 <A__A> > Nothing >>= return $  (Just 5)
17:45:02 <lambdabot>   Couldn't match expected type `t0 -> t1'
17:45:02 <lambdabot>              with actual type `Data...
17:45:04 <Cale> > Just 5 >>= \x -> return (x + 1)
17:45:06 <lambdabot>   Just 6
17:45:09 <A__A> > Nothing >>= return . Just
17:45:10 <typoclass> A__A: hello, lambdabot is also available privately
17:45:10 <lambdabot>   Nothing
17:45:19 <A__A> how?
17:45:22 <Cale> > [1,2,3] >>= \x -> return (x + 1)
17:45:24 <lambdabot>   [2,3,4]
17:45:30 <typoclass> A__A: try "/query lambdabot"
17:46:59 <A__A> > anyone here used AMQP or any other message broker? what problem did you solve with it?¬®
17:46:59 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
17:47:30 <A__A> oops
17:48:13 <A__A> @src (>>=)
17:48:13 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:48:20 <A__A> can i get the src here?
17:48:29 <elliott> you need to ask for the source for a specific monad.
17:48:30 <elliott> e.g.
17:48:33 <elliott> @src [] (>>=)
17:48:33 <lambdabot> xs >>= f     = concatMap f xs
17:48:40 <A__A> @src (Control.Monad.>>=)
17:48:40 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:48:53 <A__A> @src Maybe (>>=)
17:48:53 <lambdabot> (Just x) >>= k      = k x
17:48:53 <lambdabot> Nothing  >>= _      = Nothing
17:49:46 <A__A> if you chain a bunch of (>>=) will it abort at the first if Nothing or will it go through all still?
17:50:13 <Cale> A__A: You can see in the definition of >>= there that it won't use the second argument
17:52:35 <A__A> but it will continue to eval?
17:53:09 <Cale> nope
17:53:32 <A__A> a >>= return . (+3) >>= return . someotherfun >>= ... >>= return . (*5). if a is nothing it will go all the way?
17:53:47 <Cale> It won't evaluate the second argument, because it won't even bind it to a variable. It just becomes garbage.
17:54:03 <copumpkin> A__A: that's a basic principle in Haskell. If you don't touch something, it doesn't get evaluated
17:54:31 <Cale> At some level, the only reason anything gets evaluated is because it's being pattern matched on.
17:55:02 <Cale> (against a pattern which involves a data constructor)
17:55:51 <A__A> hmm but could you make a function that could return either Left 5 or Right 8? the return type would be Either a?
17:56:10 <Cale> Either Integer or (Num a) => Either a
17:56:49 <Cale> :t let f x = if x > 0 then Right 8 else Left 5 in f 0
17:56:51 <lambdabot> (Num b, Num a) => Either a b
17:57:08 <Cale> hehe, of course, Either has two parameters!
17:57:26 <Cale> So, Either Integer Integer
17:57:32 <A__A> > let f v = v >>= return . show . (+3) in f (Left 7)
17:57:33 <lambdabot>   Left 7
17:57:51 <A__A> > let f v = v >>= return . show . (+3) in (f (Left 7), f (Right 7))
17:57:52 <lambdabot>   (Left 7,Right "10")
17:58:20 <Cale> You might often find it more comfortable to use >>= with a lambda
17:58:41 <Cale> > let f v = v >>= \x -> return (show (x + 3)) in (f (Left 7), f (Right 7))
17:58:43 <lambdabot>   (Left 7,Right "10")
17:58:46 <A__A> are you people paid haskell devs or phds?
17:58:53 <Cale> I'm a paid Haskell dev
17:59:07 <Cale> I just have a BMath in pure mathematics
17:59:19 <A__A> B for bullshit?
17:59:26 <A__A> or useful?
17:59:31 <Cale> Bachelor's degree, very useful
17:59:35 <A__A> :)
17:59:41 <A__A> what do you develop?
17:59:42 <luite> oh so phd doesn't mean paid haskell dev? :p
17:59:53 <Cale> I wouldn't trade it for any other piece of education I'm aware of
17:59:59 <copumpkin> Cale: when you coming to the US, dammit
18:00:07 <Cale> I'm working on a new backend for skedge.me's web service.
18:00:19 <Cale> copumpkin: Why do I need to do that?
18:00:39 <copumpkin> Cale: because there are lots of interesting people and things here!
18:00:41 <shachaf> Cale: It's "the cool place to be".
18:00:43 <copumpkin> if only to visit :P
18:01:06 <Cale> shachaf: Canada is cooler :P
18:01:26 <shachaf> Cale: ICFP is going to be in Boston!
18:01:31 <shachaf> You should go.
18:01:39 <luite> shachaf: are you going?
18:01:40 <A__A> sweden is defineately cooler
18:01:59 <A__A> so why are they letting you use haskell?
18:02:04 <shachaf> luite: No plans to at the moment. It's possible, I suppose. Should I?
18:02:13 <A__A> how much do they pay you?
18:02:17 <luite> dunno
18:02:26 <Cale> A__A: The CTO is another Haskeller, ryant5000 (he's in this channel)
18:02:29 <luite> i'd like to go, but not sure
18:03:25 <Cale> A__A: The backend we inherited was written in Grails, and was very difficult to maintain and had a lot of bugs in it.
18:03:41 <luite> is it snap now?
18:04:07 <Cale> Yeah, and the part which is done runs about a thousand times faster than its Groovy counterpart.
18:04:32 <nabil> exit
18:04:35 <shachaf> But it's about a thousand times less groovy.
18:04:49 <shachaf> I guess that comes with "not being cool". :-(
18:06:34 <luite> http://hdiff.luite.com/gloss/styrene/ <- for people with a fast browser,  for people with a slow browser (or like lens) -> http://hdiff.luite.com/gloss/pong/
18:06:49 <luite> spam some more :)
18:06:49 <shachaf> What if I have a fast brower and like lens?
18:07:10 <luite> shachaf: can't help you then, yet :)
18:08:42 <Cale> http://hdiff.luite.com/gloss/styrene/out.js :D
18:09:10 <luite> hehe don't do that ;)
18:11:11 <luite> i know that a lot can be optimized, working on that
18:12:05 <Hafydd> h$_integerzmgmpZCGHCziIntegerziTypeziwild1_1929386383 would make an interesting username.
18:12:08 <hpaste> jfischoff pasted ‚ÄúGeneric Traversable and Options‚Äù at http://hpaste.org/85734
18:12:26 <luite> Cale: that is the gloss lib, half the base package, including buffered io, utf8, utf16, utf32 de/encoding etc
18:13:03 <shachaf> luite: But does it have utf-21‚Öì?
18:13:13 <jfischoff> So I am working on options manipulation and I came across a need for a more generic traversable. i.e. traverse1 :: (Applicative f) => (forall a. g a -> f (h a)) -> t g -> f (t h)
18:13:30 <jfischoff> Has that been defined anywhere?
18:13:47 <jfischoff> I'm using it here http://hpaste.org/85734
18:13:52 <Cale> luite: Implement par :)
18:14:34 <luite> Cale: i'm not sure what it does now, might be a no-op
18:15:00 <luite> can't properly implement it of course, in a js runtime
18:15:35 <luite> but forkIO threads do work
18:16:08 <Cale> luite: Apparently there's something called "Web workers" now?
18:16:33 <luite> Cale: yeah but they have higher isolation than regular threads, no shared memory
18:16:43 <jfischoff> Cale: you might know this. Is there a Traversable for (* -> *) -> * kinds?
18:16:58 <Cale> jfischoff: Not that I'm aware of
18:17:00 <luite> there is some method to transfer ownership, but really it's much like processes
18:17:12 <luite> so to implement par you'd have to set up some synchronization channel
18:17:50 <A__A> god this eclipse plugin is gonna tka the whole night to compile
18:19:46 <shachaf> jfischoff: I think elliott was working on classes like those.
18:19:49 * Cale just uses vim :P
18:19:49 <shachaf> Maybe ask him?
18:20:03 <jfischoff> elliott: ping
18:21:22 <Cale> luite: you might be able to naively use something like the spawn here: http://adambom.github.io/parallel.js/
18:21:39 <jfischoff> The whole "record or Maybes" seems to be a popular way of dealing with options, curious if there are other competing approaches, anyone know?
18:21:41 <elliott> jfischoff: i guess you'd need HApplicative or something?
18:21:47 <Cale> luite: Obviously not as cool as GHC's actual implementation of par :P
18:22:19 <jfischoff> elliott: did you look at my hpaste?
18:22:30 <elliott> oh, let me see
18:22:38 <jfischoff> http://hpaste.org/85734
18:22:47 <jfischoff> elliott:^
18:23:04 <luite> Cale: oh yes, that's possible. we can serialize thunks, in theory send them over to other web workers, but it's much more explicit than par
18:23:30 <jfischoff> elliott: I'm looking for a code review/suggestions about that approach
18:23:43 <elliott> jfischoff: hm, interesting
18:24:13 <elliott> i appear to have
18:24:16 <elliott> class Functor' t => Traversable' t where traverse' :: Applicative g => (forall a. f a -> g (h a)) -> t f -> g (t h)
18:24:26 <elliott> so pretty much exactly what you do, except i have the rest of the weird hierarchy too :P
18:24:43 <jfischoff> elliott: cool!
18:24:56 <hpaste> Rotaerk pasted ‚Äúclassy functional dependencies‚Äù at http://hpaste.org/85735
18:24:58 <jfischoff> elliott: where is it?
18:25:22 <Rotaerk> hmm that code demonstrates what I'm basically trying to do, but is not compiling due to functional dependencies
18:25:43 <Rotaerk> any particular reason there shouldn't be more than one EntityTable (with different entity types) in GameState?
18:25:48 <elliott> jfischoff: ~/ :P
18:25:59 <shachaf> ~/tmp/?
18:26:08 <elliott> I was messing around with formlet type stuff. not much came of it
18:26:57 <Rotaerk> I guess I just can't use makeClassy for this; need to build my own typeclass
18:27:19 <jfischoff> I wonder if the Traversable' instances can be derived with GHC.Generics?
19:04:03 * hackagebot honk 1.2.0.0 - Cross-platform interface to the PC speaker.  http://hackage.haskell.org/package/honk-1.2.0.0 (ChrisWong)
19:11:03 <ab9rf> honk
19:18:13 <startling> is there a good general framework for pretty-printing somewhere? @hackage pretty looks kind of iffy
19:27:49 <startling> > foldr f a [b, c]
19:27:51 <lambdabot>   f b (f c a)
19:31:48 * flebron wonders how lambdabot does that
19:31:52 <startling> :t f
19:31:54 <lambdabot> FromExpr a => a
19:32:05 <startling> :t foldr f a [b, c]
19:32:07 <lambdabot> Expr
19:32:11 <flebron> Oh so
19:32:16 <flebron> > foldr g [b, c]
19:32:18 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr
19:32:18 <lambdabot>                     [Deb...
19:32:25 <flebron> Tricksy hobbitses...
19:32:38 <flebron> > foldr g a [b, c]
19:32:40 <lambdabot>   g b (g c a)
19:32:40 <mjrosenb> flebron: yeah, lambdabot is full of magic.
19:32:43 <flebron> D:!
19:32:48 <startling> flebron, http://hackage.haskell.org/package/simple-reflect
19:33:02 <mjrosenb> > (1,2) + 4
19:33:04 <lambdabot>   (5,6)
19:33:06 <Nisstyre> :t g b (g c a)
19:33:07 <lambdabot>     Ambiguous type variable `t0' in the constraints:
19:33:07 <lambdabot>       (Show t0) arising from a use of `g' at <interactive>:1:1
19:33:07 <lambdabot>       (FromExpr t0) arising from a use of `g' at <interactive>:1:6
19:33:27 <flebron> > foldr gg aa [bb, cc]
19:33:29 <lambdabot>   Not in scope: `gg'
19:33:29 <lambdabot>  Perhaps you meant `g' (imported from Debug.SimpleReflec...
19:33:33 <flebron> Aha!
19:34:10 <startling> > foldr (+) 1 [2, 3, 4] :: Expr
19:34:12 <lambdabot>   2 + (3 + (4 + 1))
19:34:46 <Nisstyre> > foldl1 (+) [1,2,3]
19:34:47 <lambdabot>   6
19:34:57 <Nisstyre> do you have to suffix it with :: or what?
19:35:12 <startling> Nisstyre, Expr is a Num instance
19:35:12 <Nisstyre> oh I see
19:35:20 <startling> http://hackage.haskell.org/packages/archive/simple-reflect/0.3.1/doc/html/Debug-SimpleReflect-Vars.html
19:35:27 <Nisstyre> sorry my window is screwed up
19:35:31 <Nisstyre> I misread that line
19:35:41 <Nisstyre> > foldl1 (+) [1,2,3] :: Exp
19:35:42 <lambdabot>   Not in scope: type constructor or class `Exp'
19:35:42 <lambdabot>  Perhaps you meant `Expr' (im...
19:35:46 <Nisstyre> > foldl1 (+) [1,2,3] :: Expr
19:35:48 <lambdabot>   1 + 2 + 3
19:35:51 <Nisstyre> cool
19:37:35 <edeast> elm
19:47:26 <edeast> What is the derivative of a recursive function?
19:47:45 <shachaf> What makes a function recursive?
19:48:15 <Eduard_Munteanu> edeast: how do you define "derivative" for functions?
19:48:24 <Eduard_Munteanu> For Haskell functions, that is.
19:48:42 <Eduard_Munteanu> Or is it a purely math question?
19:49:06 <edeast> that's what i'm trying to figure out.
19:49:34 <edeast> in frp,  \
19:49:41 <Eduard_Munteanu> Oh.
19:49:46 <edeast> we label values as through time,
19:50:06 <edeast> so maybe we could show the event based frp, as derivative, of the signal,
19:50:13 <Eduard_Munteanu> Well, that's different. FRP has a notion of time, in this case continuous I suppose.
19:52:22 <Eduard_Munteanu> It extends to the discrete case too, I guess.
19:53:12 <edeast> I was also wondering about the interpretation of normal haskell functions' derviatives, but no progress on that front
19:53:52 <Eduard_Munteanu> I'm not sure that makes sense, generally.
19:54:07 <edeast> the recursive derivative question,  was a pure math one though,  i've googled a bit
19:54:33 <shachaf> Well, you'll have to say what "recursive function" means and what "derivative" means.
19:54:46 <shachaf> Functions are obviously just graphs.
19:54:56 <edeast> I thought recursive functions were well understood,
19:55:37 <edeast> How I understand functions, just specific form of relation.
19:57:05 <Eduard_Munteanu> In math, derivatives are defined for a particular class of functions.
19:58:24 <edeast> yep ok,
19:58:33 <edeast> next topic
20:12:45 <user317> i am trying to derive data.binary using generics but i am getting this error, No instance nor default method for class operation Data.Binary.put, any ideas what causes this?
20:17:16 <Cale> user317: Somehow it's not being derived?
20:17:22 <user317> yea
20:18:00 <user317> do i need some specific vesion of data.binary?
20:18:07 <user317> it seems to work on one machine but not the other
20:19:06 * hackagebot bits 0.2 - Various bit twiddling and bitwise serialization primitives  http://hackage.haskell.org/package/bits-0.2 (EdwardKmett)
20:19:27 <user317> yea, thats it
20:19:36 <user317> forcing it to 0.7 or later works
20:34:43 <parcs> what is the kind of => ?
20:35:09 <geekosaur> it's syntax
20:35:25 <parcs> but assuming it's not syntax
20:35:44 <monochrom> then perhaps Constraint -> *
20:35:55 <monochrom> err, Constraint -> * -> *
20:36:03 <geekosaur> right, but the point is more that I don't think it's necessarily possible to give it a kind or a sort or a whatever, in haskell
20:37:14 <parcs> :k Num Int => Int#
20:37:15 <lambdabot>     Not in scope: type constructor or class `Int#'
20:37:15 <lambdabot>     Perhaps you meant one of these:
20:37:15 <lambdabot>       `Int' (imported from Data.Int), `Int8' (imported from Data.Int)
20:37:19 <parcs> :k Num Int => (# #)
20:37:20 <lambdabot> *
20:37:32 <Eduard_Munteanu> monochrom: though stuff in * can have constraints too
20:38:26 <monochrom> it is an ill-posed question
20:38:31 <Eduard_Munteanu> Which makes stuff like    Foo a => Bar a => a    possible, I guess.
20:38:34 <parcs> the ghc kind stuff is quite messy
20:39:02 <tgeeky> parcs: newborns are messy, but worth it
20:39:04 <Eduard_Munteanu> (not saying it's an actual issue though, just probably inconsistent)
20:39:26 <parcs> :k (->)
20:39:27 <lambdabot> * -> * -> *
20:39:59 <parcs> yet (Int -> Int#) :: *
20:40:35 <Nisstyre> parcs: even with DataKinds and PolyKinds?
20:40:52 <Eduard_Munteanu> @src Int
20:40:52 <lambdabot> data Int = I# Int#
20:41:12 <parcs> Nisstyre: even what?
20:41:16 <Eduard_Munteanu> Oh, pfft, of course.
20:41:20 <Nisstyre> <parcs> the ghc kind stuff is quite messy
20:41:23 <Nisstyre> even "messy"
20:41:32 <Eduard_Munteanu> parcs: Int -> Int isn't :: * -> *
20:41:52 <Eduard_Munteanu> What would you expect (Int -> Int#) :: to be?
20:42:41 <Eduard_Munteanu> Also the kind for (->) is wrong.
20:42:41 <parcs> Eduard_Munteanu: it implies that Int# is a lifted kind
20:42:54 <parcs> er, lifted type
20:43:03 <Eduard_Munteanu> (->) :: ?? -> ? -> *   IIRC
20:43:42 <Eduard_Munteanu> And # is a subkind of '?'.
20:45:14 <geekosaur> ghc doesn't actually do those kinds nay more, does it?
20:45:19 <geekosaur> new kind stuff replaced it?
20:45:41 <parcs> Nisstyre: i'm not sure. i guess the real problem is that the kind system doesn't have a formal foundation like the type system does
20:45:41 <Eduard_Munteanu> Funny... I'm getting old.
20:50:17 <parcs> @ty let f :: (Num Int => Num Int) => (); f = undefined in f
20:50:19 <lambdabot> (Num Int => Num Int) -> ()
20:50:34 <shachaf> parcs: That's just a bug.
20:51:08 <Eduard_Munteanu> Wow.
20:51:47 <parcs> :k Num Int => Show
20:51:49 <lambdabot> *
20:51:58 <Eduard_Munteanu> @ty f :: foo bar baz; f = undefined in f
20:52:01 <lambdabot> parse error on input `;'
20:52:15 <geekosaur> "let"
20:52:16 <Eduard_Munteanu> @ty let f :: foo bar baz !!!111; f = undefined in f
20:52:18 <lambdabot> parse error on input `111'
20:52:32 <Eduard_Munteanu> Ok, so it isn't downright stupid. :P
20:52:43 <Eduard_Munteanu> @ty let f :: String; f = undefined in f
20:52:44 <lambdabot> String
20:53:26 <Eduard_Munteanu> @ty let f :: DoesNotExist; f = undefined in f
20:53:28 <lambdabot>     Not in scope: type constructor or class `DoesNotExist'
20:54:06 <parcs> :k (Num Int => Show) Char => () -- triggers a panic
20:54:42 <Eduard_Munteanu> In ghci?
20:54:46 <parcs> yeah
20:54:50 <Eduard_Munteanu> Ok, so not a lambdabot thing. :P
20:54:54 <Eduard_Munteanu> s/P/O/
20:54:56 <parcs> what should be the kind of 'Num Int => Show'?
20:55:01 <shachaf> There shouldn't be a kind.
20:55:03 <shachaf> It's an error.
20:55:14 <parcs> why shouldn't it be a kind?
20:55:18 <geekosaur> untrue
20:55:22 <parcs> er, have*
20:55:36 <geekosaur> well, no, it's an error, just not that kind of error
20:55:39 <Eduard_Munteanu> You could interpret it as a kind I guess... but you need constraints that contain constraints... weird.
20:55:41 <geekosaur> it's an undefined type constructor
20:55:56 <shachaf> parcs: Because no one has said what it should mean.
20:56:46 <geekosaur> @bot
20:56:46 <lambdabot> :)
20:57:02 <parcs> if => had kind Constraint -> k -> k, then Num Int => Show :: * -> Constraint
20:57:13 <Eduard_Munteanu> I wonder...   can you use bogus definitions to tell the compiler to check a certain type has a particular instance?
20:57:19 <Eduard_Munteanu> Like    check :: Num Int
20:57:31 <elliott> Eduard_Munteanu: you can do check :: Num Int => ()
20:57:34 <elliott> i guess
20:57:39 <elliott> or check :: Dict (Num Int); check = Dict
20:57:40 <Eduard_Munteanu> Hm, yeah, good enough.
20:57:44 <elliott> with data Dict c where Dict :: c => Dict c
20:57:58 <Eduard_Munteanu> Uh, dunno Dict, I should look this up.
20:58:29 <Eduard_Munteanu> It wouldn't be particularly useful though, perhaps in the presence of orphan instances?
20:58:29 <shachaf> data Dict k = k => Dict
20:58:53 <Eduard_Munteanu> Where k :: Constraint I guess.
20:59:47 <parcs> Num Int => Show would be an impredicative type or something
20:59:49 <Eduard_Munteanu> Or maybe it is useful, given sufficiently advanced Olegery.
21:00:01 <Eduard_Munteanu> parcs: how so
21:00:27 <Eduard_Munteanu> Looks like a constraint to me.
21:01:01 <parcs> yeah perhaps it wouldn't
21:01:30 <tgeeky> Olegery actually sounds like a type of magic.
21:01:35 <Eduard_Munteanu> (Num Int => Show) Char => ()   should be pretty much     (Num Int, Show Char) => ()    IMO.
21:01:56 <Eduard_Munteanu> It's a kind of magic... *whistles*
21:01:58 <tgeeky> Eduard_Munteanu: did you mean to have an extra => in there somewhere?
21:02:23 <Eduard_Munteanu> Um.
21:02:35 <tgeeky> (Num Int => Show) Char ?
21:02:36 <Eduard_Munteanu> tgeeky: no, why? Where?
21:02:41 <tgeeky> between ) and Char
21:02:45 <parcs> Eduard_Munteanu: i don't think so. (Num Int => Show) Char should be (Num Int => Show Char), but who knows what the latter means :P
21:02:57 <Eduard_Munteanu> < parcs> :k (Num Int => Show) Char => () -- triggers a panic
21:02:59 <Eduard_Munteanu> Oops.
21:03:40 <Eduard_Munteanu> tgeeky: wait, no, I do mean that
21:03:49 <Eduard_Munteanu> I thought I misread.
21:04:08 <tgeeky> Eduard_Munteanu: I don't know anything about anything, it just looks strange to me.
21:04:18 <Eduard_Munteanu> parcs: presumably the Show constraint requires that Num constraint, so you end up checking both
21:04:38 <Eduard_Munteanu> tgeeky: GHC agrees, it panics :)
21:05:27 <parcs> Eduard_Munteanu: hmm yeah
21:05:30 <natnayr> how do u get haskell to print out values like in c programs of printf just to check the values
21:05:33 <Eduard_Munteanu> #haskell once more proves to be more brave than GHC.
21:05:41 <tgeeky> natnayr:
21:05:50 <tgeeky> @let x = "hello" in show x
21:05:50 <lambdabot>   Parse error: in
21:05:57 <tgeeky> > show "hello"
21:05:58 <lambdabot>   "\"hello\""
21:06:13 <Eduard_Munteanu> > show False
21:06:15 <lambdabot>   "False"
21:06:58 <natnayr> in the event of writing a function, can u use that in the "where" clause?
21:07:04 <Eduard_Munteanu> natnayr: but it depends what you mean by that.... print values from IO? Outside IO? In ghci?
21:07:14 <Eduard_Munteanu> No.
21:07:30 <Eduard_Munteanu> If I'm guessing right, you want Debug.Trace.
21:07:33 <Eduard_Munteanu> @hoogle trace
21:07:34 <lambdabot> Debug.Trace module Debug.Trace
21:07:34 <lambdabot> Debug.Trace trace :: String -> a -> a
21:07:34 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
21:08:01 <applicative> natnayr: Debug.Trace is the equivalent of 'printf debugging'
21:08:15 <Eduard_Munteanu> You could write stuff like    add a b = traceShow a (a + b)
21:08:22 <applicative> @quote oasis
21:08:22 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
21:08:37 <Eduard_Munteanu> Which prints 'a' and evaluates to 'a + b'.
21:09:22 <Eduard_Munteanu> Be careful the desert is full of illusions. ;)
21:36:37 <mushi> hi can someone else me write the http://pastebin.com/njSZeS18
21:36:45 <mushi> i ve spent a few hours
21:36:55 <mushi> and i ve gone back to base 1 to build it up agian
21:37:11 <natnayr> > map (+1) [1..20]
21:37:13 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]
21:37:42 <ab9rf> mushi: what are you hoping to accomplish?
21:38:09 <tgeeky> mushi: language note: this would be "psuedo" code, not "sudo" code.
21:38:20 <ab9rf> sudo make me a sandwich
21:38:53 * tgeeky makes ab9rf a Chinese-imported psuedo sandwhich, with plastic lettuce.
21:38:59 <mushi> ab9rf: i am trying to write the accelerate function
21:39:07 * hackagebot vector-binary-instances 0.2.1.0 - Instances of Data.Binary and Data.Serialize for vector  http://hackage.haskell.org/package/vector-binary-instances-0.2.1.0 (BryanOSullivan)
21:39:09 * hackagebot htiled 0.1.1 - Import from the Tiled map editor.  http://hackage.haskell.org/package/htiled-0.1.1 (ChristianRoedliAmble)
21:39:10 <mushi> which accelerates particles in s imulation
21:39:12 <ab9rf> mushi: the type you give for accelerate doesn't seem to make sense with the description
21:39:56 <tgeeky> mushi: certainly you wouldn't want to use a Float as an identifier of a particle
21:40:09 <ab9rf> and acceleration is typically a vector
21:40:09 <mushi> hold on ab9rf  i ll give your more information about function
21:40:27 <mushi> (i ve been given the type by lecturer so cant do much)
21:41:02 <mushi> http://pastebin.com/GZSfdBND
21:41:10 <mauke> The paste GZSfdBND has been copied to http://hpaste.org/85737
21:41:16 <mushi> that should clear up more about accelerate function
21:41:56 <applicative> so the float is the period of time?
21:42:16 <ab9rf> ah
21:42:17 <mushi> yes applicative
21:42:19 <tgeeky> "the number of seconds that pass in the current time step"
21:43:19 <ab9rf> so accelerate takes a time step and a list of particles, and returns a new list of particles suitably accelerated?
21:43:20 <tgeeky> i think it's awesome that someone is asking you to do physics homework in haskell, though
21:44:40 <ab9rf> should be able to do that with a map
21:44:45 <mushi> the last time i done physics was in HS
21:44:52 <mushi> now in 3rd year uni
21:45:08 <applicative> this is a physics class?
21:45:18 <mushi> nope haskell
21:45:31 * tgeeky retracts my admiration
21:45:33 <applicative> yeah, seemed a bit too much to hope...
21:46:50 <tgeeky> at least he's doing it on a saturday night, before the night it's due :o
21:46:52 <mushi> can anyone please help me with this, i am quite stressing out its due in about 10 hours
21:47:02 * tgeeky retracts his statement again
21:47:26 <mushi> to be fair i did try it last night
21:47:38 <mushi> i was like eh maybe a sleep will help
21:47:55 <ab9rf> mushi: i think you need to offer a more focused inquiry if you want help...
21:49:48 <applicative> I see, accelerate is the function you are to write... force is given.
21:49:58 <mushi> ok first thing first i am trying to write the "make a new recursive function which is passed in a particle from the list as well as all the other particles"
21:49:58 * applicative is moving slowly as usual
21:50:42 <tgeeky> mushi: ignoring the recursive part, that means you have (Particle, [Particle]) ->
21:51:35 <mushi> recForce :: Particle -> [Particle] -> Particle
21:51:44 <mushi> do you guys think that could be correct type?
21:52:26 <applicative> accelerate1 :: Float -> Particle -> [Particle] -> Particle, isn't this it
21:52:36 <mushi> or maybe recForce :: Float -> [Particle] -> Particle
21:53:35 <mushi> oh right applicative makes sense
21:53:35 <tgeeky> mushi: that certainly can not be right. You have no way of identifying a single particle in question
21:55:12 <applicative> once you have accel1 ::  Float ->  [Particle] -> Particle -> Particle which says how time and a bunch of others update a particle, then you just map it over the list of particles.
21:57:58 <applicative> you build it by a oneAccelOne :: Float -> Particle -> (Particle -> Particle) saying how time and one particle act to update a particle.
21:57:59 <mushi> i will try that now applicative thanks
21:58:06 <applicative> you build that immediately with force, as given
22:00:21 <applicative> I see, 'force' arranges that you don't have to worry about summing in the effect of a particle on itself, so much of this will be simple mapping, and whatever sum you need to write for accel1 as I was calling it
22:05:47 <ab9rf> applicative: yeah
22:06:52 <ab9rf> applicative: otherwise you'd have to exclude the particle which is annoying
22:06:55 <mushi> so would be something along this line
22:06:55 <mushi> accelerate1 TimeI (current: restofparticles)
22:07:10 <ab9rf> applicative: but because you don't this is just a nested pair of maps
22:07:43 <mushi> also can someone please explain maps in haskell? in a few lines we havent learnt them but are alowed to use them
22:07:47 <ab9rf> well one is a map
22:07:55 <ab9rf> the other is a foldr
22:09:10 <ab9rf> roughly, accel1 is foldr vector-sum (map (\pt -> force pt) particles)
22:09:38 <ab9rf> and accelerate just maps accel1 over particles
22:10:22 <ab9rf> > map (*5) [0..6]
22:10:25 <lambdabot>   [0,5,10,15,20,25,30]
22:10:39 <ab9rf> > map (toUpper) "Help me!"
22:10:41 <lambdabot>   "HELP ME!"
22:11:03 <mushi> so map is somewhat like a linkedlist but alot more flexible
22:11:06 <ab9rf> > map (chr) [65,75,95]
22:11:08 <lambdabot>   "AK_"
22:11:11 <mauke> > map f [x,y,z] :: [Expr]
22:11:13 <ab9rf> mushi: no
22:11:13 <lambdabot>   [f x,f y,f z]
22:11:42 <mauke> map-the-function is unrelated to map-the-data-structure
22:11:57 <ab9rf> mushi: map applies a function to each element of its second argument (a list), returning a list of the results
22:13:32 <ab9rf> @src map
22:13:33 <lambdabot> map _ []     = []
22:13:33 <lambdabot> map f (x:xs) = f x : map f xs
22:14:09 <ab9rf> you'll note tht map is recursive
22:25:29 <flebron> map takes a function from a to b (say, f :: Int -> Char), and gives you a function that works on lists of Int, and produces lists of Char. That is, (Int -> Char) -> [Int] -> [Char], for instance.
22:25:47 <flebron> (this is an alternative and equivalent way of seeing it
22:39:09 * hackagebot github-backup 1.20130414 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20130414 (JoeyHess)
22:41:48 * applicative sense a circle in github-backup, doesn't github know something new once it acts; is there a 'fixed point' ? 
22:42:50 <ryant5000> applicative: lol, i just clicked the link because i was curious about that
22:43:08 <ryant5000> from what i gather you clone the repo, and it gathers the stuff into your *clone*
22:43:22 <ryant5000> which i suppose you could then push back up if you wanted
22:44:15 <applicative> I see.
22:44:53 <applicative> but clearly there would be trouble if it kept pushing , querying github and repushing...
22:45:03 <ryant5000> applicative: that would certainly seem to be the case :P
22:45:22 <applicative> i guess you'd bring down your computer before you brought github, unfortunately...
22:45:26 <ryant5000> haha
22:45:39 <applicative> brought down github
22:45:45 <ryant5000> well, since git's storing it all as deltas, it might not be an exponential expansion of space
22:46:08 <ryant5000> each push/backup cycle might only add a small amount of overhead
22:46:16 <ryant5000> but this is all baseless speculation :P
22:46:33 <applicative> yes, that's why i wondered about a fixed point
22:46:44 <applicative> i think this is the git-annex guy
22:47:03 <applicative> i considered learning about it out of haskell-patriotism
22:48:38 <ryant5000> applicative: interesting
22:48:46 <applicative> he had the sensible idea of getting 'crowd sourcing' with kickstarter
22:49:29 <jamy> Hello all!
22:50:07 <applicative> hello jamy
22:50:31 <jamy> If i make data Node = Node {color:: Int}
22:50:49 <applicative> perfectly good type
22:51:01 <applicative> somehow I feel a Node needs a little more....
22:51:02 <jamy> how then i get color in pattermatching ?
22:51:47 <applicative> in pattern matching you can write foo (Node c) = Node (c+1) for example
22:52:16 <jamy> dont understand
22:52:37 <applicative> what is most sensible will depend on what you are doing, but "increaseColor (Node color) = Node (color + 1) makes perfect sense
22:53:10 <applicative> then you aren't making actual use of the record syntax, of course
22:53:35 <jamy> (Node color) is get color?
22:53:49 <applicative> you extract the color by writing  color node
22:54:14 <applicative> getColor is just color, so color (Node 17) = 17
22:54:31 <jamy> thats real? i not see sens?
22:54:37 <mushi> applicative: can you check query real quick please?
22:55:47 <applicative> so you could write biggerColor node1 node2 = color node1 > color node2
22:57:10 <applicative> jamy, or am I still being opaque?  maybe someone else can say the perfect thing.
22:57:28 <applicative> a more definite example or problem might help.
22:57:49 <jamy> instance Node where (Node color) == (Node color) = True
22:58:03 <jamy> instance Eq Node where (Node color) == (Node color) = True
22:58:45 <applicative> it should be instance Eq Node where (Node color) == (Node color') = color == color'
22:59:15 <jamy> ok! Thank you very much!
22:59:39 <applicative> but this will come automatically if you add 'deriving Eq' to the data declaration, data Node = Node {color :: Int} deriving (Eq, Ord, Show)
23:00:59 <applicative> in this case since there is only one field you can also write newtype Node = Node {color :: Int} deriving (Eq, Ord, Show) which has some advantages, but I was thinking you might want more fields
23:02:06 <jamy> if i want custom show method?
23:02:45 <mikeplus64> then don't derive it, you can just have deriving (Eq, Ord, ... whatever instances you want derived if they can be derived ...), and a custom Show instance
23:03:13 <jamy> ok! I try it now
23:03:49 <applicative> the derived Show instances for record types are pretty lame so it's probably a good idea....
23:04:43 <mikeplus64> i like them, they are such that read . show = id
23:04:45 <mikeplus64> i think
23:05:18 <mikeplus64> i think Show is best for "showing" data as it would appear in haskell code
23:05:25 <applicative> well, yes that is a desirable property, but in this case, I would rather "Node 17" than "Node {color = 17}"
23:05:53 <jamy> applicative: why?
23:05:56 <amiller> why is it that the generics library emgm in 4.0 removed the automatic deriving stuff but in emgm-3.1 it's there
23:06:00 <amiller> was it not working or osmething?
23:06:40 <applicative> jamy: it's just easier to take in when you're testing things in ghci, but it isn't a serious matter, maybe my taste is silly here
23:08:16 <applicative> jamy the point mikeplus64 mentioned is the important or potentially important one, that you would like the show instance to be something ghc can understand as a representation of Node
23:08:17 <mushi> hey applicative dude are you still around?
23:08:33 <applicative> jamy: in the case of record types there are two choices
23:09:10 * hackagebot pipes-concurrency 1.0.0 - Concurrency for the pipes ecosystem  http://hackage.haskell.org/package/pipes-concurrency-1.0.0 (GabrielGonzalez)
23:10:01 <jamy> in my case Hugs
23:11:03 <mikeplus64> jamy: hugs is kind of dead, and will probably have much slower code than ghc, but if it's fine for your purposes there's no harm i guess
23:11:50 <jamy> I make not for production. It is test work
23:12:24 <applicative> jamy: it's fine, if you keep going you will certainly want the ghc
23:13:44 <jamy> mybe in future, but now its only simple easy task
23:14:50 <jamy> maybe in future, but now its only single easy task
23:23:51 <xpika> are there any other programming languages that support automatic currying like haskell?
23:24:09 <ryant5000> xpika: ML and its family do
23:24:26 <Cale> Agda and Coq
23:25:31 <`nand`> I don't see much of a functional difference between automatic currying vs. multi-argument functions with automatic closures for partial applications. Is there any?
23:25:32 <Cale> and F# though that probably counts as an ML
23:26:32 <`nand`> well, discounting ‚ä• and unsafePerformIO
23:27:39 <applicative> yes, lets discount them
23:28:18 <`nand`> ?wn discount
23:28:18 <lambdabot> *** "discount" wn "WordNet (r) 3.0 (2006)"
23:28:19 <lambdabot> discount
23:28:19 <lambdabot>     n 1: the act of reducing the selling price of merchandise [syn:
23:28:19 <lambdabot>          {discount}, {price reduction}, {deduction}]
23:28:19 <lambdabot>     2: interest on an annual basis deducted in advance on a loan
23:28:20 <lambdabot> [10 @more lines]
23:28:25 <`nand`> ?more
23:28:25 <lambdabot>        [syn: {discount rate}, {discount}, {bank discount}]
23:28:25 <lambdabot>     3: a refund of some fraction of the amount paid [syn: {rebate},
23:28:26 <lambdabot>        {discount}]
23:28:28 <`nand`> ?more
23:28:28 <lambdabot>     4: an amount or percentage deducted [syn: {deduction},
23:28:30 <lambdabot>        {discount}]
23:28:31 <`nand`> blah
23:28:32 <lambdabot> [5 @more lines]
23:28:33 <`nand`> ?more
23:28:35 <lambdabot>     v 1: bar from attention or consideration; "She dismissed his
23:28:37 <lambdabot>          advances" [syn: {dismiss}, {disregard}, {brush aside},
23:28:37 <`nand`> there :D
23:28:38 <lambdabot>          {brush off}, {discount}, {push aside}, {ignore}]
23:28:41 <lambdabot>     2: give a reduction in price on; "I never discount these books-
23:28:43 <lambdabot>        they sell like hot cakes"
23:28:54 <shachaf> Let's discount this channel.
23:29:03 * applicative dismisses the advances of unsafePerformIO and _|_
23:29:18 <shachaf> By discount I mean fill it with definitions of English words.
23:29:34 <`nand`> (is there some easier way to tell ?wn what to output? Say I'm only interested in the verb)
23:29:43 <jamy> `nand`: whats this?
23:30:49 * applicative isn't able to keep all the messages about who quit and joined out, so he doesn't care about ?wn
23:31:31 <`nand`> ah, qwebirc. Well, most clients these days should have the option to remove messages like those in some way or another
23:32:06 <applicative> yeah I"m not using a client I gave up on irssi since I didn't have the patience to configur eit
23:32:25 <latermuse> applicative: what do you use?
23:32:30 <`nand`> in particular, weechat lets me hide them for all people that haven't been active within the past 5 minutes (so I'm still aware if somebody disconnected mid-covnersation)
23:32:43 <applicative> at the moment http://webchat.freenode.net/ like a moron
23:33:01 <`nand`> but weechat wasn't particularly easy to configure either
23:33:17 <`nand`> I'm sure some of the more ‚Äòout of the box‚Äô clients like x-chat might be able to do it as well
23:33:49 <applicative> yes, I had some gui one that did it, a while back, but it had some other obnoxious feature.
23:34:09 <applicative> in the future even the terminal will be inside the browser, surely.
23:34:21 <applicative> itll be javascript all the way down
23:34:55 <`nand`> all chugging along with ghcjs
23:35:28 <`nand`> applicative: don't Windows 8 and Gnome 3 effectively already support native javascript applications?
23:35:58 <applicative> well, that wouldn't be so bad, I can't believe people will put up with the all-javascript future that seems increasingly in store for us
23:36:17 <applicative> ghcjs wouldn't be so bad i mean
23:36:20 <`nand`> the world won't go full-javascript until we give up and let it
23:36:31 * applicative has only heard of it
23:37:03 <`nand`> I have javascript disabled on most sites and the internet still works for me
23:37:12 <`nand`> so it's not that bad yet
23:37:12 * applicative begins composition of the first operating system written in pure javascript
23:37:54 <`nand`> hasn't linux been ported to javascript or something?
23:37:59 <`nand`> running on some virtual machine
23:38:18 <applicative> maybe I should try that. certainly I would like to kill anything that moves on the internet
23:38:37 <mushi> applicative: query
23:38:57 <shachaf> `nand`: You're thinking of x86.
23:38:59 <`nand`> oh you should, it's much better - in particular, the internet is much faster and more responsive even on this inherently slow-as-a-snail browser (firefox)
23:39:50 <`nand`> shachaf: that's possible: ‚ÄúThe JavaScript PC Emulator can do the work of an Intel 486 chip from the 1990s, but doesn't have a built-in floating point unit for numeric processing, Bellard said. Happily, Linux itself can emulate that, and a version of the operating system's core--2.6.20--runs on the foundation. ‚Äù <- this?
23:40:19 <shachaf> The one by Bellard is an x86 implementation, yes.
23:41:12 <`nand`> yes, so it's less of a linux port and more of an implementation of the environment linux runs on; but the result is the same - linux in the browser
23:42:46 <jamy> applicative: not first
23:43:55 <jamy> applicative: and why JS? Why not haskell?
23:47:05 <applicative> ah, I did it `nand`, well see how many exceptions I have to add
23:47:50 <`nand`> applicative: don't forget to get requestpolicy as well, also disable cookies
23:48:15 <`nand`> for good measure, disallow css images and page-specified colors/fonts
23:48:31 <`nand`> and uninstall the flash player, that's the most important bit
23:49:41 <applicative> hah, i just noticed 'Do not show any images'
23:50:04 <applicative> Moses was against them, why not me?
23:50:19 <`nand`> oh, that may not be what you want; if it disables the images you *want* to see as well => I mean ‚ÄúAllow pages to choose their own colors‚Äù which, if disabled, also disables css's background-image stuff
23:50:32 <`nand`> though requestpolicy should cover those as well
23:55:03 <jamy> applicative: you my Node has two or less field in record. How i can compare Nodes by colors?
23:55:36 <jamy> *you -> if
23:56:34 <applicative> whats the definition of Node now?
23:56:42 <applicative> i mean the type declaration
23:57:42 <jamy> allmost same data Node = Node {color::Int, angle::Int ...}
