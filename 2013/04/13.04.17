00:28:03 <tsinnema> hey -- i see that there are a bunch of different tools for generating ctags of haskell code. is there any that is particularly good with various ghc extensions? type synonym families and template haskell and such?
00:28:26 <tsinnema> how good is the ghci tag generation?
00:35:58 <mm_freak> tsinnema: just take a somewhat large code base and try it out
00:36:12 <mm_freak> to get one try this:  cabal unpack lens
00:36:18 <mm_freak> or cabal unpack netwire or …
00:39:19 <tsinnema> mm_freak, sounds reasonable, i'll probably try it out after a while unless i get some big other recommendation for what to do
00:39:23 <tsinnema> thakns
01:49:31 <kvda> how come dropWhileEnd (`elem` ['a'..'Z']) "foo...a" doesn't drop the last 'a'?
01:50:19 <kvda> dropWhileEnd (`elem` ['.']) "foo..." removes the dots
01:53:12 * hackagebot language-python 0.4.0 - Parsing and pretty printing of Python code.  http://hackage.haskell.org/package/language-python-0.4.0 (BerniePope)
01:55:59 <adzeitor> > dropWhileEnd (`elem` ['a'..'z']) "foo...a"
01:56:00 <lambdabot>   "foo..."
01:56:05 <adzeitor> :D
01:57:02 <Kaidelong> > dropWhileEnd (`elem` ['A'..'z']) "foo..a"
01:57:04 <lambdabot>   "foo.."
01:57:18 <kvda> it's a type issue my 'foo…a' is actually Text
01:57:23 <Kaidelong> > 'A' > 'a'
01:57:25 <lambdabot>   False
01:57:46 <Kaidelong> > ['a'..'Z']
01:57:48 <lambdabot>  Terminated
01:58:16 <kvda> how would you make ['a'..'Z'] into Text besides map Data.Text.pack?
01:58:35 <Kaidelong> ['A'..'z']
01:58:39 <Kaidelong> > ['A'..'z']
01:58:41 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
01:59:07 <adzeitor> kvda: why not ['a'..'z'] ++ ['A'..'Z']?
01:59:28 <Kaidelong> @hoogle Text -> Bool
01:59:29 <lambdabot> Data.Text null :: Text -> Bool
01:59:29 <lambdabot> Data.Text.Lazy null :: Text -> Bool
01:59:29 <lambdabot> Data.Text.Lazy.Internal strictInvariant :: Text -> Bool
01:59:37 <Kaidelong> mmm
02:00:50 <kennyd> > dropWhileEnd isAlpha "foo...a"
02:00:52 <lambdabot>   "foo..."
02:01:07 <Kaidelong> @ty isAlpha
02:01:09 <lambdabot> Char -> Bool
02:01:15 <Kaidelong> the problem is
02:01:21 <Kaidelong> oh well
02:01:32 <Kaidelong> @hoogle a -> Text -> Bool
02:01:33 <lambdabot> Data.Text isInfixOf :: Text -> Text -> Bool
02:01:33 <lambdabot> Data.Text.Lazy isInfixOf :: Text -> Text -> Bool
02:01:33 <lambdabot> Data.Text isPrefixOf :: Text -> Text -> Bool
02:01:53 <Kaidelong> @hoogle Text -> a -> Bool
02:01:54 <lambdabot> Data.Text isInfixOf :: Text -> Text -> Bool
02:01:54 <lambdabot> Data.Text.Lazy isInfixOf :: Text -> Text -> Bool
02:01:54 <lambdabot> Data.Text isPrefixOf :: Text -> Text -> Bool
02:02:28 <Kaidelong> kvda: looks like you may just need to unpack/repack
02:02:34 <kvda> kenny the "foo…a" is of Text type, i guess you could unpack repack
02:02:44 <kvda> Kaidelong, hah yes
02:02:47 <Kaidelong> however
02:02:47 <kvda> thanks all :)
02:02:54 <Kaidelong> What I was trying to illustrate earlier
02:03:01 <Kaidelong> was that ['a'..'Z'] is wrong too
02:03:09 <Kaidelong> because 'Z' comes before 'a'
02:03:19 <Kaidelong> so fix that
02:03:30 <Kaidelong> @ty isAlpha
02:03:32 <lambdabot> Char -> Bool
02:03:56 <Kaidelong> should do what you want with the added bonus of working on things like ð
02:04:11 <Kaidelong> well...
02:04:20 <kvda> ah i see
02:04:21 <Kaidelong> > isAlpha 'ð'
02:04:22 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
02:05:45 <kvda> dropWhileEnd is only Data.Text
02:05:46 <Kaidelong> > isAlpha '\u00F0'
02:05:47 <kvda> :/
02:05:48 <lambdabot>  Terminated
02:06:06 <Kaidelong> @ty dropWhileEnd
02:06:07 <lambdabot> (a -> Bool) -> [a] -> [a]
02:06:32 <Kaidelong> @hoogle dropWhileEnd
02:06:32 <lambdabot> Data.Text.Lazy dropWhileEnd :: (Char -> Bool) -> Text -> Text
02:06:33 <lambdabot> Data.Text dropWhileEnd :: (Char -> Bool) -> Text -> Text
02:06:47 <Kaidelong> mmm
02:06:54 <kvda> hah
02:07:03 <Kaidelong> is dropWhileEnd maybe part of the prelude?
02:07:12 <kvda> dropWhile is
02:07:45 <Kaidelong> @src dropWhileEnd
02:07:45 <lambdabot> Source not found. My brain just exploded
02:08:26 <kvda> maybe i can do 'let x = map Data.Text.pack ['A'..'Z]'
02:08:30 <kvda> ?
02:08:42 <Kaidelong> dropWhileEnd p = foldr (\x xs -> if p x && null xs then [] else x : xs) []
02:09:27 <Kaidelong> best way to find out would be to try it and see if it works
02:09:38 <kvda> yep trying it now
02:09:59 <kvda> just wanted to make sure that's not an obviously wrong thing to try :)
02:11:10 <adzeitor> kvda: Data.Text.pack ['A'..'Z'] because T.pack :: String -> Text
02:11:47 <kvda> ah yes
02:11:52 <kvda> thanks adzeitor
02:14:22 <adzeitor> kvda: you are welcome.
02:14:25 <kvda> let alpha = T.pack ['A'..'z']
02:15:32 <kvda> let x = T.pack "A"
02:15:43 <adzeitor> kvda: What exactly do you want?
02:16:05 <kvda> Data.Text.dropWhileEnd (`elem` alpha) x
02:16:25 <adzeitor> dropWhileEnd :: (Char -> Bool) -> Text -> Text
02:16:30 <adzeitor> Char -> Bool , not Text -> Bool
02:16:43 <kvda> ahh right
02:17:28 <kvda> I'm trying to cut a sentence cleanly
02:17:37 <kvda> i.e. not mid way through a word
02:19:31 <adzeitor> can you give an example of this?
02:19:54 <kvda> I got that to work
02:21:59 <kvda> i was unpacking the Text that i was passing to Data.Text.dropWhileEnd
02:22:14 <kvda> which it clearly isn't going to work
02:22:28 <kvda> thanks for your help adzeitor , Kaidelong
02:22:45 <kvda> it's a long day.
02:28:21 <kvda> heh, Data.Text.dropWhileEnd isAlpha t
02:28:24 <kvda> does the same thing
02:34:18 <qnikst> hello, can anybody reproduce or explain wierd behavior: of http://hpaste.org/85980
02:34:27 <qnikst> without -O everything is ok
02:34:46 <qnikst> but if I'm compiling with -O I've got incorrect response
02:35:01 <qnikst> and I'm using ghc-7.6.2
02:35:36 <adzeitor> hi qnikst :D
02:36:46 <kvda> is there a way of composing functions that otherwise wouldn't?
02:37:13 <kvda> (monads?)
02:37:39 <tapas> kvda: what kind of functions?
02:37:48 <qnikst> same stuff on ghc-7.4.2
02:38:07 <kvda> isAlpha and isPunctuation is what got me thinking about it
02:38:35 <adzeitor> qnikst: 7.6.2 debian. Same thing.
02:38:36 <kvda> i.e. they're both Char -> Bool
02:38:44 <kvda> so you can't compose them
02:39:10 <tapas> kvda: what should the composition of these do?
02:39:28 <_mr> kvda: you would like them to be "pointwise anded"?
02:39:56 <kvda> they check if the characters in a string are alpha or punctuation..
02:40:09 <kvda> _mr, yes i think so
02:40:32 <qnikst> adzeitor: do you have any idea where I should fill bug report, text package?
02:41:51 <dimka> What is the difference between modal and temporal logic?
02:41:52 <luite> qnikst: same with GHC HEAD
02:42:13 <_mr> kvda: I think you can make Bool a Monoid. Then use the Monoid b => Monoid (a -> b) instance. But I don't know if that's really worth it
02:42:35 <_mr> (The Monoid instance of Bool using and is All, IIRC)
02:44:42 <adzeitor> qnikst: Try replace T.hexadecimal to  T.decimal. I think bug in hexadecimal...
02:45:53 * qnikst submitted a bug report
02:46:30 <qnikst> adzeitor: yes
02:46:36 <qnikst> decimal works for me
02:47:50 <kvda> thanks _mr, it does seem a bit unnecessary for this
02:48:50 <merijn> kvda: Maybe you want the arrow combinators!
02:48:53 <merijn> :t (***)
02:48:55 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:49:48 <merijn> :t let isAlpha :: Char -> Bool; isAlpha = undefined; isPunctuation :: Char -> Bool; isPunctuation = undefined in isAlpha &&& isPunctuation
02:49:49 <lambdabot> Char -> (Bool, Bool)
02:49:53 <merijn> \o/
02:50:32 <kvda> ermagard
02:50:38 <kvda> i think that might be it
02:51:02 <kvda> I'll test it out, thanks merijn
02:51:07 <merijn> Or, better
02:51:20 <merijn> :t let isAlpha :: Char -> Bool; isAlpha = undefined; isPunctuation :: Char -> Bool; isPunctuation = undefined in uncurry (&&) . isAlpha &&& isPunctuation
02:51:21 <lambdabot>     Couldn't match expected type `(Bool, Bool)' with actual type `Bool'
02:51:21 <lambdabot>     Expected type: Char -> (Bool, Bool)
02:51:21 <lambdabot>       Actual type: Char -> Bool
02:51:27 <merijn> aww
02:51:29 <merijn> :t uncurry
02:51:30 <lambdabot> (a -> b -> c) -> (a, b) -> c
02:51:48 <merijn> :t uncurry (&&)
02:51:50 <lambdabot> (Bool, Bool) -> Bool
02:52:06 <merijn> :t let isAlpha :: Char -> Bool; isAlpha = undefined; isPunctuation :: Char -> Bool; isPunctuation = undefined in uncurry (&&) . (isAlpha &&& isPunctuation)
02:52:07 <lambdabot> Char -> Bool
02:52:11 <merijn> There you go
02:52:44 <supki> > sequence [isAlpha, isPunctuation] 'a'
02:52:46 <lambdabot>   [True,False]
02:55:06 <luite> qnikst: hm, odd, doing the same outside the text package works ok
02:55:30 <luite> with the same digit -> char conversion, only modified to produce a String
02:55:53 <kvda> that's pretty clever, i'll look that up too
02:56:07 <qnikst> luite: I'm afraid it's some rewriting rule
02:56:34 <luite> qnikst: yeah there is none for Integer though
02:56:44 <luite> oh wait there is one
02:57:18 <luite> it uses integer 16 instead of hexadecimal
02:59:13 <kvda> merijn, btw why is the 2nd one 'better'?
02:59:41 <qnikst> luite: /me don't understand how it should be fixed
02:59:47 <merijn> kvda: Well, not so much better but you can uncurry && or || depending on what you want to get a nice single result
03:00:01 <merijn> i.e. whether both are true, or at least one is
03:00:07 <luite> qnikst: well without optimization it uses hexadecimal directly, with optimization the rewrite rule fires, so it uses integer 16, the bug must be somewhere in there
03:00:16 <kvda> i see
03:00:32 <qnikst> ok, will try to check
03:00:43 <kvda> is there much difference between isAlpha and `elem` ['A'..'z']?
03:00:51 <kvda> besides clarity
03:01:03 <merijn> kvda: Yes
03:01:28 <merijn> > isAlpha 'λ'
03:01:29 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
03:01:38 <merijn> oh, right lambdabot doesn't do unicode...
03:01:43 <merijn> kvda: Try that in ghci :)
03:01:46 <qnikst> hm.. and integer 16 (S# i#) = hexadecimal (I# i#)
03:01:56 <merijn> isAlpha handles all of unicode, not just ASCII
03:02:16 <kvda> ah right, that's a big one
03:02:23 <m3ga> @hoogle words
03:02:23 <lambdabot> Prelude words :: String -> [String]
03:02:24 <lambdabot> Data.List words :: String -> [String]
03:02:24 <lambdabot> Data.String words :: String -> [String]
03:02:44 <merijn> I suspect isAlpha is also faster since it can use lookups based on the unicode codepoint, instead of membership test on a list (which is O(n) in the list length)
03:03:16 * hackagebot sgd 0.3.1 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.3.1 (JakubWaszczuk)
03:03:36 <kvda> merijn, that's the other thing i wasn't sure about, i though isAlpha could be faster
03:03:46 <kvda> thanks :)
03:04:24 <no-n[11]> > getChar
03:04:26 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Types.Char))
03:04:26 <lambdabot>    arising fr...
03:04:32 <no-n[11]> y
03:04:58 <luite> qnikst: the problem is in the last lines of integer
03:05:12 <luite> qnikst: in loop, it uses digit
03:05:23 <luite> it should use hexDigit
03:06:51 <qnikst> I see
03:09:57 <luite> qnikst: added it to your report
03:10:45 <qnikst> luite: thanks
03:14:04 <HugoDaniel> is there any efforts to make haskell run on llvm/asm.js ?
03:14:19 <luite> no
03:14:36 <luite> well, llvm there is, obviously, with the ghc llvm backend
03:14:39 <HugoDaniel> does it make any sense ?
03:14:40 <luite> but not asm.js
03:14:46 <luite> ghcjs doesn't target asm.js
03:15:18 <HugoDaniel> ok
03:15:52 <luite> not sure if it makes sense, it can only be done if you rewrite/recompile the whole garbage collector in javascript
03:15:58 <luite> and integer-gmp
03:16:20 <HugoDaniel> oh, yes :/
03:16:21 <HugoDaniel> true
03:16:30 <HugoDaniel> and the runtime ?
03:16:59 <HugoDaniel> i was just reading about asm.js and wondered if it could remotely be possible
03:17:00 <luite> can use a different runtime if you go from stg -> asm.js directly
03:17:37 <luite> currently it wouldn't work anyway, unless you compiled your whole program to one single huge javascript function
03:18:07 <luite> when tailcalls are added to js, then it might have a better chance
03:20:00 <luite> HugoDaniel: a problem with running in a js environment is that interacting with the browser and other js things is probably more important than with native hs programs
03:20:17 <luite> asm.js forces some low level stuff on you, that makes it rather hard
03:20:31 <luite> it's lower level than C
03:20:37 <luite> now structs, no memory management
03:20:41 <luite> and a lot more annoying
03:22:21 <luite> asm.js makese sense though if epic games pays you a lot to compile their game engine to javascript ;p
03:26:00 <luite> HugoDaniel: it also hides one major weakness of spidermonkey pretty well, they have a terrible garbage collector compared to v8. just forcing users to not use gc is the solution
03:26:46 <HugoDaniel> what is spidermonkey ?
03:27:01 <donri> the firefox js engine
03:27:12 <HugoDaniel> ah yes
03:27:13 <luite> firefox's js engine, made my mozilla, the same guys whoe came up with asm.js
03:27:17 <HugoDaniel> i was reading it on wikipedia
03:27:18 <HugoDaniel> :)
03:27:37 <luite> ghcjs code is often 4x slower with firefox
03:27:44 <luite> than with chrome
03:27:45 <donri> asm.js was made for emscripten and lljs, where it makes sense
03:28:02 <HugoDaniel> The idea of using Scheme was abandoned when "engineering management [decided] that the language must ‘look like Java’"
03:28:05 <HugoDaniel> just beautiful
03:28:07 <donri> luite: maybe target lljs instead ;)
03:29:37 <luite> "At the time of this writing, allocating structs is about as fast as allocating objects on v8, but noticeably faster on SpiderMonkey."
03:29:49 <luite> this is more a shortcoming of SpiderMonkey than an advantage of lljs
03:30:08 <luite> anyway they're working on a new GC, hopefully that means their allocator will also improve
03:31:47 <donri> oh lljs is manual memory management too?
03:31:51 <luite> yes
03:32:02 <donri> i don't see any free() calls :p
03:33:35 <donri> oh, nevermind
03:33:38 <luite> donri: delete gets translated to free
03:34:11 <donri> don't see any deletes either, i guess it's implicit to scope optionally?
03:34:28 <donri> ok there's a single delete on their page
03:35:59 <HugoDaniel> "LLJS manages memory using Typed Arrays. It allocates one large ArrayBuffer ahead of time, and creates several typed array views on this buffer, one for each of the primitive data types."
03:36:15 <HugoDaniel> that kind of feels like primitive
03:36:29 <luite> that's also what asm.js does
03:36:35 <HugoDaniel> reminds me of 1st year college projects :/
03:36:56 <HugoDaniel> do a big malloc and index inside of it
03:37:11 <HugoDaniel> or just go crazy and use the stack instead
03:37:35 <merijn> Insanity wolf: Allocate linked list...ON THE STACK!
03:37:37 <luite> HugoDaniel: if you're interested, there's still a ghcjs branch that does this to some extent
03:37:48 <merijn> I actually did that a couple of times, free GC in C \o/
03:38:31 <HugoDaniel> yes
03:38:47 <HugoDaniel> ghcjs seems cool, i must check it out
03:39:06 <luite> HugoDaniel: but i abandoned it because i really want to have a shippable release to coincide with ghc 7.8.1
03:39:20 <luite> spending 6 months on low level management isn't going to do much to make it usable
03:39:55 <HugoDaniel> you abandoned it ? :(
03:40:07 <luite> but maybe when tailcalls work it can be resurrected
03:40:22 <luite> HugoDaniel: not the whole ghcjs, the ghcjs branch that does heap management in a big array
03:40:28 <luite> ghcjs as a project is quite active :)
03:40:37 <HugoDaniel> cool :)
03:41:03 <HugoDaniel> i wonder if i could use it to do the code that runs inside webworkers
03:41:05 <luite> cabal support should be done soon
03:41:13 <HugoDaniel> i hate using JS for something that should be "pure"
03:41:47 <luite> atm you can only run IO actions, is that a problem for you?
03:41:52 <HugoDaniel> "3.5GB RAM (JavaScript linker is memory hungry)" !!
03:41:57 <luite> HugoDaniel: that's outdated
03:42:01 <luite> the new linker is better
03:42:35 <luite> but doesn't have all features yet (no split output)
03:43:49 <luite> (that said, there still are some horrible packages (i'm looking at you haskell-src-exts) that make the compiler use a few gigs of memory, but native ghc also uses well over a gigabyte there)
03:43:54 <amatsu> I'm trying to implement mergesort in Haskell, I came up with the version at the bottom of this paste but I'm not sure if it's a real merge sort..
03:43:55 <amatsu> http://hpaste.org/85981
03:44:47 <luite> HugoDaniel: what kind of haskell would you want to run in a web worker?
03:44:53 <HugoDaniel> luite: and the final code when its run on the browser fills up a lot of memory ?
03:45:44 <luite> HugoDaniel: well the javascript files for haskell-src-exts are huge, if you somehow make a program that uses all of it (which means using all specializations, instances etc) you get rather large programs :)
03:46:07 <tdammers> amatsu: merge' looks OK, but I think split' should be done differently
03:46:13 <HugoDaniel> luite: no big deal yet, im doing a simple app to share sounds and video, but the decoding is bad at the moment, i was wondering if i could use haskell (or C) to do the decoding, and memory handling of the possible chunks of data to keep ready for action
03:46:42 <HugoDaniel> i was using the omflabs decoders with some changes i made to have them work inside a webworker
03:46:42 <luite> HugoDaniel: oh using haskell would probably be too slow
03:47:03 <tdammers> typically, you'd pick a pivot, split your list in two halves, mergesort each half and then merge the sorted halves
03:47:18 <luite> HugoDaniel: perhaps you can hand-optimize some cabac, idct and color space conversion code in javascript call it from haskell with the ffi
03:47:29 <tdammers> and the base case is where you have a list of one item, which you don't need to split and merge
03:48:03 <luite> HugoDaniel: haskell ghcjs is really a lot slower than native
03:48:11 <luite> tricks like pointer tagging don't work
03:48:36 <HugoDaniel> ok
03:48:45 <HugoDaniel> whats a good use case for ghcjs then ?
03:48:58 <luite> writing user interfaces in haskell :)
03:49:05 <amatsu> tdammers: I know that the mergesort that comes with Haskell works differently, but it didn't seem very efficient to just split and re-join (hence the new mergesort at the bottom)
03:49:33 <HugoDaniel> oh ok
03:49:46 <tdammers> amatsu: what do you mean, not very efficient?
03:50:29 <tdammers> your split' function splits the input list into a list of one-element lists
03:50:49 <luite> HugoDaniel: better performance is a goal, but the js environment just makes it a lot harder. and compiled haskell code doesn't look like normal C or C++ llvm code
03:51:03 <tdammers> so if I'm not mistaken, you have implemented insert sort, not merge sort
03:51:11 <luite> HugoDaniel: more immediate goals are code size reduction and usability
03:51:30 <tdammers> because one of the lists that the merge function processes is always a one-element list
03:51:37 <HugoDaniel> i would happily trade performance for stability in the decoders, because i still have a lot of errors from the mp3 decoder, and the flac decoder doesn't even work at all
03:51:39 <tdammers> so the merge is really an insert
03:52:03 <luite> HugoDaniel: hm, that does sound like a good use case for llvm/emscripten
03:52:32 <luite> ghcjs Addr# primitive should work fine for pointing to emscripten heaps
03:52:34 <amatsu> tdammers: looks a bit like that.. will take another look at mergesort.
03:53:22 * hackagebot lazy-io 0.1.0 - Lazy IO  http://hackage.haskell.org/package/lazy-io-0.1.0 (JakubWaszczuk)
03:53:25 <tdammers> (mergesort is in fact more efficient than insertion sort except for almost-sorted lists and very small lists)
03:54:04 <__xc> > 'h':'a':"skell"
03:54:06 <lambdabot>   "haskell"
03:54:33 <__xc> this is far easier than erlang's [e,r|"lang"]"
03:55:01 <__xc> hmm, for my mind at least
03:55:26 <__xc> : is right proritized ?
03:55:39 <luite> HugoDaniel: http://hdiff.luite.com/gloss/styrene/
03:55:46 <__xc>  > 'h':('a':"skell")
03:55:58 <__xc> > 'h':('a':"skell")
03:56:00 <lambdabot>   "haskell"
03:56:23 <__xc> in erlang then it's implicitely left
03:56:27 <merijn> :i (:)
03:56:43 <merijn> __xc: It's infixr 5
03:57:09 <hpaste> tdammers pasted “mergesort” at http://hpaste.org/85985
03:57:47 <tdammers> here's my naive implementation
03:58:06 <__xc> offtopic, and other thing I don't like aout erlang is Itms = lists:map(fun erlang:binary_to_integer/1, Items),
03:58:17 <HugoDaniel> luite: this is done with ghcjs ?
03:58:48 <luite> HugoDaniel: yeah it's rather slow though, mainly because of one major missing optimization of stack frames
03:59:03 <luite> HugoDaniel: it's one of the samples that come with the gloss library, compiled with ghcjs
03:59:37 <HugoDaniel> very good
04:00:12 <luite> better stack frames should be done before first release though
04:03:22 * hackagebot sgd 0.3.2 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.3.2 (JakubWaszczuk)
04:08:21 <killy9999> does GHC havecan I force GHC to inline a function from prelude?
04:12:35 <killy9999> I mean some sort of keeness that I could use to force to GHC to inline call to filter
04:14:57 <hpc> killy9999: i don't think it havecans that feature :P
04:16:25 <hpc> if profiling shows that a dereferenced call to filter is your performance bottleneck, you are having a really awesome problem
04:21:17 <killy9999> hpc: I'm comparing performance of list comprehensions and same experssions written using a desugared form (maps, filters)
04:21:32 <killy9999> and it turns out that list comprehensions are faster
04:22:02 <killy9999> my guess is that this happens because call to filter isn't inlined in the desugared version, whereas everything in list comprehensions is fully inlined
04:22:10 <jermey> hey i am reading in a line like this
04:22:11 <jermey> inpStr <- getLine
04:22:30 <Botje> killy9999: i think your code is subtly different
04:22:34 <jermey> i want to covert the string to to upper case using toUpper
04:22:50 <jermey> this is where i am stuck
04:22:54 <hpc> killy9999: there's some ghc option to have it emit only desugared code
04:23:01 <hpc> you might try that
04:23:04 <Botje> jermey: you can do let inp' = map toUpper inpStr
04:23:09 <killy9999> hpc: OK, I'll try
04:23:13 <supki> mm_freak: what's the point of Time parameter for mk* functions? It stays around 8*10^-2 for all wire invocations so I guess I'm doing something wrong?
04:23:21 <killy9999> still it would be nice if I could adjust inlining threshold
04:23:22 <Botje> jermey: or you can use liftM/fmap
04:23:37 <killy9999> Botje: in theory it shouldn't ;)
04:23:42 <supki> mm_freak: (I assume it should increase or something?)
04:24:15 <hpaste> gishuel pasted “n-th elem of list” at http://hpaste.org/85986
04:25:34 <supki> > tails "ABCD"
04:25:35 <lambdabot>   ["ABCD","BCD","CD","D",""]
04:25:56 <supki> hmm
04:29:05 <jermey> Botje: thanks inp's worked. Two questions whats inp'? and secondly what is map doing here
04:29:23 <supki> > map (\x -> "ABCD" ^.. ifolded . Lens.indices (\i -> (i + 1) `mod` x == 0)) [1,2,3,4]
04:29:23 <amosr> @hoogle (c -> d) -> (a -> b -> c) -> (a -> b -> d)
04:29:23 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
04:29:24 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
04:29:24 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:29:25 <lambdabot>   ["ABCD","BD","C","D"]
04:30:35 <amosr> @pl (\f g a b -> f (g a b))
04:30:36 <lambdabot> (.) . (.)
04:30:39 <amosr> aha
04:32:24 <donri> > tails "echo"
04:32:26 <lambdabot>   ["echo","cho","ho","o",""]
04:42:17 <supki> mm_freak: oh, I'm an idiot, that's delta
04:46:16 <jermey> yo i m trying to read a text file with a number on each line (then add all the numbers and get a total sum)
04:46:38 <jermey> how can i add the totals
04:46:49 <jermey> because readFile gives as strings not ints
04:47:20 <luite> > read "123" :: Int
04:47:22 <lambdabot>   123
04:47:46 <luite> jermey: that would be the simple, and risky method, since you get an exception if it doesn't read
04:48:04 <jermey> the numbers are in a text file though?
04:48:15 <mauke> so use readFile
04:48:29 <hpaste> jermey pasted “jermey” at http://hpaste.org/85987
04:48:39 <jermey> http://hpaste.org/85987
04:48:45 <luite> jermey: see readMaybe (for recent GHC) and parsers like parsec for safer methods
04:49:16 <mauke> print (sum (map read (lines inpStr)))
04:49:55 <jermey> i am trying to get the next part
04:51:30 <beaky> hello
04:52:06 <beaky> is there a special name for things that have a type a, a function that goes a -> a, and an identity a?
04:52:12 <jermey> mauke: i added that but i got this error "Couldn't match expected type `IO t0'"
04:52:56 <latro`a> a monoid of endomorphisms, beaky?
04:53:02 <beaky> ah
04:53:29 <beaky> I thought monoids' functions were a -> a -> a
04:53:30 <latro`a> wait no, then the identity would be id
04:53:43 <latro`a> the "mappend" is (.)-
04:53:44 <mauke> jermey: and what's the real error message?
04:53:52 <latro`a> but that doesn't get you your desired identity *a*
04:54:09 <beaky> ah
04:54:23 <beaky> what is the easiest monoid in the universe?
04:54:30 <beaky> i.e. the easiest such 'a'?
04:54:41 <latro`a> there's a trivial monoid with just an identity
04:54:45 <beaky> ah
04:55:09 <beaky> are there monoids which are not easy?
04:55:31 <latro`a> well, given that any class of functions is a monoid, yeah...
04:55:46 <latro`a> (any non-silly class of functions, i.e. you have to insist on id being in there)
04:56:01 <hpaste> jermey revised “jermey”: “jermey” at http://hpaste.org/85987
04:56:18 <jermey> mauke: see revised paste ^
04:56:52 <mauke> jermey: readFile takes an argument
04:58:13 <jermey> hmm is there anything else similar that doesnt? We are meant to compile it liek this ./ExerciseFour numbers.txt  (but the .txt file can be any name shouldnt matter)
04:58:23 <mauke> what
04:58:34 <jermey> as in read in a text file
04:58:39 <jermey> but the name can be variable
04:58:48 <mauke> your imagined solution is at odds with the problem you're describing
04:59:08 <mauke> your exercise requires you to take a file name and read from it
04:59:20 <mauke> how will something that takes no argument know what file to read?
04:59:32 <_mr> jermey: Look at getArgs from System.Environment
05:00:02 <jermey> yes, i am wondering is there any other library function i can use that works similar to readFile?
05:00:14 <mauke> why are you wondering that?
05:00:18 <jermey> thanks _mr looking into it now
05:00:19 <mauke> how will something that takes no argument know what file to read?
05:00:32 <_mr> jermey: getArgs gives you a way to get the filename
05:00:40 <_mr> jermey: then you open the file with what you have already
05:00:46 <hpaste> rifki pasted “node addition” at http://hpaste.org/85989
05:01:05 <rifki> Hi, could you have a look my hpaste and help me please?
05:01:28 <mauke> rifki: why are you using hugs?
05:02:20 <ab9rf> :t (++) -- rifki
05:02:22 <lambdabot> Monoid m => m -> m -> m
05:02:23 <rifki> maute : I'm supposed to do
05:02:27 <mauke> rifki: why?
05:02:32 <mauke> ab9rf: gee.
05:02:43 <ab9rf> that was less useful than i hoped :)
05:02:44 <Iceland_jack> rifki: If you can use GHC instead, do so
05:02:55 <merijn> mauke: Some instructors still seem to insist on hugs :\
05:03:01 <jermey> _mr: i have found getArgs but I am wondering does it return the file name?
05:03:12 <jermey> as in ./exercise4 numbers.txt
05:03:17 <_mr> jermey: it returns a list of the arguments
05:03:20 <jermey> will get getArgs return numbers.txt?
05:03:47 <shirt> what's the best way to write something like this? list = []; if(A) { list.append("A"); } if(B) { list.append("B"); } if(C) { list.append("C"); }
05:03:57 <jermey> so if i say getArgs
05:04:03 <rifki> ab9rf : does it mean I need to write another (++)?
05:04:06 <_mr> Suppose you call it as ./exercise a b c, then getArgs gives you ["a", "b", "c"] (In IO)
05:04:17 <ab9rf> rifki: it means you need to append a _list_ to the list, not an _element_
05:04:22 <jermey> then next line inpStr <- readFile getArgs[1]
05:04:28 <jermey> it will read numbers.txt?
05:04:33 <mauke> jermey: no
05:04:34 <Cale> shirt: maybe something like ["A" | A] ++ ["B" | B] ++ ["C" | C] ?
05:04:48 <mauke> jermey: are you just making up syntax now?
05:04:50 <ab9rf> ooh, nice one, cale
05:05:12 <Cale> > ["A" | 2^2 <= 4] ++ ["B" | 1 < 0] ++ ["C" | 'e' `elem` "hello"]
05:05:15 <lambdabot>   ["A","C"]
05:05:27 <jermey> i am not trying to just figuring out (and C and java background clearly hasnt helped me)
05:05:42 <rifki> ab9rf : can you tell me how I do that in this case ?
05:05:47 <mauke> jermey: readFile getArgs [1] calls readFile with two arguments, getArgs and [1]
05:07:15 <rifki> ab9rf : I got it, thanks
05:07:19 <ab9rf> rifki: yay
05:07:29 <jermey> (fucking C) so getArgs has gotten be a list of command line arguments. I want the 2nd one (or 1st one if counting from 0)  how will i get that fileName to give it to readFile so it can do its stuff?
05:07:39 <mauke> getArgs is not a list
05:07:49 <mauke> getArgs is an action that results in a list when executed
05:07:49 <ab9rf> jermey: getArgs is IO [String], not [String]
05:07:59 <Iceland_jack> jermey: You should read up on how IO works in Haskell
05:08:29 <_mr> jermey: getArgs and readFile are the necessary functions. The exercise now is to put them together in a meaningful way. Wich is largely syntax
05:08:42 <mauke> readFile is a function, getArgs isn't
05:09:10 <jermey> yeap i ve gotten that part ^
05:09:19 <jermey> i am trying to figure out putting them together
05:09:32 <jermey> hence my stupid readFile getArgs[1] comment
05:09:53 <mauke> do { args <- getArgs; ... readFile (args !! 0) ... }
05:10:04 <mauke> > ["foo", "bar", "baz"] !! 1
05:10:06 <lambdabot>   "bar"
05:10:40 <jermey> ah got ya mauke thank you so much!
05:10:49 <jermey> damm the more i learn haskell the neater it gets
05:10:50 <Cale> Usually you'd at least use case instead of !! to be able to correctly handle the cases where you don't have enough args, but for a quick program, !! will be fine.
05:11:02 <mauke> usually you'd just read from stdin
05:11:32 <Cale> Another option which will fail if you don't have enough args is to just pattern match on the left of <-
05:12:02 <Cale> do (arg1 : arg2 : args) <- getArgs; ... readFile arg2 ...
05:12:05 <Chousuke> jermey: I bet once you understand what IO actually is you'll think it's even neater.
05:12:06 <mauke> [filename] <- getArgs;
05:13:07 <jermey> Chousuke: i am reading up on IO as we speak
05:14:44 <Chousuke> it took me a while to see how monads make IO work and then a bit longer to understand the whole "actions as values" idea.
05:15:01 <Cale> Well, IO is a monad, I'm not sure I'd say monads make IO work :)
05:15:20 <Chousuke> Cale: IO as in the act of doing IO
05:15:35 <Cale> ah
05:15:43 <mysticc> I don't remember but there was a github package not yet available on hackage which performed some kind of haskell source analysis by which I can find out which function the name refers to (in case of same named function in different scopes)
05:15:51 <mauke> monads don't make I/O work
05:16:13 <Cale> As in how various monads which will allow you to do I/O actually themselves function
05:16:29 <luite> mysticc: part of haskell-suite?
05:17:10 <Cale> Though I think focusing on understainding the actions as values aspect is the quickest way to get going.
05:17:10 <luite> mysticc: https://github.com/feuerbach/haskell-names
05:17:28 <hpaste> jermey revised “jermey”: “jermey” at http://hpaste.org/85987
05:17:51 <jermey> i am googling Prelude.(!!): index too large but many if someone kindly has time might be able to explain it more
05:18:11 <magicman> > do { let x = 5 ; return x }
05:18:12 <ab9rf> jermey: use hoogle instead.  google sucks for searching punctuation
05:18:13 <lambdabot>   <hint>:1:27: parse error on input `}'
05:18:20 <Chousuke> Cale: That's what took me a while to see. at first I thought that bind was just doing some magic to execute one action before another.
05:18:21 <Cale> jermey: Two things: 1) configure your text editor to replace tabs with spaces, and 2) you need to supply two commandline arguments
05:18:28 * hackagebot crf-chain1-constrained 0.2.1 - First-order, constrained, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-constrained-0.2.1 (JakubWaszczuk)
05:18:30 * hackagebot lgtk 0.2 - lens-based GUI with Gtk backend  http://hackage.haskell.org/package/lgtk-0.2 (PeterDivianszky)
05:18:39 <magicman> > do { let x = 5 ; return x } :: Maybe Int
05:18:40 <lambdabot>   <hint>:1:27: parse error on input `}'
05:18:51 <donri> jermey: you probably meant !! 0, indices are zero-based
05:18:55 <Cale> > do { let { x = 5 }; return x } :: Maybe Int
05:18:56 <magicman> ... why is that a parse error? Did I get something wrong?
05:18:56 <lambdabot>   Just 5
05:19:00 <magicman> Ahhh.
05:19:09 <magicman> Oh, right, because it tries to find 'in'.
05:19:11 <jermey> oh donri your right
05:19:13 <jermey> thanks
05:19:14 <magicman> Cheers :)
05:19:25 <Cale> magicman: Yeah, if you're using layout, you can get away without it
05:19:30 <mauke> magicman: no, because there's a '=' missing after 'return x'
05:19:45 <magicman> <_>
05:20:00 <jermey> (i stupid thought ,/exercise was an argument)
05:20:15 <donri> jermey: note that you could pattern match instead: [fileName] <- getArgs -- then if you provide a different number of arguments you get a better error
05:20:39 <ab9rf> at least a different one
05:21:28 <donri> better because it points to the source line, though not really a big win in this case i guess
05:21:56 <jermey> thanks donri, probably doesnt matter in this but will in a few weeks
05:23:28 * hackagebot crf-chain2-tiers 0.1.1 - Second-order, tiered, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-tiers-0.1.1 (JakubWaszczuk)
05:23:30 * hackagebot concraft 0.7.1 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.7.1 (JakubWaszczuk)
05:25:14 <donri> jermey: could also try the simpleargs package
05:26:01 <mysticc> luite: Is there more information about this package- haskell-names?
05:26:12 <mysticc> luite: Readme doesn't help much
05:29:26 <ab9rf> readmes are supposed to help?
05:29:57 <Cale> mysticc: I see a package called just 'names', is that the one you're referring to?
05:30:10 <no-n[12]> tried reading more lyah tonight but my brain doesn't want to make connections :(
05:30:17 <no-n[12]> even on caffeine
05:30:56 <Cale> no-n[12]: Anything in particular that you're having trouble understanding?
05:31:06 <luite> mysticc: i only know that it's part of haskell-suite, which is supposed to provide a standalone haskell typechecker, and part of it was done as a gsoc project last year
05:31:08 <no-n[12]> not yet
05:31:16 <no-n[12]> I guess I just can't be bothered atm
05:31:25 <luite> mysticc: if you search for the haskell-suite gsoc blog posts you can probably find out a bit more
05:32:27 <Cale> no-n[12]: Well, feel free to ask any questions which come to mind
05:32:38 <no-n[12]> thanks, will do :)
05:36:39 <hamid_> this is really itching my mind. is Int type really declared like this "    data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647  " ? cause if it's not then we can't use numbers for pattern matching and etc. right?
05:37:27 <hamid_> hmm and also Char is the same i guess?
05:37:28 <monoidal> hamid_: Pattern-matching on integer literals is a special case
05:37:39 <monoidal> hamid_: also on characters. it's built-it
05:37:59 <hamid_> monoidal, hmm sounds a reasonable decision :D
05:38:05 <arkeet> hamid_: no, they're defined by magic.
05:38:37 <monoidal> hamid_: in fact, if you match on an integer literal "case ... of 5 -> ...", it is converted to case ... of x | x == 5 -> ..."
05:38:43 <arkeet> it's really data Int = I# Int#
05:38:50 <arkeet> where Int# is an "unboxed Int" and is magic.
05:39:11 <arkeet> that is also true.
05:39:15 <monoidal> hamid_: you can match on any type that defines an instance of Num and Eq (fromInteger and (==) methods)
05:39:23 <arkeet> :t let f 5 = () in f
05:39:25 <lambdabot> (Eq a, Num a) => a -> ()
05:39:52 <hamid_> ok thanks. got it. but I don't get those # magics :P
05:40:04 <arkeet> well # is just a character.
05:40:11 <luite> hamid_: the # itself does nothing, they're just used to indicate special types and constructors
05:40:15 <arkeet> but they are primitives provided by GHC.
05:40:29 <arkeet> by they I mean Int#
05:40:31 <monoidal> hamid_: they're low-level primitives, perhaps you might revisit them later
05:40:32 <arkeet> and friends.
05:40:36 <luite> Int# is a primitive, I# isn't
05:40:45 <luite> that's just a constructor with a wacky name
05:41:28 <hamid_> hmm that's getting weird. but thank you guys. that was hard to accept that ;)
05:41:41 <mauke> @src Integer
05:41:42 <lambdabot> data Integer = S# Int#
05:41:42 <lambdabot>              | J# Int# ByteArray#
05:41:57 <luite> hamid_: don't worry, you don't need them very often :)
05:42:37 <luite> mauke: i wish that constructor wasn't exported :p
05:42:53 <hamid_> luite, but what about those _often_ cases? are they just for performance issues and such ?
05:43:25 <hamid_> and ofcourse cases like the ones I was curious about :P
05:43:29 <luite> hamid_: yeah and weird conversions
05:43:31 <donri> hamid_: the compiler will often do that translation for you, at least with some hand holding
05:44:19 <hamid_> hmm fair enough.
05:50:48 <lpsmith> I'm curious, are there plans to make use of Haswell's transactional extensions in STM?
05:52:05 <klrr> where do i start if i wanna learn FRP with yampa?
05:57:36 <lunarjar> I want to use vim for haskell, everytime I want to run my file I have to go into ghci :l myfile.hs
05:57:40 <lunarjar> how can I automate that?
05:58:15 <typoclass> lunarjar: one thing you can do is use ":l something.hs" and then ":r" for reload
05:58:37 <lunarjar> typoclass, thanks
05:58:46 <lunarjar> but is there something like vimux for haskell?
06:03:29 * hackagebot raven-haskell-scotty 0.1.0.0 - Http interface for Scotty web server.  http://hackage.haskell.org/package/raven-haskell-scotty-0.1.0.0 (AlexanderBondarenko)
06:04:57 <mysticc> Cale: No I am referring to haskell-names https://github.com/feuerbach/haskell-names
06:26:29 <hamid_> > $ 1
06:26:30 <lambdabot>   <hint>:1:1: parse error on input `$'
06:27:19 <hamid_> > 1+($1)
06:27:21 <lambdabot>   *Exception: show: No overloading for function
06:28:40 <mjrosenb> > (1+)$1
06:28:42 <lambdabot>   2
06:29:10 <lpsmith> erg, I am wishing that I could write  case (x :: Int) of { const_exp1 -> foo;  const_exp2 -> bar;  _ -> baz }
06:29:29 <hamid_> Q: Are exceptions builtin types or sth like that?
06:29:50 <lpsmith> I suppose this might be doable with TH?
06:30:08 <hamid_> > (+1)$1
06:30:10 <lambdabot>   2
06:30:17 <hamid_> hmm
06:30:28 <typoclass> lpsmith: you can?
06:30:29 <typoclass> > case 17 of 37 -> "yo" ; 17 -> "no"
06:30:31 <lambdabot>   "no"
06:30:44 <lpsmith> typoclass, no, you can't
06:31:03 <lpsmith> I don't want to write a literal, just a constant expression
06:31:08 <mjrosenb> lpsmith: you can always use guards :(
06:31:43 <lpsmith> mjrosenb, they compile to different code... unless GHC has some magic guard-optimization technology for this particular case I don't know of.
06:33:00 <lpsmith> case expressions, on the other hand, if you write down literals are optimized quite well
06:33:56 <mjrosenb> lpsmith: I didn't say it was a *good* idea.
06:34:04 <lpsmith> mjrosenb, =)
06:34:24 <mjrosenb> also, that use case of guards would be basically equivalent to a bunch of if-statements.
06:35:09 <mjrosenb> possibly with a nicer per-case syntax, and a worse syntax overall
06:35:13 <merijn> hamid_: You can define your own exceptions, if that's what you mean
06:35:24 <typoclass> mjrosenb: you're saying that guards are "not a good idea" because they "compile to different code than case-of"?
06:35:32 <lpsmith> I've found myself using guards less and less over time
06:35:53 <lpsmith> All in all I think I tend to prefer the if-then-else syntax in most (but not all) cases
06:36:31 <mjrosenb> typoclass: no, lpsmith is saying that.
06:36:52 <mjrosenb> lpsmith: but you can't get all of the functionality of guards with if-else.
06:38:06 <lpsmith> well,  assuming you aren't using Pattern Guards, with can be quite handy,  or list comprehension guards,  if then else can do everything guards can do, and more.
06:38:41 <hamid_> merijn, I don't get them actually. I think messing with purity is wrong so they should have happen in a Monad thing or so.
06:39:20 <hamid_> merijn, nvm i gotta read about them myself. :/
06:40:13 <merijn> hamid_: There's two ways to deal with errors, in pure code people are most likely to use things like Maybe and Either to represent and deal with errors
06:40:25 <typoclass> > lookup 37 [(38-1, "yo"), (42, "no")] -- how about this
06:40:26 <lambdabot>   Just "yo"
06:40:54 <merijn> hamid_: Haskell also supports "real" exceptions, as in "throw foo", but those exceptions can only be caught in IO
06:41:06 <merijn> :t Control.Exception.catch
06:41:07 <lambdabot> GHC.Exception.Exception e => IO a -> (e -> IO a) -> IO a
06:41:42 <merijn> hamid_: For example "catch" tries to run the first IO action, but if that raises exception e it will run the exception handling function instead
06:42:20 <hamid_> merijn, so if i don't cover all possiblities in a pattern matching... i can catch the error in IO with that?
06:42:43 <merijn> > case 17 of 11 -> "yay!"
06:42:44 <lambdabot>   "*Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
06:43:08 <merijn> hamid_: Yeah, that should work
06:43:36 <supki> > case 17 of ~11 -> "yay!"
06:43:38 <lambdabot>   "yay!"
06:43:51 <hamid_> merijn, got it. thanks. gotta get involved with Monads  more :P
06:44:07 <lpsmith> hmm, bytestring-trie looks useful for something I've been meaning to do
06:44:11 <typoclass> hamid_: have you looked at using "_ -> ..."? it will match anything. waiting for that exception and catching it is not the typical haskell way
06:44:50 <mjrosenb> lpsmith: "pattern guards"?
06:45:09 <lpsmith> mjrosenb, it's a GHC extension
06:45:14 <typoclass> mjrosenb: see here http://www.haskell.org/haskellwiki/Pattern_guard
06:45:18 <monoidal> hamid_: while you can catch non-exhaustive pattern matching this way, failing on non-exhaustive patterns is generally considered a programming error
06:45:20 <hamid_> typoclass, yeah the wild card. that was just an example to understand. Can we catch all exception or so.
06:46:22 <monoidal> > catch (evaluate (case 0 of 1 -> False)) (\(_ :: SomeException) -> return True)
06:46:24 <lambdabot>   Not in scope: `evaluate'
06:46:24 <lambdabot>  Perhaps you meant `evalState' (imported from Cont...
06:46:52 <monoidal> > catch (Control.Exception.evaluate (case 0 of 1 -> False)) (\(_ :: SomeException) -> return True)
06:46:54 <lambdabot>   Not in scope: `Control.Exception.evaluate'Not in scope: type constructor or...
06:47:25 <monoidal> hamid_: ^ you can do it that way, for some reason I can't access Control.Exception on lambdabot
06:47:38 <monoidal> hamid_: still, it's extremely unidiomatic to do so
06:47:45 <mjrosenb> lpsmith: but how about something like "case foo of { (h:t) | isOdd h -> ... ; (h1:h2:t) | h1 == h2 -> ...; l -> ... }" ?
06:48:22 <hamid_> monoidal, hmm well then ok.
06:48:37 <lpsmith> mjrosenb, true
06:48:37 <mm_freak> supki: there you go =)
06:49:14 <lpsmith> mjrosenb, I kinda forgot about that.  That's about the only time I use guards anymore
06:49:54 <mjrosenb> lpsmith: I tend to aviod "case pattern -> if ..."
06:50:27 <mjrosenb> at least when the conditional is based on a variable that is bound in the pattern.
06:51:36 <lpsmith> mjrosenb, to each their own =)
06:52:04 <flo1> Hey, I'm using Control.Monad.State and have a function like a = do a <- initEnv; b <- doSomething; c <- dropEnv; return (a++b++c) — but it is evaluated in wrong order (initEnv,dropEnv,doSomehting) so it fails because doSomething has no correct state — what I'm doing wrong?
06:52:11 <lpsmith> But personally unless a guard is going to allow another guard an opportunity to match,  I tend to avoid them
06:52:11 <arkeet> if is evil.
06:52:43 <monoidal> flo1: hard to tell. hpaste the code?
06:53:47 <monoidal> flo1: initEnv,dropEnv,doSomehting is the expected order here
06:53:59 <monoidal> flo1: ah, sorry
06:54:24 <hpaste> flo1 pasted “evaluation order of state monad in toErlang” at http://hpaste.org/86001
06:55:46 <flo1> it shows "init" then "drop" and then tries to evaluate the preprocessLabels stuff
06:56:13 <lpsmith> err,  unless a guard is going to let another *pattern* to match, I mean
06:57:35 <arkeet> flo1: the recursive call to toErlang is doing initEnv again. is that what you want?
06:57:43 <arkeet> unless it isn't.
06:59:06 <flo1> arkeet: yes could be, that toErlang is called initEnv again
06:59:50 <flo1> arkeet: initenv should prepare an environment and then     stats' <- mapM toErlang $ preprocessLabels stats
06:59:50 <flo1> should use this env (and maybe add another env on top on it) and then dropEnv should drop den Env again
07:00:43 <arkeet> flo1: then you better move the initEnv outside your recursive thing.
07:01:37 <klrr> is it worth learning about FRP or is the IO monad enough to write most applications?
07:01:53 <flo1> no. if "preproccessLabels stats" is conatining a LT.Block then another initEnv should be generated - and dropped
07:02:55 <flo1> initEnv
07:02:55 <flo1> - so something
07:02:55 <flo1> - initEnv
07:02:55 <flo1> -- do something other
07:03:05 <flo1> - dropEnv
07:03:05 <flo1> dropEnv
07:06:16 <boyxboy77> http://xhotspanishgirls.blogspot.com/2013/04/hot-galleries.html
07:06:28 --- mode: ChanServ set +o johnw
07:06:31 --- mode: ChanServ set +o johnw
07:06:36 --- mode: johnw set -o johnw
07:09:57 <TLM> test
07:13:44 <shirt> Cale: thanks
07:15:39 <fizbin> Hey, can someone here think of a Functor that isn't easily also an Applicative? So far all I have is (Foo, a) and Const Foo where "Foo" is something that isn't easily a Monoid, like a binary tree type.
07:16:03 <monoidal> klrr: For most applications, IO is enough. It's nice to know the idea of frp, but its support in Haskell is IMO not mature yet
07:16:27 <flo1> I tried a second method but it doesn't work either: http://hpaste.org/86001
07:16:43 <monoidal> fizbin: (a,) is not applicative (unless a is a monoid)
07:17:18 <mauke> fizbin: Map k
07:17:34 <fizbin> Right, I had that. That's what I meant by (Foo, a) - I should have written it as (,) Foo
07:17:44 <fizbin> Oh, Map… huh.
07:18:28 <monoidal> fizbin: "data F a" is a functor, but not applicative
07:18:29 <fizbin> Actually, I guess for that measure most containers of a vaguely complicated type, like binary trees or even rose trees are Functors that aren't Applicative.
07:18:31 * hackagebot herbalizer 0.4.5 - HAML to ERB translator  http://hackage.haskell.org/package/herbalizer-0.4.5 (DanielChoi)
07:19:21 <fizbin> @hoogle data
07:19:21 <lambdabot> Data.Data class Typeable a => Data a
07:19:21 <lambdabot> Data.Data module Data.Data
07:19:21 <lambdabot> Data.Data dataCast1 :: (Data a, Typeable1 t) => (forall d. Data d => c (t d)) -> Maybe (c a)
07:19:35 <monoidal> fizbin: depending on exact definition, binary trees can be monads even
07:19:46 <monoidal> fizbin: (free monads exactly)
07:20:00 <monoidal> fizbin: also there's ziplist-like thing for trees
07:20:14 <fizbin> monoidal: Monoids maybe. Monads?
07:20:34 <monoidal> fizbin: I mean data Tree a = Leaf a | Node (Tree a) (Tree a) is a monad
07:21:18 <fizbin> Really? What's join on that type?
07:21:34 <monoidal> fizbin: imagine Tree (Tree a). This is a tree where leaves are trees of a's. So you can "join" it to get a tree of a's.
07:22:01 <monoidal> fizbin: join (Leaf x) = x; join (Node a b) = Node (join a) (join b) to be precise
07:22:24 <monoidal> fizbin: or "flattening" might be more illustrative
07:22:30 <arkeet> Tree is the "free magma" monad.
07:22:30 <fizbin> Oh, you only have values at the Leaves. Ok.
07:23:34 <monoidal> fizbin: data Tree2 a = Leaf a | Node (Tree2 a) a (Tree2 a) can be made an applicative like ziplists
07:24:16 <fizbin> I suppose you could use ZipList-like things there.
07:25:10 <monoidal> fizbin: I don't see any obvious way to do an applicative/monad for data Tree3 a = Leaf a | Node (Tree3 a) (Tree3 a) | Node2 (Tree a) a (Tree a)
07:25:56 <arkeet> can you write liftA2 (,)?
07:25:58 <arkeet> :t liftA2 (,)
07:25:59 <lambdabot> Applicative f => f a -> f b -> f (a, b)
07:26:12 <arkeet> that looks like an ugly type anyway.
07:26:14 <fizbin> Couldn't you do a ZipList-like approach there too?
07:26:26 <fizbin> Though wait. Maybe not.
07:26:29 <arkeet> what would zip be?>
07:26:49 <arkeet> Tree2 looks weird to begin with.
07:27:01 <arkeet> what about Tree a = Tip | Branch (Tree a) a (Tree a)
07:27:08 <monoidal> yes, that's more natural
07:27:36 <monoidal> and also applicative
07:28:19 <arkeet> sure, you can zip them.
07:28:32 * hackagebot herbalizer 0.4.6 - HAML to ERB translator  http://hackage.haskell.org/package/herbalizer-0.4.6 (DanielChoi)
07:28:36 <fizbin> :t \x -> (fmap (,)) <*> x
07:28:37 <lambdabot> ((a -> a1) -> a) -> (a -> a1) -> b -> (a1, b)
07:29:22 <fizbin> :t \x y -> (liftA2 (,)) x y
07:29:23 <lambdabot> Applicative f => f a -> f b -> f (a, b)
07:29:58 <fizbin> :t \x -> fmap (,) x
07:29:59 <lambdabot> Functor f => f a -> f (b -> (a, b))
07:30:27 <fizbin> :t \x y -> fmap (,) x <*> y
07:30:29 <lambdabot> Applicative f => f a1 -> f a -> f (a1, a)
07:30:37 <arkeet> :t \x y -> (,) <$> x <*> y
07:30:39 <lambdabot> Applicative f => f a1 -> f a -> f (a1, a)
07:30:41 <arkeet> :t liftA2 (,)
07:30:43 <lambdabot> Applicative f => f a -> f b -> f (a, b)
07:31:12 <arkeet> :t \f x -> fmap (uncurry ($)) (liftA2 (,) f x)
07:31:14 <lambdabot> Applicative f => f (b1 -> b) -> f b1 -> f b
07:31:47 <fizbin> Isn't that just (flip (<*>)) ?
07:32:05 <arkeet> no, it is (<*>)
07:32:17 <fizbin> Oh, right. ok.
07:32:23 <arkeet> exercise: prove it.
07:38:32 * hackagebot herbalizer 0.4.7 - HAML to ERB translator  http://hackage.haskell.org/package/herbalizer-0.4.7 (DanielChoi)
07:40:26 <fizbin> :t uncurry ($)
07:40:27 <lambdabot> (b -> c, b) -> c
07:44:08 <fizbin> I suspect it would make this proof easier if <*> were associative.
07:47:58 <edwardk> :t liftA2 (.)
07:47:59 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
07:48:03 <edwardk> fizbin: use that
07:48:18 <edwardk> :t pure id
07:48:19 <lambdabot> Applicative f => f (a -> a)
07:48:30 <edwardk> :t liftA2 (.) (pure id)
07:48:31 <lambdabot> Applicative f => f (a -> c) -> f (a -> c)
07:48:56 <edwardk> then you can use the associativity of liftA2 (.) and pure id as its unit and everything becomes easy ;)
07:49:45 <arbazk> Please check this error (Haddock documentation error) http://hpaste.org/86004
07:50:16 <fizbin> edwardk: Except I don't have (liftA2 (.)). I have (liftA2 (,))
07:51:29 <fizbin> :t \f x -> pure (uncurry ($)) <*> (pure (,) <*> f <*> x)
07:51:30 <geekosaur> arbazk, you're missing full haddocks for the base system
07:51:30 <lambdabot> Applicative f => f (b1 -> b) -> f b1 -> f b
07:52:22 <arbazk> geekosaur, I have installed ghc-doc. What more should i install?
07:53:21 <geekosaur> since I have no idea which ghc you installed from where onto where, I cannot answer that question
07:54:56 <arbazk> I used cabal to install ghc and haddock. Also, the program stline.hs uses Gloss, the image editing library
07:55:27 <beaky> hello
07:55:38 <arbazk> Ghc 7.4.1 and ghc-haddock 7.4.1
07:55:45 <beaky> is there a special name for a function that has type a -> b?
07:56:05 <geekosaur> ...cabal to install ghc? what?
07:56:52 <beaky> are typeclasses bad?
07:57:24 <geekosaur> only when used nappropriately
07:57:29 <geekosaur> *inappropriately
07:58:34 <beaky> what are the only appropriate uses of typeclasses? What are the most likely abuses of them?
07:58:42 <arbazk> Sorry, cabal to install Gloss. Ghc7.4.1
07:59:06 <monoidal> beaky: a,b type variables? in this case, only such functions are undefined, there's nothing sensible to say
07:59:52 <beaky> monoidal: ah :(
08:00:19 <monoidal> beaky: for specific a,b it might be appropiate to call it "conversion of a to b" or "casting"
08:00:28 <monoidal> beaky: assuming that's the intent
08:00:44 <beaky> I wonder if there was a formal stolen-from-category-theory name for them
08:01:15 <monoidal> beaky: you want polymorphic functions a -> b where a,b are anything? there won't be any name for this
08:01:27 <beaky> right
08:01:46 <merijn> monoidal: bottom :)
08:01:48 <beaky> yeah sorry meant ones which have specific types
08:01:53 <Rarrikins> You could call them bottom-producing :)
08:01:56 <beaky> lol
08:02:05 <Rarrikins> If you really need a name
08:02:25 <beaky> yes I must name my stuff, so when I identify patterns in my code I can make a monoid from them
08:02:35 <beaky> and then prove monoid laws
08:02:38 <arbazk> geekosaur, I used synaptics to install ghc7.4.1, ghc-haddock7.4.1.
08:02:55 <beaky> maybe someday I will discover my own category :D
08:03:04 <beaky> the beaky monoid
08:03:44 <beaky> (the same way the X monad was discovered for the famous window manager)
08:05:13 <simpson> I thought X was just restricted IO.
08:05:30 <no-n[12]> what is a category?
08:05:35 <geekosaur> not even restricted, just carries around some state
08:05:40 <beaky> a category is like a monoid
08:05:48 <Trollkastel> beaky: wat
08:05:54 <geekosaur> X monad wasn't discovered, it was created...
08:05:55 <DMcGill> @src Category
08:05:55 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:06:12 <DMcGill> @info Category
08:06:12 <lambdabot> Category
08:06:15 <Trollkastel> no-n[12]: A mathematical structure satisfying certain axioms, for more info, use Wikipedia.
08:06:28 <Chousuke> well that is some useful info :P
08:06:35 <DMcGill> can I get lambdabot to say the Category class info?
08:06:37 <no-n[12]> looks complicated :3
08:06:44 <Trollkastel> :t Control.Category.id
08:06:45 <lambdabot> Control.Category.Category cat => cat a a
08:06:52 <Trollkastel> :t (Control.Category..)
08:06:53 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
08:07:05 <DMcGill> that works I suppose
08:07:32 <Trollkastel> DMcGill: Pretty much the mathematical definition, minus the left/right identity and associativity laws, which you have to make sure you are respecting.
08:07:32 <DMcGill> if you think of categories as functions, that sort of works
08:07:48 <Trollkastel> wat
08:07:50 <Chousuke> no-n[12]: that's just a fancy way of saying an identity function and composition operator :p
08:07:56 <DMcGill> cat a a is kind of like (a -> a)
08:08:01 <DMcGill> since functions are categories
08:08:07 <DMcGill> of course, lots of other things are categories too
08:08:08 <paintcan> dd
08:09:30 <fizbin> Category Theory is difficult to study outside a formal setting because you spend the first several weeks of investigating it wondering wtf is actually *there*.
08:10:04 <scriptor> and wikipedia isn't the greatest of learning resources when you're starting out
08:10:09 <Chousuke> haskell has a whole bunch of abstractions that have weird sounding names and sound complicated and then they just turn out of be things like "has a composition operator" or "has a mapping operator"
08:10:51 <DMcGill> after all, type classes are very similar to interfaces in OO languages
08:11:16 <geekosaur> similar yet very different...
08:11:35 <DMcGill> a set of common methods to implement
08:11:53 <fizbin> At first getting into CT looks like you're studying Smurf Theory. All of Smurf Theory can be summed up in "Everything's a Smurf. Your cat? That's a smurf. The relationships between neighbors on your street? That's a smurf." See? Smurf theory is *totally general* in that it can describe anything. It's also (as I hope is obvious) totally useless.
08:11:55 <Trollkastel> DMcGill: Interfaces in OO only allow the first parameter (this, self, whatever) to be polymorphic.
08:11:57 <DMcGill> you can program to the interface's methods and not need to know which actual implementor you have
08:12:42 <beaky> Trollkastel: I think some OO languages do let you dispatch on multiple parameters too :D
08:12:53 <beaky> was it smalltalk or lisp that was the first to let you do that?
08:12:59 <beaky> I think lisp
08:13:00 <DMcGill> that's a question of polymorphism and types, not of interfaces themselves
08:13:06 <Trollkastel> beaky: CLOS?
08:13:20 <beaky> yeah that
08:13:27 <Trollkastel> DMcGill: Um, interfaces are the way ad-hoc polymorphism is implemented in OO languages...?
08:13:41 <beaky> I think haskell lets you do something like multiple dispatch
08:13:42 <Trollkastel> DMcGill: So it makes sense to compare their expressive power against that of type classes.
08:14:09 <Trollkastel> beaky: multi-parameter type classes
08:14:18 <beaky> ah right
08:14:55 <DMcGill> that makes sense
08:14:57 <beaky> something like Instance Mating Horse Horse where {- two horses mating -} and instance mating Horse Donkey where {- horse and donkey mating -}
08:15:00 <beaky> ?
08:16:08 <DMcGill> hmatrix does that with type families iirc
08:16:28 <DMcGill> Mult Vector Matrix, Mult Vector Vector etc
08:16:54 <beaky> yes who needs OOP when you have typeclasses? :D
08:17:04 <beaky> what is OOP anyway?
08:17:10 <DMcGill> comonads
08:17:12 <DMcGill> ;)
08:17:22 <beaky> oh what's a comonad?
08:17:30 * Trollkastel just checked his ~/.ghci, to his horror foound there was no :set -XMultiParamTypeClasses.
08:17:40 <DMcGill> see http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
08:18:05 <beaky> ah so multiple parameters are actually a language extension and non-standard haskell?
08:18:08 <Chousuke> I think the main problem is that if you were to implement eg. a Monad interface, then the interface could only deal with generic types. you would have to have something like Object bind(Object ma, Object mf(Object)) which isn't very useful
08:18:16 <beaky> (all of the cool haskell stuff are GHC extensions :()
08:18:49 <DMcGill> Chousuke: wouldn't generics do that?
08:18:56 <Trollkastel> beaky: Not really.
08:19:02 <Chousuke> DMcGill: Templates maybe
08:19:07 <beaky> ah
08:19:11 <Chousuke> java generics just become Objects
08:19:30 <DMcGill> Monad<B> bind (Monad<A> ma, Function<A,Monad<B>> mf)
08:19:59 <geekosaur> mptcs are still an extension because they really need something else to be actually usable (without having to specify types all over the place) and the "something else" is still an open question (FDs and TFs still both have various issues)
08:20:19 <DMcGill> I mean the syntax would be awful, but then that'll come as no surprise to anybody
08:20:24 <Trollkastel> geekosaur: Ah!
08:20:55 <Chousuke> DMcGill: hmm, I wonder if that's actually possible to implement. Though then you'd have to deal with Monad<A> and A being separate types.
08:21:21 <beaky> so multiparameter type classes solve a still unsolved problem?
08:21:22 <Trollkastel> DMcGill: I do not think you can write a Java interface Monad such that "class X implements Monad" does what "instance Monad X" does in Haskell.
08:21:54 <DMcGill> http://logicaltypes.blogspot.co.uk/2011/09/monads-in-java.html
08:22:02 <DMcGill> choice quote: "public abstract class Maybe<A> extends Monad<Maybe, A>"
08:22:29 <Trollkastel> DMcGill: Why Monad<Maybe, A> ?
08:22:52 <Trollkastel> DMcGill: In Haskell, the Monad type class is simply called "Monad".
08:23:34 <beaky> java is an inferior language, so you must explicitly list them out like that :(
08:23:36 <DMcGill> I know, but Java is not Haskell. It's not my article and I'm reading it for the first time now but it certainly seems possible
08:23:37 <Trollkastel> DMcGill: Also, you could write "public class Herp<Q> extends Monad<Derp, Wat>".
08:23:44 <beaky> it is not smart enough to infer types like that :D
08:24:00 <Trollkastel> DMcGill: Which shows the brokenness of the Java approach.
08:24:48 <beaky> why doesn't haskell have something like inheritance?
08:25:00 <johnw> beaky: what would it mean?
08:25:06 <Trollkastel> DMcGill: Anything that resembles what is called the "curiously repeating template pattern" in C++ is intrinsically broken.
08:25:45 <beaky> it would be like the new datatype having the same fields as the inherited ones
08:25:53 <beaky> and more
08:26:05 * Trollkastel wonders whether Hask (with total functions as morphisms) would still have nice properties if Haskell had inheritance. I suspect the answer is "no".
08:26:10 <johnw> beaky: last weak there was a records extension library for Haskell which lets you do that
08:26:17 <beaky> ah nice
08:26:24 <DMcGill> beaky: one way of adding inheritance is to do something like "data Child = Child Parent Field1 Field" then defining any instances you want on the Parent field
08:26:46 <DMcGill> I mean like "Functor Child where fmap = fmap `on` parent"
08:26:46 <beaky> right I think that's how they do inheritance behind the scenes :D
08:26:52 <beaky> :t on
08:26:53 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
08:26:58 <Trollkastel> DMcGill: But then projection from Child to Parent becomes an explicit operation.
08:27:00 <beaky> O.o
08:27:41 <thoughtpolice> well. really what i think we want is something row type-ish, as opposed to straight 'inheritence' - Jon's vinyl library looked pretty interesting on this note
08:27:45 <aCube> Can I have forall x. in constraints? i.e. the constraint must be valid for all s
08:27:50 <johnw> yes, vinyl is what I was thinking of
08:27:54 <thoughtpolice> (and it was apparently inspired by the same slides which introduced me to row typing)
08:28:00 <Cale> aCube: You can't, and that can be kind of sad sometimes
08:28:02 <johnw> http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html
08:28:17 <Trollkastel> thoughtpolice: Something like OCaml's polymorphic variants? :-|
08:28:20 <johnw> does vinyl use edwardk's lenses, or its own?
08:28:38 <Cale> aCube: there are ways to work around it
08:28:42 <geekosaur> is beaky still trying to force haskell to be an OO language like "'real' languages"?
08:28:49 <edwardk> johnw it uses lens
08:28:56 <johnw> edwardk: what do you think of vinyl?
08:29:18 <aCube> Cale: what ways?
08:29:19 <johnw> beaky: in practice, though, inheritance isn't needed as much as you might think
08:29:21 <Cale> aCube: for example, you can make a GADT something along the lines of:
08:29:28 <beaky> no I like haskell because it doesn't need OO nonsense :D
08:30:17 <thoughtpolice> Trollkastel: i don't know ocaml very well so i can't really comment. ocaml does have row polymorphism though, from my understanding
08:30:23 <edwardk> haven't spent much time worrying about it, but I wrote all the classy lens stuff explicitly to get away from OverlappingInstances, as they infer poorly. Vinyl needs them. Infer what you will ;)
08:30:33 <thoughtpolice> (i think polymorphic variants are separate, that is)
08:31:23 <edwardk> Its the same objection that I have to using Data Types a la Carte in practice.
08:31:43 <thoughtpolice> the inference problem?
08:31:55 <johnw> inheritance feels like its trying to avoid the difficulties of not having full parametric polymorphism by making the data polymorphic instead so that you can reference multiple values as if they were the same type
08:32:00 <edwardk> I find that the classy lens approach requires more boilerplate, but pays it back in terms of improved performance, and better inference.
08:32:30 <edwardk> As the price is usually paid by me the library author, I find that to be a viable trade-off ;)
08:32:44 <edwardk> thoughtpolice: yeah
08:33:43 <edwardk> ala carte approaches rely on you putting signatures in the right places so it can figure out which branch it should go down to look for the field. its an inherently 'types get pushed down' scheme. This means that inference for it is terrible.
08:33:49 <Cale> aCube: data Always (c :: * -> Constraint) where Always :: c t => Always c
08:33:59 <edwardk> Since by definition, inference can't solve those cases
08:34:25 <aCube> hmm, then I loose my newtype :(
08:34:41 <Cale> aCube: and then by pattern matching on a value of type Always, you unpack a dictionary for the appropriate constraint
08:34:42 <thoughtpolice> edwardk: it's a real problem. poor inference can in a lot of cases make a library completely unusable. i think this is pretty much the reason you don't really see people use e.g. all those insane overloaded regex libraries
08:34:58 <Cale> actually, does that work?
08:35:01 <Cale> Let me try it :)
08:35:31 <Cale> there are not so many useful classes which can have an instance quite like this
08:35:42 <thoughtpolice> (i've wondered from time to time if the inference issues in things like original regex libraries pushed haskellers further away from regexes than they seem to go already)
08:35:43 <Cale> It's more useful if you've already constrained it a little
08:35:56 <edwardk> thoughtpolice: exactly. i go out of my way to try to make it so everything i write can be inferred, not just checked for that reason
08:36:16 <edwardk> thoughtpolice: thats why when lens takes things in negative position it takes monomorphic args, etc.
08:36:23 <edwardk> it doubles as a way to get more overloading
08:36:25 <Cale> aCube: after all, if a class is valid for every type, then it doesn't really say much
08:37:14 <Cale> and yeah, that doesn't quite work, because t is existential there
08:37:28 <aCube> Cale: it's a newtype around a ST monad, which contains a STUArray of with some value type v.
08:37:29 <Cale> let's see, how did this go...
08:37:47 <djahandarie> Trollkastel, to my knowledge there hasn't been much research into what category a type theory with subtyping is the internal type theory of.
08:37:48 <hpaste> fizbin pasted “Proof arkeet asked for” at http://hpaste.org/86005
08:37:50 <Cale> What are you actually trying to do?
08:38:02 <fizbin> Bleah. That took longer than it should have.
08:39:03 <thoughtpolice> edwardk: ah, i see. speaking of lens, zipper was finally removed? :O
08:39:05 <djahandarie> Trollkastel, I don't know what properties you're referring to but I don't think it'd ruin everything.
08:39:36 <fizbin> arkeet: What were we talking about again when you asked me to prove that?
08:39:39 <edwardk>  thoughtpolice : yeah we're splitting it into a separate package
08:39:48 <Cale> aCube: what are you actually trying to do?
08:39:49 <aCube> Cale: I have a ST monad, with an STUArray of type v (which I wanted polymorphic, but maybe it's a lot easier if I fix it to some type), and now I want freeze the array in the ST monad and get it out.
08:39:50 <arkeet> fizbin: I don't know.
08:40:01 <arkeet> I feel like there should be a much shorter proof though.
08:40:17 <edwardk> thoughtpolice: that lets us explore nicer designs faster than the main lens package and we can provide a couple of versions, something simpler like we used to have and the new complex one that works well with indices and lots of infinite structures
08:40:42 <djahandarie> Subtyping is dumb anyways so who cares! :D
08:40:45 <Cale> aCube: isn't that what runSTUArray does?
08:40:46 <aCube> But to do that, I would need the contraint (forall v. MArray (STUArray s) v (ST s))
08:41:26 <Cale> runSTUArray :: Ix i => (forall s. ST s (STUArray s i e)) -> UArray i e
08:42:21 <djahandarie> Trollkastel, in general, when you add coercive subtyping to a type theory with meta-theoretic properties like strong normalisation you do generally maintain those properties at the very least
08:42:36 <Cale> aCube: see the comment immediately following the definition here: http://www.haskell.org/ghc/docs/latest/html/libraries/array/src/Data-Array-ST.html#runSTUArray
08:42:44 <djahandarie> (Like Martin-Lof's)
08:43:39 <Cale> Subtyping *is* kind of a scam :)
08:43:53 <Eduard_Munteanu> Heh.
08:43:59 <beaky> ah
08:44:02 <aCube> Cale: Seems like I can't use that function when my ST computation returns a pair of the array and another value?
08:44:40 * Trollkastel would simply use a regular type + a predicate (a : X, p : P(a)) for subtyping. I do not think there is a saner way.
08:44:47 <Cale> aCube: that's true, but you can look at the definition of it and do the same thing
08:45:59 <aCube> Cale: Do you find where unsafeFreezeSTUArray is exported?
08:46:16 <djahandarie> Interestingly, Martin-Lof has subtyping in its universes and its extensional version has the categorial semantics of a locally cartesian closed category. I wonder how that's captured (if it is at all...).
08:46:23 <Cale> aCube: GHC.Arr apparently...
08:46:30 <Cale> That's not so nice...
08:47:13 <aCube> Cale: Data.Array.Base seems to export it (/me should have looked at the import list=
08:47:14 <Eduard_Munteanu> aCube: don't use that
08:47:26 <Eduard_Munteanu> Or maybe use it, if you know what you're doing.
08:47:30 <Cale> aCube: actually, does plain  unsafeFreeze work?
08:48:35 * hackagebot regex-applicative 0.3 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.3 (RomanCheplyaka)
08:48:45 <aCube> Cale: no
08:49:22 <Cale> aCube: oh?
08:49:52 <Eduard_Munteanu> What do you mean it doesn't work?
08:50:19 <Cale> aCube: I mean, use it inside your ST computation in order to obtain something of type  ST s (..., UArray ...)
08:50:23 <johnw> why use regex-applicative instead of just parsec?  lighterweight?
08:50:27 <Cale> (where you can fill in the blanks)
08:50:45 <mm_freak> now i have a real pipes benchmark
08:50:53 <Cale> and then since those blanks don't have any s's in them, you can runST
08:51:18 <mm_freak> the fastirc IRC line splitter processes 74 MiB or randomly generated stream in 985 ms
08:51:23 <mm_freak> seems pretty promising
08:51:29 <mm_freak> s/or/of/
08:51:31 <Cale> aCube: I'm pretty sure that *will* work
08:52:31 <monoidal> anyone know if there are interactions between Safe Haskell and unboxed types? everything concerning them is in GHC.* modules which are unsafe - so any module using them has to be trustworthy or unsafe
08:52:36 <Cale> So you'll have something like  runST (do ... mySTUArray <- ...; ... myOtherResult <- ... ; frozen <- unsafeFreeze mySTUArray; return (myOtherResult, frozen)
08:52:41 <djahandarie> mm_freak, oh, you're working on that library again?
08:52:44 <Cale> )
08:52:47 <mm_freak> djahandarie: yeah
08:52:50 <djahandarie> Excellent
08:52:59 <mm_freak> https://github.com/ertes/fastirc
08:53:14 <monoidal> on a related note, the kind Constraint is in GHC.Prim which means that by default constraint-kinds programs cannot be safe
08:53:30 <mm_freak> the fastirc library itself isn't going to be as high level as the previous version…  i'm planning to move that to a separate library
08:53:39 <djahandarie> I'm happy with that change actually.
08:53:51 <mm_freak> djahandarie: most people are =)
08:54:22 <Cale> monoidal: Do you mean in the technical sense?
08:54:35 <Cale> monoidal: Informally, you can just import only Constraint from that module and be okay.
08:54:37 <johnw> mm_freak: what's the intended use for fastirc?  a new lambdabot?
08:54:39 <djahandarie> By the way, do you think you can be more flexible with some of the spec parsing now, or code in some methodology to swap out some of your parsers for stuff? Many IRCds don't follow the spec to the dot (colorered vHosts, etc, etc,.)
08:54:44 <mm_freak> djahandarie: but i'm not yet happy with the performance, and i have a feeling that conduit is still faster than pipes
08:54:45 <monoidal> Cale: but not with -XSafe
08:54:53 <Cale> monoidal: yeah
08:54:55 <mm_freak> johnw: anything IRC, including IRC servers
08:55:06 <Cale> It's actually rather unfortunate that you should have to import anything
08:55:14 <johnw> mm_freak: are they slow right now?
08:55:16 <mm_freak> johnw: it's a low level library that gives you access to the stream processors
08:55:29 <mm_freak> johnw: not slow, just not as fast as i would like them to be =)
08:55:38 <monoidal> Cale: perhaps there could be GHC.Prim.Safe or GHC.Prim.Unsafe module, but I understand that could break a lot
08:55:48 <mm_freak> let's see how fast fastirc is at parsing
08:55:59 <Cale> Perhaps Constraint should be a keyword when you turn on that extensions
08:56:03 <Cale> extension*
08:56:30 <Cale> Or it should be in the Prelude
08:57:16 <monoidal> for constraint, there's the constraints library that has Trustworthy flag, so it can be used instead
08:57:34 <monoidal> I wonder if there's something similar for unboxed types (or, whether that would be useful at all)
08:58:18 <Cale> It would certainly be useful. It can be safe to work with unboxed types.
09:01:08 <aCube> Cale: the same problem arises with thaw :/
09:13:35 * hackagebot git-annex 4.20130417 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130417 (JoeyHess)
09:13:45 <aCube> Does thaw even work for ST arrays?
09:14:05 <Cale> aCube: I don't see why not
09:17:19 <aCube> Cale: Ah, yes, sometimes it works, but I cannot use it if I need an STArray of type forall s. STArray s Int Int for example.
09:17:37 <Cale> There is no STArray of that type
09:17:55 <Cale> There are only STArrays of type STArray s Int Int for specific s
09:18:13 <_mr> Does anyone know how fpcomplete's evaluate-haskell-boxes are implemented? (I can't seem to find sources for it)
09:18:36 <johnw> you mean, where you click Run and it runs your code?
09:18:38 <Cale> You can make a computation of type  forall s. ST s (STArray s Int Int), but you can't runST that
09:18:41 <_mr> johnw: yeah
09:18:45 <johnw> that source is not public
09:19:01 <_mr> Oh, ok
09:19:11 <Cale> and you can run it whenever you want an STArray s Int Int of some specific type, but that involves doing whatever computation produces your array again
09:19:48 <johnw> _mr: at least, not at this time; whether we open it up in the future is yet to be determined
09:19:53 <aCube> Cale: But when I have a function of type Array Int Int -> forall s. ST s (STArray s Int Int) -> Array Int Int, I cannot get the the Array in the computation in that function
09:20:22 <Cale> Do you mean Array Int Int -> (forall s. ST s (STArray s Int Int)) -> Array Int Int
09:20:24 <Cale> ?
09:20:27 <aCube> (yes
09:20:38 <_mr> johnw: Ok, thanks
09:20:41 <Cale> sure you can
09:20:50 <Cale> But there isn't an array "in the computation"
09:20:57 <Cale> You have a computation which produces an array
09:21:06 <bishboria> \quit
09:21:31 <johnw> _mr: but to answer your original question, yeah, someone does know how it is implemented :)
09:22:09 <johnw> _mr: that's actually the component I'm working on at this moment
09:23:39 <Cale> aCube: what problem are you running into?
09:24:08 <_mr> johnw: I am unsure how to proceed. Does it not being open source forbid questions about how it is implemented? (As in, how it is not unsafe) ;-)
09:24:08 <Cale> aCube: what is the function meant to do?
09:24:14 <aCube> Cale: I had Array Int Int -> (forall s. ReaderT (STArray s Int Int) (ST s) (STArray s Int Int)) -> Array Int Int, but I can solve this if I just provide a function to run the reader and another one to run the ST monad
09:24:21 <johnw> _mr: you can ask, but I can't answer every question
09:24:43 <johnw> i'm happy to discuss the basics, though
09:26:26 <_mr> johnw: is it implemented using hint?
09:26:35 <Cale> aCube: foo x r = runSTArray (do stx <- thaw x; runReaderT r stx) ?
09:27:04 <monoidal> _mr: are you asking how to make a safe service to execute users' Haskell code and display results? look at tryhaskell, for example
09:27:09 <johnw> _mr: no, we use GHC API at the bottom of the stack
09:27:14 <aCube> Cale: that doesn't work, because it would require the contraint forall s. MArray (STArray s) v (ST s)?
09:27:29 <johnw> _mr: the code is actually being compiled
09:28:15 <Cale> errr...
09:29:03 <Cale> works for me
09:29:08 <_mr> johnw: and then being run on some virtual machine?
09:29:28 <hpaste> Cale pasted “foo” at http://hpaste.org/86007
09:29:30 <_mr> monoidal: Thanks, that's helpful.
09:29:40 <johnw> _mr: exactly, an Amazon EC2 instance
09:30:05 <Cale> aCube: note: the type signature is *not* optional here
09:30:17 <monoidal> _mr: also see mueval [http://hackage.haskell.org/package/mueval]
09:30:34 <Cale> aCube: GHC will never instantiate a type variable with a polytype on its own, so it can't infer higher rank types.
09:30:44 <johnw> _mr: mueval is what lambdabot uses
09:31:54 <Cale> aCube: does that work for you?
09:32:12 <aCube> Cale: yes ... I thought I had tried exactly that and it didn't work ...
09:32:13 <_mr> Yeah, I have looked at mueval.
09:33:00 <_mr> but I'd like to be able to run more than one expression.. maybe I haven't looked enough
09:33:27 <Cale> aCube: it's very important to realise that you have to thaw x inside of the same call to runST/runSTArray that you execute the result of the runReaderT in.
09:34:18 <aCube> Cale: oh, I can't get it work with UArray/STUArray
09:35:05 <_mr> johnw: which your script handles nicely ;-9
09:35:26 <johnw> _mr: well, sure, we're running whole programs
09:35:27 <Cale> aCube: I just stuck a bunch of U's in and it worked for me
09:36:26 <aCube> Cale: Oh, sorry, I forgot again a change I made, change the Int's to type variables
09:37:04 <hpaste> aCube annotated “foo” with “foo (annotation)” at http://hpaste.org/86007#a86009
09:40:21 <Cale> aCube: yeah, you won't be able to do that.
09:40:27 <Cale> (Not easily, anyway)
09:40:39 <Cale> Let's see if I can work out how to do it in a fancy way
09:40:57 <mm_freak> fastirc needs 534ms to parse 10 MiB of IRC…  that's pretty bad
09:41:16 <mm_freak> raw stream processing takes 22ms per 10 MiB
09:41:27 <sproingie> fastirc sounds somewhat less than fast
09:41:49 <mm_freak> sproingie: i'm writing a new version of it, based on pipes and (again) attoparsec
09:41:59 <mm_freak> somehow i have a feeling that conduit is faster than pipes after all
09:42:19 <sproingie> i'd have imagined the parsing would be the main bottleneck
09:42:30 <mm_freak> but the real bottleneck is attoparsec…  i should probably do something simpler or use a parser generator instead
09:42:50 <mm_freak> sproingie: it is, but i'm not happy about the raw stream processing speed either
09:43:11 <mm_freak> now the question is whether i should just wait for pipes to become faster or switch to conduit now
09:43:33 <mm_freak> the main problem is that pipes has a number of abstraction layers
09:43:47 * hackagebot concraft 0.7.2 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.7.2 (JakubWaszczuk)
09:43:50 * hackagebot concraft 0.7.3 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.7.3 (JakubWaszczuk)
09:44:01 <sproingie> that was quick
09:44:35 <mm_freak> hehe
09:44:43 <mm_freak> anyway, if anyone is interested in the code:  https://github.com/ertes/fastirc
09:45:02 <mm_freak> i'd be happy about suggestions to improve the speed without getting rid of pipes or attoparsec =)
09:45:27 <mm_freak> btw, it's probably still faster than other IRC protocol implementations in pure haskell
09:46:14 <int-e> hmm, and why is speed even important?
09:46:37 <djahandarie> mm_freak, aren't you lacking some strictness?
09:46:38 <mm_freak> int-e: to write IRC servers or other high throughput stuff
09:46:45 <Cale> aCube: got it :)
09:46:55 <djahandarie> int-e, it can be very important during netbursts (when two ircds link together) and such.
09:47:04 <mm_freak> djahandarie: i don't think so, but if you spot some missing strictness, feel free to add a bug report =)
09:47:06 <int-e> mm_freak: right. my first idea was a client and there I can't see how it matters :)
09:47:47 <hpaste> Cale pasted “Universal instance via GADT” at http://hpaste.org/86011
09:47:54 <djahandarie> Or during attacks on the network where you can have thousands and thousands of messages per second
09:47:58 <djahandarie> Even as a client
09:47:59 <mm_freak> int-e: secondarily i'm known for fast stuff in haskell, so i'm not happy with the current result ;)
09:48:27 <mm_freak> bbl
09:48:46 <Cale> aCube: so to use that, you'll apply foo to STUArrayInst
09:48:58 <Cale> and then its two usual parameters
09:49:42 <Cale> Since for whatever reason, GHC doesn't support putting forall on constraints, we just pack up the dictionary into a GADT, and then forall that.
09:50:28 <aCube> Cale: nice, thanks for your help. But I think it's easier to just split the running of the reader and the running of the st monad (have a function  (Ix i, IArray UArray e) => UArray i e -> (ReaderT (STUArray s i e) (ST s) (STUArray s i e)) -> ST (UArray i s) and then use runST on the user side on that). (I hope I got the type right :p)
09:50:33 <Cale> We could be a little more generic about this:
09:53:07 <hpaste> Cale annotated “Universal instance via GADT” with “Universal instance via GADT (annotation)” at http://hpaste.org/86011#a86013
09:54:18 <Cale> aCube: you can get the idea of how to do this more generally from that annotation
09:54:57 * [swift]_ wishes for tryReadChan
09:55:51 <Cale> [swift]_: You might like TChan
09:56:39 <[swift]_> Cale: i suspected that'd have more overhead than a regular Chan
09:56:47 <Cale> A bit, perhaps
09:57:06 <Cale> The STM machinery isn't free, but it tends to have better semantics
09:57:20 <[swift]_> Cale: though it'd be interesting to see whether the Chan + MVar combo i have to simulate tryReadChan is really any faster than just using a TChan..
09:57:30 <[swift]_> certainly
09:57:38 <Eduard_Munteanu> I think STM stuff is considerably more expensive actually.
09:58:12 <Eduard_Munteanu> Or at least the docs seem to imply, when describing some unsafe operations on them.
09:58:15 <[swift]_> i might end up there in the end, but my gut feeling was that it was too heavyweight for my problem, which is basically that i need to read from two Chans with one having priority over the other
09:58:20 <parcs> TChan has greater throughput than Chan
09:58:46 <parcs> er sorry, i meant TQueue
09:59:05 <Eduard_Munteanu> Interesting... that's still weird though.
09:59:15 <parcs> if you don't need dupChan and stuff then you should use TQueue
09:59:32 <[swift]_> i definitely don't need dupChan. i haven't seen TQueue; i'll look at it
09:59:40 <[swift]_> thanks for the suggestion
10:00:07 <johnw> I really like using STM
10:01:13 <parcs> and TQueue is so simple -- it's just a pair of TVar [a], while Chan is basicly magic
10:02:02 <Eduard_Munteanu> Worse magic, presumably. :/
10:02:21 <Eduard_Munteanu> Dunno how TQueue behaves though, do you get any less guarantees?
10:02:25 <joeyh> The more I use STM the more I like it. BTW, I attended a linux.conf.au talk on STM in GCC. Of course from C code you have to do all sorts of tricky things to ensure safety; they don't really seem aware how big a drag that's gonna be.
10:02:58 <johnw> joeyh: hello!
10:03:17 <joeyh> heya
10:05:11 <parcs> Eduard_Munteanu: what guarantees?
10:05:29 <Eduard_Munteanu> parcs: dunno, I was wondering if there's any catch :)
10:05:55 <merijn> Eduard_Munteanu: Well, the performance of STM is harder to predict
10:06:11 <merijn> Eduard_Munteanu: Because completely unrelated code may cause transactions to fail and repeat frequently
10:06:21 <Eduard_Munteanu> Hm, I see.
10:06:33 <merijn> Eduard_Munteanu: In the common case there shouldn't really be any really significant catches
10:06:45 <Eduard_Munteanu> Maybe plain Chan is just old?
10:07:12 <merijn> Chan certainly predates STM
10:07:47 <merijn> Eduard_Munteanu: btw, STM is only considerably more expensive if you need to rollback
10:08:13 <Eduard_Munteanu> merijn: I thought logging was also rather expensive
10:12:14 <fryguybo1> Eduard_Munteanu: It is expensive and can be made cheaper, but it isn't clear that the costs are at all dominant in common uses.
10:12:35 <Eduard_Munteanu> Yeah.
10:19:11 <sproingie> obviously you increase memory requirements by whatever you're logging
10:19:18 <sproingie> so long transactions, bad
10:20:17 <Eduard_Munteanu> That's probably not much of an issue... more like logging is more expensive than locking.
10:20:33 <fnsi> https://boards.4chan.org/sci/res/5684052
10:20:54 <Eduard_Munteanu> WTF is this 4chan/sci spam? Happened last night as well.
10:21:35 <fryguybob> Mantaining the log has costs like searching through the log for previous reads or writes.
10:21:37 <Eduard_Munteanu> Right, same thing.
10:21:42 <sproingie> i'd guess the cost of rollback is the retries
10:21:49 <wting> I have a simple question. `round $ logBase 10 1000` works in ghci, but when I try to use it in source it complains about the type signature: http://pastebin.com/HFzjtSbK
10:21:51 <mauke> The paste HFzjtSbK has been copied to http://hpaste.org/86015
10:21:59 <Eduard_Munteanu> Clearly decrypting ancient scrolls is a job for #haskell.
10:22:18 <sproingie> is any of the HTM stuff in haswell useful in STM?
10:22:36 <sproingie> or is it more an inter-core sync thing?
10:22:43 <fryguybob> sproingie: Yes, I'm currently researching that particular topic.
10:23:29 <sproingie> nifty
10:23:43 <geekosaur> wting: you need fromIntegral to promote your Integral-typeclass value
10:25:02 <fryguybob> sproingie: Hopfully I'll have a paper about it by the end of the summer.
10:26:33 <fizbin> :t \f -> ((.) ((.) (uncurry f)) (,))
10:26:35 <lambdabot> (a -> b -> c) -> a -> b -> c
10:26:56 <fizbin> @pl \f -> ((.) ((.) (uncurry f)) (,))  — should be id
10:26:57 <lambdabot> (line 1, column 37):
10:26:57 <lambdabot> unexpected '\128'
10:26:57 <lambdabot> expecting variable, "(", operator or end of input
10:27:09 <fizbin> @pl \f -> ((.) ((.) (uncurry f)) (,))
10:27:09 <lambdabot> (. (,)) . (.) . uncurry
10:28:48 <fizbin> @djinn (a -> b -> c) -> a -> b -> c
10:28:48 <lambdabot> f a = a
10:29:24 <beaky> is there a haskell implementation for jvm?
10:29:24 <beaky> or clr?
10:30:18 <wting> geekosaur: Where? If I define shiftleft on it's own line then the type signature is: shiftleft :: (Floating a, Integral b, RealFrac a) => a -> b
10:30:23 <johnw> beaky: yes, but they are old
10:30:27 <fizbin> beaky: How close do you need it to be? Some people like Frege?
10:30:33 <johnw> search the web for "Haskell salsa", "Haskell lambada", for example
10:30:35 <wting> geekosaur: Also, isn't round supposed to convert it to an Integral already?
10:30:51 <fizbin> beaky: https://github.com/Frege/frege
10:31:02 <geekosaur> wting, but round expects a RealFrac as input. as does logBase, but you're feeding it an Integral
10:31:10 <geekosaur> which is what the error messages are telling you
10:31:15 <beaky> ah
10:31:29 <beaky> so there is no functional programming language for jvm :(
10:31:37 <beaky> that is u-to-date?
10:31:41 <aCube> beaky: there is
10:31:42 <beaky> up to date*
10:31:54 <geekosaur> scala, clojure
10:31:54 <aCube> scala is for the jvm, afaik
10:31:55 <beaky> there is? yay no reason to learn java now :D
10:32:14 <wting> geekosaur: ohhhh, I get it now. Thanks.
10:32:28 <fizbin> beaky: Frege isn't that old. And depending on how you define "functional", many people would consider clojure (on the jvm) to count.
10:33:03 <sproingie> clojure has many good functional idioms.  like scala, it's multiparadigm
10:33:15 <beaky> clojure is one of those weird languages that put everything between parentheses
10:33:16 <sproingie> tho clojure is more functional by default in many ways
10:33:38 <sproingie> that's why lisp never took off, it didn't look like C, even though C hadn't been invented yet
10:33:50 <simpson> Huh?
10:33:53 <aCube> But Frege might also work if you just want something "haskell-like" on the jvm I'm guessing (I haven't used it yet=
10:33:55 <fizbin> beaky: But if you're working on the JVM you should also know Java anyway. It can be much, much nicer than you might think.
10:33:59 <skyflash> CAL is on the JVM
10:34:13 <sproingie> simpson: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
10:34:21 <simpson> sproingie: Oh, that.
10:34:23 <fizbin> beaky: Just stay away from any consultant heavily dipped in J2EE words.
10:34:30 <beaky> ah
10:34:39 <beaky> what's j2ee
10:34:44 * tromp_ joins #clojure out of curiosity
10:34:45 <skyflash> https://github.com/levans/Open-Quark
10:34:50 <sproingie> "1936 - Alonzo Church also invents every language that will ever be but does it better. His lambda calculus is ignored because it is insufficiently C-like. This criticism occurs in spite of the fact that C has not yet been invented."
10:35:05 <sproingie> the bit about ada lovelace is my favorite tho
10:35:18 <simpson> As an aside, has anybody here done any work at all, including schoolwork, with the pi calculus?
10:35:40 <fizbin> beaky: Something to run away from. I deliberately won't tell you more so that if you do find out about it, it isn't my fault. It stands for "Java platform 2, Enterprise Edition"
10:35:51 <beaky> ah
10:36:41 <fizbin> simpson: Wasn't Mark Chu-Carroll (of the "Good Math, Bad Math" blog) working on a toy language based on the pi calculus? Anyone know where he left that?
10:39:38 <simpson> fizbin: Dunno.
10:48:28 <wting> Trying to understand function composition: Why does `ceiling $ sqrt 3` and `ceiling . sqrt $ 3` work but `ceiling . sqrt 3` fail?
10:49:14 <wting> Shouldn't `ceiling . sqrt` compose a new function with the type signature: Floating -> Integral?
10:49:25 <monoidal> wting: precedence. last one parses as ceiling . (sqrt 3) which attempts to compose a function with a number
10:49:28 <Eduard_Munteanu> wting: yes, but it deosn't parse as such
10:49:58 <Eduard_Munteanu> > ceiling . sqrt 3 $ 5
10:49:59 <lambdabot>   2
10:50:05 <Eduard_Munteanu> Total confuses ensues. :P
10:50:11 <Eduard_Munteanu> *confusion
10:50:23 <monoidal> wting: you can write (ceiling . sqrt) 3 though
10:50:25 <wting> oh ok, I thought . had higher precedence.
10:50:25 <Eduard_Munteanu> Ignore that Caleskellism.
10:50:37 <int-e> > sqrt id 5
10:50:39 <lambdabot>   2.23606797749979
10:50:46 <wting> Isn't parentheses vs dollar signs just a preference?
10:51:00 <monoidal> wting: yes, it's a style thing
10:51:07 <int-e> > ceiling sqrt 3
10:51:09 <lambdabot>   No instance for (GHC.Real.RealFrac (a0 -> a0))
10:51:09 <lambdabot>    arising from a use of `GH...
10:51:14 <Cale> It's *mostly* just a style thing
10:51:31 <int-e> ah. not a number. sort of :)
10:51:42 <Cale> In the presence of higher rank polymorphism like with runST, using $ can be illegal sometimes
10:51:48 <Mortchek> wting, Floating and Integral are typeclasses, not types
10:51:52 <Mortchek> @type ceiling
10:51:53 <lambdabot> (Integral b, RealFrac a) => a -> b
10:51:54 <Mortchek> @type sqrt
10:51:55 <lambdabot> Floating a => a -> a
10:51:56 <Cale> (But that's rare)
10:52:01 <wting> Mortchek: ahh yeah, I keep forgetting that
10:52:05 <Mortchek> @type ceiling . sqrt
10:52:06 <lambdabot> (Floating b, Integral c, RealFrac b) => b -> c
10:52:09 <Eduard_Munteanu> Cale: I thought ($) was exactly the exception, (.) might be illegal
10:52:54 <elliott> it's actually illegal basically all the time with runST, GHC just hacks around it
10:53:07 <Cale> For a while there were some hacks specifically for ($), I don't know if those are still in?
10:53:11 <wting> Are there any advantages to doing `(ceiling . sqrt) 3` over `ceiling $ sqrt 3`? Performance? Readability?
10:53:12 <Eduard_Munteanu> Yeah, impredicativity. :(
10:53:24 <c_wraith> I think ($) still has the hack that just removes it.
10:53:37 <monoidal> wting: no, they're equivalent
10:53:45 <sproingie> wting: typical idiom is ceiling . sqrt $ 3
10:53:53 <Eduard_Munteanu> Depends who you ask.
10:53:55 <sproingie> dot everything to the left, $ at the end
10:53:58 <wting> k thx
10:54:04 <Eduard_Munteanu> I've seen some argue for (ceiling . sqrt) 3 as nicer
10:54:16 <Eduard_Munteanu> Harder to type though.
10:54:22 <monoidal> ceiling $ sqrt 3 is simplest here
10:54:32 <sproingie> ((ceiling . sqrt) 3)
10:54:41 <sproingie> that'th thuperior
10:54:49 <wting> sproingie: Looks too LISP'ish :p
10:54:52 <Eduard_Munteanu> Lithpy.
10:55:13 <Cale> honestly, I would often just write ceiling (sqrt 3)
10:55:15 <sproingie> hell may as well go all the way lisp
10:55:41 <Cale> But switching to composition is nice if you're going to factor things out
10:56:01 <Cale> and of course, as the parens get more nested, it's better
11:02:40 <jfischoff> what is a good way to have logs that show up during calculations, without having everything in IO?
11:03:14 <Mortchek> jfischoff, Writer monad?
11:03:32 <Eduard_Munteanu> Debug.Trace?
11:03:58 <osfameron> a "refreshing desert in the oasis of referential transparency"
11:04:07 <sproingie> i'd go with writer monad if your logs are an intended effect
11:04:15 <sproingie> Debug.Trace is for, well, debugging
11:04:17 <Eduard_Munteanu> Yeah.
11:04:43 <jfischoff> I want a Writer monad, but I just get the logs at the end correct?
11:04:57 <Eduard_Munteanu> No.
11:05:12 <Eduard_Munteanu> It should produce stuff as it goes.
11:05:31 <jfischoff> let me check
11:06:55 <monoidal> more preciesly that depends on the monoid. but for [String], it should be lazy.
11:07:25 <Eduard_Munteanu> For any [a] too.
11:07:40 <aCube> > runWriter (foldr1 (<*) $ repeat $ tell "Hello")
11:07:43 <lambdabot>   ((),"HelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHello...
11:07:52 <aCube> Seems lazy :D
11:08:43 <Eduard_Munteanu> You just need a mappend that's non-strict in the 2nd argument, I guess.
11:09:15 <Eduard_Munteanu> And, well, productive.
11:09:28 <arkeet> it's lazy but it's also awful.
11:09:40 <Eduard_Munteanu> arkeet: why?
11:09:58 <arkeet> repeatedly appending to the end of a list.
11:10:14 <sproingie> doesn't have to be a list
11:10:19 <armlesshobo> Cale: ghc-iphone works on linux, right? I just need to have gnustep installed.
11:10:23 <Eduard_Munteanu> It's not that bad, because it associates the right way.
11:10:26 <aCube> @type Data.DList.fromList
11:10:27 <lambdabot> [a] -> Data.DList.DList a
11:10:33 <arkeet> does it?
11:10:40 <aCube> > runWriter (foldr1 (<*) $ repeat $ tell a)
11:10:41 <lambdabot>   ((),a <> a <> a <> a <> a <> a <> a <> a <> a <> a <> a <> a <> a <> a <> a...
11:10:57 <arkeet> > (a <> a) <> a
11:10:58 <lambdabot>   (a <> a) <> a
11:11:01 <arkeet> huh, ok.
11:11:05 <elliott> > runWriter (forever (tell a))
11:11:13 <lambdabot>   mueval: Prelude.undefined
11:11:13 <lambdabot>  mueval: ExitFailure 1
11:11:16 <aCube> ha
11:11:17 <elliott> > runWriter (() <$ forever (tell a))
11:11:21 <lambdabot>   mueval-core: Time limit exceeded
11:11:24 <elliott> useless.
11:11:36 <Eduard_Munteanu> Huh.
11:12:12 <Eduard_Munteanu> Why doesn't that work?
11:12:23 <wting> Is there a good way to correct for floating point errors in logBase? I need logBase 10 1000 == 3 (currently returns 2.999996). I can't use round because I need (floor $ logBase 10 400) == 2
11:12:28 <DanBurton> > execWriter (() <$ forever (tell a))
11:12:30 <arkeet> > runWriter (fix (tell a <*))
11:12:32 <lambdabot>   mueval-core: Time limit exceeded
11:12:34 <lambdabot>   mueval-core: Time limit exceeded
11:13:07 <DanBurton> > evalWriter (() <$ forever (tell a))
11:13:08 <lambdabot>   Not in scope: `evalWriter'
11:13:08 <lambdabot>  Perhaps you meant one of these:
11:13:08 <lambdabot>    `execWriter'...
11:13:38 <monoidal> DanBurton: the () <$ part removes the difference between exec/run/eval
11:15:45 <monoidal> wting: I don't think there is. I wouldn't use floating point arithmetic, but don't know if there's integer logarithm somewhere
11:18:20 <johnw> yes, there is
11:18:50 <johnw> log10 x = I# (integerLogBase# 10 x)
11:19:00 <johnw> from GHC.Integer.Logarithms
11:19:16 <wting> Ahh just found it, thanks johnw and monoidal
11:22:18 <elliott> Eduard_Munteanu: associativity or something. probably.
11:22:23 <klrr> CISPA JUST PASSED!
11:23:05 <Taneb> That is a thing that is not immediately relevant to this channel, klrr
11:23:38 <klrr> Taneb: dude
11:25:55 <wting> johnw: Why does `let log10 x = I# (integerLogBase# 10 x)` complain about # not being in scope?
11:26:14 <monoidal> wting: you need -XMagicHash extension
11:26:55 <wting> ahh k, thx; going down the rabbit hole
11:27:21 <mel-> Hi
11:28:05 <DMcGill> mel-: Hello
11:28:23 <DMcGill> we should get lambdabot to automatically greet people
11:28:30 <arkeet> we should not.
11:28:39 <DMcGill> not on sign in
11:28:43 <arkeet> we should not.
11:28:48 <armlesshobo> that's a horrible idea
11:28:55 <armlesshobo> considering the amount of traffic here.
11:29:04 <DMcGill> but if somebody comes in and says "hi" or "hello". There's usually somebody that does it anyway
11:29:30 <arkeet> that seems like an argument against it.
11:29:55 <DMcGill> reduces the chance of user error!
11:29:59 <mel-> It's the first time I'm trying out network programing in Haskell. I need to share data between threads (I use forkIO threads for connecting clients). I figured out that MVar's might be a good solution for my problem. I hacked the following test case program: http://pastebin.com/75d17NqX -- the idea is that you can connect via telnet to the server process and when you press enter a counter gets incremented
11:30:02 <mel-> and send to the client. But my counter stays at zero.
11:30:03 <elliott> the human will just do it anyway.
11:30:07 <mauke> The paste 75d17NqX has been copied to http://hpaste.org/86020
11:30:29 <mel-> if anybody could tell me what i might be doing wrong, that would be awesome!
11:31:01 <arkeet> mel-: you are creating a new MVar every time you run counterIncrement
11:31:35 <arkeet> you need to create a single MVar in, say, serverLoop, and pass it around.
11:33:00 <mel-> arkeet: hmm, okay, thank you! somehow this was not clear to me from reading the documentation
11:34:28 <DanBurton> lambdabot could always greet people in a private query rather than in the channel
11:34:28 <wting> Sorry for all the questions. I've enabled -XMagicHash but now it complains that I# and Int# data constructors aren't in scope.
11:34:40 <arkeet> that's because they aren't imported.
11:34:45 <dmwit> import GHC.Types, I think
11:34:53 <arkeet> they're in GHC.-yeah
11:34:59 <dmwit> DanBurton: This idea is getting worse and worse.
11:35:29 <DMcGill> yeah, I wasn't exactly serious at the time. I withdraw my proposal
11:35:33 <wting> oh ok, I couldn't find any documentation on how to import unboxed data types. :-/
11:35:44 <dmwit> We have a channel topic, isn't that enough?
11:36:02 <arkeet> oh, GHC.Exts is where they are.
11:36:30 <DanBurton> I withdraw my modified proposal
11:36:32 <dmwit> wting: MagicHash is only a little bit magic. =)
11:37:07 <arkeet> -XMagicHash just makes it treat # has a letter, no?
11:37:27 <arkeet> or
11:37:37 <arkeet> I suppose not.
11:37:45 <arkeet> since we have stuff like (# #)
11:38:10 <arkeet> The language extension -XMagicHash allows "#" as a postfix modifier to identifiers. simple
11:38:39 <c_wraith> But it also allows slightly more, since as you point out, it enables the unboxed tuple syntax.
11:39:13 <arkeet> "The -XMagicHash also enables some new forms of literals"
11:39:29 <c_wraith> and yeah, literals like 1#
11:39:40 <arkeet> looks like unboxed tuples come with -XUnboxedTuples
11:43:55 <beaky> how do you design software?
11:44:21 <fryguybob> beaky: Very carefully.
11:45:37 <beaky> my designs always break when I need to add to them :(
11:45:46 <tac> beaky: first, I decide what category it makes sense best to write it
11:45:57 <dmwit> mikeplus64: Oooo, I like that id == ($) one.
11:46:06 <dmwit> < id == (+0::Word8)
11:46:10 <goodfellow>   mueval-core: Time limit exceeded
11:46:15 <mvb> beaky: what kind of desgins? how do they break?
11:46:16 <dmwit> too bad =P
11:46:22 <mvb> > one
11:46:23 <lambdabot>   Not in scope: `one'
11:46:23 <lambdabot>  Perhaps you meant one of these:
11:46:23 <lambdabot>    `once' (imported fr...
11:46:46 <beaky> e.g. I design a roguelike that plays in the tty
11:46:52 <beaky> now I am required to make it graphical and 3d
11:47:04 <dmwit> < id == (+(0::Word8))
11:47:05 <goodfellow>   True
11:47:06 <beaky> bam, need to renovate the graphics engine
11:47:09 <dmwit> there we go
11:47:19 <mvb> is (filter (>10) . map (+5)) [1,2,3] equivalent in speed to filter (>10) $ map (+5) [1,2,3]
11:48:11 <dmwit> Benchmark it. But yes.
11:48:23 <pdxleif> I think if you add more $'s it runs faster
11:48:28 <beaky> haha
11:48:34 <pdxleif> Would the latter form create more thunks?
11:48:46 <mel-> arkeet: thanks, I've got it working
11:48:51 <arkeet> :)
11:48:56 <fryguybob> beaky: That sounds like perhaps (not necessarally) you are struggling with separation of concerns: http://en.wikipedia.org/wiki/Separation_of_concerns
11:49:05 <dmwit> They both reduce to filter (>10) (map (+5) [1,2,3]) after one step of evaluation.
11:50:04 <fryguybob> That particular article does not address how that works well in Haskell though...
11:50:08 <mvb> rougelike in the tty?
11:50:35 <beaky> yes
11:51:10 <mvb> =?
11:51:19 <beaky> if only there was a Fundamental Theorem of Programming that Icould use to design anything
11:51:31 <mvb> just program a lot and you learn
11:51:32 <beaky> maybe programs are monoids?
11:51:35 <beaky> ah
11:51:47 <beaky> so far what I've learned is that all my previous designs are broken :(
11:51:56 <beaky> I just never create the perfect design
11:51:57 <fryguybob> beaky: An answer that I like to "how to design software?" is http://conal.net/papers/type-class-morphisms/type-class-morphisms-long.pdf
11:51:58 <mvb> but try to break up programs in small pieces that do one thing and do it well. group similar functionality into the same module.
11:52:38 <beaky> ah
11:53:17 <dmwit> beaky: Yes, programs are monoids. Specifically, m a is a monoid whenever m is a monad and a is a monoid (and hence IO () is a monoid). Not sure where you want to go with that, though.
11:53:33 <Chousuke> haskell makes it easy to do that at the expense that often it's not quite obvious what the small pieces should be :P
11:53:44 <c_wraith> dmwit: technically, main doesn't need to be IO ().
11:53:55 <dmwit> technically, I didn't restrict things to IO ()
11:54:27 <dmwit> But yes, main needn't be restricted to Monoid a => IO a, either.
11:54:31 <dmwit> I understand what you're saying.
11:54:38 <c_wraith> yeah, that was my point
11:54:54 <dmwit> It's kind of a silly point, since the a gets thrown away anyway.
11:55:20 <dmwit> So in the "program" sense, you still have a monoid (with "return undefined" as the unit).
11:57:53 <DMcGill> hey edwardk, any particular way you want me to cite lens in my dissertation? Unless you say otherwise I'm just going to go with the standard 'author, title, year, url' info and use 'lens.github.com' as the url
12:01:15 * hackagebot lgtk 0.3 - lens-based GUI with Gtk backend  http://hackage.haskell.org/package/lgtk-0.3 (PeterDivianszky)
12:06:31 <klrr> good night haskers
12:08:48 <beaky> is it true that all haskell programs are just trees of expressions?
12:08:50 <Cale> DMcGill: wouldn't the hackage page be more useful? :)
12:09:03 <beaky> and that running the program is evaluating that tree?
12:09:14 <Cale> beaky: no?
12:09:24 <Cale> Well, sort of
12:09:27 <tac> isn't that true of any language?
12:09:29 <beaky> ah
12:09:30 <DMcGill> beaky: all compiled programs ever are parsed as an AST
12:09:33 <johnw> beaky: haskell source code is more than just expressions, but there is a sense in which what you say is true
12:09:40 <beaky> https://news.ycombinator.com/item?id=5083355
12:09:51 <Cale> also, evaluation results in graphs, not just trees
12:09:53 <johnw> tac: other languages have statements
12:10:06 <johnw> although you can rewrite statements into chained expressions
12:10:32 <Cale> (directed graphs)
12:11:01 <Cale> I like to point people at these animations: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
12:11:25 <Cale> I think luite has one which shows the actual graphs from GHCJS compiled code :)
12:11:37 <luite> :)
12:11:53 <beaky> aw, I thought the idea of Haskel-programs-as-expression-trees was romantic :( I imagined programs were a giant formula, and there was this Haskell dude who worked out that formula step by step
12:12:05 <Cale> beaky: It's not entirely wrong
12:12:10 <luite> i'm going to improve that later, still busy working on the dataflow optimizer for ghcjs, want to finish that first
12:12:16 <beaky> ah
12:12:17 <Cale> beaky: But you have to let the "trees" have cycles
12:12:28 <beaky> ah
12:12:50 <Cale> and execution of IO actions should probably be considered separate from evaluation
12:12:59 <Cale> but it's also important
12:13:12 <Cale> otherwise, all your Haskell program will do is make your computer hot
12:13:16 <fizbin> Also, make the Haskell dude lazy.
12:13:26 <beaky> right
12:13:57 <Eduard_Munteanu> "Hot Haskell program looking for romantic encounters with a CPU."
12:13:58 <fizbin> And the only thing Haskell dude really has to do is evaluate main
12:13:59 <beaky> so lazy means like wrapping things up in a variable, and only working out the value of that variable at the last minute i.e. one the outer expressions are reduced?
12:14:32 <DMcGill> Cale: heat is a side effect, all truely pure haskell programs are equiv to `main = return ()' ;)
12:14:41 <fizbin> Pretty much, yeah.
12:14:42 <Cale> lazy evaluation means that expressions are evaluated outermost-first, and whenever a variable occurs more than once in its scope, its value is evaluated at most once.
12:14:44 <luite> btw if anyone's interested in helping out with ghcjs: it would be nice if someone can split up gloss to have a core that doesn't depend on opengl. i mailed ben lippmeier but he doesn't have time. i really want ghcjs gloss for animations and simple programs to illustrate haskell and math concepts :)
12:14:57 <beaky> ah
12:15:01 <luite> ghcjs support works, but the opengl dependency is a pain
12:15:05 <beaky> lazy evaluation is very smart
12:15:23 <Cale> luite: y u no webgl?
12:15:32 <Cale> (or is that really hard?)
12:15:32 <DMcGill> well not especially, in fact it often gets in the way
12:15:47 <Trollkastel> beaky: Actually, typically you want to decide when you have strict/lazy evaluation. :-|
12:15:55 <DMcGill> an important part of optimising Haskell programs is working out what needs to be strict
12:16:11 <luite> Cale: gloss is 2d, is a bit simpler at first, draws on a canvas
12:16:16 <beaky> so I default to lazy, and then once I test and my stack blows up, I tell Haskell to be stricter in those parts?
12:16:23 <DMcGill> exactly
12:17:10 <luite> Cale: webgl through the opengl-raw package is probably possible, it would require more hacking in the build system, and wrapping a lot of ffi calls. browser support would also be more limited (IE10 has no WebGL, i think safari has it disabled by default)
12:17:26 <Cale> beaky: over time, you'll get used to seeing cases where you're going to generate a large expression built of functions which will all need to pattern match immediately and blow up the stack when they finally get evaluated
12:17:33 <DMcGill> as a rule, things like list accumulators are usually better off strict
12:17:39 <Cale> beaky: (and know to introduce some strictness early)
12:17:50 <DMcGill> or more generally, smallish objects that have lots of operations done to them
12:18:24 <Cale> Well, if the thing you're accumulating is itself a list, lazy should be fine
12:18:42 <fubaz> is there any package that packs if "function" ? if not why? it'd be useful for eg. currying conditionals
12:18:44 <beaky> maybe ghc -O2 will automagically decide when not to thunk
12:18:45 <DMcGill> not always the case of course, but consider things like foldl (+) 0 [1..1000] or foldl Data.Set.append and so on
12:19:14 <Cale> But if you're producing something like an Integer where it's all or nothing as far as evaluation is concerned, that's where you want some strictness
12:19:16 <DMcGill> beaky: I wouldn't count on it, optimisation is HARD and requires profilling to be sure that you're doing the right thing
12:19:31 <Cale> It's okay to use lazy foldl when defining reverse for instance.
12:19:31 <beaky> right
12:19:46 <beaky> @src reverse
12:19:46 <lambdabot> reverse = foldl (flip (:)) []
12:20:02 <fubaz> or am i missing something?
12:20:04 <DMcGill> Cale: perhaps I should amend what I said to "usually for primitive accumulators it's best to be strict"?
12:20:17 <Cale> fubaz: I don't understand your question
12:20:25 <aCube> Why is reverse not foldl' ?
12:20:38 <DMcGill> on the other hand, being non-strict for delete operations on lists and sets leads to things not being garbage collected properly
12:20:52 <fubaz> cale, ah, sorry. i'm wondering if there's any haskell module that has if defined as function.
12:20:54 <beaky> is there a way to get ghc to print out the resulting asm with comments?
12:20:54 <Cale> DMcGill: Yeah, the only exception I took to what you said was that "list accumulator" could be taken to mean that the thing being accumulated is itself a list, which will usually be okay
12:21:05 <DMcGill> aCube: because that's a case where you're going to be lazy anyway
12:21:05 <Cale> fubaz: ah, okay
12:21:08 <fubaz> cale, because it seems that'd be immensely useful little piece of function
12:21:38 <Cale> fubaz: It's not in the base library as far as I know
12:22:07 <DMcGill> @hoogle if'
12:22:07 <lambdabot> No results found
12:22:10 <DMcGill> @hoogle if
12:22:10 <lambdabot> keyword if
12:22:10 <lambdabot> package IfElse
12:22:10 <lambdabot> package iff
12:22:35 <fubaz> oh!
12:22:58 <DMcGill> none of those have it in I'm afraid
12:23:10 <DMcGill> the lack of (.:) has annoyed me too, just one of those things
12:23:37 <fubaz> hmm.. strange, because you'd expect one to exist, it'd be a lot more useful than the current if/then/else construct imo
12:23:41 <fubaz> yeah
12:24:33 <fubaz> thanks anyway!
12:24:36 <Cale> http://hackage.haskell.org/packages/archive/bool-extras/0.3.0/doc/html/Data-Bool-Extras.html
12:24:55 <fubaz> hey, cool!
12:25:04 <fubaz> perfect!
12:25:07 <fubaz> thanks! :)
12:25:28 <Cale> Kind of a silly package in some ways :P
12:26:00 <Taneb> There's a whole bunch of packages like that
12:26:02 <Cale> But that bool function would make a good addition to the prelude
12:26:11 <beaky> what makes haskell syntax so neat?
12:26:22 <beaky> compared to C++'s
12:26:41 <fubaz> indeed :)
12:26:44 <Cale> beaky: Mostly the layout
12:27:01 <DMcGill> no parentheses makes a huge difference
12:27:03 <Cale> You can leave out the braces and semicolons
12:27:07 <beaky> ah
12:27:14 <DMcGill> see also python's syntax
12:27:15 <Cale> and yeah, it has function composition/application operators
12:27:18 <beaky> I wish I could use layout in <insert braces language>
12:27:34 <DMcGill> whitespace sensitive makes it a lot more human readable imo
12:29:13 <Cale> Though to be honest, the semantics does a lot more for it than the syntax does.
12:29:54 <Cale> O'Caml has much shittier concrete syntax than Haskell and is still a million times more usable than C++
12:29:54 <DMcGill> lambda functions are nice and concise too, compare with equiv Java code
12:29:55 <c_wraith> making function application clean, especially partial application, really helps
12:33:25 <beaky> so C++ has std::bind and std::function for partial application/ first-class functions and lambadas, but I don't know how to get pattern matching :(
12:39:06 <DanBurton> write a pre-processor?
12:41:11 <Cale> I'm sure there's probably some horribly evil way to do it without a preprocessor. You'd probably be scarred for life though.
12:43:26 <johnw> i have some code in IO which does !() <- ...  What is that idiom about?
12:44:48 <DMcGill> this is about as close as it gets http://stackoverflow.com/a/252568
12:45:59 <DMcGill> hmm, would it force evaluation of that monadic function?
12:46:10 <johnw> like 'evaluate'?
12:46:20 <johnw> but shouldn't IO do that already?
12:46:54 <Cale> johnw: Using a bang pattern on something which isn't a variable is stupid and does nothing
12:47:36 <johnw> yeah, I'm having a hard time seeing how !() <- a would be any different from a in IO
12:48:02 <DanBurton> it wouldn't
12:48:10 <Cale> johnw: () <- a would be very slightly different from a
12:48:14 <luite> DMcGill: cleverer people would omit the separate tag field and store the ints in unused NaN space in the doubel :p
12:48:19 <Cale> but no different from !() <- a
12:48:38 <Cale> Pattern matching will force the evaluation of the result
12:48:40 <DanBurton> well it depends on what comes next, I suppose. And how >> is implemented
12:48:46 <DanBurton> @src >>
12:48:46 <lambdabot> m >> k      = m >>= \_ -> k
12:48:59 <Cale> If the evaluation of the () might not terminate, then it makes a semantic difference
12:49:13 <DanBurton> > return undefined >> return () :: Maybe ()
12:49:15 <lambdabot>   Just ()
12:49:17 <Cale> and if other things are evaluated as a consequence, then it can have a performance impact
12:49:29 <DanBurton> > do () <- return undefined; return () :: Maybe ()
12:49:30 <mvb> can you run the C preprocessor on haskell files? wait you can run it on any fle right? how do I invoke it?
12:49:31 <lambdabot>   *Exception: Prelude.undefined
12:49:55 <luite> DMcGill: i'm not sure if it has enough space for floats, and all (32 bit ints), probably does
12:50:48 <DanBurton> now why on earth someone would give you an infinite loop when they are expected to merely supply a () is beyond me, but I suppose that could happen
12:50:50 <DMcGill> mvb: {-# LANGUAGE CPP #-} at the top of the file or compile with -XCPP
12:51:17 <mvb> DMcGill: cant i invoke it without calling ghc?
12:51:24 <mvb> just run the preprocessor any file?
12:52:01 <DMcGill> I don't know, gcc would probably do it if you only wanted to run a file through the  preprocesser and then stop
12:52:34 <DMcGill> a ha!
12:52:46 <DMcGill> mvb: ghc file.hs -XCPP -E
12:52:59 <DMcGill> will stop after preprocessing leaving behind a .hspp file
12:53:28 <dolio> If you just want to run cpp on a file, do it.
12:53:45 <dolio> Unless it isn't installed, in which case install it.
12:54:04 <DMcGill> is ghc's cpp different to the standard one? I have no idea
12:54:16 <dolio> It's probably subtly different.
12:54:25 <dolio> Because I don't think they just use cpp.
12:54:26 <DMcGill> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/options-phases.html#c-pre-processor
12:54:37 <DMcGill> apparently it's standard cpp with a few extra macros
12:56:46 <luite> dolio: ghc does use cpp, not cpphs
12:56:56 <luite> it calls gcc -E
13:01:07 <aCube> test-framework-quickcheck2 seems to have an outdated upper bound on quickcheck, it requires < 2.6?
13:01:56 <aCube> Are there alternatives to test-framework for running quickcheck tests?
13:02:27 <Clint> hspec
13:03:53 <giogadi> howdy!
13:04:15 <giogadi> I've got a question about numeric types
13:04:47 <aCube> Clint: thanks, hspec looks nice :)
13:04:50 <giogadi> If I perform the following operations in ghci:
13:04:53 <giogadi> let x = 2
13:04:56 <giogadi> let y = x + 3.1
13:05:03 <Clint> aCube: i prefer test-framework, but enjoy
13:05:06 <giogadi> I'm given an error. fine makes sense
13:05:09 * elliott murmurs: monomorphism restriction
13:05:12 <arkeet> giogadi: x defaults to Integer
13:05:16 <eikke> aCube: I noticed that constraint as well today, rather annoying
13:05:27 <giogadi> but if I put those in a source file and interpret it in ghci, it works just fine
13:05:46 <aCube> especially if you have other packages build against QC 2.6 :( Cabal-hell!
13:05:51 <arkeet> yes, because then it can see all the bindings at once, so everything defaults to Double.
13:06:04 <arkeet> if you want more polymorphism, give things type signatures.
13:06:08 <arkeet> let x :: Num a => a; x = 2
13:06:17 <arkeet> or, turn off the monomorphism restriction.
13:06:23 <giogadi> hm, that's interesting
13:06:33 <giogadi> so the other thing I noticed was that, after loading in the source file, x is a Double
13:06:34 <arkeet> @where dmr
13:06:34 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:06:43 <giogadi> but if I remove the y operation, x is an Integer
13:06:47 <arkeet> indeed.
13:07:11 * Clint eyes https://github.com/batterseapower/test-framework/pull/48
13:07:40 <DMcGill> I once saw a nice lens derivation that was much more simple (and principled) than the one at https://github.com/ekmett/lens/wiki/derivation does anybody have a link handy?
13:07:52 <DMcGill> s/and principled/and less principled
13:08:11 <eikke> DMcGill: a presentation by Twan?
13:08:26 <giogadi_> oops, internet went out
13:08:43 <giogadi_> if anything else was said to me a few moments ago I missed it, sorry
13:08:50 <edwardk> DMcGill: glguy has one
13:09:24 <giogadi_> so does haskell go through a module and ensure that all bindings have an explicit type?
13:09:40 <DMcGill> thanks
13:09:46 <glguy> ?
13:09:50 <Cale> giogadi_: no, if you leave out type signatures, it will infer them
13:10:10 <DMcGill> giogadi: no, you can set GHC to warn/treat warnings as errors if you really want though
13:10:26 <giogadi_> so if a module has "x = 2", as long as there are no other constraints on x, it'll assume the default type of "Integer"?
13:11:01 <DMcGill> Twan's presentation will do nicely
13:11:56 <DMcGill> giogandi_: check out http://www.haskell.org/onlinereport/decls.html#sect4.3.4
13:12:14 <DMcGill> as far as I know the only defaults are Integer and Double
13:12:58 <DMcGill> if there is ambiguity it's usually best to specify it yourself though - it only takes one top level type declaration to propagate across all your code
13:13:24 <giogadi_> right, I understand now
13:13:26 <giogadi_> thanks everyone!
13:13:45 <DMcGill> note that the inferred type for most things will be parametric
13:15:07 <DMcGill> for example, this won't default to a specific type:
13:15:20 <DMcGill> :t \f (x:xs) -> f x : xs
13:15:22 <lambdabot> (a -> a) -> [a] -> [a]
13:15:55 <giogadi_> right, I see
13:16:47 <DMcGill> since the `f x' is prepended to `xs' then since xs :: [a], then f x :: a and f :: a -> a
13:23:50 <mvb> does TCP send a stream of bytes or bits+
13:23:52 <mvb> ?
13:25:26 <startling> is there a template haskell thing that can derive traversals of arbitrary type variables?
13:26:13 <johnw> mvb: are you asking about the TCP protocol?
13:26:34 <thoughtpolice> startling: {-# LANGUAGE DeriveTraversable #-} ?
13:27:04 <startling> thoughtpolice, I know. I have a type of kind * -> * -> *, though, and I want to derive a traversal of the first type argument, too.
13:27:22 <DMcGill> thoughtpolice: that doesn't help if you want a function to inline come up with one
13:27:25 <DMcGill> which I think startling is asking
13:28:05 <DMcGill> ahh, I got it completely wrong
13:28:56 <startling> and this is a huge recursive sum type. :(
13:29:06 <startling> also I'm getting charged 10c a keystroke
13:29:21 <edwardk> startling: write a Bitraversable instance and use 'first' as that traversal
13:29:21 <edwardk> er foo f = bitraverse f pure
13:30:08 <startling> edwardk: that doesn't help in actually writing the traversal, though
13:30:24 <startling> (unless there's a deriveBitraversable somewhere?)
13:30:35 <edwardk> startling: nope. you just need to bull through and do it
13:31:10 <mvb> johnw: yes
13:31:12 <startling> edwardk: yeah. hence my question.
13:31:28 <johnw> mvb: I'm pretty sure it works in bytes
13:31:36 <johnw> in network byte order
13:31:39 <edwardk> the main thing it gets you is that you can borrow its code for the normal traversal if you don't mind a little lost sharing
13:32:05 <startling> sure.
13:32:34 <johnw> yes, the internet describes TCP as a "byte stream" in many places
13:33:04 <beaky> how do I change String from [Char] to Data.Text?
13:33:16 <johnw> pack
13:33:20 <johnw> Data.Text.pack
13:34:18 <beaky> ah thanks
13:34:20 <beaky> :t pack
13:34:22 <lambdabot>     Not in scope: `pack'
13:34:22 <lambdabot>     Perhaps you meant one of these:
13:34:22 <lambdabot>       `BS.pack' (imported from Data.ByteString),
13:34:26 <beaky> :t Data.Text.pack
13:34:28 <lambdabot> String -> Data.Text.Internal.Text
13:34:33 <beaky> :)
13:34:48 <johnw> you can guess what unpack does :)
13:35:27 <beaky> :t Data.Text.unpack
13:35:29 <lambdabot> Data.Text.Internal.Text -> String
13:35:43 <beaky> where does Haskell stand in the Blub paradox?
13:35:46 <DMcGill> beaky: if you have lots of string literals in a file you find yourself doing "pack "foo" lots. Adding the OverloadedStrings extension means that "foo" is parsed as Text in the first place rather than String
13:36:07 <beaky> ah good idea to use it from the beginning I guess
13:36:37 <DMcGill> it's desugared back to using pack iirc, but it makes things a bit easier. Of course, it can get confusing if you use it to mean Text and Strings in the same file
13:36:40 <startling> DMcGill: not quite
13:36:42 <startling> yeah.
13:37:07 <simpson> DMcGill: Any idea whether OverloadedStrings causes string packing to happen at compile time instead of run time?
13:37:11 <startling> OverloadedStrings replaces string literals with "fromString literal"
13:37:17 <tomh__> anyone has an idea why compiling a project fails on mac when trying to match a Double with a CpFloat (http://hackage.haskell.org/packages/archive/Hipmunk/5.2.0.10/doc/html/Physics-Hipmunk-Common.html)?
13:37:20 <startling> simpson, run time
13:37:31 <simpson> startling: Mm. :c
13:37:36 <startling> I know. >:(
13:37:48 <DMcGill> I did not know that, can't those constants be folded out?
13:38:00 <johnw> beaky: We're definitely aware that dependently typed languages have features we'd like at some point
13:38:18 <startling> DMcGill: they definitely *could*
13:38:39 <beaky> dependendent typing sounds like a whole different beast from what I know about haskell :D what do those bring to the table?
13:38:44 <luite> tomh__: looks like that type synonym is determined by hsc2hs, so it might not really be a Double on your system
13:38:57 <DMcGill> is this back to the old problem of "optimisation is hard, it needs profiling to make the best decisions"?
13:38:59 <startling> beaky, partial evaluation at compile-time, mostly
13:39:08 <beaky> wow
13:39:29 <startling> though I don't think it's necessary for dependent typing.
13:39:32 <tomh__> luite: how do you mean?
13:39:49 <simpson> I love how simple "partial evaluation" sounds.
13:39:52 <beaky> I like the idea of the compiler proving things like "your code is buggy because of this type mismatch"
13:40:01 <startling> simpson: it's not even complete evaluation!
13:40:08 <startling> should be cake.
13:40:15 <simpson> startling: Exactly.
13:40:24 <startling> >.>
13:40:52 <DMcGill> beaky: that's the entire point of static typing, not specific to Haskell at all
13:41:03 <DMcGill> static strong typing I mean
13:41:12 <startling> DMcGill, dependent typing lets you write actual proofs though
13:41:32 <luite> tomh__: this is the actual source, which hsc2hs processes to produce the .hs file: http://hdiff.luite.com/cgit/Hipmunk/tree/Physics/Hipmunk/Common.hsc?id=7575b7051ce58d75e26ca0920786657c86450f6c#n116
13:41:38 <fizbin> > .>
13:41:40 <lambdabot>   <hint>:1:1: parse error on input `.>'
13:42:02 <beaky> a turing-complete type system sounds like huge fun
13:42:17 <eikke> startling: there's lots of things you can 'prove' using haskell with some exts (thing gadts & tfs)
13:42:30 <startling> eikke, sure.
13:42:50 <DMcGill> beaky: I've seen factorial functions done in the type level before
13:42:57 <tomh__> luite: hmm, do you have any idea how I can force it to be a double? I just fixed it yesterday on my windows machine which makes it a double, and on my mac apparently it gets compiled to a float
13:43:03 <DMcGill> it's similar in principle to abusing compiler macros
13:43:12 <beaky> the one with Peano integers and stuff?
13:43:15 <DMcGill> yes
13:43:30 <startling> but you can't write things like "head is a function on a list provided compile-time proof that the list isn't empty" or whatever
13:43:34 <luite> tomh__: probably not a good idea to force it, unless you can also force the foreign part to do the same
13:43:40 <beaky> http://www.willamette.edu/~fruehr/haskell/evolution.html the static haskell programmer?
13:43:44 <startling> you can write head :: (a, [a]) -> a, but that's just fst
13:44:06 <Nisstyre-laptop> startling: can't you create type safe lists?
13:44:13 <tomh__> luite: any suggestion on how to make my code compatible on any choice of that type?
13:44:14 <Nisstyre-laptop> i.e. a type safe head
13:44:14 <eikke> startling: huh...
13:44:24 <startling> Nisstyre-laptop, you mean never-empty list? yeah.
13:44:40 <eikke> startling: https://gist.github.com/NicolasT/5373649
13:44:40 <Nisstyre-laptop> startling: obviously it'd have to be a new type
13:44:46 <beaky> where would haskell be without the glorious glasgow haskell compiler?
13:44:46 <startling> Nisstyre-laptop: (a, [a]) is essentially that, though
13:44:49 <eikke> wrote that for a colleague some days ago
13:44:54 <Nisstyre-laptop> startling: oh, yeah I guess
13:45:03 <eikke> its ocaml, not haskell, but the idea remains the same (in haskell it could even be *much* nicer)
13:45:19 <luite> tomh__: you can use realToFrac to convert between Float and Double
13:45:55 <tomh__> luite: yes but I need to either call or not call it depending on the type of CpFloat
13:46:15 <luite> tomh__: it will still work if it's Double -> Double
13:46:29 <tomh__> hmm ok
13:47:09 <luite> the compiler will probably optimize it away in that case (not sure, check the rewrite rules)
13:49:25 <tomh__> luite: so internally it might use GHC float2Double or so?
13:50:41 <luite> tomh__: yeah, GHC has float2Double# and double2Float# primops that will do the actual conversion
13:50:51 <tomh__> nice
13:51:03 <tomh__> thanks for your help, my project seems to start compiling :)
13:51:53 <luite> (only works if the types on both sides are monomorphic, otherwise it will have to do an expensive generic realToFrac)
13:52:18 <luite> = fromRational . toRational
13:53:33 <luite> hm, i hope i'm right here with the specialization, check the core to be sure :)
13:55:39 <tomh__> well my code seems to run :)
13:59:45 <dgpratt> tomh__: what did you expect, it compiled after all? :)
14:00:27 <tomh__> dgpratt: well I could've had performance problems for one
14:00:53 <dgpratt> tomh__: that's when the code runs...too much
14:01:01 <tomh__> well its a game :)
14:18:42 <neutrino> i've just found out about scala's extractor objects
14:18:45 <neutrino> :(
14:19:38 <c_wraith> They're kind of like view patterns, right?
14:20:07 <neutrino> no they're a crude approximation of haskell's pattern matching based on type constructors
14:20:31 <neutrino> http://www.scala-lang.org/node/112
14:20:56 <bitonic> neutrino: well scala already has a less crude approximation to pattern matching
14:21:04 <c_wraith> That looks more like view patterns
14:21:09 <bitonic> agreed with c_wraith
14:21:16 <c_wraith> It's pattern matching based on a function applied to the input
14:21:17 <neutrino> why is it like view patterns?
14:21:32 <neutrino> nope
14:21:53 <neutrino> notice that Twice is applied to n in the match
14:22:07 <neutrino> they're "unwrapping" n from Twice n
14:22:17 <bitonic> neutrino: it’s a smart destructor, instead of having the default behaviour of ‘case’
14:22:26 <bitonic> (‘case class’)
14:22:42 <neutrino> in haskell it would be something like this: let x = Twice 21, foo (Twice n) = n in foo x
14:23:00 <bitonic> neutrino: but you can already do that, ‘case class Twice(n: Int)’
14:23:34 <neutrino> can you show me some more code that uses what you said
14:23:53 <neutrino> like a complete functioning snippet
14:23:57 <bitonic> neutrino: <http://www.scala-lang.org/node/107>
14:23:58 * neutrino is only learning scala now
14:24:19 <neutrino> looking
14:25:11 <neutrino> ok i see
14:25:14 <neutrino> that's much better
14:25:27 <bitonic> neutrino: I think those ‘extractor’ are very useful actually
14:25:38 <neutrino> phew, i thought there's only this extractors only
14:25:42 <neutrino> bitonic: what would you use them for?
14:25:56 <bitonic> it’s somewhat against the principle of least astonishment but that’s the essence of scala
14:26:15 <neutrino> ?
14:26:22 <bitonic> neutrino: if you want to hide the internal representation of an object somewhat while still providing pattern matching
14:26:35 <bitonic> for the same reason that views are useful (although views are more flexible)
14:26:48 <neutrino> what are views?
14:26:52 <neutrino> viewpatterns?
14:27:01 <bitonic> neutrino: yes
14:27:06 <johnw> foo x (f -> Just y)
14:27:16 <johnw> here, the second argument to foo is passed to f, and the result matched on
14:27:36 <johnw> (this is in a function definition, not a call)
14:27:38 <neutrino> yes
14:27:41 <neutrino> right
14:27:43 <johnw> foo x (f -> Just y) = ...
14:28:02 <johnw> there are also pattern guards
14:28:03 <bitonic> neutrino: well actually it’s not a good comparison, since extractors work for objects—but still, it’s a way to have custom patterns
14:28:09 <pqmodn> is there a combinator already defined for flip (<*>) . pure -- eg, op where: f <$> effect `op` value == f <$> effect <*> pure value
14:28:11 <johnw> | Just y <- f x
14:28:13 <neutrino> i'm not sure how extractors are similar to view patterns though
14:28:48 <bitonic> neutrino: well, because it’s an instance of giving hints on how to ‘destruct’ something
14:29:08 <bitonic> although I’m noticing that extractors are for scala ‘object’s, so it’s a bit different
14:29:09 <neutrino> but in haskell you have that for free
14:29:10 <monochrom> pqmodn: no, I think there isn't
14:29:29 <bitonic> neutrino: well in Haskell you have the ‘obvious’ destructors for free
14:29:40 <neutrino> oh by the way guys
14:29:42 <pqmodn> monochrom: i find myself needing it often, but i couldn't find it. thanks
14:29:47 <neutrino> is there something like 4clojure.com but for haskell?
14:29:49 <startling> what's the way to derive (>>=) from join, again?
14:29:55 <bitonic> neutrino: but you might often want others, e.g. ByteString -> (Word8, ByteString)
14:29:55 <elliott> startling: you need fmap
14:30:00 <startling> elliot, aha
14:30:03 <elliott> startling: m >>= k = join (fmap k m)
14:30:08 <elliott> and join m = m >>= id
14:30:15 <startling> elliott: yeah, that's what I was missing. thanks!
14:30:20 <elliott> (>>=) is "join with a free fmap"
14:30:31 <elliott> liftM f m = m >>= \x -> return (f x)
14:30:45 <bitonic> neutrino: anyway Walder has explained much better than I’ll ever will why views are great.
14:30:55 <bitonic> I think some of it would apply to those extractors
14:31:02 <neutrino> Wadler?
14:31:05 <neutrino> ok go on
14:31:17 <neutrino> :)
14:31:26 <mauke> Where's Walder?
14:31:50 <madjestic> hey guys, is there a better way to express the following: http://hpaste.org/86038  ?
14:32:08 <bitonic> mauke, neutrino: sorry, Wadler :)
14:32:20 <arkeet> madjestic: not without more context
14:32:47 <monochrom> mauke is going for a joke on "where's Waldo?"
14:32:52 <johnw> @pl \f g h x y -> f (g x y) (h x y)
14:32:53 <lambdabot> (liftM2 ap .) . (.) . (.)
14:32:55 <madjestic> arkeet: more specifically:  I am mildly bothered by the repetition of the arguments
14:33:06 <hpaste> jfischoff pasted “Incremental logging” at http://hpaste.org/86039
14:33:10 <madjestic> (t, k) that is
14:33:15 <johnw> @pl \g h x y -> f (g x y) (h x y)
14:33:15 <lambdabot> liftM2 (liftM2 f)
14:33:16 <arkeet> madjestic: I would say the alternative is worse.
14:33:24 <neutrino> bitonic: so what did he say? i'm curious :)
14:33:25 <arkeet> in terms of readability.
14:33:31 <johnw> multIntTrees = liftM2 (liftM2 Node)
14:33:38 <arkeet> but you could do multIntTrees = (liftA2.liftA2) Node multLabels multIntSubForests
14:33:47 <bitonic> neutrino: see his paper on views, and there was also another one where they implemented something with views, can’t remember what...
14:33:56 <johnw> ah, that
14:34:00 <jfischoff> earlier I was told that I could use writert for incremental logging…. how?
14:34:10 <neutrino> bitonic: any idea what the gist was of why they were so cool?
14:34:11 <mauke> what are his views on views
14:34:20 <c_wraith> mauke: I think he can see them
14:34:27 <jfischoff> You can see my example paste for a clearer idea of what I want http://hpaste.org/86039
14:34:29 <bitonic> neutrino: ‘A view allows any type to be viewed as a free data type, thus combining the clarity of pattern matching with the efficiency of data abstraction.’
14:35:23 <bitonic> I’d also add ‘information hiding’ to ‘efficiency’
14:35:28 <madjestic> arkeet: johnw thanks
14:35:47 <jfischoff> preflex seen Tekmo
14:35:47 <preflex>  Tekmo was last seen on #haskell-lens 19 days, 2 hours, 2 minutes and 14 seconds ago, saying: I didn't need this after all
14:35:49 <arkeet> :t liftA2.liftA2
14:35:50 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
14:37:02 <jfischoff> @tell Tekmo How is it that pipes facilitate incremental logging without resorting to IO?
14:37:02 <lambdabot> Consider it noted.
14:40:07 * startling .oO ( instance Monad Something where m >>= f = join $ liftM f m )
14:40:49 <Eduard_Munteanu> @src liftM
14:40:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:41:18 <DMcGill> "data Obj = Obj {field :: Field}". Does that define "field :: Obj -> Field; field (Obj f) = f
14:41:18 <DMcGill> " or is it something different?
14:41:18 <DMcGill>  Surely that's the only sensible definition but I'd like to make sure
14:41:24 <quchen> Defining join in terms of liftM is a little circular.
14:41:28 <quchen> Eh, bind
14:41:51 <monochrom> you are right, DMcGill
14:41:57 <bitonic> DMcGill: well, it does bring that function in scope but it also does more (record patterns)
14:42:15 <neutrino> bitonic: what's a free data type?
14:42:15 <DMcGill> bitonic: yep, I'm ignoring that for now though
14:42:19 <Eduard_Munteanu> @src join
14:42:19 <lambdabot> join x =  x >>= id
14:42:27 <Eduard_Munteanu> Well, that's circular too.
14:42:44 <startling> quchen, yeah, it diverges
14:43:00 <bitonic> neutrino: I’d guess he means ‘algebraic data type’, but I can’t swear on that :)
14:43:14 <neutrino> gotcha
14:43:32 <jfischoff> Eduard_Munteanu: Can you see how to make WriterT stream the log results http://hpaste.org/86039?
14:44:06 <jfischoff> Eduard_Munteanu: or perhaps you thought I meant something else before (… perhaps it is still unclear)?
14:44:12 <quchen> startling: Eduard_Munteanu x >>= id isn't circular. Or did you mean something else?
14:44:30 <startling> quchen: I mean m >>= f = join $ liftM f m
14:45:29 <Eduard_Munteanu> jfischoff: not sure what you mean by incremental...
14:45:56 <Eduard_Munteanu> jfischoff: print there writes to stdout, tell logs to the Writer monad, they're totally different
14:45:56 <jfischoff> I want to see log messages as I log them
14:45:56 <quchen> startling: I can't tell how you came up with that by scrolling. I just saw bind defined in terms of liftM and my alarm went off ;-)
14:46:54 <Eduard_Munteanu> jfischoff: then   execWriter test >>= mapM_ putStrLn
14:47:01 <Eduard_Munteanu> Or something like that.
14:47:03 <jfischoff> Eduard_Munteanu: yes they are. But I would like to be able to model my logging in a pure way and have it run in an impure streaming way later
14:47:24 <Eduard_Munteanu> :t execWriter
14:47:25 <lambdabot> Writer w a -> w
14:47:31 <Eduard_Munteanu> :t execWriterT
14:47:32 <lambdabot> Monad m => WriterT w m a -> m w
14:48:01 <startling> I kind of want * such that f $ a * b in analogy to f <$> a <*> b
14:48:33 <shachaf> (*) = ($)?
14:48:34 <Eduard_Munteanu> startling: just a left-associative ($)?
14:48:44 <shachaf> I think you would want to make $ infixl first.
14:48:58 <quchen> shachaf: That sounds like an excellent idea.
14:49:16 <startling> I mean, f $ a $ b as it exists is f (a b)
14:49:26 <startling> Eduard_Munteanu: yeah
14:49:45 <shachaf> Making * an infixl $ won't help you. $ itself would have to be infix
14:49:45 <shachaf> l
14:49:53 <startling> oh
14:50:12 <Eduard_Munteanu> shachaf: well you need it for  f $ a * b * c
14:50:33 <Eduard_Munteanu> Should parse as   ((f $ a) * b) * c
14:50:53 <shachaf> Right.
14:51:21 <elliott> really, it should be something like f $> a <$> b
14:51:26 <elliott> with a consistent operator naming scheme.
14:51:32 <elliott> and then the equivalent would just be f $ a $ b with infixl $
14:52:49 <startling> true.
15:01:52 <mvb> does TCP send a stream of bytes or bits?
15:02:23 <DanBurton> "yes"
15:02:23 <kayloos_> How can I write this without the lambda-abstraction (and without do-syntax): readFile path >>= (\x -> return $ pack x)
15:02:24 <shachaf> Bytes (in particular octets).
15:02:47 <quchen> Is a building meters or centimeters high? :s
15:03:09 <arkeet> yes
15:03:21 <Chousuke> kayloos_: fmap pack $ readFile path ?
15:03:36 <shachaf> I think mvb's question, while not particular on-topic in here, isn't as silly as y'all make it to be.
15:03:39 <DanBurton> @pl readFile path >>= (\x -> return $ pack x)
15:03:39 <lambdabot> pack `fmap` readFile path
15:04:19 <arkeet> TCP sends IP packets.
15:04:20 <stepkut> is there a tool that will statically look at some source code and report all the functions and types that are never used?
15:04:36 <quchen> stepkut: Compile with -Wall?
15:04:50 <quchen> ==> "Warning: unused ..."
15:04:50 <cmccann> -Wall won't complain about unused stuff that's exported
15:04:59 <kayloos_> Chousuke: ah, that's nicer, thanks. Time to learn a bit about fmap
15:05:01 <stepkut> quchen: not good enough, that only works on a per module boundary.. if a function is exported it is considered used
15:05:12 <arkeet> :t fmap
15:05:12 <quchen> Ah, I see.
15:05:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:05:20 <cmccann> stepkut: if that tool doesn't exist it should
15:05:21 <Chousuke> kayloos_: Functors are fun!
15:05:23 <arkeet> kayloos_: this is all you need to know, kind of.
15:05:29 <monochrom> it is either a silly question or a false dichotomy. you decide. but TCP packets have lengths being multiples of 8 bits. so, it's suitable to say "byte".
15:05:36 <arkeet> :t \f -> return . f
15:05:39 <lambdabot> Monad m => (a -> b) -> a -> m b
15:05:41 <arkeet> er
15:05:44 <stepkut> quchen: i want that but even more aggressive.. if a function is not reachable via main, then it should be purged
15:05:46 <arkeet> :t \f -> (>>= return . f)
15:05:47 <kayloos_> arkeet: what do you mean?
15:05:48 <lambdabot> Monad m => (a -> b) -> m a -> m b
15:05:54 <arkeet> this is liftM.
15:05:57 <arkeet> but liftM is fmap.
15:06:01 <stepkut> or at least reported as a possible purge candidate
15:06:03 <shachaf> monochrom: What is the first bit of the byte stream [0xf0]?
15:06:15 <monochrom> I don't know
15:06:16 <stepkut> I have a project here that is several years old and contains a bunch of dead code
15:06:35 <monochrom> but my ethernet wire knows
15:06:45 <shachaf> No one knows.
15:06:53 <shachaf> Therefore a stream of bytes is not a stream of bits.
15:07:30 <DanBurton> jfischoff: regarding what you were asking earlier.. I don't see how you can perform IO (write to the screen) without performing IO
15:07:44 <kayloos_> arkeet: ok, thanks
15:07:56 <jfischoff> DanBurton: agreed. I just wanted to model it in a pure way
15:08:07 <jfischoff> and swap out an impure method later
15:08:16 <monochrom> I am not going bother to argue, and just say fine, you're right. but this reminds me of an event in a Chinese novel.
15:08:21 <arkeet> kayloos_: intuitively, fmap lets you change the result of an action by a function.
15:08:28 <arkeet> well, not just intuitively.
15:08:37 <jfischoff> My point was I can't see how to use WriterT to do that
15:09:38 <DanBurton> I don't quite get what you want, though. What do you expect of this "pure model"?
15:09:53 <monochrom> 4 persons met, did something, and sworn to keep it secret. but one of them was shrewd. his exact oath was, "I will not tell it to the 5th person".
15:10:16 <cmccann> jfischoff: use ReaderT and give it a function "writeToLog :: LogData -> m ()"
15:10:29 <cmccann> jfischoff: then give it whatever you want
15:10:32 <monochrom> some time later, he told the secret to about a hundred people at a convention. his defense, "who is the 5th person? point it out."
15:10:34 <jfischoff> cmccann: interesting
15:10:46 <jfischoff> yes that is more what I want
15:10:51 <Eduard_Munteanu> Hm...
15:10:57 <cmccann> jfischoff: note that code polymorphic in choice of monad is pure because you can make it use Identity
15:11:13 <jfischoff> yes
15:11:16 <cmccann> (in which case the log output would be discarded here)
15:11:29 <jfischoff> closer
15:11:56 <monochrom> this is why I disbelieve in intuitionistic logic. it allows such criminals to cheat.
15:12:09 <Eduard_Munteanu> jfischoff: um, doesn't what I told you work?
15:12:19 <jfischoff> oh I didn't see
15:12:28 <monochrom> the 5th person clearly exists. the 1st bit clearly exists. I can't point them out, but they exist.
15:12:38 <Eduard_Munteanu> monochrom: interesting
15:13:05 <cmccann> monochrom: you could be an ultrafinitist, and deny that all of the hundred people exist instead
15:13:13 <monochrom> haha
15:13:28 <DanBurton> monochrom: clearly, it first hit the person's eardrums that sat nearest to the speaker at the time of revelation
15:14:20 <monochrom> well yeah, but the novel was set in 600 years ago or something. simultanity was assumed.
15:14:52 <jfischoff> Eduard_Munteanu: do you mean execWriterT test >>= mapM ...?
15:15:00 <Eduard_Munteanu> jfischoff: yeah
15:15:22 <jfischoff> no that doesn't work
15:15:42 <jfischoff> it still will only show the log when WriterT finishes
15:15:51 <Eduard_Munteanu> Hm.
15:15:52 <shachaf> monochrom: That person sounds obnoxious. Are you trying to hint that my argument is obnoxious?
15:15:59 <jfischoff> which is no good
15:16:00 <monochrom> haha
15:16:35 <monochrom> I am poking holes at intuitionistic logic and its practical consequences.
15:16:52 <jfischoff> I want to have an impure evaluation, evaluates the logs incrementally
15:17:05 <monochrom> despite how I like its beautiful Kripke semantics
15:17:07 <jfischoff> evaluates the message to log
15:17:31 <cmccann> jfischoff: would a monad like "(a -> [LogData] -> [LogData]) -> [LogData] -> [LogData]" do what you want for pure log output?
15:17:44 <cmccann> that will handle incremental processing of the list for both input and output
15:17:58 <Eduard_Munteanu> I thought Writer would have worked. :/
15:18:04 <Eduard_Munteanu> Not sure what the problem is.
15:18:04 <cmccann> which you don't need but anyway
15:18:59 <jfischoff> cmccann: not sure...
15:19:54 <beaky> are FSMs monoids?
15:20:05 <beaky> I mean monads*
15:20:19 <cmccann> jfischoff: the free monad for "(,) LogData" should also work
15:20:34 <cmccann> or something along those lines
15:21:03 <jfischoff> how would I integrate that into my mtl monad transformer stack?
15:21:04 <mvb> the question was does TCP send a stream of bytes OR bits? meaning it sends a stream of bytes right? 1 byte at a time. not 1 bit at a time
15:21:35 <sproingie> bytes are made of bits
15:21:46 <tgeeky> tcp sends a stream of packets
15:21:46 <sproingie> as TCP is concerned, it sends whole packets at a time
15:21:51 <tgeeky> neither bites nor bits
15:22:22 * Eduard_Munteanu bites tgeeky 
15:22:35 <Tene> mvb: TCP packets contain octets.
15:22:43 <erisco> I followed the lakseh directions for hello world and on the step where I build the package, nothing happens
15:22:55 <Tene> The length header specifies the data length in octets
15:22:56 <mvb> and a apcket could contain at minimum a byte(not a bit) and at maximum the whole message length nbr of bytes?
15:23:01 <sproingie> TCP gets wrapped in IP which gets wrapped in a link layer frame which gets transmitted over physical layer
15:23:12 <sproingie> minimum length for a tcp packet is 0
15:23:15 <Tene> mvb: That's accurate.  Check the RFC for confirmation
15:23:22 <sproingie> it'll just take a lot of bytes to say nothing
15:23:33 <Tene> http://www.ietf.org/rfc/rfc793.txt
15:23:44 <cmccann> if you look deep enough I think you will find that TCP sends a stream of electrons
15:23:45 <erisco> is there a more stable and functional IDE for haskell?
15:23:45 <Eduard_Munteanu> Maximum is enforced by the MTU.
15:24:17 <sproingie> cmccann: which is really a stream of electron potential difference pulses
15:24:22 <sm> erisco: you could try EclipseFP
15:24:28 <sproingie> only thing throwing electrons around is a crt tube
15:24:47 <cmccann> true
15:25:08 <cmccann> jfischoff: anyway I'm not sure about your specific case, just suggesting a couple things if Writer doesn't work for whatever reason
15:25:08 <jfischoff> cmccann: Pipe's Proxies seem to do the trick
15:25:20 <sproingie> cmccann: though that whole wave/particle thing does make it all pretty handwavey
15:25:22 <monochrom> it is interesting how people clarify their questions by merely making a few words bold or uppercase.
15:25:23 <jfischoff> yeah WriterT is not what I need
15:25:25 <sproingie> or is that handparticly
15:27:33 <cmccann> jfischoff: pipes is basically a much much fancier version of my "free monad of (,) LogData" suggestion
15:27:45 <cmccann> at least the original version was, I'm not sure what it looks like these days
15:28:03 <jfischoff> cmccann: the base types are similar
15:30:43 <hpaste> DanBurton pasted “Logger, with personalized interpretation” at http://hpaste.org/86046
15:31:15 <DanBurton> ^ here's a hand-written monad transformer that gives you the "tell" command, and lets you interpret it however you desire
15:31:53 <jfischoff> DanBurton: thanks that's awesome
15:32:40 <cmccann> ooh, fancy lambda case use
15:32:46 <Eduard_Munteanu> Weird that Writer doesn't do, and it doesn't seem related to IO.
15:33:22 <DanBurton> cmccann: Having written code with this free monad library before, I have been craving lambda case for this exact use case
15:33:57 <jfischoff> DanBurton: what do you think, that Logging transformer or use the Pipe library?
15:34:33 <jfischoff> I guess I would add the mtl instances ...
15:34:33 <DanBurton> jfischoff: it entirely depends on you. /shrug
15:34:49 <cmccann> that Logger is sort of a subset of what pipes does anyway
15:34:55 <jfischoff> yes
15:35:06 <jfischoff> DanBurton: but what would you do?
15:35:50 <DanBurton> jfischoff: I still don't feel like I have a good idea in my head of your situation, so I really don't know. My gut reaction is that pipes might be overkill for such a simple feature.
15:36:19 <DanBurton> But pipes is well-maintained and optimized
15:36:28 <cmccann> DanBurton: btw, your current avatar on SO keeps distracting me because you look so different from the old one :P
15:37:06 <DanBurton> cmccann: lol. I don't feel all that different. Well ok, maybe I do.
15:37:38 * cmccann agrees that "reinventing a very simple wheel" vs. "using a well-maintained but complex wheel" is the basic choice here
15:39:23 <jfischoff> I imagine the extra work for the LoggerT would be to make mtl instances and perhaps use Codensity to improve things…but I don't know enough to say if that is relevant
15:39:55 <cmccann> I'd probably use the hand-rolled version for a quick hack but something better-maintained for a long-term solution
15:41:26 * hackagebot herbalizer 0.4.8 - HAML to ERB translator  http://hackage.haskell.org/package/herbalizer-0.4.8 (DanielChoi)
15:41:41 <DanBurton> "Logging" is pretty enterprise-y, you'd think that there would be something up on hackage for that. Isn't there?
15:42:44 <johnw> hslogger
15:42:48 <johnw> that's what I use
15:43:02 <johnw> i'm pretty sure it's just unsafePerformIO under the hood, though
15:43:36 <erisco> sm, I'll give it a try. Not a fan of eclipse (too sluggish) but it may be the best available
15:43:43 <jfischoff> DanBurton: The ones I've seen assume that you are in IO
15:44:21 <DanBurton> Yeah that's weird. You'd think they would generalize and let you run it in a pure scenario.
15:45:29 <jfischoff> DanBurton: Not that weird when you remember it is enterprisy
15:46:46 <elliott> johnw: hm, hslogger is unsafe?
15:47:41 <johnw> elliott: i'm not sure what you mean by unsafe?
15:47:50 <elliott> well, you said it's just unsafePerformIO :)
15:47:56 <elliott> does it let pure code do "logging" or something?
15:48:21 <johnw> oh, maybe not, it's all in IO
15:54:56 <cmccann> logging pure code is not entirely sensible anyway
15:55:25 <jfischoff> cmccann: ?
15:55:39 <jfischoff> Writer?
15:56:27 <cmccann> I mean "unsafe" logging, not something explicit like that
15:56:52 <cmccann> Debug.trace for debugging is one thing but that's not really a sane way to do meaningful logging
15:57:05 <jfischoff> ah
15:57:28 <jfischoff> yeah not the write solution monitoring live applications
15:57:52 <dacto> Is there a map that maps a value over a list of functions? I know of: zipWith ($) functionList valueList.
15:59:29 <monochrom> > map ($ 0) [sin, cos, exp]
15:59:30 <lambdabot>   [0.0,1.0,1.0]
16:00:01 <Nisstyre-laptop> > sequence [sin,cos, exp] 0
16:00:03 <lambdabot>   [0.0,1.0,1.0]
16:00:29 <monochrom> map ($ 0) [sin, cos, exp] = [sin 0, cos 0, exp 0]
16:00:55 <startling> Nisstyre-laptop: heh
16:01:09 <dacto> ahhh thank you both
16:01:27 <startling> using sequence requires import Control.Monad.Instances though
16:01:32 <Nisstyre-laptop> yeah
16:01:36 <shachaf> Not anymore!
16:01:39 <Nisstyre-laptop> oh?
16:01:44 <startling> shachaf: since when? 7.6?
16:01:48 <shachaf> I guess.
16:01:52 <startling> neat.
16:01:59 <Nisstyre-laptop> yeah it's in Prelude here
16:11:59 <trescenzi> Ok so I need a single Int that has state or something that keeps track of an integer value that can change. What's the easiest way to do that?
16:12:12 <jfischoff> @tell Tekmo I figured it out
16:12:12 <lambdabot> Consider it noted.
16:14:01 <ParahSail1n> @hoogle stref
16:14:01 <lambdabot> Data.STRef module Data.STRef
16:14:02 <lambdabot> Data.STRef data STRef s a
16:14:02 <lambdabot> Data.STRef.Lazy data STRef s a
16:15:51 <byorgey> trescenzi: the easiest way is to write a recursive function which passes the current Int value as a parameter.
16:16:04 <byorgey> every time you make a recursive call you can specify a new Int value.
16:16:27 * hackagebot statistics 0.10.3.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.3.1 (BryanOSullivan)
16:16:54 <trescenzi> byorgey: yea I've done that. I need it to know that it's made a call previously though which is my issue really.
16:17:15 <trescenzi> Like after it returns I need to change the value stored within the parent call to know that a call has been made
16:17:59 <byorgey> trescenzi: OK. then you might be interested in using the State monad.
16:19:05 <trescenzi> byorgey: Alrighty I'll take a look into that. Is it possible to have only a single monadic value within a function? like String -> m Int -> String and only the Int is touched by State?
16:19:44 <byorgey> trescenzi: no, that doesn't make sense
16:20:05 <byorgey> trescenzi: the  'm Int'  doesn't mean that the Int is stateful.
16:20:19 <byorgey> instead you probably want a type like   String -> State Int String
16:20:41 <byorgey> which means it is a function from String to String, but it also has access to a mutable state of type Int
16:20:47 <trescenzi> byorgey: ok and State will keep track of things to the int?
16:20:52 <byorgey> right
16:20:53 <trescenzi> ok makes sense
16:20:55 <trescenzi> thans
16:21:20 <Peaker> trescenzi, what are the values you put in that Int to signify "call already made"?
16:21:35 <trescenzi> oh it just goes up by one Peaker
16:22:02 <Peaker> trescenzi, where do you read that Int?
16:22:08 <trescenzi> so a single parent could call a function an arbitary number of times and I need to know how many times that call has been made
16:22:14 <trescenzi> in the parent
16:22:37 <Peaker> trescenzi, it is possible you could use the Writer monad instead of State, which can have nice side effects
16:23:46 <Peaker> trescenzi, Writer lets you output "to your parent" without letting you send values inside children or between sibling calls -- this makes sibling calls independent allowing more optimizations to take place, opportunity for parallelism, etc
16:24:30 <trescenzi> Peaker: Ahh ok. That's pretty cool. I'll look at both of them and see which works out better
16:24:40 <Peaker> State s a = (s -> (s, a))   whereas if the child never reads the "s", but only increments it, it can be modeled instead by:   Writer w a = (w, a),  where your w = Sum Int
16:25:05 <Peaker> trescenzi, take a look at Data.Monoid.Sum, Writer, Writer.tell, Writer.listen
16:25:07 <shachaf> I,I w = [()]
16:25:21 <Peaker> ?
16:25:48 <shachaf> Another counting monoid.
16:27:22 <trescenzi> shachaf: oh yea that could work. I could cheat by building a list that gets larger everytime lol
17:14:58 <sirspazzolot> what would be a good starting point for learning about functional programming? would it be advisable to learn by applying functional concepts to a language I already am familiar, or should I try to pick up haskell fresh?
17:15:26 <sirspazzolot> (books are welcome suggestions, not much else to spend my high school graduation money on)
17:15:56 <BMeph> sirspazzolot: Yes. :)
17:15:59 <skyflash> sirpazzolot:IMHO... Haskell fresh
17:16:10 <typoclass> @where lyah
17:16:10 <lambdabot> http://www.learnyouahaskell.com/
17:16:13 <Eduard_Munteanu> Wouldn't work if you don't already know a functional language, really.
17:16:24 <typoclass> sirspazzolot: have a look at lyah! it's a good book and it's free
17:16:49 <skyflash> +1 on LYAH
17:17:52 <sirspazzolot> Eduard_Munteanu: what wouldn't work? lyah?
17:17:54 <typoclass> sirspazzolot: oh, and rwh is also a possibility :-)
17:17:56 <typoclass> @where rwh
17:17:57 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:18:15 <Eduard_Munteanu> sirspazzolot: trying to apply certain FP concepts to say, C.
17:18:20 <BMeph> sirspazzolot: (answering for Eduard_Munteanu) " to learn by applying functional concepts to a language I already am familiar"
17:19:20 <sirspazzolot> oh. okay. I had python in mind since as I understand, it supports lambdas otb
17:19:34 <cmccann> python is not very good as a functional language
17:20:01 <skyflash> If you _really_ want to learn functional programming then I'd suggest going to a place where it exists in a pure form :-)
17:20:05 <cmccann> it supports a few things but it's really not designed to make use of functional style to any large extent
17:20:34 <Eduard_Munteanu> Also, yeah, what skyflash says.
17:20:45 <sirspazzolot> I know, my concern was I'd get lost if I were fully immersed in functional programming stuff. I'll check out these books for sure!
17:21:07 <skyflash> I think you'll be pleasantly surprised with LYAH
17:21:10 <cmccann> jumping in the deep end is an effective way to learn how to swim
17:21:19 <typoclass> sirspazzolot: my suggestion is, give haskell a try :-) it's definitely strong coffee, but it'll make you a better programmer no matter what language you end up using in your job
17:21:25 <sirspazzolot> (I'll be able to handle it, right? basic competence in javascript, java, python and php)
17:21:33 <typoclass> cmccann: also, effective way to drown
17:21:38 <sirspazzolot> haha
17:21:39 <cmccann> especially with LYAH, which is like a cheerful brightly colored floatation device to keep you from drowning immediately
17:21:48 <sirspazzolot> really liking the website for lyah
17:22:03 <sirspazzolot> particularly the sun in the corner: "Holy shit!"
17:22:14 <cmccann> if you like LYAH's style it's very good
17:22:48 <cmccann> some people are put off by it for various reasons
17:23:19 <typoclass> cmccann: they should have their heads examined. how anyone be against an elephant wearing glasses
17:23:32 <cmccann> some people are very peculiar
17:24:14 <typoclass> sirspazzolot: you noticed that lyah is available online, right? you just need to click "read it"
17:24:29 <sirspazzolot> yessiree
17:25:09 <sirspazzolot> for future reference, is it pronounced HAS-kull?
17:25:21 <byorgey> yes
17:26:30 <hpaste> Lovish pasted “Rotate” at http://hpaste.org/86053
17:27:00 <cmccann> Haskell is pronounced in whatever way you hope is least likely to have people think you said "Pascal" instead
17:27:31 <byorgey> keeping in mind that people will think you said "Pascal" anyway
17:27:32 <Eduard_Munteanu> It might help to start pronouncing Pascal the way it's meant to. :)
17:27:32 <mewtwo> Hi.Please help me counter the run time error log for http://hpaste.org/86053
17:27:49 <cmccann> byorgey: hence the "hope" part, yes
17:28:43 <Mortchek> I did that once. Was talking about functional programming to someone who was a CS student in the 70s. Turned out we didn't relate very well :P
17:29:18 <Mortchek> By "did that", I mean pronounced Haskell in such a way that she thought I said Pascal
17:29:25 <Mortchek> though to be fair there was loud music in the background
17:29:32 <skyflash> The only thing I've found in many years of watching 'regular' (procedural, OO) devs try to get a handle on Haskell is that it has been couched in technical/mathematical jargon.
17:29:36 <sproingie> eddie haskell from leave it to beaver, pronounced exactly like that
17:29:40 <sproingie> minus the eddie
17:29:45 <cmccann> haha
17:29:57 <skyflash> I think the LYAH approach has been a breath of fresh air in that sense
17:30:14 <sproingie> the irony is that according to Haskell Curry's own wife, he never liked his first name
17:30:31 <hpc> her name wasn't much better
17:30:31 <Mortchek> I was born in the 90s, so that doesn't help me much :P
17:30:35 <hpc> "Virginia Curry"
17:30:45 <orzo> I have some code that uses Data.Sequence.Seq that I wanted to generalize a bit so that I could experiment with other data structure performance.  I notice that I do a foldr1 mplus on a sequence of sequences.  That requires Foldable, but the operation itself stays inside the monad, so can I do that avoiding foldable?
17:30:47 <typoclass> skyflash: i agree. i feel the jargon, and generally the state of our haddocks, is definitely a weakness of haskell
17:31:02 <hpc> skyflash: my advice is to use javascript as their gateway drug
17:31:05 <hpc> (yes, i am serious)
17:31:23 * Mortchek is a function JavaScript programmer
17:31:26 <Mortchek> functional*
17:31:30 <hpc> javascript is such a horrid API for what browsers need that to do much of anything you are already doing CPS like crazy
17:31:57 <darinmorrison> typoclass: what do you replace the jargon with?
17:32:02 <cmccann> hpc: tedious manual CPS transform as a programming paradigm was invented by node.js, right
17:32:02 <hpc> and when you are doing that, it's a fairly natural step from there all the way to monads
17:32:29 <hpc> "you mean i can leave out all the .apply(function(){})?!?"
17:32:43 <mewtwo> Hi.When I run this http://hpaste.org/86053. I am getting "user error (Pattern match failure in expression at test.hs : 12:5-11)".Please help me out.
17:32:54 <typoclass> darinmorrison: clearer wording :-/ easier said than done, i know
17:33:21 <typoclass> mewtwo: hello. the 'pattern match failure' happens for example when you do "(Just x) <- f", and f gives back a Nothing
17:33:27 <cmccann> I have yet to see any attempt to improve Haskell's jargon that didn't make things much worse
17:33:59 <Mortchek> Haskell's jargon is improving slightly - it's infect the other languages with monads
17:34:02 <Mortchek> infecting*
17:34:02 <cmccann> replacing arcane but precise jargon with deceptively familiar and imprecise jargon is not an improvement in any way
17:34:03 <darinmorrison> typoclass: I don't think that really helps. The jargon has precise meaning. You can teach the concepts underlying the jargon, but eliminating it and replacing it with wordy/imprecise alternatives is not really a solution.
17:34:10 <hpc> cmccann: i honestly have yet to see where haskell's jargon is even worse than other languages
17:34:10 <Eduard_Munteanu> cmccann: we clearly need to look at C++1X stuff and import those names
17:34:13 <elliott> it's almost as bad as java's jargon. i'll take zygohistomorphisms over virtual abstract superclass inheritance method generics
17:34:15 <cmccann> hpc: that too
17:34:20 <Eduard_Munteanu> Like ...  concepts!
17:34:26 <hpc> like "jvm trampoline" or design patterns
17:34:34 <hpc> that's a whole damn rat's nest right there
17:34:38 <cmccann> the whole programming industry is steeped in stupid and confusing NIH jargon
17:34:52 <Eduard_Munteanu> Trampolines are rather old, non-Java specific jargon.
17:34:59 <cmccann> if people don't like haskell borrowing existing jargon from math they can cry me a river frankly
17:35:20 <hpc> Eduard_Munteanu: but it was never needed until the jvm because assembly could do tail calls
17:35:36 <darinmorrison> you don't ask mathematicians or physicists to stop using jargon, why should functional programmers/CS-folk have to?
17:35:46 <Mortchek> Don't Lisp implementations do trampolining?
17:36:02 <Eduard_Munteanu> Mm, tail-calls aren't all they do.
17:36:23 <typoclass> mewtwo: i don't know why the error message mentions line 12; i suspect that the problem is really in line 10, meaning that getArgs did not return a list of length 1, or that the problem is in line 11, meaning runIL $ readImage did not reaturn an (RGB v) but something else
17:36:24 <startling> Mortchek: not necessarily
17:36:30 <Eduard_Munteanu> They're also used for JIT-ing.
17:37:11 <Mortchek> I don't mean as a matter of necessity, I mean whether it's a thing that is done by a number of things in that class
17:39:51 <typoclass> cmccann: i bet there's java people who are saying the same :-) "if they don't understand our AbstractVisitorAbstractFactory, then frankly they can cry me a river"
17:40:03 <mewtwo> typoclass : The error shows up when I am inputting BMP image.When i input it JPG it works well.
17:40:07 <Cale> Mortchek: Though, there's no language which is more popular than Haskell and which supports monads well enough to bother mentioning the abstraction.
17:40:35 <cmccann> typoclass: the difference is that in our arcane concepts are used to make programs simpler, not more complicated :P
17:41:02 <cmccann> anyway, most of the usual design patterns are actually pretty simple once you strip out all the pointless OOP cruft
17:42:01 <Mortchek> True, monads feel kind of empty to me without the strict typing
17:43:43 <skyflash> On the 'jargon' thing.  I don't think the issue is the jargon, per se, but rather it has been the lack of any bridge between Haskell-y things and names/things that regular developers understand well.
17:43:53 <typoclass> darinmorrison: i don't think the choice is between jargon an "wordy imprecision". for instance, consider Maybe = Nothing | Just. this is admirably clear. i don't think there's any problem with precision or wordiness at all
17:43:54 <darinmorrison> typoclass: If they can point to good mathematical explanation for that, I'd be okay with it.
17:44:05 <jpaugh> At least Haskell jargon isn't arbitrary: Monad means something to more than just programmers.
17:44:39 <darinmorrison> typoclass: yes, but try explaining Monads or something more complex like that. It doesn't really work.
17:44:48 <orzo> is there a function like foldr1 except that it stays inside a monad.  It would have type (m a -> m a -> m a) -> (m (m a)) -> m a
17:44:51 <orzo> ?
17:44:52 <skyflash> Also, I have a sneaky suspicion often that some 'explanations' of the jargon are just vehicles for the recently enlightened to prove that they can also use the jargon.  If you see what I mean.
17:45:00 <typoclass> skyflash: yes, exactly. i feel it's largely an issue of the text on the haddock page, not so much the type name itself
17:45:20 <sw2wolf> @djinn (m a -> m a -> m a) -> (m (m a)) -> m a
17:45:21 <lambdabot> -- f cannot be realized.
17:45:48 <darinmorrison> skyflash: I think there is probably an element of that (overuse). But a lot of it seems to be math-phobia or whatever. There's this attitude that people using jargon are trying to be language snobs or something. At least I've encountered that before.
17:45:51 <shachaf> sw2wolf: If you have a question you are allowed to ask it without using lambdabot. :-)
17:46:10 <Mortchek> I think the main reason Monad is hard is because it's really abstract. Abstract thinking can be hard.
17:46:13 <orzo> it was my question, shachaf.
17:46:18 <sipa> :t const join
17:46:20 <lambdabot> Monad m => b -> m (m a) -> m a
17:46:21 <sw2wolf> shachaf: it is orzo's question
17:46:23 <cmccann> :t foldrM
17:46:25 <lambdabot>     Not in scope: `foldrM'
17:46:25 <lambdabot>     Perhaps you meant one of these:
17:46:25 <lambdabot>       `Data.Foldable.foldrM' (imported from Data.Foldable),
17:46:27 <shachaf> Oh, whoops.
17:46:29 <cmccann> :t Data.Foldable.foldrM
17:46:30 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
17:46:46 <skyflash> darinmorrison: yes.  The least that can be said about it is that it's a barrier to entry.  You can make the barrier appear bigger or smaller for sure.
17:47:18 <orzo> Foldable is too steep a requirement, I want a semifoldable that lets me do inside folds
17:47:33 <orzo> You know what i mean?
17:47:51 <orzo> I want to require a foldr1 with the type he asked lambdabot for
17:48:07 <orzo> i'm wondering if the interface/pattern already exists
17:48:26 <sirspazzolot> so now I've got a dilemma: c first or haskell first?
17:48:43 <cmccann> orzo: I'm not sure what you intend it to do, to be honest
17:48:56 <sirspazzolot> (err, next, not first)
17:49:36 <sw2wolf> :t join
17:49:37 <cmccann> orzo: repeat the (m (m a)) action to get (m a) actions that it feeds to the function? where would it stop?
17:49:37 <lambdabot> Monad m => m (m a) -> m a
17:50:02 <darinmorrison> skyflash: I think what could help is to have a good place to point to for the kind of mathematics you need to understand more advanced type theory concepts. Wikipedia is too inconsistent in quality and nlab is a bit too advanced for intro topics. Though there are several pages on the haskell wiki that do some of that.
17:51:18 <byorgey> sirspazzolot: Haskell, naturally
17:51:48 <orzo> cmccann: I have in mind an STRef-based linked-list container.  The line I want to replace is a (foldr1 mplus) of a sequence of sequences.  It doesn't seem right to require Foldable when I'm staying in the monad there and Foldable (toList obviously) would be a problem for  my STRef based idea
17:51:49 <skyflash> darinmorrison: That could help.  I also find though, that people don't have to be hit with the full awesome nature of everything at the beginning.
17:52:26 <typoclass> darinmorrison: if the mathheads had gotten to Maybe in time, they'd have used the names SchinkelBimbachSet = Omicron | Unitarity, saying "no but that is what this *really is*" and "it's just complex, you can't explain this any easier". we would then have tons of schinkel-bimbach tutorials, there would be great mystery, beginners being intimidated, and it'd add to the reputation of haskell being incomprehensible and impractical
17:52:42 <cmccann> orzo: ah, hm. no idea if that exists, then.
17:52:57 <Cale> sirspazzolot: Haskell, unless there's something you really want to work on which is written in C. There's no problem at this point which I would actually start a new project in C for. It's too high level for low-level stuff, LLVM is typically better as a compiler target, and it's too low level for most applications.
17:53:19 <typoclass> darinmorrison: and i agree that it'd be a great help if we had a glossary or some such where you can look things up
17:53:24 <skyflash> I've explained monoid to people more times by simply using string concatenation an an example.  Of course, it's more general, but if you can get them past the name, then you at least have a start and a point to return to when they're ready for more.
17:53:43 <applicative> whoa augustss is logged on
17:53:52 <Cale> darinmorrison: Pierce's Types and Programming Languages is a good place to start
17:53:59 <sw2wolf> @hoogle sequence
17:54:00 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:54:00 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
17:54:00 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
17:54:06 <Hafydd> Maybe is a type, not a type class.
17:54:07 <darinmorrison> typoclass: I think you're exaggerating that a bit. Even in the cutting edge stuff people are doing (say with HoTT) you don't see anything quite that insular
17:55:09 <typoclass> skyflash: i'd argue that this is how almost all people learn. you go from the concrete (string concatenation) to the abstract
17:55:27 <orzo> I don't see why you shouldnt learn both haskell and c simultaneously
17:55:32 <skyflash> typoclass: exactly
17:55:35 <orzo> go back and forth
17:55:36 <applicative> you go from several concrete illustrations to the abstract
17:55:42 <sirspazzolot> orzo: I barely have the attention span for one book
17:55:48 <sirspazzolot> B)
17:56:05 <orzo> I suspect C is simpler
17:56:11 <sirspazzolot> in any case though I'm in the middle of a python project I should probably finish.
17:56:23 <orzo> to learn
17:56:26 <Cale> C is "simpler" in the sense that it's perhaps easier to write a C compiler than a Haskell compiler.
17:56:36 <Cale> But it's harder to actually use.
17:56:43 <Cale> Even for simple things.
17:56:45 <darinmorrison> Cale: yeah, it's not bad. That's what I started with anyway. I kind of prefer Harper's book now though.
17:56:54 <sirspazzolot> my first language was c++ so I'm already familiar with the syntax and I probably remember things like pointers
17:57:07 <sirspazzolot> but this was four years ago when I was thirteen, and I've done barely anything with it since then
17:57:24 <applicative> oh you are liking harpers book darinmorrison ?
17:57:25 <sirspazzolot> I suspect c would be easier for me to pick up; familiar syntax and familiar paradigms
17:57:32 <jpaugh> You probably already know C, then. I learned it by osmosis.
17:57:46 <byorgey> sirspazzolot: and that's exactly why you should learn something else instead.
17:57:59 <sirspazzolot> ... fair point.
17:58:14 <jpaugh> Too many languagues/programs are based on C not to learn it by accident.
17:58:16 <applicative> for some reason harper's indifference to elegant notation makes the book extremely irritating to me
17:58:26 <darinmorrison> applicative: yes. I've been recommending it for awhile now, even as a draft. I like the presentation and topic coverage better. TAPL is still useful though for the programming exercises.
17:59:04 <applicative> tapl is nice, too much on e.g. oo things if I remember
17:59:36 <sirspazzolot> haha yeah I suppose that's true. and I still write java all the time which as I understand is not the furthest thing from c syntactically
17:59:39 <darinmorrison> applicative: you mean the use of concrete syntax? Otherwise (for general formulas) and the type-setting and font and stuff, I like it much better.
17:59:42 <typoclass> darinmorrison: i dunno. i did make up the obscure names to be clear what my point is, and for comedic effect. i'll give you that. but if something is insular or not is a matter of perspective. i can easily imagine that phds who worked on schinkel-bimbach sets find it all very natural and not insular at all
17:59:44 <Eduard_Munteanu> The theoretical stuff on subtyping is still interesting though.
18:00:13 <applicative> oh that's an example of what I didn't like , but subtyping kind of freaks me.
18:00:37 <fluffynukeit> Hi all.  I have a list of binary data I want to store.  Each binary item can be translated into text description.  I want to search these text descriptions for substrings, and return associated binary items.  This is easy to do by storing both description and binary in a DB and search with DB, but that's redundant.  Any ideas on doing the search FAST without a DB?
18:00:47 <Eduard_Munteanu> Subtyping + polymorphism gets more complicated as well.
18:00:56 <darinmorrison> yeah, I'm not really super excited by subtyping stuff either. Mostly because of the complexity it adds to everything.
18:00:58 <typoclass> anyway, i need to get writing to make some suggestions. i wanted to propose patches to some haddock pages, as a concrete entry into the discussion :-)
18:01:05 <cmccann> subtyping makes basically everything more complicated
18:01:35 * hackagebot herbalizer 0.4.9 - HAML to ERB translator  http://hackage.haskell.org/package/herbalizer-0.4.9 (DanielChoi)
18:02:06 <jpaugh> fluffynukeit: umm, store it in text form and generate the binary on the fly? or vice-versa.
18:02:32 <Eduard_Munteanu> (also that stuff on bounded quantification)
18:02:50 <darinmorrison> typoclass: If you say so. I've found that people like that don't generally make tools or content for general consumption, so it's kind of self-defeating.
18:03:31 <applicative> oh i see harper is teaching 'Type Systems for Programming Languages' in the fall; maybe i'll brazenly ask to attend
18:03:34 <fluffynukeit> jpaugh: text to binary is hard on this, but I could just search the list for the substring in the "naive" way.  I'm concerned about performance though.
18:04:02 <jpaugh>  teaching 'Type Systems for Programming Languages' in the fall; maybe i'll brazenly ask to attend
18:04:02 <jpaugh> <fluffynukeit> jpaugh: text to binary is hard on this, but I could just search the list for the substring in the "naive" way.  I'm concerned about
18:04:02 <jpaugh> +performance though.
18:04:11 <jpaugh> oops.
18:04:16 <cmccann> applicative: hm, where are you located?
18:04:49 <applicative> pittsburgh
18:06:45 <jpaugh> fluffynukeit: idk. I don't know of a general solution to vaguely defined problems :-)
18:06:45 <sw2wolf> which country is pittsburgh in ?
18:07:07 <typoclass> sw2wolf: usa
18:07:12 <cmccann> applicative: any other haskell folks around? I've been too lazy to look since I moved here :P
18:07:33 <sw2wolf> typoclass: i first heard of it :)
18:07:42 <jmcarthur> cmccann: you're in pittsburgh?
18:07:46 <cmccann> yes
18:08:21 <cmccann> as of late last year
18:08:21 <jmcarthur> i'll let you know next time i'm around. i sometimes visit CMU
18:08:30 <darinmorrison> cmccann: not an SML/twelf convert yet? :)
18:08:37 <cmccann> heh
18:09:26 <cmccann> I'm kind of in an empty corner of nowhere but close to a bus route and technically inside the city itself
18:09:28 <applicative> oh I'll be darned.  yeah, we'll just have to convert to SML + Coq
18:10:23 <jpaugh> fluffynukeit: In general, there is no better solution than, keep both, or generate one from the other.
18:10:33 <shachaf> cmccann: Isn't Pittsburgh full of Haskell-ish people?
18:10:44 <applicative> geekosaur used to live here I think, but doesn't any more, I think.  there's a witty cmu student mirman https://github.com/mmirman and t moertel can't remember who else
18:10:51 <cmccann> shachaf: you may be thinking of the other city in this state
18:10:58 <applicative> haha
18:11:16 <applicative> shachaf: no, haskell is forbidden due to cmu / sml domination
18:11:20 <geekosaur> yeh, I've been in Akron, OH the past few years
18:11:24 * byorgey lives in not-Pittsburgh, for example
18:11:36 <shachaf> Nittsburgh
18:11:48 <applicative> awodey teaches there too, i've gone to his classes a bit
18:11:48 <geekosaur> but was at CMU (and one of the few haskell types around there...)
18:12:34 <darinmorrison> you'd probably have better luck with agda there. At least a few CMU folk are using it.
18:12:51 <cmccann> and somewhere out in the middle of the state there's supposedly a university which is where Haskell Curry used to be
18:13:11 <cmccann> I'm still skeptical that there's anything but endless nothing in most of the state though
18:13:15 <cmccann> it just goes on and on
18:13:28 <latermuse> and amish
18:13:42 <monochrom> you can always go near where Haskell Curry lived and use Haskell there
18:14:23 <sw2wolf> i feel few people can make money using haskell ?
18:14:23 <monochrom> tips: if you go into amish areas, remember to execute your Haskell programs by hand, not by electronic computers.
18:14:29 <cmccann> hahahaha
18:14:46 <monochrom> (tips: it's still better than executing C++ programs by hand)
18:15:03 <byorgey> sw2wolf: your feelings have little to do with it =)
18:15:23 <sw2wolf> byorgey: what do you mean ?
18:15:27 <applicative> Bill Clinton was told by his political adviser, whats-his-name, Pennsylvania, it Pittsburgh and Philadelphia; in between it's Alabama
18:15:36 <typoclass> i bet the amish will impressed with the purity, and be interested in our 'hair shirts'
18:15:49 <geekosaur> 'pennsyltucky'
18:15:50 <byorgey> sw2wolf: the number of people who are able to make money using Haskell is growing all the time.
18:17:39 <sw2wolf> byorgey: haskell can train your brain and you still need to make money using dominate language as a programmer in the future
18:18:05 <latermuse> i make money as a haskell programmer, and im not even 10% of the skill level most of you are at
18:18:27 <byorgey> sw2wolf: in the future, Haskell will be a dominant language.
18:18:41 <jmcarthur> latermuse: doing what or for who, may i ask?
18:18:42 <sw2wolf> latermuse: congratulation! i am glad to hear it
18:19:21 <typoclass> sw2wolf: i think when you learn haskell, you become a better programmer. no matter what language you use in your job
18:19:39 <sw2wolf> byorgey: hard because it is too abstract
18:19:59 <latermuse> web services
18:20:17 <jpaugh> sw2wolf: programming is too abstract. That's why only programmers do it.
18:20:25 <sw2wolf> typoclass: yeah, i like both math and haskell
18:20:31 <jmcarthur> latermuse: cool
18:20:53 <jmcarthur> byorgey: that's quite an assertive claim
18:21:08 <cmccann> jpaugh: many but not all programmers, rather.
18:21:09 <latermuse> jmcarthur: yeah, its pretty cool
18:21:17 <cmccann> there are certainly some who don't, and more who shouldn't
18:21:18 <jmcarthur> i guess the days are long past when "avoid success at all costs" held any water
18:21:53 <monochrom> it's supposed to hold cofree
18:22:21 <applicative> hold cofree?
18:22:24 <Nisstyre-laptop> "The psychological profiling [of a programmer] is mostly the ability to shift levels of abstraction, from low level to high level" - D. E. Knuth
18:22:31 <applicative> oh uh i get it
18:22:45 <Nisstyre-laptop> it's not just the ability to think abstractly
18:22:59 <Nisstyre-laptop> people in humanities departments do that all the time
18:23:03 <applicative> I don't believe that, it's obviously mostly mild autism that's the leading characteristic
18:23:07 <typoclass> jmcarthur: c++ might every five years acquire another one of haskell's features, until it becomes haskell with some additional old gunk under it
18:23:15 <Nisstyre-laptop> it's the ability to actually think about the low level details of an abstraction while you're implementing it
18:23:26 <shachaf> I hope C++ never becomes Haskell.
18:23:46 * applicative certainly doesn't think about the machine while writing Haskell
18:23:49 <fryguybob> "additional old gunk" is quite the understatement.
18:23:56 <Nisstyre-laptop> applicative: "low level" doesn't have to mean cpu instructions
18:24:19 <applicative> what's low level in ordinary haskell? Int?
18:24:23 <typoclass> shachaf: with the rate of 1 feature per 5 years, i think we're talking about events in the 23rd century
18:24:24 <jpaugh> by additional gunk, you mean, the entire current C++ language, right?
18:24:28 <tromp_> i don't know what the language of the future is, but it will be heavily inspired by haskell
18:24:40 <Nisstyre-laptop> applicative: well it could be the actual concrete implementation of a type class/family/whatever
18:25:04 <Nisstyre-laptop> basically the actual use of an abstraction, or how you'd actually go about implementing some grand abstraction
18:25:17 <darinmorrison> applicative: unboxed types, magic hash, etc.
18:25:32 * applicative admits he uses those
18:25:40 <Eduard_Munteanu> That's the 'asm' directive of Haskell, sort of :)
18:26:18 <cmccann> if you consider looking at the generated Core you're probably doing something low-level
18:26:19 <applicative> cmccann: well, we'll have to begin threatening to begin threatening "Hack 'Burgh" to oppose those obnoxious Hack Phi events and whatever they do in Boston
18:26:27 * sw2wolf time to work now ...
18:26:35 <cmccann> applicative: yes good plan
18:27:17 <darinmorrison> threaten to begin threatening? :)
18:27:34 <cmccann> yes, actually beginning to threaten it sounds like a lot of work
18:27:54 <applicative> darinmorrison: no, *begin* threatening to begin threatening
18:28:10 * applicative was thinking the same
18:28:19 <darinmorrison> nice
18:28:35 <applicative> I wonder if mmirman knows some bright locals
18:29:06 <kazagistar> I think procedural languages are just going to steal the type system and pattern matching
18:29:08 <typoclass> jmcarthur: i think the 'success at all costs' stuff was meant as not adding rubbish features just to appeal to the mass market, not shooting for the lowest common denominator, something like that. i think they weren't warning against making an excellent language and slowly convincing more and more people by merit
18:30:24 <applicative> cmccann: oh i know, dlukes or dylukes or whatever is her
18:30:25 <applicative> here
18:31:38 <applicative> hm position for "HASKELL PROGRAMMERS FOR FPGA SYSTEMS" yipe
18:31:49 <cmccann> applicative: srsly though we should arrange some sort of Haskell event thing around here at some point
18:32:13 <cmccann> I suppose we could let the philly people attend to if they want
18:32:21 <applicative> yes, I wonder if there is something unpretentious like Whatever They Do In Boston
18:32:27 <Eduard_Munteanu> That sounds like "INTERCAL PROGRAMMER NEEDED"
18:33:20 <applicative> well, yes, see if you can cook up a scheme
18:33:22 <Eduard_Munteanu> All serious Haskell-related ads should make proper use of camel-case. :P
18:33:45 <jpaugh> You mean camelCase?
18:33:51 <liyang> applicative: isn't that basically Andy Gill or Satnam Singh?
18:34:14 <Eduard_Munteanu> jpaugh: clearlyIDo
18:34:39 <dolio> Eduard_Munteanu: That was proper use. The entire thing is an acronym.
18:35:18 <Eduard_Munteanu> Whoa, didn't see that.
18:37:31 <applicative> liyang, which?
18:37:50 <applicative> oh, FPGA , it's Parallel Scientific
18:38:09 <applicative> seem to be a spate of positions listed on Haskellers.org
18:38:13 * liyang is sure he left a few people out.
18:38:43 <applicative> I dont know if they have to do with Parallel Scientific, Inc
18:38:51 <shachaf> cmccann: I might go!
18:39:04 <shachaf> cmccann: (Not very likely unless I happen to be nearby.)
18:39:10 <shachaf> cmccann: (But I went to the Boston event!)
18:39:32 <applicative> shachaf: it's awesome; it's the most happening place in Western Pennsylvania
18:39:47 <cmccann> haha
18:40:05 <applicative> liyang: at last I'm parsing you correctly: they're the only ones competent to apply
18:40:06 <cmccann> shachaf: it'd be a great place to find more people to not do your work for you
18:40:50 <shachaf> cmccann: I don't have much trouble finding those.
18:40:55 <shachaf> cmccann: There's one born every minute.
18:41:48 <cmccann> yes, but these would be more productive people, who would get much more work not done
18:45:06 <fxfactorial> Hello
18:45:18 <Eduard_Munteanu> fxfactorial: hi
18:45:40 <erisco> I've found a data definition that is useful to me http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html but how do I identify which package to install using cabal?
18:45:50 <fxfactorial> I was wondering if it was common to have have cabal give diffiulties in installing HTF
18:45:52 <shachaf> erisco: The package is "containers"
18:45:59 <Eduard_Munteanu> erisco: no need to, it comes with the platform
18:45:59 <shachaf> It's probably already installed.
18:46:04 <shachaf> It comes with GHC.
18:46:16 <monochrom> containers comes with GHC. please refrain from adding another version.
18:46:24 <typoclass> erisco: it is listed at the very top of the haddock page
18:46:43 <cmccann> reinstalling packages that come with GHC makes monochrom cry, don't do that
18:46:44 <erisco> Eduard_Munteanu, I did not have this
18:46:51 <monochrom> haha
18:47:03 <erisco> typoclass, thanks
18:47:07 <shachaf> erisco: Which version of GHC do you have?
18:47:22 <jpaugh> erisco: It's also in the url. They're usually easy (enough) to parse.
18:47:25 <erisco> shachaf, 7.4.2
18:48:01 <shachaf> GHC 7.4 is supposed to come with containers.
18:48:12 <shachaf> Perhaps there's something else going on here.
18:48:31 <Eduard_Munteanu> erisco: what's the issue? Did you import the module?
18:48:36 <erisco> quite likely. despite installing containers with cabal, eclipsefp doesn't find it during the build
18:48:48 <monochrom> there is some chance he/she mistrusts a linux distro for providing GHC, and that distro fragments GHC into a million incoherent shards.
18:48:50 <erisco> Eduard_Munteanu, I am attempting to, but cannot resolve the package
18:49:23 <erisco> "add containers to the build-depends in your .cabal file"
18:49:25 <erisco> okay will try that...
18:50:05 <typoclass> erisco: i suspect you now have two versions of containers, the one from ghc and the one you just installed with cabal
18:50:07 <Eduard_Munteanu> monochrom: or the platform, some do that
18:50:15 <applicative> fxfactorial: what is the trouble you are seeing with HTF
18:51:38 * hackagebot bliplib 0.1.0 - Support code for Blip.  http://hackage.haskell.org/package/bliplib-0.1.0 (BerniePope)
18:51:51 <applicative> Edgar_A: it seems to build okay here
18:51:58 <erisco> well, adding it to the build-depends line seemed to work
18:52:27 <Edgar_A> applicative: well, it gets to finishing all the dependencies and such, but right at the last moment it craps out.I'll try to do it again to get a the exact wording
18:53:11 <Edgar_A> applicative: Resolving dependencies...
18:53:11 <Edgar_A> Configuring HTF-0.10.0.7...
18:53:11 <Edgar_A> Building HTF-0.10.0.7...
18:53:11 <Edgar_A> Preprocessing library HTF-0.10.0.7...
18:53:11 <Edgar_A> ghc: could not execute: cpphs
18:53:11 <Edgar_A> cabal: Error: some packages failed to install:
18:53:11 <Edgar_A> HTF-0.10.0.7 failed during the building phase. The exception was:
18:53:13 <Edgar_A> ExitFailure 1
18:53:47 <jpaugh> Edgar_A: looks like you need to install cpphs
18:54:04 <jpaugh> I don't know what that is...
18:54:12 <Edgar_A> jpaugh: Thank you, is that somekind of c++ for haskell?
18:54:16 <applicative> oh dear, the haskell Python compiler is warm again
18:54:35 <Edgar_A> applicative: ha! My python background already revealed =/
18:55:00 <monochrom> somehow, cpphs is already a dependency of HTF, it is installed. but you need to add something to PATH
18:55:12 <applicative> Edgar_A: ah, you dont have the executable cpphs or it is not in path
18:55:51 <Edgar_A> all: thank you, so then I gather I need to add something to PATH?
18:56:00 <applicative> it isn't listed as a dependency in the cabal file, doesnt seem
18:56:08 <applicative> none of the modules depend on it
18:56:33 <monochrom> I am just reading the output of "cabal install --dry-run HTF". it contains "cpphs".
18:56:38 * hackagebot readpyc 0.1.0 - Read and pretty print Python bytecode (.pyc) files.  http://hackage.haskell.org/package/readpyc-0.1.0 (BerniePope)
18:56:51 <applicative> it comes with the Haskell Platform typically, what os are you using
18:57:08 <applicative> monochrom: ah i was looking at the haddocks
18:57:15 <jpaugh> Edgar_A: you'll need to find cpphs and add it to the path. And probably also install it first.
18:57:16 <monochrom> no, it does not come with the Haskell Platform
18:57:45 <applicative> Edgar_A: have you put ~/.cabal/bin in your path (or wherever cabal is)
18:58:09 <jpaugh> Edgar_A: It's a Haskell C preprocessor: http://www.haskell.org/cpphs/
18:58:19 <applicative> try cabal install cpphs ...
18:58:48 <Edgar_A> all: I'm on os x, mountain lion (10.8)
18:59:10 <applicative> oh so it's in ~/Libraries/somewhere...
19:01:16 <applicative> no wait, maybe it's in /Library anyway find it, Edgar_A
19:01:38 * hackagebot blip 0.1.0 - Python to bytecode compiler.  http://hackage.haskell.org/package/blip-0.1.0 (BerniePope)
19:01:51 <applicative> Edgar_A: I take it you used the haskell platform installer or else homebrew
19:02:10 <applicative> see there it is, more python compiler ^^^
19:02:38 <Edgar_A> applicative: I'm in the cabal config file now, what am I looking for?
19:02:42 <applicative> it's the haskell php compiler that will really shake the planet, I think
19:03:22 <applicative> nothing, we were thinking you just need to do pwd to find out where the bin directory is
19:04:41 <applicative> are you in some Library/ dir or in ~/.cabal/
19:04:49 <Edgar_A> latter
19:04:55 <applicative> oh great
19:05:19 <BMeph> BBL - gotta reboot the Ween-Doze,,,
19:05:20 <applicative> so you just need to add /Users/Edgar/.cabal/bin to the PATH in the .profile file
19:05:30 <BMeph> s/,,,/.../
19:05:45 <applicative> if cpphs isn't in there then of course you need to cabal install it
19:06:14 <Edgar_A> applicative: I did try cabal install on cpphs, but it says I already have it installed. Also, when you say .profile, are you referring to the regular bash profile?
19:06:30 <applicative> yeah, ~/.profile
19:06:52 <applicative> or if you have some other local thing of your own a .bashrc or whatever
19:06:55 <monochrom> "ls ~/.cabal/bin" to find cpphs there. or not.
19:07:36 <orzo> by the way, (foldr1 mplus) == join for the monads i'm using, so there i go. heh.
19:08:11 <jpaugh> Edgar_A: Note: I'm pretty sure you wanna use .bashrc rather than .profile
19:08:28 <applicative> jpaugh: I never had a bashrc on os x
19:08:42 <applicative> for some reason its .profile, but I don't profess wisdom
19:09:29 <Edgar_A> okay, I think I got it.
19:09:31 <applicative> there is a bashrc deep in the system
19:09:33 <jpaugh> applicative: I don't know Mac. That's why I was only pretty sure.
19:10:09 <applicative> I don't know why they do that, maybe its a bsd thing, or just their nonsense
19:10:24 <monochrom> even among solaris admins, PATH in .profile vs PATH in .bashrc/.cshrc is a bikeshed colour war
19:10:27 <jpaugh> applicative: bash only professes to check .profile on login: maybe all Mac term shells are login shells?
19:10:46 <orzo> http://www.joshstaiger.org/archives/2005/07/bash_profile_vs.html
19:11:00 <orzo> theres some mac os x esceptional case there
19:11:18 <applicative> I am logged in if I open the Terminal.app
19:11:37 * ksf wonders what wonders could be created by annotating functions with more semantic information. a la semantic web.
19:12:07 <jpaugh> cat .bash_profile
19:12:11 <jpaugh> . ~/.bashrc
19:13:29 <ksf> just one random example, you could ask the system if your function (composed of many other, annotated functions) loses information, and it might even be able to generate an inverse.
19:14:09 <Edgar_A> well, I'm done for tonight. Thank you all for your help.
19:14:38 <mewtwo> Hi all,I want to read a image file,detect edges in it via Sobel Edge Detection and write to the same image file.I am reading the file by function "readImageFromBMP"  and writing it by "writeImageToBMP". The problem I am facing is that the file is not written but gets curropted instead.What can be possible way to counter this keeping both input and output file the same?
19:15:00 <shachaf> mewtwo: Read the entire file into memory before writing it?
19:15:00 <ksf> don't.
19:15:02 <ksf> just don't.
19:15:07 <shachaf> Assuming that there's a lazy I/O thing going on.
19:15:08 <applicative> Edgar_A: so you got HTF installed?
19:15:14 <applicative> oop
19:15:22 <shachaf> Alternatively, write it out to a different file and then move it on top of the old file.
19:15:28 <ksf> mewtwo, open a temporary file, write to there, then move the new file over the old.
19:15:42 <no-n[1]> when does Haskell actually close a file that's been opened with readFile?
19:15:55 <applicative> mewtwo: don't write to the same file, it'll just be torture
19:15:57 <jpaugh> mewtwo: standard (unix) technique: write to a temp file, then overwrite the original after closing it for reading.
19:16:07 <shachaf> no-n[1]: Look up "semiclosed" handles for the answer.
19:16:17 <applicative> garbage collection, if you don't do it explicitly no-n[1]
19:16:18 <no-n[1]> thanks
19:16:30 <applicative> but shachaf knows better...
19:16:33 <applicative> oleg knows better
19:16:44 <ksf> even without lazyness writing into the old file is hazardous: if your program gets interrupted before finishing, you still trashed your data.
19:16:51 <ksf> moves, OTOH, are atomic.
19:16:55 <Rotaerk> hmm hoogle isn't finding this; is there anything common that does this:  (b->c->d)->(a->b)->(a->c)->a->d
19:16:58 <applicative> no-n[1]: best (non-fancy) practice is withFile
19:17:11 <no-n[1]> withFile, yea
19:17:36 <Rotaerk> (potentially some rearrangement of the args)
19:18:16 <ksf> @djinn  (b->c->d)->(a->b)->(a->c)->a->d
19:18:16 <lambdabot> f a b c d = a (b d) (c d)
19:18:59 <ksf> @pl \a b c d -> a (b d) (c d)
19:18:59 <lambdabot> liftM2
19:19:03 <ksf> there.
19:19:15 <Rotaerk> hmm.. interesting; thanks
19:19:21 <ksf> :t liftM2
19:19:23 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:19:36 <ksf> that's Monad (->), though.
19:19:41 <Rotaerk> yea
19:19:41 <ksf> :t liftA2
19:19:43 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:20:38 <ksf> maybe there's an applicative functor or such hiding in your code?
19:21:47 <Rotaerk> nah, just trying to clean this up a little
19:22:03 <monochrom> ksf: I don't know semantic web. but some parser libs annotate each parser with semantic (or whatever) information. an example is "what are the possible first characters of accepted strings", which helps lookahead and eliminate backtracking. this motivates making the parser type an arrow, although applicative enjoys the same story.
19:22:53 <hpaste> Rotaerk pasted “Cleanup...” at http://hpaste.org/86056
19:22:56 * applicative demands prof notation for profunctors
19:23:08 <Rotaerk> figured something like what I was asking about could help
19:23:17 <ksf> *shudder*
19:23:31 <ksf> can't you use normal names? like a and b?
19:23:45 <Rotaerk> no I prefer self documenting code
19:24:15 <monochrom> "normal" names are foo, bar, baz, and quux
19:24:35 <jpaugh> self-obfuscating code.
19:24:46 <tgeeky> both of those sets of normal names are totally hysterical raisins and are not good on their own, and there are good arguments that they are not good
19:24:58 <Hafydd> I hate those names.
19:25:17 <Hafydd> Standardised informality.
19:25:19 <tgeeky> the in-order alphabet as variable names?
19:25:26 <jpaugh> But they do have the virtue of being short.
19:25:38 <Hafydd> (I mean foo, bar, etc)
19:26:50 <monochrom> Rotaerk: you don't need two "let"s for this, one is enough; and you need an "in".
19:27:09 * Rotaerk hoogles "in".
19:27:19 <Eduard_Munteanu> ...
19:27:22 <Rotaerk> oh wait
19:27:23 <Rotaerk> lol.
19:27:25 <monochrom> "in" is unhooglable. not even a function name.
19:27:35 <Hafydd> @hoogle in
19:27:35 <lambdabot> Prelude init :: [a] -> [a]
19:27:36 <lambdabot> Data.List init :: [a] -> [a]
19:27:36 <lambdabot> Prelude data Int :: *
19:27:39 <tgeeky> let ___ in ___
19:27:39 <Rotaerk> nevermind
19:27:41 <Rotaerk> yea yea
19:27:50 <Rotaerk> used to F#, in which the "in" is optional if it's multi-line
19:27:58 <Rotaerk> but thanks
19:28:03 <tgeeky> @google haskell keywords
19:28:05 <lambdabot> http://www.haskell.org/haskellwiki/Keywords
19:28:05 <lambdabot> Title: Keywords - HaskellWiki
19:28:09 <tgeeky> bookmark that
19:28:11 <Eduard_Munteanu> It's optional here as well in do notation.
19:28:15 <applicative> Rotaerk: notice that hlint is not objecting to your vocabulary
19:28:25 <hpaste> wagle pasted “huh what?” at http://hpaste.org/86057
19:28:53 <wagle> why do i get a panic for that?
19:29:03 <wagle> in the shw
19:29:06 <wagle> in the show
19:29:08 <applicative> Rotaerk: I think you  should use where instead of let
19:29:12 <Eduard_Munteanu> wagle: should be Show
19:29:27 <Rotaerk> yea I was considering switching to where, but I wanted to try to eliminate the intermediate names altogether
19:29:30 <wagle> ah, thought it would be obvious..  thanks
19:29:58 <Eduard_Munteanu> No... all typeclasses need to start with an uppercase char
19:30:11 <Eduard_Munteanu> You're not deriving show the method.
19:30:25 <applicative> wagle you didn't capitalize "Show", but can that make a panic?
19:30:34 <Rotaerk> monochrom, when you said I could eliminate one let, did you mean just putting the newEntityTable expression directly in the returned expression?
19:30:34 <Eduard_Munteanu> I was wondering that too.
19:30:57 <monochrom> no, I mean replacing the second "let" by spaces.
19:31:06 <Rotaerk> oh
19:32:02 <hpaste> applicative annotated “Cleanup...” with “Cleanup... with where” at http://hpaste.org/86056#a86058
19:32:51 <applicative> Rotaerk: you can have a hundred 'statements' after a single let in haskell, God knows why
19:33:21 <Rotaerk> yea I was sloppy with the syntax; I'm not completely familiar with it so I let the compiler whine at me once I've written it
19:33:28 <Rotaerk> tends to be the last thing I worry about
19:34:15 <monochrom> I know why. mutual references
19:35:28 <monochrom> but I am not God. although I may be close. people now say "___ makes monochrom cry" like they say "___ makes baby Jesus cry" :)
19:35:34 <applicative> yeah, i see, monochrom
19:36:42 <applicative> can you write a recursive record type in ML/F#/ocaml and co?
19:36:58 <Rotaerk> you can in F#
19:37:30 <applicative> but how can you construct a record without an infinite sequence...
19:37:46 <monochrom> yes, that's just like list and tree. now, self-referencing record values and mutual-referencing record values, that's different.
19:37:56 <Rotaerk> applicative, recursive doesn't imply infinite
19:38:25 <startling> could you write a safeFromLeft :: (forall b. Either a b) -> a using Rank2Types ?
19:38:36 <applicative> Rotaerk: but a record is a product, it would be like data Stream a = Cons a (Stream a)
19:39:20 <applicative> or record Stream a = Stream {head :: a, tail :: Stream a} which must be infinite
19:39:35 <monochrom> that declaration is allowed. and then you can't write a value of it.
19:39:48 <applicative> I was wondering
19:39:56 <Rotaerk> when you say record do you not mean record-syntax
19:40:03 <monochrom> except in ocaml. "let x = Cons 0 x" works.
19:40:10 <Rotaerk> F# has "record types" which you declare similar to haskell record syntax
19:40:12 <applicative> I have a new argument that Haskell has the most advance record system, and the most advanced module system
19:40:47 <applicative> Rotaerk: I see, I wasn't distinguishing
19:41:06 <monochrom> ah, but until GHC makes cyclic imports a breeze, we don't practically have the most advanced module system, just theoretically.
19:41:14 <Rotaerk> F# does have laziness, it's just explicit
19:41:26 <applicative> my argument is that a record is properly the 'codata' version of a product type, as is argued by some type experts
19:41:41 <monochrom> err, it's "letrec" in ocaml.
19:42:33 <applicative> but the distinction is only of interest for the recursive case.  Haskell records can be recursive, or corecursive or whatever, so AT LEAST WE ACTUALLY HAVE RECORDS, unlike e.g. Agda
19:42:53 <sw2wolf> ocaml is funny ! "+" is even NOT polymorphic :)
19:43:26 <applicative> similary, every Haskell module imports itself
19:43:27 <sw2wolf> it needs +., -. ..., oh my god
19:44:02 <applicative> sw2wolf: that way come type classes, which are obviously for morons...
19:44:46 <sw2wolf> applicative: heh
19:45:39 <applicative> the creepiest aspect of ml and agda is that everything must be defined in order.  There is a latent imperativism to it, which is of course more obvious in an ml file
19:45:48 <scooty-puff> anyone particularly familiar with different trailing schemes, perhaps in prolog, but in general as well?
19:46:08 <applicative> let ...; and then let ...; and then let .... is the dirty secret of the .agda file
19:47:14 <scooty-puff> i have some backtracking strefs and iorefs (using logic) at http://hackage.haskell.org/package/logicst-0.1.0.0, where the trail is stored per reference, but i can't find too many papers one trailing schemes, and want to make sure this isn't a bad idea for any particular reason
19:47:23 <monochrom> not in order: http://hpaste.org/83483 :)
19:47:26 <scooty-puff> *one -> on
19:50:00 <sw2wolf> If haskell can improve compiling & linking speed, then it will be a dominated language ...
19:50:16 <wagle> applicative: yeah it panicked
19:51:16 <applicative> wagle: sorry, I hadn't noticed someone had already pointed out the 'show'
19:51:52 <applicative> wagle: what version of ghc are you using? i just got a sensible error message
19:54:13 <wagle> applicative: GHCi, version 7.4.2, 64 bit on a macosx
19:54:36 <wagle> prolly the 64 bit fault
19:54:51 <wagle> they warned me
19:54:53 <wagle> etc
19:55:59 <applicative> wagle: i have 7.6 64 bit, maybe it's just a bug from 7.4
19:56:15 <applicative> wagle: I do get 'Non-exhaustive patterns in function t' ...
19:56:27 <applicative> for qk1 A CW
19:58:32 <wagle> yeah, i fixed a bunch of stuff after initially trying to run it at all
20:04:01 <gwern> @quote
20:04:01 <lambdabot> grauenwolf says: (On predicates and the relational model) The definition of predicate is "the part of the sentence that makes the assertion about the subject." So predicates cannot be 'on' the
20:04:02 <lambdabot> attributes so much as 'about' the attributes.
20:11:21 <applicative> wowzer https://github.com/pigworker
20:12:09 <tgeeky> clearly lambdabot has a lower upper bound on IRC message length
20:12:48 <Rotaerk> hmm darn, so close to eliminating a point from that addEntity function
20:14:01 <gwern> @quote IRC
20:14:02 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
20:14:44 <applicative> strange quote, in 'this rose is red', the predicate 'is red' makes 'an assertion about the subject', but in 'if this rose is red, I'm a monkey's uncle' it doesn't make any assertion
20:14:52 <monochrom> haha. but he/she has not read the official python tutorial
20:15:30 <dmp1ce> I'm new to haskell.  I'm trying to setup a simple Scotty website using cabal-dev.  I don't know if that is the right approach.  I installed scotty using 'cabal-dev install scotty' and create a file named test.hs.  But when I run ghc test.hs I get 'Could not find module `Web.Scotty''.  What am I doing wrong?
20:16:14 <johnw> i really would like a caseM
20:17:07 <monochrom> clearly, "if this rose is red, I'm a monkey's uncle" is a compound assertion, about a compound subject, that is rose, monkey, and possibly me
20:17:22 <applicative> you should be using a cabal-dev function, I think, dmp1ce
20:17:38 <johnw> yes, the whole point of using cabal-dev is that just "ghc" wont' find it
20:17:47 <applicative> monochrom: but 'is red' means just the same in both sentences
20:18:02 <applicative> otherwise modus ponens would equivocate!
20:18:28 <applicative> dmp1ce: i havent used it in ages, what commands does cabal-dev --help show
20:18:35 <monochrom> "is red" is just not the top-level predicate, that's all
20:18:55 <applicative> dmp1ce: the trouble is that ghc cant find the package register or whatever presumablu
20:19:09 <applicative> oh, 'top level predicate'
20:19:28 <monochrom> the top-level predicate is a compound predicate: \r m i -> red(r) ==> uncle(i, m)
20:19:57 <mm_freak> johnw: and ifM and whenM and unlessM and …
20:20:55 <johnw> well, those exist
20:21:03 <johnw> but a proper caseM would need to be syntactic
20:21:12 <monochrom> I regret that some thinkers have not thought of composition (of subjects, predicates, propositions), unlike category theorists who natively understand that as soon as you have objects and morphisms, you can already imagine sums, products, exponents, CCC
20:21:22 <applicative> dmp1ce: I think cabal-dev probably wants you to write a cabal file by the way, which is a snap with cabal init
20:21:24 <johnw> caseM getLine of "Hello" -> ...
20:21:57 <dmp1ce> applicative: OK.  Thanks.  This is what cabal-dev shows me btw: http://bpaste.net/show/92253/
20:22:18 <dmp1ce> applicative: cabal-dev help
20:22:29 <Sheilong> taylor are you therer?
20:22:46 <applicative> yeah i have cabal-dev again now.
20:22:59 <applicative> dmp1ce: i take it cabal-dev ghci test.hs works
20:24:43 <applicative> if you had a .cabal file dmp1ce you would just give the command equivalent to cabal , cabal-dev configure, cabal-dev build; then the binary would be somewhere in there
20:26:32 * sw2wolf time to lunch
20:26:38 <dmp1ce> applicative: I'll try that.  Does it make sense for me to be using cabal-dev?  I'm not sure what the other options are.  I was thinking about using vagrant.
20:27:18 <johnw> dmp1ce: you might find hsenv a lot easier
20:27:27 <johnw> then you could just use plain "ghc" when the hsenv is activated
20:27:53 <applicative> dmp1ce: I don't know what the going sandbox mechanism, I dont use one, which isn't really tenable
20:28:20 <applicative> hsenv did seem kind of cool
20:28:25 <hpaste> Rotaerk pasted “Pointlessly almost pointless!” at http://hpaste.org/86059
20:28:54 <Rotaerk> hmm couldn't figure out how to get rid of the context point
20:29:21 <Rotaerk> although it's already pretty big and pointless
20:29:47 <Rotaerk> and probably slightly slower due to recomputation
20:30:09 <dmp1ce> I'm looking at hsenv now.
20:30:11 <monochrom> I think you're already pretty close?
20:30:34 <monochrom> you're already at: addEntity entity context = (bigf . smallf) context
20:31:30 <monochrom> oh, you have another mention of "context" deep inside bigf. nevermind.
20:32:08 <monochrom> I think there is no need making it pointfree. the dataflow is interesting. the parameter names are useful.
20:32:17 <applicative> hm, dmp1ce I can't find a recent discussion of the merits of the sandboxers. johnw 's advice would weigh with me....
20:36:04 <Rotaerk> yea, I might find a middle-ground; I just don't like the explicit unpacking of the EntityTable, and then the construction of a new one
20:36:15 <Rotaerk> don't care about eliminating the parameters themselves too much
20:37:35 <johnw> also, hsenv can let you use other compilers, which can be quite handy
20:37:40 <johnw> cabal-dev won't do that
20:37:44 <giogadi> howdy everybody
20:37:57 <johnw> hsenv --ghc=<path to GHC binary dist tarball>
20:38:06 <giogadi> has anyone been through the "arrows, robots and FRP" paper?
20:38:56 <giogadi> here's a link: http://www.staff.science.uu.nl/~jeuri101/afp/afp4/hudak.pdf
20:39:17 <ryao> I know some SML and I would like to learn Haskell. Where should I begin?
20:39:35 <ryao> Well, specifically, sml/nj.
20:39:41 <johnw> @where lyah
20:39:41 <lambdabot> http://www.learnyouahaskell.com/
20:39:50 <johnw> or, straight to RWH
20:39:52 <johnw> @where RWH
20:39:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:40:03 <ryao> johnw: Thanks.
20:40:15 <johnw> lyah might be too remedial for you, if you know SML well
20:40:32 <giogadi> I like the idea of RWH, but I found the abundance of errors to be reeeeeally annoying
20:40:36 <nbouscal> LYAH is nice coming from SML because of list comprehensions, guards, and a few other things
20:40:40 <nbouscal> also LYAH has whimsy
20:40:50 <johnw> yeah, the whimsy is pleasant
20:40:59 <napping> ryao: http://www.haskell.org/tutorial/intro.html
20:41:06 <nbouscal> one should never underestimate whimsy in a programming book. Why's Poignant Guide is half the reason I ever got into Ruby
20:41:09 <napping> you're actually in the intended audience
20:41:11 <johnw> you should read it at least once, if for nothing else than knowing which parts to direct other newbies to :)
20:41:34 <ryao> johnw: I have not done it in a while, but I am familiar with the concepts. Immutable variables, lists, tail recursion, map, foldr/foldl, how to make a function, etcetera.
20:41:56 <ryao> napping: Really? That is a surprise to me... I am usually never in the intended auidence.
20:42:06 <nbouscal> I came to Haskell with some SML and personally found LYAH much better than RWH, but, that's a very personal opinion
20:42:25 <arkeet> sounds like LYAH is for everyone.
20:42:27 <johnw> yeah, i'm not a big fan of RWH
20:42:37 <johnw> i found most of their motivating examples rather unmotivating
20:42:49 <giogadi> unmotivating and like 50% incorrect
20:42:50 <giogadi> jesus
20:42:52 <nbouscal> yeah. I haven't finished it yet so I can't render a fair opinion, but there's a reason I haven't finished it yet haha
20:43:06 <monochrom> ryao: I concur with napping
20:43:19 <napping> ryao: basically, it's gentle assuming you know ML
20:43:26 <ryao> The first thing that I want to do is write a program that takes a number, creates a tree representing a boolean equation, converts it to CNF and then prints it out. I feel like I should use a functional language for that.
20:44:05 <nbouscal> well you should use a functional language for everything, that included
20:44:06 <nbouscal> :P
20:44:07 <ryao> The one thing that I never figured out how to do in SML is do decent IO.
20:44:41 <ryao> In specific, using UNIX pipes.
20:44:58 <ryao> nbouscal: I don't think I could write a kernel in a functional language. :P
20:44:58 <napping> like making new pipes?
20:45:03 <applicative> giogadi: its a bit out of date; the authors wrote RWH then rewrote most of the standard libraries...
20:45:22 <applicative> giogadi: they should have done it in the other order
20:45:24 <giogadi> sorry to ask again, but has anyone here been through the Yampa tutorial that uses robots
20:45:25 <ryao> napping: No. Like `cat /path/to/file | sort | grep $EXPR`.
20:45:31 <giogadi> sorry to ask again, but has anyone here been through the Yampa tutorial that uses robots
20:45:42 <napping> how does SML have a problem with that?
20:45:54 <napping> Isn't the point of pipes that they look like stdin/stdout?
20:45:57 <nbouscal> ryao: I don't think I could either, but that wouldn't stop me from trying :P
20:46:10 <ryao> napping: I never figured out how to write a SML program that could, for instance, replace sort.
20:46:11 <arkeet> note: the gentle introduction is a bit dated; it's based on haskell 98, so doesn't have stuff like hierarchical modules
20:46:21 <nbouscal> look like? is there a difference?
20:46:23 <arkeet> someone should update it.
20:46:37 <napping> so you never figured out how to do input and output at all?
20:46:46 <giogadi> sorry to ask again, but has anyone here been through the Yampa tutorial that uses robots?
20:46:49 <nbouscal> i thought pipes were stdin/stdout
20:46:58 <applicative> ryao: for your first executable use main = interact f where f :: String -> String; f str = ....
20:47:38 <ryao> napping: I am afraid not. That made SML a toy language for me. I could never do anything serious.
20:47:39 <applicative> ryao: then the compiled executable is  pipeable ; there are similar 'interact' functions for ByteString and Text
20:48:17 <ryao> applicative: What about arguments to the program? i.e. argv and argc
20:48:25 <napping> well, System.IO (or perhaps the ByteString versions) will go pretty far
20:49:18 <applicative> ryao: then that's another subject; import System.Environment (getArgs) main = do {args <- getArgs; args....}
20:49:18 <giogadi> also, is Yampa still the FRP framework to learn, or has the haskell community moved on?
20:49:28 <ryao> One more thing... how long does haskell-platform and all of its dependencies take to compile?
20:49:37 <napping> but I doubt SML is particularly worse
20:49:39 <ryao> A ballpark range on a modern quad core would be lovely.
20:49:48 <applicative> it's out of date, I'm not sure if there is any frp scheme that is the current winner
20:49:59 <ryao> frp scheme?
20:50:10 <giogadi> functional reactive programming
20:50:25 <applicative> ryao: what os are you using?
20:50:31 <ryao> I know what functional programming is. What is functional reactive programming?
20:50:34 <ryao> applicative: Gentoo Linux
20:50:36 <elliott> ryao: depends what you mean by haskell-platform
20:50:48 <elliott> if you include GHC, then you need a GHC binary to start with, and it'll take a long time.
20:50:50 <giogadi> ryao: still trying to wrap my head around it!
20:50:51 <ryao> elliott: The metapackage that installs ghc and everything else.
20:50:58 <elliott> ryao: it comes in many forms
20:51:03 <elliott> in particular, its source distribution does not include GHC
20:51:06 <elliott> (but its binary distribution does)
20:51:09 <applicative> giogadi: there is reactive-banana, sodium, and the mysterious netwire
20:51:14 <ryao> http://bpaste.net/show/92256/
20:51:32 <ryao> elliott: Haskell is an optional part of Gentoo. I am building it now.
20:51:44 <elliott> I don't know Gentoo. I know Haskell :P
20:51:45 <giogadi> one of FRP's purposes is to be a framework for making functional programs which can respond to time-varying inputs and events
20:51:46 <applicative> giogadi: someone I affirm is genuinely knowledgeable declared sodium to be these best not long ago.
20:51:49 <giogadi> like GUI's and video games
20:51:59 <ryao> elliott: How long does it take you to go from not having haskell to having it when building from source?
20:52:01 <giogadi> thanks, applicative; I'll check out sodium
20:52:27 <giogadi> one thing I've noticed is that most of the FRP frameworks' tutorials seem to assume familiarity with the concepts of FRP
20:52:42 <napping> configured for build speed, building ghc takes me 10-15 minutes
20:52:46 <ryao> giogadi: I see. This is not an interactive program (thankfully). It will start with some input and end with some output. No interaction.
20:52:48 <giogadi> Yampa has an *okay* tutorial but it's still pretty academic
20:52:52 <elliott> ryao: like I said, depends what you mean by having Haskell, and from source. if you mean "not involving a binary related to Haskell at any stage", it is impossible; GHC requires GHC to build
20:52:57 <napping> I don't generally build it from source
20:53:05 <nbouscal> giogadi: well it is Haskell, academic kind of comes with the territory
20:53:05 <elliott> so you have the choice: use a GHC binary, or compile GHC with a GHC binary
20:53:11 <elliott> the latter adds some hours to your compile time, depending on your machine
20:53:17 <applicative> giogadi: also the Elm language (compiles to javascript) is a haskell-like (strict) language for web work that purports to be based on an frp theory.
20:53:24 <ryao> elliott: How was GHC first made if it needed itself to build itself? :P
20:53:27 <napping> elliott: it's not that bad with a reasonable -jN
20:53:36 <ryao> I have seen the same problem with Java. :/
20:53:41 <elliott> ryao: the first haskell compiler was written in lazy ml
20:53:49 <elliott> then ghc was rewritten in haskell
20:53:59 <napping> wasn't there a lazy lisp at some point?
20:54:03 <giogadi> Elm? that's interesting, I'll check it out. I'm likely to stay in haskell, but the idea of a language built around frp is pretty interesting
20:54:05 <elliott> maybe if you track down code from 1989 you can build the latest ghc entirely from source
20:54:06 <arkeet> and there are other haskell compilers that aren't GHC.
20:54:06 <napping> but there is unregisterized via-C
20:54:08 <elliott> given a lazy ml interpreter or whatever
20:54:09 <arkeet> wasn't hugs written in C?
20:54:14 <elliott> i estimate that would take about a year :P
20:54:17 <napping> I really hope Gentoo doesn't build through the unregisterized C sources
20:54:31 <elliott> I suspect Gentoo's ghc package, if from source, just downloads an existing binary
20:54:33 <arkeet> gentoo uses a ghc binary to build the ghc source.
20:54:35 <elliott> and then compilse GHC with it.
20:54:44 <napping> sounds rather pointless
20:54:51 <elliott> well, if you want to change compile flags or such, it makes sense.
20:55:00 <elliott> but yes, I personally just use the official binaries...
20:55:07 <ryao> It downloads the following: http://code.haskell.org/~slyfox/ghc-amd64/ghc-bin-${PV}-amd64.tbz2
20:55:13 <arkeet> well, "compile everything from source (from scratch)" isn't the point of gentoo.
20:55:15 <napping> It's not like it can even do anything with your gcc flags
20:55:15 <applicative> giogadi: http://elm-lang.org/ its kind of nice
20:55:16 <ryao> Which looks like a binary package. It then builds using that.
20:55:31 <elliott> arkeet: it isn't?
20:55:34 <ryao> arkeet: Gentoo is about customization.
20:55:36 <Nisstyre-laptop> napping: Gentoo is rather pointless
20:55:38 <arkeet> indeed.
20:55:39 <giogadi> applicative: thanks
20:55:40 <elliott> napping: there's stuff like profiling you can change.
20:55:45 <applicative> giogadi: I mention it because it seems like the most happening frp thing around
20:56:06 <arkeet> oh, speaking of profiling.
20:56:07 <Nisstyre-laptop> napping: also Lazy Racket is a thing
20:56:15 <ryao> Nisstyre-laptop: Are you a developer of any OSS project?
20:56:18 <arkeet> ryao: you should build everything with profiling support.
20:56:26 <ryao> arkeet: Why is that?
20:56:30 <Nisstyre-laptop> ryao: why?
20:56:32 <giogadi> wow, elm compiles to html/css/js? that's really interesting
20:56:35 <ryao> Nisstyre-laptop: I am a Gentoo developer.
20:56:35 <arkeet> because if you don't, and you want to profile something later, it's a huge pain.
20:56:49 <Nisstyre-laptop> ryao: sorry if I offended you, I wasn't being serious.
20:56:58 <Nisstyre-laptop> I can see why some people would use Gentoo.
20:57:01 <napping> arkeet: is it hard to rebuild stuff?
20:57:01 <ryao> arkeet: The stuff that I want to profile is usually in the kernel and profiling that is a pain.
20:57:13 <ryao> napping: It is easy.
20:57:33 <ryao> Rebuilding everything can be done with `emerge -e @world`
20:57:36 <arkeet> I suppose it's easy if you use gentoo to build all your haskell packages.
20:57:47 <nbouscal> huh, Elm actually looks really cool
20:58:03 <napping> ryao: I meant more like asking cabal or something to build profiling version of your haskell libraries
20:58:06 <ryao> arkeet: My Gentoo system is rather cutting edge. GCC 4.8.0 and root on ZFS. :)
20:58:07 <hpaste> Rotaerk revised “Pointlessly almost pointless!”: “Middleground” at http://hpaste.org/86059
20:58:16 <giogadi> nbouscal: I know! this is the first time I've been even slightly excited about web programming
20:58:19 <napping> Is there a gentoo package for everything on hackage?
20:58:31 <nbouscal> giogadi: I have the misfortune of being a web developer professionally
20:58:32 <arkeet> no, but there is hackport which will generate packages from hackage for you.
20:58:35 <ryao> napping: I don't know, but there are a ton of gentoo haskell packages... dozens are pulled in by the platform.
20:58:41 <Rotaerk> the last version of that function was my compromise between the two approaches
20:58:42 <giogadi> hahahaha
20:58:44 <arkeet> and the haskell overlay does have quite a few packages in it.
20:58:52 <ryao> I am not using the overlay. :/
20:59:02 <arkeet> you might want to.
20:59:11 <ryao> arkeet: Why is that?
20:59:51 <arkeet> because it has a lot of packages in it.
21:00:04 <ryao> arkeet: If there is something I want that is not in the main tree, I will fix that. :)
21:00:07 <napping> ryao: if I count right, there are 5053 hackage packages
21:00:46 <ryao> napping: Yeah... we don't have nearly that many in the main tree. We only have 179 packages under dev-haskell.
21:00:48 <napping> ryao: is ghc building with a decent number of threads?
21:01:03 <ryao> napping: It is keeping my quad core mostly busy.
21:01:07 <Rotaerk> hmm actually, can probably improve it with lenses on EntityTable
21:01:29 <applicative> ryao: I meant to say there are a number of libraries dedicated to making spiffy unix executables; the behemoth is http://hackage.haskell.org/package/cmdargs , less so http://hackage.haskell.org/package/optparse-applicative
21:02:08 <applicative> ryao: my personal favorite is the crude and barbaric ReadArgs  http://hackage.haskell.org/package/ReadArgs
21:03:07 <ryao> I think I will use this: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
21:03:41 <applicative> right, thats the 'standard library' version; it's kind of a pain, but yes do
21:03:56 <ryao> Anyway, this is a really simple program. It takes a number n as input and generates a CNF representation for the multiplication of two n-bit numbers as output.
21:04:08 <ryao> Well, the program that I want to write. :)
21:04:19 <arkeet> if it's really simple, you might just work with the argument list directly.
21:04:30 <ryao> arkeet: It is literally 1 argument.
21:04:41 <ryao> I might make it more complicated, but 1 argument should be all that I need.
21:04:50 <arkeet> then System.Environment.getArgs is all you need.
21:05:00 <ryao> I can pipe to another program to do more manipulations.
21:05:03 <ryao> arkeet: Thanks.
21:05:33 <arkeet> (it would be overkill to use, say, getopt if you were writing it in C.)
21:05:39 <applicative> import ReadArgs ; main = do {(n :: Int) <- readArgs ; print (f n)}   with whatever extension that is for signatures on n,
21:06:00 <arkeet> ScopedTypeVariables is it.
21:06:00 <ryao> arkeet: Yeah... I would not do use getopt for C.
21:06:06 <applicative> arkeet: right
21:07:12 <applicative> readArgs will parse the most amazing stuff into a tuple, if you give the signature, mostly by black magic.  and it's easier to import than System.Environment and the like.
21:07:43 <arkeet> huh neat.
21:07:58 <ryao> By the way, does anyone know of any work that has been done in the area of writing a program specification and generating code from it that is provably correct?
21:08:16 <napping> #coq is thataway -->
21:08:22 <ryao> coq?
21:08:38 <ryao> Ah, cool.
21:08:40 <napping> Haskell is just too darn untyped
21:08:43 <johnw> coq is rather awesome for what it does
21:08:51 <ryao> What is coq?
21:09:03 <napping> more like program extraction from constructive proofs
21:09:05 <arkeet> it's a dependently typed functional language/theorem prover thing
21:09:05 <johnw> a dependently typed language and theorem prover
21:09:09 <applicative> a proof assistant/dependently typed language
21:09:18 <napping> generating things from specifications is more general, I suppose
21:09:20 <arkeet> is there an echo here?
21:09:21 <johnw> and it supports interactive proving, which can be quite fun
21:09:22 <applicative> the house prefers agda and idris, of course
21:09:34 <applicative> @quote fugue
21:09:35 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
21:09:44 <napping> agda doesn't have ltac
21:09:46 <johnw> yeah, the syntax of coq is not the best, when you have agda available, but the theorem proving tactics can be more fun
21:09:54 <johnw> aka ltac
21:10:08 <napping> haven't tried idris enough. Ltac is pretty ugly, but it beats the alternatives
21:10:14 <ryao> Can you make a theorem that a computer program is correct and prove it?
21:10:32 <johnw> that is what dependently typed programs aim to achieve
21:10:41 <johnw> for example, check out CompCert C
21:10:49 <ryao> Is this a NP-complete problem?
21:10:52 <johnw> it's a verified C compiler built using Coq
21:11:00 <applicative> idris is beautiful and has a simple theorem prover built in
21:11:21 <arkeet> generating a proof is hard. if it were easy, mathematicians would all be out of jobs ;)
21:11:46 <johnw> the halting problem is NP-hard, and concerns analyzing any arbitrary program to determine if it will halt.  dependently typed languages don't let you write any program, but only those that can be expressed by the type system (which is much more restrictive than what Haskell will let you get away with)
21:11:48 <arkeet> (except not really.)
21:11:58 <napping> "NP-hard"
21:12:04 <elliott> the halting problem is NP-hard, heh
21:12:06 <napping> sure,
21:12:06 <arkeet> heh.
21:12:25 <monochrom> NP-hard is right but gross understatement
21:12:27 <elliott> i mean... it is.
21:12:28 <arkeet> :P
21:12:28 <elliott> but.
21:12:35 <johnw> "NP-hard" is something a friend of mine used to say all the time
21:12:35 <ryao> johnw: The halting problem is undecideable.
21:12:41 <napping> Just like you can solve the travelling salesman problem in O(log n) time
21:12:44 <ryao> NP-hard is something that can be decided.
21:12:45 <elliott> it's not only NP-hard, it's just plain hard
21:12:45 <arkeet> NP-impossible
21:12:57 <johnw> ryao: good point, thanks for the clarification
21:13:13 <napping> wait, the Omega one
21:13:21 <applicative> if the halting problem is "Is there a program that can tell you if the program terminates", it has been decided ...
21:13:26 <johnw> NPossible
21:13:32 <arkeet> applicative: that's the halting problem problem.
21:13:37 <applicative> ah
21:13:41 <elliott> the halting problem is when your programs have problem halting.
21:13:51 <ryao> arkeet: If it was not hard, you would still need people who understood how to do it. :/
21:13:55 <napping> an oracle for the halting problem suffices to decide NP problems, yes
21:14:01 <coppro> http://ebiquity.umbc.edu/blogger/2008/01/19/how-dr-suess-would-prove-the-halting-problem-undecidable/
21:14:11 <ryao> napping: An oracle for th halting problem is impossible... it is undecideable.
21:14:12 <applicative> anyway, any language that lets you directly write programs in the halting problem sense of program, is not a language really
21:14:29 <napping> ryao: that's why you say "Oracle" rather than "algorithm"
21:14:41 <applicative> thus turing uses meaningless tapes
21:14:41 <ryao> napping: Good point.
21:15:10 <DT`> so can Java solve the halting problem?
21:15:12 <ryao> Does anyone actually know how proofs would be generated if a polynomial time algorithm for NP-complete problems were found?
21:15:13 <arkeet> an oracle for the halting problem simply introduces another problem further up.
21:15:34 <monochrom> no, NP-hard is not something that can be decided
21:15:39 <ryao> You guys are simply brilliant, so I thought that I would try my luck.
21:15:49 <ryao> monochrom: NP-hard is decideable.
21:16:00 <napping> you'd just take the proof checker and feed it nondeterministic input
21:16:03 <monochrom> all you need is polytime-reduce SAT to the halting problem
21:16:35 <applicative> in agda and coq, the programs halt; there's a solution
21:16:37 <ryao> monochrom: You have it backward. You need to reduce the halting problem to SAT.
21:16:52 <monochrom> do you trust wikipedia?
21:17:06 <ryao> monochrom: Not unless it has a proof that I can verify.
21:17:14 <napping> monochrom: well, that does depend on how long your halting procedure takes
21:17:25 <applicative> do you trust people who take expressions like NP seriously ?
21:17:39 <ryao> applicative: What do you mean?
21:17:52 <ryao> napping: That is somewhat vague.
21:17:55 <monochrom> no, polytime-reductions do not talk about decision procedures on either side. it only talks about tranlating one question to another question.
21:18:06 <napping> not sure how you would bootstrap e.g. and exponential time halting test to P=NP
21:18:26 <monochrom> NP-hardness is a definition. there is no proof except looking it up.
21:18:47 <ryao> monochrom: If you can translate the halting problem into SAT, then SAT is at least as hard as the halting problem...
21:18:51 <napping> but you could compare the definition of NP-complete
21:19:08 <arkeet> indeed, so halting problem is not in NP.
21:19:10 <napping> that's how you would try to prove the halting problem is NP, if you were silly enough to start
21:19:35 <ryao> napping: I think it would follow from the definitions...
21:19:39 <arkeet> but NP-hard is not in NP.
21:19:49 <ryao> Well, that the halting problem is not in NP.
21:19:56 <arkeet> certainly.
21:20:12 <ryao> NP = Non-deterministic polynomial. Something that cannot be decided cannot be solved in that time or any time.
21:20:16 <monochrom> I'm going to just quote wikipedia, then use it, and ignore objections. you can go look up your favourite textbook.
21:20:38 <monochrom> "A problem H is NP-hard if and only if there is an NP-complete problem L that is polynomial time Turing-reducible to H"
21:21:01 <monochrom> I instantiate H to the halting problem, and pick L to be SAT.
21:21:10 <napping> well, I guess you can solve you problems in a polytime conversion, plus however long the oracle takes to run
21:21:27 <dacto> What does the "!" mean in record syntax? ie: AStar { visited  :: !(Set a), ...}
21:21:29 <ryao> monochrom: That is not quite correct. It is NP-hard if you can reduce an NP-hard problem into it.
21:21:40 <ryao> The other way is not necessary.
21:21:55 <napping> huh?
21:22:01 <napping> the iff is because it's a definition
21:22:08 <napping> dacto: that's general notation for a strict field
21:22:22 <napping> data Foo a = Foo !(Set a) as well
21:22:27 <arkeet> exercise: reduce SAT to the halting problem.
21:22:27 <arkeet> (the same article sketches how)
21:22:33 <ryao> The iff is redundant. The other way is not a necessary condition to prove NP-hardness.
21:22:36 <dacto> I shall investigate that.
21:22:55 <arkeet> dacto: it makes the constructor strict in that argument.
21:23:15 <dacto> ah ok
21:23:23 <napping> ryao: the "only if" means your problem is not NP-hard if you can't convert any NP-complete problems into it
21:24:00 <monochrom> oh, cool, I can save work now, wikipedia gives the proof I would give.
21:24:35 <ryao> napping: That would follow from the problem being reducible to NP-hard. Also, you cannot prove that you cannot convert any NP-complete problems into NP-hard problems. That would prove P != NP.
21:24:58 <arkeet> what?
21:25:00 <ryao> Maybe I have that backward... I need to think about that.
21:25:05 <napping> you do
21:25:06 <arkeet> your first sentence is backward.
21:25:09 <arkeet> and NP-hard contains NP-complete.
21:25:11 <Nisstyre-laptop> looked like there was a double negative there
21:25:16 <monochrom> do not think. look up. you think too much.
21:25:43 <ryao> arkeet: If P = NP, then you NP-hard = NP-complete = P.
21:25:49 <ryao> s/you //
21:25:51 <monochrom> if you don't trust wikipedia, I'm sure there are a dozen sources you trust.
21:25:57 <napping> ryao: not at all
21:26:09 <napping> look up what things are strict separations
21:26:39 <ryao> napping: The difference between NP-complete, P and NP-hard is how much time it takes to compute and solve the solutions.
21:26:59 <napping> see "time hierarchy theorem"
21:27:38 <ryao> Things in P (but not the others) can be solved and verified in polynomial time. Things that are NP-complete are things that can be verified in polnomial time. Things that are NP-hard cannot be solved or verified in polynomial time unless P = NP.
21:27:48 <ryao> napping: It collapses if P = NP.
21:28:04 <arkeet> if P = NP, then NP-hard contains everything.
21:28:07 <arkeet> (and only if)
21:28:22 <napping> no, NP-hard is a very vague term for anything at least as hard as NP
21:28:23 <ryao> arkeet: Well, yes and no. It does not contain exp-time.
21:28:28 <arkeet> NP-hard is not vague at all.
21:28:30 <arkeet> yes it does.
21:28:50 <ryao> Hmm... maybe I have a different definition... it does not matter very much given that P versus NP is unsolved.
21:29:02 <arkeet> a problem is in NP-hard if any problem in NP can be reduced to it (in polynomial time)
21:29:03 <ryao> For all intents and purposes, anything NP-hard is intractable.
21:29:37 <arkeet> trivially, any problem in P can be reduced to anything.
21:29:59 <ryao> arkeet: That implies that NP is a subset of NP-hard.
21:30:05 <arkeet> it does not.
21:30:09 <arkeet> unless P = NP
21:30:22 <ryao> If A, then B means A is a subset of B.
21:30:25 <arkeet> if you have something in P - NP, then no NP-complete problem can be reduced to it.
21:30:27 <napping> the time hierarchy theorem for one implies that NP is a strict subset of NP-hard
21:30:40 <ryao> I am not talking about a strict subset.
21:31:05 <arkeet> "everything X can be reduced to Y" does not mean X is a subset of Y.
21:31:13 <ryao> Anyway, I really want to know one thing. How would one use a NP oracle to do proofs? :P
21:31:24 <arkeet> easy. checking a proof is in P
21:31:32 <arkeet> er...
21:31:35 <ryao> arkeet: 00:28 < arkeet> a problem is in NP-hard if any problem in NP can be reduced to it (in polynomial time)
21:31:36 <arkeet> can be done in polynomial time.
21:31:50 <ryao> arkeet: That translates into If A, then B.
21:32:06 <arkeet> it's a definitional if, so that's reallY "if and only if"
21:32:19 <dacto> I have one more.. what does the ":->" mean? ie: case [something] of  Just (x :-> _, w') ->...
21:32:24 <ryao> I don't care anymore. :/
21:32:29 <dacto> it seems like it is somewhat like @ in patterns
21:32:31 <arkeet> dacto: it's a constructor.
21:32:34 <monochrom> A = "any problem in NP can be reduced to it", B = "it is NP-hard".
21:32:47 <napping> dacto: that's just a constructor, some syntax extension allows you to use operator names starting with : as infix constructors
21:33:09 <arkeet> I don't think you need an extension.
21:33:11 <ryao> arkeet: How would one translate the proof checker into a proof solver? I know that you can translate multiplication into factorization with boolean satisfiability, but I am not clear on how you would translate checking programs into solving problems.
21:33:42 <arkeet> ryao: easy. nondeterministically choose a proof to check.
21:33:44 <arkeet> and then check it.
21:33:59 <ryao> arkeet: More detail would be great. I am crazy enough to try it for fun.
21:34:05 <arkeet> do you know what NP is?
21:34:08 <ryao> Yes.
21:34:10 <monochrom> enumerate all proof attempts. check each one.
21:34:14 <arkeet> ^
21:34:18 <ryao> I just don't know how to enumerate all proof attempts. :/
21:34:22 <arkeet> me either.
21:34:29 <monochrom> I do.
21:34:33 <ryao> monochrom: Tell me more.
21:34:36 <arkeet> I don't have a nondeterministic turing machine.
21:34:49 <ryao> arkeet: You don't need one. You can still construct the program to run on it without one.
21:34:50 <elliott> we're still arguing about the halting problem?
21:34:56 <elliott> i looked away from this channel half an hour ago :P
21:35:04 <ryao> elliott: No. We are talking about how to put mathematicians out of work.
21:35:16 <arkeet> yes, but it won't run in polynomial time on a deterministic TM. (unless P = NP)
21:35:22 <napping> any plan where step 1 is "prove P = NP" is a bad plan
21:35:29 <arkeet> that's the point.
21:35:40 <ryao> napping: Have you ever wanted to know something for the sake of knowing it?
21:35:43 <ARCADIVS> How much work would it be/is it possible to describe a data type in Haskell resembling this formal definition of a formal grammar? https://en.wikipedia.org/wiki/Formal_grammar#Formal_definition
21:35:44 <arkeet> NP problems are precisely the ones that can be decided in polynomial time by a nondeterministic TM.
21:35:46 <ryao> i.e. academic curiosity.
21:35:56 <arkeet> this is basically a definition.
21:36:00 <ryao> arkeet: This is true.
21:36:03 <monochrom> enumerate the number sequence 0, 1, 2, ...  treat each number as a bit string. decode bit string by utf-8 to unicode characters. that is a proof attempt. oh, it may have syntax errors? that's fine, the checker will do the right thing anyway.
21:36:19 <arkeet> so, suppose I have a (deterministic) TM that can check if P is a proof of T.
21:36:28 <ryao> monochrom: I am beginning to think I will have more luck studying ZFC.
21:36:29 <monochrom> if you don't like utf-8, ascii may work just as well
21:36:45 <ryao> arkeet: The part of checking if P is a proof is where I am lost.
21:36:55 <ryao> I do not know how to recognize a proof. -_-
21:37:14 <arkeet> well, we can come back to that.
21:37:14 <ryao> At least not in a way that I can tell a computer to do it.
21:37:22 <coppro> you can formulate it in various ways
21:37:30 <arkeet> but supposing I had a thing, then I can tell a nondeterministic TM to, given T, nondeterministically choose a proof P, and check if it is a proof of T.
21:37:44 <arkeet> if one branch terminates with "yes", then return "yes".
21:37:53 <ARCADIVS> If anyone is wondering about my question I'm trying to see how closely Haskell can map to purely mathematical concepts.
21:37:56 <coppro> you can pick a logic to work in and evaluate proofs purely syntactically
21:37:57 <arkeet> thus, if proof checking is in P, then proof constriction is in NP.
21:37:58 <elliott> perhaps this is #haskell-blah material?
21:38:03 <arkeet> perhaps.
21:38:06 <napping> anyone know what the second [Int] argument to ShAAppl in Aterm.AbstractSyntax means?
21:38:07 <arkeet> construction*
21:38:34 <ryao> elliott: People here are brilliant, so I thought I would ask some of my more profound questions and see what answers I get.
21:38:59 <arkeet> anyway, it's not hard to check a proof.
21:39:05 <monochrom> #haskell-blah has brilliant people too. for example me.
21:39:11 <arkeet> do the steps follow logically? does the conclusion coincide with that which you wanted to prove?
21:39:13 <ryao> I will be hanging out here more often... for programming related things. I just happened to have proof checking on my mind.
21:39:19 <ryao> I did not know #haskell-blah existed.
21:39:28 <elliott> @remember monochrom #haskell-blah has brilliant people too. for example me.
21:39:28 <lambdabot> Done.
21:39:28 <arkeet> this really does belong there.
21:39:37 <ryao> Lets go there now.
21:41:47 <sw2wolf> @hoogle MonadIO
21:41:48 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
21:41:48 <lambdabot> package monadIO
21:41:50 * hackagebot fsnotify 0.0.8 - Cross platform library for file creation, modification,  and deletion notification.  http://hackage.haskell.org/package/fsnotify-0.0.8 (GregWeber)
21:42:13 <sw2wolf> @package MonadIO
21:42:14 <lambdabot> http://hackage.haskell.org/package/MonadIO
21:55:00 <ARCADIVS> Wikipedia tells me: "type theory generally refers to a class of formal systems, some of which can serve as alternatives to naive set theory as a foundation for all mathematics." Are haskell's data types modelled after type theory? Can Haskell's data types be used like the sets of set theory?
21:55:07 <monochrom> ARCADIVS: Haskell is a programming language, not a theorem prover or Mathematica. "closely" is subjective, and I say: not closely. having said that, http://www.grammaticalframework.org/ is a program written in Haskell for you to enter a formal grammar and then play with it, therefore representing formal grammar must be possible in Haskell.
21:55:38 <napping> monochrom: that's not representing it in types, though
21:58:51 <monochrom> sure? suppose someone asks, "how to write a data type for trees", do you try to write type-level trees?
21:59:22 <monochrom> or does it merely mean the very "mundane": a data type whose values are trees?
21:59:52 <monochrom> GF clearly has a data type inside, whose values are grammars.
22:00:11 <napping> it's only clear it has a type, some of whose values are grammars
22:00:15 <ARCADIVS> Can I express the union of types in Haskell like the union of sets?
22:00:34 <monochrom> I don't think "type-level grammars" are asked for.
22:00:59 <napping> any language has a type of "what you want, plus junk"
22:01:04 <ARCADIVS> I'm just trying to understand /how/ close if at all haskell types are to sets.
22:01:19 <napping> they are much closer to types than sets
22:01:39 <napping> you can't take a plain union of types in the kinds of stronger type theories mentioned there either
22:01:50 <napping> but Either a b lets you have a Left a or Right b
22:03:33 <napping> monochrom: whether you can write a type whose values are exactly the balanced binary trees is a different question from whether you have dependent types/make type level trees
22:04:48 <monochrom> I agree.
22:05:08 <monochrom> the second kind of question is not asked.
22:05:23 <ARCADIVS> Why don't I see sets theory as the type system for a programming language? What's preventing that?
22:05:35 <ARCADIVS> *set theory
22:06:07 <nbouscal> Why would that be useful?
22:07:09 <nbouscal> Or more to the point, why would that be more useful than using type theory?
22:08:01 <monochrom> set theory is really hard
22:08:19 <ARCADIVS> It would be useful because the mathematical concepts I constantly read about are expressed in set theory as the foundation not type theory. So is there something wrong with set theory?
22:08:20 <azimux> playing around with Haskell a bit, and was trying to make two values that "reference" each other, is this impossible?
22:08:39 <azimux> such as a doubly-linked list kind of construct
22:08:51 <napping> > let a = ('a',b,a); b = ('b',a,b) in a
22:08:52 <lambdabot>   Occurs check: cannot construct the infinite type:
22:08:53 <lambdabot>    t2 = (GHC.Types.Char, ...
22:08:54 <nbouscal> ARCADIVS: You just happen to be reading about set theory. If you read about category instead then you can see types as forming an initial algebra and do all the mathematical reasoning you like.
22:09:01 <jfischoff> ARCADIVS: set theory wasn't designed to have proofs verified by computers (either was type error …)
22:09:11 <nbouscal> category theory*
22:09:12 <jfischoff> s/error/theory
22:09:31 <monochrom> "x = 0 : y", "y = 1 : x". x and y are two values, and they reference each other.
22:09:46 <cmears> > let { xs = 1:ys ; ys = 2:xs } in take 10 xs
22:09:48 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
22:10:02 <nbouscal> Set theory and category theory are both sufficient to build whatever you like. Haskell (as you can probably tell pretty easily) tends to use category theory quite a lot.
22:10:09 <ARCADIVS> jfischoff: so is type theory more rigorous?
22:10:23 <nbouscal> they're both maths, so they're both rigorous
22:10:50 <jfischoff> ARCADIVS: The Martin-lof constructive kind I would yes
22:11:06 <jfischoff> but I can say that because I know very little about it ;)
22:12:33 <dolio> Not all types are initial algebras.
22:12:37 <ARCADIVS> Should I learn the basics of category theory to better understand this situation?
22:13:01 <nbouscal> ARCADIVS: Category theory won't go amiss, but I'm not sure exactly what situation you're trying to understand.
22:13:42 <jfischoff> ARCADIVS: I don't think so. If you want to see type theory in action Agda is one avenue, but I don't know if it is the right first step
22:13:52 <dolio> Lots of mathematicians pay lip service to the idea that their domains could be formalized in set theory, and then none of them do it, and keep working directly with their domain concepts.
22:14:12 <coppro> ^
22:14:16 <coppro> actually formalizing things is effort
22:14:19 <dolio> So you should take the 'everything is based in set theory' with a grain of salt.
22:14:39 <coppro> not to mention that there are often like 15 equivalent definitions
22:14:51 <nbouscal> Everything can be based in set theory, but equally everything can be based in category theory.
22:14:54 <ARCADIVS> I just see things described in terms of set theory all the time, so when I want to express those concepts in a programming language I'm a little disappointed.
22:14:56 <coppro> and they are convenient for different things
22:15:10 <jfischoff> mathematically reasoning tends to work out, but is more informal then what is necessary to get mechanical proof compiling
22:15:14 <coppro> but proving the different versions of every theorem for every equivalent definition would suck
22:15:24 <nbouscal> You should distinguish between being described in terms of set theory vs. being described using the language of naive set theory
22:15:43 <coppro> that too
22:15:48 <nbouscal> the language of naive set theory is simply a convenient notation, so it is used with more frequency than any actual set theoretic formalizations
22:16:01 <jfischoff> ARCADIVS: what is an example of something you are struggling with
22:20:52 <nbouscal> ARCADIVS: If you want to describe types via set theory, build algebra and then you can talk about the set of types as a commutative semiring
22:20:57 <danblick> Wondering if I've messed this up somehow... If I think of all the functions from a finite set A to another finite set B, I think there should be |B|^|A| such functions (where |X| is the number of elements in the set X).  If consider all the functions A -> (B -> C), I'd imagine there are (|C|^|B|)^|A| of them... but for functions (A * B) -> C, there would be |C|^|A*B| of them.  Seems like those should be the same?
22:21:12 <shachaf> danblick: Yep.
22:21:21 <nbouscal> (c^b)^a = c^(ba)
22:21:27 <shachaf> danblick: (a -> (b -> c)) ~ ((a * b) -> c)
22:21:31 <ARCADIVS> jfischoff: I'm sorry I can't come up with a good example right now.
22:21:49 <shachaf> Where "a * b" is spelled "(a, b)" in Haskell.
22:21:52 <nbouscal> though when talking types that equality is really isomorphism
22:22:25 <jfischoff> ARCADIVS: well when you do ...
22:23:40 <danblick> that helps; thanks
22:24:08 <nbouscal> danblick: http://chris-taylor.github.com/blog/2013/02/10/the-algebra-of-algebraic-data-types/ goes into that and quite a bit more
22:33:43 * wollw just discovers the ability to create modified records by invoking the record name...
22:33:53 <wollw> Wish I've known about that before.
22:33:57 <wollw> i'd*
22:36:16 <hpaste> Rohit pasted “installing Yesod” at http://hpaste.org/86061
22:36:40 <rohitkav> Hi Team, is their any issue with this yesod installing
22:36:51 <rohitkav> Since I see lot of things which says permission denied
22:38:28 <wollw> what are the permissions on /home/rohit/.cabal/share/doc ?
22:40:10 <azimux> thanks napping, that seems to work
22:44:27 <mm_freak> there we go
22:44:42 <mm_freak> fastirc now parses 310 MiB/s =)
22:44:57 <mm_freak> that's more like it
22:50:51 <mm_freak> the big secret:  i switched from attoparsec to StateT ByteString Maybe
22:51:13 <pharaun> manual parsing?
22:51:39 <mm_freak> yeah…  pretty much looks like attoparsec/parsec code, but with some manual boilerplate at the bottom
22:52:37 <mm_freak> the benefit is that i can keep the bytestrings intact in memory…  this gets rid of most of allocations
22:52:52 <ARCADIVS> jfischoff: I just found this free book: http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ Type Theory and Functional Programming. Maybe it will help me understand some things.
22:54:01 <elliott> mm_freak: maybe you can do even better with ST and avoiding ByteString itself or something
22:55:59 <jfischoff> ARCADIVS: I tried reading page 59 and it is not that readable. Your mileage may vary
22:57:20 <ARCADIVS> As in legible?
22:57:35 <jfischoff> as in the style
22:58:32 <ARCADIVS> If you know of some better reading material, even if it's not free, I would be interested in it.
22:58:52 <gienah> ARCADIVS: on type theory and proving the correctness of programs?
23:00:06 <ARCADIVS> On type theory specifically. I wouldn't mind reading about proving program correctness.
23:01:36 <gienah> ARCADIVS: starting with the video by Andrew Tolmach on the 2nd page: http://vimeo.com/album/1497795
23:02:20 <ARCADIVS> Thanks. :)
23:02:28 <jfischoff> ^ Those look great (I am judging by the speakers)
23:02:42 <gienah> ARCADIVS: coq code and the course is here: http://www.cis.upenn.edu/~bcpierce/sf/
23:02:52 <hpaste> sw2wolf pasted “Failed to install wai-app-file-cgi-0.8.3” at http://hpaste.org/86062
23:03:13 <jfischoff> Personally I like Pierce's material
23:04:34 <mm_freak> elliott: i just switched from ByteString to its Builder
23:04:38 <mm_freak> didn't make a speed difference
23:05:46 <elliott> mm_freak: I meant switching from bytestring to tracking the actual underlying array and an index into it
23:06:53 * hackagebot warp-static 1.3.0.1 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-1.3.0.1 (MichaelSnoyman)
23:06:55 * hackagebot lgtk 0.3.1 - lens-based GUI with Gtk backend  http://hackage.haskell.org/package/lgtk-0.3.1 (PeterDivianszky)
23:07:12 <mm_freak> elliott: i know what you meant, but i don't expect a big improvement by doing that, and it would make the code really ugly
23:07:12 <ARCADIVS> gienah: this looks great.
23:07:51 <ARCADIVS> There needs to be something like this on Coursera.
23:08:50 <hpaste> Ghoul pasted “unwrap getProgName from Monad?” at http://hpaste.org/86063
23:16:53 * hackagebot wai-test 1.3.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.3.1 (MichaelSnoyman)
23:18:06 <Ghoul_> Gah!
23:18:32 <Ghoul_> How can I unwrap getProgName without a new line
23:18:57 <Ghoul_> I tried <<='ing onto ++ and stuff, but I don't really understand how it works
23:20:10 <shachaf> "without a new line" isn't a good optimization goal.
23:20:18 <shachaf> Try to do it with a new line first.
23:21:53 <Kaidelong> what's the type of usageInfo?
23:21:53 * hackagebot x11-xim 0.0.8 - A binding to the xim of X11 graphics library  http://hackage.haskell.org/package/x11-xim-0.0.8 (YoshikuniJujo)
23:21:58 <sw2wolf> How to fix such a issue: http://hpaste.org/86062 ?!
23:22:08 <Ghoul_> How do I unwrap a string from an IOString
23:22:18 <Ghoul_> ie: where usage = "Usage: " ++ getProgName ++ " [-options] file" -- doesn't work
23:22:23 <Kaidelong> Ghoul_: unsafePerformIO
23:22:30 <Kaidelong> as you might tell from the name
23:22:45 <Kaidelong> if you need to unwrap a string from an IO string, you are likely doing something wrong
23:22:48 <Kaidelong> rather
23:23:07 <Ghoul_> w/o the unsafe preferrably
23:23:26 <Kaidelong> since your return type is IO (Options, [String]) have your over case have getProgName >>= in front of it
23:23:48 <Kaidelong> in other words, bind getProgName into the second case and make usage a pure function
23:24:04 <shachaf> Kaidelong: Please don't give people answers like that.
23:24:17 <Kaidelong> usage progName = "Usage: " ++ progName ++ " [-options] file"
23:24:37 <Kaidelong> getProgName >>= \progName -> ... ... (usage progName) ...
23:24:58 <Ghoul_> gah
23:25:01 <Ghoul_> hmm
23:25:13 <Ghoul_> Is this right?
23:25:16 <Ghoul_>         (_, _, errs) -> ioError . userError $ concat errs ++ usageInfo (usage >>= getProgName) options
23:25:16 <Ghoul_>         where usage invoc = "Usage: " ++ invoc ++ " [-options] file"
23:25:36 <Kaidelong> no
23:26:19 <Kaidelong> getProgName >>= has to be in front of a thing that has the type a -> IO b
23:26:24 <napping> you can't do I/O in the middle of expressions
23:26:43 * sw2wolf once a bad package is encountered in hackage, it seems it is hard to fix ?!
23:26:45 <Kaidelong> try doing what I suggested
23:26:46 <napping> make a separate statement progNAme <- getProgName
23:26:53 * hackagebot raven-haskell-scotty 0.1.0.1 - Sentry http interface for Scotty web server.  http://hackage.haskell.org/package/raven-haskell-scotty-0.1.0.1 (AlexanderBondarenko)
23:26:55 * hackagebot lgtk 0.3.2 - lens-based GUI with Gtk backend  http://hackage.haskell.org/package/lgtk-0.3.2 (PeterDivianszky)
23:27:24 <lavorno> sw2wolf: your stuff seems correct at the first look
23:27:29 <Kaidelong> basically the strategy is, since you are returning an IO anyway
23:27:43 <Kaidelong> make a function in the form String -> IO (Options, [String])
23:27:53 <Kaidelong> and then bind the input of getProgName into that function
23:28:01 <Kaidelong> to get a result IO (Options, [String])
23:28:05 <Ghoul_> Should I be able to do this
23:28:08 <Ghoul_> (getProgName >>= usage)
23:28:20 <sw2wolf> lavorno: in fact, the quality of packages  is NOT assured
23:28:24 <Kaidelong> no, but you could do
23:28:36 <Kaidelong> getProgName >>= \x -> return usage x
23:28:41 <Ghoul_> your lambda example above is confusing because I don't see the difference between the two
23:28:42 <Kaidelong> (usage x)*
23:28:46 <lavorno> sw2wolf: i was talkinga bout the hpaste
23:29:02 <napping> Ghoul_: use :t in ghci
23:29:18 <Ghoul_> Do I really need another lambda.. usage is already another local function
23:29:24 <elliott> just use do notation
23:29:27 <Ghoul_> napping: :t doesn't solve problems
23:29:29 <Kaidelong> what is the type of usage
23:29:30 <elliott> do { name <- getProgName; return (usage x) }
23:29:33 <elliott> simple.
23:29:38 <Ghoul_> I changed it to:
23:29:38 <Ghoul_> where usage invoc = "Usage: " ++ invoc ++ " [-options] file"
23:29:41 <napping> you can skip asking us about anything that doesn't even typecheck
23:29:41 <sw2wolf> lavorno: how to fix http://hpaste.org/86062?  seems no proper way ?
23:29:52 <elliott> s/usage x/usage name/.
23:29:56 <napping> and see stuff like that (>>=) has a type m a -> (a -> m b) -> m b,
23:29:59 <Kaidelong> napping getting the types right is part of learning
23:30:10 <lavorno> sw2wolf: i assume you mean Data.List in the imports ?
23:30:14 <napping> so using it to combine getProgName :: IO String and usage :: String -> String will not work
23:30:32 <lavorno> other than that i don't see any problem with the code (not talking whether it does whatever u want it to do)
23:30:34 <Kaidelong> anyway Ghoul_ for practice
23:30:51 <napping> yes, and learning goes faster if ghci instantly tells you whether types fit, rather than typing expressions into IRC and waiting
23:31:04 <Kaidelong> rewrite parseOptions so that it has type String -> [String] -> IO (Options, [String])
23:31:08 <Ghoul_> napping: thats dumb and I cbf explaining why
23:31:19 <elliott> napping is right.
23:31:27 <sw2wolf> lavorno: i mean how to install  wai-app-file-cgi-0.8.3 using cabal ?
23:31:30 <elliott> also telling people who are trying to help that their advice is dumb is rude and unlikely to get you more advice...
23:31:48 <Kaidelong> absolutely true, be nice online and show good manners
23:32:02 <napping> Ghoul_: just asking us "can I do this?" is pointless
23:32:02 <Ghoul_> elliott: he's not trying to help me at all
23:32:17 <sw2wolf> @wn pointless
23:32:18 <lambdabot> *** "pointless" wn "WordNet (r) 3.0 (2006)"
23:32:18 <Ghoul_> Kaidelong: sec
23:32:18 <lambdabot> pointless
23:32:18 <lambdabot>     adj 1: not having a point especially a sharp point; "my pencils
23:32:18 <lambdabot>            are all pointless" [syn: {pointless}, {unpointed}] [ant:
23:32:19 <lambdabot>            {pointed}]
23:32:20 <lambdabot> [5 @more lines]
23:32:21 <elliott> true. I think napping is trying to help you help yourself.
23:32:38 <lavorno> sw2wolf: we are talking abt diff things. i was talking about your prev post : sw2wolf: How to fix such a issue: http://hpaste.org/86062 ?!
23:32:39 <elliott> which is far more valuable.
23:32:42 <napping> trying it would tell you "no"
23:32:54 <napping> "how can I fix this" might be useful
23:33:10 <Kaidelong> tactually
23:33:22 <shachaf> Ghoul_: Be nice. People are trying to help you.
23:33:26 <Kaidelong> [String] -> String -> IO (Options, [String]) is a better idea
23:33:44 <Kaidelong> where the extra string you are taking will be the output of getProgName
23:33:46 <napping> and I think I've given you the most directly useful advice - call getProgName on a separate line, in a separate statement, and use the result in your expressions
23:36:44 <Ghoul_> I really shouldn't have to feed the invocation name to my function
23:36:49 <Kaidelong> @ty getLine >>= (f : [String] -> String -> IO (Options, String)) ["df","fk"]
23:36:50 <lambdabot>     Pattern syntax in expression context:
23:36:50 <lambdabot>         f : [String] -> String -> IO (Options, String)
23:37:02 <Kaidelong> @ty getLine >>= (f :: [String] -> String -> IO (Options, String)) ["df","fk"]
23:37:02 <elliott> what's wrong with napping's advice? you bind the variable on a separate line.
23:37:03 <lambdabot>     Not in scope: type constructor or class `Options'
23:37:04 <elliott> and then you use it.
23:37:07 <elliott> it's as simple as it gets.
23:37:13 <elliott> that's how IO works in Haskell.
23:37:15 <Kaidelong> Ghoul_: Actually, yes you should
23:37:21 <Ghoul_> elliott: that would require using do
23:37:29 <elliott> yes, you must use either do or (>>=)
23:37:31 <elliott> or something else equivalent
23:37:44 <Kaidelong> since you have to getProgName FIRST to get the result you want
23:37:57 <Kaidelong> you need to bind getProgName into parseOptions ahead of time
23:38:11 <elliott> if you don't like that, I suggest using it for a while. then it will start seeming perfectly acceptable, and later obviously necessary, once you understand Haskell's IO better.
23:38:12 <Kaidelong> hence why you feed it in
23:38:29 <Kaidelong> it's how you know that IO runs in the correct order
23:38:37 <Kaidelong> compare unix pipes
23:39:51 <Kaidelong> (and the big problem unsafePerformIO causes other than thwarting type safety is exactly that it allows IO to happen out of order)
23:40:08 <Kaidelong> (or not at all)
23:40:31 <elliott> unsafePerformIO isn't even really a consideration here.
23:40:33 <elliott> it's in another universe.
23:40:41 <Ghoul_> Okay, I rewrote parseOptions to take the invocation as an argument but now theres monadey stuff and I have no idea how >>= is supposed to work with multiple arguments
23:40:43 <elliott> we shouldn't even be mentioning its existence.
23:40:55 <Ghoul_> main = print =<< (getArgs >>= getProgName >>= parseOptions) -- thus far
23:41:00 <elliott> Ghoul_: again I suggest using do... it abstracts away (>>=) with syntax sugar to make using it less awkward
23:41:01 <napping> why are you using >>= ?
23:41:10 <napping> then you need lambdas too
23:41:26 <Kaidelong> parseOptions <*> getProgName <*> getArgs
23:41:35 <Kaidelong> err
23:41:38 <Kaidelong> nope not quite
23:41:42 <napping> getProgName >>= \prog -> getProgName >>= \backupProg -> ... use both ...
23:41:46 <napping> if you really want, ick
23:42:13 <elliott> Ghoul_: or, IOW... what reason is there to not use do?
23:42:15 <Kaidelong> ty (<*>)
23:42:37 <sw2wolf> @ty (<*>)
23:42:38 <Kaidelong> well I remember what is wrong with that just fine
23:42:39 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:43:11 <Kaidelong> but yeah you could just use do
23:43:39 <Ghoul_> Now that it's an argument, surely its easy to just pipe multiple IO's into it
23:43:42 <Kaidelong> do { progName <- getProgName; args <- getArgs; parseOptions getProgName getArgs }
23:43:49 <Ghoul_> It's not supposed to be magical ._.
23:44:03 <Ghoul_> I can't monadic bind two IO Monads into one function>
23:44:05 <Ghoul_> *?
23:44:09 <Kaidelong> sure you can
23:44:15 <Kaidelong> isn't that what that do statement does?
23:44:24 <elliott> do isn't magical.
23:44:27 <elliott> do is very simple sugar.
23:44:27 <Kaidelong> err
23:44:30 <sw2wolf> @undo do { progName <- getProgName; args <- getArgs; parseOptions getProgName getArgs }
23:44:31 <lambdabot> getProgName >>= \ progName -> getArgs >>= \ args -> parseOptions getProgName getArgs
23:44:34 <napping> Ghoul_: you are the one insisting on looking at internals rather than doing things the usual way
23:44:42 <Kaidelong> I used the wrong names though
23:45:03 <Kaidelong> do { progName <- getProgName; args <- getArgs; parseOptions progName args }
23:45:09 <napping> if you're trying to learn how monads work in general that can help, but not if you just want to get IO and simple programs working
23:45:11 <Kaidelong> there we go
23:45:39 <napping> @undo do { progName <- getProgName; args <- getArgs; parseOptions progName args }
23:45:39 <lambdabot> getProgName >>= \ progName -> getArgs >>= \ args -> parseOptions progName args
23:45:41 <sw2wolf> do is just syntax sugar
23:46:02 <Kaidelong> but anyway a good rule of thumb is to write pure functions first, then fmap or >>= them over IO later
23:46:58 <sw2wolf> The key is monad !!!
23:47:02 <Kaidelong> I mean sure you likely won't use anything other than getProgName as the source of the binding but why not write as if though you can swap that out
23:49:22 <beaky> hello
23:49:40 <Ghoul_> Blegh, I used do.
23:49:52 <beaky> is there a formal name for a complex type like "data Student = Student Int String String [String]"
23:49:52 <napping> what's wrong with that?
23:49:53 <shachaf> How can you live with yourself?
23:50:06 <Ghoul_> Well, the whole thing increased by like 4 lines and now it looks fat
23:50:14 <Ghoul_> I think I might go kill myself now.
23:53:47 * sw2wolf bad luck to encounter wai-app-file-cgi-0.8.3 :(
23:53:53 <Ghoul_> :t snd
23:53:54 <lambdabot> (a, b) -> b
23:54:11 <sw2wolf> @package wai-app-file-cgi-0.8.3
23:54:15 <lambdabot> http://hackage.haskell.org/package/wai-app-file-cgi-0.8.3
23:54:50 <shachaf> fry :: c -> (a,b) -> (a,c)
23:55:04 <latermuse> Ghoul_ how will you kill yourself? death by lambda
23:55:35 <sw2wolf> @package mighttpd2
23:55:35 <lambdabot> http://hackage.haskell.org/package/mighttpd2
23:55:50 <Ghoul_> probably
23:56:31 <shachaf> sw2wolf: You talk to/via lambdabot an awful lot in this channel. What's the goal?
23:57:07 <sw2wolf> oh, forgot private :)
23:57:44 <sw2wolf> shachaf: are you the channel controller ?
23:58:13 <Ghoul_> When I added the 'do' ghc started automatically exporting it as a .o file rather than a .exe
23:58:34 <Kaidelong> ghc --make
23:58:37 <Kaidelong> I believe
23:58:49 <Kaidelong> although I'm rusty with using ghc and may be wrong
23:58:53 <elliott> Ghoul_: I am sure the "do" had nothing to do with that...
23:59:58 <shachaf> Kaidelong: ghc --make doesn't really do much, if anything, and hasn't for a while.
