00:01:04 <hpaste> haskell_noob pasted “some help?” at http://hpaste.org/84959
00:04:29 <Rotaerk> haskell_noob, why are you collapsing two lists of trees into a list of 2-tuples
00:05:17 <haskell_noob> cuz i was asked to create a zip function with the tree datatype that was given
00:06:37 <jozefg> haskell_noob: This doesn't make sense.. are you trying to zip the values in the tree?
00:06:45 <jozefg> Otherwise just use the built in zip
00:08:14 <Rotaerk> haskell_noob, you're probably supposed to zip a pair of trees into a new tree... but it looks like you're currently trying to do list-zipping but with the elements forced to be trees, only you're doing *that* incorrectly
00:11:53 <haskell_noob> Rotaerk, yes im very confused now
00:12:28 <Rotaerk> I'm guessing you actually want a function of signature:  Tree -> Tree -> Tree
00:12:54 <Rotaerk> err Tree a -> Tree b -> Tree (a,b)
00:13:01 <haskell_noob> yes that makes a lot more sense
00:13:41 <haskell_noob> thank you
00:17:47 <Wizek> What's the easyest way to set up OpenGL with Haskell on Ubuntu 12.10?
00:18:46 <Cale> Wizek: cabal install OpenGL ?
00:19:00 <Cale> Wizek: assuming that you have cabal-install set up.
00:20:34 <arkeet> opengl is part of the platform.
00:22:31 <Cale> I confess that it's been a long time since I last tried using Haskell Platform on Linux, but last I checked, it was easier just to install the GHC generic linux binary and then grab the cabal-install tarball from hackage and run the bootstrap.sh script in there.
00:22:44 <hpaste> sg pasted “functor weirdness” at http://hpaste.org/84960
00:22:55 <Cale> Also, 7.4.2, what?
00:22:56 <sg> i cannot for the life of me figure out why that won't typecheck
00:23:51 <arkeet> Sgeo: p x has type (a,String)
00:23:54 <arkeet> Sgeo: f has type a -> b.
00:24:02 <arkeet> (assuming fmap :: (a -> b) -> (f a -> f b)
00:24:13 <Cale> sg: Did you mean to actually use the function 'first' that you'd defined?
00:24:16 <arkeet> errrrrrr
00:24:21 <arkeet> p x is Maybe (a,String)
00:24:24 <sg> argh, yes
00:24:26 <arkeet> heh.
00:24:27 <sg> lol thank you Cale
00:25:17 <sw2wolf> @let centered = onCurr (center 150 66) >=> font "-*-helvetica-*-r-*-*-64-*-*-*-*-*-*-*" >=> addArgs ["-fg", "#80c0ff"] >=> addArgs ["-bg", "#000040"]
00:25:18 <lambdabot>  <local>:10:12: Not in scope: `onCurr'
00:25:18 <lambdabot>  
00:25:18 <lambdabot>  <local>:10:20:
00:25:18 <lambdabot>      Not in scope: `...
00:25:30 <hpaste> sg revised “functor weirdness”: “(fixed) functor weirdness” at http://hpaste.org/84960
00:25:45 <sg> is there any way to eliminate that lambda?
00:26:38 <arkeet> @pl \x -> fmap (first f) (p x)
00:26:38 <lambdabot> fmap (first f) . p
00:27:27 <arkeet> fmap (fmap (first f)) p
00:27:36 <arkeet> (fmap.fmap.first) f p
00:27:57 <arkeet> hello SECs.
00:28:22 <Rotaerk> fmap f = Parser . fmap (first f) . runParser
00:29:37 <Rotaerk> wait a sec, I'm dumb
00:30:34 <Rotaerk> nm, just sleepiness kicking in; that should work
00:31:21 <sw2wolf> what's the type of centered: http://paste.lisp.org/display/136434 ?
00:32:29 <sg> arkeet: i'm having a hard time grasping the equivalency of fmap (first f) . p and (fmap.fmap.first) f p
00:34:35 <Wizek> I may be having an xy problem then. I realized I have Graphics.Rendering.OpenGL installed but I don't really know how to use it, and I don't really find the cabal docs learner-friendly either. What I'd like is a simple api with which I can create a window and control the individual pixels it displays. Which is the simplest lib for this very purpose? (as in simple to install, learn and operate)
00:34:50 <arkeet> Sgeo: (.) (fmap (first f)) p
00:34:55 <arkeet> Sgeo: and fmap = (.)
00:35:05 <arkeet> it's silly
00:36:03 <Rotaerk> imo, the fmap . fmap . first expression is much less clear
00:36:08 <arkeet> I totally agree!
00:36:22 <shachaf> fmap fmap fmap fmap (fmap fmap) first f p x
00:36:23 <shachaf> hth
00:36:40 <sg> arkeet: ah, i see now. haha thank you...i'm learning haskell and this week has been my first exposure to functors
00:37:08 <luite> Wizek: you might like gloss
00:37:46 <arkeet> shachaf++ for being horrible.
00:38:13 <shachaf> Also valid:
00:38:14 <shachaf> fmap fmap fmap fmap (fmap fmap) fmap fmap fmap fmap first f p x
00:38:19 <shachaf> fmap fmap fmap fmap (fmap fmap) fmap fmap fmap fmap fmap fmap fmap fmap first f p x
00:38:23 <shachaf> etc.
00:38:29 <arkeet> :|
00:38:37 <Rotaerk> ..
00:38:40 <shachaf> I can't quite get rid of those last parentheses. :-(
00:41:08 <Rotaerk> (<$>) (<$>) (<$>) (<$>) ((<$>) (<$>)) (<$>) (<$>) (<$>) (<$>)  first f p x
00:41:33 <shachaf> arkeet: Get rid of the last parentheses for me.
00:41:52 <shachaf> Either that or talk about free monads and F-algebras.
00:42:06 <arkeet> fmap . fmap . first $ f p
00:42:07 <arkeet> there
00:42:33 <shachaf> Infix doesn't count.
00:44:01 <sw2wolf> @djiin (a -> m b) -> (b -> m c) -> a -> m c
00:44:01 <lambdabot> -- f cannot be realized.
00:51:00 <Rotaerk> what does djinn do
00:51:21 <arkeet> takes a type and, if possible, gives you something of that type.
00:51:27 <Rotaerk> ah
00:51:31 <Rotaerk> so like hoogle
00:51:32 <arkeet> @djinn (a -> b -> c) -> (a -> b) -> a -> c
00:51:32 <lambdabot> f a b c = a c (b c)
00:51:39 <arkeet> no, hoogle is a search.
00:51:51 <Rotaerk> oh, it builds the value of that type
00:52:01 <arkeet> @djinn (a -> c) -> (b -> c) -> Either a b -> c
00:52:01 <lambdabot> f a b c =
00:52:02 <lambdabot>     case c of
00:52:02 <lambdabot>     Left d -> a d
00:52:02 <lambdabot>     Right e -> b e
00:52:17 <Rotaerk> neat
00:55:21 <Radish> hey can i set a variable's value to otherwise?
00:55:29 <Radish> like where o = otherwise
00:55:43 <Radish> kinda silly but it would be great for keeping code clean
00:55:59 <Radish> otherwise being kinda unwieldly
00:56:01 <shachaf> @src otherwise
00:56:01 <lambdabot> otherwise = True
00:56:07 <shachaf> (Also: Did you try it?)
00:56:14 <Radish> so i can just set the variable to true?
00:56:25 <Radish> shachaf: there's a lot more to gain by asking
00:56:31 <shachaf> Try first, then ask.
00:56:37 <Radish> for example, I had assumed but was not sure otherwise == True
00:56:45 <arkeet> @src otherwise
00:56:45 <lambdabot> otherwise = True
00:56:46 <Radish> you guys tend to have little helpful factoids
00:56:52 <Radish> that undo my assumptinos
00:56:56 <Radish> anyway thanks
00:57:00 <Radish> does anyone else do this?
00:57:05 <Rotaerk> otherwise isn't anything special, not a keyword
00:57:14 <Radish> set something to true instead of use otherwise?
00:57:34 <Radish> Rotaerk: i love haskell for that, $ isn't either
00:57:55 <Cale> Radish: The definition of otherwise only exists so that you can use otherwise instead of True
00:57:56 <Radish> oh well, sorry to bother y'all. thanks
00:57:59 <Ralith> Radish: code has to be written once, but it may need to be read many times.
00:58:10 <Ralith> favor clarity over conciseness.
00:58:24 <Cale> (in guards)
00:58:24 <Ralith> renaming standard values impairs clarity.
00:58:48 <Cale> Well, here it's not so bad when used in the intended way
00:59:02 <Cale> | True = ...
00:59:04 <Cale> vs.
00:59:06 <Radish> Ralith: in this case it's like commenting otherwise
00:59:07 <Cale> | otherwise = ...
00:59:11 <arkeet> I prefer | True = ...
00:59:13 <arkeet> personally.
00:59:20 <Radish> arkeet: shorter
00:59:36 <Ralith> certainly | o = ... is not desirable.
01:00:08 <Radish> Ralith: just an example
01:00:35 <Radish> Ralith: i'm actually doing audio stuff and I want to do positive = and negative  =  instead of positive =  and otherwise =
01:00:41 <Radish> I'd say that's a fair use
01:01:19 <Ralith> sounds worse to me
01:01:25 <Ralith> instead of being unclear, it's misleading
01:01:40 <Ralith> but it's your code
01:01:49 <Radish> Ralith: i'll take it into consideration sir
01:01:55 <Radish> Ralith: thanks
01:01:59 <Radish> thank you everyone :)
01:02:07 <Radish> see this is why i use the channel :) :)
01:02:19 <Radish> working doesn't mean it's the right thing to do
01:04:08 <Ralith> if you have contrived to have 'positive :: Bool' available, you might be better advised to have 'negative = not positive'; that way behavior remains consistent under reordering.
01:05:50 <Radish> Ralith: was thinking about doing that data Sign = Positive | Negative
01:06:12 <arkeet> not Negative | Positive?
01:06:17 <Ralith> none of those is a Bool, so I don't see the relevance
01:06:17 <arkeet> then the derived Ord instance would do the right thing.
01:06:31 <Radish> arkeet: see, this is why I ask the chatroom :)
01:06:37 <arkeet> :p
01:06:42 <Radish> love you guys
01:06:59 <shachaf> Radish: I didn't say not to ask. I said to try first, then ask.
01:07:23 <Radish> shachaf: ah yes then I can say "is it a good idea to ..."
01:07:24 <shachaf> Learn to puzzle these things out, to find out how "otherwise" works by yourself and so on.
01:07:27 <Radish> smart
01:07:40 <Radish> I do with some things but not the easy stuff often lol :\
01:14:15 <jozefg> The joys of brute forcing a problem with the list monad
01:25:57 <sw2wolf> afternoon
01:29:10 <sg> @pl \x -> Just (a, x)
01:29:10 <lambdabot> Just . (,) a
01:32:07 <mauke> preflex: seen jfischoff
01:32:07 <preflex>  jfischoff was last seen on #haskell 5 hours, 18 minutes and 48 seconds ago, saying: c_wraith: shh ;)
01:38:02 <circle> how do I get haskell to ignore the fact I've redefined some library functions
01:40:28 <mgccl> How can type class work if we want to work with more than the input type? For example Eq a is good because (==) is defined only on a.
01:40:47 <coppro> mgccl: eh, what?
01:41:08 <jozefg> mgccl: Do you mean multi parameter type classes?
01:41:39 <mgccl> say if we want to create a data Super a b c, and we want some class to say Super a b c must have the operation +::a->b->c
01:44:21 <coppro> mgccl: do you mean http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/type-families.html#type-family-declarations ?
01:46:49 <mgccl> coppro: oh I see, that looks like it...
01:50:22 <mgccl> coppro: Thanks. This is what I'm looking for. I spend way too long trying to use type classes for this.
01:50:30 <emzi> Hi; Is there "subtitle" for the videos linked here: http://www.haskell.org/haskellwiki/Video_presentations ? I'm searching for a new good video-course (about faskell) with english subtitle, do you know any one?
01:53:29 <circle> how do I get haskell to ignore the fact I've redefined some library functions
01:54:31 <luite> circle: hide them from your imports, or import them qualified
01:54:39 <circle> how would I do that?
01:55:12 <luite> uh
01:55:31 <luite> is it from Prelude?
01:55:34 <nxorg8> :w
01:55:59 <circle> yes
01:56:00 <circle> it is
01:56:37 <luite> circle: oh then you should probably choose differnt names. but you can import Prelude hiding (something)
01:56:39 <mauke> import Prelude hiding (abs, sort, fleshOfUnbornChildren)
01:56:53 <circle> thank you
02:04:03 <hwb> Hi everybody! I have a list of functions [f1, f2, f3] and would like to apply them to a single value v to get [f1 v, f2 v, f3 v]. There must be an elegant way to write this
02:04:21 <mauke> sequence fs x
02:05:30 <hwb> thanks a lot, mauke
02:05:47 <no-n> or map ($v) fs, right?
02:05:52 <mauke> > sequence [f, g, h] x
02:05:53 <lambdabot>   Ambiguous occurrence `x'
02:05:53 <lambdabot>  It could refer to either `L.x', defined at <local...
02:05:57 <mauke> @undefine
02:05:58 <mauke> > sequence [f, g, h] x
02:05:59 <lambdabot>   Ambiguous type variable `a0' in the constraints:
02:05:59 <lambdabot>    (GHC.Show.Show a0)
02:05:59 <lambdabot>     ...
02:06:05 <mauke> > sequence [f, g, h] x :: [Expr]
02:06:06 <lambdabot>   [f x,g x,h x]
02:06:22 <mauke> > map ($ x) [f, g, h] :: [Expr]
02:06:24 <lambdabot>   [f x,g x,h x]
02:06:55 <hwb> oh, yes, no-n, thank you too
02:07:09 <hwb> this fits even better in the place I'm using it
02:07:17 <hwb> why didn't I think of that
02:07:19 <no-n> np =]
02:07:27 <no-n> I remembered it from learn you a haskell
02:08:29 <mauke> > [t x | t <- [f, g, h]] :: [Expr]
02:08:31 <lambdabot>   [f x,g x,h x]
02:09:04 <mauke> > do { t <- [f, g, h]; return (t x) } :: [Expr]
02:09:06 <lambdabot>   [f x,g x,h x]
02:09:48 <no-n> what software is lambdabot using to do that? with symbols and Expr?
02:10:52 <mauke> heh
02:10:58 <mauke> a normal haskell module
02:11:28 <mauke> http://hackage.haskell.org/packages/archive/simple-reflect/0.3.1/doc/html/Debug-SimpleReflect.html
02:11:31 <mauke> this one
02:12:16 <no-n> ahh. ty
02:14:20 <no-n> I do not seem to have it
02:32:16 <sw2wolf> `ghci` from xterm will allow <TAB> key to auto complete input. However, `ghci` from emacs 'async-shell-command doesnot allow auto  completing. why ?
02:48:01 <Kinnison_> sw2wolf: mostly because emacs' terminal isn't a proper pty so most repls turn off their interactivity tweaks
02:49:12 <Kinnison_> sw2wolf: there are tweaks and modes out there to help, but nothing beats running a proper terminal with ghci in it (IMO)
02:49:58 <sw2wolf> Kinnison_: yeah, i have to use xterm to run ghci now
02:50:58 <sg> i don't understand how i'm supposed to implement this applicative
02:51:25 <arkeet> sg: which applicative?
02:52:06 <hpaste> sg pasted “applicative” at http://hpaste.org/84963
02:52:06 <hpaste> sg pasted “applicative” at http://hpaste.org/84964
02:53:25 <hpaste> killy9999 pasted “Exception with unboxed values” at http://hpaste.org/84965
02:53:44 <sg> arkeet: see my last paste ^^
02:53:56 <killy9999> I have these two almost identical pieces of code
02:54:15 <killy9999> the difference is that one does explicit unboxing/reboxing while the other does not
02:54:43 <killy9999> and the version doing the unboxing produces an exception :-/
02:55:26 <killy9999> I am obviously missing something here, because I believe that the two pieces of code should be identicak
02:55:36 <killy9999> s/identicak/equivalent/
02:57:16 <shachaf> killy9999: And if you make it !e instead of e?
02:57:45 <shachaf> You should know how "where" works. Look up the rules.
02:59:07 <huad> length of strings is static or dynamic ?
03:00:03 <killy9999> shachaf: if I make !e it is exactly the same
03:00:18 <shachaf> There you go. It has nothing to do with I#
03:00:37 <shachaf> It has to do with the behavior of "where", which isn't as you expect.
03:01:07 <sipa> huad: strings are lists of characters
03:01:17 <killy9999> I don't see where I went wrong with that.... especially that the former version (without I#) works fine
03:01:30 <sipa> huad: lists are linked lists, so they don't even technically have an individual length
03:01:40 <shachaf> killy9999: Oh, by "exactly the same" you mean the two pieces of code behave differently?
03:01:58 <huad> sipa: thanks
03:02:17 <killy9999> shachaf: fixed
03:02:24 <killy9999> shachaf: yes :)
03:02:31 <shachaf> fixed?
03:02:38 <killy9999> I used let instead of where
03:02:45 <huad> sipa: so lists are linked lists, is it have pointer like C or pass references like Java
03:02:47 <shachaf> OK.
03:02:50 <shachaf> Do you see what went wrong?
03:02:55 <killy9999> now I'm scratching my head trying to figure out what I did wrong
03:03:07 <killy9999> haha, nope, I guess I need a moment for that
03:03:19 <shachaf> killy9999: Here's a fun game: How far left can you indent that "where" before you get an error?
03:03:23 <sipa> huad: a list is either [] (the empty list), or (a:as), where a is a list element and as is another list
03:03:31 <shachaf> Make a prediction and then test it.
03:03:40 <killy9999> shachaf: is that related to my mistake?
03:04:06 <sipa> huad: how that is represented at runtime is implemented-defined, but you shouldn't think of it in that way
03:04:11 <shachaf> killy9999: Maybe.
03:04:28 <sipa> huad: you can't (destructively) modify data anyway, only transform it
03:05:05 <killy9999> hm... index in the Haskell Report does not have entry for "where"...
03:05:44 <sipa> killy9999: search for 'where' here: http://www.haskell.org/onlinereport/decls.html
03:06:21 <sipa> killy9999: apologies, that is not the right where
03:07:04 <killy9999> sipa: I have the PDF version of the report, the problem is that "where" is a rather common word...
03:07:33 <shachaf> killy9999: Have you figured out an answer to my question yet? :-)
03:07:49 <shachaf> Not that reading the Report is a bad idea.
03:07:59 <huad> sipa: i did a search. There is pointer in haskell. Why we use pointers?
03:08:46 <sipa> huad: have you done a haskell tutorial, like lyah?
03:09:05 <killy9999> shachaf: no, not yet
03:09:29 <typoclass> sg: could you add the compiler's error message to your hpaste?
03:09:32 <arkeet> @where lyah
03:09:32 <lambdabot> http://www.learnyouahaskell.com/
03:10:54 <killy9999> shachaf: I am able to indent where a lot and I don't get an error
03:11:44 <shachaf> killy9999: How far to the *left*.
03:11:48 <killy9999> no, wait... left not right
03:11:48 <shachaf> I.e. how much can you unindent it.
03:12:16 * hackagebot hspec 1.5.2 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.5.2 (SimonHengel)
03:12:20 <shachaf> Alternative: Convert the program from layout to { } ;
03:12:48 <huad> sipa: i begin learnahaskell but i didn't advance yet. I have a question at my homework that asks is there any pointer type in haskell
03:12:55 <killy9999> shachafL OK, where must be indented more than my go function
03:13:09 <shachaf> killy9999: Yes.
03:13:20 <shachaf> In particular it's attached to the entire "go" function, not to one of the | cases.
03:13:23 <typoclass> sg: could you add the compiler's error message to your hpaste?
03:13:34 <killy9999> shachaf: right, now I see
03:13:55 <m_hyperbolic> Is there a standard function for taking a list like [[a,b],[c,d]] and making it into [(a,b),(c,d)] ?
03:14:09 <arkeet> m_hyperbolic: no. such a thing is unsafe anyway.
03:14:12 <sipa> huad: perhaps you should learn more about how haskell works before you can answer the question correctly :)
03:14:14 <arkeet> (what if the inner lists didn't have length 2?)
03:14:36 <killy9999> shachaf: thanks. That was tricky.
03:14:41 <huad> sipa: thanks
03:14:46 <m_hyperbolic> arkeet: Well I have control over the lists, and know only lists of length 2 get passed
03:14:49 <killy9999> Still I don't see where the report says that...
03:15:08 <shachaf> m_hyperbolic: Then make tuples in the first place.
03:15:09 <arkeet> m_hyperbolic: well, you can always write a function \[x,y] -> (x,y)
03:15:16 <arkeet> but
03:15:20 <sipa> @pl \[x,y] -> (x,y)
03:15:20 <lambdabot> (line 1, column 2):
03:15:20 <lambdabot> unexpected "["
03:15:20 <lambdabot> expecting pattern
03:15:21 <shachaf> Alternatively: map (\[x,y] -> (x,y))
03:15:39 <arkeet> ideally you'd avoid that situation in the first place.
03:15:52 <sipa> @pl \(a:b:_) -> (a,b)
03:15:53 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
03:15:59 <sipa> ... that's one way
03:16:12 <shachaf> Ideally you'll listen to arkeet.
03:16:22 <arkeet> no, don't listen to me, listen to shachaf
03:16:36 <sipa> ideally you listen to both, or neither
03:16:47 <sipa> especially when they're contradicting eachother
03:17:03 <m_hyperbolic> I'll make the function, and then avoid the situation
03:17:16 * hackagebot network-metrics 0.3.0 - Send metrics to Ganglia, Graphite, and statsd.  http://hackage.haskell.org/package/network-metrics-0.3.0 (KimAltintop)
03:24:31 <killy9999> cd /dane/uczelnia/projekty/sandbox/haskell/fusion
03:24:31 <killy9999> irssi
03:27:51 <arkeet> :t set (partsOf both) ?? (undefined,undefined)
03:27:53 <lambdabot> [a] -> (a, a)
03:28:03 <arkeet> :t set (partsOf each) ?? (undefined,undefined,undefined)
03:28:04 <lambdabot> [b3] -> (b3, b3, b3)
03:31:31 <no-n> I don't have Debug.SimpleReflection on my compute,r how do I get it?
03:34:00 <takemitsu> no-n: Install the simple-reflect package.
03:34:34 <typoclass> no-n: you can also use lambdabot privately. try "/query lambdabot"
03:34:47 <no-n> ty
03:42:17 * hackagebot hspec-meta 1.5.2 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.5.2 (SimonHengel)
03:53:14 <mvj4> @djinn (Monad m, MonadTrans t) => EitherT e m a -> EitherT e (t m) a
03:53:14 <lambdabot> Error: Undefined type EitherT
03:53:37 <arkeet> djinn doesn't know about typeclasses.
03:54:11 <mvj4> ah, right.
04:00:18 <supki> @djinn Eq a => a -> a -> Bool
04:00:19 <lambdabot> f = (==)
04:08:10 <merijn> Anyone know the required voodo for compiling the unix package under cygwin?
04:13:58 <sg[]> so as part of my homework, we're building a very basic parser, and i am having troubles implementing the Applicative typeclass for my parser type
04:15:54 <typoclass> sg[]: right. could you click 'annotate' on your hpaste and add the compiler's error message?
04:15:56 <hpaste> sg pasted “applicative ” at http://hpaste.org/84972
04:16:39 <sg[]> sorry. i've been drifting in and out of sleep all morning :(
04:17:37 <ramses_> sg[]: Nothing has the wrong type there
04:18:05 <ramses_> it needs to have the same type as the second argument to "maybe"
04:18:22 <typoclass> sg[]: some information for you -- http://www.youtube.com/watch?v=uiz80CuDN8Y
04:18:28 <sg[]> see this is where i'm running into problems. i don't know how to write <*> so that it composes the other two parser elements correctly
04:18:50 <huad> Can pointers in haskell be used to manipulate data in haskell ? Like C
04:20:10 <typoclass> sg[]: when you use newtype, the 'runParser' function implicitly gets a Parser as the first argument. so the full signature will be something like Parser -> String -> Maybe (a, String)
04:21:48 <typoclass> huad: haskell has facilities to call c code, and that includes the ability to work with pointers. but it's not really used in haskell-only code
04:22:20 * hackagebot doctest 0.9.6 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.6 (SimonHengel)
04:23:47 <huad> typoclass: thanks this all i want to know.
04:24:37 <sg[]> typoclass: i see that but i still don't understand how to write <*>
04:26:57 <ramses_> sg[]: start with writing out the specialised type
04:29:31 <sg[]> ramses_: p1 <*> p2 :: Parser (a -> b) -> Parser a -> Parser b ?
04:29:54 <ramses_> sg[]: yeah, I meant after unwrapping the newtype
04:30:55 <sg[]> runParser :: Parser -> String -> Maybe (a, String)
04:31:35 <sg[]> Parser a*
04:31:55 <ramses_> sg[]: I think the issue will become clear if you expand the while signature of (<*>) in terms of the underlying type of Parser
04:32:04 <ramses_> s/while/whole
04:32:38 <jpcooper> hello
04:32:45 <typoclass> sg[]: does that make sense?
04:32:49 <typoclass> jpcooper: hi
04:32:50 <jpcooper> is there a file I can edit to append directories to GHC's search path?
04:38:37 <dudlite> Hello, attempting this homework problem, and confused on how to go about it: Using the deﬁnition of trees given by data Tree a = Node (Tree a) (Tree a) | Leaf a deﬁne tree versions of the list functions zip and zipWith.
04:39:05 <sg[]> typoclass: like this? p1 <*> p2 :: (String -> Maybe (a -> b, String)) -> (String -> Maybe (a, String)) -> (String -> Maybe (b, String))
04:39:26 <hpc> dudlite: start with the source of zip/zipWith
04:39:28 <hpc> @src zip
04:39:28 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
04:39:28 <lambdabot> zip _      _      = []
04:39:31 <hpc> @src zipWith
04:39:31 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
04:39:31 <lambdabot> zipWith _ _      _      = []
04:39:36 <ramses_> sg[]: exactly, now do you see what you have to do to implement such a function?
04:40:07 <jpcooper> dudlite: any two trees will have a common shape until some point
04:40:13 <dudlite> ohh
04:40:19 <dudlite> that is what is confusing me
04:40:28 <dudlite> two different shaped trees
04:40:30 <jpcooper> so you can start zipping at the root, and continuing until the end of the shallowest tree
04:40:36 <dudlite> so you just zip until they are different?
04:40:46 <jpcooper> all trees have two branches at each node, so you can imagine some kind of pyramid
04:40:56 <jpcooper> indeed, just like in the normal implementation of zip
04:41:02 <hpc> if it helps, a linked list (like []) is a tree with only one branch
04:41:08 <jpcooper> yes
04:41:13 <hpc> (and the leaf element [] holds no additional value)
04:41:31 <dudlite> yep, I understand the structure of the tree quite well.
04:41:34 <typoclass> > zip [0..10] "lol" -- dudlite: zip cuts off when any of the lists ends
04:41:36 <lambdabot>   [(0,'l'),(1,'o'),(2,'l')]
04:41:38 <NeOwA> Hello all !
04:42:01 <dudlite> ok, I see
04:42:29 <ramses_> hmm, with that definition of tree, you have no value for the bigger tree to zip with because there are only values in the leafs
04:43:02 <dudlite> um this might be a stupid question, but is there a tree data type in the prelude already?
04:43:06 <jpcooper> true actually
04:43:17 <jpcooper> dudlite: not that I know of
04:43:39 <hpc> dudlite: not in prelude; there's a ridiculous variety of tree types in other modules though
04:43:44 <dudlite> So with the question, we have to implement our own version of tree pretty much
04:43:46 <merijn> Can I make cabal pass a -D flag to the preprocessor?
04:43:50 <NeOwA> I'm studying Haskell and I have this function reverting a list of Int : http://pastebin.com/9FjzPM8T ; I'm asked "what happen if you call reverse ['a', 'b', 'c']" . If I do it in GHCi it returns me "cba" but i'm not specifying the Int type. Does it work because the cast between [int] and "string" is automatic or because GHCi make the function polymorph ?
04:43:52 <mauke> The paste 9FjzPM8T has been copied to http://hpaste.org/84974
04:44:04 <shachaf> merijn: ghc-options: -D?
04:44:07 <hpc> dudlite: you already have your implementation in your original question ;)
04:44:10 <ramses_> dudlite: but you can choose the definition? Or is it given?
04:44:12 <jpcooper> dudlite: then maybe a tree with a value at each branch would be more suitable
04:44:29 <jpcooper> with possibly empty leaves
04:44:29 <dudlite> Definition is given
04:44:30 <merijn> shachaf: I was thinking on the commandline, but I guess I could hack the cabal file
04:44:35 <jpcooper> right
04:44:35 <shachaf> merijn: Oh.
04:44:49 <dudlite> Here was the original question again:
04:44:51 <dudlite> deﬁne tree versions of the list functions zip and zipWith.
04:44:52 <shachaf> merijn: --ghc-options=...
04:44:54 <dudlite> oops
04:45:01 <sg[]> ramses_: no..
04:45:02 <shachaf> NeOwA: No, it's probably happening because you're calling the Prelude reverse function instead of the one you wrote.
04:45:14 <hpc> dudlite: seems like you would want a tree then, that's empty at leaves and has values at the branches
04:45:22 <hpc> to look as much like [] as possible
04:45:26 <merijn> shachaf: And for C files compiled using cabal? --c-options?
04:45:46 <shachaf> merijn: I don't know. --PROG-options, at any rate.
04:45:47 <dudlite> So i need to write a function for inserting values into the tree first right?
04:45:58 <shachaf> merijn: I'm just going by cabal configure --help here. :-)
04:46:02 <NeOwA> shachaf > I wrote it as "bad" in GHCi not as reverse
04:46:04 <ramses_> sg[]: ok, first fix the type error in the usage of "maybe", the Nothing must have type "String -> Maybe ...". That will then reveal the true problem in your implementation
04:46:16 <merijn> shachaf: ok, I'll see what happens
04:46:30 <shachaf> merijn: In fact at the bottom of cabal configure --help it tells you what PROG can be.
04:46:49 <shachaf> NeOwA: OK, paste your entire ghci session into hpaste.org.
04:46:55 <ramses_> dudlite: your zip will behave a bit differently from the list variant with that definition of tree, I think
04:47:08 <arkeet> @djinn (s -> Maybe (a -> b,s)) -> (s -> Maybe (a,s)) -> (s -> Maybe (b,s))
04:47:09 <lambdabot> f a b c =
04:47:09 <lambdabot>     case b c of
04:47:09 <lambdabot>     Nothing -> Nothing
04:47:09 <lambdabot>     Just (d, _) -> case a c of
04:47:09 <lambdabot>                    Nothing -> Nothing
04:47:11 <lambdabot>                    Just (e, f) -> Just (e d, f)
04:47:12 <arkeet> oops
04:47:50 <ramses_> dudlite: since you do not have a stream of intermediate values which you can just cut off, as you do in the list case
04:47:59 <shachaf> arkeet: I bet that's not even the function you wanted.
04:48:10 <arkeet> I never wanted anything.
04:48:20 <dudlite> ramses_: Am I able to like flatten the tree into a list and then throw it into zip?
04:48:23 <arkeet> but you're right.
04:48:26 <dudlite> or is that cheating lol
04:48:40 <arkeet> @djinn (s -> Maybe (a -> b,s')) -> (s' -> Maybe (a,s'')) -> (s -> Maybe (b,s''))
04:48:41 <lambdabot> f a b c =
04:48:41 <lambdabot>     case a c of
04:48:41 <lambdabot>     Nothing -> Nothing
04:48:41 <lambdabot>     Just (d, e) -> case b e of
04:48:41 <lambdabot>                    Nothing -> Nothing
04:48:43 <lambdabot>                    Just (f, g) -> Just (d f, g)
04:48:59 <shachaf> Indexed monads!
04:49:00 <ramses_> dudlite: depends on what you want to do.. You lose the tree semantics then though, so that's hardly a tree zip
04:49:03 <arkeet> I know.
04:49:12 <shachaf> i love indexed monads
04:49:23 <arkeet> are they easy?
04:49:32 <shachaf> I don't know.
04:49:34 <shachaf> Are they?
04:49:41 <arkeet> well, you love them, so I was guessing.
04:49:42 <shachaf> They are surely easier than going to sleep.
04:49:43 <dudlite> ramses_: Ok, I see.  So my zip type is going to be something like this:
04:49:51 <arkeet> I can agree with that.
04:49:56 <typoclass> i think they're just an endofunctor in the category of monoids, so where's the problem
04:50:17 <dudlite> ramses_: zip :: tree a -> tree a -> tree a
04:50:18 <arkeet> typoclass: no, you didn't get it right.
04:50:32 <ramses_> :t zip
04:50:33 <lambdabot> [a] -> [b] -> [(a, b)]
04:50:40 <dudlite> oh whoops
04:50:45 <ramses_> dudlite: change [] to Tree there
04:50:54 <sg[]> this isn't working. i'm smashing my head against the wall right now
04:51:03 <ramses_> sg[]: what do you have now?
04:51:04 <hpaste> neowa pasted “type” at http://hpaste.org/84975
04:51:13 <sg[]> p1 <*> p2 = Parser $ maybe (\_ -> Nothing) (runParser p1) (runParser p2)
04:51:15 <sg[]> but i KNOW that's wrong
04:51:32 <NeOwA> shachaf: http://hpaste.org/84975 here it is
04:51:37 <sg[]> I'm having such a hard time wrapping my head around applicative functors
04:51:40 <ramses_> sg[]: it is, but what error do you get know? It should shed some light on the real error
04:51:41 <arkeet> sg[]: I find these are typically easier to write with pattern matching, and *then* perhaps using catas like maybe to shorten it.
04:51:48 <dudlite> ramses_ Ohh so I don't actually have to populate two trees two test it
04:51:48 <shachaf> NeOwA: Oh, you didn't write the type.
04:51:56 <shachaf> NeOwA: Then yes. It is polymorphic.
04:52:02 <shachaf> You can find out the type with :t
04:52:04 <dudlite> to*
04:52:09 <dkasak> NeOwA, it's not the same function because there's no signature.
04:52:10 <shachaf> arkeet: I think monads are bad for the same reasons monoids are bad.
04:52:20 <arkeet> what reason is that?
04:52:28 <shachaf> You know, lack of type safety and all that.
04:52:36 <ramses_> dudlite: ? You can give it twice the same tree if that's what you mean but that's a bit of a degenerate test case
04:52:39 <arkeet> I would say expressiveness, not safety.
04:52:52 <NeOwA> shachaf: wow ":t" is really great ! But how can I specify the type of args in GHCi
04:52:57 <shachaf> The types don't tell you anything, when you're dealing with a monoid.
04:53:01 <hpaste> sg pasted “error” at http://hpaste.org/84976
04:53:05 <arkeet> NeOwA: let bad :: [Int] -> [Int]; bad [] = []; ...
04:53:06 <shachaf> NeOwA: Just write out the type, like your example code above.
04:53:26 <shachaf> NeOwA: You may want to read one of those introductions to Haskell that teaches you how to use ghci.
04:53:40 <NeOwA> shachaf: oh sorry for obvious question, thank you for you help !
04:53:47 <arkeet> sg[]: also, I find it helps immensely to write out the types of the bound variables and various expressions formed by them.
04:54:00 <shachaf> arkeet: So instead of a monoid in the category of endofunctors I want a category in the category of endofunctors, obviously.
04:54:04 <shachaf> What does that give me?
04:54:08 <ramses_> sg[]: hmm, not what I was hoping for :)
04:54:16 <arkeet> shachaf: hmm
04:54:24 <dudlite> ramses: Sorry to be a pain, still confused with the initial type
04:54:56 <ramses_> sg[]: you have to apply the function inside the result of the first parser, to the argument inside the result of the second one, you see that?
04:55:29 <ramses_> dudlite: you take two trees and put their values together in tuples, just like with lists, the signature is almost identical
04:55:40 <typoclass> sg[]: have you tried writing it like this? case runParser p1 of Just ... -> ... ; Nothing -> ...
04:55:40 <hpaste> quchen pasted “zipWith for lists” at http://hpaste.org/84977
04:55:43 <shachaf> arkeet: Any last words before I go to sleep?
04:55:56 <shachaf> quchen: Now do it with foldrs.
04:55:57 <quchen> dudlite: ^ is the source for zipWith.
04:56:06 <arkeet> shachaf: I feel like that does give the notion of an indexed monad that we need for e.g. type-changing State.
04:56:06 <sg[]> ramses_: i do
04:56:10 <sg[]> typoclass: one moment
04:56:13 <arkeet> sg[]: http://matthew.brecknell.net/posts/2013/02/26/hole-driven-haskell/
04:56:13 <dudlite> thanks
04:56:20 <typoclass> sg[]: you will then of course notice that in "case runParser p1 of", you need another argument
04:56:28 <quchen> dudlite: As a next step, add your tree type somewhere, "data Tree a = ...", annotate, and we'll work on from there.
04:56:38 <quchen> shachaf: I don't think that'd be helpful here.
04:56:47 <arkeet> sg[]: I don't quite go all-out like what this guy does, but I do write the types of a few key expressions while writing complicated things like this.
04:56:59 <arkeet> sg[]: also see the comment about -XImplicitParams if you do ths.
04:57:12 <shachaf> ImplicitParams is great.
04:57:13 <ramses_> sg[]: okay, I'd go with typoclass' suggestion then and manually unwrap the maybes with explicit pattern matching
04:57:23 <arkeet> I suggested that too.
04:57:26 <ramses_> sg[]: and just apply the function in the first one
04:57:32 <shachaf> arkeet: How does it work?
04:57:42 <arkeet> shachaf: I dunno, I'd have to write it out.
04:57:47 <shachaf> What does "category in the category" even mean?
04:58:09 <arkeet> an enriched category.
04:58:20 <arkeet> I dunno.
04:58:40 <shachaf> Are you sure?
04:58:45 <arkeet> no.
04:58:52 <ramses_> arkeet: didn't mean to not give you credit ;)
04:59:06 <arkeet> ramses_: I don't mind really.
04:59:37 <killy9999> which module exports divInt# ?
05:00:00 <dudlite> ramses_: Like this?  Tree a -> Tree b -> Tree(a,b)
05:00:22 <killy9999> answer to self: GHC.Classes
05:00:26 <shachaf> arkeet: Hmm, actually, this makes a bit of sense.
05:00:56 <ramses_> dudlite: yes
05:01:06 <shachaf> In fact, dpiponi says: "First a category theoretical aside: in this post I talked about how monads were really a kind of abstract monoid. Well ParameterisedMonad is a kind of abstract category. If we were to implement join for this class it would play a role analogous to composition of arrows in a category. In a monoid you can multiply any old elements together to get a new element. In a category, you can't multiply two arrows together unless ...
05:01:12 <shachaf> ... the tail of the second matches the head of the first."
05:01:51 <shachaf> arkeet: Have you noticed the class Category is kind of awful?
05:01:56 <arkeet> yes.
05:02:07 <shachaf> Which part is awful according to you?
05:02:30 <arkeet> it only works on * -> * -> *, for one.
05:02:51 <shachaf> Hmm, that's one perspective.
05:03:03 <shachaf> In a way it subsumes other things.
05:04:11 <arkeet> I think the notion of a category enriched over End(Hask) is exactly what you want, really.
05:04:33 <arkeet> maybe.
05:04:40 <shachaf> I'm going to sleep.
05:04:40 <arkeet> yeah.
05:04:43 <arkeet> ok.
05:04:47 <quchen> shachaf: Is there a way doing the zipWith using an ordinary fold? It's quite easy when I introduce another parameter after the fold and let it generate a function, but that is often overshooting it.
05:05:01 <arkeet> in other words
05:05:02 <arkeet> it's a monadoid
05:05:04 <arkeet> ;-)
05:05:15 <shachaf> That's a much better name than "indexed monad"!
05:05:46 <shachaf> I'll demand that edwardk rename all his packages to this scheme at once.
05:05:53 <shachaf> Functoroid, Comonadoid, everything.
05:06:04 <arkeet> :D
05:06:30 <hpaste> quchen pasted “Cheesy zipWith using foldr” at http://hpaste.org/84978
05:06:33 <arkeet> a comonad is a cocategory enriched over End(Hask)?
05:06:50 <arkeet> I guess that's an answer to "who cares about cocategories"./
05:06:54 <sg[]> excellent, i got it working, thank you so much
05:07:08 <shachaf> "cocategory"?
05:07:24 <arkeet> sure.
05:07:33 <sg[]> typoclass: is there a way to make my working code more haskell-esque
05:07:33 <arkeet> take the dual of the definition of an (enriched) category
05:07:43 <ramses_> quchen: you could tuple the two lists and pattern match in the folding function
05:07:49 <shachaf> Oh, I guess it becomes different from a category when you do the enriched thing.
05:07:53 <arkeet> yes
05:08:06 <arkeet> an ordinary category is a category enriched over Set.
05:08:12 <quchen> ramses_: And leave the base case for fold ununsed?
05:08:12 <hpaste> sg pasted “working code” at http://hpaste.org/84979
05:08:23 <shachaf> A locally small category, anyway? Or something?
05:08:31 <arkeet> I'm not worrying about smallness issues.
05:09:14 <ramses_> sg[]: when you're not tired of it yet, you can quite easily avoid pattern matching the result of the second parser
05:09:32 <sg[]> with maybe
05:09:33 <sg[]> ?
05:09:36 <arkeet> with fmap
05:09:43 <sg[]> ah
05:09:55 <arkeet> ...maybe.
05:10:16 <quchen> ramses_: How would I tuple up the lists? Foldr has to consume a list after all
05:10:32 <ramses_> quchen: haha, good point, silly me :)
05:10:47 <quchen> Phew.
05:10:53 <ramses_> quchen: I hadn't thought it through
05:11:12 <quchen> But then that solution is still a silly hybrid between a fold and the manual version of zipWith.
05:11:14 <ramses_> quchen: sorry for the confusion :)
05:11:21 <quchen> I'm not sure that's what shachaf meant.
05:11:54 <ramses_> I don't immediately see how you could use foldr to recurse over both lists at once...
05:12:01 <ramses_> using unfoldr would be a lot easier
05:12:06 <shachaf> There is a reason that it is a puzzle.
05:12:17 <quchen> shachaf: By fold do you mean foldr?
05:12:26 <quchen> Or the fold2 stuff that happens in the optimization steps
05:12:29 <shachaf> When did I say fold?
05:12:51 <quchen> Scrolling ...
05:12:54 <quchen> "foldrs"
05:13:00 <quchen> How many is "s"? :-)
05:13:21 <shachaf> One per list.
05:13:29 <typoclass> sg[]: to me, it seems pretty clear already. you could remove the parens and the $'s as hlint suggests (see yellow messages in paste). the line "Nothing -> Nothing" kind of alerts you that you could use fmap here (using the Functor Maybe instance), but i'm not sure if that will make things clearer :-)
05:13:37 <shachaf> I mean that you get the Church(/Bwhatever)-encoded versions, of course.
05:14:14 <typoclass> sg[]: you could always use 'where' or 'let in' if you're worried about the indentation getting wider and wider (some people are; it's a personal style thing)
05:14:14 <quchen> What?
05:14:17 <shachaf> (forall r. (a -> r -> r) -> r -> r) -> (forall r. (b -> r -> r) -> r -> r) -> [(a,b)]
05:14:42 <shachaf> Or maybe (forall r. (a -> r -> r) -> r -> r) -> (forall r. (b -> r -> r) -> r -> r) -> (forall r. (a -> b -> r -> r) -> r -> r)
05:15:07 <quchen> Beautiful ;-)
05:15:26 <quchen> So basically the buildable versions of the lists
05:15:31 <ramses_> I just read about that yesterday :) It's already paying off
05:15:48 <shachaf> arkeet can explain.
05:15:53 <shachaf> I'm going to sleep.
05:16:00 <arkeet> :(
05:16:02 <arkeet> but I'm going too.
05:16:04 <ramses_> quchen: it's like church numerals and booleans
05:16:12 <shachaf> Chumerals and chooleans.
05:16:41 <shachaf> arkeet: OK, what's an IndexedFunctor?
05:16:48 <quchen> ramses_: \nil cons -> 3 `cons` (4 `cons` nil)
05:16:54 <arkeet> nothing interesting. fmapoid :: (a -> b) -> (f s t a -> f s t b)
05:16:54 <sg[]> typoclass: how would i use fmap to reduce that code?
05:17:05 <shachaf> Sure.
05:17:17 <shachaf> But I mean what thing is it?
05:17:27 <ramses_> quchen: yes, and if you feed those (:) and [] you get the regular haskell list
05:17:40 <arkeet> it's just a functor.
05:17:51 <shachaf> Oh, an endofunctor in the enriched category?
05:17:56 <ramses_> quchen: you see a list as a kind of "active entity" with such an encoding, not just passive data.
05:17:57 <quchen> ramses_: Well, I know about that. I don't see how this helps me here though
05:18:04 <arkeet> shachaf: no, it's a functor from Hask to Hask^I
05:18:09 <arkeet> where I is some index category
05:18:30 <typoclass> > let f = fmap succ in (f Nothing, f (Just 42))
05:18:32 <lambdabot>   (Nothing,Just 43)
05:18:32 <arkeet> equivalently, it's a bunch of endofunctors of Hask (indexed by I)
05:18:47 <shachaf> And what's an IndexedMonad?
05:18:52 <arkeet> that's the monadoid.
05:18:56 <arkeet> well.
05:18:58 <shachaf> Right. What is it?
05:19:04 <shachaf> I mean, it's also a functor from Hask to Hask^I
05:19:21 <arkeet> in this case I is some set of pairs of objects.
05:19:33 <arkeet> (the objects of our enriched category)
05:19:59 <arkeet> if the enriched category has just one object, you get back an ordinary monad.
05:20:15 <shachaf> Sure.
05:20:23 <shachaf> Maybe I should go to sleep.
05:20:24 <ramses_> quchen: ah ok, I'd have to think about that as well ;)
05:20:26 <shachaf> OK, I'll do it this time.
05:20:26 <arkeet> ok.
05:20:28 * shachaf vanishes.
05:20:29 <arkeet> :P
05:20:49 <quchen> ramses_: ;-(
05:21:08 <quchen> ramses_: I suspect the result will be somewhat unreadable
05:21:14 <typoclass> sg[]: can you see how you'd write the above line with case-of? it's straightforward, using "Nothing -> Nothing"
05:21:14 <alshain> @pl f n = if (n == 0) then 0 else (if (n == 1) then 1 else f (n - 1) + f(n - 2))
05:21:15 <lambdabot> f = fix (ap (flip if' 0 . (0 ==)) . ap (flip if' 1 . (1 ==)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
05:23:06 <quchen> ramses_: The zipWith implementation skips the process and defines foldr2
05:23:22 <quchen> which has its own fusion rules
05:23:41 <merijn> j #cygwin
05:23:47 <merijn> bah
05:24:42 <huad> What is difference between type, typeclass and Number? Since I am a newbei to functional programming and Haskell and  I begin programming with C and Java, can anyone can explain this associate with this languages?
05:26:59 <quchen> huad: The biggest hurdle in learning Haskell is not trying to associate things with the language you've known before. Types in C aren't what types in Haskell are, typeclasses don't exist in C and arguably do exist in Java, and I'm not sure what you mean with "Number".
05:27:12 <tootooroo> huad: A type class is, well, a collection (class!) of types for which a common interface is available. For example, for any type t that is an instance of Num, there is a function (+) :: (Num t) => t -> t -> t.
05:27:58 <tootooroo> huad: Also, type classes have nothing to do with functional programming, and a lot with trying to get polymorphism right.
05:28:32 <huad> quchen: I see Number at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
05:28:52 <arkeet> there is no Number. you probably mean Num.
05:28:57 <mizu_no_oto> A type is a concrete type, much like in C:  Int, Float, String, etc.  A typeclass is like an interface.  For example, Show has the method show, of type Show a => a -> String.  Num is another example of a typeclass, which has all of the assorted stuff for dealing with numbers
05:28:58 <arkeet> Num is a typeclass.
05:29:01 <tootooroo> huad: You mean Num?
05:29:11 <arkeet> it might be helpful to think of typeclasses as like interfaces in Java.
05:29:12 <huad> sorry Num
05:29:35 <arkeet> there are several types such as Int and Double, and they "implement the Num interface"
05:29:45 <arkeet> ...we say that they are instances of Num.
05:30:00 <tootooroo> arkeet: Not really! Type classes allow functions to be polymorphic on any of its parameters or even in its return type.
05:30:10 <arkeet> tootooroo: I never said the analogy was precise. :p
05:30:15 <quchen> huad: Ah, well then it makes sense. Typeclasses can be read as "can do this". For example, things that are "Num" can do +, -, * ... Things that are "Eq" can do ==. Things that are "Ord" can do > < <= ...
05:30:42 <arkeet> tootooroo: typeclasses don't even need functions at all.
05:30:51 <huad> quchen: I understand now.
05:30:56 <typoclass> huad: some examples for types are Int, Integer, String, Maybe String, [String]. typeclasses are used for stuff like overloading functions; a typeclass is a bunch of function signatures with no implementations (i.e. they're vaguely similar to java's interfaces)
05:31:20 <mapf> is there a way to default all string literals to bytestring with -XOverloadedStrings enabled? Some defaulting extension?
05:31:21 <typoclass> huad: as a beginner, most people overestimate them and think they need to write lots of typeclasses before doing anything. this is not the case :-) in haskell, you can go quite a long way with plain functions
05:32:11 <mizu_no_oto> Also, just using the default typeclasses
05:32:57 <typoclass> mapf: maybe it'd be clearer to do «b = ByteStr.pack», letting you do «b "lolcat"»
05:33:36 <parcs> @where lyah -- huad
05:33:37 <lambdabot> http://www.learnyouahaskell.com/
05:35:50 <mapf> typoclass: yes, I just thinking about something like this: http://hackage.haskell.org/trac/haskell-prime/wiki/Defaulting
05:36:56 <huad> thanks. I begin writing some functions but I have to answer some questions for my lecture. It is very hard to understand big picture without big knowledge. In my native language there is a idiom that tells without knowledge you cant have any opinion
05:37:47 <ciaranm> first, learn category theory
05:37:52 <quchen> ciaranm: get out
05:37:59 <quchen> ;-)
05:38:00 <typoclass> ciaranm: i disagree
05:38:05 <ciaranm> well. first, learn algebra and topology.
05:38:20 <ciaranm> that makes the category theory a lot easier.
05:38:32 <huad> realworldhaskell and learnyouahaskell are very good sources
05:38:39 <quchen> LYAH first.
05:38:50 <quchen> RWH is a good follow-up.
05:39:14 <typoclass> huad: yes, use those. they're good books. keep in mind that rwh is a few years old already, so occasionally you may find some code that is outdated, but you can usually fix it easily
05:40:17 <typoclass> mapf: yeah ... defaulting exists in current haskell already. what you linked seems to be a proposal to change it or something. anyway, the keyword is "default"; it's not often used, people don't seem to like it much. i guess you could try and see if you run into problems ...
05:41:37 <typoclass> ciaranm: i still disagree. people learn by going from the concrete to the abstract, not the other way round
05:45:13 <quchen> ciaranm, typoclass: https://gist.github.com/quchen/5284753
05:46:01 <quchen> Additional list elements welcome.
05:46:18 <typoclass> quchen: hehe :-) yeah, that more or less sums up my opinion
05:46:51 <jpcooper> hello
05:46:52 <quchen> Maybe that should go on haskell.org's frontpage
05:46:54 <quchen> jpcooper: Hello
05:47:24 * hackagebot family-tree 0.3.1.4 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.3.1.4 (NathanVanDoorn)
05:48:32 <typoclass> i think it's reasonable to learn haskell, and after you have some competence, go on to learn some CT. i don't understand why people keep claiming the reverse. to me it seems like putting the cart before the horse
05:48:40 <jpcooper> I have a module M which is included by a module N, which I am using by calling ghci N.hs from the terminal. In my .ghci, I have set with :set -i two directories, one containing M.hs, and the other containing M.hi and M.o. For some reason, ghci is compiling M.hs every time I call ghci N.hs. Why could this be?
05:48:47 <ramses_> quchen: my connection was dropped somehow.. Let me know if you find something, I really should start doing something useful now ;)
05:49:55 <quchen> ramses_: Funny you say that, I just gave up. ;-)
05:50:06 <quchen> Can't do the "combine two lambda lists" thing.
05:50:58 <quchen> typoclass: Learning category theory is also not very helpful. You need to learn a lot of category theory.
05:51:05 <ramses_> quchen: haha :) I can't yet make sense of it either, although I have a feeling it will be easy once you've seen it..
05:51:16 <typoclass> quchen: i don't know about that
05:52:11 <quchen> typoclass: I've read a couple of introductions, and it's quickly boring, very detached from Haskell, and in-detail mathy. I don't think reading it for Haskell's sake leads to something.
05:52:23 * hackagebot besout 0.1.0.0 - Extended GCD of polynomials over F_p[x]  http://hackage.haskell.org/package/besout-0.1.0.0 (AbdelwahebMiled)
05:52:56 <quchen> I mean I've read quite some books like that on other topics, but then I got in there because I found that topic good in the mathematical sense, and not to understand something else
05:53:27 <quchen> Sadly, differential geometry is not a corner stone of Haskell ;-)
05:54:19 <ramses_> now that would scare away newbies! :)
05:54:38 <turiya> hi
05:54:52 <quchen> ramses_: I don't think it can be worse than what ciaranm said above
05:54:59 <ramses_> class Calabi-Yau where ...
05:55:27 <ramses_> quchen: I must have missed what he said :)
05:55:42 <quchen> ramses_: One of those "learn category theory first" comments
05:55:57 <turiya> i tried to understand FRP many times in the past but could not get the essence of it. How is it different from traditional methods. Any references or explanation would be really appreciated.
05:57:50 <tootooroo> turiya: Time-varying values and dependencies between them are native concepts, which eliminates the need to use messy constructs such as callbacks to update values that depend on other time-varying values.
05:57:51 <hiptobecubic> turiya, you use values like "t" for time, which *can* change, in definitions of things dependent on it which can not change
05:58:59 <parcs> http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming
06:00:08 <turiya> so FRP is inherently related to time
06:00:40 <parcs> nobody really knows what frp is, aside from a handful of people
06:01:58 <turiya> these time-varying value can be constructed from other time varying values, is that right?
06:02:24 * hackagebot hmemdb 0.1.0.0 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.1.0.0 (MiguelMitrofanov)
06:02:30 <turiya> what about switches?
06:02:36 <turiya> what are those
06:06:15 <parcs> turiya: http://apfelmus.nfshost.com/blog/2011/05/15-frp-dynamic-event-switching.html
06:07:24 <turiya> parcs: thnx for the links, i am reading one of them
06:09:22 <turiya> i think one of my difficulty is to understand the difference between "behaviours" and "events"
06:10:29 <monoidal> turiya: also see http://www.haskell.org/haskellwiki/FRP_explanation_using_reactive-banana
06:11:41 <turiya> monodial: i have read that in the past but i am not sure if it solved my difficulties.. may be i forgot :)
06:15:53 <andrea93> hotty shit http://www.youtube.com/watch?v=NvijX055h5M
06:20:22 <quchen> Anyone else wanna work on shachaf's challenge to write zipWith using foldrs? I can't make any progress
06:21:01 <igstan> quchen: where's the challenge description?
06:21:08 <quchen> It's basically "write zipWith using foldrs (one per list)".
06:21:32 <ramses_> and no other recursive functions, I suppose
06:22:07 <quchen> As an intermediate step he suggested to use the Church encoding for lists, as known from the build function, i.e. \cons nil -> 1 `cons` (2 `cons` nil)
06:22:23 <quchen> 14:14 < shachaf> (forall r. (a -> r -> r) -> r -> r) -> (forall r. (b -> r -> r) -> r -> r) -> [(a,b)]
06:22:25 <quchen> 14:14 < shachaf> Or maybe (forall r. (a -> r -> r) -> r -> r) -> (forall r. (b -> r -> r) -> r -> r) -> (forall r. (a -> b -> r -> r) -> r -> r)
06:22:39 <quchen> Can't even write those
06:23:48 <ramses_> that last one is actually zipWith
06:24:10 <quchen> Right
06:24:36 <quchen> I mean converting list to lambda is simply \cons nil -> foldr cons nil xs
06:25:46 <quchen> Then we could write a f-double-cons function a la "doubleCons f x y = (f x y :)"
06:26:29 <quchen> That already has the type (a -> b -> r -> r) we're looking for, specialized for lists
06:27:13 <sg[]> is there any way to do (f a, f b) -> f (a,b)
06:27:19 <sg[]> if f is an applicative functor
06:28:21 <quchen> Yes, I think this is part of an alternative definition of Applicative.
06:28:41 <BMeph_> :t uncurry (liftA2 (,))
06:28:42 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
06:28:43 <parcs> > uncurry (liftA2 (,))
06:28:44 <lambdabot>  Terminated
06:29:21 * BMeph_ WINS!!! :D
06:29:31 <igstan> quchen: this challenge looks a lot like the challenge from RWH, to write foldl in terms of foldr http://book.realworldhaskell.org/read/functional-programming.html#x_D9
06:29:59 <quchen> igstan: I don't think so, the solution using that technique is quite simple
06:30:18 <latermuse> Honestly, I barely use folds. I dont think im doing haskell the right way.
06:30:36 <quchen> igstan: http://hpaste.org/84978
06:31:03 <igstan> quchen: yeah, I'm not sure, but what I assume is that a first foldr over one of the lists should return a function which can be used on second list with another foldr
06:31:16 <igstan> quchen: just some thoughts, I'll try it a bit later.
06:31:23 <quchen> No! Try it now! ;-D
06:31:39 <ab9rf> NOWNOWNOW!
06:31:44 <igstan> quchen: shall I assume you've tried what I said? :)
06:31:45 * ab9rf giggles inanely
06:32:13 <quchen> igstan: No, I think I tried something different. I wrote the hpaste above
06:32:19 <quchen> 15:30 < quchen> igstan: http://hpaste.org/84978
06:32:26 <igstan> ah, sorry, didn't see it
06:32:54 <quchen> foldl in terms of foldr isn't actually complicated once you understand the general mechanism behind it
06:33:04 <sg[]> BMeph_: any way to do that without liftA2?
06:33:09 <quchen> I always thought it's some obscure example, but turns out it's a very handy technique
06:33:25 <ab9rf> what's wrong with liftA2? :)
06:33:29 <ab9rf> @src liftA2
06:33:29 <lambdabot> liftA2 f a b = f <$> a <*> b
06:33:51 <quchen> sg[]: :t uncurry (\a b -> (,) <$> a <*> b)
06:33:56 <quchen> ;-)
06:34:29 <arkeet> :t uncurry (liftA2 (,))
06:34:31 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
06:37:11 <ab9rf> i'd ask lambdabot to @unpl that ugly expression, but it'll just say uncurry (liftA2 (,)) :)
06:38:28 <Wizek> Gloss related question: within the play function for the `"function to convert the world a picture" :: (world -> Picture)` can I construct Picture from individual pixels somehow?
06:39:24 <byorgey> Wizek: yes, see the definition of Picture here: http://hackage.haskell.org/packages/archive/gloss/1.7.8.2/doc/html/Graphics-Gloss-Data-Picture.html#t:Picture
06:39:32 <byorgey> Wizek: in particular see the Bitmap constructor
06:41:35 <Wizek> byorgey: how can I construct BitmapData? It only says "Abstract 32-bit RGBA bitmap data."
06:42:00 <byorgey> Wizek: hmm, good question
06:42:59 <byorgey> Wizek: ah, see the "Loading bitmaps" section at the bottom of that page
06:43:22 <wereHamster> how do I unregister/uninstall a package that I installed with cabal?
06:43:23 <byorgey> unfortunately that looks geared to loading bitmap data from disk etc., not to generating the pixels programmatically yourself
06:43:32 <byorgey> Wizek: you may also be interested in the gloss-raster package
06:43:40 <byorgey> wereHamster: ghc-pkg unregister
06:44:22 <ab9rf> it looks like you have to construct it rom a ByteString
06:44:26 <ab9rf> which is fairly annoying and tedious
06:45:00 <wereHamster> byorgey: that won't delete the files from the filesystem, will it?
06:45:20 <byorgey> wereHamster: no, it won't
06:47:43 <Wizek> byorgey: Yes, I sadly also came to that conclusion that I won't be able to generate raster data for gloss to display. I'm currently looking into gloss-raster, but I have a simmilar question: In `animateArray`s 4th argument, how can I construct  (Array D DIM2 Color) ?
06:49:34 <byorgey> Wizek: Graphics.Gloss.Raster.Array is for doing stuff with repa, so to use that particular module you would need to be familiar with how to use repa to create arrays
06:49:43 <byorgey> Wizek: however I think you want  Graphics.Gloss.Raster.Field instead
06:49:57 <byorgey> Wizek: check out the 'makePicture' function in particular, which looks like just what you want
06:50:20 <byorgey> at least I assume so, it has no documentation =P
06:51:16 <ab9rf> that's the sme conclusion i came to
06:51:24 <ab9rf> although i have no idea how makePicture works.  experiment :)
06:51:42 <byorgey> yes, looking at the source is helpful -- first two arguments are window size, next two are pixel counts, and then you give a function specifying the color at any given point
06:51:58 <byorgey> the only slightly annoying thing here is that you have to give a *continuous* function for the color
06:52:09 <byorgey> at least that might be annoying if you actually do want to think about it in terms of pixels
06:52:16 <ab9rf> http://code.ouroborus.net/gloss/gloss-stable/gloss-examples/raster/Snow/Main.hs <- example code that might help?
06:52:20 <Wizek> byorgey: seems interesting, looking into it
06:52:26 * hackagebot antiquoter 0.1.0.0 - Combinator library for quasi- and anti-quoting.  http://hackage.haskell.org/package/antiquoter-0.1.0.0 (LarsCorbijn)
06:52:40 <ab9rf> there are several examples there, see generally http://code.ouroborus.net/gloss/gloss-stable/gloss-examples/raster/
06:54:24 <ab9rf> http://code.ouroborus.net/gloss/gloss-stable/gloss-examples/raster/Mandel/Solver.hs has code that uses makePicture to generate mandelbrots
06:55:32 <ab9rf> oh, wait,that code _defines_ makePicture.  well, you mightget ideas from it anyhow.
06:56:03 <arkeet> oh gee.
06:56:24 <arkeet> github can't parse stuff
06:56:25 <arkeet> https://gist.github.com/arkeet/5285089
06:56:29 <arkeet> shachaf: yeah.
06:56:57 <ab9rf> arkeet: nice syntax highlighting
06:57:01 <arkeet> yeah =(
06:57:22 <ab9rf> arkeet: it got confused about single quotes
06:57:24 <arkeet> I know.
06:58:17 <ab9rf> which is sadly lame
06:58:37 <k00mi_> submit a bugreport?
07:01:54 <arkeet> gee, took enough time to find whose bug it actually is. :p
07:02:03 <arkeet> I guess they use pygments for highlighting.
07:05:07 <arkeet> vim gets it right.
07:07:26 * hackagebot esqueleto 1.0.7 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.0.7 (FelipeLessa)
07:07:49 <arkeet> heh, even the pygments source admits it's wrong.
07:07:58 <arkeet> # Allows multi-chars, incorrectly.
07:08:40 <k00mi_> I guess they didn't realise how horribly wrong that can go
07:09:29 <k00mi_> though I used pygments to highlight haskell before and didn't have any problems
07:10:07 <arkeet> sure, but you probably didn't use lifted data types or template haskell. :p
07:10:27 <arkeet> since I guess TH would have the same problem.
07:10:40 <k00mi_> correct
07:10:49 <kmrhb> what is a reasonable throughput to expect in text output from a ghc-compiled haskell program?
07:11:14 <arkeet> I better sleep.
07:11:32 <kmrhb> I'm seeing 10 MB/s in a couple of ways
07:11:35 <kmrhb> 30 MB/s in another
07:12:04 <kmrhb> yes command gets ~100 MB/s on same machine
07:12:27 <kmrhb> (all piped to /dev/null)
07:13:31 <hiptobecubic> kmrhb, how are you measuring it?
07:13:34 <kmrhb> and catting /dev/zero gets ~800-1000 MB/s
07:13:35 <kmrhb> pv
07:13:44 <kmrhb> | pv > /dev/null
07:14:11 <kmrhb> the fastest (30 MB/s) is with cycle and lazy bytestring
07:16:12 <kmrhb> I'm trying to get a baseline so I know what the actual processing is taking
07:16:32 <kmrhb> and was surprised at what seems to me to be slow baseline throughput
07:20:45 <hiptobecubic> I get ~37 MB with plain old getContents >>= putStr
07:21:49 <arkeet> that's String.
07:21:50 <wereHamster> my app deadlocks eating 100% CPU unless I set 'LANG' in the enviroment. Is that expected?
07:22:02 <arkeet> I get 35 with that, but 2GB/s with getContents >>= putStr from lazy bytestring.
07:22:22 <arkeet> applied to /dev/zero.
07:22:42 <arkeet> I totally would expect String to be slow, considering it has to handle utf-8 conversion or whatever.
07:23:03 <parcs> and that it has an obscene memory overhead
07:23:24 <hiptobecubic> 3.2 here for lazy bytestrings
07:23:44 <arkeet> it's much slower if I'm just repeatedly printing small bytestrings
07:23:59 <arkeet> 65 MB/s for 8-byte chunks
07:24:05 <arkeet> but 2GB/s with 1024-byte chunks.
07:24:40 <ab9rf> arkeet: that makes sense
07:24:53 <hiptobecubic> well my maximum is 16GB/s with just `pv < /dev/zero > /dev/null`  so I guess 3.2 isn't terrible.
07:24:55 <arkeet> it's still slower than yes, though.
07:25:25 <jmcarthur> while i realize there are arguments for it, i think linked lists are a terrible default for strings
07:25:28 <arkeet> hiptobecubic: I get 15GB/s like that, but cat /dev/zero | pv gets 4 GB/s
07:25:45 <parcs> try a 32K chunk
07:26:00 <hiptobecubic> same
07:26:20 <arkeet> it seems to top out at 1k.
07:26:26 <ab9rf> probably be the same for anything that is a multiple of an OS page
07:26:33 <arkeet> ah wait.
07:26:51 <arkeet> I get 3.4GB/s for 64k chunks.
07:27:00 <arkeet> 2GB/s again for 1M.
07:27:08 <hiptobecubic> wereHamster, not that I've heard of?
07:27:41 <adimit> jmcarthur: it comes in handy sometimes. Since there are amazing alternate representations (Text) I think it's OK. It should just be made clear in every tutorial, and the documentation: don't ever even think of using String for anything even remotely performance critical.
07:28:03 <armlessh1bo> would using the Error monad be overkill if the only error handling I'm providing is an error message that doesn't look like an exception output?
07:28:08 <ab9rf> adimit: most haskell tutorials i've read have made that point
07:28:19 <kmrhb> hrm
07:28:36 <adimit> ab9rf: they do now. When I learned haskell, they didn't. Then again, there was no Data.Text when I learned Haskell. Go figure.
07:28:43 <kmrhb> I was doing smaller chunks as they'll reproduce my situation a bit better
07:28:47 <turiya> in netwire, how can i produce a wire which outputs 10 for time less than 100 and 20 for all other time?
07:28:51 <kmrhb> but maybe too small
07:29:09 <ab9rf> adimit: i've only been working with haskell for a couple of years
07:30:46 <jmcarthur> i don't like it when the easiest thing is extremely inefficient with little point, though. in the case of strings, the linked-list-ness is *usually* not any more convenient than Text's interface is
07:31:08 <jmcarthur> and it's not like it's hard to convert to a linked list of chars if you want it that way
07:31:13 <latermuse> im loving the "FlexibleContexts" pragma
07:31:43 <arkeet> (test program: main = BS.putStr (BS.replicate 32768 0) >> main
07:31:48 <adimit> my biggest pet peeve is a different one: that libraries which are meant to process text act like String would be a good instantiation of their "I-Parse-This" type parameter. I'm looking at iteratee, and parsec, specifically.
07:32:13 <Philippa> ab9rf: yeah, there's a pretty spectacular range of what's "normal" knowledge to people by now because there's been so much development since eg when I started ten years back
07:32:20 <adimit> iteratee doesn't even have Text instances, only String and ByteString. If you're using iteratee you would never ever even want to look in the direction of String.
07:32:40 <jmcarthur> adimit: yeah!
07:32:58 <jmcarthur> i think this is a natural consequence of linked lists being the default type for strings, though
07:33:05 <adimit> yes, true.
07:33:08 <kmrhb> Philippa: yeah. I strangely took a multi-year break from haskell right around when byte strings came about and when iteratees were something oleg was writing about
07:33:08 <jmcarthur> whatever is the default will get the most support
07:33:32 <kmrhb> coming back to ‘modern’ haskell is a bit strange and intersting
07:33:49 <adimit> i've been meaning to bug jlato about this forever. I actually have code for completely porting over iteratee to Text, including attoparsec-iteratee. It's trivial! Other things have been getting in the way though.
07:33:51 <Philippa> kmrhb: I bet!
07:34:14 <sleepynate> hah! http://blog.clement.delafargue.name/posts/2013-04-01-delicious-burritos-in-php-with-phpz.html
07:34:25 <Philippa> kmrhb: I don't know if I should apologise to you or not for what we did to parsec :p
07:34:39 <adimit> another absolute disaster in the iteratee library is that uses evil, evil ByteString.Char8.pack and unpack. *shudder*
07:34:51 <kmrhb> Philippa: I haven't looked actually. I used it in the past but it hasn't come up yet
07:35:06 <kmrhb> Philippa: but I have this understanding that when it does I should look at attoparsec
07:35:10 <Philippa> *nod*. You can, er, do all kinds of fun things with parsec3 if you're in a suitable twisty mood
07:35:24 <kmrhb> (which may or may not be correct)
07:35:31 <Philippa> and yeah, attoparsec is something I've not learned because I've been aware it's not quite right for my own domain, but which is important to be aware of
07:35:46 <arkeet> Char8, gross.
07:36:07 <hiptobecubic> what's wrong with char8?
07:36:31 <arkeet> a lot of things.
07:36:32 <adimit> Philippa: attoparsec is pretty amazing. A bit weird, because of the way 'feed' works, and the fact that it's an online parser, but i'm using it pretty much exclusively nowadays (but I need very efficient parsing.)
07:36:48 <arkeet> mostly around assuming that everything in the universe is ASCII.
07:36:58 <geekosaur> Char8 = pretend to use Char but really truncate it to 8 bits
07:37:11 <geekosaur> > maxBound :: Char
07:37:11 <adimit> hiptobecubic: it only works correctly if you can guarantee that the input text is 7-bit encoded ASCII. If not, it does *nasty* things, namely truncating, and completely misrepresenting code points.
07:37:13 <hiptobecubic> oh, but that's built into the name
07:37:13 <lambdabot>   '\1114111'
07:37:15 <Philippa> adimit: yeah. It's cool to know we have that stuff available
07:37:19 <parcs> turiya: for 100 . pure 10 <|> pure 20
07:37:36 <kmrhb> so back the question, is it reasonable to get 30 MB/s from the lazy byte string and ~ 10 MB/s from the text examples here: https://gist.github.com/kmrhb/5285279
07:37:53 <kmrhb> *the question on performance
07:37:56 <Philippa> (I really ought to either write the show-off lib I talked about at Fun in the Afternoon years back or admit I'm not going to... I'd wandered across a class of grammar it should be possible to do required-lookahead analyses for)
07:38:37 <jmcarthur> kmrhb: a 3x difference doesn't sound very surprising to me (i haven't looked at your code, though)
07:38:46 <adimit> hiptobecubic: a *lot* of people use Char8 to parse free-form text with it. Its use case is very limited, though. Something like parsing base64 encoding, or URL-encoded strings, or the input/output of protocols that are only spec'ed to use ASCII.
07:39:08 <jmcarthur> oh wait, i just looked at the code. it's Text in both cases?
07:39:16 <kmrhb> jmcarthur: they're 2 lines each, printing constant strings with forever or with cycle
07:39:32 <kmrhb> jmcarthur: yeah
07:39:41 <adimit> I wrote a blog post about it a year ago: http://a-dimit.blogspot.de/2012/04/strings-in-haskell.html ← it contains some mistakes, but it gets the point across.
07:39:45 <kmrhb> I feel like 10s of MB/s is really slow
07:39:48 <turiya> parcs: it doesnt seem to print 20
07:40:05 <kmrhb> especially if the number of 10s is 1
07:40:18 <jmcarthur> kmrhb: yeah the absolute performance sounds pretty bad. i thought your only question was about relative performance between lazy bytestring and text
07:40:56 <kmrhb> -O3 on osx 10.8
07:41:00 <kmrhb> :/
07:41:24 <adimit> oh, btw: does anybody know of work to do feature-logic or constraint logic in Haskell? I know about LogicT (backtracking) and was going to implement my own engine with it, but if there's some prior work, I'd love to hear about it.
07:41:46 <parcs> turiya: hmm
07:42:02 <cschneid> adimit: regarding that ByteString type stuff. If I'm actually working with a list of bytes (not text), is there a better built-in for that than ByteString?
07:42:27 * hackagebot skein 1.0.0 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.0 (FelipeLessa)
07:42:30 <adimit> cschneid: have you looked at Data.Binary? I use it to parse, well, binary data.
07:42:35 <turiya> parcs: may be my code is wrong but i am using the loop from "http://hackage.haskell.org/packages/archive/netwire/4.0.7/doc/html/Control-Wire.html"
07:42:41 <Philippa> adimit: I've been playing with constraint programming some, but I'm not concerned with backtracking because I'm working in a domain where it's a good idea to actively avoid it most of the time
07:43:02 <cschneid> adimit: I'll go take a look
07:43:07 <adimit> Philippa: I'm working in NLP. We don't like backtracking, but we haven't found anything better :-D
07:45:06 <Philippa> adimit: *nod*. And in fairness, it occurs to me that there are subdomains of my domain where I really rather prefer to have it and they can be reasonably isolated. Typeful constraint programming is still a research effort, of course
07:45:06 <klrr> what does the ">>" do in the "readExpr" function? http://hastebin.com/dalujomolo.hs
07:45:51 <Philippa> there's the monadic constraint programming lib that Schrijvers et al worked on
07:45:57 <Philippa> not used it myself
07:45:59 <parcs> turiya: are you actually waiting 100 seconds?
07:46:10 <adimit> cschneid: here's an example of some pretty simple code using the Get Monad of Data.Binary for binary parsing. I've worked on that code myself (it's actually not very "good" Haskell code) so I can help you if you don't understand it: https://github.com/gregwebs/haskell-sphinx-client/blob/master/Text/Search/Sphinx/Get.hs
07:46:11 <monoidal> klrr: reads spaces, but discards them (they're not in the result)
07:46:16 <parcs> turiya: Time is in seconds
07:46:27 <turiya> parcs: oh
07:46:30 <parcs> turiya: so for 100 is 100 seconds. try 'for 5' or something
07:46:38 <turiya> i didn't recognise that
07:46:43 <cschneid> adimit: my use case is: read hex encoded string: "ABC123" from cmd line, do binary manipulation on the unpacked form of it, then spool it back out as hex.
07:46:47 <monoidal> klrr: so if your string is "     lisp" the result will be the same
07:46:49 <adimit> Philippa: Schrijvers et al. thanks for the hint. I'll go read it.
07:46:58 <monoidal> klrr: often *> is used instead for parsers
07:47:01 <adimit> Philippa: I've so far only used CLP in the context of (where else) Prolog.
07:47:03 <cschneid> adimit: so that midpoint is ByteString right now. Was wondering if there was somthing cleaner
07:47:07 <Philippa> http://homepages.inf.ed.ac.uk/wadler/papers/constraints/constraints.pdf for a paper
07:47:21 <Philippa> adimit: Oz's approach is probably worth looking at
07:47:27 * hackagebot clientsession 0.9 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.9 (FelipeLessa)
07:47:44 <Philippa> (it's another language - an interesting one even if it is dynamically typed!)
07:48:08 <turiya> parcs: right, it is working now
07:49:02 <adimit> cschneid: there are functions for de-hexing and re-hexing to ByteStrings from Strings on hackage. You should find them easily with {h,g}oogle. Data.Binary does want a ByteString as input (the way you represent binary data in Haskell is ByteString,) but doing bit-level manipulation to these strings is probably going to be easiest with Data.Binary.
07:49:19 <turiya> parcs: thanks
07:49:34 <adimit> Philippa: thanks, that's very helpful! I've actually done a tutorial on Oz at some point, but it's been long ago. Very interesting.
07:50:01 <turiya> parcs: do all wires need to be constructed using existing wires?
07:50:39 <adimit> right, now that I see it, I actually skimmed that Schrijvers at al paper at some point in the past. I'll have to re-read it.
07:52:45 <adimit> Philippa: thanks a bunch. I think that'll be very useful :-)
07:53:07 <parcs> turiya: ideally yes, but you have the option to creating a custom wire with mkPure and mkGen and friends
07:53:08 <saml> is there something like  https://github.com/orf/simple   in haskell?
07:53:30 <parcs> "Simple is a clone of Obtvse written in Python running on Flask." lol...
07:53:45 <adimit> it's simple! the name says it.
07:53:50 <saml> haskell can't do these, right?
07:54:49 <klrr> monoidal: thanks, but i meant more what the expressino (spaces >> symbol) mean, i know what it do but i couldnt write something like that myself since i dont get what ">>" does?
07:55:43 <monoidal> klrr: >> is monadic bind, except it ignores result of the first argument
07:56:13 <klrr> monoidal: what's a monadic bind?
07:56:19 <monoidal> klrr: in this context x >> y is a parser that executes parser x, ignores its result (but goes forward in the text) and then uses parser y
07:56:30 <Philippa> kllr: >>=
07:56:53 <turiya> parcs: when a wire inhibits what is the Wire it produces?
07:57:01 <klrr> monoidal: well, if it skips x's result, then why evaluate x in the first place instead of just y?
07:57:19 <monoidal> klrr: because the parser x moves forward in the text, so it skips the spaces
07:57:23 <sipa> klrr: it does run the parser, so it consumes input
07:57:40 <monoidal> klrr: x >> y is the same as "do x; y" if you heard about do-notation
07:57:51 <parcs> turiya: that depends on what the wire does. if it inhibits one instant it may not inhibit the next instant, or it may inhibit forever after, like with the 'for' wire
07:57:53 <klrr> monoidal: also, what's a parser in haskell, i think i know what it is but when you said executes parser x my mind messed up, i didnt know the chares is a parser?
07:58:18 <monoidal> klrr: "spaces" is a parser that consumes arbitrarily many spaces
07:58:25 <klrr> monoidal: oh okey, so it's like do but easier to write in some contexts?
07:58:47 <klrr> monoidal: so a parser is object which parse compares to a string ?
07:59:13 <monoidal> klrr: a parser for type a has type String -> [(a, String)]
07:59:15 <klrr> (i dont mean object as in OOP, i dont know anything about oop i mean object as used in natural languages)
07:59:48 <monoidal> that means that it gets a string S, parses it, and then returns possible parses (there can be many) and leftover text
07:59:53 <klrr> monoidal: i thought "parse" was the parser and "spaces" and "symbol" what the "stuff" that would be parsed in the string?
07:59:59 <monoidal> you can also add error messages, but let's leave that for later
08:00:08 <turiya> parcs: i am trying to understand the code you have given: (for 100 . pure 10) <|> pure 20. Here, (for 100) inhibits after 100 seconds so what is the result of (for 100. pure 10)?
08:00:43 <monoidal> klrr: spaces :: Parser (), so we call spaces a parser
08:00:54 <monoidal> klrr: the "parse" function executes a parser on some text
08:00:59 <Kyo> > 4 >> 3
08:01:01 <lambdabot>   Could not deduce (GHC.Num.Num (m a0))
08:01:01 <lambdabot>    arising from the ambiguity check f...
08:01:02 <klrr> monoidal: okey, now i get it :D
08:01:13 <parcs> turiya: in wire1 . wire2, if either wire1 or wire2 inhibits then the entire computation inhibits
08:01:14 <Kyo> > (Just 5) >> 4;
08:01:17 <lambdabot>   <hint>:1:14: parse error on input `;'
08:01:45 <turiya> parcs: oh, ok. nice
08:01:46 <Philippa> monoidal: yeah. It'd be nice to have a rather that yields an Int[eger] sometimes
08:02:03 <Philippa> (the number of spaces it munched)
08:02:23 <monoidal> klrr: you can combine several parsers, for example if you have a parser for C expressions, you can use it as a building block for a parser for C statements
08:02:57 <turiya> parcs: thanks for your help
08:03:01 <parcs> turiya: my pleasure
08:03:16 <turiya> parcs++
08:04:07 <monoidal> Kyo: you might have meant Just 5 >> Just 4
08:05:07 <Kyo> > Just 5 >> Just 4
08:05:08 <lambdabot>   Just 4
08:05:16 <ramses_> [1..10] >> return 2
08:05:17 <lambdabot> ramses_: You have 1 new message. '/msg lambdabot @messages' to read it.
08:05:27 <ramses_> > [1..10] >> return 2
08:05:30 <lambdabot>   [2,2,2,2,2,2,2,2,2,2]
08:06:54 <Kyo> is concat quadratic?
08:07:47 <merijn> Kyo: In what sense?
08:08:00 <merijn> :t concat
08:08:04 <lambdabot> [[a]] -> [a]
08:08:12 <ramses_> Kyo: it iterates once over all but the last list, I think
08:08:18 <merijn> I think it's O(n)
08:08:26 <ramses_> (if you fully force it)
08:08:39 <ab9rf> i believe it's O(n) where n is the length of all the lists (except the last)
08:09:09 <merijn> Yeah, O(n)
08:09:35 <merijn> Kyo: Basically, concat uses (++) internally and (++) fuses
08:09:46 <ab9rf> @src concat
08:09:46 <lambdabot> concat = foldr (++) []
08:10:05 <ramses_> but it is important to use that (++) in the right way, otherwise it becomes quadratic
08:10:19 <merijn> Kyo: Since haskell is lazy "l1 ++ l2" doesn't actually need to traverse the first list until you actually use the result
08:10:23 <ab9rf> yeah if you did it as foldl (++) []....
08:11:02 <merijn> Kyo: And then it can just hook in l2 once you've already traversed the entire thing
08:11:59 <ramses_> ab9rf: you can make that mistake more easily in an explicitly recursive version
08:12:15 <ab9rf> ramses_: i've seen that demonstrated
08:12:57 <turiya> parcs: is it possible to obtain numerical solutions to linear differential equations in netwire. for example: dy/dt + y = u? where is u a wire and I want to obtain y.
08:15:33 <Kyo> @src catMaybe
08:15:33 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:15:39 <Kyo> @type catMaybe
08:15:41 <lambdabot>     Not in scope: `catMaybe'
08:15:41 <lambdabot>     Perhaps you meant one of these:
08:15:41 <lambdabot>       `catMaybes' (imported from Data.Maybe),
08:15:44 <Kyo> @type catMaybes
08:15:46 <lambdabot> [Maybe a] -> [a]
08:15:55 <Kyo> > catMaybes [Just 5 Nothing]
08:15:57 <lambdabot>   The function `Data.Maybe.Just' is applied to two arguments,
08:15:57 <lambdabot>  but its type `...
08:16:03 <ab9rf> you need a comma
08:16:03 <Kyo> @src catMaybes
08:16:04 <lambdabot> catMaybes ls = [x | Just x <- ls]
08:16:08 <Kyo> > catMaybes [Just 5, Nothing]
08:16:10 <lambdabot>   [5]
08:16:11 <ab9rf> > catMaybes [Just 5, Nothing]
08:16:13 <lambdabot>   [5]
08:16:34 <ab9rf> heh, guarded list comprehension
08:16:55 <Kyo> How does that actually work with Nothing?
08:17:10 <ab9rf> Kyo: nothing doesn't match the guard, so is ignored
08:17:13 <ramses_> Kyo: the pattern doesn't match so the Nothing is discarded
08:17:27 <ramses_> @undo [x | Just x <- ls]
08:17:28 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ls
08:17:42 <ramses_> there you have it explicitely
08:19:10 <Kyo> ya'all using emacs? is there some eclipse mode for haskell?
08:19:19 <ab9rf> Kyo: eclipse-fp
08:19:38 <ab9rf> Kyo: i use it sometimes.  it's not bad, but it's a monster resource pig.
08:19:59 <parcs> turiya: i'm not sure i fully understand the question, but i think the answer is probably not
08:23:15 <ab9rf> i don't think netwire can be used, directly at least, as a differential equation solver
08:23:20 <turiya> parcs: i was thinking if it was possible to obtain numerical solutions without actually solving them analytically. i was trying to understand what inputs (other than u) one needs to give the Wire which computes y (the previous value of y would do), but i am not quite sure
08:23:44 <ab9rf> it might be possible to use it to simulate the system and produce one possible numerical solution
08:28:01 <turiya> ab9rf: i think so. i really don't need a "differential equation solver" i.e., not an analytical solution but just a numerical simulation of the differential equation
08:30:04 <turiya> in C, one can use some difference operations to approximate the derivative
08:30:35 <ab9rf> turiya: you probably don't need the full complexity of FRP to simulate a differential equation system
08:32:01 <turiya> ab9rf: seems true but I just wanted to know if I can use FRP. i think there exist the GSL libraries to solve a differential equation.
08:32:30 <klrr> what's the difference between "$²
08:32:35 <klrr> what's the difference between "$" and "."?
08:32:57 <ramses_> :t ($)
08:32:58 <ab9rf> :t (.)
08:32:58 <lambdabot> (a -> b) -> a -> b
08:32:59 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:32:59 <ramses_> :t (.)
08:33:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:33:04 <ab9rf> that's the difference :)
08:33:21 <monoidal> http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign
08:33:24 <ion> A bit like the difference between + and showsPrec
08:33:26 <klrr> ab9rf: i dont get it
08:33:30 <ab9rf> $ is function application, . is function composition
08:33:35 <turiya> composition versus function application
08:34:35 <klrr> ab9rf: what's a "functiona application" and what's a function composition?
08:35:09 <ab9rf> klrr: "a $ b" is the same as "a b"
08:35:13 <turiya> composition is when the output of one function is input to another
08:35:20 <quchen> klrr: "f $ x = f x", "(f . g) x = f (g x)"
08:35:34 <ab9rf> quchen beat me to the rest of it :)
08:36:38 <turiya> if "f $ x = f x" what's the use of $ ?
08:37:04 <Adeon> you can avoid annoying parentheses in many situations
08:37:09 <Philippa> ($) is useful as a parameter, plus f $ 1 + 2 is not f 1 + 2
08:37:15 <ab9rf> turiya: sometimes you can make a more expressive presentation with $ instea dof lots of parentheses
08:37:21 <ramses_> turiya: explicitness, difference in fixity, possibility to section it
08:37:21 <Kyo> whats the way to do soemthing equal to define in C? just a function returning a value?
08:37:25 <geekosaur> normal application is highest precedence but ($) is lowest precedence
08:37:53 <klrr> okey so instead of writting "f $ g x" you do "(f . g) x" ?
08:37:55 <ab9rf> Kyo: define is a C preprocessor operation.  there's no real equivalent in haskell
08:37:59 <turiya> oh.. i see the precedence ..
08:38:10 <quchen> f x y = (f x) y, but f $ x y = f (x y)
08:38:31 <ramses_> > map ($2) [(+1),(4*)]
08:38:33 <lambdabot>   [3,8]
08:39:04 <quchen> Kyo: There is no define i C, that's the C preprocessor, which is effectively a typographical code rewriter.
08:39:17 <quchen> You can use CPP in Haskell as well.
08:39:24 <byorgey> klrr: right, or f . g $ x
08:39:29 <ab9rf> quchen: yes, but should you? :)
08:39:38 <quchen> ab9rf: Yes.
08:39:48 <byorgey> ab9rf: sure, but only when necessary.
08:39:49 <quchen> Not to the same extent though.
08:39:56 <ab9rf> quchen: there are probably situations, but not many
08:40:01 <ab9rf> and certainly not as many as in C
08:40:20 <ab9rf> not that you can't abuse the preprocessor in C.  lord knows i've seen lots of that.
08:40:24 <hpaste> kyo pasted “sockets” at http://hpaste.org/84980
08:40:25 <byorgey> most often CPP comes up when you want to conditionally include certain code depending on the versions of the libraries your code is being compiled with
08:40:33 <byorgey> or the version of the compiler.
08:40:34 <Kyo> dont i have to give ana ddress like LOCALHOST?
08:40:42 <Kyo> ^^ see my paste
08:41:03 <Philippa> Kyo: GHC will often inline things, so an ordinary function or value binding does the work of most sensible uses of #define. You can also run your code through cpp, of course
08:41:24 <ab9rf> :t listenON
08:41:25 <lambdabot>     Not in scope: `listenON'
08:41:25 <ab9rf> :t listenOn
08:41:25 <lambdabot>     Perhaps you meant one of these:
08:41:25 <lambdabot>       `listen' (imported from Control.Monad.Writer),
08:41:27 <lambdabot>     Not in scope: `listenOn'
08:41:27 <lambdabot>     Perhaps you meant one of these:
08:41:27 <lambdabot>       `listen' (imported from Control.Monad.Writer),
08:41:34 <ab9rf> sorry
08:41:49 <ab9rf> Kyo: read the docs for listenOn :)
08:43:29 <thoughtpolice> quchen: well, technically, there *is* a define in C, because preprocessor support is mandated by the standard. it just so happens that the C preprocessor can also work on not-C things (depending, of course)
08:43:46 <ab9rf> Kyo: in this case you don't specify a host addr, and let the OS bind a default address
08:44:14 <ab9rf> Kyo: if you actually specified localhost, the socket would only accept connections that are on the same interface as localhost, which means from localhost only
08:44:25 <thoughtpolice> (the line can even get slightly fuzzier when you have tools like clang that do not have a seperate preprocessor and compiler, it's all in the frontend)
08:44:27 <ab9rf> Kyo: if you bind no address, the socket accepts connections from all interfaces
08:44:42 <ab9rf> Kyo: how much networking experience do you have? :)
08:45:23 <tommd> Are there any windows users here willing to test install cipher-aes128?
08:45:54 <Kyo> how do I give localhost as a word32? it being an unisnged int...
08:46:08 <Kyo> tommd: what is it? is it a small download
08:46:38 <tommd> Kyo: It is AES-128 with automatic detection of support for NI instructions.
08:46:58 <tommd> If your tool set supports -maes then it builds with NI support.  If not, not.
08:47:01 <ab9rf> Kyo: you need a SockAddr, which has three diffrerent constructors
08:47:29 <tommd> Someone suggested it wouldn't build on windows but I'm not sure why they'd think that.
08:47:51 <Kyo> SockAddrInet PortNumber HostAddress
08:48:20 <ab9rf> Kyo: but in any case Socket.listenOn doesn't require a host address, just a port specification
08:49:20 <ab9rf> Kyo: listenOn is a convenience method that abstracts away the parts of the socket API that are normally the same in most applications
08:50:06 <ab9rf> Kyo: e.g. most network apps want to listen for connections from all interfaces, and so bind the wildcard address, and so that's what listenOn does
08:50:41 <ab9rf> Kyo: if you don't want to do that, you have to use the lower level Network.Socket.listen
08:51:03 <ab9rf> listen takes a Socket, which has a more complex constructor
08:51:37 <Kyo> all interfaces being wireless, ethernet etc...?
08:51:55 <ab9rf> Kyo: again, i have to ask, how much do you know about networking? :)
08:52:03 <Kyo> nothing
08:52:21 <ab9rf> trust me on this, just bind the wildcard :)
08:52:29 * hackagebot linux-kmod 0.1.0.0 - Linux kernel modules support  http://hackage.haskell.org/package/linux-kmod-0.1.0.0 (NicolaSquartini)
08:53:07 <ab9rf> Kyo: i don't want to go into a longwinded explanation of how networking works on POSIX platforms, because before long we'll be lost in ISO tier hell
08:54:23 <ab9rf> network engineering is my day job, and that combined with my abject refusal to tell lies to children will make this process long and tedious. don't go there.
08:56:47 <ab9rf> the short of it is that if you bind a specific address to a listening socket, the socket will only accept connections that are on the same interface as the bound address (modulo bridging and some other crazy shit you can do with netfilter).  the wildcard address will accept connections from all interfaces.
08:59:45 <ab9rf> technically we're dealing with interfaces at layer 3, and layer 3 interfaces may not have a one-to-one correspondance to interfaces that exist at layers 1 or 2
09:00:38 <klrr> how do i rewrite http://hastebin.com/puteguyera.hs so it uses do notation?=
09:01:14 <ab9rf> @do liftM (Number . read) $ many1 digit
09:01:14 <lambdabot> liftM (Number . read) $ many1 digit
09:01:20 <ab9rf> that wasn't helpful :)
09:01:29 <quchen> do liftM (Number . read) $ many1 digit
09:01:31 <quchen> There you go
09:01:37 <ab9rf> quchen: haha
09:01:44 <klrr> wtf
09:01:56 <klrr> am i stupid or is the exercise to rewrite that stupid?
09:02:10 <ab9rf> klrr: maybe you've misunderstood the assignment?
09:02:24 <quchen> klrr: We don't know the exercise, but rewriting that in terms of do is very pointless.
09:02:38 <ab9rf> i'm not sure why you'd want to rewrite that in terms of do
09:02:54 <klrr> they want me to rewrite that with do notation, and also another version using ">>="
09:03:04 <quchen> do { x <- many1 digit; return . Number . read $ x }
09:03:10 <quchen> Something like that maybe
09:03:11 <ab9rf> i guess they want you to break into the liftM
09:03:18 <quchen> But that's pretty bad style as you should use fmap for this.
09:03:21 <RayNbow> @src liftM
09:03:21 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:03:37 <ab9rf> @src return
09:03:37 <lambdabot> Source not found. Sorry.
09:03:42 <ab9rf> really
09:03:50 <quchen> return has no source.
09:04:02 <ab9rf> bad return :)
09:04:14 <quchen> Return never has "a" source, it's implementation dependent.
09:04:17 <ab9rf> @src (>>=)
09:04:18 <lambdabot> Source not found. :(
09:04:27 <klrr> i dont even get what liftM bs does
09:04:35 <quchen> klrr: liftM = fmap
09:04:37 <quchen> Always
09:04:39 <ab9rf> klrr: lambdabot just told you :)
09:04:40 <RayNbow> @src [] (>>=)
09:04:40 <lambdabot> xs >>= f     = concatMap f xs
09:04:45 <RayNbow> @src IO (>>=)
09:04:45 <lambdabot> m >>= k     = bindIO m k
09:04:46 <klrr> is liftM same as fmap?
09:04:57 <ab9rf> klrr: indeed
09:04:58 <quchen> liftM (Number . read) $ many1 digit
09:05:01 <quchen> Eh, sorry
09:05:03 <quchen> Wrong button
09:05:07 <RayNbow> @src IO return
09:05:07 <lambdabot> return x    = returnIO x
09:05:12 <RayNbow> @src [] return
09:05:13 <lambdabot> return x    = [x]
09:05:21 <ab9rf> @src Parser return
09:05:21 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:05:33 <quchen> klrr: Use fmap, not liftM. liftM is a historical accident.
09:05:37 <ab9rf> yeah, lambda bot doesn't have Parser loaded
09:05:53 <RayNbow> @src lambdabot
09:05:54 <lambdabot> Source not found. Do you think like you type?
09:06:00 <RayNbow> aww
09:06:08 <quchen> ab9rf: @src checks a static list of common functions. It's not about loaded or not.
09:06:09 <ab9rf> haskell is hard to make sense of whe you have a cold and your kids are watching world word.
09:06:20 <ab9rf> it's amazing how brainstopping children's television is.
09:06:30 <quchen> ab9rf: Basically someone pasted functions people wanted to know the source of into a textfile, and @src searches that.
09:06:30 <ab9rf> quchen: ah
09:06:45 <quchen> At least I was told so.
09:06:53 <ab9rf> quchen: i have no reason to disbelieve you
09:08:02 <RayNbow> searching a textfile is such an outdated technology... lambdabot should make use of crowdsourcing (e.g., Amazon Mechanical Turk) and ask workers to supply the source definitions
09:08:18 <ab9rf> RayNbow: it could search stackexhcnage :)
09:08:27 <klrr> guys is this correct? http://hastebin.com/baxeyuqoco.hs
09:08:30 <mansgrf> http://www.reddit.com/r/xWETPUSSYx/comments/1bfdqt/experienced_girl_does_naked_yoga/
09:09:04 <quchen> klrr: Use HPaste please. hastebin displays nothing for me.
09:09:08 <quchen> @hpaste
09:09:08 <lambdabot> Haskell pastebin: http://hpaste.org/
09:09:12 <ab9rf> another reminder of why i hate reddit
09:09:25 <quchen> ..?
09:09:32 <klrr> http://hpaste.org/84981
09:09:34 <ab9rf> nevermind
09:09:46 <ab9rf> hastebin is insanely slow for me
09:10:23 <ab9rf> klrr: note the "error: Redundant do" at the bottom
09:10:26 <quchen> klrr: That "do" is pointless, you can remove it. Like we said, converting the code you gave us to do notation is kind of an odd task.
09:10:47 <ab9rf> klrr: i imagine they want you to unwide the liftM/fmap
09:10:50 <quchen> Maybe you're supposed to not use fmap, and do everything in explcit monadic code for whatever reason
09:10:50 <ab9rf> er, unwind
09:11:10 <ab9rf> i suppose to demonstrate that yuou know what liftM does :)
09:11:21 <klrr> do sucks man whore penis
09:11:38 <ab9rf> klrr: that's not very respectful of man whores.
09:11:44 <glguy> klrr: clean up your language, please
09:11:55 <klrr> ab9rf: why not?
09:11:58 <klrr> sry sry sry
09:12:12 <quchen> do is a syntactic construct and does not commonly engage in sexual activities, according to the Haskell report.
09:12:15 <ab9rf> @src liftM
09:12:15 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:12:24 <klrr> me get very angry easily when im getting disopointed at myself
09:12:32 <ab9rf> quchen: commonly?  under what circumstances does it engage in sexual activities?
09:12:50 <ab9rf> klrr: as long as you don't turn green and smash things
09:12:54 <quchen> How would I know? Refer to the report!
09:13:06 <ab9rf> quchen: touché
09:13:58 <klrr> ab9rf: hehe already did punch my table several times :P
09:14:30 <klrr> what's "Prelude"?
09:14:45 <Kyo> klrr: the interactive prompt
09:14:52 <klrr> okey
09:14:52 <ab9rf> klrr: the standard definitions that are loaded by default
09:15:04 <klrr> ab9rf: so it's the default default library?
09:15:05 <quchen> klrr: Have you read LYAH? Writing a Lisp interpreter surely isn't the right way to start off.
09:15:08 <quchen> @lyah
09:15:08 <lambdabot> Unknown command, try @list
09:15:12 <quchen> @where lyah
09:15:12 <lambdabot> http://www.learnyouahaskell.com/
09:15:16 <klrr> quchen: i dislike manuals
09:15:26 <ab9rf> lyah is not a manual
09:15:30 <klrr> feels like one
09:15:35 <ab9rf> really
09:15:37 <ab9rf> ?
09:15:39 <quchen> I dislike taking the bus. I still have to.
09:15:40 <klrr> besides i hate reading on the screen
09:15:54 <ab9rf> klrr: are you sure you want to be a computer programmer?
09:15:54 <klrr> i hate computers and everyhing ^^
09:15:54 <Philippa> you're doing that now anyway
09:15:57 <quchen> Buy the book?
09:16:03 <Philippa> print it?
09:16:13 <klrr> we got no printer atm xD
09:16:13 <Philippa> kllr: learn Haskell by hand-evaluation!
09:16:37 <klrr> ab9rf: programming, i guess i have to somehow get more iq to even start ?
09:16:43 <klrr> is it possible to gain iq ?
09:16:49 <ab9rf> klrr: that's not what i asked
09:16:56 <companion_cube> you can reach enlightenment!
09:16:57 <ab9rf> klrr: it's not whether you _can_, it's whether you _want to_
09:17:10 <ab9rf> if you hate doing this, why are you doing it?
09:17:16 <klrr> ab9rf: want or want, i want to get laid more, secondly learn programming, after that mathiscian
09:17:33 <klrr> (and learn english too ;) )
09:17:39 <quchen> Oh boy. I'm going to have a shower, you guys have fun here.
09:17:43 <ab9rf> quchen: ha
09:18:04 <ab9rf> i'd be very surprised to find out that anybody ever got laid more as a result of learning haskell
09:18:09 <dmwit> Programming can get you laid!
09:18:11 <Philippa> klrr: discussion of people's sex lives or lack thereof belongs in -blah
09:18:21 <dmwit> okay, okay, Philippa has a point
09:18:50 <klrr> wasent trying to bring it up, tried to answer ab9rfs question sry
09:19:02 <klrr> puberty bs messing with me
09:19:17 <ab9rf> klrr: there is a limit to how much you can depend on others to help you.  you gotta help yourself some too.
09:19:53 <klrr> ab9rf: yes, i only ask if i dont understand hoogle's explaination or if i dont find good google results
09:20:56 <klrr> what's ">>=" called, i dont get any results on google
09:20:57 <ramses_> klrr: a good book might give a lot more context and guidance for the learning process than hoogle results and haddocks
09:21:05 <monoidal> klrr: bind
09:21:44 <otters> duckduckgo can search for operators, i believe
09:21:45 <klrr> ramses_: indeed, but there's no book stores with programming books near me and my parents dont wanna order more programming books to me
09:21:54 <otters> klrr: you can also use hoogle or hayoo
09:21:58 <monoidal> klrr: you can use http://www.haskell.org/hoogle/ to search for operators and haskell-related things
09:22:00 <klrr> otters: i do
09:22:03 <ab9rf> klrr: there's a symbol search site that can search stackexchange for random symbols
09:22:18 <ab9rf> and hoogle searches haskell content for nearly anything
09:22:46 <ab9rf> i'd really suggest that you bear down and work through LYAH though, or some other organized resource
09:23:01 <ramses_> klrr: than maybe you should learn reading from the screen, as you're doing anyway while asking questions here
09:23:05 <ab9rf> trying to learn a language by google searches is.. not very efficient
09:23:06 <ramses_> s/than/then
09:23:35 <klrr> i know, that's why im reading this scheme in 48 hours book
09:24:07 <ab9rf> klrr: trying to learn more than one language at the same time is also generally a bad idea
09:24:12 <ramses_> ouch, learning multiple new languages at the same time is not easy imho
09:24:25 <klrr> i know some scheme already, and some C
09:24:25 <ab9rf> klrr: this is why i'm not trying to learn scala right now
09:24:49 <Philippa> ab9rf: Scala is so the new C++, and that's not a compliment :-(
09:24:51 <ab9rf> i've allocated january through june to haskell
09:24:53 <ramses_> I'd choose one to focus on first, then start with the other after you're a bit comfortable in the first
09:25:01 <klrr> ive always wanted to write scheme interpreter since you do that in sicp which im too low iq for
09:25:03 <ab9rf> in july i'll pick a new language
09:25:11 <ab9rf> last quarter i allocated to ruby
09:25:16 <ab9rf> (october through december)
09:25:34 * Philippa finds learning multiple smallish languages simultaneously isn't a disaster so long as she doesn't need to get deep with them - but that's the near-equivalent of learning Haskell libs simultaneously
09:25:35 <ramses_> Philippa: I wholeheartedly agree (I'm doing some scala stuff atm)
09:25:55 <ab9rf> Philippa: i can't really comment on a language until i've learned it
09:26:01 <ab9rf> Philippa: first impressions can be long
09:26:11 <ab9rf> er wrong
09:26:13 <Philippa> (disclaimer: I've utterly lost count of the number of languages I've been at least somewhat familiar with)
09:26:26 <ab9rf> Philippa: i stopped counting when it crossed 20.  and that was in 1996.
09:26:45 <klrr> are there any good guide to haskell which aint like a manual, is Programming in Haskell good?
09:26:47 <ab9rf> (scheme was #20)
09:26:59 <Kyo> is resolve "" = blah equal to resolve [] = blah ?
09:26:59 <Philippa> *nod*. To be fair, when I say "the new C++" I mean accounting for overall improvements over time too - and I'm reading as a serious PL research nerd
09:27:07 <hiptobecubic> ab9rf, why so late?
09:27:09 <klrr> FUCK, im already giving up my new motto -.-
09:27:10 <Philippa> klrr: what's "like a manual" to you?
09:27:25 <klrr> Philippa: it simply teach the language, not how to use it
09:27:31 <ab9rf> hiptobecubic: with respect to which, scheme, or haskell?
09:27:38 <Philippa> ab9rf: main new lang I learned in '96 was QuakeC, but then I was a kid
09:27:40 <hiptobecubic> scheme
09:27:48 <ab9rf> hiptobecubic: i picked up scheme because i was working on a project that used scheme as an imbed language
09:27:56 <Mortchek> Kyo, almost - "" is the empty list of [Char], [] is the empty list of [a] for any a.
09:28:10 <Philippa> klrr: okay. "How to use it" is widespread and complicated with Haskell because it encompasses so many of the things you can do with programming generally - it's a bit like "how do I use lisp?"
09:28:12 <ab9rf> hiptobecubic: i already knew common lisp at that point, so it wasn't all that hard
09:28:17 <hiptobecubic> oh ok
09:28:21 <Philippa> but Real World Haskell might help or might be too much?
09:29:27 <klrr> Philippa: okey, cause when i tried learn C and Scheme i ended up with much knowledge about how to define functions and shit, but i could not write a single "real" program
09:29:42 <ab9rf> klrr: you haven't spent enough time with either, then
09:29:53 <hiptobecubic> You couldn't write a "real" program in C or scheme?
09:29:56 <ab9rf> it took me two or three years to learn my first language
09:30:10 <ab9rf> well, maybe a bit less
09:30:19 <ab9rf> depends on what you count as a "real"program
09:30:29 <ab9rf> ""10 print "Hello!" 20 goto 10 is not a
09:30:34 <ab9rf> is nt really a real program
09:30:43 <Philippa> klrr: yeah, if you don't know how to write a "real" program in anything then there's a lot to learn - you don't just want to learn a language, you want to learn programming at all as well, or the design of software...
09:30:45 <klrr> ab9rf: okey, so that means i have too little consentration for programming, is there a way to get better at consantration, is there adhd drugs you can get legally without medical reasons?
09:30:53 <ab9rf> klrr: coffee
09:31:01 <hiptobecubic> ab9rf, well termination is a good property for "real programs" to have
09:31:09 <ludamad> whats the easiest way to go from newtype A = A B back to B ?
09:31:09 <ab9rf> hiptobecubic: heh
09:31:11 <klrr> ab9rf: i already drink coffe all the time
09:31:13 <hiptobecubic> not always of course :)
09:31:16 <Philippa> ab9rf: I'm pretty sure I'm not the only person who gets too caffeinated to concentrate :-)
09:31:16 <ab9rf> ludamad: pattern matching
09:31:26 <ludamad> ab9rf: darn, was hoping to get it on one line
09:31:27 <heatsink> ludamad: you can also define a field name
09:31:33 <Philippa> hiptobecubic: are we counting coprograms separately?
09:31:33 <ab9rf> Philippa: it's impossible for me to be to caffeinated to concentrate
09:31:33 <heatsink> newtype A = A {fromA :: B}
09:31:38 <ludamad> heatsink: Not my code :-)
09:31:43 <heatsink> oh
09:31:56 <ab9rf> ludamad: fromA (A x) = x
09:32:11 <Philippa> ab9rf: lucky! My brain's scheduler is pretty much FUBAR, but that's a -blah topic
09:32:15 <ramses_> ludamad: then write the unwrapping function yourself with pattern matching and use that function everywhere else
09:32:30 <ludamad> ok, ty guys
09:32:30 * hackagebot ajhc 0.8.0.1 - Haskell compiler that produce binary through C language  http://hackage.haskell.org/package/ajhc-0.8.0.1 (KiwamuOkabe)
09:32:30 <ab9rf> Philippa: however, inadequate caffeineation will prevent concentration
09:33:01 <Philippa> *nod*. Yeah, that certainly happens to me. Better to be a bit slow and able to accumulate work than be all over the place for me, though
09:33:23 <klrr> PENIS, i need food bb
09:35:23 <ab9rf> hiptobecubic: i rather liked scheme when i discovered it, i thought that the design rectified a lot of the things about common lisp that i disliked
09:35:38 <klrr> scheme is super nice, but it sucks too
09:35:40 <hiptobecubic> I haven't used CL for anything
09:35:42 <Philippa> yeah, scheme's a nice lang
09:35:55 <hiptobecubic> i like scheme's bare-bones approach a lot though
09:35:58 <Philippa> not my thing, but in a way I have a definite respect for
09:36:04 <ab9rf> hiptobecubic: i haven't since the late 80s, i suppose
09:36:20 <Philippa> (...*sigh*, must pick up that syntax extension project again, if only to compare it to how SugarHaskell works)
09:36:28 <ab9rf> hiptobecubic: although there's one project that i work on a little that has a massive chunk of lisp code in it for something.  i've never touched that part of the project though.
09:36:29 <klrr> i have a question, why does haskell stuff have cool names and shit?
09:36:41 <Philippa> because we're not IBM employees
09:36:43 <hiptobecubic> klrr, Because it's totally rad, brah
09:37:06 <klrr> is it to trick stupid people like me to learn it and then realize how dumb they are and never go back to computers or kill themself?
09:37:34 <Philippa> honestly? Haskell's easiest to teach as an extension of maths, I find
09:37:47 <Philippa> hrmm, point
09:37:52 <ab9rf> Philippa: that's part of why i find haskell so challenging.  i suck at abstract algebra.
09:37:57 <Philippa> klrr: have you met the idea of a problem domain before?
09:38:26 <Philippa> ab9rf: I never learned it properly, which is a shame - I was clearly looking for it by my mid teens, I just didn't have access to anything that'd point me in the right direction
09:38:46 <ab9rf> i bombed out of mathematics at multivariate analysis.
09:38:50 <klrr> Philippa: what's that?
09:38:56 <ludamad> Philippa: it'd be nice if programming was taught as an extension of math in eg elementary school
09:39:03 <Philippa> so the basic mindset makes natural sense to me, I guess, but I'm also one of those who value a good piece of informal intuition
09:39:07 <ludamad> not everyone would like it, but then again tons of people hate math
09:39:10 <hiptobecubic> ludamad, spj disagrees :)
09:39:20 <ludamad> hiptobecubic: Oh ?
09:39:25 <ab9rf> ludamad: that's because elementary teachers hate math and pass that hate onto their students
09:39:52 <hiptobecubic> ludamad, http://www.infoq.com/presentations/education-IT-CS
09:39:52 <ab9rf> ludamad: and thereby keep perpetuating an irrational hate of math across the generations
09:39:59 <Philippa> klrr: it's a way of talking about the kind of program you're trying to write. A lot of programming knowledge is "domain-specific" - about specific kinds of problem. So you accumulate a lot of that as you go. Some of it's fairly generalised, and often that forms the skeletons you build programs around
09:40:40 <klrr> Philippa: i dont know what to write, well i have two things but they're compleetely different
09:40:42 <Philippa> ab9rf: honestly? You have a stronger maths background than I do
09:40:42 <ludamad> I just don't think I'd be nearly the coder I am if I didn't discover programming so early
09:40:53 <Philippa> klrr: that can be a problem :-) What are the two things?
09:41:01 <Philippa> (I was heavily into game design and development as a teenager..)
09:41:08 <ludamad> hiptobecubic, thanks for the link!
09:41:15 <hiptobecubic> ludamad, it's a good video
09:41:24 <ludamad> ill have to watch it later, sadly
09:41:27 <ludamad> but ill keep it bookmarked
09:41:33 <klrr> Philippa: website, scheme implementation, the latter sounds coolest
09:41:36 <hiptobecubic> My first several years of programming experience were entirely on graphing calculators
09:41:47 <klrr> also , i hate the web
09:41:49 <ab9rf> i feel old now
09:41:53 <Philippa> klrr: A Scheme in Haskell is a good learning exercise, yeah
09:42:03 <Philippa> one it'll take a while to build to, but not appallingly so
09:42:08 <klrr> Philippa: should i read SICP and do everything with haskell?
09:42:08 <ab9rf> graphing calculators didn't exist until after i'd already learned a dozen languages
09:42:16 <Philippa> do you know enough haskell to write a calculator?
09:42:38 <klrr> Philippa: nope, i can write fibonacci and hello world and that
09:42:41 <ludamad> Game Maker was my first mistress. what a horrid language
09:42:43 <Philippa> ab9rf: heh, *I* feel old worryingly often now. I mean, think how many kids never knew a world where internet access wasn't commonplace...
09:42:49 <hiptobecubic> Although, I *did* manage to write a pokemon clone with trading and battling over the TI-Link cable.
09:42:59 <ludamad> nice :-)
09:43:05 <Philippa> klrr: okay. Start with this datatype: data Term = Val Int | Add Term Term
09:43:16 <hiptobecubic> I'm not entirely sure why I didn't make the jump to pc programming until after high school
09:43:31 <Philippa> klrr: read enough of LYAH that you can work out how to write a recursive function that takes a Term and does all the addition to give you an Int back
09:43:38 <quchen> hiptobecubic: Because in high school Word is more valued?
09:43:39 <klrr> Philippa: dont remember, i learned about types a week ago but ive been on a trip and forgot everything
09:43:54 <Philippa> then you can try adding multiplication, variables and let-bindings, maybe write a parser...
09:43:55 <ab9rf> hiptobecubic: game programming often teaches really bad habits.  i used to TA for intro CS and breaking students of bad habits was almost as hard as teaching people who had no prior experience.
09:43:56 <klrr> Philippa: i try now, bb
09:44:04 <hiptobecubic> oh wait, i wrote a program in QBASIC to automate employee timecards at my dad's job when i was 10
09:44:10 <hiptobecubic> but it was buggy :D
09:44:19 <ludamad> ab9rf: I can confirm that :-)
09:44:24 <ludamad> But just because of my own struggle
09:44:29 <hiptobecubic> blahblah something about not all months have 30 days. Who has time for that
09:44:37 <Philippa> ab9rf: yep. Explaining the ways gamedev is weird is tricky as well because game developers have historically had as bad a case of "we're the real hackers!" as anyone going
09:44:40 <ab9rf> hiptobecubic: people should just use the shire calendar
09:44:43 <Philippa> (I don't think it's as bad these days, though)
09:45:05 <Philippa> gotta respect the scene though, lotta good stuff came out of there - I just don't want to read the source, as a rule
09:45:17 <ab9rf> Philippa: don't get me started.  i've been ranting all over the internet lately over how nobody at EA has ever heard of Dijkstra
09:45:34 <Philippa> ab9rf: That's EA for you, though
09:45:36 <ludamad> Philippa: Yea I never write as much non-ideal code as when I'm hacking a game together quick
09:46:01 <ludamad> im trying to architect https://github.com/ludamad/lanarts nicely, but its hard
09:46:05 <ludamad> its been a gradual effort
09:46:13 <Philippa> ludamad: yeah, and knowing how to pull retrace-based IO trickery was what used to make you "better", FFS
09:46:17 <Hafydd> Never heard of Edsger Dijkstra himself, or never heard of the algorithm named after him?
09:46:23 <Philippa> to be fair, the tools *sucked* back then? But still
09:46:32 <Philippa> Hafydd: the latter, while writing path-finding code
09:46:39 <ab9rf> the new simcity has totally broken traffic routing, and the developer responsible for the algorithm posted a blog post explaining how it "works".  the algorithm is broken, will reliably create loops, and evidences that the idiot has never heard of any of the shortest-path algorithms that were developed in the 60s and 70s.
09:46:59 <ludamad> ab9rf, sad :-)
09:47:30 * hackagebot xml 1.3.13 - A simple XML library.  http://hackage.haskell.org/package/xml-1.3.13 (IavorDiatchki)
09:47:43 <Philippa> mmm. I mean, if you intend for traffic routing to be a bit shitty, you should be saying so
09:48:11 <Philippa> (plenty of gameplay that started as a bug, after all - I think my favourite example's a foundational development in fighting games)
09:49:03 <Taneb> "The cabinet got possessed by a voice that shouted 'FINISH HIM', so the developers rolled with it."
09:49:20 <Philippa> Taneb: Hah. Y'know, I'm not sure I can think of *anything* good that came of that series :p
09:49:46 <Philippa> but you know you've got problems when the devs are talking about how their game is more hardcore because they have d,f+P instead of qcf+P
09:50:30 <ab9rf> although dijkstra might not be the best choice; johnson or floyd-warshall might make more sense especially with dynamic caching. but it's obvious the guy had never heard of anoy of these
09:50:44 <Philippa> ab9rf: I do think there's real work to be done on how to handle the sweng of games, but there's no way in hell I want to be anywhere near a modern AAA title's codebase anyway
09:50:54 <Taneb> The only fighting games I can play at any degree of competence have Mario on the box
09:51:09 <Philippa> Taneb: Heh. I have respect for SSB, I'll say that much
09:51:31 <Taneb> Philippa, came 4th place in a Brawl competition last weekend
09:51:45 <ab9rf> of course, simcity 2013 is implemented primarily in javascript
09:51:50 <ab9rf> which itself makes me want to hide
09:52:00 <Philippa> ab9rf: mmm. You know you're working for the borg when...
09:52:41 <Philippa> I mean okay, I can see how it's an appropriate thing to have somewhere in the toolchain these days given the number of target platforms it runs on. Javascript is the new machine code. But still, like hell do you want to write directly in it for most tasks if you can do better!
09:53:07 <ab9rf> Philippa: especially since the mac port won't be available for another four months
09:53:22 <Philippa> ab9rf: *dies of shock*
09:53:39 <Philippa> lucky for me it's not my genre. My gf is not happy, though
09:53:59 <Philippa> (not surprised, admittedly: she did a lot of relevant sim stuff at uni, we've not chatted about it in detail but kinda didn't need to)
09:54:34 <ab9rf> i'm probably going to extend my haskell cycle past june, i'm seriously thinking of looking at game programming in haskell
09:54:45 <ab9rf> provbided i can get wxwidgets or ncurses to bloody well comppile on my laptop
09:54:49 <Philippa> if you do, I'd be interested in comparing notes sometime
09:55:01 <Philippa> though I'm possibly a bit too picky about just how typeful I want my gamedev to become
09:55:28 <ab9rf> i have a feeling that lenses will be useful
09:55:32 <ab9rf> but haven't learned those yet
09:55:41 <klrr> FUCKI
09:55:49 <Philippa> *nod* they will, yeah. I've not learned them enough to see the non-obvious ways they'll be useful, though!
09:56:02 <klrr> i cant write a stupid calulator i dont have the brain for that
09:56:15 <klrr> bb me gonna fucking punch my mom if i dont get food now bbl
09:56:27 <glguy> mode +q klrr
09:56:55 <ab9rf> can't say i approve of mom-punching
09:57:34 <klrr> ab9rf: didnt punch her, even though i really want to
09:57:43 <Philippa> get your own food?
09:57:52 <ludamad> if you make a game in haskell, you can always have an imperative cop-out by using a scripting language
09:57:57 <ab9rf> ludamad: ugh
09:58:01 <klrr> tried, she was like "oh just 10 min left oh you wait "
09:58:07 <Philippa> I mean okay, my own mum used to run the kitchen so as to make it impossible for anyone else to use, but still
09:58:19 <ludamad> ab9rf: Dont like layers like that ? :-)
09:58:27 <ab9rf> ludamad: don't like cop-outs
09:58:28 <ludamad> I had to when my C++ game grew to a certain point
09:58:29 <ludamad> Ah
09:58:44 <ab9rf> ludamad: that said actually one of the ideas i've had includes having the game compile itself
09:58:58 <ludamad> mm, bootstrapping
09:59:02 <ab9rf> ludamad: although not probably to machine code
09:59:10 <ab9rf> ludamad: and so there's be a DSL for that
09:59:31 <Philippa> ab9rf: I tend to use haskell as a metalanguage with lots of things embedded in it, myself - that's definitely not a cop-out, but it's different to sticking to pure FP
10:00:16 <ludamad> ab9rf: I think DSL's for game content are a cool thing. although after a lot of tinkering I just used Lua as a data-description language. Flexibility & syntax lots of people can understand helps when you're trying to get people on board
10:00:41 <ludamad> (note, I have utterly failed at getting people on board :-()
10:00:42 <ab9rf> ludamad: i ran into lua about a year ago; it left a sour taste with me
10:00:49 <ludamad> Yea, its ok
10:00:50 <saml> microsoft dropped haskell. rip
10:00:51 <Philippa> ludamad: yeah, working out how to do stuff typefully is *hard*, alas
10:01:19 <ab9rf> Philippa: no, it's not hard, it just requires thinking differently
10:01:32 <ab9rf> Philippa: and _that_ is what is hard for many people
10:01:39 <Philippa> ab9rf: let me know when you spot the open research problems here
10:01:55 <ab9rf> especialyl epople with years, or decades, of thinking in other ways
10:02:04 <Kyo> is a socket either a server or client or can i send and listen on the same socket?
10:02:25 <ludamad> Kyo: You can send and receive from the same socket
10:02:34 <quchen> saml: Huh?
10:02:37 <ab9rf> Kyo: sockets are used for both, but a single socket can either be used to connect to a remote socket, or listen for incoming sockets
10:02:45 <Philippa> we *don't* know what a good typeful language for describing the kinds of interactions you see in anything much more complicated than a eurogame looks like
10:02:53 <ab9rf> once the socket is connected, yuo can both send and receive on it, regardless of how it connected
10:03:23 <ab9rf> Philippa: i wouldn't know what the open research problems *are*, i'm not nearly up to date on what is and isn't an open research problem
10:03:36 <ab9rf> i'm a network and systems engineer, programming is a hobby for me
10:03:48 <ludamad> Philippa: I was watching a good video on designing games, it said something to the effect 'if you think there's a good architecture for game logic, you're wrong, its always a mess'
10:03:49 <Philippa> ab9rf: yeah. Just saying, *in this domain* working out how to do things typefully is hard
10:04:12 <Philippa> ludamad: mmm. I'm not satisfied that *has* to be the case yet, but I wouldn't be surprised if there are some pithy theorems to be had
10:04:12 <ab9rf> ludamad: i don't believe that
10:04:25 <ab9rf> ludamad: i think that's just game developers self-justifying their sloppy way of doing development
10:04:51 <Philippa> ab9rf: I sure know a tabletop company that's worse
10:04:51 <ludamad> ab9rf: the video was very good. it was more 'no silver bullet' kinda thing. some stuff in games is necessarily finnicky
10:05:11 <Philippa> mmm, it's certainly possible to run into the issues in something one person can write
10:05:15 <ab9rf> ludamad: that happens in part because they tend to write close to the hardware and hardware is notoriously finicky
10:05:34 <ab9rf> ludamad: exceptions are always sticky and hardware generates exceptions
10:05:34 <Philippa> ab9rf: no, that's not the stuff we're talking about
10:06:22 <ludamad> ab9rf: i think he meant more high level stuff
10:06:30 <Philippa> really, the basic IO isn't that hard. AAA titles get seriously warped by what's involved in getting the feed rates up, sure
10:06:31 <ab9rf> such as?  i'm not seeing it
10:06:54 <Philippa> ab9rf: Rockets do 100 damage. Shamblers take half damage from rockets. Trolls don't regenerate when damages with fire. Etc etc.
10:07:01 <hiptobecubic> feed rates?
10:07:03 <ab9rf> Philippa: that's not difficult
10:07:09 <ludamad> ab9rf: its a lot of little details
10:07:10 <Philippa> ab9rf: it's difficult to scale well
10:07:11 <ab9rf> Philippa: it's tedious, but not difficult
10:07:16 <ludamad> hence, a mess
10:07:26 <ludamad> you cant reason about it in one blow
10:07:34 <Philippa> ludamad: it's a lot worse when you want to start talking about ruleset transformations, too
10:07:49 <ab9rf> it's difficult because typicalyl your first three or four efforts are insufficiently general
10:08:08 <Philippa> I mean, UT's mutator system is awesome? When you start playing with it, you quickly realise how limited it is too. After a while, you start realising that you don't even know how to fix UnrealScript enough to make it all work nicely
10:08:10 <ab9rf> and sometimes the refactoring needed to make them more general is hard
10:08:18 <hiptobecubic> ab9rf, isn't pretty much all software like that ?
10:08:23 <Philippa> ab9rf: We *don't know what the target form should look like* for this
10:08:33 <hiptobecubic> You throw out *at least* one iteration
10:08:40 <ab9rf> hiptobecubic: of coruse
10:08:56 <ludamad> Im struggling with this very problem in my game lanarts, I have to move to some complex system because my item scripting was horridly rigid
10:09:07 <Philippa> it's inherently the sort of clusterfuck that spawns attempted solutions like OOP and AOP that patch it up a bit but never solve it
10:09:16 <Kyo> Missed the answer and cant find the question,sorry, reposting: is a socket either a server or client or can i send and listen on the same socket?
10:09:17 <Philippa> we might find a solution? But that's the open research problem
10:09:23 <ab9rf> the rapid development cycles of game development discourage attempting to engineer generalized solutions
10:09:33 <Philippa> I've not seen it solved even for tabletop, not really
10:09:44 <ab9rf> because a generalized solution typically means a framekwork for which quite a bit of code has to be written before it'll run at all
10:09:45 <Philippa> there are just good ways of presenting finished product - engineering it's shitty
10:09:56 <ludamad> <ab9rf> Kyo: sockets are used for both, but a single socket can either be used to connect to a remote socket, or listen for incoming sockets
10:10:10 <ab9rf> Kyo: sockets are used for both, but a single socket can either be used to connect to a remote socket, or listen for incoming sockets
10:10:15 <ludamad> :-)
10:10:33 <ab9rf> Kyo: you can't do both with the same socket object
10:10:52 <ab9rf> er listen for incoming _connections_, my bad
10:11:43 <ab9rf> Philippa: i think haskell game development is more likely to generate the generalized frameworks because haskellers have a notorious habit to seek the most general way to do anything
10:12:30 <huad> how can i define an char or double enum
10:12:44 <Philippa> ab9rf: Yeah. But people've been poking at it for 15 years in Haskell. I've been doing it for at least 10, and when I talk about some of the basic problems making it typeful in here I get very smart people basically saying they haven't a clue and to use something like prolog instead
10:12:57 <Philippa> we don't even know what the appropriate typeful-prolog code might look like
10:13:15 <Philippa> (for similar reasons to the fact typeful constraint programming's an open problem)
10:13:29 <Kyo> ok so for a client to send something to a server and receive something I need 2 sockets...
10:13:31 <Kyo> ?
10:13:38 <ab9rf> Kyo: no
10:13:48 <johnw> sockets are full duplex
10:13:50 <ab9rf> Kyo: you can use the same socket to communicate in both directions with a server
10:14:05 <ab9rf> Kyo: but you _cannot_ use the same socket both to _run_ a server and also connect as a client to another server
10:14:18 <Chousuke_> is it something that would even benefit from types? I guess you could have some sort of type checking so that your rules make sense... but then you'd have to define rules for what makes sense.
10:15:55 <Kyo> ab9rf: so i connect a client with a server and then just send on the same socket and on the client side i recv on the same socket`?
10:15:55 <ab9rf> basically once you have a socket, you can _either_ call connect on it to connect it to some other endpoint _or_ call listen on it to allow others to connect to it.  you cannot do both.
10:16:30 <huad> how can i define an char or double enum
10:16:31 <ab9rf> once you have a connected socket, either as a result of calling connect, or as a result of calling accept, you can communicate in both directions on that socket
10:16:38 <Chousuke_> Kyo: sockets are machine-specific.
10:16:49 <ab9rf> (also, the rules are different for UDP sockets, since those are optionally connectionless)
10:16:54 <ab9rf> Chousuke_: and protocol-specific
10:17:10 <Kyo> the basic interface is the same i thought?
10:17:14 <Chousuke_> Kyo: you can open a socket that listens on a port for TCP on the server, and a socket that sends data to that port on the client.
10:18:26 <Kyo> yes and then the server sends a response. but ont he same socket?
10:18:51 <gelisam> huad: hi! did you read my advice on reddit? your questions are short and vague. what are you trying to do?
10:18:52 <ab9rf> Kyo: yes
10:19:01 <ab9rf> the channel is bidirectional
10:19:37 <ab9rf> huad: what are you asking?
10:20:32 <huad> gelisam: yes i read your advice. But now how can I ask this question long?
10:20:44 <ab9rf> Kyo: the server creates a socket, binds it to an address, and calls listen to say "i'm willing to accept connections".  it then calls accept, which blocks until a connection is available (or uses other ways to wait for connections, such as select)
10:21:13 <gelisam> huad: just tell us more about what you are trying to do. How would you write it in C++, for example?
10:21:15 <Chousuke_> Kyo: actually when you accept a connection on the server side, the accept call returns you a new socket that you can use to send data to the client who connected.
10:21:55 <ab9rf> Kyo: at least this is the POSIX model, other OSes may have different approaches
10:22:11 <ab9rf> although most modern operaitng systems use the same model
10:22:40 <huad> forgot my question. Sorry I misunderstood Enum at Hackage
10:23:20 <ab9rf> Chousuke_: i'd forgotten about that detail.
10:23:32 <ab9rf> it's been way too long since i wrote network code
10:25:03 <gelisam> huad: are you trying to understand the relationship between Haskell's Enum and C's enum?
10:25:08 <Chousuke_> yeah, nowadays it's possible to just write handlers for whatever is supposed to happen when a client connects and let a library handle the sockets :P
10:25:42 <ab9rf> Chousuke_: i wrote one of those libraries, back in 1990 :)
10:25:53 <huad> gelisam: I understood now. Chars are also enum.
10:26:21 <ab9rf> Chousuke_: it would even fork children so as to allow for more connections than the system process handle limit :)
10:26:49 <huad> gelisam: all types that use enum typeclass are enum. Different from C
10:27:07 <ab9rf> Chousuke_: i managed to get it up to handling 1100 connections simultaneously on BSD4.3
10:27:12 <ab9rf> Chousuke_: that was hard to test
10:27:34 <gelisam> huad: correct!
10:27:42 <Chousuke_> anything involving "simultaneous" generally is.
10:28:32 <Philippa> ab9rf: hrmm, a thought re earlier - have you seen what a mess Magic: the Gathering's ruleset is these days?
10:28:52 <Chousuke_> which ruleset? :P
10:28:59 <ab9rf> Philippa: no
10:29:15 <ab9rf> Philippa: but part of the fun of those games is having an underspecified ruleset
10:29:26 <ab9rf> Philippa: of course, i used to play Nomic.
10:29:32 <Philippa> hah. No, MtG's been forced to try to specify itself fully
10:30:15 <ab9rf> Philippa: a significant point of peter suber's research into that is that it's not possible to have a fully specified ruleset for a game.
10:30:29 <ab9rf> at least not if the game supports modification of its own rules during play.
10:30:34 <Philippa> *nod*
10:31:00 <Philippa> well, it's not too hard to sketch that from a formal logic perspective
10:31:21 <ab9rf> when i played nomic i would try to deliberately introduce subtle flwas into the rules
10:31:43 <Philippa> remind me not to play the Chairman's Game with you, then
10:32:18 <igstan> quchen: are there any restrictions on the number of foldr's used in that problem? expressing zipWith in terms of foldr
10:32:23 <Philippa> that said, got any links handy? I'd like to poke at how strong the results are a little
10:32:42 <Philippa> it's nasty enough trying to describe a game as static patches on top of itself, of course
10:32:49 <ab9rf> Philippa: i dunno.  check suber's website, i think he has a couple papers on it.
10:32:56 <Philippa> and that's the 'natural' mode of things that get sufficiently big
10:33:04 <Philippa> (happens to tabletop stuff all the time)
10:33:59 <ab9rf> one of the problems that happens in games is that as soon as you declare an invariant, someone wants to vary it
10:35:07 <Philippa> yep
10:35:24 <klrr> fuck life
10:35:35 <ab9rf> which means the only invariants you can have are the ones that define something as a game in the first place
10:35:51 <Philippa> so I'm thinking: this sounds like the sort of problem logical universes apply to - how do we want to structure them for engineering purposes?
10:36:15 <Philippa> (can we do any better than forcing a linear ordering of patches, for example?)
10:36:49 <Philippa> of course, this is *also* the same stuff that burns a lot of people's brains about monad transformers
10:37:02 <Philippa> and for bonus points, sooner or later you want open recursion
10:38:51 <ab9rf> Philippa: it is probably impossible to embody the full scope in a formal system
10:39:07 <ab9rf> thanks to incompleteness, if nothing else
10:40:26 <Philippa> ab9rf: The moment you start talking about typefulness seriously, you're offering to limit your scope some. The dependently-typed programming crowd have a lot to say on how little you have to do so, though
10:40:49 <parcs> > sequence (replicate 100000 (Just ())
10:40:50 <lambdabot>   <hint>:1:37: parse error (possibly incorrect indentation)
10:40:53 <parcs> > sequence (replicate 100000 (Just ()))
10:40:55 <lambdabot>   Just [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
10:41:07 <Philippa> I'm happy finding a setting you can do substantial real work in - I don't have one that doesn't dodge every interesting question outright, though
10:41:07 <parcs> > sequence (replicate 1000000 (Just ()))
10:41:08 <lambdabot>   *Exception: stack overflow
10:41:57 <Philippa> (one can, of course, just end up with a formal system that'll happily fail to produce results in some cases - but then what was the point of being typeful?)
10:41:58 <parcs> > (`runContT` return) $ sequence (replicate 1000000 (return ())) :: Maybe [()]
10:42:00 <lambdabot>   Just [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
10:42:16 <ab9rf> Philippa: well, the limitations are, in order, avoiding undeciability, avoiding NP-completeness, and avoiding practically incalcuability
10:42:16 <Philippa> (I know where Smalltalk and Prolog are if I want them!)
10:42:32 <parcs> to avoid the dreaded stack overflow caused by non-tail-recursive monadic actions, just use ContT
10:42:33 <Hafydd> :o
10:43:03 <NeOwA> I have a function multiply a b = a * b. What's the name of (multiply 2) ? (I see what it does, but looking for the name of this behaior
10:43:13 <ab9rf> NeOwA: currying
10:43:13 <Philippa> ab9rf: those are desireable design constraints, yes. They're not necessarily limits imposed by any given system! (But decidability is sure as hell useful)
10:43:39 <ab9rf> Philippa: many games include undecidable constructs.
10:43:39 <NeOwA> ab9rf: Thank you !!
10:44:02 <elliott> Philippa: have you seen http://edwinb.wordpress.com/2013/03/28/programming-and-reasoning-with-algebraic-effects-and-dependent-types/? it reminded me of when you wished for monad transformer stacks where each layer is labelled (so you could mix multiple of the same effect nicely, etc.)
10:44:24 <ab9rf> Philippa: it's up to the players to choose what interpretation to take, or to apply intuitionist reasoning to reach a decision that could not be reached within the confines of a formal system
10:44:34 <Philippa> elliott: I hadn't yet because I've been off twitter, thanks!
10:45:00 <Philippa> ab9rf: sure. This isn't much help in building most computer games, though
10:45:07 <Philippa> there are enough engineering problems there alone
10:45:09 <eacameron> How do I implement something like this? data Hash a = Hash a MyType; instance Eq a => Hashable ((,) a) where
10:45:09 <eacameron>     toHash (a, b) = Hash a b
10:45:20 <eacameron> I'm doing the instance wrong
10:45:33 <eacameron> I'm a noob which makes it harder ;)
10:45:45 <Philippa> elliott: I'm a little off my game at the moment, do you know if it does much more than, say, implement Frank?
10:46:20 <Philippa> okay, reading the abstract that's an at least unfairly-phrased question, n/m
10:47:49 <elliott> Philippa: it's similar to Frank (and inspired by it, IIRC), but it was the effect labelling that reminded me
10:48:13 <elliott> though it seems like you could do the same independently of the algebraic effects (i.e. with more conventional monad transformers)
10:48:22 <Philippa> elliott: *nod*. Yeah, Frank is definitely closer to the language I want to think in when I'm working with effects
10:48:30 <Philippa> and yeah, I can see the monad transformers implicit in Frank :p
10:48:54 <elliott> too bad they're not as powerful :(
10:48:59 <elliott> though I forget exactly what they can't do
10:49:07 <huad> gelisam: I understand that there is 2 type pointers for use with Haskell. Data pointer and Function pointer. Also there is another pointers for to use of out of Haskell for example using fields of a struct in C
10:49:46 <elliott> Philippa: actually, I think you could do a labelled monad transformer stack thing in GHC today with enough extensions
10:50:04 <Philippa> elliott: yeah, I think someone's working on that under the name "layers"?
10:50:19 <elliott> Philippa: those aren't labelled, unless it didn't mention that in the documentation
10:50:26 <elliott> seems to be more about handling things like "catch" generically
10:50:42 <elliott> (and it has some scary overlapping instances :P)
10:50:47 <Philippa> it's concerned with open recursion of transformers, yeah
10:50:53 <Philippa> (which is indeed an issue)
10:51:24 <huad> I understand that there is 2 type pointers for use with Haskell. Data pointer and Function pointer. Also there is another pointers for to use of out of Haskell for example using fields of a struct in C
10:54:00 * geekosaur has no idea what huad is talking about (aside from the ForeignPtr part)
10:56:14 <c_wraith> actually, in the FFI, pointers to data and functions *are* different.  Maybe because haskell functions can't be represented as C functions, due to closures.
11:14:04 <Kyo> does a handle need to be flushed between putStrLn and hPutStr?
11:15:52 <geekosaur> that question sounds confused. unless you are using hPutStr with stdout, its handle (and that handle's buffer) buffer has nothing to do with the one putStrLn uses
11:16:03 <Kyo> what am i doing wrong if the data is not received on the other end(server end) until i close the connection?
11:16:35 <geekosaur> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetBuffering
11:20:50 <elliott> "Functor is now a superclass of Monad in GHC HEAD" um, does anyone know if this this is true? it's on /r/haskell. but the link is just to a GHC/Base.lhs which does *not* have that superclass
11:21:03 <elliott> (and I hope it's actually Applicative that's a superclass, if so...)
11:21:04 <eikke> noticed the same, I suspect April Fools
11:21:17 <elliott> oh.
11:21:23 * elliott sigh
11:21:28 <Hafydd> Heh.
11:21:37 <sproingie> trust no announcements on Apr 1 :)
11:21:47 * elliott slept since the start of april fools, so it feels like all the nonsense should be over by now
11:21:59 <eikke> I guess such change would need some discussion on ghc-users/haskell-cafe/whatever first ;)
11:22:08 <Philippa> in most TZs, but I think it's not noon in some of the US yet
11:22:12 <sproingie> i noticed Oleg wasn't keen on making Monad derive from Functor, but I couldn't really follow the conversation.  anyone want to sum it up?
11:22:23 <elliott> eikke: I reckon the change would be easier to make with no discussion at all
11:22:45 <elliott> sproingie: I've read that Oleg post, and I don't really understand his reasoning at all
11:23:13 <elliott> it seems to essentially come down to "the properties of typeclasses means we can't do this in a 100% boilerplate-free way, so we should just live with the consequences of not having a hierarchy"
11:23:22 <elliott> but that's a pretty uncharitable reading, so maybe I'm missing something
11:23:49 <eikke> elliott: it'd break tons of packages...
11:23:56 <elliott> Philippa: the internet seems to have forgotten about the noon thing
11:24:36 <sproingie> where i come from april fools lasts all day
11:24:38 <hpaste> “Anonymous Coward” revised “moveUp”: “moveUp” at http://hpaste.org/84983
11:25:15 <cdh473__> what is the command for lambdabot?
11:25:24 <sproingie> @help
11:25:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:25:39 <cdh473__> @help list
11:25:39 <lambdabot> list [module|command]
11:25:39 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
11:25:48 <cdh473__> ty
11:26:29 <heatsink> Are type application and value application two special cases of a more general "application" operation?
11:26:29 <cdh473__> > filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
11:26:31 <lambdabot>   "GAYBALLS"
11:26:39 <heatsink> Not in Haskell, but in type theory
11:26:53 <heatsink> I'm used to System F, which treats them as completely separate.
11:27:17 <Philippa> yeah, frameworks like the Lambda Cube and Pure Type Systems give you that
11:27:30 <Philippa> a general lambda, general application and pi types
11:27:32 <otters> cdh473__: isUpper is a lot faster and Unicode-compatible
11:27:36 * hackagebot yesod-core 1.1.8.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.8.3 (MichaelSnoyman)
11:27:38 <otters> well it probably isn't faster
11:27:41 <otters> well, it might be actually
11:28:11 <cenger> hi. I am trying to define an agent which is basically a 10-tuple, and trying to modify some elements of the tuple by means of a function. but it gives error at compile time. Could you please tell me what I did wrong?
11:28:11 <Kyo> @hoogle Int->String
11:28:12 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
11:28:12 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
11:28:12 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
11:28:13 <cdh473__> > filter (isUpper) "i lauGh At You BecAuse u r aLL the Same"
11:28:14 <lambdabot>   "GAYBALLS"
11:28:19 <cdh473__> okay, thanks :3
11:28:38 <Kyo> @type show
11:28:39 <lambdabot> Show a => a -> String
11:28:55 <cenger> and this is the code and the error: http://hpaste.org/84983
11:29:04 <otters> cdh473__: hlint will tell you those parens are redundant
11:29:05 <nouitfvf> I failed compilation of lambdabot on Ubuntu because of there's an error in some library. It is sad.
11:29:45 <cdh473__> otters: ok thanks. i'm coming from lisp and a lot of haskell's syntactic sugar can be confusing at first
11:29:50 <heatsink> As I recall, even dependent type theory distinguishes lambda and pi terms.
11:29:57 <otters> that's the opposite of syntax sugar cdh473__
11:30:01 <heatsink> The core of the distinction seems to be whether the range is allowed to depend on the parameter's value.
11:30:01 <otters> it's function application
11:30:06 <cdh473__> otters: not that in particular
11:30:24 <Mortchek> cenger, on the right side, _ doesn't mean "same as it was on the left". You'd have to use a name for it on the left and that same name on the right.
11:30:27 <cdh473__> otters: i just have to get used to it
11:30:29 <otters> ok
11:30:41 <Mortchek> cenger, but I think this would be *much* easier if you just used a record.
11:30:57 <heatsink> ...whether the codomain is indexed by, or independent of, the domain
11:32:43 <cenger> Mortchek: Thanks. I don't know how I could make that mistake. :) Btw, thanks for the tip. I'll check the records.
11:37:08 <heatsink> Barendregt's Introduction to Generalized Type Systems is helpful
11:38:18 <heatsink> I think it will answer my question if I examine it a while longer.  Thanks, Philippa.
11:39:08 <Philippa> lambda : pi, basically
11:41:38 <bitonic> jaspervdj: hey, is there a reliable way to get the absolute path of the identifier?  is ‘(</> toFilePath ident) <$> getCurrentDirectory’ the best I can do?
11:41:45 <bitonic> *of an Identifier
11:41:47 <heatsink> (lamba x -> e) :: (pi x -> type-of-e)
11:43:41 <Kyo> I tried NoBuffering but doesnt change anything
11:45:56 <quchen> ..?
11:46:02 <quchen> Paste please
11:46:44 <quchen> In general you don't have to flush hPutStrLn, the newline does that thing on its own
11:46:56 <quchen> hPutStr has to be flushed manually if that's desired
11:49:17 <geekosaur> given earlier confusion I'm nbetting they set nobuffering on stdout instead of the socket
11:51:16 <armlesshobo> so, i'm reading the Typeclassopedia and I see " kind of f must be * -> *". What is it refering to, types that are of class f?
11:51:42 <armlesshobo> * -> * means that it can take any type, and map to any type, but only of typeclass f?
11:51:42 <elliott> armlesshobo: that means f takes a single type as an argument
11:51:47 <c_wraith> types have kinds, the way values have types
11:51:53 <elliott> for instance, Maybe has kind * -> *, Int has kind *
11:52:10 <armlesshobo> hmm. what is * in this case?
11:52:25 <c_wraith> it more or less means "types that can have values"
11:52:32 <armlesshobo> ok.
11:52:38 <c_wraith> not completely
11:52:44 <c_wraith> but that's a close approximation
11:52:51 <elliott> armlesshobo: data Foo = ... gives you a type of kind *
11:52:55 <elliott> or what you might just call a "type"
11:53:05 <hpaste> kyo pasted “handles” at http://hpaste.org/84985
11:53:06 <elliott> [String] has kind *, so does Maybe Int, IO (), (), etc.
11:53:25 <Kyo> i want to loop and check for commands and then send something back as you see in "response"
11:53:53 <geekosaur> the hFlush is redundant if you set NoBuffering on the socket
11:54:06 <c_wraith> @kind RWST
11:54:07 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
11:54:09 <armlesshobo> so, are there cases where a type doesn't have a kind *?
11:54:10 <jaspervdj> bitonic: hmm you're right, this is not particulary easy now... I should something to the API for this
11:54:12 <armlesshobo> or * -> *?
11:54:19 <quchen> c_wraith: Beautiful example.
11:55:20 <bitonic> jaspervdj: second question: I have written code to have Agda files turned into MD.  this sadly requires IO.  so my ‘solution’ now is to do everything in the Writer.  I understand the reasoning to keep IO out of Compiler, but are there any ways to make this nicer—e.g. have a ‘pre’ IO step, compiling, and then Writable?
11:55:27 <c_wraith> Any monad transformer's kind is going to end with (* -> *) -> * -> *
11:55:38 <c_wraith> that's just a requirement of the class definition
11:56:12 <elliott> armlesshobo: data Foo a b c = ...
11:56:16 <elliott> Foo hsa kind * -> * -> * -> *
11:56:19 <elliott> just think of it like a function
11:56:24 <elliott> foo a b c = ...
11:56:34 <elliott> (well, that only applies if Foo never gives arguments to a, b or c...)
11:56:42 <elliott> data Foo a b c = X a b | Y c, say
11:57:39 <Kyo> geekosaur: ok but what am i doing wrong? is it bc of hGetLine?
11:57:53 <quchen> Paste please
11:57:58 <geekosaur> they dd
11:58:02 <quchen> Oh, it's above. Nevermind.
11:58:05 <Kyo> i just want to interpret each sent byte as a command
11:58:18 <geekosaur> Kyo, you have commented out your response in the paste so of course it's not doing anything
11:58:57 <jaspervdj> bitonic: there's `preprocess` or `unsafeCompiler`
11:59:31 <bitonic> jaspervdj: ah, I had missed ‘preprocess’, thanks.
11:59:38 <jaspervdj> both are fine as long as you don't do crazy stuff
11:59:43 <quchen> geekosaur: That would've been my guess too. The fork does nothing, so it doesn't have to be evaluated
12:00:08 <quchen> Eh wait no
12:00:41 <bitonic> jaspervdj: well actually I don’t know if that’s better than what I do...
12:00:58 <Kyo> geekosaur: sure but thats not the point.
12:01:27 <Sonarpulse> could somebody help me debug some functions in https://github.com/Ericson2314/Codec.Archive.CnCMix/blob/master/Codec/Archive/CnCMix/TiberianDawn.hs ? I would just hpaste the function in question but I've written some tests that will help
12:01:41 <Kyo> i should have been more clear. i want the server to print otu what it receives immediately. now it gets an A then a B and then prints AB instead of just printing A when it is received
12:02:13 <geekosaur> ok, so you are usibg hGetLine which reads a line (not a character)
12:02:23 <Kyo> hGetChar then
12:02:42 <geekosaur> if you are sending a byte A and not A followed by newline, the getLine does not succeed until a newine is received or the sender closes the connection
12:03:18 <Sonarpulse> Kyo: sequence supports FiFo?
12:04:06 <Sonarpulse> yeah in comming on one end, loop pulling values on the other
12:06:34 <Sonarpulse> kyo: http://lambda-the-ultimate.org/node/4690
12:07:45 <Cale> Kyo: Make sure that the handle is in NoBuffering mode (use hSetBuffering), and use hGetChar/hPutChar
12:08:26 <amindfv> is hsenv still in active development? it looks really cool, but its github page hasn't had activity in 7 months
12:08:31 <Kyo> it works now, ty all
12:08:39 <Sonarpulse> anybody help me with my debugging?
12:08:40 <elliott> amindfv: I've heard there's an active fork, IIRC
12:08:47 <amindfv> hmmm
12:09:11 <luite> amindfv: hm, there must be more recent activity somewhere, some fixes for yesod devel got in much later than that
12:10:30 <amindfv> erg. looks like there are a couple forks...
12:12:12 <amindfv> alright, looks like this is The One True Hsenv: https://github.com/tmhedberg/hsenv
12:12:37 <elliott> Cale: wasn't NumInstances taken out of lambdabot at some point? just wondering if I'm misremembering, since the instances are back and it's come up a few times
12:12:51 <Cale> I dunno
12:13:57 <Kyo> good, now i managed to receive then send on the same socket.
12:14:16 <Sonarpulse> also, is quickCheck take a (a -> (b,b) and check equals so it can print both versions if not equal?
12:15:23 <Kyo> im doign this to learn the basics of networking and (TCP,UDP)/IP. What do you recommned? Write my own protocol on top of TCP/IP. As I understand you can't just have TCP/IP, you need to deal with buffering as well on top of TCP?
12:15:32 <shachaf> Cale: Maybe it should be disabled since a couple of people have gotten confused by it.
12:15:42 <shachaf> Or maybe I'm just a h8r.
12:16:52 <geekosaur> Kyo, this buffering is something you need to deal with in most languages; in C, you would ether use raw calls or, if you wanted to use stdio, you'd need to use setvbuf() to turn off buffering (just like hSetBuffering)
12:17:06 <lightquake> http://www.reddit.com/r/haskell/comments/1bfojn/functor_is_now_a_superclass_of_monad_in_ghc_head/
12:17:11 <geekosaur> because character at a time I/O is inefficient in general
12:17:26 <Cale> Sonarpulse: you might be able to use printTestCase for that
12:17:39 <Sonarpulse> thanks
12:17:48 <Sonarpulse> I'll find it in Test.QuickCheck
12:17:48 <amindfv> lightquake: nice!
12:17:57 <lightquake> amindfv: check the post date
12:18:32 <amindfv> ha
12:19:22 <geekosaur> that said I would expect buffering to be turned off on sockets; I expect the real problem was trying to read individual characters with hGetLine
12:19:34 <Sonarpulse> oh or when fail
12:19:38 <geekosaur> which, as its name suggests, reads a *line*
12:20:03 <Ralith> geekosaur: C stdio doesn't encompass sockets
12:20:29 <geekosaur> Ralith, ever heard of fdopen()? it's very useful with line-oriented sockets
12:21:02 <Ralith> geekosaur: fdopen is not C
12:21:14 <geekosaur> wat
12:21:18 <ab9rf> Ralith: really?
12:21:23 <geekosaur> it's C to the same extent that sockets are C
12:21:28 <Ralith> indeed.
12:21:34 <Kyo> how can i write the hex value of a char? '0x41'?
12:21:51 <geekosaur> > chr 0x41
12:21:52 <elliott> > chr 0x41
12:21:53 <lambdabot>   'A'
12:21:53 <lambdabot>   can't find file: L.hs
12:22:01 <elliott> geekosaur's is less buggy than mine, apparently.
12:22:02 <geekosaur> mmm, race conditions
12:22:03 <ab9rf> fdopen is in POSIX
12:22:19 <shachaf> > ((`showHex` "") . ord) 'A'
12:22:20 <lambdabot>   "41"
12:22:23 <Ralith> the point is, one does not generally have to deal with stdio's buffering when handling sockets in C, because you have to go out of your way to involve it at all.
12:22:39 <ab9rf> Ralith: fdopen is as much C as is anything else in stdio.
12:22:50 <Ralith> ab9rf: no, you said it yourself; it's POSIX
12:22:58 <ab9rf> Ralith: so?
12:22:58 <geekosaur> Ralith, hence "if you wanted to use stdio" which implies using fdopen() to invoke stdio
12:23:04 <ab9rf> Ralith: you don't have to use stdio in C either.
12:23:07 <Ralith> geekosaur: well, it seemed misleading to me.
12:23:10 <Ralith> ab9rf: that's orthogonal.
12:23:15 <ab9rf> Ralith: not really
12:23:19 <Ralith> entirely.
12:23:25 <geekosaur> not at all
12:23:30 <ab9rf> Ralith: you can do all IO with write and read, and entirely eschew stdio
12:23:31 <geekosaur> you are the one being confusing, really
12:23:39 <Ralith> whether you have to use something has no bearing on whether it's part of the standard.
12:23:48 <ab9rf> that's exactly analogous to doing all socket IO with send and recv and not using stdio
12:24:20 <Ralith> geekosaur: specifically, you lead with "buffering is something you need to deal with in most languages" when in C the only reason you'd have to deal with it would be if you opted into it with a platform-specific extension.
12:24:21 <geekosaur> if we are talking about what "is C" then we're not even talking about sockets, because they are not part of C
12:24:23 <ab9rf> you can fdopen a file opened with open, too
12:24:36 <ab9rf> geekosaur: but files are not part of C either
12:24:51 <geekosaur> Ralith, do you have an actual point here or are you just trying to defend a lost cause?
12:25:20 <elliott> this pedanticness seems wholly unproductive
12:25:27 <ab9rf> elliott: yes, i agree
12:25:36 <elliott> take it to comp.lang.c? :P
12:25:57 <ab9rf> elliott: it's not about c :)
12:26:01 <ab9rf> it's about POSIX
12:27:09 <Kyo> geekosaur: im not talking about that buffering but you need to hav client and server to agree on how many bytes will be sent. because with TCP you can send a message and it might be broken up so you dont know if you got it all. But with UDP if it gets there it is the whole message.
12:27:46 <geekosaur> yes, you need to implemnt your own packet protocol on top of TCP; TCP is just a stream
12:28:24 <Ralith> unless you actually want a stream, anyway
12:28:43 * Ralith wishes SCTP was viable
12:35:06 <int-e> why does Data.Sequence have fromList but no toList?
12:35:24 <elliott> int-e: Foldable provides toList
12:35:25 <Cale> int-e: It has an instance of Foldable
12:35:41 <int-e> thanks
12:36:45 <donri> but then why does e.g. Map provide toList *and* Foldable
12:37:03 <elliott> because Data.Map predates Foldable and Data.Sequence doesn't, I suspect
12:37:17 <donri> ah
12:37:26 <geekosaur> Sequence does predate it, I think
12:39:40 <eikke> elliott: what is 'dang'?
12:40:18 <Taneb> :t M.toList
12:40:20 <lambdabot> M.Map k a -> [(k, a)]
12:40:35 <Taneb> Data.Map's toList is different to Data.Foldable's
12:40:40 <Taneb> Map's keeps the keys
12:40:47 <donri> oic
12:40:56 <elliott> eikke: ?
12:41:24 <eikke> elliott: I came by that repo while looking for something else, and wonder whether I should take a closer look :) readme isnt too informative though
12:41:54 <Kyo> can a thread get its own threadid?
12:42:00 <donri> Taneb: but it also provides 'elems'
12:42:17 <elliott> eikke: I have no such repo; maybe you're thinking of one of the other Haskell elliotts (Conal or Trevor (elliottt on IRC))?
12:42:20 <Taneb> Thus returns elliott's point
12:42:22 <Sonarpulse> doesQuickCheck use unsafe extension?
12:42:28 <Sonarpulse> I just crashed ghci
12:42:28 <eikke> oooh right, sorry
12:42:29 <donri> api design is hard :)
12:42:46 <elliott> eikke: it's an easy mistake to make :P
12:42:50 <Sonarpulse> the offending code is: instance Testable (a,a) -> Property where property (a,b) = property $ whenFail (print a >> print b) $ a == b
12:42:57 <Kyo> for you to be able to connect to me, then i need to listen to my computers IP address and what port?
12:43:23 <Kyo> or listen to all interfaces and you can jsut connect to my IP?
12:44:27 <elliott> Sonarpulse: hpaste the full ghci session that crashes?
12:44:30 <elliott> it may be a GHC bug
12:44:44 <monoidal> Sonarpulse: it's bug in GHC 7.4, you need =>
12:45:07 <Sonarpulse> oh duh
12:45:10 <Sonarpulse> just syntax error
12:45:15 <Sonarpulse> documented then?
12:45:27 <monoidal> Sonarpulse: it's fixed in 7.6
12:45:46 <Sonarpulse> ok
12:45:46 <monoidal> Sonarpulse: in fact, one of the most commonly reported bugs on ghc trac
12:45:50 <Sonarpulse> what i really wanted is instance Testable (a,a) where
12:45:54 <Sonarpulse> anyways
12:46:24 <Sonarpulse> well, instance (Eq a, Show a) => Testable (a,a) where
12:48:34 <Kyo> can a thread get its own threadid?
12:49:00 <Kyo> i get a threadid with forkIO but can I commuunicate with thread?
12:49:04 <Sonarpulse> is there any prelude dataype for an (a,a) pair?
12:49:54 <ClaudiusMaximus> @hoogle IO ThreadID
12:49:55 <lambdabot> Did you mean: :: IO ThreadId
12:49:55 <lambdabot> No results found
12:50:18 <ClaudiusMaximus> @hoogle IO ThreadId
12:50:18 <lambdabot> Did you mean: :: IO ThreadId
12:50:18 <lambdabot> No results found
12:50:24 <elliott> myThreadId
12:50:29 <monoidal> Sonarpulse: no (a poor replacement is Bool -> a)
12:50:58 <Kyo> :t myThreadId
12:50:59 <lambdabot> Not in scope: `myThreadId'
12:51:05 <Sonarpulse> ok
12:51:12 <Sonarpulse> well then (a,a) it is
12:51:22 <Sonarpulse> I am suprised this wasn't put in quickCheck itself
12:51:26 <Sonarpulse> at least as an optional import
12:51:37 <Sonarpulse> equivalence tests are super common
12:52:23 <Sonarpulse> I just don't like all the extra parens needed with ,
12:52:41 * hackagebot family-tree 0.4.0.0 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.4.0.0 (NathanVanDoorn)
12:54:17 <ClaudiusMaximus> Kyo: the typical ways to communicate between threads are Control.Concurrent (MVar, Chan, etc) and STM (TVar, TChan, etc) - STM is nicer to use imo
12:55:06 <flebron> So curiously, if we define flip^k as flip . flip . ... . flip, then flip{2 + k} = flip^k. However, if we define flip^k as flip flip ... flip, then flip^{3 + k} = flip^3.
12:55:25 <flebron> (If I didn't screw it up :))
12:56:06 <Kyo> tid <- myThreadId
12:56:06 <Kyo>      putStrLn( ( show tid ) ++ "received: " ++ [c] ++ "." )
12:56:13 <Kyo> can it be done in one row?
12:56:57 <quchen> Kyo: Not really. I mean you can rewrite it with >>= but it'll be the same thing.
12:57:05 <quchen> myThreadId >>= \tid -> ...
12:59:52 <Kyo> is the erlang like concurrent lib that SPJ created used? is it a part of ghc or an extenr lib?
13:00:13 <geekosaur> @pl myThreadId >>= \tid -> putStrLn( ( show tid ) ++ "received: " ++ [c] ++ "." )
13:00:14 <lambdabot> putStrLn . (++ ("received: " ++ [c, '.'])) . show =<< myThreadId
13:00:20 <geekosaur> not recommended
13:00:34 <quchen> Kyo: You can write the putStrLn pointfree, but that results in a mess.
13:00:42 <quchen> What you've got is probably the best solution.
13:01:06 <quchen> On a related note, does hGetLine take forever for you as well?
13:01:19 <quchen> For me it's like 3-5 seconds that call consumes
13:02:21 <monoidal> flebron: in other words flip . flip = id and flip flip flip flip = flip flip flip (both are pretty clear)
13:03:20 <quchen> monoidal: Doesn't get much clearer than flip flip flip flip, yeah
13:03:44 <byorgey> flip flip flip flip = (flip flip) flip flip = (\x y -> flip y x) flip flip = flip flip flip
13:04:11 <byorgey> seeing how the type of flip flip flip flip = flip flip flip works is hurting my brain though
13:04:42 <monoidal> it's just a special case of flip f x y = f y x where you substitute f,x,y to flip
13:05:46 <quchen> :t flip flip flip
13:05:47 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
13:05:50 <Kyo> quchen: havent noticed that
13:06:12 <quchen> Kyo: Hm. I just wrote a small client/server application (basically what you did), and I'm having that problem.
13:06:29 <quchen> When you say you haven't noticed do you mean it doesn't happen, or it may happen and you didn't pay attention to it?
13:07:41 * hackagebot HUnit 1.2.5.2 - A unit testing framework for Haskell  http://hackage.haskell.org/package/HUnit-1.2.5.2 (RichardGiraud)
13:11:58 <Kyo> well it didnt work when i used hGetLine
13:12:04 <Kyo> so i dont know
13:12:09 <Kyo> hGetChar was immediate
13:12:19 <ams__> 5 + 6
13:12:41 * hackagebot hmemdb 0.1.0.1 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.1.0.1 (MiguelMitrofanov)
13:13:28 <armlesshobo> anybody here use ghc on a windows platform?
13:14:27 <Kyo> i do
13:14:52 <Kyo> are haskell threads somehow scheduld by ghc or by windows?
13:14:59 <quchen> Same problem here with char instead of line
13:15:00 <quchen> Hmm.
13:15:16 <quchen> Kyo: Haskell threads generted by forkIO are handled entirely by Haskell.
13:15:41 <quchen> When you run a program with -N, that's the number of OS threads you're spawning. Haskell then schedules its threads on those OS threads.
13:15:54 <quchen> But that's all in the runtime.
13:16:00 <armlesshobo> Kyo: is there an equivalent to the linux "strip" command?
13:16:26 <Kyo> armlesshobo: dont know
13:16:33 <Heffalump> armlesshobo: it exists in mingw/cygwin too
13:17:03 <armlesshobo> hmm ok
13:17:22 <Heffalump> and it does seem to do something (just shrunk a 80MB executable 50 50MB)
13:17:29 <Heffalump> s/50 50MB/to 50MB/
13:19:03 <armlesshobo> Heffalump: yeah, that's my goal.
13:19:23 <armlesshobo> Heffalump: even though it's only 1MB, I want any extra crap on it that I won't need.
13:19:51 <ab9rf> strip removes nonessential symbol ad debugging data
13:20:05 <Heffalump> ab9rf: including on windows?
13:20:07 <LambdaDusk> anyone else got some raspi+haskell experience?
13:20:24 <ab9rf> Heffalump: at least for stuff linked by mingw, yes
13:20:45 <ab9rf> Heffalump: no guarantees on what it'll do if you call it on an executable linked by someonthing other than mingw/cygwin
13:20:50 <Kyo> is Cloud haskell used?
13:23:03 <LambdaDusk> I feel like the chip is melting trying to compile some cabal packages...
13:25:21 <LambdaDusk> haskell how I love thee, but your resistance against anything not x86 linux...
13:26:56 <simpson> LambdaDusk: I feel like that's unfair; the Pi is not a very powerful chipset and you're asking it to do a lot.
13:27:43 <sproingie> funny thing how my smart car can't tow a trailer home
13:29:55 <LambdaDusk> simpson: I feel like doing a profile compile but I am afraid that'll kill the little thing
13:30:19 <LambdaDusk> there should be a leightweight haskell
13:30:22 <LambdaDusk> oh wait
13:30:27 <LambdaDusk> O'Caml
13:32:35 <Hafydd> LambdaDusk: is that someone's surname?
13:32:43 <Cale> LambdaDusk: Maybe you need to figure out how to cross compile
13:32:54 <Cale> I know it's supposed to be possible now
13:33:38 <LambdaDusk> Cale: Well, in theory it is...
13:33:47 <Kyo> are we stuck with C for systems programming? I mean with all the code out there in it... or if you just get a good compiler for a bitC like language and make it available for ARM processors then you could win a lot of time for people...
13:34:09 <Cale> LambdaDusk: Well, somewhat recently toolchain mode made it into mainline GHC
13:34:24 <sproingie> Kyo: while the OS is written in C, probably
13:34:39 <sproingie> write an OS not in C.  that's probably not too hard.  the drivers on the other hand ...
13:34:42 <Cale> Kyo: http://hackage.haskell.org/package/atom/
13:35:39 <LambdaDusk> Cale: I just love this language so much... I wish it was easier to use it on not x86 linux...
13:35:55 <Cale> LambdaDusk: What platforms is it hard to use on?
13:36:13 <Cale> LambdaDusk: I've used it on Mac OS X quite a bit, and never really had any issues with that.
13:36:21 <Cale> (granted, that was years ago)
13:36:33 <sproingie> windows frequently has issues with packages on hackage
13:36:42 <sproingie> the platform works just dandy tho
13:36:48 <LambdaDusk> windows
13:36:51 <Cale> Windows has issues with lots of stuff
13:37:04 <LambdaDusk> windows is the worst OS for development
13:37:06 <LambdaDusk> really
13:37:12 <LambdaDusk> in any language
13:37:16 <Cale> Yeah, it's not a Haskell-specific issue at all there
13:37:20 <sproingie> the normative assumption about ./configure scripts in some packages is not a good thing tho
13:37:29 <LambdaDusk> and yet I have to put up with is because everyone else uses windows
13:40:13 <LambdaDusk> SDL does not work... anything with a configure script does not work...
13:40:47 <sproingie> SDL's been fucked up for ages
13:41:05 <sproingie> and not just the haskell bindings
13:41:27 <LambdaDusk> I blame windows for now having any clear structure whatsoever
13:41:51 * sproingie shrugs.  GLFW works fine on windows
13:42:23 <sproingie> or GLFW-b as you'd probably want to use instead
13:42:49 <LambdaDusk> glfw does
13:42:51 <LambdaDusk> but
13:42:54 <LambdaDusk> loading a texture?
13:43:03 <LambdaDusk> juicypixel works
13:43:16 <LambdaDusk> but OpenGL wants a Ptr a
13:43:23 <LambdaDusk> the blocks are white
13:43:39 <sproingie> some low level texture loaders for OpenGLRaw would be nice.  maybe i should take a stab.
13:43:40 <LambdaDusk> I spent now 2 weeks on it and still got no textures
13:44:06 <LambdaDusk> all I want is some spriting and move on =/
13:44:06 <stelleg> does anyone know if there is an API function with the funtionality of :t in ghci?
13:44:09 <Kyo> Cale: Atom is very interesting although I dont quite get it. have you used it? It lets you generate C code from haskell code and somehow removes the need from an RTOS?
13:46:14 <simpson> Kyo: At some point one must admit that a substrate is required. It doesn't have to be C, but it has to exist.
13:47:08 <quchen> I just wrote a small network client/server program to send strings over. However, the thing has a performance problem: reading from the handle generated by a socket takes way too long (~ 5 seconds). I've uploaded the code here: Server: http://hpaste.org/84988 Client: http://hpaste.org/84989
13:47:18 <Cale> Kyo: I haven't actually applied it, but yes, it generally exists to avoid the need for more sophisticated task scheduling.
13:47:39 <quchen> I can't think of why that problem would occur :-|
13:47:48 <LambdaDusk> hmmm throw the pi into the snow for cooling - pro or contra
13:51:06 <saep> Contra: It may cool off and become rational again.
13:51:10 <ab9rf> whee
13:51:24 <quchen> AAAAAAAAAaaaaaah. Well that error was not where I thought it was.
13:51:43 <quchen> For the interested ones: the client didn't close the handle.
13:52:24 <quchen> Now I've got to try to figure out why that causes the problem.
13:52:38 <jfischoff> is there a haskell package for web page automation similar to phantomjs?
13:53:13 <LambdaDusk> quchen: Use bracket_ ?
13:54:02 <quchen> LambdaDusk: I put that in the refactoring phase
13:54:14 <quchen> Kind of glad I did, I think I learned something from that.
13:54:37 <quchen> I think the handler doesn't get used to send before it is GC'd due to timeout, which is where the delay comes from.
13:54:51 <quchen> So closing it forces evaluation of the actions, hence instant sending.
13:55:02 <luite> jfischoff: there's a lower level webkitgtk and jsc binding, which allows you to control a webkit browser frame from haskell. it's still in relatively early stage
13:55:15 <jfischoff> thanks luite
13:56:24 <luite> jfischoff: it's part of the ghcjs project, leksah want to use it, to make a native app with the webkitgtk bindings, and use the same code for a webapp, compiled to javascript with ghcjs
13:56:56 <luite> jfischoff: ask hamishmack for more info
13:57:13 <jfischoff> will do
13:58:01 <augur> http://www.reddit.com/r/haskell/comments/1bfojn/functor_is_now_a_superclass_of_monad_in_ghc_head/
13:58:05 <augur> can someone explain the joke :(
13:58:20 <monoidal> augur: the headline is a hoax (it never happened)
13:58:45 <Kyo> where is data constructor IO?
13:58:48 <augur> monoidal: i dont even understand what was supposed to have happened
13:58:49 <Kyo> @src IO
13:58:49 <lambdabot> Source not found. My pet ferret can type better than you!
13:58:57 <Kyo> @hoogle IO
13:58:57 <lambdabot> Prelude data IO a :: * -> *
13:58:57 <lambdabot> System.IO data IO a :: * -> *
13:58:57 <lambdabot> Prelude type IOError = IOException
13:59:17 <monoidal> augur: many people hope that Haskell in future will have Functor as a superclass of Monad (i.e. the Monad constraint will imply Functor, just like now Ord implies Eq)
13:59:39 <quchen> Kyo: IO is deep inside GHC. It's not an ordinary type like Maybe etc.
13:59:43 <jfischoff> luite what's the status of ghcjs?
13:59:44 <monoidal> augur: that submission was a joke that this happened
13:59:46 <augur> monoidal: as in...   class Functor f => Monad f where ... ?
13:59:50 <monoidal> augur: yes
13:59:57 <augur> monoidal: it doesnt have that currently?
14:00:02 <quchen> Kyo: For practical purposes, you can often think of IO = State RealWorld.
14:00:16 <monoidal> augur: no, you can define monad instance but not functor
14:00:20 <augur> huh. so it doesnt. thats interesting.
14:00:23 <hpaste> kyo pasted “case return IO” at http://hpaste.org/84991
14:00:24 <augur> why is that?
14:00:30 <monoidal> historical reasons
14:00:54 <augur> huh. well i always define my functor instances anyway
14:01:35 <monoidal> (honestly I think it's time to do that. any code that breaks is easily fixed, and we already have num/show/eq incompatibility.)
14:02:11 <geekosaur> Kyo, it's not visible, for good reason. you want ``` return ()```
14:02:33 <elliott> class Functor f => Monad f would be terrible
14:02:36 <luite> jfischoff: it's getting closer to release. I'm still working on the new code generator, which i think now has all the functionality of the old one, and a bit more (proper threading with blackholes and async exceptions, foreign import javascript ffi calling convention)
14:02:37 <elliott> class Applicative f => Monad f, OTOH...
14:02:59 <quchen> elliott: That would be a very evil fix to the current problem :-)
14:03:10 <Kyo> quchen: that code is weird for me too
14:03:15 <hpaste> DanBurton revised “case return IO”: “(use when)” at http://hpaste.org/84991
14:03:18 <luite> jfischoff: but we still need to get the ghc patches required for this merged, before 7.8.1 :)  and there's cabal support that also still needs to be worked on (ghcjs uses a hack to install the javascript files now)
14:03:31 <monoidal> elliott: I think it would be better than status quo, and furthermore I think code mixing applicatives and monads should be suspicious
14:03:51 <monoidal> I rarely see the need for both
14:03:54 * jfischoff nods
14:03:58 <elliott> every monad is an applicative functor, and Applicative notation is incredibly useful even for monads
14:04:01 <elliott> (see: Parsec etc.)
14:04:19 <luite> jfischoff: a generally usable release should be out when 7.8.1 is released, but it depends a bit on how much time i can keep spending on this
14:04:24 <monoidal> elliott: sure, but for Parsec we don't usually spell it out
14:04:35 * jfischoff nods
14:04:43 <quchen> Networks says "sClose is a deprecated alias". Is that a leftover comment that should be ignored? It's not declared {- DEPRECATED -}, and if you look at Network as a higher level interface to Network.Socket, sClose certainly makes sense. Here's the docs: http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network.html#v:sClose
14:05:02 <monoidal> elliott: (I am unsure if applicative => monad holds in general case, outside Hask, that's a detail, but if it was to be generalized even more in the future...)
14:05:25 <luite> jfischoff: the only major thing missing from the RTS is STM support
14:05:31 <elliott> well, Applicative depends pretty highly on Hask
14:05:56 <quchen> Kyo: See RealWorld as a stateful variable you can't access. State RealWorld is then basically something that lets you chain stateful computations together in order.
14:05:58 <jfischoff> luite: which would very cool, but I don't think most people will notice it is not there
14:06:25 <jfischoff> luite: that said STM is what I have been messing with recently
14:06:29 <luite> jfischoff: yeah it's not terribly high priority, can be added easily later if someone feels like implementing it
14:06:31 <quchen> Kyo: If you think about it, that's pretty much what IO does: it preserves evaluation order (and can do magic input/output).
14:06:51 <monoidal> elliott: indeed. It would be interesting to see a class for monoidal functors (equivalent to applicative)
14:07:04 <jfischoff> luite: cabal support is probably the most important thing. Probably more important then many language features
14:07:06 <monoidal> elliott: I prefer a lot having classes with strong connections to normal mathematical notions
14:07:23 <monoidal> elliott: so, monad with join, and applicative with liftA2 (,)
14:09:50 <luite> jfischoff: cabal does work already with some hacks, but it's a bit fragile, sometimes you have to retry installing because it missed some files the first time
14:10:49 * jfischoff nods
14:10:49 <luite> but it can for example compile test-framework to js, so you can testsuites of existing packages fully in js (with node.js or spidermonkey jsshell)
14:10:58 <luite> +run
14:11:07 <luite> and last week i tried reactive-banana
14:11:57 <jfischoff> and it worked?
14:13:24 <luite> reactive-banana worked if i removed the StableName dependency of its Unique generator. ghcjs has StableName, which should be correct according to docs, but apparently behave slightly differenly
14:13:55 <luite> test-framework worked after I fixed reporting the number of capabilities (had it set to 0, so it started 0 threads for running the test first...)
14:14:18 <bitonic> jaspervdj: what could cause to the metadata to stay in the file?  btw, I’ve hacked up a script to make Agda work with Hakyll: <http://mazzo.li/posts/AgdaSort.html>
14:14:19 <luite> it's a bit slow, but otherwise does exactly the same as native code, even prints the passed tests in green
14:16:35 <jfischoff> luite: I'm grabbing webkit from darcs. Not that I will do anything with it :p. Having a haskell based phantomjs makes sense to me
14:20:44 <Kyo> withSocketsDo has to be calle client side as well?
14:22:29 <geekosaur> has to be called by any program which manipulates sockets. (it's a no-op on unix, on windows it may be needed to load the sockets emulation)
14:22:46 <geekosaur> this isn't haskell's fault, it's winsock's fault
14:23:30 <quchen> Kyo: Not sure, and the docs aren't very conclusive. If you're running Win, why not try it out?
14:23:51 <quchen> Kyo: Eh wait, only the server deals with sockets.
14:24:57 <quchen> (... I think)
14:25:15 <geekosaur> huh?
14:25:22 <geekosaur> how does the client send data to the server?
14:26:29 <quchen> By doing magic things to a port.
14:26:38 <quchen> magic :: a
14:27:58 <Kyo> quchen: thanks for IO explanation
14:36:00 <hpaste> “Jonathan Fischoff” pasted “pango install issues” at http://hpaste.org/84993
14:36:04 <jfischoff> dmwit: any idea what is going on with my pango install? ^
14:36:27 <jfischoff> or anyone else for that matter..
14:36:38 <geekosaur> either you should be using an older ghc, or you should be pulling from the ghc repo
14:36:44 <edwardk> Hello "Jonathan Fischoff"
14:36:49 <geekosaur> er, from the gtk2hs repo
14:36:54 <jfischoff> yo edwardk!
14:37:03 <geekosaur> because that is an FFI detail that ghc got stricter about in 7.6
14:39:01 <jfischoff> geekosaur: it says hackage that pango builds on 7.6 and I am using 7.6.2 so i would assume I am in the clear.
14:40:27 <hpaste> kyo pasted “why register several \n?” at http://hpaste.org/84994
14:40:51 <Kyo> ^^ can someone tell me why it registers several keypresses?
14:42:32 <quchen> Kyo: You're not closing your h handle in main
14:42:41 <quchen> (That's not the reason, but you should fix it anyway)
14:43:05 <geekosaur> I'd guess input is line bufered so the A isn't seen until the return (newline) that sends it on
14:43:38 <geekosaur> this may involve both disabling line buffering on stdin, and possibly putting stdin into character at a time mode (on unix/linux at least)
14:43:50 <DanBurton> also, running "main" from within ghci can make things a little screwy
14:43:51 <quchen> Kyo: Also you're flushing STDOUT, mayhe you should flush h instead
14:44:11 <geekosaur> :main instead of main
14:44:17 <quchen> There's a difference?
14:44:25 <geekosaur> yes
14:44:25 <quchen> (for no parameters)
14:44:34 <quchen> Oh, what is it?
14:44:37 <DanBurton> geekosaur: what's the diff?
14:44:46 <geekosaur> not sure how much of a differenc ein that case
14:45:14 * jfischoff didn't know about :main…
14:45:16 <geekosaur> but I don't think anyone guarantees anything about how main works invoked directly vs. via :main
14:45:41 <quchen> geekosaur: main guarantees something?
14:45:57 <geekosaur> wat
14:45:58 <quchen> It's just an ordinary function/CAF isn't it?
14:46:31 <quchen> Oh, misread your sentence
14:46:32 <quchen> Nevermind
14:56:10 <etnis93> hello
14:56:15 <etnis93> !list
14:56:36 <quchen> Hello
14:59:18 <dmwit> jfischoff: Update your gtk2hs-buildtools
15:03:28 <Kyo> wait i know
15:04:27 <Kyo> the '\n' -> another round in the loop
15:04:31 <Kyo> obv
15:04:38 <lemao> is there a way to automatically generate ffi imports in a .hs file for a C shared lib?
15:04:41 <Kyo> cant i finish input without geenrating a newline?
15:05:28 <geekosaur> [01 17:43] <geekosaur> this may involve both disabling line buffering on stdin, and possibly putting stdin into character at a time mode (on unix/linux at least)
15:06:53 <dmwit> lemao: Check out the various tools like c2hs and hsc2hs.
15:07:32 <lemao> they still seem to require that I create wrapper functions in Haskell
15:08:03 <lemao> there are hundreds of functions that I want to import
15:20:20 <mgccl> say if I have a function f :: a->a, I give it a where clause which contains a function g. then I write g::a->a, here a is the same as the a in f. How do I make haskell know?
15:20:52 <hpc> mgccl: {-# LANGUAGE ScopedTypeVariables #-}
15:20:53 <hpc> then
15:20:57 <hpc> f :: forall a. a -> a
15:21:00 <hpc> g :: a -> a
15:21:53 <hpc> (the forall is important and required)
15:22:35 <quchen> bracket's type says that it returns an "IO a" no matter what happens. However, when the action raises an exception, it may never have the chance to produce an actual value of type a.
15:22:48 <mgccl> hpc: that works, thanks!
15:22:49 <quchen> So if there's an exception, what will the final value of the bracketing be?
15:23:01 <quchen> Bottom, in the sense of a rethrown exception?
15:23:18 <hpc> @hoogle bracket
15:23:18 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:23:19 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:23:19 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:23:58 <mauke> quchen: I don't think it's quite bottom
15:24:15 <quchen> Well, or some form of "doesn't matter"
15:24:28 <hpc> quchen: are you refering to an exception thrown in the (IO a) action there?
15:24:31 <mauke> similarly, a value of type 'Maybe a' may not contain an 'a' even without bottom
15:24:36 <hpc> i am fairly sure those don't get caught
15:24:56 <hpc> bracket is intended to catch exceptions in the (IO b) part, afaict
15:24:59 <mauke> that is, 'IO a' does not contain an 'a'
15:25:45 <quchen> mauke: so when I use "x <- bracket ...", if there's an exception, it'll jump out of the bind business anyway
15:25:55 <quchen> Is that what you mean?
15:26:20 <mauke> yes
15:26:22 <mauke> I blame >>=
15:27:15 <quchen> Alright. Makes sense.
15:36:04 <wereHamster> how would I go about installing ghc 7.6 on ubuntu 12.10? Is there a PPA? Or do I have to compile from source?
15:36:22 <dmwit> Just grab the binary from the official GHC website, I guess.
15:36:23 <RenJuan> PPA is some ubuntu shit?
15:36:37 <dmwit> language...
15:36:41 <Clint> redundancy
15:37:12 <RenJuan> i use debian which it's a rip on
15:37:24 <RenJuan> I install ghc and the cabal install the rest
15:37:26 <geekosaur> there are debian ppas as well
15:37:33 <Clint> not yet there aren't
15:37:48 <tippenein> what's the haskell way to parse space delimited columns and rows of ints from a file?
15:37:51 <geekosaur> not *officially* but there are PPAs which target debian
15:37:56 <Clint> oh ok
15:38:08 <tippenein> the columns and rows don't matter, I just want to end up with a list containing all the ints
15:38:11 <RenJuan> s/the//
15:38:19 <Clint> tippenein: csv-conduit with space as a delimiter?
15:38:19 <Cale> Yeah, don't bother with packages, just install the generic linux binary from the GHC website
15:38:21 <tippenein> I've got the string from readFile
15:38:34 <dmwit> tippenein: map read . words ;-)
15:38:39 <Cale> and then grab the cabal-install tarball from hackage and run the bootstrap.sh script from that
15:38:42 <cmccann> > map read . words $ "1 2 3" :: [Int]
15:38:43 <lambdabot>   [1,2,3]
15:39:11 <cmccann> > map read . words $ "i am not a number" :: [Int]
15:39:12 <lambdabot>   [*Exception: Prelude.read: no parse
15:39:22 <dmwit> hm
15:39:23 <cmccann> if you want better error handling, use something else :P
15:39:34 <dmwit> > map read . take 1 . reverse . words $ "i am NaN" :: [Double]
15:39:36 <lambdabot>   [NaN]
15:39:41 <cmccann> :D
15:39:55 <tippenein> in python I'd just split(" ") and loop through
15:40:08 <dmwit> That is what you do in Haskell, to.
15:40:09 <dmwit> too.
15:40:15 <cmccann> tippenein: that's pretty much what "map read . words" is doing
15:40:18 <Clint> wereHamster:        ghc |    7.6.2-1 | raring-proposed/universe | source, amd64, armhf, i386, powerpc
15:40:20 <cmccann> > words "1 2 3"
15:40:21 <dmwit> We just spell 'split(" ")' as "words".
15:40:22 <lambdabot>   ["1","2","3"]
15:40:33 <cmccann> > read "11" :: Int
15:40:35 <lambdabot>   11
15:41:38 <RenJuan> is this a christian channel? The last time I got clocked for Anglo Saxon usages it was in a channel where the principal developer was a Mormon.
15:41:41 <wereHamster> Clint: actually, I want to create a static binary that will work on 12.04
15:42:14 <Clint> and 7.4 isn't good enough?
15:42:33 <wereHamster> Clint: my code uses functions which are not in 7.4 (forkFinally)
15:42:35 <simpson> RenJuan: Please stay on-topic.
15:42:41 <c_wraith> RenJuan: this channel's only religion is haskell
15:43:04 <cmccann> RenJuan: it's a channel with a large number of people and an expectation of general politeness
15:44:53 * RenJuan suspected it (haskell) was a religion.
15:45:11 <simpson> RenJuan: It's not.
15:45:46 <Clint> cult
15:46:17 <tgeeky> cult implies a certian amount of systematic non-thinking, which is not the case. cabal might work.
15:46:25 <cmccann> cabal is clearly correct
15:46:33 <cmccann> I mean really
15:46:34 <Taneb> sect?
15:47:05 <Clint> you can't have a cabal with open membership
15:47:15 * dmwit feels as though #haskell is getting very successfully trolled
15:47:20 <simpson> ^^
15:47:55 <tgeeky> dmwit: I'm hapling!
15:47:59 <tgeeky> halping*
15:48:02 <dmwit> \o/
15:49:33 <Taneb> I'm saddened that I seem to be the only person in the Haskell community with a vague interest in developing genealogy software
15:50:34 <tgeeky> Taneb: that's like, family trees, not genetics right?
15:50:41 <Taneb> Yeah
15:50:55 <cmccann> Taneb: that reminds me of one of the best questions ever on stackoverflow: http://stackoverflow.com/q/6163683/157360
15:51:00 <Clint> what more do you need beyond trees?
15:51:13 <Taneb> Clint, the scary thing is, they aren't actually trees
15:51:27 <Taneb> They're a weird restriction on graphs
15:51:53 <tgeeky> i was going to say something like "isn't a family tree just some simple kind of tree data structure"
15:52:23 <cmccann> the SO question I linked to actually has some legit interesting discussion about this, fwiw
15:52:59 <tgeeky> yes, indeed, /me reads
15:53:00 <Clint> Taneb: ah, because of situations where your father is also your brother?
15:53:37 <Taneb> Because you can have brothers
15:53:41 <Taneb> That makes it not a tree
15:53:55 <tgeeky> None of these solutions will cope with our beloved Fry from Futurama.
15:54:11 <tgeeky> Due to his past nastification, he is his own grandfather.
15:54:48 <Taneb> The library I've been working on is unspecific enough that that's legal
15:54:52 <cmccann> I like how the general conclusion on that SO question is "don't try to enforce invariants, no matter how sensible they sound, real family relationships are more complicated than you'll ever capture"
15:54:53 <tgeeky> cmccann: this clearly struck a chord with some people. Every damn response has 5 comments.
15:55:08 <cmccann> rather more than 5 in most cases I'm sure
15:55:16 <cmccann> that's just the most it displays by default
15:55:28 <cmccann> the question itself has 40+ comments
15:55:58 <dmwit> http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/
15:56:25 <tgeeky> it now occurs to me that this SO question implies the only project I ever wrote in Smalltalk (a family tree program) is fundamentall flawed.
15:56:34 <glguy> That list would have been more interesting if it gave actual examples, dmwit (from last time I saw it)
15:56:37 <tgeeky> dmwit: yeah, that one is more understandable, to me.
15:57:02 <simpson> Ugh, I still hate that post.
15:57:02 <cmccann> yeah, the names thing is just the most blatant of this general problem
15:57:19 <simpson> "Here's a bunch of things that are not true about names. Also I have no advice to give you on how to Do It Right."
15:57:26 <dmwit> Names, dates, time, families, strings...
15:57:28 <frontendloader> add relationship you sick fuck? (y/n)
15:57:30 <cmccann> which is that a lot of real-world data doesn't consistently follow the rules you expect
15:57:37 <tgeeky> cmccann: perhaps not. Names are a very, very arbitrary thing imposed upon people.
15:57:43 <dmwit> The real world is stupidly complicated in even the simplest things.
15:58:52 <cmccann> dmwit: I still contend that the three hardest things to get right in programming are dates and times, text manipulation, and arithmetic
15:59:11 <niteria> are there any papers explaining how monad transformers are implemented?
15:59:13 <dmwit> Huh, arithmetic?
15:59:16 <simpson> cmccann: And off-by-one errors.
15:59:22 <Taneb> I've tried to make as few assumptions as possible
15:59:28 <elliott> glguy: simpson: I think it is more effective for not giving examples.
15:59:29 <tgeeky> cmccann: /me objects too re: arithmetic
15:59:31 <Taneb> Assumptions I have made:
15:59:31 <cmccann> dmwit: precision and truncation issues, especially with floating point
15:59:42 <elliott> the very fact that it might be hard to imagine examples for some of them is what shows you you have preconceptions
15:59:49 <dmwit> Right, I thought you might say that. This is why I avoid floating point. =P
15:59:49 <Taneb> People have a primary name
15:59:54 <simpson> elliott: I think that, if I were to take him at face value, I would be unable to store names, period.
15:59:57 <dmwit> That's an easy rule that solves a lot of problems.
15:59:57 <Taneb> People have two parents
16:01:00 <Taneb> Even these are pretty big assumptions...
16:01:04 <cmccann> dmwit: avoiding floating point helps immensely, I still hate that Haskell defaults to Double instead of Rational >:[
16:01:17 * dmwit shakes his fist
16:01:51 <simpson> elliott: I have a single preconception: If I am to be able to refer to a person, I need to have some sort of identifier for them. patio11 says nothing but "Nope, you can't," and that is *useless* for me as a programmer.
16:01:58 <glguy> elliott: I think as it stands now most people will see it and think "Oh well, sucks for those people"
16:02:14 <elliott> simpson: the article never claims to be advice on how to store names.
16:03:07 <simpson> elliott: FBOW, people keep referring to the article, so I'm blaming the article, because otherwise I would have to blame the greater HN community, which doesn't get us anywhere we haven't been.
16:04:01 * dmwit notes that there are counterexamples to most of the article's assumptions in the comments
16:04:01 <oax> I'm having trouble with Data.Hex.    I'm trying combinations of base64 & hex .   this works :  "(hex . decode) myb64"  this doesnt: "(encode . unhex) myhex"   I think it has to do witha  Monad in the unhex def.  :
16:04:16 <oax> unhex :: (Monad m, Hex t) => t -> m t
16:04:57 <oax> I wish it were straight-up String -> String, but how do I go about discarding that monad so I can compose?
16:05:19 <dmwit> You don't.
16:05:21 <dmwit> Instead, you list the encoding into the monad.
16:05:33 <glguy> If it works for any Monad, grab Id or Maybe
16:05:36 <Cale> oax: This is a silly package
16:05:40 <glguy> and get the value out
16:05:46 <dmwit> Or, you specialize the monad to something you know how to deal with, like Either.
16:05:47 <dmwit> s/list the encoding/lift the encoding/
16:05:48 <oax> Cale: what's preferred?
16:05:54 <Cale> oax: There's readHex and showHex in Numeric, which is part of the Haskell standard
16:06:01 <Cale> :t showHex
16:06:02 <lambdabot> (Integral a, Show a) => a -> ShowS
16:06:14 <Cale> Should probably be called showsHex, but whatever
16:06:17 <dmwit> For example, "encode <$> unhex myhex", with appropriate imports.
16:06:31 <Cale> > showHex 32768 ""
16:06:33 <lambdabot>   "8000"
16:06:38 <oax> Cale: OK, but I'd like this to work on strings, not numbers.  I would prefer not converting data in a string to an integer unnecessarily
16:06:46 <Cale> :t readHex
16:06:47 <lambdabot> (Eq a, Num a) => ReadS a
16:07:00 <elliott> probably picking Identity for that unhex is a bad idea
16:07:00 <elliott> it most likely uses fail
16:07:07 <Cale> :t readHex "deadbeef"
16:07:08 <lambdabot> (Eq a, Num a) => [(a, String)]
16:07:15 <Cale> > readHex "deadbeef"
16:07:16 <lambdabot>   [(3735928559,"")]
16:07:18 <dmwit> This is why I suggested Either.
16:07:27 <oax> I guess I need to learn monads
16:07:35 <Cale> > readHex "deadbeef some extra junk"
16:07:37 <lambdabot>   [(3735928559," some extra junk")]
16:07:54 <Cale> oax: What do you mean about not working on numbers?
16:07:56 <oax> I'm just going alone with a book that hasn't introduced monads yet, and I was trying to do some useful stuff on my own
16:08:07 <Taneb> oax, thing 1 to learn about monads: there are a lot of them, and they are diverse as anything
16:08:20 <Cale> oax: You realise that you can just apply show to the resulting Integer value if you want a String in decimal?
16:09:10 <Cale> You don't need to learn about monads here, and the use of the Monad typeclass in Data.Hex is an abuse.
16:09:17 <oax> Cale: the equiv of binascii.bta_hex  from python
16:09:21 <oax> b2a_hex
16:09:25 <Cale> (which has nothing to do with monads)
16:10:09 <Cale> oax: I still recommend using readHex/showHex in Numeric
16:10:09 <oax> so string (list of bytes) -> concat of the hex values of those bytes
16:10:43 <oax> Cale: ok, I'm imaining converting my string of bytes to an integer by interpreting as a base 256 number, is that what you had in mind?
16:10:59 <oax> or convert 1 byte at a time and concat?
16:11:34 <Cale> What representation is your string of bytes in?
16:11:55 <MySciThaMan> anyone from denver?
16:12:09 <Cale> > ($ "") . foldr (.) id . map (showHex . ord) $ "Here is a string"
16:12:11 <lambdabot>   "48657265206973206120737472696e67"
16:12:34 <RenJuan> so frontendloader can say f*ck but I can't say sh*t? That's racist.
16:13:03 <simpson> RenJuan: Please be on-topic.
16:13:44 <RenJuan> simpson, please bite yourself
16:13:58 --- mode: ChanServ set +o Cale
16:14:02 --- mode: ChanServ set +o geekosaur
16:14:36 <oax> ah OK here's what I came up with   foldr (\x s -> showHex (ord x) s) ""
16:15:00 --- mode: ChanServ set +o elliott_
16:15:16 <elliott_> darn, I am too late :P
16:15:52 <elliott> @ping
16:15:53 <elliott> interesting. it looks like RenJuan is trolling on the other end of the invisible netsplit.
16:15:53 <elliott> let's see if reconnecting does anything.
16:15:53 <lambdabot> pong
16:15:54 <elliott_> (there was a weird invisible netsplit there. tunes logs had more lines than me and dmwit were receiving, but there was no netsplit message or anything...)
16:16:02 <elliott_> oh, wow.
16:16:10 <elliott_> freenode is confused.
16:16:14 <dmwit> Yeah, it was really strange.
16:16:24 <Cale> Freenode has been really screwy for me the last day or so
16:16:35 <elliott_> dmwit: did you see all the messages from our side of the split come in all at once there?
16:16:46 <dmwit> No, they still haven't arrived here.
16:16:57 <dmwit> Though possibly because I ghosted my other self.
16:18:33 --- mode: geekosaur set -o geekosaur
16:19:37 <GOMADWarrior> Friendly reminder that no one in the enterprise uses a deprecated language like haskell.
16:19:39 <ab9rf> freenode goes all belgium every so often
16:19:55 <elliott> GOMADWarrior: friendly reminder that trolling isn't welcome in #haskell
16:20:11 <ab9rf> good thing i'm not in the enterprise, then
16:20:12 <startling> I forget: is there a well-liked length-typed vector type somewhere?
16:20:26 <ab9rf> i have a new pet protject
16:20:28 --- mode: elliott set -o elliott
16:20:29 <geekosaur> which is why so many banks hire haskell programmers, of course
16:20:38 <startling> maybe I should just write this in idris instead.
16:20:46 <ab9rf> geekosaur: couldn't be because they have a vested interest in having correct code
16:21:01 <simpson> GOMADWarrior: IYSS. :3
16:21:23 <ab9rf> i'm writing a Dartmouth BASIC interpreter.  mostly because i ran across the 1964 spec and i want to see how easy it is to implement
16:21:24 <geekosaur> nlo doubt banks are not enterprises
16:21:50 <ab9rf> i'm going to cheat, though, and not implement all of the very restrictive limits in the original
16:22:06 <Cale> GOMADWarrior: the company I work for is in the process of rewriting our web application backend in Haskell
16:22:34 <RenJuan> really, yesod or what?
16:22:38 <Cale> Snap
16:23:04 <ab9rf> Cale: i've got a webapp that i'm going to implement in haskell when i get around to putting that server back on line
16:23:13 <RenJuan> snap's kinda like the ruby of haskell
16:23:18 <RenJuan> or rails I guess
16:23:30 <Cale> How so?
16:23:34 <geekosaur> I think most people would say yesod is that, because of all the metaprogramming it does
16:23:41 <RenJuan> the overall aesthetic
16:24:01 <Taneb> Haskell has a nice choice of web frameworks
16:24:05 <Taneb> That are very mix and match
16:24:21 <tgeeky> there is a 'hails' package
16:24:43 <Taneb> And Haskell on a Horse somewhere
16:25:00 <ab9rf> there's never one way to do anything in haskell
16:25:07 <ab9rf> if it can be done, it can be done more than one way
16:25:10 <Clint> there are more haskell web frameworks than meaningful ipv6 addresses
16:25:19 <Cale> There's never one way to do anything in any Turing complete language.
16:32:36 <ag90> Hey, is there a way for a program to emit some form of event marker that will be shown in the heap profile graph?
16:33:12 <ag90> Clarification: I want the program to say "I have reached phase X" and for that to be marked in the heap profile graph
16:33:17 <DanBurto_> If I have a tuple, (a -> b, b -> Maybe a), for some given a and b, what do you call that?
16:33:37 <DanBurto_> one-way-kinda-isomorphism?
16:33:45 <elliott> DanBurto_: a prism :P
16:35:08 <tgeeky> DanBurto_: a conditional identity?
16:35:09 <bitonic> DanBurto_: I’ve heard the term ‘partial isomorphism’ for that thing before, in the parsing-prettyprinting paper I think
16:35:53 <Cale> Do the functions satisfy any laws with respect to each other?
16:36:27 <DanBurto_> yeah, prism-y laws I think
16:36:29 <tgeeky> bitonic: that's close, but I think you actually need an 'a' for that
16:36:38 <tgeeky> http://hackage.haskell.org/packages/archive/partial-isomorphisms/0.2/doc/html/Control-Isomorphism-Partial-Prim.html
16:37:27 <tgeeky> DanBurto_: I'd go with prism first. pretty neat.
16:37:47 <DanBurto_> the truth is the functions are (a -> b, b -> IO (Maybe a)), but whatever
16:37:49 <elliott> by prism I just meant that I'd represent it as Prism' a b in the first place
16:37:52 <elliott> or do I mean Prism' b a.
16:37:59 <elliott> oh, well that's very different
16:38:09 <tgeeky> yes, I'm backing away now that he said that :o
16:38:39 <DanBurto_> except the IO effects involve only a database which should mostly look pure if you squint hard enough
16:39:00 <DanBurto_> and it's in Scala so the type system can't tell
16:44:48 <ab9rf> i think someone just called me crazy for writing an implementation of 1964 Dartmouth BASIC
16:49:10 <RenJuan> in haskell, right?
16:52:11 <ab9rf> RenJuan: of course
16:52:34 <ab9rf> i'm going to cheat though
16:52:52 <ab9rf> i'n not going to implement all of the restrictions in the 1964 specification
16:52:58 <ab9rf> you will be allowed to have more than two feet of code
16:53:04 * alex`
16:53:11 <Hafydd> me `
16:53:53 <ab9rf> and i'm not going to limit numbers to nine digits
16:54:00 <ab9rf> but will instead just use a platform float
16:54:37 <ab9rf> or limit you to not more than 80 branches
16:56:19 <ab9rf> the 1964 spec is hilarious
16:56:47 <ab9rf> but i won't be implementing stacked gosub
16:56:56 <ab9rf> because that would break the promise that it "just won't work"
16:57:51 <ab9rf> "The user must be very careful not to write a program in which GOSUB appears inside a subroutine which itself is entered via a GOSUB; it just won't work." (page 43)
16:58:10 <jmcarthur> ab9rf: this does not sound crazy to me (implementing it, that is. the spec is crazy)
16:58:12 <rfw> hi, is there an easy way to turn a hex string into a bytestring?
16:58:35 <ab9rf> jmcarthur: implmenenting it is, of course, trivial, but the spec says that it just won't work and who am i to argue? :)
16:58:41 <rfw> like, "74657374" -> "test"
16:59:02 <ab9rf> rfw: i have code for that somewhere
16:59:17 <rfw> ah, i was just wondering if it was anywhere in a library
16:59:27 <ab9rf> https://gist.github.com/ab9rf/5149421
16:59:28 <rfw> i'm just lazy
16:59:42 <jmcarthur> > Data.ByteString.pack . show . (read :: String -> Int) . ("0x"++)
16:59:43 <lambdabot>   Not in scope: `Data.ByteString.pack'
16:59:47 <jmcarthur> bah
17:00:02 <jmcarthur> > show . (read :: String -> Int) . ("0x"++) $ "74657374"
17:00:04 <lambdabot>   "1952805748"
17:00:05 <ab9rf> look for fromHex
17:00:18 <ab9rf> jmcarthur: ouch
17:00:21 <jmcarthur> :P
17:01:05 <ab9rf> jmcarthur: he wants a bytestring, presumably by converting to ascii, not to a long
17:01:06 <jmcarthur> rfw, ab9rf: but okay seriously, just use readHex from here http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Numeric.html
17:01:16 <jmcarthur> oh?
17:01:20 <jmcarthur> i actually have no idea
17:01:49 <ab9rf> jmcarthur: 74657374 is a hex representation of "test"
17:01:53 <jmcarthur> ah!
17:02:25 <jmcarthur> i think i would still use readHex and then use cereal or something to serialize it however i want
17:02:41 <ion> > preview hex "1234abcd"
17:02:43 <lambdabot>   Not in scope: `hex'
17:02:43 <lambdabot>  Perhaps you meant `lex' (imported from Prelude)
17:03:10 <ion> > preview (base 16) "1234abcd"
17:03:12 <lambdabot>   Just 305441741
17:04:11 <ab9rf> that gist i posted is crap haskell, but i wrote it two years ago when i really didn't knwow mch haskell :)
17:05:18 <niteria> :t base
17:05:19 <lambdabot> (Integral a, Show a, Applicative f, Choice p) => a -> p a (f a) -> p String (f String)
17:06:09 <niteria> :t preview
17:06:10 <ab9rf> hm.  why did i write toPolar . ($x)
17:06:10 <lambdabot> MonadReader s m => Getting (First a) s t a b -> m (Maybe a)
17:06:15 <ab9rf> that seems deranged
17:06:31 <tootooroo> :i Choice
17:06:35 <ab9rf> :t \f x -> f . ($x)
17:06:36 <lambdabot> (b -> c) -> a -> (a -> b) -> c
17:06:47 <tootooroo> Dangit, I keep forgetting lambdabot is not ghci.
17:06:54 <nicoo> @pl \f x -> f . ($x)
17:06:55 <lambdabot> (. flip id) . (.)
17:07:05 <ab9rf> nicoo: that's not better
17:07:06 <tootooroo> @hoogle Choice
17:07:06 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
17:07:06 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
17:07:06 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
17:07:17 <nicoo> ab9rf: pointless seldom is
17:07:41 <nicoo> I was just curious about what it would look like
17:08:12 <ab9rf> nicoo: i'm sure there's something stupid about doing map (f . ($x))
17:08:28 <Fuuzetsu> @pl f y = liftM(g, h y)
17:08:28 <lambdabot> f = fmap . (,) g . h
17:09:07 <ab9rf> nicoo: but that was back when i didn't really understand haskell syntax at all and got a lot of stuff to work just by whacking at it until it generated the resut i wanted
17:09:08 <Fuuzetsu> @pl f g h y = liftM(g, h y)
17:09:08 <lambdabot> f = ((fmap .) .) . (.) . (,)
17:09:16 <ab9rf> :t \f x -> map (f . ($x))
17:09:18 <lambdabot> (b1 -> b) -> a -> [a -> b1] -> [b]
17:10:52 <niteria> tootooroo: http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Prism.html#g:5
17:11:40 <ab9rf> @pl \f x -> map (f . ($x))
17:11:41 <lambdabot> (map .) . (. flip id) . (.)
17:11:53 <ab9rf> snerk
17:12:33 <ab9rf> @unpl (map .) . (. flip id) . (.)
17:12:33 <lambdabot> (\ l r -> map (\ i -> l (i r)))
17:14:13 <Fuuzetsu> @hoogle [m b] -> m [b]
17:14:13 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:14:14 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
17:14:14 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
17:14:26 <Fuuzetsu> @hoogle [m [b]] -> m [b]
17:14:27 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
17:14:27 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
17:14:27 <lambdabot> Prelude concat :: [[a]] -> [a]
17:15:48 <niteria> :t liftM concat . sequence
17:15:50 <lambdabot> Monad m => [m [a]] -> m [a]
17:20:29 <niteria> :t foldM (>>) (return ())
17:20:31 <lambdabot> Monad m => [m (m ())] -> m (m ())
17:21:39 <ab9rf> ug
17:21:57 <niteria> :t foldM (>>) mzero
17:21:58 <lambdabot> MonadPlus m => [m (m a)] -> m (m a)
17:25:18 <niteria> :t mconcat . sequence
17:25:19 <lambdabot> [[a]] -> [a]
17:28:11 <arkeet> > sequence [[1,2],[3,4,5]
17:28:13 <lambdabot>   <hint>:1:24: parse error (possibly incorrect indentation)
17:28:13 <arkeet> > sequence [[1,2],[3,4,5]]
17:28:15 <lambdabot>   [[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]]
17:30:25 <ab9rf> whee
17:31:21 <tootooroo> niteria: ty, sorry, I was away
17:34:51 <no-n> is there a function like comparing that returns a bool for equality rather than an ordering?
17:35:06 <tootooroo> no-n: (==) ???
17:35:46 <geekosaur> ((==) on) maybe
17:35:53 <geekosaur> er
17:35:58 <Mortchek> Why does sequence require Monad when it can be written with Applicative? Historical reasons?
17:36:04 <geekosaur> ((==) `on`)
17:36:07 <no-n> something I'd use for groupBy, like groupBy length (sorry kind of an xy problem)
17:36:33 <tootooroo> :t on (==)
17:36:35 <lambdabot> Eq b => (a -> b) -> a -> a -> Bool
17:37:03 <Duffers> Noob question, is there anyway to comment in haskell besides '--'
17:37:05 <geekosaur> Mortchek, yes, sequence predates Applicative by a long time
17:37:16 <Mortchek> Duffers, multi-line comment: {- -}
17:37:25 <no-n> groupBy ((==) length) doesn't work
17:37:27 <geekosaur> {- block comment -}
17:37:44 <Duffers> that takes a list of all the ballot papers that were submitted (one per person), selects the
17:37:47 <Duffers> rst preference vote on each ballot, and returns the result of a rst past the post election
17:37:50 <Duffers> based upon these votes, in increasing order of the number of votes. You may assume that
17:37:53 <Duffers> oops
17:37:55 <Duffers> soprry
17:37:56 <geekosaur> :t (==) `on` length
17:37:58 <lambdabot> [a] -> [a] -> Bool
17:38:05 <Duffers> didnt mean to paste that
17:38:44 <geekosaur> no-n, the "on" in the suggestions was not a comment
17:39:04 <no-n> oops, sorry
17:39:17 <no-n> hmm, I get not in scope `on'
17:39:24 <geekosaur> import Data.Function
17:39:28 <no-n> ty
17:39:44 <no-n> yay it works =}
17:39:48 <no-n> thanks
18:08:19 <andrewsw> my forkIO based socket server appears to run twice as fast as a C version based on fork().
18:08:45 <andrewsw> (based on timings for handling 100,000 sequential requests)
18:09:39 <andrewsw> is this a case of fork() just being a lot more expensive than a ghc runtime thread?
18:10:10 <cmccann> possibly, haskell threads are comparatively very cheap
18:11:12 <andrewsw> the code is otherwise fairly equivalent, except that the C version has to create a file descriptor that the ghc code doesn't do explicitly.
18:12:50 * hackagebot unix-time 0.1.6 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.1.6 (KazuYamamoto)
18:13:23 <andrewsw> maybe I'll reimplement with pthreads and see what happens.
18:13:41 <alpounet> andrewsw, if you create as many threads in the C version as in the Haskell one, then yes it is normal, GHC Haskell's threads (created with forkIO) are very cheap and lightweight
18:13:54 <alpounet> they are not OS threads
18:14:01 <andrewsw> right.
18:44:29 <jmcarthur> andrewsw: i expect that you will have the same problem with pthreads in C as with fork in C. to compete with ghc threads you will need some sort of green thread library
18:45:24 <jmcarthur> andrewsw: to be honest, i'm surprised your haskell version was *only* twice as fast
18:45:57 <jmcarthur> andrewsw: were you perhaps using String instead of a faster type like ByteString?
18:53:41 <ab9rf> you compared fork to threads?
18:53:43 <ion> String and ByteString do not represent the same thing.
18:53:46 <hpaste> tippenein pasted “String IO” at http://hpaste.org/85004
18:54:12 <geekosaur> tippenin, get thee to lyah
18:54:15 <geekosaur> @where lyah
18:54:15 <lambdabot> http://www.learnyouahaskell.com/
18:56:44 <jmcarthur> ion: no, but if you're comparing to ascii strings in C, ByteString is enough
18:57:47 <no-n> do wheres span across guards?
18:58:32 <geekosaur> yes
18:59:52 <ab9rf> heh
19:00:44 --- mode: ChanServ set -o Cale
19:00:56 <ab9rf> tippenein: welcome to the wonderful world of IO in Haskell :)
19:04:12 <tgeeky> in linux, you can treat [process] and [thread] as the same thing (and I think their in-memory descriptors are identical)
19:04:23 <tippenein> ab9rf: everything else has been good ;)
19:04:38 <tgeeky> but actually using the fork syscall incurs all kinds of copying costs, and inserts an opportunity to get unscheduled
19:04:40 <ion> tippenein: words <$> readFile "ns.txt"
19:05:02 <ion> tippenein: or: split ns ' ' <$> readFile "ns.txt"
19:05:25 <ion> tippenein: (<$>) is just an infix alias to fmap and you usually get it by importing Control.Applicative.
19:05:34 <ab9rf> you nede (\ns -> split ns ' ') <$> readFile "ns.txt"
19:05:49 <ion> whoops, indeed
19:06:05 <ion> tippenein: You might want to make the delimiter the first parameter and you could use split ' ' <$> …
19:06:10 <ab9rf> @pl \ns -> split ns ' '
19:06:10 <lambdabot> flip split ' '
19:06:12 <ion> tippenein: (or you could just use words :-P)
19:06:18 <ab9rf> or (flip split ' ') :)
19:06:39 <ion> tippenein: Btw, avoid head and tail.
19:06:55 <tippenein> oh?
19:07:55 <ab9rf> hm, that code doesn't look right
19:08:10 <ab9rf> :t ('a' : head "abc")
19:08:11 <lambdabot>     Couldn't match expected type `[Char]' with actual type `Char'
19:08:11 <lambdabot>     Expected type: [[Char]]
19:08:11 <lambdabot>       Actual type: [Char]
19:08:14 <ab9rf> thought so
19:08:46 <ab9rf> and really split [] _ should be [] not [""]
19:09:37 <ion> @src words
19:09:38 <lambdabot> words s = case dropWhile isSpace s of
19:09:38 <lambdabot>     "" -> []
19:09:38 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
19:09:45 <ab9rf> oh, i see what you're trying to do here
19:11:49 <ab9rf> :t ('a' : head ["abc"])
19:11:50 <lambdabot> [Char]
19:12:00 <ab9rf> that split probably does work
19:12:08 <ab9rf> but i'm concerned about how much stack it will use
19:12:21 <tippenein> it's just extracting numbers from a text file and sorting them
19:12:22 <shachaf> Heaps of it.
19:13:04 <ab9rf> shachaf: yeah, it looks like it will eval the recursion all the way to the end of the input stringbefore it produces anything
19:13:34 <ab9rf> which will put n frames on the stack, where n is the length of the string
19:14:09 <ab9rf> or rather a very large incompletely evaluated expression
19:16:31 <Thyrgle> Hello, I am new here, and heard from the Haskell website that this is a place to ask questions.  Can I ask a question now or would I be interrupting something? Sorry I am new to IRC and Haskell, not exactly sure how everything works.
19:16:35 <jmcarthur> tgeeky: well, fork doesn't typically trigger much copying if your process doesn't thrash its memory a lot (such as if there is no GC involved), since the policy is copy-on-write anyway
19:16:39 <ab9rf> Thyrgle: ask away
19:16:45 <Thyrgle> Ok thank you.
19:16:53 <ab9rf> jmcarthur: still expensive to create a new process.
19:16:54 <andrewsw> jmcarthur: yeah, just the String version of Network.Socket.
19:16:58 <Thyrgle> So, i am working on Problem 7 of the h-99
19:17:07 <Thyrgle> http://www.haskell.org/haskellwiki/99_questions/1_to_10
19:17:08 <jmcarthur> ab9rf: somewhat, yes
19:17:22 <Thyrgle> and have come up with the following function:
19:17:25 <Thyrgle> data NestedList a = Elem a | List [NestedList a]
19:17:25 <Thyrgle> --flatten :: (NestedList a) -> [a]
19:17:25 <Thyrgle> flatten (Elem a) = [a]
19:17:25 <Thyrgle> flatten (List a) = map remove (map flatten a)
19:17:25 <Thyrgle>                  where
19:17:25 <Thyrgle> 				 remove [a] = a
19:17:29 <elliott> please don't paste lots of code
19:17:30 <elliott> @hpaste
19:17:30 <lambdabot> Haskell pastebin: http://hpaste.org/
19:17:50 <tippenein> ab9rf: thanks, I'll try rewriting split and look up <$> :)
19:17:59 <Thyrgle> oh ok.
19:18:07 <elliott> if you use hpaste people can look at it and it doesn't flood the channel
19:18:13 <elliott> btw, you're using tab characters there -- generally when coding haskell you should set your editor to expand tabs to spaces
19:18:22 <hpaste> Thyrgle pasted “h-7 failed solution” at http://hpaste.org/85005
19:18:52 <Thyrgle> ok so it works for a couple examples on the h-99 page
19:19:01 <ab9rf> often hpaste gives you hints as to what you did wrong too :)
19:19:47 <ab9rf> Thyrgle: do you get an error about nonexhaustive patterns?
19:19:51 <elliott> hlint's hint doesn't really help there.
19:19:52 <Thyrgle> yeah
19:20:20 <ab9rf> Thyrgle: first hint: what is remove [a1,a2] ?
19:20:41 <Thyrgle> i guess that doesn't work out right
19:20:53 <Thyrgle> you can't really remove the brackets from a1,a2
19:23:30 <tgeeky> jmcarthur: Looking things up, the distinction I'm making is between fork() and clone(), and the distinction of import is if you're sharing all of the descriptors (hopefully,yes) and memory space. That is "as free as it gets", and it may as well be a cll to fork() with appropriate flags, if I read the docs right.
19:23:34 <elliott> you want to turn [[1,2],[3,4]] into [1,2,3,4]. you can't do that with map
19:23:38 <elliott> > map f [[1,2],[3,4]]
19:23:40 <lambdabot>   Ambiguous type variable `b0' in the constraints:
19:23:40 <lambdabot>    (GHC.Show.Show b0)
19:23:40 <lambdabot>     ...
19:23:42 <elliott> ugh.
19:23:44 <elliott> > map f [[1,2],[3,4]] :: [Expr]
19:23:46 <lambdabot>   [f [1,2],f [3,4]]
19:23:52 <ab9rf> hah
19:23:57 <elliott> there's no "f" that could make that work -- the resulting list is always going to have two elements.
19:24:06 <ab9rf> yeah, you're going to need to like foldr (++) or something
19:24:12 <carter> jmcarthur yo, reminder we should catch up soon :)
19:24:17 <elliott> ab9rf: spoilers :)
19:24:22 <cmccann> "f [x,y] = x,y" WHAT NOW :O
19:24:28 <Thyrgle> ok thanks for the advice i'll see what i can do
19:24:51 <elliott> Thyrgle: note that there is a standard function that achieves this task.
19:24:55 <elliott> but I suspect writing your own will be more rewarding.
19:25:11 <jmcarthur> carter: let's shoot for... not this week. next week maybe?
19:25:20 <arkeet> > concat [[1,2],[3,4]] -- look, I removed brackets!
19:25:20 <carter> jmcarthur that works for me
19:25:22 <lambdabot>   [1,2,3,4]
19:25:24 <Thyrgle> is there a way to do something like flatten (List x:xs)?
19:25:27 <tgeeky> jmcarthur: I had the advantage of learning the internals of linux in college. The disadvantage is I learned against 2.4 and just a little of 2.6.
19:25:29 <jmcarthur> carter: this weekend might be good, too
19:25:33 <carter> that would work too
19:25:40 <jmcarthur> tgeeky: that sounds like my background, too
19:25:45 <carter> i might even have pre release baby benchmarks by then!
19:25:46 <ion> @hoogle [[a]] -> [a]
19:25:46 <lambdabot> Prelude concat :: [[a]] -> [a]
19:25:46 <lambdabot> Data.List concat :: [[a]] -> [a]
19:25:46 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:25:59 <jfischoff> :t join
19:26:00 <lambdabot> Monad m => m (m a) -> m a
19:26:37 <Thyrgle> ok so i'm guessing i should use concat then.
19:26:38 <jmcarthur> tgeeky: plus some professional kernel dev work after, but i never really dug into much of the task management stuff
19:26:53 <jmcarthur> tgeeky: (and i wasn't very good at it, either)
19:27:03 <jmcarthur> carter: sweet!
19:27:08 <carter> yessss
19:27:11 <tgeeky> jmcarthur: that was the single most difficult school project I ever had. A group of three had to write the 2.6 O(1) scheduler into the 2.4 O(N) kernel.
19:27:17 <carter> very very sweeet, anbd not fructoose
19:27:29 <carter> tgeeky what sort ouf course was that?!
19:27:30 <tgeeky> jmcarthur: on a handheld compaq ipaq.
19:27:31 <Thyrgle> ok thanks so much! I got it!
19:27:33 <carter>  and wher e/ where
19:27:34 <jmcarthur> tgeeky: that was definitely one of my most fulfilling courses
19:27:53 <carter> i didn't do OS in undergrad, wasn't in the right head space for a number of reasons
19:27:54 <tgeeky> jmcarthur: Linux Internals at Georgia Tech
19:27:57 <jmcarthur> tgeeky: i added full memory and swap encryption, for my project
19:27:57 <carter> cool
19:28:14 <carter> i may do some slow level hacking in the near future
19:28:18 <tgeeky> jmcarthur: when replacing the scheduler, if it doesn't boot... you have to re-flash the kernel
19:28:21 <jmcarthur> tgeeky: <something something operating systems> at University of Alabama in Huntsville
19:28:26 <tgeeky> reflash the whole device, of course
19:28:27 <ab9rf> @src concat
19:28:27 <lambdabot> concat = foldr (++) []
19:28:28 <jfischoff> jmcarthur: I just realized your in Indiana
19:28:36 <jmcarthur> jfischoff: err, no
19:28:43 <carter> i've realized i might have more than 1 reason to experiment with  CAS primops for arrays
19:28:45 <jfischoff> ha
19:28:46 <jmcarthur> jfischoff: i am in NYC
19:28:52 <ab9rf> indiana, new york, same thing
19:28:53 <carter> like me!
19:28:59 <carter> hello jfischoff  :)
19:29:05 <carter> NYC has more food
19:29:07 <carter> and less driving
19:29:09 <tgeeky> ab9rf: they are both places, on the same spherical shell!
19:29:10 <jmcarthur> carter: you mean write some of your own primops?
19:29:20 * jfischoff waves at carter
19:29:21 <jmcarthur> carter: btw, have you been playing with the new vector primops yet?
19:29:22 <carter> jmcarthur i might be playing with the cmm ffi :)
19:29:26 <carter> jmcarthur nope
19:29:32 <carter> i should
19:29:32 <ab9rf> carter: and more arbitrary police actions
19:29:33 * jfischoff waves at ion
19:29:38 <jmcarthur> me either, but i'm thinking about it
19:29:41 <ab9rf> sorry, off topic that was :)
19:29:50 <ab9rf> i used to be from indiana
19:29:52 <carter> jmcarthur first i need to get things to a benchmarking state
19:29:58 <carter> then i can evaluate stuff like that
19:29:58 <shachaf> nyc++
19:30:12 <jfischoff> nc++
19:30:13 <ab9rf> for a while, i lived in indiana and worked in new york city
19:30:19 <carter> shachaf yes, nyc ++
19:30:20 <carter> ftw
19:30:31 <arkeet> hq9++
19:30:34 <jfischoff> the city++
19:30:37 <carter> better food choices and more people than most other places
19:30:37 <carter> ever
19:30:43 <carter> indeed, tis the city
19:30:50 <jfischoff> works us too
19:31:08 <carter> jmcarthur jfischoff .... also i may be able to talk some places into adding haskell to their stacks soon
19:31:32 <jmcarthur> jfischoff: *you're
19:31:40 <jmcarthur> because i'm a jerk
19:31:51 <jmcarthur> and my wife is a grammar nazi and peeked over my shoulder
19:32:03 <ab9rf> no gerunds for you
19:32:36 <jmcarthur> carter: oh yeah?
19:32:52 <carter> jmcarthur i'll tell you when we catch up :)
19:34:15 <jfischoff> jmcarthur: I would like to say if I type slower I notice…but that is not the case
19:35:50 <mikeplus64> jmcarthur: just out of curiosity, what are these "new vector primops"?
19:37:04 <carter> mikeplus64 some  sse / avx  operations
19:37:05 <jmcarthur> mikeplus64: not sure of the best page to link http://hackage.haskell.org/trac/ghc/wiki/SIMD
19:37:10 <carter> when you build on archs that support them
19:37:18 <mikeplus64> neat
19:37:18 <carter> so code could be 2-8x faster maybe
19:37:28 <jmcarthur> i think ghc HEAD has the primops in already?
19:37:57 <carter> yes
19:38:24 <carter> though you have to use mainland's vector repo /branch to use the faster vector lib
19:38:50 <jmcarthur> oh there's already patches for vector? i didn't know that
19:39:15 <jmcarthur> i thought there was going to be a good deal of thinking necessary to make that work out well
19:39:17 <carter> also uses http://www.eecs.harvard.edu/~mainland/publications/mainland12simd.pdf
19:39:31 <carter> jmcarthur they don't benchmark fancy locality stuff
19:39:51 <jmcarthur> ooh generalized stream fusion? sounds interesting and i'm surprised this slipped past my radar
19:41:32 <jmcarthur> hmm, the paper mentions append as a "bad" stream operation. i always thought that should be an easy one to fix by using an apomorphism instead of an anamorphism
19:41:46 <carter> i don't know what those are
19:42:55 <jmcarthur> anamorphism is unfoldr. apomorphism is the same but with the ability to shortcut the whole thing by returning some tail instead of having to regenerate the whole thing
19:43:34 <carter> jmcarthur i think the solution is to kinda take a page from the stuff going on in the repa 4 work, and do the fusion at run time
19:43:55 <ab9rf> just don't confuse apomorphism and anthropomorphism
19:44:25 <jmcarthur> carter: runtime? repa 4 fusion is at runtime?
19:44:38 <carter> you have slightly worse constant factors, but you can do more aggressive / interesting fusion
19:44:41 <carter> i think so
19:44:46 <jmcarthur> that sounds suspicious
19:44:49 <carter> i've not looked at their darcs repo in a while
19:44:59 <mikeplus64> does that entail more or less changing repa into a array DSL?
19:45:21 <carter> mikeplus64 it IS an array dsl
19:46:07 <carter> jmcarthur i think the point is to have performance that isn't as dependent on "INLINE ALL THE THINGS ALWAYS"
19:46:15 <mikeplus64> carter: but only for like Array D sh a?
19:46:23 <jmcarthur> carter: ah. i can't wait, then!
19:46:27 <carter> mikeplus64 i don't understand your question
19:47:06 <mikeplus64> carter: for repa i mean doesn't fusion only happen with arrays whose type is Array D sh a?
19:47:32 <carter> umm, fusion tends to be specific to a library, yes
19:47:52 <mikeplus64> i think i'm misunderstanding repa
19:48:02 <jmcarthur> mikeplus64: you're basically right. there may be some other delayed array types that also fuse, but i don't remember
19:48:16 <mikeplus64> ok
19:48:23 <carter> mikeplus64 the data model is somewhat different looking in the repa head repo last i checked
19:48:23 <jmcarthur> mikeplus64: but carter is talking about repa 4, which isn't out yet and sounds kind of different somehow
19:48:28 <carter> yup
19:48:33 <mikeplus64> oh ok
19:48:40 <carter> got darcs get repa-unstable
19:48:41 <carter> or whatever
19:48:44 <mikeplus64> any haddocks around for it?
19:48:44 <carter> :)
19:48:53 <carter> only those you dl and cabal haddock yourself :)
19:48:58 <mikeplus64> alright
19:50:33 <jmcarthur> wow this paper promises a lot in the intro
19:50:42 <jmcarthur> beating C and competitive with hand-tuned assembly
19:51:35 <carter> jmcarthur for the exact work loads that don't require fancy locality :)
19:52:33 <jmcarthur> yeah yeah... ;)
19:58:19 <mikeplus64> carter: http://code.ouroborus.net/repa/repa-head/ is this what i should look at? the cabal version is still 3.2.3.1
19:58:34 <carter> mikeplus64 you're looking in the wrong sub dirs :)
19:58:37 <carter> right directory
19:58:40 <carter> wrong folder in that directory
19:58:52 <mikeplus64> what should i look at?
19:59:00 <carter> i don't remember
19:59:03 <carter> its in several of them
19:59:04 <mikeplus64> lol
19:59:05 <carter> bulk
19:59:06 <carter> flow
19:59:10 <carter> and maybe some others
19:59:23 <carter> i'm kinda writing a competitor thats not out yet :)
19:59:33 <carter> that takes a wildly different approach
19:59:37 <carter> so i've been kinda busy :)
19:59:39 <mikeplus64> neat
19:59:55 <carter> joys /horrors of being self employed
20:00:12 <mikeplus64> seperate from accelerate, dph (although i'm not sure of the scope of dph really), repa etc.?
20:00:36 <carter> yes
20:00:37 <mikeplus64> repa is a dph project? idk
20:00:45 <carter> dph is kinda orthogonal
20:00:57 <carter> you can use it for A LOT more than numerics
20:01:01 <carter> i think
20:01:03 <carter> idk
20:01:19 <carter> i'm just aiming at doing numerics fast in a high level way thats easy for me and hopefully others to use
20:01:54 <mikeplus64> what numerics? matrix/vector/linear algebra stuff or ... ?
20:01:55 <carter> i will be making an announce and code release sometime in the next monthish
20:01:58 <carter> those
20:01:59 <carter> yes
20:02:00 <jmcarthur> yeah dph is much more general
20:02:09 <carter> yeah
20:02:17 <tgeeky> iirc, it's also the thing most improved in 7.4 and 7.6
20:02:22 <mikeplus64> carter: cool, the linear algebra landscape is exciting in haskell
20:02:22 <tgeeky> probably
20:02:35 <carter> mikeplus64 the linear algebra land scape in haskell is crap righ tnow :)
20:02:52 <sproingie> exciting would be using the gpu
20:02:58 <tgeeky> carter: until it's as bad as the string landscape, then we should not cry.
20:03:01 <mikeplus64> uh, diverse
20:03:04 <jmcarthur> sproingie: like accelerate?
20:03:06 <carter> there are no well maintained libs / eco systems with enough BSD style licensed code that business can use
20:03:08 <mikeplus64> there's linear, hmatrix, a few misc vector packages, ...
20:03:33 <carter> mikeplus64 none of those are both BSD and fast at dense and sparse linear algebra compared with other langs tools
20:03:44 <jmcarthur> sproingie: http://justtesting.org/optimising-purely-functional-gpu-programs
20:03:56 <carter> that is a neat paper, need to skimm it more
20:04:10 <mikeplus64> carter: i'd be interested in something that is nicer to e.g. use with GLSL
20:04:20 <sproingie> hm there's that fusion again
20:04:33 <jmcarthur> mikeplus64: yeah. i wonder what has happened to conal's shady library...
20:04:35 <carter> mikeplus64 glsl is orthogonal to what i'm doing right now
20:04:42 <carter> what lib is this?
20:04:44 <jmcarthur> mikeplus64: there's also gpipe, which is... okay
20:04:53 <mikeplus64> !hackage shady
20:04:56 <carter> mikeplus64 though i'll be staring at data vis things soonish
20:04:58 <mikeplus64> @hackage shady
20:04:59 <lambdabot> http://hackage.haskell.org/package/shady
20:05:07 <carter> its empty
20:05:10 <mikeplus64> jmcarthur: hosted anywhere?
20:05:11 <jmcarthur> that's some old version of it
20:05:18 <jmcarthur> mikeplus64: not sure if it is anymore
20:05:24 <carter> http://hackage.haskell.org/package/shady-gen
20:05:33 <carter> also its AGPLY
20:05:36 <carter> AGPL
20:05:44 <carter> which is a bit .... meh
20:05:46 <jmcarthur> carter: yeah, he was thinking about commercializing at one point
20:05:48 <mikeplus64> yeah
20:05:55 <conal> jmcarthur: shady is stalled while i wait for a working low-level gui library to reappear.
20:06:03 <jmcarthur> ah right!
20:06:10 <carter> conal hello!
20:06:19 <carter> what sort of low level gui wrapper?
20:06:23 <conal> jmcarthur: i'd love to get back to that project!
20:06:31 <conal> carter: hi.
20:06:36 <carter> communicate your needs and the commitee will allocate people maybe :)
20:06:49 <carter> conal I enjoyed your lin alg slides from a few months ago!
20:06:56 <conal> carter: :)
20:07:00 <jmcarthur> mikeplus64: there's also http://www.haskell.org/haskellwiki/LambdaCubeEngine
20:07:43 <carter> conal what have you been hacking on instead?
20:08:05 <conal> i've mentioned the broken gui situation many times over the last seven years. i'm looking for a gui library that works cross-platform, is compatible with ghci, and works with opengl.
20:08:12 <ab9rf> heh
20:08:21 <ab9rf> conal: i think you need to write something
20:08:41 <conal> carter: i'm working on compiling haskell to fpga-like devices.
20:08:46 <carter> neat!
20:09:00 <jmcarthur> conal: the fastest way to get something implemented these days seems to be to get edwardk interested in it
20:09:39 <conal> it could be the best route is to leave clunkers like gtk and wx behind and develop something elegantly denotative on opengl.
20:09:50 <conal> jmcarthur: good idea! :)
20:10:00 <jfischoff> conal: yep
20:10:14 <carter> conal jmcarthur  edwardk is a bit busy with things he and other people want as is right now
20:10:22 <carter> :)
20:10:34 <carter> he's been nerd sniped for the next few months i htink
20:10:35 <chenwl> Any differency between foo :: (forall a. a -> a) -> (Char, Bool) and bar :: forall a. ((a -> a) -> (Char, Bool)) ?
20:10:54 <sproingie> i suspect the existing GL bindings are more than sufficient for that, unless you really need geometry shaders and texture views
20:11:00 <jmcarthur> carter: it's important to give your fastest machine the longest queue ;)
20:11:14 <carter> i guess so
20:11:32 <tgeeky> edwardk is like a time-reversed black hole => a white hole. all kinds of things slowly Hawking radiate into his brain over the years; then, suddenly, out pops a full featured espresso machine!
20:12:06 <carter> be warned: the coffee settings are  expressed in point free category theory
20:12:38 <conal> chenwl: yes. consider the possible first argument to foo vs to bar
20:12:38 <mikeplus64> sproingie: supporting only opengl 4+ is probably a bad idea anyway (OpenGLRaw is at 3.3 i think. dunno about OpenGL, i'm partial to it)
20:13:15 * jmcarthur prefers OpenGLRaw over OpenGL
20:13:26 <jmcarthur> much easier to find documentation on it
20:13:27 <tgeeky> I want what conal wants.
20:13:33 <jmcarthur> so do i
20:13:36 <carter> as do i
20:13:42 <jmcarthur> somebody do it
20:13:46 <conal> glad to hear :)
20:13:51 <mikeplus64> jmcarthur: don't like all those StateVars and un-gl-like names
20:14:08 <fsef> Hello, Need help with a homework problem I am stuck on: Using the deﬁnition of trees given by data Tree a = Node (Tree a) (Tree a) | Leaf a  deﬁne tree versions of the list functions zip and zipWith.
20:14:10 <hpaste> dd pasted “problem” at http://hpaste.org/85006
20:14:13 <carter> whcih part has state vars and ungl like names?
20:14:17 <mikeplus64> jmcarthur: i'm sure with inlining and such the overhead of OpenGL could be nil but still it's nicer to just use raw OpenGL
20:14:18 <jmcarthur> mikeplus64: yeah... they are a perfect example of abstraction for the sake of abstraction
20:14:19 <fsef> and that is my code so far
20:14:25 <mikeplus64> carter: more or less all of it?
20:14:28 <haskell_noob> fsef, COMP333? :P
20:14:32 <mikeplus64> !hackage OpenGL
20:14:34 <mikeplus64> @hackage OpenGL
20:14:34 <lambdabot> http://hackage.haskell.org/package/OpenGL
20:14:36 <mikeplus64> oops
20:14:40 <edwardk> carter: aka semigroupoid theory?
20:14:44 <fsef> comp313 you mean?
20:15:00 <haskell_noob> fsef, yeah haha, u done question 9 yet?
20:15:01 <tgeeky> edwardk: sure if you want to be a coffee snob!
20:15:05 <chenwl> conal: which function f can be applied to foo but not bar, vice versa
20:15:12 <carter> category theory in point free notiation is semigroupoid theory?
20:15:39 <fsef> haskell_noob: small world haha, can't get question 8 zipwith to work
20:15:40 <jmcarthur> chenwl: it can be considered rude to just grab somebody who hasn't volunteered to help you
20:16:02 <conal> chenwl: other way around: to which possible f can foo be applied? ditto for bar.
20:18:22 <jmcarthur> carter: wow, this paper describes one nasty solution... it may work, but wow....
20:18:31 <carter> jmcarthur which paper?
20:18:41 <jmcarthur> carter: generalized stream fusion
20:18:48 <carter> oh yeah
20:19:00 <carter> you mean that "chunks of primop size"
20:19:05 <carter> untill you get to the end?
20:19:12 <jmcarthur> "just smash all possible solutions together"
20:21:25 <chenwl> conal: I think both foo and bar accept functions that have type (a -> a)
20:21:43 <conal> chenwl: for which a?
20:21:57 <hpaste> tippenein pasted “attempt 2” at http://hpaste.org/85007
20:21:58 <chenwl> conal: for any a
20:22:24 <conal> chenwl: for instance, the both accept functions of type Bool -> Bool ?
20:22:46 <conal> chenwl: "the" --> "they"
20:23:18 <tippenein> couldn't match [[Char]] with [String]
20:24:21 <shachaf> That's an impressive error.
20:24:24 <ab9rf> tippenein: odd, [[Char]] _is_ [String]
20:24:44 <tippenein> that's what I thought
20:25:48 <geekosaur> that's not the actual type error
20:26:26 <tippenein> it's [[char]] expected and actual string -> [String]
20:26:27 <geekosaur> tippenin, that's not the actual type error. look closely
20:26:36 <geekosaur> yes
20:26:45 <geekosaur> you gave it a function
20:26:46 <shachaf> [[char]] is not likely.
20:26:57 <geekosaur> or a thing which produces a function
20:27:17 <tippenein> the dropWhile?
20:27:28 <ab9rf> first the fixity of $ is very low
20:27:51 <geekosaur> it's the $, yeh
20:27:55 <tippenein> I have no idea where to use $ and when to now
20:28:00 <tippenein> not*
20:28:07 <ab9rf> so that gets parsed as (x : split) $ ...
20:28:08 <geekosaur> it's very low precedenc
20:28:09 <chenwl> conal: compiler says foo wants a -> a but given Bool -> Bool
20:28:28 <ab9rf> x is String and split is String -> [String]
20:28:30 <conal> chenwl: yep.
20:28:33 <tippenein> it works with parens
20:29:13 <ab9rf> tippenein: i've been using haskell for two years and $ still confuses me
20:29:34 <tippenein> I'm trying to fit in with the style ;)
20:29:34 * geekosaur understands it pretty well by now
20:29:43 <chenwl> conal: doest that mean foo only accepts a function that accepts any type of argument?
20:29:58 <haskell_noob> anyone have any idea how to adapt a datatype to allow variables?
20:29:59 <haskell_noob> data Expr = C Float | Expr :+ Expr | Expr :- Expr | Expr :* Expr
20:30:12 <ab9rf> variables?
20:30:23 <chenwl> foo it self is not polymorphic
20:30:33 <jmcarthur> haskell_noob: why not:  data Expr a = C Float | Expr :+ Expr | Expr :- Expr | Expr :* Expr | Var a
20:30:56 <conal> chenwl: exactly
20:30:57 <tgeeky> lots of exprs without a's
20:31:05 <jmcarthur> haskell_noob: at least that is the best i can do with limited information about what you're doing
20:31:06 <chenwl> conal: bar is polymorphic, but his argument is not polymorphic
20:31:13 <jmcarthur> tgeeky: yeah yeah
20:31:15 <haskell_noob> jmcarthur: is it really that easy?
20:31:20 <conal> chenwl: you got it
20:31:22 <jmcarthur> haskell_noob: maybe
20:31:35 <haskell_noob> i can post the question, one sec
20:31:36 <jmcarthur> haskell_noob: have to add 'a's to all the Exprs, of course
20:31:52 <chenwl> conal: aha, thank you!
20:31:57 <conal> :)
20:32:02 <tgeeky> haskell_noob: it's possible you mean 'literal' instead of 'variable'
20:32:21 <jmcarthur> tgeeky: it already has float literals
20:32:41 <ab9rf> you probably do not need a type constructor in this
20:32:43 <tgeeky> jmcarthur: good point. retracted.
20:33:00 <haskell_noob> http://hpaste.org/85009
20:33:11 <tippenein> :t read
20:33:13 <lambdabot> Read a => String -> a
20:33:25 <jmcarthur> haskell_noob: ah, my suggestion is incomplete, since you need let as well
20:33:30 <tippenein> shouldn't read "22" give 22?
20:33:41 <ab9rf> tippenein: not by itself
20:33:45 <ab9rf> > read "22"
20:33:47 <lambdabot>   *Exception: Prelude.read: no parse
20:33:49 <jmcarthur> haskell_noob: this is a very telling line:   evaluate (Let "n" (C 42) (V "n" :+ C 2))
20:33:54 <ab9rf> > read "22" :: Int
20:33:55 <lambdabot>   22
20:34:00 <tippenein> ah, thanks
20:34:07 <haskell_noob> jmcarthur: yeah just trying to get my head around the concept, i was thing about something like |Char Expr
20:34:09 <tippenein> since the type is a
20:34:11 <jmcarthur> haskell_noob: note the constructors there that the original ADT doesn't have
20:34:19 <ab9rf> tippenein: exactly
20:35:19 <geekosaur> note what that means: the caller specifies the type they want. a particular instantiation of read is chosen (based on the Num constraint) to fulfill it
20:35:52 <ab9rf> in many cases the compiler can infer a more specific type without being hinted
20:36:01 <haskell_noob> jmcarthur: im still confused haha
20:36:11 <ab9rf> but Read often need an explicit type to select the appropriate instance
20:36:30 <jmcarthur> haskell_noob: first, can you identify the constructors in this expression from the problem?:   evaluate (Let "n" (C 42) (V "n" :+ C 2))
20:37:34 <ab9rf> infix constructors annoy me for no good reason
20:38:04 <fsef> Is this the correct type for zipwith function for trees zipwith :: (a -> b -> c) -> Tree a -> Tree b -> Tree (c)
20:38:07 <jmcarthur> ab9rf: i like them, myself, although i hate the colon requirement
20:38:10 <haskell_noob> jmcarthur: "n" (C 42)?
20:38:19 <tgeeky> jmcarthur: I can identify the things which are not constructors: "n", 42, "n", 2, evaluate.
20:38:31 <jmcarthur> heh
20:38:34 <haskell_noob> jmcarthur: not too sure what is meant by consturctpr
20:38:43 <haskell_noob> jmcarthur: constructor*
20:38:54 <geekosaur> for starters, all constructors (type or data) start with uppercase
20:39:13 <shachaf> That's not exactly true.
20:39:21 <shachaf> Not with TypeOperators in recent GHC, anyway.
20:39:24 <geekosaur> true
20:39:39 <tgeeky> in this case, all capital lettered words in the problem are constructors
20:39:41 <jmcarthur> haskell_noob: constructors are the things that create values of some datatype. for example, C is a constructor that takes a Float and gives you an Expr
20:39:43 <tgeeky> and one constructor is infix
20:39:53 <geekosaur> but I doubt they're worrying about GHC extensions at this point
20:40:03 <jmcarthur> haskell_noob: those operators that have : in front of them are also (infix) constructors
20:40:33 <jmcarthur> haskell_noob: constructors are special because you can also pattern match on them
20:40:48 <ab9rf> jmcarthur: i don't have a good reason for disliking them.  i just dislike them :)
20:41:24 <fsef> Hi, is this the correct type for the zipwith function for trees zipwith :: (a -> b -> c) -> Tree a -> Tree b -> Tree (c)
20:41:30 <jmcarthur> i have to go to bed. sorry for bailing, haskell_noob
20:41:54 <ab9rf> :t zipWith
20:41:54 <haskell_noob> jmcarthur: ok,thanks anyways
20:41:55 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
20:42:12 <ab9rf> fsef: would seem to be
20:42:23 <fsef> ab9rf: thankyou bro
20:44:02 <ab9rf> fsef: although i'm assuming that Tree is an Traversable of some sort
20:44:22 <ab9rf> i'm not sure what the minimum typeclass for zipWith to be meaningfule is
20:44:44 <fsef> here is the definition
20:44:52 <fsef> data Tree a = Node (Tree a) (Tree a) | Leaf a deriving Show
20:45:23 <ab9rf> fsef: yes, i'm generalizing
20:45:46 <ab9rf> fsef: Tree a can be made an instance of Traversable fairly easily
20:46:07 <fsef> would this be correct fsef?
20:46:11 <fsef> zipwith f (Leaf a) (Leaf b) = Leaf (a `f` b)
20:46:32 <fsef> for dealing with the leafs
20:46:37 <fsef> without children nodes
20:47:05 <ab9rf> in fact, Typeclassopedia uses Tree a as an example of a Traversable instance
20:48:59 <fsef> ab9rf: would this be suitable for dealing with just Leafs?  zipwith f (Leaf a) (Leaf b) = Leaf (a `f` b)
20:50:10 <andrewsw> fsef: try it and see!
20:50:43 <ab9rf> fsef: i suppose so.  hadn't really thought about it.
20:51:38 <ab9rf> i'm not at all sure what you do when you have leaf zipped with nonleaf
20:52:50 <haskell_noob> your supposed to repeat the leaf
20:52:56 <haskell_noob> value with the leaf
20:53:05 <ab9rf> haskell_noob: that is one option
20:53:34 <haskell_noob> ab9rf: yeah i think that was what our lecturer was going for
20:54:00 <ab9rf> haskell_noob: the problem with zip is when the structures are disanalogous
20:54:32 <haskell_noob> ab9rf: disanalogous, not the same structures?
20:54:44 <ab9rf> haskell_noob: where one treehas a leaf and the other doesn't
20:55:11 <haskell_noob> ab9rf: yeah i wrote somethin like zipTree (Leaf a)     (Node _ _)   = Leaf (a, a)
20:55:46 <haskell_noob> ab9rf: which seemed to just duplicate the leaf value where the problem occured
20:58:35 <andrewsw> haskell_noob: that maybe doesn't type check
20:59:04 <ab9rf> haskell_noob: hm, i would think you'd do a@(Leaf _) (Node b1 b2) = Node (zipTree a b1) (zipTree a b2)
20:59:41 <ab9rf> haskell_noob: that replciates the leaf against hte nonleaf cells of the other tree
20:59:48 <ab9rf> haskell_noob: instead of cutting off the tree at that point
21:01:21 <haskell_noob> ab9rf: good point haha
21:02:50 <ab9rf> i'm not really sure that the semantics make a whole lot of sense
21:02:54 <ab9rf> either wa
21:02:56 <ab9rf> y
21:03:12 <haskell_noob> ab9rf: yeah it still confuses me.
21:03:52 <haskell_noob> ab9rf: would u mind having a look at this problem? cant for the life of me figure out how to start http://hpaste.org/85009
21:05:04 <ab9rf> haskell_noob: what are you experiencing trouble with?
21:06:50 <haskell_noob> ab9rf: just have no idea how to change the datatype to allow variable, i tought something like |Char Expr, might do the trick but i dont think that will work
21:07:11 <ab9rf> you'll need to add constructors for Let and V obviously
21:07:30 <haskell_noob> ab9rf: apologies for the bad spelling :)
21:07:54 <ab9rf> you should be able t figure out what those are from the example on line 14
21:08:24 <ab9rf> that's the easy part, of course.  the hard part is writing evaluate :)
21:10:28 <haskell_noob> ab9rf: yeah i know, we havent been taught a whole lot..but from the example i can see that there is a Char "n" then another Expr (C 42) to assign it to the Char so i thought | Char Expr
21:10:43 <ab9rf> haskell_noob: String, not Char
21:11:11 <ab9rf> and you need the Let part too
21:11:27 <ab9rf> and there's a third component
21:11:52 <ab9rf> the let construct has three parts, the identifier, the value it's bound to, and then the expression that is evaluated with that binding in place
21:14:23 <haskell_noob> ab9rf: ok, so |String Expr | V String | Let ...would be along those lines?
21:15:06 <ab9rf> String Expr?
21:15:11 <ab9rf> that won't work
21:16:15 <haskell_noob> ab9rf: im really clueless...
21:17:56 <fsef> Could someone help with a zipwith function for trees?  I have the first part working; here is the code:
21:17:58 <hpaste> ddd pasted “zipwith” at http://hpaste.org/85012
21:33:01 * hackagebot hmemdb 0.1.0.2 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.1.0.2 (MiguelMitrofanov)
21:34:38 <fsef> fesf
21:35:12 <elliott> hi
21:35:24 <fsef> hello
21:35:27 <tgeeky> is there a #haskell-we-know-you-are-doing-your-homework channel?
21:36:13 <fsef> I want to join a #smashing-face-against-desk channel
21:36:26 <haskell_noob> ill join that
21:37:03 <fsef> anyone able to help me with my last question?
21:37:43 <simpson> fsef: Is this homework?
21:38:31 <fsef> simpson: Yep, I don't want the answer, just help understanding how to do this recursive part
21:38:59 <fsef> simpson: For when there are two childen of the node
21:39:06 <tgeeky> haskell_noob: how many weeks into your course are you?
21:39:46 <haskell_noob> tgeeky: like 5 or 6?
21:40:10 <simpson> fsef: Well, let's think about it. You're gonna call zipWith again, right?
21:40:36 <fsef> fsef: yep, I was thinking something like this:
21:40:38 <circle> what does this mean: "No instance for (Eq a) arising from a use of `=='"?
21:40:57 <fsef> let l = zipwith f (left `f` left2)
21:41:01 <fsef> r = zipwith f (right `f` right2)
21:41:07 <simpson> circle: It means that you used == on some polymorphic type `a` and didn't require `a` to be a member of Eq.
21:41:10 <ab9rf> circle: you used == with a value for which == doesn't mean anything
21:41:31 <simpson> fsef: And then something like l `f` r , right?
21:41:39 <fsef> simpson: yup
21:41:59 <simpson> Well, try it and see.
21:42:23 <ab9rf> :t (==)
21:42:24 <lambdabot> Eq a => a -> a -> Bool
21:43:52 <haskell_noob> tgeeky: any advice haha?
21:43:55 <fsef> simpson: Syntax error in expression (unexpected `;', possibly due to bad layout)
21:44:03 <fsef> simpson: hmmm
21:44:11 <ab9rf> fsef: don't use tabs :)
21:44:13 <feliperosa> hello :)
21:44:38 <fsef> here is what is the problem... don't see it =D
21:44:42 <fsef> zipwith f (Node left right) (Node left2 right2) =
21:44:46 <fsef> let l = zipwith f (left `f` left2)
21:44:50 <fsef> r = zipwith f (right `f` right2)
21:44:55 <fsef> in Node (l `f` r)
21:45:02 <ab9rf> fsef: your layout is wrog, and please use hpaste
21:45:15 <fsef> ok
21:46:25 <tgeeky> haskell_noob: I can only guess that you should make up for lost time, attend class more, etc. That you were surprised about what (type or data) constructors are, is surprising
21:46:37 <tgeeky> haskell_noob: this doesn't help you with this homework, of course
21:47:33 <ab9rf> ... study on your own using websites ...
21:47:51 <feliperosa> :t choice
21:47:52 <lambdabot> Not in scope: `choice'
21:47:54 <fsef> unification would give infinite type o.0
21:48:25 <feliperosa> is choice (the parsec combinator) the same as "try p1 <|> try p2 <|> ..." or "p1 <|> p2 <|> ..."?
21:48:34 <ab9rf> fsef: infinite types are fun
21:48:35 <elliott> feliperosa: the latter, I believe
21:48:42 <circle> replacing " xs == []" with "null xs" worked
21:48:45 <circle> I don't know why
21:48:47 <circle> sort of ridiculous
21:49:03 <elliott> circle: the latter doesn't require Eq on the elements
21:49:04 <ab9rf> circle: you should figre out why it worked
21:49:06 <fsef> ab9rf: Can't figure out what I am doing wrong *Bites nails and laughs hysterically*
21:49:13 <shachaf> Better yet: case xs of [] -> ...; ... -> ...
21:49:15 <ab9rf> fsef: hpaste already :)
21:49:19 <fsef> ok
21:49:31 <ab9rf> 'xs == []' is a fair bit stronger a statement than 'null xs'
21:49:37 <ab9rf> or just pattern matching xs against []
21:49:40 <hpaste> ddd pasted “zipwith” at http://hpaste.org/85013
21:50:58 <ab9rf> heh, infinite regress!
21:51:02 <haskell_noob> tgeeky: i attend every lecture haha, just crap at haskell, i should probably study more though
21:51:23 <feliperosa> elliott: Yeah, I guess that's right. Did some experiments here :).
21:51:33 <ab9rf> fsef: you're inside-out
21:51:37 <luite> does the current github cabal already support its own sandboxing? if so, is there a quick intro somehwere on how to use it?
21:51:53 <fsef> ab9rf: Oh that explains why my skin is so red...
21:52:02 <fsef> ab9rf: hahaha jk, sorry please explain
21:56:58 <fsef> ab9rf:  Any advice you can give mate?
21:58:22 <ab9rf> fsef: check the type of zipwith f (left `f` left2)
21:58:52 <fsef> ohhhh
21:58:58 <fsef> it is
21:59:54 <fsef> Doesn't match the correct type
22:00:03 <haskell_noob> lol
22:02:00 <haskell_noob> so far i got this
22:02:01 <haskell_noob> http://hpaste.org/85014
22:02:20 <haskell_noob> giving me a weird syntax error though (unexpected `=')
22:02:23 <fsef> and it works?
22:02:25 <fsef> ahh
22:06:22 <Cale> haskell_noob: Configure your text editor to convert tabs to spaces automatically
22:06:45 <haskell_noob> Cale: ok thank you will try
22:06:55 <Cale> haskell_noob: The problem is that the r in line 7 needs to line up with the l in line 6 to be part of the same let block
22:08:07 <Cale> Because it starts in a deeper column, line 7 as written is a continuation of the definition of l, and so the = seems out of place
22:08:34 <haskell_noob> Cale: its weird because in the text editor it lines up, but in hpaste it doesnt..
22:08:47 <Cale> That's because not every text editor treats tabs the same way
22:09:06 <Cale> The Haskell compiler will treat tabs as aligning to the next multiple of 8 spaces
22:09:32 <Cale> But really you shouldn't have any of them in your source files, because everyone's editor makes them look different.
22:09:47 <Cale> (and the alignment matters)
22:09:54 <haskell_noob> so u suggest using spaces instead of tabs?
22:10:07 <haskell_noob> so i can just use 8 spaces instead of tab
22:10:21 <Cale> yeah -- most editors have an option to store space characters and treat multiple spaces as if they were a tab
22:10:33 <Cale> If you're in vim, you'll want :set expandtab
22:10:58 <Cale> In emacs, it's (setq-default indent-tabs-mode nil)
22:11:38 <Cale> In gedit's preferences, there's "Insert spaces instead of tabs" on the Editor tab.
22:11:40 <hpaste> fsef pasted “zipwith” at http://hpaste.org/85015
22:11:42 <Cale> etc. etc.
22:11:49 <fsef> I think this is close
22:11:52 <fsef> Not sure why it is not working
22:12:30 <haskell_noob> Cale: well thank you very much for that ill see if i can get that working with sublime text :)
22:13:10 <Cale> fsef: Well, now the problem is that there's only one parameter to Node on the last line
22:13:37 <Cale> http://www.sublimetext.com/docs/2/indentation.html
22:13:43 <fsef> I see
22:16:11 <fsef> Cale: are you able to see if my logic is correct?
22:16:32 <Cale> There's also another type error: a `f` a won't work on the line with  zipwith f (Leaf a) (Node _ _), because a :: a, but f :: a -> b -> c, so the right hand parameter to f has the wrong type.
22:16:58 <Cale> There's nothing sensible that you can produce in this case, since you have no way to represent an empty tree.
22:17:07 <Cale> and there's no way to get a value of type c
22:17:55 <Cale> Well, I suppose you could recurse down, say, the left branch of the Node, looking for an element to combine.
22:18:26 <fsef> hmm
22:19:06 <Cale> But it depends on what you want the function to do
22:19:40 <fsef> This is a confusing question
22:19:57 <Cale> Is the tree type given?
22:20:07 <fsef> yep, Ill post the original question
22:20:53 <hpaste> fsef pasted “zipwith” at http://hpaste.org/85016
22:20:57 <newsham> http://www.reddit.com/r/mathgifs/comments/1bhxku/benoits_fractional_dimension/
22:22:03 <fsef> that is what he is asking
22:24:04 <haskell_noob> Cole: Yes thank you
22:27:39 <newsham> old king cale was a merry old soul
22:28:52 <dmj> > let maxAddOne = (+1) . max
22:28:54 <lambdabot>   not an expression: `let maxAddOne = (+1) . max'
22:29:15 <dmj> > maxAddOne = (+1) . max
22:29:16 <lambdabot>   <hint>:1:11: parse error on input `='
22:29:58 <dmj> :t (+1) . max
22:30:00 <lambdabot> (Num a, Ord a) => a -> a -> a
22:30:19 <dmj> (+1) . max $ 4 5
22:30:38 <dmj> > (+1) . max $ 4 5
22:30:40 <lambdabot>   *Exception: show: No overloading for function
22:31:35 <newsham> ?let maxAddOne = (+1) . max
22:31:37 <lambdabot>  Defined.
22:32:02 <shachaf> @let sum'n'max x y = (x + y, max x y)
22:32:04 <lambdabot>  Defined.
22:32:22 <dmj> > maxAddOne 4 5
22:32:24 <lambdabot>   6
22:41:21 <newsham> > \c -> (length . take 100 . takeWhile ((< 4.0) . magitude) . iterate (\x -> x + c)) 0 (0.5 :+ 0.5)
22:41:23 <lambdabot>   Not in scope: `magitude'
22:41:23 <lambdabot>  Perhaps you meant one of these:
22:41:23 <lambdabot>    `magnitude' (i...
22:41:30 <newsham> > \c -> (length . take 100 . takeWhile ((< 4.0) . magnitude) . iterate (\x -> x + c)) 0 (0.5 :+ 0.5)
22:41:31 <lambdabot>   Ambiguous occurrence `magnitude'
22:41:32 <lambdabot>  It could refer to either `Data.Complex.ma...
22:41:41 <newsham> > \c -> (length . take 100 . takeWhile ((< 4.0) . Data.Complex.magnitude) . iterate (\x -> x + c)) 0 (0.5 :+ 0.5)
22:41:43 <lambdabot>   The function `GHC.List.length
22:41:43 <lambdabot>                GHC.Base..
22:41:43 <lambdabot>                  GH...
22:42:07 <newsham> > (\c -> (length . take 100 . takeWhile ((< 4.0) . Data.Complex.magnitude) . iterate (\x -> x + c)) 0) (0.5 :+ 0.5)
22:42:08 <lambdabot>   6
22:42:29 <newsham> > (\c -> (length . take 100 . takeWhile ((< 4.0) . Data.Complex.magnitude) . iterate (\x -> x + c)) 0) (-0.5 :+ 0.5)
22:42:30 <lambdabot>   Precedence parsing error
22:42:31 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
22:42:38 <newsham> > (\c -> (length . take 100 . takeWhile ((< 4.0) . Data.Complex.magnitude) . iterate (\x -> x + c)) 0) ((0-0.5) :+ 0.5)
22:42:40 <lambdabot>   6
22:42:55 <newsham> > (\c -> (length . take 100 . takeWhile ((< 4.0) . Data.Complex.magnitude) . iterate (\x -> x + c)) 0) (0.5 :+ (0-0.5))
22:42:56 <lambdabot>   6
22:45:12 <Cale> fsef: Sorry, my internet connection died and I had to go fiddle with the cable modem a bit. Yeah, so this is somewhat ambiguous.
22:45:48 <Cale> fsef: You might just try what I said -- go searching for an element to combine the Leaf with recursively, either in the left or the right subtree.
22:46:36 <Cale> fsef: If I had to guess, this isn't the question that your prof probably meant to ask though.
22:47:20 <Cale> With a tree type like  data Tree a = Tip | Branch a (Tree a) (Tree a), it's much more obvious how to define an analogue of zip and zipWith.
22:49:16 <fsef> Cale:  Yeah I am really struggling
22:49:26 <fsef> Cale:  The zip works fine, I just ignore uneven trees
22:49:41 <fsef> Cale: Not going to do anymore than that, But I just can't get this zipwith to work
22:49:53 <Cale> Well, if you can zip, then you can zipwith
22:50:12 <fsef> Have a look at my zip
22:50:15 <Cale> Well, to be more precise: if you can zip, and you can map, then you can zipwith :)
22:50:38 <hpaste> fsef pasted “zipwith” at http://hpaste.org/85019
22:51:41 <Cale> So, you're just not handling the mismatched cases
22:51:47 <fsef> Yep
22:51:51 <Cale> Which I suppose is another way to go about it
22:51:58 <fsef> I don't think he would expect us to
22:52:03 <Cale> You could do the same with zipwith
22:52:28 <fsef> so just create a left and right node
22:52:36 <fsef> and recursively call zipwith
22:52:38 <Cale> The code for zipwith should be identical to the code for zip, except where you've replaced pair construction by the given function.
22:52:55 <fsef> I will show you what I have.
22:53:07 <Cale> The code for zipwith f should be identical to the code for zip, except where you've replaced pair construction by f. -- rather
22:53:23 <hpaste> fsef pasted “zipwith” at http://hpaste.org/85020
22:53:55 <Cale> Don't you just want Node l r at the end there?
22:54:15 <Cale> l and r are trees
22:54:22 <fsef> yeah
22:54:26 <Cale> not single values that you can apply f to
22:54:31 <fsef> I am not calling the `f` though
22:54:34 <fsef> on them
22:54:38 <sw2wolf> what's the best way to debug xmonad ?  Using ghci, you even cannot find an instance for Show (X ...) ?  (no response from #xmonad, so post it here)
22:54:39 <fsef> ohhh
22:54:45 <Cale> yes you are
22:55:13 <Cale> sw2wolf: X computations surely aren't showable.
22:55:40 <Cale> sw2wolf: X is like IO with some extra stuff
22:55:50 <sw2wolf> sure
22:55:52 <fsef> I can't figure out where I am suppose to apply f
22:56:28 <Cale> fsef: in the same place that you used (,) in the definition of zip
22:56:34 <Cale> to form a pair
22:57:33 <fsef> so when it reaches just leafs it will apply the function to each leaf in the tree
22:57:59 <Cale> It will apply the function to the values in corresponding leaves of the two trees
22:58:59 <fsef> ahh sorry I am being slow, still abit confused
22:59:08 <fsef> having problems with haskell of late
22:59:57 <fsef> getting an error on compile
23:27:04 <sw2wolf> surprising ! ghc-7.6.2 creates 2MB xmonad ! (ghc-7.4.1 creates 6MB xmonad)
23:28:17 <sw2wolf> In ghc-7.6.2, i used `$cabal install xmonad xmonad-contrib --enable-split-objs` !
23:30:03 <Licenser> sw2wolf executable size is proportional to ghc version, they're aiming to go down to 0 byte when aproaching infinite releases
23:30:17 <Licenser> actually reverse proprtional
23:31:10 <sw2wolf> what's "proportional to ghc version" ?
23:31:26 <Licenser> sw2wolf perhaps a bad translation from german :P
23:31:48 <Licenser> what I wanted to say that with every increasing release number the file size will slowly get towards zero
23:31:56 <shachaf> It's just a joke, mind you. Licenser is not being serious.
23:32:07 <Licenser> shachaf :.(
23:32:25 <sw2wolf> :)
23:32:58 <sw2wolf> doesnot ghc-7.6.x make a BIG progress in compiling tech. ?
23:33:00 * Licenser never is serious
23:34:17 <Licenser> also it was very quiet and I figured a bad answer is better then no answer :)
23:35:02 <Apes> Licenser: inversely proportional
23:35:34 <sw2wolf> From the `ghc --info`, both ghc-7.4.1 and ghc-7.6.2 use gcc which should be same ...
23:36:28 <Licenser> Apes thanks :)
23:36:40 <sw2wolf> Maybe it is "split-objs" makes such a big difference ?!
23:43:08 * hackagebot ghc-mod 1.12.4 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.12.4 (KazuYamamoto)
