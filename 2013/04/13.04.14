00:00:19 <applicative> right what do you want to define, like biggerColor node1 node2 = if color node1 > color node2 then node1 else node2 -- not too imaginative, that
00:03:12 <jamy> this example little confuse me. Why "if then else"? Why "color node1", "color node2"; i not define function "color"?
00:04:20 <applicative> you did define the function color when you wrote data Node = Node { color = Int, ...}
00:05:10 <applicative> one role of the field name is to give a function that 'accesses' the field, so in haskell it's just a function Node -> Int
00:05:31 <neutrino> hi!
00:05:35 <jamy> and this function is getter for property "color" of Node ? :)
00:05:42 <neutrino> has anyone here used atom?
00:06:06 <applicative> it is a little confusing, though strangely not to people who have become accustomed to records
00:06:48 <applicative> jamy: yes, it's a getter, here taking the form of a function, so you put it in front of the name of the node your getting the color from
00:08:01 <jamy> applicative: Thank you very much!!! And one more time: Why JS? Why not haskell?
00:08:11 <applicative> jamy:  but then it is used for setting, e.g. if you have a preexisting node, mynode, you 'update' it writing mynode {color = 15} then the angle is unaffected, but the color changes to 15, to speak that way
00:08:38 <applicative> jamy: i wasn't being serious just gloomy
00:08:56 <jamy> i see
00:10:56 <jamy> "but then it is used for setting" Settings??? State effects?
00:13:58 <jamy> applicative: "but then it is used for setting" Settings??? Side effects???
00:16:03 <lightquake> %dump
00:16:10 <lightquake> cszo… :<
00:20:58 <lightquake> 42 damage at once, though, ouch
00:25:10 <learning> hello?
00:25:20 <adnap> Hi
00:27:16 <learning> is haskell good for web development?
00:28:24 <mikeplus64> learning: sure, look at yesod, snap and happstack. they are relatively young (except happstack i guess) though
00:29:00 <adnap> I am learning Yesod right now
00:29:37 <mikeplus64> learning: http://www.yesodweb.com/book and http://happstack.com/docs/crashcourse/index.html are quite complete
00:29:44 <adnap> I don't have a lot of web development experience, but Yesod is pretty easy. However, the types in Yesod are a bit confusing.
00:29:44 <mikeplus64> or rather comprehensiev
00:30:09 <adnap> I used the Yesod book and the Yesod documentation on Hackage
00:30:42 <adnap> I guess what I really like about Haskell web development is Shakespearean templates
00:30:52 <adnap> Hamlet is pretty cool
00:31:12 <adnap> However, in general, I hate web development
00:31:18 * adnap laughs
00:31:27 <mikeplus64> learning: also http://snapframework.com/docs
00:31:47 <learning> i was planning to learn either django or rails, do you think i should skip those and go straight to yesod?
00:31:57 <adnap> This was useful for helping me decide to use Yesod: http://www.haskell.org/haskellwiki/Web/Frameworks
00:32:14 <adnap> It might help you choose
00:33:00 <adnap> Like, it says: "Snap is well-documented and has a test suite with a high level of code coverage, but it is early-stage software with still-evolving interfaces."
00:34:06 <adnap> learning: So, wouldn't that depend on whether you want to use Python, Ruby, or Haskell?
00:34:50 <learning> yes
00:34:57 <learning> im new at this
00:35:18 <adnap> Do you already have experience programming in all three languages?
00:35:53 <learning> no,
00:36:17 <learning> i was trying to learn a new language
00:36:18 <adnap> Well, if you are optimizing for hours of your life, I would choose the language you already know.
00:36:32 <learning> either ruby or python
00:36:46 <learning> but after looking into haskell
00:36:52 <adnap> I like Haskell better than Python or Ruby because it has a type system, and that allows the compiler to catch a lot of potential bugs
00:37:03 <`nand`> but maybe the time invested in learning a new language may pay off if you can work faster using that language
00:37:17 <latermuse> adnap: type system is juicy
00:37:43 <adnap> `nand`: Yeah, but doubtful for a single project.
00:38:17 <adnap> You could get through Learn You a Haskell in a few days I guess
00:38:34 <learning> do you think haskell will be suitable for the real world?
00:38:45 <adnap> What do you mean?
00:39:00 <mikeplus64> learning: yes, because i think it already is, and is already "in the real world"
00:39:05 <latermuse> I could read lyah in a day or two, but I doubt I could retain enough of that information to do much of anything with haskell
00:39:19 <latermuse> (speaking from a new-beginner pov)
00:39:26 <adnap> You could if you started working on something right after
00:39:30 <adnap> and referring back to it
00:39:40 <adnap> I guess you might forget monads you don't use
00:39:58 <adnap> But the point of reading it is to get enough understanding to use Haskell I think
00:40:38 <latermuse> i might be simple-minded, but it took me about a month of reading everything I could find about haskell before I had enough understanding to do anything significant with it
00:40:41 <learning> i want to build web apps, and django & rails have "success stories"
00:41:03 <latermuse> learning: i built this with haskell: http://www.shartnet.com
00:41:03 <jamy> learning: i heard yesod has wrong realization of session system, which save properties on client cookies
00:41:04 <learning> but i am interested in haskell as a language
00:41:25 <learning> i am trying to use haskell as much as possible
00:41:28 <mikeplus64> learning: i think a few places use yesod now, if anyone has "success stories", i'm sure that in #snapframework or #yesod or #happs, you'd be able to find them
00:41:29 <adnap> Haskell is faster than Python and Ruby on http://benchmarksgame.alioth.debian.org/
00:41:32 <`nand`> http://hdiff.luite.com/gloss/pong/ does this count?
00:41:34 <latermuse> learning: it was since defaced by the people who are managing it now, but it was built with haskell
00:41:54 <`nand`> I built this using Haskell (+ some assistance)
00:42:27 <latermuse> learning: I also built this with haskell: www.awaq.com
00:42:42 <adnap> Ew, Javascript
00:43:05 <latermuse> adnap: Yeah javascript. Its meant to be a phone app
00:43:06 <`nand`> but more importantly, Haskell
00:43:26 <mikeplus64> learning: also http://darcsden.com/ is written in haskell using snap or happstack (i forget which)
00:43:43 <`nand`> and http://hub.darcs.net
00:43:53 <`nand`> (darcsden is an older version of that)
00:43:56 <latermuse> learning: this was built with haskell (its pretty cool!) https://www.youtube.com/watch?v=Z2wzpyxsVSU
00:44:01 <mikeplus64> http://patch-tag.com/ is written using happstack
00:44:19 <`nand`> http://projects.haskell.org/diagrams/ this is built with haskell (the website)
00:44:53 <mikeplus64> learning: there are lots of hakyll sites i'm sure. hakyll is a static site generator though, not really a web app thing
00:44:55 <latermuse> im currently building an online shopping system (think shopify) with haskell
00:45:37 <learning> latermuse: is it hard to do that?
00:46:20 <mushi> hey
00:46:28 <mushi> can someone hlep me with advance world function
00:46:29 <mushi> http://www.ipaste.org/MAj
00:46:39 <mushi> i mean to somehow call accelerate and moveparticle
00:46:42 <learning> gtg, thank you, you guys have been helpful!!!!
00:47:27 <adnap> > Data.Traversable.sequence [Just 42, Nothing, Just 1]
00:47:30 <lambdabot>   Nothing
00:47:44 <latermuse> learning: the shopping system?
00:47:56 <latermuse> learning: its not hard, its fun.
00:48:22 <latermuse> learning: mixing php/javascript/html/css and writing haskell code that builds and maintains everything
00:48:41 <adnap> > Data.Traversable.sequence [[Just 42], [Nothing], [Just 1]]
00:48:43 <lambdabot>   [[Just 42,Nothing,Just 1]]
00:49:04 <adnap> Why the hell would you mix PHP and Haskell?
00:49:24 <adnap> You don't need PHP if you use a Haskell web framework
00:49:35 <latermuse> not using a framework
00:49:41 <adnap> Why not?
00:49:46 <latermuse> php so that the guys on my team who dont understand haskell can help
00:49:59 <adnap> Yuck
00:50:17 <adnap> I guess whatever gets the job done
00:50:20 <adnap> ...
00:50:53 <latermuse> I build the daemons and server-side systems in haskell
00:51:01 <latermuse> the other guys build the php/javascript front-end stuff
00:51:25 <adnap> PHP is not for front-end
00:51:45 <adnap> PHP runs server-side
00:52:08 <latermuse> I guess im not pure enough
00:52:13 <mikeplus64> i think he means like the "front end" of the server, adnap, not client side
00:52:15 <latermuse> I wouldnt have done well in nazi germany
00:52:31 <adnap> What does front-end of the server mean?
00:52:39 <adnap> I don't get it
00:53:02 <jamy> i don't get it too
00:53:15 <adnap> Like, you have some server-side request handling code in PHP and that's the front-end, and it invokes some daemons written in Haskell?
00:53:16 <mikeplus64> i suppose the part of the server directly responding to http requests? it could communicate with whatever latermuse's stuff is
00:53:19 <natnayr> when im using foldl, im ignoring first or the last items in the list... anyone know a manual recursive implementation likewise?
00:53:55 <jamy> haskell can build dsl which your other guys can teach and use
00:54:03 <adnap> natnayr: I barely understood you, but you could use init . tail
00:54:12 <adnap> > init . tail $ [1,2,3]
00:54:14 <lambdabot>   [2]
00:54:14 <latermuse> yeah, the php is the middle-man for communicating between the javascript front-end and the haskell stuff im building
00:54:23 <latermuse> maybe its not the best way to do it, but its the way my team does it
00:54:51 <adnap> It's ugly for sure
00:55:09 <adnap> But maybe saving time is better than beauty
00:55:19 <latermuse> my team also uses text files for our databases
00:55:24 * adnap laughs
00:55:25 <latermuse> *laugh*
00:55:37 <adnap> Well, maybe consider that you will lose time tracking down bugs
00:55:39 * jamy laughs
00:55:51 <latermuse> *shrug* some of our projects are over 15 years old, so theres not much that we can do to change stuff around
00:55:53 <adnap> And your users will lose time waiting for your program to run
00:56:06 <arkeet> init and tail are scary.
00:56:49 <mikeplus64> adnap: don't be fooled, we haskell programmers make plenty of errors, the type system can only go so far
00:57:15 <mikeplus64> latermuse: what role does the haskell stuff actually take then? though i guess it depends on the project
00:57:38 <adnap> I wonder if init and tail are O(1)
00:58:02 <adnap> I make less errors in Haskell than C++, which is the other language I use the most
00:58:06 <latermuse> mikeplus64: well for www.shartnet.com, we are streaming radio. I wrote the streaming server in haskell because we needed features that other streaming servers couldnt provide
00:58:56 <latermuse> mikeplus64: on awaq.com, a haskell daemon manages uploads and makes sure things run correctly
00:59:07 <adnap> It looks like tail is O(1) and init is O(n)!
00:59:24 <adnap> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#init
00:59:29 <jamy> latermuse: can you less detailed?
00:59:37 <leggo> adnap sure. it's a singly linked list
00:59:53 <latermuse> jamy: I could be less detailed, yes.
01:00:07 <mikeplus64> latermuse: neat
01:00:36 <jamy> "that other streaming servers couldnt provide" whats this meen?
01:00:49 <adnap> I wonder if you use a fold on a list after (init . tail) if GHC can optimize to one list iteration
01:01:15 <latermuse> jamy: we have a function that allows users to record themselves and it will play whatever they record on the streaming radio
01:01:28 <latermuse> jamy: its like calling into a radio station and talking, but anonymous and unmoderated. anyone can talk
01:01:43 <mikeplus64> adnap: try it out, someone put up a ghc core paste service recently
01:01:51 <adnap> mikeplus64: What is that?
01:02:03 <mikeplus64> adnap: http://core.alpmestan.com/ seems to be down though
01:02:10 <Kaidelong> the real important way to avoid making errors is not to write code at all but call it
01:02:26 <adnap> Oh, is GHC core the C code GHC generates?
01:02:38 <Kaidelong> haskell gives the advantage of not having arcane calling conventions and providing libraries that are relatively state free, but C++ has many more libraries
01:02:46 <mikeplus64> adnap: ghc doesn't generate C code
01:03:17 <adnap> mikeplus64: Really?!
01:03:18 <jamy> latermuse: what haskell streaming features doesn't has any other languages?
01:03:33 <Kaidelong> GHC core is a modified haskell that is again translated into something else, perhaps straight to machine instructions but it could also be made into C, C--, or LLVM instructions
01:03:48 <latermuse> jamy: Please rephrase that question. I dont understand.
01:03:53 <adnap> Okay
01:04:20 <Kaidelong> the answer is probably "none" regardless
01:04:22 <adnap> I don't know how to make GHC output core...
01:05:23 <jamy> latermuse: "because we needed features that other streaming servers couldnt provide" - what features?
01:05:27 <mikeplus64> adnap: ghc -ddump-simpl
01:05:35 <mikeplus64> adnap: also see the ghc-core tool
01:05:49 <latermuse> jamy: I just told you. We needed the ability for our listeners to call in unmoderated and have their voice automatically played on the radio
01:06:07 <Kaidelong> but that's not a *haskell* feature
01:06:09 <latermuse> jamy: It was quite trivial to implement using lazy bytestrings in haskell
01:06:12 <Kaidelong> to be clear
01:07:49 <latermuse> Our streaming server needed features that other streaming servers didnt have. I chose to write it in haskell, because the lazy bytestrings are easy to use, and because haskell is very stable overall.
01:08:16 <jamy> thats all?
01:08:41 <latermuse> jamy: yeah. im not doing super academic work with haskell. just every day programming
01:09:04 <adnap> It looks like -ddump-simple prints the core to standard out
01:09:22 <mikeplus64> yup
01:09:31 <jamy> and your boss accepting using bad known lang?
01:10:01 <latermuse> jamy: what is bad known lang?
01:10:21 <jamy> haskell
01:10:22 <latermuse> jamy: are you talking about haskell's relative obscurity?
01:10:36 <latermuse> jamy: yeah, boss doesnt care
01:10:42 <mikeplus64> latermuse: i think he means php
01:10:50 <mikeplus64> oh derp
01:10:54 <mikeplus64> uh ignore that
01:10:57 <mikeplus64> lol
01:10:59 <latermuse> hehe :)
01:11:16 <jamy> lucky! :) My boss don't accept event JS on server-side
01:11:35 <jamy> *even
01:11:44 <latermuse> jamy: Im not using javascript on the server-side
01:12:11 <`nand`> no sane person would accept JS anywhere
01:12:24 <latermuse> firefox's gui is made with javascript
01:12:40 <`nand`> maybe that's why it's so horribly slow and bulky
01:12:59 <hpaste> adnap pasted “core test” at http://hpaste.org/85752
01:13:01 <latermuse> its not slow or bulky on my computer
01:13:44 <`nand`> well it's not like I'm running it on a zeno machine or anything
01:14:11 <latermuse> im using a year-old macbook air, and it runs snappily even with a bunch of other processes open
01:14:34 <adnap> From the core, it looks like init and tail are still being called and then foldl1, so I guess there's no optimization
01:14:39 <adnap> Unless it happens after core
01:15:34 <jamy> I say he even not accept js on server-side because it is little known
01:16:06 <latermuse> jamy: node.js is server-side and is pretty well known
01:16:12 <latermuse> jamy: http://nodejs.org/
01:16:35 <jamy> less than PHP
01:17:02 <adnap> Who cares how well-known something is? That shouldn't be a factor
01:17:03 <mikeplus64> adnap: compile with -O2
01:17:21 <adnap> Unless your team doesn't know the language I guess
01:17:22 <mikeplus64> you've got no optimisations there i think
01:17:27 <adnap> Oh, okay
01:17:32 <mikeplus64> seeing as though $ and . aren't even inlined
01:17:35 <jamy> In my city can hire php man for 500 $ /moth
01:17:42 <mikeplus64> (which is baaaaaaaaaaaaaaaaad imo)
01:17:44 <latermuse> jamy: what city?
01:18:08 <jamy> Donetsk in Ukraine
01:18:53 <hpaste> adnap pasted “core test -O2” at http://hpaste.org/85753
01:19:04 <adnap> The core is very ugly now
01:19:19 <shachaf> adnap: Try adding -dsuppress-all
01:19:23 <shachaf> It makes it much more readable.
01:19:42 <mikeplus64> (if you're using ghc-core)
01:19:51 <shachaf> Or if you're not.
01:19:56 <shachaf> -dsuppress-all is a GHC option.
01:20:05 <mikeplus64> oh, the more i know
01:20:19 <shachaf> I need to get around to making ghc-core nicer.
01:20:23 <jamy> And Js man (even frontend) can hire > 700 / month
01:20:47 <hpaste> adnap pasted “core test -O2 2” at http://hpaste.org/85754
01:21:11 <shachaf> Now isn't that better?
01:21:16 <adnap> Yes
01:21:36 <adnap> omg
01:21:40 <adnap> it optimized!
01:21:47 <adnap> "fold2"
01:21:51 <adnap> :t fold2
01:21:52 <lambdabot>     Not in scope: `fold2'
01:21:53 <lambdabot>     Perhaps you meant one of these:
01:21:53 <lambdabot>       `foldr' (imported from Data.List),
01:23:20 <adnap> Wait, not I'm not sure
01:23:25 <adnap> I don't understand this core
01:23:26 <mikeplus64> adnap: not sure where it gets foldl2 from
01:23:39 <adnap> :t foldl2
01:23:40 <lambdabot>     Not in scope: `foldl2'
01:23:40 <lambdabot>     Perhaps you meant one of these:
01:23:40 <lambdabot>       `foldl1' (imported from Data.List),
01:23:50 <shachaf> foldl2 is probably a helper function GHC defined for foldl.
01:23:52 <shachaf> @src foldl
01:23:52 <lambdabot> foldl f z []     = z
01:23:53 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:23:59 <shachaf> Is that the real definition?
01:24:09 <Cale> The @src almost never gives the real definition of anything
01:24:17 <shachaf> I know.
01:24:20 <adnap> I was guessing maybe foldl2 skips an element of the list
01:24:26 <mikeplus64> shachaf: i guess since it's foldl1, foldl2 maybe is the error clause?
01:24:30 <adnap> Which would suggest an optimization
01:24:41 <mikeplus64> same as init2/tail1 maybe?
01:24:45 <shachaf> Oh, the original code is a foldl1.
01:25:06 <shachaf> What's the question here, anyway?
01:25:18 <adnap> If the code iterates through the list more than once
01:25:28 <Cale> What's the original program?
01:25:31 <adnap> Since init is O(n) and foldl1 is O(n)
01:25:42 <adnap> Cale: It's at the top of the paste
01:25:51 <jamy> Even if i say him what i can realize all project on node.js for self, he desagrees because scary what i move on other job and he than can't support project with less budget
01:25:52 <adnap> > putStrLn . show . foldl1 (+) . init . tail $ [2..10]
01:25:53 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
01:25:53 <lambdabot>    arising from a use of ...
01:26:07 <shachaf> adnap: That sort of depends on what you mean by "iterates more than once".
01:26:21 <shachaf> I mean, it won't go all the way to the end of the list once, and then do it again.
01:26:28 <adnap> Oh, okay
01:26:31 <adnap> That's what I want to know
01:26:34 <latermuse> jamy: thats good business. if node.js programmers are few in your country
01:26:38 <shachaf> Because that changes semantics (what if the list is infinite?).
01:26:53 <shachaf> But it might go back and forth between the init and the foldl1, coroutine-style.
01:26:59 <adnap> If the list is infinite, the result can't be computed
01:27:09 <shachaf> I.e. "do twice as much work" per node. Except not really that.
01:27:16 <jamy> :) I know each personally :)
01:27:20 <adnap> I don't understand your argument
01:27:34 <shachaf> adnap: Right, that's true in this case. But in general it might not be.
01:27:44 <shachaf> adnap: Imagine this: init xs !! n
01:27:54 <adnap> Okay...
01:28:06 <shachaf> Does that traverse the list twice?
01:28:16 <adnap> If the list is infinite, I imagine the code for init may never stop before the code for !! is run
01:28:17 <shachaf> The question here is what "traverse the list twice" means.
01:28:29 <hpaste> Cale annotated “core test” with “core test (annotation)” at http://hpaste.org/85752#a85755
01:28:48 <Cale> -ddump-simpl-stats is also nice to look at
01:28:51 <adnap> shachaf: Push each element on the stack more than once
01:28:58 <shachaf> OK, then your imagination is inconsistent with the semantics of Haskell, I think.
01:29:49 <adnap> I don't understand your argument because I don't understand the "semantics of Haskell"
01:29:57 <Cale> > init [1..]
01:29:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:30:27 <shachaf> adnap: Because (init [1..] !! 1000) is not _|_, it's a number.
01:30:27 <Cale> > init [1..] !! 100
01:30:29 <lambdabot>   101
01:30:33 <jamy> But hundreds of php people
01:30:48 <adnap> Okay...
01:31:42 <shachaf> adnap: OK, you should understand this "semantics of Haskell" business. It'll help a lot. :-)
01:32:07 <adnap> How? What do you even mean by that phrase?
01:32:18 <arkeet> "what do expressions mean"
01:32:33 <adnap> What does "mean" mean?
01:33:05 <jamy> mean mean mean
01:33:09 <adnap> Like, "how does the function get computed"?
01:33:15 <shachaf> No, not "how".
01:33:28 <shachaf> There are as many ways to compute it.
01:33:39 <jamy> like what semantic of function?
01:33:41 <shachaf> The question is "what".
01:33:49 <adnap> Will you not be so mysterious?
01:33:58 <shachaf> I'm sorry.
01:34:42 <jamy> latermuse: But hundreds of php people
01:34:44 <Cale> I found foldr2...
01:34:56 <Cale> I'm going to grab the GHC sources to search for foldl2 properly
01:35:17 <latermuse> jamy: thats why your boss doesnt do it. its too expensive to hire node.js people, and there isnt a big enough economic benefit to outweigh the costs of hiring
01:35:18 <shachaf> Cale: I don't think foldl2 exists anywhere.
01:35:19 <danr> Cale: in compilers/utils/Util.lhs
01:35:30 <danr> compiler/utils/Util.lhs:foldl2 :: (acc -> a -> b -> acc) -> acc -> [a] -> [b] -> acc
01:35:39 <shachaf> Hmm, I don't think that's the function being discussed here.
01:35:46 <shachaf> That's in GHC source itself, not in compiled code.
01:35:47 <adnap> I am so unsatisfied :/
01:36:18 <arkeet> adnap: e.g. does an expression represent a terminating value or not?
01:36:21 <danr> shachaf: yeah, Cale just suggested to search for it in the GHC sources
01:36:33 <adnap> I thought I had a question and now I think my question wasn't specific enough, but I don't know how to rephrase it because I don't know anything anymore or something
01:36:44 <shachaf> Look at http://hpaste.org/85753 -- foldl2 is in Data.List
01:36:55 <shachaf> It's being generated during compilation of foldl1.
01:37:10 <adnap> arkeet: I don't know
01:37:14 <shachaf> adnap: It's OK. Ideally you'll learn something important from all this. :-)
01:37:34 <arkeet> this is one of the things that can be answered by talking about denotational semantics.
01:37:34 <adnap> I don't want the Socratic method. I just want someone to tell me what I don't know that they know
01:37:41 <adnap> Or link it to me
01:37:46 <jamy> latermuse: so Haskell does not specify
01:37:54 <shachaf> I'm sorry. I don't know where to link.
01:38:01 <arkeet> "denotational semantics" is a keyword you can start looking up
01:38:13 <arkeet> in combination with "haskell" perhaps
01:38:29 <shachaf> Yes, but you might find a lot of things that'll leave you even more confused.
01:38:34 <shachaf> Or not. I don't know.
01:38:35 <arkeet> maybe
01:38:52 <Ralith> the Mysterious Shachaf
01:38:53 <`nand`> maybe the answer is “nobody knows, we're all stuck arguing about semantics”
01:39:04 <shachaf> `nand`: If we don't have semantics, what do we have?
01:39:04 <adnap> I just want to know if there is a factor of 2 speedup when using -O2 on the code vs not using it
01:39:14 <Ralith> syntatics
01:39:14 <shachaf> adnap: Oh. Well, you can measure that with a benchmark.
01:39:16 <Ralith> obviously
01:39:19 <Cale> shachaf: weird, I'm not seeing it defined anywhere in base, but the compiled code of many modules contains it
01:39:22 <`nand`> Ralith: oh boy..
01:39:24 <shachaf> adnap: But the answer won't satisfy you.
01:39:31 <arkeet> denotational semantics says nothing about how long a computation will take.
01:39:36 <shachaf> Cale: Yes -- like I said, it's being generated during compilation of foldl1.
01:39:45 <`nand`> shachaf: maybe we need to invent the appropriate semantics to describe the semantics we want to describe
01:39:53 <shachaf> Cale: It's probably what mikeplus64 said.
01:39:58 <shachaf> http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/Data-List.html#foldl1
01:39:58 <Cale> That does seem like a real possibility
01:40:20 <Ralith> adnap: if you want to know if there's a factor of 2 speedup, why not benchmark it and find out?
01:40:26 <shachaf> I.e. foldl2 = errorEmptyList "foldl1"
01:40:38 <shachaf> Just like main1 etc. in that very program.
01:40:53 <adnap> Maybe I will. I thought someone could just read core and tell me, or I could read core and figure it out
01:41:15 <shachaf> adnap: Yes, but first you need to understand how Haskell is evaluated.
01:41:22 <adnap> I guess "denotational semantics" is a map from Haskell code to math
01:41:31 <Cale> shachaf: yes, it has to be that
01:41:34 <adnap> According to https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
01:41:34 <shachaf> adnap: And in order to understand *how* you probably need to understand *what*.
01:41:37 <`nand`> it's a map from haskell code to ‘meaning’
01:41:40 <Cale> shachaf: since whatever it is, it's the error case
01:41:46 <shachaf> Cale: Yep.
01:41:51 <`nand`> through math, probably
01:42:04 <adnap> I understand C. I just need to look at the generated C code
01:42:12 <arkeet> what C code?
01:42:23 <neutrino> the c code haskell compiles down to *grin*
01:42:26 <Cale> GHC doesn't produce C code
01:42:34 <adnap> Ugh, why are people saying that
01:42:37 <Cale> at least, not by default
01:42:39 <arkeet> because it's true.
01:42:45 <Cale> Because it has a native code generator
01:42:53 * jamy would find job on Haskell
01:43:02 <adnap> Well, I guess I was mislead
01:43:04 <`nand`> GHC compiles down to x86, primarily
01:43:12 <`nand`> adnap: GHC used to have a C generating backend a while ago but it was removed
01:43:30 <Cale> and the C code which it generated back when it compiled via C wasn't real C code that would run, but stuff which would be passed to gcc and then the output would be mangled together into something which would actually work
01:43:37 <shachaf> adnap: I've read a fair amount of GHC-generated assembly code. It's reasonably close to a much more confusing version of the Core.
01:43:52 <neutrino> trying to understand haskell by studying low-level intermediate language output is like trying to understand human psychology by analyzing footsteps. it's possible but not the very best idea.
01:43:56 <shachaf> adnap: It's not the kind of assembly (or, when it generated C, the kind of C) that you would write.
01:44:09 <arkeet> you could try reading the cmm
01:44:13 <therp> neutrino: :)
01:44:14 <adnap> Maybe it would be easier to understand the semantics of a bit of assembly than the semantics of Haskell
01:44:29 <arkeet> which semantics?
01:44:34 <Cale> adnap: -ddump-asm
01:44:34 <shachaf> Cmm is better than assembly but it's not going to help you when you don't understand Core.
01:44:41 <therp> neutrino: human psychology:footsteps = higher-level-code:gc-trace
01:44:41 <`nand`> hmm
01:44:43 <neutrino> adnap: suggest not doing that.
01:44:49 <`nand`> “a compiler is a semantics-preserving map between languages”
01:44:55 <`nand`> good definition?
01:45:00 <neutrino> therp: i've never had to work with gc traces.
01:45:07 <neutrino> `nand`: no
01:45:17 <adnap> Well, I guess I'm using "semantics" wrong if `nand` is right
01:45:20 <therp> me neither, nor footsteps.
01:45:29 <neutrino> meaning-preserving, maybe. semantics.. definitely wrong
01:45:47 <adnap> I know what it means to put a value in a register, to increment the IP, etc.
01:46:01 <neutrino> haskell has nothing to do with this
01:46:08 <neutrino> learn haskell the way it's meant to be learnt
01:46:09 <adnap> No, but my program does
01:46:15 <neutrino> no, no it doesn't
01:46:23 <hpaste> Cale annotated “core test -O2 2” with “core test -O2 2 (annotation)” at http://hpaste.org/85754#a85756
01:46:36 <neutrino> you've just come up with some contrived way of looking at things and think that because it's unique it gives you something special
01:46:45 <neutrino> newsflash: there isn't gold at the end of every rainbow
01:47:11 <neutrino> most things are not done because they're not worth doing
01:47:12 <adnap> I don't understand your metaphors or why you are using "you"
01:47:14 <neutrino> you've just found one of them
01:47:30 <shachaf> neutrino: You're not helping. Please stop.
01:47:50 <neutrino> shachaf: leave me alone.
01:48:03 <Cale> This conversation is getting out of hand
01:48:06 <adnap> I guess I don't understand precisely what I mean by "iterate through the list". I am imagining a for loop vs two for loops
01:48:16 <Cale> Let's just try to figure out what it is that adnap wants to know and tell him that :)
01:48:36 <shachaf> adnap: OK.
01:48:51 <neutrino> adnap: if you iterate through the list, you take one element, do something with it, and then take another element, do something with it, and so on, until you run out of elements
01:48:57 <Cale> adnap: An easy way to understand how Haskell programs work (albeit slightly deficient for understanding the finest details of performance), is by expression rewriting.
01:48:58 <shachaf> adnap: The way it works in Haskell is a bit closer to switching between coroutines, if you're familiar with that.
01:49:09 <adnap> shachaf: I'm not
01:49:15 <shachaf> OK.
01:49:26 <adnap> I saw the source code for init
01:49:33 <`nand`> expression rewriting is likely a good way to look at it
01:49:36 <adnap> It recursively calls init on the rest of the list
01:49:40 <Cale> Let's look at a simple unoptimised example of how this program might run
01:49:43 <shachaf> The main point is that it's very different from what you imagine. :-)
01:49:59 <neutrino> adnap: so if you were to write this, you'd go: iterateOverList [] = [] (if you have nothing to iterate over, you have nothing to return); and: iterateOverList x:xs = (doSomethingWith x):(iterateOverList xs)
01:50:00 <Cale> excluding show and IO because blah, that's too annoying to write out :)
01:50:01 <shachaf> OK, I will go and let Cale do his thing and hope for the best.
01:50:04 <adnap> shachaf: Okay mystery man
01:50:06 <`nand`> adnap: haskell isn't strict, the recursive call may not ever be evaluated until it needs to
01:50:08 * shachaf sighs.
01:50:40 <Cale> okay
01:50:43 <adnap> neutrino: Yeah, that's what the source for init is like
01:50:44 <Cale> @src foldl1
01:50:44 <lambdabot> foldl1 f (x:xs) = foldl f x xs
01:50:44 <lambdabot> foldl1 _ []     = undefined
01:50:49 <adnap> @src init
01:50:49 <lambdabot> init [x]    = []
01:50:49 <lambdabot> init (x:xs) = x : init xs
01:50:49 <lambdabot> init []     = undefined
01:50:55 <Cale> @src tail
01:50:56 <lambdabot> tail (_:xs) = xs
01:50:56 <lambdabot> tail []     = undefined
01:51:15 <jamy> at least not doing super academic work with haskell. just every day programming
01:51:33 <Cale> Okay, so simplifying things a bit, let's start from  foldl1 (+) (init (tail [2..10]))
01:51:37 <jamy> its a good
01:51:44 <Cale> foldl1 gets to run first
01:51:51 <adnap> @src foldl
01:51:51 <lambdabot> foldl f z []     = z
01:51:51 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:51:58 <neutrino> adnap: kinda-sorta. not exactly. notice that init has an extra case (init [x]) which changes its behaviour in a strong manner. you're not iterating anymore, now you're accumulating rather than iterating.
01:52:06 <Cale> f matches (+), but the second argument, (init (tail [2..10]))
01:52:11 <Cale> is not in the form (x:xs)
01:52:32 <Cale> in fact, it's not a constructor applied to some arguments, so we need to evaluate it in order to pattern match
01:52:47 <adnap> Okay 2:[3,4,5,6,7,8,9,10]
01:52:52 <Cale> So this pattern match waits on the stack
01:52:59 <Cale> and we evaluate (init (tail [2..10]))
01:53:20 <Cale> init now needs to pattern match on (tail [2..10]) which again is not a constructor application
01:53:44 <shanks_> hi all
01:53:49 <neutrino> adnap: when you're iterating, you normally mean that you're accumulating results of some function on *each* element of the list you're iterating over. notice that in "init" you are not accumulating data resultant from *each* element, because you drop the last one. that's a different kind of accumulation, and therefore it isn't iteration in my book.
01:53:53 <Cale> so that goes on the stack and we evaluate (tail [2..10]), and again tail needs to pattern match and again [2..10] is not a constructor application
01:54:45 <Cale> So tail's pattern match goes on the stack and we evaluate [2..10] = enumFromTo 2 10... maybe we could step inside this code, but let's just say it evaluates to 2 : [3..10]
01:55:24 <Cale> now tail pattern matches that against (_:xs), which succeeds, matching xs with [3..10], and that's the result of tail
01:56:31 <Cale> now init is matching on that result, and it first needs to know if [3..10] matches its patterns, but [3..10] again isn't a constructor application, so it gets evaluated
01:56:55 <adnap> init (3:[4..10]) = 3 : init [4..10]
01:57:23 <Cale> and, if we're being really picky, it needs to be evaluated even again, before the [x] case can be excluded
01:57:30 <Cale> because what if [4..10] is []?
01:58:10 <`nand`> [x] is the first pattern after all, they get checked in that given order
01:58:13 <Cale> yes
01:58:19 <arkeet> [x] is a synonym for x:[]
01:58:27 <adnap> So, are we going to have ~n calls of init and ~n calls of foldl, or ~n calls of some function that does both?
02:00:14 <Cale> but eventually (x:xs) matches against (3 : (4 : [5..10])), with x matching 3 and xs matching (4 : [5..10]), and the result of init [3..10] is  3 : (init (4 : [5..10]))
02:00:19 <`nand`> I don't see any ‘function that does both’ in the source code; so why should there be one? In the evaluation mechanism Cale just described you would need to evaluate the result of something that looks like ‘tail ...’ and ‘foldl ...’ each about ~n times
02:00:34 <Cale> and then foldl1 can match
02:00:53 <`nand`> err
02:00:55 <`nand`> s/tail/init/
02:01:09 <Cale> foldl1 (+) (3 : (init (4 : [5..10]))) -> foldl (+) 3 (init (4 : [5..10]))
02:01:20 <adnap> So, I can image a function like fold that just ignores the first and last elements of the list
02:01:32 <`nand`> you could write a function like that, but this is not it
02:01:33 <adnap> *imagine
02:01:39 <Cale> the init will keep doing work as things go along
02:01:45 <Cale> but that work will not happen all at once
02:01:46 <adnap> So, I was imagining GHC could do that
02:01:57 <Cale> It will stick a call to init into its result which will be consumed by the fold
02:02:10 <Cale> This is the *unoptimised* version :)
02:02:28 <adnap> Yeah, but my original question was whether GHC optimizes
02:02:33 <`nand`> actually the implementation would be easy: myFoldlWhichIgnoresEnds f z = foldl f z . init . tail
02:03:24 <`nand`> GHC does something called list fusion, which as far as I'm aware prevents the unnecessary construction and immediate deconstruction of cons cells
02:04:44 <adnap> Cale: Okay, thanks
02:05:05 <Cale> adnap: So in the compiled and optimised version, the init is still there in some form
02:05:15 <adnap> Cale: I think I understand why my question didn't make sense now
02:05:30 <Cale> adnap: yeah, it's not easy to distinguish two separate passes here
02:05:35 <adnap> It looks like foldl and init progress concurrently on the list
02:05:40 <Cale> yes
02:06:10 <mjrosenb> well, interleaved most likely.
02:06:16 <shachaf> But that's true even in the unoptimized version.
02:06:22 <adnap> I think I annoyed shachaf by being impatient
02:06:27 <lightquake> suppose i have some type Foo a b, and it happens that Foo is a monad when parameterized over a, but not b. is there a way for me to define that monad instance? (yes, I know I should just swap the parameter order.)
02:06:58 <shachaf> adnap: My feeling was that you don't want your worldview changed. Unfortunately the way Haskell is evaluated doesn't fit easily into your existing worldview.
02:07:03 <Cale> lightquake: You could make a newtype
02:07:08 <Cale> lightquake: But other than that, no
02:07:13 <`nand`> the evaluation of haskell isn't very similar to the evaluation of an imperative state machine
02:07:18 <arkeet> notice that you're not holding onto a reference to the part of the list you've already processed, so the gc will clean that up for you. so that foldl of init or whatever will run in constant space (assuming the accumulator is constant size)
02:07:22 <arkeet> err
02:07:23 <lightquake> that's what i thought
02:07:25 <shachaf> I consider worldview-changes to be one of the more valuable aspects of learning Haskell (or most anything), so it seems backwards to me.
02:07:31 <adnap> shachaf: That's not true. I just don't like hearing "your worldview is wrong" with no explanation
02:07:38 <arkeet> (which won't happen because you're using foldl, not foldl')
02:07:53 <`nand`> pattern matching and the subsequent forced evaluation until you get to the constructor application is at the very heart of how Haskell runs
02:08:07 <adnap> And that's not to say I was convinced my worldview was right. I was only frustrated that I couldn't know why
02:08:09 <shachaf> adnap: I was saying "there is no short easy answer". The answer that will really answer your question is longer.
02:08:35 <adnap> I think Cale answered my question
02:09:00 <shachaf> adnap: What's the answer?
02:09:08 <Cale> adnap: When this goes on in memory, it's a big graph of pointers which gets rewritten.
02:09:18 <Cale> (pointers to code, mostly)
02:09:27 <`nand`> one could say running Haskell code pulsates between a pattern forcing you to go down into an expression and a constructor going back up into the pattern
02:09:40 <adnap> shachaf: That init and foldl get evaluated concurrently
02:09:51 <shachaf> adnap: And that this has nothing to do with optimization?
02:10:16 <adnap> Well, I guess the way I was imagining an optimization would happen is different than how it could happen
02:10:26 <shachaf> Right.
02:10:38 <Cale> Each expression is represented by a pointer to code which when entered will compute the value of the expression up to determining the topmost constructor, and return it, but before it returns this value, it rewrites the code pointer to point at a shorter piece of code which just returns the result immediately next time.
02:11:03 <arkeet> that's the model, anyway.
02:11:36 <shachaf> That's *a* model.
02:11:38 <`nand`> that's *one* model
02:11:40 <`nand`> blah
02:11:44 <arkeet> whatever.
02:11:56 <shachaf> But you could have a very different non-STG way of evaluating Haskell and all of this would still apply.
02:12:27 <mauke> .oO( ... and eval )
02:12:28 <arkeet> where was that article that showed how graph reduction worked.
02:12:29 <`nand`> but I think for gaining intuition this is a very reasonable approach to go by; sure, there may be other approaches, but one new perspective alone will help you understand how haskell programmers think
02:12:43 <adnap> Cale: What does "determining the topmost constructor" mean?
02:12:53 <adnap> Cale: Can you give an example?
02:12:59 <mauke> imagine a tree
02:13:10 <arkeet> it evaluates the list far enough to tell whether it's a [] or a _:_
02:13:11 <mauke> when you walk down from the root, you hit a first node. that one
02:13:14 <`nand`> adnap: like in the evaluation of [2..10] you had to go down until you got to ‘2 : [3..10]’, better rewritten in this case as ‘(:) 2 [3..10]’ <- (:) is the constructor
02:13:22 <Cale> I mean, reducing the expression into the form  C x1 x2 ... xn, where x1,...,xn are arbitrary expressions, and C is a data constructor
02:13:33 <Cale> (or a lambda)
02:13:36 <`nand`> eg. in data Maybe a = Nothing | Just a; ‘Just’ and ‘Nothing’ are the constructors. If something returns Just [1,2,3] then ‘Just’ is the outermost constructor
02:13:59 <Cale> This is the minimum amount of work required to match a simple pattern
02:14:06 <`nand`> the full form would be Just ((:) 1 ((:) 2 ((:) 3 []))) <- Just, (:) and [] are all constructors here
02:14:33 <`nand`> and technically, ‘1’ and ‘2’ and ‘3’ are too
02:14:38 <`nand`> or something like that
02:14:47 <adnap> I'm still don't really understand your "Each expression..." sentence
02:14:52 <mauke> I# 1 :-)
02:15:02 <`nand`> mauke: not part of Haskell!
02:15:04 <Cale> an expression which is either a constructor applied to any arguments, or a lambda is said to be in weak head normal form.
02:15:04 <`nand`> ..I think
02:15:07 <adnap> I keep reading it...
02:15:15 <shachaf> mauke: I# 1#
02:15:25 <mushi> hi
02:15:25 <arkeet> I# <magic>
02:15:26 <mauke> shachaf++#
02:15:30 <ion> mauke#: I# 1#
02:15:33 <mushi> can someone help with my http://www.ipaste.org/OAj advance world
02:15:54 <Cale> and when we evaluate an expression, it's always to weak head normal form first, and then patterns will be matched (you only evaluate something because a case is matching on it in core)
02:16:20 <`nand`> Integer is sort of built into the Haskell language; it's a bit special in that there's no clear representable constructor and no real representable pattern, but special forms of constructing/matching both (that happen to work for other Num instances too)
02:16:36 <`nand`> but for all intents and purposes, ‘1’ is a constructor and a pattern for Integer
02:17:15 <Cale> Internally though, you might actually find out that Integer has two possible constructors called S# and J#
02:17:28 <adnap> So...
02:17:41 <adnap> foldl (+) 3 (init (4 : [5..10])) and pointers to code for each expression
02:17:55 <adnap> I'm still trying to imagine
02:17:58 <Cale> S# being for Integer values which are small enough to fit in an Int, and J# holding a ByteArray with the GMP representation of the big integer
02:18:17 <ion> What does the “J” stand for?
02:18:23 <mauke> Jnteger
02:18:34 <ion> Jumbo?
02:18:35 <Cale> Jnteger is probably right ;)
02:18:43 <Cale> ooh, Jumbo is good :)
02:18:51 <shachaf> ion: Probably Jnteger, yes. As in "the letter after I".
02:19:00 <shachaf> Since I is taken.
02:19:08 <Cale> adnap: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
02:19:13 <ion> shachaf: That makes sense, especially given that S is the letter before I.
02:19:35 <Cale> This is technically a different language, but it's a similar functional programming language, but one which makes its graph representation of expressions explicit at runtime :)
02:19:38 <adnap> Oh, I've seen this before!
02:19:57 <adnap> I wish I could pause it
02:20:09 <shachaf> You can pause it!
02:20:13 <Cale> You can in the real program which is sadly not available for some reason
02:20:16 <`nand`> S being Small would make sense
02:20:17 <shachaf> http://slbkbs.org/jsgif/
02:20:27 <adnap> Good idea
02:21:16 <adnap> Hey! You made this
02:22:16 <arkeet> shachaf: I don't know which is more horrible, that or your puns.
02:22:22 <shachaf> arkeet: ?
02:22:40 <shachaf> arkeet: I'm sorry for writing an inefficient LZW decoder! I did most of it on an airplane.
02:22:44 <ion> arkeet: his funpuns?
02:22:48 <adnap> I don't know how to use this
02:23:07 <Cale> shachaf: cool!
02:23:21 <adnap> I'm pretty sure it's not working because I use NoScript
02:23:22 <shachaf> adnap: The bookmarklet? You put it in your bookmarks bar thing, then you go to the web page with the picture, click the bookmarklet, click the picture.
02:23:32 <shachaf> Then you wait for a while and then you can click to pause etc.
02:23:38 <shachaf> adnap: Ah. Yes. That'll be it.
02:24:20 <ion> NoScript users don’t get to complain about website issues before trying to allow scripts first.
02:24:43 <`nand`> ion: except if the website really should work without scripts
02:24:48 <adnap> Okay, it's working
02:25:02 <`nand`> wait
02:25:05 <`nand`> I don't have a bookmark bar
02:25:16 <`nand`> what are these ‘bookmarks’ you speak of?
02:25:19 <ion> nand: I’m sure shachaf will accept a patch to jsgif to do that.
02:25:33 <`nand`> ion: I'm not saying this is a case where it applies
02:25:45 <`nand`> but stuff like simple forms really should work without js, unfortunately some websites think otherwise
02:26:18 <shachaf> That sounds on-topic!
02:26:41 <adnap> It does not
02:26:45 <shachaf> I started it, I suppose.
02:26:51 <shachaf> (I'll respond in #-blah if you take the `s off your nick.)
02:26:57 <`nand`> .. ..and .. uh I'm saying, we should make sure our haskell web frameworks really make sure this is the case
02:26:57 <latermuse> javascript sucks, but it is becoming more and more pervasive
02:27:07 <`nand`> shachaf: ‘nand’ is taken!
02:27:34 <adnap> Sarcasm is weird
02:27:49 <nhaas> there we go
02:27:54 <adnap> Saying the opposite of what you mean so someone will have to do extra work
02:27:54 <nhaas> uh
02:28:01 <shachaf> As long sa you stick with it.
02:28:07 <nhaas> this nickname is registered, which means I registered it a while ago, and I have no idea with what password
02:28:12 <nhaas> time to find out!
02:29:16 <ion> If you don’t remember it, you can always use `nhaas`.
02:29:40 <nhaas> oh no, seems like somebody else registered it 3 years ago
02:29:42 <nhaas> and is actively using it
02:30:01 <nhaas> (very on-topic, I'm sure)
02:30:22 <haasn> works for me
02:31:10 <Coinbird> is this were you code iphones?
02:31:19 <mauke> no, I code Haskells
02:31:35 <mauke> but would you download a car?
02:31:37 <haasn> mauke is cloning Haskell Curry
02:32:23 <Taneb> I'd totally download a car
02:32:27 <leggo> I have trouble installing hakyll. is there anything I can do?  the issue seems to be that a couple of unit tests are failing.  http://hpaste.org/85758
02:33:56 <adnap> < Cale> Each expression is represented by a pointer to code which when entered will compute the value of the expression up to determining the topmost constructor, and return it,
02:33:58 <adnap>               but before it returns this value, it rewrites the code pointer to point at a shorter piece of code which just returns the result immediately next time.
02:34:11 * Coinbird goes to download a car
02:34:56 <Cale> adnap: I realise this is kind of hard to understand... if you're really into the details of it, I can point you at a pretty good introductory paper
02:35:17 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
02:35:19 <adnap> So... I guess the "code which when entered" "compute[s] the value of the expression up to determining the topmost constructor" calls "code which when entered" on a subexpression
02:35:26 <Taneb> I'd be an awful Haskell teacher because that made intuitive sense to me
02:35:47 <adnap> From looking at the animation
02:35:48 <adnap> ...
02:35:49 <supki> leggo: don't run tests? I guess they assume you are on some kind of Unix
02:35:53 <Cale> adnap: it very well may, yes
02:36:08 <adnap> The small expression turns into a bunch of pointers to pointers...
02:36:18 <Cale> adnap: Very often, evaluating an expression will require evaluating one of its subexpressions
02:36:30 <leggo> supki I am not sure how to avoid running tests?  I just ran cabal install hakyll
02:36:45 <adnap> So, I guess the second part of the sentence has to do with optimization
02:36:53 <adnap> But it doesn't really occur in the animation, so
02:37:02 <supki> leggo: --disable-tests I think
02:37:28 <adnap> Taneb: I am a dumb student
02:37:36 <Coinbird> whats the killer app made using haskell?
02:37:45 <adnap> GHC
02:37:50 <Hafydd> Hahah
02:38:05 <arkeet> found it
02:38:06 <arkeet> adnap: http://www.vex.net/~trebla/haskell/lazy.xhtml
02:38:13 <haasn> I'm sure no haskell apps are that violent
02:38:45 <adnap> arkeet: Ooh. Thank you
02:39:21 <Coinbird> isnt there a programing language that you could just speak to the computer?
02:39:23 <adnap> This looks like more walkthroughs like what Cale did
02:39:33 <adnap> evaluation walkthroughs
02:39:35 <haasn> Coinbird: lojban?
02:39:42 <haasn> not exactly a ‘programming’ language
02:39:45 <haasn> by some definitions of the term
02:39:56 <ion> coinbird: There is. http://youtu.be/KyLqUf4cdwc
02:40:03 <adnap> How about English
02:40:15 <haasn> adnap: show me a reliable english voice parser and we'll start talking
02:40:25 <adnap> No need to parse
02:40:27 <haasn> then again, show me a reliable lojban parser
02:40:28 <adnap> Just speak in Haskell
02:40:46 * mauke is a modem
02:40:57 <Coinbird> like computer i need an app that does this and that and the computer would figure something out
02:40:57 <haasn> so is ‘newline’ the name of a function or does it refer to a newline?
02:41:10 * ion whistles 2600 Hz to mauke
02:41:15 <haasn> english isn't great at unambiguously expressing haskell syntax
02:41:48 <haasn> to be fair, neither is lojban. Maybe you could introduce some escaping mechanism
02:42:24 <mauke> voice has more metadata
02:42:29 <mauke> you could encode stuff in tones
02:43:04 <haasn> the difficult thing is finding something that works for people with all sorts of voices, pitches, tonalities, accents and whatnot
02:43:16 <haasn> possibly even speech defects, if you don't want to ignore accessibility
02:43:17 <Coinbird> haskell sounds boring
02:43:42 <mauke> haasn: not everyone needs to be a programmer
02:44:14 <haasn> at the very least, not everybody needs to /dictate/ their programs
02:44:48 <adnap> mauke: https://www.dropbox.com/s/4fphtrgrnksfuf6/dialup-final.png
02:45:16 <Coinbird> voice is arguably the defacto comunication channel for humans
02:45:52 <haasn> voice is a bit culture specific even then. many gestures and nonverbal forms of communication are cross-culture
02:46:00 <haasn> for example the facial expressions associated with happiness
02:46:20 <haasn> oh, I have an idea
02:46:25 <haasn> programming Haskell via facial expressions
02:46:53 <Coinbird> yes but they cant be considered an objective language
02:48:01 <shachaf> Coinbird: Are you here in an attempt to troll the channel?
02:48:06 <shachaf> Please don't.
02:48:15 <ion> shachaf: You’re feeding it.
02:48:34 <mushi> can someone help with my http://www.ipaste.org/OAj advance world
02:48:38 <mushi> anyone
02:49:56 <mauke> mushi: not actionable
02:50:09 <mushi> woops expried
02:50:47 <mushi> http://www.ipaste.org/PAj
02:50:54 <mushi> having problems with advanceworld
02:51:04 <Coinbird> i need to make an app that makes the computer bark everytime the cam detects movment
02:51:08 <mushi> need moveParticle and acceleraet
02:51:51 <Coinbird> that will keep the cats away
02:53:19 <mushi> i got given tis advice
02:53:21 <mushi> "i suggest you do the movements in a where clause just return a (World x y z newParticles) and then apply the correct functions on the currentParticles in the where clause"
02:53:34 <mushi> but am unsure on the code, any help?
02:54:34 <leggo> ok I seem to have installed hakyll, but now I am getting this in ghci when attempting to use some function from it:  linking ... ghc.exe: unable to load package `regex-pcre-builtin-0.94.4.5.8.31'. and the same for bytestring-0.9.2.1'.  did installing hackyll break those packages?  what am I suppose to do?
02:54:35 <Botje> mushi: you have the assignment, we don't.
02:54:57 <Botje> mushi: grabbing all the particles from the old world seems like a good place to start.
02:55:21 <mushi> but there is no old work?
02:55:36 <Botje> mushi: the type of advanceWorld says there is.
02:55:39 <Botje> unless that's also wrong?
02:56:45 <Taneb> I think there should be a function "guardA" or "aguard" in Control.Applicative
02:56:53 <mushi> "which ignores its first argument and gets the number of seconds that pass in the current time step of the simulation as the second argument. In the third argument it receives the world configuration at the start of the current time step, and it computes and returns the world configuration at the end of that time step, where all particle velocities and particle positions have been suitably updated to account for the gravitational pull
02:56:56 <Botje> Hark! aguard!
02:56:58 <Taneb> aguard :: Alternative f => Bool -> f ()
02:57:14 <Taneb> aguard False = empty; aguard True = pure ()
02:57:17 <Botje> mushi: right, so you receive a world as input.
02:57:18 <Taneb> Like Control.Monad.guard
02:57:27 <Botje> mushi: grab all the particles from it, apply the necessary calculations, return the new world.
02:57:34 <Botje> mushi: which part are you having trouble with?
02:58:40 <mushi> ok
02:58:51 <mushi> start how do i even grab from old world?
02:59:00 <Botje> you pattern match against it.
02:59:05 <natnayr> he just has to apply map in such a way that its: map (moveParticle t) (accelerate t list)
02:59:21 <Botje> natnayr: yes, I recognized some types from your stuff :)
02:59:34 <natnayr> yeah we both are working on the same thing
02:59:36 <Botje> natnayr: maybe you can help mushi a bit, since you already know the assignment
03:00:48 <jrgill> Hi, I'm wondering if variables and functions named with "maybe" is a convention derived from Haskell's monad type.  Also, are the words "is" and "has" related to this nomenclature?  e.g., maybeNewUser, isRegistered, hasPrivilege.  Pardon if this is off topic; I cannot find much information for these generic words, but want to use them correctly.
03:01:21 <jrgill> + I
03:01:29 <shachaf> No, "maybe" probably has to do with "Maybe", not with "Monad".
03:01:32 <shachaf> "Monad" isn't a type.
03:01:52 <shachaf> "is" and "has" is probably used for booleans -- this isn't a Haskell convention.
03:03:08 <natnayr> Botje: dang we sound annoyting
03:03:38 <Botje> natnayr: hmm?
03:04:13 <klrr> is there a function that makes a positive number negative?
03:04:22 <sipa> :t negate
03:04:24 <lambdabot> Num a => a -> a
03:04:47 <klrr> sipa: ty :)
03:04:59 <natnayr> this assignment and all.. i do have one bug that needs a look-through.. im using foldl and its not implementing the function correctly, somehow its skipping the first/last particle in the list
03:05:04 <donri> @check \x -> abs (negate x) == x
03:05:06 <lambdabot>   Not in scope: `myquickcheck'
03:05:09 <aristid> > negate (1 :: Word32) -- oh no its broken
03:05:09 <hpaste> natnayr pasted “natnayr” at http://hpaste.org/85759
03:05:11 <lambdabot>   4294967295
03:05:18 <donri> Cale: @check broken?
03:05:31 <klrr> > (negate . read) "2"
03:05:33 <lambdabot>   -2
03:05:35 <klrr> :D
03:05:42 <Botje> natnayr: as long as people try their best, I (and presumably the rest of this channel) is happy to help
03:06:20 <shachaf> donri: For months.
03:06:28 <donri> oh :)
03:06:51 <natnayr> Botje: thanks :)
03:07:00 <jrgill> shachaf, so is Maybe a type instead of a monad?
03:07:22 <Kaidelong> the Maybe type belongs to the Monad typeclass
03:07:25 <sipa> jrgill: monads are types
03:07:27 <shachaf> There are some pointless arguments on what exactly counts as a type.
03:07:40 <Botje> natnayr: why do you think it's ignoring elements?
03:07:42 <sipa> jrgill: and Maybe is indeed one
03:07:42 <haasn> Maybe is a type that happens to be an instance of Monad; It's also a monad, in some evil parallel universe
03:07:43 <shachaf> Some people will say that Maybe is a type, and others will say that only Maybe Int is a type.
03:07:48 <natnayr> i need to reimplement my calculateAllForces function that it applys the updateAccel function regusively..
03:08:06 <shachaf> But this argument only reflects that people can't decide what words should mean; it's not important.
03:08:19 <natnayr> Botje: when i run it, the last element is stationary
03:08:22 <natnayr> so weird..
03:08:31 <jrgill> Thanks, that helps clarify some of the material I've come across.
03:08:49 <natnayr> its working on a file that flys fourparticles but not one with two particles simulating sun and earth
03:09:17 <Botje> mushi: something to think about for you as well: how are you going to apply forces, between which particles?
03:09:38 <Botje> natnayr: it's not something as stupid as opposite forces canceling out, is it?
03:10:08 <Botje> natnayr: is force p1 p2 === -1 * force p2 p1 ?
03:11:31 <natnayr> Botje: i'm not sure.. sounds likely.. but four floating particles work perfectly fine.. beautiful infact
03:11:44 <natnayr> but not a simulation of the sun and earth...
03:12:58 <mushi> hey Botje in acceOne?
03:13:05 <leggo> anyone knows what is going on in here? I think it may be related to instaling hakyll but I can't say for sure. loading this program into ghci gives me linking errors for both regex-pcre-builtin and array packages, but if I compile it with ghc it works.  http://hpaste.org/85760
03:13:53 <Botje> mushi: yes, you should probably work out how many times and on which particles you're going to apply acceOne.
03:15:31 <Renze_> does anyone know where to find a Yesod to CGI tutorial? I only found half ones without the complete description and they all fail to work with me (f.e. saying I should add wai-extra dependency while it is already there)
03:16:02 <luite> hmm i don't think people use that seriouly
03:16:04 <luite> +
03:16:04 <luite> s
03:16:23 <luite> since http proxying is so much faster
03:16:54 <natnayr> Botje: i dun think -1 * force p2 p1 ?
03:19:09 <Botje> natnayr: I'm pretty sure it is.
03:19:36 <Botje> natnayr: absAccel and d are always positive.
03:19:40 <neutrino> Renze_: you want to dispatch everything from nginx anyways.
03:19:55 <Botje> natnayr: but if you swap p1 and p2, you swap around the terms that make up dx and dy
03:21:24 <maltem> Renze_, CGI is not really  la mode these days; do you really have a scenario where you're stuck to CGI?
03:21:33 <natnayr> Botje: ive just changed force curr next to force next curr.. doenst change...
03:21:57 <Renze_> my assumption was that nginx wouldn't work on my website because I don't rent/lease/own a server, I'm only hosting my website at a webhoster
03:22:02 <natnayr> Botje: same output
03:22:11 <Botje> natnayr: well, simulate one step and verify the acceleration/velocity on your 'last' particle then.
03:22:31 <neutrino> Renze_: but they let you compile things with ghc?
03:22:36 <maltem> edwardk: In the algebra package, what is the exact reason that multiplication for associative algebras is defined dually? Is it performance or rather aesthetics?
03:22:42 <neutrino> Renze_: sounds like a weird setup.
03:22:48 <natnayr> Botje: i'll try two particles only.. considering that the earth is stationary..
03:22:59 <natnayr> sry i meant the sun
03:23:25 <natnayr> sry, how do i veryfy the velocity?
03:23:26 <Renze_> neutrino: isn't it possible to compile locally and upload it to my host?
03:23:32 <natnayr> like an printf statment?
03:23:40 <Botje> natnayr: you run your simulation for one timestep and inspect the world?
03:23:43 <neutrino> not likely they'll execute it as a persistent daemon.
03:24:00 <maltem> Renze_, does the webhoster allow custom (compiled) executables at all?
03:24:36 <edwardk> maltem: what do you expect?
03:24:45 <neutrino> the way you work with app servers is that they open a separate port or read a socket file and the web server communicates with them via one of those
03:25:01 <neutrino> neither is likely to happen on a shared host
03:25:01 <edwardk> maltem: (a -> r) -> a -> a -> r ?
03:25:50 <maltem> edwardk, am I naive to expect a -> a -> a ?  :)
03:26:07 <neutrino> bbl
03:26:13 <edwardk> maltem: yes =)
03:26:29 <maltem> I'd love to be enlightened!
03:26:39 <luite> edwardk: if you hadn't seen it already :) http://hdiff.luite.com/gloss/pong/
03:26:49 <edwardk> maltem:
03:26:50 <edwardk> class Multiplicative r where
03:26:51 <edwardk>   (*) :: r -> r -> r
03:26:55 <edwardk> that is what you are probably looking for
03:27:30 <maltem> oh, it's in a superclass
03:27:47 <edwardk> luite: hahahaha nice
03:28:25 <Renze_> maltem: all I know is that they accept CGI (and PHP and Perl) and because I say that Yesod could use CGI, my expectation was that it could possibly work out for me
03:28:35 <Renze_> say=saw
03:29:01 <luite> edwardk: not particularly useful :) i was making ghcjs web backend for gloss and `nand` suggested i'd do this one
03:29:24 <edwardk> yeah
03:29:30 <edwardk> tweeting that one =)
03:29:54 <luite> edwardk: there are other examples in http://hdiff.luite.com/gloss/
03:29:57 <aristid> i think the one with the little balls that fall down is also cool
03:30:15 <aristid> http://hdiff.luite.com/gloss/styrene/
03:30:51 <haasn> ooh, there's more than just the two?
03:31:00 <aristid> there are 3
03:31:08 <luite> i added pong later
03:31:14 <haasn> ah yes, I see it now, a bit less impressive than I was hoping :)
03:31:21 <aristid> oO
03:31:28 <luite> took a bit more time to implement the play function, handling user input
03:31:35 <aristid> you realize this is all real haskell (not some dialect) compiled down to javascript?
03:31:41 <haasn> yes
03:31:43 <haasn> and it is amazing
03:31:47 <aristid> !
03:31:50 <haasn> this is the future, literally
03:31:54 <luite> hehe..
03:31:56 <haasn> more like the present (literally)
03:32:04 <haasn> and now that was the past
03:32:05 <haasn> darn
03:32:10 <luite> i guess i'll have to come up wiht more impressive samples then
03:32:20 <haasn> by impressive I meant the number of samples
03:32:23 <maltem> edwardk, wait, now that I look at it, I would have rather expected  (Semiring r, Semiring a) as well as (r -> a -> a). Does (a -> a -> r) -> (a -> r) package all these up?
03:32:34 <aristid> luite: if the physics demo was faster that would be really impressive IMHO :>
03:32:51 <haasn> luite: oh, you never answered (or I missed the answer); what physics engine is the balls sample running on, if any?
03:32:52 <luite> aristid: yeah i'm going to look into that, i think it's probably bogged down with allocation
03:33:05 <luite> haasn: a very simple one in one of the gloss samples
03:33:23 <luite> http://code.ouroborus.net/gloss/gloss-stable/gloss-examples/picture/Styrene/
03:33:24 <edwardk> maltem: class (Additive r, Abelian r, Multiplicative r) => Semiring r    class Semiring r => Algebra r a where   no semiring structure on a itself is necessarily there.
03:33:56 <edwardk> It is only there fore some nicely behaved algebras
03:34:07 <haasn> luite: ah, okay
03:34:11 <haasn> I thought you wrote the whole sample
03:34:33 <edwardk> there are plenty of examples in Numeric.Algebra.* where the basis isn't a semigroup in its own right.
03:35:08 <maltem> edwardk, ok, so this is a more general notion of algebra than the working mathematician would be thinking of
03:35:27 <edwardk> maltem: i think you're thinking group algebras.
03:35:52 <maltem> I was thinking algebras over a ring
03:35:56 <luite> haasn: i'll ad a link to the original source
03:36:21 <edwardk> sure. these are allowed to be over just semiring-like structures, but otherwise we're still on the same page
03:37:38 <maltem> Not sure. When I'm thinking algebras over a ring, then those are rings themselves
03:38:04 <edwardk> maltem: Yes, The ring there is the (a -> r)   not 'a'
03:38:16 <edwardk> all of these are free modules
03:38:35 <edwardk> 'infinite free modules' technically
03:38:38 <maltem> Oh, so I should think of a as the basis only!
03:38:40 <edwardk> yes
03:38:46 <maltem> Thanks, that clears it up :)
03:38:56 <edwardk> the algebra package only manipulates free vector spaces and free modules
03:40:43 <edwardk> In general I work with a ring r, and a module (a -> r) over it, which can occasionally be an algebra (a -> r).   under this scheme then we can have vectors (a -> r)  and covectors (a -> r) -> r   where the outer -> is subject to linearity which is what gives rise to the Covector monad used in that package, which is Cont subject to a linearity condition on the outer function
03:41:21 <edwardk> (that is enough to rule out callCC but otherwise makes it so all the uses of monadic combinators on that monad are just tensoring, etc. in your covectors)
03:43:07 <edwardk> Then a kleisli arrow    a -> Covector r b    represents a linear map from the vector space    (b -> r)    to (a -> r)    which you can see as (b -> r) ->_L (a -> r)        being just a -> (b -> r) ->_L r       where ->_L is an arrow with a linearity side-condition on it
03:43:29 <edwardk> and that latter just being the a -> Covector r b   kleisli arrow
03:44:05 <maltem> sry, brb
03:45:19 <edwardk> np
03:55:12 <luite> aristid: hmm it's spending lots of time in the quadtree, where it's popping/pushing rather large stack frames all the time
03:55:36 <aristid> luite: hmm
03:55:42 <luite> aristid: that's another optimization that's not done yet, it should reuse stack slots if it would just push the same thing again
03:56:01 <luite> so it should just reorder the stack frame
03:57:36 <aristid> luite: you don't use the native js stack?
03:58:52 <edwardk> aristid: GHC doesn't use the native c stack either
03:59:26 <maltem> edwardk: ok, in the meantime I even understood most of your explanations. I suspect that the elegance of this would not actually meet my needs, which at the moment are more towards computer algebra; for example for polynomial rings with a nice show instance, I'd fear to need newtypes all over
03:59:51 <luite> aristid: yeah can't use it since js has only one, need one per thread :)
04:00:10 <aristid> edwardk: right, but simulating a stack in js sounds expensive
04:00:18 <edwardk> maltem: 'algebra' was mostly a toy while i explored the consequences of moving one of the commonly used infinities around in the definition of a free module.
04:00:22 <aristid> luite: do you use typed arrays or something like that?
04:00:26 <luite> aristid: untyped
04:00:39 <Ghoul_> Oh god, I'm going to get flamed for this question because of terminology
04:00:57 <Ghoul_> But how can I create a global variable or flag in haskell. The immutability thing confuses me slightly
04:01:03 <luite> aristid: it contains object references, functions and primitive values
04:01:14 <Ghoul_> What's the safe alternative to unsafeInterleaveIO?
04:01:56 <shachaf> The safe alternative is not using unsafeInterleaveIO, hth
04:02:00 <quchen> luite: I just looked a little bit at GHCJS and I was surprised it could just compile Gloss (as you showed yesterday). How does that work?
04:02:17 <supki> Ghoul_: you can have top level IORef/MVar with unsafePerformIO
04:02:28 <luite> quchen: it doesn't use the gloss opengl backend but a different backend that draws its stuff on a canvas
04:02:31 <edwardk> maltem: i was working on a computer algebra problem where i wanted piecewise padé approximation. for that i needed rings, etc to do it interestingly in haskell. So I started that library. When I got to algebras and what not I realised I wanted to say something a bit differently, rather than saying that every free module (a -> r) was non-zero at only a finite number of 'a's, i found it better to say rather than the covectors (a ->
04:02:31 <edwardk>  r) ->_L r   can only _inspect_ the (a -> r) at only a finite number of places. this makes it so the definition of vectors supports infinite spaces and the covectors are still computationally useful
04:02:34 <shachaf> I'm not sure what unsafeInterleaveIO has to do with global variables.
04:02:35 <donri> Ghoul_: you need unsafePerformIO for that, and the safer alternative is to pass around an IOVar without making it top-level, and the safest alternative is the State monad
04:02:37 <edwardk> unlike the usual version of things
04:02:54 <supki> nice _L
04:03:04 <quchen> To create a global binding, call it "x", write "x = ..." on the top level of your program.
04:03:49 <edwardk> maltem: this is particularly interesting for geometric algebra, because it lets me build up a notion of geometric 'coalgebra' that saves O(2^n) work where n is the number of dimensions!
04:04:03 <quchen> Using unsafePerformIO to store something in non-IO code is usually a good indicator that your code is strange.
04:04:11 <Ghoul_> ;\
04:04:19 <edwardk> in particular i can work there on large/infinite dimensional vector spaces that would otherwise not be tractable in a more traditional formulation
04:04:32 <maltem> edwardk, now that's just too interesting. Seeing that the tensor algebras instances look quite slick, are symmetric algebras equally slick to define?
04:04:33 <donri> Ghoul_: what are you trying to achieve?
04:04:41 <Ghoul_> donri: just learning
04:05:13 <donri> Ghoul_: ok :) well the usual idiomatic way would be a state monad, if you need state (figures eh)
04:05:32 <shachaf> For some things, anyway...
04:05:33 <edwardk> maltem: i didn't really give any thought to symmetric algebras i admit
04:05:40 <Ghoul_> coolio
04:05:45 <Ghoul_> Any idea when the SSE2/3 stuff is coming to GHC as-per this paper: Any idea when the SSE2/3 stuff is coming to GHC as-per this paper
04:05:48 <Ghoul_> Woops, sec
04:05:49 <edwardk> maltem: i may have thrown a class in, but if i did there isn't any magic in there for them
04:06:02 <Ghoul_> http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
04:06:19 <maltem> thanks in any case for the detailed perspective
04:06:31 <edwardk> maltem: one thing that i do use in that library a lot is the notion of a (co)representable functor.
04:06:41 <donri> > runState (do x <- get; put (x + 1); get) 0
04:06:43 <lambdabot>   (1,1)
04:06:51 <Ghoul_> OH get/put
04:07:12 <Ghoul_> I've used those before
04:07:18 <Ghoul_> un-knowingly of their power :P
04:07:46 <donri> 'put' "changes" what 'get' means after, but the 'x' above doesn't change
04:08:00 <donri> so you can sort of mimic state/mutation
04:08:10 <Ghoul_> > runState (do x <- get; put (x + 1); put (x + 1); get) 0
04:08:12 <lambdabot>   (1,1)
04:08:15 <donri> without breaking purity
04:08:16 <edwardk> maltem: a (co)representable functor is isomorphic to a hom-set from some object in the category.  forall r. f r ~ (x -> r)      if f is 'representable' by 'x'. So instead of using my free modules as -functions- from 'x' i can use any functor that has 'x' as a representation to store it.
04:08:27 <Ghoul_> hmm, so put always points to an expression
04:08:32 <Ghoul_> rather than a value
04:08:47 <quchen> A value is an expression too.
04:08:50 <edwardk> and these functors then get all the structure that entails from being a right adjunct, w.r.t. limit preservation, can turn temporarily into functions to move over things, etc.
04:08:53 <Ghoul_> :S lol
04:08:57 <quchen> You could use "put 1" as well.
04:09:03 <donri> an expression evaluates to a value too ;)
04:09:11 <donri> laziness makes the distinction fuzzy
04:09:23 <shachaf> "A value is an expressioN" and "an expression evaluates to a value" both sound wrong
04:09:56 <maltem> edwardk, ah, that explains the use of functors in Linear.Vector
04:09:56 <shachaf> But probably the right thing to do is not say things about it.
04:09:58 <edwardk> maltem: using those representable functors as the way to store a vector avoids the explosion in time complexity caused by my simplistic covector representation
04:10:08 <edwardk> maltem: yep
04:10:16 <Ghoul_> Well that's my brain bandwidth used up for today
04:10:22 <Ghoul_> time to read-all-about-it on lyah
04:10:44 <maltem> edwardk, btw, wasn't there once a blog at comonad.com?
04:10:46 <quchen> shachaf: A value can stand in many places where an expression could stand. There, I invoke the fuzziness of language!
04:10:52 <edwardk> maltem: anyways nobody has hacked on 'algebra' in a long time. if you spot anything you want to do to it or update in it let me know
04:10:52 <quchen> Also: http://ro-che.info/ccc/images/equality.png
04:11:05 <edwardk> there still is
04:11:14 <edwardk> it appears to be down at the moment
04:11:23 <maltem> hence my asking ;)
04:11:24 <edwardk> i'll have to talk to the guys who host it for me
04:12:25 <shachaf> quchen: I don't think so. I don't think there is hardly ever a place where they're interchangeable. But this argument about words is completely useless.
04:15:15 <maltem> I'll definitely look into it again, but at the moment I'm under master thesis constraints, and constructively revolutionising polynomials wasn't part of the plan :)
04:21:07 <edwardk> maltem: =)
04:22:25 <__xc> :t min
04:22:26 <lambdabot> Ord a => a -> a -> a
04:24:40 <__xc> :t miniimum
04:24:41 <lambdabot>     Not in scope: `miniimum'
04:24:42 <lambdabot>     Perhaps you meant one of these:
04:24:42 <lambdabot>       `minimum' (imported from Data.List),
04:24:52 <__xc> :t minimum
04:24:53 <lambdabot> Ord a => [a] -> a
04:25:18 <__xc> > miinimum $ map (\x->(x-1)^2) [0,0.1,..10]
04:25:20 <lambdabot>   <hint>:1:37: parse error on input `..'
04:25:32 <__xc> > miinimum $ map (\x->(x-1)^2) [0,0.1..10]
04:25:34 <lambdabot>   Not in scope: `miinimum'
04:25:34 <lambdabot>  Perhaps you meant one of these:
04:25:34 <lambdabot>    `minimum' (imp...
04:25:45 <__xc> > minimum $ map (\x->(x-1)^2) [0,0.1..10]
04:25:46 <lambdabot>   0.0
04:26:20 <Ghoul_> > minimum $ map (\x->(x-1)^2) [5,4.8..]
04:26:24 <__xc> getting the index of minimum?
04:26:26 <lambdabot>   mueval: ExitFailure 1
04:26:26 <lambdabot>  mueval: Prelude.undefined
04:26:43 <Ghoul_> > minimum $ map (\x->(x-1)^2) (take 20 [5,4.8..])
04:26:47 <lambdabot>   mueval-core: Time limit exceeded
04:26:57 <Ghoul_> really..
04:27:19 <__xc> weird indeed ^
04:28:03 <__xc> > minimum $ take 20 (map (\x->(x-1)^2)  [5,4.8..])
04:28:05 <lambdabot>   3.999999999999865e-2
04:28:16 * r0kis /amsg Hello guys, I need your help, got a task at university, to make a neclase and make it popular in facebook, so if you dont mind, PLEASE go to http://pieceof.com/products/basket/ and vote for my hand made neclase, I'll be really grateful <3 :)
04:28:43 <osfameron> does spamming random chans on irc ever work?
04:28:55 <quchen> Works better than not doing so.
04:29:14 <__xc> men, for getting the index of a minimum? any idea
04:29:21 * osfameron wonders what a neclase is.  If only I could be bothered to click on the link and find out
04:29:29 <__xc> (not the value at chich it's reached)
04:30:01 <osfameron> quchen: does it?  if anything, it might inspire someone to do the opposite, or run a denial of service attack on the site, or to email the person's tutor to report them for malpractice
04:30:07 <__xc> need a fold..
04:31:02 <Ghoul_> uh yeah
04:31:12 <Ghoul_> bind the list elements with their index in a tuple somehow
04:31:32 <quchen> __xc: The cheap way would be using zip to index the list.
04:31:32 <Ghoul_> and go from there \o/
04:31:39 <__xc> In could sort entirely, but it's a waste
04:32:16 <quchen> > minimumBy (comparing snd) . take 20 $ zip [0..] (map (\x -> (x-1)^2) [5, 4.8 ..])
04:32:18 <lambdabot>   (19,3.999999999999865e-2)
04:32:31 <__xc> no
04:32:54 <__xc> I need the x axis number, not the sequence
04:33:18 <__xc> (1) in the case, no the position of 1 in the input list
04:33:31 <quchen> > minimumBy (comparing snd) . take 20 $ (map (\x -> (x, (x-1)^2)) [5, 4.8 ..])
04:33:33 <lambdabot>   (1.1999999999999966,3.999999999999865e-2)
04:34:06 <Ghoul_> I honestly do not understand the difference
04:34:30 * hackagebot cuda 0.5.0.2 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.5.0.2 (TrevorMcDonell)
04:37:26 <__xc> thx quchen
04:37:38 <__xc> > min (1,2) (1,3)
04:37:39 <lambdabot>   (1,2)
04:37:55 <__xc> > min (2,1) (2,0)
04:37:56 <lambdabot>   (2,0)
04:38:43 <__xc> > (min.snd) (2,1) (2,0)
04:38:45 <lambdabot>   (1,1)
04:38:48 <supki> :t iminimumOf
04:38:51 <lambdabot>     Not in scope: `iminimumOf'
04:38:51 <lambdabot>     Perhaps you meant one of these:
04:38:51 <lambdabot>       `minimumOf' (imported from Control.Lens),
04:38:52 <quchen> Tuples are ordered similar to words. Compare first letter, if equal compare second letter etc.
04:38:54 <supki> hmm
04:40:07 <aCube> :t minimumOf
04:40:09 <lambdabot> Ord a => Getting (Endo (Endo (Maybe a))) s t a b -> s -> Maybe a
04:40:44 <shachaf> I,I Getting (Endo (Endo (Yoneda (Endo a)))) s t a b
04:40:49 <shachaf> Er.
04:40:53 <shachaf> I,I Getting (Endo (Endo (Yoneda Endo a))) s t a b
04:41:00 <__xc> that's some far fetched package
04:41:08 <__xc> ;)
04:41:33 <mushi> hi
04:41:40 <tsinnema> what would people here currently recommend for generating ctags of haskell code for vim? i want tags for the base libraries as well as for a bunch of random stuff on hackage as well as for my own code
04:41:40 <mushi> anyone know anything about foldl and map
04:41:46 <aCube> schlicht: what is that?
04:41:50 <aCube> oops
04:42:03 <shachaf> A silly way of saying an isomorphic type.
04:43:25 <aCube> > map f [a,b,c,d]
04:43:25 <mushi> hi anyone around
04:43:27 <lambdabot>   Ambiguous type variable `b0' in the constraints:
04:43:28 <lambdabot>    (GHC.Show.Show b0)
04:43:28 <lambdabot>     ...
04:43:30 <mushi> @hpaste
04:43:30 <lambdabot> Haskell pastebin: http://hpaste.org/
04:43:38 <mushi> @hpaste allForces :: Float -> [Particle] -> Particle -> Particle allForces timeI current rest = map(s1 rest current) s1 = foldl acceOne(timeI)
04:43:38 <lambdabot> Haskell pastebin: http://hpaste.org/
04:44:13 <FireFly> > map [x,y,z]
04:44:15 <lambdabot>   can't find file: L.hs
04:44:26 <FireFly> er
04:44:29 <mauke> > ()
04:44:31 <FireFly> > map x [y,z]
04:44:31 <lambdabot>   ()
04:44:33 <lambdabot>   Couldn't match expected type `a0 -> b0'
04:44:33 <lambdabot>              with actual type `Debu...
04:44:46 <mauke> > map f [x,y,z] :: [Expr]
04:44:49 <lambdabot>   [f x,f y,f z]
04:44:53 <FireFly> Aha
04:45:03 <hpaste> mushi pasted “mushi” at http://hpaste.org/85762
04:45:05 <mauke> > foldl z [a,b,c]
04:45:07 <lambdabot>   Couldn't match expected type `a0 -> b0 -> a0'
04:45:08 <lambdabot>              with actual type...
04:45:10 <mauke> > foldl f z [a,b,c]
04:45:12 <lambdabot>   f (f (f z a) b) c
04:45:20 <mauke> > foldr f z [a,b,c]
04:45:23 <lambdabot>   f a (f b (f c z))
04:45:40 <mushi> hey mauke can you please have a look at that code?
04:47:11 <hpc> mushi: first, rewrite it to not use f()-style function calls
04:47:22 <hpc> it is at best misleading, and at worst downright wrong
04:47:38 <mushi> whats do you mean by f() style fucntion calls?
04:47:46 <hpc> map(s1 rest current)
04:47:51 <aristid> mushi: in haskell you call functions like f x
04:47:53 <aristid> not f(x)
04:47:57 <mushi> oh right
04:47:59 <mushi> i can do that
04:48:15 <hpc> and then hpaste it so we don't have to guess where newlines are and chat stays clean
04:48:27 <mushi> ok doing that
04:48:30 <mm_freak_> what's the preferred way to deal with "end of stream" in pipes?
04:48:51 <natnayr> whats the forAll property in quickChecks?
04:48:53 <hpaste> mushi revised “mushi”: “mushi” at http://hpaste.org/85762
04:49:06 <mushi> done
04:49:18 <mm_freak_> @check forall (\x -> x == (x :: Word8))
04:49:20 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `forall'
04:49:25 <mm_freak_> @check forAll (\x -> x == (x :: Word8))
04:49:27 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `forAll'
04:49:32 <mm_freak_> uh
04:50:08 <hpc> @hoogle forAll
04:50:09 <lambdabot> Test.QuickCheck.Property forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
04:50:09 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
04:50:09 <lambdabot> keyword forall
04:50:21 <hpc> :t forAll
04:50:24 <lambdabot> Not in scope: `forAll'
04:50:26 <hpc> :(
04:51:10 <mm_freak_> natnayr: it really just means "use the given test case generator"
04:51:40 <mushi> hpc: you can view updated paste
04:51:49 <natnayr> mm_freak_: so that means that it adds like a "limit" to the given type?
04:52:25 <mm_freak_> natnayr: yes…  in principle you could do the same using a custom type with an Arbitrary instance
04:53:01 <natnayr> ommiting it would give a very-high or low number right?
04:53:02 <mm_freak_> despite its name it doesn't mean that the test should be exhaustive =)
04:53:15 <mm_freak_> natnayr: depends on the size parameter
04:53:16 <hpc> mushi: what are you trying to define?
04:53:33 <hpc> or rather, what do you want it to do
04:53:50 <mushi> i m trying to measure the force on all particles
04:55:05 <hpc> hmm
04:55:15 <hpc> you still have a syntax issue
04:55:22 <hpc> s1 should be defined in a where-clause
04:55:28 <mm_freak_> natnayr: the size parameter is passed to quickcheck…  for example if you use the test-framework package it's the -s argument of your test suite
04:57:00 <__xc> > foldl min (5,1000) $ map (\x -> ((x-1)^2,x)) [5, 4.8 .. -5]
04:57:01 <lambdabot>   (1.262177448353619e-29,0.9999999999999964)
04:57:02 <mushi> i ve added in where
04:57:04 <mushi> updating paste now
04:57:34 <__xc> > foldl min (5,1000) $ map (\x -> ((x^2-1)^2,x)) [5, 4.8 .. -5]
04:57:36 <lambdabot>   (5.048709793414476e-29,0.9999999999999964)
04:57:37 <hpaste> mushi revised “mushi”: “mushi” at http://hpaste.org/85762
04:58:07 <__xc> hmm -1..
04:58:46 <__xc> > take 2 sort $ map (\x -> ((x^2-1)^2,x)) [5, 4.8 .. -5]
04:58:48 <lambdabot>   Couldn't match expected type `[a0]' with actual type `[a1] -> [a1]'
04:59:02 <mushi> hpc:  now?
04:59:06 <__xc> > take 2 $ sort $ map (\x -> ((x^2-1)^2,x)) [5, 4.8 .. -5]
04:59:08 <lambdabot>   [(5.048709793414476e-29,0.9999999999999964),(1.135959703518257e-28,-1.00000...
04:59:42 <__xc> programing languages and floats
04:59:53 <aCube> What does shrink mean in quickcheck?
05:00:01 <haasn> solution: don't use floats
05:00:02 <hpc> well it's now at least syntactically correct; i suggest thinking about the problem without map/fold
05:00:16 <hpc> then look at your final working solution and translate it into map/fold
05:00:24 <haasn> > take 2 . sort $ map (\x -> ((x^2-1)^2,x)) [5, 4.8 .. -5] :: [CReal]
05:00:26 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
05:00:27 <lambdabot>              with ac...
05:00:30 <haasn> :(
05:00:32 <haasn> oh
05:00:36 <mushi> i have
05:00:39 <haasn> > take 2 . sort $ map (\x -> ((x^2-1)^2,x)) [5, 4.8 .. -5] :: [(CReal, CReal)]
05:00:41 <lambdabot>   [(0.0,-1.0),(0.0,1.0)]
05:00:41 <mushi> i ve been kinda stuck
05:00:49 <haasn> __xc: ^
05:00:59 <__xc> heh
05:01:06 <quchen> aCube: Shrink is used to give you better error descriptions. If you have a complicated test case, it is used to simplify the expression; if the simplified expression still fails, you get that error.
05:01:18 <hpc> it's too early in the morning for me to be thinking too hard about code :P
05:01:32 <quchen> aCube: It's basically a way of simplifying the error-producing expression, while still keeping the error.
05:01:33 <mushi> its too late for me :P
05:02:01 <tsinnema> what would people here currently recommend for generating ctags of haskell code for vim? i want tags for the base libraries as well as for a bunch of random stuff on hackage as well as for my own code
05:02:15 <mushi> would you have any idea how to make map accept timeI? hpc
05:02:54 <Botje> mushi: you need to think about the role of timeI in your overall computation.
05:03:27 <aCube> quchen: Looking at the implementation of shrink for some instances, it is like an ordering of how "simple" a value is? I.e. shrink a returns values that are simpler than a?
05:03:50 <Botje> you're simulating a physics system, so timeI is (i guess) the amount of time your other particles get to pull on the current one.
05:03:57 <quchen> aCube: Yes, in a way. I think the Maybe definition is quite useful.
05:03:59 <mushi> right
05:04:16 <quchen> aCube: "If a Just value fails, try whether you can reproduce the error with a Nothing"
05:04:23 <Botje> so one approximation is to multiply the pull of other paritcles for one time unit by timeI
05:04:42 <__xc> > pi :: CReal
05:04:43 <mm_freak_> mushi: i did not read everything, but are you modelling a physical simulation?
05:04:44 <lambdabot>   3.1415926535897932384626433832795028841972
05:04:50 <mushi> mm_freak_:  yes
05:04:57 <Botje> mushi: so work out how to do that (have other particles pull on one given particle) first.
05:04:59 <mm_freak_> mushi: did you consider using FRP?
05:05:09 <shachaf> mm_freak_: Modelling a homework assignment.
05:05:14 <mushi> mm_freak_:  not sure what FRP is but its a assignemnt
05:05:44 <mushi> hey Botje thats waht acceOne does
05:05:45 <Botje> mushi: if you're not sure what map and foldl do, revisit your course material and/or learn you a haskell.
05:06:25 <mushi> at first i had allForces timeI current rest = fold acceone(timeI) rest current
05:06:34 <mm_freak_> mushi: for simulations i always recommend Functional Reactive Programming, but it has a learning curve
05:06:40 <aCube> quchen: Why does shrink for (a,b) not shrink both elements?
05:06:44 <Botje> mushi: don't make up syntax.
05:07:02 <quchen> aCube: I just wondered about the exact same thing :-)
05:07:10 <Botje> fold acceOne(timeI) rest current is the same as fold acceOne timeI rest current.
05:07:22 <aCube> quchen: also, list does also not return map shrink xs
05:07:31 <Botje> if you want to partially apply acceOne to timeI, write foldl (acceOne timeI) rest current.
05:08:01 <Botje> (it's also super weird that current :: [Particle] and rest :: Particle
05:08:23 <aCube> quchen: The reason I could think of is that you get the same when you shrink to times.
05:08:27 <mushi> i meant i had this
05:08:28 <mushi> allForces timeI current rest = foldl (acceOne timeI) rest current
05:08:34 <aCube> s/to/two/
05:08:42 <mushi> (memory decieved me)
05:09:17 <__xc> haasn, any explanation to:
05:09:18 <quchen> aCube: shrink only alters one element of the result at a time it seems.
05:09:20 <__xc> > foldl1 min $  map (\x -> ((x^2-1)^2,x)) [5, 4.8 .. -5] :: [(CReal, CReal)]
05:09:21 <lambdabot>   Couldn't match expected type `[(Data.Number.CReal.CReal,
05:09:22 <lambdabot>                   ...
05:09:23 <Botje> mushi: okay.. that at least looks like it typechecks.
05:09:34 <mushi> but then none of my particles moved
05:09:41 <Botje> that's all forces from "current" pulling on the particle you have in "rest"
05:09:48 <Botje> for timeI steps, I guess.
05:09:57 <quchen> aCube: Maybe that's so the amount of shink cases grows linearly instead of squared for tuples
05:10:04 <Botje> so where is allForces invoked?
05:10:13 <mm_freak_> fallingBall = integral_ (-30, 0) . integral_ (20, 100) . pure (0, -9.8)
05:10:31 <mm_freak_> throw a ball from (-30, 0) with initial velocity (20, 100) and watch it fall =)
05:10:41 <mushi> hold on Botje i ll link you
05:11:00 <hpaste> mushi pasted “mushi” at http://hpaste.org/85766
05:11:16 <mushi> Botje:  thats the entire file
05:12:26 <__xc> > minimum $ map (\x -> ((x^2-1)^2,x)) [5, 4.8 .. -5] :: [(CReal, CReal)]
05:12:28 <lambdabot>   Couldn't match expected type `[(Data.Number.CReal.CReal,
05:12:28 <lambdabot>                   ...
05:13:31 <__xc> > min (1 :: CReal) (2 :: CReal)
05:13:33 <lambdabot>   1.0
05:13:37 <Botje> mushi: that looks sane enough. if your "force" implementation is sane that should work, I think.
05:14:30 <mushi> force is given my lecturer
05:14:36 <mushi> so it should be sane
05:14:41 <mushi> but for some reason
05:14:46 <mushi> my world is just a freeze
05:15:37 <Botje> mushi: then investigate. take a system with just two particles, work out what happens.
05:16:04 <mushi> i got one with a sun and 1 particle
05:16:06 <mushi> same thing
05:16:20 <Botje> then work out why. look at the individual parts of your solution.
05:16:36 <Botje> check if accelerate returns something sensible, check if moveparticle works, etc.
05:16:41 <mushi> i showed it to a friend
05:16:53 <mushi> who told me to look at line allForces timeI current rest = foldl (acceOne timeI) rest current
05:16:59 <mushi> he said map
05:17:05 <mushi> and thats all he gave away
05:18:14 <Botje> map doesn't make sense there.
05:18:41 <Botje> but, again, step through your solution. verify that all parts separately work.
05:18:57 <Botje> invoke allForces yourself, inspect the result.
05:19:01 <Botje> I can't do that for you.
05:20:24 <__xc> haasn, k just needs some more brackets
05:21:17 <aCube> Why does the Fun instance on http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/src/Test-QuickCheck-Function.html#Fun  require CoArbitrary a? I can't see any functions requiring CoArbitrary in the implementation of the instance methods
05:22:09 <aCube> Ah, nvm, it's hidden in the instance of (a:->b)
05:30:09 <no-n[9]> fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap
05:30:58 <Taneb> no-n[9], Haskell can let you express that quite easily!
05:31:12 <no-n[9]> heh. wrong channel, sorry ;(
05:31:12 <Taneb> > cycle "fap "
05:31:14 <lambdabot>   "fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fa...
05:31:35 <mushi> Botje:
05:31:40 * no-n[9] apologises
05:31:46 <tsinnema> i think fap is idempotent so you're not really getting anywhere
05:31:48 <tsinnema> but you a
05:31:55 <tsinnema> but you can get videagra for that
05:33:02 <tsinnema> ok let me try again
05:33:04 <tsinnema> what would people here currently recommend for generating ctags of haskell code for vim? i want tags for the base libraries as well as for a bunch of random stuff on hackage as well as for my own code
05:33:47 <hpaste> mushi pasted “musi” at http://hpaste.org/85768
05:33:59 <mushi> Botje:  can you make any sense of that?
05:34:07 <dzhus> Can I get cabal to set CPP symbol values using preconf/prebuild hooks?
05:34:11 <mushi> (i ve am super tired after a long day, i just want to finish this )
05:34:53 <Botje> mushi: are you seriously expecting me to figure out _your_ problem like this?
05:34:58 <Botje> mushi: go to bed, take another look tomorrow.
05:35:12 <tsinnema> crashing due to overwork can get nasty
05:35:21 <mushi> its dude in a hour~
05:35:28 <mushi> i fix that i should be done
05:35:36 <shachaf> Botje: What is IRC for, if not doing your homework for you when it's dude in a hour?
05:36:45 <Ghoul_> lol schach is legendary
05:36:47 <quchen> When dummy holes don't write your code, try #haskell :-)
05:37:28 <Botje> mushi: your classmate has more information than we do AND has proposed a solution.
05:38:04 <Botje> ask them instead.
05:38:06 <maltem> dzhus, there's a cpp-options field (undocumented, but it exists)
05:39:43 <natnayr> Non-exhaustive patterns in function
05:41:00 <Ghoul_> natnayr: hmm?
05:41:07 <Ghoul_> Do you need the issue solved?
05:44:48 <natnayr> sry, yeah i get that error in quickcheck
05:45:38 <Botje> and are you going to tell us the function as well?
05:46:12 <Saizan> natnayr: that error means you haven't covered some cases in the definition of your function
05:46:37 <natnayr> thanks.. yeah its one of my guards
05:47:30 <shachaf> Compiler with -Wall
05:47:33 <shachaf> s/r//
05:49:12 <aCube> Is there a good way to format numbers so they always have 2 digits on output in haskell?
05:49:36 <shachaf> No.
05:49:47 <shachaf> > printf "%02d" 8
05:49:49 <lambdabot>   Ambiguous type variable `a0' in the constraints:
05:49:50 <lambdabot>    (GHC.Show.Show a0)
05:49:50 <lambdabot>     ...
05:49:51 <shachaf> > printf "%02d" 8 :: String
05:49:53 <lambdabot>   "08"
05:55:54 <aCube> > reverse $ take 4 $ reverse (show 100) ++ repeat '0'
05:55:56 <lambdabot>   "0100"
06:03:04 <no-n[9]> > 15/0
06:03:06 <lambdabot>   Infinity
06:03:13 <no-n[9]> heh
06:05:25 <aCube> @hoogle (Show a) => a -> Text
06:05:25 <lambdabot> Data.Text.Lazy unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
06:05:26 <lambdabot> Data.Text unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
06:05:26 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
06:06:53 <aCube> Is there any such function?
06:07:48 <shachaf> @ty Data.Text.pack . show
06:07:50 <lambdabot> Show a => a -> Data.Text.Internal.Text
06:10:35 <aCube> @hoogle justifyRight
06:10:36 <lambdabot> Data.Text justifyRight :: Int -> Char -> Text -> Text
06:10:36 <lambdabot> Data.Text.Lazy justifyRight :: Int64 -> Char -> Text -> Text
06:14:00 <mm_freak_> i'm already missing my eye candy…  i just switched from KDE4+compiz to xmonad
06:19:13 <deximat> http://learnyouahaskell.com/introduction is this good?
06:19:41 <Botje> LYAH is very good.
06:19:59 <deximat> Great!
06:20:02 <deximat> tnx
06:20:51 <deximat> I need to learn Haskell fast :)
06:26:16 <niteria> @hoogle graphsec
06:26:16 <lambdabot> No results found
06:28:48 <tsinnema> what would people here currently recommend for generating ctags of haskell code for vim? i want tags for the base libraries as well as for a bunch of random stuff on hackage as well as for my own code
06:43:49 <aCube> tsinnema: There is htags (http://hackage.haskell.org/package/htags), but I'm not using vim, so I cannot say how good it works
06:44:35 <Taneb> With ghc-mod I'm getting "cannot satisfy -package doctest" which is stepping in before error-checking
06:45:09 <tsinnema> aCube, thanks, i'll look into it
06:45:16 <Taneb> What does this mean?
06:46:00 <niteria> tsinnema: I have lushtags installed but I don't use it often
06:47:16 <tsinnema> niteria, ok, thanks. there seem to be many many options
06:47:50 <tsinnema> if only i knew which one is the most useful
06:48:36 <A__A> This arise the need for a standard interface to access data from any field device ### or ### This arises the need for a standard interface to access data from any field device ?????
06:49:08 <Eelis> "Thus the need arises for .."
06:49:24 <Eelis> but even that sounds kinda wonky
06:50:08 <niteria> tsinnema: if only vim was programmable with some reasonable language
06:51:42 <tsinnema> niteria, yeah there's that
06:51:45 <bitonic> niteria: it is
06:52:06 <bitonic> you can write vim extensions in a lot of languages (python & ruby for sure)
06:52:14 <bitonic> still worse than emacs.
07:07:20 <mel-> hi
07:10:51 <hpaste> jermey pasted “jermy” at http://hpaste.org/85777
07:12:05 <mushi> hey guys you probably saw i paste
07:12:37 <mushi> the prop if it does meet that i want it to return true
07:12:38 <mushi> anyone have idea?
07:18:17 <mushi> http://hpaste.org/85777 there is a syntax error
07:18:23 <mushi> anyone know of a neater way to do it?
07:19:24 <Rembane_> mushi: Remove: == True
07:20:22 <vraid> mushi: x < y evaluates to either true or false
07:20:39 <mushi> right i just noticed it aswell
07:20:45 <vraid> x < y == True also evaluates to true or false, and is no different from the first
07:20:47 <mushi> (been a long day forvie me)
07:23:42 <Rarrikins> mushi: Are oEnergy and nEnergy both nonnegative?
07:25:16 <vraid> does that matter?
07:33:02 <A__A> ANyone use the eclipse FP/haskell IDE? how do I run the program (not ghci) from eclipse+
07:33:05 <A__A> ?
07:34:12 <A__A> Is 'if' preferred over 'case' if you are dealing with True/False?
07:36:47 <Taneb> A__A, yes
07:37:06 <Taneb> And I don't know how to run the program from eclipse, although I presume there's a way
07:38:08 <Taslem> @pl (\x -> f x >>= g)
07:38:08 <lambdabot> (g =<<) . f
07:38:34 <Taneb> Taslem, f >=> g, I think
07:38:36 <A__A> millerRabinNtimes r ntimes = do
07:38:36 <A__A>     b <- MR.isMillerRabinPrime r
07:38:36 <A__A>     if b then millerRabinNtimes r (ntimes-1) else return False
07:38:42 <Taneb> pl is a bit stuod sometimes
07:38:43 <A__A> can it be done in one step?
07:39:16 <Taneb> What monad are you working in?
07:39:47 <Taslem> Taneb: I wanted to see how you'd write the third monad law in pointfree style.
07:40:07 <Taneb> Taslem, Right
07:40:12 <Taneb> A__A, what monad are you working in?
07:40:41 <A__A> IO Bool
07:40:49 <Taneb> Right, okay
07:40:52 <ceii> Taslem: a >=> (b >=> c) = (a >=> b) >=> c
07:41:21 <ceii> in pontfree style (i.e. using Kleisli arrows) the monad laws are just category laws
07:41:23 <Peaker> looking at the source of Control.Monad.Trans.State.Strict -- I'm having a hard time seeing where there's any strictness at all
07:41:27 <Peaker> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/src/Control-Monad-Trans-State-Strict.html
07:42:09 <Taneb> A__A, just noticed, that will either end up with "return False" or not terminate
07:43:19 <A__A> A__A: yes
07:43:21 <A__A> thats ok
07:44:01 <A__A> no it wont btw
07:44:11 <A__A> ntimes-1
07:44:20 <hpaste> Peaker pasted “Strict state is lazy??” at http://hpaste.org/85779
07:44:41 <Taneb> A__A, but then it will keep going until it hits the false case
07:45:37 <Peaker> I really wonder what they mean by: "In this version, sequencing of computations is strict."
07:46:08 <shachaf> Maybe the join/fmap viewpoint is better than the >>= viewpoint.
07:46:16 <shachaf> The "expensive" part of a monad is the join, not the fmap.
07:47:18 <Peaker> I was debugging why all my debug traces were in funny order -- it seems it's because State.Strict is lazy on the state...
07:47:32 <Peaker> I wonder if there's any explanation of that weird behavior
07:47:55 <geekosaur> pretty sure -cafe has seen several discussions of what strict state means
07:48:15 <A__A> do  a <- randInRange 1 (n-1);   if mod (a^(n-1)) n == 1 then return False else fermatTest n (k-1); #### how can I rewrite without do notation?
07:48:36 <shachaf> @undo a <- randInRange 1 (n-1);   if mod (a^(n-1)) n == 1 then return False else fermatTest n (k-1);
07:48:37 <lambdabot>  Parse error at "<-" (column 3)
07:48:39 <shachaf> @undo do a <- randInRange 1 (n-1);   if mod (a^(n-1)) n == 1 then return False else fermatTest n (k-1);
07:48:40 <lambdabot> randInRange 1 (n - 1) >>= \ a -> if mod (a ^ (n - 1)) n == 1 then return False else fermatTest n (k - 1)
07:49:34 <Peaker> geekosaur, it seems so far that it just means the (a,s) tuple is strict (!!)
07:49:46 <Peaker> which seems completely meaningless
07:50:55 <shachaf> Perhaps it's "necessary", in the same way that foldl' gives you strictness on the outermost thing.
07:51:27 <shachaf> But if you foldl' with a tuple accumulator your accumulating function still needs to be manually strict on th econtents of the tuple.
07:51:48 <Peaker> but the tuple is yours, so it makes sense you force its elements
07:52:00 <Peaker> I guess I can wrap the State API with strict counterparts
07:52:28 <Peaker> but hmm.. that might not help, because an eventual put will discard the previous "s" avoiding its computation entirely
07:55:03 <Peaker> unless maybe I define:   modify' f = modify (f $!) ; put' = modify' . const
07:57:32 <Ankhers> As a newb in Haskell, how bad would it be for me to install GHC 7.6.2?
08:00:34 <geekosaur> Ankhers, you're better off installing the haskell platform
08:01:26 <Ankhers> geekosaur: Is that just due to package incompatibility?
08:02:06 <geekosaur> next platform release should be 7.6.1, not 7.6.2, there are reasons for this (i.e. you perhaps should not be trying to run 7.6.2 as a newbie)
08:02:20 <geekosaur> ghc is not linux, the latest and greatest is not the place to be
08:02:33 <geekosaur> the latest and greatest is the place for elite type hackers to be
08:02:46 <Ankhers> Fair enough, I just wanted to play around with GHCJS
08:02:51 <Ankhers> Thanks for the help.
08:02:59 <aCube> What advantages does GHC of haskell platform have over GHC 7.6 ?
08:03:49 <geekosaur> stability, lots of canned packages that are guaranteed to work together, and less likelihood of triggering cabal hell while trying to build up those packages yourself
08:19:30 <A__A> ok i have a bad pattern case  and then case again. so this could be rewritten nicely right?
08:19:41 * hackagebot epub-tools 2.2 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-2.2 (DinoMorelli)
08:20:05 <hpaste> A__A pasted “case to case, improve” at http://hpaste.org/85782
08:22:05 <A__A> i think it is kind of nice as it is though but can you simplify it? maybe with >>=
08:24:17 <hpaste> aCube annotated “case to case, improve” with “Should do the same, because of laziness” at http://hpaste.org/85782#a85783
08:24:29 <shachaf> aCube: That's not how laziness works.
08:24:40 <aCube> shachaf: not? :(
08:24:43 <shachaf> Nope.
08:25:01 <aCube> if b is not used, millerRabinNtimes r ntimes is still evaluated?
08:25:17 <shachaf> This is not about evaluation.
08:25:20 <shachaf> It is still executed.
08:26:46 <aCube> oh right, otherwise IO would be quite funny
08:26:57 <shachaf> Yep.
08:27:21 <aCube> Why is bigPrime in the IO monad, anyway?
08:27:48 <niteria> it needs random numbers I guess
08:27:51 <shachaf> It probably uses IO for randomness.
08:27:55 <shachaf> There are probably better ways.
08:28:18 <A__A> yes bc of random
08:28:34 <A__A> shachaf: like?
08:28:47 <shachaf> Passing the randomness in as a list, for instance.
08:28:54 <aCube> > fmap randoms getStdGen
08:28:56 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO [a0]))
08:28:56 <lambdabot>    arising from a use o...
08:29:06 <shachaf> Or using some monad for randomness in particular, rather than IO.
08:34:43 <niteria> why do Clients, Producers, Consumers take () as a param in Control.Proxy?
08:35:40 <Taneb> niteria, because they are type synonyms for a more general type, I think
08:36:01 <shachaf> Because the API was designed by a madman.
08:36:14 <shachaf> Alternatively, because the API was designed by someone who likes Kleisli composition.
08:36:31 <shachaf> Things like (a -> m b) -> (b -> m c) -> a -> m c
08:36:59 <shachaf> Sometimes you need to introduce extraneous ()s to make everything fit that pattern: It takes an input and produces an output.
08:37:21 <shachaf> Just like putStrLn gives you IO () as an output, some Control.Proxy things take () as an input.
08:38:35 <hpc> see also: blaze-html
08:42:26 <niteria> so http://i.qkme.me/3twjfu.jpg
08:50:12 <bjorkintosh> is there a ghc mode which handles indentations better?
08:50:31 <bjorkintosh> the default does not seem terribly smart.
08:53:13 <Okasu> bjorkintosh: Can you tell in which cases it fails with defaults?
08:53:18 <ParahSail1n> http://en.wikibooks.org/wiki/Haskell/Indentation
08:53:54 <bjorkintosh> Okasu, it seems to insert 20 spaces on each tab.
08:54:21 <bjorkintosh> and when i hit enter under an already indented piece, it indents even further.
08:54:45 <ParahSail1n> you mean your editor?
08:54:45 <Okasu> Ugh, do you mean *Emacs* mode?
08:55:06 <bjorkintosh> correct.
08:55:19 <Philonous> Wow, hslint is surprisingly clever
08:55:23 <bjorkintosh> it says it is in haskell mode
09:00:21 <bjorkintosh> any suggestions?
09:03:03 <scalable> do you have haskell indent enabled?
09:03:59 <bjorkintosh> yes i do.
09:05:16 <bjorkintosh> seems to work better with it off.
09:07:33 <ab9rf> what do you want it to do?
09:07:56 <bjorkintosh> heh. it is doing it now :)
09:08:04 <bjorkintosh> all i had to do was turn indentation off.
09:24:34 <bitonic> apart from ‘fgl’, are there any other graph libraries?  ‘fgl’ is poorly documented and seems a bit outdated (references to FiniteMap...)
09:28:15 <niteria> @hoogle runIdentityK
09:28:16 <lambdabot> No results found
09:29:35 <mint> I need some assistance with writing a function that takes a list of numbers a min and a max and returns a min and max value as a pair. im not sure how exactly to declare this
09:29:57 <int-e> bitonic: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphs
09:31:56 <bitonic> int-e: is that a way to say ‘no’?  there isn’t much there.  fgl seems to dominate
09:33:29 <A__A> mint: should you return the max and min within a min and max range?
09:34:09 <int-e> bitonic: hmm. in addition to that I see 'graphs' and 'uni-graph', which lack that category. There isn't much in the area; I suppose there are quite a few people who have their own ad-hoc implementation of various graph algorithms.
09:34:23 <Guest13046> example bounds1Accum[6,9,3] 5 10 will return (3,10)
09:34:23 <A__A> mint :: [Integer] -> Integer -> Integer -> (Integer, Integer)
09:34:47 <int-e> bitonic: 'graphs' looks best at a glance.
09:34:49 <A__A> mint=guest?
09:34:59 <A__A> then what are the bounds?
09:35:03 <Guest13046> yes sorry I tried changing it but im on a live CD so it didnt work
09:35:39 <A__A> oh i see if it was 6,7,9 it would return (5,10)?
09:36:17 <Guest13046> I think so. thats how I understand too anyway
09:36:48 <Guest13046> when you call the function you give it the list and the 5, and 10 and it should spit out (3,10)
09:37:01 <int-e> edwardk: you should really add the Graphs category to the graphs package. ;)
09:37:45 <bitonic> int-e: oh, it wasn’t under ‘Graphs’... thanks
09:38:06 <A__A> > let mint xs mini maxi = foldl(\(mi,ma) x -> if x < mi then (x,ma) else (if x > ma then (mi,x) else (mi,ma) ) else (mi,ma) ) (mini,maxi) xs in mint [6,9,3] 5 10
09:38:07 <lambdabot>   <hint>:1:110: parse error on input `else'
09:39:07 <Botje> bounds1Accum l mn mx = (minimum (mn:l), maximum (mx:l))
09:39:27 <int-e> bitonic: and there may be more, I only looked for things with "graph" in their package name or description.
09:39:36 <Botje> or you do a foldl with (x `min` mn, x `max` mx), that works too.
09:39:49 <int-e> bitonic: the complete package list is just too long :)
09:40:03 <bitonic> int-e: I know, that’s why I asked :)
09:40:14 <Guest13046> if you can cover it with just that one line Botje that looks really nice lol
09:40:32 <Guest13046> instead of multiple ifs
09:40:40 <amiller> has anyone used EMGM generics library
09:40:48 <amiller> can't figure out why/when the Deriving module disappeared
09:41:12 <amiller> 0.3 had Deriving, but I can't install 0.3 on a recent ghc because of old dependencies
09:42:28 <edwardk> int-e there is a graphs category? ok.
09:42:33 <hpaste> A__A pasted “mint” at http://hpaste.org/85786
09:44:53 <int-e> amiller: hmm. From the package description: "NOTE: As of version 0.4, this library does not have Template Haskell for generating the representation. We are working on another library for a solution to this problem."
09:45:09 <amiller> hrm, thanks.
09:45:44 <A__A> let mint mini maxi xs = foldl(\(mi,ma) x -> (min x mi, max x ma)) (mini,maxi) xs in map (mint 5 10) [[6,7,9],[3,6,9],[6,9,99],[3,6,99]]
09:45:53 <A__A> > let mint mini maxi xs = foldl(\(mi,ma) x -> (min x mi, max x ma)) (mini,maxi) xs in map (mint 5 10) [[6,7,9],[3,6,9],[6,9,99],[3,6,99]]
09:45:54 <lambdabot>   [(5,10),(3,10),(5,99),(3,99)]
09:46:02 <Guest13046> I have this http://pastebin.com/1ri21nAZ but it tell me I need to (Show (Integer -> Integer -> (Integer, Integer)))
09:46:02 <Guest13046>  or something
09:46:55 <A__A> mint. if you use hpaste you can autopaste to this channel
09:47:37 <edwardk> int-e: added in HEAD. whenever i push out a new version it'll go in that category
09:47:39 <A__A> bounds1Accum l mn mx = (minimum (mn:l), maximum (mx:l)) // woudlnt that traverse the list twicee?
09:47:49 <A__A> i think mine is good:
09:47:50 <int-e> edwardk: thanks :)
09:47:51 <A__A> > let mint mini maxi xs = foldl(\(mi,ma) x -> (min x mi, max x ma)) (mini,maxi) xs in map (mint 5 10) [[6,7,9],[3,6,9],[6,9,99],[3,6,99]]
09:47:53 <lambdabot>   [(5,10),(3,10),(5,99),(3,99)]
09:47:59 <xf> Sorry for the noob question.. but is there an up to date version of hugs available? The only one I found runs haskell 98..
09:48:22 <edwardk> xf: hugs is a bit of a dinosaur
09:48:23 <A__A> > let mint mini maxi xs = foldr (\(mi,ma) x -> (min x mi, max x ma)) (mini,maxi) xs in map (mint 5 10) [[6,7,9],[3,6,9],[6,9,99],[3,6,99]]
09:48:25 <lambdabot>   Occurs check: cannot construct the infinite type: t1 = (t0, t1)Occurs check...
09:48:35 <A__A> > let mint mini maxi xs = foldr (\x (mi,ma) -> (min x mi, max x ma)) (mini,maxi) xs in map (mint 5 10) [[6,7,9],[3,6,9],[6,9,99],[3,6,99]]
09:48:36 <lambdabot>   [(5,10),(3,10),(5,99),(3,99)]
09:48:37 <edwardk> xf: ghci has for all intents and purposes subsumed its role
09:49:02 <xf> edwardk, awesome. I will replace it with ghci. Cheers!
09:49:50 <Guest13046> I cant hardcode 5 10 into my function I need to be able to give it any 2 numbers I want
09:50:04 <A__A> it is not hardcoded...
09:50:15 <A__A>  mint mini maxi xs = foldr (\x (mi,ma) -> (min x mi, max x ma)) (mini,maxi) xs
09:50:19 <A__A> is your function
09:50:26 <Guest13046> oh ha im a noob
09:50:30 <A__A> np
09:52:41 <int-e> @type uncurry (***) . (min &&& max)
09:52:43 <lambdabot> Ord c' => c' -> (c', c') -> (c', c')
09:52:57 <Guest13046> two use that ill need to change my function definition I think
09:53:21 <int-e> (but I'm sure it can be done shorter with lenses.)
09:57:02 <hpaste> “Anonymous Coward” pasted “bounds1Accum” at http://hpaste.org/85787
09:59:49 <calsaverini> Hi there
10:00:19 <calsaverini> I asked a question here yesterday and unfortunately I had to leave before anyone could help me :/
10:00:34 <calsaverini> but, I'm having a problem with cabal
10:01:02 <calsaverini> I recently installed haskell-platform on a new ubuntu machine and I can't seem to install anything with cabal
10:01:31 <calsaverini> I followed this prescription here: http://www.haskell.org/pipermail/haskell-cafe/2012-February/099094.html
10:01:40 <calsaverini> But it didn't worked also
10:02:17 <calsaverini> does anyone knows if it's just me, or if there's something broken on cabal on ubuntu?
10:02:58 <Clint> what's the symptom?
10:03:30 <calsaverini> Everytime I try to install anything I have a "couldn't read cabal file xxxx.cabal" error
10:03:46 <calsaverini> I tried installing Yesod
10:03:53 <calsaverini> and some other packages
10:04:56 <calsaverini> I ran the suggested tar command "tar -f ~/.cabal/packages/hackage.haskell.org/00-index.tar --delete bytestring/0.9.2.0" (also for bytestring/0.9.2.1)
10:05:02 <calsaverini> but it had no effect
10:08:11 <benzrf> hello!
10:08:18 <Eduard_Munteanu> benzrf: hi
10:08:27 <benzrf> what is the difference between '(Num a) a' and 'Num'?
10:08:50 <Eduard_Munteanu> benzrf: the former makes no sense :)
10:08:59 <Eduard_Munteanu> Unless you mean   (Num a) => a   ?
10:09:04 <benzrf> right, sorry
10:09:05 <benzrf> :|
10:09:25 <Eduard_Munteanu> (Num a) => a   is a type
10:09:34 <Eduard_Munteanu> Num is a class constraint
10:09:35 <benzrf> or for that matter '(Num b, Integral a) => a -> b' vs 'Integral -> Num'
10:10:00 <benzrf> erm
10:10:00 <Eduard_Munteanu> You can only have types to the right of =>
10:10:07 <benzrf> ah
10:10:08 <Eduard_Munteanu> Integral and Num aren't types.
10:10:09 <benzrf> got it
10:10:21 <benzrf> so typeclasses and types are NOT interchangable
10:10:33 <Eduard_Munteanu> They're more like sets of types with a common interface.
10:10:35 <Eduard_Munteanu> Yeah.
10:10:46 <benzrf> ok  :)
10:14:30 <paolino_> hello I have this binary tree http://hpaste.org/85788
10:14:55 <paolino_> I'm trying to distinguish the zero level by type
10:15:34 <paolino_> I'm not able to think a zipper for this
10:15:41 <Tehnix> hi, toying a bit with nested json (using aeson), and ran into a bit of a problem, line 34 says "Couldn't match expected type `BTCInfo` with actual type `Maybe a0`.. If anyone can spot any immediate errors I've made or smth :|
10:15:45 <Tehnix> http://hastebin.com/dilavoxocu.hs
10:15:53 <Tehnix> ^ the code, forgot to add that -.-'
10:16:44 <nwf> Hey all; quick question: what's the correct categorical name for sequence (:: [m a] -> m [a]).  It feels like it should be something derived from strength, but I don't know for sure.
10:16:58 <paolino_> :t sequence
10:16:59 <Eduard_Munteanu> paolino_: that tree definition looks strange
10:16:59 <lambdabot> Monad m => [m a] -> m [a]
10:17:17 <Eduard_Munteanu> nwf: it is strength
10:17:23 <calsaverini> so, no one else having problems with cabal? I'll try to do a clean install
10:17:29 <Eduard_Munteanu> :t Data.Traversable.sequence
10:17:31 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
10:17:34 <nwf> Eduard_Munteanu: Oh, well, OK then. :)
10:17:35 <Eduard_Munteanu> Err.
10:17:43 <paolino_> Eduard_Munteanu, is it wrong ?
10:17:55 <Eduard_Munteanu> For t = (,) b
10:18:23 <deximat> [2,0.7..0] why does this list contains negative number?
10:18:43 <nwf> Eduard_Munteanu: Is there a name for the generalized notion, then, with t unrestricted?
10:18:51 <nwf> Or just "generalized strength"?
10:19:01 <paolino_> > [2,0.7 .. 0]
10:19:02 <lambdabot>   [2.0,0.7,-0.6000000000000001]
10:19:39 <Eduard_Munteanu> nwf: strength is defined with respect to a monoidal structure on a category, you can pick something else for your tensor product
10:21:02 <deximat> paolino_, why?
10:21:05 <Eduard_Munteanu> paolino_: you can only construct infinitely deep trees with that, it seems.
10:21:39 <paolino_> deximat, it seems broken, I was just trying
10:22:05 <Eduard_Munteanu> nwf: http://en.wikipedia.org/wiki/Strong_monad
10:22:45 <andrewsw> deximat: it has to do w/ the rules for Enum.
10:22:59 <paolino_> Eduard_Munteanu, you are right, sorry I just simplified the rosetree to help making the question
10:23:02 <andrewsw> deximat: on floats
10:23:10 <nwf> Eduard_Munteanu: Yes, I've read.  I'm not sure how to bend "t ~ []" into an (\otimes,I) monoid, tho'.
10:23:24 <deximat> andrewsw, could you explain a bit more or give some pointer, I am new to haskell :(
10:23:27 <Guest13046> noob question but in function declarations what is the difference between function_name and function_name'
10:23:30 <andrewsw> deximat: and proximity to the desired last element in the sequence.
10:23:37 <Guest13046> what is the ' for
10:23:42 <andrewsw> deximat: I don't have definitive information.
10:23:46 <cdh473> no pointers, please
10:23:52 <deximat> hahha
10:24:24 <deximat> Guest13046, ' doesn't have any special meaning, just new name?
10:24:43 <nwf> Guest13046: ' typically indicates either just some variant of the function or, sometimes, as with folds, that the function is strict in some way.
10:25:09 <nwf> But it's just another part of the name; what you do with it is up to you. :)
10:25:16 <deximat> nwf, yeah, but only in logical way
10:25:19 <paolino_> Eduard_Munteanu, http://hpaste.org/85788
10:25:44 <Eduard_Munteanu> nwf: A (x) B = () x B  might do I suppose
10:25:54 <Guest13046> so if I wanted to create a wrapper function (function within a function) would I use that?
10:25:59 <Guest13046> that notation
10:26:26 <Eduard_Munteanu> Guest13046: that would be ok, but you're not required to
10:27:38 <hpaste> me pasted “wrapper” at http://hpaste.org/85790
10:28:08 <Eduard_Munteanu> paolino_: hmmm... did you consider numbering the levels in reverse? That would be more like a nat-indexed list
10:28:25 <Guest13046> I have that function and I have to write another function that will simply check to see if the list is empty and if so return nothing otherwise return the result of that function as normal
10:29:10 <calsaverini> Guest13046: in haskell the ' character is a valid character to use in a name, so people usually use it to indicate that the function f' is a variant of the function f. It means nothing in particular.
10:29:16 <Eduard_Munteanu> paolino_: basically   data Tree (n : Nat) a where Leaf :: a -> Tree Zero a; Branch :: a -> Tree n a -> Tree n a -> Tree (Succ n) a
10:29:35 <paolino_> Eduard_Munteanu, it's the zero level which is different as it hold a value of a different type
10:29:44 <paolino_> not the leaf
10:29:47 <Eduard_Munteanu> Hm.
10:29:55 <Philonous> Guest13046:  like this: "checked l min max = if null l then Nothing else Just $ bounds bounds1Accum l min max" ?
10:30:03 <calsaverini> Guest13046: it's just like any other valid character, like _
10:30:13 <hpaste> me pasted “bounds” at http://hpaste.org/85791
10:30:13 <hpaste> me pasted “bounds” at http://hpaste.org/85792
10:30:24 <Guest13046> so something kinda like that
10:30:56 <mm_freak_> how do i prevent something from being garbage-collected other than putting an arbitrary unreachable IO action somewhere?
10:31:01 <Philonous> Except s/l/xs
10:31:10 <mm_freak_> (it's a Handle that should stay open until the program dies)
10:31:44 <mm_freak_> right now i'm doing this ugly hack:  forever (threadDelay 1000000) >> hClose h
10:31:56 <Philonous> mm_freak_:  touch the handle before main exits?
10:32:13 <andrewsw> deximat: http://stackoverflow.com/a/7290493 might help
10:32:20 <Eduard_Munteanu> Does it get GCed if you hClose it at the end?
10:32:41 <Philonous> Eduard_Munteanu:  forever never ends ;)
10:32:48 <Eduard_Munteanu> No, without forever.
10:32:54 <Eduard_Munteanu> At the end of main, say.
10:33:49 <mm_freak_> indeed, this works
10:33:49 <nwf> Philonous: "main = do { h <- ... ; ..., ; hClose h }" should be enough to keep h alive throughout the long-running ....
10:33:54 <mm_freak_> main = bracket xmobar hClose (const . xmonad $ cfg `additionalKeysP` keys)
10:34:05 <nwf> Ah ha, another xmonad user. :)
10:34:43 <mm_freak_> for some reason my previous attempt didn't work:  xmonad (cfg `additionalKeys` keys) `finally` hClose h
10:35:05 <mm_freak_> nwf: i'm just switching from KDE4+compiz to xmonad =)
10:35:31 <mm_freak_> after the basic configuration i really need to get some eye candy going, otherwise i might return to compiz
10:35:38 <Philonous> mm_freak_:  I like to use the xfce4-panel
10:35:54 <nwf> mm_freak_: You may be interested in my https://github.com/nwf/xconfig/blob/master/xmonad/lib/XMonad/Actions/XMobars.hs module, which lets me toggle xmobars per display.
10:36:04 <mm_freak_> Philonous: i actually like the idea of xmobar…  i'll stream some system stats into its stdin and it gets displayed =)
10:36:07 <nwf> (It's not perfect; bug reports and patches eagerly accepted)
10:36:24 <mm_freak_> nwf: oh, i want the same bar on every screen
10:36:28 <mm_freak_> but thanks =)
10:37:05 <Philonous> mm_freak_:  xfce4-panel has plugins that let you run arbitrary code and display the result. I added a modification that instead of running code read from a fifo and let xmonad pipe stuff in there.
10:37:08 <mm_freak_> nwf: i usually have only a single screen anyway…  i really only need two screens when i give a talk
10:37:43 <nh2> snoyberg: I read your http://www.yesodweb.com/blog/2012/06/attoparsec-position - and I was thinking to try and add a simple counter to attoparsec. Incrementing an Int64 doesn't sound like too much of a performance penalty to me yet. Do you know what attoparsec's Input/Added/More types are good for?
10:37:55 <nwf> mm_freak_: I have a larger monitor on my desk when I'm at work, so I dual-screen with my laptop display, which has entirely too few pixels.
10:39:01 <mm_freak_> nwf: oh, i'm used to the fairly large KDE panel + well above 30px title bars
10:39:46 <mm_freak_> also i use quite large fonts…  i don't subscribe to the need to get as much text as possible on a single screen =)
10:40:16 <mm_freak_> i never understood people who choose 8px fonts for terminals…  i use something like 16px
10:40:17 <paolino_> Eduard_Munteanu, do you think it's possible to write the parent function for the zipper without pattern matching on the Nat type ?
10:41:19 <Philonous> mm_freak_:  You should switch optometrists.
10:42:30 <Eduard_Munteanu> paolino_: hm, didn't think it through, but I guess so. You merely manipulate the path.
10:44:04 <hpaste> me pasted “bounds” at http://hpaste.org/85793
10:44:27 <Guest13046> I have that but it tells me I am missing accompanying bindings
10:44:45 <Philonous> Guest13046:  You haven't defined bounds
10:44:57 <Philonous> bounds1, even
10:45:29 <Palmik> Hi guys. I want to define a CPP flag when compiling a benchmark. I have tried this: http://hpaste.org/85794 but it does not seem to work. Any ideas?
10:46:16 <Guest13046> its basically just supposed to wrap around bounds1Accum  function I have and return whatever bounds1Accum would return as long as the list its passed isnt empty
10:47:53 <ab9rf> mm_freak_: any point size larger than 6pt is a waste of pixels!
10:48:37 <monochrom> tiny fonts are essential for practical use of tiling window managers
10:49:59 <aavogt> Palmik: there's probably a flag for cabal-dev for flags to pass to ghc. Something like   --optghc='-Dfoo'
10:50:41 <aavogt> or maybe it's called --ghc-options just like for cabal install
10:50:41 <Eduard_Munteanu> Or big screens :)
10:51:17 <Eduard_Munteanu> I use 10pt DejaVu Sans Mono on my 24".
10:53:18 <Philonous> Guest13046:  http://hpaste.org/85792 looked right, except that the type doesn't match and l really should be xs (or the other way around)
10:54:48 <niteria> is there a comparison between pipes and similar libraries somewhere?
10:57:53 <Guest13046> neither of my pastes work so its back to the drawing board haha. by second paste that includes an if fails too
10:59:39 <hpaste> guest pasted “bounds” at http://hpaste.org/85796
10:59:45 <Guest13046> like that
11:00:44 <monochrom> there is no way "map whatever whatever" can have type (whatever, whatever)
11:01:05 <monochrom> "map whatever whatever" must have type [something]
11:16:10 <Kaidelong> @instances functor
11:16:10 <lambdabot> Couldn't find class `functor'. Try @instances-importing
11:16:16 <Kaidelong> @instances Functor
11:16:17 <lambdabot> ContT r m, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
11:16:32 <Kaidelong> @instances-importing Functor
11:16:32 <lambdabot> ContT r m, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
11:16:55 <Kaidelong> I could have sword there was a functor instance for (,) a
11:17:03 <Kaidelong> which just maps over the snd
11:18:43 <scalable> instance Functor ((,) a) -- Defined in `GHC.Base'
11:18:46 <scalable> there is
11:20:50 <Taneb> > fmap reverse ("hello", "gnolediaK")
11:20:52 <lambdabot>   ("hello","Kaidelong")
11:24:27 <_mike_> hello. how can I prevent ambiguous type variable error in here?
11:24:32 <_mike_> > randomR (0 :: Int, 5 :: Int)
11:24:34 <lambdabot>   Ambiguous type variable `g0' in the constraint:
11:24:34 <lambdabot>    (System.Random.RandomGen...
11:24:47 <Hail_Spacecake> I accidentally deleted my .cabal directory
11:25:00 <Hail_Spacecake> so now I have a bunch of packages that are broken in ghc-pkg
11:25:07 <Hail_Spacecake> which is affecting me installing new packages
11:25:21 <Hail_Spacecake> so how do I reset my package state entirely?
11:26:38 <monochrom> that's .ghc
11:26:39 <ParahSail1n> accidentally delete .ghc
11:26:51 <scalable> probably delete package.cong in .ghc
11:26:55 <k00mi> _mike_: you have to give a type signature for the random generator (StdGen probably)
11:27:35 <monochrom> but .ghc also has your ghci command history. you may like to be selective in deletion
11:28:15 <parcs> :t randomR
11:28:16 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
11:28:18 <_mike_> k00ml why can't the partially applied function return RandomGen, just like randomR ?
11:28:29 <_mike_> or rather accept RandomGen
11:29:07 <parcs> _mike_: instead of doing 'foo = randomR (1::Int,5::Int)' try 'foo gen = randomR (1::Int,5::Int) gen'
11:29:13 <k00mi> _mike_: RandomGen is a type class, you havo to specify what instance of that class you want
11:29:44 <Hail_Spacecake> can I just delete the x86_64-linux directories in there?
11:29:46 <ParahSail1n> @ty randomRIO
11:29:47 <lambdabot> Random a => (a, a) -> IO a
11:30:44 <_mike_> but can't I keep it polymorphic?  as far as I can see randomR (1 :: Int, 5 :: Int) should return a function with type RandomGen g => g -> (Int, g)
11:32:16 <_mike_> which is what :t says too
11:32:17 <_mike_> :t randomR (0 :: Int, 5)
11:32:19 <lambdabot> RandomGen g => g -> (Int, g)
11:32:51 <k00mi> oh, I see
11:33:28 <k00mi> it seems to work if you give an explicit type signature for the resulting function
11:35:48 <_mike_> it doesn't for me.
11:35:55 <_mike_> > randomR (0, 5) :: RandomGen g => g -> (Int, g)
11:35:57 <lambdabot>   Ambiguous type variable `g0' in the constraint:
11:35:58 <lambdabot>    (System.Random.RandomGen...
11:36:09 <parcs> you should post code
11:36:29 <_mike_> that's the code, I am typing it in GHCI
11:37:13 <monochrom> not all requirements can be satisfied. due to self contradictions
11:37:38 <_mike_> what contradictions?
11:37:44 <monochrom> if you command ghci to evaluate an expression, ghci must give you an answer or die trying
11:37:55 <k00mi> > let f :: RandomGen g => g -> (Int, g); f = random (0,5) in f
11:37:57 <lambdabot>   Couldn't match expected type `g -> (GHC.Types.Int, g)'
11:37:57 <lambdabot>              with ac...
11:38:04 <k00mi> > let f :: RandomGen g => g -> (Int, g); f = randomR (0,5) in f
11:38:06 <lambdabot>   Ambiguous type variable `g0' in the constraint:
11:38:06 <lambdabot>    (System.Random.RandomGen...
11:38:15 <monochrom> but if your expression is type-class-polymorphic, there cannot be an answer. you must say which instance.
11:38:28 <parcs> why are you telling ghc to print a function?
11:38:32 <parcs> er, ghci
11:39:25 <k00mi> well, the ambiguity error comes before it realises there is no Show instance for functions
11:40:09 <monochrom> the combination "I want an answer" and "I want it type-class-polymorphic" is contradictory
11:40:58 <_mike_> monogchor how does typing 10 work then? it's a polymorphic literal
11:41:48 <k00mi> there are default rules for numbers
11:41:49 <monochrom> defaulting rules dumb it down to Integer
11:42:32 <k00mi> _mike_: if you define that function and then use it on some kind of RandomGen, it will work
11:42:41 <monochrom> read the GHC user's guide for what gets defaulted, and more importantly, what doesn't get defaulted
11:43:19 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
11:45:31 <_mike-> ok thanks everyone
11:49:07 <A__A> guest did you get it rigjt? i solved your boundsaccum for you...
11:52:07 <Palmik> Hi guys. I want to define a CPP flag when compiling a benchmark. I have tried this: http://hpaste.org/85794 but it does not seem to work. Any ideas?
11:54:55 * hackagebot split 0.2.2 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.2.2 (BrentYorgey)
11:54:57 * hackagebot antiquoter 0.1.1.0 - Combinator library for quasi- and anti-quoting.  http://hackage.haskell.org/package/antiquoter-0.1.1.0 (LarsCorbijn)
11:56:07 <DMcGill> is "all arrows have an arity of 1" an accurate thing to say?
11:56:37 <DMcGill> I've seen lots of "proc _ ->" and haven't seen any partial application of them
11:56:37 <maltem> Palmik, cabal configure --cpp-options=
11:57:48 <monochrom> arrows don't provide partial application
11:58:08 <int-e> DMcGill: oh you mean that (in a category) every arrow has exactly one source and one target.
11:58:17 <int-e> to me "arity" is a conceptual mismatch here though
11:59:26 <DMcGill> yes, although surely you could do the partial application yourself with `:: Arrow (~>) => a ~> (b ~> c)' and then define like (proc a -> proc b -> ...)?
11:59:45 <int-e> > ((+) >>> (*)) 1 2 3 -- huh? :-)
11:59:46 <lambdabot>   8
12:00:21 <DMcGill> exactly, although you'd have to apply it yourself with arrows that aren't  (->)
12:00:23 <int-e> DMcGill: I mean, monads don't have an arity either.
12:00:54 <DMcGill> but (a -> m b) does, and that's what Kleisli is
12:01:07 <DMcGill> I think you're right, I'm in a state oc conceptual mismatch
12:01:12 <DMcGill> s/oc/of
12:03:29 <int-e> Ah, Caleskell, where 2 = const 2, and arithmetic on functions is pointwise.
12:05:07 <monochrom> a ~> (b ~> c) is not very useful, unless you have a combinator of type (b ~> c, b) ~> c to actually make use of the b~>c you obtain
12:05:09 <int-e> And (1+3) * (const 2 3) = 8. Yay.
12:05:14 <DMcGill> on a side note, lambdabot allowing `f = sin^2 + cos^2' has never sat right with me, it feels like such of an abuse of notation
12:05:23 <DMcGill> I do it all the time on paper of course
12:05:27 <monochrom> but then, you will have a full-fledged monad, not just an arrow
12:06:16 <int-e> > 6 6 6
12:06:18 <lambdabot>   6
12:06:25 * DMcGill shudders
12:06:43 <DMcGill> although HBasic having line numbers is genius
12:07:17 <DMcGill> things like `f = do{ 10 command1; 20 command2; GOTO 10}'
12:07:48 <DMcGill> (there should be a 30 there). What can't you do with Num instances for functions!
12:07:53 <int-e> DMcGill: can you do  (5+30) command1; ?
12:08:31 <DMcGill> In HBasic? I assume so given that it's implemented using Num
12:08:41 <DMcGill> I haven't really used it myself though
12:08:51 <hpc> DMcGill: that's the most magnificently horrible thing i have ever seen
12:08:53 <DMcGill> @hoogle hbasic
12:08:53 <lambdabot> Network.HTTP.Auth AuthBasic :: String -> String -> String -> URI -> Authority
12:08:53 <lambdabot> Network.Browser AuthBasic :: String -> String -> String -> URI -> Authority
12:09:01 <DMcGill> @hackage hbasic
12:09:01 <lambdabot> http://hackage.haskell.org/package/hbasic
12:09:17 <int-e> DMcGill: it depends on whether the Num instance implements anything besides fromInteger :)
12:09:24 <DMcGill> http://hackage.haskell.org/package/basic-prelude
12:09:56 <DMcGill> argh no that's not it easier
12:10:07 <DMcGill> one sec, let me look properly
12:10:12 <DMcGill> s/easier/either
12:10:17 <FireFly> Wait, huh?
12:10:32 <FireFly> :t (sin^2 + cos^2)
12:10:33 <lambdabot> Floating a => a -> a
12:10:45 <DMcGill> http://hackage.haskell.org/packages/archive/BASIC/0.1.5.0/doc/html/Language-BASIC.html
12:11:08 <FireFly> @ty (^)
12:11:09 <lambdabot> (Integral b, Num a) => a -> b -> a
12:11:25 <DMcGill> int-e: you're right, most of the types only implement fromInteger
12:11:28 <FireFly> oh, so it's the Num instance for functions again..
12:11:59 <DMcGill> FireFly: Yep! Everybody's favourite thing to abuse
12:13:13 <monochrom> mathematicians tend to like function Num instances
12:13:50 <int-e> > ((^) + (+)) 2 3
12:13:51 <lambdabot>   13
12:14:00 <DMcGill> I still don't know if the fromInteger is applied to the type before or afterwards the (+) though - that is, if `(fromIntegral (3+27)) :: a -> b' works while `(fromIntegral 3 + fromIntegral 27) :: a -> b' wouldn't
12:14:08 <int-e> monochrom: I'm pretty sure that most mathematicians would shy away from that one :)
12:14:32 <monochrom> but they love "sin^2 + cos^2 = 1"
12:14:43 <DMcGill> I'm a maths + compsci student and while I love writing sin^2 + cos^2 in paper, I dislike it in Haskell
12:14:51 <DMcGill> monocrom: exactly!
12:15:14 <Rotaerk> :t (^) + (+)
12:15:16 <lambdabot> Integral b => b -> b -> b
12:15:35 <DMcGill> also which instance is it that gives
12:15:44 <DMcGill> > (a + b) * c
12:15:45 <lambdabot>   (a + b) * c
12:16:00 <int-e> > sin^2 + cos^2 == 1 -- alas
12:16:02 <lambdabot>   *Exception: (==): No overloading for function
12:16:12 <DMcGill> > (a + b) * c == a*c + b*c
12:16:14 <lambdabot>   False
12:16:24 <int-e> haha
12:16:36 <int-e> lambdabot has too many type hacks
12:16:39 <hpc> you heard it here first!
12:16:41 <DMcGill> > ((a + b) * c) == (a*c + b*c)
12:16:42 <lambdabot>   False
12:16:46 <DMcGill> interesting
12:17:03 <DMcGill> damn, where's halgebra?!
12:17:04 <int-e> > a^3 == (a*a)*a
12:17:06 <lambdabot>   True
12:17:11 <Eduard_Munteanu> Huh.
12:17:19 <monochrom> hehehe
12:17:27 <int-e> > a^8 == ((a*a)*(a*a))*((a*a)*(a*a))
12:17:29 <lambdabot>   True
12:17:30 <FireFly> In my mind  f^n x  makes more sense to mean  f (f (... (f x)))  (n times), rather than being sugar for  (f x)^n  :\
12:17:33 <FireFly> (even on paper)
12:17:36 <int-e> @type a
12:17:38 <lambdabot> Expr
12:17:40 <Eduard_Munteanu> > (a + b) * c :: Expr
12:17:42 <lambdabot>   (a + b) * c
12:17:49 <Eduard_Munteanu> Ah.
12:17:56 <Eduard_Munteanu> > a^3 :: Expr
12:17:58 <lambdabot>   a * a * a
12:18:11 <monochrom> yes, f^n means what you said, except for sin, cos, tan
12:18:16 <int-e> > a*a*a == a*(a*a)
12:18:18 <lambdabot>   False
12:18:25 <FireFly> Oh, good
12:18:32 <Eduard_Munteanu> > sin^2 :: Expr
12:18:34 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
12:18:34 <lambdabot>              w...
12:18:37 <shachaf> monochrom: Doesn't sin^(-1) usually mean what FireFly said?
12:18:38 <monochrom> please do not assume that mathematicians are consistent
12:18:41 <DMcGill> FireFly: I've seen it used both ways in the same sentence without any explaination
12:18:53 <int-e> > (id^2) 10
12:18:54 <monochrom> ah, yes, more exceptions
12:18:55 <lambdabot>   100
12:18:56 <FireFly> DMcGill: joy
12:19:02 <ab9rf> shachaf: yes, mathematicians are inconsistent in using exponents on trig functions
12:19:04 <monochrom> please do not assume that mathematicians are consistent
12:19:07 <shachaf> Apply sin -1 times
12:19:18 <DMcGill> arcsin!
12:19:31 <shachaf> @arrrc sin
12:19:31 <lambdabot> Swab the deck!
12:19:33 <ab9rf> sin^2 x == (sin x)^2 but sin^-1 x == arcsin x
12:19:41 <int-e> yes, sin^(-1) is the inverse function. if you want to divide by sin(x), use cosec x
12:19:54 <DMcGill> and not, as might make sense, cosin
12:20:09 <int-e> or is it csc. hmm. :)
12:20:22 <DMcGill> this has caused me much annoyance over the years
12:20:30 <ab9rf> DMcGill: insane dried fruit
12:20:52 <Eduard_Munteanu> We're going off on tangents, though.
12:20:55 <monochrom> as Dijkstra points out, 3½, 33, 3x --- you're looking at (+), (\x y -> 10*x+y), (*) respectively
12:20:59 <ab9rf> Eduard_Munteanu: boo!
12:21:13 <DMcGill> http://en.wiktionary.org/wiki/cosin
12:21:41 <Eduard_Munteanu> We call tan tg here, and cot ctg, for some reason.
12:21:56 <Eduard_Munteanu> I guest tan/cot is more consistent with sin/cos.
12:21:59 <Eduard_Munteanu> *guess
12:22:22 <ab9rf> Eduard_Munteanu: i've seen tg used for tangent, although i hadn't identified a way to predict who uses tg vs tan
12:22:43 <Eduard_Munteanu> Ah, I guess it isn't a local thingy then.
12:22:53 <ab9rf> i've also seen sn and cs for sine and cosine, although frankly i think that's weird.
12:23:56 <DMcGill> I was reading a book that suddenly and with no explaination switched to defining functions from the right
12:24:24 <DMcGill> rather than `f (g x)' or even `g \circ f', suddently started using `f g' to mean that
12:24:25 <DMcGill> I think
12:24:29 <DMcGill> I'm still rather confused by it
12:24:58 <sellout-> DMcGill: f; g?
12:25:12 <shachaf> You can be sure that whatever mathematicians do most often, they'll be laziest about writing.
12:25:23 <DMcGill> I'm afraid I don't have the book to hand anymore, shachaf has the reason though
12:25:42 <Eduard_Munteanu> ab9rf: oh, I've seen sh and ch for sinh/cosh
12:26:19 <shachaf> sh a ch a f
12:26:23 <shachaf> a is function composition
12:27:13 <Eduard_Munteanu> Heh.
12:28:02 <FireFly> sh∘ch∘f
12:28:17 <tac> f g    is pretty standard in category theory once you hit the Lazy Threshold
12:28:34 <tac> It's also obnoxious because if F and G are functors and X and object, then FGX means F(G(X))
12:28:42 <tac> err
12:28:43 <DMcGill> tac: good to know it wasn't just the one book I read
12:28:47 <Eduard_Munteanu> @@ @run (@where rot13) "sh∘ch∘f"
12:28:47 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
12:28:52 <Eduard_Munteanu> Aw.
12:28:55 <tac> DMcGill: for category theory?
12:29:10 <DMcGill> it was about circular groups iirc but it used that notation
12:29:10 <tac> I have no idea how they keep track of all their awful notation :P
12:29:41 <Taneb> @@ @run (@where rot13) "sh.ch.f"
12:29:42 <Eduard_Munteanu> Yeah, that's sort of annoying.
12:29:43 <lambdabot>   "fu.pu.s"
12:30:22 <DMcGill> as usual ##math was no help at all when I asked :(
12:30:42 <FireFly> @help whree
12:30:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:30:46 <FireFly> @help where
12:30:46 <lambdabot> where <key>. Return element associated with key
12:31:00 <FireFly> Oh, I see
12:31:29 <FireFly> @where rot13
12:31:29 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
12:31:43 <average> hey
12:31:44 <FireFly> Well, that's terse
12:31:55 <Eduard_Munteanu> average: hi
12:31:58 <average> how do I implement my nickname in haskell ?
12:32:19 <DMcGill> working out means is a nice way to teach about scrictness!
12:32:19 <Eduard_Munteanu> average: you know the mathematical definition?
12:32:28 <DMcGill> strictness*
12:32:38 <monochrom> if memory footprint is not a big concern, sum xs / length xs
12:33:11 <average> monochrom: sounds very easy
12:33:21 <average> Eduard_Munteanu: yeah
12:33:27 <DMcGill> average: that's the thing about declarative programming
12:33:30 <fryguybob> @type \xs -> sum xs / length xs
12:33:31 <lambdabot>     No instance for (Fractional Int)
12:33:32 <lambdabot>       arising from a use of `/'
12:33:32 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
12:33:46 <DMcGill> average xs = sum xs / length xs
12:33:54 <Eduard_Munteanu> @hoogle average
12:33:55 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Rasterization FourTwoTwoAverage :: PixelFormat
12:33:55 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Rasterization FourTwoTwoRevAverage :: PixelFormat
12:34:00 <Eduard_Munteanu> Hrm.
12:34:02 <monochrom> oh, oops, sum xs / fromIntegral (length xs) then
12:34:03 <amiller> @type \xs -> div (sum xs) (length xs)
12:34:04 <DMcGill> on the other hand, that will fail for really big lists as it keeps it in memory the whole time
12:34:05 <lambdabot> [Int] -> Int
12:34:14 <fryguybob> @type \xs -> sum xs / genericLength xs
12:34:16 <lambdabot> Fractional b => [b] -> b
12:37:24 <A__A> > foldr (\(s,l) x -> (s+x,l+1)) (0,0) [1,2,3]
12:37:26 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = (t0, t1)
12:37:43 <A__A> > foldr (\x (s,l) -> (s+x,l+1)) (0,0) [1,2,3]
12:37:44 <lambdabot>   (6,3)
12:38:38 <DMcGill> > curry (/) $ foldl' (\(s,l) x -> (s+x,l+1)) (0,0) [1..1000]
12:38:40 <lambdabot>   *Exception: show: No overloading for function
12:38:42 <A__A> > let avg xs = let (sm, ln) = foldr (\x (s,l) -> (s+x,l+1)) (0,0) [1,2,3] in (fromIntegral sm / fromIntegral ln) in avg [1,2,3]
12:38:44 <lambdabot>   2.0
12:39:09 <FireFly> > let mfork f (+) g x = f x + g x; avg = mfork sum (/) genericLength in avg [1,2,3]
12:39:11 <lambdabot>   2.0
12:39:14 <DMcGill> surely you want foldl' rather than foldr here?
12:39:53 <A__A> foldl' ?
12:39:57 <A__A> @src foldl'
12:39:57 <lambdabot> foldl' f a []     = a
12:39:57 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:39:57 <DMcGill> that way the (sum, length) is strict and there are no references to the elements of the list already traversed
12:40:14 <A__A> @type foldl'
12:40:16 <lambdabot> (a -> b -> a) -> a -> [b] -> a
12:40:24 <DMcGill> hence `average' using foldl will be implemented in constant space
12:40:30 <DMcGill> foldl' I mean
12:40:50 <A__A> > let avg xs = let (sm, ln) = foldl' (\x (s,l) -> (s+x,l+1)) (0,0) [1,2,3] in (fromIntegral sm / fromIntegral ln) in avg [1,2,3]
12:40:51 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = (t0, t1)
12:41:05 <A__A> > let avg xs = let (sm, ln) = foldl' (\(s,l) x -> (s+x,l+1)) (0,0) [1,2,3] in (fromIntegral sm / fromIntegral ln) in avg [1,2,3]
12:41:07 <lambdabot>   2.0
12:41:18 <DMcGill> @pl mfork f g h x = f x `h` g x
12:41:18 <lambdabot> mfork = flip . (ap .) . flip (.)
12:42:42 <DMcGill> A__A: basically the difference between foldl' and foldr is that foldl' is strict in the accumulator which is good, whereas foldr gracefully handles an infinite list as its input
12:42:44 <_mike_> can you add a language extension to the already running ghci?
12:42:49 <DMcGill> from what I understand anyway
12:42:53 <Rotaerk> is there an easy way to search through all of hackage for implementations of a certain typeclass
12:43:05 <DMcGill> _mike_: :set -XArrows or whatever
12:43:15 <DMcGill> Rotaerk: try hoogle or hayoo
12:43:18 <_mike_> thanks
12:43:48 <Rotaerk> oh didn't notice the hackage documentation itself specified instances
12:44:01 <DMcGill> only instances in that package though
12:44:23 <DMcGill> for example, the only instances of Arrow in the Control.Arrow docs are (->) and Kleisli m
12:44:43 <DMcGill> that is, only instances in that package or in Prelude
12:47:20 <DMcGill> > liftA2 (+) 1 2
12:47:22 <lambdabot>   No instance for (GHC.Num.Num (f0 c0))
12:47:22 <lambdabot>    arising from a use of `e_1212'
12:47:22 <lambdabot>  Po...
12:47:28 <DMcGill> > :t liftA2 (+)
12:47:30 <lambdabot>   <hint>:1:1: parse error on input `:'
12:47:33 <DMcGill> :t liftA2 (+)
12:47:34 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
12:48:00 <DMcGill> > liftA2 (+) (+) (+) $ 1
12:48:02 <lambdabot>   *Exception: show: No overloading for function
12:48:50 <Palmik> maltem: I get "unrecognized option --cpp-options..."
12:49:06 <A__A> @src foldr
12:49:06 <lambdabot> foldr f z []     = z
12:49:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:49:17 <A__A> @src foldl
12:49:17 <lambdabot> foldl f z []     = z
12:49:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:50:05 <A__A> @src foldl'
12:50:05 <lambdabot> foldl' f a []     = a
12:50:05 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:52:38 <maltem> Palmik, oops. I confused .cabal fields and command line options
12:53:17 <tomh__> anyone familiar with http://hackage.haskell.org/packages/archive/Hipmunk/latest/ and knows how to store custom data like in the original library (http://chipmunk-physics.net/release/Chipmunk-5.x/Chipmunk-5.3.4-Docs/#cpBody)?
12:53:27 <maltem> Palmik, try --ghc-options then
12:54:24 <DMcGill> A__A: note the two websites www.foldl.com and www.foldr.com
12:55:04 <maltem> --ghc-options=-D, to be precise
12:56:05 <tomh__> felipe_: are you the maintainer of hipmunk by any chance?
12:57:25 <average> is haskell's infinite arithmetic based on continous fractions ?
12:57:34 <average> is it a symbolic thing ?
12:57:41 <average> or a lazy infinite-decimal vector thing ?
12:58:14 <average> Eduard_Munteanu: are you going to hackathon.ro on 20-21 april ?
12:58:22 <average> it's in like 6 days
13:05:09 <ChongLi> average: infinite arithmetic?
13:09:14 <Eduard_Munteanu> average: hm, didn't know about it
13:09:31 <Eduard_Munteanu> Not sure I will, feeling lazy. :)
13:09:47 <cdh473> lol
13:10:06 <mm_freak_> now this is really weird…
13:10:15 <mm_freak_> mappend :: (Monoid a) => [a] -> a
13:10:25 <mm_freak_> composeAll :: (Monoid a) => [a] -> a  -- xmonad
13:10:33 <mm_freak_> using composeAll works, but using mappend gives me a type error
13:11:01 <mm_freak_> i'd prefer to use mappend…
13:11:05 <lep-delete> :t mconcat
13:11:07 <lambdabot> Monoid a => [a] -> a
13:11:10 <mm_freak_> omg
13:11:14 <mm_freak_> i'm so stupid lol
13:11:16 <mm_freak_> thanks
13:11:27 <lep-delete> :>
13:11:51 <geekosaur> xmonad's <+> is mappend, composeAll is mconcat
13:13:42 <mm_freak_> geekosaur: yeah, the types suggested that, and i now switched to the Monoid functions i'm used to
13:14:10 <mm_freak_> (never understood why some libraries rename predefined functions anyway)
13:14:53 <geekosaur> (1) originally they were both specialized to ManageHook; (2) xmonad had <+> as infix mappend long before <> made it into ghc
13:15:49 <jfischoff> aristid: I get a signing error when I use copyObject. Other s3 methods work fine though. Any ideas?
13:15:51 <_mike_> is there a function that outputs numbers as english words?  func 10 => "ten"
13:16:18 <mm_freak_> geekosaur: historical reasons are about the only valid ones, but i've seen it being done in other cases
13:17:10 <geekosaur> in other cases, it's done for readability
13:17:14 <geekosaur> consider
13:17:17 <geekosaur> @src otherwise
13:17:18 <lambdabot> otherwise = True
13:17:39 <aristid> jfischoff: there's an existing bug report for that i think
13:17:42 <Guest13046> could someone help me with this function please? I have been reading and trying to figure this out but have had no such luck /wrists
13:17:46 <geekosaur> a guard ```| otherwise = ...``` is more readable than ```| True = ...```
13:17:46 <hpaste> Guest13046 pasted “wrapper” at http://hpaste.org/85800
13:17:52 <aristid> jfischoff: i just couldn't get around to seriously investigating this issue myself
13:18:05 <aristid> jfischoff: sorry.
13:18:30 <geekosaur> additionally, it allows the reprentation to change in the future without requiring people to rewrite code using it (or not rewrite as much)
13:18:35 <jfischoff> aristid: Is this the issue https://github.com/aristidb/aws/issues/48?
13:18:38 <Eduard_Munteanu> Guest13046: what's that supposed to do?
13:18:59 <aristid> jfischoff: you don't use ghc 7.6.1, do you?
13:19:03 <_mike_> Guest13046 you want to filter out numbers outside of the min/max range?
13:19:15 <mm_freak_> geekosaur: well, both 'True' and 'otherwise' are predefined, so my complaint doesn't apply =)
13:19:31 <jfischoff> aristid: 7.6.2
13:19:53 <mm_freak_> i mean if (>>=) were called 'bindMonadicAction' i could totally understand a library giving an (>>=) alias
13:20:06 <geekosaur> mm_freak_, was just a (well-enshrined) example.
13:20:10 <Guest13046> it is supposed to wrap around my previous function bounds1Accum and if the list passed to it is empty return nothing otherwise just return what bound1Accum normally returns
13:20:15 <Guest13046> ill post the previous function
13:20:20 <mm_freak_> anyway, i'm back to configuring ma xmonad =)
13:20:30 <geekosaur> if you're solely fixated on "omg an add on did this" and don't care about anything else, your worry is misfocused
13:20:33 <aristid> jfischoff: then very likely not
13:20:38 <aristid> jfischoff: i meant another issue anyways
13:20:48 <hpaste> Guest13046 pasted “wrapper” at http://hpaste.org/85801
13:21:05 <jfischoff> aristid: this one https://github.com/aristidb/aws/issues/54 ?
13:21:11 <aristid> jfischoff: yes.
13:21:20 * jfischoff is reading
13:21:24 <geekosaur> Guest13046, you are declaring [Integer] result type and then trying to return a Maybe
13:21:51 <aristid> jfischoff: at the bottom i say i'll experiment with it... which i haven't done yet. :P
13:22:11 <Guest13046> so like [Integer] -> Maybe ?
13:22:55 <jfischoff> aristid: Ok cool. This is very helpful :)
13:23:11 <DMcGill> _mike_ I don't know of one, it's much more complicated then it looks at first
13:23:32 <aristid> jfischoff: if you find a way to fix it, please consider sharing the details or making a pull request. i may be able to lift my ass out of my chair and actually releasing it then :D
13:23:48 <augustss> howdy
13:23:53 <aristid> hi augustss
13:25:12 <aristid> augustss: in this channel of more than a thousand people, you are probably the person who's been using it the longest :P
13:25:50 <geekosaur> Guest13046, I haven't yet worked out what exactly you're trying to do there. I also have no idea what line 4 of http://hpaste.org/85800 is supposed to be doing; as is, it defines a new binding named checked
13:28:33 <Philonous> geekosaur:  He wants to call bounds1Accumm iff l is the empty list, otherwise return "nothing". I took his "nothing" too literally, i think he means the empty list.
13:29:29 <Philonous> so bounds1 l min max = if null l then [] else bounds1Accum l min max
13:29:38 <A__A> i solved guest/mints problem before what was wrong witht hat solutino?
13:29:51 <Philonous> A__A:  You'd have to ask him
13:29:56 <A__A> > let mint mini maxi xs = foldr (\x (mi,ma) -> (min x mi, max x ma)) (mini,maxi) xs in map (mint 5 10) [[6,7,9],[3,6,9],[6,9,99],[3,6,99]]
13:29:58 <lambdabot>   [(5,10),(3,10),(5,99),(3,99)]
13:30:03 <A__A> > let mint mini maxi xs = foldr (\x (mi,ma) -> (min x mi, max x ma)) (mini,maxi) xs in map (mint 5 10) [[6,7,9],[3,6,9],[6,9,99],[3,6,99],[]]
13:30:05 <lambdabot>   [(5,10),(3,10),(5,99),(3,99),(5,10)]
13:30:10 <augur> ever notice how HOAS Lam and App are dual?
13:30:34 <Guest13046> there is a better explanation. A_A this is a different function using that one also
13:30:37 <augur> Lam :: (Exp a -> Exp b) -> Exp (a => b)   App :: Exp (a => b) -> (Exp a -> Exp b)
13:30:45 <A__A> > let mint mini maxi xs = foldr (\x (mi,ma) -> (min x mi, max x ma)) (mini,maxi) xs in map (mint 5 10) [[6,7,9],[3,6,9],[6,9,99],[3,6,99],[],[3,3,9]
13:30:46 <lambdabot>   <hint>:1:147: parse error (possibly incorrect indentation)
13:30:51 <A__A> > let mint mini maxi xs = foldr (\x (mi,ma) -> (min x mi, max x ma)) (mini,maxi) xs in map (mint 5 10) [[6,7,9],[3,6,9],[6,9,99],[3,6,99],[],[3,3,9]]
13:30:53 <lambdabot>   [(5,10),(3,10),(5,99),(3,99),(5,10),(3,10)]
13:30:56 <augur> App (Lam f) = f   ;   Lam (App f) = f
13:31:08 <augur> im sure this comes from the adjunction somehow
13:32:42 <Eduard_Munteanu> augur: more of an isomorphism?
13:32:44 <hpaste> Guest13046 pasted “wrapper” at http://hpaste.org/85803
13:32:50 <augur> Eduard_Munteanu: that too
13:33:06 <Guest13046> I wrote better explanation there sorry for the confusion
13:34:18 <Philonous> Guest13046:  bounds1 takes 1 parameter in line 9 and 3 in line 10
13:34:28 <augustss> aristid: I'm at least the person who have been writing and running Haskell the longest.
13:34:29 <Philonous> Guest13046:  That's not going to work
13:35:17 <aristid> augustss: oh yeah i notice my phrasing was poor
13:35:32 <aristid> augustss: when i said "it" i meant haskell
13:35:34 <shachaf> Hey, it's augustss.
13:35:36 <shachaf> hi augustss
13:36:00 <augustss> hi shachaf
13:36:04 <kennyd> > filter (liftA2 (&&) (>3) (<8)) [1..10]
13:36:06 <lambdabot>   [4,5,6,7]
13:36:15 <monochrom> oh hai
13:36:28 <kennyd> how would I incorporate third predicate there, say even ?
13:37:19 <shachaf> > filter (\x -> all ($ x) [(>3), (<8), even]) [1..10]
13:37:20 <Eduard_Munteanu> Did augustss return after a record-long absence?
13:37:22 <lambdabot>   [4,6]
13:37:39 <augustss> Not sure if it's a record.
13:37:49 <Philonous> >filter (\x -> x > 3 && x<8 && even x) [1..10]
13:37:52 <monochrom> liftA2 (&&) (liftA2 (&&) (>3) (<8)) even
13:37:53 <Philonous> > filter (\x -> x > 3 && x<8 && even x) [1..10]
13:37:55 <lambdabot>   [4,6]
13:38:30 <shachaf> augustss: lenses have gotten so great since the last time you were here.
13:38:44 <augustss> > let (&&&) = liftA2 (&&) in filter ((>3) &&& (<8) &&& even) [1..10]
13:38:44 <monochrom> at which point you just want to define myop = liftA2 (&&), and then write (>3) `myop` (<8) `myop` even
13:38:46 <lambdabot>   [4,6]
13:38:54 <aristid> shachaf: so he was here before 3.7?
13:39:14 <augustss> yeah, lenses are pretty cool now
13:39:26 <kennyd> good ideas, thanks
13:39:27 <ChongLi> > [x | x <- [1..10], x > 3, x < 8, even x]
13:39:28 <lambdabot>   [4,6]
13:39:29 <shachaf> Profunctors and prisms and everything.
13:39:35 <aristid> shachaf: if we divide time by lens releases, what do we do for the time before the first release?
13:40:06 <augustss> All I use of lenses fits on 10 lines.
13:40:15 <shachaf> aristid: The first commit to lens was on my birthday. Coïncidence?
13:40:26 <aristid> shachaf: diaresis.
13:40:39 <Eduard_Munteanu> That sounds wrong.
13:40:43 <shachaf> augustss: Well, "lens" does a lot more than lenses now! It's misnamed.
13:40:57 <aristid> it should be named profunctor-prism-lens
13:41:00 <int-e> "glue"?
13:41:20 <byorgey> that's because it is wrong.  I'm guessing aristid actually meant "diaeresis".
13:41:20 <monochrom> redefine: l.e.n.s. = library of edwardk's neat stuff
13:41:22 <byorgey> =)
13:41:34 <Eduard_Munteanu> Yep.
13:41:41 <monochrom> glue also works
13:41:43 <byorgey> monochrom++
13:41:48 <aristid> byorgey: anyways, something that looks like an umlaut but is none!
13:41:50 <shachaf> diæresis
13:41:59 <int-e> monochrom: but putting glue on lenses seems wrong :)
13:42:26 <jfischoff> augustss: do you still use LLVM.Core or have you moved onto bigger and better things?
13:42:35 <aristid> monochrom: lens does have unity of purpose
13:42:39 <monochrom> g.l.u.e. = generalized library of utilities of edwardk!
13:43:06 <augustss> fjischoff: I still use it.  That reminds me, I need to upload a new version of the LLVM package.
13:43:10 <monochrom> hmm, even that is not cool enough
13:43:13 <aristid> it really is all about lenses and prisms and traversals and things in that continuum/hierarchy
13:43:32 <joeyh> is there a GHC extension that allows nesting 'data instance Foo Bar'  inside 'instance Someting Bar' ?
13:43:44 <_mike-> ChongLi probably the nicest one
13:44:41 <byorgey> joeyh: TypeFamilies?
13:45:05 <byorgey> joeyh: except in that case you just write  'data Foo Bar = ...'  not  'data instance Foo Bar'
13:45:15 <joeyh> hmm, I already have that one
13:45:21 <shachaf> augustss: Perhaps you know the answer to my question: What's a good minimal extension/axiom thing to add to Haskell to let you write foo :: (forall p. p Char -> p Bool) -> Void?
13:45:27 <jfischoff> augustss: a new package would cause much rejoicing :)
13:45:32 <ChongLi> _mike-: yeah I love list comprehensions
13:45:35 <joeyh> I'm seeing the nesting in -ddump-splices output, so maybe it's a representation of ghc's internals and not valid code
13:45:38 <shachaf> GADTs and TypeFamilies both let you do it, but those are huge extensions.
13:47:03 <joeyh> (and by nesting, I mean, inside the instance's where clause)
13:47:03 <augustss> shachaf: hmmm, you need something to reflects that all types are unequal.  I'm not sure what that should be.
13:47:31 <shachaf> Right. I don't know how to express it exactly.
13:47:35 <jmcarthur> joeyh: just don't say "instance" when you're already inside a type class instance and it should just work
13:47:53 <shachaf> GADTs do it in an implicit sort of way by not showing warnings when matching on a certain thing would lead to a unification error.
13:48:42 <joeyh> jmcarthur: aha, so it does!
13:49:08 <shachaf> augustss: Haskell is also consistent with bar :: p Char -> p Int as far as I can tell.
13:49:21 <joeyh> this is not the first time I've seen ghc's -dump-splices code be invalid. It also escapes \{ inside multi-line strings
13:49:27 <joeyh> suppose I should file some bugs..
13:49:29 <shachaf> And maybe with HoTT you can actually get that sort of thing.
13:49:37 <shachaf> I don't know.
13:49:45 <elliott> might be best to pick two isomorphic types :P
13:50:08 * byorgey already said that =P
13:50:13 <augustss> shachaf: inequalities have been a bit of a sore point in TT
13:50:28 <shachaf> elliott: Char and Int are totally isomorphic, man.
13:50:47 <shachaf> I mean, come on. ord/chr.
13:51:14 <augustss> Char has fewer elements than Int
13:51:24 * shachaf wasn't being serious there
13:51:41 <byorgey> @check \x -> ord (chr x) == x
13:51:43 <lambdabot>   Not in scope: `myquickcheck'
13:51:44 <shachaf> augustss: GeneralizedNewtypeDeriving, implemented the evil way, more or less gives you "Is Oldtype Newtype".
13:51:46 <byorgey> bah
13:51:50 <aristid> shachaf: it's possible to write something of type Iso between them, THUS they are isomorphic QED
13:52:03 <augustss> shachaf: I'm against evil
13:52:05 <bitonic> shachaf: HoTT if anything goes in the other direction, I doubt any of the familiar type theories let you inhabit that
13:52:24 <shachaf> augustss: So I think maybe the evil way is even consistent with regular Haskell+RankNTypes -- all the ways I've seen to get unsafeCoerce etc. have invovled GADTs/TypeFamilies/something like that.
13:52:33 <bitonic> I mean HoTT lets you prove *more* things equal than the usual ITT or even ETT
13:52:48 <shachaf> bitonic: Right, that's what I meant.
13:53:05 <FireFly> What is 'HoTT' expanded?
13:53:13 <bitonic> FireFly: Homotopy Type Theory
13:53:14 <shachaf> HoTT Type Theory
13:53:20 <monochrom> hahaha
13:53:23 <shachaf> Or that.
13:53:33 <bitonic> :)
13:53:34 <FireFly> You and your funpuns
13:54:00 <augustss> It really is HOT at the moment (no pun intended).
13:54:02 <shachaf> augustss: Until you take down that BASIC compiler I refuse to believe that you're against evil, by the way.
13:54:10 * monochrom prefers: hott = homotopy hott type theory, atm = automatic atm teller machine
13:54:10 <augustss> If it's actually useful, I dunno.
13:54:17 <shachaf> Actually I refuse to believe it anyway.
13:54:39 * monochrom raises the stake further! atm = automatic atm teller atm machine
13:54:41 <elliott> o stands for hott?
13:54:51 <FireFly> hOtt
13:54:52 <aristid> elliott: yes
13:55:41 <aristid> HOTT really stands for Hott hOtt hoTt hotT
13:55:50 <shachaf> It's actually Holmium Type Theory
13:56:29 <monochrom> parsec exercise! write a program to parse this grammar: atm ::= automatic atm teller atm machine | bank
13:57:15 <mauke> atm = do { string "automatic"; atm; string "teller"; atm; string "machine" } <|> string "bank"
13:57:30 <monochrom> \∩/
13:57:52 <mauke> now do it with a regex
13:58:17 <average> mauke: can I have a word with you ?
13:58:46 <shachaf> Teller machine? I'd rather teller in person!
13:58:50 <mauke> average: are you spetrea?
13:59:47 <average> mauke: yeah
14:00:15 --- mode: ChanServ set +o mauke
14:00:15 --- mode: mauke set +b *!*@188.26.210.134
14:00:18 --- kick: average was kicked by mauke (average)
14:00:30 <mauke> fucking ban evaders
14:00:51 <monochrom> what did he do previously?
14:01:15 <mauke> evade another ban
14:01:22 <Peaker> I ported some Python code that I don't understand to Haskell. Then it didn't immediately work. So I wanted to know what changed -- so I added debug traces to both, and compared. Laziness made things tricky to compare (Different order)...
14:01:36 <Peaker> most of my prints were in the State monad with   tracePutStrLn x = trace x $ return ().  I switched to Control.Monad.Trans.State.Strict and then wasted 2 hours still not figuring out why the order was messed up :(  Until I eventually realized it's only strict on the result tuple of the function inside the StateT constructor, and not on the state... once I made it strict on the state, all the prints were in order...
14:02:17 <Peaker> I think maybe the Strict State monad should export strict "state", "put", "modify" functions that don't ever throw away the input state..
14:02:18 --- mode: mauke set -o mauke
14:02:42 <shachaf> Eventually it turns out this person has only ever been banned for evading bans.
14:02:50 <shachaf> Not a well-founded ban.
14:03:02 <int-e> shachaf: it's called tying the knot
14:03:24 <monochrom> I was wondering whether there was a First Cause, too :)
14:04:55 <DMcGill> it's bans all the way down
14:06:18 <k00mi>  
14:07:01 <int-e> > let banned nick reason = nick ++ " banned because " ++ reason; evaded nick1 ban = banned nick1 ("evading ban (" ++ ban ++ ")"); b1 = banned "foo" "obnoxious"; b2 = evaded "bar" b1; b3 = evaded "average" b4; b4 = evaded "spetrea" b3 in (b1, b2, b3, b4)
14:07:04 <lambdabot>   ("foo banned because obnoxious","bar banned because evading ban (foo banned...
14:07:39 <int-e> (yay, a /hidden/ joke)
14:08:16 <bitonic> shachaf: btw, that type you posted is at odds with parametricity
14:08:33 <shachaf> bitonic: Which one?
14:08:41 <bitonic> shachaf: ‘foo’
14:08:46 <shachaf> Why?
14:08:57 <hpaste> bitonic pasted “how I'd do it in Agda” at http://hpaste.org/85806
14:09:14 <nade> hey all, I seem to be having problems installing hoogle on OSX. I've tried running both "cabal install hoogle" and "sudo cabal install hoogle --global". I was thinking that it would place an executable somewhere, such that i could run it from the command line and GHCI, but it doesn't seem to be found. I'm tempted to just copy / symlink it at /Library/Haskell/ghc-7.4.2/lib/hoogle/bin/. But I figured I should ask for help first
14:09:38 <bitonic> shachaf: well my intuition is that you’d need to ‘pattern match’ on types to prove their inequality, so to speak.  Saizan can probably give a more principled explanation, or call me wrong
14:10:07 <Saizan> bitonic: you can actually prove that by a cardinality argument
14:10:19 <bitonic> Saizan: in Agda?
14:10:21 <Cale> nade: When you cabal install binaries, at least on linux, they end up in ~/.cabal/bin which I usually end up turning into a symlink to ~/bin
14:10:31 <elliott> bitonic: you can write (p Char -> p Void) -> Void
14:10:32 <elliott> er
14:10:36 <elliott> bitonic: you can write (forall p. p Char -> p Void) -> Void
14:10:50 <elliott> (s/Char/any type with at least one inhabitant/)
14:11:07 <bitonic> elliott: but I’m not using ‘p Void’
14:11:32 <Saizan> bitonic: you can prove Char /= Bool in agda by simply observing that Bool has 2 values and Char has more
14:11:52 <Saizan> bitonic: but you can't prove Fin 2 /= Bool
14:12:23 <bitonic> Saizan: so wait, you can derive ‘Char ≢ Bool’?  then you can derive shachaf term
14:12:41 <Saizan> bitonic: what's shachaf term?
14:12:43 <nade> Cale: Well.... do you think I ought to try and do that manually...? I'm hesitant to because I imagine it wasn't done for a reason... Whenever I try to run the hoogle command in GHCI I get an error /bin/sh: hoogle: command not found
14:13:13 <bitonic> Saizan: my Agda rendition is ‘foo : ((P : Set → Set₁) → P Char → P Bool) → ⊥’, a universe polymorphic version would probably be more accurate
14:13:56 <bitonic> if you have ‘Char≢Bool : Char ≢ Bool’, then it’s simply ‘foo f = Char≢Bool (f (λ X → Char ≡ X) refl)’
14:14:07 <Saizan> bitonic: yeah, you can prove that
14:14:20 <bitonic> oh cool!  then give me a minute to figure Char≢Bool out
14:15:14 * osfameron imagines it would take him more than a minute to figure out how to *type* ≢
14:15:15 <Eduard_Munteanu> Wouldn't this sort of let you write an eliminator for Set?
14:15:19 <osfameron> as in, type it on a keyboard
14:15:35 <Saizan> \==n
14:15:45 <bitonic> Eduard_Munteanu: that’s kind of why I brought up parametricity
14:15:49 <Saizan> M-x describe-char would tell you
14:15:57 <osfameron> Saizan: huh?
14:16:07 <Eduard_Munteanu> osfameron: in agda-mode
14:16:13 <Saizan> osfameron: in emacs, where Agda developement is done
14:16:36 <osfameron> oh. Agda requires emacs?  eeek
14:16:43 <bitonic> shachaf: so definitional equality is enough to prove your term
14:16:57 <Eduard_Munteanu> osfameron: not really, but it's rather masochistic not to use Emacs for it
14:17:10 <Saizan> bitonic: you need prop.eq for this reasoning
14:17:12 <bitonic> in System Fc you have a surrogate which is probably not enough...
14:17:18 <bitonic> yes sorry, prop. eq
14:17:53 <Eduard_Munteanu> What surrogate?
14:18:16 <bitonic> Eduard_Munteanu: well, GHC type equalities
14:18:29 <bitonic> System Fc type equalities, those ~ things :P
14:18:44 <Eduard_Munteanu> Ah.
14:19:09 <Saizan> with GHC equality is even easier to prove this
14:19:32 <Saizan> but shachaf was talking about what happens without those
14:19:44 <bitonic> ah!  I keep being wrong on various dimensions tonight.
14:20:23 <Saizan> (fsvo "prove", of course)
14:20:58 <bitonic> Saizan: well there is some derivation concerning ~ for that thing.  actually now that you say I can see how it can be easier (coercions and all that...)
14:22:23 <Saizan> i'm thinking of either the exhaustiveness checks or using a typefamily to typecase and cast a value of () into one of Voide
14:22:26 <Saizan> *Void
14:24:02 <Eduard_Munteanu> Ye voide type.
14:25:40 <eikke> integrating MonadResource in some custom monad stack is no fun :-@
14:27:43 <nade> Cale: I figured it out. I had to make a quick edit to my baschrc file
14:28:21 <mm_freak_> eikke: why?  it's really no different than MonadReader or others
14:31:04 <bitonic> Saizan: would the proof be along the line of using ‘subst’ with ‘Iso Char’, and then derive absurdity with the bijection that you’d have from Bool to Char?
14:32:07 <Saizan> bitonic: yeah
14:32:47 <bitonic> right
14:33:44 <bitonic> cool for some reason I thought this was out of Agda’s prop.eq reach
14:34:32 <eikke> mm_freak_: requires MonadBaseControl IO myM being provided
14:34:45 <eikke> mm_freak_: or something like that. I might be messing up though :)
14:34:46 <Saizan> in fact type equality in HoTT for finite sets is basically the equivalence class on the number of elements
14:35:09 <bitonic> makes sense
14:35:55 <Saizan> (which irks pigworker since so much structure is overlooked that way)
14:36:04 <bitonic> but there are more ways to derive those equalities in HoTT—e.g. from Bool to Bool you have two bijections to chose from
14:36:32 <Saizan> yep
14:37:00 <bitonic> shachaf: well I’m not sure if this adds anything but in ITT you can do that :P
14:38:05 <mm_freak_> eikke: that's why i always put ResourceT at the bottom of my stack =)
14:38:31 <mm_freak_> eikke: but i'm familiar with the problem that MonadBaseControl often can't be derived even with StandaloneDeriving
14:39:19 <eikke> mm_freak_: indeed
14:42:09 <A__A> > map 1 $ map (>) [1..10]
14:42:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
14:42:30 <A__A> > map (>) [1..10]
14:42:31 <lambdabot>   *Exception: showList: No overloading for function
14:42:39 <Peaker> 1 here is "const 1", because it's Caleskell
14:43:12 <XexonixXexillion> > map ($ 1) $ map (>) [1..10]
14:43:14 <lambdabot>   [False,True,True,True,True,True,True,True,True,True]
14:43:18 <mauke> s/Caleskell/NumInstances/
14:44:05 <eikke> mm_freak_: success! :)
14:44:21 <A__A> cant i map a 2 arg fun on a list and then map a nbr on the list for results?
14:44:33 <A__A> > map 3 $ map (<) [1..10]
14:44:35 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
14:44:50 <XexonixXexillion> > map ($ 3) $ map (<) [1..10]
14:44:52 <lambdabot>   [True,True,False,False,False,False,False,False,False,False]
14:44:58 <A__A> > map (\f -> f 1) $ map (<) [1..10]
14:45:00 <lambdabot>   [False,False,False,False,False,False,False,False,False,False]
14:45:13 <A__A> > map ($ 3) $ map (<) [1..10]
14:45:15 <lambdabot>   [True,True,False,False,False,False,False,False,False,False]
14:45:20 <A__A> > map (id 3) $ map (<) [1..10]
14:45:22 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
14:45:31 <A__A> @src ($)
14:45:32 <lambdabot> f $ x = f x
14:48:12 <parcs> flip id
14:52:10 <quchen> No flip.
14:52:18 <quchen> It's id id. :-)
14:55:32 <mauke> @let di = flip id
14:55:34 <lambdabot>  Defined.
14:58:22 <Eduard_Munteanu> That sounds like a bash-ism.
14:58:29 <shachaf> Algol-ism?
14:58:46 * Eduard_Munteanu is too young :(
14:59:33 <shachaf> Should've been bourne earlier.
14:59:40 <Eduard_Munteanu> Hehe.
14:59:51 <Eduard_Munteanu> shachaf: you could be bourne again
15:02:40 <Peaker> @faq Can Haskell increase your wit in other languages?
15:02:41 <lambdabot> The answer is: Yes! Haskell can do that.
15:04:28 <Eduard_Munteanu> Subject: WIT ENLARGING LANGUAGES
15:04:38 <int-e> @faq Can Haskell make your hair fall out?
15:04:39 <lambdabot> The answer is: Yes! Haskell can do that.
15:04:55 <int-e> That explains a lot :)))
15:05:35 <Eduard_Munteanu> Hair is conserved, it just moves from your scalp to the beard.
15:06:11 <geekosaur> can't be perfectly conserved as some of us lack beards...
15:08:13 <hpaste> bitonic pasted “Saizan shachaf” at http://hpaste.org/85809
15:08:18 <A__A> > map (+9) [1..10]
15:08:19 <lambdabot>   [10,11,12,13,14,15,16,17,18,19]
15:08:23 <bitonic> Saizan: that took longer than expected... :P
15:09:11 <A__A> > foldl (\x y -> x < y) 0 [1..10]
15:09:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
15:09:14 <lambdabot>    arising from the literal `0...
15:09:51 <A__A> > foldl (\x y -> (x < y,x)) (_,0) [1..10]
15:09:52 <lambdabot>   Pattern syntax in expression context: _
15:09:56 <A__A> > foldl (\x y -> (x < y,x)) (False,0) [1..10]
15:09:57 <bitonic> it’s obvious in hindsight.  sigh.
15:09:58 <lambdabot>   Occurs check: cannot construct the infinite type:
15:09:58 <lambdabot>    t0 = (GHC.Types.Bool, ...
15:10:23 <A__A> > foldl (\x y -> (snd x < y,snd x)) (False,0) [1..10]
15:10:25 <lambdabot>   (True,0)
15:10:58 <A__A> > foldl (\x y -> (snd x < y,snd x):) [(False,0)] [1..10]
15:10:59 <lambdabot>   <hint>:1:34: parse error on input `)'
15:24:23 <hpaste> joe pasted “RandomRIO help” at http://hpaste.org/85811
15:26:05 <hpaste> allenj12 pasted “RandomRIO help” at http://hpaste.org/85812
15:27:18 <hpc> when you have a question, it generally helps to ask it ;)
15:27:29 <Eduard_Munteanu> Obviously that's something in the IO monad.
15:27:46 <Eduard_Munteanu> But makeArgument isn't.
15:28:55 <allenj12> so how would we go about fixing that?
15:29:33 <Eduard_Munteanu> allenj12: do you want to keep makeArgument pure?
15:29:59 <allenj12> well i do need to randomize in that fuction for later so i guess not
15:30:46 <Eduard_Munteanu> You need something ... -> IO String then I guess.
15:31:00 <Eduard_Munteanu> Either that, or pass around a list of random numbers.
15:31:19 <Eduard_Munteanu> (but then you still need to track state somehow)
15:32:23 <allenj12> ok i changed it to IO string it works THANK YOU!
15:34:30 <A__A> > zipWith (+) [1..10] (reverse [-10,-9,..-1]
15:34:32 <lambdabot>   <hint>:1:43: parse error (possibly incorrect indentation)
15:34:43 <A__A> > (reverse [-10,-9,..-1]
15:34:44 <lambdabot>   <hint>:1:23: parse error (possibly incorrect indentation)
15:34:48 <A__A> > (reverse [-10,-9..-1]
15:34:50 <lambdabot>   <hint>:1:22: parse error (possibly incorrect indentation)
15:35:01 <A__A> > [1,2..10]
15:35:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:35:30 <A__A> > [1,3..10]
15:35:31 <lambdabot>   [1,3,5,7,9]
15:35:56 <A__A> > (reverse [-10,-9,..-1])
15:35:58 <lambdabot>   A section must be enclosed in parentheses thus: (..- 1)Not in scope: `..-'
15:36:14 <A__A> > (reverse [(-10),(-9),..(-1)])
15:36:16 <lambdabot>   <hint>:1:22: parse error on input `..'
15:36:20 <A__A> > (reverse [(-10),(-9)..(-1)])
15:36:22 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
15:36:23 <A__A> lol i suck
15:36:40 <A__A> > zipWith (+) [1..10] (reverse [(-10),(-9)..(-1)])
15:36:41 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
15:37:33 <Rembane_> > [(-10),(-9)..(-1)]
15:37:35 <lambdabot>   [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1]
15:37:48 <Rembane_> :D
15:45:05 * hackagebot conjugateGradient 1.0 - Sparse matrix linear-equation solver  http://hackage.haskell.org/package/conjugateGradient-1.0 (LeventErkok)
16:46:35 <germanmafia> so i'm trying to upgrade my ghci version from 7.0.3 to something newer (so I can use the new function writing syntax, rather than using "let" for my functions), however, when I compile ghc from source, ghci doesn't come with it - (ghc version 7.6.2), how do i upgrade ghci too?
16:48:00 <typoclass> germanmafia: do you really need to compile from source? there's binaries on the website and they are way easier
16:48:04 <hpc> ghci should come with it
16:48:05 <hpc> also that
16:49:18 <shachaf> germanmafia: If you're not developing GHC you should probably get the binary rather than compile from source.
16:49:25 <shachaf> Anyway, ghci is just ghc --interactive
16:49:40 <shachaf> I suppose whether you get it depends on how you installed it.
16:49:42 <germanmafia> alright, i'll check it out - apt-get won't let me upgrade my version of haskell
16:50:05 <shachaf> You can just download a binary .tar.bz2
16:50:24 <monochrom> I once built from source a long time ago. but it built ghci alright. make sure you're doing it right. 2 stages, not 1.
16:50:39 <hpc> compiling ghc from source is only to be done as a learning exercise, a step in developing ghc, or to make people think you are a hacker as warnings scroll by
16:50:42 <shachaf> I build from source semiregularly.
16:51:01 <germanmafia> is compiling from source the same as using "./configure" then make and installing?
16:51:12 <hpc> essentially
16:51:16 <shachaf> Maybe.
16:51:25 <hpc> the process is slightly different for bootstrapping
16:51:31 <shachaf> That depends on where you use "./configure" and then make and installing.
16:51:40 <monochrom> then again, the default build process already does everything right. you have to work hard to break it.
16:51:43 <hpc> :t installing
16:51:45 <lambdabot> Not in scope: `installing'
16:52:18 <[swift]> anyone know how dupChan behaves, exactly? the docs are unclear. if i have several readers and one writer, and the writer writes a value to the dupChan'd channel which is then read by one reader using readChan, will the other readers also see that value?
16:52:55 <germanmafia> so what's the difference between "haskell" and "ghc"? is it similar to c++ being compiled by ghc?
16:53:25 <hpc> germanmafia: haskell is the language, ghc is the compiler
16:53:48 <hpc> "ghc haskell" is the particular brand of haskell with bugs and design decisions that is specific to ghc
16:53:51 <monochrom> if you don't dupChan, one reader sees a message, the other reader will not see it. if you dupChan, both readers see the same message
16:54:16 <germanmafia> okay, do i need the 'haskell platform' or can i get by with just ghc?
16:54:22 <hpc> [swift]: in other words, one input queue, many output queues
16:54:32 <[swift]> monochrom: oh, so the channel can support multiple concurrent readers _without_ dupChan? cool, thanks
16:54:54 <[swift]> that makes sense
16:54:58 <hpc> [swift]: if you pass the same chan to two threads, say
16:55:04 <hpc> now you write 1 to the chan, then 2
16:55:12 <hpc> a thread reads from the chan and sees 1
16:55:18 <hpc> another thread reads and sees 2
16:55:29 <hpc> now if you dupe the thread, then send 1 and 2
16:55:33 <hpc> thread reads and sees 1
16:55:41 <napping> germanmafia: you can get by fine with a binary ghc
16:55:42 <hpc> another thread reads from the dupe and also sees 1
16:56:02 <arkeet> sure you can get by, but you won't have a lot of things you probably really want. like cabal-install
16:56:05 <[swift]> hpc: very nice!
16:56:13 <germanmafia> alright awesome, thanks for the help (i like asking you guys questions, you're one of the most helpful and responsive irc channels I've been on!)
16:56:23 <arkeet> haskell platform is probably what you want if you're getting started.
16:56:24 <hpc> [swift]: hence "broadcast"; it could definitely be clearer though
16:56:48 <napping> germanmafia: also, compiling a ghc from source should give you a ghci
16:57:02 <[swift]> hpc: that's what i figured but i was confused because it wasn't immediately apparent to me that it was safe to share the channel between threads at all without calling dupChan
16:57:03 <napping> arkeet: are you sure it doesn't come with cabal-install?
16:57:06 <arkeet> I am.
16:57:17 <napping> guess I've just had cabal-installs lying around
16:57:17 <arkeet> it comes with Cabal.
16:57:26 <hpc> chans are very explicitly made for thread sharing ;)
16:57:27 <arkeet> but not the executable.
16:57:30 <germanmafia> ghc --interactive worked, so i just aliased it for the moment (ghci --> ghc --interactive)
16:57:46 <hpc> germanmafia: that's what happens anyway
16:57:49 <napping> I guess the executable just uses whatever ghc is on your path?
16:58:37 <napping> germanmafia: without the platform you might just have to 1) install a few more packages yourself, and 2) run into problems with installing too many/incompatible packages a bit sooner
16:58:52 <[swift]> hpc: of course =) thought it might have been 1 reader 1 writer though
16:59:03 <germanmafia> okay, well if i hit too many snags i'll wipe it out and try again
16:59:26 * [swift] has had too many bad experiences with C++ concurrency libraries and is now skittish
16:59:31 <napping> I figure you will run into that eventually anyway even with the platform, and if you're first instinct was to build from source you probably won't be put off by cleaning up after that
17:00:46 <germanmafia> alright, up and running! time to see what everyone is talking about, thanks again for the help
17:02:00 <germanmafia> one more question - is there a function or something to call to exit the interactive session? i always just ctrl+z, but that doesn't seem like the 'right' way to do it
17:02:30 <typoclass> germanmafia: ctrl-d works for me
17:03:00 <cmears> Or ":quit"
17:03:12 <hpaste> jfischoff pasted “confused by type error” at http://hpaste.org/85813
17:03:20 <typoclass> cmears: yeah ... but that sounds like a lot of work :-)
17:03:42 <cmears> Yes, I would always do Control-d (:
17:04:00 <jfischoff> elliott, shachaf: any ideas ^
17:08:40 <niteria> are haskell threads really that cheap? making 2 threads to merge 2 streams makes me uneasy
17:09:00 <jfischoff> wait I see …
17:10:20 <jfischoff> higher kinded traversable is maybe not that useful, with the form I have chosen …
17:10:29 <dmwit> niteria: Define "that cheap". But probably yes.
17:11:06 <typoclass> jfischoff: i can't pretend that i understand anything in that paste, but just to be sure -- does "(Applicative f, Functor g, Functor h) => (forall a. g a -> f (h a))" fit into "Apply f => (a -> f b)"?
17:11:19 <Peaker> jfischoff, hey
17:11:26 <Peaker> jfischoff, you emailed about nice font rendering
17:11:38 <jfischoff> Peaker: oh cool what are your thoughts?
17:11:41 <niteria> dmwit: guess I want to have some model of cost of haskell threads, best way would be to know how they are implemented and how they interact with os threads
17:11:50 <Peaker> jfischoff, does FTGL with ordinary TTF not do that? I don't know that much about the fonts under the hood...
17:11:51 <jfischoff> typoclass: I'll check that out
17:12:09 <dmwit> niteria: Check out dmwit.com/gtk2hs and especially the papers linked at the end.
17:12:15 <jfischoff> Peaker: not as far as I could tell
17:12:31 <dmwit> There's a little bit that's gtk2hs-specific, but not much, and it's easy to tell which it is and skip it.
17:12:38 <typoclass> jfischoff: i was assuming traverse1 is from here http://hackage.haskell.org/packages/archive/semigroupoids/3.0.0.1/doc/html/Data-Semigroup-Traversable.html
17:12:53 <jfischoff> typoclass: oh no it is something I made up ;)
17:13:01 <Peaker> jfischoff, it sounds like the right place to support it is in that kind of lib, right?
17:13:06 <typoclass> jfischoff: ugh :-) oh i see
17:13:14 <jfischoff> Peaker: yeah
17:13:27 <typoclass> jfischoff: never mind then
17:13:48 <jfischoff> jfischoff: but I would be more interested in doing the work if I knew that someone was going to use it
17:13:52 <niteria> dmwit: thanks! that looks usefull
17:15:24 <Peaker> jfischoff, sure, it sounds interesting.. also it sounds like lots of people would love any quality improvement in their fonts library
17:15:45 <jfischoff> probably true
17:15:52 <jfischoff> okay I'll check out the lib
17:18:09 <Peaker> some background in case you haven't tinkered with these libs: There's the FreeType2 library which I think virtually everyone uses for working with true type (and other?) fonts. Then there are wrappers for FreeType for GL, the main one is FTGL which lets you render to GL with it
17:23:02 <jfischoff> Peaker: I took a look at FreeType2 briefly and it seems fine for my purposes
17:23:34 <A__A> correct behaviour of a device || correct behaviour by a device? any britons in here?
17:24:14 <niteria> I've never seen "behaviour by", but I'm not a native speaker
17:24:21 <cmears> "of" is better
17:24:31 <cmears> (but I am only Australian)
17:24:40 <Eduard_Munteanu> There's "behavior on X's part" I think.
17:24:42 <dmwit> "of", but YMMV IANAB
17:25:11 <Eduard_Munteanu> "by" is odd.
17:26:02 <typoclass> cmears: ɐılɐɹʇsnɐ ıɐɥo
17:26:19 <cmears> That's a good one, never heard it before
17:26:34 <ab9rf> how do you pronounce that?
17:26:59 <niteria> lambdabot needs zalgo
17:27:01 <dmwit> Hey, I have another one I bet you've never heard. "Ah, so you're joining us from the LAN down under?"
17:27:10 <Eduard_Munteanu> They read that normally in Australia, they're upside down. :P
17:27:20 <cmears> Ha, I actually haven't heard that one before (:
17:28:14 <typoclass> cmears: i wonder why the australians groan so much at those jokes :-) i mean, it's true. things *are* upside down. it's just that you don't notice because the floor and gravity and people are also upside down
17:28:37 <cmears> ...
17:28:56 <cmears> (:
17:30:01 * typoclass refrains from making any comments about cmears' smileys
17:33:52 <Eduard_Munteanu> See... just like Eastern people use a right-to-left script. :)
17:34:37 <typoclass> Eduard_Munteanu: o...m...g. you're right
17:40:47 <nbouscal> I'm trying to do the exercises on Typeclassopedia and am struggling (so much for thinking I understood some of this stuff). Trying to write a Functor instance for ITree
17:41:08 <nbouscal> I have fmap f (Leaf g) = (Leaf (g . f))
17:41:18 <nbouscal> and fmap f (Node ts) = map (fmap f) ts
17:41:25 <nbouscal> the latter doesn't type check and I'm not following why
17:41:53 <Eduard_Munteanu> What's ITree?
17:42:13 <nbouscal> sorry. data ITree a = Leaf (Int -> a) | Node [ITree a]
17:43:34 <aavogt> nbouscal: maybe you'll see the mistake if you write `fmap f (Leaf g) = (Leaf (g . f))' with the argument explicit
17:44:29 <nbouscal> that should be f . g, huh
17:44:44 <hxs> hey, can anyone point a beginner to a good tutorial?
17:45:03 <nbouscal> I enjoyed www.learnyouahaskell.com a lot
17:45:21 <hxs> thanks, i'll check it out
17:45:40 <aavogt> nbouscal: exactly
17:45:57 <nbouscal> aavogt: thanks. I'm still not seeing the problem in the second part, though
17:46:22 <aavogt> map gives you a list back
17:46:38 <aavogt> but the result is supposed to have a Node constructor applied
17:46:40 <nbouscal> oh i need to wrap it in a node
17:46:42 <hxs> anyone ever use it for web development? how did it go?
17:47:00 <nbouscal> hxs: I got the book about Yesod but haven't started it yet
17:47:07 <nbouscal> aavogt: thanks :)
17:48:09 <aavogt> nbouscal: you can get ghc to write those instances too (-XDeriveFunctor)
17:48:29 <nbouscal> yes i figured i could, doing them as Exercises though so that defeats the purpose a bit i think :)
17:48:52 <nbouscal> working my way through Typeclassopedia on the wiki
17:49:08 <aavogt> the generated code isn't that ugly either http://hpaste.org/85814
17:50:51 <derek_c> Hello! I'm developing a performance-critical application and I'm considering which package to use to download web pages
17:51:10 <derek_c> right now I've only found Network.HTTP
17:51:36 <derek_c> but it's converting web pages to string
17:51:37 <aavogt> http://hackage.haskell.org/package/curl
17:52:18 <aavogt> I can't say much about what's more efficient
17:52:58 <Heffalump> derek_c: it should convert them to ByteString too, but the internals aren't very efficient
17:53:14 <derek_c> aavogt: thanks for pointing me to curl
17:53:21 <derek_c> Heffalump: what would you suggest me to do?
17:54:08 <Heffalump> I would guess that something more modern like http-conduit would be more likely to be performant, but I haven't measured any of them
17:54:46 <Heffalump> using curl would mean installing libcurl on clients, which can be a pain on Windows
17:55:17 <derek_c> Heffalump: Thank you for pointing me to http-conduit! It looks pretty interesting
17:55:25 <typoclass> derek_c: curl is a bit hairy. i suggest http-conduit as well, it's very simple to get started with
18:07:29 <trescenzi> If I want to use a hashtable, doesn't have to be mutable, which package is the "best"
18:08:24 <Cale> trescenzi: Does it have to actually compute hashes, or is any kind of finite function/set okay?
18:08:43 <Cale> trescenzi: Usually, I would just use Data.Map or Data.Set until it became clear that I needed something more specific.
18:08:57 <trescenzi> ok yea that should be all i need Cale
18:09:02 <Cale> There are Data.IntMap and Data.IntSet which are a little faster if your keys are Int values
18:09:33 <trescenzi> Alright
18:09:54 <Cale> and then there's the http://hackage.haskell.org/package/unordered-containers package for HashMap and HashSet, which can do a bit better on occasion.
18:10:03 <trescenzi> Hmm ok
18:10:19 <trescenzi> The more that I think about it I don't even know if I care about speed at all.
18:10:36 <trescenzi> I might just use an unordered list lol
18:10:47 <trescenzi> It just feels dirty
18:10:49 <Cale> (those require Hashable instances on the keys rather than just Ord)
18:11:11 <Cale> Data.Map and Data.Set provide a nice API for the kinds of operations you likely want
18:11:13 <arkeet> trescenzi: Data.Map at least gives you a decent api for a map-like thing.
18:11:14 <arkeet> yeah
18:11:22 <Cale> and they're usually fast enough
18:11:26 <trescenzi> ok yea I'll play around with that then
18:11:32 <trescenzi> it's better than an unordered list
18:11:59 <cmccann> if you don't know what to use for looking things up, just use Data.Map until you know what you actually need
18:12:25 <cmccann> just using a list is kind of a pain because of the lack of a nice API, as Cale mentions
18:12:29 <Cale> Everything else generally copies the API of Data.Map anyway, so it's likely not a hard change to make :)
18:12:39 <cmccann> that too
18:13:13 <trescenzi> yea this api looks pretty nice
18:13:27 <cmccann> also, my view is that Data.Map is fast enough for any task where you can't actually describe what your specific performance requirements are
18:13:44 <trescenzi> What's the diffrence between Map.lazy and Map.Strict?
18:14:01 <Cale> trescenzi: Whether the structure is strict in the elements.
18:14:18 <Cale> The lazy version can store unevaluated expressions as values
18:14:19 <arkeet> i.e. the values.
18:14:26 <cmccann> if you're doing stuff like incrementing the value at some key strictness is probably good
18:14:27 <Cale> It will always still have to evaluate the keys
18:14:38 <cmccann> if you're storing complicated stuff you might never use, laziness is good
18:14:57 <trescenzi> ah ok very cool
18:15:15 <trescenzi> Yea I don't need lazy but in this case it's not necessarily bad
18:15:48 <sg> what's the equivalent of fmap for moands?
18:15:49 <sg> monads*
18:15:57 <arkeet> usually you just want fmap.
18:15:59 <cmccann> :t liftM
18:16:00 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
18:16:18 <arkeet> because every monad is (or should be) a functor.
18:16:21 <cmccann> if you only have a Monad constraint for some reason, you can use liftM
18:16:23 <sg> listM
18:16:24 <cmccann> otherwise just use fmap
18:16:27 <sg> lift*
18:16:29 <arkeet> right, I was going to say that.
18:16:38 <sg> sorry, i just used hoogle and that was fairly obvious
18:16:38 <sg> thank you
18:16:42 <arkeet> e.g. if you're writing code that works generically on a monad.
18:16:51 <arkeet> or if you're writing a Functor instance for a monad, maybe.
18:19:10 <trescenzi> Anyone know which type of Data.Map is used by default if you don't specify lazy or strict?
18:19:41 <cmccann> lazy
18:19:51 <cmccann> cf. http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/Data-Map.html
18:20:26 <monochrom> be careful with what you mean by "strict" and "lazy". that is, strict/lazy in what?
18:20:55 <trescenzi> in this case it's the values stored right?
18:20:56 <cmccann> that was asked roughly seven minutes earlier :P
18:20:56 <pharaun> Any good unit types library (Aka Kg, meter, gram, liter, etc..)
18:20:59 <monochrom> all Data.Maps are strict in keys and in their internal trees, for example
18:21:45 <cmccann> anyway, the docs for Data.Map describe what the strictness properties are in the two modules.
18:22:18 <trescenzi> If I want to store a function in a class using the record syntax would the type of that function be, the type of the function?
18:22:24 <trescenzi> Spelled out that sounds stupid
18:22:25 <typoclass> pharaun: there's some information and some links here http://www.haskell.org/haskellwiki/Physical_units
18:23:22 <pharaun> typoclass: thanks :)
18:25:12 <monochrom> what is your record type?
18:25:34 <trescenzi> monochrom: i just tested it out in ghci I can do what I wanted to do
18:25:46 <trescenzi> I was mainly curious if I could store a function as data.
18:25:50 <monochrom> then good
18:25:54 <trescenzi> it should have been obvious I could
18:26:40 <trescenzi> If I have something like data Test = Test { function :: (Int -> Int) -> Int} function is lazy right? In the sense that it won't be called unless I actually want to use it.
18:27:40 <monochrom> yes
18:27:54 <cmccann> if you apply it to an argument and force the result, it will be evaluated. if you don't force the result, it won't. if you don't apply it to an argument, how could it be evaluated?
18:28:00 <trescenzi> Ok cool.
18:28:05 <trescenzi> yea good point cmccann
18:28:11 <tsou> t
18:28:40 <cmccann> in other words, yes, things really do work in the simple and obvious way you'd expect :]
18:28:50 <trescenzi> gotta love it
18:29:04 <trescenzi> I've been going through the stage of hating haskell this weekend
18:29:10 <trescenzi> but tonight i'm in love once again
18:29:47 <cmccann> the tendency for haskell code to mean exactly what I'd expect it to and things to behave in the obvious predictable way is a large part of why I like the language
18:30:08 <cmccann> so many things you don't even have to worry about
18:30:38 <trescenzi> yea
18:30:42 <trescenzi> at first it seemed unexpected
18:30:51 <napping> cmccann: that evaluation stuff is a bit more than you are promised
18:30:54 <trescenzi> but now it's just amazing how much you can do with the basic building blocks
18:31:19 <sw2wolf> trescenzi: i just scared of its laziness as i am worry i cannot control the app. developed by haskell
18:32:07 <trescenzi> sw2wolf: I ran into some craziness with laziness and if you really need something strictly evaluated there are ways to do it.
18:32:28 <cmccann> napping: how so?
18:32:50 <A__A> is there a fold without start arg?
18:32:52 <napping> "non-strict" is how the language is defined
18:32:56 <A__A> @src fold
18:32:56 <lambdabot> Source not found. You speak an infinite deal of nothing
18:33:31 <cmccann> napping: ah true
18:33:34 <sw2wolf> trescenzi: although default laziness scare me now, i still like haskell as it makes me think programming in different way
18:34:18 <trescenzi> sw2wolf: yea it feels really weird at first but you learn to enjoy it.
18:34:27 <BMeph> A__A: Yes. Next question? ;)
18:34:28 <sw2wolf> hope so
18:34:36 <napping> If you really depend on something - like unsafePerformIO - not being evaluated you probably just have to look at the generated code
18:34:59 <sw2wolf> @src foldr
18:35:00 <lambdabot> foldr f z []     = z
18:35:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:37:35 <napping> as far as I know that's just from stuff like inlining and let-hoisting in GHC, but there have been some experiments with eager evaluation
18:38:22 <cmccann> I think the term I've heard is "optimistic evaluation"?
18:38:31 <[swift]_> not having much luck finding an async-like library that uses multiple processes rather than multiple threads
18:38:35 <[swift]_> is anyone aware of one?
18:38:53 <cmccann> if memory serves me CPUs do something similar with branch prediction, evaluating stuff in advance based on what they guess you'll want
18:39:02 <cmccann> a non-strict language could certainly do the same
18:39:02 <trescenzi> [swift]_: donesn't the OS tend to handle that?
18:39:36 <napping> cmccann: perhaps, the general idea is to evaluate a bounded amount of time into thunks, apparently it took tons of run-time profiling to figure out where that might be productive and make it a net win
18:39:57 <[swift]_> trescenzi: the OS handles the processes, sure, but it'd be nice to have a convenient API for interacting with them
18:39:58 <cmccann> it's an interesting idea at least
18:40:38 <trescenzi> [swift]_: I wouldn't know then. haven't done too much async stuff with Haskell
18:40:45 <napping> anyway, part of the point of purity is that it shouldn't matter when thing are evaluated
18:41:12 <[swift]_> i'd prefer to stick with threads but as far as i can tell libclang isn't threadsafe =\
18:41:40 <napping> and separately, the compiler ought to guarantee whatever it does isn't asympotically worse than being lazy
18:42:27 <trescenzi> I've only run into one situation where being lazy was bad and it resulted in a rather easily fixed infinite loop
18:43:02 * sw2wolf i am curious if STM can be used to develop production system
18:44:49 <jfischoff> sw2wolf: you mean is it as enterprise ready as PHP?
18:45:44 <arkeet> hahaha
18:46:11 <dolio> Well, optimistic evaluation is nice for things like "sum = foldl (+) 0".
18:46:27 <dolio> Without the '.
18:46:55 <dolio> The problem is that it's kind of fundamentally unreliable.
18:47:46 <augustss> It can be made reliable.
18:48:00 <dolio> Well, no more unreliable than laziness, I guess.
18:48:12 <copumpkin> whoa, augustss on #haskell again
18:48:16 <copumpkin> feels like 2009 again
18:48:27 * cmccann waits for copumpkin to engage fanboy mode
18:48:33 <copumpkin> OMG YAYAYAY
18:48:41 <jfischoff> haha
18:48:44 <augustss> I'll soon be gone
18:48:50 <copumpkin> augustss: I can haz autograph?!?!!?
18:49:11 <copumpkin> cmccann: is that suitable?
18:49:18 <cmccann> yeah that was good
18:49:21 <cmccann> well done
18:49:23 * copumpkin bows
18:49:26 <augustss> :)
18:50:10 * elliott doesn't believe in augustss. he's just like santa claus
18:50:32 * monochrom had to decode the double-negation in "no more unreliable"
18:50:36 <augustss> I hand out presents?
18:50:52 <cmccann> well you've been more active on StackOverflow lately, that's kinda similar
18:50:57 <copumpkin> @djinn a -> a
18:50:58 <lambdabot> f a = a
18:51:00 <copumpkin> ^
18:51:15 <napping> dolio: the unreliability is only whether you can actually improve performance - not changing semantics is a requirement
18:51:16 <dolio> monochrom: Like, no worse?
18:51:40 <napping> "Eager Haskell" was the name of a project
18:52:05 <monochrom> my brain has a special shortcut for "no worse" cached
18:52:17 <dolio> napping: No, I mean more like, "can I trust that optimistic evaluation is good enough for this function, or should I put ! anyway?"
18:52:23 <augustss> And Eager Haskell worked quite well.  But it wasn't exactly how I would have done it.
18:52:50 <BMeph> I think I remember EZ had some speculations on it, but I don't remember if it got past the "idle" point. :)
18:53:35 <kristof> Oh, is Eager Haskell just eager by default, with lazy when specified?
18:54:45 <napping> it was always eager, where eager is still properly non-strict
18:55:03 <elliott> augustss: sure. you're handing out your presence right now, in fact
18:55:57 <napping> it would execute for a bounded (possibly zero) amount of time, and then make thunks for everything if it wasn't done, rather than being lazy right away
18:56:31 <napping> as I recall, automatically finding the right amount of time for each expression in the program to be a net win overall was the tricky part
19:40:23 <NemesisD> anyone know how to nuke the packages in an hsenv? apparently lots of my packages are missing files and I can't figure out which ones to nuke
19:42:38 <monochrom> I only know that it is some hidden subdirectory of your working directory. browse.
19:44:22 <byorgey> NemesisD: rm -rf .hsenv_*
19:44:53 <NemesisD> i think it might be that my user packages are corrupted
19:45:12 <monochrom> then look into ~/.ghc
19:46:14 <NemesisD> why does this happen?
19:46:33 <NemesisD> it seems like every month or so i end up having to obliterate my packages and start from nothing
19:46:55 <NemesisD> also: would it be safe to rm -rf ~/.ghc ~/.cabal or...
19:46:57 <monochrom> I don't know what you did every month. no comment.
19:47:24 <monochrom> does your file system keep a history? I may read something from it.
19:47:55 <NemesisD> nothing terribly dangerous from what i know. i don't force reinstalls. i develop using cabal-dev or hsenv
19:48:19 <monochrom> understandably, I do not trust human recollection
19:48:48 <NemesisD> monochrom: so which directory do i destroy?
19:49:36 <monochrom> ~/.ghc, but it also contains your ghci command history. consider doing an "ls" and decide what to really delete
19:49:52 <NemesisD> losing that is fine
19:50:33 <monochrom> in the long run, you cannot sustainably play "it is a black box". you must know. see my http://www.vex.net/~trebla/haskell/sicp.xhtml
19:52:06 <dolio> .cabal may have your config in it, too.
19:52:22 <dolio> If you wrote one.
19:52:48 <NemesisD> i can't believe i didn't know about cabal install -jN until recently
19:53:00 <jfischoff> its pretty recent
19:53:43 <NemesisD> good stuff
19:54:10 <NemesisD> makes ragequitting my hsenv and .ghc directories less painful
19:54:27 <dolio> I force reinstalls all the time, by the way, and don't blow away stuff in those directories until I update to a new version of GHC.
19:54:30 <dolio> But maybe I'm just lucky.
19:54:38 <monochrom> you are supposed to have editted ~/.cabal/config, if you are a respectable developer. it has wrong defaults for respectable developers.
19:55:16 <dolio> Yeah, cabal is pretty paranoid these days.
19:55:24 <sw2wolf> monochrom: split-objs should be default in ~/.cabal/config ?
19:55:42 <monochrom> no, I am referring to "documentation: False" and "library-profiling: False"
19:55:51 <dolio> Oh, that too.
19:55:55 <monochrom> it is like cabal doesn't want you to be a serious developer
19:56:05 <monochrom> it is like cabal doesn't want you to learn haskell
19:56:35 <sw2wolf> maybe it is due to performance
19:56:49 <sw2wolf> so default to False
19:58:01 <NemesisD> i run a rolling release ditro of linux so my ghc stays pretty darn frehs
19:58:05 <NemesisD> fresh*
19:59:28 <monochrom> I have not used profiling for several years, and I still turn on library-profiling and pay its cost. do you understand why?
19:59:46 <sw2wolf> no
20:00:13 <monochrom> when one day I need it, and have not turned it on previously, it will be a pain. a lot of libs have to be rebuilt to obtain profiling
20:00:21 <cmccann> wanting to profile something and realizing you forgot to enable library-profiling when you reinstalled stuff months ago is the worst thing ever
20:01:25 <dolio> Crap. Now that you mentioned that, I looked and forgot to have that turned on.
20:01:26 <sw2wolf> seems reasonable
20:02:54 <monochrom> there is no choice between "pay or not pay". there is only choice between "spread thin the payment from now to then" and "pay it in one big stroke some day"
20:02:55 * sw2wolf is it time to use LL
20:03:10 * sw2wolf is it time to use LLVM instead of gcc now ?
20:03:45 <sw2wolf> i want to add -llvm in ~/.cabal/config
20:04:24 <sw2wolf> i mean ghc options
20:04:30 <cmccann> monochrom: except that massive reinstalls create additional pain vs. enabling profiling in the first place
20:05:30 * sw2wolf In face i profile little up to now 
20:05:40 <sw2wolf> s/face/fact
20:06:00 <cmccann> it's like if you have a cut that never heals, you can either keep it clean with some effort on a regular basis, or ignore it until it gets infected and you have to get your arm amputated or something.
20:06:07 <cmccann> except a less terrible analogy than that
20:06:17 <sw2wolf> i dream the app is ok if type checking ok :)
20:07:23 <monochrom> foldl' vs foldl
20:07:50 <sw2wolf> what's the difference ?
20:08:20 <monochrom> foldl' spreads thin the payment from now to then. foldl pays in one big stroke at the end
20:08:32 <cmccann> or causes a stack overflow
20:09:58 <sw2wolf> horrible  laziness ?!
20:10:49 <monochrom> yes
20:11:31 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml shows the process. scroll down or look for "foldl" to fast-forward
20:12:06 <sw2wolf> i hate laziness :)
20:12:27 <sw2wolf> but i like haskell
20:14:24 <monochrom> I like laziness. I dislike eagerness.
20:14:32 <pharaun> both have merits
20:14:33 <cmccann> laziness is great
20:14:44 <cmccann> intrinsically strict expressions evaluated as if they could be lazy not so much
20:14:57 <pharaun> there are stuff in which eagerness is easier to deal with, and there are stuff that are much easier with laziness
20:15:30 <sw2wolf> but default to laziness is shortcoming ?
20:15:48 <cmccann> laziness by default is a shortcoming. eagerness by default is a bigger shortcoming.
20:15:59 <pharaun> i haven't used haskell long enough yet to decide, but so far, i think defaulting to lazyness is less of a issue than eagerness
20:16:08 <pharaun> the main sore point for me regarding lazyness is I/O
20:16:11 <monochrom> with laziness, "my_if_then_else b x y = if b then x else y" does what you want. more generally, you can define control and short-circuit operators yourself, it's just another function.
20:16:12 <pharaun> but outside that
20:16:45 <monochrom> with eagerness, every control and short-circuit operator must be built in, you can't add more.
20:17:07 <jfischoff> monochrom: or you need a way to say "this is lazy"
20:17:45 <elliott> @remember cmccann laziness by default is a shortcoming. eagerness by default is a bigger shortcoming.
20:17:45 <lambdabot> Nice!
20:17:54 <elliott> it's not nice lambdabot. it's awful
20:17:59 <cmccann> haha
20:18:09 <cmccann> lambdabot is just optimistic.
20:19:55 <napping> monochrom: what do you mean by eagerness?
20:20:23 <shanks_> hey hey
20:20:37 <monochrom> call by value. opposite of laziness
20:20:49 <monochrom> (clearly, the opposite of laziness cannot be strictness)
20:20:58 <shanks_> i need help with operating on lists of tuples
20:20:59 <sw2wolf> it seems it is NOT elegant to make a strict code, i.e. ! ...
20:21:13 <napping> that's not at all how Eager Haskell worked, and they seem to have defined the term
20:21:42 <nbouscal> This guy on HN will not give up trying to argue that jQuery is a monad
20:21:48 * nbouscal facepalm
20:22:06 <sw2wolf> jfischoff: you still need to say "this is strict", right ?
20:22:07 * tgeeky thought eager haskell was just a support group for people who are really excited about haskell
20:22:30 <parcs> i bet he watched that terrible talk by douglas crawford on monads in javascript
20:22:39 <nbouscal> haven't seen that one
20:22:44 <shanks_> say i have a list of 2-tuples... the list is of arbitrary length... i want to be able to multiply each 2-tuple with the other ones in the list, and return the sum of those multiplications
20:22:49 <napping> monochrom: in particular, an evaluation strategy which delivers proper non-strict semantics and promises not to repeat work, but doesn't necessarily promise not to evaluate things before they are proved to be needed
20:22:49 <jfischoff> sw2wolf: with haskell yes. With mu haskell you "this is lazy"
20:23:02 <tgeeky> it's bad. I was told not to watch it, and watched it anyway, and was amazed that the guy keeps publishing things along those lines.
20:24:09 <shanks_> oh wait, nevermind my original scenario
20:24:17 <shanks_> that's not what I want to do
20:25:23 <cmccann> tgeeky: that talk by crockford?
20:26:02 <cmccann> I think that got submitted like three times to /r/haskell
20:26:14 <ab9rf> whee
20:26:24 <cmccann> people didn't realize it had already been submitted because of how quickly it got downvoted to oblivion
20:26:42 <ab9rf> cmccann: this is why i don't do reddit
20:26:44 <tgeeky> cmccann: well, I actually discussed it with you. The one I saw was a *new* talk, but given with old mateiral.
20:27:15 <cmccann> ab9rf: /r/haskell is usually fine, most of reddit is a cesspool though
20:27:18 <tgeeky> Someone said it was a repost, but that was impossible at the time since it wasn't even 24 hours old (google talks).
20:27:24 <tgeeky> subreddits are awesome.
20:28:06 <parcs> from the beginning of the talk: "go to yahoo and google for monad..."
20:28:11 <parcs> oops :)
20:28:21 <nbouscal> nice thing about reddit is you can unsubscribe from the bad ones. my front page never seems to have anything interesting on it though, so i rarely bother
20:28:31 <tgeeky> Needless to say, after watching the video, I wanted my time back.
20:28:34 <cmccann> tgeeky: ah, I'm afraid I've completely forgotten the details, heh
20:28:40 <dolio> napping: Lots of people use the term "eager evaluation" to reference the evaluation strategies of things like ML.
20:28:46 <dolio> I doubt Eager Haskell coined the term.
20:28:58 <napping> strict evaluation is a perfectly good term for that
20:28:59 <cmccann> nbouscal: well you just said you unsubscribed from everything! no wonder there's nothing on your front page.
20:29:14 <nbouscal> haha i subscribed to a bunch of things, they're just all too small to be very active i guess
20:29:26 <nbouscal> i mostly just unsubscribed from the awful defaults. memes etc
20:30:15 <pharaun> [5~[5~[6~[6~[6~
20:30:16 <cmccann> there are good subreddits in roughly the same sense that there are rational numbers among the reals
20:30:16 <monochrom> then I would say, it is Eager Haskell who had to change the meaning to fit the non-strictness goal. Richard Bird's Introduction to Functional Programming using Haskell uses "eager" as what I mean.
20:30:22 <cmccann> they exist but good luck finding one by chance
20:30:27 <nbouscal> haha very true
20:30:35 <dolio> I'm not entirely sure that it is, but it also probably doesn't matter. Lots of people do use 'eager' to mean that, and have for a long time.
20:31:09 <greymalkin> Why is it that command line arguments are considered impure? They are probably the only pure input a program can receive.
20:31:31 <ab9rf> they're unsafe
20:31:52 <greymalkin> Ah, that makes a different sort of sense.
20:31:54 <dolio> You can change the results of getArgs with some other IO call.
20:31:58 <parcs> cmccann: what's the chance?
20:32:14 <monochrom> "strict evaluation" is in the same genre as "lazy denotation" and "loud colour"
20:32:25 <ab9rf> the reason tehy're impure is becuase they involve interacting with the environment, and thus might not return the same thing on every call
20:32:25 <shanks_> does anyone know how to apply a function that takes two parameters using elements from two lists? say, i have two lists of the same arbitrary length, e.g. l1 = [(a,b),(c,d),(e,f)] and l2 = [(g,h),(i,j),(k,l)]. I want to apply a function like foo (a,b) (x,y) where (x,y) is each element in l2, then (c,d) (x,y) and so on
20:32:31 <cmccann> parcs: indistinguishable from zero
20:32:44 <ab9rf> there's no guarantee that getArgs returns the same thing every time it's called.
20:33:22 <parcs> cmccann: aw :(
20:33:34 <napping> there's no particular reason main couldn't have a type like [String] -> IO ()
20:33:35 <cmccann> anyway, even if command line arguments were treated as pure, they'd be parameters to main
20:33:43 <cmccann> so you'd still have to pass them to other functions
20:33:48 <nbouscal> shanks_: use the [] instance of Applicative?
20:33:54 <cmccann> which saves you exactly one line over using getArgs right away
20:34:18 <napping> Treating the initial value of arguments as some global constant of type [String] that will be different on different executions just seems a bit fishy
20:34:48 <cmccann> napping: the idea is that by running the program, you're applying main to those arguments
20:34:49 <shanks_> nbouscal: I'll check it out
20:35:01 <dolio> @hoogle withArgs
20:35:01 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
20:35:02 <napping> yeah, I
20:35:11 <napping> I'm imagining a "System.args :: [String]"
20:35:21 <cmccann> napping: that would be entirely different
20:35:32 <cmccann> making the args a magic global constant is very fishy
20:35:48 <cmccann> I misread what you said, sorry
20:35:55 <dolio> 'withArgs ["hello"] getArgs' gives you back ["hello"]
20:35:56 <nbouscal> shanks_: I'm new-ish to it but I think it would just look like f <$> xs <*> ys
20:36:14 <nbouscal> or close to that anyway
20:36:25 <cmccann> > (++) <$> ["foo", "bar"] <*> ["baz", "quux"]
20:36:27 <lambdabot>   ["foobaz","fooquux","barbaz","barquux"]
20:37:12 <napping> arguably constants are no worse than arguments to main, but somehow it seems fishier
20:37:30 <cmccann> napping: no, they're certainly worse
20:38:14 <cmccann> with arguments to main, a function that isn't given the args as input can't use them
20:38:17 <nbouscal> might just be me but Applicative strikes me as more magical than Monad
20:38:40 <nbouscal> at least as far as "number of uses I can immediately think of for this" goes
20:38:50 <mikeplus64> there is no magic, and that is the magic
20:38:51 <cmccann> nbouscal: that's quite the trick, since every Monad can be an Applicative in a simple way
20:39:28 <nbouscal> cmccann: yep, i'm aware :) but hey every Arrow can be a Monad in a simple(ish) way :P
20:39:48 <cmccann> only with ArrowApply
20:39:58 <nbouscal> right, sorry, that's what i meant. not every arrow
20:39:59 <cmccann> every Monad gives you a Kleisli arrow though
20:40:22 <nbouscal> i think my brain was going every monad can be an arrow
20:40:50 <nbouscal> i don't even know anymore, too many type classes.
20:41:50 <nbouscal> Haskell has certainly been demonstrating the extent to which it isn't true that a programmer can pick up and work in any language
20:42:17 <cmccann> people who say that don't realize that they only know languages that are basically the same
20:42:20 <nbouscal> In most languages you can but not idiomatically, in Haskell you barely can at all, idioms be damned
20:42:26 <cmccann> people like myself, several years ago...
20:42:35 <monochrom> it was true a long time ago
20:42:57 <monochrom> I need to further edit that statement
20:43:22 <monochrom> it was true a long time ago and you had to add "mainstream"
20:44:05 <cmccann> now when someone says programmers can pick up any language quickly all I hear is the quote "oh we have both kinds of music here, country AND western!"
20:44:14 <nbouscal> i've had a weird experience recently of associating with a few people whose language knowledge consists of Java, C, C++, C#, and maybe one or two others. apparently that's what they learn in school.
20:45:32 <nbouscal> half the time i look at code in those languages i actually have a hard time telling the difference between them
20:45:46 <monochrom> since about 20 years ago, it ceased to be true, even if you add "mainstream"
20:45:55 <napping> cmccann: reminds me of parameterization vs. fibration in module systems
20:45:58 * BMeph grew up in a place where country and western music were considered two different (though related) styles
20:46:06 <nbouscal> I dunno, most of the mainstream languages i've used were quite pick-up-able
20:46:23 <cmccann> BMeph: sounds like the kinda place that quote was making fun of :D
20:46:51 <cmccann> man, that was a great movie.
20:47:05 <BMeph> cmccann: Oh, it is, it is. 8D
20:47:23 <monochrom> take merely C and Java (or C and Perl). they're mainstream. you can no longer learn one and quickly pick up another. in C, you have to malloc and free, but you do not have to lose the pointer for freeing. in Java or Perl, you must trust GC, and you must lose the pointer for freeing.
20:47:45 <monochrom> there are other conceptual differences
20:48:08 <nbouscal> There are always a few conceptual differences, but I think 'pick up' allows for a day to learn those
20:48:14 <nbouscal> if not a few days
20:48:36 <cmccann> Java and C are the ones without lambdas, C and C++ are the ones where your program segfaults, C is the one where it's easier to write buffer overrun vulnerabilities
20:48:43 <cmccann> those are the important differences
20:48:52 <monochrom> haha
20:51:52 <nbouscal> Anyway, haskell is feeling like a league of its own on the 'time to pick up' scale
20:52:17 <dolio> You should learn Twelf.
20:52:44 <nbouscal> I haven't even learned Prolog yet >.>
20:53:04 <mikeplus64> nbouscal: well, you don't really "need" to understand Arrow, Applicative etc. and their motivations for actual usage
20:53:25 <lightquake> what's the best way to implement a plugin system?
20:53:39 <nbouscal> mikeplus64: fair enough. but i want to write good code, so...
20:53:50 <tgeeky> lightquake: probbaly not 'plugins', but it's probably the closest you'll find
20:53:51 <lightquake> i.e., if my blog engine's themes are effectively a bunch of functions from input data to Html, and i want people to be able to switch the theme they use
20:54:08 --- mode: ChanServ set +o elliott
20:54:13 <tgeeky> lightquake: oh, that's totally different
20:54:19 <lightquake> tgeeky: well, no
20:54:37 <lightquake> because i want to just be able to distribute plugins as binary blobs
20:54:41 <nbouscal> mikeplus64: weird thing is, i think i actually understand the theory behind them just fine. it's the practical use in actual code that is taking some time to become comfortable with
20:55:07 <nbouscal> likely because i've done a bit of algebra and category theory in the past
20:55:09 --- mode: elliott set +b *!~michael@unaffiliated/maikeru/x-7708887$##fixyourconnection
20:55:12 <cmccann> nbouscal: understanding the practical use of the abstractions will come naturally as you make practical use of the motivating examples
20:55:13 * hackagebot conjugateGradient 1.1 - Sparse matrix linear-equation solver  http://hackage.haskell.org/package/conjugateGradient-1.1 (LeventErkok)
20:55:20 --- mode: elliott set -o elliott
20:55:45 <monochrom> eh? ##fixyourconnection exists?
20:55:55 <elliott> apparently
20:56:00 <nbouscal> cmccann: yep. i think i just need a better learning project. the Pinochle idea probably isn't the best one haha
20:56:08 * elliott is just mimicking other bans-for-joinquit-spam I've seen here
20:56:13 <mikeplus64> nbouscal: don't worry about it. i barely ever use Arrow, and think that's mostly the same for others
20:56:41 <cmccann> hating on Arrow is the cool thing to do these days.
20:56:44 <nbouscal> haha
20:56:51 <nbouscal> i like Arrow! it's all nice and abstract and broad
20:56:56 <mikeplus64> nbouscal: just go forth, and write code! if ever you find yourself seeing something that can be abstracted, maybe you'll find it is Arrow or something
20:57:02 <elliott> the problem with Arrow is it's not abstract or broad. :(
20:57:11 <monochrom> I like arrow
20:57:19 <cmccann> Arrow is messy and demands a bunch of arbitrary properties of the category it uses
20:57:19 <nbouscal> elliott: guess i don't understand it as well as i thought then XD
20:58:03 <nbouscal> mikeplus64: i always have the problem of thinking/reading too much and not writing code enough. working on fixing that.
20:58:08 <lightquake> cmccann: like the ability to lift arbitrary functions into it?
20:58:12 <monochrom> Wadler has simplified it. not messy or arbitrary anymore
20:58:21 <cmccann> lightquake: that's a common one
20:58:52 <cmccann> arr makes a lot of potential DSL stuff awkward or impossible
20:59:24 <mikeplus64> while we're at it, frankly arrow notation is ugly
20:59:44 <lightquake> i used netwire arrows a bit a while ago and i thought they were ok
21:00:22 <tgeeky> cmccann: would it improve things if you changed (literally) the function arr to be the function 'a'
21:00:23 <cmccann> netwire is based on the automaton arrow IIRC, which is by far the most common example of Arrow being useful
21:00:45 <cmccann> tgeeky: not sure what you mean
21:00:47 <tgeeky> as in, first (a function) = a (first function)
21:01:06 <lightquake> the type Wire e m a b is equivalent to Time -> a -> m (Either e b, Wire e m a b)
21:01:35 <tgeeky> cmccann: I mean, what about 'arr' makes arrow DSLs awkward or impossible? The name of the functions? Their types?
21:01:40 <cmccann> the problem with arr is when you have something that would be an arrow except you can't lift arbitrary functions into it
21:02:30 <cmccann> e.g. say you need to be able to serialize every value of your not-quite-Arrow type somehow
21:02:33 <monochrom> i.e., sometimes you don't want to support arr
21:03:14 <tgeeky> oh, i see what you mean.
21:03:57 <cmccann> if you need everything to be open to introspection you can't allow arbitrary functions to be stuck in the middle
21:04:20 <mikeplus64> arr _ = error "Sorry, can't do that"
21:04:26 * mikeplus64 shows himself out
21:05:29 <cmccann> arr _ = error "I used to be a function but then I took an Arrow to the knee"
21:06:31 <lightquake> >:|
21:06:36 <elliott> cmccann........
21:06:38 <Hafydd> ab9rf: maybe I missed your answer to my question.
21:06:52 <cmccann> elliott: :D
21:06:54 <elliott> unfortunately it's not as simple as just taking arr away.
21:07:00 <elliott> because all the other "primitive" things use arr a lot.
21:07:21 <elliott> also, arrow programming gets even more awkward if you take it away, the whole working with native Haskell data thing gets even worse. :(
21:07:39 <cmccann> lightquake: anyway yeah, the basic automaton arrow looks like "Automaton a b = a -> (b, Automaton a b)"
21:08:00 <lightquake> ah
21:08:12 <lightquake> yeah that looks like the netwire one except with the addition of time and failure
21:08:22 <cmccann> a simple state machine/stream transducer/whatever
21:09:18 <cmccann> arrow-based FRP and iteratee-style stream processing usually boil down to an automaton arrow with some stuff bolted on the side
21:11:58 <ab9rf> Hafydd: maybe i missed your question
21:12:27 <Hafydd> ab9rf:
21:12:28 <Hafydd> 04:25:17 < greymalkin> Why is it that command line arguments are considered impure? They are probably the only pure input a program can receive.
21:12:31 <Hafydd> 04:25:31 -!- sleepynate [~sleepynat@108-80-181-6.lightspeed.livnmi.sbcglobal.net] has joined #haskell
21:12:35 <Hafydd> 04:25:38 < ab9rf> they're unsafe
21:12:37 <Hafydd> 04:25:59 < greymalkin> Ah, that makes a different sort of sense.
21:12:40 <Hafydd> 04:26:14 < Hafydd> How are they unsafe?
21:12:50 <ab9rf> Hafydd: ah, i did miss that
21:13:00 <ab9rf> they're 'unsafe' in the sense that they could contain anything, and should be untrusted :)
21:13:15 <ab9rf> but the reason tehy're impure is as i explained previously
21:13:27 <ab9rf> the reason tehy're impure is becuase they involve interacting with the environment, and thus might not return the same thing on every call
21:14:00 <Hafydd> What do you mean by "anything"? Aren't they always a list of strings?
21:14:09 <Hafydd> And don't they exist on the program's stack?
21:14:30 <ab9rf> Hafydd: no, they're "somewhere"
21:14:43 <ab9rf> you don't know how the OS passes command arguments to the program
21:15:03 <Hafydd> Okay, fair point.
21:15:04 <ab9rf> they're not "on the stack" in a POSIX environment
21:15:32 <ab9rf> i think it's a kernel memory block, iirc
21:15:42 <ab9rf> but it's been a long time since i looked at that
21:16:04 <tgeeky> ab9rf: I don't know if they can change, though. They are certainly unsafe, and I see how you could alter environment variables (suspend process, change, unsuspend)
21:16:26 <ab9rf> in BSD a process could twiddle its argument vector and that twiddling would show up on the ps listing
21:16:35 <ab9rf> tgeeky: they can in some environment
21:16:43 <tgeeky> ah yes, that ruins it then. :)
21:16:47 <greymalkin> Is there a shorter way to take an `IO String` and use it as the variable to a pure function whose result is passed to putStrLn ?
21:16:57 <ab9rf> tgeeky: whether they can is implemnenttion dependent
21:17:02 <tgeeky> they also leak information (which is a part about purity people never think about) into the environment
21:17:04 <greymalkin> (specifically, pure `usage` function, taking result of `getProgName`)
21:17:08 <Clint> setenv() is in posix
21:17:18 <ab9rf> tgeeky: but because haskell cannot _guarantee_ they can't change, acessing them is impure and thus has to be sequenced through IO
21:17:19 <tgeeky> which is the reason you don't allow passwords on the command line
21:17:19 <elliott> greymalkin: getProgName >>= putStrLn . usage, if you want to golf
21:17:30 <elliott> greymalkin: or just: do { name <- getProgName; putStrLn (usage name) }
21:17:52 <shapr> So me and two other classmates will be teaching introduction to functional programming languages tomorrow and Wednesday, any last minute comments on my slides? http://scannedinavian.com/~shae/fp.pdf
21:19:10 <greymalkin> elliott: I'm golfing for the sake of learning, so thank you.
21:19:47 <ab9rf> tgeeky: in some OS enviromments, command line parameters aren't parsed until and unless the program wnts them.
21:20:04 <johncrayton> Hello. Can anyone enlighten me - what's the difference between traversable and a functor - they seem exactly teh same
21:20:20 <nbouscal> shapr: on how it's different, maybe mention higher-order functions. you get at it by saying functions are values, but higher-order functions are (partly, anyway) why that's useful, might be worth making explicit.
21:20:32 <ab9rf> johncrayton: have you seen typeclassopedia?
21:21:19 <johncrayton> ab9rf: did read it ages ago - does it cover it i can't remember
21:21:24 <Mortchek> shapr, "Haskell/Scheme structure is not even close to C++" Is the point here to illustrate how the language is quite different from what most programmers are used to? If so, I'd make that more explicit. C++ isn't some de facto standard of language design.
21:21:44 <Mortchek> Unless it happens to be significant in your course, I suppose.
21:21:59 <shapr> Mortchek: C++ is the only language we're really taught in our degree program.
21:22:15 <shapr> We do have a course on Java, and the web dev course touches on JavaScript.
21:22:20 <cmccann> shapr: how terrible
21:22:20 <nbouscal> and that is why i am not so sad that i didn't do a CS degree
21:23:18 <nbouscal> four years of java and c++ i probably would have dropped out
21:23:27 <shapr> I'm considering it myself.
21:23:57 <monochrom> you have to be careful which CS school you choose
21:24:09 <nbouscal> well, it isn't always a choice
21:24:11 <Mortchek> Our curriculum so far has been Java, C, Ruby, OCaml, and Prolog. So, not horrible, especially since I managed to skip over Java.
21:24:28 <shapr> I got to teach myself Prolog last term in my Programming Languages course, but that was my own decision.
21:24:28 <nbouscal> Mortchek: not horrible at all
21:24:32 <cmccann> Mortchek: that's at least a decent variety
21:24:35 <johncrayton> nbouscal: almost everyone on the original haskell comittee was an academic in a cs department, so you can't pretend all departments are like that
21:24:42 <Mortchek> The Ruby, OCaml, and Prolog are kind of in passing though.
21:25:02 <nbouscal> johncrayton: didn't mean to imply that. at the school i received my degree from it very much is though, so for myself specifically it's applicable
21:25:37 <monochrom> you should also not be so worked up about what programming languages the school doesn't cover
21:25:43 * nbouscal received a degree in Accounting. life is weird.
21:26:03 <nbouscal> monochrom: I'm not so worried about the languages as the concepts
21:26:14 <slack1256> I thought CS major studied formal languages
21:26:18 <nbouscal> if the school only teaches C++ and Java they are not teaching a whole slew of important concepts
21:26:21 <Trollkastel> nbouscal: Wow! I struggled with cost accounting in university.
21:26:23 <slack1256> consistency and completness
21:26:45 <monochrom> ok, but there are many good schools that are boring on the language front but totally worth your time on most topics and diversity of topics
21:26:50 <nbouscal> Trollkastel: I had an easy time with accounting so I got a degree in it. Which I will never use.
21:26:54 <Mortchek> In the evaluation for the course where we learn OCaml, I argued for teaching Haskell instead, owing to its greater beauty and larger community. But OCaml really isn't a bad language.
21:26:59 <Trollkastel> nbouscal: Haha.
21:27:08 <tgeeky> A good university will teach you how to learn programming languages, not teach you programming languages.
21:27:21 <shapr> Mortchek: Any other feedback?
21:27:27 <nbouscal> Mortchek: As long as they're teaching the concepts, OCaml's fine. I learned functional first with SML, most of it carries right over.
21:27:54 <nbouscal> tgeeky: Very true. But how to learn programming languages requires to some extent enough variety to be able to understand the various types of languages
21:27:56 <ab9rf> johncrayton: typeclassopedia has a nice graph of many of the major type classes including Functor and Traversable
21:28:09 <ab9rf> i can't imagine an entire 4 year program in C++
21:28:17 <Nafai> shapr: btw, I keep meaning to share this with you, I know you talked about learning Calculus from the Infinitesimal perspective. http://www.math.wisc.edu/~keisler/calc.html
21:28:38 <shapr> Nafai: Thanks, I've downloaded that, but haven't gotten around to reading it yet.
21:29:01 <Nafai> shapr: figured you might have found it, but thought I'd share just in case
21:29:07 <shapr> I also grabbed some Calculus texts from the early 1900s that look nifty.
21:29:11 <ab9rf> i'm trying to remember if i had to learn FORTRAN back when i was in CS or not
21:29:18 <monochrom> a 4-year curriculum is clearly a zero-sum game. the more time it spends on, say, NP-completeness and machine learning, the less time it can spend on, say, type systems and denotational semantics. and vice versa
21:29:22 <Mortchek> shapr, feedback about the course?
21:29:42 <shapr> Mortchek: No, I mean.. any other suggestions directed towards the slides I've put together?
21:30:02 <Mortchek> Oh, I'm still perusing.
21:30:02 <monochrom> you can easily say, this school misses out on a lot of important topics. but every school does. every bloody school. every school has to play this zero-sum game.
21:30:02 <nbouscal> monochrom: having a solid core and allowing for many of those types of subjects to be elective should work okay, no?
21:30:20 <mjrosenb> monochrom: I was pretty happy with my 4 year cirriculum.
21:30:34 <ab9rf> nbouscal: you teach what you're good at.  if you have someone who does natural language parsing then you offer a class in it
21:30:40 <ab9rf> if not, then not
21:30:45 <monochrom> you are also looking at prof availability
21:31:11 <ab9rf> you can't learn everything in four years
21:31:16 <nbouscal> honestly as a student if you aren't learning as much on your own as you are in your classes i don't have much hope for you
21:31:27 <tgeeky> ab9rf: you can probably learn *a lot* more than I did :/
21:31:30 <nbouscal> that might just be my cynicism about the educational system
21:31:41 <ab9rf> if you have been _exposed_, at least briefly, to most of the major subdisciplines in those four years, they've done well
21:31:42 <tgeeky> ab9rf: to my fault, not those of my professors.
21:32:09 <nbouscal> i think we'd be better served if programming followed more of a guild culture
21:32:10 <ab9rf> you can't learn them all in depth in any reasonable timeline
21:32:11 <monochrom> apparently, type system profs want to join other type system profs, and machine learning profs want to join other machine learning profs. therefore, every school ends up being unable to hire profs of many subjects
21:32:16 <ab9rf> and if you want to learn more in depth, that's what grad school is for
21:32:22 <Mortchek> shapr, I don't see what the points in "Why is it useful for AI?" have to do with AI in particular.
21:32:42 <ab9rf> monochrom: unless the school is large enough to have subdepartments, basically
21:32:46 <nbouscal> programming as practiced in industry is essentially a trade, yet we adopt none of the lessons learned by tradesmen
21:32:50 <shapr> Mortchek: Yah, I pretty much made that up. Got any other ideas?
21:33:01 <shapr> Mortchek: Got any suggestions as to why FP might be good for AI?
21:33:08 <ab9rf> nbouscal: i reject the role of computer science programs as vocational training for the programming industry
21:33:12 <Mortchek> None that spring to mind.
21:33:17 <Trollkastel> nbouscal: Programming as practiced in the industry is the kind of thing you think ought to be taught?
21:33:20 <shapr> In my opinion, Lisp's popularity for AI is a historical accident, not really anything to do with FP
21:33:27 <Mortchek> I take it as pretty much a given that FP is just better overall. :P
21:33:28 <ab9rf> nbouscal: codefarms don't want or need computer scientists.
21:33:32 <nbouscal> Sorry, should have been clearer, I'm saying in actual workplaces.
21:33:39 <nbouscal> After the degree program, or in place of it.
21:33:56 <shapr> Mortchek: While I agree, I'm trying to persuade undergrads that they should learn FP on their own free time.
21:34:04 <ab9rf> nbouscal: you're talking about software engineering, not computer science
21:34:13 <nbouscal> ab9rf: Exactly, and the fact that they are different.
21:34:21 <nbouscal> ab9rf: We seem stuck in a delusion that they are not
21:34:34 <ab9rf> nbouscal: that's widespread, of course
21:34:40 <nbouscal> of course.
21:35:29 <monochrom> even large schools must miss out a number of "important" topics. I put it in quotes because they're so important to you but I beg to differ
21:36:31 <nbouscal> shapr: reference the AI portion of "Why FP Matters" ?
21:36:41 <shapr> That's a good idea
21:37:01 <Mortchek> shapr, you could probably make some sort of argument about how you don't need to keep as much of the system in your head at once owing to lack of state, but, again, that's not really particular.
21:37:09 <Mortchek> +to AI
21:37:50 <tgeeky> computer science is also very, very young. chemistry and physics have had hundreds of years to be arranged and rearranged; mathematics has had thousands.
21:37:55 <Mortchek> But if you maybe elaborate a bit and say how these advantages apply to AI (I'm not that familiar with the field myself so I'm not sure I can think of any), that might make the slide more on-point.
21:38:04 <monochrom> for example in my school U of Toronto CS, we have no PL, no category theory, no type system. you will say my school is boring. but we have everything else. we have Stephen Cook, cryptography, distributed systems, machine learning, OS, network, software engineering, bioinformatics, computer forensics, ...
21:38:26 <tgeeky> monochrom: sounds good to me.
21:38:26 <nbouscal> I guess CS has a similar problem to Mathematics, in that there is such a broad diversity of fields of study, but with the difference that Mathematics tends to have a reasonably agreed-upon core that is essential to understanding neighboring fields. the CS 'core' is a moving target
21:38:51 <monochrom> and MIT, while it has PL, that is mostly untyped, it misses out the type system front, and I'm sure it misses some other things
21:38:59 <ab9rf> nbouscal: eventhere the 'core' mathematics varies from institutions
21:39:22 <ab9rf> nbouscal: largely depending on what the professorship there favors.
21:39:38 <shapr> Mortchek: Thanks for the input, if you think of anything else before 10am tomorrow, I want to hear more :-)
21:39:40 <nbouscal> varies, yes, but everywhere you will see an introduction to algebra, an introduction to real and complex analysis, an introduction to topology. as well as of course the calc series, DE, linear alg
21:39:47 <monochrom> one year, we came very close to hiring a PL prof. but he had two choices. us or another school that already had some PL people. clearly, he chose not us. therefore, we still have no PL prof.
21:40:12 <ab9rf> nbouscal: CS ought to have a fairly stable core but we get all caought up on language choice instead of teaching ocncepts
21:40:47 <nbouscal> ab9rf: Right. That's one thing I really enjoyed about the PL class at University of Washington which I just took via Coursera. He used SML, Racket, and Ruby, and emphasized that he was teaching concepts not languages.
21:40:57 <ab9rf> plus there's all the idiotic abortions like teaching TCP/IP internals as a CS topic
21:41:07 <Mortchek> What concepts are very probably fundamental in CS? I would say abstraction is one. What else?
21:41:27 <arkeet> "abstraction" doesn't sound like a CS thing.
21:41:34 <nbouscal> algorithms and data structures sounds like a fundamental concept
21:41:45 <monochrom> abstraction is very hard to teach as its own course. too abstract.
21:41:47 <ab9rf> Mortchek: compiler theory, algorithm analysis, data structures
21:42:00 <Trollkastel> Mortchek: The fact machines, languages, and grammars go hand in hand?
21:42:05 <Mortchek> Well, lots of CS things are a form of abstraction. Things dealing with functions and data, for example.
21:42:06 <arkeet> compiler theory doesn't sound like something everyone needs.
21:42:13 <Mortchek> monochrom, good point :P
21:42:15 <ab9rf> arkeet: it was required at my old school
21:42:23 <arkeet> what's required for a degree program is different
21:42:32 <nbouscal> compilers sounds like an important elective
21:42:39 <ab9rf> arkeet: i think it's an area most undergrads ought to be exposed to at least briefly
21:42:42 <arkeet> for sure
21:42:55 <coppro> My school has two compilers courses. The exposed briefly course, which is mandatory, and the real one, which is not
21:43:03 <ab9rf> the idea of NFAs and DFAs, context-free languages, recognition problems, etc
21:43:16 <monochrom> a category theory course may count as an abstraction course.
21:43:17 <arkeet> disclaimer: I have not done a CS program.
21:43:17 <dmj`> this book is really good. If all I had was this and CLRS wouldn't be too bad. http://csapp.cs.cmu.edu
21:43:26 <ab9rf> my old school also used that class to expose students to a bunch of different languages
21:43:34 <arkeet> oh, that stuff is part of "compiler theory"?
21:43:48 <ab9rf> arkeet: it was when i did CS in the late 80s :)
21:43:52 <nbouscal> graph theory might merit it's own course but i don't know
21:43:59 <Mortchek> monochrom, there's hardly any CT even in math programs, isn't there?
21:44:03 <Trollkastel> nbouscal: Why graph theory specifically?
21:44:04 <ab9rf> nbouscal: a class in discrete mathematics might be useful
21:44:08 <monochrom> that's right
21:44:12 <arkeet> Mortchek: indeed
21:44:14 <nbouscal> discrete mathematics i think for sure, actually
21:44:21 <dmj`> discrete math was a hard class
21:44:22 <nbouscal> Trollkastel: Seems to come up an awful lot
21:44:35 <ab9rf> few CS students have had discrete math and i think it hurts them
21:44:52 <arkeet> Mortchek: although you're inevitably exposed to some of it in some courses
21:45:02 <nbouscal> more math in general i think is essential. linear algebra
21:45:11 <arkeet> everyone needs linear algebra.
21:45:14 <nbouscal> honestly i think linear algebra is often more important than calculus
21:45:15 <ab9rf> i don't remember what our math requirement was
21:45:17 <arkeet> me too.
21:45:18 <Mortchek> Sure, I mean set theory contains some category theory for example, and you generally see that
21:45:20 <ab9rf> i was a math/cs double
21:45:23 <ab9rf> originally
21:45:29 <nbouscal> that's what I'd be if I went back
21:45:44 <ab9rf> and so i was doing math requirements in parallel and i don't remmeber whether linear algebra was required for CS because it was obviously required for math
21:45:49 <arkeet> most people don't use set theory to any significant depth.
21:45:59 <Mortchek> My professor for discrete structures even used CT terminology when talking about sets and functions, which I found helpful as I was beginning to scratch the surface of CT at the time
21:46:04 <nbouscal> naive set theory is enough for most purposes and is part of a discrete math class
21:46:12 <Mortchek> (I still am only scratching the surface, and just barely :P)
21:46:29 <monochrom> did you know: the notation "f : X -> Y" is from category theory people
21:46:44 <Mortchek> I did not know that but it's not surprising
21:46:50 <arkeet> citation needed.
21:47:09 <Trollkastel> monochrom: For some reason I thought the CT notation "f : X -> Y" was designed by analogy with sets and functions. :-|
21:47:21 <Trollkastel> monochrom: It is nice to know it was the other way around..
21:47:27 <nbouscal> hasn't that notation been around for longer than category theory has?
21:47:32 <arkeet> that was my thought.
21:47:41 <Mortchek> Sounds like a citation is definitely in order.
21:47:43 <tgeeky> hysterical raisins!
21:48:34 <tgeeky> http://www.cse.chalmers.se/~nicsma/hipspec-cade.pdf <- how cool is this!
21:49:21 <monochrom> I heard it from friends with math degrees. one day, I complained about inconsistent math notation (again), why it is x E X but not f E X->Y, why they inconsistently switch between E and colon. my friends said, but colon is from category theory!
21:50:09 <Mortchek> That's not as bad as the notation f = O(n)
21:50:43 <shapr> What's the latest high water mark on #haskell?
21:50:49 <shapr> I heard 1100 or something?
21:50:52 <arkeet> but it still makes perfectly good sense in category to write f \in hom(X,Y)
21:50:53 <Mortchek> My professor actually tried to use equational reasoning on that but I just ended up confused as a result
21:51:04 <arkeet> category theory.
21:51:32 <mjrosenb> Mortchek: I don't use that notation, I always use f \in O(n)
21:51:43 <Mortchek> Yeah, that is the way I write it
21:52:04 <arkeet> I would write it that way, but I'd still say "f is O(n)"
21:52:22 <mjrosenb> Mortchek: if enough people start using the right notation, eventually it'll stick
21:52:23 <ab9rf> i have always used "in" rather than "is"
21:52:24 <arkeet> which is fine, since "is" isn't equality.
21:52:26 <Mortchek> Sure, but = and "is" are not interchangeable. "is" is one seriously overloaded word
21:52:30 <arkeet> :p
21:52:41 <arkeet> "f is green"
21:52:59 <ab9rf> but i'll also say "f is quadratic" instead of "f has quadratic time complexity" or whatever
21:52:59 <mjrosenb> arkeet: that is fine, you are describing f with the property "O(n)", it is like saying "the dog is big"
21:53:03 <arkeet> exactly.
21:53:06 <Mortchek> "f is green" means either "f is in the set of green objects" or "f equals the color green", with decreasing probability
21:53:13 <mjrosenb> arkeet: which is equivalent to "this dog is in the set of large dogs"
21:54:58 <Mortchek> Time to go collapse on something soft and be unconscious for a while. Good night~
21:55:01 --- mode: ChanServ set +o elliott
21:55:08 --- mode: elliott set -b *!~michael@unaffiliated/maikeru/x-7708887$##fixyourconnection
21:55:09 <shapr> Mortchek:  thanks for the suggestions
21:55:11 --- mode: elliott set -o elliott
22:00:27 <mjrosenb> is conal elliott still in the channel? (as I notice "elliott" kicking someone)
22:00:53 <dolio> conal is conal
22:00:57 <dolio> He's not here right now.
22:01:16 * elliott kicked nobody :)
22:02:36 <byorgey> conal is conal.  elliott is elliott.  conal is not elliott.  conal is Elliott.  elliott is not Elliot.
22:02:49 <ab9rf> identity is such a confusing concept
22:02:53 <c_wraith> are you sure elliot isn't Elliot?
22:03:05 <shachaf> elliottt is Elliott
22:03:07 <c_wraith> I mean, conal *is* Conal.
22:03:16 <elliott> elliottt is - yes
22:03:17 <byorgey> c_wraith: not the one I was talking about.
22:03:33 <elliott> c_wraith: I know of no elliot
22:03:49 <elliot[> aww
22:04:05 <shapr> gruss gott tensorpudding
22:04:11 <mjrosenb> dolio: that is what I remember
22:04:30 <mjrosenb> elliott: oops, flipped the sign on that 'b', although I guess that isn't a kick?
22:04:40 <mjrosenb> byorgey: thank you for the clarification.
22:05:08 <byorgey> -b is an unban.
22:05:16 <elliott> every time someone listens to me, some part of me suspects it's because they think it's Conal
22:07:44 <cmccann> elliott: yes but how often do people actually listen to you?
22:07:48 <cmccann> shachaf doesn't count
22:07:58 <elliott> cmccann: :(
22:08:01 <elliott> cmccann: you listen. sometimes.
22:08:02 <monochrom> I listen to elliott.
22:08:08 <cmccann> :D
22:08:23 <elliott> monochrom: very poor decision, I think
22:08:30 <shachaf> cmccann: Why don't I count?
22:09:50 <cmccann> shachaf: because I wanted to see if you'd react to me saying that mostly
22:09:57 <ab9rf> i don't count
22:10:01 <ab9rf> i have computers to do that for me
22:10:29 <monochrom> I am those computers
22:10:44 <cmccann> shachaf: you and elliott have a track record of encouraging each other's bad ideas anyway, that's not news
22:11:16 <shachaf> cmccann: I may listen to elliott, but he also listens to me.
22:11:21 <shachaf> Otherwise how would he know what not to do?
22:12:08 * cmccann has a vague mental image of elliott and shachaf as statler and waldorf, sitting up in the box and heckling edwardk
22:12:40 <mjrosenb> cmccann: were those the grumpy hecklers from the muppets?
22:12:45 <cmccann> yes
22:12:49 <cmccann> a.k.a. best muppets ever
22:13:07 <monochrom> <3 muppets
22:13:43 <shachaf> monochrom: Yes. In particular, 2 muppets.
22:14:08 <monochrom> umm!
22:14:09 <mjrosenb> cmccann: http://basicinstructions.net/basic-instructions/2008/9/15/how-to-reveal-a-shocking-truth-to-a-person-whos-not-ready-fo.html
22:14:42 <monochrom> so much text to read
22:14:57 <mjrosenb> monochrom: basic instructions usually makes it worth it.
22:15:29 <shachaf> The IRC user that you know as "beaky" actually speaks perfect English.
22:16:47 <monochrom> oh no, hahaha
22:17:06 <monochrom> I almost forgot beaky
22:18:19 <mjrosenb> shachaf: I'm guessing this is a person that I haven't met (and isn't in channel atm)
22:18:45 <arkeet> beaky loves monoids.
22:18:52 <shapr> Who doesn't?
22:19:00 <arkeet> I dunno.
22:19:39 <shachaf> I don't.
22:19:44 <arkeet> why not?
22:19:49 <shachaf> Lack of type safety.
22:20:02 <arkeet> they are perfectly safe. there is only one type.
22:20:10 <shachaf> That's the trouble.
22:20:15 <shachaf> Lack of guidance by the type checker.
22:20:23 <arkeet> that's not a question of safety.
22:20:35 <shachaf> Eh. What is type safety?
22:20:58 <arkeet> the thing that lets you avoid writing partial functions.
22:21:29 <shachaf> Hmm. Haskell doesn't have type safety. :-(
22:21:37 <monochrom> SQL has type safety
22:21:49 <arkeet> actually
22:21:54 <arkeet> I have no idea what type safety is.
22:22:01 <shachaf> Now we're getting somewhere!
22:22:22 <arkeet> In computer science, type safety is the extent to which a programming language discourages or prevents type errors.
22:23:04 <monochrom> that just moves the question to "what is type error?"
22:23:18 <arkeet> wikipedia has an answer to that too.
22:23:19 <arkeet> A type error is erroneous or undesirable program behaviour caused by a discrepancy between differing data types for the program's constants, variables, and methods (functions), e.g., treating an integer (int) as a floating-point number (float).
22:23:25 <cmccann> type safety is a measurement of how much blame the programmer deserves for writing a partial function
22:23:33 <elliott> monochrom: an error that, were it not forbidden, would result in violation of type safety.
22:23:51 <monochrom> this is why I listen to elliott :)
22:24:14 <arkeet> I should have listened to elliott.
22:24:19 <shachaf> Do you listen to me?
22:24:25 <monochrom> yes
22:30:42 <byorgey> type safety means that some language designer somewhere decided to just chuck a whole class of programs out the window
22:30:58 <byorgey> and hopefully they are the ones you didn't want to write.
22:31:04 <greymalkin> Any good (pure) screen scraping utilities in haskell (like BeautifulSoup for python, or some such)
22:31:30 <greymalkin> s/utilities/libraries/
22:31:32 <byorgey> @package tagsoup
22:31:33 <lambdabot> http://hackage.haskell.org/package/tagsoup
22:31:37 <byorgey> greymalkin: ^^^
22:31:43 <BMeph> Wasn't that a take-off of tagsoup?
22:33:58 <greymalkin> Excellent.
22:34:35 <mjrosenb> greymalkin: almost certainly won't be pure, since it sounds like it involves IO.
22:35:06 <greymalkin> mjrosenb: Nothing impure about parsing text; it's where it comes from that's impure.
22:35:38 <shachaf> "screen scraping" sure sounds like it has something to do with a screen. :-(
22:36:18 <greymalkin> Usually used to denote "get info from the web... the hard way"
22:36:35 <shachaf> By taking screenshots and OCRing?
22:37:04 <monochrom> I feel like I'm an alien now
22:37:52 <elliott> finally the truth about monochrom is revealed
22:53:49 <devn> Warning: haddock-html: /usr/local/Cellar/haskell-platform/2012.4.0.0/share/doc/HUnit-1.2.5.1/html doesn't exist or isn't a directory
22:54:07 <devn> I'm trying to get haskell set up properly on OSX and keep seeing this from ghc-pkg check
22:54:37 <devn> i uninstalled ghc, cabal-install, hugs, haskell-platform (all from homebrew)
22:54:40 <tgeeky> devn: you or the haskell platform you got didn't build documentation for HUnit. You can ignore that warning.
22:54:59 <devn> tgeeky: there are many more
22:55:13 <tgeeky> devn: as long as they are all warnings, you can ignore them.
22:55:28 <tgeeky> You may want to enable building documentation by default in your ~/.cabal/config file
22:55:28 <devn> tgeeky: cool, thanks.
22:55:57 <devn> once I've made documentation: True
22:56:01 <devn> do i need to cabal install world?
22:56:37 <tgeeky> devn: no. The docs for those libraries won't be built unless you reinstall them, which I don't think you should do.
22:56:51 <devn> fair enough
22:56:52 <devn> thanks
22:57:11 <tgeeky> devn: you should enable doc: True as soon as possible after a fresh install
23:05:01 <sw2wolf> @type whenJust
23:05:02 <lambdabot> Not in scope: `whenJust'
23:05:11 <sw2wolf> @hoogle whenJust
23:05:11 <lambdabot> No results found
23:05:37 <Kinnison> what would whenJust do?
23:05:48 <shachaf> Probably the same thing as for_
23:05:52 <sw2wolf> whenJust ml $ \l -> ...
23:06:04 <cmears> fromMaybe (return ())  ?
23:06:04 <sw2wolf> from xmonad
23:06:30 <cmears> (with a flip, maybe)
23:07:13 <sw2wolf> @ty when
23:07:14 <lambdabot> Monad m => Bool -> m () -> m ()
23:08:03 <sw2wolf> guess whenJust means if it is not Nothing then do something
23:08:37 <sw2wolf> with the value in Just
23:27:43 <shanks_> Hi all! If I have a list [a,b,c,d] and a value e, how can I turn than into a list full of lists that have this format: [[e,a],[e,b],[e,c],[e,d]]
23:28:02 <shachaf> map (\x -> [e,x])
23:30:50 <ion> > map (\x -> [e,x]) [a,b,c,d]
23:30:53 <lambdabot>   [[e,a],[e,b],[e,c],[e,d]]
23:32:05 <shanks_> awesome!
23:32:24 <shanks_> thanks, guys!
23:32:41 <shanks_> i was going to do some sort of list comprehension thing, but i knew there was a simpler way
23:33:02 <ion> > [ [e,x] | x <- [a,b,c,d] ]
23:33:04 <cmears> list comprehension version would look nice too I reckon
23:33:06 <lambdabot>   can't find file: L.hs
23:33:06 <cmears> see?
23:33:11 <ion> > [ [e,x] | x <- [a,b,c,d] ]
23:33:13 <lambdabot>   [[e,a],[e,b],[e,c],[e,d]]
23:33:30 <ion> I would use the map version myself.
23:33:49 <shachaf> So would I.
23:33:50 <shachaf> List comprehensions are overrated.
23:33:52 <mjrosenb> shanks_: you sure you want a list of lists, and not a list of tuples?
23:34:05 <mjrosenb> i,i map (,e)
23:34:53 <shanks_> yeah, i want a list of lists because I want to perform a function on two parameters at a time, so i think passing each list within the list would be easier, since the values a,b,c,d,e are data structures
23:47:08 <derek_c> Hello! I have a quick question: is there a way to declare the type of a local variable inside a function?
23:47:14 <nbouscal> Is there a recommended plugin for vim for highlighting/indentation/etc?
23:47:47 <opqdonut> derek_c: yes, just do it
23:48:00 <derek_c> opqdonut: what do you mean?
23:48:01 <opqdonut> e.g. "let a :: Int; a = 3; b = True; in (a,b)"
23:48:15 <derek_c> opqdonut: oh cool! thank you!
23:48:28 <opqdonut> alternatively you can use "let a = 3 :: Int"
23:49:33 <derek_c> yep it works!~
23:49:41 <derek_c> nbouscal: :: [Tag L.ByteString]
23:50:21 <derek_c> nbouscal: sorry wrong link. this one: http://www.haskell.org/haskellwiki/Vim
23:50:44 <nbouscal> derek_c: Thank you
23:51:19 <nbouscal> Not much a fan of tabstop=8 :/
23:51:50 <Ghoul_> What does %~ do
23:52:02 <Ghoul_> :t %~
23:52:04 <lambdabot> parse error on input `%~'
23:52:35 <fxr> we sholuld s/tab/indent/
23:52:38 <mjrosenb> :t (%~)
23:52:40 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
23:53:00 <Ghoul_> o-O
23:53:19 <Cale> tee hee
23:53:32 <Cale> Ghoul_: Probably best to just assume p = (->)
23:53:53 <Ghoul_> I'll just pretend it's not there
23:53:57 <shachaf> And Setting (->) s t a b = ((a -> Identity b) -> s -> Identity t)
23:54:09 <Ghoul_> stab, lol
23:54:23 <FireFly> Yeah, lenses are really stabby
23:54:33 <Ghoul_> Ah, it's lens stuff
23:54:35 <FireFly> dangerous things
23:54:41 <nbouscal> here i was just about to try to learn about lenses, now i'm not so sure
23:55:02 <Cale> Well, Setting (->) s t a b is the type of a lens which gives you permission to replace something of type a with something of type b to change an overall structure of type s to something of type t.
23:55:30 <shachaf> Well, in particular it's how you consume such a lens-like thing.
23:56:47 <ion> l %~ f = runIdentity (l (Identity . f))
23:56:58 <ion> For example, with _1 f (a,b) = (,b) <$> f a…
23:57:09 <FireFly> What is the "p" part in general, if you don't assume it's (->)
23:57:36 <ion> (_1 %~ f) (a,b) = runIdentity ((,b) <$> Identity (f a))
23:57:47 <Ghoul_> ick, lenses don't represent any type of imperative getter/setter
23:57:57 <ion> > runIdentity ((,"bar") <$> Identity (reverse "foo"))
23:57:59 <lambdabot>   Illegal tuple section: use -XTupleSections
23:58:07 <ion> > runIdentity ((\x -> (x,"bar")) <$> Identity (reverse "foo"))
23:58:09 <lambdabot>   ("oof","bar")
23:58:09 <shachaf> ion: That's why people like to demonstrate with _2 :-)
23:58:17 <shachaf> This isn't exactly about lenses as such.
23:58:20 <ion> > ("foo","bar") & _1 %~ reverse
23:58:22 <arkeet> FireFly: it could be some indexed thing for indexed lenses, or a Choice thing for prisms
23:58:23 <lambdabot>   ("oof","bar")
23:58:26 <shachaf> I should write my lenstroduction. :-(
23:58:35 <arkeet> yet another lens tutorial
23:58:39 <FireFly> shachaf: yes you should
23:58:45 <shachaf> arkeet: Except it would be good because I would write it? QED
23:58:49 <arkeet> I suppose.
23:58:54 <shachaf> Actually it would probably not be very good.
23:59:03 <shachaf> But at least I could only blame myself (and arkeet).
23:59:14 <arkeet> shachaf: I have an idea for how you could write the best lenstroduction.
23:59:19 <arkeet> get edwardk to do it.
23:59:27 <Ghoul_> does lens plug into Data.Serialize or something
23:59:40 <shachaf> arkeet: I disagree with edwardk on matters of lens pedagogy.
23:59:45 <arkeet> ok.
23:59:54 <arkeet> get gabriel gonzalez to write it.
