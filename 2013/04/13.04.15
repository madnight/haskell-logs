00:00:20 <arkeet> as a last resort, get me to write it.
00:00:21 <shachaf> I disagree with gabriel gonzalez on matters of lots of things.
00:00:29 <shachaf> OK, I don't know your stance on lens pedagogy.
00:00:33 <shachaf> So gopher it.
00:00:34 <arkeet> me either.
00:00:59 <arkeet> I'll do it when I get some free time.
00:01:58 <Cale> Ghoul_: Well, they're like functional abstractions of those. Simplifying things greatly, you can imagine just starting out with a type like:
00:02:25 <Ghoul_> Cale: I'm just gonna watch the video \o/
00:02:26 <Cale> data Lens a b = L { view :: a -> b, set :: b -> a -> a }
00:02:33 <Ghoul_> by edward
00:02:40 <Cale> ah, yeah, that's a good intro
00:07:31 <Ghoul_> ick
00:07:40 <derek_c> :quit
00:07:53 <Ghoul_> 10 minutes into the video I have a headache from too much comonad coalgebra cosomethingelse
00:08:05 <Cale> hah
00:08:12 <Cale> Which video are you watching?
00:08:14 <nbouscal> something something dual something
00:08:48 <nbouscal> it's cool it's just a cohomology on an abstract dual space
00:08:53 <nbouscal> >.> <.<
00:09:15 <Ghoul_> http://www.youtube.com/watch?v=cefnmjtAolY&feature=youtu.be&hd=1
00:09:37 <Cale> oh, this one
00:10:30 <Cale> yeah, don't start with that :)
00:10:45 <nbouscal> hahaha
00:10:58 <Cale> http://www.youtube.com/watch?v=efv0SQNde5Q -- maybe this one would be good
00:11:04 <Cale> Though it's oddly not in Haskell
00:12:25 <Ghoul_> ick my head hurts
00:12:32 <Ghoul_> I'll try the second one
00:13:22 <shachaf> I wish we knew how to do good pure profunctor traversals without representability.
00:13:30 <shachaf> arkeet: ☝exercise☝
00:13:43 <arkeet> well the point is that a lens is a getter and a setter packaged up into a thing that's composable.
00:14:04 <greymalkin> > ([a] -> a) -> [m a] -> m [a]
00:14:06 <lambdabot>   <hint>:1:12: parse error on input `->'
00:14:47 <arkeet> a getter looks like s -> a
00:14:56 <arkeet> a setter looks like a -> s -> s
00:15:07 <arkeet> so if you wanted to, you could type Lens s a = (s -> a, a -> s -> s)
00:15:26 <arkeet> or probably use data
00:15:40 <arkeet> and then write some way of composing them (lenses form a category)
00:15:50 <elliott> Cale: hm, what's wrong with the 2hr one?
00:16:27 <arkeet> but the magic of the lens library is that
00:16:41 <arkeet> well, twanvl observed that another way to represent lenses is
00:16:50 <arkeet> Lens s a = forall f. Functor f => (a -> f a) -> (s -> f s)
00:16:58 <shachaf> elliott: hey remember symmetric lenses
00:17:07 <shachaf> i.e. remember when we didn't know a thing about anything
00:17:20 <Cale> elliott: I seem to recall it being a bit too advanced for beginners?
00:17:41 <arkeet> to get a setter out of that, you could put f = identity, so you have (a -> a) -> (s -> s)
00:17:43 <shachaf> I learned lens from it!
00:17:46 <arkeet> and then you pass it some constant function.
00:17:51 <shachaf> Well, from that talk. Not the video.
00:17:56 <elliott> I haven't watched it myself, just seen other people watch it :P
00:17:59 <arkeet> to get a getter, you could put f = Const a
00:18:07 <arkeet> so the lens thing comes (a -> a) -> (s -> a), and then you pass it id
00:18:13 <arkeet> becomes*
00:18:35 <arkeet> and the category structure just comes from the identity function and composition of functions
00:18:38 <arkeet> which is nice.
00:19:01 <arkeet> and it's also really easy to write lenses in this form. it's almost as easy as just writing a setter, and you get a getter for free.
00:19:38 <arkeet> :t \f (x,y) -> (,) (f x) <$> y
00:19:40 <lambdabot> Functor f => (t -> a1) -> (t, f a) -> f (a1, a)
00:19:46 <arkeet> errr
00:19:52 <hpaste> awgn pasted “catch problem” at http://hpaste.org/85816
00:20:02 <shachaf> arkeet: Well, lots of other forms are easy to write lenses in.
00:20:16 <arkeet> whatever.
00:20:32 <arkeet> shachaf: writing separate getters and setters is annoying.
00:20:51 <shachaf> > let _2 (x,y) = (y, \y' -> (x,y')); view l s = fst (l s) in view _2 (1,2)
00:20:53 <lambdabot>   2
00:21:09 <shachaf> That version supports polymorphic lenses and sharing and everything.
00:21:11 <awgn> morning, is it possible for a catch handler to capture variable declared in the same IO action ?
00:21:23 <arkeet> :t \f (x,y) -> (,) x <$> f y
00:21:25 <lambdabot> Functor f => (t -> f a) -> (a1, t) -> f (a1, a)
00:21:35 <shachaf> arkeet: This version isn't rank-2. :-)
00:22:04 <arkeet> shachaf: but you're essentially writing separate getters and setters
00:22:18 <shachaf> arkeet: Hmm? You're doing the same thing the Functor version is doing.
00:22:27 <shachaf> You're just using a tuple instead of fmap
00:22:36 <arkeet> ??
00:23:25 <arkeet> what "Functor version"?
00:23:33 <shachaf> The "lens" version with the fmap
00:23:42 <shachaf> @ty let transform l f s = let (a,b) = l s in b <$> f a in transform
00:23:43 <lambdabot> Functor f => (t1 -> (t, a -> b)) -> (t -> f a) -> t1 -> f b
00:24:07 <arkeet> I still argue that it's easier.
00:24:16 <shachaf> arkeet: I don't see a monoid...
00:24:24 <arkeet> easier.
00:24:25 <arkeet> not easy.
00:25:13 <shachaf> You think it's easier because you've spent way more time on it, or something.
00:25:24 <elliott> arkeet: well, what shachaf writes as (x,y) is y <$> f x in the functor version.
00:25:32 <elliott> they're equivalent modulo very light syntax sugar
00:25:49 <arkeet> but he's writing a separate getter.
00:26:09 <shachaf> ?
00:26:14 <arkeet> (y,
00:26:27 <shachaf> <$> f x
00:26:37 <Ghoul_> the second one didn't asplode my brain
00:26:41 <Ghoul_> so its k
00:26:42 <elliott> (x,y) = (y, \y' -> (x,y'))
00:26:47 <elliott> er
00:26:50 <elliott> \(x,y) -> (y, \y' -> (x,y'))
00:26:56 <elliott> \f (x,y) -> f y <&> \y' -> (x,y')
00:26:57 <elliott> compare
00:27:19 <arkeet> I'm dumb
00:27:34 <elliott> we all are.
00:27:36 <arkeet> but the point is that it looks a lot more like just writing a setter
00:27:54 <shachaf> It looks almost exactly the same.
00:28:40 <arkeet> really I'd rather think of it as a pair of a getter and a SEC.
00:29:01 <greymalkin> Man, I wish I had thought about changing some shell scripts I wrote to haskell a while ago. Excellent way to learn.
00:29:52 <arkeet> I should learn some more category theory, to better understand lenses.
00:29:54 <arkeet> er, lens.
00:30:27 <arkeet> I still only have a vague idea of what ends and kan extensions and stuff are.
00:30:55 <arkeet> hmm
00:31:13 <arkeet> I should see how far one can get by thinking of lenses as natural transformations.
00:31:58 <arkeet> between functors End(Hask) -> Hask that take f to (a -> f a) or something.
00:32:29 <arkeet> is that even a functor? who knows.
00:32:45 <arkeet> between "things", then.
00:34:38 <arkeet> maybe I should think about profunctors.
00:38:43 <arkeet> I think profunctors is the right way to think about this, actually.
00:39:32 <arkeet> let's go to -lens
00:45:24 * hackagebot binary-file 0.15.10 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.15.10 (YoshikuniJujo)
00:46:50 <ryantanjunming> \nick astonia
00:59:03 <mercuryrising> is there a rhyme or reason to what :t outputs? sometimes it say Num a => a, other times it's b, other times it's t, why does it change?
01:00:20 <shachaf> It tries to make nice types based on the types of the things you use.
01:00:30 <shachaf> Look at the types of the things you use, match them up.
01:00:44 <shanks_> Say I have a list of data structures that I'm pattern matching. If the list is in the format [a,b,c,d], and I'm pattern-matching things within a,b,c,d, (say the data structure a has fields (Type p1 p2 p3)) how do I reference the data structure I'm on so I can pass that to a function? I've pattern-matched p3 within the structure, but I want to pass the whole, e.g. "b" structure as a parameter in a where clause.
01:00:57 <shachaf> "t" is probably the default if it doesn't have anything to go by.
01:01:22 <shachaf> shanks_: name@pattern matches on the pattern and gives the whole thing the name "name"
01:01:50 <shanks_> I tried doing struct@(Type p1 p2 p3) and then using "struct" as the parameter, but ghci gives me an error
01:02:16 <shanks_> it says that struct is not in scope
01:02:54 <shachaf> OK.
01:02:58 <shanks_> let me rephrase...
01:03:08 <shachaf> I find myself compelled to infer that you did something wrong.
01:03:23 <shachaf> Unfortunately I can't tell you what. :-)
01:03:27 <no-n[9]> what's the difference between mod and rem?
01:03:36 <shanks_> I figured I did something wrong... It has got to do with me putting the name@pattern on the left side of the =
01:03:40 <shachaf> @google haskell mod vs rem
01:03:41 <lambdabot> http://stackoverflow.com/questions/5891140/difference-between-mod-and-rem-in-haskell
01:03:41 <lambdabot> Title: Difference between `mod` and `rem` in Haskell - Stack Overflow
01:03:52 <shachaf> shanks_: (If you show your code, maybe someone can help you.)
01:04:42 <shanks_> If I use (x:xs), would that reference just the first element of the list xs, or the current match?
01:04:58 <shanks_> I'm using just xs as my list pattern
01:05:05 <shachaf> I don't know. Try it.
01:05:39 <shachaf> (By "I don't know" I mean that I don't understand your question. But ghci is a good way to figure out these sorts of things.)
01:06:58 <shanks_> hehe. yeah, i tried replacing xs with (x:xs) and then giving it a name like name@(x:xs), but when I pass this as a parameter, it send the whole list instead of just the x element.
01:07:18 <shanks_> oh wait, i can just use x now
01:07:20 <shanks_> let me try that
01:16:22 <augur> interesting observation: &L in the SC is an associativity rule on contexts if your internal and external conjunction is the same
01:24:40 <quchen> I did not understand a word of that, augur.
01:25:05 <quchen> Is it understandable without substantial study?
01:25:17 <augur> quchen: lol :)
01:25:24 <shachaf> Is it on-topic?
01:25:43 <Twisol> Is there ever a situation where you might want an IO (IO a) ?
01:25:56 <shachaf> Twisol: Sure.
01:26:13 <shachaf> For example spawn :: IO a -> IO (IO a) spawns off a thread and gives you an IO action you can use to wait for the result.
01:27:21 <Twisol> Hmm, okay.
01:28:04 <Ghoul_> what does IO (IO a) even mean
01:28:14 <Twisol> I'm actually dealing with an analogous (I think) situation, with promises in Javascript
01:28:39 <Twisol> and I'm trying to come up with an example of when you want a nested promise without joining it
01:28:52 <quchen> Twisol: I often like to have a dedicated thread for printing etc. That thread reads from a Chan, and that Chan is filled with IO actions to execute. When you pop an element from that, you'll get an IO (IO a).
01:29:16 <Twisol> Can you show me an example of how you would use that?
01:29:57 <quchen> Not below a couple of hundred of lines :s But I could write a minimal example I guess
01:30:30 <Twisol> Hehe. I'd appreciate it, but not a big deal.
01:32:04 <shachaf> IO actions are first-class in Haskell. This is a powerful concept.
01:32:05 <danr> augur: what is &L and SC in your sentence? and have you had a look at substructural logics/type systems?
01:32:25 <augur> &L = & left rule in SC, SC = sequent calculust
01:32:26 <pygmalion> Is there some way to model an undirected graph with the data structure in Data.Graph other than just adding two edges (from A to B and B to A) for every set of connected nodes?
01:32:29 <augur> calculus*
01:34:25 <Ghoul_> !seen BONUS
01:52:01 <rohitkav> How to install haskell fully in my ubuntu 12.10 machine
01:52:51 <Botje> rohitkav: install the haskell-platform package. it's by far the easiest way.
01:53:27 <rohitkav> through synaptic package manager or through terminal
01:53:43 <rohitkav> i need to get everything updated so that i can install yesod, Botje
01:56:48 <quchen> rohitkav: Terminal is pretty much the same as Synaptic. Synaptic means clicking "haskell-platform", terminal means entering "sudo apt-get install haskell-platform".
01:57:33 <rohitkav> will it get me every necessary packages installed
01:57:50 <Sonderblade> love it how haskell-mode offers up three different identation modes to choose from with absolutely no information on what distinguishes them
01:57:53 <quchen> Do you have GHC?
01:58:36 <shanks_> how do I access a value inside a data structure? Say I have a data structure x, which is like (Type p1 p2 p3), I want to know how I can assign just p3 to a variable as in a = p3
01:59:06 <arkeet> you pattern match.
01:59:20 <quchen> shanks_: Many possible ways. Pattern matching the straight way, pattern matching using records, Lens.
01:59:43 <arkeet> I don't know what "(Type p1 p2 p3)" means, though.
02:00:17 <shanks_> as in x :: Type, where Type is a data structure with fields p1 p2 p3
02:00:37 <shachaf> data Data datа dаta dаtа = Data datа dаta dаtа
02:00:37 <arkeet> surely it has a constructor.
02:00:38 <darinmorrison> shanks_: case x of Type _ _ a -> ...
02:00:47 <arkeet> if you had
02:00:54 <arkeet> well
02:01:03 <arkeet> if you had e.g.
02:01:07 <arkeet> type X = C Int Bool
02:01:17 <arkeet> and you had some x :: X and you wanted to access the Int
02:01:28 <arkeet> you pattern match on the C constructor.
02:01:50 <arkeet> e.g. in a function definition: f (C a b) = ... -- now a :: Int and b :: Bool
02:02:03 <arkeet> or, if you have some x :: X, you can case x of C a b -> ..
02:02:09 <shanks_> so a = (C a _ )
02:02:12 <arkeet> (if you don't care about b, you can match on C a _)
02:02:13 <arkeet> sure
02:02:23 <arkeet> oops
02:02:28 <arkeet> I meant: data X = C Int Bool
02:02:29 <shachaf> The way people always pun between types and constructors doesn't help much when beginners always confuse types and constructors.
02:02:29 <arkeet> not type.
02:02:41 <arkeet> indeed
02:03:06 <shanks_> but then where do i put the x in "a = (C a _)"?
02:03:08 <shachaf> But that's not the worst.
02:03:15 <shachaf> arkeet: Sometimes I confuse types when they have the same number of inhabitants.
02:03:15 <shanks_> if i'm referring to x :: X
02:03:19 <arkeet> shanks_: if you already have x, then use case.
02:03:20 <shachaf> arkeet: It is a cardinal sin.
02:03:25 <shanks_> okay
02:03:47 <arkeet> but please don't write f x = case x of ...
02:04:12 <shachaf> Sometimes that's reasonable to write.
02:04:15 <arkeet> well fine.
02:04:22 <arkeet> when is it reasonable to write?
02:04:37 <haasn`windows> what's this about?
02:04:44 <typoclass> arkeet: name of the function is very long
02:05:07 <arkeet> I might dislike your function name then.
02:05:37 <arkeet> anyway, if you only have one constructor then you don't save anything.
02:05:39 <Ghoul_> yeah bois
02:05:40 <Ghoul_> http://puu.sh/2AuwA/fb72e24456
02:06:14 <arkeet> that's nothing.
02:06:18 <arkeet> I can replicate stuff infinitely many times.
02:06:54 <Ghoul_> careful! Voyager doesn't use lazy power couplings
02:07:09 <Ghoul_> They're imperative and they're quite delicate
02:07:11 <shachaf> arkeet: For example when f's name is long and there are many options.
02:07:21 <arkeet> ok, but say we only had one constructor.
02:07:42 <veggies12> hello, I'm having trouble with Maybe and lenses: http://hpaste.org/85822
02:09:33 <haasn`windows> "makeLenses ''Stone" <- doesn't seem awfully useful
02:09:42 <ion> veggies: How about (?~)?
02:10:09 <arkeet> yes, use ?~
02:10:12 <arkeet> instead of .~
02:10:19 <arkeet> > Nothing ?~ 3
02:10:22 <lambdabot>   Couldn't match expected type `Control.Lens.Setter.ASetter
02:10:22 <lambdabot>                  ...
02:10:29 <haasn`windows> :t (?~)
02:10:30 <arkeet> > Nothing & _Just ?~ 3
02:10:30 <lambdabot> ASetter s t a (Maybe b) -> b -> s -> t
02:10:32 <lambdabot>   Nothing
02:10:36 <arkeet> uhhh
02:10:53 <arkeet> duh.
02:10:55 <shachaf> arkeet: I don't think that solves the issue.
02:10:58 <arkeet> no.
02:11:16 <haasn`windows> it's impossible unless it's not a valid traversal
02:11:16 <arkeet> indeed.
02:11:22 <haasn`windows> becuase you can't change the number of targets
02:11:33 <haasn`windows> modifying stoneAt2, that is
02:11:37 <shachaf> haasn`windows: You really like ` in your nick, huh?
02:11:44 <arkeet> > Nothing & id ?~ 3
02:11:46 <lambdabot>   Just 3
02:11:59 <ion> haasn`windows: You really like windows in your nick, huh?
02:12:04 <arkeet> hmm
02:12:07 <haasn`windows> shachaf: I don't like _ or | and you gotta warn people that you're using windows somehow, huh
02:12:10 <veggies12> it's not required that it stay a Traversal
02:12:12 <haasn`windows> err
02:12:15 <haasn`windows> scratch that 'huh'
02:12:21 <haasn`windows> don't know why I typed that
02:12:36 <ion> huh
02:13:17 <haasn`windows> veggies12: I think a lens into a Maybe is idiomatic here
02:13:17 <arkeet> :t at
02:13:19 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
02:13:41 <shachaf> I think that I don't know a good solution to this issue.
02:14:04 <veggies12> haasn`windows: the problem with that is the getting, which produces a Maybe (Maybe Stone) result, which is just noise to the caller
02:14:16 <haasn`windows> there might be some nicer way of obtaining the target of a Maybe a traversal, if any, other than the usual ^? and composing with _Just
02:14:30 <shanks_> the case thingy from earlier worked perfectly! thanks again guys. This channel is awesome.
02:14:54 <Ghoul_> without understand it too much, tuples seem really out of place
02:15:27 <veggies12> haasn`windows: that's not to say it doesn't work (that's how the real code is right now), but it's ugly
02:15:28 <Ghoul_> every else is constructed with higher order functions or sugar, but tuples seem to be really labour intensive, to, for example increase or decrease their size
02:15:39 <Ghoul_> *understanding
02:15:43 <Ghoul_> *everything
02:16:26 <ion> Why do you want to increase or decrease the size of a tuple?
02:16:47 <shachaf> You have no business doing that to a tuple.
02:18:13 <ion> If you think you need that operation, you are very probably using the wrong data structure.
02:18:15 <neutrino> Ghoul_: do you mean like when doing 2d geometry and then you want to start doing 3d geometry?
02:18:28 <neutrino> and you need to make your types use triples and not pairs?
02:20:48 <typoclass> Ghoul_: tuples don't really fill the same role as lists. you could think of tuples as "records but with the fields not having names". it'd be weird to have "Person { name :: String, age :: Int }" and increase or decrease the length :-)
02:21:28 <haasn`windows> tuples are really out of place, we should be using length-indexed lists!
02:21:58 <typoclass> haasn`windows: hm ... i wouldn't go that far
02:22:18 <haasn`windows> I wonder how far it would work to have tuple syntax be syntactic sugar for length-indexeed lists
02:22:41 <arkeet> not just length-indexed.
02:22:42 <haasn`windows> at any rate, it probably won't work as well as in languages with dependent types
02:22:44 <arkeet> list-of-types-indexed.
02:22:51 <haasn`windows> arkeet: or that, yes
02:23:00 <arkeet> and you can do that.
02:23:07 <haasn`windows> sure, 7.6
02:23:28 <typoclass> haasn`windows: well lists traditionally have all elements of the same type. tuples differ
02:23:49 <typoclass> (if this length-indexed list is anything like normal lists)
02:24:04 <haasn`windows> typoclass: oh, right; we *need* list-of-types-indexed lists to simulate tuples
02:25:09 <haasn`windows> but we lose other nice things, like a Monad instance
02:25:24 <haasn`windows> so it's not backwards compatible with normal homogeneous lists
02:26:05 <arkeet> it's not like you have a Monad instance for fixed-size tuples anyway.
02:26:10 <arkeet> even homogeneous
02:26:15 <arkeet> you do get Applicative though, by zipping.
02:26:22 <arkeet> sort of.
02:26:30 <arkeet> for homogeneous ones.
02:27:41 <haasn`windows> arkeet: or ones with the same types, at least
02:27:53 <arkeet> that's what homogeneous means.
02:28:00 <haasn`windows> oh no, I meant
02:28:23 <haasn`windows> HList [Int, Char, String] -> HList [Int, Char, String] -> HList [(Int, Int), (Char, Char), (String, String)]
02:29:58 <romm> why does ioError return IO a and not IO ()?
02:31:06 <arkeet> romm: because it never returns.
02:31:18 <arkeet> "returns"
02:31:34 <romm> arkeet, i understand, but then why 'IO a' and not 'IO ()'?
02:31:35 <ion> romm: Otherwise this wouldn’t typecheck, for instance: if something then return "foo" else ioError bar
02:31:50 <arkeet> that's a better reason.
02:31:50 <romm> ah, right. thanks
02:32:12 <ion> @type error
02:32:14 <lambdabot> [Char] -> a
02:33:01 <nh2> snoyberg: I have a question about your style of documentation. You do most explanations on how to do things in yesodweb blog posts. I'm reading the one on ResourceT now from 03/2013. That will probably be outdated in 6 months. Is there a generic way to find the most recent "tutorials" to your packages?
02:33:06 <arkeet> if something returns some type a, for any a, then it's basically a guarantee that it will never produce any value. since you could take a to be Void.
02:35:28 <Botje> .oO(automatic verification of literate haskell blog posts. won't that be the dream)
02:37:35 <veggies12> http://hpaste.org/85827 -- I am not sure if this is a net gain or loss of ugliness :)
02:42:02 <no-n[9]> what does '' in front of a word mean like that?
02:44:15 <veggies12> no-n[9]: it's type name quoting in Template Haskell
02:45:34 <no-n[9]> okay
02:46:30 <arkeet> veggies12: does that work?
02:46:57 <veggies12> arkeet: it does. Feels more than a little hackish though
02:51:04 <supki> instance At (Maybe a) where
02:51:07 <arkeet> you still get a Maybe (Maybe Stone)
02:51:52 <veggies12> oh, hmm
02:51:55 <veggies12> I thought I checked that!
02:51:56 <arkeet> supki: that would be good.
02:58:12 <hpaste> Nereid annotated “hackish solution” with “hackish solution (annotation)” at http://hpaste.org/85827#a85828
02:58:28 <shachaf> I miss Nereid.
02:58:34 <arkeet> oops.
02:58:47 <supki> I think there is Index instance already
02:58:52 <arkeet> there is?
02:59:19 <arkeet> ah there is a FunctorWithIndex instance.
02:59:40 <arkeet> and yeah, so there is.
02:59:48 <shachaf> IndexedFunctorWithIndex
02:59:53 <arkeet> but no IxValue instance
03:00:49 <arkeet> patch time?
03:04:29 <arkeet> it really does make sense for Maybe to have an At instance, doesn't it.
03:04:39 <shachaf> At what?
03:04:48 <arkeet> instance At (Maybe a)
03:05:00 <shachaf> What's the index?
03:05:08 <arkeet> ()
03:05:18 <shachaf> Eh.
03:05:22 <arkeet> there already is a type instance Index (Maybe a) = ()
03:05:30 <arkeet> but no IxValue
03:05:31 <arkeet> and no At
03:14:26 <supki> what about Ixed?
03:15:08 <supki> hmm
03:18:09 <arkeet> yeah I'm writing Ixed too
03:29:41 <arkeet> veggies12: ok, an At instance for Maybe is now in lens HEAD
03:29:43 <arkeet> ;)
03:56:25 <Ghoul_> Well, someone did put a controversial suggestion on the trac a while ago
03:56:42 <Ghoul_> which effectively made tuples syntax sugar for something else, and hence, made them "high order"
03:56:47 <Ghoul_> I'll try and find it
03:57:26 <Ghoul_> http://hackage.haskell.org/trac/ghc/ticket/1245
04:03:16 <supki> that looks more "nobody cares" than "controversial" really
04:10:37 * hackagebot text-locale-encoding 0.1 - Encode and decode Text to/from ByteString using TextEncoding  http://hackage.haskell.org/package/text-locale-encoding-0.1 (MikhailKuddah)
04:33:33 <ipetrovilya> `cabal update --verbose=3` freezes on my Windows 7 laptom, logs are here: [ http://pastebin.com/X6vYTkzX ]. What reason can it be for?
04:33:38 <mauke> The paste X6vYTkzX has been copied to http://hpaste.org/85829
04:37:24 <haskall> can I ask something ?
04:37:32 <haskall> I want to find a book that would teach me some logic for formal methods
04:37:34 <haskall> some formal methods
04:37:44 <haskall> and of course, how to do formal methods and verification using haskell
04:38:00 <haskall> I've been looking on amazon but there's a lot of stuff there and I don't have  a very good eye for picking
04:38:09 <haskall> if someone has some recommendations please let me know
04:38:44 <haskall> tl;dr => I basically want the shortest path to formal methods to haskell. I am willing to put some reading into this, but don't know what books I should read
04:38:49 <luite> haskall: perhaps you can read this http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf
04:52:15 <haskall> luite: did you read it ?
04:52:58 <luite> haskall: no
04:53:54 <haskall> well..
04:53:58 <haskall> that's encouraging
04:54:52 <aleator> haskall: reasoned programming by broda is a nice elementary introduction
04:56:45 <haskall> aleator: this one ? http://www.doc.ic.ac.uk/pandora/firstyearbook.pdf
04:56:53 <aleator> haskall: Yeah.
04:57:09 <haskall> looks cool, thank you
04:57:30 <aleator> Thats a bit old, but I find it to be a nice introduction to thinking formally about programming
05:06:49 <arkeet> haskall: I am enjoying reading this.
05:06:59 <arkeet> at least the introduction.
05:07:14 <haskall> arkeet: what in particular ? the last pdf posted above ?
05:07:17 <arkeet> yes
05:07:34 <arkeet> oh, I guess I really wanted to say that to aleator.
05:07:41 <haskall> arkeet: wanna form a reading group with me ?
05:07:47 <haskall> like just us two
05:07:47 <arkeet> not in particular.
05:07:50 <haskall> ok
05:09:52 <haskall> are there any reading groups for haskell centralized somewhere ?
05:20:39 * hackagebot data-interval 0.2.0 - Interval Arithmetic  http://hackage.haskell.org/package/data-interval-0.2.0 (MasahiroSakai)
05:21:13 <typoclass> haskall: how do you mean, centralized reading groups?
05:22:36 <haskall> typoclass: well my understanding is that a reading group is usually some people who are reading a particular book and want to share information about their progress or questions or whatever. so it is usually accompanied by a mailing list
05:22:59 <haskall> typoclass: and I was wondering if there's like a list of reading group focused on haskell
05:23:02 <haskall> that's what I meant
05:25:52 <typoclass> haskall: oh i see :-) i'm not aware of that kind of thing. though i guess this channel could be relevant, or the haskell-cafe mailing list
05:26:24 <haskall> typoclass: ok, thanks
05:26:29 <typoclass> haskall: ... in the sense of, if you have any questions, try asking in here, once or twice :-) worst thing that can happen is that nothing happens
05:27:16 <merijn> Yeah, the two main community hubs are here and the -cafe mailing list, although the SO community is pretty big too.
05:28:29 <notdan> http://stackoverflow.com/questions/16001056/parsing-xml-data-which-makes-heavy-use-of-identifiers if any of you arrows/hxt masters can take a look at http://stackoverflow.com/questions/16001056/parsing-xml-data-which-makes-heavy-use-of-identifiers I would be most grateful
05:33:13 <Palmik> Hi guys. I have very interesting (from my POV) performance 'issue'. I have these functions: http://hpaste.org/85830 (the code comes from here: https://github.com/Palmik/data-store/blob/v0.2/src/Data/Store/Internal/Function.hs). The interesting thing is that indexInsertID'' (inserts and ignores collisions) is slower than indexInsertID' (inserts and deals with collisions) even though it is implemented in terms of indexInsertID'' (measured on data set
05:34:32 <Palmik> I found out that the speed up is caused by calling the function 'findCollisions' ... (you can see that I have commented out different versions of the local value 'collisions' in the function indexInsertID' -- this first version causes it to be clow and the other two versions cause it to be fast).
05:34:42 <typoclass> Palmik: hello. your message was cut off at "measured on data set"
05:35:02 <Palmik> typoclass: Thanks. It continues like this: "(measured on data sets without collisions)"
05:35:59 <merijn> Did you profile it?
05:36:32 <merijn> </unhelpful question> :>
05:36:47 <Palmik> merijn: Not yet.
05:37:51 <Palmik> The function findCollisions traverses the index and should be quite costly. Yet its evaluation makes the function faster in the end (at least when there are no collisions). I tried to simply force the index to qhnf, but that did not help.
05:38:27 <Palmik> *whnf
05:39:35 <Palmik> I believe I have to add some strictness somewhere...
05:40:42 <typoclass> Palmik: when you say faster and slower, how did you determine that? "ghc -O2 && time theBinary" ...?
05:40:53 <typoclass> (not that i know anything about performance)
05:44:33 <paulusghc> anyone up for a memoization question?
05:44:34 <Palmik> typoclass: I used this benchmark. https://github.com/Palmik/data-store/blob/v0.2/benchmarks/src/01.hs#L52
05:45:14 <Eduard_Munteanu> paulusghc: just go ahead and ask, we'll see :)
05:45:14 <a11235> Hi, if I copy-paste any unicode char in the command line of ghci it appears as a sequence of "?". I'm on osx 10.8.3 with ghci v7.4.2 installed with homebrew (haskell-platform package). Any idea how to fix this?
05:45:35 <Palmik> typoclass: (the benchmarks on line 52 and 53)
05:45:41 <merijn> a11235: Probably your terminal settings are wrong
05:45:53 <merijn> a11235: What's the value of TERM?
05:45:54 <Palmik> typoclass: So I guess the answer is "using criterion".
05:46:11 <typoclass> Palmik: thanks
05:46:12 <a11235> merijn: xterm-256color
05:46:26 <typoclass> Palmik: not sure :) profiling would be another option
05:46:45 <armlesshobo> a11235: you need to have a terminal with UTF8 support
05:47:03 <merijn> a11235: Are you using Terminal.app? Also, check what the encoding is if you go to terminal preferences, advanced tab and check the encoding at the bottom
05:47:05 <paulusghc> OK, I have read and more or less understand the meoization technique given in the Hakell wiki
05:47:16 <typoclass> a11235: does pasting the same unicode char work if you do it into the shell? (without ghci being started)
05:47:24 <paulusghc> for a simple function like fibonacchi
05:47:37 <a11235> merijn: I'm using iTerm2
05:48:06 <a11235> typoclass: it works in the shell
05:48:07 <merijn> Ah, then I don't know where to look
05:48:15 <Palmik> typoclass: I am also quite lost as far as profiling in Haskell goes. Since evaluating something seems to improve the running time rather than hinder it, it seems to be the case that there is too much lazyness somewhere and I'm not sure how I can see where using a profiler.
05:48:55 <merijn> a11235: Check your LANG, LC_ALL and LC_CTYPE environment variables too
05:49:25 <merijn> Palmik: RWH has a chapter on profiling, I haven't used it myself, but might be worth checking out
05:51:16 <Palmik> merijn: I will take a look thanks.
05:54:05 <a11235> merijn: that was it, it works now thanks
05:55:56 <merijn> \o/
05:59:51 <paulusghc> what I would like is an automatic memoization applied to a function 9especiall a recursive one)
06:00:16 <paulusghc> wo the need to do the map business like the fibonacci example.
06:00:48 <paulusghc> I have checked out the docs for Data.Function.Memoize, but can find no examples or tutorial on using it
06:01:25 <paulusghc> I tried just defining a new function memzfib as memoize fibonacci but that did not speed things up at all
06:01:28 <merijn> paulusghc: You mean "without using Map" or "without having to manually bother with introducing Map"?
06:01:55 <paulusghc> yup.. do you know the fib example I am referring to?
06:02:54 <merijn> Not of the top of my head
06:03:33 <paulusghc> actually rereading the wiki section:http://www.haskell.org/haskellwiki/Memoization
06:03:35 <merijn> paulusghc: How comfortable are you with haskell in general? There's a very cool memoisation example in Fun with Type Functions, but it might be to complicated for newbies
06:03:42 <paulusghc> I think I see a way to do it
06:04:11 <paulusghc> Still teaching myself, using project Euler as a vechile
06:05:19 <notdan> http://hpaste.org/85832 Why doesn't my parser work? It produces the empty list
06:05:28 <paulusghc> ok I will try using the example on the wiki, where they define the meoizing fix point operator memoFix, using memoize from the library
06:05:52 <merijn> I don't really like Project Euleras a teaching vehicle, many of the exercises are more about number theory than programming. It also seems to promote code golfing and focus on things which don't really show of haskell's strengths
06:05:54 <notdan> I want it to produce the list [(452,1),(453,1)]
06:06:09 <typoclass> paulusghc: i think project euler is better for doing math exercises, not really haskell exercises
06:07:52 <merijn> There was a subreddit for interesting programming exercises, but I can't find it right now
06:08:21 <paulusghc> ok you are probably right, often I know how to do the thing in c or python, and I struggle to find the pure functional way to do it
06:08:27 <merijn> Oh: http://www.reddit.com/r/dailyprogrammer
06:08:31 <Kinnison> merijn: http://www.reddit.com/r/programingchallenges/ ?
06:08:34 <typoclass> notdan: what output does it produce?
06:08:36 <merijn> Kinnison: Probably
06:08:41 <paulusghc> but it has taught me some things
06:08:51 <notdan> typoclass: an empty list
06:08:55 <notdan> typoclass: it only traces "1"
06:09:17 <notdan> typoclass: if I remove the "call" to the xval arrow it runs instP arrow
06:09:26 <merijn> paulusghc: Oh sure, I'm just saying that more programming focussed exercises might teach you more haskell with the same effort. i.e. you can focus more on haskell and less on obscure number theory ;)
06:09:54 <merijn> Try those two subreddits, there seem to be some nice challenges there
06:12:02 <paulusghc> thanks guys, yup but anyway primes, and series are nice also each problem is quite succint, but thanks for the reddit challeng, will try some of those as well
06:12:48 <paulusghc> when you say fun with type you mean the 2010 paper by spj  et al
06:13:34 <merijn> Yeah, Oleg, SPJ and Shan
06:13:55 <merijn> It's a very neat paper, but don't worry if it's over your head for now.
06:14:24 <Eduard_Munteanu> Those names are as short as function names in Haskell.
06:14:31 <notdan> typoclass: If I change the 'proc' code in testP to 'multi (instP &&& xval)' it does run both arrows (I can see the traces), but it still returns an empty list
06:14:52 <Eduard_Munteanu> K&R on the other hand... :)
06:16:11 <_mr> Those papers always mention "type systems inevitably exclude some good programs". Whatexactly is meant by that?
06:16:29 <no-n[9]> in the express "map f xs" which is the functor - f or xs?
06:16:34 <dmwit> _mr: One common thing to exclude is something like "5 + if True then 3 else False"
06:16:38 <no-n[9]> s/express/expression
06:16:39 <Botje> no-n[9]: xs is the functor.
06:16:43 <merijn> _mr: That there are correct programs which cannot be written
06:16:45 <no-n[9]> ty
06:16:51 <no-n[9]> would the new list be a functor as well?
06:16:53 <Botje> :t fmap -- no-n[9]
06:16:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:16:57 <Saizan> no-n[9]: more precisely the list type is the functor
06:17:02 <Botje> no-n[9]: 'functorness' is a property of types.
06:17:18 <Botje> map is actually fmap, and as you see it takes a functor f a and returns a functor f b
06:17:22 <no-n[9]> ye
06:17:27 <dmwit> _mr: Even though that never goes wrong, it's too annoying to catch all such runtime "doesn't-go-wrong"nesses at compile time, so we just exclude them all instead and argue that you shouldn't want to write that anyway.
06:17:33 <_mr> dmwit: So programs that would typecheck if you checked at runtime?
06:17:37 <dmwit> _mr: yes
06:17:41 <merijn> _mr: For example, yes
06:17:44 <no-n[9]> oh, I see
06:17:49 <no-n[9]> cool
06:17:51 <_mr> Great, thanks
06:18:20 <Eduard_Munteanu> The type constructor is the part of the functor which maps the objects. 'fmap' maps the arrows.
06:18:24 <_mr> merijn: do you know other examples?
06:18:54 <merijn> _mr: The way to think of it is: Clearly you could write arbitrary code without the type system, right? The type system disallows you from writing a significant (majority?) of that code, hoping to eliminate "wrong" things, but it accidentally also disallows some correct things
06:19:13 <merijn> _mr: I don't know any concrete examples, but one thing to consider is, for example "fix"
06:19:16 <merijn> :t fix
06:19:18 <lambdabot> (a -> a) -> a
06:19:36 <merijn> _mr: Look at that type, clearly it makes no sense, right?
06:19:55 <_mr> yes
06:20:11 <merijn> I can "a -> a" ever get you an 'a', without having an 'a' to begin with? Yet there's still programs that use fix which work perfectly fine
06:20:32 <merijn> > fix ("Hey!"++)
06:20:34 <lambdabot>   "Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!Hey!He...
06:20:42 <merijn> > take 10 $ fix ("Hey!"++)
06:20:44 <lambdabot>   "Hey!Hey!He"
06:20:45 * dmwit finds this line of argument confusing
06:21:14 <merijn> dmwit: Yeah, I'm not convinced it's a good direction either, feel free to provide a better one :p
06:21:15 <dmwit> This seems very orthogonal to what good programs a type system rules out. You seem to be suggesting that this is a bad program that a type system allows.
06:21:24 <_mr> merijn: are you saying fix should not work, but does? ;-)
06:22:07 <dmwit> (And I don't agree that this is a bad program.)
06:22:19 <fizbin> > take 20 $ fix (\x -> 1:1:(zipWith (+) x $ tail x))
06:22:21 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
06:22:46 <merijn> _mr: No, I'm saying that fix clearly works, even though the type says it shouldn't. i.e. it's a good program that should normally be disallowed by the type system
06:23:07 <dmwit> what
06:23:23 <merijn> dmwit: I dunno, come up with a better explanation if you can :p
06:23:25 <quchen> merijn: I don't get it either. What's bad about fix? Why shouldn't it work (superficially)?
06:23:26 <typoclass> is there an example for a 'good' program that haskell disallows?
06:23:39 <dmwit> typoclass: I gave a very simple one above.
06:23:48 <dmwit> There are of course more complicated ones. =)
06:23:54 <typoclass> dmwit: right, i've seen it, but that's not 'good', is it
06:23:55 <merijn> quchen: How could you possibly get from "a -> a" to "a" without ever having an "a"?
06:24:00 <merijn> quchen: Where is the a coming from?
06:24:01 <dmwit> typoclass: What makes it bad?
06:24:19 <dmwit> typoclass: Would you find it more convincing if I wrote something like this?
06:24:27 <quchen> typoclass: The y combinator can't be explicitly defined for example. You have to work around that by defining it with its unique property. Maybe?
06:24:34 <dmwit> 5 + if checkSomeInvariant then 3 else False
06:24:55 <dmwit> where checkSomeInvariant provably always evaluates to True at runtime?
06:25:04 <haasn> typoclass: halts :: a -> Bool
06:25:20 <quchen> merijn: I think that makes a lot of sense. A function has some (least defined) fixed point, and fix finds it.
06:25:30 <_mr> haasn: now that's a different sort of problem, isn't it?
06:25:58 <fizbin> merijn: You seem to be mixing "what the type system should allow" with "what strict evaluation semantics should allow".
06:26:04 <merijn> quchen: What are you ging as input to the function?
06:26:14 <Eduard_Munteanu> Presumably you want   halts halts = True
06:26:50 <merijn> fizbin: No, that it doesn't work for strict semantics is orthogonal
06:26:52 <quchen> merijn: Nothing.
06:27:02 <latermuse> Haskell: Solving the halting problem.
06:27:04 <veggies12> there was a very good example of a program that would run fine in a dynamically typed language but not in a statically typed language that used variable arity functions, except I can't remember any details about it
06:27:09 <merijn> quchen: How can you give Nothing to a function and get something out without a type error?
06:27:25 <_mr> given void: Void -> Void, what is fix void?
06:27:29 <quchen> merijn: Not Nothing, nothing. :-)
06:27:40 <merijn> fizbin: fix is a logical inconsistency in the HM type system
06:27:43 <typoclass> dmwit: hm, i dunno. i read "good" in the sense of "you might want to write that". but "5 + if ... then 3 else False" doesn't seem like that. why do people want to add 5 to False? (and suppose you came up with some Num Bool instance and added fromIntegral ...)
06:27:51 <merijn> quchen: And that's not a type error in your opinion?
06:27:51 <dmwit> _mr: fix id is an infinite loop, no matter what type you specialize it to.
06:28:17 <_mr> Ah
06:28:24 <typoclass> haasn: not sure, i thought solving the halting problem was disallowed by the universe, not by the type checker
06:28:37 <merijn> > fix error
06:28:38 <quchen> merijn: I have no opinion about this, I'm not very educated when it comes to type systems. But yeah, thinking of Curry-Howarding that, it basically means any A follows from a tautology.
06:28:39 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
06:28:46 <Eduard_Munteanu> _mr: void = fix void   ?
06:28:48 <dmwit> typoclass: People do this in Python all the time, only they leave the "else ()" off of their if-blocks. =)
06:28:50 <quchen> merijn: Is that where you're coming from?
06:29:05 <typoclass> dmwit: that's true :-) urgh
06:29:06 <fizbin> > let y x = x y x in y (\x -> 1:1:(zipWith (+) x $ tail x))
06:29:08 <lambdabot>   Occurs check: cannot construct the infinite type:
06:29:08 <lambdabot>    t2 = t1 -> t2 -> t0Occ...
06:29:08 <dmwit> typoclass: "Well, I happen to know that this field is a pointer to the rest of the list, so I'll do such-and-such a thing with it..."
06:29:11 <merijn> quchen: The fact that you *can* write fix in haskell is what makes it Turing complete and thus also introduces the Halting problem
06:29:28 <DanielDiaz> merijn: "fix" error doesn't fix the error, it produces an infinite one! haha
06:29:35 <quchen> merijn: Now you're losing me :s
06:29:46 <merijn> quchen: If the type system wasn't inconsistent you couldn't write fix, wouldn't be turing complete and you wouldn't have the halting problem
06:30:01 <_mr> dmwit: ah, so (a -> a) -> a makes no sense in total functions, but is OK otherwise?
06:30:20 <dmwit> _mr: That wasn't quite precise. fix f is a loop when f is strict.
06:30:33 <merijn> _mr: (a -> a) -> a only makes sense if the "a -> a" can produce output before recursing
06:30:33 <Eduard_Munteanu> _mr: parametricity doesn't quite let you define that
06:30:33 <quchen> merijn: That sounds very odd. I like incompleteness more than inconsistency. :s
06:30:48 <merijn> quchen: Why?
06:31:05 <quchen> merijn: The odd part, or the like part?
06:31:07 <dmwit> _mr: "f is strict" is another way of saying "f _|_ = _|_", where here "_|_" is the name of an infinite loop, exception, or other runtime problem.
06:31:29 <merijn> _mr: Take my "fix ("Hey"++)" example, the ++ can return "hey" before needing the rest
06:31:49 <dmwit> _mr: (Totality is another thing altogether. "f is total" means "f n /= _|_ whenever n /= _|_".)
06:32:18 <merijn> _mr: 'fix ("Hey"++)' = "Hey" ++ fix ("Hey"++) = "Hey" ++ ("Hey" ++ fix ("Hey"++))', etc.
06:32:24 <monoidal> dmwit: is "fst" total?
06:32:29 <dmwit> _mr: ...actually I don't stand by that last definition.
06:32:29 <fizbin> merijn: This is why I said that you're confusing "type doesn't makes sense" with "doesn't make sense under strict evaluation semantics". When I call the function, I'm passing it something I haven't evaluated yet, but that's okay.
06:32:30 <merijn> monoidal: Yes
06:32:31 <typoclass> dmwit: but yeah, i think i get what you're saying now. sometimes the programmer knows more than the compiler, but can't communicate that concisely. "i'll use head here, because i know the list isn't empty, only ghc doesn't know"
06:32:33 <Eduard_Munteanu> monoidal: sure it is
06:32:50 <merijn> fizbin: No, the type doesn't make sense in a consistent type theory
06:32:51 <quchen> merijn: Incompleteness means there's more possible stuff. Inconsistency says there's this weird loophole in your system and you don't really know the consequences. In my head at least.
06:32:54 <dmwit> typoclass: Right. "head" isn't a great example, but that's the idea.
06:33:01 <merijn> Or the Curry-Howard view of type systems
06:33:08 <Eduard_Munteanu> monoidal: are you asking if it's strict, maybe?
06:33:20 <monoidal> Eduard_Munteanu: I was refering to dmwit's definition of totality
06:33:25 <_mr> merijn: hmm, ok
06:33:36 <dmwit> monoidal: Yes, I retract my definition. It was bad, and I feel bad.
06:33:44 <Eduard_Munteanu> dmwit: why?
06:34:03 <merijn> @src fix
06:34:03 <lambdabot> fix f = let x = f x in x
06:34:09 <dmwit> Total should mean something simultaneously stronger and weaker.
06:34:25 <dmwit> I don't know exactly what I want it to mean, but something like "if n is totally defined, then f n is totally defined".
06:34:32 <monoidal> Eduard_Munteanu: if "fst" is total, then total does not mean "f n /= _|_ whenever n /= _|_".
06:34:33 <Eduard_Munteanu> Ah, yeah.
06:35:15 <_mr> monoidal: because the scnd could be _|_ ?
06:35:27 <dmwit> _mr: because fst (_|_, ()) = _|_
06:35:35 <Eduard_Munteanu> monoidal: why not? Every non-_|_ value is a (_, _)
06:35:37 <dmwit> ...and (_|_, ()) /= _|_
06:35:44 <Eduard_Munteanu> Ah.
06:35:47 <_mr> dmwit: oh
06:36:04 <_mr> dmwit: Ok, had it backwards
06:36:13 <DanielDiaz> so what that total means exactly?
06:36:23 <dmwit> good question =)
06:36:32 <Eduard_Munteanu> DanielDiaz: fully-defined input => fully-defined output
06:36:50 <monoidal> or consider totality for streams [a] -> [a]
06:36:55 <Eduard_Munteanu> Well, excluding coinductive stuff.
06:37:15 <fizbin> @hoogle on
06:37:15 <DanielDiaz> and what fully-defined means? No bottoms at all?
06:37:15 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:37:15 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
06:37:15 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
06:37:45 <Eduard_Munteanu> Yeah.
06:38:03 <quchen> So fst isn't total? Hm. Odd, I always thought it would behave.
06:38:11 <Eduard_Munteanu> quchen: it is
06:38:14 <Philonous> What is a good definition of totallity then? f ist total iff f(x) is a lub for all lub x?
06:38:23 <DanielDiaz> Eduard_Munteanu: And finite, I guess
06:38:24 <Eduard_Munteanu> quchen: we were picking on that particular definition of totality
06:38:26 <monoidal> it might be easier to see if we use a Partiality monad. then any function a -> b is total, and nontotal functions are a -> Partial b (like a -> [b] are "nondeterministic" functions)
06:38:35 <quchen> Eduard_Munteanu: But for the non-bottom value (bot, ()), fst evaluates to bot, doesn't it?
06:38:48 <quchen> Eduard_Munteanu: Oh, you had a different definition? Didn't realize that
06:38:50 <Eduard_Munteanu> quchen: yes, but that's not a fully-defined input
06:38:54 <dmwit> quchen: The definition Eduard_Munteanu gave makes no guarantees about inputs that have bottom in them.
06:38:58 <_mr> quchen: yes, but (bot,()) is not fully defined
06:39:14 <Eduard_Munteanu> DanielDiaz: let's assume finiteness for now
06:39:18 <veggies12> Eduard_Munteanu: is (Identity _|_, ()) fully defined?
06:39:23 <dmwit> no
06:39:32 <quchen> Aaah, now I see where the discussion of "fully defined" comes from.
06:40:07 <dmwit> Q: Is (some expression involving _|_ with no beta redexes) fully defined? A: no
06:40:10 <veggies12> oh, right, I had the implication going the wrong way
06:40:12 <Eduard_Munteanu> Infinite stuff is coinductive, and you kinda have to treat that separately if you want to be really pedantic/accurate.
06:40:12 <_mr> (I've always believed I could use Curry-Howard on Haskell-types.. :-)
06:40:21 <quchen> I guess you could read fully defined as "deepseq terminates" then?
06:40:26 <DanielDiaz> Eduard_Munteanu: And does <const 1 _|_> contain any bottoms?
06:40:30 <dmwit> quchen: right
06:40:45 * hackagebot conjugateGradient 1.2 - Sparse matrix linear-equation solver  http://hackage.haskell.org/package/conjugateGradient-1.2 (LeventErkok)
06:40:48 <dmwit> DanielDiaz: It contains a beta redex, so we don't know yet. =)
06:40:50 <DanielDiaz> i.e. is it fully-defined?
06:41:01 <monoidal> but deepseq cannot always be applied (i.e. consider functions...)
06:41:04 <dmwit> But yes, it's fully-defined provided your fromInteger is total.
06:41:08 <Eduard_Munteanu> DanielDiaz: yep, but you can't distinguish   const 1 _|_   from   const 1 something_defined
06:41:34 <Eduard_Munteanu> DanielDiaz: so it's enough to quantify over all defined stuff
06:41:40 <quchen> dmwit: When you said "some expression involving bot and no beta redexes", that basically meant to take care of an expression like "(fst (bot, 1), 1)", right? There's a bottom in there, but also a beta redex
06:41:49 <quchen> Eh, snd ^
06:41:53 <dmwit> right
06:41:57 <quchen> I see.
06:44:13 <DanielDiaz> so, finally, a fully-defined expression is a finite expression that contains no bottoms in its normal form?
06:44:38 <saml> no
06:44:45 <saml> depends on bottom
06:44:50 <saml> let me google
06:45:17 <saml> i think fully defined expression is not partial expression
06:47:10 <monoidal> random thought: we have equivalence between "Subset a -> b" and "a -> Partial b". is this some sensible adjunction?
06:49:13 <Eduard_Munteanu> monoidal: what's Subset?
06:49:15 <_mr> monoidal: are these actual Haskell types?
06:49:27 <Eduard_Munteanu> Partial is the partiality monad.
06:49:35 <Eduard_Munteanu> (I suppose)
06:49:44 <merijn> _mr: If they're not, I don't see why they couldn't be
06:49:53 <monoidal> assuming Subset x is some subset of a, could be implemented with newtype Subset a = Subset a
06:49:54 <_mr> merijn :-)
06:50:03 <Eduard_Munteanu> :/
06:50:39 <monoidal> what I'm saying is that a total function taking a subset of values is equivalent to a function taking all values and returning sometimes _|_
06:51:09 <Eduard_Munteanu> Ah, an actual subtype.
06:51:15 <monoidal> yes
06:52:51 <Eduard_Munteanu> Hm, could be.
06:53:24 <Eduard_Munteanu> But I suspect it's more than an adjunction, making it rather trivial. (An equivalence perhaps.)
06:54:15 <monoidal> Eduard_Munteanu: equivalence is not a specific case of adjointness...
06:54:57 <Eduard_Munteanu> Every equivalence gives you two adjoint functors, no? And adjunctions are sort of a half of an equivalence.
06:55:19 <monoidal> Eduard_Munteanu: let's say F : C -> C is the identity functor/equivalence, what adjunction do you get?
06:55:29 <monoidal> ahh nvmd
06:56:44 <monoidal> it might be the adjunction that gives rise to the Partiality monad
06:57:00 <Eduard_Munteanu> Hm, which would that be?
06:58:06 <Dodek> is there an easy way to pretty print a haskell struct for debugging purposes?
06:58:30 <Eduard_Munteanu> Dodek: derive Show and show it
06:58:40 <Dodek> this will not pretty print it.
06:58:49 <Eduard_Munteanu> Not pretty or not print? :)
06:58:53 <Dodek> not pretty
06:58:58 <Eduard_Munteanu> Ah, fair.
06:58:58 <Dodek> everything will be in a single line
06:59:04 <Dodek> resulting in an unreadable mess
07:00:31 <monoidal> Eduard_Munteanu: I'm now unconvinced. it's more an equivalence between a -> Partial b (~ Maybe b) and dependent pairs (a1, a1 -> b) where a1 is a subset of a
07:02:01 <Dodek> ha
07:02:03 <Dodek> found it
07:02:05 <Eduard_Munteanu> Hm, I'm more familiar with Agda's idea of the partiality monad: http://www.cse.chalmers.se/~nad/repos/lib/src/Category/Monad/Partiality.agda
07:02:07 <Dodek> Text.Show.Pretty
07:05:46 * hackagebot RxHaskell 0.1 - Reactive Extensions for Haskell  http://hackage.haskell.org/package/RxHaskell-0.1 (JustinSpahrSummers)
07:05:58 <saml> > let a :: Int; a = 23423423489472937283749237424  in a  -- why no compiler error?
07:05:59 <lambdabot>   -5225451896096075088
07:06:05 <merijn> If I want to dispatch on type without introducing a bunch of typeclasses I should just use Data.Typeable, right?
07:06:15 <Eduard_Munteanu> saml: -Wall?
07:06:28 <saml> is Int not 32bit? architecture dependent?
07:06:30 <merijn> saml: Because numeric constants are translated into "fromIntegral <numeric constant>"?
07:06:42 <merijn> > fromIntegral 23423423489472937283749237424 :: Int
07:06:44 <lambdabot>   -5225451896096075088
07:07:01 <Eduard_Munteanu> saml: it's 64bit on 64bit, IIRC
07:07:05 <saml> maybe dependent type language implementations will give compielr error
07:07:08 <Eduard_Munteanu> It's not equivalent to the C int.
07:07:27 <saml> scala gives compiler error
07:07:28 <merijn> saml: Int is architecture dependent >27 bit
07:07:39 <merijn> But numeric constants aren't ints
07:07:48 <merijn> I guess that they are in Scala?
07:07:58 <Eduard_Munteanu> saml: ints eventually wrap around anyway
07:08:17 <Eduard_Munteanu> You can only detect overflowing constants.
07:08:52 <monoidal> saml: in GHC.Int you can find Int32, Int64 etc.
07:09:00 <merijn> That won't help
07:09:07 <merijn> > fromIntegral 23423423489472937283749237424 :: Int32
07:09:09 <lambdabot>   -1504882000
07:09:26 <arkeet> it's actually fromInteger
07:09:34 <merijn> > fromInteger 23423423489472937283749237424 :: Int32
07:09:35 <lambdabot>   -1504882000
07:09:36 <merijn> Same diff
07:09:50 <monoidal> >  23423423489472937283749237424 :: Int32
07:09:52 <lambdabot>   -1504882000
07:10:26 <monoidal> there's a hackage library somewhere for bound-checked arithmetic if you are interested
07:11:00 <monoidal> http://hackage.haskell.org/package/safeint
07:11:25 <arkeet> If an overflow or arithmetic error occurs, a run-time exception is thrown.
07:11:27 <arkeet> sounds really safe!
07:11:29 <monoidal> defines Int only, though
07:11:52 <arkeet> safeAdd :: Int -> Int -> Maybe Int
07:12:45 <saml> is there analysis tool that detects overflow.. and given input and memory constraints it warns me about potential out of memory error?
07:13:15 <saml> while we're at it, it solves halting problem, too
07:13:20 <arkeet> I was about to say.
07:13:33 <bitonic> arkeet: better than silently succeeding
07:14:01 <arkeet> perhaps
07:14:17 <monoidal> there's ezyang's patch for ghc, http://hackage.haskell.org/trac/ghc/ticket/7763, don't know its status
07:15:01 <bitonic> arkeet: perhaps?  I’d say it’s *a lot* better
07:15:07 <arkeet> perhaps
07:15:12 <bitonic> ehe.
07:15:24 <quchen> There are a couple of manual "--source..." parameters for Haddock. Is there some way of automatically including all source files?
07:15:39 <quchen> (How does Hackage do this?)
07:16:22 <bitonic> quchen: last time I checked, there wasn’t, there was a bug open on this
07:16:44 <quchen> bitonic: Aww. Well, thanks anyway.
07:16:59 <bitonic> quchen: well ‘last time I checked’ was more than a year ago.  so I’d double check
07:17:04 <bitonic> they were aware of the problem
07:18:32 <parcs> > 2*3*5*7*11 + 1
07:18:34 <lambdabot>   2311
07:19:26 <parcs> > 2*3*5*7*11*13 + 1
07:19:28 <lambdabot>   30031
07:20:49 <_mr> parcs: looking for primes?
07:22:04 <parcs> yes
07:22:47 <Eduard_Munteanu> Good, I heard they were looking for you too. ;P
07:24:49 <monoidal> 2*3*5*7*11*13 + 1 is not prime, for what's worth
07:27:05 <fizbin> monoidal: No, but it's certainly relatively prime to [2, 3, 5, 7, 11, 13]
07:30:47 <Dodek> hey
07:32:14 <hpaste> Dodek pasted “applicative concat” at http://hpaste.org/85834
07:32:21 <Dodek> how can i rewrite it to applicative styl
07:32:22 <Dodek> e
07:32:23 <Dodek> ?
07:33:23 <Lethalman> Dodek, start by using (++) as prefix instead of infix
07:34:06 <Lethalman> Dodek, otherwise liftA2
07:34:12 <Dodek> yeah, but i get something like  (++) <$> "A: " <*> getLine
07:34:18 <Dodek> and i don't know how to continue
07:34:25 <Lethalman> Dodek, from that you get an IO
07:34:39 <Lethalman> Dodek, e.g. (++) ((++) a b) c
07:34:48 <Dodek> yeah, but that's nasty
07:35:18 <Dodek> i'd rather have it in non-applicative style :)
07:35:28 <Dodek> than do this kind of stuff
07:37:27 <Lethalman> :t liftA2 (++)
07:37:29 <lambdabot> (Applicative f, Monoid c) => f c -> f c -> f c
07:38:00 <Lethalman> @hoogle f c -> f c -> f c
07:38:00 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
07:38:01 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
07:38:01 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
07:38:26 <Lethalman> :t pure "foo" `mplus` getLine
07:38:27 <lambdabot> IO [Char]
07:38:36 <Taneb> :t liftA2 (\foo bar-> "I got this " ++ foo ++ " and this " bar) getLine getLine
07:38:37 <lambdabot> Taneb: You have 1 new message. '/msg lambdabot @messages' to read it.
07:38:38 <lambdabot>     The function `" and this "' is applied to one argument,
07:38:38 <lambdabot>     but its type `[Char]' has none
07:38:38 <lambdabot>     In the second argument of `(++)', namely `" and this " bar'
07:38:39 <Lethalman> :t pure "foo" `mplus` getLine `mplus` pure "bar" `mplus` getLine
07:38:40 <lambdabot> IO [Char]
07:38:44 <Lethalman> Dodek, ^^
07:38:49 <Dodek> Lethalman: thanks
07:39:18 <monoidal> Lethalman: mplus /= liftM2 (+)
07:39:20 <monoidal> (++)
07:40:54 <Lethalman> > pure "foo" `mplus` Just "getline" `mplus` "bar"
07:40:56 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe [GHC.Types.Char]'
07:40:56 <lambdabot>           ...
07:41:03 <Lethalman> > pure "foo" `mplus` Just "getline" `mplus` pure "bar"
07:41:05 <lambdabot>   Just "foo"
07:41:12 <Lethalman> indeed :P
07:41:15 <DanielDiaz> the best way of running a benchmark is having all the programs you have installed in your computer running at the same time
07:41:18 <Philonous> What does the MonadPlus instance of IO look like?
07:41:24 <monoidal> Philonous: it doesn't
07:41:43 <Philonous> monoidal:  lambdabot seems to think it does
07:41:55 <Lethalman> > let conc = liftM2 (++) in pure "foo" `conc` getLine `conc` pure "bar" `conc` getLine
07:41:57 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO [GHC.Types.Char]))
07:41:57 <lambdabot>    arising ...
07:42:11 <Lethalman> :t let conc = liftM2 (++) in pure "foo" `conc` getLine `conc` pure "bar" `conc` getLine
07:42:12 <lambdabot> IO [Char]
07:42:19 <Lethalman> Dodek, ^^ :P
07:42:25 <Lethalman> is that better monoidal ?
07:42:31 <monoidal> Lethalman: yes
07:42:42 <monoidal> Lethalman: though I prefer original
07:42:45 <parcs> :k (forall (a :: * -> *). a)
07:42:47 <lambdabot>     Illegal kind signature for `a'
07:42:48 <lambdabot>       Perhaps you intended to use -XKindSignatures
07:42:59 <Lethalman> monoidal, in his paste? indeed
07:43:09 <monoidal> Lethalman: you can do concat $ sequence [pure "foo", getLine ... ] though
07:43:18 <monoidal> umm something similar
07:43:24 <Lethalman> monoidal, right
07:43:28 <Sculptor> hi
07:43:35 <Lethalman> :t sequence [pure "foo", getLine]
07:43:36 <lambdabot> IO [[Char]]
07:43:39 <Lethalman> eheh
07:43:45 <monoidal> liftM concat . sequence
07:43:47 <Lethalman> :t mconcat
07:43:48 <lambdabot> Monoid a => [a] -> a
07:43:58 <hpaste> allenj12 pasted “parse error” at http://hpaste.org/85835
07:44:19 <Lethalman> > mconcat $ sequence [pure "foo", Just "bar"]
07:44:20 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
07:44:20 <lambdabot>              with actual ...
07:44:29 <allenj12> can someone tell me what im doing wrong there?
07:44:36 <monoidal> allenj12: you're missing "in" after "let
07:44:36 <Lethalman> > mconcat <$> sequence [pure "foo", Just "bar"]
07:44:37 <lambdabot>   Just "foobar"
07:44:46 <Lethalman> monoidal, ^^ that?
07:44:51 <supki> and else branches
07:44:53 <monoidal> Lethalman: yes
07:44:56 <allenj12> k thanks!
07:44:57 <Lethalman> > concat <$> sequence [pure "foo", Just "bar"]
07:44:59 <lambdabot>   Just "foobar"
07:45:01 <Lethalman> right
07:45:07 <monoidal> allenj12: and 1 elem X should be 1 `elem` X
07:45:14 * Lethalman does't use haskell daily but sometimes tries to refresh his mind :)
07:45:31 <monoidal> allenj12: problem is, Haskell does not work this way
07:45:38 <monoidal> allenj12: you don't have mutable variables
07:45:51 <allenj12> hmmm alright
07:46:39 <klrr> how can a turn a argument from the commandline into a filename handle?
07:47:24 <merijn> klrr: By opening the file?
07:47:27 <merijn> :t withFile
07:47:29 <lambdabot>     Not in scope: `withFile'
07:47:29 <lambdabot>     Perhaps you meant one of these:
07:47:29 <lambdabot>       `writeFile' (imported from Prelude),
07:47:32 <merijn> hmmm
07:47:39 <Philonous> klrr:  What do you mean by "filename handle" ?
07:47:40 <klrr> merijn: good idea will check at hoogle
07:47:47 <monoidal> allenj12: one way would be to define operator1 = []; operator2 = if 3 `elem` dummyOperators then operator1 ++ ["->"]; operator3 = ... etc
07:47:53 <klrr> Philonous: i donno, im meaning a Handle
07:48:00 <merijn> klrr: Take a look at System.IO
07:48:14 <monoidal> allenj12: that might be convoluted, but at least uses simple concepts. there are other things to do it
07:48:42 <monoidal> allenj12: um I meant "...then operator1 ++ ["->"] else operator1 ... "
07:48:52 <allenj12> k thanks! makes sense
07:49:10 <monoidal> allenj12: perhaps you wanted map f operators where f 3 = "->"; f 2 = "\/" etc
07:49:32 <monoidal> but this has a different behavior if dummyOperators has repetitions
07:49:33 <twoolie> can someone please point me to a link for the source of mkMigrate from persistent?
07:49:59 <hpaste> “Anonymous Coward” pasted “ordering in do notation” at http://hpaste.org/85836
07:50:09 <allenj12> hmm I will give it a shot
07:50:23 <twoolie> GHCI says: -- Defined in `Database.Persist.TH' but it's not in the source file there, nor imported
07:50:35 <Philonous> twoolie:  http://hackage.haskell.org/packages/archive/persistent-template/latest/doc/html/src/Database-Persist-TH.html#mkMigrate
07:50:58 <twoolie> Philonous: Thankyou good  sir
07:51:52 <Philonous> twoolie:  The documentation on hackage has links to the sources.
07:54:46 <jamil> hi all
07:54:57 <Eduard_Munteanu> jamil: hi
07:55:10 <jamil> I am currently trying to understand parser combinators
07:55:29 <jamil> can't understand why changing ordering in http://hpaste.org/85836#line6
07:55:45 <jamil> causes the parser to accepts reverse strings
07:56:01 <jamil> line 5 and 6
07:56:17 <hpaste> “Anonymous Coward” pasted “parser combinator” at http://hpaste.org/85837
07:57:16 <Botje> jamil: you mean xs <- string' b, right?
07:57:38 <jamil> nope
07:57:41 <monoidal> Botje: I think not, it's under fold
07:58:05 <Botje> oh, right
07:58:08 <Botje> mondays -.-
07:58:41 <Botje> jamil: have you tried working out string' "x" by hand?
07:58:51 <Botje> (and then string' "xy")
07:59:23 <monoidal> jamil: do you see that the ordering here matters: "do x <- getLine; y <- getLine; return (x,y)" - exchanging first two lines will give tuple in different order
07:59:43 <jamil> monoidal: I don't see why
08:00:25 <monoidal> jamil: for example, if you run the program and enter "a" and then "b" you get the tuple ("a","b"). if you change the order and type "a" then "b", you get ("b", "a")
08:00:52 <jamil> it should desugar to char a >>= \x -> b >>= \xs -> return (x:xs) right ?
08:01:16 <monoidal> char a >>= (\x -> b >>= (\xs -> return (x:xs))), yes
08:02:04 <monoidal> >>= executes its left operand and passes the result to the right operand. it is inherently noncommutative (you cannot execute a -> m b if you don't know what a to feed)
08:02:44 <monoidal> for example, getLine >>= print
08:03:21 <monoidal> first we get a String from getLine, for example "a", and then we do print "a". note that we have to actually read the string before we run print: it cannot be done right-to-left
08:04:08 <jamil> i see
08:04:32 <jamil> so in my case, by switching those line changes the order in which I read the inp string
08:04:54 <monoidal> jamil: it switches the order how parsers are constructed
08:04:58 <pmade> Change lines 5 and 6 gets you: b >>= (\xs -> char a >>= (\x -> return (x:xs)))
08:05:56 * hackagebot tagged 0.5 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.5 (EdwardKmett)
08:06:04 <mauke> assume the input string is "hello"
08:06:06 <jamil> right
08:06:10 <mauke> the action b will parse "ello"; a is 'h'
08:06:11 <jamil> ok
08:07:07 <m_hyperbolic> Can you make a type declaration for a function in ghci ?
08:07:24 <monoidal> m_hyperbolic: let id :: a -> a; id x = x
08:07:30 <merijn> m_hyperbolic: Yes, but generally it's easier to just work in a text file and load that
08:08:31 <m_hyperbolic> ah ok with a ;. Thanks!
08:08:49 <m_hyperbolic> merijn: and yes I agree, but I just wondered :)
08:22:55 <hpaste> dmcgill_laptop pasted “safeDivArrow” at http://hpaste.org/85838
08:23:14 <DMcGill_laptop> is this the best way of writing it?
08:23:45 <DMcGill_laptop> being inside Kleisli means that you can't call Nothing or mzero I think, hence why I used 'zeroArrow -< ()'
08:23:50 <trescenzi> So I presume the answer is I can't but if I wanted to be able to point from a child to it's parent in a tree is there any way to do it that doesn't involve searching the tree a second time?
08:24:09 <DMcGill_laptop> trescenzi: zippers can do that
08:24:12 <Bor0> besides "thinking recursively", which can be achieved in other (non functional) languages as well, what other differences are between, say haskell and python?
08:24:31 <merijn> Bor0: Laziness!
08:24:36 <koltar> Bor0: referential transparency is a big one, i'd say
08:24:40 <DMcGill_laptop> why do you need to do it in the first place though, perhaps lens can do what you're writing manually
08:24:42 <merijn> Bor0: Neat examples as follows:
08:25:01 <DMcGill_laptop> Bor0: strict static typing is a huge difference between python and haskell
08:25:05 <merijn> > let onesAndZeroes = 0 : 1 : onesAndZeroes in onesAndZeroes
08:25:07 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
08:25:22 <Bor0> that's... :D
08:25:24 <trescenzi> DMcGill_laptop: I'm writing a tree that sometimes needs to look at it's parent for values
08:25:26 <snoyberg> twoolie: https://www.fpcomplete.com/hoogle?q=mkMigrate http://haddocks.fpcomplete.com/fp/7.4.2/20130313-1/persistent-template/Database-Persist-TH.html#v:mkMigrate http://haddocks.fpcomplete.com/fp/7.4.2/20130313-1/persistent-template/src/Database-Persist-TH.html#mkMigrate
08:25:37 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs --because everyone needs fibonacci
08:25:37 <klrr> is this if-else expression invalid? http://hpaste.org/85839
08:25:39 <DMcGill_laptop> merijn: can't you do that with recursive iterators in python though?
08:25:39 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:25:48 <trescenzi> Right now I have a "pseudopointer" that names the parent and then it searches through the tree a second time
08:25:58 <merijn> DMcGill_laptop: Not with constant space like this one, I think?
08:25:58 <aCube> > let fibs = 0 : scanl (+) 1 fibs in fibs -- Alternative
08:25:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:26:16 <edwardk> merijn: i find that the code i write in haskell takes half the space of the equivalent code in python partially due to typeclasses dispatching things, is strongly typed so i catch my errors at compile time rather than runtime, is more robust because the types help me think about the code, and laziness causes me to not have to duplicate algorithms just to entangle another concern in most cases.
08:26:16 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
08:26:27 <edwardk> er s/merijn/bor0
08:26:41 <merijn> Bor0: I also think the type system and typeclasses are really neat, as compared to python
08:26:45 <alshain> @pl f x y z = fold (y z) x
08:26:45 <lambdabot> f = flip (flip . (fold .))
08:26:55 <klrr> is else required in a if expression?
08:27:00 <DMcGill_laptop> klrr: are you inside a do block?
08:27:01 <Bor0> thanks for the points
08:27:02 <koltar> klrr: yes
08:27:03 <aCube> klrr: yes
08:27:04 <merijn> Bor0: I got into haskell from python and I really don't wanna go back to no types :(
08:27:05 <klrr> DMcGill_laptop: yes
08:27:07 <edwardk> @tell supki. There is currently no TaggedT but I have no objection to adding one
08:27:07 <lambdabot> Consider it noted.
08:27:14 <Eduard_Munteanu> klrr: luckily you rarely need if-then-else :)
08:27:25 <merijn> klrr: If there was no else, what would happen if the boolean was False?
08:27:30 <klrr> i need it to check if there even are stuff in the list to
08:27:34 <fizbin> trescenzi: Do you need to refer to the whole parent, or just to the data the parent holds?
08:27:51 <fizbin> trescenzi: Basically, do you ever need to walk back up the tree?
08:27:54 <merijn> klrr: In do you might be looking for when?
08:27:57 <merijn> :t when
08:27:59 <lambdabot> Monad m => Bool -> m () -> m ()
08:28:04 <edwardk> Bor0: so other than brevity, reasonability, reduced code duplication and a culture that is more oriented around correctness, not much ;)
08:28:05 <klrr> merijn: if the boolean is false it prints a line and then exit
08:28:06 <koltar> is there an equivalent to mapAccumL which doesn't actually map anything? something like accumL
08:28:09 <trescenzi> fizbin: yea I might have to walk all the way back up the tree
08:28:13 <alshain> @pl f x y z = fold (y z z) x
08:28:13 <lambdabot> f = flip (flip . (fold .) . join)
08:28:52 <merijn> :t when (not ?x) $ putStrLn "Whoops!"
08:28:53 <lambdabot> (?x::Bool) => IO ()
08:28:59 <hpaste> dmcgill_laptop annotated “sdgsdgsd” with “sdgsdgsd (annotation)” at http://hpaste.org/85839#a85840
08:29:07 <fizbin> trescenzi: Interesting. I think then that though you can do this, it has bad implications for how slow constructing the tree is going to be.
08:29:14 <edwardk> oh, and lexical scoping rules that aren't dumb =)
08:29:20 <amiller> anyone use the criterion benchmarking library
08:29:24 <DMcGill_laptop> klrr: if you abstract out your server into a function runServer, then you can use this nice clean version
08:29:30 <merijn> edwardk: python has decent lexical scoping, IMO
08:29:31 <edwardk> amiller: yes
08:29:32 <amiller> i'm a little frustrated that it seems i can't add a prep/setup phase for *each* benchmark rather than just one for the whole execution
08:29:34 <typoclass> Boro: it's frustrating if the haskell compiler yells at me all day, but the key realization for me was that 90% of those things are problems with my code that the compiler is alerting me to. it's not made-up ridiculous stuff just to annoy me :-)
08:29:40 <DMcGill_laptop> using length and (!) like that you go over the list about 5 times in total
08:29:59 <trescenzi> fizbin: I was thinking of including the parent in the child but that makes the space complexity really terrible
08:30:10 <amiller> i want to benchmark the amount of time it takes to add/delete 100 elements to a tree, but starting with a tree of size 1k, 10k, etc
08:30:18 <amiller> i don't want constructing or loading that tree to be part of it
08:30:22 <edwardk> merijn: http://programmers.stackexchange.com/questions/15468/what-are-the-drawbacks-of-python/15507#15507
08:30:24 <trescenzi> oh and sadly it's a rose tree not binary because that would be simple
08:30:35 <klrr> is there a way to test something in a do block, if it's true then print something and exit and if false just conteniue the do =
08:30:38 <klrr> ?
08:30:41 <trescenzi> it can be arbitrarily wide
08:30:52 <DMcGill_laptop> trescenzi: zippers let you go up and down tree structures. The data is shared so the space complexity is fine
08:30:53 <fizbin> trescenzi: I think the most efficient way to build this structure is going to be to have a non-parent-pointing tree and then a function that converts such a tree into your tree-with-up-pointers.
08:30:56 <edwardk> merijn: yes, i know global and nonlocal have been introduced to patch over this historical oddity
08:31:07 <edwardk> merijn: but its a _very_ arbitrary default
08:31:16 <DMcGill_laptop> trescenzi: http://www.haskell.org/haskellwiki/Zipper
08:31:19 <merijn> global has always been there, I think? At least as I can remember, nonlocal is recent, yeah
08:31:21 <fizbin> trescenzi: Though yes, I'd look closely at zippers to see if they can do what you want first.
08:31:23 <klrr> i want to test if the args is as many as needed, if not exit and print a message, else continue the do block, how can i do that?
08:31:42 <merijn> edwardk: Oh, I'm not saying it's a *good* default, but at least its consistent, works and well-documented
08:31:43 <DMcGill_laptop> klrr: did you see that I linked http://hpaste.org/85839#a85840 above?
08:31:44 <trescenzi> fizbin and DMcGill_laptop thanks I had not seen those before
08:32:09 <fizbin> trescenzi: But if you're committed to this points-to-parent approach, I think it can be done. Let me think about how…
08:32:14 <merijn> edwardk: As opposed to all these fancy Web2.0 that don't even have lexical scoping (e.g. CoffeeScript)
08:32:16 <edwardk> i merely made the value judgment that it was 'dumb', not that people couldn't reason about it ;)
08:32:23 <klrr> DMcGill_laptop: nice, thank you, do a case have to be in the end of a do or can it be in the middle?
08:32:34 <edwardk> i wrote python for many years before i switched to haskell
08:32:48 <trescenzi> fizbin: yea in c++ or a language with pointers I'd just include a pointer to the parent but I can't do that here since it's all really just a list
08:32:52 <typoclass> Bor0: so in my opinion, dynamic languages (python ...) are somewhat understandable historically, but ultimately, dynamic typing is shooting the messenger. i *want* to know about problems with my code, and the earlier the better :-) i'd rather be told now by a picky compiler, than in some weeks by someone screaming at me at 3:30 am
08:32:58 <merijn> I prefer consistent and properly work lexical scoping with an odd default to inconsistent/non-functional scoping :p
08:33:44 <FireFly> Does  flip (.)  have a standard (Haskell) name?
08:33:45 <DMcGill_laptop> klrr: the idea is that you have a runServer function with all the code in. Your main will simply be `main = do {args <- getArgs; case args of ...}'
08:33:59 <Lethalman> typoclass, that said, only with good type inference (that is, not java :P )
08:34:04 <FireFly> (or, well, common name)
08:34:06 <Eduren> Hey, so Haskell was accepted as an organization in Googles Summer of Code. But I dont see any information page other than the list of projects and past summers.
08:34:11 <aCube> @ty (>>>)
08:34:13 <klrr> well it doesnt work with my code actually, since i need chan and stdlib to be global variables
08:34:13 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
08:34:22 <aCube> @ty (>>>) `asTypeOf` flip (.)
08:34:23 <typoclass> Lethalman: yup
08:34:24 <lambdabot> (a -> b) -> (b -> c) -> a -> c
08:34:25 <FireFly> aCube: oh, right, yeah
08:34:31 <Eduren> And those projects havent been updates in months
08:34:35 <FireFly> hm
08:34:39 <FireFly> @ty asTypeOf
08:34:41 <lambdabot> a -> a -> a
08:34:43 <DMcGill_laptop> klrr: if they're arguments to runServer, then they can be accessed from anywhere inside it
08:35:13 <DMcGill_laptop> that's about as global as you're going to get without cheating
08:35:15 <merijn> FireFly: Wanna see real voodoo?
08:35:16 <klrr> DMcGill_laptop: i know, but chan will be used later and stdlib in a other functions
08:35:28 <merijn> :t (>>>) `asAppliedTo` id
08:35:29 <lambdabot> (b -> b) -> (b -> c) -> b -> c
08:35:39 <klrr> currently the "variables" are simply functions that just return their values
08:35:45 <DMcGill_laptop> klrr: then pass them to the other functions as arguments or look into MVars and pass those around
08:36:01 <merijn> klrr: Reader monad, maybe?
08:36:09 <FireFly> @ty asAppliedTo
08:36:11 <lambdabot> (t -> b) -> t -> t -> b
08:36:23 <FireFly> Hm
08:36:38 <koltar> klrr: you know variables can't be modified in Haskell, right?
08:36:45 <merijn> tbh, I don't even really know how asAppliedTo works, but I haven't really looked into it
08:36:47 <DMcGill_laptop> can somebody that knows arrows have a look at http://hpaste.org/85838 please?
08:37:07 <FireFly> >> asAppliedTo  -- is it just defined to be `undefined`?
08:37:10 <DMcGill_laptop> is there a more elegant way of writing that?
08:37:14 <FireFly> er
08:37:17 <FireFly> > asAppliedTo
08:37:19 <lambdabot>   *Exception: show: No overloading for function
08:37:33 <DMcGill_laptop> FireFly: it's probably const
08:37:38 <FireFly> Oh
08:37:45 <FireFly> Yeah, that makes sense
08:37:47 <aCube> Type restricted const, so you can force types
08:37:49 <DMcGill_laptop> @src asAppliedTo
08:37:49 <lambdabot> Source not found. Just try something else.
08:38:14 <aCube> > id `asAppliedTo` 3
08:38:16 <lambdabot>   *Exception: show: No overloading for function
08:38:18 <DMcGill_laptop> :t (>>>) `const` id
08:38:19 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
08:38:22 <aCube> @ty id `asAppliedTo` 3
08:38:23 <lambdabot> Num b => b -> b
08:38:52 <merijn> aCube: You usually pass it to @ty/:t, yeah
08:39:16 <ryantanjunming> heys, is there a "effect" way i can immediately get a character from Stdin without entering a return statement?
08:39:41 <merijn> ryantanjunming: Disable buffering
08:40:01 <merijn> @hoogle hSetBuffering
08:40:01 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
08:40:01 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
08:40:10 <Bor0> what mathematical methods exist to prove correctness of a recursive function?
08:40:14 <DMcGill_laptop> ryantanjunming: I think you're a little confused about how IO works, but in general you can't do IO without making your functions impure
08:40:16 <koltar> ryantanjunming: no buffering, or you can try doing line-by-line IO, which may end up cleaner :)
08:40:18 <companion_cube> Bor0: induction
08:40:26 <merijn> ryantanjunming: By default writing to/reading from stdin and stdout are line buffered
08:40:37 <Bor0> why didn't I think of that. thanks.
08:40:38 <ryantanjunming> DMcGill_laptop: i know which is why i said effect
08:40:48 <DMcGill_laptop> ryantanjunming: my apologies, I misunderstood what you meant
08:41:05 <ryantanjunming> DMcGill_laptop:its ok, thanks
08:41:13 <ryantanjunming> merign: bigger thanks to ya
08:41:18 <merijn> ryantanjunming: Anyway, i you hoogle that function you can click the docs to see how you use it
08:41:33 <FireFly> @ty (.)
08:41:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:41:46 <FireFly> No Control.Category.. :(
08:41:51 <koltar> prettmy sure there's an example in the Gentle Introduction too
08:41:53 <ryantanjunming> merign: genius
08:43:31 <[swift]> so i noticed that GHC.Conc.numCapabilities is 1 if i build my executable for profiling
08:43:37 <[swift]> this is a bit of a bummer
08:43:48 <ryantanjunming> koltar: heys, ur line-by-line IO would be a getChar, but that still requires the return key to be entered right?
08:44:14 <aCube> @src mapM
08:44:14 <lambdabot> mapM f as = sequence (map f as)
08:44:28 <aCube> @src mapM_
08:44:29 <lambdabot> mapM_ f as = sequence_ (map f as)
08:45:14 <DMcGill_laptop> ryantanjunming: I don't know, it's easy enough to test though both with and without `hSetBuffering NoBuffering' or whatever it is
08:46:02 <ryantanjunming> DMcGill_laptop: so i just typr in hSetBuffering NoBuffering, says i need a Handle
08:46:36 <ryantanjunming> hSetBuffering = NoBuffering
08:46:38 <ryantanjunming> works
08:46:54 <DMcGill_laptop> ryantanjunming: looking on Hoogle, the type of hSetBuffering :: Handing -> BufferMode -> IO ()
08:46:56 <Botje> ryantanjunming: that just redefines hSetBuffering.
08:47:05 <DMcGill_laptop> so you want to run hSetBuffering stdin NoBuffering
08:47:12 <aCube> :t hSetBuffering stdin NoBuffering
08:47:14 <lambdabot> Not in scope: `hSetBuffering'
08:47:14 <lambdabot> Not in scope: `stdin'
08:47:14 <lambdabot> Not in scope: data constructor `NoBuffering'
08:47:32 <merijn> aCube: lambdabot doesn't export System.IO
08:47:44 <ryantanjunming> aCube so stdin is a handle?
08:47:46 <DMcGill_laptop> ryantanjunming: see http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetBuffering
08:47:50 <sm> ack.. haskell platform doesn't include cabal-install on windows, I guess ?
08:47:51 <aCube> ryantanjunming: yes
08:48:00 <merijn> sm: It does for me
08:48:07 <DMcGill_laptop> also on that page are the Handle and BufferMode data types
08:48:11 <sm> hm
08:48:11 <aCube> @hoogle stdin
08:48:12 <lambdabot> System.IO stdin :: Handle
08:48:12 <lambdabot> GHC.IO.Handle.FD stdin :: Handle
08:48:50 <sm> I don't see it in \Program Files\Haskell Platform\2012.4.0.0\bin
08:49:06 <typoclass> sm: do you have the required directory in the %PATH%, or whatever the windows equivalent is?
08:50:07 <sm> I expect not.. does the installer set that up normally ?
08:50:32 <merijn> sm: I remember seeing an option to do that yes
08:50:51 <sm> aha! yes it did. I just had to open a new DOS prompt
08:51:18 <sm> thanks all
08:52:02 * sm is doing this in wine, to add a little extra confusion
08:53:02 <ryantanjunming> hmm, doesnt seem to work guys, still gotta hit return to getLine my input
08:54:20 <DMcGill_laptop> ryantanjunming: http://stackoverflow.com/questions/2983974/haskell-read-input-character-from-console-immediately-not-after-newline
08:54:53 <DMcGill_laptop> in short: it's a bug, but there is a work around
08:55:38 <Ankhers> Does anyone know if the new platform is on schedule for release early-mid may?
08:55:53 <ryantanjunming> :(
08:55:58 * hackagebot Craft3e 0.1.0.10 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  http://hackage.haskell.org/package/Craft3e-0.1.0.10 (SimonThompson)
08:57:27 <ryantanjunming> DMcGill_laptop: workaround is getHiddenChar.. dodge..
08:57:41 <ryantanjunming> but thanks
08:58:08 <DMcGill_laptop> ryantanjunming: I don't understand what you mean
08:58:15 <DMcGill_laptop> :t Kleisli
08:58:16 <lambdabot> (a -> m b) -> Kleisli m a b
08:59:06 <DMcGill_laptop> what does it take for constructors to have constraints? GADTs?
08:59:25 <DMcGill_laptop> would it be better or worse if Set had an ord constraint etc?
08:59:51 <supki> edwardk: well, what I want from TaggedT does not fit into H98 =(
08:59:54 <DMcGill_laptop> I suppose all the functions would need one too
09:00:07 <edwardk> supki: tagged-extras time ;)
09:00:23 <c_wraith> DMcGill_laptop: also, not *all* Set functions have the Ord constraint.
09:00:43 <c_wraith> DMcGill_laptop: by putting that constraint in the constructor, you would be explicitly making it work less often
09:00:58 * hackagebot up 0.1.0.0 - Generates pathnames to up directories  http://hackage.haskell.org/package/up-0.1.0.0 (ThomasEding)
09:01:00 * hackagebot RxHaskell 0.2 - Reactive Extensions for Haskell  http://hackage.haskell.org/package/RxHaskell-0.2 (JustinSpahrSummers)
09:01:43 <c_wraith> @ty Data.Set.singleton -- DMcGill_laptop: notice the lack of Ord a => ...
09:01:45 <lambdabot> a -> S.Set a
09:01:50 <DMcGill_laptop> c_wraith: does that matter though? The only way you can add non-Ord elements to Set would be singleton iirc. You couldn't get any out either, only use toList or null
09:02:05 <fizbin> trescenzi: I've got an example tree-with-parent implementation to show you.
09:02:21 <trescenzi> fizbin: ok sweet thanks
09:02:27 <c_wraith> DMcGill_laptop: it's still more restrictive for no gain except having trivially shorter type signatures
09:02:35 <DMcGill_laptop> fair enough
09:04:30 <hpaste> fizbin pasted “Rose tree with parent pointers (for trescenzi)” at http://hpaste.org/85844
09:05:19 <DMcGill_laptop> fizbin: wouldn't it be better to use a zipper library than define everything yourse;f?
09:05:25 <trescenzi> fizbin: thanks!
09:05:58 <trescenzi> DMcGill_laptop: In this case I'm not certain I can just use a built in library
09:05:58 * hackagebot hamlet 1.1.7.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.7.1 (MichaelSnoyman)
09:06:05 <fizbin> DMcGill_laptop: I suppose, but I haven't really defined anything yet there that a zipper library would do.
09:06:08 <trescenzi> it's a rather specific example
09:07:12 <pmade> With TH, if I have a non-TH function that takes a Name as an argument, how do I pass that variable to a TH function? $(foo name) gives me a stage restriction.
09:10:18 <fizbin> trescenzi: That code follows the "build it without parents, then add parentage information at the end" approach. I think it might be possible to write a zipper that could build/update trees with parentage from scratch, but it would take a little while to work out.
09:11:52 <trescenzi> fizbin: yea that made sense. I was actually thinking about building the tree upside down and that's kinda what that does.
09:12:15 <merijn> The only way to dispatch on types is using typeclasses, right? i.e. the most universal approach if I want to do that type of stuff is using Data.Typeable, right?
09:17:22 <ryantanjunming> issit possible to catch eof in stdin?
09:17:59 <ryantanjunming> e.g. `< less <a file>`
09:18:14 <arkeet> :t isEOF
09:18:16 <lambdabot> Not in scope: `isEOF'
09:18:27 <DMcGill_laptop> @hoogle isEOF
09:18:28 <lambdabot> System.IO isEOF :: IO Bool
09:18:28 <lambdabot> GHC.IO.Handle.FD isEOF :: IO Bool
09:18:28 <lambdabot> System.IO.Error isEOFError :: IOError -> Bool
09:18:29 <mauke> ryantanjunming: huh?
09:18:34 <jfischoff> merijn: yes I would say. Although I've never had to use typeable
09:19:01 <typoclass> ryantanjunming: have you tried getContents? it is something that needs extra attention (lazy i/o ...), but when it works, it's probably the easiest way
09:19:14 <merijn> jfischoff: I wanna do things like heterogeneous list of functions, then apply all functions whose type match
09:19:29 <Taneb> merijn, you need typeable for that
09:19:39 <arkeet> if you want to keep any type information around at runtime, you need typeable.
09:19:42 <merijn> Taneb: That's what I figured, was just checking :)
09:19:53 <Taneb> It seems a bit odd thing to do, though
09:19:58 <jfischoff> merijn: it might be possible to not use typeable, for instance if a Thrist would work
09:20:00 <merijn> arkeet: Not if you manage to get everything working statically :p
09:20:05 <merijn> Thrist?
09:20:09 <jfischoff> @hackage Thrist
09:20:10 <lambdabot> http://hackage.haskell.org/package/Thrist
09:20:24 <merijn> 404
09:20:26 <jfischoff> :|
09:20:37 <arkeet> @hackage thrist
09:20:37 <lambdabot> http://hackage.haskell.org/package/thrist
09:20:38 <typoclass> merijn: http://hackage.haskell.org/package/thrist
09:20:44 <jfischoff> http://hackage.haskell.org/package/thrist
09:20:51 <hpaste> poophead pasted “catching EOF...” at http://hpaste.org/85846
09:20:55 <geekosaur> the @hackage command, sadly, does not search
09:21:26 <ryantanjunming> eh, poophead is me
09:21:28 <arkeet> I wonder why arr isn't a type argument to Thrist?
09:21:43 <hpaste> mememe pasted “catching EOF...” at http://hpaste.org/85847
09:21:45 <arkeet> isEOF, not IsEOF
09:21:46 <merijn> jfischoff: Oh, that's interesting a GADT is exactly how I have my current heterogenous list
09:22:20 <arkeet> also, please don't use tabs.
09:22:30 <arkeet> hlint ought to complain about tabs.
09:22:40 <gabor> arkeet: Thrist has 3 type args
09:22:45 <mememe> arkeet: huh?
09:22:53 <arkeet> gabor: oh I'm dumb.
09:23:08 <mememe> arkeet are u refering to my paste?
09:23:11 <arkeet> mememe: yes
09:23:20 <mememe> which line should i fix?
09:23:23 <merijn> Oh, no. The Thrist type is very different from what I have
09:23:27 <typoclass> mememe: to me, that looks a lot like "main = putStrLn =<< fmap (map toUpper) =<< getContents"
09:23:38 <typoclass> (untested)
09:23:43 <arkeet> mememe: well, first of all it's isEOF, not IsEOF
09:23:59 <arkeet> second, you have hard tab characters everywhere
09:24:00 <arkeet> @where style
09:24:01 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
09:24:01 <mememe> typoclass yeah but i gotta make an impure function
09:24:23 <geekosaur> ...and that isn't?
09:24:42 <merijn> Right now I have "data Foo :: [*] -> * where Nil :: Foo '[]; Cons :: a -> Foo as -> Foo (a ': as)" for my heterogeneous list
09:25:03 <arkeet> read the first link there on why tabs are bad.
09:25:15 <mememe> arkeet, seems easier to read..
09:25:20 <arkeet> use spaces instead.
09:25:29 <mememe> arkeet: ok, noted
09:26:21 <arkeet> haskell assumes tab stops are all at 8 characters, so unless your editor is configured to match that, you may end up with errors that don't make sense due to weird indentation.
09:26:48 <arkeet> (well, read the link)
09:27:02 <arkeet> but anyway...
09:27:17 <merijn> Taneb: As for it being an odd thing, I'm experimenting with some very heavy type level programming, but I'm running into some scenarios where I can't write code that actually matches my types without Data.Typeable :p
09:27:42 <Taneb> merijn, it sounds like you need more GADTs
09:27:43 <mememe> arkeet: how bout a double if statement? just two spaces?
09:28:00 <arkeet> ?
09:28:07 <merijn> Taneb: If I knew how to do it with GADTs I would
09:28:42 <mememe> arkeet: is an impure function like mine like a python code?
09:28:55 <arkeet> I don't know what you mean by "impure function"
09:28:57 <merijn> Taneb: But I dunno how to write code that does "X iff type matches t, Y otherwise" without typeclasses/Typeable
09:29:16 <merijn> Relatedly, is there anything that can't be made in instance of Typeable?
09:29:26 <Taneb> With polymorphism, you can't do it WITH typeable
09:29:29 <arkeet> higher-rank types probably
09:29:35 <arkeet> ?
09:29:35 <Taneb> Anything with polymorphism
09:29:37 <arkeet> yeah
09:29:47 <merijn> Taneb: What does that mean?
09:29:50 <Taneb> :t id
09:29:52 <lambdabot> a -> a
09:30:11 <Taneb> You need to solidify the "a" to an actual type before it can be made an instance of Typeable
09:30:29 <hpaste> typoclass annotated “catching EOF...” with “catching EOF... (annotation)” at http://hpaste.org/85847#a85848
09:30:31 <aCube> Does GHC expand traverse_ f [1..4] to pure () <* f 1 <* f 2 <* f 3 <* f 4 ?
09:30:35 <merijn> oh, right, that shouldn't be a problem, I think?
09:30:52 <merijn> I think I only want to dispatchon concrete types anyway
09:30:53 <typoclass> mememe: ^^ here is a suggestion how you could write it. (i hope it works)
09:30:54 <Taneb> So, if you had a function whose type was an instance of typeable, it couldn't match it with 6 and "hello", even if it was just id
09:30:57 <thirsteh> anyone else have problems with the tls package (e.g. in http-conduit)? I can't seem to access any TLS host: TlsException (HandshakeFailed (Error_Packet_unexpected \"Alert [(AlertLevel_Fatal,BadRecordMac)]\" \" expected: change cipher\"))
09:31:37 <arkeet> aCube: find out by looking at core?
09:32:16 <aCube> arkeet: ok, I tried it, seems like pure () <* f 1 <* f 2 <* f 3 <* f 4  is faster, but it doesn't look so nice :(
09:32:25 <mememe> typoclass: wow, thanks, big thanks
09:34:16 <arkeet> aCube: well, they're different, actually
09:34:18 <typoclass> @where when
09:34:19 <lambdabot> I know nothing about when.
09:34:23 <typoclass> @hoogle when
09:34:24 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
09:34:24 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
09:34:24 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
09:34:27 <arkeet> traverse_ f [1..4] = f 1 *> f 2 *> f 3 *> f 4 *> pure ()
09:34:43 <typoclass> mememe: no problem :-) i think you need to import Control.Monad for that one function i used (see above)
09:35:10 <mememe> typoclass: yeah just did.. kept stating errors
09:35:38 <mememe> @hoogle fmap
09:35:38 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
09:35:38 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
09:35:38 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
09:37:51 <aCube> arkeet: f 1 *> f 2 *> f 3 *> f 4 *> pure () is also faster
09:38:02 <arkeet> what if you write traverse_ f [1,2,3,4]?
09:38:10 <arkeet> oh,
09:38:16 <arkeet> is your thing polymorphic in the number type?
09:38:40 <aCube> arkeet: I tried with [1::Int..4], same effect
09:38:46 <arkeet> hm
09:39:02 <arkeet> no but what about [1,2,3,4]
09:39:07 <hpaste> typoclass revised “catching EOF... (annotation)”: “Works now” at http://hpaste.org/85848
09:39:49 <typoclass> mememe: here, i fixed it :-) my thingy wasn't working. sorry, should have done that right away
09:40:07 <aCube> arkeet: same with [1,2,3,4]
09:41:01 <typoclass> mememe: i've got to run now, but in short, fmap is used because toUpper is a pure function (Char -> Char), but getChar doesn't give a Char
09:41:04 <typoclass> @type getChar
09:41:06 <lambdabot> IO Char
09:41:33 <mememe> typeclass, thanks dude.. but now i dunno what the hSetBuffering stdin NoBuffering is for...
09:41:43 <mememe> typeclass: nvm
09:41:43 <tac> @type map . map toUpper
09:41:45 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `[b1]'
09:41:45 <lambdabot>     Expected type: [a1] -> a0 -> b0
09:41:45 <lambdabot>       Actual type: [a1] -> [b1]
09:41:52 <tac> @type map $ map toUpper
09:41:53 <lambdabot> [[Char]] -> [[Char]]
09:42:24 <typoclass> ... so it's "IO Char", not "Char". line 13 is the same as writing "c <- getChar" and then "putChar (toUpper c)". it's just a little shortcut
09:42:41 <arkeet> aCube: *> is infixl
09:42:46 <arkeet> what about f 1 *> (f 2 *> ...)
09:43:02 <tac> is there a convenient function to concat with spaces for a string?
09:43:11 <arkeet> :t intercalate
09:43:13 <lambdabot> [a] -> [[a]] -> [a]
09:43:18 <arkeet> :t intersperse
09:43:19 <lambdabot> a -> [a] -> [a]
09:43:20 <typoclass> > unwords ["lol", "cat"] -- tac
09:43:22 <lambdabot>   "lol cat"
09:43:23 <arkeet> oh, unwords.
09:43:28 <tac> ah yes!
09:43:30 <tac> thanks :)
09:43:36 <arkeet> unwords = intercalate " "
09:46:30 <aCube> arkeet: still same result
09:46:35 <arkeet> interesting
09:46:49 <klrr> can i write "x == response" where x is a string and response is a function of type String?
09:46:49 <arkeet> although maybe not too surprising.
09:47:21 <Iceland_jack> klrr: if it's of type String then it's not a function
09:47:28 <klrr> okey
09:48:46 <arkeet> functions have -> in their types.
09:49:01 <arkeet> (at the top level.)
09:49:13 <Eduard_Munteanu> :t (==)
09:49:15 <lambdabot> Eq a => a -> a -> Bool
09:49:31 <Eduard_Munteanu> klrr: like the type says, the operands have the same type ^^
09:49:58 <Eduard_Munteanu> Or must have, if it wasn't clear.
09:57:50 <Dodek> hey, i have f :: a -> m b and v :: Maybe a. i want to obtain m (Maybe b). is there a nicer way to do the equivalent of sequence (f <$> v) ?
09:58:02 <Dodek> sequence comes from Traversable
09:58:34 <byorgey> Dodek: traverse
09:58:38 <byorgey> @type traverse
09:58:39 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:58:51 <Dodek> heh
09:58:53 <Dodek> thanks byorgey
10:09:19 <Palmik> Hmm, does anyone know what happens to private repositories on github when you coupon expires?
10:09:34 <Palmik> s/you/your/
10:10:00 <ab9rf> they turn into pumpkins/
10:10:26 <ehamberg> Palmik: you get an email that tells you that you have to start paying or make your private repositories public.
10:10:31 <klrr> http://hpaste.org/85850 (error and code in paste), i get this type mismatch error, how do i make it work? got problems with Either
10:10:51 <ehamberg> i guess you'll lose write access to your private repositories if you don't to anything.
10:11:43 <Ankhers> Does anyone know if the new Haskell Platform is still on track to be released early-mid may?
10:12:22 <geekosaur> "probably"
10:12:32 <monoidal> klrr: you put Either A B C where A ~ IOThrowsError [LispVal], B ~ ThrowsError, C ~ LispVal
10:12:43 <monoidal> klrr: not sure what you wanted, but that's why there's an error - Either takes two args
10:12:51 <ab9rf> private repos are locked if the paid account to which they were associated goes out of current status
10:12:56 <geekosaur> they're arguing over ghc versions again >.>
10:13:12 <klrr> monoidal: oh okey
10:13:24 <ab9rf> you can convert them to public and regain access if this happens
10:13:31 <ab9rf> (but they'll be public at that point, be warned)
10:13:35 <Ankhers> Is there anywhere that I would be able to get information about the current status?
10:13:48 <ab9rf> Ankhers: depends on how much you want to spend on ninjas
10:14:40 <Palmik> ehamberg: OK, thanks.
10:15:12 <ab9rf> Palmik: github currently won't delete private repos when they're no longer being paid for.  you just can't access them.
10:15:24 <ab9rf> Palmik: https://help.github.com/articles/what-happens-if-my-account-is-locked
10:16:03 <geekosaur> Ankhers: http://www.haskell.org/pipermail/libraries/2013-April/thread.html
10:16:25 <Dodek> i have a lens question
10:16:26 <geekosaur> libraries list gets updates on platform status; I suspect they do most actual discussion elsewhere though
10:16:43 <Dodek> suppose i'm inside State Foo monad
10:17:01 <Dodek> where data Foo = Foo { bar :: Map Int String, ... }
10:17:13 <Dodek> with lens, i can do things like
10:17:30 <Dodek> bar .= insert 1 "asd" Map.empty
10:17:57 <Dodek> but suppose i want to insert some element to the map bar
10:18:03 <Dodek> how can i compose lens to do that?
10:18:38 <klrr> have anyone here done the Write Scheme in 48 hours tutorial? i need some help regarding it
10:18:38 <Ankhers> geekosaur: Thanks. that helped.
10:18:41 <merijn> Probably something like: bar . idx 1 .= Just "asd"
10:18:47 <Eduard_Munteanu> Dodek: use (%=)
10:19:04 <fizbin> Dodek: So I can think of two ways.
10:19:24 <fizbin> Either bar . at 1 .= Just "asd"
10:19:27 <fizbin> Or:
10:19:43 <merijn> I was close \o/
10:19:44 <Eduard_Munteanu> bar %= insert 5 "foo"
10:19:44 <Iceland_jack> klrr: If you have a question just ask it
10:19:53 <fizbin> bar %= insert 1 "asdf"
10:19:59 <Dodek> ah
10:20:13 <Dodek> i actually tried bar . at 2 .= "asd"
10:20:17 <Dodek> but forgot about Just
10:20:19 <dmj> hey guys, I made the state monad, but now I want to make it a functor (since all monads *can* be functors right?), my code looks like fmap f a = State $ \s -> (f a, s) but ghci says it can't match type 'a' with State s a, since a is a rigid type
10:20:23 <Dodek> thank you!
10:20:27 <Palmik> ab9rf: Ah, thanks for the heads up.
10:20:35 <Eduard_Munteanu> dmj: all monads *are* functors
10:20:47 <fizbin> Assuming "at" is the right combinator. Can't remember all the lens stuff… There's also #haskell-lens as a place to ask.
10:21:01 <edwardk> what is the goal?
10:21:02 <dmj> Eduard_Munteanu: k good
10:21:03 * edwardk just tuned in
10:21:08 <fizbin> @hoogle fmapDefault
10:21:09 <edwardk> bar . at 2 ?= "asd"
10:21:09 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
10:21:24 <edwardk> ?= puts a Just on the right hand side
10:21:25 <lambdabot> Maybe you meant: . ? @ v
10:21:41 <edwardk> > M.empty & at 2 ?~ 3
10:21:43 <dmj> Eduard_Munteanu: any ideas on my functor implementation?
10:21:44 <lambdabot>   fromList [(2,3)]
10:21:58 <monoidal> dmj: fmap f (State a) = ...
10:22:06 <edwardk> > M.empty & at 2 ?~ 3 & at 4 ?~ 5 & at 2 .~ Nothing
10:22:08 <lambdabot>   fromList [(4,5)]
10:22:57 <monoidal> dmj: fmap f a = \s -> (f a, s) is wrong. That means that after fmap your state value will never change the state
10:23:16 <edwardk> Dodek: 'at x' gives you a lens to Maybe a value. you can delete by setting it to Nothing or insert by setting it to Just something
10:23:29 <monoidal> dmj: for example, the function \s -> (s+5, s+1) after "fmap (+2) should become \s -> (s+7, s+1)
10:24:22 <Dodek> edwardk: yeah, i forgot to use Just when setting, and couldn't understand the compile error
10:24:25 <dmj> monoidal: I think it was fmap f a = State $ \s -> (f a, s), which would use the data constructor of state. You're saying f needs to be applied to both (a,s) here?
10:24:26 <fizbin> dmj: Can you hpaste your State monad definition?
10:24:51 <monoidal> dmj: you need the data constructors on both LHS and RHS
10:25:27 <hpaste> dmj pasted “rando” at http://hpaste.org/85851
10:25:30 <monoidal> dmj: what "fmap f a" should do, given state s, is do what "a" does, return the new state after doing "a" but the end value should be after applying f
10:26:38 <fizbin> dmj: what monoidal is saying is that the LHS of the definition should be: fmap f (State statefn) =
10:27:10 <ipetrovilya> `cabal install <pkg> --verbose=3` works in a retarted way on my Win7, stubling upon each <name>.exe call. Is it ok?
10:27:33 <monoidal> dmj: disregarding type constructors, we have f :: a -> b and we want fmap f :: (s -> (a,s)) -> (s -> (b,s))
10:28:12 <monoidal> dmj: when doing "fmap f (State a)", we have f :: (a -> b) and a :: s -> (a,s). we cannot do "f a" since that's a type error
10:29:18 <fizbin> dmj: What you could do though is something like \s -> (f a', s') where (a', s') = a s
10:31:01 <dmj> monoidal: Isn't the type of a here "(s -> (a,s))" and using the above definition of f of "(s -> (a,s) -> (s -> (b,s)))" why wouldn't those types match?
10:31:22 <dmj> f is (s -> (a,s)) -> (s -> (b,s))
10:31:29 <fizbin> dmj: fmap f (State a) = \s -> (let (a', s') = a s in (f a', s'))
10:31:59 <monoidal> dmj: no, fmap requires general function a -> b to be converted to f a -> f b
10:32:21 <fizbin> dmj: No, f isn't. If you're defining an fmap instance for "State s", then "f" is a -> b and "fmap f" is "State s a -> State s b"
10:33:32 <dmj> fizbin: wouldn't you need to rewrap inside of state? fmap f (State a) = State $ \s -> (let (a', s') = a s in (f a', s'))
10:33:44 <fizbin> Right, rewrapped in State.
10:33:46 <fizbin> Forgot that.
10:37:48 <dmj> fizbin: thanks, gonna need to let this sink in.
10:37:57 <fizbin> Hey, can people check my understanding? If Monad were being rebuilt today, it would be built with (Applicative m) => Monad m and the only function on the typeclass would be "join"? (Well, maybe others for efficient overloads)
10:38:03 <monoidal> dmj: do you know fmap of the Reader monad? it is bit simpler
10:38:57 <monoidal> fizbin: that's correct
10:39:15 <aCube> fizbin: There could be both join and (>>=), each with default definitions in terms of the other
10:40:18 <veggies12> fizbin: often (>>=) is more convenient to implmement, so both would probably be class methods (but you'd only have to define one)
10:40:28 <dmj> monoidal: no, can you link me?
10:40:50 <fizbin> Right. But the point is, "join" would be sufficient to go from Applicative to Monad.
10:40:52 <dmj> monoidal: or just say "hoogle it" or something
10:40:52 <monoidal> veggies12: I don't know any such case. join x = x >>= id so take any defn of (>>=), substitute id (which often simplifies) and you get join
10:41:37 <monoidal> dmj: well, I hope you do it as an exercise. we have newtype Reader r a = Reader (r -> a). it's a monad, but that doesn't matter. try writing the Functor instance
10:42:29 <monochrom> join is easier if you think container. >>= is easier if you think plumbing.
10:44:18 <monochrom> imagine! State s (State s a) -> State s a
10:44:59 <aCube> monochrom: pass the outer state to the inner state computation?
10:45:01 * simpson thinks of (s -> (s -> (a, s), s)) -> s -> (a, s)
10:45:44 <klrr> Iceland_jack: okey, well when you use the load function it crashes if it doesnt fine the file
10:45:51 <klrr> i dont really know how to solve this
10:46:02 <monoidal> maybe it looks nasty because of nesting of State s, but the meaning is very clear
10:46:25 <monoidal> execute the first state-changing computation, you get another computation, execute it and there's the result
10:46:31 <fizbin> There isn't a Monad instance for ZipList, is there?
10:46:38 <monoidal> fizbin: no
10:46:47 <monoidal> fizbin: ZipList is a canonical non-monad applicative.
10:46:58 <monoidal> (canonical in non-mathematical sense)
10:47:10 <fizbin> monoidal: I thought that was Const.
10:47:19 <monoidal> ah, Const too
10:47:43 <fizbin> But ZipList … I can see why join can't really be defined sensibly for ZipList.
10:47:50 <fizbin> I think.
10:49:37 <dmj> monoidal: I think I got it for the implementation of the reader functor
10:49:38 <dmj> newtype Reader                          |.hs, interpreted )
10:49:47 <dmj> oops, ill hpaste it
10:50:09 <hpaste> dmj pasted “reader functor” at http://hpaste.org/85852
10:50:12 <[swift]> i've noticed that my program periodically jumps from using two or three threads (the number i actually created) to double that
10:50:18 <[swift]> is that the GC kicking in?
10:50:35 <[swift]> i.e., does the GC use several threads?
10:51:01 * hackagebot digestive-functors-heist 0.6.2.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.6.2.0 (JasperVanDerJeugt)
10:51:23 <c_wraith> [swift]: no, the GC doesn't.  But native calls made with the "safe" machinery are made from separate threads
10:51:29 <monoidal> dmj: that's correct. Do you see how you can simplify  \r -> f (func r)?
10:51:40 <[swift]> c_wraith: ah, i _am_ doing that!
10:51:58 <dmj> (f . func) ?
10:52:00 <[swift]> that makes sense
10:52:02 <monoidal> dmj: yes
10:52:06 <dmj> hyfr
10:52:10 <dmj> :)
10:52:36 <dmj> what's another good exercise? I think I want to do applicatives noe
10:52:40 <monoidal> dmj: it's pretty clear on types. fmap :: (a -> b) -> Reader r a -> Reader r b
10:52:55 <fizbin> dmj: Const.
10:53:01 <monoidal> now substitute Reader r x = r -> x and you get type (a -> b) -> (r -> a) -> r -> b
10:53:30 <monoidal> dmj: can you write a functor instance for data X a = X ((a -> Bool) -> Bool)?
10:53:39 <monoidal> or, instead of Bool, any type s
10:57:10 <dmj> monoidal: so make a functor instance for: data X a s = X ((a -> Bool) -> s)?
10:57:45 <dolio> data X s a = X ((a -> s) -> s) is probably what was meant.
10:58:00 <Eduard_Munteanu> Or not.
10:58:04 <monoidal> dmj: what dolio said. it can be more generally data X s t a = X ((a -> s) -> t)
10:58:05 <dolio> Poorly chosen variable name.
10:58:15 <dolio> Or, well chosen?
10:58:16 <Eduard_Munteanu> Heh.
10:59:17 <monoidal> dmj: note that this functor should be able to change "a" there, not "t".
11:00:58 <Taneb> I am foiled by the lack of either a Hashable or Ord instance for HashMap
11:01:32 <monoidal> Taneb: (Ord k, Ord v) => Ord (HashMap k v)	
11:01:45 <Taneb> monoidal, I can't see that
11:02:03 <monoidal> http://hackage.haskell.org/packages/archive/hashmap/1.0.0.2/doc/html/Data-HashMap.html
11:02:11 <Taneb> Wrong hashmap
11:02:18 <Taneb> I'm using unordered-containers
11:02:23 <monoidal> ah, sorry
11:05:34 <klrr> can i get some help, i get some type mismatch errors , i cant really figure out what's wrong since it seems to me that it should be correct http://hpaste.org/85853 (error at the buttom) any ideas?
11:06:42 <Botje> klrr: did you forget a liftIO? sure looks like it.
11:07:23 <veggies12> klrr: readFile :: FilePath -> IO String. You need to lift it
11:08:03 <klrr> but if it gets a error it will crash
11:08:07 <klrr> that's why i didnt lift it
11:08:26 <klrr> is there a way i can catch the error so the program doesnt crash while still lifting it?
11:08:47 <Botje> use `catch` or something? (never had to use that before)
11:10:04 <fizbin> Taneb: Can you add a stupid Hashable instance for your map that's good enough for your use case?
11:10:15 <monoidal> klrr: lifting does not have an effect on exceptions (like head [] or readFile from nonexisting file)
11:10:25 <klrr> monoidal: okey thanks!
11:10:32 <fizbin> "stupid" hashable here means something like "hashWithSalt = const"
11:11:30 <Taneb> fizbin, not really
11:12:28 <Palmik> Taneb: out of interest, what use case do you have for those instances?
11:12:47 <klrr> okey, i did change it now but now i get another error http://hpaste.org/85853 (error at buttom)
11:12:51 <klrr> any ideas?
11:12:54 <fizbin> Okay, then slightly less stupid: are the maps you wish were Hashable restricted to some small number of keys?
11:12:57 <Taneb> Palmik, I'm trying to use tables where one of the fields is a HashMap Text Text
11:13:36 <Taneb> So it either needs to be Ord (to go in a Map), Hashable (to go in a HashMap) or an Int (to go in an IntMap)
11:13:41 <Taneb> The last isn't going to happen
11:13:55 <Taneb> So it's either Ord or Hashable
11:14:25 <Botje> klrr: please. think.
11:14:42 <Botje> klrr: haskell is complaining that it can't match the type String against Either ....
11:14:51 <Palmik> Hmm... I would wager that 'compare' of non-bogus Ord instace would be quite costly.
11:14:55 <Botje> klrr: readFile "foo" :: IO String
11:15:28 <Botje> klrr: you still need to catch the IO error and return a Left if it throws an error.
11:16:24 <klrr> Botje: well, doesnt the code in (load) first binds result to a String, if it's not a string but an error it returns throws a error else it evaulates the result?
11:16:52 <fizbin> Taneb: If you do have some relatively small number of possible keys, you could define hashWithSalt salt myMap = hashWithSalt salt $ map (M.lookup myMap) keyList
11:16:54 <Palmik> I'm also not sure how I would use such field in real life.
11:16:59 <Botje> klrr: no. on line 214, result has type String.
11:17:08 <Botje> klrr: if an error had occurred, your program would have aborted there.
11:17:18 <Botje> klrr: you need to explicitly catch errors if you want to catch them.
11:18:00 <fizbin> Taneb: Note that keyList need not be exhaustive. If every hash has keys "a", "b", and "c" and then some other unpredictable key, it's fine to use "a", "b", and "c" in keyList.
11:18:44 <Taneb> fizbin, alas, there are loads of potential keys
11:19:20 <klrr> Botje: oh okey
11:19:33 <Botje> :t catchIO
11:19:34 <lambdabot>     Not in scope: `catchIO'
11:19:34 <lambdabot>     Perhaps you meant `catch' (imported from Prelude)
11:19:42 <Botje> gah. catch it is.
11:19:53 <klrr> :t catch
11:19:55 <lambdabot> IO a -> (IOError -> IO a) -> IO a
11:20:03 <klrr> so
11:20:14 <klrr> what will be the arguments to this function in my funciton?
11:20:25 <Botje> the first IO a is your readFile call.
11:20:43 <Botje> the second is a callback if an error occurred.
11:21:08 <klrr> what's a callback?
11:21:21 <Botje> a function that is called when something happens
11:21:35 <klrr> like thowError?
11:21:39 <Botje> yes.
11:21:42 <klrr> okey
11:21:50 <Botje> so your handler callback should look something like \err -> return (Left err)
11:22:18 <Botje> however, the a must match the one generated in your first parameter.
11:22:27 <klrr> so
11:22:34 <Botje> so a is *at least* Left IOError _something_
11:22:48 <Botje> where _something_ is the type of your Right data member.
11:23:16 <klrr> "result <- catch (liftIO $ readFile filename) (throwError $ Default)"
11:23:20 <klrr> does that work
11:24:08 <fizbin> Taneb: Are there any guarantees about the order traverseWithKey travels over a HashMap? Specifically, will it travel over two equal (In the Eq.== sense) hashmaps in the same order?
11:24:32 <fizbin> Taneb: Because if it will, then there's a straightforward Hashable implementation.
11:24:41 <Botje> klrr: depends. what's the type of throwError ?
11:24:49 <klrr> :t throwError
11:24:51 <lambdabot> MonadError e m => e -> m a
11:25:11 <Botje> where m is ?
11:25:24 <Botje> IOThrowsError, it looks like?
11:25:26 <Eduard_Munteanu> Any MonadError e :)
11:25:42 <Botje> in your code, I meant.
11:26:05 <klrr> i actually dont know how IOThrowsError work, it's some transformational type ive heard
11:26:12 <Botje> klrr: because catch is only wants IO actions, not IOThrowsError ones.
11:26:12 <Taneb> fizbin, I have no idea
11:26:42 <klrr> Botje: i think liftThrows turns it into a IOTHrowsError
11:27:37 <Botje> result <- (Right `liftM` readFile filename) `catch` (\err -> return $ Left err)
11:27:46 <Botje> then case result of ... again.
11:27:52 <klrr> oh okey
11:27:56 <Botje> your Left branch will have an IOError, your Right branch will have a String.
11:28:46 <dmj> monoidal: without using uncurry I'm unsure how to apply f to a when implementing fmap on data X s t a X (a -> s -> t)
11:28:58 <dmj> data X s t a = X (a -> s -> t)
11:29:16 <monoidal> dmj: note the parens! it's (a -> s) -> t, not a -> s -> t
11:29:27 <monoidal> dmj: the latter means a -> (s -> t)
11:30:08 <dmj> so on the LHS I have "fmap f (X func)"
11:30:13 <monoidal> yes
11:30:17 <dmj> f is a -> b
11:30:20 <monoidal> yes
11:30:24 <dmj> func is (a -> (s -> t))
11:30:27 <monoidal> no
11:30:37 <monoidal> (a -> s) -> t
11:31:03 <monoidal> It's a function that takes a function - not a function that returns a function
11:32:03 <monoidal> dmj: is this too complex? I'll show something simpler
11:32:25 <dmj> ok, but I want to revisit this to solve it
11:32:46 <monoidal> There's no functor for data X s a = X (a -> s). now, why?
11:33:00 <monoidal> we would have fmap f (X k)
11:33:11 <monoidal> where f :: a -> b and k :: a -> s
11:33:23 <dmj> yes
11:33:36 <monoidal> there is no way we can get a value of type X b here
11:33:42 <monoidal> that would be b -> s
11:33:56 <dmj> yes
11:34:33 <fizbin> Taneb: Oh, I have a solution, I think. hashWithKey salt myMap = sum $ map (hashWithKey salt) (toList myMap)
11:34:34 <dmj> isn't that the same as data X s t a = X ((a -> s) -> t)?
11:34:46 <Taneb> fizbin, I think I don't actually need it
11:34:49 <Taneb> Thank you anyway
11:34:50 <monoidal> dmj: will tell you now
11:35:13 <fizbin> Taneb: And yeah, it may seem like sort of crap, but that's what java does to make java.util.Map instances hashable.
11:35:56 <monoidal> Suppose you can change apples to cores, have a function eat :: Apple -> Core. Now, if you can change an Apple to an Orange, this does not mean you can change Orange to a Core
11:36:20 <monoidal> BUT if you could change an Orange to an Apple, then you could compose that with eating and get a function Orange -> Core
11:36:23 <monoidal> is this clear?
11:36:43 <Hafydd> I hate orange cores.
11:36:48 <fizbin> :t (.)
11:36:50 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:36:51 <dmj> yes
11:37:20 <dmj> transitivity
11:37:40 <monoidal> dmj: So, doing data X a =  X (a -> Core) is not a functor. However, it is a "contravariant functor"
11:37:58 <monoidal> dmj: which means that it has a function analogous to fmap but reversing direction
11:38:08 <monoidal> dmj: of type (a -> b) -> X b -> X a
11:38:11 <monoidal> dmj: can you write it?
11:38:45 <monoidal> dmj: essentially that example was (Orange -> Apple) -> X Apple -> X Orange
11:39:35 <dmj> (a -> b) -> f a -> f b, which is fmap, but you want (a -> b) -> f b -> f a
11:39:57 <monoidal> dmj: Yes. but for fmap, "f" is a functor, while here f is X, which is not a functor
11:40:21 <monoidal> so again we have data X a = X (a -> Core) and I'd like you to write a function of type (a -> b) -> X b -> X a
11:40:35 <monoidal> instead of Core you can put Int
11:40:50 <klrr> which module is liftIO part of?
11:41:08 <dmwit> Control.Monad.IO.Class
11:41:12 <dmwit> ?index liftIO
11:41:12 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:41:14 <klrr> thanks!
11:41:33 <dmwit> Methinks ?index's index may be a bit out of date.
11:42:13 <aCube> instance Functor X where fmap f (X g) = X $ \h -> g (h . f) -- is that instance for X right?
11:43:27 <dmwit> aCube: Looks too complicated to me.
11:43:30 <monoidal> aCube: yes
11:43:47 <monoidal> (that's the previous exercise with data X a = X ((a -> Bool) -> Bool) functor)
11:43:51 <dmwit> oh
11:46:38 <dmj> monoidal: if given, data X a = X (a -> Int), and I need to make: func :: (a -> b) -> X b -> X a, and my LHS looks like func f (X b) =  , in this case f :: (a -> b) and b is (a -> Int)
11:46:39 <monoidal> aCube: (just for information, X is also known as "Cont" monad/functor.)
11:46:57 <dmj> so both f and b do not yield a
11:47:11 <dmj> how can I return a type of X a?
11:47:32 <monoidal> dmj: The second argument to func is X b
11:47:40 <monoidal> dmj: I mean has type X b
11:47:56 <dmj> and b is a function from a -> int right?
11:47:58 <monoidal> dmj: which is b -> Int, not a -> Int
11:48:11 <monoidal> fmap: let's call it func f (X k) to avoid confusion
11:48:42 <monoidal> we have func :: (a -> b) -> X b -> X a, so the first argument f :: a -> b and the second argument X k :: X b
11:48:49 <monoidal> dmj: do you agree with this?
11:49:13 <dmj> yes, but regardless, f is (a -> b) and b is (b -> Int), neither make an a
11:49:33 <dmwit> You don't need to make an a. =)
11:49:41 <monoidal> dmj: we want to make a value of type X a
11:49:56 <dmj> yes, I wrap a in X
11:50:06 <dmj> an a must be produced no?
11:50:13 <dmwit> That is a lousy way to understand the type "X a".
11:50:22 <monochrom> a->Int looks like consume a, not produce a
11:50:27 <dmwit> And no, an a need not be produced.
11:50:30 <monoidal> dmj: No. Having having to produce a -> Int does not mean having to produce a
11:51:03 * hackagebot lgtk 0.1 - lens-based GUI with Gtk backend  http://hackage.haskell.org/package/lgtk-0.1 (PeterDivianszky)
11:51:04 <dmwit> dmwit-- for being insulting. I'm sorry, I take it back.
11:51:21 <Mortchek> shapr, how went your presentation?
11:51:26 <monoidal> dmj: note that once we have f :: a -> b and a value of type b -> Int, we can compose it to get a -> Int
11:51:27 <dmj> yes, I need to make an X (a -> int)
11:51:37 <Chousuke> dmj: can you think up a function of type a -> Int? any one function will do
11:51:53 <dmj> length
11:52:09 <Chousuke> that's [a] -> Int
11:52:14 <Chousuke> too specific
11:52:16 <dmj> oh
11:52:34 <dmwit> dmj: "I need to make an X (a -> int)" is not quite precise. You need to make an "X a"; doing so is equivalent to making an "a -> Int".
11:52:35 <otters> const 0
11:52:42 <dmj> monoidal: I see what you're saying now, I compose the two functions and wrap them in X
11:52:58 <dmwit> Or perhaps the confusion here is between type constructors and value constructors.
11:53:16 <monoidal> dmj: Exactly.
11:53:19 <monoidal> dmj: now comes a kicker
11:53:31 <monoidal> Suppose we have data Y a = Y (X (X a))
11:53:43 <monoidal> which means, a value of type Y a is equivalent to a value of type X (X a)
11:53:55 <monoidal> we have a function a -> b
11:54:06 <shapr> Mortchek: It went well. people seemed interested, and we'll be running them through tutorials on Wednesday.
11:54:13 <monochrom> it is why in tutorials I write "data X = Ctor ..." not "data X = X ..."
11:54:15 <monoidal> dmj: f :: (a -> b). What type does func f have?
11:54:27 <klrr> is cabal-dev something different from cabal?
11:55:01 <dmwit> monochrom: Yes, it is simultaneously convenient and confusing that Haskell allows this.
11:55:04 <dmwit> klrr: yes
11:55:05 <dmj> monoidal: (X (X a)) -> (X (X -> b))
11:55:15 <dmj> oops
11:55:18 <sproingie> klrr: it installs a cabal environment local to the project
11:55:37 <dmj> monoidal: (X (X a))-> (X (X b))
11:55:43 <sproingie> i've found it doesn't really work as well as i'd hoped.  virthualenv might be better
11:55:55 <monoidal> dmj: Yes (you skipped a bit, but that was my point.)
11:55:57 <Mortchek> shapr, neat. What on? Beginning Haskell?
11:56:03 * hackagebot lgtk 0.1.0.1 - lens-based GUI with Gtk backend  http://hackage.haskell.org/package/lgtk-0.1.0.1 (PeterDivianszky)
11:56:09 <monoidal> dmj: If f :: a -> b, then func f :: X b -> X a
11:56:19 <monoidal> dmj: but then func (func f) :: X (X a) -> X (X b)
11:56:34 <monoidal> dmj: do you see this?
11:56:58 <dmj> monoidal: (func . func) f
11:57:00 <monoidal> we reverse direction of arrows twice -- which is equivalent to not reversing at all.
11:57:18 <donri> there's hsenv now
11:57:30 <monoidal> dmj: what is the type of func . func?
11:57:36 <shapr> Mortchek: Today was beginning Scheme, Wednesday will be beginning Haskell. I can teach Haskell for hours without preparation, but Scheme requires more effort.
11:57:45 <shapr> Mortchek: How long have you been doing Haskell?
11:59:01 <Mortchek> shapr, hrm, some amount of time less than a year, as I recall.
11:59:26 <shapr> I've been doing Haskell for about as long as #haskell has been around :-P
11:59:55 <c_wraith> That doesn't count, you founded the channel
12:00:10 <shapr> c_wraith: mostly so I could get someone to teach me Haskell...
12:00:34 <Mortchek> Haha, well I'm glad the channel was founded. Nice community in here.
12:00:55 <Mortchek> We could probably learn something from this channel over in ##javascript.
12:01:05 <Mortchek> (I'm an op there.)
12:01:08 <parcs> hi
12:01:12 <monoidal> dmj: the point is, while X is not a functor, composing X with itself (that I named Y) is a functor
12:01:37 <shapr> Mortchek: Yah, I've been asking questions in #racket, the community there is not as active or friendly as #haskell
12:02:10 <monoidal> dmj: and that functor, since X a ~ a -> Int, is equivalent to X (X a) ~ X (a -> Int) ~ (a -> Int) -> Int. This is the previous exercise that I gave
12:02:48 <dmj> what is ~ ?
12:03:02 <monoidal> dmj: I used it to mean "equality after removing data constructors"
12:03:02 <Chousuke> What I like most about this channel is that people are often discussing things I haven't encountered in other programming languages so I get to just follow and learn new cool things.
12:03:12 <monoidal> dmj: (normally, in GHC, it means type equality.)
12:03:17 <dmj> ohhh
12:03:53 <shapr> Isn't ~ also an arrow constructor? Or is that only ~> ?
12:03:58 <shapr> I don't remember.
12:04:00 <monoidal> shapr: only the second
12:04:08 <monoidal> shapr: GHC reserves ~
12:04:12 <shapr> ah, thanks
12:05:02 <jfischoff> shapr is here!
12:05:08 <jfischoff> yay!
12:05:08 <shapr> oh hai jfischoff !
12:05:16 <shapr> jfischoff: How's life treating you?
12:05:28 <jfischoff> shapr: pretty well yourself?
12:05:41 <shapr> Enjoying being an undergrad, but looking forward to income again.
12:05:45 <monoidal> dmj: that's probably as complex as Functor class in haskell can get.
12:05:59 <shapr> I keep teaching Python, Haskell and other languages to my classmates.
12:06:00 <jfischoff> yeah I know what you mean ….
12:06:03 <luite> Mortchek: i've been able to get some good help in ##javascript a few times, it doesn't feel too unfriendly, but unfortunately people tend to assume that you're a newbie... (and then brag about their own knowledge)
12:06:04 * hackagebot haskell-coffee 0.1.0.0 - Simple CoffeeScript API  http://hackage.haskell.org/package/haskell-coffee-0.1.0.0 (KevinVanRooijen)
12:06:06 * hackagebot snaplet-coffee 0.1.0.0 -   http://hackage.haskell.org/package/snaplet-coffee-0.1.0.0 (KevinVanRooijen)
12:06:22 <luite> oh noo, haskell getting infected with coffeescript
12:06:27 <dmj> X (X a) reduces to X (a -> Int) reduces to (a -> Int) -> Int
12:06:32 <monoidal> dmj: Yes
12:06:59 <donri> hide yo hs transcompilers
12:07:39 <dmj> monoidal: yes, it's complex but good, my type intuition must become stronger. What do you recommend?
12:07:53 <Mortchek> luite, I think it got better once we banned the trolls we had previously let run free.
12:08:09 <monoidal> dmj: have you seen http://www.haskell.org/haskellwiki/Typeclassopedia ?
12:08:09 <fizbin> #haskell had trolls?
12:08:16 <Mortchek> No, ##javascript
12:08:44 <dmj> yes, but haven't gone through it all yet. Sometimes I feel as though I'm memorizing without truly understanding.
12:09:29 <monoidal> dmj: in any case, it takes a lot of time to digest it; reading it is only a small part of it, it's vital to experiment with types etc
12:09:38 <luite> Mortchek: I have to admit that i tend to ask weird questions there, usually related to writing a haskell runtime in js :)
12:10:11 <monoidal> dmj: another exercise?
12:10:18 <dmj> please
12:10:34 <Mortchek> luite, I'd be interested in seeing that if you have it up somewhere.
12:10:43 <monoidal> dmj: do you know kinds?
12:11:08 <dmj> * -> *, briefly from LYAH, in the context of type constructors
12:11:37 <monoidal> dmj: Suppose data X f = X (f Int). do you know the kind of X?
12:11:55 <dmj> * -> * since it takes a generic parameter?
12:12:03 <luite> Mortchek: uh i have some samples, http://hdiff.luite.com/gloss/ , and a github project page: https://github.com/ghcjs/ghcjs/tree/gen2-64-alth , but this is all based on GHC HEAD and not terribly easy to install
12:12:44 <monoidal> dmj: the kind of f is * -> *
12:12:51 <monoidal> but the type X takes f
12:12:53 <luite> Mortchek: a proper release is planned to coincide with GHC 7.8.1, but early adopters can probably play with it in 2 months or so
12:13:06 <dmj> monoidal: (* -> *) -> *
12:13:23 <monoidal> dmj: Yes. Can you give a value of type X k, for some k?
12:13:26 <Mortchek> luite, how complete is it?
12:14:07 <monoidal> dmj: for example, a value of type X Maybe
12:15:19 <luite> Mortchek: it supports most GHC functions already, including arrays (vector, text, repa), foreign pointers (bytestring), threading (MVar, Chan, forkIO), exceptions (async and sync), bignums (integer-gmp), 32 and 64 bit arithmetic
12:15:40 <dmj> monoidal: You mean something like Just (Just 4), which would be a Maybe (Maybe Int)
12:16:29 <luite> Mortchek: cabal support is mostly done, but needs more polishing and handling of javascript libraries
12:16:40 <luite> Mortchek: missing is STM
12:17:13 <luite> Mortchek: threading can be used to do things like AJAX calls. the thread manager suspends the (lightweight) haskell thread while the request is pending, wakes it up again when the result is in
12:17:23 <monoidal> dmj: note data X f = X (f Int), which means that a value of type X f is equivalent to f Int
12:17:37 <monoidal> dmj: (it has no relation to previous X in the functor exercise.)
12:17:42 <luite> Mortchek: and you can use the usual haskell things like System.Timeout.timeout to cancel them
12:18:12 <Mortchek> Is ajax part of IO?
12:18:34 <luite> Mortchek: it's not built in, but if you foreign import it, then it would be in IO
12:18:49 <donri> luite: Y U NO JS monad
12:18:54 <Mortchek> I seem to recall Fay, for example, has a special monad for browser-related actions, but wasn't sure why it was done that way
12:19:17 <dmj> monoidal: wouldn't I need to make X an instance of something first?
12:19:29 <luite> Mortchek: everything is browser related there, so I'm not sure what a separate monad would do for us :)
12:19:32 <monoidal> dmj: no, I'm not speaking about typeclasses or instances. It's just a plain type.
12:20:00 <monoidal> dmj: So, can you tell me a value of type X Maybe?
12:20:04 <c_wraith> Mortchek: well, mostly it would help by clearly signaling that you can't do arbitrary IO actions in a browser.
12:20:24 <donri> c_wraith: (but with ghcjs you kinda can.)
12:20:27 <c_wraith> Mortchek: how is the compiler to JS supposed to compile file IO?
12:20:37 <dmj> monoidal: X $ Just 4
12:20:40 <donri> c_wraith: ghcjs can apparently translate that to http requests
12:20:49 <Mortchek> Not every system you could conceivably run Haskell on even has a filesystem, no?
12:20:55 <monoidal> dmj: Yes. Great.
12:20:57 <luite> c_wraith: it translates file paths to urls and can read them over http
12:20:58 <dmj> is of type X Maybe
12:21:04 <Mortchek> So how would you adopt Haskell generally to such a system?
12:21:35 <monoidal> dmj: And a value of type X []? The syntax [] means lists (in general [a] is sugar for [] a)
12:21:35 <Mortchek> adapt*
12:22:05 <luite> c_wraith: but even if it didn't, IO would be appropriate I think, only the base library would be a bit more restricted
12:22:32 <dmj> X $ [4]
12:22:37 <dmj> :monoidal ^
12:22:53 <monoidal> dmj: Yes. Now, something more complicated
12:22:58 <Mortchek> Yeah, that is what I was thinking
12:23:12 <monoidal> dmj: newtype Compose f g x = Compose (f (g x)) - what's the kind of Compose?
12:23:52 <monoidal> dmj: (you might start by thinking about kinds of f,g,x)
12:25:00 <dmj> f and g are both * -> * and x would be *
12:25:09 <monoidal> dmj: Yes. So, what's the type of Compose?
12:25:34 <dmj> (* -> (* -> *)) -> *
12:25:59 <luite> Mortchek: foreign import javascript safe "jQuery.get($1).done(function(d) { $c(d); }).fail(function() { $c(null); })" jqueryGet :: JSString -> IO JSString
12:26:09 <dmj> Compose :: (* -> *) -> (* -> *) -> * -> *
12:26:15 <monoidal> dmj: Yes
12:26:20 <monoidal> dmj: So, time for an exercise
12:26:42 <luite> Mortchek: a bit simplified, but that would give you an async IO action that suspends the current thread until the reult is in, the foreign code calls the supplied continuation $c with the result
12:26:45 <monoidal> or maybe one more question
12:26:57 <monoidal> dmj: Can you give a value of type Compose [] Maybe Bool?
12:27:40 <dmj> Compose $ [Just False]
12:28:11 <monoidal> dmj: Yes. So, the exercise is:
12:28:12 <Mortchek> luite, so it takes a JS expression and substitutes in whatever arguments and evaluates it?
12:28:24 <Mortchek> Or can it be arbitrary JS code?
12:28:31 <monoidal> dmj: Can you write "instance (Functor f, Functor g) => Functor (Compose f g)"?
12:28:52 <monoidal> dmj: in other words, fmap for Compose values, assuming f and g are functors
12:29:31 <luite> Mortchek: foreign imports ahve $1, $2, $3 etc for arguments. it's parsed at compile time, so at least it's syntactically correct. code can be expressions and statements. you can declare local variables in a foreign import, they get translated to unique names that don't clash with anything else that ghcjs generates
12:30:00 <Mortchek> luite, so you can't have function declarations?
12:30:41 <luite> Mortchek: oh you can have them, but i've not yet needed them. would probably be easier to just include external .js files if you need big things, rather than inlining everything in a foreign import declaration
12:31:42 <dmj> fmap k (Compose f g) = k (f . g)
12:31:48 <Mortchek> Oh, okay. I was confused because function declarations are neither expressions nor statements. Anyway, was just curious. I definitely agree that separating out involved code is a good idea.
12:32:24 <monoidal> dmj: "Compose f g" does not exist. Compose at value-level takes exactly one argument, like "Compose $ [Just False]"
12:33:37 <luite> Mortchek: hm i just realized that functions aren't renamed to safe names. i think it might be better to disallow them
12:34:19 <trescenzi> Do all whole numbers default to Integer over Int?
12:34:31 <dmwit> Yes, the default default puts Integer before Int.
12:34:54 <trescenzi> hmm ok
12:35:05 <trescenzi> so should I just change everything in my code to Integer?
12:35:06 <monoidal> dmj: what will be the LHS of fmap and with what types?
12:35:40 <dmj> fmap k comp
12:35:54 <dmj> k :: (a -> b)
12:36:40 <luite> Mortchek: tnx :) https://github.com/ghcjs/ghcjs/issues/67
12:36:42 <monoidal> yes, and comp?
12:36:44 <dmj> comp :: (f g (x))
12:36:55 <dmwit> trescenzi: I'm not really sure how you got from here to there.
12:37:01 <dmj> f (g x)
12:37:11 <monoidal> dmj: f (g a)
12:37:18 <dmwit> trescenzi: Why does "the default default is (Integer, Double)" lead you to conclude you should use only Integer over Int?
12:37:33 <monoidal> dmj: More precisely, it's Compose f g a, which after removing the constructor is f (g a).
12:37:45 <trescenzi> dmwit: lol I was thinking maybe because it's more expected and standard.
12:38:04 <Mortchek> luite, yay, accidental help \o/
12:38:14 <trescenzi> dmwit: I just ran into the first issue with that ever though so I don't know how much of a problem it actually is
12:38:18 <dmwit> You should use the type that best fits your needs.
12:38:25 <monoidal> dmj: So we have fmap k (Compose comp), where k :: a -> b and comp :: f (g a). do you see this?
12:38:35 <dmj> monoidal: so (k . comp), k :: ( a -> b), comp (f (g a))
12:38:57 <dmj> monoidal: yes
12:38:57 <monoidal> dmj: I don't understand
12:38:59 <monoidal> ok
12:39:14 <monoidal> dmj: what type we want on RHS?
12:39:34 <dmj> on RHS we would want to compose comp with k
12:39:41 <romm> f b?
12:39:44 <monoidal> dmj: what type?
12:40:14 <trescenzi> dmwit: alright I'm just trying to make sure there isn't some standard but I see Int all over the docs so I guess it's fine.
12:40:21 <trescenzi> dmwit: thanks
12:40:44 <dmj> monoidal: since k is (a -> b) and comp returns an a can't we compose them with (k . comp)
12:40:51 <dmj> or does comp not return an a
12:41:09 <monoidal> dmj: comp is not a function. It's a value of type f (g a).
12:41:25 <monoidal> dmj: The type of fmap is (a -> b) -> Compose f g a -> Compose f g b
12:41:40 <monoidal> after removing the wrapping, it's (a -> b) -> f (g a) -> f (g b)
12:41:53 <dmj> monoidal: we'd just apply k to comp then
12:42:06 <romm> is this a lesson i should be following if i'm in the middle of the functors chapter in LYAH? :)
12:42:11 <monoidal> k has type a -> b while comp has type f (g a). we cannot apply it directly
12:43:01 <dmj> how can I apply k to comp if a is inside of f (g a)
12:43:36 <monoidal> dmj: In general, we cannot. But we don't write an instance for Functor (Compose f g). We write an instance for (Functor f, Functor g) => Functor (Compose f g), which gives us something...
12:44:00 <monoidal> romm: You might be able to follow, or scroll back to see earlier part
12:44:25 <romm> monoidal, i'm actually understanding everything except newtype, but i'm guessing what it means.
12:44:38 <monoidal> romm: for purposes of this lesson, it means the same as data
12:44:40 <romm> the fact that both f and g are functors means you can "inside map" with k
12:45:17 <monoidal> dmj: we know f and g are functors, so we have fmap available both for f and for g
12:46:14 <dmj> fmap f . fmap g == fmap (f . g) right?
12:46:28 <monoidal> dmj: Yes, but it won't help here
12:46:52 <monoidal> dmj: we need to use both f's and g's fmap
12:47:07 <edwardk> dmj: given fmap id = id, fmap f . fmap g = fmap (f . g) follows by parametricity
12:47:34 * edwardk looks up finds more context and lets folks get back to explaining
12:47:45 <romm> edwardk, what is parametricity?
12:47:48 <monoidal> dmj: suppose we have a function k :: a -> b. How do we get a value of type g a -> g b?
12:48:08 <edwardk> http://en.wikipedia.org/wiki/Parametric_polymorphism
12:48:56 <dmj> monoidal: liftM
12:49:13 <monoidal> dmj: liftM is for monads, here we have a functor only
12:49:15 <monoidal> dmj: so?
12:49:37 <dmj> fmap?
12:49:39 <monoidal> yes
12:49:57 <dmj> edwardk: thanks I will read this
12:50:25 <dmj> monoidal: isn't "k" fmap in this case?
12:50:35 <monoidal> dmj: So let l = fmap k. Suppose we have a function l :: g a -> g b. How do we get a value of type f (g a) -> f (g b)?
12:50:38 <dmj> oh, no it's not
12:50:50 <romm> edwardk, not sure how it makes the "second law" follow from that. especially since in LYAH he mentions that the authors of functors must make sure they follow the laws.
12:50:57 <edwardk> dmj: that was an answer to romm, not necessarily directly useful to you right now
12:51:00 <edwardk> dmj: fmap transformers a function from (a -> b) into one from (f a -> f b)
12:51:04 * hackagebot snaplet-coffee 0.1.0.1 - CoffeeScript for Snap, auto-compilation and pre-compilation.  http://hackage.haskell.org/package/snaplet-coffee-0.1.0.1 (KevinVanRooijen)
12:51:31 <edwardk> romm: parametricity gives you 'free theorems'. The second law follows as a consequence of the free theorem for the signature of fmap and the first law.
12:51:46 <edwardk> romm: it is a non-trivial result, but it holds
12:51:49 <monoidal> romm: it's just a pecularity, the functors you define in Haskell will automatically satisfy second law if they satisfy the first law
12:52:09 <monoidal> romm: in general category theory setting, that's not true anymore
12:52:20 <dmj> monoidal: we use fmap on g a -> g b
12:52:23 <romm> oh, okay.
12:52:48 <monoidal> dmj: Exactly. So suppose k :: a -> b again. How do we get value of type f (g a) -> f (g b) ?
12:53:17 <dmj> fmap k (f (g a))
12:53:30 <edwardk> @free fmap :: (a -> b) -> [a] -> [b]
12:53:31 <lambdabot> g . h = k . f => $map g . fmap h = fmap k . $map f
12:53:47 <monoidal> dmj: no. Above f,g,a are types, the only value we have is k (and fmaps)
12:54:24 <edwardk> you can use that to relate fmap to $map, and then use that to borrow the properties of a valid functor fmap for your custom fmap using fmap id = id
12:54:38 <edwardk> its a cute result, but its not immediately obvious
12:55:17 <Chousuke> is it correct to call a type constructor a type? :P
12:55:21 <dmj> monoidal: fmap k comp
12:55:27 <romm> edwardk, aren't you borrowing properties of something that is an "instance" of fmap in order to describe fmap?
12:55:45 <monoidal> dmj: "fmap k" has type g a -> g b". you cannot apply comp to it
12:55:59 <edwardk> romm: the properties of $map are intrinsic. its not assuming the hypothesis but the argument is more subtle than i can work out here on the fly
12:56:05 <dmj> comp is f (g a) right?
12:56:21 <romm> edwardk, it's okay. i was just curious. still interesting.
12:56:24 <monoidal> dmj: Yes
12:56:25 <Chousuke> dmj: you're confusing values with types and type constructors
12:56:52 <edwardk> romm: i think russell o'connor worked it out in a mailing list post to haskell-cafe at one point, if you want to chase after the derivation
12:57:19 <monoidal> edwardk: romm is if I remember in middle of reading functor chapter in LYAH...
12:57:22 <romm> edwardk, like i seem to end all conversation here: "let me finish LYAH first" :)
12:58:28 <Chousuke> dmj: you can think of the f and g in g (f a) -> g (f b) as "functor1" and "functor2" so you don't confuse them with functions named f and g
12:58:31 <romm> but i have to say that even after reading half the book, i still manage to get some of what you folk are saying. means it's a good book.
12:58:41 <dmj> fmap k g would work for one of them
12:58:46 <monoidal> dmj: Once again. Assume k :: a -> b. Can you tell me (1) a value of type g a -> g b and (2) a value of type f (g a) -> f (g b)?
12:59:03 <monoidal> dmj: The only thing you have is k and fmap
12:59:44 <dmj> monoidal: and comp right?
12:59:50 <dmj> fmap takes 2 params
13:00:06 <monoidal> dmj: Without comp. Give fmap only one parameter
13:00:21 <monoidal> dmj: (you know that a function taking 2 parameters is really a function returning a function?)
13:01:01 <ab9rf> a -> b -> c is the sme as a -> (b -> c)
13:01:02 <dmj> monoidal: yes, currying
13:01:22 <dmj> monoidal: which is the same thing as "partial function application" right?
13:01:34 <monoidal> dmj: it's not precisely the same, but close
13:02:04 <monoidal> dmj: here's partial application
13:02:11 <dmj> so if all I have is fmap k on the LHS, then all I can use is fmap k on the RHS
13:02:25 <monoidal> dmj: Yes. What is the type of fmap k?
13:02:31 <dmj> g a -> g b
13:02:35 <dmj> f a -> f b
13:02:56 <monoidal> dmj: It's both (that's polymorphism) but since Haskell will choose correct one, assume it is g a -> g b
13:03:24 <monoidal> dmj: Now, we have a value called "fmap k" that is of type g a -> g b. How to get something of type f (g a) -> f (g b)?
13:03:36 <dmj> fmap that
13:03:49 <dmj> so fmap k = fmap fmap k
13:03:55 <romm> fmap id ...
13:04:12 <Eduard_Munteanu> Missing some parens.
13:04:14 <monoidal> dmj: parens
13:04:39 <dmj> fmap = fmap . fmap
13:04:51 <dmj> can I do that?
13:05:05 <dmj> fmap k = (fmap . fmap) k
13:05:13 <Eduard_Munteanu> fmap . fmap = fmap fmap fmap :)
13:05:13 <Chousuke> wait, how can that make sense?
13:05:25 <dmj> Eduard_Munteanu :)
13:05:28 <dmj> I heard you like fmap
13:05:36 <monoidal> dmj: Yes, that would be correct, but unfortunately we have the extra constructors Compose so we cannot use pointfree version in full
13:05:48 <monoidal> dmj: i.e. the wrapping will make it a bit more ugly
13:05:55 <monoidal> dmj: but other than that, it's correct
13:06:05 * hackagebot hydra-print 0.1.0.2 - NCurses interface to view multiple ByteString streams in parallel.  http://hackage.haskell.org/package/hydra-print-0.1.0.2 (RyanNewton)
13:06:08 * hackagebot gsl-random 0.4.5 - Bindings the the GSL random number generation facilities.  http://hackage.haskell.org/package/gsl-random-0.4.5 (PatrickPerry)
13:06:41 <monoidal> dmj: To finish: assume f :: a -> b and k :: f (g a). What is the value of type f (g b)?
13:06:58 <Chousuke> now *I* am confused
13:07:01 <monoidal> * assume comp :: a -> b and k :: f (g a). What is the value of type f (g b)?
13:07:10 <Eduard_Munteanu> Chousuke: why?
13:07:36 <monoidal> Chousuke: about that multiple fmap? The point is that fmap = (.) for (a->) monad and fmap fmap fmap gets specialized to (.) fmap fmap = fmap . fmap
13:07:47 <Chousuke> Eduard_Munteanu: in which context do you get fmap k = (fmap . fmap) k
13:08:10 <Eduard_Munteanu> Well, that's not quite accurate generally.
13:08:10 <monoidal> Chousuke: you don't, the type constructors are missing
13:08:49 <Chousuke> okay, I just thought there's something fishy with it and got confused since no-one said anything :P
13:09:15 <dmj> monoidal: How can I find the value if all the types are generic.
13:09:30 <monoidal> dmj: I mean an expression for that type
13:09:37 <monoidal> dmj: using comp and k
13:09:45 <Eduard_Munteanu> monoidal sort of said
13:09:45 <Chousuke> dmj: the value and the expression that produces it are equivalent
13:10:03 <Chousuke> sort of
13:13:09 <dmj> monoidal: ((fmap . fmap) k) comp
13:13:19 <otters> :t fmap . fmap
13:13:21 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
13:13:36 <monoidal> dmj: Yes
13:13:51 <monoidal> dmj: Now the only thing you need is to add constructors
13:13:58 <monoidal> dmj: fmap f (Compose k) = ?
13:14:47 <dmj> fmap f (Compose k) = ((fmap . fmap) f) k
13:15:16 <monoidal> dmj: you need to cast f (g a) into Compose f g a
13:15:22 <monoidal> dmj: (and sorry for messing the names)
13:15:57 <fragamus> fac n = foldr (\x g n -> g (x*n)) id [1..n] 1
13:16:06 <fragamus> trying to understand that^^^
13:16:13 <dmj> fmap f (Compose k) = Compose $ ((fmap . fmap) f) k
13:16:50 <monoidal> dmj: Yes!
13:17:00 <monoidal> dmj: If you haven't, you can compile that with GHC
13:17:21 <monoidal> dmj: and use it like fmap (+2) (Compose [Just 3]) to get Compose [Just 5]
13:17:48 <Eduard_Munteanu> fragamus: it's a CPS variant of factorial
13:17:52 <monoidal> dmj: that would be all from me for now, I'll go make some food
13:17:55 <Eduard_Munteanu> :t foldr
13:17:56 <lambdabot> (a -> b -> b) -> b -> [a] -> b
13:18:17 <fragamus> yeah it is
13:18:20 <monoidal> dmj: alternative version is fmap f (Compose x) = Compose (fmap (fmap f) x)
13:18:48 <Eduard_Munteanu> Let b = c -> c (because of id) and expand things there.
13:18:52 <dmj> monoidal: same, thanks for the lesson, my brain needs a break. I'll be back for more and will visit the typeclassopedia in the meantime.
13:19:04 <fragamus> but the lambda function takes three args
13:19:18 <Chousuke> Functors upon functors.
13:20:40 <Chousuke> It's funny how you can take such a simple concept and then take it to extremes and break your brain if you're not careful.
13:22:33 <romm> hmm... function composition facilitated with functors. cool.
13:23:45 <edwardk> fragamus: did any of my replies get through?
13:23:46 <edwardk> i just realized i got cut off =)
13:23:48 <Chousuke> speaking of composition... Since you can compose functors like that, could you implement a Category instance for it? or would you need a dependently typed language for something like that?
13:23:53 <edwardk> 16:19] edwardk:	 fragramus: consider the type of a foldr as taking function of the form (a -> b -> b)     and a base case b. here the base case is an identity function, so b = (c -> c)    then a -> (c -> c) -> (c -> c)  is the form of the function you're using
13:23:54 <edwardk> [16:20] edwardk:	 fragramus: in that setting the fact that it can take 3 args is obvious.
13:23:54 <Eduard_Munteanu> One particular functor, (->) r
13:23:57 <fragamus> yes
13:24:03 <edwardk> [16:20] edwardk:	 and the fact that the final result is a function, and so it can accept the '1'
13:24:08 <monoidal> fragamus: I believe that's foldl implemented via foldr
13:24:12 <edwardk> > foldr (\x g n -> g (x*n)) id [a,b,c,d,e] 1
13:24:14 <lambdabot>   e * (d * (c * (b * (a * 1))))
13:24:42 <edwardk> Chousuke: you can define functor composition. it just doesm
13:24:56 <edwardk> doesn't fit well with haskell's Functor class
13:24:57 <otters> @pl \x g n -> g (x * n)
13:24:58 <lambdabot> flip (.) . (*)
13:25:10 <edwardk> Chousuke: er a category for
13:25:21 <Chousuke> it would be amusing if you could compose functors on the type level just by using .
13:25:28 <monoidal> Chousuke: composing functions is value-level. composing functors is type-level
13:25:58 <Eduard_Munteanu> You can, but you can't really make it a type synonym, you need to use a wrapper.
13:26:18 <monoidal> Chousuke: (.) is reserved but you should be able to use a different symbol
13:26:38 <monoidal> take the defn of Compose and replace it with (.$), say
13:27:03 <Eduard_Munteanu> I sometimes used   f `O` g   for that.
13:27:59 <monoidal> fragamus: in related fold matters, one of my favorite paper is http://www.cs.nott.ac.uk/~gmh/fold.pdf
13:28:33 <fragamus> edwardk: im on a quest to understand http://www.willamette.edu/~fruehr/haskell/evolution.html
13:28:49 <Eduard_Munteanu> Heh.
13:29:01 <fragamus> I want to get to understand the penultimate example in that evolution thingy
13:29:20 <Chousuke> monoidal: it just seems that many things that are useful on the value level have almost identical counterparts on the type level
13:29:26 <Nisstyre> the "Static Haskell Programmer" could use an update
13:30:05 <monoidal> Chousuke: there's omega that supports level polymorphism. other things like that: differentiation that can be done on values (AD) has a counterpart on types
13:30:28 <Eduard_Munteanu> Or you can graduate to Agda. ;)
13:30:36 <monoidal> or Agda, yes
13:31:18 <tac> oooh, Agda is the answer to a question? (What was the question asked?)
13:32:22 <Eduard_Munteanu> Agda is more like an uncomfortable truth.
13:33:00 <Eduard_Munteanu> "Can you do X?" - "Yes..." - "Yay!" - "... in Agda." - "Ohhhh"
13:33:12 <Chousuke> I wonder how many turtles you can stack before it stops making sense
13:33:35 <Eduard_Munteanu> About ω turtles. :)
13:33:45 <tac> I think once you have dependent types, you're well on your way to realizing you'll never be happy in life
13:34:21 <Trollkastel> tac: Why? :-(
13:34:32 <monoidal> Chousuke: <advertisement> http://students.mimuw.edu.pl/~kg262935/kpol/Author.pdf - scroll to page 23 to see some level polymorphism. it's a rough draft that I should update soon. </advertisement>
13:35:00 <tac> Trollkastel: It means you can see every potential corner case in every function you ever write.
13:35:07 <tac> And you can't encode it into your type system.
13:35:23 <tac> You look at "functions" like head and tail
13:35:26 <tac> :t head
13:35:27 <lambdabot> [a] -> a
13:35:33 <tac> ^ This is a lie
13:35:44 <Trollkastel> tac: Oh, that.
13:36:14 <Trollkastel> More like [a] -> {evidence that it is not empty} -> a, right?
13:36:23 <tac> yeah
13:36:34 <tac> or head : [a] -> (default : a) -> a
13:36:35 <ab9rf> head is [a] -> a, it's just not total
13:37:05 <dmwit> :t \xs x -> head (xs ++ [x])
13:37:06 <lambdabot> [a] -> a -> a
13:37:13 <dmwit> this type is not a lie
13:37:48 <Eduard_Munteanu> head :: NonEmptyList a -> a     data NonEmptyList a = End a | Cons a (NonEmptyList a)
13:38:05 <two-> i'm having a real hard time understanding the order of evaluation with haskell
13:38:06 <dmwit> type NonEmptyList a = (a, [a])
13:38:07 <Chousuke> monoidal: looks interesting
13:38:14 <dmwit> head :: NonEmptyList a -> a; head = fst
13:38:17 <dmwit> tail = snd
13:38:22 <Eduard_Munteanu> :)
13:38:44 <Eduard_Munteanu> dmwit: but head . tail gets tricky
13:38:52 <Botje> two-: it's not uncommon. have some specific example in mind?
13:38:55 <tac> two-: for the most part, it's not so important. So don't get *too* hung up on it.
13:39:07 <tac> two-: but there are times when it can be used to do some weird things
13:39:07 <dmwit> type ListOfLengthAtLeastTwo a = (a, NonEmptyList a) -- ... ;-)
13:39:18 <Eduard_Munteanu> Heh.
13:39:39 <dmwit> Before long, you've got yourself a homegrown HList.
13:40:53 <dmwit> ...or else you've migrated to Agda and brought the conversation full circle.
13:42:04 <fizbin> Is there a tool I can run locally on my pile of Haskell source to produce prettified HTML that cross-links from functions (even weird ones like +~ ) to their definitions (for stuff defined in my code) or the appropriate documentation on hackage (for stuff in lens)?
13:42:31 <Eduard_Munteanu> fizbin: haddock?
13:42:59 <Eduard_Munteanu> Or do you mean for the entire code?
13:43:42 <fizbin> I suppose. I hadn't considered that because I haven't been writing any haddock comments worth reading. And what I want is cross-links in the source code, not in the documentation.
13:44:22 <fizbin> This is supposed to make it easier for people to code review some chunk of code.
13:44:53 <dmwit> I vaguely recall somebody had a fork of haddock that did this in the "source" links.
13:45:15 <dmwit> I'm not sure whether this vague memory is helpful to you or not.
13:45:21 <dmwit> Probably not.
13:46:05 <dmwit> But perhaps you can get your editor to do this instead of using HTML as a middle-man?
13:46:19 <dmwit> There are tools on Hackage to generate ctags files for Haskell, I'm pretty sure.
13:48:01 <mercuryrising> i read somewhere that I could reuse typeclasses (like rev :: [a] -> [a] then later revLast :: rev) , but rev, revLast :: [a] -> [a] doesn't work, and rev :: revLast doesn't work, how do I reuse a typeclass?
13:48:26 <dmwit> That's a type, not a class. And rev, revLast :: [a] -> [a] does work.
13:49:08 <dmwit> > let rev, revLast :: [a] -> [a]; rev = reverse; revLast = reverse in 3
13:49:10 <lambdabot>   3
13:50:18 <dmwit> Additionally, you may be interested in type synonyms. There you would write something like type EndoList a = [a] -> [a]; rev :: EndoList a; revList :: EndoList a
13:50:27 <dmwit> s/revList/revLast/
13:50:43 <mercuryrising> ah yeah that does work, must have messed something else up. thanks!
13:51:41 <mercuryrising> ah that's cool, so if i want to do list -> list manipulations, i can just make one and reuse it
13:52:41 <dmwit> [a] -> [a] is a light enough type that it's probably not worth it, but that's an aesthetic choice that you have to make.
13:52:47 <dmwit> tl;dr "go with your heart"
13:53:12 <simpson> > length "[a] -> [a]" == length "EndoList a"
13:53:14 <lambdabot>   True
13:54:24 <Dodek> why there's no mapM_ in Data.Traversable?
13:54:29 <dmwit> > comparing length "[a] -> [a]" "EL a"
13:54:31 <lambdabot>   GT
13:56:21 <fizbin> Dodek: What would mapM_ mean? How is that different from forM_ ?
13:56:56 <fizbin> Or would you have mapM_ = flip forM_ ?
13:57:06 <monoidal> Dodek: Data.Foldable has forM_
13:57:06 <lispy> Dodek: there is a mapM_ in Data.Foldable
13:57:20 <hpc> i think forM is the more useful definition anyway
13:57:44 <hpc> it puts the predicate in a useful position for trailing do-notation
13:57:56 <hpc> forM_ list $ \elem -> do ...
13:58:14 <lispy> Traversable assumes you are working over the structure. Foldable is for reducing the structure.
13:58:28 <lispy> (that's why there is no mapM_ in Traversable)
14:00:55 <Dodek> ah, that makes sense
14:01:07 * hackagebot haskell-coffee 0.1.0.1 - Simple CoffeeScript API  http://hackage.haskell.org/package/haskell-coffee-0.1.0.1 (KevinVanRooijen)
14:01:54 <Botje> Haskell coffee: 10 times more potent than Java coffee!
14:03:04 <fizbin> Yeah, but if you don't have your cup matched exactly right, it's a compile error and you don't get any coffee at all.
14:04:31 <Botje> -or- you try to take a sip and the coffee machine starts working.
14:04:39 <Botje> because you forgot to properly force your cup
14:06:25 <ab9rf> Botje: haha
14:15:11 <Dodek> is there any way to get any kind of backtrace from exception thrown by Map.! ?
14:15:39 <shachaf> @where rts-xc
14:15:39 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
14:16:04 <Dodek> ah
14:16:19 <Dodek> how to add these compilation switches to program build via cabal?
14:18:48 <dmwit> perhaps --ghc-options="..."?
14:19:45 <Dodek> works
14:19:47 <Dodek> thanks!
14:21:51 <dmj> where do I find the data the data definition for (->) r
14:22:05 <hpc> dmj: you don't
14:22:23 <dmj> hpc: how do I make it a functor then
14:22:25 <monoidal> dmj: (->) is an abstract datatype, (->) a b = a -> b. do you want some instance?
14:22:43 <shachaf> data (->) a b 	-- Defined in `GHC.Prim'
14:22:44 <augustss> yo!
14:22:59 <shachaf> GHC.Prim is where things that aren't defined are defined. hth
14:23:09 <dmj> monoidal: can I define my own abstract datatypes or is this unique to GHC.Prim
14:23:25 <monochrom> @quote monochrom primop
14:23:26 <lambdabot> monochrom says: primop is where the turtle tower ends and the russian dolls begin!
14:23:37 <monoidal> dmj: functions are specific to the language
14:23:39 <shachaf> You can mae a data type and not export the constructors. Does that make it abstract?
14:23:48 <shachaf> (->) is a very magic type in lots of ways.
14:24:17 <shachaf> You can't replicate all the (->) magic for your own type.
14:25:51 <monoidal> dmj: as for the Functor instance, you can define it normally. It's built-in Prelude in ghc 7.6
14:26:05 <monoidal> dmj: in older versions, it's available at Control.Monad.Instances
14:27:27 <dmj> how can I hide the one that exists in Control.Monad.Instances so I can define my own?
14:27:42 <dmj> something like import Control.Monad.Instances hiding ((->))
14:27:46 <Botje> you can't. don't import that module.
14:27:58 <DMcGill> dmj is this so you can just test making your own?
14:28:08 <dmj> Botje: if I import Control.Monad will it import Instances as well?
14:28:08 <monoidal> dmj: Just open a plain file and write instance Functor ((->) a) where ...
14:28:08 <DMcGill> or do you actually want to do this for a real program?
14:28:13 <monoidal> dmj: No
14:28:18 <Botje> dmj: no. the two modules are not related.
14:28:22 <dmj> DMcGill: yes, for fun
14:28:28 <dmj> for learning
14:29:06 <DMcGill> what was that tutorial that had you writing instances in a web browser?
14:29:11 <DMcGill> I remember it being really good
14:29:39 <dmj> Botje: I'm not importing Control.Monad.Instances, but when I add a functor instance for instance Functor ((->) e) where ... it says "duplicate instance declarations""
14:30:21 <DMcGill> dmj: Control.Monad does import Functor.
14:30:27 <DMcGill> what I would do is not import Control.Monad
14:30:41 <Botje> oh, evil
14:30:56 <DMcGill> and simply write myself "class Functor f where fmap :: (a -> b) -> f a -> f b"
14:31:17 <DMcGill> that way in your .hs file you can write "instance Functor ((->) a) where ..."
14:31:21 <DMcGill> same for Maybe, List etc
14:31:26 <monoidal> dmj: if ghc 7.6, the (->) e instance is by default and you can't get rid of it to manually experiment
14:31:29 <monochrom> I'm afraid Functor is in Prelude
14:31:32 <dmj> DMcGill: it says, "duplicate instance declarations: Defined in Control.Monad.Instances"
14:31:43 <DMcGill> check out http://www.haskell.org/haskellwiki/Typeclassopedia too afterwards
14:31:45 <dmj> monoidal: ok
14:31:47 <DMcGill> dmj: call it Functor1 then
14:31:53 <monochrom> oh, nevermind, misread
14:32:22 <DMcGill> "class Functor1 where ..." and "instance Functor1 ((->_ a) where..."
14:32:29 <monochrom> is this pursuit worth your time?
14:32:56 <DMcGill> monochrom: defining them yourself is a very good way to get a handle on these things imo
14:33:36 <Botje> http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/ # if you're going to rename everything anyway.
14:33:53 <monochrom> provided it doesn't cost you going out of your way to circumvent this and that and that
14:34:06 <DMcGill> Botje: that's the link I was looking for, thanks!
14:34:23 <monoidal> personally I kind of dislike the naming in 20 exercises, it's better to call spade a spade
14:34:36 <Botje> it's the first hit for 'haskell unicorn'
14:34:45 <DMcGill> dmj: copy all of Botje's link into your text file, then one-by-one remove the "error" and replace with your own defintions
14:35:22 <DMcGill> by the way: Fluffy = Functor and Misty = Monad
14:36:20 <Mortomes> Aww, now you spoiled it
14:36:39 <DMcGill> monoidal: maybe it would have been better as Functor' and such, but the whole point is that you can't define your own functor, even using just the prelude
14:36:48 <DMcGill> s/functor/Functor
14:37:00 <monoidal> yes, that's what I mean.
14:38:04 <monochrom> I recommend Functoroid, Monadoid, Applicoid
14:39:18 <monochrom> but I guess Misty, Fluffy, Cloudy aint' so bad
14:42:38 <dmj> is this supposed to be Either?
14:42:39 <dmj> class Fluffy f where
14:42:39 <dmj>   furry :: (a -> b) -> f a -> f b
14:42:39 <dmj> -- Exercise 1
14:42:41 <dmj> -- Relative Difficulty: 1
14:42:45 <dmj> instance Fluffy [] where
14:42:48 <dmj>   furry = error "todo"
14:42:53 <dmj> -- Exercise 2
14:42:56 <dmj> -- Relative Difficulty: 1
14:42:56 <dmj> instance Fluffy Maybe where
14:43:00 <dmj>   furry = error "todo"
14:43:00 <Botje> dmj: gah! you're pasting everything!
14:43:03 <dmj> -- Exercise 3
14:43:08 <dmj> -- Relative Difficulty: 5
14:43:11 <dmj> instance Fluffy ((->) t) where
14:43:14 <dmj>   furry = error "todo"
14:43:14 <dmj> newtype EitherLeft b a = EitherLeft (Either a b)
14:43:17 <dmj> newtype EitherRight a b = EitherRight (Either a b)
14:43:20 <dmj> -- Exercise 4
14:43:21 <simpson> @where ops
14:43:21 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
14:43:22 <lambdabot> xerox
14:43:23 <dmj> -- Relative Difficulty: 5
14:43:27 <dmj> instance Fluffy (EitherLeft t) where
14:43:30 <dmj>   furry = error "todo"
14:43:31 --- mode: ChanServ set +o geekosaur
14:43:33 <dmj> -- Exercise 5
14:43:38 <dmj> -- Relative Difficulty: 5
14:43:39 --- mode: ChanServ set +o glguy
14:43:41 <dmj> instance Fluffy (EitherRight t) where
14:43:42 --- kick: dmj was kicked by geekosaur (dmj)
14:43:44 <simpson> geekosaur++
14:43:58 <simpson> geekosaur: Hm. You're not in @where ops. :c
14:44:05 --- mode: glguy set -oo glguy geekosaur
14:44:11 <Botje> the batman of channel ops.
14:44:21 <simpson> He's not the op we want, but the op that we need.
14:45:42 <geekosaur> my op state seems tobe a bit strange, I was still listed with chanserv even though I thought I wasn't an op any more... no idea, really
14:46:10 <shachaf> You changed your nick but are still using the same account.
14:46:10 <c_wraith> well, the list in the @where was never intended to be complete
14:46:17 <mercuryrising> (i'm asking a vague question as I would like a push in the right direction) what's an alternative to lookup if I know something is going to be in the list (I want to create a mapping from one thing to another)
14:46:36 <Botje> mercuryrising: using Data.Map is not an option?
14:46:55 <Botje> if not, lookup is good enough
14:46:56 <c_wraith> Why do you need an alternative to lookup?
14:47:04 <mercuryrising> im just starting, i've never seen data.map
14:47:35 <geekosaur> yes, but I used to be in @where with the old nick and that was removed...
14:47:42 <geekosaur> er, @where ops
14:48:04 <shachaf> @where oops
14:48:05 <lambdabot> I know nothing about oops.
14:48:12 <c_wraith> mercuryrising: That is, in what way is lookup not sufficient for your needs? knowing that allows a lot better recommendations
14:48:24 <mercuryrising> i know lookup is going to give me an output char, but i don't know how to make a string from lookup
14:48:45 <geekosaur> :t (:[])
14:48:46 <lambdabot> a -> [a]
14:48:57 <mercuryrising> cipher (c:cs) n = ( lookup n (LOOKUP TABLE) ) ++ cipher cs
14:48:59 <geekosaur> :t String
14:49:00 <lambdabot> Not in scope: data constructor `String'
14:49:03 <geekosaur> bah
14:49:13 <geekosaur> String is [Char]
14:49:40 <js6i> catMaybes ?
14:49:44 <monoidal> mercuryrising: you can use case lookup n table of Just x -> x, for example
14:49:53 <monoidal> mercuryrising: (also known as fromJust - a partial function)
14:50:17 <monoidal> mercuryrising: you can also attempt to use the "map" function...
15:00:29 <user317> i am trying to understand how to work around scanl blowing up.  i need to drop a bunch of elements from the returned list before i write it to a file, and from what i understand that causes a huge thunk to be created
15:01:01 <dmwit> ?hpaste
15:01:01 <lambdabot> Haskell pastebin: http://hpaste.org/
15:01:14 <dmwit> The more minimal your example space leak is, the better.
15:01:16 <monochrom> write your own drop that forces items before dropping
15:01:49 <monochrom> or use another algorithm entirely
15:03:06 <monochrom> you can, of course, alternatively write your own scanl that forces items before producing more
15:03:47 * dmwit wonders vaguely what would criterion says the current implementation of scanl is a better choice than the one that behaves like scanl and then drop 1
15:03:58 <monochrom> last but not least, write a forcer :: [a] -> [a] to force items one by one, and insert forcer between scanl and drop
15:04:00 <dmwit> -would
15:06:03 <Ontolog> Can someone point me to a github repo that serves as a good example for the way a modern Haskell project is layed out?
15:06:39 <dmwit> Ontolog: There's a wiki page about it, and a package in the Acme category on Hackage.
15:06:52 <Ontolog> cool tahnks
15:08:15 <Ontolog> dmwit: which package should i be looking at here/ http://hackage.haskell.org/packages/archive/pkg-list.html#cat:acme
15:09:28 <dmwit> ?hackage hello (Sorry, I was wrong about the category.)
15:09:28 <lambdabot> http://hackage.haskell.org/package/hello (Sorry, I was wrong about the category.)
15:11:01 <dmwit> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
15:11:41 <Ontolog> thanks
15:21:51 <Peaker> @ops
15:21:51 <Peaker> normmalno is spamming in private messages
15:21:51 <lambdabot> Maybe you meant: docs oeis pl
15:22:04 <tgeeky> Peaker:  /ignore ?
15:22:47 <elliott> hm, aren't freenode supposed to handle that thing?
15:23:31 <geekosaur> channel ops can't do anything abotu private messages. try #freenode
15:24:16 <Peaker> tgeeky, sure, I'm hoping it could help others and discourage it in the future
15:25:12 <tgeeky> Peaker: yep. the heads up and official logging into chat-log is helpful for us, but it won't help you :(
15:30:46 <Peaker> geekosaur, I meant /kick so he can't easily get a list of users
15:30:47 <Peaker> (and/or discourage behavior)
15:33:23 <Eduard_Munteanu> A kickban should do, but spam is serious enough to warrant staff attention for a k-line.
15:36:13 <hpc> what is a k-line?
15:36:14 * hackagebot vinyl 0.1.3 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.1.3 (JonSterling)
15:36:30 <geekosaur> ban at the irc server level
15:36:52 <merijn> kill line, to auto-kill incoming connections from a given IP or mask
15:37:03 <merijn> geekosaur: Aren't k-lines network level?
15:37:12 <geekosaur> effectively, on freenode
15:37:32 <geekosaur> some other networks distibguish between k-line = individual server, g-line = network ("global")
15:38:03 * hpc would be an asshole and set the firewall to never SYN-ACK
15:38:11 <Eduard_Munteanu> Yeah, k-line is better known as well.
15:38:32 <Eduard_Munteanu> hpc: or -j TARPIT
15:39:00 <hpc> i am also a fan of stackoverflow's hellban
15:39:14 <hpc> a hellbanned user can post questions and answers as usual
15:39:19 <hpc> but they are invisible to everyone but them
15:39:22 <hackedy> hacker news does slowbans too
15:39:24 <Eduard_Munteanu> Haha.
15:39:27 <cmccann> SO doesn't actually do that, does it?
15:39:32 <hackedy> the whole site gets visibly slower
15:39:36 <hpc> it does in exceptional cases
15:39:49 <Eduard_Munteanu> cmccann: why, ever wondered why nobody cares about your questions? :P
15:39:51 <hpc> http://www.codinghorror.com/blog/2011/06/suspension-ban-or-hellban.html
15:39:56 <cmccann> mostly it just has some magic semi-automated ban triggers
15:39:58 <shachaf> hi cmccann
15:40:10 <shachaf> How's the book?
15:40:11 <cmccann> where if you post a lot of shitty questions eventually it just goes "nope" and you can't post more
15:40:27 <shachaf> Hmm, I hope that happened to $CERTAIN_PERSON
15:40:39 <hpc> oh no, that link just documents the concept
15:41:23 <cmccann> shachaf: roughly 99.9% as hypothetical as last time you asked, with a 0.2% margin of error
15:42:23 <sproingie> slowban sounds like a good way to self-DOS
15:42:39 <shachaf> cmccann: I was supposed to bug you about it, wasn't I?
15:42:49 <hackedy> sproingie: good point
15:42:55 <hackedy> I wonder how it's implemented
15:43:06 <hpc> sproingie: it's only a DoS if you are already DoS-prone
15:43:12 <cmccann> shachaf: yes, though I'm not sure doing so this frequently is helpful :P
15:43:17 <sproingie> if you're keeping a request hanging
15:43:22 <elliott> well hacker news is written in arc running on mzscheme
15:43:28 <elliott> i doubt terribly much attention is paid to performance
15:43:31 <Eduard_Munteanu> cmccann: writing a book? (guessing)
15:43:33 <hpc> sproingie: the client can keep a request hanging just as easily
15:43:38 <sproingie> i suppose you could tune the js you send them to make it poll really really slow
15:43:47 <sproingie> most people wouldnt notice that
15:44:56 <cmccann> Eduard_Munteanu: more like having rough ideas about a book I want to eventually write
15:45:11 <Eduard_Munteanu> Haskell-related?
15:45:27 <cmccann> somewhat
15:45:54 <cmccann> roughly to the extent that SICP is scheme-related
15:46:09 <hpc> SICP is common lisp
15:46:18 <hpc> so i assume you will be covering ML?
15:46:32 <augur> cmccann: better to make a video series instead!
15:46:42 <augur> hpc: SICP is scheme, not common lisp..
15:47:23 <augur> cmccann: are you rob-mccann on github?
15:47:28 <hpc> (defmacro scheme () 'common-lisp)
15:47:36 <cmccann> augur: no, "isomorphism"
15:47:43 <augur> o ok
15:47:59 <cmccann> hpc: the idea is an intro to programming thing sorta along the lines of SICP, but coming from a ML-style statically typed mindset instead of lispiness
15:48:25 <augur> why not both?
15:48:29 <augur> statically typed lisp!
15:48:47 <cmccann> it's probably more likely that I'd concoct a simplified Haskell-ish language instead of using Haskell itself though
15:48:57 <Eduard_Munteanu> That'd be a crippled Lisp.
15:49:27 <hpc> fun game: take a list program and s/[()]//g
15:49:33 <hpc> then get a seasoned lisper to rebuild the program
15:49:46 <cmccann> anyway, I was about to go find dinner, bbl
15:49:46 <hpc> er, lisp program
15:49:48 <monochrom> it is going to be (: map (-> (-> 'a 'b) (-> ([] 'a) ([] 'b))))) ?
15:49:52 <Eduard_Munteanu> Mm, I wouldn't pull a Knuth on that (like he invented MMIX to teach computer stuff).
15:51:42 <Eduard_Munteanu> We had a strange course at the uni, we didn't use Verilog or stuff like that, instead some mysterious mutant APL, called AHPL, as HDL. It was sort of functional though.
15:52:30 <Eduard_Munteanu> Computer architecture stuff.
15:55:10 <nicoo> @type liftM
15:55:11 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:01:14 <augur> nicoo: liftM f mx = do x <- mx ; return (f x)
16:01:36 <augur> nicoo: liftM2 is similar:   liftM2 f mx my = do x <- mx ; y <- my ; return (f x y)
16:01:51 <eikke> use Functor and Applicative instead ;)
16:02:41 <nicoo> augur: I was just checking before making a lame pun somewhere else ;)
16:02:50 <augur> :P
16:26:16 <XexonixXexillion> does GHC work on GNU Hurd?
16:27:05 <simpson> XexonixXexillion: Probably not. Interested in porting?
16:30:11 <XexonixXexillion> If no one else has ported it, I'll give it a shot
16:32:56 <parcs> does anything work on gnu hurd?
16:33:14 <shanse> does gnu hurd work?
16:33:33 <Eduard_Munteanu> LOL
16:33:52 <Eduard_Munteanu> Sort of, it's in a pretty sad state I hear.
16:33:57 <XexonixXexillion> emacs works on gnu hurd, so it contains at least one working operating system
16:34:03 <Eduard_Munteanu> Hah.
16:34:27 <simpson> Work is "ongoing" on porting the plumbing necessary for Xorg.
16:35:13 <Eduard_Munteanu> The only promising microkernel project I've seen is HelenOS, they actually made good progress even though it's a lot younger than Hurd.
16:35:54 <Eduard_Munteanu> IIRC Hurd was stuck trying to replace their core microkernel for a while.
16:43:19 <pygmalion> I'm looking to implement multi-dimensional tic tac toe in Haskell. I need a way to store the current state of the board. I'm having trouble distinguishing between the State, StateT, and ST monads, can someone provide me with direction?
16:43:41 <elliott> well, you probably don't want ST, if that helps :)
16:43:54 <hpc> pygmalion: (State s a) is equal to (s -> (s, a))
16:43:55 <elliott> StateT is exactly like State except it lets you layer it on top of another monad
16:44:13 <hpc> ST is a slightly magical mutable state monad
16:44:14 <pygmalion> elliott: What would a use case of that be?
16:44:25 <hpc> with an interface that keeps the outside world from noticing the impurity
16:44:39 <pygmalion> hpc: Gotcha. I'd like to avoid magic as much as possible right now ;)
16:44:55 <hpc> you likely want something like (StateT Board IO)
16:45:03 <elliott> pygmalion: for instance, if you want state and nondeterminism, or state and random number generation, or state and some read-only information, or state and an accumulated value (e.g. a log), or state and IO, etc.
16:45:19 <pygmalion> ah ok, state and IO for sure.
16:46:22 <pygmalion> thanks hpc and elliott.
16:46:57 <hpc> for completeness, (StateT s m a) is equal to (s -> m (s, a))
16:47:16 * aavogt suggests just passing an (IORef Board)  around is probably simpler than StateT Board IO
16:47:25 <jmcarthur> pygmalion: ST gives you access to mutable references. State represents a state transition.
16:47:52 <dmwit> StateT and State are for immutable state whose type is known ahead of time. StateT is the transformer version of State. ST is for mutable state, and the type of the total state being tracked can be changed during the computation.
16:48:06 <jmcarthur> pygmalion: also, ST does not come in the form of a transformer, so must be at the bottom of any transformer stack it's in
16:48:43 <jmcarthur> dmwit: i don't understand the type portion of that explanation
16:48:56 <dmwit> jmcarthur: newRef changes the type of the state.
16:49:22 <jmcarthur> dmwit: oh, in some sense, i guess, sure
16:49:25 <dmwit> For example, from s to (s, a), where newRef :: ST s (STRef a).
16:49:33 <dmwit> uh
16:49:39 <dmwit> those 's's weren't supposed to be the same
16:49:56 <dmwit> from t to (t, a), where newRef :: ST s (STRef a)
16:51:04 <mercuryrising> does (x:xs) only work for splitting the first and rest of the list? does that pattern show up in other operations too?
16:51:25 <dmwit> Yes, it only works for splitting off the first and rest of the list. What is the pattern you're asking about?
16:51:44 <dmwit> Do you literally mean the pattern "x:xs"? Then what do you mean "in other operations"?
16:51:51 <dmwit> (What's the first operation it shows up in?)
16:53:07 <mercuryrising> just grabbing elements from a list passed to a function, i thought that was a useful pattern matching, and was curious if anything similar can be used in functions (say flipping it, grabbing the init then the last)
16:53:41 <dmwit> You can use view patterns, or an auxiliary case.
16:53:49 <dmwit> e.g. case reverse xs of x:xs -> ...
16:53:56 <dmwit> or f (reverse -> x:xs) = ...
16:54:36 <dmwit> ...but in general, patterns may only match against the constructors of a type.
16:54:43 <dmwit> And list's constructors are [] and (:).
16:55:43 <mercuryrising> ah okay, that makes way more sense now, i thought it was a specific pattern match syntax thing, rather than grabbing the first element then the rest of them
16:55:53 <dmwit> > let (f . g) (f -> (g -> y)) = y in (+1) . (*2) $ 5
16:55:56 <lambdabot>   12
16:56:10 <dmwit> whoops
16:56:12 <otters> what the hell?
16:56:13 <dmwit> Anyway, that's cute.
16:56:28 <dmwit> :t let (f . g) (g -> (f -> y)) = y in (.)
16:56:29 <otters> where are the backslashes?
16:56:30 <lambdabot>     Illegal view pattern:  g -> (f -> y)
16:56:30 <lambdabot>     Use -XViewPatterns to enable view patterns
16:56:30 <lambdabot>     Illegal view pattern:  f -> y
16:56:50 <dmwit> otters: don't need 'em! =D
16:56:56 <elliott> haha, that's cute
16:57:12 <otters> view patterns, even more fascinating things about haskell
16:57:22 <ab9rf> i need to learn vie
16:57:30 <ab9rf> w patterns
16:57:43 <otters> > let f (f -> 4) = True in f 3
16:57:44 <dmwit> ab9rf: View patterns are easy. The pattern (f -> p) matches when f applied to the value matches the pattern p.
16:57:45 <ab9rf> also how to type
16:57:45 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
16:57:45 <lambdabot>    arising from the literal `4...
16:58:03 <dmwit> (f -> p) matches v when f v matches p
16:58:12 <ab9rf> ah
16:58:34 <dmwit> (and binds variables in the way suggested by this match, of course)
16:59:34 <dmwit> > let f (f -> True) = True in f 3 -- infinite loop, I'm afraid
16:59:36 <lambdabot>   *Exception: stack overflow
16:59:54 <otters> oh, I see
16:59:57 <elliott> > let f ~(f -> ~True) = True in f 3
16:59:59 <lambdabot>   True
17:00:03 <otters> > let f (4 -> y) = y in f 3
17:00:05 <lambdabot>   4
17:00:11 <dmwit> hehehe
17:00:12 <elliott> > let f ~(f -> x) = True || x in f False
17:00:14 <ab9rf> heh
17:00:15 <lambdabot>   True
17:00:16 <otters> ok clearly I don't get this
17:00:48 <dmwit> I really like the (4 -> y) one. It's subtle.
17:00:59 <elliott> > let fact ~(id &&& (fact . pred) -> (n,m)) = if n == 0 then 1 else n * m in fact 10
17:01:01 <lambdabot>   3628800
17:01:14 <ab9rf> that is subtle
17:01:34 <otters> that's what I intended
17:03:43 <dmwit> elliott: Is this your own invention?
17:03:49 <elliott> I wrote that abomination, yes
17:03:59 <elliott> > let fact n@~(id &&& fact . pred >>> uncurry (*) -> m) = if n == 0 then 1 else m in fact 10
17:04:01 <lambdabot>   <hint>:1:5: Parse error in pattern: fact
17:04:06 <elliott> > let fact n@ ~(id &&& fact . pred >>> uncurry (*) -> m) = if n == 0 then 1 else m in fact 10
17:04:08 <lambdabot>   3628800
17:04:11 <dmwit> ?remember elliott
17:04:11 <lambdabot> Incorrect arguments to quote
17:04:12 <elliott> hehehehehehehe
17:04:19 <dmwit> ?remember elliott > let fact ~(id &&& (fact . pred) -> (n,m)) = if n == 0 then 1 else n * m in fact 10
17:04:20 <lambdabot> It is forever etched in my memory.
17:04:35 <otters> @quote PHP
17:04:35 <lambdabot> int-e says: PHP is a programming language like penguins are birds. And people try to make it fly.
17:04:40 <elliott> there should be a version of haskell where all you write is the part before the =
17:04:45 <elliott> and then it fills in "= result" for you.
17:06:01 <dmwit> f &&& g >>> uncurry h = liftM2 h f g
17:06:05 <monochrom> > let mono ((\x -> x > 0) -> True) = () in mono 5
17:06:08 <lambdabot>   ()
17:06:17 * hackagebot text-locale-encoding 0.1.0.1 - Encode and decode Text to/from ByteString using TextEncoding  http://hackage.haskell.org/package/text-locale-encoding-0.1.0.1 (MikhailKuddah)
17:06:30 <otters> no comprendo view patterns
17:06:44 <otters> oh, no, I do
17:07:28 <monochrom> it scares you. the fact that you understand view patterns used for recursive calls scares you. :)
17:08:49 <monochrom> also, you don't need the ~ in your fact
17:09:34 <monochrom> > let fact n@ (id &&& fact . pred >>> uncurry (*) -> m) = if n == 0 then 1 else m in fact 10
17:09:36 <lambdabot>   3628800
17:10:52 <monochrom> > let fact (id &&& (fact . pred) -> (n,m)) = if n == 0 then 1 else n * m in fact 10
17:10:54 <lambdabot>   3628800
17:11:17 * hackagebot tagged 0.6 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.6 (EdwardKmett)
17:15:27 <dmwit> > let fact n@(liftM2 (*) id (fact . pred) -> m) = if n == 0 then 1 else m in fact 10
17:15:29 <lambdabot>   3628800
17:15:36 <dmwit> oh
17:15:45 <dmwit> > let fact n@(id * (fact . pred) -> m) = if n == 0 then 1 else m in fact 10
17:15:47 <lambdabot>   3628800
17:16:00 <dmwit> > let fact n@(id * fact . pred -> m) = if n == 0 then 1 else m in fact 10
17:16:02 <lambdabot>   3628800
17:16:13 <dmwit> ho yes
17:18:53 <elliott> dmwit: huh, it works even without ~?
17:19:01 <byorgey> > let fact n@(liftA2 (,) (==0) (id * fact . pred) -> (b,m)) = if b then 1 else m in fact 10
17:19:03 <lambdabot>   3628800
17:19:11 <elliott> what have I caused.
17:19:30 <shapr> Is there already a TH+QC golf module that tries to simplify a given expression?
17:19:54 <fryguybob> > let fact 0 = 1; fact (id * fact . pred -> m) = m in fact 10
17:19:56 <lambdabot>   3628800
17:20:51 <parcs> :k Num Int => Num -- should this type's kind be * -> Constraint ?
17:20:52 <lambdabot> *
17:21:33 <otters> oh, now I get view patterns
17:21:39 <otters> because they're not on the type level
17:21:43 <parcs> :k forall a. Maybe
17:21:44 <lambdabot> * -> *
17:21:55 <byorgey> parcs: no
17:22:16 <byorgey> parcs: oh! that says Num, not Int.  weird.
17:22:19 <parcs> :k forall (a :: * -> *). Num Int => a
17:22:20 <lambdabot>     Illegal kind signature for `a'
17:22:21 <lambdabot>       Perhaps you intended to use -XKindSignatures
17:22:37 <byorgey> :k Num
17:22:39 <lambdabot> * -> Constraint
17:22:44 <byorgey> :k () => Num
17:22:45 <lambdabot> * -> Constraint
17:22:52 <byorgey> :k Num Int => Num
17:22:53 <lambdabot> *
17:23:02 <byorgey> looks like a bug to me.
17:23:13 <byorgey> though I am not sure what  Num Int => Num  is really supposed to mean.
17:23:20 <monochrom> explanation: "if n==0 then 1 else m" is strict in n, but if n=0, non-strict in m. therefore, you do not need ~ to increase non-strictness in m.
17:24:02 <elliott> monochrom: right.
17:24:02 <parcs> byorgey: yeah, me neither. but then again, ghc already accepts meaningless types like 'forall a. Maybe'
17:24:21 <monochrom> in the version that uses a tuple, it is strict in the tuple anyway (so as to extract n). therefore, ~ does not increase non-strictness in the tuple.
17:24:23 <parcs> :k Num Int => Show Char
17:24:24 <lambdabot> *
17:24:28 <dmwit> parcs: What's meaningless about forall a. Maybe?
17:24:36 <elliott> monochrom: I was thinking it would somehow force the recursion immediately.
17:24:40 <elliott> but that makes no sense, really.
17:25:01 <parcs> dmwit: i suppose it's meaningful, but it's not very useful in ghc
17:25:10 * cmccann points to http://stackoverflow.com/q/15903490/157360 
17:25:12 <parcs> :t let f :: (forall a. Maybe) Char; f = Just 'c' in f
17:25:13 <lambdabot>     Illegal polymorphic or qualified type: forall a. Maybe
17:25:14 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
17:25:14 <lambdabot>     In the type signature for `f': f :: (forall a. Maybe) Char
17:25:30 <parcs> bah, even with ImpredicativeTypes it would say "can't unify forall a. Maybe with Maybe"
17:29:07 <parcs> is Num Int => Show Char meaningful? i suppose it could be equivalent to (Num Int, Show Char)
17:29:40 <dmwit> Not quite equivalent.
17:29:49 <dmwit> If there's no Num Int instance, the former doesn't guarantee a Show Char instance.
17:30:29 <monochrom> I don't know whether this => is logical implication
17:30:47 <dmwit> GHC compiles => to a function, no?
17:30:53 <dmwit> So, pretty nearly exactly logical implication.
17:31:10 <monochrom> however, if it is, then http://www.youtube.com/watch?v=qNBzwwLiOUc is helpful
17:31:12 <mikeplus64> > let f :: Num a => Show a => a; f = show 0 in f
17:31:14 <lambdabot>   Could not deduce (a1 ~ [GHC.Types.Char])
17:31:14 <lambdabot>  from the context (GHC.Num.Num a, ...
17:31:21 <mikeplus64> > let f :: Num a => Show a => a; f = 0 in f
17:31:23 <lambdabot>   0
17:31:38 <mikeplus64> dmwit: what does that mean? how can => be a function?
17:31:41 <shachaf> dmwit: What GHC compiles things to and what things mean are not the same.
17:31:48 <monochrom> reportedly, only 10% of the population passes the Wason test
17:32:00 <dmwit> shachaf: Since the code in question is valid only in GHC anyway, who cares?
17:32:01 <parcs> mikeplus64: that's Num a => (Show a => a)
17:32:20 <mikeplus64> parcs: i know. just demonstrating
17:32:39 <dmwit> mikeplus64: c => t is a function that takes a dictionary (or many dictionaries) witnessing the satisfaction of the constraint c and returns a value of type t.
17:32:44 <dmwit> (in GHC)
17:33:06 <mikeplus64> oh, ok
17:35:09 <dmwit> monochrom: I probably failed, but I can't check because I can't remember how to turn off the HTML5 beta (and consequently don't have annotations).
17:36:52 <monochrom> I don't know how to turn that on or off
17:37:19 <dmwit> But I think the answer is the cards marked 5, 8, and green.
17:37:23 <dmwit> Do I lose?
17:37:39 <monochrom> skip the 5 card, and you're good
17:37:40 <Eduard_Munteanu> http://www.youtube.com/html5
17:37:49 <dmwit> What if the 5 has an 8 on the other side?
17:37:55 <Eduard_Munteanu> You can set it on that page.
17:38:10 <monochrom> oh haha. assume the other side is a colour, not a number.
17:38:46 <dmwit> Oh, that *is* a stated assumption, and I just missed it.
17:38:59 <dmwit> I thought I was being so clever. =(
17:39:05 <monochrom> effectively, you win
17:39:20 <supersym> cls
17:40:03 <mikeplus64> i don't understand why turning an odd card and getting blue invalidates the proposition, the proposition isn't that *only* even numbered cards have blue on their opposite face
17:40:04 <dmwit> I guess I'm going to claim I win anyway because having a colour one one side does not preclude having an 8 on that same side. ;-)
17:40:21 <monochrom> heh
17:40:29 <dmwit> mikeplus64: That doesn't invalidate the claim. But turning an odd card and seeing an even number *would* invalidate the claim.
17:40:37 <dmwit> ...provided the odd card isn't also blue =)
17:41:04 <mikeplus64> the 'correct' answer is 8 and green
17:41:08 <shachaf> Having a color and a number on the same side would be very odd indeed.
17:41:15 <monochrom> hahaha
17:41:41 <nbouscal> what if it's a 5 with a diagonal colored piece that makes it an eight
17:41:52 <dmwit> This test is flawed!
17:41:54 <dmwit> I demand a rematch.
17:42:08 <monochrom> Wadler says: how to add laziness to a strict language, without even being odd
17:47:49 <tgeeky> Wadler is a wizard. You can never be sure they aren't twisting the tendrils of your neurons in even the simplest of sentences.
17:52:23 <Eduard_Munteanu> I sometimes think he's an avant-garde fashion designer.
17:52:29 <Ontolog_> argh!
17:52:53 <Eduard_Munteanu> @arrgh
17:52:53 <lambdabot> Yo ho ho, and a bottle of rum!
17:52:55 <Ontolog_> Actually having trouble because Data.Set *relies* on Ord for computing the difference between two sets
17:53:35 <Eduard_Munteanu> Ontolog_: and what are you storing in the Set?
17:53:39 <dmwit> How are you constructing a non-singleton Set in the first place without an Ord instance?
17:53:42 <Ontolog_> Eduard_Munteanu: vertices :(
17:53:50 <Eduard_Munteanu> Ok.
17:53:55 <Ontolog_> dmwit: i have defined Ord for Edges
17:53:59 <Ontolog_> Eduard_Munteanu: actually edges not vertices
17:54:07 <dmwit> So... you defined it but lied?
17:54:11 <dmwit> Shame on you.
17:54:14 <Ontolog_> lol
17:54:15 <Eduard_Munteanu> :)
17:54:23 <Ontolog_> well i don't know of a good way to implement LT or GT
17:54:34 <dmwit> Ontolog_: :i Edge
17:54:39 <Ontolog_> i'm just deferring to compare (x1,y1) (x2,y2)
17:54:48 <dmwit> That seems perfectly cromulent to me.
17:54:52 <byorgey> sounds fine
17:55:02 <Eduard_Munteanu> You only need something "good enough".
17:55:04 <Ontolog_> ok ill paste the shits
17:55:24 <Ontolog_> apparently its not good enough since it confuses Set's difference algorithm (some shit about 'hedge')
17:55:27 <Eduard_Munteanu> It doesn't even need to have a mathematical sense.
17:55:41 <dmwit> Do edges have more than just an x and a y in them?
17:56:15 <Eduard_Munteanu> Well, you want a consistent Ord, no stuff like x < y and y < x.
17:56:29 <hpaste> Ontolog pasted “mata-mofo gentleman” at http://hpaste.org/85873
17:56:54 <Ontolog_> so yeah my edges are defined in there
17:57:09 <Ontolog_> however with a big enough set of edges, Set.difference gets confused
17:57:19 <Eduard_Munteanu> You could just derive Eq for Edge.
17:57:29 <monochrom> you could simply "data Edge = ... deriving (Show, Ord, Eq)"
17:57:46 <dmwit> Oh, these are "unordered" edges?
17:58:12 <dmwit> Why not use fromEdge in compare as well?
17:58:15 <Eduard_Munteanu> Hm, yes, I guess Ord works too.
17:58:20 <dmwit> compare x y = compare (fromEdge x) (fromEdge y)?
17:59:00 <dmwit> Ignore monochrom and Eduard_Munteanu, they are not reading carefully.
17:59:07 <monochrom> I agree
17:59:23 <shachaf> Ignore me, also. I have your worst interests in mind.
18:00:04 <monochrom> I have a cunning plan!
18:00:05 <Eduard_Munteanu> Unlike monochrom, I don't readily spot my mistake. :)
18:00:37 <dmwit> I have a guess about what monochrom's cunning plan is!
18:00:48 <dmwit> edge x y = Edge (min x y) (max x y)
18:00:49 <monochrom> work on directed graphs instead. then the programming is so much simpler. you can now "deriving (Show, Ord, Eq)" and it will be right
18:01:35 <dmwit> My guess was wrong.
18:01:38 <Eduard_Munteanu> Oh! You're saying the derived Eq doesn't work for undirected graphs.
18:01:43 <monochrom> Eduard_Munteanu: the program is intended for undirected graphs. therefore, "Edge 3 4 == Edge 4 3" wants to be true.
18:01:49 <Eduard_Munteanu> Yeah.
18:01:53 <monochrom> yeah, similarly deriving Ord
18:02:06 <dmwit> But I kind of like my guess anyway.
18:02:16 <Ontolog_> becdause
18:02:18 <Ontolog_> because
18:02:24 <Ontolog_> fromEdge to compare was also giving bs results
18:03:02 <monochrom> Captain Kirk would have approved my plan. change the problem to suit the existing solution!
18:03:21 <dmwit> Your problem description sucks.
18:04:18 <Ontolog_> sorry im testing it again
18:04:19 <Ontolog_> hold up bro
18:04:58 <monochrom> I guess edge x y = Edge (min x y) (max x y) is a really good idea
18:05:35 <monochrom> "I have a cunning plan!" is not meant for really good ideas :)
18:06:18 <tgeeky> I can help, though. You should use SignedMultisets instead: http://hackage.haskell.org/packages/archive/signed-multiset/0.3.0.1/doc/html/Data-SignedMultiset.html. This will solve none of your current problems, and possibly add new ones!
18:06:18 <no-n[10]> expressions are evaluated when we ask for the result. if we ask twice are they evaluated twice or are they "recalled"?
18:07:22 <monochrom> depends on how much aliasing you set up.
18:07:22 <tgeeky> no-n[10]: I think the answer is "recalled" under "normal lazy evaluation". I'm not sure why what you're describing isn't "memoization" but distinguish the two shortly:
18:07:35 <Eduard_Munteanu> no-n[10]: each computation makes up a thunk. The first evaluation goes there and fills it up, then it's reused.
18:08:02 <monochrom> "1+1", "1+1": two evaluations. "let x=1+1", "x", "x", one evaluation.
18:08:14 <Eduard_Munteanu> Stuff like    let a = f x in (a, a)   doesn't result in f x being evaluated twice.
18:08:52 <monochrom> also, "x=1+1", "y=x", "x", "y": one evaluation
18:08:54 <no-n[10]> ahh :)
18:09:19 <nbouscal> is that any different from a promise?
18:09:27 <nbouscal> or are they the same idea
18:09:30 <Ontolog> omg everything magically works now, i could have swore there was a problem before with using fromEdge to compare but it looks good now
18:09:30 <Ontolog> thanks
18:10:04 <Ontolog> btw, doesn't implementing Ord imply an implementation of Eq? Why are both required?
18:10:08 <monochrom> compiler optimizations may increase aliasing, even when you don't want it. example: "sin 10 + sin 10", compiler may turn it into "let tmp = sin 10 in tmp + tmp"
18:10:52 <monochrom> Ord is a subclass of Eq
18:10:55 <no-n[10]> mmmm
18:11:33 <Ontolog> so if Ord is a subclass of Eq, and I implement Ord, I won't get complaints about not implementing Eq?
18:12:02 <geekosaur> no, it means you must implement Eq before you can implement Ord
18:12:03 <monochrom> when you or compiler increase aliasing, you spend less time but more memory. sometimes this is what you want. sometimes not.
18:12:16 <geekosaur> you cannot implement the Eq part *within* Ord
18:12:53 <shachaf> You can also implement Eq after.
18:12:56 <shachaf> GHC doesn't care.
18:13:34 <nbouscal> why can't GHC implement Eq for itself from your `compare`?
18:13:51 <nbouscal> (i'm a compiler noob so that might be a bad question)
18:13:52 <Ontolog> lol yeah that's essentially what im asking
18:14:28 <monochrom> because it awaits you to submit a proposal for that
18:14:39 <nbouscal> i was wondering the same thing earlier when reading the argument for not constraining Monad to Applicative, the argument was that you'd have to write instances for both, which seemed silly
18:14:53 <cmccann> it kinda is silly
18:15:07 <hpaste> allenj12 pasted “list comprehension help” at http://hpaste.org/85874
18:15:15 <geekosaur> there are ongoing arguments about that...
18:15:42 <cmccann> the way dependencies between type classes work is not one of the nicer parts of the language design, to my mind
18:15:42 <allenj12> can someone tell me the best way to tackle that problem
18:15:58 <nbouscal> can we rebuild it? better, stronger than before?
18:16:02 <nbouscal> :P
18:16:25 <geekosaur> the question is how to do so without breaking existing programs
18:16:34 <nbouscal> yeah. that's always the question. i hate that question.
18:16:46 <monochrom> I like declaring things in reverse. line 1 is "instance VClass W where", line 5 is "class VClass a where", line 15 is "data W = ..."
18:16:54 <nbouscal> hahaha
18:17:07 <nbouscal> that sounds like it makes for very easy-to-read code
18:17:13 <cmccann> monochrom: you should submit a proposal to allow putting the "module" bit at the bottom of the file
18:17:21 <cmccann> for completeness
18:17:24 <monochrom> it's too bad I can't make "import Control.Monad" my punchline
18:17:28 <elliott> there is no satisfactory way of doing the Applicative => Monad change without breaking existing programs, really
18:17:36 <ipetrovilya> What is the better Linux Distribution for Haskell: Archlinux or Gentoo? Or maybe you can say a word for some other like nixos -- you are welcome as well.
18:17:43 <ipetrovilya> *-the
18:17:44 <elliott> it's a shame people are still chasing that goal
18:17:59 <nbouscal> Well the goal to chase I think is making the language the best it can be
18:18:11 <cmccann> elliott: I agree, let's just break everything
18:18:13 <nbouscal> I understand why support for old programs tends to top the priority list, but I've never been able to convince myself that it should
18:18:15 <cmccann> stability is overrated
18:18:36 <Ontolog> there's a page that recommends using HUnit only for the impure parts of your code, why is that?
18:18:43 <elliott> cmccann: it works for the Num change.
18:18:45 <elliott> *worked
18:18:50 <cmccann> how about switching : and :: while we're at it to match everyone else?
18:18:58 <cmccann> that would break a few things but pf
18:19:01 <nbouscal> ipetrovilya: Better in what way? Any distro will provide an environment that you can code in. The differences tend to be matters of preference
18:19:23 <shachaf> cmsmcq: Well, *not* changing it would also break some things. Like my heart.
18:19:23 <cmccann> Ontolog: because quickcheck is usually better for pure functions
18:19:23 <elliott> it is already a bug in a library to not declare an Applicative instance for a Monad; a bug that actually affects users
18:19:28 <elliott> (imagine if parsec didn't)
18:19:34 <allenj12> can anyone tell me the best way to tackle the list comprehension problem i posted above?
18:19:39 <shachaf> s/smcq/ccann/
18:20:12 <hpaste> monochrom annotated “list comprehension help” with “list comprehension help attempt” at http://hpaste.org/85874#a85875
18:20:26 <monochrom> allenj12: I think you need to do it that way
18:20:27 <shachaf> That is not a list comprehension problem.
18:20:32 <shachaf> It is a list comprehension solution.
18:20:37 <monochrom> haha
18:20:37 <shachaf> Or an attempt at one, anyway.
18:20:48 <nbouscal> it is a list comprehension with a problem
18:21:13 <cmccann> we need list incomprehensions
18:21:16 <cmccann> for comonads
18:21:29 <allenj12> yes lol and i will try that thank you
18:21:29 <ipetrovilya> nbouscal: Well, maybe some package managers are better than the others in way they resolve dependencies.
18:21:37 <nbouscal> comonads are already incomprehensions to me
18:21:42 <cmccann> nbouscal: exactly!
18:22:20 <nbouscal> ipetrovilya: for Haskell-specific packages you'll be using cabal regardless of distro. As for the distro package manager, yes some are better than others, but like I said it's preference whether that's your priority or something else is your priority
18:23:29 <ipetrovilya> nbouscal: thaks, I'll stick with arch then
18:23:47 <nbouscal> Anyways it does irk me that every language accumulates a whole slate of issues that go unfixed because the fixes would break programs
18:24:03 <nbouscal> The programs should be being maintained anyway, and in many cases the fixes would not be all that labor-intensive
18:24:20 <hpaste> allenj12 revised “list comprehension help attempt”: “Edit attempt” at http://hpaste.org/85875
18:24:33 <edwardk> Most Haskell users are used to comonad incomprehensions already.
18:24:42 <allenj12> hmm still does not seem to like it
18:24:52 <monochrom> oh, forgot ++
18:25:00 <shachaf> Commandment K: All identity proofs are equal, but some are more equal than others.
18:25:02 <monochrom> [atom1] ++ " " ++ [operator] ++ " " ++ [atom2]
18:25:27 <monochrom> you need 4 ++. you only had 3.
18:25:40 <nbouscal> hehe i was puzzling over that for a second, " " is a function? lol
18:25:47 <allenj12> o lol i missed that to
18:25:55 <allenj12> :)
18:26:12 <cmccann> nbouscal: really, the haskell world tends to be more liberal with breaking changes than most other language communities
18:26:16 <allenj12> It Works thank you
18:26:17 <elliott> cmccann: hmm, what would a comonad incomprehension even look like?
18:26:21 <elliott> i mean for real.
18:26:22 <monochrom> wait until you turn on "overloaded strings". then " " may be a function
18:26:31 <nbouscal> cmccann: glad to hear it.
18:26:39 <cmccann> elliott: for real meaning you don't want me to say "incomprehensible"?
18:26:41 <edwardk> elliott: there was a codo sugar proposal from dominic orchard
18:26:45 <monochrom> this is why I hate all those blasted overloaded things.
18:26:51 <allenj12> lol
18:26:53 <edwardk> that is actually a viable proposal
18:26:55 <elliott> cmccann: yes exactly.
18:27:01 <elliott> edwardk: doesn't that one require ComonadApply or something?
18:27:03 <cmccann> elliott: well I'm out of ideas then
18:27:04 <edwardk> yes
18:27:10 <elliott> that one was a bit weird.
18:27:17 <elliott> but sometimes list comprehension form can make things easier.
18:27:23 <elliott> since you have the implicit "pure"/"return" for the monadic form
18:27:23 <edwardk> its the right proposal though in many ways
18:27:27 <elliott> which also means it generalises to applicative more nicely
18:27:31 <edwardk> i was originally against it but he won me over
18:27:49 <elliott> edwardk: i take it you don't think much of Tekmo's proposed sugar? (which i found weird)
18:28:01 <cmccann> well according to DNS edwardk is in charge of comonads
18:28:04 <edwardk> i can't say that i've seen it
18:28:07 <cmccann> so I saw we go with what he says
18:28:17 <cmccann> s/saw/say/
18:28:22 <monochrom> good plan
18:28:37 <darinmorrison> edwardk: is that the one at dorchard/codo-notation?
18:28:45 <edwardk> darinmorrison: yes
18:28:48 <shachaf> cmccann: Only for commercial use.
18:28:51 <ab9rf> i can read this now
18:28:53 <darinmorrison> hmm, interesting. Hadn't seen that before
18:28:55 <edwardk> i tweaked it to use the comonad package a while back
18:29:03 <edwardk> darinmorrison: there is a paper as well
18:29:19 <darinmorrison> ah, nice
18:30:06 <elliott> edwardk: i was thinking of http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html, after "Syntactic sugar for comonads"
18:31:49 <edwardk> elliott: yeah that approach is sadly too naive. its very close to what i used to argue would be sufficient actually
18:32:42 <edwardk> you only need the comonadzip/comonadapply when you go to do the very things that the proposal there and the one i used to champion can't do.
18:33:10 <edwardk> so its strictly more powerful than gabriel's, dan piponi's and my original proposals, which are all equivalent.
18:51:32 <haasn> ‘exampleHistory’ <- hehe
18:51:40 <mememe> it seems that catch used in IO exception handling is depreciated..
18:58:29 <shachaf> The name "catch" is not deprecated.
18:58:34 <shachaf> Only what it referred to.
19:01:00 <monochrom> use Control.Exception's catch for a greater catch
19:17:10 <mememe> :t lines
19:17:12 <lambdabot> String -> [String]
19:18:52 <hpaste> “mitra seo” pasted “Cipto Junaedy” at http://hpaste.org/85877
19:21:35 <hpaste> ipetrovilya pasted “hykill” at http://hpaste.org/85878
19:22:49 <ipetrovilya> I'm on Debian and cabal intstall fails to instal hakyll -- is it an ordinary thing? Should I go with a debian package instead of cabal?
19:23:18 <tgeeky> ipetrovilya: you'll have to be more specific, really. paste an error or some output
19:23:32 <ipetrovilya> > ipetrovilya pasted “hykill” at http://hpaste.org/85878
19:23:32 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
19:24:37 <Cale> It's unclear why it's selecting crypto-pubkey-types-0.2.0 there, hmm
19:25:19 <ipetrovilya> Cale: can I elaborate it for you somehow?
19:26:08 <Cale> Well, I'll see if I can build the package myself
19:26:22 * hackagebot hscrtmpl 1.0 - Haskell shell script template  http://hackage.haskell.org/package/hscrtmpl-1.0 (DinoMorelli)
19:26:34 <tgeeky> I still haven't figure out why hakyll wants it at all.
19:27:11 <Cale> ipetrovilya: run "ghc-pkg check" and see if it reports anything wrong
19:27:54 * tgeeky tried using reverse deps to figure out where it could be imported from, and can't.
19:28:41 <ipetrovilya> Cale: `ghc-pkg check` returns nothing. I also couldn't  execute `cabal install caball`, it fails at the end.
19:29:08 <Cale> tgeeky: well, we know it's certificate and crypto-pubkey
19:29:16 <Cale> (at least, directly)
19:29:51 <monochrom> my "cabal install --dry-run hakyll" is pretty successful from a pretty clean environment. however, it selects crypto-pubkey 0.1.2, not 0.1.3
19:31:55 <Cale> ipetrovilya: Oh, also, you shouldn't generally run cabal as root, unless you really need to make the package available to other users on the machine
19:32:00 <tgeeky> Cale: I don't know which of hakyll's deps uses any of those, is what I mean.
19:32:52 <Cale> ipetrovilya: Installing into your home directory is generally much more convenient if you end up messing up your packages somehow.
19:33:11 <ipetrovilya> Cale: thanks for this clarification
19:34:13 <monochrom> actually, "sudo cabal install" = "sudo cabal install --user". this means /root. which means, on the bright side, it won't mess up the global registry anyway
19:34:37 <tgeeky> it might not see any of your config files though
19:34:54 <monochrom> that's right, it reads /root/.cabal/config
19:35:16 <monochrom> and it writes /root/.ghc
19:36:01 <tgeeky> Cale: so, I went to: http://packdeps.haskellers.com/feed?needle=crypto-pubkey&deep=on
19:36:08 <tgeeky> and I don't see how that gets us back to hakyll
19:36:15 <tgeeky> this site might just be outdated, though
19:36:55 <mikeplus64> > (-2 `mod` 7, (-2) `mod` 7)
19:36:57 <lambdabot>   (-2,5)
19:37:05 <mikeplus64> pesky unary -
19:37:10 <monochrom> there is some conditional dependencies at work. "cabal install --dry-run hakyll --constraint='crypto-pubkey == 0.1.3'" leads to excluding crypto-pubkey altogether
19:37:39 <monochrom> at this stage -v3 is the least worst information source
19:38:27 <Cale> mikeplus64: It's just that `mod` has relatively high precedence
19:38:46 <monochrom> crypto-pubkey (dependency of tls-extra-0.6.1)
19:38:47 <Cale> (It has the same precedence as multiplication and division do)
19:38:55 <Raynes> This: http://hackage.haskell.org/trac/hackage/wiki/SandboxedBuildsAndIsolatedEnvironments claims that a 'cabal-dev ghci'-like command isn't going to be supported in the new cabal sandbox stuff. Is that just a 'for now' sort of thing? It's kind of important.
19:39:19 <mikeplus64> i kind of expect - to have the same precedence as normal functions
19:39:33 <Cale> That'd be way too high
19:39:36 <monochrom> trying: tls-extra-0.6.1:+fastaes
19:39:46 <mikeplus64> Cale: why's that?
19:39:47 <monochrom> I think +fastaes is key
19:40:23 <shachaf> monochrom: Hopefully the key is a runtime parameter and not part of the package name or flags.
19:40:23 <Cale> Because it's part of the additive structure of numbers, so it belongs somewhere close to addition and subtraction
19:40:49 <monochrom> eh? I don't know what you mean
19:41:10 <hpaste> ipetrovilya pasted “Hakyll, crypto-pubkey and packages” at http://hpaste.org/85879
19:41:18 <Cale> mikeplus64: You wouldn't want -x^2 to mean (-x)^2
19:41:25 <monochrom> "key" is an English word here. clearly, fastaes is a flag, and + means turning on the flag
19:41:42 <shachaf> Yes.
19:41:42 <mikeplus64> Cale: yeah, i guess
19:41:59 <shachaf> It was an attempt at getting arkeet to hate me.
19:43:39 <whileone> is there a way to use websockets over https? i'm not seeing anything obvious in Network.WebSockets.connect
19:43:47 <arkeet> shachaf: it didn't work very well.
19:45:13 <monochrom> fastaes has nothing to do with it
19:45:51 <monochrom> if I force crypto-pubkey 0.1.3, then cabal just falls back to an older tls-extra that doesn't ask for crypto-pubkey
19:46:46 <Cale> It builds successfully here, and yeah, I end up with crypto-pubkey-0.1.2 just like monochrom
19:46:51 <mememe> :t read
19:46:53 <lambdabot> Read a => String -> a
19:46:58 <mememe> @hoogle read
19:46:58 <lambdabot> Prelude class Read a
19:46:59 <lambdabot> Text.Read class Read a
19:46:59 <lambdabot> Prelude read :: Read a => String -> a
19:47:06 <monochrom> anyway, it is easiest to start with a clean environment. every installed package is a risk.
19:47:16 <monochrom> perhaps s/risk/liability/
19:47:35 <Cale> To that effect, it might be worth trying cabal-dev.
19:50:23 <mememe> :t print
19:50:25 <lambdabot> Show a => a -> IO ()
19:50:32 <mememe> @hoogle print
19:50:32 <lambdabot> Prelude print :: Show a => a -> IO ()
19:50:32 <lambdabot> System.IO print :: Show a => a -> IO ()
19:50:32 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
19:50:34 <parcs> :k forall a. (a :: Bool)
19:50:36 <lambdabot>     Illegal kind signature for `a'
19:50:36 <lambdabot>       Perhaps you intended to use -XKindSignatures
19:50:50 <mememe> i soo love lambdabot..
19:51:00 <parcs> :k forall (a :: Bool). a
19:51:01 <lambdabot>     Illegal kind signature for `a'
19:51:02 <lambdabot>       Perhaps you intended to use -XKindSignatures
19:51:07 <mememe> thou its annoying to u peeps
19:51:24 <monochrom> if you're concerned, /msg works
19:51:25 <Cale> ipetrovilya: You could try cabal install cabal-dev and then go into your project directory and type cabal-dev -s ./cabal-dev install hakyll
19:52:11 <Cale> ipetrovilya: and if that works, you can use cabal-dev to build your project using that sandbox
19:53:02 <ipetrovilya> Cale: unfortunately: `cabal-dev-0.9.2 failed during the configure step. The exception was: ExitFailure 1`
19:53:22 <Cale> is that the only message?
19:53:23 <monochrom> this is a rabbit hole
19:54:34 <hpaste> ipetrovilya pasted “cabal-dev” at http://hpaste.org/85880
19:54:39 <ipetrovilya> Cale: here you are
19:55:32 <monochrom> 9?
19:57:34 <ipetrovilya> monochrom: hmm, [ http://blog.inventic.eu/2012/07/linux-c-linker-ld-terminated-with-signal-9/ ]
19:58:12 <monochrom> ok, it is out of memory then
19:58:15 <ipetrovilya> The machine is host1free's vps with Debian.
19:58:34 <monochrom> GHC pushes ld to use a lot of memory
20:01:07 <Cale> I've often wondered why it is that the linker can be so memory intensive. Its job certainly doesn't sound like it should require a lot of space, but I don't know the details all that well.
20:01:08 <whileone> i guess the answer is websockets used to support https, but it was removed about 5 months ago. oh well.
20:01:14 <allenj12> can anyone help me figure out Data.random.extras work with there data types
20:01:20 <hpaste> allenj12 pasted “Rvar to String” at http://hpaste.org/85881
20:02:39 <Cale> allenj12: Well, your first problem is that there are no functions of the type signature you gave which will actually do anything much like selecting a random element.
20:03:02 <ipetrovilya> Cale: The reason ld is using so much memory is because of a feature called "split objs"... -->  [ http://stackoverflow.com/questions/3144722/how-can-i-build-cabal-install-on-eeepc-701-ubuntu-netbook-remix-1-6-lucid ]
20:03:28 <Cale> allenj12: The issue being that if a function has type  String -> String -> [String]  and you give it the same two String parameters, it must always give the same [String] result.
20:03:31 <allenj12> hmmm ok so what are my alternative options
20:03:45 <allenj12> i see
20:05:23 <Cale> So, the library you're using that declares the RVar monad also defines a function  runRVar :: RandomSource m s => RVar a -> s -> m a
20:05:40 <Cale> http://hackage.haskell.org/packages/archive/random-fu/0.2.3.0/doc/html/Data-Random-RVar.html#v:runRVar -- which is here
20:05:57 <Cale> If we click the RandomSource class in that signature, we get a list of instances
20:06:53 <Ralith> Cale: oh man I have been looking for that lib
20:07:33 <sw2wolf> @ty callCC
20:07:35 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
20:07:46 <allenj12> hmmmm alright
20:08:02 <Cale> There are a bunch of instances there which can be used to select various different PRNGs or real RNGs
20:08:38 <Cale> Let's see, what would the easiest thing be...
20:09:17 <Cale> oh, the first one, since IO is an instance of MonadRandom
20:09:37 <Cale> runRVar :: RVar a -> StdRandom -> IO a
20:09:52 <allenj12> k
20:10:19 <nsxt> #ror
20:11:03 <Cale> allenj12: So you'll write  runRVar (your RVar computation) StdRandom, and that's an IO action you can run to choose one randomly
20:11:19 <allenj12> Cale: ahhh k ty
20:11:40 <allenj12> Cale: i was just about to ask for an example
20:16:23 * hackagebot stemmer 0.4 - Haskell bindings to the Snowball stemming library.  http://hackage.haskell.org/package/stemmer-0.4 (BenGamari)
20:24:15 <allenj12> what do i import to get StdRandom
20:24:40 <dmwit> ?index StdGen
20:24:40 <lambdabot> System.Random
20:25:04 <dmwit> Oh, you're talking about rvar.
20:25:12 <alang> :t Refl
20:25:14 <lambdabot> Not in scope: data constructor `Refl'
20:25:39 <edeast> Would it be possible to use the diagrams packag, somehow to show the abstract syntax tree?  It took a nice picture, in Pierce for me to understand lambda's associate to the right, and application to the left.
20:25:58 <allenj12> i got this  Module `System.Random' does not export `StdRandom'
20:26:12 <dmwit> It's in Data.Random.
20:26:16 <dmwit> http://hackage.haskell.org/packages/archive/random-fu/0.2.4.0/doc/html/Data-Random.html#t:StdRandom
20:27:08 <dmwit> edeast: Sure. You'll have to write some code, of course.
20:27:16 <edeast> ya that what I figured
20:27:25 <dmwit> ?faq Can diagrams be used to visualize abstract syntax trees?
20:27:26 <lambdabot> The answer is: Yes! Haskell can do that.
20:27:45 <edeast> ok brb, ...
20:28:03 <allenj12> kk ty
20:28:12 <dmwit> alang: Dunno for sure, but the most common definition for Refl is data Eq a b where Refl :: Eq a a
20:29:07 <alang> dmwit: thanks
20:29:22 <dmwit> ...so take your pick of type signatures: Refl :: Eq a a, or Refl :: a ~ b => Eq a b
20:29:25 <dmwit> =)
20:31:17 <augur> whats the gadget that is used for correct parenthesization?
20:31:36 <mikeplus64> i think ghc-mod and hlint do it
20:33:12 <scooty-puff> is it possible to import documentation on a particular top-level definition of another module (preferable another package) to another top-level definition (without just copy/paste)?
20:33:48 <dmwit> If you export a symbol that you imported from elsewhere, its documentation will remain intact.
20:33:51 <dmwit> Other than that, no.
20:34:23 <scooty-puff> perhaps just a 'See also "module#label"' will do well enought
20:34:25 <dmwit> (...we're talking about haddock here, right?)
20:34:26 <scooty-puff> *enough
20:34:29 <scooty-puff> o, yes
20:34:51 <dmwit> You can: -- | See also 'Module.foo'.
20:46:23 * hackagebot conjugateGradient 1.3 - Sparse matrix linear-equation solver  http://hackage.haskell.org/package/conjugateGradient-1.3 (LeventErkok)
21:18:11 <derek_c> Hello! I'm writing a web crawler that needs to download webpages and save them to local disk.  Meanwhile, being a crawler, it needs to find the hyperlinks on each page and download those linked pages as well.
21:18:23 <derek_c> I have two questions:
21:18:28 <derek_c> 1. Firstly, should I use Network.HTTP or Network.HTTP.Conduit?  They both provide functions (simpleHTTP) to download pages.  I want to choose the more performant one, of course.
21:18:38 <derek_c> 2. Secondly, I notice that if I use String as the intermediate data type, the webpage would be corrupted due to encoding issues.  To get around that I need to use ByteString.  Specifically, I want to use Data.ByteString.Lazy, since it doesn't have to be loaded into memory, but can be streamed lazily into a file.  The problem, however, is that TagSoup does not work with Lazy bytestrings.  Therefore, I wonder if there is a way to som
21:18:49 <tgeeky> derek_c: you were cut off after "if there is a way to som"
21:19:06 <derek_c> Therefore, I wonder if  there is a way to somehow make TagSoup work with Lazy  bytestring, or another way to find hyperlinks in a lazy  bytestring?
21:19:36 <davean> "performant" isn't what you're looking for.
21:20:27 <derek_c> davean: huh?
21:20:38 <davean> and lazy bytestrings don't easily just "stream" into files, not from IO sources.
21:20:59 <derek_c> davean: I'm not sure what you meant. Could you please explain?
21:21:47 <davean> which part?
21:22:11 <pharaun> is there any good pointer toward equation solvers?
21:22:50 <derek_c> davean: why did you say performant isn't what I'm looking for?
21:25:26 <davean> Because performance is directly counter to the rest of your requirements
21:26:40 <davean> do you want to be able to work inside bounded memory or do you not care? you come down on care apparently
21:26:44 <davean> for example
21:27:47 <davean> So, you want to get a webpage and process it into links?
21:27:52 <davean> or do you want to save it into a file?
21:27:58 <derek_c> Memory isn't my primary concern, but I do want to make my program as light-weight as possible
21:28:01 <derek_c> I want both
21:28:11 <derek_c> I need to save it to a file
21:28:16 <derek_c> and also save all the linked pages
21:28:25 <derek_c> all the pages it links to
21:28:32 <startling> derek_c, luckily CPUs weigh hardly anything these days
21:28:46 <derek_c> yeah true
21:29:04 <derek_c> I'm just wondering what's the best solution for my case
21:29:14 <davean> So, you could do something like combine http-conduit with http://hackage.haskell.org/package/tagstream-conduit and also stream it to a file for example
21:31:43 <derek_c> davean: thank you for pointing me to tagstream-conduit
21:31:47 <derek_c> looks pretty interesting
21:32:16 <derek_c> I'm pretty new to Haskell, so I'm trying to imagine how I would use it with Http-Conduit
21:32:33 <davean> derek_c: you send the output of the second into the first
21:34:08 <derek_c> davean: hmm are you talking about the "Text.HTML.TagStream.ByteString.decode" method?
21:34:10 <davean> what http-conduit returns is a request, and in the case you want, that contains instructions an iterating function for getting more pieces of the page
21:34:28 <haasn> CPUs are surprisingly heavy for their small size
21:34:38 <davean> No, more like tokenStreamBS
21:34:50 <haasn> very dense
21:36:09 <derek_c> davean: what http-conduit returns is a lazy bytestring isn't it?
21:36:19 <derek_c> I mean, I could make it return a lazy bytestring
21:36:21 <derek_c> or a strict one
21:36:34 <davean> Or a ...
21:36:38 <davean> it is parameratized
21:36:41 <davean> you're missing an option
21:36:47 <derek_c> what?
21:37:30 <davean> What else do you see under "perform a request"?
21:37:50 <davean> It is the 3rd thing there
21:38:23 <davean> http :: (MonadResource m, MonadBaseControl IO m) => Request m -> Manager -> m (Response (ResumableSource m ByteString))
21:38:57 <derek_c> sorry I'm kinda lost... which page are you talking about?
21:40:31 <davean> http://hackage.haskell.org/packages/archive/http-conduit/1.9.3/doc/html/Network-HTTP-Conduit.html
21:42:17 <davean> I assume you had the http-conduit documentation open
21:42:31 <andrewsw> davean: oh that's neat... conduits.
21:42:47 <derek_c> davean: yeah right I'm reading the docs now
21:45:21 <derek_c> looks kinda complex
21:46:02 <davean> well, what do you want? Simple? Performant? Constant memory usage? you need to specify your problem better
21:46:21 <andrewsw> davean: so, can he create a sink that writes IO and also goes on to further process the stream?
21:46:55 <davean> andrewsw: yes
21:47:11 <derek_c> andrewsw: that's exactly what I was thinking
21:47:32 <derek_c> but my limited Haskell knowledge doesn't quite allow me to see exactly how I would do it
21:47:56 <derek_c> that certainly sounds like the most performant solution though
21:48:33 <davean> It works somwhat similarly to shell pipes
21:48:43 <andrewsw> davean: yeah, neat.
21:49:43 <derek_c> so I was looking at the example given here:
21:49:49 <derek_c> http://www.yesodweb.com/book/http-conduit
21:50:31 <derek_c> so I was wondering if I could write a function called sinkFileAndProcessLink that replaces the sinkFile in that example
21:50:45 <derek_c> and my function would write the web page to a file, and also extracts links in the mean time
21:50:56 <derek_c> and then deal with those links recursively
21:51:19 <derek_c> davean: does this approach sound right to you?
21:51:36 <davean> Yes, you can do that, but it probably would usually look more like
21:52:08 <davean> ... $$+ proccessFile $$ sinkFile "file.html"
21:52:12 <davean> or somesuch
21:52:40 <derek_c> oh right, I actually couldn't find docs about what those symbols mean
21:52:51 <derek_c> $$+-, $$+, etc.
21:52:51 <davean> look in conduit
21:53:14 <davean> They are basicly variants of | from shell, sorta, not really
21:53:33 <derek_c> are they defined in the HTTP.conduit source code?
21:53:45 <derek_c> or are they like actual Haskell operators?
21:53:57 <davean> No, in conduit
21:53:58 <andrewsw> http://hackage.haskell.org/packages/archive/conduit/1.0.4.2/doc/html/src/Data-Conduit.html#%24%24%2B
21:54:10 <davean> Haskell doesn't have many actual "operators"
21:54:25 <davean> actually, does it have any? /me is too tired to think that hard right now
21:54:46 <haasn> in Haskell you can define your own operators
21:54:52 <haasn> arbitrarily many
21:54:52 <derek_c> andrewsw: thank you for the link!
21:54:58 <derek_c> oh I see
21:55:14 <davean> haasn: yah, but are there any that are built in? Not at the type level?
21:55:25 <andrewsw> I admit it seems non intuitive how one would "split" the stream.
21:55:33 <davean> andrewsw: no need to here
21:55:37 <davean> thoguh you can ...
21:55:38 <haasn> to name a few, (+), (-), (*), (/), (++) are built in, among others
21:55:40 <andrewsw> but I see zipSinks
21:55:49 <davean> haasn: They're in prelude, not built in
21:55:54 <haasn> same thing
21:56:03 <davean> No? Somepeople don't use the standard prelude
21:56:05 <haasn> prelude is built in
21:56:08 <davean> oh, - is built in
21:56:12 <davean> In its unary form
21:56:17 <haasn> that's not an operator afaik
21:56:50 <andrewsw> davean: ... $$+ processLinks $$ sinkFile "foo.html" seems like it would leave the file empty, there must be some way to pass the data through.
21:57:04 * andrewsw installs conduit.
21:57:11 <davean> andrewsw: yes, that *is* passing the data through
21:57:22 <haasn> davean: yes, prefix negation is an operator
21:57:24 <davean> though, I did leave the details of processlinks missing
21:57:25 <andrewsw> hmmm... okay. I'll have to experiment w/ it.
21:57:48 <davean> I just defined it as passing it through, which is easy enough.
21:58:30 <andrewsw> davean: oh! yield?
21:58:38 <davean> basicly, yah
21:58:43 <davean> you just reyield it
21:58:46 <andrewsw> yeah, okay. I see.
21:58:51 <davean> though one would probably use something that does the plumbing for you
21:59:13 <andrewsw> and you get a conduit, so perhaps =$ is in order instead of $$+?
21:59:25 <andrewsw> (last ? not part of operator...)
21:59:26 <davean> $$+ is for resumable
21:59:38 <davean> but uh,
21:59:53 <davean> ... $$+ proccessFile =$ sinkFile "file.html"
21:59:53 <davean> ?
22:00:00 <davean> I don't remember the operators off the top of my head
22:00:06 <davean> attach the proccessFile to the sink :)
22:00:06 <andrewsw> okay. right. ... $= processLinks $$+ sinkFile ...
22:00:22 <davean> yah, plenty of ways to do it
22:00:25 <andrewsw> hey neat and now it's passed my bedtime.
22:00:28 <haasn> davean: the ‘Prelude’ mechanism is just a means for controlling visibility of prelude functions, the functions themselves are effectively built into the language - some of them don't even have a definition, and the compiler is free to implement and optimize calls into prelude in any way it wishes
22:00:33 <davean> The exact code seemed uninteresting to me
22:00:33 <andrewsw> derek_c: sorry to hijack your question.
22:00:39 <haasn> s/mechanism/module/
22:00:41 <andrewsw> davean: sure, and thanks.
22:01:39 <derek_c> andrewsw: haha np
22:01:44 <derek_c> andrewsw: thanks for help
22:01:46 <davean> haasn: except you don't need to use them, you can choose nto to import prelude
22:01:52 <derek_c> davean: thank you very much for help
22:01:59 <davean> derek_c: of course
22:02:06 * elliott thinks prelude is just like any other module
22:02:15 <davean> right, there isn't anything special about prelude
22:02:17 <elliott> other modules can contain primitives too
22:02:19 <elliott> like Data.IORef
22:02:33 <elliott> davean: well, there is: it's imported by default and some syntactic sugar refers to it even if you explicitly do import Prelude ()
22:02:41 <derek_c> davean: what would be the arguments of processFile?
22:02:42 <cmccann> unary negation, (>>), (>>=), and a few other operators are sort of "built in"
22:02:44 <elliott> but I don't think what's inside is inherently more primitive.
22:02:54 <haasn> cmccann: (:)
22:02:58 <derek_c> I mean.. what type would it be?
22:03:03 <cmccann> but that's not unique to operators, there are functions that are similarly "built in"
22:03:08 <davean> derek_c: possily a place to shove the links it gets?
22:03:29 <davean> derek_c: oh, type!
22:03:39 <davean> derek_c: Conduit ByteString m ByteString  I'd think
22:04:18 <cmccann> haasn: that too, yes
22:04:27 <derek_c> hmm ok I need sometime to consume this
22:04:38 <davean> derek_c: thta would be the file you're saving it into
22:05:35 <derek_c> davean: huh? you mean the file would have the type "Conduit ByteString m ByteString"?
22:06:09 <davean> no, the sinkFile has type Sink ByteString m () or something
22:10:00 <derek_c> davean: OK I will spend more time looking into it.  Thanks for help again!
22:12:04 <zinnia> Is there a repl that treates typed lines the same as lines read from a file? hugs and ghci both reject `x=3'.
22:12:24 <Eduard_Munteanu> zinnia: you can do 'let x = 3'
22:12:43 <zinnia> I know, but the dissimilarity still bothers me.
22:12:52 <cmccann> think of the GHCi prompt as a do block
22:13:07 <cmccann> but yeah it's a bit annoying
22:13:19 <derek_c> right. IO in top level will be executed
22:13:38 <zinnia> As a newbie, I use the repl to check my syntax. If it doesn't behave the same, it can't serve that purpose.
22:13:48 <cmccann> the thing is, you can rebind identifiers at the prompt
22:13:57 <cmccann> so it will never work like lines from a file
22:14:00 <zinnia> also it's philosophically impure.
22:14:14 <derek_c> zinnia: like cmccann said, think of it as a do block
22:14:31 <cmccann> there are a variety of reasons why GHCi can't actually behave the same as the toplevel of a loaded file
22:15:05 <cmccann> the way it works is annoying but I'm not sure there's an alternative that doesn't have just as many problems
22:15:07 <zinnia> I understand the theory of what it does (though not all of why). I was just hoping there was an alternate version that worked the other way.
22:15:25 <davean> zinnia: ghc ;)
22:15:41 <cmccann> I usually just type stuff in a file and then :r
22:15:42 <zinnia> just seems like most other languages I've seen have congruent repls.
22:15:43 <davean> zinnia: send ghc a pipe instead of a file ;)
22:16:00 <zinnia> hmm
22:16:09 <cmccann> zinnia: most other languages with REPLs don't do H-M type inference
22:16:14 <tgeeky> most other languages you use are probably just interpreted, not compiled
22:16:23 <nbouscal> is SML's type inference not H-M?
22:16:58 * cmccann isn't sure how ML dialects handle it
22:17:13 <nbouscal> i was under the impression it was, but am unsure, i'll go look
22:17:21 <cmccann> my brief experiences with the F# interactive mode were inevitably frustrating for reasons I don't recall right now
22:17:22 <tgeeky> zinnia: even worse (perhaps), GHC has only allowed toplevel declerations since 7.4
22:17:23 <davean> zinnia: I can't think of any compiled langauges that do off the top of my head. Like C doesn't for example (though there have been attempts) C++ just ... can't
22:17:35 <davean> hum, I guess asm does
22:18:09 <cmccann> nbouscal: yes, H-M inference is a feature of ML-style languages
22:18:36 <nbouscal> SML's REPL is a pretty typical REPL iirc
22:19:02 <cmccann> then again, most MLs also have rather limited type systems compared to Haskell
22:19:11 <nbouscal> true, SML is a pretty small language
22:19:37 <DigitalKiwi> the s is for small?!
22:19:42 <nbouscal> don't think so
22:19:48 <DigitalKiwi> darn
22:20:11 <nbouscal> davean: 'compiled language' is pretty ambiguous
22:20:21 <nbouscal> many languages can be (and are) both compiled and interpreted
22:20:27 <nbouscal> any lisp, for starters
22:21:00 <DigitalKiwi> aren't most interpreted languages compiled to bytecode anyway?
22:21:38 <simpson> Depends.
22:21:45 <cmccann> the distinction between interpreted and compiled is kinda hazy these days
22:21:52 <simpson> I recommend not considering execution strategy to be part of any language proper.
22:21:57 <cmccann> with the prevalence of fancy VMs and JITing
22:22:10 <nbouscal> agreed. compiling/interpreting is not a language feature, it's an implementation detail.
22:22:40 <cmccann> by the strictest definitions I suppose stuff like Java would be considered interpreted, which is a bit silly
22:23:25 <davean> cmccann: How is that silly? Java acts very interprited
22:23:47 <davean> I think Java falls very far and clearly into interprited territory
22:24:07 <cmccann> whether a language is considered interpreted by most people seems to boil down to whether it includes an "eval" function that interprets and executes a string at runtime
22:24:16 <cmccann> davean: perhaps, but I don't think most people see it that way
22:24:18 <sw2wolf> ASAIK, Java has n REPL
22:24:24 <sw2wolf> s/n/no
22:25:55 <davean> sw2wolf: there area java repls
22:25:57 <nbouscal> i know Scala has a good REPL, no idea about Java itself though
22:26:07 <simpson> sw2wolf: There are several Java REPLs.
22:26:36 <simpson> Beanshell or something like that.
22:26:43 <davean> cmccann: try reasoning about java performance and tell me it is anything but interprited :)
22:26:58 <davean> i mean, modulo a few special CPUs
22:26:59 <simpson> davean: Mu. There is no correlation.
22:27:07 <davean> simpson: ?
22:27:15 <cmccann> it's quite possible to make a compiled language as slow as you want
22:27:16 <simpson> davean: "Compiled" does not mean "native code"!
22:27:18 <nbouscal> Yeah I definitely wouldn't use performance as a metric for calling a language interpreted/compiled.
22:27:33 <nbouscal> Compiled means "translated into another language."
22:27:40 <davean> it isn't performance
22:27:40 <nbouscal> Interpreted means "evaluated"
22:27:48 <davean> it is the performance model
22:27:53 <nbouscal> Performance is a totally orthogonal issue
22:27:57 <davean> I said nothing about how performant it was
22:28:14 <simpson> davean: http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
22:28:32 <simpson> There is no such thing as a performance model.
22:28:56 <simpson> Or, rather, "performance model" could be an obtuse way to describe algorithmic complexity.
22:28:58 <cmccann> consider something like Haskell, which has a fairly complicated runtime to initialize at startup that it depends on for lots of stuff
22:29:16 <davean> and I agree not to use performance ... I never tried to
22:29:51 <davean> simpson: what do you ever mean ...
22:30:16 <davean> simpson: there is a mathematical model that converts instructions and their arguements into clock cycles.
22:30:29 <davean> thoguh things like cache complicate it
22:30:44 <simpson> davean: But choice of language cannot immediately map onto that.
22:31:08 <cmccann> not to mention that modern CPUs aren't exactly executing the instructions you give them directly
22:31:12 <davean> ... asm
22:31:28 <davean> cmccann: So? It is entirely definated, that is entirely irrelivent
22:31:37 <simpson> It's not entirely defined.
22:31:38 <mauke> davean: you've never written an asm interpreter?
22:31:47 <simpson> The fun of memory accesses is never-ending.
22:31:51 <davean> mauke: I have, then it isn't running on that CPU
22:31:58 <davean> the performance model takes into account where it is running
22:32:02 <simpson> davean: But it's not the CPU. It's the CPU and north bridge.
22:32:09 <simpson> And south bridge. And hard drives. And memory.
22:32:13 <mauke> davean: the only thing that runs is machine code
22:32:16 <mauke> not some programming language
22:32:31 <davean> mauke: yes?
22:32:47 <simpson> davean: You must beard up and forget about the microoptimizations of the assembly world.
22:32:49 <simpson> :3
22:33:46 <davean> simpson: I see no reason at all to
22:34:48 <startling> davean, are you writing a compiler?
22:35:02 <davean> startling: rarely
22:35:29 <startling> davean: then <simpson> davean: You must beard up and forget about the microoptimizations of the assembly world.
22:35:51 <davean> They're rather useful to me at times still though
22:35:52 <simpson> davean: Do you think that your IRC client is written in assembly? >:3
22:36:05 <davean> simpson: no, mine is writen in a combination of C, perl, and python
22:36:11 <simpson> davean: As is mine.
22:36:16 <DigitalKiwi> irssi?
22:36:25 <simpson> None of which are languages that directly contain any assembly.
22:36:37 <davean> simpson: Ok? So?
22:36:44 <davean> simpson: how is that relivent?
22:36:48 <davean> My assembly contains assembly
22:36:56 <DigitalKiwi> though irssi having python would be new to me :/
22:37:06 <davean> DigitalKiwi: it is an option
22:37:11 <davean> DigitalKiwi: it isn't well supported
22:37:23 <DigitalKiwi> ahh
22:37:52 <davean> simpson: So, why does my IRC client have to do with my asm?
22:40:32 <simpson> davean: Just saying. Your IRC client author was able to forget about assembly.
22:40:44 <davean> So?
22:41:05 <simpson> You must do the same!
22:41:14 <davean> ... how does that make any sense at all?
22:41:32 <nbouscal> because IRC client authors are our source of guidance in this world
22:41:32 <davean> If I was writing an IRC client I wouldn't use any assembly or any assembly knowlege
22:42:22 <davean> I have never actually writen an IRC client
22:43:02 <davean> I've been considering writing an IRC server ...
22:43:23 <arkeet> the IRC protocol is kind of a mess.
22:43:46 <davean> It really, really is
22:43:56 <DigitalKiwi> xmpp is the future!
22:44:02 <davean> especially between servers
22:46:45 <davean> Haha, actually, an IRC client might :(
22:47:05 * davean has bad memories of debugging calling convention issues in FFI libraries
22:47:50 <arkeet> might what?
22:48:10 <arkeet> oh, aseembly
22:48:13 <davean> arkeet: writing an IRC client might involve assembly knowlege, though only as an edge case
22:48:25 <arkeet> maybe if you try :p
22:49:28 <davean> Yah, just thinking back to a FFI library bug I had to debug once and how irssi and others like it have a lot of FFI going around.
22:51:29 <Jesin> https://news.ycombinator.com/item?id=2069810
23:02:57 <flazz> why would cabal install not install a certain dep (happy) ?
23:03:26 <sopvop> xmpp, hah! STOMP is the future
23:03:49 <davean> flazz: build dep, not direct dep?
23:04:14 <sopvop> flazz happy is a program, cabal only tracks installed libraries IIRC
23:04:46 <sw2wolf> @package happy
23:04:46 <lambdabot> http://hackage.haskell.org/package/happy
23:04:47 <davean> http://hackage.haskell.org/trac/hackage/ticket/227
23:05:26 <sw2wolf> lambdabot: it is better to give us the package description
23:06:28 * hackagebot web-fpco 0.1.1.0 - Wrappers for web frameworks to ease usage with the FP Complete environment.  http://hackage.haskell.org/package/web-fpco-0.1.1.0 (MichaelSnoyman)
23:06:33 <sw2wolf> @hoogle happy
23:06:34 <lambdabot> package happy
23:06:34 <lambdabot> package happy-meta
23:07:49 <Heffalump> flazz: you can manually install it, it just doesn't follow the dependency automatically unfortunately
23:07:56 <Heffalump> manually install with cabal install that is
23:19:34 <flazz> no big deal, thanks for the info
23:21:11 <flebron_> What would you guys recommend for learning to use mutable vectors? I'll try porting a simple C++ dynamic programming to use Haskell. The C++ code is at http://hpaste.org/85882 .
23:22:01 <flebron_> (In the meantime I'm reading http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial )
