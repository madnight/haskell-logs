00:00:49 <aleator> Ralith: If this is a problem, you'd need to dig the internals of the related libraries.
00:00:56 <Ralith> well that's a shame
00:02:04 <Ralith> I'll see if I can just do the png encoding directly from repa
00:03:20 <mitchell> does anyone know much about stratification in parsing?
00:37:22 <Zeev> any example online of a haskell gui application (calculator, etc?
00:37:33 <Zeev> non web
00:39:07 <donri> Zeev: http://www.haskell.org/haskellwiki/Reactive-banana/Examples
00:39:08 <dimka> Zeev: take a look http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html
00:44:13 <Zeev> thanks will take a look
00:57:25 * hackagebot language-lua 0.2.0 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.2.0 (OmerAgacan)
01:25:38 <akegalj> how to send simple email with haskell?
01:29:03 <quchen> akegalj: There seem to be a couple of packages on Hackage. http://new-hackage.haskell.org/packages/find?name=email
01:29:24 <quchen> mime-email seems to be somewhat maintained.
01:29:47 <akegalj> quchen: thnx, i'll check that
01:32:26 * hackagebot bytestring-show 0.3.5.5 - Efficient conversion of values into readable byte strings.  http://hackage.haskell.org/package/bytestring-show-0.3.5.5 (DanDoel)
01:32:43 <Ralith> Enigmagic: do you expect to be able to get to the LLVM bindings soon? I'd like to have at least the low-hanging updates/fixes there in the release.
01:36:30 <mitchell> Hi need help with my "Tiny" parser.  So far i have implemented a parser for most of the expressions apart from identifiers.  Here is my code so far and the grammar for command/expression are at the top
01:36:33 <hpaste> mitchell pasted “tiny parser” at http://hpaste.org/86804
01:39:30 <mauke_tmp> that grammar looks ambiguous
01:40:14 <mauke_tmp> not 0 + 1
01:41:12 <mitchell> mauke_tmp: Any ideas how I would approach implementing the parser for identifiers?  I am pretty stuck
01:42:35 <mauke_tmp> what is Parsing?
01:44:46 <mitchell> um analysing a string and putting it into components
01:45:02 <mitchell> definition is something like that
01:45:03 <arkeet> no, what is the Parsing module?
01:45:07 <mitchell> oh
01:45:10 <mitchell> ill pastei t
01:45:52 <hpaste> mitchell pasted “tiny parser” at http://hpaste.org/86805
01:46:44 <mauke_tmp> that has 'ident' right there
01:47:47 <mitchell> hmmm
01:47:52 <mitchell> so would i do something like this
01:48:03 <mitchell> do e1 <- expr
01:48:17 <mitchell> return (identifier e1)
01:48:18 <mitchell> or something
01:48:42 <mauke_tmp> are you just guessing random stuff?
01:48:49 <mauke_tmp> is this homework?
01:48:53 <mitchell> homework yeah
01:48:56 <mitchell> wasn't guessing lol
01:49:01 <mitchell> thought you bound it to a variable
01:49:09 <mitchell> then parse it as an identifier
01:49:11 <mitchell> and return it
01:49:15 <mitchell> im guessing that is wrong lol
01:49:18 <mauke_tmp> what is "it" here?
01:49:50 <mitchell> errr maybe I am off track
01:49:57 <mitchell> lemme look again
01:53:28 <applicative> "cabal-install is evil (and so is cabal-dev) (self.haskell)" -- but I had been hoping to read something uplifting today ...
01:56:02 <hpaste> “Anonymous Coward” pasted “weird output” at http://hpaste.org/86806
01:56:07 <quchen> applicative: I sometimes love Cabal. Uplifting enough? :-)
01:56:35 <hpaste> “Anonymous Coward” revised “weird output”: “weird output” at http://hpaste.org/86806
01:56:52 <applicative> yes quchen , thank you.
01:56:55 <mauke_tmp> > foldl (\x y -> show x ++ ", " ++ show y) "" [1,2,3]
01:56:56 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\", 1\\\", 2\", 3"
01:57:09 <mauke_tmp> > foldl (\x y -> x ++ ", " ++ show y) "" [1,2,3]
01:57:10 <lambdabot>   ", 1, 2, 3"
01:57:13 <quchen> applicative: Are you one of the Cabal maintainers, or was that just a general comment?
01:57:54 <oihk> mauke_tmp: aah, that makes sense :)
01:58:12 <quchen> You're probably looking for
01:58:13 <quchen> > intercalate ", " . map show $ [1,2,3]
01:58:15 <applicative> its just a general comment. I'm  cabal maintainer defender.
01:58:15 <lambdabot>   "1, 2, 3"
01:58:35 <applicative> excellent work oihk
01:58:39 <mauke_tmp> > show (show "")
01:58:40 <lambdabot>   "\"\\\"\\\"\""
01:58:58 <mauke_tmp> > fix show
01:58:59 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
01:59:10 <quchen> applicative: Well, let's say it's cool we have something like Cabal, although it certainly isn't the ideal solution.
01:59:27 <arkeet> > fix (printf "a %s b")
01:59:29 <lambdabot>   Ambiguous type variable `a0' in the constraints:
01:59:29 <lambdabot>    (GHC.Show.Show a0)
01:59:29 <lambdabot>     ...
01:59:33 <arkeet> > fix (printf "a %s b" :: String -> String)
01:59:35 <quchen> applicative: It beats manual tarballs by a huge margin at least :-)
01:59:37 <lambdabot>   mueval-core: Time limit exceeded
01:59:38 <arkeet> aw.
01:59:42 <arkeet> printf is too strict.
01:59:55 <arkeet> > head $ fix (printf "a %s b" :: String -> String)
01:59:56 <lambdabot>   'a'
01:59:58 * mauke_tmp wonders
02:00:01 <shachaf> > take 2 $ fix (printf "a %s b" :: String -> String)
02:00:03 <applicative> quchen: yeah ask the ocaml or ml people
02:00:03 <lambdabot>   "a "
02:00:15 <arkeet> > take 3 $ fix (printf "a %s b" :: String -> String)
02:00:19 <quchen> applicative: Is that how they do it?
02:00:19 <lambdabot>   mueval-core: Time limit exceeded
02:00:21 <shachaf> No, it's only 2.
02:00:29 <mauke_tmp> ah, dammit. no haskell here
02:00:40 <mauke_tmp> I wanted to try it with printf-mauke
02:00:58 <quchen> applicative: Thinking of it, C++, C and mostly everything else don't have their own packaging system
02:01:00 * shachaf $ cabal install printf-mauke
02:01:26 <arkeet> quchen: python does, perl does, ruby does
02:01:35 <arkeet> who else?
02:01:41 <oihk> lisp does :)
02:01:49 <shachaf> mauke: With Text.Printf.Mauke it gives (cycle "a ").
02:01:54 <oihk> (common lisp that is)
02:02:08 <mauke_tmp> shachaf: and the TH version?
02:02:26 <quchen> arkeet: Python does? The more you know ...
02:02:31 <arkeet> yes, eggs
02:03:04 <shachaf> mauke_tmp: Also.
02:03:19 <mauke_tmp> ok! this may be a good thing
02:03:51 <applicative> no, c and c++ have e.g. pacman
02:03:52 <shachaf> What happened to your computer and/or Internet connection?
02:04:02 <Ghoul_> Hahaha, I was browsing wikipedia for strange keyboard layouts and came across the kinesis -- look what's on the table!
02:04:03 <Ghoul_> http://upload.wikimedia.org/wikipedia/commons/7/71/Xmonad-screen-triplehead-dons.png
02:04:11 <Ghoul_> Ofcourse the haskell programmers are the nuttiest to try new things :)
02:04:29 <shachaf> That sounds like a #xmonad topic.
02:04:54 <arkeet> not really.
02:04:57 <mauke_tmp> shachaf: I moved and may be getting a shiny new internet tomorrow
02:05:01 <arkeet> could be -blah though
02:05:19 <applicative> indeed, let us cast it into the outer darkness, and bring things back to monoids
02:05:35 <donri> xmonoid?
02:05:39 <quchen> applicative: How is Pacman related to C++? Isn't it Arch's general purpose packager?
02:06:15 <shachaf> arkeet: No thanks.
02:06:23 <applicative> yes, i was making, what do they say in shachaf's language -- a punning? no.
02:06:50 <applicative> quchen: all the labor is left to an army of lemmings for each distribution.
02:06:51 <shachaf> dmwit's language.
02:07:41 <jermey> hey haskell can someone help me with some syntax
02:07:42 <jermey> http://pastebin.com/q7XzJcMS
02:07:43 <applicative> quchen: whereas we insanely hold that the question what fits with what should be lieft in the hands of the library writer.  What foolishness
02:07:53 <jermey> i have never seen the ' in my life
02:07:57 <jermey> what do they mean?
02:08:13 <donri> haskell's package manager is ghc-pkg not cabal. c has pkg-config :)
02:08:20 <quchen> jermey: ' is just a letter.
02:08:22 <dmwit> jermey: It's just part of the name.
02:08:26 <shachaf> jermey: v' is a variable name, just like v
02:08:30 <mauke_tmp> jermey: your syntax highlighting is bad
02:08:41 <shachaf> pastebin.com is highlighting it badly. Solution: Don't use pastebin.com.
02:08:44 <dcoutts_> donri: I'm not sure you can call either of those package managers
02:08:54 <jermey> mauke_tmp: pastebin default
02:09:02 <jermey> ah thanks guys
02:09:14 <jermey> is there any reason why somoen would use that instead of normal v?
02:09:16 <dcoutts_> donri: ghc-pkg with pkg-config is a fair comparison though
02:09:22 <shachaf> The name v is already taken.
02:09:32 <shachaf> v' is a new v.
02:09:41 <applicative> jermey: the l' is not lined up
02:10:16 <mauke_tmp> @where hpaste
02:10:17 <lambdabot> http://hpaste.org/
02:10:17 <dmwit> v' looks better than v2
02:10:19 <dmwit> sometimes
02:10:25 <donri> dcoutts_: well they seem like 'rpm' to me. Cabal then is like 'rpmbuild' and cabal-install like yum (but from source)
02:10:29 <mauke_tmp> did you mean: a4
02:10:33 <shachaf> (It's sometimes considered slightly impolite to use pastebin.com. Use hpaste.org or something else without advertisements.)
02:11:00 <dcoutts_> donri: the big difference between ghc-pkg/pkg-config and rpm is that rpm tracks files
02:11:22 <dcoutts_> donri: you know that obviously, but I think the file tracking is a significant difference
02:11:32 <donri> dcoutts_: but i'm sure there's a ton of problems with this metaphor
02:11:48 <donri> true
02:12:07 <dcoutts_> donri: and rpm enforces certain kinds of low level consistency
02:12:26 <applicative> jermey: are you using tabs? the paste site seems to be giving two representations, one wrong and one write.  I recommend giving up on it.  :)
02:12:59 <applicative> I mean the paste site, but also tabs, sorry to say
02:13:50 <applicative> dcoutts_: but the main point is 'cabal is evil' thats what the reddit is saying ...
02:14:03 <donri> lol
02:14:33 <applicative> dcoutts_: do you want me to take some of these folks out?  I don't any military skills admittedly
02:14:35 <dcoutts_> applicative: yes I saw
02:14:37 <applicative> dont have....
02:14:40 <dcoutts_> applicative: heh
02:15:25 <donri> you can find hitmen online if you have some €25000 laying around
02:15:48 <dcoutts_> I think that'd be better spent on coding :-)
02:16:24 <applicative> no dcoutts_ they'll never stop, it doesn't matter if cabal install waxes their cars for them
02:16:25 <donri> +1
02:16:27 <quchen> Half a year of a dedicated coder's time would probably make a better Cabal than killing one of the opposers silently.
02:16:48 <quchen> applicative: I think the main problem with Cabal is that it cannot read email.
02:17:12 <dcoutts_> applicative: oh yes I know that, there will always be complains, and there's too many of them, we just need thick skin
02:17:31 <applicative> dcoutts_: yes, i have to say I much admire yours.
02:17:46 <mauke_tmp> s/laying/lying/
02:18:12 <Ralith> speaking of cabal
02:18:16 <quchen> dcoutts_: Well, the complaints are mostly justified, no? From the perspective of someone who just wants to use Haskell and not worry about packaging at least.
02:18:18 <Ralith> is there any way to get data files included based on a flag?
02:18:25 <dcoutts_> quchen: sure
02:18:36 <applicative> speaking of cabal, how it sucks so much, in ruby ....
02:19:10 <Kinnison> That's not fair.  Almost anything looks awesomely wonderful when compared with Ruby
02:19:24 <quchen> Let's not say "it sucks so much", let's say "it has a lot of potential".
02:19:32 * applicative refuses to believe the complaints are justified. 
02:20:08 <applicative> for one thing hackage, bless it, is a complete madhouse.
02:20:09 <dcoutts_> quchen: the point is that no matter how much better you make it, people's expectations will be raised until they complain again. That doesn't mean it's not worth improving, but one should not do it just to reduce complaints :-)
02:20:27 <dcoutts_> quchen: it's certainly worth making better
02:20:27 <donri> mauke_tmp: ah, thanks
02:21:21 * applicative remembers when he was first learning haskell 'cabal update' took a couple of seconds. Now you take the cat out for a walk. 
02:21:24 <quchen> dcoutts_: That's a very handwavy argument. I don't think "people will always complain" makes a good case for anything. For example, there are things to complain about Haskell, but very few are seriously annoyed by those things.
02:22:04 <quchen> With Cabal, everyone has a story about how he tried to install Yesod at one point. The bad thing about this is that it makes really awful Google search hits.
02:22:33 <dcoutts_> quchen: I'm not sure I was making a case for anything on that basis
02:22:59 <applicative> do installations of python packages often have as many dependencies?
02:23:13 <applicative> as yesod?  it stuns the mind really
02:24:03 <krimi> I have a list of tuples of size 3 [(a,b,c),...] how can i get a list of all the middle values?
02:24:10 * applicative knows what it is like to be incompetent with a package system; he has python libraries buried in every corner of his computer
02:24:13 <dcoutts_> quchen: the yesod example is good, before we improved it last time, the yesod example was simply impossible/impractical. Now it's close enough to practical that it exists for people to complain about. The complaints are certainly valid however, I don't deny that at all.
02:24:24 <quchen> krimi: map (\(_,x,_) -> x) LIST
02:24:29 <applicative> krimi: there isn't a standard function.
02:24:31 <t7> krig, map (head . tail)
02:24:35 <krimi> cheers!
02:24:40 <applicative> as there are fst and snd for pairs
02:24:53 <dcoutts_> quchen: it's more an observation than an argument for doing or not doing anything in particular
02:24:56 <applicative> with the supernatural lens library, there are combinators for that
02:25:32 <applicative> > (True, 17,"krimi") ^. _2
02:25:34 <lambdabot>   17
02:25:37 <mitchell> Hey I already asked for help but I am really stuck on parsing an identifier for a homework assignment.  Here is my code so far:
02:25:41 <hpaste> mitchell pasted “parse” at http://hpaste.org/86809
02:25:43 <t7> @check (\(_,x,_) -> x) == (head . tail)
02:25:44 <lambdabot>   Not in scope: `myquickcheck'
02:25:44 <quchen> dcoutts_: Let's say the complaints that come from actual deficiencies should be fixed then. :-)
02:26:14 <dcoutts_> quchen: sure, only bottleneck is dev time
02:26:17 <h4199> @ty (head.tail)
02:26:18 <lambdabot> [c] -> c
02:26:21 <mauke_tmp> v <- ident; return (I v)
02:26:22 <quchen> t7: You're mixing tuples and lists here.
02:26:35 <quchen> dcoutts_: I'd try to help out if I had the knowledge :-|
02:26:36 <t7> oh yeah :|
02:26:37 <applicative> +++ in Hutton's libray is <|>
02:26:40 <applicative> ?
02:26:50 <mauke_tmp> yes
02:26:54 <h4199> @ty (\(_,x,_) -> x)
02:27:01 <lambdabot> (t, t1, t2) -> t1
02:27:04 <mitchell> umm it is of type parser a -> parser a -> parser a
02:27:06 <dcoutts_> quchen: it's actually more a matter of time than knowledge
02:27:07 <mitchell> i can post the code
02:27:20 <t7> they should make a type class for HeadAndTailable
02:27:35 <mauke_tmp> a.k.a. Stream
02:27:41 <hpaste> mitchell revised “tiny parser”: “parser” at http://hpaste.org/86805
02:27:54 <quchen> dcoutts_: Do you think Cabal's management can be fixed (as opposed to rewritten)? Sandboxes are kind of a workaround, aren't they?
02:28:13 <quchen> dcoutts_: The "Nix-like" approach certainly sounds nice, but is nothing like Cabal works right now, is it
02:28:17 <applicative> krimi: whats in these identifiers, many1 alphanum or something?
02:28:17 <donri> > [(a,b,c),(x,y,z)] ^.. folded._2
02:28:20 <lambdabot>   [b,y]
02:28:46 <mitchell> applicative: sorry, were you talking to me?
02:29:06 <applicative> oh i guess i was
02:29:08 <dcoutts_> quchen: well, parts/layers will need rewriting. There's two ways of looking at sandboxes, one is as a mechanism and the other is as a UI.
02:29:29 <applicative> #haskell is excellent for insomnia, have you noticed
02:29:30 <mitchell> Yeah, identifier can be any alphanum
02:29:39 <mitchell> in this parser
02:29:40 <mitchell> lol
02:29:46 <dcoutts_> quchen: it'd be quite possible to have a nix-like impl with a ui that looks like sandboxes, or more generally "environments"
02:30:09 <dcoutts_> quchen: but yes, I think it can be done
02:30:34 <donri> quchen: it's not that far from how cabal works now, since some work has already happened to move it in that direction
02:30:40 <hpaste> jermey pasted “jermey” at http://hpaste.org/86811
02:31:29 <djcoin> Are there some kind of (maybe functional) database written (or being planned) in haskell ?
02:31:42 <applicative> mitchell: case doesn't matter? then something like many1 alphanum, but let me look at hutton
02:31:55 <donri> djcoin: acid-state and analytics perhaps
02:32:02 <donri> they changed the name of the second i think
02:32:15 <applicative> mitchell: I don't get it,he defines ident
02:32:20 <djcoin> yeah analytics just looked at that
02:32:20 <jermey_> hey guys
02:32:21 <quchen> dcoutts_: What do you mean with "UI" here?
02:32:25 <jermey_> can someone look at this http://hpaste.org/86811
02:32:27 <djcoin> donri: thanks - so that's all ?
02:32:31 <quchen> dcoutts_: In conjunction with sandboxes, that is
02:32:34 <jermey_> if they have time/know about bst
02:32:39 <applicative> mitchell: his insists on  lower case at the start
02:32:55 <jermey_> my irc died so i might have missed anything if anyone mentions anything
02:33:00 <donri> djcoin: depends what you mean "in haskell". there are several libraries for interacting with outside databases
02:33:13 <dcoutts_> quchen: how the user interacts with the stuff, e.g. via command line ui, but slightly more generally, how the user thinks about it
02:33:14 <mitchell> applicative: oh really?  Let me look.
02:33:46 <applicative> jermey_: somehow I think these instructions are going to lead to an excess of parallelization
02:33:57 <mitchell> applicative: so it is setting the first character to lower case?
02:34:04 <mitchell> applicative: seems weird
02:34:26 <donri> djcoin: also there's http://hackage.haskell.org/package/DSH which makes use of external databases but isn't really a database interface library
02:34:36 <g3orge> hi guys, upgrated ghc and cabal (in arch) and it said "all cabalized packages need to be reinstalled' what do I do? cabal upgrade doesn't work
02:34:39 <djcoin> donri: yeah no, i was not refering to drivers/wrappers. I was wondering if someone could leverage concurrency/parallelism/distributed in haskell to build "disruptive" database, à la datomic for example
02:34:41 <dcoutts_> quchen: e.g. we need a ui that changes the way people think: currently people tend to things like "install A; install B; install C" and they have expectations that this will work and that C will use the instances of A, B that they just installed.
02:34:51 <applicative> his is, do you see the definition, first a <- lower, then as <- many alphaNum; return (a:as)
02:34:57 <jermey_> applicative: this may seem a stupid question but what is excess parallelization?
02:35:08 <mitchell> applicative: yep
02:35:10 <donri> djcoin: i don't know datomic, but it sounds like you want acid-state
02:35:16 <quchen> dcoutts_: In the end Haskell's going to need a billion dollar enterprise to back it up for all those things to get fixed. (Not sure if joking.)
02:35:33 <djcoin> donri: all right, thanks
02:35:36 <quchen> dcoutts_: That example above won't work due to the nondeterministic binary interface?
02:35:41 <djcoin> I will dig in
02:36:07 <donri> djcoin: here's some docs http://www.happstack.com/docs/crashcourse/AcidState.html#acid_state
02:36:09 <dcoutts_> quchen: no I don't think so, not to solve these issues. I'm guessing at 6-12 months full time from someone who knows what they're doing.
02:36:10 <applicative> jermey_: well, im no expert.  But if you divide the problem too fine-grainedly then the cost of coordinating and communicating between the threads begins to outweigh the advantage of parallelizing
02:36:16 <dcoutts_> quchen: so that style of ui does not match the nature of the problem very well.
02:36:33 <applicative> jermey_: but as an initial exercise it makes sense
02:36:56 <jermey_> yeah applicative that might happened (we were born) but this is my first time ever doing anything with parallelism or of the like
02:37:08 <jermey_> (yes it is my first ever exercise)
02:37:21 <dcoutts_> quchen: so a different ui that I'm thinking of is that the user works with a package environment, and they have to add packages into that environment, adding them may or may not work because it may not be consistent with other packages currently in the environment.
02:37:47 <jermey_> would have any idea what "A spark should be created for each node in the tree." means?
02:37:51 <dcoutts_> quchen: users will be encouraged to think about how they want to setup/change their environment, rather than individual actions like "install blah"
02:37:55 <applicative> jermy_ maybe not:  v' `par` l' `par` r' `par` Branch v' l' r'  but rather v' `par` l' `par` r' `pseq` Branch v' l' r'
02:38:26 <applicative> then v' l' and r' go off their separate ways, and return to constiture Branch '
02:38:40 <donri> jermey_: i don't think you can have full control over sparks except maybe with some low level primitives, but the instructor probably just means "evaluate them with par" basically.
02:38:45 <quchen> dcoutts_: If you could do that per sandbox that would be nice.
02:39:04 <applicative> Branch v' l' r'.  You don't want the latter to be going ts own separate way, it isn't independent of the others.
02:39:06 <quchen> dcoutts_: At least some warning "hey stuff breaks if you do this" would be appreciated :-)
02:39:19 <donri> jermey_: 'par' tells the runtime system that it could be a good idea to schedule a spark for something, but i think it's up to the system whether to spark or not
02:39:40 <dcoutts_> quchen: we do that already, but it's not nearly enough
02:39:58 <dcoutts_> quchen: right, a sandbox is then just a separate environment
02:40:20 <applicative> jermey_: you dont want to say go calculate v l and r on separate threads or cores, since they have notiong to do with each other, and do the same with Branch ' v r
02:40:41 <jermey_> hey donri you seem to know what to do was par and pseq, can you you please explain this like i am 3. (i get the thoery of it). but i somehow dont get the haskell code of it "                              v' `par` l' `par` r' `pseq` Branch v' l' r'	  "
02:40:47 <jermey_> that is kinda confusing me
02:40:59 <quchen> dcoutts_: Is there something like a roadmap for Cabal? If time is the issue, do we know what to spend it on yet?
02:41:15 <applicative> jermey_: `pseq` to put it crudely is saying that Branch l v r depends on the others, which much be calculated first.
02:41:35 <quchen> dcoutts_: I hope the roadmap doesn't just say "fix dependency hell" ;-)
02:42:11 <donri> jermey_: i'm no expert no :)
02:42:29 <applicative> jermey_: its always the same you have a bunch of pars, and then when you come to what you needed them all for, you do pseq
02:43:25 <dcoutts_> quchen: well we know more or less how to fix the issues, if that's what you mean, and there's info in various places for people to find out what that is
02:43:43 <applicative> i could be wrong but your v' `par` l' `par` r' `par` Branch v' l' r' will make 4 calculations in parallel, none communicating its result to another; Branch v l r is the actual value, and will be caluclated not-in-parallel
02:44:11 <jermey2> hey donri applicative i missed everything after this line [19:40] <quchen> dcoutts_: Is there something like a roadmap for Cabal? If time is the issue, do we know what to spend it on yet?
02:44:18 <jermey2> did you guys say anything after that?
02:44:29 <jermey2> (i should really download a irc client for my mac)
02:44:53 <dcoutts_> jermey2: not all written down clearly in one place, but people involved do know what needs doing, mostly
02:45:12 <donri> jermey_: (a `par` b) is the same as (b) but tells the runtime system that it might be beneficial to evaluate (a) in parallel to this
02:45:52 <donri> jermey2: logs linked in topic
02:46:03 <applicative> jermey2: so if you define `apartFrom = par` and `andThenComeTogetherFor` as `pseq` you get v' `apartFrom ` l' `apartFrom` r' `andThenComeToghetrFor` Branch v l r
02:47:25 <Ralith> any way to get ghc-mod to automatically find cabal Paths_ modules?
02:47:31 <Ralith> for flymake specifically
02:47:40 <applicative> whereas yours was  v' `apartFrom ` l' `apartFrom` r' `apartFrom` Branch v l r jermey2
02:47:50 <applicative> so you have three wasted calculations
02:47:51 <donri> Ralith: you'd have to make it an exposed-module
02:48:06 <jermey2> so does this mean
02:48:17 <Ralith> donri: I'd be satisfied with it just searching the dist dir automatically
02:48:37 <donri> Ralith: although you could maybe cheat it by passing -g-idist/... i forgot the exact location
02:48:44 <Ralith> dist/build/autogen/
02:48:47 <Ralith> the problem is finding the dist dir
02:48:51 <jermey2> evluate v' in parallel, evaluate l' in parellel then the r' in cocurrency?
02:49:01 <donri> Ralith: ghc-mod takes ghc args with -g
02:49:02 <applicative> jermey if I send my workers out to pick up supplies and so forth independently, then I do expect them to come back so we can put it all together
02:49:03 <jermey2> is that what its means?
02:49:11 <Ralith> donri: I'm not sure what that means.
02:49:17 <jermey2> right, applicative
02:49:51 <donri> Ralith: well i don't know flymake but in vim you can configure the ghc-mod command line and then you can make it pass -g-idist/build/autogen
02:49:57 <applicative> to parallelize is to send out worker to calculate independently and the (pseq) come togehter for the big calculation
02:50:00 <donri> Ralith: i bet there's something similar for flymake
02:50:08 <Ralith> donri: what does -g do?
02:50:20 <donri> Ralith: passes an option to ghc
02:50:27 <jermey2> ah applicative got ya
02:50:29 <Ralith> ooh.
02:50:37 <jermey2> so you pseq on branch for the total calculation
02:50:45 <jermey2> right/
02:50:46 <jermey2> ?
02:51:01 <applicative> you send them out to calculate independently (par) and then come together (pseq) for the thing that is the actual value of the whole expression
02:51:17 <Ralith> donri: are all paths relative to the project root dir, then?
02:51:39 <jermey2> got you applicative thanks SO MUCH DUDE
02:51:45 <donri> Ralith: relative to the $PWD of emacs, i'd think
02:51:48 <applicative> yes, the last bit of the series is 'the whole calculation' so you pseq on it
02:51:55 <jermey2> this channel makes #haskell so much more fun to learn
02:52:03 <Ralith> donri: well that's completely useless then.
02:52:12 <donri> heh
02:53:40 <Ralith> seems unlikely
02:53:41 <osa1_> how hard would it be to write a GHC extension to support OCaml style patterns(patterns with same body) ? ie. match ... of { pat1 | pat2 | pat3 -> body; | pat4 -> another_body }
02:53:45 <Ralith> the ghc-mod docs provide examples with -i
02:53:51 <Ralith> there's just absolutely no way to debug this crap :/
02:54:01 <Ralith> silent failure is all you get
02:54:32 <donri> osa1_: could maybe be done with ViewPatterns
02:55:35 <osa1_> donri: as far as I know ViewPatterns gives a way to get similar effect but it's not the same
02:56:07 <donri> exactly
02:56:23 <osa1_> OCaml style patterns is more useful in my case
02:57:14 <donri> perhaps hpaste your current code and let #haskell golf it with you
02:58:25 <osa1_> donri: it's basically this http://hpaste.org/86815 and some other definitions like this one
02:58:28 <Ralith> man why is it so impossible to get ghc-mod to work properly
02:58:31 <osa1_> full code is not ready to be pasted ^^
02:58:36 <Ralith> or even find anyone who knows anything about fixing it
02:59:23 <donri> osa1_: could do it with TH ...
03:00:03 <osa1_> hmm
03:00:39 <donri> osa1_: actually, why not just ti _ _ = binop_arith at the bottom
03:00:54 <donri> then just list the other ones before
03:01:13 <Jaxan> Anyone experience with the llvm bindings on mac osx 10.7 ?
03:01:33 <osa1_> donri: I don't like that "match all" pattern because then adding new constructors to the type would not throw me a warning :-)
03:01:39 <donri> true
03:03:12 <donri> make some TH ti _ $(anyOf ['Add, 'Sub, ...]) = binop_arith
03:04:35 <osa1_> heh 5th result of google "TemplateHaskell" is "what's so bad about TH" ..
03:04:36 <donri> expanding to something like ((\case Add -> True; Sub -> True; _ -> False) -> True)
03:05:01 <donri> (yay inline lambda case in a view pattern via template haskell)
03:05:33 <mauke_tmp> would you like CPP with that?
03:06:33 <donri> :)
03:07:41 <merijn> Jaxan: I have *very limited* experience with it, I don't think the llvm bindings work with the clang/llvm version that ships with 10.7 so you'll have to get a newer version from MacPorts/homebrew
03:07:49 <bobry> Cabal question: is it possible to compile a C file and run resulting binary _before_ building any Haskell sources?
03:08:12 <Jaxan> merijn: hmm I have a new clang laying around somewhere
03:08:53 <Jaxan> merijn: btw, I built the newest llvm (3.3)
03:09:52 <Jaxan> merijn: why from macports/homebrew? llvm/clang from source compiles just fine
03:10:28 <merijn> Jaxan: Oh, yeah, I guess. I'm just lazy :)
03:10:34 <Jaxan> :)
03:11:07 <merijn> bobry: Yes, worst case scenario you can just write a manual hook to do that
03:11:50 <dcoutts_> bobry: you can have pre-processors inside the same package that uses them. You have to write a bit of code in Setup.hs to explain how to run the prog as a pre-processor.
03:12:01 <dcoutts_> bobry: so you get some help, but you still need to write some code
03:13:50 <bobry> dcoutts_: is there an example somewhere?
03:14:21 <merijn> bobry: I have a trivial example of shelling out, which is probably not the right way to do things, but I was lazy: https://github.com/merijn/SNet2.0/blob/master/Setup.hs
03:14:29 <bobry> dcoutts_: an by pre-processors you mean UserHooks?
03:14:30 <merijn> bobry: The documentation is pretty readable
03:14:41 <dcoutts_> bobry: right, via user hooks
03:15:00 <bobry> merijn: thanks!
03:15:17 <dcoutts_> bobry: you define an exe in the package and make the other exe/lib component depend on that via build-tools: the-local-preprocessor-exe-name
03:15:44 <dcoutts_> bobry: but to actually run the pre-processor needs to be explained via the user hooks api
03:17:10 <statusfailed> wow. I just got a segfault
03:17:12 <statusfailed> that's not normal
03:23:21 <bobry> dcoutts_: exe requires 'main-is' field, which can only contain *.hs
03:23:37 <bobry> is there a way to make a C exe?
03:24:56 <fanatik86> kalimera se olous
03:25:02 <fanatik86> kai kali evdomdasa
03:27:12 <dcoutts_> bobry: in current release it has to be .hs, but you can make a .hs main that calls c
03:27:32 <dcoutts_> bobry: in dev version .c is allowed as the main-is file
03:28:10 <fanatik86> good morning
03:28:16 <fanatik86> need some help
03:35:52 <akegalj> i run ':t "hi"' on ghci. On one machine it says Data.String.IsString a => a, on other [Char]. Why is that?
03:36:18 <shachaf> Because you have OverloadedStrings turned on on the first machine.
03:36:35 <akegalj> thnx
03:36:37 <shachaf> I bet you're not running ghci the same way or have a different .ghci.
03:40:48 <fanatik86> good morning
03:41:01 <fanatik86> anyone from greece?>
03:41:29 <engla> ti kanis. (no)
03:42:00 <fanatik86> speak greek?
03:42:32 <engla> no :-)
03:52:33 <hpaste> jermey pasted “jermey” at http://hpaste.org/86818
03:54:35 <jermey> i am trying to figure out the d case, i don't think haskell has if cases, does it?
03:55:44 <danr> jermey: there are if-then-else expressions, and also guards
03:57:46 <donri> parTreeMapWithCutoff d f t | d > 0 = ... parTreeMapWithCutoff (d - 1) f ...
03:58:42 <donri> | otherwise = sequential version
04:00:23 <fanatik86> anybody knows how can i find a greek hacker?
04:00:46 <t7> advert in a greek paper ?
04:00:51 <jermey> whats the difference between | and | otherwise?
04:01:04 <donri> @src otherwise
04:01:05 <lambdabot> otherwise = True
04:01:18 <donri> jermey: it's just an alias for True for readability
04:01:46 <donri> | takes a Bool. d > 0 is a Bool, otherwise is a Bool
04:02:31 <donri> make sure to align both | vertically
04:03:36 <shachaf> Yes. If they're aligned horizontally, you've gone very wrong somewhere.
04:04:00 <donri> :)
04:07:10 <jermey> hey donri what did you mean with those ...
04:07:31 <danr> jermey: he meant you should fill in the details :)
04:07:51 <jermey> i m thinking
04:08:05 <jermey> wouldn't i need to call parMapTree somewhere
04:08:34 <jermey> because his line didn't make sense to me
04:08:46 <hpaste> jermey revised “jermey”: “jermey” at http://hpaste.org/86818
04:11:37 <donri> jermey: no you need to recurse with parTreeMapWithCutoff wich parTreeMap doesn't
04:12:29 <donri> jermey: after the first = you basically put the parTreeMap code but with l' = parTreeMapWithCutoff (d-1) f l, etc
04:12:38 * hackagebot free-game 0.9.1 - Create graphical applications for free  http://hackage.haskell.org/package/free-game-0.9.1 (FumiakiKinoshita)
04:12:55 <donri> jermey: after the second, you can call treeMap though
04:14:09 <donri> jermey: if you just call parTreeMap in the first case, it'll parallelize the whole computation and just be an alias for parTreeMap, ignoring the depth
04:16:05 <donri> jermey: i could show you the code but if it's for homework i better not ;)
04:16:21 <jermey> yeah i kind want to figure it out myself
04:16:27 <donri> good! :)
04:16:27 <jermey> but thanks for helping
04:16:33 <donri> np
04:16:37 <jermey> you are making a lot of it clearer
04:17:01 <hpaste> jermey revised “jermey”: “jermey” at http://hpaste.org/86818
04:17:24 <jermey> just revised paste, mind having a look if i am on the right path?
04:17:43 <donri> jermey: no, you need basically to reimplement parTreeMap in the case where d > 0
04:17:54 <donri> and missing a = after otherwise
04:18:59 <donri> jermey: also this is only for the Branch cases, for Leafs you can ignore d and f and just return the Leaf back
04:19:41 <jermey> branch cases? do you mean the sequential part?
04:20:51 <donri> I mean parTreeMapWithCutoff d f (Branch v l r) | d > 0 = paste code from parTreeMap, change calls to parTreeMap to parTreeMapWithCutoff (d - 1)
04:21:37 <bobry> one more Cabal question: how can I run an executable (defined in .cabal file) from Setup.hs?
04:21:44 <donri> | otherwise = call treeMap, i'll let you figure it out
04:22:38 <donri> parTreeMapWithCutoff _ _ Leaf = Leaf  -- or parTreeMapWithCutoff _ _ t = t, for better sharing, not sure ghc optimizes it to that anyway though
04:23:38 <zink> hi, having some problems with installing haskell client
04:23:43 <zink> i get an NSIS error
04:23:51 <zink> i've tried everything on the NSIS help page
04:23:53 <donri> zink: what is "haskell client"?
04:23:56 <zink> but am getting no results
04:24:12 <zink> haskell platform, sorry
04:24:15 <zink> http://www.haskell.org/platform/
04:24:32 <zink> Windows 7 32-Bit
04:24:39 <donri> zink: aha. is this on windows? I don't really know about haskell on windows, sorry
04:24:52 <zink> yeah, it's windows
04:25:39 <hpaste> jermey revised “jermey”: “jermey” at http://hpaste.org/86818
04:26:08 <zink> so anyone have any thoughts?
04:26:17 <donri> jermey: sorry i wasn't clear: paste the code *body* from parTreeMap, e.g. that after the =
04:26:48 <jermey> so only this?
04:26:48 <jermey> let v' = f v
04:26:49 <jermey>                                   l' = parTreeMap f l
04:26:50 <jermey>                                   r' = parTreeMap f r
04:27:02 <donri> jermey: yeah
04:27:08 <donri> and the 'in' part
04:28:25 <hpaste> jermey revised “jermey”: “jermey” at http://hpaste.org/86818
04:29:04 <donri> jermey: so | after a pattern makes the pattern match only if the right-hand-side of the | is True, with fall-through to the next | on the next line etc.
04:29:20 <donri> jermey: you need a = after d > 0
04:30:05 <donri> jermey: and you need a Leaf case
04:30:33 <donri> jermey: also you pasted the code for treeMap not parTreeMap! :)
04:31:19 <hpaste> jermey revised “jermey”: “jermey” at http://hpaste.org/86818
04:31:22 <jermey> w00ps
04:31:27 <jermey> that was terrible of me
04:31:34 <donri> no worries :) does it compile?
04:31:57 <donri> jermey: you need to align l' and r' with v'
04:31:57 <bobry> dcoutts: why can't I preprocess .cmm files?
04:32:29 <jermey> yeah i realised that
04:33:18 <donri> jermey: i may have confused you with guards btw. this whole thing is the same as: parTreeMapWithCutoff d f (Branch v l r) = if d > 0 then let v' = ... in ... else treeMap f (Branch v l r)
04:33:19 <hpaste> jermey revised “jermey”: “jermey” at http://hpaste.org/86818
04:33:45 <donri> jermey: still not quite aligned :)
04:34:03 <jermey> can we if/then in haskell?
04:34:07 <donri> sure
04:34:18 <jermey> i swear they were aligned in the editor
04:34:23 <donri> > if 4 > 5 then "wat" else "ah"
04:34:25 <lambdabot>   "ah"
04:35:00 <dcoutts_> bobry: ghc handles cmm files, cabal just passes them to ghc
04:35:28 <donri> jermey: once it compiles, try to tell me how and why this works, if you feel like it
04:35:32 <dcoutts_> bobry: oh you mean with cabal's pre-processor stuff? oh that's only designed for haskell modules
04:35:58 <dcoutts_> bobry: it only supports a simple notion of pre-processor for haskell modules, not for c sources
04:36:11 <donri> jermey: (i fear i might've told you too much, so would be good to check that you understand the code you just wrote!)
04:36:22 <kmels_> hi, i'm trying to test my executable with cabal and a module in my test suite can't find a module contained in the executable. Should I separate the executable into a library + executable?
04:36:28 <bobry> dcoutts_: I see, thanks
04:36:29 <dcoutts_> bobry: you'd need to run the preprocessor yourself in the Setup.hs
04:36:49 <jermey> yeah donri i am going to go over the code
04:36:55 <jermey> because i get some of it but some of it i dont
04:37:17 <bobry> dcoutts_: can I somehow first compile my preprocessor-exe and then invoke it from Setup.hs for the library?
04:37:26 <dcoutts_> bobry: yes
04:37:38 * hackagebot io-streams 1.1.0.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.0.0 (GregoryCollins)
04:37:51 <bobry> dcoutts_: can you point me to the function / functions I need to do this?
04:38:18 <dcoutts_> kmels_: you don't need to separate it into a lib. You just need to arrange the src dirs so that the test can find the modules
04:38:28 <bobry> I was looking at Distribution.Simple.Program, but it doesn't allow to run an exe
04:38:37 <dcoutts_> kmels_: using the hs-source-dirs field
04:38:37 <donri> kmels_: two options i know of: add the executable source dir to hs-source-dirs, or, move all modules to the library and make them exposed-modules then depend on yourself in the test-suite
04:39:15 <donri> MK_FG: the first option has the downside that it'll compile the module twice; the second has the downside that you have to expose the module in the library
04:39:19 <dcoutts_> bobry: the Distribution.Simple.Program lets you define programs and run them, so that can be used for programs you've just compiled in the build tree
04:39:23 <donri> MK_FG: sorry
04:39:28 <donri> kmels_: that was for you
04:39:45 <dcoutts_> bobry: there's no specific util to get the location of the exe however (I think)
04:39:53 <towadako> i'd like lambdabot to connect to my irc server; doing lambdabot -e "irc-connect irc irc.example.com 6667 currybot currybot" results in it receiving the welcome message from my server, but then outputting "BOUNCE!" 3 times
04:40:02 <bobry> dcoutts_: okay, thanks once again
04:40:43 <dcoutts_> kmels_: I presume you've split the test into a separate dir from the exe (otherwise it would find the modules)
04:41:08 <dcoutts_> kmels_: so just need to list the exe's src dir in the hs-source-dirs field of the test, and it'll find them
04:41:28 <shachaf> towadako: That's 005 at https://www.alien.net.au/irc/irc2numerics.html
04:41:35 <jermey> ok donri  here is what the code is doing (parTreeMapwithcutoff) line by line. First line is just base case if only 1 think its a Leaf. (basic BST).2nd line getting the BST hence Branch v l r thing. then d>0 checks depth is positive. then v' = f v for the vertex, then l' side then r'. (i don't really understand the "in" statement hopefully you can help me with this). |otherwise is like a else if then just call the sequential
04:41:36 <jermey> function.
04:42:18 <shachaf> towadako: Maybe connect by hand and see what the full message is.
04:42:40 <shachaf> lambdabot isn't really meant to be used.
04:42:48 <donri> jermey: 'in' just means "end of let-bindings, start of expression"
04:42:56 <shachaf> At least, not by people who aren't ready to investigate the source etc. whenever anything goes wrong. :-)
04:43:04 <donri> jermey: but what makes parTreeMapWithCutoff do the right thing with depth?
04:43:20 <kmels_> dcoutts, donri: I added 'src' to hs-source-dirs, it finds my module but it complains that it needs the dependencies (listed in other-modules)
04:43:59 <kmels_> dcoutts, donri: changing other-modules to exposed-modules does something else, but it still fails.. do I all my dependencies to the test-suite as well?
04:44:23 <donri> kmels_: in deed. each component in cabal needs all its depends listed
04:44:35 <kmels_> okay
04:44:36 <kmels_> thanks.
04:44:38 <kmels_> ^^
04:44:41 <jermey> donri do you mean why does it use depth? Isn't that because its being called recursively so say d is 5, its called for 5, 4, 3, 2,1 cases of depth?
04:44:50 <donri> kmels_: well i think you're mixing up my two suggestions here and trying both
04:45:16 <donri> kmels_: *either* use hs-source-dirs: src tests; build-depends: stuff-needed-for-module
04:45:50 <donri> kmels_: *or*, move the module to src and make it an exposed-module in the library and then build-depends: this-project-name in the test-suite
04:46:39 <kmels_> donri: I have "hs-source-dirs: test, src" but it asks for the deps.
04:46:54 <donri> kmels_: in deed. that's what i said :)
04:47:14 <donri> if you use hs-source-dirs, you need to list the deps also in the test-suite component
04:48:06 <kmels_> donri: yeah, I'll try your other solution hoping there's no prob that this-project-name is an executable and not a library
04:48:23 <donri> basically, pretend each cabal component is a separate cabal package (that happens to have the same name and source tree)
04:48:53 <donri> kmels_: it won't be a problem if you also have a library component (which you need, to exposed-modules it)
04:49:21 <donri> with no library component, it's a problem because ghc-pkg doesn't track those
04:49:40 <donri> and you can't expose modules from an executable anyway :)
04:50:13 <donri> jermey: yeah, sounds like you understand it i think
04:50:13 <kmels_> oh I see! well I guess it is more modular
04:50:36 <kmels_> doing the library
04:50:39 <donri> jermey: so, why did we have to paste code, why couldn't we just call parTreeMap?
04:50:47 <jermey> hey donri can you explain this line ro                        v' `par` l' `par` r' `pseq` Branch v' l' r'
04:51:06 <jermey> because parTreeMap didn't handle depth
04:51:27 <donri> kmels_: yeah it's how i like to do things. make everything a library, and the executables just import something and main = someFunction, and then depend on myself for test-suites
04:52:56 <donri> jermey: in deed! :) it would just recurse on itself, never reaching the "otherwise" case where we call treeMap
04:53:12 <kmels_> donri: hmm that is nice, is it possible to specify two libraries in one cabal file?
04:54:10 <donri> jermey: and that line basically says the same as (Branch v' l' r') but also tells the runtime system that it could be useful to evaluate v', l' and r' in parallel
04:54:15 <kmels_> well that might be unnecessary..
04:54:20 <donri> kmels_: no can do
04:55:43 <jermey> so something like v and l parallel, l and r parraell then pseq whole tree?
04:55:53 <towadako> shachaf, tcpdumping reveals various messages from my irc server to lambdabot which I will have to google before I understand
05:01:43 <donri> jermey: well, v and (l and r) in parallel. so parallel to something parallel
05:02:02 <donri> jermey: so potentially all three in parallel
05:02:13 <jermey> ok thanks
05:05:09 <Kwstas> \q
05:09:17 <kwstas> Hello! I'm using a datatype with 6 constructors. Is there any way to use deriving (Eq) for the five of them and create my own Equation function (==) for only the remaining one?
05:10:59 <donri> kwstas: kind of, with generics
05:12:02 <donri> kwstas: deriving (Generic); instance Eq ... where X == X = True; x == y = x `geq` y
05:12:06 <donri> http://hackage.haskell.org/packages/archive/generic-deriving/1.5.0/doc/html/Generics-Deriving-Eq.html
05:13:11 <donri> actually, not sure that does what i thought ...
05:13:41 <donri> oh, you just need instance GEq Foo, for each type you need
05:14:15 <donri> too bad it doesn't expose geqdefault
05:14:17 <donri> dreixel!
05:15:16 <kwstas> donri: ok, thanks anyway... (dreixel??)
05:15:49 <donri> it's his package (and i think he did the ghc extension too?)
05:16:22 <kwstas> oh! ok then :)
05:31:32 <dreixel> donri, kwstas: you'd need the default, yes
05:31:47 <donri> dreixel: it's not exported though :)
05:32:04 <dreixel> yes, I know. I couldn't think of why it could be necessary...
05:32:20 <donri> hehe
05:32:51 <dreixel> but, in the meantime, kwstas can copy its definition
05:33:49 <bitonic> byorgey: is it convenient, with ‘unbound’ to build up terms where for example you have to carry around variables taking care of shifting them when you enter a scope?  I’m currently using ‘bound’ that enforces that at the type level, but ‘unbound’ is much more featureful (in a sense precisely because it’s less ‘typed’, I’d imagine)
05:33:51 <kwstas> I'm little bit new to haskell... I cannot follow you a lot :) What should I copy?
05:36:07 <donri> kwstas: https://github.com/dreixel/generic-deriving/blob/master/src/Generics/Deriving/Eq.hs
05:36:34 <donri> kwstas: or alternatively add instance declarations for GEq for each type you need
05:37:08 <donri> you'll probably end up with more code than just writing the Eq instance by hand though, either way
05:37:12 <mauke_tmp> just write your instance manually
05:37:15 <mauke_tmp> it's much easier
05:39:30 <kwstas> donri, mauke_tmp: Yes, I'll probably keep my existing implementation... It's not such a big issue. I was just curious to find out if there is a build in and easy way to handle these sort of cases.
05:39:33 <true_droid> purely theoretical question: can I define this function? (+) :: (Num a) String -> a -> String, e.g. by introducing a new typeclass. Will it conflict with the default (+) :: (Num a) => a -> a -> a ?
05:39:45 <kwstas> Thanks for your help, again
05:39:55 <true_droid> I tried making a typeclass and it says that my Main.+ conflicts with Prelude.+
05:39:57 <quicksilver> yes, true_droid, there can only be one (+) in scope at once.
05:40:11 <quicksilver> you can certainly hide the standard one if you prefer your version.
05:41:20 <donri> true_droid: import Prelude hiding ((+))  -- but you probably don't want this
05:41:28 <quchen> > let (+) = (*) in 2 + 3
05:41:29 <lambdabot>   6
05:41:51 <donri> and you can shadow it in a local scope like quchen just showed
05:42:29 <true_droid> okay, thanks
05:42:35 <quchen> I would strongly suggest you don't hide (+) from Prelude and define your own. If you really need a custom "add" operation that's not the one from Num, give it your own name, e.g. <+>
05:42:38 <true_droid> I'm not trying to use this, just figuring out type classes
05:42:45 <true_droid> and their possibilities
05:43:08 <quchen> Oh. Well then you may want to consider writing an instance of Num, which lets you define your implementation of (+).
05:43:53 <quchen> Like "instance Eq Foo where Foo == Foo = ..." lets you define (and not re-define!) "==" for the Foo type
05:44:08 <donri> import Prelude.PHP  - from acme-php
05:44:14 <donri> s/-/--/
05:44:18 <quchen> donri: :P
05:44:19 <true_droid> quchen: but the Prelude.+ always expects the same type on both sides, doesn't it?
05:44:33 <quchen> true_droid: Yes.
05:45:06 <quchen> true_droid: But adding two different things seems weird. Maybe you could accomplish your goal with a typecast, so both operands have the same type?
05:45:30 <quchen> > fromIntegral 10 + pi
05:45:31 <lambdabot>   13.141592653589793
05:46:11 <quchen> fromIntegral converts any Integral type to a Num type. In this case, that Num type is a Double.
05:46:18 <quchen> Pi is a Double too, so + works just fine.
05:46:20 <true_droid> quchen: I'm trying to draw parallels between Haskell's typeclass-based overloading of functions and the overloading in other languages (by means of looking at the type of the receiver or the first argument)
05:46:42 <true_droid> what I image is that Haskell looks at the type of all arguments
05:46:49 <quchen> true_droid: My advice for drawing parallels efficiently: don't. :-)
05:47:22 <quchen> Think of a typeclass as a label "can do this". Eq things "can do" (==).
05:47:32 <quchen> Num things "can do" + - fromIntegral
05:48:25 <supki> s/fromIntegral/fromInteger/
05:49:04 <quchen> Since you said "overloading", you're probably familiar with C++. If you want to sort something there, you have to have the "<" operator overloaded for the stuff in your list/vector/...
05:49:36 <quchen> If your classes don't have that operator overloaded, you get a premium sized C++ compiler error.
05:50:19 <quchen> In Haskell, it would say "no Ord instance for type XY"
05:51:49 <quchen> The problem here in C++ is you don't see whether "<" is needed from the type signature of a function. sort has type "T sort(T& foo const)" or something along those lines.
05:52:48 <quchen> The naively equivalent Haskell type for that would be "sort :: [a] -> [a]". But if you implement sort, you'll see that its type is actually derived to be "(Ord a) => [a] -> [a]".
05:52:58 <tdammers> the problem is worse than that in C++: the same mechanics apply to regular methods, and methods match on name (and signature) alone, which leads to false positives when names clash
05:53:01 <quchen> So the type tells you that it's a function that requires "<" and all that stuff.
05:53:11 <true_droid> quchen: there are type traits in C++, but they're mostly hacks and the syntax is shit, no arguing about that
05:53:28 <true_droid> quchen: thanks, I'll read about typeclasses' nature in more detail
05:53:38 <quchen> true_droid: Four planks weren't enough so they added type traits? :-)
05:54:04 <Chousuke> C++ sort is also only implementable as a template, and requires a new instantiation for each type.
05:54:09 <true_droid> quchen: they were discovered I believe. Boost is littered with those, even prior to C++11
05:54:13 <Chousuke> Haskell sort doesn't
05:57:21 <true_droid> Chousuke: I'm curious about how Haskell doesn't need instantiation. It's because it only supports those type that explicitly define the function in question?
05:58:14 <quchen> Good point. I'm not sure what GHC does on the fundamental level. I would think it *does* instantiate on a per-type basis.
05:58:24 <quchen> (But that's just a guess)
05:58:26 <Chousuke> it can, but I don't think it has to
05:58:29 <arkeet> no, sort is just another polymorphic function.
05:59:08 <Chousuke> As far as I understand it will just pass the "instance" of Ord as a parameter behind the scenes
05:59:18 <arkeet> the dictionary, yes
05:59:47 <shachaf> quchen: See polymorphic recursion.
05:59:51 <mauke_tmp> the "instance" is like a vtable
06:00:19 <shachaf> Hmm, only somewhat like a vtable.
06:00:22 <true_droid> so it's a dynamic dispatch in Haskell
06:00:32 <true_droid> where C++ does instantiation to make it a static dispatch
06:01:15 <Chousuke> well, ghc knows what the type will be at compile time.
06:01:30 <mauke_tmp> ghc can also specialize functions, but it's a compiler optimization, not a language construct
06:02:03 <shachaf> Well, the language construct doesn't specify anything about dictionary passing etc. either.
06:02:03 <arkeet> typeclass constraints are really just implicit function arguments
06:02:13 <shachaf> It's only one way to implement it.
06:02:13 <arkeet> at least, with GHC.
06:02:39 <arkeet> and I think it's a good way to think about them.
06:02:47 <shachaf> Yes.
06:03:06 <shachaf> (Though you probably need Rank2Types for this sort of thinking to really work.)
06:03:14 <arkeet> you do?
06:03:24 <shachaf> Well, what does the dictionary for Monad look like?
06:03:35 <mauke_tmp> { bind, return }
06:03:36 <arkeet> oh, fine.
06:03:52 <shachaf> mauke_tmp: With what types?
06:03:59 <mauke_tmp> no types
06:05:00 <shachaf> OK, I suppose. But now you're not translating into Haskell.
06:05:28 <quchen> shachaf: What does polymorphic recursion have to do with instantiation here? Do they contradict each other somehow?
06:05:40 <mauke_tmp> .oO( if I wanted to translate into Haskell, I'd compile my code with cat )
06:05:46 <arkeet> quchen: same reason you can't inline a recursive function.
06:06:01 <arkeet> er, not reason. whatever.
06:06:19 <shachaf> quchen: Try it out.
06:06:36 <shachaf> Instantiate a polymorphically-recursive function.
06:06:53 <shachaf> 水の
06:06:56 <shachaf> Er.
06:06:58 <quchen> (Are we talking about the same "instantiation" here?)
06:07:01 <arkeet> 音
06:07:30 <quchen> I thought our "instantiation" here was the C++-style one, where each call to a function with new types generates its own object code
06:07:54 <arkeet> I suppose you're going to generate an infinite amount of code for a function with polymorphic recursion.
06:08:01 <shachaf> Lazy compilation!
06:08:06 <arkeet> fine.
06:08:18 <arkeet> but then that's not really different from what happens.
06:08:32 <mauke_tmp> just-too-late compilation
06:09:31 <quchen> arkeet: Only for sufficiently complicated nestings, no?
06:09:58 <shachaf> Does it matter how complicated they are?
06:10:12 <arkeet> @let funny :: Show a => Int -> a -> String; funny 0 x = show x; funny n x = funny (n-1) [x]
06:10:14 <shachaf> You said GHC does this "instantiation" thing.
06:10:15 <lambdabot>  Defined.
06:10:16 <arkeet> > funny 5 ()
06:10:18 <lambdabot>   "[[[[[()]]]]]"
06:10:33 <arkeet> > funny (-1) ()
06:10:36 <lambdabot>   mueval-core: Time limit exceeded
06:10:42 <arkeet> > take 100 $ funny (-1) ()
06:10:46 <lambdabot>   mueval-core: Time limit exceeded
06:10:52 <mauke_tmp> > let foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x); foo :: (Show a) => Int -> a -> String in foo 3 'c'
06:10:52 <arkeet> :/
06:10:53 <lambdabot>   "((('c','c'),('c','c')),(('c','c'),('c','c')))"
06:11:22 <mauke_tmp> > let foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x); foo :: (Show a) => Int -> a -> String in foo 2 'I'
06:11:24 <lambdabot>   "(('I','I'),('I','I'))"
06:11:24 <shachaf> I,I foo 3 (var "I")
06:11:42 <mauke_tmp> > let foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x); foo :: (Show a) => Int -> a -> String in foo 2 (var "I")
06:11:44 <lambdabot>   "((I,I),(I,I))"
06:11:50 <arkeet> shachaf: :|
06:11:57 <shachaf> arkeet: ?
06:12:09 <arkeet> shachaf: I,I
06:12:28 <quchen> Ah, I think I get it. The problem wouldn't be there if during compile time, the "depth" of the instantiations would be known. That's of course not the case in a library etc.
06:12:39 <quchen> Take the Wikipedia example: http://en.wikipedia.org/wiki/Polymorphic_recursion
06:12:47 <arkeet> take any example.
06:12:56 <arkeet> the depth could even be determined at runtime.
06:13:01 <arkeet> it could even be infinite.
06:13:08 <quchen> I thought "well, this goes up to a nesting up to 2D lists, so it should work wit a 2-level instance"
06:15:11 <shachaf> It could be infinite, or worse!
06:15:32 <quchen> Suddendly, a Gdel sentence!
06:15:41 <quchen> -d
06:18:07 <mauke_tmp> template<typename T> void foo(int n, T x) { if (n <= 0) { cout << x; return; } foo(n - 1, std::pair<T, T>(x, x)); }
06:42:17 <parcs> c++ is powerful
06:46:34 <t7> C++ has a stronger type system than agda
06:46:46 <t7> unbounded recursion
06:47:41 <merijn> 〆(・∀・＠)
06:48:25 <capisce> C++ can roundhouse kick you in the face. With both legs simultaneously.
06:49:19 <mauke_tmp> this is known as "multiparadigm"
06:54:50 <parcs> mauke_tmp: that doesn't work :(
06:55:03 <parcs> the templates get recursively instantiated forever
06:56:06 <mauke_tmp> of course
06:56:17 <mauke_tmp> do you feel the RAW POWER of the STRONG TYPES?
06:58:23 <t7> infinity powerful
06:58:37 <t7> infinitely
07:07:57 <Sculptor> yo
07:09:31 <hamid> Sculptor, yo
07:13:57 <dmwit> ?unmtl StateT [a] [] b
07:13:57 <lambdabot> [a] -> [(b, [a])]
07:14:44 * dmwit wonders briefly: does anybody understand the mtl so well that they never unroll the type stack any more to check in on it?
07:15:07 <arkeet> ?unmtl ReaderT r m a
07:15:07 <lambdabot> r -> m a
07:18:39 <danr> dmwit: no, noone does. btw, in which package is unmtl defined? ;)
07:28:02 * hackagebot snap-predicates 0.2.0 - Declarative routing for Snap.  http://hackage.haskell.org/package/snap-predicates-0.2.0 (ToralfWittner)
07:28:06 <dmwit> hah, I don't know how to run unmtl except in #haskell =P
07:28:40 <tromp> >344+676
07:29:22 <dmwit> > 344+676
07:29:24 <lambdabot>   1020
07:56:28 <joey_trey> Ok struggling to understand how to use "case of" when dealing with list comprehension. For example. function xs = case ??? of <[p] -> ...><(p:ps) -> ...> what do I put in the place of ???
07:57:05 <quicksilver> joey_trey: xs
07:57:18 <quicksilver> (what does your question have to do with list comprehensions?)
07:58:44 <joey_trey> ok so the function is taking a list as an argumen, And I want to take case one if the list has only one thing in it and case 2 if there is more than one thing in the list
07:59:05 <quicksilver> joey_trey: yup.
07:59:15 <quicksilver> joey_trey: you put xs as the ???
07:59:24 <quicksilver> because xs is the list you're taking as an argument.
07:59:44 <joey_trey> ok ill try that thanks mate
07:59:49 <quicksilver> normally you'd just write the two cases of hte function rather than using case of, but it's useful to understand the syntax.
08:01:21 <ski> > let function xs = case xs of [p] -> "Just one, dave : " ++ show p; p:ps -> "One " ++ show p ++ " and then some more : " ++ show ps; _ -> "Sorry, can't help" in function [2,3,4]
08:01:23 <lambdabot>   "One 2 and then some more : [3,4]"
08:01:25 <geekosaur> also note that a list comprehension is not a different type from a list, it's just an expression that can generate a list
08:01:44 <ski> > let function [p] = "Just one, dave : " ++ show p; function (p:ps) = "One " ++ show p ++ " and then some more : " ++ show ps function _ = "Sorry, can't help" in function [2,3,4]
08:01:45 <lambdabot>   <hint>:1:136: parse error on input `='
08:02:00 <ski> > let function [p] = "Just one, dave : " ++ show p; function (p:ps) = "One " ++ show p ++ " and then some more : " ++ show ps; function _ = "Sorry, can't help" in function [2,3,4] -- missing `;'
08:02:03 <lambdabot>   "One 2 and then some more : [3,4]"
08:03:03 * hackagebot hakyll-blaze-templates 0.1.0.0 - Blaze templates for Hakyll  http://hackage.haskell.org/package/hakyll-blaze-templates-0.1.0.0 (SimonasKazlauskas)
08:03:35 <cschneid> What's the documentation library that looks like: " -- ^ Substring to search for (@needle@)"
08:03:42 <cschneid> and --| and similar magic tokens
08:03:50 <geekosaur> haddock
08:03:53 <mauke_tmp_> haddock
08:04:06 <cschneid> and it's the standard inline-docs syntax?
08:04:19 <geekosaur> for haskell, yes
08:04:26 <cschneid> right. And thanks :)
08:04:27 <Eduard_Munteanu> FSVO standard.
08:04:43 <Eduard_Munteanu> (not part of Haskell98/2010, but common)
08:05:06 <mauke_tmp_> unless you're oleg. then it's just bird tracks
08:26:28 <latermuse> can someone recommend a simple graphics library?
08:27:06 <Eduard_Munteanu> latermuse: what sort of stuff do you want to draw?
08:29:03 <latermuse> Eduard_Munteanu: Just some simple graphics demos. Maybe a pong clone
08:29:15 <latermuse> 2d
08:31:03 <latermuse> i cant find anything recent on google. It all seems to be years outdated
08:32:21 <elliott> latermuse: try gloss
08:33:57 <latermuse> elliot: wow looks great. thanks
08:37:19 <haasn> gloss is my tool of choice for pong clones
08:37:40 <haasn> see gloss in action here: http://hdiff.luite.com/gloss/pong/
08:37:45 <latermuse> haasn: im reading gloss tutorials now while compiling the libraries. im excited to test it out
08:38:58 <elliott> haasn: you should fix the part where it's impossible.
08:41:57 <latermuse> wow look at the javascript code on that pong game. extraordinary!
08:44:13 <elliott> latermuse: that's like saying "look at the assembly GHC outputs" :P
08:44:51 <haasn> I'm surprised it runs at all (at a pace faster than several seconds per frame)
08:45:19 <latermuse> it runs smoothly on my computer
08:45:40 <latermuse> way out of this world
08:47:12 <Eduard_Munteanu> Hm, people in here change nicks everyday.
08:47:14 <haasn> runs more or less smoothly here
08:47:25 <haasn> though the other ones work a bit less well
08:47:26 * Eduard_Munteanu stares at haasn 
08:47:31 <haasn> Eduard_Munteanu: blame shachaf!
08:47:42 <haasn> he compelled me to change it
08:47:50 <Eduard_Munteanu> haasn: oh? Why? :/
08:47:55 <haasn> because of the `` thing
08:48:02 <haasn> and ‘nand’ itself was taken
08:48:09 <Eduard_Munteanu> Heh.
08:48:32 <Eduard_Munteanu> That'd be even harder to type.
08:48:38 <elliott> what about "‘nand’"
08:48:52 <haasn> elliott: I haven't checked, though I imagine that would be even worse than `
08:48:58 <aCube> What are the controls for the pong game?
08:49:11 <Eduard_Munteanu> haasn: what was wrong with `nand`? You looked like an operator.
08:49:21 <haasn> exactly!
08:49:32 <haasn> aCube: up and down arrow keys to move the left (your) paddle
08:49:35 <haasn> nothing else
08:49:57 <Eduard_Munteanu> I guess "`nand`: <message>" didn't make much sense as prefix. :)
08:50:34 <haasn> Eduard_Munteanu $ and how about this?
08:51:00 <Eduard_Munteanu> Now you make me look like a constructor. I don't want to be a constructor. :(
08:51:04 <elliott> haasn is a smooth operator
08:51:09 <haasn> you'd rather be a prism?
08:51:10 <Eduard_Munteanu> :)
08:52:29 <Eduard_Munteanu> I should probably /nick eduardMunteanu
08:55:54 <scooty-puff> is it possible to have the old behavior of GHC.Generics (Par0) by some other means, where a type parameter could be detected?  i have defined a type class for heterogeneous mapping with default signatures, where type class instances look like Heterogeneous f (a, b) (f a, f b), Heterogeneous f (Either a b) (Either (f a) (f b)), but cannot use the default generic definition for [a] (Heterogeneous f [a] [f a]) - there is non-parame
09:02:25 <hpaste> scooty-puff pasted “Heterogeneous” at http://hpaste.org/86838
09:05:08 <ocharles> win 10
09:05:11 <ocharles> ahem
09:05:20 <typoclass> fail 10? :-)
09:05:27 <ocharles> :)
09:09:44 <no-n> how can I get colours when writing the shell ?
09:10:11 <no-n> (on linux)
09:10:55 <haasn> depends on the terminal
09:11:52 <facepalm> hello I am trying to write a haskell function using 3 of my previous functions  that takes list of pairs as a param and Just returns a pair whos first element is the pair of  x extrema and second is a pair of y extrema could someone give me a hint of what I am doing wrong please?
09:11:53 <haasn> try eg. putStrLn "\ESC[36;1mhello, world\ESC[m"
09:11:56 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/86840
09:12:44 <acube> @hackage ansi-terminal
09:12:44 <lambdabot> http://hackage.haskell.org/package/ansi-terminal
09:12:45 <geekosaur> why are you asking that here instead of e.g. #bash?
09:12:55 <geekosaur> (for no-n)
09:13:09 <no-n> haasn: that works
09:13:11 <geekosaur> ...oh
09:13:19 * geekosaur grumbles, notwork fell over
09:13:36 <geekosaur> noturally that went through after it came back...
09:14:59 <hiptobecubic> :hoogle Either a b -> Bool
09:15:02 <hiptobecubic> @hoogle Either a b -> Bool
09:15:03 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
09:15:03 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
09:15:03 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
09:15:13 <haasn> :t either (const False) (const True)
09:15:16 <lambdabot> Either a b -> Bool
09:15:30 <haasn> :t isRight
09:15:32 <lambdabot>     Not in scope: `isRight'
09:15:33 <lambdabot>     Perhaps you meant one of these:
09:15:33 <lambdabot>       `isDigit' (imported from Data.Char),
09:15:34 <haasn> ah
09:15:36 <hiptobecubic> haasn, yes :) Just wanted to see if it was already out there
09:15:44 <haasn> :t isJust
09:15:46 <lambdabot> Maybe a -> Bool
09:15:49 <haasn> okay so we have that one
09:16:17 <supki> @ty has _Right
09:16:20 <lambdabot> Either c a -> Bool
09:16:31 <facepalm> I should be able to do it all in 1 case
09:16:38 <haasn> supki: very nice
09:17:06 <elliott> neither of those should exist :(
09:17:40 <hiptobecubic> stacking monads kind of sucks
09:17:49 <acube> no-n: You might also be interrested in the ansi-terminal package on hackage
09:17:51 <acube> @hackage ansi-terminal
09:17:51 <lambdabot> http://hackage.haskell.org/package/ansi-terminal
09:18:04 <acube> It provides functions for colored output
09:18:11 <hiptobecubic> IO (Writer (State (IO)))
09:18:52 <acube> hiptobecubic: What is that? A writer of States? :O
09:18:53 <no-n> acube: thanks, I'll look into it
09:19:04 <haasn> a kind error is what it is
09:19:14 <hiptobecubic> acube, main runs a writer which runs a state that also has to do io
09:20:18 <acube> hiptobecubic: Do you know about monad transformers?
09:20:45 <hiptobecubic> I am indeed using monad transformers
09:20:51 <haasn> :t isn't
09:20:53 <lambdabot> APrism s t a b -> s -> Bool
09:21:03 <haasn> :t is
09:21:05 <lambdabot>     Not in scope: `is'
09:21:05 <lambdabot>     Perhaps you meant one of these:
09:21:05 <lambdabot>       `id' (imported from Data.Function),
09:21:11 <acube> :t hasn'
09:21:14 <acube> :t hasn't
09:21:14 <lambdabot>     Not in scope: hasn'
09:21:14 <lambdabot>     Perhaps you meant `hasn't' (imported from Control.Lens)
09:21:15 <lambdabot> Getting All s t a b -> s -> Bool
09:21:22 <hiptobecubic> :t wasn't
09:21:24 <lambdabot>     Not in scope: `wasn't'
09:21:24 <lambdabot>     Perhaps you meant one of these:
09:21:24 <lambdabot>       `hasn't' (imported from Control.Lens),
09:21:36 <hiptobecubic> What!? Tardis isn't part of lens?
09:21:40 <latermuse> this 'stab' in lens is surely an inside joke, no?
09:21:47 <haasn> hasn't = isn't ?
09:21:51 <haasn> oh, not quite
09:21:55 <haasn> hasn't is for any fold
09:21:55 <acube> :t is
09:21:57 <lambdabot>     Not in scope: `is'
09:21:57 <lambdabot>     Perhaps you meant one of these:
09:21:57 <lambdabot>       `id' (imported from Data.Function),
09:22:26 <acube> Yes, I think hasn't + has are the generalized isn't + is (which doesn't exist)
09:22:26 <haasn> > isn't _Empty [1,2,3] -- neat
09:22:31 <lambdabot>   mueval-core: Time limit exceeded
09:22:44 <acube> > [1,2,3] ^? _Empty
09:22:46 <lambdabot>   Not in scope: `_Empty'
09:22:47 <lambdabot>  Perhaps you meant one of these:
09:22:47 <lambdabot>    `empty' (importe...
09:22:55 <haasn> Cale!!
09:22:58 <acube> :t empty
09:22:59 <lambdabot> Alternative f => f a
09:23:10 <FireFly> @ty has
09:23:13 <lambdabot> Getting Any s t a b -> s -> Bool
09:27:36 <JordiGH> Is Hask a topos?
09:27:47 <facepalm> perhaps something like bounds2[(x,y)] = x <-fsts [(x, y)] y<-snds[(x,y)] bounds1[x,y]
09:27:48 <JordiGH> It seems like it is, since it's a concrete category...
09:27:55 <JordiGH> Well, I think it's a concrete category.
09:28:00 <elliott> I think Hask is technically not even a category.
09:28:15 <JordiGH> elliott: Why not? What's it missing?
09:28:31 <tac> JordiGH: Haskell doesn't have pullbacks or pushouts.
09:28:31 <elliott> I think it violates the laws because of _|_ or something. don't look at me, I'm not a category theorist!
09:28:38 <elliott> I just play one on IRC.
09:29:06 <JordiGH> tac: Eh? You don't need  those for a topos, do you?
09:29:21 <acube> > undefined . id $ 3
09:29:23 <lambdabot>   *Exception: Prelude.undefined
09:29:23 <tac> JordiGH: Topoi must have all finite limits and colimits.
09:31:43 <tac> JordiGH: http://ncatlab.org/nlab/show/topos
09:31:58 <otters> :t undefined . id
09:32:00 <tac> Ctrl+F finite limits
09:32:00 <lambdabot> b -> c
09:32:34 <JordiGH> tac: idk, it looked to me like Set was a subcategory of Hask.
09:33:18 <tac> JordiGH: No. The problem is essentially that algebraic data types aren't powerful enough to capture interesting constraints
09:33:54 <tac> Algebraic data types are "free" structures, and you can't, say, define a data type of "prime numbers"
09:34:36 <JordiGH> Hm, so it's like we don't have an axiom of comprehension?
09:34:56 <tac> that's basically what a dependent sum type is
09:35:16 <tac> pairs where the second element in the pair's type depends on the first
09:38:33 <hpaste> facepalm revised “Haskell function”: “Haskell function” at http://hpaste.org/86840
09:40:39 <facepalm> if anyone has time to take a peek at that  it would be great.  I can repost question too if needed ty!
09:40:44 <dolio> Free things often allow you to include constraints, although probably not primality.
09:41:21 <dolio> But algebraic data types only include the generator part of freeness, not the equation part.
10:11:12 <dmwit> facepalm: I missed the question, but bounds2 just looks... wrong
10:11:35 <dmwit> Perhaps a good pedagogical question: which values do you expect the pattern "[(x,y)]" to match?
10:12:05 <dmwit> (Maybe you are confusing term-level patterns and types, which is one common beginner mistake.)
10:12:15 <klrr> how do i implement macros in my lisp implementation?
10:14:07 <Chousuke> implement a way to have functions be run at compile time and eval the result
10:14:32 <dmwit> klrr: Can you make the question more concrete?
10:14:34 <Botje> klrr: which part are you having trouble with? detecting macro usage or expanding them?
10:14:43 <dmwit> Why should we believe that implementing macros is hard?
10:19:59 <klrr> dmwit: well it's sounds scary and im not sure if i even understand what macros do yet :x
10:20:00 <Raynos> What does `>>` do for monads?
10:20:10 <elliott> depends on the monad.
10:20:15 <elliott> m >> n is the same as do { m; n }
10:20:22 <elliott> or m >>= \_ -> n
10:20:46 <Raynos> intuitively I understand `>>=` as `flatMap` or `bind`
10:20:55 <Tene> klrr: First determine what you want to implement, then implement it.  Go read about macros, hygenic macros, etc.
10:21:07 <Cale> With a computational intuition, it means the action which first runs m, and then runs n, producing the result of n as its result, and ignoring the result of m.
10:21:10 <Raynos> is `m >> n` just a way to have the "side effect" of doing one monad after the other?
10:21:30 <Cale> You don't do one monad after the other. Monads aren't values.
10:21:40 <Cale> You do one action after the other :)
10:21:41 <Iceland_jack> > Just undefined >> Just 5
10:21:44 <lambdabot>   Just 5
10:21:47 <Iceland_jack> > Nothing >> Just 5
10:21:49 <lambdabot>   Nothing
10:22:02 <Cale> But yes, apart from the terminology, that's right
10:22:09 <Raynos> What is the name for `>>=` ?
10:22:09 <elliott> > [1,2,3] >> [4,5,6]
10:22:11 <lambdabot>   [4,5,6,4,5,6,4,5,6]
10:22:13 <Iceland_jack> Raynos: Bind
10:22:13 <Cale> "bind"
10:22:13 <elliott> Raynos: bind
10:22:23 <otters> heh
10:22:55 <Iceland_jack> In general you can think of (a >>= b) as feeding the output of a into b, and (a >> b) as running a and then b ((>>) is called ‘then’)
10:23:07 <otters> @pl \x y -> [1..x] >> [y]
10:23:07 <lambdabot> (. return) . (>>) . enumFromTo 1
10:23:08 <Iceland_jack> it doesn't quite hold for every monad but it should give you the rough idea
10:27:30 <facepalm> dmwit: bounds2 is meant to take a list of pairs as a param and returns Just a pair whos first element is the pair of x extrema second element is the pair of y extrema and do this using 3 of the previous functions
10:31:48 <Cale> Raynos: Or, slightly more precisely, x >>= f = do { v <- x; f v } is the action which first runs x :: M a, then applies f :: a -> M b to the result and runs that action, producing its result as the result of the whole thing. What it means to "run" something will depend on the given monad.
10:32:39 <Cale> For instance, in the list monad, "running" a list means picking an element from it in all possible ways.
10:32:55 <Cale> > [1,2,3] >>= (\x -> [x, 10*x])
10:32:57 <lambdabot>   [1,10,2,20,3,30]
10:33:46 <Cale> So, we "run" the list [1,2,3], picking some element x from it, and then we "run" the list [x,10*x], picking an element of that, to obtain an element in our overall list.
10:34:52 <Cale> In the IO monad, what "running" means is perhaps somewhat more obvious (though it's much more complicated in detail) -- it means to actually carry out the instructions described by the IO action and cause their effects to occur.
10:36:35 <Cale> In a parsing monad, the actions are parsers, and running one of those means allowing it to attempt to eat some of the input in order to produce a parsed result
10:36:46 <Cale> Raynos: Perhaps that helps? :)
10:38:59 <conehead> It certainly helped me (specifically the non-IO examples) -- thanks for that
10:41:14 <Raynos> Cale: vaguely :)
10:43:49 <Cale> Raynos: In the abstract case, it's hard to know what (>>=) and return actually do (it's dependent on which monad you're talking about, be it IO or Maybe or lists, or Parsers, or a state monad, or STM, etc. etc.), but you can always think about their behaviour in terms of a few examples once you have some under your belt.
10:44:12 <Cale> You don't really need to know much about monads generally to use specific libraries which happen to define a monad instance -- just that you can replace 'm
10:44:26 <Cale> 'm' in various types with the particular monad in question, like IO
10:44:39 <Cale> For example, it helps to know that you can specialise:
10:44:42 <Cale> :t sequence
10:44:44 <lambdabot> Monad m => [m a] -> m [a]
10:44:46 <Cale> to
10:44:51 <Cale> [IO a] -> IO [a]
10:45:48 <hpaste> facepalm revised “Haskell function”: “Haskell function” at http://hpaste.org/86840
10:45:59 <facepalm> perhaps this insead is closer?
10:46:00 <Cale> But even just a couple of things like that (sequence is occasionally nice, forM or mapM and replicateM also help to know about, perhaps forever is good), and you can work with IO pretty sensibly.
10:46:51 <tomboy64> i am having a look at vty/vty-ui and there are only 2 packages depending on it; hach and matsuri
10:47:08 <tomboy64> are there other curses-like haskell libs?
10:48:20 <skyflash> tomboy64: there's hscurses and ncurses at least.
10:49:40 <tomboy64> skyflash: but both are only wrappers for ncurses in c, right?
10:50:14 <skyflash> tomboy64: that's right.  Also, both have a few little issues AFAICT.
10:50:20 <Clint> tomboy64: http://packdeps.haskellers.com/reverse/vty
10:50:29 <tomboy64> Clint: seen that
10:50:48 <dmwit> facepalm: As written, bounds2 accepts *only* lists of length 1.
10:50:51 <Clint> then why'd you say only two packages
10:51:05 <dmwit> facepalm: (The pattern "[(x,y)]" is shorthand for "(x,y):[]", if that helps you understand why.)
10:51:21 <dmwit> < 1 < \_ -> 2
10:51:25 <skyflash> tomboy64: I've found that ncurses doesn't allow the use of colour because terminals seem to respond with -1 max colour pairs, which confuses the library.
10:51:26 <goodfellow>   mueval-core: Time limit exceeded
10:51:34 <facepalm> dmwit: so do I need to do like (x:y:xs) ?
10:51:39 <skyflash> tomboy64: Probably an easy fix though.
10:51:45 <dmwit> facepalm: Why not just "xs"?
10:52:05 <dmwit> Your other functions know how to handle both empty and non-empty lists, so why differentiate?
10:52:10 <facepalm> and that will accept a list of pairs?
10:52:10 <skyflash> tomboy64: hscurses is missing a way to set the background on windows AFAICT.  Also probably a small fix.
10:52:23 <tomboy64> hm
10:52:40 <tomboy64> vty-ui seems to be a rather good choice then
10:53:18 <skyflash> tomboy64: vty-ui is the one I haven't actually tried.  I'll probably be doing that soon, as I was fighting with ncurses and hscurses all weekend!
10:53:26 <tomboy64> or seems to be ^^
10:53:59 <tomboy64> well, it's supposed to provide actual widgets instead of the basic support of vty
10:54:06 <tomboy64> building on top of vty
10:55:28 <dmwit> facepalm: I'm not really sure how to answer that question. I mean, the immediate answer is "yes", but the existence of the question suggests there's a fundamental misunderstanding somewhere that we should strive to correct.
10:56:02 <facepalm> dmwit: I agree with you, because I am rather new to haskell
10:56:09 <dmwit> facepalm: The pattern "xs" (that is, just a variable name) matches _any_ value. Doesn't matter what type that value has.
10:56:13 <skyflash> tomboy64: Also seems like vty is being actively maintained... which is always nice :-)
10:56:45 <fragamus> http://www.willamette.edu/~fruehr/haskell/evolution.html
10:56:51 <tomboy64> hahahaha
10:56:55 <fragamus> I really want to understand that^^^
10:57:02 <tomboy64> been trying to package a bunch of java crap the other day
10:57:13 <tomboy64> half of the packages hasn't been touched in 5 years
10:57:35 <tomboy64> they just get pulled in upon build as pre-provided libs
10:57:40 <tomboy64> rightout ugly
10:58:15 <dmwit> fragamus: Which one is giving you trouble?
10:58:17 * hackagebot fixed-vector 0.4.1.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.4.1.0 (AlexeyKhudyakov)
10:58:41 <fragamus> dmwit: well the penultimate one
10:59:04 <fragamus> but I dont understand some of the others either
10:59:25 <dmwit> Okay. Have you seen the trick to break ADTs down into fixpoints of pattern functors?
10:59:34 <facepalm> dmwit: I changed it to this bounds2 xs = (fsts xs, snds xs) and it works but I still need to use bounds1 around it I think and Just so I end up with ((num,num))
10:59:34 <fragamus> nope
10:59:36 <dmwit> (e.g. the Mu, cata, and instance Functor stuff at the top?)
10:59:37 <skyflash> tomboy64: there's definitely a kind of "dll hell" with packages.  Hackage has a lot of toy projects as well as the big, well-supported, almost 'canonical' packages (of course the real canonical ones might be in the HP).
10:59:43 <fragamus> nope
10:59:49 <fragamus> gimmie
11:00:00 <tomboy64> skyflash: HP?
11:00:14 <skyflash> tomboy64: sry... Haskell Platform
11:01:19 <fragamus> I really want to make *some* progress understanding this
11:01:31 <dmwit> I'm looking for a good reference to give you, one moment.
11:02:42 <dmwit> I guess "Functional Programming with Bananas, Lenses, Envelopes, and Barbed Wire"?
11:02:46 <dmwit> (Not that kind of lenses.
11:02:47 <dmwit> )
11:03:10 <skyflash> Wow, vty-ui also has... *documentation*  (colour me shocked!).
11:04:03 <fragamus> dmwit: thanks man
11:04:05 <dmwit> facepalm: What should bounds2 do differently from bounds1?
11:04:24 <dmwit> Oh, I see.
11:04:35 <dmwit> Yes, why not just call bounds1 after doing the split with fsts and snds?
11:04:50 <dmwit> Then you will need to combine your two Maybe values.
11:05:04 <dmwit> So write something of type Maybe a -> Maybe b -> Maybe (a,b).
11:05:09 <dmwit> There are many good ways to write this.
11:06:02 <tomboy64> skyflash: it also has a nice test program for making sure your terminal supports its tinkering
11:06:07 <schellan> does anybody have a lead on a tool to watch a directory for file changes and autmatically recompile?
11:06:52 <tomboy64> i think i read something bout yi being able to do that.
11:06:52 <tomboy64> i might be mistaken, though. @schellan
11:07:10 <schellan> i know yesod does this somehow with ghci
11:07:27 <schellan> was hoping it had been abstracted out into a package
11:07:47 <facepalm> it returns Just a pair whos first element is a pair of x extrema and second element is a pair of y extrema. like bounds2[(1,2), (3,4), (0,0)] will return ((0,4))
11:07:50 <Clint> schellan: look for packages that end in *notify
11:08:03 <facepalm> should be able to do it with only 1 case
11:08:20 <schellan> Clint: thanks, checking
11:09:35 <fragamus> dmwit: oh yeah not our kind of lenses
11:10:15 <tomboy64> schellan: http://hackage.haskell.org/package/codemonitor
11:10:52 <schellan> tomboy64: awesome, thanks - i was just looking at fsnotify
11:13:28 <klrr> can someone help me with a little problem? https://gist.github.com/klrr/5483513 i get a type error which i do not understand, basically it says it returns wrong value but that's in the case expression not the funtion itself, any ideas how to solve this? (code and error in paste)
11:14:55 <danr> klrr: so the usual practice when you ask questions like this is to minimize to a small self-contained problem
11:14:59 <dmwit> klrr: Perhaps you meant "case ... of Right (Bol True) -> ...; Right (Bol False) -> ...; _ -> ..."
11:15:16 <klrr> okey thanks!
11:15:37 <danr> klrr: also what dmwit said :)
11:15:47 <dmwit> klrr: Reading the error carefully displays this: it says you gave an Expr', but it was expecting a pattern for Either Err Expr.
11:16:35 <dmwit> s/an Expr'/a pattern for Expr'/;s/Either Err Expr/Either Err Expr'/
11:18:06 <hpaste> hiptobecubic pasted “Monad Trans Hangman” at http://hpaste.org/86851
11:18:30 <hiptobecubic> Everything in that "works", but can anyone comment on how it could be better reorganized?
11:18:43 <haskelluser> @pl \x y z -> f (g x y) z
11:18:43 <lambdabot> (f .) . g
11:18:46 <facepalm> dmwit: did you see the example I gave?  I have this now bounds2 xs = Just (fsts xs, snds xs) but if I add bounds1 xs after that it errors out.
11:19:04 <hiptobecubic> Specifically, I wanted to use monad-loops in main, but couldn't figure how to get whileM to behave how I wanted
11:19:41 <dmwit> facepalm: Did you see my hints for how to solve your problem?
11:19:41 <haskelluser> @pl \x -> i >>> s (l x)
11:19:41 <lambdabot> (i >>>) . s . l
11:20:06 <haskelluser> @pl \x -> i >>> s (l . x)
11:20:06 <lambdabot> (i >>>) . s . (l .)
11:20:17 <byorgey> hiptobecubic: renderWord could probably be much more simply implemented by a combination of 'map' and 'intersperse'
11:20:28 <hiptobecubic> haskelluser, /query lambdabot
11:20:45 <hiptobecubic> byorgey, ah yes. that one kind of grew organically
11:20:56 <hiptobecubic> byorgey, i thought maybe unfold? I don't konw
11:20:58 <hiptobecubic> know*
11:21:02 <facepalm> to add bounds2 :: Maybe a -> Maybe b -> Maybe(a,b) that?
11:21:05 <byorgey> hiptobecubic: unfold for what?
11:21:11 <hiptobecubic> render word?
11:21:20 <byorgey> why unfold?
11:21:23 <dmwit> facepalm: Absolutely not. You should write another function with that type and use it to implement bounds2.
11:21:27 <hiptobecubic> oh no i see what you mean with map.. yes that would be more clear
11:23:24 <hiptobecubic> Use 'if then else' always feels dirty
11:23:49 <dmwit> use fromEnum, that will make you feel clean
11:23:54 <facepalm> dmwit: I guess I am misunderstanding then and need to go do some more reading or something.I thought I could do it in just 1 line of code using 3 of my previously written functions
11:24:12 <hiptobecubic> :t fromEnum
11:24:16 <lambdabot> Enum a => a -> Int
11:24:29 <hiptobecubic> I don't see how that helps here :)
11:24:33 <Taneb> if then else should be a function rather than a construction.
11:24:38 <dmwit> facepalm: You can, if you're clever, but to begin with I would recommend doing something unclever that takes a few more lines.
11:24:54 <dmwit> > fromEnum False
11:24:56 <lambdabot>   0
11:24:57 <dmwit> > fromEnum True
11:24:59 <lambdabot>   1
11:25:16 <dmwit> :t \x c s -> x - fromEnum (c `elem` s)
11:25:19 <lambdabot> Eq a => Int -> a -> [a] -> Int
11:25:20 <dmwit> SO CLEAN
11:26:29 <danr> @pl \x c s -> x - fromEnum (c `elem` s)
11:26:29 <lambdabot> (. ((fromEnum .) . elem)) . (.) . (-)
11:26:31 <danr> cleaner!!
11:26:41 <hiptobecubic> clearly
11:27:24 <byorgey> :t const (const (const 0)) :: Eq a => Int -> a -> [a] -> Int
11:27:28 <lambdabot> Eq a => Int -> a -> [a] -> Int
11:27:30 <dmwit> I strive to make my code consist entirely of parentheses and dots.
11:27:32 <danr> now what does this function do?
11:27:35 <byorgey> the cleanest!
11:27:41 <hiptobecubic> bravo
11:28:24 <hiptobecubic> :t \g -> flip (if' =<< (`elem` g)) '_'
11:28:26 <lambdabot>     Not in scope: if'
11:28:27 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
11:28:41 <hiptobecubic> @let if' p a b = if p then a else b
11:28:46 <lambdabot>  Defined.
11:28:46 <hiptobecubic> :t \g -> flip (if' =<< (`elem` g)) '_'
11:28:49 <lambdabot> [Char] -> Char -> Char
11:28:59 <klrr> i suck i should kill myself
11:29:19 <dmwit> klrr is truly the dramaticest
11:29:32 <hiptobecubic> I think it's great
11:29:46 <hiptobecubic> spirit of the samurai
11:29:56 <oconnor0> and here i was going to say that not understanding haskell isn't a good reason to commit or threaten suicide.
11:30:09 <hiptobecubic> I'm sure that was the samurai's most common utterance
11:30:16 <kryft> #haskell-bushido
11:31:03 <oconnor0> kryft: seems to be an empty channel...
11:31:11 <Taneb> @tell klrr please don't really kill yourself.
11:31:11 <lambdabot> Consider it noted.
11:32:15 <hiptobecubic> byorgey, I was really concerned about main
11:32:49 <hiptobecubic> byorgey, mostly because I just threw my arms in the air and rubbed my butt on the keyboard until it compiled
11:33:24 <hiptobecubic> GHC, take the wheel!
11:33:26 <byorgey> hahaha
11:33:55 <byorgey>  I'd break it up into more functions, other than that, I dunno
11:34:23 <Boreeas> oconnor0: Well, I guess the people that enter don't stay there long
11:35:02 <hiptobecubic> I think this thing is ... switching monads bizarrely
11:35:36 <chrisdotcode> :t Monad
11:35:39 <lambdabot> Not in scope: data constructor `Monad'
11:36:00 <chrisdotcode_> :t Control.Monad
11:36:02 <lambdabot> Couldn't find qualified module.
11:36:33 <dmwit> Monad is a class, not a value.
11:36:50 <dmwit> It has kind * -> Constraint, if that's what you wanted to know.
11:36:57 <dmwit> uh
11:37:03 <dmwit> kind (* -> *) -> Constraint, I mean
11:37:28 <hiptobecubic> main is just IO (), playRound :: StateT Int IO (), play :: StateT Game IO (Either Game Game)...
11:37:36 <chrisdotcode_> dmwit: I had just <del>mastered</del> learned about monads from LYAH, and this great picture explanation from reddit, and I was trying to find the type signature
11:37:57 <chrisdotcode_> m a -> (a -> m b) -> a -> m b right?
11:38:06 <dmwit> :t (>>=) -- perhaps you wanted this?
11:38:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:38:16 <chrisdotcode_> dmwit: yeah, bind that's it :)
11:38:24 <chrisdotcode_> dmwit: and is it just me, or are monads really not that difficult? >_>
11:38:26 <dmwit> ?src Monad
11:38:26 <lambdabot> class  Monad m  where
11:38:26 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:38:26 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:38:26 <lambdabot>     return      :: a -> m a
11:38:26 <lambdabot>     fail        :: String -> m a
11:38:35 <dmwit> chrisdotcode_: They really are not that difficult.
11:38:49 <chrisdotcode_> dmwit: okay, good. thought I was a genius for a second :)
11:39:43 <Iceland_jack> chrisdotcode_: Glad you've come to your senses :)
11:40:00 <chrisdotcode_> Iceland_jack: it took a while, but I'm glad I didn't give into the hype :)
11:40:17 <chrisdotcode_> I don't quite understand the associative law just quite yet, so I'll go back to that later
11:40:40 <dmwit> chrisdotcode_: Have you seen the formulation of the laws in terms of return and (>=>) instead of return and (>>=)+
11:40:44 <dmwit> s/+/?/
11:40:57 <dmwit> :t (>=>) -- like composition, but with an extra "m" stuck in
11:40:58 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
11:41:01 <danr> chrisdotcode_: deceptively simple!
11:41:31 <chrisdotcode_> dmwit: sweet! monad piping (or something like it), right?
11:41:34 <dmwit> return >=> m = m >=> return = m; and the associativity law is (f >=> g) >=> h = f >=> (g >=> h)
11:41:37 <dmwit> chrisdotcode_: right
11:42:03 <dmwit> When spelled this ways, the laws look totally reasonable.
11:42:44 <dmwit> (In fact, they are just the laws for an identity and composition in a category... hooray!)
11:43:09 <chrisdotcode_> left and right identity I get, but the associative law looked complex at 2am, so I just decided to skip it
11:43:25 <chrisdotcode_> I only have to read two more chapters, then review, then onto real world haskell
11:43:36 <dmwit> Okay. In your own time. =)
11:43:49 <chrisdotcode_> haskell has completely destroyed me...
11:43:54 <chrisdotcode_> I can't think in terms of any langauges anymore...
11:43:59 <chrisdotcode_> *any other languages
11:44:17 <dmwit> That's how you know it's working!
11:44:23 <monochrom> the associative law is harder. but writing in do-notation is easier.
11:44:28 <chrisdotcode_> hahaha
11:44:44 <Botje> chrisdotcode_: i know the feeling. I spent thirty minutes in a piece of ruby before I realized I could just assign variables
11:44:57 <monochrom> http://www.haskell.org/haskellwiki/Monad_laws
11:45:40 <chrisdotcode_> Botje: and since I"m at a point where I can only barely program Haskell, I feel I can't go back down, but until I master recursion and learn the rest of haskell, I can't go up quite yet either...
11:46:28 <chrisdotcode_> by the way, is python's yield lazy evaluation, or lenient evaluation?
11:46:48 <schellsan> tomboy64: bummer - codemonitor depends on hinotify and a couple other pkgs that won't build
11:46:53 <schellsan> i'm on a mac
11:47:14 <Botje> chrisdotcode_: more like a delimited continuation >:)
11:47:26 <danr> hidden in an iterator
11:47:26 <tomboy64> schellsan: well, fsnotify depends on hinotify
11:47:34 <tomboy64> schellsan: port them :)
11:47:37 <chrisdotcode_> Botje: isn't that the same as laziness?
11:47:42 <chrisdotcode_> or really, really close?
11:47:46 <elliott> no
11:47:56 <chrisdotcode_> well values are generated only as needed
11:48:03 <elliott> it's not really delimited continuations either; it's more coroutines than anything
11:48:13 <tomboy64> ahh
11:48:24 <chrisdotcode_> def incr(n): yield n+1
11:48:27 <tomboy64> schellsan: inotify is linux-specific. darwin doesn't support that.
11:48:42 <hiptobecubic> well that's a shame because it's seriously fabulous
11:48:49 <schellsan> yeah, bummer - though fsnotify says it works on mac
11:48:52 <chrisdotcode_> def incr(n): yield n+ 1 == not lazy?
11:49:26 <hiptobecubic> chrisdotcode_, that's lazy, yes.
11:49:34 <elliott> os x has something like inotify i think
11:49:42 <luite> yeah fsevents
11:49:48 <chrisdotcode_> hiptobecubic: because elliott was saying that it wasn't...
11:50:00 <hiptobecubic> elliott, how is it not?
11:50:05 <elliott> chrisdotcode_: ok, you can argue that python generators model a lazy list/stream. it's not general lazy evaluation, just a list
11:50:18 <monochrom> python's yield does not have the full power of delimited continuation. however, you may still like to use delimited continuation to explain yield.
11:50:53 <chrisdotcode_> elliott: what's the different between a lazy stream and general lazy evaluation? isn't it all "get only when needed"?
11:51:00 <dmwit> Why can't it be lazy in the same sense that putting a bang on some stuff in a Haskell function makes it strict?
11:51:15 <luite> schellsan: fsnotify does use fsevents on mac, so it's efficient event based watching
11:51:21 <elliott> chrisdotcode_: data Tree a = Leaf a | Branch (Tree a) (Tree a)
11:51:27 <elliott> chrisdotcode_: how do you model this with a python generator?
11:51:39 <luite> schellsan: unfortunately the fsevents api si a bit flaky, the events it reports are often not quite correct, seems to be a bug in OS X itself
11:51:46 <elliott> your answer will be equivalent to an encoding of Tree a into [T a] (for some T)
11:52:21 <elliott> dmwit: well, I didn't say it wasn't lazy. I said it wasn't _laziness_, i.e. not the same thing
11:52:40 <chrisdotcode_> elliott: def traverse(node): yield traverse(node.left); print(node.content); yield traverse(node.right);
11:52:53 <elliott> I don't see much use in describing a language feature like generators as "lazy", though -- functions yes, whole languages yes, features not so much
11:53:00 <elliott> chrisdotcode_: that is not an encoding, it is a traversal
11:53:08 <elliott> you lose the entire tree structure
11:53:11 <chrisdotcode_> elliott: oh, oops
11:53:13 <luite> schellsan: so if you can patch it toch use fsnotify instead of hinotify that would work :)
11:53:15 <chrisdotcode_> elliott: yeah, true
11:53:36 <monochrom> elliott: you are right about needing to serialize the tree, and I did it in http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#yield-tree
11:54:04 <elliott> chrisdotcode_: def traverse(t): { if t.is_leaf: { yield 'leaf'; yield t.data } else: { yield 'branch'; yield traverse(node.left); yield traverse(node.right) } }
11:54:19 <elliott> chrisdotcode_: this would work. note how you are turning structure into a flat stream
11:54:22 <elliott> equivalently:
11:55:11 <elliott> data T a = TLeaf a | TBranch; traverse :: Tree a -> [T a]; traverse (Leaf a) = [TLeaf a]; traverse (Branch a b) = TBranch : traverse a ++ traverse b
11:55:34 <elliott> needless to say, working on this representation is not terribly pleasant :)
11:55:36 <bitonic`> when did Prelude stop exporting ‘catch’?
11:55:38 <chrisdotcode_> elliott: right...
11:56:15 <elliott> this may be a more accurate statement: laziness makes a list data structure of "a"s be the same as a Python generator of "a"s.
11:57:37 <c_wraith> that's very limited, but more or less true
11:57:40 <monochrom> ah, I see. given a lazy tree, I can serialize it in many orders. given a serialized tree, well now I can't choose another order.
11:58:09 <chrisdotcode_> ohh, okay. so what's this "lenient" evaluation I've heard of before?
11:58:20 * hackagebot fb 0.14.5 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.5 (FelipeLessa)
11:58:37 <c_wraith> no one has a clue what "lenient" evaluation is, since no one's bothered to define it. >_>
11:59:05 <monochrom> what is lenient evaluation?
11:59:27 <c_wraith> As far as I can tell from how I've seen it used, it's magically lazy-except-when-that-would-leak-space evaluation
11:59:50 <monochrom> "what does it mean to be lenient?" "what does it mean to be?" ... http://captionsearch.com/image.php?id=244 :)
12:00:01 <elliott> monochrom: btw, does mkgen really require IO?
12:00:03 <elliott> as opposed to just State or something
12:00:04 <chrisdotcode_> i always assumed lenient was python's "yield" model, and lazy was haskell's model
12:00:26 <monochrom> mkgen requires mutable cells. you could make it ST.
12:00:29 <chrisdotcode_> but now I know that python's streams are "lazy-ish" :)
12:00:31 <elliott> "Lenient, or optimistic, evaluation is an implementation approach that lies somewhere between lazy and strict, and combines eager evaluation with non-strict semantics. This seems to be considered more promising for parallelisation."
12:00:35 <elliott> perhaps you are thinking of this?
12:00:59 <monochrom> ok, I call that crazy evaluation
12:01:13 <facepalm> dmwit: I got this to work bounds2 xs = (bounds1 (fsts xs)) but so far not able to get it to do the same thing for snds....I wasn't sure how to implement what you were talking about to create another function to work with this
12:01:13 <c_wraith> good luck being both eager and non-strict
12:01:22 <monochrom> because it rhymes with lazy evaluation, and both are good for non-strict
12:01:24 <elliott> yes, I just googled it and copied that from haskellwiki
12:01:24 <chrisdotcode_> yeah, I was reading through some gaming powerpoint, "the next mainstream programming language" or something, and it said that haskell's laziness is too much, but eager isn't good enough.
12:01:39 <chrisdotcode_> so he was hoping for "lenient". couldn't figure out where it was, though.
12:01:45 <elliott> http://lambda-the-ultimate.org/node/243
12:02:09 <elliott> in fact, I think Tim Sweeney (the person quoted there) wrote that powerpoint
12:02:17 <chrisdotcode_> ^ yes, I do remember his name
12:02:19 <elliott> so there, presumably, is your answer
12:02:31 <chrisdotcode_> awesome, thanks!
12:02:42 <dolio> It's an evaluation strategy where you evaluate arguments to functions for some amount of time, or until you hit an exception, and then fall back to thunking otherwise.
12:02:52 <elliott> that doesn't seem to be it
12:02:56 <elliott> I thought it would just be speculative evaluation
12:03:12 <elliott> but both the refs I looked at (one from the user of the term) are talking about something else entirely
12:03:35 <elliott> this seems to just be a strict language with codata, I guess?
12:04:08 <c_wraith> which seems like the less-useful arrangement
12:04:08 <dolio> Well, what I described is usually called "optimistic evaluation."
12:04:18 <dolio> So if that's what lenient is....
12:04:44 * elliott finds it unsurprising that there is overloaded terminology here :)
12:06:32 <c_wraith> I guess strict evaluation with codata might be what was intended
12:07:00 <elliott> it seems to be what the email LTU links to describes
12:07:55 <c_wraith> It gives you infinite lists and trees and so on, and even supports knot-tying of those structures.  But it doesn't give you any capacity to build your own control structures.
12:08:17 <c_wraith> So I'm not sure it's really a useful point on the continuum
12:08:17 <dolio> Anyhow, it deals with a lot of the simple cases where you'd need to use seq to get good behavior in GHC and such.
12:08:18 <dolio> Which is nice, I guess.
12:09:23 <elliott> just getting codata is a bit boring, though
12:10:58 <dolio> Okay, lenient is not optimistic.
12:12:36 <dolio> It sounds like lenient is a strict evaluation strategy.
12:13:07 <chrisdotcode_> it's strict so that we can statically approximate run-time speed
12:13:18 <chrisdotcode_> the problem with lazy was that appearently, it's hard to predict that
12:13:30 <chrisdotcode_> and some things are unknowable, but I"m sure you guys already know about that :)
12:13:33 <dimka> :info lift
12:17:44 <c_wraith> performance of lazy evaluation isn't really hard to predict. It just requires more sophisticated answers locally. A full description of an algorithm's timing will include how long it takes to produce each incremental result.
12:18:23 <ciaranm> all performance is hard to predict...
12:18:54 <ciaranm> if you think it's easy then you've only looked at a few very simple examples on a single system with a single small set of data that's all the same size...
12:19:11 <robstewartuk> bah, I have a cabalised project with a random directory in the root of the project foo/ which doesn't contain Haskell sources, but does contain random files I want to be added to the tar.gz file when I run `cabal sdist`.
12:19:40 <c_wraith> Like, I've just been messing around with an algorithm that takes a finite list of length n, and produces a list of the same length. The first element of the result takes O(n) time to calculate, and consumes the entire input list. each remaining cons cell in the output takes O(1) time to calculate
12:19:46 <robstewartuk> Is there cabal parameter I can add to the cabal file to include foo/ in the .tar.gz ?
12:19:55 <c_wraith> robstewartuk: extra-files:
12:20:00 <robstewartuk> thank you!
12:21:22 <c_wraith> That's a full description of the performance of the algorithm. You can't just say O(n), because, well - that's accurate if it was non-lazy. But it doesn't tell the whole story when it is lazy.
12:22:34 <c_wraith> I guess I left out memory performance characteristics, too, which are that it allocates O(n) memory total, and doesn't release it until the full output list is consumed.
12:23:06 <chrisdotcode_> do you guys think that having records be mutable would have been a good idea?
12:23:23 <c_wraith> These things aren't really hard to describe fully. It's just that a full description is bigger.
12:23:36 <c_wraith> Not really. data being immutable is a core thing.
12:24:10 <chrisdotcode_> I hear haskell isn't so good for giant games *because* game state is really really ugly done immutably
12:24:33 <coppro> it's not that bad when you get all the tools
12:24:37 <coppro> like lenses and State
12:24:40 <elliott> I hear lots of things
12:24:45 <coppro> it just requires a lot more thinking
12:24:48 <elliott> I hear that Haskell supports mutability, for instance
12:25:01 <c_wraith> You should read Carmack's thoughts on game programming and functional languages.
12:25:25 <c_wraith> One of his key points was that for correctness, game state almost certainly should be managed with immutable structures even in languages that support mutation.
12:26:09 <elliott> I do sometimes wonder whether Carmack has ever actually written anything in a purely functional language :P
12:26:23 <c_wraith> I don't think he's written anything big in a purely functional language.
12:26:53 <c_wraith> However, he has said that the stuff he writes gets big gains from adopting even a few of the principles.
12:27:21 <chrisdotcode_> I know that the game core, shading and number crunching is purely functional anyway, but in the "next mainstream programming langauge" powerpoint, he was saying how hard it would be to have non-mutable changes in the game state.
12:27:36 <coppro> non-mutable changes?
12:27:39 <c_wraith> you're thinking of Tim Sweeney, rather than carmack
12:27:49 <chrisdotcode_> yeah, I was talking about Sweeney xD
12:27:53 <coppro> what does that even mean?
12:27:59 <chrisdotcode_> carmack *likes* haskell, that much I know
12:28:05 <c_wraith> Like, having the core game state be immutable has significantly reduced the amount of bugs he's run into when writing multi-threaded game code.
12:28:10 * bitonic has gotten like 4 GHC panics in the last month
12:28:11 <coppro> ah
12:28:42 <Taneb> bitonic: how much have you been using unsafeCoerce
12:28:51 <bitonic> Taneb: 0.
12:28:58 <c_wraith> unsafeCoerce is usually runtime crashes, not GHC panics
12:29:01 <bitonic> yeah
12:29:09 <elliott> c_wraith: sure, just I often get an air of overrating how easy it is to e.g. program a large game in a purely functional style with our current knowledge
12:29:17 <elliott> (not to say it's not a noble goal)
12:29:34 <arkx> Carmack was thinking about teaching his 7 year old son Haskell (but decided against it).
12:29:41 <bitonic> arkx: why?
12:29:45 <c_wraith> GHC panics are usually attempting to use irrefutable pattern matches with GADTs.  In my experience. :)
12:29:46 <arkx> http://blogs.uw.edu/ajko/2012/08/22/john-carmack-discusses-the-art-and-science-of-software-engineering/
12:29:49 <bitonic> what an irresponsible parent
12:29:52 <`^_^v> because 7 year olds should be playing outside with friends and not learning haskell
12:29:58 <bitonic> c_wraith: I doubt this one has anything to do with GADTs
12:30:06 <bitonic> it’s from an happy generated parser
12:30:11 <hpaste> chrisdotcode pasted “Functional programming and game state” at http://hpaste.org/86858
12:30:12 <Taneb> Why can't they play Haskell outside with friends
12:30:15 <bitonic> has to do with unboxed tuples as far as I can see
12:30:16 <c_wraith> Oh, probably. That's just the only way I've managed to make GHC cry
12:30:30 <chrisdotcode_> sorry, forgot to properly space the text...
12:30:30 <Eduard_Munteanu> LOL
12:30:45 <Taneb> "you'll be the state transformer and I'll be the list monad"
12:31:29 <Eduard_Munteanu> Yes, kids these days are big on transformers.
12:31:37 <hpaste> chrisdotcode revised “Functional programming and game state”: “how can this be implemented in fp?” at http://hpaste.org/86858
12:31:46 <chrisdotcode_> ^ what do you guys think about that?
12:31:58 <chrisdotcode_> how would that be done in pure fp?
12:32:20 <elliott> first, you should define pure FP.
12:32:26 <elliott> as in, what a solution will have to look like to meet your requirements.
12:32:31 <elliott> otherwise, it will just be an argument over what counts
12:32:38 <Taneb> It feels comonady
12:32:39 <chrisdotcode_> no side-effects, no globals, referential transperency
12:32:51 <chrisdotcode_> er, nevermind that no globals part
12:32:56 <elliott> does State count as side-effects?
12:33:01 <elliott> it is implemented with 100% purely functional code.
12:33:03 <chrisdotcode_> I thought it did?
12:33:07 <elliott> yet it lets you program as if with mutable global variables.
12:33:11 * chrisdotcode_ hasn't gotten to State yet
12:33:14 <Eduard_Munteanu> Hm, so Carmack pretty much says he's still thinking in terms of imperative stuff, AFAICT.
12:33:21 <elliott> this is why defining what counts as pure FP to you is vital
12:33:22 * hackagebot postgresql-simple 0.3.1.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.1.1 (LeonSmith)
12:33:56 <rzh_> \\\\\\\\\\\\\\xxc
12:34:45 <elliott> agreed.
12:35:25 <Eduard_Munteanu> chrisdotcode_: the State gets to you eventually. :P
12:35:42 <chrisdotcode_> Eduard_Munteanu: I hope so, everything else certainly has :-)
12:38:23 <facepalm> dmwit: are you still around? just have 1 more quick question
12:39:24 <oconnor0> clearly all of you should band together & write a game in haskell to see how easy/hard/whatever it is. :D
12:40:08 <hpaste> facepalm revised “Haskell function”: “Haskell function” at http://hpaste.org/86840
12:40:09 <Eduard_Munteanu> The hardest part is usually something like arguing whether you want elves or dwarves in your game. :P
12:40:27 <merijn> oconnor0: Some people have already done that, depending on how complex you want your games :)
12:40:47 <chrisdotcode_> I would like to see the haskell ninjas do something like that :)
12:40:48 <facepalm> I got this working I just need to figure out why the result from calling bounds 2 gives me so many just's instead of just 1
12:41:17 <merijn> chrisdotcode_: Some people were working on an iOS game in haskell, but I think that got postponed/cancelled
12:41:38 <chrisdotcode_> merijn: is there an haskell -> objective C compiler?
12:41:46 <chrisdotcode_> or do they both support LLVM bytecode, or something?
12:41:47 <dolio> Nikki and the Robots is written in Haskell, isn't it?
12:41:47 <facepalm> it gives me (Just (0,4),Just (0,3)) and I want it to be just ((0,4),(0,3))
12:42:06 <merijn> chrisdotcode_: I think they were just compiling to ARM bytecode? I dunno
12:42:13 <oconnor0> Eduard_Munteanu: clearly both elves & dwarves can't be in the same game. :)
12:42:22 <merijn> ARM support for GHC is in the works, isn't it?
12:42:27 <oconnor0> merijn: what examples are there? i know of nikki & the robots.
12:42:34 <doomlord> the hybrid languages are encouraging, ones which take lessons from haskell andmix them with more traditiional paradigms
12:43:07 <arkeet> > both id (Just (0,4),Just (0,3))
12:43:08 <merijn> oconnor0: lens has a pong example and I know of a FRP breakout for in the browser (compiling haskell to JS)
12:43:09 <lambdabot>   Just ((0,4),(0,3))
12:43:11 <doomlord> the thing with games is you usually need to reason about resources, but i'm sure you could do some parts functional
12:43:36 <dolio> There was also raincat.
12:43:47 <merijn> oconnor0: https://github.com/ekmett/lens/blob/master/examples/Pong.hs and http://jshaskell.blogspot.de/2012/09/breakout.html
12:43:49 <Eduard_Munteanu> That FPS named Frags too, IIRC.
12:44:05 <merijn> oconnor0: Also browser pong: http://jshaskell.blogspot.de/2012/09/pong.html
12:44:45 * arbn never got raincat to compile, as fun as it looked.
12:45:05 * arkeet never got frag to compile
12:45:07 <luite> lens based poing is much betterer: http://hdiff.luite.com/gloss/pong/
12:45:14 <merijn> luite: Already linked it
12:45:17 <luite> oh :(
12:45:35 <geekosaur> facepalm, why do you expect that to somehow do something other than exactly what you told it to do?
12:45:53 <geekosaur> (bounds1 (...), bounds2 (...))
12:46:05 <geekosaur> where each bounds1 produces a Just (...)
12:46:29 <arkeet> :t sequenceAOf
12:46:30 <facepalm> yes but if I remove the second bounds1 then I do not get the correct answer
12:46:30 <lambdabot> LensLike f s t (f b) b -> s -> f t
12:46:48 <geekosaur> um?
12:46:54 <geekosaur> that has what to do with it?
12:47:06 <facepalm> I end up with (Just (0,4),[1,3,0])
12:47:08 <geekosaur> you seem to be assuming something will magically rearrange Just-s for you?
12:47:30 <geekosaur> facepalm, you apparently did not understand my point at all
12:47:31 <facepalm> no I am wondering how I can fix what I have to give me the same result
12:48:04 <chrisdotcode_> doomlord: like rust, you think?
12:48:12 <merijn> facepalm: You want to get "Maybe (x, y)" as end result, right?
12:48:39 <doomlord> yes, rust is  ray of hope for me
12:48:53 <facepalm> I understand what you are saying and realize why the 2 justs came up my question was how to eliminate that from happening but still get the same 2 pairs
12:49:26 <doomlord> although iguess its a lot closer to C++ really than haskell. i'd like it if they borrows haskells partial application...
12:49:31 <merijn> facepalm: How to solve it depends on what you expect to happen if one of those two is Nothing instead of Just
12:49:43 <facepalm> I want ((0,3),(0,4)) as my end result
12:50:15 <merijn> facepalm: What if one of the bounds1 calls returns Nothing, though?
12:50:16 <doomlord> i am getting fed up of manually writing const so much in C++ , and knowing it can't be applied to global
12:50:30 <nwf> Hey channel; is it expected that building ghc 7.6.3 with make -j12 might fail?  I am currently re-running make without -j and it appears to be making progress...
12:50:47 <arkeet> facepalm: what should bounds2 [] be?
12:50:54 <arkeet> nwf: out of memory?
12:51:11 <merijn> nwf: How was it failing? Any errors or just silent?
12:51:13 <nwf> arkeet: It looks like improper dependency ordering.
12:51:20 <doomlord> i am tempted to try haskell again after rust (typeclasses will make more sense ) but i remember the record system is one of thee things that made me give up
12:51:20 <facepalm> arkeet: are you asking what it is meant to do or what the result should be ?
12:51:28 <arkeet> facepalm: what should it be?
12:51:33 <merijn> facepalm: Those are the same thing
12:51:34 <arkeet> I did ask that.
12:51:46 <merijn> doomlord: But now we have lens :p
12:52:05 <hpaste> nwf pasted “7.6.3 -j12 build failure” at http://hpaste.org/86863
12:52:08 <merijn> doomlord: Although, tbh I never thought the record system was that big of a problem...
12:52:21 <facepalm> [(1,2),(3,4), (0,0)] should return ((0,3),(0,4))
12:52:21 <nwf> arkeet, merijn: ^
12:52:24 <doomlord> but did lens adress the fundemental issue about record element names: were lenses about emulating record mutation?
12:52:30 <arkeet> facepalm: and what if you give it the empty list?
12:52:43 <merijn> doomlord: lenses are composable updates
12:52:44 <facepalm> then a pair of nothings
12:52:53 <arkeet> a pair of nothings does not have the same type as a pair of pairs of numbers.
12:53:11 <doomlord> ok. plus i dont think i ever really fully groked the state monad.. i really struggled to write a file parser
12:53:29 <Taneb> > (1, Just "hello") & _1 . _Just . unto tail %~ reverse
12:53:31 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
12:53:31 <lambdabot>    arising from the lit...
12:53:38 <Taneb> > (1, Just "hello") & _2 . _Just . unto tail %~ reverse
12:53:40 <lambdabot>   No instance for (Control.Lens.Internal.Review.Reviewable (->))
12:53:40 <lambdabot>    arising f...
12:53:45 <doomlord> when just manipulating things you already had the language was awesome
12:53:47 <arkeet> > (1, Just "hello") & _2 . _Just . _tail %~ reverse
12:53:48 <lambdabot>   (1,Just "holle")
12:54:15 <merijn> doomlord: The lens libraries drastically simplify working with records as State
12:55:21 <Taneb> I was thinking of "upon"
12:55:22 <Taneb> > (1, Just "hello") & _2 . _Just . upon tail %~ reverse
12:55:25 <lambdabot>   (1,Just "holle")
12:55:40 <arkeet> oh, upon is that awful thing.
12:55:48 <Tekmo> Ok, really dumb category theory question
12:55:48 <lambdabot> Tekmo: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:55:59 <arkeet> correspondingly dumb category theory answer
12:56:01 <Tekmo> What is the name of the functor that transforms a category to its opposite category?
12:56:13 <arkeet> what, the functor Cat -> Cat?
12:56:28 <Tekmo> It preserves objects but reverses all morphisms
12:56:48 <arkeet> no, the opposite category functor is covariant.
12:57:43 <Tekmo> Yes, it is covariant
12:57:50 <arkeet> Tekmo: what exactly are you asking for?
12:57:55 <Tekmo> What is the name of the functor?
12:58:00 <Tekmo> Does it have an official name?
12:58:13 <arkeet> why not the "opposite category functor"
12:58:27 <arkeet> it's as good a name as any.
12:58:47 <Tekmo> Alright
12:58:52 <Tekmo> I originally tried "opposite functor"
12:58:56 <Tekmo> But googling turned up nothing
12:59:05 <nwf> I think it is just called "op" by most texts?
12:59:19 <arkeet> it's normally not named indeed.
12:59:21 <nwf> Usually written -^{op}
12:59:45 <Tekmo> Alright, then I'll probably just use "opposite functor"
12:59:53 <arkeet> I don't know what an opposite functor is.
13:00:02 <arkeet> opposite what?
13:00:06 <Tekmo> The one you just named the "opposite category functor"
13:00:12 <Tekmo> Or maybe I'll just use your name
13:00:17 <arkeet> I would use my name.
13:00:20 <Tekmo> Alright
13:00:25 <Tekmo> I will use that so it is clearer
13:00:34 <arkeet> I might denote it by  op
13:00:56 <Tekmo> Well, this is for haddocks where I can't use latex
13:01:49 <statusfailed> Why is the memoized_fib from here so fast? http://www.haskell.org/haskellwiki/Memoization
13:01:54 <statusfailed> doesn't the (!!) take lots of time?
13:02:00 <statusfailed> or is it just because the list is small
13:02:32 <arkeet> it takes linear time.
13:03:01 <statusfailed> arkeet: isn't it doing a lookup for each sub call?
13:03:25 <Taneb> statusfailed: I think it caches the lot in memory
13:03:32 <Taneb> So it needs to do a lot fewer subcalls
13:03:46 <statusfailed> oh, so it's basically because the compiler is being smart?
13:03:50 <Taneb> (how does the memoized version compare with the exponents and phi version)?
13:03:55 <Tekmo> Much slower
13:03:59 <arkeet> the elements of map fib [0..] are each only computed once
13:04:00 <int-e> statusfailed: it is slow, but *much* faster than the (exponential) naive implementation
13:04:13 <Tekmo> The exponents version can go up to insane numbers
13:04:18 <arkeet> but sure, accessing it will be slowish.
13:05:11 <statusfailed> ok, so even if it were to do a linear-time lookup on that list each time, it'll still be quick enough
13:05:11 <arkeet> but yeah, it would be some quadratic time thing I suppose.
13:05:14 <arkeet> much better than exponential
13:05:17 <statusfailed> sure
13:05:20 <statusfailed> thanks :)
13:05:30 <arkeet> of course, there is a linear time way to do it.
13:05:50 <Taneb> Tekmo: I can imagine the list-based version being quicker when you want all of the fibs in turn
13:06:05 <statusfailed> arkeet: right. I'm mostly interested in memoization in general tho. Was just wondering about that specific implementation
13:06:26 <arkeet> probably better to use a structure with faster access.
13:06:26 <Tekmo> Taneb: That's true, but in that case you are probably still better off with the zipWith (+) solution
13:06:55 <int-e> statusfailed: a quick experiment in ghci (so interpreted code): memoized_fib 10000 `mod` 13 takes 0.87 seconds to evaluate; let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !!  10000 `mod` 13  takes 0.01.
13:07:20 <statusfailed> int-e: ok, fair enough- much slower than haha
13:07:21 <statusfailed> then(
13:07:36 <arkeet> memoized_fib 100000 is still giong for me.
13:07:38 <arkeet> going.
13:07:50 <arkeet> probably because Integers are large.
13:09:30 <Ralith> Enigmagic: ping
13:09:34 <int-e> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in (fibs !! 100000) `mod` 13
13:09:37 <lambdabot>   1
13:10:46 <parcs> quick -how many digits does fibs !! 100000
13:10:48 <parcs> have
13:10:51 <arkeet> ah yes, further down it mentions data-inttrie
13:10:56 <int-e> 20899
13:11:14 <int-e> > length $ show $ let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! 100000
13:11:18 <lambdabot>   20899
13:11:31 <arkeet> > logBase 10 $ ((1 + sqrt 5)/2)^100000
13:11:32 <lambdabot>   Infinity
13:11:37 <arkeet> > logBase 10 $ ((1 + sqrt 5)/2)**100000
13:11:38 <lambdabot>   Infinity
13:11:41 <arkeet> heh.
13:11:50 <arkeet> > 100000 * logBase 10 ((1 + sqrt 5)/2)
13:11:52 <lambdabot>   20898.764024997872
13:12:06 <parcs> :)
13:12:59 <Tekmo> There is a fast Integer-based solution for exponents
13:13:03 <Tekmo> I did a while ago, let me pull it up
13:13:45 <int-e> length . show  is not half as bad as one might expect :)
13:14:08 <arkeet> > length . show $ ((1 + sqrt 5)/2) ** 100
13:14:10 <lambdabot>   20
13:14:10 <arkeet> yes it is.
13:14:20 <int-e> arkeet: for integers. duh.
13:14:27 <byorgey> arkeet: you forgot to divide by  sqrt 5.
13:14:32 <arkeet> so I did.
13:14:42 <int-e> and to round
13:14:54 <arkeet> well I wasn't claiming anything about the number of digits.
13:15:22 <Tekmo> Damn, I can't find it
13:15:47 <Tekmo> But the basic premise is simple
13:16:04 <Tekmo> You convert the zipWith form into the matrix multiplication equivalent, using Integer matrices
13:16:11 <Tekmo> Then you exponentiate by matrix squarings
13:16:25 <Tekmo> So it's logarithmic in the fibonacci number and ridiculously fast
13:16:42 <luite> only if you assume that integer multiplication is O(1)
13:16:46 <Tekmo> That's right
13:17:05 <Tekmo> But in practice, integer multiplication is so fast that I couldn't even get it to go slow
13:17:12 <luite> uh?
13:17:24 <Boreeas> Just multiply enough of them
13:17:25 <parcs> O(1) fibonacci  http://hackage.haskell.org/package/gutenberg-fibonaccis
13:17:41 <Tekmo> I went up to 100's of digits
13:17:46 <luite> i thought we were talking about numbers that were too big to fit in memory
13:17:51 <luite> oh 100's is not big
13:18:05 <Tekmo> I mean
13:18:09 <Tekmo> 100s of digits for the argument
13:18:13 <Tekmo> not the fibonacci number itself
13:18:18 <luite> ah 20k digits
13:18:26 * hackagebot parsers 0.7.1 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.7.1 (EdwardKmett)
13:18:39 <luite> right that's still doable computing it fully :)
13:19:21 <byorgey> Tekmo: I have an assignment that walks you through that algorithm here: http://www.cis.upenn.edu/~cis194/hw/06-laziness.pdf (near the end)
13:19:40 <Tekmo> Well, I've already done it myself :)
13:19:45 <Tekmo> I just lost my original code
13:20:10 <byorgey> I know, I guess my comment was really just directed towards anyone else who is interested rather than you in particular =)
13:20:23 <Tekmo> Yeah, it's a neat trick to know :)
13:20:35 <Tekmo> It's great for solving lots of infinite precision problems
13:20:36 <byorgey> Moreover the trick works for any linear recurrence
13:20:44 <Tekmo> Yeah, I've solved the general case, too
13:20:49 <byorgey> cool
13:20:50 <parcs> for all those times when you need the milliontth fibonacci number
13:20:59 <Tekmo> It follows immediately from the matrix solution
13:21:10 <Tekmo> You just change the matrix to reflect the linear recurrence
13:21:42 <Tekmo> Of course, back when I solved it
13:21:46 <Tekmo> I didn't know anything about matrices
13:21:55 <Tekmo> So I came up with this weird bizarre notation to describe what was going on
13:22:01 <Tekmo> It was pretty funny
13:22:41 <int-e> > let f 0 = (0,1); f n = let (n',r) = (n-1) `quotRem` 2; (a,b) = f n' in if r == 0 then (a*a + b*b, a*b + b*(a+b)) else (a*b + b*(a+b), b*b + (a+b)*(a+b)); fib = fst . f in length . show . fib $ 1000000
13:22:45 <lambdabot>   mueval-core: Time limit exceeded
13:22:54 <int-e> > let f 0 = (0,1); f n = let (n',r) = (n-1) `quotRem` 2; (a,b) = f n' in if r == 0 then (a*a + b*b, a*b + b*(a+b)) else (a*b + b*(a+b), b*b + (a+b)*(a+b)); fib = fst . f in length . show . fib $ 100000
13:22:56 <lambdabot>   20899
13:23:26 * hackagebot fb-persistent 0.3 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.3 (FelipeLessa)
13:23:50 <int-e> and that's not the best way to do it ... hakmem has a more clever version, IIRC
13:24:02 <arkeet> :t timesN
13:24:03 <lambdabot> Not in scope: `timesN'
13:24:18 <arkeet> :t reify
13:24:20 <lambdabot> Not in scope: `reify'
13:24:26 <arkeet> reflection in lambdabot please
13:36:58 <chrisdotcode_> latency test
13:38:28 * hackagebot skein 1.0.3 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.3 (FelipeLessa)
13:40:06 <drostie> ooh, skein in Haskell? :3 :3 :3
13:45:05 <facepalm> how are mask lists created or defined? I am not able to find documentation on them
13:48:41 <dmwit> What is a mask list?
13:48:59 <dmwit> Also, did you work out how to write a function of type Maybe a -> Maybe b -> Maybe (a, b) yet?
13:55:44 * byorgey has never heard of a mask list
13:55:57 <byorgey> googling for "mask list" gives a bunch of stuff about video games
14:03:29 * hackagebot parsers 0.8 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.8 (EdwardKmett)
14:10:00 <Botje> hmm
14:10:31 <Botje> what's the lens magic to perform a monadic action over the second element of a tuple?
14:11:00 <supki> @ty (1, 2) & _2 print
14:11:04 <lambdabot> Num t => IO (t, ())
14:11:21 <arbn> Where can I find a Storable ByteString?
14:11:28 <Botje> thought I tried that.
14:11:39 <arbn> Data.Vector.Storable.ByteString doesn't seem to have a Storable instance, which is really confusing me.
14:13:55 <Botje> ah, I didn't need the .
14:13:58 <Botje> cool, thanks :)
14:14:49 <supki> well, you can also do
14:14:52 <supki> @ty (1, 2) ^! _2 . act print
14:14:54 <lambdabot> IO ()
14:15:52 <Botje> well, the monadic action changes the second element and i want to reconstruct the tuple with modified snd, so _2 m is fine
14:17:46 <h4199> Is anyone else perversely uncomfortable after a large refactor results in immediate compilation and seeming success?
14:18:00 <Tene> Depends on the language.
14:18:09 <Tene> Far less so with haskell.
14:18:59 <monochrom> I suppose there is always this "too good to be true" feeling :)
14:20:33 <Tene> It depends on the scope of my test coverage.
14:20:55 <Tene> That's pretty much the definition of being comfortable with my test coverage, for me.
14:21:01 <dropdrive> So I can see how to write code so that 'tree = Literal 1 `plus` Variable "x" ' is an abstract syntax tree representing '1+x'.  But is there a way to extend this to defining functions, with pattern matching, etc.?
14:21:12 <byorgey> h4199: I used to be.  Now it is quite a comfortable feeling =)
14:21:54 <uniquenick> is there a reason ZonedTime doesn't have an Eq instance, or is it just an oversight?
14:22:32 <h4199> Yeah, it is something I could get used to.  :)
14:23:29 * hackagebot esqueleto 1.2 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.2 (FelipeLessa)
14:23:36 <edwardk>  Botje : _2 youraction yourtuple
14:24:15 <Botje> edwardk: yeah, got it now, thanks.
14:24:30 <Botje> and that's actually the function part of a mapM
14:24:46 <Botje> I tried mapMOf but didn't seem to do it
14:25:03 <Botje> unless I tried that with the . as well, hmm.
14:25:28 <edwardk> mapMOf _2 youraction yourtuple
14:25:41 <edwardk> :t mapMOf _2 putStrLn
14:25:43 <lambdabot> Field2 s t String () => s -> IO t
14:25:52 <edwardk> :t mapMOf both putStrLn
14:25:54 <lambdabot> (String, String) -> IO ((), ())
14:26:01 <edwardk> :t mapMOf_ both putStrLn
14:26:02 <lambdabot> (String, String) -> IO ()
14:26:30 <ihm1> Is there anyway to include a typeclass restriction in a type synonym declaration?
14:26:32 <supki> @ty id both putStrLn
14:26:34 <lambdabot> (String, String) -> IO ((), ())
14:26:35 <ihm1> E.g., type Product e => Kernel e = Vector e -> Vector e -> e
14:26:44 <edwardk> ihm1: no
14:26:46 <Botje> edwardk: aha! that's super cool! thanks
14:27:31 <edwardk> mapMOf just makes sure it works for any monad, even ones that lack a corresponding Applicative instance, otherwise you can just use the lens directly
14:31:46 <hpaste> facepalm pasted “filter” at http://hpaste.org/86875
14:33:26 <facepalm> I am trying to make a function that accepts a function a mask list and a data list to filter out data items for example filtermask (/d d =d  >m) [1,5,7,][5,6,7,] returns [5,6]
14:35:11 <armlesshobo> ok
14:35:26 <byorgey> facepalm: your implementation of filtermask looks file.
14:35:35 <byorgey> facepalm: what is (/d d =d  >m)  supposed to mean?
14:36:01 <byorgey> s/file/fine/
14:36:13 <h4199> he wants to compare the values of each list elementwise and only keep the ones that are lagers
14:36:17 <byorgey> facepalm: also, note your 'filtermask' is already in the standard Prelude as 'filter'
14:36:21 <h4199> larger*
14:36:28 <facepalm> what to filter out is my guess
14:37:05 <byorgey> wait, you don't *know* what (/d d =d  >m) means?
14:37:14 <byorgey> it looks like something badly OCR'ed
14:37:28 <armlesshobo> (\d m -> d > m)
14:37:30 <armlesshobo> right?
14:37:40 <facepalm> yeah
14:37:45 <byorgey> ahh
14:38:05 <armlesshobo> @type (\d m -> d > m)
14:38:06 <lambdabot> Ord a => a -> a -> Bool
14:38:22 <armlesshobo> it takes in two arguments and compares them, thus returning a Bool
14:38:30 <armlesshobo> it's a lambda function
14:38:35 <byorgey> facepalm: the simplest way is to write something similar to the 'filtermask' you pasted, but with a type   (a -> a -> Bool) -> [a] -> [a] -> [a]
14:38:45 <byorgey> it will be very similar in structure to the version that you pasted
14:38:45 <armlesshobo> you don't care about it's name, just it's functionality
14:40:15 <bitonic> edwardk: we need to find a way to have a ‘bound’-like thing that works with heterogeneous data types!  I think I’m going to spend some time on that when I finish uni...
14:40:32 <cmccann> bitonic: why wait? :D
14:40:36 <bitonic> it’s absurd that the apparently harmless problem of naming/substitution is such a huge pain in the ass
14:40:45 <cmccann> carpe diem!
14:41:03 <facepalm> do I have to make changes to filtermask p? or just make filtermask _[] = [] []?
14:41:10 <bitonic> cmccann: aha.  because if I start rewriting bound I’m never going to finish my project!
14:41:15 <byorgey> facepalm: you have to make changes.
14:41:34 <cmccann> is filtermask supposed to be some sort of zipWith+filter thing?
14:42:00 <facepalm> is filtermast _ [] = [][] correct for that part?
14:42:09 <elliott> [][] is never correct
14:42:31 <facepalm> ha /wrists
14:43:37 <cmccann> elliott: -XOverloadedLists
14:43:40 <cmccann> WHAT NOW
14:44:01 <elliott> cmccann: then your instance is incorrect
14:44:20 <edwardk> bitonic: by lifting it up by a level to use higher order functors and higher order monads, etc?
14:44:44 <facepalm> byorgey: I am not sure what changes to make I am kind of trying to teach myself as I go along, Is there something I could read speifically that would show me what to do?
14:44:45 <bitonic> edwardk: I don’t care how, but I want to be able to cheaply compose telescopes and terms, for example
14:45:03 <cmccann> elliott: I don't see why there couldn't be an instance that creates a function from list syntax.
14:45:05 <bitonic> edwardk: that path (higher order functors/monads) looked messy when I tried it...
14:45:15 <byorgey> facepalm: have you been reading any book or tutorial in particular?
14:45:20 <cmccann> elliott: something like DList or foldr, perhaps
14:45:21 <edwardk> bitonic: i showed you the little remote edsl i had right?
14:45:32 <bitonic> edwardk: I’m pretty sure you did, but a link would refresh my memory :)
14:45:32 <facepalm> byorgey: learn you a haskell for greater good
14:45:45 <cschneid> Are there haskell mailing lists I should be on?
14:45:46 <facepalm> byorgey: which is where I got the first thing I had from
14:45:53 <byorgey> facepalm: OK, have you read anything in there about pattern matching?
14:45:58 <edwardk> bitonic: http://hpaste.org/79582 looks like a version of it
14:46:03 <facepalm> byorgey: I am just not sure how to modify it to work with my situation
14:46:28 <elliott> cmccann: without a newtype that instance would be pretty evil.
14:46:33 <tippenein> *** WARNING: /home/tippenein/.ghci is writable by someone else, IGNORING!
14:46:35 <elliott> for instance, Endo is a good newtype for DLists.
14:46:47 <byorgey> facepalm: do you understand how the filtermask you pasted works?
14:46:50 <cmccann> elliott: evil is not the same as incorrect!
14:47:12 <cmccann> correct instances are morally neutral.
14:47:21 <int-e> tippenein: chmod g-w ~/.ghci
14:47:34 <facepalm> byorgey: the filter mask p part I am a little unsure about to be honest.
14:47:54 <tippenein> thanks int-e
14:47:54 <int-e> tippenein: you are probably using one of these setups where every user is in his/her own group, and files are created group writeable by default.
14:47:58 <bitonic> edwardk: right, yes.  if I recall correctly that didn’t solve the ‘heterogeneous’ problem?  another cool thing would be a nice way of representing contexts while you are traversing a term.  right now I have this <https://github.com/bitonic/kant/blob/master/src/Kant/Cursor.hs>, but I’m sure you can abstract it way more :D
14:48:30 <tippenein> int-e: strangely enough, it's my own system
14:48:33 <edwardk> probably. not a problem i'm currently facing though. so i've handed it down to you to solve ;)
14:48:37 <byorgey> facepalm: I think you need to focus on understanding the existing filtermask before you can think about how to modify it.
14:48:51 <byorgey> facepalm: the key terms are defining a function by pattern-matching, and guards
14:49:02 <int-e> tippenein: this is the default in a couple of linux distributions, possibly other OSes, too
14:49:11 <byorgey> facepalm: sorry, I don't have more time to help right now, but perhaps you want to go back and review those topics in LYAH
14:49:23 <elliott> tippenein: it doesn't mean there is an actual other person who can edit it
14:49:34 <facepalm> seems like foldr or map might be useful
14:49:34 <elliott> tippenein: it means that another user could edit it, if one existed
14:49:37 <elliott> which would be a security risk
14:49:40 <bitonic> edwardk: OK :).  but I really think that the overall idea of ‘bound’ is the right one, it just lacks some usability...  and polymorphic recursion is a bit of a pain
14:49:44 <facepalm> yes I will go back and read some more ty
14:50:47 <cmccann> bitonic: to be fair the alternatives to bound generally lack rather more usability
14:51:07 <edwardk> sure. ah i think i blew away the .htaccess file
14:51:33 <bitonic> cmccann: if you manipulate terms a lot and keep sophisticated contexts bound is disadvantaged in some sense
14:52:01 <elliott> cmccann: how is your language??
14:52:10 <cschneid> what's the web stack I should look at playing with? What's "winning" most mindshare? Haapstack and Yesod look like the two big ones?
14:52:12 <bitonic> basically if you are doing non-trivial stuff with dependent typed languages (pattern unification, elaboration of data types, stuff like that)
14:52:23 <bitonic> or, god forbid, pattern matching
14:52:25 <cmccann> bitonic: yeah, I ran into a bit of that and couldn't find a satisfactory solution when walking the AST recursively
14:52:32 <hpc> cschneid: 3-way tie between those two and snap
14:52:33 <bitonic> in general telescope are a pain in ‘bound’
14:52:38 <cmccann> elliott: which one
14:52:38 <hpc> learn all three, see which you like
14:52:40 <bitonic> cmccann: see the ‘Cursor.hs’ above
14:52:57 <elliott> cmccann: the dual-intuitionistic one
14:53:10 <cmccann> oh. I still have no idea how that would even work.
14:53:12 <cschneid> hpc: is one "simpler" than the others? ie, in ruby land where I'm coming from, Sinatra is minimal & simple, rails is complete & more complex.
14:53:16 <bitonic> cmccann: I use that to traverse inside ASTs while keeping a context for bound variables
14:53:17 <cmccann> elliott: you should figure it out for me.
14:53:26 <elliott> cmccann: no. you should.
14:53:34 <hpc> cschneid: i don't actually know all of them :P
14:53:50 <elliott> cmccann: find a famous dual-intuitionist and give them the problem. note: you may have to dualise an existing intuitionist to find one
14:53:59 <elliott> but that's easy, just reverse all their internal organs.
14:54:07 <bitonic> gross.
14:54:09 <cmccann> bitonic: interesting, I'll take a look at it later though
14:54:37 <int-e> elliott: somehow it seems more humane to dualise the problem instead.
14:54:40 <bitonic> cmccann: actually dolio has a much smaller example showing the idea, although I pimped it a bit
14:55:02 <edwardk> btw i _think_ i fixed comonad.com's articles
14:55:03 <cmccann> elliott: well, it falls under the broader concept of paraconsistent logics
14:55:08 <elliott> int-e: cmccann has enough problems, making them dual would cause an overflow.
14:55:13 <edwardk> let me know if there is still a problem
14:55:24 <elliott> cmccann: unfortunately I think everyone who works on those is crazy
14:55:39 <cmccann> elliott: that might not be a coincidence maybe?
14:55:41 <cmccann> hm.
14:56:03 <cmccann> elliott: how about you spend some time pondering it, and then keep notes about whether you go crazy.
14:56:04 <cmccann> for science.
14:56:39 <MichaelA_> Hey guys, I've got a question on type parameters, specifically explaining the difference between that and generics in other languages. I get that Haskell has higher kinded polymorphism and what not but how would one go about concisely explaining how and why Haskell types are more powerful than types in, say, Java or C#.
14:56:54 <elliott> cmccann: I have strong evidence to suggest I already did
14:57:19 <elliott> cmccann: we can assume causality works backwards when dealing with dual-intuitionistic systems, ergo quod erat demonstrandum
14:57:25 <hpc> MichaelA_: types in java or C# are used to say what you can't do
14:57:44 <hpc> MichaelA_: you can't add a string and a float, you can't find the length of a boolean, etc
14:58:05 <int-e> @type lenght
14:58:07 <lambdabot>     Not in scope: `lenght'
14:58:07 <lambdabot>     Perhaps you meant one of these:
14:58:07 <lambdabot>       `length' (imported from Data.List),
14:58:09 <int-e> @type length
14:58:11 <lambdabot> [a] -> Int
14:58:15 <hpc> MichaelA_: if you pick the right types in haskell, entire parts of your program can effectively write themselves
14:58:17 <int-e> -- you can't find the length of anything but a list
14:58:24 <hpc> MichaelA_: for instance, a particularly useful function is callCC
14:58:28 <hpc> :t callCC
14:58:30 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
14:58:39 <hpc> if we expand that for Cont, we get
14:58:42 <hpc> @unmtl Cont r a
14:58:43 <lambdabot> (a -> r) -> r
14:58:49 <cmccann> elliott: that almost certainly makes some finite amount of sense, probably.
14:59:18 <hpc> ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
14:59:22 <hpc> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
14:59:22 <lambdabot> f a b = a (\ c _ -> b c) b
14:59:29 <hpc> MichaelA_: you get that definition
14:59:33 <int-e> (however, that statement will keep intuitionists wondering whether length will work on lists.)
14:59:45 <cmccann> hpc: if you have djinn integrated into your development environment, parts of your program can very literally write themselves!
14:59:51 <elliott> int-e: classicists too
14:59:52 <hpc> as it so happens, this is the only function you can define with that type
15:00:05 <hpc> and as far as functions go, this one is a doozy
15:00:07 <bitonic> hpc: well...  the only meaningful one
15:00:21 <hpc> bitonic: the only non-recursive one
15:00:25 <hpc> or non-bottom
15:00:37 <bitonic> hpc: I guess that’s what I meant with ‘meaningful’ :)
15:00:44 <bitonic> defined
15:00:46 <MichaelA_> Right, I get the advantages of the Haskell type system with regards to Type Classes and such but I'm trying to explain, on a slightly more theoretical level, what makes it more powerful than Javas
15:00:54 <int-e> elliott: ah, the english language is interfering with my intended meaning :)
15:00:55 <elliott> int-e: well, sort of.
15:01:26 <hpc> MichaelA_: well, when you say something is polymorphic in haskell, it's actually polymorphic
15:01:28 <tac> MichaelA_: uniformity is probably the most important thing
15:01:42 <elliott> maybe you mean that you can deduce from the facts "every function can be applied to something" and "length cannot be applied to non-lists" that "length can be applied to lists" classically. however, you can do the same constructively, with some reasonable constraints on how you model it
15:01:49 <hpc> there's no nasty crap like instanceof to make things surprising
15:01:50 <elliott> also this is the most pointless thing I've ever argued about.
15:01:55 <cmccann> Michael__: explaining the benefit of static typing to java developers sounds like a losing battle to me
15:02:12 <int-e> elliott: :)
15:02:41 <hpc> MichaelA_: if you have done much developing in java, you probably know that you can't make arrays of generic types
15:02:53 <int-e> elliott: my excuse is that it's around midnight and I'm about to go to bed, what's yours? (don't answer this. good night :) )
15:03:02 <cmccann> elliott: ah, but the original phrasing was about whether you "can find the length", not "apply the length function". as such, you can't find the length of an infinite list either.
15:03:05 <elliott> cmccann writes my excuses for me.
15:03:15 <hpc> or you know how to cast things up and down such that you can make a universal cast from A to B
15:03:25 <Michael__>  This might derive from my only surface level understanding on monads, but what's the benefit of making something like Parsec, to parse strings, a monad versus a standard function?
15:03:30 <elliott> cmccann: oh good, a pedantry war! yes you can, it's _|_.
15:03:58 <elliott> Michael__: what kind of function are we talking here?
15:04:13 <cmccann> elliott: objection! _|_ is stupid and I hate it so that doesn't count.
15:04:14 <MichaelA_> So true polymorphism, higher kinded types and type classes. Anything more I need to throw in to really shock-and-awe a Java or C# dev?
15:04:17 <elliott> also the monad Parsec uses is a function under the hood, but I doubt that's the confusion here...
15:04:23 <hpc> MichaelA_: the haskell type system is more "solid", as it were
15:04:26 <int-e> > let safelyCoerce = undefined in safelyCoerce () :: Int
15:04:26 <Michael__> parseList :: Parser Expr
15:04:27 <Michael__> parseList = liftM List $ sepBy Expr space
15:04:28 <lambdabot>   *Exception: Prelude.undefined
15:04:36 <Michael__> For example, like ^, where Expr is self defined
15:04:42 <elliott> cmccann: ok, if you reject the presumed denotational semantics of Haskell then the problem cannot even be stated so I win byd efault.
15:05:02 <Michael__> sorry, not self defined, defined by me
15:05:11 <typoclass> Michael__: it's a good question in my opinion. it's easy to see how haskell's types are more powerful than the ones in traditional java, but with java since it got generics, it's harder to see
15:05:35 <elliott> Michael__: I don't understand the question
15:05:44 <hpc> MichaelA_: the type system is honestly quite unshocking; most of the fun comes in reasoning about new data types
15:05:48 <elliott> typoclass: I think you mean MichaelA_
15:06:15 <cmccann> elliott: it's more that you don't lose. not quite the same thing.
15:06:20 <Anonny> Sorry to bother, but could somebody throw together a gist of using aeson to access array's of objects?  (ie. [{"this": "that"}{"this":"the other"}])  Been banging my head against for a bit now and can't find any good examples.
15:06:25 <typoclass> elliott: right. sorry
15:06:27 <Michael__> Why is that using monads, versus parseList :: String -> Expr
15:06:29 <elliott> cmccann: back to the excluded middle again, I see
15:06:46 <hpc> MichaelA_: imo, the place to start for real shock-and-awe would be first-class IO
15:06:57 <MichaelA_> Right. Well, thanks, I'll be off then.
15:07:14 <hpc> ta
15:07:14 <cmccann> elliott: or Top, according to game semantics for linear logic
15:07:17 <elliott> Michael__: well, the parse can fail. so say parseList :: String -> Maybe Expr. or what if you have a parser defined by reading two lists? it needs to get the rest of the string left over. so parseList :: String -> Maybe (String, Expr)
15:07:28 <elliott> Michael__: and at this point you'll find that composing these functions is awful because of the many layers of wrapping
15:07:31 <elliott> so we define
15:07:39 <cmccann> basically "you technically win because your opponent can't do anything, but the game never actually ends"
15:07:41 <elliott> data Parser a = Parser { runParser :: String -> Maybe (String, a) }; parseList :: Parser Expr
15:07:56 <elliott> and how do we compose parsers? ah... it's a monad, so with the monad operators!
15:08:05 <hpc> cmccann: the only winning move is to be a pedantic dickweed until they get bored
15:08:17 <elliott> making something a monad isn't a special magic wand you wave over a type... it's just a set of composition operators you get
15:08:27 <cmccann> hpc: a flawless strategy
15:08:30 <hpc> incidentally, this is how nixon won the cold war
15:08:34 <cmccann> hahahaha
15:08:37 <elliott> which lets parsec encapsulate the possibility of parsers failing, backtracking, etc. into an abstract interface without you having to plumb the details manually.
15:08:51 <monochrom> the complete parser, the final finished product, can easily be String -> Maybe Expr. but that type is completely useless for components of your parser.
15:09:28 <Michael__> okay, that was informative. Thanks
15:10:18 <monochrom> Rome is not built in one day. a parser is not written as one single monolith.
15:12:28 <Taneb> It looks like it's "cabal sucks" season on reddit
15:12:33 <Taneb> :(
15:13:03 <monochrom> shall I add my http://www.vex.net/~trebla/haskell/sicp.xhtml to the fuel? :)
15:13:47 <monochrom> more seriously, half of the problem is that GHC is a cross-boundary optimizer.
15:14:22 <monochrom> people should use hugs if they don't want that half of the problem.
15:15:37 <cmccann> the other half of the problem is that people expect cabal to magically solve everything and give them a pony.
15:15:55 <elliott> the third half is that cabal is annoying
15:16:08 <Iceland_jack> How many halfs are there exactly?
15:16:11 <Iceland_jack> *halves
15:16:14 <monochrom> 4
15:16:14 <Taneb> 7
15:16:15 <elliott> seven.
15:16:19 <elliott> monochrom: you are outvoted
15:16:27 <monochrom> 10 dimensions
15:16:44 <elliott> "Are you suggesting that packages should never be allowed to make breaking changes?" "Appalling, I know. But this is what (all?) the other-language-ecosystems have settled for."
15:16:49 <elliott> well, this reddit discussion is exciting.
15:16:50 <monochrom> ok, I'll accept 7 :)
15:17:44 <cmccann> elliott: it's sort of a watered down godwin's law for reddit, as a post collects more comments the likelihood of someone expressing a really dumb opinion loudly approaches 1.
15:17:51 <monochrom> why don't I create a reddit account to reply "Haskell does not negotiate with terrorists"? :)
15:18:38 <cmccann> monochrom: that sounds like a high-quality reddit account.
15:18:50 <elliott> cmccann: I think that is because it starts as 1.
15:19:41 <cmccann> elliott: you may be right
15:23:16 <hpaste> facepalm pasted “filter” at http://hpaste.org/86884
15:23:33 <facepalm> is foldr what I would want to use to modify this to work properly?
15:24:29 <monochrom> the type sig has one spurrious [a]
15:24:57 <monochrom> foldr can be used
15:25:09 <monochrom> but not compulsory
15:25:24 <Botje> facepalm: your type says p takes two arguments, but your function body only gives it one.
15:25:38 <eikke> why didn't I ever hear about ekmett's Analytics before?!
15:25:49 <Botje> facepalm: likewise, your type says your function takes two lists, but you only pattern match on one.
15:26:04 <monochrom> it is not mentioned that often, until recently. afterall, he has only started recently.
15:26:42 <facepalm> Botje: yeah thats what I cannot figure out how to fix..how to modify it to work
15:26:59 <cmccann> eikke: because edwardk generates new libraries faster than other people can figure out what they all do
15:27:34 <Botje> facepalm: start by pattern matchin on two lists instead of one.
15:28:18 <facepalm> Botje: for the filtermask _[] = [] part?
15:28:31 <Botje> facepalm: that and the other one.
15:28:35 <eikke> cmccann: heh :) this stuff looks really neat!
15:28:55 <cmccann> eikke: also apparently you don't watch conversations in #haskell-lens much
15:28:57 <facepalm> Botje: I can make it for two by doing _[][] = [] correct?
15:29:02 <cmccann> it's been as much analytics as lens lately I think :P
15:29:07 <Botje> facepalm: that's for the first case, yes.
15:29:15 <eikke> cmccann: no, indeed. guess I should
15:29:18 <Botje> facepalm: now the second case.
15:29:52 <cmccann> eikke: the thing to realize is that #haskell-lens is more like #haskell-edwardkscurrenthobby in practice
15:30:00 <facepalm> Botje: I tried to add another | statement but then it crashes saying syntax error on |
15:30:10 <eikke> cmccann: trying to get a quote in HWN? :P
15:30:27 <cmccann> no, that's shachaf's job.
15:30:29 <Botje> facepalm: please revisit your textbook or source material on how to pattern match.
15:30:48 <Botje> the pattern match needs to come before the | clauses.
15:39:48 <mitchell> Hi, I am writing a parser for "tiny" and have implemented 90% now but I am stuck on how to parse Identifiers.  Here is my code, any help would be appreciated.
15:40:01 <hpaste> mitchell pasted “tiny parser” at http://hpaste.org/86885
15:41:01 <simpson> mitchell: Do you have a reference on this? Unrelated, but I wish to make an example out of your grammar in a separate project.
15:41:54 <Botje> mitchell: you have a perfectly nice 'ident' parser sitting around
15:42:23 <mitchell> simpson: gordons haskell book i believe
15:42:47 <simpson> mitchell: Also, I mean, are your identifiers something like... identifier = ('_' | <alpha>) ('_' | <alpha> | <digit>)+
15:43:09 <simpson> Er... identifier = ('_' | <alpha>) ('_' | <alpha> | <digit>)*
15:43:31 <mitchell> I think they are any alpha num
15:45:40 <mitchell> lol all the different parsers for constructing the tiny parser were given to us
15:45:53 <mitchell> I think it made it harder lol
15:48:09 <monochrom> I don't understand the question. you can already use "identifier" which is near the end of module Parsing
15:48:39 * hackagebot postgresql-simple 0.3.1.2 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.1.2 (LeonSmith)
15:49:27 <mitchell> umm let me make sure I am on the right track
15:49:37 <mitchell> an identifier is a string that references an expression right?
15:49:42 <mitchell> oh wait a command
15:50:05 <monochrom> you don't know identifier? it means variable name.
15:50:09 <mitchell> or is that does in the interpreter?
15:50:18 <mitchell> yeah i know what it is lol
15:50:30 <simpson> mitchell: Oh, are you wondering about how your data structure should look?
15:50:47 <mitchell> Yeah
15:50:57 <Reku> Does anyone here use Leksah IDE, if so could you help me with a depedency error I am having?
15:50:58 <Reku>  
15:51:18 <monochrom> your Exp already has "I Ide", that's where you store an identifier
15:51:23 <mitchell> I guess I am confused as what I am suppose to do for the parser compared to the interpreter
15:51:37 <monochrom> ok, again, your Exp already has "I Ide", that's where you store an identifier
15:52:38 <monochrom> and the relevant grammar rule is "<factor> ::= read | false | true | 0 | 1 |  <ide> | (<expr>)", so you are to add something to your factor code.
15:52:58 <hpaste> Reku pasted “ GLUT library Leksah Error” at http://hpaste.org/86886
15:53:29 <mitchell> sorry I am slow lol, doing 3 different papers in 3 dif languages atm
15:53:35 <mitchell> gets confusing
15:54:18 <monochrom> ok, come back when you have 0 papers to do and focus on this code, just this code and nothing else.
15:54:37 <mitchell> it his homework btw
15:54:49 <monochrom> that makes no difference.
15:54:50 <mitchell> i understand how the structure of the parser works
15:55:08 <mitchell> and the tree form it takes etc
15:55:36 <monochrom> be careful with that claim. my definition of "understand" is whether you get things to work.
15:56:01 <monochrom> "I understand it but I can't get it to work" is a contradiction by my criterion.
15:56:31 <monochrom> it is the only objective, observable criterion and therefore the only tenable one.
15:57:21 <mitchell> well it parses everything but identifiers =\
15:57:41 <monochrom> again, you have things to add to factor for that.
15:58:25 <monochrom> "<factor> ::= read | false | true | 0 | 1 |  <ide> | (<expr>)" but your factor code does not have that <ide> case.
15:58:56 <monochrom> (how many times must I repeat myself?)
15:59:06 <mitchell> I know it doesn't lol
15:59:12 <mitchell> I don't know how to write it
15:59:14 <mitchell> =\
15:59:20 <mitchell> trying to get my head around it
15:59:24 <mitchell> with the other cases
15:59:41 <mitchell> it reads the input and returns the value
15:59:46 <mitchell> but identifier is different
15:59:46 <monochrom> ok, then learn from the other cases first. they are inspirations.
16:01:11 <facepalm> Botje: you said for first case I can have the two empty lists correct? _[][] =[] I only ask because I have not seen many examples where it has the [][]..sorry I am noob I am learning ask I go here. I am still on same problem haha
16:03:45 <monochrom> the way I do homework, I start by not doing the homework. I butcher the homework first. I cut away 90% of 95% of it, and I ask myself, how do I do this 10% or 5%, what should I learn to do this?
16:04:39 <schellsan> have you guys ever run into an error like " Couldn't match expected type `FilePath' with actual type `FilePath'"
16:04:52 <Clint> yes
16:04:52 <monochrom> for example I may just do "<blah> ::= <ide> | not <blah>" first
16:05:27 <monochrom> then I cut out another 5% of the homework and do that. etc etc.
16:05:35 <schellsan> does this mean i've included two separate FilePath types or something?
16:05:47 <Clint> @hoogle FilePath
16:05:47 <lambdabot> Prelude type FilePath = String
16:05:48 <lambdabot> System.IO type FilePath = String
16:05:48 <lambdabot> System.FilePath.Windows type FilePath = String
16:05:48 * typoclass walks over to monochrom, meows, and looks attentive. i reason if there's butchering, there will be some leftover meat for kitty. or some meat that is not being actively defended at all times
16:06:06 <monochrom> if the homework is due in 2 weeks, I can easily spend 1.5 weeks doing just that. cut out 5% of it, do just that.
16:06:56 <mitchell> seems like you have it all figured out
16:07:00 <mitchell> anyway thanks for the help
16:07:02 <mitchell> goodbye
16:07:32 <schellsan> ... well shoot - how do I incorporate all those synonymous types?
16:08:59 <Clint> schellsan: you should figure out the cause of your actual problem
16:09:10 <typoclass> schellsan: FilePath is a type synonym for String, defined in System.Something. it'd be unusual if you defined another thing named FilePath, or if you imported one
16:09:32 <luite> not so unusual, system-filepath has another one
16:09:47 <luite> since String isn't really the correct type for filenames
16:10:12 <luite> and it's OS-dependent what is
16:10:13 <typoclass> luite: hm ok. haven't heard of system-filepath
16:10:26 <Clint> and other packages use that type
16:10:37 <schellsan> ah - looks like the fsnotify pkg is using Filesystem.Path.FilePath
16:11:13 <luite> typoclass: system-fileio, shelly and a few other things use it
16:11:15 <Clint> there you go
16:11:18 * eikke just wrote what might be the most ugly haskell code he ever wrote
16:12:35 <typoclass> schellsan: i suggest that to avoid confusion, you don't import the FilePath from System.FilePath. try adding "hiding" to your import statement
16:12:48 <luite> import Prelude hiding (FilePath)
16:13:37 <Clint> i always import Filesystem.Path.CurrentOS as qualified
16:14:00 <typoclass> schellsan: urgh, luite is right. Prelude brings in FilePath. could have sworn it doesn't
16:15:29 <facepalm> is it legal to have _[][] =[] ?
16:15:56 <Eduard_Munteanu> facepalm: what does that mean?
16:16:58 <lightquake> how should i implement collision detection in a game?
16:17:02 <hpaste> facepalm pasted “filter” at http://hpaste.org/86890
16:17:10 <facepalm> Eduard_Munteanu: like that
16:17:16 <lightquake> like, ignoring the question of 'does this shape collide with that shape'; assume i can solve that
16:17:43 <Eduard_Munteanu> facepalm: you should separate that by a space, [] []
16:17:54 <lightquake> should i have all my collideable objects output a shape and then collide them?
16:18:23 <Mortchek> facepalm, keep in mind you could have filtermask p (x:xs) [] as well, for example
16:18:25 <Eduard_Munteanu> facepalm: also the second clause seems to miss one argument
16:18:52 <facepalm> Eduard_Munteanu: okay I am still trying to figure out how to modify my second case to get this to work properly
16:18:58 <lightquake> or should each object be responsible for, given a shape, computing 'does this collide with me'
16:19:38 <Mortchek> facepalm, hint: how many parameters does p take? How many are you applying it to?
16:20:00 <Eduard_Munteanu> lightquake: you probably want to look into collision detection in general, it's a studied problem
16:20:03 <typoclass> facepalm: the type signature indicates 3 arguments (a function, a list, another list). the first equation agrees with that (_ and [] and []), but the second equation doesn't agree, giving only the 2 arguments p and (x:xs)
16:20:33 <lightquake> Eduard_Munteanu: fair, but i imagine a lot of that is designed around OO languages
16:21:04 <facepalm> typoclass: yes that is what I am trying to figure out how to fix. I did try to change it to x:y:xs but that did not work either
16:22:18 <typoclass> facepalm: that will match on lists of length 2 and up. it will call the first element x, the second one y, and the rest of the list xs (which may have any length, even 0)
16:22:26 <Eduard_Munteanu> lightquake: you should still study that first, the math isn't OO-ish
16:22:47 <oconnor0> facepalm: where is the third argument to filtermask in "filtermask p (x:xs)"?
16:22:50 <lightquake> Eduard_Munteanu: right, i'm not concerned about the math, more about 'where does the actual code live'
16:22:50 <typoclass> facepalm: anyway, you want "(x:xs) ys" or "(x:xs) (y:ys)" or whatever you need :-)
16:22:58 <lightquake> for now everything is going to be squares so the math is easy :)
16:24:02 <facepalm> andy make 2 more of the | statements for the y's?
16:24:38 <Eduard_Munteanu> lightquake: I haven't done stuff like that :/
16:25:13 <hpaste> facepalm revised “filter”: “filter” at http://hpaste.org/86890
16:25:19 <facepalm> like that
16:25:50 <elliott> lightquake: "or should each object be responsible for, given a shape, computing 'does this collide with me'" this approach seems to have the same pitfalls as single dispatch OOP does for things like arithmetic
16:26:05 <elliott> where x.plus(y) isn't necessarily y.plus(x), and which to choose isn't obvious
16:26:06 <facepalm> minus filtermask p (x:xs) [] lol
16:26:12 <lightquake> elliott: true
16:26:54 <lightquake> so it's more appropriate to have a 'collides with' function and dispatch collision events?
16:31:24 <facepalm> typoclass: like this? http://pastebin.com/D3PB6mWW or something close. this still yells at me haha
16:32:57 <oconnor0> facepalm: some of your recursive calls to filtermask only have 2 arguments instead of 3.
16:43:41 * hackagebot hashable 1.2.0.7 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.7 (JohanTibell)
16:49:06 <h4199> facepalm: Are you still trying to do what you wanted to do earlier?
16:51:03 <h4199> If you are, then notice that you are keeping values from both lists, as I understood it you wanted to compare x and y not match against them in separate guards
16:51:24 <facepalm> h4199: yes I got it to somewhat work but it does not produce the correct results http://pastebin.com/BPP6X8eA it runs now at least
16:52:52 <facepalm> h4199: calling it like this filtermask(\m d -> d > m)[1,5,7][5,6,7] returns [1,5] and it should return [5,6]
16:53:20 <h4199> look at your first guard closely
16:53:42 * hackagebot kure 2.6.22 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.6.22 (NeilSculthorpe)
16:53:54 <h4199> tell me which list it keeps values from
16:55:53 <facepalm> h4199: from first list
16:56:25 <h4199> and you only want values from the second list right?
16:57:10 <facepalm> h4199: correct so I have to change it to match the guard below? filtermask p xs ys ?
16:58:06 <h4199> More accurately, you only really need the guard below, but switch y and x and ys and xs to match the first guard
16:58:31 <h4199> otherwise the lists will flip every time you recurse
16:59:18 <ezyang> Are all pullbacks in Haskell trivial?
17:01:29 <h4199> facepalm: Additionally, you need to change change your initial pattern match to handle these cases p [] _ and p _ [], the case of _ [] [] will not cover you for uneven lists
17:02:45 <h4199> facepalm: oops formatting goof, and I meant lists with different lengths
17:05:18 <facepalm> h4199: is this what you mean? http://pastebin.com/zJWv5RBQ
17:06:10 <h4199> first things first, tell me why this won't work: filtermask p (x:xs) (y:ys) []
17:06:13 <dmwit> Are you just randomly guessing syntax?
17:06:34 <facepalm> dmwit: no
17:06:45 <dmwit> Okay. Defend yourself. Why did you write what you wrote?
17:07:44 <h4199> facepalm: second thing, Tell me what values this will keep: p x y       = x y : filtermask p ys xs
17:07:57 <h4199> *ingnoring the syntax error
17:08:48 <facepalm> values from list one so it ys and xs should be switched
17:09:41 <schellsan> how can i turn a String into a FilePath?
17:09:48 <dmwit> id
17:09:52 <schellsan> ahhh
17:09:55 <eikke> dmwit: lolz
17:09:56 <schellsan> thank your
17:10:01 <schellsan> you
17:10:01 <h4199> facepalm: they should be switched, but not for that reason.
17:10:01 <schellsan> *
17:10:32 <dmwit> ?src FilePath
17:10:33 <lambdabot> type FilePath = String
17:10:58 <schellsan> i keep getting errors like "Couldn't match expected type `String' with actual type `FilePath'"
17:10:59 <h4199> facepalm: It looks like you are trying to keep an x and a y at the start of the list, that is not what you want right?
17:11:11 <schellsan> so thanks
17:11:16 <dmwit> Perhaps you are using a different FilePath than the one in the libraries shipped with GHC.
17:11:30 <typoclass> schellsan: if you're using package system-filepath, try looking at this http://hackage.haskell.org/packages/archive/system-filepath/0.4.7/doc/html/Filesystem-Path-CurrentOS.html
17:11:35 <dmwit> If so, you should say which one, and which package it's coming from.
17:11:55 <schellsan> well it's from Filesystem.Path
17:12:23 * dmwit twitches at "Safe Haskell: Safe Infered"
17:12:41 <dmwit> fixitfixitfixitfixitfixit
17:13:30 <schellsan> hey that helps - thanks
17:13:31 <Clint> never fere
17:13:37 <facepalm> h4199: no its not what I want
17:13:42 * hackagebot finite-field 0.4.0 - Finite Fields  http://hackage.haskell.org/package/finite-field-0.4.0 (MasahiroSakai)
17:14:20 <h4199> facepalm: so if you only want the y, then only write the y
17:15:35 <h4199> facepalm: the reason that the ys and xs are in the wrong order is that if you use it that way your "mask" becomes the good list and the good list becomes the "mask" in the next call, can you see why that is?
17:16:39 <facepalm> h4199: it works :) http://pastebin.com/HfzVnM6G
17:17:06 <schellsan> thanks guys - that did it
17:17:34 <facepalm> h4199: yes I see what you mean.
17:18:02 <h4199> facepalm: almost there! try it with these two though [1,5,7][5,6,7,8]
17:18:09 <facepalm> h4199: I still need to fix it for my empty list though correct? you said  _ [] [] would not work for all cases
17:19:01 <h4199> facepalm: yeah that case will only match when both lists are empty, not just one or the other
17:21:11 <dmwit> "I still need to fix it for the empty list" is not correct, because "the empty list" is not precise.
17:21:25 <dmwit> You have two arguments which are both lists.
17:21:44 <dmwit> Each may be empty independently.
17:22:23 <facepalm> h4199: I switched it to filtermask p [] _ = [] filtermask p _ [] = [] and it works now.. ty I appreciate it
17:22:59 * h4199 cheers
17:24:30 <dropdrive> Are there any examples of (e)dsls where one can define and inspect "functions"?
17:24:47 <lightquake> i want to have a data type where you have the usual map-ish operations on it (insert, delete) but inserting items automatically picks an unused key
17:25:30 <dmwit> lightquake: sounds like fun
17:25:52 <lightquake> (what i'm Really Trying To Do is have a set of objects in a game, each of which has an ID)
17:25:56 <Mortchek> lightquake, have you considered using a Set?
17:26:10 <lightquake> Mortchek: doesn't work, since you can't index into a set
17:26:11 <dmwit> lightquake: Perhaps you would like
17:26:14 <dmwit> ?hackage monad-supply
17:26:14 <lambdabot> http://hackage.haskell.org/package/monad-supply
17:26:18 <Mortchek> A Unique then
17:26:31 <lightquake> Mortchek: unique?
17:26:37 <Mortchek> @hoogle Unique
17:26:37 <lambdabot> Data.Unique module Data.Unique
17:26:37 <lambdabot> Data.Unique data Unique
17:26:37 <lambdabot> package uniqueid
17:26:48 <elliott> pfft, Supply is just Free . (->)
17:27:09 <dmwit> Supply is State, but without the MonadState instance.
17:27:16 <dmwit> This is useful for the same reason MonadRandom is.
17:27:59 <lightquake> namely that it lets you stick it in your stack without running into ambiguities?
17:28:24 <dmwit> Yes, it means it coexists with another instance of MonadState nicely.
17:32:55 <elliott> dmwit: Supply isn't State if you want to use it for interesting things
17:32:58 <elliott> like supplying from user input
17:33:17 <elliott> or an RNG where you can't cheat and use randoms
17:33:29 <elliott> seems that package's definition is too weak for this though :/
17:37:32 <lightquake> i don't think i want to wrap the map up in the state monad though; i might just want to make a new type data ObjMap a = ObjMap (Map ObjId a) ObjId
17:37:33 <lightquake> or something
17:50:51 <dmwit> lightquake: Yes, that is what I was imagining when you started.
17:50:59 <dmwit> It has the advantage of being nice and simple.
18:13:52 <mike4_> haskell sucks balls!
18:14:26 <mike4_> I'm stuck!
18:14:27 * copumpkin yawns
18:14:42 <copumpkin> if you have non-trollish ways of asking for help, those will work
18:16:37 * copumpkin pokes ryant5000 
18:17:05 <ryant5000> copumpkin: hey
18:18:58 <Reku> haskell is excellent I dont know what you are talking about.
18:20:44 <hpc> haskell is a terrible name
18:20:47 <hpc> even haskell thinks so!
18:23:15 <mike4_> do many trolls come in here?
18:23:24 <mike4_> why?
18:25:02 <typoclass> mike4_: i don't know why trolls do what they do. anyway, that's not the topic of this channel. if you have any questions about the haskell programming language, we'll happily take those
18:25:42 <mike4_> ok
18:25:54 <mike4_> no I figured it out
18:38:26 <dmwit> That's taking things to a new low.
18:39:01 <dmwit> I used to get annoyed when I ran across a forum post describing a problem I was having with a single reply, "I fixed it.". But seeing the same thread, minus the problem description... =P
18:40:01 <Mortchek> dmwit, if you were a mathematician, you would only care that a solution exists
18:41:10 <djahandarie> Would he? I dare say mathematicians care about proofs more than any other people.
18:41:25 <djahandarie> And who's to say that dmwit isn't a mathematician? ;p
18:41:40 <elliott> Mortchek: you've clearly never talked to a constructivist
18:41:45 <Mortchek> It was a (reference to a) joke
18:41:54 <dmwit> I have been informed elsewhere on IRC in no uncertain terms that I am not a mathematician.
18:41:58 <dmwit> Who am I to argue?
18:42:03 <Mortchek> and yes, since this is #haskell, I've considered the probability that any given person I may talk to is a mathematician
18:42:13 <Mortchek> talk to may be*
18:50:58 <lightquake> i hate dealing with mutually recursive types
18:51:08 <lightquake> because you can't have mutually recursive modules
18:51:46 <geekosaur> well, you can, it's just annoying
18:51:53 <geekosaur> hs-boot files :/
18:52:29 <arbn> Is it just me, or is Data.Vector.Storable.ByteString not Storable? Where can I find a Storable ByteString?
18:54:08 <arkeet> what is Data.Vector.Storable.ByteString?
18:54:33 <arbn> arkeet: Vector Word8, apparently.
18:54:43 <arkeet> I don't see such a thing
18:54:50 <arbn> http://hackage.haskell.org/packages/archive/vector-bytestring/0.0.0.1/doc/html/Data-Vector-Storable-ByteString.html
18:54:57 <arkeet> oh, different package.
18:55:04 <arbn> arkeet: Honestly, though, I just want to know how to get a Storable ByteString of *any* sort.
18:55:11 <arkeet> sure it's storable.
18:55:19 <arkeet> it's a type synonym for a storable thing.
18:55:27 <arbn> arkeet: Where do I find the Storable instance for that?
18:55:44 <arkeet> it's the storable instance for Vector Word8
18:56:01 <arkeet> errrr
18:56:02 <arbn> Is that in Data.Vector.Storable?
18:56:12 <arkeet> wait.
18:56:29 <arkeet> Vectors aren't storable.
18:56:50 <arbn> Then why is it called Data.Vector.Storable?
18:57:02 <arkeet> because it's a vector whose elements are Storable.
18:57:32 <arkeet> I think you're trying to use Storable for the wrong thing.
18:59:13 <arkeet> Storable is for fixed-size values of primitive types.
18:59:35 <arkeet> sizeOf doesn't make sense for Vector, say.
18:59:35 <arbn> arkeet: Oh. I see. So, an array of ByteString doesn't even make sense. I would have to concatenate them together  first.
19:00:06 <vikt0r0> Anyone familiar with the generic queries in Data.Generics?
19:01:04 <dmwit> um
19:01:12 <dmwit> Surely even after concatenating them they're variable-sized?
19:01:27 <dmwit> ?where justask
19:01:27 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
19:01:29 <dmwit> vikt0r0: ^^
19:01:39 <vikt0r0> Okay: http://hpaste.org/86895
19:03:06 <arbn> dmwit: OK. I'll take a step back. I have a function that produces an IO [Text]. I want to export a foreign-ized version of this. Recommendations on a foreign type to use for this?
19:03:27 <dmwit> vikt0r0: What's TypeBox?
19:04:09 <Saizan> vikt0r0: try commenting out the signature for containsVarIdx, isVar and isRef
19:05:03 <dmwit> arbn: I suppose you must encode it to a Ptr (Ptr CChar) or similar.
19:05:18 <dmwit> I'm sure that text (or possibly bytestring) already has functions for doing this.
19:05:56 <Saizan> yes, bytestring has functors to convert to Ptr CChar, aka CString
19:05:58 <vikt0r0> dmwit: It's used for boxing of types in the AST, and possibly retrieving them
19:06:02 <Saizan> *functions
19:06:34 <arbn> OK. So, I should expect to export something outputting a CString. Makes sense.
19:07:08 <arbn> A Ptr CString, rather.
19:07:15 <dmwit> See {pack,useAs}CString{,Len}
19:07:31 <vikt0r0> Saizan: It gives me http://hpaste.org/86896
19:08:24 <dmwit> Data.Text.Foreign also looks relevant.
19:09:36 <arbn> dmwit: I was looking at that...
19:09:40 <vikt0r0> I read that it uses rank-2 polymorphism, so doesn't that mean that I will need to explicitly write the signatures of each binding, as type inference is undecidable?
19:09:46 <arbn> dmwit: Might be a more faithful representation than CString.
19:09:59 <vikt0r0> 'It' being Data.Generics...
19:12:15 <lightquake> geekosaur: yeah, i really don't want to get into that
19:14:02 <Saizan> vikt0r0: not each
19:14:42 <Saizan> vikt0r0: anyhow i guess you need to provide some signatures here, because there's some ambiguity (not caused by rank-2 actually)
19:16:04 <Saizan> vikt0r0: 1) everything needs a Data instance for the type of its last argument, so you need "containsVarIdx :: Data tf => Exp tf -> Bool" according to your instance Data t => Data (Exp t) listed in one of those errors
19:16:11 <vikt0r0> Saizan: Yes, I'm just having a really hard type wrapping my head around the error message. I am not really sure what tf0 refers to in e.g.: "The type variable `tf0' is ambiguous"
19:17:18 <Saizan> vikt0r0: tf0 is an autogenerated name of a variable created during typechecking, usually you have to figure out what it refers to from where it's used in the rest of the error message
19:17:45 <Saizan> vikt0r0: but the fact that it starts with "tf" hints that it's related to the variable you've called tf yourself
19:17:56 <vikt0r0> Saizan: Aha.
19:18:20 <Saizan> vikt0r0: anyhow, the second problem is that you have to fix a type for the second argument of mkQ
19:18:48 <vikt0r0> Saizan: Okay, so what does that imply?
19:18:53 <Saizan> mkQ :: (Typeable b, Typeable a) => r -> (b -> r) -> a -> r
19:19:36 <Saizan> in your code you have r = Bool, a is fixed by everything, but b needs to be pinned down
19:20:26 <Saizan> you could e.g. write ((||) <$> isVar <*> isRef :: Exp X -> Bool) for some concrete type X of your choice
19:20:39 <Saizan> this would make it typecheck, but maybe it's not what you want?
19:21:04 <Saizan> i.e. it will only pick the occurences of Exp X to test, not Exp Y or other..
19:21:21 <vikt0r0> Saizan: But doesn't that inference happen when i declare the signatures of isVar and isRef and glue them together with the applicative stuff?
19:21:49 <vikt0r0> e.g. isRef :: Exp tf -> Bool
19:21:50 <vikt0r0> Ahh
19:22:06 <vikt0r0> 'Concrete type' is the keyword, I guess...
19:23:17 <Saizan> yeah, it can't just be a variable like tf
19:23:35 <Saizan> otherwise it doesn't know which Typeable instance to use
19:24:15 <Saizan> though i suspect that you want something else built around Data.Typeable.gcast1
19:24:38 <Saizan> which would let you handle any tf
19:25:00 <vikt0r0> Yes, it is compiling now. However I am not really sure that's what I want. A little confused right now tbh.
19:25:32 <vikt0r0> But thanks for that.
19:27:05 <vikt0r0> Saizan: If I were to use gcast1, I suppose would I have to design the traversal functions all over again?
19:28:30 <Saizan> vikt0r0: you'd only have to replace the mkQ part i think
19:29:16 <Saizan> mh, maybe not
19:29:44 <lpvb> is there no more state monad?
19:29:48 <lpvb> just StateT?
19:29:54 <Saizan> everything wants a forall a. Data a => a -> r
19:29:58 <Eduard_Munteanu> lpvb: there is
19:30:16 <lpvb> well it's not in Control.Monad.State anymore
19:30:18 <Eduard_Munteanu> lpvb: though plain State is just StateT over Identity
19:30:42 <lpvb> yea
19:30:49 <lpvb> but that type isn't there anymore
19:30:55 <Hidenori> Hello guys, I am wondering what is the difference between truncate and ceiling? Their types seem to be exactly the same and I tried a few parameters but they return the same value everytime
19:31:10 <Ralith> > truncate 1.5
19:31:12 <lambdabot>   1
19:31:13 <Ralith> > ceiling 1.5
19:31:15 <lambdabot>   2
19:31:44 <aavogt> lpvb: you should have something like:   type State s = StateT s Data.Functor.Identity.Identity
19:31:46 <Hidenori> sorry floor
19:31:50 <Eduard_Munteanu> lpvb: type State s = StateT s Identity    in Control.Monad.State.Lazy
19:31:51 <h4199> > floor 1.5
19:31:53 <lambdabot>   1
19:32:02 <sellout-> > truncate -1.5
19:32:02 <geekosaur> > truncate (-2)
19:32:04 <lambdabot>   Ambiguous type variable `b0' in the constraints:
19:32:04 <lambdabot>    (GHC.Real.Fractional b0...
19:32:04 <lambdabot>   can't find file: L.hs
19:32:08 <geekosaur> bah
19:32:13 <sellout-> > floor (-1.5)
19:32:14 <Hidenori> im wondering about the difference between floor and truncate
19:32:15 <lambdabot>   -2
19:32:16 <aavogt> @type state
19:32:17 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
19:32:24 <sellout-> > truncate (-1.5)
19:32:27 <lambdabot>   -1
19:32:33 <geekosaur> Hidenori, ^^
19:32:55 <Hidenori> geekosaur ^^
19:32:57 <Eduard_Munteanu> Hidenori: truncate removes the fractional part altogether, while ceiling rounds to the next higher integer
19:32:59 <cschneid> does anybody have a halfway decent tutorial on writing my own quickcheck generators and generally best practices?  ie, I want to check that if two strings are only a single char apart, some property holds. But I'm not sure how to make that generator
19:33:00 <sellout-> Hidenori: floor rounds toward neg infinity, truncate rounds toward 0.
19:33:10 <geekosaur> Hidenori, that meant "look just above this"
19:33:22 <Hidenori> ohhhhhh got it! Thank you!!
19:33:51 <shachaf> ☝ is a better way of saying it.
19:34:02 <Hidenori> ohh i see lol
19:34:17 <Hidenori> geekosaur I thought it's smile lol
19:34:33 <Eduard_Munteanu> Heh.
19:35:27 <vikt0r0> Saizan: Well it compiles, at least that's something :-) I think what I need is a good read on the type system some time.
19:35:38 <Saizan> vikt0r0: it seems Typeable doesn't have a way to cast something into Exp tf for some unknown tf, though i guess it could be built by checking the TypeRep and using unsafeCoerce yourself
19:36:01 <Saizan> vikt0r0: the SYB papers are also fairly readable
19:36:13 <vikt0r0> Saizan: Yes, I found that.
19:36:55 <Saizan> vikt0r0: there are newer approaches to generics too btw, like uniplate (and its lens version)
19:37:29 <Saizan> (but i think the problem with Typeable would stay)
19:38:42 <lpvb> well can someone tell me why I get this error
19:38:47 <lpvb> Plugin/Pl/Transform.hs:77:21:
19:38:48 <lpvb>     Not in scope: data constructor `State'
19:38:50 <lpvb>     Perhaps you meant `StateT' (imported from Control.Monad.State)
19:38:52 <lpvb> on this file
19:38:54 <lpvb> https://github.com/benmachine/pointfree/blob/master/Plugin/Pl/Transform.hs
19:39:01 <lpvb> it doesn't make sense
19:39:08 <lpvb> there's no State constructor anywhere
19:39:14 <Saizan> lpvb: there used to be
19:39:19 <Saizan> lpvb: in older versions of mtl
19:39:20 <lpvb> yea but in that file
19:39:29 <lpvb> there isn't any use of a State constructor function
19:39:38 <lpvb> so I don't know why GHC is complaining
19:40:17 <Saizan> oh, are you sure you are compiling that version of the module then?
19:40:26 <Saizan> what command are you running?
19:40:31 <lpvb> cabal install pointfree
19:41:04 <Saizan> yeah, that'd pick the pointfree from hackage, not from the git repo or locally
19:41:23 <lpvb> same file
19:41:45 <lpvb> I downloaded the tarball and it says the same thing on line 77
19:43:53 <Saizan> tried with cabal update first? maybe it's picking the older version
19:44:01 <lpvb> yea I did
19:44:53 <Saizan> no idea then, pointfree-1.0.4.3 builds fine here
19:45:30 <lpvb> which ghc version?
19:45:59 <Saizan> 7.4.1
19:46:20 <lpvb> oh I'm using 7.6.2
19:46:58 <Saizan> yeah, i'm a bit behind
19:48:02 <hpaste> “Anonymous Coward” pasted “CHATLOLGS” at http://hpaste.org/86897
19:53:11 <Ralith> Is there any way to enable a cabal flag by default iff an external tool is available in the build environment?
19:55:40 <byorgey> Ralith: not that I know of
19:55:45 <Ralith> aw.
20:08:38 <cschneid> Why is this giving me a non-exhaustive pattern error? https://gist.github.com/anonymous/5915b5313ea70193d724
20:09:46 <cschneid> it's not making too much sense - since it says "if you give me anything that didn't pattern match (x:xs), then just return a single element list of the char.
20:09:48 <cschneid> (which is a string)
20:09:50 <byorgey> cschneid: on line 3 you have  replaceFirstchar  instead of  replaceFirstChar
20:09:54 <byorgey> note the lowercase c
20:10:00 <cschneid> hahaha
20:10:01 <cschneid> damn it
20:10:06 <cschneid> byorgey: thanks a bunch
20:10:06 <byorgey> so you are defining two separate functions
20:10:07 <cmears> cschneid, also newer versions of GHC give better error messages:
20:10:16 <cmears> "In an equation for `replaceFirstChar': Patterns not matched: [] _"
20:10:21 <cschneid> ohh, cool
20:10:47 <cmears> And with -Wall you'd get "no type signature" for the unintended lower-case spelling
20:11:00 <shachaf> -Wall is the future.
20:11:09 <cmears> The future, today!
20:11:19 <shachaf> In the future, -Wall will be the present.
20:11:43 <cschneid> version 7.4.2 -- worth figuring out how to update my ghc?
20:12:21 <cmears> I would update, so long as all the libraries you like build with 7.6
20:12:31 <cschneid> I don't like libraries
20:12:32 <sw2wolf> when building, ghc-7.6.x seems slower than ghc-7.4.x ?
20:12:36 <byorgey> I wouldn't update
20:12:42 <cschneid> I've spent the last 2 hours just figuring out quickcheck
20:12:46 <cschneid> (still don't have it... )
20:12:47 <cschneid> hah
20:12:53 <sw2wolf> At lease i feel it slower in freebsd box
20:28:28 <DanBurton> cschneid: what's your trouble?
20:28:48 <DanBurton> building quickcheck with 7.4.2?
20:28:52 <cschneid> DanBurton: nothing in particular. Having problems making quickcheck fail in a specific way with something that should.
20:28:56 <cschneid> I built it just fine, and am using it
20:29:04 <cschneid> after muddling through outdated tutorials that aren't correct any more :)
20:29:09 <cschneid> the RealWorldHaskell one was good
20:29:40 <DanBurton> is there a word for that... "docrot"?
20:30:40 <parcs> > let p = 1/6 in map (\n -> 1 / (1/p  + n - 1)) [1..6] -- does this look familiar to anybody?
20:30:42 <lambdabot>   [0.16666666666666666,0.14285714285714285,0.125,0.1111111111111111,0.1,9.090...
20:31:08 <parcs> err :(
20:32:00 <parcs> > let p = 1/6 in map (\n -> 1 / (1/p - (n - 1))) [1..6] -- does this look familiar to anybody?
20:32:02 <lambdabot>   [0.16666666666666666,0.2,0.25,0.3333333333333333,0.5,1.0]
20:32:35 <DanBurton> looks familiar, not sure why though :P
20:33:09 <ijp> DanBurton: I think it looks familiar, because parcs suggested it was probably familiar :)
20:33:36 <parcs> if you perform 6 experiments in order with those respective probabilities of success, the probability of each experiment to succeed first is 1/6
20:34:02 <ijp> ah, backwards harmonic numbers
20:34:06 <ijp> from 1/6
20:34:07 <DanBurton> > let x = 6 in map (\n -> 1 / (x - (n - 1)) [1 .. x]
20:34:09 <lambdabot>   <hint>:1:51: parse error (possibly incorrect indentation)
20:34:26 <DanBurton> > let x = 6 in map (\n -> 1 / (x - (n - 1))) [1 .. x]
20:34:27 <parcs> ijp: woah!!
20:34:27 <lambdabot>   [0.16666666666666666,0.2,0.25,0.3333333333333333,0.5,1.0]
20:34:39 <ijp> parcs: I cheated, and used ratios :P
20:35:07 <Anpheus_> How does one build or install GHC on a system that lacks a package containing libgmp3.so?
20:35:22 <Anpheus_> Such as Ubuntu 13.04 Raring Ringtail, which removed the libgmp3c2 package found in prior versions
20:35:27 <ijp> stupid floating point obscuring perfectly reasonable rationals
20:35:29 <DanBurton> it's just obfuscated by p = 1/6, 1/p
20:35:55 <lispy> Anpheus_: can you fix the problem with a symlink?
20:36:08 <parcs> DanBurton: oh right. duh
20:36:17 <lispy> Anpheus_: I guess you could also build libgmp from scratch
20:36:19 <Anpheus_> lispy: I don't know, is libgmp10 compatible?
20:36:28 <lispy> Anpheus_: I don't know either :(
20:36:48 * lispy has not been in your situation
20:36:51 <Anpheus_> damn
20:37:12 <Clint> have you tried apt-get install ghc
20:37:15 <Anpheus_> Well, the situation is, I want to either build it from source or from the binaries available on the GHC site instead of package management, to ensure uniformity between servers and clients
20:37:16 <lispy> Anpheus_: Do you have any ghc that you can install?
20:37:29 <Anpheus_> I could do that, but my servers are 12.04.2 LTS, and my dev machine is 13.04
20:37:40 <Clint> use a 12.04.2 chroot
20:37:50 <lispy> What if you the apt-get version to build a custom version?
20:38:18 * lispy isn't fully understanding which problem to solve
20:38:21 <AfC> or use LXC to get a lightweight 12.04.2 install
20:38:30 <lispy> Anpheus_: so you want to have the same version of ghc on both versions of ubuntu?
20:38:43 <Anpheus_> lispy: Yes, and the ghc packages are out of sync on each
20:39:15 <lispy> Anpheus_: ah, so in that case. Use the distro ghc to build a ghc in your homedir and just use that on both machines (you'll have to build it twice presumably)
20:39:38 <Anpheus_> That won't solve the libgmp dependency - to the other two people, are there guides on doing that efficiently?
20:39:58 <Clint> Anpheus_: schroot is pretty good
20:39:59 <lispy> Anpheus_: the source build of ghc can't use libgmp10?
20:40:03 <Anpheus_> That sounds good, using chroot or LXC or something, as I only need a backwards compatible shell
20:40:11 <Anpheus_> lispy: I don't know how to tell it to use libgmp10 :/
20:40:23 <lispy> Anpheus_: ./configure :)
20:40:32 <geekosaur> it should use whatever ghc dev libs are installed
20:40:39 <Clint> lispy: building in a different environment than your deployment isn't a good idea
20:40:40 <geekosaur> er, whatever gmp dev libs
20:41:08 <geekosaur> hm, actually, not true; ghc uses its own gmp by default
20:41:18 <geekosaur> debianoids patch it to use the system one
20:41:43 <geekosaur> so official source builds should be fine
20:42:09 <Anpheus_> Okay, I'll try building it from source rather than the generic x86_64 binary and see where that gets me
20:42:22 <lispy> hopefully to a working ghc :)
20:42:28 <Anpheus_> Hopefully!
20:49:54 <sw2wolf> Does GHC maintained by community or special team ?
20:50:05 <lispy> sw2wolf: special time plus community contributions
20:50:09 <lispy> team*
20:50:54 <sw2wolf> lispy: Why are not there ANSI standard about haskell ?
20:51:19 <lispy> sw2wolf: there is a language standard
20:51:30 <lispy> sw2wolf: http://www.haskell.org/onlinereport/haskell2010/
20:51:39 <Ralith> Enigmagic: ping
20:52:04 <sw2wolf> haskell 2010 , thanks
21:17:46 <johnw> plus, I don't see that Haskell would have much to gain by becoming an ANSI Standard
21:21:24 <Ghoul_> What's the most efficient way to "fold" list backwards onto a function other than foldl f (reverse a)
21:21:57 <Ghoul_> ie: [1..5] -> f 5 (f 4 (f 3 (f 2 (f 1 []) ) ) ) )...
21:22:44 <augur> koninkje_away: have you read Keenan and Stabler's Bare Grammar?
21:22:45 <aavogt> > foldl (flip f) [] [1,2,3,4,5]
21:22:47 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr [a0])
21:22:47 <lambdabot>    arising from a ...
21:22:56 <aavogt> > foldl (flip f) [] [1,2,3,4,5] :: Expr
21:22:57 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
21:22:57 <lambdabot>              w...
21:23:12 <Mortchek> aavogt, the flip may be the problem
21:23:26 <Mortchek> Wait no
21:23:43 <aavogt> it's the []
21:24:14 <aavogt> > foldl (flip f) x [1,2,3,4,5]
21:24:15 <lambdabot>   f 5 (f 4 (f 3 (f 2 (f 1 x))))
21:25:15 <Ghoul_> flip f
21:25:32 <Ghoul_> looks like it works though, thanks!
21:25:39 <aavogt> @type flip
21:25:40 <lambdabot> (a -> b -> c) -> b -> a -> c
21:25:47 <shachaf> It is likely but not entirely certain that you want foldl'
21:26:25 <Ghoul_> -- lecture, thanks for the help guys
21:30:24 <aavogt> how long has `flip :: Functor f => f (a -> b) -> a -> f b' been gone?
21:30:55 <shachaf> Medium long.
21:31:08 <aavogt> @type (.)
21:31:09 <shachaf> It went away with (.) = fmap etc.
21:31:09 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:31:44 <aavogt> @quote great.mono
21:31:44 <lambdabot> No quotes match. It can only be attributed to human error.
21:58:13 <mm_freak_> how do you generate the index.html for all installed packages with haddock?
21:58:41 <mm_freak_> now that i switched to cabal-dev there is no index.html anymore and that's really inconvenient
21:58:51 * hackagebot reflection 1.3 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.3 (EdwardKmett)
22:03:50 * hackagebot approximate 0.1 - Approximate discrete values and numbers  http://hackage.haskell.org/package/approximate-0.1 (EdwardKmett)
22:19:37 <lispy> mm_freak_: I don't know where you were expecting it, but look under the cabal-dev dir
22:19:58 <lispy> find cabal-dev -name "index.html" should find something
22:21:50 <AfC> I just want to cabal install edwardk.
22:24:14 <johnw> AfC: except that you have to upgrade him every few minutes
22:24:48 <tgeeky> I used to believe cabal install edwardk implied "Documentation: False" for all packages, but it's not true!
22:24:59 <johnw> haha
22:24:59 <edwardk> now its just half
22:25:11 <shachaf> The half that isn't lens?
22:25:17 <edwardk> johnw: i'm high maintenance that way
22:28:51 * hackagebot hyperloglog 0.1 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.1 (EdwardKmett)
22:43:26 <AfC> edwardk: you know, it might be cool if you put an ancillary note on {hackage pages | github READMEs} saying what use case you were solving when you wrote a library.
22:43:43 <edwardk> i've been trying to do that with AUTHORS.markdown
22:43:52 * hackagebot approximate 0.1.1 - Approximate discrete values and numbers  http://hackage.haskell.org/package/approximate-0.1.1 (EdwardKmett)
22:43:59 <AfC> edwardk: you are prolific in the extreme, but half the time I see your uploads go by and, after clicking, say "wow, that's cool, I wonder what it's for"
22:44:02 <edwardk> i'm not always successful =)
22:44:11 <edwardk> AfC: sok, so do i =)
22:44:22 <AfC> edwardk heh
22:44:34 <edwardk> hyperloglog is useful when you need to get an approximate count of how many distinct elements you've seen
22:44:46 <edwardk> it is quite alarmingly accurate for the size
22:45:07 <edwardk> for about 1.5k worth of space you can get accuracy to within 1-2% on billions of elements
22:45:28 <edwardk> and you can calculate approximate set unions, etc. with them
22:45:34 <AfC> I mean, I assume at least half of what you are doing is [for] proprietary [usage at your employer], but even so, it would be good PR to allude to how brilliant they are :)
22:45:35 <edwardk> so they are quite flexible
22:45:46 <Anpheus_> So, an update on my trying to build ghc-7.6.3 on Ubuntu 13.04 / 12.04.2 from sources
22:45:58 <edwardk> this one is mostly for me actually =)
22:46:14 <elliott> i think at least 100% of what edwardk is doing is because he's too bored to not do the things he does
22:46:20 <Anpheus_> I am still hitting issues with libgmp.so.3 missing, and since it is absent on 13.04 I am not sure how to proceed. As well, I can't seem to figure out how to get the source distribution to ./configure correctly.
22:46:31 <edwardk> elliott: =P
22:46:56 <AfC> elliott: [old school, that's traditionally why so many with-it sysadmins do open source; they're bored out of their minds]
22:47:41 <edwardk> AfC: thats how i found the demo scene and started in on 3d graphics. i was running an ISP. ;)
22:47:54 <lispy> anyone know how to use this package to render the quoted program back to a string? http://hackage.haskell.org/package/language-c-quote
22:48:01 <lispy> I tried show but that shows it as a haskell type
22:48:11 <Enigmagic> Ralith: hi
22:49:03 <lispy> am I supposed show the result of pprLoc?
22:49:23 <lispy> I can't find any documentation for language-c-quote :(
22:49:37 <Ralith> Enigmagic: are you expecting to get to the high level bindings soon? It'd be nice to have a first pass of merges in for the next releas
22:49:40 <Ralith> e
22:49:58 <Enigmagic> Ralith: i'll have time later in the week
22:50:30 <Ralith> you sure?
22:50:39 <Ralith> I recall you were hoping to have time this past weekend
22:50:48 <mm_freak_> lispy: the /share/doc directory is there as expected, but the index.html is not there, and according to cabal-dev-install's output it isn't generated
22:51:04 <Enigmagic> yeah, i'm pretty sure.
22:51:20 <lispy> mm_freak_: hmm...Time to file a bug report :)
22:51:26 <Ralith> kk, great
22:51:30 <Ralith> I'll hold off then
22:51:50 <Ralith> maybe cram some more features in the low level
22:53:06 <Enigmagic> are you merging your ST stuff in?
22:55:12 <Ralith> I'm not sure if it makes sense to stuff it in the same repository
22:55:40 <Ralith> I certainly wouldn't mind it being convenient to hack on, though
22:55:58 <Ralith> any thoughts?
22:57:13 * lispy gets it working
22:57:25 <lispy> (the language-c-quote + opencl thing that is)
22:57:35 <lispy> On windows even
22:57:49 <Ralith> it's certainly true that changes to the ST stuff are frequently made in concert with lower level extensions
23:02:00 <Enigmagic> Ralith: it seems like the sort of thing a lot of people actually want..
23:02:32 <Ralith> Enigmagic: oh, certainly, but it'll be on hackage one way or another
23:02:57 <Enigmagic> i'd say to merge it into the main git repo but that's just me.
23:03:02 <Ralith> I do like having one commit for adding a given feature across all the binding layers
23:03:27 <Ralith> I think I'll probably do that; I don't see it hurting, and it might help
23:03:47 <Enigmagic> i think it would help, for sure
23:03:53 <Ralith> reduces its chances of bitrotting at the very least
23:04:18 <Enigmagic> yeah and most people using llvm would benefit from that more than the super high level bindings
23:04:33 <Enigmagic> though i'd like them to work together...
23:05:04 <Ralith> Enigmagic: one of the biggest standing maintenance issues is integrating the work I've done with the high level bindings
23:05:07 <Ralith> there's a lot of duplicated glue code
23:05:26 <Ralith> and definitely places where things could be slightly adjusted for a great deal more sharing
23:06:09 <Enigmagic> that's what i was thinking from my initial scan through it
23:06:15 <Ralith> so yeah, I agree; I've just felt that trying to do that myself, especially on the first pass, would bog me down and delay getting the compiler that's motivating all this work functional
23:07:45 <Enigmagic> that's something i can do
23:08:17 <Enigmagic> if you can get your bindings merged in ;-)
23:18:26 <Ralith> Enigmagic: there's an argument for it if ever there was one ^^
23:37:16 <fruitFly> Why does (a -> a) have to be in parens?
23:37:16 <fruitFly> applyTwice :: (a -> a) -> a -> a   applyTwice f x = f (f x)
23:38:01 <lambdadelta> fruitFly: Because -> is right associative.
23:38:51 <fruitFly> lambdadelta: wouldn't tht mean parens is not necessary? I'm pulling the example from here: http://learnyouahaskell.com/higher-order-functions#higher-orderism
23:39:01 <tgeeky> @pl f x = f (f x)
23:39:01 <lambdabot> f = fix (join (.))
23:39:44 <tgeeky> @djinn a -> a -> a -> a
23:39:44 <lambdabot> f _ _ a = a
23:39:45 <supki> fruitFly: right associative means that without parens applyTwice would be :: a -> (a -> (a -> a))
23:39:51 <tgeeky> @djinn (a -> a) -> a -> a
23:39:51 <lambdabot> f a = a
23:41:25 <fruitFly> supki: ok, i'm gonna think about the eg some more
23:42:00 <lambdadelta> fruitFly: Think about pretty much any other right-associative operator in mathematics - e.g., the exponentiation operator.
23:42:40 <lambdadelta> fruitFly: a ^ b ^ c ^ d ^ ... means a ^ (b ^ (c ^ (d ^ ...)))
23:43:23 <fruitFly> lambdadelta: alright
23:50:12 <fruitFly> applyTwice :: (a -> a) -> a -> a   applyTwice f x = f (f x) ... so (a->a) is in parens because it's taking a function? like (+ 3) or (subtract 3) and if it wasn't in parens how would it get confused? what would happen?
23:50:20 <fruitFly> sti\\\\\\*still thinking*
23:50:30 <fruitFly> *still* thinking*
23:50:47 <fruitFly> lambdadelta: supki ^^^
23:53:09 <lambdadelta> fruitFly: Perhaps you should read about currying.
23:53:26 <h4199> @ty \f x -> f (f x)
23:53:27 <lambdabot> (t -> t) -> t -> t
23:53:35 <fruitFly> lambdadelta: I just did, still thinking about everything
23:53:35 <h4199> Haskell isn't confused
23:54:24 <h4199> It would only be wondering why you gave it conflicting information
23:54:29 <fruitFly> so does (a->a) just mean it takes a function?
23:54:45 <h4199> yes, in this case, f
23:54:53 <lambdadelta> fruitFly: Not just that.
23:55:12 <fruitFly> the example is here: http://learnyouahaskell.com/higher-order-functions#higher-orderism
23:55:15 <lambdadelta> fruitFly: It cannot take *any* function.
23:55:25 <fruitFly> lambdadelta: ok
23:55:26 <lambdadelta> fruitFly: The input and output types have to be the same.
23:55:34 <fruitFly> lambdadelta: right got that
23:55:35 <h4199> ^^
23:56:19 <fruitFly> so if it was a->a->a->a and you gave it a function it would be like wtf right?
23:56:51 <fruitFly> dn't have haskell on this machine but i'm gonna try it on codepad
23:57:06 <fruitFly> i dn't know these lambda bot commands yet
23:57:41 <lambdadelta> fruitFly: If the function's type is "a -> a -> a -> a", then "a" may as well be a function type.
23:58:54 <lambdadelta> @djinn a -> a -> a -> a
23:58:55 <lambdabot> f _ _ a = a
23:59:17 <lambdadelta> @djinn (a -> b) -> (a -> b) -> (a -> b) -> (a -> b)
23:59:17 <lambdabot> f _ _ a b = a b
