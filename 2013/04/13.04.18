00:00:01 <shachaf> sw2wolf: ?
00:00:14 <Ghoul_> Heh, it doesn't link - just for my one file
00:00:22 <Ghoul_> if I try any of the other files it links perfectly
00:00:36 <sw2wolf> shachaf: Nothing, Just curious
00:01:23 <napping> did you change the file or module name?
00:02:13 <Ghoul_> Oh actually, I just realized why people don't have main inside their project modules
00:02:15 <Ghoul_> <_<
00:13:21 <beaky> @src Data.Tuple.Tuple
00:13:22 <lambdabot> Source not found. There are some things that I just don't know.
00:13:24 <beaky> :(
00:13:28 <shachaf> :(
00:13:28 <beaky> does haskell have tules?
00:13:31 <beaky> tuples*
00:13:42 <no-n[1]> yes
00:14:11 <beaky> is there something like mconcat for tuples?
00:14:15 <beaky> I mean, mappend*
00:14:18 <no-n[1]> but the tuple isn't a type, each type of tuple is? like the empty tuple is of type (), (5, "hello") is of type (Int, String) and so on
00:14:34 <no-n[1]> (unless 5  is an Integer or some other numeric type of course)
00:14:42 <Kaidelong> @instances-importing Monoid
00:14:44 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
00:15:02 <Kaidelong> apparently (a, b) and (a, b, c)
00:15:02 <no-n[1]> beaky, I don't know what that does. it sounds like something you would probably do with lists.
00:15:05 <beaky> ah :(
00:15:11 <no-n[1]> but I'm a newb
00:15:13 <Kaidelong> although those are probably with constraints
00:15:14 <no-n[1]> so don't listen to me :P
00:15:16 <beaky> I want to do something like the natural join in relational algebra
00:15:22 <beaky> for tuples
00:15:32 <Kaidelong> @ty mappend (undefined, undefined)
00:15:34 <lambdabot> (Monoid t, Monoid t1) => (t, t1) -> (t, t1)
00:15:38 <Kaidelong> ahah
00:15:38 <beaky> < (1, 2, 3) `mappend` ('a', 'b', 'c')
00:15:45 <beaky> > (1, 2, 3) `mappend` ('a', 'b', 'c')
00:15:47 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
00:15:48 <lambdabot>    arising from the literal `1...
00:15:50 <beaky> :(
00:15:57 <shachaf> :(
00:16:13 <beaky> maybe the type itself needs to be a monoid
00:16:18 <Kaidelong> it does!
00:16:26 <Kaidelong> all that mappend does is go
00:16:45 <beaky> > (1, 2, 3) `mappend` (4, 5, 6)
00:16:47 <lambdabot>   Ambiguous type variable `t0' in the constraints:
00:16:47 <lambdabot>    (GHC.Num.Num t0)
00:16:47 <lambdabot>      a...
00:16:53 <zebr> hey all. i'm working on some maths, and i have a set comprehension that looks to me like it should have a cleaner version perhaps using a monadic definition. it goes, {(x,y,z) | x <- xs, y <- ys, z <- zs}. any idea how best to define that?
00:16:57 <Kaidelong> (x,y) `mappend` (x',y') = (x `mappend x', y `mappend` y')
00:17:02 <tzh> beaky: do you want something like zip?
00:17:07 <beaky> :t zip
00:17:08 <tzh> > zip [1,2,3] "abc"
00:17:09 <lambdabot> [a] -> [b] -> [(a, b)]
00:17:10 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
00:17:19 <beaky> ah no just tuple extension
00:17:37 <Kaidelong> oh you want to use tuples like lists ala prolog?
00:17:43 <beaky> yep
00:17:53 <Kaidelong> umm
00:17:56 <Kaidelong> use lists
00:17:59 <Kaidelong> instead
00:18:28 <shachaf> zebr: You should give a bit more context.
00:18:36 <beaky> lists cannot be heterognous like tuples are
00:18:39 <tzh> so like (a, b) -> c -> (a, b, c) but with any length of n-ple?
00:18:45 <beaky> tzh: yep
00:18:57 <Kaidelong> no, which is why they can be extended
00:19:04 <beaky> @djinn (a, b) -> (c, d) -> (a, b, c, d)
00:19:05 <lambdabot> f (a, b) (c, d) = (a, b, c, d)
00:19:08 <wollw> define a type for your list elements maybe?
00:19:16 <shachaf> zebr: Is the trouble that a list comprehension doesn't work here because you're dealing with sets?
00:20:33 <tzh> there are the (,) (,,) (,,,) functions for a specific number but i don't know off the top of my head how you'd write a general-case function for tuples of up to infinite length; afaik haskell is bad at that because each tuple length is a distinct type
00:20:49 <tzh> maybe the more important question is why do you want to do this
00:21:11 <shachaf> Haskell is also bad at dividing by zero.
00:21:23 <beaky> I want something like c++'s tuple concatenation
00:21:42 <beaky> but that gives me an idea... in LISP all those big tuples are just pairs
00:22:00 <beaky> so the element on the right is just a deeply nested pair, then I think it can be done in haskell :D
00:22:29 <zebr> shachaf: the problem is that the actual example looks like this, http://i.imgur.com/XaX4AWV.png - and it's rather ugly.
00:22:46 <zebr> shachaf: so i'm hoping there's a nicer way to write it, basically >.>
00:23:23 <shachaf> I don't know what that notation means, so you'll have to decipher it for your question. :-)
00:23:48 <beaky> @djinn (a, b) -> c -> (a, (b, c))
00:23:49 <lambdabot> f (a, b) c = (a, (b, c))
00:24:03 <beaky> yeah that works
00:24:51 <beaky> let <--> = (,) in (1, 2) <--> ('a', 'b')
00:24:56 <beaky> > let <--> = (,) in (1, 2) <--> ('a', 'b')
00:24:57 <lambdabot>   <hint>:1:5: parse error on input `<-->'
00:25:00 <beaky> :(
00:25:14 <Kaidelong> > let (<-->) = (,) in (1, 2) <--> ('a', 'b')
00:25:16 <lambdabot>   ((1,2),('a','b'))
00:25:18 <beaky> :D
00:25:30 <shachaf> :D
00:25:32 <beaky> if only there was a way to flatten a tuple
00:25:59 <beaky> :t curry
00:26:00 <lambdabot> ((a, b) -> c) -> a -> b -> c
00:26:57 <Kaidelong> the problem with flattening a tuple is you'd need a flatten3, flatten4, flatten5, etc
00:27:02 <beaky> right
00:27:05 <Kaidelong> with a different type for each
00:27:13 <Kaidelong> however, mmm
00:27:14 <beaky> tuples are awful to work with :(
00:27:29 <arkeet> clearly (a,b,c) should be a synonym for (a,(b,c))
00:27:36 <zebr> shachaf: essentially it says "the relation <->1;->r;<->2 where <->1 is any member of S1(t), ->R is any member of R(C(t)), <->2 is any member of S2(t)." so it's kind of a set of tuples of all possible combinations of the elements of the three sets. if that makes sense.
00:27:51 <zebr> *triples
00:27:55 <arkeet> or should it be ((a,b),c)??
00:28:04 <arkeet> :)
00:28:30 <Kaidelong> anyway beaky tuples are awful to work with and you're not really supposed to
00:28:44 <Kaidelong> for better or worse tuples are not as useful in haskell as they are in some other places
00:29:47 <beaky> right
00:29:55 <beaky> I should make an ADT
00:29:55 <quchen> That's like saying Either is awful to work with because you can't store two values at the same time in it.
00:30:09 <beaky> because ADTs are monoids
00:30:10 <quchen> Tuples aren't the structure you need. Stop using them for your problem.
00:30:17 <tzh> due to the way haskell is written it's just not that useful to have hetrogenous lists (= tuples you can concat) in the same way you can use them in other languages
00:30:18 <Kaidelong> quchen: Either would also make an awful structure for a collection
00:30:21 <Kaidelong> so yes
00:30:25 <Kaidelong> I suppose it is like saying that
00:30:38 <tzh> or at least that's my understanding from coding at an amateur level in haskell for a few months :V
00:30:50 <beaky> but sometimes data has to be a product of different types, and I think tuples are the way to go :(
00:30:51 <Kaidelong> there are some places where tuples really do see use as collections though
00:31:19 <beaky> e.g. a student has an id, a name, a dob, a date of enrollment, and ...
00:31:34 <beaky> and maybe I can do a join on the ID
00:31:34 <Kaidelong> a tuple is exactly a product type, but in haskell all the type information of a product type has to be preserved. You could try using records, which are similarly ugly
00:31:35 <tzh> beaky: so like, fields & field notation?
00:31:39 <beaky> yes
00:31:46 <Kaidelong> there are also some libraries specifically for this sort of thing
00:31:48 <Kaidelong> like accessor
00:32:20 <zebr> shachaf: thinking about it, i think my thing is basically the cartesian product, except i actually yield a relation instead of a tuple. not sure how to do that, though.
00:33:35 <shachaf> Well, it's up to you how to model a relation. :-)
00:33:46 <tzh> beaky: yeah, record syntax for types of multiple data points: data ab { a :: String, b :: Int }
00:34:11 <tzh> and then `a` is `ab -> String` and `b` is `ab -> Int`
00:35:01 <zebr> shachaf: this is what happens when a lowly programmer tries to write a paper involving relational algebra. >.>
00:36:17 <tzh> er *`data Ab = Ab {a :: String, b :: Int}`; same thing
00:36:34 <shachaf> zebr: Oh, is your question about Haskell or about writing a paper?
00:37:59 <zebr> shachaf: well, it's about maths as opposed to haskell; the problem just looked very like something haskell would have a short form for.
00:38:37 <shachaf> OK. It seemed like you were asking about translating this paper to Haskell or something like that.
00:39:19 <zebr> shachaf: ahh, sorry about that. i'm rather tired so i might be making little sense.
00:44:40 <killy9999> I'm building and installing the primitive library, but for some reason I only get .a file and no .so file
00:44:46 <killy9999> does anyone have idea why?
00:45:01 <shachaf> Did you pass the option for dynamic linking to whatever it is you pass options to?
00:45:19 <killy9999> no
00:45:39 <killy9999> were there any changes that require this to be passed explicitly?
00:45:51 <killy9999> I'm using a method of building that *used* to work
00:46:09 <shachaf> Oh. That's a good thing to mention when you ask a question like that.
00:46:24 <shachaf> Other good things to mention are what's different between then and now.
00:48:39 <icarot> I understand why a function like getchar()  in C is impure, but I can't wrap my hand around why writing to stdout could be impure.
00:48:47 <killy9999> shachaf: you were right, I needed --enable-shared option
00:49:26 <killy9999> BTW. "now" is GHC HEAD from today, "then" is GHC HEAD from about 5 or 6 weeks ago
00:49:30 <icarot> I feel as though I could call printf()  one thousand times and each times the result would be identical, if the data was immutable.
00:50:21 <icarot> Does anyone care to enlighten me? The only things I've found have been tenuous arguments over the definition of referential transparency; leading me nowhere.
00:50:52 <shachaf> Maybe "pure" is the wrong thing to worry about. I'm not entirely sure what "pure" means, really.
00:51:16 <shachaf> Rather, you can worry about what some function/value means.
00:52:15 <icarot> I don't really care about it too highly. I've just been a bit interested. Looking at the differences between imperative and functional style with asynchrony (callbacks vs promises) in nodejs got me thinking.
00:52:32 <jesyspa> icarot: As far as I understand: print 5 `seq` print 5 `seq` () != let x = print 5 in x `seq` x `seq` ()
00:52:44 <shachaf> jesyspa: You understand incorrectly.
00:52:45 <tzh> icarot: maybe one answer would be since you want those printf calls to be output in a certain order you need to know when to run them, which makes them not purely functional?
00:53:00 <jesyspa> shachaf: Ooh, please explain then. :D
00:53:07 <shachaf> jesyspa: Try it out in ghci!
00:53:32 <shachaf> jesyspa: You're mixing up running a program with, uh, looking at a program.
00:53:54 <jesyspa> shachaf: Oh, I know that's not the way it works in Haskell, seeing as Haskell forces referential transparency.
00:54:08 <shachaf> Wait, that wasn't Haskell code?
00:54:32 <shachaf> I see what you mean now. You're talking about a hypothetical unsafeIO "print".
00:54:47 <jesyspa> Yeah, and I guess I should have done !x ?
00:55:29 <killy9999> icarot: I'd say that although the function printf always "does" the same thing, you cannot tell from its type (in C) that it does something like printing to the screen
00:55:41 <shachaf> printf is not a function. :-)
00:56:33 <shachaf> Well, C printf. Well, it's a C function -- but maybe we should try to mean something by the word "function" here.
00:57:19 <shachaf> icarot: By the way, the way Haskell does I/O is very similar to callbacks in node.js and all that.
00:57:24 <shachaf> And to promises.
00:57:39 <killy9999> shachaf: procedure, not a function perhaps?
00:57:48 <shachaf> killy9999: Sure.
00:57:56 <icarot> I just took (a function) to be a set of expressions that generate a process.
00:58:15 <jesyspa> Hm, isn't a function just one expression?
00:58:21 <shachaf> I'm not sure what that means.
00:58:47 <_mr> shachaf: what's a function for you? ;-)
00:58:59 <beaky> printf isn a function String -> (a...) -> IO Int
00:59:15 <beaky> (btw how do you convey variadics in Haskell?)
00:59:16 <shachaf> How about starting from https://en.wikipedia.org/wiki/Function_(mathematics) ?
00:59:26 <icarot> Shachaf: by that, do you mean that nodejs callbacks are like sequenced procedures (side effecting) which Haskell simply uses Monads to handle? I've never actually written a line of Haskell, btw.
00:59:35 <jesyspa> shachaf: is unsafePerformIO a function? :P
00:59:47 <shachaf> jesyspa: No.
01:00:11 <shachaf> Alternatively, yes, because its type is a function type. Take your pick.
01:00:20 <shachaf> Alternatively, unsafePerformIO isn't anything -- it's meaningless.
01:00:22 * jesyspa takes the middle ground.
01:00:27 <beaky> unsafePerformIO is an abomination :D
01:00:43 <icarot> I remember reading that in Haskell, the type of side effects is orthogonal to the type of a function.
01:00:51 <shachaf> icarot: Some of these things might be easier to explain if you know some Haskell. :-)
01:00:55 <icarot> But I should shut up because I don't know what I'm talking about.
01:00:55 <shachaf> Hmm, I'm not sure what that means.
01:01:16 <shachaf> icarot: We can make an analogy to promise-like things in JavaScript.
01:02:15 <shachaf> I could try and explain how Haskell-style I/O works in JavaScripty terms in #haskell-overflow if you like.
01:02:31 <icarot> Sounds tempting.
01:02:51 <icarot> I'm there
01:11:58 <killy9999> So I'm using --enable-shared option when building library with Cabal-1.17.0
01:12:05 <killy9999> and everything is built twice
01:12:14 <killy9999> can I avoid that somehow?
01:14:34 <elliott> not really
01:17:52 <killy9999> :/
01:19:36 <Ghoul_> Is there a way to easily change the "user error" part of fail ?
01:27:30 <rohitkav> I am unable to install haskell webframeworks: yesod as well as snap
01:27:44 <rohitkav> on my ubuntu 12.10 machine
01:28:54 <luite> rohitkav: what errors do you see, can you paste them on hpaste.org?
01:31:01 <rohitkav> it's very huge list which I couldn't copy too, some parts are missing as well
01:31:12 <rohitkav> this was the path in .bashrc http://hpaste.org/86065
01:31:14 <rohitkav> luite,
01:32:02 <rohitkav> even when i try cabal install from url I get "error during cabal-install bootstrap, installing the cabal-install package failed
01:32:55 <luite> rohitkav: the last line in that paste looks incorrect, doesn't add $HOME/.cabal/bin to your path
01:34:17 <luite> rohitkav: and i'm not sure using .bashrc does the right thing, it says it's for non-login shells. i've added my $PATH customization to ~/.profile
01:35:30 <luite> rohitkav: have you installed with sudo before?
01:38:55 <notdan> @hoogle Arrow a => [a b c] -> a b c
01:38:55 <lambdabot> Data.Map unions :: Ord k => [Map k a] -> Map k a
01:38:56 <lambdabot> Data.Graph.Inductive.Internal.Heap mergeAll :: Ord a => [Heap a b] -> Heap a b
01:38:56 <lambdabot> Data.Graph.Inductive.Basic grev :: DynGraph gr => gr a b -> gr a b
01:39:03 <notdan> @hoogle Arrow a => [a b c] -> a b [c]
01:39:04 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
01:39:06 <notdan> hm
01:39:25 <notdan> I am looking for something like &&& but which could split the input onto multiple arrows
01:39:29 <notdan> not just two
01:41:21 <shachaf> If your type is Applicative you can use sequenceA! :-)
01:42:05 * hackagebot lgtk 0.4 - lens-based API for Gtk  http://hackage.haskell.org/package/lgtk-0.4 (PeterDivianszky)
01:44:43 <notdan> shachaf: hm, unfortunately, I am not sure of the connective between Arrow and Applicative :(
01:45:01 <shachaf> What are you using Arrow for?
01:49:19 <quchen> shachaf: The other day you said "GHC arrow notation considered harmful". What did you mean with that?
01:49:30 <quchen> The -< syntax?
01:52:05 * hackagebot binary-file 0.15.11 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.15.11 (YoshikuniJujo)
02:05:26 <notdan> shachaf: HXT
02:05:47 <notdan> shachaf: hm, and why do you yhink that arrow notation is harmful?
02:06:12 <notdan> I am not a big fan of arrow notation, but sometimes it's better than a whole lot of &&& and first/second
02:07:06 <shachaf> quchen: Yes, I mean the -< and related syntax.
02:07:22 <shachaf> notdan: Well, part of it is that Arrow is harmful. :-)
02:08:29 <quchen> shachaf: And why is that?
02:08:39 <shachaf> Let us not go into it.
02:08:45 <notdan> shachaf: well, I mean that is certainly a very particular opinion
02:09:01 <quchen> shachaf: Could you at least point me in the right direction then?
02:09:03 <shachaf> It's a very general opinion!
02:09:13 <shachaf> quchen: The right direction is away from Arrow.
02:09:23 <shachaf> And fortunately every arrow points away from itself.
02:09:36 <shachaf> →
02:09:53 <notdan> I haven't heard from anyone but you that Arrows are harmful, tbqh
02:10:05 <quchen> Same here.
02:10:11 <shachaf> OK.
02:10:35 <quchen> I mean it's sometimes hard to read and instances can be arbitrarily complicated, but that's not something exclusive to arrows.
02:11:39 <startling> shachaf, on the contrary, ↻
02:12:11 <shachaf> startling: You have bested me.
02:12:38 <startling> I'd like to thank my parents, and the unicode consortium.
02:12:54 <shachaf> ⇶
02:13:20 <startling> ↴
02:13:20 <beaky> I just see [?] :(
02:13:21 <startling> ↵
02:13:47 <quchen> And they told me there was no set that contained everything!
02:13:58 <Ghoul_> Are the haskell messenger bags ever going to come back into stock>
02:14:48 <startling> beaky, ☹
02:15:05 <shachaf> :☹(
02:15:06 <quchen> Searching Google a bit leaves me with "arrows are bad for the reason shachaf doesn't like them". :-/
02:15:19 <startling> quchen, ⚞☆⚟
02:15:35 <quchen> My font doesn't support that one.
02:15:47 <Ghoul_> So, does Microsoft own Haskell
02:15:54 <notdan> quchen: albeit, it's hard to find stuff about arrows, at least for me
02:16:06 <notdan> quchen: i try adding keywords like haskell, typeclasses
02:16:07 <Ghoul_> or do they outsource parts of Microsoft Research to work on open source haskell just because they can
02:16:08 <notdan> but it doesnt help
02:16:09 <quchen> notdan: That's certainly true.
02:16:17 <startling> anyway, I don't like arrows because they don't seem very useful.
02:17:07 <startling> like, it's cool that you can compose things this way, but it seems like the only Arrow that's anywhere near common is (->)
02:17:26 <merijn> Don't forget Kleisli :p
02:17:37 <startling> and parsing seems to be done better with Applicative and Monad.
02:17:46 <merijn> or rather, the "Kleisli m" arrow
02:17:50 <startling> merijn, I can't forget something I never knew in the first place.
02:18:13 <Chousuke> FRP libraries seem to like arrows
02:18:14 <merijn> startling: Kleisli m a b = a -> m b
02:18:15 <quchen> startling: That doesn't make arrows bad.
02:18:31 <quchen> They're just an abstraction not currently used very much then.
02:18:44 <merijn> Which means you can use "Kleisli IO" as an arrow
02:18:49 <notdan> startling: well, I haven't used an applicative XML parser
02:18:54 <notdan> but HXT is quite nice
02:18:59 <notdan> I seem to like its design
02:18:59 <startling> quchen, it makes it bad that a) there's a typeclass, and b) it's in base
02:19:30 <startling> merijn: oh, ugh, that doesn't seem useful at all.
02:20:01 <startling> why not just use >=> ? :(
02:20:14 <merijn> startling: It is, because that makes the arrow combinators available for monadic functions
02:20:34 <merijn> :t putStrLn *** putStrLn
02:20:36 <lambdabot> (String, String) -> (IO (), IO ())
02:20:53 <merijn> :t putStrLn *** putStrLn :: (String, String) -> IO ((), ())
02:20:55 <lambdabot>     Couldn't match expected type `IO ((), ())'
02:20:55 <lambdabot>                 with actual type `(c0, c'0)'
02:20:55 <lambdabot>     Expected type: (String, String) -> IO ((), ())
02:20:58 <merijn> bah
02:21:08 <shachaf> @ty Kleisli putStrLn *** Kleisli putStrLn
02:21:10 <lambdabot> Kleisli IO (String, String) ((), ())
02:21:12 <merijn> oh, I guess that needs wrapping into Kleisli, duh
02:21:16 <shachaf> @yarrrr
02:21:16 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
02:21:31 <adimit> I found it hard to google for this: are there any examples of dsls that introduce their own type system? I need an oo-like subtyping/inheritance based type system for a DSL, and I haven't really found a 'best' way to do it, such that type checking would be part of the compilation process (not the interpretation process.) My fear is that I'll have to resort to using TH.
02:21:37 <Chousuke> merijn: that looks like something you'd do with lenses nowadays
02:21:57 <supki> @ty both putStrLn
02:21:59 <lambdabot> (String, String) -> IO ((), ())
02:22:11 <startling> adimit, write an AST for what you want with strong type guarantees
02:22:28 <startling> merijn, I see, but I'm not convinced.
02:22:40 <notdan> supki has a hilight alert set for the word 'lens'
02:23:16 <startling> though wow, what the hell is ArrowLoop
02:23:26 <notdan> OK, got to go
02:23:35 <notdan> still not convinced that Arrows are bad :P
02:23:50 <shachaf> My goal was not to convince anyone.
02:23:56 <quchen> We noticed.
02:24:07 <shachaf> preflex: seen conal
02:24:07 <startling> > loop (\(a, b) -> ('a', b + 1))
02:24:07 <preflex>  conal was last seen on #haskell 16 days, 5 hours, 52 minutes and 11 seconds ago, saying: :)
02:24:09 <lambdabot>   *Exception: show: No overloading for function
02:24:22 <startling> > loop (\(a, b) -> (
02:24:23 <lambdabot>   <hint>:1:19: parse error (possibly incorrect indentation)
02:24:24 <shachaf> startling: It is lie MonadFix.
02:24:25 <startling> ugh
02:24:26 <shachaf> k
02:24:51 <startling> > loop (\(a, b) -> ('b', b + 1)) $ 'b'
02:24:52 <adimit> startling: I'm a bit confused, though. Do you mean, I'd parameterize the AST types, so that the AST couldn't be built except when the typing checks out? I'm not sure how I'd go about doing that…
02:24:53 <lambdabot>   'b'
02:25:04 <startling> adimit: that's what I mean, yeah.
02:25:43 <startling> adimit: the other dumb trick is to write functions that are unnecessarily type-restricted
02:26:16 <merijn> adimit: DataKinds and GADTs \o/
02:26:16 <startling> :t const :: (b -> b) -> [b] -> [b]
02:26:17 <lambdabot>     Couldn't match expected type `[b]' with actual type `b -> b'
02:26:18 <lambdabot>     Expected type: (b -> b) -> [b] -> [b]
02:26:18 <lambdabot>       Actual type: (b -> b) -> [b] -> b -> b
02:26:35 <merijn> Also, possibly TypeFamilies
02:27:00 <startling> oh yeah, those can help too.
02:27:00 <adimit> startling: I think I like the AST idea more, though I don't understand how I could let the user specify their own type system (i.e. type signatures) and get an AST like that from the DSL code (i.e. the type system is custom.)
02:27:35 <startling> adimit: the type *system* isn't custom, the types are custom, right?
02:27:35 <merijn> adimit: Here's a nice GADT intro that might help: https://en.wikibooks.org/wiki/Haskell/GADT
02:27:51 <adimit> startling: yes. they can specify a type hierarchy on a per-program basis.
02:28:11 <startling> sure.
02:28:31 <adimit> merijn: gadts, type families and data kinds have been on my reading list these past days. I think I'm just lacking the vision to put it all together :-|
02:29:29 <startling> adimit: anyway, in general, this is a hard problem. this is what dependently-typed languages are trying to fix. Things like DataKinds and GADTs give some of that power to haskell, but there's still quite a bit you can do without it.
02:29:42 <sopvop> type families are pretty cool. Especially for annotating ASTs
02:29:58 <merijn> adimit: Well, DataKinds and TypeFamilies don't really start to make sense until you grok GADTs a bit. OTOH GADTs are pretty easy to grok, imo
02:30:23 <merijn> That link I just gave gives a pretty simple intro based on an AST example
02:31:21 <adimit> yes, I've been using GADTs for a while now. It can come in pretty handy — though I don't exactly understand why GADTs and type families are both a thing, i.e. they seem to cover a lot of the same ground. I think the latter a just more extensible?
02:32:24 <merijn> adimit: Why do you think they cover the same ground? They seem completely orthogonal to me...
02:32:25 <adimit> *are
02:33:45 <adimit> merijn: I guess that's quite a tangent, but basically, you can use both to specialize the construction of parametric types, no? I.e. here's one for when I instantiate my parameter with, say 'Int', here's one for (), etc.
02:33:58 <adimit> maybe I'm just not understanding it yet.
02:34:36 <merijn> GADTs let you write datatypes who's return type are unrelated to the other types, example "data Foo a where Bar :: Char -> Foo Int"
02:35:10 <adimit> ah.
02:35:35 <merijn> TypeFamilies let you write type level functions, like "type family Foo a b; type instance Foo Int Char = Bool" at which point "f :: Foo Int Char -> Int" is typechecked as being "f :: Bool -> Int"
02:36:43 <merijn> adimit: They place togehter very nice in the sense that your GADTs can carry all sorts of phantom types (i.e. types not present in the value) and then you can use TypeFamilies' type functions to compute what the type of your actual function should be.
02:37:09 <adimit> merijn: that sounds pretty powerful!
02:38:06 <merijn> adimit: One example, I had a GADT that encoded a heterogeneous list of values and wanted to write a function that takes such a list and an FFI function and then kept applying argument from the heterogenous list to the FFI function until I got an "IO ()" back
02:38:15 <adimit> I think here's where I went wrong: I wanted the type signature declarations to be part of the 'language', i.e. parsable in an expression. But I think I'll just have to use Haskell Syntax to let the user define their types, or maybe TH to expand a definition in the language's own type signature syntax to Haskell's type declaration syntax.
02:39:09 <adimit> (so the type signature declarations would've been part of the AST, just like when writing a non-embedded compiler/interpreter. I don't think that can be done embeddedly, can it?)
02:40:05 <merijn> I dunno, tbh
02:40:07 <adimit> merijn: heterogenous lists were introduced with 7.4, no? with the DataKinds extension, IIRC. I read the paper a while ago.
02:40:51 <merijn> Well, my list was just "data HList :: [*] -> * where Nil :: HList '[]; Cons :: a -> HList as -> HList (a ': as)"
02:41:13 <merijn> i.e. HList is a type constructor that takes a list of types as arguments and returns a type
02:41:35 <merijn> Nil is the constrctor with an empty list of types and Cons just adds types to the front of the list
02:41:44 <adimit> merijn: yes, I think that's how it was described in the paper. Lemme see.
02:42:01 <merijn> DataKinds is a bit buggy in 7.4, better to use 7.6 if you want to use it
02:42:49 <varun1> Hi
02:42:55 <varun1> When using emacs and ghc-mod
02:43:08 <varun1> how do I get emacs to give me the type of a function
02:43:39 <adimit> Yorgey et al. 2011. Ah, it was byorgey's work :-) (among others.) here's a link: http://dl.acm.org/citation.cfm?id=2103795
02:43:50 <shachaf> Brent Byorgey
02:44:32 <adimit> Half of that paper went over my head, but the parts I did understand were pretty cool.
02:44:40 <adimit> Maybe I should re-read it. I think I'd understand more today.
02:48:00 <Peaker> I think an HList is more like a tuple than like a list
02:48:16 <Peaker> Maybe more of a first-class tuple than a hetero list
02:49:22 <adimit> well, where's the difference between an n-tuple and an n-sequence?
02:51:45 <Peaker> the type-per-element and random access, mostly
02:54:06 <adimit> yes — but except with reflection, not completely typed out lists don't make a lot of sense, or do they? genuine question, I couldn't really imagine accessing list elements without explicit type encoding. I can see where the drawback of explicit type encoding is, of course…
02:57:03 <Peaker> reflection?
02:57:47 <beaky> who am I?
02:59:12 <adimit> code being able to say: i have a "thing" what type is it, and let's go have a switch statement to execute different code depending on its type — at runtime. Like java. I'm not saying it's a good thing.
02:59:19 <adimit> but it *can* be useful.
02:59:34 <mauke> > typeOf cake
02:59:37 <lambdabot>   [[Char]]
02:59:59 <shachaf> But there are other ways to work with HLists.
03:00:11 <shachaf> elliott has done a bit of it, I remember.
03:01:06 <adimit> yes, exactly what mauke did :-)
03:01:15 <adimit> shachaf: that's interesting!
03:01:22 <mauke> > pieceOf cake
03:01:24 <lambdabot>   Not in scope: `pieceOf'
03:02:13 <adimit> > cake
03:02:15 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
03:02:35 <adimit> … ok. no questions, lambdabot
03:03:18 <beaky> > cake >>= (,)
03:03:20 <lambdabot>   Couldn't match expected type `[b0]'
03:03:20 <lambdabot>              with actual type `b1 -> ([...
03:03:26 <beaky> :(
03:03:49 <mauke> what did you expect?
03:04:12 <beaky> I expected the list would become a tuple
03:04:26 <beaky> or a conspair list like in lisp
03:04:43 <mauke> what's a conspair list?
03:05:04 <beaky> it's like (a, (b, (c, (d, e))))
03:05:11 <beaky> hmm that gives me an idea
03:05:12 <mauke> you get an error because >>= is concatMap and (,) combines 2 values into a pair
03:05:25 <mauke> the function passed to concatMap needs to return a list
03:05:29 <beaky> > foldr (,) () [1..10]
03:05:31 <lambdabot>   Couldn't match type `(GHC.Integer.Type.Integer, ())' with `()'
03:05:44 <mauke> not bad but that's a type error
03:05:46 <beaky> > foldr (,) 0 [1..10]
03:05:48 <lambdabot>   Occurs check: cannot construct the infinite type: b0 = (a0, b0)
03:05:52 <beaky> :o
03:06:16 <beaky> :t foldr (,)
03:06:18 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = (a0, b0)
03:06:18 <lambdabot>     Expected type: a0 -> b0 -> b0
03:06:18 <lambdabot>       Actual type: a0 -> b0 -> (a0, b0)
03:06:25 <beaky> ah :(
03:06:37 <mauke> basically you're trying to construct a tuple where the second element is a tuple where the second element is a tuple where ...
03:06:45 <beaky> yeah
03:06:54 <beaky> :D
03:07:00 <mauke> this is more or less what HList does
03:07:12 <beaky> :t HList
03:07:14 <lambdabot> Not in scope: data constructor `HList'
03:08:11 <beaky> :t HList.hlist
03:08:13 <lambdabot> Couldn't find qualified module.
03:09:31 <beaky> let f = unsafeCoerce foldr (,) () in f [1..10]
03:09:38 <beaky> > let f = unsafeCoerce foldr (,) () in f [1..10]
03:09:40 <lambdabot>   Not in scope: `unsafeCoerce'
03:09:57 * beaky .giveUp();
03:10:28 <mauke> @where HList
03:10:29 <lambdabot> http://homepages.cwi.nl/~ralf/HList
03:10:40 <mauke> @where hlist
03:10:41 <lambdabot> http://homepages.cwi.nl/~ralf/HList
03:11:14 <mauke> @where+ HList http://hackage.haskell.org/package/HList
03:11:15 <lambdabot> It is stored.
03:46:20 <Peaker> @type \f -> fmap join . traverse f
03:46:22 <lambdabot> (Monad m, Applicative f, Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
03:47:43 <Peaker> @type \f -> fmap join $ traverse f =<< ?g
03:47:44 <lambdabot> (?g::f (m a1), Monad f, Monad m, Applicative f, Traversable m) => (a1 -> f (m a)) -> f (m a)
03:51:50 <mm_freak> it seems like i'm reading conflicting definitions of universal properties…  so far my impression is this:  a universal property (C, A) is really just an initial object A in the category C, but that can't be it, can it?
03:53:25 <mm_freak> obviously you want there to be a functor from some "more interesting" category to C
03:53:38 <mm_freak> but is this functor part of the definition?
03:57:13 * hackagebot musicbrainz-email 1.0.0.0 - Send an email to all MusicBrainz editors  http://hackage.haskell.org/package/musicbrainz-email-1.0.0.0 (OliverCharles)
03:59:19 <leggo> in C++ a functor is a callable, function-like object. in haskell it's something completely different. is haskell's definition closer to the math definition of a functor?
03:59:33 <mauke> yes
03:59:49 <mauke> for all values of "functor" and "C++"
04:00:18 <mm_freak> leggo: in categorical terms a haskell functor is an endofunctor on the category Hask
04:00:24 <mauke> btw, OCaml uses yet another definition of "functor"
04:00:26 <mm_freak> so it's not "closer to math", it is math
04:05:29 <mm_freak> the term "functor" is abused in quite a few languages actually…  interestingly they are actually abused by the languages in question, while in haskell functors, the real functors from CT, are defined inside of the language
04:06:07 <elliott> you could call "Functor" an abuse too.
04:06:17 <elliott> it's a very weird notion of functor.
04:06:25 <mm_freak> well, more precisely it should be called EndofunctorOnHask
04:06:40 <elliott> it's not even quite that.
04:06:44 <elliott> you don't get to map the objects in an arbitrary way.
04:07:02 <elliott> you have to map a to f a, with some conditions on what f can be.
04:07:03 <mm_freak> elliott: you do, up to isomorphism
04:07:45 <Eduard_Munteanu> I wonder what subcategories of Hask the codomain is.
04:07:51 <elliott> also you can't express things like functors that depend on values and stuff?
04:07:58 <elliott> which are still endofunctors on hask that map objects in that specific way.
04:08:00 <elliott> it's weird.
04:08:17 <mm_freak> elliott: you can with a few language extensions
04:08:31 <Eduard_Munteanu> Type families?
04:08:36 <elliott> you're stretching it
04:08:53 <mm_freak> Eduard_Munteanu: higher rank types or existentials
04:09:39 <elliott> huh?
04:09:45 <elliott> no, you need implicit paramters or reflection or something like that.
04:09:56 <mm_freak> elliott: my point is that you can't define arbitrary instances of + either, yet when you say 3 + 5 that's still an addition
04:10:08 <mm_freak> elliott: and what do you need for reflection to work?
04:10:16 <elliott> unsafePerformIO.
04:10:19 <mm_freak> (implicit parameters are not sufficient)
04:10:20 <mm_freak> no
04:10:25 <elliott> yes
04:10:32 <elliott> plus the FFI.
04:10:35 <mm_freak> you don't need unsafePerformIO…  it's just that the reflection library uses it to improve performance
04:10:41 <elliott> no.
04:10:41 <mm_freak> you don't need the FFI either
04:10:46 <elliott> read the original paper.
04:10:47 <mm_freak> yes, i've implemented it
04:10:49 <elliott> it uses unsafePerformIO.
04:10:53 <lunarjar> if you can't add to variables like i++, how do you find the index of an element in haskell?
04:11:02 <elliott> that is the only way you can go from lifting naturals up to reifying any object whatsoever.
04:11:03 <Peaker> @src findIndex
04:11:03 <lambdabot> findIndex p     = listToMaybe . findIndices p
04:11:05 <mm_freak> i don't care about the original paper, if i can implement it without unsafePerformIO ;)
04:11:08 <Entroacceptor> now I thought I'd be smart and use the archhaskell repos
04:11:10 <elliott> and there's no other way to turn a value like an IORef into a bunch of numbers.
04:11:12 <Peaker> @src findIndices
04:11:13 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
04:11:15 <elliott> you need FFI + unsafePerformIO
04:11:22 <elliott> for arbitrary haskell values.
04:11:25 <Peaker> lunarjar, ^^
04:11:27 <lunarjar> like you have ['a','b','c'] I want to find that c is the 3 one?
04:11:29 <Entroacceptor> and now I can't upgrade my system, because of dependency problems there :(
04:11:32 <mm_freak> elliott: not every value you may want to reflect is an IORef
04:11:36 <elliott> some are.
04:11:41 <Peaker> > zip [1..] ['a','b','c']
04:11:43 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
04:11:48 <elliott> so if you want to do this generically (and you can in theory, so...), you have to.
04:12:19 <mm_freak> elliott: your statement was that you need unsafe stuff for reflection, which is a misleading generalization
04:12:32 <mm_freak> in fact you often use reflection without even knowing:  Vec
04:12:57 <kennyd> @src findIndex
04:12:57 <lambdabot> findIndex p     = listToMaybe . findIndices p
04:13:11 <lunarjar> I already have an array and want like tellMeIndex "gold" ["rubies", "perls", gold"]
04:13:17 <shachaf> You need unsafePerformIO for the API provided by the packkage "reflection".
04:13:28 <lunarjar> and it should give 3
04:13:38 <shachaf> You don't need unsafePerformIO to reify a Bool.
04:13:46 <elliott> mm_freak: my statement is that if you want to be able to define all the instances you can imagine -- including that depend on Haskell values from outside -- you need unsafePerformIO and the Haskell FFI.
04:13:57 <mm_freak> elliott: in fact check out the older versions of reflection…  it didn't always use that unsafe stuff
04:14:00 <elliott> the fact that you can do it for some subset without those things is no disproof, and surely doesn't make my statement misleading.
04:14:29 <elliott> mm_freak: I don't believe you. reflection always used unsafePerformIO + the FFI. I know because I helped with the faster implementation it uses now...
04:14:39 <elliott> http://hackage.haskell.org/packages/archive/reflection/0.0.0/doc/html/src/Data-Reflection.html
04:14:45 <mm_freak> elliott: your statement is misleading, because i'm using pure reflection all the time, including but not limited to defining dependent Functor instances
04:14:52 <shachaf> http://hackage.haskell.org/packages/archive/reflection/0.0.0/doc/html/src/Data-Reflection.html uses unsafePerformIO
04:15:11 <kennyd> > elemIndex "gold" ["rubies", "perls", "gold"]
04:15:13 <lambdabot>   Just 2
04:15:18 <kennyd> see above lunarjar
04:15:22 <kennyd> @src elemIndex
04:15:22 <lambdabot> elemIndex x     = findIndex (x==)
04:15:23 <mm_freak> elliott: 'reflection', but not reflection…  the library has an unfortunate name
04:15:32 <mm_freak> elliott: i'm talking about reflection as the concept
04:15:36 <mm_freak> not the library
04:15:47 <elliott> ??? I'm very confused
04:15:53 <elliott> what was the "it" in "in fact check out the older versions of reflection…  it didn't always use that unsafe stuff", if not the library?
04:16:04 <lunarjar> kennyd, how to do it manually, without integrated haskell functions? and I want it to be 3 to 2
04:16:07 <mm_freak> in that case it was the library
04:16:30 <lunarjar> *not 2
04:16:36 <kennyd> lunarjar recursion
04:16:39 <elliott> anyway, if I'm speaking in generalities, the existence of subsets isn't relevant.
04:16:45 <mm_freak> elliott: i consider this reflection/reification, too:  getLine :: (forall n. Vec n Char -> IO a) -> IO a
04:16:48 <elliott> you can write instances that depend on no values, and those that depend on values constructed a certain way.
04:16:54 <elliott> you can't write instances that depend on any value whatsoever.
04:16:58 <lunarjar> kennyd, yeah recurssion I know but how do you store a value?
04:17:04 <kennyd> lunarjar write a helper function that increments index each time it calls itself
04:17:04 <elliott> so it's not an endofunctor in blah blah blah with full generality.
04:17:07 <lunarjar> or do you just return +1?
04:17:10 <elliott> this doesn't matter in practice, of course.
04:17:24 <elliott> but it means Functor is a bit of a misleading name, if you want to do things full CT functors do.
04:17:25 <lunarjar> then the recurrsion adds all the +1 and you get your element?
04:17:30 <lunarjar> cheers
04:17:45 <elliott> (and you *can* define a more accurate model of a CT functor, it's just a lot of work and ugly to use and nobody really wants it.)
04:17:49 <mm_freak> elliott: i don't see why…  every Functor with proven laws is an endofunctor on Hask
04:18:41 <mm_freak> transitively every Functor is an actual CT functor, it's just that not every CT functor is a Functor
04:19:07 <elliott> so if I define a class whose only instance is Identity, it's not misleading to call that Functor...?
04:19:12 <Eduard_Munteanu> Yeah, you can define a functor from/to arbitrary categories, but I guess you must be able to actually express those categories in Haskell.
04:19:27 <elliott> Eduard_Munteanu: yeah. you can get pretty close, at least
04:19:35 <mm_freak> elliott: the name is not precise, but do you really want to rename it to EndofunctorOnHaskAndPleaseProveTheLaws?
04:20:39 <mm_freak> i'd be happy with Endo, but then again it's EndoOnHask…  the precise name would fill a screen line
04:21:02 <elliott> nope, all names are approximations. haskell certainly does better than the rest in terms of how misleading its Functor is :P
04:21:08 <elliott> it's just not entirely unmisleading
04:21:16 <mm_freak> yes ;)
04:21:22 <bitonic> well it doesn’t take much to do better than C++
04:21:23 <elliott> a worse offender is Num, which doesn't model anything like numbers whatsoever...
04:21:30 <bitonic> or SML
04:21:38 <shachaf> Num models things?
04:21:48 <bitonic> (if you see ‘functor’ as in ‘category theory functor’)
04:21:56 <bitonic> or Prolog.  damn functor is a really popular word
04:21:59 <mm_freak> i don't think Num models anything except "looks like numbers in C code"
04:22:35 <elliott> Num models nums.
04:22:42 <elliott> a num is something deceptively like a number, but not really.
04:22:53 <shachaf> elliott: To be fair, it has instances like Double.
04:22:53 <Eduard_Munteanu> Perfunctorily popular.
04:22:59 <shachaf> You can't do much with that.
04:23:01 <mm_freak> bitonic: like energy…  SML, prolog and other languages are the esoterics of category theory
04:23:06 <bitonic> I think that Haskell is actually the only language were Functor was meant to be a reference to category theory?  I’m not sure I see the connection in SML/C++/Prolog
04:23:10 <elliott> the num law: abs x * signum x = x
04:23:24 <elliott> I like how that's literally the only law Num states. also, it's only a "should"
04:23:26 <Peaker> What are Prolog functors?
04:23:34 <Eduard_Munteanu> Profunctors. :P
04:24:13 <bitonic> Peaker: it’s an atom
04:24:22 <bitonic> that takes arguments
04:24:24 <bitonic> iirc
04:24:28 <Eduard_Munteanu> Protip: don't trust things named pro-
04:24:33 <sopvop> Maybe they took name not from CT
04:24:47 <Mortchek> Isn't Num just FieldPlusSomeOtherStuff?
04:24:53 <bitonic> Peaker: they use the name ‘functor’ in automated reasoning to mean that
04:24:55 <Eduard_Munteanu> And atom clearly isn't from chemistry.
04:25:39 <Mortchek> Wait no, it doesn't even include field laws.
04:26:02 <shachaf> Most Num instances aren't fields.
04:29:39 <bitonic> Eduard_Munteanu: I think they just like to name ‘functors’ something that kinda looks like a function but isn’t :P
04:30:26 <Eduard_Munteanu> Yeah.
04:31:45 <sopvop> Thanks god they didn't name Singleton a Monoid (because mono-)
04:32:19 <bitonic> I guess that SML functors kind of have a CT-feel
04:32:26 <bitonic> but C++ and Prolog, no
04:37:11 <mm_freak> the four laws of monads: 1. c >>= return = c; 2. return x >>= f = f x; 3. (a >=> b) >=> c = a >=> (b >=> c); 4. forall t t2. t <= t2, x understands monads at time t => x can't explain monads to anyone else at time t2
04:37:36 <Eduard_Munteanu> Heh, clearly.
04:37:53 <quicksilver> I spent some time trying to research if there was any historical basis for the word 'functor' to mean 'function object' or 'thing-like-a-function'
04:38:06 <quicksilver> I couldn't find any clear answer, but the usage does seem to be quite old.
04:38:08 <blueonyx> 13:37 < mm_freak > the four laws of monads: ... coincidence? i dont think so xD
04:38:48 <mm_freak> quicksilver: the word is certainly older than CT
04:39:02 <parcs> :k (forall a. Either a) b
04:39:03 <lambdabot> Not in scope: type variable `b'
04:39:08 <parcs> :k forall b. (forall a. Either a) b
04:39:09 <lambdabot> Top level:
04:39:10 <lambdabot>     Illegal polymorphic or qualified type: forall a. Either a
04:39:10 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
04:39:13 <mm_freak> often what people call functor is actual a "functional", a "function-like object"
04:39:24 <mm_freak> blueonyx: ;)
04:39:52 <Eduard_Munteanu> Or functional as in maps from spaces of functions to numbers?
04:40:08 <quicksilver> yeah functionals are function-like
04:40:10 <quicksilver> aren't
04:40:15 <quicksilver> they're dual to functions
04:40:27 <mm_freak> i haven't seen "functor" being abused in that context, though
04:41:32 <mm_freak> (could you really call that abuse?  probably not)
04:41:45 <mm_freak> but "object" in OO is clearly an abuse =)
05:12:15 * hackagebot soap 0.2.0.2 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.0.2 (AlexanderBondarenko)
05:53:08 <erisco> I am trying to grok if Data.Sequence is a structure I can use... I need to be able to make views that represent a subset of the sequence (ideally represented as start and ending indexes)
05:53:38 <erisco> so I am looking at ViewL, but can't make head or tails of what it does... the only explanation is "View the left end of a sequence"
05:54:10 <erisco> looking at this page here: http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html
05:58:41 <supki> > Seq.viewl (Seq.fromList [1..5])
05:58:43 <lambdabot>   1 :< fromList [2,3,4,5]
05:59:00 <supki> > Seq.viewl (Seq.fromList [])
05:59:02 <lambdabot>   EmptyL
05:59:41 <erisco> I'm not sure how the first example you show works
06:00:00 <erisco> :< is an infix operator, yes? how does the former equal the latteR?
06:00:28 <supki> :< is an infix constructor, like :
06:00:57 <supki> erisco: do you agree that 1:[2,3,4,5] = [1,2,3,4,5] ?
06:01:02 <erisco> sure
06:01:36 <supki> well, 1 :< fromList [2,3,4,5] = fromList [1,2,3,4,5]
06:01:55 <albel727> @type :<
06:01:57 <lambdabot> parse error on input `:<'
06:02:14 <erisco> it's been a while since I've looked at Haskell, so I am rusty on the concepts. Seq.viewl is a function, and I would expect it to have a single return value. I am confused why this return value is an expression that reconstructs the sequence...
06:02:24 <erisco> it doesn't make any sense to me with how that is used
06:02:48 <supki> hmm, I don't think what I wrote is really true
06:02:51 <bitonic> @type (:<)
06:02:52 <lambdabot>     Not in scope: data constructor `:<'
06:02:53 <lambdabot>     Perhaps you meant one of these:
06:02:53 <lambdabot>       `Seq.:<' (imported from Data.Sequence),
06:03:01 <bitonic> @type (Seq.:<)
06:03:03 <lambdabot> a -> Seq.Seq a -> Seq.ViewL a
06:03:17 <albel727> ic
06:03:30 <bitonic> erisco: ‘viewl’ returns a ‘ViewL’, which is a datatype like any other
06:03:41 <bitonic> ‘:<’ is one of the constructors for ‘ViewL’
06:04:12 <bitonic> you use ‘viewl’ it to decompose the sequence, but if the sequence is empty, you get ‘EmptyL’
06:04:18 <erisco> bitonic, that is,   a :< Seq a   has the type ViewL a?
06:04:23 <Eduard_Munteanu> supki: view-patterns might help with that
06:04:29 <Eduard_Munteanu> Erm, erisco
06:04:39 <erisco> I am absolutely confused
06:05:12 <Eduard_Munteanu> f (viewl -> x :< xs) = ...
06:05:15 <erisco> to me it looks like    "4 + 5"  is "10-1"
06:05:36 <bitonic> erisco: what’s ‘Seq a’?  ‘x :< xs : ViewL a’, where ‘x : a’ and ‘xs : Seq a’
06:05:37 <erisco> I don't understand why the former is rewritten as the latter, nor do I understand the use
06:06:18 <bitonic> @ty 1 Seq.:< Seq.fromList [2,3]
06:06:20 <lambdabot> Num a => Seq.ViewL a
06:06:26 <bitonic> @ty (1 :: Int) Seq.:< Seq.fromList [2,3]
06:06:27 <lambdabot> Seq.ViewL Int
06:06:46 <bitonic> > Seq.viewl (Seq.fromList [1,2,3])
06:06:48 <lambdabot>   1 :< fromList [2,3]
06:07:02 <bitonic> > Seq.viewl (Seq.fromList [1,2,3]) == (1 :: Int) Seq.:< Seq.fromList [2,3]
06:07:05 <lambdabot>   True
06:07:22 <erisco> okay, again, the example is great, I plainly don't understand how the return value of viewl can be  "a :< Seq a"
06:07:34 <erisco> is this intended to be pattern matched upon? I just don't get what use that has
06:07:42 <Eduard_Munteanu> That's how ViewL is defined.\
06:07:44 <Eduard_Munteanu> Yes.
06:07:54 <erisco> as far as I can tell, if you evaluated  a :< Seq a, you'd merely have the original sequence again
06:07:54 <bitonic> erisco: it’s intended to decompose the seq, if it’s non-empty
06:08:15 <bitonic> erisco: yes but ‘Seq a’ gives you information about whether the list is empty or not, and extracts the first element
06:08:21 <bitonic> sorry, ‘ViewL a’
06:08:50 <Eduard_Munteanu> erisco: I think you're confusing (:<) and (<|).
06:08:50 <bitonic> also, I’m not sure why you keep writing ‘a :< Seq a’, since :< is not a type constructor
06:09:22 <erisco> okay, I am still confused somewhat then
06:09:41 <erisco> as far as I can tell it is the same as writing   1:[2]
06:09:49 <bitonic> erisco: ‘data ViewL a = EmptyL | a :< Seq a’.  agreed?
06:10:31 <bitonic> ‘1 :< Seq.fromList [2,3]’ is *not* the same as Seq.fromList [1,2,3]
06:10:42 <typoclass> erisco: about your earlier question, it's a more-or-less fixed convention that when you call 'show' on a data structure, you get back a String with a valid haskell expression. lambdabot calls 'show' to convert stuff to a String. run it to reconstruct the data structure
06:10:43 <erisco> no? okay..
06:11:03 <typoclass> erisco: Data.Map is another example which works like that iirc
06:11:04 <bitonic> erisco: well, what’s the type of ‘1 :< Seq.fromList [2,3]’?
06:11:06 <Eduard_Munteanu> erisco: that would be 1 <| Seq.fromList [2,3]
06:11:28 <erisco> bitonic, what is :< doing in the type constructor?
06:11:40 <bitonic> erisco: what type constructor?
06:11:47 <erisco> for data ViewL
06:11:48 <Eduard_Munteanu> erisco: it's a data constructor called :<
06:12:03 <bitonic> erisco: it’s a data constructor, like ‘Just’ or ‘Left’
06:12:18 <nh2> bitonic: is this finger trees?
06:12:21 <Eduard_Munteanu> They could've said    data ViewL a = EmptyL | LeftDecompose a (Seq a)
06:12:29 <erisco> nh2, yes
06:12:39 <nh2> erisco: fingertree package or sequence?
06:12:41 <bitonic> nh2: it’s Seq
06:12:46 <bitonic> nh2: in ‘containers’
06:12:55 <bitonic> the implementation is irrelevant
06:12:59 <nh2> bitonic: OK. "fingertree" might thunk-leak :(
06:13:23 <bitonic> nh2: that’s a completely different issue :P
06:13:28 <erisco> :< is just another data type then?
06:13:41 <bitonic> erisco: it’s a data *constructor* for the data type ‘ViewL’
06:13:48 <nh2> I don't know the question anyway :D In case it was fingertree, it might become relevant
06:14:09 <bitonic> nh2: the question is ‘what is “ViewL” and what’s its point’
06:14:15 <nh2> ok
06:14:27 <erisco> how is it decerned as infix?
06:14:42 <erisco> why isn't the constructor's name assumed to be 'a'?
06:14:42 <nh2> here comes a question from me: how do I link in an archive (.a) file with ghc?
06:14:49 <bitonic> erisco: you can define infix data constructors in Haskell.  they must begin with : and include only certain symbols
06:14:51 <Eduard_Munteanu> Um, 'a'?
06:14:58 <hpaste> amatsu pasted “could not deduce (a ~ a1)” at http://hpaste.org/86073
06:15:19 <Eduard_Munteanu> Constructors must begin with an uppercase letter.
06:15:30 <erisco> or full colon, it seems
06:15:40 <Eduard_Munteanu> Yeah, in case they're infix.
06:15:42 <bitonic> erisco: infix constructors must begin with a colon yes
06:15:52 <amatsu> I know that this won't compile if I remove the comments, but is there a way to keep the type signature on the local functions while still maintaining polymorphism?
06:16:10 <erisco> okay, that helps
06:16:21 <erisco> so a viewL is merely the first element and the rest of the sequence, or empty
06:16:30 <simpson> amatsu: Well, you could always specify a polymorphic type signature.
06:16:34 <Eduard_Munteanu> erisco: yeah
06:16:48 <nh2> simpson: no amatsu in this room
06:16:56 <amatsu> nh2: ?
06:17:00 <erisco> that isn't what I intended by "view". will have to find another data structure...
06:17:15 <lpsmith> Is there a handy way of converting a Rational to a decimal string,  accurately?
06:17:16 <erisco> thanks for the help. hopefully I'll get into the swing of things again
06:17:19 <Eduard_Munteanu> erisco: what are you looking for? :/
06:17:21 <bitonic> amatsu: what’s ‘list_of_squares’ and ‘sum_of_squares’?  anyway, NoMonomorphismRestriction might help
06:17:23 <nh2> amatsu: whoa why do you not tab complete? you must have a magic cloak
06:17:36 <bitonic> nh2: amatsu tab completes here.
06:17:48 <amatsu> bitonic: oh, it was for a task, we're not supposed to use Prelude helper functions
06:17:58 <nh2> bitonic: yes, I just don't know how my client works
06:18:17 <bitonic> amatsu: right, but what’s their types?
06:18:55 <nh2> amatsu, bitonic: scopedtypevariables to make it the same a?
06:19:05 <amatsu> bitonic: I'd have just thought normalise :: [a] -> [a] and sumSquares :: [a] -> a
06:19:11 <erisco> Eduard_Munteanu, I wrote an LL parser in C# and I am porting it to Haskell (plus some improvements) because I want to take advantage of the better type system. (also, excuse to refresh myself on Haskell)... anyways, in the C# version I defined StringView which is the string plus a start and end index
06:19:34 <erisco> Eduard_Munteanu, this is how I kept track of what rules matched where
06:19:45 <Eduard_Munteanu> erisco: an array?
06:19:54 <erisco> well, string is more or less an array
06:20:13 <Eduard_Munteanu> erisco: if you need a list-like thing where you can access both ends, Seq is good
06:20:17 <erisco> I don't need random access, only left to right sequentially, but I do need to store arbitrary views of the string, as I defined
06:20:26 <erisco> I don't need to access both ends, just the left
06:20:37 <Eduard_Munteanu> Then use a plain list.
06:20:39 <bitonic> amatsu: so wait, what’s not working?
06:20:40 <Eduard_Munteanu> What does a view do?
06:21:32 <amatsu> bitonic: when I get rid of the comments GHC complains with a "could not deduce (a ~ a1)" error, presumably caused by the fact that I've declared all the functions to be polymorphic over Floating a
06:22:00 <erisco> Eduard_Munteanu, a view represents a subset, and it does this by storing start and end positions (rather than copying the data, say)
06:22:01 <bitonic> amatsu: I don’t get that error, but yes than it’s most likely what nh2 said
06:22:23 <amatsu> bitonic: nh2: alright then, thanks for the help, will check out those extensions
06:22:31 <Eduard_Munteanu> erisco: I wouldn't do that in Haskell
06:22:41 <nh2> amatsu: one sec, I have a nice link for you
06:22:51 <bitonic> amatsu: standard Haskell will implicitly quantify those ‘a’s in the ‘where’.  if you want to refer to the top-level ‘a’, you need to enable ‘ScopedTypeVariables’ and quantify at the top level with ‘forall’
06:22:54 <Eduard_Munteanu> erisco: you could just cut and keep the portion of the list you're interested in, it's not duplicated
06:23:01 <bitonic> but I’d just leave the type signatures out
06:23:16 <erisco> Eduard_Munteanu, could you explain in a bit more detail please?
06:23:31 <Eduard_Munteanu> > take 3 [1..10]
06:23:32 <lambdabot>   [1,2,3]
06:23:45 <Peaker> it would be nice if GHC had a warning mode when auto-shadowing type-variables due to lack of forall+scoped-type-vars
06:23:53 <Peaker> beginner friends of mine would have appreciated it
06:23:58 <erisco> I don't know what this is supposed to demonstrate
06:24:12 <amatsu> bitonic: sounds good.
06:24:27 <Eduard_Munteanu> erisco: you're afraid to copy the data, but you should do exactly that... no actual copy should be involved.
06:24:42 <bitonic> Eduard_Munteanu: wait there won’t be sharing in your example, apart from the boxed integers
06:24:50 <bitonic> but the list cells will be separate
06:25:22 <Eduard_Munteanu> bitonic: really? :/
06:25:37 <erisco> Eduard_Munteanu, your sentence seems to contradict itself... how is copying the data not copying it?
06:26:00 <bitonic> Eduard_Munteanu: yeah, it can’t be otherwise: if the 1 cell for the first list is the same as the second, then the two lists must be equal
06:26:05 <mauke> Eduard_Munteanu: how could it share anything?
06:26:10 <mauke> @src take
06:26:10 <lambdabot> take n _      | n <= 0 =  []
06:26:10 <lambdabot> take _ []              =  []
06:26:10 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
06:26:14 <Eduard_Munteanu> Oh right.
06:26:30 <mauke> the last line shows it consing up a new list
06:26:41 <nh2> amatsu: ah, my link is not that good. I wanted to send you http://stackoverflow.com/questions/13936502/sampling-a-normal-distribution-using-control-monad-monadrandom/13946470#13946470 which also uses ScopedTypeVariables, but it is for scoping a monad constraint. Might be helpful still, perhaps
06:26:43 <Mortchek> drop, on the other hand
06:26:45 <Mortchek> @src drop
06:26:45 <lambdabot> drop n xs     | n <= 0 =  xs
06:26:45 <lambdabot> drop _ []              =  []
06:26:45 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
06:27:02 <amatsu> nh2: I'll look into it, thanks!
06:27:07 <mauke> drop doesn't allocate at all
06:27:15 <Eduard_Munteanu> Yeah, you end up keeping a new list skeleton.
06:27:28 <bitonic> erisco: Eduard_Munteanu was referring to the fact that with functional structures subtrees can be shared, but it doesn’t apply for ‘take’, which is actually building up a new list
06:27:32 <erisco> if you consider a singly linked list, a view would represent a subset by storing a start and end node
06:27:41 <erisco> having a view, I can use the starting node to traverse the entire subset
06:27:50 <erisco> but nowhere do I need random access, see
06:28:14 <mauke> erisco: end nodes only work if you have equality on nodes
06:28:18 <mauke> otherwise you don't know where to stop
06:28:59 <erisco> I was thinking of pointers in this case, so you'd compare memory addresses, but otherwise yes, I see your point
06:29:21 <mauke> yes, that's what I mean
06:29:23 <Eduard_Munteanu> I wonder if Seq gives you more sharing.
06:29:40 <mauke> Haskell values don't have addresses
06:29:49 <erisco> mauke, I could modify the definition to store the start node and an integer representing the subset length
06:34:19 <bitonic> Eduard_Munteanu: it depends what you mean by ‘more’, but if you’re taking slices of a Seq it is going to be better
06:34:30 <Eduard_Munteanu> Yes.
06:34:36 <Eduard_Munteanu> Something like dropping from both ends.
06:34:46 <Eduard_Munteanu> Instead of take-drop.
06:35:34 <erisco> mauke, I should be able to define such a thing for Traversable yes?
06:36:06 <Eduard_Munteanu> erisco: indexing in lists kinda sucks
06:36:07 <Peaker> > let withReversed f = reverse . f . reverse in drop 3 . withReversed (drop 3) $ "Hello world"
06:36:09 <lambdabot>   "lo wo"
06:36:28 <mauke> erisco: I've never used Traversable
06:36:30 <erisco> Eduard_Munteanu, well, I am not indexing anything, as far as I know. random access is not required
06:37:19 <erisco> and I presume that when I deconstruct a list, it isn't creating a new list. ie, x:xs isn't making a whole new list for xs
06:37:36 <bitonic> erisco: that’s right
06:37:47 <bitonic> if by ‘x : xs’ you mean pattern matching
06:37:53 <erisco> yes
06:38:23 <bitonic> when you are creating a new list by ‘x : xs’, a new cell is created with two pointers, one to ‘x’ and one to ‘xs’, so no ‘copying’ there either
06:38:52 <bitonic> but there is some allocation
06:39:07 <erisco> really? so it is like a tree rather than a singly linked list?
06:39:14 <bitonic> while ‘x : xs’ is simply testing for the right constructor and bringing things in scope
06:39:21 <erisco> a sort of degenerate tree, but
06:39:21 <bitonic> (‘x : xs’ pattern)
06:39:31 <mauke> erisco: linked lists are degenerate trees
06:39:44 <bitonic> erisco: I’m not sure what you mean, but all ADTs are trees of some sort
06:40:05 <mauke> fix (1 :)
06:40:42 <erisco> well, according to the description, if you drew it, it wouldn't look the same as a linked list... assuming that these "cells" are parent to the 'x' and the next cell
06:40:49 <erisco> otherwise I don't understand what is meant by this "cell"
06:41:12 <mauke> @where diagrams
06:41:13 <lambdabot> http://projects.haskell.org/diagrams/
06:41:42 <mauke> erisco: http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
06:41:53 <bitonic> erisco: with ‘cell’ I mean something holding references to the head and the tail of the list
06:41:59 <mauke> the left side is the list [1,2,3,4,5]
06:42:01 <erisco> right, that is what I was envisioning
06:42:09 <bitonic> erisco: well that’s what’s happening :P
06:42:16 <erisco> something that looked like a queue of people's legs :P
06:43:25 <erisco> are there no graphs?
06:43:33 <bitonic> erisco: graphs of what?
06:43:59 <erisco> you said all ADTs are trees of some sort. is it not possible to construct a graph?
06:44:05 <erisco> that is, something that is a graph but not a tree?
06:44:19 <bitonic> erisco: what do you mean with ‘graph’?  something with cycles?
06:44:39 <erisco> sure, that would qualify for graph and not a tree
06:44:42 <merijn> > let ones = 1 : ones in ones -- cycles are easy \o/
06:44:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:44:43 <bitonic> or anyway something self-referencing?  in any case, the answer is yes: that’s an infinite tree
06:44:46 <mauke> > fix (1 :)
06:44:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:44:58 <erisco> ah, I see
06:45:04 <bitonic> erisco: you can reference to a previous branch of the tree you are defining, so to speak
06:45:05 <erisco> clever
06:45:15 <bitonic> that’s also called as ‘tying the knot’ :)
06:45:22 <bitonic> /s/as// :P
06:45:31 <merijn> mauke: Is fix (1:) less efficient or identical to my definition in terms of space consumed?
06:45:51 <mauke> merijn: identical
06:46:08 <mauke> @src fix
06:46:08 <lambdabot> fix f = let x = f x in x
06:46:28 <erisco> hmm... so if infinite trees are a permissible substitution for a finite graph, are there any graphs that cannot be represented as a tree?
06:46:29 <mauke> fix (1 :) = let x = (1 :) x in x = let x = 1 : x in x
06:46:29 <merijn> Oh, right. That makes sense
06:46:33 <bitonic> fix f = f (fix f) is nicer
06:46:38 <mauke> bitonic: disagree
06:46:53 <bitonic> mauke: I can picture that much better
06:47:02 <mauke> bitonic: but it's different
06:47:12 <bitonic> it’s clearly an infinite chains of ‘f’s
06:47:16 <mauke> yes, exactly
06:47:18 <mauke> it's not a cycle
06:47:22 <bitonic> mauke: denotationally it’s the same :P
06:47:29 <bitonic> but yes, I see your point
06:47:32 <mauke> I don't picture denotationally
06:47:37 <bitonic> (especially in the context of this discussion)
06:47:53 <bitonic> although you could expect the ‘sufficiently smart compiler’ to tie the knot :)
06:48:01 <mauke> http://codepad.org/foU8zf0q
06:48:12 <mauke> I'm not sure if that's legal
06:48:28 <mauke> it would be something like CSE
06:49:37 <nh2> question still up: how do I link in an archive (.a) file with ghc?
06:49:52 <merijn> nh2: I suspect just -l?
06:50:01 <geekosaur> or name it on the command line
06:50:17 <nh2> merijn: is l not for dynamic libraries (stuff in /usr/lib with .so)?
06:50:24 <merijn> nh2: Works for both
06:50:28 <geekosaur> -l is for libraries
06:50:30 <nh2> merijn: will try immediately
06:50:40 <merijn> Or my C code would never have worked in the past 2 years :p
06:50:45 <nh2> does the order of linking matter?
06:50:51 <merijn> nh2: Depends on your linker
06:50:59 <nh2> when I do ghc .... -package-id  bla bla ....
06:50:59 <geekosaur> generally in /usr/lib, or where -L points, not really appropriate for application-local .a or .so files though
06:51:15 <merijn> On OSX or using gnu gold, no. Traditional linux ld it does (boo! hiss! crap linker!)
06:51:22 <nh2> do I have to stuff it in a certain palace before/after the package that "wants" the symbol in my archive?
06:51:52 <geekosaur> hm, ghc should order the package stuff appropriately itself
06:51:52 <merijn> nh2: The library needs to be in the library include path, you can use -L to specify additional paths to look for libraries
06:52:15 <geekosaur> merijn, -l requires the file start with "lib"
06:52:19 <geekosaur> *filename'
06:52:28 <merijn> So if you wanna link libfoo.a in /opt/blah you can link using "-lfoo -L/opt/blah"
06:54:07 <hpaste> nh2 pasted “linking editline” at http://hpaste.org/86074
06:54:37 <geekosaur> that's not how -l works
06:54:38 <nh2> merijn, geekosaur: this is my actual problem http://hpaste.org/86074
06:54:49 <geekosaur> just leave off the -l on that
06:55:04 <nh2> geekosaur: same problem without -l
06:55:10 <nh2> so the problem seems to be
06:55:17 <merijn> nh2: See how I said to use -l
06:55:18 <geekosaur> that said, you don't have the problem you think you do
06:55:26 <geekosaur> stop
06:55:42 <merijn> But, yeah, this looks like you're not doing something right
06:55:45 <geekosaur> nh2, you are on a Mac, right?
06:55:54 <geekosaur> the system libedit will not work here
06:55:55 <nh2> geekosaur: no, Ubuntu
06:56:01 <geekosaur> oh
06:56:21 <nh2> editline-0.2.1.1.o has that symbol listed in "nm -g", but as "U" (undefined)
06:56:44 <nh2> so I suppose I am somehow supposed to tell ghc to get that el_reset symbol from my system-installed library
06:56:53 <geekosaur> ok, (a) your editline package is broken as it should be doing the right thing to pull that in; (b) you wanrt -ledit
06:56:58 <lunarjar> how to check if an element occurs in array only once?
06:57:07 <nh2> geekosaur: tried -ledit, no difference
06:57:21 <nh2> does this have to do anything with dynamic vs static linking?
06:57:21 <mauke> lunarjar: manually
06:57:28 <geekosaur> so does that library actually define el_reset?
06:57:52 <nh2> geekosaur: yes, nm --dynamic on libedit's .so file lists it as available
06:58:00 <nh2> and it is "T" (text) on the .a file
06:58:01 <lunarjar> mauke, but how do I store the occurences?
06:58:39 <mauke> lunarjar: why store them?
06:58:40 <nh2> what happens in ghc when I specify -ledit? Does it in the final ld step link to the .so dynamically?
06:58:49 <geekosaur> it should
06:59:06 <geekosaur> so, static archive won;t work like that because the symbol is not known to be needed at the point you list it
06:59:35 <geekosaur> this strikes me as a problem with the editline haskell package, because it's not linking correctly to the library for some reason
06:59:49 <erisco> fmap :: (a -> b) -> f a -> f b     where does the 'f' come from?
07:00:06 <mauke> erisco: where does the 'a' come from?
07:00:35 <erisco> what does juxtaposing type variables mean?
07:01:13 <byorgey> erisco: application, the same as it does for value variables
07:01:14 <bitonic> erisco: application, just like values
07:01:15 <mauke> function application
07:01:22 <nh2> geekosaur: I will first try to specify the .a after the editline package then
07:01:24 <mauke> erisco: cf. 'Maybe Int'
07:01:25 <byorgey> erisco: e.g.  f  could be 'Maybe' and  a  could be 'Int'
07:01:28 <Tehnix> does anyone no if there is something wrong in my script here http://hastebin.com/hetaloruwi.hs , it always returns "Couldn't find it :(" even though it "should" be able to :/
07:01:32 <mauke> byorgey: GET OUT OF MY HEAD
07:01:56 <byorgey> mauke: I knew you were going to say that
07:02:02 <bitonic> Tehnix: bitcoin is bust anyway.
07:02:17 <erisco> okay... so fmap on a list, what is 'f'?
07:02:18 * geekosaur was typing in that very example too, but is trying to do too many things at once...
07:02:22 <geekosaur> []
07:02:38 <geekosaur> that is, you can write a list of a as [a], or you can write it in prefix form as [] a
07:02:44 <mauke> > [1,2,3] :: [] Int
07:02:44 <Tehnix> bitonic: heh, well, you can still gain from investing. Anyways, it's more as to getting the prices
07:02:44 <elliott> Tehnix: what is this "return"?
07:02:46 <lambdabot>   [1,2,3]
07:02:46 <geekosaur> and f would be []
07:02:47 <erisco> is the square bracket syntax treated specially in haskell?
07:02:49 <mauke> yes
07:02:51 <elliott> oh, wait.
07:02:55 <elliott> it's actually in the json.
07:02:56 <bitonic> Tehnix: also, how do we know what ‘json’ is, in ‘main’?
07:03:02 <mauke> erisco: square brackets are double special
07:03:03 <Tehnix> elliott: I prolly should have said printed
07:03:05 <klrr> if im having a functions of type String (aka a string variable) can i have that string being on several lines if it's getting longer than 80 chars?
07:03:16 <Tehnix> bitonic: the json is http://data.mtgox.com/api/1/BTCUSD/ticker
07:03:17 <bitonic> well, ‘rawJSON’
07:03:28 <elliott> Tehnix: isn't there a thingy that lets you get a parse error if the json parsing fails?
07:03:33 <elliott> that would be a good thing to use instead.
07:03:48 <mauke> klrr: your use of "function" disturbs me
07:03:54 <Tehnix> elliott: This is the first time using Aeson, so, i don't exactly know if there is :/
07:04:08 <Tehnix> that, and i'm fairly new to haskell
07:04:11 <Tehnix> still
07:04:12 <nh2> geekosaur: ok, changing the order did not work. How would you go about finding out what hseditline does wrong (if it does)?
07:04:15 * elliott takes a peek at the docs
07:04:28 <elliott> eitherDecode :: FromJSON a => ByteString -> Either String aSource
07:04:28 <elliott> Like decode but returns an error message when decoding fails.
07:04:29 <bitonic> Tehnix: the numbers are actually strings in that thing
07:04:32 <elliott> Tehnix: try that
07:04:37 <geekosaur> the link instructions it builds are in its package.conf.d file
07:04:44 <bitonic> Tehnix: so that’s probably failing
07:04:45 <elliott> instead of Nothing, you'll get back Left err, where err is something more useful you can print.
07:05:00 <nh2> geekosaur: should hseditline.so reference my public object file in any way?
07:05:12 <Tehnix> bitonic: :D that was *exactly* the problem
07:05:20 <bitonic> @next
07:05:23 <lambdabot>  Defined.
07:05:25 <bitonic> oh.
07:05:28 <bitonic> wrong channel.
07:05:38 <geekosaur> you mean -ledit? it should be listing it because it's a dependency
07:05:41 <elliott> Tehnix: a good practice even if your immediate problem is fixed, since programs have a tendency to break :)
07:05:43 <mauke> preflex: ? next
07:05:44 <preflex>  another satisfied customer! next please.
07:05:47 <Tehnix> bitonic: I just figured the value i was testing would succeed (i defined getLast to be a String), but apparently all failed
07:05:52 <nh2> geekosaur: actually, is that "Loading package" stuff a templatehaskell invocation?
07:06:07 <Tehnix> elliott: yup, Either is where you use Left and Right, right?
07:06:08 <nh2> because usually it should link at the end, right?
07:06:08 <geekosaur> no
07:06:12 <bitonic> Tehnix: cool, but elliott is right
07:06:12 <geekosaur> *but*
07:06:18 <nh2> not just in the middle of compiling my first module
07:06:19 <geekosaur> TH and ghci use the same mechanisms
07:06:24 <elliott> Tehnix: yep
07:06:27 <klrr> mauke: why? i think it fits perfectly in my program, i just need a way to have a string that's more than one line, since i dont wanna have it being wider than 80 chars
07:06:33 <elliott> Tehnix: instead of Just x you have Right x, instead of Nothing you have Left y
07:06:42 <Tehnix> bitonic, elliott: I'll try and implement it, but, atleast I know it's working now
07:06:46 <mauke> klrr: because a string is not a function
07:06:59 <mauke> "a function of type String" is an oxymoron
07:07:00 <geekosaur> and when ghci sees an import it will link any associated objects immediately
07:07:05 <lunarjar> mauke, well how do you check otherwise if n > 1 then false if n == 1 then true
07:07:25 <nh2> geekosaur: ok, but I'm not using ghci explicitly
07:07:53 <mauke> lunarjar: like that
07:07:57 <nh2> so when it says [1 of 213] Compiling MyModlue (...) \n Loading package XXX ... linking ... done.
07:08:02 <lunarjar> but you can't add to n
07:08:05 <geekosaur> oh. then it probably is something TH-ish, if it's doing that mid-compile
07:08:06 <nh2> is that not what appears on a TH invocation?
07:08:23 <mauke> lunarjar: oh, you don't know how to transform loops into recursion?
07:08:24 <bitonic> nh2: you’d see a lot of packages being loaded if it’s TH
07:08:39 <nh2> bitonic: I do, it's around 150
07:08:49 <nh2> this is why I suspect ghc*i* (for the TH) does not find that symbol
07:08:52 <lunarjar> mauke, not really, just starting out haskell
07:09:07 <mauke> lunarjar: loops turn into recursive functions
07:09:09 <nh2> geekosaur: so maybe my -l flag for ghc does not get used in the TH ghci invocation?
07:09:17 <mauke> lunarjar: variables that change in the loop become function parameters
07:09:24 <geekosaur> likely, yes
07:09:40 <lunarjar> xs[10,20,30,20] a = 20
07:09:42 <geekosaur> so you need to fix the package.conf for editline to make dure -ledit is added properly
07:10:03 <lunarjar> oneTime 20 xs should give False
07:10:09 <geekosaur> it's a text file, you can edit it. but run "ghc-pkg recache" afterward
07:10:10 <Tehnix> elliott: using eitherDecode instead, how would the type of the return be. With decode it was "Maybe BTCInfo".
07:10:29 <nh2> geekosaur: will have a look at that. How do I do that? Download the cabal package and see if it's listed as "extra-libraries: edit"?
07:10:29 <mauke> lunarjar: that's not an array, btw
07:10:37 <lunarjar> a list
07:10:39 <lunarjar> of integers
07:11:00 <geekosaur> nh2, I am talking about editing the local ghc registry
07:11:00 <lunarjar> for(x in xs) if x == a then i++
07:11:08 <lunarjar> How to translate that line into haskell?
07:11:13 <geekosaur> ~/.ghc/<version>/package.conf.d/
07:11:17 <klrr> mauke: i know, but it fits great in my program
07:11:30 <geekosaur> as shown by "ghc-pkg list"
07:11:43 <klrr> anyone know how to have a string on several lines like """foobar\nfoobar""" in python?
07:12:11 <nh2> geekosaur: oh. I see
07:12:27 <mauke> lunarjar: count a xs = rcount 0 a xs where { rcount i a [] = i; rcount i a (x : xs) = if x == a then rcount (i + 1) a xs else rcount i a xs }
07:12:27 <bitonic> klrr: use ++ or lists and ‘concat’
07:12:30 <geekosaur> I don't know why it installed apparently incorrectly on your system
07:12:35 <nh2> geekosaur: "extra-libraries: edit curses" is listed
07:12:43 <mauke> lunarjar: (this is not very elegant code and can be improved)
07:12:45 <elliott> Tehnix: Either String BTCInfo
07:12:52 <hpaste> merijn pasted “lunarjar - recursive loop” at http://hpaste.org/86075
07:12:53 <Kinnison> mauke: I hope that was deliberately icky :-)
07:13:08 * elliott doesn't find that so icky. not optimal, but not awful.
07:13:11 <merijn> lunarjar: There's a simple example to write such a loop
07:13:20 <lunarjar> thanks! :)
07:13:20 <elliott> it's "low-level"
07:13:32 <merijn> Apparently there's also notElem which would make it slightly nicer, but I didn't know that :p
07:14:06 <klrr> bitonic: thanks!
07:14:11 <merijn> lunarjar: So basically step one is checking that a is in there *at least* once, then if you find it the first time then you check that the rest doesn't have it again
07:14:23 <mauke> merijn: that's a different algorithm, though
07:14:27 <mauke> (a more efficient one)
07:14:29 <nh2> geekosaur: wo with that flag being present, would you count that as "correctly installed" or do I have to check for more?
07:14:57 <merijn> lunarjar: The trick is to learn how to decompose these problem into simple steps, i.e. "first check whether there is one a, THEN check that there isn't a second"
07:15:08 <geekosaur> nh2, that looks like it should be correct.
07:15:19 <merijn> mauke: Sure, I wasn't trying to transliterate arbitrary loops. I was trying to illustrate the functional approach to problems like this
07:15:25 <nh2> geekosaur: can I maybe check from ghci manuallY?
07:15:33 <erisco> can classes be used as types? is this what existential type classes are about? the analogy to classes that I read was "they are like interfaces from oop languages"
07:15:51 <geekosaur> this starts to sound like a ghc (ghci/th) bug of some kind
07:16:01 <geekosaur> erisco, classes are not types
07:16:05 <bitonic> erisco: your question is vague, give examples.  in standard Haskell, the answer is probably ‘no’ :P
07:16:05 <mauke> erisco: classes can't be used as types (classes group types into ... classes)
07:16:12 <Eduard_Munteanu> erisco: existential types, not typeclasses
07:16:33 <nh2> geekosaur: I wish not
07:16:45 <mauke> erisco: existential types give you the ability to forget everything about the type of a value (except possibly for the classes it inhabits)
07:17:00 <erisco> data Foo a = Foo Traversable a
07:17:10 <mauke> error
07:17:33 <erisco> I know, but in an oop language it is commonplace to store references as interface types
07:17:33 <lunarjar> merijin haskell really requires a pen and paper and a lot of thought
07:17:44 <lunarjar> thanks mauke and merijin ;)
07:17:46 <mauke> data Foo = forall a. (Traversable a) => Foo a
07:17:57 <merijn> lunarjar: After a while you get really handy in doing these things in your head
07:18:14 <merijn> lunarjar: But I can certainly recommend thinking on paper a lot when you start, it helps
07:18:15 <Eduard_Munteanu> erisco: typeclasses are sets of types with a common interface (not as an OOP term)
07:18:29 <mauke> erisco: existentials bundle a value and a vtable, so to speak
07:18:50 <Eduard_Munteanu> erisco: for example, both Int and Double are Nums, you can add 2 Ints or 2 Doubles.
07:19:13 <Eduard_Munteanu> :t (+)
07:19:14 <lambdabot> Num a => a -> a -> a
07:19:33 <mauke> let's go with (==) first
07:19:35 <mauke> :t (==)
07:19:37 <lambdabot> Eq a => a -> a -> Bool
07:19:49 <mauke> > "abc" == "abc"
07:19:50 <lambdabot>   True
07:19:52 <mauke> > "abc" == 'x'
07:19:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:19:54 <lambdabot>              with actual ty...
07:19:57 <mauke> type error
07:20:12 <mauke> because "abc" is a String while 'x' is a Char
07:20:14 <byorgey> erisco: this kind of thing is much less common in Haskell.
07:20:25 <erisco> so I can use the interface as a formal parameter type, but not as the type of a type variable in a data constructor?
07:20:31 <mauke> they're both instances of Eq, but the type of (==) doesn't just say that each argument must implement Eq
07:20:40 <byorgey> erisco: you can't use it as either.
07:20:56 <mauke> it says that the arguments must have the same type, *and* that type must implement Eq
07:20:58 <erisco> I don't understand then... what purpose do these interfaces have then?
07:21:12 <mauke> erisco: the usual
07:21:22 <mauke> :t elem
07:21:24 <lambdabot> Eq a => a -> [a] -> Bool
07:21:37 <mauke> ^ works for any type that supports equality comparison
07:21:46 <mauke> @src elem
07:21:46 <erisco> well as byorgey just hinted, you can't use classes as a parameter type... where else are they used?
07:21:46 <lambdabot> elem x    =  any (== x)
07:21:54 <merijn> erisco: "(==) :: Eq a => a -> a -> a" basically says "IF a is an instance of Eq, THEN (==) has type a -> a -> a"
07:21:55 <mauke> erisco: in type constraints
07:22:24 * hackagebot language-objc 0.4.2.6 - Analysis and generation of Objective C code  http://hackage.haskell.org/package/language-objc-0.4.2.6 (JohnLato)
07:23:21 <erisco> ... okay, so when I said "use as a parameter type" what I should have been saying is "use as a type constraint"
07:23:26 <erisco> I don't particularly see the difference
07:23:40 <mauke> erisco: see the (==) example
07:23:51 <merijn> erisco: Well, a constraint is saying a type is only valid if all the constraints are met
07:24:01 <erisco> mauke, okay, I see
07:24:17 <erisco> mauke, so the function still recognizes... in oop terms... the most derived type
07:24:29 <erisco> mauke, this is like any generic constraint then
07:24:30 <mauke> (==) :: (Eq a) => a -> a -> Bool, not (==) :: Eq -> Eq -> Bool
07:24:31 <Spockz> Was John Hughes the first to notice that you need something akin to Weak Pointers when storing values in a table for memorization?
07:24:45 <merijn> "id == (+1)" is a type error, because functions are not an instance of Eq, but you could write in an instance for functions and then it would work (although any instance for function would be silly)
07:24:48 <mauke> erisco: huh? types aren't derived
07:24:49 <Spockz> + in his paper Lazy memo-functions (http://dl.acm.org/citation.cfm?id=5289&CFID=205891911&CFTOKEN=99534439)
07:24:57 <erisco> mauke, I said in oop terms
07:25:07 <mauke> erisco: how do oop terms apply here?
07:25:14 <erisco> do they not?
07:25:23 <mauke> I don't know
07:25:43 <erisco> this seems entirely analogous to generic constraints
07:25:46 <merijn> erisco: It's best to not try to compare things to OOP terminology/concepts, generally it only leads to confusion
07:25:56 <erisco> (noting that generics and oop aren't the same thing, but nonetheless)
07:26:11 <merijn> erisco: A completely different typeclass example
07:26:21 <erisco> well, if you expect me to discard all working knowledge I have, then you're asking too much
07:26:25 <merijn> Bounded, which gives you two values minBound and maxBound
07:26:30 <merijn> > minBound :: Int
07:26:32 <lambdabot>   -9223372036854775808
07:26:35 <merijn> :t minBound
07:26:36 <lambdabot> Bounded a => a
07:26:44 <erisco> I'm not asserting equivalence, only similarity in concept
07:26:44 <Spockz> erisco: not discard, but set aside for a moment
07:26:53 <merijn> erisco: How would that fit in your OOP analogy?
07:28:17 <erisco> I don't understand your first statement merijn. How does Bounded 'give' two values?
07:28:26 <mauke> @src Bounded
07:28:27 <lambdabot> class  Bounded a  where
07:28:27 <lambdabot>     minBound, maxBound :: a
07:28:30 <mauke> ^ like that
07:28:53 <merijn> It doesn't give a value, it *is* a value
07:29:08 <mauke> ?
07:29:16 <mauke> Bounded is not a value
07:29:20 <merijn> mauke: I mean minBound/maxBound are values
07:29:26 <erisco> okay, and then you had to explicitly state the type of minBound because it is overridden for each type that derives it
07:29:34 <merijn> The type says "IF a is Bounded, THEN minBound is an a"
07:29:42 <mauke> erisco: s/derives/instantiates/
07:29:43 <erisco> well this is type specialisation, which I don't see as related
07:29:50 <mauke> erisco: and s/overriden/implemented/
07:30:18 <merijn> erisco: The fact that you don't see this as related is what's causing you problems
07:30:27 <geekosaur> erisco, you may have just answered yourself
07:30:29 <klrr> in Pandoc, how do i use renderTemplate?
07:30:31 <merijn> The exact same thing is happening in both cases
07:30:53 <erisco> geekosaur, I don't have a question at this point
07:31:49 <geekosaur> no, you have a persistent misunderstanding, and you just demonstrated it. if it's "not related", how can your understanding possibly be correct?
07:32:32 <erisco> it isn't related to the initial analogy I saw
07:32:45 <erisco> however, I do see the connection being drawn now
07:32:48 <merijn> Which is why people were saying the analogy was wrong :)
07:32:48 <latermuse> what is template haskell used for?
07:32:59 <merijn> latermuse: Compile time code generation
07:33:08 <latermuse> merijn: like lisp macros?
07:33:11 <mauke> latermuse: yes
07:33:14 <merijn> latermuse: Yes
07:33:21 <latermuse> got it. thanks!
07:33:50 <erisco> merijn, unless I am confused, then it is merely a different aspect that I was referring to, which is the difference between accepting an interface type N and a type T constrained to N
07:34:27 <merijn> erisco: Actually, I just remembered a good example
07:35:03 <erisco> but how this plays into type specialisation I see now
07:35:06 <klrr> can someone explain how do specify if i want a string or a html or a bytestring http://hackage.haskell.org/packages/archive/pandoc/1.11.1/doc/html/Text-Pandoc-Templates.html
07:35:07 <erisco> so thank-you
07:35:14 <klrr> when i use renderTemplate
07:35:42 <merijn> erisco: The difference between constraints and OO derivations/inheritance is that constraints also let you be polymorphic in return types/values, unlike inheritance polymorphism which typically only allows polymorphism in function arguments
07:35:48 <merijn> For example read
07:35:50 <merijn> :t read
07:35:51 <lambdabot> Read a => String -> a
07:36:10 <merijn> The implementation is selected by the caller, not by the arguments passed to it
07:36:14 <Peaker> it also lets you express type equality:   Eq a => a -> a -> Bool          is different from:    (Eq a, Eq b) => a -> b -> Bool
07:36:42 <Peaker> And  (IEq -> IEq -> Bool) is more like the latter
07:36:57 <Peaker> erisco, ^^
07:36:59 <erisco> merijn, I was only referring to generics, which isn't really related to oop (it only happens to be a common feature that interlaces with inheritance, which is unrelated)
07:38:24 <hpaste> “Anonymous Coward” annotated “cabal install hsc2hs” with “cabal install hsc2hs (annotation)” at http://hpaste.org/57014#a86076
07:38:26 <erisco> merijn, covariant arguments and contravariant return values (if I remembered the prefixes correctly) and not all languages even support this, yes
07:39:04 <erisco> merijn, but with the addition of generics you can have polymorphic return values
07:39:23 <erisco> (well, depending on the implementation, but it is possible)
07:40:46 <erisco> Peaker, how is it more like the latter? the latter seems to be comparison between two different types, but the example operates on two equal types
07:40:59 <erisco> not that it is incompatible, but not necessary
07:42:03 <Peaker> erisco, Yes, in Java, if you have something like:    bool foo(IEq a, IEq b)    then the two types can be different
07:42:35 <erisco> but you've just stated then as the same. I don't understand what you are saying
07:43:10 <Peaker> erisco, in OOP, when you say both params are IEq, then they are both some subclasses/implementors of IEq
07:43:11 <mornfall> erisco: IEq is an interface
07:43:17 <Peaker> erisco, but you're not saying they're the same type
07:43:20 <mornfall> It's like a typeclass.
07:43:23 <mornfall> Only it's not.
07:43:24 <mm_freak> erisco: in principle the java interface lets you write foo(3, "blah")
07:43:30 <mm_freak> for haskell's (==) you get a type error
07:43:41 <mm_freak> > 3 == "blah"
07:43:42 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:43:43 <lambdabot>    arising from the literal ...
07:43:50 <erisco> okay, I understand this completely... it was what I was saying this whole time
07:44:09 <erisco> and the Java equivalent is not what you are stating
07:44:50 <Peaker> erisco, what is the Java equivalent?
07:45:02 <erisco> I forget the exact notation, but it is something like      bool <A extends IEq, B extends IEq> foo(A a, B b)
07:45:04 <Peaker> erisco, in Java you cannot really state that two types are equal, only that some base-type of both is equal
07:45:17 <erisco> this is the difference I was talking about exactly
07:45:43 <Peaker> erisco, even if you said:  bool <A extends IEq> foo(A a, A b)   you're *still* not saying that "a" and "b" are the same type
07:45:50 <mornfall> What was the original thesis? I have tried backlog but it's long. :-)
07:46:04 <erisco> Peaker, no, of course not, but I could...
07:46:14 <Peaker> mornfall, explaining the difference between type-class constraints and OOP instance inheritance
07:46:16 <mornfall> Peaker: Well, I guess type equality doesn't really make any sense in Java.
07:46:28 <mm_freak> not sure about the notation, but the following is the java equivalent up to subtyping:  Bool foo<A extends IEq)(A x, A y);
07:46:56 <erisco> Peaker, bool <A extends IEq> foo(A left, A right)    I'm not sure what you are saying at this point though
07:46:58 <mm_freak> java considers subtypes to be equal
07:47:14 <Peaker> erisco, I wrote that above..?
07:47:48 <mornfall> mm_freak: Yeah, but that's not really type equality for any useful definition of equality.
07:47:56 <erisco> Peaker, that does say they are the same type. Give me an example of how this is not so
07:48:28 <mm_freak> mornfall: subtyping can be well defined…  i don't know if it is in java
07:48:31 <mornfall> erisco: class A : public I; class B : public I; compare( a, b ) :-)
07:48:39 <Peaker> mornfall, "extends" in Java-land
07:48:39 <mm_freak> in general i'm very wary about subtyping languages
07:48:46 <erisco> mornfall, that fails to match the signature
07:49:06 <Peaker> erisco, compare<I>(new A(), new B())
07:49:07 <erisco> precisely because A =/= B
07:49:27 <mornfall> erisco: Ok, make it B : public A then. That has to work.
07:49:56 <mornfall> I dunno how generics actually work. :-) Last time I checked it just slapped some automatic conversions in front of things.
07:50:19 <erisco> Peaker, you also did this with IEq a, IEq b, but it isn't sensical. We can talk about the most derived type of an object, but that isn't relevent
07:51:10 <byorgey> mm_freak: subtyping isn't well-defined in Java.  There are well-known bugs with co-/contra-variance, especially wrt arrays, which were DELIBERATELY chosen by the designers for "convenience" =P
07:51:10 <mornfall> erisco: The thing is, Java can't reject code where you pass a subtype in place of its parent type.
07:51:17 <mornfall> erisco: And generics can't break that either.
07:51:31 <mauke> did someone say ArrayStoreException?
07:51:45 <erisco> of course not, that is inherent design
07:53:39 <mornfall> erisco: But then you must claim that A = B if B is subtype of A.
07:53:49 <erisco> but that has nothing to do with the distinction between    bool foo(IEq a, IEq b)    and    bool <A extends IEq, B extends IEq> foo(A a, B b)    . The fact that the types A and B may not represent the most derived type of the passed objects isn't what's important
07:54:12 <mm_freak> byorgey: i'm not surprised
07:54:37 <mm_freak> java is so badly designed overall, i'd be very surprised to find that they got subtyping right =)
07:54:47 <mornfall> erisco: The distinction is only that the first allows siblings to be passed, while the latter only allows a pair connected through ancestry alone.
07:54:52 <byorgey> I learned this when preparing a lecture on subtyping in Java (for an intro programming course).  I almost threw something.
07:55:05 <mm_freak> hehe
07:55:30 <mm_freak> byorgey: but now i'm curious…  could you explain how exactly it's broken?
07:55:32 <Tehnix> is there a way to do String -> IO String ?
07:55:37 <mm_freak> Tehnix: return
07:55:41 <mornfall> Even when subtyping is well defined, it is kinda tacky.
07:55:51 <merijn> :t return `asAppliedTo` ""
07:55:53 <lambdabot> Monad m => [Char] -> m [Char]
07:55:55 <mornfall> Tehnix: retu... mm_freak got me again?
07:56:11 <erisco> mornfall, I don't have to claim A = B because an A cannot be treated as a B
07:56:13 <byorgey> mm_freak: it's simple: Array is considered covariant for the purposes of subtyping, even though arrays are mutable so they should really be invariant
07:56:22 <erisco> mornfall, it might be more apt to use subset
07:56:24 <ion> :t return `asAppliedTo` (undefined :: String) -- i wonder if it picks the type alias from this?
07:56:24 <Tehnix> mm_freak, mornfall: ah, thanks :)
07:56:26 <lambdabot> Monad m => String -> m String
07:56:31 <mornfall> erisco: It can't, but then you can't express type equality with generics.
07:57:17 <mm_freak> byorgey: covariant in what sense?  as a functor?
07:57:19 <erisco> you are only considering the most derived type, which I see no compelling reason to require
07:58:09 <mornfall> erisco: Well, if you define equality otherwise, then you say A = B. :-)
07:58:09 <byorgey> mm_freak: i.e.  if  A <: B  then  Array A <: Array B  (where <: means "is a subtype of")
07:58:11 <erisco> but anyways, this has gone in circles, and I don't think we're discussing with the same definitions and intentions
07:58:30 <mm_freak> byorgey: ah, i see
07:58:51 <mm_freak> byorgey: that's a consideration not many OO programmers make
07:59:20 <mm_freak> when i came from C++ to haskell i had never thought about relationships like that
08:00:13 <bitonic> mm_freak: to Java’s defense, that mistake applies only to arrays and not to generics in general
08:00:17 <bitonic> *in Java’s defense
08:00:32 <mornfall> bitonic: generics are much newer than arrays, too
08:00:42 <bitonic> mornfall: they are
08:00:43 <mm_freak> bitonic: i think this is about subtyping, not generics
08:01:05 <bitonic> mm_freak: subtyping of generics (generic = parametrised type, in java)
08:01:28 <mm_freak> true
08:01:48 <bitonic> in Scala you have variance annotations, which is fun ehe
08:02:30 <mm_freak> this mixture is weird anyway, but it's not that i have an aversion against subtyping in general
08:02:36 <bitonic> I have
08:04:28 <mm_freak> well, type classes can be used for subtyping…  it doesn't have to be a language feature
08:04:51 <mm_freak> what we don't have is subtype polymorphism
08:07:08 <bitonic> mm_freak: ‘type classes can be used for subtyping’?
08:07:10 <armlesshobo> hmm
08:07:49 <bitonic> subtyping means something precise, and type classes are not subtyping.  there is some functional overlap
08:09:59 <mm_freak> bitonic: i think you have to keep subtyping and subtype polymorphism separate…  not sure if there is an actual formal definition of subtyping, but i consider this a form of it:  data Stuff where Stuff :: (Integral a) => a -> Stuff
08:10:14 <erisco> bitonic, absolutely agreed and I understand this distinction. would you not agree is it much like template specialisation from, say, C++?
08:10:28 <nominolo> Anyone know where the contents of .cabal/config are documented?
08:11:01 <bitonic> mm_freak: that’s not subtyping.  subtyping is when according to your type system you can use some value of type A as something of type B if ‘A :< B’ (A is a subtype of B).  in Haskell there is no such judgement
08:11:05 <mm_freak> nominolo: your best bet is the cabal user guide and the default file
08:11:13 <erisco> bitonic, or even function overloading, really
08:11:14 <bitonic> I’m not sure what you mean by ‘subtype polymorphism’
08:11:21 <mm_freak> bitonic: i see
08:11:28 <bitonic> erisco: what’s like template specialisation?
08:11:30 <nominolo> mm_freak: yeah, and that's useless
08:11:43 <nominolo> well, the default config file is kinda ok
08:11:51 <mm_freak> bitonic: well, commonly subtype polymorphism means that a function may have different code depending on the types
08:12:11 <nominolo> I guess the next problem is why there's no way to configure cabal-install to always generate the hoogle file
08:12:12 <erisco> bitonic, you said type classes in Haskell are not like subtyping in OOP languages. I agreed, and offered something else that is more similar
08:12:21 <erisco> bitonic, and then asked if you agreed with this assertion
08:12:41 <mm_freak> erisco: C++ templates are a macro language…  haskell polymorphic types actually compile to a single code instance, unless you specifically ask to specialize
08:12:54 <mm_freak> erisco: id :: a -> a
08:12:56 <bitonic> mm_freak: that’s simply subtyping
08:13:10 <mm_freak> you call the same function 'id', whether the argument is an Int or a (Window -> X ())
08:13:41 <nominolo> dcoutts: do you know if there's some magic undocumented way to specify cabal install --haddock-hoogle via .cabal/configL
08:14:04 <erisco> mm_freak, whether you duplicate the routine for each type or you insert code to decide which type is being used into the routine is just an implementation detail
08:14:06 <mornfall> mm_freak: What code is generated is an implementation detail, though.
08:14:08 <erisco> mm_freak, the concept remains the same
08:14:18 <mm_freak> erisco: no, in haskell no such decision is made
08:14:26 <mm_freak> the type information does not exist at run time
08:14:56 <erisco> mm_freak, well, I presume we're only talking about implementation details. how does haskell manage to do this then
08:15:47 <bitonic> erisco: I suppose there are some similarities but it’s always risky and not that useful to do these comparisons
08:16:04 <mm_freak> erisco: read 'a -> a' as 'forall a. a -> a' and interpret it as a promise
08:16:05 <bitonic> erisco: there is a difference between two things being used for similar things and the two things being similar
08:16:18 <mm_freak> "i'm id and i work for all types a, so i don't care what you pass me"
08:16:21 <erisco> bitonic, understanding and discussing the relationships between different approaches to similar problems is not deterimental to understanding.
08:16:45 <mm_freak> erisco: let me give you something that C++ templates can't express:
08:16:45 <bitonic> erisco: that’s true, I was just making clear my position about the word ‘similar’ :P
08:17:15 <mm_freak> getTwoRandoms :: (Monad m) => (forall a. (Random a) => m a) -> m (Int, Integer)
08:17:30 <mm_freak> the first argument is a function that is polymorphic in its type 'a'
08:17:51 <mm_freak> so you can actually write:  getTwoRandoms getRandom = liftM2 (,) getRandom getRandom
08:17:54 <bitonic> erisco: I think what you are noticing here is that type classed methods will be resolved to different bodies depending on the type class instance.  similarly with template specialisation you can get different classes for different type parameters
08:18:13 <bitonic> erisco: but it doesn’t go much further than that
08:18:17 <mm_freak> erisco: it this point you get an actual semantic difference and not merely an implementation detail
08:18:21 <mm_freak> s/it/at/
08:18:30 <erisco> bitonic, well, that is as far as I was drawing it too
08:18:56 <bitonic> erisco: well then yes.  I’m not sure it is a fruitful comparison
08:19:13 <erisco> bitonic, it is
08:20:17 <bitonic> erisco: I don’t think it’s useful because you’re still describing very different things
08:20:17 <erisco> mm_freak, I don't yet understand forall
08:20:44 <mm_freak> erisco: technically it means:  the argument passed to getTwoRandoms /must/ be polymorphic
08:20:44 <erisco> bitonic, to me it is like arguing abstractions are pointless to identify and talk about because particular implementations vary considerably
08:21:38 <mm_freak> erisco: haskell is designed such that no run-time type information will be needed ever, so there will never be type-based branches in the generated code
08:22:16 <mm_freak> in particular polymorphic functions never need to be "instantiated"…  a compiler can choose to do so for efficiency, and /that/ is an implementation detail
08:22:26 <erisco> mm_freak, all the while not duplicating routines for each type such as with C++ templates? this almost seems like magic
08:22:35 <bitonic> erisco: no, it’s different, because templates and type classes are very different ways of expressing those abstractions.  what I’m scared about is that you’ll start using type classes as C++ templates
08:22:50 <mm_freak> erisco: there is really nothing magic about that…  haskell just takes polymorphism seriously =)
08:23:01 <nh2> geekosaur: the package imports fine with standard ghci
08:23:04 <mm_freak> erisco: if a type is polymorphic you can't make assumptions
08:23:17 <bitonic> mm_freak: polymorphic and with no constraints :)
08:23:18 <mm_freak> consider this:  f :: a -> a -> a; f x y = x + y
08:23:26 <mm_freak> this is a type error
08:23:33 <mm_freak> because you assumed that 'a' is a Num
08:24:00 <geekosaur> nh2: then I think you have a ghc bug :(
08:24:06 <erisco> mm_freak, okay, but "serious" doesn't translate into machine code
08:24:15 <mm_freak> erisco: exactly =)
08:24:32 <mm_freak> you can take that literally ;)
08:24:32 <erisco> mm_freak, well that doesn't answer how a decision about type is avoided
08:24:54 <mm_freak> erisco: again, if you make no assumptions you don't do anything a value is not prepared for
08:24:55 <mornfall> erisco: It's not actually avoided, the type class is passed along as a hidden parameter.
08:25:07 <bitonic> erisco: instance resolution is done at compile time.  there are rules to what instances can be defined that guarantee that it is possible to do so
08:25:18 <mm_freak> erisco: think about it:  id can really only do to things with its argument, either give it back or ignore it
08:25:20 <erisco> mm_freak, I only press because an implementation detail such as this could greatly inform my understanding
08:25:30 <mm_freak> how do you ignore it?  there is only one possibility:  call itself recursively
08:25:45 <mm_freak> you never reach a point where you would /use/ the value or pass it to a function that expects an Int
08:26:39 <bitonic> erisco: wait what is your doubt again?
08:27:34 <mm_freak> erisco: consider this:  you want to sum a list of values, and there is this combinator for that called foldl
08:27:42 <mm_freak> let me simplify the type a bit
08:27:53 <mm_freak> foldl :: (a -> a -> a) -> a -> [a] -> a
08:27:56 <erisco> bitonic, that no decision is made at runtime to decern type and it is not necessary to duplicate routines at compile time per type
08:28:13 <mm_freak> it takes a list of values…  the type of those values is completely polymorphic
08:28:22 <klrr> how do i launch another program from within my own program?
08:28:24 <mm_freak> if that were all you get, what could you do?
08:28:31 <erisco> bitonic, which voids how C# does generics and how C++ does templates, and these are the only two approaches I know of
08:28:31 <mm_freak> klrr: System.Process
08:28:35 <klrr> mm_freak: thanks!
08:28:58 <bitonic> erisco: so it’s really two questions 1) how can Haskell erase all types at runtime and 2) another question I don’t understand about ‘duplicated routines’
08:29:20 <mm_freak> erisco: imagine you would write 'sum' with this type signature:  sum :: [a] -> a
08:29:31 <mm_freak> how can you possibly implement this function?
08:29:47 <erisco> bitonic, if you template a function in C++, the compiler will generate a version of that function for each instantiation
08:30:21 <erisco> mm_freak, at what level are you asking for an implementation?
08:30:44 <mm_freak> erisco: just ideas…  give me an algorithm…  feel free to use words or express it in terms of "foreach" or something
08:31:05 <bitonic> erisco: oh right.  well that’s what I was talking about: it’s a useless comparison because template and typeclasses are different things.  type classes provide a signature that can be implemented for specific types.  those implementations are resolved at compile time and passed to the functions that need them.  C++ templates do something different: you define the methods bodies once and they generate type-specific code for you
08:31:36 <erisco> sum [] = 0   sum x:xs = x + (sum xs)
08:31:47 <mm_freak> erisco: that's a type error
08:32:02 <merijn> mm_freak: sum = head :D
08:32:08 <mm_freak> (a syntax error, too, but let's ignore that for now)
08:32:27 * hackagebot concraft-pl 0.2.0 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.2.0 (JakubWaszczuk)
08:32:29 <erisco> mm_freak, I don't see a syntax or type error
08:32:32 * aCube is too blind to spot the type error
08:32:36 <erisco> mm_freak, perhaps we should clarify that first
08:32:39 <merijn> No parens around x:xs
08:32:46 <bitonic> no type error
08:32:51 <mm_freak> erisco: (+) expects something of a class of types, it doesn't accept everything
08:32:58 <mm_freak> you could pass it Ints, Doubles, etc.
08:33:09 <mm_freak> but 'sum' does not know what 'a' is
08:33:19 <Chousuke> there is a type error unless you specify a constraint.
08:33:30 <erisco> mm_freak, granted that a type constraint would be required. Is Num sufficient?
08:33:31 <Chousuke> because you've specified the type beforehand to be too general
08:33:43 <geekosaur> Chousuke, defaulting
08:33:55 <mm_freak> erisco: for the sake of argument let's assume that there are no type classes
08:34:06 <mm_freak> erisco: how could you implement 'sum' with such a polymorphic type?
08:34:27 <geekosaur> :t let sum [] = 0; sum (x:xs) = x + sum xs in sum
08:34:28 <lambdabot> Num a => [a] -> a
08:34:37 <erisco> mm_freak, is this question any different than    sum a b = a + b ?
08:34:38 <mm_freak> guys, please don't spoil
08:34:58 <mm_freak> erisco: well, not that different actually, but it's a more useful function =)
08:35:09 * geekosaur was actually respindung to Chousuke but it loks like they need the same lesson :p
08:35:15 <erisco> well let's use the useless function
08:35:18 <mm_freak> hehe
08:35:23 <erisco> mm_freak, but still I don't understand the nature of your question
08:35:27 <armlesshobo> sum = (+)
08:35:38 <armlesshobo> > let sum = (+) in sum 1 3
08:35:40 <lambdabot>   4
08:35:40 <erisco> armlesshobo, very good but this isn't the point
08:35:50 <mm_freak> erisco: i'm explaining why type information at runtime is not required in haskell, but i'm taking a detour towards there
08:35:56 <mm_freak> erisco: ok, plus :: a -> a -> a
08:35:57 <armlesshobo> erisco: my bad, wasn't trying to participate in the discussion :\
08:36:10 <mm_freak> plus x y = x + y  -- obviously doesn't work because of the implicit assumption problem
08:36:25 <mm_freak> what could you do to make it work?  remember that you don't have type classes
08:36:57 <erisco> mm_freak, you have a framework for answering this question that I haven't the inkling of
08:37:00 <mm_freak> one solution is to make the type less polymorphic, but let's find another solution
08:37:11 <mm_freak> erisco: you can answer this in terms of C++ =)
08:37:40 <mm_freak> template <typename A> A plus(A x, A y) { return x + y; }  // this works in C++, but it won't in haskell
08:37:43 <erisco> well there isn't necessarily any problem in C++
08:37:44 <mm_freak> how can you solve it?
08:38:03 <mm_freak> … such that you don't need to know the type at run-time
08:38:12 <erisco> so you are asking how I can make the function  "plus a b = a + b"  valid in haskell?
08:38:21 <mm_freak> erisco: ok, let me ask a different question:  what's wrong with the function?
08:39:12 <erisco> mm_freak, the problem is that + is not defined for all types. Haskell won't allow such a definition because it won't work in all cases. However, C++ will allow such a thing as long as it is never actually used with types for which + is not defined
08:39:14 <armlesshobo> mm_freak: but if you go further (let me know if i'm assuming too much), each type would then need to override the + operatore (if not a native type)
08:39:49 <mm_freak> erisco: now in haskell it is actually allowed to pass polymorphic stuff to this function
08:40:01 <mm_freak> hence the C++ template instantiation is not only not needed, it isn't actually possible
08:40:17 <erisco> I don't understand what you've just said
08:40:25 <mm_freak> erisco: let me help you:  the function lacks something
08:40:40 <mm_freak> it doesn't know how to add numbers, it just assumes that it gets told how to do it
08:40:47 <mm_freak> what would you do to tell it explicitly?
08:41:07 <armlesshobo> what are we looking at? a paste?
08:41:13 <nh2> geekosaur: I managed to improve something! I did ln -s /usr/lib/x86.../libedit.a /usr/local/ghc/ghc-../lib/editline-.../ghc-.../libedit.a
08:41:32 <erisco> mm_freak, if I understand your question, then an approach would be to pass a third argument which is a function that will add the numbers
08:41:35 <mm_freak> armlesshobo: no, just an answer in works…  and if you know it, please don't spoil =)
08:41:35 <nh2> and the new error message is "...libedit.a: unknown symbol 'strlcpy'"
08:41:42 <armlesshobo> mm_freak: ;)
08:41:43 <mm_freak> erisco: exactly
08:41:53 <mm_freak> erisco: now that changes the type of the function
08:41:58 <erisco> agreed
08:42:03 <mm_freak> plus :: (a -> a -> a) -> a -> a -> a
08:42:07 <mm_freak> plus (+) x y = x + y
08:42:25 <mm_freak> now you have two arguments of type 'a' and a function that takes two arguments of type 'a'
08:42:28 <mm_freak> so this works
08:42:34 <Tehnix> I have no idea why i can't google my way to this, but, what is the way to convert a String to an Int?
08:42:34 <erisco> sure
08:42:34 <mm_freak> do you still need to check types at run-time?
08:42:38 <Tehnix> or float
08:42:48 <armlesshobo> Tehnix: read "12"::Int
08:42:57 <armlesshobo> > read "12"::Int
08:43:13 <lambdabot>   12
08:43:45 <armlesshobo> > read "12"::Float
08:43:47 <lambdabot>   12.0
08:44:08 <erisco> mm_freak, no, but I don't understand your point
08:44:21 <erisco> mm_freak, all you've required is the definition of an addition function for all types (that you wish to add)
08:44:38 <mm_freak> erisco: ok, no type-switching needed…  then the question arises:  do you actually need to instantiate?  or could you just use this function as it is for every type?
08:44:46 <erisco> mm_freak, which is duplicating routines in a nature not unlike template instantiation
08:44:55 <armlesshobo> mm_freak: i feel like something is missing
08:45:02 <armlesshobo> mm_freak: i'm gonna privmsg you
08:45:11 <erisco> mm_freak, that function, yes, but the functions you need to pass to your polymorphic routine still have to be created
08:45:28 <erisco> mm_freak, all this seems to have done is to offload the problem, not get rid of it
08:45:45 <mm_freak> erisco: obviously every function must be compiled to code, but not to multiple instantiations
08:45:59 <erisco> yes, that is precisely what ends up happening
08:46:11 <mm_freak> erisco: because this "no assumptions!"-rule holds for everything in haskell
08:46:15 <mm_freak> not just for the functions you define
08:46:22 <Chousuke> what happens if you use a templated add twice for the same types in C++?
08:46:59 <Jaak> it will use the same instantiation
08:47:01 <hiptobecubic> Chousuke, it doesn't generate a new function for each use. Just per type
08:47:02 <erisco> mm_freak, in both cases you end up with routines for each type
08:47:07 <Chousuke> right.
08:47:12 <mm_freak> erisco: nope
08:47:17 <mm_freak> erisco: check the compiler output =)
08:47:18 <erisco> mm_freak, you've described exactly this
08:47:25 <hiptobecubic> Having read all this, I also don't see how erisco is wrong here.
08:48:00 <mm_freak> erisco: if you turn off optimizations you will find that every function is compiled exactly to one instantiation
08:48:08 <mm_freak> erisco: the type system makes sure that this is sound
08:48:16 <hiptobecubic> C++ can't codify that the type needs to have operator+() defined, but it still requires it.
08:48:41 <Jaak> in fact, if you implement recursive Fibonacci with template metaprogramming in C++ you wont get exponential blowup
08:48:44 <erisco> mm_freak, I agree that the 'plus' function will have only one instance in the executable, sure
08:48:46 <hiptobecubic> You can't compile a C++ program that wants to use that function with a type that has no operator+ method.
08:48:59 <armlesshobo> typeclass would be necessary then, if you're not going with 'native' types in Num
08:49:09 <erisco> mm_freak, but as I am saying, the addition functions you pass to 'plus' must still exist for each type, so this has only offloaded the problem
08:49:36 <mm_freak> erisco: certainly there are primitive functions for each primitive type, but that's about it
08:49:39 <erisco> mm_freak, but I do agree this approach means you do not require runtime type checks
08:49:50 <hiptobecubic> they go in the class definition as operator+, similar to the typeclass instantiation for the type, i think.
08:50:14 <hiptobecubic> And after the compiler agrees that everything is ok, you don't need to typecheck either
08:50:17 <mm_freak> erisco: think of a game with many object types…  if you write it in haskell it will not ask for the object type at run-time to decide what to do with it
08:51:07 <mm_freak> erisco: neither will it instantiate multiple codes for the same function, even if it is polymorphic in the object type
08:51:26 <solrize_> ok i can temporarily test out a 16 core e5 server with 256gb of ram and 3.2tb of super fast (pcie interface) ssd.. any suggestions?
08:51:33 <mm_freak> except for efficiency or inlining…  there is no fundamental reason to do that
08:51:39 <hiptobecubic> I think the "multiple codes" was referring to the object method definitions and typeclass instantiations.
08:51:51 <hiptobecubic> You have to implement Num for each type that's going to use (+)
08:52:16 <erisco> mm_freak, yes, I agree, but it doesn't mean that routines for each type do not exist. It just means the code that differs for each type has been extracted. This is much like the thin template pattern in C++
08:52:37 <mm_freak> hiptobecubic: that's really just sugar for passing different monomorphic functions to a polymorphic higher order function
08:52:52 <hiptobecubic> mm_freak, sure.
08:53:17 <hiptobecubic> so what's the argument here? that c++ doesn't have the latter and makes up for it by generating monomorphic higher order functions for each case it needs?
08:53:22 <erisco> mm_freak, in my view what you've described minimizes the amount of extra code required, whereas a naive C++ approach would duplicate more (but this does have its own advantages of locality and no jumps or function calls required)
08:53:53 <mm_freak> hiptobecubic: yes, and that C++ fundamentally can't express certain functions that haskell can express, still without run-time type checks or multiple instantiation
08:53:56 <Entroacceptor> Tehnix: but beware of
08:54:02 <Entroacceptor> > read "hello"::Int
08:54:04 <lambdabot>   *Exception: Prelude.read: no parse
08:54:13 <mm_freak> that shows that there is a semantic difference between C++ templates and haskell polymorphism
08:54:24 <mm_freak> i.e. it's not just an implementation detail
08:54:43 <hiptobecubic> mm_freak, "or multiple instantiation" being what i just said?
08:54:45 <Tehnix> Entroacceptor: does read return an IO Int or just an Int?
08:54:54 <mm_freak> hiptobecubic: yes
08:54:55 <ab9rf> read is not in IO
08:54:57 <Entroacceptor> :t read ::Int
08:54:58 <lambdabot>     Couldn't match expected type `Int' with actual type `String -> a0'
08:54:58 <lambdabot>     In the expression: read :: Int
08:55:01 <ab9rf> read just parses strings
08:55:08 <Entroacceptor> :t read
08:55:10 <lambdabot> Read a => String -> a
08:55:38 <aCube> Is there a package providing Arbitrary instances for the array package? I think those are needed quite frequently, so I'm asking here
08:55:52 <Entroacceptor> there's reads or readMay
08:56:00 <Tehnix> hmm, I'm trying to use read on a String (that was an IO String, but I use it in do-notation with <-), doing "priceInFloat <- read curPrice::Float" throws "Couldn't match expected type `IO t0' with actual type `Float'"
08:56:06 <hiptobecubic> mm_freak, Well I clearly agree that it's implemented differently, but how do we arrive at a difference in semantics? What kind of function can C++ not express? I don't mean literally, I mean functionally. What kind of function can C++ not perfectly mimic.
08:56:31 <Tehnix> don't know what exactly is wrong with that (if that was enough info to go on)
08:57:01 <aCube> Tehnix: the ::Float must be :: IO Float
08:57:04 <erisco> mm_freak, thanks for the discussion, it has been enlightening. I am going for lunch at this time, so we'll have to talk later.
08:57:20 <Tehnix> aCube: ahhh
08:57:30 <ab9rf> Tehnix: that's because read doesn't genereate an IO object
08:57:34 <aCube> Tehnix: It specifies the type on the right side of the <-, so the Float is still in IO
08:57:49 <aCube> ab9rf: oh, that too :P
08:58:10 <ab9rf> you can't do read str :: IO Float
08:58:15 <ab9rf> try it :)
08:59:04 <aCube> > read "3" :: IO Fload
08:59:06 <lambdabot>   Not in scope: type constructor or class `Fload'
08:59:06 <lambdabot>  Perhaps you meant `Float' ...
08:59:08 <aCube> > read "3" :: IO Float
08:59:10 <lambdabot>   No instance for (GHC.Read.Read (GHC.Types.IO GHC.Types.Float))
08:59:10 <lambdabot>    arising f...
08:59:22 <aCube> > read "3" :: Float
08:59:24 <lambdabot>   3.0
08:59:40 <Tehnix> hmmm, I guess my question still stands then?
08:59:40 <mm_freak> hiptobecubic: turing-completeness aside, this function can't be expressed in C++ the way it can in haskell:  getTwoRandoms :: (Monad m) => (forall a. (Random a) => m a) -> m (Int, Integer)
08:59:44 <armlesshobo> aCube: there needs to be an instance of Read defined for (IO Float)
08:59:55 <ab9rf> which would be difficult to do
08:59:56 <mm_freak> hiptobecubic: getTwoRandoms getR = liftM2 (,) getR getR
09:00:19 <mm_freak> erisco: sure, have fun =)
09:00:21 <Entroacceptor> Tehnix: stuff inside a  "do" block is special, to just answer your question "let priceInFloat = read curPrice"
09:00:36 <Entroacceptor> I take you're in the very beginning of learning?
09:00:47 <Entroacceptor> be sure to checkout LYAH
09:00:49 <Entroacceptor> !lyah
09:00:54 <mm_freak> hiptobecubic: to express the same in C++ you would actually step away from parametric polymorphism and use subtype polymorphism instead
09:00:55 <typoclass> @where lyah
09:00:55 <lambdabot> http://www.learnyouahaskell.com/
09:01:09 <hiptobecubic> mm_freak, hmmm. have to digest that.
09:01:10 <Chousuke> :t fmap (read :: (String -> Float)) (return "3")
09:01:12 <lambdabot> (Monad f, Functor f) => f Float
09:01:20 <mm_freak> hiptobecubic: or you would actually take two monomorphic functions instead of a single polymorphic function
09:01:41 <armlesshobo> mm_freak: which would still require you to override the operator+()
09:01:47 <mm_freak> in other words, C++'s template system, being a macro language and not a real type system, lacks higher rank types
09:01:50 <armlesshobo> for that subtype
09:02:03 <mm_freak> armlesshobo: we have a different example now =)
09:02:11 <Tehnix> Entroacceptor: ah, thanks. Yeah, also, I'm coming from an imperative background. It's quite hard to see the difference sometimes between using let and using the <- :/
09:02:35 <Tehnix> in this specific case
09:02:41 <mm_freak> Tehnix: (x :: A) <- (c :: M A)
09:02:51 <mm_freak> Tehnix: when you say "=" you say "equal", so the types can't be different
09:02:57 <mm_freak> let (x :: A) = (y :: A)
09:02:58 <hiptobecubic> { getTwoRandoms<getR>(); } template <typename f> getTwoRandoms() { return std::pair<int, MyInteger>(f(), f()); }   ?
09:03:33 <mm_freak> Tehnix: it helps to remember that "=" in haskell uncondinitionally means "is equal to"
09:04:03 <Tehnix> mm_freak: ah :) and the <- kindda "pulls" it into the monad?
09:04:13 <Entroacceptor> no, the <- pulls it out :)
09:04:17 <armlesshobo> Tehnix: we prefer the term "binds"
09:04:24 <armlesshobo> :)
09:04:28 <Tehnix> binds it out of the monad?
09:04:52 <mm_freak> Tehnix: a monad is a type, like IO…  you can't go into or out of a monad…  a value is either monadic or it isn't…  however, "<-" allows you to give a name to the result of a monadic value
09:04:58 <mm_freak> Tehnix: x <- getLine
09:05:23 <mm_freak> getLine is still an IO String, and x just gives a name to its result, so that you can refer to it in later monadic actions
09:05:26 <Tehnix> oh, that way, so binds to a name, so to speak
09:05:48 <mm_freak> no, "bind" is actually something very specific:  (>>=)
09:06:06 <Tehnix> oh
09:06:20 <mm_freak> but don't go there now…  it's fine to understand do-notation first, where you don't actually 'see' the binds =)
09:06:28 <mm_freak> they are hidden below a layer of syntactic sugar
09:06:29 <armlesshobo> getLine >>= \x -> return $ (read x::Int * 2)
09:06:36 <limo> Hello everyone
09:06:40 <armlesshobo> getLine >>= \x -> return $ (read x::Int) * 2
09:06:49 <Eduard_Munteanu> limo: hi
09:06:51 <limo> I'm interested in an arbitrary precision type, is such a thing available in Haskell?
09:06:56 <Tehnix> mm_freak: i've heard about that :)
09:07:09 <typoclass> limo: yes, it's called Integer and imported by default (via Prelude)
09:07:12 <mm_freak> Tehnix: when you write "do x <- getLine; putStrLn x" it's really the same as writing "getLine >>= putStrLn"
09:07:16 <limo> When I enter a number on the REPL, is that withouch precision
09:07:23 <limo> I see that in the default namespace.
09:07:27 <armlesshobo> @type (>>=)
09:07:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:07:38 <limo> So, how could I get arbitrary decimal points as well
09:07:53 <donri> hm if return and bind are the only operations for a monad, would it be the identity monad? i mean 'return' is the only way to construct a value of the type
09:07:55 <aCube> @ty Ratio
09:07:56 <lambdabot> Not in scope: data constructor `Ratio'
09:08:05 <mm_freak> limo: not sure if i understand your question, but either use decimal notation or add a type signature
09:08:06 <armlesshobo> limo: do a :t <number>
09:08:08 <limo> If I try 0.003 == 0.00300000000000000000000000000000000001 it returns a true
09:08:10 <mm_freak> > 15 :: Double
09:08:12 <lambdabot>   15.0
09:08:21 <armlesshobo> @type 15.0
09:08:23 <limo> Ok, what signature should I use for arbitrary precision
09:08:23 <lambdabot> Fractional a => a
09:08:27 <mm_freak> limo: floating point is not exact
09:08:32 <limo> Fractional then?
09:08:35 <mm_freak> limo: there are various possibilities
09:08:38 <aCube> limo: Ratio Integer
09:08:41 <mm_freak> limo: there is Rational for example
09:08:42 <bitonic> limo: if rational numbers are enough for you, Rational
09:08:57 <mm_freak> > 0.003 == (0.00300000000000000000000000000000000001 :: Rational)
09:08:58 <limo> Yes, I don't have transcedentals or something like that
09:08:58 <lambdabot>   False
09:09:12 <tromp_> > 0.003 == (0.00300000000000000000000000000000000001::CReal)
09:09:13 <bitonic> limo: you don’t have irrationals
09:09:15 <lambdabot>   False
09:09:18 <Javran> > 10 % 1 + 10 % 2
09:09:20 <lambdabot>   Not in scope: `%'
09:09:20 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)Not in...
09:09:40 <mm_freak> actually we have irrationals
09:09:42 <Javran> > 10 `R.%` 1 + 10 `R.%`2
09:09:44 <lambdabot>   <hint>:1:5: parse error on input `R.%'
09:09:50 <bitonic> mm_freak: with Rational?  I doubt it :)
09:09:51 <limo> WHere is the Rational import located?
09:09:55 <aCube> > sqrt 2 :: Rational
09:09:57 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
09:09:57 <lambdabot>    arising from a us...
09:09:57 <typoclass> limo: the thing with float and double are that they're inherently not arbitrary-precision, as far as i know
09:09:59 <bitonic> limo: it’s in the Prelude
09:10:07 <limo> OK
09:10:15 <mm_freak> > sin (pi/4) == (sqrt 2 / 2 :: CReal)
09:10:17 <lambdabot>   True
09:10:30 <tromp_> > sqrt 2 :: CReal
09:10:31 <mm_freak> CReal is either exact or does not terminate
09:10:33 <lambdabot>   1.4142135623730950488016887242096980785697
09:10:49 <bitonic> mm_freak: CReal is exact, which means it doesn’t terminating
09:10:56 <bitonic> *it’s not terminating
09:11:03 <limo> Is there any type where 0.0 !== 0.00?
09:11:04 <limo> Is there any type where 0.0 !== 0.00
09:11:09 <mm_freak> bitonic: i mean, the result is either exact or bottom
09:11:17 <mm_freak> limo: since they are the same values no =)
09:11:38 <bitonic> mm_freak: well but you make it sound like it’s a shortcoming of CReal—it’s a shortcoming of real numbers :P
09:11:38 <limo> Sorry about that - basically I'm trying to study the default behavior of different implementations of arbitrary precinion types in different programming languages.
09:11:43 <mm_freak> limo: saying "0.0" in haskell really is the same as saying "fromRational (0 % 1)"
09:12:03 <mm_freak> and both 0.0 and 0.00 will be the same fromRational (0 % 1)
09:12:21 <limo> I see. So for instance, in Java a BigDecimal number consists of a scale and the data. When both are not matched it does not equal another object of the same type.
09:12:36 <ab9rf> limo: that's becauase java is lame :)
09:12:38 <limo> So for instance BigDecimal(0.00) will not equal BigDecimal(0.0)
09:12:41 <limo> Roger that!
09:13:02 <mm_freak> limo: java is broken in many ways…  haskell usually does what you would expect
09:13:11 <ab9rf> limo: that's because == in java on objects is referential equality and cannot be overridden
09:13:21 <luite> limo: whoah that surprises me
09:13:27 <limo> no ab9rf, I'm not talking about referential equality
09:13:29 <ab9rf> limo: == in java is never useful for testing equality
09:13:40 <typoclass> limo: well, floats and doubles are an ieee standard, so if two programming languages conform very well to the standard, there should be no difference in behavior. but floats and doubles of course aren't arbitrary-precision
09:13:54 <ab9rf> limo: if .equal is false i that case then the class is misimplemented
09:13:59 <mm_freak> ab9rf: limo says that java's BigDecimal makes a difference between 0 * 2^(-1) and 0 * 2^(-2)
09:14:14 <mm_freak> i.e. it doesn't normalize before comparison
09:14:26 <limo> We use scala for all of our development, and since it's BigDecimal classes are basically thin wrappers around the default Java implementation I found this a bit odd. Other than that, Scala still rocks my pants.
09:14:27 <mm_freak> i don't know if that's true, but i wouldn't be surprised =)
09:14:27 <ab9rf> mm_freak: or even special case a zero mantissa
09:14:49 <bitonic> typoclass: floats (single and double precision) are usually implemented in the processor so no need for languages to conform to standards.  I guess languages differ on NaN behaviour sometimes
09:15:00 <mm_freak> to be fair i don't like scala either =)
09:15:16 <limo> I'm in your house, so I won't object.
09:15:21 <ab9rf> bitonic: see also php's bizarre behavior on comparisons involving NaN :)
09:15:27 <mm_freak> limo: feel free to object
09:15:45 <limo> I love the NaNNaNNaNNaNNaNNaNNaNNaNNaN BatMan!
09:15:49 <donri> java: feel free to object
09:15:54 <bitonic> limo: that works in Scala too
09:15:57 <bitonic> any2string ftw
09:16:07 <limo> Roger that bitonic.
09:16:23 <bitonic> Scala is a mess, but a fun mess anyway
09:16:28 <limo> They actually match, I must be taking crazy pills. BigDecimal("0.00") == BigDecimal("0.000")
09:17:55 <limo> OK, so in the future, you can at least remember one bit of trivia: In Java, new java.math.BigDecimal("0.0") equals new java.math.BigDecimal("0.00") returns false :)
09:18:45 <tdammers> does BigDecimal keep track of its precision?
09:18:52 <limo> Yes.
09:18:53 <typoclass> limo: oh. so 0.00 == 0.000, but 0.0 != 0.00 ?
09:18:58 <donri> it takes a string? o_O
09:19:02 <tdammers> if so, then it makes sense that they're different, in a weird way
09:19:06 <bitonic> BigDecimal is simply a number + how many digits are after the ., iirc
09:19:06 <limo> No, typoclass
09:19:20 <mm_freak> btw, "BigDecimal" suggests that it's a "big" decimal representation…  so how big is "big" actually?
09:19:24 <limo> bitonic I think it's represented by an array of bytes internally so I guess it makes sense.
09:19:31 <limo> I don't think it's limited.
09:19:37 <tdammers> they're not completely equal because they have different precisions, woul dbe my guess
09:19:38 <limo> At least BigInt isn't.
09:19:51 <limo> Yes, I already confirmed that they compare scales as well.
09:19:58 <bitonic> limo: according to the docs for opejdk 7, the scale is a 32bit integer.  so it is somewhat limited, although it practically isn’t
09:20:01 <mm_freak> limo: it isn't limited?  what happens when you calculate sqrt(2)?
09:20:05 <impostor-tac> limo:
09:20:06 <impostor-tac> > (concat . replicate 8 $ show (0.0 / 0.0)) ++ " batman"
09:20:08 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaN batman"
09:20:39 <mm_freak> > cycle (show (0 / 0))
09:20:41 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNa...
09:20:42 <typoclass> limo: maybe it would be helpful to track the precision separately? as in, "i've got the number 7, and it's accurate to 6 decimal places"
09:20:51 <limo> mm_freak I wouldn't know. My guess is that the decimals themselves are limited.
09:21:13 <limo> I know tha the integer part can go on for millions...
09:21:20 <typoclass> > toRational (0/0) -- mm_freak: yeah, but check out my party trick
09:21:22 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
09:21:23 <bitonic> limo, mm_freak: you can make it arbitrarly big, but it still needs to be a computed integer
09:21:40 <bitonic> (a BigInteger)
09:22:04 <tdammers> my guess would be that sqrt() isn't defined for BigDecimal directly; you'd have to use floats (at least internally), and then convert back to BigDecimal, at which point you'd have to pick a precision
09:22:17 <limo> OK, guys was nice meeting you and now I'm a proud owner of a GHCi icon on my desktop
09:22:24 <limo> Later, and have fun.
09:22:30 <limo> <and by fun I mean Scala :>
09:22:34 <bitonic> I agree with tdammers
09:22:45 <ab9rf> tdammers: it's not that hard to write an infinite-precision sqrt
09:22:48 <bitonic> limo: every time you implicit a kitten dies
09:22:50 <bitonic> too late
09:22:52 <aCube> > toRational (0/0)
09:22:54 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
09:22:57 <mm_freak> typoclass: i know that trick =)
09:23:00 <ab9rf> hhah
09:23:00 <aCube> Oh, not random :(
09:23:06 <tdammers> ab9rf: no, but representing it as a BigDecimal is impossible
09:23:11 <tdammers> at least the irrational results
09:23:14 <aCube> @src toRational
09:23:15 <lambdabot> Source not found. That's something I cannot allow to happen.
09:23:29 <aCube> @ty toRational
09:23:30 <lambdabot> Real a => a -> Rational
09:23:37 <ab9rf> tdammers: could be, i don't remember how bigdecimal works
09:23:38 <bitonic> you can get arbitrarly close to it using a BigDecimal, but you won’t be able to represent ‘the real thing’
09:23:46 <aCube> @ty toRational `asAppliedTo` (0/0)
09:23:47 <lambdabot> (Fractional t, Real t) => t -> Rational
09:24:04 <typoclass> @remember limo OK, guys was nice meeting you and now I'm a proud owner of a GHCi icon on my desktop
09:24:05 <lambdabot> I will never forget.
09:24:37 <tdammers> ab9rf: usually one bigint for the mantissa and one for the exponent (base-10, hence the *deci* part in "decimal")
09:25:41 <tdammers> well, not technically mantissa and exponent, but you get the point
09:26:06 <tdammers> a bigint, and then another one to indicate how many decimal places are supposed to be after the .
09:27:02 <tdammers> you can cheat and use a 64-bit int for the decimal-places indicator, gambling that numbers this large would exceed the available RAM anyway
09:27:27 <bitonic> tdammers: it’s a reasonable gamble
09:27:39 <bitonic> similar gambles are made by big integers
09:27:45 <bitonic> for the exponent
09:28:38 <bitonic> I wouldn’t even call it a gamble really :P
09:28:49 <tdammers> one could argue that it's actually the *same* gamble
09:29:23 <bitonic> tdammers: different bases
09:29:28 <bitonic> but yeah
09:30:50 <tdammers> anyway, with a flat-memory 64-bit address space, 64 decimal digits are not enough to represent the largest possible bigint
09:31:50 <tdammers> but I doubt any OS would let you go anywhere near such a massive chunk of RAM
09:33:31 <ab9rf> i'm not even sure what the prefix is for that much ram
09:34:19 <ab9rf> ah, i guess 2^64 is 16 exabytes
09:42:30 <Chousuke> when dealing with numbers that big you'd use a specialised library for it anyway.
09:42:33 <aCube> How would one write shrink for the arbitrary instance for IArray?
09:43:08 <merijn> Use the one for [] and fromList?
09:43:19 <aCube> @ty listArray
09:43:21 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
09:43:29 <aCube> @ty fromList
09:43:30 <lambdabot>     Not in scope: `fromList'
09:43:31 <lambdabot>     Perhaps you meant one of these:
09:43:31 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
09:43:48 <aCube> there is no fromList for array, afaik ?
09:45:12 <merijn> oh, listArray then
09:46:21 <aCube> but the I would have to shrink the bounds too ?
09:52:48 <crdueck_> why does GHC not precompute this numeric constant expression (3 - sqrt 3) / 6 :: Float. It's obviously contant, I'd expect its value (0.21132487) to be inlined in the produced Core, but instead the operations are performed at runtime. I gained a %10 speedup in my code by inlining the result myself, but GHC should be performing this optimization, correct?
09:53:41 <mel-> hi
09:54:11 <crdueck_> even compiling with -fllvm -optlo-O3, the speedup from manually inlining remains.
09:54:27 <mel-> crdueck_: that is interesting, maybe you should file a bug report?
09:54:46 <mauke> workaround: TH
09:54:56 <mel-> or... welll... you could maybe force it to be strict.
09:56:30 <mauke> I wonder what would happen if you gave it a (global?) name
09:56:32 <crdueck_> mel-: adding strictness doesnt help unfortunately
09:57:40 <Spockz> has anyone setup distcc with GHC?
09:57:44 <crdueck_> mauke: i'd like to avoid TH if possible (and this should be possible). also, even having the single expression f = (3 - sqrt 3) / 6 :: Float in a file by itself, its still not inlined
09:57:54 <Spockz> and did it improve performance?
09:58:20 <mauke> crdueck_: but does it get recomputed every time?
09:58:37 <__xc> > toRational pi
09:58:39 <lambdabot>   884279719003555 % 281474976710656
09:59:24 <crdueck_> mauke: i assume not. but I'm going from 0.96s -> 0.86s by manually inlining. so something strange is going on
09:59:45 <__xc> pi -  884279719003555 % 281474976710656
09:59:50 <__xc> > pi -  884279719003555 % 281474976710656
09:59:52 <lambdabot>   Not in scope: `%'
09:59:52 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
10:00:15 <ab9rf> pi -  884279719003555 % 281474976710656
10:00:17 <ab9rf> oops
10:00:23 <ab9rf> > pi -  884279719003555 R.% 281474976710656
10:00:25 <lambdabot>   No instance for (GHC.Float.Floating (GHC.Real.Ratio a0))
10:00:26 <lambdabot>    arising from a ...
10:00:55 <__xc> > pi -  884279719003555 / 281474976710656
10:00:57 <lambdabot>   0.0
10:01:18 <parcs> crdueck: i don't think ghc performs strength reduction on the 'sqrt(3)' term
10:01:45 <__xc> >( pi*281474976710656 -  884279719003555) / 281474976710656
10:01:57 <__xc> > ( pi*281474976710656 -  884279719003555) / 281474976710656
10:01:59 <lambdabot>   0.0
10:02:34 * hackagebot smtLib 1.0.3 - A library for working with the SMTLIB format.  http://hackage.haskell.org/package/smtLib-1.0.3 (IavorDiatchki)
10:03:17 <mm_freak> given ByteString's Builder is there a reason to use blaze-builder?
10:07:24 <parcs> crdueck: perhaps file a ticket about implementing this optimization
10:11:15 <mm_freak> ok yes, blaze-builder is faster
10:15:07 <parcs> > (3 - sqrt 3) / 6
10:15:08 <lambdabot>   0.21132486540518713
10:18:45 <donri> mm_freak: and you need a recent (latest?) ghc for bytestring builder ...
10:19:02 <donri> mm_freak: odd that blaze if faster though, it's pretty much the same code?
10:22:02 <parcs> > toRational $ sqrt (-3)
10:22:03 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
10:22:15 <parcs> > fromRational $ toRational $ sqrt (-3)
10:22:17 <lambdabot>   -Infinity
10:22:27 <parcs> > sqrt (-3)
10:22:29 <lambdabot>   NaN
10:22:50 <RichyB> (toRational NaN) does not raise? Huh.
10:26:27 <parcs> should it?
10:27:30 <geekosaur> NaN is specifically a floating point thing
10:27:40 <geekosaur> toRational is a meaningless operation on it
10:27:43 <typoclass> RichyB: it might be a bug. i don't see how toRational can reasonably come up with a number for NaN
10:28:30 <elliott> > toRational NaN
10:28:32 <lambdabot>   Not in scope: data constructor `NaN'
10:28:34 <elliott> oh, right.
10:29:14 <typoclass> > 42 `div` 0
10:29:16 <lambdabot>   *Exception: divide by zero
10:29:36 <oconnor0> > 0/0
10:29:38 <lambdabot>   NaN
10:29:56 <typoclass> ^^ i think throwing is the right thing to do, as opposed to coming up with some weird number. same for toRational NaN
10:30:42 <RichyB> > fromRational (0 % 0)
10:30:43 <lambdabot>   Not in scope: `%'
10:30:44 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
10:30:48 <RichyB> > fromRational (0 R.% 0)
10:30:50 <lambdabot>   *Exception: Ratio.%: zero denominator
10:30:55 <RichyB> Aww.
10:31:44 <typoclass> RichyB: NaN is a float thing, i don't think Ratio has an equivalent
10:31:51 <oconnor0> > denominator $ toRational $ 0/0
10:31:53 <lambdabot>   1
10:33:33 <RichyB> typoclass: I was wondering if "0/0" would be a good-enough representation of NaN.
10:33:48 <RichyB> 0.0f/0.0f is *a* NaN, after all.
10:33:59 <armlesshobo> X is also NaN
10:34:00 <armlesshobo> :P
10:34:44 <ion> Why would we want a representation of NaN in Rational?
10:34:57 <typoclass> ion: beats me :)
10:35:23 <ion> Let’s also have a representation of NaS in String.
10:35:52 <erisco> it seems that Traversable is suitable for any structure which can be mapped, but is it possible to deconstruct Traversable if you wanted to do your own iteration?
10:36:36 <erisco> um, specifically, I only want to traverse part of it, just as 'take' only looks at a prefix of a list
10:36:43 <typoclass> ion: a library for loading jpegs should have NaC (not a cat)
10:37:34 * hackagebot data-inttrie 0.0.9 - A lazy, infinite trie of integers.  http://hackage.haskell.org/package/data-inttrie-0.0.9 (LukePalmer)
10:38:49 <erisco> is there a different type class which describes any structure which can be constructed like a list?
10:38:55 <mm_freak> donri: with one difference:  blaze-builder doesn't require me to go through lazy ByteString
10:39:06 <giogadi> howdy!
10:39:13 <mm_freak> i can go to strict ByteString directly, which is probably the reason for the better performance
10:39:19 <giogadi> anyone here experienced with FRP or arrow notation?
10:39:21 <erisco> or is a list universally used in such a case?
10:39:28 <monochrom> there is a ListLike type class, but I forgot where to find it
10:39:31 <mm_freak> giogadi: speak =)
10:39:49 <giogadi> mm_freak: I'm having a lot of trouble grasping recursive binding in arrow notation
10:40:02 <mm_freak> erisco: lists can be constructed in many ways…  for example there is cons (:), then there is Monoid and there is Unfold, and …
10:40:12 <giogadi> it makes literally zero sense to me. is there a tutorial that does a good job of explaining it?
10:40:33 <mm_freak> giogadi: i've written an arrow tutorial, but ArrowLoop is not in there yet
10:40:54 <erisco> mm_freak, so, for example, how would you generalize 'take' to work on any such type?
10:41:06 <erisco> mm_freak, I was presuming there'd be a type class
10:41:31 <mm_freak> erisco: that's not constructing, but destructing…  you basically need a type class for the 'uncons' operation
10:41:48 <giogadi> mm_freak: so there aren't any other resources you know of? I'm finding the lack of good resources for FRP really depressing
10:41:59 <mm_freak> giogadi: which FRP framework?
10:42:02 <ion> > Node 4 [Node 5 [Node 6 [], Node 7 []], Node 8 []] & taking 3 traverse *~ 100 -- erisco
10:42:03 <giogadi> yampa
10:42:05 <lambdabot>   Node {rootLabel = 400, subForest = [Node {rootLabel = 500, subForest = [Nod...
10:42:05 <typoclass> mm_freak: do you have a link on Unfold? google found only unfoldr
10:42:18 <ion> > [0..] & taking 5 traverse *~ 100
10:42:20 <lambdabot>   [0,100,200,300,400,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,2...
10:42:25 <mm_freak> giogadi: there is little to no documentation on yampa, but i'm actually the author of netwire =)
10:42:54 <mm_freak> giogadi: since yampa and netwire share the basic idea i can probably help you
10:43:03 <giogadi> mm_freak: ah, that's super helpful then!
10:43:24 <erisco> >:t taking
10:43:27 <erisco> :t taking
10:43:28 <mm_freak> typoclass: i don't know of any predefined type class there
10:43:29 <lambdabot> (Applicative f, Conjoined p) => Int -> Over p (Control.Lens.Internal.Bazaar.BazaarT p f a a) s t a a -> Over p f s t a a
10:43:41 <giogadi> mm_freak: I just can't quite grasp the insight that explains where the recursion "ends" so to speak
10:43:49 <otters> lens law #1: the implementation must be shorter than the type
10:44:00 <mm_freak> giogadi: it doesn't end
10:44:05 <merijn> erisco: taking is a lens thing, the types tend to be...somewhat intimidating
10:44:13 <mm_freak> a signal network has no natural "stopping point"
10:44:21 <typoclass> mm_freak: ok thanks :-) i've wondered the other day if there's "something like Data.Foldable in reverse"
10:44:26 <giogadi> mm_freak: I think I understand that, but where does the "first" value come from?
10:44:59 <monochrom> giogadi: I'm wondering if MonadFix helps you understand ArrowLoop. http://www.haskell.org/haskellwiki/MonadFix
10:45:01 <typoclass> @remember otters lens law #1: the implementation must be shorter than the type
10:45:01 <lambdabot> I will remember.
10:45:08 <mm_freak> giogadi: depends…  if you open the haddock documentation for netwire for most "wires" (netwire's SF equivalent) you will find a comment like "Depends: previous instant"
10:45:43 <mm_freak> giogadi: this basically means:  the output value depends on the input value in the previous instant, which in most cases means that the first value is passed as an argument
10:45:47 <monochrom> but the summary is "it is not recursion"
10:45:53 <mm_freak> giogadi: let's take 'integral' as an example
10:45:58 <giogadi> mm_freak: ah, I see. I'm gonna go pore over the netwire docs and see if things make more sense :) I'm really excited about the idea of FRP but so many of the resources seem to require knowledge of it already. kinda recursive actually
10:46:00 <monochrom> well, not recursive execution
10:46:05 <mm_freak> giogadi: x <- integral -< x
10:46:11 <giogadi> mm_freak: ah, one quick question on that
10:46:32 <mm_freak> giogadi: there is actually an argument to 'integral' which yampa hides from you:  the starting value (the integration constant)…  it simply starts at 0
10:46:36 <giogadi> mm_freak: does 'integral' only integrate the time step, or does it "accumulate" the integration from t=0?
10:46:42 <giogadi> ooooh ok
10:46:54 <mm_freak> giogadi: time always starts at 0 for yampa
10:47:01 <mm_freak> you notice this when you switch
10:47:05 <aCube> How can I write the shrink method required for an Arbitrary instance (QuickCheck) for IArray?
10:47:20 <mm_freak> aCube: it's optional
10:48:09 <aCube> mm_freak: Regardless of that, Is there a good implementation for shrink in this case?
10:48:14 <mm_freak> giogadi: read the Control.Wire module's documentation…  it has a tutorial
10:48:31 <giogadi> mm_freak: will do! thanks so much for the help
10:48:52 <mm_freak> giogadi: you're welcome, but i didn't actually answer your question yet =)
10:48:53 <giogadi> mm_freak: so if I'd like to use FRP for writing a physical simulation, you'd recommend using netwire?
10:49:01 <mm_freak> giogadi: yes
10:49:08 <Hannibal_Smith> Is it possible to don't use IO monad, using only an reactive enviroment?
10:49:09 <giogadi> mm_freak: pointing me in the right direction is more than enough help
10:49:13 <mm_freak> aCube: i don't know…  shrink beats me =)
10:49:46 <mm_freak> giogadi: there is nowhere i can point you really, because i'm not aware of any real documentation on value recursion in FRP
10:50:07 <giogadi> mm_freak: this monadfix thing that monochrom linked me to seems very promising
10:50:23 <giogadi> mm_freak: he was right, it's the idea of value recursion specifically that's throwing me for a loop
10:50:25 <mm_freak> giogadi: yes, ArrowLoop is basically the MonadFix equivalent for arrows
10:50:36 <giogadi> pun not intended
10:50:49 <mm_freak> Hannibal_Smith: well, a pure reactive environment is just a calculation =)
10:50:53 <mm_freak> giogadi: hehe
10:51:19 <mm_freak> giogadi: but it's not that difficult actually:  rec x <- c1 -< y; y <- c2 -< z
10:51:40 <mm_freak> you notice that regularly y wouldn't be available in the first computation
10:51:45 <giogadi> mm_freak: so does the 'rec' refer to the entire line, or just the 'x'?
10:51:57 <giogadi> mm_freak: right
10:52:07 <mm_freak> rec makes it available because c2's output doesn't actually depend on the input in this instant…  it only depends on the previous instant
10:52:25 <mm_freak> think of a sum accumulator:  x <- sum x0 -< dx
10:52:33 <mm_freak> the first output is x0 regardless of dx
10:52:45 <mm_freak> the next output is x0 + dx
10:52:56 <giogadi> mm_freak: ooooooh, I think I see
10:53:12 <mm_freak> that's the basic idea of ArrowLoop in FRP
10:53:20 <giogadi> mm_freak: in your first example, if I changed the second line to "y <- c2 -< x", would that be an error?
10:53:45 <mm_freak> one thing to keep in mind is that understanding ArrowLoop really needs you to think of time as discrete, but it's find to think of instants being infinitesimally small
10:54:02 <mm_freak> giogadi: no, that's the regular flow of values
10:54:02 <giogadi> mm_freak: I'm comfortable with discrete time I think
10:54:57 <mm_freak> (where "instant" = "time step")
10:55:47 <__xc> list comprehensions are a bit less powerful than list monads right?
10:56:03 <tromp_> how so less?
10:56:04 <Taneb> __xc, I think they're equivalent
10:56:08 <mm_freak> giogadi: if you use netwire the rule of thumb is:  if the documentation says "depends: current instant", then you can't use value recursion, otherwise you can
10:56:16 <__xc> wait et me try to fiond you a case
10:56:37 <mm_freak> __xc: list comprehension may require a final 'concat'
10:56:56 <mm_freak> > ["abc", "def", "ghi"] >>= id
10:56:57 <lambdabot>   "abcdefghi"
10:57:00 <parcs> > (pi, fromRational (toRational pi))
10:57:01 <__xc> yes
10:57:02 <lambdabot>   (3.141592653589793,3.141592653589793)
10:57:17 <mm_freak> > concat [ x | x <- ["abc", "def", "ghi"] ]
10:57:18 <lambdabot>   "abcdefghi"
10:57:25 <mm_freak> __xc: that's the only case though
10:57:35 * hackagebot linear-algebra-cblas 0.1 - A linear algebra library with bindings to BLAS and LAPACK  http://hackage.haskell.org/package/linear-algebra-cblas-0.1 (CarterSchonwald)
10:58:07 <__xc> I was really thinking of multipke ' <- ' and mixing variables
10:58:10 <tromp_> no need for concat
10:58:17 <erisco> these lenses seem to be about operations on tuples... how does this relate?
10:58:22 <tromp_> > [ y | x <- ["abc", "def", "ghi"], y<-x ]
10:58:24 <lambdabot>   "abcdefghi"
10:58:38 <mm_freak> tromp_: you're using a combinator now
10:58:43 <mm_freak> and that combinator is called concat ;)
10:59:03 <mm_freak> with combinators you can do everything and everything is equally powerful
10:59:28 <monochrom> what combinator is in "[ y | x <- ["abc", "def", "ghi"], y<-x ]"?
10:59:40 <erisco> I'm just a bit confused. Many languages have some abstract notion of a list of things. Haskell has lists, but this is a specific implementation... ie, you could construct other types which behave like lists
10:59:47 <mm_freak> oh, wait
10:59:50 <mm_freak> sorry, my failure
10:59:51 <tromp_> i'm also using bind and return under the hood. so what?>
11:00:04 <mm_freak> i read that as a nested comprehension
11:00:08 <erisco> and it seems natural to want to make as few assumptions as possible when writing code, so if I don't have to assume haskell [], then I won't, but rather I just need something that is list-like
11:00:11 <tromp_> if you look under the hood, then it's all the same
11:00:15 <mm_freak> ok, yes, they are equivalent
11:00:21 * __xc searching combinator ^^
11:00:25 <erisco> I thought this was Traversable, but it seems Traversable only exposes enough to define map operations
11:00:28 <mm_freak> tromp_: i just misread your code
11:00:33 <monochrom> ", y<-x" is your >>=id and concat
11:01:11 <mm_freak> erisco: haskell lists are more like a control structure
11:01:17 <monochrom> [ y | x <- #haskell, y <- x]
11:01:19 <mm_freak> a very specific one
11:01:31 <erisco> mm_freak, but it isn't unique
11:01:47 <erisco> mm_freak, what I mean is, I can create my own type which can be constructed like a list
11:01:58 <mm_freak> erisco: sure
11:02:22 <erisco> sure, so like most other things in Haskell, I'd expect a grander generalization of things which are list-like
11:02:31 <applicative_> erisco: it's true there isn't much to piece together things like list, vector, array, bytestring, text.
11:02:36 <mm_freak> erisco: it's not as useful as you think it would be
11:02:48 <applicative_> erisco, but there are attempts, see e.g. the ListLike package
11:03:05 <erisco> mm_freak, why, because I can convert something that is like-like to a list and then operate on it?
11:03:28 <mm_freak> erisco: indeed
11:03:30 <applicative_> one trouble as mm_freak is I think suggesting, is that these things are farther a part than they seem; for example laziness operates differently in them
11:03:59 <mm_freak> erisco: to take your example, Traversable, sounds like a very useful thing to have
11:04:08 <mm_freak> but it's actually used seldomly
11:04:35 <hpaste> h4199 pasted “nonblocking IO” at http://hpaste.org/86083
11:04:51 <applicative_> almost everything you can think of as sequential or listlike has toList methods, and also foldr/l which can be used to make a list with foldr (:) []
11:05:03 <h4199> Oh that is nice
11:05:19 <geekosaur> x <- return ... better written as let x = ...
11:05:29 <h4199> I think I am mishandling the use of MVars to block the main thread
11:05:42 <erisco> it is an interesting approach, but I don't understand why it is more useful to convert than to have a more general abstraction
11:06:25 <applicative_> erisco: http://hackage.haskell.org/package/ListLike http://hackage.haskell.org/package/listlike-instances
11:06:36 <mm_freak> h4199: i'm having trouble reading your code, but in any case when concurrency behaves weirdly, a common cause is that you compiled without -threaded
11:07:25 <applicative_> erisco: I see John Lato is maintaining them, so someone with judgment is keeping them going.
11:07:35 * hackagebot data-inttrie 0.1.0 - A lazy, infinite trie of integers.  http://hackage.haskell.org/package/data-inttrie-0.1.0 (LukePalmer)
11:07:55 <dmwit> geekosaur: if x is a literal variable, yeah, though that transformation doesn't work for all patterns
11:08:05 <h4199> I compiled with and without threaded, same story
11:08:18 <geekosaur> dmwit, look at h4199's paste
11:08:22 <geekosaur> it's filled with that
11:08:34 <mm_freak> erisco: this is very related:  say you have a function like this:  f :: (forall a. (Show a) => a -> b) -> b
11:08:45 <applicative_> erisco: not that for example Parsec works with a general abstraction "Stream a b" which just has the method uncons :: a -> Maybe (b,a)
11:08:49 <mm_freak> erisco: this is really not much different from:  f :: (String -> b) -> b
11:09:00 <dmwit> oh yeah
11:09:07 <monochrom> h4199: for each filename, your program does this: a thread is spawned, it creates an MVar, and eventually puts stuff into it; the main thread creates an MVar, a different one, and waits on it.
11:09:20 <mm_freak> erisco: with the same argument you can say that if your scenario is listlike, you may as well use a list
11:09:59 <mm_freak> erisco: also consider the most common reason why people request ListLike
11:10:31 <mm_freak> they simply would like to write "break" instead of "V.break" or "B.break" or "T.break" or …
11:10:33 <monochrom> it is illuminating to simplify your program to the case of only one filename
11:11:38 <h4199> Well that does explain it, should I just write a manager to keep the MVars's IDs sorted out so that they are consistent?
11:11:53 <applicative_> erisco: heres another mad scheme, as I call it despite the notability of the author : http://hackage.haskell.org/packages/archive/classy-prelude/0.5.4/doc/html/ClassyPrelude-Classes.html
11:12:56 <applicative_> hm, it has 10 things depending on it; ListLike has 22
11:13:48 <monochrom> h4199: no, I think you don't understand. first, do you understand why the spawned thread and the main thread both create their own MVars, as opposed to the main thread creating an MVar and sharing it with the spawned thread?
11:14:18 <applicative_> I find writing "V.break" or "B.break" or "T.break" to be kind of a nightmare, but on the other hand, as Peaker likes to point out, it does tell you which break the writer means....
11:14:31 <erisco> mm_freak, well, if a lossless conversion exists between two types, then it could be understood as adhering to the same properties
11:14:33 <mm_freak> applicative_: i actually prefer to write it that way
11:14:44 <erisco> mm_freak, but no interface is formalized, which is merely giving consistent names to the operations
11:14:48 <Peaker> applicative_, nightmare is a bit much :) I agree that going to the top of the file to edit the import lists and back is kind of a nightmare
11:14:56 <mm_freak> erisco: that would be true in C++, but in haskell a stronger relationship holds
11:15:02 <Peaker> can't wait for lamdu to fix that :)
11:15:05 <mm_freak> erisco: if you can convert between two types, they are isomorphic
11:15:08 <applicative_> mm_freak: yeah, i'm coming around to it, it's taking surpringly long
11:15:26 <merijn> Peaker: Yes! Stop procrastinating on IRC and get back to coding that!
11:15:27 <erisco> mm_freak, isomorphic meaning that they are substitutable?
11:15:33 <mm_freak> erisco: exactly
11:15:42 <applicative_> Peaker, erisco wants to know why we don't work with some general list/sequence abstraction in place of all this
11:15:51 <Peaker> merijn, heh :) We're finally back on that after months of personal arrangements, holidays, etc
11:16:03 <mm_freak> erisco: now you will find that [Char] and Text are far from isomorphic
11:16:06 <dmwit> h4199: Compare: main = do { foo newEmptyMVar; v <- newEmptyMVar; takeMVar v }/foo m = do { v <- m; putMVar v } with main = do { v <- newEmptyMVar; foo v; takeMVar v }/foo v = putMVar v
11:16:13 <Peaker> applicative_, because we still suck at that :)  lens is a huge step forward though
11:16:14 <applicative_> how is bottle/lambdu doing? i haven't heard about it
11:16:25 <erisco> mm_freak, so the only missing thing is a formalized interface where operations are given the same name for each isomorphic type
11:16:32 <Peaker> applicative_, we're working on a record system and UI now
11:16:47 <applicative_> ah nice
11:16:53 <mm_freak> erisco: "for each isomorphic type" is already a very strong condition
11:16:55 <Peaker> applicative_, we want to have structural records rather than explicit record definitions, so intermediate states can have different records
11:17:03 <dmwit> h4199: Do you understand how the behaviors of these two programs differ?
11:17:06 <erisco> mm_freak, it just seems to be the logical direction to go... conversion alone seems like a cheaper version of this where two parties are maintaining libraries separately and they can't agree on names
11:17:23 <mm_freak> erisco: that's not the problem
11:17:24 <edwardk> applicative_: because general list sequence abstractions tend to lead you to write suboptimal code for all scenarios. How you best work with a container is largely determined by its asymptotics. Should I copy or make local edits? Should I cons onto it or do things in one big jump, etc.
11:17:24 <h4199> still reading
11:17:30 <applicative_> erisco: that's a point, the lens lib does some pretty sexy things of the sort that are interesting to you.   never mind the cognitive load....
11:17:41 <applicative_> edwardk: yes, I was making that point earlier
11:17:45 <erisco> mm_freak, then I don't see the motivation. If isomorphism is good enough, why bother with type classes?
11:17:56 <applicative_> edwardk: in a cruder way
11:18:08 <mm_freak> erisco: [Char] and Text are simply not isomorphic…  they are so different that they can't actually agree on interfaces, because the meanings of the individual functions would be so different
11:18:27 <mm_freak> erisco: type classes aren't there to give a common interface to isomorphic types
11:18:34 <edwardk> applicative_: That doesn't stop me from writing lots of convenient classes that give me ad hoc overloading, like Cons, etc. in lens, but whenever i work with them i have to stop and think about the particular instance i'm working with rather than the general case, and it really slows me down
11:18:49 <mm_freak> erisco: consider Monoid…  many types form a monoid and they are in no way isomorphic
11:18:53 <applicative_> arent they  'isomorphic' or something like that
11:18:54 <erisco> mm_freak, then what is their purpose? and why do you mention [Char] and Text if they are not isomorphic?
11:19:11 <mm_freak> erisco: () forms a monoid just like String and Text and Last SomeException
11:19:14 <typoclass> h4199: it's a bit hard to see due to the "... <- return ..." convention in the code that you pasted :-) line 7 doesn't actually run the newEmptyMVar action, it just sticks them in a list. the list will contain tuples which contain things of type IO (MVar a)
11:19:23 <typoclass> h4199: does that make any sense?
11:19:27 <applicative_> ooo Last SomeException, what's that for
11:19:52 <mm_freak> applicative_: to be algebraically sound the inhibition type in netwire needs to be a monoid
11:19:52 * applicative_ is finally getting into exceptions
11:19:58 <h4199> Yes
11:20:02 <mm_freak> so you can't use SomeException…  you need Last SomeException
11:20:17 <applicative_> ah ok
11:20:30 <erisco> mm_freak, can you use an example other than Monoid? I am not familiar
11:20:36 <mm_freak> Last is really just Maybe, but its monoid instance is last-biased
11:20:40 <mm_freak> there is also First
11:20:54 <mm_freak> erisco: Eq
11:21:00 <elliott> erisco: have you ever written code generic over a particular interface some types can support?
11:21:03 <elliott> or wanted to?
11:21:20 <elliott> (if not, you've been working at a very restrictive level of abstraction)
11:21:25 <hiptobecubic> mm_freak, meaning forall a b. Last a <> Last b == Last b  ?
11:21:27 <erisco> elliott, I'm not sure precisely what you mean, but tentatively, yes
11:21:28 <Peaker> edwardk, it's true that for each particular scenario/end-case you want a very concrete type -- but you still want to re-use generic code in different scenarios, on different concrete sequence types
11:21:43 <dmwit> hiptobecubic: Last a <> Last (Just b) = Last (Just b), yes
11:21:46 <typoclass> mm_freak: i'm unfamiliar with netwire, but will the "Last SomeException" thing give the newest exception that occurred or the oldest? (intuitively it seems like you'd usually want the oldest, "root cause", "first sign of trouble" kind of thing)
11:21:47 <mm_freak> hiptobecubic: Last (Just x) <> Last (Just y) = Last (Just y)
11:21:57 <elliott> erisco: then that's what typeclasses are for.
11:22:01 <Peaker> edwardk, even though different things are better/worse for each concrete type, you still want many/all of those things to be available for all containers polymorphically without duplicating code
11:22:07 <elliott> as well as providing convenient operator overloading for common shared operations at the same time.
11:22:07 <hiptobecubic> dmwit, mm_freak , oh sorry. Monoid a, Monoid b :)
11:22:18 <applicative_> we want to use generic combinators, but the implementations are all different
11:22:25 <hiptobecubic> or is it not?
11:22:27 <mm_freak> hiptobecubic: that's not what you missed…  you missed the Just =)
11:22:27 <erisco> elliott, that doesn't inform me why type classes are not desired for isomorphic types
11:22:29 <dmwit> hiptobecubic: Last is not a monoid transformer; it always uses Maybe underneath.
11:22:31 <hiptobecubic> yes
11:22:35 <hiptobecubic> ok
11:22:36 <hiptobecubic> I see
11:22:40 <edwardk> Peaker: i'm perfectly on board with ad hoc overloadings for working with different classes. it just troubles me that they are just that. very ad hoc, requiring me to stop and reason casewise about the performance of each container, etc.
11:22:47 <elliott> i admit i don't know the full context of this isomorphism thing
11:22:55 <elliott> especially since thsi seems to have gone on for ten hours :P
11:22:56 <Peaker> There are many many cases where I really don't care if I'm using strict ByteString or lazy ByteString, and performance is very secondary and would be ok either way, but I still have to do ugly conversions or duplicate code
11:22:59 <edwardk> Peaker: its like how i die a little inside everytime I see 'foldMap point'
11:23:00 <mm_freak> the Maybe is important, otherwise Last a does not form a monoid at all
11:23:23 <mm_freak> (it would still form a semigroup)
11:23:24 <Peaker> edwardk, that's scala for (>>= return) ?
11:23:26 <applicative_> point?
11:23:38 <edwardk> applicative_: from pointed
11:23:43 <applicative_> :t (>>= return)
11:23:44 <Peaker> or the Pointed class? ah
11:23:44 <lambdabot> Monad m => m b -> m b
11:24:01 <__xc> sooner I was thinkin that wrting things like the last example here http://www.haskell.org/haskellwiki/List_comprehension with list comprehension would be hard
11:24:03 <dmwit> The Maybe isn't so important. Any Monoid/Eq would do.
11:24:15 <edwardk> Peaker: i've seen 'foldMap point' used in a dozen places in third party code for things like building sets, etc.
11:24:22 <dmwit> But I can't imagine much of a use for other Monoid/Eq instances, so Maybe seems reasonable.
11:24:22 <otters> :t (>>= id)
11:24:24 <lambdabot> Monad m => m (m b) -> m b
11:24:33 <dmwit> (In fact, all you need is Default/Eq.)
11:24:37 <__xc> s/sooner/earlier
11:24:41 <Peaker> edwardk, is it used because it is a polymorphic way to convert between container types? I'm not sure I follow...
11:24:46 <__xc> sorry my english
11:24:48 <edwardk> i have to push 'down' knowledge of the types to understand what that means.
11:24:58 <applicative_> foldmap pointed, wont that just reduce everything to the point ?
11:25:03 <edwardk> Peaker: its not something where the meaning works without context
11:25:06 <applicative_> foldmap point rather
11:25:14 <edwardk> applicative_: no, consider using it to build a set.
11:25:20 <erisco> mm_freak, okay, so you have many types which can be compared for equality. therefore, there is an Eq type class. Why is there a type class in this case, but not for isomorphic types?
11:25:24 <__xc> actually comining lists comprehensions is hard to read probably
11:25:27 <applicative_> let me look at foldmap again...
11:25:28 <edwardk> or Maybe
11:25:29 <__xc> combining*
11:25:39 <erisco> mm_freak, as far as I can tell, you'd be arguing not to have Eq and rather to convert all types to Int for comparison
11:25:42 <edwardk> or First
11:25:48 <mm_freak> erisco: because you don't need isomorphic types
11:25:52 <donri> :t foldMap pure
11:25:53 <lambdabot> (Applicative f, Foldable t, Monoid (f a)) => t a -> f a
11:25:59 <Peaker> edwardk, in the Set case, is it equivalent to    Set.fromList . Foldable.toList?
11:26:06 <applicative_> oh I see, it was Point I was misremembering
11:26:15 <mm_freak> erisco: think about this C struct:  struct X { int x; int y; }
11:26:19 <edwardk> you get very different meanings since there are no laws relating 'point' to monoid for the 'foldMap'.
11:26:22 <erisco> mm_freak, so you are saying if you find yourself introducing a type which is isomorphic to another, to use the other instead?
11:26:28 <mm_freak> erisco: and then this:  struct Y { int y; int x; }
11:26:37 <mm_freak> in C these types are very different
11:26:46 <Peaker> edwardk, but the meaning is a relatively straightforward composition of meanings, isn't it?
11:26:47 <edwardk> My experience with highly ad hoc classes that people write to say 'hey i want to do this across everything that looks kinda like this', is that those classes tend to require case-wise reasoning
11:26:52 <erisco> mm_freak, agreed
11:26:56 <mm_freak> however, consider the two haskell types:  data X = X Int Int;  data Y = Y Int Int
11:26:57 <dmwit> erisco: Nah. In fact, we even have a specific keyword made only for introducing a type that's isomorphic to an existing one.
11:27:06 <mm_freak> you see immediately that they are actually the same
11:27:10 <applicative_> do they have ListLike modules in MLs?
11:27:27 <__xc> > take 10  [(i,j) | i <- [1..], j <- [1..i^2]]
11:27:28 <lambdabot>   [(1,1),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(3,5)]
11:27:36 <mm_freak> erisco: even though i flipped the two arguments in Y =)
11:27:40 <erisco> mm_freak, well this is only because you've dropped the semantic meaning of the variable name
11:27:46 <Peaker> edwardk, I'm not arguing for that -- I'm just arguing that the current situation of explicit duplication/conversion sucks.. I think ad-hoc classes that help with DRY (even if they don't help with reasoning) are an improvement, and ideally we could reuse classes with laws
11:27:52 <edwardk> Peaker: for Set it means build a set. for Maybe it glues together elements using a semigroup. For First, it takes the first answer, etc. but each of those is radically different behavior that requires you to push the context down rather than infer the meaning from the statement in isolation
11:28:01 <erisco> mm_freak, if you said    data X = X { y :: Int, x :: Int }   it wouldn'
11:28:07 <erisco> mm_freak, t seem so different
11:28:12 <mm_freak> erisco: yes, they would still be the same
11:28:26 <Peaker> edwardk, isn't this also true of "mconcat"?
11:28:32 <applicative_> there is still a latent order there, like it or not
11:28:35 <edwardk> Peaker: i offer them, because i admit the reality is that i need them. i just tend to try to avoid them and seek a more principled story with laws when i can avoid it.
11:28:40 <erisco> mm_freak, so you are saying haskell will not recognize any difference between these types?
11:28:46 <mm_freak> erisco: exactly
11:28:54 <erisco> really now? that seems dangerous
11:29:00 <mm_freak> it's not =)
11:29:08 <applicative_> between mm_freak 's X and Y?
11:29:18 <mm_freak> erisco: keep in mind that you are not defining memory layouts
11:29:23 <mm_freak> you are defining an abstract type
11:29:25 <erisco> in C, or other languages where type comparison is done by name and not signature, you can encode semantic meaning in the name
11:29:33 <edwardk> Peaker: 'Pointed' is a perfectly fine way to say 'associated with this type is some family of coalgebras, but the only laws associated with it are free theorems, so you wind up doing ad hoc reasoning from the type in each case.
11:29:39 <mm_freak> erisco: wait
11:29:42 <Peaker> erisco, typically there's more variation inside types. You could re-use a Vector/Tensor type from a library, or you could use a newtype to distinguish different dimensions
11:29:43 <FireFly> I think `data X = X { y :: Int, x :: Int }` is basically just sugar for `data X = X Int Int; let y (val, _) = val; let x (_, val) = val` ?
11:29:46 <dmwit> I would like to point out that Haskell does not have subtyping. So be careful to say what you mean when you say "Haskell  will not recognize any difference between these types".
11:29:49 <mm_freak> erisco: if a function expects an X, you can't pass it a Y
11:29:50 <FireFly> That's my understanding anyway
11:29:56 <edwardk> foo = foldMap point is so much nonsense in isolation, but its useful in context.
11:29:59 <mm_freak> erisco: they are not the same type, they are just isomorphic
11:30:20 <h4199> @typoclass,monochrom,dmwit
11:30:21 <lambdabot> Unknown command, try @list
11:30:22 <h4199> I understand the difference between the two pasted programs, and now I understand where my expectations were wrong, but I am still not sure what the proper way to write what I wrote is. I want to pair an MVar with each file name in a list and then use those to block the main thread until the writes are finished. Is there some code that does something similar that I can look at?
11:30:26 <typoclass> erisco: just to clarify, with mm_freak's example, you of course couldn't take a Y and give it to a function :: X -> ...
11:30:28 <edwardk> as a library author i tend to like packageable behavior. 'foldMap point' isn't packageable, because you can't reason about it just from the signature sanely
11:30:31 <mm_freak> erisco: if the function would expect a Y instead it would still be the same function
11:30:37 <applicative_> mcbride uses a pair of list types sometimes, Bwd a = Bwd | Bwd a :< a ; Fwd a = Fwd | a :> Fwd a
11:30:39 <erisco> mm_freak, okay, so if you had the type 'Mass' you couldn't just pass in 'Mph
11:30:47 <erisco> mm_freak, even if they were both constructed with one Int
11:30:48 <applicative_> the difference is purely psychological
11:30:53 <mm_freak> erisco: yeah
11:31:02 <erisco> that was the danger I was worried of, so okay
11:31:16 <mm_freak> erisco: that would be horrible ;)
11:31:17 <donri> if 'return' is the only way to construct a value of some type is that the identity monad then?
11:31:21 <edwardk> applicative_: not entirely. you get different traversal orders, too.
11:31:40 <applicative_> yeah, i'm busily taking it back here
11:31:54 <Peaker> edwardk, so what's up with the lambdabot giving more general types than lens 3.9/3.10?
11:31:59 <dmwit> h4199: How about using something like mapM_ (\filename -> newEmptyMVar >>= \mvar -> return (mvar, filename)) files
11:32:01 <erisco> mm_freak, so what makes them isomorphic?
11:32:04 <edwardk> Peaker: how so?
11:32:15 <edwardk> lambdabot is on an old version of lens
11:32:18 <applicative_> the purpose is psychological, would be the better thing to say
11:32:18 <erisco> mm_freak, I thought we said there were so if and only if a lossless conversion can be made between the two?
11:32:24 <mm_freak> erisco: the fact that you can define total mapping functions between them, in both directions
11:32:34 <mm_freak> aka isomorphisms
11:32:38 <erisco> mm_freak, how so? we don't know what those values represent
11:32:46 <mm_freak> erisco: that doesn't matter
11:32:57 <edwardk> we modified the types of getting to be simpler in 3.9 or so, because it helps inference for a lot of cases involving ^. and set.
11:33:01 <erisco> mm_freak, why not? there is no sensible conversion from Mass to MPH without extra information
11:33:08 <mm_freak> erisco: say f :: X -> Y, g :: Y -> X and f . g = g . f = id
11:33:14 <edwardk> that is probably the distinction you are seeing
11:33:18 <mm_freak> if those functions exist, the types X and Y are isomorphic
11:33:22 <edwardk> :t (^.)
11:33:22 <typoclass> h4199: you will probably be interested in the functions mapM, mapM_, or sequence, as dmwit demonstrated
11:33:23 <lambdabot> s -> Getting a s t a b -> a
11:33:25 <typoclass> @type mapM_
11:33:27 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
11:33:35 <edwardk> in lens 3.9 that is s -> Getting a s a -> a
11:33:37 <dmwit> oops
11:33:43 <typoclass> h4199: in your case, m is IO of course
11:33:48 <dmwit> h4199: not mapM_, that was a mistake, I meant mapM in my example
11:33:53 <edwardk> we dropped the 't and b' parameters to Getting, which means the types are less flexible, but now if you have something like
11:33:58 <erisco> mm_freak, sure, but I don't know how you go from "these two types are both constructed with Int" to "there is a conversion between the two types"
11:34:19 <edwardk> json :: (FromJSON a, ToJSON b) => Iso ByteString ByteString a b
11:34:23 <mm_freak> erisco: f (X x y) = Y x y
11:34:24 <edwardk> and you go to use it with (^.)
11:34:42 <mm_freak> erisco: g (Y x y) = X x y
11:34:44 <edwardk> you don't get everything panicking that it can't pick the instance for the underdetermined side
11:34:51 <mm_freak> erisco: you can easily prove that f . g = g . f = id
11:34:59 <danharaj> I will miss the violent type signatures, personally.
11:35:01 <h4199> @dmwitt, thanks, yeah, I got the meaning, and I think I will run with that from there, Thanks all!
11:35:01 <lambdabot> Unknown command, try @list
11:35:04 <Peaker> edwardk, I see.. how do you restore the type flexibility from before?
11:35:07 <Taneb> edwardk, isn't that a Prism?
11:35:22 <edwardk> Taneb: yes
11:35:29 <edwardk> Peaker: whats biting you?
11:35:35 <erisco> mm_freak, is there no semantic consideration?
11:35:48 <mm_freak> erisco: it's not needed
11:35:59 <mm_freak> the isomorphism exists, so you could just as well use Y where you use X
11:36:07 <Peaker> edwardk, I'm actually just curious about it.. old lens allowed the general type, so surely the new lens should make that general type possible too?
11:36:10 <erisco> it has to be explicitly excluded, because with it it is senseless
11:36:30 <mm_freak> erisco: you could write f (X x y) = Y y x instead
11:36:34 <edwardk> the problem is that to get that more general type, you had to make users put manual type annotations on _lots_ of code
11:36:38 <mm_freak> you would still get an isomorphism
11:36:54 * elliott doesn't understand what all this confusion is, or was ever, about, any more
11:37:07 <edwardk> the hope was that by tightening up the types for Getting, we could elsewhere loosen up the types on things like prisms
11:37:07 <typoclass> h4199: it may help if you explicitly write down the type of loop, just so that ghc can double-check your work :-) loop :: (MVar (), String) -> IO (). currently you have of course loop :: (IO (MVar ()), String) -> IO (), if i'm not mistaken
11:37:10 <Peaker> edwardk, I understand -- I thought maybe there was a way to write a more verbose/elaborate version here -- or is the general type not possible at all?
11:37:21 <mm_freak> elliott: i think this is still about ListLike and why i think it's not needed =)
11:37:28 <erisco> mm_freak, sure, but again, if one type is Mass and the other MPH... you can say Mass 5 = MPH 5, but this is nonsensical semantically
11:37:46 <erisco> mm_freak, so I am just clarifying that semantics are excluded
11:37:47 <edwardk>  \p f -> fmap (review (clonePrism p) . f) . (^? clonePrism p)   yields   APrism t t b b -> (b -> b) -> t -> Maybe t  -- is the culprit?
11:37:50 <elliott> I have no idea what it has to do with isomorphisms then, reall
11:37:51 <elliott> y
11:37:55 <edwardk> lets fix that to not use ^? and review
11:38:03 <edwardk> and then you can have your cake and eat it too
11:38:06 <dmwit> h4199: Also, if all you're doing is waiting for *all* your threads to exit, you might want to consider just making one mvar and sending it to all your threads.
11:38:08 <mm_freak> erisco: sure, but consider this:  newtype Mass = Mass Int;  newtype MPH = MPH Int
11:38:15 <mm_freak> erisco: they are both isomorphic to Int
11:38:20 <dmwit> h4199: Write to it once from each thread, read from it number-of-loops times in main.
11:38:24 <mm_freak> newtype actually makes sure that they are
11:39:09 <Peaker> edwardk, Ideally there could be a way to write it more nicely -- the purpose is having the result of a prism update in a Maybe in case the prism didn't match at all
11:39:20 <Peaker> edwardk, (instead of manually decomposing it with ^? and recomposing it with review)
11:39:34 <mm_freak> erisco: newtype is precisely for making isomorphic types and with the GeneralizedNewtypeDeriving you can even copy class instances
11:39:55 <edwardk> Peaker: sure. i pulled this off before a few ways. trying to figure out the nicest encoding
11:39:58 <mm_freak> erisco: newtype MyId a = MyId (Identity a) deriving (Applicative, Functor, Monad, …)
11:40:17 <erisco> mm_freak, alright, so to bring this back to isomorphism and type classes, why does isomorphism alone not warrant a type class?
11:40:29 <applicative_> edwardk: was augustss
11:40:42 <mm_freak> erisco: because you can map back and forth
11:40:44 <edwardk> applicative_: ?
11:40:50 <applicative_> edwardk: was augustss 's only objection to lens the mass of 'operators'? I noticed some kerfuffle on reddit
11:40:50 <mm_freak> map, apply the operations of the other type, map back
11:41:08 <edwardk> applicative_: pretty much
11:41:21 <elliott> mm_freak: and you can pass around a dictionary of the Num operations too
11:41:26 <edwardk> it also has pretty high cognitive overhead just to get started with
11:41:26 <mm_freak> erisco: example:  newtype MyList a = MyList [a]
11:41:27 <applicative_> ah good. at first I thought he thought there was some unsoundness
11:41:29 <edwardk> and i freely admit that
11:41:42 <edwardk> if you go looking at lens just to use a couple of lenses it hits you like a wave of 'wtf'
11:41:47 <applicative_> tell him to join #haskell-lens and get tutored
11:41:55 <mm_freak> erisco: don't write 'head' for MyList…  instead write:  withMyList :: ([a] -> [a]) -> MyList a -> MyList a
11:41:57 <erisco> mm_freak, then in the other direction, why are all type classes not removed and replaced with type conversions?
11:41:58 <neutrino> hi
11:42:04 <edwardk> if you go in and are willing to spend a couple of days looking around and learn new ways to do things, it is useful
11:42:19 <mm_freak> erisco: because you can't convert between Int and Integer, but you still can compare both
11:42:20 <neutrino> could one calculate sqrt(2) by computing fix of \x -> 2/x ?
11:42:30 <neutrino> i tried but it does not terminate, am i doing something wrong?
11:42:35 <applicative_> yea, I only have imprinted five or six operators, I think.  Well theres the ones for state, which are memorable, but I dont use
11:42:38 <neutrino> is there a way to do this at all?
11:42:43 <mm_freak> erisco: just because types X and Y have equality predicates doesn't mean that they are isomorphic
11:42:52 <erisco> mm_freak, agreed
11:43:00 <applicative_> edwardk: I mean, just learning five or six operators is a huge win
11:43:07 <typoclass> mm_freak: can we ...? i thought (==) requires both guys to be the same type, so you need a fromIntegral or similar to compare Int and Integer
11:43:17 <Peaker> edwardk, I thought of writing a blog post or such to start from conal's semantic-editor-combinators, add support for effects (yielding the form in lens) and then "tricking" it with Const to do a get, and voila, lens
11:43:27 <mm_freak> typoclass: that's not the point…  there is no isomorphism between Int and Integer
11:43:30 <erisco> mm_freak, okay, I can follow this reasoning
11:43:31 <Eduard_Munteanu> neutrino: that wouldn't work
11:43:47 <h4199> yes, I had loop :: (MVar (), String) -> IO () earlier, though, so it is as simple a reverting, I had errors elsewhere that caused me to change it.
11:43:48 <h4199> and I thought about the one MVar solution too, but I thought that storing the length of my list to use as a "taker" wasn't really the ideomatic way to approach the problem. Wouldn't the multiple MVar way be better if I choose to introduce something to handle and report errors?
11:44:13 <Eduard_Munteanu> neutrino: you'd need some sort of lazy reals to do it
11:44:15 <mm_freak> erisco: you could however define various operations many listlike types have in common, but don't pretend they are the same =)
11:44:33 <mm_freak> erisco: for example almost all listlike operations have an 'uncons' operation
11:44:42 <mm_freak> s/operations/types/
11:44:49 <edwardk> :t \p f a -> case p ((,) (Any True) . f) a of (Any True, a) -> Just a; (Any False, _) -> Nothing
11:44:50 <lambdabot> ((a -> (Any, b)) -> t -> (Any, a1)) -> (a -> b) -> t -> Maybe a1
11:44:51 <neutrino> Eduard_Munteanu: why would i need lazy reals? what are lazy reals?
11:44:53 <erisco> mm_freak, okay, sure, but this just seems to support having a type class
11:44:55 <edwardk> Peaker: use that
11:45:03 <mm_freak> erisco: in other words, don't define ListLike…  define Uncons instead
11:45:18 <edwardk> @let peaker p f a = case p ((,) (Any True) . f) a of (Any True, a) -> Just a; (Any False, _) -> Nothing
11:45:21 <lambdabot>  Defined.
11:45:23 <mm_freak> erisco: note that type classes should usually have a set of laws
11:45:25 <erisco> mm_freak, since isomorphism does not exist across all types which are list like, then this seems like the case for a type class
11:45:39 <edwardk> Peaker: note that doesn't need a prism, it'll work on any traversal as well
11:45:44 <Eduard_Munteanu> neutrino: normal numbers are strict, so the expression will diverge
11:45:48 <erisco> mm_freak, okay, Uncons can be the name
11:45:58 <typoclass> h4199: possibly yes. but you could also have a single MVar that passes along a number of errors (Strings or whatever)
11:46:04 <Peaker> edwardk, thanks!
11:46:10 <dmwit> h4199: I guess handling and reporting errors can go through that MVar, too.
11:46:14 <edwardk> Peaker: it applies the function to the targets of the traversal and if it finds no targets it'll return Nothing, otherwise it'll return the new structure
11:46:21 <dmwit> h4199: Still no need for multiple MVars, as far as I can tell.
11:46:23 <edwardk> Peaker: that works with prisms because every prism is a traversal
11:46:32 <applicative_> erisco: the Uncons class already exists in Parsec
11:46:38 <Peaker> edwardk, I understand... it's a traversal in Writer,w=Any
11:46:43 <applicative_> instances are all over
11:46:48 <mm_freak> erisco: the problem is that arbitrary type classes are harmful…  if at all possible, type classes should have associated laws
11:46:51 <edwardk> Peaker: actually
11:46:52 <edwardk> one sec
11:46:58 <edwardk> check for 'failover' =)
11:46:59 <mm_freak> erisco: a sensible law for a Cons type class would be:  uncons (cons x xs) = Just (x, xs)
11:47:02 <edwardk> its already in the library
11:47:07 <h4199> you both are right, hmm.
11:47:08 <Eduard_Munteanu> neutrino: I can tell you what lazy naturals looks like... they're   data Nat = Zero | Succ Nat
11:47:08 <h4199> I am making the problem harder than it has to be. Thanks again
11:47:09 <mm_freak> erisco: and you would have to express the slightly more complicated inverse law
11:47:26 <neutrino> Eduard_Munteanu: how is that "lazy"?
11:47:28 <mm_freak> then there is a sensible notion of when types are actually Cons
11:47:29 <applicative_> excelent law
11:47:35 <mm_freak> otherwise you could define a Cons instance for every type
11:47:39 <mm_freak> do you see what i mean?
11:48:27 <erisco> mm_freak, what does Just (x, xs) mean? isn't this Maybe constructed with a tuple?
11:48:42 <applicative_> if you define append with this Cons class, I think you won't want to use it with Vector or Array....
11:48:47 <Eduard_Munteanu> neutrino: well, they're lazy because Haskell makes them so... the actual exceptions are the normal numbers :)
11:49:01 <mm_freak> erisco: uncons :: (Cons f) => f a -> Maybe (a, f a)
11:49:12 <mm_freak> erisco: this type already poses a problem, btw =)
11:49:15 <applicative_> erisco: it just gives you the head and the tail (head,tail) if it exists
11:49:25 <Peaker> erisco,   List a   is either   Nil   or   a Cons pair with a and (List a).    Maybe (a, List a)    is either   Nothing     or    a Just pair with a and (List a) in it
11:49:27 <erisco> okay, but does this even work for :?
11:49:28 <applicative_> if they exist
11:49:39 <mm_freak> erisco: sure
11:49:41 <typoclass> h4199: just as another tip, you can use "let ... = ..." inside of do blocks. i noticed that you sometimes did things like "str <- return (snd v)"
11:49:48 <mm_freak> uncons (x:xs) = Just (x, xs)
11:49:52 <mm_freak> uncons [] = Nothing
11:50:32 <Eduard_Munteanu> neutrino: the nice thing is you can play with infinities and such if you're careful
11:50:37 <applicative_> class Streamy a b where cons :: a -> b -> b; uncons :: b -> Maybe (a,b)
11:51:35 <Eduard_Munteanu> neutrino: I can define omega :: Nat; omega = Succ omega      Now if I want to decide if that's larger than a finite number, I can do it just fine.
11:51:43 <applicative_> or maybe class Str a where type Elem a :: *; cons :: Elem a -> a -> a; uncons :: a -> Maybe (Elem a, a)
11:51:45 <mm_freak> erisco: but as said, the type already poses a problem…  i can come up with at least three different ways to define a Cons type class, let alone a full listlike class
11:51:45 * typoclass . o O ( why does that class have an 'a' in its head ...? ) the whole discussion is mystifying to me
11:52:05 <mm_freak> erisco: each of them would rule out some of the types which would be perfect Cons types otherwise
11:52:11 <dmwit> typoclass: To avoid TypeFamilies, I guess.
11:53:03 <typoclass> dmwit: hmmm right
11:53:23 <mm_freak> erisco: btw, the class i just proposed is the only one you could actually put into the base library without requiring type system extensions…  and guess what…  you can't make ByteString and Text instances of it =)
11:53:37 <Eduard_Munteanu> neutrino: try defining (>) for Nats to see why it works
11:53:40 <erisco> mm_freak, why  uncons :: (Cons f) => f a -> Maybe (a, f a)   and not   uncons :: (Cons f) => f a b -> Maybe (a, f b)  ?
11:53:43 <applicative_> mm_freak: of Uncons?
11:54:01 <mm_freak> let's call it Cons
11:54:02 <erisco> mm_freak, that doesn't make sense either...
11:54:12 <mm_freak> erisco: because that's a kind error
11:54:14 <erisco> sorry, I don't understand the signature..
11:54:22 <applicative_> mm_freak: Parsec.Text and Parsec.Bytestring make instances
11:54:45 <mm_freak> i'm just showing the inherent difficulty in defining a sensible ListLike class
11:55:05 <erisco> mm_freak, oh nevermind, I get it now
11:55:28 <mm_freak> erisco: if you go further you will notice that you don't actually need the Cons class as i defined it
11:55:34 <mm_freak> it's completely useless
11:56:03 <applicative_> I guess it makes sense in parsec because it's going to have to go through each element anyway
11:56:28 <mm_freak> applicative_: yes, that's a special-purpose class
11:57:00 <erisco> I'll have to play with this more. I can't extrapolate this far
11:57:30 <erisco> thanks for the explanations. I'll use a list for now and hopefully can understand what is being said in the future
11:57:31 <mm_freak> erisco: the best way is to try to implement it yourself =)
11:58:40 <mm_freak> erisco: as a side note you will find that cons and uncons together give rise to an isomorphism between [] and any type you make an instance of that class =)
12:01:21 <danharaj> > [1..10] & (upon.view.upon) tail %~ reverse
12:01:24 <lambdabot>   mueval-core: Time limit exceeded
12:06:23 <applicative_> erisco: I think I read that list syntax will be overloadable in coming ghc's .  That's sure to cause amusing chaos
12:06:26 <aCube> Can I use quickcheck to generate a list of exactly length n
12:06:51 <aCube> ?
12:07:23 <applicative_> you can put a condition on a test, but that might not be a great idea
12:07:36 <applicative_> @check \x -> 3
12:07:38 <lambdabot>   Not in scope: `myquickcheck'
12:07:43 <applicative_> :(
12:07:59 <aCube> There is no better way? :(
12:08:13 <Clint> use a special type?
12:08:39 <aCube> Does GHC.TypeLits.Nat also exist in GHC 7.4?
12:13:18 <erisco> >:t []
12:13:32 <erisco> :t []
12:13:34 <lambdabot> [a]
12:14:25 <erisco> data ([] a) => ListView a
12:14:39 <erisco> not sure where I am going wrong with this, but it is an error
12:14:50 <erisco> I guess it doesn't make sense...
12:14:58 <Eduard_Munteanu> [] is not a typeclass
12:15:01 <erisco> yeah
12:15:38 <coppro> erisco: you simply do ListView a, and refer to [a]
12:15:56 <coppro> however, I strongly recommend looking at Tarversable in lens
12:15:57 <erisco> coppro, right, I did this. I am confused on another part but I'll work on it
12:16:00 <coppro> *Traversible
12:16:10 <elliott> Traversable is in base
12:16:11 <erisco> coppro, I've determined Traversable to not be suitable for my need
12:16:16 <coppro> why?
12:16:25 <erisco> coppro, when I say "view" I don't mean the same thing as in Traversable
12:16:55 <erisco> and lens is beyond my comprehension at this point
12:17:10 <coppro> what are you trying to do?
12:17:20 <erisco> I want to do it myself, thanks
12:17:37 <coppro> uh ok
12:17:37 * hackagebot vector-heterogenous 0.1.0 - A type-safe library for vectors whose elements can be of any type, or any type satisfying some constraints  http://hackage.haskell.org/package/vector-heterogenous-0.1.0 (MikeIzbicki)
12:18:16 <elliott> oh.
12:18:21 <elliott> that must be why that took so long.
12:19:01 <trescenz_> ok so if I imported Data.Map as Map and I use Map in type definitions why, in the same file, when I want to use it in a function is it telling me that the data constructor Map.Map isn't in scope?
12:19:59 <Eduard_Munteanu> trescenz_: it doesn't export the constructor for Map
12:20:20 <trescenz_> huh well that's kinda annoying
12:20:24 <Eduard_Munteanu> You don't need it anyway. I guess you mentioned 'Map' in a term rather than type.
12:20:57 <Eduard_Munteanu> trescenz_: paste some code
12:22:29 <trescenz_> Eduard_Munteanu: sure give me a sec though my internet is going really slow right now
12:25:56 <applicative> aCube: here's a trivial demo  agen :: Int -> Gen (Bool) ; agen n = liftM2 (\x y -> length x == length y ) (vector n) (vector n);   > quickCheck (agen 5)  "Okay passed 100 tests"
12:26:37 <applicative> the vector generator restricts the lists to the given length, aCube
12:27:33 <aCube> @ty vector
12:27:34 <lambdabot> Not in scope: `vector'
12:28:19 <hpaste> trescenzi pasted “Eduard_Munteanu” at http://hpaste.org/86085
12:28:42 * Eduard_Munteanu suddenly feels sticky
12:28:45 <parcs> > sqrt (0/0)
12:28:46 <trescen__> Eduard_Munteanu: Ignore the fact that the design is really terrible and that it's a map to a map
12:28:47 <lambdabot>   NaN
12:29:31 <Eduard_Munteanu> trescen__: you don't pattern-match on Map
12:29:57 <trescen__> Eduard_Munteanu: then how would I decompose that?
12:30:04 <applicative> aCube: what do you want to test
12:30:26 <Eduard_Munteanu> trescen__: if you want a list of all values in a Map you can use toList
12:30:42 <trescen__> Eduard_Munteanu: right I have a map of maps though and I want to fold it into a list of lists
12:31:03 <trescen__> I tried map (Map.toList) (Map.toList x)
12:31:08 <trescen__> but it didn't like that
12:31:37 <aCube> applicative: nvm, I don't really need a random list. It's enough if I use a list of some predefined value
12:32:25 <Eduard_Munteanu> @hoogle Map.toList
12:32:25 <lambdabot> Data.Map toList :: Map k a -> [(k, a)]
12:32:25 <applicative> a list of any length, but all the same elements?
12:32:33 <Eduard_Munteanu> trescen__: look at the type
12:32:46 <aCube> applicative: yes, but that one is easy :D
12:32:54 <Eduard_Munteanu> trescen__: you want elems instead
12:32:58 <trescen__> Eduard_Munteanu: yea makes more sense now
12:33:02 <Eduard_Munteanu> :t Map.elems
12:33:04 <lambdabot> Couldn't find qualified module.
12:33:08 <Eduard_Munteanu> :t Data.Map.elems
12:33:09 <lambdabot> M.Map k a -> [a]
12:34:15 <trescen__> Eduard_Munteanu: I'm not used to type signatures being super helpful yet
12:35:32 <dmwit> :t M.elems
12:35:34 <lambdabot> M.Map k a -> [a]
12:35:39 <dmwit> :t M.elems >=> M.elems
12:35:41 <lambdabot> M.Map k (M.Map k1 c) -> [c]
12:37:46 <neutrino> scala has null ????
12:37:58 <neutrino> wow, in this century?
12:38:12 <nlogax> Maybe for Java compatibility?
12:38:15 <nlogax> No pun intended
12:38:23 <divarvel> hi, I'm using optparse-applicative, and I'd like to unit-test the parser. Does anyone have examples of using it in a pure way?
12:38:31 <neutrino> nlogax: hahaha.
12:38:32 <divarvel> neutrino: yup, needed for java interop :(
12:38:34 <neutrino> well
12:38:35 <dmwit> But pun resulted, and you get punished accordingly!
12:38:38 <neutrino> it's a sad state of things
12:38:40 <nlogax> :D
12:38:55 <divarvel> neutrino: nobody uses it though, but it's still there
12:39:14 <ocharles> divarvel: can't you just use runParser and pass in a bunch of strings, and then check that the parsed structure is what you'd expect?
12:39:37 <divarvel> ocharles: runParser returns an instance of MonadP
12:39:54 <neutrino> divarvel: it's not about anyone using it.. it's about things possibly being null
12:39:54 <divarvel> I don't know which type I can use
12:40:04 <divarvel> neutrino: I know.
12:40:41 <dmwit> divarvel: execParserPure looks like a fairly reasonable type to me
12:40:42 <divarvel> ocharles: there is also execParserPure, but it takes other arguments (ParserPrefs)
12:40:44 <ocharles> divarvel: hmm, yes - that is a annoying
12:41:04 <dmwit> divarvel: So... make a value of type ParserPrefs?
12:41:07 <divarvel> dmwit: execParserPure takes parserPrefs and parserinfo
12:41:41 <dmwit> I don't understand why that's a problem.
12:41:42 <ocharles> ParserInfo is what execParser takes
12:42:15 <ocharles> and ParserPrefs is something you can construct
12:42:27 <divarvel> yep
12:43:03 <divarvel> I was just looking for something with a simpler signature
12:43:09 <divarvel> but it's not that bad
12:43:12 <divarvel> thanks :)
12:44:40 <dmwit> divarvel: What things are instances of MonadP?
12:45:19 <divarvel> dmwit: the result of runParser
12:45:35 <dmwit> No, what types are instances of MonadP?
12:46:12 <dmwit> (What types can runParser's type specialize to?)
12:46:49 <divarvel> dmwit: oh sorry.
12:47:01 <divarvel> dmwit: I'm perusing through the doc
12:47:17 <neutrino> anyone know the difference between type parameters and type arguments in scala?
12:47:49 <divarvel> dmwit: I haven't found yet
12:49:48 * dmwit notes that optparse-applicative comes with a "tests" directory which probably has some tests in it that could be used for inspiration.
12:52:32 <divarvel> dmwit: I've read them.
12:53:14 <divarvel> the examples show how to construct parsers, not how to use them in a pure fashion
12:53:21 * divarvel is still able to RTFM
12:53:37 <divarvel> all the examples use execParser
12:53:57 <neutrino> can i have def's only inside a class?
12:54:04 <neutrino> what about val's? can i have those outside of a class?
12:54:31 <dmwit> divarvel: I am looking at a file full of tests that call execParserPure all over the place and execParser nowhere.
12:54:37 <neutrino> argh, sorry, wrong window
12:54:40 <divarvel> oh.
12:55:04 <divarvel> dmwit: I must be looking at the wrong examples.
12:55:21 <divarvel> dmwit: if you could tell me which file, it would be even more useful
12:55:33 <dmwit> tests/Tests.hs
12:56:30 <Eiam> ha, saw this position when I was browsing and I thought someone in #haskell might think it would be up their alley, https://jobs.apple.com/us/search?jobFunction=SFWEG#&ss=26727006&t=0&so=&j=SFWEG&lo=0*USA&pN=0&openJobId=26727006
12:57:11 <Eiam> unfortuntely it doesn't seem to ask for Haskell but hey, thats why you start there right? to change that? ha ha ;)
12:57:16 <divarvel> dmwit: thx, I was in examples
12:57:39 <dmwit> what is this
12:57:45 <dmwit> What does this have to do with #haskell at all?
12:57:59 <jfischoff> Eiam: no
12:58:01 <mauke> spam?
12:58:08 <dmwit> spam.
12:58:14 <Eiam> oh yeah, I'm spamming you =/
12:58:18 <dmwit> I mean, it looks like a real job listing.
12:58:21 <Eiam> seriously I've been in here for like a year
12:58:23 <Eiam> sheesh
12:58:25 <dmwit> But it's not on-topic here, as far as I can tell.
12:58:44 <Eiam> data analysis & research?
12:58:49 <Eiam> totally off topic I guess.
12:58:54 <Eiam> with computers
13:00:01 <mauke> yes
13:00:59 <__xc> > |..]
13:01:01 <lambdabot>   <hint>:1:1: parse error on input `|..'
13:01:02 <Eiam> *shrug* sorry then
13:01:11 <__xc> > [..]
13:01:13 <lambdabot>   <hint>:1:2: parse error on input `..'
13:01:35 <__xc> > [..1,3..]
13:01:36 <lambdabot>   <hint>:1:2: parse error on input `..'
13:01:41 <dmwit> < U.universe :: [Word8]
13:01:46 <goodfellow>   mueval-core: Time limit exceeded
13:01:49 <dmwit> oh come on
13:01:53 <Rants> > -- parse error on input: everything
13:01:55 <dmwit> < U.universe :: [Word8]
13:01:55 <lambdabot>   not an expression: `-- parse error on input: everything'
13:01:59 <goodfellow>   mueval-core: Time limit exceeded
13:02:43 <dmwit> weird
13:03:19 <dmwit> Anyway, the universe package does more or less what I would expect you want from something like [..].
13:03:42 <dmwit> < filter odd (U.universe :: [Int])
13:03:43 <goodfellow>   [-9223372036854775807,-9223372036854775805,-9223372036854775803,-9223372036...
13:03:52 <dmwit> < filter odd U.universe
13:03:53 <goodfellow>   [1,-1,3,-3,5,-5,7,-7,9,-9,11,-11,13,-13,15,-15,17,-17,19,-19,21,-21,23,-23,...
13:06:48 <dmwit> < let a ... b = filter (\x -> x `mod` (b-a) == a `mod` (b-a)) U.universe in 1 ... 3 :: [Word8]
13:06:50 <goodfellow>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
13:06:58 <dmwit> < let a ... b = filter (\x -> x `mod` (b-a) == a `mod` (b-a)) U.universe in 1 ... 3 :: [Int8]
13:07:00 <goodfellow>   [-127,-125,-123,-121,-119,-117,-115,-113,-111,-109,-107,-105,-103,-101,-99,...
13:08:16 <__xc> Neural netwoks are non deterministic right?
13:08:45 <__xc> generally speaking
13:08:53 <Eduard_Munteanu> Um, why?
13:09:20 <__xc> just asking, it's a sort of biased system
13:09:28 <__xc> the ENN's
13:09:33 <__xc> ANN's*
13:10:10 <neutrino> types in scala can be covariant or contravariant to their type parameters. does this exist in haskell?
13:10:11 <__xc> empirical, biased
13:10:40 <neutrino> are there even such things as subtypes in haskell? because i'm not sure
13:10:45 <Eduard_Munteanu> neutrino: no
13:10:54 <impostor-tac> subtypes are evil :P
13:10:55 <neutrino> that fixes it then
13:11:01 <neutrino> type classes for the win
13:11:02 <ion> @type U.universe
13:11:04 <lambdabot> Couldn't find qualified module.
13:11:12 <Eduard_Munteanu> There is the notion of a type variable appearing in a covariant or contravariant position, but it's different.
13:11:23 <__xc> but yes they are adapted where there is no unique algotithm that tells a solution
13:11:27 <ion> What’s U.universe?
13:11:43 <neutrino> Eduard_Munteanu: ok
13:11:44 <neutrino> thx
13:12:50 <__xc> Eduard_Munteanu, could a random generator be implmented as a NN?
13:13:43 <Eduard_Munteanu> __xc: a PRNG? Maybe, if there's some sort of feedback (to preserve some state).
13:14:02 <nooodl> ion: http://hackage.haskell.org/package/universe
13:14:13 <ion> thanks
13:15:34 <__xc> Eduard_Munteanu, ok, just asking the 'feedbacking' is actually what differentiate a NN from an algo?
13:16:02 <Eduard_Munteanu> __xc: no
13:25:03 <Blablu> How can I use logical operations in mongodb querys with the haskell binding of mongodb?
13:27:34 <jfischoff> there is also #yesod that might be able to help.
13:28:14 <Blablu> But I'm not even using yesod
13:28:26 <jfischoff> they still might know
13:28:44 <Blablu> true
13:31:09 <Taneb> (I've asked for help in the Snap channel when using Happstack before)
13:31:21 <parcs> > []
13:31:23 <lambdabot>   []
13:32:27 <donri> Taneb: there is #happs you know
13:32:39 <Taneb> donri, I was asking for help with Heist
13:32:52 <donri> okies, that's certainly on topic in #snapframework :)
13:33:10 <Blablu> I'll start with snap and work my way through. I don't want to spam around everywhere
13:33:55 <Taneb> I think once I ended up asking a question in all three web framework channels
13:34:07 <Taneb> (I like to mix and match)
13:34:41 <stepkut> Taneb: :)
13:34:56 <stepkut> Taneb: don't forget #haskell-web!
13:35:00 <trescen__> how do you assign a character value of $? i tried '$' and '\\$' but it still parsed those as operators
13:35:05 <Taneb> I'll have to make a note of that!
13:35:17 <Taneb> > let x = '$' in x
13:35:19 <lambdabot>   '$'
13:35:20 <geekosaur> trescen__, then you're doing something wrong
13:35:26 <stepkut> I'm pretty sure #haskell-web is pretty dead
13:35:32 <donri> stepkut: there's all of 7 people in there!
13:35:34 <trescen__> ok that's weird
13:35:47 <Taneb> Are you sure you're using the right quote marks?
13:35:56 <Taneb> > let x = `$` in x
13:35:58 <lambdabot>   <hint>:1:9: parse error on input ``'
13:36:00 <trescen__> of course I was trusting my syntax highlighter
13:36:01 * donri sorta wishes #haskell-web and the web ml was more alive and there was more active collab between the frameworks
13:36:04 <trescen__> no I was just being stupid
13:38:27 <erisco_> :t isPrefixOf
13:38:28 <lambdabot> Eq a => [a] -> [a] -> Bool
13:42:40 <erisco_> how can I split off a string prefix?
13:43:17 <erisco_> splitPrefix :: [a] -> Maybe ([a], [a])
13:43:58 <hpc> :t break
13:44:00 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
13:44:12 <Eduard_Munteanu> @hoogle stripPrefix
13:44:12 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
13:44:12 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
13:44:12 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
13:44:18 <Cale> well, there's
13:44:20 <hpc> > break (== 'g') "abcdefghijklmnop"
13:44:22 <lambdabot>   ("abcdef","ghijklmnop")
13:44:22 <Cale> :t stripPrefix
13:44:23 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
13:44:39 <Cale> > stripPrefix "abc" "abcdefg"
13:44:41 <lambdabot>   Just "defg"
13:44:45 <Cale> > stripPrefix "abc" "xbcdefg"
13:44:47 <lambdabot>   Nothing
13:44:54 <hpc> erisco_: you should specify what kind of prefix you mean
13:45:05 <erisco_> Cale, that is sufficient, thanks
13:45:46 <shachaf> > preview (strippingPrefix "abc") "abcdefg"
13:45:48 <lambdabot>   Just "defg"
13:46:00 <Cale> heh
13:46:38 <DanBurton> @type preview . strippingPrefix
13:46:40 <lambdabot> (Eq a, MonadReader [a] m) => [a] -> m (Maybe [a])
13:46:43 <shachaf> > strippingPrefix "abc" # "defg" -- it works the other way too!
13:46:46 <lambdabot>   "abcdefg"
13:47:15 <shachaf> @let prefixed = strippingPrefix
13:47:17 <donri> > "abcdefg" & strippingPrefix "abc" %~ map toUpper
13:47:17 <lambdabot>  Defined.
13:47:19 <Cale> > preview (prefixed "pre") "preview"
13:47:19 <lambdabot>   "abcDEFG"
13:47:21 <lambdabot>   Just "view"
13:47:40 <donri> > "abcdefg" & strippingPrefix "abc".mapped %~ toUpper
13:47:41 * hackagebot groundhog 0.3.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.3.0 (BorisLykah)
13:47:42 <lambdabot>   "abcDEFG"
13:48:31 <mvb> is there some special condition that needs to be met with regarding to networking if i want to be able to open up 2 sockets on the same system and communicate between them? like i can do it on windows but i have a little embedded systems (proprietary) and i can open several sockets but icant communicate via them. i can have several sockets that are connected to a pc but cant connect to sockets
13:48:31 <mvb> on the same computer. i relaize this is very hard for someone else to answer but mayeb there is soem general asnwer...
13:49:37 <DanBurton> mvb: is there some Haskell-specific component to your question?
13:50:10 <Cale> I don't really understand what's being asked... that doesn't sound very much like something which ought to require special setup?
13:50:13 <Tene> mvb: No, no special condition at all; I make connections to the same host every day.
13:52:41 * hackagebot groundhog-th 0.3.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.3.0 (BorisLykah)
13:52:43 * hackagebot groundhog-sqlite 0.3.0 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.3.0 (BorisLykah)
13:52:45 * hackagebot groundhog-postgresql 0.3.0 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.3.0 (BorisLykah)
13:52:47 * hackagebot groundhog-mysql 0.3.0 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.3.0 (BorisLykah)
13:57:42 * hackagebot up 0.1.0.1 - Generates pathnames to up directories  http://hackage.haskell.org/package/up-0.1.0.1 (ThomasEding)
14:45:13 <scooty-puff> i was experimenting with unification-fd and implementing the zebra benchmark, but was having trouble - i could not get away from there being a single monolithic type that can take part in unification
14:46:37 <scooty-puff> i would like data List a b = Nil | a :| b deriving ...; data House a = House a a a a a, or some such, but insteadhave to do data Term a = Nil | a :| a | House a a a a a | Englishman | ...
14:47:43 * hackagebot io-streams 1.0.2.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.0.2.0 (GregoryCollins)
14:47:53 <scooty-puff> is it possible to have many types that mutually take part in unification?
14:48:40 <bscarlet> I've suddenly started getting only a screenful of garbage characters from http://www.yesodweb.com, but only under Safari. Does anyone else running Safari see this weird behavior?
14:52:28 <bscarlet> (I've cleared my caches, etc.)
14:52:53 <int-e> bscarlet: I see it under firefox (iceweasel branding)
14:54:24 <bscarlet> int-e: Hmm. I do see it under Safari on OS X and on iOS, but I don't see it on Firefox on OS X.
14:55:56 * geekosaur not seeing it in safari in os x, fwiw
14:56:18 <int-e> bscarlet: looks like an undeclared compressed (zlib?) transfer encoding to me.
14:57:27 <int-e> though actually, no. there are *two* Content-Encoding: gzip headers in the reply. odd?
14:57:40 <bscarlet> int-e: Yeah, I saw that.
14:57:51 <int-e> (and wireshark is misbehaving :/)
14:58:33 <bscarlet> Well, it's not just me. That's reassuring.
14:59:01 <bscarlet> Thanks.
14:59:06 <Tene> int-e: what trouble with wireshark?
14:59:09 <int-e> bscarlet: and that's what it is - it's compressed twice.
14:59:28 <bscarlet> int-e: aha!
14:59:39 <int-e> Tene: the "follow tcp stream" window isn't reizing properly, so I only have a very small text box.
14:59:45 <Tene> Ahh.
14:59:50 <bscarlet> (Shouldn't that be Content-Encoding: gzip . gzip?
14:59:53 <bscarlet> )
15:00:11 <int-e> nah, it just ... oh you're joking.
15:03:42 <bscarlet> int-e: yeah, though apparently just barely. Without making any claims about standards, some implementations appear to use "Content-Encoding: gzip, gzip".
15:03:47 <bscarlet> Anyway, thanks.
15:13:39 <jfischoff> is there a simple to launch an external process with a timeout?
15:14:33 <typoclass> jfischoff: maybe forking the process, then doing forkIO with something like "threadDelay ... ; kill external process"?
15:14:58 <donri> :t System.Timeout.timeout
15:15:00 <lambdabot> Int -> IO a -> IO (Maybe a)
15:15:21 <donri> although it probably doesn't kill the process
15:15:31 <jfischoff> typoclass, donri: the combination of your answers will work
15:15:46 <jfischoff> but I want a package that provides the functionality as a function :)
15:16:01 <typoclass> ... magnificent stereo of the sound of one hand clapping ...
15:17:02 <otters> why do so many library functions in System take Ints instead of Integers?
15:17:05 <hpc> donri: that function has some fairly major limitations even sticking to just IO actions
15:17:06 <clahey_> jfischoff: What do you mean by with a timeout?
15:17:19 <clahey_> jfischoff: Should the external one die after the timeout?
15:17:22 <hpc> otters: in System, or in general?
15:17:28 <jfischoff> clahey_: yes
15:17:33 <hpc> for System, Int is a wrapper for Int#, which is a machine int
15:17:41 <otters> hpc: in System
15:17:42 <hpc> for other things, old design decisions
15:17:56 <clahey_> jfischoff: And do you want the function to return instantly?
15:17:57 <hpc> Integer uses libgmp for bignums
15:18:04 <otters> oh, is that it?
15:18:06 <clahey_> jfischoff: Or after the external process is ended?
15:18:15 <otters> because I like being able to timeout for longer than maxBound microseconds, sometimes
15:18:17 <hpc> which obviously makes it hard to interop with low-level stuff
15:18:18 <jfischoff> clahey_: I don't care
15:18:31 <otters> well, a high level version could still be provided
15:18:35 <clahey_> jfischoff: And you don't need the response from the external process.
15:18:47 <jfischoff> clayey_: I do need the response
15:18:55 <hpc> otters: that timeout function has issues dealing with stuff like foreign calls
15:18:56 <otters> like, pattern match on the result of Timeout and recurse if it fails
15:19:00 <otters> right
15:19:01 <clahey_> jfischoff: Then you obviously need to wait for the function to end, no?
15:19:09 <hpc> you'd likely be better off writing your own timeout logic anyway
15:19:09 <jfischoff> clahey_: is there is one
15:19:12 <clahey_> The external process.
15:19:19 <clahey_> Not the function.
15:19:21 <typoclass> otters: i guess the biggest problem is with threadDelay, because iirc, for 32 bit systems threadDelay maxBound will only wait 35 minutes or something. and people could reasonably want to wait for say an hour
15:19:26 <jfischoff> clahey_: at some point yest
15:19:34 <otters> yeah, typoclass that's exactly my point
15:19:40 <otters> so you have to recurse
15:19:49 <otters> I had to implement something similar for IO when I wanted to timeout after 180 seconds
15:20:04 <hpc> i am going to go ahead and be the jerk who says get a 64-bit system
15:20:05 <typoclass> otters: yes, absolutely. that recursing should be in a library function
15:20:26 <otters> yeah hpc, so I installed debian amd64 on my VPS, and now I can't run old Skype versions anymore
15:20:37 <otters> and old Skype versions don't have a broken API
15:20:53 <otters> so now I can't use bitlbee and skype, but at least I get to threadDelay for much longer
15:21:09 <clahey_> jfischoff: I don't actually know, come to think of it.
15:21:23 <clahey_> jfischoff: Actually, maybe I would write a shell one liner.
15:21:33 <hpc> otters: if they link with 32-bit libraries, it's likely you can find them somewhere in apt
15:21:41 <otters> yeah, that's what I thought
15:21:47 <hpc> i don't remember how to actually trick those things into using the 32-bit libs though
15:21:57 <typoclass> hpc: i'm gonna be the jerk who says, just get a 32 bit system
15:21:59 <typoclass> ;-)
15:22:00 <hpc> just that (from others' experience with 32-bit java) it is an enormous pain
15:22:03 <otters> I installed the 32 bit libs, but damn thing just gives up
15:22:08 <otters> exits with a 0 status code, too
15:22:14 <hpc> hmm
15:22:25 <otters> but even skype 2.0 uses crazy amounts of RAM, so fuck it, I'll run the actual skype client on my own
15:22:47 <typoclass> (that was a joke satirizing the earlier comment, just to be clear)
15:23:01 <otters> it's weird that the last working version of the skype API was released right when microsoft acquired skype
15:27:31 <lunarjar> I have a 2d array how do I putIntoCrate "A" 1 so that it puts into crate[0][0]
15:29:29 <Peaker> lunarjar, you mean something like:   putIntoCrate :: String -> (Int,Int) -> Array (Int,Int) String -> Array (Int,Int) String ?
15:29:59 <Botje> lunarjar: you can index your arrays by Chars as well, I think
15:30:03 <Botje> (should you somehow want that.)
15:31:51 <latro`a> :t undefined :: Array Char Int
15:31:52 <lambdabot> Array Char Int
15:32:07 <latro`a> :t undefined :: Array (Char->Char) Int
15:32:09 <lambdabot> Array (Char -> Char) Int
15:32:22 <latro`a> :t (undefined :: Array Char Int) ! 'a'
15:32:23 <lambdabot> Int
15:32:36 <Botje> @instances Ix
15:32:37 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
15:32:43 <lispy> Cale: I'm rebooting the linode to have 1GB of rame
15:32:45 <Botje> bleah.
15:32:46 <lispy> ram, even
15:32:46 <latro`a> :t (undefined :: Array (Char->Char) Int) ! (const 'a')
15:32:48 <lambdabot>     No instance for (Ix (Char -> Char))
15:32:49 <lambdabot>       arising from a use of `!'
15:32:49 <lambdabot>     Possible fix: add an instance declaration for (Ix (Char -> Char))
15:32:51 <latro`a> there we go
15:32:55 <latro`a> so it is nindeed an Ix
15:32:58 <latro`a> *indeed
15:33:01 <lispy> So, sorry everyone lambdabot is going away until Cale can reboot it
15:33:51 <Clint> :-O
15:34:14 <lispy> Well, that is assuming I can figure out how to active the free upgrade :)
15:35:14 <lunarjar> Peaker, putIntoCrate :: [[Char]] -> Char -> Char -> [[Char]]
15:35:49 <Peaker> lunarjar, i don't understand how the Char indexes the [[Char]]
15:35:50 <lunarjar> Peaker, putIntoCrate :: [[Char]] -> Int -> Char  -> [[Char]]
15:36:08 <Peaker> how does the Int index the [[Char]]?
15:36:48 <lunarjar> putIntoCrate crate 1 "A" should give me a crate with index 1 filled with "A"
15:37:02 <lunarjar> I didn't implement the indexing yet
15:37:04 <lunarjar> don't know how
15:37:18 <Peaker> lunarjar, an Int indexes a single list ordinarily. how do you make it index two?
15:37:48 <cmccann> oh noooooo lambdabot :[
15:38:03 <lunarjar> Peaker, [0][0] = 1 [0
15:38:09 <lunarjar> Peaker, [0][0] = 1 [0][1
15:38:16 <lunarjar> Peaker, [0][0] = 1 [0][1] = 2 and so on
15:38:23 <lunarjar> sorry for spam
15:39:36 <lunarjar> Peaker, [0][0] = 1 [0][1] = 2 [0][2] = 3 [1][0] = 4 am I explaining any good?
15:40:36 <lunarjar> or is it easier to make putIntoCrate crate x y "A"
15:41:52 <Peaker> lunarjar, each row has 3 in it?
15:43:19 <lunarjar> it can be more
15:43:24 <lunarjar> not defined
15:43:56 * tgeeky just gets here
15:45:08 <lunarjar> a crate is a data type it can have "A", "O" or Empty, it can be any size[x][y]
15:45:14 <tgeeky> lunarjar: you said it's a 2d array. You are saying you want the two dimensions to genuinely have a different type?
15:45:43 <lunarjar> tgeeky, I didn't understand your question
15:46:01 <lunarjar> I want to change the value inside crate[x,y]
15:48:09 <timofonic1> Hello guys
15:48:52 <tgeeky> lunarjar: if x and y are of the same type (say, Int), then you can reduce them to a single index (x * y = z) and index from [0..z]
15:49:47 <Eduard_Munteanu> timofonic1: hi
15:52:34 <timofonic1> I know this is totally unrelated, but I'm trying to pass the entry exam to a vocational school and study a computer programming course. I need to understand how to solve a degree two equation (quadratic?) but I'm unable to understand the process http://nopaste.me/paste/8726760735170790058106
15:53:15 <timofonic1> I don't have enough friends able to help me at maths, and it's a known belief haskell devs are math nerds. So maybe someone could help me at it :)
15:53:39 <DMcGill_> timofonic1: try ##math :)
15:53:57 <timofonic1> DMcGill_: Oh. It exists? Thanks!
15:54:16 <tgeeky> timofonic1: also, use http://www.wolframalpha.com/input/?i=11%28x-1%29%C2%B2%3D%282x-3%29%C2%B2%2B4x%C2%B2%2B1
15:54:27 <tgeeky> evidently step-by-step solutions cost a membership now
15:54:36 <timofonic1> tgeeky: Damn
15:55:04 <typoclass> timofonic1: have you googled for the subject? maybe there's tutorials available that explain how to do this
15:55:22 <tgeeky> timofonic1: obviously (1.) and (5.) are just expansion of squares
15:55:26 <cmccann> tgeeky: yeah wolfram alpha got kinda way less useful at some point
15:55:34 <cmccann> I remember it used to actually do neat stuff
15:55:40 <lunarjar> tgeeky, but how do I access it(preferably with x, y)
15:56:21 <cmccann> but frankly wolfram alpha was never useful enough to pay for before so I'm not sure why anyone would want to now :T
15:56:38 <tgeeky> it does some pretty coold things
15:56:40 <k00mi> timofonic1: maybe khanacademy.org has something helfpul to you, they do real nice tutorials
15:56:52 <tgeeky> i have some bookmarks and screenshots of some pretty nice results
15:59:26 <timofonic1> Uhm
15:59:33 <Cale> @bot
15:59:39 <lambdabot> :)
15:59:59 <cmccann> yay lambdabot!
16:01:05 <timofonic1> k00mi: It solved it, but at this moment it also confuses me with more "sophisticated" ways for solving second degree equations...
16:06:06 <k00mi> well, I can't tell you how much you have to learn
16:06:26 <k00mi> personally, I was only teached how to use the quadratic equation in school
16:15:34 <timofonic1> I see, no prob :)
16:16:24 <timofonic1> The wolfram alpha step by step (it gives 3 free ones per day) confused me even more. It changes the way symbols are, possibly to solve it in another less step way or whatever the computer wants
16:17:37 <parcs> :k BOX
16:17:41 <lambdabot> Not in scope: type constructor or class `BOX'
16:18:13 <geekosaur> kinds don't have kinds, they *are* kinds :p
16:19:42 <eikke> geekosaur: oh come on, higher kinded kinds should go in Haskell2014
16:22:01 <parcs> lies
16:22:03 <parcs> :k Constraint
16:22:05 <lambdabot> BOX
16:22:45 <parcs> :k GHC.Prim.BOX
16:22:46 <lambdabot>     Not in scope: type constructor or class `GHC.Prim.BOX'
16:22:59 <parcs> BOX :: BOX
16:25:02 <numberten> is there random support for the word8 datatype?
16:25:39 <parcs> yes!
16:25:48 <parcs> :t randomIO :: IO Word8
16:25:49 <lambdabot> IO Word8
16:27:01 <numberten> oh great thanks
16:27:29 <int-e> . o O ( make_present :: a -> Box; make_present = unsafeCoerce )
16:29:21 <numberten> looks like I was looking through an older random library
16:36:21 <ion> int-e: hah
16:36:48 <ion> hide :: a -> Void; hide = unsafeCoerce
16:37:08 <int-e> ion: the fun part is that this is perfectly safe; it's when unpacking the present that you may get nasty surprises :)
16:37:14 <ion> indeed
16:37:38 <ion> Although… this applies to unsafeCoerce in general. ;-)
16:37:50 * hackagebot hakyll-agda 0.1 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1 (FrancescoMazzoli)
16:42:49 * hackagebot unpack-funcs 0.3.1 - Monad transformers that mirror worker-wrapper transformations.  http://hackage.haskell.org/package/unpack-funcs-0.3.1 (LouisWasserman)
16:51:15 <trescenzi> is there a head that instead of erroring returns an empty list?
16:51:46 <geekosaur> head doesn't return a list, so how could it do that?
16:52:07 <eikke> :hoogle [a] -> Maybe a
16:52:22 <eikke> lambdabot: hoole [a] -> Maybe a
16:52:26 <eikke> grrr
16:52:29 <trescenzi> lol yea
16:52:38 <geekosaur> but try ```take 1 list``` if you want a list consisting of the head, or an empty list
16:52:39 <nade> Hey all, I came across typeclass definition that looked this: "data Foo a b = Bar a ( s ( Foo a b ))" and I wasn't sure what to make of it. What would s or a be?
16:53:12 <Eduard_Munteanu> @hoogle safeHead
16:53:13 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
16:53:26 <geekosaur> that's not a typeclass... if you mean it was *inside* some class definition, then it is an associated type
16:53:39 <eikke> trescenzi: you'll most likely find what you want in the 'safe' library
16:54:18 <trescenzi> ok eikke. I'm just going to write a specific one. It doesn't matter too much in my case what is actually returned
16:54:24 <nade> geekosaur: eh sorry im new. Bar would be the constructor right?
16:54:34 <skeet70> I need to match a particular attribute of a datatype in a list of that datatype (which is inside another datatype/list). What's the best way to go about it?
16:54:35 <nade> oh
16:54:37 <nade> yeah
16:54:41 <geekosaur> yes
16:54:52 <nade> geekosaur: Eq et all are typeclasses
16:55:00 <eikke> trescenzi: depending on your needs, something like "maybeHead :: a -> [a] -> a" could make sense as well
16:55:06 <geekosaur> yes, but "data" does not declare a typeclass
16:55:09 <nade> yeah
16:55:11 <parcs> can an associative operator have an arity that is not 2?
16:56:14 <trescenzi> eikke: yea that's the sort of thing I'm returning
16:56:21 <nade> anyways, I understand some aspects of the type system, but I don't get what that snippet would be doing.
16:56:21 <nade> I
16:56:40 <nade> understand how you can use recursive definitions
16:56:40 <Eduard_Munteanu> parcs: no, but now you can upgrade to Agda for FREE! We provide the best mixfix out there.
16:56:41 <kadoban> parcs: i don't think so
16:57:02 <geekosaur> I don't know where the ```s``` came from there, which makes me think it's incomplete
16:57:48 <geekosaur> a is a parameter to the type, as is b
16:57:57 <nade> geekosaur: Okay, it was taken out of context I saw it here
16:57:59 <nade> http://www.willamette.edu/~fruehr/haskell/lectures/tutorial6.html#@sli@43
16:58:25 <geekosaur> oh, so s a instead of a b
16:58:30 <nade> oh wohops yeah sorry
16:58:35 <geekosaur> so, have you seen the Either type yet?
16:58:36 <nade> my mistake
16:58:46 <nade> eh, i've seen it
16:58:49 <geekosaur> an example would be Either String Int
16:58:57 <nade> ok
16:59:07 <nade> or Maybe
16:59:08 <nade> ?
16:59:09 <geekosaur> mapped to that example s would be String and a would be Int
16:59:22 <geekosaur> @src Either
16:59:23 <lambdabot> Source not found. I am sorry.
16:59:25 <geekosaur> bah
16:59:36 <geekosaur> you'd think it would be in the database...
16:59:48 <geekosaur> data Either l r = Left l | Right r
17:00:30 <nade> yeah i've seen that. But never really used it.. So im not quite seeing how it would apply here
17:01:55 <geekosaur> so, the example they show is for a tree type GenTree; there is a value type ```a``` and a container type ```s```, and a Branch contains an ```a``` and a container ```s``` that can hold more ```GenTree s a``` subtrees
17:02:45 <geekosaur> you might, for an example, instantiate it as a tree of Int using lists as the container:  GenTree [] Int
17:02:51 * hackagebot TrieMap 4.1.0 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-4.1.0 (LouisWasserman)
17:02:53 <nade> what makes something a "container type"?
17:03:34 <geekosaur> it takes a parameter.  we typically write a list of ```thing``` as ```[thing]```, but in prefix form that is ```[] thing```
17:04:14 <nade> looking at maybe I don't see a difference
17:04:14 <nade> er Either
17:04:14 <nade> not maybe
17:04:15 <geekosaur> (not all such are necessarily useful for trees, though; consider what happens if you use ```Maybe```)
17:04:45 <lunarjar> how to change value in basket[x][y] ?
17:04:46 <geekosaur> (what happes is you don't get a tree, you get a list)
17:05:33 <geekosaur> lunarjar, you don't "change values" in Haskell
17:06:28 <Eduard_Munteanu> Also, that looks like C syntax.
17:07:00 <geekosaur> and I bet theyre usinng linked lists of linked lists...
17:07:11 <Eduard_Munteanu> If you want arrays, look at Data.Array. But for now you probably shouldn't.
17:07:25 <nade> okay. On a slightly different topic, can you generate new types in runtime? I feel like that doesn't really make sense in haskell, but I thought I might ask.
17:07:38 <Eduard_Munteanu> geekosaur: yeah those suck
17:07:40 <geekosaur> not really, no
17:07:58 <nade> that in response to me?
17:08:02 <jmcarthur> nade: i don't understand the question
17:08:14 <jmcarthur> what does it mean to generate a new type? why do you want it?
17:08:18 <kadoban> nade: afaik that doesn't make sense in haskell...is there some language where it does?
17:08:34 <kadoban> (besides like duck typed ones i guess)
17:08:37 <geekosaur> there are some ways to manipulate "types" at runtime, but you dont have either general introspection or general evaluation unless you embed the compiler in your program
17:08:40 <Eduard_Munteanu> Agda. :)
17:08:43 <lunarjar> I'm ok with basket[x][y] giving me a new basket that is changed
17:08:47 <jmcarthur> nade: you kind of can in a sense, but it's probably not what you are thinking
17:09:01 <lunarjar> changeBasket basket x y "a"
17:09:03 <geekosaur> lunarjar, you are still speaking C
17:09:04 <bitonic> nade: ‘Maybe’ is a type generator!
17:09:08 <nade> jmcarthur: heh yeah. I mean I was messing around with zippers. and I was trying to think of ways to generalize trees
17:09:23 <jmcarthur> and existential type is a new type in the sense that you can't tell what existing type it is equivalent to
17:09:26 <lunarjar> geekosaur, so how do you work in haskell with 2d arrays?
17:09:40 <geekosaur> Data.Array or the repa package
17:09:50 <bitonic> nade: yeah one thing you can’t do is to encode some concrete representation into a type
17:09:54 <jmcarthur> but even that is somewhat static. you can just give it an operational interpretation
17:10:03 <lunarjar> I need to change a value inside basket[x][y]
17:10:13 <Eduard_Munteanu> lunarjar: what is basket?
17:10:19 <bitonic> nade: which is useful to do cool stuff like have a generic representation for ADTs and the you automaticall ‘derive’ (pun intended) the zipper
17:10:36 <nade> bitonic: yeah I was thinking that. I had the feeling that even wanting to shows I don't quite appreciate the whole mindset
17:10:41 <jmcarthur> lunarjar: you could use an actual 2d array instead of nested linked lists, if you want...
17:10:53 <lunarjar> basket = [["a",a"],["a",a"],["a",a"]
17:11:06 <lunarjar> I have this
17:11:32 <bitonic> nade: in languages like Agda/Coq/Idris is very natural to do so
17:11:45 <bitonic> and it’s very very useful
17:11:57 <lunarjar> I want to change like in C basket[1][0] = "b", so to get ["a",a"],["b",a"],["a",a"]
17:11:59 <bitonic> but being able to do those things entails a lot of things
17:12:11 <jmcarthur> lunarjar: http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.4.0.1/Data-Array.html http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.4.0.1/Data-Array-MArray-Safe.html
17:12:13 <lunarjar> how to do that in haskell?
17:13:49 <parcs> woot!
17:14:49 <BadRadish> can someone assist me for a second?
17:15:02 <Eduard_Munteanu> BadRadish: just ask the question directly
17:15:13 <nade> another question. Given that most ( if not all ) things in haskell are "functions" what does it mean for something to be a function? They don't seem to represent some computation, given that type constructors are functions as well and they don't seem to "compute" something but rather classify it
17:15:15 <BadRadish> I'm using round
17:15:25 <BadRadish> and I'm getting an ambiguous type error
17:15:42 <Eduard_Munteanu> :t round
17:15:44 <lambdabot> (Integral b, RealFrac a) => a -> b
17:16:03 <Eduard_Munteanu> BadRadish: you can probably fix it with a type signature or ascription
17:16:10 <BadRadish> yeah but why do I have to specify the type just because it's a function?
17:16:11 <kadoban> nade: function being equal to a computation is a property of imperitive languages. here it's closer to the mathematical definition
17:16:28 <geekosaur> lunarjar: you don't do it at all easily, because that is a linked list of linked lists and as such is painful to work with. if you really must wokr with something like that, consider using Vector or Array
17:16:29 <lunarjar> jmcarthur, its a list not an array
17:16:30 <BadRadish> when I type it up with examples it works just fine
17:16:42 <Eduard_Munteanu> BadRadish: because you're probably using it in a context where multiple choices make sense and none is prefered (by e.g. defaulting rules)
17:17:01 <BadRadish> that's weird because it works when I just use numbers
17:17:02 <jmcarthur> lunarjar: i know, but you keep calling them arrays. i wasn't sure if you actually wanted arrays
17:17:25 <jmcarthur> lunarjar: also if you want to be indexing and such you want arrays anyway, not lists
17:17:37 <Eduard_Munteanu> BadRadish: you should paste some code probably
17:17:40 <BadRadish> anyway I tried doing type signatures but I don't understand how to specify that it's just an Integer to output
17:18:08 <BadRadish> okay I'll post it
17:18:17 <hpaste> BadRadish pasted “truncate troubles” at http://hpaste.org/86105
17:18:36 <dmwit> nade: The question is a bit philosophical.
17:18:52 <dmwit> I wonder. Suppose somebody answered the question to your satisfaction. How do you imagine your behavior would change as a result?
17:18:55 <BadRadish> the strange part is it runs just fine if I type in examples for the function using truncate.
17:19:18 <lunarjar> I'll go read first on arrays then ;)
17:19:44 <BadRadish> > 10+ truncate (5 * ((2 - 3) / 7))
17:19:46 <lambdabot>   10
17:19:57 <nade> well coming from using imperative languages, I feel like I really need to break away from all preconceptions about this stuff
17:19:59 <geekosaur> yes, because numeric literals are polymorphic
17:20:05 <geekosaur> BadRadish, ^^
17:20:24 <Eduard_Munteanu> :t 10+ truncate (5 * ((2 - 3) / 7))
17:20:25 <lambdabot> Integral a => a
17:20:29 <BadRadish> geekosaur: but not the variables I was using?
17:20:36 <Eduard_Munteanu> And it defaults to Integer.
17:20:52 <nade> I still think I don't quite think about this stuff "functionally". For instance I have still yet to feel like I
17:21:19 <jmcarthur> nade: "functional" is kind of a misleading term, depending on your prior exposure to the word
17:21:22 <nade> m describing relations as opposed to instructions
17:21:31 <dmwit> BadRadish: Perhaps you would like "fromInteger (truncate (x*step))" instead.
17:21:34 <geekosaur> BadRadish, the problem is you have findY whose parameter is Integral according to where it comes from, but you multiply it by step which is RealFrac. and to make things worse, step also is trying to divide an Integral by a RealFrac
17:21:42 <jmcarthur> nade: i prefer to call it "value oriented" programming. everything is a value
17:22:20 <jmcarthur> (or at least every term you can bind to a variable)
17:22:27 <technopredator> hello I need help with Leksah
17:22:31 <nade> but not values you'd find in imperative languages
17:22:44 <jmcarthur> nade: imperative languages have values too. they just aren't as pervasive
17:22:46 <dmwit> nade: Just start coding. Intuition comes from experience, not windbagging. =)
17:22:51 <geekosaur> BadRadish, try assigning types to all of: slope, findY, step, samples
17:23:15 <cmccann> dmwit: just a matter of windbagging in Haskell instead of in English really
17:23:18 <jmcarthur> nade: but i think the things you would think of as a value in an imperative language is probably pretty accurate
17:23:21 <geekosaur> remember that in Haskell, (/) will not operate on mixed types
17:23:26 <BadRadish> why does it work outside the function but not inside the function?
17:23:30 <BadRadish> > 10+ truncate (5 * ((2 - 3) / 7))
17:23:32 <lambdabot>   10
17:23:43 <geekosaur> because it promotes most of the literals to Double
17:23:47 <dmwit> > (10 :: Double) + truncate (5 * ((2-3) / 7))
17:23:47 <geekosaur> so that it can typecheck
17:23:48 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
17:23:48 <lambdabot>    arising from a use ...
17:23:50 <BadRadish> geekosaur: okay
17:23:55 <dmwit> BadRadish: See? It doesn't work.
17:24:14 <geekosaur> but this only works with literals, and will not work with your combination of equations
17:24:46 <geekosaur> because truncate is forcing a value to be Integral, but Haskell had to force that value to be RealFrac to make other things typecheck
17:25:21 <jmcarthur> nade: the only thing that is different here is that every expression is a value. there aren't really "statements" that "do" things.
17:25:22 <dmwit> BadRadish: You may find the following enlightening.:
17:25:24 <geekosaur> (and as a general rule, defaulting will cause an Integral to be resolved to Integer and a RealFrac to Double)
17:25:30 <dmwit> > (10, 10, 10) :: (Double, Int, Integer)
17:25:31 <lambdabot>   (10.0,10,10)
17:25:40 <nade> windbagging? : O I mean, I understand that the question might be a bit vague, but for instance what distinguishes a data type from a data constructor?
17:25:43 <BadRadish> geekosaur: I tried telling haskell to use Integral input and output but then it can't cast for / ... slope :: (Integral a) => (a,a) -> (a,a) -> a -> [a]
17:25:53 <geekosaur> yes
17:26:03 <dmwit> nade: Aha, that question is much more answerable.
17:26:07 <jmcarthur> nade: the closest to a statement that we have is what we informally call an "action", which is actually just a value that in the right context can be interpreted as an effect
17:26:20 <geekosaur> you need to use fromIntegral in places to make values acceptable to (/)
17:26:25 <nade> well they are both "functions" right?
17:26:33 <jmcarthur> no
17:26:35 <geekosaur> I even told you where already
17:26:49 <dmwit> nade: Haskell has two separate languages: a type language and a term language. Expressions in the term language are annotated by expressions in the type language. Data types live in the type language; data constructors live in the expression language.
17:26:58 <lunarjar> so here is my code http://hpaste.org/86106
17:27:05 <BadRadish> geekosaur: I saw that I'm just trying to understand why
17:27:07 <lunarjar> can anyone help me to generate properly an array for this?
17:27:14 <BadRadish> I think I get it now
17:27:37 <parcs> what's a common associative but not commutative operator?
17:27:39 <jmcarthur> lunarjar: http://www.haskell.org/tutorial/arrays.html
17:27:45 <jmcarthur> parcs: (++)
17:27:54 <dolio> parcs: Matrix multiplication.
17:27:55 <Cale> lunarjar: You'd need an index of Ix for Item to do that... but what are you trying to do?
17:27:56 <dmwit> lunarjar: Perhaps you would like to write b = Basket [[A,A],[O,O]]. However, this is not an array.
17:28:00 <BadRadish> it's a little annoying the way you have to do this even when it seems like it would be obvious
17:28:13 <geekosaur> defaulting is often somewhat confusing in these cases
17:28:30 <nade> dmwit: Okay, so when I do somethng like data Foo a b = Bar a Foo b its not as if I'm applying a to Boo?
17:28:38 <lunarjar> I want an array, so that I could change  b[x][y] = Empty
17:28:39 <geekosaur> and the fact that literals are implicitly wrapped in fromRational or fromIntegral as appropriate
17:28:40 <nade> er Foo
17:28:47 <Cale> lunarjar: Are you trying to build arrays indexed by pairs of Items?
17:29:19 <dmwit> nade: No, you are defining a new term named Foo in the type language, and informing Haskell that you expect this term to be applied to at most two arguments.
17:29:42 <lunarjar> changeItem :: Array -> Int -> Int -> a -> Array
17:29:59 <dmwit> nade: You are also defining a new term in the expression language named Bar, and fixing its type to be "a -> Foo a b -> b -> Foo a b".
17:30:02 <lunarjar> changeItem basket x y Empty should give a change Array
17:30:04 * geekosaur finds it helpful to assign explicit type signatures to functions, so ghc can tell him where he got them wrong without it including a confusing inference from a possibly distant place
17:30:12 <dmwit> nade: (Assuming you meant to write "data Foo a b = Bar a (Foo a b) b".
17:30:14 <dmwit> )
17:30:57 <Cale> lunarjar: Okay, so really you want an array indexed by pairs of Int values
17:31:21 <Cale> lunarjar: But what should it be to start with, and what is the minimum and maximum index in each dimension?
17:31:24 <lunarjar> or if possible do it with a list
17:31:35 <lunarjar> max and min don't matter it can be any valeu
17:32:06 <erisco__> :t init
17:32:07 <lambdabot> [a] -> [a]
17:32:14 <erisco__> > init [1,2,3]
17:32:16 <lambdabot>   [1,2]
17:32:26 <erisco__> > last [1,2,3]
17:32:28 <lambdabot>   3
17:33:06 <Cale> > listArray ((0,0),(2,2)) [1,2,3,4,5,6,7,8,9]
17:33:07 <lambdabot>   array ((0,0),(2,2)) [((0,0),1),((0,1),2),((0,2),3),((1,0),4),((1,1),5),((1,...
17:33:25 <Cale> > let b = listArray ((0,0),(2,2)) [1,2,3,4,5,6,7,8,9] in b // [((0,0),10)]
17:33:26 <lambdabot>   array ((0,0),(2,2)) [((0,0),10),((0,1),2),((0,2),3),((1,0),4),((1,1),5),((1...
17:33:48 <Cale> lunarjar: ^^ is that the sort of thing you want?
17:34:13 <nade> dmwit: okay i suppose that makes sense
17:34:16 <Cale> So  changeItem a i j x = a // [((i,j),x)]
17:34:31 <otters> init is linear time, right?
17:34:44 <Cale> otters: If you evaluate the entire resulting list, then yes.
17:34:58 <erisco__> otters, yes
17:35:08 <Cale> init is constant time per element of the result
17:35:15 <Cale> which is why this works:
17:35:17 <Cale> > init [1..]
17:35:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:36:11 <erisco__> I don't see the point of distinction
17:36:21 <dmwit> ; let commutative f = and [f x y == f y x | (x,y) <- U.universe]; associative f = and [f x (f y z) == f (f x y) z | (x,y,z) <- U.universe]
17:36:34 <Eduard_Munteanu> @src init
17:36:34 <lambdabot> init [x]    = []
17:36:34 <lambdabot> init (x:xs) = x : init xs
17:36:34 <lambdabot> init []     = undefined
17:36:51 <Cale> Well, I just gave it an infinite list. If it took linear time to get the first element of the result, then it would never finish.
17:37:04 <mm_freak> init is O(1)
17:37:10 <mm_freak> it's traversing a list that is O(n)
17:37:14 <mm_freak> it has nothing to do with init
17:37:17 <Eduard_Munteanu> Uhm?
17:37:17 <Cale> Yeah, there's a very real sense in which init is constant time
17:37:36 <Cale> It's just that its result has another application of init in it :)
17:37:39 <jmcarthur> init incurs a linear amount of debt, but it doesn't always have to pay it
17:37:44 <mm_freak> if init were in fact real time, then traversal would become O(n^2)
17:37:45 <Eduard_Munteanu> init still is O(n), it just produces intermediate results.
17:37:52 <mm_freak> Eduard_Munteanu: no, init is O(1)
17:37:53 <Eduard_Munteanu> It still takes an infinite time to finish.
17:37:57 <erisco__> Cale, this just seems to conflate lazy evaluation into the complexity, and I don't see the reason to do so
17:38:12 <jmcarthur> there can be good reasons to do so
17:38:14 <Cale> Well, there are multiple ways to do the analysis
17:38:21 <mm_freak> Eduard_Munteanu: nub has O(n) complexity…  if you traverse nub xs, the traversal becomes O(n^2)
17:38:43 <jmcarthur> for example, consider the difference between    head . nub   and   head . sort
17:38:47 <Cale> It tends to be very important to know what the complexity of pattern matching on the result is.
17:38:50 <Eduard_Munteanu> Hm, that doesn't seem like the right way to count complexity.
17:38:54 <dmwit> < [f | associative f && not (commutative f)] :: [Bool -> Bool -> Bool]
17:38:56 <goodfellow>   No instance for (Debug.SimpleReflect.Expr.FromExpr GHC.Types.Bool)
17:38:56 <goodfellow>    arisi...
17:39:02 <Eduard_Munteanu> You should really say it's O(something) per chunk.
17:39:09 <dmwit> < [f | f <- U.universe, associative f && not (commutative f)] :: [Bool -> Bool -> Bool]
17:39:10 <goodfellow>   [[(False,[(False,False),(True,False)]),(True,[(False,True),(True,True)])],[...
17:39:13 <dmwit> parcs: ^^
17:39:15 <jmcarthur> > head $ nub [1..]
17:39:17 <lambdabot>   1
17:39:19 <jmcarthur> > head $ sort [1..]
17:39:24 <lambdabot>  Terminated
17:39:32 <mm_freak> Eduard_Munteanu: why not?  it just doesn't make sense to ask for "the i-th result" of init
17:39:36 <mm_freak> because init has exactly one result
17:39:39 <dmwit> < const :: Bool -> Bool -> Bool
17:39:41 <goodfellow>   [(False,[(False,False),(True,False)]),(True,[(False,True),(True,True)])]
17:39:55 <mm_freak> think about it
17:39:58 <dmwit> parcs: So const is associative but not commutative. =)
17:40:14 <erisco__> :t nub
17:40:18 <Cale> nub is "O(n^2) time", but as you can see there, you can apply it to an infinite list, and still get a result in a constant amount of time, while sort is "O(n log n)", but when applied to an infinite list, it takes forever.
17:40:20 <lambdabot> Eq a => [a] -> [a]
17:40:27 <mm_freak> let's say traversing a single element takes time s, performing a step of init takes time t
17:40:30 <erisco__> > nub [1,2,3]
17:40:34 <lambdabot>   [1,2,3]
17:40:35 <Eduard_Munteanu> mm_freak: I'm just saying that most CS out there considers an algorithm finished when the results are fully evaluated
17:40:37 <mm_freak> traversing an init-ed list thus takes time s + t
17:40:46 <erisco__> > nub [1,1,2]
17:40:47 <mm_freak> not traversing
17:40:48 <lambdabot>   [1,2]
17:40:54 <mm_freak> asking for the next element
17:41:15 <Eduard_Munteanu> mm_freak: here's another O(1) algorithm: f xs = []
17:41:16 <lunarjar> Cale, how do I implement the listArray into this http://hpaste.org/86106
17:41:29 <Cale> The way I tend to think about complexity of list operations is in terms of the cost associated to the nth element of the result.
17:41:56 <mm_freak> Eduard_Munteanu: think about it this way:  applying init to a list adds a constant (!) factor to the time you need to traverse it
17:42:00 <jmcarthur> Eduard_Munteanu: most CS doesn't even *consider* non-strictness in the analysis of algorithms, so i don't think drawing on your knowledge from algorithms class is going to be sufficiently helpful
17:42:01 <mm_freak> what does constant mean?
17:42:03 <mm_freak> O(1)!
17:42:33 <Cale> lunarjar: I don't know what you're intending to do with that code. The reason that you're going to have problems with b there is that A and O are values of type Item, and you have no instance of Ix Item, and so no instance of Ix (Item,Item), so you can't use pairs of Item values as array indices.
17:42:40 <dmwit> < const `asAppliedTo` True == head [f | f <- U.universe, associative f && not (commutative f)]
17:42:41 <goodfellow>   Couldn't match expected type `GHC.Types.Bool'
17:42:41 <goodfellow>              with actual type...
17:42:44 <Eduard_Munteanu> mm_freak: doesn't it add a constant factor to *each* element?
17:42:50 <Cale> lunarjar: The first parameter to array is a pair of bounds for the array you're constructing.
17:42:56 <mm_freak> Eduard_Munteanu: not a factor
17:42:56 <dmwit> < (const `asAppliedTo` True) == head [f | f <- U.universe, associative f && not (commutative f)]
17:42:57 <goodfellow>   True
17:43:06 <mm_freak> Eduard_Munteanu: an addend
17:43:17 <Eduard_Munteanu> Yeah, that's what I was thinking of.
17:43:18 <Eduard_Munteanu> Hm.
17:43:19 <mm_freak> those /addends/ form a constant /factor/ when traversing
17:43:20 <Cale> lunarjar: and the type of the bounds must be an instance of the typeclass Ix (short for index)
17:43:49 <mm_freak> there are list algorithms, which have linear complexity, but init is certainly not one of them
17:44:11 <lunarjar> Cale how would I change basket[x][y] if it was a haskell list then instead of array?
17:44:18 <Eduard_Munteanu> mm_freak: I suspect you could conclude that now you can do sorts in O(log n)
17:44:29 <Eduard_Munteanu> It seems a bit artificial.
17:44:47 <Cale> lunarjar: There's no library function to replace the nth element of a list, so you'll have to write one. It's a particularly bad operation to perform on lists.
17:44:51 <mm_freak> Eduard_Munteanu: why?  sort already needs something like O(n * log n) or O(n^2) to produce even the first element?
17:45:11 <jmcarthur> Eduard_Munteanu: even in a strict context, you can do that with infinite parallelism :P
17:45:51 <lunarjar> Cale there is elem and I would only need to write setElement ?
17:45:56 <Eduard_Munteanu> Actually analyzing sort is more difficult.
17:45:58 <jmcarthur> mm_freak: you only need O(n) to produce the first
17:46:10 <Cale> lunarjar: elem determines whether a given thing is an element of a list
17:46:18 <mm_freak> jmcarthur: i don't know which algorithm it uses
17:46:25 <Cale> > elem 'e' "hello"
17:46:27 <lambdabot>   True
17:46:29 <Cale> > elem 'x' "hello"
17:46:30 <lambdabot>   False
17:46:32 <Eduard_Munteanu> mm_freak: optimal sorting
17:46:36 <jmcarthur> ghc uses mergesort i think, but it's also true of quicksort
17:46:40 <Eduard_Munteanu> Shouldn't matter.
17:46:52 <mm_freak> Eduard_Munteanu: in any case you won't get anything from sort in less than O(n) steps
17:47:01 <mm_freak> so the conclusion O(log n) can't be right
17:47:36 <dmwit> O(n + n log k) to get k elements from the front of sorting n elements
17:47:59 <Eduard_Munteanu> Well, yes, because that changes as you evaluate the final list. But on average it is O(log n). Even if it is O(n) it still comes off as too good :)
17:48:08 <dmwit> err
17:48:09 <jmcarthur> not k log n?
17:48:13 <dmwit> yeah, k log n
17:48:24 <dmwit> wait
17:48:30 <mm_freak> Eduard_Munteanu: for lists it's always important to remember that the /traversal/ is what's complex…  in fact if your list ops are not O(1) you're probably abusing lists =)
17:48:39 * dmwit asks Wikipedia to be his memory for him
17:48:49 <mm_freak> O(log n) is probably fine, like an Ord-based nub
17:49:12 <Eduard_Munteanu> mm_freak: and if I ignore the result completely then everything is O(1)? :P
17:49:14 <dmwit> yeah, k log n
17:49:23 <mm_freak> edu	yes
17:49:25 <mm_freak> Eduard_Munteanu: yes
17:49:52 <mm_freak> > const () . sort $ [1..]
17:49:54 <lambdabot>   ()
17:50:07 <Eduard_Munteanu> Well, yeah. :)
17:50:28 <jmcarthur> the point is that its complexity depends on how it is consumed
17:50:38 <mm_freak> Eduard_Munteanu: a good measure of complexity is how long an expression takes to give the WHNF
17:50:53 <Cale> lunarjar: So you could write something recursive like  setElement n x [] = [x]; setElement 0 x (y:ys) = x:ys; setElement n x (y:ys) = y : setElement (n-1) x ys -- If there's no element at the given index, it will be placed at the end of the list this way.
17:50:57 <mm_freak> NF analysis isn't very useful in haskell
17:51:05 <jmcarthur> i somewhat disagree with that
17:51:13 <jmcarthur> if that was true we would just use nub instead of sort
17:51:22 <Cale> lunarjar: Another option would be to use take and drop:  setElement n x xs = take (n-1) xs ++ x : drop n xs
17:51:24 <Eduard_Munteanu> mm_freak: that makes algorithms hard to compare
17:51:46 <BadRadish> I don't understand :'(
17:51:49 <jmcarthur> Eduard_Munteanu: i think of it as just giving us more variables to play with when choosing algorithms
17:52:00 <mm_freak> Eduard_Munteanu: not really…  it tells you more about an algorithm than NF complexity
17:52:04 <Eduard_Munteanu> mm_freak: there are algos which improve even the NF case when implemented lazily, AFAIK.
17:52:16 <jmcarthur> well sure
17:52:18 <Cale> lunarjar: But typically, if you're doing a lot of this kind of operation, lists are not a good data structure and/or you should be thinking more globally about what type of operation you're performing.
17:52:21 <jmcarthur> > const () $ sort [1..]
17:52:23 <lambdabot>   ()
17:52:34 <mm_freak> if you consider NF, then you have to multiply every list operation by O(n)
17:52:38 <lunarjar> I know lists are bad but this is now a challenge to prove it can be done
17:52:54 <lunarjar> thanks Cale
17:53:01 <mm_freak> and then you get to a very wrong conlusion:  sum . nub takes O(n^3)
17:53:14 <Eduard_Munteanu> I don't think you want to do that.
17:53:24 <Cale> lunarjar: You should generally think of lists as essentially loops that are waiting to happen
17:53:36 <Eduard_Munteanu> More like figure O(something) that gives you the average case and multiply that by 'n'.
17:53:46 <Eduard_Munteanu> Like you do with sorts.
17:53:50 <mm_freak> Eduard_Munteanu: big O is not average =)
17:53:59 <Cale> lunarjar: Just like a loop either doesn't run at all (because its precondition isn't met) or it consists of an iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
17:54:17 <Eduard_Munteanu> mm_freak: there are minimal, average and maximal big Os, on the contrary
17:54:36 <mm_freak> Eduard_Munteanu: yes, but the big O notation O(x) means worst case
17:54:36 <Eduard_Munteanu> This isn't merely parametrized by input length.
17:54:51 <Cale> lunarjar: So replacing the nth element of a list is like writing a loop which does something different just on its nth iteration -- a somewhat unnatural thing to have, usually.
17:55:14 <Eduard_Munteanu> mm_freak: mind I'm not saying average O() is Theta()
17:55:20 <Eduard_Munteanu> Or anything like it.
17:55:49 <jmcarthur> > [1,2,3,4] & ix 2 .~ 10
17:55:52 <Eduard_Munteanu> For instance, maximal big O for quicksort is O(n^2) AFAIK.
17:55:53 <lambdabot>   [1,2,10,4]
17:56:31 <Eduard_Munteanu> The average and minimal big Os are O(n * log n). Depends on other qualities of the input.
17:56:59 <mm_freak> Eduard_Munteanu: if you really want to resolve all this you should always look at the complexity of an actual program
17:57:01 <jmcarthur> Eduard_Munteanu: that is not big-O
17:57:10 <Cale> lunarjar: another way to write setElement would be like this:  setElement n a xs = [if k == n then a else x | (k,x) <- zip [0..] xs]
17:57:15 <mm_freak> it's difficult to talk about the complexity of 'init', because it has two complexities:  WHNF and NF
17:57:19 <Eduard_Munteanu> jmcarthur: why not?
17:57:45 <mm_freak> however, this program has a very well defined complexity:  main = print . sum . init $ xs
17:57:46 <Cale> lunarjar: This idiom of zipping a list with [0..] is a handy thing to do when you want to perform an operation which depends on the indices of the elements in the list.
17:57:48 <mm_freak> namely O(1) =P
17:57:59 <jmcarthur> Eduard_Munteanu: big-O is always worst case. the average case is not descriptive of the upper bound in general.
17:58:15 <Cale> > zip [0..] "hello"
17:58:16 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
17:58:24 <Eduard_Munteanu> jmcarthur: a lot of sources call quicksort O(n*log n) for example
17:58:37 <Eduard_Munteanu> Which isn't true if the input is already sorted.
17:59:04 <Cale> > [if k == 1 then 'a' else x | (k,x) <- zip [0..] "hello"]
17:59:06 <lambdabot>   "hallo"
17:59:09 <jmcarthur> > [[1,2,3,4],[5,6,7,8],[9,10,11,12]] & ix 2 . ix 1 .~ 999
17:59:11 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,999,11,12]]
17:59:17 <mm_freak> Eduard_Munteanu: which is wrong…  quicksort is O(n^2), but people often look at a related concept, "amortized worst case" or something like that
17:59:37 <Eduard_Munteanu> I guess that's what I mean by average.
18:00:12 <Cale> I always have to think hard whenever someone uses edwardk's infix operators for lenses.
18:00:18 <jmcarthur> yeah me too
18:00:33 <jmcarthur> i used them because i'm still not used to lens and they were the first thing i saw in the documentation this time
18:00:40 <mm_freak> to this day i'm not really fond of the lens library
18:01:02 <jmcarthur> i like a lot of things about it, but as a whole i think i agree
18:01:06 <Cale> I think lens is nice, I just don't like the operator symbols.
18:01:52 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms   seems to break down big O similarly
18:02:24 <jmcarthur> Eduard_Munteanu: only the "worst" column there is actually big-O
18:02:48 <Cale> > set (ix 2 . ix 1) 999 [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
18:02:50 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,999,11,12]]
18:02:51 <Eduard_Munteanu> jmcarthur: yes, I think you're right, strictly speaking
18:02:54 <Cale> ^^ that's just fine
18:03:02 <jmcarthur> Cale: agreed. i prefer that
18:03:46 <edwardk> cale: in the next major version of lens we already agreed to export some kind of Control.Lens.Bikeshedding module that doesn't export the operator symboks
18:03:48 <edwardk> er symbols
18:03:49 <Cale> I also have a slight opposition to the names _1, _2 etc.
18:04:00 <edwardk> however, it will still have _1, _2, etc. =P
18:04:14 <Cale> But only because I'm horribly opposed to the use of underscores in names meant for actual use.
18:04:25 <edwardk> deliberately so
18:04:29 <mm_freak> Eduard_Munteanu: not strictly speaking, he is right =)
18:04:35 <mm_freak> big O is worst case
18:04:38 <jmcarthur> i'm okay with those names because i am unlikely to use them otherwise anyway
18:05:12 <Eduard_Munteanu> Yeah, by definition it is.
18:05:39 <Cale> When I see an underscore at the beginning of a name, it says to me "I didn't really want to bind this name, please ignore"
18:06:06 <mm_freak> Eduard_Munteanu: amortized worst case can be applied to certain data structures and algorithms, most notably hash tables
18:06:09 <Eduard_Munteanu> Or _lookatmeImimportant_ :P
18:06:13 <Cale> lol
18:06:21 <mm_freak> while insertion into a hash table is O(n), its amortized worst case is O(1)
18:06:31 <jmcarthur> Cale: same here, but since i didn't bind it i don't tend to have that inclinatation with identifiers i import
18:06:48 <Eduard_Munteanu> I see.
18:06:51 <jmcarthur> in a binder position that would be my first thought though
18:06:53 * Eduard_Munteanu needs to get some sleep
18:07:02 <Cale> mm_freak: But you always have to compute the hash, don't you?
18:07:08 <Cale> mm_freak: and that's O(log n)
18:07:18 <jmcarthur> *now* the pedant argument begins
18:07:18 <mm_freak> Cale: for strings
18:07:26 <Eduard_Munteanu> Heh.
18:07:31 <Cale> For anything
18:08:00 <mm_freak> Cale: actually for strings it's O(n)…  what's the n in your O(log n)?
18:08:19 <Cale> If you have n buckets, any hash function whatsoever which is capable of distributing items into all of them must take at least O(log n) time.
18:08:39 <Eduard_Munteanu> Perhaps you could make a multidimensional O()?
18:08:50 <mm_freak> Cale: ah, so a constant n? ;)
18:09:06 <Eduard_Munteanu> Clearly you could parametrize by both key size and number of elements.
18:09:07 <lunarjar> Cale almost done it, can you tell me how to make this work http://hpaste.org/86108
18:09:17 * jmcarthur sides with Cale even though it doesn't mean my preferred comparison-based data structures beat hash tables for speed most of the time
18:09:24 <lunarjar> it works for Type but not for Data
18:09:26 <erisco> not sure how to clearly explain this... I am convert parsing tools I wrote in C# to Haskell. There are various parsers which I combine to recognize a grammar. One such simple parser is 'end', which simply recognizes the end of a sequence
18:09:33 <Eduard_Munteanu> Yielding something like O(log m + n)
18:09:35 <erisco> in Haskell I made the function  end :: Parser a ()
18:09:36 * cmccann thinks parameterizing time complexity in terms of cache misses might be more informative
18:09:41 <jmcarthur> Eduard_Munteanu: the key must have sufficient information to distinguish each element though
18:09:57 <Eduard_Munteanu> Hm.
18:10:10 <erisco> but I also have to deal with error messages, so to attach an error message on failure, I return  "ParseError 'end'" on failure
18:10:18 <Eduard_Munteanu> Pepper up some min/max in there :)
18:10:24 <Eduard_Munteanu> It's not unheard of. :P
18:10:28 <mm_freak> erisco: parsec?
18:10:34 <erisco> this doesn't work well for more complex cases
18:10:38 <jmcarthur> Eduard_Munteanu: if we measure the key in terms of bits then the keys must be at least log2 n bits to distinguish n elements
18:11:04 <Eduard_Munteanu> Assuming distinct elements are handled differently.
18:11:10 <erisco> I was thinking of making a type class, calling it 'Parser', and then adding a method which returns the error message appropriate with the parser
18:11:13 <jmcarthur> if they weren't then we wouldn't count them
18:11:19 <Eduard_Munteanu> But I kinda have to go.
18:11:44 <erisco> but such a method would logically have the simple type of String, and that doesn't accept any type variables
18:11:50 <erisco> so it can't be part of a type class
18:11:52 <Cale> mm_freak: Well, I suppose you could insert into a fixed size hash table in O(1) and get O(n) many collisions to deal with when you take items out.
18:12:16 <Cale> (where n is the number of items that were inserted in that case)
18:12:19 <erisco> but I could create a bunk type which accepted a type variable, and a string, with the only intended use being the String
18:12:23 <ab9rf> erisco: i don't understand ho that makes sense
18:12:25 <erisco> but I feel like I'm fighting the system
18:12:51 <erisco> ab9rf, if I explained it more tersely I feared I'd merely be asked why I'd want to do that
18:12:56 <jmcarthur> i don't understand why people don't use balanced trees instead of linked lists for hash table buckets more often
18:13:01 <erisco> ab9rf, so I tried to include reasoning from the start
18:13:04 <mm_freak> Cale: the size of the hash table is dynamic…  you mean that the hash value itself needs to grow over time?
18:13:22 <Cale> mm_freak: the cost of computing the hash function has to grow with the size of the hash table
18:13:50 <mm_freak> Cale: well, in theory…  in practice your memory will be exhausted before you have to use larger hashes
18:13:51 <Cale> mm_freak: Or else the size of the hash table isn't really growing, because you won't be using most of your buckets
18:14:07 <Cale> But this is asymptotic analysis
18:14:23 <jmcarthur> mm_freak: consider a hash table with 256 unique strings of 8 chars each. you must add another char to grow the hash table add all, so the hash function must take longer
18:14:25 <Cale> You can't say "oh, we'll run out of memory", if you assume there's a fixed amount of space, everything is O(1).
18:14:28 <jmcarthur> *at all
18:14:37 <jmcarthur> not 8 chars
18:14:38 <erisco> this is what I mean: http://hpaste.org/86109
18:14:39 <jmcarthur> gah
18:14:51 <jmcarthur> 1 8bit char each, i guess
18:15:07 <erisco> 'expecting' cannot be a method of the Parser type class because it doesn't use the type variable, which means that there'd be nothing to instantiate
18:15:18 <mm_freak> Cale: the reasoning for the amortized O(1) complexity (assuming O(1) hashing):  if at size n you need to grow, you won't have to grow for another n elements
18:15:29 <mm_freak> the O(n) growth is thus "amortized" by that
18:15:50 <jmcarthur> mm_freak: that's not the cost of growing Cale is talking about
18:15:56 <mm_freak> i know
18:16:15 <jmcarthur> mm_freak: he's talking about having enough information in the keys to distinguish the additional elements that caused the hash table to grow
18:16:18 <Cale> The cost of growing I'm talking about is that once you've grown your hash table to a size O(n), your hash function now costs O(log n) time.
18:16:28 <Cale> (at least!)
18:16:45 <mm_freak> jmcarthur: you would usually use hash values that are large enough that they are unlikely to be exhausted
18:17:06 <mm_freak> that's why usually you assume O(1) hashing
18:17:17 <Cale> If you fix the size of things in asymptotic analysis, you get garbage results
18:17:26 <mm_freak> in fact i expect most hash table implementations to simply fail when the hash space is exhausted
18:17:29 <jmcarthur> mm_freak: you can assume O(1) anything if the input size is bounded by the constraints of realistic hardware
18:17:53 <Cale> I could just write the algorithm which iterates over all possible states in memory looking for the one which corresponds to the result of the insertion and that's still O(1) if memory is finite.
18:17:54 <mm_freak> well, some assumptions are stupid, but some are reasonable
18:18:00 <jmcarthur> mm_freak: i can never have more than 2^64 of anything in memory
18:18:25 <jmcarthur> so my binary search tree is O(log(2^64)) = O(64) = O(1)
18:18:39 <jmcarthur> *lookup, that is
18:19:05 <jmcarthur> i'm saying obvious things of course
18:19:14 <mm_freak> conclusion:  if you want to pick the best data structure, you need to benchmark =)
18:19:19 <jmcarthur> indeed
18:19:21 <mm_freak> big O won't help you
18:19:29 <Cale> also, do asymptotic analysis sensibly :P
18:19:54 <Cale> Don't fix the size of your data when doing it or your results are meaningless.
18:20:12 <mm_freak> i'm just saying:  sometimes certain assumptions help to map a purely theoretical concept to actual hardware
18:20:26 <Cale> It's really okay for the result to be O(log n) here
18:20:57 <mm_freak> Cale: i still consider hash tables O(n)
18:21:14 <mm_freak> i don't really like amortized complexity analysis
18:21:27 <jmcarthur> they can be O(log n) if you put balanced trees in the buckets at least
18:21:42 <jmcarthur> err
18:22:07 <Cale> Yes, that works.
18:22:24 <jmcarthur> but of course if you don't consider the hash function to be O(1) then you can't consider the balanced tree lookup to be O(log n)
18:22:27 <Cale> Any function which has a range of size n takes at least O(log n) time to compute, and we should be very suspicious of anything which claims otherwise.
18:22:43 <jmcarthur> it's a bit nicer with a trie at least
18:22:53 <mm_freak> for example amortized O(1)/O(log n) can actually give a false sense of safety…  the hash table DoS attacks have shown that you should never ignore real asymptotic complexity
18:23:36 <mm_freak> the attackers simply forced worst cases in a high frequency causing sites to break down
18:23:43 <jmcarthur> tries are basically optimal in the big-O sense afaik
18:23:47 <Cale> Of course, if you have to contend with malicious input, then unless your hash function is cryptographically strong, your worst case will have every insert be a collision.
18:28:40 <BadRadish> man this is confusing but at least its working thanks everyone
18:39:00 <edwardk> If anybody would be interesting in some relatively short term (say ~4 weeks + some maintenance funding after) work helping to maintain/update some existing haskell code / possibly doing some interesting differential equation stuff, let me know. I have someone who was looking for help.
18:56:28 <tgeeky> edsko: /me
18:56:32 <tgeeky> edwardk: /me
19:02:16 <jmcarthur> it would be awesome if i could put foreign imports into a where clause
19:02:40 <shachaf> module Pedant where { foreign import ... }
19:02:52 <jmcarthur> bah
19:03:07 <jmcarthur> you know i meant in the definition of a value :P
19:04:01 <DiegoNolan> what is the actually cabal package name to install Data.String.Utils ?
19:04:17 <shachaf> @where hayoo
19:04:17 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
19:04:24 <shachaf> Oh, it's down.
19:04:37 <shachaf> @google hackage "data.string.utils"
19:04:38 <lambdabot> http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html
19:04:38 <lambdabot> Title: Data.String.Utils
19:04:42 <shachaf> Looks like it's MissingH. :-(
19:05:01 <DiegoNolan> Yeah its driving me nuts
19:08:06 <lunarjar> so I almost done it, but can't figure out the last part https://gist.github.com/anonymous/ef88c2f4134d6c7c5201
19:15:56 <dmwit> lunarjar: A value v :: [a] is either [] or (x:xs) where x :: a and xs :: [a].
19:16:08 <dmwit> lunarjar: Perhaps considering these two cases will help you write your loop.
19:18:12 <lunarjar> nope :(
19:19:50 <dmwit> What have you tried?
19:21:49 <lunarjar> I don't really know where to start
19:21:55 <twoolie> lunarjar: what's the problem definition?
19:22:10 <cschneid> is there a way to minimize parens on this line: problem4 hashes corpusFreq = map ((flip P3.problem3) corpusFreq) hashes
19:22:22 <lunarjar> twoolie, change a value in this 2d list and return the changed list
19:22:39 <cmccann> cschneid: why do you have the inner parens?
19:22:40 <Mortchek> cschneid, sure, use $ :)
19:22:51 <Mortchek> And yeah, (foo bar) baz is just foo bar baz
19:23:04 <Mortchek> Function application associates to the left
19:23:06 <cschneid> hmm
19:23:12 <cmccann> also, you can use (<$>) in place of map
19:23:16 <cschneid> because flip by definition only takes one arg, it figures that out?
19:23:30 <cmccann> so "flip P3.problem3 corpusFreq <$> hashes"
19:23:32 <cmccann> is what I would write
19:23:33 <Mortchek> The result of flip whatever is a function that can be applied like any other function
19:23:35 <nbouscal> function application associates left and is highest precedence (10)
19:23:45 <Mortchek> @type flip
19:23:46 <lambdabot> (a -> b -> c) -> b -> a -> c
19:23:53 <cschneid> cmccann: what package is <$>
19:23:58 <Mortchek> @type flip flip
19:24:00 <lambdabot> b -> (a -> b -> c) -> a -> c
19:24:00 <twoolie> lunarjar: and you have to write the whole function yourself or can you use standard library functions?
19:24:25 <cschneid> cmccann: and that's actually fmap, yes? which just happens to be a boring map on an array
19:24:26 <cmccann> cschneid: import Data.Functor or Control.Applicative
19:24:34 <cmccann> yes, fmap on lists is map
19:24:49 <lunarjar> twoolie, everything is ok except !!
19:25:18 <cschneid> and it's the infix version.  So   funcToApply <$> thingToApplyTo
19:25:47 <twoolie> ok so first, show us an example of an input and an output of the function you want to write
19:25:52 <cmccann> > flip (,) "foo" <$> ["bar", "baz"]
19:25:54 <lambdabot>   [("bar","foo"),("baz","foo")]
19:26:03 <cmccann> > (,) "foo" <$> ["bar", "baz"]
19:26:05 <lambdabot>   [("foo","bar"),("foo","baz")]
19:26:46 <cmccann> > flip (,) "foo" "bar"
19:26:48 <lambdabot>   ("bar","foo")
19:26:51 <cmccann> see how that all works?
19:27:20 <cschneid> sure. I forget how clever the complier is at disambiguating. (ruby all day will do that to me)
19:27:36 <nbouscal> not so much disambiguating as the set rules are well-designed
19:27:43 <cschneid> (by clever I mean it has way way more information...)
19:27:51 <Mortchek> Judging from a recent experience with Ruby in one of my classes, I am of the opinion that Ruby's syntax is terrible
19:27:54 <cmccann> there's no actual ambiguity here
19:28:14 <lunarjar> twoolie, move board 2 2 X would result in Board [[ , , ],[ ,X, ],[ , , ]]
19:28:23 <nbouscal> Ruby tends to favor being readable to a not-very-coder-ish audience
19:28:28 <nbouscal> “poetry mode”
19:28:32 <cschneid> honestly, ruby is pretty perl.
19:28:44 <ab9rf> i don't think ruby is all that bad
19:28:45 <cschneid> it's very different than haskell, but gets the job done, and reasonably well
19:28:46 <nbouscal> pretty perl had a baby with smalltalk, and yes
19:28:57 <ab9rf> but it's certainly not the "cleanest" language
19:29:02 <nbouscal> I like Ruby, personally, it's just a very different kind of language from Haskell
19:29:04 <ab9rf> and its runtime performance is atrocious
19:29:12 <cschneid> it's less atrocious now... :)
19:29:23 <ab9rf> yes, it is improving :)
19:29:27 <nbouscal> also most people coding in Ruby don't care much about performance
19:29:29 <cmccann> ab9rf: I thought they improved to be at least comparable to Python or perl
19:29:35 <Mortchek> Ruby purports to have optional parens for function calls, but that throws other things out of whack. Plus, it doesn't like comma-first
19:29:40 <ab9rf> cmccann: it's not at python's level, but it might be at php's :)
19:29:52 <cschneid> nbouscal: more accurately, the runtime of the code is way less important than the wait time of IO for most ruby land stuff
19:29:54 <nbouscal> Mortchek: I don't think comma-first really exists outside of the functional niche
19:29:58 <nbouscal> cschneid: exactly
19:30:14 <cschneid> comma first?
19:30:18 <nbouscal> on newlines
19:30:24 <Mortchek> I don't see any reason why not. Besides, I want to program functionally in Ruby :P
19:30:34 <cmccann> it used to be that Ruby's performance was moderately faster than evaluating your program by hand with pen and paper
19:30:42 <nbouscal> Ruby actually isn't bad for programming functionally in. a sight better than PHP anyway, though I guess that's not hard
19:30:49 <dmwit> cmccann: ...but now it isn't any more?
19:30:59 <cschneid> cmccann: yeah, it was seriously terrible before, now it's just slowish. They totally redid the vm recently
19:31:00 <Mortchek> Almost anything is better than programming functionally in PHP
19:31:04 <Mortchek> s/functionally //
19:31:09 <nbouscal> yeah i do it at work and it hurts my soul
19:31:13 <ab9rf> nbouscal: being compared favorably to PHP is akin to damning with faint praise
19:31:18 <nbouscal> a bit, yeah
19:31:22 <cmccann> dmwit: no, now it's only slow instead of glacial
19:31:24 <ab9rf> "ooh, you're better than that horrible language designed by idiots"
19:31:51 <nbouscal> though, i do like the quote “Let's argue about whether Haskell or Lisp is better while someone else ships product made of PHP and duct tape”
19:31:58 <nbouscal> or however it went
19:32:04 <ab9rf> nbouscal: 'worse is better'
19:32:08 <nbouscal> yep
19:32:09 <Mortchek> "idiots" is a bit much, but they certainly had no formal knowledge of PL theory
19:32:30 <cmccann> duct tape is totally legit engineering, it doesn't deserve being attached to PHP
19:32:30 <cschneid> but yeah, it's fun learning a language so very different than ruby. I start pushing the ruby type system a bit more (not that it goes very far).
19:32:34 <nbouscal> I'm curious if they thought of themselves as designing a programming language
19:32:47 <dmwit> ruby... type system?
19:32:54 <nbouscal> duck typing is a type system?
19:33:17 <Mortchek> Tomorrow I get to find out whether I lost points for answering on a quiz that Ruby doesn't have type inference when the professor has been telling us that it does
19:33:17 <tromp_> it's an excuse for a type system
19:33:24 <ab9rf> quack
19:33:24 <Mortchek> s/quiz/exam/
19:33:29 <ryant5000> does anyone happen to know if it's possible to suppress the output generated by postgres-simple ?
19:33:46 <lunarjar> twoolie, any tips? :)
19:33:47 <ab9rf> mortchek: ruby has no types to infer
19:33:49 <ryant5000> it looks like it might be coming from a lower level
19:33:51 <Mortchek> ab9rf, exactly
19:33:53 <cmccann> sure it does, it has one type
19:33:56 <tgeeky> ruby has a typing system if going to a masked key party is considered safe sex
19:33:57 <nbouscal> object!
19:33:58 <ab9rf> yes, one type
19:34:01 <cschneid> Mortchek: lol. It sure doesn't.
19:34:01 <ab9rf> and everythng is that type
19:34:02 <cmccann> all terms have type "ruby value"
19:34:06 <Mortchek> It's not really meaningful to say a language has type inference when it's not statically typed
19:34:08 <nbouscal> i infer that this is an object! and this is an object!
19:34:12 <nbouscal> such good inference.
19:34:27 <tgeeky> nbouscal: note it's not actually inferred, it's defined.
19:34:37 <ab9rf> it's a very short inference
19:34:39 <cschneid> but it has classes, which can be of help, it's not like php where anything can be anything.
19:34:47 <ryant5000> not everything in ruby is  an object! some things are blocks!
19:34:48 <nbouscal> tgeeky: you're just undervaluing my inferring skills
19:34:54 <nbouscal> ryant5000: fair point
19:34:55 <ab9rf> blocks are objects
19:35:03 <Mortchek> nbouscal, there there, you pointed out that object *really* well I thought.
19:35:03 <nbouscal> they're not, but they can be turned into procs, which are
19:35:06 <cschneid> ryant5000: blocks are Proc objects (lambdas maybe?)
19:35:08 <ryant5000> ab9rf: iirc, you have to manually box them to make them into objcts
19:35:15 <nbouscal> blocks are not proc objects. they can be made them.
19:35:19 <ab9rf> i thought that was automatic now
19:35:27 <cschneid> ahh, sure. the yield vs. &block speed diff.
19:35:28 <ab9rf> i dunno, never quite grasped that inanity
19:35:36 <ryant5000> ab9rf: you may be right; it's been a while
19:35:52 <ab9rf> ruby is an old language that got dragged out of obscurity a while back
19:35:55 <cmccann> on the other hand, Ruby's worst feature is DHH, not the type system
19:35:56 <nbouscal> i've read that they're still second-class somewhat recently… though i don't know how recently the thing i was reading was written :P
19:35:57 <cschneid> well, anyway, thanks for the help on <$> and flip. I'm going to go do problem5 now. :)
19:36:02 <Mortchek> Languages that have special syntax for identifiers referring to functions make me sad
19:36:37 <Mortchek> Or I guess I should just say languages without first-class functions make me sad
19:36:47 <Mortchek> I am spoiled
19:36:47 <dmwit> languages make me sad
19:36:53 <nbouscal> languages without proper lexical scope make me sad
19:37:02 <Mortchek> dmwit, yeah, why not directly interface our brains with each other / the computer?
19:37:02 <cmccann> dammit dmwit I was about to say that >:[
19:37:15 <cschneid> hard and poorly defined business problems make me sad. No matter the language.
19:37:18 <Mortchek> It's a sad world where we have to use words to mean things
19:37:44 <dmwit> http://axisofeval.blogspot.ru/2012/07/when-new-language-doesnt-get-lexical.html
19:37:58 <nbouscal> dmwit: hahaha
19:38:05 <Mortchek> Wait, what's a language without lexical scoping?
19:38:11 <dmwit> Be sure to click the "thispltlife" tag for more hilarity.
19:38:11 <nbouscal> PHP's scoping is very aggravating
19:38:13 * Mortchek is having trouble imagining one
19:38:33 <Mortchek> How does PHP's scoping differ from lexical scoping?
19:38:37 <nbouscal> PHP has function scope, where functions don't have access to anything that isn't passed to them explicitly. unless it's an anonymous function, in which case you can use a 'using' keyword to access it's parent's variables
19:38:46 <Mortchek> That's odd
19:38:46 <nbouscal> but named functions can't use that keyword
19:38:47 <cmccann> Mortchek: it's like a real language, except sometimes things mean what they shouldn't for no reason
19:39:04 <Mortchek> cmccann, well that's hardly specific to PHP's scope :P
19:39:21 <nbouscal> it's extremely odd. I still am thinking I just misunderstand it and there's some secret that makes it act properly
19:39:40 <Mortchek> nbouscal, I rate it highly probable that PHP is exactly as odd, if not odder, than it appears
19:39:50 <ab9rf> Mortchek: it's odder.
19:39:56 <nbouscal> yeah. i was actually taken aback to find that it has a few higher order functions
19:39:57 <dmwit> http://this-plt-life.tumblr.com/post/44462204757/simon-peyton-jones-adding-the-io-monad-to-haskell
19:39:57 <ab9rf> PHP is fractally odd
19:40:07 <cads> Hey guys
19:40:08 <Mortchek> Wait really? Do they use special syntax or something?
19:40:12 <nbouscal> though more than likely, using them just slowed my company down because the other coders will get confused and replace them with for loops
19:40:15 <cads> hi ab9rf , dmwit
19:40:24 <ab9rf> hello?
19:40:28 * cmccann suggests reading http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/ to learn more about PHP than you wanted to know
19:40:30 <nbouscal> as far as i can tell they only exist for arrays
19:40:58 <ab9rf> cmccann: there are aspets of PHP wierdness that are not covered by that article, but it is quite good
19:41:10 <Mortchek> cmccann, that article would be a sufficient replacement for a ghost story around a programmer campfire
19:41:22 <cmccann> ab9rf: yes because it's not like that article is long enough already
19:41:29 <nbouscal> my favorite part about working in PHP is when my coworkers use the mysql_ extension which was replaced 8 years ago, and into their queries they pass completely unsanitized user input. and then they use the mysql password() function for hashing. i couldn't make this up
19:41:31 <ab9rf> cmccann: i think that should be required reading for anyone contemplating developing a lgnauge
19:42:06 <cmccann> nbouscal: SQL injection is a built-in site administration interface
19:42:08 <cmccann> it's a feature, see
19:42:14 <cads> Hey guys, I'm having trouble deploying the haskell platform for OSX. Specifically, has anyone managed to download the required Xcode dependency without... giving your credit card information to apple?
19:42:26 <Mortchek> nbouscal, I once tried to enter a comment on a some site for my school, noticed it came back with a SQL error, and told the web admin exactly what PHP function he needed to use to prevent terrible things from happening.
19:42:26 <ab9rf> haha
19:42:32 <nbouscal> cads: pretty sure they had my CC from way back
19:42:35 * ab9rf knows nothing about OSX
19:43:31 <cads> Haskell platform on OSX seems to depend on the Xcode build platform (which seems to be a collection of Unix build tools). However as of last December, it seems that apple has become really adamant about making everyone register with their credit cards.
19:43:46 <nbouscal> Mortchek: answering PHP questions on Stack Overflow is painful because of how many people use deprecated code. The documentation (if you can call it that) has bright red warning boxes, and yet still…
19:44:04 <nbouscal> cads: Most dev stuff on OS X seems to depend on Xcode
19:44:31 <cmccann> nbouscal: I like to forget just how terrible most of StackOverflow is, especially tags like [php]
19:44:40 <cmccann> the [haskell] tag is nice
19:45:00 <cads> nbouscal: it's a minor inconvenience to have to use my CC - I just happen to be away from it now, so I'm going to have to wait till I get back to it.
19:45:07 <nbouscal> cmccann: yeah. i tend to browse php and jQuery stuff because i'm not smart enough to answer any haskell questions :P
19:45:19 <Mortchek> Sometimes I forget whether I'm browsing http://math.stackexchange.com/ or the Haskell tag on StackOverflow
19:45:23 <cmccann> nbouscal: never stopped me!
19:45:30 <nbouscal> hehe
19:45:39 <nbouscal> I used to spend more time on Math.SE, I should get back to it.
19:45:50 <nbouscal> one of my goals is to eventually understand a fraction of what the hell they're talking about on Math Overflow
19:45:57 <cmccann> srsly, answering easier Haskell questions is a good way to learn the language
19:46:09 <nbouscal> oh for sure. teaching is by far the best way to learn
19:46:23 <nbouscal> goes for pretty much anything
19:46:25 <cads> I'm thinking of installing haskell in a ubuntu VM, but it seems like overkill. Any other ideas for getting the haskell platform running without my credit card info would be appreciated
19:46:37 <nbouscal> maybe try it in XQuartz?
19:47:08 <cmccann> also, more people should help sclv clean up unanswered questions in the [haskell] tag!
19:47:37 <sclv> the ones left are obscure or hard :-(
19:47:47 <dmwit> I have a bookmarked question where he asked me to turn a comment into a question. I'll get around to it eventually, I swear!
19:47:49 <cmccann> but there's like 200!
19:47:59 <dmwit> uh
19:48:03 <dmwit> s/question/answer/
19:48:05 <sclv> dmwit: you're one of the two worst offenders
19:48:11 <tgeeky> bwhahaha
19:48:13 <sclv> dfischer is i think the other
19:48:14 <cmccann> surely some of those are answerable, besides the ones you already did answer.
19:48:17 <ab9rf> i haven't figured out how to actually participate on stack overflow
19:48:30 <sclv> yeah the ones i already did answer often need a single upvote to my answer
19:48:34 <sclv> to knock 'em off the list
19:48:35 <nbouscal> 'Answer questions by pretending you know things' has been my strategy so far
19:48:46 <sclv> (not trolling for karma, i don't need more really)
19:48:50 <cmccann> sclv: I upvoted a few recently from you and other people
19:48:54 <sclv> :-)
19:49:06 <sclv> there's some answers that i just can't bring myself to vote for in good conscience
19:49:13 <ab9rf> i dont' really hacve time to learn another social environment
19:49:40 <sclv> participating on SO: read the new questions, see if any look interesting in that you'd like to know the answer
19:49:44 <sclv> read the answers
19:49:45 <cmccann> but 1) I can't just upvote all of them or the serial vote script will kick in 2) I can't justify upvoting answers if I can't tell whether they work
19:49:56 * dmwit apologizes for nothing
19:49:59 <ab9rf> so instead i troll PHP communities, making fun od them fdor all being idiots
19:50:25 <nbouscal> hahaha
19:50:31 <sclv> also you'll start to see questions you know how to answer, answer them.
19:50:32 <nbouscal> hey some of us don't have a choice
19:50:33 <sclv> that's it!
19:50:37 <tgeeky> dmwit: that's a lie an I can prove it: you're married.
19:50:43 <djahandarie> I haven't been able to get into the Haskell SO
19:50:54 <sclv> its way busier than when i started
19:51:04 <sclv> but v. responsive and good still.
19:51:09 <djahandarie> Yeah. There's that and it just seems that most of the questions aren't interesting to me.
19:51:12 <cmccann> sclv: so I skipped a lot of your answers where it was basically "you could try this, it might help" and the questioner is long gone and never responded to anything :T
19:51:13 <sclv> just usually now someone beats me to good answers.
19:51:28 <ab9rf> i don't care for the "rush to answer" and the whole karma whoring thing
19:51:32 <dmwit> tgeeky: =D
19:51:38 <sclv> cmccann: i wish we had a better way to knock those off the list
19:51:58 <cmccann> other than close them, not much
19:52:01 <sclv> i was so pleased i finally got a "populist" badge for an answer over 20 pts that was twice as high as the accepted answer
19:52:08 <nbouscal> haha nice
19:52:21 <nbouscal> gamification works way too well on me, i want all the badges
19:52:36 * cmccann has two populist badges...
19:52:51 <djahandarie> I have the populist badge.
19:52:59 <djahandarie> And I only have two answers.
19:53:18 <djahandarie> The populist badge came from answering a Harrop question.
19:53:22 <sclv> hahaah
19:53:25 <cmccann> hahahahaha
19:53:36 <sclv> i joined SO because i saw some terrible harrop answers
19:53:45 <sclv> and i wanted to downvote them but it was like "you need karma first"
19:53:50 <sclv> so i went and answered a bunch of stuff
19:54:23 <cmccann> I was looking something up on wikipedia the other day and apparently at one point there was a huge fuss because harrop kept spamming articles with links to his company and eventually he got banned or something
19:54:50 <cmccann> it was frickin hilarious, like wikipedia drama usually is
19:55:39 <ab9rf> wikipedia is incredibly good at drama
19:56:09 <Nafai> djahandarie: let me guess, a carefully worded question intended to troll?
19:56:20 <nbouscal> cmccann: Just started this PHP article and the analogy he starts with is both spot-on and really really funny
19:56:35 <cmccann> nbouscal: that link I gave a bit ago?
19:56:38 <djahandarie> Nafai, be your own judge. http://stackoverflow.com/questions/4559399/can-parser-combinators-be-made-efficient
19:56:40 <nbouscal> yea
19:56:45 <cmccann> haha, have fun
19:56:50 <cmccann> you'll be crying by the end I bet
19:57:01 <nbouscal> more than likely
19:57:06 <simpson> nbouscal: Oh, eevee's rant? It's pretty great.
19:57:33 <cmccann> simpson: yes
19:58:49 <Nafai> djahandarie: thanks.
20:16:06 <nbouscal> Yeah it's sure something to see it all written out in one place like that
20:16:50 <dmwit> lolphp.reddit.com
20:17:46 <nbouscal> hahaha i love the double-tailed hammer logo
20:18:03 <monochrom> heh
20:20:26 <nbouscal> Yeah, I am at least hopeful that my company's small enough that I can get us using proper technology soon
20:20:52 <nbouscal> my boss has already given the ok on a rails project, so at least going the right direction
20:28:16 <cmccann> nbouscal: at least rails is developed by true professionals, like this guy: http://blog.wekeroad.com/wp-content/uploads/2007/10/dhh-fu.jpg
20:29:13 <tgeeky> maybe the previous slide said "Hitler"
20:31:02 <koninkje> Any Text gurus about?
20:31:27 <shachaf> Ask your question and see! :-)
20:31:54 <shachaf> Oh, koninkje = wren ng thornton?
20:32:43 <cmccann> or a clever impostor perhaps
20:32:44 <koninkje> Basically, I'm looking for an incremental ByteString -> Text function (where the ByteString is utf8). The trick being, it needs to be incremental for iteratee-like processing
20:32:46 <nbouscal> cmccann: yeah, i had him in my twitter feed for a brief while but got tired of seeing rand paul retweets
20:32:52 <koninkje> shachaf: indeed...
20:32:54 <cmccann> hahahaha
20:34:08 <shachaf> Well, there's lazy ByteString -> lazy Text, but that's probably not what you're after.
20:34:19 <koninkje> that is, I have some incremental utf8 ByteString, but I want to use Attoparsec's Text parsing
20:35:08 <hpaste> karirkoe revised “penting, panas, perlu, seru”: “Penting, Panas, Perlu dan Seruu” at http://hpaste.org/85727
20:35:22 <technopredator> Hi I need help
20:35:34 <koninkje> shachaf: does the lazy BS -> lazy Text handle characters that are broken up across chunks?
20:35:44 <shachaf> koninkje: I should hope so.
20:36:05 <technopredator> why this doesn't work? doubleUS x y = x*2 + y*2
20:36:09 <shachaf> Otherwise it breaks the abstraction. That would be awful.
20:36:19 <dmwit> > let doubleUS x y = x*2 + y*2 in doubleUS 3 4
20:36:21 <lambdabot>   14
20:36:26 <dmwit> technopredator: Looks like it works to me.
20:36:55 <technopredator> damn then why GHCi vices an error?
20:37:09 <tgeeky> technopredator: you forgot 'let'
20:38:34 <nbouscal> technopredator: GHCi is not the same REPL experience as some other language's REPLs
20:38:36 <koninkje> actually, just having some (Parser ByteString a -> Parser Text a) would suffice...
20:38:36 <technopredator> but 'learn you a a Haskell' book doesn't use let and it worked with another function that doesn't use let: doubleMe x=x+x
20:38:52 <arkeet> ghci is not a .hs file
20:38:54 <shachaf> koninkje: Yep, it does.
20:38:55 <tgeeky> technopredator: LYAH expects you are saving things to files after it introduces this
20:41:31 <shachaf> koninkje: What sort of iteratee-like thing are you using?
20:41:31 <technopredator> I'm saving it to 'baby.hs' as it says but ti doesn't work as the book. Maybe it worked on a earlier  compiler? I'm a noob Haskell programmer so ' (Parser ByteString a -> Parser Text a)'  I don't have a clue what that is
20:43:01 * hackagebot conjugateGradient 2.1 - Sparse matrix linear-equation solver  http://hackage.haskell.org/package/conjugateGradient-2.1 (LeventErkok)
20:43:59 <dmwit> technopredator: koninkje and shachaf are having their own conversation that isn't related to your problem.
20:44:11 <technopredator> yeah I just realized it wasn't for me
20:44:12 <dmwit> technopredator: Can you please show us the exact file you created, and the error that ghc(i) gives you?
20:44:15 <dmwit> ?hpaste
20:44:15 <lambdabot> Haskell pastebin: http://hpaste.org/
20:44:20 <jmcarthur> technopredator: if you name the file Baby.hs and put "module Baby where" at the top of the file, you should be able to put top-level definitions there and load it into ghci
20:46:21 <technopredator> OK, the book says to put only 2 lines on it: doubleMe x = x + x (works fine) and doubleUs x y = x*2 + y*2 (doesn't work directly on GHCi or in file)
20:47:20 <technopredator> I put "module Baby where" as the first line of 'baby.hs' and it didn't help
20:48:02 <technopredator> same error: <interactive>:8:1:
20:48:04 <technopredator>     Not in scope: `doubleUs'
20:48:05 <technopredator>     Perhaps you meant one of these:
20:48:07 <technopredator>       `doubleUS' (line 3), `doubleMe' (line 2)
20:48:16 <cmears> mispelling?
20:48:22 <dmwit> technopredator: capitalization matters
20:48:36 <ab9rf> yeah, you had doubleUS in one place and doubleUs in the other
20:48:38 <dmwit> technopredator: If your file says doubleUS, you have to type doubleUS (not doubleUs) in ghci to use it.
20:48:55 <technopredator> I put it exactly how the book indicates
20:49:06 <dmwit> I don't believe you.
20:49:11 <dmwit> ?where LYAH
20:49:12 <lambdabot> http://www.learnyouahaskell.com/
20:49:32 <ab9rf> technopredator: you should recheck your assumptions
20:50:09 <dmwit> Confirmed: you did not do exactly what the book says.
20:50:36 <mgccl> is there a way to just type check a program? so I don't have to implement the functions? Say I just write the function type definition, and compiler just check if every point I use this function, the definition checks out, it passes.
20:50:38 <technopredator> rechecking..
20:51:03 <cmears> mgccl: a quick workaround is to define them as "undefined"
20:51:03 <dmwit> mgccl: implement it with "undefined"
20:51:10 <dmwit> :t undefined
20:51:12 <lambdabot> a
20:51:20 <cmccann> or (error "TODO") or such
20:51:31 <dmwit> :t error "TODO"
20:51:32 <lambdabot> a
20:51:44 <arkeet> :t let x = x in x
20:51:45 <lambdabot> t
20:51:53 <dmwit> Well, that one's obviously no good.
20:51:59 <dmwit> Its type isn't "a".
20:52:04 <arkeet> :(
20:52:32 <cmccann> :t let x = x in x `asTypeOf` undefined
20:52:33 <lambdabot> a
20:52:34 <cmccann> fixed it
20:52:41 <dmwit> yaaaay
20:52:53 <dmwit> also: kind of hilarious
20:53:07 <cmccann> that is probably the worst use of asTypeOf ever.
20:53:15 <mgccl> oh this is awesome... I was wondering how to write pseudocode for algorithms but still type checks! Haskell is perfect as I don't have to implement the pseudocodes!
20:53:17 <dmwit> How did you know unification would choose to rewrite t => a instead of a => t? =P
20:53:22 <otters> > let x = x; y = y in x == y
20:53:26 <lambdabot>   mueval-core: Time limit exceeded
20:53:28 <otters> oh, damn
20:53:38 <GOMADWarrior> http://tilebased.hp.af.cm/
20:53:46 <cmccann> dmwit: guessed, and then asked lambdabot in /msg to test first :P
20:53:59 <dmwit> hahaha
20:54:11 <arkeet> > let x == y = True in 1 == 2
20:54:11 <dmwit> That's why they call it computer _science_!
20:54:13 <lambdabot>   True
20:54:41 <cmccann> plan B was to suggest using unsafeCoerce
20:55:43 <cmccann> dmwit: that said, it was a pretty confident guess
20:55:47 <dmwit> yeah
20:55:50 <cmccann> 't' is usually a fabricated type variable
20:55:58 <cmccann> whereas undefined :: a is probably an explicit annotation
20:56:01 <cmccann> and it favors those
20:58:00 <dmwit> < let x = 1 in (x(), x == 2)
20:58:04 <goodfellow>   mueval-core: Time limit exceeded
20:58:32 <dmwit> < let x = 1 in (x(), x == 2)
20:58:34 <goodfellow>   (1,False)
20:58:35 <technopredator> can you indicate where misspelled please? I can't find my error
20:58:46 <dmwit> technopredator: the s in doubleUS
20:59:17 <technopredator> oh damn, thx
20:59:18 <dmwit> See also my comment 11 minutes ago to this effect.
20:59:28 <dmwit> (and everyone else's, too)
21:02:02 <technopredator> yeah, I read it, thx
21:02:23 <GOMADWarrior> > let 1 == 2
21:02:25 <lambdabot>   <hint>:1:11: parse error (possibly incorrect indentation)
21:02:25 <technopredator> I read too fast didn't see the correction at all
21:03:26 <dmwit> Oh, x is not as monomorphic as I thought it would be. Even \bot can handle that.
21:03:32 <dmwit> > let x = 1 in (x(), x == 2)
21:03:34 <lambdabot>   (1,False)
21:07:26 <Rotaerk> does GHCi ignore export lists?
21:07:38 <Rotaerk> seems to let me use things I didn't export
21:08:06 <parcs> yeah if the currently loaded source file has everything in scope
21:08:21 <ryant5000> Rotaerk: that's what the "*" before the module name means
21:08:29 <Rotaerk> ah
21:08:39 <ryant5000> Rotaerk: you can use * when you're adding modules to scope with :m, too, if you want, but only if those modules are interpreted
21:08:48 <Rotaerk> k
21:08:49 <ryant5000> e.g.: :m + *MyModule
21:09:56 <scroy> > let f x = (show x, x+5)
21:09:57 <lambdabot>   not an expression: `let f x = (show x, x+5)'
21:10:31 <scroy> > Control.Monad.State.state (\x -> (show x, x+5))
21:10:33 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Base.String))
21:10:33 <lambdabot>    arising from a use ...
21:10:59 <scroy> > let s = Control.Monad.State.state (\x -> (show x, x+5)) in s 4
21:11:01 <lambdabot>   No instance for (Control.Monad.State.Class.MonadState a0 ((->) a1))
21:11:01 <lambdabot>    aris...
21:11:18 <scroy> can someone help me out? i got it to work earlier but i forget what i did
21:11:32 <scroy> just trying out the State monad
21:12:50 <Rotaerk> :t Control.Monad.State.state (\x -> (show x, x + 5))
21:12:52 <lambdabot> (Num a, Show a, MonadState a m) => m String
21:13:19 <Rotaerk> and you just tried to apply that to 4 as though it were a function
21:13:46 <scroy> :t Control.Monad.State.state
21:13:48 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
21:13:51 <technopredator> can I ask a question off topic?
21:14:07 <scroy> Rotaerk: i thought i could get a State monad from this function
21:14:24 <simpson> technopredator: In general, no, but I suppose you can ask anyway.
21:14:25 <technopredator> is kind of religious related?
21:14:30 <simpson> Nope.
21:14:36 <technopredator> ok
21:14:40 <simpson> Nope nope. Go to -blah if you want to be offtopic like that.
21:15:01 <Rotaerk> scroy, you it does give you a state monad; when you apply state to (\x -> (show x, x + 5))
21:15:01 <technopredator> the answer is just a yes or no
21:15:08 <technopredator> quick survey
21:15:14 <Rotaerk> technopredator, no
21:15:20 <technopredator> ok
21:15:45 <copumpkin> you can run a survey on a subset of the same people in #haskell-blah
21:16:05 <technopredator> ok thx
21:19:33 <scroy> Rotaerk: from what i'd read, a State monad is applicable.. is that completely wrong?
21:21:20 <scroy> Rotaerk: for instance http://en.wikipedia.org/wiki/Monad_(functional_programming)#State_monads
21:21:48 <Rotaerk> scroy, that is not how State is defined in haskell
21:21:56 <scroy> i know it's simplified, but it seems to be a working definition
21:22:21 <Rotaerk> http://www.haskell.org/haskellwiki/State_Monad
21:22:26 <Rotaerk> look at that for how to use
21:22:42 <Rotaerk> of course, that is for State not MonadState
21:23:08 <scroy> Rotaerk: i am
21:23:24 <Rotaerk> scroy, look at how they're applying "runState"
21:23:35 <scroy> oh, is that what i want?
21:23:44 <scroy> i think that's what i used earlier
21:24:05 <scroy> yeah
21:24:45 <scroy> ok, thx Rotaerk
21:33:08 * hackagebot antigate 0.6 - Interface for antigate.com captcha recognition API  http://hackage.haskell.org/package/antigate-0.6 (MikhailKuddah)
21:36:38 <orzo> hi
21:40:13 <lightquake> i really want to write code with pipes, but i'm not sure what to do
22:57:18 <latermuse> lightquake: so make a tech demo and figure out how it all works
22:58:20 <Zeev> does haskell have inline intellisense (like F#)?
22:59:29 <lightquake> latermuse: but i want to build something *neat*
22:59:43 <lightquake> Zeev: depending on your editor, it might support different levels of autocomplete
22:59:51 <lightquake> i've never used f# so i can't say how it compares
22:59:54 <Zeev> what's the best one
23:00:11 <Zeev> try tryfsharp.org to see what i mean
23:00:26 <ryant5000> has anyone ever actually used a threaded state "monad" in practice?
23:01:09 <ryant5000> rebindable syntax seems to make it somewhat possible, but i'm wondering if there are any serious pitfalls
23:01:26 <Zeev> it during typing underlines the errors in code
23:01:42 <Zeev> like symbols that, weren't declared, incorrect type etc
23:02:06 <Zeev> anyway f# is f#
23:02:12 <ryant5000> Zeev:  you could try 'leksah'
23:02:15 <ryant5000> you can cabal-install it
23:02:44 <Ralith> Zeev: that's not what most people mean by "intellisense", but emacs with ghc-mod's flymake minor mode does that quite nicely
23:03:17 <Zeev> by intellisense I also mean list of methods, when u press '.'
23:03:42 <Ralith> haskell has neither . nor methods
23:03:53 <Ralith> well, it has a different .
23:04:19 <Zeev> and also if earlier you created object with some methods, now when you write "obj." it lists those methods, without compiling just inferences from what u typed earlier
23:05:09 <ryant5000> Zeev: haskell doesn't really have a notion of "object"
23:05:46 <startling> there could theoretically be autocomplete for values that would typecheck where you're typing, though
23:05:51 <nbouscal> apparently comonads, but, yeah.
23:06:07 <ryant5000> nbouscal: lol; depends on how you define object, i think
23:06:26 <nbouscal> yeah, nobody really has a good definition of object or of OO generally
23:06:37 <nbouscal> there's a funny c2.org article about it
23:06:42 <ryant5000> nbouscal: yeah
23:06:46 <nbouscal> err com. whatever it is
23:06:56 <h4199> zeev is probably not going to enjoy the comonadic object rabbithole on his first haskell outing
23:06:58 <nbouscal> http://c2.com/cgi/wiki?NobodyAgreesOnWhatOoIs
23:07:26 <nbouscal> h4199: that's kind of what i meant by the "but, yeah" part :P
23:14:51 <h4199> In all seriousness Zeev, object orientation and the accompanying methodology will not be something you can one to one map onto haskell. So in answer to that question, that kind of object method autocompletion does not exist for any subset of haskell that I am aware of.
23:14:52 <h4199> Though most editors keep track of functions that you have written previously and can autocomplete those. Boilerplate declarations can be automated in Vim and sublimetext and probably other editors.
23:14:54 <h4199> Also there is EclipseFP which might be along the lines of what you want.
23:14:55 <h4199> http://eclipsefp.github.io/
23:15:41 <nbouscal> Might also be worth playing with Scala a bit as a bridge
23:39:14 <rifki> hello, I need to do this in haskell : I have two lists, if an element in second list is also in the first one do something else, add the element at the end of the first list. I couldn't find an efficient way to do this. Any ideas?
23:40:01 <dmwit> As in, if any element in the second list is in the first one?
23:40:24 <dmwit> My inclination would be to just call Data.Set.fromList on both and check whether the intersection is null.
23:42:32 <rifki> dmwit : lists could be like this : l1 = [1,2,3,4,5] l2= [6,1,7,2,9]
23:43:36 <dmwit> And what's the desired output?
23:44:09 <hpaste> nh2 pasted “weird desugared error message” at http://hpaste.org/86113
23:45:06 <hpaste> otters revised “weird desugared error message”: “the right way to do if then do” at http://hpaste.org/86113
23:45:07 <dmwit> nh2: Perhaps, as the error says, you meant to use -XDoAndIfThenElse.
23:45:11 <rifki> the output is complicated, actually lists are graph nodes. I should merge the same nodes and add the other nodes to the l1
23:45:16 <dmwit> nh2: Otherwise, indent else a tiny bit.
23:45:17 <otters> nh2: that might help
23:45:34 <shachaf> My new Proxy proposal is to use Maybe instead.
23:46:14 <dmwit> Doesn't Haskell2010 include DoAndIfThenElse?
23:46:19 <dmwit> If so, perhaps you meant to upgrade GHC. =P
23:47:04 <Cale> otters: It might be better in general to annotate rather than revising things :)
23:47:14 <otters> maybe so
23:47:32 <Cale> (If you edit it, then I get confused about why GHC is putting a semicolon there)
23:47:36 <Cale> :)
23:47:36 <otters> yeah
23:47:38 <otters> okay
23:47:49 <Cale> It's fine, just took me a moment :)
23:48:15 <Cale> rifki: are you still here?
23:48:17 <sw2wolf> > ([1,2,3,4,5] \\ [4,5,6]) ++ ([4,5,6])
23:48:19 <lambdabot>   [1,2,3,4,5,6]
23:48:27 <rifki> Cale : yes
23:48:38 <Cale> rifki: I'm not sure I understand what it is that you're looking for
23:48:55 <Cale> rifki: Could you give an example of some kind?
23:49:05 <Cale> oh
23:49:12 <Cale> I missed one of your messages
23:49:20 <rifki> Cale : yes, Iam making a hpaste to be more clear
23:49:22 <Cale> So you want a union basically
23:50:01 <Cale> > union [1,2,3,4,5] [6,1,7,2,9]
23:50:03 <lambdabot>   [1,2,3,4,5,6,7,9]
23:50:08 <Cale> this?
23:50:56 <Cale> > union [1,2,3,4,5,5,5] [6,1,7,2,9,9,9] -- Note that duplicates are removed from the second list, but not the first
23:50:58 <lambdabot>   [1,2,3,4,5,5,5,6,7,9]
23:51:22 <Cale> If you need set-like behaviour, you should use a Set
23:51:23 <rifki> Cale : a different version of it. it does a different things on same elements
23:51:40 <hpaste> “rifki ” pasted “list union” at http://hpaste.org/86115
23:53:53 <hpaste> “rifki ” revised “list union”: “list union” at http://hpaste.org/86115
23:55:05 <Cale> rifki: I assume you don't want at least one of those = signs?
23:55:47 <rifki> Cale : yeah, the first one is the one I don't want.
23:56:15 <hpaste> Cale revised “list union”: “formatted” at http://hpaste.org/86115
23:56:26 <Cale> Check that my reformat didn't ruin anything?
23:56:59 <rifki> no it didn't :)
23:57:06 <Cale> okay
23:57:41 <Cale> The simplest way to do this would be to use Data.Map
23:59:35 <rifki> Can you give a hint for using a recursive algorithm? I think I found one but it is highly inefficient and hard to implement
23:59:56 <Cale> graphToMap nodes = Map.fromList [(x,xs) | Node x xs <- nodes]
