00:10:06 <Kinnison> monochrom: I shall pop that on my to-read list
00:17:32 <eikke> has anyone ever written something to merge(sort) 2 sorted conduit sources?
00:32:59 <DarkFox> Anyone here with experience with pandoc? Is there anything wrong with this? $if(url)$<a href="$url$">$title$</a>$else$$title$$endif$
00:32:59 <lambdabot> DarkFox: You have 1 new message. '/msg lambdabot @messages' to read it.
00:37:54 * hackagebot ghc-core-html 0.1.0 - Core to HTML display  http://hackage.haskell.org/package/ghc-core-html-0.1.0 (VincentHanquez)
01:01:20 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/104783
01:04:28 <huad> is there any goto in haskell? is continuation passing style is equavelent of goto
01:04:50 <matthias_g> Goto in haskell wouldn't really make sense..
01:05:06 <latermuse> matthias_g: it makes sense, but it wouldnt be useful
01:05:12 <matthias_g> Tail calls might be the closest thing.
01:05:37 <matthias_g> How would it make sense?  Apart from IO, you can even call about an instruction pointer that would be manipulated with the goto.
01:05:58 <matthias_g> can -> can't.
01:06:03 <matthias_g> call -> talk.
01:10:34 <Cale> You can create a goto in Cont/ContT
01:10:41 <Cale> more or less
01:10:50 <shachaf> Well, you need something more involved to make a real goto.
01:11:01 <shachaf> That can go forward, for instance.
01:11:23 <Cale> Yeah, the label is a value which is created by a particular action, so you can't jump forward to a point you haven't been yet.
01:11:33 <Cale> But on the other hand, it is first class.
01:12:17 <flux> it's not really a goto when you can't just "jump" to a place where a label exists without it having been assigned a value..
01:12:44 <flux> so when it's so safe :-)
01:13:08 <shachaf> Well, you can make a goto that jumps forward too.
01:28:14 <Targen> What causes GHCi to build a .so file in /tmp for each expression evaluated in the REPL?  I’d never noticed it doing that before.
01:29:24 <no-n[2]> how do I check if a Double is an integer? (not to be confused with Integer)
01:29:50 <no-n[2]> I would use mod but it only works on Integral typeclass
01:30:08 <mauke_tmp> :t modf
01:30:09 <lambdabot>     Not in scope: `modf'
01:30:09 <lambdabot>     Perhaps you meant one of these:
01:30:09 <lambdabot>       `mod' (imported from Prelude), mod' (imported from Data.Fixed),
01:30:38 <no-n[2]> nothing on hoogle for modf
01:31:06 <mauke_tmp> :t properFraction
01:31:07 <lambdabot> (Integral b, RealFrac a) => a -> (b, a)
01:31:20 <mauke_tmp> > properFraction 2
01:31:21 <lambdabot>   (2,0.0)
01:31:30 <no-n[2]> ahh, mod' from Data.Fixed works
01:32:22 <arkeet> so does properFraction
01:33:30 <Ghoul_> Anyone know how to use parsec buildExpressionParser to match 3 the same as (((3))) the same as 3 > 0
01:52:56 * hackagebot aeson-bson 0.2.0 - Mapping between Aeson's JSON and Bson objects.  http://hackage.haskell.org/package/aeson-bson-0.2.0 (AlfredoDiNapoli)
02:25:42 <shirt> how can i join a thread?
02:26:02 <danr> do you mean wait for it to terminate?
02:27:46 <t7> @pl \x y -> x + (foo y)
02:27:46 <lambdabot> (. foo) . (+)
02:28:05 <shachaf> shirt: Do your own synchronization with an MVar, or (preferably) use some library that does it for you, like async.
02:28:27 <shachaf> @hackage async lets you spawn threads that you can wait on and which give you results.
02:28:27 <lambdabot> http://hackage.haskell.org/package/async lets you spawn threads that you can wait on and which give you results.
02:29:15 <shirt> thanks
02:29:34 <neutrino> is there an async-based implementation of futures?
02:32:58 * hackagebot mainland-pretty 0.2.6 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.2.6 (GeoffreyMainland)
02:33:54 <mr-> wow, async is awesome
02:38:04 <Cale> mr-: it is :)
02:38:37 <Cale> It's good to see libraries starting to crop up that are actually built on top of the good foundational stuff that STM was meant to be
02:39:19 <mr-> weird.. race (threadDelay 10 >> return "10") (threadDelay 20 >> return "20") -- returns 20, only when I increase the right delay to 60 does it start to return 10
02:39:56 <mr-> guess it's the time it takes to start the second
02:40:07 <mel-> hi
02:41:37 <quchen> mr-: threadDelay uses microseconds, so 10 and 20 aren't very different. Try it with 10^6 and 2*10^6
02:42:55 <mr-> quchen: Yeah.. I realize it was stupid to expect it to work on that scale ;-)
02:43:42 <dEPy> I'm  reading LYAH and I'm confused with monoids O_o
02:44:41 <Botje> which part is confusing?
02:45:42 <dEPy> Basically monoids are for composing things right? I kinda undestand the basics but I got confused with the sample of Ordering.
02:45:54 <mr-> but it's awesome.. one simple instruction to handle a "Oh.. this thread is taking too long" :-)
02:47:36 <adimit> so there's a proof that well-typed ML programs don't cause runtime type-errors due to the HM algorithm. Is there a similar proof for Haskell programs? Its type system is quite bit more extensive, and uses a different variant of System F internally, afaik.
02:47:38 <quchen> mr-: You mean you can let a thread race against a dummy "threadDelay" thread? Good idea actually
02:47:58 * hackagebot groundhog-th 0.3.0.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.3.0.2 (BorisLykah)
02:48:07 <mr-> quchen: yeah
02:48:18 <Botje> dEPy: well, mappend for orderings takes the right argument if the left one is EQ, otherwise it takes the left one
02:48:54 <t7> does this exist in std lib: \xs -> tail xs : head xs
02:49:13 <adimit> t7: it can't.
02:49:17 <Botje> that's a type error
02:49:19 <t7> ++
02:49:24 <quchen> []
02:49:28 <adimit> > \xs -> tail xs ++ head xs
02:49:29 <t7> ++ [head xs]
02:49:29 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
02:49:32 <adimit> still a type error.
02:49:37 <adimit> ok, better.
02:49:43 <adimit> I don't think so
02:50:01 <adimit> it'd be terribly inefficient, too, I think.
02:50:27 <t7> not really
02:50:28 <quchen> You're looking for rotating a list, a better way would be using drop and cycle: let rotate n = drop n . cycle
02:50:35 <quchen> eh
02:50:37 <quchen> And then take
02:51:43 <quchen> Or better, zipWith const so you don't need to know your list's length
02:51:47 <merijn> t7: Isn't that just fold with flip (:)?
02:53:25 <quchen> merijn: ?
02:53:27 <adimit> t7: append is linear in its left-hand argument: it has to traverse the entire list first.
02:53:30 <quchen> foldl (flip (:)) = reverse
02:53:34 <quchen> foldr (:) = id
02:54:07 <t7> adimit, your gonna have to traverse a list to put something at the end ...  ?
02:55:53 <adimit> t7: not necessarily. You can use a difference list, or some of the other alternatives. Of course, this is only relevant if you're planning to do this operation often, or on a big list.
02:56:57 <hpaste> Quchen pasted “rotate left” at http://hpaste.org/86305
03:05:11 <merijn> quchen: Oh, I wasn't paying attention. Forget what I said
03:07:20 <FireFly> @pl \xs -> tail xs ++ [head xs]  -- I wonder what @pl could come up with for that
03:07:21 <lambdabot> liftM2 (++) tail (return . head)
03:08:00 <t7> can i do nested gaurds ?
03:08:07 <adimit> something … something …list Monad… not surprising :-)
03:10:52 <danr> > let rot = flip ((!!) . iterate ((++) <$> tail <*> return . head)) in rot 3 "apabepa"
03:10:54 <lambdabot>   "bepaapa"
03:13:03 <arkeet> @pl rot n xs = zipWith (const id) xs (drop n $ cycle xs)
03:13:03 <lambdabot> rot = ap (zipWith (const id)) . (. cycle) . drop
03:13:26 <arkeet> > let rot = rot = ap (zipWith (const id)) . (. cycle) . drop in rot 3 "apabepa"
03:13:27 <lambdabot>   <hint>:1:15: parse error on input `='
03:13:31 <arkeet> > let rot = ap (zipWith (const id)) . (. cycle) . drop in rot 3 "apabepa"
03:13:33 <lambdabot>   "bepaapa"
03:14:27 <arkeet> > let rot n = zipWith (const id) <*> drop n . cycle in rot 3 "abcdefg"
03:14:29 <lambdabot>   "defgabc"
03:14:43 <arkeet> > let rot n = zipWith (const id) <*> drop n . cycle in rot 3 ""
03:14:45 <lambdabot>   ""
03:15:19 <pxqr> Is there something like findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a) ?
03:16:10 <FireFly> Could any Haskell function be written in points-free style based on a finite set of predefined functions? is there a proof of that? has anyone tried to minimise that set of functions?
03:16:15 <FireFly> (@pl got me curious :P)
03:16:48 <adimit> FireFly: you should take a look at concatenative programming.
03:16:56 <FireFly> Oh, right
03:17:14 <FireFly> I've actually read a bit about it
03:17:17 <adimit> it's pretty much in that spirit of just modifying data with combinators. Excessive use of @pl is known to cause brain damage.
03:17:22 <arkeet> combinator calculus
03:17:24 <FireFly> So that's a "yes" then
03:17:44 <arkeet> any nonrecursive thing can be written with S and K (ap and const)
03:17:55 <arkeet> for recursion, just add Y (fix)
03:18:11 <pxqr> FireFly: stg actually implemented this way as far as i understand (and like any other G-machine)
03:18:47 <adimit> I wouldn't want to give a general "yes", really, because haskell is big and nasty, so some corner of it might not be accesible with point-free style. But "mostly, yes" sounds safe.
03:19:03 <arkeet> what corner?
03:19:12 <adimit> well, that's the point, I don't know.
03:19:13 <jesyspa> Y can be implemented in terms of S and K, afaik.
03:19:42 <arkeet> uh no
03:19:52 <Saizan> in untyped SKI it can
03:19:59 <arkeet> well sure.
03:20:07 <jesyspa> Ah, yeah, forgot about typing issues.
03:22:16 <adnap> When were type families firsts supported by GHC?
03:22:20 <adnap> *first
03:24:12 <Saizan> somewhere around 6.12
03:24:31 <arkeet> so
03:24:35 <arkeet> does that mean
03:24:41 <arkeet> we can implement Y using S, K, and unsafeCoerce?
03:25:26 <Saizan> sure
03:25:32 <arkeet> :p
03:26:49 <arkeet> haha it works.
03:27:27 <arkeet> y :: (t -> t) -> t; y = s (k (s (u i) i)) (s (s (k s) k) (k (s (u i) i)))
03:27:32 <arkeet> where u = unsafeCoerce
03:29:40 <Saizan> probably sends the inliner into a loop like the newtype version though :)
03:29:48 <arkeet> excellent.
03:30:36 <adimit> that's what you get for lying to the compiler :-P
03:31:49 <shachaf> arkeet: (u i)?
03:31:53 <shachaf> Is that different from u?
03:32:01 <qnikst> hello, is it possible to add cmm files compilation using cabal?
03:32:05 <arkeet> good question.
03:32:09 <shachaf> (I mean, you could use it at a non-function type. But are you?)
03:32:25 <shachaf> qnikst: I'm pretty sure it is.
03:32:30 <arkeet> yeah it works with u instead of u i
03:32:34 <shachaf> There are many packages that include cmm.
03:32:58 <shachaf> arkeet: For fun, change the rest of the is to us too.
03:32:59 * hackagebot shakespeare 1.0.5 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.5 (MichaelSnoyman)
03:33:02 * hackagebot shakespeare-js 1.1.4 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.1.4 (MichaelSnoyman)
03:33:08 <qnikst> shachaf: can you give some examples, I was failed to find at a first glance
03:33:14 <arkeet> yep, still works.
03:33:14 <arkeet> :p
03:33:25 <shachaf> qnikst: integer-gmp, which comes with GHC?
03:33:41 <shachaf> I can't really think of many off-hand.
03:33:42 <jesyspa> In a compiler course, I was taught about how functional languages can be compiled to SKI combinators.  However, looking at the aosa page for GHC and the intermediate represenations of compiled Haskell code, I can't find them anywhere; why is this?
03:33:52 <shachaf> @hackage ghc-dup is another one
03:33:52 <lambdabot> http://hackage.haskell.org/package/ghc-dup is another one
03:34:04 <qnikst> shachaf: thanks
03:34:22 <shachaf> qnikst: But note that integer-gmp is actually used, so it might be more up-to-date. :-)
03:34:33 <shachaf> jesyspa: They can be compiled into lots of things.
03:34:44 <qnikst> ok it's simple c-sources, fine
03:36:09 <merijn> jesyspa: "can" is not "have to" ;)
03:36:15 <jesyspa> shachaf: Is there a formal name for the approach GHC takes?
03:37:10 <neutrino> dEPy: do you know how orders on monoids in maths work?
03:37:29 <jesyspa> And why was the alternative taken?  Efficiency?
03:37:41 <dEPy> neutrino, no, no idea.
03:38:02 <neutrino> dEPy: try reading up on that. a lot of stuff about haskell data structures stems from very basic abstract algebra
03:38:42 <danr> jesyspa: ghc does not compile into SK combinators. you could for instance have a look at the paper "Making a fast curry..." http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/ where the STG language is explained
03:39:12 <danr> (which ghc does compile into)
03:39:20 <jesyspa> danr: Thanks, that looks like the kind of thing I'm looking for.
03:41:17 <shirt> what is the best way to get the current time?
03:41:19 <danr> jesyspa: np
03:41:58 <arkeet> shirt: have you looked at the 'time' package?
03:43:17 <shirt> arkeet: what about old-time?
03:44:08 <arkeet> that's old.
03:44:19 <arkeet> and you should use the new time.
03:46:37 <no-n[2]> "Prelude.read: no parse" <-- how would I catch this error?
03:47:10 <aleator> no-n[2]: http://hackage.haskell.org/package/safe-0.3.3
03:50:30 <merijn> no-n[2]: Don't use read
03:50:57 <merijn> no-n[2]: If you have GHC 7.6 use readMaybe from Text.Read, older versions have reads which you can pattern match to write your own readMaybe
03:52:27 <merijn> no-n[2]: Depending on what you're doing you might also want to use a proper parser or serialisation approach instead
03:52:43 <no-n[2]> ok
03:52:55 <no-n[2]> well it was just a little toy program so I don't think I'll bother with that
03:53:05 * hackagebot ois-input-manager 0.1.0.0 - wrapper for OIS input manager for use with hogre  http://hackage.haskell.org/package/ois-input-manager-0.1.0.0 (GregHorn)
03:53:07 * hackagebot MusicBrainz-libdiscid 0.5.0.0 - Binding to libdiscid by MusicBrainz  http://hackage.haskell.org/package/MusicBrainz-libdiscid-0.5.0.0 (AndreTwupack)
03:56:17 <merijn> no-n[2]: In that case either readMaybe/reads or just don't typo your input ;)
03:56:40 <no-n[2]> k :P
03:57:23 <merijn> You could also use Control.Exception, but that also might be overkill
03:57:41 <no-n[2]> yeah, I think I'll just leave it hehe
03:57:42 <hpc> with Control.Exception you also need readIO
03:57:54 <hpc> or some way of controlling when the read is evaluated
03:58:07 <hpc> catching pure exceptions is evil
03:58:19 <merijn> hpc: Not if you want to just fail up to some main loop and continue from there
03:58:34 <hpc> even then
03:58:42 <hpc> the solution is to just not throw pure exceptions
03:59:11 <merijn> I blame people for not supporting my suggestion on libraries@ to make readMaybe and readMaybeIO the default!
04:00:01 <hpc> for 8, they should change read :: String -> Maybe a, unsafeRead :: String -> a
04:00:06 <hpc> ditto for IO
04:00:15 <merijn> hpc: And head/tail! \o/
04:00:30 <hpc> @quote fromJust
04:00:30 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
04:00:39 <merijn> Although I guess this would require a change of the standard
04:00:53 <hpc> yeah
04:01:14 <merijn> I think no amount of lobbying will get that to happen, though
04:01:33 <hpc> it could if haskell was already up for another revision
04:01:43 <hpc> which will be in another 12 years at this rate
04:01:53 <Targen> still more likely than a functor superclass
04:02:03 <hpc> seriously... :P
04:02:54 <shachaf> jesyspa: If you want to get a general idea about how GHCcompiles things, you should read the STG paper.
04:02:58 <shachaf> @where stg
04:02:58 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
04:03:11 <hpc> @quote spineless
04:03:11 <lambdabot> JohnMeacham says: no matter what I name a AM.. it can never be as cool a name as 'spineless tagless g-machine'.
04:03:37 <jesyspa> Thanks, will do.
04:03:54 <shachaf> "fast curry" is about a specific optimization
04:06:15 <helmut> hi. can you tell me (or point to docs) about when overloading constructors in haskell is allowed / desirable?
04:06:36 <hpc> you can't overload constructors
04:07:13 <helmut> http://marc.info/?l=haskell&m=66622004921485 suggests otherwise
04:07:48 <dmwit> helmut: Each module can define each name up to once.
04:08:22 <helmut> but surely 0 is an overloaded constructor.
04:08:29 <hpc> no
04:08:32 <dmwit> Haven't looked at your link, though, so I'm not sure whether that's what you mean by overloading.
04:08:47 <hpc> 0 is syntax sugar for fromInteger (0 :: Integer)
04:08:47 <dmwit> Ah, right, 0 is not a constructor.
04:09:01 <helmut> thanks
04:09:08 <dmwit> ...and pattern matches on numeric literals are sugar for a guard with an equality test.
04:09:30 <merijn> helmut: You can't overload constructors, but you can use typeclasses to produce "overloaded" values
04:09:38 <merijn> Take for example Bounded
04:09:43 <merijn> > minBound :: Int
04:09:45 <lambdabot>   -9223372036854775808
04:09:46 <merijn> > minBound :: Char
04:09:48 <lambdabot>   '\NUL'
04:09:53 <hpc> helmut: note that these are lowercase values, not uppercase Constructors
04:09:57 <merijn> helmut: Maybe that's what you're looking for?
04:10:13 <hpc> there are "smart constructors" though, that you could put in a class
04:10:14 <hpc> :t state
04:10:15 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
04:10:16 <helmut> thank you very much. I was looking for how haskell handles this, because in Agda you are allowed to overload constructors.
04:10:37 <hpc> agda has much more freedom to do type-directed name resolution
04:11:03 <hpc> because it doesn't have so many evil ways of being polymorphic :P
04:11:15 <helmut> so you answered everything I wanted to know and more. thanks!
04:11:58 <hpc> i have a feeling the guy on that mailing list didn't test his code at all
04:12:43 <helmut> well 1993 is a bit dated, maybe the language (or compiler) was different back then?
04:13:11 <mr-> wow.. the internet has gotten old
04:14:06 <hpc> lol, i didn't even look at the date
04:16:01 <adimit> can someone recommend me a good introductory text (for somebody with good knowledge of formal (predicate and description) logic, but poor knowledge of type theory) for System F?
04:16:05 <dmwit> Okay, I just looked at the link. It sounds to me like this guy was proposing an extension to the compiler.
04:16:15 <dmwit> ("...but I wouldn't want to put such a constraint
04:16:17 <dmwit> into a type inference algorithm")
04:16:49 <dmwit> adimit: TAPL? =)
04:18:14 <adimit> dmwit: oh right. TAPL has been on my reading list for a while.
04:19:53 <adimit> damn, our library doesn't have it…
04:20:14 <hpc> request it
04:20:59 <adimit> I shall :-)
04:30:02 <danr> hpc: which messaghe from 1993 are you refering to?
04:39:42 <dmwit> danr: helmut posted a link
04:43:06 * hackagebot groundhog 0.3.0.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.3.0.1 (BorisLykah)
04:53:06 * hackagebot hflags 0.1.2 - Command line flag parser, very similar to Google's gflags  http://hackage.haskell.org/package/hflags-0.1.2 (GergelyRisko)
04:58:30 <quchen> Is there a way to make a terminating "rotate list right" function? For finite lists it's of course trivial, but can it be done for infinte lists? The first few elements of that list would of course be bottom ("last elements of the infinte lists"), but after that the values are known
04:58:47 <quchen> rotateR 1 [1..] = [bottom, 1, 2, 3, ...]
04:59:25 <quchen> On a side note, how are such functions called? They're not total as the results include bottom, but it's also not crashing on its own, right?
05:00:01 <shachaf> Yes, there is a way.
05:00:16 <shachaf> You can write splitAtFromEnd using a medium-clever trick.
05:00:23 <XexonixXexillion> :t \n -> (++ (replicate n undefined))
05:00:25 <lambdabot> Int -> [a] -> [a]
05:00:32 <shachaf> The trick is left as an exercise to the reader.
05:00:40 <shachaf> @where sneaky is the general idea.
05:00:40 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
05:01:45 <quchen> That's what I used for left rotations. Didn't think it would work out for right ones though.
05:01:51 <quchen> I'll try again then, thanks.
05:02:15 <shachaf> What did you use for left rotations?
05:02:51 <quchen> "zipWith const"
05:03:46 <dmwit> I feel like the really interesting trick here is to generate the cons nodes before generating the content inside them.
05:04:04 <shachaf> > let rotateLeft n xs = b ++ a where (a,b) = splitAt n xs in rotateLeft 2 "abcdefgh" -- ?
05:04:06 <lambdabot>   "cdefghab"
05:04:16 <shachaf> dmwit: Yes, something along those lines.
05:04:35 <shachaf> dmwit: You can also e.g. write a reverse function that yields cons cells as soon as it sees them, rather than only when it gets to the end of the list.
05:06:16 <xplat> still can't reverse an actual infinite list, but you can reverse its spine
05:07:10 <shachaf> Arguably the reverse of its spine is ⊥ rather than repeat ⊥
05:07:22 <shachaf> But it's still fun.
05:08:07 <xplat> more interesting is can you use that trick to multiply infinite lazy naturals?
05:08:57 <xplat> hm, or is there a problem in  the first place?  i remembered one, but now i can't find it
05:09:28 <xplat> oh, right, when 0 is involved
05:10:08 <xplat> but there's a much easier way to fix that
05:14:34 <quchen> dmwit: Got any further hints? I can't make the function work on both finite and infinite lists. For finite lists splitAt works fine, for infinite lists I basically have to add the bottoms manually right now.
05:15:17 <dmwit> Perhaps something like...
05:15:18 <quchen> My approaches so far kind of tried handling the finite and infinite cases differently, which didn't work very well (figures).
05:15:47 <xplat> quchen: yeah, that literally cannot be done
05:15:55 <quchen> xplat: Yep.
05:16:17 <quchen> xplat: But when I minimalize my past tries it always turned out that that was what I was trying in there somehow ;-)
05:16:26 <dmwit> Well, you can't treat finite and infinite differently. But you can treat finite and less than n and more than n (either finite or infinite) differently with no trouble.
05:16:41 <shachaf> quchen: Don't use splitAt
05:16:44 <shachaf> Use splitAtFromEnd
05:16:47 <shachaf> It uses the same trick as
05:16:51 <shachaf> @where sneaky
05:16:51 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
05:17:23 <shachaf> If you don't want to write splitAtFromEnd, you can make a separate takeFromEnd that uses this trick and use it.
05:17:59 <shirt> what does it mean that readMVar is not atomic?
05:18:26 <dmwit> shirt: readMVar v = do { v <- takeMVar; putMVar v; return v } -- roughly
05:18:27 <shachaf> readMVar is just takeMVar followed by putMVar
05:18:31 <dmwit> but with better exception handling
05:18:39 <dmwit> ugh
05:18:50 <dmwit> readMVar m = do { v <- takeMVar m; putMVar m v; return v } -- I mean
05:18:58 <shachaf> dmwit: Aw, you renamed the MVar.
05:19:09 <dmwit> have to, for putMVar's sake
05:19:10 <shachaf> imo readMVar v = do { v <- takeMVar v; putMVar v v; return v }
05:19:43 <dmwit> takeMVar v >>= liftM2 (>>) (putMVar v) return
05:19:47 <xplat> which means someone could put in a new value and take it back out while you were reading it
05:20:20 <xplat> or put a new value in and block you during the read iirc?
05:21:03 <shachaf> Presumably put in a new value after you take.
05:21:15 <xplat> right
05:21:17 <shachaf> But note that that can never happen if you only use readMVar.
05:21:46 <xplat> right, because they would block on the take part until you put your value back
05:21:59 <xplat> except how would your mvars get full in the first place?
05:24:30 <merijn> You're also safe with modifyMVar, which does take, modify, put
05:24:46 <merijn> xplat: Create them with an initial value?
05:25:17 <xplat> that would work
05:34:25 <quchen> Hmpf. Looky like uncurrying (++) isn't the way to go. http://hpaste.org/86310
05:34:52 <quchen> dmwit: What did you mean earlier with "allocating the cons cells before their values"?
05:35:01 <quchen> I know what it means, but how does it translate to Haskell?
05:35:11 <shachaf> @where sneaky is an example
05:35:11 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
05:35:31 <quchen> shachaf: splitAtFromEn works.
05:35:41 <shachaf> Oh.
05:35:46 <shachaf> Then you solved your problem?
05:36:05 <shachaf> Hmm.
05:36:15 <quchen> No. splitAtFromEnd for an infinite lists gives me a tuple (list, bottom)
05:36:25 <quchen> I then want to put that together a la "bottom ++ list"
05:36:28 <quchen> Which of course crashes
05:36:32 <shachaf> Maybe it doesn't actually solve your problem here...
05:36:39 <shachaf> Or maybe you need a cleverer splitAtFromEnd
05:36:43 <quchen> :P
05:37:30 <shachaf> It ought to be possible.
05:37:39 <shachaf> I mean, you know how to do rotateR by hand.
05:37:45 <shachaf> So it's just a matter of generalizing it.
05:38:18 <quchen> I don't know how to do it by hand so that it works both in the finite an infinite case.
05:38:41 <shachaf> Do you know how to (rotateR 1) by hand?
05:39:02 <quchen> I don't think so
05:39:15 <quchen> Well, I could keep a "hole" open in the beginning
05:39:29 <shachaf> foo xs = last xs : init xs
05:39:50 <quchen> Oh. Well. Now I feel dumb.
05:39:56 <shachaf> If you want you can handle the [] case separately so that you have a "total" function.
05:40:10 <shachaf> Now generalize it to N values.
05:42:00 <shachaf> By the way, note the difference between foo x = x and foo x = (fst x, snd x)
05:42:05 <shachaf> I think that's the sort of thing dmwit meant.
05:42:14 <dmwit> yes
05:42:34 <dmwit> Also, if your splitAtFromEnd gives you (list, bottom) when you hand it an infinite list, you haven't written it the way shachaf is trying to prod you to.
05:43:25 <shachaf> Right.
05:43:29 <quchen> Ah.
05:43:41 <shachaf> You can extract a little bit more laziness.
05:57:14 <tdammers> http://programmers.stackexchange.com/questions/195708/why-does-haskell-have-built-in-if-then-else-instead-of-defining-it-as-a-simple
05:57:23 <tdammers> I think this is actually kind of an interesting question
05:58:21 <merijn> @where+ comonad http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
05:58:22 <lambdabot> Nice!
05:59:00 <merijn> tdammers: Readability and hysterical raisins, I think?
05:59:07 <quchen> tdammers: History, I assume. Can't curry it though.
05:59:34 <merijn> "if b then x else y" is slightly nicer than "if b x y"
05:59:47 <merijn> Especially when b/x/y is non-trivial
06:00:08 <quchen> It makes worrying about indentation at easier if nothing else
06:00:36 <Cale> Also, if it were a function, we'd more often want:
06:00:47 <Cale> bool :: a -> a -> Bool -> a
06:01:00 <quchen> Cale: the "maybe" problem? :-)
06:01:09 <tdammers> yeah, that's mostly what I thought
06:01:19 <tdammers> in practice, if is a tiny bit nicer than when
06:01:52 <tdammers> but indeed, it doesn't curry, and it reserves three keywords
06:02:47 <dmwit> Cale: Why not both? =)
06:02:51 <quchen> Problem is that changing would break _every_ module
06:03:33 <dmwit> cabal install --with-ghc-opts=--hysterical-raisins
06:05:20 <tdammers> so, mainly historical reasons really
06:05:27 <Cale> I've often wanted if and case to be sectionable
06:05:34 <Cale> And now case is, sort of
06:05:40 <Cale> But if isn't.
06:05:45 <dmwit> Yes, there's no real fundamental reason that having if/then/else in the syntax is preferable to having it in the Prelude.
06:06:08 <quchen> Cale: Case is sectionable?
06:06:16 <dmwit> \case
06:06:24 <quchen> Ah, lambda case, okay
06:06:26 <Cale> We could define the syntax (if then x else y) to mean (\fresh -> if fresh then x else y)
06:06:34 <augur> merijn: well if haskell would get on the mixfix bandwagon we wouldnt need built-in if-then-else!
06:07:04 <dmwit> We don't need it even without those drastic measures!
06:07:05 <xplat> what about '(if then else return ())'?
06:07:30 <merijn> augur: I'm all in favour of the mixfix bandwagon!
06:07:41 <quchen> mixfix = ternary operators etc?
06:07:42 <Cale> hah, we could really confuse beginners by introducing (if cond then x) to mean (\fresh -> if cond then x else fresh)
06:07:52 <augur> quchen: mixfix = arbitrary operators
06:08:01 <merijn> quchen: ternary and up
06:08:04 <quchen> augur: I don't see that end well
06:08:22 <dmwit> Agda does it, and I think it works out pretty well.
06:08:31 <merijn> Agda lets you define "if _ then _ else _" as a function of three parameters
06:08:33 <augur> merijn: i wouldnt even say that. its just arbitrary, because it can be circumfix, postfix, etc etc.
06:08:33 <dmwit> Coq sort of does it, too, with less success (in my opinion).
06:08:52 <merijn> mixfix seems amazing for making nice EDSLs
06:08:55 <augur> if_then_else_ : {A : Set} -> Bool -> A -> A -> A
06:09:00 <xplat> well, you don't *have* to allow things like word operators to use mixfix parsing, you could force every fixedpart to have an operator char (or be all operator chars)
06:09:18 <merijn> xplat: That'd ruin the beauty
06:09:20 <augur> xplat: word operators are half the fun
06:09:31 <dmwit> augur: Huh. How would you specify the value of A explicitly in that?
06:09:40 <hiptobecubic> can you partially apply mixfix somehow?
06:09:42 <augur> dmwit: what do you mean?
06:09:55 <augur> hiptobecubic: sure. you leave the _'s in place and it becomes a normal function.
06:09:59 <dmwit> augur: Normally, implicit parameters can be made explicit, I guess.
06:10:06 <xplat> merijn: i'd prefer whole hawg or kosher myself, but as a technical point ...
06:10:06 <quchen> Bra-Ket notation in Haskell? < foo | H | baz >
06:10:07 <quchen> :-)
06:10:15 <augur> dmwit: oh, you have to use it as a prefix function instead.
06:10:20 <dmwit> I see.
06:10:28 <augur> dmwit: if_then_else_ {X} a b c
06:10:34 <JordiGH> I'm looking at the functor type class, and I'm trying to figure out if this really is a functor in the categorical sense or if it's just supposed to be suggestive of a categorical functor. I'm just readying LYAHFGG, so I probably am just uninformed, but... if the signature is (a -> b) -> f a -> f b, it looks to me like unless a is the same as b, the arrows in the source are from a category of two objects, namely, "a" and "b"?
06:10:48 <arkeet> what?
06:11:05 <JordiGH> It also seems to me that whether this is a function or not depends on how fmap is implemented, since, e.g. a functor must map id to id.
06:11:09 <dmwit> JordiGH: fmap is a mapping from arrows (of type (a -> b)) to arrows in the subcategory (of type (f a -> f b)).
06:11:13 <augur> dmwit: usually when that becomes a common enough thing, people will use a special notation. so for instance you have a case expression:
06:11:15 <JordiGH> s/is a function/is a functor/
06:11:26 <dmwit> JordiGH: It is not just suggestive; it really is supposed to model functors from Hask to subcategories of Hask.
06:11:40 <JordiGH> dmwit: Why are arrows of type a -> b a category? That's a category of two objects, right?
06:11:41 <dmwit> Specifically, computable functors.
06:11:42 <xplat> there are various ways you could potentially section mixfix operators, a favorite among agda fans is (if_then x else y) but agda doesn't actually implement that
06:11:48 <arkeet> JordiGH: no, that's not the category.
06:11:55 <dmwit> JordiGH: No, the arrows have type (a -> b); the objects here are "a" and "b".
06:12:08 <JordiGH> dmwit: Right, only two objects, right? It's a very specific category?
06:12:08 <augur> dmwit: case_as_of_ where you do case blarg as B of ...
06:12:13 <dmwit> JordiGH: Specifically: the category has as objects Haskell types, and as arrows Haskell functions.
06:12:14 <arkeet> JordiGH: for *all* a and b
06:12:15 <augur> where B : A -> Set or something like that
06:12:19 <dmwit> JordiGH: No.
06:12:42 <augur> dmwit: so you could do   if_as_then_else_ : Bool -> (A : Set) -> A -> A -> A
06:12:50 <quchen> a and b are arbitrary objects in Hask, aren't they?
06:12:53 <arkeet> yes.
06:12:58 <xplat> JordiGH: a and b are not specific types, they are placeholders for any type you want to put there
06:13:06 <augur> dmwit: then you'd just do   if test as Nat then x else y
06:13:06 <xplat> JordiGH: you can tell because they are lowercase
06:13:13 <quchen> arkeet: Well, not arbitrary, but arbitrary-and-have-an-arrow-between-them :-)
06:13:23 <arkeet> no, arbitrary.
06:13:25 <arkeet> :p
06:13:31 <FireFly> The types of Hask are only "concrete" types, i.e. without any type variables?
06:13:34 <JordiGH> arkeet: But then... what's the functor.. the Functor type class or the concrete types in Functor? It seems that if you want me to think of arbitrary a and b, then the functor is the Functor type class.
06:13:43 <arkeet> ok look.
06:13:48 <dmwit> JordiGH: A functor is two mappings, right?
06:13:49 <quchen> arkeet: Oh, right, nevermin.
06:13:51 <arkeet> there is a category, which we call Hask.
06:13:52 <xplat> JordiGH: the functor is f
06:13:56 <arkeet> its objects are types.
06:13:58 <dmwit> JordiGH: One from objects to objects, and the other from arrows to arrows.
06:14:07 <arkeet> given two types a and b, hom(a,b) is the set of functions a -> b.
06:14:18 <dmwit> JordiGH: When you write "instance Functor Foo where fmap = bar", Foo is the object -> object mapping, and bar is the arrow -> arrow mapping.
06:14:19 <arkeet> now, if you have a type constructor F,
06:14:29 <arkeet> that already gives you a mapping of objects of Hask to objects of Hask.
06:14:36 <arkeet> mapping a to F a
06:14:39 <JordiGH> Okay, show me a specific famous functor I'm familiar with: the Galois functor. How would you write this in Haskell?
06:14:49 <arkeet> stop. listen.
06:14:55 <merijn> btw, I think I asked before, but is there a simple "intro to CT"? This discussion and the "you could have invented comonads" thing really make me think I should read more...
06:14:58 <xplat> (technically it's : the Functor is f.)
06:15:03 <JordiGH> No, you stop and listen. Show me the Galois functor in Haskell. We all know maths, right?
06:15:17 <arkeet> no, because you can't represent arbitrary functors like that.
06:15:20 <arkeet> anyway,
06:15:25 <arkeet> so if F is an instance of Functor,
06:15:25 <ab9rf> oi
06:15:44 <dmwit> JordiGH: (As I said above: Functor only models functors from Hask to subcategories of Hask. In fact it's even more specific than that.)
06:15:46 <xplat> JordiGH: not all mathematical functors are haskell Functors.  but all haskell Functors (if they follow the laws) are mathematical functors
06:15:47 <mr-> JordiGH: The only sort of functors you can have in haskell are Hask -> Hask
06:15:48 <arkeet> then what that gives you is a mapping from hom(a,b) to hom(F a, F b), for any a and b.
06:15:58 <arkeet> i.e. a function (a -> b) -> (F a -> F b)
06:16:06 <quchen> merijn: I like to iterate through books every now and then. If you don't understand something Cale is an awesome help ;-)
06:16:09 <mr-> dmwit: all functors are fully faithful?
06:16:20 <arkeet> mr-: no
06:16:27 <merijn> quchen: Yes, but which books?
06:16:27 <arkeet> but they are injective on objects.
06:16:31 <dmwit> mr-: I'm not 100% sure I know what that means, but I doubt it.
06:16:33 <arkeet> that's it.
06:16:35 <JordiGH> Ah, ok, so it's less abstract than I thought. I can't express the Galois functor in Haskell?
06:16:40 <quchen> merijn: I started reading Awodey the other day
06:16:47 <quchen> It's about CT and has examples (!)
06:16:48 <dmwit> JordiGH: You might be able to. Just not as an instance of Functor.
06:16:55 <arkeet> JordiGH: Functor only describes certain functors from Hask to Hask.
06:16:56 <Cale> JordiGH: The Functor typeclass is just for endofunctors on Hask.
06:16:57 <FireFly> merijn: I've been reading Barr Well's lecture notes about CT recently, which works for me anyway
06:16:59 <arbn> merijn: There's a ##categorytheory. If your background is CS, philosophy, or something like that, Awodey is good.
06:17:16 <JordiGH> Okay, so the category is Hask. I can live with that. I get it.
06:17:21 <FireFly> er
06:17:21 <merijn> arbn: ok, sounds like as good a point as any to start then
06:17:29 <FireFly> Actually, Barr & Wells' apparently
06:17:45 <arkeet> and you also can't get any functor like that, because you can only write Functor instances for type constructors.
06:17:45 <quchen> merijn: It even has somewhat practical examples (Lambda calculus for one)
06:17:53 <arkeet> not arbitrary type funtcions.
06:18:22 <arkeet> so e.g. you don't get the identity functor.
06:18:45 <arkeet> (although you can write an Identity type constructor and give it a Functor instance, such that the result is naturally isomorphic to the identity.)
06:18:55 <yitz> how am i supposed to figure out what it means when cabal configure says: Found cycle in intrapackage dependency graph: 'library' depends on 'library'
06:18:55 <xplat> you do get a functor naturally isomorphic to the identity func...ninja'd
06:19:44 <dmwit> yitz: It sounds like that means a single package's library depends on itself.
06:20:00 <dmwit> yitz: Perhaps you could open up that package's cabal file and take a peek yourself.
06:20:06 <dmwit> yitz: (Which package is it?)
06:20:38 <yitz> dmwit: these exact package versions already built once. and there are 65 dependencies - how do i find out where to look?
06:20:51 <yitz> dmwit: it's an internal proprietary package
06:21:19 <dmwit> You look for the dependency whose name matches the package you're trying to build, no?
06:21:49 <yitz> dmwit: i built it once with fluid dep versions in cabal-dev, got a list of the exact versions that it used, then replaced all the deps with those exact versions in the cabal file. why shouldn't it build now?
06:22:21 <dmwit> Perhaps this package builds both an executable and a library, and you accidentally union'd their dependencies.
06:22:31 <yitz> dmwit: ahhh maybe you're right. when i copied in all those deps, i may have accidentally included itself. lemme look. thanks a million!
06:23:31 <yitz> dmwit++
06:23:35 <dmwit> =)
06:24:18 <augur> dmwit--
06:24:23 <dmwit> =(
06:24:28 <augur> no, it's good, dmwit!
06:24:36 <augur> dmwit-- : dmwit++ :: c-- : c++
06:24:56 <quchen> This "++" business is blasphemy in this chanel anyway.
06:25:03 <dmwit> Ah, it feels good to be feature-free and obviously correct!
06:25:06 <quchen> You should both be whipped with a lambda or something.
06:25:16 <augur> (dmwit++)
06:25:30 <quchen> dmwit: Please rejoin to accept the state change
06:25:55 <Mortchek> let dmwit = succ dmwit
06:26:02 <Mortchek> I've just shadowed them with an imposter!
06:26:20 * dmwit <<loop>>
06:26:36 <Mortchek> Oh right, my brain was in OCaml mode.
06:26:55 <ketil> This is your brain. This is your brain on OCaml.
06:27:05 <ab9rf> quchen: really, mutable values in a haskell channel?
06:27:13 <quchen> ab9rf: Right?
06:27:20 <arbn> @karma dmwit
06:27:21 <lambdabot> dmwit has a karma of 44
06:27:31 <FireFly> @karma (dmwit
06:27:31 <lambdabot> (dmwit has a karma of 0
06:27:46 <Bor0> @karma
06:27:46 <lambdabot> You have a karma of 0
06:28:03 <Bor0> @karma lambdabot
06:28:04 <lambdabot> lambdabot has a karma of 25
06:28:14 <quchen> @karma notepad
06:28:15 <lambdabot> notepad has a karma of 42
06:28:25 <arkeet> @karma C
06:28:25 <lambdabot> C has a karma of 1
06:28:49 <quchen> @karma Java
06:28:49 <mr-> arbn: Ah, it is injective on objects, because it always is f a, even though f a might be constant (in a)
06:28:49 <lambdabot> Java has a karma of -2
06:28:51 <quchen> :D
06:29:00 <mr-> arkeet: Ah, it is injective on objects, because it always is f a, even though f a might be constant (in a)
06:29:19 <arkeet> I don't know what you mean by constant, but yes it is.
06:29:33 <arkeet> f a ~ g b implies f ~ g and a ~ b.
06:30:02 <mr-> arkeet: constant in the sense of data F a = Bool ;-)
06:30:02 <dmwit> I think he means f a may have all the same values as f b even when a /~ b.
06:30:05 <dmwit> For sneaky f.
06:30:18 <arkeet> it would be nice to have injective type families.
06:30:26 <dmwit> indeed
06:30:42 <dmwit> Well, there's data families. It's not quite the same, I know.
06:30:43 <quicksilver> they're called data families?
06:30:55 <arkeet> quicksilver: that's not quite the same. :p
06:31:03 <dmwit> (You don't get to reuse existing types with data families.)
06:31:07 <ab9rf> i'm not even going to try to figure out what a coburrito is
06:31:10 <quicksilver> injective-by-construction is the best you can do with the way constraints are handled.
06:31:30 <quchen> ab9rf: You take the meat out before you put it in a new bread thing
06:31:30 <quicksilver> to try to handle a more primitive injection is the same kind of problem as tracking for overlapping instances
06:31:51 <quicksilver> it's not composable
06:32:30 <ab9rf> injectable burritos
06:33:18 <quchen> ab9rf: No, not injectable. You can always eat the contents. When you want to handle the contents, you first have to mash the entire burrito.
06:33:19 <Taneb> It's a bit sad that Haskell on a Horse seems to have disappeared
06:33:21 <quchen> It really is a mess.
06:33:27 <Taneb> It must have rode off into the sunset
06:34:03 <dmwit> I don't buy it.
06:34:49 <coburrito> ab9rf: Yeah. The best explanation I have is that you just invert the position of the tortilla and the fillings to create a coburrito. If you succeed in making one in your own kitchen, I'd love a picture.
06:34:49 <dmwit> quicksilver: We already track whether something can be instantiated as a type constructor or not. It shouldn't be notionally harder to allow those things to be instantiated as injective type families.
06:35:05 <dmwit> Or are you saying that checking injectivity is the hard part?
06:35:11 <dmwit> Yeah, that must be what you're saying.
06:35:23 <arkeet> it shouldn't be any harder than functional dependencies.
06:36:04 <dmwit> arkeet: I'm not sure I buy that, either. Have you tried expressing injectivity as a fundep? =)
06:36:14 <arkeet> no
06:36:15 <arkeet> =)
06:38:10 <fubaz> hi, i'm trying to familiarize myself with typefamilies and made a little example trying to utilize them. i however encounter strange behaviour in ghci and would much appreciate if someone could explain it to me :)
06:38:14 <fubaz> http://hpaste.org/86315
06:38:52 <quicksilver> dmwit: I'm saying that you can have two modules which, compiled separately, don't violate the injectivity condition
06:39:01 <quicksilver> dmwit: but put into the same program would.
06:39:26 <arkeet> fubaz: type families and polymorphism don't get along very well.
06:39:30 <quicksilver> at a "trivial" level that violates separate compilation but at a more interesting/semantic level that breaks a kind of composability.
06:39:34 <dmwit> fubaz: I'm actually a bit surprised that unwrap typechecks at all.
06:39:53 <arkeet> unwrap is fine.
06:40:12 <dmwit> um
06:40:15 <dmwit> quite, and I can't read
06:41:20 <dmwit> quicksilver: Sure. But we never really had any pretensions to composability in that sense, right? As you said, overlapping instances have the same "problem".
06:41:31 <arkeet> I think the reason unwrap foo works is because foo is defaulted to Holder Integer Integer by the monomorphism restriction.
06:41:51 <quicksilver> dmwit: I consider overlapping instances entirely broken, so in my world we do have that kind of composability.
06:42:00 <quicksilver> dmwit: your possible world may vary
06:42:19 <dmwit> quicksilver: Wait, so you reject the open world assumption? Do you just not use type classes at all, then?
06:42:23 * dmwit finds this hard to believe
06:42:34 <quicksilver> no, I'm entirely happy with the open world assumption
06:42:40 <dmwit> Then I'm confused.
06:42:41 <quicksilver> I just don't use -XOverlappingInstances
06:42:45 <dmwit> Oh, of course.
06:42:48 <quicksilver> which is the thing which makes it break
06:43:02 <dmwit> I'm saying that you already have the problem that two perfectly fine, compiling modules won't work together.
06:43:09 <dmwit> Even without -XOverlappingInstances.
06:43:12 <arkeet> fubaz: so the thing is that wrap 1 has type (Num m, Wrapping m) => Holder m m
06:43:55 <arkeet> fubaz: when you pass it to unwrap I, it unifies Holder m m with Maybe Integer, so that m = Integer (and Holder m = Maybe)
06:43:58 <arkeet> er, unwrapI
06:44:07 <arkeet> but it can't do that in unwrap (wrap 1)
06:44:17 <fubaz> arkeet, ah
06:44:17 <czro_> Hello. Thinking about laziness... is list mapping over a list that is itself built by concatenating lists O(n) if the function mapped is O(1)?
06:44:18 <fubaz> hmm
06:44:19 <arkeet> if you fix the type to 1 :: Integer, then it works.
06:44:23 <merijn> fubaz: eh... "wrap :: m -> Holder m m" <- this looks wrong
06:44:34 <merijn> Shouldn't the first and last m be something other than m?
06:44:50 <merijn> oh, no
06:44:52 <merijn> I'm silly
06:44:57 <fubaz> merijn, sorry, i'm very new to typefamilies and just tried to do "simplest example that works"
06:45:15 <dmwit> fubaz: You made it unsimple by using number literals, that's all. =)
06:45:18 <danr> what does unwrapI and unwrap have to do with the Wrapping class here?
06:45:22 <merijn> fubaz: No, I just misread what you were doing
06:45:23 <arkeet> nothing.
06:45:23 <fubaz> dmwit, :D
06:45:43 <fubaz> they're just for demonstrational purposes
06:45:54 <quchen> czro_: I don't understand the question. Could you paste the code you're referring to?
06:45:57 <merijn> fubaz: Pro-tip, use Char/Bool/() for simple example to avoid stupid mistakes due to polymorphic literals :)
06:46:05 <quicksilver> dmwit: yes it's a fair point. Not quite sure what I'm trying to say.
06:46:16 <fubaz> merijn, thanks for the pro tip :D
06:46:32 <fubaz> arkeet, thanks a lot for the explanation :)
06:46:45 <fubaz> and thanks fly out to dmwit also ;)
06:46:52 <merijn> fubaz: Since those are fixed you never run into problems like here where the it can't select which polymorphic type you used :)
06:46:52 <czro_> quchen: map (+1) ([1,2,3] ++ [4,5,6])
06:46:57 <arkeet> fubaz: with NoMonomorphismRestriction, unwrap foo also wouldn't work.
06:47:15 <merijn> czro_: The ++ is O(1) in that scenario, yes.
06:47:26 <czro_> quchen: Excellent. Thanks.
06:47:35 <dmwit> merijn++
06:47:38 <dmwit> arkeet++
06:47:50 <merijn> czro_: The map is still O(n), but you only traverse the entire list once. You don't first iterate to the end for ++ and then do it again for map
06:47:57 <quchen> czro_: the "map (+1)" is O(n). In your case, n = 6, so the whole thing is O(6) = O(1).
06:47:59 <fubaz> merijn, that was actually new to me, so thanks! i'll be careful about that
06:48:11 <quchen> merijn: You ninja!
06:48:24 <merijn> fubaz: I know from experience, I keep making that myself all the time :p
06:48:29 <merijn> +mistake
06:48:54 <fubaz> arkeet, i see. hm, now i understand better :)
06:48:59 <merijn> dmwit: I have mystic "underlying question divining" skills :p
06:49:01 <fubaz> merijn, haha :D
06:49:23 <czro_> quchen: Yes. The example was simplified but as I understand it from your first answer it doesn't concat the list first (O(length of list)).
06:49:26 <dmwit> czro_: The question you should be thinking about is "How much more does the map cost than not doing the map?". The answer to that question is that it doesn't matter how the input is built; you pay 1 for each cons cell you look at and O(f(n)) for each element you look at, where f(n) is what you pay to run the function you handed map.
06:49:34 <fubaz> thanks a lot everyone! i've been scratching my head for a while because of this :D
06:50:05 <fubaz> because typefamilies are new i assumed it was something directly related to them
06:50:10 <fubaz> new to me, even
06:50:16 <merijn> czro_: The GHC manual has a list of "well-behaved" list producers/consumers, combining any of these let GHC fuse the traversals into one single loop over the list
06:50:48 <merijn> fubaz: If you wanna play with type families, make sure you update to 7.7 so you get "type instance where" \o/
06:50:49 <quchen> czro_: (++) is lazy, so "map f ([1,2] ++ [3]) = map f (1 : [2] ++ [3] = f 1 : map f ([2] ++ [3]) = ..."
06:50:59 <quchen> The whole thing consumes the list once only.
06:50:59 <merijn> fubaz: Also, I think type families have existed since 6.12 or so? :p
06:51:24 <fubaz> merjn, *cough* :D
06:52:07 <fubaz> merijn, gotta update then :)
06:52:43 <merijn> fubaz: Which means you can write
06:53:01 <quchen> merijn: Isn't this case independent of the "well-behaved producer" scenario? I thought that was referring to things that fuse well. Fusion may be applied here, but even without it it will only traverse the list once, no?
06:53:03 <hpaste> merijn pasted “TypeFamily with easy type equality \o/” at http://hpaste.org/86317
06:53:21 <eikke> is there any nicer way to write this Conduit thing: https://gist.github.com/NicolasT/5d812a89abef868992c2
06:53:50 <dmwit> Indeed, fusion doesn't really change asymptotic behavior.
06:54:02 <fubaz> merijn, cool! :)
06:54:33 <czro_> dmwit: Thinking out loud. The running time will be O(n) where n is the lenght of the concatenated lists since (+) has to be applied to every cell in the list. In the case stat n is constant = O(1).
06:55:20 <dmwit> Running time in a lazy language depends on your consumer. Any statement that doesn't take a consumer into account is likely wrong.
06:55:56 <dmwit> Or perhaps I missed the context where (+) was used, and that statement *is* considering the consumer.
06:56:04 <dmwit> In which case I apologize.
06:56:27 <fubaz> merijn, thanks for the example :)
06:56:47 <czro_> dmwit: phone..brb
06:58:38 <merijn> Wasn't the a command for evaluating typefamily applications in ghci?
06:59:01 <dmwit> :k!
06:59:04 <merijn> fubaz: Basically the where lets you specify the definitions should be evaluated in lexical order, just like normal function
06:59:18 <merijn> dmwit: I get "unknown command" :(
06:59:54 <dmwit> Perhaps your ghci is too old.
06:59:58 <dmwit> You might also try :kind!
07:00:04 <dmwit> which I think worked before :k! did.
07:00:11 <merijn> dmwit: 7.7...
07:00:20 <dmwit> Perhaps your ghci is too new. =)
07:00:28 <dmwit> (file a bug)
07:00:51 <merijn> dmwit: :kind! works
07:01:09 <merijn> Where do I file it? :>
07:01:32 <dmwit> ?google GHC trac
07:01:34 <lambdabot> http://hackage.haskell.org/trac/ghc/
07:01:34 <lambdabot> Title: GHC
07:01:42 <czro_> dmwit: I just cooked that example up and threw in the plus. Thanks for the help, no need to apologise.
07:02:45 <fubaz> merijn, yeah, noticed :) looks very intuitive
07:06:04 <onion> Hello, everyone. Haskell noobie here.
07:06:19 <Botje> Welcome!
07:06:39 <onion> You probably got this question these last few days.
07:06:55 <onion> So, I have this homework assignment.
07:07:08 <ab9rf> heh
07:07:11 <onion> And we have to implement a regex parser in Haskell.
07:07:18 <ab9rf> my condolences :)
07:07:32 <Botje> oh right, the particule simulator one was done. Wonder how that turned out.
07:07:58 * coburrito is still dying to know where all these students are lucky enough to be given Haskell homework.
07:07:58 <onion> And I managed to do something that transforms a string like "(a|b)+" into something like MoreThan1 (Grouped (Sequence (Letter 'a') (Alternate (Letter 'c') (Letter 'b')))).
07:08:09 * hackagebot data-checked 0.2 - Type-indexed runtime-checked properties  http://hackage.haskell.org/package/data-checked-0.2 (MikhailVorozhtsov)
07:08:29 <Botje> onion: well, that'd be (a(b|c))+, but okay.
07:08:30 <onion> We are not that lucky. :)
07:08:45 <onion> Oh yeah.
07:08:52 <onion> Sorry, copied the wrong text.
07:09:09 <onion> Now, I am stuck on how to go further from here.
07:09:31 <Botje> start with simpler cases and work your way up
07:09:35 <merijn> dmwit: :k! doesn't work in 7.4 either, are you sure that's even supposed to exist before I file it as bug? :p
07:09:38 <onion> And apply what I have on a normal string like "abab" or something.
07:10:31 <Botje> onion: do you know about the Maybe datatype?
07:10:44 <merijn> onion: Well, have you got the simple case working? i.e. matching just a simple fixed sequence?
07:11:30 <onion> I heard about it, but did not use until now. We've only started learning Haskell three weeks ago.
07:12:20 <onion> merjin, no, I didn't. I just don't know how to start and need a hint.
07:12:45 <Botje> onion: I'd start with a match :: Regexp -> String -> Just (String, String)
07:12:47 <Botje> err
07:12:50 <Botje> s/Just/Maybe
07:13:02 <Botje> where you return Nothing if the Regexp didn't match, and Just (matched, rest) if it did
07:13:16 <Botje> where matched = the string you matched, rest = everything after it
07:13:30 <Botje> do you need to implement capturing as well?
07:13:33 <ab9rf> i'd probably have a Match type
07:13:38 <ab9rf> if i had to do captures
07:13:40 <Botje> otherwise it can just be Just rest
07:13:51 <mr-> Botje: does that work well with MoreThan1 ? Wouldn't you need a list of those, or soemthing?
07:14:22 <ab9rf> and do match :: Regexp -> String -> Maybe Match
07:14:38 <Botje> mr-: probably. but can you remember the last time you got a (...)+ right on the first time? :)
07:14:50 <Botje> you can just append the matching substrings, i'd think
07:14:55 <ab9rf> actually Regexp a -> [a] -> Maybe Match a
07:15:03 <ab9rf> no rason why it has to be limited to String
07:15:19 <onion> No, they are strings. :)
07:15:44 <onion> Well, ok, let's say I have a simple case.
07:15:47 <ab9rf> probably hav to constrain that to Eq a
07:16:42 <merijn> ab9rf: I'm assuming for now he just has to work on Strings
07:16:48 <onion> Like say I have "ab?" on the string "ab".
07:17:02 <onion> What I curreny have returns Sequence (Letter 'a') (Optional (Letter 'b')) for "ab?"
07:17:04 <merijn> onion: Well, the most simple case would be like matching "Letter 'a'" with a string, right?
07:17:14 <onion> Or that, yeah. :d
07:18:00 <merijn> "match (Letter x) (c:cs) | x == c = Just ([c], cs) | otherwise = Nothing"
07:18:10 * hackagebot text-latin1 0.2 - Latin-1 (including ASCII) utility functions  http://hackage.haskell.org/package/text-latin1-0.2 (MikhailVorozhtsov)
07:18:18 <merijn> i.e. if a letter matches the first character in a string, then that's fine
07:18:49 <onion> Hmm, that makes sense. :)
07:19:03 <merijn> onion: Now, what you want to do in case of, for example, "a|b" (I guess that's Alternate (Letter 'a') (Letter 'b')?)
07:19:31 <merijn> Is, first match the first option, then if that returns Nothing (i.e. it didn't match) try the second option
07:20:07 <merijn> onion: Similarly, for things like Many you want to basically, keep trying to do them until you get Nothing, which means the previous one was that last thing that matched
07:20:37 <onion> Oh, I think I understand how to go further from here. :D
07:20:46 <onion> Thank you so much.
07:21:22 <merijn> i.e. "match (Sequence (Letter 'a') (Letter 'b') cs = match (Letter 'a') cs, then use the second result of the "Maybe (String, String)" to try and match the Letter 'b' bit
07:21:28 <merijn> Good luck!
07:21:34 <onion> If I have any more questions I'll be sure to bother you later. Thank you. :)
07:23:10 * hackagebot text-printer 0.3 - Abstract interface for text builders/printers.  http://hackage.haskell.org/package/text-printer-0.3 (MikhailVorozhtsov)
07:28:11 * hackagebot data-textual 0.1 - Human-friendly textual representations.  http://hackage.haskell.org/package/data-textual-0.1 (MikhailVorozhtsov)
07:38:11 * hackagebot network-ip 0.0.1 - Internet Protocol data structures  http://hackage.haskell.org/package/network-ip-0.0.1 (MikhailVorozhtsov)
07:55:51 <quchen> How do things like pipes solve the streaming problem? The concept of reading when needed sounds like laziness but different.
07:56:17 <quchen> Am I misunderstanding the streaming problem? Right now, I'm thinking it's about memory usage and issues like closing a handle too early.
07:57:21 <quchen> I just read through the pipes tutorial and it's beautiful and everything, but it seems like a generalization of what we currently have, so there's got to be a catch I'm missing somewhere
07:58:10 <quchen> (Well, IO can't send stuff back upstream while proxies can, but let's focus on the classical pipes lib for now)
07:58:43 <merijn> quchen: Deterministic memory/resource usage and handling IO errors seem to be the selling points of pipes/conduits/iteratees
07:59:18 <quchen> merijn: So it's not really something else, it's just a better implementation of lazy IO?
08:00:00 <quchen> Such as "read data is properly chunked so memory is more predictable" etc?
08:05:14 <merijn> quchen: Pretty much
08:06:09 <rodlogic> \join
08:09:08 <romain1> Quick question regarding packages dependency : I am considering modifying the @hackage Crypto package, as the Word128 implements only a part of the Integral type class. The @hackage largeword module implements it completly. Would you recommend me to use the largeword module, or to simply copy the relevant files in the crypto modules? Thx
08:21:30 <czro_> What is the recommended way to map a simple algebraic datatype to a c enum?
08:24:40 <skuggi> czro_: if all constructors are nullary you can derive Enum
08:25:24 <czro_> skuggi: Just found Enum in the docs.  Looks like what I'm after. Thanks.
08:28:11 <merijn> You can derive Enum with non-nullary constructors too...
08:31:44 <fizbin> Ah the built-in derivation rules explicitly spelled out in code somewhere in recent ghc versions?
08:32:08 <fizbin> Have they been rewritten to work underneath in terms of GHC.Generics?
08:32:30 <fizbin> That "Ah" was supposed to be "Are"
08:32:58 <Taneb> fizbin: I think they're in the Haskell specification
08:33:18 <Taneb> http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18200011
08:34:57 <fizbin> merijn: Explain "You can derive Enum with non-nullary constructors too…" - you can certainly define an Enum instance with non-nullary constructors, but the spec. says that deriving an instance is possible only with nullary constructors.
08:37:07 <merijn> oh? I remember trying it with non-nullary and it working?
08:37:54 <Eduard_Munteanu> Not sure how "succ Nothing" is going to work...
08:38:12 * hackagebot data-store 0.3.0 - Type safe, in-memory dictionary with multidimensional keys.  http://hackage.haskell.org/package/data-store-0.3.0 (PetrPilar)
08:38:33 <Eduard_Munteanu> Hm, wait, maybe for stuff that also has Enum instances.
08:38:38 <Taneb> "Derived instance declarations for the class Enum are only possible for enumerations (data types with only nullary constructors)."
08:38:50 <Taneb> Haskell 2010 specs 11.2
08:39:00 <simpson> And Haskell 98 had the same language.
08:39:01 <Eduard_Munteanu> (though you'd need Bounded too I guess?)
08:47:17 <axion_> Huuuuuuuuge props on HN today boys! PARTAY!!!!!!!!!!!!!!!!!
08:48:14 <johnw> axion_: to what are you referring?
08:48:21 <axion_> https://news.ycombinator.com/item?id=5587268
08:48:29 <axion_> Everyone loves #haskell
08:49:16 <Palmik> Hi. Does anyone know how I could benchmark inserts into various data structures where the data structures which are basically lists of Data.Map.Map, but the data structure themselves are not necessarily strict enough that using whnf would suffice to force the spines of the underlying maps.
08:50:23 <Ankhers> Does Haskell have anything similar to Lisp's car and cdr functions when working with lists? I know about head and tail, I'm looking more for something like caadar without having to do the !! syntax
08:50:56 <Eduard_Munteanu> Ankhers: what does that do?
08:51:03 <armlesshobo> Ankhers, head and tail
08:51:10 <ion> ankhers: Use pattern matching instead of head and tail.
08:51:18 <tromp_> haskellers try to avoid head & tail and prefer pattern matching
08:51:26 <johnw> Ankhers: head . tail . tail
08:51:39 <johnw> but yeah, caadar would have the same problem of partiality
08:51:45 <johnw> caadr
08:51:46 <ion> So does head . tail . tail
08:51:54 <johnw> yes
08:52:04 <ion> With pattern matching, you at least get a warning when you forget a case.
08:52:17 <johnw> I think the answer is "don't do it that way in Haskell, use pattern matching"
08:52:38 <quicksilver> also, don't store stuff in deeply nested untagged lists
08:52:43 <quicksilver> although that's quite common in lisp
08:52:44 <Ankhers> Pattern matching does make more sense actually.. Thanks everyone. I am still trying to get used to Haskell.
08:52:48 <quicksilver> instaed, use named datatypes
08:53:01 <quicksilver> and useful combinators to get/calculate/transform your named types
08:53:14 <tac> head and tail are both lies. You cannot go wrong in pattern matching
08:53:45 <Ankhers> Is there a conceivable time were I would want to use head/tail or even the !! syntax over anything else
08:53:46 <Ankhers> ?
08:53:54 <johnw> almost never
08:54:07 <Ankhers> Awesome, thanks. I will try and keep this in mind.
08:54:12 <johnw> there are times when you can absolutely know that lists won't be empty
08:54:12 <Eduard_Munteanu> Avoid head and (!!).
08:54:22 <johnw> and in those cases, using head with a map or filter can be more convenient
08:54:26 <johnw> but consider that "advanced usage"
08:54:58 <Shou> Hi #haskell, in Attoparsec, is there a way to match against something and then rewind back to before the match? Like a lookahead.
08:55:02 <johnw> as my co-worker points out, even if YOU know that head must work, you can't stop others from changing your code such that that assertion no longer holds true
08:55:23 <johnw> Shou: try?
08:56:02 <Shou> johnw: That's supposed to do that? Because it doesn't seem like it does, or maybe I'm doing something wrong ;_;
08:56:20 <johnw> maybe try does consume if it succeeds
08:56:23 <johnw> one sec, let me check the docs
08:56:56 <Shou> yeah I think on success it consumes it
08:57:31 <johnw> well, you could always terminate your try with something that can never succeed
08:57:48 <johnw> try (myParser *> impossibleParse)
08:58:47 <supki> try is id in attoparsec
09:02:03 <Shou> It needs to match because it's in a manyTill
09:13:26 <cschneid> I'm trying to do a bitwise hamming distance ( "00" -> "01" == 1 bit difference).  I have two Word8s. I xor the two together, then count the number of 1s. What's the easiest way to do that last part (counting the set bits).
09:14:18 <cschneid> testBit does one at a time, which I could certainly use I guess.
09:14:29 <Eduard_Munteanu> cschneid: shift and AND with 1, or use a lookup table, there are many ways (some more efficient, some not)
09:15:19 <Eduard_Munteanu> cschneid: you probably want to look up "population count" for a reference
09:15:36 <luite> yeah. Data.Bits.popCount
09:15:40 <cschneid> ahh, nice
09:15:47 <cschneid> non-obvious name, skimmed right by that
09:16:00 <Eduard_Munteanu> Ah, I didn't know that one.
09:16:17 <cschneid> thanks guys :)
09:22:53 <kate_r> hi
09:23:00 <kate_r> in logic, what is the "head" of an expression?
09:23:59 <arbn> kate_r: Hmm? I'm not sure what you mean.
09:24:30 <aCube> > head [1,2,3] -- ?
09:24:31 <danr> kate_r: where are you reading this? maybe you are thinking of the root?
09:24:32 <lambdabot>   1
09:24:32 <lambdabot> aCube: You have 1 new message. '/msg lambdabot @messages' to read it.
09:24:53 <kate_r> i'm looking up higher order unification
09:25:02 <danr> and what do you mean by logic? in FOL, the expressions are usually called terms and formulae
09:26:48 <Ankhers> #yesod
09:26:51 <Ankhers> sigh...
09:27:25 <Ankhers> sorry... apparently missed my key combination...
09:32:47 <ky3> > 1+2
09:32:49 <lambdabot>   3
09:33:50 <ky3> > 1+2 -- ?
09:33:52 <lambdabot>   3
09:34:14 <ramses_> ky3: looks correct to me :)
09:34:44 <monochrom> Ankhers: see my http://www.vex.net/~trebla/haskell/crossroad.xhtml on head and tail
09:35:29 <ky3> ramses_: i thought it was a new feature that sends results only to questioner
09:36:11 <ramses_> ky3: you can message lambdabot to have a private conversation if that's what you're after
09:38:53 <MEMMYBOY89> http://russianteenmoviedownload.blogspot.com/2013/04/russian-schoolgirls-anal-lessons.html
09:39:47 <ky3> ramses_: do you know the syntax for privately messaging lambdabot? /msg lambdabot 1+2 does nothing
09:40:09 <ramses_> ky3: it has probably opened a new window/tab/...
09:40:48 <ramses_> ky3: it acts like a new channel in my client
09:41:23 <ky3> ramses_: oh you're right, subtle!
09:43:14 * hackagebot data-store 0.3.0.1 - Type safe, in-memory dictionary with multidimensional keys.  http://hackage.haskell.org/package/data-store-0.3.0.1 (PetrPilar)
09:43:17 <cschneid> I have a handful of files in my project now, what build system is common in haskell land? Classic makefiles? something fancier?
09:44:32 <ramses_> cschneid: cabal
09:44:53 <cschneid> ramses_: for personal projects too? Not just libraries?
09:45:05 <ramses_> sure :)
09:45:32 <cschneid> tl;dr - I want to hit a key combo in vim, and have my project build.  right now that's manually calling into ghc with all my files, which is a pain to update for each new file
09:45:42 <cschneid> cabal build or equivalent does that magically?
09:45:53 <monochrom> the cabal user guide is at http://www.haskell.org/cabal/users-guide/
09:47:38 <ramses_> cschneid: yes, it can, you just have to provide a cabal file with the needed info about your project
09:47:52 <cschneid> cool, I'll look at that later
09:48:43 <cschneid> assuming only ascii strings: is there a way to get a list of [Word8]s out? Gymnastics with bytestring don't seem to play quite right
09:49:48 <wting> Is there a pointfree bot in here?
09:50:46 <wting> @pl \xs n -> take n xs
09:50:46 <lambdabot> flip take
09:50:47 <bos> @pl \a b -> a + b
09:50:48 <lambdabot> (+)
09:51:23 <wting> @pl \n -> sum . takeWhile (<n) . filter odd . map (^2) $ [1..]
09:51:23 <lambdabot> flip (sum .) [1..] . (. (filter odd . map (^ 2))) . takeWhile . flip (<)
09:52:14 <wting> Hmm, not sure if the pointfree style is more readable in that case. :p
09:52:25 <monochrom> cschneid: do you mean String -> [Word8]? map ((fromIntegral :: Int -> Word8) . ord)
09:53:15 <cschneid> what's `ord` do.
09:53:16 <cschneid> :t ord
09:53:18 <lambdabot> Char -> Int
09:53:35 <monochrom> for example ord 'A' = 65
09:53:50 <cschneid> and then the fromIntegral turns it into the word8
09:54:06 <monochrom> ord is in Data.Char
09:54:08 <cschneid> is fromIntegral one of those massively overloaded functions for lots of types?
09:54:13 <monochrom> yes!
09:54:17 <monochrom> @type fromIntegral
09:54:19 <lambdabot> (Integral a, Num b) => a -> b
09:54:26 <cschneid> cool
09:54:33 <monochrom> @quote monochrom fromIntegral
09:54:33 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
09:55:24 <h4199> ord 'A' - ord '0'
09:55:46 <cschneid> cool.  I need to start taking notes of some of these globally useful coercion functions.
09:56:23 <Iceland_jack> cschneid: (they're not coercion functions)
09:56:55 <cschneid> well. sorta. I have data, and want it to be the same value, but in a different type. 2 -> 2.0.  Is there a better name for it?
09:58:34 <h4199> ah, ord uses the exact same coercion pattern as C for alphanumerics,
09:58:41 <h4199> good to know
09:59:07 <hiptobecubic> h4199, you mean ascii?
10:00:52 <h4199> well, ord 'A' - ord '0', == 17, ord '4' - ord '0' == 4, same pattern as C
10:01:23 <hiptobecubic> h4199, https://en.wikipedia.org/wiki/Ascii_table
10:02:30 <Iceland_jack> I wouldn't agree that 'A' and 65 are the same ‘value’ in a different type, what if you used a different character encoding where 'A' maps to 15: are 65 and 15 then the same value as well?
10:03:46 <h4199> I meant equal only in the sense that it follows the chart that hip linked, which I had never noticed
10:03:52 <cschneid> Iceland_jack: sure, I get what you're saying. but fromIntegral is something I need to go figure out :)
10:07:58 <thorguy> What IRC channels does everyone find interesting?
10:08:05 <ion> #haskell
10:09:00 <ab9rf> there are other channels?
10:09:24 <mr-> ab9rf: yeah, there's #haskell-blah
10:10:58 <Rarrikins> ##math is nice.
10:11:17 <ab9rf> math makes my head hurt
10:12:02 <dolio> I don't know if 'nice' is the right word for ##math.
10:13:25 <wting> @pl \n -> div n 2
10:13:26 <lambdabot> flip div 2
10:22:45 <beaky> hello
10:22:57 <beaky> what is the monomorphism restriction?
10:23:20 <Clint> beaky: http://www.haskell.org/haskellwiki/Monomorphism_restriction
10:23:31 <geekosaur> ...a pain in the ***
10:23:33 <geekosaur> mostly
10:23:40 <tac> beaky: If you don't specify a top-level type, it doesn't give you the "most general type" possible
10:23:52 <tac> It's considered to be a bad design decision (by most people) in the original haskell spec
10:25:03 <elliott> note: this only applies to definitions with no arguments
10:25:39 <ab9rf> ah, i get it
10:26:03 <beaky> ah
10:26:31 <beaky> so if I have something like a polymorphic constant, haskell just decides that it's not polymorpic?
10:27:11 <beaky> e.g. typing out 3, I'd expect it to be Num a => a, but it becomes Int
10:29:29 <hseg> This guy, Ian Bloom, asked for help on the Cafe yesterday: http://www.mail-archive.com/haskell-cafe@haskell.org/msg105476.html While his app seems to be just <*> for State's Applicative instance, I don't think his lam is definable in terms of some general combinator. Before I tell him this, can someone please verify this?
10:29:29 <lambdabot> hseg: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:30:36 <beaky> is it possible to make list comprehension work on any monad, or ++ to work for any monoid?
10:30:51 <tromp_> :t mappend
10:30:53 <lambdabot> Monoid a => a -> a -> a
10:31:08 <beaky> :t (++)
10:31:10 <lambdabot> Monoid m => m -> m -> m
10:31:13 <beaky> hah
10:31:19 <quchen> That's a Lambdabot thing.
10:31:25 <quchen> <> = mappend is the usual way.
10:31:48 <beaky> I like how lamdabot makes the basic operators like (.) and (++) more general
10:31:58 <quchen> List comprehensions for any monad can be done using the MonadComprehension extension.
10:32:18 <quchen> (.) is not special here.
10:32:36 <tromp_> :t (.)
10:32:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:33:21 <hseg> I'd like to answer Ian Bloom, but I'm unsure whether my assertion that app :: (s -> (s,a->b)) -> (s -> (s,a)) -> (s -> (s,b)) is the same as State's Applicative instance's <*> is true.
10:33:32 <beaky> hmm I remember it meaning Functor f => (a -> b) -> f a -> f b
10:33:53 <quchen> Well that would be awful.
10:34:05 <hseg> Also, I'm unsure whether my assertion that lam :: (State g a -> State g b) -> State g (a -> b)  isn't definable in terms of general combinators is true.
10:34:05 <quchen> (+1) . [1,2,3]
10:34:07 <quchen> 8)
10:34:17 <beaky> > (+1) . [1..100]
10:34:18 <lambdabot>   Couldn't match expected type `a0 -> c0' with actual type `[t0]'
10:34:22 <beaky> :(
10:36:40 <quchen> hseg: ap looks good to me. The explcit definition would be "mf <*> mx = state $ \s -> let (sf, xf) = runState mf s; (sx, xx) = runState mx sf in (sx, xf xx)" I think.
10:39:31 <quchen> And that kind of does what you said above. Run state on first Applicative, run on second argument, combine results.
10:40:26 <quchen> I'm not sure why the first one (mf) has to be run first, but it's surely in the Applicative laws somewhere :-)
10:40:47 <monochrom> actually, Applicative doesn't require that
10:41:08 <quchen> Oh. So that choice is arbitrary?
10:41:20 <klrr> do i need to use liftIO to get out a String out of a IO String?
10:41:24 <quchen> Would something break if the whole thing was done in reverse? Like it wouldn't be a monad?
10:41:44 <hseg> I think it would be a reverse-state monad or something like that
10:41:58 <hseg> Like, you would be passing state backwards in time.
10:41:59 <Cale> klrr: no
10:42:01 <monochrom> if you have a non-Monad Applicative, the choice is arbitrary. but if you want to bridge Applicative to Monad, it is kind of forced
10:42:13 <Taneb> klrr: no, there's a page thingy that has the answer to what you want
10:42:18 <Taneb> (it's not what you think)
10:42:33 <lavorno> >:t []
10:42:38 <Cale> klrr: liftIO turns an IO action into an action in some monad with more structure than IO
10:42:48 <hseg> :t liftIO
10:42:49 <lambdabot> MonadIO m => IO a -> m a
10:42:55 <lavorno> :t []
10:42:56 <lambdabot> [a]
10:43:01 <lavorno> :t ""
10:43:02 <lambdabot> [Char]
10:43:14 <lavorno> []==""
10:43:21 <klrr> okey, so if i do "string <- hGetLine handle" and then "string == "hello"" will it be true if the input from that handle is that?
10:43:37 <lavorno> >[]==""
10:43:38 <Cale> yes
10:43:38 <hseg> klrr: Only if you're doing that in a do block
10:43:55 <Cale> klrr: The do-block containing that line will be another IO action
10:44:01 <Taneb> klrr: http://www.haskell.org/haskellwiki/How_to_get_rid_of_IO
10:44:02 <klrr> hseg: oh that's what's the problem, thank you!
10:44:03 <czro> I'm working on a project where I need to call some functions in a c++ header only library that uses c++11 features. I guess it should be possible to wrap the binding code in a .c file with ifdef __cplusplus, but how do I specify in cabal the cfags and compiler to use?
10:44:23 <monoidal> lavorno: Haskell displays lists of characters, like ['a','b'] as "ab". As a special case, "" is the same as [], but more specialized (can only be a list of Chars)
10:44:24 <Cale> klrr: http://www.haskell.org/haskellwiki/Introduction_to_IO
10:44:37 <monoidal> > ['a']
10:44:39 <lambdabot>   "a"
10:44:49 <lavorno> > [] == ""
10:44:50 <lambdabot>   True
10:44:59 <monoidal> > [] :: [Char] -- lavorno
10:45:01 <lambdabot>   ""
10:45:07 <lavorno> monoidal: so is this a feature or a bug ? :)
10:45:13 <monoidal> lavorno: A feature
10:45:16 <monoidal> > ['a', 'b']
10:45:18 <lambdabot>   "ab"
10:45:30 <Cale> klrr: You should think of do-blocks as a notation for gluing together simple IO actions into more complex ones
10:45:36 <arcatan> > ["a"] == [1]
10:45:38 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
10:45:38 <lambdabot>    arising from the literal ...
10:45:45 <monoidal> lavorno: (internally, that's why the Show class has the method showList for this)
10:45:48 <Cale> (or actions of other monads, but don't worry too much about that)
10:45:50 <hseg> I don't see a way to define lam :: (State s a -> State s b) -> State s (a -> b) from Ian Bloom's message
10:46:09 <lavorno> monoidal: it is kind of confusing
10:46:13 <Cale> klrr: and then the 'main' in your program is one of these IO actions, which describes what the entire program does
10:46:25 <lavorno> because :t [] == [a]
10:46:36 <klrr> Cale: okey, but if i for example do "msg <- hGetLine h" and then pass that msg to another function, will it become a string that i can compare to "hello" for example and return true?
10:46:42 <monoidal> lavorno: bit like 2 :: Num a => a, but you can specialize that to Integer or Float
10:46:43 <Cale> sure
10:46:44 <lavorno> and :t "" == [Char]
10:46:50 <Cale> For example...
10:47:01 <Cale> do x <- getLine; putStrLn (reverse x)
10:47:05 <klrr> okey, cause then there's some weird bug in my program, cause it doesnt work, when i compare it it doesnt reutnr true
10:47:14 <ivoscc> geneial
10:47:16 <Cale> reverse here needn't care that the line of text came from doing I/O
10:47:32 <klrr> Cale: i mean pass it to a new function, then another new function
10:47:40 <monoidal> lavorno: Perhaps it might be confusing, but I don't see how any other choice would be sane.
10:47:45 <lavorno> monoidal: in a way the system is quashing the level of generality of [] into ""
10:48:00 <Cale> klrr: Does your program compile? Perhaps you could paste it on hpaste.org?
10:48:12 <lavorno> because [] is more generic, can be an empty string of anything
10:48:17 <monoidal> lavorno: IMO, if the type of "" was [a] while "a" was [Char] it would be more confusing
10:48:25 <klrr> Cale: it does, ill paste it just give me a min
10:48:33 <lavorno> when you make it equal with the type of empty character u mess things up, no ?
10:48:42 <monoidal> lavorno: empty character?
10:49:45 <lavorno> monoidal: let's say i define a data FooBar = FooBar {a::String}
10:50:00 <hseg> lavorno: In short, Haskell adds a bit of syntactic sugar that makes the list ['a','b','c'] equal to the string literal "abc"
10:50:04 <lavorno> then i make a T = [FooBar]
10:50:16 <lavorno> hseg: i understand that part :)
10:50:32 <hseg> OK, then what's confusing about this whole thing?
10:50:35 <lavorno> the part that is confusing is how it quashes my T into ""
10:50:55 <lavorno> for example if i define T = [FooBar] as mentioned
10:50:58 <monoidal> lavorno: It won't. [] :: T will not be displayed as "".
10:51:01 <lavorno> if FooBar happens to be empty
10:51:02 <Cale> klrr: One thing to point out is that passing the result of getLine is very different from passing getLine itself to another function.
10:51:13 <lavorno> moniodal: yes it is
10:51:23 <lavorno> i tried that
10:51:33 <monoidal> lavorno: FooBar [], on the other hand, will.
10:51:36 <klrr> Cale: http://hpaste.org/86329 explaination of bug at bottom
10:52:02 <lavorno> if i do a putStr for ""
10:52:05 <hseg> Wouldn't it be displayed as [Foobar {a = ""}] ?
10:52:10 <lavorno> or a putStr for []
10:52:13 <monoidal> lavorno: A list [a] is displayed using quotation marks, not brackets, exactly if it is a list of characters.
10:52:15 <lavorno> i get the same empty representation
10:52:17 <hseg> Scratch that
10:52:32 <lavorno> hseg: no
10:52:49 <hseg> I know. Forget what I said.
10:53:10 <lavorno> hseg: but but .. i don't want to forget, cuz that's my question :)
10:53:20 <hseg> So you're saying putStr "" == putStr [] == [] ?
10:53:26 <lavorno> y
10:53:34 <monoidal> putStr "" prints the empty string (i.e. prints nothing)
10:53:35 <lavorno> where the [] comes from T
10:53:41 <monoidal> same with putStr []
10:53:46 <lavorno> which is T = [FooBar]
10:53:49 <lavorno> with an empty FooBar
10:54:04 <lavorno> which empty FooBar is NOT the same thing as an empty string !!
10:54:15 <monoidal> lavorno: The type T does not make a difference here. You might as well say print (FooBar "")
10:54:32 <lavorno> monoidal:
10:54:34 <lavorno> ?
10:54:45 <monochrom> I don't understand this conversation, or its point.
10:54:52 <quchen> ^ this
10:54:53 <monoidal> lavorno: the brackets indicting list T will be printed always with []. But the string inside the FooBar, will be printed with "".
10:55:12 <lavorno> monoidal: that is not the case
10:55:16 <monochrom> but show actual code and actual output, then perhaps say what you don't like about the output
10:55:24 <monoidal> lavorno: It is.
10:55:37 <monochrom> for example, "T = [FooBar]" is clearly not actual code
10:55:44 <lavorno> monochrom: i'll do it later - need to simplify the code a bit
10:55:46 <monochrom> and "empty FooBar" is really vague
10:56:05 <monoidal> lavorno: for example, x = [FooBar ""]  - here the string is printed with "", the list with []
10:56:14 <lavorno> monochrom: i was explaining the problm before
10:56:21 <lavorno> here is again:
10:56:26 <Cale> klrr: aha, I know what the problem is
10:56:37 <klrr> Cale: you do? :D
10:56:37 <Cale> klrr: It's the weird line endings coming from telnet
10:56:47 <lavorno> i have a type data FooBar = FooBar {a::String}
10:57:00 <klrr> Cale: okey so if i write my own client there wont be a problem?
10:57:10 <typoclass> lavorno: the thing is that values in haskell can be polymorphic. the value [] is polymorphic and can be an empty list of Strings, an empty list of Ints, and so on. "[1.23, 7.4] ++ []" and "['u'] ++ []" will both type-check
10:57:14 <lavorno> then i define a T=[FooBar]
10:57:20 <Cale> klrr: yeah
10:57:31 <monochrom> do you mean "type T = [FooBar]"?
10:57:31 <klrr> Cale: thanks! your my savior :)
10:57:39 <Cale> klrr: Or you could change the line ending mode on the handle to CRLF
10:57:51 <lavorno> typoclass: imo that comes from list being a monoid (?)
10:58:06 <klrr> Cale: hmm, how do i do that?
10:58:16 <monochrom> monoid is beside the point here
10:58:23 <lavorno> monoidal: let's continue
10:58:29 <Cale> klrr: btw, to see this effect, apply show to the string before applying hPutStrLn
10:58:29 <lavorno> then after i define T
10:58:41 <monoidal> lavorno: as monochrom asked, did you want "type T = [FooBar]"?
10:58:45 <monochrom> no, you haven't asnwered, do you mean "type T = [FooBar]"?
10:58:57 <Cale> hSetNewlineMode h CRLF
10:59:02 <monochrom> call me pedantic but I disbelieve in programmer's English.
10:59:03 <lavorno> monoidal yes
10:59:18 <klrr> Cale: okey thanks again :D
10:59:39 <Cale> klrr: another thing you should note is that you can also write main like:
10:59:49 <lavorno> ok, let's use haskellish :
11:00:15 <lavorno> data T = Tt {b::[FooBar]}
11:00:30 <lavorno> then when FooBar is empty
11:00:33 <Cale> main = do (x:_) <- getArgs; runServer (fromIntegral (read x)) test
11:00:34 <lavorno> i get empty T
11:00:42 <monoidal> you mean, b is empty
11:00:43 <monochrom> ok, I have two questions.
11:00:48 <Cale> that might be more readable for you :)
11:00:55 <lavorno> monochrom: pls go ahead
11:01:00 <typoclass> lavorno: in «"" == []», the function (==) requires both of its arguments to have exactly the same type. (you can see this by looking at its type signature.) the value "" has a concrete type, which is [Char], aka list of Char's. so here, [] is of the same type as the other side. [] is type [a] normally, and here specializes to [Char]. then it's compared, and the result is, both lists have the same number of elements (0) and each elemen
11:01:04 <lavorno> monoidal : yes
11:01:11 <monochrom> 1. "type T = [FooBar]" and "data T = Tt {b::[FooBar]}" at the same time? that's a contradiction
11:01:24 <typoclass> lavorno: and no, monoids don't have anything to do with this, as far as i know :-)
11:01:34 <monochrom> 2. what the hell does "FooBar is empty" mean? what's the actual code?
11:01:42 <quchen> lavorno: Maybe hack together a full example, and put that on HPaste. It's a little Monte-Carlo style help right now.
11:01:52 <lavorno> typoclass: i was talking about the ++ operator you mentioned
11:02:07 <lavorno> quchen: sounds good
11:02:10 <lavorno> let me do that
11:02:40 <monochrom> what quchen says
11:03:00 <monochrom> and it's about 3 lines of code
11:03:23 <typoclass> lavorno: yes, (++) does require its arguments to be a Monoid, but what i meant is how it requires both arguments to be the same type
11:03:25 <typoclass> @type (++)
11:03:26 <lambdabot> Monoid m => m -> m -> m
11:03:40 <lavorno> typoclass: sounds good
11:03:46 <monoidal> typoclass: in prelude, (++) is for [a] only
11:03:55 <quchen> (++) is for lists *only*. I have no idea why someone put that bug in Lambdabot.
11:04:11 <monoidal> typoclass: lambdabot has a strange specialization. normally monoid operation is mappend or <>
11:04:13 <quchen> Monoids have mappend or (<>)
11:04:22 <monoidal> s/specialization/generalization
11:04:24 <beaky> 234 ++ 234
11:04:26 <typoclass> monoidal: i think that doesn't change the point? (++) still needs both arguments to be the same type
11:04:27 <beaky> > 234 ++ 234
11:04:28 <lambdabot>   Ambiguous type variable `a0' in the constraints:
11:04:28 <lambdabot>    (GHC.Num.Num a0)
11:04:28 <lambdabot>      a...
11:04:31 <lavorno> i thought mappend is specialized to ++ for lists ?
11:04:38 <oconnor0> where is (++) defined on monoids?
11:04:47 <beaky> > (234 :: Integral) ++ 234
11:04:48 <lambdabot>   Expecting one more argument to `GHC.Real.Integral'
11:04:56 <quchen> oconnor0: In Lambdabot.
11:04:56 <typoclass> monoidal: but good point anyway
11:04:57 <monoidal> > Sum 1 + Sum 3 -- beaky
11:04:59 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum a0))
11:04:59 <lambdabot>    arising from a use of...
11:05:05 <beaky> :(
11:05:06 <monoidal> > Sum 1 ++ Sum 3 -- beaky
11:05:09 <lambdabot>   Sum {getSum = 4}
11:05:14 <beaky> :D
11:05:14 <oconnor0> quchen: only? that's odd.
11:05:51 <quchen> lavorno: (++) is the specialization for mappend for lists. Wherever you can use (++), you can use (<>) as well (if the types can be inferenced). The converse however is not true.
11:05:52 <monoidal> oconnor0: operations in Prelude are rarely changed, and the consensus was to call the monoid operation <>
11:06:05 <Cale> oconnor0: There's an .hs file which imports all kinds of libraries and defines a handful of things
11:06:18 <lavorno> quchen: yes, agreed, thanks for clarification
11:06:22 <typoclass> lavorno: whether it's 'a' or 'm' or some other letter, the point is that (++) requires its two arguments to be the same type. its signature is not "m -> n -> ...", instead it's "m -> m -> ..." :-)
11:06:34 <Cale> monoidal: Lately there have been some changes to the Prelude though!
11:06:51 <typoclass> Cale: you mean the exception stuff?
11:07:09 <Cale> I mean Num
11:07:28 <typoclass> Cale: ah, right!
11:07:30 <Cale> typoclass: Eq and Show are no longer superclasses of Num
11:07:36 <monoidal> Cale: also gcd 0 0 is now 0
11:07:52 <Cale> monoidal: that's a nice one too :)
11:08:09 <monoidal> but IMO changing type of (++) would be much more far-reaching
11:08:34 <Cale> It used to be that (++) :: (MonadPlus m) => m a -> m a -> m a
11:08:59 <Cale> (In Haskell 1.4)
11:10:17 <monochrom> I'm going to make a snark remark
11:10:27 <monochrom> do you intend lambdabot to provide Haskell 1.4?
11:10:34 <h4199> ⊕
11:11:10 <typoclass> monochrom: they didn't have irc back then. indeed they didn't have electricity or sliced bread at the time of haskell 1.4
11:11:33 <Cale> monochrom: No, if I did, it would have that type, rather than the type that it does ;)
11:15:11 <otters> > Product 3 ++ Product 4
11:15:14 <lambdabot>   Product {getProduct = 12}
11:18:28 <monoidal> speaking of Haskell 1.4, here's a curiosity. There was a constraint for strictness. The function "seq" had type "Eval a => a -> b -> b". Using bang patterns or strict datatypes required the Eval constraint.
11:19:10 <ciaranm> strictness should be a functor!
11:19:11 <monoidal> I think this solution is quite interesting (for example, free theorems get more powerful, and a function a -> b -> b cannot force its argument), I wonder if some day it will be revisited.
11:20:48 <typoclass> monoidal: so this Eval thing indicated in type signatures if something was to be evaluated strictly or lazily?
11:20:59 <monochrom> the Eval constraint was quite nice
11:21:12 <monoidal> typoclass: Yes. Of course, even with Eval constraint it could be lazy
11:22:38 <monoidal> typoclass: (I mean, for example, you can have f :: Eval a => a -> a -> a -> a -> a that returns its fourth argument, is strict in first and second, but not third.)
11:23:36 <typoclass> monoidal: oh i see. interesting, thanks
11:24:45 <monoidal> also every concrete type was automatically an instance of Eval, the constraints are present only for type variables
11:36:17 <monochrom> so, have you seen my latest article promoting pattern matching? http://www.vex.net/~trebla/haskell/crossroad.xhtml
11:37:00 <monochrom> I also found something while writing it and testing GHC: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/104783
11:39:26 <Sonarpulse> I am making a cabal package that provides a library, a test suite (via the haskell testing framework) and an executable
11:40:17 <Sonarpulse> should the executable and test suite require the package itself (in library) form? That seems weird but it's what http://hackage.haskell.org/packages/archive/zip-archive/0.1.3.4/zip-archive.cabal does
11:40:27 <Sonarpulse> my other guide is https://github.com/skogsbaer/HTF/blob/master/sample/sample-HTF.cabal
11:40:53 <Clint> Sonarpulse: what's weird about that?
11:41:39 <Sonarpulse> well seeing that the requirement doesn't specify with or without executable
11:41:57 <Sonarpulse> I would worry it would create a cyclic dependancy
11:42:16 <Sonarpulse> Also the HTU expample doesn't do it
11:43:33 <magicman> @hoogle gcd
11:43:33 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
11:43:40 <hpaste> Sonarpulse pasted “cncmix.cabal” at http://hpaste.org/86337
11:43:45 <magicman> Huh, prelude even. Okay <_<
11:44:04 <Sonarpulse> this is what I have so far
11:46:52 <Sonarpulse> repo is https://github.com/Ericson2314/cncmix
11:51:11 <lispy> hello
11:52:11 <aavogt> @hoogle Enum a => CInt -> a
11:52:14 <lambdabot> Prelude pred :: Enum a => a -> a
11:52:15 <lambdabot> Prelude succ :: Enum a => a -> a
11:52:15 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:52:38 <Eduard_Munteanu> lispy: hi
11:52:43 <aavogt> there's a cToEnum in the C2HS.hs that comes with C2HS, but it warns me to use standard library functions for that
11:54:14 * lispy thinks today is a good day to haskell
11:54:44 <lightquake> i have some datatype data Foo = Bar | Baz | Quux Int | ...
11:55:08 <lightquake> i want to construct a datatype that represents a Foo that is either a Baz or a Quux Int. how should i do that?
11:55:24 <elliott> lightquake: probably best to inverse the relation
11:55:34 <elliott> data SubFoo = Baz | Quux Int; data Foo = Bar | Sub SubFoo | ...
11:56:01 <lightquake> elliott: what if i want multiple overlapping subsets?
11:56:01 <applicative> dunno maybe, data Bar = Bar | Baz ; data Foo = Barz Bar | Quux Int
11:56:03 <elliott> failing that, you can do newtype SubFoo = SubFoo { subFoo :: Foo }, hide the SubFoo constructor, and export a smart constructor, or duplicate the constructors and define conversion functions (partial one way)
11:56:15 <hpaste> lavorno pasted “[] == ""  -- ??” at http://hpaste.org/86338
11:56:40 <lightquake> lavorno: "" is the empty string, i.e., the string consisting of no chars
11:56:43 <applicative> oh I got the last bit backward; whats wrong with elliott 's types, lightquake
11:56:46 <elliott> lightquake: you could do something heavyweight like data types a la carte for those kind of ad hoc combinations if you really want; I'd lean towards trying to eliminate the overlapping... depends on your usecase?
11:57:10 <elliott> this is an "untagged union" sort of thing which ADTs don't do very well (but are thankfully rare in practice, IME)
11:57:13 <lavorno> lightquake: true, but [] is the empty *anything* - why should they be the same ?
11:57:36 <Sonarpulse> yeah, it sounds like you are tying to do some sort of deep sub-typing thing that doesn't work so well here
11:57:39 <lightquake> because [] is the empty list of chars, and the empty list of integers, and the empty list of booleans, and the empty list of ()s
11:57:54 <applicative> lavorno: why shouldn't the empty string have a name?
11:58:04 <elliott> lavorno: "abc" is just sugar for ['a','b','c']
11:58:10 <elliott> is just sugar for 'a' : 'b' : 'c' : []
11:58:15 <elliott> so "" is just sugar for []. strings are lists of characters
11:58:17 <applicative> > let emptyString :: String ; emptyString = [] in emptyString
11:58:19 <lambdabot>   ""
11:58:22 <elliott> type String = [Char]
11:59:03 <lightquake> elliott: what i'm Really Trying To Do is make an asm generator that deals with arrays; my datatype is data Expr = Register | Literal | StackOffset | Global | StringGlobal | Array Expr Expr; the problem is that i want to make it so that you can only index into a Global or a StackOffset, and you can only index using a Literal, Register, StackOffset, or Global
11:59:08 <elliott> didn't you ask this an hour ago, btw? :p
11:59:20 <applicative> lightquake: which is bad, that we have "" as a special representation of the empty list of chars, or that we have [] as a representation of the empty list of whatever
11:59:28 <lavorno> elliott: yes, but ppl asked for a paste with more clear details
11:59:37 <lightquake> applicative: wrong l-username
11:59:40 <elliott> lightquake: hm. consider a typeclass?
11:59:41 <applicative> sorry that was for lavorno
11:59:49 <applicative> lightquake: yes sorry
11:59:53 <elliott> lightquake: where you replace your constructors with methods of a typeclass
11:59:55 <lightquake> :)
12:00:01 <elliott> and give instances for the relevant types which capture exactly what can appear in each position
12:00:03 <lavorno> applicative: that both are the same
12:00:14 <lightquake> yeah, that's what i was considering. that or a GADT
12:00:31 <elliott> yeah, you can do a GADT with two type-level tags and then let things that work in both positions be polymorphic in the tag
12:00:35 <applicative> they don't mean the same thing, no? -- I mean as we see from the types
12:00:48 <applicative> @type ("",[])
12:00:50 <lambdabot> ([Char], [a])
12:00:51 <Sonarpulse> I would start with type classes, should be sufficient
12:00:59 <applicative> [] has a different type
12:01:05 <elliott> lightquake: though you could do something even more "primitive"
12:01:07 <lavorno> applicative: exactly, the are different thing, however they are equal
12:01:12 <Sonarpulse> but yes, GADTs if need be.
12:01:51 <elliott> lightquake: data IndexInto = Global | StackOffset; data IndexUsing = Literal | Register; data IndexUsingFull = Inner IndexUsing | Into IndexInto; data Expr = ExprInto IndexInto | ExprUsing IndexUsingFull
12:01:53 <lavorno> applicative: [] == ""
12:01:59 <lavorno> (even though they have different types)
12:02:00 <elliott> lightquake: or something like that. probably not very pleasant.
12:02:08 <elliott> er, that should be | ExprUsing IndexUsing
12:02:11 <elliott> in the definition of Expr
12:02:15 <applicative> lavorno: yes this is just polymorphism, its good!
12:02:37 <applicative> lavorno, does it worry you that
12:02:40 <Sonarpulse> existentials can help too
12:02:44 <applicative> > 1 == 1.0
12:02:47 <lambdabot>   True
12:02:50 <applicative> but
12:02:51 <lavorno> applicative: yes, sometimes at night :))
12:02:55 <applicative> @type (1,1.0)
12:02:58 <lambdabot> (Fractional t1, Num t) => (t, t1)
12:03:05 <lavorno> applicative :  no, just run into this issue with some types
12:03:18 <lavorno> and wanted to see what's teh best way to handle it
12:03:31 <lavorno> was signalling the "empty value of a type" with []
12:03:45 <lavorno> that got overloaded with ""
12:03:50 <applicative> but the first problem, which has to do with polymorphism has been well understood and accompanied by a deep theory for 40 years
12:03:52 <lavorno> and got me some problems down the road
12:04:03 <applicative> the other has a not too bad theory in haskell with type classes
12:04:10 <elliott> lavorno: if you are dealing with lists, then "" is the "empty" value of [Char]
12:04:21 <elliott> pretend the "" syntax doesn't even exist. it's just []. strings are just lists
12:04:25 <lavorno> elliott: yes, dealing with lists
12:04:25 <elliott> there is no conflict
12:04:42 <applicative> lavorno: [] signals the empty value of a *list* type
12:05:02 <monoidal> lavorno: It's like numbers 2 and 2.0 are the same, only one is special version of the other
12:05:15 <applicative> "" is really an excess of cuteness
12:05:18 <lavorno> applicative: but how can i differentiate between "the empty value of a list of Foo vs the empty value of a list of Bar" ?
12:05:30 <applicative> monoidal: I tried that above :)
12:05:35 <Iceland_jack> lavorno: You don't
12:05:44 <monoidal> applicative:  :(
12:05:49 <lavorno> Iceland_jack : but i want to..
12:05:50 <Iceland_jack> @type (==)
12:05:52 <lambdabot> Eq a => a -> a -> Bool
12:06:02 <applicative> lavorno: you can't if you call them both [], but you can give them separate names if you use a signature
12:06:02 <elliott> lavorno: what are you trying to do, really?
12:06:15 <elliott> it sounds like you're trying to make the language do things it doesn't want to :)
12:06:30 <lavorno> elliott: differentiate between different list of types
12:06:39 <lavorno> and find out when some are empty
12:06:48 <s778> but why?
12:06:58 <elliott> can you explain what you mean by that? do you have any code you can show? or perhaps desired behaviour of the function you want to write? (is it a function? what's its type?)
12:06:59 <applicative> lavorno: you can also define a dedicated list-of-Foo type, in several ways. e.g. data Foolist = FooNil | FooCons Foo Foolist
12:07:02 <monoidal> lavorno: Types are determined compile-time and erased run-time
12:07:03 <elliott> I'm unsure of your goals
12:07:24 <applicative> and similarly with Barlist, then FooNil and BarNil won't be the same, the equality wont typecheck
12:08:36 <lavorno> applicative: that sounds like an idea, but is there a simpler way? i was hoping that if i just make lists of different types they will be inferred as different even if they are empty..
12:08:45 <applicative> lavorno: similarly you can just newtype FooList = FooList {getFoolist :: [Foo]} then 'the empty foolist' is Foolist [], the empty bar list is Barlist []
12:09:08 <Sonarpulse> could anybody figure out what's broekn with http://hackage.haskell.org/packages/archive/zip-archive/0.1.3.4/zip-archive.cabal ? I asked earlier but no respondees
12:09:21 <lavorno> applicative: that sounds even better..
12:09:37 <applicative> lavorno: what is the trouble you are trying to avoid; I think you will find that it is impossible.  general polymorphism is an iron tight system
12:09:47 <Iceland_jack> lavorno: I don't understand what your actual goal is, you can make lists of different types but why do you believe you need to compare empty lists of different types?
12:10:31 <Sonarpulse> the problem building the test suite complains "Warning: output was redirected with -o, but no output will be generated"
12:10:46 <Sonarpulse> though testSuit (which has a main function) is clearly specified
12:11:11 <lavorno> Iceland_jack: i am trying to build a larger type, composed of subtypes that can be lists of ohter types, etc. then need to play around with them - hence hte question
12:11:26 <Iceland_jack> There aren't subtypes in Haskell lavorno
12:11:50 <lavorno> Iceland_jack : i mean a type with fields of different types
12:12:56 <Iceland_jack> Do you consider ('a', True) a “type with fields of different types”?
12:12:59 <applicative> Sonarpulse: are you running the testsuite? it works fine here
12:13:12 <Sonarpulse> I can manually run TestMain.hs
12:13:15 <Iceland_jack> ('a', True)'s type is (Char, Bool) and Char and Bool of different types
12:13:20 <Sonarpulse> but cabal test fails
12:13:21 <lavorno> Iceland_jack: the type merging created by the [] forcing them to be equal creates some confusion.. but applicative's approach is an interesting one - let me try that and get back if i have further q
12:13:54 <Iceland_jack> That is probably not what you want to do, but do as you please
12:14:08 <Sonarpulse> as far as I can tell testMain isn't being passed to ghc
12:14:12 <Eduard_Munteanu> (,) can be considered sugar for data Pair a b = Pair a b
12:14:20 <applicative> Sonarpulse: did you do cabal configure --enable-tests (and cabal clean before that)? -- just making sure...
12:14:22 <Sonarpulse> or ghc isn't realizing it and not some other file contains the main method
12:14:25 <Sonarpulse> not cabal clean
12:14:35 <lavorno> Iceland_jack: I consider Blah = Blah {a::[Foo], b::[Bar], c:: {Baz} } to be that
12:15:05 <Iceland_jack> sigh
12:15:13 <Sonarpulse> still doesn't work
12:16:20 <lavorno> Iceland_jack: not sure what u mean by "that is not what u want to do.." but thanks anyway for your input
12:16:30 <Sonarpulse> the other error part of the error is "because there is no Main module."
12:16:31 <applicative> Sonarpulse: dunno, I did cabal configure --enable-tests then as usual cabal build and then cabal test and all tests passed
12:16:42 <Sonarpulse> with my repository version or the paste bin?
12:18:45 <Sonarpulse> wait, I havne
12:18:57 <Sonarpulse> t pushed enough I would think for you to be able to run anything at all
12:19:54 <Sonarpulse> maybe try again with a clean copy of https://github.com/Ericson2314/cncmix
12:20:00 <Sonarpulse> I just pushed what I have so far
12:21:03 <wting> Is calling point free style pointless style an intentional double entendre?
12:21:17 <Eduard_Munteanu> wting: it is tongue-in-cheek
12:21:43 <Sonarpulse> we really should take on C and have an obfuscated haskell contest
12:21:43 <Eduard_Munteanu> wting: truth is it's pointless indeed, if taken to the extreme
12:22:33 <Eduard_Munteanu> @pl \x y z -> foo x y . bar y z
12:22:33 <lambdabot> (`ap` bar) . (((.) . (.)) .) . foo
12:22:33 <ciaranm> the worst you can do in c is abuse the preprocessor and use expressions like x +++ y
12:24:13 <wting> ciaranm: http://cm.bell-labs.com/who/ken/trust.html
12:24:14 <Happy0> oh look, it's ciaranm
12:24:17 * Happy0 hides
12:25:14 <Sid_a> Hi Eduard, I'm new and curious about the lambdabot, You had @pl (assuming that is an IRC name) and the rest is a lambda definition but with free variables foo and bar?
12:25:46 <wting> Sid_a: http://www.haskell.org/haskellwiki/Lambdabot
12:25:48 <Eduard_Munteanu> Sid_a: hi... @pl is just a lambdabot command
12:25:53 <ciaranm> @pl \x y -> x + y
12:25:53 <lambdabot> (+)
12:26:09 <Eduard_Munteanu> foo and bar don't have to be defined
12:26:23 <Sid_a> cool thanks that was my next question.
12:26:48 <ciaranm> @pl \x y z -> (x + y) * (x + z)
12:26:49 <lambdabot> ap (flip . (((.) . (*)) .) . (+)) (+)
12:27:00 <ciaranm> and that's why you shouldn't go pointless pointlessly
12:27:15 <Eduard_Munteanu> Seemingly "innocent" stuff can get turned into a mess.
12:27:41 <tac> It can turn into a real category of a mess!
12:28:06 <ciaranm> messes don't form a category. there's no identity. if you don't touch a mess, it still becomes a different mess.
12:28:35 <Taneb> :t \x -> (*) <*> (x +)
12:28:36 <lambdabot> Num b => b -> b -> b
12:28:36 <tac> It's a higher-order mess
12:28:45 <ciaranm> surely "higher-disorder"
12:28:46 <Eduard_Munteanu> n-mess
12:30:50 <lavorno> @pl \ (x*x -1)
12:30:50 <lambdabot> (line 1, column 5):
12:30:50 <lambdabot> unexpected "*"
12:30:50 <lambdabot> expecting letter or digit, operator or ")"
12:31:12 <lavorno> @pl \ x^2-1
12:31:12 <lambdabot> (line 1, column 4):
12:31:12 <lambdabot> unexpected "^"
12:31:12 <lambdabot> expecting letter or digit, operator, pattern or "->"
12:31:40 <lavorno> @pl \ x -> (x^2 -1)
12:31:40 <lambdabot> subtract 1 . (^ 2)
12:31:41 <h4199> @pl \x -> (x*x - 1)
12:31:41 <lambdabot> subtract 1 . join (*)
12:31:47 <Eduard_Munteanu> ciaranm: hm... maybe messes have identities only up to isomorphism... messy, no? :P
12:32:00 <lavorno> h4199:tx
12:32:08 <LoremIpsum_> @pl \ x**2-1
12:32:08 <lambdabot> (line 1, column 4):
12:32:08 <lambdabot> unexpected "*"
12:32:08 <lambdabot> expecting letter or digit, operator, pattern or "->"
12:32:47 <geekosaur> \x -> x**2-1 -- perhaps you meant?
12:33:20 * hackagebot hydra-print 0.1.0.3 - NCurses interface to view multiple ByteString streams in parallel.  http://hackage.haskell.org/package/hydra-print-0.1.0.3 (RyanNewton)
12:33:41 <lavorno> @pl \x-> x^4 - 2*x^2 +1
12:33:42 <lambdabot> (1 +) . liftM2 (-) (^ 4) ((2 *) . (^ 2))
12:35:01 <lavorno> imo from @pl \x-> x^4 - 2*x^2 +1 decomposition as (1 +) . liftM2 (-) (^ 4) ((2 *) . (^ 2)) results that the bot algo is not able to "see" too deep into compositions (?)
12:35:19 <lavorno> (x2-1) ^2
12:35:21 <h4199> that is pretty clear
12:35:32 <Eduard_Munteanu> Pointfree style merely tries to avoid function application.
12:35:54 <Eduard_Munteanu> It doesn't necessarily imply other clever tricks.
12:36:02 <ciaranm> being pointless certainly has applications!
12:36:07 <Eduard_Munteanu> :)
12:36:11 <lavorno> i was hoping the bot has teh clever tricks up his stack :)
12:37:10 <fizbin> Occasionally it'll come through with a nice derivation, but lots of times I find it misses pretty obvious connections.
12:37:13 <s778> Does the haskell runtime automagically use memoiziation?
12:37:21 <luite> s778: mostly no
12:37:38 <fizbin> :t uncurry id
12:37:40 <lambdabot> (b -> c, b) -> c
12:37:50 <s778> Oh. Well, good to know
12:38:10 <fizbin> :t (uncurry id) . (,)
12:38:13 <lambdabot>     Couldn't match expected type `(b0 -> c0, b0)'
12:38:13 <lambdabot>                 with actual type `b1 -> (a0, b1)'
12:38:13 <lambdabot>     Expected type: a0 -> (b0 -> c0, b0)
12:38:36 <luite> s778: there are some cases where values might be more shared than you might expect through lambda lifting (making global things from locals), but it doesn't memoize function application
12:38:46 <tac> @type curry
12:38:49 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:39:17 <ab9rf> there should be a spicy curry
12:39:50 <Clint> @type vindaloo
12:39:53 <lambdabot> Not in scope: `vindaloo'
12:40:10 <s778> Is it safe to assume the compiler is good at optimizing but the runtime just, well, runs?
12:40:15 <lavorno> ab9rf: you can make your own spice curry in haskell
12:40:19 <parcs> luite: what about through inlining? e.g. let f x = .... where y = g x. if 'f x' is inlined does y get shared?
12:40:45 <Eduard_Munteanu> s778: what does "just runs" mean?
12:41:13 <Eduard_Munteanu> @faq Can Haskell cook you some spice curry?
12:41:13 <lambdabot> The answer is: Yes! Haskell can do that.
12:41:15 <s778> It doesn't do any clever tricks, just what you'd expect it to do. No JIT for example
12:41:33 <ciaranm> why would it JIT? it's compiled...
12:41:33 <ab9rf> why would it need to do JIT? the compiler already generated machine code
12:41:44 <fizbin> @pl \x y -> (uncurry id) ((,) x y)
12:41:45 <lambdabot> (uncurry id .) . (,)
12:41:47 <s778> Derp, well yeah, but I can't think of many other examples
12:42:02 <fizbin> > (uncurry id .) . (,) $ 2
12:42:04 <lambdabot>   *Exception: show: No overloading for function
12:42:21 <fizbin> :t (uncurry id .) . (,) $ 2
12:42:24 <lambdabot> Num c => b -> c
12:42:37 <dolio> GHC, at least, doesn't do any extra optimizations at runtime. It's all at compile time, to my knowledge.
12:42:43 <monochrom> that is a vague question. perhaps upload your brain for a full analysis. but GHC's runtime doesn't do JIT code changes
12:42:44 <dolio> Same for JHC.
12:42:57 <luite> parcs: hm it's already shared even before inlining isn't it?
12:43:11 <fizbin> Wow. I got the NumInstances exception message there.
12:43:20 * hackagebot http-reverse-proxy 0.1.1.5 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.1.5 (MichaelSnoyman)
12:44:21 <__xc> are there real hastables/hashmaps in haskell, with O(1) lookup?
12:44:51 <monochrom> no
12:44:56 <ciaranm> there's no such thing anywhere
12:45:03 <ab9rf> nobody has O(1) lookup for a hashmap
12:45:05 <oconnor0> hehe
12:45:20 * monochrom not going to play this debate this time
12:45:20 <ab9rf> unless your hash table is larger than the index domain
12:45:26 <ab9rf> in which case, why are you using a hash table?
12:45:28 <parcs> luite: oh right
12:45:43 <ciaranm> also it still costs log n at some point. possibly in hardware.
12:45:53 <s778> Okay, I'll just describe why I'm actually asking these questions. I have this method which is pretty CPU intensive; but haskell handles it surprisingly fast. This method gets called a lot (at least 60 per s). Seeing as the arguments to this method don't change often I was wondering if the runtime optimizes it with memoization (and if not, to do it myself)
12:45:59 <fizbin> ab9rf: You do so long as your hash table grows proportional to n.
12:46:06 <luite> parcs: i think it also does lambda lifting after inlining though, you might check yourself :)
12:46:34 <__xc> ok, thx, that confirms what I think
12:46:38 <fizbin> ab9rf: If you can put a limit on the average number of thinks in a hash bucket that holds as n grows arbitrarily, then you have O(1) lookup.
12:46:47 <fizbin> *things, rather.
12:47:12 <monochrom> no automatic statistics-based memoization. do it yourself.
12:47:25 <ciaranm> you only have O(1) lookup if your hardware is cheating for you
12:47:52 <Happy0>  lul'z
12:47:53 <s778> Right. Got it.
12:47:57 <__xc> yes, well in C you could do that, with pointers?
12:48:20 <fizbin> ciaranm: No, because you end up with O(1) * O(log k) where k is the average number of things in a bucket. If k is bounded...
12:48:46 <ciaranm> fizbin: dereferencing a pointer isn't O(1) except when your hardware cheats for you
12:49:32 <geekosaur> __xc, no, O(1) is actually a misrepresentation, but you're talkg to mathematicians who are more interested in the reality than the CS approximation where O(1) really means O(log n)
12:49:50 <fizbin> You're claiming that dereferencing a pointer costs more if you have more pointers allocated?
12:50:01 <ciaranm> no, i'm claiming it costs more the larger your address space is
12:50:10 <bitonic> ciaranm: that’s not how you usually work with complexity (you assume that operations like that are constant)... in that framework it makes some sense to say hash tables have O(1) *amortised* lookup
12:50:24 <ciaranm> bitonic: they don't have O(1) amortised lookup either...
12:50:44 <__xc> yes thanks, the hardware complexity should be abstracted (the best possible) from
12:51:03 <Ralith> bitonic: I think the missing part ciaranm is alluding to is where you bound the number of elements by available memory.
12:51:09 <ciaranm> the problem is, if you continue down this road, you can claim you can add together two arbitrarily large integers "in O(1)"
12:51:15 <bitonic> ciaranm: if you are going to argue otherwise by saying that ‘dereferencing pointers is not constant’, OK.  but that’s not usually the point when talking about complexity
12:51:42 <fizbin> I'm not sure how to do big-O calculations when you've got to stop and change machines once n gets large enough.
12:51:47 <Ralith> bitonic: rather, it's usually a given that there are bounds on things like integer size, address space size, etc.
12:52:20 <bitonic> __xc: to answer your question more usefully: Haskell has various ‘hash table’ packages that behave well.  the most popular one for immutable hash tables is ‘unordered-containers’, ‘hashtables’ for mutable ones
12:52:43 <elliott> unordered-containers isn't really a hash table...
12:52:45 <elliott> it's a HAMT
12:52:46 <__xc> Ralith, that's what types are foor
12:52:51 <elliott> it uses hash tables, but it's not a hash table
12:52:53 <__xc> for*
12:53:07 <geekosaur> let's be so pedantic as to confuse the **** out of everyone...
12:53:14 <monoidal> geekosaur: http://cs.stackexchange.com/questions/1643/
12:53:18 <Happy0> lmao
12:53:28 <bitonic> elliott: I was trying to help __xc, who probably just wants a fast container.
12:53:38 <ciaranm> O() tells you nothing about how fast it is!
12:53:40 <bitonic> I even put hash table in quotes, to be prudent :P
12:53:43 <elliott> sure, Haskell has various fast container packages that behave well :P
12:53:51 <geekosaur> and is using standard terms instead of accpetable-to-#haskell pedantic ones
12:53:57 <elliott> I think it's miselading to call HashMap a hash table though, because people will expect properties that it doesn't have.
12:54:01 <monochrom> I am pedantic, but I explain what I want pedantic and why
12:54:14 <elliott> it's more of a tree than a table.
12:54:15 <Eduard_Munteanu> People will expect too much of hashtables anyway. :P
12:54:22 <elliott> it's more similar to Map than a hash table.
12:54:25 <elliott> or whatever.
12:54:32 <__xc> bitonic, thx wads asking generally, because I has this wrong idea oh O(1)
12:54:39 <__xc> was*
12:54:41 <Happy0> rofl. we're now branching out to different lines of pedantry in parallel
12:54:45 <Happy0> this gets better and better
12:54:53 <Happy0> the poor guy is no closer to an answer
12:55:05 <Sonarpulse> Data.Map *done*
12:55:22 <Sonarpulse> optomize it later
12:55:25 <ion> or HashMap if you want as hash instead.
12:55:57 <ion> s/\<as\>/a/
12:56:24 <bitonic> elliott: again I know HashMap is not quite an hash table, I was trying to give a generic useful answer, given the generic question
12:56:30 <ion> (For instance, when the Hashable + Eq constraints are more feasible than Ord)
12:56:56 <h4199> http://hackage.haskell.org/packages/archive/hashmap/1.1.0/doc/html/Data-HashMap.html
12:57:16 <Eduard_Munteanu> ion: I somehow suspect Hashable tends to give you a reasonable Ord
12:57:17 <ion> @hackage unordered-containers
12:57:18 <lambdabot> http://hackage.haskell.org/package/unordered-containers
12:57:42 <ion> eduard_munteanu: System.Mem.StableName
12:58:29 <fizbin> Eduard_Munteanu: Not necessarily, especially since you still need to sort those things that hash together.
12:58:43 <bitonic> __xc: to wrap it up, if you want the closest thing possible to imperative hash tables (and you probably don’t), use ‘hashtables’.  if you just want a fast container, use ‘unordered-containers’.
12:59:45 <__xc> bitonic, perfect, and are functional languages more a barrier for hash tables or not?
12:59:53 <fizbin> Eduard_Munteanu: e.g., you could define a Hashable for (Hashable a) => Set a that was just the sum or xor of every component piece (maybe then plus the size). This wouldn't come close to pointing at an Ord instance.
13:00:18 <ciaranm> __xc: are aircraft a barrier for bridges?
13:00:22 <bitonic> __xc: I don’t understand the question.  Haskell is a perfectly good host for any kind of hash table, if that’s what you are asking
13:00:57 <bitonic> @faq can Haskell hash tables?
13:00:57 <lambdabot> The answer is: Yes! Haskell can do that.
13:01:16 <cschneid> @faq can Haskell solve halting problem?
13:01:16 <lambdabot> The answer is: Yes! Haskell can do that.
13:01:24 <sproingie> wow the hash table thing again
13:01:24 <__xc> ciaranm, hehe right, they are just a tool
13:02:03 <tgeeky> These are not 'ash brownies, mon!
13:02:17 <elliott> fizbin: well, you can derive compare from (==) + ordering on hashes
13:02:29 <sproingie> if you say "hash table" in a mirror three times, jon harrop comes out to flame you
13:02:39 <typoclass> __xc: there's a number of data structures that suit functional languages very well, if that's what you mean. for example there's a complete book by okasaki that discusses them
13:02:49 <__xc> bitonic, thinking with 'states'
13:02:59 <fizbin> elliott: Then what do you do if the hashes are equal but the objects aren't (==) ?
13:03:06 <cschneid> typoclass: book reference?
13:03:10 <bitonic> __xc: ‘states’?
13:03:25 <bitonic> cschneid: ‘Purely Functional Data Structures’
13:03:39 <cschneid> thanks
13:03:45 <cschneid> worth buying?
13:03:53 <cschneid> is it mostly theoretical or practical?
13:03:57 <h4199> it is free as far as I know
13:04:02 <typoclass> cschneid: when googling "okasaki", google's first hit was the right thing :-)
13:04:10 <bitonic> cschneid: it’s both, which is great
13:04:23 <elliott> fizbin: you check object (==) first
13:04:33 <bitonic> cschneid: it gives SML and Haskell code for each data structure described
13:04:40 <elliott> oh well
13:04:41 <elliott> I see what you mean
13:04:47 <elliott> you could just assign it arbitrarily, I think?
13:04:53 <cschneid> cool. I'll have to pick this up - it sounds like a good way to start understanding the complexity of the crap I'm writing
13:05:17 <fizbin> elliott: So you're saying that you could define an Ord instance… by picking an arbitrary order?
13:05:35 <fizbin> At that point, you didn't really need Hashable, did you?
13:05:46 <__xc> bitonic, err, when an imperative hastbale is saved, the key/vals are overwritten, which functional languages must abstract (without any IO monads etc..)
13:06:02 <fizbin> Because whatever you do in the hashes-are-equal case, you could do generally.
13:06:13 <__xc> (ah this  keyboard)
13:06:19 <elliott> fizbin: point :)
13:06:23 <bitonic> __xc: Haskell gives you ways of expressing mutability (ST, IO)
13:06:31 <fizbin> __xc: Sure, blame the keyboard.
13:06:56 <__xc> yes I've seen the StateMonad, not used yet
13:07:31 <Eduard_Munteanu> Hmm, now that I think about it, what fizbin says about collisions sounds like a problem for e.g. Set.
13:08:09 <fizbin> Eduard_Munteanu: That's why most operations on (Set a) require (Ord a)
13:08:10 <Eduard_Munteanu> You could say Hashable + Eq though.
13:09:03 <__xc> the Set write is portentially long to do
13:09:22 <__xc> (insert at right place)
13:09:36 * Eduard_Munteanu suddenly wants first-class instances and parametrized modules like Agda
13:09:45 <ab9rf> hashtables have become the swiss army knife of many programmers because they're a language feature in so many ducktyped languages
13:09:56 <Eduard_Munteanu> You should really be able to pass in a makeshift Ord without making it an instance.
13:11:18 <ab9rf> "I'll just put this into a hash table instead of making a type for it because making a type is so much hassle, and besides hash tables and objects are really the same thing in this language anyhow"
13:11:49 <__xc> yes and the most misleading (for me at least) are those nosql databases that claims to be O(1)
13:12:36 <Eduard_Munteanu> We should make an everything-is-a-hash language.
13:12:55 <ab9rf> Eduard_Munteanu: i think that's ruby.
13:13:05 <bitonic> Eduard_Munteanu: I did that at one point
13:13:21 * hackagebot pipes-network 0.1.1.0 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.1.1.0 (RenzoCarbonara)
13:13:35 <Eduard_Munteanu> Hm, crazy. :)
13:13:59 <bitonic> it’s the O(1) language
13:14:05 <nominolo> Eduard_Munteanu: ruby has tables
13:14:13 <nominolo> and tables have meta tables
13:14:21 <nominolo> they also double as modules
13:14:24 <nominolo> and arrays
13:14:26 <ab9rf> it's turtles all the way down
13:14:35 <nominolo> it's actually very powerful
13:14:44 <ab9rf> (and therefore slow)
13:15:07 <nominolo> ab9rf: yes, luajit internally has a more efficient representation
13:15:24 <donri> javascript arrays are nice
13:15:32 <otters> ruby is my favorite non-haskell language
13:15:41 <nominolo> but the hash lookups can be optimised to direct offset lookups in a JIT, so it's not really slow
13:15:49 <tac> fix fromTurtle
13:15:51 <Chousuke> __xc: is that O(1) in the same way that some Clojure data structures are O(1) for some operations (ie. actually O(log n) but the base of the logarithm is so small and n is limited by available memory so it's also effectively O(1))
13:16:02 <otters> :t var
13:16:04 <lambdabot> String -> Sym a
13:16:14 <otters> > let turtle = fun "turtle" in fix turtle
13:16:16 <lambdabot>   Ambiguous type variable `a0' in the constraints:
13:16:16 <lambdabot>    (GHC.Show.Show a0)
13:16:16 <lambdabot>     ...
13:16:19 <Eduard_Munteanu> unsafeTurtleLeaveShell
13:16:36 <luite> donri: it's a bit annoying that there's no efficient Ord equivalent to (===) though
13:16:37 <otters> > let turtle = fun "turtle" in fix turtle :: Expr
13:16:39 <lambdabot>   turtle (turtle (turtle (turtle (turtle (turtle (turtle (turtle (turtle (tur...
13:16:51 <nominolo> :t (===)
13:16:53 <lambdabot>     Not in scope: `==='
13:16:53 <lambdabot>     Perhaps you meant `==' (imported from Data.Eq)
13:17:03 <luite> nominolo: oh i meant for javascript arrays
13:17:04 <Sonarpulse> lualol
13:17:37 <Sonarpulse> fixed my cabal error, TestMain had to contain module Main, not just function main
13:17:41 <luite> you have object identity, but you can't make efficient collections with it, because you have nothing other than identity
13:18:02 <nominolo> luite: Oh, right. well JS is an incredibly fucked-up language, so it's not really a surprise.
13:18:58 <donri> luite: maybe i should've been more obviously sarcastic, but i thought it'd be obvious by default
13:19:03 <nominolo> hm, hashes, identity and moving GC is a difficult thing indeed
13:19:09 <monoidal> Chousuke: "but the base of the logarithm is so small" - I'll nitpick, but the base is smaller, the logarithm is larger
13:19:21 <monoidal> (for base and value > 1)
13:19:36 <Chousuke> monoidal: yeah, I need sleep
13:19:37 <luite> donri: hehe i did suspect it, but i like ignoring that ;)
13:21:54 <Taenk> @djinn (Either a (Not a))
13:21:54 <lambdabot> -- f cannot be realized.
13:22:20 <Taenk> @djinn Either a (Not a)
13:22:20 <lambdabot> -- f cannot be realized.
13:22:49 <Taenk> @djinn Not (Not (Either p (Not p)))
13:22:49 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
13:23:00 <otters> @info Not
13:23:01 <lambdabot> Not
13:23:04 <otters> nice
13:23:08 <armlesshobo> lol
13:23:17 <Taenk> @djinn (Not (Either p (Not p)))
13:23:17 <lambdabot> -- f cannot be realized.
13:23:32 <Taenk> @djinn (Either p (Not p))
13:23:32 <lambdabot> -- f cannot be realized.
13:23:34 <__xc> Chousuke, n can get large, but at a point you're ight, it will be partiotinned and so on..
13:23:43 <Taenk> @djinn p
13:23:44 <lambdabot> -- f cannot be realized.
13:23:50 <Taenk> @djinn (p)
13:23:50 <lambdabot> -- f cannot be realized.
13:24:52 <mithodin> Hey. I'm trying to do a local install of ghc on my linux account on a university computer (which is why I can't install it properly). GHCi works, but when I try to compile a program, ld can't find libgmp (ld: cannot find -lgmp)
13:25:09 <mithodin> I added the directory where the libraries are to $LD_LIBRARY_PATH
13:25:19 <mithodin> do I need to do anything else?
13:25:25 <Taenk> @djinn Either p (Not p)
13:25:25 <lambdabot> -- f cannot be realized.
13:25:32 <ab9rf> LD_LIBRARY_PATH is used for ld.so, not for ld
13:25:46 <jfischoff> @djinn (a, Either b c) -> Either (a, b) (a, c)
13:25:47 <lambdabot> f (a, b) =
13:25:47 <lambdabot>     case b of
13:25:47 <lambdabot>     Left c -> Left (a, c)
13:25:47 <lambdabot>     Right d -> Right (a, d)
13:25:57 <ab9rf> you probably need to reconfigure and relink
13:26:19 <mithodin> reconfigure what? ghc?
13:26:26 <ab9rf> or edit a config file somewhere that has those paths interned
13:27:12 <ab9rf> mithodin: ghc isn't telling ld to look in that directory for libraries
13:27:40 <ab9rf> so you need to convince ghc to do so, probably by editing its config, possibly by rebuilding it
13:27:54 <mithodin> ok, reading ./configure --help now
13:28:18 <supki> otters: type Not a = a -> Void
13:28:41 <mithodin> there's --with-gmp-includes and --with-gmp-libraries, but I had set those before
13:29:02 <ab9rf> mithodin: did you specify the folder where those are when you configured it?
13:29:08 <Sonarpulse> hmm I am having trouble invoking my own configuration flag with caba
13:29:11 <Sonarpulse> *cabal
13:29:19 <mithodin> ab9rf: I did
13:32:27 <mithodin> ab9rf: Ok, I ran "./configure --with-gmp-includes=/home/nuss/s1lutref/bin/include --with-gmp-libraries=/home/nuss/s1lutref/bin/lib --prefix=/home/nuss/s1lutref/bin/" and make install after that
13:32:33 <mithodin> the problem remains
13:35:35 <lightquake> in a .prof file, what do the "no." and "entries" columns mean?
13:41:02 <lightquake> oh 'entries' is number of times the cost center was entered
13:45:04 <dmwit> merijn: :k! works in 7.6 and 7.4 here.
13:45:11 <dmwit> merijn: Are you sure you're Doing It Right?
13:45:51 <dmwit> merijn: ...oh, haha
13:45:58 <dmwit> merijn: I have something in .ghci...
13:46:32 <dmwit> :def k! return . (":kind! "++)
13:48:55 <mithodin> ab9rf: Okay, there's a workaround: I can just pass ghc a library search path with -L
13:49:25 <ab9rf> mithodin: that at least works
13:49:37 <mithodin> yep, it doe
13:49:41 <mithodin> *does
13:51:16 <mithodin> I can put that in the ghc wrapper script
13:51:21 <mithodin> problem solved :-)
13:59:46 <monoidal> is there a variant of rawSystem that gives an exception on failure?
14:00:29 <monoidal> or, a way to convert ExitCode to user-friendly String?
14:01:06 <arkeet> how would you convert an ExitCode to a string?
14:01:47 <dmwit> monoidal: You just want the number, or do you have a mapping from numbers to friendly strings?
14:01:55 <dmwit> If the latter, just pattern match on the exit code.
14:02:01 <monoidal> dmwit: A friendly string
14:02:17 <monoidal> arkeet: I believe C has strerror for this
14:02:29 <dmwit> ...no
14:02:42 <arkeet> monochrom: that's for errno, not for exit codes.
14:02:45 <dmwit> I don't even know what that does and I know it's not that.
14:03:08 <arkeet> there isn't really any consistent meaning for exit codes, other than "nonzero is failure"
14:03:23 <monoidal> arkeet: right sorry
14:03:32 <Sonarpulse> hmm setDefaultArgs is not changing the number of tests run for me with HTF + quick check
14:04:42 <dmwit> monoidal: So, is your question sufficiently answered, or is there more?
14:05:27 <jfischoff> Is there a  package that uses TH to generate mysql marshaling code from an existing type declaration?
14:06:18 <monoidal> dmwit: I'm now not convinced whether what I want to do is possible.
14:07:03 <dmwit> monoidal: For particular programs, you may know a mapping from exit codes to what went wrong.
14:07:13 <Sid_a> Yeah it seems like it would require an assumption about the OS or at least a POSIX standard or something like that.
14:07:27 * dmwit pines for plan9
14:07:37 <dmwit> ...where exit codes are strings to begin with.
14:07:44 <typoclass> monoidal: an errno is a thingy in c that a function can use to indicate an error happened. there's a defined list of possible values, and strerror looks up a friendly string from this list. an exit code is not for functions, but for programs. they aren't really standardized; every program makes up its own stuff. if you're lucky, the manpage of the particular program will list the possible exit codes and what they mean
14:08:34 <monochrom> for example, cabal-install doesn't document what its exit codes mean :)
14:08:37 <monoidal> dmwit: the story is: runghc runs rawSystem ghc parameters, and you can override which ghc to run with command flag -f. But if that ghc is not found, we get no diagnostic from runghc - except the error code, which is often not seen in a haskell
14:08:52 <monoidal> I'd like to fix that, but now don't know how.
14:09:10 <monoidal> *often not seen in shell
14:09:34 <dmwit> monochrom: Does cabal-install even have more than one exit code? =P
14:09:49 <typoclass> monoidal: interesting, you mean from package runghc, or the builtin tool 'runghc' that comes with ghc?
14:09:50 <monochrom> yes, 9 was observed a few days ago
14:10:49 <monoidal> typoclass: built-in. For example, if you do "runghc -fdefer-type-errors X.hs" you would think that runghc was meant to use defer-type-errors, while in reality it run as if "defer-type-errors" was a version of GHC to be run
14:11:06 <typoclass> monoidal: oh wow
14:11:09 <monoidal> typoclass: while the intent is "runghc X.hs -fdefer-type-errors"
14:11:19 <typoclass> monoidal: absolutely
14:15:33 <monoidal> runghc is just 175 lines of code, easy to modify. But I don't know way to fix it, other than printing the error code on failure
14:17:31 <dmwit> monoidal: Why would you print the error *code* on failure?
14:17:38 <dmwit> The code is available in other, better ways.
14:17:59 <monochrom> echo $?
14:18:09 <monoidal> https://github.com/ghc/ghc/blob/master/utils/runghc/runghc.hs#L127 if anyone wants to see it
14:18:22 <monoidal> dmit: What ways?
14:18:36 <dmwit> Oh, you mean the code of the underlying process?
14:18:51 <dmwit> ok
14:19:07 <dmwit> But runghc already exits with the exit code of the underlying process.
14:19:14 <dmwit> So... just look at runghc's exit code.
14:19:15 <monochrom> arguably it should be the shell's job
14:22:08 <Rc43> Hi, guys.
14:22:17 <Eduard_Munteanu> Rc43: hi
14:22:59 <johnw> I'm looking for some more examples of using Yoneda in Haskell.  I've found two so far: (1) transforming GADT representation into ADTs, and (2) transforming any function x -> y into a CPS version: forall b. x -> (y -> b) -> b.  Are there other good ones?
14:23:47 <johnw> the code I'm playing around with is: https://gist.github.com/jwiegley/5438178
14:23:49 <Rc43> Can cabal build packages with cache? It seems that it recompile whole package by default.
14:24:01 <johnw> Rc43: do you mean, ccache?
14:24:18 <typoclass> monochrom: true. i've long used a prompt in my shell which mentions the exit status of the last command, colored green for 0 and yellow otherwise
14:24:34 <johnw> typoclass: is that for bash?  can you share it?
14:24:38 <monoidal> in any case I think runghc behaves rather inconsistently: it gives an error message when it does not find ghc, but when the user tells the executable and it does not exist, there is no error
14:25:03 <typoclass> johnw: sure :-) hang on
14:25:23 <Rc43> johnw, didnt talk about it directly, but may be it is related
14:26:05 <Rc43> johnw, just want to make `cabal build` to build without recompiling all; `make`-like behaviour would be ok
14:26:30 <dmwit> Rc43: cabal build should not rebuild everything, only what's changed.
14:26:35 <dmwit> That's what it does here, anyway.
14:26:36 <johnw> cabal doesn't usually rebuild everything
14:26:37 <typoclass> i suppose runghc could try to run ghc, check if it exited with a failure, then say "warning: ghc exited with a error code 123". this however will trigger e.g. whenever your source code contains an error
14:27:24 <typoclass> independently, i think runghc should read its -f option and try doesExistFile on that path. it can then output a clear message and exit
14:27:26 <typoclass> monoidal: ^^
14:27:43 <johnw> hmm.. no yoneda fans on I guess.  shachaf!!
14:28:01 <dmwit> typoclass: That would mean that runghc would have to re-implement $PATH (or %PATH%) searches. I disagree that it should do this.
14:28:29 <Nafai> johnw: What's yoneda?
14:28:57 <johnw> Nafai: http://en.wikipedia.org/wiki/Yoneda%27s_lemma
14:29:27 <typoclass> dmwit: good point. so rawSystem runs a shell and gives it a string to run?
14:29:43 <dmwit> Approximately, yes.
14:29:59 <Rc43> dmwit, johnw, can cabal-dev cause recompiling?
14:30:08 <johnw> Rc43: it shouldn't anymore than cabal would
14:30:13 <armlesshobo> wow, parsec is so friggin easy to use.
14:30:23 <armlesshobo> it makes me sick... :\
14:30:28 <johnw> armlesshobo: yeah, pretty awesome isn't it?
14:30:30 <johnw> suck it, yacc!
14:30:35 <armlesshobo> ugh...
14:30:40 <monoidal> so, there is no way to tell apart "shell failed to run a process" and "process failed with some error code"? That's strange
14:30:56 <dmwit> There is, if the exit codes differ. =)
14:31:06 <johnw> now if only parsec would gain back from me all the time I spent writing yacc grammars in my life, it would be perfection
14:31:55 <fegu> is there a way to do this without the \s -> : filter (\s -> length s > 2) ["yes","no","maybe"]
14:31:57 <monoidal> johnw: you saw sigfpe's blog posts on Yoneda? you might find something inspiring
14:32:01 <armlesshobo> combinator parsers in the same language? didn't even think to think of that. mind = blown.
14:32:05 <dmwit> ?pl \s -> length s > 2
14:32:05 <lambdabot> (> 2) . length
14:32:07 <johnw> yes, I've read it several times; I have it queued to read again
14:32:16 <johnw> plus Gabriel's and Edward's posts on it are good
14:32:22 <johnw> and John Baez seems to have a really solid grasp on it too
14:32:33 <fegu> dmwit: thanks!
14:32:45 <fegu> dmwit: will use lambdabot in the future
14:32:54 <dmwit> fegu: \o/
14:33:35 <typoclass> monoidal: dmwit has a point. i think you should check rawSystem's exit code if it is 127 or not. if i remember correctly that's what the shell will give you to indicate "couldn't find executable file"
14:36:56 <monoidal> typoclass: I agree, although I don't know how widely applicable the number 127 is.
14:37:18 <monoidal> of course, there are other possible errors, for example "permission denied"...
14:37:33 <lispy> Suppose a cabal file with executable and library sections. The executable depends on the lib. Is there a way to say, 'hey, this executable has the same depends as the library' without repeating the build-depends section in both?
14:37:58 <monoidal> most probably instead of runghc we should have "ghc --run", like ghci is really "ghc --interactive"
14:38:11 <lispy> (this has bugged me for a while, but I never figured out if I'm doing something wrong)
14:38:57 <johnw> lispy: I've wondered that many times too
14:40:15 <typoclass> monoidal: i don't know either. but something like «when (exitstatus == 127) $ hPrint stderr "Exit status 127. This may indicate that the ghc executable file was not found"» would help the portion of users where it's applicable. so it's at least some sort of improvement over the current situation
14:41:18 <lispy> johnw: I know that the minimum requested cabal version matters in this behavior
14:41:30 <johnw> yes, I've noticed that too
14:41:36 <monoidal> typoclass: Agreed. if no better solution will surface within several days, I'll make a patch.
14:41:39 <typoclass> monoidal: possibly an awesomer fix would be to "just" add a function System.Process that searches through the PATH in a platform-independent foolproof awesome manner. then runghc, and tons of other people as well, could just use this function to determine if an executable is present
14:41:40 <lispy> johnw: if it's 1.8 or less it is (incorrectly) permissive
14:41:49 <lispy> or was it 1.2?
14:41:52 <lispy> anyway, something like th at
14:42:07 <typoclass> monoidal: (this new function probably needs to be extracted from how rawSystem's internals work)
14:49:27 <monoidal> typoclass, dmwit: System.Directory.findExecutable searches system PATH for an executable and returns Maybe String. that's probably the best solution.
14:49:28 <armlesshobo> I am so bad at naming functions it's sad
14:49:55 <typoclass> monoidal: that sounds excellent. didn't know about that function. thanks a lot
14:55:48 <lispy> johnw: http://stackoverflow.com/questions/6711151/how-to-avoid-recompiling-in-this-cabal-file/6711739
14:55:56 <lispy> johnw: note the gotcha about hs-source-dirs
14:56:06 <lispy> that was what was biting me
14:56:32 <johnw> interesting!
14:56:41 <johnw> thanks for finding that
14:58:01 <lispy> johnw: things like this always remind me how nice a hypothetical cabal-lint could be.
14:58:14 <lispy> johnw: I guess this one is an actual bug, but still
14:58:41 <lispy> having a tool that can critique your build-depends would be handy
14:58:54 <lispy> "Unused dependency zlib"
15:00:07 <johnw> i'd love that too
15:01:00 <typoclass> johnw: ok i've dug it out and written it up! :-D http://hpaste.org/86341 could've sworn i had the colored exit code thing for bash, but i have it only for zsh. maybe you can adapt it
15:01:08 <typoclass> s/maybe/i bet/
15:01:40 <stelleg> :t putStrLn.show
15:01:41 <lambdabot> Show a => a -> IO ()
15:01:57 <typoclass> stelleg: that's practically the same as 'print' :-)
15:01:58 <stelleg> :t let print = putStrLn.show in print
15:02:00 <lambdabot> Show a => a -> IO ()
15:02:05 <stelleg> weird
15:02:10 <monoidal> stelleg: print is the same thing as putStrLn . show
15:02:19 <stelleg> yeah but try defining print that way in ghci
15:02:29 <stelleg> it types it as () -> IO ()
15:02:46 <elliott> that's because of extended defaulting rules and the monomorphism restriction :(
15:02:48 <monoidal> stelleg: it's monomorphism restriction, a corner case
15:02:55 <stelleg> ah
15:03:13 <stelleg> I've used NoMonoMorphism a couple of times
15:03:20 <stelleg> don't fully grok it yet though :)
15:03:30 <hpc> welcome to the wonderful world of trying to use ghci for things that should go in a file!
15:03:31 <monoidal> stelleg: you can either use NoMonomorphismRestriction or add a type sig:
15:03:32 <typoclass> stelleg: the dmr strikes! try :set -XNoMonomorphismRestriction. probably best to put it in your .ghc/ghci file. or whatever the name is
15:03:32 <monoidal> let print :: Show a => a -> IO (); print = putStrLn.show
15:03:45 <monoidal> stelleg: ^ the above will give a normal type
15:04:09 <monoidal> stelleg: also, if you run ghc -Wall (not sure if without Wall), you'll get a warning that GHC defaults the type
15:04:12 <stelleg> monoidal: cool, i tried let print = putStrLn.show :: Show a => a -> IO ()
15:04:16 <stelleg> and that didn't work
15:04:23 <stelleg> cool
15:04:24 <johnw> typoclass: :(
15:04:44 <stelleg> typoclass: good idea, I didn't know you could do that
15:04:53 <elliott> better to use :iset I think
15:05:08 <typoclass> stelleg: also good for imports that you use all the time :-) Data.Maybe and so on
15:05:20 <stelleg> oh man so many things I dont know about
15:06:29 <typoclass> johnw: sorry. but one section in bash's manpage (PROMPTING) talks about how variables inside the prompt are being expanded. it should be "just" a matter of having a function run everytime it's about to show a prompt. the function can set some variables then
15:07:35 <johnw> yeah, my bash fu is pretty terrible
15:07:44 <johnw> so, i'll live without :)
15:08:09 <monoidal> johnw, typoclass http://stackoverflow.com/questions/103857/what-is-your-favorite-bash-prompt
15:08:23 <johnw> ooohhh
15:09:04 <johnw> heh, the smiley/frowney is funny
15:09:12 <Nafai> My bash prompt runs calls an array of functions
15:09:26 <Nafai> all I have to do to add stuff to my prompt is add a function to the array
15:10:06 <typoclass> johnw: good choice. whenever i learn one new thing about the shell i immediately regret it. there's always one more crappily-designed dsl with cryptic incompatible escape codes. like PS1="\[\033[1;7m\]\j \w \[\033[0m\] "
15:10:53 <Clint> yeah, zsh's cryptic escape codes are a lot prettier
15:16:21 <typoclass> Clint: in this case yes, to some extent. it's good that the color green has the name "green" as opposed to "\033\[3;7m" or whatever. but it's still not great. it's not exactly easy to read "%K{green}%(1j|%K{cyan}|)%%%j%k%K{green}"
15:17:54 <typoclass> i swear, one of these days i'mma write a shell that is just ... i dunno. something that you'd want to use in the year 2013
15:18:20 * arbn feels guilty for really enjoying libraries that use Arrow.
15:18:27 <Clint> typoclass: pfft, my prompt is much clearer than that
15:18:53 <Nafai> typoclass: I've been tempted to write my own shell at times too
15:19:41 <jfischoff> typoclass: have you seen plush?
15:19:57 <jfischoff> it at least could serve as a starting place
15:20:05 <typoclass> jfischoff: googling now! haven't heard of it before, many thanks
15:20:31 <typoclass> ah, it's on mzero's github account :-)
15:20:51 <jfischoff> yep its pretty cool
15:21:04 <luksow> is there a 'join' (wait for completion) for a thread created by forkIO?
15:21:22 <jfischoff> yes waitForThreadId or something
15:23:17 <luite> jfischoff: uh really?
15:23:34 <jfischoff> or something :)
15:23:50 <luite> i don't think there is one, ghc doesn't have primops for it either
15:24:26 <jfischoff> waitForChildren?
15:24:56 <jfischoff> oh I see
15:25:02 <jfischoff> listen to luite
15:25:07 <luite> that's not a standard thing, you can do it manually with MVar
15:25:37 <monochrom> consider using the "async" library. comes with Haskell Platform
15:25:38 <jfischoff> yeah I was thinking of waitForProcess
15:25:55 <typoclass> luksow: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html has some code that you can copy-paste. i wonder why it's not a real function you can call
15:26:00 <fegu> I really need parMap parallelizable bytestrings. It is supported in the latest version. But how to uprade? a LOT of packages depend on bytestring.
15:26:08 <typoclass> luksow: erm, monochrom is right. listen to him
15:26:08 <shachaf> jfischoff: No, use thread communication primitives for thread communication.
15:26:15 <shachaf> "async" is a good wrapper around using MVars.
15:26:22 <shachaf> (Or, actually, TVars?)
15:26:41 <jfischoff> shachaf: no doubt, I just misremembered
15:27:06 <jfischoff> I remember waiting, but it was for a process not a thread
15:27:18 <shachaf> "async"-spawned threads can be waited for.
15:27:34 <luksow> hmm, ok I'll try async
15:27:57 <luksow> but well, in fact I can threadDelay because it's just a demo...
15:28:07 <monochrom> I think async uses both MVars and TVars
15:28:15 <Ralith> async is pretty awesome
15:28:49 <shachaf> I suppose there is killThread so the question is not entirely unreasonable.
15:32:17 <luksow> wow, async is really nice
15:32:24 <luite> you could even use killThread for this purpose, if you're careful what you do in the other thread
15:37:14 <luksow> ok so I'm writing MSc thesis about (un)safe concurrent programming and in one chapter I'm showing how life is simplified by transactional memory, so I wrote this simple example: http://hpaste.org/86342 is it correct? I wanted to show that no matter how many times you run handlePlayerGoal the result is the same
15:37:38 <applictive> i was trying once to figure out how to get a monadzip instance for one of he types in async; then you could use parallel monadcomprehensions for maximal amusement
15:38:09 <tcrayford> luksow: You could quickcheck that, or actually write a proof.
15:38:11 <applictive> [x + y | x <- async1, y <- async2 ]
15:38:49 <luksow> tcrayford, I know but I'm looking for human remarks like "this example is stupid/inadequate" etc ;)
15:40:33 <typoclass> luksow: if you change line 12 to "atomically $ do", you can eliminate the stray ")" in line 18 :-)
15:40:43 <tcrayford> luksow: it seems to make sense to me. It's not exactly how I'd accomplish that goal in a piece of code, but it shows coordination pretty well in a small example.
15:41:38 <luksow> typoclass, thanks! I really don't like dangling lispy ')' ;)
15:42:05 <tgeeky> applictive: what is [x + y | x <- async1 | y <- async2 ] ?
15:42:06 <monochrom> I like parentheses
15:42:48 <tcrayford> tgeeky: an monad comprehension
15:42:54 <monochrom> but anyway, luksow: the program does only one update regardless of more threads calling handlePlayerGoal
15:43:13 <typoclass> luksow: most people write "main = do", not "main = \n do", but it's a matter of personal style. if you're doing that consciously, then ok
15:43:24 <typoclass> luksow: (applies also to line 11)
15:43:27 <applictive> tgeeky, a parallel monad comprehension
15:43:28 * hackagebot commsec 0.2.1 - Provide communications security using symmetric ephemeral keys  description: This package provides confidentiallity,  integrity and replay detection. Users must  provide ephemeral keys for one time use (reuse  will compromise the...  http://hackage.haskell.org/package/commsec-0.2.1 (ThomasDuBuisson)
15:43:28 <luksow> tcrayford, thanks! it's rewritten incorrect ruby code mentioned in my thesis so I wanted to show differences...
15:43:49 <luksow> monochrom, yes it's supposed to :)
15:44:04 <luksow> in "buggy" version score was incremented too many times
15:44:16 <applictive> tgeeky: unfortunately I think it requires a monadplus instance
15:44:36 <luksow> typoclass, thanks, will fix it, I like both but if you say that = do is more popular...
15:44:38 <monochrom> buggy versions correspond to splitting the single "atomically" block into several smaller ones
15:46:11 <applictive> tgeeky: but it is sort of the secret 'idiom brackets' of ghc since the instance requires only mzip :: m a-> m b -> m (a,b)
15:46:22 <monochrom> for maximum bugginess, use 4 "atomically"s
15:46:53 <luksow> monochrom, in code listing in thesis main function won't be shown ;)
15:47:16 <monochrom> right, but I'm referring to handlePlayerGoal
15:47:35 <luksow> ah, ok
15:50:26 <hpaste> Ghoul pasted “Syntax Error” at http://hpaste.org/86344
15:50:57 <Ghoul_> Hi, anyone know how to fix that ^ ?
15:51:20 <Ghoul_> type of stat is stat :: Parser Stat
15:51:49 <simpson> Ghoul_: Did you want something on that line like...: optional (reserved "then")
15:52:10 <Ghoul_> Here are the rest of the types http://hpaste.org/86345
15:52:24 <Ghoul_> simpson: I was going for If (expr) statement (Maybe If)
15:52:24 <typoclass> luksow: the two TVars seem to be written and read together, right? so in principle, you could combine them into a tuple (Score, Goal), or even just add a Score field to Goal
15:52:50 <Ghoul_> oh, thans for the fix simpson on that line btw
15:53:18 <luksow> typoclass, hmm tuple is quite good idea, combining them into one type however is not in the context of this example
15:54:33 <Ghoul_> One more error http://hpaste.org/86346
15:55:44 <Ghoul_> I think I did or understood the Just/Nothing thing wrong - its the first time I really tried it without using an example as a base :\
15:57:05 <simpson> Yeah, I'm not sure what you were going for there and am not familiar with parsec, sorry.
15:57:36 <typoclass> luksow: how does the program work overall? one player reads the initial values from that TVar. 'completed' is False, therefore the player writes new values into both TVars, setting completed = True. the next 2 players read from the TVars again, but don't write and don't do anything because 'completed' is True
15:59:50 <typoclass> luksow: about "adding a Score field to Goal", i meant, you may need to rename Goal. you could call it State or GameState or something
16:01:43 <luksow> typoclass, yes you are probably right
16:02:07 <shirt> is there a good tutorial for Control.Applicative?
16:02:08 <luksow> typoclass, generally I proposed (in Haskell) fix for the bug study here: http://eviltrout.com/2013/01/10/exploiting-concurrency.html
16:02:45 <luksow> typoclass, no big deal here, just showing use case for stm :)
16:03:28 * hackagebot commsec 0.2.2 - Provide communications security using symmetric ephemeral keys  description: This package provides confidentiallity,  integrity and replay detection. Users must  provide ephemeral keys for one time use (reuse  will compromise the...  http://hackage.haskell.org/package/commsec-0.2.2 (ThomasDuBuisson)
16:09:46 <typoclass> luksow: yeah, that blog post seems to describe a race condition. it's a standard problem. it has its own wikipedia page
16:10:23 <luksow> typoclass, yep, it's (almost) what my thesis is all about
16:11:16 <luksow> typoclass, I'm analysing dangers of concurrency programming, especially security and proposing ways to make it safe and secure - Haskell is one of them ;)
16:11:39 <typoclass> luksow: it's a little worrying that the blog author is using concurrency in his code, but calls semaphores "exotic"
16:12:14 <Ralith> luksow: masters' thesis?
16:12:16 <luksow> typoclass, yes! exactly, I'm kind of laughing about it in my thesis also ;)
16:12:21 <luksow> Ralith, yes
16:12:30 <typoclass> luksow: ok :-)
16:14:50 <luksow> Ralith, sound too easy/difficult, boring/exciting? ;)
16:15:20 <typoclass> shirt: basically, there's <$> which is an alias for fmap (which you may already know from Functor). the addition that Applicative makes is <*>
16:15:26 <typoclass> shirt: you could be interested in http://www.haskell.org/haskellwiki/Typeclassopedia#Applicative
16:15:33 <Ghoul_> I found the problem - my error is that the `do` thinks that its transparent and the return is trying to return from the whole function
16:15:38 <Ralith> luksow: if I must pass judgement, it sounds awfully wide-scoped.
16:19:05 <Asterfield> I'm getting the feeling that recursive calls in Java are really expensive...
16:19:32 <luksow> Ralith, yes, it is but I'm doing my best to narrowing it to sensible parts... most of it is examining some open source bugs, discussing their causes and outcomes and making some findings about it, I'm also implementing C/C++ test framework for concurrent apps and looking how good it is... generally I'm aiming at 100 - 110 pages ;)
16:21:17 <johnw> is Dan Piponi here?
16:21:30 <cmccann> I don't think he uses IRC
16:21:46 <johnw> :(
16:24:02 <Saizan> only very rarely
16:27:43 <Ghoul_> Fixed all my errors but this -- I don't understand (I think, monads?) enough to know what it wants :| http://hpaste.org/86347
16:31:54 <monochrom> "Just stat" is the result of confusion
16:32:34 <typoclass> Ghoul_: have you read the complete error message? do you have any ideas about it?
16:32:52 <monochrom> change "return $ Just stat" to "Just `fmap` stat"
16:32:53 <Ghoul_> Uh, the type seems to be wrapped in the Parser (Monad?)
16:33:01 <Ghoul_> okay ;D
16:33:22 <Ghoul_> Wonderful!
16:33:26 <typoclass> Ghoul_: well, i think it's still valuable to look at this problem
16:33:26 <Ghoul_> It works, thankyou!
16:33:30 <monochrom> do you know why?
16:33:52 <typoclass> Ghoul_: ghc is telling you that the problem is with the 3rd argument, which is 'elsestat'
16:34:25 <Ghoul_> I think its something to do with return not expecting a monad wrapped value or something
16:34:33 <Ghoul_> dont fully understand sorry ._.
16:35:08 <Ghoul_> typoclass: thanks, I was able to interpret not much more than that from the error though. I know I needed a Maybe Stat from a Maybe (Parser Stat) and that's about it.
16:35:09 <typoclass> Ghoul_: yes that's true. you figured that out correctly
16:35:22 * BMeph_ idly wonders if Ghoul_ "knows" what return "does"...
16:35:37 <monochrom> "return (Just stat)" says, do not execute stat, just pass it around. clearly, that is the opposite of what you want.
16:36:09 <Ghoul_> nope.
16:36:19 <monochrom> "Just `fmap` stat" says, execute stat, get answer, attach Just to that answer.
16:37:05 <monochrom> you have never needed "a Maybe Stat from a Maybe (Parser Stat)". that's an XY problem.
16:37:09 <Ghoul_> thanks :)
16:37:55 <typoclass> Ghoul_: return "adds one layer of wrapping", to stick with your terminology. in this case it's one layer too much, because ghc reported it saw Parser Stat, but needed a Stat
16:38:32 <sproingie> "return" has got to be the most awfully named thing in haskell
16:39:03 <monochrom> "Just `fmap` stat" = "s <- stat; return (Just s)"
16:39:06 * Ghoul_ is a C programmer and got fooled.
16:39:47 <sproingie> #define zycvwyub return and turn on cpp
16:39:56 <typoclass> sproingie: it is. it was added at a time when there were too few confused newbies in #haskell asking about newbie problems. they wanted to fix this by adding return
16:40:24 <joeyh> I prefer to use pure from Control.Applicative if the return would be confusing to an imperative programmer
16:40:40 <sproingie> and it's a good thing Monad derives from that o wait
16:40:54 <BMeph_> typoclass, sproingie: I blams Simon for it! ;)
16:41:02 <monochrom> it is unclear to me whether it should be "pure" or "impurify"
16:41:11 <hpc> typoclass: this was the best design decision that was ever made about haskell
16:41:28 <sproingie> well there's "yield" perhaps, which will just confuse python and ruby guys
16:41:47 <typoclass> joeyh: not a bad idea. i gotta stop using return, and start using pure
16:41:49 <hpc> preventing a massive influx of experienced programmers who understand programming conventions and can exert their influence to bring in new coders
16:41:53 <hpc> thus avoiding success
16:41:56 <sproingie> who are already confused by "return" anyway
16:42:00 <geekosaur> we have ``return`` and you... that
16:42:17 <joeyh> I also use noop = return () sometimes (not in any library I know of)
16:42:35 <monochrom> "return" is nothing, compared to "class"
16:42:44 <typoclass> joeyh: ah :-) i've got that function as well, in my homegrown util library
16:43:03 <shachaf> I say we rename "data" to "struct".
16:43:17 <typoclass> monochrom: good point
16:43:26 <cmccann> class at least makes some sense if interpreted as the set theory definition
16:43:29 <typoclass> hpc: what?
16:43:33 <cmccann> "instance" is worse
16:43:44 <shachaf> cmccann: How about "method"?
16:43:55 <cmccann> shachaf: I refuse to acknowledge that term
16:43:56 <Eduard_Munteanu> Or maybe "union"?
16:43:57 <shachaf> I mean, at one point one must conclude that they're doing it on purpose.
16:44:44 <cmccann> anyway, we should stick with established category theory names for things. I propose "return" be changed to "η".
16:44:56 <dmwit> joeyh: There's void :: m a -> m ()
16:45:09 <sproingie> i propose "undefined" be changed to ☠
16:45:13 <dmwit> (continuing, incidentally, the list of badly named things)
16:45:19 <shirt> typoclass: thanks
16:45:20 <joeyh> yes, I also use void rather a lot, for silly ghc warning prevention
16:45:41 <dmwit> You can also use "_ <- foo" to prevent that warning, provided that's not the last thing in the block.
16:45:51 <dmwit> I wonder whether there's a proposal to allow "_ <- foo" as the last thing in a block.
16:45:56 <typoclass> cmccann: the 3.5 people in the world who know CT and want to learn haskell will be happy. the eleventy million people in the world who have common sense will be unhappy
16:46:08 <sproingie> change "class" to ☭ because it's a class struggle
16:46:14 <cmccann> hahahaha
16:46:18 <coppro> ahahahaha
16:46:38 <coppro> best enhacnement proposal I've heard in years
16:46:40 <monochrom> but where is the struggle?
16:47:59 <cmccann> typoclass: I suspect there are more than 3.5 people in that first group. I suspect there are fewer than 3.5 people in that group who also want to deal with unicode input for a common function.
16:49:02 <shachaf> cmccann: What kind of input *isn't* Unicode input?
16:49:30 * monochrom has a better idea. ζ :: a -> m a; ξ :: m a -> (a -> m b) -> m b
16:50:33 <sproingie> oo squiggly!
16:50:48 <elliott> cmccann: i wouldn't mind eta/nu for Monad
16:50:51 <elliott> hypothetically.
16:51:02 <typoclass> monochrom: pronounced squiggly and squigiggly
16:51:17 * sproingie giggles
16:51:26 <elliott> squigiggles
16:51:59 <joeyh> hah, there's an instance of Default for IO a, so def == return () except when it doesn't
16:52:13 <sproingie> it's like snoop dog with a cold
16:57:46 <acowley> Anyone ever noticed GLFW-b messing with the current working directory in GHCi?
16:59:32 <typoclass> urgh, intersperse and intercalate. i always have to look up which is which. they differ only by one concat, iirc
16:59:57 <typoclass> (by 'look up' i mean, use one randomly, if ghc complains, use the other)
17:00:06 <dmwit> I don't have that problem. I've never ended up wanting intersperse.
17:00:11 <monochrom> haha
17:00:14 <sproingie> i'd never heard of "intercalate" before haskell
17:00:25 * typoclass goes look up what intersperse is
17:00:26 <acowley> typoclass: I never got a chance to thank you for that feedback on the video I made a while back. It was very helpful!
17:00:29 <geekosaur> I had, but not often
17:00:33 <dmwit> I've thought I wanted intersperse, but I always discovered I wanted intercalate later. ;-)
17:00:44 <byorgey> interCAlate has an extra conCAt
17:00:47 <cmccann> intercalate is the one you probably want when messing with strings
17:00:53 <RenJuan> intercalate is std English
17:00:59 <geekosaur> usually referring to inserting extra days into a calendar
17:01:24 <sproingie> other languages call it "join", which obviously doesn't work well for haskell
17:01:33 <acowley> I find that intercalate is one of those words that scares non-Haskellers off. "Monad" gets all the love/hate, but it's not the only hero/monster.
17:01:42 <cmccann> join usually means concat in other languages, I think
17:01:42 <typoclass> acowley: aw thanks :-D that's great. had nearly forgotten about it
17:01:46 <cmccann> which it also does in haskell
17:02:26 <typoclass> cmccann: heh, i'd have said the opposite ... "intersperse is probably what you want when preparing Strings for output"
17:02:32 <joeyh> why doesn't join work?
17:02:43 <joeyh> (Data.String.Utils.join is in MissingH fwiw)
17:02:57 <dmwit> joeyh: because Control.Monad.join is BETTER
17:03:08 <typoclass> byorgey: i would be happier if it was called intercatlate, then
17:03:09 <cmccann> intercalate is a real world. it is part of the English language. I understand people not knowing category theory jargon, but knowing what is for many of them their native language?!
17:03:13 <joeyh> aha
17:03:20 <cmccann> s/world/word
17:03:30 <byorgey> typoclass: but that is not a real English word.
17:03:41 <sproingie> it's a perfectly cromulent word
17:03:42 <byorgey> cmccann: to be fair, intercalate is a fairly obscure English word.
17:03:59 <geekosaur> @wn intercalate
17:03:59 <cmccann> intercatlate is like intercalate except it converts string input to LOLCAT first
17:04:00 <lambdabot> *** "intercalate" wn "WordNet (r) 3.0 (2006)"
17:04:00 <lambdabot> intercalate
17:04:00 <lambdabot>     v 1: insert (days) in a calendar
17:04:07 <byorgey> I actually didn't know it before seeing the Haskell function
17:04:10 <elliott> I think my first exposure to "intercalate" was Haskell.
17:04:15 <elliott> it's not really a word people use :P
17:04:16 <cmccann> byorgey: so is "concatenate"
17:04:27 <sproingie> haskell can only do LOLCODE at the type level
17:04:29 <typoclass> cmccann: yes they're both 'real words', whatever that may mean exactly, but my point was that they don't seem to suggest what they're doing
17:04:34 <byorgey> cmccann: indeed.  I don't think I've ever seen that outside of a programming context either.
17:04:48 <acowley> I'd seen concatenate before Haskell, but never encountered intercalate before Haskell.
17:04:56 <cmccann> byorgey: it's archaic I think
17:05:05 <solrize_> (molecular biology) To insert a substance between two or more molecules, bases, cells, or tissues.
17:05:15 <solrize_> http://en.wiktionary.org/wiki/intercalate
17:06:04 <cmccann> anyway, the point is that programming is full of ridiculous obscure and/or made up words
17:06:36 <sproingie> it's actually not that awful, it is curious looking.  and kinda a handful to type
17:06:44 <cmccann> if someone is scared off by using a moderately obscure English word all I can do is roll my eyes because come on
17:07:02 <acowley> I think choosing good names for things is worth spending some time on
17:07:03 <fryguybob> My wife was reading my paper and was quite confused by arity
17:07:08 <sproingie> i'm more annoyed at infix operators that make me lean on the shift key
17:07:12 <cmccann> the "inter-" root on a verb-y word gives a pretty good idea what it might mean too
17:07:38 <BMeph_> cmccann: So, to make Haskell more popular, we need to quit using real, but unpopular words, and start making up things? ;þ
17:07:38 <cmccann> sproingie: I get annoyed by infix operators that require pressing shift halfway through
17:07:53 <sproingie> cmccann: yeah alternating it is even worse
17:08:02 <typoclass> cmccann: i disagree. i think that's like saying "math is hard, let's go shopping"
17:08:19 <sproingie> camelCase is an exception mostly because i can make my IDE autocomplete it nicely
17:08:35 <cmccann> BMeph_: I think the usual approach is to take a random common word and use it to mean something ill-defined and only vaguely related to the original definition
17:08:46 <cmccann> which makes things more "intuitive" than math jargon obv
17:09:04 <chrisdotcode> hello everyone
17:09:35 <cmccann> camelCase is tolerable because you have long stretches of lowercase usually. it gets obnoxious with short words.
17:09:44 <cmccann> try typing in alternating caps and see how horrible it is
17:09:44 <typoclass> chrisdotcode: hello
17:10:01 <monochrom> I don't mind pressing the shift key. it is, like, abstracted away into a device driver
17:10:09 <chrisdotcode> hi typoclass :)
17:10:50 <cmccann> anyway I don't really buy that the jargon is what scares people off in the first place
17:10:57 <chrisdotcode> so I'm having trouble with the applicative functors and monoids chapter of LYAH. the rest of the book was fantastic, but I feel that this chapter is either making common sense really difficult to understand, or it's just going way over my head. is there an alternate reading or any easier way for me to understand applicative functors?
17:10:59 <cmccann> sounds like a rationalization, not a true reason
17:11:24 <sproingie> yah LYAH starts suffering "wall of text syndrome" around that point
17:11:26 <typoclass> cmccann: i don't think that only things that come from math can be precise (and good and beautiful, or whatever). i don't see what's so imprecise about "Maybe = Nothing | Just", or "words", or the "group" function, or any number of things
17:11:48 <chrisdotcode> sproingie: any advice?
17:12:02 <cmccann> typoclass: precise and carefully chosen jargon is good no matter where the terms come from
17:12:07 <sproingie> typeclassopedia maybe?
17:12:15 <sproingie> @where typeclassopedia
17:12:15 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
17:12:35 <acowley> cmccann: "carefully chosen" is exactly what is being debated here
17:12:36 <cmccann> typoclass: but every single time I've seen a conversation about how Haskell could be "improved" by getting rid of math jargon the proposed replacements are *atrocious*
17:12:41 <sproingie> chrisdotcode: it's more dense than LYAH but sometimes that's a good thing
17:12:44 <typoclass> cmccann: that's exactly the point. i feel i was arguing for 'carefully chosen', you were saying 'no just take terms from math'
17:12:54 <sproingie> chrisdotcode: makes a good thing to flip back and forth between
17:13:25 <chrisdotcode> sproingie: sweet! this seems like the perfect supplement! (and I *am* really eager to learn about monads, and why they scare people so much...)
17:13:27 <cmccann> typoclass: I'm complaining about people who complain about the math terms because they're allegedly scary
17:13:55 <sproingie> chrisdotcode: as monads go, by the time you get through LYAH you'll wonder what the fuss was about
17:13:59 <cmccann> typoclass: my own naming preferences tend more toward cheap puns than mathematics in fact :P
17:14:37 <chrisdotcode> sproingie: so I *should* continue reading LYAH through after this chapter?
17:14:51 <acowley> Scary usually means unfamiliar. The abstractions people worry about are genuinely unfamiliar, but things like string munging are familiar to a broader programmer audience.
17:15:05 <dmwit> You should continue reading LYAH (or anything for that matter) right up to JUST before you get bored with it.
17:15:14 <sproingie> chrisdotcode: oh definitely.  it's just that LYAH can be fatiguing after a while because its chapters feel less bite-sized
17:15:22 <typoclass> cmccann: well i have some sympathy for the complaints about math terms, but i feel we'd need to discuss this on the basis of one particular proposal ("let's now rename 'return' to 'injumblify'" or some such)
17:15:33 <sproingie> chrisdotcode: so it's good to supplement it with something more pithy
17:15:39 <typoclass> cmccann: i have a lot of sympathy for cheap puns :-D
17:15:57 <cmccann> typoclass: you've seen my either-or-both data type, right?
17:16:11 <chrisdotcode> dmwit: yeah, I'm about that point, but I'm really curious about all of the fuss of monads.
17:16:19 * sproingie never figured out how "pithy" became a synonym for "informationally dense".  isn't pith the opposite of dense?
17:16:24 <chrisdotcode> sproingie: yeah, that's exactly what happened. you're right about the wall of text syndrom
17:16:27 <chrisdotcode> * syndrome
17:16:35 <dmwit> ?go you could have invented monads
17:16:35 <lambdabot> Maybe you meant: google googleit do
17:16:39 <dmwit> ?google you could have invented monads
17:16:39 <typoclass> cmccann: nope, not yet seen it!
17:16:40 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
17:16:45 <monochrom> chrisdotcode: monad is not scary if explained by LYAH and Typeclassopedia. monad is scary if explained by natural language essays instead of actual code and experiments. imagine explaining Int by an essay without a single "1+0" example
17:16:55 <cmccann> typoclass: "data These a b = This a | That b | These a b"
17:17:27 <chrisdotcode> monochrom: yeah, I'm an example sort of guy, which is what I loved about LYAH
17:17:28 <simpson> cmccann: Interesting type. Did you define the obvious Monad on top?
17:17:41 <cmccann> typoclass: with lens-y traversals for the two parameters named "here" and "there", so that I can map the two sides with "over here" and "over there" :D
17:18:02 <dmwit> Is the Monad instance really so obvious?
17:18:14 <typoclass> cmccann: erm :-) i guess that could be useful if you have a [Either] whose length is <2
17:18:24 <cmccann> simpson: http://hackage.haskell.org/packages/archive/these/0.3/doc/html/Control-Monad-Trans-Chronicle.html
17:18:25 <sproingie> monochrom: explaining Monoid first helps, and whaddya know, "1+0" works pretty well there too :)
17:19:20 <cmccann> typoclass: the original motivating example is a structural union, like a zip that pads the inputs so that nothing is discarded
17:19:25 <monochrom> Piaget's theory. concrete before abstract. special before general. Monoid has no place until after experiencing Int, String, and functions
17:19:32 <cmccann> typoclass: whereas zip is a structural intersection
17:19:36 <typoclass> monochrom++
17:19:49 <sproingie> okay not "first" first
17:20:17 <monochrom> monoid should be the last, absolute last.
17:20:30 <sproingie> should be before Monad
17:21:00 <simpson> cmccann: Oh my, that's far better than just having an augmented Either.
17:21:21 <simpson> cmccann: Very nice type. I mean, I don't know what I'd use it for, but nice.
17:21:46 <cmccann> simpson: I've used it for accumulating warnings and errors
17:22:16 <cmccann> simpson: that's sort of the assumed use case
17:22:39 <cmccann> simpson: but it's mostly just there because why not
17:22:44 <cmccann> the rest of the package is more useful
17:22:53 <sproingie> Chronicle is a way cool name for a type
17:23:10 <simpson> cmccann: *More* useful!?
17:23:14 <typoclass> chrisdotcode: in my opinion, the fuss about monads is largely an accident caused by group psychology
17:23:17 <sproingie> heh the functions have great names too
17:23:26 <sproingie> "absolve", "condemn"
17:23:29 <cmccann> sproingie: yeah the names in that module are the best part really
17:23:37 <cmccann> I had fun making those up :P
17:23:50 <sproingie> reminds me of Perl and Acme::Damn
17:24:02 <chrisdotcode> typoclass: I hesitate to say I already understand them, but I've seen examples of $.jquerys().chaining() that was supposededly monads.
17:24:14 <simpson> Nope.
17:24:16 <sproingie> http://search.cpan.org/~ibb/Acme-Damn-0.02/Damn.pm#Method_Aliases
17:24:17 <chrisdotcode> at first I thought that a monad was something that "returned self" at the end of the function so it could be chained
17:24:19 <simpson> JQuery's not a proper monad.
17:24:34 <simpson> Deferred is, however, although it's still used in a very impure way.
17:24:46 <simpson> I'd just not worry about trying to find monads as patterns in other languages.
17:24:50 <chrisdotcode> then, I also heard that monads were like promises, which I *do* understand.
17:25:16 <chrisdotcode> but besides that, I'm relatively pure with respect to learning about them, so I'd like to learn them the right way, as soon as possible.
17:25:22 <cmccann> sproingie: "memento" is the probably the most interesting bit, as far as the warning vs. error use case goes
17:25:43 <sproingie> chrisdotcode: promises can be monads, scala libraries tend to use that to great effect
17:25:53 <jmcarthur> chrisdotcode: a key to understanding monads is to just not overthink them
17:25:58 <sproingie> haskell doesn't because well, laziness
17:26:07 <cmccann> simpson: here's the ostensibly most useful bit: http://hackage.haskell.org/packages/archive/these/0.3/doc/html/Data-Align.html
17:26:11 <sproingie> effectively everything's a promise anyway
17:26:29 <cmccann> except for the Bicrosswalk class, it's basically the most useless abstraction ever
17:26:37 <cmccann> I blame elliott for that
17:27:23 <elliott> it has two instances!!
17:27:40 <cmccann> :D
17:28:09 <dmwit> Two instances is pretty much the threshold for needing a type class.
17:28:25 <simpson> cmccann: Your naming is extravagant and you should feel extravagant. :3
17:29:09 <cmccann> oh man I almost forgot, the version of align that pads with mempty is called "malign"
17:29:13 <cmccann> that one was great
17:29:26 <monochrom> haha
17:32:00 <chrisdotcode> what do you guys feel about the "hyphenate-multiple-words-syntax"? After using it for a while, I've really grown to like it.
17:32:22 <typoclass> chrisdotcode: it's a little as if arrays in java weren't called arrays, but some weird name. someone would have googled the weird name and found a wikipedia page that talked about a strange division of mathematics. he assumes that arrays are quite mystical, then later he'd discover that they really are not. he'd write a "tutorial". more people would assume that it's all very mystical and warrants special tutorials, etc.
17:32:35 <geekosaur> aside from the flashbacks to cobol...
17:32:52 <typoclass> chrisdotcode: i guess it's kind of moot how we feel about it, because haskell doesn't allow it :-P
17:33:24 <chrisdotcode> typoclass: I feel that that's one thing that's really missing from Haskell... it seems it would make a lot of function names a lot... "cleaner"
17:33:26 <cmccann> instead, haskell allows apostrophe'separated'word'syntax!
17:34:00 <ion> Well, in Haskell, ' is supposed to approximate prime. :-P
17:34:06 <cmccann> oh and underscores I guess. but those are boring.
17:34:14 <monochrom> I most prefer unrestricted naming. failing that, hyphen for space. failing that, underscore for space. failing that, I ditch the stupid language
17:34:23 <ion> even though it approximates ‘ and ’ in most other contexts.
17:34:40 <typoclass> chrisdotcode: well you can always use camelCasedNames. it's really not very different. same number of keystrokes, and similarly separates the words visually
17:34:53 <monochrom> I dislike camel case
17:35:02 <ion> monochrom: Have you ditched Haskell?
17:35:11 <jmcarthur> chrisdotcode: agda lets you use almost anything you want :o
17:35:23 <monochrom> no, it still allows underscore
17:35:26 * cmccann also prefers hyphen-spaced-identifiers actually
17:35:34 <cmccann> it just looks nicer than underscores.
17:35:37 <chrisdotcode> ^
17:35:51 <monochrom> but Oleg uses ' for space
17:35:57 <chrisdotcode> I mean, I was amazed when I say ' in a name.
17:36:00 <ion> monochrom: Not really if you use any modules made by others. Such as Prelude.
17:36:02 <cmccann> I can tolerate camelCase though
17:36:08 <chrisdotcode> and even more amazed when I say a function named <*>
17:36:16 <cmccann> monochrom: well, that's oleg.
17:36:17 <chrisdotcode> so why not hypen-case, I figure?
17:36:17 <typoclass> chrisdotcode: :-)
17:36:43 * typoclass will start representing space with u, or m
17:36:45 <sproingie> i'm a fan of hyphen-case-identifiers but alas not too many languages are
17:36:55 <jmcarthur> chrisdotcode: oh, and that reminds me to also add that agda allows what are called "mixfix" operators (operators that can have any number of arguments)
17:37:01 <monochrom> module names are a tiny fraction of names. I tolerate that.
17:37:16 <chrisdotcode> jmcarthur: infixr also blew my mind
17:37:17 <jmcarthur> chrisdotcode: e.g.    if_then_else_    is the way to define the function that looks like this when you use it:   if A then B else C
17:37:17 <cmccann> @quote power.of.mixfix
17:37:18 <lambdabot> copumpkin says: THE POWER OF MIXFIX COMPELS YOU (to not use it much)
17:37:24 <otters> @quote otters
17:37:25 <lambdabot> otters says: lens law #1: the implementation must be shorter than the type
17:38:03 <ion> monochrom: fromIntegral. takeWhile.
17:38:05 <jmcarthur> i overuse mixfix
17:38:12 <jmcarthur> and i am not ashamed
17:38:13 <chrisdotcode> from-integral take-while
17:38:14 <latro`a_> lol @ lens law
17:38:24 <monochrom> also, if really necessary, I can still try Johnny.Whatford.Die.Die.Die
17:38:40 <latro`a_> aren't most lens functions actually just id anyways
17:38:42 <BMeph_> jmcarthur: Heh-heh. You will be.... >;)
17:38:52 <cmccann> latro`a_: except for the ones that are unsafeCoerce
17:38:55 <chrisdotcode> jmcarthur: also mixfix operators sound awesome. can you pattern match against them?
17:39:55 <sproingie> by_the_power_of_mixfix "I have the power"
17:40:24 <jmcarthur> chrisdotcode: yup (but i'll emphasize again that i'm talking about agda, not haskell. haskell does not have mixfix operators)
17:40:25 <monochrom> ion, you camel-case-huggers and your standard libs are a sunk cost. as long as I can still name my things get_value, all is not lost.
17:40:58 <cmccann> monochrom: you could hack your editor to display "camelCase" as "camel-case".
17:41:04 <chrisdotcode> I mean, *technically* I can make a vimscript to...
17:41:07 <chrisdotcode> ninja'd by cmccann
17:41:10 <cmccann> haha
17:41:33 * BMeph_ should play around in Monoids, to rename the binary function "mAppend"! >:)
17:41:35 <sproingie> i dunno about display it but autocorrect it maybe
17:41:49 <sproingie> i've thought of doing that for all the snake_case i have to deal with in python and perl
17:42:01 <sproingie> foo-bar becoming foo_bar
17:42:34 <chrisdotcode> sproingie: which is still nicer than fooBar
17:42:42 <chrisdotcode> (or even FooBar) >_>
17:42:48 <sproingie> foo.bar becoming foo->bar, that sort of thing.  i would otherwise always use spaces anyway
17:42:51 <ion> monochrom: I dislike camelCase, but i use it in Haskell because that’s the style everyone uses. Using an inconsistent style depending on whether i happened to define the value or not would be even worse.
17:43:26 <sproingie> it's just that my emacs-fu is seriously rusty and i dont remember how to pull that sort of thing off
17:44:08 <chrisdotcode> :%s/\([a-z]\)\([A-z]\)/\1-\2/g
17:44:13 <chrisdotcode> *should* work...
17:44:33 <monochrom> that is not part of my idea of style
17:44:35 <chrisdotcode> in vim, that is :)
17:44:37 <sproingie> i'd rather do it as i typed
17:44:47 <chrisdotcode> well to convert an existing codebase
17:44:57 <chrisdotcode> I naturally think in hypen-case anyway :-)
17:45:56 <sproingie> entering haskell code has different problems, all those operators that make me wander all over the keyboard and bounce on the shift key.  could probably just use dabbrevs for that
17:46:18 <chrisdotcode> what I really honestly don't like syntactically is "$" for function application
17:46:33 <chrisdotcode> "\" is *alright* for lambda, IMO, but "$" is just pure ugly...
17:46:34 <monochrom> I dislike $ too
17:46:36 <sproingie> ! would have looked nicer
17:46:55 <chrisdotcode> "!!" for elem is also really weird looking...
17:47:01 <typoclass> chrisdotcode: luckily, you can always replace it with ( ), and sometimes with .
17:47:12 <sproingie> yah never liked !!
17:47:22 <mgsloan> chrisdotcode: You get used to it!  What else should ($) be used for?  Haskell puts money to good application
17:47:23 <lambdabot> mgsloan: You have 1 new message. '/msg lambdabot @messages' to read it.
17:47:29 <chrisdotcode> composition I find extremely sexy
17:47:36 <chrisdotcode> mgsloan: haha
17:47:36 <charco> Hi, I have a source file with plenty of functions, and I want to create a source file with tests for this functions
17:48:12 <charco> How can I make so? Like "load this functions from this file, and this others functions from this other file"
17:48:30 <charco> (I'm using HUnit)
17:49:05 <chrisdotcode> haskell has a lot of syntactical quirks I don't like, but I love it as a language. (x:xs) and (x:_:y) are beautiful. I think I may make a dialect of haskell that compiles to haskell with ever-so-slightly different syntax...
17:49:16 <sproingie> yah dot for composition is nice.  i love the Caleskell dot too.
17:49:34 <sproingie> tho i now do have to admit the caleskell dot in lambdabot is confusing to the newbs
17:50:12 <cmccann> :t (.)
17:50:14 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:50:17 <monochrom> have you seen:
17:50:26 <sproingie> i like that if you put the ascii symbol for bottom, _|_ in parenthesis, it looks kinda like a bottom.  (_|_)
17:50:26 <monochrom> > Nothing ++ Nothing
17:50:28 <lambdabot>   Nothing
17:50:50 <tac> > Nothing ++ Just "Hello"
17:50:52 <lambdabot>   Just "Hello"
17:50:55 <typoclass> charco: hello, have you seen doctest? you put things like ">>> reverse [1,2,3]" in your haddock comments, followed by "[3,2,1]". the doctest tool looks at all the comments and runs this code, checking if the output matches. the cool thing is that it also serves as documentation, showing an example of how to use your function
17:50:57 <Eduard_Munteanu> sproingie: it looks like _|_ *and* a bottom :P
17:50:58 <chrisdotcode> monochrom: woah. how does that work? isn't ++ for lists?
17:51:07 <chrisdotcode> oh wait... is it for functors?
17:51:08 <tac> > Just "Hello " ++ Just "world"
17:51:10 <lambdabot>   Just "Hello world"
17:51:17 <cmccann> :t (++)
17:51:18 <lambdabot> Monoid m => m -> m -> m
17:51:20 <sproingie> chrisdotcode: more caleskell
17:51:23 <cmccann> lambdabot is weird.
17:51:24 <monochrom> ++ is for lists. except when on lambdabot
17:51:36 <fryguybob> @type (<>)
17:51:37 <chrisdotcode> ah,okay... xD
17:51:38 <lambdabot> Monoid m => m -> m -> m
17:51:43 <tac> > 1 <> 2
17:51:43 <cmccann> (I still like (++) for mappend though)
17:51:44 <lambdabot>   Ambiguous type variable `a0' in the constraints:
17:51:45 <lambdabot>    (GHC.Num.Num a0)
17:51:45 <lambdabot>      a...
17:51:46 <charco> typoclass, Awesome!
17:51:51 <tac> > Sum 1 <> Sum 2
17:51:52 <lambdabot>   Sum {getSum = 3}
17:51:53 <sproingie> chrisdotcode: the guy who does lambdabot uses some kinda souped up syntax in lambdabot.  it's awesome, but nonstandard
17:51:54 <charco> I will take a look at that! :)
17:52:07 <chrisdotcode> sproingie: so that's what "caleskell" is?
17:52:18 <sproingie> chrisdotcode: yah, cale gibbard
17:52:26 <charco> typoclass, but is there a way to do what I want?
17:52:46 <chrisdotcode> Just "Hello" ++ Nothing
17:52:49 <Cale> It's nothing special, there's just a handful of local definitions in L.hs
17:52:54 <chrisdotcode> > Just "Hello" ++ Nothing
17:52:57 <lambdabot>   Just "Hello"
17:53:04 <Cale> which is the context in which lambdabot is evaluating its expressions
17:53:12 <chrisdotcode> > Just "Hello" ++ Nothing ++ "world"
17:53:14 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe [GHC.Types.Char]'
17:53:14 <lambdabot>           ...
17:53:15 <Cale> You'll also note that lots and lots of modules are imported
17:53:32 <Cale> > foldr f z [1,2,3]
17:53:33 <lambdabot>   f 1 (f 2 (f 3 z))
17:53:36 <typoclass> charco: i guess in your UnitTests.hs, you'd have to add "import TheModule.YouWantToTest"?
17:53:43 <chrisdotcode> > Just "Hello" ++ Nothing ++ Just "world"
17:53:45 <lambdabot>   Just "Helloworld"
17:53:48 <chrisdotcode> cool
17:53:52 <Cale> There's all kinds of funky stuff which is in scope just from imports :)
17:54:30 <sproingie> they are pretty good at showing the intuition for the abstractions.  seeing how composition is fmap is the first one of those, it's essential to know
17:54:48 <chrisdotcode> sproingie: I was able to gather that much from LYAH
17:55:09 <chrisdotcode> and the laws as well
17:55:21 <charco> typoclass, but the module I want to test isn't a module per se, it is just a bunch of functions
17:55:29 <chrisdotcode> but after that, it was turtles all the way down
17:56:22 <sproingie> if (.) could be Category.<<< then that'd be cool except there's just not a lot of interesting instances of Category
17:57:13 <typoclass> charco: i guess you *could* somehow use ghci, feeding it a file that has ":load thefile.hs", then the test code. not sure how much sense that would make :-)
17:58:16 <charco> Ok, I think I will use doctest :) thanks typoclass
17:58:24 <typoclass> charco: i think sooner or later you will want to make your code a module anyway. it's not difficult, you really only add one line at the top: "module TheName where". and you need to rename "somefilename.hs -> TheName.hs"
17:59:21 <charco> I will try doing something like that. It is just for an assignment
18:02:23 <typoclass> anyhoo. as a thought experiment, intersperse should be renamed to unwordsBy, concatBy, or sepBy. i think my favorite is unwordsBy. intercalate can stay :-)
18:03:51 <tac> > fromRational (4 :: Int)
18:03:53 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
18:03:53 <lambdabot>              with actual t...
18:03:56 <tac> :(
18:04:40 <tac> @hoogle Int -> Complex Double
18:04:41 <lambdabot> Prelude (!!) :: [a] -> Int -> a
18:04:41 <lambdabot> Data.List (!!) :: [a] -> Int -> a
18:04:41 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
18:07:16 <tac> How do you turn an Int into a Double or Complex T_______T
18:07:26 <cmccann> :t fromIntegral
18:07:27 <lambdabot> (Integral a, Num b) => a -> b
18:07:35 <tac> @type fromInteger
18:07:37 <lambdabot> Num a => Integer -> a
18:07:38 <tac> ugg
18:07:42 <tac> that was the mistake I made
18:07:53 <cmccann> @src fromIntegral
18:07:53 <lambdabot> fromIntegral = fromInteger . toInteger
18:07:57 <cmccann> you were close at least
18:07:59 <monochrom> @quote monochrom fromIntegral
18:08:00 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
18:08:33 <typoclass> "if there's something strange / in your numberhood / ..."
18:08:38 <cmccann> hahaha
18:09:45 * monochrom is full of sublime advice
18:10:08 <typoclass> monochrom: slime? the green flying guy?
18:13:43 <charco> How can I upgrade GHC from Cabal?
18:13:45 <charco> It says
18:13:46 <charco> Default available version: [ Not available from any configured repository ]
18:14:20 <shachaf> You cannot.
18:14:24 <tgeeky> charco: I'm guessing, you can't.
18:14:29 <shachaf> Upgrade GHC separately.
18:14:31 <charco> How can I upgrade ghc ?
18:14:38 <tgeeky> from cabal's perspective, GHC is outside
18:14:49 <shachaf> Download the new version from haskell.org and follow the instructions.
18:14:51 <tgeeky> charco: just install a new version alongside the old
18:14:58 <charco> Hm
18:15:01 <charco> the thing is
18:15:12 <typoclass> charco: same way you installed it initially. on linux, you probably used your package manager, on other operating systems, what shachaf says
18:15:19 <tac> Ugg.... now I have to deal with the fact floating point is inexact
18:15:24 <tac> and it makes the output hard to read :(
18:15:36 <charco> I installed haskell-platform from apt (ubuntu), and I can't install haddock because it is incompatible with the version of ghc that was installed along haskell-platform..
18:15:37 <tac> #firstworldprograms
18:15:41 <monochrom> that sounds like an XY problem. why do you want to upgrade GHC?
18:16:00 <monochrom> haddock comes with haskell-platform already
18:16:06 <typoclass> tac: floats are sneaky. just randomly, have you looked at Ratio? and Data.Fixed?
18:16:15 <monochrom> in fact comes with GHC
18:16:17 <tac> No, I just squinted
18:16:29 <tac> I'm just doing a sanity check for a simple math problem
18:16:47 <charco> Oh, thanks
18:16:56 <charco> Anyway, I can't upgrade it =/
18:17:19 <geekosaur> haddock is very tightly tied to ghc
18:17:23 <m3ga> anyone know mountain view? looking for hotel recommendations for bayhac'13. is walking from the Ramada MV to the hacker dojo possible/sane?
18:17:26 <monochrom> if you want a newer haddock, it is more consistent to just get a newer GHC
18:17:35 <charco> Which should I install? DocTest or doctest ?
18:17:43 <charco> both figure on cabal..
18:17:44 <shachaf> typoclass: No, I use Debian and I download GHC from haskell.org
18:17:57 <geekosaur> (as in, haddock uses ghc's internals to parse Haskell code and comments)
18:18:17 <typoclass> shachaf: right, if you want something newer than what the distro offers. that's why i added 'probably'
18:18:22 <tgeeky> charco: lowercase version
18:18:31 <tgeeky> charco: uppercase version is deprecated
18:18:51 <shachaf> typoclass: I installed it with my package manager and then upgraded it by downloading a new version from haskell.org.
18:19:20 <charco> Ok, thanks
18:20:01 <monochrom> all those linux distros vary wildly concerning GHC. approximately the only distro where my conscience allows me to recommend "go with the distro" is arch. all others suck.
18:20:02 <charco> I'm getting this error PLP-TP1.hs:16:14: parse error on input `''
18:20:03 <fragamus> edwardk are you here
18:20:05 <charco> in this line
18:20:12 <charco>         g () 'a' = "e"
18:20:23 <charco> I can swear that that worked a while ago =/
18:20:55 <typoclass> shachaf: ah i see what you mean. you're right
18:20:59 <geekosaur> charco, sounds like you swapped your ' and your `
18:21:16 <geekosaur> make sure the Char constant is using 'a' not `a`
18:21:25 <charco> it IS 'a' >.<
18:21:40 <charco> I think the problem is with the line that is above that
18:21:53 <geekosaur> then you'd have to show us that...
18:21:53 <charco> is it illegal to define something like..
18:21:55 <typoclass> charco: please paste the relevant code on hpaste.org
18:21:56 <geekosaur> @hpaste
18:21:56 <lambdabot> Haskell pastebin: http://hpaste.org/
18:22:29 <hpaste> marco pasted “weird bug. ” at http://hpaste.org/86348
18:22:35 <charco> http://hpaste.org/86348
18:22:39 <charco> Oh
18:22:42 <charco> thanks bot
18:22:48 <monochrom> ubuntu always lags behind a bit, sometimes a lot. "debian" is not even one single thing, there are like 4 "debian"s, always. fedora splits GHC into a dozen packages to confound us all. centos has really outdated libc and downright unusable.
18:22:57 <elliott> charco: you are using tabs
18:22:59 <geekosaur> indentation?
18:23:07 <charco> Grrr
18:23:19 <geekosaur> those are continuation lines for the type signature because they're further indented
18:23:21 <typoclass> charco: try lining up all the "g"s. in other words, try un-indenting lines 6-8
18:23:27 <charco> I will check that. I always use spaces instead of tabs
18:23:56 <monochrom> and gentoo? if you're compiling GHC anyway, may as well compile it from the official source.
18:25:57 <charco> thanks guys
18:26:00 <fubaz> my suggestion for debian/fedora based: forget the dist version, get the source and build your own and install it as .deb or .rpm with checkinstall
18:26:15 <fubaz> easy upgrading/removing when needed
18:26:36 * cmccann just installs the GHC binaries from haskell.org under his home directory
18:26:56 <fubaz> cmccann, yea that works as well :)
18:27:12 <typoclass> monochrom: this is getting off-topic, but i've wondered if it's a weakness of linux, not a strength, that there's one bazillion distros with packaging and dependency management being done about one bazillion times. it seems like a huge duplication of effort
18:27:20 <Ghoul_> is there a way to prettyprint a show?
18:27:23 <tgeeky> cmccann also builds a steaming ship just to eat a fresh plate of fish, so maybe he overdoes it
18:27:34 <monochrom> anyway all these distros seem to have this NIV attitude and must do something different for the sake of being different. for example ubuntu 12.10 combines GHC 7.4.1 (not 7.4.2) with Haskell Platform 2012.4.0.0 (which is supposed to be with GHC 7.4.2).
18:27:40 <tgeeky> Ghoul_: you probably aren't understanding 'a show"
18:28:13 <cmccann> tgeeky: freshness is important with seafood!
18:28:14 <Ghoul_> I'd rather not provide my own show because it'd be huge and un-necessary
18:28:27 <tgeeky> Ghoul_: add (deriving Show)
18:28:27 <Ghoul_> but at the same time, the current one prints out lists like puke on the screen
18:28:48 <charco> typoclass, you lied to me :(
18:28:49 <tgeeky> Ghoul_: use one of the pretty printers out there, or write your own
18:28:50 <charco> Module TP1 where
18:28:55 <Ghoul_> mm
18:29:02 <charco> TP1.hs:1:12: parse error on input `where'
18:29:19 <geekosaur> `module` should be lowercase
18:29:21 <typoclass> charco: make sure that 'module' is written in lower case
18:29:54 <tgeeky> charco: to accuse a man of lying is a serious offense, punishable by accusations of lying
18:30:00 <geekosaur> you don't get to pick the case of the first letter of anything in Haksell to suit yourself
18:30:08 <geekosaur> *Haskell
18:30:17 * geekosaur kan tipe gud
18:30:22 <cmccann> you can pick any case you want as long as it's the correct one
18:30:26 <charco> it was highlighted
18:30:30 <charco> I felt so secure
18:30:50 <typoclass> charco: don't worry about it :-)
18:30:58 <RichyB> Only in string constants and comments may you freely choose your case. ☺
18:31:00 <geekosaur> trust not in syntax highlighting, because you editor is not as clever as it thinks it is :p
18:31:01 <tgeeky> charco: GHC errors and warnings are often misleading, but always more correct than we are.
18:31:38 <cmccann> GHC has a bad habit of suggesting ways to break things further so that the rest of your program matches the mistake you made
18:31:48 <monochrom> hehe
18:32:02 <cmccann> like suggesting ridiculous instances
18:33:01 <charco> Sorry to bother again >.<
18:33:11 <charco> I did haddock File.hs -o doc
18:33:19 <charco> and it didn't create any file =/
18:33:22 <cmccann> it's like if you go to open a door and push when you need to pull and then someone suggests "hey, maybe you should try kicking it open"
18:33:23 <charco> And no errors
18:33:26 <monochrom> add -h
18:33:57 <charco> what does haddock does by default =/?
18:34:05 <typoclass> cmccann: "possible fix: drive car through door"
18:34:13 <cmccann> typoclass: yeah basically
18:34:18 <tgeeky> "I see you need help operating this [revolving door entrance]. Here, try this [hand grenade]."
18:34:23 <monochrom> what you just observed. output nothing by default. you must choose -h or something else
18:34:58 <typoclass> charco: haddock extracts (certain) comments from your source code and generates html files
18:36:21 <charco> Yeah, but I tought that -h would be the default >.< or at least give an example of use in its manpages..
18:36:30 <charco> thanks monochrom  :)
18:36:42 <charco> sorry for all these noob questions
18:36:57 <typoclass> but yeah, i wonder if the "Possible fix: add instance" line shouldn't be removed. anyone who knows enough about typeclasses and instances will not need that line, and anyone who doesn't know enough will probably be misled. other "possible fix" lines seem fine
18:37:20 <typoclass> charco: no problem :-) have you seen lyah? it's a good book which you can read online
18:37:22 <typoclass> @where lyah
18:37:22 <lambdabot> http://www.learnyouahaskell.com/
18:39:29 <charco> I'm currently reading Introduction to functional programming using haskell
18:40:51 <charco> I don't have much trouble with the language itself (altought I don't know anything about monads and those things). I just did a TP for college and it was easy, I hope to learn more in these weeks
18:41:44 <charco> But I think I don't know about the whole "haskell-platform" thing, as I said, we had to code a bunch of functions in a .hs file
18:42:24 <monochrom> it means a common set of libraries. or that plus GHC.
18:42:33 <typoclass> charco: the haskell platform is a group of packages where they're doing extra work to ensure those packages all work well together
18:42:56 <charco> I mean, Hunit, Haddock, QuickCheck, doctest, etc
18:43:40 <typoclass> charco: ah i see. yeah, i guess as a beginner, someone has to tell you what all this stuff is :-) but there's #haskell for that
18:43:51 <charco> That's why I am here :p
18:44:31 <hpaste> aavogt pasted “ipopt binding naming suggestions?” at http://hpaste.org/86349
18:45:32 <Rotaerk> is there a term for a function with signature (s -> (a, s)), to distinguish it from a MonadState s m => m a
18:46:04 <aavogt>  MonadState s m => m a is like     s -> m (a,s)
18:46:37 * aavogt is confused actually
18:47:19 <typoclass> Rotaerk: i've a similar function in my homegrown util library, it's called annot (for annotate)
18:47:29 <hpaste> marco pasted “valid haddock” at http://hpaste.org/86350
18:47:36 <charco> Is that valid haddock?
18:47:38 <typoclass> Rotaerk: it looks vaguely like zip, so maybe you could name it that
18:48:29 <aavogt> edwardk: my paste (http://hpaste.org/86349) works (Ipopt binding using AD), but is there a way around those conversions between Data.Vector.Vector and Data.Vector.Storable.Vector?
18:48:33 <charco> I read that on the haddock doc but it doesn't seem to work =/
18:48:35 <Guest> if i'm going to be rendering a bunch of objects of different types, should i put all my render code in a Render module, or should i put renderPlayer with the Player, etc.
18:48:36 <Guest> ?
18:48:46 <typoclass> Rotaerk: on second thought, i don't really know what you're asking
18:49:14 <Rotaerk> I'll explain what I'm doing then
18:49:16 <aavogt> edwardk: we talked about this a couple months ago, and I finally got around to something that works
18:50:00 <Rotaerk> I'm trying to name a function that has this signature:  (HasOne t context) => (t -> (r, t)) -> context -> (r, context)
18:50:36 <shachaf> Can you generalisze it to any Applicative or Functor or something?
18:51:16 <Rotaerk> basically, there's a mapping from context to "the one T" in it, defined by the instance of HasOne.  and this function exists to transform a state-action (i.e. s -> (a,s)) into another state action, but with the s being context instead of t
18:51:35 <Rotaerk> ("state action" is what I've been calling it, but I dunno if I like that)
18:52:13 <Rotaerk> so the name of this function could (verbosely) be liftAnnotationToContext
18:52:28 <Rotaerk> (per typoclass's suggested name)
18:53:28 <Rotaerk> HasOne t is like the classes generated by edwardk's makeClassy
18:53:35 <jekor> Anyone with FreeBSD experience that knows how to resolve: Loading package hs-bibutils-4.17 ... unhandled ELF relocation(RelA) type 22 ?
18:53:50 <hpaste> monochrom annotated “valid haddock” with “need blank lines” at http://hpaste.org/86350#a86351
18:54:07 <monochrom> charco: you need blank lines. see my paste.
18:54:21 <monochrom> or just reload your paste.
18:54:30 <charco> monochrom, yeah, I figured that out after re-reading
18:54:41 <charco> It seems that blank lines are a big deal in haddock
18:54:44 <monochrom> good
18:55:04 <Rotaerk> guess people got bored with my question
18:58:13 <charco> Sorry to bother again, how can I run doctest? I installed it via cabal, and cabal info doctest says that there's an executable named doctest but it isn't in my path =/
18:59:06 <Cale> charco: Generally executables installed by cabal end up in ~/.cabal/bin
18:59:08 <typoclass> Rotaerk: i suggest "type Stateish t r = (t -> (r, t))" and "contextify :: (HasOne t ctx) => Stateish t r -> Stateish ctx r". you could also use a name involving "map", e.g. contextMap. (you mentioned "mapping", i thought that was pretty clear)
18:59:35 <charco> Thanks Cale
18:59:51 <Rotaerk> typoclass, thing is, I'm also going to have a function for (t->t) -> context -> context, and (t -> r) -> context -> r
18:59:51 <Cale> charco: You can reconfigure that in your ~/.cabal/config if you want them to be installed somewhere else, like ~/bin
19:00:15 <charco> Nah, I'll just add that folder to my path :p
19:00:39 <shachaf> Rotaerk: It sounds like you're making a lens.
19:00:47 <charco> Warning: TP1: could not find link destinations for:
19:00:47 <charco>     GHC.Types.Char GHC.Base.String Data.Maybe.Maybe GHC.Types.Int GHC.Types.Bool
19:00:53 <charco> how can I avoid those warnings?
19:00:55 <charco> what do they mean?
19:01:20 <monochrom> they mean you don't get nice hyperlinks for "Int", "Bool" etc
19:01:58 <monochrom> there are lengthy options on the haddock command line to say where your GHC docs are so the hyperlinks can be set up
19:02:36 <monochrom> in practice no one learns it, because we just call "cabal haddock" and it computes the right options
19:02:58 <Rotaerk> shachaf, hmm I don't think so, though I could be wrong; lemme hpaste something to demonstrate
19:03:11 <monochrom> so, at this stage when you're just toying and calling haddock yourself, ignore
19:04:22 <shachaf> Unifying (a -> a) -> s -> s with (a -> r) -> s -> r is exactly what lens does.
19:04:25 <charco> Ok, thanks :)
19:04:31 <hpaste> Rotaerk pasted “Entity” at http://hpaste.org/86352
19:05:25 <Rotaerk> shachaf, for this entity table I had addEntity and removeEntity, signatures similar to (s -> (a,s)), and (s -> s), respectively
19:05:45 <Rotaerk> additionally I could add a function such as entityCount of signature like (s -> a)
19:06:02 <shachaf> I don't deal with HasFoo classes.
19:06:19 <Rotaerk> however I was originally writing them not in terms of EntityTable, but in terms of a context that is an instance of HasEntityTable
19:06:29 <Rotaerk> which I realized was kind of silly to write all my functions that way
19:06:46 <Rotaerk> so now I wanted to transform them as I did with addEntity'
19:07:01 <Rotaerk> but I wanted a way to transform addEntity' back into something equivalent to addEntity, and that's state'
19:07:18 <Rotaerk> but then I'd need something also to transform a... removeEntity' and a entityCount'
19:07:32 <Rotaerk> up into HasEntityTable-context versions
19:07:56 <johnw> edwardk: ping
19:08:00 <charco> hmm, it seems that I cant show comments on the source code, right? >.<
19:08:41 <charco> (with haddock)
19:08:53 <Rotaerk> shachaf, I see value in a Has* class; I *don't* see that as a need to write any functions directly in terms of it
19:09:12 <Rotaerk> as long as I have combinators to transform normal functions into it
19:09:27 <shachaf> I didn't say I see no value.
19:09:44 <charco> It would be nice if I can watch the source code of a function if I click on it, and its comments
19:09:44 <charco> asd
19:11:54 <typoclass> charco: you can, but you need to set an extra option (i think it's called "hscolour" or similar). here is example output that haddock produces when the option is set correctly: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html note the "source links" on the right-hand side
19:12:59 <monochrom> oh shachaf: you already know about my crossroad article, but have you seen my little discovery when I was writing it? http://thread.gmane.org/gmane.comp.lang.haskell.cafe/104783
19:13:34 <charco> typoclass, nice!
19:13:42 <edwardk> johnw: pong
19:14:15 <johnw> edwardk: hey, I'm rereading your Free Monads for Less
19:14:15 <Rotaerk> typoclass, anyway, thanks for your suggestion
19:14:17 <johnw> part 2
19:14:17 <edwardk> "shachaf:	 Rotaerk: It sounds like you're making a lens."
19:14:23 <edwardk> shachaf just turned into clippy
19:14:28 <Rotaerk> lol
19:14:30 <monochrom> hahaha
19:14:36 <johnw> and you mention that Yoneda Endo is the CPS transform of the Maybe monad.  And I'm just not seeing it
19:15:09 <johnw> edwardk: if you check https://gist.github.com/jwiegley/5438178, you'll see my attempts to implement Yoneda Endo
19:15:09 <edwardk> Yoneda Endo a = forall r. (a -> r) -> (r -> r)
19:15:16 <johnw> but I'm getting stuck
19:15:25 <johnw> yeah, I saw that part
19:15:27 <monochrom> @type maybe
19:15:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:15:34 <johnw> but how does "Maybe" behavior come into that at all?
19:15:38 <edwardk> now, given that what can it do? it can't put the 'r's together.
19:15:46 <johnw> there's no "empty"
19:15:49 <edwardk> so it has to either use the function a -> r   -- in which case it has an 'a' lying around
19:15:53 <edwardk> or it has to use the 'r'
19:15:58 <johnw> oh
19:15:59 <edwardk> in which case it doesn't
19:16:04 <edwardk> nothing _ r = r
19:16:08 <edwardk> just a f _ = f a
19:16:26 <edwardk> add newtype noise and season to taste
19:16:32 <johnw> ok, let me go chew on that, thanks!
19:16:40 <typoclass> monochrom: oh wow, nice discovery in that email
19:17:30 <aavogt> edwardk: did you see this (ipopt binding) mess above http://hpaste.org/86349 ?
19:17:49 <edwardk> aavogt: missed it
19:18:00 <edwardk> i've kind of moved on from playing with the DAE stuff for now
19:18:14 <edwardk> analytics has been consuming too much of my time
19:18:39 * hackagebot binary-file 0.15.13 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.15.13 (YoshikuniJujo)
19:18:46 <monochrom> typoclass: I dare not let newbies know this! XD
19:18:59 <edwardk> monochrom: what is this? =)
19:19:05 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/104783
19:20:05 <edwardk> monochrom: ah yes that
19:20:33 <edwardk> this is part of why i tend to write out lots of my combinators laboriously by hand
19:26:20 <shachaf> monochrom: Yes, I saw.
19:26:32 <monochrom> good good
19:26:56 <shachaf> However, I still don't really approve of booleans, however they get optimized.
19:27:17 <Rotaerk> hmm, it probably would've been a good idea for me to have my functions written before asking for naming advice >_> sorry
19:28:14 <arj> @djinn not (not (either p (not p)))
19:28:14 <lambdabot> -- f cannot be realized.
19:28:22 <monochrom> I understand the dilemma. I get it worse: I try to decide on the filename before I write the file content!
19:28:47 <elliott> @djinn Not (Not (Either p (Not p)))
19:28:47 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
19:29:16 <fubaz> how about endlessly pondering about the project's name before starting it? and then resorting to some under-construction name... :p
19:30:25 <monochrom> I do that too
19:30:42 <typoclass> shachaf: i could send you a lolcat that i made, expressing opposition to booleans and conditional branching
19:31:03 <fubaz> monochrom, :)
19:34:08 <Eduren> Im having a bit of trouble trying to find the intersection of multiple lists
19:34:28 <Eduren> Trying to fold the intersect function over a list of the lists
19:34:40 <Eduren> Is there a better way?
19:35:12 <Eduren> inmult = foldr intersect [1..] [take 100 [x | x <- mult n, x /= 0] | n <- [1..20]]
19:35:39 <Eduren> mult n just generates a list of multiples of n
19:35:47 <BMeph_> monochrom: I think you missed an option in your list: [ ] D'Oh!
19:35:58 <monochrom> [1..] will cause your program to take forever and do nothing
19:36:00 <Eduren> ooooh
19:36:09 <Eduren> how would I fix that
19:36:35 <monochrom> don't use [1..]. I don't know what to use instead. perhaps use a better algorithm altogether
19:37:15 <Eduren> [1..] doesnt make it go forever
19:37:19 <Eduren> I get []
19:37:37 <Eduren> Which makes sense considering what BMeph_ said
19:38:11 * BMeph_ goes: Whoo-HOO!!
19:40:39 <Eduren> Would there be a way to easily check a bunch of predicates at once?
19:41:00 <Eduren> Say check if a number is divisible by 1 thru 20?
19:41:15 <allenj12> Hey so if i have a string of a logic statement what would be the best way of finding the index of the  main connective so for example given (((A a B) o A) a (B o C)) where the middle a is the main connective
19:41:32 <arkeet> Eduren: you could be clever about it and check if it's divisible by the lcm of {1,...,20}
19:42:01 <fubaz> allenj, build a tree out of the statement. the root is the index
19:42:03 <Eduren> Awwww yeah. That makes sense
19:42:05 <monochrom> parse the statement into a tree. the root of the tree is the answer
19:42:09 <fubaz> heh
19:42:37 <BMeph_> [1..20] & map (flip div) & sequence ? ;)
19:42:48 <allenj12> hmmm k ty!!
19:42:51 <Rotaerk> is there a such thing as partial type annotation in haskell?  for instance if I have:  foo :: (T a -> Int), is there a way to explicitly constrain it to (T String -> Int), but without the T and Int
19:42:52 <monochrom> learn how to parse a context-free grammar. recursive descent parser etc
19:43:08 <Rotaerk> I only see some threads where people are mentioning wanting it, which makes me lean towards no
19:44:29 <Rotaerk> in F# you can do something like:  type Foo<'a> = 'a -> 'a -> 'a
19:44:44 <Rotaerk> then you can force-specialize it with Foo<int>, rather than Foo :: int -> int -> int
19:46:22 <Mortchek> Is there some clear way subtyping or sharing values between types might theoretically work? For example, the language contains the type Bool = True | False; so is there some theoretical limitation that prevents it from allowing me to write a type BetterBool = True | False | FileNotFound in which the True and False are the very same members of Bool?
19:46:47 <Rotaerk> hmm... actually, I guess I could do a type alias for the function:  type Foo a = T a -> Int; foo :: Foo a
19:47:18 <geekosaur> no (thankfully)
19:47:25 <Cale> Mortchek: Subtyping makes type inference generally suck
19:47:41 <BMeph_> Mortchek: Short answer, no. Why not: what's the type of False?
19:48:26 <Mortchek> No type unless it's made explicit or can be inferred from use where only a Bool would do, or a BetterBool
19:48:31 <Cale> There exist languages which do this though.
19:48:38 <Mortchek> I suppose that does suck.
19:48:53 <geekosaur> haskell does not have a "no type" or "no type unless..."
19:49:18 <Saizan> extensible variants wouldn't be bad to have
19:49:18 <Rotaerk> mmm, that worked
19:49:36 <Cale> See Timber for a Haskell-like language with subtyping.
19:49:56 <Mortchek> Cool, I will check that out. Thanks.
19:50:01 <Cale> http://www.timber-lang.org/types.html (scroll to the bottom)
19:50:43 <Rotaerk> isn't that super-typing anyway?
19:51:02 <Rotaerk> i.e. coming up with a type that's larger, not smaller, than another
19:51:11 <Cale> hm?
19:51:25 <Cale> oh, yes
19:51:26 <Rotaerk> BetterBool isn't a subtype of Bool
19:51:52 <monochrom> Bool is a subtype of BetterBool
19:52:04 <Cale> But Bool is a subtype of BetterBool, so if you could do one, the only questions become about how it works in the face of separate compilation.
19:53:23 <typoclass> Cale: when you say timber is haskell-like, does that mean timber manages to have good type inference?
19:54:50 <Cale> typoclass: Well, it's strict, and I don't know how well the type inference works
19:55:04 <Cale> but in many other regards, it looks and works similarly to Haskell
19:55:32 <typoclass> Cale: i see
19:55:39 <Cale> (It has type classes for instance)
19:56:01 * typoclass . o O ( must not make pun about this ... )
19:56:31 <Nisstyre-laptop> typoclass: Frege looks interesting too
19:56:39 <Cale> http://www.timber-lang.org/MasterMind_descr.html -- example program
19:57:08 <Cale> 'class' isn't for typeclasses though, it has a keyword 'typeclass' for that
19:57:58 <Cale> Timber grew out of an older project called O'Haskell which was an extension of Haskell with object-oriented features.
20:01:02 <Cale> http://staff.www.ltu.se/~nordland/SCP.pdf describes the subtyping in O'Haskell, and discusses the impact on type inference
20:03:43 * hackagebot binary-file 0.15.16 - read/write binary file  http://hackage.haskell.org/package/binary-file-0.15.16 (YoshikuniJujo)
20:03:45 * hackagebot ipopt-hs 0.0.0.0 - haskell binding to ipopt including automatic differentiation  http://hackage.haskell.org/package/ipopt-hs-0.0.0.0 (AdamVogt)
20:10:42 <nh2> does anybody have some example usage for addDepenentFile? I can't find one on the Internet and am wondering if I should use that or qAddDependentFile with m being IO
20:12:04 <allenj12> can someone show me a goos source on trees? im trying to make one for the problem i asked for before but it seems unclear
20:12:57 <Cale> nh2: What library is that from?
20:13:04 <Cale> allenj12: What kind of tree?
20:13:13 <nh2> Cale: Language.Haskell.TH
20:13:32 <Cale> ah
20:13:38 <nh2> it's the thing to notify ghc of what external files to check for recompilation of TH code
20:15:34 <Cale> nh2: It appears that the instance of Quasi for IO just complains on qAddDependentFile
20:15:42 <Cale> So, you have to do it in the Q monad anyway
20:16:13 <Cale> and the instance of Quasi for Q just implements qAddDependentFile as addDependentFile
20:16:51 <Cale> http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/src/Language-Haskell-TH-Syntax.html#Quasi -- see the instances here
20:17:30 <Cale> counter = unsafePerformIO (newIORef 0) -- nice
20:21:29 <latro`a_> :t newIORef
20:21:30 <lambdabot>     Not in scope: `newIORef'
20:21:31 <lambdabot>     Perhaps you meant `newSTRef' (imported from Data.STRef)
20:21:37 <latro`a_> lame
20:22:17 <latro`a_> ...where *is* the IORef stuff? (I haven't used it before)
20:22:52 <arkeet> @index IORef
20:22:52 <lambdabot> Data.IORef
20:23:05 <latro`a_> TIL about @index, thank you arkeet
20:23:16 <arkeet> @hoogle IORef
20:23:16 <lambdabot> Data.IORef module Data.IORef
20:23:17 <lambdabot> Data.IORef data IORef a
20:23:17 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
20:23:40 <latro`a_> knew about that, not sure why I didn't think to use it
20:23:47 <arkeet> :p
20:27:08 <charco> is there a function that given an elem it creates an infinite list with that elem? just like [ a | x <- [1..]]
20:27:13 <latro`a_> :t repeat
20:27:15 <lambdabot> a -> [a]
20:27:19 <charco> thanks.
20:27:34 <latro`a_> also, a generalization
20:27:35 <latro`a_> :t cycle
20:27:37 <lambdabot> [a] -> [a]
20:27:49 <latro`a_> :t cycle . return
20:27:51 <lambdabot> a -> [a]
20:28:09 <latro`a_> cycle . return === repeat
20:30:33 <charco> cycle [a]
20:31:26 <latro`a_> indeed
20:32:21 <DanielDiaz> > repeat 0
20:32:23 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
20:37:31 <jmcarthur> is there a good reason for transformers not having   instance Monoid r => MonadPlus (ContT r m)  ? (and the same for Alternative, of course)
20:37:50 <jmcarthur> ah well i guess there would need to be at least a Monad constraint on m for that
20:38:06 <Ghoul_> What's a Monoid
20:38:12 <jmcarthur> err, Applicative would enough, but in transformers style it would probably overconstraint m to Monad
20:38:16 <Ghoul_> Infact, I won't ask that here. Ignore the question.
20:38:50 <jmcarthur> Ghoul_: a monoid is a set with an binary operation such that the operation is associative and has an identity in the set
20:39:14 <Ghoul_> Yeah, that was the sound of it going over my head.
20:39:37 <jmcarthur> Ghoul_: addition and multiplication of the real numbers are both examples of monoids
20:39:54 <jmcarthur> Ghoul_: take addition: it's associative, and has an identity (0)
20:40:02 <nh2> Cale: with addDependentFile, I have no clue how I'm supposed to tell it about a file relative to the file I'm compiling. If I do runIO getCurrentDirectory, that sure gives me the folder I'm running cabal from, and I don't know how to obtain the path to the currently compiled file
20:40:11 <Ghoul_> So + is a monoid in regards to [1..]?
20:40:28 <jmcarthur> Ghoul_: 0+a=a  a+0=a  a+(b+c)=(a+b)+c
20:40:29 <cmears> Ghoul_, I think you'd need [0..]
20:40:34 <cmears> so you have the identity, zero
20:40:52 <Ghoul_> Oh, hey, that's pretty cool
20:41:01 <jmcarthur> Ghoul_: yeah if you include 0 then the natural numbers with (+) do indeed form a monoid, with 0 being the identity
20:41:21 <Ghoul_> Are those the rules that need to be met;  0+a=a a+0=a a+(b+c)=(a+b)+c
20:41:25 <jmcarthur> Ghoul_: a non-numeric example is string concatenation
20:41:30 <jmcarthur> yup!
20:41:31 <cmears> Ghoul_, that's right
20:41:36 <Cale> nh2: Can't you just specify it relative to the project root?
20:41:50 <Ghoul_> Sweet
20:42:08 <jmcarthur> Ghoul_: so for strings,   ""++a=a  a++""=a  a++(b++c)=(a++b)++c
20:42:55 <jmcarthur> @check \a b c -> (a :: String) ++ (b ++ c) == (a ++ b) ++ c
20:42:57 <lambdabot>   Not in scope: `myquickcheck'
20:42:59 <jmcarthur> bah
20:43:09 <Ghoul_> lol
20:43:23 <nh2> Cale: I can, but that seems like an ugly hack and not like what is intended; from the cabal perspective, there is a project root, but from GHC's probably not
20:43:23 <jmcarthur> well, normally lambdabot would say something like "passed 500 tests" or somesuch
20:44:36 <jmcarthur> Ghoul_: let's turn this up a notch. monads are actually monoids! (it might be a bad idea for me to go down this path)
20:45:02 <Cale> nh2: Well, GHC does have some concept of it. It's the directory you're running GHC from, and module paths already have to agree with file paths from that point in order for GHC to find them.
20:45:36 <Ghoul_> Let's not go there. I don't really understand monads -- I kind of know how to use them though, I think.
20:45:45 <jmcarthur> Ghoul_: return :: Monad m => Id a -> m a   -- Id is just   newtype Id a = Id a...  it's normally not in the signature since it doesn't really do anything
20:45:49 <jmcarthur> Ghoul_: oh i'm about to explain them!
20:46:08 <jmcarthur> Ghoul_: join :: Monad m => m (m a) -> m a
20:46:20 <Cale> inb4 jmcarthur is forced to explain monoidal categories
20:46:20 <jmcarthur> Ghoul_: so if you squint (this will be an informal explanation)...
20:46:34 <jmcarthur> Cale: i'm not really going to explain them precisely
20:46:41 <Ghoul_> .-.
20:46:53 <jmcarthur> Ghoul_: Id ~> m   (we're pretending the a isn't there)
20:47:07 <jmcarthur> Ghoul_: and   (m . m) ~> m  (again, pretending the a isn't there)
20:47:19 <shachaf> The a is there. ~> takes care of it.
20:47:39 <jmcarthur> did i not say i'm intentionally being fuzzy? :P
20:48:02 <Ghoul_> What's the identity of Maybe then.
20:48:07 <jmcarthur> Ghoul_: so return gives you an m from Id and join gives you an m from (m . m)
20:48:15 <Ghoul_> is it Nothing?
20:48:28 <jmcarthur> Ghoul_: return :: Id a -> Maybe a
20:48:31 <jmcarthur> Ghoul_: it would be Just
20:48:42 <jmcarthur> Ghoul_: return (Id x) = Just x
20:49:15 <Ghoul_> So, uh, is x = Just x a valid substitution into the rule
20:49:19 <Ghoul_> or nope.
20:49:27 <jmcarthur> Ghoul_: anyway, the point is that return gives us the standalone m (our identity, by the laws) and join gives us a way to combine two ms (that associative binary operation)
20:50:07 <Cale> Ghoul_: If you want, you can turn the mempty :: m  into a function from a one-element type:  mempty :: () -> m
20:50:20 <jmcarthur> that may be the thing i should have been explicit about
20:50:34 <Cale> Ghoul_: and then you can make  mappend :: m -> m -> m  into  mappend :: (m,m) -> m
20:50:50 <Cale> and then things will look a little more similar
20:51:20 <Ghoul_> Off-hand question but uncurry (m,m) -> m == m -> m -> m
20:51:24 <jmcarthur> Ghoul_: anyway, i know i just volunteered this without you asking, but i think it's an okay way to get a peek of some of the theory behind monads. it's all unnecessary to use them of course
20:51:31 <Cale> :t uncurry
20:51:32 <lambdabot> (a -> b -> c) -> (a, b) -> c
20:51:37 <Ghoul_> oh, yay.
20:51:46 <jmcarthur> :t curry
20:51:47 <lambdabot> ((a, b) -> c) -> a -> b -> c
20:52:50 <Cale> Ghoul_: So the idea is that if you replace () by the identity functor, and m by some chosen functor, and then the product type (,) with functor composition
20:53:28 <Cale> and functions m -> n with natural transformations between functors, which can be realised as polymorphic functions m a -> n a
20:53:37 <Cale> then the definitions are structurally similar
20:53:53 <jmcarthur> mempty :: () -> a   ==>   return :: Id ~> m          mappend :: (a,a) -> a  ==>  join :: (m . m) ~> m
20:53:55 <Cale> and it's possible to make precise exactly the way in which they're similar, in order to look for "monoids" in other settings
20:54:08 <jmcarthur> type f ~> g = forall a. f a -> g a
20:54:54 <Ghoul_> :t mappend
20:54:55 <lambdabot> Monoid a => a -> a -> a
20:55:10 <jmcarthur> :t join
20:55:12 <lambdabot> Monad m => m (m a) -> m a
20:55:20 <otters> :t (join ++)
20:55:22 <lambdabot> (Monad m, Monoid (m a)) => (m (m a) -> m a) -> m (m a) -> m a
20:55:32 <jmcarthur> o_O
20:55:36 <Ghoul_> Ugh, it was all simple
20:55:39 <Ghoul_> and then you had to do THAT
20:55:44 <jmcarthur> that
20:55:49 <jmcarthur> was unnecessary :)
20:55:57 <otters> sorry
20:56:00 <Ghoul_> :P
20:56:16 <elliott> that one is Cale's fault :P
20:56:38 * jmcarthur looks at Cale angrily
20:57:02 <Cale> haha
20:57:30 <Cale> well, it'd be a type error otherwise
20:57:38 <Cale>     Couldn't match expected type `[a0]'
20:57:38 <Cale>                 with actual type `m0 (m0 a1) -> m0 a1'
20:57:48 <Cale> if you didn't have the generalised ++
20:57:48 <jmcarthur> :t ((++) :: [a] -> [a] -> [a]) join
20:57:50 <lambdabot>     Couldn't match expected type `[a0]'
20:57:50 <lambdabot>                 with actual type `m0 (m0 a1) -> m0 a1'
20:57:50 <lambdabot>     In the first argument of `(++) :: [a] -> [a] -> [a]', namely `join'
20:58:13 <otters> :t ((++) ++)
20:58:15 <lambdabot> Monoid m => (m -> m -> m) -> m -> m -> m
20:58:19 <Ghoul_> Certainly makes C feel babyish
20:58:35 <jmcarthur> C has its perks, but high level code is not among them
21:00:01 <jmcarthur> Haskell+C are the only two languages i really feel like i ever need. they compliment each other well. Haskell for most things, C where necessary to interface with existing libs or for very specific performance related things
21:00:19 <jmcarthur> and the FFI makes it really convenient to use them together
21:13:34 <johnw> C has its perks, but most of them are not related to C
21:14:16 <johnw> uh oh, shachaf is going to get on me for C bashing... must stop...
21:14:35 <Eduard_Munteanu> Does he do that? Hm.
21:14:36 <Nisstyre-laptop> johnw: I dislike C too
21:14:45 <Nisstyre-laptop> Forth ftw
21:14:51 <johnw> i just spent too long with C is all
21:14:58 <Eduard_Munteanu> I know you could annoy a few people by saying "C/C++". ;P
21:15:05 <Nisstyre-laptop> haha, yes
21:15:10 <Nisstyre-laptop> that pushes some people's buttons
21:15:30 <johnw> i'm sure a whole lot of people still think that C is a proper subset of C++
21:15:45 <Eduard_Munteanu> I know I get annoyed when people go further and call plain C C++
21:16:09 <immanuelkant> main = do          c <- getChar       if c /= ' '           then do               putChar c               main           else return ()
21:16:13 <immanuelkant> oops
21:16:21 <Eduard_Munteanu> "Hey, what's your code written in?"  "C."  "Cool, C++ is great."  *frown*
21:16:26 <Nisstyre-laptop> johnw: a subset of C is a proper subset of C++ though
21:16:27 <Nisstyre-laptop> right?
21:16:42 <c_wraith> that's not much of a statement
21:16:46 <Nisstyre-laptop> I know :P
21:17:01 <Ghoul_> except restrict
21:17:02 <c_wraith> I mean, it's satisfied by "they have the same semantics for if .. else" :)
21:17:09 <Ghoul_> which was introduced in C99 and isn't valid in cpp.
21:17:21 <c_wraith> Ghoul_: subset was listed on both sides of that
21:17:30 <c_wraith> Ghoul_: making it a true and very weak statement
21:17:37 <nbouscal> isn't it vacuously true? empty set
21:18:37 <Nisstyre-laptop> nbouscal: yes
21:18:59 <immanuelkant> https://gist.github.com/syllogismos/c369ed599615f7b67a7b
21:18:59 <Nisstyre-laptop> it's a truism
21:19:16 <immanuelkant> why does the code shown in the above gist works that way
21:20:41 <immanuelkant> tell me why its reading more than one char, when there is no looping,
21:20:57 <geekosaur> line buffering?
21:21:02 <Eduard_Munteanu> immanuelkant: but there is, you're calling main again
21:21:05 <elliott> immanuelkant: there is a loop.
21:21:05 <immanuelkant> i'm new to haskell, and the explanation given is bufering
21:21:06 <h4199> Why do you think there is no loop?
21:21:09 <elliott> yes, what Eduard_Munteanu said
21:21:26 <Eduard_Munteanu> I was about to say line buffering as well until I saw his question was actually more basic. :)
21:21:32 <Ghoul_> wut, really, thats not raelly the best way to do it
21:21:38 <immanuelkant> yes mine is very basic..
21:21:49 <geekosaur> right, missed that part. how is reinvoking main not looping?
21:21:49 <immanuelkant> my question is very basic
21:22:08 <immanuelkant> so how is it looping/
21:22:11 <immanuelkant> ?
21:22:16 <geekosaur> (although line buffering is why it continues past the ' ')
21:22:24 <geekosaur> again: how is reinvoking main not looping?
21:22:26 <h4199> The call back to main restarts the process
21:22:26 <Eduard_Munteanu> geekosaur: yeah
21:22:37 <geekosaur> what do you think it does?
21:22:39 <h4199> until it hits the ' '
21:22:47 <immanuelkant> The second line is the input. We input hello sir and then press return. Due to buffering, the execution of the program will begin only when after we've hit return and not after every inputted character. But once we press return, it acts on what we've been putting in so far. Try playing with this program to get a feel for it!
21:22:52 <Ghoul_> > let c = "hello sweetie" in [x <- x | (x:xs) <- c, c/= ' ']
21:22:54 <lambdabot>   <hint>:1:31: parse error on input `<-'
21:22:55 <elliott> immanuelkant: are you unfamiliar with the basic idea of recursion?
21:23:03 <elliott> the buffering thing is referring to something other than why it reads multiple charatcers
21:23:11 <Ghoul_> Yeah, cbs, probably better using tail recursion (x:xs) pattern. Idk how I could do that with list comprehension
21:23:12 <immanuelkant> no no i'm familiar with recursion..
21:23:20 <geekosaur> then why is this confusing you?
21:23:25 <64MAC0KKG> i'm pretty sure i just wrote the Arrow equivalent of using runMonad and wrapping stuff in a monad everywhere
21:23:27 <Eduard_Munteanu> immanuelkant: this is recursion :)
21:23:29 <immanuelkant> i understood what Ghoul_
21:23:31 <immanuelkant> said
21:23:43 <Eduard_Munteanu> Oh, I see the problem.
21:24:03 <Eduard_Munteanu> immanuelkant: recursion *is* looping for us
21:24:06 <liyang> copumpkin: why no teaspoonWithHandle? Repo? Can I submit a patch?
21:24:19 <Eduard_Munteanu> You might not call it that way in another language though, if you mean iteration.
21:24:31 <immanuelkant> why is the gist code similar to let c = "hello sweetie" in [x <- x | (x:xs) <- c, c/= ' ']
21:24:50 <geekosaur> there is still the question of what they thought reinvoking main was going to do, if not re-run the code on the next character...
21:24:50 <copumpkin> liyang: you can take over maintainership if you'd like! but please, I keep burning myself on my silver teaspoon, so if you can affix a handle that would be much appreciated
21:25:09 <immanuelkant> why is it reading more than on char
21:25:19 <liyang> copumpkin: is there an existing repo? I don't particularly want to maintain it…
21:25:22 <immanuelkant> main keeps on running till??
21:25:30 <copumpkin> hmm, I don't think we ever made a repo for it :P
21:25:33 <geekosaur> what?
21:25:33 <geekosaur> immanuelkant, what is on line 6?
21:25:37 <geekosaur> what do you think it does?
21:25:44 <liyang> copumpkin: orly… I suppose 2009 was pre-GitHub.
21:25:53 <immanuelkant> omg thank you geekosaur
21:26:03 <copumpkin> I had a github account, but it wasn't very haskell-idiomatic at the time
21:26:12 <copumpkin> mmorrow might have had something on his site in darcs
21:26:19 <copumpkin> but his site went down and took all the good stuff with it
21:26:31 <liyang> copumpkin: You were #1 in my activity when I opened up GitHub.com just then.
21:26:44 <copumpkin> oh?
21:26:57 <copumpkin> what was I up to?
21:26:58 <liyang> Oh, misread. You *had an account in 2009*.
21:27:12 <copumpkin> yeah :)
21:27:19 <liyang> Just then you followed dmwit.
21:27:28 <copumpkin> oh that's pretty exciting news
21:27:31 <copumpkin> aren't you glad you follow me
21:27:51 <liyang> Verily!
21:28:18 <copumpkin> man, I wish my last name were a tld
21:28:28 <liyang> mmorrow doesn't seem to be on GitHub.
21:28:35 <copumpkin> mmorrow is long-gone :(
21:29:10 <nbouscal> immanuelkant: In the second do block you are calling main. So, it reads a character, then it goes to that second do block where it prints it and calls main again, jumping back to the top. Then it reads another character and repeats until it hits the space.
21:29:24 <nbouscal> oh blast it, scrollbar broke and that was irrelevant
21:29:28 <nbouscal> ignore me
21:29:56 <nbouscal> distraction: cool cloth tearing thing: http://codepen.io/stuffit/pen/KrAwx
21:31:38 <nbouscal> the last two letters of my last name are a tld, but it's albania and they seem to be somewhat hostile in their domain registration practices
21:31:45 <immanuelkant> nbouscal: thanks, got it
21:32:52 <wting> @pl \n -> foldl1 (+) [1..n]
21:32:53 <lambdabot> foldl1 (+) . enumFromTo 1
21:33:30 * dmwit looks around vaguely
21:33:35 <dmwit> did somebody say my name?
21:34:01 <copumpkin> nevar
21:34:32 <liyang> dmwit: copumpkin's been stalking you.
21:35:08 <dmwit> I like the sound of that!
21:35:19 <dmwit> It's because I'm such a savvy bitcoin investor, I think.
21:43:10 <lightquake> is anybody in here familiar with netwire? i'm building a game, and i have a collection of 'projectile' wires which should independently evolve, but they can also be spawned by the player or destroyed when they hit something
21:43:20 <lightquake> so i need to dynamically adjust the collection of wires, which i'm not sure how to do
21:46:40 <wting> Is using list comprehension predicates vs filters simply a matter of preference?
21:47:02 <lightquake> wting: yes, but generally most people use filters
21:47:49 <Eduard_Munteanu> Comprehensions could be considered more powerful though.
21:48:50 <wting> I don't know how it gets compiled, but intuitively predicates are more efficient to me since they reduce results at the beginning rather than traversing through a list again.
21:48:59 <wting> Then again that doesn't take lazy evaluation into consideration.
21:49:41 <wting> I guess my question is which is more idiomatic / better performing?
21:49:44 <Eduard_Munteanu> @undo [ x | x <- [1..10], even x ]
21:49:44 <lambdabot> concatMap (\ x -> if even x then [x] else []) [1 .. 10]
21:50:01 <immanuelkant> m
21:50:20 <wting> Oh then it's the same thing.
21:50:36 <wting> Thanks Eduard_Munteanu.
21:51:15 <Eduard_Munteanu> I think filters are your best bet, both ways.
21:51:44 <Eduard_Munteanu> Likely there are a few RULES covering that.
21:52:40 <Eduard_Munteanu> @src filter
21:52:40 <lambdabot> filter _ []     = []
21:52:40 <lambdabot> filter p (x:xs)
21:52:40 <lambdabot>     | p x       = x : filter p xs
21:52:40 <lambdabot>     | otherwise = filter p xs
21:53:12 <wting> I want a personal lambdabot... or I wish its functionality was built-in to GHCi.
21:53:47 <wting> Wish I could look up function definitions from the interpreter. :(
21:53:57 <Eduard_Munteanu> You can install lambdabot through cabal, if you're lucky and it builds for you.
21:54:28 <Eduard_Munteanu> Otherwise, you can get a private session if you /query lambdabot   ;)
21:55:18 <fxr> anyone know how to deal with cabal generated Paths_*.hs with haskell-mode in emacs?
21:55:31 <wting> Ahh ok, thanks. Yeah I tried cabal install quickcheck hoogle pointfree earlier today but it failed to build all 3 for me on Arch. Works fine on Ubuntu 12.04 though (GHC 7.6 vs 7.4).
21:57:07 <wting> lambdabot has brainfuck as a dependency... T_T
21:57:28 <Eduard_Munteanu> It has a brainfuck command.
21:58:49 <sw2wolf> @ty on
21:58:51 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:59:54 <h4199> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
21:59:54 <lambdabot>   Hello World!
22:14:05 <BonSequitur> exit
22:14:14 <BonSequitur> Ack, forgot the slash, pardon me.
22:14:47 <applicative> bon sequitur BonSequitur , sort of
22:16:04 <immanuelkant> how o i exit fromm ghci?
22:16:08 <immanuelkant> do*
22:16:24 <h4199> :quit
22:16:27 <immanuelkant> quit, exit, ctrl+z,x,c not working
22:16:35 <immanuelkant> thanks
22:17:34 <hpaste> applicative pasted “ParallelMonadAsyncComp” at http://hpaste.org/86354
22:18:16 <applicative> tgeeky: ^^ here's a goofy use of MonadComprehensions with an 'async' instance for IO , if you're still around.
22:19:03 <applicative> immanuelkant: :q
22:19:53 <applicative> immanuelkant: :? will show you the commands available. there are distractingly many related to the debugger
22:20:54 <immanuelkant> is tthere a way to get help in ghci of various functions? like in R
22:21:11 <applicative> :t map tells you the type
22:21:13 <lambdabot> parse error on input `type'
22:21:14 <immanuelkant> ?sort
22:21:15 <lambdabot> Maybe you meant: more part src
22:21:18 <applicative> :i whatever gives you a bit more
22:21:32 <applicative> oh sorry, lambdabot is trying to read these as well
22:21:39 <immanuelkant> yeah i know :t
22:22:31 <applicative>   the :info command gives a bit more; you are likely to be disappointed though. I don't know R, but certainly python has a swanker system
22:22:37 <immanuelkant> i have yet to see the functional programming light..
22:23:19 <immanuelkant> it looks like there is a big learning curve..
22:23:20 <applicative> it is not a visible light; it is more like the light of heaven.
22:23:33 <immanuelkant> i know, i want to feel it too :D
22:24:04 <immanuelkant> its like when i first started learning vim.. i didnot see the point of it.. but now i dont even want mouse
22:26:59 <applicative> the 'haddock' documentation for the base libraries is somewhere on your system if you installed ghc in one of the more familiar ways. These (the ones for the base libs) also exhibit the source if you find the place to click.
22:28:11 <applicative> it is well, maybe to have some convenient way of opening what might or might not end with ...share/doc/ghc/html/index.html
22:29:29 <applicative> or just for the libraries something like share/doc/ghc/html/libraries/index.html
22:30:45 <wting> Why does this fail with tuples but works when you change it to a (a,b,c) to [a,b,c]?
22:30:48 <wting>     where
22:30:50 <wting>         p1 = (a + b + c) == n
22:30:52 <wting> pythTrip n = product . head $ [(a,b,c) | a <- [1..n], b <- [1..n], c <- [n-a-b], a^2 + b^2 == c^2]
22:30:55 <wting>         
22:31:00 <fxr> I need to find generated executable for my cabal project in order to blackbox testing. I found that I can import Paths_myproject and use getBinDir in order to locate it. But my tests are running before installation. I tried to make my own Paths_myproject.hs and overwrite getBinDir. But this time cabal uses it and discards it's own generated module. Any ideas_
22:31:15 <immanuelkant> yeah i found the documentation nfiles, still it would e convenient to have something like :help command in ghci
22:31:47 <Hermit> wting: why don't you start checking the type signature of  product ?
22:32:11 <applicative> (a,b,c) doesn't have a head wting , if I understand you
22:32:53 <Hermit> applicative: he gets [(a,b,c)], so what's failing is either head on [], or product on (a,b,c)
22:33:19 <applicative> immanuelkant: yes the point is frequently brought up, but no one has had the strength to do it.... ghci is pretty complicated business
22:33:32 <applicative> Hermit: hm
22:34:05 <h4199> wting: fstT (a,_,_) = a is what you want if you need "head" for triples
22:34:06 <wting> Hermit: Thanks, I was confused because ghci was complaining about head's argument not matching.
22:34:28 <wting> when in reality it's a problem with product operating on tuples.
22:34:48 <applicative> Hermit: yes, of course
22:35:07 <applicative> (a,b,c) dont have a product, except the one they are
22:35:43 <h4199> do you want the product of the a's?
22:38:01 <immanuelkant> length . nub [1,2,2,1,3,4,3]
22:38:10 <applicative> wting: also I think youll have better luck not making the biggest available 'c' smaller than for 'a' and 'b'
22:38:17 <immanuelkant> why is this throwing an error for me
22:38:25 <immanuelkant> you have to import Data.List
22:38:32 <Hermit> immanuelkant: length $ nub [...]
22:38:41 <applicative> > let pythTrip n =  [(a,b,c) | a <- [1..n], b <- [1..n], c <- [n-a-b], a^2 + b^2 == c^2] in pythTrip 44
22:38:43 <lambdabot>   []
22:38:50 <immanuelkant> i know why $ wors
22:39:17 <immanuelkant> when i say length . nub  it means lenght(nub(a))
22:39:26 <Hermit> no, it doesn't
22:39:26 <immanuelkant> but its throwing me an error
22:39:27 <applicative> > let pythTrip n =  [(a,b,c) | a <- [1..n], b <- [1..n], c <- [1..n], a^2 + b^2 == c^2] in pythTrip 13
22:39:28 <lambdabot>   [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(12,5,13)]
22:39:49 <Hermit> immanuelkant: length . nub [...]  /=  length $ nub [...]
22:40:11 <Hermit> immanuelkant: length . nub $ [...]  ==  length $ nub [...]
22:40:33 <applicative> just use parentheses for the moment immanuelkant length (nub "alphabetsoup")
22:40:44 <h4199> > (length . nub) [1,2,2,1,3,4,3]
22:40:46 <lambdabot>   4
22:41:18 <immanuelkant> but why doesnt just length.nub work
22:41:20 <applicative> theres the most styling parentheses
22:41:54 <applicative> @type length . nub
22:41:55 <lambdabot> Eq a => [a] -> Int
22:41:56 <Hermit> immanuelkant: just   length . nub  does work, but you are missing the point that . has lower priority than function application
22:42:17 <Hermit> immanuelkant: so you either add some parens, or use $
22:42:23 <immanuelkant> what is wrong with it.. what is it trying to do..
22:42:26 <immanuelkant> oh okay
22:43:01 <applicative> works fine, just make sure you keep them together, as you dont with  length . nub "cold weather" which composes the length function with the dubious nub "cold weather" function
22:43:56 <applicative> immanuelkant: you can query ghci for operator precedence too :i $
22:43:58 <agoristIntuition> is haskell good for "hacking", or at least superior to ruby, python etc.?
22:44:17 <Hermit> applicative: :i ($)
22:44:21 <johnw> agoristIntuition: yes, Haskell is quite nice for "hacking"
22:44:48 <immanuelkant> sorry im still not able to understand
22:44:48 <applicative> Hermit: weirdly enough it accepts $
22:44:59 <immanuelkant> i did let b = lenght . nub
22:45:04 <immanuelkant> and checed its type
22:45:04 <Hermit> uh.. what?
22:45:06 <applicative> I feel guilty when I type it and the like though....
22:45:08 <agoristIntuition> johnw: superior to ruby python etc in your opinion? what is your experience?
22:45:18 <agoristIntuition> johnw: for hacking*
22:45:21 <Hermit> holly...
22:45:31 <immanuelkant> b :: [()] -> Int
22:46:16 <applicative> but you can't do e.g. :type $
22:46:17 <immanuelkant> i think i need some rest.. get back to it later.. i feel like im missing simple things
22:46:34 <Hermit> immanuelkant: it specialized to list of (), so you must have added something else
22:46:51 <applicative> it sort of makes sense since precedence is a pure feature of the symbol, but it mostly doesn't make sense ....
22:47:27 <h4199> you tried the call length on a (nub [1,2,2,1,3,4,3]) all at once, haskell wasn't sure what you meant, just add parens until you get a feel for it
22:48:19 <immanuelkant> but when you say f . g . h x it means f(g(h(x))) or am i wrong?
22:48:30 <Hermit> you are wrong
22:48:43 <agoristIntuition> is haskell good for "hacking", or at least superior to ruby, python etc.?
22:48:48 <applicative> hlint is very good for learning precedence of the main operators, you write with tons of parens, it tells you what to get rid of, then somehow you get it.
22:48:57 <Hermit> immanuelkant: (f . g . h) x  or  f . g . h $ x   is  f (g (h x))
22:48:59 <immanuelkant> oh, that was my understanding.. i was wrong..
22:49:11 <immanuelkant> okay
22:49:19 <applicative> f(g(h(x)) is f . g. h APPLIED to x
22:49:26 <applicative> f(g(h(x)) is f . g. h $ x
22:50:50 <ab9rf> agoristIntuition: i confess that i do not understand your inquiry
22:51:06 <ab9rf> i find that a machete is good for hacking
22:51:10 <h4199> hacking is a polymorphic word
22:51:45 <immanuelkant> is machete pure?
22:51:47 <Hermit> immanuelkant: now, since you have been insisting on  length . nub [...]  you must have seen that pattern somewhere before, but you missed the types. I could say   length . fst . splitAt 2 $ [1..10]
22:52:14 <immanuelkant> yes i did it tutorial learnyouahaskell
22:52:38 <immanuelkant> but i missed the brackets somehow
22:52:46 <agoristIntuition> ab9rf: h4199 might haskell be a useful tool for compromising some evil servers? is it at least better than ruby and python? or only in some applications? and if so in which "hacking" applications?
22:53:03 <Hermit> brackets? what brackets? this doesn't have a thing to do with the lists brackets
22:53:09 <h4199> oh it is evil servers guy
22:53:14 <immanuelkant> i still have some doubts.. but i will get back to it later..
22:53:41 <immanuelkant> (length.nub) x
22:53:45 <ab9rf> agoristIntuition: in my experience, contracts with satan and goatsblood are more effective than any programming language for that purpose
22:53:52 <h4199> he meant parens
22:54:01 <h4199> ...I think
22:54:31 <Hermit> h4199: if he didn't, then he should definitely come back later
22:54:44 <immanuelkant> sory, lost in translation. i call all of them brackets.. from school days
22:54:47 <mgsloan> @faq Can haskell compromise evil servers?
22:54:47 <lambdabot> The answer is: Yes! Haskell can do that.
22:54:51 <agoristIntuition> ab9rf: I disagree.
22:54:53 <immanuelkant> [ { (
22:54:59 <Hermit> immanuelkant: guess what, HORRIBLE habit
22:55:16 <ab9rf> square bracket, curly bracket, round bracket
22:55:21 <elliott> agoristIntuition: you asked this question under another name yesterday; were the answers insufficient?
22:55:25 <ab9rf> don't forget the pointy brackets, either <
22:55:28 <h4199> ()[]{}〈〉☾☽〚〛⟦⟧⟬⟭⟮⟯⦇⦈⦃⦄⦅⦆, fear them
22:55:36 <Hermit> ...
22:55:42 <ab9rf> aaah, my poor font
22:55:54 <DigitalKiwi> heh
22:56:01 <Eduard_Munteanu> < > should be there too!
22:56:14 <immanuelkant> sorry, perens, square brackets, flower/curly brackets is acceptable?
22:56:15 <agoristIntuition> elliott: ? I think you're mixed up. They're a lot of people trying to put an end to these evil servers.
22:56:21 <h4199> ⟪⟫,<>
22:56:23 <Eduard_Munteanu> Also, bra-kets!
22:56:35 <Hermit> immanuelkant: [] brackets, {} braces, () parens, <> ???
22:56:43 <ab9rf> bruce perens?
22:56:53 <ab9rf> don't get me down, bruce
22:57:05 <elliott> agoristIntuition: fruitFly's ip was 36.37.218.22, yours is 36.37.218.11. I don't believe you :)
22:57:16 <DigitalKiwi> dorm?
22:57:24 <agoristIntuition> anywhoo.. I'd appreciate more beans on the bread guys... please elaborate a little on haskell for hacking. I'd really appreciate the insight.\
22:57:41 <ab9rf> vietnam?
22:57:55 <ab9rf> sorry, cambodia
22:58:01 <ab9rf> in other words, botnet
22:58:13 <tgeeky> ban them all!
22:58:25 <agoristIntuition> ab9rf: yes, they're many of us here trying to stop the evil servers elliott
22:58:27 <DigitalKiwi> i think brainfuck is the most promising hacking language
22:58:33 <immanuelkant> step one: get a phd in cs, step two: throw it away, step three: learn haskell, step 4: profit, step 5: evil servers ded
22:58:37 <ab9rf> DigitalKiwi: malbolge is even better
22:58:42 <agoristIntuition> and on the same subnet too elliott
22:58:49 <elliott> you can understand my scepticism of good faith when you come back under two names in as many days asking about hacking servers.
22:58:52 <simpson> And this is why we should have +r on this channel.
22:58:58 <DigitalKiwi> followed closely by whitespace, pinet (spelling?) and uh hmm...
22:59:07 <DigitalKiwi> lolpython? :P
23:00:09 <agoristIntuition> anyways is lyah a good way to start stopping the evil servers?
23:00:17 <lightquake> this is a pretty great troll
23:00:21 <agoristIntuition> learn yourself a haskell i,.e.
23:00:22 <Heffalump> agoristIntuition: unsafePerformIO is the key to hacking in Haskell
23:00:39 <elliott> i'm pretty sure hacking servers is off-topic for freenode.
23:00:43 <elliott> even if they're evil.
23:00:50 <elliott> so you can stop talking about it.
23:01:31 <lightquake> so i'm building a game, and i have a collection of 'projectile' wires which should independently evolve, but they can also be spawned by the player or destroyed when they hit something. i don't know how to handle this nicely.
23:01:47 <simpson> agoristIntuition: Go bother #python.
23:02:00 <agoristIntuition> simpson: no
23:02:11 <agoristIntuition> do you think lyah is the best place to start?
23:02:16 <immanuelkant> can i ask a general noob question?
23:02:22 <simpson> agoristIntuition: Why, is registering too hard for you? >:3
23:02:23 <Hermit> agoristIntuition: sure, why not
23:02:25 <simpson> immanuelkant: Of course!
23:02:40 <lightquake> do i want to treat each projectile as a wire and build a 'projectile list' wire that uses mkStateM and stateWire internally?
23:02:40 <Hermit> agoristIntuition: check real world haskell too
23:02:45 <Cale> immanuelkant: ask lots of questions :)
23:02:49 <immanuelkant> why are monods, functors, applicators not there in imperative languages
23:03:01 <agoristIntuition> Hermit: alright, thanks
23:03:07 <immanuelkant> like why am i comin across these only in functional programming
23:03:24 <DigitalKiwi> ab9rf: you win, malbolge is indeed more useful at being not useful than brainfuck
23:03:26 <Cale> immanuelkant: It's not so much about the imperative/functional split (though that's part of it, one of the parameters to >>= is itself a function)
23:03:28 <Hermit> agoristIntuition: also, check the source code of haskell's printf for some true hackery
23:03:30 <elliott> well, they're all pretty "funtcional" concepts in some ways.
23:03:38 <elliott> in that higher-order functions are pretty core to using them.
23:03:45 <Cale> immanuelkant: It's more about the kinds of polymorphism that these languages support
23:03:46 <agoristIntuition> And guys if you will, many months ago I dived into haskell but got as far as monads I think, could you simply explain what it is?
23:03:51 <elliott> but it's also just that the abstraction mechanisms provided by most imperative langauges don't match up with providing such abstractions.
23:04:02 <agoristIntuition> Hermit: Thanks real dawg OG
23:04:40 <Cale> immanuelkant: Haskell has this nice feature called type classes, which among other things, allows functions to be polymorphic, not just in the type of their parameters, but also in the type of their result, with the implementation chosen depending on which type of result is inferred
23:04:45 <elliott> and it's also a community thing. a lot of imperative languages were designed by people who probably never even heard of monads, because they had no connection to category theory.
23:05:30 <tgeeky> agoristIntuition: it's an abstract way way of sequencing effectful computation with properties that make proof and understanding about it reasonable.
23:05:31 <Cale> immanuelkant: If you look at the type of return :: (Monad m) => a -> m a, its result is polymorphic in the choice of m, in a way which can't be determined from the argument, which isn't something that most OO languages can do easily.
23:05:59 <agoristIntuition> tgeeky: thankks, that makes some sense
23:06:07 <tgeeky> agoristIntuition: it could also be false, I hope someone agrees
23:06:08 <simpson> agoristIntuition: It's like a burrito.
23:06:14 <Hermit> agoristIntuition: monads are black tecnology, they can't be explained in common terms. You'll have to work your way through lyah and rwh until you get to monads, or you won't have the base to understand them
23:06:19 <simpson> agoristIntuition: There's some stuff inside, and it's spicy.
23:06:56 <agoristIntuition> simpson: that also makes sense.. thanks
23:07:01 <mgsloan> and if you have a burrito inside your burrito, it might as well just be one burrito
23:07:18 * tgeeky looks up agorist to see if he's going to regret this conversation, but is happily supprised
23:07:34 <Hermit> simpson: even if he seems like a troll, don't mislead him. Learning haskell comming from the imperative world is a brutal cognitive wall already
23:07:44 <Cale> immanuelkant: does that kind of answer your question?
23:07:53 <simpson> Hermit: I take it that you didn't see the conversation with him yesterday.
23:07:55 <immanuelkant> there was this tutorial where they explained what monods functors are in a way noobs like me understand.. http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
23:08:03 <Hermit> simpson: right, I didn't
23:08:07 <Hermit> simpson: what's with it?
23:08:10 <immanuelkant> im not a troll
23:08:21 <Hermit> immanuelkant: I meant agoristIntuition
23:08:28 <immanuelkant> yeah, im trying to understand what you are saying..
23:08:38 <tgeeky> mgsloan: no, no, no! You have magic thin burritos which have the property that no matter how many you layer on top of one another, they will always fuse to keep the burrito height to 1 burrito height
23:09:03 <simpson> Hermit: He has been asking about how to crack and do black hat stuff. He's mostly here because this is the only large programming channel that isn't +r, so he doesn't have to register.
23:09:19 <immanuelkant> it makes sense, i learned what they are.. atleast i think i learned, but i dont know why they are used..
23:09:31 <Hermit> simpson: a script kiddie I guess
23:09:32 <mgsloan> tgeeky: Nice!  Wait till chipotle finds out about this.  After that it's on to coburritos
23:10:09 <Hermit> simpson: oh well, no need to be harsh, just let the compiler bite his ass for a while ;-)
23:10:47 <immanuelkant> kind of like when i was first introduced to matrices, why would i ever want matric data structure, and its transpose.. but now it makes sense after learning what they are used for
23:11:00 <tgeeky> immanuelkant: no, it's not anything like that.
23:11:10 <Cale> This article you linked is kind of... rough
23:11:16 <tgeeky> immanuelkant: a good rule in life: You can never, ever, ever, learn enough linear algebra.
23:11:21 <immanuelkant> so that tutorial is too dumbed down its wrong?
23:11:27 <tgeeky> That is a very deep and complex thing. Monads are a *very* simple thing.
23:11:33 <Cale> It's not completely wrong
23:12:02 <Cale> but... it abuses terminology a bit, and I'm not sure it'd convey the right things unless you already knew what it wanted to convey
23:12:42 <immanuelkant> exactly, i wish someone can do it in a way people like me could understand,
23:13:17 <tgeeky> immanuelkant: if I may, you are wasting your time thinking about your inability to understand them; for you could be playing with them and learning them.
23:14:04 <lightquake> for me it was useless to try to understand monads by reading tutorials
23:14:07 <lightquake> i just wrote a lot of haskell
23:14:15 <Cale> immanuelkant: So, monads are an abstraction of something which occurs fairly often in libraries written in functional languages.
23:14:19 <tgeeky> I'd bet a good many of us confess to being not the brightest bulbs in the box, but everyone here has gotten used to them in one way or another.
23:14:30 <mgsloan> Yeah, maybe that's the ultimate irony of the surplus of monad tutorials: it implies you need to read about them to use them / get them
23:14:55 <immanuelkant> so i just use them?
23:14:57 <Cale> immanuelkant: The way that we generally try to structure our libraries is that we'll often have some representation of "computations" of a particular sort that we want to be able to talk about.
23:15:27 <Hermit> immanuelkant: yep, you should. You'll develop your own very personal way of thinking about them soon enough
23:15:33 <Cale> immanuelkant: Like for instance, parsers, or drawings, or prettyprinters, or binary serialisers
23:15:36 <immanuelkant> i just started, so trying to learn form the past two days..
23:15:49 <wting> Is there a way to add multiple values per iteration in a list comprehension? Or do I need to add a list and then flatten? e.g. Is something like this possible? [x, y | x <-- [1..3], y <-- [4..6]]
23:16:09 <Cale> immanuelkant: and our library will define a bunch of primitive computations of the given type that we're interested in
23:16:18 <Hermit> immanuelkant: it took me 3 days to _get_ them
23:16:22 <Cale> immanuelkant: and then a way to glue those together into more complex ones
23:16:41 <Cale> Or, a bunch of ways, typically
23:16:44 <Hermit> and it's not that they were complex, it's just that they were too different from everything else
23:16:51 <mgsloan> >  [(x, y) | x <-- [1..3], y <-- [4..6]]
23:16:52 <lambdabot>   Not in scope: `<--'
23:16:53 <lambdabot>  Perhaps you meant one of these:
23:16:53 <lambdabot>    `<-=' (imported fro...
23:16:58 <lightquake> <-, not <--
23:17:01 <immanuelkant> i can see why functional language is superior without monads etc..
23:17:02 <mgsloan> >  [(x, y) | x <- [1..3], y <- [4..6]]
23:17:03 <Cale> immanuelkant: In that fashion, libraries start to look like miniature programming languages
23:17:03 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
23:17:04 <elliott> fruitFly: oh, please...
23:17:14 <immanuelkant> but i still have to understand what monads are
23:17:17 <mgsloan> lightquake: yeah, I was copy pasting from wting to show how close he was!
23:17:22 <Cale> immanuelkant: If you'll listen, I'm getting to it
23:17:22 <mgsloan> didn't see the -- heh
23:17:28 <tgeeky> immanuelkant: another way to think about now -not- complex they are: if you were to write down the laws which ordinary arithmetic you do in your head are, you would need many bullet points to list them, but you only need a handful for monads
23:17:34 <immanuelkant> im reading all of it
23:17:45 <immanuelkant> Cale:  please continue
23:18:27 <h4199> wting: did that answer your question?
23:18:42 <Cale> immanuelkant: Certain libraries written in this style will define a type (M t) for computations producing a result of type t. This M data type will somehow represent all the things that such a computation could do or mean. It might itself internally involve function types, or it might involve syntax trees of some fashion.
23:18:54 <wting> mgsloan: h4199: Sorry, that wasn't what I was looking for because I still need to unpack the tuple.
23:19:11 <h4199> into what?
23:19:32 <wting> into a flat list
23:19:52 <Cale> It'll also probably define a bunch of specific primitives that aren't part of the monad structure, and which make the library useful -- the fact that this is or isn't a monad doesn't really tell us much. What it does tell us is that we (initially) have two things:
23:20:02 <Hermit> wting: add  (\(a,b,c) -> [a,b,c]) between product and head
23:20:13 <fruitFly> I'm interested in crypto and want to learn a powerful programming language to supplement it and just my general interest in programming? What about agda, idris or ocaml? Or do you think haskell pretty much does it all and is the king of applicability?
23:20:25 --- mode: ChanServ set +o elliott
23:20:29 <tgeeky> Hermit: assuming they have the same type?
23:20:30 <Cale> return :: a -> M a   is a function which will take a value, and produce the computation which "does nothing" and produces that value as its result
23:20:36 <mgsloan> wting: ohh, yeah, you'll need to use concat
23:20:37 <h4199> >concat  [[x + y] | x <- [1..3], y <- [4..6]]
23:20:38 <wting> Instead of [(1,4),(1,5)] I want [1,4,1,5]. Right now I'm using concat [[x,y] | x <- [1..3], y <- [4..6]].
23:20:41 <Hermit> tgeeky: right
23:20:43 <Cale> What is means to "do nothing" in context will depend on what M is.
23:20:50 --- mode: elliott set +b *!*2425da0b@*.36.37.218.11
23:20:50 --- kick: fruitFly was kicked by elliott (timewasting from multiple nicks)
23:21:00 <Hermit> tgeeky: they had the same type iirc, the code involved some list comprehension
23:21:01 * sw2wolf at first glimpse of monad, i regard it as interface same as in Java and use it. Although i donot understand it very well, i still can use it to program ...
23:21:04 <h4199> err
23:21:13 <Cale> For example, if M is a type of parsers, return v might be the parser which always succeeds without eating any of its input string, and which produces the result v.
23:21:14 --- mode: elliott set -o elliott
23:21:28 <h4199> > concat [[x,y] | x <- [1..3], y <- [4..6]]
23:21:29 <lambdabot>   [1,4,1,5,1,6,2,4,2,5,2,6,3,4,3,5,3,6]
23:21:56 <wting> Hermit: Why wouldn't I just use a list to begin with instead of converting from tuple to list? i.e. why not [[a,b,c] | etc]?
23:22:03 <h4199> too late :(
23:22:06 <Rileld> Hi all, I'm trying to install yesod, but cabal runs into a conflict. Could anyone help me out? http://hpaste.org/86355
23:22:19 <Hermit> wting: that's right, why wouldn't you?
23:22:21 <Cale> Secondly, it means that we have a function (>>=) :: M a -> (a -> M b) -> M b, which, given an initial computation to perform having a result of type a, and a function from values of type a to further computations to perform,
23:22:38 <Hermit> wting: I was just answering your "how to convert the tuple to a flat list" question
23:22:55 <Hermit> wting: given your earlier code, that is...
23:23:01 <wting> Hermit: Oh I thought you were answering my previous question.
23:23:14 <Cale> glues these together in whatever way makes sense in context, into a computation which "runs" the first one, then applies the function and "runs" its result as well, producing the result of this computation as its result.
23:23:14 <Hermit> wting: sorry, missed it, care to repeat it?
23:23:19 <wting> Hermit: No, working on a different, irrelevant problem now. :p
23:23:51 <wting> Hermit: Oh I was just wondering if I could append multiple values within a list comprehension without having to use concat.
23:24:10 <wting> append multiple values in a single step*
23:24:30 <Cale> immanuelkant: So, for example, if M is a parsing monad, then x >>= f will be a parser which first runs the parser x on the initial part of the input, parsing out some value v, say, and then it runs the parser (f v) on the remainder of the input, producing the result of that second parse
23:25:36 <immanuelkant> Cale: im reading please continue
23:25:42 <Cale> immanuelkant: This is a bit of a mouthful perhaps, but it's often exactly the sort of combination of computations that you want -- where the computation to perform next can depend on the result of the computation which just finished.
23:25:47 <Hermit> wting: well, either lists monad or lists comprehension both involve concat. If you want to avoid concat entirely you'd be better served consing to the end of a DList and passing the list as an argument..
23:26:54 <Cale> immanuelkant: and so we define a monad to be a type constructor M which has a return :: a -> M a, and (>>=) :: M a -> (a -> M b) -> M b which satisfy certain laws which follow from the intuition about what these things mean that I've implied in my description of them above.
23:27:34 <Cale> immanuelkant: So, it's just an interface -- a little API fragment which might occur in many different libraries for many different choices of M, return and >>=
23:27:52 <Hermit> wting: on second thought, forget the DList, just do a plain recursion using normal lists
23:27:54 <Cale> immanuelkant: But in terms of these things, we can write a lot of handy functions which will work with any monad.
23:28:09 <wting> Hermit: k, thx
23:28:17 <supki> Rileld: what ghc version?
23:28:35 <Cale> immanuelkant: For example,  sequence :: (Monad m) => [m a] -> m [a]   is something which takes a list of computations in some monad, and produces a computation which runs each of them in turn and collects a list of the results.
23:28:56 <Cale> immanuelkant: In a parsing monad, this would be the concatenation of a bunch of parsers
23:29:13 <Rileld> supki: Version 7.0.4, for Haskell 98, stage 2 booted by GHC version 7.0.4
23:29:18 <Hermit> wting: however, the DList way would be easier to implement, using plain foldl
23:29:47 <Cale> immanuelkant: In the list monad, "running" a list means to pick one element from it in all possible ways, and so sequence takes a list of lists, and picks one element from each of them in all possible ways, returning the list of ways that can be done
23:29:47 <supki> Rileld: you should upgrade to 7.4 I think
23:29:54 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
23:29:56 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
23:30:42 <Cale> immanuelkant: In the IO monad, sequence takes a list of IO actions, and produces an action which when executed will perform each of them in turn and collect a list of the results,
23:30:43 <supki> Rileld: basically it says your installed containers package version is too old, and containers are bundled with ghc
23:31:06 <Cale> so  sequence [getLine, getLine, getLine]  will get three lines of text from the user, and produce a list of the resulting strings.
23:31:22 <Cale> getLine :: IO String, and IO is another monad
23:32:07 <Rileld> supki: I got this version from the standard Fedora 17 repos. If I download and build the latest source from the haskell platform website, would you expect that to work?
23:32:31 <Cale> immanuelkant: and so the whole point is that there are a bunch of libraries which happen to be able to define a monad, and then a whole bunch of useful things like this sequence which work in any monad, and probably do something useful in context.
23:33:55 <Cale> immanuelkant: and the same goes for Functor, Applicative, and Arrow, and Comonad, and many others
23:34:00 <immanuelkant> Things are kind of making sense, thank you Cale, I will read up on it more..
23:34:18 <Cale> immanuelkant: The best way to understand this stuff is just by learning a bunch of examples of it
23:34:25 <Cale> immanuelkant: and worry about the general pattern later
23:34:49 <supki> Rileld: yeah, I expect yesod to work with latest platform
23:34:56 <Cale> immanuelkant: e.g. actually learn to use IO in Haskell, without worrying about the fact that it's a monad
23:34:59 <immanuelkant> okay.. im finding learnyouahaskell fairly comprehensive and clear..
23:35:11 <Cale> immanuelkant: and maybe a parsing library like Parsec
23:35:23 <immanuelkant> okay,
23:35:45 <immanuelkant> are there any well known machine learning haskell libraries?
23:36:01 <Cale> and maybe some others, like the list monad, which is pretty simple to define, but can be quite useful
23:37:01 <Cale> immanuelkant: I know that k-means clustering has been implemented a bunch to provide a nice example for various sorts of parallelism
23:37:34 <Cale> and yeah, there do appear to be some libraries on hackage with a bunch of stuff I don't know much about
23:37:41 <Cale> http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=machine+learning
23:38:51 <Cale> http://hackage.haskell.org/package/HasGP looks useful
23:41:00 <Cale> immanuelkant: There's also a bunch of packages HLearn-* which look like they have a fair amount of content
23:42:27 <immanuelkant> i will try toimplement svm in haskell, and hit two birds with one stone :D maybe in two weeks
23:43:17 <Cale> http://hackage.haskell.org/packages/archive/svm/1.0.0.1/doc/html/SVM.html
23:44:42 <immanuelkant> i know there are lot of packages, just to get familiar with both svm implementation and haskell.. i will use them as reference
23:45:00 <Cale> yeah :)
23:46:23 <immanuelkant> Cale thanks for your help :)
23:49:40 <Cale> no problem!
